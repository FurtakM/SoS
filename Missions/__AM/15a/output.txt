// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 22616 0 0
// InitNature ;
  19: CALL 19282 0 0
// InitArtifact ;
  23: CALL 19899 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5112 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 7095 0 0
// PrepareRussian ;
  52: CALL 9318 0 0
// PrepareLegion ;
  56: CALL 7592 0 0
// Action ;
  60: CALL 12245 0 0
// MC_Start ( ) ;
  64: CALL 24796 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 102
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 103
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 46513 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 47592 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 47685 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 107
 353: PUSH
 354: LD_EXP 107
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 46850 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 47035 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 47592 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 47685 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 46850 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 47035 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 47465 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 46513 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 47592 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 47685 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 107
 843: PUSH
 844: LD_EXP 107
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 46850 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 47035 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 47592 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 47685 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 48003 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 47797 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 46850 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 47035 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 47416 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// SetInvulnrability ( alien , true ) ;
1443: LD_INT 1
1445: PPUSH
1446: LD_INT 1
1448: PPUSH
1449: CALL_OW 607
// uc_side := 7 ;
1453: LD_ADDR_OWVAR 20
1457: PUSH
1458: LD_INT 7
1460: ST_TO_ADDR
// tmp := [ ] ;
1461: LD_ADDR_VAR 0 5
1465: PUSH
1466: EMPTY
1467: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1468: LD_ADDR_EXP 19
1472: PUSH
1473: LD_STRING JMM
1475: PPUSH
1476: LD_EXP 1
1480: NOT
1481: PPUSH
1482: LD_STRING 14a_
1484: PPUSH
1485: CALL 53324 0 3
1489: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1490: LD_ADDR_EXP 52
1494: PUSH
1495: LD_STRING Burlak
1497: PPUSH
1498: LD_EXP 1
1502: NOT
1503: PPUSH
1504: LD_STRING 14a_
1506: PPUSH
1507: CALL 53324 0 3
1511: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1512: LD_ADDR_EXP 34
1516: PUSH
1517: LD_STRING Joan
1519: PPUSH
1520: LD_EXP 1
1524: NOT
1525: PPUSH
1526: LD_STRING 13a_
1528: PPUSH
1529: CALL 53324 0 3
1533: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1534: LD_ADDR_EXP 20
1538: PUSH
1539: LD_STRING Roth
1541: PPUSH
1542: LD_EXP 1
1546: NOT
1547: PPUSH
1548: LD_STRING 13a_
1550: PPUSH
1551: CALL 53324 0 3
1555: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1556: LD_ADDR_EXP 38
1560: PUSH
1561: LD_STRING Gossudarov
1563: PPUSH
1564: LD_EXP 1
1568: NOT
1569: PPUSH
1570: LD_STRING 13a_
1572: PPUSH
1573: CALL 53324 0 3
1577: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1578: LD_ADDR_EXP 25
1582: PUSH
1583: LD_STRING Denis
1585: PPUSH
1586: LD_EXP 1
1590: NOT
1591: PPUSH
1592: LD_STRING 13a_
1594: PPUSH
1595: CALL 53324 0 3
1599: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1600: LD_ADDR_EXP 35
1604: PUSH
1605: LD_STRING DeltaDoctor
1607: PPUSH
1608: LD_EXP 1
1612: NOT
1613: PPUSH
1614: LD_STRING 13a_
1616: PPUSH
1617: CALL 53324 0 3
1621: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1622: LD_ADDR_EXP 37
1626: PUSH
1627: LD_STRING Mike
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 13a_
1638: PPUSH
1639: CALL 53324 0 3
1643: ST_TO_ADDR
// if DeltaDoctor then
1644: LD_EXP 35
1648: IFFALSE 1666
// tmp := tmp ^ DeltaDoctor ;
1650: LD_ADDR_VAR 0 5
1654: PUSH
1655: LD_VAR 0 5
1659: PUSH
1660: LD_EXP 35
1664: ADD
1665: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1666: LD_ADDR_EXP 33
1670: PUSH
1671: LD_STRING Simms
1673: PPUSH
1674: LD_EXP 1
1678: NOT
1679: PPUSH
1680: LD_STRING 13a_
1682: PPUSH
1683: CALL 53324 0 3
1687: ST_TO_ADDR
// if Simms then
1688: LD_EXP 33
1692: IFFALSE 1710
// tmp := tmp ^ Simms ;
1694: LD_ADDR_VAR 0 5
1698: PUSH
1699: LD_VAR 0 5
1703: PUSH
1704: LD_EXP 33
1708: ADD
1709: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1710: LD_ADDR_EXP 31
1714: PUSH
1715: LD_STRING Frank
1717: PPUSH
1718: LD_EXP 1
1722: NOT
1723: PPUSH
1724: LD_STRING 13a_
1726: PPUSH
1727: CALL 53324 0 3
1731: ST_TO_ADDR
// if Frank then
1732: LD_EXP 31
1736: IFFALSE 1754
// tmp := tmp ^ Frank ;
1738: LD_ADDR_VAR 0 5
1742: PUSH
1743: LD_VAR 0 5
1747: PUSH
1748: LD_EXP 31
1752: ADD
1753: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1754: LD_ADDR_EXP 39
1758: PUSH
1759: LD_STRING Kirilenkova
1761: PPUSH
1762: LD_EXP 1
1766: NOT
1767: PPUSH
1768: LD_STRING 13a_
1770: PPUSH
1771: CALL 53324 0 3
1775: ST_TO_ADDR
// if Kirilenkova then
1776: LD_EXP 39
1780: IFFALSE 1798
// tmp := tmp ^ Kirilenkova ;
1782: LD_ADDR_VAR 0 5
1786: PUSH
1787: LD_VAR 0 5
1791: PUSH
1792: LD_EXP 39
1796: ADD
1797: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1798: LD_ADDR_EXP 40
1802: PUSH
1803: LD_STRING Titov
1805: PPUSH
1806: LD_EXP 1
1810: NOT
1811: PPUSH
1812: LD_STRING 13a_
1814: PPUSH
1815: CALL 53324 0 3
1819: ST_TO_ADDR
// if Titov then
1820: LD_EXP 40
1824: IFFALSE 1842
// tmp := tmp ^ Titov ;
1826: LD_ADDR_VAR 0 5
1830: PUSH
1831: LD_VAR 0 5
1835: PUSH
1836: LD_EXP 40
1840: ADD
1841: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1842: LD_ADDR_EXP 41
1846: PUSH
1847: LD_STRING Fadeev
1849: PPUSH
1850: LD_EXP 1
1854: NOT
1855: PPUSH
1856: LD_STRING 13a_
1858: PPUSH
1859: CALL 53324 0 3
1863: ST_TO_ADDR
// if Fadeev then
1864: LD_EXP 41
1868: IFFALSE 1886
// tmp := tmp ^ Fadeev ;
1870: LD_ADDR_VAR 0 5
1874: PUSH
1875: LD_VAR 0 5
1879: PUSH
1880: LD_EXP 41
1884: ADD
1885: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1886: LD_ADDR_EXP 42
1890: PUSH
1891: LD_STRING Dolgov
1893: PPUSH
1894: LD_EXP 1
1898: NOT
1899: PPUSH
1900: LD_STRING 13a_
1902: PPUSH
1903: CALL 53324 0 3
1907: ST_TO_ADDR
// if Dolgov then
1908: LD_EXP 42
1912: IFFALSE 1930
// tmp := tmp ^ Dolgov ;
1914: LD_ADDR_VAR 0 5
1918: PUSH
1919: LD_VAR 0 5
1923: PUSH
1924: LD_EXP 42
1928: ADD
1929: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1930: LD_ADDR_EXP 43
1934: PUSH
1935: LD_STRING Petrosyan
1937: PPUSH
1938: LD_EXP 1
1942: NOT
1943: PPUSH
1944: LD_STRING 13a_
1946: PPUSH
1947: CALL 53324 0 3
1951: ST_TO_ADDR
// if Petrosyan then
1952: LD_EXP 43
1956: IFFALSE 1974
// tmp := tmp ^ Petrosyan ;
1958: LD_ADDR_VAR 0 5
1962: PUSH
1963: LD_VAR 0 5
1967: PUSH
1968: LD_EXP 43
1972: ADD
1973: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1974: LD_ADDR_EXP 44
1978: PUSH
1979: LD_STRING Scholtze
1981: PPUSH
1982: LD_EXP 1
1986: NOT
1987: PPUSH
1988: LD_STRING 13a_
1990: PPUSH
1991: CALL 53324 0 3
1995: ST_TO_ADDR
// if Scholtze then
1996: LD_EXP 44
2000: IFFALSE 2018
// tmp := tmp ^ Scholtze ;
2002: LD_ADDR_VAR 0 5
2006: PUSH
2007: LD_VAR 0 5
2011: PUSH
2012: LD_EXP 44
2016: ADD
2017: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2018: LD_ADDR_EXP 45
2022: PUSH
2023: LD_STRING Oblukov
2025: PPUSH
2026: LD_EXP 1
2030: NOT
2031: PPUSH
2032: LD_STRING 13a_
2034: PPUSH
2035: CALL 53324 0 3
2039: ST_TO_ADDR
// if Oblukov then
2040: LD_EXP 45
2044: IFFALSE 2062
// tmp := tmp ^ Oblukov ;
2046: LD_ADDR_VAR 0 5
2050: PUSH
2051: LD_VAR 0 5
2055: PUSH
2056: LD_EXP 45
2060: ADD
2061: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2062: LD_ADDR_EXP 46
2066: PUSH
2067: LD_STRING Kapitsova
2069: PPUSH
2070: LD_EXP 1
2074: NOT
2075: PPUSH
2076: LD_STRING 13a_
2078: PPUSH
2079: CALL 53324 0 3
2083: ST_TO_ADDR
// if Kapitsova then
2084: LD_EXP 46
2088: IFFALSE 2106
// tmp := tmp ^ Kapitsova ;
2090: LD_ADDR_VAR 0 5
2094: PUSH
2095: LD_VAR 0 5
2099: PUSH
2100: LD_EXP 46
2104: ADD
2105: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2106: LD_ADDR_EXP 47
2110: PUSH
2111: LD_STRING Lipshchin
2113: PPUSH
2114: LD_EXP 1
2118: NOT
2119: PPUSH
2120: LD_STRING 13a_
2122: PPUSH
2123: CALL 53324 0 3
2127: ST_TO_ADDR
// if Lipshchin then
2128: LD_EXP 47
2132: IFFALSE 2150
// tmp := tmp ^ Lipshchin ;
2134: LD_ADDR_VAR 0 5
2138: PUSH
2139: LD_VAR 0 5
2143: PUSH
2144: LD_EXP 47
2148: ADD
2149: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2150: LD_ADDR_EXP 48
2154: PUSH
2155: LD_STRING Petrovova
2157: PPUSH
2158: LD_EXP 1
2162: NOT
2163: PPUSH
2164: LD_STRING 13a_
2166: PPUSH
2167: CALL 53324 0 3
2171: ST_TO_ADDR
// if Petrovova then
2172: LD_EXP 48
2176: IFFALSE 2194
// tmp := tmp ^ Petrovova ;
2178: LD_ADDR_VAR 0 5
2182: PUSH
2183: LD_VAR 0 5
2187: PUSH
2188: LD_EXP 48
2192: ADD
2193: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2194: LD_ADDR_EXP 49
2198: PUSH
2199: LD_STRING Kovalyuk
2201: PPUSH
2202: LD_EXP 1
2206: NOT
2207: PPUSH
2208: LD_STRING 13a_
2210: PPUSH
2211: CALL 53324 0 3
2215: ST_TO_ADDR
// if Kovalyuk then
2216: LD_EXP 49
2220: IFFALSE 2238
// tmp := tmp ^ Kovalyuk ;
2222: LD_ADDR_VAR 0 5
2226: PUSH
2227: LD_VAR 0 5
2231: PUSH
2232: LD_EXP 49
2236: ADD
2237: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2238: LD_ADDR_EXP 50
2242: PUSH
2243: LD_STRING Kuzmov
2245: PPUSH
2246: LD_EXP 1
2250: NOT
2251: PPUSH
2252: LD_STRING 13a_
2254: PPUSH
2255: CALL 53324 0 3
2259: ST_TO_ADDR
// if Kuzmov then
2260: LD_EXP 50
2264: IFFALSE 2282
// tmp := tmp ^ Kuzmov ;
2266: LD_ADDR_VAR 0 5
2270: PUSH
2271: LD_VAR 0 5
2275: PUSH
2276: LD_EXP 50
2280: ADD
2281: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2282: LD_ADDR_EXP 51
2286: PUSH
2287: LD_STRING Karamazov
2289: PPUSH
2290: LD_EXP 1
2294: NOT
2295: PPUSH
2296: LD_STRING 13a_
2298: PPUSH
2299: CALL 53324 0 3
2303: ST_TO_ADDR
// if Karamazov then
2304: LD_EXP 51
2308: IFFALSE 2326
// tmp := tmp ^ Karamazov ;
2310: LD_ADDR_VAR 0 5
2314: PUSH
2315: LD_VAR 0 5
2319: PUSH
2320: LD_EXP 51
2324: ADD
2325: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2326: LD_ADDR_EXP 53
2330: PUSH
2331: LD_STRING Belkov
2333: PPUSH
2334: LD_EXP 1
2338: NOT
2339: PPUSH
2340: LD_STRING 13a_
2342: PPUSH
2343: CALL 53324 0 3
2347: ST_TO_ADDR
// if Belkov then
2348: LD_EXP 53
2352: IFFALSE 2370
// tmp := tmp ^ Belkov ;
2354: LD_ADDR_VAR 0 5
2358: PUSH
2359: LD_VAR 0 5
2363: PUSH
2364: LD_EXP 53
2368: ADD
2369: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2370: LD_ADDR_EXP 54
2374: PUSH
2375: LD_STRING Gnyevko
2377: PPUSH
2378: LD_EXP 1
2382: NOT
2383: PPUSH
2384: LD_STRING 13a_
2386: PPUSH
2387: CALL 53324 0 3
2391: ST_TO_ADDR
// if Gnyevko then
2392: LD_EXP 54
2396: IFFALSE 2414
// tmp := tmp ^ Gnyevko ;
2398: LD_ADDR_VAR 0 5
2402: PUSH
2403: LD_VAR 0 5
2407: PUSH
2408: LD_EXP 54
2412: ADD
2413: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2414: LD_ADDR_EXP 36
2418: PUSH
2419: LD_STRING Coonie
2421: PPUSH
2422: CALL_OW 25
2426: ST_TO_ADDR
// if not Lisa then
2427: LD_EXP 21
2431: NOT
2432: IFFALSE 2478
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2434: LD_ADDR_EXP 21
2438: PUSH
2439: LD_STRING Lisa
2441: PPUSH
2442: LD_EXP 1
2446: NOT
2447: PPUSH
2448: LD_STRING 13a_
2450: PPUSH
2451: CALL 53324 0 3
2455: ST_TO_ADDR
// if Lisa then
2456: LD_EXP 21
2460: IFFALSE 2478
// tmp := tmp ^ Lisa ;
2462: LD_ADDR_VAR 0 5
2466: PUSH
2467: LD_VAR 0 5
2471: PUSH
2472: LD_EXP 21
2476: ADD
2477: ST_TO_ADDR
// end ; if not Donaldson then
2478: LD_EXP 22
2482: NOT
2483: IFFALSE 2529
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2485: LD_ADDR_EXP 22
2489: PUSH
2490: LD_STRING Donaldson
2492: PPUSH
2493: LD_EXP 1
2497: NOT
2498: PPUSH
2499: LD_STRING 13a_
2501: PPUSH
2502: CALL 53324 0 3
2506: ST_TO_ADDR
// if Donaldson then
2507: LD_EXP 22
2511: IFFALSE 2529
// tmp := tmp ^ Donaldson ;
2513: LD_ADDR_VAR 0 5
2517: PUSH
2518: LD_VAR 0 5
2522: PUSH
2523: LD_EXP 22
2527: ADD
2528: ST_TO_ADDR
// end ; if not Bobby then
2529: LD_EXP 23
2533: NOT
2534: IFFALSE 2580
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2536: LD_ADDR_EXP 23
2540: PUSH
2541: LD_STRING Bobby
2543: PPUSH
2544: LD_EXP 1
2548: NOT
2549: PPUSH
2550: LD_STRING 13a_
2552: PPUSH
2553: CALL 53324 0 3
2557: ST_TO_ADDR
// if Bobby then
2558: LD_EXP 23
2562: IFFALSE 2580
// tmp := tmp ^ Bobby ;
2564: LD_ADDR_VAR 0 5
2568: PUSH
2569: LD_VAR 0 5
2573: PUSH
2574: LD_EXP 23
2578: ADD
2579: ST_TO_ADDR
// end ; if not Cyrus then
2580: LD_EXP 24
2584: NOT
2585: IFFALSE 2631
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2587: LD_ADDR_EXP 24
2591: PUSH
2592: LD_STRING Cyrus
2594: PPUSH
2595: LD_EXP 1
2599: NOT
2600: PPUSH
2601: LD_STRING 13a_
2603: PPUSH
2604: CALL 53324 0 3
2608: ST_TO_ADDR
// if Cyrus then
2609: LD_EXP 24
2613: IFFALSE 2631
// tmp := tmp ^ Cyrus ;
2615: LD_ADDR_VAR 0 5
2619: PUSH
2620: LD_VAR 0 5
2624: PUSH
2625: LD_EXP 24
2629: ADD
2630: ST_TO_ADDR
// end ; if not Brown then
2631: LD_EXP 26
2635: NOT
2636: IFFALSE 2682
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2638: LD_ADDR_EXP 26
2642: PUSH
2643: LD_STRING Brown
2645: PPUSH
2646: LD_EXP 1
2650: NOT
2651: PPUSH
2652: LD_STRING 13a_
2654: PPUSH
2655: CALL 53324 0 3
2659: ST_TO_ADDR
// if Brown then
2660: LD_EXP 26
2664: IFFALSE 2682
// tmp := tmp ^ Brown ;
2666: LD_ADDR_VAR 0 5
2670: PUSH
2671: LD_VAR 0 5
2675: PUSH
2676: LD_EXP 26
2680: ADD
2681: ST_TO_ADDR
// end ; if not Gladstone then
2682: LD_EXP 27
2686: NOT
2687: IFFALSE 2733
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2689: LD_ADDR_EXP 27
2693: PUSH
2694: LD_STRING Gladstone
2696: PPUSH
2697: LD_EXP 1
2701: NOT
2702: PPUSH
2703: LD_STRING 13a_
2705: PPUSH
2706: CALL 53324 0 3
2710: ST_TO_ADDR
// if Gladstone then
2711: LD_EXP 27
2715: IFFALSE 2733
// tmp := tmp ^ Gladstone ;
2717: LD_ADDR_VAR 0 5
2721: PUSH
2722: LD_VAR 0 5
2726: PUSH
2727: LD_EXP 27
2731: ADD
2732: ST_TO_ADDR
// end ; if not Cornel then
2733: LD_EXP 29
2737: NOT
2738: IFFALSE 2784
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2740: LD_ADDR_EXP 29
2744: PUSH
2745: LD_STRING Cornel
2747: PPUSH
2748: LD_EXP 1
2752: NOT
2753: PPUSH
2754: LD_STRING 13a_
2756: PPUSH
2757: CALL 53324 0 3
2761: ST_TO_ADDR
// if Cornel then
2762: LD_EXP 29
2766: IFFALSE 2784
// tmp := tmp ^ Cornel ;
2768: LD_ADDR_VAR 0 5
2772: PUSH
2773: LD_VAR 0 5
2777: PUSH
2778: LD_EXP 29
2782: ADD
2783: ST_TO_ADDR
// end ; if not Houten then
2784: LD_EXP 28
2788: NOT
2789: IFFALSE 2835
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2791: LD_ADDR_EXP 28
2795: PUSH
2796: LD_STRING Houten
2798: PPUSH
2799: LD_EXP 1
2803: NOT
2804: PPUSH
2805: LD_STRING 13a_
2807: PPUSH
2808: CALL 53324 0 3
2812: ST_TO_ADDR
// if Houten then
2813: LD_EXP 28
2817: IFFALSE 2835
// tmp := tmp ^ Houten ;
2819: LD_ADDR_VAR 0 5
2823: PUSH
2824: LD_VAR 0 5
2828: PUSH
2829: LD_EXP 28
2833: ADD
2834: ST_TO_ADDR
// end ; if not Gary then
2835: LD_EXP 30
2839: NOT
2840: IFFALSE 2886
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2842: LD_ADDR_EXP 30
2846: PUSH
2847: LD_STRING Gary
2849: PPUSH
2850: LD_EXP 1
2854: NOT
2855: PPUSH
2856: LD_STRING 13a_
2858: PPUSH
2859: CALL 53324 0 3
2863: ST_TO_ADDR
// if Gary then
2864: LD_EXP 30
2868: IFFALSE 2886
// tmp := tmp ^ Gary ;
2870: LD_ADDR_VAR 0 5
2874: PUSH
2875: LD_VAR 0 5
2879: PUSH
2880: LD_EXP 30
2884: ADD
2885: ST_TO_ADDR
// end ; if not Kikuchi then
2886: LD_EXP 32
2890: NOT
2891: IFFALSE 2937
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2893: LD_ADDR_EXP 32
2897: PUSH
2898: LD_STRING Kikuchi
2900: PPUSH
2901: LD_EXP 1
2905: NOT
2906: PPUSH
2907: LD_STRING 13a_
2909: PPUSH
2910: CALL 53324 0 3
2914: ST_TO_ADDR
// if Kikuchi then
2915: LD_EXP 32
2919: IFFALSE 2937
// tmp := tmp ^ Kikuchi ;
2921: LD_ADDR_VAR 0 5
2925: PUSH
2926: LD_VAR 0 5
2930: PUSH
2931: LD_EXP 32
2935: ADD
2936: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2937: LD_ADDR_VAR 0 5
2941: PUSH
2942: LD_VAR 0 5
2946: PUSH
2947: LD_STRING 13a_others
2949: PPUSH
2950: CALL_OW 31
2954: UNION
2955: ST_TO_ADDR
// tmp := tmp diff 0 ;
2956: LD_ADDR_VAR 0 5
2960: PUSH
2961: LD_VAR 0 5
2965: PUSH
2966: LD_INT 0
2968: DIFF
2969: ST_TO_ADDR
// if tmp < 15 then
2970: LD_VAR 0 5
2974: PUSH
2975: LD_INT 15
2977: LESS
2978: IFFALSE 3066
// for i = 15 downto tmp do
2980: LD_ADDR_VAR 0 2
2984: PUSH
2985: DOUBLE
2986: LD_INT 15
2988: INC
2989: ST_TO_ADDR
2990: LD_VAR 0 5
2994: PUSH
2995: FOR_DOWNTO
2996: IFFALSE 3064
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2998: LD_ADDR_OWVAR 21
3002: PUSH
3003: LD_INT 1
3005: PUSH
3006: LD_INT 3
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: PUSH
3013: LD_INT 1
3015: PPUSH
3016: LD_INT 2
3018: PPUSH
3019: CALL_OW 12
3023: ARRAY
3024: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3025: LD_INT 0
3027: PPUSH
3028: LD_INT 1
3030: PPUSH
3031: LD_INT 4
3033: PPUSH
3034: CALL_OW 12
3038: PPUSH
3039: LD_INT 8
3041: PPUSH
3042: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3046: LD_ADDR_VAR 0 5
3050: PUSH
3051: LD_VAR 0 5
3055: PUSH
3056: CALL_OW 44
3060: ADD
3061: ST_TO_ADDR
// end ;
3062: GO 2995
3064: POP
3065: POP
// if not debug then
3066: LD_EXP 1
3070: NOT
3071: IFFALSE 3251
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3073: LD_ADDR_VAR 0 4
3077: PUSH
3078: LD_STRING 
3080: PPUSH
3081: LD_INT 14
3083: PUSH
3084: LD_INT 13
3086: PUSH
3087: LD_INT 12
3089: PUSH
3090: LD_INT 11
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_OWVAR 67
3103: ARRAY
3104: PPUSH
3105: LD_INT 14
3107: PUSH
3108: LD_INT 13
3110: PUSH
3111: LD_INT 12
3113: PUSH
3114: LD_INT 11
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_OWVAR 67
3127: ARRAY
3128: PPUSH
3129: LD_INT -5
3131: PUSH
3132: LD_EXP 19
3136: PUSH
3137: LD_EXP 52
3141: PUSH
3142: LD_EXP 20
3146: PUSH
3147: LD_EXP 34
3151: PUSH
3152: LD_EXP 25
3156: PUSH
3157: LD_EXP 38
3161: PUSH
3162: LD_INT -2
3164: PUSH
3165: LD_INT -3
3167: PUSH
3168: LD_INT -5
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: PUSH
3183: LD_VAR 0 5
3187: ADD
3188: PPUSH
3189: LD_INT 1
3191: PUSH
3192: LD_INT 4
3194: PUSH
3195: LD_INT 2
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: EMPTY
3202: LIST
3203: LIST
3204: PUSH
3205: LD_INT 3
3207: PUSH
3208: LD_INT 5
3210: PUSH
3211: LD_INT 0
3213: PUSH
3214: LD_INT 3
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: PUSH
3222: LD_INT 9
3224: PUSH
3225: LD_INT 0
3227: PUSH
3228: LD_INT 3
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: LIST
3242: LIST
3243: PPUSH
3244: CALL_OW 42
3248: ST_TO_ADDR
3249: GO 3300
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3251: LD_ADDR_VAR 0 4
3255: PUSH
3256: LD_EXP 40
3260: PUSH
3261: LD_EXP 41
3265: PUSH
3266: LD_EXP 42
3270: PUSH
3271: LD_EXP 43
3275: PUSH
3276: LD_EXP 44
3280: PUSH
3281: LD_EXP 45
3285: PUSH
3286: LD_EXP 46
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: LIST
3298: LIST
3299: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3300: LD_ADDR_EXP 17
3304: PUSH
3305: LD_VAR 0 5
3309: PUSH
3310: LD_VAR 0 4
3314: DIFF
3315: ST_TO_ADDR
// uc_nation := 1 ;
3316: LD_ADDR_OWVAR 21
3320: PUSH
3321: LD_INT 1
3323: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3324: LD_INT 5
3326: PPUSH
3327: LD_INT 3
3329: PPUSH
3330: LD_INT 1
3332: PPUSH
3333: LD_INT 6
3335: PPUSH
3336: LD_INT 100
3338: PPUSH
3339: CALL 58164 0 5
// veh := CreateVehicle ;
3343: LD_ADDR_VAR 0 3
3347: PUSH
3348: CALL_OW 45
3352: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3353: LD_VAR 0 3
3357: PPUSH
3358: LD_INT 7
3360: NEG
3361: PPUSH
3362: CALL_OW 242
// SetDir ( veh , 3 ) ;
3366: LD_VAR 0 3
3370: PPUSH
3371: LD_INT 3
3373: PPUSH
3374: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3378: LD_VAR 0 3
3382: PPUSH
3383: LD_INT 31
3385: PPUSH
3386: LD_INT 0
3388: PPUSH
3389: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3393: LD_EXP 19
3397: PPUSH
3398: LD_VAR 0 3
3402: PPUSH
3403: CALL_OW 52
// if Joan then
3407: LD_EXP 34
3411: IFFALSE 3483
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 3
3418: PPUSH
3419: LD_INT 1
3421: PPUSH
3422: LD_INT 11
3424: PPUSH
3425: LD_INT 100
3427: PPUSH
3428: CALL 58164 0 5
// veh := CreateVehicle ;
3432: LD_ADDR_VAR 0 3
3436: PUSH
3437: CALL_OW 45
3441: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3442: LD_VAR 0 3
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3454: LD_VAR 0 3
3458: PPUSH
3459: LD_INT 30
3461: PPUSH
3462: LD_INT 0
3464: PPUSH
3465: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3469: LD_EXP 34
3473: PPUSH
3474: LD_VAR 0 3
3478: PPUSH
3479: CALL_OW 52
// end ; if Roth then
3483: LD_EXP 20
3487: IFFALSE 3559
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3489: LD_INT 3
3491: PPUSH
3492: LD_INT 3
3494: PPUSH
3495: LD_INT 1
3497: PPUSH
3498: LD_INT 11
3500: PPUSH
3501: LD_INT 100
3503: PPUSH
3504: CALL 58164 0 5
// veh := CreateVehicle ;
3508: LD_ADDR_VAR 0 3
3512: PUSH
3513: CALL_OW 45
3517: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3518: LD_VAR 0 3
3522: PPUSH
3523: LD_INT 3
3525: PPUSH
3526: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3530: LD_VAR 0 3
3534: PPUSH
3535: LD_INT 30
3537: PPUSH
3538: LD_INT 0
3540: PPUSH
3541: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3545: LD_EXP 20
3549: PPUSH
3550: LD_VAR 0 3
3554: PPUSH
3555: CALL_OW 52
// end ; if Denis then
3559: LD_EXP 25
3563: IFFALSE 3635
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3565: LD_INT 5
3567: PPUSH
3568: LD_INT 3
3570: PPUSH
3571: LD_INT 1
3573: PPUSH
3574: LD_INT 9
3576: PPUSH
3577: LD_INT 100
3579: PPUSH
3580: CALL 58164 0 5
// veh := CreateVehicle ;
3584: LD_ADDR_VAR 0 3
3588: PUSH
3589: CALL_OW 45
3593: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3594: LD_VAR 0 3
3598: PPUSH
3599: LD_INT 3
3601: PPUSH
3602: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3606: LD_VAR 0 3
3610: PPUSH
3611: LD_INT 30
3613: PPUSH
3614: LD_INT 0
3616: PPUSH
3617: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3621: LD_EXP 25
3625: PPUSH
3626: LD_VAR 0 3
3630: PPUSH
3631: CALL_OW 52
// end ; uc_nation := 3 ;
3635: LD_ADDR_OWVAR 21
3639: PUSH
3640: LD_INT 3
3642: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3643: LD_INT 22
3645: PPUSH
3646: LD_INT 3
3648: PPUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 45
3654: PPUSH
3655: LD_INT 100
3657: PPUSH
3658: CALL 58164 0 5
// veh := CreateVehicle ;
3662: LD_ADDR_VAR 0 3
3666: PUSH
3667: CALL_OW 45
3671: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3672: LD_VAR 0 3
3676: PPUSH
3677: LD_INT 7
3679: NEG
3680: PPUSH
3681: CALL_OW 242
// SetDir ( veh , 3 ) ;
3685: LD_VAR 0 3
3689: PPUSH
3690: LD_INT 3
3692: PPUSH
3693: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3697: LD_VAR 0 3
3701: PPUSH
3702: LD_INT 31
3704: PPUSH
3705: LD_INT 0
3707: PPUSH
3708: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3712: LD_EXP 52
3716: PPUSH
3717: LD_VAR 0 3
3721: PPUSH
3722: CALL_OW 52
// if Gossudarov then
3726: LD_EXP 38
3730: IFFALSE 3817
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3732: LD_INT 22
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 1
3740: PPUSH
3741: LD_INT 51
3743: PPUSH
3744: LD_INT 100
3746: PPUSH
3747: CALL 58164 0 5
// veh := CreateVehicle ;
3751: LD_ADDR_VAR 0 3
3755: PUSH
3756: CALL_OW 45
3760: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 3
3768: PPUSH
3769: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3773: LD_VAR 0 3
3777: PPUSH
3778: LD_INT 30
3780: PPUSH
3781: LD_INT 0
3783: PPUSH
3784: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3788: LD_EXP 38
3792: PPUSH
3793: LD_VAR 0 3
3797: PPUSH
3798: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3802: LD_VAR 0 3
3806: PPUSH
3807: LD_INT 1
3809: PPUSH
3810: LD_INT 100
3812: PPUSH
3813: CALL_OW 290
// end ; if Mike then
3817: LD_EXP 37
3821: IFFALSE 3838
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3823: LD_EXP 37
3827: PPUSH
3828: LD_INT 30
3830: PPUSH
3831: LD_INT 0
3833: PPUSH
3834: CALL_OW 49
// for i in selected do
3838: LD_ADDR_VAR 0 2
3842: PUSH
3843: LD_VAR 0 4
3847: PUSH
3848: FOR_IN
3849: IFFALSE 4407
// begin uc_nation := GetNation ( i ) ;
3851: LD_ADDR_OWVAR 21
3855: PUSH
3856: LD_VAR 0 2
3860: PPUSH
3861: CALL_OW 248
3865: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3866: LD_VAR 0 2
3870: PUSH
3871: LD_EXP 21
3875: PUSH
3876: LD_EXP 22
3880: PUSH
3881: LD_EXP 24
3885: PUSH
3886: LD_EXP 23
3890: PUSH
3891: EMPTY
3892: LIST
3893: LIST
3894: LIST
3895: LIST
3896: IN
3897: IFFALSE 3920
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 3
3904: PPUSH
3905: LD_INT 1
3907: PPUSH
3908: LD_INT 6
3910: PPUSH
3911: LD_INT 100
3913: PPUSH
3914: CALL 58164 0 5
3918: GO 4354
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3920: LD_VAR 0 2
3924: PUSH
3925: LD_EXP 45
3929: PUSH
3930: LD_EXP 50
3934: PUSH
3935: LD_EXP 48
3939: PUSH
3940: LD_EXP 40
3944: PUSH
3945: EMPTY
3946: LIST
3947: LIST
3948: LIST
3949: LIST
3950: IN
3951: IFFALSE 3982
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3953: LD_INT 24
3955: PPUSH
3956: LD_INT 1
3958: PPUSH
3959: LD_INT 1
3961: PPUSH
3962: LD_INT 46
3964: PPUSH
3965: LD_INT 65
3967: PPUSH
3968: LD_INT 75
3970: PPUSH
3971: CALL_OW 12
3975: PPUSH
3976: CALL 58164 0 5
3980: GO 4354
// if i = Karamazov then
3982: LD_VAR 0 2
3986: PUSH
3987: LD_EXP 51
3991: EQUAL
3992: IFFALSE 4015
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3994: LD_INT 22
3996: PPUSH
3997: LD_INT 3
3999: PPUSH
4000: LD_INT 1
4002: PPUSH
4003: LD_INT 52
4005: PPUSH
4006: LD_INT 100
4008: PPUSH
4009: CALL 58164 0 5
4013: GO 4354
// if i = Brown then
4015: LD_VAR 0 2
4019: PUSH
4020: LD_EXP 26
4024: EQUAL
4025: IFFALSE 4048
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4027: LD_INT 3
4029: PPUSH
4030: LD_INT 3
4032: PPUSH
4033: LD_INT 1
4035: PPUSH
4036: LD_INT 13
4038: PPUSH
4039: LD_INT 100
4041: PPUSH
4042: CALL 58164 0 5
4046: GO 4354
// if uc_nation = nation_american then
4048: LD_OWVAR 21
4052: PUSH
4053: LD_INT 1
4055: EQUAL
4056: IFFALSE 4207
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4058: LD_INT 3
4060: PUSH
4061: LD_INT 5
4063: PUSH
4064: LD_INT 5
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: LIST
4071: PUSH
4072: LD_OWVAR 21
4076: PUSH
4077: LD_INT 3
4079: MOD
4080: PUSH
4081: LD_INT 1
4083: PLUS
4084: ARRAY
4085: PPUSH
4086: LD_INT 1
4088: PUSH
4089: LD_INT 3
4091: PUSH
4092: LD_INT 1
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: PUSH
4100: LD_OWVAR 21
4104: PUSH
4105: LD_INT 3
4107: MOD
4108: PUSH
4109: LD_INT 1
4111: PLUS
4112: ARRAY
4113: PPUSH
4114: LD_INT 1
4116: PPUSH
4117: LD_INT 11
4119: PUSH
4120: LD_INT 4
4122: PUSH
4123: LD_INT 5
4125: PUSH
4126: EMPTY
4127: LIST
4128: LIST
4129: LIST
4130: PUSH
4131: LD_INT 6
4133: PUSH
4134: LD_INT 7
4136: PUSH
4137: LD_INT 9
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: LIST
4144: PUSH
4145: LD_INT 6
4147: PUSH
4148: LD_INT 9
4150: PUSH
4151: LD_INT 12
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: EMPTY
4160: LIST
4161: LIST
4162: LIST
4163: PUSH
4164: LD_OWVAR 21
4168: PUSH
4169: LD_INT 3
4171: MOD
4172: PUSH
4173: LD_INT 1
4175: PLUS
4176: ARRAY
4177: PUSH
4178: LD_INT 1
4180: PPUSH
4181: LD_INT 3
4183: PPUSH
4184: CALL_OW 12
4188: ARRAY
4189: PPUSH
4190: LD_INT 65
4192: PPUSH
4193: LD_INT 75
4195: PPUSH
4196: CALL_OW 12
4200: PPUSH
4201: CALL 58164 0 5
// end else
4205: GO 4354
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4207: LD_INT 22
4209: PUSH
4210: LD_INT 23
4212: PUSH
4213: LD_INT 23
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: LIST
4220: PUSH
4221: LD_OWVAR 21
4225: PUSH
4226: LD_INT 3
4228: MOD
4229: PUSH
4230: LD_INT 1
4232: PLUS
4233: ARRAY
4234: PPUSH
4235: LD_INT 1
4237: PUSH
4238: LD_INT 3
4240: PUSH
4241: LD_INT 1
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: PUSH
4249: LD_OWVAR 21
4253: PUSH
4254: LD_INT 3
4256: MOD
4257: PUSH
4258: LD_INT 1
4260: PLUS
4261: ARRAY
4262: PPUSH
4263: LD_INT 1
4265: PPUSH
4266: LD_INT 45
4268: PUSH
4269: LD_INT 43
4271: PUSH
4272: LD_INT 44
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: LIST
4279: PUSH
4280: LD_INT 46
4282: PUSH
4283: LD_INT 45
4285: PUSH
4286: LD_INT 44
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: LIST
4293: PUSH
4294: LD_INT 46
4296: PUSH
4297: LD_INT 43
4299: PUSH
4300: LD_INT 45
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: LIST
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: LIST
4312: PUSH
4313: LD_OWVAR 21
4317: PUSH
4318: LD_INT 3
4320: MOD
4321: PUSH
4322: LD_INT 1
4324: PLUS
4325: ARRAY
4326: PUSH
4327: LD_INT 1
4329: PPUSH
4330: LD_INT 3
4332: PPUSH
4333: CALL_OW 12
4337: ARRAY
4338: PPUSH
4339: LD_INT 65
4341: PPUSH
4342: LD_INT 75
4344: PPUSH
4345: CALL_OW 12
4349: PPUSH
4350: CALL 58164 0 5
// end ; veh := CreateVehicle ;
4354: LD_ADDR_VAR 0 3
4358: PUSH
4359: CALL_OW 45
4363: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4364: LD_VAR 0 3
4368: PPUSH
4369: LD_INT 3
4371: PPUSH
4372: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4376: LD_VAR 0 3
4380: PPUSH
4381: LD_INT 30
4383: PPUSH
4384: LD_INT 0
4386: PPUSH
4387: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4391: LD_VAR 0 2
4395: PPUSH
4396: LD_VAR 0 3
4400: PPUSH
4401: CALL_OW 52
// end ;
4405: GO 3848
4407: POP
4408: POP
// if artifactArCaptured then
4409: LD_EXP 9
4413: IFFALSE 4499
// begin uc_nation := nation_american ;
4415: LD_ADDR_OWVAR 21
4419: PUSH
4420: LD_INT 1
4422: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4423: LD_INT 3
4425: PPUSH
4426: LD_INT 3
4428: PPUSH
4429: LD_INT 3
4431: PPUSH
4432: LD_INT 12
4434: PPUSH
4435: LD_INT 100
4437: PPUSH
4438: CALL 58164 0 5
// veh := CreateVehicle ;
4442: LD_ADDR_VAR 0 3
4446: PUSH
4447: CALL_OW 45
4451: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4452: LD_VAR 0 3
4456: PPUSH
4457: LD_INT 3
4459: PPUSH
4460: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4464: LD_VAR 0 3
4468: PPUSH
4469: LD_INT 198
4471: PPUSH
4472: LD_INT 22
4474: PPUSH
4475: LD_INT 0
4477: PPUSH
4478: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4482: LD_VAR 0 3
4486: PPUSH
4487: LD_INT 4
4489: PPUSH
4490: LD_INT 50
4492: PPUSH
4493: CALL_OW 290
// end else
4497: GO 4518
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4499: LD_INT 4
4501: PPUSH
4502: LD_INT 5
4504: PPUSH
4505: LD_INT 267
4507: PPUSH
4508: LD_INT 226
4510: PPUSH
4511: LD_INT 0
4513: PPUSH
4514: CALL_OW 58
// end ; uc_nation := nation_american ;
4518: LD_ADDR_OWVAR 21
4522: PUSH
4523: LD_INT 1
4525: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4526: LD_INT 3
4528: PPUSH
4529: LD_INT 3
4531: PPUSH
4532: LD_INT 3
4534: PPUSH
4535: LD_INT 12
4537: PPUSH
4538: LD_INT 100
4540: PPUSH
4541: CALL 58164 0 5
// veh := CreateVehicle ;
4545: LD_ADDR_VAR 0 3
4549: PUSH
4550: CALL_OW 45
4554: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4555: LD_VAR 0 3
4559: PPUSH
4560: LD_INT 3
4562: PPUSH
4563: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4567: LD_VAR 0 3
4571: PPUSH
4572: LD_INT 218
4574: PPUSH
4575: LD_INT 23
4577: PPUSH
4578: LD_INT 0
4580: PPUSH
4581: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4585: LD_VAR 0 3
4589: PPUSH
4590: LD_INT 4
4592: PPUSH
4593: LD_INT 30
4595: PPUSH
4596: CALL_OW 290
// uc_nation := nation_russian ;
4600: LD_ADDR_OWVAR 21
4604: PUSH
4605: LD_INT 3
4607: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4608: LD_INT 22
4610: PPUSH
4611: LD_INT 3
4613: PPUSH
4614: LD_INT 3
4616: PPUSH
4617: LD_INT 51
4619: PPUSH
4620: LD_INT 100
4622: PPUSH
4623: CALL 58164 0 5
// veh := CreateVehicle ;
4627: LD_ADDR_VAR 0 3
4631: PUSH
4632: CALL_OW 45
4636: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4637: LD_VAR 0 3
4641: PPUSH
4642: LD_INT 3
4644: PPUSH
4645: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4649: LD_VAR 0 3
4653: PPUSH
4654: LD_INT 214
4656: PPUSH
4657: LD_INT 20
4659: PPUSH
4660: LD_INT 0
4662: PPUSH
4663: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4667: LD_VAR 0 3
4671: PPUSH
4672: LD_INT 4
4674: PPUSH
4675: LD_INT 40
4677: PPUSH
4678: CALL_OW 290
// end ;
4682: LD_VAR 0 1
4686: RET
// export function AllianceSupport ; var i , veh ; begin
4687: LD_INT 0
4689: PPUSH
4690: PPUSH
4691: PPUSH
// if not allianceTeam then
4692: LD_EXP 17
4696: NOT
4697: IFFALSE 4701
// exit ;
4699: GO 5107
// for i := 1 to 6 do
4701: LD_ADDR_VAR 0 2
4705: PUSH
4706: DOUBLE
4707: LD_INT 1
4709: DEC
4710: ST_TO_ADDR
4711: LD_INT 6
4713: PUSH
4714: FOR_TO
4715: IFFALSE 5011
// begin uc_side := 7 ;
4717: LD_ADDR_OWVAR 20
4721: PUSH
4722: LD_INT 7
4724: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4725: LD_ADDR_OWVAR 21
4729: PUSH
4730: LD_INT 1
4732: PUSH
4733: LD_INT 3
4735: PUSH
4736: EMPTY
4737: LIST
4738: LIST
4739: PUSH
4740: LD_VAR 0 2
4744: PUSH
4745: LD_INT 2
4747: MOD
4748: PUSH
4749: LD_INT 1
4751: PLUS
4752: ARRAY
4753: ST_TO_ADDR
// if uc_nation = 1 then
4754: LD_OWVAR 21
4758: PUSH
4759: LD_INT 1
4761: EQUAL
4762: IFFALSE 4804
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4764: LD_INT 5
4766: PPUSH
4767: LD_INT 3
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 6
4775: PUSH
4776: LD_INT 7
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 2
4788: PPUSH
4789: CALL_OW 12
4793: ARRAY
4794: PPUSH
4795: LD_INT 100
4797: PPUSH
4798: CALL 58164 0 5
4802: GO 4842
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4804: LD_INT 23
4806: PPUSH
4807: LD_INT 3
4809: PPUSH
4810: LD_INT 1
4812: PPUSH
4813: LD_INT 46
4815: PUSH
4816: LD_INT 47
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 1
4825: PPUSH
4826: LD_INT 2
4828: PPUSH
4829: CALL_OW 12
4833: ARRAY
4834: PPUSH
4835: LD_INT 100
4837: PPUSH
4838: CALL 58164 0 5
// if not allianceTeam then
4842: LD_EXP 17
4846: NOT
4847: IFFALSE 4851
// break ;
4849: GO 5011
// veh := CreateVehicle ;
4851: LD_ADDR_VAR 0 3
4855: PUSH
4856: CALL_OW 45
4860: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4861: LD_VAR 0 3
4865: PPUSH
4866: LD_INT 4
4868: PPUSH
4869: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4873: LD_VAR 0 3
4877: PPUSH
4878: LD_INT 38
4880: PPUSH
4881: LD_INT 0
4883: PPUSH
4884: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4888: LD_EXP 17
4892: PUSH
4893: LD_INT 1
4895: ARRAY
4896: PPUSH
4897: LD_INT 3
4899: PPUSH
4900: CALL_OW 259
4904: PUSH
4905: LD_INT 4
4907: GREATER
4908: IFFALSE 4926
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4910: LD_EXP 17
4914: PUSH
4915: LD_INT 1
4917: ARRAY
4918: PPUSH
4919: LD_INT 3
4921: PPUSH
4922: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4926: LD_EXP 17
4930: PUSH
4931: LD_INT 1
4933: ARRAY
4934: PPUSH
4935: LD_INT 4
4937: PPUSH
4938: CALL_OW 259
4942: PUSH
4943: LD_INT 8
4945: GREATER
4946: IFFALSE 4964
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4948: LD_EXP 17
4952: PUSH
4953: LD_INT 1
4955: ARRAY
4956: PPUSH
4957: LD_INT 4
4959: PPUSH
4960: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4964: LD_EXP 17
4968: PUSH
4969: LD_INT 1
4971: ARRAY
4972: PPUSH
4973: LD_VAR 0 3
4977: PPUSH
4978: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4982: LD_ADDR_EXP 17
4986: PUSH
4987: LD_EXP 17
4991: PPUSH
4992: LD_INT 1
4994: PPUSH
4995: CALL_OW 3
4999: ST_TO_ADDR
// ComHold ( veh ) ;
5000: LD_VAR 0 3
5004: PPUSH
5005: CALL_OW 140
// end ;
5009: GO 4714
5011: POP
5012: POP
// uc_side := 7 ;
5013: LD_ADDR_OWVAR 20
5017: PUSH
5018: LD_INT 7
5020: ST_TO_ADDR
// uc_nation := 1 ;
5021: LD_ADDR_OWVAR 21
5025: PUSH
5026: LD_INT 1
5028: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5029: LD_INT 5
5031: PPUSH
5032: LD_INT 3
5034: PPUSH
5035: LD_INT 3
5037: PPUSH
5038: LD_INT 11
5040: PPUSH
5041: LD_INT 100
5043: PPUSH
5044: CALL 58164 0 5
// veh := CreateVehicle ;
5048: LD_ADDR_VAR 0 3
5052: PUSH
5053: CALL_OW 45
5057: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5058: LD_VAR 0 3
5062: PPUSH
5063: LD_INT 4
5065: PPUSH
5066: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5070: LD_VAR 0 3
5074: PPUSH
5075: LD_INT 305
5077: PPUSH
5078: LD_INT 218
5080: PPUSH
5081: LD_INT 0
5083: PPUSH
5084: CALL_OW 48
// ComHold ( veh ) ;
5088: LD_VAR 0 3
5092: PPUSH
5093: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5097: LD_INT 313
5099: PPUSH
5100: LD_INT 220
5102: PPUSH
5103: CALL_OW 86
// end ; end_of_file
5107: LD_VAR 0 1
5111: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5112: LD_INT 0
5114: PPUSH
5115: PPUSH
5116: PPUSH
5117: PPUSH
5118: PPUSH
5119: PPUSH
5120: PPUSH
5121: PPUSH
5122: PPUSH
5123: PPUSH
5124: PPUSH
// InitHc ;
5125: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5129: LD_INT 387
5131: PPUSH
5132: LD_STRING sigma
5134: PPUSH
5135: CALL_OW 500
// uc_side := 1 ;
5139: LD_ADDR_OWVAR 20
5143: PUSH
5144: LD_INT 1
5146: ST_TO_ADDR
// uc_nation := 1 ;
5147: LD_ADDR_OWVAR 21
5151: PUSH
5152: LD_INT 1
5154: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5155: LD_ADDR_VAR 0 2
5159: PUSH
5160: LD_INT 22
5162: PUSH
5163: LD_INT 1
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: LD_INT 21
5172: PUSH
5173: LD_INT 3
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PUSH
5180: EMPTY
5181: LIST
5182: LIST
5183: PPUSH
5184: CALL_OW 69
5188: PUSH
5189: FOR_IN
5190: IFFALSE 5206
// SetBLevel ( i , 10 ) ;
5192: LD_VAR 0 2
5196: PPUSH
5197: LD_INT 10
5199: PPUSH
5200: CALL_OW 241
5204: GO 5189
5206: POP
5207: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5208: LD_INT 387
5210: PPUSH
5211: CALL_OW 274
5215: PPUSH
5216: LD_INT 1
5218: PPUSH
5219: LD_INT 7500
5221: PPUSH
5222: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5226: LD_INT 387
5228: PPUSH
5229: CALL_OW 274
5233: PPUSH
5234: LD_INT 2
5236: PPUSH
5237: LD_INT 4000
5239: PPUSH
5240: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5244: LD_INT 387
5246: PPUSH
5247: CALL_OW 274
5251: PPUSH
5252: LD_INT 3
5254: PPUSH
5255: LD_INT 50
5257: PPUSH
5258: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5262: LD_INT 476
5264: PPUSH
5265: CALL_OW 274
5269: PPUSH
5270: LD_INT 1
5272: PPUSH
5273: LD_INT 5500
5275: PPUSH
5276: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5280: LD_INT 476
5282: PPUSH
5283: CALL_OW 274
5287: PPUSH
5288: LD_INT 2
5290: PPUSH
5291: LD_INT 4000
5293: PPUSH
5294: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5298: LD_INT 476
5300: PPUSH
5301: CALL_OW 274
5305: PPUSH
5306: LD_INT 3
5308: PPUSH
5309: LD_INT 10
5311: PPUSH
5312: CALL_OW 277
// if LoadVariable ( 12a_PowellKilled , false ) then
5316: LD_STRING 12a_PowellKilled
5318: PPUSH
5319: LD_INT 0
5321: PPUSH
5322: CALL_OW 30
5326: IFFALSE 5353
// begin PrepareHuman ( sex_male , class_soldier , 10 ) ;
5328: LD_INT 1
5330: PPUSH
5331: LD_INT 1
5333: PPUSH
5334: LD_INT 10
5336: PPUSH
5337: CALL_OW 380
// Powell := CreateHuman ;
5341: LD_ADDR_EXP 55
5345: PUSH
5346: CALL_OW 44
5350: ST_TO_ADDR
// end else
5351: GO 5366
// Powell := NewCharacter ( Powell ) ;
5353: LD_ADDR_EXP 55
5357: PUSH
5358: LD_STRING Powell
5360: PPUSH
5361: CALL_OW 25
5365: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5366: LD_EXP 55
5370: PPUSH
5371: LD_INT 387
5373: PPUSH
5374: CALL_OW 52
// tmp := [ ] ;
5378: LD_ADDR_VAR 0 7
5382: PUSH
5383: EMPTY
5384: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5385: LD_ADDR_EXP 21
5389: PUSH
5390: LD_STRING Lisa
5392: PPUSH
5393: LD_EXP 1
5397: NOT
5398: PPUSH
5399: LD_STRING 12p_
5401: PPUSH
5402: CALL 53324 0 3
5406: ST_TO_ADDR
// if Lisa then
5407: LD_EXP 21
5411: IFFALSE 5429
// tmp := tmp ^ Lisa ;
5413: LD_ADDR_VAR 0 7
5417: PUSH
5418: LD_VAR 0 7
5422: PUSH
5423: LD_EXP 21
5427: ADD
5428: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5429: LD_ADDR_EXP 22
5433: PUSH
5434: LD_STRING Donaldson
5436: PPUSH
5437: LD_EXP 1
5441: NOT
5442: PPUSH
5443: LD_STRING 12p_
5445: PPUSH
5446: CALL 53324 0 3
5450: ST_TO_ADDR
// if Donaldson then
5451: LD_EXP 22
5455: IFFALSE 5473
// tmp := tmp ^ Donaldson ;
5457: LD_ADDR_VAR 0 7
5461: PUSH
5462: LD_VAR 0 7
5466: PUSH
5467: LD_EXP 22
5471: ADD
5472: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5473: LD_ADDR_EXP 23
5477: PUSH
5478: LD_STRING Bobby
5480: PPUSH
5481: LD_EXP 1
5485: NOT
5486: PPUSH
5487: LD_STRING 12p_
5489: PPUSH
5490: CALL 53324 0 3
5494: ST_TO_ADDR
// if Bobby then
5495: LD_EXP 23
5499: IFFALSE 5517
// tmp := tmp ^ Bobby ;
5501: LD_ADDR_VAR 0 7
5505: PUSH
5506: LD_VAR 0 7
5510: PUSH
5511: LD_EXP 23
5515: ADD
5516: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5517: LD_ADDR_EXP 24
5521: PUSH
5522: LD_STRING Cyrus
5524: PPUSH
5525: LD_EXP 1
5529: NOT
5530: PPUSH
5531: LD_STRING 12p_
5533: PPUSH
5534: CALL 53324 0 3
5538: ST_TO_ADDR
// if Cyrus then
5539: LD_EXP 24
5543: IFFALSE 5561
// tmp := tmp ^ Cyrus ;
5545: LD_ADDR_VAR 0 7
5549: PUSH
5550: LD_VAR 0 7
5554: PUSH
5555: LD_EXP 24
5559: ADD
5560: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5561: LD_ADDR_EXP 26
5565: PUSH
5566: LD_STRING Brown
5568: PPUSH
5569: LD_EXP 1
5573: NOT
5574: PPUSH
5575: LD_STRING 12p_
5577: PPUSH
5578: CALL 53324 0 3
5582: ST_TO_ADDR
// if Brown then
5583: LD_EXP 26
5587: IFFALSE 5605
// tmp := tmp ^ Brown ;
5589: LD_ADDR_VAR 0 7
5593: PUSH
5594: LD_VAR 0 7
5598: PUSH
5599: LD_EXP 26
5603: ADD
5604: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5605: LD_ADDR_EXP 27
5609: PUSH
5610: LD_STRING Gladstone
5612: PPUSH
5613: LD_EXP 1
5617: NOT
5618: PPUSH
5619: LD_STRING 12p_
5621: PPUSH
5622: CALL 53324 0 3
5626: ST_TO_ADDR
// if Gladstone then
5627: LD_EXP 27
5631: IFFALSE 5649
// tmp := tmp ^ Gladstone ;
5633: LD_ADDR_VAR 0 7
5637: PUSH
5638: LD_VAR 0 7
5642: PUSH
5643: LD_EXP 27
5647: ADD
5648: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5649: LD_ADDR_EXP 28
5653: PUSH
5654: LD_STRING Houten
5656: PPUSH
5657: LD_EXP 1
5661: NOT
5662: PPUSH
5663: LD_STRING 12p_
5665: PPUSH
5666: CALL 53324 0 3
5670: ST_TO_ADDR
// if Houten then
5671: LD_EXP 28
5675: IFFALSE 5693
// tmp := tmp ^ Houten ;
5677: LD_ADDR_VAR 0 7
5681: PUSH
5682: LD_VAR 0 7
5686: PUSH
5687: LD_EXP 28
5691: ADD
5692: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5693: LD_ADDR_EXP 29
5697: PUSH
5698: LD_STRING Cornel
5700: PPUSH
5701: LD_EXP 1
5705: NOT
5706: PPUSH
5707: LD_STRING 12p_
5709: PPUSH
5710: CALL 53324 0 3
5714: ST_TO_ADDR
// if Cornel then
5715: LD_EXP 29
5719: IFFALSE 5737
// tmp := tmp ^ Cornel ;
5721: LD_ADDR_VAR 0 7
5725: PUSH
5726: LD_VAR 0 7
5730: PUSH
5731: LD_EXP 29
5735: ADD
5736: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5737: LD_ADDR_EXP 30
5741: PUSH
5742: LD_STRING Gary
5744: PPUSH
5745: LD_EXP 1
5749: NOT
5750: PPUSH
5751: LD_STRING 12p_
5753: PPUSH
5754: CALL 53324 0 3
5758: ST_TO_ADDR
// if Gary then
5759: LD_EXP 30
5763: IFFALSE 5781
// tmp := tmp ^ Gary ;
5765: LD_ADDR_VAR 0 7
5769: PUSH
5770: LD_VAR 0 7
5774: PUSH
5775: LD_EXP 30
5779: ADD
5780: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5781: LD_ADDR_EXP 32
5785: PUSH
5786: LD_STRING Kikuchi
5788: PPUSH
5789: LD_EXP 1
5793: NOT
5794: PPUSH
5795: LD_STRING 12p_
5797: PPUSH
5798: CALL 53324 0 3
5802: ST_TO_ADDR
// if Kikuchi then
5803: LD_EXP 32
5807: IFFALSE 5825
// tmp := tmp ^ Kikuchi ;
5809: LD_ADDR_VAR 0 7
5813: PUSH
5814: LD_VAR 0 7
5818: PUSH
5819: LD_EXP 32
5823: ADD
5824: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5825: LD_ADDR_VAR 0 7
5829: PUSH
5830: LD_VAR 0 7
5834: PUSH
5835: LD_STRING 12p_others
5837: PPUSH
5838: CALL_OW 31
5842: UNION
5843: ST_TO_ADDR
// InitHc_All ( ) ;
5844: CALL_OW 584
// if tmp < 36 then
5848: LD_VAR 0 7
5852: PUSH
5853: LD_INT 36
5855: LESS
5856: IFFALSE 5923
// for i = 1 to 36 - tmp do
5858: LD_ADDR_VAR 0 2
5862: PUSH
5863: DOUBLE
5864: LD_INT 1
5866: DEC
5867: ST_TO_ADDR
5868: LD_INT 36
5870: PUSH
5871: LD_VAR 0 7
5875: MINUS
5876: PUSH
5877: FOR_TO
5878: IFFALSE 5921
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5880: LD_INT 1
5882: PPUSH
5883: LD_VAR 0 2
5887: PUSH
5888: LD_INT 4
5890: MOD
5891: PUSH
5892: LD_INT 1
5894: PLUS
5895: PPUSH
5896: LD_INT 10
5898: PPUSH
5899: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5903: LD_ADDR_VAR 0 7
5907: PUSH
5908: LD_VAR 0 7
5912: PUSH
5913: CALL_OW 44
5917: ADD
5918: ST_TO_ADDR
// end ;
5919: GO 5877
5921: POP
5922: POP
// p := 0 ;
5923: LD_ADDR_VAR 0 6
5927: PUSH
5928: LD_INT 0
5930: ST_TO_ADDR
// for i in tmp do
5931: LD_ADDR_VAR 0 2
5935: PUSH
5936: LD_VAR 0 7
5940: PUSH
5941: FOR_IN
5942: IFFALSE 5994
// begin p := Inc ( p ) ;
5944: LD_ADDR_VAR 0 6
5948: PUSH
5949: LD_VAR 0 6
5953: PPUSH
5954: CALL 92376 0 1
5958: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5959: LD_VAR 0 2
5963: PPUSH
5964: LD_INT 62
5966: PPUSH
5967: LD_INT 93
5969: PPUSH
5970: LD_INT 9
5972: PPUSH
5973: LD_INT 0
5975: PPUSH
5976: CALL_OW 50
// if p > 36 then
5980: LD_VAR 0 6
5984: PUSH
5985: LD_INT 36
5987: GREATER
5988: IFFALSE 5992
// break ;
5990: GO 5994
// end ;
5992: GO 5941
5994: POP
5995: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5996: LD_ADDR_EXP 78
6000: PUSH
6001: LD_EXP 78
6005: PPUSH
6006: LD_INT 4
6008: PPUSH
6009: LD_INT 22
6011: PUSH
6012: LD_INT 1
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PPUSH
6019: CALL_OW 69
6023: PUSH
6024: LD_EXP 55
6028: DIFF
6029: PPUSH
6030: CALL_OW 1
6034: ST_TO_ADDR
// uc_side := 0 ;
6035: LD_ADDR_OWVAR 20
6039: PUSH
6040: LD_INT 0
6042: ST_TO_ADDR
// uc_nation := 0 ;
6043: LD_ADDR_OWVAR 21
6047: PUSH
6048: LD_INT 0
6050: ST_TO_ADDR
// for i = 1 to 4 do
6051: LD_ADDR_VAR 0 2
6055: PUSH
6056: DOUBLE
6057: LD_INT 1
6059: DEC
6060: ST_TO_ADDR
6061: LD_INT 4
6063: PUSH
6064: FOR_TO
6065: IFFALSE 6096
// begin InitHc ;
6067: CALL_OW 19
// hc_class := class_apeman ;
6071: LD_ADDR_OWVAR 28
6075: PUSH
6076: LD_INT 12
6078: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6079: CALL_OW 44
6083: PPUSH
6084: LD_INT 11
6086: PPUSH
6087: LD_INT 0
6089: PPUSH
6090: CALL_OW 49
// end ;
6094: GO 6064
6096: POP
6097: POP
// end ;
6098: LD_VAR 0 1
6102: RET
// every 9 9$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6103: LD_EXP 4
6107: NOT
6108: IFFALSE 7017
6110: GO 6112
6112: DISABLE
6113: LD_INT 0
6115: PPUSH
6116: PPUSH
6117: PPUSH
6118: PPUSH
// begin enable ;
6119: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6120: LD_INT 22
6122: PUSH
6123: LD_INT 1
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: PUSH
6130: LD_INT 23
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: PUSH
6140: LD_INT 30
6142: PUSH
6143: LD_INT 3
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: PPUSH
6155: CALL_OW 69
6159: NOT
6160: IFFALSE 6164
// exit ;
6162: GO 7017
// if Prob ( 40 ) then
6164: LD_INT 40
6166: PPUSH
6167: CALL_OW 13
6171: IFFALSE 6298
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6173: LD_INT 4
6175: PPUSH
6176: LD_INT 5
6178: PUSH
6179: LD_INT 1
6181: PUSH
6182: LD_INT 2
6184: PUSH
6185: LD_INT 7
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PUSH
6194: LD_INT 5
6196: PUSH
6197: LD_INT 1
6199: PUSH
6200: LD_INT 2
6202: PUSH
6203: LD_INT 7
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 5
6214: PUSH
6215: LD_INT 1
6217: PUSH
6218: LD_INT 2
6220: PUSH
6221: LD_INT 7
6223: PUSH
6224: EMPTY
6225: LIST
6226: LIST
6227: LIST
6228: LIST
6229: PUSH
6230: LD_INT 5
6232: PUSH
6233: LD_INT 1
6235: PUSH
6236: LD_INT 2
6238: PUSH
6239: LD_INT 6
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: LIST
6246: LIST
6247: PUSH
6248: LD_INT 5
6250: PUSH
6251: LD_INT 1
6253: PUSH
6254: LD_INT 2
6256: PUSH
6257: LD_INT 6
6259: PUSH
6260: EMPTY
6261: LIST
6262: LIST
6263: LIST
6264: LIST
6265: PUSH
6266: LD_INT 5
6268: PUSH
6269: LD_INT 1
6271: PUSH
6272: LD_INT 2
6274: PUSH
6275: LD_INT 6
6277: PUSH
6278: EMPTY
6279: LIST
6280: LIST
6281: LIST
6282: LIST
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: LIST
6290: LIST
6291: PPUSH
6292: CALL 46898 0 2
// end else
6296: GO 6421
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6298: LD_INT 4
6300: PPUSH
6301: LD_INT 5
6303: PUSH
6304: LD_INT 1
6306: PUSH
6307: LD_INT 2
6309: PUSH
6310: LD_INT 7
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: LIST
6317: LIST
6318: PUSH
6319: LD_INT 5
6321: PUSH
6322: LD_INT 1
6324: PUSH
6325: LD_INT 2
6327: PUSH
6328: LD_INT 9
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PUSH
6337: LD_INT 5
6339: PUSH
6340: LD_INT 1
6342: PUSH
6343: LD_INT 2
6345: PUSH
6346: LD_INT 9
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: LIST
6353: LIST
6354: PUSH
6355: LD_INT 5
6357: PUSH
6358: LD_INT 1
6360: PUSH
6361: LD_INT 2
6363: PUSH
6364: LD_INT 6
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 5
6375: PUSH
6376: LD_INT 1
6378: PUSH
6379: LD_INT 2
6381: PUSH
6382: LD_INT 6
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: PUSH
6391: LD_INT 5
6393: PUSH
6394: LD_INT 1
6396: PUSH
6397: LD_INT 2
6399: PUSH
6400: LD_INT 6
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: PPUSH
6417: CALL 46898 0 2
// end ; p := 0 ;
6421: LD_ADDR_VAR 0 4
6425: PUSH
6426: LD_INT 0
6428: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6429: LD_INT 35
6431: PPUSH
6432: CALL_OW 67
// p := Inc ( p ) ;
6436: LD_ADDR_VAR 0 4
6440: PUSH
6441: LD_VAR 0 4
6445: PPUSH
6446: CALL 92376 0 1
6450: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6451: LD_INT 4
6453: PPUSH
6454: LD_INT 1
6456: PPUSH
6457: CALL 48316 0 2
6461: PUSH
6462: LD_INT 6
6464: GREATEREQUAL
6465: PUSH
6466: LD_VAR 0 4
6470: PUSH
6471: LD_INT 100
6473: GREATER
6474: OR
6475: IFFALSE 6429
// wait ( 0 0$30 ) ;
6477: LD_INT 1050
6479: PPUSH
6480: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_siberium_rocket ] , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] ] ] ) diff mc_defender [ 4 ] ;
6484: LD_ADDR_VAR 0 2
6488: PUSH
6489: LD_INT 22
6491: PUSH
6492: LD_INT 1
6494: PUSH
6495: EMPTY
6496: LIST
6497: LIST
6498: PUSH
6499: LD_INT 21
6501: PUSH
6502: LD_INT 2
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: PUSH
6509: LD_INT 3
6511: PUSH
6512: LD_INT 34
6514: PUSH
6515: LD_INT 8
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 34
6524: PUSH
6525: LD_INT 12
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: PUSH
6532: LD_INT 34
6534: PUSH
6535: LD_INT 13
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: LIST
6552: PPUSH
6553: CALL_OW 69
6557: PUSH
6558: LD_EXP 100
6562: PUSH
6563: LD_INT 4
6565: ARRAY
6566: DIFF
6567: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6568: LD_ADDR_EXP 97
6572: PUSH
6573: LD_EXP 97
6577: PPUSH
6578: LD_INT 4
6580: PPUSH
6581: LD_EXP 97
6585: PUSH
6586: LD_INT 4
6588: ARRAY
6589: PUSH
6590: LD_VAR 0 2
6594: DIFF
6595: PPUSH
6596: CALL_OW 1
6600: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6601: LD_ADDR_VAR 0 3
6605: PUSH
6606: LD_INT 0
6608: PPUSH
6609: LD_INT 2
6611: PPUSH
6612: CALL_OW 12
6616: ST_TO_ADDR
// p := 0 ;
6617: LD_ADDR_VAR 0 4
6621: PUSH
6622: LD_INT 0
6624: ST_TO_ADDR
// if target then
6625: LD_VAR 0 3
6629: IFFALSE 6782
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6631: LD_ADDR_VAR 0 2
6635: PUSH
6636: LD_VAR 0 2
6640: PPUSH
6641: LD_INT 24
6643: PUSH
6644: LD_INT 250
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: PPUSH
6651: CALL_OW 72
6655: ST_TO_ADDR
// for i in tmp do
6656: LD_ADDR_VAR 0 1
6660: PUSH
6661: LD_VAR 0 2
6665: PUSH
6666: FOR_IN
6667: IFFALSE 6707
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6669: LD_VAR 0 1
6673: PPUSH
6674: LD_INT 114
6676: PPUSH
6677: LD_INT 108
6679: PPUSH
6680: CALL_OW 297
6684: PUSH
6685: LD_INT 9
6687: GREATER
6688: IFFALSE 6705
// ComMoveXY ( i , 114 , 108 ) ;
6690: LD_VAR 0 1
6694: PPUSH
6695: LD_INT 114
6697: PPUSH
6698: LD_INT 108
6700: PPUSH
6701: CALL_OW 111
6705: GO 6666
6707: POP
6708: POP
// wait ( 0 0$1 ) ;
6709: LD_INT 35
6711: PPUSH
6712: CALL_OW 67
// p := Inc ( p ) ;
6716: LD_ADDR_VAR 0 4
6720: PUSH
6721: LD_VAR 0 4
6725: PPUSH
6726: CALL 92376 0 1
6730: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6731: LD_VAR 0 2
6735: PPUSH
6736: LD_INT 92
6738: PUSH
6739: LD_INT 114
6741: PUSH
6742: LD_INT 108
6744: PUSH
6745: LD_INT 9
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: LIST
6752: LIST
6753: PPUSH
6754: CALL_OW 72
6758: PUSH
6759: LD_VAR 0 2
6763: PUSH
6764: LD_INT 1
6766: MINUS
6767: GREATEREQUAL
6768: PUSH
6769: LD_VAR 0 4
6773: PUSH
6774: LD_INT 30
6776: GREATER
6777: OR
6778: IFFALSE 6631
// end else
6780: GO 6931
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6782: LD_ADDR_VAR 0 2
6786: PUSH
6787: LD_VAR 0 2
6791: PPUSH
6792: LD_INT 24
6794: PUSH
6795: LD_INT 250
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PPUSH
6802: CALL_OW 72
6806: ST_TO_ADDR
// for i in tmp do
6807: LD_ADDR_VAR 0 1
6811: PUSH
6812: LD_VAR 0 2
6816: PUSH
6817: FOR_IN
6818: IFFALSE 6858
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6820: LD_VAR 0 1
6824: PPUSH
6825: LD_INT 129
6827: PPUSH
6828: LD_INT 139
6830: PPUSH
6831: CALL_OW 297
6835: PUSH
6836: LD_INT 9
6838: GREATER
6839: IFFALSE 6856
// ComMoveXY ( i , 129 , 139 ) ;
6841: LD_VAR 0 1
6845: PPUSH
6846: LD_INT 129
6848: PPUSH
6849: LD_INT 139
6851: PPUSH
6852: CALL_OW 111
6856: GO 6817
6858: POP
6859: POP
// wait ( 0 0$1 ) ;
6860: LD_INT 35
6862: PPUSH
6863: CALL_OW 67
// p := Inc ( p ) ;
6867: LD_ADDR_VAR 0 4
6871: PUSH
6872: LD_VAR 0 4
6876: PPUSH
6877: CALL 92376 0 1
6881: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6882: LD_VAR 0 2
6886: PPUSH
6887: LD_INT 92
6889: PUSH
6890: LD_INT 129
6892: PUSH
6893: LD_INT 139
6895: PUSH
6896: LD_INT 9
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: LIST
6903: LIST
6904: PPUSH
6905: CALL_OW 72
6909: PUSH
6910: LD_VAR 0 2
6914: PUSH
6915: LD_INT 1
6917: MINUS
6918: GREATEREQUAL
6919: PUSH
6920: LD_VAR 0 4
6924: PUSH
6925: LD_INT 30
6927: GREATER
6928: OR
6929: IFFALSE 6782
// end ; repeat wait ( 0 0$1 ) ;
6931: LD_INT 35
6933: PPUSH
6934: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6938: LD_ADDR_VAR 0 2
6942: PUSH
6943: LD_VAR 0 2
6947: PPUSH
6948: LD_INT 50
6950: PUSH
6951: EMPTY
6952: LIST
6953: PPUSH
6954: CALL_OW 72
6958: ST_TO_ADDR
// for i in tmp do
6959: LD_ADDR_VAR 0 1
6963: PUSH
6964: LD_VAR 0 2
6968: PUSH
6969: FOR_IN
6970: IFFALSE 7008
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
6972: LD_VAR 0 1
6976: PPUSH
6977: LD_INT 81
6979: PUSH
6980: LD_INT 1
6982: PUSH
6983: EMPTY
6984: LIST
6985: LIST
6986: PPUSH
6987: CALL_OW 69
6991: PPUSH
6992: LD_VAR 0 1
6996: PPUSH
6997: CALL_OW 74
7001: PPUSH
7002: CALL_OW 115
7006: GO 6969
7008: POP
7009: POP
// until not tmp ;
7010: LD_VAR 0 2
7014: NOT
7015: IFFALSE 6931
// end ;
7017: PPOPN 4
7019: END
// every 30 30$00 trigger not americanDestroyed do
7020: LD_EXP 4
7024: NOT
7025: IFFALSE 7094
7027: GO 7029
7029: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
7030: LD_INT 63000
7032: PUSH
7033: LD_INT 42000
7035: PUSH
7036: LD_INT 31500
7038: PUSH
7039: LD_INT 21000
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: LIST
7046: LIST
7047: PUSH
7048: LD_OWVAR 67
7052: ARRAY
7053: PPUSH
7054: CALL_OW 67
// if americanDestroyed then
7058: LD_EXP 4
7062: IFFALSE 7066
// exit ;
7064: GO 7094
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
7066: LD_INT 4
7068: PPUSH
7069: LD_INT 5
7071: PUSH
7072: LD_INT 3
7074: PUSH
7075: LD_INT 1
7077: PUSH
7078: LD_INT 8
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: EMPTY
7088: LIST
7089: PPUSH
7090: CALL 46898 0 2
// end ; end_of_file
7094: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
7095: LD_INT 0
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
// side := 2 ;
7102: LD_ADDR_VAR 0 5
7106: PUSH
7107: LD_INT 2
7109: ST_TO_ADDR
// InitHc ;
7110: CALL_OW 19
// uc_side := side ;
7114: LD_ADDR_OWVAR 20
7118: PUSH
7119: LD_VAR 0 5
7123: ST_TO_ADDR
// uc_nation := 2 ;
7124: LD_ADDR_OWVAR 21
7128: PUSH
7129: LD_INT 2
7131: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
7132: LD_ADDR_VAR 0 2
7136: PUSH
7137: LD_INT 22
7139: PUSH
7140: LD_INT 2
7142: PUSH
7143: EMPTY
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 21
7149: PUSH
7150: LD_INT 3
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PPUSH
7161: CALL_OW 69
7165: PUSH
7166: FOR_IN
7167: IFFALSE 7183
// SetBLevel ( i , 10 ) ;
7169: LD_VAR 0 2
7173: PPUSH
7174: LD_INT 10
7176: PPUSH
7177: CALL_OW 241
7181: GO 7166
7183: POP
7184: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7185: LD_ADDR_VAR 0 4
7189: PUSH
7190: LD_INT 22
7192: PUSH
7193: LD_VAR 0 5
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: PUSH
7202: LD_INT 30
7204: PUSH
7205: LD_INT 32
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: PUSH
7212: LD_INT 58
7214: PUSH
7215: EMPTY
7216: LIST
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: PPUSH
7223: CALL_OW 69
7227: ST_TO_ADDR
// for i = 1 to 10 do
7228: LD_ADDR_VAR 0 2
7232: PUSH
7233: DOUBLE
7234: LD_INT 1
7236: DEC
7237: ST_TO_ADDR
7238: LD_INT 10
7240: PUSH
7241: FOR_TO
7242: IFFALSE 7314
// begin uc_nation := nation_nature ;
7244: LD_ADDR_OWVAR 21
7248: PUSH
7249: LD_INT 0
7251: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7252: LD_ADDR_OWVAR 28
7256: PUSH
7257: LD_INT 15
7259: ST_TO_ADDR
// hc_gallery :=  ;
7260: LD_ADDR_OWVAR 33
7264: PUSH
7265: LD_STRING 
7267: ST_TO_ADDR
// hc_name :=  ;
7268: LD_ADDR_OWVAR 26
7272: PUSH
7273: LD_STRING 
7275: ST_TO_ADDR
// un := CreateHuman ;
7276: LD_ADDR_VAR 0 3
7280: PUSH
7281: CALL_OW 44
7285: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7286: LD_VAR 0 3
7290: PPUSH
7291: LD_VAR 0 4
7295: PUSH
7296: LD_VAR 0 4
7300: PUSH
7301: LD_VAR 0 2
7305: MINUS
7306: ARRAY
7307: PPUSH
7308: CALL_OW 52
// end ;
7312: GO 7241
7314: POP
7315: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7316: LD_INT 503
7318: PPUSH
7319: LD_INT 27
7321: PPUSH
7322: LD_STRING 
7324: PPUSH
7325: LD_INT 8
7327: PUSH
7328: LD_INT 9
7330: PUSH
7331: LD_INT 10
7333: PUSH
7334: LD_INT 10
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: LIST
7341: LIST
7342: PUSH
7343: LD_OWVAR 67
7347: ARRAY
7348: PPUSH
7349: LD_INT 3000
7351: PUSH
7352: LD_INT 500
7354: PUSH
7355: LD_INT 150
7357: PUSH
7358: EMPTY
7359: LIST
7360: LIST
7361: LIST
7362: PPUSH
7363: LD_INT 16
7365: PUSH
7366: LD_INT 6
7368: PUSH
7369: LD_INT 6
7371: PUSH
7372: LD_INT 6
7374: PUSH
7375: EMPTY
7376: LIST
7377: LIST
7378: LIST
7379: LIST
7380: PPUSH
7381: CALL 61985 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7385: LD_ADDR_EXP 78
7389: PUSH
7390: LD_EXP 78
7394: PPUSH
7395: LD_INT 1
7397: PPUSH
7398: LD_INT 22
7400: PUSH
7401: LD_VAR 0 5
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: LD_INT 23
7412: PUSH
7413: LD_INT 2
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: LD_INT 21
7425: PUSH
7426: LD_INT 2
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: LIST
7441: PPUSH
7442: CALL_OW 69
7446: PPUSH
7447: CALL_OW 1
7451: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7452: LD_INT 216
7454: PPUSH
7455: LD_INT 228
7457: PPUSH
7458: LD_INT 2
7460: PPUSH
7461: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7465: LD_INT 223
7467: PPUSH
7468: LD_INT 241
7470: PPUSH
7471: LD_INT 2
7473: PPUSH
7474: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7478: LD_INT 216
7480: PPUSH
7481: LD_INT 217
7483: PPUSH
7484: LD_INT 2
7486: PPUSH
7487: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7491: LD_INT 233
7493: PPUSH
7494: LD_INT 257
7496: PPUSH
7497: LD_INT 2
7499: PPUSH
7500: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7504: LD_INT 230
7506: PPUSH
7507: LD_INT 199
7509: PPUSH
7510: LD_INT 2
7512: PPUSH
7513: CALL_OW 244
// end ;
7517: LD_VAR 0 1
7521: RET
// export Omar ; export function PrepareOmarAli ; begin
7522: LD_INT 0
7524: PPUSH
// uc_side := 5 ;
7525: LD_ADDR_OWVAR 20
7529: PUSH
7530: LD_INT 5
7532: ST_TO_ADDR
// uc_nation := 2 ;
7533: LD_ADDR_OWVAR 21
7537: PUSH
7538: LD_INT 2
7540: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7541: LD_ADDR_EXP 56
7545: PUSH
7546: LD_STRING Omar
7548: PPUSH
7549: CALL_OW 25
7553: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7554: LD_EXP 56
7558: PPUSH
7559: LD_INT 330
7561: PPUSH
7562: LD_INT 244
7564: PPUSH
7565: LD_INT 0
7567: PPUSH
7568: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7572: LD_EXP 56
7576: PPUSH
7577: LD_INT 252
7579: PPUSH
7580: LD_INT 220
7582: PPUSH
7583: CALL_OW 111
// end ; end_of_file
7587: LD_VAR 0 1
7591: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7592: LD_INT 0
7594: PPUSH
7595: PPUSH
7596: PPUSH
7597: PPUSH
7598: PPUSH
// side := 8 ;
7599: LD_ADDR_VAR 0 3
7603: PUSH
7604: LD_INT 8
7606: ST_TO_ADDR
// InitHc ;
7607: CALL_OW 19
// uc_side := side ;
7611: LD_ADDR_OWVAR 20
7615: PUSH
7616: LD_VAR 0 3
7620: ST_TO_ADDR
// uc_nation := 2 ;
7621: LD_ADDR_OWVAR 21
7625: PUSH
7626: LD_INT 2
7628: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7629: LD_ADDR_VAR 0 2
7633: PUSH
7634: LD_INT 22
7636: PUSH
7637: LD_VAR 0 3
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PUSH
7646: LD_INT 21
7648: PUSH
7649: LD_INT 3
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: PPUSH
7660: CALL_OW 69
7664: PUSH
7665: FOR_IN
7666: IFFALSE 7682
// SetBLevel ( i , 10 ) ;
7668: LD_VAR 0 2
7672: PPUSH
7673: LD_INT 10
7675: PPUSH
7676: CALL_OW 241
7680: GO 7665
7682: POP
7683: POP
// Schulz := NewCharacter ( Schulz ) ;
7684: LD_ADDR_EXP 57
7688: PUSH
7689: LD_STRING Schulz
7691: PPUSH
7692: CALL_OW 25
7696: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7697: LD_ADDR_EXP 59
7701: PUSH
7702: LD_STRING Kaia
7704: PPUSH
7705: CALL_OW 25
7709: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7710: LD_EXP 59
7714: PPUSH
7715: LD_INT 324
7717: PPUSH
7718: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7722: LD_ADDR_EXP 58
7726: PUSH
7727: LD_STRING Kozlov
7729: PPUSH
7730: LD_INT 0
7732: PPUSH
7733: LD_STRING 
7735: PPUSH
7736: CALL 53324 0 3
7740: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7741: LD_EXP 58
7745: PPUSH
7746: LD_INT 22
7748: PUSH
7749: LD_INT 8
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: PUSH
7756: LD_INT 23
7758: PUSH
7759: LD_INT 3
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PUSH
7766: LD_INT 30
7768: PUSH
7769: LD_INT 8
7771: PUSH
7772: EMPTY
7773: LIST
7774: LIST
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: LIST
7780: PPUSH
7781: CALL_OW 69
7785: PUSH
7786: LD_INT 1
7788: ARRAY
7789: PPUSH
7790: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7794: LD_EXP 58
7798: PPUSH
7799: LD_INT 3
7801: PPUSH
7802: LD_INT 10
7804: PPUSH
7805: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7809: LD_ADDR_VAR 0 5
7813: PUSH
7814: LD_INT 22
7816: PUSH
7817: LD_VAR 0 3
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 30
7828: PUSH
7829: LD_INT 32
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: LD_INT 58
7838: PUSH
7839: EMPTY
7840: LIST
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: LIST
7846: PPUSH
7847: CALL_OW 69
7851: ST_TO_ADDR
// for i = 1 to 10 do
7852: LD_ADDR_VAR 0 2
7856: PUSH
7857: DOUBLE
7858: LD_INT 1
7860: DEC
7861: ST_TO_ADDR
7862: LD_INT 10
7864: PUSH
7865: FOR_TO
7866: IFFALSE 7938
// begin uc_nation := nation_nature ;
7868: LD_ADDR_OWVAR 21
7872: PUSH
7873: LD_INT 0
7875: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7876: LD_ADDR_OWVAR 28
7880: PUSH
7881: LD_INT 15
7883: ST_TO_ADDR
// hc_gallery :=  ;
7884: LD_ADDR_OWVAR 33
7888: PUSH
7889: LD_STRING 
7891: ST_TO_ADDR
// hc_name :=  ;
7892: LD_ADDR_OWVAR 26
7896: PUSH
7897: LD_STRING 
7899: ST_TO_ADDR
// un := CreateHuman ;
7900: LD_ADDR_VAR 0 4
7904: PUSH
7905: CALL_OW 44
7909: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7910: LD_VAR 0 4
7914: PPUSH
7915: LD_VAR 0 5
7919: PUSH
7920: LD_VAR 0 5
7924: PUSH
7925: LD_VAR 0 2
7929: MINUS
7930: ARRAY
7931: PPUSH
7932: CALL_OW 52
// end ;
7936: GO 7865
7938: POP
7939: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7940: LD_INT 324
7942: PPUSH
7943: LD_INT 3
7945: PPUSH
7946: LD_STRING 
7948: PPUSH
7949: LD_INT 8
7951: PUSH
7952: LD_INT 9
7954: PUSH
7955: LD_INT 10
7957: PUSH
7958: LD_INT 10
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: LIST
7965: LIST
7966: PUSH
7967: LD_OWVAR 67
7971: ARRAY
7972: PPUSH
7973: LD_INT 3000
7975: PUSH
7976: LD_INT 500
7978: PUSH
7979: LD_INT 150
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: LIST
7986: PPUSH
7987: LD_INT 16
7989: PUSH
7990: LD_INT 6
7992: PUSH
7993: LD_INT 6
7995: PUSH
7996: LD_INT 8
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: LIST
8003: LIST
8004: PPUSH
8005: CALL 61985 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
8009: LD_ADDR_EXP 78
8013: PUSH
8014: LD_EXP 78
8018: PPUSH
8019: LD_INT 3
8021: PPUSH
8022: LD_INT 22
8024: PUSH
8025: LD_VAR 0 3
8029: PUSH
8030: EMPTY
8031: LIST
8032: LIST
8033: PUSH
8034: LD_INT 23
8036: PUSH
8037: LD_INT 2
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: PUSH
8044: LD_INT 3
8046: PUSH
8047: LD_INT 21
8049: PUSH
8050: LD_INT 2
8052: PUSH
8053: EMPTY
8054: LIST
8055: LIST
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: PPUSH
8066: CALL_OW 69
8070: PUSH
8071: LD_EXP 57
8075: DIFF
8076: PPUSH
8077: CALL_OW 1
8081: ST_TO_ADDR
// end ;
8082: LD_VAR 0 1
8086: RET
// export function BuildKozlovBomb ; begin
8087: LD_INT 0
8089: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
8090: LD_INT 332
8092: PPUSH
8093: CALL_OW 302
8097: NOT
8098: PUSH
8099: LD_INT 336
8101: PPUSH
8102: CALL_OW 302
8106: NOT
8107: OR
8108: IFFALSE 8112
// exit ;
8110: GO 8209
// ComChangeProfession ( Kozlov , 4 ) ;
8112: LD_EXP 58
8116: PPUSH
8117: LD_INT 4
8119: PPUSH
8120: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
8124: LD_INT 336
8126: PPUSH
8127: LD_INT 25
8129: PPUSH
8130: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
8134: LD_INT 35
8136: PPUSH
8137: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
8141: LD_INT 25
8143: PPUSH
8144: LD_INT 8
8146: PPUSH
8147: CALL_OW 321
8151: PUSH
8152: LD_INT 2
8154: EQUAL
8155: IFFALSE 8134
// ComExitBuilding ( Kozlov ) ;
8157: LD_EXP 58
8161: PPUSH
8162: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8166: LD_EXP 58
8170: PPUSH
8171: LD_INT 332
8173: PPUSH
8174: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8178: LD_EXP 58
8182: PPUSH
8183: LD_INT 3
8185: PPUSH
8186: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8190: LD_INT 332
8192: PPUSH
8193: LD_INT 23
8195: PPUSH
8196: LD_INT 3
8198: PPUSH
8199: LD_INT 1
8201: PPUSH
8202: LD_INT 48
8204: PPUSH
8205: CALL_OW 125
// end ;
8209: LD_VAR 0 1
8213: RET
// every 9 9$30 + 7 7$00 trigger not legionDestroyed do var i , tmp , target , p ;
8214: LD_EXP 3
8218: NOT
8219: IFFALSE 9212
8221: GO 8223
8223: DISABLE
8224: LD_INT 0
8226: PPUSH
8227: PPUSH
8228: PPUSH
8229: PPUSH
// begin enable ;
8230: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8231: LD_INT 22
8233: PUSH
8234: LD_INT 8
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: PUSH
8241: LD_INT 23
8243: PUSH
8244: LD_INT 2
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: LD_INT 30
8253: PUSH
8254: LD_INT 3
8256: PUSH
8257: EMPTY
8258: LIST
8259: LIST
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: LIST
8265: PPUSH
8266: CALL_OW 69
8270: NOT
8271: IFFALSE 8275
// exit ;
8273: GO 9212
// if Prob ( 40 ) then
8275: LD_INT 40
8277: PPUSH
8278: CALL_OW 13
8282: IFFALSE 8409
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8284: LD_INT 3
8286: PPUSH
8287: LD_INT 14
8289: PUSH
8290: LD_INT 1
8292: PUSH
8293: LD_INT 2
8295: PUSH
8296: LD_INT 28
8298: PUSH
8299: EMPTY
8300: LIST
8301: LIST
8302: LIST
8303: LIST
8304: PUSH
8305: LD_INT 14
8307: PUSH
8308: LD_INT 1
8310: PUSH
8311: LD_INT 2
8313: PUSH
8314: LD_INT 28
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: LIST
8321: LIST
8322: PUSH
8323: LD_INT 14
8325: PUSH
8326: LD_INT 1
8328: PUSH
8329: LD_INT 2
8331: PUSH
8332: LD_INT 28
8334: PUSH
8335: EMPTY
8336: LIST
8337: LIST
8338: LIST
8339: LIST
8340: PUSH
8341: LD_INT 14
8343: PUSH
8344: LD_INT 1
8346: PUSH
8347: LD_INT 2
8349: PUSH
8350: LD_INT 28
8352: PUSH
8353: EMPTY
8354: LIST
8355: LIST
8356: LIST
8357: LIST
8358: PUSH
8359: LD_INT 14
8361: PUSH
8362: LD_INT 1
8364: PUSH
8365: LD_INT 2
8367: PUSH
8368: LD_INT 28
8370: PUSH
8371: EMPTY
8372: LIST
8373: LIST
8374: LIST
8375: LIST
8376: PUSH
8377: LD_INT 14
8379: PUSH
8380: LD_INT 1
8382: PUSH
8383: LD_INT 2
8385: PUSH
8386: LD_INT 26
8388: PUSH
8389: EMPTY
8390: LIST
8391: LIST
8392: LIST
8393: LIST
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: LIST
8402: PPUSH
8403: CALL 46898 0 2
// end else
8407: GO 8616
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8409: LD_INT 3
8411: PPUSH
8412: LD_INT 14
8414: PUSH
8415: LD_INT 1
8417: PUSH
8418: LD_INT 2
8420: PUSH
8421: LD_INT 27
8423: PUSH
8424: LD_INT 26
8426: PUSH
8427: LD_INT 26
8429: PUSH
8430: LD_INT 28
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: LIST
8437: LIST
8438: PUSH
8439: LD_OWVAR 67
8443: ARRAY
8444: PUSH
8445: EMPTY
8446: LIST
8447: LIST
8448: LIST
8449: LIST
8450: PUSH
8451: LD_INT 14
8453: PUSH
8454: LD_INT 1
8456: PUSH
8457: LD_INT 2
8459: PUSH
8460: LD_INT 27
8462: PUSH
8463: LD_INT 26
8465: PUSH
8466: LD_INT 26
8468: PUSH
8469: LD_INT 26
8471: PUSH
8472: EMPTY
8473: LIST
8474: LIST
8475: LIST
8476: LIST
8477: PUSH
8478: LD_OWVAR 67
8482: ARRAY
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: LIST
8488: LIST
8489: PUSH
8490: LD_INT 14
8492: PUSH
8493: LD_INT 1
8495: PUSH
8496: LD_INT 2
8498: PUSH
8499: LD_INT 26
8501: PUSH
8502: LD_INT 26
8504: PUSH
8505: LD_INT 29
8507: PUSH
8508: LD_INT 29
8510: PUSH
8511: EMPTY
8512: LIST
8513: LIST
8514: LIST
8515: LIST
8516: PUSH
8517: LD_OWVAR 67
8521: ARRAY
8522: PUSH
8523: EMPTY
8524: LIST
8525: LIST
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 13
8531: PUSH
8532: LD_INT 1
8534: PUSH
8535: LD_INT 2
8537: PUSH
8538: LD_INT 26
8540: PUSH
8541: LD_INT 29
8543: PUSH
8544: LD_INT 29
8546: PUSH
8547: LD_INT 29
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: PUSH
8556: LD_OWVAR 67
8560: ARRAY
8561: PUSH
8562: EMPTY
8563: LIST
8564: LIST
8565: LIST
8566: LIST
8567: PUSH
8568: LD_INT 13
8570: PUSH
8571: LD_INT 1
8573: PUSH
8574: LD_INT 2
8576: PUSH
8577: LD_INT 29
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: LIST
8584: LIST
8585: PUSH
8586: LD_INT 14
8588: PUSH
8589: LD_INT 1
8591: PUSH
8592: LD_INT 2
8594: PUSH
8595: LD_INT 26
8597: PUSH
8598: EMPTY
8599: LIST
8600: LIST
8601: LIST
8602: LIST
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: LIST
8608: LIST
8609: LIST
8610: LIST
8611: PPUSH
8612: CALL 46898 0 2
// end ; p := 0 ;
8616: LD_ADDR_VAR 0 4
8620: PUSH
8621: LD_INT 0
8623: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8624: LD_INT 35
8626: PPUSH
8627: CALL_OW 67
// p := Inc ( p ) ;
8631: LD_ADDR_VAR 0 4
8635: PUSH
8636: LD_VAR 0 4
8640: PPUSH
8641: CALL 92376 0 1
8645: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8646: LD_INT 3
8648: PPUSH
8649: LD_INT 1
8651: PPUSH
8652: CALL 48316 0 2
8656: PUSH
8657: LD_INT 6
8659: GREATEREQUAL
8660: PUSH
8661: LD_VAR 0 4
8665: PUSH
8666: LD_INT 100
8668: GREATER
8669: OR
8670: IFFALSE 8624
// wait ( 0 0$30 ) ;
8672: LD_INT 1050
8674: PPUSH
8675: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
8679: LD_ADDR_VAR 0 2
8683: PUSH
8684: LD_INT 22
8686: PUSH
8687: LD_INT 8
8689: PUSH
8690: EMPTY
8691: LIST
8692: LIST
8693: PUSH
8694: LD_INT 21
8696: PUSH
8697: LD_INT 2
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: PUSH
8704: LD_INT 3
8706: PUSH
8707: LD_INT 34
8709: PUSH
8710: LD_INT 31
8712: PUSH
8713: EMPTY
8714: LIST
8715: LIST
8716: PUSH
8717: LD_INT 34
8719: PUSH
8720: LD_INT 32
8722: PUSH
8723: EMPTY
8724: LIST
8725: LIST
8726: PUSH
8727: LD_INT 34
8729: PUSH
8730: LD_INT 88
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: PUSH
8743: EMPTY
8744: LIST
8745: LIST
8746: LIST
8747: PPUSH
8748: CALL_OW 69
8752: PUSH
8753: LD_EXP 100
8757: PUSH
8758: LD_INT 3
8760: ARRAY
8761: DIFF
8762: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8763: LD_ADDR_EXP 97
8767: PUSH
8768: LD_EXP 97
8772: PPUSH
8773: LD_INT 3
8775: PPUSH
8776: LD_EXP 97
8780: PUSH
8781: LD_INT 3
8783: ARRAY
8784: PUSH
8785: LD_VAR 0 2
8789: DIFF
8790: PPUSH
8791: CALL_OW 1
8795: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8796: LD_ADDR_VAR 0 3
8800: PUSH
8801: LD_INT 0
8803: PPUSH
8804: LD_INT 2
8806: PPUSH
8807: CALL_OW 12
8811: ST_TO_ADDR
// p := 0 ;
8812: LD_ADDR_VAR 0 4
8816: PUSH
8817: LD_INT 0
8819: ST_TO_ADDR
// if target then
8820: LD_VAR 0 3
8824: IFFALSE 8977
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8826: LD_ADDR_VAR 0 2
8830: PUSH
8831: LD_VAR 0 2
8835: PPUSH
8836: LD_INT 24
8838: PUSH
8839: LD_INT 250
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PPUSH
8846: CALL_OW 72
8850: ST_TO_ADDR
// for i in tmp do
8851: LD_ADDR_VAR 0 1
8855: PUSH
8856: LD_VAR 0 2
8860: PUSH
8861: FOR_IN
8862: IFFALSE 8902
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8864: LD_VAR 0 1
8868: PPUSH
8869: LD_INT 89
8871: PPUSH
8872: LD_INT 71
8874: PPUSH
8875: CALL_OW 297
8879: PUSH
8880: LD_INT 9
8882: GREATER
8883: IFFALSE 8900
// ComMoveXY ( i , 89 , 71 ) ;
8885: LD_VAR 0 1
8889: PPUSH
8890: LD_INT 89
8892: PPUSH
8893: LD_INT 71
8895: PPUSH
8896: CALL_OW 111
8900: GO 8861
8902: POP
8903: POP
// wait ( 0 0$1 ) ;
8904: LD_INT 35
8906: PPUSH
8907: CALL_OW 67
// p := Inc ( p ) ;
8911: LD_ADDR_VAR 0 4
8915: PUSH
8916: LD_VAR 0 4
8920: PPUSH
8921: CALL 92376 0 1
8925: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
8926: LD_VAR 0 2
8930: PPUSH
8931: LD_INT 92
8933: PUSH
8934: LD_INT 89
8936: PUSH
8937: LD_INT 71
8939: PUSH
8940: LD_INT 9
8942: PUSH
8943: EMPTY
8944: LIST
8945: LIST
8946: LIST
8947: LIST
8948: PPUSH
8949: CALL_OW 72
8953: PUSH
8954: LD_VAR 0 2
8958: PUSH
8959: LD_INT 1
8961: MINUS
8962: GREATEREQUAL
8963: PUSH
8964: LD_VAR 0 4
8968: PUSH
8969: LD_INT 30
8971: GREATER
8972: OR
8973: IFFALSE 8826
// end else
8975: GO 9126
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8977: LD_ADDR_VAR 0 2
8981: PUSH
8982: LD_VAR 0 2
8986: PPUSH
8987: LD_INT 24
8989: PUSH
8990: LD_INT 250
8992: PUSH
8993: EMPTY
8994: LIST
8995: LIST
8996: PPUSH
8997: CALL_OW 72
9001: ST_TO_ADDR
// for i in tmp do
9002: LD_ADDR_VAR 0 1
9006: PUSH
9007: LD_VAR 0 2
9011: PUSH
9012: FOR_IN
9013: IFFALSE 9053
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
9015: LD_VAR 0 1
9019: PPUSH
9020: LD_INT 147
9022: PPUSH
9023: LD_INT 4
9025: PPUSH
9026: CALL_OW 297
9030: PUSH
9031: LD_INT 9
9033: GREATER
9034: IFFALSE 9051
// ComMoveXY ( i , 147 , 4 ) ;
9036: LD_VAR 0 1
9040: PPUSH
9041: LD_INT 147
9043: PPUSH
9044: LD_INT 4
9046: PPUSH
9047: CALL_OW 111
9051: GO 9012
9053: POP
9054: POP
// wait ( 0 0$1 ) ;
9055: LD_INT 35
9057: PPUSH
9058: CALL_OW 67
// p := Inc ( p ) ;
9062: LD_ADDR_VAR 0 4
9066: PUSH
9067: LD_VAR 0 4
9071: PPUSH
9072: CALL 92376 0 1
9076: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9077: LD_VAR 0 2
9081: PPUSH
9082: LD_INT 92
9084: PUSH
9085: LD_INT 147
9087: PUSH
9088: LD_INT 4
9090: PUSH
9091: LD_INT 9
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: LIST
9098: LIST
9099: PPUSH
9100: CALL_OW 72
9104: PUSH
9105: LD_VAR 0 2
9109: PUSH
9110: LD_INT 1
9112: MINUS
9113: GREATEREQUAL
9114: PUSH
9115: LD_VAR 0 4
9119: PUSH
9120: LD_INT 30
9122: GREATER
9123: OR
9124: IFFALSE 8977
// end ; repeat wait ( 0 0$1 ) ;
9126: LD_INT 35
9128: PPUSH
9129: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
9133: LD_ADDR_VAR 0 2
9137: PUSH
9138: LD_VAR 0 2
9142: PPUSH
9143: LD_INT 50
9145: PUSH
9146: EMPTY
9147: LIST
9148: PPUSH
9149: CALL_OW 72
9153: ST_TO_ADDR
// for i in tmp do
9154: LD_ADDR_VAR 0 1
9158: PUSH
9159: LD_VAR 0 2
9163: PUSH
9164: FOR_IN
9165: IFFALSE 9203
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
9167: LD_VAR 0 1
9171: PPUSH
9172: LD_INT 81
9174: PUSH
9175: LD_INT 8
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PPUSH
9182: CALL_OW 69
9186: PPUSH
9187: LD_VAR 0 1
9191: PPUSH
9192: CALL_OW 74
9196: PPUSH
9197: CALL_OW 115
9201: GO 9164
9203: POP
9204: POP
// until not tmp ;
9205: LD_VAR 0 2
9209: NOT
9210: IFFALSE 9126
// end ;
9212: PPOPN 4
9214: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
9215: LD_EXP 58
9219: PPUSH
9220: CALL_OW 302
9224: PUSH
9225: LD_EXP 3
9229: NOT
9230: AND
9231: IFFALSE 9240
9233: GO 9235
9235: DISABLE
// BuildKozlovBomb ;
9236: CALL 8087 0 0
9240: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
9241: LD_INT 22
9243: PUSH
9244: LD_INT 8
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: PUSH
9251: LD_INT 34
9253: PUSH
9254: LD_INT 48
9256: PUSH
9257: EMPTY
9258: LIST
9259: LIST
9260: PUSH
9261: EMPTY
9262: LIST
9263: LIST
9264: PPUSH
9265: CALL_OW 69
9269: IFFALSE 9317
9271: GO 9273
9273: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9274: LD_INT 22
9276: PUSH
9277: LD_INT 8
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: PUSH
9284: LD_INT 34
9286: PUSH
9287: LD_INT 48
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: PUSH
9294: EMPTY
9295: LIST
9296: LIST
9297: PPUSH
9298: CALL_OW 69
9302: PUSH
9303: LD_INT 1
9305: ARRAY
9306: PPUSH
9307: LD_INT 173
9309: PPUSH
9310: LD_INT 96
9312: PPUSH
9313: CALL_OW 116
// end ; end_of_file
9317: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9318: LD_INT 0
9320: PPUSH
9321: PPUSH
9322: PPUSH
9323: PPUSH
9324: PPUSH
9325: PPUSH
9326: PPUSH
9327: PPUSH
9328: PPUSH
9329: PPUSH
// side := 3 ;
9330: LD_ADDR_VAR 0 6
9334: PUSH
9335: LD_INT 3
9337: ST_TO_ADDR
// InitHc ;
9338: CALL_OW 19
// uc_side := side ;
9342: LD_ADDR_OWVAR 20
9346: PUSH
9347: LD_VAR 0 6
9351: ST_TO_ADDR
// uc_nation := 3 ;
9352: LD_ADDR_OWVAR 21
9356: PUSH
9357: LD_INT 3
9359: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9360: LD_ADDR_VAR 0 2
9364: PUSH
9365: LD_INT 22
9367: PUSH
9368: LD_VAR 0 6
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: PUSH
9377: LD_INT 21
9379: PUSH
9380: LD_INT 3
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: PUSH
9387: EMPTY
9388: LIST
9389: LIST
9390: PPUSH
9391: CALL_OW 69
9395: PUSH
9396: FOR_IN
9397: IFFALSE 9413
// SetBLevel ( i , 10 ) ;
9399: LD_VAR 0 2
9403: PPUSH
9404: LD_INT 10
9406: PPUSH
9407: CALL_OW 241
9411: GO 9396
9413: POP
9414: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9415: LD_ADDR_VAR 0 10
9419: PUSH
9420: LD_INT 22
9422: PUSH
9423: LD_VAR 0 6
9427: PUSH
9428: EMPTY
9429: LIST
9430: LIST
9431: PUSH
9432: LD_INT 30
9434: PUSH
9435: LD_INT 34
9437: PUSH
9438: EMPTY
9439: LIST
9440: LIST
9441: PUSH
9442: EMPTY
9443: LIST
9444: LIST
9445: PPUSH
9446: CALL_OW 69
9450: ST_TO_ADDR
// if teleport then
9451: LD_VAR 0 10
9455: IFFALSE 9476
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9457: LD_VAR 0 10
9461: PUSH
9462: LD_INT 1
9464: ARRAY
9465: PPUSH
9466: LD_INT 123
9468: PPUSH
9469: LD_INT 122
9471: PPUSH
9472: CALL_OW 243
// hc_importance := 0 ;
9476: LD_ADDR_OWVAR 32
9480: PUSH
9481: LD_INT 0
9483: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9484: LD_ADDR_EXP 60
9488: PUSH
9489: LD_STRING Platonov
9491: PPUSH
9492: CALL_OW 25
9496: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9497: LD_ADDR_EXP 61
9501: PUSH
9502: LD_STRING Yakotich
9504: PPUSH
9505: LD_EXP 1
9509: NOT
9510: PPUSH
9511: LD_STRING 09_
9513: PPUSH
9514: CALL 53324 0 3
9518: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9519: LD_ADDR_EXP 62
9523: PUSH
9524: LD_STRING Gleb
9526: PPUSH
9527: CALL_OW 25
9531: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9532: LD_STRING 03_Cornel
9534: PPUSH
9535: CALL_OW 28
9539: IFFALSE 9587
// begin Bierezov := NewCharacter ( Mikhail ) ;
9541: LD_ADDR_EXP 63
9545: PUSH
9546: LD_STRING Mikhail
9548: PPUSH
9549: CALL_OW 25
9553: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9554: LD_EXP 63
9558: PPUSH
9559: LD_INT 197
9561: PPUSH
9562: LD_INT 111
9564: PPUSH
9565: LD_INT 9
9567: PPUSH
9568: LD_INT 0
9570: PPUSH
9571: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9575: LD_EXP 63
9579: PPUSH
9580: LD_INT 3
9582: PPUSH
9583: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9587: LD_EXP 60
9591: PPUSH
9592: LD_INT 126
9594: PPUSH
9595: CALL_OW 52
// if Yakotich then
9599: LD_EXP 61
9603: IFFALSE 9626
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9605: LD_EXP 61
9609: PPUSH
9610: LD_INT 197
9612: PPUSH
9613: LD_INT 111
9615: PPUSH
9616: LD_INT 9
9618: PPUSH
9619: LD_INT 0
9621: PPUSH
9622: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9626: LD_EXP 62
9630: PPUSH
9631: LD_INT 197
9633: PPUSH
9634: LD_INT 111
9636: PPUSH
9637: LD_INT 9
9639: PPUSH
9640: LD_INT 0
9642: PPUSH
9643: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9647: LD_ADDR_VAR 0 5
9651: PUSH
9652: LD_INT 126
9654: PPUSH
9655: LD_INT 2
9657: PPUSH
9658: LD_STRING zhukov
9660: PPUSH
9661: LD_INT 9
9663: PUSH
9664: LD_INT 10
9666: PUSH
9667: LD_INT 10
9669: PUSH
9670: LD_INT 10
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: LIST
9677: LIST
9678: PUSH
9679: LD_OWVAR 67
9683: ARRAY
9684: PPUSH
9685: LD_INT 9000
9687: PUSH
9688: LD_INT 1000
9690: PUSH
9691: LD_INT 300
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: LIST
9698: PPUSH
9699: LD_INT 21
9701: PUSH
9702: LD_INT 8
9704: PUSH
9705: LD_INT 13
9707: PUSH
9708: LD_INT 8
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: PPUSH
9717: CALL 61985 0 6
9721: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9722: LD_ADDR_EXP 78
9726: PUSH
9727: LD_EXP 78
9731: PPUSH
9732: LD_INT 2
9734: PPUSH
9735: LD_VAR 0 5
9739: PUSH
9740: LD_EXP 61
9744: PUSH
9745: LD_EXP 62
9749: PUSH
9750: LD_EXP 63
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: LIST
9759: UNION
9760: PPUSH
9761: CALL_OW 1
9765: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9766: LD_ADDR_VAR 0 4
9770: PUSH
9771: LD_INT 267
9773: PPUSH
9774: CALL_OW 274
9778: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9779: LD_VAR 0 4
9783: PPUSH
9784: LD_INT 1
9786: PPUSH
9787: LD_INT 5000
9789: PPUSH
9790: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9794: LD_VAR 0 4
9798: PPUSH
9799: LD_INT 2
9801: PPUSH
9802: LD_INT 200
9804: PPUSH
9805: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9809: LD_VAR 0 4
9813: PPUSH
9814: LD_INT 3
9816: PPUSH
9817: LD_INT 200
9819: PPUSH
9820: CALL_OW 277
// for i := 1 to 6 do
9824: LD_ADDR_VAR 0 2
9828: PUSH
9829: DOUBLE
9830: LD_INT 1
9832: DEC
9833: ST_TO_ADDR
9834: LD_INT 6
9836: PUSH
9837: FOR_TO
9838: IFFALSE 9921
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
9840: LD_INT 0
9842: PPUSH
9843: LD_INT 8
9845: PUSH
9846: LD_INT 9
9848: PUSH
9849: LD_INT 10
9851: PUSH
9852: LD_INT 10
9854: PUSH
9855: EMPTY
9856: LIST
9857: LIST
9858: LIST
9859: LIST
9860: PUSH
9861: LD_OWVAR 67
9865: ARRAY
9866: PPUSH
9867: CALL_OW 381
// un := CreateHuman ;
9871: LD_ADDR_VAR 0 8
9875: PUSH
9876: CALL_OW 44
9880: ST_TO_ADDR
// if i mod 2 = 0 then
9881: LD_VAR 0 2
9885: PUSH
9886: LD_INT 2
9888: MOD
9889: PUSH
9890: LD_INT 0
9892: EQUAL
9893: IFFALSE 9907
// SetClass ( un , class_bazooker ) ;
9895: LD_VAR 0 8
9899: PPUSH
9900: LD_INT 9
9902: PPUSH
9903: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
9907: LD_VAR 0 8
9911: PPUSH
9912: LD_INT 674
9914: PPUSH
9915: CALL_OW 52
// end ;
9919: GO 9837
9921: POP
9922: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
9923: LD_INT 21
9925: PPUSH
9926: LD_INT 3
9928: PPUSH
9929: LD_INT 3
9931: PPUSH
9932: LD_INT 52
9934: PPUSH
9935: LD_INT 100
9937: PPUSH
9938: CALL 58164 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
9942: CALL_OW 45
9946: PPUSH
9947: LD_INT 259
9949: PPUSH
9950: LD_INT 145
9952: PPUSH
9953: LD_INT 3
9955: PPUSH
9956: LD_INT 0
9958: PPUSH
9959: CALL 93155 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
9963: CALL_OW 45
9967: PPUSH
9968: LD_INT 245
9970: PPUSH
9971: LD_INT 139
9973: PPUSH
9974: LD_INT 3
9976: PPUSH
9977: LD_INT 0
9979: PPUSH
9980: CALL 93155 0 5
// behemoths := [ ] ;
9984: LD_ADDR_EXP 64
9988: PUSH
9989: EMPTY
9990: ST_TO_ADDR
// behemothBuilders := [ ] ;
9991: LD_ADDR_EXP 65
9995: PUSH
9996: EMPTY
9997: ST_TO_ADDR
// j := 3 ;
9998: LD_ADDR_VAR 0 3
10002: PUSH
10003: LD_INT 3
10005: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
10006: LD_ADDR_VAR 0 2
10010: PUSH
10011: LD_INT 22
10013: PUSH
10014: LD_INT 3
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PUSH
10021: LD_INT 25
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PPUSH
10035: CALL_OW 69
10039: PUSH
10040: FOR_IN
10041: IFFALSE 10091
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
10043: LD_ADDR_EXP 65
10047: PUSH
10048: LD_EXP 65
10052: PPUSH
10053: LD_VAR 0 2
10057: PPUSH
10058: CALL 91015 0 2
10062: ST_TO_ADDR
// j := j - 1 ;
10063: LD_ADDR_VAR 0 3
10067: PUSH
10068: LD_VAR 0 3
10072: PUSH
10073: LD_INT 1
10075: MINUS
10076: ST_TO_ADDR
// if j = 0 then
10077: LD_VAR 0 3
10081: PUSH
10082: LD_INT 0
10084: EQUAL
10085: IFFALSE 10089
// break ;
10087: GO 10091
// end ;
10089: GO 10040
10091: POP
10092: POP
// end ;
10093: LD_VAR 0 1
10097: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
10098: LD_INT 0
10100: PPUSH
10101: PPUSH
10102: PPUSH
10103: PPUSH
10104: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
10105: LD_ADDR_VAR 0 4
10109: PUSH
10110: LD_INT 209
10112: PUSH
10113: LD_INT 149
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 219
10122: PUSH
10123: LD_INT 154
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PUSH
10130: LD_INT 223
10132: PUSH
10133: LD_INT 149
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: PUSH
10140: LD_INT 232
10142: PUSH
10143: LD_INT 155
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: ST_TO_ADDR
// if not behemothBuilders then
10156: LD_EXP 65
10160: NOT
10161: IFFALSE 10165
// exit ;
10163: GO 10269
// j := 1 ;
10165: LD_ADDR_VAR 0 3
10169: PUSH
10170: LD_INT 1
10172: ST_TO_ADDR
// for i in behemothBuilders do
10173: LD_ADDR_VAR 0 2
10177: PUSH
10178: LD_EXP 65
10182: PUSH
10183: FOR_IN
10184: IFFALSE 10267
// begin if IsInUnit ( i ) then
10186: LD_VAR 0 2
10190: PPUSH
10191: CALL_OW 310
10195: IFFALSE 10206
// ComExitBuilding ( i ) ;
10197: LD_VAR 0 2
10201: PPUSH
10202: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
10206: LD_VAR 0 2
10210: PPUSH
10211: LD_INT 37
10213: PPUSH
10214: LD_VAR 0 4
10218: PUSH
10219: LD_VAR 0 3
10223: ARRAY
10224: PUSH
10225: LD_INT 1
10227: ARRAY
10228: PPUSH
10229: LD_VAR 0 4
10233: PUSH
10234: LD_VAR 0 3
10238: ARRAY
10239: PUSH
10240: LD_INT 2
10242: ARRAY
10243: PPUSH
10244: LD_INT 0
10246: PPUSH
10247: CALL_OW 230
// j := j + 1 ;
10251: LD_ADDR_VAR 0 3
10255: PUSH
10256: LD_VAR 0 3
10260: PUSH
10261: LD_INT 1
10263: PLUS
10264: ST_TO_ADDR
// end ;
10265: GO 10183
10267: POP
10268: POP
// end ;
10269: LD_VAR 0 1
10273: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10274: LD_INT 3
10276: PPUSH
10277: CALL 91076 0 1
10281: PUSH
10282: LD_INT 22
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: PUSH
10292: LD_INT 30
10294: PUSH
10295: LD_INT 37
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: PPUSH
10306: CALL_OW 69
10310: NOT
10311: AND
10312: IFFALSE 10498
10314: GO 10316
10316: DISABLE
10317: LD_INT 0
10319: PPUSH
10320: PPUSH
// begin enable ;
10321: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10322: LD_ADDR_VAR 0 2
10326: PUSH
10327: LD_INT 3
10329: PPUSH
10330: CALL 91076 0 1
10334: ST_TO_ADDR
// for i in tmp do
10335: LD_ADDR_VAR 0 1
10339: PUSH
10340: LD_VAR 0 2
10344: PUSH
10345: FOR_IN
10346: IFFALSE 10496
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10348: LD_VAR 0 1
10352: PPUSH
10353: LD_INT 7
10355: PPUSH
10356: CALL_OW 308
10360: PUSH
10361: LD_VAR 0 1
10365: PPUSH
10366: CALL_OW 110
10370: PUSH
10371: LD_INT 2
10373: EQUAL
10374: NOT
10375: AND
10376: IFFALSE 10390
// SetTag ( i , 2 ) ;
10378: LD_VAR 0 1
10382: PPUSH
10383: LD_INT 2
10385: PPUSH
10386: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10390: LD_INT 81
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: PUSH
10400: LD_INT 91
10402: PUSH
10403: LD_VAR 0 1
10407: PUSH
10408: LD_INT 12
10410: PUSH
10411: EMPTY
10412: LIST
10413: LIST
10414: LIST
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: PPUSH
10420: CALL_OW 69
10424: NOT
10425: PUSH
10426: LD_VAR 0 1
10430: PPUSH
10431: CALL_OW 110
10435: PUSH
10436: LD_INT 2
10438: EQUAL
10439: NOT
10440: AND
10441: IFFALSE 10460
// ComAgressiveMove ( i , 64 , 93 ) else
10443: LD_VAR 0 1
10447: PPUSH
10448: LD_INT 64
10450: PPUSH
10451: LD_INT 93
10453: PPUSH
10454: CALL_OW 114
10458: GO 10494
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10460: LD_VAR 0 1
10464: PPUSH
10465: LD_INT 81
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: EMPTY
10472: LIST
10473: LIST
10474: PPUSH
10475: CALL_OW 69
10479: PPUSH
10480: LD_VAR 0 1
10484: PPUSH
10485: CALL_OW 74
10489: PPUSH
10490: CALL_OW 115
// end ;
10494: GO 10345
10496: POP
10497: POP
// end ;
10498: PPOPN 2
10500: END
// every 9 9$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10501: LD_EXP 2
10505: NOT
10506: IFFALSE 11567
10508: GO 10510
10510: DISABLE
10511: LD_INT 0
10513: PPUSH
10514: PPUSH
10515: PPUSH
10516: PPUSH
10517: PPUSH
// begin enable ;
10518: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10519: LD_INT 22
10521: PUSH
10522: LD_INT 3
10524: PUSH
10525: EMPTY
10526: LIST
10527: LIST
10528: PUSH
10529: LD_INT 30
10531: PUSH
10532: LD_INT 3
10534: PUSH
10535: EMPTY
10536: LIST
10537: LIST
10538: PUSH
10539: EMPTY
10540: LIST
10541: LIST
10542: PPUSH
10543: CALL_OW 69
10547: NOT
10548: IFFALSE 10552
// exit ;
10550: GO 11567
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10552: LD_ADDR_VAR 0 4
10556: PUSH
10557: LD_INT 22
10559: PUSH
10560: LD_INT 3
10562: PUSH
10563: EMPTY
10564: LIST
10565: LIST
10566: PUSH
10567: LD_INT 30
10569: PUSH
10570: LD_INT 34
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PUSH
10577: EMPTY
10578: LIST
10579: LIST
10580: PPUSH
10581: CALL_OW 69
10585: ST_TO_ADDR
// if Prob ( 40 ) then
10586: LD_INT 40
10588: PPUSH
10589: CALL_OW 13
10593: IFFALSE 10720
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10595: LD_INT 2
10597: PPUSH
10598: LD_INT 22
10600: PUSH
10601: LD_INT 3
10603: PUSH
10604: LD_INT 3
10606: PUSH
10607: LD_INT 49
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: PUSH
10616: LD_INT 22
10618: PUSH
10619: LD_INT 3
10621: PUSH
10622: LD_INT 3
10624: PUSH
10625: LD_INT 49
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: LIST
10632: LIST
10633: PUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 3
10639: PUSH
10640: LD_INT 3
10642: PUSH
10643: LD_INT 49
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: LIST
10650: LIST
10651: PUSH
10652: LD_INT 24
10654: PUSH
10655: LD_INT 3
10657: PUSH
10658: LD_INT 3
10660: PUSH
10661: LD_INT 46
10663: PUSH
10664: EMPTY
10665: LIST
10666: LIST
10667: LIST
10668: LIST
10669: PUSH
10670: LD_INT 24
10672: PUSH
10673: LD_INT 3
10675: PUSH
10676: LD_INT 3
10678: PUSH
10679: LD_INT 46
10681: PUSH
10682: EMPTY
10683: LIST
10684: LIST
10685: LIST
10686: LIST
10687: PUSH
10688: LD_INT 24
10690: PUSH
10691: LD_INT 3
10693: PUSH
10694: LD_INT 3
10696: PUSH
10697: LD_INT 46
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: LIST
10704: LIST
10705: PUSH
10706: EMPTY
10707: LIST
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: LIST
10713: PPUSH
10714: CALL 46898 0 2
// end else
10718: GO 10843
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10720: LD_INT 2
10722: PPUSH
10723: LD_INT 24
10725: PUSH
10726: LD_INT 3
10728: PUSH
10729: LD_INT 3
10731: PUSH
10732: LD_INT 47
10734: PUSH
10735: EMPTY
10736: LIST
10737: LIST
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 24
10743: PUSH
10744: LD_INT 3
10746: PUSH
10747: LD_INT 3
10749: PUSH
10750: LD_INT 47
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: PUSH
10759: LD_INT 24
10761: PUSH
10762: LD_INT 3
10764: PUSH
10765: LD_INT 3
10767: PUSH
10768: LD_INT 47
10770: PUSH
10771: EMPTY
10772: LIST
10773: LIST
10774: LIST
10775: LIST
10776: PUSH
10777: LD_INT 24
10779: PUSH
10780: LD_INT 3
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 46
10788: PUSH
10789: EMPTY
10790: LIST
10791: LIST
10792: LIST
10793: LIST
10794: PUSH
10795: LD_INT 24
10797: PUSH
10798: LD_INT 3
10800: PUSH
10801: LD_INT 3
10803: PUSH
10804: LD_INT 46
10806: PUSH
10807: EMPTY
10808: LIST
10809: LIST
10810: LIST
10811: LIST
10812: PUSH
10813: LD_INT 24
10815: PUSH
10816: LD_INT 3
10818: PUSH
10819: LD_INT 3
10821: PUSH
10822: LD_INT 46
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: LIST
10829: LIST
10830: PUSH
10831: EMPTY
10832: LIST
10833: LIST
10834: LIST
10835: LIST
10836: LIST
10837: LIST
10838: PPUSH
10839: CALL 46898 0 2
// end ; if Difficulty > 1 then
10843: LD_OWVAR 67
10847: PUSH
10848: LD_INT 1
10850: GREATER
10851: IFFALSE 10881
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10853: LD_INT 2
10855: PPUSH
10856: LD_INT 24
10858: PUSH
10859: LD_INT 3
10861: PUSH
10862: LD_INT 3
10864: PUSH
10865: LD_INT 47
10867: PUSH
10868: EMPTY
10869: LIST
10870: LIST
10871: LIST
10872: LIST
10873: PUSH
10874: EMPTY
10875: LIST
10876: PPUSH
10877: CALL 46898 0 2
// p := 0 ;
10881: LD_ADDR_VAR 0 5
10885: PUSH
10886: LD_INT 0
10888: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10889: LD_INT 35
10891: PPUSH
10892: CALL_OW 67
// p := Inc ( p ) ;
10896: LD_ADDR_VAR 0 5
10900: PUSH
10901: LD_VAR 0 5
10905: PPUSH
10906: CALL 92376 0 1
10910: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 120 ;
10911: LD_INT 2
10913: PPUSH
10914: LD_INT 1
10916: PPUSH
10917: CALL 48316 0 2
10921: PUSH
10922: LD_INT 6
10924: PUSH
10925: LD_INT 7
10927: PUSH
10928: LD_INT 7
10930: PUSH
10931: LD_INT 7
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: LIST
10938: LIST
10939: PUSH
10940: LD_OWVAR 67
10944: ARRAY
10945: GREATEREQUAL
10946: PUSH
10947: LD_VAR 0 5
10951: PUSH
10952: LD_INT 120
10954: GREATER
10955: OR
10956: IFFALSE 10889
// wait ( 0 0$30 ) ;
10958: LD_INT 1050
10960: PPUSH
10961: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
10965: LD_ADDR_VAR 0 2
10969: PUSH
10970: LD_INT 22
10972: PUSH
10973: LD_INT 3
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: PUSH
10980: LD_INT 21
10982: PUSH
10983: LD_INT 2
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: PUSH
10990: LD_INT 3
10992: PUSH
10993: LD_INT 34
10995: PUSH
10996: LD_INT 48
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: PUSH
11003: LD_INT 34
11005: PUSH
11006: LD_INT 51
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: PUSH
11013: LD_INT 34
11015: PUSH
11016: LD_INT 52
11018: PUSH
11019: EMPTY
11020: LIST
11021: LIST
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: PUSH
11029: EMPTY
11030: LIST
11031: LIST
11032: LIST
11033: PPUSH
11034: CALL_OW 69
11038: PUSH
11039: LD_EXP 100
11043: PUSH
11044: LD_INT 2
11046: ARRAY
11047: DIFF
11048: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11049: LD_ADDR_EXP 97
11053: PUSH
11054: LD_EXP 97
11058: PPUSH
11059: LD_INT 2
11061: PPUSH
11062: LD_EXP 97
11066: PUSH
11067: LD_INT 2
11069: ARRAY
11070: PUSH
11071: LD_VAR 0 2
11075: DIFF
11076: PPUSH
11077: CALL_OW 1
11081: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11082: LD_ADDR_VAR 0 3
11086: PUSH
11087: LD_INT 0
11089: PPUSH
11090: LD_INT 1
11092: PPUSH
11093: CALL_OW 12
11097: ST_TO_ADDR
// p := 0 ;
11098: LD_ADDR_VAR 0 5
11102: PUSH
11103: LD_INT 0
11105: ST_TO_ADDR
// if target then
11106: LD_VAR 0 3
11110: IFFALSE 11263
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11112: LD_ADDR_VAR 0 2
11116: PUSH
11117: LD_VAR 0 2
11121: PPUSH
11122: LD_INT 24
11124: PUSH
11125: LD_INT 250
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: PPUSH
11132: CALL_OW 72
11136: ST_TO_ADDR
// for i in tmp do
11137: LD_ADDR_VAR 0 1
11141: PUSH
11142: LD_VAR 0 2
11146: PUSH
11147: FOR_IN
11148: IFFALSE 11188
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11150: LD_VAR 0 1
11154: PPUSH
11155: LD_INT 139
11157: PPUSH
11158: LD_INT 89
11160: PPUSH
11161: CALL_OW 297
11165: PUSH
11166: LD_INT 9
11168: GREATER
11169: IFFALSE 11186
// ComMoveXY ( i , 139 , 89 ) ;
11171: LD_VAR 0 1
11175: PPUSH
11176: LD_INT 139
11178: PPUSH
11179: LD_INT 89
11181: PPUSH
11182: CALL_OW 111
11186: GO 11147
11188: POP
11189: POP
// wait ( 0 0$1 ) ;
11190: LD_INT 35
11192: PPUSH
11193: CALL_OW 67
// p := Inc ( p ) ;
11197: LD_ADDR_VAR 0 5
11201: PUSH
11202: LD_VAR 0 5
11206: PPUSH
11207: CALL 92376 0 1
11211: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11212: LD_VAR 0 2
11216: PPUSH
11217: LD_INT 92
11219: PUSH
11220: LD_INT 139
11222: PUSH
11223: LD_INT 89
11225: PUSH
11226: LD_INT 9
11228: PUSH
11229: EMPTY
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: PPUSH
11235: CALL_OW 72
11239: PUSH
11240: LD_VAR 0 2
11244: PUSH
11245: LD_INT 1
11247: MINUS
11248: GREATEREQUAL
11249: PUSH
11250: LD_VAR 0 5
11254: PUSH
11255: LD_INT 30
11257: GREATER
11258: OR
11259: IFFALSE 11112
// end else
11261: GO 11430
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11263: LD_VAR 0 2
11267: PPUSH
11268: LD_VAR 0 4
11272: PUSH
11273: LD_INT 1
11275: ARRAY
11276: PPUSH
11277: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11281: LD_ADDR_VAR 0 2
11285: PUSH
11286: LD_VAR 0 2
11290: PPUSH
11291: LD_INT 24
11293: PUSH
11294: LD_INT 250
11296: PUSH
11297: EMPTY
11298: LIST
11299: LIST
11300: PPUSH
11301: CALL_OW 72
11305: ST_TO_ADDR
// for i in tmp do
11306: LD_ADDR_VAR 0 1
11310: PUSH
11311: LD_VAR 0 2
11315: PUSH
11316: FOR_IN
11317: IFFALSE 11357
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11319: LD_VAR 0 1
11323: PPUSH
11324: LD_INT 124
11326: PPUSH
11327: LD_INT 139
11329: PPUSH
11330: CALL_OW 297
11334: PUSH
11335: LD_INT 9
11337: GREATER
11338: IFFALSE 11355
// ComMoveXY ( i , 124 , 139 ) ;
11340: LD_VAR 0 1
11344: PPUSH
11345: LD_INT 124
11347: PPUSH
11348: LD_INT 139
11350: PPUSH
11351: CALL_OW 111
11355: GO 11316
11357: POP
11358: POP
// wait ( 0 0$1 ) ;
11359: LD_INT 35
11361: PPUSH
11362: CALL_OW 67
// p := Inc ( p ) ;
11366: LD_ADDR_VAR 0 5
11370: PUSH
11371: LD_VAR 0 5
11375: PPUSH
11376: CALL 92376 0 1
11380: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11381: LD_VAR 0 2
11385: PPUSH
11386: LD_INT 92
11388: PUSH
11389: LD_INT 124
11391: PUSH
11392: LD_INT 139
11394: PUSH
11395: LD_INT 9
11397: PUSH
11398: EMPTY
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: PPUSH
11404: CALL_OW 72
11408: PUSH
11409: LD_VAR 0 2
11413: PUSH
11414: LD_INT 1
11416: MINUS
11417: GREATEREQUAL
11418: PUSH
11419: LD_VAR 0 5
11423: PUSH
11424: LD_INT 30
11426: GREATER
11427: OR
11428: IFFALSE 11281
// end ; repeat wait ( 0 0$1 ) ;
11430: LD_INT 35
11432: PPUSH
11433: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11437: LD_ADDR_VAR 0 2
11441: PUSH
11442: LD_VAR 0 2
11446: PPUSH
11447: LD_INT 50
11449: PUSH
11450: EMPTY
11451: LIST
11452: PPUSH
11453: CALL_OW 72
11457: ST_TO_ADDR
// for i in tmp do
11458: LD_ADDR_VAR 0 1
11462: PUSH
11463: LD_VAR 0 2
11467: PUSH
11468: FOR_IN
11469: IFFALSE 11558
// begin if GetWeapon ( i ) = ru_time_lapser then
11471: LD_VAR 0 1
11475: PPUSH
11476: CALL_OW 264
11480: PUSH
11481: LD_INT 49
11483: EQUAL
11484: IFFALSE 11522
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11486: LD_VAR 0 1
11490: PPUSH
11491: LD_INT 81
11493: PUSH
11494: LD_INT 3
11496: PUSH
11497: EMPTY
11498: LIST
11499: LIST
11500: PPUSH
11501: CALL_OW 69
11505: PPUSH
11506: LD_VAR 0 1
11510: PPUSH
11511: CALL_OW 74
11515: PPUSH
11516: CALL_OW 112
11520: GO 11556
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11522: LD_VAR 0 1
11526: PPUSH
11527: LD_INT 81
11529: PUSH
11530: LD_INT 3
11532: PUSH
11533: EMPTY
11534: LIST
11535: LIST
11536: PPUSH
11537: CALL_OW 69
11541: PPUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 74
11551: PPUSH
11552: CALL_OW 115
// end ;
11556: GO 11468
11558: POP
11559: POP
// until not tmp ;
11560: LD_VAR 0 2
11564: NOT
11565: IFFALSE 11430
// end ;
11567: PPOPN 5
11569: END
// every 30 30$00 trigger not russianDestroyed do
11570: LD_EXP 2
11574: NOT
11575: IFFALSE 11644
11577: GO 11579
11579: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11580: LD_INT 105000
11582: PUSH
11583: LD_INT 84000
11585: PUSH
11586: LD_INT 63000
11588: PUSH
11589: LD_INT 52500
11591: PUSH
11592: EMPTY
11593: LIST
11594: LIST
11595: LIST
11596: LIST
11597: PUSH
11598: LD_OWVAR 67
11602: ARRAY
11603: PPUSH
11604: CALL_OW 67
// if russianDestroyed then
11608: LD_EXP 2
11612: IFFALSE 11616
// exit ;
11614: GO 11644
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11616: LD_INT 2
11618: PPUSH
11619: LD_INT 23
11621: PUSH
11622: LD_INT 3
11624: PUSH
11625: LD_INT 1
11627: PUSH
11628: LD_INT 48
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: PUSH
11637: EMPTY
11638: LIST
11639: PPUSH
11640: CALL 46898 0 2
// end ; end_of_file
11644: END
// export function CustomEvent ( event ) ; begin
11645: LD_INT 0
11647: PPUSH
// end ;
11648: LD_VAR 0 2
11652: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11653: LD_VAR 0 2
11657: PPUSH
11658: LD_VAR 0 3
11662: PPUSH
11663: LD_INT 15
11665: PPUSH
11666: CALL_OW 309
11670: IFFALSE 11679
// YouLost ( MothContaminate ) ;
11672: LD_STRING MothContaminate
11674: PPUSH
11675: CALL_OW 104
// end ;
11679: PPOPN 3
11681: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11682: LD_VAR 0 2
11686: PPUSH
11687: LD_VAR 0 3
11691: PPUSH
11692: LD_INT 15
11694: PPUSH
11695: CALL_OW 309
11699: IFFALSE 11715
// begin wait ( 0 0$6 ) ;
11701: LD_INT 210
11703: PPUSH
11704: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11708: LD_STRING MothContaminateBomb
11710: PPUSH
11711: CALL_OW 104
// end ; end ;
11715: PPOPN 3
11717: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11718: LD_VAR 0 1
11722: PPUSH
11723: CALL 111914 0 1
// if un = JMM then
11727: LD_VAR 0 1
11731: PUSH
11732: LD_EXP 19
11736: EQUAL
11737: IFFALSE 11748
// begin YouLost ( JMM ) ;
11739: LD_STRING JMM
11741: PPUSH
11742: CALL_OW 104
// exit ;
11746: GO 11877
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11748: LD_VAR 0 1
11752: PPUSH
11753: CALL_OW 255
11757: PUSH
11758: LD_INT 2
11760: EQUAL
11761: PUSH
11762: LD_EXP 18
11766: NOT
11767: AND
11768: IFFALSE 11778
// arabianAttacked := true ;
11770: LD_ADDR_EXP 18
11774: PUSH
11775: LD_INT 1
11777: ST_TO_ADDR
// if un = Powell then
11778: LD_VAR 0 1
11782: PUSH
11783: LD_EXP 55
11787: EQUAL
11788: IFFALSE 11798
// americanDestroyed := true ;
11790: LD_ADDR_EXP 4
11794: PUSH
11795: LD_INT 1
11797: ST_TO_ADDR
// if un = Platonov then
11798: LD_VAR 0 1
11802: PUSH
11803: LD_EXP 60
11807: EQUAL
11808: IFFALSE 11818
// russianDestroyed := true ;
11810: LD_ADDR_EXP 2
11814: PUSH
11815: LD_INT 1
11817: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11818: LD_VAR 0 1
11822: PUSH
11823: LD_INT 22
11825: PUSH
11826: LD_INT 7
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: PUSH
11833: LD_INT 21
11835: PUSH
11836: LD_INT 2
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: PUSH
11843: EMPTY
11844: LIST
11845: LIST
11846: PPUSH
11847: CALL_OW 69
11851: IN
11852: IFFALSE 11868
// vehicleLostCounter := vehicleLostCounter + 1 ;
11854: LD_ADDR_EXP 15
11858: PUSH
11859: LD_EXP 15
11863: PUSH
11864: LD_INT 1
11866: PLUS
11867: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11868: LD_VAR 0 1
11872: PPUSH
11873: CALL 50340 0 1
// end ;
11877: PPOPN 1
11879: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11880: LD_VAR 0 1
11884: PPUSH
11885: LD_VAR 0 2
11889: PPUSH
11890: CALL 52672 0 2
// end ;
11894: PPOPN 2
11896: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11897: LD_VAR 0 1
11901: PPUSH
11902: CALL 51740 0 1
// end ;
11906: PPOPN 1
11908: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11909: LD_VAR 0 1
11913: PUSH
11914: LD_INT 22
11916: PUSH
11917: LD_INT 8
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: PUSH
11924: LD_INT 30
11926: PUSH
11927: LD_INT 2
11929: PUSH
11930: EMPTY
11931: LIST
11932: LIST
11933: PUSH
11934: LD_INT 23
11936: PUSH
11937: LD_INT 3
11939: PUSH
11940: EMPTY
11941: LIST
11942: LIST
11943: PUSH
11944: EMPTY
11945: LIST
11946: LIST
11947: LIST
11948: PPUSH
11949: CALL_OW 69
11953: IN
11954: IFFALSE 11981
// begin ComUpgrade ( building ) ;
11956: LD_VAR 0 1
11960: PPUSH
11961: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11965: LD_EXP 58
11969: PPUSH
11970: LD_VAR 0 1
11974: PPUSH
11975: CALL 61524 0 2
// exit ;
11979: GO 11990
// end ; MCE_BuildingComplete ( building ) ;
11981: LD_VAR 0 1
11985: PPUSH
11986: CALL 51981 0 1
// end ;
11990: PPOPN 1
11992: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11993: LD_VAR 0 1
11997: PPUSH
11998: LD_VAR 0 2
12002: PPUSH
12003: CALL 50036 0 2
// end ;
12007: PPOPN 2
12009: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12010: LD_VAR 0 1
12014: PPUSH
12015: LD_VAR 0 2
12019: PPUSH
12020: LD_VAR 0 3
12024: PPUSH
12025: LD_VAR 0 4
12029: PPUSH
12030: LD_VAR 0 5
12034: PPUSH
12035: CALL 49656 0 5
// end ;
12039: PPOPN 5
12041: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
12042: LD_VAR 0 1
12046: PPUSH
12047: LD_VAR 0 2
12051: PPUSH
12052: CALL 112034 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
12056: LD_VAR 0 1
12060: PPUSH
12061: LD_VAR 0 2
12065: PPUSH
12066: CALL 49209 0 2
// end ;
12070: PPOPN 2
12072: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12073: LD_VAR 0 1
12077: PPUSH
12078: LD_VAR 0 2
12082: PPUSH
12083: LD_VAR 0 3
12087: PPUSH
12088: LD_VAR 0 4
12092: PPUSH
12093: CALL 49047 0 4
// end ;
12097: PPOPN 4
12099: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12100: LD_VAR 0 1
12104: PPUSH
12105: LD_VAR 0 2
12109: PPUSH
12110: LD_VAR 0 3
12114: PPUSH
12115: CALL 48822 0 3
// end ;
12119: PPOPN 3
12121: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12122: LD_VAR 0 1
12126: PPUSH
12127: LD_VAR 0 2
12131: PPUSH
12132: CALL 48707 0 2
// end ;
12136: PPOPN 2
12138: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12139: LD_VAR 0 1
12143: PPUSH
12144: LD_VAR 0 2
12148: PPUSH
12149: CALL 52967 0 2
// end ;
12153: PPOPN 2
12155: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
12156: LD_VAR 0 1
12160: PUSH
12161: LD_INT 674
12163: EQUAL
12164: IFFALSE 12186
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
12166: LD_VAR 0 2
12170: PPUSH
12171: LD_INT 227
12173: PPUSH
12174: LD_INT 136
12176: PPUSH
12177: CALL_OW 428
12181: PPUSH
12182: CALL_OW 120
// end ;
12186: PPOPN 2
12188: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12189: LD_VAR 0 1
12193: PPUSH
12194: LD_VAR 0 2
12198: PPUSH
12199: LD_VAR 0 3
12203: PPUSH
12204: LD_VAR 0 4
12208: PPUSH
12209: CALL 53183 0 4
// end ;
12213: PPOPN 4
12215: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12216: LD_VAR 0 1
12220: PPUSH
12221: LD_VAR 0 2
12225: PPUSH
12226: CALL 48516 0 2
// end ;
12230: PPOPN 2
12232: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12233: LD_VAR 0 1
12237: PPUSH
12238: CALL 112018 0 1
// end ; end_of_file
12242: PPOPN 1
12244: END
// export function Action ; begin
12245: LD_INT 0
12247: PPUSH
// InGameOn ;
12248: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
12252: LD_INT 206
12254: PPUSH
12255: LD_INT 11
12257: PPUSH
12258: CALL_OW 86
// wait ( 0 0$1 ) ;
12262: LD_INT 35
12264: PPUSH
12265: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
12269: LD_EXP 19
12273: PPUSH
12274: LD_STRING DStart-JMM-JMM-1
12276: PPUSH
12277: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
12281: LD_EXP 52
12285: PPUSH
12286: LD_STRING DStart-JMM-Bur-1
12288: PPUSH
12289: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
12293: LD_EXP 19
12297: PPUSH
12298: LD_STRING DStart-JMM-JMM-2
12300: PPUSH
12301: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
12305: LD_EXP 52
12309: PPUSH
12310: LD_STRING DStart-JMM-Bur-2
12312: PPUSH
12313: CALL_OW 88
// InGameOff ;
12317: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
12321: LD_STRING MStart
12323: PPUSH
12324: CALL_OW 337
// SaveForQuickRestart ;
12328: CALL_OW 22
// end ;
12332: LD_VAR 0 1
12336: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
12337: LD_INT 7
12339: PPUSH
12340: LD_INT 255
12342: PPUSH
12343: LD_INT 219
12345: PPUSH
12346: CALL_OW 293
12350: IFFALSE 12959
12352: GO 12354
12354: DISABLE
12355: LD_INT 0
12357: PPUSH
// begin wait ( 0 0$3 ) ;
12358: LD_INT 105
12360: PPUSH
12361: CALL_OW 67
// alienSpotted := true ;
12365: LD_ADDR_EXP 10
12369: PUSH
12370: LD_INT 1
12372: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12373: LD_ADDR_VAR 0 1
12377: PUSH
12378: LD_INT 22
12380: PUSH
12381: LD_INT 7
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: PUSH
12388: LD_INT 23
12390: PUSH
12391: LD_INT 3
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: LD_INT 21
12400: PUSH
12401: LD_INT 1
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 26
12410: PUSH
12411: LD_INT 1
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: LIST
12422: LIST
12423: PPUSH
12424: CALL_OW 69
12428: PUSH
12429: LD_EXP 52
12433: PUSH
12434: LD_EXP 40
12438: PUSH
12439: LD_EXP 42
12443: PUSH
12444: LD_EXP 43
12448: PUSH
12449: LD_EXP 50
12453: PUSH
12454: LD_EXP 49
12458: PUSH
12459: LD_EXP 44
12463: PUSH
12464: EMPTY
12465: LIST
12466: LIST
12467: LIST
12468: LIST
12469: LIST
12470: LIST
12471: LIST
12472: DIFF
12473: ST_TO_ADDR
// DialogueOn ;
12474: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12478: LD_INT 255
12480: PPUSH
12481: LD_INT 219
12483: PPUSH
12484: LD_INT 7
12486: PPUSH
12487: LD_INT 20
12489: NEG
12490: PPUSH
12491: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12495: LD_INT 255
12497: PPUSH
12498: LD_INT 219
12500: PPUSH
12501: CALL_OW 86
// if speaker then
12505: LD_VAR 0 1
12509: IFFALSE 12527
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12511: LD_VAR 0 1
12515: PUSH
12516: LD_INT 1
12518: ARRAY
12519: PPUSH
12520: LD_STRING DAlienBase-RSol1-1
12522: PPUSH
12523: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12527: LD_EXP 19
12531: PPUSH
12532: LD_STRING DAlienBase-JMM-1
12534: PPUSH
12535: CALL_OW 88
// if IsOk ( Burlak ) then
12539: LD_EXP 52
12543: PPUSH
12544: CALL_OW 302
12548: IFFALSE 12569
// begin dwait ( 0 0$1 ) ;
12550: LD_INT 35
12552: PPUSH
12553: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12557: LD_EXP 52
12561: PPUSH
12562: LD_STRING DAlienBase-Bur-1
12564: PPUSH
12565: CALL_OW 88
// end ; if IsOk ( Roth ) then
12569: LD_EXP 20
12573: PPUSH
12574: CALL_OW 302
12578: IFFALSE 12592
// Say ( Roth , DAlienBase-Roth-1 ) ;
12580: LD_EXP 20
12584: PPUSH
12585: LD_STRING DAlienBase-Roth-1
12587: PPUSH
12588: CALL_OW 88
// if IsOk ( Gossudarov ) then
12592: LD_EXP 38
12596: PPUSH
12597: CALL_OW 302
12601: IFFALSE 12617
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12603: LD_EXP 38
12607: PPUSH
12608: LD_STRING DAlienBase-Gos-1
12610: PPUSH
12611: CALL_OW 88
12615: GO 12734
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12617: LD_ADDR_VAR 0 1
12621: PUSH
12622: LD_INT 22
12624: PUSH
12625: LD_INT 7
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 25
12634: PUSH
12635: LD_INT 4
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: LD_INT 21
12644: PUSH
12645: LD_INT 1
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PUSH
12652: LD_INT 26
12654: PUSH
12655: LD_INT 1
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: LIST
12666: LIST
12667: PPUSH
12668: CALL_OW 69
12672: PUSH
12673: LD_EXP 20
12677: PUSH
12678: LD_EXP 19
12682: PUSH
12683: LD_EXP 52
12687: PUSH
12688: LD_EXP 40
12692: PUSH
12693: LD_EXP 50
12697: PUSH
12698: LD_EXP 49
12702: PUSH
12703: EMPTY
12704: LIST
12705: LIST
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: DIFF
12711: ST_TO_ADDR
// if speaker then
12712: LD_VAR 0 1
12716: IFFALSE 12734
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12718: LD_VAR 0 1
12722: PUSH
12723: LD_INT 1
12725: ARRAY
12726: PPUSH
12727: LD_STRING DAlienBase-Sci1-1
12729: PPUSH
12730: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12734: LD_INT 255
12736: PPUSH
12737: LD_INT 219
12739: PPUSH
12740: LD_INT 7
12742: PPUSH
12743: CALL_OW 331
// DialogueOff ;
12747: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12751: LD_INT 35
12753: PPUSH
12754: CALL_OW 67
// until IsSelected ( alien ) ;
12758: LD_INT 1
12760: PPUSH
12761: CALL_OW 306
12765: IFFALSE 12751
// if not artifactIResearched or not artifactIIResearched then
12767: LD_EXP 12
12771: NOT
12772: PUSH
12773: LD_EXP 13
12777: NOT
12778: OR
12779: IFFALSE 12959
// begin if IsOk ( Roth ) then
12781: LD_EXP 20
12785: PPUSH
12786: CALL_OW 302
12790: IFFALSE 12806
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12792: LD_EXP 20
12796: PPUSH
12797: LD_STRING DAlieBaseNotReady-Roth-1
12799: PPUSH
12800: CALL_OW 88
12804: GO 12959
// if IsOk ( Gossudarov ) then
12806: LD_EXP 38
12810: PPUSH
12811: CALL_OW 302
12815: IFFALSE 12831
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12817: LD_EXP 38
12821: PPUSH
12822: LD_STRING DAlieBaseNotReady-Gos-1
12824: PPUSH
12825: CALL_OW 88
12829: GO 12959
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12831: LD_ADDR_VAR 0 1
12835: PUSH
12836: LD_INT 22
12838: PUSH
12839: LD_INT 7
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 23
12848: PUSH
12849: LD_INT 3
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: LD_INT 25
12858: PUSH
12859: LD_INT 4
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: LD_INT 21
12868: PUSH
12869: LD_INT 1
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: PUSH
12876: LD_INT 26
12878: PUSH
12879: LD_INT 1
12881: PUSH
12882: EMPTY
12883: LIST
12884: LIST
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: PPUSH
12893: CALL_OW 69
12897: PUSH
12898: LD_EXP 20
12902: PUSH
12903: LD_EXP 19
12907: PUSH
12908: LD_EXP 52
12912: PUSH
12913: LD_EXP 40
12917: PUSH
12918: LD_EXP 50
12922: PUSH
12923: LD_EXP 49
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: DIFF
12936: ST_TO_ADDR
// if speaker then
12937: LD_VAR 0 1
12941: IFFALSE 12959
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12943: LD_VAR 0 1
12947: PUSH
12948: LD_INT 1
12950: ARRAY
12951: PPUSH
12952: LD_STRING DAlieBaseNotReady-RSci1-1
12954: PPUSH
12955: CALL_OW 88
// end ; end ; end ;
12959: PPOPN 1
12961: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12962: LD_INT 24
12964: PPUSH
12965: LD_INT 7
12967: PPUSH
12968: CALL_OW 321
12972: PUSH
12973: LD_INT 2
12975: EQUAL
12976: IFFALSE 13667
12978: GO 12980
12980: DISABLE
12981: LD_INT 0
12983: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12984: LD_ADDR_VAR 0 1
12988: PUSH
12989: LD_INT 22
12991: PUSH
12992: LD_INT 7
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PUSH
12999: LD_INT 23
13001: PUSH
13002: LD_INT 3
13004: PUSH
13005: EMPTY
13006: LIST
13007: LIST
13008: PUSH
13009: LD_INT 25
13011: PUSH
13012: LD_INT 4
13014: PUSH
13015: EMPTY
13016: LIST
13017: LIST
13018: PUSH
13019: LD_INT 21
13021: PUSH
13022: LD_INT 1
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: PUSH
13029: LD_INT 26
13031: PUSH
13032: LD_INT 1
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: PPUSH
13046: CALL_OW 69
13050: PUSH
13051: LD_EXP 20
13055: PUSH
13056: LD_EXP 19
13060: PUSH
13061: LD_EXP 52
13065: PUSH
13066: LD_EXP 40
13070: PUSH
13071: LD_EXP 50
13075: PUSH
13076: LD_EXP 49
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: DIFF
13089: ST_TO_ADDR
// if not speaker then
13090: LD_VAR 0 1
13094: NOT
13095: IFFALSE 13099
// exit ;
13097: GO 13667
// DialogueOn ;
13099: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
13103: LD_VAR 0 1
13107: PUSH
13108: LD_INT 1
13110: ARRAY
13111: PPUSH
13112: LD_STRING DArtefTechnology-RSci1-1
13114: PPUSH
13115: CALL_OW 88
// if IsOk ( Burlak ) then
13119: LD_EXP 52
13123: PPUSH
13124: CALL_OW 302
13128: IFFALSE 13142
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
13130: LD_EXP 52
13134: PPUSH
13135: LD_STRING DArtefTechnology-Bur-1
13137: PPUSH
13138: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
13142: LD_VAR 0 1
13146: PUSH
13147: LD_INT 1
13149: ARRAY
13150: PPUSH
13151: LD_STRING DArtefTechnology-RSci1-2
13153: PPUSH
13154: CALL_OW 88
// if Denis then
13158: LD_EXP 25
13162: IFFALSE 13179
// speaker := [ Denis ] else
13164: LD_ADDR_VAR 0 1
13168: PUSH
13169: LD_EXP 25
13173: PUSH
13174: EMPTY
13175: LIST
13176: ST_TO_ADDR
13177: GO 13285
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13179: LD_ADDR_VAR 0 1
13183: PUSH
13184: LD_INT 22
13186: PUSH
13187: LD_INT 7
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PUSH
13194: LD_INT 23
13196: PUSH
13197: LD_INT 1
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: PUSH
13204: LD_INT 25
13206: PUSH
13207: LD_INT 4
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 21
13216: PUSH
13217: LD_INT 1
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PUSH
13224: LD_INT 26
13226: PUSH
13227: LD_INT 1
13229: PUSH
13230: EMPTY
13231: LIST
13232: LIST
13233: PUSH
13234: EMPTY
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: LIST
13240: PPUSH
13241: CALL_OW 69
13245: PUSH
13246: LD_EXP 20
13250: PUSH
13251: LD_EXP 19
13255: PUSH
13256: LD_EXP 52
13260: PUSH
13261: LD_EXP 40
13265: PUSH
13266: LD_EXP 50
13270: PUSH
13271: LD_EXP 49
13275: PUSH
13276: EMPTY
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: LIST
13282: LIST
13283: DIFF
13284: ST_TO_ADDR
// if speaker then
13285: LD_VAR 0 1
13289: IFFALSE 13307
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
13291: LD_VAR 0 1
13295: PUSH
13296: LD_INT 1
13298: ARRAY
13299: PPUSH
13300: LD_STRING DArtefTechnology-Sci1-2
13302: PPUSH
13303: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13307: LD_ADDR_VAR 0 1
13311: PUSH
13312: LD_INT 22
13314: PUSH
13315: LD_INT 7
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PUSH
13322: LD_INT 23
13324: PUSH
13325: LD_INT 3
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PUSH
13332: LD_INT 25
13334: PUSH
13335: LD_INT 4
13337: PUSH
13338: EMPTY
13339: LIST
13340: LIST
13341: PUSH
13342: LD_INT 21
13344: PUSH
13345: LD_INT 1
13347: PUSH
13348: EMPTY
13349: LIST
13350: LIST
13351: PUSH
13352: LD_INT 26
13354: PUSH
13355: LD_INT 1
13357: PUSH
13358: EMPTY
13359: LIST
13360: LIST
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: PPUSH
13369: CALL_OW 69
13373: PUSH
13374: LD_EXP 20
13378: PUSH
13379: LD_EXP 19
13383: PUSH
13384: LD_EXP 52
13388: PUSH
13389: LD_EXP 40
13393: PUSH
13394: LD_EXP 50
13398: PUSH
13399: LD_EXP 49
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: LIST
13408: LIST
13409: LIST
13410: LIST
13411: DIFF
13412: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13413: LD_VAR 0 1
13417: PUSH
13418: LD_EXP 9
13422: PUSH
13423: LD_EXP 5
13427: OR
13428: AND
13429: IFFALSE 13663
// begin if arabianDestroyed and IsOk ( Burlak ) then
13431: LD_EXP 5
13435: PUSH
13436: LD_EXP 52
13440: PPUSH
13441: CALL_OW 302
13445: AND
13446: IFFALSE 13462
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13448: LD_EXP 52
13452: PPUSH
13453: LD_STRING DArtefTechnology-Bur-2
13455: PPUSH
13456: CALL_OW 88
13460: GO 13474
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13462: LD_EXP 19
13466: PPUSH
13467: LD_STRING DArtefTechnology-JMM-2
13469: PPUSH
13470: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13474: LD_VAR 0 1
13478: PUSH
13479: LD_INT 1
13481: ARRAY
13482: PPUSH
13483: LD_STRING DArtefTechnology-RSci1-3
13485: PPUSH
13486: CALL_OW 88
// if Denis then
13490: LD_EXP 25
13494: IFFALSE 13511
// speaker := [ Denis ] else
13496: LD_ADDR_VAR 0 1
13500: PUSH
13501: LD_EXP 25
13505: PUSH
13506: EMPTY
13507: LIST
13508: ST_TO_ADDR
13509: GO 13617
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13511: LD_ADDR_VAR 0 1
13515: PUSH
13516: LD_INT 22
13518: PUSH
13519: LD_INT 7
13521: PUSH
13522: EMPTY
13523: LIST
13524: LIST
13525: PUSH
13526: LD_INT 23
13528: PUSH
13529: LD_INT 1
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: LD_INT 25
13538: PUSH
13539: LD_INT 4
13541: PUSH
13542: EMPTY
13543: LIST
13544: LIST
13545: PUSH
13546: LD_INT 21
13548: PUSH
13549: LD_INT 1
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: LD_INT 26
13558: PUSH
13559: LD_INT 1
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PUSH
13566: EMPTY
13567: LIST
13568: LIST
13569: LIST
13570: LIST
13571: LIST
13572: PPUSH
13573: CALL_OW 69
13577: PUSH
13578: LD_EXP 20
13582: PUSH
13583: LD_EXP 19
13587: PUSH
13588: LD_EXP 52
13592: PUSH
13593: LD_EXP 40
13597: PUSH
13598: LD_EXP 50
13602: PUSH
13603: LD_EXP 49
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: LIST
13614: LIST
13615: DIFF
13616: ST_TO_ADDR
// if speaker then
13617: LD_VAR 0 1
13621: IFFALSE 13663
// if alienSpotted then
13623: LD_EXP 10
13627: IFFALSE 13647
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13629: LD_VAR 0 1
13633: PUSH
13634: LD_INT 1
13636: ARRAY
13637: PPUSH
13638: LD_STRING DArtefTechnology-Sci1-3
13640: PPUSH
13641: CALL_OW 88
13645: GO 13663
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13647: LD_VAR 0 1
13651: PUSH
13652: LD_INT 1
13654: ARRAY
13655: PPUSH
13656: LD_STRING DArtefTechnology-Sci1-3a
13658: PPUSH
13659: CALL_OW 88
// end ; DialogueOff ;
13663: CALL_OW 7
// end ;
13667: PPOPN 1
13669: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13670: LD_EXP 12
13674: IFFALSE 13877
13676: GO 13678
13678: DISABLE
13679: LD_INT 0
13681: PPUSH
// begin if Denis then
13682: LD_EXP 25
13686: IFFALSE 13703
// speaker := [ Denis ] else
13688: LD_ADDR_VAR 0 1
13692: PUSH
13693: LD_EXP 25
13697: PUSH
13698: EMPTY
13699: LIST
13700: ST_TO_ADDR
13701: GO 13809
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13703: LD_ADDR_VAR 0 1
13707: PUSH
13708: LD_INT 22
13710: PUSH
13711: LD_INT 7
13713: PUSH
13714: EMPTY
13715: LIST
13716: LIST
13717: PUSH
13718: LD_INT 23
13720: PUSH
13721: LD_INT 1
13723: PUSH
13724: EMPTY
13725: LIST
13726: LIST
13727: PUSH
13728: LD_INT 25
13730: PUSH
13731: LD_INT 4
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: PUSH
13738: LD_INT 21
13740: PUSH
13741: LD_INT 1
13743: PUSH
13744: EMPTY
13745: LIST
13746: LIST
13747: PUSH
13748: LD_INT 26
13750: PUSH
13751: LD_INT 1
13753: PUSH
13754: EMPTY
13755: LIST
13756: LIST
13757: PUSH
13758: EMPTY
13759: LIST
13760: LIST
13761: LIST
13762: LIST
13763: LIST
13764: PPUSH
13765: CALL_OW 69
13769: PUSH
13770: LD_EXP 20
13774: PUSH
13775: LD_EXP 19
13779: PUSH
13780: LD_EXP 52
13784: PUSH
13785: LD_EXP 40
13789: PUSH
13790: LD_EXP 50
13794: PUSH
13795: LD_EXP 49
13799: PUSH
13800: EMPTY
13801: LIST
13802: LIST
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: DIFF
13808: ST_TO_ADDR
// if not speaker then
13809: LD_VAR 0 1
13813: NOT
13814: IFFALSE 13818
// exit ;
13816: GO 13877
// DialogueOn ;
13818: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13822: LD_VAR 0 1
13826: PUSH
13827: LD_INT 1
13829: ARRAY
13830: PPUSH
13831: LD_STRING DArtefTechnologyAm-Sci1-1
13833: PPUSH
13834: CALL_OW 88
// if IsOk ( Burlak ) then
13838: LD_EXP 52
13842: PPUSH
13843: CALL_OW 302
13847: IFFALSE 13861
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13849: LD_EXP 52
13853: PPUSH
13854: LD_STRING DArtefTechnologyAm-Bur-1
13856: PPUSH
13857: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13861: LD_EXP 19
13865: PPUSH
13866: LD_STRING DArtefTechnologyAm-JMM-1
13868: PPUSH
13869: CALL_OW 88
// DialogueOff ;
13873: CALL_OW 7
// end ;
13877: PPOPN 1
13879: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13880: LD_EXP 13
13884: IFFALSE 14086
13886: GO 13888
13888: DISABLE
13889: LD_INT 0
13891: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13892: LD_ADDR_VAR 0 1
13896: PUSH
13897: LD_INT 22
13899: PUSH
13900: LD_INT 7
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: PUSH
13907: LD_INT 23
13909: PUSH
13910: LD_INT 3
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: PUSH
13917: LD_INT 25
13919: PUSH
13920: LD_INT 4
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: PUSH
13927: LD_INT 21
13929: PUSH
13930: LD_INT 1
13932: PUSH
13933: EMPTY
13934: LIST
13935: LIST
13936: PUSH
13937: LD_INT 26
13939: PUSH
13940: LD_INT 1
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: PUSH
13947: EMPTY
13948: LIST
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: PPUSH
13954: CALL_OW 69
13958: PUSH
13959: LD_EXP 20
13963: PUSH
13964: LD_EXP 19
13968: PUSH
13969: LD_EXP 52
13973: PUSH
13974: LD_EXP 40
13978: PUSH
13979: LD_EXP 50
13983: PUSH
13984: LD_EXP 49
13988: PUSH
13989: EMPTY
13990: LIST
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: LIST
13996: DIFF
13997: ST_TO_ADDR
// if not speaker then
13998: LD_VAR 0 1
14002: NOT
14003: IFFALSE 14007
// exit ;
14005: GO 14086
// DialogueOn ;
14007: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
14011: LD_VAR 0 1
14015: PUSH
14016: LD_VAR 0 1
14020: ARRAY
14021: PPUSH
14022: LD_STRING DArtefTechnologyRu-RSci1-1
14024: PPUSH
14025: CALL_OW 88
// if IsOk ( Burlak ) then
14029: LD_EXP 52
14033: PPUSH
14034: CALL_OW 302
14038: IFFALSE 14052
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
14040: LD_EXP 52
14044: PPUSH
14045: LD_STRING DArtefTechnologyRu-Bur-1
14047: PPUSH
14048: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
14052: LD_VAR 0 1
14056: PUSH
14057: LD_VAR 0 1
14061: ARRAY
14062: PPUSH
14063: LD_STRING DArtefTechnologyRu-RSci1-2
14065: PPUSH
14066: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
14070: LD_EXP 19
14074: PPUSH
14075: LD_STRING DArtefTechnologyRu-JMM-1
14077: PPUSH
14078: CALL_OW 88
// DialogueOff ;
14082: CALL_OW 7
// end ;
14086: PPOPN 1
14088: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
14089: LD_INT 24
14091: PPUSH
14092: LD_INT 7
14094: PPUSH
14095: CALL_OW 321
14099: PUSH
14100: LD_INT 2
14102: EQUAL
14103: PUSH
14104: LD_INT 1
14106: PPUSH
14107: CALL_OW 255
14111: PUSH
14112: LD_INT 7
14114: EQUAL
14115: AND
14116: IFFALSE 14284
14118: GO 14120
14120: DISABLE
14121: LD_INT 0
14123: PPUSH
// begin if Denis then
14124: LD_EXP 25
14128: IFFALSE 14145
// speaker := [ Denis ] else
14130: LD_ADDR_VAR 0 1
14134: PUSH
14135: LD_EXP 25
14139: PUSH
14140: EMPTY
14141: LIST
14142: ST_TO_ADDR
14143: GO 14251
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14145: LD_ADDR_VAR 0 1
14149: PUSH
14150: LD_INT 22
14152: PUSH
14153: LD_INT 7
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: PUSH
14160: LD_INT 23
14162: PUSH
14163: LD_INT 1
14165: PUSH
14166: EMPTY
14167: LIST
14168: LIST
14169: PUSH
14170: LD_INT 25
14172: PUSH
14173: LD_INT 4
14175: PUSH
14176: EMPTY
14177: LIST
14178: LIST
14179: PUSH
14180: LD_INT 21
14182: PUSH
14183: LD_INT 1
14185: PUSH
14186: EMPTY
14187: LIST
14188: LIST
14189: PUSH
14190: LD_INT 26
14192: PUSH
14193: LD_INT 1
14195: PUSH
14196: EMPTY
14197: LIST
14198: LIST
14199: PUSH
14200: EMPTY
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: LIST
14206: PPUSH
14207: CALL_OW 69
14211: PUSH
14212: LD_EXP 20
14216: PUSH
14217: LD_EXP 19
14221: PUSH
14222: LD_EXP 52
14226: PUSH
14227: LD_EXP 40
14231: PUSH
14232: LD_EXP 50
14236: PUSH
14237: LD_EXP 49
14241: PUSH
14242: EMPTY
14243: LIST
14244: LIST
14245: LIST
14246: LIST
14247: LIST
14248: LIST
14249: DIFF
14250: ST_TO_ADDR
// if not speaker then
14251: LD_VAR 0 1
14255: NOT
14256: IFFALSE 14260
// exit ;
14258: GO 14284
// DialogueOn ;
14260: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
14264: LD_VAR 0 1
14268: PUSH
14269: LD_INT 1
14271: ARRAY
14272: PPUSH
14273: LD_STRING DArtefTechnologyArStart-Sci1-1
14275: PPUSH
14276: CALL_OW 88
// DialogueOff ;
14280: CALL_OW 7
// end ;
14284: PPOPN 1
14286: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
14287: LD_EXP 14
14291: IFFALSE 14572
14293: GO 14295
14295: DISABLE
14296: LD_INT 0
14298: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14299: LD_ADDR_VAR 0 1
14303: PUSH
14304: LD_INT 22
14306: PUSH
14307: LD_INT 7
14309: PUSH
14310: EMPTY
14311: LIST
14312: LIST
14313: PUSH
14314: LD_INT 23
14316: PUSH
14317: LD_INT 3
14319: PUSH
14320: EMPTY
14321: LIST
14322: LIST
14323: PUSH
14324: LD_INT 25
14326: PUSH
14327: LD_INT 4
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: LD_INT 21
14336: PUSH
14337: LD_INT 1
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: LD_INT 26
14346: PUSH
14347: LD_INT 1
14349: PUSH
14350: EMPTY
14351: LIST
14352: LIST
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: PPUSH
14361: CALL_OW 69
14365: PUSH
14366: LD_EXP 20
14370: PUSH
14371: LD_EXP 19
14375: PUSH
14376: LD_EXP 52
14380: PUSH
14381: LD_EXP 40
14385: PUSH
14386: LD_EXP 50
14390: PUSH
14391: LD_EXP 49
14395: PUSH
14396: EMPTY
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: DIFF
14404: ST_TO_ADDR
// if not speaker then
14405: LD_VAR 0 1
14409: NOT
14410: IFFALSE 14414
// exit ;
14412: GO 14572
// DialogueOn ;
14414: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14418: LD_VAR 0 1
14422: PUSH
14423: LD_INT 1
14425: ARRAY
14426: PPUSH
14427: LD_STRING DArtefTechnologyAr-RSci1-1
14429: PPUSH
14430: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14434: LD_EXP 19
14438: PPUSH
14439: LD_STRING DArtefTechnologyAr-JMM-1
14441: PPUSH
14442: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14446: LD_VAR 0 1
14450: PUSH
14451: LD_INT 1
14453: ARRAY
14454: PPUSH
14455: LD_STRING DArtefTechnologyAr-RSci1-2
14457: PPUSH
14458: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14462: LD_EXP 19
14466: PPUSH
14467: LD_STRING DArtefTechnologyAr-JMM-2
14469: PPUSH
14470: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14474: LD_VAR 0 1
14478: PUSH
14479: LD_INT 1
14481: ARRAY
14482: PPUSH
14483: LD_STRING DArtefTechnologyAr-RSci1-3
14485: PPUSH
14486: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14490: LD_EXP 19
14494: PPUSH
14495: LD_STRING DArtefTechnologyAr-JMM-3
14497: PPUSH
14498: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14502: LD_VAR 0 1
14506: PUSH
14507: LD_INT 1
14509: ARRAY
14510: PPUSH
14511: LD_STRING DArtefTechnologyAr-RSci1-4
14513: PPUSH
14514: CALL_OW 88
// if IsOk ( Burlak ) then
14518: LD_EXP 52
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14529: LD_EXP 52
14533: PPUSH
14534: LD_STRING DArtefTechnologyAr-Bur-4
14536: PPUSH
14537: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14541: LD_EXP 19
14545: PPUSH
14546: LD_STRING DArtefTechnologyAr-JMM-4
14548: PPUSH
14549: CALL_OW 88
// DialogueOff ;
14553: CALL_OW 7
// wait ( 0 0$45 ) ;
14557: LD_INT 1575
14559: PPUSH
14560: CALL_OW 67
// spawnOmar := true ;
14564: LD_ADDR_EXP 11
14568: PUSH
14569: LD_INT 1
14571: ST_TO_ADDR
// end ;
14572: PPOPN 1
14574: END
// every 0 0$1 trigger spawnOmar do
14575: LD_EXP 11
14579: IFFALSE 14959
14581: GO 14583
14583: DISABLE
// begin PrepareOmarAli ;
14584: CALL 7522 0 0
// if not HasTask ( Omar ) then
14588: LD_EXP 56
14592: PPUSH
14593: CALL_OW 314
14597: NOT
14598: IFFALSE 14615
// ComMoveXY ( Omar , 252 , 220 ) ;
14600: LD_EXP 56
14604: PPUSH
14605: LD_INT 252
14607: PPUSH
14608: LD_INT 220
14610: PPUSH
14611: CALL_OW 111
// if not Omar then
14615: LD_EXP 56
14619: NOT
14620: IFFALSE 14624
// exit ;
14622: GO 14959
// repeat wait ( 0 0$1 ) ;
14624: LD_INT 35
14626: PPUSH
14627: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14631: LD_EXP 56
14635: PPUSH
14636: CALL_OW 314
14640: NOT
14641: PUSH
14642: LD_EXP 56
14646: PPUSH
14647: LD_INT 252
14649: PPUSH
14650: LD_INT 220
14652: PPUSH
14653: CALL_OW 297
14657: PUSH
14658: LD_INT 6
14660: GREATER
14661: AND
14662: IFFALSE 14679
// ComMoveXY ( Omar , 252 , 220 ) ;
14664: LD_EXP 56
14668: PPUSH
14669: LD_INT 252
14671: PPUSH
14672: LD_INT 220
14674: PPUSH
14675: CALL_OW 111
// until See ( 7 , Omar ) ;
14679: LD_INT 7
14681: PPUSH
14682: LD_EXP 56
14686: PPUSH
14687: CALL_OW 292
14691: IFFALSE 14624
// CenterNowOnUnits ( Omar ) ;
14693: LD_EXP 56
14697: PPUSH
14698: CALL_OW 87
// DialogueOn ;
14702: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14706: LD_EXP 56
14710: PPUSH
14711: LD_STRING DOmar-Omar-1
14713: PPUSH
14714: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14718: LD_EXP 19
14722: PPUSH
14723: LD_STRING DOmar-JMM-1
14725: PPUSH
14726: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14730: LD_EXP 56
14734: PPUSH
14735: LD_STRING DOmar-Omar-2
14737: PPUSH
14738: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14742: LD_EXP 19
14746: PPUSH
14747: LD_STRING DOmar-JMM-2
14749: PPUSH
14750: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14754: LD_EXP 56
14758: PPUSH
14759: LD_STRING DOmar-Omar-3
14761: PPUSH
14762: CALL_OW 88
// if IsOk ( Burlak ) then
14766: LD_EXP 52
14770: PPUSH
14771: CALL_OW 302
14775: IFFALSE 14791
// Say ( Burlak , DOmar-Bur-3 ) else
14777: LD_EXP 52
14781: PPUSH
14782: LD_STRING DOmar-Bur-3
14784: PPUSH
14785: CALL_OW 88
14789: GO 14803
// Say ( JMM , DOmar-JMM-3 ) ;
14791: LD_EXP 19
14795: PPUSH
14796: LD_STRING DOmar-JMM-3
14798: PPUSH
14799: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14803: LD_EXP 56
14807: PPUSH
14808: LD_STRING DOmar-Omar-4
14810: PPUSH
14811: CALL_OW 88
// case Query ( QAccept ) of 1 :
14815: LD_STRING QAccept
14817: PPUSH
14818: CALL_OW 97
14822: PUSH
14823: LD_INT 1
14825: DOUBLE
14826: EQUAL
14827: IFTRUE 14831
14829: GO 14867
14831: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14832: LD_EXP 19
14836: PPUSH
14837: LD_STRING DQrAccept#1-JMM-1
14839: PPUSH
14840: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14844: LD_EXP 56
14848: PPUSH
14849: LD_INT 7
14851: PPUSH
14852: CALL_OW 235
// ComStop ( Omar ) ;
14856: LD_EXP 56
14860: PPUSH
14861: CALL_OW 141
// end ; 2 :
14865: GO 14916
14867: LD_INT 2
14869: DOUBLE
14870: EQUAL
14871: IFTRUE 14875
14873: GO 14915
14875: POP
// begin if IsOk ( Burlak ) then
14876: LD_EXP 52
14880: PPUSH
14881: CALL_OW 302
14885: IFFALSE 14901
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14887: LD_EXP 52
14891: PPUSH
14892: LD_STRING DQrAccept#2-Bur-1
14894: PPUSH
14895: CALL_OW 88
14899: GO 14913
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14901: LD_EXP 19
14905: PPUSH
14906: LD_STRING DQrAccept#2-JMM-1
14908: PPUSH
14909: CALL_OW 88
// end ; end ;
14913: GO 14916
14915: POP
// DialogueOff ;
14916: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14920: LD_EXP 56
14924: PPUSH
14925: CALL_OW 255
14929: PUSH
14930: LD_INT 7
14932: EQUAL
14933: IFFALSE 14944
// begin SetAchievement ( ACH_OMAR ) ;
14935: LD_STRING ACH_OMAR
14937: PPUSH
14938: CALL_OW 543
// exit ;
14942: GO 14959
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14944: LD_EXP 56
14948: PPUSH
14949: LD_INT 202
14951: PPUSH
14952: LD_INT 115
14954: PPUSH
14955: CALL_OW 111
// end ;
14959: END
// every 0 0$1 trigger IsOk ( Omar ) and russianDestroyed and GetSide ( Omar ) = 7 do var i ;
14960: LD_EXP 56
14964: PPUSH
14965: CALL_OW 302
14969: PUSH
14970: LD_EXP 2
14974: AND
14975: PUSH
14976: LD_EXP 56
14980: PPUSH
14981: CALL_OW 255
14985: PUSH
14986: LD_INT 7
14988: EQUAL
14989: AND
14990: IFFALSE 15482
14992: GO 14994
14994: DISABLE
14995: LD_INT 0
14997: PPUSH
// begin wait ( 0 0$2 ) ;
14998: LD_INT 70
15000: PPUSH
15001: CALL_OW 67
// SetSide ( Omar , 5 ) ;
15005: LD_EXP 56
15009: PPUSH
15010: LD_INT 5
15012: PPUSH
15013: CALL_OW 235
// if IsInUnit ( Omar ) then
15017: LD_EXP 56
15021: PPUSH
15022: CALL_OW 310
15026: IFFALSE 15037
// ComExitVehicle ( Omar ) ;
15028: LD_EXP 56
15032: PPUSH
15033: CALL_OW 121
// if IsInUnit ( Omar ) then
15037: LD_EXP 56
15041: PPUSH
15042: CALL_OW 310
15046: IFFALSE 15057
// ComExitBuilding ( Omar ) ;
15048: LD_EXP 56
15052: PPUSH
15053: CALL_OW 122
// wait ( 0 0$1 ) ;
15057: LD_INT 35
15059: PPUSH
15060: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15064: LD_EXP 56
15068: PPUSH
15069: LD_INT 203
15071: PPUSH
15072: LD_INT 120
15074: PPUSH
15075: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
15079: LD_INT 35
15081: PPUSH
15082: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
15086: LD_EXP 56
15090: PPUSH
15091: CALL_OW 306
15095: PUSH
15096: LD_EXP 56
15100: PPUSH
15101: LD_INT 203
15103: PPUSH
15104: LD_INT 120
15106: PPUSH
15107: CALL_OW 297
15111: PUSH
15112: LD_INT 20
15114: LESS
15115: OR
15116: IFFALSE 15079
// DialogueOn ;
15118: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
15122: LD_EXP 56
15126: PPUSH
15127: CALL_OW 250
15131: PPUSH
15132: LD_EXP 56
15136: PPUSH
15137: CALL_OW 251
15141: PPUSH
15142: LD_INT 7
15144: PPUSH
15145: LD_INT 6
15147: NEG
15148: PPUSH
15149: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
15153: LD_EXP 56
15157: PPUSH
15158: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
15162: LD_EXP 19
15166: PPUSH
15167: LD_STRING DOmarContam-JMM-1
15169: PPUSH
15170: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
15174: LD_EXP 56
15178: PPUSH
15179: LD_STRING DOmarContam-Omar-1
15181: PPUSH
15182: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
15186: LD_EXP 19
15190: PPUSH
15191: LD_STRING DOmarContam-JMM-2
15193: PPUSH
15194: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
15198: LD_EXP 56
15202: PPUSH
15203: CALL_OW 250
15207: PPUSH
15208: LD_EXP 56
15212: PPUSH
15213: CALL_OW 251
15217: PPUSH
15218: LD_INT 7
15220: PPUSH
15221: CALL_OW 331
// DialogueOff ;
15225: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
15229: LD_INT 5
15231: PPUSH
15232: LD_INT 7
15234: PPUSH
15235: LD_INT 2
15237: PPUSH
15238: LD_INT 1
15240: PPUSH
15241: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
15245: LD_INT 105
15247: PPUSH
15248: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15252: LD_EXP 56
15256: PPUSH
15257: LD_INT 203
15259: PPUSH
15260: LD_INT 120
15262: PPUSH
15263: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
15267: LD_EXP 56
15271: PPUSH
15272: LD_INT 203
15274: PPUSH
15275: LD_INT 120
15277: PPUSH
15278: CALL_OW 307
15282: IFFALSE 15245
// ComHold ( Omar ) ;
15284: LD_EXP 56
15288: PPUSH
15289: CALL_OW 140
// InGameOn ;
15293: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
15297: LD_INT 203
15299: PPUSH
15300: LD_INT 120
15302: PPUSH
15303: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
15307: LD_INT 203
15309: PPUSH
15310: LD_INT 120
15312: PPUSH
15313: LD_INT 7
15315: PPUSH
15316: LD_INT 30
15318: NEG
15319: PPUSH
15320: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
15324: LD_ADDR_VAR 0 1
15328: PUSH
15329: LD_INT 203
15331: PUSH
15332: LD_INT 120
15334: PUSH
15335: EMPTY
15336: LIST
15337: LIST
15338: PUSH
15339: LD_INT 202
15341: PUSH
15342: LD_INT 125
15344: PUSH
15345: EMPTY
15346: LIST
15347: LIST
15348: PUSH
15349: LD_INT 195
15351: PUSH
15352: LD_INT 117
15354: PUSH
15355: EMPTY
15356: LIST
15357: LIST
15358: PUSH
15359: LD_INT 216
15361: PUSH
15362: LD_INT 123
15364: PUSH
15365: EMPTY
15366: LIST
15367: LIST
15368: PUSH
15369: LD_INT 224
15371: PUSH
15372: LD_INT 131
15374: PUSH
15375: EMPTY
15376: LIST
15377: LIST
15378: PUSH
15379: LD_INT 212
15381: PUSH
15382: LD_INT 133
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: LIST
15393: LIST
15394: LIST
15395: LIST
15396: PUSH
15397: FOR_IN
15398: IFFALSE 15434
// begin wait ( 0 0$0.5 ) ;
15400: LD_INT 18
15402: PPUSH
15403: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15407: LD_VAR 0 1
15411: PUSH
15412: LD_INT 1
15414: ARRAY
15415: PPUSH
15416: LD_VAR 0 1
15420: PUSH
15421: LD_INT 2
15423: ARRAY
15424: PPUSH
15425: LD_INT 5
15427: PPUSH
15428: CALL_OW 495
// end ;
15432: GO 15397
15434: POP
15435: POP
// KillUnit ( Omar ) ;
15436: LD_EXP 56
15440: PPUSH
15441: CALL_OW 66
// wait ( 0 0$3 ) ;
15445: LD_INT 105
15447: PPUSH
15448: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15452: LD_EXP 19
15456: PPUSH
15457: LD_STRING D16b-JMM-1
15459: PPUSH
15460: CALL_OW 91
// wait ( 0 0$2 ) ;
15464: LD_INT 70
15466: PPUSH
15467: CALL_OW 67
// InGameOff ;
15471: CALL_OW 9
// YouLost ( MothContaminate ) ;
15475: LD_STRING MothContaminate
15477: PPUSH
15478: CALL_OW 104
// end ;
15482: PPOPN 1
15484: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15485: LD_EXP 4
15489: NOT
15490: PUSH
15491: LD_INT 22
15493: PUSH
15494: LD_INT 1
15496: PUSH
15497: EMPTY
15498: LIST
15499: LIST
15500: PUSH
15501: LD_INT 34
15503: PUSH
15504: LD_INT 8
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: PUSH
15511: EMPTY
15512: LIST
15513: LIST
15514: PPUSH
15515: CALL_OW 69
15519: AND
15520: IFFALSE 15639
15522: GO 15524
15524: DISABLE
// begin wait ( 0 0$10 ) ;
15525: LD_INT 350
15527: PPUSH
15528: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15532: LD_EXP 55
15536: PPUSH
15537: CALL_OW 302
15541: NOT
15542: PUSH
15543: LD_INT 22
15545: PUSH
15546: LD_INT 1
15548: PUSH
15549: EMPTY
15550: LIST
15551: LIST
15552: PUSH
15553: LD_INT 34
15555: PUSH
15556: LD_INT 8
15558: PUSH
15559: EMPTY
15560: LIST
15561: LIST
15562: PUSH
15563: EMPTY
15564: LIST
15565: LIST
15566: PPUSH
15567: CALL_OW 69
15571: NOT
15572: OR
15573: IFFALSE 15577
// exit ;
15575: GO 15639
// DialogueOn ;
15577: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15581: LD_EXP 55
15585: PPUSH
15586: LD_STRING DWinAmericans-Pow-1
15588: PPUSH
15589: CALL_OW 94
// if IsOk ( Burlak ) then
15593: LD_EXP 52
15597: PPUSH
15598: CALL_OW 302
15602: IFFALSE 15616
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15604: LD_EXP 52
15608: PPUSH
15609: LD_STRING DWinAmericans-Bur-1
15611: PPUSH
15612: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15616: LD_EXP 19
15620: PPUSH
15621: LD_STRING DWinAmericans-JMM-1
15623: PPUSH
15624: CALL_OW 88
// DialogueOff ;
15628: CALL_OW 7
// YouLost ( AmBomb ) ;
15632: LD_STRING AmBomb
15634: PPUSH
15635: CALL_OW 104
// end ;
15639: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15640: LD_EXP 2
15644: NOT
15645: PUSH
15646: LD_INT 22
15648: PUSH
15649: LD_INT 3
15651: PUSH
15652: EMPTY
15653: LIST
15654: LIST
15655: PUSH
15656: LD_INT 34
15658: PUSH
15659: LD_INT 48
15661: PUSH
15662: EMPTY
15663: LIST
15664: LIST
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: PPUSH
15670: CALL_OW 69
15674: AND
15675: IFFALSE 15794
15677: GO 15679
15679: DISABLE
// begin wait ( 0 0$10 ) ;
15680: LD_INT 350
15682: PPUSH
15683: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15687: LD_EXP 60
15691: PPUSH
15692: CALL_OW 302
15696: NOT
15697: PUSH
15698: LD_INT 22
15700: PUSH
15701: LD_INT 3
15703: PUSH
15704: EMPTY
15705: LIST
15706: LIST
15707: PUSH
15708: LD_INT 34
15710: PUSH
15711: LD_INT 48
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: PUSH
15718: EMPTY
15719: LIST
15720: LIST
15721: PPUSH
15722: CALL_OW 69
15726: NOT
15727: OR
15728: IFFALSE 15732
// exit ;
15730: GO 15794
// DialogueOn ;
15732: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15736: LD_EXP 60
15740: PPUSH
15741: LD_STRING DWinRussians-Pla-1
15743: PPUSH
15744: CALL_OW 94
// if IsOk ( Burlak ) then
15748: LD_EXP 52
15752: PPUSH
15753: CALL_OW 302
15757: IFFALSE 15771
// Say ( Burlak , DWinRussians-Bur-1 ) ;
15759: LD_EXP 52
15763: PPUSH
15764: LD_STRING DWinRussians-Bur-1
15766: PPUSH
15767: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
15771: LD_EXP 19
15775: PPUSH
15776: LD_STRING DWinRussians-JMM-1
15778: PPUSH
15779: CALL_OW 88
// DialogueOff ;
15783: CALL_OW 7
// YouLost ( RuBomb ) ;
15787: LD_STRING RuBomb
15789: PPUSH
15790: CALL_OW 104
// end ;
15794: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
15795: LD_INT 7
15797: PPUSH
15798: LD_INT 22
15800: PUSH
15801: LD_INT 7
15803: PUSH
15804: EMPTY
15805: LIST
15806: LIST
15807: PPUSH
15808: CALL_OW 70
15812: PUSH
15813: LD_EXP 4
15817: NOT
15818: AND
15819: IFFALSE 15848
15821: GO 15823
15823: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
15824: LD_EXP 55
15828: PPUSH
15829: LD_STRING DSurrenderAmericans-Pow-1
15831: PPUSH
15832: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
15836: LD_EXP 19
15840: PPUSH
15841: LD_STRING DSurrenderAmericans-JMM-1
15843: PPUSH
15844: CALL_OW 88
// end ;
15848: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
15849: LD_INT 2
15851: PPUSH
15852: LD_INT 22
15854: PUSH
15855: LD_INT 7
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PPUSH
15862: CALL_OW 70
15866: PUSH
15867: LD_EXP 2
15871: NOT
15872: AND
15873: PUSH
15874: LD_EXP 52
15878: AND
15879: IFFALSE 15908
15881: GO 15883
15883: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
15884: LD_EXP 60
15888: PPUSH
15889: LD_STRING DSurrenderRussians-Pla-1
15891: PPUSH
15892: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15896: LD_EXP 52
15900: PPUSH
15901: LD_STRING DSurrenderRussians-Bur-1
15903: PPUSH
15904: CALL_OW 88
// end ;
15908: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
15909: LD_EXP 4
15913: IFFALSE 16352
15915: GO 15917
15917: DISABLE
15918: LD_INT 0
15920: PPUSH
15921: PPUSH
15922: PPUSH
// begin MC_Kill ( 4 ) ;
15923: LD_INT 4
15925: PPUSH
15926: CALL 22873 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
15930: LD_INT 1
15932: PPUSH
15933: LD_INT 7
15935: PPUSH
15936: LD_INT 1
15938: PPUSH
15939: LD_INT 1
15941: PPUSH
15942: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
15946: LD_ADDR_VAR 0 3
15950: PUSH
15951: LD_INT 22
15953: PUSH
15954: LD_INT 1
15956: PUSH
15957: EMPTY
15958: LIST
15959: LIST
15960: PUSH
15961: LD_INT 50
15963: PUSH
15964: EMPTY
15965: LIST
15966: PUSH
15967: LD_INT 26
15969: PUSH
15970: LD_INT 1
15972: PUSH
15973: EMPTY
15974: LIST
15975: LIST
15976: PUSH
15977: LD_INT 23
15979: PUSH
15980: LD_INT 1
15982: PUSH
15983: EMPTY
15984: LIST
15985: LIST
15986: PUSH
15987: EMPTY
15988: LIST
15989: LIST
15990: LIST
15991: LIST
15992: PPUSH
15993: CALL_OW 69
15997: PUSH
15998: LD_EXP 55
16002: PUSH
16003: LD_EXP 27
16007: PUSH
16008: LD_EXP 24
16012: PUSH
16013: LD_EXP 23
16017: PUSH
16018: LD_EXP 30
16022: PUSH
16023: LD_EXP 28
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: LIST
16032: LIST
16033: LIST
16034: LIST
16035: DIFF
16036: ST_TO_ADDR
// if not speaker then
16037: LD_VAR 0 3
16041: NOT
16042: IFFALSE 16082
// begin uc_side := 1 ;
16044: LD_ADDR_OWVAR 20
16048: PUSH
16049: LD_INT 1
16051: ST_TO_ADDR
// uc_nation := 1 ;
16052: LD_ADDR_OWVAR 21
16056: PUSH
16057: LD_INT 1
16059: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16060: LD_INT 1
16062: PPUSH
16063: LD_INT 0
16065: PPUSH
16066: CALL_OW 381
// speaker := CreateHuman ;
16070: LD_ADDR_VAR 0 3
16074: PUSH
16075: CALL_OW 44
16079: ST_TO_ADDR
// end else
16080: GO 16096
// speaker := speaker [ 1 ] ;
16082: LD_ADDR_VAR 0 3
16086: PUSH
16087: LD_VAR 0 3
16091: PUSH
16092: LD_INT 1
16094: ARRAY
16095: ST_TO_ADDR
// DialogueOn ;
16096: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
16100: LD_VAR 0 3
16104: PPUSH
16105: LD_STRING DSurrenderAmericans-Sol1-1a
16107: PPUSH
16108: CALL_OW 94
// DialogueOff ;
16112: CALL_OW 7
// americanCapitulated := true ;
16116: LD_ADDR_EXP 6
16120: PUSH
16121: LD_INT 1
16123: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16124: LD_ADDR_VAR 0 2
16128: PUSH
16129: LD_INT 22
16131: PUSH
16132: LD_INT 1
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 21
16141: PUSH
16142: LD_INT 1
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: PPUSH
16153: CALL_OW 69
16157: PUSH
16158: LD_INT 22
16160: PUSH
16161: LD_INT 1
16163: PUSH
16164: EMPTY
16165: LIST
16166: LIST
16167: PUSH
16168: LD_INT 21
16170: PUSH
16171: LD_INT 2
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: PUSH
16178: LD_INT 1
16180: PUSH
16181: EMPTY
16182: LIST
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: LIST
16188: PPUSH
16189: CALL_OW 69
16193: ADD
16194: ST_TO_ADDR
// if tmp then
16195: LD_VAR 0 2
16199: IFFALSE 16352
// repeat wait ( 0 0$1 ) ;
16201: LD_INT 35
16203: PPUSH
16204: CALL_OW 67
// for i in tmp do
16208: LD_ADDR_VAR 0 1
16212: PUSH
16213: LD_VAR 0 2
16217: PUSH
16218: FOR_IN
16219: IFFALSE 16301
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16221: LD_VAR 0 1
16225: PPUSH
16226: CALL_OW 310
16230: PUSH
16231: LD_VAR 0 1
16235: PPUSH
16236: CALL_OW 310
16240: PPUSH
16241: CALL_OW 247
16245: PUSH
16246: LD_INT 3
16248: EQUAL
16249: AND
16250: IFFALSE 16261
// ComExitBuilding ( i ) ;
16252: LD_VAR 0 1
16256: PPUSH
16257: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
16261: LD_VAR 0 1
16265: PPUSH
16266: LD_INT 122
16268: PPUSH
16269: LD_INT 242
16271: PPUSH
16272: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
16276: LD_VAR 0 1
16280: PPUSH
16281: LD_INT 35
16283: PPUSH
16284: CALL_OW 308
16288: IFFALSE 16299
// RemoveUnit ( i ) ;
16290: LD_VAR 0 1
16294: PPUSH
16295: CALL_OW 64
// end ;
16299: GO 16218
16301: POP
16302: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16303: LD_INT 22
16305: PUSH
16306: LD_INT 1
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: PUSH
16313: LD_INT 2
16315: PUSH
16316: LD_INT 21
16318: PUSH
16319: LD_INT 1
16321: PUSH
16322: EMPTY
16323: LIST
16324: LIST
16325: PUSH
16326: LD_INT 33
16328: PUSH
16329: LD_INT 1
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: PUSH
16336: EMPTY
16337: LIST
16338: LIST
16339: LIST
16340: PUSH
16341: EMPTY
16342: LIST
16343: LIST
16344: PPUSH
16345: CALL_OW 69
16349: NOT
16350: IFFALSE 16201
// end ;
16352: PPOPN 3
16354: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
16355: LD_EXP 2
16359: IFFALSE 16808
16361: GO 16363
16363: DISABLE
16364: LD_INT 0
16366: PPUSH
16367: PPUSH
16368: PPUSH
// begin repeat wait ( 0 0$1 ) ;
16369: LD_INT 35
16371: PPUSH
16372: CALL_OW 67
// until IsDead ( Yakotich ) ;
16376: LD_EXP 61
16380: PPUSH
16381: CALL_OW 301
16385: IFFALSE 16369
// MC_Kill ( 2 ) ;
16387: LD_INT 2
16389: PPUSH
16390: CALL 22873 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16394: LD_INT 3
16396: PPUSH
16397: LD_INT 7
16399: PPUSH
16400: LD_INT 1
16402: PPUSH
16403: LD_INT 1
16405: PPUSH
16406: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16410: LD_ADDR_VAR 0 3
16414: PUSH
16415: LD_INT 22
16417: PUSH
16418: LD_INT 3
16420: PUSH
16421: EMPTY
16422: LIST
16423: LIST
16424: PUSH
16425: LD_INT 50
16427: PUSH
16428: EMPTY
16429: LIST
16430: PUSH
16431: LD_INT 26
16433: PUSH
16434: LD_INT 1
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: PUSH
16441: LD_INT 23
16443: PUSH
16444: LD_INT 3
16446: PUSH
16447: EMPTY
16448: LIST
16449: LIST
16450: PUSH
16451: EMPTY
16452: LIST
16453: LIST
16454: LIST
16455: LIST
16456: PPUSH
16457: CALL_OW 69
16461: PUSH
16462: LD_EXP 60
16466: DIFF
16467: ST_TO_ADDR
// if not speaker then
16468: LD_VAR 0 3
16472: NOT
16473: IFFALSE 16513
// begin uc_side := 3 ;
16475: LD_ADDR_OWVAR 20
16479: PUSH
16480: LD_INT 3
16482: ST_TO_ADDR
// uc_nation := 3 ;
16483: LD_ADDR_OWVAR 21
16487: PUSH
16488: LD_INT 3
16490: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16491: LD_INT 1
16493: PPUSH
16494: LD_INT 0
16496: PPUSH
16497: CALL_OW 381
// speaker := CreateHuman ;
16501: LD_ADDR_VAR 0 3
16505: PUSH
16506: CALL_OW 44
16510: ST_TO_ADDR
// end else
16511: GO 16527
// speaker := speaker [ 1 ] ;
16513: LD_ADDR_VAR 0 3
16517: PUSH
16518: LD_VAR 0 3
16522: PUSH
16523: LD_INT 1
16525: ARRAY
16526: ST_TO_ADDR
// DialogueOn ;
16527: CALL_OW 6
// if IsOK ( Burlak ) then
16531: LD_EXP 52
16535: PPUSH
16536: CALL_OW 302
16540: IFFALSE 16556
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16542: LD_VAR 0 3
16546: PPUSH
16547: LD_STRING DSurrenderRussians-RSol1-1
16549: PPUSH
16550: CALL_OW 94
16554: GO 16568
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16556: LD_VAR 0 3
16560: PPUSH
16561: LD_STRING DSurrenderRussians-RSol1-1a
16563: PPUSH
16564: CALL_OW 94
// DialogueOff ;
16568: CALL_OW 7
// russianCapitulated := true ;
16572: LD_ADDR_EXP 7
16576: PUSH
16577: LD_INT 1
16579: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16580: LD_ADDR_VAR 0 2
16584: PUSH
16585: LD_INT 22
16587: PUSH
16588: LD_INT 3
16590: PUSH
16591: EMPTY
16592: LIST
16593: LIST
16594: PUSH
16595: LD_INT 21
16597: PUSH
16598: LD_INT 1
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: PUSH
16605: EMPTY
16606: LIST
16607: LIST
16608: PPUSH
16609: CALL_OW 69
16613: PUSH
16614: LD_INT 22
16616: PUSH
16617: LD_INT 3
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: LD_INT 21
16626: PUSH
16627: LD_INT 2
16629: PUSH
16630: EMPTY
16631: LIST
16632: LIST
16633: PUSH
16634: LD_INT 1
16636: PUSH
16637: EMPTY
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL_OW 69
16649: ADD
16650: ST_TO_ADDR
// if tmp then
16651: LD_VAR 0 2
16655: IFFALSE 16808
// repeat wait ( 0 0$1 ) ;
16657: LD_INT 35
16659: PPUSH
16660: CALL_OW 67
// for i in tmp do
16664: LD_ADDR_VAR 0 1
16668: PUSH
16669: LD_VAR 0 2
16673: PUSH
16674: FOR_IN
16675: IFFALSE 16757
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16677: LD_VAR 0 1
16681: PPUSH
16682: CALL_OW 310
16686: PUSH
16687: LD_VAR 0 1
16691: PPUSH
16692: CALL_OW 310
16696: PPUSH
16697: CALL_OW 247
16701: PUSH
16702: LD_INT 3
16704: EQUAL
16705: AND
16706: IFFALSE 16717
// ComExitBuilding ( i ) ;
16708: LD_VAR 0 1
16712: PPUSH
16713: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16717: LD_VAR 0 1
16721: PPUSH
16722: LD_INT 154
16724: PPUSH
16725: LD_INT 1
16727: PPUSH
16728: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16732: LD_VAR 0 1
16736: PPUSH
16737: LD_INT 36
16739: PPUSH
16740: CALL_OW 308
16744: IFFALSE 16755
// RemoveUnit ( i ) ;
16746: LD_VAR 0 1
16750: PPUSH
16751: CALL_OW 64
// end ;
16755: GO 16674
16757: POP
16758: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16759: LD_INT 22
16761: PUSH
16762: LD_INT 3
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: PUSH
16769: LD_INT 2
16771: PUSH
16772: LD_INT 21
16774: PUSH
16775: LD_INT 1
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: PUSH
16782: LD_INT 33
16784: PUSH
16785: LD_INT 1
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: PUSH
16792: EMPTY
16793: LIST
16794: LIST
16795: LIST
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PPUSH
16801: CALL_OW 69
16805: NOT
16806: IFFALSE 16657
// end ;
16808: PPOPN 3
16810: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
16811: LD_INT 22
16813: PUSH
16814: LD_INT 8
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PUSH
16821: LD_INT 21
16823: PUSH
16824: LD_INT 1
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: PUSH
16831: LD_INT 23
16833: PUSH
16834: LD_INT 2
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: PUSH
16841: EMPTY
16842: LIST
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 69
16850: PUSH
16851: LD_INT 18
16853: LESS
16854: PUSH
16855: LD_EXP 58
16859: PPUSH
16860: CALL_OW 301
16864: OR
16865: PUSH
16866: LD_INT 324
16868: PPUSH
16869: CALL_OW 255
16873: PUSH
16874: LD_INT 7
16876: EQUAL
16877: OR
16878: IFFALSE 16891
16880: GO 16882
16882: DISABLE
// legionDestroyed := true ;
16883: LD_ADDR_EXP 3
16887: PUSH
16888: LD_INT 1
16890: ST_TO_ADDR
16891: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
16892: LD_INT 22
16894: PUSH
16895: LD_INT 2
16897: PUSH
16898: EMPTY
16899: LIST
16900: LIST
16901: PUSH
16902: LD_INT 21
16904: PUSH
16905: LD_INT 1
16907: PUSH
16908: EMPTY
16909: LIST
16910: LIST
16911: PUSH
16912: LD_INT 23
16914: PUSH
16915: LD_INT 2
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: LIST
16926: PPUSH
16927: CALL_OW 69
16931: PUSH
16932: LD_INT 9
16934: LESS
16935: PUSH
16936: LD_INT 503
16938: PPUSH
16939: CALL_OW 301
16943: OR
16944: PUSH
16945: LD_INT 503
16947: PPUSH
16948: CALL_OW 255
16952: PUSH
16953: LD_INT 7
16955: EQUAL
16956: OR
16957: IFFALSE 16970
16959: GO 16961
16961: DISABLE
// arabianDestroyed := true ;
16962: LD_ADDR_EXP 5
16966: PUSH
16967: LD_INT 1
16969: ST_TO_ADDR
16970: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
16971: LD_EXP 5
16975: IFFALSE 17219
16977: GO 16979
16979: DISABLE
16980: LD_INT 0
16982: PPUSH
16983: PPUSH
// begin MC_Kill ( 1 ) ;
16984: LD_INT 1
16986: PPUSH
16987: CALL 22873 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16991: LD_ADDR_VAR 0 2
16995: PUSH
16996: LD_INT 22
16998: PUSH
16999: LD_INT 2
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: PUSH
17006: LD_INT 21
17008: PUSH
17009: LD_INT 1
17011: PUSH
17012: EMPTY
17013: LIST
17014: LIST
17015: PUSH
17016: EMPTY
17017: LIST
17018: LIST
17019: PPUSH
17020: CALL_OW 69
17024: PUSH
17025: LD_INT 22
17027: PUSH
17028: LD_INT 2
17030: PUSH
17031: EMPTY
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 21
17037: PUSH
17038: LD_INT 2
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: PUSH
17045: LD_INT 1
17047: PUSH
17048: EMPTY
17049: LIST
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: LIST
17055: PPUSH
17056: CALL_OW 69
17060: ADD
17061: ST_TO_ADDR
// if tmp then
17062: LD_VAR 0 2
17066: IFFALSE 17219
// repeat wait ( 0 0$1 ) ;
17068: LD_INT 35
17070: PPUSH
17071: CALL_OW 67
// for i in tmp do
17075: LD_ADDR_VAR 0 1
17079: PUSH
17080: LD_VAR 0 2
17084: PUSH
17085: FOR_IN
17086: IFFALSE 17168
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17088: LD_VAR 0 1
17092: PPUSH
17093: CALL_OW 310
17097: PUSH
17098: LD_VAR 0 1
17102: PPUSH
17103: CALL_OW 310
17107: PPUSH
17108: CALL_OW 247
17112: PUSH
17113: LD_INT 3
17115: EQUAL
17116: AND
17117: IFFALSE 17128
// ComExitBuilding ( i ) ;
17119: LD_VAR 0 1
17123: PPUSH
17124: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
17128: LD_VAR 0 1
17132: PPUSH
17133: LD_INT 254
17135: PPUSH
17136: LD_INT 268
17138: PPUSH
17139: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
17143: LD_VAR 0 1
17147: PPUSH
17148: LD_INT 34
17150: PPUSH
17151: CALL_OW 308
17155: IFFALSE 17166
// RemoveUnit ( i ) ;
17157: LD_VAR 0 1
17161: PPUSH
17162: CALL_OW 64
// end ;
17166: GO 17085
17168: POP
17169: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17170: LD_INT 22
17172: PUSH
17173: LD_INT 2
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: PUSH
17180: LD_INT 2
17182: PUSH
17183: LD_INT 21
17185: PUSH
17186: LD_INT 1
17188: PUSH
17189: EMPTY
17190: LIST
17191: LIST
17192: PUSH
17193: LD_INT 33
17195: PUSH
17196: LD_INT 1
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: EMPTY
17204: LIST
17205: LIST
17206: LIST
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: PPUSH
17212: CALL_OW 69
17216: NOT
17217: IFFALSE 17068
// end ;
17219: PPOPN 2
17221: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
17222: LD_EXP 3
17226: IFFALSE 17578
17228: GO 17230
17230: DISABLE
17231: LD_INT 0
17233: PPUSH
17234: PPUSH
// begin MC_Kill ( 3 ) ;
17235: LD_INT 3
17237: PPUSH
17238: CALL 22873 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
17242: LD_INT 8
17244: PPUSH
17245: LD_INT 7
17247: PPUSH
17248: LD_INT 1
17250: PPUSH
17251: LD_INT 1
17253: PPUSH
17254: CALL_OW 80
// DialogueOn ;
17258: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
17262: LD_EXP 57
17266: PPUSH
17267: LD_STRING D15-Szulc-1
17269: PPUSH
17270: CALL_OW 94
// DialogueOff ;
17274: CALL_OW 7
// legionCapitulated := true ;
17278: LD_ADDR_EXP 8
17282: PUSH
17283: LD_INT 1
17285: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
17286: LD_ADDR_VAR 0 1
17290: PUSH
17291: LD_INT 22
17293: PUSH
17294: LD_INT 8
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 21
17303: PUSH
17304: LD_INT 3
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PUSH
17311: LD_INT 23
17313: PUSH
17314: LD_INT 3
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: PUSH
17321: EMPTY
17322: LIST
17323: LIST
17324: LIST
17325: PPUSH
17326: CALL_OW 69
17330: PUSH
17331: FOR_IN
17332: IFFALSE 17348
// SetLives ( i , 3 ) ;
17334: LD_VAR 0 1
17338: PPUSH
17339: LD_INT 3
17341: PPUSH
17342: CALL_OW 234
17346: GO 17331
17348: POP
17349: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17350: LD_ADDR_VAR 0 2
17354: PUSH
17355: LD_INT 22
17357: PUSH
17358: LD_INT 8
17360: PUSH
17361: EMPTY
17362: LIST
17363: LIST
17364: PUSH
17365: LD_INT 21
17367: PUSH
17368: LD_INT 1
17370: PUSH
17371: EMPTY
17372: LIST
17373: LIST
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: PPUSH
17379: CALL_OW 69
17383: PUSH
17384: LD_INT 22
17386: PUSH
17387: LD_INT 8
17389: PUSH
17390: EMPTY
17391: LIST
17392: LIST
17393: PUSH
17394: LD_INT 21
17396: PUSH
17397: LD_INT 2
17399: PUSH
17400: EMPTY
17401: LIST
17402: LIST
17403: PUSH
17404: LD_INT 1
17406: PUSH
17407: EMPTY
17408: LIST
17409: PUSH
17410: EMPTY
17411: LIST
17412: LIST
17413: LIST
17414: PPUSH
17415: CALL_OW 69
17419: ADD
17420: ST_TO_ADDR
// if tmp then
17421: LD_VAR 0 2
17425: IFFALSE 17578
// repeat wait ( 0 0$1 ) ;
17427: LD_INT 35
17429: PPUSH
17430: CALL_OW 67
// for i in tmp do
17434: LD_ADDR_VAR 0 1
17438: PUSH
17439: LD_VAR 0 2
17443: PUSH
17444: FOR_IN
17445: IFFALSE 17527
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17447: LD_VAR 0 1
17451: PPUSH
17452: CALL_OW 310
17456: PUSH
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 310
17466: PPUSH
17467: CALL_OW 247
17471: PUSH
17472: LD_INT 3
17474: EQUAL
17475: AND
17476: IFFALSE 17487
// ComExitBuilding ( i ) ;
17478: LD_VAR 0 1
17482: PPUSH
17483: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17487: LD_VAR 0 1
17491: PPUSH
17492: LD_INT 10
17494: PPUSH
17495: LD_INT 1
17497: PPUSH
17498: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17502: LD_VAR 0 1
17506: PPUSH
17507: LD_INT 32
17509: PPUSH
17510: CALL_OW 308
17514: IFFALSE 17525
// RemoveUnit ( i ) ;
17516: LD_VAR 0 1
17520: PPUSH
17521: CALL_OW 64
// end ;
17525: GO 17444
17527: POP
17528: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17529: LD_INT 22
17531: PUSH
17532: LD_INT 8
17534: PUSH
17535: EMPTY
17536: LIST
17537: LIST
17538: PUSH
17539: LD_INT 2
17541: PUSH
17542: LD_INT 21
17544: PUSH
17545: LD_INT 1
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: PUSH
17552: LD_INT 33
17554: PUSH
17555: LD_INT 1
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: LIST
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: PPUSH
17571: CALL_OW 69
17575: NOT
17576: IFFALSE 17427
// end ;
17578: PPOPN 2
17580: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17581: LD_EXP 5
17585: NOT
17586: PUSH
17587: LD_OWVAR 1
17591: PUSH
17592: LD_INT 63000
17594: GREATEREQUAL
17595: AND
17596: PUSH
17597: LD_OWVAR 67
17601: PUSH
17602: LD_INT 3
17604: LESS
17605: AND
17606: IFFALSE 17615
17608: GO 17610
17610: DISABLE
// AllianceSupport ;
17611: CALL 4687 0 0
17615: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17616: LD_EXP 4
17620: PUSH
17621: LD_EXP 2
17625: AND
17626: PUSH
17627: LD_EXP 3
17631: AND
17632: PUSH
17633: LD_EXP 5
17637: AND
17638: PUSH
17639: LD_EXP 6
17643: AND
17644: PUSH
17645: LD_EXP 7
17649: AND
17650: PUSH
17651: LD_EXP 8
17655: AND
17656: PUSH
17657: LD_EXP 56
17661: PPUSH
17662: CALL_OW 255
17666: PUSH
17667: LD_INT 5
17669: NONEQUAL
17670: PUSH
17671: LD_EXP 56
17675: PPUSH
17676: CALL_OW 301
17680: OR
17681: PUSH
17682: LD_EXP 56
17686: PPUSH
17687: CALL_OW 305
17691: NOT
17692: OR
17693: AND
17694: IFFALSE 19279
17696: GO 17698
17698: DISABLE
17699: LD_INT 0
17701: PPUSH
17702: PPUSH
// begin wait ( 0 0$5 ) ;
17703: LD_INT 175
17705: PPUSH
17706: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 3 then
17710: LD_INT 22
17712: PUSH
17713: LD_INT 7
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: PUSH
17720: LD_INT 21
17722: PUSH
17723: LD_INT 1
17725: PUSH
17726: EMPTY
17727: LIST
17728: LIST
17729: PUSH
17730: LD_INT 23
17732: PUSH
17733: LD_INT 1
17735: PUSH
17736: EMPTY
17737: LIST
17738: LIST
17739: PUSH
17740: LD_INT 50
17742: PUSH
17743: EMPTY
17744: LIST
17745: PUSH
17746: EMPTY
17747: LIST
17748: LIST
17749: LIST
17750: LIST
17751: PPUSH
17752: CALL_OW 69
17756: PPUSH
17757: CALL 55426 0 1
17761: PUSH
17762: LD_INT 3
17764: LESS
17765: IFFALSE 17776
// begin YouLost ( LostVictory ) ;
17767: LD_STRING LostVictory
17769: PPUSH
17770: CALL_OW 104
// exit ;
17774: GO 19279
// end ; music_class := 5 ;
17776: LD_ADDR_OWVAR 72
17780: PUSH
17781: LD_INT 5
17783: ST_TO_ADDR
// music_nat := 5 ;
17784: LD_ADDR_OWVAR 71
17788: PUSH
17789: LD_INT 5
17791: ST_TO_ADDR
// if vehicleLostCounter < 3 then
17792: LD_EXP 15
17796: PUSH
17797: LD_INT 3
17799: LESS
17800: IFFALSE 17809
// SetAchievement ( ACH_ECONOMY ) ;
17802: LD_STRING ACH_ECONOMY
17804: PPUSH
17805: CALL_OW 543
// if tick < 60 60$00 then
17809: LD_OWVAR 1
17813: PUSH
17814: LD_INT 126000
17816: LESS
17817: IFFALSE 17833
// begin wait ( 3 ) ;
17819: LD_INT 3
17821: PPUSH
17822: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
17826: LD_STRING ACH_ASPEED_19
17828: PPUSH
17829: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
17833: LD_EXP 19
17837: PPUSH
17838: CALL_OW 87
// InGameOn ;
17842: CALL_OW 8
// DialogueOn ;
17846: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
17850: LD_EXP 19
17854: PPUSH
17855: LD_STRING DEnd-JMM-JMM-1
17857: PPUSH
17858: CALL_OW 88
// if Joan then
17862: LD_EXP 34
17866: IFFALSE 17882
// Say ( Joan , DEnd-JMM-Joan-1 ) else
17868: LD_EXP 34
17872: PPUSH
17873: LD_STRING DEnd-JMM-Joan-1
17875: PPUSH
17876: CALL_OW 88
17880: GO 17926
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
17882: LD_EXP 21
17886: PUSH
17887: LD_EXP 21
17891: PPUSH
17892: CALL_OW 255
17896: PUSH
17897: LD_INT 7
17899: EQUAL
17900: AND
17901: PUSH
17902: LD_EXP 21
17906: PPUSH
17907: CALL_OW 305
17911: AND
17912: IFFALSE 17926
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17914: LD_EXP 21
17918: PPUSH
17919: LD_STRING DEnd-JMM-Lisa-1
17921: PPUSH
17922: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
17926: LD_EXP 31
17930: PUSH
17931: LD_EXP 31
17935: PPUSH
17936: CALL_OW 305
17940: AND
17941: IFFALSE 17955
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17943: LD_EXP 31
17947: PPUSH
17948: LD_STRING DEnd-JMM-Frank-1
17950: PPUSH
17951: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
17955: LD_EXP 24
17959: PUSH
17960: LD_EXP 24
17964: PPUSH
17965: CALL_OW 255
17969: PUSH
17970: LD_INT 7
17972: EQUAL
17973: AND
17974: PUSH
17975: LD_EXP 24
17979: PPUSH
17980: CALL_OW 305
17984: AND
17985: IFFALSE 17999
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17987: LD_EXP 24
17991: PPUSH
17992: LD_STRING DEnd-JMM-Cyrus-1
17994: PPUSH
17995: CALL_OW 88
// if Burlak then
17999: LD_EXP 52
18003: IFFALSE 18017
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
18005: LD_EXP 52
18009: PPUSH
18010: LD_STRING DEnd-JMM-Bur-1
18012: PPUSH
18013: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
18017: LD_EXP 34
18021: PUSH
18022: LD_EXP 21
18026: AND
18027: PUSH
18028: LD_EXP 21
18032: PPUSH
18033: CALL_OW 255
18037: PUSH
18038: LD_INT 7
18040: EQUAL
18041: AND
18042: PUSH
18043: LD_EXP 21
18047: PPUSH
18048: CALL_OW 305
18052: AND
18053: PUSH
18054: LD_EXP 52
18058: PPUSH
18059: CALL_OW 302
18063: AND
18064: IFFALSE 18078
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
18066: LD_EXP 21
18070: PPUSH
18071: LD_STRING DEnd-Burlak-Lisa-1
18073: PPUSH
18074: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
18078: LD_EXP 53
18082: PUSH
18083: LD_EXP 53
18087: PPUSH
18088: CALL_OW 305
18092: AND
18093: IFFALSE 18107
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
18095: LD_EXP 53
18099: PPUSH
18100: LD_STRING DEnd-JMM-Bel-1
18102: PPUSH
18103: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
18107: LD_EXP 54
18111: PUSH
18112: LD_EXP 54
18116: PPUSH
18117: CALL_OW 305
18121: AND
18122: IFFALSE 18136
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
18124: LD_EXP 54
18128: PPUSH
18129: LD_STRING DEnd-JMM-Gny-1
18131: PPUSH
18132: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
18136: LD_EXP 29
18140: PUSH
18141: LD_EXP 29
18145: PPUSH
18146: CALL_OW 255
18150: PUSH
18151: LD_INT 7
18153: EQUAL
18154: AND
18155: PUSH
18156: LD_EXP 29
18160: PPUSH
18161: CALL_OW 305
18165: AND
18166: IFFALSE 18180
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
18168: LD_EXP 29
18172: PPUSH
18173: LD_STRING DEnd-JMM-Corn-1
18175: PPUSH
18176: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
18180: LD_EXP 22
18184: PUSH
18185: LD_EXP 22
18189: PPUSH
18190: CALL_OW 255
18194: PUSH
18195: LD_INT 7
18197: EQUAL
18198: AND
18199: PUSH
18200: LD_EXP 22
18204: PPUSH
18205: CALL_OW 305
18209: AND
18210: IFFALSE 18224
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
18212: LD_EXP 22
18216: PPUSH
18217: LD_STRING DEnd-JMM-Don-1
18219: PPUSH
18220: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
18224: LD_EXP 23
18228: PUSH
18229: LD_EXP 23
18233: PPUSH
18234: CALL_OW 255
18238: PUSH
18239: LD_INT 7
18241: EQUAL
18242: AND
18243: PUSH
18244: LD_EXP 23
18248: PPUSH
18249: CALL_OW 305
18253: AND
18254: IFFALSE 18268
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
18256: LD_EXP 23
18260: PPUSH
18261: LD_STRING DEnd-JMM-Bobby-1
18263: PPUSH
18264: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
18268: LD_EXP 25
18272: PUSH
18273: LD_EXP 25
18277: PPUSH
18278: CALL_OW 255
18282: PUSH
18283: LD_INT 7
18285: EQUAL
18286: AND
18287: PUSH
18288: LD_EXP 25
18292: PPUSH
18293: CALL_OW 305
18297: AND
18298: IFFALSE 18312
// Say ( Denis , DEnd-JMM-Den-1 ) ;
18300: LD_EXP 25
18304: PPUSH
18305: LD_STRING DEnd-JMM-Den-1
18307: PPUSH
18308: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
18312: LD_EXP 27
18316: PUSH
18317: LD_EXP 27
18321: PPUSH
18322: CALL_OW 255
18326: PUSH
18327: LD_INT 7
18329: EQUAL
18330: AND
18331: PUSH
18332: LD_EXP 27
18336: PPUSH
18337: CALL_OW 305
18341: AND
18342: IFFALSE 18356
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
18344: LD_EXP 27
18348: PPUSH
18349: LD_STRING DEnd-JMM-Glad-1
18351: PPUSH
18352: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18356: LD_EXP 32
18360: PUSH
18361: LD_EXP 32
18365: PPUSH
18366: CALL_OW 255
18370: PUSH
18371: LD_INT 7
18373: EQUAL
18374: AND
18375: PUSH
18376: LD_EXP 32
18380: PPUSH
18381: CALL_OW 305
18385: AND
18386: IFFALSE 18400
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18388: LD_EXP 32
18392: PPUSH
18393: LD_STRING DEnd-JMM-Yam-1
18395: PPUSH
18396: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
18400: LD_EXP 26
18404: PUSH
18405: LD_EXP 26
18409: PPUSH
18410: CALL_OW 255
18414: PUSH
18415: LD_INT 7
18417: EQUAL
18418: AND
18419: PUSH
18420: LD_EXP 26
18424: PPUSH
18425: CALL_OW 305
18429: AND
18430: IFFALSE 18444
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
18432: LD_EXP 26
18436: PPUSH
18437: LD_STRING DEnd-JMM-Brown-1
18439: PPUSH
18440: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
18444: LD_EXP 36
18448: PUSH
18449: LD_EXP 36
18453: PPUSH
18454: CALL_OW 255
18458: PUSH
18459: LD_INT 7
18461: EQUAL
18462: AND
18463: PUSH
18464: LD_EXP 36
18468: PPUSH
18469: CALL_OW 305
18473: AND
18474: IFFALSE 18488
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18476: LD_EXP 36
18480: PPUSH
18481: LD_STRING DEnd-JMM-Con-1
18483: PPUSH
18484: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
18488: LD_EXP 30
18492: PUSH
18493: LD_EXP 30
18497: PPUSH
18498: CALL_OW 255
18502: PUSH
18503: LD_INT 7
18505: EQUAL
18506: AND
18507: PUSH
18508: LD_EXP 30
18512: PPUSH
18513: CALL_OW 305
18517: AND
18518: IFFALSE 18532
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18520: LD_EXP 30
18524: PPUSH
18525: LD_STRING DEnd-JMM-Gary-1
18527: PPUSH
18528: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18532: LD_EXP 20
18536: PUSH
18537: LD_EXP 20
18541: PPUSH
18542: CALL_OW 305
18546: AND
18547: IFFALSE 18561
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18549: LD_EXP 20
18553: PPUSH
18554: LD_STRING DEnd-JMM-Roth-1
18556: PPUSH
18557: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18561: LD_EXP 33
18565: PUSH
18566: LD_EXP 20
18570: AND
18571: PUSH
18572: LD_EXP 33
18576: PPUSH
18577: CALL_OW 305
18581: AND
18582: IFFALSE 18596
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18584: LD_EXP 33
18588: PPUSH
18589: LD_STRING DEnd-JMM-Sim-1
18591: PPUSH
18592: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18596: LD_EXP 28
18600: PUSH
18601: LD_EXP 28
18605: PPUSH
18606: CALL_OW 255
18610: PUSH
18611: LD_INT 7
18613: EQUAL
18614: AND
18615: PUSH
18616: LD_EXP 28
18620: PPUSH
18621: CALL_OW 305
18625: AND
18626: IFFALSE 18640
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18628: LD_EXP 28
18632: PPUSH
18633: LD_STRING DEnd-JMM-VanH-1
18635: PPUSH
18636: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18640: LD_EXP 42
18644: PUSH
18645: LD_EXP 42
18649: PPUSH
18650: CALL_OW 305
18654: AND
18655: IFFALSE 18669
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18657: LD_EXP 42
18661: PPUSH
18662: LD_STRING DEnd-JMM-Dol-1
18664: PPUSH
18665: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18669: LD_EXP 32
18673: PUSH
18674: LD_EXP 32
18678: PPUSH
18679: CALL_OW 255
18683: PUSH
18684: LD_INT 7
18686: EQUAL
18687: AND
18688: PUSH
18689: LD_EXP 32
18693: PPUSH
18694: CALL_OW 305
18698: AND
18699: IFFALSE 18713
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18701: LD_EXP 32
18705: PPUSH
18706: LD_STRING DEnd-JMM-Yam-1
18708: PPUSH
18709: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18713: LD_EXP 46
18717: PUSH
18718: LD_EXP 46
18722: PPUSH
18723: CALL_OW 305
18727: AND
18728: IFFALSE 18742
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18730: LD_EXP 46
18734: PPUSH
18735: LD_STRING DEnd-JMM-Kap-1
18737: PPUSH
18738: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18742: LD_EXP 49
18746: PUSH
18747: LD_EXP 49
18751: PPUSH
18752: CALL_OW 305
18756: AND
18757: IFFALSE 18771
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18759: LD_EXP 49
18763: PPUSH
18764: LD_STRING DEnd-JMM-Kov-1
18766: PPUSH
18767: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
18771: LD_EXP 44
18775: PUSH
18776: LD_EXP 44
18780: PPUSH
18781: CALL_OW 305
18785: AND
18786: IFFALSE 18800
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18788: LD_EXP 44
18792: PPUSH
18793: LD_STRING DEnd-JMM-Sch-1
18795: PPUSH
18796: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
18800: LD_EXP 40
18804: PUSH
18805: LD_EXP 40
18809: PPUSH
18810: CALL_OW 305
18814: AND
18815: PUSH
18816: LD_EXP 52
18820: PPUSH
18821: CALL_OW 302
18825: AND
18826: IFFALSE 18840
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18828: LD_EXP 40
18832: PPUSH
18833: LD_STRING DEnd-JMM-Tit-1
18835: PPUSH
18836: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
18840: LD_EXP 45
18844: PUSH
18845: LD_EXP 45
18849: PPUSH
18850: CALL_OW 305
18854: AND
18855: IFFALSE 18869
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18857: LD_EXP 45
18861: PPUSH
18862: LD_STRING DEnd-JMM-Obl-1
18864: PPUSH
18865: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
18869: LD_EXP 47
18873: PUSH
18874: LD_EXP 47
18878: PPUSH
18879: CALL_OW 305
18883: AND
18884: IFFALSE 18898
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18886: LD_EXP 47
18890: PPUSH
18891: LD_STRING DEnd-JMM-Lip-1
18893: PPUSH
18894: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
18898: LD_EXP 41
18902: PUSH
18903: LD_EXP 41
18907: PPUSH
18908: CALL_OW 305
18912: AND
18913: PUSH
18914: LD_EXP 52
18918: PPUSH
18919: CALL_OW 302
18923: AND
18924: IFFALSE 18938
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
18926: LD_EXP 41
18930: PPUSH
18931: LD_STRING DEnd-Burlak-Fad-1
18933: PPUSH
18934: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
18938: LD_EXP 48
18942: PUSH
18943: LD_EXP 48
18947: PPUSH
18948: CALL_OW 305
18952: AND
18953: IFFALSE 18967
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
18955: LD_EXP 48
18959: PPUSH
18960: LD_STRING DEnd-Burlak-Ptr-1
18962: PPUSH
18963: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
18967: LD_EXP 50
18971: PUSH
18972: LD_EXP 50
18976: PPUSH
18977: CALL_OW 305
18981: AND
18982: IFFALSE 18996
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
18984: LD_EXP 50
18988: PPUSH
18989: LD_STRING DEnd-Burlak-Kuz-1
18991: PPUSH
18992: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
18996: LD_EXP 39
19000: PUSH
19001: LD_EXP 39
19005: PPUSH
19006: CALL_OW 305
19010: AND
19011: PUSH
19012: LD_EXP 52
19016: PPUSH
19017: CALL_OW 302
19021: AND
19022: IFFALSE 19036
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
19024: LD_EXP 39
19028: PPUSH
19029: LD_STRING DEnd-Burlak-Kir-1
19031: PPUSH
19032: CALL_OW 88
// if Joan then
19036: LD_EXP 34
19040: IFFALSE 19054
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
19042: LD_EXP 34
19046: PPUSH
19047: LD_STRING DEnd-Burlak-Joan-1
19049: PPUSH
19050: CALL_OW 88
// if IsOk ( Burlak ) then
19054: LD_EXP 52
19058: PPUSH
19059: CALL_OW 302
19063: IFFALSE 19077
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
19065: LD_EXP 19
19069: PPUSH
19070: LD_STRING DEnd-Burlak-JMM-1
19072: PPUSH
19073: CALL_OW 88
// dwait ( 0 0$2 ) ;
19077: LD_INT 70
19079: PPUSH
19080: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
19084: LD_EXP 57
19088: PPUSH
19089: LD_STRING DEnd-Szulc
19091: PPUSH
19092: CALL_OW 94
// dwait ( 0 0$1 ) ;
19096: LD_INT 35
19098: PPUSH
19099: CALL_OW 68
// if IsLive ( Burlak ) then
19103: LD_EXP 52
19107: PPUSH
19108: CALL_OW 300
19112: IFFALSE 19124
// med1 := 1 else
19114: LD_ADDR_VAR 0 1
19118: PUSH
19119: LD_INT 1
19121: ST_TO_ADDR
19122: GO 19133
// med1 := - 1 ;
19124: LD_ADDR_VAR 0 1
19128: PUSH
19129: LD_INT 1
19131: NEG
19132: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
19133: LD_EXP 12
19137: PUSH
19138: LD_EXP 13
19142: AND
19143: PUSH
19144: LD_EXP 14
19148: AND
19149: IFFALSE 19161
// med2 := 1 else
19151: LD_ADDR_VAR 0 2
19155: PUSH
19156: LD_INT 1
19158: ST_TO_ADDR
19159: GO 19170
// med2 := - 1 ;
19161: LD_ADDR_VAR 0 2
19165: PUSH
19166: LD_INT 1
19168: NEG
19169: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
19170: LD_STRING Hero
19172: PPUSH
19173: LD_INT 1
19175: PPUSH
19176: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
19180: LD_STRING Artefact
19182: PPUSH
19183: LD_VAR 0 2
19187: PPUSH
19188: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
19192: LD_STRING ReconcileBurlak
19194: PPUSH
19195: LD_VAR 0 1
19199: PPUSH
19200: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
19204: LD_OWVAR 67
19208: PUSH
19209: LD_INT 3
19211: GREATEREQUAL
19212: PUSH
19213: LD_VAR 0 1
19217: PUSH
19218: LD_INT 1
19220: EQUAL
19221: AND
19222: PUSH
19223: LD_VAR 0 2
19227: PUSH
19228: LD_INT 1
19230: EQUAL
19231: AND
19232: IFFALSE 19244
// SetAchievementEX ( ACH_AMER , 19 ) ;
19234: LD_STRING ACH_AMER
19236: PPUSH
19237: LD_INT 19
19239: PPUSH
19240: CALL_OW 564
// GiveMedals ( MAIN ) ;
19244: LD_STRING MAIN
19246: PPUSH
19247: CALL_OW 102
// InGameOff ;
19251: CALL_OW 9
// DialogueOff ;
19255: CALL_OW 7
// music_nat := 1 ;
19259: LD_ADDR_OWVAR 71
19263: PUSH
19264: LD_INT 1
19266: ST_TO_ADDR
// music_class := 4 ;
19267: LD_ADDR_OWVAR 72
19271: PUSH
19272: LD_INT 4
19274: ST_TO_ADDR
// YouWin ;
19275: CALL_OW 103
// end ; end_of_file
19279: PPOPN 2
19281: END
// export function InitNature ; begin
19282: LD_INT 0
19284: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
19285: LD_INT 3
19287: PPUSH
19288: LD_INT 3
19290: PPUSH
19291: LD_INT 2
19293: PPUSH
19294: LD_INT 1
19296: PPUSH
19297: LD_INT 1
19299: PPUSH
19300: LD_INT 0
19302: PPUSH
19303: LD_INT 0
19305: PPUSH
19306: LD_INT 17
19308: PPUSH
19309: LD_INT 0
19311: PPUSH
19312: CALL 87692 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
19316: LD_INT 2
19318: PPUSH
19319: LD_INT 1
19321: PPUSH
19322: LD_INT 1
19324: PPUSH
19325: LD_INT 1
19327: PPUSH
19328: LD_INT 1
19330: PPUSH
19331: LD_INT 0
19333: PPUSH
19334: LD_INT 0
19336: PPUSH
19337: LD_INT 18
19339: PPUSH
19340: LD_INT 0
19342: PPUSH
19343: CALL 87692 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
19347: LD_INT 4
19349: PPUSH
19350: LD_INT 1
19352: PPUSH
19353: LD_INT 2
19355: PPUSH
19356: LD_INT 4
19358: PPUSH
19359: LD_INT 2
19361: PPUSH
19362: LD_INT 1
19364: PPUSH
19365: LD_INT 0
19367: PPUSH
19368: LD_INT 19
19370: PPUSH
19371: LD_INT 0
19373: PPUSH
19374: CALL 87692 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
19378: LD_INT 0
19380: PPUSH
19381: LD_INT 0
19383: PPUSH
19384: LD_INT 0
19386: PPUSH
19387: LD_INT 0
19389: PPUSH
19390: LD_INT 0
19392: PPUSH
19393: LD_INT 0
19395: PPUSH
19396: LD_INT 9
19398: PPUSH
19399: LD_INT 0
19401: PPUSH
19402: LD_INT 20
19404: PPUSH
19405: CALL 87692 0 9
// end ; end_of_file
19409: LD_VAR 0 1
19413: RET
// every 0 0$30 do var time ;
19414: GO 19416
19416: DISABLE
19417: LD_INT 0
19419: PPUSH
// begin time := 0 0$30 ;
19420: LD_ADDR_VAR 0 1
19424: PUSH
19425: LD_INT 1050
19427: ST_TO_ADDR
// repeat wait ( time ) ;
19428: LD_VAR 0 1
19432: PPUSH
19433: CALL_OW 67
// if Prob ( 50 ) then
19437: LD_INT 50
19439: PPUSH
19440: CALL_OW 13
19444: IFFALSE 19473
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
19446: LD_INT 1
19448: PPUSH
19449: LD_INT 5
19451: PPUSH
19452: CALL_OW 12
19456: PPUSH
19457: LD_INT 106
19459: PPUSH
19460: LD_INT 89
19462: PPUSH
19463: LD_INT 45
19465: PPUSH
19466: LD_INT 1
19468: PPUSH
19469: CALL_OW 56
// time := time + 0 0$3 ;
19473: LD_ADDR_VAR 0 1
19477: PUSH
19478: LD_VAR 0 1
19482: PUSH
19483: LD_INT 105
19485: PLUS
19486: ST_TO_ADDR
// if Prob ( 30 ) then
19487: LD_INT 30
19489: PPUSH
19490: CALL_OW 13
19494: IFFALSE 19540
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
19496: LD_INT 525
19498: PPUSH
19499: LD_INT 735
19501: PPUSH
19502: CALL_OW 12
19506: PPUSH
19507: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19511: LD_INT 1
19513: PPUSH
19514: LD_INT 5
19516: PPUSH
19517: CALL_OW 12
19521: PPUSH
19522: LD_INT 21
19524: PPUSH
19525: LD_INT 26
19527: PPUSH
19528: LD_INT 12
19530: PPUSH
19531: LD_INT 1
19533: PPUSH
19534: CALL_OW 56
// end else
19538: GO 19576
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19540: LD_INT 700
19542: PPUSH
19543: LD_INT 1225
19545: PPUSH
19546: CALL_OW 12
19550: PPUSH
19551: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19555: LD_INT 1
19557: PPUSH
19558: LD_INT 5
19560: PPUSH
19561: CALL_OW 12
19565: PPUSH
19566: LD_INT 14
19568: PPUSH
19569: LD_INT 1
19571: PPUSH
19572: CALL_OW 55
// end ; if Prob ( 50 ) then
19576: LD_INT 50
19578: PPUSH
19579: CALL_OW 13
19583: IFFALSE 19629
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19585: LD_INT 700
19587: PPUSH
19588: LD_INT 1050
19590: PPUSH
19591: CALL_OW 12
19595: PPUSH
19596: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19600: LD_INT 1
19602: PPUSH
19603: LD_INT 5
19605: PPUSH
19606: CALL_OW 12
19610: PPUSH
19611: LD_INT 181
19613: PPUSH
19614: LD_INT 218
19616: PPUSH
19617: LD_INT 16
19619: PPUSH
19620: LD_INT 1
19622: PPUSH
19623: CALL_OW 56
// end else
19627: GO 19701
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19629: LD_INT 350
19631: PPUSH
19632: LD_INT 525
19634: PPUSH
19635: CALL_OW 12
19639: PPUSH
19640: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19644: LD_INT 1
19646: PPUSH
19647: LD_INT 5
19649: PPUSH
19650: CALL_OW 12
19654: PPUSH
19655: LD_INT 13
19657: PPUSH
19658: LD_INT 1
19660: PPUSH
19661: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19665: LD_INT 350
19667: PPUSH
19668: LD_INT 700
19670: PPUSH
19671: CALL_OW 12
19675: PPUSH
19676: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19680: LD_INT 1
19682: PPUSH
19683: LD_INT 5
19685: PPUSH
19686: CALL_OW 12
19690: PPUSH
19691: LD_INT 33
19693: PPUSH
19694: LD_INT 1
19696: PPUSH
19697: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19701: LD_INT 65
19703: PUSH
19704: LD_INT 62
19706: PUSH
19707: LD_INT 55
19709: PUSH
19710: LD_INT 50
19712: PUSH
19713: EMPTY
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: PUSH
19719: LD_OWVAR 67
19723: ARRAY
19724: PPUSH
19725: CALL_OW 13
19729: IFFALSE 19775
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19731: LD_INT 525
19733: PPUSH
19734: LD_INT 875
19736: PPUSH
19737: CALL_OW 12
19741: PPUSH
19742: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19746: LD_INT 1
19748: PPUSH
19749: LD_INT 5
19751: PPUSH
19752: CALL_OW 12
19756: PPUSH
19757: LD_INT 294
19759: PPUSH
19760: LD_INT 211
19762: PPUSH
19763: LD_INT 30
19765: PPUSH
19766: LD_INT 1
19768: PPUSH
19769: CALL_OW 56
// end else
19773: GO 19817
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
19775: LD_INT 420
19777: PPUSH
19778: LD_INT 770
19780: PPUSH
19781: CALL_OW 12
19785: PPUSH
19786: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19790: LD_INT 1
19792: PPUSH
19793: LD_INT 5
19795: PPUSH
19796: CALL_OW 12
19800: PPUSH
19801: LD_INT 294
19803: PPUSH
19804: LD_INT 211
19806: PPUSH
19807: LD_INT 30
19809: PPUSH
19810: LD_INT 1
19812: PPUSH
19813: CALL_OW 56
// end ; if time > 2 2$20 then
19817: LD_VAR 0 1
19821: PUSH
19822: LD_INT 4900
19824: GREATER
19825: IFFALSE 19835
// time := 0 0$50 ;
19827: LD_ADDR_VAR 0 1
19831: PUSH
19832: LD_INT 1750
19834: ST_TO_ADDR
// until false ;
19835: LD_INT 0
19837: IFFALSE 19428
// end ;
19839: PPOPN 1
19841: END
// every 0 0$45 trigger tick < 10 10$00 do
19842: LD_OWVAR 1
19846: PUSH
19847: LD_INT 21000
19849: LESS
19850: IFFALSE 19898
19852: GO 19854
19854: DISABLE
// begin enable ;
19855: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19856: LD_INT 350
19858: PPUSH
19859: LD_INT 700
19861: PPUSH
19862: CALL_OW 12
19866: PPUSH
19867: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
19871: LD_INT 3
19873: PPUSH
19874: LD_INT 5
19876: PPUSH
19877: CALL_OW 12
19881: PPUSH
19882: LD_INT 181
19884: PPUSH
19885: LD_INT 13
19887: PPUSH
19888: LD_INT 20
19890: PPUSH
19891: LD_INT 1
19893: PPUSH
19894: CALL_OW 56
// end ; end_of_file
19898: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
19899: LD_INT 0
19901: PPUSH
// SetArtifactRes ( 7 , true ) ;
19902: LD_INT 7
19904: PPUSH
19905: LD_INT 1
19907: PPUSH
19908: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
19912: LD_ADDR_EXP 66
19916: PUSH
19917: EMPTY
19918: PUSH
19919: EMPTY
19920: PUSH
19921: EMPTY
19922: PUSH
19923: EMPTY
19924: LIST
19925: LIST
19926: LIST
19927: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
19928: LD_ADDR_EXP 67
19932: PUSH
19933: LD_INT 1050
19935: PUSH
19936: LD_OWVAR 67
19940: MUL
19941: PUSH
19942: LD_INT 2800
19944: PUSH
19945: LD_OWVAR 67
19949: MUL
19950: PUSH
19951: LD_INT 1
19953: NEG
19954: PUSH
19955: EMPTY
19956: LIST
19957: LIST
19958: LIST
19959: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
19960: LD_ADDR_EXP 68
19964: PUSH
19965: LD_INT 10
19967: PUSH
19968: LD_INT 35
19970: PUSH
19971: LD_INT 100
19973: PUSH
19974: EMPTY
19975: LIST
19976: LIST
19977: LIST
19978: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
19979: LD_ADDR_EXP 69
19983: PUSH
19984: LD_INT 0
19986: PUSH
19987: LD_INT 0
19989: PUSH
19990: LD_INT 0
19992: PUSH
19993: EMPTY
19994: LIST
19995: LIST
19996: LIST
19997: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
19998: LD_ADDR_EXP 71
20002: PUSH
20003: LD_INT 300
20005: PUSH
20006: LD_INT 500
20008: PUSH
20009: LD_INT 800
20011: PUSH
20012: EMPTY
20013: LIST
20014: LIST
20015: LIST
20016: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
20017: LD_ADDR_EXP 72
20021: PUSH
20022: LD_INT 0
20024: PUSH
20025: LD_INT 0
20027: PUSH
20028: LD_INT 0
20030: PUSH
20031: EMPTY
20032: LIST
20033: LIST
20034: LIST
20035: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
20036: LD_ADDR_EXP 73
20040: PUSH
20041: LD_INT 0
20043: PUSH
20044: LD_INT 0
20046: PUSH
20047: LD_INT 0
20049: PUSH
20050: EMPTY
20051: LIST
20052: LIST
20053: LIST
20054: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
20055: LD_ADDR_EXP 70
20059: PUSH
20060: LD_INT 0
20062: PUSH
20063: LD_INT 0
20065: PUSH
20066: LD_INT 0
20068: PUSH
20069: EMPTY
20070: LIST
20071: LIST
20072: LIST
20073: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
20074: LD_ADDR_EXP 74
20078: PUSH
20079: LD_INT 4
20081: PUSH
20082: LD_INT 3
20084: PUSH
20085: LD_INT 1
20087: PUSH
20088: EMPTY
20089: LIST
20090: LIST
20091: LIST
20092: PUSH
20093: LD_INT 5
20095: PUSH
20096: LD_INT 4
20098: PUSH
20099: LD_INT 2
20101: PUSH
20102: EMPTY
20103: LIST
20104: LIST
20105: LIST
20106: PUSH
20107: LD_INT 6
20109: PUSH
20110: LD_INT 3
20112: PUSH
20113: LD_INT 3
20115: PUSH
20116: EMPTY
20117: LIST
20118: LIST
20119: LIST
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
20126: LD_ADDR_EXP 75
20130: PUSH
20131: LD_INT 0
20133: PUSH
20134: LD_INT 0
20136: PUSH
20137: LD_INT 0
20139: PUSH
20140: EMPTY
20141: LIST
20142: LIST
20143: LIST
20144: ST_TO_ADDR
// end ;
20145: LD_VAR 0 1
20149: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
20150: LD_INT 24
20152: PPUSH
20153: LD_INT 7
20155: PPUSH
20156: CALL_OW 321
20160: PUSH
20161: LD_INT 2
20163: EQUAL
20164: IFFALSE 21090
20166: GO 20168
20168: DISABLE
20169: LD_INT 0
20171: PPUSH
20172: PPUSH
20173: PPUSH
20174: PPUSH
20175: PPUSH
// begin enable ;
20176: ENABLE
// for i = 1 to 3 do
20177: LD_ADDR_VAR 0 1
20181: PUSH
20182: DOUBLE
20183: LD_INT 1
20185: DEC
20186: ST_TO_ADDR
20187: LD_INT 3
20189: PUSH
20190: FOR_TO
20191: IFFALSE 21088
// begin pos := FindArtifact ( i + 2 ) ;
20193: LD_ADDR_VAR 0 2
20197: PUSH
20198: LD_VAR 0 1
20202: PUSH
20203: LD_INT 2
20205: PLUS
20206: PPUSH
20207: CALL_OW 469
20211: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
20212: LD_ADDR_EXP 66
20216: PUSH
20217: LD_EXP 66
20221: PPUSH
20222: LD_VAR 0 1
20226: PPUSH
20227: LD_VAR 0 2
20231: PPUSH
20232: CALL_OW 1
20236: ST_TO_ADDR
// if pos then
20237: LD_VAR 0 2
20241: IFFALSE 20949
// begin case i of 1 :
20243: LD_VAR 0 1
20247: PUSH
20248: LD_INT 1
20250: DOUBLE
20251: EQUAL
20252: IFTRUE 20256
20254: GO 20333
20256: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
20257: LD_ADDR_VAR 0 4
20261: PUSH
20262: LD_INT 22
20264: PUSH
20265: LD_INT 7
20267: PUSH
20268: EMPTY
20269: LIST
20270: LIST
20271: PUSH
20272: LD_INT 23
20274: PUSH
20275: LD_INT 1
20277: PUSH
20278: EMPTY
20279: LIST
20280: LIST
20281: PUSH
20282: LD_INT 2
20284: PUSH
20285: LD_INT 30
20287: PUSH
20288: LD_INT 8
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: PUSH
20295: LD_INT 30
20297: PUSH
20298: LD_INT 7
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: PUSH
20305: LD_INT 30
20307: PUSH
20308: LD_INT 11
20310: PUSH
20311: EMPTY
20312: LIST
20313: LIST
20314: PUSH
20315: EMPTY
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: LIST
20325: PPUSH
20326: CALL_OW 69
20330: ST_TO_ADDR
20331: GO 20441
20333: LD_INT 2
20335: DOUBLE
20336: EQUAL
20337: IFTRUE 20341
20339: GO 20418
20341: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
20342: LD_ADDR_VAR 0 4
20346: PUSH
20347: LD_INT 22
20349: PUSH
20350: LD_INT 7
20352: PUSH
20353: EMPTY
20354: LIST
20355: LIST
20356: PUSH
20357: LD_INT 23
20359: PUSH
20360: LD_INT 3
20362: PUSH
20363: EMPTY
20364: LIST
20365: LIST
20366: PUSH
20367: LD_INT 2
20369: PUSH
20370: LD_INT 30
20372: PUSH
20373: LD_INT 8
20375: PUSH
20376: EMPTY
20377: LIST
20378: LIST
20379: PUSH
20380: LD_INT 30
20382: PUSH
20383: LD_INT 7
20385: PUSH
20386: EMPTY
20387: LIST
20388: LIST
20389: PUSH
20390: LD_INT 30
20392: PUSH
20393: LD_INT 11
20395: PUSH
20396: EMPTY
20397: LIST
20398: LIST
20399: PUSH
20400: EMPTY
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: PUSH
20406: EMPTY
20407: LIST
20408: LIST
20409: LIST
20410: PPUSH
20411: CALL_OW 69
20415: ST_TO_ADDR
20416: GO 20441
20418: LD_INT 3
20420: DOUBLE
20421: EQUAL
20422: IFTRUE 20426
20424: GO 20440
20426: POP
// labs := [ alien ] ; end ;
20427: LD_ADDR_VAR 0 4
20431: PUSH
20432: LD_INT 1
20434: PUSH
20435: EMPTY
20436: LIST
20437: ST_TO_ADDR
20438: GO 20441
20440: POP
// if not labs then
20441: LD_VAR 0 4
20445: NOT
20446: IFFALSE 20450
// continue ;
20448: GO 20190
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
20450: LD_ADDR_VAR 0 5
20454: PUSH
20455: LD_VAR 0 4
20459: PPUSH
20460: LD_EXP 66
20464: PUSH
20465: LD_VAR 0 1
20469: ARRAY
20470: PUSH
20471: LD_INT 1
20473: ARRAY
20474: PPUSH
20475: LD_EXP 66
20479: PUSH
20480: LD_VAR 0 1
20484: ARRAY
20485: PUSH
20486: LD_INT 2
20488: ARRAY
20489: PPUSH
20490: CALL_OW 73
20494: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
20495: LD_VAR 0 5
20499: NOT
20500: PUSH
20501: LD_VAR 0 5
20505: PUSH
20506: LD_EXP 73
20510: PUSH
20511: LD_VAR 0 1
20515: ARRAY
20516: NONEQUAL
20517: OR
20518: IFFALSE 20623
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20520: LD_INT 7
20522: PPUSH
20523: LD_EXP 74
20527: PUSH
20528: LD_VAR 0 1
20532: ARRAY
20533: PUSH
20534: LD_INT 3
20536: ARRAY
20537: PPUSH
20538: LD_INT 0
20540: PPUSH
20541: LD_EXP 73
20545: PUSH
20546: LD_VAR 0 1
20550: ARRAY
20551: PPUSH
20552: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20556: LD_INT 7
20558: PPUSH
20559: LD_EXP 74
20563: PUSH
20564: LD_VAR 0 1
20568: ARRAY
20569: PUSH
20570: LD_INT 1
20572: ARRAY
20573: PPUSH
20574: LD_INT 0
20576: PPUSH
20577: LD_EXP 73
20581: PUSH
20582: LD_VAR 0 1
20586: ARRAY
20587: PPUSH
20588: CALL_OW 468
// if nearestLab then
20592: LD_VAR 0 5
20596: IFFALSE 20623
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20598: LD_ADDR_EXP 73
20602: PUSH
20603: LD_EXP 73
20607: PPUSH
20608: LD_VAR 0 1
20612: PPUSH
20613: LD_VAR 0 5
20617: PPUSH
20618: CALL_OW 1
20622: ST_TO_ADDR
// end ; if not nearestLab then
20623: LD_VAR 0 5
20627: NOT
20628: IFFALSE 20632
// continue ;
20630: GO 20190
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20632: LD_VAR 0 5
20636: PPUSH
20637: LD_EXP 66
20641: PUSH
20642: LD_VAR 0 1
20646: ARRAY
20647: PUSH
20648: LD_INT 1
20650: ARRAY
20651: PPUSH
20652: LD_EXP 66
20656: PUSH
20657: LD_VAR 0 1
20661: ARRAY
20662: PUSH
20663: LD_INT 2
20665: ARRAY
20666: PPUSH
20667: CALL_OW 297
20671: PUSH
20672: LD_INT 8
20674: LESS
20675: IFFALSE 20872
// begin if not artifactsResearched [ i ] then
20677: LD_EXP 69
20681: PUSH
20682: LD_VAR 0 1
20686: ARRAY
20687: NOT
20688: IFFALSE 20769
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20690: LD_VAR 0 5
20694: PPUSH
20695: CALL_OW 461
20699: PUSH
20700: LD_INT 2
20702: EQUAL
20703: IFFALSE 20737
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20705: LD_INT 7
20707: PPUSH
20708: LD_EXP 74
20712: PUSH
20713: LD_VAR 0 1
20717: ARRAY
20718: PUSH
20719: LD_INT 3
20721: ARRAY
20722: PPUSH
20723: LD_INT 2
20725: PPUSH
20726: LD_VAR 0 5
20730: PPUSH
20731: CALL_OW 468
20735: GO 20767
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20737: LD_INT 7
20739: PPUSH
20740: LD_EXP 74
20744: PUSH
20745: LD_VAR 0 1
20749: ARRAY
20750: PUSH
20751: LD_INT 3
20753: ARRAY
20754: PPUSH
20755: LD_INT 1
20757: PPUSH
20758: LD_VAR 0 5
20762: PPUSH
20763: CALL_OW 468
// end else
20767: GO 20870
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
20769: LD_VAR 0 5
20773: PPUSH
20774: CALL_OW 461
20778: PUSH
20779: LD_INT 2
20781: EQUAL
20782: PUSH
20783: LD_EXP 75
20787: PUSH
20788: LD_VAR 0 1
20792: ARRAY
20793: AND
20794: IFFALSE 20840
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
20796: LD_INT 7
20798: PPUSH
20799: LD_EXP 74
20803: PUSH
20804: LD_VAR 0 1
20808: ARRAY
20809: PUSH
20810: LD_INT 1
20812: ARRAY
20813: PPUSH
20814: LD_EXP 74
20818: PUSH
20819: LD_VAR 0 1
20823: ARRAY
20824: PUSH
20825: LD_INT 2
20827: ARRAY
20828: PPUSH
20829: LD_VAR 0 5
20833: PPUSH
20834: CALL_OW 468
20838: GO 20870
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
20840: LD_INT 7
20842: PPUSH
20843: LD_EXP 74
20847: PUSH
20848: LD_VAR 0 1
20852: ARRAY
20853: PUSH
20854: LD_INT 1
20856: ARRAY
20857: PPUSH
20858: LD_INT 1
20860: PPUSH
20861: LD_VAR 0 5
20865: PPUSH
20866: CALL_OW 468
// end else
20870: GO 20947
// begin if not artifactsResearched [ i ] then
20872: LD_EXP 69
20876: PUSH
20877: LD_VAR 0 1
20881: ARRAY
20882: NOT
20883: IFFALSE 20917
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
20885: LD_INT 7
20887: PPUSH
20888: LD_EXP 74
20892: PUSH
20893: LD_VAR 0 1
20897: ARRAY
20898: PUSH
20899: LD_INT 3
20901: ARRAY
20902: PPUSH
20903: LD_INT 0
20905: PPUSH
20906: LD_VAR 0 5
20910: PPUSH
20911: CALL_OW 468
20915: GO 20947
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
20917: LD_INT 7
20919: PPUSH
20920: LD_EXP 74
20924: PUSH
20925: LD_VAR 0 1
20929: ARRAY
20930: PUSH
20931: LD_INT 1
20933: ARRAY
20934: PPUSH
20935: LD_INT 0
20937: PPUSH
20938: LD_VAR 0 5
20942: PPUSH
20943: CALL_OW 468
// end ; end else
20947: GO 21086
// begin if not artifactsLabs [ i ] then
20949: LD_EXP 73
20953: PUSH
20954: LD_VAR 0 1
20958: ARRAY
20959: NOT
20960: IFFALSE 20964
// continue ;
20962: GO 20190
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20964: LD_INT 7
20966: PPUSH
20967: LD_EXP 74
20971: PUSH
20972: LD_VAR 0 1
20976: ARRAY
20977: PUSH
20978: LD_INT 3
20980: ARRAY
20981: PPUSH
20982: LD_INT 0
20984: PPUSH
20985: LD_EXP 73
20989: PUSH
20990: LD_VAR 0 1
20994: ARRAY
20995: PPUSH
20996: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
21000: LD_INT 7
21002: PPUSH
21003: LD_EXP 74
21007: PUSH
21008: LD_VAR 0 1
21012: ARRAY
21013: PUSH
21014: LD_INT 1
21016: ARRAY
21017: PPUSH
21018: LD_INT 0
21020: PPUSH
21021: LD_EXP 73
21025: PUSH
21026: LD_VAR 0 1
21030: ARRAY
21031: PPUSH
21032: CALL_OW 468
// if artifactsLabsWorking [ i ] then
21036: LD_EXP 70
21040: PUSH
21041: LD_VAR 0 1
21045: ARRAY
21046: IFFALSE 21086
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
21048: LD_ADDR_EXP 70
21052: PUSH
21053: LD_EXP 70
21057: PPUSH
21058: LD_VAR 0 1
21062: PPUSH
21063: LD_INT 0
21065: PPUSH
21066: CALL_OW 1
21070: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
21071: LD_EXP 73
21075: PUSH
21076: LD_VAR 0 1
21080: ARRAY
21081: PPUSH
21082: CALL_OW 127
// end ; end ; end ;
21086: GO 20190
21088: POP
21089: POP
// end ;
21090: PPOPN 5
21092: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
21093: LD_INT 0
21095: PPUSH
21096: PPUSH
21097: PPUSH
21098: PPUSH
21099: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
21100: LD_VAR 0 2
21104: PUSH
21105: LD_EXP 74
21109: PUSH
21110: LD_INT 1
21112: ARRAY
21113: PUSH
21114: LD_INT 3
21116: ARRAY
21117: EQUAL
21118: IFFALSE 21241
// begin lab := artifactsLabs [ 1 ] ;
21120: LD_ADDR_VAR 0 6
21124: PUSH
21125: LD_EXP 73
21129: PUSH
21130: LD_INT 1
21132: ARRAY
21133: ST_TO_ADDR
// if not lab then
21134: LD_VAR 0 6
21138: NOT
21139: IFFALSE 21143
// exit ;
21141: GO 22221
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
21143: LD_VAR 0 6
21147: PPUSH
21148: LD_EXP 71
21152: PUSH
21153: LD_INT 1
21155: ARRAY
21156: PPUSH
21157: LD_INT 1
21159: PPUSH
21160: CALL_OW 486
// if artifactsResProgress [ 1 ] then
21164: LD_EXP 72
21168: PUSH
21169: LD_INT 1
21171: ARRAY
21172: IFFALSE 21192
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
21174: LD_VAR 0 6
21178: PPUSH
21179: LD_EXP 72
21183: PUSH
21184: LD_INT 1
21186: ARRAY
21187: PPUSH
21188: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
21192: LD_ADDR_EXP 70
21196: PUSH
21197: LD_EXP 70
21201: PPUSH
21202: LD_INT 1
21204: PPUSH
21205: LD_INT 1
21207: PPUSH
21208: CALL_OW 1
21212: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
21213: LD_INT 7
21215: PPUSH
21216: LD_EXP 74
21220: PUSH
21221: LD_INT 1
21223: ARRAY
21224: PUSH
21225: LD_INT 3
21227: ARRAY
21228: PPUSH
21229: LD_INT 0
21231: PPUSH
21232: LD_VAR 0 6
21236: PPUSH
21237: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
21241: LD_VAR 0 2
21245: PUSH
21246: LD_EXP 74
21250: PUSH
21251: LD_INT 2
21253: ARRAY
21254: PUSH
21255: LD_INT 3
21257: ARRAY
21258: EQUAL
21259: IFFALSE 21382
// begin lab := artifactsLabs [ 2 ] ;
21261: LD_ADDR_VAR 0 6
21265: PUSH
21266: LD_EXP 73
21270: PUSH
21271: LD_INT 2
21273: ARRAY
21274: ST_TO_ADDR
// if not lab then
21275: LD_VAR 0 6
21279: NOT
21280: IFFALSE 21284
// exit ;
21282: GO 22221
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
21284: LD_VAR 0 6
21288: PPUSH
21289: LD_EXP 71
21293: PUSH
21294: LD_INT 2
21296: ARRAY
21297: PPUSH
21298: LD_INT 1
21300: PPUSH
21301: CALL_OW 486
// if artifactsResProgress [ 2 ] then
21305: LD_EXP 72
21309: PUSH
21310: LD_INT 2
21312: ARRAY
21313: IFFALSE 21333
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
21315: LD_VAR 0 6
21319: PPUSH
21320: LD_EXP 72
21324: PUSH
21325: LD_INT 2
21327: ARRAY
21328: PPUSH
21329: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
21333: LD_ADDR_EXP 70
21337: PUSH
21338: LD_EXP 70
21342: PPUSH
21343: LD_INT 2
21345: PPUSH
21346: LD_INT 1
21348: PPUSH
21349: CALL_OW 1
21353: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
21354: LD_INT 7
21356: PPUSH
21357: LD_EXP 74
21361: PUSH
21362: LD_INT 2
21364: ARRAY
21365: PUSH
21366: LD_INT 3
21368: ARRAY
21369: PPUSH
21370: LD_INT 0
21372: PPUSH
21373: LD_VAR 0 6
21377: PPUSH
21378: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
21382: LD_VAR 0 2
21386: PUSH
21387: LD_EXP 74
21391: PUSH
21392: LD_INT 3
21394: ARRAY
21395: PUSH
21396: LD_INT 3
21398: ARRAY
21399: EQUAL
21400: IFFALSE 21523
// begin lab := artifactsLabs [ 3 ] ;
21402: LD_ADDR_VAR 0 6
21406: PUSH
21407: LD_EXP 73
21411: PUSH
21412: LD_INT 3
21414: ARRAY
21415: ST_TO_ADDR
// if not lab then
21416: LD_VAR 0 6
21420: NOT
21421: IFFALSE 21425
// exit ;
21423: GO 22221
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
21425: LD_VAR 0 6
21429: PPUSH
21430: LD_EXP 71
21434: PUSH
21435: LD_INT 3
21437: ARRAY
21438: PPUSH
21439: LD_INT 1
21441: PPUSH
21442: CALL_OW 486
// if artifactsResProgress [ 3 ] then
21446: LD_EXP 72
21450: PUSH
21451: LD_INT 3
21453: ARRAY
21454: IFFALSE 21474
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
21456: LD_VAR 0 6
21460: PPUSH
21461: LD_EXP 72
21465: PUSH
21466: LD_INT 3
21468: ARRAY
21469: PPUSH
21470: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
21474: LD_ADDR_EXP 70
21478: PUSH
21479: LD_EXP 70
21483: PPUSH
21484: LD_INT 3
21486: PPUSH
21487: LD_INT 1
21489: PPUSH
21490: CALL_OW 1
21494: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
21495: LD_INT 7
21497: PPUSH
21498: LD_EXP 74
21502: PUSH
21503: LD_INT 3
21505: ARRAY
21506: PUSH
21507: LD_INT 3
21509: ARRAY
21510: PPUSH
21511: LD_INT 0
21513: PPUSH
21514: LD_VAR 0 6
21518: PPUSH
21519: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21523: LD_VAR 0 2
21527: PUSH
21528: LD_EXP 74
21532: PUSH
21533: LD_INT 1
21535: ARRAY
21536: PUSH
21537: LD_INT 1
21539: ARRAY
21540: EQUAL
21541: IFFALSE 21699
// begin lab := artifactsLabs [ 1 ] ;
21543: LD_ADDR_VAR 0 6
21547: PUSH
21548: LD_EXP 73
21552: PUSH
21553: LD_INT 1
21555: ARRAY
21556: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21557: LD_VAR 0 6
21561: PPUSH
21562: CALL_OW 274
21566: PPUSH
21567: CALL 91245 0 1
21571: PUSH
21572: LD_INT 3
21574: ARRAY
21575: PUSH
21576: LD_EXP 68
21580: PUSH
21581: LD_INT 1
21583: ARRAY
21584: LESS
21585: IFFALSE 21599
// begin HintSpec ( ArtifactCost , 2 ) ;
21587: LD_STRING ArtifactCost
21589: PPUSH
21590: LD_INT 2
21592: PPUSH
21593: CALL_OW 338
// exit ;
21597: GO 22221
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21599: LD_ADDR_EXP 75
21603: PUSH
21604: LD_EXP 75
21608: PPUSH
21609: LD_INT 1
21611: PPUSH
21612: LD_INT 0
21614: PPUSH
21615: CALL_OW 1
21619: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21620: LD_VAR 0 3
21624: PPUSH
21625: LD_VAR 0 4
21629: PPUSH
21630: LD_INT 7
21632: PPUSH
21633: LD_INT 12
21635: NEG
21636: PPUSH
21637: CALL_OW 330
// wait ( 0 0$30 ) ;
21641: LD_INT 1050
21643: PPUSH
21644: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21648: LD_VAR 0 3
21652: PPUSH
21653: LD_VAR 0 4
21657: PPUSH
21658: LD_INT 7
21660: PPUSH
21661: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21665: LD_EXP 67
21669: PUSH
21670: LD_INT 1
21672: ARRAY
21673: PPUSH
21674: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21678: LD_ADDR_EXP 75
21682: PUSH
21683: LD_EXP 75
21687: PPUSH
21688: LD_INT 1
21690: PPUSH
21691: LD_INT 1
21693: PPUSH
21694: CALL_OW 1
21698: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
21699: LD_VAR 0 2
21703: PUSH
21704: LD_EXP 74
21708: PUSH
21709: LD_INT 2
21711: ARRAY
21712: PUSH
21713: LD_INT 1
21715: ARRAY
21716: EQUAL
21717: IFFALSE 21954
// begin lab := artifactsLabs [ 2 ] ;
21719: LD_ADDR_VAR 0 6
21723: PUSH
21724: LD_EXP 73
21728: PUSH
21729: LD_INT 2
21731: ARRAY
21732: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
21733: LD_VAR 0 3
21737: PUSH
21738: LD_INT 81
21740: PUSH
21741: LD_INT 7
21743: PUSH
21744: EMPTY
21745: LIST
21746: LIST
21747: PUSH
21748: LD_INT 2
21750: PUSH
21751: LD_INT 32
21753: PUSH
21754: LD_INT 3
21756: PUSH
21757: EMPTY
21758: LIST
21759: LIST
21760: PUSH
21761: LD_INT 30
21763: PUSH
21764: LD_INT 28
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: PUSH
21771: LD_INT 30
21773: PUSH
21774: LD_INT 30
21776: PUSH
21777: EMPTY
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 35
21783: PUSH
21784: LD_INT 49
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: PUSH
21791: LD_INT 34
21793: PUSH
21794: LD_INT 49
21796: PUSH
21797: EMPTY
21798: LIST
21799: LIST
21800: PUSH
21801: LD_INT 30
21803: PUSH
21804: LD_INT 21
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: LIST
21815: LIST
21816: LIST
21817: LIST
21818: LIST
21819: PUSH
21820: EMPTY
21821: LIST
21822: LIST
21823: PPUSH
21824: CALL_OW 69
21828: IN
21829: NOT
21830: IFFALSE 21834
// exit ;
21832: GO 22221
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
21834: LD_VAR 0 6
21838: PPUSH
21839: CALL_OW 274
21843: PPUSH
21844: CALL 91245 0 1
21848: PUSH
21849: LD_INT 3
21851: ARRAY
21852: PUSH
21853: LD_EXP 68
21857: PUSH
21858: LD_INT 2
21860: ARRAY
21861: LESS
21862: IFFALSE 21876
// begin HintSpec ( ArtifactCost , 2 ) ;
21864: LD_STRING ArtifactCost
21866: PPUSH
21867: LD_INT 2
21869: PPUSH
21870: CALL_OW 338
// exit ;
21874: GO 22221
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
21876: LD_ADDR_EXP 75
21880: PUSH
21881: LD_EXP 75
21885: PPUSH
21886: LD_INT 2
21888: PPUSH
21889: LD_INT 0
21891: PPUSH
21892: CALL_OW 1
21896: ST_TO_ADDR
// KillUnit ( x ) ;
21897: LD_VAR 0 3
21901: PPUSH
21902: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
21906: LD_ADDR_EXP 16
21910: PUSH
21911: LD_EXP 16
21915: PUSH
21916: LD_INT 1
21918: PLUS
21919: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
21920: LD_EXP 67
21924: PUSH
21925: LD_INT 2
21927: ARRAY
21928: PPUSH
21929: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
21933: LD_ADDR_EXP 75
21937: PUSH
21938: LD_EXP 75
21942: PPUSH
21943: LD_INT 2
21945: PPUSH
21946: LD_INT 1
21948: PPUSH
21949: CALL_OW 1
21953: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
21954: LD_VAR 0 2
21958: PUSH
21959: LD_EXP 74
21963: PUSH
21964: LD_INT 3
21966: ARRAY
21967: PUSH
21968: LD_INT 1
21970: ARRAY
21971: EQUAL
21972: IFFALSE 22221
// begin lab := artifactsLabs [ 3 ] ;
21974: LD_ADDR_VAR 0 6
21978: PUSH
21979: LD_EXP 73
21983: PUSH
21984: LD_INT 3
21986: ARRAY
21987: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
21988: LD_VAR 0 6
21992: PPUSH
21993: CALL_OW 274
21997: PPUSH
21998: CALL 91245 0 1
22002: PUSH
22003: LD_INT 3
22005: ARRAY
22006: PUSH
22007: LD_EXP 68
22011: PUSH
22012: LD_INT 3
22014: ARRAY
22015: LESS
22016: IFFALSE 22030
// begin HintSpec ( ArtifactCost , 2 ) ;
22018: LD_STRING ArtifactCost
22020: PPUSH
22021: LD_INT 2
22023: PPUSH
22024: CALL_OW 338
// exit ;
22028: GO 22221
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
22030: LD_INT 37
22032: PPUSH
22033: LD_INT 1
22035: PPUSH
22036: CALL_OW 424
// time := 0 0$30 ;
22040: LD_ADDR_VAR 0 7
22044: PUSH
22045: LD_INT 1050
22047: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
22048: LD_ADDR_EXP 75
22052: PUSH
22053: LD_EXP 75
22057: PPUSH
22058: LD_INT 3
22060: PPUSH
22061: LD_INT 0
22063: PPUSH
22064: CALL_OW 1
22068: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
22069: LD_ADDR_OWVAR 47
22073: PUSH
22074: LD_STRING #Am15a-1
22076: PUSH
22077: LD_VAR 0 7
22081: PUSH
22082: EMPTY
22083: LIST
22084: LIST
22085: ST_TO_ADDR
// wait ( 0 0$1 ) ;
22086: LD_INT 35
22088: PPUSH
22089: CALL_OW 67
// time := time - 0 0$1 ;
22093: LD_ADDR_VAR 0 7
22097: PUSH
22098: LD_VAR 0 7
22102: PUSH
22103: LD_INT 35
22105: MINUS
22106: ST_TO_ADDR
// until time = 0 0$00 ;
22107: LD_VAR 0 7
22111: PUSH
22112: LD_INT 0
22114: EQUAL
22115: IFFALSE 22069
// display_strings :=  ;
22117: LD_ADDR_OWVAR 47
22121: PUSH
22122: LD_STRING 
22124: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
22125: LD_INT 37
22127: PPUSH
22128: LD_INT 0
22130: PPUSH
22131: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
22135: LD_ADDR_VAR 0 8
22139: PUSH
22140: LD_INT 37
22142: PPUSH
22143: LD_INT 3
22145: PUSH
22146: LD_INT 21
22148: PUSH
22149: LD_INT 3
22151: PUSH
22152: EMPTY
22153: LIST
22154: LIST
22155: PUSH
22156: EMPTY
22157: LIST
22158: LIST
22159: PPUSH
22160: CALL_OW 70
22164: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
22165: LD_VAR 0 3
22169: PPUSH
22170: LD_VAR 0 4
22174: PPUSH
22175: CALL_OW 84
// for un in list do
22179: LD_ADDR_VAR 0 9
22183: PUSH
22184: LD_VAR 0 8
22188: PUSH
22189: FOR_IN
22190: IFFALSE 22219
// TeleportUnit ( un , x , y , 12 , true ) ;
22192: LD_VAR 0 9
22196: PPUSH
22197: LD_VAR 0 3
22201: PPUSH
22202: LD_VAR 0 4
22206: PPUSH
22207: LD_INT 12
22209: PPUSH
22210: LD_INT 1
22212: PPUSH
22213: CALL_OW 483
22217: GO 22189
22219: POP
22220: POP
// end ; end ;
22221: PPOPN 9
22223: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
22224: LD_INT 0
22226: PPUSH
22227: PPUSH
// begin labNum := 0 ;
22228: LD_ADDR_VAR 0 4
22232: PUSH
22233: LD_INT 0
22235: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22236: LD_ADDR_VAR 0 3
22240: PUSH
22241: DOUBLE
22242: LD_INT 1
22244: DEC
22245: ST_TO_ADDR
22246: LD_EXP 73
22250: PUSH
22251: FOR_TO
22252: IFFALSE 22286
// if artifactsLabs [ i ] = lab then
22254: LD_EXP 73
22258: PUSH
22259: LD_VAR 0 3
22263: ARRAY
22264: PUSH
22265: LD_VAR 0 1
22269: EQUAL
22270: IFFALSE 22284
// begin labNum := i ;
22272: LD_ADDR_VAR 0 4
22276: PUSH
22277: LD_VAR 0 3
22281: ST_TO_ADDR
// break ;
22282: GO 22286
// end ;
22284: GO 22251
22286: POP
22287: POP
// if not labNum then
22288: LD_VAR 0 4
22292: NOT
22293: IFFALSE 22297
// exit ;
22295: GO 22375
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
22297: LD_INT 7
22299: PPUSH
22300: LD_EXP 74
22304: PUSH
22305: LD_VAR 0 4
22309: ARRAY
22310: PUSH
22311: LD_INT 3
22313: ARRAY
22314: PPUSH
22315: LD_INT 2
22317: PPUSH
22318: LD_VAR 0 1
22322: PPUSH
22323: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
22327: LD_ADDR_EXP 72
22331: PUSH
22332: LD_EXP 72
22336: PPUSH
22337: LD_VAR 0 4
22341: PPUSH
22342: LD_VAR 0 2
22346: PPUSH
22347: CALL_OW 1
22351: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
22352: LD_ADDR_EXP 70
22356: PUSH
22357: LD_EXP 70
22361: PPUSH
22362: LD_VAR 0 4
22366: PPUSH
22367: LD_INT 0
22369: PPUSH
22370: CALL_OW 1
22374: ST_TO_ADDR
// end ;
22375: PPOPN 4
22377: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
22378: LD_INT 0
22380: PPUSH
22381: PPUSH
// begin labNum := 0 ;
22382: LD_ADDR_VAR 0 3
22386: PUSH
22387: LD_INT 0
22389: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22390: LD_ADDR_VAR 0 2
22394: PUSH
22395: DOUBLE
22396: LD_INT 1
22398: DEC
22399: ST_TO_ADDR
22400: LD_EXP 73
22404: PUSH
22405: FOR_TO
22406: IFFALSE 22440
// if artifactsLabs [ i ] = lab then
22408: LD_EXP 73
22412: PUSH
22413: LD_VAR 0 2
22417: ARRAY
22418: PUSH
22419: LD_VAR 0 1
22423: EQUAL
22424: IFFALSE 22438
// begin labNum := i ;
22426: LD_ADDR_VAR 0 3
22430: PUSH
22431: LD_VAR 0 2
22435: ST_TO_ADDR
// break ;
22436: GO 22440
// end ;
22438: GO 22405
22440: POP
22441: POP
// if not labNum then
22442: LD_VAR 0 3
22446: NOT
22447: IFFALSE 22451
// exit ;
22449: GO 22613
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
22451: LD_INT 7
22453: PPUSH
22454: LD_EXP 74
22458: PUSH
22459: LD_VAR 0 3
22463: ARRAY
22464: PUSH
22465: LD_INT 3
22467: ARRAY
22468: PPUSH
22469: LD_INT 0
22471: PPUSH
22472: LD_VAR 0 1
22476: PPUSH
22477: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
22481: LD_ADDR_EXP 69
22485: PUSH
22486: LD_EXP 69
22490: PPUSH
22491: LD_VAR 0 3
22495: PPUSH
22496: LD_INT 1
22498: PPUSH
22499: CALL_OW 1
22503: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22504: LD_ADDR_EXP 75
22508: PUSH
22509: LD_EXP 75
22513: PPUSH
22514: LD_VAR 0 3
22518: PPUSH
22519: LD_INT 1
22521: PPUSH
22522: CALL_OW 1
22526: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22527: LD_ADDR_EXP 70
22531: PUSH
22532: LD_EXP 70
22536: PPUSH
22537: LD_VAR 0 3
22541: PPUSH
22542: LD_INT 0
22544: PPUSH
22545: CALL_OW 1
22549: ST_TO_ADDR
// case labNum of 1 :
22550: LD_VAR 0 3
22554: PUSH
22555: LD_INT 1
22557: DOUBLE
22558: EQUAL
22559: IFTRUE 22563
22561: GO 22574
22563: POP
// artifactIResearched := true ; 2 :
22564: LD_ADDR_EXP 12
22568: PUSH
22569: LD_INT 1
22571: ST_TO_ADDR
22572: GO 22613
22574: LD_INT 2
22576: DOUBLE
22577: EQUAL
22578: IFTRUE 22582
22580: GO 22593
22582: POP
// artifactIIResearched := true ; 3 :
22583: LD_ADDR_EXP 13
22587: PUSH
22588: LD_INT 1
22590: ST_TO_ADDR
22591: GO 22613
22593: LD_INT 3
22595: DOUBLE
22596: EQUAL
22597: IFTRUE 22601
22599: GO 22612
22601: POP
// artifactIIIResearched := true ; end ;
22602: LD_ADDR_EXP 14
22606: PUSH
22607: LD_INT 1
22609: ST_TO_ADDR
22610: GO 22613
22612: POP
// end ; end_of_file
22613: PPOPN 3
22615: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
22616: LD_INT 0
22618: PPUSH
22619: PPUSH
// skirmish := false ;
22620: LD_ADDR_EXP 76
22624: PUSH
22625: LD_INT 0
22627: ST_TO_ADDR
// debug_mc := false ;
22628: LD_ADDR_EXP 77
22632: PUSH
22633: LD_INT 0
22635: ST_TO_ADDR
// mc_bases := [ ] ;
22636: LD_ADDR_EXP 78
22640: PUSH
22641: EMPTY
22642: ST_TO_ADDR
// mc_sides := [ ] ;
22643: LD_ADDR_EXP 104
22647: PUSH
22648: EMPTY
22649: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
22650: LD_ADDR_EXP 79
22654: PUSH
22655: EMPTY
22656: ST_TO_ADDR
// mc_building_repairs := [ ] ;
22657: LD_ADDR_EXP 80
22661: PUSH
22662: EMPTY
22663: ST_TO_ADDR
// mc_need_heal := [ ] ;
22664: LD_ADDR_EXP 81
22668: PUSH
22669: EMPTY
22670: ST_TO_ADDR
// mc_healers := [ ] ;
22671: LD_ADDR_EXP 82
22675: PUSH
22676: EMPTY
22677: ST_TO_ADDR
// mc_build_list := [ ] ;
22678: LD_ADDR_EXP 83
22682: PUSH
22683: EMPTY
22684: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
22685: LD_ADDR_EXP 110
22689: PUSH
22690: EMPTY
22691: ST_TO_ADDR
// mc_builders := [ ] ;
22692: LD_ADDR_EXP 84
22696: PUSH
22697: EMPTY
22698: ST_TO_ADDR
// mc_construct_list := [ ] ;
22699: LD_ADDR_EXP 85
22703: PUSH
22704: EMPTY
22705: ST_TO_ADDR
// mc_turret_list := [ ] ;
22706: LD_ADDR_EXP 86
22710: PUSH
22711: EMPTY
22712: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
22713: LD_ADDR_EXP 87
22717: PUSH
22718: EMPTY
22719: ST_TO_ADDR
// mc_miners := [ ] ;
22720: LD_ADDR_EXP 92
22724: PUSH
22725: EMPTY
22726: ST_TO_ADDR
// mc_mines := [ ] ;
22727: LD_ADDR_EXP 91
22731: PUSH
22732: EMPTY
22733: ST_TO_ADDR
// mc_minefields := [ ] ;
22734: LD_ADDR_EXP 93
22738: PUSH
22739: EMPTY
22740: ST_TO_ADDR
// mc_crates := [ ] ;
22741: LD_ADDR_EXP 94
22745: PUSH
22746: EMPTY
22747: ST_TO_ADDR
// mc_crates_collector := [ ] ;
22748: LD_ADDR_EXP 95
22752: PUSH
22753: EMPTY
22754: ST_TO_ADDR
// mc_crates_area := [ ] ;
22755: LD_ADDR_EXP 96
22759: PUSH
22760: EMPTY
22761: ST_TO_ADDR
// mc_vehicles := [ ] ;
22762: LD_ADDR_EXP 97
22766: PUSH
22767: EMPTY
22768: ST_TO_ADDR
// mc_attack := [ ] ;
22769: LD_ADDR_EXP 98
22773: PUSH
22774: EMPTY
22775: ST_TO_ADDR
// mc_produce := [ ] ;
22776: LD_ADDR_EXP 99
22780: PUSH
22781: EMPTY
22782: ST_TO_ADDR
// mc_defender := [ ] ;
22783: LD_ADDR_EXP 100
22787: PUSH
22788: EMPTY
22789: ST_TO_ADDR
// mc_parking := [ ] ;
22790: LD_ADDR_EXP 102
22794: PUSH
22795: EMPTY
22796: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
22797: LD_ADDR_EXP 88
22801: PUSH
22802: EMPTY
22803: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
22804: LD_ADDR_EXP 90
22808: PUSH
22809: EMPTY
22810: ST_TO_ADDR
// mc_scan := [ ] ;
22811: LD_ADDR_EXP 101
22815: PUSH
22816: EMPTY
22817: ST_TO_ADDR
// mc_scan_area := [ ] ;
22818: LD_ADDR_EXP 103
22822: PUSH
22823: EMPTY
22824: ST_TO_ADDR
// mc_tech := [ ] ;
22825: LD_ADDR_EXP 105
22829: PUSH
22830: EMPTY
22831: ST_TO_ADDR
// mc_class := [ ] ;
22832: LD_ADDR_EXP 119
22836: PUSH
22837: EMPTY
22838: ST_TO_ADDR
// mc_class_case_use := [ ] ;
22839: LD_ADDR_EXP 120
22843: PUSH
22844: EMPTY
22845: ST_TO_ADDR
// mc_is_defending := [ ] ;
22846: LD_ADDR_EXP 121
22850: PUSH
22851: EMPTY
22852: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
22853: LD_ADDR_EXP 112
22857: PUSH
22858: EMPTY
22859: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
22860: LD_ADDR_EXP 122
22864: PUSH
22865: LD_INT 0
22867: ST_TO_ADDR
// end ;
22868: LD_VAR 0 1
22872: RET
// export function MC_Kill ( base ) ; begin
22873: LD_INT 0
22875: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
22876: LD_ADDR_EXP 78
22880: PUSH
22881: LD_EXP 78
22885: PPUSH
22886: LD_VAR 0 1
22890: PPUSH
22891: EMPTY
22892: PPUSH
22893: CALL_OW 1
22897: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22898: LD_ADDR_EXP 79
22902: PUSH
22903: LD_EXP 79
22907: PPUSH
22908: LD_VAR 0 1
22912: PPUSH
22913: EMPTY
22914: PPUSH
22915: CALL_OW 1
22919: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22920: LD_ADDR_EXP 80
22924: PUSH
22925: LD_EXP 80
22929: PPUSH
22930: LD_VAR 0 1
22934: PPUSH
22935: EMPTY
22936: PPUSH
22937: CALL_OW 1
22941: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22942: LD_ADDR_EXP 81
22946: PUSH
22947: LD_EXP 81
22951: PPUSH
22952: LD_VAR 0 1
22956: PPUSH
22957: EMPTY
22958: PPUSH
22959: CALL_OW 1
22963: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22964: LD_ADDR_EXP 82
22968: PUSH
22969: LD_EXP 82
22973: PPUSH
22974: LD_VAR 0 1
22978: PPUSH
22979: EMPTY
22980: PPUSH
22981: CALL_OW 1
22985: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22986: LD_ADDR_EXP 83
22990: PUSH
22991: LD_EXP 83
22995: PPUSH
22996: LD_VAR 0 1
23000: PPUSH
23001: EMPTY
23002: PPUSH
23003: CALL_OW 1
23007: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23008: LD_ADDR_EXP 84
23012: PUSH
23013: LD_EXP 84
23017: PPUSH
23018: LD_VAR 0 1
23022: PPUSH
23023: EMPTY
23024: PPUSH
23025: CALL_OW 1
23029: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23030: LD_ADDR_EXP 85
23034: PUSH
23035: LD_EXP 85
23039: PPUSH
23040: LD_VAR 0 1
23044: PPUSH
23045: EMPTY
23046: PPUSH
23047: CALL_OW 1
23051: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23052: LD_ADDR_EXP 86
23056: PUSH
23057: LD_EXP 86
23061: PPUSH
23062: LD_VAR 0 1
23066: PPUSH
23067: EMPTY
23068: PPUSH
23069: CALL_OW 1
23073: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23074: LD_ADDR_EXP 87
23078: PUSH
23079: LD_EXP 87
23083: PPUSH
23084: LD_VAR 0 1
23088: PPUSH
23089: EMPTY
23090: PPUSH
23091: CALL_OW 1
23095: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23096: LD_ADDR_EXP 88
23100: PUSH
23101: LD_EXP 88
23105: PPUSH
23106: LD_VAR 0 1
23110: PPUSH
23111: EMPTY
23112: PPUSH
23113: CALL_OW 1
23117: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23118: LD_ADDR_EXP 89
23122: PUSH
23123: LD_EXP 89
23127: PPUSH
23128: LD_VAR 0 1
23132: PPUSH
23133: LD_INT 0
23135: PPUSH
23136: CALL_OW 1
23140: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23141: LD_ADDR_EXP 90
23145: PUSH
23146: LD_EXP 90
23150: PPUSH
23151: LD_VAR 0 1
23155: PPUSH
23156: EMPTY
23157: PPUSH
23158: CALL_OW 1
23162: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23163: LD_ADDR_EXP 91
23167: PUSH
23168: LD_EXP 91
23172: PPUSH
23173: LD_VAR 0 1
23177: PPUSH
23178: EMPTY
23179: PPUSH
23180: CALL_OW 1
23184: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23185: LD_ADDR_EXP 92
23189: PUSH
23190: LD_EXP 92
23194: PPUSH
23195: LD_VAR 0 1
23199: PPUSH
23200: EMPTY
23201: PPUSH
23202: CALL_OW 1
23206: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23207: LD_ADDR_EXP 93
23211: PUSH
23212: LD_EXP 93
23216: PPUSH
23217: LD_VAR 0 1
23221: PPUSH
23222: EMPTY
23223: PPUSH
23224: CALL_OW 1
23228: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23229: LD_ADDR_EXP 94
23233: PUSH
23234: LD_EXP 94
23238: PPUSH
23239: LD_VAR 0 1
23243: PPUSH
23244: EMPTY
23245: PPUSH
23246: CALL_OW 1
23250: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23251: LD_ADDR_EXP 95
23255: PUSH
23256: LD_EXP 95
23260: PPUSH
23261: LD_VAR 0 1
23265: PPUSH
23266: EMPTY
23267: PPUSH
23268: CALL_OW 1
23272: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23273: LD_ADDR_EXP 96
23277: PUSH
23278: LD_EXP 96
23282: PPUSH
23283: LD_VAR 0 1
23287: PPUSH
23288: EMPTY
23289: PPUSH
23290: CALL_OW 1
23294: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23295: LD_ADDR_EXP 97
23299: PUSH
23300: LD_EXP 97
23304: PPUSH
23305: LD_VAR 0 1
23309: PPUSH
23310: EMPTY
23311: PPUSH
23312: CALL_OW 1
23316: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23317: LD_ADDR_EXP 98
23321: PUSH
23322: LD_EXP 98
23326: PPUSH
23327: LD_VAR 0 1
23331: PPUSH
23332: EMPTY
23333: PPUSH
23334: CALL_OW 1
23338: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23339: LD_ADDR_EXP 99
23343: PUSH
23344: LD_EXP 99
23348: PPUSH
23349: LD_VAR 0 1
23353: PPUSH
23354: EMPTY
23355: PPUSH
23356: CALL_OW 1
23360: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23361: LD_ADDR_EXP 100
23365: PUSH
23366: LD_EXP 100
23370: PPUSH
23371: LD_VAR 0 1
23375: PPUSH
23376: EMPTY
23377: PPUSH
23378: CALL_OW 1
23382: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23383: LD_ADDR_EXP 101
23387: PUSH
23388: LD_EXP 101
23392: PPUSH
23393: LD_VAR 0 1
23397: PPUSH
23398: EMPTY
23399: PPUSH
23400: CALL_OW 1
23404: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23405: LD_ADDR_EXP 102
23409: PUSH
23410: LD_EXP 102
23414: PPUSH
23415: LD_VAR 0 1
23419: PPUSH
23420: EMPTY
23421: PPUSH
23422: CALL_OW 1
23426: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23427: LD_ADDR_EXP 103
23431: PUSH
23432: LD_EXP 103
23436: PPUSH
23437: LD_VAR 0 1
23441: PPUSH
23442: EMPTY
23443: PPUSH
23444: CALL_OW 1
23448: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23449: LD_ADDR_EXP 105
23453: PUSH
23454: LD_EXP 105
23458: PPUSH
23459: LD_VAR 0 1
23463: PPUSH
23464: EMPTY
23465: PPUSH
23466: CALL_OW 1
23470: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23471: LD_ADDR_EXP 107
23475: PUSH
23476: LD_EXP 107
23480: PPUSH
23481: LD_VAR 0 1
23485: PPUSH
23486: EMPTY
23487: PPUSH
23488: CALL_OW 1
23492: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23493: LD_ADDR_EXP 108
23497: PUSH
23498: LD_EXP 108
23502: PPUSH
23503: LD_VAR 0 1
23507: PPUSH
23508: EMPTY
23509: PPUSH
23510: CALL_OW 1
23514: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23515: LD_ADDR_EXP 109
23519: PUSH
23520: LD_EXP 109
23524: PPUSH
23525: LD_VAR 0 1
23529: PPUSH
23530: EMPTY
23531: PPUSH
23532: CALL_OW 1
23536: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23537: LD_ADDR_EXP 110
23541: PUSH
23542: LD_EXP 110
23546: PPUSH
23547: LD_VAR 0 1
23551: PPUSH
23552: EMPTY
23553: PPUSH
23554: CALL_OW 1
23558: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23559: LD_ADDR_EXP 111
23563: PUSH
23564: LD_EXP 111
23568: PPUSH
23569: LD_VAR 0 1
23573: PPUSH
23574: EMPTY
23575: PPUSH
23576: CALL_OW 1
23580: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23581: LD_ADDR_EXP 112
23585: PUSH
23586: LD_EXP 112
23590: PPUSH
23591: LD_VAR 0 1
23595: PPUSH
23596: EMPTY
23597: PPUSH
23598: CALL_OW 1
23602: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23603: LD_ADDR_EXP 113
23607: PUSH
23608: LD_EXP 113
23612: PPUSH
23613: LD_VAR 0 1
23617: PPUSH
23618: EMPTY
23619: PPUSH
23620: CALL_OW 1
23624: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23625: LD_ADDR_EXP 114
23629: PUSH
23630: LD_EXP 114
23634: PPUSH
23635: LD_VAR 0 1
23639: PPUSH
23640: EMPTY
23641: PPUSH
23642: CALL_OW 1
23646: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23647: LD_ADDR_EXP 115
23651: PUSH
23652: LD_EXP 115
23656: PPUSH
23657: LD_VAR 0 1
23661: PPUSH
23662: EMPTY
23663: PPUSH
23664: CALL_OW 1
23668: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23669: LD_ADDR_EXP 116
23673: PUSH
23674: LD_EXP 116
23678: PPUSH
23679: LD_VAR 0 1
23683: PPUSH
23684: EMPTY
23685: PPUSH
23686: CALL_OW 1
23690: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23691: LD_ADDR_EXP 117
23695: PUSH
23696: LD_EXP 117
23700: PPUSH
23701: LD_VAR 0 1
23705: PPUSH
23706: EMPTY
23707: PPUSH
23708: CALL_OW 1
23712: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23713: LD_ADDR_EXP 118
23717: PUSH
23718: LD_EXP 118
23722: PPUSH
23723: LD_VAR 0 1
23727: PPUSH
23728: EMPTY
23729: PPUSH
23730: CALL_OW 1
23734: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23735: LD_ADDR_EXP 119
23739: PUSH
23740: LD_EXP 119
23744: PPUSH
23745: LD_VAR 0 1
23749: PPUSH
23750: EMPTY
23751: PPUSH
23752: CALL_OW 1
23756: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23757: LD_ADDR_EXP 120
23761: PUSH
23762: LD_EXP 120
23766: PPUSH
23767: LD_VAR 0 1
23771: PPUSH
23772: LD_INT 0
23774: PPUSH
23775: CALL_OW 1
23779: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23780: LD_ADDR_EXP 121
23784: PUSH
23785: LD_EXP 121
23789: PPUSH
23790: LD_VAR 0 1
23794: PPUSH
23795: LD_INT 0
23797: PPUSH
23798: CALL_OW 1
23802: ST_TO_ADDR
// end ;
23803: LD_VAR 0 2
23807: RET
// export function MC_Add ( side , units ) ; var base ; begin
23808: LD_INT 0
23810: PPUSH
23811: PPUSH
// base := mc_bases + 1 ;
23812: LD_ADDR_VAR 0 4
23816: PUSH
23817: LD_EXP 78
23821: PUSH
23822: LD_INT 1
23824: PLUS
23825: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
23826: LD_ADDR_EXP 104
23830: PUSH
23831: LD_EXP 104
23835: PPUSH
23836: LD_VAR 0 4
23840: PPUSH
23841: LD_VAR 0 1
23845: PPUSH
23846: CALL_OW 1
23850: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
23851: LD_ADDR_EXP 78
23855: PUSH
23856: LD_EXP 78
23860: PPUSH
23861: LD_VAR 0 4
23865: PPUSH
23866: LD_VAR 0 2
23870: PPUSH
23871: CALL_OW 1
23875: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23876: LD_ADDR_EXP 79
23880: PUSH
23881: LD_EXP 79
23885: PPUSH
23886: LD_VAR 0 4
23890: PPUSH
23891: EMPTY
23892: PPUSH
23893: CALL_OW 1
23897: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23898: LD_ADDR_EXP 80
23902: PUSH
23903: LD_EXP 80
23907: PPUSH
23908: LD_VAR 0 4
23912: PPUSH
23913: EMPTY
23914: PPUSH
23915: CALL_OW 1
23919: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23920: LD_ADDR_EXP 81
23924: PUSH
23925: LD_EXP 81
23929: PPUSH
23930: LD_VAR 0 4
23934: PPUSH
23935: EMPTY
23936: PPUSH
23937: CALL_OW 1
23941: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23942: LD_ADDR_EXP 82
23946: PUSH
23947: LD_EXP 82
23951: PPUSH
23952: LD_VAR 0 4
23956: PPUSH
23957: EMPTY
23958: PPUSH
23959: CALL_OW 1
23963: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23964: LD_ADDR_EXP 83
23968: PUSH
23969: LD_EXP 83
23973: PPUSH
23974: LD_VAR 0 4
23978: PPUSH
23979: EMPTY
23980: PPUSH
23981: CALL_OW 1
23985: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23986: LD_ADDR_EXP 84
23990: PUSH
23991: LD_EXP 84
23995: PPUSH
23996: LD_VAR 0 4
24000: PPUSH
24001: EMPTY
24002: PPUSH
24003: CALL_OW 1
24007: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
24008: LD_ADDR_EXP 85
24012: PUSH
24013: LD_EXP 85
24017: PPUSH
24018: LD_VAR 0 4
24022: PPUSH
24023: EMPTY
24024: PPUSH
24025: CALL_OW 1
24029: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
24030: LD_ADDR_EXP 86
24034: PUSH
24035: LD_EXP 86
24039: PPUSH
24040: LD_VAR 0 4
24044: PPUSH
24045: EMPTY
24046: PPUSH
24047: CALL_OW 1
24051: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
24052: LD_ADDR_EXP 87
24056: PUSH
24057: LD_EXP 87
24061: PPUSH
24062: LD_VAR 0 4
24066: PPUSH
24067: EMPTY
24068: PPUSH
24069: CALL_OW 1
24073: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
24074: LD_ADDR_EXP 88
24078: PUSH
24079: LD_EXP 88
24083: PPUSH
24084: LD_VAR 0 4
24088: PPUSH
24089: EMPTY
24090: PPUSH
24091: CALL_OW 1
24095: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
24096: LD_ADDR_EXP 89
24100: PUSH
24101: LD_EXP 89
24105: PPUSH
24106: LD_VAR 0 4
24110: PPUSH
24111: LD_INT 0
24113: PPUSH
24114: CALL_OW 1
24118: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
24119: LD_ADDR_EXP 90
24123: PUSH
24124: LD_EXP 90
24128: PPUSH
24129: LD_VAR 0 4
24133: PPUSH
24134: EMPTY
24135: PPUSH
24136: CALL_OW 1
24140: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
24141: LD_ADDR_EXP 91
24145: PUSH
24146: LD_EXP 91
24150: PPUSH
24151: LD_VAR 0 4
24155: PPUSH
24156: EMPTY
24157: PPUSH
24158: CALL_OW 1
24162: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
24163: LD_ADDR_EXP 92
24167: PUSH
24168: LD_EXP 92
24172: PPUSH
24173: LD_VAR 0 4
24177: PPUSH
24178: EMPTY
24179: PPUSH
24180: CALL_OW 1
24184: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
24185: LD_ADDR_EXP 93
24189: PUSH
24190: LD_EXP 93
24194: PPUSH
24195: LD_VAR 0 4
24199: PPUSH
24200: EMPTY
24201: PPUSH
24202: CALL_OW 1
24206: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
24207: LD_ADDR_EXP 94
24211: PUSH
24212: LD_EXP 94
24216: PPUSH
24217: LD_VAR 0 4
24221: PPUSH
24222: EMPTY
24223: PPUSH
24224: CALL_OW 1
24228: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
24229: LD_ADDR_EXP 95
24233: PUSH
24234: LD_EXP 95
24238: PPUSH
24239: LD_VAR 0 4
24243: PPUSH
24244: EMPTY
24245: PPUSH
24246: CALL_OW 1
24250: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
24251: LD_ADDR_EXP 96
24255: PUSH
24256: LD_EXP 96
24260: PPUSH
24261: LD_VAR 0 4
24265: PPUSH
24266: EMPTY
24267: PPUSH
24268: CALL_OW 1
24272: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
24273: LD_ADDR_EXP 97
24277: PUSH
24278: LD_EXP 97
24282: PPUSH
24283: LD_VAR 0 4
24287: PPUSH
24288: EMPTY
24289: PPUSH
24290: CALL_OW 1
24294: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
24295: LD_ADDR_EXP 98
24299: PUSH
24300: LD_EXP 98
24304: PPUSH
24305: LD_VAR 0 4
24309: PPUSH
24310: EMPTY
24311: PPUSH
24312: CALL_OW 1
24316: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
24317: LD_ADDR_EXP 99
24321: PUSH
24322: LD_EXP 99
24326: PPUSH
24327: LD_VAR 0 4
24331: PPUSH
24332: EMPTY
24333: PPUSH
24334: CALL_OW 1
24338: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
24339: LD_ADDR_EXP 100
24343: PUSH
24344: LD_EXP 100
24348: PPUSH
24349: LD_VAR 0 4
24353: PPUSH
24354: EMPTY
24355: PPUSH
24356: CALL_OW 1
24360: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
24361: LD_ADDR_EXP 101
24365: PUSH
24366: LD_EXP 101
24370: PPUSH
24371: LD_VAR 0 4
24375: PPUSH
24376: EMPTY
24377: PPUSH
24378: CALL_OW 1
24382: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
24383: LD_ADDR_EXP 102
24387: PUSH
24388: LD_EXP 102
24392: PPUSH
24393: LD_VAR 0 4
24397: PPUSH
24398: EMPTY
24399: PPUSH
24400: CALL_OW 1
24404: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
24405: LD_ADDR_EXP 103
24409: PUSH
24410: LD_EXP 103
24414: PPUSH
24415: LD_VAR 0 4
24419: PPUSH
24420: EMPTY
24421: PPUSH
24422: CALL_OW 1
24426: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
24427: LD_ADDR_EXP 105
24431: PUSH
24432: LD_EXP 105
24436: PPUSH
24437: LD_VAR 0 4
24441: PPUSH
24442: EMPTY
24443: PPUSH
24444: CALL_OW 1
24448: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
24449: LD_ADDR_EXP 107
24453: PUSH
24454: LD_EXP 107
24458: PPUSH
24459: LD_VAR 0 4
24463: PPUSH
24464: EMPTY
24465: PPUSH
24466: CALL_OW 1
24470: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24471: LD_ADDR_EXP 108
24475: PUSH
24476: LD_EXP 108
24480: PPUSH
24481: LD_VAR 0 4
24485: PPUSH
24486: EMPTY
24487: PPUSH
24488: CALL_OW 1
24492: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24493: LD_ADDR_EXP 109
24497: PUSH
24498: LD_EXP 109
24502: PPUSH
24503: LD_VAR 0 4
24507: PPUSH
24508: EMPTY
24509: PPUSH
24510: CALL_OW 1
24514: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24515: LD_ADDR_EXP 110
24519: PUSH
24520: LD_EXP 110
24524: PPUSH
24525: LD_VAR 0 4
24529: PPUSH
24530: EMPTY
24531: PPUSH
24532: CALL_OW 1
24536: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24537: LD_ADDR_EXP 111
24541: PUSH
24542: LD_EXP 111
24546: PPUSH
24547: LD_VAR 0 4
24551: PPUSH
24552: EMPTY
24553: PPUSH
24554: CALL_OW 1
24558: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24559: LD_ADDR_EXP 112
24563: PUSH
24564: LD_EXP 112
24568: PPUSH
24569: LD_VAR 0 4
24573: PPUSH
24574: EMPTY
24575: PPUSH
24576: CALL_OW 1
24580: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24581: LD_ADDR_EXP 113
24585: PUSH
24586: LD_EXP 113
24590: PPUSH
24591: LD_VAR 0 4
24595: PPUSH
24596: EMPTY
24597: PPUSH
24598: CALL_OW 1
24602: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24603: LD_ADDR_EXP 114
24607: PUSH
24608: LD_EXP 114
24612: PPUSH
24613: LD_VAR 0 4
24617: PPUSH
24618: EMPTY
24619: PPUSH
24620: CALL_OW 1
24624: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24625: LD_ADDR_EXP 115
24629: PUSH
24630: LD_EXP 115
24634: PPUSH
24635: LD_VAR 0 4
24639: PPUSH
24640: EMPTY
24641: PPUSH
24642: CALL_OW 1
24646: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24647: LD_ADDR_EXP 116
24651: PUSH
24652: LD_EXP 116
24656: PPUSH
24657: LD_VAR 0 4
24661: PPUSH
24662: EMPTY
24663: PPUSH
24664: CALL_OW 1
24668: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24669: LD_ADDR_EXP 117
24673: PUSH
24674: LD_EXP 117
24678: PPUSH
24679: LD_VAR 0 4
24683: PPUSH
24684: EMPTY
24685: PPUSH
24686: CALL_OW 1
24690: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24691: LD_ADDR_EXP 118
24695: PUSH
24696: LD_EXP 118
24700: PPUSH
24701: LD_VAR 0 4
24705: PPUSH
24706: EMPTY
24707: PPUSH
24708: CALL_OW 1
24712: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24713: LD_ADDR_EXP 119
24717: PUSH
24718: LD_EXP 119
24722: PPUSH
24723: LD_VAR 0 4
24727: PPUSH
24728: EMPTY
24729: PPUSH
24730: CALL_OW 1
24734: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24735: LD_ADDR_EXP 120
24739: PUSH
24740: LD_EXP 120
24744: PPUSH
24745: LD_VAR 0 4
24749: PPUSH
24750: LD_INT 0
24752: PPUSH
24753: CALL_OW 1
24757: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24758: LD_ADDR_EXP 121
24762: PUSH
24763: LD_EXP 121
24767: PPUSH
24768: LD_VAR 0 4
24772: PPUSH
24773: LD_INT 0
24775: PPUSH
24776: CALL_OW 1
24780: ST_TO_ADDR
// result := base ;
24781: LD_ADDR_VAR 0 3
24785: PUSH
24786: LD_VAR 0 4
24790: ST_TO_ADDR
// end ;
24791: LD_VAR 0 3
24795: RET
// export function MC_Start ( ) ; var i ; begin
24796: LD_INT 0
24798: PPUSH
24799: PPUSH
// for i = 1 to mc_bases do
24800: LD_ADDR_VAR 0 2
24804: PUSH
24805: DOUBLE
24806: LD_INT 1
24808: DEC
24809: ST_TO_ADDR
24810: LD_EXP 78
24814: PUSH
24815: FOR_TO
24816: IFFALSE 25916
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
24818: LD_ADDR_EXP 78
24822: PUSH
24823: LD_EXP 78
24827: PPUSH
24828: LD_VAR 0 2
24832: PPUSH
24833: LD_EXP 78
24837: PUSH
24838: LD_VAR 0 2
24842: ARRAY
24843: PUSH
24844: LD_INT 0
24846: DIFF
24847: PPUSH
24848: CALL_OW 1
24852: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
24853: LD_ADDR_EXP 79
24857: PUSH
24858: LD_EXP 79
24862: PPUSH
24863: LD_VAR 0 2
24867: PPUSH
24868: EMPTY
24869: PPUSH
24870: CALL_OW 1
24874: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
24875: LD_ADDR_EXP 80
24879: PUSH
24880: LD_EXP 80
24884: PPUSH
24885: LD_VAR 0 2
24889: PPUSH
24890: EMPTY
24891: PPUSH
24892: CALL_OW 1
24896: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
24897: LD_ADDR_EXP 81
24901: PUSH
24902: LD_EXP 81
24906: PPUSH
24907: LD_VAR 0 2
24911: PPUSH
24912: EMPTY
24913: PPUSH
24914: CALL_OW 1
24918: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
24919: LD_ADDR_EXP 82
24923: PUSH
24924: LD_EXP 82
24928: PPUSH
24929: LD_VAR 0 2
24933: PPUSH
24934: EMPTY
24935: PUSH
24936: EMPTY
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PPUSH
24942: CALL_OW 1
24946: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
24947: LD_ADDR_EXP 83
24951: PUSH
24952: LD_EXP 83
24956: PPUSH
24957: LD_VAR 0 2
24961: PPUSH
24962: EMPTY
24963: PPUSH
24964: CALL_OW 1
24968: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
24969: LD_ADDR_EXP 110
24973: PUSH
24974: LD_EXP 110
24978: PPUSH
24979: LD_VAR 0 2
24983: PPUSH
24984: EMPTY
24985: PPUSH
24986: CALL_OW 1
24990: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
24991: LD_ADDR_EXP 84
24995: PUSH
24996: LD_EXP 84
25000: PPUSH
25001: LD_VAR 0 2
25005: PPUSH
25006: EMPTY
25007: PPUSH
25008: CALL_OW 1
25012: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
25013: LD_ADDR_EXP 85
25017: PUSH
25018: LD_EXP 85
25022: PPUSH
25023: LD_VAR 0 2
25027: PPUSH
25028: EMPTY
25029: PPUSH
25030: CALL_OW 1
25034: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
25035: LD_ADDR_EXP 86
25039: PUSH
25040: LD_EXP 86
25044: PPUSH
25045: LD_VAR 0 2
25049: PPUSH
25050: LD_EXP 78
25054: PUSH
25055: LD_VAR 0 2
25059: ARRAY
25060: PPUSH
25061: LD_INT 2
25063: PUSH
25064: LD_INT 30
25066: PUSH
25067: LD_INT 32
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: LD_INT 30
25076: PUSH
25077: LD_INT 33
25079: PUSH
25080: EMPTY
25081: LIST
25082: LIST
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: LIST
25088: PPUSH
25089: CALL_OW 72
25093: PPUSH
25094: CALL_OW 1
25098: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
25099: LD_ADDR_EXP 87
25103: PUSH
25104: LD_EXP 87
25108: PPUSH
25109: LD_VAR 0 2
25113: PPUSH
25114: LD_EXP 78
25118: PUSH
25119: LD_VAR 0 2
25123: ARRAY
25124: PPUSH
25125: LD_INT 2
25127: PUSH
25128: LD_INT 30
25130: PUSH
25131: LD_INT 32
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PUSH
25138: LD_INT 30
25140: PUSH
25141: LD_INT 31
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: PUSH
25148: EMPTY
25149: LIST
25150: LIST
25151: LIST
25152: PUSH
25153: LD_INT 58
25155: PUSH
25156: EMPTY
25157: LIST
25158: PUSH
25159: EMPTY
25160: LIST
25161: LIST
25162: PPUSH
25163: CALL_OW 72
25167: PPUSH
25168: CALL_OW 1
25172: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
25173: LD_ADDR_EXP 88
25177: PUSH
25178: LD_EXP 88
25182: PPUSH
25183: LD_VAR 0 2
25187: PPUSH
25188: EMPTY
25189: PPUSH
25190: CALL_OW 1
25194: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
25195: LD_ADDR_EXP 92
25199: PUSH
25200: LD_EXP 92
25204: PPUSH
25205: LD_VAR 0 2
25209: PPUSH
25210: EMPTY
25211: PPUSH
25212: CALL_OW 1
25216: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
25217: LD_ADDR_EXP 91
25221: PUSH
25222: LD_EXP 91
25226: PPUSH
25227: LD_VAR 0 2
25231: PPUSH
25232: EMPTY
25233: PPUSH
25234: CALL_OW 1
25238: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
25239: LD_ADDR_EXP 93
25243: PUSH
25244: LD_EXP 93
25248: PPUSH
25249: LD_VAR 0 2
25253: PPUSH
25254: EMPTY
25255: PPUSH
25256: CALL_OW 1
25260: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
25261: LD_ADDR_EXP 94
25265: PUSH
25266: LD_EXP 94
25270: PPUSH
25271: LD_VAR 0 2
25275: PPUSH
25276: EMPTY
25277: PPUSH
25278: CALL_OW 1
25282: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
25283: LD_ADDR_EXP 95
25287: PUSH
25288: LD_EXP 95
25292: PPUSH
25293: LD_VAR 0 2
25297: PPUSH
25298: EMPTY
25299: PPUSH
25300: CALL_OW 1
25304: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
25305: LD_ADDR_EXP 96
25309: PUSH
25310: LD_EXP 96
25314: PPUSH
25315: LD_VAR 0 2
25319: PPUSH
25320: EMPTY
25321: PPUSH
25322: CALL_OW 1
25326: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
25327: LD_ADDR_EXP 97
25331: PUSH
25332: LD_EXP 97
25336: PPUSH
25337: LD_VAR 0 2
25341: PPUSH
25342: EMPTY
25343: PPUSH
25344: CALL_OW 1
25348: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
25349: LD_ADDR_EXP 98
25353: PUSH
25354: LD_EXP 98
25358: PPUSH
25359: LD_VAR 0 2
25363: PPUSH
25364: EMPTY
25365: PPUSH
25366: CALL_OW 1
25370: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
25371: LD_ADDR_EXP 99
25375: PUSH
25376: LD_EXP 99
25380: PPUSH
25381: LD_VAR 0 2
25385: PPUSH
25386: EMPTY
25387: PPUSH
25388: CALL_OW 1
25392: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
25393: LD_ADDR_EXP 100
25397: PUSH
25398: LD_EXP 100
25402: PPUSH
25403: LD_VAR 0 2
25407: PPUSH
25408: EMPTY
25409: PPUSH
25410: CALL_OW 1
25414: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
25415: LD_ADDR_EXP 89
25419: PUSH
25420: LD_EXP 89
25424: PPUSH
25425: LD_VAR 0 2
25429: PPUSH
25430: LD_INT 0
25432: PPUSH
25433: CALL_OW 1
25437: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
25438: LD_ADDR_EXP 102
25442: PUSH
25443: LD_EXP 102
25447: PPUSH
25448: LD_VAR 0 2
25452: PPUSH
25453: LD_INT 0
25455: PPUSH
25456: CALL_OW 1
25460: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
25461: LD_ADDR_EXP 90
25465: PUSH
25466: LD_EXP 90
25470: PPUSH
25471: LD_VAR 0 2
25475: PPUSH
25476: EMPTY
25477: PPUSH
25478: CALL_OW 1
25482: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
25483: LD_ADDR_EXP 101
25487: PUSH
25488: LD_EXP 101
25492: PPUSH
25493: LD_VAR 0 2
25497: PPUSH
25498: LD_INT 0
25500: PPUSH
25501: CALL_OW 1
25505: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25506: LD_ADDR_EXP 103
25510: PUSH
25511: LD_EXP 103
25515: PPUSH
25516: LD_VAR 0 2
25520: PPUSH
25521: EMPTY
25522: PPUSH
25523: CALL_OW 1
25527: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25528: LD_ADDR_EXP 106
25532: PUSH
25533: LD_EXP 106
25537: PPUSH
25538: LD_VAR 0 2
25542: PPUSH
25543: LD_INT 0
25545: PPUSH
25546: CALL_OW 1
25550: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25551: LD_ADDR_EXP 107
25555: PUSH
25556: LD_EXP 107
25560: PPUSH
25561: LD_VAR 0 2
25565: PPUSH
25566: EMPTY
25567: PPUSH
25568: CALL_OW 1
25572: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25573: LD_ADDR_EXP 108
25577: PUSH
25578: LD_EXP 108
25582: PPUSH
25583: LD_VAR 0 2
25587: PPUSH
25588: EMPTY
25589: PPUSH
25590: CALL_OW 1
25594: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25595: LD_ADDR_EXP 109
25599: PUSH
25600: LD_EXP 109
25604: PPUSH
25605: LD_VAR 0 2
25609: PPUSH
25610: EMPTY
25611: PPUSH
25612: CALL_OW 1
25616: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
25617: LD_ADDR_EXP 111
25621: PUSH
25622: LD_EXP 111
25626: PPUSH
25627: LD_VAR 0 2
25631: PPUSH
25632: LD_EXP 78
25636: PUSH
25637: LD_VAR 0 2
25641: ARRAY
25642: PPUSH
25643: LD_INT 2
25645: PUSH
25646: LD_INT 30
25648: PUSH
25649: LD_INT 6
25651: PUSH
25652: EMPTY
25653: LIST
25654: LIST
25655: PUSH
25656: LD_INT 30
25658: PUSH
25659: LD_INT 7
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: PUSH
25666: LD_INT 30
25668: PUSH
25669: LD_INT 8
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PUSH
25676: EMPTY
25677: LIST
25678: LIST
25679: LIST
25680: LIST
25681: PPUSH
25682: CALL_OW 72
25686: PPUSH
25687: CALL_OW 1
25691: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
25692: LD_ADDR_EXP 112
25696: PUSH
25697: LD_EXP 112
25701: PPUSH
25702: LD_VAR 0 2
25706: PPUSH
25707: EMPTY
25708: PPUSH
25709: CALL_OW 1
25713: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
25714: LD_ADDR_EXP 113
25718: PUSH
25719: LD_EXP 113
25723: PPUSH
25724: LD_VAR 0 2
25728: PPUSH
25729: EMPTY
25730: PPUSH
25731: CALL_OW 1
25735: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
25736: LD_ADDR_EXP 114
25740: PUSH
25741: LD_EXP 114
25745: PPUSH
25746: LD_VAR 0 2
25750: PPUSH
25751: EMPTY
25752: PPUSH
25753: CALL_OW 1
25757: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
25758: LD_ADDR_EXP 115
25762: PUSH
25763: LD_EXP 115
25767: PPUSH
25768: LD_VAR 0 2
25772: PPUSH
25773: EMPTY
25774: PPUSH
25775: CALL_OW 1
25779: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
25780: LD_ADDR_EXP 116
25784: PUSH
25785: LD_EXP 116
25789: PPUSH
25790: LD_VAR 0 2
25794: PPUSH
25795: EMPTY
25796: PPUSH
25797: CALL_OW 1
25801: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
25802: LD_ADDR_EXP 117
25806: PUSH
25807: LD_EXP 117
25811: PPUSH
25812: LD_VAR 0 2
25816: PPUSH
25817: EMPTY
25818: PPUSH
25819: CALL_OW 1
25823: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
25824: LD_ADDR_EXP 118
25828: PUSH
25829: LD_EXP 118
25833: PPUSH
25834: LD_VAR 0 2
25838: PPUSH
25839: EMPTY
25840: PPUSH
25841: CALL_OW 1
25845: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
25846: LD_ADDR_EXP 119
25850: PUSH
25851: LD_EXP 119
25855: PPUSH
25856: LD_VAR 0 2
25860: PPUSH
25861: EMPTY
25862: PPUSH
25863: CALL_OW 1
25867: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
25868: LD_ADDR_EXP 120
25872: PUSH
25873: LD_EXP 120
25877: PPUSH
25878: LD_VAR 0 2
25882: PPUSH
25883: LD_INT 0
25885: PPUSH
25886: CALL_OW 1
25890: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
25891: LD_ADDR_EXP 121
25895: PUSH
25896: LD_EXP 121
25900: PPUSH
25901: LD_VAR 0 2
25905: PPUSH
25906: LD_INT 0
25908: PPUSH
25909: CALL_OW 1
25913: ST_TO_ADDR
// end ;
25914: GO 24815
25916: POP
25917: POP
// MC_InitSides ( ) ;
25918: CALL 26204 0 0
// MC_InitResearch ( ) ;
25922: CALL 25943 0 0
// CustomInitMacro ( ) ;
25926: CALL 228 0 0
// skirmish := true ;
25930: LD_ADDR_EXP 76
25934: PUSH
25935: LD_INT 1
25937: ST_TO_ADDR
// end ;
25938: LD_VAR 0 1
25942: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
25943: LD_INT 0
25945: PPUSH
25946: PPUSH
25947: PPUSH
25948: PPUSH
25949: PPUSH
25950: PPUSH
// if not mc_bases then
25951: LD_EXP 78
25955: NOT
25956: IFFALSE 25960
// exit ;
25958: GO 26199
// for i = 1 to 8 do
25960: LD_ADDR_VAR 0 2
25964: PUSH
25965: DOUBLE
25966: LD_INT 1
25968: DEC
25969: ST_TO_ADDR
25970: LD_INT 8
25972: PUSH
25973: FOR_TO
25974: IFFALSE 26000
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
25976: LD_ADDR_EXP 105
25980: PUSH
25981: LD_EXP 105
25985: PPUSH
25986: LD_VAR 0 2
25990: PPUSH
25991: EMPTY
25992: PPUSH
25993: CALL_OW 1
25997: ST_TO_ADDR
25998: GO 25973
26000: POP
26001: POP
// tmp := [ ] ;
26002: LD_ADDR_VAR 0 5
26006: PUSH
26007: EMPTY
26008: ST_TO_ADDR
// for i = 1 to mc_sides do
26009: LD_ADDR_VAR 0 2
26013: PUSH
26014: DOUBLE
26015: LD_INT 1
26017: DEC
26018: ST_TO_ADDR
26019: LD_EXP 104
26023: PUSH
26024: FOR_TO
26025: IFFALSE 26083
// if not mc_sides [ i ] in tmp then
26027: LD_EXP 104
26031: PUSH
26032: LD_VAR 0 2
26036: ARRAY
26037: PUSH
26038: LD_VAR 0 5
26042: IN
26043: NOT
26044: IFFALSE 26081
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
26046: LD_ADDR_VAR 0 5
26050: PUSH
26051: LD_VAR 0 5
26055: PPUSH
26056: LD_VAR 0 5
26060: PUSH
26061: LD_INT 1
26063: PLUS
26064: PPUSH
26065: LD_EXP 104
26069: PUSH
26070: LD_VAR 0 2
26074: ARRAY
26075: PPUSH
26076: CALL_OW 2
26080: ST_TO_ADDR
26081: GO 26024
26083: POP
26084: POP
// if not tmp then
26085: LD_VAR 0 5
26089: NOT
26090: IFFALSE 26094
// exit ;
26092: GO 26199
// for j in tmp do
26094: LD_ADDR_VAR 0 3
26098: PUSH
26099: LD_VAR 0 5
26103: PUSH
26104: FOR_IN
26105: IFFALSE 26197
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
26107: LD_ADDR_VAR 0 6
26111: PUSH
26112: LD_INT 22
26114: PUSH
26115: LD_VAR 0 3
26119: PUSH
26120: EMPTY
26121: LIST
26122: LIST
26123: PPUSH
26124: CALL_OW 69
26128: ST_TO_ADDR
// if not un then
26129: LD_VAR 0 6
26133: NOT
26134: IFFALSE 26138
// continue ;
26136: GO 26104
// nation := GetNation ( un [ 1 ] ) ;
26138: LD_ADDR_VAR 0 4
26142: PUSH
26143: LD_VAR 0 6
26147: PUSH
26148: LD_INT 1
26150: ARRAY
26151: PPUSH
26152: CALL_OW 248
26156: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
26157: LD_ADDR_EXP 105
26161: PUSH
26162: LD_EXP 105
26166: PPUSH
26167: LD_VAR 0 3
26171: PPUSH
26172: LD_VAR 0 3
26176: PPUSH
26177: LD_VAR 0 4
26181: PPUSH
26182: LD_INT 1
26184: PPUSH
26185: CALL 53387 0 3
26189: PPUSH
26190: CALL_OW 1
26194: ST_TO_ADDR
// end ;
26195: GO 26104
26197: POP
26198: POP
// end ;
26199: LD_VAR 0 1
26203: RET
// export function MC_InitSides ( ) ; var i ; begin
26204: LD_INT 0
26206: PPUSH
26207: PPUSH
// if not mc_bases then
26208: LD_EXP 78
26212: NOT
26213: IFFALSE 26217
// exit ;
26215: GO 26291
// for i = 1 to mc_bases do
26217: LD_ADDR_VAR 0 2
26221: PUSH
26222: DOUBLE
26223: LD_INT 1
26225: DEC
26226: ST_TO_ADDR
26227: LD_EXP 78
26231: PUSH
26232: FOR_TO
26233: IFFALSE 26289
// if mc_bases [ i ] then
26235: LD_EXP 78
26239: PUSH
26240: LD_VAR 0 2
26244: ARRAY
26245: IFFALSE 26287
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
26247: LD_ADDR_EXP 104
26251: PUSH
26252: LD_EXP 104
26256: PPUSH
26257: LD_VAR 0 2
26261: PPUSH
26262: LD_EXP 78
26266: PUSH
26267: LD_VAR 0 2
26271: ARRAY
26272: PUSH
26273: LD_INT 1
26275: ARRAY
26276: PPUSH
26277: CALL_OW 255
26281: PPUSH
26282: CALL_OW 1
26286: ST_TO_ADDR
26287: GO 26232
26289: POP
26290: POP
// end ;
26291: LD_VAR 0 1
26295: RET
// every 0 0$03 trigger skirmish do
26296: LD_EXP 76
26300: IFFALSE 26454
26302: GO 26304
26304: DISABLE
// begin enable ;
26305: ENABLE
// MC_CheckBuildings ( ) ;
26306: CALL 30966 0 0
// MC_CheckPeopleLife ( ) ;
26310: CALL 31127 0 0
// RaiseSailEvent ( 100 ) ;
26314: LD_INT 100
26316: PPUSH
26317: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
26321: LD_INT 103
26323: PPUSH
26324: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
26328: LD_INT 104
26330: PPUSH
26331: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
26335: LD_INT 105
26337: PPUSH
26338: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
26342: LD_INT 106
26344: PPUSH
26345: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
26349: LD_INT 107
26351: PPUSH
26352: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
26356: LD_INT 108
26358: PPUSH
26359: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
26363: LD_INT 109
26365: PPUSH
26366: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
26370: LD_INT 110
26372: PPUSH
26373: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
26377: LD_INT 111
26379: PPUSH
26380: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
26384: LD_INT 112
26386: PPUSH
26387: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
26391: LD_INT 113
26393: PPUSH
26394: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
26398: LD_INT 120
26400: PPUSH
26401: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
26405: LD_INT 121
26407: PPUSH
26408: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
26412: LD_INT 122
26414: PPUSH
26415: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
26419: LD_INT 123
26421: PPUSH
26422: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
26426: LD_INT 124
26428: PPUSH
26429: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
26433: LD_INT 125
26435: PPUSH
26436: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
26440: LD_INT 126
26442: PPUSH
26443: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
26447: LD_INT 200
26449: PPUSH
26450: CALL_OW 427
// end ;
26454: END
// on SailEvent ( event ) do begin if event < 100 then
26455: LD_VAR 0 1
26459: PUSH
26460: LD_INT 100
26462: LESS
26463: IFFALSE 26474
// CustomEvent ( event ) ;
26465: LD_VAR 0 1
26469: PPUSH
26470: CALL 11645 0 1
// if event = 100 then
26474: LD_VAR 0 1
26478: PUSH
26479: LD_INT 100
26481: EQUAL
26482: IFFALSE 26488
// MC_ClassManager ( ) ;
26484: CALL 26880 0 0
// if event = 101 then
26488: LD_VAR 0 1
26492: PUSH
26493: LD_INT 101
26495: EQUAL
26496: IFFALSE 26502
// MC_RepairBuildings ( ) ;
26498: CALL 31712 0 0
// if event = 102 then
26502: LD_VAR 0 1
26506: PUSH
26507: LD_INT 102
26509: EQUAL
26510: IFFALSE 26516
// MC_Heal ( ) ;
26512: CALL 32647 0 0
// if event = 103 then
26516: LD_VAR 0 1
26520: PUSH
26521: LD_INT 103
26523: EQUAL
26524: IFFALSE 26530
// MC_Build ( ) ;
26526: CALL 33069 0 0
// if event = 104 then
26530: LD_VAR 0 1
26534: PUSH
26535: LD_INT 104
26537: EQUAL
26538: IFFALSE 26544
// MC_TurretWeapon ( ) ;
26540: CALL 34703 0 0
// if event = 105 then
26544: LD_VAR 0 1
26548: PUSH
26549: LD_INT 105
26551: EQUAL
26552: IFFALSE 26558
// MC_BuildUpgrade ( ) ;
26554: CALL 34254 0 0
// if event = 106 then
26558: LD_VAR 0 1
26562: PUSH
26563: LD_INT 106
26565: EQUAL
26566: IFFALSE 26572
// MC_PlantMines ( ) ;
26568: CALL 35133 0 0
// if event = 107 then
26572: LD_VAR 0 1
26576: PUSH
26577: LD_INT 107
26579: EQUAL
26580: IFFALSE 26586
// MC_CollectCrates ( ) ;
26582: CALL 35931 0 0
// if event = 108 then
26586: LD_VAR 0 1
26590: PUSH
26591: LD_INT 108
26593: EQUAL
26594: IFFALSE 26600
// MC_LinkRemoteControl ( ) ;
26596: CALL 37781 0 0
// if event = 109 then
26600: LD_VAR 0 1
26604: PUSH
26605: LD_INT 109
26607: EQUAL
26608: IFFALSE 26614
// MC_ProduceVehicle ( ) ;
26610: CALL 37962 0 0
// if event = 110 then
26614: LD_VAR 0 1
26618: PUSH
26619: LD_INT 110
26621: EQUAL
26622: IFFALSE 26628
// MC_SendAttack ( ) ;
26624: CALL 38428 0 0
// if event = 111 then
26628: LD_VAR 0 1
26632: PUSH
26633: LD_INT 111
26635: EQUAL
26636: IFFALSE 26642
// MC_Defend ( ) ;
26638: CALL 38536 0 0
// if event = 112 then
26642: LD_VAR 0 1
26646: PUSH
26647: LD_INT 112
26649: EQUAL
26650: IFFALSE 26656
// MC_Research ( ) ;
26652: CALL 39416 0 0
// if event = 113 then
26656: LD_VAR 0 1
26660: PUSH
26661: LD_INT 113
26663: EQUAL
26664: IFFALSE 26670
// MC_MinesTrigger ( ) ;
26666: CALL 40530 0 0
// if event = 120 then
26670: LD_VAR 0 1
26674: PUSH
26675: LD_INT 120
26677: EQUAL
26678: IFFALSE 26684
// MC_RepairVehicle ( ) ;
26680: CALL 40629 0 0
// if event = 121 then
26684: LD_VAR 0 1
26688: PUSH
26689: LD_INT 121
26691: EQUAL
26692: IFFALSE 26698
// MC_TameApe ( ) ;
26694: CALL 41398 0 0
// if event = 122 then
26698: LD_VAR 0 1
26702: PUSH
26703: LD_INT 122
26705: EQUAL
26706: IFFALSE 26712
// MC_ChangeApeClass ( ) ;
26708: CALL 42227 0 0
// if event = 123 then
26712: LD_VAR 0 1
26716: PUSH
26717: LD_INT 123
26719: EQUAL
26720: IFFALSE 26726
// MC_Bazooka ( ) ;
26722: CALL 42877 0 0
// if event = 124 then
26726: LD_VAR 0 1
26730: PUSH
26731: LD_INT 124
26733: EQUAL
26734: IFFALSE 26740
// MC_TeleportExit ( ) ;
26736: CALL 43075 0 0
// if event = 125 then
26740: LD_VAR 0 1
26744: PUSH
26745: LD_INT 125
26747: EQUAL
26748: IFFALSE 26754
// MC_Deposits ( ) ;
26750: CALL 43722 0 0
// if event = 126 then
26754: LD_VAR 0 1
26758: PUSH
26759: LD_INT 126
26761: EQUAL
26762: IFFALSE 26768
// MC_RemoteDriver ( ) ;
26764: CALL 44347 0 0
// if event = 200 then
26768: LD_VAR 0 1
26772: PUSH
26773: LD_INT 200
26775: EQUAL
26776: IFFALSE 26782
// MC_Idle ( ) ;
26778: CALL 46254 0 0
// end ;
26782: PPOPN 1
26784: END
// export function MC_Reset ( base , tag ) ; var i ; begin
26785: LD_INT 0
26787: PPUSH
26788: PPUSH
// if not mc_bases [ base ] or not tag then
26789: LD_EXP 78
26793: PUSH
26794: LD_VAR 0 1
26798: ARRAY
26799: NOT
26800: PUSH
26801: LD_VAR 0 2
26805: NOT
26806: OR
26807: IFFALSE 26811
// exit ;
26809: GO 26875
// for i in mc_bases [ base ] union mc_ape [ base ] do
26811: LD_ADDR_VAR 0 4
26815: PUSH
26816: LD_EXP 78
26820: PUSH
26821: LD_VAR 0 1
26825: ARRAY
26826: PUSH
26827: LD_EXP 107
26831: PUSH
26832: LD_VAR 0 1
26836: ARRAY
26837: UNION
26838: PUSH
26839: FOR_IN
26840: IFFALSE 26873
// if GetTag ( i ) = tag then
26842: LD_VAR 0 4
26846: PPUSH
26847: CALL_OW 110
26851: PUSH
26852: LD_VAR 0 2
26856: EQUAL
26857: IFFALSE 26871
// SetTag ( i , 0 ) ;
26859: LD_VAR 0 4
26863: PPUSH
26864: LD_INT 0
26866: PPUSH
26867: CALL_OW 109
26871: GO 26839
26873: POP
26874: POP
// end ;
26875: LD_VAR 0 3
26879: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
26880: LD_INT 0
26882: PPUSH
26883: PPUSH
26884: PPUSH
26885: PPUSH
26886: PPUSH
26887: PPUSH
26888: PPUSH
26889: PPUSH
// if not mc_bases then
26890: LD_EXP 78
26894: NOT
26895: IFFALSE 26899
// exit ;
26897: GO 27348
// for i = 1 to mc_bases do
26899: LD_ADDR_VAR 0 2
26903: PUSH
26904: DOUBLE
26905: LD_INT 1
26907: DEC
26908: ST_TO_ADDR
26909: LD_EXP 78
26913: PUSH
26914: FOR_TO
26915: IFFALSE 27346
// begin tmp := MC_ClassCheckReq ( i ) ;
26917: LD_ADDR_VAR 0 4
26921: PUSH
26922: LD_VAR 0 2
26926: PPUSH
26927: CALL 27353 0 1
26931: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
26932: LD_ADDR_EXP 119
26936: PUSH
26937: LD_EXP 119
26941: PPUSH
26942: LD_VAR 0 2
26946: PPUSH
26947: LD_VAR 0 4
26951: PPUSH
26952: CALL_OW 1
26956: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
26957: LD_ADDR_VAR 0 6
26961: PUSH
26962: LD_EXP 78
26966: PUSH
26967: LD_VAR 0 2
26971: ARRAY
26972: PPUSH
26973: LD_INT 2
26975: PUSH
26976: LD_INT 30
26978: PUSH
26979: LD_INT 4
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PUSH
26986: LD_INT 30
26988: PUSH
26989: LD_INT 5
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: LIST
27000: PPUSH
27001: CALL_OW 72
27005: PUSH
27006: LD_EXP 78
27010: PUSH
27011: LD_VAR 0 2
27015: ARRAY
27016: PPUSH
27017: LD_INT 2
27019: PUSH
27020: LD_INT 30
27022: PUSH
27023: LD_INT 0
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 30
27032: PUSH
27033: LD_INT 1
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: LIST
27044: PPUSH
27045: CALL_OW 72
27049: PUSH
27050: LD_EXP 78
27054: PUSH
27055: LD_VAR 0 2
27059: ARRAY
27060: PPUSH
27061: LD_INT 30
27063: PUSH
27064: LD_INT 3
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PPUSH
27071: CALL_OW 72
27075: PUSH
27076: LD_EXP 78
27080: PUSH
27081: LD_VAR 0 2
27085: ARRAY
27086: PPUSH
27087: LD_INT 2
27089: PUSH
27090: LD_INT 30
27092: PUSH
27093: LD_INT 6
27095: PUSH
27096: EMPTY
27097: LIST
27098: LIST
27099: PUSH
27100: LD_INT 30
27102: PUSH
27103: LD_INT 7
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: LD_INT 30
27112: PUSH
27113: LD_INT 8
27115: PUSH
27116: EMPTY
27117: LIST
27118: LIST
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: LIST
27124: LIST
27125: PPUSH
27126: CALL_OW 72
27130: PUSH
27131: EMPTY
27132: LIST
27133: LIST
27134: LIST
27135: LIST
27136: ST_TO_ADDR
// for j := 1 to 4 do
27137: LD_ADDR_VAR 0 3
27141: PUSH
27142: DOUBLE
27143: LD_INT 1
27145: DEC
27146: ST_TO_ADDR
27147: LD_INT 4
27149: PUSH
27150: FOR_TO
27151: IFFALSE 27342
// begin if not tmp [ j ] then
27153: LD_VAR 0 4
27157: PUSH
27158: LD_VAR 0 3
27162: ARRAY
27163: NOT
27164: IFFALSE 27168
// continue ;
27166: GO 27150
// for p in tmp [ j ] do
27168: LD_ADDR_VAR 0 5
27172: PUSH
27173: LD_VAR 0 4
27177: PUSH
27178: LD_VAR 0 3
27182: ARRAY
27183: PUSH
27184: FOR_IN
27185: IFFALSE 27338
// begin if not b [ j ] then
27187: LD_VAR 0 6
27191: PUSH
27192: LD_VAR 0 3
27196: ARRAY
27197: NOT
27198: IFFALSE 27202
// break ;
27200: GO 27338
// e := 0 ;
27202: LD_ADDR_VAR 0 7
27206: PUSH
27207: LD_INT 0
27209: ST_TO_ADDR
// for k in b [ j ] do
27210: LD_ADDR_VAR 0 8
27214: PUSH
27215: LD_VAR 0 6
27219: PUSH
27220: LD_VAR 0 3
27224: ARRAY
27225: PUSH
27226: FOR_IN
27227: IFFALSE 27254
// if IsNotFull ( k ) then
27229: LD_VAR 0 8
27233: PPUSH
27234: CALL 55508 0 1
27238: IFFALSE 27252
// begin e := k ;
27240: LD_ADDR_VAR 0 7
27244: PUSH
27245: LD_VAR 0 8
27249: ST_TO_ADDR
// break ;
27250: GO 27254
// end ;
27252: GO 27226
27254: POP
27255: POP
// if e and not UnitGoingToBuilding ( p , e ) then
27256: LD_VAR 0 7
27260: PUSH
27261: LD_VAR 0 5
27265: PPUSH
27266: LD_VAR 0 7
27270: PPUSH
27271: CALL 89647 0 2
27275: NOT
27276: AND
27277: IFFALSE 27336
// begin if IsInUnit ( p ) then
27279: LD_VAR 0 5
27283: PPUSH
27284: CALL_OW 310
27288: IFFALSE 27299
// ComExitBuilding ( p ) ;
27290: LD_VAR 0 5
27294: PPUSH
27295: CALL_OW 122
// ComEnterUnit ( p , e ) ;
27299: LD_VAR 0 5
27303: PPUSH
27304: LD_VAR 0 7
27308: PPUSH
27309: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
27313: LD_VAR 0 5
27317: PPUSH
27318: LD_VAR 0 3
27322: PPUSH
27323: CALL_OW 183
// AddComExitBuilding ( p ) ;
27327: LD_VAR 0 5
27331: PPUSH
27332: CALL_OW 182
// end ; end ;
27336: GO 27184
27338: POP
27339: POP
// end ;
27340: GO 27150
27342: POP
27343: POP
// end ;
27344: GO 26914
27346: POP
27347: POP
// end ;
27348: LD_VAR 0 1
27352: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
27353: LD_INT 0
27355: PPUSH
27356: PPUSH
27357: PPUSH
27358: PPUSH
27359: PPUSH
27360: PPUSH
27361: PPUSH
27362: PPUSH
27363: PPUSH
27364: PPUSH
27365: PPUSH
27366: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
27367: LD_ADDR_VAR 0 2
27371: PUSH
27372: LD_INT 0
27374: PUSH
27375: LD_INT 0
27377: PUSH
27378: LD_INT 0
27380: PUSH
27381: LD_INT 0
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
27390: LD_VAR 0 1
27394: NOT
27395: PUSH
27396: LD_EXP 78
27400: PUSH
27401: LD_VAR 0 1
27405: ARRAY
27406: NOT
27407: OR
27408: PUSH
27409: LD_EXP 78
27413: PUSH
27414: LD_VAR 0 1
27418: ARRAY
27419: PPUSH
27420: LD_INT 2
27422: PUSH
27423: LD_INT 30
27425: PUSH
27426: LD_INT 0
27428: PUSH
27429: EMPTY
27430: LIST
27431: LIST
27432: PUSH
27433: LD_INT 30
27435: PUSH
27436: LD_INT 1
27438: PUSH
27439: EMPTY
27440: LIST
27441: LIST
27442: PUSH
27443: EMPTY
27444: LIST
27445: LIST
27446: LIST
27447: PPUSH
27448: CALL_OW 72
27452: NOT
27453: OR
27454: IFFALSE 27458
// exit ;
27456: GO 30961
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27458: LD_ADDR_VAR 0 4
27462: PUSH
27463: LD_EXP 78
27467: PUSH
27468: LD_VAR 0 1
27472: ARRAY
27473: PPUSH
27474: LD_INT 2
27476: PUSH
27477: LD_INT 25
27479: PUSH
27480: LD_INT 1
27482: PUSH
27483: EMPTY
27484: LIST
27485: LIST
27486: PUSH
27487: LD_INT 25
27489: PUSH
27490: LD_INT 2
27492: PUSH
27493: EMPTY
27494: LIST
27495: LIST
27496: PUSH
27497: LD_INT 25
27499: PUSH
27500: LD_INT 3
27502: PUSH
27503: EMPTY
27504: LIST
27505: LIST
27506: PUSH
27507: LD_INT 25
27509: PUSH
27510: LD_INT 4
27512: PUSH
27513: EMPTY
27514: LIST
27515: LIST
27516: PUSH
27517: LD_INT 25
27519: PUSH
27520: LD_INT 5
27522: PUSH
27523: EMPTY
27524: LIST
27525: LIST
27526: PUSH
27527: LD_INT 25
27529: PUSH
27530: LD_INT 8
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PUSH
27537: LD_INT 25
27539: PUSH
27540: LD_INT 9
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: PPUSH
27557: CALL_OW 72
27561: ST_TO_ADDR
// if not tmp then
27562: LD_VAR 0 4
27566: NOT
27567: IFFALSE 27571
// exit ;
27569: GO 30961
// for i in tmp do
27571: LD_ADDR_VAR 0 3
27575: PUSH
27576: LD_VAR 0 4
27580: PUSH
27581: FOR_IN
27582: IFFALSE 27613
// if GetTag ( i ) then
27584: LD_VAR 0 3
27588: PPUSH
27589: CALL_OW 110
27593: IFFALSE 27611
// tmp := tmp diff i ;
27595: LD_ADDR_VAR 0 4
27599: PUSH
27600: LD_VAR 0 4
27604: PUSH
27605: LD_VAR 0 3
27609: DIFF
27610: ST_TO_ADDR
27611: GO 27581
27613: POP
27614: POP
// if not tmp then
27615: LD_VAR 0 4
27619: NOT
27620: IFFALSE 27624
// exit ;
27622: GO 30961
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27624: LD_ADDR_VAR 0 5
27628: PUSH
27629: LD_EXP 78
27633: PUSH
27634: LD_VAR 0 1
27638: ARRAY
27639: PPUSH
27640: LD_INT 2
27642: PUSH
27643: LD_INT 25
27645: PUSH
27646: LD_INT 1
27648: PUSH
27649: EMPTY
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 25
27655: PUSH
27656: LD_INT 5
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: PUSH
27663: LD_INT 25
27665: PUSH
27666: LD_INT 8
27668: PUSH
27669: EMPTY
27670: LIST
27671: LIST
27672: PUSH
27673: LD_INT 25
27675: PUSH
27676: LD_INT 9
27678: PUSH
27679: EMPTY
27680: LIST
27681: LIST
27682: PUSH
27683: EMPTY
27684: LIST
27685: LIST
27686: LIST
27687: LIST
27688: LIST
27689: PPUSH
27690: CALL_OW 72
27694: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
27695: LD_ADDR_VAR 0 6
27699: PUSH
27700: LD_EXP 78
27704: PUSH
27705: LD_VAR 0 1
27709: ARRAY
27710: PPUSH
27711: LD_INT 25
27713: PUSH
27714: LD_INT 2
27716: PUSH
27717: EMPTY
27718: LIST
27719: LIST
27720: PPUSH
27721: CALL_OW 72
27725: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
27726: LD_ADDR_VAR 0 7
27730: PUSH
27731: LD_EXP 78
27735: PUSH
27736: LD_VAR 0 1
27740: ARRAY
27741: PPUSH
27742: LD_INT 25
27744: PUSH
27745: LD_INT 3
27747: PUSH
27748: EMPTY
27749: LIST
27750: LIST
27751: PPUSH
27752: CALL_OW 72
27756: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
27757: LD_ADDR_VAR 0 8
27761: PUSH
27762: LD_EXP 78
27766: PUSH
27767: LD_VAR 0 1
27771: ARRAY
27772: PPUSH
27773: LD_INT 25
27775: PUSH
27776: LD_INT 4
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: LD_INT 24
27785: PUSH
27786: LD_INT 251
27788: PUSH
27789: EMPTY
27790: LIST
27791: LIST
27792: PUSH
27793: EMPTY
27794: LIST
27795: LIST
27796: PPUSH
27797: CALL_OW 72
27801: ST_TO_ADDR
// if mc_is_defending [ base ] then
27802: LD_EXP 121
27806: PUSH
27807: LD_VAR 0 1
27811: ARRAY
27812: IFFALSE 28273
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
27814: LD_ADDR_EXP 120
27818: PUSH
27819: LD_EXP 120
27823: PPUSH
27824: LD_VAR 0 1
27828: PPUSH
27829: LD_INT 4
27831: PPUSH
27832: CALL_OW 1
27836: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
27837: LD_ADDR_VAR 0 12
27841: PUSH
27842: LD_EXP 78
27846: PUSH
27847: LD_VAR 0 1
27851: ARRAY
27852: PPUSH
27853: LD_INT 2
27855: PUSH
27856: LD_INT 30
27858: PUSH
27859: LD_INT 4
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: LD_INT 30
27868: PUSH
27869: LD_INT 5
27871: PUSH
27872: EMPTY
27873: LIST
27874: LIST
27875: PUSH
27876: EMPTY
27877: LIST
27878: LIST
27879: LIST
27880: PPUSH
27881: CALL_OW 72
27885: ST_TO_ADDR
// if not b then
27886: LD_VAR 0 12
27890: NOT
27891: IFFALSE 27895
// exit ;
27893: GO 30961
// p := [ ] ;
27895: LD_ADDR_VAR 0 11
27899: PUSH
27900: EMPTY
27901: ST_TO_ADDR
// if sci >= 2 then
27902: LD_VAR 0 8
27906: PUSH
27907: LD_INT 2
27909: GREATEREQUAL
27910: IFFALSE 27941
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
27912: LD_ADDR_VAR 0 8
27916: PUSH
27917: LD_VAR 0 8
27921: PUSH
27922: LD_INT 1
27924: ARRAY
27925: PUSH
27926: LD_VAR 0 8
27930: PUSH
27931: LD_INT 2
27933: ARRAY
27934: PUSH
27935: EMPTY
27936: LIST
27937: LIST
27938: ST_TO_ADDR
27939: GO 28002
// if sci = 1 then
27941: LD_VAR 0 8
27945: PUSH
27946: LD_INT 1
27948: EQUAL
27949: IFFALSE 27970
// sci := [ sci [ 1 ] ] else
27951: LD_ADDR_VAR 0 8
27955: PUSH
27956: LD_VAR 0 8
27960: PUSH
27961: LD_INT 1
27963: ARRAY
27964: PUSH
27965: EMPTY
27966: LIST
27967: ST_TO_ADDR
27968: GO 28002
// if sci = 0 then
27970: LD_VAR 0 8
27974: PUSH
27975: LD_INT 0
27977: EQUAL
27978: IFFALSE 28002
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
27980: LD_ADDR_VAR 0 11
27984: PUSH
27985: LD_VAR 0 4
27989: PPUSH
27990: LD_INT 4
27992: PPUSH
27993: CALL 89519 0 2
27997: PUSH
27998: LD_INT 1
28000: ARRAY
28001: ST_TO_ADDR
// if eng > 4 then
28002: LD_VAR 0 6
28006: PUSH
28007: LD_INT 4
28009: GREATER
28010: IFFALSE 28056
// for i = eng downto 4 do
28012: LD_ADDR_VAR 0 3
28016: PUSH
28017: DOUBLE
28018: LD_VAR 0 6
28022: INC
28023: ST_TO_ADDR
28024: LD_INT 4
28026: PUSH
28027: FOR_DOWNTO
28028: IFFALSE 28054
// eng := eng diff eng [ i ] ;
28030: LD_ADDR_VAR 0 6
28034: PUSH
28035: LD_VAR 0 6
28039: PUSH
28040: LD_VAR 0 6
28044: PUSH
28045: LD_VAR 0 3
28049: ARRAY
28050: DIFF
28051: ST_TO_ADDR
28052: GO 28027
28054: POP
28055: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
28056: LD_ADDR_VAR 0 4
28060: PUSH
28061: LD_VAR 0 4
28065: PUSH
28066: LD_VAR 0 5
28070: PUSH
28071: LD_VAR 0 6
28075: UNION
28076: PUSH
28077: LD_VAR 0 7
28081: UNION
28082: PUSH
28083: LD_VAR 0 8
28087: UNION
28088: DIFF
28089: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
28090: LD_ADDR_VAR 0 13
28094: PUSH
28095: LD_EXP 78
28099: PUSH
28100: LD_VAR 0 1
28104: ARRAY
28105: PPUSH
28106: LD_INT 2
28108: PUSH
28109: LD_INT 30
28111: PUSH
28112: LD_INT 32
28114: PUSH
28115: EMPTY
28116: LIST
28117: LIST
28118: PUSH
28119: LD_INT 30
28121: PUSH
28122: LD_INT 31
28124: PUSH
28125: EMPTY
28126: LIST
28127: LIST
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: LIST
28133: PPUSH
28134: CALL_OW 72
28138: PUSH
28139: LD_EXP 78
28143: PUSH
28144: LD_VAR 0 1
28148: ARRAY
28149: PPUSH
28150: LD_INT 2
28152: PUSH
28153: LD_INT 30
28155: PUSH
28156: LD_INT 4
28158: PUSH
28159: EMPTY
28160: LIST
28161: LIST
28162: PUSH
28163: LD_INT 30
28165: PUSH
28166: LD_INT 5
28168: PUSH
28169: EMPTY
28170: LIST
28171: LIST
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: LIST
28177: PPUSH
28178: CALL_OW 72
28182: PUSH
28183: LD_INT 6
28185: MUL
28186: PLUS
28187: ST_TO_ADDR
// if bcount < tmp then
28188: LD_VAR 0 13
28192: PUSH
28193: LD_VAR 0 4
28197: LESS
28198: IFFALSE 28244
// for i = tmp downto bcount do
28200: LD_ADDR_VAR 0 3
28204: PUSH
28205: DOUBLE
28206: LD_VAR 0 4
28210: INC
28211: ST_TO_ADDR
28212: LD_VAR 0 13
28216: PUSH
28217: FOR_DOWNTO
28218: IFFALSE 28242
// tmp := Delete ( tmp , tmp ) ;
28220: LD_ADDR_VAR 0 4
28224: PUSH
28225: LD_VAR 0 4
28229: PPUSH
28230: LD_VAR 0 4
28234: PPUSH
28235: CALL_OW 3
28239: ST_TO_ADDR
28240: GO 28217
28242: POP
28243: POP
// result := [ tmp , 0 , 0 , p ] ;
28244: LD_ADDR_VAR 0 2
28248: PUSH
28249: LD_VAR 0 4
28253: PUSH
28254: LD_INT 0
28256: PUSH
28257: LD_INT 0
28259: PUSH
28260: LD_VAR 0 11
28264: PUSH
28265: EMPTY
28266: LIST
28267: LIST
28268: LIST
28269: LIST
28270: ST_TO_ADDR
// exit ;
28271: GO 30961
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28273: LD_EXP 78
28277: PUSH
28278: LD_VAR 0 1
28282: ARRAY
28283: PPUSH
28284: LD_INT 2
28286: PUSH
28287: LD_INT 30
28289: PUSH
28290: LD_INT 6
28292: PUSH
28293: EMPTY
28294: LIST
28295: LIST
28296: PUSH
28297: LD_INT 30
28299: PUSH
28300: LD_INT 7
28302: PUSH
28303: EMPTY
28304: LIST
28305: LIST
28306: PUSH
28307: LD_INT 30
28309: PUSH
28310: LD_INT 8
28312: PUSH
28313: EMPTY
28314: LIST
28315: LIST
28316: PUSH
28317: EMPTY
28318: LIST
28319: LIST
28320: LIST
28321: LIST
28322: PPUSH
28323: CALL_OW 72
28327: NOT
28328: PUSH
28329: LD_EXP 78
28333: PUSH
28334: LD_VAR 0 1
28338: ARRAY
28339: PPUSH
28340: LD_INT 30
28342: PUSH
28343: LD_INT 3
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PPUSH
28350: CALL_OW 72
28354: NOT
28355: AND
28356: IFFALSE 28428
// begin if eng = tmp then
28358: LD_VAR 0 6
28362: PUSH
28363: LD_VAR 0 4
28367: EQUAL
28368: IFFALSE 28372
// exit ;
28370: GO 30961
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
28372: LD_ADDR_EXP 120
28376: PUSH
28377: LD_EXP 120
28381: PPUSH
28382: LD_VAR 0 1
28386: PPUSH
28387: LD_INT 1
28389: PPUSH
28390: CALL_OW 1
28394: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
28395: LD_ADDR_VAR 0 2
28399: PUSH
28400: LD_INT 0
28402: PUSH
28403: LD_VAR 0 4
28407: PUSH
28408: LD_VAR 0 6
28412: DIFF
28413: PUSH
28414: LD_INT 0
28416: PUSH
28417: LD_INT 0
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: LIST
28424: LIST
28425: ST_TO_ADDR
// exit ;
28426: GO 30961
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28428: LD_EXP 105
28432: PUSH
28433: LD_EXP 104
28437: PUSH
28438: LD_VAR 0 1
28442: ARRAY
28443: ARRAY
28444: PUSH
28445: LD_EXP 78
28449: PUSH
28450: LD_VAR 0 1
28454: ARRAY
28455: PPUSH
28456: LD_INT 2
28458: PUSH
28459: LD_INT 30
28461: PUSH
28462: LD_INT 6
28464: PUSH
28465: EMPTY
28466: LIST
28467: LIST
28468: PUSH
28469: LD_INT 30
28471: PUSH
28472: LD_INT 7
28474: PUSH
28475: EMPTY
28476: LIST
28477: LIST
28478: PUSH
28479: LD_INT 30
28481: PUSH
28482: LD_INT 8
28484: PUSH
28485: EMPTY
28486: LIST
28487: LIST
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: PPUSH
28495: CALL_OW 72
28499: AND
28500: PUSH
28501: LD_EXP 78
28505: PUSH
28506: LD_VAR 0 1
28510: ARRAY
28511: PPUSH
28512: LD_INT 30
28514: PUSH
28515: LD_INT 3
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: PPUSH
28522: CALL_OW 72
28526: NOT
28527: AND
28528: IFFALSE 28742
// begin if sci >= 6 then
28530: LD_VAR 0 8
28534: PUSH
28535: LD_INT 6
28537: GREATEREQUAL
28538: IFFALSE 28542
// exit ;
28540: GO 30961
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28542: LD_ADDR_EXP 120
28546: PUSH
28547: LD_EXP 120
28551: PPUSH
28552: LD_VAR 0 1
28556: PPUSH
28557: LD_INT 2
28559: PPUSH
28560: CALL_OW 1
28564: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28565: LD_ADDR_VAR 0 9
28569: PUSH
28570: LD_VAR 0 4
28574: PUSH
28575: LD_VAR 0 8
28579: DIFF
28580: PPUSH
28581: LD_INT 4
28583: PPUSH
28584: CALL 89519 0 2
28588: ST_TO_ADDR
// p := [ ] ;
28589: LD_ADDR_VAR 0 11
28593: PUSH
28594: EMPTY
28595: ST_TO_ADDR
// if sci < 6 and sort > 6 then
28596: LD_VAR 0 8
28600: PUSH
28601: LD_INT 6
28603: LESS
28604: PUSH
28605: LD_VAR 0 9
28609: PUSH
28610: LD_INT 6
28612: GREATER
28613: AND
28614: IFFALSE 28695
// begin for i = 1 to 6 - sci do
28616: LD_ADDR_VAR 0 3
28620: PUSH
28621: DOUBLE
28622: LD_INT 1
28624: DEC
28625: ST_TO_ADDR
28626: LD_INT 6
28628: PUSH
28629: LD_VAR 0 8
28633: MINUS
28634: PUSH
28635: FOR_TO
28636: IFFALSE 28691
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
28638: LD_ADDR_VAR 0 11
28642: PUSH
28643: LD_VAR 0 11
28647: PPUSH
28648: LD_VAR 0 11
28652: PUSH
28653: LD_INT 1
28655: PLUS
28656: PPUSH
28657: LD_VAR 0 9
28661: PUSH
28662: LD_INT 1
28664: ARRAY
28665: PPUSH
28666: CALL_OW 2
28670: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
28671: LD_ADDR_VAR 0 9
28675: PUSH
28676: LD_VAR 0 9
28680: PPUSH
28681: LD_INT 1
28683: PPUSH
28684: CALL_OW 3
28688: ST_TO_ADDR
// end ;
28689: GO 28635
28691: POP
28692: POP
// end else
28693: GO 28715
// if sort then
28695: LD_VAR 0 9
28699: IFFALSE 28715
// p := sort [ 1 ] ;
28701: LD_ADDR_VAR 0 11
28705: PUSH
28706: LD_VAR 0 9
28710: PUSH
28711: LD_INT 1
28713: ARRAY
28714: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
28715: LD_ADDR_VAR 0 2
28719: PUSH
28720: LD_INT 0
28722: PUSH
28723: LD_INT 0
28725: PUSH
28726: LD_INT 0
28728: PUSH
28729: LD_VAR 0 11
28733: PUSH
28734: EMPTY
28735: LIST
28736: LIST
28737: LIST
28738: LIST
28739: ST_TO_ADDR
// exit ;
28740: GO 30961
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28742: LD_EXP 105
28746: PUSH
28747: LD_EXP 104
28751: PUSH
28752: LD_VAR 0 1
28756: ARRAY
28757: ARRAY
28758: PUSH
28759: LD_EXP 78
28763: PUSH
28764: LD_VAR 0 1
28768: ARRAY
28769: PPUSH
28770: LD_INT 2
28772: PUSH
28773: LD_INT 30
28775: PUSH
28776: LD_INT 6
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: PUSH
28783: LD_INT 30
28785: PUSH
28786: LD_INT 7
28788: PUSH
28789: EMPTY
28790: LIST
28791: LIST
28792: PUSH
28793: LD_INT 30
28795: PUSH
28796: LD_INT 8
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: PUSH
28803: EMPTY
28804: LIST
28805: LIST
28806: LIST
28807: LIST
28808: PPUSH
28809: CALL_OW 72
28813: AND
28814: PUSH
28815: LD_EXP 78
28819: PUSH
28820: LD_VAR 0 1
28824: ARRAY
28825: PPUSH
28826: LD_INT 30
28828: PUSH
28829: LD_INT 3
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PPUSH
28836: CALL_OW 72
28840: AND
28841: IFFALSE 29575
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
28843: LD_ADDR_EXP 120
28847: PUSH
28848: LD_EXP 120
28852: PPUSH
28853: LD_VAR 0 1
28857: PPUSH
28858: LD_INT 3
28860: PPUSH
28861: CALL_OW 1
28865: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28866: LD_ADDR_VAR 0 2
28870: PUSH
28871: LD_INT 0
28873: PUSH
28874: LD_INT 0
28876: PUSH
28877: LD_INT 0
28879: PUSH
28880: LD_INT 0
28882: PUSH
28883: EMPTY
28884: LIST
28885: LIST
28886: LIST
28887: LIST
28888: ST_TO_ADDR
// if not eng then
28889: LD_VAR 0 6
28893: NOT
28894: IFFALSE 28957
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
28896: LD_ADDR_VAR 0 11
28900: PUSH
28901: LD_VAR 0 4
28905: PPUSH
28906: LD_INT 2
28908: PPUSH
28909: CALL 89519 0 2
28913: PUSH
28914: LD_INT 1
28916: ARRAY
28917: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
28918: LD_ADDR_VAR 0 2
28922: PUSH
28923: LD_VAR 0 2
28927: PPUSH
28928: LD_INT 2
28930: PPUSH
28931: LD_VAR 0 11
28935: PPUSH
28936: CALL_OW 1
28940: ST_TO_ADDR
// tmp := tmp diff p ;
28941: LD_ADDR_VAR 0 4
28945: PUSH
28946: LD_VAR 0 4
28950: PUSH
28951: LD_VAR 0 11
28955: DIFF
28956: ST_TO_ADDR
// end ; if tmp and sci < 6 then
28957: LD_VAR 0 4
28961: PUSH
28962: LD_VAR 0 8
28966: PUSH
28967: LD_INT 6
28969: LESS
28970: AND
28971: IFFALSE 29159
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
28973: LD_ADDR_VAR 0 9
28977: PUSH
28978: LD_VAR 0 4
28982: PUSH
28983: LD_VAR 0 8
28987: PUSH
28988: LD_VAR 0 7
28992: UNION
28993: DIFF
28994: PPUSH
28995: LD_INT 4
28997: PPUSH
28998: CALL 89519 0 2
29002: ST_TO_ADDR
// p := [ ] ;
29003: LD_ADDR_VAR 0 11
29007: PUSH
29008: EMPTY
29009: ST_TO_ADDR
// if sort then
29010: LD_VAR 0 9
29014: IFFALSE 29130
// for i = 1 to 6 - sci do
29016: LD_ADDR_VAR 0 3
29020: PUSH
29021: DOUBLE
29022: LD_INT 1
29024: DEC
29025: ST_TO_ADDR
29026: LD_INT 6
29028: PUSH
29029: LD_VAR 0 8
29033: MINUS
29034: PUSH
29035: FOR_TO
29036: IFFALSE 29128
// begin if i = sort then
29038: LD_VAR 0 3
29042: PUSH
29043: LD_VAR 0 9
29047: EQUAL
29048: IFFALSE 29052
// break ;
29050: GO 29128
// if GetClass ( i ) = 4 then
29052: LD_VAR 0 3
29056: PPUSH
29057: CALL_OW 257
29061: PUSH
29062: LD_INT 4
29064: EQUAL
29065: IFFALSE 29069
// continue ;
29067: GO 29035
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29069: LD_ADDR_VAR 0 11
29073: PUSH
29074: LD_VAR 0 11
29078: PPUSH
29079: LD_VAR 0 11
29083: PUSH
29084: LD_INT 1
29086: PLUS
29087: PPUSH
29088: LD_VAR 0 9
29092: PUSH
29093: LD_VAR 0 3
29097: ARRAY
29098: PPUSH
29099: CALL_OW 2
29103: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29104: LD_ADDR_VAR 0 4
29108: PUSH
29109: LD_VAR 0 4
29113: PUSH
29114: LD_VAR 0 9
29118: PUSH
29119: LD_VAR 0 3
29123: ARRAY
29124: DIFF
29125: ST_TO_ADDR
// end ;
29126: GO 29035
29128: POP
29129: POP
// if p then
29130: LD_VAR 0 11
29134: IFFALSE 29159
// result := Replace ( result , 4 , p ) ;
29136: LD_ADDR_VAR 0 2
29140: PUSH
29141: LD_VAR 0 2
29145: PPUSH
29146: LD_INT 4
29148: PPUSH
29149: LD_VAR 0 11
29153: PPUSH
29154: CALL_OW 1
29158: ST_TO_ADDR
// end ; if tmp and mech < 6 then
29159: LD_VAR 0 4
29163: PUSH
29164: LD_VAR 0 7
29168: PUSH
29169: LD_INT 6
29171: LESS
29172: AND
29173: IFFALSE 29361
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29175: LD_ADDR_VAR 0 9
29179: PUSH
29180: LD_VAR 0 4
29184: PUSH
29185: LD_VAR 0 8
29189: PUSH
29190: LD_VAR 0 7
29194: UNION
29195: DIFF
29196: PPUSH
29197: LD_INT 3
29199: PPUSH
29200: CALL 89519 0 2
29204: ST_TO_ADDR
// p := [ ] ;
29205: LD_ADDR_VAR 0 11
29209: PUSH
29210: EMPTY
29211: ST_TO_ADDR
// if sort then
29212: LD_VAR 0 9
29216: IFFALSE 29332
// for i = 1 to 6 - mech do
29218: LD_ADDR_VAR 0 3
29222: PUSH
29223: DOUBLE
29224: LD_INT 1
29226: DEC
29227: ST_TO_ADDR
29228: LD_INT 6
29230: PUSH
29231: LD_VAR 0 7
29235: MINUS
29236: PUSH
29237: FOR_TO
29238: IFFALSE 29330
// begin if i = sort then
29240: LD_VAR 0 3
29244: PUSH
29245: LD_VAR 0 9
29249: EQUAL
29250: IFFALSE 29254
// break ;
29252: GO 29330
// if GetClass ( i ) = 3 then
29254: LD_VAR 0 3
29258: PPUSH
29259: CALL_OW 257
29263: PUSH
29264: LD_INT 3
29266: EQUAL
29267: IFFALSE 29271
// continue ;
29269: GO 29237
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29271: LD_ADDR_VAR 0 11
29275: PUSH
29276: LD_VAR 0 11
29280: PPUSH
29281: LD_VAR 0 11
29285: PUSH
29286: LD_INT 1
29288: PLUS
29289: PPUSH
29290: LD_VAR 0 9
29294: PUSH
29295: LD_VAR 0 3
29299: ARRAY
29300: PPUSH
29301: CALL_OW 2
29305: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29306: LD_ADDR_VAR 0 4
29310: PUSH
29311: LD_VAR 0 4
29315: PUSH
29316: LD_VAR 0 9
29320: PUSH
29321: LD_VAR 0 3
29325: ARRAY
29326: DIFF
29327: ST_TO_ADDR
// end ;
29328: GO 29237
29330: POP
29331: POP
// if p then
29332: LD_VAR 0 11
29336: IFFALSE 29361
// result := Replace ( result , 3 , p ) ;
29338: LD_ADDR_VAR 0 2
29342: PUSH
29343: LD_VAR 0 2
29347: PPUSH
29348: LD_INT 3
29350: PPUSH
29351: LD_VAR 0 11
29355: PPUSH
29356: CALL_OW 1
29360: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
29361: LD_VAR 0 4
29365: PUSH
29366: LD_INT 6
29368: GREATER
29369: PUSH
29370: LD_VAR 0 6
29374: PUSH
29375: LD_INT 6
29377: LESS
29378: AND
29379: IFFALSE 29573
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29381: LD_ADDR_VAR 0 9
29385: PUSH
29386: LD_VAR 0 4
29390: PUSH
29391: LD_VAR 0 8
29395: PUSH
29396: LD_VAR 0 7
29400: UNION
29401: PUSH
29402: LD_VAR 0 6
29406: UNION
29407: DIFF
29408: PPUSH
29409: LD_INT 2
29411: PPUSH
29412: CALL 89519 0 2
29416: ST_TO_ADDR
// p := [ ] ;
29417: LD_ADDR_VAR 0 11
29421: PUSH
29422: EMPTY
29423: ST_TO_ADDR
// if sort then
29424: LD_VAR 0 9
29428: IFFALSE 29544
// for i = 1 to 6 - eng do
29430: LD_ADDR_VAR 0 3
29434: PUSH
29435: DOUBLE
29436: LD_INT 1
29438: DEC
29439: ST_TO_ADDR
29440: LD_INT 6
29442: PUSH
29443: LD_VAR 0 6
29447: MINUS
29448: PUSH
29449: FOR_TO
29450: IFFALSE 29542
// begin if i = sort then
29452: LD_VAR 0 3
29456: PUSH
29457: LD_VAR 0 9
29461: EQUAL
29462: IFFALSE 29466
// break ;
29464: GO 29542
// if GetClass ( i ) = 2 then
29466: LD_VAR 0 3
29470: PPUSH
29471: CALL_OW 257
29475: PUSH
29476: LD_INT 2
29478: EQUAL
29479: IFFALSE 29483
// continue ;
29481: GO 29449
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29483: LD_ADDR_VAR 0 11
29487: PUSH
29488: LD_VAR 0 11
29492: PPUSH
29493: LD_VAR 0 11
29497: PUSH
29498: LD_INT 1
29500: PLUS
29501: PPUSH
29502: LD_VAR 0 9
29506: PUSH
29507: LD_VAR 0 3
29511: ARRAY
29512: PPUSH
29513: CALL_OW 2
29517: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29518: LD_ADDR_VAR 0 4
29522: PUSH
29523: LD_VAR 0 4
29527: PUSH
29528: LD_VAR 0 9
29532: PUSH
29533: LD_VAR 0 3
29537: ARRAY
29538: DIFF
29539: ST_TO_ADDR
// end ;
29540: GO 29449
29542: POP
29543: POP
// if p then
29544: LD_VAR 0 11
29548: IFFALSE 29573
// result := Replace ( result , 2 , p ) ;
29550: LD_ADDR_VAR 0 2
29554: PUSH
29555: LD_VAR 0 2
29559: PPUSH
29560: LD_INT 2
29562: PPUSH
29563: LD_VAR 0 11
29567: PPUSH
29568: CALL_OW 1
29572: ST_TO_ADDR
// end ; exit ;
29573: GO 30961
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29575: LD_EXP 105
29579: PUSH
29580: LD_EXP 104
29584: PUSH
29585: LD_VAR 0 1
29589: ARRAY
29590: ARRAY
29591: NOT
29592: PUSH
29593: LD_EXP 78
29597: PUSH
29598: LD_VAR 0 1
29602: ARRAY
29603: PPUSH
29604: LD_INT 30
29606: PUSH
29607: LD_INT 3
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PPUSH
29614: CALL_OW 72
29618: AND
29619: PUSH
29620: LD_EXP 83
29624: PUSH
29625: LD_VAR 0 1
29629: ARRAY
29630: AND
29631: IFFALSE 30239
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
29633: LD_ADDR_EXP 120
29637: PUSH
29638: LD_EXP 120
29642: PPUSH
29643: LD_VAR 0 1
29647: PPUSH
29648: LD_INT 5
29650: PPUSH
29651: CALL_OW 1
29655: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29656: LD_ADDR_VAR 0 2
29660: PUSH
29661: LD_INT 0
29663: PUSH
29664: LD_INT 0
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 0
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: ST_TO_ADDR
// if sci > 1 then
29679: LD_VAR 0 8
29683: PUSH
29684: LD_INT 1
29686: GREATER
29687: IFFALSE 29715
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
29689: LD_ADDR_VAR 0 4
29693: PUSH
29694: LD_VAR 0 4
29698: PUSH
29699: LD_VAR 0 8
29703: PUSH
29704: LD_VAR 0 8
29708: PUSH
29709: LD_INT 1
29711: ARRAY
29712: DIFF
29713: DIFF
29714: ST_TO_ADDR
// if tmp and not sci then
29715: LD_VAR 0 4
29719: PUSH
29720: LD_VAR 0 8
29724: NOT
29725: AND
29726: IFFALSE 29795
// begin sort := SortBySkill ( tmp , 4 ) ;
29728: LD_ADDR_VAR 0 9
29732: PUSH
29733: LD_VAR 0 4
29737: PPUSH
29738: LD_INT 4
29740: PPUSH
29741: CALL 89519 0 2
29745: ST_TO_ADDR
// if sort then
29746: LD_VAR 0 9
29750: IFFALSE 29766
// p := sort [ 1 ] ;
29752: LD_ADDR_VAR 0 11
29756: PUSH
29757: LD_VAR 0 9
29761: PUSH
29762: LD_INT 1
29764: ARRAY
29765: ST_TO_ADDR
// if p then
29766: LD_VAR 0 11
29770: IFFALSE 29795
// result := Replace ( result , 4 , p ) ;
29772: LD_ADDR_VAR 0 2
29776: PUSH
29777: LD_VAR 0 2
29781: PPUSH
29782: LD_INT 4
29784: PPUSH
29785: LD_VAR 0 11
29789: PPUSH
29790: CALL_OW 1
29794: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29795: LD_ADDR_VAR 0 4
29799: PUSH
29800: LD_VAR 0 4
29804: PUSH
29805: LD_VAR 0 7
29809: DIFF
29810: ST_TO_ADDR
// if tmp and mech < 6 then
29811: LD_VAR 0 4
29815: PUSH
29816: LD_VAR 0 7
29820: PUSH
29821: LD_INT 6
29823: LESS
29824: AND
29825: IFFALSE 30013
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29827: LD_ADDR_VAR 0 9
29831: PUSH
29832: LD_VAR 0 4
29836: PUSH
29837: LD_VAR 0 8
29841: PUSH
29842: LD_VAR 0 7
29846: UNION
29847: DIFF
29848: PPUSH
29849: LD_INT 3
29851: PPUSH
29852: CALL 89519 0 2
29856: ST_TO_ADDR
// p := [ ] ;
29857: LD_ADDR_VAR 0 11
29861: PUSH
29862: EMPTY
29863: ST_TO_ADDR
// if sort then
29864: LD_VAR 0 9
29868: IFFALSE 29984
// for i = 1 to 6 - mech do
29870: LD_ADDR_VAR 0 3
29874: PUSH
29875: DOUBLE
29876: LD_INT 1
29878: DEC
29879: ST_TO_ADDR
29880: LD_INT 6
29882: PUSH
29883: LD_VAR 0 7
29887: MINUS
29888: PUSH
29889: FOR_TO
29890: IFFALSE 29982
// begin if i = sort then
29892: LD_VAR 0 3
29896: PUSH
29897: LD_VAR 0 9
29901: EQUAL
29902: IFFALSE 29906
// break ;
29904: GO 29982
// if GetClass ( i ) = 3 then
29906: LD_VAR 0 3
29910: PPUSH
29911: CALL_OW 257
29915: PUSH
29916: LD_INT 3
29918: EQUAL
29919: IFFALSE 29923
// continue ;
29921: GO 29889
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29923: LD_ADDR_VAR 0 11
29927: PUSH
29928: LD_VAR 0 11
29932: PPUSH
29933: LD_VAR 0 11
29937: PUSH
29938: LD_INT 1
29940: PLUS
29941: PPUSH
29942: LD_VAR 0 9
29946: PUSH
29947: LD_VAR 0 3
29951: ARRAY
29952: PPUSH
29953: CALL_OW 2
29957: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29958: LD_ADDR_VAR 0 4
29962: PUSH
29963: LD_VAR 0 4
29967: PUSH
29968: LD_VAR 0 9
29972: PUSH
29973: LD_VAR 0 3
29977: ARRAY
29978: DIFF
29979: ST_TO_ADDR
// end ;
29980: GO 29889
29982: POP
29983: POP
// if p then
29984: LD_VAR 0 11
29988: IFFALSE 30013
// result := Replace ( result , 3 , p ) ;
29990: LD_ADDR_VAR 0 2
29994: PUSH
29995: LD_VAR 0 2
29999: PPUSH
30000: LD_INT 3
30002: PPUSH
30003: LD_VAR 0 11
30007: PPUSH
30008: CALL_OW 1
30012: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30013: LD_ADDR_VAR 0 4
30017: PUSH
30018: LD_VAR 0 4
30022: PUSH
30023: LD_VAR 0 6
30027: DIFF
30028: ST_TO_ADDR
// if tmp and eng < 6 then
30029: LD_VAR 0 4
30033: PUSH
30034: LD_VAR 0 6
30038: PUSH
30039: LD_INT 6
30041: LESS
30042: AND
30043: IFFALSE 30237
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
30045: LD_ADDR_VAR 0 9
30049: PUSH
30050: LD_VAR 0 4
30054: PUSH
30055: LD_VAR 0 8
30059: PUSH
30060: LD_VAR 0 7
30064: UNION
30065: PUSH
30066: LD_VAR 0 6
30070: UNION
30071: DIFF
30072: PPUSH
30073: LD_INT 2
30075: PPUSH
30076: CALL 89519 0 2
30080: ST_TO_ADDR
// p := [ ] ;
30081: LD_ADDR_VAR 0 11
30085: PUSH
30086: EMPTY
30087: ST_TO_ADDR
// if sort then
30088: LD_VAR 0 9
30092: IFFALSE 30208
// for i = 1 to 6 - eng do
30094: LD_ADDR_VAR 0 3
30098: PUSH
30099: DOUBLE
30100: LD_INT 1
30102: DEC
30103: ST_TO_ADDR
30104: LD_INT 6
30106: PUSH
30107: LD_VAR 0 6
30111: MINUS
30112: PUSH
30113: FOR_TO
30114: IFFALSE 30206
// begin if i = sort then
30116: LD_VAR 0 3
30120: PUSH
30121: LD_VAR 0 9
30125: EQUAL
30126: IFFALSE 30130
// break ;
30128: GO 30206
// if GetClass ( i ) = 2 then
30130: LD_VAR 0 3
30134: PPUSH
30135: CALL_OW 257
30139: PUSH
30140: LD_INT 2
30142: EQUAL
30143: IFFALSE 30147
// continue ;
30145: GO 30113
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30147: LD_ADDR_VAR 0 11
30151: PUSH
30152: LD_VAR 0 11
30156: PPUSH
30157: LD_VAR 0 11
30161: PUSH
30162: LD_INT 1
30164: PLUS
30165: PPUSH
30166: LD_VAR 0 9
30170: PUSH
30171: LD_VAR 0 3
30175: ARRAY
30176: PPUSH
30177: CALL_OW 2
30181: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30182: LD_ADDR_VAR 0 4
30186: PUSH
30187: LD_VAR 0 4
30191: PUSH
30192: LD_VAR 0 9
30196: PUSH
30197: LD_VAR 0 3
30201: ARRAY
30202: DIFF
30203: ST_TO_ADDR
// end ;
30204: GO 30113
30206: POP
30207: POP
// if p then
30208: LD_VAR 0 11
30212: IFFALSE 30237
// result := Replace ( result , 2 , p ) ;
30214: LD_ADDR_VAR 0 2
30218: PUSH
30219: LD_VAR 0 2
30223: PPUSH
30224: LD_INT 2
30226: PPUSH
30227: LD_VAR 0 11
30231: PPUSH
30232: CALL_OW 1
30236: ST_TO_ADDR
// end ; exit ;
30237: GO 30961
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
30239: LD_EXP 105
30243: PUSH
30244: LD_EXP 104
30248: PUSH
30249: LD_VAR 0 1
30253: ARRAY
30254: ARRAY
30255: NOT
30256: PUSH
30257: LD_EXP 78
30261: PUSH
30262: LD_VAR 0 1
30266: ARRAY
30267: PPUSH
30268: LD_INT 30
30270: PUSH
30271: LD_INT 3
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PPUSH
30278: CALL_OW 72
30282: AND
30283: PUSH
30284: LD_EXP 83
30288: PUSH
30289: LD_VAR 0 1
30293: ARRAY
30294: NOT
30295: AND
30296: IFFALSE 30961
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
30298: LD_ADDR_EXP 120
30302: PUSH
30303: LD_EXP 120
30307: PPUSH
30308: LD_VAR 0 1
30312: PPUSH
30313: LD_INT 6
30315: PPUSH
30316: CALL_OW 1
30320: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
30321: LD_ADDR_VAR 0 2
30325: PUSH
30326: LD_INT 0
30328: PUSH
30329: LD_INT 0
30331: PUSH
30332: LD_INT 0
30334: PUSH
30335: LD_INT 0
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: LIST
30342: LIST
30343: ST_TO_ADDR
// if sci >= 1 then
30344: LD_VAR 0 8
30348: PUSH
30349: LD_INT 1
30351: GREATEREQUAL
30352: IFFALSE 30374
// tmp := tmp diff sci [ 1 ] ;
30354: LD_ADDR_VAR 0 4
30358: PUSH
30359: LD_VAR 0 4
30363: PUSH
30364: LD_VAR 0 8
30368: PUSH
30369: LD_INT 1
30371: ARRAY
30372: DIFF
30373: ST_TO_ADDR
// if tmp and not sci then
30374: LD_VAR 0 4
30378: PUSH
30379: LD_VAR 0 8
30383: NOT
30384: AND
30385: IFFALSE 30454
// begin sort := SortBySkill ( tmp , 4 ) ;
30387: LD_ADDR_VAR 0 9
30391: PUSH
30392: LD_VAR 0 4
30396: PPUSH
30397: LD_INT 4
30399: PPUSH
30400: CALL 89519 0 2
30404: ST_TO_ADDR
// if sort then
30405: LD_VAR 0 9
30409: IFFALSE 30425
// p := sort [ 1 ] ;
30411: LD_ADDR_VAR 0 11
30415: PUSH
30416: LD_VAR 0 9
30420: PUSH
30421: LD_INT 1
30423: ARRAY
30424: ST_TO_ADDR
// if p then
30425: LD_VAR 0 11
30429: IFFALSE 30454
// result := Replace ( result , 4 , p ) ;
30431: LD_ADDR_VAR 0 2
30435: PUSH
30436: LD_VAR 0 2
30440: PPUSH
30441: LD_INT 4
30443: PPUSH
30444: LD_VAR 0 11
30448: PPUSH
30449: CALL_OW 1
30453: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30454: LD_ADDR_VAR 0 4
30458: PUSH
30459: LD_VAR 0 4
30463: PUSH
30464: LD_VAR 0 7
30468: DIFF
30469: ST_TO_ADDR
// if tmp and mech < 6 then
30470: LD_VAR 0 4
30474: PUSH
30475: LD_VAR 0 7
30479: PUSH
30480: LD_INT 6
30482: LESS
30483: AND
30484: IFFALSE 30666
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
30486: LD_ADDR_VAR 0 9
30490: PUSH
30491: LD_VAR 0 4
30495: PUSH
30496: LD_VAR 0 7
30500: DIFF
30501: PPUSH
30502: LD_INT 3
30504: PPUSH
30505: CALL 89519 0 2
30509: ST_TO_ADDR
// p := [ ] ;
30510: LD_ADDR_VAR 0 11
30514: PUSH
30515: EMPTY
30516: ST_TO_ADDR
// if sort then
30517: LD_VAR 0 9
30521: IFFALSE 30637
// for i = 1 to 6 - mech do
30523: LD_ADDR_VAR 0 3
30527: PUSH
30528: DOUBLE
30529: LD_INT 1
30531: DEC
30532: ST_TO_ADDR
30533: LD_INT 6
30535: PUSH
30536: LD_VAR 0 7
30540: MINUS
30541: PUSH
30542: FOR_TO
30543: IFFALSE 30635
// begin if i = sort then
30545: LD_VAR 0 3
30549: PUSH
30550: LD_VAR 0 9
30554: EQUAL
30555: IFFALSE 30559
// break ;
30557: GO 30635
// if GetClass ( i ) = 3 then
30559: LD_VAR 0 3
30563: PPUSH
30564: CALL_OW 257
30568: PUSH
30569: LD_INT 3
30571: EQUAL
30572: IFFALSE 30576
// continue ;
30574: GO 30542
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30576: LD_ADDR_VAR 0 11
30580: PUSH
30581: LD_VAR 0 11
30585: PPUSH
30586: LD_VAR 0 11
30590: PUSH
30591: LD_INT 1
30593: PLUS
30594: PPUSH
30595: LD_VAR 0 9
30599: PUSH
30600: LD_VAR 0 3
30604: ARRAY
30605: PPUSH
30606: CALL_OW 2
30610: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30611: LD_ADDR_VAR 0 4
30615: PUSH
30616: LD_VAR 0 4
30620: PUSH
30621: LD_VAR 0 9
30625: PUSH
30626: LD_VAR 0 3
30630: ARRAY
30631: DIFF
30632: ST_TO_ADDR
// end ;
30633: GO 30542
30635: POP
30636: POP
// if p then
30637: LD_VAR 0 11
30641: IFFALSE 30666
// result := Replace ( result , 3 , p ) ;
30643: LD_ADDR_VAR 0 2
30647: PUSH
30648: LD_VAR 0 2
30652: PPUSH
30653: LD_INT 3
30655: PPUSH
30656: LD_VAR 0 11
30660: PPUSH
30661: CALL_OW 1
30665: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30666: LD_ADDR_VAR 0 4
30670: PUSH
30671: LD_VAR 0 4
30675: PUSH
30676: LD_VAR 0 6
30680: DIFF
30681: ST_TO_ADDR
// if tmp and eng < 4 then
30682: LD_VAR 0 4
30686: PUSH
30687: LD_VAR 0 6
30691: PUSH
30692: LD_INT 4
30694: LESS
30695: AND
30696: IFFALSE 30886
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
30698: LD_ADDR_VAR 0 9
30702: PUSH
30703: LD_VAR 0 4
30707: PUSH
30708: LD_VAR 0 7
30712: PUSH
30713: LD_VAR 0 6
30717: UNION
30718: DIFF
30719: PPUSH
30720: LD_INT 2
30722: PPUSH
30723: CALL 89519 0 2
30727: ST_TO_ADDR
// p := [ ] ;
30728: LD_ADDR_VAR 0 11
30732: PUSH
30733: EMPTY
30734: ST_TO_ADDR
// if sort then
30735: LD_VAR 0 9
30739: IFFALSE 30855
// for i = 1 to 4 - eng do
30741: LD_ADDR_VAR 0 3
30745: PUSH
30746: DOUBLE
30747: LD_INT 1
30749: DEC
30750: ST_TO_ADDR
30751: LD_INT 4
30753: PUSH
30754: LD_VAR 0 6
30758: MINUS
30759: PUSH
30760: FOR_TO
30761: IFFALSE 30853
// begin if i = sort then
30763: LD_VAR 0 3
30767: PUSH
30768: LD_VAR 0 9
30772: EQUAL
30773: IFFALSE 30777
// break ;
30775: GO 30853
// if GetClass ( i ) = 2 then
30777: LD_VAR 0 3
30781: PPUSH
30782: CALL_OW 257
30786: PUSH
30787: LD_INT 2
30789: EQUAL
30790: IFFALSE 30794
// continue ;
30792: GO 30760
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30794: LD_ADDR_VAR 0 11
30798: PUSH
30799: LD_VAR 0 11
30803: PPUSH
30804: LD_VAR 0 11
30808: PUSH
30809: LD_INT 1
30811: PLUS
30812: PPUSH
30813: LD_VAR 0 9
30817: PUSH
30818: LD_VAR 0 3
30822: ARRAY
30823: PPUSH
30824: CALL_OW 2
30828: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30829: LD_ADDR_VAR 0 4
30833: PUSH
30834: LD_VAR 0 4
30838: PUSH
30839: LD_VAR 0 9
30843: PUSH
30844: LD_VAR 0 3
30848: ARRAY
30849: DIFF
30850: ST_TO_ADDR
// end ;
30851: GO 30760
30853: POP
30854: POP
// if p then
30855: LD_VAR 0 11
30859: IFFALSE 30884
// result := Replace ( result , 2 , p ) ;
30861: LD_ADDR_VAR 0 2
30865: PUSH
30866: LD_VAR 0 2
30870: PPUSH
30871: LD_INT 2
30873: PPUSH
30874: LD_VAR 0 11
30878: PPUSH
30879: CALL_OW 1
30883: ST_TO_ADDR
// end else
30884: GO 30930
// for i = eng downto 5 do
30886: LD_ADDR_VAR 0 3
30890: PUSH
30891: DOUBLE
30892: LD_VAR 0 6
30896: INC
30897: ST_TO_ADDR
30898: LD_INT 5
30900: PUSH
30901: FOR_DOWNTO
30902: IFFALSE 30928
// tmp := tmp union eng [ i ] ;
30904: LD_ADDR_VAR 0 4
30908: PUSH
30909: LD_VAR 0 4
30913: PUSH
30914: LD_VAR 0 6
30918: PUSH
30919: LD_VAR 0 3
30923: ARRAY
30924: UNION
30925: ST_TO_ADDR
30926: GO 30901
30928: POP
30929: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
30930: LD_ADDR_VAR 0 2
30934: PUSH
30935: LD_VAR 0 2
30939: PPUSH
30940: LD_INT 1
30942: PPUSH
30943: LD_VAR 0 4
30947: PUSH
30948: LD_VAR 0 5
30952: DIFF
30953: PPUSH
30954: CALL_OW 1
30958: ST_TO_ADDR
// exit ;
30959: GO 30961
// end ; end ;
30961: LD_VAR 0 2
30965: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
30966: LD_INT 0
30968: PPUSH
30969: PPUSH
30970: PPUSH
// if not mc_bases then
30971: LD_EXP 78
30975: NOT
30976: IFFALSE 30980
// exit ;
30978: GO 31122
// for i = 1 to mc_bases do
30980: LD_ADDR_VAR 0 2
30984: PUSH
30985: DOUBLE
30986: LD_INT 1
30988: DEC
30989: ST_TO_ADDR
30990: LD_EXP 78
30994: PUSH
30995: FOR_TO
30996: IFFALSE 31113
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
30998: LD_ADDR_VAR 0 3
31002: PUSH
31003: LD_EXP 78
31007: PUSH
31008: LD_VAR 0 2
31012: ARRAY
31013: PPUSH
31014: LD_INT 21
31016: PUSH
31017: LD_INT 3
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: LD_INT 3
31026: PUSH
31027: LD_INT 2
31029: PUSH
31030: LD_INT 30
31032: PUSH
31033: LD_INT 29
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 30
31042: PUSH
31043: LD_INT 30
31045: PUSH
31046: EMPTY
31047: LIST
31048: LIST
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: LIST
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 3
31061: PUSH
31062: LD_INT 24
31064: PUSH
31065: LD_INT 1000
31067: PUSH
31068: EMPTY
31069: LIST
31070: LIST
31071: PUSH
31072: EMPTY
31073: LIST
31074: LIST
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: LIST
31080: PPUSH
31081: CALL_OW 72
31085: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
31086: LD_ADDR_EXP 79
31090: PUSH
31091: LD_EXP 79
31095: PPUSH
31096: LD_VAR 0 2
31100: PPUSH
31101: LD_VAR 0 3
31105: PPUSH
31106: CALL_OW 1
31110: ST_TO_ADDR
// end ;
31111: GO 30995
31113: POP
31114: POP
// RaiseSailEvent ( 101 ) ;
31115: LD_INT 101
31117: PPUSH
31118: CALL_OW 427
// end ;
31122: LD_VAR 0 1
31126: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
31127: LD_INT 0
31129: PPUSH
31130: PPUSH
31131: PPUSH
31132: PPUSH
31133: PPUSH
31134: PPUSH
31135: PPUSH
// if not mc_bases then
31136: LD_EXP 78
31140: NOT
31141: IFFALSE 31145
// exit ;
31143: GO 31707
// for i = 1 to mc_bases do
31145: LD_ADDR_VAR 0 2
31149: PUSH
31150: DOUBLE
31151: LD_INT 1
31153: DEC
31154: ST_TO_ADDR
31155: LD_EXP 78
31159: PUSH
31160: FOR_TO
31161: IFFALSE 31698
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
31163: LD_ADDR_VAR 0 5
31167: PUSH
31168: LD_EXP 78
31172: PUSH
31173: LD_VAR 0 2
31177: ARRAY
31178: PUSH
31179: LD_EXP 107
31183: PUSH
31184: LD_VAR 0 2
31188: ARRAY
31189: UNION
31190: PPUSH
31191: LD_INT 21
31193: PUSH
31194: LD_INT 1
31196: PUSH
31197: EMPTY
31198: LIST
31199: LIST
31200: PUSH
31201: LD_INT 1
31203: PUSH
31204: LD_INT 3
31206: PUSH
31207: LD_INT 54
31209: PUSH
31210: EMPTY
31211: LIST
31212: PUSH
31213: EMPTY
31214: LIST
31215: LIST
31216: PUSH
31217: LD_INT 3
31219: PUSH
31220: LD_INT 24
31222: PUSH
31223: LD_INT 1000
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: LIST
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PPUSH
31243: CALL_OW 72
31247: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
31248: LD_ADDR_VAR 0 6
31252: PUSH
31253: LD_EXP 78
31257: PUSH
31258: LD_VAR 0 2
31262: ARRAY
31263: PPUSH
31264: LD_INT 21
31266: PUSH
31267: LD_INT 1
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 1
31276: PUSH
31277: LD_INT 3
31279: PUSH
31280: LD_INT 54
31282: PUSH
31283: EMPTY
31284: LIST
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 3
31292: PUSH
31293: LD_INT 24
31295: PUSH
31296: LD_INT 250
31298: PUSH
31299: EMPTY
31300: LIST
31301: LIST
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: EMPTY
31308: LIST
31309: LIST
31310: LIST
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PPUSH
31316: CALL_OW 72
31320: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
31321: LD_ADDR_VAR 0 7
31325: PUSH
31326: LD_VAR 0 5
31330: PUSH
31331: LD_VAR 0 6
31335: DIFF
31336: ST_TO_ADDR
// if not need_heal_1 then
31337: LD_VAR 0 6
31341: NOT
31342: IFFALSE 31375
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
31344: LD_ADDR_EXP 81
31348: PUSH
31349: LD_EXP 81
31353: PPUSH
31354: LD_VAR 0 2
31358: PUSH
31359: LD_INT 1
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PPUSH
31366: EMPTY
31367: PPUSH
31368: CALL 58286 0 3
31372: ST_TO_ADDR
31373: GO 31445
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
31375: LD_ADDR_EXP 81
31379: PUSH
31380: LD_EXP 81
31384: PPUSH
31385: LD_VAR 0 2
31389: PUSH
31390: LD_INT 1
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PPUSH
31397: LD_EXP 81
31401: PUSH
31402: LD_VAR 0 2
31406: ARRAY
31407: PUSH
31408: LD_INT 1
31410: ARRAY
31411: PPUSH
31412: LD_INT 3
31414: PUSH
31415: LD_INT 24
31417: PUSH
31418: LD_INT 1000
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PPUSH
31429: CALL_OW 72
31433: PUSH
31434: LD_VAR 0 6
31438: UNION
31439: PPUSH
31440: CALL 58286 0 3
31444: ST_TO_ADDR
// if not need_heal_2 then
31445: LD_VAR 0 7
31449: NOT
31450: IFFALSE 31483
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
31452: LD_ADDR_EXP 81
31456: PUSH
31457: LD_EXP 81
31461: PPUSH
31462: LD_VAR 0 2
31466: PUSH
31467: LD_INT 2
31469: PUSH
31470: EMPTY
31471: LIST
31472: LIST
31473: PPUSH
31474: EMPTY
31475: PPUSH
31476: CALL 58286 0 3
31480: ST_TO_ADDR
31481: GO 31515
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
31483: LD_ADDR_EXP 81
31487: PUSH
31488: LD_EXP 81
31492: PPUSH
31493: LD_VAR 0 2
31497: PUSH
31498: LD_INT 2
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PPUSH
31505: LD_VAR 0 7
31509: PPUSH
31510: CALL 58286 0 3
31514: ST_TO_ADDR
// if need_heal_2 then
31515: LD_VAR 0 7
31519: IFFALSE 31680
// for j in need_heal_2 do
31521: LD_ADDR_VAR 0 3
31525: PUSH
31526: LD_VAR 0 7
31530: PUSH
31531: FOR_IN
31532: IFFALSE 31678
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31534: LD_ADDR_VAR 0 5
31538: PUSH
31539: LD_EXP 78
31543: PUSH
31544: LD_VAR 0 2
31548: ARRAY
31549: PPUSH
31550: LD_INT 2
31552: PUSH
31553: LD_INT 30
31555: PUSH
31556: LD_INT 6
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 30
31565: PUSH
31566: LD_INT 7
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 30
31575: PUSH
31576: LD_INT 8
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 30
31585: PUSH
31586: LD_INT 0
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 30
31595: PUSH
31596: LD_INT 1
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: EMPTY
31604: LIST
31605: LIST
31606: LIST
31607: LIST
31608: LIST
31609: LIST
31610: PPUSH
31611: CALL_OW 72
31615: ST_TO_ADDR
// if tmp then
31616: LD_VAR 0 5
31620: IFFALSE 31676
// begin k := NearestUnitToUnit ( tmp , j ) ;
31622: LD_ADDR_VAR 0 4
31626: PUSH
31627: LD_VAR 0 5
31631: PPUSH
31632: LD_VAR 0 3
31636: PPUSH
31637: CALL_OW 74
31641: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
31642: LD_VAR 0 3
31646: PPUSH
31647: LD_VAR 0 4
31651: PPUSH
31652: CALL_OW 296
31656: PUSH
31657: LD_INT 5
31659: GREATER
31660: IFFALSE 31676
// ComMoveToNearbyEntrance ( j , k ) ;
31662: LD_VAR 0 3
31666: PPUSH
31667: LD_VAR 0 4
31671: PPUSH
31672: CALL 91892 0 2
// end ; end ;
31676: GO 31531
31678: POP
31679: POP
// if not need_heal_1 and not need_heal_2 then
31680: LD_VAR 0 6
31684: NOT
31685: PUSH
31686: LD_VAR 0 7
31690: NOT
31691: AND
31692: IFFALSE 31696
// continue ;
31694: GO 31160
// end ;
31696: GO 31160
31698: POP
31699: POP
// RaiseSailEvent ( 102 ) ;
31700: LD_INT 102
31702: PPUSH
31703: CALL_OW 427
// end ;
31707: LD_VAR 0 1
31711: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
31712: LD_INT 0
31714: PPUSH
31715: PPUSH
31716: PPUSH
31717: PPUSH
31718: PPUSH
31719: PPUSH
31720: PPUSH
31721: PPUSH
// if not mc_bases then
31722: LD_EXP 78
31726: NOT
31727: IFFALSE 31731
// exit ;
31729: GO 32642
// for i = 1 to mc_bases do
31731: LD_ADDR_VAR 0 2
31735: PUSH
31736: DOUBLE
31737: LD_INT 1
31739: DEC
31740: ST_TO_ADDR
31741: LD_EXP 78
31745: PUSH
31746: FOR_TO
31747: IFFALSE 32640
// begin if not mc_building_need_repair [ i ] then
31749: LD_EXP 79
31753: PUSH
31754: LD_VAR 0 2
31758: ARRAY
31759: NOT
31760: IFFALSE 31945
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
31762: LD_ADDR_VAR 0 6
31766: PUSH
31767: LD_EXP 97
31771: PUSH
31772: LD_VAR 0 2
31776: ARRAY
31777: PPUSH
31778: LD_INT 3
31780: PUSH
31781: LD_INT 24
31783: PUSH
31784: LD_INT 1000
31786: PUSH
31787: EMPTY
31788: LIST
31789: LIST
31790: PUSH
31791: EMPTY
31792: LIST
31793: LIST
31794: PUSH
31795: LD_INT 2
31797: PUSH
31798: LD_INT 34
31800: PUSH
31801: LD_INT 13
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 34
31810: PUSH
31811: LD_INT 52
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 34
31820: PUSH
31821: LD_INT 88
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PPUSH
31838: CALL_OW 72
31842: ST_TO_ADDR
// if cranes then
31843: LD_VAR 0 6
31847: IFFALSE 31909
// for j in cranes do
31849: LD_ADDR_VAR 0 3
31853: PUSH
31854: LD_VAR 0 6
31858: PUSH
31859: FOR_IN
31860: IFFALSE 31907
// if not IsInArea ( j , mc_parking [ i ] ) then
31862: LD_VAR 0 3
31866: PPUSH
31867: LD_EXP 102
31871: PUSH
31872: LD_VAR 0 2
31876: ARRAY
31877: PPUSH
31878: CALL_OW 308
31882: NOT
31883: IFFALSE 31905
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31885: LD_VAR 0 3
31889: PPUSH
31890: LD_EXP 102
31894: PUSH
31895: LD_VAR 0 2
31899: ARRAY
31900: PPUSH
31901: CALL_OW 113
31905: GO 31859
31907: POP
31908: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
31909: LD_ADDR_EXP 80
31913: PUSH
31914: LD_EXP 80
31918: PPUSH
31919: LD_VAR 0 2
31923: PPUSH
31924: EMPTY
31925: PPUSH
31926: CALL_OW 1
31930: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
31931: LD_VAR 0 2
31935: PPUSH
31936: LD_INT 101
31938: PPUSH
31939: CALL 26785 0 2
// continue ;
31943: GO 31746
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
31945: LD_ADDR_EXP 84
31949: PUSH
31950: LD_EXP 84
31954: PPUSH
31955: LD_VAR 0 2
31959: PPUSH
31960: EMPTY
31961: PPUSH
31962: CALL_OW 1
31966: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31967: LD_VAR 0 2
31971: PPUSH
31972: LD_INT 103
31974: PPUSH
31975: CALL 26785 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
31979: LD_ADDR_VAR 0 5
31983: PUSH
31984: LD_EXP 78
31988: PUSH
31989: LD_VAR 0 2
31993: ARRAY
31994: PUSH
31995: LD_EXP 107
31999: PUSH
32000: LD_VAR 0 2
32004: ARRAY
32005: UNION
32006: PPUSH
32007: LD_INT 2
32009: PUSH
32010: LD_INT 25
32012: PUSH
32013: LD_INT 2
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 25
32022: PUSH
32023: LD_INT 16
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: LIST
32034: PUSH
32035: EMPTY
32036: LIST
32037: PPUSH
32038: CALL_OW 72
32042: ST_TO_ADDR
// if mc_need_heal [ i ] then
32043: LD_EXP 81
32047: PUSH
32048: LD_VAR 0 2
32052: ARRAY
32053: IFFALSE 32097
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
32055: LD_ADDR_VAR 0 5
32059: PUSH
32060: LD_VAR 0 5
32064: PUSH
32065: LD_EXP 81
32069: PUSH
32070: LD_VAR 0 2
32074: ARRAY
32075: PUSH
32076: LD_INT 1
32078: ARRAY
32079: PUSH
32080: LD_EXP 81
32084: PUSH
32085: LD_VAR 0 2
32089: ARRAY
32090: PUSH
32091: LD_INT 2
32093: ARRAY
32094: UNION
32095: DIFF
32096: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
32097: LD_ADDR_VAR 0 6
32101: PUSH
32102: LD_EXP 97
32106: PUSH
32107: LD_VAR 0 2
32111: ARRAY
32112: PPUSH
32113: LD_INT 2
32115: PUSH
32116: LD_INT 34
32118: PUSH
32119: LD_INT 13
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 34
32128: PUSH
32129: LD_INT 52
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 34
32138: PUSH
32139: LD_INT 88
32141: PUSH
32142: EMPTY
32143: LIST
32144: LIST
32145: PUSH
32146: EMPTY
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: PPUSH
32152: CALL_OW 72
32156: ST_TO_ADDR
// if cranes then
32157: LD_VAR 0 6
32161: IFFALSE 32329
// begin for j in cranes do
32163: LD_ADDR_VAR 0 3
32167: PUSH
32168: LD_VAR 0 6
32172: PUSH
32173: FOR_IN
32174: IFFALSE 32327
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
32176: LD_VAR 0 3
32180: PPUSH
32181: CALL_OW 256
32185: PUSH
32186: LD_INT 1000
32188: EQUAL
32189: PUSH
32190: LD_VAR 0 3
32194: PPUSH
32195: CALL_OW 314
32199: NOT
32200: AND
32201: IFFALSE 32267
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
32203: LD_ADDR_VAR 0 8
32207: PUSH
32208: LD_EXP 79
32212: PUSH
32213: LD_VAR 0 2
32217: ARRAY
32218: PPUSH
32219: LD_VAR 0 3
32223: PPUSH
32224: CALL_OW 74
32228: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
32229: LD_VAR 0 8
32233: PPUSH
32234: LD_INT 16
32236: PPUSH
32237: CALL 61251 0 2
32241: PUSH
32242: LD_INT 4
32244: ARRAY
32245: PUSH
32246: LD_INT 10
32248: LESS
32249: IFFALSE 32265
// ComRepairBuilding ( j , to_repair ) ;
32251: LD_VAR 0 3
32255: PPUSH
32256: LD_VAR 0 8
32260: PPUSH
32261: CALL_OW 130
// end else
32265: GO 32325
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
32267: LD_VAR 0 3
32271: PPUSH
32272: CALL_OW 256
32276: PUSH
32277: LD_INT 500
32279: LESS
32280: PUSH
32281: LD_VAR 0 3
32285: PPUSH
32286: LD_EXP 102
32290: PUSH
32291: LD_VAR 0 2
32295: ARRAY
32296: PPUSH
32297: CALL_OW 308
32301: NOT
32302: AND
32303: IFFALSE 32325
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32305: LD_VAR 0 3
32309: PPUSH
32310: LD_EXP 102
32314: PUSH
32315: LD_VAR 0 2
32319: ARRAY
32320: PPUSH
32321: CALL_OW 113
// end ;
32325: GO 32173
32327: POP
32328: POP
// end ; if tmp > 3 then
32329: LD_VAR 0 5
32333: PUSH
32334: LD_INT 3
32336: GREATER
32337: IFFALSE 32357
// tmp := ShrinkArray ( tmp , 4 ) ;
32339: LD_ADDR_VAR 0 5
32343: PUSH
32344: LD_VAR 0 5
32348: PPUSH
32349: LD_INT 4
32351: PPUSH
32352: CALL 91330 0 2
32356: ST_TO_ADDR
// if not tmp then
32357: LD_VAR 0 5
32361: NOT
32362: IFFALSE 32366
// continue ;
32364: GO 31746
// for j in tmp do
32366: LD_ADDR_VAR 0 3
32370: PUSH
32371: LD_VAR 0 5
32375: PUSH
32376: FOR_IN
32377: IFFALSE 32636
// begin if IsInUnit ( j ) then
32379: LD_VAR 0 3
32383: PPUSH
32384: CALL_OW 310
32388: IFFALSE 32399
// ComExitBuilding ( j ) ;
32390: LD_VAR 0 3
32394: PPUSH
32395: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
32399: LD_VAR 0 3
32403: PUSH
32404: LD_EXP 80
32408: PUSH
32409: LD_VAR 0 2
32413: ARRAY
32414: IN
32415: NOT
32416: IFFALSE 32474
// begin SetTag ( j , 101 ) ;
32418: LD_VAR 0 3
32422: PPUSH
32423: LD_INT 101
32425: PPUSH
32426: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
32430: LD_ADDR_EXP 80
32434: PUSH
32435: LD_EXP 80
32439: PPUSH
32440: LD_VAR 0 2
32444: PUSH
32445: LD_EXP 80
32449: PUSH
32450: LD_VAR 0 2
32454: ARRAY
32455: PUSH
32456: LD_INT 1
32458: PLUS
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PPUSH
32464: LD_VAR 0 3
32468: PPUSH
32469: CALL 58286 0 3
32473: ST_TO_ADDR
// end ; wait ( 1 ) ;
32474: LD_INT 1
32476: PPUSH
32477: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
32481: LD_ADDR_VAR 0 7
32485: PUSH
32486: LD_EXP 79
32490: PUSH
32491: LD_VAR 0 2
32495: ARRAY
32496: ST_TO_ADDR
// if mc_scan [ i ] then
32497: LD_EXP 101
32501: PUSH
32502: LD_VAR 0 2
32506: ARRAY
32507: IFFALSE 32569
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
32509: LD_ADDR_VAR 0 7
32513: PUSH
32514: LD_EXP 79
32518: PUSH
32519: LD_VAR 0 2
32523: ARRAY
32524: PPUSH
32525: LD_INT 3
32527: PUSH
32528: LD_INT 30
32530: PUSH
32531: LD_INT 32
32533: PUSH
32534: EMPTY
32535: LIST
32536: LIST
32537: PUSH
32538: LD_INT 30
32540: PUSH
32541: LD_INT 33
32543: PUSH
32544: EMPTY
32545: LIST
32546: LIST
32547: PUSH
32548: LD_INT 30
32550: PUSH
32551: LD_INT 31
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: LIST
32562: LIST
32563: PPUSH
32564: CALL_OW 72
32568: ST_TO_ADDR
// if not to_repair_tmp then
32569: LD_VAR 0 7
32573: NOT
32574: IFFALSE 32578
// continue ;
32576: GO 32376
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32578: LD_ADDR_VAR 0 8
32582: PUSH
32583: LD_VAR 0 7
32587: PPUSH
32588: LD_VAR 0 3
32592: PPUSH
32593: CALL_OW 74
32597: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
32598: LD_VAR 0 8
32602: PPUSH
32603: LD_INT 16
32605: PPUSH
32606: CALL 61251 0 2
32610: PUSH
32611: LD_INT 4
32613: ARRAY
32614: PUSH
32615: LD_INT 14
32617: LESS
32618: IFFALSE 32634
// ComRepairBuilding ( j , to_repair ) ;
32620: LD_VAR 0 3
32624: PPUSH
32625: LD_VAR 0 8
32629: PPUSH
32630: CALL_OW 130
// end ;
32634: GO 32376
32636: POP
32637: POP
// end ;
32638: GO 31746
32640: POP
32641: POP
// end ;
32642: LD_VAR 0 1
32646: RET
// export function MC_Heal ; var i , j , tmp ; begin
32647: LD_INT 0
32649: PPUSH
32650: PPUSH
32651: PPUSH
32652: PPUSH
// if not mc_bases then
32653: LD_EXP 78
32657: NOT
32658: IFFALSE 32662
// exit ;
32660: GO 33064
// for i = 1 to mc_bases do
32662: LD_ADDR_VAR 0 2
32666: PUSH
32667: DOUBLE
32668: LD_INT 1
32670: DEC
32671: ST_TO_ADDR
32672: LD_EXP 78
32676: PUSH
32677: FOR_TO
32678: IFFALSE 33062
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
32680: LD_EXP 81
32684: PUSH
32685: LD_VAR 0 2
32689: ARRAY
32690: PUSH
32691: LD_INT 1
32693: ARRAY
32694: NOT
32695: PUSH
32696: LD_EXP 81
32700: PUSH
32701: LD_VAR 0 2
32705: ARRAY
32706: PUSH
32707: LD_INT 2
32709: ARRAY
32710: NOT
32711: AND
32712: IFFALSE 32750
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
32714: LD_ADDR_EXP 82
32718: PUSH
32719: LD_EXP 82
32723: PPUSH
32724: LD_VAR 0 2
32728: PPUSH
32729: EMPTY
32730: PPUSH
32731: CALL_OW 1
32735: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
32736: LD_VAR 0 2
32740: PPUSH
32741: LD_INT 102
32743: PPUSH
32744: CALL 26785 0 2
// continue ;
32748: GO 32677
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
32750: LD_ADDR_VAR 0 4
32754: PUSH
32755: LD_EXP 78
32759: PUSH
32760: LD_VAR 0 2
32764: ARRAY
32765: PPUSH
32766: LD_INT 25
32768: PUSH
32769: LD_INT 4
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PPUSH
32776: CALL_OW 72
32780: ST_TO_ADDR
// if not tmp then
32781: LD_VAR 0 4
32785: NOT
32786: IFFALSE 32790
// continue ;
32788: GO 32677
// if mc_taming [ i ] then
32790: LD_EXP 109
32794: PUSH
32795: LD_VAR 0 2
32799: ARRAY
32800: IFFALSE 32824
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
32802: LD_ADDR_EXP 109
32806: PUSH
32807: LD_EXP 109
32811: PPUSH
32812: LD_VAR 0 2
32816: PPUSH
32817: EMPTY
32818: PPUSH
32819: CALL_OW 1
32823: ST_TO_ADDR
// for j in tmp do
32824: LD_ADDR_VAR 0 3
32828: PUSH
32829: LD_VAR 0 4
32833: PUSH
32834: FOR_IN
32835: IFFALSE 33058
// begin if IsInUnit ( j ) then
32837: LD_VAR 0 3
32841: PPUSH
32842: CALL_OW 310
32846: IFFALSE 32857
// ComExitBuilding ( j ) ;
32848: LD_VAR 0 3
32852: PPUSH
32853: CALL_OW 122
// if not j in mc_healers [ i ] then
32857: LD_VAR 0 3
32861: PUSH
32862: LD_EXP 82
32866: PUSH
32867: LD_VAR 0 2
32871: ARRAY
32872: IN
32873: NOT
32874: IFFALSE 32920
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
32876: LD_ADDR_EXP 82
32880: PUSH
32881: LD_EXP 82
32885: PPUSH
32886: LD_VAR 0 2
32890: PUSH
32891: LD_EXP 82
32895: PUSH
32896: LD_VAR 0 2
32900: ARRAY
32901: PUSH
32902: LD_INT 1
32904: PLUS
32905: PUSH
32906: EMPTY
32907: LIST
32908: LIST
32909: PPUSH
32910: LD_VAR 0 3
32914: PPUSH
32915: CALL 58286 0 3
32919: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
32920: LD_VAR 0 3
32924: PPUSH
32925: CALL_OW 110
32929: PUSH
32930: LD_INT 102
32932: NONEQUAL
32933: IFFALSE 32947
// SetTag ( j , 102 ) ;
32935: LD_VAR 0 3
32939: PPUSH
32940: LD_INT 102
32942: PPUSH
32943: CALL_OW 109
// Wait ( 3 ) ;
32947: LD_INT 3
32949: PPUSH
32950: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
32954: LD_EXP 81
32958: PUSH
32959: LD_VAR 0 2
32963: ARRAY
32964: PUSH
32965: LD_INT 1
32967: ARRAY
32968: IFFALSE 33000
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
32970: LD_VAR 0 3
32974: PPUSH
32975: LD_EXP 81
32979: PUSH
32980: LD_VAR 0 2
32984: ARRAY
32985: PUSH
32986: LD_INT 1
32988: ARRAY
32989: PUSH
32990: LD_INT 1
32992: ARRAY
32993: PPUSH
32994: CALL_OW 128
32998: GO 33056
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
33000: LD_VAR 0 3
33004: PPUSH
33005: CALL_OW 314
33009: NOT
33010: PUSH
33011: LD_EXP 81
33015: PUSH
33016: LD_VAR 0 2
33020: ARRAY
33021: PUSH
33022: LD_INT 2
33024: ARRAY
33025: AND
33026: IFFALSE 33056
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
33028: LD_VAR 0 3
33032: PPUSH
33033: LD_EXP 81
33037: PUSH
33038: LD_VAR 0 2
33042: ARRAY
33043: PUSH
33044: LD_INT 2
33046: ARRAY
33047: PUSH
33048: LD_INT 1
33050: ARRAY
33051: PPUSH
33052: CALL_OW 128
// end ;
33056: GO 32834
33058: POP
33059: POP
// end ;
33060: GO 32677
33062: POP
33063: POP
// end ;
33064: LD_VAR 0 1
33068: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
33069: LD_INT 0
33071: PPUSH
33072: PPUSH
33073: PPUSH
33074: PPUSH
33075: PPUSH
33076: PPUSH
// if not mc_bases then
33077: LD_EXP 78
33081: NOT
33082: IFFALSE 33086
// exit ;
33084: GO 34249
// for i = 1 to mc_bases do
33086: LD_ADDR_VAR 0 2
33090: PUSH
33091: DOUBLE
33092: LD_INT 1
33094: DEC
33095: ST_TO_ADDR
33096: LD_EXP 78
33100: PUSH
33101: FOR_TO
33102: IFFALSE 34247
// begin if mc_scan [ i ] then
33104: LD_EXP 101
33108: PUSH
33109: LD_VAR 0 2
33113: ARRAY
33114: IFFALSE 33118
// continue ;
33116: GO 33101
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
33118: LD_EXP 83
33122: PUSH
33123: LD_VAR 0 2
33127: ARRAY
33128: NOT
33129: PUSH
33130: LD_EXP 85
33134: PUSH
33135: LD_VAR 0 2
33139: ARRAY
33140: NOT
33141: AND
33142: PUSH
33143: LD_EXP 84
33147: PUSH
33148: LD_VAR 0 2
33152: ARRAY
33153: AND
33154: IFFALSE 33192
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
33156: LD_ADDR_EXP 84
33160: PUSH
33161: LD_EXP 84
33165: PPUSH
33166: LD_VAR 0 2
33170: PPUSH
33171: EMPTY
33172: PPUSH
33173: CALL_OW 1
33177: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
33178: LD_VAR 0 2
33182: PPUSH
33183: LD_INT 103
33185: PPUSH
33186: CALL 26785 0 2
// continue ;
33190: GO 33101
// end ; if mc_construct_list [ i ] then
33192: LD_EXP 85
33196: PUSH
33197: LD_VAR 0 2
33201: ARRAY
33202: IFFALSE 33422
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33204: LD_ADDR_VAR 0 5
33208: PUSH
33209: LD_EXP 78
33213: PUSH
33214: LD_VAR 0 2
33218: ARRAY
33219: PPUSH
33220: LD_INT 25
33222: PUSH
33223: LD_INT 2
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PPUSH
33230: CALL_OW 72
33234: PUSH
33235: LD_EXP 80
33239: PUSH
33240: LD_VAR 0 2
33244: ARRAY
33245: DIFF
33246: ST_TO_ADDR
// if not tmp then
33247: LD_VAR 0 5
33251: NOT
33252: IFFALSE 33256
// continue ;
33254: GO 33101
// for j in tmp do
33256: LD_ADDR_VAR 0 3
33260: PUSH
33261: LD_VAR 0 5
33265: PUSH
33266: FOR_IN
33267: IFFALSE 33418
// begin if not mc_builders [ i ] then
33269: LD_EXP 84
33273: PUSH
33274: LD_VAR 0 2
33278: ARRAY
33279: NOT
33280: IFFALSE 33338
// begin SetTag ( j , 103 ) ;
33282: LD_VAR 0 3
33286: PPUSH
33287: LD_INT 103
33289: PPUSH
33290: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33294: LD_ADDR_EXP 84
33298: PUSH
33299: LD_EXP 84
33303: PPUSH
33304: LD_VAR 0 2
33308: PUSH
33309: LD_EXP 84
33313: PUSH
33314: LD_VAR 0 2
33318: ARRAY
33319: PUSH
33320: LD_INT 1
33322: PLUS
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PPUSH
33328: LD_VAR 0 3
33332: PPUSH
33333: CALL 58286 0 3
33337: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33338: LD_VAR 0 3
33342: PPUSH
33343: CALL_OW 310
33347: IFFALSE 33358
// ComExitBuilding ( j ) ;
33349: LD_VAR 0 3
33353: PPUSH
33354: CALL_OW 122
// wait ( 3 ) ;
33358: LD_INT 3
33360: PPUSH
33361: CALL_OW 67
// if not mc_construct_list [ i ] then
33365: LD_EXP 85
33369: PUSH
33370: LD_VAR 0 2
33374: ARRAY
33375: NOT
33376: IFFALSE 33380
// break ;
33378: GO 33418
// if not HasTask ( j ) then
33380: LD_VAR 0 3
33384: PPUSH
33385: CALL_OW 314
33389: NOT
33390: IFFALSE 33416
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
33392: LD_VAR 0 3
33396: PPUSH
33397: LD_EXP 85
33401: PUSH
33402: LD_VAR 0 2
33406: ARRAY
33407: PUSH
33408: LD_INT 1
33410: ARRAY
33411: PPUSH
33412: CALL 61524 0 2
// end ;
33416: GO 33266
33418: POP
33419: POP
// end else
33420: GO 34245
// if mc_build_list [ i ] then
33422: LD_EXP 83
33426: PUSH
33427: LD_VAR 0 2
33431: ARRAY
33432: IFFALSE 34245
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
33434: LD_EXP 83
33438: PUSH
33439: LD_VAR 0 2
33443: ARRAY
33444: PUSH
33445: LD_INT 1
33447: ARRAY
33448: PUSH
33449: LD_INT 1
33451: ARRAY
33452: PPUSH
33453: CALL 61348 0 1
33457: PUSH
33458: LD_EXP 78
33462: PUSH
33463: LD_VAR 0 2
33467: ARRAY
33468: PPUSH
33469: LD_INT 2
33471: PUSH
33472: LD_INT 30
33474: PUSH
33475: LD_INT 2
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 30
33484: PUSH
33485: LD_INT 3
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: LIST
33496: PPUSH
33497: CALL_OW 72
33501: NOT
33502: AND
33503: IFFALSE 33608
// begin for j = 1 to mc_build_list [ i ] do
33505: LD_ADDR_VAR 0 3
33509: PUSH
33510: DOUBLE
33511: LD_INT 1
33513: DEC
33514: ST_TO_ADDR
33515: LD_EXP 83
33519: PUSH
33520: LD_VAR 0 2
33524: ARRAY
33525: PUSH
33526: FOR_TO
33527: IFFALSE 33606
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33529: LD_EXP 83
33533: PUSH
33534: LD_VAR 0 2
33538: ARRAY
33539: PUSH
33540: LD_VAR 0 3
33544: ARRAY
33545: PUSH
33546: LD_INT 1
33548: ARRAY
33549: PUSH
33550: LD_INT 2
33552: EQUAL
33553: IFFALSE 33604
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33555: LD_ADDR_EXP 83
33559: PUSH
33560: LD_EXP 83
33564: PPUSH
33565: LD_VAR 0 2
33569: PPUSH
33570: LD_EXP 83
33574: PUSH
33575: LD_VAR 0 2
33579: ARRAY
33580: PPUSH
33581: LD_VAR 0 3
33585: PPUSH
33586: LD_INT 1
33588: PPUSH
33589: LD_INT 0
33591: PPUSH
33592: CALL 57704 0 4
33596: PPUSH
33597: CALL_OW 1
33601: ST_TO_ADDR
// break ;
33602: GO 33606
// end ;
33604: GO 33526
33606: POP
33607: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33608: LD_ADDR_VAR 0 6
33612: PUSH
33613: LD_EXP 78
33617: PUSH
33618: LD_VAR 0 2
33622: ARRAY
33623: PPUSH
33624: LD_INT 2
33626: PUSH
33627: LD_INT 30
33629: PUSH
33630: LD_INT 0
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 30
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: EMPTY
33648: LIST
33649: LIST
33650: LIST
33651: PPUSH
33652: CALL_OW 72
33656: ST_TO_ADDR
// for k := 1 to depot do
33657: LD_ADDR_VAR 0 4
33661: PUSH
33662: DOUBLE
33663: LD_INT 1
33665: DEC
33666: ST_TO_ADDR
33667: LD_VAR 0 6
33671: PUSH
33672: FOR_TO
33673: IFFALSE 34243
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
33675: LD_EXP 83
33679: PUSH
33680: LD_VAR 0 2
33684: ARRAY
33685: PUSH
33686: LD_INT 1
33688: ARRAY
33689: PUSH
33690: LD_INT 1
33692: ARRAY
33693: PUSH
33694: LD_INT 0
33696: EQUAL
33697: PUSH
33698: LD_VAR 0 6
33702: PUSH
33703: LD_VAR 0 4
33707: ARRAY
33708: PPUSH
33709: LD_EXP 83
33713: PUSH
33714: LD_VAR 0 2
33718: ARRAY
33719: PUSH
33720: LD_INT 1
33722: ARRAY
33723: PUSH
33724: LD_INT 1
33726: ARRAY
33727: PPUSH
33728: LD_EXP 83
33732: PUSH
33733: LD_VAR 0 2
33737: ARRAY
33738: PUSH
33739: LD_INT 1
33741: ARRAY
33742: PUSH
33743: LD_INT 2
33745: ARRAY
33746: PPUSH
33747: LD_EXP 83
33751: PUSH
33752: LD_VAR 0 2
33756: ARRAY
33757: PUSH
33758: LD_INT 1
33760: ARRAY
33761: PUSH
33762: LD_INT 3
33764: ARRAY
33765: PPUSH
33766: LD_EXP 83
33770: PUSH
33771: LD_VAR 0 2
33775: ARRAY
33776: PUSH
33777: LD_INT 1
33779: ARRAY
33780: PUSH
33781: LD_INT 4
33783: ARRAY
33784: PPUSH
33785: CALL 66760 0 5
33789: OR
33790: IFFALSE 34071
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33792: LD_ADDR_VAR 0 5
33796: PUSH
33797: LD_EXP 78
33801: PUSH
33802: LD_VAR 0 2
33806: ARRAY
33807: PPUSH
33808: LD_INT 25
33810: PUSH
33811: LD_INT 2
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PPUSH
33818: CALL_OW 72
33822: PUSH
33823: LD_EXP 80
33827: PUSH
33828: LD_VAR 0 2
33832: ARRAY
33833: DIFF
33834: ST_TO_ADDR
// if not tmp then
33835: LD_VAR 0 5
33839: NOT
33840: IFFALSE 33844
// continue ;
33842: GO 33672
// for j in tmp do
33844: LD_ADDR_VAR 0 3
33848: PUSH
33849: LD_VAR 0 5
33853: PUSH
33854: FOR_IN
33855: IFFALSE 34067
// begin if not mc_builders [ i ] then
33857: LD_EXP 84
33861: PUSH
33862: LD_VAR 0 2
33866: ARRAY
33867: NOT
33868: IFFALSE 33926
// begin SetTag ( j , 103 ) ;
33870: LD_VAR 0 3
33874: PPUSH
33875: LD_INT 103
33877: PPUSH
33878: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33882: LD_ADDR_EXP 84
33886: PUSH
33887: LD_EXP 84
33891: PPUSH
33892: LD_VAR 0 2
33896: PUSH
33897: LD_EXP 84
33901: PUSH
33902: LD_VAR 0 2
33906: ARRAY
33907: PUSH
33908: LD_INT 1
33910: PLUS
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PPUSH
33916: LD_VAR 0 3
33920: PPUSH
33921: CALL 58286 0 3
33925: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33926: LD_VAR 0 3
33930: PPUSH
33931: CALL_OW 310
33935: IFFALSE 33946
// ComExitBuilding ( j ) ;
33937: LD_VAR 0 3
33941: PPUSH
33942: CALL_OW 122
// wait ( 3 ) ;
33946: LD_INT 3
33948: PPUSH
33949: CALL_OW 67
// if not mc_build_list [ i ] then
33953: LD_EXP 83
33957: PUSH
33958: LD_VAR 0 2
33962: ARRAY
33963: NOT
33964: IFFALSE 33968
// break ;
33966: GO 34067
// if not HasTask ( j ) then
33968: LD_VAR 0 3
33972: PPUSH
33973: CALL_OW 314
33977: NOT
33978: IFFALSE 34065
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
33980: LD_VAR 0 3
33984: PPUSH
33985: LD_EXP 83
33989: PUSH
33990: LD_VAR 0 2
33994: ARRAY
33995: PUSH
33996: LD_INT 1
33998: ARRAY
33999: PUSH
34000: LD_INT 1
34002: ARRAY
34003: PPUSH
34004: LD_EXP 83
34008: PUSH
34009: LD_VAR 0 2
34013: ARRAY
34014: PUSH
34015: LD_INT 1
34017: ARRAY
34018: PUSH
34019: LD_INT 2
34021: ARRAY
34022: PPUSH
34023: LD_EXP 83
34027: PUSH
34028: LD_VAR 0 2
34032: ARRAY
34033: PUSH
34034: LD_INT 1
34036: ARRAY
34037: PUSH
34038: LD_INT 3
34040: ARRAY
34041: PPUSH
34042: LD_EXP 83
34046: PUSH
34047: LD_VAR 0 2
34051: ARRAY
34052: PUSH
34053: LD_INT 1
34055: ARRAY
34056: PUSH
34057: LD_INT 4
34059: ARRAY
34060: PPUSH
34061: CALL_OW 145
// end ;
34065: GO 33854
34067: POP
34068: POP
// end else
34069: GO 34241
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
34071: LD_EXP 78
34075: PUSH
34076: LD_VAR 0 2
34080: ARRAY
34081: PPUSH
34082: LD_EXP 83
34086: PUSH
34087: LD_VAR 0 2
34091: ARRAY
34092: PUSH
34093: LD_INT 1
34095: ARRAY
34096: PUSH
34097: LD_INT 1
34099: ARRAY
34100: PPUSH
34101: LD_EXP 83
34105: PUSH
34106: LD_VAR 0 2
34110: ARRAY
34111: PUSH
34112: LD_INT 1
34114: ARRAY
34115: PUSH
34116: LD_INT 2
34118: ARRAY
34119: PPUSH
34120: LD_EXP 83
34124: PUSH
34125: LD_VAR 0 2
34129: ARRAY
34130: PUSH
34131: LD_INT 1
34133: ARRAY
34134: PUSH
34135: LD_INT 3
34137: ARRAY
34138: PPUSH
34139: LD_EXP 83
34143: PUSH
34144: LD_VAR 0 2
34148: ARRAY
34149: PUSH
34150: LD_INT 1
34152: ARRAY
34153: PUSH
34154: LD_INT 4
34156: ARRAY
34157: PPUSH
34158: LD_EXP 78
34162: PUSH
34163: LD_VAR 0 2
34167: ARRAY
34168: PPUSH
34169: LD_INT 21
34171: PUSH
34172: LD_INT 3
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PPUSH
34179: CALL_OW 72
34183: PPUSH
34184: EMPTY
34185: PPUSH
34186: CALL 65514 0 7
34190: NOT
34191: IFFALSE 34241
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
34193: LD_ADDR_EXP 83
34197: PUSH
34198: LD_EXP 83
34202: PPUSH
34203: LD_VAR 0 2
34207: PPUSH
34208: LD_EXP 83
34212: PUSH
34213: LD_VAR 0 2
34217: ARRAY
34218: PPUSH
34219: LD_INT 1
34221: PPUSH
34222: LD_INT 1
34224: NEG
34225: PPUSH
34226: LD_INT 0
34228: PPUSH
34229: CALL 57704 0 4
34233: PPUSH
34234: CALL_OW 1
34238: ST_TO_ADDR
// continue ;
34239: GO 33672
// end ; end ;
34241: GO 33672
34243: POP
34244: POP
// end ; end ;
34245: GO 33101
34247: POP
34248: POP
// end ;
34249: LD_VAR 0 1
34253: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
34254: LD_INT 0
34256: PPUSH
34257: PPUSH
34258: PPUSH
34259: PPUSH
34260: PPUSH
34261: PPUSH
// if not mc_bases then
34262: LD_EXP 78
34266: NOT
34267: IFFALSE 34271
// exit ;
34269: GO 34698
// for i = 1 to mc_bases do
34271: LD_ADDR_VAR 0 2
34275: PUSH
34276: DOUBLE
34277: LD_INT 1
34279: DEC
34280: ST_TO_ADDR
34281: LD_EXP 78
34285: PUSH
34286: FOR_TO
34287: IFFALSE 34696
// begin tmp := mc_build_upgrade [ i ] ;
34289: LD_ADDR_VAR 0 4
34293: PUSH
34294: LD_EXP 110
34298: PUSH
34299: LD_VAR 0 2
34303: ARRAY
34304: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
34305: LD_ADDR_VAR 0 6
34309: PUSH
34310: LD_EXP 111
34314: PUSH
34315: LD_VAR 0 2
34319: ARRAY
34320: PPUSH
34321: LD_INT 2
34323: PUSH
34324: LD_INT 30
34326: PUSH
34327: LD_INT 6
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 30
34336: PUSH
34337: LD_INT 7
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: EMPTY
34345: LIST
34346: LIST
34347: LIST
34348: PPUSH
34349: CALL_OW 72
34353: ST_TO_ADDR
// if not tmp and not lab then
34354: LD_VAR 0 4
34358: NOT
34359: PUSH
34360: LD_VAR 0 6
34364: NOT
34365: AND
34366: IFFALSE 34370
// continue ;
34368: GO 34286
// if tmp then
34370: LD_VAR 0 4
34374: IFFALSE 34494
// for j in tmp do
34376: LD_ADDR_VAR 0 3
34380: PUSH
34381: LD_VAR 0 4
34385: PUSH
34386: FOR_IN
34387: IFFALSE 34492
// begin if UpgradeCost ( j ) then
34389: LD_VAR 0 3
34393: PPUSH
34394: CALL 65174 0 1
34398: IFFALSE 34490
// begin ComUpgrade ( j ) ;
34400: LD_VAR 0 3
34404: PPUSH
34405: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
34409: LD_ADDR_EXP 110
34413: PUSH
34414: LD_EXP 110
34418: PPUSH
34419: LD_VAR 0 2
34423: PPUSH
34424: LD_EXP 110
34428: PUSH
34429: LD_VAR 0 2
34433: ARRAY
34434: PUSH
34435: LD_VAR 0 3
34439: DIFF
34440: PPUSH
34441: CALL_OW 1
34445: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34446: LD_ADDR_EXP 85
34450: PUSH
34451: LD_EXP 85
34455: PPUSH
34456: LD_VAR 0 2
34460: PUSH
34461: LD_EXP 85
34465: PUSH
34466: LD_VAR 0 2
34470: ARRAY
34471: PUSH
34472: LD_INT 1
34474: PLUS
34475: PUSH
34476: EMPTY
34477: LIST
34478: LIST
34479: PPUSH
34480: LD_VAR 0 3
34484: PPUSH
34485: CALL 58286 0 3
34489: ST_TO_ADDR
// end ; end ;
34490: GO 34386
34492: POP
34493: POP
// if not lab or not mc_lab_upgrade [ i ] then
34494: LD_VAR 0 6
34498: NOT
34499: PUSH
34500: LD_EXP 112
34504: PUSH
34505: LD_VAR 0 2
34509: ARRAY
34510: NOT
34511: OR
34512: IFFALSE 34516
// continue ;
34514: GO 34286
// for j in lab do
34516: LD_ADDR_VAR 0 3
34520: PUSH
34521: LD_VAR 0 6
34525: PUSH
34526: FOR_IN
34527: IFFALSE 34692
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34529: LD_VAR 0 3
34533: PPUSH
34534: CALL_OW 266
34538: PUSH
34539: LD_INT 6
34541: PUSH
34542: LD_INT 7
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: IN
34549: PUSH
34550: LD_VAR 0 3
34554: PPUSH
34555: CALL_OW 461
34559: PUSH
34560: LD_INT 1
34562: NONEQUAL
34563: AND
34564: IFFALSE 34690
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34566: LD_VAR 0 3
34570: PPUSH
34571: LD_EXP 112
34575: PUSH
34576: LD_VAR 0 2
34580: ARRAY
34581: PUSH
34582: LD_INT 1
34584: ARRAY
34585: PPUSH
34586: CALL 65379 0 2
34590: IFFALSE 34690
// begin ComCancel ( j ) ;
34592: LD_VAR 0 3
34596: PPUSH
34597: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
34601: LD_VAR 0 3
34605: PPUSH
34606: LD_EXP 112
34610: PUSH
34611: LD_VAR 0 2
34615: ARRAY
34616: PUSH
34617: LD_INT 1
34619: ARRAY
34620: PPUSH
34621: CALL_OW 207
// if not j in mc_construct_list [ i ] then
34625: LD_VAR 0 3
34629: PUSH
34630: LD_EXP 85
34634: PUSH
34635: LD_VAR 0 2
34639: ARRAY
34640: IN
34641: NOT
34642: IFFALSE 34688
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34644: LD_ADDR_EXP 85
34648: PUSH
34649: LD_EXP 85
34653: PPUSH
34654: LD_VAR 0 2
34658: PUSH
34659: LD_EXP 85
34663: PUSH
34664: LD_VAR 0 2
34668: ARRAY
34669: PUSH
34670: LD_INT 1
34672: PLUS
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PPUSH
34678: LD_VAR 0 3
34682: PPUSH
34683: CALL 58286 0 3
34687: ST_TO_ADDR
// break ;
34688: GO 34692
// end ; end ; end ;
34690: GO 34526
34692: POP
34693: POP
// end ;
34694: GO 34286
34696: POP
34697: POP
// end ;
34698: LD_VAR 0 1
34702: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
34703: LD_INT 0
34705: PPUSH
34706: PPUSH
34707: PPUSH
34708: PPUSH
34709: PPUSH
34710: PPUSH
34711: PPUSH
34712: PPUSH
34713: PPUSH
// if not mc_bases then
34714: LD_EXP 78
34718: NOT
34719: IFFALSE 34723
// exit ;
34721: GO 35128
// for i = 1 to mc_bases do
34723: LD_ADDR_VAR 0 2
34727: PUSH
34728: DOUBLE
34729: LD_INT 1
34731: DEC
34732: ST_TO_ADDR
34733: LD_EXP 78
34737: PUSH
34738: FOR_TO
34739: IFFALSE 35126
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
34741: LD_EXP 86
34745: PUSH
34746: LD_VAR 0 2
34750: ARRAY
34751: NOT
34752: PUSH
34753: LD_EXP 78
34757: PUSH
34758: LD_VAR 0 2
34762: ARRAY
34763: PPUSH
34764: LD_INT 30
34766: PUSH
34767: LD_INT 3
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PPUSH
34774: CALL_OW 72
34778: NOT
34779: OR
34780: IFFALSE 34784
// continue ;
34782: GO 34738
// busy := false ;
34784: LD_ADDR_VAR 0 8
34788: PUSH
34789: LD_INT 0
34791: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34792: LD_ADDR_VAR 0 4
34796: PUSH
34797: LD_EXP 78
34801: PUSH
34802: LD_VAR 0 2
34806: ARRAY
34807: PPUSH
34808: LD_INT 30
34810: PUSH
34811: LD_INT 3
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PPUSH
34818: CALL_OW 72
34822: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
34823: LD_ADDR_VAR 0 6
34827: PUSH
34828: LD_EXP 86
34832: PUSH
34833: LD_VAR 0 2
34837: ARRAY
34838: PPUSH
34839: LD_INT 2
34841: PUSH
34842: LD_INT 30
34844: PUSH
34845: LD_INT 32
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 30
34854: PUSH
34855: LD_INT 33
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: LIST
34866: PPUSH
34867: CALL_OW 72
34871: ST_TO_ADDR
// if not t then
34872: LD_VAR 0 6
34876: NOT
34877: IFFALSE 34881
// continue ;
34879: GO 34738
// for j in tmp do
34881: LD_ADDR_VAR 0 3
34885: PUSH
34886: LD_VAR 0 4
34890: PUSH
34891: FOR_IN
34892: IFFALSE 34922
// if not BuildingStatus ( j ) = bs_idle then
34894: LD_VAR 0 3
34898: PPUSH
34899: CALL_OW 461
34903: PUSH
34904: LD_INT 2
34906: EQUAL
34907: NOT
34908: IFFALSE 34920
// begin busy := true ;
34910: LD_ADDR_VAR 0 8
34914: PUSH
34915: LD_INT 1
34917: ST_TO_ADDR
// break ;
34918: GO 34922
// end ;
34920: GO 34891
34922: POP
34923: POP
// if busy then
34924: LD_VAR 0 8
34928: IFFALSE 34932
// continue ;
34930: GO 34738
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
34932: LD_ADDR_VAR 0 7
34936: PUSH
34937: LD_VAR 0 6
34941: PPUSH
34942: LD_INT 35
34944: PUSH
34945: LD_INT 0
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PPUSH
34952: CALL_OW 72
34956: ST_TO_ADDR
// if tw then
34957: LD_VAR 0 7
34961: IFFALSE 35038
// begin tw := tw [ 1 ] ;
34963: LD_ADDR_VAR 0 7
34967: PUSH
34968: LD_VAR 0 7
34972: PUSH
34973: LD_INT 1
34975: ARRAY
34976: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
34977: LD_ADDR_VAR 0 9
34981: PUSH
34982: LD_VAR 0 7
34986: PPUSH
34987: LD_EXP 103
34991: PUSH
34992: LD_VAR 0 2
34996: ARRAY
34997: PPUSH
34998: CALL 63671 0 2
35002: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
35003: LD_EXP 117
35007: PUSH
35008: LD_VAR 0 2
35012: ARRAY
35013: IFFALSE 35036
// if not weapon in mc_allowed_tower_weapons [ i ] then
35015: LD_VAR 0 9
35019: PUSH
35020: LD_EXP 117
35024: PUSH
35025: LD_VAR 0 2
35029: ARRAY
35030: IN
35031: NOT
35032: IFFALSE 35036
// continue ;
35034: GO 34738
// end else
35036: GO 35101
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
35038: LD_ADDR_VAR 0 5
35042: PUSH
35043: LD_EXP 86
35047: PUSH
35048: LD_VAR 0 2
35052: ARRAY
35053: PPUSH
35054: LD_VAR 0 4
35058: PPUSH
35059: CALL 90563 0 2
35063: ST_TO_ADDR
// if not tmp2 then
35064: LD_VAR 0 5
35068: NOT
35069: IFFALSE 35073
// continue ;
35071: GO 34738
// tw := tmp2 [ 1 ] ;
35073: LD_ADDR_VAR 0 7
35077: PUSH
35078: LD_VAR 0 5
35082: PUSH
35083: LD_INT 1
35085: ARRAY
35086: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
35087: LD_ADDR_VAR 0 9
35091: PUSH
35092: LD_VAR 0 5
35096: PUSH
35097: LD_INT 2
35099: ARRAY
35100: ST_TO_ADDR
// end ; if not weapon then
35101: LD_VAR 0 9
35105: NOT
35106: IFFALSE 35110
// continue ;
35108: GO 34738
// ComPlaceWeapon ( tw , weapon ) ;
35110: LD_VAR 0 7
35114: PPUSH
35115: LD_VAR 0 9
35119: PPUSH
35120: CALL_OW 148
// end ;
35124: GO 34738
35126: POP
35127: POP
// end ;
35128: LD_VAR 0 1
35132: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
35133: LD_INT 0
35135: PPUSH
35136: PPUSH
35137: PPUSH
35138: PPUSH
35139: PPUSH
35140: PPUSH
35141: PPUSH
// if not mc_bases then
35142: LD_EXP 78
35146: NOT
35147: IFFALSE 35151
// exit ;
35149: GO 35926
// for i = 1 to mc_bases do
35151: LD_ADDR_VAR 0 2
35155: PUSH
35156: DOUBLE
35157: LD_INT 1
35159: DEC
35160: ST_TO_ADDR
35161: LD_EXP 78
35165: PUSH
35166: FOR_TO
35167: IFFALSE 35924
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
35169: LD_EXP 91
35173: PUSH
35174: LD_VAR 0 2
35178: ARRAY
35179: NOT
35180: PUSH
35181: LD_EXP 91
35185: PUSH
35186: LD_VAR 0 2
35190: ARRAY
35191: PUSH
35192: LD_EXP 92
35196: PUSH
35197: LD_VAR 0 2
35201: ARRAY
35202: EQUAL
35203: OR
35204: PUSH
35205: LD_EXP 101
35209: PUSH
35210: LD_VAR 0 2
35214: ARRAY
35215: OR
35216: IFFALSE 35220
// continue ;
35218: GO 35166
// if mc_miners [ i ] then
35220: LD_EXP 92
35224: PUSH
35225: LD_VAR 0 2
35229: ARRAY
35230: IFFALSE 35611
// begin for j = mc_miners [ i ] downto 1 do
35232: LD_ADDR_VAR 0 3
35236: PUSH
35237: DOUBLE
35238: LD_EXP 92
35242: PUSH
35243: LD_VAR 0 2
35247: ARRAY
35248: INC
35249: ST_TO_ADDR
35250: LD_INT 1
35252: PUSH
35253: FOR_DOWNTO
35254: IFFALSE 35609
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
35256: LD_EXP 92
35260: PUSH
35261: LD_VAR 0 2
35265: ARRAY
35266: PUSH
35267: LD_VAR 0 3
35271: ARRAY
35272: PPUSH
35273: CALL_OW 301
35277: PUSH
35278: LD_EXP 92
35282: PUSH
35283: LD_VAR 0 2
35287: ARRAY
35288: PUSH
35289: LD_VAR 0 3
35293: ARRAY
35294: PPUSH
35295: CALL_OW 257
35299: PUSH
35300: LD_INT 1
35302: NONEQUAL
35303: OR
35304: IFFALSE 35367
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
35306: LD_ADDR_VAR 0 5
35310: PUSH
35311: LD_EXP 92
35315: PUSH
35316: LD_VAR 0 2
35320: ARRAY
35321: PUSH
35322: LD_EXP 92
35326: PUSH
35327: LD_VAR 0 2
35331: ARRAY
35332: PUSH
35333: LD_VAR 0 3
35337: ARRAY
35338: DIFF
35339: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
35340: LD_ADDR_EXP 92
35344: PUSH
35345: LD_EXP 92
35349: PPUSH
35350: LD_VAR 0 2
35354: PPUSH
35355: LD_VAR 0 5
35359: PPUSH
35360: CALL_OW 1
35364: ST_TO_ADDR
// continue ;
35365: GO 35253
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
35367: LD_EXP 92
35371: PUSH
35372: LD_VAR 0 2
35376: ARRAY
35377: PUSH
35378: LD_VAR 0 3
35382: ARRAY
35383: PPUSH
35384: CALL_OW 257
35388: PUSH
35389: LD_INT 1
35391: EQUAL
35392: PUSH
35393: LD_EXP 92
35397: PUSH
35398: LD_VAR 0 2
35402: ARRAY
35403: PUSH
35404: LD_VAR 0 3
35408: ARRAY
35409: PPUSH
35410: CALL_OW 459
35414: NOT
35415: AND
35416: PUSH
35417: LD_EXP 92
35421: PUSH
35422: LD_VAR 0 2
35426: ARRAY
35427: PUSH
35428: LD_VAR 0 3
35432: ARRAY
35433: PPUSH
35434: CALL_OW 314
35438: NOT
35439: AND
35440: IFFALSE 35607
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
35442: LD_EXP 92
35446: PUSH
35447: LD_VAR 0 2
35451: ARRAY
35452: PUSH
35453: LD_VAR 0 3
35457: ARRAY
35458: PPUSH
35459: CALL_OW 310
35463: IFFALSE 35486
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
35465: LD_EXP 92
35469: PUSH
35470: LD_VAR 0 2
35474: ARRAY
35475: PUSH
35476: LD_VAR 0 3
35480: ARRAY
35481: PPUSH
35482: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
35486: LD_EXP 92
35490: PUSH
35491: LD_VAR 0 2
35495: ARRAY
35496: PUSH
35497: LD_VAR 0 3
35501: ARRAY
35502: PPUSH
35503: CALL_OW 314
35507: NOT
35508: IFFALSE 35607
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
35510: LD_ADDR_VAR 0 7
35514: PUSH
35515: LD_VAR 0 3
35519: PUSH
35520: LD_EXP 91
35524: PUSH
35525: LD_VAR 0 2
35529: ARRAY
35530: PPUSH
35531: CALL 55426 0 1
35535: MOD
35536: PUSH
35537: LD_INT 1
35539: PLUS
35540: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35541: LD_EXP 92
35545: PUSH
35546: LD_VAR 0 2
35550: ARRAY
35551: PUSH
35552: LD_VAR 0 3
35556: ARRAY
35557: PPUSH
35558: LD_EXP 91
35562: PUSH
35563: LD_VAR 0 2
35567: ARRAY
35568: PUSH
35569: LD_VAR 0 7
35573: ARRAY
35574: PUSH
35575: LD_INT 1
35577: ARRAY
35578: PPUSH
35579: LD_EXP 91
35583: PUSH
35584: LD_VAR 0 2
35588: ARRAY
35589: PUSH
35590: LD_VAR 0 7
35594: ARRAY
35595: PUSH
35596: LD_INT 2
35598: ARRAY
35599: PPUSH
35600: LD_INT 0
35602: PPUSH
35603: CALL_OW 193
// end ; end ; end ;
35607: GO 35253
35609: POP
35610: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
35611: LD_ADDR_VAR 0 5
35615: PUSH
35616: LD_EXP 78
35620: PUSH
35621: LD_VAR 0 2
35625: ARRAY
35626: PPUSH
35627: LD_INT 2
35629: PUSH
35630: LD_INT 30
35632: PUSH
35633: LD_INT 4
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 30
35642: PUSH
35643: LD_INT 5
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 30
35652: PUSH
35653: LD_INT 32
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: LIST
35664: LIST
35665: PPUSH
35666: CALL_OW 72
35670: ST_TO_ADDR
// if not tmp then
35671: LD_VAR 0 5
35675: NOT
35676: IFFALSE 35680
// continue ;
35678: GO 35166
// list := [ ] ;
35680: LD_ADDR_VAR 0 6
35684: PUSH
35685: EMPTY
35686: ST_TO_ADDR
// for j in tmp do
35687: LD_ADDR_VAR 0 3
35691: PUSH
35692: LD_VAR 0 5
35696: PUSH
35697: FOR_IN
35698: IFFALSE 35767
// begin for k in UnitsInside ( j ) do
35700: LD_ADDR_VAR 0 4
35704: PUSH
35705: LD_VAR 0 3
35709: PPUSH
35710: CALL_OW 313
35714: PUSH
35715: FOR_IN
35716: IFFALSE 35763
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
35718: LD_VAR 0 4
35722: PPUSH
35723: CALL_OW 257
35727: PUSH
35728: LD_INT 1
35730: EQUAL
35731: PUSH
35732: LD_VAR 0 4
35736: PPUSH
35737: CALL_OW 459
35741: NOT
35742: AND
35743: IFFALSE 35761
// list := list ^ k ;
35745: LD_ADDR_VAR 0 6
35749: PUSH
35750: LD_VAR 0 6
35754: PUSH
35755: LD_VAR 0 4
35759: ADD
35760: ST_TO_ADDR
35761: GO 35715
35763: POP
35764: POP
// end ;
35765: GO 35697
35767: POP
35768: POP
// list := list diff mc_miners [ i ] ;
35769: LD_ADDR_VAR 0 6
35773: PUSH
35774: LD_VAR 0 6
35778: PUSH
35779: LD_EXP 92
35783: PUSH
35784: LD_VAR 0 2
35788: ARRAY
35789: DIFF
35790: ST_TO_ADDR
// if not list then
35791: LD_VAR 0 6
35795: NOT
35796: IFFALSE 35800
// continue ;
35798: GO 35166
// k := mc_mines [ i ] - mc_miners [ i ] ;
35800: LD_ADDR_VAR 0 4
35804: PUSH
35805: LD_EXP 91
35809: PUSH
35810: LD_VAR 0 2
35814: ARRAY
35815: PUSH
35816: LD_EXP 92
35820: PUSH
35821: LD_VAR 0 2
35825: ARRAY
35826: MINUS
35827: ST_TO_ADDR
// if k > list then
35828: LD_VAR 0 4
35832: PUSH
35833: LD_VAR 0 6
35837: GREATER
35838: IFFALSE 35850
// k := list ;
35840: LD_ADDR_VAR 0 4
35844: PUSH
35845: LD_VAR 0 6
35849: ST_TO_ADDR
// for j = 1 to k do
35850: LD_ADDR_VAR 0 3
35854: PUSH
35855: DOUBLE
35856: LD_INT 1
35858: DEC
35859: ST_TO_ADDR
35860: LD_VAR 0 4
35864: PUSH
35865: FOR_TO
35866: IFFALSE 35920
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
35868: LD_ADDR_EXP 92
35872: PUSH
35873: LD_EXP 92
35877: PPUSH
35878: LD_VAR 0 2
35882: PUSH
35883: LD_EXP 92
35887: PUSH
35888: LD_VAR 0 2
35892: ARRAY
35893: PUSH
35894: LD_INT 1
35896: PLUS
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PPUSH
35902: LD_VAR 0 6
35906: PUSH
35907: LD_VAR 0 3
35911: ARRAY
35912: PPUSH
35913: CALL 58286 0 3
35917: ST_TO_ADDR
35918: GO 35865
35920: POP
35921: POP
// end ;
35922: GO 35166
35924: POP
35925: POP
// end ;
35926: LD_VAR 0 1
35930: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
35931: LD_INT 0
35933: PPUSH
35934: PPUSH
35935: PPUSH
35936: PPUSH
35937: PPUSH
35938: PPUSH
35939: PPUSH
35940: PPUSH
35941: PPUSH
35942: PPUSH
35943: PPUSH
// if not mc_bases then
35944: LD_EXP 78
35948: NOT
35949: IFFALSE 35953
// exit ;
35951: GO 37776
// for i = 1 to mc_bases do
35953: LD_ADDR_VAR 0 2
35957: PUSH
35958: DOUBLE
35959: LD_INT 1
35961: DEC
35962: ST_TO_ADDR
35963: LD_EXP 78
35967: PUSH
35968: FOR_TO
35969: IFFALSE 37774
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
35971: LD_EXP 78
35975: PUSH
35976: LD_VAR 0 2
35980: ARRAY
35981: NOT
35982: PUSH
35983: LD_EXP 85
35987: PUSH
35988: LD_VAR 0 2
35992: ARRAY
35993: OR
35994: IFFALSE 35998
// continue ;
35996: GO 35968
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
35998: LD_EXP 94
36002: PUSH
36003: LD_VAR 0 2
36007: ARRAY
36008: NOT
36009: PUSH
36010: LD_EXP 95
36014: PUSH
36015: LD_VAR 0 2
36019: ARRAY
36020: AND
36021: IFFALSE 36059
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36023: LD_ADDR_EXP 95
36027: PUSH
36028: LD_EXP 95
36032: PPUSH
36033: LD_VAR 0 2
36037: PPUSH
36038: EMPTY
36039: PPUSH
36040: CALL_OW 1
36044: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
36045: LD_VAR 0 2
36049: PPUSH
36050: LD_INT 107
36052: PPUSH
36053: CALL 26785 0 2
// continue ;
36057: GO 35968
// end ; target := [ ] ;
36059: LD_ADDR_VAR 0 7
36063: PUSH
36064: EMPTY
36065: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36066: LD_ADDR_VAR 0 6
36070: PUSH
36071: LD_EXP 78
36075: PUSH
36076: LD_VAR 0 2
36080: ARRAY
36081: PUSH
36082: LD_INT 1
36084: ARRAY
36085: PPUSH
36086: CALL_OW 255
36090: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36091: LD_ADDR_VAR 0 9
36095: PUSH
36096: LD_EXP 78
36100: PUSH
36101: LD_VAR 0 2
36105: ARRAY
36106: PPUSH
36107: LD_INT 2
36109: PUSH
36110: LD_INT 30
36112: PUSH
36113: LD_INT 0
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 30
36122: PUSH
36123: LD_INT 1
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: LIST
36134: PPUSH
36135: CALL_OW 72
36139: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
36140: LD_ADDR_VAR 0 3
36144: PUSH
36145: DOUBLE
36146: LD_EXP 94
36150: PUSH
36151: LD_VAR 0 2
36155: ARRAY
36156: INC
36157: ST_TO_ADDR
36158: LD_INT 1
36160: PUSH
36161: FOR_DOWNTO
36162: IFFALSE 36407
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
36164: LD_EXP 94
36168: PUSH
36169: LD_VAR 0 2
36173: ARRAY
36174: PUSH
36175: LD_VAR 0 3
36179: ARRAY
36180: PUSH
36181: LD_INT 2
36183: ARRAY
36184: PPUSH
36185: LD_EXP 94
36189: PUSH
36190: LD_VAR 0 2
36194: ARRAY
36195: PUSH
36196: LD_VAR 0 3
36200: ARRAY
36201: PUSH
36202: LD_INT 3
36204: ARRAY
36205: PPUSH
36206: CALL_OW 488
36210: PUSH
36211: LD_EXP 94
36215: PUSH
36216: LD_VAR 0 2
36220: ARRAY
36221: PUSH
36222: LD_VAR 0 3
36226: ARRAY
36227: PUSH
36228: LD_INT 2
36230: ARRAY
36231: PPUSH
36232: LD_EXP 94
36236: PUSH
36237: LD_VAR 0 2
36241: ARRAY
36242: PUSH
36243: LD_VAR 0 3
36247: ARRAY
36248: PUSH
36249: LD_INT 3
36251: ARRAY
36252: PPUSH
36253: CALL_OW 284
36257: PUSH
36258: LD_INT 0
36260: EQUAL
36261: AND
36262: IFFALSE 36317
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
36264: LD_ADDR_VAR 0 5
36268: PUSH
36269: LD_EXP 94
36273: PUSH
36274: LD_VAR 0 2
36278: ARRAY
36279: PPUSH
36280: LD_VAR 0 3
36284: PPUSH
36285: CALL_OW 3
36289: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
36290: LD_ADDR_EXP 94
36294: PUSH
36295: LD_EXP 94
36299: PPUSH
36300: LD_VAR 0 2
36304: PPUSH
36305: LD_VAR 0 5
36309: PPUSH
36310: CALL_OW 1
36314: ST_TO_ADDR
// continue ;
36315: GO 36161
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
36317: LD_VAR 0 6
36321: PPUSH
36322: LD_EXP 94
36326: PUSH
36327: LD_VAR 0 2
36331: ARRAY
36332: PUSH
36333: LD_VAR 0 3
36337: ARRAY
36338: PUSH
36339: LD_INT 2
36341: ARRAY
36342: PPUSH
36343: LD_EXP 94
36347: PUSH
36348: LD_VAR 0 2
36352: ARRAY
36353: PUSH
36354: LD_VAR 0 3
36358: ARRAY
36359: PUSH
36360: LD_INT 3
36362: ARRAY
36363: PPUSH
36364: LD_INT 30
36366: PPUSH
36367: CALL 59550 0 4
36371: PUSH
36372: LD_INT 4
36374: ARRAY
36375: PUSH
36376: LD_INT 0
36378: EQUAL
36379: IFFALSE 36405
// begin target := mc_crates [ i ] [ j ] ;
36381: LD_ADDR_VAR 0 7
36385: PUSH
36386: LD_EXP 94
36390: PUSH
36391: LD_VAR 0 2
36395: ARRAY
36396: PUSH
36397: LD_VAR 0 3
36401: ARRAY
36402: ST_TO_ADDR
// break ;
36403: GO 36407
// end ; end ;
36405: GO 36161
36407: POP
36408: POP
// if not target then
36409: LD_VAR 0 7
36413: NOT
36414: IFFALSE 36418
// continue ;
36416: GO 35968
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
36418: LD_ADDR_VAR 0 8
36422: PUSH
36423: LD_EXP 97
36427: PUSH
36428: LD_VAR 0 2
36432: ARRAY
36433: PPUSH
36434: LD_INT 2
36436: PUSH
36437: LD_INT 3
36439: PUSH
36440: LD_INT 58
36442: PUSH
36443: EMPTY
36444: LIST
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 61
36452: PUSH
36453: EMPTY
36454: LIST
36455: PUSH
36456: LD_INT 33
36458: PUSH
36459: LD_INT 5
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 33
36468: PUSH
36469: LD_INT 3
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: PUSH
36483: LD_INT 2
36485: PUSH
36486: LD_INT 34
36488: PUSH
36489: LD_INT 32
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 34
36498: PUSH
36499: LD_INT 51
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 34
36508: PUSH
36509: LD_INT 12
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PPUSH
36526: CALL_OW 72
36530: ST_TO_ADDR
// if not cargo then
36531: LD_VAR 0 8
36535: NOT
36536: IFFALSE 37242
// begin if mc_crates_collector [ i ] < 5 then
36538: LD_EXP 95
36542: PUSH
36543: LD_VAR 0 2
36547: ARRAY
36548: PUSH
36549: LD_INT 5
36551: LESS
36552: IFFALSE 36918
// begin if mc_ape [ i ] then
36554: LD_EXP 107
36558: PUSH
36559: LD_VAR 0 2
36563: ARRAY
36564: IFFALSE 36611
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36566: LD_ADDR_VAR 0 5
36570: PUSH
36571: LD_EXP 107
36575: PUSH
36576: LD_VAR 0 2
36580: ARRAY
36581: PPUSH
36582: LD_INT 25
36584: PUSH
36585: LD_INT 16
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 24
36594: PUSH
36595: LD_INT 750
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PPUSH
36606: CALL_OW 72
36610: ST_TO_ADDR
// if not tmp then
36611: LD_VAR 0 5
36615: NOT
36616: IFFALSE 36663
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
36618: LD_ADDR_VAR 0 5
36622: PUSH
36623: LD_EXP 78
36627: PUSH
36628: LD_VAR 0 2
36632: ARRAY
36633: PPUSH
36634: LD_INT 25
36636: PUSH
36637: LD_INT 2
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 24
36646: PUSH
36647: LD_INT 750
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PPUSH
36658: CALL_OW 72
36662: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
36663: LD_EXP 107
36667: PUSH
36668: LD_VAR 0 2
36672: ARRAY
36673: PUSH
36674: LD_EXP 78
36678: PUSH
36679: LD_VAR 0 2
36683: ARRAY
36684: PPUSH
36685: LD_INT 25
36687: PUSH
36688: LD_INT 2
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: LD_INT 24
36697: PUSH
36698: LD_INT 750
36700: PUSH
36701: EMPTY
36702: LIST
36703: LIST
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PPUSH
36709: CALL_OW 72
36713: AND
36714: PUSH
36715: LD_VAR 0 5
36719: PUSH
36720: LD_INT 5
36722: LESS
36723: AND
36724: IFFALSE 36806
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
36726: LD_ADDR_VAR 0 3
36730: PUSH
36731: LD_EXP 78
36735: PUSH
36736: LD_VAR 0 2
36740: ARRAY
36741: PPUSH
36742: LD_INT 25
36744: PUSH
36745: LD_INT 2
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 24
36754: PUSH
36755: LD_INT 750
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PPUSH
36766: CALL_OW 72
36770: PUSH
36771: FOR_IN
36772: IFFALSE 36804
// begin tmp := tmp union j ;
36774: LD_ADDR_VAR 0 5
36778: PUSH
36779: LD_VAR 0 5
36783: PUSH
36784: LD_VAR 0 3
36788: UNION
36789: ST_TO_ADDR
// if tmp >= 5 then
36790: LD_VAR 0 5
36794: PUSH
36795: LD_INT 5
36797: GREATEREQUAL
36798: IFFALSE 36802
// break ;
36800: GO 36804
// end ;
36802: GO 36771
36804: POP
36805: POP
// end ; if not tmp then
36806: LD_VAR 0 5
36810: NOT
36811: IFFALSE 36815
// continue ;
36813: GO 35968
// for j in tmp do
36815: LD_ADDR_VAR 0 3
36819: PUSH
36820: LD_VAR 0 5
36824: PUSH
36825: FOR_IN
36826: IFFALSE 36916
// if not GetTag ( j ) then
36828: LD_VAR 0 3
36832: PPUSH
36833: CALL_OW 110
36837: NOT
36838: IFFALSE 36914
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
36840: LD_ADDR_EXP 95
36844: PUSH
36845: LD_EXP 95
36849: PPUSH
36850: LD_VAR 0 2
36854: PUSH
36855: LD_EXP 95
36859: PUSH
36860: LD_VAR 0 2
36864: ARRAY
36865: PUSH
36866: LD_INT 1
36868: PLUS
36869: PUSH
36870: EMPTY
36871: LIST
36872: LIST
36873: PPUSH
36874: LD_VAR 0 3
36878: PPUSH
36879: CALL 58286 0 3
36883: ST_TO_ADDR
// SetTag ( j , 107 ) ;
36884: LD_VAR 0 3
36888: PPUSH
36889: LD_INT 107
36891: PPUSH
36892: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
36896: LD_EXP 95
36900: PUSH
36901: LD_VAR 0 2
36905: ARRAY
36906: PUSH
36907: LD_INT 5
36909: GREATEREQUAL
36910: IFFALSE 36914
// break ;
36912: GO 36916
// end ;
36914: GO 36825
36916: POP
36917: POP
// end ; if mc_crates_collector [ i ] and target then
36918: LD_EXP 95
36922: PUSH
36923: LD_VAR 0 2
36927: ARRAY
36928: PUSH
36929: LD_VAR 0 7
36933: AND
36934: IFFALSE 37240
// begin if mc_crates_collector [ i ] < target [ 1 ] then
36936: LD_EXP 95
36940: PUSH
36941: LD_VAR 0 2
36945: ARRAY
36946: PUSH
36947: LD_VAR 0 7
36951: PUSH
36952: LD_INT 1
36954: ARRAY
36955: LESS
36956: IFFALSE 36976
// tmp := mc_crates_collector [ i ] else
36958: LD_ADDR_VAR 0 5
36962: PUSH
36963: LD_EXP 95
36967: PUSH
36968: LD_VAR 0 2
36972: ARRAY
36973: ST_TO_ADDR
36974: GO 36990
// tmp := target [ 1 ] ;
36976: LD_ADDR_VAR 0 5
36980: PUSH
36981: LD_VAR 0 7
36985: PUSH
36986: LD_INT 1
36988: ARRAY
36989: ST_TO_ADDR
// k := 0 ;
36990: LD_ADDR_VAR 0 4
36994: PUSH
36995: LD_INT 0
36997: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
36998: LD_ADDR_VAR 0 3
37002: PUSH
37003: LD_EXP 95
37007: PUSH
37008: LD_VAR 0 2
37012: ARRAY
37013: PUSH
37014: FOR_IN
37015: IFFALSE 37238
// begin k := k + 1 ;
37017: LD_ADDR_VAR 0 4
37021: PUSH
37022: LD_VAR 0 4
37026: PUSH
37027: LD_INT 1
37029: PLUS
37030: ST_TO_ADDR
// if k > tmp then
37031: LD_VAR 0 4
37035: PUSH
37036: LD_VAR 0 5
37040: GREATER
37041: IFFALSE 37045
// break ;
37043: GO 37238
// if not GetClass ( j ) in [ 2 , 16 ] then
37045: LD_VAR 0 3
37049: PPUSH
37050: CALL_OW 257
37054: PUSH
37055: LD_INT 2
37057: PUSH
37058: LD_INT 16
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: IN
37065: NOT
37066: IFFALSE 37119
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
37068: LD_ADDR_EXP 95
37072: PUSH
37073: LD_EXP 95
37077: PPUSH
37078: LD_VAR 0 2
37082: PPUSH
37083: LD_EXP 95
37087: PUSH
37088: LD_VAR 0 2
37092: ARRAY
37093: PUSH
37094: LD_VAR 0 3
37098: DIFF
37099: PPUSH
37100: CALL_OW 1
37104: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37105: LD_VAR 0 3
37109: PPUSH
37110: LD_INT 0
37112: PPUSH
37113: CALL_OW 109
// continue ;
37117: GO 37014
// end ; if IsInUnit ( j ) then
37119: LD_VAR 0 3
37123: PPUSH
37124: CALL_OW 310
37128: IFFALSE 37139
// ComExitBuilding ( j ) ;
37130: LD_VAR 0 3
37134: PPUSH
37135: CALL_OW 122
// wait ( 3 ) ;
37139: LD_INT 3
37141: PPUSH
37142: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
37146: LD_VAR 0 3
37150: PPUSH
37151: CALL_OW 314
37155: PUSH
37156: LD_VAR 0 6
37160: PPUSH
37161: LD_VAR 0 7
37165: PUSH
37166: LD_INT 2
37168: ARRAY
37169: PPUSH
37170: LD_VAR 0 7
37174: PUSH
37175: LD_INT 3
37177: ARRAY
37178: PPUSH
37179: LD_INT 30
37181: PPUSH
37182: CALL 59550 0 4
37186: PUSH
37187: LD_INT 4
37189: ARRAY
37190: AND
37191: IFFALSE 37209
// ComStandNearbyBuilding ( j , depot ) else
37193: LD_VAR 0 3
37197: PPUSH
37198: LD_VAR 0 9
37202: PPUSH
37203: CALL 54888 0 2
37207: GO 37236
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37209: LD_VAR 0 3
37213: PPUSH
37214: LD_VAR 0 7
37218: PUSH
37219: LD_INT 2
37221: ARRAY
37222: PPUSH
37223: LD_VAR 0 7
37227: PUSH
37228: LD_INT 3
37230: ARRAY
37231: PPUSH
37232: CALL_OW 117
// end ;
37236: GO 37014
37238: POP
37239: POP
// end ; end else
37240: GO 37772
// begin for j in cargo do
37242: LD_ADDR_VAR 0 3
37246: PUSH
37247: LD_VAR 0 8
37251: PUSH
37252: FOR_IN
37253: IFFALSE 37770
// begin if GetTag ( j ) <> 0 then
37255: LD_VAR 0 3
37259: PPUSH
37260: CALL_OW 110
37264: PUSH
37265: LD_INT 0
37267: NONEQUAL
37268: IFFALSE 37272
// continue ;
37270: GO 37252
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
37272: LD_VAR 0 3
37276: PPUSH
37277: CALL_OW 256
37281: PUSH
37282: LD_INT 1000
37284: LESS
37285: PUSH
37286: LD_VAR 0 3
37290: PPUSH
37291: LD_EXP 102
37295: PUSH
37296: LD_VAR 0 2
37300: ARRAY
37301: PPUSH
37302: CALL_OW 308
37306: NOT
37307: AND
37308: IFFALSE 37330
// ComMoveToArea ( j , mc_parking [ i ] ) ;
37310: LD_VAR 0 3
37314: PPUSH
37315: LD_EXP 102
37319: PUSH
37320: LD_VAR 0 2
37324: ARRAY
37325: PPUSH
37326: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
37330: LD_VAR 0 3
37334: PPUSH
37335: CALL_OW 256
37339: PUSH
37340: LD_INT 1000
37342: LESS
37343: PUSH
37344: LD_VAR 0 3
37348: PPUSH
37349: LD_EXP 102
37353: PUSH
37354: LD_VAR 0 2
37358: ARRAY
37359: PPUSH
37360: CALL_OW 308
37364: AND
37365: IFFALSE 37369
// continue ;
37367: GO 37252
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
37369: LD_VAR 0 3
37373: PPUSH
37374: CALL_OW 262
37378: PUSH
37379: LD_INT 2
37381: EQUAL
37382: PUSH
37383: LD_VAR 0 3
37387: PPUSH
37388: CALL_OW 261
37392: PUSH
37393: LD_INT 15
37395: LESS
37396: AND
37397: IFFALSE 37401
// continue ;
37399: GO 37252
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
37401: LD_VAR 0 3
37405: PPUSH
37406: CALL_OW 262
37410: PUSH
37411: LD_INT 1
37413: EQUAL
37414: PUSH
37415: LD_VAR 0 3
37419: PPUSH
37420: CALL_OW 261
37424: PUSH
37425: LD_INT 10
37427: LESS
37428: AND
37429: IFFALSE 37709
// begin if not depot then
37431: LD_VAR 0 9
37435: NOT
37436: IFFALSE 37440
// continue ;
37438: GO 37252
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
37440: LD_VAR 0 3
37444: PPUSH
37445: LD_VAR 0 9
37449: PPUSH
37450: LD_VAR 0 3
37454: PPUSH
37455: CALL_OW 74
37459: PPUSH
37460: CALL_OW 296
37464: PUSH
37465: LD_INT 6
37467: LESS
37468: IFFALSE 37484
// SetFuel ( j , 100 ) else
37470: LD_VAR 0 3
37474: PPUSH
37475: LD_INT 100
37477: PPUSH
37478: CALL_OW 240
37482: GO 37709
// if GetFuel ( j ) = 0 then
37484: LD_VAR 0 3
37488: PPUSH
37489: CALL_OW 261
37493: PUSH
37494: LD_INT 0
37496: EQUAL
37497: IFFALSE 37709
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
37499: LD_ADDR_EXP 97
37503: PUSH
37504: LD_EXP 97
37508: PPUSH
37509: LD_VAR 0 2
37513: PPUSH
37514: LD_EXP 97
37518: PUSH
37519: LD_VAR 0 2
37523: ARRAY
37524: PUSH
37525: LD_VAR 0 3
37529: DIFF
37530: PPUSH
37531: CALL_OW 1
37535: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37536: LD_VAR 0 3
37540: PPUSH
37541: CALL_OW 263
37545: PUSH
37546: LD_INT 1
37548: EQUAL
37549: IFFALSE 37565
// ComExitVehicle ( IsInUnit ( j ) ) ;
37551: LD_VAR 0 3
37555: PPUSH
37556: CALL_OW 310
37560: PPUSH
37561: CALL_OW 121
// if GetControl ( j ) = control_remote then
37565: LD_VAR 0 3
37569: PPUSH
37570: CALL_OW 263
37574: PUSH
37575: LD_INT 2
37577: EQUAL
37578: IFFALSE 37589
// ComUnlink ( j ) ;
37580: LD_VAR 0 3
37584: PPUSH
37585: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37589: LD_ADDR_VAR 0 10
37593: PUSH
37594: LD_VAR 0 2
37598: PPUSH
37599: LD_INT 3
37601: PPUSH
37602: CALL 47353 0 2
37606: ST_TO_ADDR
// if fac then
37607: LD_VAR 0 10
37611: IFFALSE 37707
// begin for k in fac do
37613: LD_ADDR_VAR 0 4
37617: PUSH
37618: LD_VAR 0 10
37622: PUSH
37623: FOR_IN
37624: IFFALSE 37705
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
37626: LD_ADDR_VAR 0 11
37630: PUSH
37631: LD_VAR 0 10
37635: PPUSH
37636: LD_VAR 0 3
37640: PPUSH
37641: CALL_OW 265
37645: PPUSH
37646: LD_VAR 0 3
37650: PPUSH
37651: CALL_OW 262
37655: PPUSH
37656: LD_VAR 0 3
37660: PPUSH
37661: CALL_OW 263
37665: PPUSH
37666: LD_VAR 0 3
37670: PPUSH
37671: CALL_OW 264
37675: PPUSH
37676: CALL 55784 0 5
37680: ST_TO_ADDR
// if components then
37681: LD_VAR 0 11
37685: IFFALSE 37703
// begin MC_InsertProduceList ( i , components ) ;
37687: LD_VAR 0 2
37691: PPUSH
37692: LD_VAR 0 11
37696: PPUSH
37697: CALL 46898 0 2
// break ;
37701: GO 37705
// end ; end ;
37703: GO 37623
37705: POP
37706: POP
// end ; continue ;
37707: GO 37252
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
37709: LD_VAR 0 3
37713: PPUSH
37714: LD_INT 1
37716: PPUSH
37717: CALL_OW 289
37721: PUSH
37722: LD_INT 100
37724: LESS
37725: PUSH
37726: LD_VAR 0 3
37730: PPUSH
37731: CALL_OW 314
37735: NOT
37736: AND
37737: IFFALSE 37766
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37739: LD_VAR 0 3
37743: PPUSH
37744: LD_VAR 0 7
37748: PUSH
37749: LD_INT 2
37751: ARRAY
37752: PPUSH
37753: LD_VAR 0 7
37757: PUSH
37758: LD_INT 3
37760: ARRAY
37761: PPUSH
37762: CALL_OW 117
// break ;
37766: GO 37770
// end ;
37768: GO 37252
37770: POP
37771: POP
// end ; end ;
37772: GO 35968
37774: POP
37775: POP
// end ;
37776: LD_VAR 0 1
37780: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
37781: LD_INT 0
37783: PPUSH
37784: PPUSH
37785: PPUSH
37786: PPUSH
// if not mc_bases then
37787: LD_EXP 78
37791: NOT
37792: IFFALSE 37796
// exit ;
37794: GO 37957
// for i = 1 to mc_bases do
37796: LD_ADDR_VAR 0 2
37800: PUSH
37801: DOUBLE
37802: LD_INT 1
37804: DEC
37805: ST_TO_ADDR
37806: LD_EXP 78
37810: PUSH
37811: FOR_TO
37812: IFFALSE 37955
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
37814: LD_ADDR_VAR 0 4
37818: PUSH
37819: LD_EXP 97
37823: PUSH
37824: LD_VAR 0 2
37828: ARRAY
37829: PUSH
37830: LD_EXP 100
37834: PUSH
37835: LD_VAR 0 2
37839: ARRAY
37840: UNION
37841: PPUSH
37842: LD_INT 33
37844: PUSH
37845: LD_INT 2
37847: PUSH
37848: EMPTY
37849: LIST
37850: LIST
37851: PPUSH
37852: CALL_OW 72
37856: ST_TO_ADDR
// if tmp then
37857: LD_VAR 0 4
37861: IFFALSE 37953
// for j in tmp do
37863: LD_ADDR_VAR 0 3
37867: PUSH
37868: LD_VAR 0 4
37872: PUSH
37873: FOR_IN
37874: IFFALSE 37951
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
37876: LD_VAR 0 3
37880: PPUSH
37881: CALL_OW 312
37885: NOT
37886: PUSH
37887: LD_VAR 0 3
37891: PPUSH
37892: CALL_OW 256
37896: PUSH
37897: LD_INT 250
37899: GREATEREQUAL
37900: AND
37901: IFFALSE 37914
// Connect ( j ) else
37903: LD_VAR 0 3
37907: PPUSH
37908: CALL 61632 0 1
37912: GO 37949
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
37914: LD_VAR 0 3
37918: PPUSH
37919: CALL_OW 256
37923: PUSH
37924: LD_INT 250
37926: LESS
37927: PUSH
37928: LD_VAR 0 3
37932: PPUSH
37933: CALL_OW 312
37937: AND
37938: IFFALSE 37949
// ComUnlink ( j ) ;
37940: LD_VAR 0 3
37944: PPUSH
37945: CALL_OW 136
37949: GO 37873
37951: POP
37952: POP
// end ;
37953: GO 37811
37955: POP
37956: POP
// end ;
37957: LD_VAR 0 1
37961: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
37962: LD_INT 0
37964: PPUSH
37965: PPUSH
37966: PPUSH
37967: PPUSH
37968: PPUSH
// if not mc_bases then
37969: LD_EXP 78
37973: NOT
37974: IFFALSE 37978
// exit ;
37976: GO 38423
// for i = 1 to mc_bases do
37978: LD_ADDR_VAR 0 2
37982: PUSH
37983: DOUBLE
37984: LD_INT 1
37986: DEC
37987: ST_TO_ADDR
37988: LD_EXP 78
37992: PUSH
37993: FOR_TO
37994: IFFALSE 38421
// begin if not mc_produce [ i ] then
37996: LD_EXP 99
38000: PUSH
38001: LD_VAR 0 2
38005: ARRAY
38006: NOT
38007: IFFALSE 38011
// continue ;
38009: GO 37993
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38011: LD_ADDR_VAR 0 5
38015: PUSH
38016: LD_EXP 78
38020: PUSH
38021: LD_VAR 0 2
38025: ARRAY
38026: PPUSH
38027: LD_INT 30
38029: PUSH
38030: LD_INT 3
38032: PUSH
38033: EMPTY
38034: LIST
38035: LIST
38036: PPUSH
38037: CALL_OW 72
38041: ST_TO_ADDR
// if not fac then
38042: LD_VAR 0 5
38046: NOT
38047: IFFALSE 38051
// continue ;
38049: GO 37993
// for j in fac do
38051: LD_ADDR_VAR 0 3
38055: PUSH
38056: LD_VAR 0 5
38060: PUSH
38061: FOR_IN
38062: IFFALSE 38417
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
38064: LD_VAR 0 3
38068: PPUSH
38069: CALL_OW 461
38073: PUSH
38074: LD_INT 2
38076: NONEQUAL
38077: PUSH
38078: LD_VAR 0 3
38082: PPUSH
38083: LD_INT 15
38085: PPUSH
38086: CALL 61251 0 2
38090: PUSH
38091: LD_INT 4
38093: ARRAY
38094: OR
38095: IFFALSE 38099
// continue ;
38097: GO 38061
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
38099: LD_VAR 0 3
38103: PPUSH
38104: LD_EXP 99
38108: PUSH
38109: LD_VAR 0 2
38113: ARRAY
38114: PUSH
38115: LD_INT 1
38117: ARRAY
38118: PUSH
38119: LD_INT 1
38121: ARRAY
38122: PPUSH
38123: LD_EXP 99
38127: PUSH
38128: LD_VAR 0 2
38132: ARRAY
38133: PUSH
38134: LD_INT 1
38136: ARRAY
38137: PUSH
38138: LD_INT 2
38140: ARRAY
38141: PPUSH
38142: LD_EXP 99
38146: PUSH
38147: LD_VAR 0 2
38151: ARRAY
38152: PUSH
38153: LD_INT 1
38155: ARRAY
38156: PUSH
38157: LD_INT 3
38159: ARRAY
38160: PPUSH
38161: LD_EXP 99
38165: PUSH
38166: LD_VAR 0 2
38170: ARRAY
38171: PUSH
38172: LD_INT 1
38174: ARRAY
38175: PUSH
38176: LD_INT 4
38178: ARRAY
38179: PPUSH
38180: CALL_OW 448
38184: PUSH
38185: LD_VAR 0 3
38189: PPUSH
38190: LD_EXP 99
38194: PUSH
38195: LD_VAR 0 2
38199: ARRAY
38200: PUSH
38201: LD_INT 1
38203: ARRAY
38204: PUSH
38205: LD_INT 1
38207: ARRAY
38208: PUSH
38209: LD_EXP 99
38213: PUSH
38214: LD_VAR 0 2
38218: ARRAY
38219: PUSH
38220: LD_INT 1
38222: ARRAY
38223: PUSH
38224: LD_INT 2
38226: ARRAY
38227: PUSH
38228: LD_EXP 99
38232: PUSH
38233: LD_VAR 0 2
38237: ARRAY
38238: PUSH
38239: LD_INT 1
38241: ARRAY
38242: PUSH
38243: LD_INT 3
38245: ARRAY
38246: PUSH
38247: LD_EXP 99
38251: PUSH
38252: LD_VAR 0 2
38256: ARRAY
38257: PUSH
38258: LD_INT 1
38260: ARRAY
38261: PUSH
38262: LD_INT 4
38264: ARRAY
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: PPUSH
38272: CALL 65027 0 2
38276: AND
38277: IFFALSE 38415
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
38279: LD_VAR 0 3
38283: PPUSH
38284: LD_EXP 99
38288: PUSH
38289: LD_VAR 0 2
38293: ARRAY
38294: PUSH
38295: LD_INT 1
38297: ARRAY
38298: PUSH
38299: LD_INT 1
38301: ARRAY
38302: PPUSH
38303: LD_EXP 99
38307: PUSH
38308: LD_VAR 0 2
38312: ARRAY
38313: PUSH
38314: LD_INT 1
38316: ARRAY
38317: PUSH
38318: LD_INT 2
38320: ARRAY
38321: PPUSH
38322: LD_EXP 99
38326: PUSH
38327: LD_VAR 0 2
38331: ARRAY
38332: PUSH
38333: LD_INT 1
38335: ARRAY
38336: PUSH
38337: LD_INT 3
38339: ARRAY
38340: PPUSH
38341: LD_EXP 99
38345: PUSH
38346: LD_VAR 0 2
38350: ARRAY
38351: PUSH
38352: LD_INT 1
38354: ARRAY
38355: PUSH
38356: LD_INT 4
38358: ARRAY
38359: PPUSH
38360: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
38364: LD_ADDR_VAR 0 4
38368: PUSH
38369: LD_EXP 99
38373: PUSH
38374: LD_VAR 0 2
38378: ARRAY
38379: PPUSH
38380: LD_INT 1
38382: PPUSH
38383: CALL_OW 3
38387: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
38388: LD_ADDR_EXP 99
38392: PUSH
38393: LD_EXP 99
38397: PPUSH
38398: LD_VAR 0 2
38402: PPUSH
38403: LD_VAR 0 4
38407: PPUSH
38408: CALL_OW 1
38412: ST_TO_ADDR
// break ;
38413: GO 38417
// end ; end ;
38415: GO 38061
38417: POP
38418: POP
// end ;
38419: GO 37993
38421: POP
38422: POP
// end ;
38423: LD_VAR 0 1
38427: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
38428: LD_INT 0
38430: PPUSH
38431: PPUSH
38432: PPUSH
// if not mc_bases then
38433: LD_EXP 78
38437: NOT
38438: IFFALSE 38442
// exit ;
38440: GO 38531
// for i = 1 to mc_bases do
38442: LD_ADDR_VAR 0 2
38446: PUSH
38447: DOUBLE
38448: LD_INT 1
38450: DEC
38451: ST_TO_ADDR
38452: LD_EXP 78
38456: PUSH
38457: FOR_TO
38458: IFFALSE 38529
// begin if mc_attack [ i ] then
38460: LD_EXP 98
38464: PUSH
38465: LD_VAR 0 2
38469: ARRAY
38470: IFFALSE 38527
// begin tmp := mc_attack [ i ] [ 1 ] ;
38472: LD_ADDR_VAR 0 3
38476: PUSH
38477: LD_EXP 98
38481: PUSH
38482: LD_VAR 0 2
38486: ARRAY
38487: PUSH
38488: LD_INT 1
38490: ARRAY
38491: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38492: LD_ADDR_EXP 98
38496: PUSH
38497: LD_EXP 98
38501: PPUSH
38502: LD_VAR 0 2
38506: PPUSH
38507: EMPTY
38508: PPUSH
38509: CALL_OW 1
38513: ST_TO_ADDR
// Attack ( tmp ) ;
38514: LD_VAR 0 3
38518: PPUSH
38519: CALL 116808 0 1
// exit ;
38523: POP
38524: POP
38525: GO 38531
// end ; end ;
38527: GO 38457
38529: POP
38530: POP
// end ;
38531: LD_VAR 0 1
38535: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38536: LD_INT 0
38538: PPUSH
38539: PPUSH
38540: PPUSH
38541: PPUSH
38542: PPUSH
38543: PPUSH
38544: PPUSH
// if not mc_bases then
38545: LD_EXP 78
38549: NOT
38550: IFFALSE 38554
// exit ;
38552: GO 39411
// for i = 1 to mc_bases do
38554: LD_ADDR_VAR 0 2
38558: PUSH
38559: DOUBLE
38560: LD_INT 1
38562: DEC
38563: ST_TO_ADDR
38564: LD_EXP 78
38568: PUSH
38569: FOR_TO
38570: IFFALSE 39409
// begin if not mc_bases [ i ] then
38572: LD_EXP 78
38576: PUSH
38577: LD_VAR 0 2
38581: ARRAY
38582: NOT
38583: IFFALSE 38587
// continue ;
38585: GO 38569
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38587: LD_ADDR_VAR 0 7
38591: PUSH
38592: LD_EXP 78
38596: PUSH
38597: LD_VAR 0 2
38601: ARRAY
38602: PUSH
38603: LD_INT 1
38605: ARRAY
38606: PPUSH
38607: CALL 55110 0 1
38611: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
38612: LD_ADDR_EXP 101
38616: PUSH
38617: LD_EXP 101
38621: PPUSH
38622: LD_VAR 0 2
38626: PPUSH
38627: LD_EXP 78
38631: PUSH
38632: LD_VAR 0 2
38636: ARRAY
38637: PUSH
38638: LD_INT 1
38640: ARRAY
38641: PPUSH
38642: CALL_OW 255
38646: PPUSH
38647: LD_EXP 103
38651: PUSH
38652: LD_VAR 0 2
38656: ARRAY
38657: PPUSH
38658: CALL 55075 0 2
38662: PPUSH
38663: CALL_OW 1
38667: ST_TO_ADDR
// if not mc_scan [ i ] then
38668: LD_EXP 101
38672: PUSH
38673: LD_VAR 0 2
38677: ARRAY
38678: NOT
38679: IFFALSE 38857
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38681: LD_ADDR_EXP 121
38685: PUSH
38686: LD_EXP 121
38690: PPUSH
38691: LD_VAR 0 2
38695: PPUSH
38696: LD_INT 0
38698: PPUSH
38699: CALL_OW 1
38703: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38704: LD_ADDR_VAR 0 4
38708: PUSH
38709: LD_EXP 78
38713: PUSH
38714: LD_VAR 0 2
38718: ARRAY
38719: PPUSH
38720: LD_INT 2
38722: PUSH
38723: LD_INT 25
38725: PUSH
38726: LD_INT 5
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: LD_INT 25
38735: PUSH
38736: LD_INT 8
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 25
38745: PUSH
38746: LD_INT 9
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: PPUSH
38759: CALL_OW 72
38763: ST_TO_ADDR
// if not tmp then
38764: LD_VAR 0 4
38768: NOT
38769: IFFALSE 38773
// continue ;
38771: GO 38569
// for j in tmp do
38773: LD_ADDR_VAR 0 3
38777: PUSH
38778: LD_VAR 0 4
38782: PUSH
38783: FOR_IN
38784: IFFALSE 38855
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
38786: LD_VAR 0 3
38790: PPUSH
38791: CALL_OW 310
38795: PPUSH
38796: CALL_OW 266
38800: PUSH
38801: LD_INT 5
38803: EQUAL
38804: PUSH
38805: LD_VAR 0 3
38809: PPUSH
38810: CALL_OW 257
38814: PUSH
38815: LD_INT 1
38817: EQUAL
38818: AND
38819: PUSH
38820: LD_VAR 0 3
38824: PPUSH
38825: CALL_OW 459
38829: NOT
38830: AND
38831: PUSH
38832: LD_VAR 0 7
38836: AND
38837: IFFALSE 38853
// ComChangeProfession ( j , class ) ;
38839: LD_VAR 0 3
38843: PPUSH
38844: LD_VAR 0 7
38848: PPUSH
38849: CALL_OW 123
38853: GO 38783
38855: POP
38856: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
38857: LD_EXP 101
38861: PUSH
38862: LD_VAR 0 2
38866: ARRAY
38867: PUSH
38868: LD_EXP 121
38872: PUSH
38873: LD_VAR 0 2
38877: ARRAY
38878: NOT
38879: AND
38880: PUSH
38881: LD_EXP 100
38885: PUSH
38886: LD_VAR 0 2
38890: ARRAY
38891: NOT
38892: AND
38893: PUSH
38894: LD_EXP 78
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: PPUSH
38905: LD_INT 50
38907: PUSH
38908: EMPTY
38909: LIST
38910: PUSH
38911: LD_INT 2
38913: PUSH
38914: LD_INT 30
38916: PUSH
38917: LD_INT 32
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PUSH
38924: LD_INT 30
38926: PUSH
38927: LD_INT 33
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 30
38936: PUSH
38937: LD_INT 4
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 30
38946: PUSH
38947: LD_INT 5
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: LIST
38958: LIST
38959: LIST
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: PPUSH
38965: CALL_OW 72
38969: PUSH
38970: LD_INT 4
38972: LESS
38973: PUSH
38974: LD_EXP 78
38978: PUSH
38979: LD_VAR 0 2
38983: ARRAY
38984: PPUSH
38985: LD_INT 3
38987: PUSH
38988: LD_INT 24
38990: PUSH
38991: LD_INT 1000
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 2
39004: PUSH
39005: LD_INT 30
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 30
39017: PUSH
39018: LD_INT 1
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: LIST
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PPUSH
39034: CALL_OW 72
39038: OR
39039: AND
39040: IFFALSE 39291
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39042: LD_ADDR_EXP 121
39046: PUSH
39047: LD_EXP 121
39051: PPUSH
39052: LD_VAR 0 2
39056: PPUSH
39057: LD_INT 1
39059: PPUSH
39060: CALL_OW 1
39064: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39065: LD_ADDR_VAR 0 4
39069: PUSH
39070: LD_EXP 78
39074: PUSH
39075: LD_VAR 0 2
39079: ARRAY
39080: PPUSH
39081: LD_INT 2
39083: PUSH
39084: LD_INT 25
39086: PUSH
39087: LD_INT 1
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PUSH
39094: LD_INT 25
39096: PUSH
39097: LD_INT 5
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 25
39106: PUSH
39107: LD_INT 8
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PUSH
39114: LD_INT 25
39116: PUSH
39117: LD_INT 9
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: LIST
39128: LIST
39129: LIST
39130: PPUSH
39131: CALL_OW 72
39135: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
39136: LD_ADDR_VAR 0 4
39140: PUSH
39141: LD_VAR 0 4
39145: PUSH
39146: LD_VAR 0 4
39150: PPUSH
39151: LD_INT 18
39153: PPUSH
39154: CALL 88584 0 2
39158: DIFF
39159: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
39160: LD_VAR 0 4
39164: NOT
39165: PUSH
39166: LD_EXP 78
39170: PUSH
39171: LD_VAR 0 2
39175: ARRAY
39176: PPUSH
39177: LD_INT 2
39179: PUSH
39180: LD_INT 30
39182: PUSH
39183: LD_INT 4
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 30
39192: PUSH
39193: LD_INT 5
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: LIST
39204: PPUSH
39205: CALL_OW 72
39209: NOT
39210: AND
39211: IFFALSE 39273
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
39213: LD_ADDR_VAR 0 4
39217: PUSH
39218: LD_EXP 78
39222: PUSH
39223: LD_VAR 0 2
39227: ARRAY
39228: PPUSH
39229: LD_INT 2
39231: PUSH
39232: LD_INT 25
39234: PUSH
39235: LD_INT 2
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: LD_INT 25
39244: PUSH
39245: LD_INT 3
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 25
39254: PUSH
39255: LD_INT 4
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: LIST
39266: LIST
39267: PPUSH
39268: CALL_OW 72
39272: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
39273: LD_VAR 0 2
39277: PPUSH
39278: LD_VAR 0 4
39282: PPUSH
39283: CALL 121517 0 2
// exit ;
39287: POP
39288: POP
39289: GO 39411
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
39291: LD_EXP 101
39295: PUSH
39296: LD_VAR 0 2
39300: ARRAY
39301: PUSH
39302: LD_EXP 121
39306: PUSH
39307: LD_VAR 0 2
39311: ARRAY
39312: NOT
39313: AND
39314: PUSH
39315: LD_EXP 100
39319: PUSH
39320: LD_VAR 0 2
39324: ARRAY
39325: AND
39326: IFFALSE 39407
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39328: LD_ADDR_EXP 121
39332: PUSH
39333: LD_EXP 121
39337: PPUSH
39338: LD_VAR 0 2
39342: PPUSH
39343: LD_INT 1
39345: PPUSH
39346: CALL_OW 1
39350: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
39351: LD_ADDR_VAR 0 4
39355: PUSH
39356: LD_EXP 100
39360: PUSH
39361: LD_VAR 0 2
39365: ARRAY
39366: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39367: LD_ADDR_EXP 100
39371: PUSH
39372: LD_EXP 100
39376: PPUSH
39377: LD_VAR 0 2
39381: PPUSH
39382: EMPTY
39383: PPUSH
39384: CALL_OW 1
39388: ST_TO_ADDR
// Defend ( i , tmp ) ;
39389: LD_VAR 0 2
39393: PPUSH
39394: LD_VAR 0 4
39398: PPUSH
39399: CALL 122113 0 2
// exit ;
39403: POP
39404: POP
39405: GO 39411
// end ; end ;
39407: GO 38569
39409: POP
39410: POP
// end ;
39411: LD_VAR 0 1
39415: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
39416: LD_INT 0
39418: PPUSH
39419: PPUSH
39420: PPUSH
39421: PPUSH
39422: PPUSH
39423: PPUSH
39424: PPUSH
39425: PPUSH
39426: PPUSH
39427: PPUSH
39428: PPUSH
// if not mc_bases then
39429: LD_EXP 78
39433: NOT
39434: IFFALSE 39438
// exit ;
39436: GO 40525
// for i = 1 to mc_bases do
39438: LD_ADDR_VAR 0 2
39442: PUSH
39443: DOUBLE
39444: LD_INT 1
39446: DEC
39447: ST_TO_ADDR
39448: LD_EXP 78
39452: PUSH
39453: FOR_TO
39454: IFFALSE 40523
// begin tmp := mc_lab [ i ] ;
39456: LD_ADDR_VAR 0 6
39460: PUSH
39461: LD_EXP 111
39465: PUSH
39466: LD_VAR 0 2
39470: ARRAY
39471: ST_TO_ADDR
// if not tmp then
39472: LD_VAR 0 6
39476: NOT
39477: IFFALSE 39481
// continue ;
39479: GO 39453
// idle_lab := 0 ;
39481: LD_ADDR_VAR 0 11
39485: PUSH
39486: LD_INT 0
39488: ST_TO_ADDR
// for j in tmp do
39489: LD_ADDR_VAR 0 3
39493: PUSH
39494: LD_VAR 0 6
39498: PUSH
39499: FOR_IN
39500: IFFALSE 40519
// begin researching := false ;
39502: LD_ADDR_VAR 0 10
39506: PUSH
39507: LD_INT 0
39509: ST_TO_ADDR
// side := GetSide ( j ) ;
39510: LD_ADDR_VAR 0 4
39514: PUSH
39515: LD_VAR 0 3
39519: PPUSH
39520: CALL_OW 255
39524: ST_TO_ADDR
// if not mc_tech [ side ] then
39525: LD_EXP 105
39529: PUSH
39530: LD_VAR 0 4
39534: ARRAY
39535: NOT
39536: IFFALSE 39540
// continue ;
39538: GO 39499
// if BuildingStatus ( j ) = bs_idle then
39540: LD_VAR 0 3
39544: PPUSH
39545: CALL_OW 461
39549: PUSH
39550: LD_INT 2
39552: EQUAL
39553: IFFALSE 39741
// begin if idle_lab and UnitsInside ( j ) < 6 then
39555: LD_VAR 0 11
39559: PUSH
39560: LD_VAR 0 3
39564: PPUSH
39565: CALL_OW 313
39569: PUSH
39570: LD_INT 6
39572: LESS
39573: AND
39574: IFFALSE 39645
// begin tmp2 := UnitsInside ( idle_lab ) ;
39576: LD_ADDR_VAR 0 9
39580: PUSH
39581: LD_VAR 0 11
39585: PPUSH
39586: CALL_OW 313
39590: ST_TO_ADDR
// if tmp2 then
39591: LD_VAR 0 9
39595: IFFALSE 39637
// for x in tmp2 do
39597: LD_ADDR_VAR 0 7
39601: PUSH
39602: LD_VAR 0 9
39606: PUSH
39607: FOR_IN
39608: IFFALSE 39635
// begin ComExitBuilding ( x ) ;
39610: LD_VAR 0 7
39614: PPUSH
39615: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39619: LD_VAR 0 7
39623: PPUSH
39624: LD_VAR 0 3
39628: PPUSH
39629: CALL_OW 180
// end ;
39633: GO 39607
39635: POP
39636: POP
// idle_lab := 0 ;
39637: LD_ADDR_VAR 0 11
39641: PUSH
39642: LD_INT 0
39644: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
39645: LD_ADDR_VAR 0 5
39649: PUSH
39650: LD_EXP 105
39654: PUSH
39655: LD_VAR 0 4
39659: ARRAY
39660: PUSH
39661: FOR_IN
39662: IFFALSE 39722
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
39664: LD_VAR 0 3
39668: PPUSH
39669: LD_VAR 0 5
39673: PPUSH
39674: CALL_OW 430
39678: PUSH
39679: LD_VAR 0 4
39683: PPUSH
39684: LD_VAR 0 5
39688: PPUSH
39689: CALL 54180 0 2
39693: AND
39694: IFFALSE 39720
// begin researching := true ;
39696: LD_ADDR_VAR 0 10
39700: PUSH
39701: LD_INT 1
39703: ST_TO_ADDR
// ComResearch ( j , t ) ;
39704: LD_VAR 0 3
39708: PPUSH
39709: LD_VAR 0 5
39713: PPUSH
39714: CALL_OW 124
// break ;
39718: GO 39722
// end ;
39720: GO 39661
39722: POP
39723: POP
// if not researching then
39724: LD_VAR 0 10
39728: NOT
39729: IFFALSE 39741
// idle_lab := j ;
39731: LD_ADDR_VAR 0 11
39735: PUSH
39736: LD_VAR 0 3
39740: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
39741: LD_VAR 0 3
39745: PPUSH
39746: CALL_OW 461
39750: PUSH
39751: LD_INT 10
39753: EQUAL
39754: IFFALSE 40342
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
39756: LD_EXP 107
39760: PUSH
39761: LD_VAR 0 2
39765: ARRAY
39766: NOT
39767: PUSH
39768: LD_EXP 108
39772: PUSH
39773: LD_VAR 0 2
39777: ARRAY
39778: NOT
39779: AND
39780: PUSH
39781: LD_EXP 105
39785: PUSH
39786: LD_VAR 0 4
39790: ARRAY
39791: PUSH
39792: LD_INT 1
39794: GREATER
39795: AND
39796: IFFALSE 39927
// begin ComCancel ( j ) ;
39798: LD_VAR 0 3
39802: PPUSH
39803: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
39807: LD_ADDR_EXP 105
39811: PUSH
39812: LD_EXP 105
39816: PPUSH
39817: LD_VAR 0 4
39821: PPUSH
39822: LD_EXP 105
39826: PUSH
39827: LD_VAR 0 4
39831: ARRAY
39832: PPUSH
39833: LD_EXP 105
39837: PUSH
39838: LD_VAR 0 4
39842: ARRAY
39843: PUSH
39844: LD_INT 1
39846: MINUS
39847: PPUSH
39848: LD_EXP 105
39852: PUSH
39853: LD_VAR 0 4
39857: ARRAY
39858: PPUSH
39859: LD_INT 0
39861: PPUSH
39862: CALL 57704 0 4
39866: PPUSH
39867: CALL_OW 1
39871: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
39872: LD_ADDR_EXP 105
39876: PUSH
39877: LD_EXP 105
39881: PPUSH
39882: LD_VAR 0 4
39886: PPUSH
39887: LD_EXP 105
39891: PUSH
39892: LD_VAR 0 4
39896: ARRAY
39897: PPUSH
39898: LD_EXP 105
39902: PUSH
39903: LD_VAR 0 4
39907: ARRAY
39908: PPUSH
39909: LD_INT 1
39911: PPUSH
39912: LD_INT 0
39914: PPUSH
39915: CALL 57704 0 4
39919: PPUSH
39920: CALL_OW 1
39924: ST_TO_ADDR
// continue ;
39925: GO 39499
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
39927: LD_EXP 107
39931: PUSH
39932: LD_VAR 0 2
39936: ARRAY
39937: PUSH
39938: LD_EXP 108
39942: PUSH
39943: LD_VAR 0 2
39947: ARRAY
39948: NOT
39949: AND
39950: IFFALSE 40077
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
39952: LD_ADDR_EXP 108
39956: PUSH
39957: LD_EXP 108
39961: PPUSH
39962: LD_VAR 0 2
39966: PUSH
39967: LD_EXP 108
39971: PUSH
39972: LD_VAR 0 2
39976: ARRAY
39977: PUSH
39978: LD_INT 1
39980: PLUS
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PPUSH
39986: LD_EXP 107
39990: PUSH
39991: LD_VAR 0 2
39995: ARRAY
39996: PUSH
39997: LD_INT 1
39999: ARRAY
40000: PPUSH
40001: CALL 58286 0 3
40005: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
40006: LD_EXP 107
40010: PUSH
40011: LD_VAR 0 2
40015: ARRAY
40016: PUSH
40017: LD_INT 1
40019: ARRAY
40020: PPUSH
40021: LD_INT 112
40023: PPUSH
40024: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
40028: LD_ADDR_VAR 0 9
40032: PUSH
40033: LD_EXP 107
40037: PUSH
40038: LD_VAR 0 2
40042: ARRAY
40043: PPUSH
40044: LD_INT 1
40046: PPUSH
40047: CALL_OW 3
40051: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
40052: LD_ADDR_EXP 107
40056: PUSH
40057: LD_EXP 107
40061: PPUSH
40062: LD_VAR 0 2
40066: PPUSH
40067: LD_VAR 0 9
40071: PPUSH
40072: CALL_OW 1
40076: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
40077: LD_EXP 107
40081: PUSH
40082: LD_VAR 0 2
40086: ARRAY
40087: PUSH
40088: LD_EXP 108
40092: PUSH
40093: LD_VAR 0 2
40097: ARRAY
40098: AND
40099: PUSH
40100: LD_EXP 108
40104: PUSH
40105: LD_VAR 0 2
40109: ARRAY
40110: PUSH
40111: LD_INT 1
40113: ARRAY
40114: PPUSH
40115: CALL_OW 310
40119: NOT
40120: AND
40121: PUSH
40122: LD_VAR 0 3
40126: PPUSH
40127: CALL_OW 313
40131: PUSH
40132: LD_INT 6
40134: EQUAL
40135: AND
40136: IFFALSE 40192
// begin tmp2 := UnitsInside ( j ) ;
40138: LD_ADDR_VAR 0 9
40142: PUSH
40143: LD_VAR 0 3
40147: PPUSH
40148: CALL_OW 313
40152: ST_TO_ADDR
// if tmp2 = 6 then
40153: LD_VAR 0 9
40157: PUSH
40158: LD_INT 6
40160: EQUAL
40161: IFFALSE 40192
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
40163: LD_VAR 0 9
40167: PUSH
40168: LD_INT 1
40170: ARRAY
40171: PPUSH
40172: LD_INT 112
40174: PPUSH
40175: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
40179: LD_VAR 0 9
40183: PUSH
40184: LD_INT 1
40186: ARRAY
40187: PPUSH
40188: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
40192: LD_EXP 108
40196: PUSH
40197: LD_VAR 0 2
40201: ARRAY
40202: PUSH
40203: LD_EXP 108
40207: PUSH
40208: LD_VAR 0 2
40212: ARRAY
40213: PUSH
40214: LD_INT 1
40216: ARRAY
40217: PPUSH
40218: CALL_OW 314
40222: NOT
40223: AND
40224: PUSH
40225: LD_EXP 108
40229: PUSH
40230: LD_VAR 0 2
40234: ARRAY
40235: PUSH
40236: LD_INT 1
40238: ARRAY
40239: PPUSH
40240: CALL_OW 310
40244: NOT
40245: AND
40246: IFFALSE 40272
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
40248: LD_EXP 108
40252: PUSH
40253: LD_VAR 0 2
40257: ARRAY
40258: PUSH
40259: LD_INT 1
40261: ARRAY
40262: PPUSH
40263: LD_VAR 0 3
40267: PPUSH
40268: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
40272: LD_EXP 108
40276: PUSH
40277: LD_VAR 0 2
40281: ARRAY
40282: PUSH
40283: LD_INT 1
40285: ARRAY
40286: PPUSH
40287: CALL_OW 310
40291: PUSH
40292: LD_EXP 108
40296: PUSH
40297: LD_VAR 0 2
40301: ARRAY
40302: PUSH
40303: LD_INT 1
40305: ARRAY
40306: PPUSH
40307: CALL_OW 310
40311: PPUSH
40312: CALL_OW 461
40316: PUSH
40317: LD_INT 3
40319: NONEQUAL
40320: AND
40321: IFFALSE 40342
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
40323: LD_EXP 108
40327: PUSH
40328: LD_VAR 0 2
40332: ARRAY
40333: PUSH
40334: LD_INT 1
40336: ARRAY
40337: PPUSH
40338: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
40342: LD_VAR 0 3
40346: PPUSH
40347: CALL_OW 461
40351: PUSH
40352: LD_INT 6
40354: EQUAL
40355: PUSH
40356: LD_VAR 0 6
40360: PUSH
40361: LD_INT 1
40363: GREATER
40364: AND
40365: IFFALSE 40517
// begin sci := [ ] ;
40367: LD_ADDR_VAR 0 8
40371: PUSH
40372: EMPTY
40373: ST_TO_ADDR
// for x in ( tmp diff j ) do
40374: LD_ADDR_VAR 0 7
40378: PUSH
40379: LD_VAR 0 6
40383: PUSH
40384: LD_VAR 0 3
40388: DIFF
40389: PUSH
40390: FOR_IN
40391: IFFALSE 40443
// begin if sci = 6 then
40393: LD_VAR 0 8
40397: PUSH
40398: LD_INT 6
40400: EQUAL
40401: IFFALSE 40405
// break ;
40403: GO 40443
// if BuildingStatus ( x ) = bs_idle then
40405: LD_VAR 0 7
40409: PPUSH
40410: CALL_OW 461
40414: PUSH
40415: LD_INT 2
40417: EQUAL
40418: IFFALSE 40441
// sci := sci ^ UnitsInside ( x ) ;
40420: LD_ADDR_VAR 0 8
40424: PUSH
40425: LD_VAR 0 8
40429: PUSH
40430: LD_VAR 0 7
40434: PPUSH
40435: CALL_OW 313
40439: ADD
40440: ST_TO_ADDR
// end ;
40441: GO 40390
40443: POP
40444: POP
// if not sci then
40445: LD_VAR 0 8
40449: NOT
40450: IFFALSE 40454
// continue ;
40452: GO 39499
// for x in sci do
40454: LD_ADDR_VAR 0 7
40458: PUSH
40459: LD_VAR 0 8
40463: PUSH
40464: FOR_IN
40465: IFFALSE 40515
// if IsInUnit ( x ) and not HasTask ( x ) then
40467: LD_VAR 0 7
40471: PPUSH
40472: CALL_OW 310
40476: PUSH
40477: LD_VAR 0 7
40481: PPUSH
40482: CALL_OW 314
40486: NOT
40487: AND
40488: IFFALSE 40513
// begin ComExitBuilding ( x ) ;
40490: LD_VAR 0 7
40494: PPUSH
40495: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40499: LD_VAR 0 7
40503: PPUSH
40504: LD_VAR 0 3
40508: PPUSH
40509: CALL_OW 180
// end ;
40513: GO 40464
40515: POP
40516: POP
// end ; end ;
40517: GO 39499
40519: POP
40520: POP
// end ;
40521: GO 39453
40523: POP
40524: POP
// end ;
40525: LD_VAR 0 1
40529: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40530: LD_INT 0
40532: PPUSH
40533: PPUSH
// if not mc_bases then
40534: LD_EXP 78
40538: NOT
40539: IFFALSE 40543
// exit ;
40541: GO 40624
// for i = 1 to mc_bases do
40543: LD_ADDR_VAR 0 2
40547: PUSH
40548: DOUBLE
40549: LD_INT 1
40551: DEC
40552: ST_TO_ADDR
40553: LD_EXP 78
40557: PUSH
40558: FOR_TO
40559: IFFALSE 40622
// if mc_mines [ i ] and mc_miners [ i ] then
40561: LD_EXP 91
40565: PUSH
40566: LD_VAR 0 2
40570: ARRAY
40571: PUSH
40572: LD_EXP 92
40576: PUSH
40577: LD_VAR 0 2
40581: ARRAY
40582: AND
40583: IFFALSE 40620
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40585: LD_EXP 92
40589: PUSH
40590: LD_VAR 0 2
40594: ARRAY
40595: PUSH
40596: LD_INT 1
40598: ARRAY
40599: PPUSH
40600: CALL_OW 255
40604: PPUSH
40605: LD_EXP 91
40609: PUSH
40610: LD_VAR 0 2
40614: ARRAY
40615: PPUSH
40616: CALL 55263 0 2
40620: GO 40558
40622: POP
40623: POP
// end ;
40624: LD_VAR 0 1
40628: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
40629: LD_INT 0
40631: PPUSH
40632: PPUSH
40633: PPUSH
40634: PPUSH
40635: PPUSH
40636: PPUSH
40637: PPUSH
40638: PPUSH
// if not mc_bases or not mc_parking then
40639: LD_EXP 78
40643: NOT
40644: PUSH
40645: LD_EXP 102
40649: NOT
40650: OR
40651: IFFALSE 40655
// exit ;
40653: GO 41393
// for i = 1 to mc_bases do
40655: LD_ADDR_VAR 0 2
40659: PUSH
40660: DOUBLE
40661: LD_INT 1
40663: DEC
40664: ST_TO_ADDR
40665: LD_EXP 78
40669: PUSH
40670: FOR_TO
40671: IFFALSE 41391
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
40673: LD_EXP 78
40677: PUSH
40678: LD_VAR 0 2
40682: ARRAY
40683: NOT
40684: PUSH
40685: LD_EXP 102
40689: PUSH
40690: LD_VAR 0 2
40694: ARRAY
40695: NOT
40696: OR
40697: IFFALSE 40701
// continue ;
40699: GO 40670
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
40701: LD_ADDR_VAR 0 5
40705: PUSH
40706: LD_EXP 78
40710: PUSH
40711: LD_VAR 0 2
40715: ARRAY
40716: PUSH
40717: LD_INT 1
40719: ARRAY
40720: PPUSH
40721: CALL_OW 255
40725: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40726: LD_ADDR_VAR 0 6
40730: PUSH
40731: LD_EXP 78
40735: PUSH
40736: LD_VAR 0 2
40740: ARRAY
40741: PPUSH
40742: LD_INT 30
40744: PUSH
40745: LD_INT 3
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PPUSH
40752: CALL_OW 72
40756: ST_TO_ADDR
// if not fac then
40757: LD_VAR 0 6
40761: NOT
40762: IFFALSE 40813
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40764: LD_ADDR_VAR 0 6
40768: PUSH
40769: LD_EXP 78
40773: PUSH
40774: LD_VAR 0 2
40778: ARRAY
40779: PPUSH
40780: LD_INT 2
40782: PUSH
40783: LD_INT 30
40785: PUSH
40786: LD_INT 0
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 30
40795: PUSH
40796: LD_INT 1
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: LIST
40807: PPUSH
40808: CALL_OW 72
40812: ST_TO_ADDR
// if not fac then
40813: LD_VAR 0 6
40817: NOT
40818: IFFALSE 40822
// continue ;
40820: GO 40670
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40822: LD_ADDR_VAR 0 7
40826: PUSH
40827: LD_EXP 102
40831: PUSH
40832: LD_VAR 0 2
40836: ARRAY
40837: PPUSH
40838: LD_INT 22
40840: PUSH
40841: LD_VAR 0 5
40845: PUSH
40846: EMPTY
40847: LIST
40848: LIST
40849: PUSH
40850: LD_INT 21
40852: PUSH
40853: LD_INT 2
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: LD_INT 3
40862: PUSH
40863: LD_INT 60
40865: PUSH
40866: EMPTY
40867: LIST
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: PUSH
40873: LD_INT 3
40875: PUSH
40876: LD_INT 24
40878: PUSH
40879: LD_INT 1000
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: LIST
40894: LIST
40895: PPUSH
40896: CALL_OW 70
40900: ST_TO_ADDR
// for j in fac do
40901: LD_ADDR_VAR 0 3
40905: PUSH
40906: LD_VAR 0 6
40910: PUSH
40911: FOR_IN
40912: IFFALSE 41007
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40914: LD_ADDR_VAR 0 7
40918: PUSH
40919: LD_VAR 0 7
40923: PUSH
40924: LD_INT 22
40926: PUSH
40927: LD_VAR 0 5
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 91
40938: PUSH
40939: LD_VAR 0 3
40943: PUSH
40944: LD_INT 15
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: LIST
40951: PUSH
40952: LD_INT 21
40954: PUSH
40955: LD_INT 2
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: LD_INT 3
40964: PUSH
40965: LD_INT 60
40967: PUSH
40968: EMPTY
40969: LIST
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 3
40977: PUSH
40978: LD_INT 24
40980: PUSH
40981: LD_INT 1000
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: PPUSH
40999: CALL_OW 69
41003: UNION
41004: ST_TO_ADDR
41005: GO 40911
41007: POP
41008: POP
// if not vehs then
41009: LD_VAR 0 7
41013: NOT
41014: IFFALSE 41040
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41016: LD_ADDR_EXP 90
41020: PUSH
41021: LD_EXP 90
41025: PPUSH
41026: LD_VAR 0 2
41030: PPUSH
41031: EMPTY
41032: PPUSH
41033: CALL_OW 1
41037: ST_TO_ADDR
// continue ;
41038: GO 40670
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
41040: LD_ADDR_VAR 0 8
41044: PUSH
41045: LD_EXP 78
41049: PUSH
41050: LD_VAR 0 2
41054: ARRAY
41055: PPUSH
41056: LD_INT 30
41058: PUSH
41059: LD_INT 3
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: PPUSH
41066: CALL_OW 72
41070: ST_TO_ADDR
// if tmp then
41071: LD_VAR 0 8
41075: IFFALSE 41178
// begin for j in tmp do
41077: LD_ADDR_VAR 0 3
41081: PUSH
41082: LD_VAR 0 8
41086: PUSH
41087: FOR_IN
41088: IFFALSE 41176
// for k in UnitsInside ( j ) do
41090: LD_ADDR_VAR 0 4
41094: PUSH
41095: LD_VAR 0 3
41099: PPUSH
41100: CALL_OW 313
41104: PUSH
41105: FOR_IN
41106: IFFALSE 41172
// if k then
41108: LD_VAR 0 4
41112: IFFALSE 41170
// if not k in mc_repair_vehicle [ i ] then
41114: LD_VAR 0 4
41118: PUSH
41119: LD_EXP 90
41123: PUSH
41124: LD_VAR 0 2
41128: ARRAY
41129: IN
41130: NOT
41131: IFFALSE 41170
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
41133: LD_ADDR_EXP 90
41137: PUSH
41138: LD_EXP 90
41142: PPUSH
41143: LD_VAR 0 2
41147: PPUSH
41148: LD_EXP 90
41152: PUSH
41153: LD_VAR 0 2
41157: ARRAY
41158: PUSH
41159: LD_VAR 0 4
41163: UNION
41164: PPUSH
41165: CALL_OW 1
41169: ST_TO_ADDR
41170: GO 41105
41172: POP
41173: POP
41174: GO 41087
41176: POP
41177: POP
// end ; if not mc_repair_vehicle [ i ] then
41178: LD_EXP 90
41182: PUSH
41183: LD_VAR 0 2
41187: ARRAY
41188: NOT
41189: IFFALSE 41193
// continue ;
41191: GO 40670
// for j in mc_repair_vehicle [ i ] do
41193: LD_ADDR_VAR 0 3
41197: PUSH
41198: LD_EXP 90
41202: PUSH
41203: LD_VAR 0 2
41207: ARRAY
41208: PUSH
41209: FOR_IN
41210: IFFALSE 41387
// begin if GetClass ( j ) <> 3 then
41212: LD_VAR 0 3
41216: PPUSH
41217: CALL_OW 257
41221: PUSH
41222: LD_INT 3
41224: NONEQUAL
41225: IFFALSE 41266
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
41227: LD_ADDR_EXP 90
41231: PUSH
41232: LD_EXP 90
41236: PPUSH
41237: LD_VAR 0 2
41241: PPUSH
41242: LD_EXP 90
41246: PUSH
41247: LD_VAR 0 2
41251: ARRAY
41252: PUSH
41253: LD_VAR 0 3
41257: DIFF
41258: PPUSH
41259: CALL_OW 1
41263: ST_TO_ADDR
// continue ;
41264: GO 41209
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41266: LD_VAR 0 3
41270: PPUSH
41271: CALL_OW 311
41275: NOT
41276: PUSH
41277: LD_VAR 0 3
41281: PUSH
41282: LD_EXP 81
41286: PUSH
41287: LD_VAR 0 2
41291: ARRAY
41292: PUSH
41293: LD_INT 1
41295: ARRAY
41296: IN
41297: NOT
41298: AND
41299: PUSH
41300: LD_VAR 0 3
41304: PUSH
41305: LD_EXP 81
41309: PUSH
41310: LD_VAR 0 2
41314: ARRAY
41315: PUSH
41316: LD_INT 2
41318: ARRAY
41319: IN
41320: NOT
41321: AND
41322: IFFALSE 41385
// begin if IsInUnit ( j ) then
41324: LD_VAR 0 3
41328: PPUSH
41329: CALL_OW 310
41333: IFFALSE 41346
// ComExitBuilding ( j ) else
41335: LD_VAR 0 3
41339: PPUSH
41340: CALL_OW 122
41344: GO 41385
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
41346: LD_VAR 0 3
41350: PPUSH
41351: LD_VAR 0 7
41355: PUSH
41356: LD_INT 1
41358: ARRAY
41359: PPUSH
41360: CALL 93080 0 2
41364: NOT
41365: IFFALSE 41385
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
41367: LD_VAR 0 3
41371: PPUSH
41372: LD_VAR 0 7
41376: PUSH
41377: LD_INT 1
41379: ARRAY
41380: PPUSH
41381: CALL_OW 129
// end ; end ;
41385: GO 41209
41387: POP
41388: POP
// end ;
41389: GO 40670
41391: POP
41392: POP
// end ;
41393: LD_VAR 0 1
41397: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
41398: LD_INT 0
41400: PPUSH
41401: PPUSH
41402: PPUSH
41403: PPUSH
41404: PPUSH
41405: PPUSH
41406: PPUSH
41407: PPUSH
41408: PPUSH
41409: PPUSH
41410: PPUSH
// if not mc_bases then
41411: LD_EXP 78
41415: NOT
41416: IFFALSE 41420
// exit ;
41418: GO 42222
// for i = 1 to mc_bases do
41420: LD_ADDR_VAR 0 2
41424: PUSH
41425: DOUBLE
41426: LD_INT 1
41428: DEC
41429: ST_TO_ADDR
41430: LD_EXP 78
41434: PUSH
41435: FOR_TO
41436: IFFALSE 42220
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
41438: LD_EXP 106
41442: PUSH
41443: LD_VAR 0 2
41447: ARRAY
41448: NOT
41449: PUSH
41450: LD_EXP 81
41454: PUSH
41455: LD_VAR 0 2
41459: ARRAY
41460: PUSH
41461: LD_INT 1
41463: ARRAY
41464: OR
41465: PUSH
41466: LD_EXP 81
41470: PUSH
41471: LD_VAR 0 2
41475: ARRAY
41476: PUSH
41477: LD_INT 2
41479: ARRAY
41480: OR
41481: PUSH
41482: LD_EXP 104
41486: PUSH
41487: LD_VAR 0 2
41491: ARRAY
41492: PPUSH
41493: LD_INT 1
41495: PPUSH
41496: CALL_OW 325
41500: NOT
41501: OR
41502: PUSH
41503: LD_EXP 101
41507: PUSH
41508: LD_VAR 0 2
41512: ARRAY
41513: OR
41514: IFFALSE 41518
// continue ;
41516: GO 41435
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41518: LD_ADDR_VAR 0 8
41522: PUSH
41523: LD_EXP 78
41527: PUSH
41528: LD_VAR 0 2
41532: ARRAY
41533: PPUSH
41534: LD_INT 25
41536: PUSH
41537: LD_INT 4
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 50
41546: PUSH
41547: EMPTY
41548: LIST
41549: PUSH
41550: LD_INT 3
41552: PUSH
41553: LD_INT 60
41555: PUSH
41556: EMPTY
41557: LIST
41558: PUSH
41559: EMPTY
41560: LIST
41561: LIST
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: LIST
41567: PPUSH
41568: CALL_OW 72
41572: PUSH
41573: LD_EXP 82
41577: PUSH
41578: LD_VAR 0 2
41582: ARRAY
41583: DIFF
41584: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41585: LD_ADDR_VAR 0 9
41589: PUSH
41590: LD_EXP 78
41594: PUSH
41595: LD_VAR 0 2
41599: ARRAY
41600: PPUSH
41601: LD_INT 2
41603: PUSH
41604: LD_INT 30
41606: PUSH
41607: LD_INT 0
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: LD_INT 30
41616: PUSH
41617: LD_INT 1
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: PUSH
41624: EMPTY
41625: LIST
41626: LIST
41627: LIST
41628: PPUSH
41629: CALL_OW 72
41633: ST_TO_ADDR
// if not tmp or not dep then
41634: LD_VAR 0 8
41638: NOT
41639: PUSH
41640: LD_VAR 0 9
41644: NOT
41645: OR
41646: IFFALSE 41650
// continue ;
41648: GO 41435
// side := GetSide ( tmp [ 1 ] ) ;
41650: LD_ADDR_VAR 0 11
41654: PUSH
41655: LD_VAR 0 8
41659: PUSH
41660: LD_INT 1
41662: ARRAY
41663: PPUSH
41664: CALL_OW 255
41668: ST_TO_ADDR
// dep := dep [ 1 ] ;
41669: LD_ADDR_VAR 0 9
41673: PUSH
41674: LD_VAR 0 9
41678: PUSH
41679: LD_INT 1
41681: ARRAY
41682: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
41683: LD_ADDR_VAR 0 7
41687: PUSH
41688: LD_EXP 106
41692: PUSH
41693: LD_VAR 0 2
41697: ARRAY
41698: PPUSH
41699: LD_INT 22
41701: PUSH
41702: LD_INT 0
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: LD_INT 25
41711: PUSH
41712: LD_INT 12
41714: PUSH
41715: EMPTY
41716: LIST
41717: LIST
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PPUSH
41723: CALL_OW 70
41727: PUSH
41728: LD_INT 22
41730: PUSH
41731: LD_INT 0
41733: PUSH
41734: EMPTY
41735: LIST
41736: LIST
41737: PUSH
41738: LD_INT 25
41740: PUSH
41741: LD_INT 12
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 91
41750: PUSH
41751: LD_VAR 0 9
41755: PUSH
41756: LD_INT 20
41758: PUSH
41759: EMPTY
41760: LIST
41761: LIST
41762: LIST
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: LIST
41768: PPUSH
41769: CALL_OW 69
41773: UNION
41774: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
41775: LD_ADDR_VAR 0 10
41779: PUSH
41780: LD_EXP 106
41784: PUSH
41785: LD_VAR 0 2
41789: ARRAY
41790: PPUSH
41791: LD_INT 81
41793: PUSH
41794: LD_VAR 0 11
41798: PUSH
41799: EMPTY
41800: LIST
41801: LIST
41802: PPUSH
41803: CALL_OW 70
41807: ST_TO_ADDR
// if not apes or danger_at_area then
41808: LD_VAR 0 7
41812: NOT
41813: PUSH
41814: LD_VAR 0 10
41818: OR
41819: IFFALSE 41869
// begin if mc_taming [ i ] then
41821: LD_EXP 109
41825: PUSH
41826: LD_VAR 0 2
41830: ARRAY
41831: IFFALSE 41867
// begin MC_Reset ( i , 121 ) ;
41833: LD_VAR 0 2
41837: PPUSH
41838: LD_INT 121
41840: PPUSH
41841: CALL 26785 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41845: LD_ADDR_EXP 109
41849: PUSH
41850: LD_EXP 109
41854: PPUSH
41855: LD_VAR 0 2
41859: PPUSH
41860: EMPTY
41861: PPUSH
41862: CALL_OW 1
41866: ST_TO_ADDR
// end ; continue ;
41867: GO 41435
// end ; for j in tmp do
41869: LD_ADDR_VAR 0 3
41873: PUSH
41874: LD_VAR 0 8
41878: PUSH
41879: FOR_IN
41880: IFFALSE 42216
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
41882: LD_VAR 0 3
41886: PUSH
41887: LD_EXP 109
41891: PUSH
41892: LD_VAR 0 2
41896: ARRAY
41897: IN
41898: NOT
41899: PUSH
41900: LD_EXP 109
41904: PUSH
41905: LD_VAR 0 2
41909: ARRAY
41910: PUSH
41911: LD_INT 3
41913: LESS
41914: AND
41915: IFFALSE 41973
// begin SetTag ( j , 121 ) ;
41917: LD_VAR 0 3
41921: PPUSH
41922: LD_INT 121
41924: PPUSH
41925: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
41929: LD_ADDR_EXP 109
41933: PUSH
41934: LD_EXP 109
41938: PPUSH
41939: LD_VAR 0 2
41943: PUSH
41944: LD_EXP 109
41948: PUSH
41949: LD_VAR 0 2
41953: ARRAY
41954: PUSH
41955: LD_INT 1
41957: PLUS
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PPUSH
41963: LD_VAR 0 3
41967: PPUSH
41968: CALL 58286 0 3
41972: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
41973: LD_VAR 0 3
41977: PUSH
41978: LD_EXP 109
41982: PUSH
41983: LD_VAR 0 2
41987: ARRAY
41988: IN
41989: IFFALSE 42214
// begin if GetClass ( j ) <> 4 then
41991: LD_VAR 0 3
41995: PPUSH
41996: CALL_OW 257
42000: PUSH
42001: LD_INT 4
42003: NONEQUAL
42004: IFFALSE 42057
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
42006: LD_ADDR_EXP 109
42010: PUSH
42011: LD_EXP 109
42015: PPUSH
42016: LD_VAR 0 2
42020: PPUSH
42021: LD_EXP 109
42025: PUSH
42026: LD_VAR 0 2
42030: ARRAY
42031: PUSH
42032: LD_VAR 0 3
42036: DIFF
42037: PPUSH
42038: CALL_OW 1
42042: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42043: LD_VAR 0 3
42047: PPUSH
42048: LD_INT 0
42050: PPUSH
42051: CALL_OW 109
// continue ;
42055: GO 41879
// end ; if IsInUnit ( j ) then
42057: LD_VAR 0 3
42061: PPUSH
42062: CALL_OW 310
42066: IFFALSE 42077
// ComExitBuilding ( j ) ;
42068: LD_VAR 0 3
42072: PPUSH
42073: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
42077: LD_ADDR_VAR 0 6
42081: PUSH
42082: LD_VAR 0 7
42086: PPUSH
42087: LD_VAR 0 3
42091: PPUSH
42092: CALL_OW 74
42096: ST_TO_ADDR
// if not ape then
42097: LD_VAR 0 6
42101: NOT
42102: IFFALSE 42106
// break ;
42104: GO 42216
// x := GetX ( ape ) ;
42106: LD_ADDR_VAR 0 4
42110: PUSH
42111: LD_VAR 0 6
42115: PPUSH
42116: CALL_OW 250
42120: ST_TO_ADDR
// y := GetY ( ape ) ;
42121: LD_ADDR_VAR 0 5
42125: PUSH
42126: LD_VAR 0 6
42130: PPUSH
42131: CALL_OW 251
42135: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
42136: LD_VAR 0 4
42140: PPUSH
42141: LD_VAR 0 5
42145: PPUSH
42146: CALL_OW 488
42150: NOT
42151: PUSH
42152: LD_VAR 0 11
42156: PPUSH
42157: LD_VAR 0 4
42161: PPUSH
42162: LD_VAR 0 5
42166: PPUSH
42167: LD_INT 20
42169: PPUSH
42170: CALL 59550 0 4
42174: PUSH
42175: LD_INT 4
42177: ARRAY
42178: OR
42179: IFFALSE 42183
// break ;
42181: GO 42216
// if not HasTask ( j ) then
42183: LD_VAR 0 3
42187: PPUSH
42188: CALL_OW 314
42192: NOT
42193: IFFALSE 42214
// ComTameXY ( j , x , y ) ;
42195: LD_VAR 0 3
42199: PPUSH
42200: LD_VAR 0 4
42204: PPUSH
42205: LD_VAR 0 5
42209: PPUSH
42210: CALL_OW 131
// end ; end ;
42214: GO 41879
42216: POP
42217: POP
// end ;
42218: GO 41435
42220: POP
42221: POP
// end ;
42222: LD_VAR 0 1
42226: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
42227: LD_INT 0
42229: PPUSH
42230: PPUSH
42231: PPUSH
42232: PPUSH
42233: PPUSH
42234: PPUSH
42235: PPUSH
42236: PPUSH
// if not mc_bases then
42237: LD_EXP 78
42241: NOT
42242: IFFALSE 42246
// exit ;
42244: GO 42872
// for i = 1 to mc_bases do
42246: LD_ADDR_VAR 0 2
42250: PUSH
42251: DOUBLE
42252: LD_INT 1
42254: DEC
42255: ST_TO_ADDR
42256: LD_EXP 78
42260: PUSH
42261: FOR_TO
42262: IFFALSE 42870
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
42264: LD_EXP 107
42268: PUSH
42269: LD_VAR 0 2
42273: ARRAY
42274: NOT
42275: PUSH
42276: LD_EXP 107
42280: PUSH
42281: LD_VAR 0 2
42285: ARRAY
42286: PPUSH
42287: LD_INT 25
42289: PUSH
42290: LD_INT 12
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PPUSH
42297: CALL_OW 72
42301: NOT
42302: OR
42303: IFFALSE 42307
// continue ;
42305: GO 42261
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
42307: LD_ADDR_VAR 0 5
42311: PUSH
42312: LD_EXP 107
42316: PUSH
42317: LD_VAR 0 2
42321: ARRAY
42322: PUSH
42323: LD_INT 1
42325: ARRAY
42326: PPUSH
42327: CALL_OW 255
42331: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
42332: LD_VAR 0 5
42336: PPUSH
42337: LD_INT 2
42339: PPUSH
42340: CALL_OW 325
42344: IFFALSE 42597
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42346: LD_ADDR_VAR 0 4
42350: PUSH
42351: LD_EXP 107
42355: PUSH
42356: LD_VAR 0 2
42360: ARRAY
42361: PPUSH
42362: LD_INT 25
42364: PUSH
42365: LD_INT 16
42367: PUSH
42368: EMPTY
42369: LIST
42370: LIST
42371: PPUSH
42372: CALL_OW 72
42376: ST_TO_ADDR
// if tmp < 6 then
42377: LD_VAR 0 4
42381: PUSH
42382: LD_INT 6
42384: LESS
42385: IFFALSE 42597
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42387: LD_ADDR_VAR 0 6
42391: PUSH
42392: LD_EXP 78
42396: PUSH
42397: LD_VAR 0 2
42401: ARRAY
42402: PPUSH
42403: LD_INT 2
42405: PUSH
42406: LD_INT 30
42408: PUSH
42409: LD_INT 0
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 30
42418: PUSH
42419: LD_INT 1
42421: PUSH
42422: EMPTY
42423: LIST
42424: LIST
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: LIST
42430: PPUSH
42431: CALL_OW 72
42435: ST_TO_ADDR
// if depot then
42436: LD_VAR 0 6
42440: IFFALSE 42597
// begin selected := 0 ;
42442: LD_ADDR_VAR 0 7
42446: PUSH
42447: LD_INT 0
42449: ST_TO_ADDR
// for j in depot do
42450: LD_ADDR_VAR 0 3
42454: PUSH
42455: LD_VAR 0 6
42459: PUSH
42460: FOR_IN
42461: IFFALSE 42492
// begin if UnitsInside ( j ) < 6 then
42463: LD_VAR 0 3
42467: PPUSH
42468: CALL_OW 313
42472: PUSH
42473: LD_INT 6
42475: LESS
42476: IFFALSE 42490
// begin selected := j ;
42478: LD_ADDR_VAR 0 7
42482: PUSH
42483: LD_VAR 0 3
42487: ST_TO_ADDR
// break ;
42488: GO 42492
// end ; end ;
42490: GO 42460
42492: POP
42493: POP
// if selected then
42494: LD_VAR 0 7
42498: IFFALSE 42597
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42500: LD_ADDR_VAR 0 3
42504: PUSH
42505: LD_EXP 107
42509: PUSH
42510: LD_VAR 0 2
42514: ARRAY
42515: PPUSH
42516: LD_INT 25
42518: PUSH
42519: LD_INT 12
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PPUSH
42526: CALL_OW 72
42530: PUSH
42531: FOR_IN
42532: IFFALSE 42595
// if not HasTask ( j ) then
42534: LD_VAR 0 3
42538: PPUSH
42539: CALL_OW 314
42543: NOT
42544: IFFALSE 42593
// begin if not IsInUnit ( j ) then
42546: LD_VAR 0 3
42550: PPUSH
42551: CALL_OW 310
42555: NOT
42556: IFFALSE 42572
// ComEnterUnit ( j , selected ) ;
42558: LD_VAR 0 3
42562: PPUSH
42563: LD_VAR 0 7
42567: PPUSH
42568: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42572: LD_VAR 0 3
42576: PPUSH
42577: LD_INT 16
42579: PPUSH
42580: CALL_OW 183
// AddComExitBuilding ( j ) ;
42584: LD_VAR 0 3
42588: PPUSH
42589: CALL_OW 182
// end ;
42593: GO 42531
42595: POP
42596: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
42597: LD_VAR 0 5
42601: PPUSH
42602: LD_INT 11
42604: PPUSH
42605: CALL_OW 325
42609: IFFALSE 42868
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42611: LD_ADDR_VAR 0 4
42615: PUSH
42616: LD_EXP 107
42620: PUSH
42621: LD_VAR 0 2
42625: ARRAY
42626: PPUSH
42627: LD_INT 25
42629: PUSH
42630: LD_INT 16
42632: PUSH
42633: EMPTY
42634: LIST
42635: LIST
42636: PPUSH
42637: CALL_OW 72
42641: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
42642: LD_VAR 0 4
42646: PUSH
42647: LD_INT 6
42649: GREATEREQUAL
42650: PUSH
42651: LD_VAR 0 5
42655: PPUSH
42656: LD_INT 2
42658: PPUSH
42659: CALL_OW 325
42663: NOT
42664: OR
42665: IFFALSE 42868
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42667: LD_ADDR_VAR 0 8
42671: PUSH
42672: LD_EXP 78
42676: PUSH
42677: LD_VAR 0 2
42681: ARRAY
42682: PPUSH
42683: LD_INT 2
42685: PUSH
42686: LD_INT 30
42688: PUSH
42689: LD_INT 4
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: LD_INT 30
42698: PUSH
42699: LD_INT 5
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: LIST
42710: PPUSH
42711: CALL_OW 72
42715: ST_TO_ADDR
// if barracks then
42716: LD_VAR 0 8
42720: IFFALSE 42868
// begin selected := 0 ;
42722: LD_ADDR_VAR 0 7
42726: PUSH
42727: LD_INT 0
42729: ST_TO_ADDR
// for j in barracks do
42730: LD_ADDR_VAR 0 3
42734: PUSH
42735: LD_VAR 0 8
42739: PUSH
42740: FOR_IN
42741: IFFALSE 42772
// begin if UnitsInside ( j ) < 6 then
42743: LD_VAR 0 3
42747: PPUSH
42748: CALL_OW 313
42752: PUSH
42753: LD_INT 6
42755: LESS
42756: IFFALSE 42770
// begin selected := j ;
42758: LD_ADDR_VAR 0 7
42762: PUSH
42763: LD_VAR 0 3
42767: ST_TO_ADDR
// break ;
42768: GO 42772
// end ; end ;
42770: GO 42740
42772: POP
42773: POP
// if selected then
42774: LD_VAR 0 7
42778: IFFALSE 42868
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42780: LD_ADDR_VAR 0 3
42784: PUSH
42785: LD_EXP 107
42789: PUSH
42790: LD_VAR 0 2
42794: ARRAY
42795: PPUSH
42796: LD_INT 25
42798: PUSH
42799: LD_INT 12
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PPUSH
42806: CALL_OW 72
42810: PUSH
42811: FOR_IN
42812: IFFALSE 42866
// if not IsInUnit ( j ) and not HasTask ( j ) then
42814: LD_VAR 0 3
42818: PPUSH
42819: CALL_OW 310
42823: NOT
42824: PUSH
42825: LD_VAR 0 3
42829: PPUSH
42830: CALL_OW 314
42834: NOT
42835: AND
42836: IFFALSE 42864
// begin ComEnterUnit ( j , selected ) ;
42838: LD_VAR 0 3
42842: PPUSH
42843: LD_VAR 0 7
42847: PPUSH
42848: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
42852: LD_VAR 0 3
42856: PPUSH
42857: LD_INT 15
42859: PPUSH
42860: CALL_OW 183
// end ;
42864: GO 42811
42866: POP
42867: POP
// end ; end ; end ; end ; end ;
42868: GO 42261
42870: POP
42871: POP
// end ;
42872: LD_VAR 0 1
42876: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
42877: LD_INT 0
42879: PPUSH
42880: PPUSH
42881: PPUSH
42882: PPUSH
// if not mc_bases then
42883: LD_EXP 78
42887: NOT
42888: IFFALSE 42892
// exit ;
42890: GO 43070
// for i = 1 to mc_bases do
42892: LD_ADDR_VAR 0 2
42896: PUSH
42897: DOUBLE
42898: LD_INT 1
42900: DEC
42901: ST_TO_ADDR
42902: LD_EXP 78
42906: PUSH
42907: FOR_TO
42908: IFFALSE 43068
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
42910: LD_ADDR_VAR 0 4
42914: PUSH
42915: LD_EXP 78
42919: PUSH
42920: LD_VAR 0 2
42924: ARRAY
42925: PPUSH
42926: LD_INT 25
42928: PUSH
42929: LD_INT 9
42931: PUSH
42932: EMPTY
42933: LIST
42934: LIST
42935: PPUSH
42936: CALL_OW 72
42940: ST_TO_ADDR
// if not tmp then
42941: LD_VAR 0 4
42945: NOT
42946: IFFALSE 42950
// continue ;
42948: GO 42907
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
42950: LD_EXP 104
42954: PUSH
42955: LD_VAR 0 2
42959: ARRAY
42960: PPUSH
42961: LD_INT 29
42963: PPUSH
42964: CALL_OW 325
42968: NOT
42969: PUSH
42970: LD_EXP 104
42974: PUSH
42975: LD_VAR 0 2
42979: ARRAY
42980: PPUSH
42981: LD_INT 28
42983: PPUSH
42984: CALL_OW 325
42988: NOT
42989: AND
42990: IFFALSE 42994
// continue ;
42992: GO 42907
// for j in tmp do
42994: LD_ADDR_VAR 0 3
42998: PUSH
42999: LD_VAR 0 4
43003: PUSH
43004: FOR_IN
43005: IFFALSE 43064
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
43007: LD_VAR 0 3
43011: PUSH
43012: LD_EXP 81
43016: PUSH
43017: LD_VAR 0 2
43021: ARRAY
43022: PUSH
43023: LD_INT 1
43025: ARRAY
43026: IN
43027: NOT
43028: PUSH
43029: LD_VAR 0 3
43033: PUSH
43034: LD_EXP 81
43038: PUSH
43039: LD_VAR 0 2
43043: ARRAY
43044: PUSH
43045: LD_INT 2
43047: ARRAY
43048: IN
43049: NOT
43050: AND
43051: IFFALSE 43062
// ComSpaceTimeShoot ( j ) ;
43053: LD_VAR 0 3
43057: PPUSH
43058: CALL 54271 0 1
43062: GO 43004
43064: POP
43065: POP
// end ;
43066: GO 42907
43068: POP
43069: POP
// end ;
43070: LD_VAR 0 1
43074: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
43075: LD_INT 0
43077: PPUSH
43078: PPUSH
43079: PPUSH
43080: PPUSH
43081: PPUSH
43082: PPUSH
43083: PPUSH
43084: PPUSH
43085: PPUSH
// if not mc_bases then
43086: LD_EXP 78
43090: NOT
43091: IFFALSE 43095
// exit ;
43093: GO 43717
// for i = 1 to mc_bases do
43095: LD_ADDR_VAR 0 2
43099: PUSH
43100: DOUBLE
43101: LD_INT 1
43103: DEC
43104: ST_TO_ADDR
43105: LD_EXP 78
43109: PUSH
43110: FOR_TO
43111: IFFALSE 43715
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
43113: LD_EXP 113
43117: PUSH
43118: LD_VAR 0 2
43122: ARRAY
43123: NOT
43124: PUSH
43125: LD_INT 38
43127: PPUSH
43128: LD_EXP 104
43132: PUSH
43133: LD_VAR 0 2
43137: ARRAY
43138: PPUSH
43139: CALL_OW 321
43143: PUSH
43144: LD_INT 2
43146: NONEQUAL
43147: OR
43148: IFFALSE 43152
// continue ;
43150: GO 43110
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
43152: LD_ADDR_VAR 0 8
43156: PUSH
43157: LD_EXP 78
43161: PUSH
43162: LD_VAR 0 2
43166: ARRAY
43167: PPUSH
43168: LD_INT 30
43170: PUSH
43171: LD_INT 34
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PPUSH
43178: CALL_OW 72
43182: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
43183: LD_ADDR_VAR 0 9
43187: PUSH
43188: LD_EXP 78
43192: PUSH
43193: LD_VAR 0 2
43197: ARRAY
43198: PPUSH
43199: LD_INT 25
43201: PUSH
43202: LD_INT 4
43204: PUSH
43205: EMPTY
43206: LIST
43207: LIST
43208: PPUSH
43209: CALL_OW 72
43213: PPUSH
43214: LD_INT 0
43216: PPUSH
43217: CALL 88584 0 2
43221: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
43222: LD_VAR 0 9
43226: NOT
43227: PUSH
43228: LD_VAR 0 8
43232: NOT
43233: OR
43234: PUSH
43235: LD_EXP 78
43239: PUSH
43240: LD_VAR 0 2
43244: ARRAY
43245: PPUSH
43246: LD_INT 124
43248: PPUSH
43249: CALL 88584 0 2
43253: OR
43254: IFFALSE 43258
// continue ;
43256: GO 43110
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
43258: LD_EXP 114
43262: PUSH
43263: LD_VAR 0 2
43267: ARRAY
43268: PUSH
43269: LD_EXP 113
43273: PUSH
43274: LD_VAR 0 2
43278: ARRAY
43279: LESS
43280: PUSH
43281: LD_EXP 114
43285: PUSH
43286: LD_VAR 0 2
43290: ARRAY
43291: PUSH
43292: LD_VAR 0 8
43296: LESS
43297: AND
43298: IFFALSE 43713
// begin tmp := sci [ 1 ] ;
43300: LD_ADDR_VAR 0 7
43304: PUSH
43305: LD_VAR 0 9
43309: PUSH
43310: LD_INT 1
43312: ARRAY
43313: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
43314: LD_VAR 0 7
43318: PPUSH
43319: LD_INT 124
43321: PPUSH
43322: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
43326: LD_ADDR_VAR 0 3
43330: PUSH
43331: DOUBLE
43332: LD_EXP 113
43336: PUSH
43337: LD_VAR 0 2
43341: ARRAY
43342: INC
43343: ST_TO_ADDR
43344: LD_EXP 113
43348: PUSH
43349: LD_VAR 0 2
43353: ARRAY
43354: PUSH
43355: FOR_DOWNTO
43356: IFFALSE 43699
// begin if IsInUnit ( tmp ) then
43358: LD_VAR 0 7
43362: PPUSH
43363: CALL_OW 310
43367: IFFALSE 43378
// ComExitBuilding ( tmp ) ;
43369: LD_VAR 0 7
43373: PPUSH
43374: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
43378: LD_INT 35
43380: PPUSH
43381: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
43385: LD_VAR 0 7
43389: PPUSH
43390: CALL_OW 310
43394: NOT
43395: PUSH
43396: LD_VAR 0 7
43400: PPUSH
43401: CALL_OW 314
43405: NOT
43406: AND
43407: IFFALSE 43378
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
43409: LD_ADDR_VAR 0 6
43413: PUSH
43414: LD_VAR 0 7
43418: PPUSH
43419: CALL_OW 250
43423: PUSH
43424: LD_VAR 0 7
43428: PPUSH
43429: CALL_OW 251
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
43438: LD_INT 35
43440: PPUSH
43441: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
43445: LD_ADDR_VAR 0 4
43449: PUSH
43450: LD_EXP 113
43454: PUSH
43455: LD_VAR 0 2
43459: ARRAY
43460: PUSH
43461: LD_VAR 0 3
43465: ARRAY
43466: PUSH
43467: LD_INT 1
43469: ARRAY
43470: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
43471: LD_ADDR_VAR 0 5
43475: PUSH
43476: LD_EXP 113
43480: PUSH
43481: LD_VAR 0 2
43485: ARRAY
43486: PUSH
43487: LD_VAR 0 3
43491: ARRAY
43492: PUSH
43493: LD_INT 2
43495: ARRAY
43496: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
43497: LD_VAR 0 7
43501: PPUSH
43502: LD_INT 10
43504: PPUSH
43505: CALL 61251 0 2
43509: PUSH
43510: LD_INT 4
43512: ARRAY
43513: IFFALSE 43551
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43515: LD_VAR 0 7
43519: PPUSH
43520: LD_VAR 0 6
43524: PUSH
43525: LD_INT 1
43527: ARRAY
43528: PPUSH
43529: LD_VAR 0 6
43533: PUSH
43534: LD_INT 2
43536: ARRAY
43537: PPUSH
43538: CALL_OW 111
// wait ( 0 0$10 ) ;
43542: LD_INT 350
43544: PPUSH
43545: CALL_OW 67
// end else
43549: GO 43577
// begin ComMoveXY ( tmp , x , y ) ;
43551: LD_VAR 0 7
43555: PPUSH
43556: LD_VAR 0 4
43560: PPUSH
43561: LD_VAR 0 5
43565: PPUSH
43566: CALL_OW 111
// wait ( 0 0$3 ) ;
43570: LD_INT 105
43572: PPUSH
43573: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43577: LD_VAR 0 7
43581: PPUSH
43582: LD_VAR 0 4
43586: PPUSH
43587: LD_VAR 0 5
43591: PPUSH
43592: CALL_OW 307
43596: IFFALSE 43438
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
43598: LD_VAR 0 7
43602: PPUSH
43603: LD_VAR 0 4
43607: PPUSH
43608: LD_VAR 0 5
43612: PPUSH
43613: LD_VAR 0 8
43617: PUSH
43618: LD_VAR 0 3
43622: ARRAY
43623: PPUSH
43624: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
43628: LD_INT 35
43630: PPUSH
43631: CALL_OW 67
// until not HasTask ( tmp ) ;
43635: LD_VAR 0 7
43639: PPUSH
43640: CALL_OW 314
43644: NOT
43645: IFFALSE 43628
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
43647: LD_ADDR_EXP 114
43651: PUSH
43652: LD_EXP 114
43656: PPUSH
43657: LD_VAR 0 2
43661: PUSH
43662: LD_EXP 114
43666: PUSH
43667: LD_VAR 0 2
43671: ARRAY
43672: PUSH
43673: LD_INT 1
43675: PLUS
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PPUSH
43681: LD_VAR 0 8
43685: PUSH
43686: LD_VAR 0 3
43690: ARRAY
43691: PPUSH
43692: CALL 58286 0 3
43696: ST_TO_ADDR
// end ;
43697: GO 43355
43699: POP
43700: POP
// MC_Reset ( i , 124 ) ;
43701: LD_VAR 0 2
43705: PPUSH
43706: LD_INT 124
43708: PPUSH
43709: CALL 26785 0 2
// end ; end ;
43713: GO 43110
43715: POP
43716: POP
// end ;
43717: LD_VAR 0 1
43721: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
43722: LD_INT 0
43724: PPUSH
43725: PPUSH
43726: PPUSH
// if not mc_bases then
43727: LD_EXP 78
43731: NOT
43732: IFFALSE 43736
// exit ;
43734: GO 44342
// for i = 1 to mc_bases do
43736: LD_ADDR_VAR 0 2
43740: PUSH
43741: DOUBLE
43742: LD_INT 1
43744: DEC
43745: ST_TO_ADDR
43746: LD_EXP 78
43750: PUSH
43751: FOR_TO
43752: IFFALSE 44340
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43754: LD_ADDR_VAR 0 3
43758: PUSH
43759: LD_EXP 78
43763: PUSH
43764: LD_VAR 0 2
43768: ARRAY
43769: PPUSH
43770: LD_INT 25
43772: PUSH
43773: LD_INT 4
43775: PUSH
43776: EMPTY
43777: LIST
43778: LIST
43779: PPUSH
43780: CALL_OW 72
43784: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43785: LD_VAR 0 3
43789: NOT
43790: PUSH
43791: LD_EXP 115
43795: PUSH
43796: LD_VAR 0 2
43800: ARRAY
43801: NOT
43802: OR
43803: PUSH
43804: LD_EXP 78
43808: PUSH
43809: LD_VAR 0 2
43813: ARRAY
43814: PPUSH
43815: LD_INT 2
43817: PUSH
43818: LD_INT 30
43820: PUSH
43821: LD_INT 0
43823: PUSH
43824: EMPTY
43825: LIST
43826: LIST
43827: PUSH
43828: LD_INT 30
43830: PUSH
43831: LD_INT 1
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: LIST
43842: PPUSH
43843: CALL_OW 72
43847: NOT
43848: OR
43849: IFFALSE 43899
// begin if mc_deposits_finder [ i ] then
43851: LD_EXP 116
43855: PUSH
43856: LD_VAR 0 2
43860: ARRAY
43861: IFFALSE 43897
// begin MC_Reset ( i , 125 ) ;
43863: LD_VAR 0 2
43867: PPUSH
43868: LD_INT 125
43870: PPUSH
43871: CALL 26785 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43875: LD_ADDR_EXP 116
43879: PUSH
43880: LD_EXP 116
43884: PPUSH
43885: LD_VAR 0 2
43889: PPUSH
43890: EMPTY
43891: PPUSH
43892: CALL_OW 1
43896: ST_TO_ADDR
// end ; continue ;
43897: GO 43751
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
43899: LD_EXP 115
43903: PUSH
43904: LD_VAR 0 2
43908: ARRAY
43909: PUSH
43910: LD_INT 1
43912: ARRAY
43913: PUSH
43914: LD_INT 3
43916: ARRAY
43917: PUSH
43918: LD_INT 1
43920: EQUAL
43921: PUSH
43922: LD_INT 20
43924: PPUSH
43925: LD_EXP 104
43929: PUSH
43930: LD_VAR 0 2
43934: ARRAY
43935: PPUSH
43936: CALL_OW 321
43940: PUSH
43941: LD_INT 2
43943: NONEQUAL
43944: AND
43945: IFFALSE 43995
// begin if mc_deposits_finder [ i ] then
43947: LD_EXP 116
43951: PUSH
43952: LD_VAR 0 2
43956: ARRAY
43957: IFFALSE 43993
// begin MC_Reset ( i , 125 ) ;
43959: LD_VAR 0 2
43963: PPUSH
43964: LD_INT 125
43966: PPUSH
43967: CALL 26785 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43971: LD_ADDR_EXP 116
43975: PUSH
43976: LD_EXP 116
43980: PPUSH
43981: LD_VAR 0 2
43985: PPUSH
43986: EMPTY
43987: PPUSH
43988: CALL_OW 1
43992: ST_TO_ADDR
// end ; continue ;
43993: GO 43751
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
43995: LD_EXP 115
43999: PUSH
44000: LD_VAR 0 2
44004: ARRAY
44005: PUSH
44006: LD_INT 1
44008: ARRAY
44009: PUSH
44010: LD_INT 1
44012: ARRAY
44013: PPUSH
44014: LD_EXP 115
44018: PUSH
44019: LD_VAR 0 2
44023: ARRAY
44024: PUSH
44025: LD_INT 1
44027: ARRAY
44028: PUSH
44029: LD_INT 2
44031: ARRAY
44032: PPUSH
44033: LD_EXP 104
44037: PUSH
44038: LD_VAR 0 2
44042: ARRAY
44043: PPUSH
44044: CALL_OW 440
44048: IFFALSE 44091
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
44050: LD_ADDR_EXP 115
44054: PUSH
44055: LD_EXP 115
44059: PPUSH
44060: LD_VAR 0 2
44064: PPUSH
44065: LD_EXP 115
44069: PUSH
44070: LD_VAR 0 2
44074: ARRAY
44075: PPUSH
44076: LD_INT 1
44078: PPUSH
44079: CALL_OW 3
44083: PPUSH
44084: CALL_OW 1
44088: ST_TO_ADDR
44089: GO 44338
// begin if not mc_deposits_finder [ i ] then
44091: LD_EXP 116
44095: PUSH
44096: LD_VAR 0 2
44100: ARRAY
44101: NOT
44102: IFFALSE 44154
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
44104: LD_ADDR_EXP 116
44108: PUSH
44109: LD_EXP 116
44113: PPUSH
44114: LD_VAR 0 2
44118: PPUSH
44119: LD_VAR 0 3
44123: PUSH
44124: LD_INT 1
44126: ARRAY
44127: PUSH
44128: EMPTY
44129: LIST
44130: PPUSH
44131: CALL_OW 1
44135: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
44136: LD_VAR 0 3
44140: PUSH
44141: LD_INT 1
44143: ARRAY
44144: PPUSH
44145: LD_INT 125
44147: PPUSH
44148: CALL_OW 109
// end else
44152: GO 44338
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
44154: LD_EXP 116
44158: PUSH
44159: LD_VAR 0 2
44163: ARRAY
44164: PUSH
44165: LD_INT 1
44167: ARRAY
44168: PPUSH
44169: CALL_OW 310
44173: IFFALSE 44196
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
44175: LD_EXP 116
44179: PUSH
44180: LD_VAR 0 2
44184: ARRAY
44185: PUSH
44186: LD_INT 1
44188: ARRAY
44189: PPUSH
44190: CALL_OW 122
44194: GO 44338
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
44196: LD_EXP 116
44200: PUSH
44201: LD_VAR 0 2
44205: ARRAY
44206: PUSH
44207: LD_INT 1
44209: ARRAY
44210: PPUSH
44211: CALL_OW 314
44215: NOT
44216: PUSH
44217: LD_EXP 116
44221: PUSH
44222: LD_VAR 0 2
44226: ARRAY
44227: PUSH
44228: LD_INT 1
44230: ARRAY
44231: PPUSH
44232: LD_EXP 115
44236: PUSH
44237: LD_VAR 0 2
44241: ARRAY
44242: PUSH
44243: LD_INT 1
44245: ARRAY
44246: PUSH
44247: LD_INT 1
44249: ARRAY
44250: PPUSH
44251: LD_EXP 115
44255: PUSH
44256: LD_VAR 0 2
44260: ARRAY
44261: PUSH
44262: LD_INT 1
44264: ARRAY
44265: PUSH
44266: LD_INT 2
44268: ARRAY
44269: PPUSH
44270: CALL_OW 297
44274: PUSH
44275: LD_INT 6
44277: GREATER
44278: AND
44279: IFFALSE 44338
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
44281: LD_EXP 116
44285: PUSH
44286: LD_VAR 0 2
44290: ARRAY
44291: PUSH
44292: LD_INT 1
44294: ARRAY
44295: PPUSH
44296: LD_EXP 115
44300: PUSH
44301: LD_VAR 0 2
44305: ARRAY
44306: PUSH
44307: LD_INT 1
44309: ARRAY
44310: PUSH
44311: LD_INT 1
44313: ARRAY
44314: PPUSH
44315: LD_EXP 115
44319: PUSH
44320: LD_VAR 0 2
44324: ARRAY
44325: PUSH
44326: LD_INT 1
44328: ARRAY
44329: PUSH
44330: LD_INT 2
44332: ARRAY
44333: PPUSH
44334: CALL_OW 111
// end ; end ; end ;
44338: GO 43751
44340: POP
44341: POP
// end ;
44342: LD_VAR 0 1
44346: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
44347: LD_INT 0
44349: PPUSH
44350: PPUSH
44351: PPUSH
44352: PPUSH
44353: PPUSH
44354: PPUSH
44355: PPUSH
44356: PPUSH
44357: PPUSH
44358: PPUSH
44359: PPUSH
// if not mc_bases then
44360: LD_EXP 78
44364: NOT
44365: IFFALSE 44369
// exit ;
44367: GO 45309
// for i = 1 to mc_bases do
44369: LD_ADDR_VAR 0 2
44373: PUSH
44374: DOUBLE
44375: LD_INT 1
44377: DEC
44378: ST_TO_ADDR
44379: LD_EXP 78
44383: PUSH
44384: FOR_TO
44385: IFFALSE 45307
// begin if not mc_bases [ i ] or mc_scan [ i ] then
44387: LD_EXP 78
44391: PUSH
44392: LD_VAR 0 2
44396: ARRAY
44397: NOT
44398: PUSH
44399: LD_EXP 101
44403: PUSH
44404: LD_VAR 0 2
44408: ARRAY
44409: OR
44410: IFFALSE 44414
// continue ;
44412: GO 44384
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
44414: LD_ADDR_VAR 0 7
44418: PUSH
44419: LD_EXP 78
44423: PUSH
44424: LD_VAR 0 2
44428: ARRAY
44429: PUSH
44430: LD_INT 1
44432: ARRAY
44433: PPUSH
44434: CALL_OW 248
44438: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
44439: LD_VAR 0 7
44443: PUSH
44444: LD_INT 3
44446: EQUAL
44447: PUSH
44448: LD_EXP 97
44452: PUSH
44453: LD_VAR 0 2
44457: ARRAY
44458: PUSH
44459: LD_EXP 100
44463: PUSH
44464: LD_VAR 0 2
44468: ARRAY
44469: UNION
44470: PPUSH
44471: LD_INT 33
44473: PUSH
44474: LD_INT 2
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PPUSH
44481: CALL_OW 72
44485: NOT
44486: OR
44487: IFFALSE 44491
// continue ;
44489: GO 44384
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
44491: LD_ADDR_VAR 0 9
44495: PUSH
44496: LD_EXP 78
44500: PUSH
44501: LD_VAR 0 2
44505: ARRAY
44506: PPUSH
44507: LD_INT 30
44509: PUSH
44510: LD_INT 36
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PPUSH
44517: CALL_OW 72
44521: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44522: LD_ADDR_VAR 0 10
44526: PUSH
44527: LD_EXP 97
44531: PUSH
44532: LD_VAR 0 2
44536: ARRAY
44537: PPUSH
44538: LD_INT 34
44540: PUSH
44541: LD_INT 31
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: PPUSH
44548: CALL_OW 72
44552: ST_TO_ADDR
// if not cts and not mcts then
44553: LD_VAR 0 9
44557: NOT
44558: PUSH
44559: LD_VAR 0 10
44563: NOT
44564: AND
44565: IFFALSE 44569
// continue ;
44567: GO 44384
// x := cts ;
44569: LD_ADDR_VAR 0 11
44573: PUSH
44574: LD_VAR 0 9
44578: ST_TO_ADDR
// if not x then
44579: LD_VAR 0 11
44583: NOT
44584: IFFALSE 44596
// x := mcts ;
44586: LD_ADDR_VAR 0 11
44590: PUSH
44591: LD_VAR 0 10
44595: ST_TO_ADDR
// if not x then
44596: LD_VAR 0 11
44600: NOT
44601: IFFALSE 44605
// continue ;
44603: GO 44384
// if mc_remote_driver [ i ] then
44605: LD_EXP 118
44609: PUSH
44610: LD_VAR 0 2
44614: ARRAY
44615: IFFALSE 45002
// for j in mc_remote_driver [ i ] do
44617: LD_ADDR_VAR 0 3
44621: PUSH
44622: LD_EXP 118
44626: PUSH
44627: LD_VAR 0 2
44631: ARRAY
44632: PUSH
44633: FOR_IN
44634: IFFALSE 45000
// begin if GetClass ( j ) <> 3 then
44636: LD_VAR 0 3
44640: PPUSH
44641: CALL_OW 257
44645: PUSH
44646: LD_INT 3
44648: NONEQUAL
44649: IFFALSE 44702
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
44651: LD_ADDR_EXP 118
44655: PUSH
44656: LD_EXP 118
44660: PPUSH
44661: LD_VAR 0 2
44665: PPUSH
44666: LD_EXP 118
44670: PUSH
44671: LD_VAR 0 2
44675: ARRAY
44676: PUSH
44677: LD_VAR 0 3
44681: DIFF
44682: PPUSH
44683: CALL_OW 1
44687: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44688: LD_VAR 0 3
44692: PPUSH
44693: LD_INT 0
44695: PPUSH
44696: CALL_OW 109
// continue ;
44700: GO 44633
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
44702: LD_EXP 97
44706: PUSH
44707: LD_VAR 0 2
44711: ARRAY
44712: PPUSH
44713: LD_INT 34
44715: PUSH
44716: LD_INT 31
44718: PUSH
44719: EMPTY
44720: LIST
44721: LIST
44722: PUSH
44723: LD_INT 58
44725: PUSH
44726: EMPTY
44727: LIST
44728: PUSH
44729: EMPTY
44730: LIST
44731: LIST
44732: PPUSH
44733: CALL_OW 72
44737: PUSH
44738: LD_VAR 0 3
44742: PPUSH
44743: CALL 88619 0 1
44747: NOT
44748: AND
44749: IFFALSE 44820
// begin if IsInUnit ( j ) then
44751: LD_VAR 0 3
44755: PPUSH
44756: CALL_OW 310
44760: IFFALSE 44771
// ComExitBuilding ( j ) ;
44762: LD_VAR 0 3
44766: PPUSH
44767: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
44771: LD_VAR 0 3
44775: PPUSH
44776: LD_EXP 97
44780: PUSH
44781: LD_VAR 0 2
44785: ARRAY
44786: PPUSH
44787: LD_INT 34
44789: PUSH
44790: LD_INT 31
44792: PUSH
44793: EMPTY
44794: LIST
44795: LIST
44796: PUSH
44797: LD_INT 58
44799: PUSH
44800: EMPTY
44801: LIST
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PPUSH
44807: CALL_OW 72
44811: PUSH
44812: LD_INT 1
44814: ARRAY
44815: PPUSH
44816: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
44820: LD_VAR 0 3
44824: PPUSH
44825: CALL_OW 310
44829: NOT
44830: PUSH
44831: LD_VAR 0 3
44835: PPUSH
44836: CALL_OW 310
44840: PPUSH
44841: CALL_OW 266
44845: PUSH
44846: LD_INT 36
44848: NONEQUAL
44849: PUSH
44850: LD_VAR 0 3
44854: PPUSH
44855: CALL 88619 0 1
44859: NOT
44860: AND
44861: OR
44862: IFFALSE 44998
// begin if IsInUnit ( j ) then
44864: LD_VAR 0 3
44868: PPUSH
44869: CALL_OW 310
44873: IFFALSE 44884
// ComExitBuilding ( j ) ;
44875: LD_VAR 0 3
44879: PPUSH
44880: CALL_OW 122
// ct := 0 ;
44884: LD_ADDR_VAR 0 8
44888: PUSH
44889: LD_INT 0
44891: ST_TO_ADDR
// for k in x do
44892: LD_ADDR_VAR 0 4
44896: PUSH
44897: LD_VAR 0 11
44901: PUSH
44902: FOR_IN
44903: IFFALSE 44976
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
44905: LD_VAR 0 4
44909: PPUSH
44910: CALL_OW 264
44914: PUSH
44915: LD_INT 31
44917: EQUAL
44918: PUSH
44919: LD_VAR 0 4
44923: PPUSH
44924: CALL_OW 311
44928: NOT
44929: AND
44930: PUSH
44931: LD_VAR 0 4
44935: PPUSH
44936: CALL_OW 266
44940: PUSH
44941: LD_INT 36
44943: EQUAL
44944: PUSH
44945: LD_VAR 0 4
44949: PPUSH
44950: CALL_OW 313
44954: PUSH
44955: LD_INT 3
44957: LESS
44958: AND
44959: OR
44960: IFFALSE 44974
// begin ct := k ;
44962: LD_ADDR_VAR 0 8
44966: PUSH
44967: LD_VAR 0 4
44971: ST_TO_ADDR
// break ;
44972: GO 44976
// end ;
44974: GO 44902
44976: POP
44977: POP
// if ct then
44978: LD_VAR 0 8
44982: IFFALSE 44998
// ComEnterUnit ( j , ct ) ;
44984: LD_VAR 0 3
44988: PPUSH
44989: LD_VAR 0 8
44993: PPUSH
44994: CALL_OW 120
// end ; end ;
44998: GO 44633
45000: POP
45001: POP
// places := 0 ;
45002: LD_ADDR_VAR 0 5
45006: PUSH
45007: LD_INT 0
45009: ST_TO_ADDR
// for j = 1 to x do
45010: LD_ADDR_VAR 0 3
45014: PUSH
45015: DOUBLE
45016: LD_INT 1
45018: DEC
45019: ST_TO_ADDR
45020: LD_VAR 0 11
45024: PUSH
45025: FOR_TO
45026: IFFALSE 45102
// if GetWeapon ( x [ j ] ) = ar_control_tower then
45028: LD_VAR 0 11
45032: PUSH
45033: LD_VAR 0 3
45037: ARRAY
45038: PPUSH
45039: CALL_OW 264
45043: PUSH
45044: LD_INT 31
45046: EQUAL
45047: IFFALSE 45065
// places := places + 1 else
45049: LD_ADDR_VAR 0 5
45053: PUSH
45054: LD_VAR 0 5
45058: PUSH
45059: LD_INT 1
45061: PLUS
45062: ST_TO_ADDR
45063: GO 45100
// if GetBType ( x [ j ] ) = b_control_tower then
45065: LD_VAR 0 11
45069: PUSH
45070: LD_VAR 0 3
45074: ARRAY
45075: PPUSH
45076: CALL_OW 266
45080: PUSH
45081: LD_INT 36
45083: EQUAL
45084: IFFALSE 45100
// places := places + 3 ;
45086: LD_ADDR_VAR 0 5
45090: PUSH
45091: LD_VAR 0 5
45095: PUSH
45096: LD_INT 3
45098: PLUS
45099: ST_TO_ADDR
45100: GO 45025
45102: POP
45103: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
45104: LD_VAR 0 5
45108: PUSH
45109: LD_INT 0
45111: EQUAL
45112: PUSH
45113: LD_VAR 0 5
45117: PUSH
45118: LD_EXP 118
45122: PUSH
45123: LD_VAR 0 2
45127: ARRAY
45128: LESSEQUAL
45129: OR
45130: IFFALSE 45134
// continue ;
45132: GO 44384
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
45134: LD_ADDR_VAR 0 6
45138: PUSH
45139: LD_EXP 78
45143: PUSH
45144: LD_VAR 0 2
45148: ARRAY
45149: PPUSH
45150: LD_INT 25
45152: PUSH
45153: LD_INT 3
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: PPUSH
45160: CALL_OW 72
45164: PUSH
45165: LD_EXP 118
45169: PUSH
45170: LD_VAR 0 2
45174: ARRAY
45175: DIFF
45176: PPUSH
45177: LD_INT 3
45179: PPUSH
45180: CALL 89519 0 2
45184: ST_TO_ADDR
// for j in tmp do
45185: LD_ADDR_VAR 0 3
45189: PUSH
45190: LD_VAR 0 6
45194: PUSH
45195: FOR_IN
45196: IFFALSE 45231
// if GetTag ( j ) > 0 then
45198: LD_VAR 0 3
45202: PPUSH
45203: CALL_OW 110
45207: PUSH
45208: LD_INT 0
45210: GREATER
45211: IFFALSE 45229
// tmp := tmp diff j ;
45213: LD_ADDR_VAR 0 6
45217: PUSH
45218: LD_VAR 0 6
45222: PUSH
45223: LD_VAR 0 3
45227: DIFF
45228: ST_TO_ADDR
45229: GO 45195
45231: POP
45232: POP
// if not tmp then
45233: LD_VAR 0 6
45237: NOT
45238: IFFALSE 45242
// continue ;
45240: GO 44384
// if places then
45242: LD_VAR 0 5
45246: IFFALSE 45305
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
45248: LD_ADDR_EXP 118
45252: PUSH
45253: LD_EXP 118
45257: PPUSH
45258: LD_VAR 0 2
45262: PPUSH
45263: LD_EXP 118
45267: PUSH
45268: LD_VAR 0 2
45272: ARRAY
45273: PUSH
45274: LD_VAR 0 6
45278: PUSH
45279: LD_INT 1
45281: ARRAY
45282: UNION
45283: PPUSH
45284: CALL_OW 1
45288: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
45289: LD_VAR 0 6
45293: PUSH
45294: LD_INT 1
45296: ARRAY
45297: PPUSH
45298: LD_INT 126
45300: PPUSH
45301: CALL_OW 109
// end ; end ;
45305: GO 44384
45307: POP
45308: POP
// end ;
45309: LD_VAR 0 1
45313: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
45314: LD_INT 0
45316: PPUSH
45317: PPUSH
45318: PPUSH
45319: PPUSH
45320: PPUSH
45321: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
45322: LD_VAR 0 1
45326: NOT
45327: PUSH
45328: LD_VAR 0 2
45332: NOT
45333: OR
45334: PUSH
45335: LD_VAR 0 3
45339: NOT
45340: OR
45341: PUSH
45342: LD_VAR 0 4
45346: PUSH
45347: LD_INT 1
45349: PUSH
45350: LD_INT 2
45352: PUSH
45353: LD_INT 3
45355: PUSH
45356: LD_INT 4
45358: PUSH
45359: LD_INT 5
45361: PUSH
45362: LD_INT 8
45364: PUSH
45365: LD_INT 9
45367: PUSH
45368: LD_INT 15
45370: PUSH
45371: LD_INT 16
45373: PUSH
45374: EMPTY
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: IN
45385: NOT
45386: OR
45387: IFFALSE 45391
// exit ;
45389: GO 46249
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
45391: LD_ADDR_VAR 0 2
45395: PUSH
45396: LD_VAR 0 2
45400: PPUSH
45401: LD_INT 21
45403: PUSH
45404: LD_INT 3
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 24
45413: PUSH
45414: LD_INT 250
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PPUSH
45425: CALL_OW 72
45429: ST_TO_ADDR
// case class of 1 , 15 :
45430: LD_VAR 0 4
45434: PUSH
45435: LD_INT 1
45437: DOUBLE
45438: EQUAL
45439: IFTRUE 45449
45441: LD_INT 15
45443: DOUBLE
45444: EQUAL
45445: IFTRUE 45449
45447: GO 45534
45449: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
45450: LD_ADDR_VAR 0 8
45454: PUSH
45455: LD_VAR 0 2
45459: PPUSH
45460: LD_INT 2
45462: PUSH
45463: LD_INT 30
45465: PUSH
45466: LD_INT 32
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 30
45475: PUSH
45476: LD_INT 31
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: LIST
45487: PPUSH
45488: CALL_OW 72
45492: PUSH
45493: LD_VAR 0 2
45497: PPUSH
45498: LD_INT 2
45500: PUSH
45501: LD_INT 30
45503: PUSH
45504: LD_INT 4
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: PUSH
45511: LD_INT 30
45513: PUSH
45514: LD_INT 5
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: EMPTY
45522: LIST
45523: LIST
45524: LIST
45525: PPUSH
45526: CALL_OW 72
45530: ADD
45531: ST_TO_ADDR
45532: GO 45780
45534: LD_INT 2
45536: DOUBLE
45537: EQUAL
45538: IFTRUE 45548
45540: LD_INT 16
45542: DOUBLE
45543: EQUAL
45544: IFTRUE 45548
45546: GO 45594
45548: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45549: LD_ADDR_VAR 0 8
45553: PUSH
45554: LD_VAR 0 2
45558: PPUSH
45559: LD_INT 2
45561: PUSH
45562: LD_INT 30
45564: PUSH
45565: LD_INT 0
45567: PUSH
45568: EMPTY
45569: LIST
45570: LIST
45571: PUSH
45572: LD_INT 30
45574: PUSH
45575: LD_INT 1
45577: PUSH
45578: EMPTY
45579: LIST
45580: LIST
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: LIST
45586: PPUSH
45587: CALL_OW 72
45591: ST_TO_ADDR
45592: GO 45780
45594: LD_INT 3
45596: DOUBLE
45597: EQUAL
45598: IFTRUE 45602
45600: GO 45648
45602: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
45603: LD_ADDR_VAR 0 8
45607: PUSH
45608: LD_VAR 0 2
45612: PPUSH
45613: LD_INT 2
45615: PUSH
45616: LD_INT 30
45618: PUSH
45619: LD_INT 2
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 30
45628: PUSH
45629: LD_INT 3
45631: PUSH
45632: EMPTY
45633: LIST
45634: LIST
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: LIST
45640: PPUSH
45641: CALL_OW 72
45645: ST_TO_ADDR
45646: GO 45780
45648: LD_INT 4
45650: DOUBLE
45651: EQUAL
45652: IFTRUE 45656
45654: GO 45713
45656: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
45657: LD_ADDR_VAR 0 8
45661: PUSH
45662: LD_VAR 0 2
45666: PPUSH
45667: LD_INT 2
45669: PUSH
45670: LD_INT 30
45672: PUSH
45673: LD_INT 6
45675: PUSH
45676: EMPTY
45677: LIST
45678: LIST
45679: PUSH
45680: LD_INT 30
45682: PUSH
45683: LD_INT 7
45685: PUSH
45686: EMPTY
45687: LIST
45688: LIST
45689: PUSH
45690: LD_INT 30
45692: PUSH
45693: LD_INT 8
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: PPUSH
45706: CALL_OW 72
45710: ST_TO_ADDR
45711: GO 45780
45713: LD_INT 5
45715: DOUBLE
45716: EQUAL
45717: IFTRUE 45733
45719: LD_INT 8
45721: DOUBLE
45722: EQUAL
45723: IFTRUE 45733
45725: LD_INT 9
45727: DOUBLE
45728: EQUAL
45729: IFTRUE 45733
45731: GO 45779
45733: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
45734: LD_ADDR_VAR 0 8
45738: PUSH
45739: LD_VAR 0 2
45743: PPUSH
45744: LD_INT 2
45746: PUSH
45747: LD_INT 30
45749: PUSH
45750: LD_INT 4
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 30
45759: PUSH
45760: LD_INT 5
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: LIST
45771: PPUSH
45772: CALL_OW 72
45776: ST_TO_ADDR
45777: GO 45780
45779: POP
// if not tmp then
45780: LD_VAR 0 8
45784: NOT
45785: IFFALSE 45789
// exit ;
45787: GO 46249
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
45789: LD_VAR 0 4
45793: PUSH
45794: LD_INT 1
45796: PUSH
45797: LD_INT 15
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: IN
45804: PUSH
45805: LD_EXP 87
45809: PUSH
45810: LD_VAR 0 1
45814: ARRAY
45815: AND
45816: IFFALSE 45972
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
45818: LD_ADDR_VAR 0 9
45822: PUSH
45823: LD_EXP 87
45827: PUSH
45828: LD_VAR 0 1
45832: ARRAY
45833: PUSH
45834: LD_INT 1
45836: ARRAY
45837: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
45838: LD_VAR 0 9
45842: PUSH
45843: LD_EXP 88
45847: PUSH
45848: LD_VAR 0 1
45852: ARRAY
45853: IN
45854: NOT
45855: IFFALSE 45970
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
45857: LD_ADDR_EXP 88
45861: PUSH
45862: LD_EXP 88
45866: PPUSH
45867: LD_VAR 0 1
45871: PUSH
45872: LD_EXP 88
45876: PUSH
45877: LD_VAR 0 1
45881: ARRAY
45882: PUSH
45883: LD_INT 1
45885: PLUS
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PPUSH
45891: LD_VAR 0 9
45895: PPUSH
45896: CALL 58286 0 3
45900: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
45901: LD_ADDR_EXP 87
45905: PUSH
45906: LD_EXP 87
45910: PPUSH
45911: LD_VAR 0 1
45915: PPUSH
45916: LD_EXP 87
45920: PUSH
45921: LD_VAR 0 1
45925: ARRAY
45926: PUSH
45927: LD_VAR 0 9
45931: DIFF
45932: PPUSH
45933: CALL_OW 1
45937: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
45938: LD_VAR 0 3
45942: PPUSH
45943: LD_EXP 88
45947: PUSH
45948: LD_VAR 0 1
45952: ARRAY
45953: PUSH
45954: LD_EXP 88
45958: PUSH
45959: LD_VAR 0 1
45963: ARRAY
45964: ARRAY
45965: PPUSH
45966: CALL_OW 120
// end ; exit ;
45970: GO 46249
// end ; if tmp > 1 then
45972: LD_VAR 0 8
45976: PUSH
45977: LD_INT 1
45979: GREATER
45980: IFFALSE 46084
// for i = 2 to tmp do
45982: LD_ADDR_VAR 0 6
45986: PUSH
45987: DOUBLE
45988: LD_INT 2
45990: DEC
45991: ST_TO_ADDR
45992: LD_VAR 0 8
45996: PUSH
45997: FOR_TO
45998: IFFALSE 46082
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
46000: LD_VAR 0 8
46004: PUSH
46005: LD_VAR 0 6
46009: ARRAY
46010: PPUSH
46011: CALL_OW 461
46015: PUSH
46016: LD_INT 6
46018: EQUAL
46019: IFFALSE 46080
// begin x := tmp [ i ] ;
46021: LD_ADDR_VAR 0 9
46025: PUSH
46026: LD_VAR 0 8
46030: PUSH
46031: LD_VAR 0 6
46035: ARRAY
46036: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
46037: LD_ADDR_VAR 0 8
46041: PUSH
46042: LD_VAR 0 8
46046: PPUSH
46047: LD_VAR 0 6
46051: PPUSH
46052: CALL_OW 3
46056: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
46057: LD_ADDR_VAR 0 8
46061: PUSH
46062: LD_VAR 0 8
46066: PPUSH
46067: LD_INT 1
46069: PPUSH
46070: LD_VAR 0 9
46074: PPUSH
46075: CALL_OW 2
46079: ST_TO_ADDR
// end ;
46080: GO 45997
46082: POP
46083: POP
// for i in tmp do
46084: LD_ADDR_VAR 0 6
46088: PUSH
46089: LD_VAR 0 8
46093: PUSH
46094: FOR_IN
46095: IFFALSE 46122
// begin if IsNotFull ( i ) then
46097: LD_VAR 0 6
46101: PPUSH
46102: CALL 55508 0 1
46106: IFFALSE 46120
// begin j := i ;
46108: LD_ADDR_VAR 0 7
46112: PUSH
46113: LD_VAR 0 6
46117: ST_TO_ADDR
// break ;
46118: GO 46122
// end ; end ;
46120: GO 46094
46122: POP
46123: POP
// if j then
46124: LD_VAR 0 7
46128: IFFALSE 46146
// ComEnterUnit ( unit , j ) else
46130: LD_VAR 0 3
46134: PPUSH
46135: LD_VAR 0 7
46139: PPUSH
46140: CALL_OW 120
46144: GO 46249
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46146: LD_ADDR_VAR 0 10
46150: PUSH
46151: LD_VAR 0 2
46155: PPUSH
46156: LD_INT 2
46158: PUSH
46159: LD_INT 30
46161: PUSH
46162: LD_INT 0
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: LD_INT 30
46171: PUSH
46172: LD_INT 1
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: LIST
46183: PPUSH
46184: CALL_OW 72
46188: ST_TO_ADDR
// if depot then
46189: LD_VAR 0 10
46193: IFFALSE 46249
// begin depot := NearestUnitToUnit ( depot , unit ) ;
46195: LD_ADDR_VAR 0 10
46199: PUSH
46200: LD_VAR 0 10
46204: PPUSH
46205: LD_VAR 0 3
46209: PPUSH
46210: CALL_OW 74
46214: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
46215: LD_VAR 0 3
46219: PPUSH
46220: LD_VAR 0 10
46224: PPUSH
46225: CALL_OW 296
46229: PUSH
46230: LD_INT 10
46232: GREATER
46233: IFFALSE 46249
// ComStandNearbyBuilding ( unit , depot ) ;
46235: LD_VAR 0 3
46239: PPUSH
46240: LD_VAR 0 10
46244: PPUSH
46245: CALL 54888 0 2
// end ; end ; end ;
46249: LD_VAR 0 5
46253: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
46254: LD_INT 0
46256: PPUSH
46257: PPUSH
46258: PPUSH
46259: PPUSH
// if not mc_bases then
46260: LD_EXP 78
46264: NOT
46265: IFFALSE 46269
// exit ;
46267: GO 46508
// for i = 1 to mc_bases do
46269: LD_ADDR_VAR 0 2
46273: PUSH
46274: DOUBLE
46275: LD_INT 1
46277: DEC
46278: ST_TO_ADDR
46279: LD_EXP 78
46283: PUSH
46284: FOR_TO
46285: IFFALSE 46506
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
46287: LD_ADDR_VAR 0 4
46291: PUSH
46292: LD_EXP 78
46296: PUSH
46297: LD_VAR 0 2
46301: ARRAY
46302: PPUSH
46303: LD_INT 21
46305: PUSH
46306: LD_INT 1
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PPUSH
46313: CALL_OW 72
46317: PUSH
46318: LD_EXP 107
46322: PUSH
46323: LD_VAR 0 2
46327: ARRAY
46328: UNION
46329: ST_TO_ADDR
// if not tmp then
46330: LD_VAR 0 4
46334: NOT
46335: IFFALSE 46339
// continue ;
46337: GO 46284
// for j in tmp do
46339: LD_ADDR_VAR 0 3
46343: PUSH
46344: LD_VAR 0 4
46348: PUSH
46349: FOR_IN
46350: IFFALSE 46502
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
46352: LD_VAR 0 3
46356: PPUSH
46357: CALL_OW 110
46361: NOT
46362: PUSH
46363: LD_VAR 0 3
46367: PPUSH
46368: CALL_OW 314
46372: NOT
46373: AND
46374: PUSH
46375: LD_VAR 0 3
46379: PPUSH
46380: CALL_OW 311
46384: NOT
46385: AND
46386: PUSH
46387: LD_VAR 0 3
46391: PPUSH
46392: CALL_OW 310
46396: NOT
46397: AND
46398: PUSH
46399: LD_VAR 0 3
46403: PUSH
46404: LD_EXP 81
46408: PUSH
46409: LD_VAR 0 2
46413: ARRAY
46414: PUSH
46415: LD_INT 1
46417: ARRAY
46418: IN
46419: NOT
46420: AND
46421: PUSH
46422: LD_VAR 0 3
46426: PUSH
46427: LD_EXP 81
46431: PUSH
46432: LD_VAR 0 2
46436: ARRAY
46437: PUSH
46438: LD_INT 2
46440: ARRAY
46441: IN
46442: NOT
46443: AND
46444: PUSH
46445: LD_VAR 0 3
46449: PUSH
46450: LD_EXP 90
46454: PUSH
46455: LD_VAR 0 2
46459: ARRAY
46460: IN
46461: NOT
46462: AND
46463: IFFALSE 46500
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
46465: LD_VAR 0 2
46469: PPUSH
46470: LD_EXP 78
46474: PUSH
46475: LD_VAR 0 2
46479: ARRAY
46480: PPUSH
46481: LD_VAR 0 3
46485: PPUSH
46486: LD_VAR 0 3
46490: PPUSH
46491: CALL_OW 257
46495: PPUSH
46496: CALL 45314 0 4
// end ;
46500: GO 46349
46502: POP
46503: POP
// end ;
46504: GO 46284
46506: POP
46507: POP
// end ;
46508: LD_VAR 0 1
46512: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46513: LD_INT 0
46515: PPUSH
46516: PPUSH
46517: PPUSH
46518: PPUSH
46519: PPUSH
46520: PPUSH
// if not mc_bases [ base ] then
46521: LD_EXP 78
46525: PUSH
46526: LD_VAR 0 1
46530: ARRAY
46531: NOT
46532: IFFALSE 46536
// exit ;
46534: GO 46737
// tmp := [ ] ;
46536: LD_ADDR_VAR 0 6
46540: PUSH
46541: EMPTY
46542: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46543: LD_ADDR_VAR 0 7
46547: PUSH
46548: LD_VAR 0 3
46552: PPUSH
46553: LD_INT 0
46555: PPUSH
46556: CALL_OW 517
46560: ST_TO_ADDR
// if not list then
46561: LD_VAR 0 7
46565: NOT
46566: IFFALSE 46570
// exit ;
46568: GO 46737
// c := Count ( list [ 1 ] ) ;
46570: LD_ADDR_VAR 0 9
46574: PUSH
46575: LD_VAR 0 7
46579: PUSH
46580: LD_INT 1
46582: ARRAY
46583: PPUSH
46584: CALL 55426 0 1
46588: ST_TO_ADDR
// if amount > c then
46589: LD_VAR 0 2
46593: PUSH
46594: LD_VAR 0 9
46598: GREATER
46599: IFFALSE 46611
// amount := c ;
46601: LD_ADDR_VAR 0 2
46605: PUSH
46606: LD_VAR 0 9
46610: ST_TO_ADDR
// for i := 1 to amount do
46611: LD_ADDR_VAR 0 5
46615: PUSH
46616: DOUBLE
46617: LD_INT 1
46619: DEC
46620: ST_TO_ADDR
46621: LD_VAR 0 2
46625: PUSH
46626: FOR_TO
46627: IFFALSE 46685
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
46629: LD_ADDR_VAR 0 6
46633: PUSH
46634: LD_VAR 0 6
46638: PPUSH
46639: LD_VAR 0 5
46643: PPUSH
46644: LD_VAR 0 7
46648: PUSH
46649: LD_INT 1
46651: ARRAY
46652: PUSH
46653: LD_VAR 0 5
46657: ARRAY
46658: PUSH
46659: LD_VAR 0 7
46663: PUSH
46664: LD_INT 2
46666: ARRAY
46667: PUSH
46668: LD_VAR 0 5
46672: ARRAY
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PPUSH
46678: CALL_OW 1
46682: ST_TO_ADDR
46683: GO 46626
46685: POP
46686: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
46687: LD_ADDR_EXP 91
46691: PUSH
46692: LD_EXP 91
46696: PPUSH
46697: LD_VAR 0 1
46701: PPUSH
46702: LD_VAR 0 6
46706: PPUSH
46707: CALL_OW 1
46711: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
46712: LD_ADDR_EXP 93
46716: PUSH
46717: LD_EXP 93
46721: PPUSH
46722: LD_VAR 0 1
46726: PPUSH
46727: LD_VAR 0 3
46731: PPUSH
46732: CALL_OW 1
46736: ST_TO_ADDR
// end ;
46737: LD_VAR 0 4
46741: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
46742: LD_INT 0
46744: PPUSH
// if not mc_bases [ base ] then
46745: LD_EXP 78
46749: PUSH
46750: LD_VAR 0 1
46754: ARRAY
46755: NOT
46756: IFFALSE 46760
// exit ;
46758: GO 46785
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
46760: LD_ADDR_EXP 83
46764: PUSH
46765: LD_EXP 83
46769: PPUSH
46770: LD_VAR 0 1
46774: PPUSH
46775: LD_VAR 0 2
46779: PPUSH
46780: CALL_OW 1
46784: ST_TO_ADDR
// end ;
46785: LD_VAR 0 3
46789: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
46790: LD_INT 0
46792: PPUSH
// if not mc_bases [ base ] then
46793: LD_EXP 78
46797: PUSH
46798: LD_VAR 0 1
46802: ARRAY
46803: NOT
46804: IFFALSE 46808
// exit ;
46806: GO 46845
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
46808: LD_ADDR_EXP 83
46812: PUSH
46813: LD_EXP 83
46817: PPUSH
46818: LD_VAR 0 1
46822: PPUSH
46823: LD_EXP 83
46827: PUSH
46828: LD_VAR 0 1
46832: ARRAY
46833: PUSH
46834: LD_VAR 0 2
46838: UNION
46839: PPUSH
46840: CALL_OW 1
46844: ST_TO_ADDR
// end ;
46845: LD_VAR 0 3
46849: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
46850: LD_INT 0
46852: PPUSH
// if not mc_bases [ base ] then
46853: LD_EXP 78
46857: PUSH
46858: LD_VAR 0 1
46862: ARRAY
46863: NOT
46864: IFFALSE 46868
// exit ;
46866: GO 46893
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
46868: LD_ADDR_EXP 99
46872: PUSH
46873: LD_EXP 99
46877: PPUSH
46878: LD_VAR 0 1
46882: PPUSH
46883: LD_VAR 0 2
46887: PPUSH
46888: CALL_OW 1
46892: ST_TO_ADDR
// end ;
46893: LD_VAR 0 3
46897: RET
// export function MC_InsertProduceList ( base , components ) ; begin
46898: LD_INT 0
46900: PPUSH
// if not mc_bases [ base ] then
46901: LD_EXP 78
46905: PUSH
46906: LD_VAR 0 1
46910: ARRAY
46911: NOT
46912: IFFALSE 46916
// exit ;
46914: GO 46953
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
46916: LD_ADDR_EXP 99
46920: PUSH
46921: LD_EXP 99
46925: PPUSH
46926: LD_VAR 0 1
46930: PPUSH
46931: LD_EXP 99
46935: PUSH
46936: LD_VAR 0 1
46940: ARRAY
46941: PUSH
46942: LD_VAR 0 2
46946: ADD
46947: PPUSH
46948: CALL_OW 1
46952: ST_TO_ADDR
// end ;
46953: LD_VAR 0 3
46957: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
46958: LD_INT 0
46960: PPUSH
// if not mc_bases [ base ] then
46961: LD_EXP 78
46965: PUSH
46966: LD_VAR 0 1
46970: ARRAY
46971: NOT
46972: IFFALSE 46976
// exit ;
46974: GO 47030
// mc_defender := Replace ( mc_defender , base , deflist ) ;
46976: LD_ADDR_EXP 100
46980: PUSH
46981: LD_EXP 100
46985: PPUSH
46986: LD_VAR 0 1
46990: PPUSH
46991: LD_VAR 0 2
46995: PPUSH
46996: CALL_OW 1
47000: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
47001: LD_ADDR_EXP 89
47005: PUSH
47006: LD_EXP 89
47010: PPUSH
47011: LD_VAR 0 1
47015: PPUSH
47016: LD_VAR 0 2
47020: PUSH
47021: LD_INT 0
47023: PLUS
47024: PPUSH
47025: CALL_OW 1
47029: ST_TO_ADDR
// end ;
47030: LD_VAR 0 3
47034: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
47035: LD_INT 0
47037: PPUSH
// if not mc_bases [ base ] then
47038: LD_EXP 78
47042: PUSH
47043: LD_VAR 0 1
47047: ARRAY
47048: NOT
47049: IFFALSE 47053
// exit ;
47051: GO 47078
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
47053: LD_ADDR_EXP 89
47057: PUSH
47058: LD_EXP 89
47062: PPUSH
47063: LD_VAR 0 1
47067: PPUSH
47068: LD_VAR 0 2
47072: PPUSH
47073: CALL_OW 1
47077: ST_TO_ADDR
// end ;
47078: LD_VAR 0 3
47082: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
47083: LD_INT 0
47085: PPUSH
47086: PPUSH
47087: PPUSH
47088: PPUSH
// if not mc_bases [ base ] then
47089: LD_EXP 78
47093: PUSH
47094: LD_VAR 0 1
47098: ARRAY
47099: NOT
47100: IFFALSE 47104
// exit ;
47102: GO 47169
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
47104: LD_ADDR_EXP 98
47108: PUSH
47109: LD_EXP 98
47113: PPUSH
47114: LD_VAR 0 1
47118: PUSH
47119: LD_EXP 98
47123: PUSH
47124: LD_VAR 0 1
47128: ARRAY
47129: PUSH
47130: LD_INT 1
47132: PLUS
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PPUSH
47138: LD_VAR 0 1
47142: PUSH
47143: LD_VAR 0 2
47147: PUSH
47148: LD_VAR 0 3
47152: PUSH
47153: LD_VAR 0 4
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: LIST
47162: LIST
47163: PPUSH
47164: CALL 58286 0 3
47168: ST_TO_ADDR
// end ;
47169: LD_VAR 0 5
47173: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
47174: LD_INT 0
47176: PPUSH
// if not mc_bases [ base ] then
47177: LD_EXP 78
47181: PUSH
47182: LD_VAR 0 1
47186: ARRAY
47187: NOT
47188: IFFALSE 47192
// exit ;
47190: GO 47217
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
47192: LD_ADDR_EXP 115
47196: PUSH
47197: LD_EXP 115
47201: PPUSH
47202: LD_VAR 0 1
47206: PPUSH
47207: LD_VAR 0 2
47211: PPUSH
47212: CALL_OW 1
47216: ST_TO_ADDR
// end ;
47217: LD_VAR 0 3
47221: RET
// export function MC_GetMinesField ( base ) ; begin
47222: LD_INT 0
47224: PPUSH
// result := mc_mines [ base ] ;
47225: LD_ADDR_VAR 0 2
47229: PUSH
47230: LD_EXP 91
47234: PUSH
47235: LD_VAR 0 1
47239: ARRAY
47240: ST_TO_ADDR
// end ;
47241: LD_VAR 0 2
47245: RET
// export function MC_GetProduceList ( base ) ; begin
47246: LD_INT 0
47248: PPUSH
// result := mc_produce [ base ] ;
47249: LD_ADDR_VAR 0 2
47253: PUSH
47254: LD_EXP 99
47258: PUSH
47259: LD_VAR 0 1
47263: ARRAY
47264: ST_TO_ADDR
// end ;
47265: LD_VAR 0 2
47269: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
47270: LD_INT 0
47272: PPUSH
47273: PPUSH
// if not mc_bases then
47274: LD_EXP 78
47278: NOT
47279: IFFALSE 47283
// exit ;
47281: GO 47348
// if mc_bases [ base ] then
47283: LD_EXP 78
47287: PUSH
47288: LD_VAR 0 1
47292: ARRAY
47293: IFFALSE 47348
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47295: LD_ADDR_VAR 0 3
47299: PUSH
47300: LD_EXP 78
47304: PUSH
47305: LD_VAR 0 1
47309: ARRAY
47310: PPUSH
47311: LD_INT 30
47313: PUSH
47314: LD_VAR 0 2
47318: PUSH
47319: EMPTY
47320: LIST
47321: LIST
47322: PPUSH
47323: CALL_OW 72
47327: ST_TO_ADDR
// if result then
47328: LD_VAR 0 3
47332: IFFALSE 47348
// result := result [ 1 ] ;
47334: LD_ADDR_VAR 0 3
47338: PUSH
47339: LD_VAR 0 3
47343: PUSH
47344: LD_INT 1
47346: ARRAY
47347: ST_TO_ADDR
// end ; end ;
47348: LD_VAR 0 3
47352: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
47353: LD_INT 0
47355: PPUSH
47356: PPUSH
// if not mc_bases then
47357: LD_EXP 78
47361: NOT
47362: IFFALSE 47366
// exit ;
47364: GO 47411
// if mc_bases [ base ] then
47366: LD_EXP 78
47370: PUSH
47371: LD_VAR 0 1
47375: ARRAY
47376: IFFALSE 47411
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47378: LD_ADDR_VAR 0 3
47382: PUSH
47383: LD_EXP 78
47387: PUSH
47388: LD_VAR 0 1
47392: ARRAY
47393: PPUSH
47394: LD_INT 30
47396: PUSH
47397: LD_VAR 0 2
47401: PUSH
47402: EMPTY
47403: LIST
47404: LIST
47405: PPUSH
47406: CALL_OW 72
47410: ST_TO_ADDR
// end ;
47411: LD_VAR 0 3
47415: RET
// export function MC_SetTame ( base , area ) ; begin
47416: LD_INT 0
47418: PPUSH
// if not mc_bases or not base then
47419: LD_EXP 78
47423: NOT
47424: PUSH
47425: LD_VAR 0 1
47429: NOT
47430: OR
47431: IFFALSE 47435
// exit ;
47433: GO 47460
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
47435: LD_ADDR_EXP 106
47439: PUSH
47440: LD_EXP 106
47444: PPUSH
47445: LD_VAR 0 1
47449: PPUSH
47450: LD_VAR 0 2
47454: PPUSH
47455: CALL_OW 1
47459: ST_TO_ADDR
// end ;
47460: LD_VAR 0 3
47464: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
47465: LD_INT 0
47467: PPUSH
47468: PPUSH
// if not mc_bases or not base then
47469: LD_EXP 78
47473: NOT
47474: PUSH
47475: LD_VAR 0 1
47479: NOT
47480: OR
47481: IFFALSE 47485
// exit ;
47483: GO 47587
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47485: LD_ADDR_VAR 0 4
47489: PUSH
47490: LD_EXP 78
47494: PUSH
47495: LD_VAR 0 1
47499: ARRAY
47500: PPUSH
47501: LD_INT 30
47503: PUSH
47504: LD_VAR 0 2
47508: PUSH
47509: EMPTY
47510: LIST
47511: LIST
47512: PPUSH
47513: CALL_OW 72
47517: ST_TO_ADDR
// if not tmp then
47518: LD_VAR 0 4
47522: NOT
47523: IFFALSE 47527
// exit ;
47525: GO 47587
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47527: LD_ADDR_EXP 110
47531: PUSH
47532: LD_EXP 110
47536: PPUSH
47537: LD_VAR 0 1
47541: PPUSH
47542: LD_EXP 110
47546: PUSH
47547: LD_VAR 0 1
47551: ARRAY
47552: PPUSH
47553: LD_EXP 110
47557: PUSH
47558: LD_VAR 0 1
47562: ARRAY
47563: PUSH
47564: LD_INT 1
47566: PLUS
47567: PPUSH
47568: LD_VAR 0 4
47572: PUSH
47573: LD_INT 1
47575: ARRAY
47576: PPUSH
47577: CALL_OW 2
47581: PPUSH
47582: CALL_OW 1
47586: ST_TO_ADDR
// end ;
47587: LD_VAR 0 3
47591: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47592: LD_INT 0
47594: PPUSH
47595: PPUSH
// if not mc_bases or not base or not kinds then
47596: LD_EXP 78
47600: NOT
47601: PUSH
47602: LD_VAR 0 1
47606: NOT
47607: OR
47608: PUSH
47609: LD_VAR 0 2
47613: NOT
47614: OR
47615: IFFALSE 47619
// exit ;
47617: GO 47680
// for i in kinds do
47619: LD_ADDR_VAR 0 4
47623: PUSH
47624: LD_VAR 0 2
47628: PUSH
47629: FOR_IN
47630: IFFALSE 47678
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
47632: LD_ADDR_EXP 112
47636: PUSH
47637: LD_EXP 112
47641: PPUSH
47642: LD_VAR 0 1
47646: PUSH
47647: LD_EXP 112
47651: PUSH
47652: LD_VAR 0 1
47656: ARRAY
47657: PUSH
47658: LD_INT 1
47660: PLUS
47661: PUSH
47662: EMPTY
47663: LIST
47664: LIST
47665: PPUSH
47666: LD_VAR 0 4
47670: PPUSH
47671: CALL 58286 0 3
47675: ST_TO_ADDR
47676: GO 47629
47678: POP
47679: POP
// end ;
47680: LD_VAR 0 3
47684: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
47685: LD_INT 0
47687: PPUSH
// if not mc_bases or not base or not areas then
47688: LD_EXP 78
47692: NOT
47693: PUSH
47694: LD_VAR 0 1
47698: NOT
47699: OR
47700: PUSH
47701: LD_VAR 0 2
47705: NOT
47706: OR
47707: IFFALSE 47711
// exit ;
47709: GO 47736
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
47711: LD_ADDR_EXP 96
47715: PUSH
47716: LD_EXP 96
47720: PPUSH
47721: LD_VAR 0 1
47725: PPUSH
47726: LD_VAR 0 2
47730: PPUSH
47731: CALL_OW 1
47735: ST_TO_ADDR
// end ;
47736: LD_VAR 0 3
47740: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
47741: LD_INT 0
47743: PPUSH
// if not mc_bases or not base or not teleports_exit then
47744: LD_EXP 78
47748: NOT
47749: PUSH
47750: LD_VAR 0 1
47754: NOT
47755: OR
47756: PUSH
47757: LD_VAR 0 2
47761: NOT
47762: OR
47763: IFFALSE 47767
// exit ;
47765: GO 47792
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
47767: LD_ADDR_EXP 113
47771: PUSH
47772: LD_EXP 113
47776: PPUSH
47777: LD_VAR 0 1
47781: PPUSH
47782: LD_VAR 0 2
47786: PPUSH
47787: CALL_OW 1
47791: ST_TO_ADDR
// end ;
47792: LD_VAR 0 3
47796: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
47797: LD_INT 0
47799: PPUSH
47800: PPUSH
47801: PPUSH
// if not mc_bases or not base or not ext_list then
47802: LD_EXP 78
47806: NOT
47807: PUSH
47808: LD_VAR 0 1
47812: NOT
47813: OR
47814: PUSH
47815: LD_VAR 0 5
47819: NOT
47820: OR
47821: IFFALSE 47825
// exit ;
47823: GO 47998
// tmp := GetFacExtXYD ( x , y , d ) ;
47825: LD_ADDR_VAR 0 8
47829: PUSH
47830: LD_VAR 0 2
47834: PPUSH
47835: LD_VAR 0 3
47839: PPUSH
47840: LD_VAR 0 4
47844: PPUSH
47845: CALL 88649 0 3
47849: ST_TO_ADDR
// if not tmp then
47850: LD_VAR 0 8
47854: NOT
47855: IFFALSE 47859
// exit ;
47857: GO 47998
// for i in tmp do
47859: LD_ADDR_VAR 0 7
47863: PUSH
47864: LD_VAR 0 8
47868: PUSH
47869: FOR_IN
47870: IFFALSE 47996
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
47872: LD_ADDR_EXP 83
47876: PUSH
47877: LD_EXP 83
47881: PPUSH
47882: LD_VAR 0 1
47886: PPUSH
47887: LD_EXP 83
47891: PUSH
47892: LD_VAR 0 1
47896: ARRAY
47897: PPUSH
47898: LD_EXP 83
47902: PUSH
47903: LD_VAR 0 1
47907: ARRAY
47908: PUSH
47909: LD_INT 1
47911: PLUS
47912: PPUSH
47913: LD_VAR 0 5
47917: PUSH
47918: LD_INT 1
47920: ARRAY
47921: PUSH
47922: LD_VAR 0 7
47926: PUSH
47927: LD_INT 1
47929: ARRAY
47930: PUSH
47931: LD_VAR 0 7
47935: PUSH
47936: LD_INT 2
47938: ARRAY
47939: PUSH
47940: LD_VAR 0 7
47944: PUSH
47945: LD_INT 3
47947: ARRAY
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: LIST
47953: LIST
47954: PPUSH
47955: CALL_OW 2
47959: PPUSH
47960: CALL_OW 1
47964: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
47965: LD_ADDR_VAR 0 5
47969: PUSH
47970: LD_VAR 0 5
47974: PPUSH
47975: LD_INT 1
47977: PPUSH
47978: CALL_OW 3
47982: ST_TO_ADDR
// if not ext_list then
47983: LD_VAR 0 5
47987: NOT
47988: IFFALSE 47994
// exit ;
47990: POP
47991: POP
47992: GO 47998
// end ;
47994: GO 47869
47996: POP
47997: POP
// end ;
47998: LD_VAR 0 6
48002: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
48003: LD_INT 0
48005: PPUSH
// if not mc_bases or not base or not weapon_list then
48006: LD_EXP 78
48010: NOT
48011: PUSH
48012: LD_VAR 0 1
48016: NOT
48017: OR
48018: PUSH
48019: LD_VAR 0 2
48023: NOT
48024: OR
48025: IFFALSE 48029
// exit ;
48027: GO 48054
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
48029: LD_ADDR_EXP 117
48033: PUSH
48034: LD_EXP 117
48038: PPUSH
48039: LD_VAR 0 1
48043: PPUSH
48044: LD_VAR 0 2
48048: PPUSH
48049: CALL_OW 1
48053: ST_TO_ADDR
// end ;
48054: LD_VAR 0 3
48058: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
48059: LD_INT 0
48061: PPUSH
// if not mc_bases or not base or not tech_list then
48062: LD_EXP 78
48066: NOT
48067: PUSH
48068: LD_VAR 0 1
48072: NOT
48073: OR
48074: PUSH
48075: LD_VAR 0 2
48079: NOT
48080: OR
48081: IFFALSE 48085
// exit ;
48083: GO 48110
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
48085: LD_ADDR_EXP 105
48089: PUSH
48090: LD_EXP 105
48094: PPUSH
48095: LD_VAR 0 1
48099: PPUSH
48100: LD_VAR 0 2
48104: PPUSH
48105: CALL_OW 1
48109: ST_TO_ADDR
// end ;
48110: LD_VAR 0 3
48114: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
48115: LD_INT 0
48117: PPUSH
// if not mc_bases or not parking_area or not base then
48118: LD_EXP 78
48122: NOT
48123: PUSH
48124: LD_VAR 0 2
48128: NOT
48129: OR
48130: PUSH
48131: LD_VAR 0 1
48135: NOT
48136: OR
48137: IFFALSE 48141
// exit ;
48139: GO 48166
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
48141: LD_ADDR_EXP 102
48145: PUSH
48146: LD_EXP 102
48150: PPUSH
48151: LD_VAR 0 1
48155: PPUSH
48156: LD_VAR 0 2
48160: PPUSH
48161: CALL_OW 1
48165: ST_TO_ADDR
// end ;
48166: LD_VAR 0 3
48170: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
48171: LD_INT 0
48173: PPUSH
// if not mc_bases or not base or not scan_area then
48174: LD_EXP 78
48178: NOT
48179: PUSH
48180: LD_VAR 0 1
48184: NOT
48185: OR
48186: PUSH
48187: LD_VAR 0 2
48191: NOT
48192: OR
48193: IFFALSE 48197
// exit ;
48195: GO 48222
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
48197: LD_ADDR_EXP 103
48201: PUSH
48202: LD_EXP 103
48206: PPUSH
48207: LD_VAR 0 1
48211: PPUSH
48212: LD_VAR 0 2
48216: PPUSH
48217: CALL_OW 1
48221: ST_TO_ADDR
// end ;
48222: LD_VAR 0 3
48226: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
48227: LD_INT 0
48229: PPUSH
48230: PPUSH
// if not mc_bases or not base then
48231: LD_EXP 78
48235: NOT
48236: PUSH
48237: LD_VAR 0 1
48241: NOT
48242: OR
48243: IFFALSE 48247
// exit ;
48245: GO 48311
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
48247: LD_ADDR_VAR 0 3
48251: PUSH
48252: LD_INT 1
48254: PUSH
48255: LD_INT 2
48257: PUSH
48258: LD_INT 3
48260: PUSH
48261: LD_INT 4
48263: PUSH
48264: LD_INT 11
48266: PUSH
48267: EMPTY
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
48274: LD_ADDR_EXP 105
48278: PUSH
48279: LD_EXP 105
48283: PPUSH
48284: LD_VAR 0 1
48288: PPUSH
48289: LD_EXP 105
48293: PUSH
48294: LD_VAR 0 1
48298: ARRAY
48299: PUSH
48300: LD_VAR 0 3
48304: DIFF
48305: PPUSH
48306: CALL_OW 1
48310: ST_TO_ADDR
// end ;
48311: LD_VAR 0 2
48315: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
48316: LD_INT 0
48318: PPUSH
// result := mc_vehicles [ base ] ;
48319: LD_ADDR_VAR 0 3
48323: PUSH
48324: LD_EXP 97
48328: PUSH
48329: LD_VAR 0 1
48333: ARRAY
48334: ST_TO_ADDR
// if onlyCombat then
48335: LD_VAR 0 2
48339: IFFALSE 48511
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
48341: LD_ADDR_VAR 0 3
48345: PUSH
48346: LD_VAR 0 3
48350: PUSH
48351: LD_VAR 0 3
48355: PPUSH
48356: LD_INT 2
48358: PUSH
48359: LD_INT 34
48361: PUSH
48362: LD_INT 12
48364: PUSH
48365: EMPTY
48366: LIST
48367: LIST
48368: PUSH
48369: LD_INT 34
48371: PUSH
48372: LD_INT 51
48374: PUSH
48375: EMPTY
48376: LIST
48377: LIST
48378: PUSH
48379: LD_INT 34
48381: PUSH
48382: LD_INT 89
48384: PUSH
48385: EMPTY
48386: LIST
48387: LIST
48388: PUSH
48389: LD_INT 34
48391: PUSH
48392: LD_INT 32
48394: PUSH
48395: EMPTY
48396: LIST
48397: LIST
48398: PUSH
48399: LD_INT 34
48401: PUSH
48402: LD_INT 13
48404: PUSH
48405: EMPTY
48406: LIST
48407: LIST
48408: PUSH
48409: LD_INT 34
48411: PUSH
48412: LD_INT 52
48414: PUSH
48415: EMPTY
48416: LIST
48417: LIST
48418: PUSH
48419: LD_INT 34
48421: PUSH
48422: LD_INT 88
48424: PUSH
48425: EMPTY
48426: LIST
48427: LIST
48428: PUSH
48429: LD_INT 34
48431: PUSH
48432: LD_INT 14
48434: PUSH
48435: EMPTY
48436: LIST
48437: LIST
48438: PUSH
48439: LD_INT 34
48441: PUSH
48442: LD_INT 53
48444: PUSH
48445: EMPTY
48446: LIST
48447: LIST
48448: PUSH
48449: LD_INT 34
48451: PUSH
48452: LD_INT 98
48454: PUSH
48455: EMPTY
48456: LIST
48457: LIST
48458: PUSH
48459: LD_INT 34
48461: PUSH
48462: LD_INT 31
48464: PUSH
48465: EMPTY
48466: LIST
48467: LIST
48468: PUSH
48469: LD_INT 34
48471: PUSH
48472: LD_INT 48
48474: PUSH
48475: EMPTY
48476: LIST
48477: LIST
48478: PUSH
48479: LD_INT 34
48481: PUSH
48482: LD_INT 8
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: PUSH
48489: EMPTY
48490: LIST
48491: LIST
48492: LIST
48493: LIST
48494: LIST
48495: LIST
48496: LIST
48497: LIST
48498: LIST
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: PPUSH
48505: CALL_OW 72
48509: DIFF
48510: ST_TO_ADDR
// end ; end_of_file
48511: LD_VAR 0 3
48515: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48516: LD_INT 0
48518: PPUSH
48519: PPUSH
48520: PPUSH
// if not mc_bases or not skirmish then
48521: LD_EXP 78
48525: NOT
48526: PUSH
48527: LD_EXP 76
48531: NOT
48532: OR
48533: IFFALSE 48537
// exit ;
48535: GO 48702
// for i = 1 to mc_bases do
48537: LD_ADDR_VAR 0 4
48541: PUSH
48542: DOUBLE
48543: LD_INT 1
48545: DEC
48546: ST_TO_ADDR
48547: LD_EXP 78
48551: PUSH
48552: FOR_TO
48553: IFFALSE 48700
// begin if sci in mc_bases [ i ] then
48555: LD_VAR 0 2
48559: PUSH
48560: LD_EXP 78
48564: PUSH
48565: LD_VAR 0 4
48569: ARRAY
48570: IN
48571: IFFALSE 48698
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48573: LD_ADDR_EXP 107
48577: PUSH
48578: LD_EXP 107
48582: PPUSH
48583: LD_VAR 0 4
48587: PUSH
48588: LD_EXP 107
48592: PUSH
48593: LD_VAR 0 4
48597: ARRAY
48598: PUSH
48599: LD_INT 1
48601: PLUS
48602: PUSH
48603: EMPTY
48604: LIST
48605: LIST
48606: PPUSH
48607: LD_VAR 0 1
48611: PPUSH
48612: CALL 58286 0 3
48616: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
48617: LD_ADDR_VAR 0 5
48621: PUSH
48622: LD_EXP 78
48626: PUSH
48627: LD_VAR 0 4
48631: ARRAY
48632: PPUSH
48633: LD_INT 2
48635: PUSH
48636: LD_INT 30
48638: PUSH
48639: LD_INT 0
48641: PUSH
48642: EMPTY
48643: LIST
48644: LIST
48645: PUSH
48646: LD_INT 30
48648: PUSH
48649: LD_INT 1
48651: PUSH
48652: EMPTY
48653: LIST
48654: LIST
48655: PUSH
48656: EMPTY
48657: LIST
48658: LIST
48659: LIST
48660: PPUSH
48661: CALL_OW 72
48665: PPUSH
48666: LD_VAR 0 1
48670: PPUSH
48671: CALL_OW 74
48675: ST_TO_ADDR
// if tmp then
48676: LD_VAR 0 5
48680: IFFALSE 48696
// ComStandNearbyBuilding ( ape , tmp ) ;
48682: LD_VAR 0 1
48686: PPUSH
48687: LD_VAR 0 5
48691: PPUSH
48692: CALL 54888 0 2
// break ;
48696: GO 48700
// end ; end ;
48698: GO 48552
48700: POP
48701: POP
// end ;
48702: LD_VAR 0 3
48706: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
48707: LD_INT 0
48709: PPUSH
48710: PPUSH
48711: PPUSH
// if not mc_bases or not skirmish then
48712: LD_EXP 78
48716: NOT
48717: PUSH
48718: LD_EXP 76
48722: NOT
48723: OR
48724: IFFALSE 48728
// exit ;
48726: GO 48817
// for i = 1 to mc_bases do
48728: LD_ADDR_VAR 0 4
48732: PUSH
48733: DOUBLE
48734: LD_INT 1
48736: DEC
48737: ST_TO_ADDR
48738: LD_EXP 78
48742: PUSH
48743: FOR_TO
48744: IFFALSE 48815
// begin if building in mc_busy_turret_list [ i ] then
48746: LD_VAR 0 1
48750: PUSH
48751: LD_EXP 88
48755: PUSH
48756: LD_VAR 0 4
48760: ARRAY
48761: IN
48762: IFFALSE 48813
// begin tmp := mc_busy_turret_list [ i ] diff building ;
48764: LD_ADDR_VAR 0 5
48768: PUSH
48769: LD_EXP 88
48773: PUSH
48774: LD_VAR 0 4
48778: ARRAY
48779: PUSH
48780: LD_VAR 0 1
48784: DIFF
48785: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
48786: LD_ADDR_EXP 88
48790: PUSH
48791: LD_EXP 88
48795: PPUSH
48796: LD_VAR 0 4
48800: PPUSH
48801: LD_VAR 0 5
48805: PPUSH
48806: CALL_OW 1
48810: ST_TO_ADDR
// break ;
48811: GO 48815
// end ; end ;
48813: GO 48743
48815: POP
48816: POP
// end ;
48817: LD_VAR 0 3
48821: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
48822: LD_INT 0
48824: PPUSH
48825: PPUSH
48826: PPUSH
// if not mc_bases or not skirmish then
48827: LD_EXP 78
48831: NOT
48832: PUSH
48833: LD_EXP 76
48837: NOT
48838: OR
48839: IFFALSE 48843
// exit ;
48841: GO 49042
// for i = 1 to mc_bases do
48843: LD_ADDR_VAR 0 5
48847: PUSH
48848: DOUBLE
48849: LD_INT 1
48851: DEC
48852: ST_TO_ADDR
48853: LD_EXP 78
48857: PUSH
48858: FOR_TO
48859: IFFALSE 49040
// if building in mc_bases [ i ] then
48861: LD_VAR 0 1
48865: PUSH
48866: LD_EXP 78
48870: PUSH
48871: LD_VAR 0 5
48875: ARRAY
48876: IN
48877: IFFALSE 49038
// begin tmp := mc_bases [ i ] diff building ;
48879: LD_ADDR_VAR 0 6
48883: PUSH
48884: LD_EXP 78
48888: PUSH
48889: LD_VAR 0 5
48893: ARRAY
48894: PUSH
48895: LD_VAR 0 1
48899: DIFF
48900: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
48901: LD_ADDR_EXP 78
48905: PUSH
48906: LD_EXP 78
48910: PPUSH
48911: LD_VAR 0 5
48915: PPUSH
48916: LD_VAR 0 6
48920: PPUSH
48921: CALL_OW 1
48925: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
48926: LD_VAR 0 1
48930: PUSH
48931: LD_EXP 86
48935: PUSH
48936: LD_VAR 0 5
48940: ARRAY
48941: IN
48942: IFFALSE 48981
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
48944: LD_ADDR_EXP 86
48948: PUSH
48949: LD_EXP 86
48953: PPUSH
48954: LD_VAR 0 5
48958: PPUSH
48959: LD_EXP 86
48963: PUSH
48964: LD_VAR 0 5
48968: ARRAY
48969: PUSH
48970: LD_VAR 0 1
48974: DIFF
48975: PPUSH
48976: CALL_OW 1
48980: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
48981: LD_VAR 0 1
48985: PUSH
48986: LD_EXP 87
48990: PUSH
48991: LD_VAR 0 5
48995: ARRAY
48996: IN
48997: IFFALSE 49036
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
48999: LD_ADDR_EXP 87
49003: PUSH
49004: LD_EXP 87
49008: PPUSH
49009: LD_VAR 0 5
49013: PPUSH
49014: LD_EXP 87
49018: PUSH
49019: LD_VAR 0 5
49023: ARRAY
49024: PUSH
49025: LD_VAR 0 1
49029: DIFF
49030: PPUSH
49031: CALL_OW 1
49035: ST_TO_ADDR
// break ;
49036: GO 49040
// end ;
49038: GO 48858
49040: POP
49041: POP
// end ;
49042: LD_VAR 0 4
49046: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
49047: LD_INT 0
49049: PPUSH
49050: PPUSH
49051: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
49052: LD_EXP 78
49056: NOT
49057: PUSH
49058: LD_EXP 76
49062: NOT
49063: OR
49064: PUSH
49065: LD_VAR 0 3
49069: PUSH
49070: LD_EXP 104
49074: IN
49075: NOT
49076: OR
49077: IFFALSE 49081
// exit ;
49079: GO 49204
// for i = 1 to mc_vehicles do
49081: LD_ADDR_VAR 0 6
49085: PUSH
49086: DOUBLE
49087: LD_INT 1
49089: DEC
49090: ST_TO_ADDR
49091: LD_EXP 97
49095: PUSH
49096: FOR_TO
49097: IFFALSE 49202
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
49099: LD_VAR 0 2
49103: PUSH
49104: LD_EXP 97
49108: PUSH
49109: LD_VAR 0 6
49113: ARRAY
49114: IN
49115: PUSH
49116: LD_VAR 0 1
49120: PUSH
49121: LD_EXP 97
49125: PUSH
49126: LD_VAR 0 6
49130: ARRAY
49131: IN
49132: OR
49133: IFFALSE 49200
// begin tmp := mc_vehicles [ i ] diff old ;
49135: LD_ADDR_VAR 0 7
49139: PUSH
49140: LD_EXP 97
49144: PUSH
49145: LD_VAR 0 6
49149: ARRAY
49150: PUSH
49151: LD_VAR 0 2
49155: DIFF
49156: ST_TO_ADDR
// tmp := tmp diff new ;
49157: LD_ADDR_VAR 0 7
49161: PUSH
49162: LD_VAR 0 7
49166: PUSH
49167: LD_VAR 0 1
49171: DIFF
49172: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
49173: LD_ADDR_EXP 97
49177: PUSH
49178: LD_EXP 97
49182: PPUSH
49183: LD_VAR 0 6
49187: PPUSH
49188: LD_VAR 0 7
49192: PPUSH
49193: CALL_OW 1
49197: ST_TO_ADDR
// break ;
49198: GO 49202
// end ;
49200: GO 49096
49202: POP
49203: POP
// end ;
49204: LD_VAR 0 5
49208: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
49209: LD_INT 0
49211: PPUSH
49212: PPUSH
49213: PPUSH
49214: PPUSH
// if not mc_bases or not skirmish then
49215: LD_EXP 78
49219: NOT
49220: PUSH
49221: LD_EXP 76
49225: NOT
49226: OR
49227: IFFALSE 49231
// exit ;
49229: GO 49651
// repeat wait ( 0 0$1 ) ;
49231: LD_INT 35
49233: PPUSH
49234: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
49238: LD_EXP 122
49242: NOT
49243: IFFALSE 49231
// mc_block_vehicle_constructed_thread := true ;
49245: LD_ADDR_EXP 122
49249: PUSH
49250: LD_INT 1
49252: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
49253: LD_ADDR_VAR 0 5
49257: PUSH
49258: LD_VAR 0 1
49262: PPUSH
49263: CALL_OW 255
49267: ST_TO_ADDR
// for i = 1 to mc_bases do
49268: LD_ADDR_VAR 0 4
49272: PUSH
49273: DOUBLE
49274: LD_INT 1
49276: DEC
49277: ST_TO_ADDR
49278: LD_EXP 78
49282: PUSH
49283: FOR_TO
49284: IFFALSE 49641
// begin if factory in mc_bases [ i ] then
49286: LD_VAR 0 2
49290: PUSH
49291: LD_EXP 78
49295: PUSH
49296: LD_VAR 0 4
49300: ARRAY
49301: IN
49302: IFFALSE 49639
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
49304: LD_EXP 100
49308: PUSH
49309: LD_VAR 0 4
49313: ARRAY
49314: PUSH
49315: LD_EXP 89
49319: PUSH
49320: LD_VAR 0 4
49324: ARRAY
49325: LESS
49326: PUSH
49327: LD_VAR 0 1
49331: PPUSH
49332: CALL_OW 264
49336: PUSH
49337: LD_INT 31
49339: PUSH
49340: LD_INT 32
49342: PUSH
49343: LD_INT 51
49345: PUSH
49346: LD_INT 89
49348: PUSH
49349: LD_INT 12
49351: PUSH
49352: LD_INT 30
49354: PUSH
49355: LD_INT 98
49357: PUSH
49358: LD_INT 11
49360: PUSH
49361: LD_INT 53
49363: PUSH
49364: LD_INT 14
49366: PUSH
49367: LD_INT 91
49369: PUSH
49370: LD_INT 29
49372: PUSH
49373: LD_INT 99
49375: PUSH
49376: LD_INT 13
49378: PUSH
49379: LD_INT 52
49381: PUSH
49382: LD_INT 88
49384: PUSH
49385: LD_INT 48
49387: PUSH
49388: LD_INT 8
49390: PUSH
49391: EMPTY
49392: LIST
49393: LIST
49394: LIST
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: IN
49411: NOT
49412: AND
49413: IFFALSE 49461
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
49415: LD_ADDR_EXP 100
49419: PUSH
49420: LD_EXP 100
49424: PPUSH
49425: LD_VAR 0 4
49429: PUSH
49430: LD_EXP 100
49434: PUSH
49435: LD_VAR 0 4
49439: ARRAY
49440: PUSH
49441: LD_INT 1
49443: PLUS
49444: PUSH
49445: EMPTY
49446: LIST
49447: LIST
49448: PPUSH
49449: LD_VAR 0 1
49453: PPUSH
49454: CALL 58286 0 3
49458: ST_TO_ADDR
49459: GO 49505
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
49461: LD_ADDR_EXP 97
49465: PUSH
49466: LD_EXP 97
49470: PPUSH
49471: LD_VAR 0 4
49475: PUSH
49476: LD_EXP 97
49480: PUSH
49481: LD_VAR 0 4
49485: ARRAY
49486: PUSH
49487: LD_INT 1
49489: PLUS
49490: PUSH
49491: EMPTY
49492: LIST
49493: LIST
49494: PPUSH
49495: LD_VAR 0 1
49499: PPUSH
49500: CALL 58286 0 3
49504: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
49505: LD_ADDR_EXP 122
49509: PUSH
49510: LD_INT 0
49512: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49513: LD_VAR 0 1
49517: PPUSH
49518: CALL_OW 263
49522: PUSH
49523: LD_INT 2
49525: EQUAL
49526: IFFALSE 49555
// begin repeat wait ( 0 0$3 ) ;
49528: LD_INT 105
49530: PPUSH
49531: CALL_OW 67
// Connect ( vehicle ) ;
49535: LD_VAR 0 1
49539: PPUSH
49540: CALL 61632 0 1
// until IsControledBy ( vehicle ) ;
49544: LD_VAR 0 1
49548: PPUSH
49549: CALL_OW 312
49553: IFFALSE 49528
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49555: LD_VAR 0 1
49559: PPUSH
49560: LD_EXP 102
49564: PUSH
49565: LD_VAR 0 4
49569: ARRAY
49570: PPUSH
49571: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49575: LD_VAR 0 1
49579: PPUSH
49580: CALL_OW 263
49584: PUSH
49585: LD_INT 1
49587: NONEQUAL
49588: IFFALSE 49592
// break ;
49590: GO 49641
// repeat wait ( 0 0$1 ) ;
49592: LD_INT 35
49594: PPUSH
49595: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
49599: LD_VAR 0 1
49603: PPUSH
49604: LD_EXP 102
49608: PUSH
49609: LD_VAR 0 4
49613: ARRAY
49614: PPUSH
49615: CALL_OW 308
49619: IFFALSE 49592
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
49621: LD_VAR 0 1
49625: PPUSH
49626: CALL_OW 311
49630: PPUSH
49631: CALL_OW 121
// exit ;
49635: POP
49636: POP
49637: GO 49651
// end ; end ;
49639: GO 49283
49641: POP
49642: POP
// mc_block_vehicle_constructed_thread := false ;
49643: LD_ADDR_EXP 122
49647: PUSH
49648: LD_INT 0
49650: ST_TO_ADDR
// end ;
49651: LD_VAR 0 3
49655: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
49656: LD_INT 0
49658: PPUSH
49659: PPUSH
49660: PPUSH
49661: PPUSH
// if not mc_bases or not skirmish then
49662: LD_EXP 78
49666: NOT
49667: PUSH
49668: LD_EXP 76
49672: NOT
49673: OR
49674: IFFALSE 49678
// exit ;
49676: GO 50031
// repeat wait ( 0 0$1 ) ;
49678: LD_INT 35
49680: PPUSH
49681: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
49685: LD_VAR 0 2
49689: PPUSH
49690: LD_VAR 0 3
49694: PPUSH
49695: CALL_OW 284
49699: IFFALSE 49678
// if GetResourceTypeXY ( x , y ) = mat_artefact then
49701: LD_VAR 0 2
49705: PPUSH
49706: LD_VAR 0 3
49710: PPUSH
49711: CALL_OW 283
49715: PUSH
49716: LD_INT 4
49718: EQUAL
49719: IFFALSE 49723
// exit ;
49721: GO 50031
// for i = 1 to mc_bases do
49723: LD_ADDR_VAR 0 7
49727: PUSH
49728: DOUBLE
49729: LD_INT 1
49731: DEC
49732: ST_TO_ADDR
49733: LD_EXP 78
49737: PUSH
49738: FOR_TO
49739: IFFALSE 50029
// begin if mc_crates_area [ i ] then
49741: LD_EXP 96
49745: PUSH
49746: LD_VAR 0 7
49750: ARRAY
49751: IFFALSE 49862
// for j in mc_crates_area [ i ] do
49753: LD_ADDR_VAR 0 8
49757: PUSH
49758: LD_EXP 96
49762: PUSH
49763: LD_VAR 0 7
49767: ARRAY
49768: PUSH
49769: FOR_IN
49770: IFFALSE 49860
// if InArea ( x , y , j ) then
49772: LD_VAR 0 2
49776: PPUSH
49777: LD_VAR 0 3
49781: PPUSH
49782: LD_VAR 0 8
49786: PPUSH
49787: CALL_OW 309
49791: IFFALSE 49858
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49793: LD_ADDR_EXP 94
49797: PUSH
49798: LD_EXP 94
49802: PPUSH
49803: LD_VAR 0 7
49807: PUSH
49808: LD_EXP 94
49812: PUSH
49813: LD_VAR 0 7
49817: ARRAY
49818: PUSH
49819: LD_INT 1
49821: PLUS
49822: PUSH
49823: EMPTY
49824: LIST
49825: LIST
49826: PPUSH
49827: LD_VAR 0 4
49831: PUSH
49832: LD_VAR 0 2
49836: PUSH
49837: LD_VAR 0 3
49841: PUSH
49842: EMPTY
49843: LIST
49844: LIST
49845: LIST
49846: PPUSH
49847: CALL 58286 0 3
49851: ST_TO_ADDR
// exit ;
49852: POP
49853: POP
49854: POP
49855: POP
49856: GO 50031
// end ;
49858: GO 49769
49860: POP
49861: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49862: LD_ADDR_VAR 0 9
49866: PUSH
49867: LD_EXP 78
49871: PUSH
49872: LD_VAR 0 7
49876: ARRAY
49877: PPUSH
49878: LD_INT 2
49880: PUSH
49881: LD_INT 30
49883: PUSH
49884: LD_INT 0
49886: PUSH
49887: EMPTY
49888: LIST
49889: LIST
49890: PUSH
49891: LD_INT 30
49893: PUSH
49894: LD_INT 1
49896: PUSH
49897: EMPTY
49898: LIST
49899: LIST
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: LIST
49905: PPUSH
49906: CALL_OW 72
49910: ST_TO_ADDR
// if not depot then
49911: LD_VAR 0 9
49915: NOT
49916: IFFALSE 49920
// continue ;
49918: GO 49738
// for j in depot do
49920: LD_ADDR_VAR 0 8
49924: PUSH
49925: LD_VAR 0 9
49929: PUSH
49930: FOR_IN
49931: IFFALSE 50025
// if GetDistUnitXY ( j , x , y ) < 30 then
49933: LD_VAR 0 8
49937: PPUSH
49938: LD_VAR 0 2
49942: PPUSH
49943: LD_VAR 0 3
49947: PPUSH
49948: CALL_OW 297
49952: PUSH
49953: LD_INT 30
49955: LESS
49956: IFFALSE 50023
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49958: LD_ADDR_EXP 94
49962: PUSH
49963: LD_EXP 94
49967: PPUSH
49968: LD_VAR 0 7
49972: PUSH
49973: LD_EXP 94
49977: PUSH
49978: LD_VAR 0 7
49982: ARRAY
49983: PUSH
49984: LD_INT 1
49986: PLUS
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: PPUSH
49992: LD_VAR 0 4
49996: PUSH
49997: LD_VAR 0 2
50001: PUSH
50002: LD_VAR 0 3
50006: PUSH
50007: EMPTY
50008: LIST
50009: LIST
50010: LIST
50011: PPUSH
50012: CALL 58286 0 3
50016: ST_TO_ADDR
// exit ;
50017: POP
50018: POP
50019: POP
50020: POP
50021: GO 50031
// end ;
50023: GO 49930
50025: POP
50026: POP
// end ;
50027: GO 49738
50029: POP
50030: POP
// end ;
50031: LD_VAR 0 6
50035: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
50036: LD_INT 0
50038: PPUSH
50039: PPUSH
50040: PPUSH
50041: PPUSH
// if not mc_bases or not skirmish then
50042: LD_EXP 78
50046: NOT
50047: PUSH
50048: LD_EXP 76
50052: NOT
50053: OR
50054: IFFALSE 50058
// exit ;
50056: GO 50335
// side := GetSide ( lab ) ;
50058: LD_ADDR_VAR 0 4
50062: PUSH
50063: LD_VAR 0 2
50067: PPUSH
50068: CALL_OW 255
50072: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
50073: LD_VAR 0 4
50077: PUSH
50078: LD_EXP 104
50082: IN
50083: NOT
50084: PUSH
50085: LD_EXP 105
50089: NOT
50090: OR
50091: PUSH
50092: LD_EXP 78
50096: NOT
50097: OR
50098: IFFALSE 50102
// exit ;
50100: GO 50335
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
50102: LD_ADDR_EXP 105
50106: PUSH
50107: LD_EXP 105
50111: PPUSH
50112: LD_VAR 0 4
50116: PPUSH
50117: LD_EXP 105
50121: PUSH
50122: LD_VAR 0 4
50126: ARRAY
50127: PUSH
50128: LD_VAR 0 1
50132: DIFF
50133: PPUSH
50134: CALL_OW 1
50138: ST_TO_ADDR
// for i = 1 to mc_bases do
50139: LD_ADDR_VAR 0 5
50143: PUSH
50144: DOUBLE
50145: LD_INT 1
50147: DEC
50148: ST_TO_ADDR
50149: LD_EXP 78
50153: PUSH
50154: FOR_TO
50155: IFFALSE 50333
// begin if lab in mc_bases [ i ] then
50157: LD_VAR 0 2
50161: PUSH
50162: LD_EXP 78
50166: PUSH
50167: LD_VAR 0 5
50171: ARRAY
50172: IN
50173: IFFALSE 50331
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
50175: LD_VAR 0 1
50179: PUSH
50180: LD_INT 11
50182: PUSH
50183: LD_INT 4
50185: PUSH
50186: LD_INT 3
50188: PUSH
50189: LD_INT 2
50191: PUSH
50192: EMPTY
50193: LIST
50194: LIST
50195: LIST
50196: LIST
50197: IN
50198: PUSH
50199: LD_EXP 108
50203: PUSH
50204: LD_VAR 0 5
50208: ARRAY
50209: AND
50210: IFFALSE 50331
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
50212: LD_ADDR_VAR 0 6
50216: PUSH
50217: LD_EXP 108
50221: PUSH
50222: LD_VAR 0 5
50226: ARRAY
50227: PUSH
50228: LD_INT 1
50230: ARRAY
50231: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50232: LD_ADDR_EXP 108
50236: PUSH
50237: LD_EXP 108
50241: PPUSH
50242: LD_VAR 0 5
50246: PPUSH
50247: EMPTY
50248: PPUSH
50249: CALL_OW 1
50253: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
50254: LD_VAR 0 6
50258: PPUSH
50259: LD_INT 0
50261: PPUSH
50262: CALL_OW 109
// ComExitBuilding ( tmp ) ;
50266: LD_VAR 0 6
50270: PPUSH
50271: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
50275: LD_ADDR_EXP 107
50279: PUSH
50280: LD_EXP 107
50284: PPUSH
50285: LD_VAR 0 5
50289: PPUSH
50290: LD_EXP 107
50294: PUSH
50295: LD_VAR 0 5
50299: ARRAY
50300: PPUSH
50301: LD_INT 1
50303: PPUSH
50304: LD_VAR 0 6
50308: PPUSH
50309: CALL_OW 2
50313: PPUSH
50314: CALL_OW 1
50318: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
50319: LD_VAR 0 5
50323: PPUSH
50324: LD_INT 112
50326: PPUSH
50327: CALL 26785 0 2
// end ; end ; end ;
50331: GO 50154
50333: POP
50334: POP
// end ;
50335: LD_VAR 0 3
50339: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
50340: LD_INT 0
50342: PPUSH
50343: PPUSH
50344: PPUSH
50345: PPUSH
50346: PPUSH
50347: PPUSH
50348: PPUSH
50349: PPUSH
// if not mc_bases or not skirmish then
50350: LD_EXP 78
50354: NOT
50355: PUSH
50356: LD_EXP 76
50360: NOT
50361: OR
50362: IFFALSE 50366
// exit ;
50364: GO 51735
// for i = 1 to mc_bases do
50366: LD_ADDR_VAR 0 3
50370: PUSH
50371: DOUBLE
50372: LD_INT 1
50374: DEC
50375: ST_TO_ADDR
50376: LD_EXP 78
50380: PUSH
50381: FOR_TO
50382: IFFALSE 51733
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
50384: LD_VAR 0 1
50388: PUSH
50389: LD_EXP 78
50393: PUSH
50394: LD_VAR 0 3
50398: ARRAY
50399: IN
50400: PUSH
50401: LD_VAR 0 1
50405: PUSH
50406: LD_EXP 85
50410: PUSH
50411: LD_VAR 0 3
50415: ARRAY
50416: IN
50417: OR
50418: PUSH
50419: LD_VAR 0 1
50423: PUSH
50424: LD_EXP 100
50428: PUSH
50429: LD_VAR 0 3
50433: ARRAY
50434: IN
50435: OR
50436: PUSH
50437: LD_VAR 0 1
50441: PUSH
50442: LD_EXP 97
50446: PUSH
50447: LD_VAR 0 3
50451: ARRAY
50452: IN
50453: OR
50454: PUSH
50455: LD_VAR 0 1
50459: PUSH
50460: LD_EXP 107
50464: PUSH
50465: LD_VAR 0 3
50469: ARRAY
50470: IN
50471: OR
50472: PUSH
50473: LD_VAR 0 1
50477: PUSH
50478: LD_EXP 108
50482: PUSH
50483: LD_VAR 0 3
50487: ARRAY
50488: IN
50489: OR
50490: IFFALSE 51731
// begin if un in mc_ape [ i ] then
50492: LD_VAR 0 1
50496: PUSH
50497: LD_EXP 107
50501: PUSH
50502: LD_VAR 0 3
50506: ARRAY
50507: IN
50508: IFFALSE 50547
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
50510: LD_ADDR_EXP 107
50514: PUSH
50515: LD_EXP 107
50519: PPUSH
50520: LD_VAR 0 3
50524: PPUSH
50525: LD_EXP 107
50529: PUSH
50530: LD_VAR 0 3
50534: ARRAY
50535: PUSH
50536: LD_VAR 0 1
50540: DIFF
50541: PPUSH
50542: CALL_OW 1
50546: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50547: LD_VAR 0 1
50551: PUSH
50552: LD_EXP 108
50556: PUSH
50557: LD_VAR 0 3
50561: ARRAY
50562: IN
50563: IFFALSE 50587
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50565: LD_ADDR_EXP 108
50569: PUSH
50570: LD_EXP 108
50574: PPUSH
50575: LD_VAR 0 3
50579: PPUSH
50580: EMPTY
50581: PPUSH
50582: CALL_OW 1
50586: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50587: LD_VAR 0 1
50591: PPUSH
50592: CALL_OW 247
50596: PUSH
50597: LD_INT 2
50599: EQUAL
50600: PUSH
50601: LD_VAR 0 1
50605: PPUSH
50606: CALL_OW 110
50610: PUSH
50611: LD_INT 20
50613: EQUAL
50614: PUSH
50615: LD_VAR 0 1
50619: PUSH
50620: LD_EXP 100
50624: PUSH
50625: LD_VAR 0 3
50629: ARRAY
50630: IN
50631: OR
50632: PUSH
50633: LD_VAR 0 1
50637: PPUSH
50638: CALL_OW 264
50642: PUSH
50643: LD_INT 12
50645: PUSH
50646: LD_INT 51
50648: PUSH
50649: LD_INT 89
50651: PUSH
50652: LD_INT 32
50654: PUSH
50655: LD_INT 13
50657: PUSH
50658: LD_INT 52
50660: PUSH
50661: LD_INT 31
50663: PUSH
50664: EMPTY
50665: LIST
50666: LIST
50667: LIST
50668: LIST
50669: LIST
50670: LIST
50671: LIST
50672: IN
50673: OR
50674: AND
50675: IFFALSE 50983
// begin if un in mc_defender [ i ] then
50677: LD_VAR 0 1
50681: PUSH
50682: LD_EXP 100
50686: PUSH
50687: LD_VAR 0 3
50691: ARRAY
50692: IN
50693: IFFALSE 50732
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50695: LD_ADDR_EXP 100
50699: PUSH
50700: LD_EXP 100
50704: PPUSH
50705: LD_VAR 0 3
50709: PPUSH
50710: LD_EXP 100
50714: PUSH
50715: LD_VAR 0 3
50719: ARRAY
50720: PUSH
50721: LD_VAR 0 1
50725: DIFF
50726: PPUSH
50727: CALL_OW 1
50731: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
50732: LD_ADDR_VAR 0 8
50736: PUSH
50737: LD_VAR 0 3
50741: PPUSH
50742: LD_INT 3
50744: PPUSH
50745: CALL 47353 0 2
50749: ST_TO_ADDR
// if fac then
50750: LD_VAR 0 8
50754: IFFALSE 50983
// begin for j in fac do
50756: LD_ADDR_VAR 0 4
50760: PUSH
50761: LD_VAR 0 8
50765: PUSH
50766: FOR_IN
50767: IFFALSE 50981
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
50769: LD_ADDR_VAR 0 9
50773: PUSH
50774: LD_VAR 0 8
50778: PPUSH
50779: LD_VAR 0 1
50783: PPUSH
50784: CALL_OW 265
50788: PPUSH
50789: LD_VAR 0 1
50793: PPUSH
50794: CALL_OW 262
50798: PPUSH
50799: LD_VAR 0 1
50803: PPUSH
50804: CALL_OW 263
50808: PPUSH
50809: LD_VAR 0 1
50813: PPUSH
50814: CALL_OW 264
50818: PPUSH
50819: CALL 55784 0 5
50823: ST_TO_ADDR
// if components then
50824: LD_VAR 0 9
50828: IFFALSE 50979
// begin if GetWeapon ( un ) = ar_control_tower then
50830: LD_VAR 0 1
50834: PPUSH
50835: CALL_OW 264
50839: PUSH
50840: LD_INT 31
50842: EQUAL
50843: IFFALSE 50960
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
50845: LD_VAR 0 1
50849: PPUSH
50850: CALL_OW 311
50854: PPUSH
50855: LD_INT 0
50857: PPUSH
50858: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
50862: LD_ADDR_EXP 118
50866: PUSH
50867: LD_EXP 118
50871: PPUSH
50872: LD_VAR 0 3
50876: PPUSH
50877: LD_EXP 118
50881: PUSH
50882: LD_VAR 0 3
50886: ARRAY
50887: PUSH
50888: LD_VAR 0 1
50892: PPUSH
50893: CALL_OW 311
50897: DIFF
50898: PPUSH
50899: CALL_OW 1
50903: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
50904: LD_ADDR_VAR 0 7
50908: PUSH
50909: LD_EXP 99
50913: PUSH
50914: LD_VAR 0 3
50918: ARRAY
50919: PPUSH
50920: LD_INT 1
50922: PPUSH
50923: LD_VAR 0 9
50927: PPUSH
50928: CALL_OW 2
50932: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50933: LD_ADDR_EXP 99
50937: PUSH
50938: LD_EXP 99
50942: PPUSH
50943: LD_VAR 0 3
50947: PPUSH
50948: LD_VAR 0 7
50952: PPUSH
50953: CALL_OW 1
50957: ST_TO_ADDR
// end else
50958: GO 50977
// MC_InsertProduceList ( i , [ components ] ) ;
50960: LD_VAR 0 3
50964: PPUSH
50965: LD_VAR 0 9
50969: PUSH
50970: EMPTY
50971: LIST
50972: PPUSH
50973: CALL 46898 0 2
// break ;
50977: GO 50981
// end ; end ;
50979: GO 50766
50981: POP
50982: POP
// end ; end ; if GetType ( un ) = unit_building then
50983: LD_VAR 0 1
50987: PPUSH
50988: CALL_OW 247
50992: PUSH
50993: LD_INT 3
50995: EQUAL
50996: IFFALSE 51399
// begin btype := GetBType ( un ) ;
50998: LD_ADDR_VAR 0 5
51002: PUSH
51003: LD_VAR 0 1
51007: PPUSH
51008: CALL_OW 266
51012: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
51013: LD_VAR 0 5
51017: PUSH
51018: LD_INT 29
51020: PUSH
51021: LD_INT 30
51023: PUSH
51024: EMPTY
51025: LIST
51026: LIST
51027: IN
51028: IFFALSE 51101
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
51030: LD_VAR 0 1
51034: PPUSH
51035: CALL_OW 250
51039: PPUSH
51040: LD_VAR 0 1
51044: PPUSH
51045: CALL_OW 251
51049: PPUSH
51050: LD_VAR 0 1
51054: PPUSH
51055: CALL_OW 255
51059: PPUSH
51060: CALL_OW 440
51064: NOT
51065: IFFALSE 51101
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
51067: LD_VAR 0 1
51071: PPUSH
51072: CALL_OW 250
51076: PPUSH
51077: LD_VAR 0 1
51081: PPUSH
51082: CALL_OW 251
51086: PPUSH
51087: LD_VAR 0 1
51091: PPUSH
51092: CALL_OW 255
51096: PPUSH
51097: CALL_OW 441
// end ; if btype = b_warehouse then
51101: LD_VAR 0 5
51105: PUSH
51106: LD_INT 1
51108: EQUAL
51109: IFFALSE 51127
// begin btype := b_depot ;
51111: LD_ADDR_VAR 0 5
51115: PUSH
51116: LD_INT 0
51118: ST_TO_ADDR
// pos := 1 ;
51119: LD_ADDR_VAR 0 6
51123: PUSH
51124: LD_INT 1
51126: ST_TO_ADDR
// end ; if btype = b_factory then
51127: LD_VAR 0 5
51131: PUSH
51132: LD_INT 3
51134: EQUAL
51135: IFFALSE 51153
// begin btype := b_workshop ;
51137: LD_ADDR_VAR 0 5
51141: PUSH
51142: LD_INT 2
51144: ST_TO_ADDR
// pos := 1 ;
51145: LD_ADDR_VAR 0 6
51149: PUSH
51150: LD_INT 1
51152: ST_TO_ADDR
// end ; if btype = b_barracks then
51153: LD_VAR 0 5
51157: PUSH
51158: LD_INT 5
51160: EQUAL
51161: IFFALSE 51171
// btype := b_armoury ;
51163: LD_ADDR_VAR 0 5
51167: PUSH
51168: LD_INT 4
51170: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
51171: LD_VAR 0 5
51175: PUSH
51176: LD_INT 7
51178: PUSH
51179: LD_INT 8
51181: PUSH
51182: EMPTY
51183: LIST
51184: LIST
51185: IN
51186: IFFALSE 51196
// btype := b_lab ;
51188: LD_ADDR_VAR 0 5
51192: PUSH
51193: LD_INT 6
51195: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
51196: LD_ADDR_EXP 83
51200: PUSH
51201: LD_EXP 83
51205: PPUSH
51206: LD_VAR 0 3
51210: PUSH
51211: LD_EXP 83
51215: PUSH
51216: LD_VAR 0 3
51220: ARRAY
51221: PUSH
51222: LD_INT 1
51224: PLUS
51225: PUSH
51226: EMPTY
51227: LIST
51228: LIST
51229: PPUSH
51230: LD_VAR 0 5
51234: PUSH
51235: LD_VAR 0 1
51239: PPUSH
51240: CALL_OW 250
51244: PUSH
51245: LD_VAR 0 1
51249: PPUSH
51250: CALL_OW 251
51254: PUSH
51255: LD_VAR 0 1
51259: PPUSH
51260: CALL_OW 254
51264: PUSH
51265: EMPTY
51266: LIST
51267: LIST
51268: LIST
51269: LIST
51270: PPUSH
51271: CALL 58286 0 3
51275: ST_TO_ADDR
// if pos = 1 then
51276: LD_VAR 0 6
51280: PUSH
51281: LD_INT 1
51283: EQUAL
51284: IFFALSE 51399
// begin tmp := mc_build_list [ i ] ;
51286: LD_ADDR_VAR 0 7
51290: PUSH
51291: LD_EXP 83
51295: PUSH
51296: LD_VAR 0 3
51300: ARRAY
51301: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51302: LD_VAR 0 7
51306: PPUSH
51307: LD_INT 2
51309: PUSH
51310: LD_INT 30
51312: PUSH
51313: LD_INT 0
51315: PUSH
51316: EMPTY
51317: LIST
51318: LIST
51319: PUSH
51320: LD_INT 30
51322: PUSH
51323: LD_INT 1
51325: PUSH
51326: EMPTY
51327: LIST
51328: LIST
51329: PUSH
51330: EMPTY
51331: LIST
51332: LIST
51333: LIST
51334: PPUSH
51335: CALL_OW 72
51339: IFFALSE 51349
// pos := 2 ;
51341: LD_ADDR_VAR 0 6
51345: PUSH
51346: LD_INT 2
51348: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
51349: LD_ADDR_VAR 0 7
51353: PUSH
51354: LD_VAR 0 7
51358: PPUSH
51359: LD_VAR 0 6
51363: PPUSH
51364: LD_VAR 0 7
51368: PPUSH
51369: CALL 58612 0 3
51373: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
51374: LD_ADDR_EXP 83
51378: PUSH
51379: LD_EXP 83
51383: PPUSH
51384: LD_VAR 0 3
51388: PPUSH
51389: LD_VAR 0 7
51393: PPUSH
51394: CALL_OW 1
51398: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
51399: LD_VAR 0 1
51403: PUSH
51404: LD_EXP 78
51408: PUSH
51409: LD_VAR 0 3
51413: ARRAY
51414: IN
51415: IFFALSE 51454
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
51417: LD_ADDR_EXP 78
51421: PUSH
51422: LD_EXP 78
51426: PPUSH
51427: LD_VAR 0 3
51431: PPUSH
51432: LD_EXP 78
51436: PUSH
51437: LD_VAR 0 3
51441: ARRAY
51442: PUSH
51443: LD_VAR 0 1
51447: DIFF
51448: PPUSH
51449: CALL_OW 1
51453: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
51454: LD_VAR 0 1
51458: PUSH
51459: LD_EXP 85
51463: PUSH
51464: LD_VAR 0 3
51468: ARRAY
51469: IN
51470: IFFALSE 51509
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
51472: LD_ADDR_EXP 85
51476: PUSH
51477: LD_EXP 85
51481: PPUSH
51482: LD_VAR 0 3
51486: PPUSH
51487: LD_EXP 85
51491: PUSH
51492: LD_VAR 0 3
51496: ARRAY
51497: PUSH
51498: LD_VAR 0 1
51502: DIFF
51503: PPUSH
51504: CALL_OW 1
51508: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
51509: LD_VAR 0 1
51513: PUSH
51514: LD_EXP 97
51518: PUSH
51519: LD_VAR 0 3
51523: ARRAY
51524: IN
51525: IFFALSE 51564
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51527: LD_ADDR_EXP 97
51531: PUSH
51532: LD_EXP 97
51536: PPUSH
51537: LD_VAR 0 3
51541: PPUSH
51542: LD_EXP 97
51546: PUSH
51547: LD_VAR 0 3
51551: ARRAY
51552: PUSH
51553: LD_VAR 0 1
51557: DIFF
51558: PPUSH
51559: CALL_OW 1
51563: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51564: LD_VAR 0 1
51568: PUSH
51569: LD_EXP 100
51573: PUSH
51574: LD_VAR 0 3
51578: ARRAY
51579: IN
51580: IFFALSE 51619
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51582: LD_ADDR_EXP 100
51586: PUSH
51587: LD_EXP 100
51591: PPUSH
51592: LD_VAR 0 3
51596: PPUSH
51597: LD_EXP 100
51601: PUSH
51602: LD_VAR 0 3
51606: ARRAY
51607: PUSH
51608: LD_VAR 0 1
51612: DIFF
51613: PPUSH
51614: CALL_OW 1
51618: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
51619: LD_VAR 0 1
51623: PUSH
51624: LD_EXP 87
51628: PUSH
51629: LD_VAR 0 3
51633: ARRAY
51634: IN
51635: IFFALSE 51674
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
51637: LD_ADDR_EXP 87
51641: PUSH
51642: LD_EXP 87
51646: PPUSH
51647: LD_VAR 0 3
51651: PPUSH
51652: LD_EXP 87
51656: PUSH
51657: LD_VAR 0 3
51661: ARRAY
51662: PUSH
51663: LD_VAR 0 1
51667: DIFF
51668: PPUSH
51669: CALL_OW 1
51673: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
51674: LD_VAR 0 1
51678: PUSH
51679: LD_EXP 86
51683: PUSH
51684: LD_VAR 0 3
51688: ARRAY
51689: IN
51690: IFFALSE 51729
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
51692: LD_ADDR_EXP 86
51696: PUSH
51697: LD_EXP 86
51701: PPUSH
51702: LD_VAR 0 3
51706: PPUSH
51707: LD_EXP 86
51711: PUSH
51712: LD_VAR 0 3
51716: ARRAY
51717: PUSH
51718: LD_VAR 0 1
51722: DIFF
51723: PPUSH
51724: CALL_OW 1
51728: ST_TO_ADDR
// end ; break ;
51729: GO 51733
// end ;
51731: GO 50381
51733: POP
51734: POP
// end ;
51735: LD_VAR 0 2
51739: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
51740: LD_INT 0
51742: PPUSH
51743: PPUSH
51744: PPUSH
// if not mc_bases or not skirmish then
51745: LD_EXP 78
51749: NOT
51750: PUSH
51751: LD_EXP 76
51755: NOT
51756: OR
51757: IFFALSE 51761
// exit ;
51759: GO 51976
// for i = 1 to mc_bases do
51761: LD_ADDR_VAR 0 3
51765: PUSH
51766: DOUBLE
51767: LD_INT 1
51769: DEC
51770: ST_TO_ADDR
51771: LD_EXP 78
51775: PUSH
51776: FOR_TO
51777: IFFALSE 51974
// begin if building in mc_construct_list [ i ] then
51779: LD_VAR 0 1
51783: PUSH
51784: LD_EXP 85
51788: PUSH
51789: LD_VAR 0 3
51793: ARRAY
51794: IN
51795: IFFALSE 51972
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51797: LD_ADDR_EXP 85
51801: PUSH
51802: LD_EXP 85
51806: PPUSH
51807: LD_VAR 0 3
51811: PPUSH
51812: LD_EXP 85
51816: PUSH
51817: LD_VAR 0 3
51821: ARRAY
51822: PUSH
51823: LD_VAR 0 1
51827: DIFF
51828: PPUSH
51829: CALL_OW 1
51833: ST_TO_ADDR
// if building in mc_lab [ i ] then
51834: LD_VAR 0 1
51838: PUSH
51839: LD_EXP 111
51843: PUSH
51844: LD_VAR 0 3
51848: ARRAY
51849: IN
51850: IFFALSE 51905
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
51852: LD_ADDR_EXP 112
51856: PUSH
51857: LD_EXP 112
51861: PPUSH
51862: LD_VAR 0 3
51866: PPUSH
51867: LD_EXP 112
51871: PUSH
51872: LD_VAR 0 3
51876: ARRAY
51877: PPUSH
51878: LD_INT 1
51880: PPUSH
51881: LD_EXP 112
51885: PUSH
51886: LD_VAR 0 3
51890: ARRAY
51891: PPUSH
51892: LD_INT 0
51894: PPUSH
51895: CALL 57704 0 4
51899: PPUSH
51900: CALL_OW 1
51904: ST_TO_ADDR
// if not building in mc_bases [ i ] then
51905: LD_VAR 0 1
51909: PUSH
51910: LD_EXP 78
51914: PUSH
51915: LD_VAR 0 3
51919: ARRAY
51920: IN
51921: NOT
51922: IFFALSE 51968
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51924: LD_ADDR_EXP 78
51928: PUSH
51929: LD_EXP 78
51933: PPUSH
51934: LD_VAR 0 3
51938: PUSH
51939: LD_EXP 78
51943: PUSH
51944: LD_VAR 0 3
51948: ARRAY
51949: PUSH
51950: LD_INT 1
51952: PLUS
51953: PUSH
51954: EMPTY
51955: LIST
51956: LIST
51957: PPUSH
51958: LD_VAR 0 1
51962: PPUSH
51963: CALL 58286 0 3
51967: ST_TO_ADDR
// exit ;
51968: POP
51969: POP
51970: GO 51976
// end ; end ;
51972: GO 51776
51974: POP
51975: POP
// end ;
51976: LD_VAR 0 2
51980: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
51981: LD_INT 0
51983: PPUSH
51984: PPUSH
51985: PPUSH
51986: PPUSH
51987: PPUSH
51988: PPUSH
51989: PPUSH
// if not mc_bases or not skirmish then
51990: LD_EXP 78
51994: NOT
51995: PUSH
51996: LD_EXP 76
52000: NOT
52001: OR
52002: IFFALSE 52006
// exit ;
52004: GO 52667
// for i = 1 to mc_bases do
52006: LD_ADDR_VAR 0 3
52010: PUSH
52011: DOUBLE
52012: LD_INT 1
52014: DEC
52015: ST_TO_ADDR
52016: LD_EXP 78
52020: PUSH
52021: FOR_TO
52022: IFFALSE 52665
// begin if building in mc_construct_list [ i ] then
52024: LD_VAR 0 1
52028: PUSH
52029: LD_EXP 85
52033: PUSH
52034: LD_VAR 0 3
52038: ARRAY
52039: IN
52040: IFFALSE 52663
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52042: LD_ADDR_EXP 85
52046: PUSH
52047: LD_EXP 85
52051: PPUSH
52052: LD_VAR 0 3
52056: PPUSH
52057: LD_EXP 85
52061: PUSH
52062: LD_VAR 0 3
52066: ARRAY
52067: PUSH
52068: LD_VAR 0 1
52072: DIFF
52073: PPUSH
52074: CALL_OW 1
52078: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52079: LD_ADDR_EXP 78
52083: PUSH
52084: LD_EXP 78
52088: PPUSH
52089: LD_VAR 0 3
52093: PUSH
52094: LD_EXP 78
52098: PUSH
52099: LD_VAR 0 3
52103: ARRAY
52104: PUSH
52105: LD_INT 1
52107: PLUS
52108: PUSH
52109: EMPTY
52110: LIST
52111: LIST
52112: PPUSH
52113: LD_VAR 0 1
52117: PPUSH
52118: CALL 58286 0 3
52122: ST_TO_ADDR
// btype := GetBType ( building ) ;
52123: LD_ADDR_VAR 0 5
52127: PUSH
52128: LD_VAR 0 1
52132: PPUSH
52133: CALL_OW 266
52137: ST_TO_ADDR
// side := GetSide ( building ) ;
52138: LD_ADDR_VAR 0 8
52142: PUSH
52143: LD_VAR 0 1
52147: PPUSH
52148: CALL_OW 255
52152: ST_TO_ADDR
// if btype = b_lab then
52153: LD_VAR 0 5
52157: PUSH
52158: LD_INT 6
52160: EQUAL
52161: IFFALSE 52211
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
52163: LD_ADDR_EXP 111
52167: PUSH
52168: LD_EXP 111
52172: PPUSH
52173: LD_VAR 0 3
52177: PUSH
52178: LD_EXP 111
52182: PUSH
52183: LD_VAR 0 3
52187: ARRAY
52188: PUSH
52189: LD_INT 1
52191: PLUS
52192: PUSH
52193: EMPTY
52194: LIST
52195: LIST
52196: PPUSH
52197: LD_VAR 0 1
52201: PPUSH
52202: CALL 58286 0 3
52206: ST_TO_ADDR
// exit ;
52207: POP
52208: POP
52209: GO 52667
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
52211: LD_VAR 0 5
52215: PUSH
52216: LD_INT 0
52218: PUSH
52219: LD_INT 2
52221: PUSH
52222: LD_INT 4
52224: PUSH
52225: EMPTY
52226: LIST
52227: LIST
52228: LIST
52229: IN
52230: IFFALSE 52354
// begin if btype = b_armoury then
52232: LD_VAR 0 5
52236: PUSH
52237: LD_INT 4
52239: EQUAL
52240: IFFALSE 52250
// btype := b_barracks ;
52242: LD_ADDR_VAR 0 5
52246: PUSH
52247: LD_INT 5
52249: ST_TO_ADDR
// if btype = b_depot then
52250: LD_VAR 0 5
52254: PUSH
52255: LD_INT 0
52257: EQUAL
52258: IFFALSE 52268
// btype := b_warehouse ;
52260: LD_ADDR_VAR 0 5
52264: PUSH
52265: LD_INT 1
52267: ST_TO_ADDR
// if btype = b_workshop then
52268: LD_VAR 0 5
52272: PUSH
52273: LD_INT 2
52275: EQUAL
52276: IFFALSE 52286
// btype := b_factory ;
52278: LD_ADDR_VAR 0 5
52282: PUSH
52283: LD_INT 3
52285: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
52286: LD_VAR 0 5
52290: PPUSH
52291: LD_VAR 0 8
52295: PPUSH
52296: CALL_OW 323
52300: PUSH
52301: LD_INT 1
52303: EQUAL
52304: IFFALSE 52350
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
52306: LD_ADDR_EXP 110
52310: PUSH
52311: LD_EXP 110
52315: PPUSH
52316: LD_VAR 0 3
52320: PUSH
52321: LD_EXP 110
52325: PUSH
52326: LD_VAR 0 3
52330: ARRAY
52331: PUSH
52332: LD_INT 1
52334: PLUS
52335: PUSH
52336: EMPTY
52337: LIST
52338: LIST
52339: PPUSH
52340: LD_VAR 0 1
52344: PPUSH
52345: CALL 58286 0 3
52349: ST_TO_ADDR
// exit ;
52350: POP
52351: POP
52352: GO 52667
// end ; if btype in [ b_bunker , b_turret ] then
52354: LD_VAR 0 5
52358: PUSH
52359: LD_INT 32
52361: PUSH
52362: LD_INT 33
52364: PUSH
52365: EMPTY
52366: LIST
52367: LIST
52368: IN
52369: IFFALSE 52659
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
52371: LD_ADDR_EXP 86
52375: PUSH
52376: LD_EXP 86
52380: PPUSH
52381: LD_VAR 0 3
52385: PUSH
52386: LD_EXP 86
52390: PUSH
52391: LD_VAR 0 3
52395: ARRAY
52396: PUSH
52397: LD_INT 1
52399: PLUS
52400: PUSH
52401: EMPTY
52402: LIST
52403: LIST
52404: PPUSH
52405: LD_VAR 0 1
52409: PPUSH
52410: CALL 58286 0 3
52414: ST_TO_ADDR
// if btype = b_bunker then
52415: LD_VAR 0 5
52419: PUSH
52420: LD_INT 32
52422: EQUAL
52423: IFFALSE 52659
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52425: LD_ADDR_EXP 87
52429: PUSH
52430: LD_EXP 87
52434: PPUSH
52435: LD_VAR 0 3
52439: PUSH
52440: LD_EXP 87
52444: PUSH
52445: LD_VAR 0 3
52449: ARRAY
52450: PUSH
52451: LD_INT 1
52453: PLUS
52454: PUSH
52455: EMPTY
52456: LIST
52457: LIST
52458: PPUSH
52459: LD_VAR 0 1
52463: PPUSH
52464: CALL 58286 0 3
52468: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
52469: LD_ADDR_VAR 0 6
52473: PUSH
52474: LD_EXP 78
52478: PUSH
52479: LD_VAR 0 3
52483: ARRAY
52484: PPUSH
52485: LD_INT 25
52487: PUSH
52488: LD_INT 1
52490: PUSH
52491: EMPTY
52492: LIST
52493: LIST
52494: PUSH
52495: LD_INT 3
52497: PUSH
52498: LD_INT 54
52500: PUSH
52501: EMPTY
52502: LIST
52503: PUSH
52504: EMPTY
52505: LIST
52506: LIST
52507: PUSH
52508: EMPTY
52509: LIST
52510: LIST
52511: PPUSH
52512: CALL_OW 72
52516: ST_TO_ADDR
// if tmp then
52517: LD_VAR 0 6
52521: IFFALSE 52527
// exit ;
52523: POP
52524: POP
52525: GO 52667
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52527: LD_ADDR_VAR 0 6
52531: PUSH
52532: LD_EXP 78
52536: PUSH
52537: LD_VAR 0 3
52541: ARRAY
52542: PPUSH
52543: LD_INT 2
52545: PUSH
52546: LD_INT 30
52548: PUSH
52549: LD_INT 4
52551: PUSH
52552: EMPTY
52553: LIST
52554: LIST
52555: PUSH
52556: LD_INT 30
52558: PUSH
52559: LD_INT 5
52561: PUSH
52562: EMPTY
52563: LIST
52564: LIST
52565: PUSH
52566: EMPTY
52567: LIST
52568: LIST
52569: LIST
52570: PPUSH
52571: CALL_OW 72
52575: ST_TO_ADDR
// if not tmp then
52576: LD_VAR 0 6
52580: NOT
52581: IFFALSE 52587
// exit ;
52583: POP
52584: POP
52585: GO 52667
// for j in tmp do
52587: LD_ADDR_VAR 0 4
52591: PUSH
52592: LD_VAR 0 6
52596: PUSH
52597: FOR_IN
52598: IFFALSE 52657
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
52600: LD_ADDR_VAR 0 7
52604: PUSH
52605: LD_VAR 0 4
52609: PPUSH
52610: CALL_OW 313
52614: PPUSH
52615: LD_INT 25
52617: PUSH
52618: LD_INT 1
52620: PUSH
52621: EMPTY
52622: LIST
52623: LIST
52624: PPUSH
52625: CALL_OW 72
52629: ST_TO_ADDR
// if units then
52630: LD_VAR 0 7
52634: IFFALSE 52655
// begin ComExitBuilding ( units [ 1 ] ) ;
52636: LD_VAR 0 7
52640: PUSH
52641: LD_INT 1
52643: ARRAY
52644: PPUSH
52645: CALL_OW 122
// exit ;
52649: POP
52650: POP
52651: POP
52652: POP
52653: GO 52667
// end ; end ;
52655: GO 52597
52657: POP
52658: POP
// end ; end ; exit ;
52659: POP
52660: POP
52661: GO 52667
// end ; end ;
52663: GO 52021
52665: POP
52666: POP
// end ;
52667: LD_VAR 0 2
52671: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
52672: LD_INT 0
52674: PPUSH
52675: PPUSH
52676: PPUSH
52677: PPUSH
52678: PPUSH
52679: PPUSH
52680: PPUSH
// if not mc_bases or not skirmish then
52681: LD_EXP 78
52685: NOT
52686: PUSH
52687: LD_EXP 76
52691: NOT
52692: OR
52693: IFFALSE 52697
// exit ;
52695: GO 52962
// btype := GetBType ( building ) ;
52697: LD_ADDR_VAR 0 6
52701: PUSH
52702: LD_VAR 0 1
52706: PPUSH
52707: CALL_OW 266
52711: ST_TO_ADDR
// x := GetX ( building ) ;
52712: LD_ADDR_VAR 0 7
52716: PUSH
52717: LD_VAR 0 1
52721: PPUSH
52722: CALL_OW 250
52726: ST_TO_ADDR
// y := GetY ( building ) ;
52727: LD_ADDR_VAR 0 8
52731: PUSH
52732: LD_VAR 0 1
52736: PPUSH
52737: CALL_OW 251
52741: ST_TO_ADDR
// d := GetDir ( building ) ;
52742: LD_ADDR_VAR 0 9
52746: PUSH
52747: LD_VAR 0 1
52751: PPUSH
52752: CALL_OW 254
52756: ST_TO_ADDR
// for i = 1 to mc_bases do
52757: LD_ADDR_VAR 0 4
52761: PUSH
52762: DOUBLE
52763: LD_INT 1
52765: DEC
52766: ST_TO_ADDR
52767: LD_EXP 78
52771: PUSH
52772: FOR_TO
52773: IFFALSE 52960
// begin if not mc_build_list [ i ] then
52775: LD_EXP 83
52779: PUSH
52780: LD_VAR 0 4
52784: ARRAY
52785: NOT
52786: IFFALSE 52790
// continue ;
52788: GO 52772
// for j := 1 to mc_build_list [ i ] do
52790: LD_ADDR_VAR 0 5
52794: PUSH
52795: DOUBLE
52796: LD_INT 1
52798: DEC
52799: ST_TO_ADDR
52800: LD_EXP 83
52804: PUSH
52805: LD_VAR 0 4
52809: ARRAY
52810: PUSH
52811: FOR_TO
52812: IFFALSE 52956
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
52814: LD_VAR 0 6
52818: PUSH
52819: LD_VAR 0 7
52823: PUSH
52824: LD_VAR 0 8
52828: PUSH
52829: LD_VAR 0 9
52833: PUSH
52834: EMPTY
52835: LIST
52836: LIST
52837: LIST
52838: LIST
52839: PPUSH
52840: LD_EXP 83
52844: PUSH
52845: LD_VAR 0 4
52849: ARRAY
52850: PUSH
52851: LD_VAR 0 5
52855: ARRAY
52856: PPUSH
52857: CALL 64843 0 2
52861: IFFALSE 52954
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
52863: LD_ADDR_EXP 83
52867: PUSH
52868: LD_EXP 83
52872: PPUSH
52873: LD_VAR 0 4
52877: PPUSH
52878: LD_EXP 83
52882: PUSH
52883: LD_VAR 0 4
52887: ARRAY
52888: PPUSH
52889: LD_VAR 0 5
52893: PPUSH
52894: CALL_OW 3
52898: PPUSH
52899: CALL_OW 1
52903: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
52904: LD_ADDR_EXP 85
52908: PUSH
52909: LD_EXP 85
52913: PPUSH
52914: LD_VAR 0 4
52918: PUSH
52919: LD_EXP 85
52923: PUSH
52924: LD_VAR 0 4
52928: ARRAY
52929: PUSH
52930: LD_INT 1
52932: PLUS
52933: PUSH
52934: EMPTY
52935: LIST
52936: LIST
52937: PPUSH
52938: LD_VAR 0 1
52942: PPUSH
52943: CALL 58286 0 3
52947: ST_TO_ADDR
// exit ;
52948: POP
52949: POP
52950: POP
52951: POP
52952: GO 52962
// end ;
52954: GO 52811
52956: POP
52957: POP
// end ;
52958: GO 52772
52960: POP
52961: POP
// end ;
52962: LD_VAR 0 3
52966: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
52967: LD_INT 0
52969: PPUSH
52970: PPUSH
52971: PPUSH
// if not mc_bases or not skirmish then
52972: LD_EXP 78
52976: NOT
52977: PUSH
52978: LD_EXP 76
52982: NOT
52983: OR
52984: IFFALSE 52988
// exit ;
52986: GO 53178
// for i = 1 to mc_bases do
52988: LD_ADDR_VAR 0 4
52992: PUSH
52993: DOUBLE
52994: LD_INT 1
52996: DEC
52997: ST_TO_ADDR
52998: LD_EXP 78
53002: PUSH
53003: FOR_TO
53004: IFFALSE 53091
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
53006: LD_VAR 0 1
53010: PUSH
53011: LD_EXP 86
53015: PUSH
53016: LD_VAR 0 4
53020: ARRAY
53021: IN
53022: PUSH
53023: LD_VAR 0 1
53027: PUSH
53028: LD_EXP 87
53032: PUSH
53033: LD_VAR 0 4
53037: ARRAY
53038: IN
53039: NOT
53040: AND
53041: IFFALSE 53089
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
53043: LD_ADDR_EXP 87
53047: PUSH
53048: LD_EXP 87
53052: PPUSH
53053: LD_VAR 0 4
53057: PUSH
53058: LD_EXP 87
53062: PUSH
53063: LD_VAR 0 4
53067: ARRAY
53068: PUSH
53069: LD_INT 1
53071: PLUS
53072: PUSH
53073: EMPTY
53074: LIST
53075: LIST
53076: PPUSH
53077: LD_VAR 0 1
53081: PPUSH
53082: CALL 58286 0 3
53086: ST_TO_ADDR
// break ;
53087: GO 53091
// end ; end ;
53089: GO 53003
53091: POP
53092: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
53093: LD_VAR 0 1
53097: PPUSH
53098: CALL_OW 257
53102: PUSH
53103: LD_EXP 104
53107: IN
53108: PUSH
53109: LD_VAR 0 1
53113: PPUSH
53114: CALL_OW 266
53118: PUSH
53119: LD_INT 5
53121: EQUAL
53122: AND
53123: PUSH
53124: LD_VAR 0 2
53128: PPUSH
53129: CALL_OW 110
53133: PUSH
53134: LD_INT 18
53136: NONEQUAL
53137: AND
53138: IFFALSE 53178
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
53140: LD_VAR 0 2
53144: PPUSH
53145: CALL_OW 257
53149: PUSH
53150: LD_INT 5
53152: PUSH
53153: LD_INT 8
53155: PUSH
53156: LD_INT 9
53158: PUSH
53159: EMPTY
53160: LIST
53161: LIST
53162: LIST
53163: IN
53164: IFFALSE 53178
// SetClass ( unit , 1 ) ;
53166: LD_VAR 0 2
53170: PPUSH
53171: LD_INT 1
53173: PPUSH
53174: CALL_OW 336
// end ;
53178: LD_VAR 0 3
53182: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
53183: LD_INT 0
53185: PPUSH
53186: PPUSH
// if not mc_bases or not skirmish then
53187: LD_EXP 78
53191: NOT
53192: PUSH
53193: LD_EXP 76
53197: NOT
53198: OR
53199: IFFALSE 53203
// exit ;
53201: GO 53319
// if GetLives ( abandoned_vehicle ) > 250 then
53203: LD_VAR 0 2
53207: PPUSH
53208: CALL_OW 256
53212: PUSH
53213: LD_INT 250
53215: GREATER
53216: IFFALSE 53220
// exit ;
53218: GO 53319
// for i = 1 to mc_bases do
53220: LD_ADDR_VAR 0 6
53224: PUSH
53225: DOUBLE
53226: LD_INT 1
53228: DEC
53229: ST_TO_ADDR
53230: LD_EXP 78
53234: PUSH
53235: FOR_TO
53236: IFFALSE 53317
// begin if driver in mc_bases [ i ] then
53238: LD_VAR 0 1
53242: PUSH
53243: LD_EXP 78
53247: PUSH
53248: LD_VAR 0 6
53252: ARRAY
53253: IN
53254: IFFALSE 53315
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
53256: LD_VAR 0 1
53260: PPUSH
53261: LD_EXP 78
53265: PUSH
53266: LD_VAR 0 6
53270: ARRAY
53271: PPUSH
53272: LD_INT 2
53274: PUSH
53275: LD_INT 30
53277: PUSH
53278: LD_INT 0
53280: PUSH
53281: EMPTY
53282: LIST
53283: LIST
53284: PUSH
53285: LD_INT 30
53287: PUSH
53288: LD_INT 1
53290: PUSH
53291: EMPTY
53292: LIST
53293: LIST
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: LIST
53299: PPUSH
53300: CALL_OW 72
53304: PUSH
53305: LD_INT 1
53307: ARRAY
53308: PPUSH
53309: CALL 91892 0 2
// break ;
53313: GO 53317
// end ; end ;
53315: GO 53235
53317: POP
53318: POP
// end ; end_of_file
53319: LD_VAR 0 5
53323: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
53324: LD_INT 0
53326: PPUSH
53327: PPUSH
// if exist_mode then
53328: LD_VAR 0 2
53332: IFFALSE 53357
// unit := CreateCharacter ( prefix & ident ) else
53334: LD_ADDR_VAR 0 5
53338: PUSH
53339: LD_VAR 0 3
53343: PUSH
53344: LD_VAR 0 1
53348: STR
53349: PPUSH
53350: CALL_OW 34
53354: ST_TO_ADDR
53355: GO 53372
// unit := NewCharacter ( ident ) ;
53357: LD_ADDR_VAR 0 5
53361: PUSH
53362: LD_VAR 0 1
53366: PPUSH
53367: CALL_OW 25
53371: ST_TO_ADDR
// result := unit ;
53372: LD_ADDR_VAR 0 4
53376: PUSH
53377: LD_VAR 0 5
53381: ST_TO_ADDR
// end ;
53382: LD_VAR 0 4
53386: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
53387: LD_INT 0
53389: PPUSH
53390: PPUSH
// if not side or not nation then
53391: LD_VAR 0 1
53395: NOT
53396: PUSH
53397: LD_VAR 0 2
53401: NOT
53402: OR
53403: IFFALSE 53407
// exit ;
53405: GO 54175
// case nation of nation_american :
53407: LD_VAR 0 2
53411: PUSH
53412: LD_INT 1
53414: DOUBLE
53415: EQUAL
53416: IFTRUE 53420
53418: GO 53634
53420: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
53421: LD_ADDR_VAR 0 4
53425: PUSH
53426: LD_INT 35
53428: PUSH
53429: LD_INT 45
53431: PUSH
53432: LD_INT 46
53434: PUSH
53435: LD_INT 47
53437: PUSH
53438: LD_INT 82
53440: PUSH
53441: LD_INT 83
53443: PUSH
53444: LD_INT 84
53446: PUSH
53447: LD_INT 85
53449: PUSH
53450: LD_INT 86
53452: PUSH
53453: LD_INT 1
53455: PUSH
53456: LD_INT 2
53458: PUSH
53459: LD_INT 6
53461: PUSH
53462: LD_INT 15
53464: PUSH
53465: LD_INT 16
53467: PUSH
53468: LD_INT 7
53470: PUSH
53471: LD_INT 12
53473: PUSH
53474: LD_INT 13
53476: PUSH
53477: LD_INT 10
53479: PUSH
53480: LD_INT 14
53482: PUSH
53483: LD_INT 20
53485: PUSH
53486: LD_INT 21
53488: PUSH
53489: LD_INT 22
53491: PUSH
53492: LD_INT 25
53494: PUSH
53495: LD_INT 32
53497: PUSH
53498: LD_INT 27
53500: PUSH
53501: LD_INT 36
53503: PUSH
53504: LD_INT 69
53506: PUSH
53507: LD_INT 39
53509: PUSH
53510: LD_INT 34
53512: PUSH
53513: LD_INT 40
53515: PUSH
53516: LD_INT 48
53518: PUSH
53519: LD_INT 49
53521: PUSH
53522: LD_INT 50
53524: PUSH
53525: LD_INT 51
53527: PUSH
53528: LD_INT 52
53530: PUSH
53531: LD_INT 53
53533: PUSH
53534: LD_INT 54
53536: PUSH
53537: LD_INT 55
53539: PUSH
53540: LD_INT 56
53542: PUSH
53543: LD_INT 57
53545: PUSH
53546: LD_INT 58
53548: PUSH
53549: LD_INT 59
53551: PUSH
53552: LD_INT 60
53554: PUSH
53555: LD_INT 61
53557: PUSH
53558: LD_INT 62
53560: PUSH
53561: LD_INT 80
53563: PUSH
53564: LD_INT 82
53566: PUSH
53567: LD_INT 83
53569: PUSH
53570: LD_INT 84
53572: PUSH
53573: LD_INT 85
53575: PUSH
53576: LD_INT 86
53578: PUSH
53579: EMPTY
53580: LIST
53581: LIST
53582: LIST
53583: LIST
53584: LIST
53585: LIST
53586: LIST
53587: LIST
53588: LIST
53589: LIST
53590: LIST
53591: LIST
53592: LIST
53593: LIST
53594: LIST
53595: LIST
53596: LIST
53597: LIST
53598: LIST
53599: LIST
53600: LIST
53601: LIST
53602: LIST
53603: LIST
53604: LIST
53605: LIST
53606: LIST
53607: LIST
53608: LIST
53609: LIST
53610: LIST
53611: LIST
53612: LIST
53613: LIST
53614: LIST
53615: LIST
53616: LIST
53617: LIST
53618: LIST
53619: LIST
53620: LIST
53621: LIST
53622: LIST
53623: LIST
53624: LIST
53625: LIST
53626: LIST
53627: LIST
53628: LIST
53629: LIST
53630: LIST
53631: ST_TO_ADDR
53632: GO 54099
53634: LD_INT 2
53636: DOUBLE
53637: EQUAL
53638: IFTRUE 53642
53640: GO 53868
53642: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
53643: LD_ADDR_VAR 0 4
53647: PUSH
53648: LD_INT 35
53650: PUSH
53651: LD_INT 45
53653: PUSH
53654: LD_INT 46
53656: PUSH
53657: LD_INT 47
53659: PUSH
53660: LD_INT 82
53662: PUSH
53663: LD_INT 83
53665: PUSH
53666: LD_INT 84
53668: PUSH
53669: LD_INT 85
53671: PUSH
53672: LD_INT 87
53674: PUSH
53675: LD_INT 70
53677: PUSH
53678: LD_INT 1
53680: PUSH
53681: LD_INT 11
53683: PUSH
53684: LD_INT 3
53686: PUSH
53687: LD_INT 4
53689: PUSH
53690: LD_INT 5
53692: PUSH
53693: LD_INT 6
53695: PUSH
53696: LD_INT 15
53698: PUSH
53699: LD_INT 18
53701: PUSH
53702: LD_INT 7
53704: PUSH
53705: LD_INT 17
53707: PUSH
53708: LD_INT 8
53710: PUSH
53711: LD_INT 20
53713: PUSH
53714: LD_INT 21
53716: PUSH
53717: LD_INT 22
53719: PUSH
53720: LD_INT 72
53722: PUSH
53723: LD_INT 26
53725: PUSH
53726: LD_INT 69
53728: PUSH
53729: LD_INT 39
53731: PUSH
53732: LD_INT 40
53734: PUSH
53735: LD_INT 41
53737: PUSH
53738: LD_INT 42
53740: PUSH
53741: LD_INT 43
53743: PUSH
53744: LD_INT 48
53746: PUSH
53747: LD_INT 49
53749: PUSH
53750: LD_INT 50
53752: PUSH
53753: LD_INT 51
53755: PUSH
53756: LD_INT 52
53758: PUSH
53759: LD_INT 53
53761: PUSH
53762: LD_INT 54
53764: PUSH
53765: LD_INT 55
53767: PUSH
53768: LD_INT 56
53770: PUSH
53771: LD_INT 60
53773: PUSH
53774: LD_INT 61
53776: PUSH
53777: LD_INT 62
53779: PUSH
53780: LD_INT 66
53782: PUSH
53783: LD_INT 67
53785: PUSH
53786: LD_INT 68
53788: PUSH
53789: LD_INT 81
53791: PUSH
53792: LD_INT 82
53794: PUSH
53795: LD_INT 83
53797: PUSH
53798: LD_INT 84
53800: PUSH
53801: LD_INT 85
53803: PUSH
53804: LD_INT 87
53806: PUSH
53807: LD_INT 88
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: LIST
53814: LIST
53815: LIST
53816: LIST
53817: LIST
53818: LIST
53819: LIST
53820: LIST
53821: LIST
53822: LIST
53823: LIST
53824: LIST
53825: LIST
53826: LIST
53827: LIST
53828: LIST
53829: LIST
53830: LIST
53831: LIST
53832: LIST
53833: LIST
53834: LIST
53835: LIST
53836: LIST
53837: LIST
53838: LIST
53839: LIST
53840: LIST
53841: LIST
53842: LIST
53843: LIST
53844: LIST
53845: LIST
53846: LIST
53847: LIST
53848: LIST
53849: LIST
53850: LIST
53851: LIST
53852: LIST
53853: LIST
53854: LIST
53855: LIST
53856: LIST
53857: LIST
53858: LIST
53859: LIST
53860: LIST
53861: LIST
53862: LIST
53863: LIST
53864: LIST
53865: ST_TO_ADDR
53866: GO 54099
53868: LD_INT 3
53870: DOUBLE
53871: EQUAL
53872: IFTRUE 53876
53874: GO 54098
53876: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
53877: LD_ADDR_VAR 0 4
53881: PUSH
53882: LD_INT 46
53884: PUSH
53885: LD_INT 47
53887: PUSH
53888: LD_INT 1
53890: PUSH
53891: LD_INT 2
53893: PUSH
53894: LD_INT 82
53896: PUSH
53897: LD_INT 83
53899: PUSH
53900: LD_INT 84
53902: PUSH
53903: LD_INT 85
53905: PUSH
53906: LD_INT 86
53908: PUSH
53909: LD_INT 11
53911: PUSH
53912: LD_INT 9
53914: PUSH
53915: LD_INT 20
53917: PUSH
53918: LD_INT 19
53920: PUSH
53921: LD_INT 21
53923: PUSH
53924: LD_INT 24
53926: PUSH
53927: LD_INT 22
53929: PUSH
53930: LD_INT 25
53932: PUSH
53933: LD_INT 28
53935: PUSH
53936: LD_INT 29
53938: PUSH
53939: LD_INT 30
53941: PUSH
53942: LD_INT 31
53944: PUSH
53945: LD_INT 37
53947: PUSH
53948: LD_INT 38
53950: PUSH
53951: LD_INT 32
53953: PUSH
53954: LD_INT 27
53956: PUSH
53957: LD_INT 33
53959: PUSH
53960: LD_INT 69
53962: PUSH
53963: LD_INT 39
53965: PUSH
53966: LD_INT 34
53968: PUSH
53969: LD_INT 40
53971: PUSH
53972: LD_INT 71
53974: PUSH
53975: LD_INT 23
53977: PUSH
53978: LD_INT 44
53980: PUSH
53981: LD_INT 48
53983: PUSH
53984: LD_INT 49
53986: PUSH
53987: LD_INT 50
53989: PUSH
53990: LD_INT 51
53992: PUSH
53993: LD_INT 52
53995: PUSH
53996: LD_INT 53
53998: PUSH
53999: LD_INT 54
54001: PUSH
54002: LD_INT 55
54004: PUSH
54005: LD_INT 56
54007: PUSH
54008: LD_INT 57
54010: PUSH
54011: LD_INT 58
54013: PUSH
54014: LD_INT 59
54016: PUSH
54017: LD_INT 63
54019: PUSH
54020: LD_INT 64
54022: PUSH
54023: LD_INT 65
54025: PUSH
54026: LD_INT 82
54028: PUSH
54029: LD_INT 83
54031: PUSH
54032: LD_INT 84
54034: PUSH
54035: LD_INT 85
54037: PUSH
54038: LD_INT 86
54040: PUSH
54041: EMPTY
54042: LIST
54043: LIST
54044: LIST
54045: LIST
54046: LIST
54047: LIST
54048: LIST
54049: LIST
54050: LIST
54051: LIST
54052: LIST
54053: LIST
54054: LIST
54055: LIST
54056: LIST
54057: LIST
54058: LIST
54059: LIST
54060: LIST
54061: LIST
54062: LIST
54063: LIST
54064: LIST
54065: LIST
54066: LIST
54067: LIST
54068: LIST
54069: LIST
54070: LIST
54071: LIST
54072: LIST
54073: LIST
54074: LIST
54075: LIST
54076: LIST
54077: LIST
54078: LIST
54079: LIST
54080: LIST
54081: LIST
54082: LIST
54083: LIST
54084: LIST
54085: LIST
54086: LIST
54087: LIST
54088: LIST
54089: LIST
54090: LIST
54091: LIST
54092: LIST
54093: LIST
54094: LIST
54095: ST_TO_ADDR
54096: GO 54099
54098: POP
// if state > - 1 and state < 3 then
54099: LD_VAR 0 3
54103: PUSH
54104: LD_INT 1
54106: NEG
54107: GREATER
54108: PUSH
54109: LD_VAR 0 3
54113: PUSH
54114: LD_INT 3
54116: LESS
54117: AND
54118: IFFALSE 54175
// for i in result do
54120: LD_ADDR_VAR 0 5
54124: PUSH
54125: LD_VAR 0 4
54129: PUSH
54130: FOR_IN
54131: IFFALSE 54173
// if GetTech ( i , side ) <> state then
54133: LD_VAR 0 5
54137: PPUSH
54138: LD_VAR 0 1
54142: PPUSH
54143: CALL_OW 321
54147: PUSH
54148: LD_VAR 0 3
54152: NONEQUAL
54153: IFFALSE 54171
// result := result diff i ;
54155: LD_ADDR_VAR 0 4
54159: PUSH
54160: LD_VAR 0 4
54164: PUSH
54165: LD_VAR 0 5
54169: DIFF
54170: ST_TO_ADDR
54171: GO 54130
54173: POP
54174: POP
// end ;
54175: LD_VAR 0 4
54179: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
54180: LD_INT 0
54182: PPUSH
54183: PPUSH
54184: PPUSH
// result := true ;
54185: LD_ADDR_VAR 0 3
54189: PUSH
54190: LD_INT 1
54192: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
54193: LD_ADDR_VAR 0 5
54197: PUSH
54198: LD_VAR 0 2
54202: PPUSH
54203: CALL_OW 480
54207: ST_TO_ADDR
// if not tmp then
54208: LD_VAR 0 5
54212: NOT
54213: IFFALSE 54217
// exit ;
54215: GO 54266
// for i in tmp do
54217: LD_ADDR_VAR 0 4
54221: PUSH
54222: LD_VAR 0 5
54226: PUSH
54227: FOR_IN
54228: IFFALSE 54264
// if GetTech ( i , side ) <> state_researched then
54230: LD_VAR 0 4
54234: PPUSH
54235: LD_VAR 0 1
54239: PPUSH
54240: CALL_OW 321
54244: PUSH
54245: LD_INT 2
54247: NONEQUAL
54248: IFFALSE 54262
// begin result := false ;
54250: LD_ADDR_VAR 0 3
54254: PUSH
54255: LD_INT 0
54257: ST_TO_ADDR
// exit ;
54258: POP
54259: POP
54260: GO 54266
// end ;
54262: GO 54227
54264: POP
54265: POP
// end ;
54266: LD_VAR 0 3
54270: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
54271: LD_INT 0
54273: PPUSH
54274: PPUSH
54275: PPUSH
54276: PPUSH
54277: PPUSH
54278: PPUSH
54279: PPUSH
54280: PPUSH
54281: PPUSH
54282: PPUSH
54283: PPUSH
54284: PPUSH
54285: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
54286: LD_VAR 0 1
54290: NOT
54291: PUSH
54292: LD_VAR 0 1
54296: PPUSH
54297: CALL_OW 257
54301: PUSH
54302: LD_INT 9
54304: NONEQUAL
54305: OR
54306: IFFALSE 54310
// exit ;
54308: GO 54883
// side := GetSide ( unit ) ;
54310: LD_ADDR_VAR 0 9
54314: PUSH
54315: LD_VAR 0 1
54319: PPUSH
54320: CALL_OW 255
54324: ST_TO_ADDR
// tech_space := tech_spacanom ;
54325: LD_ADDR_VAR 0 12
54329: PUSH
54330: LD_INT 29
54332: ST_TO_ADDR
// tech_time := tech_taurad ;
54333: LD_ADDR_VAR 0 13
54337: PUSH
54338: LD_INT 28
54340: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
54341: LD_ADDR_VAR 0 11
54345: PUSH
54346: LD_VAR 0 1
54350: PPUSH
54351: CALL_OW 310
54355: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
54356: LD_VAR 0 11
54360: PPUSH
54361: CALL_OW 247
54365: PUSH
54366: LD_INT 2
54368: EQUAL
54369: IFFALSE 54373
// exit ;
54371: GO 54883
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54373: LD_ADDR_VAR 0 8
54377: PUSH
54378: LD_INT 81
54380: PUSH
54381: LD_VAR 0 9
54385: PUSH
54386: EMPTY
54387: LIST
54388: LIST
54389: PUSH
54390: LD_INT 3
54392: PUSH
54393: LD_INT 21
54395: PUSH
54396: LD_INT 3
54398: PUSH
54399: EMPTY
54400: LIST
54401: LIST
54402: PUSH
54403: EMPTY
54404: LIST
54405: LIST
54406: PUSH
54407: EMPTY
54408: LIST
54409: LIST
54410: PPUSH
54411: CALL_OW 69
54415: ST_TO_ADDR
// if not tmp then
54416: LD_VAR 0 8
54420: NOT
54421: IFFALSE 54425
// exit ;
54423: GO 54883
// if in_unit then
54425: LD_VAR 0 11
54429: IFFALSE 54453
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
54431: LD_ADDR_VAR 0 10
54435: PUSH
54436: LD_VAR 0 8
54440: PPUSH
54441: LD_VAR 0 11
54445: PPUSH
54446: CALL_OW 74
54450: ST_TO_ADDR
54451: GO 54473
// enemy := NearestUnitToUnit ( tmp , unit ) ;
54453: LD_ADDR_VAR 0 10
54457: PUSH
54458: LD_VAR 0 8
54462: PPUSH
54463: LD_VAR 0 1
54467: PPUSH
54468: CALL_OW 74
54472: ST_TO_ADDR
// if not enemy then
54473: LD_VAR 0 10
54477: NOT
54478: IFFALSE 54482
// exit ;
54480: GO 54883
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54482: LD_VAR 0 11
54486: PUSH
54487: LD_VAR 0 11
54491: PPUSH
54492: LD_VAR 0 10
54496: PPUSH
54497: CALL_OW 296
54501: PUSH
54502: LD_INT 13
54504: GREATER
54505: AND
54506: PUSH
54507: LD_VAR 0 1
54511: PPUSH
54512: LD_VAR 0 10
54516: PPUSH
54517: CALL_OW 296
54521: PUSH
54522: LD_INT 12
54524: GREATER
54525: OR
54526: IFFALSE 54530
// exit ;
54528: GO 54883
// missile := [ 1 ] ;
54530: LD_ADDR_VAR 0 14
54534: PUSH
54535: LD_INT 1
54537: PUSH
54538: EMPTY
54539: LIST
54540: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54541: LD_VAR 0 9
54545: PPUSH
54546: LD_VAR 0 12
54550: PPUSH
54551: CALL_OW 325
54555: IFFALSE 54584
// missile := Replace ( missile , missile + 1 , 2 ) ;
54557: LD_ADDR_VAR 0 14
54561: PUSH
54562: LD_VAR 0 14
54566: PPUSH
54567: LD_VAR 0 14
54571: PUSH
54572: LD_INT 1
54574: PLUS
54575: PPUSH
54576: LD_INT 2
54578: PPUSH
54579: CALL_OW 1
54583: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54584: LD_VAR 0 9
54588: PPUSH
54589: LD_VAR 0 13
54593: PPUSH
54594: CALL_OW 325
54598: PUSH
54599: LD_VAR 0 10
54603: PPUSH
54604: CALL_OW 255
54608: PPUSH
54609: LD_VAR 0 13
54613: PPUSH
54614: CALL_OW 325
54618: NOT
54619: AND
54620: IFFALSE 54649
// missile := Replace ( missile , missile + 1 , 3 ) ;
54622: LD_ADDR_VAR 0 14
54626: PUSH
54627: LD_VAR 0 14
54631: PPUSH
54632: LD_VAR 0 14
54636: PUSH
54637: LD_INT 1
54639: PLUS
54640: PPUSH
54641: LD_INT 3
54643: PPUSH
54644: CALL_OW 1
54648: ST_TO_ADDR
// if missile < 2 then
54649: LD_VAR 0 14
54653: PUSH
54654: LD_INT 2
54656: LESS
54657: IFFALSE 54661
// exit ;
54659: GO 54883
// x := GetX ( enemy ) ;
54661: LD_ADDR_VAR 0 4
54665: PUSH
54666: LD_VAR 0 10
54670: PPUSH
54671: CALL_OW 250
54675: ST_TO_ADDR
// y := GetY ( enemy ) ;
54676: LD_ADDR_VAR 0 5
54680: PUSH
54681: LD_VAR 0 10
54685: PPUSH
54686: CALL_OW 251
54690: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
54691: LD_ADDR_VAR 0 6
54695: PUSH
54696: LD_VAR 0 4
54700: PUSH
54701: LD_INT 1
54703: NEG
54704: PPUSH
54705: LD_INT 1
54707: PPUSH
54708: CALL_OW 12
54712: PLUS
54713: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
54714: LD_ADDR_VAR 0 7
54718: PUSH
54719: LD_VAR 0 5
54723: PUSH
54724: LD_INT 1
54726: NEG
54727: PPUSH
54728: LD_INT 1
54730: PPUSH
54731: CALL_OW 12
54735: PLUS
54736: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54737: LD_VAR 0 6
54741: PPUSH
54742: LD_VAR 0 7
54746: PPUSH
54747: CALL_OW 488
54751: NOT
54752: IFFALSE 54774
// begin _x := x ;
54754: LD_ADDR_VAR 0 6
54758: PUSH
54759: LD_VAR 0 4
54763: ST_TO_ADDR
// _y := y ;
54764: LD_ADDR_VAR 0 7
54768: PUSH
54769: LD_VAR 0 5
54773: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
54774: LD_ADDR_VAR 0 3
54778: PUSH
54779: LD_INT 1
54781: PPUSH
54782: LD_VAR 0 14
54786: PPUSH
54787: CALL_OW 12
54791: ST_TO_ADDR
// case i of 1 :
54792: LD_VAR 0 3
54796: PUSH
54797: LD_INT 1
54799: DOUBLE
54800: EQUAL
54801: IFTRUE 54805
54803: GO 54822
54805: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
54806: LD_VAR 0 1
54810: PPUSH
54811: LD_VAR 0 10
54815: PPUSH
54816: CALL_OW 115
54820: GO 54883
54822: LD_INT 2
54824: DOUBLE
54825: EQUAL
54826: IFTRUE 54830
54828: GO 54852
54830: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
54831: LD_VAR 0 1
54835: PPUSH
54836: LD_VAR 0 6
54840: PPUSH
54841: LD_VAR 0 7
54845: PPUSH
54846: CALL_OW 153
54850: GO 54883
54852: LD_INT 3
54854: DOUBLE
54855: EQUAL
54856: IFTRUE 54860
54858: GO 54882
54860: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
54861: LD_VAR 0 1
54865: PPUSH
54866: LD_VAR 0 6
54870: PPUSH
54871: LD_VAR 0 7
54875: PPUSH
54876: CALL_OW 154
54880: GO 54883
54882: POP
// end ;
54883: LD_VAR 0 2
54887: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
54888: LD_INT 0
54890: PPUSH
54891: PPUSH
54892: PPUSH
54893: PPUSH
54894: PPUSH
54895: PPUSH
// if not unit or not building then
54896: LD_VAR 0 1
54900: NOT
54901: PUSH
54902: LD_VAR 0 2
54906: NOT
54907: OR
54908: IFFALSE 54912
// exit ;
54910: GO 55070
// x := GetX ( building ) ;
54912: LD_ADDR_VAR 0 5
54916: PUSH
54917: LD_VAR 0 2
54921: PPUSH
54922: CALL_OW 250
54926: ST_TO_ADDR
// y := GetY ( building ) ;
54927: LD_ADDR_VAR 0 6
54931: PUSH
54932: LD_VAR 0 2
54936: PPUSH
54937: CALL_OW 251
54941: ST_TO_ADDR
// for i = 0 to 5 do
54942: LD_ADDR_VAR 0 4
54946: PUSH
54947: DOUBLE
54948: LD_INT 0
54950: DEC
54951: ST_TO_ADDR
54952: LD_INT 5
54954: PUSH
54955: FOR_TO
54956: IFFALSE 55068
// begin _x := ShiftX ( x , i , 3 ) ;
54958: LD_ADDR_VAR 0 7
54962: PUSH
54963: LD_VAR 0 5
54967: PPUSH
54968: LD_VAR 0 4
54972: PPUSH
54973: LD_INT 3
54975: PPUSH
54976: CALL_OW 272
54980: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
54981: LD_ADDR_VAR 0 8
54985: PUSH
54986: LD_VAR 0 6
54990: PPUSH
54991: LD_VAR 0 4
54995: PPUSH
54996: LD_INT 3
54998: PPUSH
54999: CALL_OW 273
55003: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55004: LD_VAR 0 7
55008: PPUSH
55009: LD_VAR 0 8
55013: PPUSH
55014: CALL_OW 488
55018: NOT
55019: IFFALSE 55023
// continue ;
55021: GO 54955
// if HexInfo ( _x , _y ) = 0 then
55023: LD_VAR 0 7
55027: PPUSH
55028: LD_VAR 0 8
55032: PPUSH
55033: CALL_OW 428
55037: PUSH
55038: LD_INT 0
55040: EQUAL
55041: IFFALSE 55066
// begin ComMoveXY ( unit , _x , _y ) ;
55043: LD_VAR 0 1
55047: PPUSH
55048: LD_VAR 0 7
55052: PPUSH
55053: LD_VAR 0 8
55057: PPUSH
55058: CALL_OW 111
// exit ;
55062: POP
55063: POP
55064: GO 55070
// end ; end ;
55066: GO 54955
55068: POP
55069: POP
// end ;
55070: LD_VAR 0 3
55074: RET
// export function ScanBase ( side , base_area ) ; begin
55075: LD_INT 0
55077: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
55078: LD_ADDR_VAR 0 3
55082: PUSH
55083: LD_VAR 0 2
55087: PPUSH
55088: LD_INT 81
55090: PUSH
55091: LD_VAR 0 1
55095: PUSH
55096: EMPTY
55097: LIST
55098: LIST
55099: PPUSH
55100: CALL_OW 70
55104: ST_TO_ADDR
// end ;
55105: LD_VAR 0 3
55109: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
55110: LD_INT 0
55112: PPUSH
55113: PPUSH
55114: PPUSH
55115: PPUSH
// result := false ;
55116: LD_ADDR_VAR 0 2
55120: PUSH
55121: LD_INT 0
55123: ST_TO_ADDR
// side := GetSide ( unit ) ;
55124: LD_ADDR_VAR 0 3
55128: PUSH
55129: LD_VAR 0 1
55133: PPUSH
55134: CALL_OW 255
55138: ST_TO_ADDR
// nat := GetNation ( unit ) ;
55139: LD_ADDR_VAR 0 4
55143: PUSH
55144: LD_VAR 0 1
55148: PPUSH
55149: CALL_OW 248
55153: ST_TO_ADDR
// case nat of 1 :
55154: LD_VAR 0 4
55158: PUSH
55159: LD_INT 1
55161: DOUBLE
55162: EQUAL
55163: IFTRUE 55167
55165: GO 55178
55167: POP
// tech := tech_lassight ; 2 :
55168: LD_ADDR_VAR 0 5
55172: PUSH
55173: LD_INT 12
55175: ST_TO_ADDR
55176: GO 55217
55178: LD_INT 2
55180: DOUBLE
55181: EQUAL
55182: IFTRUE 55186
55184: GO 55197
55186: POP
// tech := tech_mortar ; 3 :
55187: LD_ADDR_VAR 0 5
55191: PUSH
55192: LD_INT 41
55194: ST_TO_ADDR
55195: GO 55217
55197: LD_INT 3
55199: DOUBLE
55200: EQUAL
55201: IFTRUE 55205
55203: GO 55216
55205: POP
// tech := tech_bazooka ; end ;
55206: LD_ADDR_VAR 0 5
55210: PUSH
55211: LD_INT 44
55213: ST_TO_ADDR
55214: GO 55217
55216: POP
// if Researched ( side , tech ) then
55217: LD_VAR 0 3
55221: PPUSH
55222: LD_VAR 0 5
55226: PPUSH
55227: CALL_OW 325
55231: IFFALSE 55258
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
55233: LD_ADDR_VAR 0 2
55237: PUSH
55238: LD_INT 5
55240: PUSH
55241: LD_INT 8
55243: PUSH
55244: LD_INT 9
55246: PUSH
55247: EMPTY
55248: LIST
55249: LIST
55250: LIST
55251: PUSH
55252: LD_VAR 0 4
55256: ARRAY
55257: ST_TO_ADDR
// end ;
55258: LD_VAR 0 2
55262: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
55263: LD_INT 0
55265: PPUSH
55266: PPUSH
55267: PPUSH
// if not mines then
55268: LD_VAR 0 2
55272: NOT
55273: IFFALSE 55277
// exit ;
55275: GO 55421
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55277: LD_ADDR_VAR 0 5
55281: PUSH
55282: LD_INT 81
55284: PUSH
55285: LD_VAR 0 1
55289: PUSH
55290: EMPTY
55291: LIST
55292: LIST
55293: PUSH
55294: LD_INT 3
55296: PUSH
55297: LD_INT 21
55299: PUSH
55300: LD_INT 3
55302: PUSH
55303: EMPTY
55304: LIST
55305: LIST
55306: PUSH
55307: EMPTY
55308: LIST
55309: LIST
55310: PUSH
55311: EMPTY
55312: LIST
55313: LIST
55314: PPUSH
55315: CALL_OW 69
55319: ST_TO_ADDR
// for i in mines do
55320: LD_ADDR_VAR 0 4
55324: PUSH
55325: LD_VAR 0 2
55329: PUSH
55330: FOR_IN
55331: IFFALSE 55419
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
55333: LD_VAR 0 4
55337: PUSH
55338: LD_INT 1
55340: ARRAY
55341: PPUSH
55342: LD_VAR 0 4
55346: PUSH
55347: LD_INT 2
55349: ARRAY
55350: PPUSH
55351: CALL_OW 458
55355: NOT
55356: IFFALSE 55360
// continue ;
55358: GO 55330
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
55360: LD_VAR 0 4
55364: PUSH
55365: LD_INT 1
55367: ARRAY
55368: PPUSH
55369: LD_VAR 0 4
55373: PUSH
55374: LD_INT 2
55376: ARRAY
55377: PPUSH
55378: CALL_OW 428
55382: PUSH
55383: LD_VAR 0 5
55387: IN
55388: IFFALSE 55417
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
55390: LD_VAR 0 4
55394: PUSH
55395: LD_INT 1
55397: ARRAY
55398: PPUSH
55399: LD_VAR 0 4
55403: PUSH
55404: LD_INT 2
55406: ARRAY
55407: PPUSH
55408: LD_VAR 0 1
55412: PPUSH
55413: CALL_OW 456
// end ;
55417: GO 55330
55419: POP
55420: POP
// end ;
55421: LD_VAR 0 3
55425: RET
// export function Count ( array ) ; begin
55426: LD_INT 0
55428: PPUSH
// result := array + 0 ;
55429: LD_ADDR_VAR 0 2
55433: PUSH
55434: LD_VAR 0 1
55438: PUSH
55439: LD_INT 0
55441: PLUS
55442: ST_TO_ADDR
// end ;
55443: LD_VAR 0 2
55447: RET
// export function IsEmpty ( building ) ; begin
55448: LD_INT 0
55450: PPUSH
// if not building then
55451: LD_VAR 0 1
55455: NOT
55456: IFFALSE 55460
// exit ;
55458: GO 55503
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
55460: LD_ADDR_VAR 0 2
55464: PUSH
55465: LD_VAR 0 1
55469: PUSH
55470: LD_INT 22
55472: PUSH
55473: LD_VAR 0 1
55477: PPUSH
55478: CALL_OW 255
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: PUSH
55487: LD_INT 58
55489: PUSH
55490: EMPTY
55491: LIST
55492: PUSH
55493: EMPTY
55494: LIST
55495: LIST
55496: PPUSH
55497: CALL_OW 69
55501: IN
55502: ST_TO_ADDR
// end ;
55503: LD_VAR 0 2
55507: RET
// export function IsNotFull ( building ) ; var places ; begin
55508: LD_INT 0
55510: PPUSH
55511: PPUSH
// if not building then
55512: LD_VAR 0 1
55516: NOT
55517: IFFALSE 55521
// exit ;
55519: GO 55549
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
55521: LD_ADDR_VAR 0 2
55525: PUSH
55526: LD_VAR 0 1
55530: PPUSH
55531: LD_INT 3
55533: PUSH
55534: LD_INT 62
55536: PUSH
55537: EMPTY
55538: LIST
55539: PUSH
55540: EMPTY
55541: LIST
55542: LIST
55543: PPUSH
55544: CALL_OW 72
55548: ST_TO_ADDR
// end ;
55549: LD_VAR 0 2
55553: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55554: LD_INT 0
55556: PPUSH
55557: PPUSH
55558: PPUSH
55559: PPUSH
// tmp := [ ] ;
55560: LD_ADDR_VAR 0 3
55564: PUSH
55565: EMPTY
55566: ST_TO_ADDR
// list := [ ] ;
55567: LD_ADDR_VAR 0 5
55571: PUSH
55572: EMPTY
55573: ST_TO_ADDR
// for i = 16 to 25 do
55574: LD_ADDR_VAR 0 4
55578: PUSH
55579: DOUBLE
55580: LD_INT 16
55582: DEC
55583: ST_TO_ADDR
55584: LD_INT 25
55586: PUSH
55587: FOR_TO
55588: IFFALSE 55661
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55590: LD_ADDR_VAR 0 3
55594: PUSH
55595: LD_VAR 0 3
55599: PUSH
55600: LD_INT 22
55602: PUSH
55603: LD_VAR 0 1
55607: PPUSH
55608: CALL_OW 255
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: PUSH
55617: LD_INT 91
55619: PUSH
55620: LD_VAR 0 1
55624: PUSH
55625: LD_INT 6
55627: PUSH
55628: EMPTY
55629: LIST
55630: LIST
55631: LIST
55632: PUSH
55633: LD_INT 30
55635: PUSH
55636: LD_VAR 0 4
55640: PUSH
55641: EMPTY
55642: LIST
55643: LIST
55644: PUSH
55645: EMPTY
55646: LIST
55647: LIST
55648: LIST
55649: PUSH
55650: EMPTY
55651: LIST
55652: PPUSH
55653: CALL_OW 69
55657: ADD
55658: ST_TO_ADDR
55659: GO 55587
55661: POP
55662: POP
// for i = 1 to tmp do
55663: LD_ADDR_VAR 0 4
55667: PUSH
55668: DOUBLE
55669: LD_INT 1
55671: DEC
55672: ST_TO_ADDR
55673: LD_VAR 0 3
55677: PUSH
55678: FOR_TO
55679: IFFALSE 55767
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55681: LD_ADDR_VAR 0 5
55685: PUSH
55686: LD_VAR 0 5
55690: PUSH
55691: LD_VAR 0 3
55695: PUSH
55696: LD_VAR 0 4
55700: ARRAY
55701: PPUSH
55702: CALL_OW 266
55706: PUSH
55707: LD_VAR 0 3
55711: PUSH
55712: LD_VAR 0 4
55716: ARRAY
55717: PPUSH
55718: CALL_OW 250
55722: PUSH
55723: LD_VAR 0 3
55727: PUSH
55728: LD_VAR 0 4
55732: ARRAY
55733: PPUSH
55734: CALL_OW 251
55738: PUSH
55739: LD_VAR 0 3
55743: PUSH
55744: LD_VAR 0 4
55748: ARRAY
55749: PPUSH
55750: CALL_OW 254
55754: PUSH
55755: EMPTY
55756: LIST
55757: LIST
55758: LIST
55759: LIST
55760: PUSH
55761: EMPTY
55762: LIST
55763: ADD
55764: ST_TO_ADDR
55765: GO 55678
55767: POP
55768: POP
// result := list ;
55769: LD_ADDR_VAR 0 2
55773: PUSH
55774: LD_VAR 0 5
55778: ST_TO_ADDR
// end ;
55779: LD_VAR 0 2
55783: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55784: LD_INT 0
55786: PPUSH
55787: PPUSH
55788: PPUSH
55789: PPUSH
55790: PPUSH
55791: PPUSH
55792: PPUSH
// if not factory then
55793: LD_VAR 0 1
55797: NOT
55798: IFFALSE 55802
// exit ;
55800: GO 56395
// if control = control_apeman then
55802: LD_VAR 0 4
55806: PUSH
55807: LD_INT 5
55809: EQUAL
55810: IFFALSE 55919
// begin tmp := UnitsInside ( factory ) ;
55812: LD_ADDR_VAR 0 8
55816: PUSH
55817: LD_VAR 0 1
55821: PPUSH
55822: CALL_OW 313
55826: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55827: LD_VAR 0 8
55831: PPUSH
55832: LD_INT 25
55834: PUSH
55835: LD_INT 12
55837: PUSH
55838: EMPTY
55839: LIST
55840: LIST
55841: PPUSH
55842: CALL_OW 72
55846: NOT
55847: IFFALSE 55857
// control := control_manual ;
55849: LD_ADDR_VAR 0 4
55853: PUSH
55854: LD_INT 1
55856: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55857: LD_ADDR_VAR 0 8
55861: PUSH
55862: LD_VAR 0 1
55866: PPUSH
55867: CALL 55554 0 1
55871: ST_TO_ADDR
// if tmp then
55872: LD_VAR 0 8
55876: IFFALSE 55919
// begin for i in tmp do
55878: LD_ADDR_VAR 0 7
55882: PUSH
55883: LD_VAR 0 8
55887: PUSH
55888: FOR_IN
55889: IFFALSE 55917
// if i [ 1 ] = b_ext_radio then
55891: LD_VAR 0 7
55895: PUSH
55896: LD_INT 1
55898: ARRAY
55899: PUSH
55900: LD_INT 22
55902: EQUAL
55903: IFFALSE 55915
// begin control := control_remote ;
55905: LD_ADDR_VAR 0 4
55909: PUSH
55910: LD_INT 2
55912: ST_TO_ADDR
// break ;
55913: GO 55917
// end ;
55915: GO 55888
55917: POP
55918: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55919: LD_VAR 0 1
55923: PPUSH
55924: LD_VAR 0 2
55928: PPUSH
55929: LD_VAR 0 3
55933: PPUSH
55934: LD_VAR 0 4
55938: PPUSH
55939: LD_VAR 0 5
55943: PPUSH
55944: CALL_OW 448
55948: IFFALSE 55983
// begin result := [ chassis , engine , control , weapon ] ;
55950: LD_ADDR_VAR 0 6
55954: PUSH
55955: LD_VAR 0 2
55959: PUSH
55960: LD_VAR 0 3
55964: PUSH
55965: LD_VAR 0 4
55969: PUSH
55970: LD_VAR 0 5
55974: PUSH
55975: EMPTY
55976: LIST
55977: LIST
55978: LIST
55979: LIST
55980: ST_TO_ADDR
// exit ;
55981: GO 56395
// end ; _chassis := AvailableChassisList ( factory ) ;
55983: LD_ADDR_VAR 0 9
55987: PUSH
55988: LD_VAR 0 1
55992: PPUSH
55993: CALL_OW 475
55997: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55998: LD_ADDR_VAR 0 11
56002: PUSH
56003: LD_VAR 0 1
56007: PPUSH
56008: CALL_OW 476
56012: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
56013: LD_ADDR_VAR 0 12
56017: PUSH
56018: LD_VAR 0 1
56022: PPUSH
56023: CALL_OW 477
56027: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
56028: LD_ADDR_VAR 0 10
56032: PUSH
56033: LD_VAR 0 1
56037: PPUSH
56038: CALL_OW 478
56042: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
56043: LD_VAR 0 9
56047: NOT
56048: PUSH
56049: LD_VAR 0 11
56053: NOT
56054: OR
56055: PUSH
56056: LD_VAR 0 12
56060: NOT
56061: OR
56062: PUSH
56063: LD_VAR 0 10
56067: NOT
56068: OR
56069: IFFALSE 56104
// begin result := [ chassis , engine , control , weapon ] ;
56071: LD_ADDR_VAR 0 6
56075: PUSH
56076: LD_VAR 0 2
56080: PUSH
56081: LD_VAR 0 3
56085: PUSH
56086: LD_VAR 0 4
56090: PUSH
56091: LD_VAR 0 5
56095: PUSH
56096: EMPTY
56097: LIST
56098: LIST
56099: LIST
56100: LIST
56101: ST_TO_ADDR
// exit ;
56102: GO 56395
// end ; if not chassis in _chassis then
56104: LD_VAR 0 2
56108: PUSH
56109: LD_VAR 0 9
56113: IN
56114: NOT
56115: IFFALSE 56141
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
56117: LD_ADDR_VAR 0 2
56121: PUSH
56122: LD_VAR 0 9
56126: PUSH
56127: LD_INT 1
56129: PPUSH
56130: LD_VAR 0 9
56134: PPUSH
56135: CALL_OW 12
56139: ARRAY
56140: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
56141: LD_VAR 0 2
56145: PPUSH
56146: LD_VAR 0 3
56150: PPUSH
56151: CALL 56400 0 2
56155: NOT
56156: IFFALSE 56215
// repeat engine := _engine [ 1 ] ;
56158: LD_ADDR_VAR 0 3
56162: PUSH
56163: LD_VAR 0 11
56167: PUSH
56168: LD_INT 1
56170: ARRAY
56171: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
56172: LD_ADDR_VAR 0 11
56176: PUSH
56177: LD_VAR 0 11
56181: PPUSH
56182: LD_INT 1
56184: PPUSH
56185: CALL_OW 3
56189: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
56190: LD_VAR 0 2
56194: PPUSH
56195: LD_VAR 0 3
56199: PPUSH
56200: CALL 56400 0 2
56204: PUSH
56205: LD_VAR 0 11
56209: PUSH
56210: EMPTY
56211: EQUAL
56212: OR
56213: IFFALSE 56158
// if not control in _control then
56215: LD_VAR 0 4
56219: PUSH
56220: LD_VAR 0 12
56224: IN
56225: NOT
56226: IFFALSE 56252
// control := _control [ rand ( 1 , _control ) ] ;
56228: LD_ADDR_VAR 0 4
56232: PUSH
56233: LD_VAR 0 12
56237: PUSH
56238: LD_INT 1
56240: PPUSH
56241: LD_VAR 0 12
56245: PPUSH
56246: CALL_OW 12
56250: ARRAY
56251: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
56252: LD_VAR 0 2
56256: PPUSH
56257: LD_VAR 0 5
56261: PPUSH
56262: CALL 56620 0 2
56266: NOT
56267: IFFALSE 56326
// repeat weapon := _weapon [ 1 ] ;
56269: LD_ADDR_VAR 0 5
56273: PUSH
56274: LD_VAR 0 10
56278: PUSH
56279: LD_INT 1
56281: ARRAY
56282: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
56283: LD_ADDR_VAR 0 10
56287: PUSH
56288: LD_VAR 0 10
56292: PPUSH
56293: LD_INT 1
56295: PPUSH
56296: CALL_OW 3
56300: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
56301: LD_VAR 0 2
56305: PPUSH
56306: LD_VAR 0 5
56310: PPUSH
56311: CALL 56620 0 2
56315: PUSH
56316: LD_VAR 0 10
56320: PUSH
56321: EMPTY
56322: EQUAL
56323: OR
56324: IFFALSE 56269
// result := [ ] ;
56326: LD_ADDR_VAR 0 6
56330: PUSH
56331: EMPTY
56332: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56333: LD_VAR 0 1
56337: PPUSH
56338: LD_VAR 0 2
56342: PPUSH
56343: LD_VAR 0 3
56347: PPUSH
56348: LD_VAR 0 4
56352: PPUSH
56353: LD_VAR 0 5
56357: PPUSH
56358: CALL_OW 448
56362: IFFALSE 56395
// result := [ chassis , engine , control , weapon ] ;
56364: LD_ADDR_VAR 0 6
56368: PUSH
56369: LD_VAR 0 2
56373: PUSH
56374: LD_VAR 0 3
56378: PUSH
56379: LD_VAR 0 4
56383: PUSH
56384: LD_VAR 0 5
56388: PUSH
56389: EMPTY
56390: LIST
56391: LIST
56392: LIST
56393: LIST
56394: ST_TO_ADDR
// end ;
56395: LD_VAR 0 6
56399: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
56400: LD_INT 0
56402: PPUSH
// if not chassis or not engine then
56403: LD_VAR 0 1
56407: NOT
56408: PUSH
56409: LD_VAR 0 2
56413: NOT
56414: OR
56415: IFFALSE 56419
// exit ;
56417: GO 56615
// case engine of engine_solar :
56419: LD_VAR 0 2
56423: PUSH
56424: LD_INT 2
56426: DOUBLE
56427: EQUAL
56428: IFTRUE 56432
56430: GO 56470
56432: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
56433: LD_ADDR_VAR 0 3
56437: PUSH
56438: LD_INT 11
56440: PUSH
56441: LD_INT 12
56443: PUSH
56444: LD_INT 13
56446: PUSH
56447: LD_INT 14
56449: PUSH
56450: LD_INT 1
56452: PUSH
56453: LD_INT 2
56455: PUSH
56456: LD_INT 3
56458: PUSH
56459: EMPTY
56460: LIST
56461: LIST
56462: LIST
56463: LIST
56464: LIST
56465: LIST
56466: LIST
56467: ST_TO_ADDR
56468: GO 56599
56470: LD_INT 1
56472: DOUBLE
56473: EQUAL
56474: IFTRUE 56478
56476: GO 56540
56478: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56479: LD_ADDR_VAR 0 3
56483: PUSH
56484: LD_INT 11
56486: PUSH
56487: LD_INT 12
56489: PUSH
56490: LD_INT 13
56492: PUSH
56493: LD_INT 14
56495: PUSH
56496: LD_INT 1
56498: PUSH
56499: LD_INT 2
56501: PUSH
56502: LD_INT 3
56504: PUSH
56505: LD_INT 4
56507: PUSH
56508: LD_INT 5
56510: PUSH
56511: LD_INT 21
56513: PUSH
56514: LD_INT 23
56516: PUSH
56517: LD_INT 22
56519: PUSH
56520: LD_INT 24
56522: PUSH
56523: EMPTY
56524: LIST
56525: LIST
56526: LIST
56527: LIST
56528: LIST
56529: LIST
56530: LIST
56531: LIST
56532: LIST
56533: LIST
56534: LIST
56535: LIST
56536: LIST
56537: ST_TO_ADDR
56538: GO 56599
56540: LD_INT 3
56542: DOUBLE
56543: EQUAL
56544: IFTRUE 56548
56546: GO 56598
56548: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56549: LD_ADDR_VAR 0 3
56553: PUSH
56554: LD_INT 13
56556: PUSH
56557: LD_INT 14
56559: PUSH
56560: LD_INT 2
56562: PUSH
56563: LD_INT 3
56565: PUSH
56566: LD_INT 4
56568: PUSH
56569: LD_INT 5
56571: PUSH
56572: LD_INT 21
56574: PUSH
56575: LD_INT 22
56577: PUSH
56578: LD_INT 23
56580: PUSH
56581: LD_INT 24
56583: PUSH
56584: EMPTY
56585: LIST
56586: LIST
56587: LIST
56588: LIST
56589: LIST
56590: LIST
56591: LIST
56592: LIST
56593: LIST
56594: LIST
56595: ST_TO_ADDR
56596: GO 56599
56598: POP
// result := ( chassis in result ) ;
56599: LD_ADDR_VAR 0 3
56603: PUSH
56604: LD_VAR 0 1
56608: PUSH
56609: LD_VAR 0 3
56613: IN
56614: ST_TO_ADDR
// end ;
56615: LD_VAR 0 3
56619: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56620: LD_INT 0
56622: PPUSH
// if not chassis or not weapon then
56623: LD_VAR 0 1
56627: NOT
56628: PUSH
56629: LD_VAR 0 2
56633: NOT
56634: OR
56635: IFFALSE 56639
// exit ;
56637: GO 57699
// case weapon of us_machine_gun :
56639: LD_VAR 0 2
56643: PUSH
56644: LD_INT 2
56646: DOUBLE
56647: EQUAL
56648: IFTRUE 56652
56650: GO 56682
56652: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56653: LD_ADDR_VAR 0 3
56657: PUSH
56658: LD_INT 1
56660: PUSH
56661: LD_INT 2
56663: PUSH
56664: LD_INT 3
56666: PUSH
56667: LD_INT 4
56669: PUSH
56670: LD_INT 5
56672: PUSH
56673: EMPTY
56674: LIST
56675: LIST
56676: LIST
56677: LIST
56678: LIST
56679: ST_TO_ADDR
56680: GO 57683
56682: LD_INT 3
56684: DOUBLE
56685: EQUAL
56686: IFTRUE 56690
56688: GO 56720
56690: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56691: LD_ADDR_VAR 0 3
56695: PUSH
56696: LD_INT 1
56698: PUSH
56699: LD_INT 2
56701: PUSH
56702: LD_INT 3
56704: PUSH
56705: LD_INT 4
56707: PUSH
56708: LD_INT 5
56710: PUSH
56711: EMPTY
56712: LIST
56713: LIST
56714: LIST
56715: LIST
56716: LIST
56717: ST_TO_ADDR
56718: GO 57683
56720: LD_INT 11
56722: DOUBLE
56723: EQUAL
56724: IFTRUE 56728
56726: GO 56758
56728: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56729: LD_ADDR_VAR 0 3
56733: PUSH
56734: LD_INT 1
56736: PUSH
56737: LD_INT 2
56739: PUSH
56740: LD_INT 3
56742: PUSH
56743: LD_INT 4
56745: PUSH
56746: LD_INT 5
56748: PUSH
56749: EMPTY
56750: LIST
56751: LIST
56752: LIST
56753: LIST
56754: LIST
56755: ST_TO_ADDR
56756: GO 57683
56758: LD_INT 4
56760: DOUBLE
56761: EQUAL
56762: IFTRUE 56766
56764: GO 56792
56766: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56767: LD_ADDR_VAR 0 3
56771: PUSH
56772: LD_INT 2
56774: PUSH
56775: LD_INT 3
56777: PUSH
56778: LD_INT 4
56780: PUSH
56781: LD_INT 5
56783: PUSH
56784: EMPTY
56785: LIST
56786: LIST
56787: LIST
56788: LIST
56789: ST_TO_ADDR
56790: GO 57683
56792: LD_INT 5
56794: DOUBLE
56795: EQUAL
56796: IFTRUE 56800
56798: GO 56826
56800: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56801: LD_ADDR_VAR 0 3
56805: PUSH
56806: LD_INT 2
56808: PUSH
56809: LD_INT 3
56811: PUSH
56812: LD_INT 4
56814: PUSH
56815: LD_INT 5
56817: PUSH
56818: EMPTY
56819: LIST
56820: LIST
56821: LIST
56822: LIST
56823: ST_TO_ADDR
56824: GO 57683
56826: LD_INT 9
56828: DOUBLE
56829: EQUAL
56830: IFTRUE 56834
56832: GO 56860
56834: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56835: LD_ADDR_VAR 0 3
56839: PUSH
56840: LD_INT 2
56842: PUSH
56843: LD_INT 3
56845: PUSH
56846: LD_INT 4
56848: PUSH
56849: LD_INT 5
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: LIST
56856: LIST
56857: ST_TO_ADDR
56858: GO 57683
56860: LD_INT 7
56862: DOUBLE
56863: EQUAL
56864: IFTRUE 56868
56866: GO 56894
56868: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56869: LD_ADDR_VAR 0 3
56873: PUSH
56874: LD_INT 2
56876: PUSH
56877: LD_INT 3
56879: PUSH
56880: LD_INT 4
56882: PUSH
56883: LD_INT 5
56885: PUSH
56886: EMPTY
56887: LIST
56888: LIST
56889: LIST
56890: LIST
56891: ST_TO_ADDR
56892: GO 57683
56894: LD_INT 12
56896: DOUBLE
56897: EQUAL
56898: IFTRUE 56902
56900: GO 56928
56902: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56903: LD_ADDR_VAR 0 3
56907: PUSH
56908: LD_INT 2
56910: PUSH
56911: LD_INT 3
56913: PUSH
56914: LD_INT 4
56916: PUSH
56917: LD_INT 5
56919: PUSH
56920: EMPTY
56921: LIST
56922: LIST
56923: LIST
56924: LIST
56925: ST_TO_ADDR
56926: GO 57683
56928: LD_INT 13
56930: DOUBLE
56931: EQUAL
56932: IFTRUE 56936
56934: GO 56962
56936: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56937: LD_ADDR_VAR 0 3
56941: PUSH
56942: LD_INT 2
56944: PUSH
56945: LD_INT 3
56947: PUSH
56948: LD_INT 4
56950: PUSH
56951: LD_INT 5
56953: PUSH
56954: EMPTY
56955: LIST
56956: LIST
56957: LIST
56958: LIST
56959: ST_TO_ADDR
56960: GO 57683
56962: LD_INT 14
56964: DOUBLE
56965: EQUAL
56966: IFTRUE 56970
56968: GO 56988
56970: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56971: LD_ADDR_VAR 0 3
56975: PUSH
56976: LD_INT 4
56978: PUSH
56979: LD_INT 5
56981: PUSH
56982: EMPTY
56983: LIST
56984: LIST
56985: ST_TO_ADDR
56986: GO 57683
56988: LD_INT 6
56990: DOUBLE
56991: EQUAL
56992: IFTRUE 56996
56994: GO 57014
56996: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56997: LD_ADDR_VAR 0 3
57001: PUSH
57002: LD_INT 4
57004: PUSH
57005: LD_INT 5
57007: PUSH
57008: EMPTY
57009: LIST
57010: LIST
57011: ST_TO_ADDR
57012: GO 57683
57014: LD_INT 10
57016: DOUBLE
57017: EQUAL
57018: IFTRUE 57022
57020: GO 57040
57022: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
57023: LD_ADDR_VAR 0 3
57027: PUSH
57028: LD_INT 4
57030: PUSH
57031: LD_INT 5
57033: PUSH
57034: EMPTY
57035: LIST
57036: LIST
57037: ST_TO_ADDR
57038: GO 57683
57040: LD_INT 22
57042: DOUBLE
57043: EQUAL
57044: IFTRUE 57048
57046: GO 57074
57048: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
57049: LD_ADDR_VAR 0 3
57053: PUSH
57054: LD_INT 11
57056: PUSH
57057: LD_INT 12
57059: PUSH
57060: LD_INT 13
57062: PUSH
57063: LD_INT 14
57065: PUSH
57066: EMPTY
57067: LIST
57068: LIST
57069: LIST
57070: LIST
57071: ST_TO_ADDR
57072: GO 57683
57074: LD_INT 23
57076: DOUBLE
57077: EQUAL
57078: IFTRUE 57082
57080: GO 57108
57082: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
57083: LD_ADDR_VAR 0 3
57087: PUSH
57088: LD_INT 11
57090: PUSH
57091: LD_INT 12
57093: PUSH
57094: LD_INT 13
57096: PUSH
57097: LD_INT 14
57099: PUSH
57100: EMPTY
57101: LIST
57102: LIST
57103: LIST
57104: LIST
57105: ST_TO_ADDR
57106: GO 57683
57108: LD_INT 24
57110: DOUBLE
57111: EQUAL
57112: IFTRUE 57116
57114: GO 57142
57116: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
57117: LD_ADDR_VAR 0 3
57121: PUSH
57122: LD_INT 11
57124: PUSH
57125: LD_INT 12
57127: PUSH
57128: LD_INT 13
57130: PUSH
57131: LD_INT 14
57133: PUSH
57134: EMPTY
57135: LIST
57136: LIST
57137: LIST
57138: LIST
57139: ST_TO_ADDR
57140: GO 57683
57142: LD_INT 30
57144: DOUBLE
57145: EQUAL
57146: IFTRUE 57150
57148: GO 57176
57150: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
57151: LD_ADDR_VAR 0 3
57155: PUSH
57156: LD_INT 11
57158: PUSH
57159: LD_INT 12
57161: PUSH
57162: LD_INT 13
57164: PUSH
57165: LD_INT 14
57167: PUSH
57168: EMPTY
57169: LIST
57170: LIST
57171: LIST
57172: LIST
57173: ST_TO_ADDR
57174: GO 57683
57176: LD_INT 25
57178: DOUBLE
57179: EQUAL
57180: IFTRUE 57184
57182: GO 57202
57184: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
57185: LD_ADDR_VAR 0 3
57189: PUSH
57190: LD_INT 13
57192: PUSH
57193: LD_INT 14
57195: PUSH
57196: EMPTY
57197: LIST
57198: LIST
57199: ST_TO_ADDR
57200: GO 57683
57202: LD_INT 27
57204: DOUBLE
57205: EQUAL
57206: IFTRUE 57210
57208: GO 57228
57210: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
57211: LD_ADDR_VAR 0 3
57215: PUSH
57216: LD_INT 13
57218: PUSH
57219: LD_INT 14
57221: PUSH
57222: EMPTY
57223: LIST
57224: LIST
57225: ST_TO_ADDR
57226: GO 57683
57228: LD_INT 92
57230: DOUBLE
57231: EQUAL
57232: IFTRUE 57236
57234: GO 57262
57236: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
57237: LD_ADDR_VAR 0 3
57241: PUSH
57242: LD_INT 11
57244: PUSH
57245: LD_INT 12
57247: PUSH
57248: LD_INT 13
57250: PUSH
57251: LD_INT 14
57253: PUSH
57254: EMPTY
57255: LIST
57256: LIST
57257: LIST
57258: LIST
57259: ST_TO_ADDR
57260: GO 57683
57262: LD_INT 28
57264: DOUBLE
57265: EQUAL
57266: IFTRUE 57270
57268: GO 57288
57270: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
57271: LD_ADDR_VAR 0 3
57275: PUSH
57276: LD_INT 13
57278: PUSH
57279: LD_INT 14
57281: PUSH
57282: EMPTY
57283: LIST
57284: LIST
57285: ST_TO_ADDR
57286: GO 57683
57288: LD_INT 29
57290: DOUBLE
57291: EQUAL
57292: IFTRUE 57296
57294: GO 57314
57296: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
57297: LD_ADDR_VAR 0 3
57301: PUSH
57302: LD_INT 13
57304: PUSH
57305: LD_INT 14
57307: PUSH
57308: EMPTY
57309: LIST
57310: LIST
57311: ST_TO_ADDR
57312: GO 57683
57314: LD_INT 31
57316: DOUBLE
57317: EQUAL
57318: IFTRUE 57322
57320: GO 57340
57322: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
57323: LD_ADDR_VAR 0 3
57327: PUSH
57328: LD_INT 13
57330: PUSH
57331: LD_INT 14
57333: PUSH
57334: EMPTY
57335: LIST
57336: LIST
57337: ST_TO_ADDR
57338: GO 57683
57340: LD_INT 26
57342: DOUBLE
57343: EQUAL
57344: IFTRUE 57348
57346: GO 57366
57348: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
57349: LD_ADDR_VAR 0 3
57353: PUSH
57354: LD_INT 13
57356: PUSH
57357: LD_INT 14
57359: PUSH
57360: EMPTY
57361: LIST
57362: LIST
57363: ST_TO_ADDR
57364: GO 57683
57366: LD_INT 42
57368: DOUBLE
57369: EQUAL
57370: IFTRUE 57374
57372: GO 57400
57374: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
57375: LD_ADDR_VAR 0 3
57379: PUSH
57380: LD_INT 21
57382: PUSH
57383: LD_INT 22
57385: PUSH
57386: LD_INT 23
57388: PUSH
57389: LD_INT 24
57391: PUSH
57392: EMPTY
57393: LIST
57394: LIST
57395: LIST
57396: LIST
57397: ST_TO_ADDR
57398: GO 57683
57400: LD_INT 43
57402: DOUBLE
57403: EQUAL
57404: IFTRUE 57408
57406: GO 57434
57408: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
57409: LD_ADDR_VAR 0 3
57413: PUSH
57414: LD_INT 21
57416: PUSH
57417: LD_INT 22
57419: PUSH
57420: LD_INT 23
57422: PUSH
57423: LD_INT 24
57425: PUSH
57426: EMPTY
57427: LIST
57428: LIST
57429: LIST
57430: LIST
57431: ST_TO_ADDR
57432: GO 57683
57434: LD_INT 44
57436: DOUBLE
57437: EQUAL
57438: IFTRUE 57442
57440: GO 57468
57442: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
57443: LD_ADDR_VAR 0 3
57447: PUSH
57448: LD_INT 21
57450: PUSH
57451: LD_INT 22
57453: PUSH
57454: LD_INT 23
57456: PUSH
57457: LD_INT 24
57459: PUSH
57460: EMPTY
57461: LIST
57462: LIST
57463: LIST
57464: LIST
57465: ST_TO_ADDR
57466: GO 57683
57468: LD_INT 45
57470: DOUBLE
57471: EQUAL
57472: IFTRUE 57476
57474: GO 57502
57476: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57477: LD_ADDR_VAR 0 3
57481: PUSH
57482: LD_INT 21
57484: PUSH
57485: LD_INT 22
57487: PUSH
57488: LD_INT 23
57490: PUSH
57491: LD_INT 24
57493: PUSH
57494: EMPTY
57495: LIST
57496: LIST
57497: LIST
57498: LIST
57499: ST_TO_ADDR
57500: GO 57683
57502: LD_INT 49
57504: DOUBLE
57505: EQUAL
57506: IFTRUE 57510
57508: GO 57536
57510: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57511: LD_ADDR_VAR 0 3
57515: PUSH
57516: LD_INT 21
57518: PUSH
57519: LD_INT 22
57521: PUSH
57522: LD_INT 23
57524: PUSH
57525: LD_INT 24
57527: PUSH
57528: EMPTY
57529: LIST
57530: LIST
57531: LIST
57532: LIST
57533: ST_TO_ADDR
57534: GO 57683
57536: LD_INT 51
57538: DOUBLE
57539: EQUAL
57540: IFTRUE 57544
57542: GO 57570
57544: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57545: LD_ADDR_VAR 0 3
57549: PUSH
57550: LD_INT 21
57552: PUSH
57553: LD_INT 22
57555: PUSH
57556: LD_INT 23
57558: PUSH
57559: LD_INT 24
57561: PUSH
57562: EMPTY
57563: LIST
57564: LIST
57565: LIST
57566: LIST
57567: ST_TO_ADDR
57568: GO 57683
57570: LD_INT 52
57572: DOUBLE
57573: EQUAL
57574: IFTRUE 57578
57576: GO 57604
57578: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57579: LD_ADDR_VAR 0 3
57583: PUSH
57584: LD_INT 21
57586: PUSH
57587: LD_INT 22
57589: PUSH
57590: LD_INT 23
57592: PUSH
57593: LD_INT 24
57595: PUSH
57596: EMPTY
57597: LIST
57598: LIST
57599: LIST
57600: LIST
57601: ST_TO_ADDR
57602: GO 57683
57604: LD_INT 53
57606: DOUBLE
57607: EQUAL
57608: IFTRUE 57612
57610: GO 57630
57612: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57613: LD_ADDR_VAR 0 3
57617: PUSH
57618: LD_INT 23
57620: PUSH
57621: LD_INT 24
57623: PUSH
57624: EMPTY
57625: LIST
57626: LIST
57627: ST_TO_ADDR
57628: GO 57683
57630: LD_INT 46
57632: DOUBLE
57633: EQUAL
57634: IFTRUE 57638
57636: GO 57656
57638: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57639: LD_ADDR_VAR 0 3
57643: PUSH
57644: LD_INT 23
57646: PUSH
57647: LD_INT 24
57649: PUSH
57650: EMPTY
57651: LIST
57652: LIST
57653: ST_TO_ADDR
57654: GO 57683
57656: LD_INT 47
57658: DOUBLE
57659: EQUAL
57660: IFTRUE 57664
57662: GO 57682
57664: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57665: LD_ADDR_VAR 0 3
57669: PUSH
57670: LD_INT 23
57672: PUSH
57673: LD_INT 24
57675: PUSH
57676: EMPTY
57677: LIST
57678: LIST
57679: ST_TO_ADDR
57680: GO 57683
57682: POP
// result := ( chassis in result ) ;
57683: LD_ADDR_VAR 0 3
57687: PUSH
57688: LD_VAR 0 1
57692: PUSH
57693: LD_VAR 0 3
57697: IN
57698: ST_TO_ADDR
// end ;
57699: LD_VAR 0 3
57703: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57704: LD_INT 0
57706: PPUSH
57707: PPUSH
57708: PPUSH
57709: PPUSH
57710: PPUSH
57711: PPUSH
57712: PPUSH
// result := array ;
57713: LD_ADDR_VAR 0 5
57717: PUSH
57718: LD_VAR 0 1
57722: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57723: LD_VAR 0 1
57727: NOT
57728: PUSH
57729: LD_VAR 0 2
57733: NOT
57734: OR
57735: PUSH
57736: LD_VAR 0 3
57740: NOT
57741: OR
57742: PUSH
57743: LD_VAR 0 2
57747: PUSH
57748: LD_VAR 0 1
57752: GREATER
57753: OR
57754: PUSH
57755: LD_VAR 0 3
57759: PUSH
57760: LD_VAR 0 1
57764: GREATER
57765: OR
57766: IFFALSE 57770
// exit ;
57768: GO 58066
// if direction then
57770: LD_VAR 0 4
57774: IFFALSE 57838
// begin d := 1 ;
57776: LD_ADDR_VAR 0 9
57780: PUSH
57781: LD_INT 1
57783: ST_TO_ADDR
// if i_from > i_to then
57784: LD_VAR 0 2
57788: PUSH
57789: LD_VAR 0 3
57793: GREATER
57794: IFFALSE 57820
// length := ( array - i_from ) + i_to else
57796: LD_ADDR_VAR 0 11
57800: PUSH
57801: LD_VAR 0 1
57805: PUSH
57806: LD_VAR 0 2
57810: MINUS
57811: PUSH
57812: LD_VAR 0 3
57816: PLUS
57817: ST_TO_ADDR
57818: GO 57836
// length := i_to - i_from ;
57820: LD_ADDR_VAR 0 11
57824: PUSH
57825: LD_VAR 0 3
57829: PUSH
57830: LD_VAR 0 2
57834: MINUS
57835: ST_TO_ADDR
// end else
57836: GO 57899
// begin d := - 1 ;
57838: LD_ADDR_VAR 0 9
57842: PUSH
57843: LD_INT 1
57845: NEG
57846: ST_TO_ADDR
// if i_from > i_to then
57847: LD_VAR 0 2
57851: PUSH
57852: LD_VAR 0 3
57856: GREATER
57857: IFFALSE 57877
// length := i_from - i_to else
57859: LD_ADDR_VAR 0 11
57863: PUSH
57864: LD_VAR 0 2
57868: PUSH
57869: LD_VAR 0 3
57873: MINUS
57874: ST_TO_ADDR
57875: GO 57899
// length := ( array - i_to ) + i_from ;
57877: LD_ADDR_VAR 0 11
57881: PUSH
57882: LD_VAR 0 1
57886: PUSH
57887: LD_VAR 0 3
57891: MINUS
57892: PUSH
57893: LD_VAR 0 2
57897: PLUS
57898: ST_TO_ADDR
// end ; if not length then
57899: LD_VAR 0 11
57903: NOT
57904: IFFALSE 57908
// exit ;
57906: GO 58066
// tmp := array ;
57908: LD_ADDR_VAR 0 10
57912: PUSH
57913: LD_VAR 0 1
57917: ST_TO_ADDR
// for i = 1 to length do
57918: LD_ADDR_VAR 0 6
57922: PUSH
57923: DOUBLE
57924: LD_INT 1
57926: DEC
57927: ST_TO_ADDR
57928: LD_VAR 0 11
57932: PUSH
57933: FOR_TO
57934: IFFALSE 58054
// begin for j = 1 to array do
57936: LD_ADDR_VAR 0 7
57940: PUSH
57941: DOUBLE
57942: LD_INT 1
57944: DEC
57945: ST_TO_ADDR
57946: LD_VAR 0 1
57950: PUSH
57951: FOR_TO
57952: IFFALSE 58040
// begin k := j + d ;
57954: LD_ADDR_VAR 0 8
57958: PUSH
57959: LD_VAR 0 7
57963: PUSH
57964: LD_VAR 0 9
57968: PLUS
57969: ST_TO_ADDR
// if k > array then
57970: LD_VAR 0 8
57974: PUSH
57975: LD_VAR 0 1
57979: GREATER
57980: IFFALSE 57990
// k := 1 ;
57982: LD_ADDR_VAR 0 8
57986: PUSH
57987: LD_INT 1
57989: ST_TO_ADDR
// if not k then
57990: LD_VAR 0 8
57994: NOT
57995: IFFALSE 58007
// k := array ;
57997: LD_ADDR_VAR 0 8
58001: PUSH
58002: LD_VAR 0 1
58006: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
58007: LD_ADDR_VAR 0 10
58011: PUSH
58012: LD_VAR 0 10
58016: PPUSH
58017: LD_VAR 0 8
58021: PPUSH
58022: LD_VAR 0 1
58026: PUSH
58027: LD_VAR 0 7
58031: ARRAY
58032: PPUSH
58033: CALL_OW 1
58037: ST_TO_ADDR
// end ;
58038: GO 57951
58040: POP
58041: POP
// array := tmp ;
58042: LD_ADDR_VAR 0 1
58046: PUSH
58047: LD_VAR 0 10
58051: ST_TO_ADDR
// end ;
58052: GO 57933
58054: POP
58055: POP
// result := array ;
58056: LD_ADDR_VAR 0 5
58060: PUSH
58061: LD_VAR 0 1
58065: ST_TO_ADDR
// end ;
58066: LD_VAR 0 5
58070: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
58071: LD_INT 0
58073: PPUSH
58074: PPUSH
// result := 0 ;
58075: LD_ADDR_VAR 0 3
58079: PUSH
58080: LD_INT 0
58082: ST_TO_ADDR
// if not array or not value in array then
58083: LD_VAR 0 1
58087: NOT
58088: PUSH
58089: LD_VAR 0 2
58093: PUSH
58094: LD_VAR 0 1
58098: IN
58099: NOT
58100: OR
58101: IFFALSE 58105
// exit ;
58103: GO 58159
// for i = 1 to array do
58105: LD_ADDR_VAR 0 4
58109: PUSH
58110: DOUBLE
58111: LD_INT 1
58113: DEC
58114: ST_TO_ADDR
58115: LD_VAR 0 1
58119: PUSH
58120: FOR_TO
58121: IFFALSE 58157
// if value = array [ i ] then
58123: LD_VAR 0 2
58127: PUSH
58128: LD_VAR 0 1
58132: PUSH
58133: LD_VAR 0 4
58137: ARRAY
58138: EQUAL
58139: IFFALSE 58155
// begin result := i ;
58141: LD_ADDR_VAR 0 3
58145: PUSH
58146: LD_VAR 0 4
58150: ST_TO_ADDR
// exit ;
58151: POP
58152: POP
58153: GO 58159
// end ;
58155: GO 58120
58157: POP
58158: POP
// end ;
58159: LD_VAR 0 3
58163: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
58164: LD_INT 0
58166: PPUSH
// vc_chassis := chassis ;
58167: LD_ADDR_OWVAR 37
58171: PUSH
58172: LD_VAR 0 1
58176: ST_TO_ADDR
// vc_engine := engine ;
58177: LD_ADDR_OWVAR 39
58181: PUSH
58182: LD_VAR 0 2
58186: ST_TO_ADDR
// vc_control := control ;
58187: LD_ADDR_OWVAR 38
58191: PUSH
58192: LD_VAR 0 3
58196: ST_TO_ADDR
// vc_weapon := weapon ;
58197: LD_ADDR_OWVAR 40
58201: PUSH
58202: LD_VAR 0 4
58206: ST_TO_ADDR
// vc_fuel_battery := fuel ;
58207: LD_ADDR_OWVAR 41
58211: PUSH
58212: LD_VAR 0 5
58216: ST_TO_ADDR
// end ;
58217: LD_VAR 0 6
58221: RET
// export function WantPlant ( unit ) ; var task ; begin
58222: LD_INT 0
58224: PPUSH
58225: PPUSH
// result := false ;
58226: LD_ADDR_VAR 0 2
58230: PUSH
58231: LD_INT 0
58233: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
58234: LD_ADDR_VAR 0 3
58238: PUSH
58239: LD_VAR 0 1
58243: PPUSH
58244: CALL_OW 437
58248: ST_TO_ADDR
// if task then
58249: LD_VAR 0 3
58253: IFFALSE 58281
// if task [ 1 ] [ 1 ] = p then
58255: LD_VAR 0 3
58259: PUSH
58260: LD_INT 1
58262: ARRAY
58263: PUSH
58264: LD_INT 1
58266: ARRAY
58267: PUSH
58268: LD_STRING p
58270: EQUAL
58271: IFFALSE 58281
// result := true ;
58273: LD_ADDR_VAR 0 2
58277: PUSH
58278: LD_INT 1
58280: ST_TO_ADDR
// end ;
58281: LD_VAR 0 2
58285: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
58286: LD_INT 0
58288: PPUSH
58289: PPUSH
58290: PPUSH
58291: PPUSH
// if pos < 1 then
58292: LD_VAR 0 2
58296: PUSH
58297: LD_INT 1
58299: LESS
58300: IFFALSE 58304
// exit ;
58302: GO 58607
// if pos = 1 then
58304: LD_VAR 0 2
58308: PUSH
58309: LD_INT 1
58311: EQUAL
58312: IFFALSE 58345
// result := Replace ( arr , pos [ 1 ] , value ) else
58314: LD_ADDR_VAR 0 4
58318: PUSH
58319: LD_VAR 0 1
58323: PPUSH
58324: LD_VAR 0 2
58328: PUSH
58329: LD_INT 1
58331: ARRAY
58332: PPUSH
58333: LD_VAR 0 3
58337: PPUSH
58338: CALL_OW 1
58342: ST_TO_ADDR
58343: GO 58607
// begin tmp := arr ;
58345: LD_ADDR_VAR 0 6
58349: PUSH
58350: LD_VAR 0 1
58354: ST_TO_ADDR
// s_arr := [ tmp ] ;
58355: LD_ADDR_VAR 0 7
58359: PUSH
58360: LD_VAR 0 6
58364: PUSH
58365: EMPTY
58366: LIST
58367: ST_TO_ADDR
// for i = 1 to pos - 1 do
58368: LD_ADDR_VAR 0 5
58372: PUSH
58373: DOUBLE
58374: LD_INT 1
58376: DEC
58377: ST_TO_ADDR
58378: LD_VAR 0 2
58382: PUSH
58383: LD_INT 1
58385: MINUS
58386: PUSH
58387: FOR_TO
58388: IFFALSE 58433
// begin tmp := tmp [ pos [ i ] ] ;
58390: LD_ADDR_VAR 0 6
58394: PUSH
58395: LD_VAR 0 6
58399: PUSH
58400: LD_VAR 0 2
58404: PUSH
58405: LD_VAR 0 5
58409: ARRAY
58410: ARRAY
58411: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
58412: LD_ADDR_VAR 0 7
58416: PUSH
58417: LD_VAR 0 7
58421: PUSH
58422: LD_VAR 0 6
58426: PUSH
58427: EMPTY
58428: LIST
58429: ADD
58430: ST_TO_ADDR
// end ;
58431: GO 58387
58433: POP
58434: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
58435: LD_ADDR_VAR 0 6
58439: PUSH
58440: LD_VAR 0 6
58444: PPUSH
58445: LD_VAR 0 2
58449: PUSH
58450: LD_VAR 0 2
58454: ARRAY
58455: PPUSH
58456: LD_VAR 0 3
58460: PPUSH
58461: CALL_OW 1
58465: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
58466: LD_ADDR_VAR 0 7
58470: PUSH
58471: LD_VAR 0 7
58475: PPUSH
58476: LD_VAR 0 7
58480: PPUSH
58481: LD_VAR 0 6
58485: PPUSH
58486: CALL_OW 1
58490: ST_TO_ADDR
// for i = s_arr downto 2 do
58491: LD_ADDR_VAR 0 5
58495: PUSH
58496: DOUBLE
58497: LD_VAR 0 7
58501: INC
58502: ST_TO_ADDR
58503: LD_INT 2
58505: PUSH
58506: FOR_DOWNTO
58507: IFFALSE 58591
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58509: LD_ADDR_VAR 0 6
58513: PUSH
58514: LD_VAR 0 7
58518: PUSH
58519: LD_VAR 0 5
58523: PUSH
58524: LD_INT 1
58526: MINUS
58527: ARRAY
58528: PPUSH
58529: LD_VAR 0 2
58533: PUSH
58534: LD_VAR 0 5
58538: PUSH
58539: LD_INT 1
58541: MINUS
58542: ARRAY
58543: PPUSH
58544: LD_VAR 0 7
58548: PUSH
58549: LD_VAR 0 5
58553: ARRAY
58554: PPUSH
58555: CALL_OW 1
58559: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58560: LD_ADDR_VAR 0 7
58564: PUSH
58565: LD_VAR 0 7
58569: PPUSH
58570: LD_VAR 0 5
58574: PUSH
58575: LD_INT 1
58577: MINUS
58578: PPUSH
58579: LD_VAR 0 6
58583: PPUSH
58584: CALL_OW 1
58588: ST_TO_ADDR
// end ;
58589: GO 58506
58591: POP
58592: POP
// result := s_arr [ 1 ] ;
58593: LD_ADDR_VAR 0 4
58597: PUSH
58598: LD_VAR 0 7
58602: PUSH
58603: LD_INT 1
58605: ARRAY
58606: ST_TO_ADDR
// end ; end ;
58607: LD_VAR 0 4
58611: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58612: LD_INT 0
58614: PPUSH
58615: PPUSH
// if not list then
58616: LD_VAR 0 1
58620: NOT
58621: IFFALSE 58625
// exit ;
58623: GO 58716
// i := list [ pos1 ] ;
58625: LD_ADDR_VAR 0 5
58629: PUSH
58630: LD_VAR 0 1
58634: PUSH
58635: LD_VAR 0 2
58639: ARRAY
58640: ST_TO_ADDR
// if not i then
58641: LD_VAR 0 5
58645: NOT
58646: IFFALSE 58650
// exit ;
58648: GO 58716
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58650: LD_ADDR_VAR 0 1
58654: PUSH
58655: LD_VAR 0 1
58659: PPUSH
58660: LD_VAR 0 2
58664: PPUSH
58665: LD_VAR 0 1
58669: PUSH
58670: LD_VAR 0 3
58674: ARRAY
58675: PPUSH
58676: CALL_OW 1
58680: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58681: LD_ADDR_VAR 0 1
58685: PUSH
58686: LD_VAR 0 1
58690: PPUSH
58691: LD_VAR 0 3
58695: PPUSH
58696: LD_VAR 0 5
58700: PPUSH
58701: CALL_OW 1
58705: ST_TO_ADDR
// result := list ;
58706: LD_ADDR_VAR 0 4
58710: PUSH
58711: LD_VAR 0 1
58715: ST_TO_ADDR
// end ;
58716: LD_VAR 0 4
58720: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58721: LD_INT 0
58723: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58724: LD_ADDR_VAR 0 5
58728: PUSH
58729: LD_VAR 0 1
58733: PPUSH
58734: CALL_OW 250
58738: PPUSH
58739: LD_VAR 0 1
58743: PPUSH
58744: CALL_OW 251
58748: PPUSH
58749: LD_VAR 0 2
58753: PPUSH
58754: LD_VAR 0 3
58758: PPUSH
58759: LD_VAR 0 4
58763: PPUSH
58764: CALL 59142 0 5
58768: ST_TO_ADDR
// end ;
58769: LD_VAR 0 5
58773: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
58774: LD_INT 0
58776: PPUSH
58777: PPUSH
58778: PPUSH
58779: PPUSH
// if not list or not unit then
58780: LD_VAR 0 2
58784: NOT
58785: PUSH
58786: LD_VAR 0 1
58790: NOT
58791: OR
58792: IFFALSE 58796
// exit ;
58794: GO 59137
// result := [ ] ;
58796: LD_ADDR_VAR 0 5
58800: PUSH
58801: EMPTY
58802: ST_TO_ADDR
// for i in list do
58803: LD_ADDR_VAR 0 6
58807: PUSH
58808: LD_VAR 0 2
58812: PUSH
58813: FOR_IN
58814: IFFALSE 59032
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
58816: LD_ADDR_VAR 0 8
58820: PUSH
58821: LD_VAR 0 1
58825: PPUSH
58826: LD_VAR 0 6
58830: PUSH
58831: LD_INT 1
58833: ARRAY
58834: PPUSH
58835: LD_VAR 0 6
58839: PUSH
58840: LD_INT 2
58842: ARRAY
58843: PPUSH
58844: CALL_OW 297
58848: ST_TO_ADDR
// if not Count ( result ) then
58849: LD_VAR 0 5
58853: PPUSH
58854: CALL 55426 0 1
58858: NOT
58859: IFFALSE 58892
// begin result := Join ( result , [ i , tmp ] ) ;
58861: LD_ADDR_VAR 0 5
58865: PUSH
58866: LD_VAR 0 5
58870: PPUSH
58871: LD_VAR 0 6
58875: PUSH
58876: LD_VAR 0 8
58880: PUSH
58881: EMPTY
58882: LIST
58883: LIST
58884: PPUSH
58885: CALL 91015 0 2
58889: ST_TO_ADDR
// continue ;
58890: GO 58813
// end ; if result [ result ] [ 2 ] <= tmp then
58892: LD_VAR 0 5
58896: PUSH
58897: LD_VAR 0 5
58901: ARRAY
58902: PUSH
58903: LD_INT 2
58905: ARRAY
58906: PUSH
58907: LD_VAR 0 8
58911: LESSEQUAL
58912: IFFALSE 58945
// result := Join ( result , [ i , tmp ] ) else
58914: LD_ADDR_VAR 0 5
58918: PUSH
58919: LD_VAR 0 5
58923: PPUSH
58924: LD_VAR 0 6
58928: PUSH
58929: LD_VAR 0 8
58933: PUSH
58934: EMPTY
58935: LIST
58936: LIST
58937: PPUSH
58938: CALL 91015 0 2
58942: ST_TO_ADDR
58943: GO 59030
// begin for j := 1 to Count ( result ) do
58945: LD_ADDR_VAR 0 7
58949: PUSH
58950: DOUBLE
58951: LD_INT 1
58953: DEC
58954: ST_TO_ADDR
58955: LD_VAR 0 5
58959: PPUSH
58960: CALL 55426 0 1
58964: PUSH
58965: FOR_TO
58966: IFFALSE 59028
// begin if tmp < result [ j ] [ 2 ] then
58968: LD_VAR 0 8
58972: PUSH
58973: LD_VAR 0 5
58977: PUSH
58978: LD_VAR 0 7
58982: ARRAY
58983: PUSH
58984: LD_INT 2
58986: ARRAY
58987: LESS
58988: IFFALSE 59026
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58990: LD_ADDR_VAR 0 5
58994: PUSH
58995: LD_VAR 0 5
58999: PPUSH
59000: LD_VAR 0 7
59004: PPUSH
59005: LD_VAR 0 6
59009: PUSH
59010: LD_VAR 0 8
59014: PUSH
59015: EMPTY
59016: LIST
59017: LIST
59018: PPUSH
59019: CALL_OW 2
59023: ST_TO_ADDR
// break ;
59024: GO 59028
// end ; end ;
59026: GO 58965
59028: POP
59029: POP
// end ; end ;
59030: GO 58813
59032: POP
59033: POP
// if result and not asc then
59034: LD_VAR 0 5
59038: PUSH
59039: LD_VAR 0 3
59043: NOT
59044: AND
59045: IFFALSE 59062
// result := ReverseArray ( result ) ;
59047: LD_ADDR_VAR 0 5
59051: PUSH
59052: LD_VAR 0 5
59056: PPUSH
59057: CALL 86302 0 1
59061: ST_TO_ADDR
// tmp := [ ] ;
59062: LD_ADDR_VAR 0 8
59066: PUSH
59067: EMPTY
59068: ST_TO_ADDR
// if mode then
59069: LD_VAR 0 4
59073: IFFALSE 59137
// begin for i := 1 to result do
59075: LD_ADDR_VAR 0 6
59079: PUSH
59080: DOUBLE
59081: LD_INT 1
59083: DEC
59084: ST_TO_ADDR
59085: LD_VAR 0 5
59089: PUSH
59090: FOR_TO
59091: IFFALSE 59125
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
59093: LD_ADDR_VAR 0 8
59097: PUSH
59098: LD_VAR 0 8
59102: PPUSH
59103: LD_VAR 0 5
59107: PUSH
59108: LD_VAR 0 6
59112: ARRAY
59113: PUSH
59114: LD_INT 1
59116: ARRAY
59117: PPUSH
59118: CALL 91015 0 2
59122: ST_TO_ADDR
59123: GO 59090
59125: POP
59126: POP
// result := tmp ;
59127: LD_ADDR_VAR 0 5
59131: PUSH
59132: LD_VAR 0 8
59136: ST_TO_ADDR
// end ; end ;
59137: LD_VAR 0 5
59141: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
59142: LD_INT 0
59144: PPUSH
59145: PPUSH
59146: PPUSH
59147: PPUSH
// if not list then
59148: LD_VAR 0 3
59152: NOT
59153: IFFALSE 59157
// exit ;
59155: GO 59545
// result := [ ] ;
59157: LD_ADDR_VAR 0 6
59161: PUSH
59162: EMPTY
59163: ST_TO_ADDR
// for i in list do
59164: LD_ADDR_VAR 0 7
59168: PUSH
59169: LD_VAR 0 3
59173: PUSH
59174: FOR_IN
59175: IFFALSE 59377
// begin tmp := GetDistUnitXY ( i , x , y ) ;
59177: LD_ADDR_VAR 0 9
59181: PUSH
59182: LD_VAR 0 7
59186: PPUSH
59187: LD_VAR 0 1
59191: PPUSH
59192: LD_VAR 0 2
59196: PPUSH
59197: CALL_OW 297
59201: ST_TO_ADDR
// if not result then
59202: LD_VAR 0 6
59206: NOT
59207: IFFALSE 59233
// result := [ [ i , tmp ] ] else
59209: LD_ADDR_VAR 0 6
59213: PUSH
59214: LD_VAR 0 7
59218: PUSH
59219: LD_VAR 0 9
59223: PUSH
59224: EMPTY
59225: LIST
59226: LIST
59227: PUSH
59228: EMPTY
59229: LIST
59230: ST_TO_ADDR
59231: GO 59375
// begin if result [ result ] [ 2 ] < tmp then
59233: LD_VAR 0 6
59237: PUSH
59238: LD_VAR 0 6
59242: ARRAY
59243: PUSH
59244: LD_INT 2
59246: ARRAY
59247: PUSH
59248: LD_VAR 0 9
59252: LESS
59253: IFFALSE 59295
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
59255: LD_ADDR_VAR 0 6
59259: PUSH
59260: LD_VAR 0 6
59264: PPUSH
59265: LD_VAR 0 6
59269: PUSH
59270: LD_INT 1
59272: PLUS
59273: PPUSH
59274: LD_VAR 0 7
59278: PUSH
59279: LD_VAR 0 9
59283: PUSH
59284: EMPTY
59285: LIST
59286: LIST
59287: PPUSH
59288: CALL_OW 2
59292: ST_TO_ADDR
59293: GO 59375
// for j = 1 to result do
59295: LD_ADDR_VAR 0 8
59299: PUSH
59300: DOUBLE
59301: LD_INT 1
59303: DEC
59304: ST_TO_ADDR
59305: LD_VAR 0 6
59309: PUSH
59310: FOR_TO
59311: IFFALSE 59373
// begin if tmp < result [ j ] [ 2 ] then
59313: LD_VAR 0 9
59317: PUSH
59318: LD_VAR 0 6
59322: PUSH
59323: LD_VAR 0 8
59327: ARRAY
59328: PUSH
59329: LD_INT 2
59331: ARRAY
59332: LESS
59333: IFFALSE 59371
// begin result := Insert ( result , j , [ i , tmp ] ) ;
59335: LD_ADDR_VAR 0 6
59339: PUSH
59340: LD_VAR 0 6
59344: PPUSH
59345: LD_VAR 0 8
59349: PPUSH
59350: LD_VAR 0 7
59354: PUSH
59355: LD_VAR 0 9
59359: PUSH
59360: EMPTY
59361: LIST
59362: LIST
59363: PPUSH
59364: CALL_OW 2
59368: ST_TO_ADDR
// break ;
59369: GO 59373
// end ; end ;
59371: GO 59310
59373: POP
59374: POP
// end ; end ;
59375: GO 59174
59377: POP
59378: POP
// if result and not asc then
59379: LD_VAR 0 6
59383: PUSH
59384: LD_VAR 0 4
59388: NOT
59389: AND
59390: IFFALSE 59465
// begin tmp := result ;
59392: LD_ADDR_VAR 0 9
59396: PUSH
59397: LD_VAR 0 6
59401: ST_TO_ADDR
// for i = tmp downto 1 do
59402: LD_ADDR_VAR 0 7
59406: PUSH
59407: DOUBLE
59408: LD_VAR 0 9
59412: INC
59413: ST_TO_ADDR
59414: LD_INT 1
59416: PUSH
59417: FOR_DOWNTO
59418: IFFALSE 59463
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
59420: LD_ADDR_VAR 0 6
59424: PUSH
59425: LD_VAR 0 6
59429: PPUSH
59430: LD_VAR 0 9
59434: PUSH
59435: LD_VAR 0 7
59439: MINUS
59440: PUSH
59441: LD_INT 1
59443: PLUS
59444: PPUSH
59445: LD_VAR 0 9
59449: PUSH
59450: LD_VAR 0 7
59454: ARRAY
59455: PPUSH
59456: CALL_OW 1
59460: ST_TO_ADDR
59461: GO 59417
59463: POP
59464: POP
// end ; tmp := [ ] ;
59465: LD_ADDR_VAR 0 9
59469: PUSH
59470: EMPTY
59471: ST_TO_ADDR
// if mode then
59472: LD_VAR 0 5
59476: IFFALSE 59545
// begin for i = 1 to result do
59478: LD_ADDR_VAR 0 7
59482: PUSH
59483: DOUBLE
59484: LD_INT 1
59486: DEC
59487: ST_TO_ADDR
59488: LD_VAR 0 6
59492: PUSH
59493: FOR_TO
59494: IFFALSE 59533
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
59496: LD_ADDR_VAR 0 9
59500: PUSH
59501: LD_VAR 0 9
59505: PPUSH
59506: LD_VAR 0 7
59510: PPUSH
59511: LD_VAR 0 6
59515: PUSH
59516: LD_VAR 0 7
59520: ARRAY
59521: PUSH
59522: LD_INT 1
59524: ARRAY
59525: PPUSH
59526: CALL_OW 1
59530: ST_TO_ADDR
59531: GO 59493
59533: POP
59534: POP
// result := tmp ;
59535: LD_ADDR_VAR 0 6
59539: PUSH
59540: LD_VAR 0 9
59544: ST_TO_ADDR
// end ; end ;
59545: LD_VAR 0 6
59549: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
59550: LD_INT 0
59552: PPUSH
59553: PPUSH
59554: PPUSH
59555: PPUSH
59556: PPUSH
59557: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
59558: LD_ADDR_VAR 0 5
59562: PUSH
59563: LD_INT 0
59565: PUSH
59566: LD_INT 0
59568: PUSH
59569: LD_INT 0
59571: PUSH
59572: EMPTY
59573: PUSH
59574: EMPTY
59575: LIST
59576: LIST
59577: LIST
59578: LIST
59579: ST_TO_ADDR
// if not x or not y then
59580: LD_VAR 0 2
59584: NOT
59585: PUSH
59586: LD_VAR 0 3
59590: NOT
59591: OR
59592: IFFALSE 59596
// exit ;
59594: GO 61246
// if not range then
59596: LD_VAR 0 4
59600: NOT
59601: IFFALSE 59611
// range := 10 ;
59603: LD_ADDR_VAR 0 4
59607: PUSH
59608: LD_INT 10
59610: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
59611: LD_ADDR_VAR 0 8
59615: PUSH
59616: LD_INT 81
59618: PUSH
59619: LD_VAR 0 1
59623: PUSH
59624: EMPTY
59625: LIST
59626: LIST
59627: PUSH
59628: LD_INT 92
59630: PUSH
59631: LD_VAR 0 2
59635: PUSH
59636: LD_VAR 0 3
59640: PUSH
59641: LD_VAR 0 4
59645: PUSH
59646: EMPTY
59647: LIST
59648: LIST
59649: LIST
59650: LIST
59651: PUSH
59652: LD_INT 3
59654: PUSH
59655: LD_INT 21
59657: PUSH
59658: LD_INT 3
59660: PUSH
59661: EMPTY
59662: LIST
59663: LIST
59664: PUSH
59665: EMPTY
59666: LIST
59667: LIST
59668: PUSH
59669: EMPTY
59670: LIST
59671: LIST
59672: LIST
59673: PPUSH
59674: CALL_OW 69
59678: ST_TO_ADDR
// if not tmp then
59679: LD_VAR 0 8
59683: NOT
59684: IFFALSE 59688
// exit ;
59686: GO 61246
// for i in tmp do
59688: LD_ADDR_VAR 0 6
59692: PUSH
59693: LD_VAR 0 8
59697: PUSH
59698: FOR_IN
59699: IFFALSE 61221
// begin points := [ 0 , 0 , 0 ] ;
59701: LD_ADDR_VAR 0 9
59705: PUSH
59706: LD_INT 0
59708: PUSH
59709: LD_INT 0
59711: PUSH
59712: LD_INT 0
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: LIST
59719: ST_TO_ADDR
// bpoints := 1 ;
59720: LD_ADDR_VAR 0 10
59724: PUSH
59725: LD_INT 1
59727: ST_TO_ADDR
// case GetType ( i ) of unit_human :
59728: LD_VAR 0 6
59732: PPUSH
59733: CALL_OW 247
59737: PUSH
59738: LD_INT 1
59740: DOUBLE
59741: EQUAL
59742: IFTRUE 59746
59744: GO 60324
59746: POP
// begin if GetClass ( i ) = 1 then
59747: LD_VAR 0 6
59751: PPUSH
59752: CALL_OW 257
59756: PUSH
59757: LD_INT 1
59759: EQUAL
59760: IFFALSE 59781
// points := [ 10 , 5 , 3 ] ;
59762: LD_ADDR_VAR 0 9
59766: PUSH
59767: LD_INT 10
59769: PUSH
59770: LD_INT 5
59772: PUSH
59773: LD_INT 3
59775: PUSH
59776: EMPTY
59777: LIST
59778: LIST
59779: LIST
59780: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
59781: LD_VAR 0 6
59785: PPUSH
59786: CALL_OW 257
59790: PUSH
59791: LD_INT 2
59793: PUSH
59794: LD_INT 3
59796: PUSH
59797: LD_INT 4
59799: PUSH
59800: EMPTY
59801: LIST
59802: LIST
59803: LIST
59804: IN
59805: IFFALSE 59826
// points := [ 3 , 2 , 1 ] ;
59807: LD_ADDR_VAR 0 9
59811: PUSH
59812: LD_INT 3
59814: PUSH
59815: LD_INT 2
59817: PUSH
59818: LD_INT 1
59820: PUSH
59821: EMPTY
59822: LIST
59823: LIST
59824: LIST
59825: ST_TO_ADDR
// if GetClass ( i ) = 5 then
59826: LD_VAR 0 6
59830: PPUSH
59831: CALL_OW 257
59835: PUSH
59836: LD_INT 5
59838: EQUAL
59839: IFFALSE 59860
// points := [ 130 , 5 , 2 ] ;
59841: LD_ADDR_VAR 0 9
59845: PUSH
59846: LD_INT 130
59848: PUSH
59849: LD_INT 5
59851: PUSH
59852: LD_INT 2
59854: PUSH
59855: EMPTY
59856: LIST
59857: LIST
59858: LIST
59859: ST_TO_ADDR
// if GetClass ( i ) = 8 then
59860: LD_VAR 0 6
59864: PPUSH
59865: CALL_OW 257
59869: PUSH
59870: LD_INT 8
59872: EQUAL
59873: IFFALSE 59894
// points := [ 35 , 35 , 30 ] ;
59875: LD_ADDR_VAR 0 9
59879: PUSH
59880: LD_INT 35
59882: PUSH
59883: LD_INT 35
59885: PUSH
59886: LD_INT 30
59888: PUSH
59889: EMPTY
59890: LIST
59891: LIST
59892: LIST
59893: ST_TO_ADDR
// if GetClass ( i ) = 9 then
59894: LD_VAR 0 6
59898: PPUSH
59899: CALL_OW 257
59903: PUSH
59904: LD_INT 9
59906: EQUAL
59907: IFFALSE 59928
// points := [ 20 , 55 , 40 ] ;
59909: LD_ADDR_VAR 0 9
59913: PUSH
59914: LD_INT 20
59916: PUSH
59917: LD_INT 55
59919: PUSH
59920: LD_INT 40
59922: PUSH
59923: EMPTY
59924: LIST
59925: LIST
59926: LIST
59927: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59928: LD_VAR 0 6
59932: PPUSH
59933: CALL_OW 257
59937: PUSH
59938: LD_INT 12
59940: PUSH
59941: LD_INT 16
59943: PUSH
59944: EMPTY
59945: LIST
59946: LIST
59947: IN
59948: IFFALSE 59969
// points := [ 5 , 3 , 2 ] ;
59950: LD_ADDR_VAR 0 9
59954: PUSH
59955: LD_INT 5
59957: PUSH
59958: LD_INT 3
59960: PUSH
59961: LD_INT 2
59963: PUSH
59964: EMPTY
59965: LIST
59966: LIST
59967: LIST
59968: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59969: LD_VAR 0 6
59973: PPUSH
59974: CALL_OW 257
59978: PUSH
59979: LD_INT 17
59981: EQUAL
59982: IFFALSE 60003
// points := [ 100 , 50 , 75 ] ;
59984: LD_ADDR_VAR 0 9
59988: PUSH
59989: LD_INT 100
59991: PUSH
59992: LD_INT 50
59994: PUSH
59995: LD_INT 75
59997: PUSH
59998: EMPTY
59999: LIST
60000: LIST
60001: LIST
60002: ST_TO_ADDR
// if GetClass ( i ) = 15 then
60003: LD_VAR 0 6
60007: PPUSH
60008: CALL_OW 257
60012: PUSH
60013: LD_INT 15
60015: EQUAL
60016: IFFALSE 60037
// points := [ 10 , 5 , 3 ] ;
60018: LD_ADDR_VAR 0 9
60022: PUSH
60023: LD_INT 10
60025: PUSH
60026: LD_INT 5
60028: PUSH
60029: LD_INT 3
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: LIST
60036: ST_TO_ADDR
// if GetClass ( i ) = 14 then
60037: LD_VAR 0 6
60041: PPUSH
60042: CALL_OW 257
60046: PUSH
60047: LD_INT 14
60049: EQUAL
60050: IFFALSE 60071
// points := [ 10 , 0 , 0 ] ;
60052: LD_ADDR_VAR 0 9
60056: PUSH
60057: LD_INT 10
60059: PUSH
60060: LD_INT 0
60062: PUSH
60063: LD_INT 0
60065: PUSH
60066: EMPTY
60067: LIST
60068: LIST
60069: LIST
60070: ST_TO_ADDR
// if GetClass ( i ) = 11 then
60071: LD_VAR 0 6
60075: PPUSH
60076: CALL_OW 257
60080: PUSH
60081: LD_INT 11
60083: EQUAL
60084: IFFALSE 60105
// points := [ 30 , 10 , 5 ] ;
60086: LD_ADDR_VAR 0 9
60090: PUSH
60091: LD_INT 30
60093: PUSH
60094: LD_INT 10
60096: PUSH
60097: LD_INT 5
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: LIST
60104: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
60105: LD_VAR 0 1
60109: PPUSH
60110: LD_INT 5
60112: PPUSH
60113: CALL_OW 321
60117: PUSH
60118: LD_INT 2
60120: EQUAL
60121: IFFALSE 60138
// bpoints := bpoints * 1.8 ;
60123: LD_ADDR_VAR 0 10
60127: PUSH
60128: LD_VAR 0 10
60132: PUSH
60133: LD_REAL  1.80000000000000E+0000
60136: MUL
60137: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
60138: LD_VAR 0 6
60142: PPUSH
60143: CALL_OW 257
60147: PUSH
60148: LD_INT 1
60150: PUSH
60151: LD_INT 2
60153: PUSH
60154: LD_INT 3
60156: PUSH
60157: LD_INT 4
60159: PUSH
60160: EMPTY
60161: LIST
60162: LIST
60163: LIST
60164: LIST
60165: IN
60166: PUSH
60167: LD_VAR 0 1
60171: PPUSH
60172: LD_INT 51
60174: PPUSH
60175: CALL_OW 321
60179: PUSH
60180: LD_INT 2
60182: EQUAL
60183: AND
60184: IFFALSE 60201
// bpoints := bpoints * 1.2 ;
60186: LD_ADDR_VAR 0 10
60190: PUSH
60191: LD_VAR 0 10
60195: PUSH
60196: LD_REAL  1.20000000000000E+0000
60199: MUL
60200: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
60201: LD_VAR 0 6
60205: PPUSH
60206: CALL_OW 257
60210: PUSH
60211: LD_INT 5
60213: PUSH
60214: LD_INT 7
60216: PUSH
60217: LD_INT 9
60219: PUSH
60220: EMPTY
60221: LIST
60222: LIST
60223: LIST
60224: IN
60225: PUSH
60226: LD_VAR 0 1
60230: PPUSH
60231: LD_INT 52
60233: PPUSH
60234: CALL_OW 321
60238: PUSH
60239: LD_INT 2
60241: EQUAL
60242: AND
60243: IFFALSE 60260
// bpoints := bpoints * 1.5 ;
60245: LD_ADDR_VAR 0 10
60249: PUSH
60250: LD_VAR 0 10
60254: PUSH
60255: LD_REAL  1.50000000000000E+0000
60258: MUL
60259: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
60260: LD_VAR 0 1
60264: PPUSH
60265: LD_INT 66
60267: PPUSH
60268: CALL_OW 321
60272: PUSH
60273: LD_INT 2
60275: EQUAL
60276: IFFALSE 60293
// bpoints := bpoints * 1.1 ;
60278: LD_ADDR_VAR 0 10
60282: PUSH
60283: LD_VAR 0 10
60287: PUSH
60288: LD_REAL  1.10000000000000E+0000
60291: MUL
60292: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
60293: LD_ADDR_VAR 0 10
60297: PUSH
60298: LD_VAR 0 10
60302: PUSH
60303: LD_VAR 0 6
60307: PPUSH
60308: LD_INT 1
60310: PPUSH
60311: CALL_OW 259
60315: PUSH
60316: LD_REAL  1.15000000000000E+0000
60319: MUL
60320: MUL
60321: ST_TO_ADDR
// end ; unit_vehicle :
60322: GO 61150
60324: LD_INT 2
60326: DOUBLE
60327: EQUAL
60328: IFTRUE 60332
60330: GO 61138
60332: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
60333: LD_VAR 0 6
60337: PPUSH
60338: CALL_OW 264
60342: PUSH
60343: LD_INT 2
60345: PUSH
60346: LD_INT 42
60348: PUSH
60349: LD_INT 24
60351: PUSH
60352: EMPTY
60353: LIST
60354: LIST
60355: LIST
60356: IN
60357: IFFALSE 60378
// points := [ 25 , 5 , 3 ] ;
60359: LD_ADDR_VAR 0 9
60363: PUSH
60364: LD_INT 25
60366: PUSH
60367: LD_INT 5
60369: PUSH
60370: LD_INT 3
60372: PUSH
60373: EMPTY
60374: LIST
60375: LIST
60376: LIST
60377: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
60378: LD_VAR 0 6
60382: PPUSH
60383: CALL_OW 264
60387: PUSH
60388: LD_INT 4
60390: PUSH
60391: LD_INT 43
60393: PUSH
60394: LD_INT 25
60396: PUSH
60397: EMPTY
60398: LIST
60399: LIST
60400: LIST
60401: IN
60402: IFFALSE 60423
// points := [ 40 , 15 , 5 ] ;
60404: LD_ADDR_VAR 0 9
60408: PUSH
60409: LD_INT 40
60411: PUSH
60412: LD_INT 15
60414: PUSH
60415: LD_INT 5
60417: PUSH
60418: EMPTY
60419: LIST
60420: LIST
60421: LIST
60422: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
60423: LD_VAR 0 6
60427: PPUSH
60428: CALL_OW 264
60432: PUSH
60433: LD_INT 3
60435: PUSH
60436: LD_INT 23
60438: PUSH
60439: EMPTY
60440: LIST
60441: LIST
60442: IN
60443: IFFALSE 60464
// points := [ 7 , 25 , 8 ] ;
60445: LD_ADDR_VAR 0 9
60449: PUSH
60450: LD_INT 7
60452: PUSH
60453: LD_INT 25
60455: PUSH
60456: LD_INT 8
60458: PUSH
60459: EMPTY
60460: LIST
60461: LIST
60462: LIST
60463: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
60464: LD_VAR 0 6
60468: PPUSH
60469: CALL_OW 264
60473: PUSH
60474: LD_INT 5
60476: PUSH
60477: LD_INT 27
60479: PUSH
60480: LD_INT 44
60482: PUSH
60483: EMPTY
60484: LIST
60485: LIST
60486: LIST
60487: IN
60488: IFFALSE 60509
// points := [ 14 , 50 , 16 ] ;
60490: LD_ADDR_VAR 0 9
60494: PUSH
60495: LD_INT 14
60497: PUSH
60498: LD_INT 50
60500: PUSH
60501: LD_INT 16
60503: PUSH
60504: EMPTY
60505: LIST
60506: LIST
60507: LIST
60508: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
60509: LD_VAR 0 6
60513: PPUSH
60514: CALL_OW 264
60518: PUSH
60519: LD_INT 6
60521: PUSH
60522: LD_INT 46
60524: PUSH
60525: EMPTY
60526: LIST
60527: LIST
60528: IN
60529: IFFALSE 60550
// points := [ 32 , 120 , 70 ] ;
60531: LD_ADDR_VAR 0 9
60535: PUSH
60536: LD_INT 32
60538: PUSH
60539: LD_INT 120
60541: PUSH
60542: LD_INT 70
60544: PUSH
60545: EMPTY
60546: LIST
60547: LIST
60548: LIST
60549: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
60550: LD_VAR 0 6
60554: PPUSH
60555: CALL_OW 264
60559: PUSH
60560: LD_INT 7
60562: PUSH
60563: LD_INT 28
60565: PUSH
60566: LD_INT 45
60568: PUSH
60569: LD_INT 92
60571: PUSH
60572: EMPTY
60573: LIST
60574: LIST
60575: LIST
60576: LIST
60577: IN
60578: IFFALSE 60599
// points := [ 35 , 20 , 45 ] ;
60580: LD_ADDR_VAR 0 9
60584: PUSH
60585: LD_INT 35
60587: PUSH
60588: LD_INT 20
60590: PUSH
60591: LD_INT 45
60593: PUSH
60594: EMPTY
60595: LIST
60596: LIST
60597: LIST
60598: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
60599: LD_VAR 0 6
60603: PPUSH
60604: CALL_OW 264
60608: PUSH
60609: LD_INT 47
60611: PUSH
60612: EMPTY
60613: LIST
60614: IN
60615: IFFALSE 60636
// points := [ 67 , 45 , 75 ] ;
60617: LD_ADDR_VAR 0 9
60621: PUSH
60622: LD_INT 67
60624: PUSH
60625: LD_INT 45
60627: PUSH
60628: LD_INT 75
60630: PUSH
60631: EMPTY
60632: LIST
60633: LIST
60634: LIST
60635: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
60636: LD_VAR 0 6
60640: PPUSH
60641: CALL_OW 264
60645: PUSH
60646: LD_INT 26
60648: PUSH
60649: EMPTY
60650: LIST
60651: IN
60652: IFFALSE 60673
// points := [ 120 , 30 , 80 ] ;
60654: LD_ADDR_VAR 0 9
60658: PUSH
60659: LD_INT 120
60661: PUSH
60662: LD_INT 30
60664: PUSH
60665: LD_INT 80
60667: PUSH
60668: EMPTY
60669: LIST
60670: LIST
60671: LIST
60672: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
60673: LD_VAR 0 6
60677: PPUSH
60678: CALL_OW 264
60682: PUSH
60683: LD_INT 22
60685: PUSH
60686: EMPTY
60687: LIST
60688: IN
60689: IFFALSE 60710
// points := [ 40 , 1 , 1 ] ;
60691: LD_ADDR_VAR 0 9
60695: PUSH
60696: LD_INT 40
60698: PUSH
60699: LD_INT 1
60701: PUSH
60702: LD_INT 1
60704: PUSH
60705: EMPTY
60706: LIST
60707: LIST
60708: LIST
60709: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
60710: LD_VAR 0 6
60714: PPUSH
60715: CALL_OW 264
60719: PUSH
60720: LD_INT 29
60722: PUSH
60723: EMPTY
60724: LIST
60725: IN
60726: IFFALSE 60747
// points := [ 70 , 200 , 400 ] ;
60728: LD_ADDR_VAR 0 9
60732: PUSH
60733: LD_INT 70
60735: PUSH
60736: LD_INT 200
60738: PUSH
60739: LD_INT 400
60741: PUSH
60742: EMPTY
60743: LIST
60744: LIST
60745: LIST
60746: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
60747: LD_VAR 0 6
60751: PPUSH
60752: CALL_OW 264
60756: PUSH
60757: LD_INT 14
60759: PUSH
60760: LD_INT 53
60762: PUSH
60763: EMPTY
60764: LIST
60765: LIST
60766: IN
60767: IFFALSE 60788
// points := [ 40 , 10 , 20 ] ;
60769: LD_ADDR_VAR 0 9
60773: PUSH
60774: LD_INT 40
60776: PUSH
60777: LD_INT 10
60779: PUSH
60780: LD_INT 20
60782: PUSH
60783: EMPTY
60784: LIST
60785: LIST
60786: LIST
60787: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
60788: LD_VAR 0 6
60792: PPUSH
60793: CALL_OW 264
60797: PUSH
60798: LD_INT 9
60800: PUSH
60801: EMPTY
60802: LIST
60803: IN
60804: IFFALSE 60825
// points := [ 5 , 70 , 20 ] ;
60806: LD_ADDR_VAR 0 9
60810: PUSH
60811: LD_INT 5
60813: PUSH
60814: LD_INT 70
60816: PUSH
60817: LD_INT 20
60819: PUSH
60820: EMPTY
60821: LIST
60822: LIST
60823: LIST
60824: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
60825: LD_VAR 0 6
60829: PPUSH
60830: CALL_OW 264
60834: PUSH
60835: LD_INT 10
60837: PUSH
60838: EMPTY
60839: LIST
60840: IN
60841: IFFALSE 60862
// points := [ 35 , 110 , 70 ] ;
60843: LD_ADDR_VAR 0 9
60847: PUSH
60848: LD_INT 35
60850: PUSH
60851: LD_INT 110
60853: PUSH
60854: LD_INT 70
60856: PUSH
60857: EMPTY
60858: LIST
60859: LIST
60860: LIST
60861: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
60862: LD_VAR 0 6
60866: PPUSH
60867: CALL_OW 265
60871: PUSH
60872: LD_INT 25
60874: EQUAL
60875: IFFALSE 60896
// points := [ 80 , 65 , 100 ] ;
60877: LD_ADDR_VAR 0 9
60881: PUSH
60882: LD_INT 80
60884: PUSH
60885: LD_INT 65
60887: PUSH
60888: LD_INT 100
60890: PUSH
60891: EMPTY
60892: LIST
60893: LIST
60894: LIST
60895: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
60896: LD_VAR 0 6
60900: PPUSH
60901: CALL_OW 263
60905: PUSH
60906: LD_INT 1
60908: EQUAL
60909: IFFALSE 60944
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
60911: LD_ADDR_VAR 0 10
60915: PUSH
60916: LD_VAR 0 10
60920: PUSH
60921: LD_VAR 0 6
60925: PPUSH
60926: CALL_OW 311
60930: PPUSH
60931: LD_INT 3
60933: PPUSH
60934: CALL_OW 259
60938: PUSH
60939: LD_INT 4
60941: MUL
60942: MUL
60943: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60944: LD_VAR 0 6
60948: PPUSH
60949: CALL_OW 263
60953: PUSH
60954: LD_INT 2
60956: EQUAL
60957: IFFALSE 61008
// begin j := IsControledBy ( i ) ;
60959: LD_ADDR_VAR 0 7
60963: PUSH
60964: LD_VAR 0 6
60968: PPUSH
60969: CALL_OW 312
60973: ST_TO_ADDR
// if j then
60974: LD_VAR 0 7
60978: IFFALSE 61008
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60980: LD_ADDR_VAR 0 10
60984: PUSH
60985: LD_VAR 0 10
60989: PUSH
60990: LD_VAR 0 7
60994: PPUSH
60995: LD_INT 3
60997: PPUSH
60998: CALL_OW 259
61002: PUSH
61003: LD_INT 3
61005: MUL
61006: MUL
61007: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
61008: LD_VAR 0 6
61012: PPUSH
61013: CALL_OW 264
61017: PUSH
61018: LD_INT 5
61020: PUSH
61021: LD_INT 6
61023: PUSH
61024: LD_INT 46
61026: PUSH
61027: LD_INT 44
61029: PUSH
61030: LD_INT 47
61032: PUSH
61033: LD_INT 45
61035: PUSH
61036: LD_INT 28
61038: PUSH
61039: LD_INT 7
61041: PUSH
61042: LD_INT 27
61044: PUSH
61045: LD_INT 29
61047: PUSH
61048: EMPTY
61049: LIST
61050: LIST
61051: LIST
61052: LIST
61053: LIST
61054: LIST
61055: LIST
61056: LIST
61057: LIST
61058: LIST
61059: IN
61060: PUSH
61061: LD_VAR 0 1
61065: PPUSH
61066: LD_INT 52
61068: PPUSH
61069: CALL_OW 321
61073: PUSH
61074: LD_INT 2
61076: EQUAL
61077: AND
61078: IFFALSE 61095
// bpoints := bpoints * 1.2 ;
61080: LD_ADDR_VAR 0 10
61084: PUSH
61085: LD_VAR 0 10
61089: PUSH
61090: LD_REAL  1.20000000000000E+0000
61093: MUL
61094: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
61095: LD_VAR 0 6
61099: PPUSH
61100: CALL_OW 264
61104: PUSH
61105: LD_INT 6
61107: PUSH
61108: LD_INT 46
61110: PUSH
61111: LD_INT 47
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: LIST
61118: IN
61119: IFFALSE 61136
// bpoints := bpoints * 1.2 ;
61121: LD_ADDR_VAR 0 10
61125: PUSH
61126: LD_VAR 0 10
61130: PUSH
61131: LD_REAL  1.20000000000000E+0000
61134: MUL
61135: ST_TO_ADDR
// end ; unit_building :
61136: GO 61150
61138: LD_INT 3
61140: DOUBLE
61141: EQUAL
61142: IFTRUE 61146
61144: GO 61149
61146: POP
// ; end ;
61147: GO 61150
61149: POP
// for j = 1 to 3 do
61150: LD_ADDR_VAR 0 7
61154: PUSH
61155: DOUBLE
61156: LD_INT 1
61158: DEC
61159: ST_TO_ADDR
61160: LD_INT 3
61162: PUSH
61163: FOR_TO
61164: IFFALSE 61217
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
61166: LD_ADDR_VAR 0 5
61170: PUSH
61171: LD_VAR 0 5
61175: PPUSH
61176: LD_VAR 0 7
61180: PPUSH
61181: LD_VAR 0 5
61185: PUSH
61186: LD_VAR 0 7
61190: ARRAY
61191: PUSH
61192: LD_VAR 0 9
61196: PUSH
61197: LD_VAR 0 7
61201: ARRAY
61202: PUSH
61203: LD_VAR 0 10
61207: MUL
61208: PLUS
61209: PPUSH
61210: CALL_OW 1
61214: ST_TO_ADDR
61215: GO 61163
61217: POP
61218: POP
// end ;
61219: GO 59698
61221: POP
61222: POP
// result := Replace ( result , 4 , tmp ) ;
61223: LD_ADDR_VAR 0 5
61227: PUSH
61228: LD_VAR 0 5
61232: PPUSH
61233: LD_INT 4
61235: PPUSH
61236: LD_VAR 0 8
61240: PPUSH
61241: CALL_OW 1
61245: ST_TO_ADDR
// end ;
61246: LD_VAR 0 5
61250: RET
// export function DangerAtRange ( unit , range ) ; begin
61251: LD_INT 0
61253: PPUSH
// if not unit then
61254: LD_VAR 0 1
61258: NOT
61259: IFFALSE 61263
// exit ;
61261: GO 61308
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
61263: LD_ADDR_VAR 0 3
61267: PUSH
61268: LD_VAR 0 1
61272: PPUSH
61273: CALL_OW 255
61277: PPUSH
61278: LD_VAR 0 1
61282: PPUSH
61283: CALL_OW 250
61287: PPUSH
61288: LD_VAR 0 1
61292: PPUSH
61293: CALL_OW 251
61297: PPUSH
61298: LD_VAR 0 2
61302: PPUSH
61303: CALL 59550 0 4
61307: ST_TO_ADDR
// end ;
61308: LD_VAR 0 3
61312: RET
// export function DangerInArea ( side , area ) ; begin
61313: LD_INT 0
61315: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
61316: LD_ADDR_VAR 0 3
61320: PUSH
61321: LD_VAR 0 2
61325: PPUSH
61326: LD_INT 81
61328: PUSH
61329: LD_VAR 0 1
61333: PUSH
61334: EMPTY
61335: LIST
61336: LIST
61337: PPUSH
61338: CALL_OW 70
61342: ST_TO_ADDR
// end ;
61343: LD_VAR 0 3
61347: RET
// export function IsExtension ( b ) ; begin
61348: LD_INT 0
61350: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
61351: LD_ADDR_VAR 0 2
61355: PUSH
61356: LD_VAR 0 1
61360: PUSH
61361: LD_INT 23
61363: PUSH
61364: LD_INT 20
61366: PUSH
61367: LD_INT 22
61369: PUSH
61370: LD_INT 17
61372: PUSH
61373: LD_INT 24
61375: PUSH
61376: LD_INT 21
61378: PUSH
61379: LD_INT 19
61381: PUSH
61382: LD_INT 16
61384: PUSH
61385: LD_INT 25
61387: PUSH
61388: LD_INT 18
61390: PUSH
61391: EMPTY
61392: LIST
61393: LIST
61394: LIST
61395: LIST
61396: LIST
61397: LIST
61398: LIST
61399: LIST
61400: LIST
61401: LIST
61402: IN
61403: ST_TO_ADDR
// end ;
61404: LD_VAR 0 2
61408: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
61409: LD_INT 0
61411: PPUSH
61412: PPUSH
61413: PPUSH
// result := [ ] ;
61414: LD_ADDR_VAR 0 4
61418: PUSH
61419: EMPTY
61420: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
61421: LD_ADDR_VAR 0 5
61425: PUSH
61426: LD_VAR 0 2
61430: PPUSH
61431: LD_INT 21
61433: PUSH
61434: LD_INT 3
61436: PUSH
61437: EMPTY
61438: LIST
61439: LIST
61440: PPUSH
61441: CALL_OW 70
61445: ST_TO_ADDR
// if not tmp then
61446: LD_VAR 0 5
61450: NOT
61451: IFFALSE 61455
// exit ;
61453: GO 61519
// if checkLink then
61455: LD_VAR 0 3
61459: IFFALSE 61509
// begin for i in tmp do
61461: LD_ADDR_VAR 0 6
61465: PUSH
61466: LD_VAR 0 5
61470: PUSH
61471: FOR_IN
61472: IFFALSE 61507
// if GetBase ( i ) <> base then
61474: LD_VAR 0 6
61478: PPUSH
61479: CALL_OW 274
61483: PUSH
61484: LD_VAR 0 1
61488: NONEQUAL
61489: IFFALSE 61505
// ComLinkToBase ( base , i ) ;
61491: LD_VAR 0 1
61495: PPUSH
61496: LD_VAR 0 6
61500: PPUSH
61501: CALL_OW 169
61505: GO 61471
61507: POP
61508: POP
// end ; result := tmp ;
61509: LD_ADDR_VAR 0 4
61513: PUSH
61514: LD_VAR 0 5
61518: ST_TO_ADDR
// end ;
61519: LD_VAR 0 4
61523: RET
// export function ComComplete ( units , b ) ; var i ; begin
61524: LD_INT 0
61526: PPUSH
61527: PPUSH
// if not units then
61528: LD_VAR 0 1
61532: NOT
61533: IFFALSE 61537
// exit ;
61535: GO 61627
// for i in units do
61537: LD_ADDR_VAR 0 4
61541: PUSH
61542: LD_VAR 0 1
61546: PUSH
61547: FOR_IN
61548: IFFALSE 61625
// if BuildingStatus ( b ) = bs_build then
61550: LD_VAR 0 2
61554: PPUSH
61555: CALL_OW 461
61559: PUSH
61560: LD_INT 1
61562: EQUAL
61563: IFFALSE 61623
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
61565: LD_VAR 0 4
61569: PPUSH
61570: LD_STRING h
61572: PUSH
61573: LD_VAR 0 2
61577: PPUSH
61578: CALL_OW 250
61582: PUSH
61583: LD_VAR 0 2
61587: PPUSH
61588: CALL_OW 251
61592: PUSH
61593: LD_VAR 0 2
61597: PUSH
61598: LD_INT 0
61600: PUSH
61601: LD_INT 0
61603: PUSH
61604: LD_INT 0
61606: PUSH
61607: EMPTY
61608: LIST
61609: LIST
61610: LIST
61611: LIST
61612: LIST
61613: LIST
61614: LIST
61615: PUSH
61616: EMPTY
61617: LIST
61618: PPUSH
61619: CALL_OW 446
61623: GO 61547
61625: POP
61626: POP
// end ;
61627: LD_VAR 0 3
61631: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
61632: LD_INT 0
61634: PPUSH
61635: PPUSH
61636: PPUSH
61637: PPUSH
61638: PPUSH
61639: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
61640: LD_VAR 0 1
61644: NOT
61645: PUSH
61646: LD_VAR 0 1
61650: PPUSH
61651: CALL_OW 263
61655: PUSH
61656: LD_INT 2
61658: NONEQUAL
61659: OR
61660: IFFALSE 61664
// exit ;
61662: GO 61980
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
61664: LD_ADDR_VAR 0 6
61668: PUSH
61669: LD_INT 22
61671: PUSH
61672: LD_VAR 0 1
61676: PPUSH
61677: CALL_OW 255
61681: PUSH
61682: EMPTY
61683: LIST
61684: LIST
61685: PUSH
61686: LD_INT 2
61688: PUSH
61689: LD_INT 30
61691: PUSH
61692: LD_INT 36
61694: PUSH
61695: EMPTY
61696: LIST
61697: LIST
61698: PUSH
61699: LD_INT 34
61701: PUSH
61702: LD_INT 31
61704: PUSH
61705: EMPTY
61706: LIST
61707: LIST
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: LIST
61713: PUSH
61714: EMPTY
61715: LIST
61716: LIST
61717: PPUSH
61718: CALL_OW 69
61722: ST_TO_ADDR
// if not tmp then
61723: LD_VAR 0 6
61727: NOT
61728: IFFALSE 61732
// exit ;
61730: GO 61980
// result := [ ] ;
61732: LD_ADDR_VAR 0 2
61736: PUSH
61737: EMPTY
61738: ST_TO_ADDR
// for i in tmp do
61739: LD_ADDR_VAR 0 3
61743: PUSH
61744: LD_VAR 0 6
61748: PUSH
61749: FOR_IN
61750: IFFALSE 61821
// begin t := UnitsInside ( i ) ;
61752: LD_ADDR_VAR 0 4
61756: PUSH
61757: LD_VAR 0 3
61761: PPUSH
61762: CALL_OW 313
61766: ST_TO_ADDR
// if t then
61767: LD_VAR 0 4
61771: IFFALSE 61819
// for j in t do
61773: LD_ADDR_VAR 0 7
61777: PUSH
61778: LD_VAR 0 4
61782: PUSH
61783: FOR_IN
61784: IFFALSE 61817
// result := Replace ( result , result + 1 , j ) ;
61786: LD_ADDR_VAR 0 2
61790: PUSH
61791: LD_VAR 0 2
61795: PPUSH
61796: LD_VAR 0 2
61800: PUSH
61801: LD_INT 1
61803: PLUS
61804: PPUSH
61805: LD_VAR 0 7
61809: PPUSH
61810: CALL_OW 1
61814: ST_TO_ADDR
61815: GO 61783
61817: POP
61818: POP
// end ;
61819: GO 61749
61821: POP
61822: POP
// if not result then
61823: LD_VAR 0 2
61827: NOT
61828: IFFALSE 61832
// exit ;
61830: GO 61980
// mech := result [ 1 ] ;
61832: LD_ADDR_VAR 0 5
61836: PUSH
61837: LD_VAR 0 2
61841: PUSH
61842: LD_INT 1
61844: ARRAY
61845: ST_TO_ADDR
// if result > 1 then
61846: LD_VAR 0 2
61850: PUSH
61851: LD_INT 1
61853: GREATER
61854: IFFALSE 61966
// begin for i = 2 to result do
61856: LD_ADDR_VAR 0 3
61860: PUSH
61861: DOUBLE
61862: LD_INT 2
61864: DEC
61865: ST_TO_ADDR
61866: LD_VAR 0 2
61870: PUSH
61871: FOR_TO
61872: IFFALSE 61964
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
61874: LD_ADDR_VAR 0 4
61878: PUSH
61879: LD_VAR 0 2
61883: PUSH
61884: LD_VAR 0 3
61888: ARRAY
61889: PPUSH
61890: LD_INT 3
61892: PPUSH
61893: CALL_OW 259
61897: PUSH
61898: LD_VAR 0 2
61902: PUSH
61903: LD_VAR 0 3
61907: ARRAY
61908: PPUSH
61909: CALL_OW 432
61913: MINUS
61914: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
61915: LD_VAR 0 4
61919: PUSH
61920: LD_VAR 0 5
61924: PPUSH
61925: LD_INT 3
61927: PPUSH
61928: CALL_OW 259
61932: PUSH
61933: LD_VAR 0 5
61937: PPUSH
61938: CALL_OW 432
61942: MINUS
61943: GREATEREQUAL
61944: IFFALSE 61962
// mech := result [ i ] ;
61946: LD_ADDR_VAR 0 5
61950: PUSH
61951: LD_VAR 0 2
61955: PUSH
61956: LD_VAR 0 3
61960: ARRAY
61961: ST_TO_ADDR
// end ;
61962: GO 61871
61964: POP
61965: POP
// end ; ComLinkTo ( vehicle , mech ) ;
61966: LD_VAR 0 1
61970: PPUSH
61971: LD_VAR 0 5
61975: PPUSH
61976: CALL_OW 135
// end ;
61980: LD_VAR 0 2
61984: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61985: LD_INT 0
61987: PPUSH
61988: PPUSH
61989: PPUSH
61990: PPUSH
61991: PPUSH
61992: PPUSH
61993: PPUSH
61994: PPUSH
61995: PPUSH
61996: PPUSH
61997: PPUSH
61998: PPUSH
61999: PPUSH
// result := [ ] ;
62000: LD_ADDR_VAR 0 7
62004: PUSH
62005: EMPTY
62006: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
62007: LD_VAR 0 1
62011: PPUSH
62012: CALL_OW 266
62016: PUSH
62017: LD_INT 0
62019: PUSH
62020: LD_INT 1
62022: PUSH
62023: EMPTY
62024: LIST
62025: LIST
62026: IN
62027: NOT
62028: IFFALSE 62032
// exit ;
62030: GO 63666
// if name then
62032: LD_VAR 0 3
62036: IFFALSE 62052
// SetBName ( base_dep , name ) ;
62038: LD_VAR 0 1
62042: PPUSH
62043: LD_VAR 0 3
62047: PPUSH
62048: CALL_OW 500
// base := GetBase ( base_dep ) ;
62052: LD_ADDR_VAR 0 15
62056: PUSH
62057: LD_VAR 0 1
62061: PPUSH
62062: CALL_OW 274
62066: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
62067: LD_ADDR_VAR 0 16
62071: PUSH
62072: LD_VAR 0 1
62076: PPUSH
62077: CALL_OW 255
62081: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
62082: LD_ADDR_VAR 0 17
62086: PUSH
62087: LD_VAR 0 1
62091: PPUSH
62092: CALL_OW 248
62096: ST_TO_ADDR
// if sources then
62097: LD_VAR 0 5
62101: IFFALSE 62148
// for i = 1 to 3 do
62103: LD_ADDR_VAR 0 8
62107: PUSH
62108: DOUBLE
62109: LD_INT 1
62111: DEC
62112: ST_TO_ADDR
62113: LD_INT 3
62115: PUSH
62116: FOR_TO
62117: IFFALSE 62146
// AddResourceType ( base , i , sources [ i ] ) ;
62119: LD_VAR 0 15
62123: PPUSH
62124: LD_VAR 0 8
62128: PPUSH
62129: LD_VAR 0 5
62133: PUSH
62134: LD_VAR 0 8
62138: ARRAY
62139: PPUSH
62140: CALL_OW 276
62144: GO 62116
62146: POP
62147: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
62148: LD_ADDR_VAR 0 18
62152: PUSH
62153: LD_VAR 0 15
62157: PPUSH
62158: LD_VAR 0 2
62162: PPUSH
62163: LD_INT 1
62165: PPUSH
62166: CALL 61409 0 3
62170: ST_TO_ADDR
// InitHc ;
62171: CALL_OW 19
// InitUc ;
62175: CALL_OW 18
// uc_side := side ;
62179: LD_ADDR_OWVAR 20
62183: PUSH
62184: LD_VAR 0 16
62188: ST_TO_ADDR
// uc_nation := nation ;
62189: LD_ADDR_OWVAR 21
62193: PUSH
62194: LD_VAR 0 17
62198: ST_TO_ADDR
// if buildings then
62199: LD_VAR 0 18
62203: IFFALSE 63525
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
62205: LD_ADDR_VAR 0 19
62209: PUSH
62210: LD_VAR 0 18
62214: PPUSH
62215: LD_INT 2
62217: PUSH
62218: LD_INT 30
62220: PUSH
62221: LD_INT 29
62223: PUSH
62224: EMPTY
62225: LIST
62226: LIST
62227: PUSH
62228: LD_INT 30
62230: PUSH
62231: LD_INT 30
62233: PUSH
62234: EMPTY
62235: LIST
62236: LIST
62237: PUSH
62238: EMPTY
62239: LIST
62240: LIST
62241: LIST
62242: PPUSH
62243: CALL_OW 72
62247: ST_TO_ADDR
// if tmp then
62248: LD_VAR 0 19
62252: IFFALSE 62300
// for i in tmp do
62254: LD_ADDR_VAR 0 8
62258: PUSH
62259: LD_VAR 0 19
62263: PUSH
62264: FOR_IN
62265: IFFALSE 62298
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
62267: LD_VAR 0 8
62271: PPUSH
62272: CALL_OW 250
62276: PPUSH
62277: LD_VAR 0 8
62281: PPUSH
62282: CALL_OW 251
62286: PPUSH
62287: LD_VAR 0 16
62291: PPUSH
62292: CALL_OW 441
62296: GO 62264
62298: POP
62299: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
62300: LD_VAR 0 18
62304: PPUSH
62305: LD_INT 2
62307: PUSH
62308: LD_INT 30
62310: PUSH
62311: LD_INT 32
62313: PUSH
62314: EMPTY
62315: LIST
62316: LIST
62317: PUSH
62318: LD_INT 30
62320: PUSH
62321: LD_INT 33
62323: PUSH
62324: EMPTY
62325: LIST
62326: LIST
62327: PUSH
62328: EMPTY
62329: LIST
62330: LIST
62331: LIST
62332: PPUSH
62333: CALL_OW 72
62337: IFFALSE 62425
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
62339: LD_ADDR_VAR 0 8
62343: PUSH
62344: LD_VAR 0 18
62348: PPUSH
62349: LD_INT 2
62351: PUSH
62352: LD_INT 30
62354: PUSH
62355: LD_INT 32
62357: PUSH
62358: EMPTY
62359: LIST
62360: LIST
62361: PUSH
62362: LD_INT 30
62364: PUSH
62365: LD_INT 33
62367: PUSH
62368: EMPTY
62369: LIST
62370: LIST
62371: PUSH
62372: EMPTY
62373: LIST
62374: LIST
62375: LIST
62376: PPUSH
62377: CALL_OW 72
62381: PUSH
62382: FOR_IN
62383: IFFALSE 62423
// begin if not GetBWeapon ( i ) then
62385: LD_VAR 0 8
62389: PPUSH
62390: CALL_OW 269
62394: NOT
62395: IFFALSE 62421
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
62397: LD_VAR 0 8
62401: PPUSH
62402: LD_VAR 0 8
62406: PPUSH
62407: LD_VAR 0 2
62411: PPUSH
62412: CALL 63671 0 2
62416: PPUSH
62417: CALL_OW 431
// end ;
62421: GO 62382
62423: POP
62424: POP
// end ; for i = 1 to personel do
62425: LD_ADDR_VAR 0 8
62429: PUSH
62430: DOUBLE
62431: LD_INT 1
62433: DEC
62434: ST_TO_ADDR
62435: LD_VAR 0 6
62439: PUSH
62440: FOR_TO
62441: IFFALSE 63505
// begin if i > 4 then
62443: LD_VAR 0 8
62447: PUSH
62448: LD_INT 4
62450: GREATER
62451: IFFALSE 62455
// break ;
62453: GO 63505
// case i of 1 :
62455: LD_VAR 0 8
62459: PUSH
62460: LD_INT 1
62462: DOUBLE
62463: EQUAL
62464: IFTRUE 62468
62466: GO 62548
62468: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
62469: LD_ADDR_VAR 0 12
62473: PUSH
62474: LD_VAR 0 18
62478: PPUSH
62479: LD_INT 22
62481: PUSH
62482: LD_VAR 0 16
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: PUSH
62491: LD_INT 58
62493: PUSH
62494: EMPTY
62495: LIST
62496: PUSH
62497: LD_INT 2
62499: PUSH
62500: LD_INT 30
62502: PUSH
62503: LD_INT 32
62505: PUSH
62506: EMPTY
62507: LIST
62508: LIST
62509: PUSH
62510: LD_INT 30
62512: PUSH
62513: LD_INT 4
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PUSH
62520: LD_INT 30
62522: PUSH
62523: LD_INT 5
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: LIST
62534: LIST
62535: PUSH
62536: EMPTY
62537: LIST
62538: LIST
62539: LIST
62540: PPUSH
62541: CALL_OW 72
62545: ST_TO_ADDR
62546: GO 62770
62548: LD_INT 2
62550: DOUBLE
62551: EQUAL
62552: IFTRUE 62556
62554: GO 62618
62556: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
62557: LD_ADDR_VAR 0 12
62561: PUSH
62562: LD_VAR 0 18
62566: PPUSH
62567: LD_INT 22
62569: PUSH
62570: LD_VAR 0 16
62574: PUSH
62575: EMPTY
62576: LIST
62577: LIST
62578: PUSH
62579: LD_INT 2
62581: PUSH
62582: LD_INT 30
62584: PUSH
62585: LD_INT 0
62587: PUSH
62588: EMPTY
62589: LIST
62590: LIST
62591: PUSH
62592: LD_INT 30
62594: PUSH
62595: LD_INT 1
62597: PUSH
62598: EMPTY
62599: LIST
62600: LIST
62601: PUSH
62602: EMPTY
62603: LIST
62604: LIST
62605: LIST
62606: PUSH
62607: EMPTY
62608: LIST
62609: LIST
62610: PPUSH
62611: CALL_OW 72
62615: ST_TO_ADDR
62616: GO 62770
62618: LD_INT 3
62620: DOUBLE
62621: EQUAL
62622: IFTRUE 62626
62624: GO 62688
62626: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
62627: LD_ADDR_VAR 0 12
62631: PUSH
62632: LD_VAR 0 18
62636: PPUSH
62637: LD_INT 22
62639: PUSH
62640: LD_VAR 0 16
62644: PUSH
62645: EMPTY
62646: LIST
62647: LIST
62648: PUSH
62649: LD_INT 2
62651: PUSH
62652: LD_INT 30
62654: PUSH
62655: LD_INT 2
62657: PUSH
62658: EMPTY
62659: LIST
62660: LIST
62661: PUSH
62662: LD_INT 30
62664: PUSH
62665: LD_INT 3
62667: PUSH
62668: EMPTY
62669: LIST
62670: LIST
62671: PUSH
62672: EMPTY
62673: LIST
62674: LIST
62675: LIST
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: PPUSH
62681: CALL_OW 72
62685: ST_TO_ADDR
62686: GO 62770
62688: LD_INT 4
62690: DOUBLE
62691: EQUAL
62692: IFTRUE 62696
62694: GO 62769
62696: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
62697: LD_ADDR_VAR 0 12
62701: PUSH
62702: LD_VAR 0 18
62706: PPUSH
62707: LD_INT 22
62709: PUSH
62710: LD_VAR 0 16
62714: PUSH
62715: EMPTY
62716: LIST
62717: LIST
62718: PUSH
62719: LD_INT 2
62721: PUSH
62722: LD_INT 30
62724: PUSH
62725: LD_INT 6
62727: PUSH
62728: EMPTY
62729: LIST
62730: LIST
62731: PUSH
62732: LD_INT 30
62734: PUSH
62735: LD_INT 7
62737: PUSH
62738: EMPTY
62739: LIST
62740: LIST
62741: PUSH
62742: LD_INT 30
62744: PUSH
62745: LD_INT 8
62747: PUSH
62748: EMPTY
62749: LIST
62750: LIST
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: LIST
62756: LIST
62757: PUSH
62758: EMPTY
62759: LIST
62760: LIST
62761: PPUSH
62762: CALL_OW 72
62766: ST_TO_ADDR
62767: GO 62770
62769: POP
// if i = 1 then
62770: LD_VAR 0 8
62774: PUSH
62775: LD_INT 1
62777: EQUAL
62778: IFFALSE 62889
// begin tmp := [ ] ;
62780: LD_ADDR_VAR 0 19
62784: PUSH
62785: EMPTY
62786: ST_TO_ADDR
// for j in f do
62787: LD_ADDR_VAR 0 9
62791: PUSH
62792: LD_VAR 0 12
62796: PUSH
62797: FOR_IN
62798: IFFALSE 62871
// if GetBType ( j ) = b_bunker then
62800: LD_VAR 0 9
62804: PPUSH
62805: CALL_OW 266
62809: PUSH
62810: LD_INT 32
62812: EQUAL
62813: IFFALSE 62840
// tmp := Insert ( tmp , 1 , j ) else
62815: LD_ADDR_VAR 0 19
62819: PUSH
62820: LD_VAR 0 19
62824: PPUSH
62825: LD_INT 1
62827: PPUSH
62828: LD_VAR 0 9
62832: PPUSH
62833: CALL_OW 2
62837: ST_TO_ADDR
62838: GO 62869
// tmp := Insert ( tmp , tmp + 1 , j ) ;
62840: LD_ADDR_VAR 0 19
62844: PUSH
62845: LD_VAR 0 19
62849: PPUSH
62850: LD_VAR 0 19
62854: PUSH
62855: LD_INT 1
62857: PLUS
62858: PPUSH
62859: LD_VAR 0 9
62863: PPUSH
62864: CALL_OW 2
62868: ST_TO_ADDR
62869: GO 62797
62871: POP
62872: POP
// if tmp then
62873: LD_VAR 0 19
62877: IFFALSE 62889
// f := tmp ;
62879: LD_ADDR_VAR 0 12
62883: PUSH
62884: LD_VAR 0 19
62888: ST_TO_ADDR
// end ; x := personel [ i ] ;
62889: LD_ADDR_VAR 0 13
62893: PUSH
62894: LD_VAR 0 6
62898: PUSH
62899: LD_VAR 0 8
62903: ARRAY
62904: ST_TO_ADDR
// if x = - 1 then
62905: LD_VAR 0 13
62909: PUSH
62910: LD_INT 1
62912: NEG
62913: EQUAL
62914: IFFALSE 63123
// begin for j in f do
62916: LD_ADDR_VAR 0 9
62920: PUSH
62921: LD_VAR 0 12
62925: PUSH
62926: FOR_IN
62927: IFFALSE 63119
// repeat InitHc ;
62929: CALL_OW 19
// if GetBType ( j ) = b_barracks then
62933: LD_VAR 0 9
62937: PPUSH
62938: CALL_OW 266
62942: PUSH
62943: LD_INT 5
62945: EQUAL
62946: IFFALSE 63016
// begin if UnitsInside ( j ) < 3 then
62948: LD_VAR 0 9
62952: PPUSH
62953: CALL_OW 313
62957: PUSH
62958: LD_INT 3
62960: LESS
62961: IFFALSE 62997
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62963: LD_INT 0
62965: PPUSH
62966: LD_INT 5
62968: PUSH
62969: LD_INT 8
62971: PUSH
62972: LD_INT 9
62974: PUSH
62975: EMPTY
62976: LIST
62977: LIST
62978: LIST
62979: PUSH
62980: LD_VAR 0 17
62984: ARRAY
62985: PPUSH
62986: LD_VAR 0 4
62990: PPUSH
62991: CALL_OW 380
62995: GO 63014
// PrepareHuman ( false , i , skill ) ;
62997: LD_INT 0
62999: PPUSH
63000: LD_VAR 0 8
63004: PPUSH
63005: LD_VAR 0 4
63009: PPUSH
63010: CALL_OW 380
// end else
63014: GO 63033
// PrepareHuman ( false , i , skill ) ;
63016: LD_INT 0
63018: PPUSH
63019: LD_VAR 0 8
63023: PPUSH
63024: LD_VAR 0 4
63028: PPUSH
63029: CALL_OW 380
// un := CreateHuman ;
63033: LD_ADDR_VAR 0 14
63037: PUSH
63038: CALL_OW 44
63042: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63043: LD_ADDR_VAR 0 7
63047: PUSH
63048: LD_VAR 0 7
63052: PPUSH
63053: LD_INT 1
63055: PPUSH
63056: LD_VAR 0 14
63060: PPUSH
63061: CALL_OW 2
63065: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
63066: LD_VAR 0 14
63070: PPUSH
63071: LD_VAR 0 9
63075: PPUSH
63076: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
63080: LD_VAR 0 9
63084: PPUSH
63085: CALL_OW 313
63089: PUSH
63090: LD_INT 6
63092: EQUAL
63093: PUSH
63094: LD_VAR 0 9
63098: PPUSH
63099: CALL_OW 266
63103: PUSH
63104: LD_INT 32
63106: PUSH
63107: LD_INT 31
63109: PUSH
63110: EMPTY
63111: LIST
63112: LIST
63113: IN
63114: OR
63115: IFFALSE 62929
63117: GO 62926
63119: POP
63120: POP
// end else
63121: GO 63503
// for j = 1 to x do
63123: LD_ADDR_VAR 0 9
63127: PUSH
63128: DOUBLE
63129: LD_INT 1
63131: DEC
63132: ST_TO_ADDR
63133: LD_VAR 0 13
63137: PUSH
63138: FOR_TO
63139: IFFALSE 63501
// begin InitHc ;
63141: CALL_OW 19
// if not f then
63145: LD_VAR 0 12
63149: NOT
63150: IFFALSE 63239
// begin PrepareHuman ( false , i , skill ) ;
63152: LD_INT 0
63154: PPUSH
63155: LD_VAR 0 8
63159: PPUSH
63160: LD_VAR 0 4
63164: PPUSH
63165: CALL_OW 380
// un := CreateHuman ;
63169: LD_ADDR_VAR 0 14
63173: PUSH
63174: CALL_OW 44
63178: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63179: LD_ADDR_VAR 0 7
63183: PUSH
63184: LD_VAR 0 7
63188: PPUSH
63189: LD_INT 1
63191: PPUSH
63192: LD_VAR 0 14
63196: PPUSH
63197: CALL_OW 2
63201: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63202: LD_VAR 0 14
63206: PPUSH
63207: LD_VAR 0 1
63211: PPUSH
63212: CALL_OW 250
63216: PPUSH
63217: LD_VAR 0 1
63221: PPUSH
63222: CALL_OW 251
63226: PPUSH
63227: LD_INT 10
63229: PPUSH
63230: LD_INT 0
63232: PPUSH
63233: CALL_OW 50
// continue ;
63237: GO 63138
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
63239: LD_VAR 0 12
63243: PUSH
63244: LD_INT 1
63246: ARRAY
63247: PPUSH
63248: CALL_OW 313
63252: PUSH
63253: LD_VAR 0 12
63257: PUSH
63258: LD_INT 1
63260: ARRAY
63261: PPUSH
63262: CALL_OW 266
63266: PUSH
63267: LD_INT 32
63269: PUSH
63270: LD_INT 31
63272: PUSH
63273: EMPTY
63274: LIST
63275: LIST
63276: IN
63277: AND
63278: PUSH
63279: LD_VAR 0 12
63283: PUSH
63284: LD_INT 1
63286: ARRAY
63287: PPUSH
63288: CALL_OW 313
63292: PUSH
63293: LD_INT 6
63295: EQUAL
63296: OR
63297: IFFALSE 63317
// f := Delete ( f , 1 ) ;
63299: LD_ADDR_VAR 0 12
63303: PUSH
63304: LD_VAR 0 12
63308: PPUSH
63309: LD_INT 1
63311: PPUSH
63312: CALL_OW 3
63316: ST_TO_ADDR
// if not f then
63317: LD_VAR 0 12
63321: NOT
63322: IFFALSE 63340
// begin x := x + 2 ;
63324: LD_ADDR_VAR 0 13
63328: PUSH
63329: LD_VAR 0 13
63333: PUSH
63334: LD_INT 2
63336: PLUS
63337: ST_TO_ADDR
// continue ;
63338: GO 63138
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
63340: LD_VAR 0 12
63344: PUSH
63345: LD_INT 1
63347: ARRAY
63348: PPUSH
63349: CALL_OW 266
63353: PUSH
63354: LD_INT 5
63356: EQUAL
63357: IFFALSE 63431
// begin if UnitsInside ( f [ 1 ] ) < 3 then
63359: LD_VAR 0 12
63363: PUSH
63364: LD_INT 1
63366: ARRAY
63367: PPUSH
63368: CALL_OW 313
63372: PUSH
63373: LD_INT 3
63375: LESS
63376: IFFALSE 63412
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
63378: LD_INT 0
63380: PPUSH
63381: LD_INT 5
63383: PUSH
63384: LD_INT 8
63386: PUSH
63387: LD_INT 9
63389: PUSH
63390: EMPTY
63391: LIST
63392: LIST
63393: LIST
63394: PUSH
63395: LD_VAR 0 17
63399: ARRAY
63400: PPUSH
63401: LD_VAR 0 4
63405: PPUSH
63406: CALL_OW 380
63410: GO 63429
// PrepareHuman ( false , i , skill ) ;
63412: LD_INT 0
63414: PPUSH
63415: LD_VAR 0 8
63419: PPUSH
63420: LD_VAR 0 4
63424: PPUSH
63425: CALL_OW 380
// end else
63429: GO 63448
// PrepareHuman ( false , i , skill ) ;
63431: LD_INT 0
63433: PPUSH
63434: LD_VAR 0 8
63438: PPUSH
63439: LD_VAR 0 4
63443: PPUSH
63444: CALL_OW 380
// un := CreateHuman ;
63448: LD_ADDR_VAR 0 14
63452: PUSH
63453: CALL_OW 44
63457: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63458: LD_ADDR_VAR 0 7
63462: PUSH
63463: LD_VAR 0 7
63467: PPUSH
63468: LD_INT 1
63470: PPUSH
63471: LD_VAR 0 14
63475: PPUSH
63476: CALL_OW 2
63480: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
63481: LD_VAR 0 14
63485: PPUSH
63486: LD_VAR 0 12
63490: PUSH
63491: LD_INT 1
63493: ARRAY
63494: PPUSH
63495: CALL_OW 52
// end ;
63499: GO 63138
63501: POP
63502: POP
// end ;
63503: GO 62440
63505: POP
63506: POP
// result := result ^ buildings ;
63507: LD_ADDR_VAR 0 7
63511: PUSH
63512: LD_VAR 0 7
63516: PUSH
63517: LD_VAR 0 18
63521: ADD
63522: ST_TO_ADDR
// end else
63523: GO 63666
// begin for i = 1 to personel do
63525: LD_ADDR_VAR 0 8
63529: PUSH
63530: DOUBLE
63531: LD_INT 1
63533: DEC
63534: ST_TO_ADDR
63535: LD_VAR 0 6
63539: PUSH
63540: FOR_TO
63541: IFFALSE 63664
// begin if i > 4 then
63543: LD_VAR 0 8
63547: PUSH
63548: LD_INT 4
63550: GREATER
63551: IFFALSE 63555
// break ;
63553: GO 63664
// x := personel [ i ] ;
63555: LD_ADDR_VAR 0 13
63559: PUSH
63560: LD_VAR 0 6
63564: PUSH
63565: LD_VAR 0 8
63569: ARRAY
63570: ST_TO_ADDR
// if x = - 1 then
63571: LD_VAR 0 13
63575: PUSH
63576: LD_INT 1
63578: NEG
63579: EQUAL
63580: IFFALSE 63584
// continue ;
63582: GO 63540
// PrepareHuman ( false , i , skill ) ;
63584: LD_INT 0
63586: PPUSH
63587: LD_VAR 0 8
63591: PPUSH
63592: LD_VAR 0 4
63596: PPUSH
63597: CALL_OW 380
// un := CreateHuman ;
63601: LD_ADDR_VAR 0 14
63605: PUSH
63606: CALL_OW 44
63610: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63611: LD_VAR 0 14
63615: PPUSH
63616: LD_VAR 0 1
63620: PPUSH
63621: CALL_OW 250
63625: PPUSH
63626: LD_VAR 0 1
63630: PPUSH
63631: CALL_OW 251
63635: PPUSH
63636: LD_INT 10
63638: PPUSH
63639: LD_INT 0
63641: PPUSH
63642: CALL_OW 50
// result := result ^ un ;
63646: LD_ADDR_VAR 0 7
63650: PUSH
63651: LD_VAR 0 7
63655: PUSH
63656: LD_VAR 0 14
63660: ADD
63661: ST_TO_ADDR
// end ;
63662: GO 63540
63664: POP
63665: POP
// end ; end ;
63666: LD_VAR 0 7
63670: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
63671: LD_INT 0
63673: PPUSH
63674: PPUSH
63675: PPUSH
63676: PPUSH
63677: PPUSH
63678: PPUSH
63679: PPUSH
63680: PPUSH
63681: PPUSH
63682: PPUSH
63683: PPUSH
63684: PPUSH
63685: PPUSH
63686: PPUSH
63687: PPUSH
63688: PPUSH
// result := false ;
63689: LD_ADDR_VAR 0 3
63693: PUSH
63694: LD_INT 0
63696: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
63697: LD_VAR 0 1
63701: NOT
63702: PUSH
63703: LD_VAR 0 1
63707: PPUSH
63708: CALL_OW 266
63712: PUSH
63713: LD_INT 32
63715: PUSH
63716: LD_INT 33
63718: PUSH
63719: EMPTY
63720: LIST
63721: LIST
63722: IN
63723: NOT
63724: OR
63725: IFFALSE 63729
// exit ;
63727: GO 64838
// nat := GetNation ( tower ) ;
63729: LD_ADDR_VAR 0 12
63733: PUSH
63734: LD_VAR 0 1
63738: PPUSH
63739: CALL_OW 248
63743: ST_TO_ADDR
// side := GetSide ( tower ) ;
63744: LD_ADDR_VAR 0 16
63748: PUSH
63749: LD_VAR 0 1
63753: PPUSH
63754: CALL_OW 255
63758: ST_TO_ADDR
// x := GetX ( tower ) ;
63759: LD_ADDR_VAR 0 10
63763: PUSH
63764: LD_VAR 0 1
63768: PPUSH
63769: CALL_OW 250
63773: ST_TO_ADDR
// y := GetY ( tower ) ;
63774: LD_ADDR_VAR 0 11
63778: PUSH
63779: LD_VAR 0 1
63783: PPUSH
63784: CALL_OW 251
63788: ST_TO_ADDR
// if not x or not y then
63789: LD_VAR 0 10
63793: NOT
63794: PUSH
63795: LD_VAR 0 11
63799: NOT
63800: OR
63801: IFFALSE 63805
// exit ;
63803: GO 64838
// weapon := 0 ;
63805: LD_ADDR_VAR 0 18
63809: PUSH
63810: LD_INT 0
63812: ST_TO_ADDR
// fac_list := [ ] ;
63813: LD_ADDR_VAR 0 17
63817: PUSH
63818: EMPTY
63819: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
63820: LD_ADDR_VAR 0 6
63824: PUSH
63825: LD_VAR 0 1
63829: PPUSH
63830: CALL_OW 274
63834: PPUSH
63835: LD_VAR 0 2
63839: PPUSH
63840: LD_INT 0
63842: PPUSH
63843: CALL 61409 0 3
63847: PPUSH
63848: LD_INT 30
63850: PUSH
63851: LD_INT 3
63853: PUSH
63854: EMPTY
63855: LIST
63856: LIST
63857: PPUSH
63858: CALL_OW 72
63862: ST_TO_ADDR
// if not factories then
63863: LD_VAR 0 6
63867: NOT
63868: IFFALSE 63872
// exit ;
63870: GO 64838
// for i in factories do
63872: LD_ADDR_VAR 0 8
63876: PUSH
63877: LD_VAR 0 6
63881: PUSH
63882: FOR_IN
63883: IFFALSE 63908
// fac_list := fac_list union AvailableWeaponList ( i ) ;
63885: LD_ADDR_VAR 0 17
63889: PUSH
63890: LD_VAR 0 17
63894: PUSH
63895: LD_VAR 0 8
63899: PPUSH
63900: CALL_OW 478
63904: UNION
63905: ST_TO_ADDR
63906: GO 63882
63908: POP
63909: POP
// if not fac_list then
63910: LD_VAR 0 17
63914: NOT
63915: IFFALSE 63919
// exit ;
63917: GO 64838
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
63919: LD_ADDR_VAR 0 5
63923: PUSH
63924: LD_INT 4
63926: PUSH
63927: LD_INT 5
63929: PUSH
63930: LD_INT 9
63932: PUSH
63933: LD_INT 10
63935: PUSH
63936: LD_INT 6
63938: PUSH
63939: LD_INT 7
63941: PUSH
63942: LD_INT 11
63944: PUSH
63945: EMPTY
63946: LIST
63947: LIST
63948: LIST
63949: LIST
63950: LIST
63951: LIST
63952: LIST
63953: PUSH
63954: LD_INT 27
63956: PUSH
63957: LD_INT 28
63959: PUSH
63960: LD_INT 26
63962: PUSH
63963: LD_INT 30
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: LIST
63970: LIST
63971: PUSH
63972: LD_INT 43
63974: PUSH
63975: LD_INT 44
63977: PUSH
63978: LD_INT 46
63980: PUSH
63981: LD_INT 45
63983: PUSH
63984: LD_INT 47
63986: PUSH
63987: LD_INT 49
63989: PUSH
63990: EMPTY
63991: LIST
63992: LIST
63993: LIST
63994: LIST
63995: LIST
63996: LIST
63997: PUSH
63998: EMPTY
63999: LIST
64000: LIST
64001: LIST
64002: PUSH
64003: LD_VAR 0 12
64007: ARRAY
64008: ST_TO_ADDR
// list := list isect fac_list ;
64009: LD_ADDR_VAR 0 5
64013: PUSH
64014: LD_VAR 0 5
64018: PUSH
64019: LD_VAR 0 17
64023: ISECT
64024: ST_TO_ADDR
// if not list then
64025: LD_VAR 0 5
64029: NOT
64030: IFFALSE 64034
// exit ;
64032: GO 64838
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
64034: LD_VAR 0 12
64038: PUSH
64039: LD_INT 3
64041: EQUAL
64042: PUSH
64043: LD_INT 49
64045: PUSH
64046: LD_VAR 0 5
64050: IN
64051: AND
64052: PUSH
64053: LD_INT 31
64055: PPUSH
64056: LD_VAR 0 16
64060: PPUSH
64061: CALL_OW 321
64065: PUSH
64066: LD_INT 2
64068: EQUAL
64069: AND
64070: IFFALSE 64130
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
64072: LD_INT 22
64074: PUSH
64075: LD_VAR 0 16
64079: PUSH
64080: EMPTY
64081: LIST
64082: LIST
64083: PUSH
64084: LD_INT 35
64086: PUSH
64087: LD_INT 49
64089: PUSH
64090: EMPTY
64091: LIST
64092: LIST
64093: PUSH
64094: LD_INT 91
64096: PUSH
64097: LD_VAR 0 1
64101: PUSH
64102: LD_INT 10
64104: PUSH
64105: EMPTY
64106: LIST
64107: LIST
64108: LIST
64109: PUSH
64110: EMPTY
64111: LIST
64112: LIST
64113: LIST
64114: PPUSH
64115: CALL_OW 69
64119: NOT
64120: IFFALSE 64130
// weapon := ru_time_lapser ;
64122: LD_ADDR_VAR 0 18
64126: PUSH
64127: LD_INT 49
64129: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
64130: LD_VAR 0 12
64134: PUSH
64135: LD_INT 1
64137: PUSH
64138: LD_INT 2
64140: PUSH
64141: EMPTY
64142: LIST
64143: LIST
64144: IN
64145: PUSH
64146: LD_INT 11
64148: PUSH
64149: LD_VAR 0 5
64153: IN
64154: PUSH
64155: LD_INT 30
64157: PUSH
64158: LD_VAR 0 5
64162: IN
64163: OR
64164: AND
64165: PUSH
64166: LD_INT 6
64168: PPUSH
64169: LD_VAR 0 16
64173: PPUSH
64174: CALL_OW 321
64178: PUSH
64179: LD_INT 2
64181: EQUAL
64182: AND
64183: IFFALSE 64348
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
64185: LD_INT 22
64187: PUSH
64188: LD_VAR 0 16
64192: PUSH
64193: EMPTY
64194: LIST
64195: LIST
64196: PUSH
64197: LD_INT 2
64199: PUSH
64200: LD_INT 35
64202: PUSH
64203: LD_INT 11
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: PUSH
64210: LD_INT 35
64212: PUSH
64213: LD_INT 30
64215: PUSH
64216: EMPTY
64217: LIST
64218: LIST
64219: PUSH
64220: EMPTY
64221: LIST
64222: LIST
64223: LIST
64224: PUSH
64225: LD_INT 91
64227: PUSH
64228: LD_VAR 0 1
64232: PUSH
64233: LD_INT 18
64235: PUSH
64236: EMPTY
64237: LIST
64238: LIST
64239: LIST
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: LIST
64245: PPUSH
64246: CALL_OW 69
64250: NOT
64251: PUSH
64252: LD_INT 22
64254: PUSH
64255: LD_VAR 0 16
64259: PUSH
64260: EMPTY
64261: LIST
64262: LIST
64263: PUSH
64264: LD_INT 2
64266: PUSH
64267: LD_INT 30
64269: PUSH
64270: LD_INT 32
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: LD_INT 30
64279: PUSH
64280: LD_INT 33
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PUSH
64287: EMPTY
64288: LIST
64289: LIST
64290: LIST
64291: PUSH
64292: LD_INT 91
64294: PUSH
64295: LD_VAR 0 1
64299: PUSH
64300: LD_INT 12
64302: PUSH
64303: EMPTY
64304: LIST
64305: LIST
64306: LIST
64307: PUSH
64308: EMPTY
64309: LIST
64310: LIST
64311: LIST
64312: PUSH
64313: EMPTY
64314: LIST
64315: PPUSH
64316: CALL_OW 69
64320: PUSH
64321: LD_INT 2
64323: GREATER
64324: AND
64325: IFFALSE 64348
// weapon := [ us_radar , ar_radar ] [ nat ] ;
64327: LD_ADDR_VAR 0 18
64331: PUSH
64332: LD_INT 11
64334: PUSH
64335: LD_INT 30
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PUSH
64342: LD_VAR 0 12
64346: ARRAY
64347: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
64348: LD_VAR 0 18
64352: NOT
64353: PUSH
64354: LD_INT 40
64356: PPUSH
64357: LD_VAR 0 16
64361: PPUSH
64362: CALL_OW 321
64366: PUSH
64367: LD_INT 2
64369: EQUAL
64370: AND
64371: PUSH
64372: LD_INT 7
64374: PUSH
64375: LD_VAR 0 5
64379: IN
64380: PUSH
64381: LD_INT 28
64383: PUSH
64384: LD_VAR 0 5
64388: IN
64389: OR
64390: PUSH
64391: LD_INT 45
64393: PUSH
64394: LD_VAR 0 5
64398: IN
64399: OR
64400: AND
64401: IFFALSE 64655
// begin hex := GetHexInfo ( x , y ) ;
64403: LD_ADDR_VAR 0 4
64407: PUSH
64408: LD_VAR 0 10
64412: PPUSH
64413: LD_VAR 0 11
64417: PPUSH
64418: CALL_OW 546
64422: ST_TO_ADDR
// if hex [ 1 ] then
64423: LD_VAR 0 4
64427: PUSH
64428: LD_INT 1
64430: ARRAY
64431: IFFALSE 64435
// exit ;
64433: GO 64838
// height := hex [ 2 ] ;
64435: LD_ADDR_VAR 0 15
64439: PUSH
64440: LD_VAR 0 4
64444: PUSH
64445: LD_INT 2
64447: ARRAY
64448: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
64449: LD_ADDR_VAR 0 14
64453: PUSH
64454: LD_INT 0
64456: PUSH
64457: LD_INT 2
64459: PUSH
64460: LD_INT 3
64462: PUSH
64463: LD_INT 5
64465: PUSH
64466: EMPTY
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: ST_TO_ADDR
// for i in tmp do
64472: LD_ADDR_VAR 0 8
64476: PUSH
64477: LD_VAR 0 14
64481: PUSH
64482: FOR_IN
64483: IFFALSE 64653
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
64485: LD_ADDR_VAR 0 9
64489: PUSH
64490: LD_VAR 0 10
64494: PPUSH
64495: LD_VAR 0 8
64499: PPUSH
64500: LD_INT 5
64502: PPUSH
64503: CALL_OW 272
64507: PUSH
64508: LD_VAR 0 11
64512: PPUSH
64513: LD_VAR 0 8
64517: PPUSH
64518: LD_INT 5
64520: PPUSH
64521: CALL_OW 273
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
64530: LD_VAR 0 9
64534: PUSH
64535: LD_INT 1
64537: ARRAY
64538: PPUSH
64539: LD_VAR 0 9
64543: PUSH
64544: LD_INT 2
64546: ARRAY
64547: PPUSH
64548: CALL_OW 488
64552: IFFALSE 64651
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
64554: LD_ADDR_VAR 0 4
64558: PUSH
64559: LD_VAR 0 9
64563: PUSH
64564: LD_INT 1
64566: ARRAY
64567: PPUSH
64568: LD_VAR 0 9
64572: PUSH
64573: LD_INT 2
64575: ARRAY
64576: PPUSH
64577: CALL_OW 546
64581: ST_TO_ADDR
// if hex [ 1 ] then
64582: LD_VAR 0 4
64586: PUSH
64587: LD_INT 1
64589: ARRAY
64590: IFFALSE 64594
// continue ;
64592: GO 64482
// h := hex [ 2 ] ;
64594: LD_ADDR_VAR 0 13
64598: PUSH
64599: LD_VAR 0 4
64603: PUSH
64604: LD_INT 2
64606: ARRAY
64607: ST_TO_ADDR
// if h + 7 < height then
64608: LD_VAR 0 13
64612: PUSH
64613: LD_INT 7
64615: PLUS
64616: PUSH
64617: LD_VAR 0 15
64621: LESS
64622: IFFALSE 64651
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
64624: LD_ADDR_VAR 0 18
64628: PUSH
64629: LD_INT 7
64631: PUSH
64632: LD_INT 28
64634: PUSH
64635: LD_INT 45
64637: PUSH
64638: EMPTY
64639: LIST
64640: LIST
64641: LIST
64642: PUSH
64643: LD_VAR 0 12
64647: ARRAY
64648: ST_TO_ADDR
// break ;
64649: GO 64653
// end ; end ; end ;
64651: GO 64482
64653: POP
64654: POP
// end ; if not weapon then
64655: LD_VAR 0 18
64659: NOT
64660: IFFALSE 64720
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
64662: LD_ADDR_VAR 0 5
64666: PUSH
64667: LD_VAR 0 5
64671: PUSH
64672: LD_INT 11
64674: PUSH
64675: LD_INT 30
64677: PUSH
64678: LD_INT 49
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: LIST
64685: DIFF
64686: ST_TO_ADDR
// if not list then
64687: LD_VAR 0 5
64691: NOT
64692: IFFALSE 64696
// exit ;
64694: GO 64838
// weapon := list [ rand ( 1 , list ) ] ;
64696: LD_ADDR_VAR 0 18
64700: PUSH
64701: LD_VAR 0 5
64705: PUSH
64706: LD_INT 1
64708: PPUSH
64709: LD_VAR 0 5
64713: PPUSH
64714: CALL_OW 12
64718: ARRAY
64719: ST_TO_ADDR
// end ; if weapon then
64720: LD_VAR 0 18
64724: IFFALSE 64838
// begin tmp := CostOfWeapon ( weapon ) ;
64726: LD_ADDR_VAR 0 14
64730: PUSH
64731: LD_VAR 0 18
64735: PPUSH
64736: CALL_OW 451
64740: ST_TO_ADDR
// j := GetBase ( tower ) ;
64741: LD_ADDR_VAR 0 9
64745: PUSH
64746: LD_VAR 0 1
64750: PPUSH
64751: CALL_OW 274
64755: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
64756: LD_VAR 0 9
64760: PPUSH
64761: LD_INT 1
64763: PPUSH
64764: CALL_OW 275
64768: PUSH
64769: LD_VAR 0 14
64773: PUSH
64774: LD_INT 1
64776: ARRAY
64777: GREATEREQUAL
64778: PUSH
64779: LD_VAR 0 9
64783: PPUSH
64784: LD_INT 2
64786: PPUSH
64787: CALL_OW 275
64791: PUSH
64792: LD_VAR 0 14
64796: PUSH
64797: LD_INT 2
64799: ARRAY
64800: GREATEREQUAL
64801: AND
64802: PUSH
64803: LD_VAR 0 9
64807: PPUSH
64808: LD_INT 3
64810: PPUSH
64811: CALL_OW 275
64815: PUSH
64816: LD_VAR 0 14
64820: PUSH
64821: LD_INT 3
64823: ARRAY
64824: GREATEREQUAL
64825: AND
64826: IFFALSE 64838
// result := weapon ;
64828: LD_ADDR_VAR 0 3
64832: PUSH
64833: LD_VAR 0 18
64837: ST_TO_ADDR
// end ; end ;
64838: LD_VAR 0 3
64842: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
64843: LD_INT 0
64845: PPUSH
64846: PPUSH
// result := true ;
64847: LD_ADDR_VAR 0 3
64851: PUSH
64852: LD_INT 1
64854: ST_TO_ADDR
// if array1 = array2 then
64855: LD_VAR 0 1
64859: PUSH
64860: LD_VAR 0 2
64864: EQUAL
64865: IFFALSE 64925
// begin for i = 1 to array1 do
64867: LD_ADDR_VAR 0 4
64871: PUSH
64872: DOUBLE
64873: LD_INT 1
64875: DEC
64876: ST_TO_ADDR
64877: LD_VAR 0 1
64881: PUSH
64882: FOR_TO
64883: IFFALSE 64921
// if array1 [ i ] <> array2 [ i ] then
64885: LD_VAR 0 1
64889: PUSH
64890: LD_VAR 0 4
64894: ARRAY
64895: PUSH
64896: LD_VAR 0 2
64900: PUSH
64901: LD_VAR 0 4
64905: ARRAY
64906: NONEQUAL
64907: IFFALSE 64919
// begin result := false ;
64909: LD_ADDR_VAR 0 3
64913: PUSH
64914: LD_INT 0
64916: ST_TO_ADDR
// break ;
64917: GO 64921
// end ;
64919: GO 64882
64921: POP
64922: POP
// end else
64923: GO 64933
// result := false ;
64925: LD_ADDR_VAR 0 3
64929: PUSH
64930: LD_INT 0
64932: ST_TO_ADDR
// end ;
64933: LD_VAR 0 3
64937: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
64938: LD_INT 0
64940: PPUSH
64941: PPUSH
// if not array1 or not array2 then
64942: LD_VAR 0 1
64946: NOT
64947: PUSH
64948: LD_VAR 0 2
64952: NOT
64953: OR
64954: IFFALSE 64958
// exit ;
64956: GO 65022
// result := true ;
64958: LD_ADDR_VAR 0 3
64962: PUSH
64963: LD_INT 1
64965: ST_TO_ADDR
// for i = 1 to array1 do
64966: LD_ADDR_VAR 0 4
64970: PUSH
64971: DOUBLE
64972: LD_INT 1
64974: DEC
64975: ST_TO_ADDR
64976: LD_VAR 0 1
64980: PUSH
64981: FOR_TO
64982: IFFALSE 65020
// if array1 [ i ] <> array2 [ i ] then
64984: LD_VAR 0 1
64988: PUSH
64989: LD_VAR 0 4
64993: ARRAY
64994: PUSH
64995: LD_VAR 0 2
64999: PUSH
65000: LD_VAR 0 4
65004: ARRAY
65005: NONEQUAL
65006: IFFALSE 65018
// begin result := false ;
65008: LD_ADDR_VAR 0 3
65012: PUSH
65013: LD_INT 0
65015: ST_TO_ADDR
// break ;
65016: GO 65020
// end ;
65018: GO 64981
65020: POP
65021: POP
// end ;
65022: LD_VAR 0 3
65026: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
65027: LD_INT 0
65029: PPUSH
65030: PPUSH
65031: PPUSH
// pom := GetBase ( fac ) ;
65032: LD_ADDR_VAR 0 5
65036: PUSH
65037: LD_VAR 0 1
65041: PPUSH
65042: CALL_OW 274
65046: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
65047: LD_ADDR_VAR 0 4
65051: PUSH
65052: LD_VAR 0 2
65056: PUSH
65057: LD_INT 1
65059: ARRAY
65060: PPUSH
65061: LD_VAR 0 2
65065: PUSH
65066: LD_INT 2
65068: ARRAY
65069: PPUSH
65070: LD_VAR 0 2
65074: PUSH
65075: LD_INT 3
65077: ARRAY
65078: PPUSH
65079: LD_VAR 0 2
65083: PUSH
65084: LD_INT 4
65086: ARRAY
65087: PPUSH
65088: CALL_OW 449
65092: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65093: LD_ADDR_VAR 0 3
65097: PUSH
65098: LD_VAR 0 5
65102: PPUSH
65103: LD_INT 1
65105: PPUSH
65106: CALL_OW 275
65110: PUSH
65111: LD_VAR 0 4
65115: PUSH
65116: LD_INT 1
65118: ARRAY
65119: GREATEREQUAL
65120: PUSH
65121: LD_VAR 0 5
65125: PPUSH
65126: LD_INT 2
65128: PPUSH
65129: CALL_OW 275
65133: PUSH
65134: LD_VAR 0 4
65138: PUSH
65139: LD_INT 2
65141: ARRAY
65142: GREATEREQUAL
65143: AND
65144: PUSH
65145: LD_VAR 0 5
65149: PPUSH
65150: LD_INT 3
65152: PPUSH
65153: CALL_OW 275
65157: PUSH
65158: LD_VAR 0 4
65162: PUSH
65163: LD_INT 3
65165: ARRAY
65166: GREATEREQUAL
65167: AND
65168: ST_TO_ADDR
// end ;
65169: LD_VAR 0 3
65173: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
65174: LD_INT 0
65176: PPUSH
65177: PPUSH
65178: PPUSH
65179: PPUSH
// pom := GetBase ( building ) ;
65180: LD_ADDR_VAR 0 3
65184: PUSH
65185: LD_VAR 0 1
65189: PPUSH
65190: CALL_OW 274
65194: ST_TO_ADDR
// if not pom then
65195: LD_VAR 0 3
65199: NOT
65200: IFFALSE 65204
// exit ;
65202: GO 65374
// btype := GetBType ( building ) ;
65204: LD_ADDR_VAR 0 5
65208: PUSH
65209: LD_VAR 0 1
65213: PPUSH
65214: CALL_OW 266
65218: ST_TO_ADDR
// if btype = b_armoury then
65219: LD_VAR 0 5
65223: PUSH
65224: LD_INT 4
65226: EQUAL
65227: IFFALSE 65237
// btype := b_barracks ;
65229: LD_ADDR_VAR 0 5
65233: PUSH
65234: LD_INT 5
65236: ST_TO_ADDR
// if btype = b_depot then
65237: LD_VAR 0 5
65241: PUSH
65242: LD_INT 0
65244: EQUAL
65245: IFFALSE 65255
// btype := b_warehouse ;
65247: LD_ADDR_VAR 0 5
65251: PUSH
65252: LD_INT 1
65254: ST_TO_ADDR
// if btype = b_workshop then
65255: LD_VAR 0 5
65259: PUSH
65260: LD_INT 2
65262: EQUAL
65263: IFFALSE 65273
// btype := b_factory ;
65265: LD_ADDR_VAR 0 5
65269: PUSH
65270: LD_INT 3
65272: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65273: LD_ADDR_VAR 0 4
65277: PUSH
65278: LD_VAR 0 5
65282: PPUSH
65283: LD_VAR 0 1
65287: PPUSH
65288: CALL_OW 248
65292: PPUSH
65293: CALL_OW 450
65297: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65298: LD_ADDR_VAR 0 2
65302: PUSH
65303: LD_VAR 0 3
65307: PPUSH
65308: LD_INT 1
65310: PPUSH
65311: CALL_OW 275
65315: PUSH
65316: LD_VAR 0 4
65320: PUSH
65321: LD_INT 1
65323: ARRAY
65324: GREATEREQUAL
65325: PUSH
65326: LD_VAR 0 3
65330: PPUSH
65331: LD_INT 2
65333: PPUSH
65334: CALL_OW 275
65338: PUSH
65339: LD_VAR 0 4
65343: PUSH
65344: LD_INT 2
65346: ARRAY
65347: GREATEREQUAL
65348: AND
65349: PUSH
65350: LD_VAR 0 3
65354: PPUSH
65355: LD_INT 3
65357: PPUSH
65358: CALL_OW 275
65362: PUSH
65363: LD_VAR 0 4
65367: PUSH
65368: LD_INT 3
65370: ARRAY
65371: GREATEREQUAL
65372: AND
65373: ST_TO_ADDR
// end ;
65374: LD_VAR 0 2
65378: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
65379: LD_INT 0
65381: PPUSH
65382: PPUSH
65383: PPUSH
// pom := GetBase ( building ) ;
65384: LD_ADDR_VAR 0 4
65388: PUSH
65389: LD_VAR 0 1
65393: PPUSH
65394: CALL_OW 274
65398: ST_TO_ADDR
// if not pom then
65399: LD_VAR 0 4
65403: NOT
65404: IFFALSE 65408
// exit ;
65406: GO 65509
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65408: LD_ADDR_VAR 0 5
65412: PUSH
65413: LD_VAR 0 2
65417: PPUSH
65418: LD_VAR 0 1
65422: PPUSH
65423: CALL_OW 248
65427: PPUSH
65428: CALL_OW 450
65432: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65433: LD_ADDR_VAR 0 3
65437: PUSH
65438: LD_VAR 0 4
65442: PPUSH
65443: LD_INT 1
65445: PPUSH
65446: CALL_OW 275
65450: PUSH
65451: LD_VAR 0 5
65455: PUSH
65456: LD_INT 1
65458: ARRAY
65459: GREATEREQUAL
65460: PUSH
65461: LD_VAR 0 4
65465: PPUSH
65466: LD_INT 2
65468: PPUSH
65469: CALL_OW 275
65473: PUSH
65474: LD_VAR 0 5
65478: PUSH
65479: LD_INT 2
65481: ARRAY
65482: GREATEREQUAL
65483: AND
65484: PUSH
65485: LD_VAR 0 4
65489: PPUSH
65490: LD_INT 3
65492: PPUSH
65493: CALL_OW 275
65497: PUSH
65498: LD_VAR 0 5
65502: PUSH
65503: LD_INT 3
65505: ARRAY
65506: GREATEREQUAL
65507: AND
65508: ST_TO_ADDR
// end ;
65509: LD_VAR 0 3
65513: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
65514: LD_INT 0
65516: PPUSH
65517: PPUSH
65518: PPUSH
65519: PPUSH
65520: PPUSH
65521: PPUSH
65522: PPUSH
65523: PPUSH
65524: PPUSH
65525: PPUSH
65526: PPUSH
// result := false ;
65527: LD_ADDR_VAR 0 8
65531: PUSH
65532: LD_INT 0
65534: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
65535: LD_VAR 0 5
65539: NOT
65540: PUSH
65541: LD_VAR 0 1
65545: NOT
65546: OR
65547: PUSH
65548: LD_VAR 0 2
65552: NOT
65553: OR
65554: PUSH
65555: LD_VAR 0 3
65559: NOT
65560: OR
65561: IFFALSE 65565
// exit ;
65563: GO 66379
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
65565: LD_ADDR_VAR 0 14
65569: PUSH
65570: LD_VAR 0 1
65574: PPUSH
65575: LD_VAR 0 2
65579: PPUSH
65580: LD_VAR 0 3
65584: PPUSH
65585: LD_VAR 0 4
65589: PPUSH
65590: LD_VAR 0 5
65594: PUSH
65595: LD_INT 1
65597: ARRAY
65598: PPUSH
65599: CALL_OW 248
65603: PPUSH
65604: LD_INT 0
65606: PPUSH
65607: CALL 67632 0 6
65611: ST_TO_ADDR
// if not hexes then
65612: LD_VAR 0 14
65616: NOT
65617: IFFALSE 65621
// exit ;
65619: GO 66379
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
65621: LD_ADDR_VAR 0 17
65625: PUSH
65626: LD_VAR 0 5
65630: PPUSH
65631: LD_INT 22
65633: PUSH
65634: LD_VAR 0 13
65638: PPUSH
65639: CALL_OW 255
65643: PUSH
65644: EMPTY
65645: LIST
65646: LIST
65647: PUSH
65648: LD_INT 2
65650: PUSH
65651: LD_INT 30
65653: PUSH
65654: LD_INT 0
65656: PUSH
65657: EMPTY
65658: LIST
65659: LIST
65660: PUSH
65661: LD_INT 30
65663: PUSH
65664: LD_INT 1
65666: PUSH
65667: EMPTY
65668: LIST
65669: LIST
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: LIST
65675: PUSH
65676: EMPTY
65677: LIST
65678: LIST
65679: PPUSH
65680: CALL_OW 72
65684: ST_TO_ADDR
// for i = 1 to hexes do
65685: LD_ADDR_VAR 0 9
65689: PUSH
65690: DOUBLE
65691: LD_INT 1
65693: DEC
65694: ST_TO_ADDR
65695: LD_VAR 0 14
65699: PUSH
65700: FOR_TO
65701: IFFALSE 66377
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65703: LD_ADDR_VAR 0 13
65707: PUSH
65708: LD_VAR 0 14
65712: PUSH
65713: LD_VAR 0 9
65717: ARRAY
65718: PUSH
65719: LD_INT 1
65721: ARRAY
65722: PPUSH
65723: LD_VAR 0 14
65727: PUSH
65728: LD_VAR 0 9
65732: ARRAY
65733: PUSH
65734: LD_INT 2
65736: ARRAY
65737: PPUSH
65738: CALL_OW 428
65742: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
65743: LD_VAR 0 14
65747: PUSH
65748: LD_VAR 0 9
65752: ARRAY
65753: PUSH
65754: LD_INT 1
65756: ARRAY
65757: PPUSH
65758: LD_VAR 0 14
65762: PUSH
65763: LD_VAR 0 9
65767: ARRAY
65768: PUSH
65769: LD_INT 2
65771: ARRAY
65772: PPUSH
65773: CALL_OW 351
65777: PUSH
65778: LD_VAR 0 14
65782: PUSH
65783: LD_VAR 0 9
65787: ARRAY
65788: PUSH
65789: LD_INT 1
65791: ARRAY
65792: PPUSH
65793: LD_VAR 0 14
65797: PUSH
65798: LD_VAR 0 9
65802: ARRAY
65803: PUSH
65804: LD_INT 2
65806: ARRAY
65807: PPUSH
65808: CALL_OW 488
65812: NOT
65813: OR
65814: PUSH
65815: LD_VAR 0 13
65819: PPUSH
65820: CALL_OW 247
65824: PUSH
65825: LD_INT 3
65827: EQUAL
65828: OR
65829: IFFALSE 65835
// exit ;
65831: POP
65832: POP
65833: GO 66379
// if not tmp then
65835: LD_VAR 0 13
65839: NOT
65840: IFFALSE 65844
// continue ;
65842: GO 65700
// result := true ;
65844: LD_ADDR_VAR 0 8
65848: PUSH
65849: LD_INT 1
65851: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
65852: LD_VAR 0 6
65856: PUSH
65857: LD_VAR 0 13
65861: PPUSH
65862: CALL_OW 247
65866: PUSH
65867: LD_INT 2
65869: EQUAL
65870: AND
65871: PUSH
65872: LD_VAR 0 13
65876: PPUSH
65877: CALL_OW 263
65881: PUSH
65882: LD_INT 1
65884: EQUAL
65885: AND
65886: IFFALSE 66050
// begin if IsDrivenBy ( tmp ) then
65888: LD_VAR 0 13
65892: PPUSH
65893: CALL_OW 311
65897: IFFALSE 65901
// continue ;
65899: GO 65700
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
65901: LD_VAR 0 6
65905: PPUSH
65906: LD_INT 3
65908: PUSH
65909: LD_INT 60
65911: PUSH
65912: EMPTY
65913: LIST
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: PUSH
65919: LD_INT 3
65921: PUSH
65922: LD_INT 55
65924: PUSH
65925: EMPTY
65926: LIST
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: EMPTY
65933: LIST
65934: LIST
65935: PPUSH
65936: CALL_OW 72
65940: IFFALSE 66048
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
65942: LD_ADDR_VAR 0 18
65946: PUSH
65947: LD_VAR 0 6
65951: PPUSH
65952: LD_INT 3
65954: PUSH
65955: LD_INT 60
65957: PUSH
65958: EMPTY
65959: LIST
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: LD_INT 3
65967: PUSH
65968: LD_INT 55
65970: PUSH
65971: EMPTY
65972: LIST
65973: PUSH
65974: EMPTY
65975: LIST
65976: LIST
65977: PUSH
65978: EMPTY
65979: LIST
65980: LIST
65981: PPUSH
65982: CALL_OW 72
65986: PUSH
65987: LD_INT 1
65989: ARRAY
65990: ST_TO_ADDR
// if IsInUnit ( driver ) then
65991: LD_VAR 0 18
65995: PPUSH
65996: CALL_OW 310
66000: IFFALSE 66011
// ComExit ( driver ) ;
66002: LD_VAR 0 18
66006: PPUSH
66007: CALL 91413 0 1
// AddComEnterUnit ( driver , tmp ) ;
66011: LD_VAR 0 18
66015: PPUSH
66016: LD_VAR 0 13
66020: PPUSH
66021: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
66025: LD_VAR 0 18
66029: PPUSH
66030: LD_VAR 0 7
66034: PPUSH
66035: CALL_OW 173
// AddComExitVehicle ( driver ) ;
66039: LD_VAR 0 18
66043: PPUSH
66044: CALL_OW 181
// end ; continue ;
66048: GO 65700
// end ; if not cleaners or not tmp in cleaners then
66050: LD_VAR 0 6
66054: NOT
66055: PUSH
66056: LD_VAR 0 13
66060: PUSH
66061: LD_VAR 0 6
66065: IN
66066: NOT
66067: OR
66068: IFFALSE 66375
// begin if dep then
66070: LD_VAR 0 17
66074: IFFALSE 66210
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
66076: LD_ADDR_VAR 0 16
66080: PUSH
66081: LD_VAR 0 17
66085: PUSH
66086: LD_INT 1
66088: ARRAY
66089: PPUSH
66090: CALL_OW 250
66094: PPUSH
66095: LD_VAR 0 17
66099: PUSH
66100: LD_INT 1
66102: ARRAY
66103: PPUSH
66104: CALL_OW 254
66108: PPUSH
66109: LD_INT 5
66111: PPUSH
66112: CALL_OW 272
66116: PUSH
66117: LD_VAR 0 17
66121: PUSH
66122: LD_INT 1
66124: ARRAY
66125: PPUSH
66126: CALL_OW 251
66130: PPUSH
66131: LD_VAR 0 17
66135: PUSH
66136: LD_INT 1
66138: ARRAY
66139: PPUSH
66140: CALL_OW 254
66144: PPUSH
66145: LD_INT 5
66147: PPUSH
66148: CALL_OW 273
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
66157: LD_VAR 0 16
66161: PUSH
66162: LD_INT 1
66164: ARRAY
66165: PPUSH
66166: LD_VAR 0 16
66170: PUSH
66171: LD_INT 2
66173: ARRAY
66174: PPUSH
66175: CALL_OW 488
66179: IFFALSE 66210
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
66181: LD_VAR 0 13
66185: PPUSH
66186: LD_VAR 0 16
66190: PUSH
66191: LD_INT 1
66193: ARRAY
66194: PPUSH
66195: LD_VAR 0 16
66199: PUSH
66200: LD_INT 2
66202: ARRAY
66203: PPUSH
66204: CALL_OW 111
// continue ;
66208: GO 65700
// end ; end ; r := GetDir ( tmp ) ;
66210: LD_ADDR_VAR 0 15
66214: PUSH
66215: LD_VAR 0 13
66219: PPUSH
66220: CALL_OW 254
66224: ST_TO_ADDR
// if r = 5 then
66225: LD_VAR 0 15
66229: PUSH
66230: LD_INT 5
66232: EQUAL
66233: IFFALSE 66243
// r := 0 ;
66235: LD_ADDR_VAR 0 15
66239: PUSH
66240: LD_INT 0
66242: ST_TO_ADDR
// for j = r to 5 do
66243: LD_ADDR_VAR 0 10
66247: PUSH
66248: DOUBLE
66249: LD_VAR 0 15
66253: DEC
66254: ST_TO_ADDR
66255: LD_INT 5
66257: PUSH
66258: FOR_TO
66259: IFFALSE 66373
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
66261: LD_ADDR_VAR 0 11
66265: PUSH
66266: LD_VAR 0 13
66270: PPUSH
66271: CALL_OW 250
66275: PPUSH
66276: LD_VAR 0 10
66280: PPUSH
66281: LD_INT 2
66283: PPUSH
66284: CALL_OW 272
66288: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
66289: LD_ADDR_VAR 0 12
66293: PUSH
66294: LD_VAR 0 13
66298: PPUSH
66299: CALL_OW 251
66303: PPUSH
66304: LD_VAR 0 10
66308: PPUSH
66309: LD_INT 2
66311: PPUSH
66312: CALL_OW 273
66316: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
66317: LD_VAR 0 11
66321: PPUSH
66322: LD_VAR 0 12
66326: PPUSH
66327: CALL_OW 488
66331: PUSH
66332: LD_VAR 0 11
66336: PPUSH
66337: LD_VAR 0 12
66341: PPUSH
66342: CALL_OW 428
66346: NOT
66347: AND
66348: IFFALSE 66371
// begin ComMoveXY ( tmp , _x , _y ) ;
66350: LD_VAR 0 13
66354: PPUSH
66355: LD_VAR 0 11
66359: PPUSH
66360: LD_VAR 0 12
66364: PPUSH
66365: CALL_OW 111
// break ;
66369: GO 66373
// end ; end ;
66371: GO 66258
66373: POP
66374: POP
// end ; end ;
66375: GO 65700
66377: POP
66378: POP
// end ;
66379: LD_VAR 0 8
66383: RET
// export function BuildingTechInvented ( side , btype ) ; begin
66384: LD_INT 0
66386: PPUSH
// result := true ;
66387: LD_ADDR_VAR 0 3
66391: PUSH
66392: LD_INT 1
66394: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
66395: LD_VAR 0 2
66399: PUSH
66400: LD_INT 24
66402: DOUBLE
66403: EQUAL
66404: IFTRUE 66414
66406: LD_INT 33
66408: DOUBLE
66409: EQUAL
66410: IFTRUE 66414
66412: GO 66439
66414: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
66415: LD_ADDR_VAR 0 3
66419: PUSH
66420: LD_INT 32
66422: PPUSH
66423: LD_VAR 0 1
66427: PPUSH
66428: CALL_OW 321
66432: PUSH
66433: LD_INT 2
66435: EQUAL
66436: ST_TO_ADDR
66437: GO 66755
66439: LD_INT 20
66441: DOUBLE
66442: EQUAL
66443: IFTRUE 66447
66445: GO 66472
66447: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
66448: LD_ADDR_VAR 0 3
66452: PUSH
66453: LD_INT 6
66455: PPUSH
66456: LD_VAR 0 1
66460: PPUSH
66461: CALL_OW 321
66465: PUSH
66466: LD_INT 2
66468: EQUAL
66469: ST_TO_ADDR
66470: GO 66755
66472: LD_INT 22
66474: DOUBLE
66475: EQUAL
66476: IFTRUE 66486
66478: LD_INT 36
66480: DOUBLE
66481: EQUAL
66482: IFTRUE 66486
66484: GO 66511
66486: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
66487: LD_ADDR_VAR 0 3
66491: PUSH
66492: LD_INT 15
66494: PPUSH
66495: LD_VAR 0 1
66499: PPUSH
66500: CALL_OW 321
66504: PUSH
66505: LD_INT 2
66507: EQUAL
66508: ST_TO_ADDR
66509: GO 66755
66511: LD_INT 30
66513: DOUBLE
66514: EQUAL
66515: IFTRUE 66519
66517: GO 66544
66519: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
66520: LD_ADDR_VAR 0 3
66524: PUSH
66525: LD_INT 20
66527: PPUSH
66528: LD_VAR 0 1
66532: PPUSH
66533: CALL_OW 321
66537: PUSH
66538: LD_INT 2
66540: EQUAL
66541: ST_TO_ADDR
66542: GO 66755
66544: LD_INT 28
66546: DOUBLE
66547: EQUAL
66548: IFTRUE 66558
66550: LD_INT 21
66552: DOUBLE
66553: EQUAL
66554: IFTRUE 66558
66556: GO 66583
66558: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
66559: LD_ADDR_VAR 0 3
66563: PUSH
66564: LD_INT 21
66566: PPUSH
66567: LD_VAR 0 1
66571: PPUSH
66572: CALL_OW 321
66576: PUSH
66577: LD_INT 2
66579: EQUAL
66580: ST_TO_ADDR
66581: GO 66755
66583: LD_INT 16
66585: DOUBLE
66586: EQUAL
66587: IFTRUE 66591
66589: GO 66616
66591: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
66592: LD_ADDR_VAR 0 3
66596: PUSH
66597: LD_INT 84
66599: PPUSH
66600: LD_VAR 0 1
66604: PPUSH
66605: CALL_OW 321
66609: PUSH
66610: LD_INT 2
66612: EQUAL
66613: ST_TO_ADDR
66614: GO 66755
66616: LD_INT 19
66618: DOUBLE
66619: EQUAL
66620: IFTRUE 66630
66622: LD_INT 23
66624: DOUBLE
66625: EQUAL
66626: IFTRUE 66630
66628: GO 66655
66630: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
66631: LD_ADDR_VAR 0 3
66635: PUSH
66636: LD_INT 83
66638: PPUSH
66639: LD_VAR 0 1
66643: PPUSH
66644: CALL_OW 321
66648: PUSH
66649: LD_INT 2
66651: EQUAL
66652: ST_TO_ADDR
66653: GO 66755
66655: LD_INT 17
66657: DOUBLE
66658: EQUAL
66659: IFTRUE 66663
66661: GO 66688
66663: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
66664: LD_ADDR_VAR 0 3
66668: PUSH
66669: LD_INT 39
66671: PPUSH
66672: LD_VAR 0 1
66676: PPUSH
66677: CALL_OW 321
66681: PUSH
66682: LD_INT 2
66684: EQUAL
66685: ST_TO_ADDR
66686: GO 66755
66688: LD_INT 18
66690: DOUBLE
66691: EQUAL
66692: IFTRUE 66696
66694: GO 66721
66696: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
66697: LD_ADDR_VAR 0 3
66701: PUSH
66702: LD_INT 40
66704: PPUSH
66705: LD_VAR 0 1
66709: PPUSH
66710: CALL_OW 321
66714: PUSH
66715: LD_INT 2
66717: EQUAL
66718: ST_TO_ADDR
66719: GO 66755
66721: LD_INT 27
66723: DOUBLE
66724: EQUAL
66725: IFTRUE 66729
66727: GO 66754
66729: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
66730: LD_ADDR_VAR 0 3
66734: PUSH
66735: LD_INT 35
66737: PPUSH
66738: LD_VAR 0 1
66742: PPUSH
66743: CALL_OW 321
66747: PUSH
66748: LD_INT 2
66750: EQUAL
66751: ST_TO_ADDR
66752: GO 66755
66754: POP
// end ;
66755: LD_VAR 0 3
66759: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
66760: LD_INT 0
66762: PPUSH
66763: PPUSH
66764: PPUSH
66765: PPUSH
66766: PPUSH
66767: PPUSH
66768: PPUSH
66769: PPUSH
66770: PPUSH
66771: PPUSH
66772: PPUSH
// result := false ;
66773: LD_ADDR_VAR 0 6
66777: PUSH
66778: LD_INT 0
66780: ST_TO_ADDR
// if btype = b_depot then
66781: LD_VAR 0 2
66785: PUSH
66786: LD_INT 0
66788: EQUAL
66789: IFFALSE 66801
// begin result := true ;
66791: LD_ADDR_VAR 0 6
66795: PUSH
66796: LD_INT 1
66798: ST_TO_ADDR
// exit ;
66799: GO 67627
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
66801: LD_VAR 0 1
66805: NOT
66806: PUSH
66807: LD_VAR 0 1
66811: PPUSH
66812: CALL_OW 266
66816: PUSH
66817: LD_INT 0
66819: PUSH
66820: LD_INT 1
66822: PUSH
66823: EMPTY
66824: LIST
66825: LIST
66826: IN
66827: NOT
66828: OR
66829: PUSH
66830: LD_VAR 0 2
66834: NOT
66835: OR
66836: PUSH
66837: LD_VAR 0 5
66841: PUSH
66842: LD_INT 0
66844: PUSH
66845: LD_INT 1
66847: PUSH
66848: LD_INT 2
66850: PUSH
66851: LD_INT 3
66853: PUSH
66854: LD_INT 4
66856: PUSH
66857: LD_INT 5
66859: PUSH
66860: EMPTY
66861: LIST
66862: LIST
66863: LIST
66864: LIST
66865: LIST
66866: LIST
66867: IN
66868: NOT
66869: OR
66870: PUSH
66871: LD_VAR 0 3
66875: PPUSH
66876: LD_VAR 0 4
66880: PPUSH
66881: CALL_OW 488
66885: NOT
66886: OR
66887: IFFALSE 66891
// exit ;
66889: GO 67627
// side := GetSide ( depot ) ;
66891: LD_ADDR_VAR 0 9
66895: PUSH
66896: LD_VAR 0 1
66900: PPUSH
66901: CALL_OW 255
66905: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
66906: LD_VAR 0 9
66910: PPUSH
66911: LD_VAR 0 2
66915: PPUSH
66916: CALL 66384 0 2
66920: NOT
66921: IFFALSE 66925
// exit ;
66923: GO 67627
// pom := GetBase ( depot ) ;
66925: LD_ADDR_VAR 0 10
66929: PUSH
66930: LD_VAR 0 1
66934: PPUSH
66935: CALL_OW 274
66939: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
66940: LD_ADDR_VAR 0 11
66944: PUSH
66945: LD_VAR 0 2
66949: PPUSH
66950: LD_VAR 0 1
66954: PPUSH
66955: CALL_OW 248
66959: PPUSH
66960: CALL_OW 450
66964: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
66965: LD_VAR 0 10
66969: PPUSH
66970: LD_INT 1
66972: PPUSH
66973: CALL_OW 275
66977: PUSH
66978: LD_VAR 0 11
66982: PUSH
66983: LD_INT 1
66985: ARRAY
66986: GREATEREQUAL
66987: PUSH
66988: LD_VAR 0 10
66992: PPUSH
66993: LD_INT 2
66995: PPUSH
66996: CALL_OW 275
67000: PUSH
67001: LD_VAR 0 11
67005: PUSH
67006: LD_INT 2
67008: ARRAY
67009: GREATEREQUAL
67010: AND
67011: PUSH
67012: LD_VAR 0 10
67016: PPUSH
67017: LD_INT 3
67019: PPUSH
67020: CALL_OW 275
67024: PUSH
67025: LD_VAR 0 11
67029: PUSH
67030: LD_INT 3
67032: ARRAY
67033: GREATEREQUAL
67034: AND
67035: NOT
67036: IFFALSE 67040
// exit ;
67038: GO 67627
// if GetBType ( depot ) = b_depot then
67040: LD_VAR 0 1
67044: PPUSH
67045: CALL_OW 266
67049: PUSH
67050: LD_INT 0
67052: EQUAL
67053: IFFALSE 67065
// dist := 28 else
67055: LD_ADDR_VAR 0 14
67059: PUSH
67060: LD_INT 28
67062: ST_TO_ADDR
67063: GO 67073
// dist := 36 ;
67065: LD_ADDR_VAR 0 14
67069: PUSH
67070: LD_INT 36
67072: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
67073: LD_VAR 0 1
67077: PPUSH
67078: LD_VAR 0 3
67082: PPUSH
67083: LD_VAR 0 4
67087: PPUSH
67088: CALL_OW 297
67092: PUSH
67093: LD_VAR 0 14
67097: GREATER
67098: IFFALSE 67102
// exit ;
67100: GO 67627
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
67102: LD_ADDR_VAR 0 12
67106: PUSH
67107: LD_VAR 0 2
67111: PPUSH
67112: LD_VAR 0 3
67116: PPUSH
67117: LD_VAR 0 4
67121: PPUSH
67122: LD_VAR 0 5
67126: PPUSH
67127: LD_VAR 0 1
67131: PPUSH
67132: CALL_OW 248
67136: PPUSH
67137: LD_INT 0
67139: PPUSH
67140: CALL 67632 0 6
67144: ST_TO_ADDR
// if not hexes then
67145: LD_VAR 0 12
67149: NOT
67150: IFFALSE 67154
// exit ;
67152: GO 67627
// hex := GetHexInfo ( x , y ) ;
67154: LD_ADDR_VAR 0 15
67158: PUSH
67159: LD_VAR 0 3
67163: PPUSH
67164: LD_VAR 0 4
67168: PPUSH
67169: CALL_OW 546
67173: ST_TO_ADDR
// if hex [ 1 ] then
67174: LD_VAR 0 15
67178: PUSH
67179: LD_INT 1
67181: ARRAY
67182: IFFALSE 67186
// exit ;
67184: GO 67627
// height := hex [ 2 ] ;
67186: LD_ADDR_VAR 0 13
67190: PUSH
67191: LD_VAR 0 15
67195: PUSH
67196: LD_INT 2
67198: ARRAY
67199: ST_TO_ADDR
// for i = 1 to hexes do
67200: LD_ADDR_VAR 0 7
67204: PUSH
67205: DOUBLE
67206: LD_INT 1
67208: DEC
67209: ST_TO_ADDR
67210: LD_VAR 0 12
67214: PUSH
67215: FOR_TO
67216: IFFALSE 67546
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
67218: LD_VAR 0 12
67222: PUSH
67223: LD_VAR 0 7
67227: ARRAY
67228: PUSH
67229: LD_INT 1
67231: ARRAY
67232: PPUSH
67233: LD_VAR 0 12
67237: PUSH
67238: LD_VAR 0 7
67242: ARRAY
67243: PUSH
67244: LD_INT 2
67246: ARRAY
67247: PPUSH
67248: CALL_OW 488
67252: NOT
67253: PUSH
67254: LD_VAR 0 12
67258: PUSH
67259: LD_VAR 0 7
67263: ARRAY
67264: PUSH
67265: LD_INT 1
67267: ARRAY
67268: PPUSH
67269: LD_VAR 0 12
67273: PUSH
67274: LD_VAR 0 7
67278: ARRAY
67279: PUSH
67280: LD_INT 2
67282: ARRAY
67283: PPUSH
67284: CALL_OW 428
67288: PUSH
67289: LD_INT 0
67291: GREATER
67292: OR
67293: PUSH
67294: LD_VAR 0 12
67298: PUSH
67299: LD_VAR 0 7
67303: ARRAY
67304: PUSH
67305: LD_INT 1
67307: ARRAY
67308: PPUSH
67309: LD_VAR 0 12
67313: PUSH
67314: LD_VAR 0 7
67318: ARRAY
67319: PUSH
67320: LD_INT 2
67322: ARRAY
67323: PPUSH
67324: CALL_OW 351
67328: OR
67329: IFFALSE 67335
// exit ;
67331: POP
67332: POP
67333: GO 67627
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
67335: LD_ADDR_VAR 0 8
67339: PUSH
67340: LD_VAR 0 12
67344: PUSH
67345: LD_VAR 0 7
67349: ARRAY
67350: PUSH
67351: LD_INT 1
67353: ARRAY
67354: PPUSH
67355: LD_VAR 0 12
67359: PUSH
67360: LD_VAR 0 7
67364: ARRAY
67365: PUSH
67366: LD_INT 2
67368: ARRAY
67369: PPUSH
67370: CALL_OW 546
67374: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
67375: LD_VAR 0 8
67379: PUSH
67380: LD_INT 1
67382: ARRAY
67383: PUSH
67384: LD_VAR 0 8
67388: PUSH
67389: LD_INT 2
67391: ARRAY
67392: PUSH
67393: LD_VAR 0 13
67397: PUSH
67398: LD_INT 2
67400: PLUS
67401: GREATER
67402: OR
67403: PUSH
67404: LD_VAR 0 8
67408: PUSH
67409: LD_INT 2
67411: ARRAY
67412: PUSH
67413: LD_VAR 0 13
67417: PUSH
67418: LD_INT 2
67420: MINUS
67421: LESS
67422: OR
67423: PUSH
67424: LD_VAR 0 8
67428: PUSH
67429: LD_INT 3
67431: ARRAY
67432: PUSH
67433: LD_INT 0
67435: PUSH
67436: LD_INT 8
67438: PUSH
67439: LD_INT 9
67441: PUSH
67442: LD_INT 10
67444: PUSH
67445: LD_INT 11
67447: PUSH
67448: LD_INT 12
67450: PUSH
67451: LD_INT 13
67453: PUSH
67454: LD_INT 16
67456: PUSH
67457: LD_INT 17
67459: PUSH
67460: LD_INT 18
67462: PUSH
67463: LD_INT 19
67465: PUSH
67466: LD_INT 20
67468: PUSH
67469: LD_INT 21
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: LIST
67483: LIST
67484: LIST
67485: LIST
67486: IN
67487: NOT
67488: OR
67489: PUSH
67490: LD_VAR 0 8
67494: PUSH
67495: LD_INT 5
67497: ARRAY
67498: NOT
67499: OR
67500: PUSH
67501: LD_VAR 0 8
67505: PUSH
67506: LD_INT 6
67508: ARRAY
67509: PUSH
67510: LD_INT 1
67512: PUSH
67513: LD_INT 2
67515: PUSH
67516: LD_INT 7
67518: PUSH
67519: LD_INT 9
67521: PUSH
67522: LD_INT 10
67524: PUSH
67525: LD_INT 11
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: LIST
67532: LIST
67533: LIST
67534: LIST
67535: IN
67536: NOT
67537: OR
67538: IFFALSE 67544
// exit ;
67540: POP
67541: POP
67542: GO 67627
// end ;
67544: GO 67215
67546: POP
67547: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
67548: LD_VAR 0 9
67552: PPUSH
67553: LD_VAR 0 3
67557: PPUSH
67558: LD_VAR 0 4
67562: PPUSH
67563: LD_INT 20
67565: PPUSH
67566: CALL 59550 0 4
67570: PUSH
67571: LD_INT 4
67573: ARRAY
67574: IFFALSE 67578
// exit ;
67576: GO 67627
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
67578: LD_VAR 0 2
67582: PUSH
67583: LD_INT 29
67585: PUSH
67586: LD_INT 30
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: IN
67593: PUSH
67594: LD_VAR 0 3
67598: PPUSH
67599: LD_VAR 0 4
67603: PPUSH
67604: LD_VAR 0 9
67608: PPUSH
67609: CALL_OW 440
67613: NOT
67614: AND
67615: IFFALSE 67619
// exit ;
67617: GO 67627
// result := true ;
67619: LD_ADDR_VAR 0 6
67623: PUSH
67624: LD_INT 1
67626: ST_TO_ADDR
// end ;
67627: LD_VAR 0 6
67631: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
67632: LD_INT 0
67634: PPUSH
67635: PPUSH
67636: PPUSH
67637: PPUSH
67638: PPUSH
67639: PPUSH
67640: PPUSH
67641: PPUSH
67642: PPUSH
67643: PPUSH
67644: PPUSH
67645: PPUSH
67646: PPUSH
67647: PPUSH
67648: PPUSH
67649: PPUSH
67650: PPUSH
67651: PPUSH
67652: PPUSH
67653: PPUSH
67654: PPUSH
67655: PPUSH
67656: PPUSH
67657: PPUSH
67658: PPUSH
67659: PPUSH
67660: PPUSH
67661: PPUSH
67662: PPUSH
67663: PPUSH
67664: PPUSH
67665: PPUSH
67666: PPUSH
67667: PPUSH
67668: PPUSH
67669: PPUSH
67670: PPUSH
67671: PPUSH
67672: PPUSH
67673: PPUSH
67674: PPUSH
67675: PPUSH
67676: PPUSH
67677: PPUSH
67678: PPUSH
67679: PPUSH
67680: PPUSH
67681: PPUSH
67682: PPUSH
67683: PPUSH
67684: PPUSH
67685: PPUSH
67686: PPUSH
67687: PPUSH
67688: PPUSH
67689: PPUSH
67690: PPUSH
67691: PPUSH
// result = [ ] ;
67692: LD_ADDR_VAR 0 7
67696: PUSH
67697: EMPTY
67698: ST_TO_ADDR
// temp_list = [ ] ;
67699: LD_ADDR_VAR 0 9
67703: PUSH
67704: EMPTY
67705: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
67706: LD_VAR 0 4
67710: PUSH
67711: LD_INT 0
67713: PUSH
67714: LD_INT 1
67716: PUSH
67717: LD_INT 2
67719: PUSH
67720: LD_INT 3
67722: PUSH
67723: LD_INT 4
67725: PUSH
67726: LD_INT 5
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: IN
67737: NOT
67738: PUSH
67739: LD_VAR 0 1
67743: PUSH
67744: LD_INT 0
67746: PUSH
67747: LD_INT 1
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: IN
67754: PUSH
67755: LD_VAR 0 5
67759: PUSH
67760: LD_INT 1
67762: PUSH
67763: LD_INT 2
67765: PUSH
67766: LD_INT 3
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: LIST
67773: IN
67774: NOT
67775: AND
67776: OR
67777: IFFALSE 67781
// exit ;
67779: GO 86172
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
67781: LD_VAR 0 1
67785: PUSH
67786: LD_INT 6
67788: PUSH
67789: LD_INT 7
67791: PUSH
67792: LD_INT 8
67794: PUSH
67795: LD_INT 13
67797: PUSH
67798: LD_INT 12
67800: PUSH
67801: LD_INT 15
67803: PUSH
67804: LD_INT 11
67806: PUSH
67807: LD_INT 14
67809: PUSH
67810: LD_INT 10
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: LIST
67817: LIST
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: LIST
67823: IN
67824: IFFALSE 67834
// btype = b_lab ;
67826: LD_ADDR_VAR 0 1
67830: PUSH
67831: LD_INT 6
67833: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
67834: LD_VAR 0 6
67838: PUSH
67839: LD_INT 0
67841: PUSH
67842: LD_INT 1
67844: PUSH
67845: LD_INT 2
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: LIST
67852: IN
67853: NOT
67854: PUSH
67855: LD_VAR 0 1
67859: PUSH
67860: LD_INT 0
67862: PUSH
67863: LD_INT 1
67865: PUSH
67866: LD_INT 2
67868: PUSH
67869: LD_INT 3
67871: PUSH
67872: LD_INT 6
67874: PUSH
67875: LD_INT 36
67877: PUSH
67878: LD_INT 4
67880: PUSH
67881: LD_INT 5
67883: PUSH
67884: LD_INT 31
67886: PUSH
67887: LD_INT 32
67889: PUSH
67890: LD_INT 33
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: LIST
67897: LIST
67898: LIST
67899: LIST
67900: LIST
67901: LIST
67902: LIST
67903: LIST
67904: LIST
67905: IN
67906: NOT
67907: PUSH
67908: LD_VAR 0 6
67912: PUSH
67913: LD_INT 1
67915: EQUAL
67916: AND
67917: OR
67918: PUSH
67919: LD_VAR 0 1
67923: PUSH
67924: LD_INT 2
67926: PUSH
67927: LD_INT 3
67929: PUSH
67930: EMPTY
67931: LIST
67932: LIST
67933: IN
67934: NOT
67935: PUSH
67936: LD_VAR 0 6
67940: PUSH
67941: LD_INT 2
67943: EQUAL
67944: AND
67945: OR
67946: IFFALSE 67956
// mode = 0 ;
67948: LD_ADDR_VAR 0 6
67952: PUSH
67953: LD_INT 0
67955: ST_TO_ADDR
// case mode of 0 :
67956: LD_VAR 0 6
67960: PUSH
67961: LD_INT 0
67963: DOUBLE
67964: EQUAL
67965: IFTRUE 67969
67967: GO 79422
67969: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67970: LD_ADDR_VAR 0 11
67974: PUSH
67975: LD_INT 0
67977: PUSH
67978: LD_INT 0
67980: PUSH
67981: EMPTY
67982: LIST
67983: LIST
67984: PUSH
67985: LD_INT 0
67987: PUSH
67988: LD_INT 1
67990: NEG
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 1
67998: PUSH
67999: LD_INT 0
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 1
68008: PUSH
68009: LD_INT 1
68011: PUSH
68012: EMPTY
68013: LIST
68014: LIST
68015: PUSH
68016: LD_INT 0
68018: PUSH
68019: LD_INT 1
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PUSH
68026: LD_INT 1
68028: NEG
68029: PUSH
68030: LD_INT 0
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: LD_INT 1
68039: NEG
68040: PUSH
68041: LD_INT 1
68043: NEG
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: PUSH
68049: LD_INT 1
68051: NEG
68052: PUSH
68053: LD_INT 2
68055: NEG
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: PUSH
68061: LD_INT 0
68063: PUSH
68064: LD_INT 2
68066: NEG
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: PUSH
68072: LD_INT 1
68074: PUSH
68075: LD_INT 1
68077: NEG
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 1
68085: PUSH
68086: LD_INT 2
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: PUSH
68093: LD_INT 0
68095: PUSH
68096: LD_INT 2
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PUSH
68103: LD_INT 1
68105: NEG
68106: PUSH
68107: LD_INT 1
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 1
68116: PUSH
68117: LD_INT 3
68119: PUSH
68120: EMPTY
68121: LIST
68122: LIST
68123: PUSH
68124: LD_INT 0
68126: PUSH
68127: LD_INT 3
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: PUSH
68134: LD_INT 1
68136: NEG
68137: PUSH
68138: LD_INT 2
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68163: LD_ADDR_VAR 0 12
68167: PUSH
68168: LD_INT 0
68170: PUSH
68171: LD_INT 0
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PUSH
68178: LD_INT 0
68180: PUSH
68181: LD_INT 1
68183: NEG
68184: PUSH
68185: EMPTY
68186: LIST
68187: LIST
68188: PUSH
68189: LD_INT 1
68191: PUSH
68192: LD_INT 0
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: PUSH
68199: LD_INT 1
68201: PUSH
68202: LD_INT 1
68204: PUSH
68205: EMPTY
68206: LIST
68207: LIST
68208: PUSH
68209: LD_INT 0
68211: PUSH
68212: LD_INT 1
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: PUSH
68219: LD_INT 1
68221: NEG
68222: PUSH
68223: LD_INT 0
68225: PUSH
68226: EMPTY
68227: LIST
68228: LIST
68229: PUSH
68230: LD_INT 1
68232: NEG
68233: PUSH
68234: LD_INT 1
68236: NEG
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: LD_INT 1
68244: PUSH
68245: LD_INT 1
68247: NEG
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 2
68255: PUSH
68256: LD_INT 0
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 2
68265: PUSH
68266: LD_INT 1
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: PUSH
68273: LD_INT 1
68275: NEG
68276: PUSH
68277: LD_INT 1
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 2
68286: NEG
68287: PUSH
68288: LD_INT 0
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 2
68297: NEG
68298: PUSH
68299: LD_INT 1
68301: NEG
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 2
68309: NEG
68310: PUSH
68311: LD_INT 1
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 3
68320: NEG
68321: PUSH
68322: LD_INT 0
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: LD_INT 3
68331: NEG
68332: PUSH
68333: LD_INT 1
68335: NEG
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: LIST
68353: LIST
68354: LIST
68355: LIST
68356: LIST
68357: LIST
68358: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68359: LD_ADDR_VAR 0 13
68363: PUSH
68364: LD_INT 0
68366: PUSH
68367: LD_INT 0
68369: PUSH
68370: EMPTY
68371: LIST
68372: LIST
68373: PUSH
68374: LD_INT 0
68376: PUSH
68377: LD_INT 1
68379: NEG
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PUSH
68385: LD_INT 1
68387: PUSH
68388: LD_INT 0
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: PUSH
68395: LD_INT 1
68397: PUSH
68398: LD_INT 1
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 0
68407: PUSH
68408: LD_INT 1
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: PUSH
68415: LD_INT 1
68417: NEG
68418: PUSH
68419: LD_INT 0
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 1
68428: NEG
68429: PUSH
68430: LD_INT 1
68432: NEG
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 1
68440: NEG
68441: PUSH
68442: LD_INT 2
68444: NEG
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: LD_INT 2
68452: PUSH
68453: LD_INT 1
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 2
68462: PUSH
68463: LD_INT 2
68465: PUSH
68466: EMPTY
68467: LIST
68468: LIST
68469: PUSH
68470: LD_INT 1
68472: PUSH
68473: LD_INT 2
68475: PUSH
68476: EMPTY
68477: LIST
68478: LIST
68479: PUSH
68480: LD_INT 2
68482: NEG
68483: PUSH
68484: LD_INT 1
68486: NEG
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 2
68494: NEG
68495: PUSH
68496: LD_INT 2
68498: NEG
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 2
68506: NEG
68507: PUSH
68508: LD_INT 3
68510: NEG
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: LD_INT 3
68518: NEG
68519: PUSH
68520: LD_INT 2
68522: NEG
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 3
68530: NEG
68531: PUSH
68532: LD_INT 3
68534: NEG
68535: PUSH
68536: EMPTY
68537: LIST
68538: LIST
68539: PUSH
68540: EMPTY
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: LIST
68546: LIST
68547: LIST
68548: LIST
68549: LIST
68550: LIST
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: LIST
68556: LIST
68557: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
68558: LD_ADDR_VAR 0 14
68562: PUSH
68563: LD_INT 0
68565: PUSH
68566: LD_INT 0
68568: PUSH
68569: EMPTY
68570: LIST
68571: LIST
68572: PUSH
68573: LD_INT 0
68575: PUSH
68576: LD_INT 1
68578: NEG
68579: PUSH
68580: EMPTY
68581: LIST
68582: LIST
68583: PUSH
68584: LD_INT 1
68586: PUSH
68587: LD_INT 0
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: PUSH
68594: LD_INT 1
68596: PUSH
68597: LD_INT 1
68599: PUSH
68600: EMPTY
68601: LIST
68602: LIST
68603: PUSH
68604: LD_INT 0
68606: PUSH
68607: LD_INT 1
68609: PUSH
68610: EMPTY
68611: LIST
68612: LIST
68613: PUSH
68614: LD_INT 1
68616: NEG
68617: PUSH
68618: LD_INT 0
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: PUSH
68625: LD_INT 1
68627: NEG
68628: PUSH
68629: LD_INT 1
68631: NEG
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: LD_INT 1
68639: NEG
68640: PUSH
68641: LD_INT 2
68643: NEG
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: PUSH
68649: LD_INT 0
68651: PUSH
68652: LD_INT 2
68654: NEG
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: PUSH
68660: LD_INT 1
68662: PUSH
68663: LD_INT 1
68665: NEG
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 1
68673: PUSH
68674: LD_INT 2
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 0
68683: PUSH
68684: LD_INT 2
68686: PUSH
68687: EMPTY
68688: LIST
68689: LIST
68690: PUSH
68691: LD_INT 1
68693: NEG
68694: PUSH
68695: LD_INT 1
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: PUSH
68702: LD_INT 1
68704: NEG
68705: PUSH
68706: LD_INT 3
68708: NEG
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: PUSH
68714: LD_INT 0
68716: PUSH
68717: LD_INT 3
68719: NEG
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 1
68727: PUSH
68728: LD_INT 2
68730: NEG
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: LIST
68746: LIST
68747: LIST
68748: LIST
68749: LIST
68750: LIST
68751: LIST
68752: LIST
68753: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
68754: LD_ADDR_VAR 0 15
68758: PUSH
68759: LD_INT 0
68761: PUSH
68762: LD_INT 0
68764: PUSH
68765: EMPTY
68766: LIST
68767: LIST
68768: PUSH
68769: LD_INT 0
68771: PUSH
68772: LD_INT 1
68774: NEG
68775: PUSH
68776: EMPTY
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 1
68782: PUSH
68783: LD_INT 0
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: LD_INT 1
68792: PUSH
68793: LD_INT 1
68795: PUSH
68796: EMPTY
68797: LIST
68798: LIST
68799: PUSH
68800: LD_INT 0
68802: PUSH
68803: LD_INT 1
68805: PUSH
68806: EMPTY
68807: LIST
68808: LIST
68809: PUSH
68810: LD_INT 1
68812: NEG
68813: PUSH
68814: LD_INT 0
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 1
68823: NEG
68824: PUSH
68825: LD_INT 1
68827: NEG
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: LD_INT 1
68835: PUSH
68836: LD_INT 1
68838: NEG
68839: PUSH
68840: EMPTY
68841: LIST
68842: LIST
68843: PUSH
68844: LD_INT 2
68846: PUSH
68847: LD_INT 0
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: LD_INT 2
68856: PUSH
68857: LD_INT 1
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: PUSH
68864: LD_INT 1
68866: NEG
68867: PUSH
68868: LD_INT 1
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: PUSH
68875: LD_INT 2
68877: NEG
68878: PUSH
68879: LD_INT 0
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: LD_INT 2
68888: NEG
68889: PUSH
68890: LD_INT 1
68892: NEG
68893: PUSH
68894: EMPTY
68895: LIST
68896: LIST
68897: PUSH
68898: LD_INT 2
68900: PUSH
68901: LD_INT 1
68903: NEG
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PUSH
68909: LD_INT 3
68911: PUSH
68912: LD_INT 0
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 3
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: LIST
68933: LIST
68934: LIST
68935: LIST
68936: LIST
68937: LIST
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
68947: LD_ADDR_VAR 0 16
68951: PUSH
68952: LD_INT 0
68954: PUSH
68955: LD_INT 0
68957: PUSH
68958: EMPTY
68959: LIST
68960: LIST
68961: PUSH
68962: LD_INT 0
68964: PUSH
68965: LD_INT 1
68967: NEG
68968: PUSH
68969: EMPTY
68970: LIST
68971: LIST
68972: PUSH
68973: LD_INT 1
68975: PUSH
68976: LD_INT 0
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: LD_INT 1
68985: PUSH
68986: LD_INT 1
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 0
68995: PUSH
68996: LD_INT 1
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 1
69005: NEG
69006: PUSH
69007: LD_INT 0
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 1
69016: NEG
69017: PUSH
69018: LD_INT 1
69020: NEG
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PUSH
69026: LD_INT 1
69028: NEG
69029: PUSH
69030: LD_INT 2
69032: NEG
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 2
69040: PUSH
69041: LD_INT 1
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: LD_INT 2
69050: PUSH
69051: LD_INT 2
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PUSH
69058: LD_INT 1
69060: PUSH
69061: LD_INT 2
69063: PUSH
69064: EMPTY
69065: LIST
69066: LIST
69067: PUSH
69068: LD_INT 2
69070: NEG
69071: PUSH
69072: LD_INT 1
69074: NEG
69075: PUSH
69076: EMPTY
69077: LIST
69078: LIST
69079: PUSH
69080: LD_INT 2
69082: NEG
69083: PUSH
69084: LD_INT 2
69086: NEG
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 3
69094: PUSH
69095: LD_INT 2
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 3
69104: PUSH
69105: LD_INT 3
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 2
69114: PUSH
69115: LD_INT 3
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69140: LD_ADDR_VAR 0 17
69144: PUSH
69145: LD_INT 0
69147: PUSH
69148: LD_INT 0
69150: PUSH
69151: EMPTY
69152: LIST
69153: LIST
69154: PUSH
69155: LD_INT 0
69157: PUSH
69158: LD_INT 1
69160: NEG
69161: PUSH
69162: EMPTY
69163: LIST
69164: LIST
69165: PUSH
69166: LD_INT 1
69168: PUSH
69169: LD_INT 0
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: PUSH
69176: LD_INT 1
69178: PUSH
69179: LD_INT 1
69181: PUSH
69182: EMPTY
69183: LIST
69184: LIST
69185: PUSH
69186: LD_INT 0
69188: PUSH
69189: LD_INT 1
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PUSH
69196: LD_INT 1
69198: NEG
69199: PUSH
69200: LD_INT 0
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PUSH
69207: LD_INT 1
69209: NEG
69210: PUSH
69211: LD_INT 1
69213: NEG
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: PUSH
69219: LD_INT 1
69221: NEG
69222: PUSH
69223: LD_INT 2
69225: NEG
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PUSH
69231: LD_INT 0
69233: PUSH
69234: LD_INT 2
69236: NEG
69237: PUSH
69238: EMPTY
69239: LIST
69240: LIST
69241: PUSH
69242: LD_INT 1
69244: PUSH
69245: LD_INT 1
69247: NEG
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 2
69255: PUSH
69256: LD_INT 0
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 2
69265: PUSH
69266: LD_INT 1
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: LD_INT 2
69275: PUSH
69276: LD_INT 2
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 1
69285: PUSH
69286: LD_INT 2
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PUSH
69293: LD_INT 0
69295: PUSH
69296: LD_INT 2
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: PUSH
69303: LD_INT 1
69305: NEG
69306: PUSH
69307: LD_INT 1
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PUSH
69314: LD_INT 2
69316: NEG
69317: PUSH
69318: LD_INT 0
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 2
69327: NEG
69328: PUSH
69329: LD_INT 1
69331: NEG
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: LD_INT 2
69339: NEG
69340: PUSH
69341: LD_INT 2
69343: NEG
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: LIST
69367: LIST
69368: LIST
69369: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69370: LD_ADDR_VAR 0 18
69374: PUSH
69375: LD_INT 0
69377: PUSH
69378: LD_INT 0
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: LD_INT 0
69387: PUSH
69388: LD_INT 1
69390: NEG
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: PUSH
69396: LD_INT 1
69398: PUSH
69399: LD_INT 0
69401: PUSH
69402: EMPTY
69403: LIST
69404: LIST
69405: PUSH
69406: LD_INT 1
69408: PUSH
69409: LD_INT 1
69411: PUSH
69412: EMPTY
69413: LIST
69414: LIST
69415: PUSH
69416: LD_INT 0
69418: PUSH
69419: LD_INT 1
69421: PUSH
69422: EMPTY
69423: LIST
69424: LIST
69425: PUSH
69426: LD_INT 1
69428: NEG
69429: PUSH
69430: LD_INT 0
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 1
69439: NEG
69440: PUSH
69441: LD_INT 1
69443: NEG
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 1
69451: NEG
69452: PUSH
69453: LD_INT 2
69455: NEG
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 0
69463: PUSH
69464: LD_INT 2
69466: NEG
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 1
69474: PUSH
69475: LD_INT 1
69477: NEG
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: PUSH
69483: LD_INT 2
69485: PUSH
69486: LD_INT 0
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 2
69495: PUSH
69496: LD_INT 1
69498: PUSH
69499: EMPTY
69500: LIST
69501: LIST
69502: PUSH
69503: LD_INT 2
69505: PUSH
69506: LD_INT 2
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 1
69515: PUSH
69516: LD_INT 2
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: LD_INT 0
69525: PUSH
69526: LD_INT 2
69528: PUSH
69529: EMPTY
69530: LIST
69531: LIST
69532: PUSH
69533: LD_INT 1
69535: NEG
69536: PUSH
69537: LD_INT 1
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: LD_INT 2
69546: NEG
69547: PUSH
69548: LD_INT 0
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: PUSH
69555: LD_INT 2
69557: NEG
69558: PUSH
69559: LD_INT 1
69561: NEG
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 2
69569: NEG
69570: PUSH
69571: LD_INT 2
69573: NEG
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69600: LD_ADDR_VAR 0 19
69604: PUSH
69605: LD_INT 0
69607: PUSH
69608: LD_INT 0
69610: PUSH
69611: EMPTY
69612: LIST
69613: LIST
69614: PUSH
69615: LD_INT 0
69617: PUSH
69618: LD_INT 1
69620: NEG
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PUSH
69626: LD_INT 1
69628: PUSH
69629: LD_INT 0
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PUSH
69636: LD_INT 1
69638: PUSH
69639: LD_INT 1
69641: PUSH
69642: EMPTY
69643: LIST
69644: LIST
69645: PUSH
69646: LD_INT 0
69648: PUSH
69649: LD_INT 1
69651: PUSH
69652: EMPTY
69653: LIST
69654: LIST
69655: PUSH
69656: LD_INT 1
69658: NEG
69659: PUSH
69660: LD_INT 0
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 1
69669: NEG
69670: PUSH
69671: LD_INT 1
69673: NEG
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: PUSH
69679: LD_INT 1
69681: NEG
69682: PUSH
69683: LD_INT 2
69685: NEG
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: LD_INT 0
69693: PUSH
69694: LD_INT 2
69696: NEG
69697: PUSH
69698: EMPTY
69699: LIST
69700: LIST
69701: PUSH
69702: LD_INT 1
69704: PUSH
69705: LD_INT 1
69707: NEG
69708: PUSH
69709: EMPTY
69710: LIST
69711: LIST
69712: PUSH
69713: LD_INT 2
69715: PUSH
69716: LD_INT 0
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 2
69725: PUSH
69726: LD_INT 1
69728: PUSH
69729: EMPTY
69730: LIST
69731: LIST
69732: PUSH
69733: LD_INT 2
69735: PUSH
69736: LD_INT 2
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: PUSH
69743: LD_INT 1
69745: PUSH
69746: LD_INT 2
69748: PUSH
69749: EMPTY
69750: LIST
69751: LIST
69752: PUSH
69753: LD_INT 0
69755: PUSH
69756: LD_INT 2
69758: PUSH
69759: EMPTY
69760: LIST
69761: LIST
69762: PUSH
69763: LD_INT 1
69765: NEG
69766: PUSH
69767: LD_INT 1
69769: PUSH
69770: EMPTY
69771: LIST
69772: LIST
69773: PUSH
69774: LD_INT 2
69776: NEG
69777: PUSH
69778: LD_INT 0
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: PUSH
69785: LD_INT 2
69787: NEG
69788: PUSH
69789: LD_INT 1
69791: NEG
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 2
69799: NEG
69800: PUSH
69801: LD_INT 2
69803: NEG
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: LIST
69813: LIST
69814: LIST
69815: LIST
69816: LIST
69817: LIST
69818: LIST
69819: LIST
69820: LIST
69821: LIST
69822: LIST
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69830: LD_ADDR_VAR 0 20
69834: PUSH
69835: LD_INT 0
69837: PUSH
69838: LD_INT 0
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: PUSH
69845: LD_INT 0
69847: PUSH
69848: LD_INT 1
69850: NEG
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: PUSH
69856: LD_INT 1
69858: PUSH
69859: LD_INT 0
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: LD_INT 1
69868: PUSH
69869: LD_INT 1
69871: PUSH
69872: EMPTY
69873: LIST
69874: LIST
69875: PUSH
69876: LD_INT 0
69878: PUSH
69879: LD_INT 1
69881: PUSH
69882: EMPTY
69883: LIST
69884: LIST
69885: PUSH
69886: LD_INT 1
69888: NEG
69889: PUSH
69890: LD_INT 0
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 1
69899: NEG
69900: PUSH
69901: LD_INT 1
69903: NEG
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: LD_INT 1
69911: NEG
69912: PUSH
69913: LD_INT 2
69915: NEG
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 0
69923: PUSH
69924: LD_INT 2
69926: NEG
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PUSH
69932: LD_INT 1
69934: PUSH
69935: LD_INT 1
69937: NEG
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 2
69945: PUSH
69946: LD_INT 0
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PUSH
69953: LD_INT 2
69955: PUSH
69956: LD_INT 1
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: LD_INT 2
69965: PUSH
69966: LD_INT 2
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: PUSH
69973: LD_INT 1
69975: PUSH
69976: LD_INT 2
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PUSH
69983: LD_INT 0
69985: PUSH
69986: LD_INT 2
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 1
69995: NEG
69996: PUSH
69997: LD_INT 1
69999: PUSH
70000: EMPTY
70001: LIST
70002: LIST
70003: PUSH
70004: LD_INT 2
70006: NEG
70007: PUSH
70008: LD_INT 0
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: PUSH
70015: LD_INT 2
70017: NEG
70018: PUSH
70019: LD_INT 1
70021: NEG
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: PUSH
70027: LD_INT 2
70029: NEG
70030: PUSH
70031: LD_INT 2
70033: NEG
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: PUSH
70039: EMPTY
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: LIST
70053: LIST
70054: LIST
70055: LIST
70056: LIST
70057: LIST
70058: LIST
70059: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70060: LD_ADDR_VAR 0 21
70064: PUSH
70065: LD_INT 0
70067: PUSH
70068: LD_INT 0
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 0
70077: PUSH
70078: LD_INT 1
70080: NEG
70081: PUSH
70082: EMPTY
70083: LIST
70084: LIST
70085: PUSH
70086: LD_INT 1
70088: PUSH
70089: LD_INT 0
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: PUSH
70096: LD_INT 1
70098: PUSH
70099: LD_INT 1
70101: PUSH
70102: EMPTY
70103: LIST
70104: LIST
70105: PUSH
70106: LD_INT 0
70108: PUSH
70109: LD_INT 1
70111: PUSH
70112: EMPTY
70113: LIST
70114: LIST
70115: PUSH
70116: LD_INT 1
70118: NEG
70119: PUSH
70120: LD_INT 0
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: PUSH
70127: LD_INT 1
70129: NEG
70130: PUSH
70131: LD_INT 1
70133: NEG
70134: PUSH
70135: EMPTY
70136: LIST
70137: LIST
70138: PUSH
70139: LD_INT 1
70141: NEG
70142: PUSH
70143: LD_INT 2
70145: NEG
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: LD_INT 0
70153: PUSH
70154: LD_INT 2
70156: NEG
70157: PUSH
70158: EMPTY
70159: LIST
70160: LIST
70161: PUSH
70162: LD_INT 1
70164: PUSH
70165: LD_INT 1
70167: NEG
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 2
70175: PUSH
70176: LD_INT 0
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: PUSH
70183: LD_INT 2
70185: PUSH
70186: LD_INT 1
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 2
70195: PUSH
70196: LD_INT 2
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PUSH
70203: LD_INT 1
70205: PUSH
70206: LD_INT 2
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: PUSH
70213: LD_INT 0
70215: PUSH
70216: LD_INT 2
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: LD_INT 1
70225: NEG
70226: PUSH
70227: LD_INT 1
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 2
70236: NEG
70237: PUSH
70238: LD_INT 0
70240: PUSH
70241: EMPTY
70242: LIST
70243: LIST
70244: PUSH
70245: LD_INT 2
70247: NEG
70248: PUSH
70249: LD_INT 1
70251: NEG
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 2
70259: NEG
70260: PUSH
70261: LD_INT 2
70263: NEG
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: LIST
70288: LIST
70289: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70290: LD_ADDR_VAR 0 22
70294: PUSH
70295: LD_INT 0
70297: PUSH
70298: LD_INT 0
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 0
70307: PUSH
70308: LD_INT 1
70310: NEG
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 1
70318: PUSH
70319: LD_INT 0
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 1
70328: PUSH
70329: LD_INT 1
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 0
70338: PUSH
70339: LD_INT 1
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: LD_INT 1
70348: NEG
70349: PUSH
70350: LD_INT 0
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: PUSH
70357: LD_INT 1
70359: NEG
70360: PUSH
70361: LD_INT 1
70363: NEG
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: LD_INT 2
70375: NEG
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 0
70383: PUSH
70384: LD_INT 2
70386: NEG
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: PUSH
70395: LD_INT 1
70397: NEG
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: PUSH
70403: LD_INT 2
70405: PUSH
70406: LD_INT 0
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: LD_INT 2
70415: PUSH
70416: LD_INT 1
70418: PUSH
70419: EMPTY
70420: LIST
70421: LIST
70422: PUSH
70423: LD_INT 2
70425: PUSH
70426: LD_INT 2
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: LD_INT 1
70435: PUSH
70436: LD_INT 2
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 0
70445: PUSH
70446: LD_INT 2
70448: PUSH
70449: EMPTY
70450: LIST
70451: LIST
70452: PUSH
70453: LD_INT 1
70455: NEG
70456: PUSH
70457: LD_INT 1
70459: PUSH
70460: EMPTY
70461: LIST
70462: LIST
70463: PUSH
70464: LD_INT 2
70466: NEG
70467: PUSH
70468: LD_INT 0
70470: PUSH
70471: EMPTY
70472: LIST
70473: LIST
70474: PUSH
70475: LD_INT 2
70477: NEG
70478: PUSH
70479: LD_INT 1
70481: NEG
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 2
70489: NEG
70490: PUSH
70491: LD_INT 2
70493: NEG
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: LIST
70503: LIST
70504: LIST
70505: LIST
70506: LIST
70507: LIST
70508: LIST
70509: LIST
70510: LIST
70511: LIST
70512: LIST
70513: LIST
70514: LIST
70515: LIST
70516: LIST
70517: LIST
70518: LIST
70519: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
70520: LD_ADDR_VAR 0 23
70524: PUSH
70525: LD_INT 0
70527: PUSH
70528: LD_INT 0
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 0
70537: PUSH
70538: LD_INT 1
70540: NEG
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 1
70548: PUSH
70549: LD_INT 0
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 1
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 0
70568: PUSH
70569: LD_INT 1
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 1
70578: NEG
70579: PUSH
70580: LD_INT 0
70582: PUSH
70583: EMPTY
70584: LIST
70585: LIST
70586: PUSH
70587: LD_INT 1
70589: NEG
70590: PUSH
70591: LD_INT 1
70593: NEG
70594: PUSH
70595: EMPTY
70596: LIST
70597: LIST
70598: PUSH
70599: LD_INT 1
70601: NEG
70602: PUSH
70603: LD_INT 2
70605: NEG
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 0
70613: PUSH
70614: LD_INT 2
70616: NEG
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 1
70624: PUSH
70625: LD_INT 1
70627: NEG
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: LD_INT 2
70635: PUSH
70636: LD_INT 0
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 2
70645: PUSH
70646: LD_INT 1
70648: PUSH
70649: EMPTY
70650: LIST
70651: LIST
70652: PUSH
70653: LD_INT 2
70655: PUSH
70656: LD_INT 2
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 1
70665: PUSH
70666: LD_INT 2
70668: PUSH
70669: EMPTY
70670: LIST
70671: LIST
70672: PUSH
70673: LD_INT 0
70675: PUSH
70676: LD_INT 2
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: PUSH
70683: LD_INT 1
70685: NEG
70686: PUSH
70687: LD_INT 1
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: PUSH
70694: LD_INT 2
70696: NEG
70697: PUSH
70698: LD_INT 0
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: LD_INT 2
70707: NEG
70708: PUSH
70709: LD_INT 1
70711: NEG
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: LD_INT 2
70719: NEG
70720: PUSH
70721: LD_INT 2
70723: NEG
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: LD_INT 2
70731: NEG
70732: PUSH
70733: LD_INT 3
70735: NEG
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: PUSH
70741: LD_INT 1
70743: NEG
70744: PUSH
70745: LD_INT 3
70747: NEG
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: PUSH
70753: LD_INT 1
70755: PUSH
70756: LD_INT 2
70758: NEG
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 2
70766: PUSH
70767: LD_INT 1
70769: NEG
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
70800: LD_ADDR_VAR 0 24
70804: PUSH
70805: LD_INT 0
70807: PUSH
70808: LD_INT 0
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: PUSH
70815: LD_INT 0
70817: PUSH
70818: LD_INT 1
70820: NEG
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 1
70828: PUSH
70829: LD_INT 0
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: PUSH
70836: LD_INT 1
70838: PUSH
70839: LD_INT 1
70841: PUSH
70842: EMPTY
70843: LIST
70844: LIST
70845: PUSH
70846: LD_INT 0
70848: PUSH
70849: LD_INT 1
70851: PUSH
70852: EMPTY
70853: LIST
70854: LIST
70855: PUSH
70856: LD_INT 1
70858: NEG
70859: PUSH
70860: LD_INT 0
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PUSH
70867: LD_INT 1
70869: NEG
70870: PUSH
70871: LD_INT 1
70873: NEG
70874: PUSH
70875: EMPTY
70876: LIST
70877: LIST
70878: PUSH
70879: LD_INT 1
70881: NEG
70882: PUSH
70883: LD_INT 2
70885: NEG
70886: PUSH
70887: EMPTY
70888: LIST
70889: LIST
70890: PUSH
70891: LD_INT 0
70893: PUSH
70894: LD_INT 2
70896: NEG
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: PUSH
70902: LD_INT 1
70904: PUSH
70905: LD_INT 1
70907: NEG
70908: PUSH
70909: EMPTY
70910: LIST
70911: LIST
70912: PUSH
70913: LD_INT 2
70915: PUSH
70916: LD_INT 0
70918: PUSH
70919: EMPTY
70920: LIST
70921: LIST
70922: PUSH
70923: LD_INT 2
70925: PUSH
70926: LD_INT 1
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: LD_INT 2
70935: PUSH
70936: LD_INT 2
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 1
70945: PUSH
70946: LD_INT 2
70948: PUSH
70949: EMPTY
70950: LIST
70951: LIST
70952: PUSH
70953: LD_INT 0
70955: PUSH
70956: LD_INT 2
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 1
70965: NEG
70966: PUSH
70967: LD_INT 1
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: PUSH
70974: LD_INT 2
70976: NEG
70977: PUSH
70978: LD_INT 0
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: LD_INT 2
70987: NEG
70988: PUSH
70989: LD_INT 1
70991: NEG
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PUSH
70997: LD_INT 2
70999: NEG
71000: PUSH
71001: LD_INT 2
71003: NEG
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: PUSH
71009: LD_INT 1
71011: PUSH
71012: LD_INT 2
71014: NEG
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: PUSH
71020: LD_INT 2
71022: PUSH
71023: LD_INT 1
71025: NEG
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: PUSH
71031: LD_INT 3
71033: PUSH
71034: LD_INT 1
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: LD_INT 3
71043: PUSH
71044: LD_INT 2
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: LIST
71055: LIST
71056: LIST
71057: LIST
71058: LIST
71059: LIST
71060: LIST
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
71076: LD_ADDR_VAR 0 25
71080: PUSH
71081: LD_INT 0
71083: PUSH
71084: LD_INT 0
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 0
71093: PUSH
71094: LD_INT 1
71096: NEG
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PUSH
71102: LD_INT 1
71104: PUSH
71105: LD_INT 0
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 1
71114: PUSH
71115: LD_INT 1
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PUSH
71122: LD_INT 0
71124: PUSH
71125: LD_INT 1
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 1
71134: NEG
71135: PUSH
71136: LD_INT 0
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: LD_INT 1
71145: NEG
71146: PUSH
71147: LD_INT 1
71149: NEG
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: LD_INT 1
71157: NEG
71158: PUSH
71159: LD_INT 2
71161: NEG
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 0
71169: PUSH
71170: LD_INT 2
71172: NEG
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PUSH
71178: LD_INT 1
71180: PUSH
71181: LD_INT 1
71183: NEG
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 2
71191: PUSH
71192: LD_INT 0
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 2
71201: PUSH
71202: LD_INT 1
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PUSH
71209: LD_INT 2
71211: PUSH
71212: LD_INT 2
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PUSH
71219: LD_INT 1
71221: PUSH
71222: LD_INT 2
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 0
71231: PUSH
71232: LD_INT 2
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 1
71241: NEG
71242: PUSH
71243: LD_INT 1
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: PUSH
71250: LD_INT 2
71252: NEG
71253: PUSH
71254: LD_INT 0
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 2
71263: NEG
71264: PUSH
71265: LD_INT 1
71267: NEG
71268: PUSH
71269: EMPTY
71270: LIST
71271: LIST
71272: PUSH
71273: LD_INT 2
71275: NEG
71276: PUSH
71277: LD_INT 2
71279: NEG
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: LD_INT 3
71287: PUSH
71288: LD_INT 1
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: LD_INT 3
71297: PUSH
71298: LD_INT 2
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: PUSH
71305: LD_INT 2
71307: PUSH
71308: LD_INT 3
71310: PUSH
71311: EMPTY
71312: LIST
71313: LIST
71314: PUSH
71315: LD_INT 1
71317: PUSH
71318: LD_INT 3
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
71350: LD_ADDR_VAR 0 26
71354: PUSH
71355: LD_INT 0
71357: PUSH
71358: LD_INT 0
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 0
71367: PUSH
71368: LD_INT 1
71370: NEG
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 1
71378: PUSH
71379: LD_INT 0
71381: PUSH
71382: EMPTY
71383: LIST
71384: LIST
71385: PUSH
71386: LD_INT 1
71388: PUSH
71389: LD_INT 1
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: LD_INT 0
71398: PUSH
71399: LD_INT 1
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: PUSH
71406: LD_INT 1
71408: NEG
71409: PUSH
71410: LD_INT 0
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 1
71419: NEG
71420: PUSH
71421: LD_INT 1
71423: NEG
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: LD_INT 1
71431: NEG
71432: PUSH
71433: LD_INT 2
71435: NEG
71436: PUSH
71437: EMPTY
71438: LIST
71439: LIST
71440: PUSH
71441: LD_INT 0
71443: PUSH
71444: LD_INT 2
71446: NEG
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 1
71454: PUSH
71455: LD_INT 1
71457: NEG
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: PUSH
71463: LD_INT 2
71465: PUSH
71466: LD_INT 0
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 2
71475: PUSH
71476: LD_INT 1
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: PUSH
71483: LD_INT 2
71485: PUSH
71486: LD_INT 2
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: PUSH
71493: LD_INT 1
71495: PUSH
71496: LD_INT 2
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 0
71505: PUSH
71506: LD_INT 2
71508: PUSH
71509: EMPTY
71510: LIST
71511: LIST
71512: PUSH
71513: LD_INT 1
71515: NEG
71516: PUSH
71517: LD_INT 1
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PUSH
71524: LD_INT 2
71526: NEG
71527: PUSH
71528: LD_INT 0
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 2
71537: NEG
71538: PUSH
71539: LD_INT 1
71541: NEG
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 2
71549: NEG
71550: PUSH
71551: LD_INT 2
71553: NEG
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: PUSH
71559: LD_INT 2
71561: PUSH
71562: LD_INT 3
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 1
71571: PUSH
71572: LD_INT 3
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 1
71581: NEG
71582: PUSH
71583: LD_INT 2
71585: PUSH
71586: EMPTY
71587: LIST
71588: LIST
71589: PUSH
71590: LD_INT 2
71592: NEG
71593: PUSH
71594: LD_INT 1
71596: PUSH
71597: EMPTY
71598: LIST
71599: LIST
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: LIST
71605: LIST
71606: LIST
71607: LIST
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: LIST
71624: LIST
71625: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71626: LD_ADDR_VAR 0 27
71630: PUSH
71631: LD_INT 0
71633: PUSH
71634: LD_INT 0
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 0
71643: PUSH
71644: LD_INT 1
71646: NEG
71647: PUSH
71648: EMPTY
71649: LIST
71650: LIST
71651: PUSH
71652: LD_INT 1
71654: PUSH
71655: LD_INT 0
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 1
71664: PUSH
71665: LD_INT 1
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 0
71674: PUSH
71675: LD_INT 1
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 1
71684: NEG
71685: PUSH
71686: LD_INT 0
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: LD_INT 1
71695: NEG
71696: PUSH
71697: LD_INT 1
71699: NEG
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: LD_INT 1
71707: NEG
71708: PUSH
71709: LD_INT 2
71711: NEG
71712: PUSH
71713: EMPTY
71714: LIST
71715: LIST
71716: PUSH
71717: LD_INT 0
71719: PUSH
71720: LD_INT 2
71722: NEG
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 1
71730: PUSH
71731: LD_INT 1
71733: NEG
71734: PUSH
71735: EMPTY
71736: LIST
71737: LIST
71738: PUSH
71739: LD_INT 2
71741: PUSH
71742: LD_INT 0
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 2
71751: PUSH
71752: LD_INT 1
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: LD_INT 2
71761: PUSH
71762: LD_INT 2
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 1
71771: PUSH
71772: LD_INT 2
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: PUSH
71779: LD_INT 0
71781: PUSH
71782: LD_INT 2
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: PUSH
71789: LD_INT 1
71791: NEG
71792: PUSH
71793: LD_INT 1
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 2
71802: NEG
71803: PUSH
71804: LD_INT 0
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: PUSH
71811: LD_INT 2
71813: NEG
71814: PUSH
71815: LD_INT 1
71817: NEG
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: PUSH
71823: LD_INT 2
71825: NEG
71826: PUSH
71827: LD_INT 2
71829: NEG
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PUSH
71835: LD_INT 1
71837: NEG
71838: PUSH
71839: LD_INT 2
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 2
71848: NEG
71849: PUSH
71850: LD_INT 1
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 3
71859: NEG
71860: PUSH
71861: LD_INT 1
71863: NEG
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 3
71871: NEG
71872: PUSH
71873: LD_INT 2
71875: NEG
71876: PUSH
71877: EMPTY
71878: LIST
71879: LIST
71880: PUSH
71881: EMPTY
71882: LIST
71883: LIST
71884: LIST
71885: LIST
71886: LIST
71887: LIST
71888: LIST
71889: LIST
71890: LIST
71891: LIST
71892: LIST
71893: LIST
71894: LIST
71895: LIST
71896: LIST
71897: LIST
71898: LIST
71899: LIST
71900: LIST
71901: LIST
71902: LIST
71903: LIST
71904: LIST
71905: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71906: LD_ADDR_VAR 0 28
71910: PUSH
71911: LD_INT 0
71913: PUSH
71914: LD_INT 0
71916: PUSH
71917: EMPTY
71918: LIST
71919: LIST
71920: PUSH
71921: LD_INT 0
71923: PUSH
71924: LD_INT 1
71926: NEG
71927: PUSH
71928: EMPTY
71929: LIST
71930: LIST
71931: PUSH
71932: LD_INT 1
71934: PUSH
71935: LD_INT 0
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: PUSH
71942: LD_INT 1
71944: PUSH
71945: LD_INT 1
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 0
71954: PUSH
71955: LD_INT 1
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PUSH
71962: LD_INT 1
71964: NEG
71965: PUSH
71966: LD_INT 0
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: LD_INT 1
71975: NEG
71976: PUSH
71977: LD_INT 1
71979: NEG
71980: PUSH
71981: EMPTY
71982: LIST
71983: LIST
71984: PUSH
71985: LD_INT 1
71987: NEG
71988: PUSH
71989: LD_INT 2
71991: NEG
71992: PUSH
71993: EMPTY
71994: LIST
71995: LIST
71996: PUSH
71997: LD_INT 0
71999: PUSH
72000: LD_INT 2
72002: NEG
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 1
72010: PUSH
72011: LD_INT 1
72013: NEG
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: PUSH
72019: LD_INT 2
72021: PUSH
72022: LD_INT 0
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 2
72031: PUSH
72032: LD_INT 1
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: PUSH
72039: LD_INT 2
72041: PUSH
72042: LD_INT 2
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: LD_INT 1
72051: PUSH
72052: LD_INT 2
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: LD_INT 0
72061: PUSH
72062: LD_INT 2
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: PUSH
72069: LD_INT 1
72071: NEG
72072: PUSH
72073: LD_INT 1
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: PUSH
72080: LD_INT 2
72082: NEG
72083: PUSH
72084: LD_INT 0
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: PUSH
72091: LD_INT 2
72093: NEG
72094: PUSH
72095: LD_INT 1
72097: NEG
72098: PUSH
72099: EMPTY
72100: LIST
72101: LIST
72102: PUSH
72103: LD_INT 2
72105: NEG
72106: PUSH
72107: LD_INT 2
72109: NEG
72110: PUSH
72111: EMPTY
72112: LIST
72113: LIST
72114: PUSH
72115: LD_INT 2
72117: NEG
72118: PUSH
72119: LD_INT 3
72121: NEG
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 1
72129: NEG
72130: PUSH
72131: LD_INT 3
72133: NEG
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PUSH
72139: LD_INT 3
72141: NEG
72142: PUSH
72143: LD_INT 1
72145: NEG
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 3
72153: NEG
72154: PUSH
72155: LD_INT 2
72157: NEG
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: LIST
72167: LIST
72168: LIST
72169: LIST
72170: LIST
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: LIST
72176: LIST
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72188: LD_ADDR_VAR 0 29
72192: PUSH
72193: LD_INT 0
72195: PUSH
72196: LD_INT 0
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: PUSH
72203: LD_INT 0
72205: PUSH
72206: LD_INT 1
72208: NEG
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: PUSH
72214: LD_INT 1
72216: PUSH
72217: LD_INT 0
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 1
72226: PUSH
72227: LD_INT 1
72229: PUSH
72230: EMPTY
72231: LIST
72232: LIST
72233: PUSH
72234: LD_INT 0
72236: PUSH
72237: LD_INT 1
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: PUSH
72244: LD_INT 1
72246: NEG
72247: PUSH
72248: LD_INT 0
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 1
72257: NEG
72258: PUSH
72259: LD_INT 1
72261: NEG
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 1
72269: NEG
72270: PUSH
72271: LD_INT 2
72273: NEG
72274: PUSH
72275: EMPTY
72276: LIST
72277: LIST
72278: PUSH
72279: LD_INT 0
72281: PUSH
72282: LD_INT 2
72284: NEG
72285: PUSH
72286: EMPTY
72287: LIST
72288: LIST
72289: PUSH
72290: LD_INT 1
72292: PUSH
72293: LD_INT 1
72295: NEG
72296: PUSH
72297: EMPTY
72298: LIST
72299: LIST
72300: PUSH
72301: LD_INT 2
72303: PUSH
72304: LD_INT 0
72306: PUSH
72307: EMPTY
72308: LIST
72309: LIST
72310: PUSH
72311: LD_INT 2
72313: PUSH
72314: LD_INT 1
72316: PUSH
72317: EMPTY
72318: LIST
72319: LIST
72320: PUSH
72321: LD_INT 1
72323: PUSH
72324: LD_INT 2
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: PUSH
72331: LD_INT 0
72333: PUSH
72334: LD_INT 2
72336: PUSH
72337: EMPTY
72338: LIST
72339: LIST
72340: PUSH
72341: LD_INT 1
72343: NEG
72344: PUSH
72345: LD_INT 1
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: PUSH
72352: LD_INT 2
72354: NEG
72355: PUSH
72356: LD_INT 1
72358: NEG
72359: PUSH
72360: EMPTY
72361: LIST
72362: LIST
72363: PUSH
72364: LD_INT 2
72366: NEG
72367: PUSH
72368: LD_INT 2
72370: NEG
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: LD_INT 2
72378: NEG
72379: PUSH
72380: LD_INT 3
72382: NEG
72383: PUSH
72384: EMPTY
72385: LIST
72386: LIST
72387: PUSH
72388: LD_INT 2
72390: PUSH
72391: LD_INT 1
72393: NEG
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 3
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 1
72411: PUSH
72412: LD_INT 3
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: PUSH
72419: LD_INT 1
72421: NEG
72422: PUSH
72423: LD_INT 2
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 3
72432: NEG
72433: PUSH
72434: LD_INT 2
72436: NEG
72437: PUSH
72438: EMPTY
72439: LIST
72440: LIST
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72467: LD_ADDR_VAR 0 30
72471: PUSH
72472: LD_INT 0
72474: PUSH
72475: LD_INT 0
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 0
72484: PUSH
72485: LD_INT 1
72487: NEG
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: LD_INT 1
72495: PUSH
72496: LD_INT 0
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 1
72505: PUSH
72506: LD_INT 1
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 0
72515: PUSH
72516: LD_INT 1
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 1
72525: NEG
72526: PUSH
72527: LD_INT 0
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 1
72536: NEG
72537: PUSH
72538: LD_INT 1
72540: NEG
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 1
72548: NEG
72549: PUSH
72550: LD_INT 2
72552: NEG
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: PUSH
72558: LD_INT 0
72560: PUSH
72561: LD_INT 2
72563: NEG
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: PUSH
72569: LD_INT 1
72571: PUSH
72572: LD_INT 1
72574: NEG
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 2
72582: PUSH
72583: LD_INT 0
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: PUSH
72590: LD_INT 2
72592: PUSH
72593: LD_INT 1
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 2
72602: PUSH
72603: LD_INT 2
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 1
72612: PUSH
72613: LD_INT 2
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 1
72622: NEG
72623: PUSH
72624: LD_INT 1
72626: PUSH
72627: EMPTY
72628: LIST
72629: LIST
72630: PUSH
72631: LD_INT 2
72633: NEG
72634: PUSH
72635: LD_INT 0
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PUSH
72642: LD_INT 2
72644: NEG
72645: PUSH
72646: LD_INT 1
72648: NEG
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: LD_INT 1
72656: NEG
72657: PUSH
72658: LD_INT 3
72660: NEG
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 1
72668: PUSH
72669: LD_INT 2
72671: NEG
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: PUSH
72677: LD_INT 3
72679: PUSH
72680: LD_INT 2
72682: PUSH
72683: EMPTY
72684: LIST
72685: LIST
72686: PUSH
72687: LD_INT 2
72689: PUSH
72690: LD_INT 3
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 2
72699: NEG
72700: PUSH
72701: LD_INT 1
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 3
72710: NEG
72711: PUSH
72712: LD_INT 1
72714: NEG
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: LIST
72724: LIST
72725: LIST
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: LIST
72733: LIST
72734: LIST
72735: LIST
72736: LIST
72737: LIST
72738: LIST
72739: LIST
72740: LIST
72741: LIST
72742: LIST
72743: LIST
72744: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72745: LD_ADDR_VAR 0 31
72749: PUSH
72750: LD_INT 0
72752: PUSH
72753: LD_INT 0
72755: PUSH
72756: EMPTY
72757: LIST
72758: LIST
72759: PUSH
72760: LD_INT 0
72762: PUSH
72763: LD_INT 1
72765: NEG
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: LD_INT 1
72773: PUSH
72774: LD_INT 0
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 1
72783: PUSH
72784: LD_INT 1
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 0
72793: PUSH
72794: LD_INT 1
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 1
72803: NEG
72804: PUSH
72805: LD_INT 0
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: PUSH
72812: LD_INT 1
72814: NEG
72815: PUSH
72816: LD_INT 1
72818: NEG
72819: PUSH
72820: EMPTY
72821: LIST
72822: LIST
72823: PUSH
72824: LD_INT 1
72826: NEG
72827: PUSH
72828: LD_INT 2
72830: NEG
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: PUSH
72836: LD_INT 1
72838: PUSH
72839: LD_INT 1
72841: NEG
72842: PUSH
72843: EMPTY
72844: LIST
72845: LIST
72846: PUSH
72847: LD_INT 2
72849: PUSH
72850: LD_INT 0
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 2
72859: PUSH
72860: LD_INT 1
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 2
72869: PUSH
72870: LD_INT 2
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 1
72879: PUSH
72880: LD_INT 2
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 0
72889: PUSH
72890: LD_INT 2
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 1
72899: NEG
72900: PUSH
72901: LD_INT 1
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 2
72910: NEG
72911: PUSH
72912: LD_INT 1
72914: NEG
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: PUSH
72920: LD_INT 2
72922: NEG
72923: PUSH
72924: LD_INT 2
72926: NEG
72927: PUSH
72928: EMPTY
72929: LIST
72930: LIST
72931: PUSH
72932: LD_INT 2
72934: NEG
72935: PUSH
72936: LD_INT 3
72938: NEG
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: LD_INT 2
72946: PUSH
72947: LD_INT 1
72949: NEG
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 3
72957: PUSH
72958: LD_INT 1
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 1
72967: PUSH
72968: LD_INT 3
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: LD_INT 1
72977: NEG
72978: PUSH
72979: LD_INT 2
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 3
72988: NEG
72989: PUSH
72990: LD_INT 2
72992: NEG
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: LIST
73015: LIST
73016: LIST
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: LIST
73022: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73023: LD_ADDR_VAR 0 32
73027: PUSH
73028: LD_INT 0
73030: PUSH
73031: LD_INT 0
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 0
73040: PUSH
73041: LD_INT 1
73043: NEG
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 1
73051: PUSH
73052: LD_INT 0
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 1
73061: PUSH
73062: LD_INT 1
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 0
73071: PUSH
73072: LD_INT 1
73074: PUSH
73075: EMPTY
73076: LIST
73077: LIST
73078: PUSH
73079: LD_INT 1
73081: NEG
73082: PUSH
73083: LD_INT 0
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 1
73092: NEG
73093: PUSH
73094: LD_INT 1
73096: NEG
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: LD_INT 1
73104: NEG
73105: PUSH
73106: LD_INT 2
73108: NEG
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: LD_INT 0
73116: PUSH
73117: LD_INT 2
73119: NEG
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: PUSH
73125: LD_INT 1
73127: PUSH
73128: LD_INT 1
73130: NEG
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 2
73138: PUSH
73139: LD_INT 1
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: PUSH
73146: LD_INT 2
73148: PUSH
73149: LD_INT 2
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: PUSH
73156: LD_INT 1
73158: PUSH
73159: LD_INT 2
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: PUSH
73166: LD_INT 0
73168: PUSH
73169: LD_INT 2
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 1
73178: NEG
73179: PUSH
73180: LD_INT 1
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: LD_INT 2
73189: NEG
73190: PUSH
73191: LD_INT 0
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 2
73200: NEG
73201: PUSH
73202: LD_INT 1
73204: NEG
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: PUSH
73210: LD_INT 1
73212: NEG
73213: PUSH
73214: LD_INT 3
73216: NEG
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: LD_INT 1
73224: PUSH
73225: LD_INT 2
73227: NEG
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 3
73235: PUSH
73236: LD_INT 2
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 2
73245: PUSH
73246: LD_INT 3
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 2
73255: NEG
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PUSH
73264: LD_INT 3
73266: NEG
73267: PUSH
73268: LD_INT 1
73270: NEG
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: LIST
73296: LIST
73297: LIST
73298: LIST
73299: LIST
73300: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73301: LD_ADDR_VAR 0 33
73305: PUSH
73306: LD_INT 0
73308: PUSH
73309: LD_INT 0
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PUSH
73316: LD_INT 0
73318: PUSH
73319: LD_INT 1
73321: NEG
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: PUSH
73327: LD_INT 1
73329: PUSH
73330: LD_INT 0
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: PUSH
73337: LD_INT 1
73339: PUSH
73340: LD_INT 1
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: LD_INT 0
73349: PUSH
73350: LD_INT 1
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PUSH
73357: LD_INT 1
73359: NEG
73360: PUSH
73361: LD_INT 0
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: PUSH
73368: LD_INT 1
73370: NEG
73371: PUSH
73372: LD_INT 1
73374: NEG
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PUSH
73380: LD_INT 1
73382: NEG
73383: PUSH
73384: LD_INT 2
73386: NEG
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: PUSH
73392: LD_INT 1
73394: PUSH
73395: LD_INT 1
73397: NEG
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 2
73405: PUSH
73406: LD_INT 0
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 2
73415: PUSH
73416: LD_INT 1
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: PUSH
73423: LD_INT 1
73425: PUSH
73426: LD_INT 2
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 0
73435: PUSH
73436: LD_INT 2
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 1
73445: NEG
73446: PUSH
73447: LD_INT 1
73449: PUSH
73450: EMPTY
73451: LIST
73452: LIST
73453: PUSH
73454: LD_INT 2
73456: NEG
73457: PUSH
73458: LD_INT 0
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 2
73467: NEG
73468: PUSH
73469: LD_INT 1
73471: NEG
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: LD_INT 2
73479: NEG
73480: PUSH
73481: LD_INT 2
73483: NEG
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: LD_INT 2
73491: NEG
73492: PUSH
73493: LD_INT 3
73495: NEG
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PUSH
73501: LD_INT 2
73503: PUSH
73504: LD_INT 1
73506: NEG
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: PUSH
73512: LD_INT 3
73514: PUSH
73515: LD_INT 1
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 1
73524: PUSH
73525: LD_INT 3
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PUSH
73532: LD_INT 1
73534: NEG
73535: PUSH
73536: LD_INT 2
73538: PUSH
73539: EMPTY
73540: LIST
73541: LIST
73542: PUSH
73543: LD_INT 3
73545: NEG
73546: PUSH
73547: LD_INT 2
73549: NEG
73550: PUSH
73551: EMPTY
73552: LIST
73553: LIST
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: LIST
73577: LIST
73578: LIST
73579: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73580: LD_ADDR_VAR 0 34
73584: PUSH
73585: LD_INT 0
73587: PUSH
73588: LD_INT 0
73590: PUSH
73591: EMPTY
73592: LIST
73593: LIST
73594: PUSH
73595: LD_INT 0
73597: PUSH
73598: LD_INT 1
73600: NEG
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 1
73608: PUSH
73609: LD_INT 0
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: LD_INT 1
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: LD_INT 0
73628: PUSH
73629: LD_INT 1
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 1
73638: NEG
73639: PUSH
73640: LD_INT 0
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 1
73649: NEG
73650: PUSH
73651: LD_INT 1
73653: NEG
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 1
73661: NEG
73662: PUSH
73663: LD_INT 2
73665: NEG
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 0
73673: PUSH
73674: LD_INT 2
73676: NEG
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: PUSH
73685: LD_INT 1
73687: NEG
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 2
73695: PUSH
73696: LD_INT 1
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 2
73705: PUSH
73706: LD_INT 2
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: LD_INT 1
73715: PUSH
73716: LD_INT 2
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 1
73725: NEG
73726: PUSH
73727: LD_INT 1
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: PUSH
73734: LD_INT 2
73736: NEG
73737: PUSH
73738: LD_INT 0
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 2
73747: NEG
73748: PUSH
73749: LD_INT 1
73751: NEG
73752: PUSH
73753: EMPTY
73754: LIST
73755: LIST
73756: PUSH
73757: LD_INT 2
73759: NEG
73760: PUSH
73761: LD_INT 2
73763: NEG
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: PUSH
73769: LD_INT 1
73771: NEG
73772: PUSH
73773: LD_INT 3
73775: NEG
73776: PUSH
73777: EMPTY
73778: LIST
73779: LIST
73780: PUSH
73781: LD_INT 1
73783: PUSH
73784: LD_INT 2
73786: NEG
73787: PUSH
73788: EMPTY
73789: LIST
73790: LIST
73791: PUSH
73792: LD_INT 3
73794: PUSH
73795: LD_INT 2
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: PUSH
73802: LD_INT 2
73804: PUSH
73805: LD_INT 3
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 2
73814: NEG
73815: PUSH
73816: LD_INT 1
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 3
73825: NEG
73826: PUSH
73827: LD_INT 1
73829: NEG
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: LIST
73846: LIST
73847: LIST
73848: LIST
73849: LIST
73850: LIST
73851: LIST
73852: LIST
73853: LIST
73854: LIST
73855: LIST
73856: LIST
73857: LIST
73858: LIST
73859: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
73860: LD_ADDR_VAR 0 35
73864: PUSH
73865: LD_INT 0
73867: PUSH
73868: LD_INT 0
73870: PUSH
73871: EMPTY
73872: LIST
73873: LIST
73874: PUSH
73875: LD_INT 0
73877: PUSH
73878: LD_INT 1
73880: NEG
73881: PUSH
73882: EMPTY
73883: LIST
73884: LIST
73885: PUSH
73886: LD_INT 1
73888: PUSH
73889: LD_INT 0
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: PUSH
73896: LD_INT 1
73898: PUSH
73899: LD_INT 1
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: PUSH
73906: LD_INT 0
73908: PUSH
73909: LD_INT 1
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: PUSH
73916: LD_INT 1
73918: NEG
73919: PUSH
73920: LD_INT 0
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 1
73929: NEG
73930: PUSH
73931: LD_INT 1
73933: NEG
73934: PUSH
73935: EMPTY
73936: LIST
73937: LIST
73938: PUSH
73939: LD_INT 2
73941: PUSH
73942: LD_INT 1
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: LD_INT 2
73951: NEG
73952: PUSH
73953: LD_INT 1
73955: NEG
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: LIST
73965: LIST
73966: LIST
73967: LIST
73968: LIST
73969: LIST
73970: LIST
73971: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73972: LD_ADDR_VAR 0 36
73976: PUSH
73977: LD_INT 0
73979: PUSH
73980: LD_INT 0
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: PUSH
73987: LD_INT 0
73989: PUSH
73990: LD_INT 1
73992: NEG
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: LD_INT 1
74000: PUSH
74001: LD_INT 0
74003: PUSH
74004: EMPTY
74005: LIST
74006: LIST
74007: PUSH
74008: LD_INT 1
74010: PUSH
74011: LD_INT 1
74013: PUSH
74014: EMPTY
74015: LIST
74016: LIST
74017: PUSH
74018: LD_INT 0
74020: PUSH
74021: LD_INT 1
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 1
74030: NEG
74031: PUSH
74032: LD_INT 0
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: LD_INT 1
74041: NEG
74042: PUSH
74043: LD_INT 1
74045: NEG
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: LD_INT 1
74053: NEG
74054: PUSH
74055: LD_INT 2
74057: NEG
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: PUSH
74063: LD_INT 1
74065: PUSH
74066: LD_INT 2
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: LIST
74077: LIST
74078: LIST
74079: LIST
74080: LIST
74081: LIST
74082: LIST
74083: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74084: LD_ADDR_VAR 0 37
74088: PUSH
74089: LD_INT 0
74091: PUSH
74092: LD_INT 0
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: LD_INT 0
74101: PUSH
74102: LD_INT 1
74104: NEG
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 1
74112: PUSH
74113: LD_INT 0
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 1
74122: PUSH
74123: LD_INT 1
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 0
74132: PUSH
74133: LD_INT 1
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 1
74142: NEG
74143: PUSH
74144: LD_INT 0
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: PUSH
74151: LD_INT 1
74153: NEG
74154: PUSH
74155: LD_INT 1
74157: NEG
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_INT 1
74165: PUSH
74166: LD_INT 1
74168: NEG
74169: PUSH
74170: EMPTY
74171: LIST
74172: LIST
74173: PUSH
74174: LD_INT 1
74176: NEG
74177: PUSH
74178: LD_INT 1
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: LIST
74189: LIST
74190: LIST
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
74196: LD_ADDR_VAR 0 38
74200: PUSH
74201: LD_INT 0
74203: PUSH
74204: LD_INT 0
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: LD_INT 0
74213: PUSH
74214: LD_INT 1
74216: NEG
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 1
74224: PUSH
74225: LD_INT 0
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 1
74234: PUSH
74235: LD_INT 1
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: LD_INT 1
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 1
74254: NEG
74255: PUSH
74256: LD_INT 0
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: NEG
74266: PUSH
74267: LD_INT 1
74269: NEG
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 2
74277: PUSH
74278: LD_INT 1
74280: PUSH
74281: EMPTY
74282: LIST
74283: LIST
74284: PUSH
74285: LD_INT 2
74287: NEG
74288: PUSH
74289: LD_INT 1
74291: NEG
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: LIST
74305: LIST
74306: LIST
74307: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
74308: LD_ADDR_VAR 0 39
74312: PUSH
74313: LD_INT 0
74315: PUSH
74316: LD_INT 0
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: PUSH
74323: LD_INT 0
74325: PUSH
74326: LD_INT 1
74328: NEG
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 1
74336: PUSH
74337: LD_INT 0
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: LD_INT 1
74346: PUSH
74347: LD_INT 1
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: PUSH
74354: LD_INT 0
74356: PUSH
74357: LD_INT 1
74359: PUSH
74360: EMPTY
74361: LIST
74362: LIST
74363: PUSH
74364: LD_INT 1
74366: NEG
74367: PUSH
74368: LD_INT 0
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: LD_INT 1
74377: NEG
74378: PUSH
74379: LD_INT 1
74381: NEG
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PUSH
74387: LD_INT 1
74389: NEG
74390: PUSH
74391: LD_INT 2
74393: NEG
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: LD_INT 1
74401: PUSH
74402: LD_INT 2
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74420: LD_ADDR_VAR 0 40
74424: PUSH
74425: LD_INT 0
74427: PUSH
74428: LD_INT 0
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PUSH
74435: LD_INT 0
74437: PUSH
74438: LD_INT 1
74440: NEG
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: PUSH
74446: LD_INT 1
74448: PUSH
74449: LD_INT 0
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: LD_INT 1
74458: PUSH
74459: LD_INT 1
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PUSH
74466: LD_INT 0
74468: PUSH
74469: LD_INT 1
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 1
74478: NEG
74479: PUSH
74480: LD_INT 0
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PUSH
74487: LD_INT 1
74489: NEG
74490: PUSH
74491: LD_INT 1
74493: NEG
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 1
74501: PUSH
74502: LD_INT 1
74504: NEG
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: LD_INT 1
74512: NEG
74513: PUSH
74514: LD_INT 1
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: LIST
74529: LIST
74530: LIST
74531: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74532: LD_ADDR_VAR 0 41
74536: PUSH
74537: LD_INT 0
74539: PUSH
74540: LD_INT 0
74542: PUSH
74543: EMPTY
74544: LIST
74545: LIST
74546: PUSH
74547: LD_INT 0
74549: PUSH
74550: LD_INT 1
74552: NEG
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: LD_INT 1
74560: PUSH
74561: LD_INT 0
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PUSH
74568: LD_INT 1
74570: PUSH
74571: LD_INT 1
74573: PUSH
74574: EMPTY
74575: LIST
74576: LIST
74577: PUSH
74578: LD_INT 0
74580: PUSH
74581: LD_INT 1
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: PUSH
74588: LD_INT 1
74590: NEG
74591: PUSH
74592: LD_INT 0
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: PUSH
74599: LD_INT 1
74601: NEG
74602: PUSH
74603: LD_INT 1
74605: NEG
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: LD_INT 1
74613: NEG
74614: PUSH
74615: LD_INT 2
74617: NEG
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: PUSH
74623: LD_INT 1
74625: PUSH
74626: LD_INT 1
74628: NEG
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: PUSH
74634: LD_INT 2
74636: PUSH
74637: LD_INT 0
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 2
74646: PUSH
74647: LD_INT 1
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 2
74656: PUSH
74657: LD_INT 2
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: LD_INT 1
74666: PUSH
74667: LD_INT 2
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 1
74676: NEG
74677: PUSH
74678: LD_INT 1
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: PUSH
74685: LD_INT 2
74687: NEG
74688: PUSH
74689: LD_INT 0
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PUSH
74696: LD_INT 2
74698: NEG
74699: PUSH
74700: LD_INT 1
74702: NEG
74703: PUSH
74704: EMPTY
74705: LIST
74706: LIST
74707: PUSH
74708: LD_INT 2
74710: NEG
74711: PUSH
74712: LD_INT 2
74714: NEG
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 2
74722: NEG
74723: PUSH
74724: LD_INT 3
74726: NEG
74727: PUSH
74728: EMPTY
74729: LIST
74730: LIST
74731: PUSH
74732: LD_INT 2
74734: PUSH
74735: LD_INT 1
74737: NEG
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: PUSH
74743: LD_INT 3
74745: PUSH
74746: LD_INT 0
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: PUSH
74753: LD_INT 3
74755: PUSH
74756: LD_INT 1
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: PUSH
74763: LD_INT 3
74765: PUSH
74766: LD_INT 2
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: PUSH
74773: LD_INT 3
74775: PUSH
74776: LD_INT 3
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: LD_INT 2
74785: PUSH
74786: LD_INT 3
74788: PUSH
74789: EMPTY
74790: LIST
74791: LIST
74792: PUSH
74793: LD_INT 2
74795: NEG
74796: PUSH
74797: LD_INT 1
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: PUSH
74804: LD_INT 3
74806: NEG
74807: PUSH
74808: LD_INT 0
74810: PUSH
74811: EMPTY
74812: LIST
74813: LIST
74814: PUSH
74815: LD_INT 3
74817: NEG
74818: PUSH
74819: LD_INT 1
74821: NEG
74822: PUSH
74823: EMPTY
74824: LIST
74825: LIST
74826: PUSH
74827: LD_INT 3
74829: NEG
74830: PUSH
74831: LD_INT 2
74833: NEG
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 3
74841: NEG
74842: PUSH
74843: LD_INT 3
74845: NEG
74846: PUSH
74847: EMPTY
74848: LIST
74849: LIST
74850: PUSH
74851: EMPTY
74852: LIST
74853: LIST
74854: LIST
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: LIST
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: LIST
74867: LIST
74868: LIST
74869: LIST
74870: LIST
74871: LIST
74872: LIST
74873: LIST
74874: LIST
74875: LIST
74876: LIST
74877: LIST
74878: LIST
74879: LIST
74880: LIST
74881: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74882: LD_ADDR_VAR 0 42
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: LD_INT 0
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: LD_INT 0
74899: PUSH
74900: LD_INT 1
74902: NEG
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 1
74910: PUSH
74911: LD_INT 0
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 1
74920: PUSH
74921: LD_INT 1
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: PUSH
74928: LD_INT 0
74930: PUSH
74931: LD_INT 1
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: LD_INT 1
74940: NEG
74941: PUSH
74942: LD_INT 0
74944: PUSH
74945: EMPTY
74946: LIST
74947: LIST
74948: PUSH
74949: LD_INT 1
74951: NEG
74952: PUSH
74953: LD_INT 1
74955: NEG
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: PUSH
74961: LD_INT 1
74963: NEG
74964: PUSH
74965: LD_INT 2
74967: NEG
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 0
74975: PUSH
74976: LD_INT 2
74978: NEG
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 1
74986: PUSH
74987: LD_INT 1
74989: NEG
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 2
74997: PUSH
74998: LD_INT 1
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: LD_INT 2
75007: PUSH
75008: LD_INT 2
75010: PUSH
75011: EMPTY
75012: LIST
75013: LIST
75014: PUSH
75015: LD_INT 1
75017: PUSH
75018: LD_INT 2
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PUSH
75025: LD_INT 0
75027: PUSH
75028: LD_INT 2
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: PUSH
75035: LD_INT 1
75037: NEG
75038: PUSH
75039: LD_INT 1
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: LD_INT 2
75048: NEG
75049: PUSH
75050: LD_INT 1
75052: NEG
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: LD_INT 2
75060: NEG
75061: PUSH
75062: LD_INT 2
75064: NEG
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 2
75072: NEG
75073: PUSH
75074: LD_INT 3
75076: NEG
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 1
75084: NEG
75085: PUSH
75086: LD_INT 3
75088: NEG
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: LD_INT 0
75096: PUSH
75097: LD_INT 3
75099: NEG
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: LD_INT 1
75107: PUSH
75108: LD_INT 2
75110: NEG
75111: PUSH
75112: EMPTY
75113: LIST
75114: LIST
75115: PUSH
75116: LD_INT 3
75118: PUSH
75119: LD_INT 2
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: PUSH
75126: LD_INT 3
75128: PUSH
75129: LD_INT 3
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 2
75138: PUSH
75139: LD_INT 3
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 1
75148: PUSH
75149: LD_INT 3
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: LD_INT 0
75158: PUSH
75159: LD_INT 3
75161: PUSH
75162: EMPTY
75163: LIST
75164: LIST
75165: PUSH
75166: LD_INT 1
75168: NEG
75169: PUSH
75170: LD_INT 2
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: PUSH
75177: LD_INT 3
75179: NEG
75180: PUSH
75181: LD_INT 2
75183: NEG
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: LD_INT 3
75191: NEG
75192: PUSH
75193: LD_INT 3
75195: NEG
75196: PUSH
75197: EMPTY
75198: LIST
75199: LIST
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: LIST
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: LIST
75212: LIST
75213: LIST
75214: LIST
75215: LIST
75216: LIST
75217: LIST
75218: LIST
75219: LIST
75220: LIST
75221: LIST
75222: LIST
75223: LIST
75224: LIST
75225: LIST
75226: LIST
75227: LIST
75228: LIST
75229: LIST
75230: LIST
75231: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75232: LD_ADDR_VAR 0 43
75236: PUSH
75237: LD_INT 0
75239: PUSH
75240: LD_INT 0
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: LD_INT 0
75249: PUSH
75250: LD_INT 1
75252: NEG
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: PUSH
75258: LD_INT 1
75260: PUSH
75261: LD_INT 0
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: LD_INT 1
75270: PUSH
75271: LD_INT 1
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: LD_INT 0
75280: PUSH
75281: LD_INT 1
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 1
75290: NEG
75291: PUSH
75292: LD_INT 0
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 1
75301: NEG
75302: PUSH
75303: LD_INT 1
75305: NEG
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PUSH
75311: LD_INT 1
75313: NEG
75314: PUSH
75315: LD_INT 2
75317: NEG
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 0
75325: PUSH
75326: LD_INT 2
75328: NEG
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: PUSH
75334: LD_INT 1
75336: PUSH
75337: LD_INT 1
75339: NEG
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 2
75347: PUSH
75348: LD_INT 0
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 2
75357: PUSH
75358: LD_INT 1
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: LD_INT 1
75367: PUSH
75368: LD_INT 2
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PUSH
75375: LD_INT 0
75377: PUSH
75378: LD_INT 2
75380: PUSH
75381: EMPTY
75382: LIST
75383: LIST
75384: PUSH
75385: LD_INT 1
75387: NEG
75388: PUSH
75389: LD_INT 1
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: LD_INT 2
75398: NEG
75399: PUSH
75400: LD_INT 0
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 2
75409: NEG
75410: PUSH
75411: LD_INT 1
75413: NEG
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: PUSH
75419: LD_INT 1
75421: NEG
75422: PUSH
75423: LD_INT 3
75425: NEG
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 0
75433: PUSH
75434: LD_INT 3
75436: NEG
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 1
75444: PUSH
75445: LD_INT 2
75447: NEG
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 2
75455: PUSH
75456: LD_INT 1
75458: NEG
75459: PUSH
75460: EMPTY
75461: LIST
75462: LIST
75463: PUSH
75464: LD_INT 3
75466: PUSH
75467: LD_INT 0
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 3
75476: PUSH
75477: LD_INT 1
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 1
75486: PUSH
75487: LD_INT 3
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 0
75496: PUSH
75497: LD_INT 3
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 1
75506: NEG
75507: PUSH
75508: LD_INT 2
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: PUSH
75515: LD_INT 2
75517: NEG
75518: PUSH
75519: LD_INT 1
75521: PUSH
75522: EMPTY
75523: LIST
75524: LIST
75525: PUSH
75526: LD_INT 3
75528: NEG
75529: PUSH
75530: LD_INT 0
75532: PUSH
75533: EMPTY
75534: LIST
75535: LIST
75536: PUSH
75537: LD_INT 3
75539: NEG
75540: PUSH
75541: LD_INT 1
75543: NEG
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: LIST
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: LIST
75564: LIST
75565: LIST
75566: LIST
75567: LIST
75568: LIST
75569: LIST
75570: LIST
75571: LIST
75572: LIST
75573: LIST
75574: LIST
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75580: LD_ADDR_VAR 0 44
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: LD_INT 0
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 0
75597: PUSH
75598: LD_INT 1
75600: NEG
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: LD_INT 1
75608: PUSH
75609: LD_INT 0
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 1
75618: PUSH
75619: LD_INT 1
75621: PUSH
75622: EMPTY
75623: LIST
75624: LIST
75625: PUSH
75626: LD_INT 0
75628: PUSH
75629: LD_INT 1
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: PUSH
75636: LD_INT 1
75638: NEG
75639: PUSH
75640: LD_INT 0
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: PUSH
75647: LD_INT 1
75649: NEG
75650: PUSH
75651: LD_INT 1
75653: NEG
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 1
75661: NEG
75662: PUSH
75663: LD_INT 2
75665: NEG
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: PUSH
75671: LD_INT 1
75673: PUSH
75674: LD_INT 1
75676: NEG
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 2
75684: PUSH
75685: LD_INT 0
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 2
75694: PUSH
75695: LD_INT 1
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 2
75704: PUSH
75705: LD_INT 2
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 1
75714: PUSH
75715: LD_INT 2
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 1
75724: NEG
75725: PUSH
75726: LD_INT 1
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 2
75735: NEG
75736: PUSH
75737: LD_INT 0
75739: PUSH
75740: EMPTY
75741: LIST
75742: LIST
75743: PUSH
75744: LD_INT 2
75746: NEG
75747: PUSH
75748: LD_INT 1
75750: NEG
75751: PUSH
75752: EMPTY
75753: LIST
75754: LIST
75755: PUSH
75756: LD_INT 2
75758: NEG
75759: PUSH
75760: LD_INT 2
75762: NEG
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 2
75770: NEG
75771: PUSH
75772: LD_INT 3
75774: NEG
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: LD_INT 2
75782: PUSH
75783: LD_INT 1
75785: NEG
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: PUSH
75791: LD_INT 3
75793: PUSH
75794: LD_INT 0
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 3
75803: PUSH
75804: LD_INT 1
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: PUSH
75811: LD_INT 3
75813: PUSH
75814: LD_INT 2
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 3
75823: PUSH
75824: LD_INT 3
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: PUSH
75831: LD_INT 2
75833: PUSH
75834: LD_INT 3
75836: PUSH
75837: EMPTY
75838: LIST
75839: LIST
75840: PUSH
75841: LD_INT 2
75843: NEG
75844: PUSH
75845: LD_INT 1
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 3
75854: NEG
75855: PUSH
75856: LD_INT 0
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 3
75865: NEG
75866: PUSH
75867: LD_INT 1
75869: NEG
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: PUSH
75875: LD_INT 3
75877: NEG
75878: PUSH
75879: LD_INT 2
75881: NEG
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 3
75889: NEG
75890: PUSH
75891: LD_INT 3
75893: NEG
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: LIST
75903: LIST
75904: LIST
75905: LIST
75906: LIST
75907: LIST
75908: LIST
75909: LIST
75910: LIST
75911: LIST
75912: LIST
75913: LIST
75914: LIST
75915: LIST
75916: LIST
75917: LIST
75918: LIST
75919: LIST
75920: LIST
75921: LIST
75922: LIST
75923: LIST
75924: LIST
75925: LIST
75926: LIST
75927: LIST
75928: LIST
75929: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75930: LD_ADDR_VAR 0 45
75934: PUSH
75935: LD_INT 0
75937: PUSH
75938: LD_INT 0
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 0
75947: PUSH
75948: LD_INT 1
75950: NEG
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 1
75958: PUSH
75959: LD_INT 0
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 1
75968: PUSH
75969: LD_INT 1
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: PUSH
75976: LD_INT 0
75978: PUSH
75979: LD_INT 1
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: LD_INT 1
75988: NEG
75989: PUSH
75990: LD_INT 0
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 1
75999: NEG
76000: PUSH
76001: LD_INT 1
76003: NEG
76004: PUSH
76005: EMPTY
76006: LIST
76007: LIST
76008: PUSH
76009: LD_INT 1
76011: NEG
76012: PUSH
76013: LD_INT 2
76015: NEG
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PUSH
76021: LD_INT 0
76023: PUSH
76024: LD_INT 2
76026: NEG
76027: PUSH
76028: EMPTY
76029: LIST
76030: LIST
76031: PUSH
76032: LD_INT 1
76034: PUSH
76035: LD_INT 1
76037: NEG
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 2
76045: PUSH
76046: LD_INT 1
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 2
76055: PUSH
76056: LD_INT 2
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 1
76065: PUSH
76066: LD_INT 2
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 0
76075: PUSH
76076: LD_INT 2
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: LD_INT 1
76085: NEG
76086: PUSH
76087: LD_INT 1
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: LD_INT 2
76096: NEG
76097: PUSH
76098: LD_INT 1
76100: NEG
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: PUSH
76106: LD_INT 2
76108: NEG
76109: PUSH
76110: LD_INT 2
76112: NEG
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: PUSH
76118: LD_INT 2
76120: NEG
76121: PUSH
76122: LD_INT 3
76124: NEG
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 1
76132: NEG
76133: PUSH
76134: LD_INT 3
76136: NEG
76137: PUSH
76138: EMPTY
76139: LIST
76140: LIST
76141: PUSH
76142: LD_INT 0
76144: PUSH
76145: LD_INT 3
76147: NEG
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 1
76155: PUSH
76156: LD_INT 2
76158: NEG
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 3
76166: PUSH
76167: LD_INT 2
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: PUSH
76174: LD_INT 3
76176: PUSH
76177: LD_INT 3
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: PUSH
76184: LD_INT 2
76186: PUSH
76187: LD_INT 3
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: PUSH
76194: LD_INT 1
76196: PUSH
76197: LD_INT 3
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PUSH
76204: LD_INT 0
76206: PUSH
76207: LD_INT 3
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: LD_INT 1
76216: NEG
76217: PUSH
76218: LD_INT 2
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: LD_INT 3
76227: NEG
76228: PUSH
76229: LD_INT 2
76231: NEG
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 3
76239: NEG
76240: PUSH
76241: LD_INT 3
76243: NEG
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: LIST
76257: LIST
76258: LIST
76259: LIST
76260: LIST
76261: LIST
76262: LIST
76263: LIST
76264: LIST
76265: LIST
76266: LIST
76267: LIST
76268: LIST
76269: LIST
76270: LIST
76271: LIST
76272: LIST
76273: LIST
76274: LIST
76275: LIST
76276: LIST
76277: LIST
76278: LIST
76279: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76280: LD_ADDR_VAR 0 46
76284: PUSH
76285: LD_INT 0
76287: PUSH
76288: LD_INT 0
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: PUSH
76295: LD_INT 0
76297: PUSH
76298: LD_INT 1
76300: NEG
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: LD_INT 1
76308: PUSH
76309: LD_INT 0
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 1
76318: PUSH
76319: LD_INT 1
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: LD_INT 0
76328: PUSH
76329: LD_INT 1
76331: PUSH
76332: EMPTY
76333: LIST
76334: LIST
76335: PUSH
76336: LD_INT 1
76338: NEG
76339: PUSH
76340: LD_INT 0
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 1
76349: NEG
76350: PUSH
76351: LD_INT 1
76353: NEG
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: LD_INT 1
76361: NEG
76362: PUSH
76363: LD_INT 2
76365: NEG
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PUSH
76371: LD_INT 0
76373: PUSH
76374: LD_INT 2
76376: NEG
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: PUSH
76382: LD_INT 1
76384: PUSH
76385: LD_INT 1
76387: NEG
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: PUSH
76393: LD_INT 2
76395: PUSH
76396: LD_INT 0
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 2
76405: PUSH
76406: LD_INT 1
76408: PUSH
76409: EMPTY
76410: LIST
76411: LIST
76412: PUSH
76413: LD_INT 1
76415: PUSH
76416: LD_INT 2
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: LD_INT 0
76425: PUSH
76426: LD_INT 2
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: LD_INT 1
76435: NEG
76436: PUSH
76437: LD_INT 1
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 2
76446: NEG
76447: PUSH
76448: LD_INT 0
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PUSH
76455: LD_INT 2
76457: NEG
76458: PUSH
76459: LD_INT 1
76461: NEG
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: LD_INT 1
76469: NEG
76470: PUSH
76471: LD_INT 3
76473: NEG
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: LD_INT 0
76481: PUSH
76482: LD_INT 3
76484: NEG
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 1
76492: PUSH
76493: LD_INT 2
76495: NEG
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: LD_INT 2
76503: PUSH
76504: LD_INT 1
76506: NEG
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PUSH
76512: LD_INT 3
76514: PUSH
76515: LD_INT 0
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: PUSH
76522: LD_INT 3
76524: PUSH
76525: LD_INT 1
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: PUSH
76532: LD_INT 1
76534: PUSH
76535: LD_INT 3
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: PUSH
76542: LD_INT 0
76544: PUSH
76545: LD_INT 3
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_INT 1
76554: NEG
76555: PUSH
76556: LD_INT 2
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 2
76565: NEG
76566: PUSH
76567: LD_INT 1
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PUSH
76574: LD_INT 3
76576: NEG
76577: PUSH
76578: LD_INT 0
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: LD_INT 3
76587: NEG
76588: PUSH
76589: LD_INT 1
76591: NEG
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: LIST
76601: LIST
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: LIST
76607: LIST
76608: LIST
76609: LIST
76610: LIST
76611: LIST
76612: LIST
76613: LIST
76614: LIST
76615: LIST
76616: LIST
76617: LIST
76618: LIST
76619: LIST
76620: LIST
76621: LIST
76622: LIST
76623: LIST
76624: LIST
76625: LIST
76626: LIST
76627: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76628: LD_ADDR_VAR 0 47
76632: PUSH
76633: LD_INT 0
76635: PUSH
76636: LD_INT 0
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: PUSH
76643: LD_INT 0
76645: PUSH
76646: LD_INT 1
76648: NEG
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: LD_INT 1
76656: PUSH
76657: LD_INT 0
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PUSH
76664: LD_INT 1
76666: PUSH
76667: LD_INT 1
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: PUSH
76674: LD_INT 0
76676: PUSH
76677: LD_INT 1
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 1
76686: NEG
76687: PUSH
76688: LD_INT 0
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PUSH
76695: LD_INT 1
76697: NEG
76698: PUSH
76699: LD_INT 1
76701: NEG
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PUSH
76707: LD_INT 1
76709: NEG
76710: PUSH
76711: LD_INT 2
76713: NEG
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 0
76721: PUSH
76722: LD_INT 2
76724: NEG
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: PUSH
76730: LD_INT 1
76732: PUSH
76733: LD_INT 1
76735: NEG
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: PUSH
76741: LD_INT 2
76743: NEG
76744: PUSH
76745: LD_INT 1
76747: NEG
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 2
76755: NEG
76756: PUSH
76757: LD_INT 2
76759: NEG
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: LIST
76769: LIST
76770: LIST
76771: LIST
76772: LIST
76773: LIST
76774: LIST
76775: LIST
76776: LIST
76777: LIST
76778: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76779: LD_ADDR_VAR 0 48
76783: PUSH
76784: LD_INT 0
76786: PUSH
76787: LD_INT 0
76789: PUSH
76790: EMPTY
76791: LIST
76792: LIST
76793: PUSH
76794: LD_INT 0
76796: PUSH
76797: LD_INT 1
76799: NEG
76800: PUSH
76801: EMPTY
76802: LIST
76803: LIST
76804: PUSH
76805: LD_INT 1
76807: PUSH
76808: LD_INT 0
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 1
76817: PUSH
76818: LD_INT 1
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: PUSH
76825: LD_INT 0
76827: PUSH
76828: LD_INT 1
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: LD_INT 1
76837: NEG
76838: PUSH
76839: LD_INT 0
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 1
76848: NEG
76849: PUSH
76850: LD_INT 1
76852: NEG
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 1
76860: NEG
76861: PUSH
76862: LD_INT 2
76864: NEG
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 0
76872: PUSH
76873: LD_INT 2
76875: NEG
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 1
76883: PUSH
76884: LD_INT 1
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 2
76894: PUSH
76895: LD_INT 0
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: LD_INT 2
76904: PUSH
76905: LD_INT 1
76907: PUSH
76908: EMPTY
76909: LIST
76910: LIST
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: LIST
76921: LIST
76922: LIST
76923: LIST
76924: LIST
76925: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76926: LD_ADDR_VAR 0 49
76930: PUSH
76931: LD_INT 0
76933: PUSH
76934: LD_INT 0
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: LD_INT 0
76943: PUSH
76944: LD_INT 1
76946: NEG
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: LD_INT 1
76954: PUSH
76955: LD_INT 0
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: PUSH
76962: LD_INT 1
76964: PUSH
76965: LD_INT 1
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 0
76974: PUSH
76975: LD_INT 1
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: PUSH
76982: LD_INT 1
76984: NEG
76985: PUSH
76986: LD_INT 0
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: LD_INT 1
76995: NEG
76996: PUSH
76997: LD_INT 1
76999: NEG
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: PUSH
77005: LD_INT 1
77007: PUSH
77008: LD_INT 1
77010: NEG
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PUSH
77016: LD_INT 2
77018: PUSH
77019: LD_INT 0
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 2
77028: PUSH
77029: LD_INT 1
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 2
77038: PUSH
77039: LD_INT 2
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 1
77048: PUSH
77049: LD_INT 2
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: LIST
77060: LIST
77061: LIST
77062: LIST
77063: LIST
77064: LIST
77065: LIST
77066: LIST
77067: LIST
77068: LIST
77069: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77070: LD_ADDR_VAR 0 50
77074: PUSH
77075: LD_INT 0
77077: PUSH
77078: LD_INT 0
77080: PUSH
77081: EMPTY
77082: LIST
77083: LIST
77084: PUSH
77085: LD_INT 0
77087: PUSH
77088: LD_INT 1
77090: NEG
77091: PUSH
77092: EMPTY
77093: LIST
77094: LIST
77095: PUSH
77096: LD_INT 1
77098: PUSH
77099: LD_INT 0
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 1
77108: PUSH
77109: LD_INT 1
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PUSH
77116: LD_INT 0
77118: PUSH
77119: LD_INT 1
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PUSH
77126: LD_INT 1
77128: NEG
77129: PUSH
77130: LD_INT 0
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 1
77139: NEG
77140: PUSH
77141: LD_INT 1
77143: NEG
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 2
77151: PUSH
77152: LD_INT 1
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 2
77161: PUSH
77162: LD_INT 2
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 1
77171: PUSH
77172: LD_INT 2
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 0
77181: PUSH
77182: LD_INT 2
77184: PUSH
77185: EMPTY
77186: LIST
77187: LIST
77188: PUSH
77189: LD_INT 1
77191: NEG
77192: PUSH
77193: LD_INT 1
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: LIST
77204: LIST
77205: LIST
77206: LIST
77207: LIST
77208: LIST
77209: LIST
77210: LIST
77211: LIST
77212: LIST
77213: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77214: LD_ADDR_VAR 0 51
77218: PUSH
77219: LD_INT 0
77221: PUSH
77222: LD_INT 0
77224: PUSH
77225: EMPTY
77226: LIST
77227: LIST
77228: PUSH
77229: LD_INT 0
77231: PUSH
77232: LD_INT 1
77234: NEG
77235: PUSH
77236: EMPTY
77237: LIST
77238: LIST
77239: PUSH
77240: LD_INT 1
77242: PUSH
77243: LD_INT 0
77245: PUSH
77246: EMPTY
77247: LIST
77248: LIST
77249: PUSH
77250: LD_INT 1
77252: PUSH
77253: LD_INT 1
77255: PUSH
77256: EMPTY
77257: LIST
77258: LIST
77259: PUSH
77260: LD_INT 0
77262: PUSH
77263: LD_INT 1
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: PUSH
77270: LD_INT 1
77272: NEG
77273: PUSH
77274: LD_INT 0
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: PUSH
77281: LD_INT 1
77283: NEG
77284: PUSH
77285: LD_INT 1
77287: NEG
77288: PUSH
77289: EMPTY
77290: LIST
77291: LIST
77292: PUSH
77293: LD_INT 1
77295: PUSH
77296: LD_INT 2
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 0
77305: PUSH
77306: LD_INT 2
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: PUSH
77313: LD_INT 1
77315: NEG
77316: PUSH
77317: LD_INT 1
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: PUSH
77324: LD_INT 2
77326: NEG
77327: PUSH
77328: LD_INT 0
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PUSH
77335: LD_INT 2
77337: NEG
77338: PUSH
77339: LD_INT 1
77341: NEG
77342: PUSH
77343: EMPTY
77344: LIST
77345: LIST
77346: PUSH
77347: EMPTY
77348: LIST
77349: LIST
77350: LIST
77351: LIST
77352: LIST
77353: LIST
77354: LIST
77355: LIST
77356: LIST
77357: LIST
77358: LIST
77359: LIST
77360: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77361: LD_ADDR_VAR 0 52
77365: PUSH
77366: LD_INT 0
77368: PUSH
77369: LD_INT 0
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: LD_INT 0
77378: PUSH
77379: LD_INT 1
77381: NEG
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: PUSH
77387: LD_INT 1
77389: PUSH
77390: LD_INT 0
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 1
77399: PUSH
77400: LD_INT 1
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: PUSH
77407: LD_INT 0
77409: PUSH
77410: LD_INT 1
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 1
77419: NEG
77420: PUSH
77421: LD_INT 0
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 1
77430: NEG
77431: PUSH
77432: LD_INT 1
77434: NEG
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: LD_INT 1
77442: NEG
77443: PUSH
77444: LD_INT 2
77446: NEG
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 1
77454: NEG
77455: PUSH
77456: LD_INT 1
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: PUSH
77463: LD_INT 2
77465: NEG
77466: PUSH
77467: LD_INT 0
77469: PUSH
77470: EMPTY
77471: LIST
77472: LIST
77473: PUSH
77474: LD_INT 2
77476: NEG
77477: PUSH
77478: LD_INT 1
77480: NEG
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: LD_INT 2
77488: NEG
77489: PUSH
77490: LD_INT 2
77492: NEG
77493: PUSH
77494: EMPTY
77495: LIST
77496: LIST
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: LIST
77502: LIST
77503: LIST
77504: LIST
77505: LIST
77506: LIST
77507: LIST
77508: LIST
77509: LIST
77510: LIST
77511: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77512: LD_ADDR_VAR 0 53
77516: PUSH
77517: LD_INT 0
77519: PUSH
77520: LD_INT 0
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PUSH
77527: LD_INT 0
77529: PUSH
77530: LD_INT 1
77532: NEG
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: LD_INT 1
77540: PUSH
77541: LD_INT 0
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 1
77550: PUSH
77551: LD_INT 1
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: LD_INT 0
77560: PUSH
77561: LD_INT 1
77563: PUSH
77564: EMPTY
77565: LIST
77566: LIST
77567: PUSH
77568: LD_INT 1
77570: NEG
77571: PUSH
77572: LD_INT 0
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PUSH
77579: LD_INT 1
77581: NEG
77582: PUSH
77583: LD_INT 1
77585: NEG
77586: PUSH
77587: EMPTY
77588: LIST
77589: LIST
77590: PUSH
77591: LD_INT 1
77593: NEG
77594: PUSH
77595: LD_INT 2
77597: NEG
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: LD_INT 0
77605: PUSH
77606: LD_INT 2
77608: NEG
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 1
77616: PUSH
77617: LD_INT 1
77619: NEG
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 2
77627: PUSH
77628: LD_INT 0
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 2
77637: PUSH
77638: LD_INT 1
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: PUSH
77645: LD_INT 2
77647: PUSH
77648: LD_INT 2
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: LD_INT 1
77657: PUSH
77658: LD_INT 2
77660: PUSH
77661: EMPTY
77662: LIST
77663: LIST
77664: PUSH
77665: LD_INT 0
77667: PUSH
77668: LD_INT 2
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 1
77677: NEG
77678: PUSH
77679: LD_INT 1
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 2
77688: NEG
77689: PUSH
77690: LD_INT 0
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: LD_INT 2
77699: NEG
77700: PUSH
77701: LD_INT 1
77703: NEG
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PUSH
77709: LD_INT 2
77711: NEG
77712: PUSH
77713: LD_INT 2
77715: NEG
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: LIST
77740: LIST
77741: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77742: LD_ADDR_VAR 0 54
77746: PUSH
77747: LD_INT 0
77749: PUSH
77750: LD_INT 0
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 0
77759: PUSH
77760: LD_INT 1
77762: NEG
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: LD_INT 1
77770: PUSH
77771: LD_INT 0
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: PUSH
77778: LD_INT 1
77780: PUSH
77781: LD_INT 1
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: PUSH
77788: LD_INT 0
77790: PUSH
77791: LD_INT 1
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: PUSH
77798: LD_INT 1
77800: NEG
77801: PUSH
77802: LD_INT 0
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: PUSH
77809: LD_INT 1
77811: NEG
77812: PUSH
77813: LD_INT 1
77815: NEG
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: PUSH
77821: LD_INT 1
77823: NEG
77824: PUSH
77825: LD_INT 2
77827: NEG
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 0
77835: PUSH
77836: LD_INT 2
77838: NEG
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 1
77846: PUSH
77847: LD_INT 1
77849: NEG
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 2
77857: PUSH
77858: LD_INT 0
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: PUSH
77865: LD_INT 2
77867: PUSH
77868: LD_INT 1
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: LD_INT 2
77877: PUSH
77878: LD_INT 2
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 1
77887: PUSH
77888: LD_INT 2
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 0
77897: PUSH
77898: LD_INT 2
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 1
77907: NEG
77908: PUSH
77909: LD_INT 1
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 2
77918: NEG
77919: PUSH
77920: LD_INT 0
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: LD_INT 2
77929: NEG
77930: PUSH
77931: LD_INT 1
77933: NEG
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 2
77941: NEG
77942: PUSH
77943: LD_INT 2
77945: NEG
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: LIST
77955: LIST
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: LIST
77962: LIST
77963: LIST
77964: LIST
77965: LIST
77966: LIST
77967: LIST
77968: LIST
77969: LIST
77970: LIST
77971: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77972: LD_ADDR_VAR 0 55
77976: PUSH
77977: LD_INT 0
77979: PUSH
77980: LD_INT 0
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: PUSH
77987: LD_INT 0
77989: PUSH
77990: LD_INT 1
77992: NEG
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 1
78000: PUSH
78001: LD_INT 0
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 1
78010: PUSH
78011: LD_INT 1
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PUSH
78018: LD_INT 0
78020: PUSH
78021: LD_INT 1
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 1
78030: NEG
78031: PUSH
78032: LD_INT 0
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PUSH
78039: LD_INT 1
78041: NEG
78042: PUSH
78043: LD_INT 1
78045: NEG
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: LD_INT 1
78053: NEG
78054: PUSH
78055: LD_INT 2
78057: NEG
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: PUSH
78063: LD_INT 0
78065: PUSH
78066: LD_INT 2
78068: NEG
78069: PUSH
78070: EMPTY
78071: LIST
78072: LIST
78073: PUSH
78074: LD_INT 1
78076: PUSH
78077: LD_INT 1
78079: NEG
78080: PUSH
78081: EMPTY
78082: LIST
78083: LIST
78084: PUSH
78085: LD_INT 2
78087: PUSH
78088: LD_INT 0
78090: PUSH
78091: EMPTY
78092: LIST
78093: LIST
78094: PUSH
78095: LD_INT 2
78097: PUSH
78098: LD_INT 1
78100: PUSH
78101: EMPTY
78102: LIST
78103: LIST
78104: PUSH
78105: LD_INT 2
78107: PUSH
78108: LD_INT 2
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 1
78117: PUSH
78118: LD_INT 2
78120: PUSH
78121: EMPTY
78122: LIST
78123: LIST
78124: PUSH
78125: LD_INT 0
78127: PUSH
78128: LD_INT 2
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: PUSH
78135: LD_INT 1
78137: NEG
78138: PUSH
78139: LD_INT 1
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: PUSH
78146: LD_INT 2
78148: NEG
78149: PUSH
78150: LD_INT 0
78152: PUSH
78153: EMPTY
78154: LIST
78155: LIST
78156: PUSH
78157: LD_INT 2
78159: NEG
78160: PUSH
78161: LD_INT 1
78163: NEG
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: LD_INT 2
78171: NEG
78172: PUSH
78173: LD_INT 2
78175: NEG
78176: PUSH
78177: EMPTY
78178: LIST
78179: LIST
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: LIST
78185: LIST
78186: LIST
78187: LIST
78188: LIST
78189: LIST
78190: LIST
78191: LIST
78192: LIST
78193: LIST
78194: LIST
78195: LIST
78196: LIST
78197: LIST
78198: LIST
78199: LIST
78200: LIST
78201: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78202: LD_ADDR_VAR 0 56
78206: PUSH
78207: LD_INT 0
78209: PUSH
78210: LD_INT 0
78212: PUSH
78213: EMPTY
78214: LIST
78215: LIST
78216: PUSH
78217: LD_INT 0
78219: PUSH
78220: LD_INT 1
78222: NEG
78223: PUSH
78224: EMPTY
78225: LIST
78226: LIST
78227: PUSH
78228: LD_INT 1
78230: PUSH
78231: LD_INT 0
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 1
78240: PUSH
78241: LD_INT 1
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: PUSH
78248: LD_INT 0
78250: PUSH
78251: LD_INT 1
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 1
78260: NEG
78261: PUSH
78262: LD_INT 0
78264: PUSH
78265: EMPTY
78266: LIST
78267: LIST
78268: PUSH
78269: LD_INT 1
78271: NEG
78272: PUSH
78273: LD_INT 1
78275: NEG
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 1
78283: NEG
78284: PUSH
78285: LD_INT 2
78287: NEG
78288: PUSH
78289: EMPTY
78290: LIST
78291: LIST
78292: PUSH
78293: LD_INT 0
78295: PUSH
78296: LD_INT 2
78298: NEG
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PUSH
78304: LD_INT 1
78306: PUSH
78307: LD_INT 1
78309: NEG
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: LD_INT 2
78317: PUSH
78318: LD_INT 0
78320: PUSH
78321: EMPTY
78322: LIST
78323: LIST
78324: PUSH
78325: LD_INT 2
78327: PUSH
78328: LD_INT 1
78330: PUSH
78331: EMPTY
78332: LIST
78333: LIST
78334: PUSH
78335: LD_INT 2
78337: PUSH
78338: LD_INT 2
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: PUSH
78345: LD_INT 1
78347: PUSH
78348: LD_INT 2
78350: PUSH
78351: EMPTY
78352: LIST
78353: LIST
78354: PUSH
78355: LD_INT 0
78357: PUSH
78358: LD_INT 2
78360: PUSH
78361: EMPTY
78362: LIST
78363: LIST
78364: PUSH
78365: LD_INT 1
78367: NEG
78368: PUSH
78369: LD_INT 1
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: PUSH
78376: LD_INT 2
78378: NEG
78379: PUSH
78380: LD_INT 0
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PUSH
78387: LD_INT 2
78389: NEG
78390: PUSH
78391: LD_INT 1
78393: NEG
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 2
78401: NEG
78402: PUSH
78403: LD_INT 2
78405: NEG
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: LIST
78426: LIST
78427: LIST
78428: LIST
78429: LIST
78430: LIST
78431: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78432: LD_ADDR_VAR 0 57
78436: PUSH
78437: LD_INT 0
78439: PUSH
78440: LD_INT 0
78442: PUSH
78443: EMPTY
78444: LIST
78445: LIST
78446: PUSH
78447: LD_INT 0
78449: PUSH
78450: LD_INT 1
78452: NEG
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: PUSH
78458: LD_INT 1
78460: PUSH
78461: LD_INT 0
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: LD_INT 1
78470: PUSH
78471: LD_INT 1
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: PUSH
78478: LD_INT 0
78480: PUSH
78481: LD_INT 1
78483: PUSH
78484: EMPTY
78485: LIST
78486: LIST
78487: PUSH
78488: LD_INT 1
78490: NEG
78491: PUSH
78492: LD_INT 0
78494: PUSH
78495: EMPTY
78496: LIST
78497: LIST
78498: PUSH
78499: LD_INT 1
78501: NEG
78502: PUSH
78503: LD_INT 1
78505: NEG
78506: PUSH
78507: EMPTY
78508: LIST
78509: LIST
78510: PUSH
78511: LD_INT 1
78513: NEG
78514: PUSH
78515: LD_INT 2
78517: NEG
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: PUSH
78523: LD_INT 0
78525: PUSH
78526: LD_INT 2
78528: NEG
78529: PUSH
78530: EMPTY
78531: LIST
78532: LIST
78533: PUSH
78534: LD_INT 1
78536: PUSH
78537: LD_INT 1
78539: NEG
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: PUSH
78545: LD_INT 2
78547: PUSH
78548: LD_INT 0
78550: PUSH
78551: EMPTY
78552: LIST
78553: LIST
78554: PUSH
78555: LD_INT 2
78557: PUSH
78558: LD_INT 1
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 2
78567: PUSH
78568: LD_INT 2
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 1
78577: PUSH
78578: LD_INT 2
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 0
78587: PUSH
78588: LD_INT 2
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 1
78597: NEG
78598: PUSH
78599: LD_INT 1
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: LD_INT 2
78608: NEG
78609: PUSH
78610: LD_INT 0
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: LD_INT 2
78619: NEG
78620: PUSH
78621: LD_INT 1
78623: NEG
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 2
78631: NEG
78632: PUSH
78633: LD_INT 2
78635: NEG
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: LIST
78645: LIST
78646: LIST
78647: LIST
78648: LIST
78649: LIST
78650: LIST
78651: LIST
78652: LIST
78653: LIST
78654: LIST
78655: LIST
78656: LIST
78657: LIST
78658: LIST
78659: LIST
78660: LIST
78661: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78662: LD_ADDR_VAR 0 58
78666: PUSH
78667: LD_INT 0
78669: PUSH
78670: LD_INT 0
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: PUSH
78677: LD_INT 0
78679: PUSH
78680: LD_INT 1
78682: NEG
78683: PUSH
78684: EMPTY
78685: LIST
78686: LIST
78687: PUSH
78688: LD_INT 1
78690: PUSH
78691: LD_INT 0
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 1
78700: PUSH
78701: LD_INT 1
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 0
78710: PUSH
78711: LD_INT 1
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 1
78720: NEG
78721: PUSH
78722: LD_INT 0
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 1
78731: NEG
78732: PUSH
78733: LD_INT 1
78735: NEG
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: PUSH
78741: LD_INT 1
78743: NEG
78744: PUSH
78745: LD_INT 2
78747: NEG
78748: PUSH
78749: EMPTY
78750: LIST
78751: LIST
78752: PUSH
78753: LD_INT 0
78755: PUSH
78756: LD_INT 2
78758: NEG
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 1
78766: PUSH
78767: LD_INT 1
78769: NEG
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 2
78777: PUSH
78778: LD_INT 0
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: LD_INT 2
78787: PUSH
78788: LD_INT 1
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: PUSH
78795: LD_INT 2
78797: PUSH
78798: LD_INT 2
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: PUSH
78805: LD_INT 1
78807: PUSH
78808: LD_INT 2
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 0
78817: PUSH
78818: LD_INT 2
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: LD_INT 1
78827: NEG
78828: PUSH
78829: LD_INT 1
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 2
78838: NEG
78839: PUSH
78840: LD_INT 0
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 2
78849: NEG
78850: PUSH
78851: LD_INT 1
78853: NEG
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 2
78861: NEG
78862: PUSH
78863: LD_INT 2
78865: NEG
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: LIST
78880: LIST
78881: LIST
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78892: LD_ADDR_VAR 0 59
78896: PUSH
78897: LD_INT 0
78899: PUSH
78900: LD_INT 0
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 0
78909: PUSH
78910: LD_INT 1
78912: NEG
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 1
78920: PUSH
78921: LD_INT 0
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: PUSH
78928: LD_INT 1
78930: PUSH
78931: LD_INT 1
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: LD_INT 0
78940: PUSH
78941: LD_INT 1
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PUSH
78948: LD_INT 1
78950: NEG
78951: PUSH
78952: LD_INT 0
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: LD_INT 1
78961: NEG
78962: PUSH
78963: LD_INT 1
78965: NEG
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PUSH
78971: EMPTY
78972: LIST
78973: LIST
78974: LIST
78975: LIST
78976: LIST
78977: LIST
78978: LIST
78979: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78980: LD_ADDR_VAR 0 60
78984: PUSH
78985: LD_INT 0
78987: PUSH
78988: LD_INT 0
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PUSH
78995: LD_INT 0
78997: PUSH
78998: LD_INT 1
79000: NEG
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 1
79008: PUSH
79009: LD_INT 0
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 1
79018: PUSH
79019: LD_INT 1
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 0
79028: PUSH
79029: LD_INT 1
79031: PUSH
79032: EMPTY
79033: LIST
79034: LIST
79035: PUSH
79036: LD_INT 1
79038: NEG
79039: PUSH
79040: LD_INT 0
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PUSH
79047: LD_INT 1
79049: NEG
79050: PUSH
79051: LD_INT 1
79053: NEG
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79068: LD_ADDR_VAR 0 61
79072: PUSH
79073: LD_INT 0
79075: PUSH
79076: LD_INT 0
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 0
79085: PUSH
79086: LD_INT 1
79088: NEG
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 1
79096: PUSH
79097: LD_INT 0
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 1
79106: PUSH
79107: LD_INT 1
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 0
79116: PUSH
79117: LD_INT 1
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 1
79126: NEG
79127: PUSH
79128: LD_INT 0
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PUSH
79135: LD_INT 1
79137: NEG
79138: PUSH
79139: LD_INT 1
79141: NEG
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: LIST
79153: LIST
79154: LIST
79155: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79156: LD_ADDR_VAR 0 62
79160: PUSH
79161: LD_INT 0
79163: PUSH
79164: LD_INT 0
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 0
79173: PUSH
79174: LD_INT 1
79176: NEG
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 1
79184: PUSH
79185: LD_INT 0
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: LD_INT 1
79194: PUSH
79195: LD_INT 1
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 0
79204: PUSH
79205: LD_INT 1
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 1
79214: NEG
79215: PUSH
79216: LD_INT 0
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 1
79225: NEG
79226: PUSH
79227: LD_INT 1
79229: NEG
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: LIST
79239: LIST
79240: LIST
79241: LIST
79242: LIST
79243: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79244: LD_ADDR_VAR 0 63
79248: PUSH
79249: LD_INT 0
79251: PUSH
79252: LD_INT 0
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 0
79261: PUSH
79262: LD_INT 1
79264: NEG
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PUSH
79270: LD_INT 1
79272: PUSH
79273: LD_INT 0
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: PUSH
79280: LD_INT 1
79282: PUSH
79283: LD_INT 1
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 0
79292: PUSH
79293: LD_INT 1
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 1
79302: NEG
79303: PUSH
79304: LD_INT 0
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 1
79313: NEG
79314: PUSH
79315: LD_INT 1
79317: NEG
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: EMPTY
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79332: LD_ADDR_VAR 0 64
79336: PUSH
79337: LD_INT 0
79339: PUSH
79340: LD_INT 0
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 0
79349: PUSH
79350: LD_INT 1
79352: NEG
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 1
79360: PUSH
79361: LD_INT 0
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 1
79370: PUSH
79371: LD_INT 1
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: PUSH
79378: LD_INT 0
79380: PUSH
79381: LD_INT 1
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 1
79390: NEG
79391: PUSH
79392: LD_INT 0
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 1
79401: NEG
79402: PUSH
79403: LD_INT 1
79405: NEG
79406: PUSH
79407: EMPTY
79408: LIST
79409: LIST
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: ST_TO_ADDR
// end ; 1 :
79420: GO 85317
79422: LD_INT 1
79424: DOUBLE
79425: EQUAL
79426: IFTRUE 79430
79428: GO 82053
79430: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79431: LD_ADDR_VAR 0 11
79435: PUSH
79436: LD_INT 1
79438: NEG
79439: PUSH
79440: LD_INT 3
79442: NEG
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 0
79450: PUSH
79451: LD_INT 3
79453: NEG
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 1
79461: PUSH
79462: LD_INT 2
79464: NEG
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: LIST
79474: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79475: LD_ADDR_VAR 0 12
79479: PUSH
79480: LD_INT 2
79482: PUSH
79483: LD_INT 1
79485: NEG
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 3
79493: PUSH
79494: LD_INT 0
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: LD_INT 3
79503: PUSH
79504: LD_INT 1
79506: PUSH
79507: EMPTY
79508: LIST
79509: LIST
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: LIST
79515: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79516: LD_ADDR_VAR 0 13
79520: PUSH
79521: LD_INT 3
79523: PUSH
79524: LD_INT 2
79526: PUSH
79527: EMPTY
79528: LIST
79529: LIST
79530: PUSH
79531: LD_INT 3
79533: PUSH
79534: LD_INT 3
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: LD_INT 2
79543: PUSH
79544: LD_INT 3
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: LIST
79555: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79556: LD_ADDR_VAR 0 14
79560: PUSH
79561: LD_INT 1
79563: PUSH
79564: LD_INT 3
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 0
79573: PUSH
79574: LD_INT 3
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: LD_INT 1
79583: NEG
79584: PUSH
79585: LD_INT 2
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: LIST
79596: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79597: LD_ADDR_VAR 0 15
79601: PUSH
79602: LD_INT 2
79604: NEG
79605: PUSH
79606: LD_INT 1
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: PUSH
79613: LD_INT 3
79615: NEG
79616: PUSH
79617: LD_INT 0
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: LD_INT 3
79626: NEG
79627: PUSH
79628: LD_INT 1
79630: NEG
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: LIST
79640: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79641: LD_ADDR_VAR 0 16
79645: PUSH
79646: LD_INT 2
79648: NEG
79649: PUSH
79650: LD_INT 3
79652: NEG
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 3
79660: NEG
79661: PUSH
79662: LD_INT 2
79664: NEG
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 3
79672: NEG
79673: PUSH
79674: LD_INT 3
79676: NEG
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: LIST
79686: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79687: LD_ADDR_VAR 0 17
79691: PUSH
79692: LD_INT 1
79694: NEG
79695: PUSH
79696: LD_INT 3
79698: NEG
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 0
79706: PUSH
79707: LD_INT 3
79709: NEG
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: PUSH
79715: LD_INT 1
79717: PUSH
79718: LD_INT 2
79720: NEG
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: LIST
79730: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79731: LD_ADDR_VAR 0 18
79735: PUSH
79736: LD_INT 2
79738: PUSH
79739: LD_INT 1
79741: NEG
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 3
79749: PUSH
79750: LD_INT 0
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: PUSH
79757: LD_INT 3
79759: PUSH
79760: LD_INT 1
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: LIST
79771: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79772: LD_ADDR_VAR 0 19
79776: PUSH
79777: LD_INT 3
79779: PUSH
79780: LD_INT 2
79782: PUSH
79783: EMPTY
79784: LIST
79785: LIST
79786: PUSH
79787: LD_INT 3
79789: PUSH
79790: LD_INT 3
79792: PUSH
79793: EMPTY
79794: LIST
79795: LIST
79796: PUSH
79797: LD_INT 2
79799: PUSH
79800: LD_INT 3
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: LIST
79811: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79812: LD_ADDR_VAR 0 20
79816: PUSH
79817: LD_INT 1
79819: PUSH
79820: LD_INT 3
79822: PUSH
79823: EMPTY
79824: LIST
79825: LIST
79826: PUSH
79827: LD_INT 0
79829: PUSH
79830: LD_INT 3
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: LD_INT 1
79839: NEG
79840: PUSH
79841: LD_INT 2
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: LIST
79852: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79853: LD_ADDR_VAR 0 21
79857: PUSH
79858: LD_INT 2
79860: NEG
79861: PUSH
79862: LD_INT 1
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 3
79871: NEG
79872: PUSH
79873: LD_INT 0
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: PUSH
79880: LD_INT 3
79882: NEG
79883: PUSH
79884: LD_INT 1
79886: NEG
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: LIST
79896: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79897: LD_ADDR_VAR 0 22
79901: PUSH
79902: LD_INT 2
79904: NEG
79905: PUSH
79906: LD_INT 3
79908: NEG
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: PUSH
79914: LD_INT 3
79916: NEG
79917: PUSH
79918: LD_INT 2
79920: NEG
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 3
79928: NEG
79929: PUSH
79930: LD_INT 3
79932: NEG
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: LIST
79942: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
79943: LD_ADDR_VAR 0 23
79947: PUSH
79948: LD_INT 0
79950: PUSH
79951: LD_INT 3
79953: NEG
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 1
79961: NEG
79962: PUSH
79963: LD_INT 4
79965: NEG
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PUSH
79971: LD_INT 1
79973: PUSH
79974: LD_INT 3
79976: NEG
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: LIST
79986: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
79987: LD_ADDR_VAR 0 24
79991: PUSH
79992: LD_INT 3
79994: PUSH
79995: LD_INT 0
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 3
80004: PUSH
80005: LD_INT 1
80007: NEG
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 4
80015: PUSH
80016: LD_INT 1
80018: PUSH
80019: EMPTY
80020: LIST
80021: LIST
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: LIST
80027: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
80028: LD_ADDR_VAR 0 25
80032: PUSH
80033: LD_INT 3
80035: PUSH
80036: LD_INT 3
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: PUSH
80043: LD_INT 4
80045: PUSH
80046: LD_INT 3
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 3
80055: PUSH
80056: LD_INT 4
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: LIST
80067: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
80068: LD_ADDR_VAR 0 26
80072: PUSH
80073: LD_INT 0
80075: PUSH
80076: LD_INT 3
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: LD_INT 1
80085: PUSH
80086: LD_INT 4
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PUSH
80093: LD_INT 1
80095: NEG
80096: PUSH
80097: LD_INT 3
80099: PUSH
80100: EMPTY
80101: LIST
80102: LIST
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: LIST
80108: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
80109: LD_ADDR_VAR 0 27
80113: PUSH
80114: LD_INT 3
80116: NEG
80117: PUSH
80118: LD_INT 0
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 3
80127: NEG
80128: PUSH
80129: LD_INT 1
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 4
80138: NEG
80139: PUSH
80140: LD_INT 1
80142: NEG
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: LIST
80152: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
80153: LD_ADDR_VAR 0 28
80157: PUSH
80158: LD_INT 3
80160: NEG
80161: PUSH
80162: LD_INT 3
80164: NEG
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 3
80172: NEG
80173: PUSH
80174: LD_INT 4
80176: NEG
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 4
80184: NEG
80185: PUSH
80186: LD_INT 3
80188: NEG
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: LIST
80198: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
80199: LD_ADDR_VAR 0 29
80203: PUSH
80204: LD_INT 1
80206: NEG
80207: PUSH
80208: LD_INT 3
80210: NEG
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 0
80218: PUSH
80219: LD_INT 3
80221: NEG
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 1
80229: PUSH
80230: LD_INT 2
80232: NEG
80233: PUSH
80234: EMPTY
80235: LIST
80236: LIST
80237: PUSH
80238: LD_INT 1
80240: NEG
80241: PUSH
80242: LD_INT 4
80244: NEG
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 0
80252: PUSH
80253: LD_INT 4
80255: NEG
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 1
80263: PUSH
80264: LD_INT 3
80266: NEG
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 1
80274: NEG
80275: PUSH
80276: LD_INT 5
80278: NEG
80279: PUSH
80280: EMPTY
80281: LIST
80282: LIST
80283: PUSH
80284: LD_INT 0
80286: PUSH
80287: LD_INT 5
80289: NEG
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: LD_INT 1
80297: PUSH
80298: LD_INT 4
80300: NEG
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 1
80308: NEG
80309: PUSH
80310: LD_INT 6
80312: NEG
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 0
80320: PUSH
80321: LD_INT 6
80323: NEG
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: PUSH
80329: LD_INT 1
80331: PUSH
80332: LD_INT 5
80334: NEG
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
80354: LD_ADDR_VAR 0 30
80358: PUSH
80359: LD_INT 2
80361: PUSH
80362: LD_INT 1
80364: NEG
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: PUSH
80370: LD_INT 3
80372: PUSH
80373: LD_INT 0
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 3
80382: PUSH
80383: LD_INT 1
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 3
80392: PUSH
80393: LD_INT 1
80395: NEG
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 4
80403: PUSH
80404: LD_INT 0
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 4
80413: PUSH
80414: LD_INT 1
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PUSH
80421: LD_INT 4
80423: PUSH
80424: LD_INT 1
80426: NEG
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 5
80434: PUSH
80435: LD_INT 0
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 5
80444: PUSH
80445: LD_INT 1
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: LD_INT 5
80454: PUSH
80455: LD_INT 1
80457: NEG
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 6
80465: PUSH
80466: LD_INT 0
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 6
80475: PUSH
80476: LD_INT 1
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: LIST
80487: LIST
80488: LIST
80489: LIST
80490: LIST
80491: LIST
80492: LIST
80493: LIST
80494: LIST
80495: LIST
80496: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
80497: LD_ADDR_VAR 0 31
80501: PUSH
80502: LD_INT 3
80504: PUSH
80505: LD_INT 2
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 3
80514: PUSH
80515: LD_INT 3
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: PUSH
80522: LD_INT 2
80524: PUSH
80525: LD_INT 3
80527: PUSH
80528: EMPTY
80529: LIST
80530: LIST
80531: PUSH
80532: LD_INT 4
80534: PUSH
80535: LD_INT 3
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 4
80544: PUSH
80545: LD_INT 4
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: LD_INT 3
80554: PUSH
80555: LD_INT 4
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 5
80564: PUSH
80565: LD_INT 4
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: PUSH
80572: LD_INT 5
80574: PUSH
80575: LD_INT 5
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: PUSH
80582: LD_INT 4
80584: PUSH
80585: LD_INT 5
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: PUSH
80592: LD_INT 6
80594: PUSH
80595: LD_INT 5
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 6
80604: PUSH
80605: LD_INT 6
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 5
80614: PUSH
80615: LD_INT 6
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
80636: LD_ADDR_VAR 0 32
80640: PUSH
80641: LD_INT 1
80643: PUSH
80644: LD_INT 3
80646: PUSH
80647: EMPTY
80648: LIST
80649: LIST
80650: PUSH
80651: LD_INT 0
80653: PUSH
80654: LD_INT 3
80656: PUSH
80657: EMPTY
80658: LIST
80659: LIST
80660: PUSH
80661: LD_INT 1
80663: NEG
80664: PUSH
80665: LD_INT 2
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: LD_INT 1
80674: PUSH
80675: LD_INT 4
80677: PUSH
80678: EMPTY
80679: LIST
80680: LIST
80681: PUSH
80682: LD_INT 0
80684: PUSH
80685: LD_INT 4
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 1
80694: NEG
80695: PUSH
80696: LD_INT 3
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: PUSH
80703: LD_INT 1
80705: PUSH
80706: LD_INT 5
80708: PUSH
80709: EMPTY
80710: LIST
80711: LIST
80712: PUSH
80713: LD_INT 0
80715: PUSH
80716: LD_INT 5
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 1
80725: NEG
80726: PUSH
80727: LD_INT 4
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: LD_INT 1
80736: PUSH
80737: LD_INT 6
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 0
80746: PUSH
80747: LD_INT 6
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: PUSH
80754: LD_INT 1
80756: NEG
80757: PUSH
80758: LD_INT 5
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: LIST
80777: LIST
80778: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
80779: LD_ADDR_VAR 0 33
80783: PUSH
80784: LD_INT 2
80786: NEG
80787: PUSH
80788: LD_INT 1
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 3
80797: NEG
80798: PUSH
80799: LD_INT 0
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 3
80808: NEG
80809: PUSH
80810: LD_INT 1
80812: NEG
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 3
80820: NEG
80821: PUSH
80822: LD_INT 1
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 4
80831: NEG
80832: PUSH
80833: LD_INT 0
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 4
80842: NEG
80843: PUSH
80844: LD_INT 1
80846: NEG
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 4
80854: NEG
80855: PUSH
80856: LD_INT 1
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 5
80865: NEG
80866: PUSH
80867: LD_INT 0
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 5
80876: NEG
80877: PUSH
80878: LD_INT 1
80880: NEG
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 5
80888: NEG
80889: PUSH
80890: LD_INT 1
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: LD_INT 6
80899: NEG
80900: PUSH
80901: LD_INT 0
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 6
80910: NEG
80911: PUSH
80912: LD_INT 1
80914: NEG
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
80934: LD_ADDR_VAR 0 34
80938: PUSH
80939: LD_INT 2
80941: NEG
80942: PUSH
80943: LD_INT 3
80945: NEG
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: LD_INT 3
80953: NEG
80954: PUSH
80955: LD_INT 2
80957: NEG
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: LD_INT 3
80965: NEG
80966: PUSH
80967: LD_INT 3
80969: NEG
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PUSH
80975: LD_INT 3
80977: NEG
80978: PUSH
80979: LD_INT 4
80981: NEG
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 4
80989: NEG
80990: PUSH
80991: LD_INT 3
80993: NEG
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 4
81001: NEG
81002: PUSH
81003: LD_INT 4
81005: NEG
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 4
81013: NEG
81014: PUSH
81015: LD_INT 5
81017: NEG
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 5
81025: NEG
81026: PUSH
81027: LD_INT 4
81029: NEG
81030: PUSH
81031: EMPTY
81032: LIST
81033: LIST
81034: PUSH
81035: LD_INT 5
81037: NEG
81038: PUSH
81039: LD_INT 5
81041: NEG
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 5
81049: NEG
81050: PUSH
81051: LD_INT 6
81053: NEG
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 6
81061: NEG
81062: PUSH
81063: LD_INT 5
81065: NEG
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 6
81073: NEG
81074: PUSH
81075: LD_INT 6
81077: NEG
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
81097: LD_ADDR_VAR 0 41
81101: PUSH
81102: LD_INT 0
81104: PUSH
81105: LD_INT 2
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 1
81115: NEG
81116: PUSH
81117: LD_INT 3
81119: NEG
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: LD_INT 1
81127: PUSH
81128: LD_INT 2
81130: NEG
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: LIST
81140: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
81141: LD_ADDR_VAR 0 42
81145: PUSH
81146: LD_INT 2
81148: PUSH
81149: LD_INT 0
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 2
81158: PUSH
81159: LD_INT 1
81161: NEG
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 3
81169: PUSH
81170: LD_INT 1
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: LIST
81181: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
81182: LD_ADDR_VAR 0 43
81186: PUSH
81187: LD_INT 2
81189: PUSH
81190: LD_INT 2
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 3
81199: PUSH
81200: LD_INT 2
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 2
81209: PUSH
81210: LD_INT 3
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: LIST
81221: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
81222: LD_ADDR_VAR 0 44
81226: PUSH
81227: LD_INT 0
81229: PUSH
81230: LD_INT 2
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 1
81239: PUSH
81240: LD_INT 3
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 1
81249: NEG
81250: PUSH
81251: LD_INT 2
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: LIST
81262: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81263: LD_ADDR_VAR 0 45
81267: PUSH
81268: LD_INT 2
81270: NEG
81271: PUSH
81272: LD_INT 0
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 2
81281: NEG
81282: PUSH
81283: LD_INT 1
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 3
81292: NEG
81293: PUSH
81294: LD_INT 1
81296: NEG
81297: PUSH
81298: EMPTY
81299: LIST
81300: LIST
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: LIST
81306: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
81307: LD_ADDR_VAR 0 46
81311: PUSH
81312: LD_INT 2
81314: NEG
81315: PUSH
81316: LD_INT 2
81318: NEG
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 2
81326: NEG
81327: PUSH
81328: LD_INT 3
81330: NEG
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 3
81338: NEG
81339: PUSH
81340: LD_INT 2
81342: NEG
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: EMPTY
81349: LIST
81350: LIST
81351: LIST
81352: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
81353: LD_ADDR_VAR 0 47
81357: PUSH
81358: LD_INT 2
81360: NEG
81361: PUSH
81362: LD_INT 3
81364: NEG
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 1
81372: NEG
81373: PUSH
81374: LD_INT 3
81376: NEG
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81386: LD_ADDR_VAR 0 48
81390: PUSH
81391: LD_INT 1
81393: PUSH
81394: LD_INT 2
81396: NEG
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 2
81404: PUSH
81405: LD_INT 1
81407: NEG
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
81417: LD_ADDR_VAR 0 49
81421: PUSH
81422: LD_INT 3
81424: PUSH
81425: LD_INT 1
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 3
81434: PUSH
81435: LD_INT 2
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: EMPTY
81443: LIST
81444: LIST
81445: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
81446: LD_ADDR_VAR 0 50
81450: PUSH
81451: LD_INT 2
81453: PUSH
81454: LD_INT 3
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 1
81463: PUSH
81464: LD_INT 3
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81475: LD_ADDR_VAR 0 51
81479: PUSH
81480: LD_INT 1
81482: NEG
81483: PUSH
81484: LD_INT 2
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 2
81493: NEG
81494: PUSH
81495: LD_INT 1
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81506: LD_ADDR_VAR 0 52
81510: PUSH
81511: LD_INT 3
81513: NEG
81514: PUSH
81515: LD_INT 1
81517: NEG
81518: PUSH
81519: EMPTY
81520: LIST
81521: LIST
81522: PUSH
81523: LD_INT 3
81525: NEG
81526: PUSH
81527: LD_INT 2
81529: NEG
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81539: LD_ADDR_VAR 0 53
81543: PUSH
81544: LD_INT 1
81546: NEG
81547: PUSH
81548: LD_INT 3
81550: NEG
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 0
81558: PUSH
81559: LD_INT 3
81561: NEG
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 1
81569: PUSH
81570: LD_INT 2
81572: NEG
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PUSH
81578: EMPTY
81579: LIST
81580: LIST
81581: LIST
81582: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81583: LD_ADDR_VAR 0 54
81587: PUSH
81588: LD_INT 2
81590: PUSH
81591: LD_INT 1
81593: NEG
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 3
81601: PUSH
81602: LD_INT 0
81604: PUSH
81605: EMPTY
81606: LIST
81607: LIST
81608: PUSH
81609: LD_INT 3
81611: PUSH
81612: LD_INT 1
81614: PUSH
81615: EMPTY
81616: LIST
81617: LIST
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: LIST
81623: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81624: LD_ADDR_VAR 0 55
81628: PUSH
81629: LD_INT 3
81631: PUSH
81632: LD_INT 2
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 3
81641: PUSH
81642: LD_INT 3
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 2
81651: PUSH
81652: LD_INT 3
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: LIST
81663: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81664: LD_ADDR_VAR 0 56
81668: PUSH
81669: LD_INT 1
81671: PUSH
81672: LD_INT 3
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: PUSH
81679: LD_INT 0
81681: PUSH
81682: LD_INT 3
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 1
81691: NEG
81692: PUSH
81693: LD_INT 2
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: LIST
81704: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81705: LD_ADDR_VAR 0 57
81709: PUSH
81710: LD_INT 2
81712: NEG
81713: PUSH
81714: LD_INT 1
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 3
81723: NEG
81724: PUSH
81725: LD_INT 0
81727: PUSH
81728: EMPTY
81729: LIST
81730: LIST
81731: PUSH
81732: LD_INT 3
81734: NEG
81735: PUSH
81736: LD_INT 1
81738: NEG
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: LIST
81748: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81749: LD_ADDR_VAR 0 58
81753: PUSH
81754: LD_INT 2
81756: NEG
81757: PUSH
81758: LD_INT 3
81760: NEG
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: PUSH
81766: LD_INT 3
81768: NEG
81769: PUSH
81770: LD_INT 2
81772: NEG
81773: PUSH
81774: EMPTY
81775: LIST
81776: LIST
81777: PUSH
81778: LD_INT 3
81780: NEG
81781: PUSH
81782: LD_INT 3
81784: NEG
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: LIST
81794: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
81795: LD_ADDR_VAR 0 59
81799: PUSH
81800: LD_INT 1
81802: NEG
81803: PUSH
81804: LD_INT 2
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 0
81814: PUSH
81815: LD_INT 2
81817: NEG
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: PUSH
81823: LD_INT 1
81825: PUSH
81826: LD_INT 1
81828: NEG
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: LIST
81838: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
81839: LD_ADDR_VAR 0 60
81843: PUSH
81844: LD_INT 1
81846: PUSH
81847: LD_INT 1
81849: NEG
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 2
81857: PUSH
81858: LD_INT 0
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 2
81867: PUSH
81868: LD_INT 1
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: LIST
81879: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
81880: LD_ADDR_VAR 0 61
81884: PUSH
81885: LD_INT 2
81887: PUSH
81888: LD_INT 1
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: PUSH
81895: LD_INT 2
81897: PUSH
81898: LD_INT 2
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: PUSH
81905: LD_INT 1
81907: PUSH
81908: LD_INT 2
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: EMPTY
81916: LIST
81917: LIST
81918: LIST
81919: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
81920: LD_ADDR_VAR 0 62
81924: PUSH
81925: LD_INT 1
81927: PUSH
81928: LD_INT 2
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 0
81937: PUSH
81938: LD_INT 2
81940: PUSH
81941: EMPTY
81942: LIST
81943: LIST
81944: PUSH
81945: LD_INT 1
81947: NEG
81948: PUSH
81949: LD_INT 1
81951: PUSH
81952: EMPTY
81953: LIST
81954: LIST
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: LIST
81960: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
81961: LD_ADDR_VAR 0 63
81965: PUSH
81966: LD_INT 1
81968: NEG
81969: PUSH
81970: LD_INT 1
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 2
81979: NEG
81980: PUSH
81981: LD_INT 0
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: LD_INT 2
81990: NEG
81991: PUSH
81992: LD_INT 1
81994: NEG
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: LIST
82004: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82005: LD_ADDR_VAR 0 64
82009: PUSH
82010: LD_INT 1
82012: NEG
82013: PUSH
82014: LD_INT 2
82016: NEG
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 2
82024: NEG
82025: PUSH
82026: LD_INT 1
82028: NEG
82029: PUSH
82030: EMPTY
82031: LIST
82032: LIST
82033: PUSH
82034: LD_INT 2
82036: NEG
82037: PUSH
82038: LD_INT 2
82040: NEG
82041: PUSH
82042: EMPTY
82043: LIST
82044: LIST
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: LIST
82050: ST_TO_ADDR
// end ; 2 :
82051: GO 85317
82053: LD_INT 2
82055: DOUBLE
82056: EQUAL
82057: IFTRUE 82061
82059: GO 85316
82061: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
82062: LD_ADDR_VAR 0 29
82066: PUSH
82067: LD_INT 4
82069: PUSH
82070: LD_INT 0
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: PUSH
82077: LD_INT 4
82079: PUSH
82080: LD_INT 1
82082: NEG
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 5
82090: PUSH
82091: LD_INT 0
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 5
82100: PUSH
82101: LD_INT 1
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 4
82110: PUSH
82111: LD_INT 1
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 3
82120: PUSH
82121: LD_INT 0
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 3
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 3
82141: PUSH
82142: LD_INT 2
82144: NEG
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 5
82152: PUSH
82153: LD_INT 2
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 3
82162: PUSH
82163: LD_INT 3
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 3
82172: PUSH
82173: LD_INT 2
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 4
82182: PUSH
82183: LD_INT 3
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 4
82192: PUSH
82193: LD_INT 4
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 3
82202: PUSH
82203: LD_INT 4
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: PUSH
82210: LD_INT 2
82212: PUSH
82213: LD_INT 3
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 2
82222: PUSH
82223: LD_INT 2
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 4
82232: PUSH
82233: LD_INT 2
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 2
82242: PUSH
82243: LD_INT 4
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: PUSH
82250: LD_INT 0
82252: PUSH
82253: LD_INT 4
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 0
82262: PUSH
82263: LD_INT 3
82265: PUSH
82266: EMPTY
82267: LIST
82268: LIST
82269: PUSH
82270: LD_INT 1
82272: PUSH
82273: LD_INT 4
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 1
82282: PUSH
82283: LD_INT 5
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 0
82292: PUSH
82293: LD_INT 5
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 1
82302: NEG
82303: PUSH
82304: LD_INT 4
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 1
82313: NEG
82314: PUSH
82315: LD_INT 3
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PUSH
82322: LD_INT 2
82324: PUSH
82325: LD_INT 5
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 2
82334: NEG
82335: PUSH
82336: LD_INT 3
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 3
82345: NEG
82346: PUSH
82347: LD_INT 0
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PUSH
82354: LD_INT 3
82356: NEG
82357: PUSH
82358: LD_INT 1
82360: NEG
82361: PUSH
82362: EMPTY
82363: LIST
82364: LIST
82365: PUSH
82366: LD_INT 2
82368: NEG
82369: PUSH
82370: LD_INT 0
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 2
82379: NEG
82380: PUSH
82381: LD_INT 1
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: LD_INT 3
82390: NEG
82391: PUSH
82392: LD_INT 1
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 4
82401: NEG
82402: PUSH
82403: LD_INT 0
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 4
82412: NEG
82413: PUSH
82414: LD_INT 1
82416: NEG
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: LD_INT 4
82424: NEG
82425: PUSH
82426: LD_INT 2
82428: NEG
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 2
82436: NEG
82437: PUSH
82438: LD_INT 2
82440: PUSH
82441: EMPTY
82442: LIST
82443: LIST
82444: PUSH
82445: LD_INT 4
82447: NEG
82448: PUSH
82449: LD_INT 4
82451: NEG
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 4
82459: NEG
82460: PUSH
82461: LD_INT 5
82463: NEG
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 3
82471: NEG
82472: PUSH
82473: LD_INT 4
82475: NEG
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PUSH
82481: LD_INT 3
82483: NEG
82484: PUSH
82485: LD_INT 3
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 4
82495: NEG
82496: PUSH
82497: LD_INT 3
82499: NEG
82500: PUSH
82501: EMPTY
82502: LIST
82503: LIST
82504: PUSH
82505: LD_INT 5
82507: NEG
82508: PUSH
82509: LD_INT 4
82511: NEG
82512: PUSH
82513: EMPTY
82514: LIST
82515: LIST
82516: PUSH
82517: LD_INT 5
82519: NEG
82520: PUSH
82521: LD_INT 5
82523: NEG
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 3
82531: NEG
82532: PUSH
82533: LD_INT 5
82535: NEG
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 5
82543: NEG
82544: PUSH
82545: LD_INT 3
82547: NEG
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: EMPTY
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: LIST
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: LIST
82584: LIST
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: LIST
82595: LIST
82596: LIST
82597: LIST
82598: LIST
82599: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
82600: LD_ADDR_VAR 0 30
82604: PUSH
82605: LD_INT 4
82607: PUSH
82608: LD_INT 4
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 4
82617: PUSH
82618: LD_INT 3
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 5
82627: PUSH
82628: LD_INT 4
82630: PUSH
82631: EMPTY
82632: LIST
82633: LIST
82634: PUSH
82635: LD_INT 5
82637: PUSH
82638: LD_INT 5
82640: PUSH
82641: EMPTY
82642: LIST
82643: LIST
82644: PUSH
82645: LD_INT 4
82647: PUSH
82648: LD_INT 5
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: LD_INT 3
82657: PUSH
82658: LD_INT 4
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: PUSH
82665: LD_INT 3
82667: PUSH
82668: LD_INT 3
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 5
82677: PUSH
82678: LD_INT 3
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: LD_INT 3
82687: PUSH
82688: LD_INT 5
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 0
82697: PUSH
82698: LD_INT 3
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 0
82707: PUSH
82708: LD_INT 2
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 1
82717: PUSH
82718: LD_INT 3
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 1
82727: PUSH
82728: LD_INT 4
82730: PUSH
82731: EMPTY
82732: LIST
82733: LIST
82734: PUSH
82735: LD_INT 0
82737: PUSH
82738: LD_INT 4
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 1
82747: NEG
82748: PUSH
82749: LD_INT 3
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 1
82758: NEG
82759: PUSH
82760: LD_INT 2
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: PUSH
82767: LD_INT 2
82769: PUSH
82770: LD_INT 4
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 2
82779: NEG
82780: PUSH
82781: LD_INT 2
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 4
82790: NEG
82791: PUSH
82792: LD_INT 0
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 4
82801: NEG
82802: PUSH
82803: LD_INT 1
82805: NEG
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 3
82813: NEG
82814: PUSH
82815: LD_INT 0
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 3
82824: NEG
82825: PUSH
82826: LD_INT 1
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 4
82835: NEG
82836: PUSH
82837: LD_INT 1
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 5
82846: NEG
82847: PUSH
82848: LD_INT 0
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 5
82857: NEG
82858: PUSH
82859: LD_INT 1
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 5
82869: NEG
82870: PUSH
82871: LD_INT 2
82873: NEG
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 3
82881: NEG
82882: PUSH
82883: LD_INT 2
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 3
82892: NEG
82893: PUSH
82894: LD_INT 3
82896: NEG
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: LD_INT 3
82904: NEG
82905: PUSH
82906: LD_INT 4
82908: NEG
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: LD_INT 2
82916: NEG
82917: PUSH
82918: LD_INT 3
82920: NEG
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 2
82928: NEG
82929: PUSH
82930: LD_INT 2
82932: NEG
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 3
82940: NEG
82941: PUSH
82942: LD_INT 2
82944: NEG
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 4
82952: NEG
82953: PUSH
82954: LD_INT 3
82956: NEG
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 4
82964: NEG
82965: PUSH
82966: LD_INT 4
82968: NEG
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 2
82976: NEG
82977: PUSH
82978: LD_INT 4
82980: NEG
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: LD_INT 4
82988: NEG
82989: PUSH
82990: LD_INT 2
82992: NEG
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 0
83000: PUSH
83001: LD_INT 4
83003: NEG
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 0
83011: PUSH
83012: LD_INT 5
83014: NEG
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 1
83022: PUSH
83023: LD_INT 4
83025: NEG
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_INT 1
83033: PUSH
83034: LD_INT 3
83036: NEG
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PUSH
83042: LD_INT 0
83044: PUSH
83045: LD_INT 3
83047: NEG
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 1
83055: NEG
83056: PUSH
83057: LD_INT 4
83059: NEG
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 1
83067: NEG
83068: PUSH
83069: LD_INT 5
83071: NEG
83072: PUSH
83073: EMPTY
83074: LIST
83075: LIST
83076: PUSH
83077: LD_INT 2
83079: PUSH
83080: LD_INT 3
83082: NEG
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PUSH
83088: LD_INT 2
83090: NEG
83091: PUSH
83092: LD_INT 5
83094: NEG
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: LIST
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
83147: LD_ADDR_VAR 0 31
83151: PUSH
83152: LD_INT 0
83154: PUSH
83155: LD_INT 4
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: PUSH
83162: LD_INT 0
83164: PUSH
83165: LD_INT 3
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 1
83174: PUSH
83175: LD_INT 4
83177: PUSH
83178: EMPTY
83179: LIST
83180: LIST
83181: PUSH
83182: LD_INT 1
83184: PUSH
83185: LD_INT 5
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: LD_INT 0
83194: PUSH
83195: LD_INT 5
83197: PUSH
83198: EMPTY
83199: LIST
83200: LIST
83201: PUSH
83202: LD_INT 1
83204: NEG
83205: PUSH
83206: LD_INT 4
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PUSH
83213: LD_INT 1
83215: NEG
83216: PUSH
83217: LD_INT 3
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 2
83226: PUSH
83227: LD_INT 5
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 2
83236: NEG
83237: PUSH
83238: LD_INT 3
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 3
83247: NEG
83248: PUSH
83249: LD_INT 0
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 3
83258: NEG
83259: PUSH
83260: LD_INT 1
83262: NEG
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 2
83270: NEG
83271: PUSH
83272: LD_INT 0
83274: PUSH
83275: EMPTY
83276: LIST
83277: LIST
83278: PUSH
83279: LD_INT 2
83281: NEG
83282: PUSH
83283: LD_INT 1
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PUSH
83290: LD_INT 3
83292: NEG
83293: PUSH
83294: LD_INT 1
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 4
83303: NEG
83304: PUSH
83305: LD_INT 0
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: LD_INT 4
83314: NEG
83315: PUSH
83316: LD_INT 1
83318: NEG
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: PUSH
83324: LD_INT 4
83326: NEG
83327: PUSH
83328: LD_INT 2
83330: NEG
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PUSH
83336: LD_INT 2
83338: NEG
83339: PUSH
83340: LD_INT 2
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 4
83349: NEG
83350: PUSH
83351: LD_INT 4
83353: NEG
83354: PUSH
83355: EMPTY
83356: LIST
83357: LIST
83358: PUSH
83359: LD_INT 4
83361: NEG
83362: PUSH
83363: LD_INT 5
83365: NEG
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: LD_INT 3
83373: NEG
83374: PUSH
83375: LD_INT 4
83377: NEG
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 3
83385: NEG
83386: PUSH
83387: LD_INT 3
83389: NEG
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 4
83397: NEG
83398: PUSH
83399: LD_INT 3
83401: NEG
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 5
83409: NEG
83410: PUSH
83411: LD_INT 4
83413: NEG
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 5
83421: NEG
83422: PUSH
83423: LD_INT 5
83425: NEG
83426: PUSH
83427: EMPTY
83428: LIST
83429: LIST
83430: PUSH
83431: LD_INT 3
83433: NEG
83434: PUSH
83435: LD_INT 5
83437: NEG
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 5
83445: NEG
83446: PUSH
83447: LD_INT 3
83449: NEG
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 0
83457: PUSH
83458: LD_INT 3
83460: NEG
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 0
83468: PUSH
83469: LD_INT 4
83471: NEG
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 1
83479: PUSH
83480: LD_INT 3
83482: NEG
83483: PUSH
83484: EMPTY
83485: LIST
83486: LIST
83487: PUSH
83488: LD_INT 1
83490: PUSH
83491: LD_INT 2
83493: NEG
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 0
83501: PUSH
83502: LD_INT 2
83504: NEG
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 1
83512: NEG
83513: PUSH
83514: LD_INT 3
83516: NEG
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 1
83524: NEG
83525: PUSH
83526: LD_INT 4
83528: NEG
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 2
83536: PUSH
83537: LD_INT 2
83539: NEG
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 2
83547: NEG
83548: PUSH
83549: LD_INT 4
83551: NEG
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: PUSH
83557: LD_INT 4
83559: PUSH
83560: LD_INT 0
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: PUSH
83567: LD_INT 4
83569: PUSH
83570: LD_INT 1
83572: NEG
83573: PUSH
83574: EMPTY
83575: LIST
83576: LIST
83577: PUSH
83578: LD_INT 5
83580: PUSH
83581: LD_INT 0
83583: PUSH
83584: EMPTY
83585: LIST
83586: LIST
83587: PUSH
83588: LD_INT 5
83590: PUSH
83591: LD_INT 1
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PUSH
83598: LD_INT 4
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 3
83610: PUSH
83611: LD_INT 0
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 3
83620: PUSH
83621: LD_INT 1
83623: NEG
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: PUSH
83629: LD_INT 3
83631: PUSH
83632: LD_INT 2
83634: NEG
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: PUSH
83640: LD_INT 5
83642: PUSH
83643: LD_INT 2
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: LIST
83669: LIST
83670: LIST
83671: LIST
83672: LIST
83673: LIST
83674: LIST
83675: LIST
83676: LIST
83677: LIST
83678: LIST
83679: LIST
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: LIST
83685: LIST
83686: LIST
83687: LIST
83688: LIST
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
83697: LD_ADDR_VAR 0 32
83701: PUSH
83702: LD_INT 4
83704: NEG
83705: PUSH
83706: LD_INT 0
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: PUSH
83713: LD_INT 4
83715: NEG
83716: PUSH
83717: LD_INT 1
83719: NEG
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: PUSH
83725: LD_INT 3
83727: NEG
83728: PUSH
83729: LD_INT 0
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 3
83738: NEG
83739: PUSH
83740: LD_INT 1
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: LD_INT 4
83749: NEG
83750: PUSH
83751: LD_INT 1
83753: PUSH
83754: EMPTY
83755: LIST
83756: LIST
83757: PUSH
83758: LD_INT 5
83760: NEG
83761: PUSH
83762: LD_INT 0
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: PUSH
83769: LD_INT 5
83771: NEG
83772: PUSH
83773: LD_INT 1
83775: NEG
83776: PUSH
83777: EMPTY
83778: LIST
83779: LIST
83780: PUSH
83781: LD_INT 5
83783: NEG
83784: PUSH
83785: LD_INT 2
83787: NEG
83788: PUSH
83789: EMPTY
83790: LIST
83791: LIST
83792: PUSH
83793: LD_INT 3
83795: NEG
83796: PUSH
83797: LD_INT 2
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: LD_INT 3
83806: NEG
83807: PUSH
83808: LD_INT 3
83810: NEG
83811: PUSH
83812: EMPTY
83813: LIST
83814: LIST
83815: PUSH
83816: LD_INT 3
83818: NEG
83819: PUSH
83820: LD_INT 4
83822: NEG
83823: PUSH
83824: EMPTY
83825: LIST
83826: LIST
83827: PUSH
83828: LD_INT 2
83830: NEG
83831: PUSH
83832: LD_INT 3
83834: NEG
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: PUSH
83840: LD_INT 2
83842: NEG
83843: PUSH
83844: LD_INT 2
83846: NEG
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: PUSH
83852: LD_INT 3
83854: NEG
83855: PUSH
83856: LD_INT 2
83858: NEG
83859: PUSH
83860: EMPTY
83861: LIST
83862: LIST
83863: PUSH
83864: LD_INT 4
83866: NEG
83867: PUSH
83868: LD_INT 3
83870: NEG
83871: PUSH
83872: EMPTY
83873: LIST
83874: LIST
83875: PUSH
83876: LD_INT 4
83878: NEG
83879: PUSH
83880: LD_INT 4
83882: NEG
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: PUSH
83888: LD_INT 2
83890: NEG
83891: PUSH
83892: LD_INT 4
83894: NEG
83895: PUSH
83896: EMPTY
83897: LIST
83898: LIST
83899: PUSH
83900: LD_INT 4
83902: NEG
83903: PUSH
83904: LD_INT 2
83906: NEG
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PUSH
83912: LD_INT 0
83914: PUSH
83915: LD_INT 4
83917: NEG
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PUSH
83923: LD_INT 0
83925: PUSH
83926: LD_INT 5
83928: NEG
83929: PUSH
83930: EMPTY
83931: LIST
83932: LIST
83933: PUSH
83934: LD_INT 1
83936: PUSH
83937: LD_INT 4
83939: NEG
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 1
83947: PUSH
83948: LD_INT 3
83950: NEG
83951: PUSH
83952: EMPTY
83953: LIST
83954: LIST
83955: PUSH
83956: LD_INT 0
83958: PUSH
83959: LD_INT 3
83961: NEG
83962: PUSH
83963: EMPTY
83964: LIST
83965: LIST
83966: PUSH
83967: LD_INT 1
83969: NEG
83970: PUSH
83971: LD_INT 4
83973: NEG
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PUSH
83979: LD_INT 1
83981: NEG
83982: PUSH
83983: LD_INT 5
83985: NEG
83986: PUSH
83987: EMPTY
83988: LIST
83989: LIST
83990: PUSH
83991: LD_INT 2
83993: PUSH
83994: LD_INT 3
83996: NEG
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: PUSH
84002: LD_INT 2
84004: NEG
84005: PUSH
84006: LD_INT 5
84008: NEG
84009: PUSH
84010: EMPTY
84011: LIST
84012: LIST
84013: PUSH
84014: LD_INT 3
84016: PUSH
84017: LD_INT 0
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: PUSH
84024: LD_INT 3
84026: PUSH
84027: LD_INT 1
84029: NEG
84030: PUSH
84031: EMPTY
84032: LIST
84033: LIST
84034: PUSH
84035: LD_INT 4
84037: PUSH
84038: LD_INT 0
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 4
84047: PUSH
84048: LD_INT 1
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 3
84057: PUSH
84058: LD_INT 1
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 2
84067: PUSH
84068: LD_INT 0
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 2
84077: PUSH
84078: LD_INT 1
84080: NEG
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 2
84088: PUSH
84089: LD_INT 2
84091: NEG
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: LD_INT 4
84099: PUSH
84100: LD_INT 2
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 4
84109: PUSH
84110: LD_INT 4
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: LD_INT 4
84119: PUSH
84120: LD_INT 3
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 5
84129: PUSH
84130: LD_INT 4
84132: PUSH
84133: EMPTY
84134: LIST
84135: LIST
84136: PUSH
84137: LD_INT 5
84139: PUSH
84140: LD_INT 5
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: PUSH
84147: LD_INT 4
84149: PUSH
84150: LD_INT 5
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 3
84159: PUSH
84160: LD_INT 4
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 3
84169: PUSH
84170: LD_INT 3
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 5
84179: PUSH
84180: LD_INT 3
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 3
84189: PUSH
84190: LD_INT 5
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
84244: LD_ADDR_VAR 0 33
84248: PUSH
84249: LD_INT 4
84251: NEG
84252: PUSH
84253: LD_INT 4
84255: NEG
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: PUSH
84261: LD_INT 4
84263: NEG
84264: PUSH
84265: LD_INT 5
84267: NEG
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: LD_INT 3
84275: NEG
84276: PUSH
84277: LD_INT 4
84279: NEG
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 3
84287: NEG
84288: PUSH
84289: LD_INT 3
84291: NEG
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 4
84299: NEG
84300: PUSH
84301: LD_INT 3
84303: NEG
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PUSH
84309: LD_INT 5
84311: NEG
84312: PUSH
84313: LD_INT 4
84315: NEG
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PUSH
84321: LD_INT 5
84323: NEG
84324: PUSH
84325: LD_INT 5
84327: NEG
84328: PUSH
84329: EMPTY
84330: LIST
84331: LIST
84332: PUSH
84333: LD_INT 3
84335: NEG
84336: PUSH
84337: LD_INT 5
84339: NEG
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_INT 5
84347: NEG
84348: PUSH
84349: LD_INT 3
84351: NEG
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: LD_INT 0
84359: PUSH
84360: LD_INT 3
84362: NEG
84363: PUSH
84364: EMPTY
84365: LIST
84366: LIST
84367: PUSH
84368: LD_INT 0
84370: PUSH
84371: LD_INT 4
84373: NEG
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 1
84381: PUSH
84382: LD_INT 3
84384: NEG
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 1
84392: PUSH
84393: LD_INT 2
84395: NEG
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PUSH
84401: LD_INT 0
84403: PUSH
84404: LD_INT 2
84406: NEG
84407: PUSH
84408: EMPTY
84409: LIST
84410: LIST
84411: PUSH
84412: LD_INT 1
84414: NEG
84415: PUSH
84416: LD_INT 3
84418: NEG
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 1
84426: NEG
84427: PUSH
84428: LD_INT 4
84430: NEG
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 2
84438: PUSH
84439: LD_INT 2
84441: NEG
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PUSH
84447: LD_INT 2
84449: NEG
84450: PUSH
84451: LD_INT 4
84453: NEG
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: LD_INT 4
84461: PUSH
84462: LD_INT 0
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 4
84471: PUSH
84472: LD_INT 1
84474: NEG
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 5
84482: PUSH
84483: LD_INT 0
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 5
84492: PUSH
84493: LD_INT 1
84495: PUSH
84496: EMPTY
84497: LIST
84498: LIST
84499: PUSH
84500: LD_INT 4
84502: PUSH
84503: LD_INT 1
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: PUSH
84510: LD_INT 3
84512: PUSH
84513: LD_INT 0
84515: PUSH
84516: EMPTY
84517: LIST
84518: LIST
84519: PUSH
84520: LD_INT 3
84522: PUSH
84523: LD_INT 1
84525: NEG
84526: PUSH
84527: EMPTY
84528: LIST
84529: LIST
84530: PUSH
84531: LD_INT 3
84533: PUSH
84534: LD_INT 2
84536: NEG
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PUSH
84542: LD_INT 5
84544: PUSH
84545: LD_INT 2
84547: PUSH
84548: EMPTY
84549: LIST
84550: LIST
84551: PUSH
84552: LD_INT 3
84554: PUSH
84555: LD_INT 3
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 3
84564: PUSH
84565: LD_INT 2
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: PUSH
84572: LD_INT 4
84574: PUSH
84575: LD_INT 3
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: PUSH
84582: LD_INT 4
84584: PUSH
84585: LD_INT 4
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 3
84594: PUSH
84595: LD_INT 4
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: PUSH
84602: LD_INT 2
84604: PUSH
84605: LD_INT 3
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 2
84614: PUSH
84615: LD_INT 2
84617: PUSH
84618: EMPTY
84619: LIST
84620: LIST
84621: PUSH
84622: LD_INT 4
84624: PUSH
84625: LD_INT 2
84627: PUSH
84628: EMPTY
84629: LIST
84630: LIST
84631: PUSH
84632: LD_INT 2
84634: PUSH
84635: LD_INT 4
84637: PUSH
84638: EMPTY
84639: LIST
84640: LIST
84641: PUSH
84642: LD_INT 0
84644: PUSH
84645: LD_INT 4
84647: PUSH
84648: EMPTY
84649: LIST
84650: LIST
84651: PUSH
84652: LD_INT 0
84654: PUSH
84655: LD_INT 3
84657: PUSH
84658: EMPTY
84659: LIST
84660: LIST
84661: PUSH
84662: LD_INT 1
84664: PUSH
84665: LD_INT 4
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: PUSH
84672: LD_INT 1
84674: PUSH
84675: LD_INT 5
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: PUSH
84682: LD_INT 0
84684: PUSH
84685: LD_INT 5
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 1
84694: NEG
84695: PUSH
84696: LD_INT 4
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 1
84705: NEG
84706: PUSH
84707: LD_INT 3
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 2
84716: PUSH
84717: LD_INT 5
84719: PUSH
84720: EMPTY
84721: LIST
84722: LIST
84723: PUSH
84724: LD_INT 2
84726: NEG
84727: PUSH
84728: LD_INT 3
84730: PUSH
84731: EMPTY
84732: LIST
84733: LIST
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: LIST
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: LIST
84753: LIST
84754: LIST
84755: LIST
84756: LIST
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
84782: LD_ADDR_VAR 0 34
84786: PUSH
84787: LD_INT 0
84789: PUSH
84790: LD_INT 4
84792: NEG
84793: PUSH
84794: EMPTY
84795: LIST
84796: LIST
84797: PUSH
84798: LD_INT 0
84800: PUSH
84801: LD_INT 5
84803: NEG
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PUSH
84809: LD_INT 1
84811: PUSH
84812: LD_INT 4
84814: NEG
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_INT 1
84822: PUSH
84823: LD_INT 3
84825: NEG
84826: PUSH
84827: EMPTY
84828: LIST
84829: LIST
84830: PUSH
84831: LD_INT 0
84833: PUSH
84834: LD_INT 3
84836: NEG
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: PUSH
84842: LD_INT 1
84844: NEG
84845: PUSH
84846: LD_INT 4
84848: NEG
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: PUSH
84854: LD_INT 1
84856: NEG
84857: PUSH
84858: LD_INT 5
84860: NEG
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: PUSH
84866: LD_INT 2
84868: PUSH
84869: LD_INT 3
84871: NEG
84872: PUSH
84873: EMPTY
84874: LIST
84875: LIST
84876: PUSH
84877: LD_INT 2
84879: NEG
84880: PUSH
84881: LD_INT 5
84883: NEG
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: LD_INT 3
84891: PUSH
84892: LD_INT 0
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: PUSH
84899: LD_INT 3
84901: PUSH
84902: LD_INT 1
84904: NEG
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: LD_INT 4
84912: PUSH
84913: LD_INT 0
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: PUSH
84920: LD_INT 4
84922: PUSH
84923: LD_INT 1
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 3
84932: PUSH
84933: LD_INT 1
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 2
84942: PUSH
84943: LD_INT 0
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 2
84952: PUSH
84953: LD_INT 1
84955: NEG
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 2
84963: PUSH
84964: LD_INT 2
84966: NEG
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 4
84974: PUSH
84975: LD_INT 2
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 4
84984: PUSH
84985: LD_INT 4
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_INT 4
84994: PUSH
84995: LD_INT 3
84997: PUSH
84998: EMPTY
84999: LIST
85000: LIST
85001: PUSH
85002: LD_INT 5
85004: PUSH
85005: LD_INT 4
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 5
85014: PUSH
85015: LD_INT 5
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 4
85024: PUSH
85025: LD_INT 5
85027: PUSH
85028: EMPTY
85029: LIST
85030: LIST
85031: PUSH
85032: LD_INT 3
85034: PUSH
85035: LD_INT 4
85037: PUSH
85038: EMPTY
85039: LIST
85040: LIST
85041: PUSH
85042: LD_INT 3
85044: PUSH
85045: LD_INT 3
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PUSH
85052: LD_INT 5
85054: PUSH
85055: LD_INT 3
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: LD_INT 3
85064: PUSH
85065: LD_INT 5
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 0
85074: PUSH
85075: LD_INT 3
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 0
85084: PUSH
85085: LD_INT 2
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: PUSH
85092: LD_INT 1
85094: PUSH
85095: LD_INT 3
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 1
85104: PUSH
85105: LD_INT 4
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: PUSH
85112: LD_INT 0
85114: PUSH
85115: LD_INT 4
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: PUSH
85122: LD_INT 1
85124: NEG
85125: PUSH
85126: LD_INT 3
85128: PUSH
85129: EMPTY
85130: LIST
85131: LIST
85132: PUSH
85133: LD_INT 1
85135: NEG
85136: PUSH
85137: LD_INT 2
85139: PUSH
85140: EMPTY
85141: LIST
85142: LIST
85143: PUSH
85144: LD_INT 2
85146: PUSH
85147: LD_INT 4
85149: PUSH
85150: EMPTY
85151: LIST
85152: LIST
85153: PUSH
85154: LD_INT 2
85156: NEG
85157: PUSH
85158: LD_INT 2
85160: PUSH
85161: EMPTY
85162: LIST
85163: LIST
85164: PUSH
85165: LD_INT 4
85167: NEG
85168: PUSH
85169: LD_INT 0
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 4
85178: NEG
85179: PUSH
85180: LD_INT 1
85182: NEG
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: PUSH
85188: LD_INT 3
85190: NEG
85191: PUSH
85192: LD_INT 0
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: PUSH
85199: LD_INT 3
85201: NEG
85202: PUSH
85203: LD_INT 1
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: LD_INT 4
85212: NEG
85213: PUSH
85214: LD_INT 1
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 5
85223: NEG
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 5
85234: NEG
85235: PUSH
85236: LD_INT 1
85238: NEG
85239: PUSH
85240: EMPTY
85241: LIST
85242: LIST
85243: PUSH
85244: LD_INT 5
85246: NEG
85247: PUSH
85248: LD_INT 2
85250: NEG
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: LD_INT 3
85258: NEG
85259: PUSH
85260: LD_INT 2
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PUSH
85267: EMPTY
85268: LIST
85269: LIST
85270: LIST
85271: LIST
85272: LIST
85273: LIST
85274: LIST
85275: LIST
85276: LIST
85277: LIST
85278: LIST
85279: LIST
85280: LIST
85281: LIST
85282: LIST
85283: LIST
85284: LIST
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: ST_TO_ADDR
// end ; end ;
85314: GO 85317
85316: POP
// case btype of b_depot , b_warehouse :
85317: LD_VAR 0 1
85321: PUSH
85322: LD_INT 0
85324: DOUBLE
85325: EQUAL
85326: IFTRUE 85336
85328: LD_INT 1
85330: DOUBLE
85331: EQUAL
85332: IFTRUE 85336
85334: GO 85537
85336: POP
// case nation of nation_american :
85337: LD_VAR 0 5
85341: PUSH
85342: LD_INT 1
85344: DOUBLE
85345: EQUAL
85346: IFTRUE 85350
85348: GO 85406
85350: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
85351: LD_ADDR_VAR 0 9
85355: PUSH
85356: LD_VAR 0 11
85360: PUSH
85361: LD_VAR 0 12
85365: PUSH
85366: LD_VAR 0 13
85370: PUSH
85371: LD_VAR 0 14
85375: PUSH
85376: LD_VAR 0 15
85380: PUSH
85381: LD_VAR 0 16
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: LIST
85393: PUSH
85394: LD_VAR 0 4
85398: PUSH
85399: LD_INT 1
85401: PLUS
85402: ARRAY
85403: ST_TO_ADDR
85404: GO 85535
85406: LD_INT 2
85408: DOUBLE
85409: EQUAL
85410: IFTRUE 85414
85412: GO 85470
85414: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
85415: LD_ADDR_VAR 0 9
85419: PUSH
85420: LD_VAR 0 17
85424: PUSH
85425: LD_VAR 0 18
85429: PUSH
85430: LD_VAR 0 19
85434: PUSH
85435: LD_VAR 0 20
85439: PUSH
85440: LD_VAR 0 21
85444: PUSH
85445: LD_VAR 0 22
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: LIST
85454: LIST
85455: LIST
85456: LIST
85457: PUSH
85458: LD_VAR 0 4
85462: PUSH
85463: LD_INT 1
85465: PLUS
85466: ARRAY
85467: ST_TO_ADDR
85468: GO 85535
85470: LD_INT 3
85472: DOUBLE
85473: EQUAL
85474: IFTRUE 85478
85476: GO 85534
85478: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
85479: LD_ADDR_VAR 0 9
85483: PUSH
85484: LD_VAR 0 23
85488: PUSH
85489: LD_VAR 0 24
85493: PUSH
85494: LD_VAR 0 25
85498: PUSH
85499: LD_VAR 0 26
85503: PUSH
85504: LD_VAR 0 27
85508: PUSH
85509: LD_VAR 0 28
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: PUSH
85522: LD_VAR 0 4
85526: PUSH
85527: LD_INT 1
85529: PLUS
85530: ARRAY
85531: ST_TO_ADDR
85532: GO 85535
85534: POP
85535: GO 86090
85537: LD_INT 2
85539: DOUBLE
85540: EQUAL
85541: IFTRUE 85551
85543: LD_INT 3
85545: DOUBLE
85546: EQUAL
85547: IFTRUE 85551
85549: GO 85607
85551: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
85552: LD_ADDR_VAR 0 9
85556: PUSH
85557: LD_VAR 0 29
85561: PUSH
85562: LD_VAR 0 30
85566: PUSH
85567: LD_VAR 0 31
85571: PUSH
85572: LD_VAR 0 32
85576: PUSH
85577: LD_VAR 0 33
85581: PUSH
85582: LD_VAR 0 34
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: LIST
85593: LIST
85594: PUSH
85595: LD_VAR 0 4
85599: PUSH
85600: LD_INT 1
85602: PLUS
85603: ARRAY
85604: ST_TO_ADDR
85605: GO 86090
85607: LD_INT 16
85609: DOUBLE
85610: EQUAL
85611: IFTRUE 85669
85613: LD_INT 17
85615: DOUBLE
85616: EQUAL
85617: IFTRUE 85669
85619: LD_INT 18
85621: DOUBLE
85622: EQUAL
85623: IFTRUE 85669
85625: LD_INT 19
85627: DOUBLE
85628: EQUAL
85629: IFTRUE 85669
85631: LD_INT 22
85633: DOUBLE
85634: EQUAL
85635: IFTRUE 85669
85637: LD_INT 20
85639: DOUBLE
85640: EQUAL
85641: IFTRUE 85669
85643: LD_INT 21
85645: DOUBLE
85646: EQUAL
85647: IFTRUE 85669
85649: LD_INT 23
85651: DOUBLE
85652: EQUAL
85653: IFTRUE 85669
85655: LD_INT 24
85657: DOUBLE
85658: EQUAL
85659: IFTRUE 85669
85661: LD_INT 25
85663: DOUBLE
85664: EQUAL
85665: IFTRUE 85669
85667: GO 85725
85669: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
85670: LD_ADDR_VAR 0 9
85674: PUSH
85675: LD_VAR 0 35
85679: PUSH
85680: LD_VAR 0 36
85684: PUSH
85685: LD_VAR 0 37
85689: PUSH
85690: LD_VAR 0 38
85694: PUSH
85695: LD_VAR 0 39
85699: PUSH
85700: LD_VAR 0 40
85704: PUSH
85705: EMPTY
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: PUSH
85713: LD_VAR 0 4
85717: PUSH
85718: LD_INT 1
85720: PLUS
85721: ARRAY
85722: ST_TO_ADDR
85723: GO 86090
85725: LD_INT 6
85727: DOUBLE
85728: EQUAL
85729: IFTRUE 85781
85731: LD_INT 7
85733: DOUBLE
85734: EQUAL
85735: IFTRUE 85781
85737: LD_INT 8
85739: DOUBLE
85740: EQUAL
85741: IFTRUE 85781
85743: LD_INT 13
85745: DOUBLE
85746: EQUAL
85747: IFTRUE 85781
85749: LD_INT 12
85751: DOUBLE
85752: EQUAL
85753: IFTRUE 85781
85755: LD_INT 15
85757: DOUBLE
85758: EQUAL
85759: IFTRUE 85781
85761: LD_INT 11
85763: DOUBLE
85764: EQUAL
85765: IFTRUE 85781
85767: LD_INT 14
85769: DOUBLE
85770: EQUAL
85771: IFTRUE 85781
85773: LD_INT 10
85775: DOUBLE
85776: EQUAL
85777: IFTRUE 85781
85779: GO 85837
85781: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
85782: LD_ADDR_VAR 0 9
85786: PUSH
85787: LD_VAR 0 41
85791: PUSH
85792: LD_VAR 0 42
85796: PUSH
85797: LD_VAR 0 43
85801: PUSH
85802: LD_VAR 0 44
85806: PUSH
85807: LD_VAR 0 45
85811: PUSH
85812: LD_VAR 0 46
85816: PUSH
85817: EMPTY
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: LIST
85823: LIST
85824: PUSH
85825: LD_VAR 0 4
85829: PUSH
85830: LD_INT 1
85832: PLUS
85833: ARRAY
85834: ST_TO_ADDR
85835: GO 86090
85837: LD_INT 36
85839: DOUBLE
85840: EQUAL
85841: IFTRUE 85845
85843: GO 85901
85845: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
85846: LD_ADDR_VAR 0 9
85850: PUSH
85851: LD_VAR 0 47
85855: PUSH
85856: LD_VAR 0 48
85860: PUSH
85861: LD_VAR 0 49
85865: PUSH
85866: LD_VAR 0 50
85870: PUSH
85871: LD_VAR 0 51
85875: PUSH
85876: LD_VAR 0 52
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: PUSH
85889: LD_VAR 0 4
85893: PUSH
85894: LD_INT 1
85896: PLUS
85897: ARRAY
85898: ST_TO_ADDR
85899: GO 86090
85901: LD_INT 4
85903: DOUBLE
85904: EQUAL
85905: IFTRUE 85927
85907: LD_INT 5
85909: DOUBLE
85910: EQUAL
85911: IFTRUE 85927
85913: LD_INT 34
85915: DOUBLE
85916: EQUAL
85917: IFTRUE 85927
85919: LD_INT 37
85921: DOUBLE
85922: EQUAL
85923: IFTRUE 85927
85925: GO 85983
85927: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
85928: LD_ADDR_VAR 0 9
85932: PUSH
85933: LD_VAR 0 53
85937: PUSH
85938: LD_VAR 0 54
85942: PUSH
85943: LD_VAR 0 55
85947: PUSH
85948: LD_VAR 0 56
85952: PUSH
85953: LD_VAR 0 57
85957: PUSH
85958: LD_VAR 0 58
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: PUSH
85971: LD_VAR 0 4
85975: PUSH
85976: LD_INT 1
85978: PLUS
85979: ARRAY
85980: ST_TO_ADDR
85981: GO 86090
85983: LD_INT 31
85985: DOUBLE
85986: EQUAL
85987: IFTRUE 86033
85989: LD_INT 32
85991: DOUBLE
85992: EQUAL
85993: IFTRUE 86033
85995: LD_INT 33
85997: DOUBLE
85998: EQUAL
85999: IFTRUE 86033
86001: LD_INT 27
86003: DOUBLE
86004: EQUAL
86005: IFTRUE 86033
86007: LD_INT 26
86009: DOUBLE
86010: EQUAL
86011: IFTRUE 86033
86013: LD_INT 28
86015: DOUBLE
86016: EQUAL
86017: IFTRUE 86033
86019: LD_INT 29
86021: DOUBLE
86022: EQUAL
86023: IFTRUE 86033
86025: LD_INT 30
86027: DOUBLE
86028: EQUAL
86029: IFTRUE 86033
86031: GO 86089
86033: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
86034: LD_ADDR_VAR 0 9
86038: PUSH
86039: LD_VAR 0 59
86043: PUSH
86044: LD_VAR 0 60
86048: PUSH
86049: LD_VAR 0 61
86053: PUSH
86054: LD_VAR 0 62
86058: PUSH
86059: LD_VAR 0 63
86063: PUSH
86064: LD_VAR 0 64
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: PUSH
86077: LD_VAR 0 4
86081: PUSH
86082: LD_INT 1
86084: PLUS
86085: ARRAY
86086: ST_TO_ADDR
86087: GO 86090
86089: POP
// temp_list2 = [ ] ;
86090: LD_ADDR_VAR 0 10
86094: PUSH
86095: EMPTY
86096: ST_TO_ADDR
// for i in temp_list do
86097: LD_ADDR_VAR 0 8
86101: PUSH
86102: LD_VAR 0 9
86106: PUSH
86107: FOR_IN
86108: IFFALSE 86160
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
86110: LD_ADDR_VAR 0 10
86114: PUSH
86115: LD_VAR 0 10
86119: PUSH
86120: LD_VAR 0 8
86124: PUSH
86125: LD_INT 1
86127: ARRAY
86128: PUSH
86129: LD_VAR 0 2
86133: PLUS
86134: PUSH
86135: LD_VAR 0 8
86139: PUSH
86140: LD_INT 2
86142: ARRAY
86143: PUSH
86144: LD_VAR 0 3
86148: PLUS
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: PUSH
86154: EMPTY
86155: LIST
86156: ADD
86157: ST_TO_ADDR
86158: GO 86107
86160: POP
86161: POP
// result = temp_list2 ;
86162: LD_ADDR_VAR 0 7
86166: PUSH
86167: LD_VAR 0 10
86171: ST_TO_ADDR
// end ;
86172: LD_VAR 0 7
86176: RET
// export function EnemyInRange ( unit , dist ) ; begin
86177: LD_INT 0
86179: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
86180: LD_ADDR_VAR 0 3
86184: PUSH
86185: LD_VAR 0 1
86189: PPUSH
86190: CALL_OW 255
86194: PPUSH
86195: LD_VAR 0 1
86199: PPUSH
86200: CALL_OW 250
86204: PPUSH
86205: LD_VAR 0 1
86209: PPUSH
86210: CALL_OW 251
86214: PPUSH
86215: LD_VAR 0 2
86219: PPUSH
86220: CALL 59550 0 4
86224: PUSH
86225: LD_INT 4
86227: ARRAY
86228: ST_TO_ADDR
// end ;
86229: LD_VAR 0 3
86233: RET
// export function PlayerSeeMe ( unit ) ; begin
86234: LD_INT 0
86236: PPUSH
// result := See ( your_side , unit ) ;
86237: LD_ADDR_VAR 0 2
86241: PUSH
86242: LD_OWVAR 2
86246: PPUSH
86247: LD_VAR 0 1
86251: PPUSH
86252: CALL_OW 292
86256: ST_TO_ADDR
// end ;
86257: LD_VAR 0 2
86261: RET
// export function ReverseDir ( unit ) ; begin
86262: LD_INT 0
86264: PPUSH
// if not unit then
86265: LD_VAR 0 1
86269: NOT
86270: IFFALSE 86274
// exit ;
86272: GO 86297
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
86274: LD_ADDR_VAR 0 2
86278: PUSH
86279: LD_VAR 0 1
86283: PPUSH
86284: CALL_OW 254
86288: PUSH
86289: LD_INT 3
86291: PLUS
86292: PUSH
86293: LD_INT 6
86295: MOD
86296: ST_TO_ADDR
// end ;
86297: LD_VAR 0 2
86301: RET
// export function ReverseArray ( array ) ; var i ; begin
86302: LD_INT 0
86304: PPUSH
86305: PPUSH
// if not array then
86306: LD_VAR 0 1
86310: NOT
86311: IFFALSE 86315
// exit ;
86313: GO 86370
// result := [ ] ;
86315: LD_ADDR_VAR 0 2
86319: PUSH
86320: EMPTY
86321: ST_TO_ADDR
// for i := array downto 1 do
86322: LD_ADDR_VAR 0 3
86326: PUSH
86327: DOUBLE
86328: LD_VAR 0 1
86332: INC
86333: ST_TO_ADDR
86334: LD_INT 1
86336: PUSH
86337: FOR_DOWNTO
86338: IFFALSE 86368
// result := Join ( result , array [ i ] ) ;
86340: LD_ADDR_VAR 0 2
86344: PUSH
86345: LD_VAR 0 2
86349: PPUSH
86350: LD_VAR 0 1
86354: PUSH
86355: LD_VAR 0 3
86359: ARRAY
86360: PPUSH
86361: CALL 91015 0 2
86365: ST_TO_ADDR
86366: GO 86337
86368: POP
86369: POP
// end ;
86370: LD_VAR 0 2
86374: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
86375: LD_INT 0
86377: PPUSH
86378: PPUSH
86379: PPUSH
86380: PPUSH
86381: PPUSH
86382: PPUSH
// if not unit or not hexes then
86383: LD_VAR 0 1
86387: NOT
86388: PUSH
86389: LD_VAR 0 2
86393: NOT
86394: OR
86395: IFFALSE 86399
// exit ;
86397: GO 86522
// dist := 9999 ;
86399: LD_ADDR_VAR 0 5
86403: PUSH
86404: LD_INT 9999
86406: ST_TO_ADDR
// for i = 1 to hexes do
86407: LD_ADDR_VAR 0 4
86411: PUSH
86412: DOUBLE
86413: LD_INT 1
86415: DEC
86416: ST_TO_ADDR
86417: LD_VAR 0 2
86421: PUSH
86422: FOR_TO
86423: IFFALSE 86510
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
86425: LD_ADDR_VAR 0 6
86429: PUSH
86430: LD_VAR 0 1
86434: PPUSH
86435: LD_VAR 0 2
86439: PUSH
86440: LD_VAR 0 4
86444: ARRAY
86445: PUSH
86446: LD_INT 1
86448: ARRAY
86449: PPUSH
86450: LD_VAR 0 2
86454: PUSH
86455: LD_VAR 0 4
86459: ARRAY
86460: PUSH
86461: LD_INT 2
86463: ARRAY
86464: PPUSH
86465: CALL_OW 297
86469: ST_TO_ADDR
// if tdist < dist then
86470: LD_VAR 0 6
86474: PUSH
86475: LD_VAR 0 5
86479: LESS
86480: IFFALSE 86508
// begin hex := hexes [ i ] ;
86482: LD_ADDR_VAR 0 8
86486: PUSH
86487: LD_VAR 0 2
86491: PUSH
86492: LD_VAR 0 4
86496: ARRAY
86497: ST_TO_ADDR
// dist := tdist ;
86498: LD_ADDR_VAR 0 5
86502: PUSH
86503: LD_VAR 0 6
86507: ST_TO_ADDR
// end ; end ;
86508: GO 86422
86510: POP
86511: POP
// result := hex ;
86512: LD_ADDR_VAR 0 3
86516: PUSH
86517: LD_VAR 0 8
86521: ST_TO_ADDR
// end ;
86522: LD_VAR 0 3
86526: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
86527: LD_INT 0
86529: PPUSH
86530: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86531: LD_VAR 0 1
86535: NOT
86536: PUSH
86537: LD_VAR 0 1
86541: PUSH
86542: LD_INT 21
86544: PUSH
86545: LD_INT 2
86547: PUSH
86548: EMPTY
86549: LIST
86550: LIST
86551: PUSH
86552: LD_INT 23
86554: PUSH
86555: LD_INT 2
86557: PUSH
86558: EMPTY
86559: LIST
86560: LIST
86561: PUSH
86562: EMPTY
86563: LIST
86564: LIST
86565: PPUSH
86566: CALL_OW 69
86570: IN
86571: NOT
86572: OR
86573: IFFALSE 86577
// exit ;
86575: GO 86624
// for i = 1 to 3 do
86577: LD_ADDR_VAR 0 3
86581: PUSH
86582: DOUBLE
86583: LD_INT 1
86585: DEC
86586: ST_TO_ADDR
86587: LD_INT 3
86589: PUSH
86590: FOR_TO
86591: IFFALSE 86622
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
86593: LD_VAR 0 1
86597: PPUSH
86598: CALL_OW 250
86602: PPUSH
86603: LD_VAR 0 1
86607: PPUSH
86608: CALL_OW 251
86612: PPUSH
86613: LD_INT 1
86615: PPUSH
86616: CALL_OW 453
86620: GO 86590
86622: POP
86623: POP
// end ;
86624: LD_VAR 0 2
86628: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
86629: LD_INT 0
86631: PPUSH
86632: PPUSH
86633: PPUSH
86634: PPUSH
86635: PPUSH
86636: PPUSH
// if not unit or not enemy_unit then
86637: LD_VAR 0 1
86641: NOT
86642: PUSH
86643: LD_VAR 0 2
86647: NOT
86648: OR
86649: IFFALSE 86653
// exit ;
86651: GO 87120
// if GetLives ( i ) < 250 then
86653: LD_VAR 0 4
86657: PPUSH
86658: CALL_OW 256
86662: PUSH
86663: LD_INT 250
86665: LESS
86666: IFFALSE 86679
// begin ComAutodestruct ( i ) ;
86668: LD_VAR 0 4
86672: PPUSH
86673: CALL 86527 0 1
// exit ;
86677: GO 87120
// end ; x := GetX ( enemy_unit ) ;
86679: LD_ADDR_VAR 0 7
86683: PUSH
86684: LD_VAR 0 2
86688: PPUSH
86689: CALL_OW 250
86693: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
86694: LD_ADDR_VAR 0 8
86698: PUSH
86699: LD_VAR 0 2
86703: PPUSH
86704: CALL_OW 251
86708: ST_TO_ADDR
// if not x or not y then
86709: LD_VAR 0 7
86713: NOT
86714: PUSH
86715: LD_VAR 0 8
86719: NOT
86720: OR
86721: IFFALSE 86725
// exit ;
86723: GO 87120
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
86725: LD_ADDR_VAR 0 6
86729: PUSH
86730: LD_VAR 0 7
86734: PPUSH
86735: LD_INT 0
86737: PPUSH
86738: LD_INT 4
86740: PPUSH
86741: CALL_OW 272
86745: PUSH
86746: LD_VAR 0 8
86750: PPUSH
86751: LD_INT 0
86753: PPUSH
86754: LD_INT 4
86756: PPUSH
86757: CALL_OW 273
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_VAR 0 7
86770: PPUSH
86771: LD_INT 1
86773: PPUSH
86774: LD_INT 4
86776: PPUSH
86777: CALL_OW 272
86781: PUSH
86782: LD_VAR 0 8
86786: PPUSH
86787: LD_INT 1
86789: PPUSH
86790: LD_INT 4
86792: PPUSH
86793: CALL_OW 273
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_VAR 0 7
86806: PPUSH
86807: LD_INT 2
86809: PPUSH
86810: LD_INT 4
86812: PPUSH
86813: CALL_OW 272
86817: PUSH
86818: LD_VAR 0 8
86822: PPUSH
86823: LD_INT 2
86825: PPUSH
86826: LD_INT 4
86828: PPUSH
86829: CALL_OW 273
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_VAR 0 7
86842: PPUSH
86843: LD_INT 3
86845: PPUSH
86846: LD_INT 4
86848: PPUSH
86849: CALL_OW 272
86853: PUSH
86854: LD_VAR 0 8
86858: PPUSH
86859: LD_INT 3
86861: PPUSH
86862: LD_INT 4
86864: PPUSH
86865: CALL_OW 273
86869: PUSH
86870: EMPTY
86871: LIST
86872: LIST
86873: PUSH
86874: LD_VAR 0 7
86878: PPUSH
86879: LD_INT 4
86881: PPUSH
86882: LD_INT 4
86884: PPUSH
86885: CALL_OW 272
86889: PUSH
86890: LD_VAR 0 8
86894: PPUSH
86895: LD_INT 4
86897: PPUSH
86898: LD_INT 4
86900: PPUSH
86901: CALL_OW 273
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: LD_VAR 0 7
86914: PPUSH
86915: LD_INT 5
86917: PPUSH
86918: LD_INT 4
86920: PPUSH
86921: CALL_OW 272
86925: PUSH
86926: LD_VAR 0 8
86930: PPUSH
86931: LD_INT 5
86933: PPUSH
86934: LD_INT 4
86936: PPUSH
86937: CALL_OW 273
86941: PUSH
86942: EMPTY
86943: LIST
86944: LIST
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: LIST
86950: LIST
86951: LIST
86952: LIST
86953: ST_TO_ADDR
// for i = tmp downto 1 do
86954: LD_ADDR_VAR 0 4
86958: PUSH
86959: DOUBLE
86960: LD_VAR 0 6
86964: INC
86965: ST_TO_ADDR
86966: LD_INT 1
86968: PUSH
86969: FOR_DOWNTO
86970: IFFALSE 87071
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
86972: LD_VAR 0 6
86976: PUSH
86977: LD_VAR 0 4
86981: ARRAY
86982: PUSH
86983: LD_INT 1
86985: ARRAY
86986: PPUSH
86987: LD_VAR 0 6
86991: PUSH
86992: LD_VAR 0 4
86996: ARRAY
86997: PUSH
86998: LD_INT 2
87000: ARRAY
87001: PPUSH
87002: CALL_OW 488
87006: NOT
87007: PUSH
87008: LD_VAR 0 6
87012: PUSH
87013: LD_VAR 0 4
87017: ARRAY
87018: PUSH
87019: LD_INT 1
87021: ARRAY
87022: PPUSH
87023: LD_VAR 0 6
87027: PUSH
87028: LD_VAR 0 4
87032: ARRAY
87033: PUSH
87034: LD_INT 2
87036: ARRAY
87037: PPUSH
87038: CALL_OW 428
87042: PUSH
87043: LD_INT 0
87045: NONEQUAL
87046: OR
87047: IFFALSE 87069
// tmp := Delete ( tmp , i ) ;
87049: LD_ADDR_VAR 0 6
87053: PUSH
87054: LD_VAR 0 6
87058: PPUSH
87059: LD_VAR 0 4
87063: PPUSH
87064: CALL_OW 3
87068: ST_TO_ADDR
87069: GO 86969
87071: POP
87072: POP
// j := GetClosestHex ( unit , tmp ) ;
87073: LD_ADDR_VAR 0 5
87077: PUSH
87078: LD_VAR 0 1
87082: PPUSH
87083: LD_VAR 0 6
87087: PPUSH
87088: CALL 86375 0 2
87092: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
87093: LD_VAR 0 1
87097: PPUSH
87098: LD_VAR 0 5
87102: PUSH
87103: LD_INT 1
87105: ARRAY
87106: PPUSH
87107: LD_VAR 0 5
87111: PUSH
87112: LD_INT 2
87114: ARRAY
87115: PPUSH
87116: CALL_OW 111
// end ;
87120: LD_VAR 0 3
87124: RET
// export function PrepareApemanSoldier ( ) ; begin
87125: LD_INT 0
87127: PPUSH
// uc_nation := 0 ;
87128: LD_ADDR_OWVAR 21
87132: PUSH
87133: LD_INT 0
87135: ST_TO_ADDR
// hc_sex := sex_male ;
87136: LD_ADDR_OWVAR 27
87140: PUSH
87141: LD_INT 1
87143: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
87144: LD_ADDR_OWVAR 28
87148: PUSH
87149: LD_INT 15
87151: ST_TO_ADDR
// hc_gallery :=  ;
87152: LD_ADDR_OWVAR 33
87156: PUSH
87157: LD_STRING 
87159: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87160: LD_ADDR_OWVAR 31
87164: PUSH
87165: LD_INT 0
87167: PPUSH
87168: LD_INT 3
87170: PPUSH
87171: CALL_OW 12
87175: PUSH
87176: LD_INT 0
87178: PPUSH
87179: LD_INT 3
87181: PPUSH
87182: CALL_OW 12
87186: PUSH
87187: LD_INT 0
87189: PUSH
87190: LD_INT 0
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: ST_TO_ADDR
// end ;
87199: LD_VAR 0 1
87203: RET
// export function PrepareApemanEngineer ( ) ; begin
87204: LD_INT 0
87206: PPUSH
// uc_nation := 0 ;
87207: LD_ADDR_OWVAR 21
87211: PUSH
87212: LD_INT 0
87214: ST_TO_ADDR
// hc_sex := sex_male ;
87215: LD_ADDR_OWVAR 27
87219: PUSH
87220: LD_INT 1
87222: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
87223: LD_ADDR_OWVAR 28
87227: PUSH
87228: LD_INT 16
87230: ST_TO_ADDR
// hc_gallery :=  ;
87231: LD_ADDR_OWVAR 33
87235: PUSH
87236: LD_STRING 
87238: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87239: LD_ADDR_OWVAR 31
87243: PUSH
87244: LD_INT 0
87246: PPUSH
87247: LD_INT 3
87249: PPUSH
87250: CALL_OW 12
87254: PUSH
87255: LD_INT 0
87257: PPUSH
87258: LD_INT 3
87260: PPUSH
87261: CALL_OW 12
87265: PUSH
87266: LD_INT 0
87268: PUSH
87269: LD_INT 0
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: ST_TO_ADDR
// end ;
87278: LD_VAR 0 1
87282: RET
// export function PrepareApeman ( agressivity ) ; begin
87283: LD_INT 0
87285: PPUSH
// uc_side := 0 ;
87286: LD_ADDR_OWVAR 20
87290: PUSH
87291: LD_INT 0
87293: ST_TO_ADDR
// uc_nation := 0 ;
87294: LD_ADDR_OWVAR 21
87298: PUSH
87299: LD_INT 0
87301: ST_TO_ADDR
// hc_sex := sex_male ;
87302: LD_ADDR_OWVAR 27
87306: PUSH
87307: LD_INT 1
87309: ST_TO_ADDR
// hc_class := class_apeman ;
87310: LD_ADDR_OWVAR 28
87314: PUSH
87315: LD_INT 12
87317: ST_TO_ADDR
// hc_gallery :=  ;
87318: LD_ADDR_OWVAR 33
87322: PUSH
87323: LD_STRING 
87325: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87326: LD_ADDR_OWVAR 35
87330: PUSH
87331: LD_VAR 0 1
87335: NEG
87336: PPUSH
87337: LD_VAR 0 1
87341: PPUSH
87342: CALL_OW 12
87346: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87347: LD_ADDR_OWVAR 31
87351: PUSH
87352: LD_INT 0
87354: PPUSH
87355: LD_INT 3
87357: PPUSH
87358: CALL_OW 12
87362: PUSH
87363: LD_INT 0
87365: PPUSH
87366: LD_INT 3
87368: PPUSH
87369: CALL_OW 12
87373: PUSH
87374: LD_INT 0
87376: PUSH
87377: LD_INT 0
87379: PUSH
87380: EMPTY
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: ST_TO_ADDR
// end ;
87386: LD_VAR 0 2
87390: RET
// export function PrepareTiger ( agressivity ) ; begin
87391: LD_INT 0
87393: PPUSH
// uc_side := 0 ;
87394: LD_ADDR_OWVAR 20
87398: PUSH
87399: LD_INT 0
87401: ST_TO_ADDR
// uc_nation := 0 ;
87402: LD_ADDR_OWVAR 21
87406: PUSH
87407: LD_INT 0
87409: ST_TO_ADDR
// hc_class := class_tiger ;
87410: LD_ADDR_OWVAR 28
87414: PUSH
87415: LD_INT 14
87417: ST_TO_ADDR
// hc_gallery :=  ;
87418: LD_ADDR_OWVAR 33
87422: PUSH
87423: LD_STRING 
87425: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87426: LD_ADDR_OWVAR 35
87430: PUSH
87431: LD_VAR 0 1
87435: NEG
87436: PPUSH
87437: LD_VAR 0 1
87441: PPUSH
87442: CALL_OW 12
87446: ST_TO_ADDR
// end ;
87447: LD_VAR 0 2
87451: RET
// export function PrepareEnchidna ( ) ; begin
87452: LD_INT 0
87454: PPUSH
// uc_side := 0 ;
87455: LD_ADDR_OWVAR 20
87459: PUSH
87460: LD_INT 0
87462: ST_TO_ADDR
// uc_nation := 0 ;
87463: LD_ADDR_OWVAR 21
87467: PUSH
87468: LD_INT 0
87470: ST_TO_ADDR
// hc_class := class_baggie ;
87471: LD_ADDR_OWVAR 28
87475: PUSH
87476: LD_INT 13
87478: ST_TO_ADDR
// hc_gallery :=  ;
87479: LD_ADDR_OWVAR 33
87483: PUSH
87484: LD_STRING 
87486: ST_TO_ADDR
// end ;
87487: LD_VAR 0 1
87491: RET
// export function PrepareFrog ( ) ; begin
87492: LD_INT 0
87494: PPUSH
// uc_side := 0 ;
87495: LD_ADDR_OWVAR 20
87499: PUSH
87500: LD_INT 0
87502: ST_TO_ADDR
// uc_nation := 0 ;
87503: LD_ADDR_OWVAR 21
87507: PUSH
87508: LD_INT 0
87510: ST_TO_ADDR
// hc_class := class_frog ;
87511: LD_ADDR_OWVAR 28
87515: PUSH
87516: LD_INT 19
87518: ST_TO_ADDR
// hc_gallery :=  ;
87519: LD_ADDR_OWVAR 33
87523: PUSH
87524: LD_STRING 
87526: ST_TO_ADDR
// end ;
87527: LD_VAR 0 1
87531: RET
// export function PrepareFish ( ) ; begin
87532: LD_INT 0
87534: PPUSH
// uc_side := 0 ;
87535: LD_ADDR_OWVAR 20
87539: PUSH
87540: LD_INT 0
87542: ST_TO_ADDR
// uc_nation := 0 ;
87543: LD_ADDR_OWVAR 21
87547: PUSH
87548: LD_INT 0
87550: ST_TO_ADDR
// hc_class := class_fish ;
87551: LD_ADDR_OWVAR 28
87555: PUSH
87556: LD_INT 20
87558: ST_TO_ADDR
// hc_gallery :=  ;
87559: LD_ADDR_OWVAR 33
87563: PUSH
87564: LD_STRING 
87566: ST_TO_ADDR
// end ;
87567: LD_VAR 0 1
87571: RET
// export function PrepareBird ( ) ; begin
87572: LD_INT 0
87574: PPUSH
// uc_side := 0 ;
87575: LD_ADDR_OWVAR 20
87579: PUSH
87580: LD_INT 0
87582: ST_TO_ADDR
// uc_nation := 0 ;
87583: LD_ADDR_OWVAR 21
87587: PUSH
87588: LD_INT 0
87590: ST_TO_ADDR
// hc_class := class_phororhacos ;
87591: LD_ADDR_OWVAR 28
87595: PUSH
87596: LD_INT 18
87598: ST_TO_ADDR
// hc_gallery :=  ;
87599: LD_ADDR_OWVAR 33
87603: PUSH
87604: LD_STRING 
87606: ST_TO_ADDR
// end ;
87607: LD_VAR 0 1
87611: RET
// export function PrepareHorse ( ) ; begin
87612: LD_INT 0
87614: PPUSH
// uc_side := 0 ;
87615: LD_ADDR_OWVAR 20
87619: PUSH
87620: LD_INT 0
87622: ST_TO_ADDR
// uc_nation := 0 ;
87623: LD_ADDR_OWVAR 21
87627: PUSH
87628: LD_INT 0
87630: ST_TO_ADDR
// hc_class := class_horse ;
87631: LD_ADDR_OWVAR 28
87635: PUSH
87636: LD_INT 21
87638: ST_TO_ADDR
// hc_gallery :=  ;
87639: LD_ADDR_OWVAR 33
87643: PUSH
87644: LD_STRING 
87646: ST_TO_ADDR
// end ;
87647: LD_VAR 0 1
87651: RET
// export function PrepareMastodont ( ) ; begin
87652: LD_INT 0
87654: PPUSH
// uc_side := 0 ;
87655: LD_ADDR_OWVAR 20
87659: PUSH
87660: LD_INT 0
87662: ST_TO_ADDR
// uc_nation := 0 ;
87663: LD_ADDR_OWVAR 21
87667: PUSH
87668: LD_INT 0
87670: ST_TO_ADDR
// vc_chassis := class_mastodont ;
87671: LD_ADDR_OWVAR 37
87675: PUSH
87676: LD_INT 31
87678: ST_TO_ADDR
// vc_control := control_rider ;
87679: LD_ADDR_OWVAR 38
87683: PUSH
87684: LD_INT 4
87686: ST_TO_ADDR
// end ;
87687: LD_VAR 0 1
87691: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
87692: LD_INT 0
87694: PPUSH
87695: PPUSH
87696: PPUSH
// uc_side = 0 ;
87697: LD_ADDR_OWVAR 20
87701: PUSH
87702: LD_INT 0
87704: ST_TO_ADDR
// uc_nation = 0 ;
87705: LD_ADDR_OWVAR 21
87709: PUSH
87710: LD_INT 0
87712: ST_TO_ADDR
// InitHc_All ( ) ;
87713: CALL_OW 584
// InitVc ;
87717: CALL_OW 20
// if mastodonts then
87721: LD_VAR 0 6
87725: IFFALSE 87792
// for i = 1 to mastodonts do
87727: LD_ADDR_VAR 0 11
87731: PUSH
87732: DOUBLE
87733: LD_INT 1
87735: DEC
87736: ST_TO_ADDR
87737: LD_VAR 0 6
87741: PUSH
87742: FOR_TO
87743: IFFALSE 87790
// begin vc_chassis := 31 ;
87745: LD_ADDR_OWVAR 37
87749: PUSH
87750: LD_INT 31
87752: ST_TO_ADDR
// vc_control := control_rider ;
87753: LD_ADDR_OWVAR 38
87757: PUSH
87758: LD_INT 4
87760: ST_TO_ADDR
// animal := CreateVehicle ;
87761: LD_ADDR_VAR 0 12
87765: PUSH
87766: CALL_OW 45
87770: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87771: LD_VAR 0 12
87775: PPUSH
87776: LD_VAR 0 8
87780: PPUSH
87781: LD_INT 0
87783: PPUSH
87784: CALL 89920 0 3
// end ;
87788: GO 87742
87790: POP
87791: POP
// if horses then
87792: LD_VAR 0 5
87796: IFFALSE 87863
// for i = 1 to horses do
87798: LD_ADDR_VAR 0 11
87802: PUSH
87803: DOUBLE
87804: LD_INT 1
87806: DEC
87807: ST_TO_ADDR
87808: LD_VAR 0 5
87812: PUSH
87813: FOR_TO
87814: IFFALSE 87861
// begin hc_class := 21 ;
87816: LD_ADDR_OWVAR 28
87820: PUSH
87821: LD_INT 21
87823: ST_TO_ADDR
// hc_gallery :=  ;
87824: LD_ADDR_OWVAR 33
87828: PUSH
87829: LD_STRING 
87831: ST_TO_ADDR
// animal := CreateHuman ;
87832: LD_ADDR_VAR 0 12
87836: PUSH
87837: CALL_OW 44
87841: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87842: LD_VAR 0 12
87846: PPUSH
87847: LD_VAR 0 8
87851: PPUSH
87852: LD_INT 0
87854: PPUSH
87855: CALL 89920 0 3
// end ;
87859: GO 87813
87861: POP
87862: POP
// if birds then
87863: LD_VAR 0 1
87867: IFFALSE 87934
// for i = 1 to birds do
87869: LD_ADDR_VAR 0 11
87873: PUSH
87874: DOUBLE
87875: LD_INT 1
87877: DEC
87878: ST_TO_ADDR
87879: LD_VAR 0 1
87883: PUSH
87884: FOR_TO
87885: IFFALSE 87932
// begin hc_class := 18 ;
87887: LD_ADDR_OWVAR 28
87891: PUSH
87892: LD_INT 18
87894: ST_TO_ADDR
// hc_gallery =  ;
87895: LD_ADDR_OWVAR 33
87899: PUSH
87900: LD_STRING 
87902: ST_TO_ADDR
// animal := CreateHuman ;
87903: LD_ADDR_VAR 0 12
87907: PUSH
87908: CALL_OW 44
87912: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87913: LD_VAR 0 12
87917: PPUSH
87918: LD_VAR 0 8
87922: PPUSH
87923: LD_INT 0
87925: PPUSH
87926: CALL 89920 0 3
// end ;
87930: GO 87884
87932: POP
87933: POP
// if tigers then
87934: LD_VAR 0 2
87938: IFFALSE 88022
// for i = 1 to tigers do
87940: LD_ADDR_VAR 0 11
87944: PUSH
87945: DOUBLE
87946: LD_INT 1
87948: DEC
87949: ST_TO_ADDR
87950: LD_VAR 0 2
87954: PUSH
87955: FOR_TO
87956: IFFALSE 88020
// begin hc_class = class_tiger ;
87958: LD_ADDR_OWVAR 28
87962: PUSH
87963: LD_INT 14
87965: ST_TO_ADDR
// hc_gallery =  ;
87966: LD_ADDR_OWVAR 33
87970: PUSH
87971: LD_STRING 
87973: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
87974: LD_ADDR_OWVAR 35
87978: PUSH
87979: LD_INT 7
87981: NEG
87982: PPUSH
87983: LD_INT 7
87985: PPUSH
87986: CALL_OW 12
87990: ST_TO_ADDR
// animal := CreateHuman ;
87991: LD_ADDR_VAR 0 12
87995: PUSH
87996: CALL_OW 44
88000: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88001: LD_VAR 0 12
88005: PPUSH
88006: LD_VAR 0 8
88010: PPUSH
88011: LD_INT 0
88013: PPUSH
88014: CALL 89920 0 3
// end ;
88018: GO 87955
88020: POP
88021: POP
// if apemans then
88022: LD_VAR 0 3
88026: IFFALSE 88149
// for i = 1 to apemans do
88028: LD_ADDR_VAR 0 11
88032: PUSH
88033: DOUBLE
88034: LD_INT 1
88036: DEC
88037: ST_TO_ADDR
88038: LD_VAR 0 3
88042: PUSH
88043: FOR_TO
88044: IFFALSE 88147
// begin hc_class = class_apeman ;
88046: LD_ADDR_OWVAR 28
88050: PUSH
88051: LD_INT 12
88053: ST_TO_ADDR
// hc_gallery =  ;
88054: LD_ADDR_OWVAR 33
88058: PUSH
88059: LD_STRING 
88061: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
88062: LD_ADDR_OWVAR 35
88066: PUSH
88067: LD_INT 2
88069: NEG
88070: PPUSH
88071: LD_INT 2
88073: PPUSH
88074: CALL_OW 12
88078: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
88079: LD_ADDR_OWVAR 31
88083: PUSH
88084: LD_INT 1
88086: PPUSH
88087: LD_INT 3
88089: PPUSH
88090: CALL_OW 12
88094: PUSH
88095: LD_INT 1
88097: PPUSH
88098: LD_INT 3
88100: PPUSH
88101: CALL_OW 12
88105: PUSH
88106: LD_INT 0
88108: PUSH
88109: LD_INT 0
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: ST_TO_ADDR
// animal := CreateHuman ;
88118: LD_ADDR_VAR 0 12
88122: PUSH
88123: CALL_OW 44
88127: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88128: LD_VAR 0 12
88132: PPUSH
88133: LD_VAR 0 8
88137: PPUSH
88138: LD_INT 0
88140: PPUSH
88141: CALL 89920 0 3
// end ;
88145: GO 88043
88147: POP
88148: POP
// if enchidnas then
88149: LD_VAR 0 4
88153: IFFALSE 88220
// for i = 1 to enchidnas do
88155: LD_ADDR_VAR 0 11
88159: PUSH
88160: DOUBLE
88161: LD_INT 1
88163: DEC
88164: ST_TO_ADDR
88165: LD_VAR 0 4
88169: PUSH
88170: FOR_TO
88171: IFFALSE 88218
// begin hc_class = 13 ;
88173: LD_ADDR_OWVAR 28
88177: PUSH
88178: LD_INT 13
88180: ST_TO_ADDR
// hc_gallery =  ;
88181: LD_ADDR_OWVAR 33
88185: PUSH
88186: LD_STRING 
88188: ST_TO_ADDR
// animal := CreateHuman ;
88189: LD_ADDR_VAR 0 12
88193: PUSH
88194: CALL_OW 44
88198: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88199: LD_VAR 0 12
88203: PPUSH
88204: LD_VAR 0 8
88208: PPUSH
88209: LD_INT 0
88211: PPUSH
88212: CALL 89920 0 3
// end ;
88216: GO 88170
88218: POP
88219: POP
// if fishes then
88220: LD_VAR 0 7
88224: IFFALSE 88291
// for i = 1 to fishes do
88226: LD_ADDR_VAR 0 11
88230: PUSH
88231: DOUBLE
88232: LD_INT 1
88234: DEC
88235: ST_TO_ADDR
88236: LD_VAR 0 7
88240: PUSH
88241: FOR_TO
88242: IFFALSE 88289
// begin hc_class = 20 ;
88244: LD_ADDR_OWVAR 28
88248: PUSH
88249: LD_INT 20
88251: ST_TO_ADDR
// hc_gallery =  ;
88252: LD_ADDR_OWVAR 33
88256: PUSH
88257: LD_STRING 
88259: ST_TO_ADDR
// animal := CreateHuman ;
88260: LD_ADDR_VAR 0 12
88264: PUSH
88265: CALL_OW 44
88269: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
88270: LD_VAR 0 12
88274: PPUSH
88275: LD_VAR 0 9
88279: PPUSH
88280: LD_INT 0
88282: PPUSH
88283: CALL 89920 0 3
// end ;
88287: GO 88241
88289: POP
88290: POP
// end ;
88291: LD_VAR 0 10
88295: RET
// export function WantHeal ( sci , unit ) ; begin
88296: LD_INT 0
88298: PPUSH
// if GetTaskList ( sci ) > 0 then
88299: LD_VAR 0 1
88303: PPUSH
88304: CALL_OW 437
88308: PUSH
88309: LD_INT 0
88311: GREATER
88312: IFFALSE 88382
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
88314: LD_VAR 0 1
88318: PPUSH
88319: CALL_OW 437
88323: PUSH
88324: LD_INT 1
88326: ARRAY
88327: PUSH
88328: LD_INT 1
88330: ARRAY
88331: PUSH
88332: LD_STRING l
88334: EQUAL
88335: PUSH
88336: LD_VAR 0 1
88340: PPUSH
88341: CALL_OW 437
88345: PUSH
88346: LD_INT 1
88348: ARRAY
88349: PUSH
88350: LD_INT 4
88352: ARRAY
88353: PUSH
88354: LD_VAR 0 2
88358: EQUAL
88359: AND
88360: IFFALSE 88372
// result := true else
88362: LD_ADDR_VAR 0 3
88366: PUSH
88367: LD_INT 1
88369: ST_TO_ADDR
88370: GO 88380
// result := false ;
88372: LD_ADDR_VAR 0 3
88376: PUSH
88377: LD_INT 0
88379: ST_TO_ADDR
// end else
88380: GO 88390
// result := false ;
88382: LD_ADDR_VAR 0 3
88386: PUSH
88387: LD_INT 0
88389: ST_TO_ADDR
// end ;
88390: LD_VAR 0 3
88394: RET
// export function HealTarget ( sci ) ; begin
88395: LD_INT 0
88397: PPUSH
// if not sci then
88398: LD_VAR 0 1
88402: NOT
88403: IFFALSE 88407
// exit ;
88405: GO 88472
// result := 0 ;
88407: LD_ADDR_VAR 0 2
88411: PUSH
88412: LD_INT 0
88414: ST_TO_ADDR
// if GetTaskList ( sci ) then
88415: LD_VAR 0 1
88419: PPUSH
88420: CALL_OW 437
88424: IFFALSE 88472
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
88426: LD_VAR 0 1
88430: PPUSH
88431: CALL_OW 437
88435: PUSH
88436: LD_INT 1
88438: ARRAY
88439: PUSH
88440: LD_INT 1
88442: ARRAY
88443: PUSH
88444: LD_STRING l
88446: EQUAL
88447: IFFALSE 88472
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
88449: LD_ADDR_VAR 0 2
88453: PUSH
88454: LD_VAR 0 1
88458: PPUSH
88459: CALL_OW 437
88463: PUSH
88464: LD_INT 1
88466: ARRAY
88467: PUSH
88468: LD_INT 4
88470: ARRAY
88471: ST_TO_ADDR
// end ;
88472: LD_VAR 0 2
88476: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
88477: LD_INT 0
88479: PPUSH
88480: PPUSH
88481: PPUSH
88482: PPUSH
// if not base_units then
88483: LD_VAR 0 1
88487: NOT
88488: IFFALSE 88492
// exit ;
88490: GO 88579
// result := false ;
88492: LD_ADDR_VAR 0 2
88496: PUSH
88497: LD_INT 0
88499: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
88500: LD_ADDR_VAR 0 5
88504: PUSH
88505: LD_VAR 0 1
88509: PPUSH
88510: LD_INT 21
88512: PUSH
88513: LD_INT 3
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PPUSH
88520: CALL_OW 72
88524: ST_TO_ADDR
// if not tmp then
88525: LD_VAR 0 5
88529: NOT
88530: IFFALSE 88534
// exit ;
88532: GO 88579
// for i in tmp do
88534: LD_ADDR_VAR 0 3
88538: PUSH
88539: LD_VAR 0 5
88543: PUSH
88544: FOR_IN
88545: IFFALSE 88577
// begin result := EnemyInRange ( i , 22 ) ;
88547: LD_ADDR_VAR 0 2
88551: PUSH
88552: LD_VAR 0 3
88556: PPUSH
88557: LD_INT 22
88559: PPUSH
88560: CALL 86177 0 2
88564: ST_TO_ADDR
// if result then
88565: LD_VAR 0 2
88569: IFFALSE 88575
// exit ;
88571: POP
88572: POP
88573: GO 88579
// end ;
88575: GO 88544
88577: POP
88578: POP
// end ;
88579: LD_VAR 0 2
88583: RET
// export function FilterByTag ( units , tag ) ; begin
88584: LD_INT 0
88586: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
88587: LD_ADDR_VAR 0 3
88591: PUSH
88592: LD_VAR 0 1
88596: PPUSH
88597: LD_INT 120
88599: PUSH
88600: LD_VAR 0 2
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PPUSH
88609: CALL_OW 72
88613: ST_TO_ADDR
// end ;
88614: LD_VAR 0 3
88618: RET
// export function IsDriver ( un ) ; begin
88619: LD_INT 0
88621: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
88622: LD_ADDR_VAR 0 2
88626: PUSH
88627: LD_VAR 0 1
88631: PUSH
88632: LD_INT 55
88634: PUSH
88635: EMPTY
88636: LIST
88637: PPUSH
88638: CALL_OW 69
88642: IN
88643: ST_TO_ADDR
// end ;
88644: LD_VAR 0 2
88648: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
88649: LD_INT 0
88651: PPUSH
88652: PPUSH
// list := [ ] ;
88653: LD_ADDR_VAR 0 5
88657: PUSH
88658: EMPTY
88659: ST_TO_ADDR
// case d of 0 :
88660: LD_VAR 0 3
88664: PUSH
88665: LD_INT 0
88667: DOUBLE
88668: EQUAL
88669: IFTRUE 88673
88671: GO 88806
88673: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
88674: LD_ADDR_VAR 0 5
88678: PUSH
88679: LD_VAR 0 1
88683: PUSH
88684: LD_INT 4
88686: MINUS
88687: PUSH
88688: LD_VAR 0 2
88692: PUSH
88693: LD_INT 4
88695: MINUS
88696: PUSH
88697: LD_INT 2
88699: PUSH
88700: EMPTY
88701: LIST
88702: LIST
88703: LIST
88704: PUSH
88705: LD_VAR 0 1
88709: PUSH
88710: LD_INT 3
88712: MINUS
88713: PUSH
88714: LD_VAR 0 2
88718: PUSH
88719: LD_INT 1
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: LIST
88726: PUSH
88727: LD_VAR 0 1
88731: PUSH
88732: LD_INT 4
88734: PLUS
88735: PUSH
88736: LD_VAR 0 2
88740: PUSH
88741: LD_INT 4
88743: PUSH
88744: EMPTY
88745: LIST
88746: LIST
88747: LIST
88748: PUSH
88749: LD_VAR 0 1
88753: PUSH
88754: LD_INT 3
88756: PLUS
88757: PUSH
88758: LD_VAR 0 2
88762: PUSH
88763: LD_INT 3
88765: PLUS
88766: PUSH
88767: LD_INT 5
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: LIST
88774: PUSH
88775: LD_VAR 0 1
88779: PUSH
88780: LD_VAR 0 2
88784: PUSH
88785: LD_INT 4
88787: PLUS
88788: PUSH
88789: LD_INT 0
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: LIST
88796: PUSH
88797: EMPTY
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: ST_TO_ADDR
// end ; 1 :
88804: GO 89504
88806: LD_INT 1
88808: DOUBLE
88809: EQUAL
88810: IFTRUE 88814
88812: GO 88947
88814: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
88815: LD_ADDR_VAR 0 5
88819: PUSH
88820: LD_VAR 0 1
88824: PUSH
88825: LD_VAR 0 2
88829: PUSH
88830: LD_INT 4
88832: MINUS
88833: PUSH
88834: LD_INT 3
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: LIST
88841: PUSH
88842: LD_VAR 0 1
88846: PUSH
88847: LD_INT 3
88849: MINUS
88850: PUSH
88851: LD_VAR 0 2
88855: PUSH
88856: LD_INT 3
88858: MINUS
88859: PUSH
88860: LD_INT 2
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: LIST
88867: PUSH
88868: LD_VAR 0 1
88872: PUSH
88873: LD_INT 4
88875: MINUS
88876: PUSH
88877: LD_VAR 0 2
88881: PUSH
88882: LD_INT 1
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: LIST
88889: PUSH
88890: LD_VAR 0 1
88894: PUSH
88895: LD_VAR 0 2
88899: PUSH
88900: LD_INT 3
88902: PLUS
88903: PUSH
88904: LD_INT 0
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: LIST
88911: PUSH
88912: LD_VAR 0 1
88916: PUSH
88917: LD_INT 4
88919: PLUS
88920: PUSH
88921: LD_VAR 0 2
88925: PUSH
88926: LD_INT 4
88928: PLUS
88929: PUSH
88930: LD_INT 5
88932: PUSH
88933: EMPTY
88934: LIST
88935: LIST
88936: LIST
88937: PUSH
88938: EMPTY
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: ST_TO_ADDR
// end ; 2 :
88945: GO 89504
88947: LD_INT 2
88949: DOUBLE
88950: EQUAL
88951: IFTRUE 88955
88953: GO 89084
88955: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88956: LD_ADDR_VAR 0 5
88960: PUSH
88961: LD_VAR 0 1
88965: PUSH
88966: LD_VAR 0 2
88970: PUSH
88971: LD_INT 3
88973: MINUS
88974: PUSH
88975: LD_INT 3
88977: PUSH
88978: EMPTY
88979: LIST
88980: LIST
88981: LIST
88982: PUSH
88983: LD_VAR 0 1
88987: PUSH
88988: LD_INT 4
88990: PLUS
88991: PUSH
88992: LD_VAR 0 2
88996: PUSH
88997: LD_INT 4
88999: PUSH
89000: EMPTY
89001: LIST
89002: LIST
89003: LIST
89004: PUSH
89005: LD_VAR 0 1
89009: PUSH
89010: LD_VAR 0 2
89014: PUSH
89015: LD_INT 4
89017: PLUS
89018: PUSH
89019: LD_INT 0
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: LIST
89026: PUSH
89027: LD_VAR 0 1
89031: PUSH
89032: LD_INT 3
89034: MINUS
89035: PUSH
89036: LD_VAR 0 2
89040: PUSH
89041: LD_INT 1
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: LIST
89048: PUSH
89049: LD_VAR 0 1
89053: PUSH
89054: LD_INT 4
89056: MINUS
89057: PUSH
89058: LD_VAR 0 2
89062: PUSH
89063: LD_INT 4
89065: MINUS
89066: PUSH
89067: LD_INT 2
89069: PUSH
89070: EMPTY
89071: LIST
89072: LIST
89073: LIST
89074: PUSH
89075: EMPTY
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: ST_TO_ADDR
// end ; 3 :
89082: GO 89504
89084: LD_INT 3
89086: DOUBLE
89087: EQUAL
89088: IFTRUE 89092
89090: GO 89225
89092: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
89093: LD_ADDR_VAR 0 5
89097: PUSH
89098: LD_VAR 0 1
89102: PUSH
89103: LD_INT 3
89105: PLUS
89106: PUSH
89107: LD_VAR 0 2
89111: PUSH
89112: LD_INT 4
89114: PUSH
89115: EMPTY
89116: LIST
89117: LIST
89118: LIST
89119: PUSH
89120: LD_VAR 0 1
89124: PUSH
89125: LD_INT 4
89127: PLUS
89128: PUSH
89129: LD_VAR 0 2
89133: PUSH
89134: LD_INT 4
89136: PLUS
89137: PUSH
89138: LD_INT 5
89140: PUSH
89141: EMPTY
89142: LIST
89143: LIST
89144: LIST
89145: PUSH
89146: LD_VAR 0 1
89150: PUSH
89151: LD_INT 4
89153: MINUS
89154: PUSH
89155: LD_VAR 0 2
89159: PUSH
89160: LD_INT 1
89162: PUSH
89163: EMPTY
89164: LIST
89165: LIST
89166: LIST
89167: PUSH
89168: LD_VAR 0 1
89172: PUSH
89173: LD_VAR 0 2
89177: PUSH
89178: LD_INT 4
89180: MINUS
89181: PUSH
89182: LD_INT 3
89184: PUSH
89185: EMPTY
89186: LIST
89187: LIST
89188: LIST
89189: PUSH
89190: LD_VAR 0 1
89194: PUSH
89195: LD_INT 3
89197: MINUS
89198: PUSH
89199: LD_VAR 0 2
89203: PUSH
89204: LD_INT 3
89206: MINUS
89207: PUSH
89208: LD_INT 2
89210: PUSH
89211: EMPTY
89212: LIST
89213: LIST
89214: LIST
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: ST_TO_ADDR
// end ; 4 :
89223: GO 89504
89225: LD_INT 4
89227: DOUBLE
89228: EQUAL
89229: IFTRUE 89233
89231: GO 89366
89233: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
89234: LD_ADDR_VAR 0 5
89238: PUSH
89239: LD_VAR 0 1
89243: PUSH
89244: LD_VAR 0 2
89248: PUSH
89249: LD_INT 4
89251: PLUS
89252: PUSH
89253: LD_INT 0
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: LIST
89260: PUSH
89261: LD_VAR 0 1
89265: PUSH
89266: LD_INT 3
89268: PLUS
89269: PUSH
89270: LD_VAR 0 2
89274: PUSH
89275: LD_INT 3
89277: PLUS
89278: PUSH
89279: LD_INT 5
89281: PUSH
89282: EMPTY
89283: LIST
89284: LIST
89285: LIST
89286: PUSH
89287: LD_VAR 0 1
89291: PUSH
89292: LD_INT 4
89294: PLUS
89295: PUSH
89296: LD_VAR 0 2
89300: PUSH
89301: LD_INT 4
89303: PUSH
89304: EMPTY
89305: LIST
89306: LIST
89307: LIST
89308: PUSH
89309: LD_VAR 0 1
89313: PUSH
89314: LD_VAR 0 2
89318: PUSH
89319: LD_INT 3
89321: MINUS
89322: PUSH
89323: LD_INT 3
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: LIST
89330: PUSH
89331: LD_VAR 0 1
89335: PUSH
89336: LD_INT 4
89338: MINUS
89339: PUSH
89340: LD_VAR 0 2
89344: PUSH
89345: LD_INT 4
89347: MINUS
89348: PUSH
89349: LD_INT 2
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: LIST
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: ST_TO_ADDR
// end ; 5 :
89364: GO 89504
89366: LD_INT 5
89368: DOUBLE
89369: EQUAL
89370: IFTRUE 89374
89372: GO 89503
89374: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
89375: LD_ADDR_VAR 0 5
89379: PUSH
89380: LD_VAR 0 1
89384: PUSH
89385: LD_INT 4
89387: MINUS
89388: PUSH
89389: LD_VAR 0 2
89393: PUSH
89394: LD_INT 1
89396: PUSH
89397: EMPTY
89398: LIST
89399: LIST
89400: LIST
89401: PUSH
89402: LD_VAR 0 1
89406: PUSH
89407: LD_VAR 0 2
89411: PUSH
89412: LD_INT 4
89414: MINUS
89415: PUSH
89416: LD_INT 3
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: LIST
89423: PUSH
89424: LD_VAR 0 1
89428: PUSH
89429: LD_INT 4
89431: PLUS
89432: PUSH
89433: LD_VAR 0 2
89437: PUSH
89438: LD_INT 4
89440: PLUS
89441: PUSH
89442: LD_INT 5
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: LIST
89449: PUSH
89450: LD_VAR 0 1
89454: PUSH
89455: LD_INT 3
89457: PLUS
89458: PUSH
89459: LD_VAR 0 2
89463: PUSH
89464: LD_INT 4
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: LIST
89471: PUSH
89472: LD_VAR 0 1
89476: PUSH
89477: LD_VAR 0 2
89481: PUSH
89482: LD_INT 3
89484: PLUS
89485: PUSH
89486: LD_INT 0
89488: PUSH
89489: EMPTY
89490: LIST
89491: LIST
89492: LIST
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: LIST
89498: LIST
89499: LIST
89500: ST_TO_ADDR
// end ; end ;
89501: GO 89504
89503: POP
// result := list ;
89504: LD_ADDR_VAR 0 4
89508: PUSH
89509: LD_VAR 0 5
89513: ST_TO_ADDR
// end ;
89514: LD_VAR 0 4
89518: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
89519: LD_INT 0
89521: PPUSH
89522: PPUSH
89523: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
89524: LD_VAR 0 1
89528: NOT
89529: PUSH
89530: LD_VAR 0 2
89534: PUSH
89535: LD_INT 1
89537: PUSH
89538: LD_INT 2
89540: PUSH
89541: LD_INT 3
89543: PUSH
89544: LD_INT 4
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: IN
89553: NOT
89554: OR
89555: IFFALSE 89559
// exit ;
89557: GO 89642
// tmp := [ ] ;
89559: LD_ADDR_VAR 0 5
89563: PUSH
89564: EMPTY
89565: ST_TO_ADDR
// for i in units do
89566: LD_ADDR_VAR 0 4
89570: PUSH
89571: LD_VAR 0 1
89575: PUSH
89576: FOR_IN
89577: IFFALSE 89611
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
89579: LD_ADDR_VAR 0 5
89583: PUSH
89584: LD_VAR 0 5
89588: PPUSH
89589: LD_VAR 0 4
89593: PPUSH
89594: LD_VAR 0 2
89598: PPUSH
89599: CALL_OW 259
89603: PPUSH
89604: CALL 91015 0 2
89608: ST_TO_ADDR
89609: GO 89576
89611: POP
89612: POP
// if not tmp then
89613: LD_VAR 0 5
89617: NOT
89618: IFFALSE 89622
// exit ;
89620: GO 89642
// result := SortListByListDesc ( units , tmp ) ;
89622: LD_ADDR_VAR 0 3
89626: PUSH
89627: LD_VAR 0 1
89631: PPUSH
89632: LD_VAR 0 5
89636: PPUSH
89637: CALL_OW 77
89641: ST_TO_ADDR
// end ;
89642: LD_VAR 0 3
89646: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
89647: LD_INT 0
89649: PPUSH
89650: PPUSH
89651: PPUSH
// result := false ;
89652: LD_ADDR_VAR 0 3
89656: PUSH
89657: LD_INT 0
89659: ST_TO_ADDR
// if not building then
89660: LD_VAR 0 2
89664: NOT
89665: IFFALSE 89669
// exit ;
89667: GO 89807
// x := GetX ( building ) ;
89669: LD_ADDR_VAR 0 4
89673: PUSH
89674: LD_VAR 0 2
89678: PPUSH
89679: CALL_OW 250
89683: ST_TO_ADDR
// y := GetY ( building ) ;
89684: LD_ADDR_VAR 0 5
89688: PUSH
89689: LD_VAR 0 2
89693: PPUSH
89694: CALL_OW 251
89698: ST_TO_ADDR
// if not x or not y then
89699: LD_VAR 0 4
89703: NOT
89704: PUSH
89705: LD_VAR 0 5
89709: NOT
89710: OR
89711: IFFALSE 89715
// exit ;
89713: GO 89807
// if GetTaskList ( unit ) then
89715: LD_VAR 0 1
89719: PPUSH
89720: CALL_OW 437
89724: IFFALSE 89807
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89726: LD_STRING e
89728: PUSH
89729: LD_VAR 0 1
89733: PPUSH
89734: CALL_OW 437
89738: PUSH
89739: LD_INT 1
89741: ARRAY
89742: PUSH
89743: LD_INT 1
89745: ARRAY
89746: EQUAL
89747: PUSH
89748: LD_VAR 0 4
89752: PUSH
89753: LD_VAR 0 1
89757: PPUSH
89758: CALL_OW 437
89762: PUSH
89763: LD_INT 1
89765: ARRAY
89766: PUSH
89767: LD_INT 2
89769: ARRAY
89770: EQUAL
89771: AND
89772: PUSH
89773: LD_VAR 0 5
89777: PUSH
89778: LD_VAR 0 1
89782: PPUSH
89783: CALL_OW 437
89787: PUSH
89788: LD_INT 1
89790: ARRAY
89791: PUSH
89792: LD_INT 3
89794: ARRAY
89795: EQUAL
89796: AND
89797: IFFALSE 89807
// result := true end ;
89799: LD_ADDR_VAR 0 3
89803: PUSH
89804: LD_INT 1
89806: ST_TO_ADDR
// end ;
89807: LD_VAR 0 3
89811: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
89812: LD_INT 0
89814: PPUSH
// result := false ;
89815: LD_ADDR_VAR 0 4
89819: PUSH
89820: LD_INT 0
89822: ST_TO_ADDR
// if GetTaskList ( unit ) then
89823: LD_VAR 0 1
89827: PPUSH
89828: CALL_OW 437
89832: IFFALSE 89915
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89834: LD_STRING M
89836: PUSH
89837: LD_VAR 0 1
89841: PPUSH
89842: CALL_OW 437
89846: PUSH
89847: LD_INT 1
89849: ARRAY
89850: PUSH
89851: LD_INT 1
89853: ARRAY
89854: EQUAL
89855: PUSH
89856: LD_VAR 0 2
89860: PUSH
89861: LD_VAR 0 1
89865: PPUSH
89866: CALL_OW 437
89870: PUSH
89871: LD_INT 1
89873: ARRAY
89874: PUSH
89875: LD_INT 2
89877: ARRAY
89878: EQUAL
89879: AND
89880: PUSH
89881: LD_VAR 0 3
89885: PUSH
89886: LD_VAR 0 1
89890: PPUSH
89891: CALL_OW 437
89895: PUSH
89896: LD_INT 1
89898: ARRAY
89899: PUSH
89900: LD_INT 3
89902: ARRAY
89903: EQUAL
89904: AND
89905: IFFALSE 89915
// result := true ;
89907: LD_ADDR_VAR 0 4
89911: PUSH
89912: LD_INT 1
89914: ST_TO_ADDR
// end ; end ;
89915: LD_VAR 0 4
89919: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89920: LD_INT 0
89922: PPUSH
89923: PPUSH
89924: PPUSH
89925: PPUSH
// if not unit or not area then
89926: LD_VAR 0 1
89930: NOT
89931: PUSH
89932: LD_VAR 0 2
89936: NOT
89937: OR
89938: IFFALSE 89942
// exit ;
89940: GO 90118
// tmp := AreaToList ( area , i ) ;
89942: LD_ADDR_VAR 0 6
89946: PUSH
89947: LD_VAR 0 2
89951: PPUSH
89952: LD_VAR 0 5
89956: PPUSH
89957: CALL_OW 517
89961: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89962: LD_ADDR_VAR 0 5
89966: PUSH
89967: DOUBLE
89968: LD_INT 1
89970: DEC
89971: ST_TO_ADDR
89972: LD_VAR 0 6
89976: PUSH
89977: LD_INT 1
89979: ARRAY
89980: PUSH
89981: FOR_TO
89982: IFFALSE 90116
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89984: LD_ADDR_VAR 0 7
89988: PUSH
89989: LD_VAR 0 6
89993: PUSH
89994: LD_INT 1
89996: ARRAY
89997: PUSH
89998: LD_VAR 0 5
90002: ARRAY
90003: PUSH
90004: LD_VAR 0 6
90008: PUSH
90009: LD_INT 2
90011: ARRAY
90012: PUSH
90013: LD_VAR 0 5
90017: ARRAY
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
90023: LD_INT 92
90025: PUSH
90026: LD_VAR 0 7
90030: PUSH
90031: LD_INT 1
90033: ARRAY
90034: PUSH
90035: LD_VAR 0 7
90039: PUSH
90040: LD_INT 2
90042: ARRAY
90043: PUSH
90044: LD_INT 2
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: PPUSH
90053: CALL_OW 69
90057: PUSH
90058: LD_INT 0
90060: EQUAL
90061: IFFALSE 90114
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
90063: LD_VAR 0 1
90067: PPUSH
90068: LD_VAR 0 7
90072: PUSH
90073: LD_INT 1
90075: ARRAY
90076: PPUSH
90077: LD_VAR 0 7
90081: PUSH
90082: LD_INT 2
90084: ARRAY
90085: PPUSH
90086: LD_VAR 0 3
90090: PPUSH
90091: CALL_OW 48
// result := IsPlaced ( unit ) ;
90095: LD_ADDR_VAR 0 4
90099: PUSH
90100: LD_VAR 0 1
90104: PPUSH
90105: CALL_OW 305
90109: ST_TO_ADDR
// exit ;
90110: POP
90111: POP
90112: GO 90118
// end ; end ;
90114: GO 89981
90116: POP
90117: POP
// end ;
90118: LD_VAR 0 4
90122: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
90123: LD_INT 0
90125: PPUSH
90126: PPUSH
90127: PPUSH
// if not side or side > 8 then
90128: LD_VAR 0 1
90132: NOT
90133: PUSH
90134: LD_VAR 0 1
90138: PUSH
90139: LD_INT 8
90141: GREATER
90142: OR
90143: IFFALSE 90147
// exit ;
90145: GO 90334
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
90147: LD_ADDR_VAR 0 4
90151: PUSH
90152: LD_INT 22
90154: PUSH
90155: LD_VAR 0 1
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 21
90166: PUSH
90167: LD_INT 3
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PPUSH
90178: CALL_OW 69
90182: ST_TO_ADDR
// if not tmp then
90183: LD_VAR 0 4
90187: NOT
90188: IFFALSE 90192
// exit ;
90190: GO 90334
// enable_addtolog := true ;
90192: LD_ADDR_OWVAR 81
90196: PUSH
90197: LD_INT 1
90199: ST_TO_ADDR
// AddToLog ( [ ) ;
90200: LD_STRING [
90202: PPUSH
90203: CALL_OW 561
// for i in tmp do
90207: LD_ADDR_VAR 0 3
90211: PUSH
90212: LD_VAR 0 4
90216: PUSH
90217: FOR_IN
90218: IFFALSE 90325
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
90220: LD_STRING [
90222: PUSH
90223: LD_VAR 0 3
90227: PPUSH
90228: CALL_OW 266
90232: STR
90233: PUSH
90234: LD_STRING , 
90236: STR
90237: PUSH
90238: LD_VAR 0 3
90242: PPUSH
90243: CALL_OW 250
90247: STR
90248: PUSH
90249: LD_STRING , 
90251: STR
90252: PUSH
90253: LD_VAR 0 3
90257: PPUSH
90258: CALL_OW 251
90262: STR
90263: PUSH
90264: LD_STRING , 
90266: STR
90267: PUSH
90268: LD_VAR 0 3
90272: PPUSH
90273: CALL_OW 254
90277: STR
90278: PUSH
90279: LD_STRING , 
90281: STR
90282: PUSH
90283: LD_VAR 0 3
90287: PPUSH
90288: LD_INT 1
90290: PPUSH
90291: CALL_OW 268
90295: STR
90296: PUSH
90297: LD_STRING , 
90299: STR
90300: PUSH
90301: LD_VAR 0 3
90305: PPUSH
90306: LD_INT 2
90308: PPUSH
90309: CALL_OW 268
90313: STR
90314: PUSH
90315: LD_STRING ],
90317: STR
90318: PPUSH
90319: CALL_OW 561
// end ;
90323: GO 90217
90325: POP
90326: POP
// AddToLog ( ]; ) ;
90327: LD_STRING ];
90329: PPUSH
90330: CALL_OW 561
// end ;
90334: LD_VAR 0 2
90338: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
90339: LD_INT 0
90341: PPUSH
90342: PPUSH
90343: PPUSH
90344: PPUSH
90345: PPUSH
// if not area or not rate or not max then
90346: LD_VAR 0 1
90350: NOT
90351: PUSH
90352: LD_VAR 0 2
90356: NOT
90357: OR
90358: PUSH
90359: LD_VAR 0 4
90363: NOT
90364: OR
90365: IFFALSE 90369
// exit ;
90367: GO 90558
// while 1 do
90369: LD_INT 1
90371: IFFALSE 90558
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
90373: LD_ADDR_VAR 0 9
90377: PUSH
90378: LD_VAR 0 1
90382: PPUSH
90383: LD_INT 1
90385: PPUSH
90386: CALL_OW 287
90390: PUSH
90391: LD_INT 10
90393: MUL
90394: ST_TO_ADDR
// r := rate / 10 ;
90395: LD_ADDR_VAR 0 7
90399: PUSH
90400: LD_VAR 0 2
90404: PUSH
90405: LD_INT 10
90407: DIVREAL
90408: ST_TO_ADDR
// time := 1 1$00 ;
90409: LD_ADDR_VAR 0 8
90413: PUSH
90414: LD_INT 2100
90416: ST_TO_ADDR
// if amount < min then
90417: LD_VAR 0 9
90421: PUSH
90422: LD_VAR 0 3
90426: LESS
90427: IFFALSE 90445
// r := r * 2 else
90429: LD_ADDR_VAR 0 7
90433: PUSH
90434: LD_VAR 0 7
90438: PUSH
90439: LD_INT 2
90441: MUL
90442: ST_TO_ADDR
90443: GO 90471
// if amount > max then
90445: LD_VAR 0 9
90449: PUSH
90450: LD_VAR 0 4
90454: GREATER
90455: IFFALSE 90471
// r := r / 2 ;
90457: LD_ADDR_VAR 0 7
90461: PUSH
90462: LD_VAR 0 7
90466: PUSH
90467: LD_INT 2
90469: DIVREAL
90470: ST_TO_ADDR
// time := time / r ;
90471: LD_ADDR_VAR 0 8
90475: PUSH
90476: LD_VAR 0 8
90480: PUSH
90481: LD_VAR 0 7
90485: DIVREAL
90486: ST_TO_ADDR
// if time < 0 then
90487: LD_VAR 0 8
90491: PUSH
90492: LD_INT 0
90494: LESS
90495: IFFALSE 90512
// time := time * - 1 ;
90497: LD_ADDR_VAR 0 8
90501: PUSH
90502: LD_VAR 0 8
90506: PUSH
90507: LD_INT 1
90509: NEG
90510: MUL
90511: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
90512: LD_VAR 0 8
90516: PUSH
90517: LD_INT 35
90519: PPUSH
90520: LD_INT 875
90522: PPUSH
90523: CALL_OW 12
90527: PLUS
90528: PPUSH
90529: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
90533: LD_INT 1
90535: PPUSH
90536: LD_INT 5
90538: PPUSH
90539: CALL_OW 12
90543: PPUSH
90544: LD_VAR 0 1
90548: PPUSH
90549: LD_INT 1
90551: PPUSH
90552: CALL_OW 55
// end ;
90556: GO 90369
// end ;
90558: LD_VAR 0 5
90562: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
90563: LD_INT 0
90565: PPUSH
90566: PPUSH
90567: PPUSH
90568: PPUSH
90569: PPUSH
90570: PPUSH
90571: PPUSH
90572: PPUSH
// if not turrets or not factories then
90573: LD_VAR 0 1
90577: NOT
90578: PUSH
90579: LD_VAR 0 2
90583: NOT
90584: OR
90585: IFFALSE 90589
// exit ;
90587: GO 90896
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
90589: LD_ADDR_VAR 0 10
90593: PUSH
90594: LD_INT 5
90596: PUSH
90597: LD_INT 6
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: LD_INT 2
90606: PUSH
90607: LD_INT 4
90609: PUSH
90610: EMPTY
90611: LIST
90612: LIST
90613: PUSH
90614: LD_INT 3
90616: PUSH
90617: LD_INT 5
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 24
90631: PUSH
90632: LD_INT 25
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: LD_INT 23
90641: PUSH
90642: LD_INT 27
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PUSH
90649: EMPTY
90650: LIST
90651: LIST
90652: PUSH
90653: LD_INT 42
90655: PUSH
90656: LD_INT 43
90658: PUSH
90659: EMPTY
90660: LIST
90661: LIST
90662: PUSH
90663: LD_INT 44
90665: PUSH
90666: LD_INT 46
90668: PUSH
90669: EMPTY
90670: LIST
90671: LIST
90672: PUSH
90673: LD_INT 45
90675: PUSH
90676: LD_INT 47
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: EMPTY
90684: LIST
90685: LIST
90686: LIST
90687: PUSH
90688: EMPTY
90689: LIST
90690: LIST
90691: LIST
90692: ST_TO_ADDR
// result := [ ] ;
90693: LD_ADDR_VAR 0 3
90697: PUSH
90698: EMPTY
90699: ST_TO_ADDR
// for i in turrets do
90700: LD_ADDR_VAR 0 4
90704: PUSH
90705: LD_VAR 0 1
90709: PUSH
90710: FOR_IN
90711: IFFALSE 90894
// begin nat := GetNation ( i ) ;
90713: LD_ADDR_VAR 0 7
90717: PUSH
90718: LD_VAR 0 4
90722: PPUSH
90723: CALL_OW 248
90727: ST_TO_ADDR
// weapon := 0 ;
90728: LD_ADDR_VAR 0 8
90732: PUSH
90733: LD_INT 0
90735: ST_TO_ADDR
// if not nat then
90736: LD_VAR 0 7
90740: NOT
90741: IFFALSE 90745
// continue ;
90743: GO 90710
// for j in list [ nat ] do
90745: LD_ADDR_VAR 0 5
90749: PUSH
90750: LD_VAR 0 10
90754: PUSH
90755: LD_VAR 0 7
90759: ARRAY
90760: PUSH
90761: FOR_IN
90762: IFFALSE 90803
// if GetBWeapon ( i ) = j [ 1 ] then
90764: LD_VAR 0 4
90768: PPUSH
90769: CALL_OW 269
90773: PUSH
90774: LD_VAR 0 5
90778: PUSH
90779: LD_INT 1
90781: ARRAY
90782: EQUAL
90783: IFFALSE 90801
// begin weapon := j [ 2 ] ;
90785: LD_ADDR_VAR 0 8
90789: PUSH
90790: LD_VAR 0 5
90794: PUSH
90795: LD_INT 2
90797: ARRAY
90798: ST_TO_ADDR
// break ;
90799: GO 90803
// end ;
90801: GO 90761
90803: POP
90804: POP
// if not weapon then
90805: LD_VAR 0 8
90809: NOT
90810: IFFALSE 90814
// continue ;
90812: GO 90710
// for k in factories do
90814: LD_ADDR_VAR 0 6
90818: PUSH
90819: LD_VAR 0 2
90823: PUSH
90824: FOR_IN
90825: IFFALSE 90890
// begin weapons := AvailableWeaponList ( k ) ;
90827: LD_ADDR_VAR 0 9
90831: PUSH
90832: LD_VAR 0 6
90836: PPUSH
90837: CALL_OW 478
90841: ST_TO_ADDR
// if not weapons then
90842: LD_VAR 0 9
90846: NOT
90847: IFFALSE 90851
// continue ;
90849: GO 90824
// if weapon in weapons then
90851: LD_VAR 0 8
90855: PUSH
90856: LD_VAR 0 9
90860: IN
90861: IFFALSE 90888
// begin result := [ i , weapon ] ;
90863: LD_ADDR_VAR 0 3
90867: PUSH
90868: LD_VAR 0 4
90872: PUSH
90873: LD_VAR 0 8
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: ST_TO_ADDR
// exit ;
90882: POP
90883: POP
90884: POP
90885: POP
90886: GO 90896
// end ; end ;
90888: GO 90824
90890: POP
90891: POP
// end ;
90892: GO 90710
90894: POP
90895: POP
// end ;
90896: LD_VAR 0 3
90900: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
90901: LD_INT 0
90903: PPUSH
// if not side or side > 8 then
90904: LD_VAR 0 3
90908: NOT
90909: PUSH
90910: LD_VAR 0 3
90914: PUSH
90915: LD_INT 8
90917: GREATER
90918: OR
90919: IFFALSE 90923
// exit ;
90921: GO 90982
// if not range then
90923: LD_VAR 0 4
90927: NOT
90928: IFFALSE 90939
// range := - 12 ;
90930: LD_ADDR_VAR 0 4
90934: PUSH
90935: LD_INT 12
90937: NEG
90938: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90939: LD_VAR 0 1
90943: PPUSH
90944: LD_VAR 0 2
90948: PPUSH
90949: LD_VAR 0 3
90953: PPUSH
90954: LD_VAR 0 4
90958: PPUSH
90959: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90963: LD_VAR 0 1
90967: PPUSH
90968: LD_VAR 0 2
90972: PPUSH
90973: LD_VAR 0 3
90977: PPUSH
90978: CALL_OW 331
// end ;
90982: LD_VAR 0 5
90986: RET
// export function Video ( mode ) ; begin
90987: LD_INT 0
90989: PPUSH
// ingame_video = mode ;
90990: LD_ADDR_OWVAR 52
90994: PUSH
90995: LD_VAR 0 1
90999: ST_TO_ADDR
// interface_hidden = mode ;
91000: LD_ADDR_OWVAR 54
91004: PUSH
91005: LD_VAR 0 1
91009: ST_TO_ADDR
// end ;
91010: LD_VAR 0 2
91014: RET
// export function Join ( array , element ) ; begin
91015: LD_INT 0
91017: PPUSH
// result := Replace ( array , array + 1 , element ) ;
91018: LD_ADDR_VAR 0 3
91022: PUSH
91023: LD_VAR 0 1
91027: PPUSH
91028: LD_VAR 0 1
91032: PUSH
91033: LD_INT 1
91035: PLUS
91036: PPUSH
91037: LD_VAR 0 2
91041: PPUSH
91042: CALL_OW 1
91046: ST_TO_ADDR
// end ;
91047: LD_VAR 0 3
91051: RET
// export function JoinUnion ( array , element ) ; begin
91052: LD_INT 0
91054: PPUSH
// result := array union element ;
91055: LD_ADDR_VAR 0 3
91059: PUSH
91060: LD_VAR 0 1
91064: PUSH
91065: LD_VAR 0 2
91069: UNION
91070: ST_TO_ADDR
// end ;
91071: LD_VAR 0 3
91075: RET
// export function GetBehemoths ( side ) ; begin
91076: LD_INT 0
91078: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
91079: LD_ADDR_VAR 0 2
91083: PUSH
91084: LD_INT 22
91086: PUSH
91087: LD_VAR 0 1
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 31
91098: PUSH
91099: LD_INT 25
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: EMPTY
91107: LIST
91108: LIST
91109: PPUSH
91110: CALL_OW 69
91114: ST_TO_ADDR
// end ;
91115: LD_VAR 0 2
91119: RET
// export function Shuffle ( array ) ; var i , index ; begin
91120: LD_INT 0
91122: PPUSH
91123: PPUSH
91124: PPUSH
// result := [ ] ;
91125: LD_ADDR_VAR 0 2
91129: PUSH
91130: EMPTY
91131: ST_TO_ADDR
// if not array then
91132: LD_VAR 0 1
91136: NOT
91137: IFFALSE 91141
// exit ;
91139: GO 91240
// Randomize ;
91141: CALL_OW 10
// for i = array downto 1 do
91145: LD_ADDR_VAR 0 3
91149: PUSH
91150: DOUBLE
91151: LD_VAR 0 1
91155: INC
91156: ST_TO_ADDR
91157: LD_INT 1
91159: PUSH
91160: FOR_DOWNTO
91161: IFFALSE 91238
// begin index := rand ( 1 , array ) ;
91163: LD_ADDR_VAR 0 4
91167: PUSH
91168: LD_INT 1
91170: PPUSH
91171: LD_VAR 0 1
91175: PPUSH
91176: CALL_OW 12
91180: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
91181: LD_ADDR_VAR 0 2
91185: PUSH
91186: LD_VAR 0 2
91190: PPUSH
91191: LD_VAR 0 2
91195: PUSH
91196: LD_INT 1
91198: PLUS
91199: PPUSH
91200: LD_VAR 0 1
91204: PUSH
91205: LD_VAR 0 4
91209: ARRAY
91210: PPUSH
91211: CALL_OW 2
91215: ST_TO_ADDR
// array := Delete ( array , index ) ;
91216: LD_ADDR_VAR 0 1
91220: PUSH
91221: LD_VAR 0 1
91225: PPUSH
91226: LD_VAR 0 4
91230: PPUSH
91231: CALL_OW 3
91235: ST_TO_ADDR
// end ;
91236: GO 91160
91238: POP
91239: POP
// end ;
91240: LD_VAR 0 2
91244: RET
// export function GetBaseMaterials ( base ) ; begin
91245: LD_INT 0
91247: PPUSH
// result := [ 0 , 0 , 0 ] ;
91248: LD_ADDR_VAR 0 2
91252: PUSH
91253: LD_INT 0
91255: PUSH
91256: LD_INT 0
91258: PUSH
91259: LD_INT 0
91261: PUSH
91262: EMPTY
91263: LIST
91264: LIST
91265: LIST
91266: ST_TO_ADDR
// if not base then
91267: LD_VAR 0 1
91271: NOT
91272: IFFALSE 91276
// exit ;
91274: GO 91325
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
91276: LD_ADDR_VAR 0 2
91280: PUSH
91281: LD_VAR 0 1
91285: PPUSH
91286: LD_INT 1
91288: PPUSH
91289: CALL_OW 275
91293: PUSH
91294: LD_VAR 0 1
91298: PPUSH
91299: LD_INT 2
91301: PPUSH
91302: CALL_OW 275
91306: PUSH
91307: LD_VAR 0 1
91311: PPUSH
91312: LD_INT 3
91314: PPUSH
91315: CALL_OW 275
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: LIST
91324: ST_TO_ADDR
// end ;
91325: LD_VAR 0 2
91329: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
91330: LD_INT 0
91332: PPUSH
91333: PPUSH
// result := array ;
91334: LD_ADDR_VAR 0 3
91338: PUSH
91339: LD_VAR 0 1
91343: ST_TO_ADDR
// if size >= result then
91344: LD_VAR 0 2
91348: PUSH
91349: LD_VAR 0 3
91353: GREATEREQUAL
91354: IFFALSE 91358
// exit ;
91356: GO 91408
// if size then
91358: LD_VAR 0 2
91362: IFFALSE 91408
// for i := array downto size do
91364: LD_ADDR_VAR 0 4
91368: PUSH
91369: DOUBLE
91370: LD_VAR 0 1
91374: INC
91375: ST_TO_ADDR
91376: LD_VAR 0 2
91380: PUSH
91381: FOR_DOWNTO
91382: IFFALSE 91406
// result := Delete ( result , result ) ;
91384: LD_ADDR_VAR 0 3
91388: PUSH
91389: LD_VAR 0 3
91393: PPUSH
91394: LD_VAR 0 3
91398: PPUSH
91399: CALL_OW 3
91403: ST_TO_ADDR
91404: GO 91381
91406: POP
91407: POP
// end ;
91408: LD_VAR 0 3
91412: RET
// export function ComExit ( unit ) ; var tmp ; begin
91413: LD_INT 0
91415: PPUSH
91416: PPUSH
// if not IsInUnit ( unit ) then
91417: LD_VAR 0 1
91421: PPUSH
91422: CALL_OW 310
91426: NOT
91427: IFFALSE 91431
// exit ;
91429: GO 91491
// tmp := IsInUnit ( unit ) ;
91431: LD_ADDR_VAR 0 3
91435: PUSH
91436: LD_VAR 0 1
91440: PPUSH
91441: CALL_OW 310
91445: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
91446: LD_VAR 0 3
91450: PPUSH
91451: CALL_OW 247
91455: PUSH
91456: LD_INT 2
91458: EQUAL
91459: IFFALSE 91472
// ComExitVehicle ( unit ) else
91461: LD_VAR 0 1
91465: PPUSH
91466: CALL_OW 121
91470: GO 91481
// ComExitBuilding ( unit ) ;
91472: LD_VAR 0 1
91476: PPUSH
91477: CALL_OW 122
// result := tmp ;
91481: LD_ADDR_VAR 0 2
91485: PUSH
91486: LD_VAR 0 3
91490: ST_TO_ADDR
// end ;
91491: LD_VAR 0 2
91495: RET
// export function ComExitAll ( units ) ; var i ; begin
91496: LD_INT 0
91498: PPUSH
91499: PPUSH
// if not units then
91500: LD_VAR 0 1
91504: NOT
91505: IFFALSE 91509
// exit ;
91507: GO 91535
// for i in units do
91509: LD_ADDR_VAR 0 3
91513: PUSH
91514: LD_VAR 0 1
91518: PUSH
91519: FOR_IN
91520: IFFALSE 91533
// ComExit ( i ) ;
91522: LD_VAR 0 3
91526: PPUSH
91527: CALL 91413 0 1
91531: GO 91519
91533: POP
91534: POP
// end ;
91535: LD_VAR 0 2
91539: RET
// export function ResetHc ; begin
91540: LD_INT 0
91542: PPUSH
// InitHc ;
91543: CALL_OW 19
// hc_importance := 0 ;
91547: LD_ADDR_OWVAR 32
91551: PUSH
91552: LD_INT 0
91554: ST_TO_ADDR
// end ;
91555: LD_VAR 0 1
91559: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
91560: LD_INT 0
91562: PPUSH
91563: PPUSH
91564: PPUSH
// _x := ( x1 + x2 ) div 2 ;
91565: LD_ADDR_VAR 0 6
91569: PUSH
91570: LD_VAR 0 1
91574: PUSH
91575: LD_VAR 0 3
91579: PLUS
91580: PUSH
91581: LD_INT 2
91583: DIV
91584: ST_TO_ADDR
// if _x < 0 then
91585: LD_VAR 0 6
91589: PUSH
91590: LD_INT 0
91592: LESS
91593: IFFALSE 91610
// _x := _x * - 1 ;
91595: LD_ADDR_VAR 0 6
91599: PUSH
91600: LD_VAR 0 6
91604: PUSH
91605: LD_INT 1
91607: NEG
91608: MUL
91609: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
91610: LD_ADDR_VAR 0 7
91614: PUSH
91615: LD_VAR 0 2
91619: PUSH
91620: LD_VAR 0 4
91624: PLUS
91625: PUSH
91626: LD_INT 2
91628: DIV
91629: ST_TO_ADDR
// if _y < 0 then
91630: LD_VAR 0 7
91634: PUSH
91635: LD_INT 0
91637: LESS
91638: IFFALSE 91655
// _y := _y * - 1 ;
91640: LD_ADDR_VAR 0 7
91644: PUSH
91645: LD_VAR 0 7
91649: PUSH
91650: LD_INT 1
91652: NEG
91653: MUL
91654: ST_TO_ADDR
// result := [ _x , _y ] ;
91655: LD_ADDR_VAR 0 5
91659: PUSH
91660: LD_VAR 0 6
91664: PUSH
91665: LD_VAR 0 7
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: ST_TO_ADDR
// end ;
91674: LD_VAR 0 5
91678: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
91679: LD_INT 0
91681: PPUSH
91682: PPUSH
91683: PPUSH
91684: PPUSH
// task := GetTaskList ( unit ) ;
91685: LD_ADDR_VAR 0 7
91689: PUSH
91690: LD_VAR 0 1
91694: PPUSH
91695: CALL_OW 437
91699: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
91700: LD_VAR 0 7
91704: NOT
91705: PUSH
91706: LD_VAR 0 1
91710: PPUSH
91711: LD_VAR 0 2
91715: PPUSH
91716: CALL_OW 308
91720: NOT
91721: AND
91722: IFFALSE 91726
// exit ;
91724: GO 91844
// if IsInArea ( unit , area ) then
91726: LD_VAR 0 1
91730: PPUSH
91731: LD_VAR 0 2
91735: PPUSH
91736: CALL_OW 308
91740: IFFALSE 91758
// begin ComMoveToArea ( unit , goAway ) ;
91742: LD_VAR 0 1
91746: PPUSH
91747: LD_VAR 0 3
91751: PPUSH
91752: CALL_OW 113
// exit ;
91756: GO 91844
// end ; if task [ 1 ] [ 1 ] <> M then
91758: LD_VAR 0 7
91762: PUSH
91763: LD_INT 1
91765: ARRAY
91766: PUSH
91767: LD_INT 1
91769: ARRAY
91770: PUSH
91771: LD_STRING M
91773: NONEQUAL
91774: IFFALSE 91778
// exit ;
91776: GO 91844
// x := task [ 1 ] [ 2 ] ;
91778: LD_ADDR_VAR 0 5
91782: PUSH
91783: LD_VAR 0 7
91787: PUSH
91788: LD_INT 1
91790: ARRAY
91791: PUSH
91792: LD_INT 2
91794: ARRAY
91795: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
91796: LD_ADDR_VAR 0 6
91800: PUSH
91801: LD_VAR 0 7
91805: PUSH
91806: LD_INT 1
91808: ARRAY
91809: PUSH
91810: LD_INT 3
91812: ARRAY
91813: ST_TO_ADDR
// if InArea ( x , y , area ) then
91814: LD_VAR 0 5
91818: PPUSH
91819: LD_VAR 0 6
91823: PPUSH
91824: LD_VAR 0 2
91828: PPUSH
91829: CALL_OW 309
91833: IFFALSE 91844
// ComStop ( unit ) ;
91835: LD_VAR 0 1
91839: PPUSH
91840: CALL_OW 141
// end ;
91844: LD_VAR 0 4
91848: RET
// export function Abs ( value ) ; begin
91849: LD_INT 0
91851: PPUSH
// result := value ;
91852: LD_ADDR_VAR 0 2
91856: PUSH
91857: LD_VAR 0 1
91861: ST_TO_ADDR
// if value < 0 then
91862: LD_VAR 0 1
91866: PUSH
91867: LD_INT 0
91869: LESS
91870: IFFALSE 91887
// result := value * - 1 ;
91872: LD_ADDR_VAR 0 2
91876: PUSH
91877: LD_VAR 0 1
91881: PUSH
91882: LD_INT 1
91884: NEG
91885: MUL
91886: ST_TO_ADDR
// end ;
91887: LD_VAR 0 2
91891: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
91892: LD_INT 0
91894: PPUSH
91895: PPUSH
91896: PPUSH
91897: PPUSH
91898: PPUSH
91899: PPUSH
91900: PPUSH
91901: PPUSH
// if not unit or not building then
91902: LD_VAR 0 1
91906: NOT
91907: PUSH
91908: LD_VAR 0 2
91912: NOT
91913: OR
91914: IFFALSE 91918
// exit ;
91916: GO 92144
// x := GetX ( building ) ;
91918: LD_ADDR_VAR 0 4
91922: PUSH
91923: LD_VAR 0 2
91927: PPUSH
91928: CALL_OW 250
91932: ST_TO_ADDR
// y := GetY ( building ) ;
91933: LD_ADDR_VAR 0 6
91937: PUSH
91938: LD_VAR 0 2
91942: PPUSH
91943: CALL_OW 251
91947: ST_TO_ADDR
// d := GetDir ( building ) ;
91948: LD_ADDR_VAR 0 8
91952: PUSH
91953: LD_VAR 0 2
91957: PPUSH
91958: CALL_OW 254
91962: ST_TO_ADDR
// r := 4 ;
91963: LD_ADDR_VAR 0 9
91967: PUSH
91968: LD_INT 4
91970: ST_TO_ADDR
// for i := 1 to 5 do
91971: LD_ADDR_VAR 0 10
91975: PUSH
91976: DOUBLE
91977: LD_INT 1
91979: DEC
91980: ST_TO_ADDR
91981: LD_INT 5
91983: PUSH
91984: FOR_TO
91985: IFFALSE 92142
// begin _x := ShiftX ( x , d , r + i ) ;
91987: LD_ADDR_VAR 0 5
91991: PUSH
91992: LD_VAR 0 4
91996: PPUSH
91997: LD_VAR 0 8
92001: PPUSH
92002: LD_VAR 0 9
92006: PUSH
92007: LD_VAR 0 10
92011: PLUS
92012: PPUSH
92013: CALL_OW 272
92017: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
92018: LD_ADDR_VAR 0 7
92022: PUSH
92023: LD_VAR 0 6
92027: PPUSH
92028: LD_VAR 0 8
92032: PPUSH
92033: LD_VAR 0 9
92037: PUSH
92038: LD_VAR 0 10
92042: PLUS
92043: PPUSH
92044: CALL_OW 273
92048: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
92049: LD_VAR 0 5
92053: PPUSH
92054: LD_VAR 0 7
92058: PPUSH
92059: CALL_OW 488
92063: PUSH
92064: LD_VAR 0 5
92068: PPUSH
92069: LD_VAR 0 7
92073: PPUSH
92074: CALL_OW 428
92078: PPUSH
92079: CALL_OW 247
92083: PUSH
92084: LD_INT 3
92086: PUSH
92087: LD_INT 2
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: IN
92094: NOT
92095: AND
92096: IFFALSE 92140
// begin ComMoveXY ( unit , _x , _y ) ;
92098: LD_VAR 0 1
92102: PPUSH
92103: LD_VAR 0 5
92107: PPUSH
92108: LD_VAR 0 7
92112: PPUSH
92113: CALL_OW 111
// result := [ _x , _y ] ;
92117: LD_ADDR_VAR 0 3
92121: PUSH
92122: LD_VAR 0 5
92126: PUSH
92127: LD_VAR 0 7
92131: PUSH
92132: EMPTY
92133: LIST
92134: LIST
92135: ST_TO_ADDR
// exit ;
92136: POP
92137: POP
92138: GO 92144
// end ; end ;
92140: GO 91984
92142: POP
92143: POP
// end ;
92144: LD_VAR 0 3
92148: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
92149: LD_INT 0
92151: PPUSH
92152: PPUSH
92153: PPUSH
// result := 0 ;
92154: LD_ADDR_VAR 0 3
92158: PUSH
92159: LD_INT 0
92161: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
92162: LD_VAR 0 1
92166: PUSH
92167: LD_INT 0
92169: LESS
92170: PUSH
92171: LD_VAR 0 1
92175: PUSH
92176: LD_INT 8
92178: GREATER
92179: OR
92180: PUSH
92181: LD_VAR 0 2
92185: PUSH
92186: LD_INT 0
92188: LESS
92189: OR
92190: PUSH
92191: LD_VAR 0 2
92195: PUSH
92196: LD_INT 8
92198: GREATER
92199: OR
92200: IFFALSE 92204
// exit ;
92202: GO 92279
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
92204: LD_ADDR_VAR 0 4
92208: PUSH
92209: LD_INT 22
92211: PUSH
92212: LD_VAR 0 2
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: PPUSH
92221: CALL_OW 69
92225: PUSH
92226: FOR_IN
92227: IFFALSE 92277
// begin un := UnitShoot ( i ) ;
92229: LD_ADDR_VAR 0 5
92233: PUSH
92234: LD_VAR 0 4
92238: PPUSH
92239: CALL_OW 504
92243: ST_TO_ADDR
// if GetSide ( un ) = side1 then
92244: LD_VAR 0 5
92248: PPUSH
92249: CALL_OW 255
92253: PUSH
92254: LD_VAR 0 1
92258: EQUAL
92259: IFFALSE 92275
// begin result := un ;
92261: LD_ADDR_VAR 0 3
92265: PUSH
92266: LD_VAR 0 5
92270: ST_TO_ADDR
// exit ;
92271: POP
92272: POP
92273: GO 92279
// end ; end ;
92275: GO 92226
92277: POP
92278: POP
// end ;
92279: LD_VAR 0 3
92283: RET
// export function GetCargoBay ( units ) ; begin
92284: LD_INT 0
92286: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
92287: LD_ADDR_VAR 0 2
92291: PUSH
92292: LD_VAR 0 1
92296: PPUSH
92297: LD_INT 2
92299: PUSH
92300: LD_INT 34
92302: PUSH
92303: LD_INT 12
92305: PUSH
92306: EMPTY
92307: LIST
92308: LIST
92309: PUSH
92310: LD_INT 34
92312: PUSH
92313: LD_INT 51
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: PUSH
92320: LD_INT 34
92322: PUSH
92323: LD_INT 32
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: PUSH
92330: LD_INT 34
92332: PUSH
92333: LD_INT 89
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: LIST
92344: LIST
92345: LIST
92346: PPUSH
92347: CALL_OW 72
92351: ST_TO_ADDR
// end ;
92352: LD_VAR 0 2
92356: RET
// export function Negate ( value ) ; begin
92357: LD_INT 0
92359: PPUSH
// result := not value ;
92360: LD_ADDR_VAR 0 2
92364: PUSH
92365: LD_VAR 0 1
92369: NOT
92370: ST_TO_ADDR
// end ;
92371: LD_VAR 0 2
92375: RET
// export function Inc ( value ) ; begin
92376: LD_INT 0
92378: PPUSH
// result := value + 1 ;
92379: LD_ADDR_VAR 0 2
92383: PUSH
92384: LD_VAR 0 1
92388: PUSH
92389: LD_INT 1
92391: PLUS
92392: ST_TO_ADDR
// end ;
92393: LD_VAR 0 2
92397: RET
// export function Dec ( value ) ; begin
92398: LD_INT 0
92400: PPUSH
// result := value - 1 ;
92401: LD_ADDR_VAR 0 2
92405: PUSH
92406: LD_VAR 0 1
92410: PUSH
92411: LD_INT 1
92413: MINUS
92414: ST_TO_ADDR
// end ;
92415: LD_VAR 0 2
92419: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
92420: LD_INT 0
92422: PPUSH
92423: PPUSH
92424: PPUSH
92425: PPUSH
92426: PPUSH
92427: PPUSH
92428: PPUSH
92429: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
92430: LD_VAR 0 1
92434: PPUSH
92435: LD_VAR 0 2
92439: PPUSH
92440: CALL_OW 488
92444: NOT
92445: PUSH
92446: LD_VAR 0 3
92450: PPUSH
92451: LD_VAR 0 4
92455: PPUSH
92456: CALL_OW 488
92460: NOT
92461: OR
92462: IFFALSE 92475
// begin result := - 1 ;
92464: LD_ADDR_VAR 0 5
92468: PUSH
92469: LD_INT 1
92471: NEG
92472: ST_TO_ADDR
// exit ;
92473: GO 92710
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
92475: LD_ADDR_VAR 0 12
92479: PUSH
92480: LD_VAR 0 1
92484: PPUSH
92485: LD_VAR 0 2
92489: PPUSH
92490: LD_VAR 0 3
92494: PPUSH
92495: LD_VAR 0 4
92499: PPUSH
92500: CALL 91560 0 4
92504: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
92505: LD_ADDR_VAR 0 11
92509: PUSH
92510: LD_VAR 0 1
92514: PPUSH
92515: LD_VAR 0 2
92519: PPUSH
92520: LD_VAR 0 12
92524: PUSH
92525: LD_INT 1
92527: ARRAY
92528: PPUSH
92529: LD_VAR 0 12
92533: PUSH
92534: LD_INT 2
92536: ARRAY
92537: PPUSH
92538: CALL_OW 298
92542: ST_TO_ADDR
// distance := 9999 ;
92543: LD_ADDR_VAR 0 10
92547: PUSH
92548: LD_INT 9999
92550: ST_TO_ADDR
// for i := 0 to 5 do
92551: LD_ADDR_VAR 0 6
92555: PUSH
92556: DOUBLE
92557: LD_INT 0
92559: DEC
92560: ST_TO_ADDR
92561: LD_INT 5
92563: PUSH
92564: FOR_TO
92565: IFFALSE 92708
// begin _x := ShiftX ( x1 , i , centerDist ) ;
92567: LD_ADDR_VAR 0 7
92571: PUSH
92572: LD_VAR 0 1
92576: PPUSH
92577: LD_VAR 0 6
92581: PPUSH
92582: LD_VAR 0 11
92586: PPUSH
92587: CALL_OW 272
92591: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
92592: LD_ADDR_VAR 0 8
92596: PUSH
92597: LD_VAR 0 2
92601: PPUSH
92602: LD_VAR 0 6
92606: PPUSH
92607: LD_VAR 0 11
92611: PPUSH
92612: CALL_OW 273
92616: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
92617: LD_VAR 0 7
92621: PPUSH
92622: LD_VAR 0 8
92626: PPUSH
92627: CALL_OW 488
92631: NOT
92632: IFFALSE 92636
// continue ;
92634: GO 92564
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
92636: LD_ADDR_VAR 0 9
92640: PUSH
92641: LD_VAR 0 12
92645: PUSH
92646: LD_INT 1
92648: ARRAY
92649: PPUSH
92650: LD_VAR 0 12
92654: PUSH
92655: LD_INT 2
92657: ARRAY
92658: PPUSH
92659: LD_VAR 0 7
92663: PPUSH
92664: LD_VAR 0 8
92668: PPUSH
92669: CALL_OW 298
92673: ST_TO_ADDR
// if tmp < distance then
92674: LD_VAR 0 9
92678: PUSH
92679: LD_VAR 0 10
92683: LESS
92684: IFFALSE 92706
// begin result := i ;
92686: LD_ADDR_VAR 0 5
92690: PUSH
92691: LD_VAR 0 6
92695: ST_TO_ADDR
// distance := tmp ;
92696: LD_ADDR_VAR 0 10
92700: PUSH
92701: LD_VAR 0 9
92705: ST_TO_ADDR
// end ; end ;
92706: GO 92564
92708: POP
92709: POP
// end ;
92710: LD_VAR 0 5
92714: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92715: LD_INT 0
92717: PPUSH
92718: PPUSH
// if not driver or not IsInUnit ( driver ) then
92719: LD_VAR 0 1
92723: NOT
92724: PUSH
92725: LD_VAR 0 1
92729: PPUSH
92730: CALL_OW 310
92734: NOT
92735: OR
92736: IFFALSE 92740
// exit ;
92738: GO 92830
// vehicle := IsInUnit ( driver ) ;
92740: LD_ADDR_VAR 0 3
92744: PUSH
92745: LD_VAR 0 1
92749: PPUSH
92750: CALL_OW 310
92754: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92755: LD_VAR 0 1
92759: PPUSH
92760: LD_STRING \
92762: PUSH
92763: LD_INT 0
92765: PUSH
92766: LD_INT 0
92768: PUSH
92769: LD_INT 0
92771: PUSH
92772: LD_INT 0
92774: PUSH
92775: LD_INT 0
92777: PUSH
92778: LD_INT 0
92780: PUSH
92781: EMPTY
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: PUSH
92790: LD_STRING E
92792: PUSH
92793: LD_INT 0
92795: PUSH
92796: LD_INT 0
92798: PUSH
92799: LD_VAR 0 3
92803: PUSH
92804: LD_INT 0
92806: PUSH
92807: LD_INT 0
92809: PUSH
92810: LD_INT 0
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PPUSH
92826: CALL_OW 446
// end ;
92830: LD_VAR 0 2
92834: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92835: LD_INT 0
92837: PPUSH
92838: PPUSH
// if not driver or not IsInUnit ( driver ) then
92839: LD_VAR 0 1
92843: NOT
92844: PUSH
92845: LD_VAR 0 1
92849: PPUSH
92850: CALL_OW 310
92854: NOT
92855: OR
92856: IFFALSE 92860
// exit ;
92858: GO 92950
// vehicle := IsInUnit ( driver ) ;
92860: LD_ADDR_VAR 0 3
92864: PUSH
92865: LD_VAR 0 1
92869: PPUSH
92870: CALL_OW 310
92874: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92875: LD_VAR 0 1
92879: PPUSH
92880: LD_STRING \
92882: PUSH
92883: LD_INT 0
92885: PUSH
92886: LD_INT 0
92888: PUSH
92889: LD_INT 0
92891: PUSH
92892: LD_INT 0
92894: PUSH
92895: LD_INT 0
92897: PUSH
92898: LD_INT 0
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: PUSH
92910: LD_STRING E
92912: PUSH
92913: LD_INT 0
92915: PUSH
92916: LD_INT 0
92918: PUSH
92919: LD_VAR 0 3
92923: PUSH
92924: LD_INT 0
92926: PUSH
92927: LD_INT 0
92929: PUSH
92930: LD_INT 0
92932: PUSH
92933: EMPTY
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: PUSH
92942: EMPTY
92943: LIST
92944: LIST
92945: PPUSH
92946: CALL_OW 447
// end ;
92950: LD_VAR 0 2
92954: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
92955: LD_INT 0
92957: PPUSH
92958: PPUSH
92959: PPUSH
// tmp := [ ] ;
92960: LD_ADDR_VAR 0 5
92964: PUSH
92965: EMPTY
92966: ST_TO_ADDR
// for i in units do
92967: LD_ADDR_VAR 0 4
92971: PUSH
92972: LD_VAR 0 1
92976: PUSH
92977: FOR_IN
92978: IFFALSE 93016
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
92980: LD_ADDR_VAR 0 5
92984: PUSH
92985: LD_VAR 0 5
92989: PPUSH
92990: LD_VAR 0 5
92994: PUSH
92995: LD_INT 1
92997: PLUS
92998: PPUSH
92999: LD_VAR 0 4
93003: PPUSH
93004: CALL_OW 256
93008: PPUSH
93009: CALL_OW 2
93013: ST_TO_ADDR
93014: GO 92977
93016: POP
93017: POP
// if not tmp then
93018: LD_VAR 0 5
93022: NOT
93023: IFFALSE 93027
// exit ;
93025: GO 93075
// if asc then
93027: LD_VAR 0 2
93031: IFFALSE 93055
// result := SortListByListAsc ( units , tmp ) else
93033: LD_ADDR_VAR 0 3
93037: PUSH
93038: LD_VAR 0 1
93042: PPUSH
93043: LD_VAR 0 5
93047: PPUSH
93048: CALL_OW 76
93052: ST_TO_ADDR
93053: GO 93075
// result := SortListByListDesc ( units , tmp ) ;
93055: LD_ADDR_VAR 0 3
93059: PUSH
93060: LD_VAR 0 1
93064: PPUSH
93065: LD_VAR 0 5
93069: PPUSH
93070: CALL_OW 77
93074: ST_TO_ADDR
// end ;
93075: LD_VAR 0 3
93079: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
93080: LD_INT 0
93082: PPUSH
93083: PPUSH
// task := GetTaskList ( mech ) ;
93084: LD_ADDR_VAR 0 4
93088: PUSH
93089: LD_VAR 0 1
93093: PPUSH
93094: CALL_OW 437
93098: ST_TO_ADDR
// if not task then
93099: LD_VAR 0 4
93103: NOT
93104: IFFALSE 93108
// exit ;
93106: GO 93150
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
93108: LD_ADDR_VAR 0 3
93112: PUSH
93113: LD_VAR 0 4
93117: PUSH
93118: LD_INT 1
93120: ARRAY
93121: PUSH
93122: LD_INT 1
93124: ARRAY
93125: PUSH
93126: LD_STRING r
93128: EQUAL
93129: PUSH
93130: LD_VAR 0 4
93134: PUSH
93135: LD_INT 1
93137: ARRAY
93138: PUSH
93139: LD_INT 4
93141: ARRAY
93142: PUSH
93143: LD_VAR 0 2
93147: EQUAL
93148: AND
93149: ST_TO_ADDR
// end ;
93150: LD_VAR 0 3
93154: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
93155: LD_INT 0
93157: PPUSH
// SetDir ( unit , d ) ;
93158: LD_VAR 0 1
93162: PPUSH
93163: LD_VAR 0 4
93167: PPUSH
93168: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
93172: LD_VAR 0 1
93176: PPUSH
93177: LD_VAR 0 2
93181: PPUSH
93182: LD_VAR 0 3
93186: PPUSH
93187: LD_VAR 0 5
93191: PPUSH
93192: CALL_OW 48
// end ;
93196: LD_VAR 0 6
93200: RET
// export function ToNaturalNumber ( number ) ; begin
93201: LD_INT 0
93203: PPUSH
// result := number div 1 ;
93204: LD_ADDR_VAR 0 2
93208: PUSH
93209: LD_VAR 0 1
93213: PUSH
93214: LD_INT 1
93216: DIV
93217: ST_TO_ADDR
// if number < 0 then
93218: LD_VAR 0 1
93222: PUSH
93223: LD_INT 0
93225: LESS
93226: IFFALSE 93236
// result := 0 ;
93228: LD_ADDR_VAR 0 2
93232: PUSH
93233: LD_INT 0
93235: ST_TO_ADDR
// end ;
93236: LD_VAR 0 2
93240: RET
// export function SortByClass ( units , class ) ; var un ; begin
93241: LD_INT 0
93243: PPUSH
93244: PPUSH
// if not units or not class then
93245: LD_VAR 0 1
93249: NOT
93250: PUSH
93251: LD_VAR 0 2
93255: NOT
93256: OR
93257: IFFALSE 93261
// exit ;
93259: GO 93356
// result := [ ] ;
93261: LD_ADDR_VAR 0 3
93265: PUSH
93266: EMPTY
93267: ST_TO_ADDR
// for un in units do
93268: LD_ADDR_VAR 0 4
93272: PUSH
93273: LD_VAR 0 1
93277: PUSH
93278: FOR_IN
93279: IFFALSE 93354
// if GetClass ( un ) = class then
93281: LD_VAR 0 4
93285: PPUSH
93286: CALL_OW 257
93290: PUSH
93291: LD_VAR 0 2
93295: EQUAL
93296: IFFALSE 93323
// result := Insert ( result , 1 , un ) else
93298: LD_ADDR_VAR 0 3
93302: PUSH
93303: LD_VAR 0 3
93307: PPUSH
93308: LD_INT 1
93310: PPUSH
93311: LD_VAR 0 4
93315: PPUSH
93316: CALL_OW 2
93320: ST_TO_ADDR
93321: GO 93352
// result := Replace ( result , result + 1 , un ) ;
93323: LD_ADDR_VAR 0 3
93327: PUSH
93328: LD_VAR 0 3
93332: PPUSH
93333: LD_VAR 0 3
93337: PUSH
93338: LD_INT 1
93340: PLUS
93341: PPUSH
93342: LD_VAR 0 4
93346: PPUSH
93347: CALL_OW 1
93351: ST_TO_ADDR
93352: GO 93278
93354: POP
93355: POP
// end ;
93356: LD_VAR 0 3
93360: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
93361: LD_INT 0
93363: PPUSH
93364: PPUSH
93365: PPUSH
93366: PPUSH
93367: PPUSH
93368: PPUSH
93369: PPUSH
// result := [ ] ;
93370: LD_ADDR_VAR 0 4
93374: PUSH
93375: EMPTY
93376: ST_TO_ADDR
// if x - r < 0 then
93377: LD_VAR 0 1
93381: PUSH
93382: LD_VAR 0 3
93386: MINUS
93387: PUSH
93388: LD_INT 0
93390: LESS
93391: IFFALSE 93403
// min_x := 0 else
93393: LD_ADDR_VAR 0 8
93397: PUSH
93398: LD_INT 0
93400: ST_TO_ADDR
93401: GO 93419
// min_x := x - r ;
93403: LD_ADDR_VAR 0 8
93407: PUSH
93408: LD_VAR 0 1
93412: PUSH
93413: LD_VAR 0 3
93417: MINUS
93418: ST_TO_ADDR
// if y - r < 0 then
93419: LD_VAR 0 2
93423: PUSH
93424: LD_VAR 0 3
93428: MINUS
93429: PUSH
93430: LD_INT 0
93432: LESS
93433: IFFALSE 93445
// min_y := 0 else
93435: LD_ADDR_VAR 0 7
93439: PUSH
93440: LD_INT 0
93442: ST_TO_ADDR
93443: GO 93461
// min_y := y - r ;
93445: LD_ADDR_VAR 0 7
93449: PUSH
93450: LD_VAR 0 2
93454: PUSH
93455: LD_VAR 0 3
93459: MINUS
93460: ST_TO_ADDR
// max_x := x + r ;
93461: LD_ADDR_VAR 0 9
93465: PUSH
93466: LD_VAR 0 1
93470: PUSH
93471: LD_VAR 0 3
93475: PLUS
93476: ST_TO_ADDR
// max_y := y + r ;
93477: LD_ADDR_VAR 0 10
93481: PUSH
93482: LD_VAR 0 2
93486: PUSH
93487: LD_VAR 0 3
93491: PLUS
93492: ST_TO_ADDR
// for _x = min_x to max_x do
93493: LD_ADDR_VAR 0 5
93497: PUSH
93498: DOUBLE
93499: LD_VAR 0 8
93503: DEC
93504: ST_TO_ADDR
93505: LD_VAR 0 9
93509: PUSH
93510: FOR_TO
93511: IFFALSE 93612
// for _y = min_y to max_y do
93513: LD_ADDR_VAR 0 6
93517: PUSH
93518: DOUBLE
93519: LD_VAR 0 7
93523: DEC
93524: ST_TO_ADDR
93525: LD_VAR 0 10
93529: PUSH
93530: FOR_TO
93531: IFFALSE 93608
// begin if not ValidHex ( _x , _y ) then
93533: LD_VAR 0 5
93537: PPUSH
93538: LD_VAR 0 6
93542: PPUSH
93543: CALL_OW 488
93547: NOT
93548: IFFALSE 93552
// continue ;
93550: GO 93530
// if GetResourceTypeXY ( _x , _y ) then
93552: LD_VAR 0 5
93556: PPUSH
93557: LD_VAR 0 6
93561: PPUSH
93562: CALL_OW 283
93566: IFFALSE 93606
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
93568: LD_ADDR_VAR 0 4
93572: PUSH
93573: LD_VAR 0 4
93577: PPUSH
93578: LD_VAR 0 4
93582: PUSH
93583: LD_INT 1
93585: PLUS
93586: PPUSH
93587: LD_VAR 0 5
93591: PUSH
93592: LD_VAR 0 6
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PPUSH
93601: CALL_OW 1
93605: ST_TO_ADDR
// end ;
93606: GO 93530
93608: POP
93609: POP
93610: GO 93510
93612: POP
93613: POP
// end ;
93614: LD_VAR 0 4
93618: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
93619: LD_INT 0
93621: PPUSH
93622: PPUSH
93623: PPUSH
93624: PPUSH
93625: PPUSH
93626: PPUSH
93627: PPUSH
93628: PPUSH
// if not units then
93629: LD_VAR 0 1
93633: NOT
93634: IFFALSE 93638
// exit ;
93636: GO 94162
// result := UnitFilter ( units , [ f_ok ] ) ;
93638: LD_ADDR_VAR 0 3
93642: PUSH
93643: LD_VAR 0 1
93647: PPUSH
93648: LD_INT 50
93650: PUSH
93651: EMPTY
93652: LIST
93653: PPUSH
93654: CALL_OW 72
93658: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
93659: LD_ADDR_VAR 0 8
93663: PUSH
93664: LD_VAR 0 1
93668: PUSH
93669: LD_INT 1
93671: ARRAY
93672: PPUSH
93673: CALL_OW 255
93677: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
93678: LD_ADDR_VAR 0 10
93682: PUSH
93683: LD_INT 29
93685: PUSH
93686: LD_INT 91
93688: PUSH
93689: LD_INT 49
93691: PUSH
93692: EMPTY
93693: LIST
93694: LIST
93695: LIST
93696: ST_TO_ADDR
// if not result then
93697: LD_VAR 0 3
93701: NOT
93702: IFFALSE 93706
// exit ;
93704: GO 94162
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
93706: LD_ADDR_VAR 0 5
93710: PUSH
93711: LD_INT 81
93713: PUSH
93714: LD_VAR 0 8
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PPUSH
93723: CALL_OW 69
93727: ST_TO_ADDR
// for i in result do
93728: LD_ADDR_VAR 0 4
93732: PUSH
93733: LD_VAR 0 3
93737: PUSH
93738: FOR_IN
93739: IFFALSE 94160
// begin tag := GetTag ( i ) + 1 ;
93741: LD_ADDR_VAR 0 9
93745: PUSH
93746: LD_VAR 0 4
93750: PPUSH
93751: CALL_OW 110
93755: PUSH
93756: LD_INT 1
93758: PLUS
93759: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
93760: LD_ADDR_VAR 0 7
93764: PUSH
93765: LD_VAR 0 4
93769: PPUSH
93770: CALL_OW 250
93774: PPUSH
93775: LD_VAR 0 4
93779: PPUSH
93780: CALL_OW 251
93784: PPUSH
93785: LD_INT 6
93787: PPUSH
93788: CALL 93361 0 3
93792: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
93793: LD_VAR 0 4
93797: PPUSH
93798: CALL_OW 247
93802: PUSH
93803: LD_INT 2
93805: EQUAL
93806: PUSH
93807: LD_VAR 0 7
93811: AND
93812: PUSH
93813: LD_VAR 0 4
93817: PPUSH
93818: CALL_OW 264
93822: PUSH
93823: LD_VAR 0 10
93827: IN
93828: NOT
93829: AND
93830: IFFALSE 93869
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
93832: LD_VAR 0 4
93836: PPUSH
93837: LD_VAR 0 7
93841: PUSH
93842: LD_INT 1
93844: ARRAY
93845: PUSH
93846: LD_INT 1
93848: ARRAY
93849: PPUSH
93850: LD_VAR 0 7
93854: PUSH
93855: LD_INT 1
93857: ARRAY
93858: PUSH
93859: LD_INT 2
93861: ARRAY
93862: PPUSH
93863: CALL_OW 116
93867: GO 94158
// if path > tag then
93869: LD_VAR 0 2
93873: PUSH
93874: LD_VAR 0 9
93878: GREATER
93879: IFFALSE 94087
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
93881: LD_ADDR_VAR 0 6
93885: PUSH
93886: LD_VAR 0 5
93890: PPUSH
93891: LD_INT 91
93893: PUSH
93894: LD_VAR 0 4
93898: PUSH
93899: LD_INT 8
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: LIST
93906: PPUSH
93907: CALL_OW 72
93911: ST_TO_ADDR
// if nearEnemy then
93912: LD_VAR 0 6
93916: IFFALSE 93985
// begin if GetWeapon ( i ) = ru_time_lapser then
93918: LD_VAR 0 4
93922: PPUSH
93923: CALL_OW 264
93927: PUSH
93928: LD_INT 49
93930: EQUAL
93931: IFFALSE 93959
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
93933: LD_VAR 0 4
93937: PPUSH
93938: LD_VAR 0 6
93942: PPUSH
93943: LD_VAR 0 4
93947: PPUSH
93948: CALL_OW 74
93952: PPUSH
93953: CALL_OW 112
93957: GO 93983
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
93959: LD_VAR 0 4
93963: PPUSH
93964: LD_VAR 0 6
93968: PPUSH
93969: LD_VAR 0 4
93973: PPUSH
93974: CALL_OW 74
93978: PPUSH
93979: CALL 95087 0 2
// end else
93983: GO 94085
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
93985: LD_VAR 0 4
93989: PPUSH
93990: LD_VAR 0 2
93994: PUSH
93995: LD_VAR 0 9
93999: ARRAY
94000: PUSH
94001: LD_INT 1
94003: ARRAY
94004: PPUSH
94005: LD_VAR 0 2
94009: PUSH
94010: LD_VAR 0 9
94014: ARRAY
94015: PUSH
94016: LD_INT 2
94018: ARRAY
94019: PPUSH
94020: CALL_OW 297
94024: PUSH
94025: LD_INT 6
94027: GREATER
94028: IFFALSE 94071
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
94030: LD_VAR 0 4
94034: PPUSH
94035: LD_VAR 0 2
94039: PUSH
94040: LD_VAR 0 9
94044: ARRAY
94045: PUSH
94046: LD_INT 1
94048: ARRAY
94049: PPUSH
94050: LD_VAR 0 2
94054: PUSH
94055: LD_VAR 0 9
94059: ARRAY
94060: PUSH
94061: LD_INT 2
94063: ARRAY
94064: PPUSH
94065: CALL_OW 114
94069: GO 94085
// SetTag ( i , tag ) ;
94071: LD_VAR 0 4
94075: PPUSH
94076: LD_VAR 0 9
94080: PPUSH
94081: CALL_OW 109
// end else
94085: GO 94158
// if enemy then
94087: LD_VAR 0 5
94091: IFFALSE 94158
// begin if GetWeapon ( i ) = ru_time_lapser then
94093: LD_VAR 0 4
94097: PPUSH
94098: CALL_OW 264
94102: PUSH
94103: LD_INT 49
94105: EQUAL
94106: IFFALSE 94134
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
94108: LD_VAR 0 4
94112: PPUSH
94113: LD_VAR 0 5
94117: PPUSH
94118: LD_VAR 0 4
94122: PPUSH
94123: CALL_OW 74
94127: PPUSH
94128: CALL_OW 112
94132: GO 94158
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
94134: LD_VAR 0 4
94138: PPUSH
94139: LD_VAR 0 5
94143: PPUSH
94144: LD_VAR 0 4
94148: PPUSH
94149: CALL_OW 74
94153: PPUSH
94154: CALL 95087 0 2
// end ; end ;
94158: GO 93738
94160: POP
94161: POP
// end ;
94162: LD_VAR 0 3
94166: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
94167: LD_INT 0
94169: PPUSH
94170: PPUSH
94171: PPUSH
// if not unit or IsInUnit ( unit ) then
94172: LD_VAR 0 1
94176: NOT
94177: PUSH
94178: LD_VAR 0 1
94182: PPUSH
94183: CALL_OW 310
94187: OR
94188: IFFALSE 94192
// exit ;
94190: GO 94283
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
94192: LD_ADDR_VAR 0 4
94196: PUSH
94197: LD_VAR 0 1
94201: PPUSH
94202: CALL_OW 250
94206: PPUSH
94207: LD_VAR 0 2
94211: PPUSH
94212: LD_INT 1
94214: PPUSH
94215: CALL_OW 272
94219: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
94220: LD_ADDR_VAR 0 5
94224: PUSH
94225: LD_VAR 0 1
94229: PPUSH
94230: CALL_OW 251
94234: PPUSH
94235: LD_VAR 0 2
94239: PPUSH
94240: LD_INT 1
94242: PPUSH
94243: CALL_OW 273
94247: ST_TO_ADDR
// if ValidHex ( x , y ) then
94248: LD_VAR 0 4
94252: PPUSH
94253: LD_VAR 0 5
94257: PPUSH
94258: CALL_OW 488
94262: IFFALSE 94283
// ComTurnXY ( unit , x , y ) ;
94264: LD_VAR 0 1
94268: PPUSH
94269: LD_VAR 0 4
94273: PPUSH
94274: LD_VAR 0 5
94278: PPUSH
94279: CALL_OW 118
// end ;
94283: LD_VAR 0 3
94287: RET
// export function SeeUnits ( side , units ) ; var i ; begin
94288: LD_INT 0
94290: PPUSH
94291: PPUSH
// result := false ;
94292: LD_ADDR_VAR 0 3
94296: PUSH
94297: LD_INT 0
94299: ST_TO_ADDR
// if not units then
94300: LD_VAR 0 2
94304: NOT
94305: IFFALSE 94309
// exit ;
94307: GO 94354
// for i in units do
94309: LD_ADDR_VAR 0 4
94313: PUSH
94314: LD_VAR 0 2
94318: PUSH
94319: FOR_IN
94320: IFFALSE 94352
// if See ( side , i ) then
94322: LD_VAR 0 1
94326: PPUSH
94327: LD_VAR 0 4
94331: PPUSH
94332: CALL_OW 292
94336: IFFALSE 94350
// begin result := true ;
94338: LD_ADDR_VAR 0 3
94342: PUSH
94343: LD_INT 1
94345: ST_TO_ADDR
// exit ;
94346: POP
94347: POP
94348: GO 94354
// end ;
94350: GO 94319
94352: POP
94353: POP
// end ;
94354: LD_VAR 0 3
94358: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
94359: LD_INT 0
94361: PPUSH
94362: PPUSH
94363: PPUSH
94364: PPUSH
// if not unit or not points then
94365: LD_VAR 0 1
94369: NOT
94370: PUSH
94371: LD_VAR 0 2
94375: NOT
94376: OR
94377: IFFALSE 94381
// exit ;
94379: GO 94471
// dist := 99999 ;
94381: LD_ADDR_VAR 0 5
94385: PUSH
94386: LD_INT 99999
94388: ST_TO_ADDR
// for i in points do
94389: LD_ADDR_VAR 0 4
94393: PUSH
94394: LD_VAR 0 2
94398: PUSH
94399: FOR_IN
94400: IFFALSE 94469
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
94402: LD_ADDR_VAR 0 6
94406: PUSH
94407: LD_VAR 0 1
94411: PPUSH
94412: LD_VAR 0 4
94416: PUSH
94417: LD_INT 1
94419: ARRAY
94420: PPUSH
94421: LD_VAR 0 4
94425: PUSH
94426: LD_INT 2
94428: ARRAY
94429: PPUSH
94430: CALL_OW 297
94434: ST_TO_ADDR
// if tmpDist < dist then
94435: LD_VAR 0 6
94439: PUSH
94440: LD_VAR 0 5
94444: LESS
94445: IFFALSE 94467
// begin result := i ;
94447: LD_ADDR_VAR 0 3
94451: PUSH
94452: LD_VAR 0 4
94456: ST_TO_ADDR
// dist := tmpDist ;
94457: LD_ADDR_VAR 0 5
94461: PUSH
94462: LD_VAR 0 6
94466: ST_TO_ADDR
// end ; end ;
94467: GO 94399
94469: POP
94470: POP
// end ;
94471: LD_VAR 0 3
94475: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
94476: LD_INT 0
94478: PPUSH
// uc_side := side ;
94479: LD_ADDR_OWVAR 20
94483: PUSH
94484: LD_VAR 0 1
94488: ST_TO_ADDR
// uc_nation := 3 ;
94489: LD_ADDR_OWVAR 21
94493: PUSH
94494: LD_INT 3
94496: ST_TO_ADDR
// vc_chassis := 25 ;
94497: LD_ADDR_OWVAR 37
94501: PUSH
94502: LD_INT 25
94504: ST_TO_ADDR
// vc_engine := engine_siberite ;
94505: LD_ADDR_OWVAR 39
94509: PUSH
94510: LD_INT 3
94512: ST_TO_ADDR
// vc_control := control_computer ;
94513: LD_ADDR_OWVAR 38
94517: PUSH
94518: LD_INT 3
94520: ST_TO_ADDR
// vc_weapon := 59 ;
94521: LD_ADDR_OWVAR 40
94525: PUSH
94526: LD_INT 59
94528: ST_TO_ADDR
// result := CreateVehicle ;
94529: LD_ADDR_VAR 0 5
94533: PUSH
94534: CALL_OW 45
94538: ST_TO_ADDR
// SetDir ( result , d ) ;
94539: LD_VAR 0 5
94543: PPUSH
94544: LD_VAR 0 4
94548: PPUSH
94549: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
94553: LD_VAR 0 5
94557: PPUSH
94558: LD_VAR 0 2
94562: PPUSH
94563: LD_VAR 0 3
94567: PPUSH
94568: LD_INT 0
94570: PPUSH
94571: CALL_OW 48
// end ;
94575: LD_VAR 0 5
94579: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
94580: LD_INT 0
94582: PPUSH
94583: PPUSH
94584: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
94585: LD_ADDR_VAR 0 2
94589: PUSH
94590: LD_INT 0
94592: PUSH
94593: LD_INT 0
94595: PUSH
94596: LD_INT 0
94598: PUSH
94599: LD_INT 0
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
94608: LD_VAR 0 1
94612: NOT
94613: PUSH
94614: LD_VAR 0 1
94618: PPUSH
94619: CALL_OW 264
94623: PUSH
94624: LD_INT 12
94626: PUSH
94627: LD_INT 51
94629: PUSH
94630: LD_INT 32
94632: PUSH
94633: LD_INT 89
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: IN
94642: NOT
94643: OR
94644: IFFALSE 94648
// exit ;
94646: GO 94746
// for i := 1 to 3 do
94648: LD_ADDR_VAR 0 3
94652: PUSH
94653: DOUBLE
94654: LD_INT 1
94656: DEC
94657: ST_TO_ADDR
94658: LD_INT 3
94660: PUSH
94661: FOR_TO
94662: IFFALSE 94744
// begin tmp := GetCargo ( cargo , i ) ;
94664: LD_ADDR_VAR 0 4
94668: PUSH
94669: LD_VAR 0 1
94673: PPUSH
94674: LD_VAR 0 3
94678: PPUSH
94679: CALL_OW 289
94683: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
94684: LD_ADDR_VAR 0 2
94688: PUSH
94689: LD_VAR 0 2
94693: PPUSH
94694: LD_VAR 0 3
94698: PPUSH
94699: LD_VAR 0 4
94703: PPUSH
94704: CALL_OW 1
94708: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
94709: LD_ADDR_VAR 0 2
94713: PUSH
94714: LD_VAR 0 2
94718: PPUSH
94719: LD_INT 4
94721: PPUSH
94722: LD_VAR 0 2
94726: PUSH
94727: LD_INT 4
94729: ARRAY
94730: PUSH
94731: LD_VAR 0 4
94735: PLUS
94736: PPUSH
94737: CALL_OW 1
94741: ST_TO_ADDR
// end ;
94742: GO 94661
94744: POP
94745: POP
// end ;
94746: LD_VAR 0 2
94750: RET
// export function Length ( array ) ; begin
94751: LD_INT 0
94753: PPUSH
// result := array + 0 ;
94754: LD_ADDR_VAR 0 2
94758: PUSH
94759: LD_VAR 0 1
94763: PUSH
94764: LD_INT 0
94766: PLUS
94767: ST_TO_ADDR
// end ;
94768: LD_VAR 0 2
94772: RET
// export function PrepareArray ( array ) ; begin
94773: LD_INT 0
94775: PPUSH
// result := array diff 0 ;
94776: LD_ADDR_VAR 0 2
94780: PUSH
94781: LD_VAR 0 1
94785: PUSH
94786: LD_INT 0
94788: DIFF
94789: ST_TO_ADDR
// if not result [ 1 ] then
94790: LD_VAR 0 2
94794: PUSH
94795: LD_INT 1
94797: ARRAY
94798: NOT
94799: IFFALSE 94819
// result := Delete ( result , 1 ) ;
94801: LD_ADDR_VAR 0 2
94805: PUSH
94806: LD_VAR 0 2
94810: PPUSH
94811: LD_INT 1
94813: PPUSH
94814: CALL_OW 3
94818: ST_TO_ADDR
// end ;
94819: LD_VAR 0 2
94823: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
94824: LD_INT 0
94826: PPUSH
94827: PPUSH
94828: PPUSH
94829: PPUSH
// sibRocketRange := 25 ;
94830: LD_ADDR_VAR 0 6
94834: PUSH
94835: LD_INT 25
94837: ST_TO_ADDR
// result := false ;
94838: LD_ADDR_VAR 0 4
94842: PUSH
94843: LD_INT 0
94845: ST_TO_ADDR
// for i := 0 to 5 do
94846: LD_ADDR_VAR 0 5
94850: PUSH
94851: DOUBLE
94852: LD_INT 0
94854: DEC
94855: ST_TO_ADDR
94856: LD_INT 5
94858: PUSH
94859: FOR_TO
94860: IFFALSE 94927
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
94862: LD_VAR 0 1
94866: PPUSH
94867: LD_VAR 0 5
94871: PPUSH
94872: LD_VAR 0 6
94876: PPUSH
94877: CALL_OW 272
94881: PPUSH
94882: LD_VAR 0 2
94886: PPUSH
94887: LD_VAR 0 5
94891: PPUSH
94892: LD_VAR 0 6
94896: PPUSH
94897: CALL_OW 273
94901: PPUSH
94902: LD_VAR 0 3
94906: PPUSH
94907: CALL_OW 309
94911: IFFALSE 94925
// begin result := true ;
94913: LD_ADDR_VAR 0 4
94917: PUSH
94918: LD_INT 1
94920: ST_TO_ADDR
// exit ;
94921: POP
94922: POP
94923: GO 94929
// end ;
94925: GO 94859
94927: POP
94928: POP
// end ;
94929: LD_VAR 0 4
94933: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
94934: LD_INT 0
94936: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
94937: LD_VAR 0 1
94941: PPUSH
94942: LD_VAR 0 2
94946: PPUSH
94947: LD_INT 0
94949: PPUSH
94950: LD_INT 0
94952: PPUSH
94953: LD_INT 1
94955: PPUSH
94956: LD_INT 0
94958: PPUSH
94959: CALL_OW 587
// end ;
94963: LD_VAR 0 3
94967: RET
// export function CenterOnNow ( unit ) ; begin
94968: LD_INT 0
94970: PPUSH
// result := IsInUnit ( unit ) ;
94971: LD_ADDR_VAR 0 2
94975: PUSH
94976: LD_VAR 0 1
94980: PPUSH
94981: CALL_OW 310
94985: ST_TO_ADDR
// if not result then
94986: LD_VAR 0 2
94990: NOT
94991: IFFALSE 95003
// result := unit ;
94993: LD_ADDR_VAR 0 2
94997: PUSH
94998: LD_VAR 0 1
95002: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
95003: LD_VAR 0 1
95007: PPUSH
95008: CALL_OW 87
// end ;
95012: LD_VAR 0 2
95016: RET
// export function ComMoveHex ( unit , hex ) ; begin
95017: LD_INT 0
95019: PPUSH
// if not hex then
95020: LD_VAR 0 2
95024: NOT
95025: IFFALSE 95029
// exit ;
95027: GO 95082
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
95029: LD_VAR 0 2
95033: PUSH
95034: LD_INT 1
95036: ARRAY
95037: PPUSH
95038: LD_VAR 0 2
95042: PUSH
95043: LD_INT 2
95045: ARRAY
95046: PPUSH
95047: CALL_OW 428
95051: IFFALSE 95055
// exit ;
95053: GO 95082
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
95055: LD_VAR 0 1
95059: PPUSH
95060: LD_VAR 0 2
95064: PUSH
95065: LD_INT 1
95067: ARRAY
95068: PPUSH
95069: LD_VAR 0 2
95073: PUSH
95074: LD_INT 2
95076: ARRAY
95077: PPUSH
95078: CALL_OW 111
// end ;
95082: LD_VAR 0 3
95086: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
95087: LD_INT 0
95089: PPUSH
95090: PPUSH
95091: PPUSH
// if not unit or not enemy then
95092: LD_VAR 0 1
95096: NOT
95097: PUSH
95098: LD_VAR 0 2
95102: NOT
95103: OR
95104: IFFALSE 95108
// exit ;
95106: GO 95232
// x := GetX ( enemy ) ;
95108: LD_ADDR_VAR 0 4
95112: PUSH
95113: LD_VAR 0 2
95117: PPUSH
95118: CALL_OW 250
95122: ST_TO_ADDR
// y := GetY ( enemy ) ;
95123: LD_ADDR_VAR 0 5
95127: PUSH
95128: LD_VAR 0 2
95132: PPUSH
95133: CALL_OW 251
95137: ST_TO_ADDR
// if ValidHex ( x , y ) then
95138: LD_VAR 0 4
95142: PPUSH
95143: LD_VAR 0 5
95147: PPUSH
95148: CALL_OW 488
95152: IFFALSE 95232
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
95154: LD_VAR 0 2
95158: PPUSH
95159: CALL_OW 247
95163: PUSH
95164: LD_INT 3
95166: PUSH
95167: LD_INT 2
95169: PUSH
95170: EMPTY
95171: LIST
95172: LIST
95173: IN
95174: PUSH
95175: LD_VAR 0 1
95179: PPUSH
95180: CALL_OW 255
95184: PPUSH
95185: LD_VAR 0 2
95189: PPUSH
95190: CALL_OW 292
95194: OR
95195: IFFALSE 95213
// ComAttackUnit ( unit , enemy ) else
95197: LD_VAR 0 1
95201: PPUSH
95202: LD_VAR 0 2
95206: PPUSH
95207: CALL_OW 115
95211: GO 95232
// ComAgressiveMove ( unit , x , y ) ;
95213: LD_VAR 0 1
95217: PPUSH
95218: LD_VAR 0 4
95222: PPUSH
95223: LD_VAR 0 5
95227: PPUSH
95228: CALL_OW 114
// end ;
95232: LD_VAR 0 3
95236: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
95237: LD_INT 0
95239: PPUSH
95240: PPUSH
95241: PPUSH
// list := AreaToList ( area , 0 ) ;
95242: LD_ADDR_VAR 0 5
95246: PUSH
95247: LD_VAR 0 1
95251: PPUSH
95252: LD_INT 0
95254: PPUSH
95255: CALL_OW 517
95259: ST_TO_ADDR
// if not list then
95260: LD_VAR 0 5
95264: NOT
95265: IFFALSE 95269
// exit ;
95267: GO 95399
// if all then
95269: LD_VAR 0 2
95273: IFFALSE 95361
// begin for i := 1 to list [ 1 ] do
95275: LD_ADDR_VAR 0 4
95279: PUSH
95280: DOUBLE
95281: LD_INT 1
95283: DEC
95284: ST_TO_ADDR
95285: LD_VAR 0 5
95289: PUSH
95290: LD_INT 1
95292: ARRAY
95293: PUSH
95294: FOR_TO
95295: IFFALSE 95357
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
95297: LD_ADDR_VAR 0 3
95301: PUSH
95302: LD_VAR 0 3
95306: PPUSH
95307: LD_VAR 0 3
95311: PUSH
95312: LD_INT 1
95314: PLUS
95315: PPUSH
95316: LD_VAR 0 5
95320: PUSH
95321: LD_INT 1
95323: ARRAY
95324: PUSH
95325: LD_VAR 0 4
95329: ARRAY
95330: PUSH
95331: LD_VAR 0 5
95335: PUSH
95336: LD_INT 2
95338: ARRAY
95339: PUSH
95340: LD_VAR 0 4
95344: ARRAY
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: PPUSH
95350: CALL_OW 1
95354: ST_TO_ADDR
95355: GO 95294
95357: POP
95358: POP
// exit ;
95359: GO 95399
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
95361: LD_ADDR_VAR 0 3
95365: PUSH
95366: LD_VAR 0 5
95370: PUSH
95371: LD_INT 1
95373: ARRAY
95374: PUSH
95375: LD_INT 1
95377: ARRAY
95378: PUSH
95379: LD_VAR 0 5
95383: PUSH
95384: LD_INT 2
95386: ARRAY
95387: PUSH
95388: LD_INT 1
95390: ARRAY
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: PUSH
95396: EMPTY
95397: LIST
95398: ST_TO_ADDR
// end ;
95399: LD_VAR 0 3
95403: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
95404: LD_INT 0
95406: PPUSH
95407: PPUSH
// list := AreaToList ( area , 0 ) ;
95408: LD_ADDR_VAR 0 4
95412: PUSH
95413: LD_VAR 0 1
95417: PPUSH
95418: LD_INT 0
95420: PPUSH
95421: CALL_OW 517
95425: ST_TO_ADDR
// if not list then
95426: LD_VAR 0 4
95430: NOT
95431: IFFALSE 95435
// exit ;
95433: GO 95476
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
95435: LD_ADDR_VAR 0 3
95439: PUSH
95440: LD_VAR 0 4
95444: PUSH
95445: LD_INT 1
95447: ARRAY
95448: PUSH
95449: LD_INT 1
95451: ARRAY
95452: PUSH
95453: LD_VAR 0 4
95457: PUSH
95458: LD_INT 2
95460: ARRAY
95461: PUSH
95462: LD_INT 1
95464: ARRAY
95465: PUSH
95466: LD_VAR 0 2
95470: PUSH
95471: EMPTY
95472: LIST
95473: LIST
95474: LIST
95475: ST_TO_ADDR
// end ;
95476: LD_VAR 0 3
95480: RET
// export function First ( array ) ; begin
95481: LD_INT 0
95483: PPUSH
// if not array then
95484: LD_VAR 0 1
95488: NOT
95489: IFFALSE 95493
// exit ;
95491: GO 95507
// result := array [ 1 ] ;
95493: LD_ADDR_VAR 0 2
95497: PUSH
95498: LD_VAR 0 1
95502: PUSH
95503: LD_INT 1
95505: ARRAY
95506: ST_TO_ADDR
// end ;
95507: LD_VAR 0 2
95511: RET
// export function Last ( array ) ; begin
95512: LD_INT 0
95514: PPUSH
// if not array then
95515: LD_VAR 0 1
95519: NOT
95520: IFFALSE 95524
// exit ;
95522: GO 95540
// result := array [ array ] ;
95524: LD_ADDR_VAR 0 2
95528: PUSH
95529: LD_VAR 0 1
95533: PUSH
95534: LD_VAR 0 1
95538: ARRAY
95539: ST_TO_ADDR
// end ;
95540: LD_VAR 0 2
95544: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
95545: LD_INT 0
95547: PPUSH
95548: PPUSH
// result := [ ] ;
95549: LD_ADDR_VAR 0 5
95553: PUSH
95554: EMPTY
95555: ST_TO_ADDR
// if not array then
95556: LD_VAR 0 1
95560: NOT
95561: IFFALSE 95565
// exit ;
95563: GO 95677
// for i := 1 to array do
95565: LD_ADDR_VAR 0 6
95569: PUSH
95570: DOUBLE
95571: LD_INT 1
95573: DEC
95574: ST_TO_ADDR
95575: LD_VAR 0 1
95579: PUSH
95580: FOR_TO
95581: IFFALSE 95675
// if array [ i ] [ index ] = value then
95583: LD_VAR 0 1
95587: PUSH
95588: LD_VAR 0 6
95592: ARRAY
95593: PUSH
95594: LD_VAR 0 2
95598: ARRAY
95599: PUSH
95600: LD_VAR 0 3
95604: EQUAL
95605: IFFALSE 95673
// begin if indexColumn then
95607: LD_VAR 0 4
95611: IFFALSE 95647
// result := Join ( result , array [ i ] [ indexColumn ] ) else
95613: LD_ADDR_VAR 0 5
95617: PUSH
95618: LD_VAR 0 5
95622: PPUSH
95623: LD_VAR 0 1
95627: PUSH
95628: LD_VAR 0 6
95632: ARRAY
95633: PUSH
95634: LD_VAR 0 4
95638: ARRAY
95639: PPUSH
95640: CALL 91015 0 2
95644: ST_TO_ADDR
95645: GO 95673
// result := Join ( result , array [ i ] ) ;
95647: LD_ADDR_VAR 0 5
95651: PUSH
95652: LD_VAR 0 5
95656: PPUSH
95657: LD_VAR 0 1
95661: PUSH
95662: LD_VAR 0 6
95666: ARRAY
95667: PPUSH
95668: CALL 91015 0 2
95672: ST_TO_ADDR
// end ;
95673: GO 95580
95675: POP
95676: POP
// end ;
95677: LD_VAR 0 5
95681: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
95682: LD_INT 0
95684: PPUSH
95685: PPUSH
95686: PPUSH
// if btype = b_depot then
95687: LD_VAR 0 2
95691: PUSH
95692: LD_INT 0
95694: EQUAL
95695: IFFALSE 95707
// begin result := true ;
95697: LD_ADDR_VAR 0 3
95701: PUSH
95702: LD_INT 1
95704: ST_TO_ADDR
// exit ;
95705: GO 95823
// end ; pom := GetBase ( depot ) ;
95707: LD_ADDR_VAR 0 4
95711: PUSH
95712: LD_VAR 0 1
95716: PPUSH
95717: CALL_OW 274
95721: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
95722: LD_ADDR_VAR 0 5
95726: PUSH
95727: LD_VAR 0 2
95731: PPUSH
95732: LD_VAR 0 1
95736: PPUSH
95737: CALL_OW 248
95741: PPUSH
95742: CALL_OW 450
95746: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
95747: LD_ADDR_VAR 0 3
95751: PUSH
95752: LD_VAR 0 4
95756: PPUSH
95757: LD_INT 1
95759: PPUSH
95760: CALL_OW 275
95764: PUSH
95765: LD_VAR 0 5
95769: PUSH
95770: LD_INT 1
95772: ARRAY
95773: GREATEREQUAL
95774: PUSH
95775: LD_VAR 0 4
95779: PPUSH
95780: LD_INT 2
95782: PPUSH
95783: CALL_OW 275
95787: PUSH
95788: LD_VAR 0 5
95792: PUSH
95793: LD_INT 2
95795: ARRAY
95796: GREATEREQUAL
95797: AND
95798: PUSH
95799: LD_VAR 0 4
95803: PPUSH
95804: LD_INT 3
95806: PPUSH
95807: CALL_OW 275
95811: PUSH
95812: LD_VAR 0 5
95816: PUSH
95817: LD_INT 3
95819: ARRAY
95820: GREATEREQUAL
95821: AND
95822: ST_TO_ADDR
// end ;
95823: LD_VAR 0 3
95827: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
95828: LD_INT 0
95830: PPUSH
// if not vehicles or not parkingPoint then
95831: LD_VAR 0 1
95835: NOT
95836: PUSH
95837: LD_VAR 0 2
95841: NOT
95842: OR
95843: IFFALSE 95847
// exit ;
95845: GO 95945
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
95847: LD_ADDR_VAR 0 1
95851: PUSH
95852: LD_VAR 0 1
95856: PPUSH
95857: LD_INT 50
95859: PUSH
95860: EMPTY
95861: LIST
95862: PUSH
95863: LD_INT 3
95865: PUSH
95866: LD_INT 92
95868: PUSH
95869: LD_VAR 0 2
95873: PUSH
95874: LD_INT 1
95876: ARRAY
95877: PUSH
95878: LD_VAR 0 2
95882: PUSH
95883: LD_INT 2
95885: ARRAY
95886: PUSH
95887: LD_INT 8
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: PUSH
95896: EMPTY
95897: LIST
95898: LIST
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PPUSH
95904: CALL_OW 72
95908: ST_TO_ADDR
// if not vehicles then
95909: LD_VAR 0 1
95913: NOT
95914: IFFALSE 95918
// exit ;
95916: GO 95945
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
95918: LD_VAR 0 1
95922: PPUSH
95923: LD_VAR 0 2
95927: PUSH
95928: LD_INT 1
95930: ARRAY
95931: PPUSH
95932: LD_VAR 0 2
95936: PUSH
95937: LD_INT 2
95939: ARRAY
95940: PPUSH
95941: CALL_OW 111
// end ;
95945: LD_VAR 0 3
95949: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
95950: LD_INT 0
95952: PPUSH
95953: PPUSH
95954: PPUSH
// if not side or not area then
95955: LD_VAR 0 1
95959: NOT
95960: PUSH
95961: LD_VAR 0 2
95965: NOT
95966: OR
95967: IFFALSE 95971
// exit ;
95969: GO 96090
// tmp := AreaToList ( area , 0 ) ;
95971: LD_ADDR_VAR 0 5
95975: PUSH
95976: LD_VAR 0 2
95980: PPUSH
95981: LD_INT 0
95983: PPUSH
95984: CALL_OW 517
95988: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
95989: LD_ADDR_VAR 0 4
95993: PUSH
95994: DOUBLE
95995: LD_INT 1
95997: DEC
95998: ST_TO_ADDR
95999: LD_VAR 0 5
96003: PUSH
96004: LD_INT 1
96006: ARRAY
96007: PUSH
96008: FOR_TO
96009: IFFALSE 96088
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
96011: LD_VAR 0 5
96015: PUSH
96016: LD_INT 1
96018: ARRAY
96019: PUSH
96020: LD_VAR 0 4
96024: ARRAY
96025: PPUSH
96026: LD_VAR 0 5
96030: PUSH
96031: LD_INT 2
96033: ARRAY
96034: PUSH
96035: LD_VAR 0 4
96039: ARRAY
96040: PPUSH
96041: CALL_OW 351
96045: IFFALSE 96086
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
96047: LD_VAR 0 5
96051: PUSH
96052: LD_INT 1
96054: ARRAY
96055: PUSH
96056: LD_VAR 0 4
96060: ARRAY
96061: PPUSH
96062: LD_VAR 0 5
96066: PUSH
96067: LD_INT 2
96069: ARRAY
96070: PUSH
96071: LD_VAR 0 4
96075: ARRAY
96076: PPUSH
96077: LD_VAR 0 1
96081: PPUSH
96082: CALL_OW 244
// end ;
96086: GO 96008
96088: POP
96089: POP
// end ; end_of_file end_of_file
96090: LD_VAR 0 3
96094: RET
// export globalGameSaveCounter ; every 0 0$1 do
96095: GO 96097
96097: DISABLE
// begin enable ;
96098: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
96099: LD_STRING updateTimer(
96101: PUSH
96102: LD_OWVAR 1
96106: STR
96107: PUSH
96108: LD_STRING );
96110: STR
96111: PPUSH
96112: CALL_OW 559
// end ;
96116: END
// every 0 0$1 do
96117: GO 96119
96119: DISABLE
// begin globalGameSaveCounter := 0 ;
96120: LD_ADDR_EXP 123
96124: PUSH
96125: LD_INT 0
96127: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
96128: LD_STRING setGameSaveCounter(0)
96130: PPUSH
96131: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
96135: LD_STRING initStreamRollete();
96137: PPUSH
96138: CALL_OW 559
// InitStreamMode ;
96142: CALL 97485 0 0
// DefineStreamItems ( false ) ;
96146: LD_INT 0
96148: PPUSH
96149: CALL 97949 0 1
// end ;
96153: END
// export function SOS_MapStart ( ) ; begin
96154: LD_INT 0
96156: PPUSH
// if streamModeActive then
96157: LD_EXP 124
96161: IFFALSE 96170
// DefineStreamItems ( true ) ;
96163: LD_INT 1
96165: PPUSH
96166: CALL 97949 0 1
// UpdateLuaVariables ( ) ;
96170: CALL 96187 0 0
// UpdateFactoryWaypoints ( ) ;
96174: CALL 110818 0 0
// UpdateWarehouseGatheringPoints ( ) ;
96178: CALL 111075 0 0
// end ;
96182: LD_VAR 0 1
96186: RET
// function UpdateLuaVariables ( ) ; begin
96187: LD_INT 0
96189: PPUSH
// if globalGameSaveCounter then
96190: LD_EXP 123
96194: IFFALSE 96228
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
96196: LD_ADDR_EXP 123
96200: PUSH
96201: LD_EXP 123
96205: PPUSH
96206: CALL 92376 0 1
96210: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96211: LD_STRING setGameSaveCounter(
96213: PUSH
96214: LD_EXP 123
96218: STR
96219: PUSH
96220: LD_STRING )
96222: STR
96223: PPUSH
96224: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
96228: LD_STRING setGameDifficulty(
96230: PUSH
96231: LD_OWVAR 67
96235: STR
96236: PUSH
96237: LD_STRING )
96239: STR
96240: PPUSH
96241: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
96245: LD_STRING displayDifficulty(
96247: PUSH
96248: LD_OWVAR 67
96252: STR
96253: PUSH
96254: LD_STRING )
96256: STR
96257: PPUSH
96258: CALL_OW 559
// end ;
96262: LD_VAR 0 1
96266: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96267: LD_INT 0
96269: PPUSH
// if p2 = stream_mode then
96270: LD_VAR 0 2
96274: PUSH
96275: LD_INT 100
96277: EQUAL
96278: IFFALSE 97281
// begin if not StreamModeActive then
96280: LD_EXP 124
96284: NOT
96285: IFFALSE 96295
// StreamModeActive := true ;
96287: LD_ADDR_EXP 124
96291: PUSH
96292: LD_INT 1
96294: ST_TO_ADDR
// if p3 = 0 then
96295: LD_VAR 0 3
96299: PUSH
96300: LD_INT 0
96302: EQUAL
96303: IFFALSE 96309
// InitStreamMode ;
96305: CALL 97485 0 0
// if p3 = 1 then
96309: LD_VAR 0 3
96313: PUSH
96314: LD_INT 1
96316: EQUAL
96317: IFFALSE 96327
// sRocket := true ;
96319: LD_ADDR_EXP 129
96323: PUSH
96324: LD_INT 1
96326: ST_TO_ADDR
// if p3 = 2 then
96327: LD_VAR 0 3
96331: PUSH
96332: LD_INT 2
96334: EQUAL
96335: IFFALSE 96345
// sSpeed := true ;
96337: LD_ADDR_EXP 128
96341: PUSH
96342: LD_INT 1
96344: ST_TO_ADDR
// if p3 = 3 then
96345: LD_VAR 0 3
96349: PUSH
96350: LD_INT 3
96352: EQUAL
96353: IFFALSE 96363
// sEngine := true ;
96355: LD_ADDR_EXP 130
96359: PUSH
96360: LD_INT 1
96362: ST_TO_ADDR
// if p3 = 4 then
96363: LD_VAR 0 3
96367: PUSH
96368: LD_INT 4
96370: EQUAL
96371: IFFALSE 96381
// sSpec := true ;
96373: LD_ADDR_EXP 127
96377: PUSH
96378: LD_INT 1
96380: ST_TO_ADDR
// if p3 = 5 then
96381: LD_VAR 0 3
96385: PUSH
96386: LD_INT 5
96388: EQUAL
96389: IFFALSE 96399
// sLevel := true ;
96391: LD_ADDR_EXP 131
96395: PUSH
96396: LD_INT 1
96398: ST_TO_ADDR
// if p3 = 6 then
96399: LD_VAR 0 3
96403: PUSH
96404: LD_INT 6
96406: EQUAL
96407: IFFALSE 96417
// sArmoury := true ;
96409: LD_ADDR_EXP 132
96413: PUSH
96414: LD_INT 1
96416: ST_TO_ADDR
// if p3 = 7 then
96417: LD_VAR 0 3
96421: PUSH
96422: LD_INT 7
96424: EQUAL
96425: IFFALSE 96435
// sRadar := true ;
96427: LD_ADDR_EXP 133
96431: PUSH
96432: LD_INT 1
96434: ST_TO_ADDR
// if p3 = 8 then
96435: LD_VAR 0 3
96439: PUSH
96440: LD_INT 8
96442: EQUAL
96443: IFFALSE 96453
// sBunker := true ;
96445: LD_ADDR_EXP 134
96449: PUSH
96450: LD_INT 1
96452: ST_TO_ADDR
// if p3 = 9 then
96453: LD_VAR 0 3
96457: PUSH
96458: LD_INT 9
96460: EQUAL
96461: IFFALSE 96471
// sHack := true ;
96463: LD_ADDR_EXP 135
96467: PUSH
96468: LD_INT 1
96470: ST_TO_ADDR
// if p3 = 10 then
96471: LD_VAR 0 3
96475: PUSH
96476: LD_INT 10
96478: EQUAL
96479: IFFALSE 96489
// sFire := true ;
96481: LD_ADDR_EXP 136
96485: PUSH
96486: LD_INT 1
96488: ST_TO_ADDR
// if p3 = 11 then
96489: LD_VAR 0 3
96493: PUSH
96494: LD_INT 11
96496: EQUAL
96497: IFFALSE 96507
// sRefresh := true ;
96499: LD_ADDR_EXP 137
96503: PUSH
96504: LD_INT 1
96506: ST_TO_ADDR
// if p3 = 12 then
96507: LD_VAR 0 3
96511: PUSH
96512: LD_INT 12
96514: EQUAL
96515: IFFALSE 96525
// sExp := true ;
96517: LD_ADDR_EXP 138
96521: PUSH
96522: LD_INT 1
96524: ST_TO_ADDR
// if p3 = 13 then
96525: LD_VAR 0 3
96529: PUSH
96530: LD_INT 13
96532: EQUAL
96533: IFFALSE 96543
// sDepot := true ;
96535: LD_ADDR_EXP 139
96539: PUSH
96540: LD_INT 1
96542: ST_TO_ADDR
// if p3 = 14 then
96543: LD_VAR 0 3
96547: PUSH
96548: LD_INT 14
96550: EQUAL
96551: IFFALSE 96561
// sFlag := true ;
96553: LD_ADDR_EXP 140
96557: PUSH
96558: LD_INT 1
96560: ST_TO_ADDR
// if p3 = 15 then
96561: LD_VAR 0 3
96565: PUSH
96566: LD_INT 15
96568: EQUAL
96569: IFFALSE 96579
// sKamikadze := true ;
96571: LD_ADDR_EXP 148
96575: PUSH
96576: LD_INT 1
96578: ST_TO_ADDR
// if p3 = 16 then
96579: LD_VAR 0 3
96583: PUSH
96584: LD_INT 16
96586: EQUAL
96587: IFFALSE 96597
// sTroll := true ;
96589: LD_ADDR_EXP 149
96593: PUSH
96594: LD_INT 1
96596: ST_TO_ADDR
// if p3 = 17 then
96597: LD_VAR 0 3
96601: PUSH
96602: LD_INT 17
96604: EQUAL
96605: IFFALSE 96615
// sSlow := true ;
96607: LD_ADDR_EXP 150
96611: PUSH
96612: LD_INT 1
96614: ST_TO_ADDR
// if p3 = 18 then
96615: LD_VAR 0 3
96619: PUSH
96620: LD_INT 18
96622: EQUAL
96623: IFFALSE 96633
// sLack := true ;
96625: LD_ADDR_EXP 151
96629: PUSH
96630: LD_INT 1
96632: ST_TO_ADDR
// if p3 = 19 then
96633: LD_VAR 0 3
96637: PUSH
96638: LD_INT 19
96640: EQUAL
96641: IFFALSE 96651
// sTank := true ;
96643: LD_ADDR_EXP 153
96647: PUSH
96648: LD_INT 1
96650: ST_TO_ADDR
// if p3 = 20 then
96651: LD_VAR 0 3
96655: PUSH
96656: LD_INT 20
96658: EQUAL
96659: IFFALSE 96669
// sRemote := true ;
96661: LD_ADDR_EXP 154
96665: PUSH
96666: LD_INT 1
96668: ST_TO_ADDR
// if p3 = 21 then
96669: LD_VAR 0 3
96673: PUSH
96674: LD_INT 21
96676: EQUAL
96677: IFFALSE 96687
// sPowell := true ;
96679: LD_ADDR_EXP 155
96683: PUSH
96684: LD_INT 1
96686: ST_TO_ADDR
// if p3 = 22 then
96687: LD_VAR 0 3
96691: PUSH
96692: LD_INT 22
96694: EQUAL
96695: IFFALSE 96705
// sTeleport := true ;
96697: LD_ADDR_EXP 158
96701: PUSH
96702: LD_INT 1
96704: ST_TO_ADDR
// if p3 = 23 then
96705: LD_VAR 0 3
96709: PUSH
96710: LD_INT 23
96712: EQUAL
96713: IFFALSE 96723
// sOilTower := true ;
96715: LD_ADDR_EXP 160
96719: PUSH
96720: LD_INT 1
96722: ST_TO_ADDR
// if p3 = 24 then
96723: LD_VAR 0 3
96727: PUSH
96728: LD_INT 24
96730: EQUAL
96731: IFFALSE 96741
// sShovel := true ;
96733: LD_ADDR_EXP 161
96737: PUSH
96738: LD_INT 1
96740: ST_TO_ADDR
// if p3 = 25 then
96741: LD_VAR 0 3
96745: PUSH
96746: LD_INT 25
96748: EQUAL
96749: IFFALSE 96759
// sSheik := true ;
96751: LD_ADDR_EXP 162
96755: PUSH
96756: LD_INT 1
96758: ST_TO_ADDR
// if p3 = 26 then
96759: LD_VAR 0 3
96763: PUSH
96764: LD_INT 26
96766: EQUAL
96767: IFFALSE 96777
// sEarthquake := true ;
96769: LD_ADDR_EXP 164
96773: PUSH
96774: LD_INT 1
96776: ST_TO_ADDR
// if p3 = 27 then
96777: LD_VAR 0 3
96781: PUSH
96782: LD_INT 27
96784: EQUAL
96785: IFFALSE 96795
// sAI := true ;
96787: LD_ADDR_EXP 165
96791: PUSH
96792: LD_INT 1
96794: ST_TO_ADDR
// if p3 = 28 then
96795: LD_VAR 0 3
96799: PUSH
96800: LD_INT 28
96802: EQUAL
96803: IFFALSE 96813
// sCargo := true ;
96805: LD_ADDR_EXP 168
96809: PUSH
96810: LD_INT 1
96812: ST_TO_ADDR
// if p3 = 29 then
96813: LD_VAR 0 3
96817: PUSH
96818: LD_INT 29
96820: EQUAL
96821: IFFALSE 96831
// sDLaser := true ;
96823: LD_ADDR_EXP 169
96827: PUSH
96828: LD_INT 1
96830: ST_TO_ADDR
// if p3 = 30 then
96831: LD_VAR 0 3
96835: PUSH
96836: LD_INT 30
96838: EQUAL
96839: IFFALSE 96849
// sExchange := true ;
96841: LD_ADDR_EXP 170
96845: PUSH
96846: LD_INT 1
96848: ST_TO_ADDR
// if p3 = 31 then
96849: LD_VAR 0 3
96853: PUSH
96854: LD_INT 31
96856: EQUAL
96857: IFFALSE 96867
// sFac := true ;
96859: LD_ADDR_EXP 171
96863: PUSH
96864: LD_INT 1
96866: ST_TO_ADDR
// if p3 = 32 then
96867: LD_VAR 0 3
96871: PUSH
96872: LD_INT 32
96874: EQUAL
96875: IFFALSE 96885
// sPower := true ;
96877: LD_ADDR_EXP 172
96881: PUSH
96882: LD_INT 1
96884: ST_TO_ADDR
// if p3 = 33 then
96885: LD_VAR 0 3
96889: PUSH
96890: LD_INT 33
96892: EQUAL
96893: IFFALSE 96903
// sRandom := true ;
96895: LD_ADDR_EXP 173
96899: PUSH
96900: LD_INT 1
96902: ST_TO_ADDR
// if p3 = 34 then
96903: LD_VAR 0 3
96907: PUSH
96908: LD_INT 34
96910: EQUAL
96911: IFFALSE 96921
// sShield := true ;
96913: LD_ADDR_EXP 174
96917: PUSH
96918: LD_INT 1
96920: ST_TO_ADDR
// if p3 = 35 then
96921: LD_VAR 0 3
96925: PUSH
96926: LD_INT 35
96928: EQUAL
96929: IFFALSE 96939
// sTime := true ;
96931: LD_ADDR_EXP 175
96935: PUSH
96936: LD_INT 1
96938: ST_TO_ADDR
// if p3 = 36 then
96939: LD_VAR 0 3
96943: PUSH
96944: LD_INT 36
96946: EQUAL
96947: IFFALSE 96957
// sTools := true ;
96949: LD_ADDR_EXP 176
96953: PUSH
96954: LD_INT 1
96956: ST_TO_ADDR
// if p3 = 101 then
96957: LD_VAR 0 3
96961: PUSH
96962: LD_INT 101
96964: EQUAL
96965: IFFALSE 96975
// sSold := true ;
96967: LD_ADDR_EXP 141
96971: PUSH
96972: LD_INT 1
96974: ST_TO_ADDR
// if p3 = 102 then
96975: LD_VAR 0 3
96979: PUSH
96980: LD_INT 102
96982: EQUAL
96983: IFFALSE 96993
// sDiff := true ;
96985: LD_ADDR_EXP 142
96989: PUSH
96990: LD_INT 1
96992: ST_TO_ADDR
// if p3 = 103 then
96993: LD_VAR 0 3
96997: PUSH
96998: LD_INT 103
97000: EQUAL
97001: IFFALSE 97011
// sFog := true ;
97003: LD_ADDR_EXP 145
97007: PUSH
97008: LD_INT 1
97010: ST_TO_ADDR
// if p3 = 104 then
97011: LD_VAR 0 3
97015: PUSH
97016: LD_INT 104
97018: EQUAL
97019: IFFALSE 97029
// sReset := true ;
97021: LD_ADDR_EXP 146
97025: PUSH
97026: LD_INT 1
97028: ST_TO_ADDR
// if p3 = 105 then
97029: LD_VAR 0 3
97033: PUSH
97034: LD_INT 105
97036: EQUAL
97037: IFFALSE 97047
// sSun := true ;
97039: LD_ADDR_EXP 147
97043: PUSH
97044: LD_INT 1
97046: ST_TO_ADDR
// if p3 = 106 then
97047: LD_VAR 0 3
97051: PUSH
97052: LD_INT 106
97054: EQUAL
97055: IFFALSE 97065
// sTiger := true ;
97057: LD_ADDR_EXP 143
97061: PUSH
97062: LD_INT 1
97064: ST_TO_ADDR
// if p3 = 107 then
97065: LD_VAR 0 3
97069: PUSH
97070: LD_INT 107
97072: EQUAL
97073: IFFALSE 97083
// sBomb := true ;
97075: LD_ADDR_EXP 144
97079: PUSH
97080: LD_INT 1
97082: ST_TO_ADDR
// if p3 = 108 then
97083: LD_VAR 0 3
97087: PUSH
97088: LD_INT 108
97090: EQUAL
97091: IFFALSE 97101
// sWound := true ;
97093: LD_ADDR_EXP 152
97097: PUSH
97098: LD_INT 1
97100: ST_TO_ADDR
// if p3 = 109 then
97101: LD_VAR 0 3
97105: PUSH
97106: LD_INT 109
97108: EQUAL
97109: IFFALSE 97119
// sBetray := true ;
97111: LD_ADDR_EXP 156
97115: PUSH
97116: LD_INT 1
97118: ST_TO_ADDR
// if p3 = 110 then
97119: LD_VAR 0 3
97123: PUSH
97124: LD_INT 110
97126: EQUAL
97127: IFFALSE 97137
// sContamin := true ;
97129: LD_ADDR_EXP 157
97133: PUSH
97134: LD_INT 1
97136: ST_TO_ADDR
// if p3 = 111 then
97137: LD_VAR 0 3
97141: PUSH
97142: LD_INT 111
97144: EQUAL
97145: IFFALSE 97155
// sOil := true ;
97147: LD_ADDR_EXP 159
97151: PUSH
97152: LD_INT 1
97154: ST_TO_ADDR
// if p3 = 112 then
97155: LD_VAR 0 3
97159: PUSH
97160: LD_INT 112
97162: EQUAL
97163: IFFALSE 97173
// sStu := true ;
97165: LD_ADDR_EXP 163
97169: PUSH
97170: LD_INT 1
97172: ST_TO_ADDR
// if p3 = 113 then
97173: LD_VAR 0 3
97177: PUSH
97178: LD_INT 113
97180: EQUAL
97181: IFFALSE 97191
// sBazooka := true ;
97183: LD_ADDR_EXP 166
97187: PUSH
97188: LD_INT 1
97190: ST_TO_ADDR
// if p3 = 114 then
97191: LD_VAR 0 3
97195: PUSH
97196: LD_INT 114
97198: EQUAL
97199: IFFALSE 97209
// sMortar := true ;
97201: LD_ADDR_EXP 167
97205: PUSH
97206: LD_INT 1
97208: ST_TO_ADDR
// if p3 = 115 then
97209: LD_VAR 0 3
97213: PUSH
97214: LD_INT 115
97216: EQUAL
97217: IFFALSE 97227
// sRanger := true ;
97219: LD_ADDR_EXP 177
97223: PUSH
97224: LD_INT 1
97226: ST_TO_ADDR
// if p3 = 116 then
97227: LD_VAR 0 3
97231: PUSH
97232: LD_INT 116
97234: EQUAL
97235: IFFALSE 97245
// sComputer := true ;
97237: LD_ADDR_EXP 178
97241: PUSH
97242: LD_INT 1
97244: ST_TO_ADDR
// if p3 = 117 then
97245: LD_VAR 0 3
97249: PUSH
97250: LD_INT 117
97252: EQUAL
97253: IFFALSE 97263
// s30 := true ;
97255: LD_ADDR_EXP 179
97259: PUSH
97260: LD_INT 1
97262: ST_TO_ADDR
// if p3 = 118 then
97263: LD_VAR 0 3
97267: PUSH
97268: LD_INT 118
97270: EQUAL
97271: IFFALSE 97281
// s60 := true ;
97273: LD_ADDR_EXP 180
97277: PUSH
97278: LD_INT 1
97280: ST_TO_ADDR
// end ; if p2 = hack_mode then
97281: LD_VAR 0 2
97285: PUSH
97286: LD_INT 101
97288: EQUAL
97289: IFFALSE 97417
// begin case p3 of 1 :
97291: LD_VAR 0 3
97295: PUSH
97296: LD_INT 1
97298: DOUBLE
97299: EQUAL
97300: IFTRUE 97304
97302: GO 97311
97304: POP
// hHackUnlimitedResources ; 2 :
97305: CALL 109564 0 0
97309: GO 97417
97311: LD_INT 2
97313: DOUBLE
97314: EQUAL
97315: IFTRUE 97319
97317: GO 97326
97319: POP
// hHackSetLevel10 ; 3 :
97320: CALL 109697 0 0
97324: GO 97417
97326: LD_INT 3
97328: DOUBLE
97329: EQUAL
97330: IFTRUE 97334
97332: GO 97341
97334: POP
// hHackSetLevel10YourUnits ; 4 :
97335: CALL 109782 0 0
97339: GO 97417
97341: LD_INT 4
97343: DOUBLE
97344: EQUAL
97345: IFTRUE 97349
97347: GO 97356
97349: POP
// hHackInvincible ; 5 :
97350: CALL 110230 0 0
97354: GO 97417
97356: LD_INT 5
97358: DOUBLE
97359: EQUAL
97360: IFTRUE 97364
97362: GO 97371
97364: POP
// hHackInvisible ; 6 :
97365: CALL 110341 0 0
97369: GO 97417
97371: LD_INT 6
97373: DOUBLE
97374: EQUAL
97375: IFTRUE 97379
97377: GO 97386
97379: POP
// hHackChangeYourSide ; 7 :
97380: CALL 110398 0 0
97384: GO 97417
97386: LD_INT 7
97388: DOUBLE
97389: EQUAL
97390: IFTRUE 97394
97392: GO 97401
97394: POP
// hHackChangeUnitSide ; 8 :
97395: CALL 110440 0 0
97399: GO 97417
97401: LD_INT 8
97403: DOUBLE
97404: EQUAL
97405: IFTRUE 97409
97407: GO 97416
97409: POP
// hHackFog ; end ;
97410: CALL 110541 0 0
97414: GO 97417
97416: POP
// end ; if p2 = game_save_mode then
97417: LD_VAR 0 2
97421: PUSH
97422: LD_INT 102
97424: EQUAL
97425: IFFALSE 97480
// begin if p3 = 1 then
97427: LD_VAR 0 3
97431: PUSH
97432: LD_INT 1
97434: EQUAL
97435: IFFALSE 97447
// globalGameSaveCounter := p4 ;
97437: LD_ADDR_EXP 123
97441: PUSH
97442: LD_VAR 0 4
97446: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
97447: LD_VAR 0 3
97451: PUSH
97452: LD_INT 2
97454: EQUAL
97455: PUSH
97456: LD_EXP 123
97460: AND
97461: IFFALSE 97480
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
97463: LD_STRING setGameSaveCounter(
97465: PUSH
97466: LD_EXP 123
97470: STR
97471: PUSH
97472: LD_STRING )
97474: STR
97475: PPUSH
97476: CALL_OW 559
// end ; end ;
97480: LD_VAR 0 7
97484: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
97485: LD_INT 0
97487: PPUSH
// streamModeActive := false ;
97488: LD_ADDR_EXP 124
97492: PUSH
97493: LD_INT 0
97495: ST_TO_ADDR
// normalCounter := 36 ;
97496: LD_ADDR_EXP 125
97500: PUSH
97501: LD_INT 36
97503: ST_TO_ADDR
// hardcoreCounter := 18 ;
97504: LD_ADDR_EXP 126
97508: PUSH
97509: LD_INT 18
97511: ST_TO_ADDR
// sRocket := false ;
97512: LD_ADDR_EXP 129
97516: PUSH
97517: LD_INT 0
97519: ST_TO_ADDR
// sSpeed := false ;
97520: LD_ADDR_EXP 128
97524: PUSH
97525: LD_INT 0
97527: ST_TO_ADDR
// sEngine := false ;
97528: LD_ADDR_EXP 130
97532: PUSH
97533: LD_INT 0
97535: ST_TO_ADDR
// sSpec := false ;
97536: LD_ADDR_EXP 127
97540: PUSH
97541: LD_INT 0
97543: ST_TO_ADDR
// sLevel := false ;
97544: LD_ADDR_EXP 131
97548: PUSH
97549: LD_INT 0
97551: ST_TO_ADDR
// sArmoury := false ;
97552: LD_ADDR_EXP 132
97556: PUSH
97557: LD_INT 0
97559: ST_TO_ADDR
// sRadar := false ;
97560: LD_ADDR_EXP 133
97564: PUSH
97565: LD_INT 0
97567: ST_TO_ADDR
// sBunker := false ;
97568: LD_ADDR_EXP 134
97572: PUSH
97573: LD_INT 0
97575: ST_TO_ADDR
// sHack := false ;
97576: LD_ADDR_EXP 135
97580: PUSH
97581: LD_INT 0
97583: ST_TO_ADDR
// sFire := false ;
97584: LD_ADDR_EXP 136
97588: PUSH
97589: LD_INT 0
97591: ST_TO_ADDR
// sRefresh := false ;
97592: LD_ADDR_EXP 137
97596: PUSH
97597: LD_INT 0
97599: ST_TO_ADDR
// sExp := false ;
97600: LD_ADDR_EXP 138
97604: PUSH
97605: LD_INT 0
97607: ST_TO_ADDR
// sDepot := false ;
97608: LD_ADDR_EXP 139
97612: PUSH
97613: LD_INT 0
97615: ST_TO_ADDR
// sFlag := false ;
97616: LD_ADDR_EXP 140
97620: PUSH
97621: LD_INT 0
97623: ST_TO_ADDR
// sKamikadze := false ;
97624: LD_ADDR_EXP 148
97628: PUSH
97629: LD_INT 0
97631: ST_TO_ADDR
// sTroll := false ;
97632: LD_ADDR_EXP 149
97636: PUSH
97637: LD_INT 0
97639: ST_TO_ADDR
// sSlow := false ;
97640: LD_ADDR_EXP 150
97644: PUSH
97645: LD_INT 0
97647: ST_TO_ADDR
// sLack := false ;
97648: LD_ADDR_EXP 151
97652: PUSH
97653: LD_INT 0
97655: ST_TO_ADDR
// sTank := false ;
97656: LD_ADDR_EXP 153
97660: PUSH
97661: LD_INT 0
97663: ST_TO_ADDR
// sRemote := false ;
97664: LD_ADDR_EXP 154
97668: PUSH
97669: LD_INT 0
97671: ST_TO_ADDR
// sPowell := false ;
97672: LD_ADDR_EXP 155
97676: PUSH
97677: LD_INT 0
97679: ST_TO_ADDR
// sTeleport := false ;
97680: LD_ADDR_EXP 158
97684: PUSH
97685: LD_INT 0
97687: ST_TO_ADDR
// sOilTower := false ;
97688: LD_ADDR_EXP 160
97692: PUSH
97693: LD_INT 0
97695: ST_TO_ADDR
// sShovel := false ;
97696: LD_ADDR_EXP 161
97700: PUSH
97701: LD_INT 0
97703: ST_TO_ADDR
// sSheik := false ;
97704: LD_ADDR_EXP 162
97708: PUSH
97709: LD_INT 0
97711: ST_TO_ADDR
// sEarthquake := false ;
97712: LD_ADDR_EXP 164
97716: PUSH
97717: LD_INT 0
97719: ST_TO_ADDR
// sAI := false ;
97720: LD_ADDR_EXP 165
97724: PUSH
97725: LD_INT 0
97727: ST_TO_ADDR
// sCargo := false ;
97728: LD_ADDR_EXP 168
97732: PUSH
97733: LD_INT 0
97735: ST_TO_ADDR
// sDLaser := false ;
97736: LD_ADDR_EXP 169
97740: PUSH
97741: LD_INT 0
97743: ST_TO_ADDR
// sExchange := false ;
97744: LD_ADDR_EXP 170
97748: PUSH
97749: LD_INT 0
97751: ST_TO_ADDR
// sFac := false ;
97752: LD_ADDR_EXP 171
97756: PUSH
97757: LD_INT 0
97759: ST_TO_ADDR
// sPower := false ;
97760: LD_ADDR_EXP 172
97764: PUSH
97765: LD_INT 0
97767: ST_TO_ADDR
// sRandom := false ;
97768: LD_ADDR_EXP 173
97772: PUSH
97773: LD_INT 0
97775: ST_TO_ADDR
// sShield := false ;
97776: LD_ADDR_EXP 174
97780: PUSH
97781: LD_INT 0
97783: ST_TO_ADDR
// sTime := false ;
97784: LD_ADDR_EXP 175
97788: PUSH
97789: LD_INT 0
97791: ST_TO_ADDR
// sTools := false ;
97792: LD_ADDR_EXP 176
97796: PUSH
97797: LD_INT 0
97799: ST_TO_ADDR
// sSold := false ;
97800: LD_ADDR_EXP 141
97804: PUSH
97805: LD_INT 0
97807: ST_TO_ADDR
// sDiff := false ;
97808: LD_ADDR_EXP 142
97812: PUSH
97813: LD_INT 0
97815: ST_TO_ADDR
// sFog := false ;
97816: LD_ADDR_EXP 145
97820: PUSH
97821: LD_INT 0
97823: ST_TO_ADDR
// sReset := false ;
97824: LD_ADDR_EXP 146
97828: PUSH
97829: LD_INT 0
97831: ST_TO_ADDR
// sSun := false ;
97832: LD_ADDR_EXP 147
97836: PUSH
97837: LD_INT 0
97839: ST_TO_ADDR
// sTiger := false ;
97840: LD_ADDR_EXP 143
97844: PUSH
97845: LD_INT 0
97847: ST_TO_ADDR
// sBomb := false ;
97848: LD_ADDR_EXP 144
97852: PUSH
97853: LD_INT 0
97855: ST_TO_ADDR
// sWound := false ;
97856: LD_ADDR_EXP 152
97860: PUSH
97861: LD_INT 0
97863: ST_TO_ADDR
// sBetray := false ;
97864: LD_ADDR_EXP 156
97868: PUSH
97869: LD_INT 0
97871: ST_TO_ADDR
// sContamin := false ;
97872: LD_ADDR_EXP 157
97876: PUSH
97877: LD_INT 0
97879: ST_TO_ADDR
// sOil := false ;
97880: LD_ADDR_EXP 159
97884: PUSH
97885: LD_INT 0
97887: ST_TO_ADDR
// sStu := false ;
97888: LD_ADDR_EXP 163
97892: PUSH
97893: LD_INT 0
97895: ST_TO_ADDR
// sBazooka := false ;
97896: LD_ADDR_EXP 166
97900: PUSH
97901: LD_INT 0
97903: ST_TO_ADDR
// sMortar := false ;
97904: LD_ADDR_EXP 167
97908: PUSH
97909: LD_INT 0
97911: ST_TO_ADDR
// sRanger := false ;
97912: LD_ADDR_EXP 177
97916: PUSH
97917: LD_INT 0
97919: ST_TO_ADDR
// sComputer := false ;
97920: LD_ADDR_EXP 178
97924: PUSH
97925: LD_INT 0
97927: ST_TO_ADDR
// s30 := false ;
97928: LD_ADDR_EXP 179
97932: PUSH
97933: LD_INT 0
97935: ST_TO_ADDR
// s60 := false ;
97936: LD_ADDR_EXP 180
97940: PUSH
97941: LD_INT 0
97943: ST_TO_ADDR
// end ;
97944: LD_VAR 0 1
97948: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
97949: LD_INT 0
97951: PPUSH
97952: PPUSH
97953: PPUSH
97954: PPUSH
97955: PPUSH
97956: PPUSH
97957: PPUSH
// result := [ ] ;
97958: LD_ADDR_VAR 0 2
97962: PUSH
97963: EMPTY
97964: ST_TO_ADDR
// if campaign_id = 1 then
97965: LD_OWVAR 69
97969: PUSH
97970: LD_INT 1
97972: EQUAL
97973: IFFALSE 101139
// begin case mission_number of 1 :
97975: LD_OWVAR 70
97979: PUSH
97980: LD_INT 1
97982: DOUBLE
97983: EQUAL
97984: IFTRUE 97988
97986: GO 98064
97988: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
97989: LD_ADDR_VAR 0 2
97993: PUSH
97994: LD_INT 2
97996: PUSH
97997: LD_INT 4
97999: PUSH
98000: LD_INT 11
98002: PUSH
98003: LD_INT 12
98005: PUSH
98006: LD_INT 15
98008: PUSH
98009: LD_INT 16
98011: PUSH
98012: LD_INT 22
98014: PUSH
98015: LD_INT 23
98017: PUSH
98018: LD_INT 26
98020: PUSH
98021: EMPTY
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: LIST
98028: LIST
98029: LIST
98030: LIST
98031: PUSH
98032: LD_INT 101
98034: PUSH
98035: LD_INT 102
98037: PUSH
98038: LD_INT 106
98040: PUSH
98041: LD_INT 116
98043: PUSH
98044: LD_INT 117
98046: PUSH
98047: LD_INT 118
98049: PUSH
98050: EMPTY
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: LIST
98056: LIST
98057: PUSH
98058: EMPTY
98059: LIST
98060: LIST
98061: ST_TO_ADDR
98062: GO 101137
98064: LD_INT 2
98066: DOUBLE
98067: EQUAL
98068: IFTRUE 98072
98070: GO 98156
98072: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
98073: LD_ADDR_VAR 0 2
98077: PUSH
98078: LD_INT 2
98080: PUSH
98081: LD_INT 4
98083: PUSH
98084: LD_INT 11
98086: PUSH
98087: LD_INT 12
98089: PUSH
98090: LD_INT 15
98092: PUSH
98093: LD_INT 16
98095: PUSH
98096: LD_INT 22
98098: PUSH
98099: LD_INT 23
98101: PUSH
98102: LD_INT 26
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: PUSH
98116: LD_INT 101
98118: PUSH
98119: LD_INT 102
98121: PUSH
98122: LD_INT 105
98124: PUSH
98125: LD_INT 106
98127: PUSH
98128: LD_INT 108
98130: PUSH
98131: LD_INT 116
98133: PUSH
98134: LD_INT 117
98136: PUSH
98137: LD_INT 118
98139: PUSH
98140: EMPTY
98141: LIST
98142: LIST
98143: LIST
98144: LIST
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: PUSH
98150: EMPTY
98151: LIST
98152: LIST
98153: ST_TO_ADDR
98154: GO 101137
98156: LD_INT 3
98158: DOUBLE
98159: EQUAL
98160: IFTRUE 98164
98162: GO 98252
98164: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
98165: LD_ADDR_VAR 0 2
98169: PUSH
98170: LD_INT 2
98172: PUSH
98173: LD_INT 4
98175: PUSH
98176: LD_INT 5
98178: PUSH
98179: LD_INT 11
98181: PUSH
98182: LD_INT 12
98184: PUSH
98185: LD_INT 15
98187: PUSH
98188: LD_INT 16
98190: PUSH
98191: LD_INT 22
98193: PUSH
98194: LD_INT 26
98196: PUSH
98197: LD_INT 36
98199: PUSH
98200: EMPTY
98201: LIST
98202: LIST
98203: LIST
98204: LIST
98205: LIST
98206: LIST
98207: LIST
98208: LIST
98209: LIST
98210: LIST
98211: PUSH
98212: LD_INT 101
98214: PUSH
98215: LD_INT 102
98217: PUSH
98218: LD_INT 105
98220: PUSH
98221: LD_INT 106
98223: PUSH
98224: LD_INT 108
98226: PUSH
98227: LD_INT 116
98229: PUSH
98230: LD_INT 117
98232: PUSH
98233: LD_INT 118
98235: PUSH
98236: EMPTY
98237: LIST
98238: LIST
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: ST_TO_ADDR
98250: GO 101137
98252: LD_INT 4
98254: DOUBLE
98255: EQUAL
98256: IFTRUE 98260
98258: GO 98356
98260: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
98261: LD_ADDR_VAR 0 2
98265: PUSH
98266: LD_INT 2
98268: PUSH
98269: LD_INT 4
98271: PUSH
98272: LD_INT 5
98274: PUSH
98275: LD_INT 8
98277: PUSH
98278: LD_INT 11
98280: PUSH
98281: LD_INT 12
98283: PUSH
98284: LD_INT 15
98286: PUSH
98287: LD_INT 16
98289: PUSH
98290: LD_INT 22
98292: PUSH
98293: LD_INT 23
98295: PUSH
98296: LD_INT 26
98298: PUSH
98299: LD_INT 36
98301: PUSH
98302: EMPTY
98303: LIST
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: LIST
98309: LIST
98310: LIST
98311: LIST
98312: LIST
98313: LIST
98314: LIST
98315: PUSH
98316: LD_INT 101
98318: PUSH
98319: LD_INT 102
98321: PUSH
98322: LD_INT 105
98324: PUSH
98325: LD_INT 106
98327: PUSH
98328: LD_INT 108
98330: PUSH
98331: LD_INT 116
98333: PUSH
98334: LD_INT 117
98336: PUSH
98337: LD_INT 118
98339: PUSH
98340: EMPTY
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: PUSH
98350: EMPTY
98351: LIST
98352: LIST
98353: ST_TO_ADDR
98354: GO 101137
98356: LD_INT 5
98358: DOUBLE
98359: EQUAL
98360: IFTRUE 98364
98362: GO 98476
98364: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
98365: LD_ADDR_VAR 0 2
98369: PUSH
98370: LD_INT 2
98372: PUSH
98373: LD_INT 4
98375: PUSH
98376: LD_INT 5
98378: PUSH
98379: LD_INT 6
98381: PUSH
98382: LD_INT 8
98384: PUSH
98385: LD_INT 11
98387: PUSH
98388: LD_INT 12
98390: PUSH
98391: LD_INT 15
98393: PUSH
98394: LD_INT 16
98396: PUSH
98397: LD_INT 22
98399: PUSH
98400: LD_INT 23
98402: PUSH
98403: LD_INT 25
98405: PUSH
98406: LD_INT 26
98408: PUSH
98409: LD_INT 36
98411: PUSH
98412: EMPTY
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: LIST
98427: PUSH
98428: LD_INT 101
98430: PUSH
98431: LD_INT 102
98433: PUSH
98434: LD_INT 105
98436: PUSH
98437: LD_INT 106
98439: PUSH
98440: LD_INT 108
98442: PUSH
98443: LD_INT 109
98445: PUSH
98446: LD_INT 112
98448: PUSH
98449: LD_INT 116
98451: PUSH
98452: LD_INT 117
98454: PUSH
98455: LD_INT 118
98457: PUSH
98458: EMPTY
98459: LIST
98460: LIST
98461: LIST
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: LIST
98467: LIST
98468: LIST
98469: PUSH
98470: EMPTY
98471: LIST
98472: LIST
98473: ST_TO_ADDR
98474: GO 101137
98476: LD_INT 6
98478: DOUBLE
98479: EQUAL
98480: IFTRUE 98484
98482: GO 98616
98484: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
98485: LD_ADDR_VAR 0 2
98489: PUSH
98490: LD_INT 2
98492: PUSH
98493: LD_INT 4
98495: PUSH
98496: LD_INT 5
98498: PUSH
98499: LD_INT 6
98501: PUSH
98502: LD_INT 8
98504: PUSH
98505: LD_INT 11
98507: PUSH
98508: LD_INT 12
98510: PUSH
98511: LD_INT 15
98513: PUSH
98514: LD_INT 16
98516: PUSH
98517: LD_INT 20
98519: PUSH
98520: LD_INT 21
98522: PUSH
98523: LD_INT 22
98525: PUSH
98526: LD_INT 23
98528: PUSH
98529: LD_INT 25
98531: PUSH
98532: LD_INT 26
98534: PUSH
98535: LD_INT 30
98537: PUSH
98538: LD_INT 31
98540: PUSH
98541: LD_INT 32
98543: PUSH
98544: LD_INT 36
98546: PUSH
98547: EMPTY
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: PUSH
98568: LD_INT 101
98570: PUSH
98571: LD_INT 102
98573: PUSH
98574: LD_INT 105
98576: PUSH
98577: LD_INT 106
98579: PUSH
98580: LD_INT 108
98582: PUSH
98583: LD_INT 109
98585: PUSH
98586: LD_INT 112
98588: PUSH
98589: LD_INT 116
98591: PUSH
98592: LD_INT 117
98594: PUSH
98595: LD_INT 118
98597: PUSH
98598: EMPTY
98599: LIST
98600: LIST
98601: LIST
98602: LIST
98603: LIST
98604: LIST
98605: LIST
98606: LIST
98607: LIST
98608: LIST
98609: PUSH
98610: EMPTY
98611: LIST
98612: LIST
98613: ST_TO_ADDR
98614: GO 101137
98616: LD_INT 7
98618: DOUBLE
98619: EQUAL
98620: IFTRUE 98624
98622: GO 98736
98624: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
98625: LD_ADDR_VAR 0 2
98629: PUSH
98630: LD_INT 2
98632: PUSH
98633: LD_INT 4
98635: PUSH
98636: LD_INT 5
98638: PUSH
98639: LD_INT 7
98641: PUSH
98642: LD_INT 11
98644: PUSH
98645: LD_INT 12
98647: PUSH
98648: LD_INT 15
98650: PUSH
98651: LD_INT 16
98653: PUSH
98654: LD_INT 20
98656: PUSH
98657: LD_INT 21
98659: PUSH
98660: LD_INT 22
98662: PUSH
98663: LD_INT 23
98665: PUSH
98666: LD_INT 25
98668: PUSH
98669: LD_INT 26
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: LIST
98676: LIST
98677: LIST
98678: LIST
98679: LIST
98680: LIST
98681: LIST
98682: LIST
98683: LIST
98684: LIST
98685: LIST
98686: LIST
98687: PUSH
98688: LD_INT 101
98690: PUSH
98691: LD_INT 102
98693: PUSH
98694: LD_INT 103
98696: PUSH
98697: LD_INT 105
98699: PUSH
98700: LD_INT 106
98702: PUSH
98703: LD_INT 108
98705: PUSH
98706: LD_INT 112
98708: PUSH
98709: LD_INT 116
98711: PUSH
98712: LD_INT 117
98714: PUSH
98715: LD_INT 118
98717: PUSH
98718: EMPTY
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: PUSH
98730: EMPTY
98731: LIST
98732: LIST
98733: ST_TO_ADDR
98734: GO 101137
98736: LD_INT 8
98738: DOUBLE
98739: EQUAL
98740: IFTRUE 98744
98742: GO 98884
98744: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
98745: LD_ADDR_VAR 0 2
98749: PUSH
98750: LD_INT 2
98752: PUSH
98753: LD_INT 4
98755: PUSH
98756: LD_INT 5
98758: PUSH
98759: LD_INT 6
98761: PUSH
98762: LD_INT 7
98764: PUSH
98765: LD_INT 8
98767: PUSH
98768: LD_INT 11
98770: PUSH
98771: LD_INT 12
98773: PUSH
98774: LD_INT 15
98776: PUSH
98777: LD_INT 16
98779: PUSH
98780: LD_INT 20
98782: PUSH
98783: LD_INT 21
98785: PUSH
98786: LD_INT 22
98788: PUSH
98789: LD_INT 23
98791: PUSH
98792: LD_INT 25
98794: PUSH
98795: LD_INT 26
98797: PUSH
98798: LD_INT 30
98800: PUSH
98801: LD_INT 31
98803: PUSH
98804: LD_INT 32
98806: PUSH
98807: LD_INT 36
98809: PUSH
98810: EMPTY
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: LIST
98830: LIST
98831: PUSH
98832: LD_INT 101
98834: PUSH
98835: LD_INT 102
98837: PUSH
98838: LD_INT 103
98840: PUSH
98841: LD_INT 105
98843: PUSH
98844: LD_INT 106
98846: PUSH
98847: LD_INT 108
98849: PUSH
98850: LD_INT 109
98852: PUSH
98853: LD_INT 112
98855: PUSH
98856: LD_INT 116
98858: PUSH
98859: LD_INT 117
98861: PUSH
98862: LD_INT 118
98864: PUSH
98865: EMPTY
98866: LIST
98867: LIST
98868: LIST
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: LIST
98874: LIST
98875: LIST
98876: LIST
98877: PUSH
98878: EMPTY
98879: LIST
98880: LIST
98881: ST_TO_ADDR
98882: GO 101137
98884: LD_INT 9
98886: DOUBLE
98887: EQUAL
98888: IFTRUE 98892
98890: GO 99040
98892: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
98893: LD_ADDR_VAR 0 2
98897: PUSH
98898: LD_INT 2
98900: PUSH
98901: LD_INT 4
98903: PUSH
98904: LD_INT 5
98906: PUSH
98907: LD_INT 6
98909: PUSH
98910: LD_INT 7
98912: PUSH
98913: LD_INT 8
98915: PUSH
98916: LD_INT 11
98918: PUSH
98919: LD_INT 12
98921: PUSH
98922: LD_INT 15
98924: PUSH
98925: LD_INT 16
98927: PUSH
98928: LD_INT 20
98930: PUSH
98931: LD_INT 21
98933: PUSH
98934: LD_INT 22
98936: PUSH
98937: LD_INT 23
98939: PUSH
98940: LD_INT 25
98942: PUSH
98943: LD_INT 26
98945: PUSH
98946: LD_INT 28
98948: PUSH
98949: LD_INT 30
98951: PUSH
98952: LD_INT 31
98954: PUSH
98955: LD_INT 32
98957: PUSH
98958: LD_INT 36
98960: PUSH
98961: EMPTY
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: PUSH
98984: LD_INT 101
98986: PUSH
98987: LD_INT 102
98989: PUSH
98990: LD_INT 103
98992: PUSH
98993: LD_INT 105
98995: PUSH
98996: LD_INT 106
98998: PUSH
98999: LD_INT 108
99001: PUSH
99002: LD_INT 109
99004: PUSH
99005: LD_INT 112
99007: PUSH
99008: LD_INT 114
99010: PUSH
99011: LD_INT 116
99013: PUSH
99014: LD_INT 117
99016: PUSH
99017: LD_INT 118
99019: PUSH
99020: EMPTY
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: LIST
99026: LIST
99027: LIST
99028: LIST
99029: LIST
99030: LIST
99031: LIST
99032: LIST
99033: PUSH
99034: EMPTY
99035: LIST
99036: LIST
99037: ST_TO_ADDR
99038: GO 101137
99040: LD_INT 10
99042: DOUBLE
99043: EQUAL
99044: IFTRUE 99048
99046: GO 99244
99048: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
99049: LD_ADDR_VAR 0 2
99053: PUSH
99054: LD_INT 2
99056: PUSH
99057: LD_INT 4
99059: PUSH
99060: LD_INT 5
99062: PUSH
99063: LD_INT 6
99065: PUSH
99066: LD_INT 7
99068: PUSH
99069: LD_INT 8
99071: PUSH
99072: LD_INT 9
99074: PUSH
99075: LD_INT 10
99077: PUSH
99078: LD_INT 11
99080: PUSH
99081: LD_INT 12
99083: PUSH
99084: LD_INT 13
99086: PUSH
99087: LD_INT 14
99089: PUSH
99090: LD_INT 15
99092: PUSH
99093: LD_INT 16
99095: PUSH
99096: LD_INT 17
99098: PUSH
99099: LD_INT 18
99101: PUSH
99102: LD_INT 19
99104: PUSH
99105: LD_INT 20
99107: PUSH
99108: LD_INT 21
99110: PUSH
99111: LD_INT 22
99113: PUSH
99114: LD_INT 23
99116: PUSH
99117: LD_INT 24
99119: PUSH
99120: LD_INT 25
99122: PUSH
99123: LD_INT 26
99125: PUSH
99126: LD_INT 28
99128: PUSH
99129: LD_INT 30
99131: PUSH
99132: LD_INT 31
99134: PUSH
99135: LD_INT 32
99137: PUSH
99138: LD_INT 36
99140: PUSH
99141: EMPTY
99142: LIST
99143: LIST
99144: LIST
99145: LIST
99146: LIST
99147: LIST
99148: LIST
99149: LIST
99150: LIST
99151: LIST
99152: LIST
99153: LIST
99154: LIST
99155: LIST
99156: LIST
99157: LIST
99158: LIST
99159: LIST
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: PUSH
99172: LD_INT 101
99174: PUSH
99175: LD_INT 102
99177: PUSH
99178: LD_INT 103
99180: PUSH
99181: LD_INT 104
99183: PUSH
99184: LD_INT 105
99186: PUSH
99187: LD_INT 106
99189: PUSH
99190: LD_INT 107
99192: PUSH
99193: LD_INT 108
99195: PUSH
99196: LD_INT 109
99198: PUSH
99199: LD_INT 110
99201: PUSH
99202: LD_INT 111
99204: PUSH
99205: LD_INT 112
99207: PUSH
99208: LD_INT 114
99210: PUSH
99211: LD_INT 116
99213: PUSH
99214: LD_INT 117
99216: PUSH
99217: LD_INT 118
99219: PUSH
99220: EMPTY
99221: LIST
99222: LIST
99223: LIST
99224: LIST
99225: LIST
99226: LIST
99227: LIST
99228: LIST
99229: LIST
99230: LIST
99231: LIST
99232: LIST
99233: LIST
99234: LIST
99235: LIST
99236: LIST
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: ST_TO_ADDR
99242: GO 101137
99244: LD_INT 11
99246: DOUBLE
99247: EQUAL
99248: IFTRUE 99252
99250: GO 99456
99252: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
99253: LD_ADDR_VAR 0 2
99257: PUSH
99258: LD_INT 2
99260: PUSH
99261: LD_INT 3
99263: PUSH
99264: LD_INT 4
99266: PUSH
99267: LD_INT 5
99269: PUSH
99270: LD_INT 6
99272: PUSH
99273: LD_INT 7
99275: PUSH
99276: LD_INT 8
99278: PUSH
99279: LD_INT 9
99281: PUSH
99282: LD_INT 10
99284: PUSH
99285: LD_INT 11
99287: PUSH
99288: LD_INT 12
99290: PUSH
99291: LD_INT 13
99293: PUSH
99294: LD_INT 14
99296: PUSH
99297: LD_INT 15
99299: PUSH
99300: LD_INT 16
99302: PUSH
99303: LD_INT 17
99305: PUSH
99306: LD_INT 18
99308: PUSH
99309: LD_INT 19
99311: PUSH
99312: LD_INT 20
99314: PUSH
99315: LD_INT 21
99317: PUSH
99318: LD_INT 22
99320: PUSH
99321: LD_INT 23
99323: PUSH
99324: LD_INT 24
99326: PUSH
99327: LD_INT 25
99329: PUSH
99330: LD_INT 26
99332: PUSH
99333: LD_INT 28
99335: PUSH
99336: LD_INT 30
99338: PUSH
99339: LD_INT 31
99341: PUSH
99342: LD_INT 32
99344: PUSH
99345: LD_INT 34
99347: PUSH
99348: LD_INT 36
99350: PUSH
99351: EMPTY
99352: LIST
99353: LIST
99354: LIST
99355: LIST
99356: LIST
99357: LIST
99358: LIST
99359: LIST
99360: LIST
99361: LIST
99362: LIST
99363: LIST
99364: LIST
99365: LIST
99366: LIST
99367: LIST
99368: LIST
99369: LIST
99370: LIST
99371: LIST
99372: LIST
99373: LIST
99374: LIST
99375: LIST
99376: LIST
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: LIST
99383: PUSH
99384: LD_INT 101
99386: PUSH
99387: LD_INT 102
99389: PUSH
99390: LD_INT 103
99392: PUSH
99393: LD_INT 104
99395: PUSH
99396: LD_INT 105
99398: PUSH
99399: LD_INT 106
99401: PUSH
99402: LD_INT 107
99404: PUSH
99405: LD_INT 108
99407: PUSH
99408: LD_INT 109
99410: PUSH
99411: LD_INT 110
99413: PUSH
99414: LD_INT 111
99416: PUSH
99417: LD_INT 112
99419: PUSH
99420: LD_INT 114
99422: PUSH
99423: LD_INT 116
99425: PUSH
99426: LD_INT 117
99428: PUSH
99429: LD_INT 118
99431: PUSH
99432: EMPTY
99433: LIST
99434: LIST
99435: LIST
99436: LIST
99437: LIST
99438: LIST
99439: LIST
99440: LIST
99441: LIST
99442: LIST
99443: LIST
99444: LIST
99445: LIST
99446: LIST
99447: LIST
99448: LIST
99449: PUSH
99450: EMPTY
99451: LIST
99452: LIST
99453: ST_TO_ADDR
99454: GO 101137
99456: LD_INT 12
99458: DOUBLE
99459: EQUAL
99460: IFTRUE 99464
99462: GO 99684
99464: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
99465: LD_ADDR_VAR 0 2
99469: PUSH
99470: LD_INT 1
99472: PUSH
99473: LD_INT 2
99475: PUSH
99476: LD_INT 3
99478: PUSH
99479: LD_INT 4
99481: PUSH
99482: LD_INT 5
99484: PUSH
99485: LD_INT 6
99487: PUSH
99488: LD_INT 7
99490: PUSH
99491: LD_INT 8
99493: PUSH
99494: LD_INT 9
99496: PUSH
99497: LD_INT 10
99499: PUSH
99500: LD_INT 11
99502: PUSH
99503: LD_INT 12
99505: PUSH
99506: LD_INT 13
99508: PUSH
99509: LD_INT 14
99511: PUSH
99512: LD_INT 15
99514: PUSH
99515: LD_INT 16
99517: PUSH
99518: LD_INT 17
99520: PUSH
99521: LD_INT 18
99523: PUSH
99524: LD_INT 19
99526: PUSH
99527: LD_INT 20
99529: PUSH
99530: LD_INT 21
99532: PUSH
99533: LD_INT 22
99535: PUSH
99536: LD_INT 23
99538: PUSH
99539: LD_INT 24
99541: PUSH
99542: LD_INT 25
99544: PUSH
99545: LD_INT 26
99547: PUSH
99548: LD_INT 27
99550: PUSH
99551: LD_INT 28
99553: PUSH
99554: LD_INT 30
99556: PUSH
99557: LD_INT 31
99559: PUSH
99560: LD_INT 32
99562: PUSH
99563: LD_INT 33
99565: PUSH
99566: LD_INT 34
99568: PUSH
99569: LD_INT 36
99571: PUSH
99572: EMPTY
99573: LIST
99574: LIST
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: LIST
99583: LIST
99584: LIST
99585: LIST
99586: LIST
99587: LIST
99588: LIST
99589: LIST
99590: LIST
99591: LIST
99592: LIST
99593: LIST
99594: LIST
99595: LIST
99596: LIST
99597: LIST
99598: LIST
99599: LIST
99600: LIST
99601: LIST
99602: LIST
99603: LIST
99604: LIST
99605: LIST
99606: LIST
99607: PUSH
99608: LD_INT 101
99610: PUSH
99611: LD_INT 102
99613: PUSH
99614: LD_INT 103
99616: PUSH
99617: LD_INT 104
99619: PUSH
99620: LD_INT 105
99622: PUSH
99623: LD_INT 106
99625: PUSH
99626: LD_INT 107
99628: PUSH
99629: LD_INT 108
99631: PUSH
99632: LD_INT 109
99634: PUSH
99635: LD_INT 110
99637: PUSH
99638: LD_INT 111
99640: PUSH
99641: LD_INT 112
99643: PUSH
99644: LD_INT 113
99646: PUSH
99647: LD_INT 114
99649: PUSH
99650: LD_INT 116
99652: PUSH
99653: LD_INT 117
99655: PUSH
99656: LD_INT 118
99658: PUSH
99659: EMPTY
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: LIST
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: LIST
99677: PUSH
99678: EMPTY
99679: LIST
99680: LIST
99681: ST_TO_ADDR
99682: GO 101137
99684: LD_INT 13
99686: DOUBLE
99687: EQUAL
99688: IFTRUE 99692
99690: GO 99900
99692: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
99693: LD_ADDR_VAR 0 2
99697: PUSH
99698: LD_INT 1
99700: PUSH
99701: LD_INT 2
99703: PUSH
99704: LD_INT 3
99706: PUSH
99707: LD_INT 4
99709: PUSH
99710: LD_INT 5
99712: PUSH
99713: LD_INT 8
99715: PUSH
99716: LD_INT 9
99718: PUSH
99719: LD_INT 10
99721: PUSH
99722: LD_INT 11
99724: PUSH
99725: LD_INT 12
99727: PUSH
99728: LD_INT 14
99730: PUSH
99731: LD_INT 15
99733: PUSH
99734: LD_INT 16
99736: PUSH
99737: LD_INT 17
99739: PUSH
99740: LD_INT 18
99742: PUSH
99743: LD_INT 19
99745: PUSH
99746: LD_INT 20
99748: PUSH
99749: LD_INT 21
99751: PUSH
99752: LD_INT 22
99754: PUSH
99755: LD_INT 23
99757: PUSH
99758: LD_INT 24
99760: PUSH
99761: LD_INT 25
99763: PUSH
99764: LD_INT 26
99766: PUSH
99767: LD_INT 27
99769: PUSH
99770: LD_INT 28
99772: PUSH
99773: LD_INT 30
99775: PUSH
99776: LD_INT 31
99778: PUSH
99779: LD_INT 32
99781: PUSH
99782: LD_INT 33
99784: PUSH
99785: LD_INT 34
99787: PUSH
99788: LD_INT 36
99790: PUSH
99791: EMPTY
99792: LIST
99793: LIST
99794: LIST
99795: LIST
99796: LIST
99797: LIST
99798: LIST
99799: LIST
99800: LIST
99801: LIST
99802: LIST
99803: LIST
99804: LIST
99805: LIST
99806: LIST
99807: LIST
99808: LIST
99809: LIST
99810: LIST
99811: LIST
99812: LIST
99813: LIST
99814: LIST
99815: LIST
99816: LIST
99817: LIST
99818: LIST
99819: LIST
99820: LIST
99821: LIST
99822: LIST
99823: PUSH
99824: LD_INT 101
99826: PUSH
99827: LD_INT 102
99829: PUSH
99830: LD_INT 103
99832: PUSH
99833: LD_INT 104
99835: PUSH
99836: LD_INT 105
99838: PUSH
99839: LD_INT 106
99841: PUSH
99842: LD_INT 107
99844: PUSH
99845: LD_INT 108
99847: PUSH
99848: LD_INT 109
99850: PUSH
99851: LD_INT 110
99853: PUSH
99854: LD_INT 111
99856: PUSH
99857: LD_INT 112
99859: PUSH
99860: LD_INT 113
99862: PUSH
99863: LD_INT 114
99865: PUSH
99866: LD_INT 116
99868: PUSH
99869: LD_INT 117
99871: PUSH
99872: LD_INT 118
99874: PUSH
99875: EMPTY
99876: LIST
99877: LIST
99878: LIST
99879: LIST
99880: LIST
99881: LIST
99882: LIST
99883: LIST
99884: LIST
99885: LIST
99886: LIST
99887: LIST
99888: LIST
99889: LIST
99890: LIST
99891: LIST
99892: LIST
99893: PUSH
99894: EMPTY
99895: LIST
99896: LIST
99897: ST_TO_ADDR
99898: GO 101137
99900: LD_INT 14
99902: DOUBLE
99903: EQUAL
99904: IFTRUE 99908
99906: GO 100132
99908: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
99909: LD_ADDR_VAR 0 2
99913: PUSH
99914: LD_INT 1
99916: PUSH
99917: LD_INT 2
99919: PUSH
99920: LD_INT 3
99922: PUSH
99923: LD_INT 4
99925: PUSH
99926: LD_INT 5
99928: PUSH
99929: LD_INT 6
99931: PUSH
99932: LD_INT 7
99934: PUSH
99935: LD_INT 8
99937: PUSH
99938: LD_INT 9
99940: PUSH
99941: LD_INT 10
99943: PUSH
99944: LD_INT 11
99946: PUSH
99947: LD_INT 12
99949: PUSH
99950: LD_INT 13
99952: PUSH
99953: LD_INT 14
99955: PUSH
99956: LD_INT 15
99958: PUSH
99959: LD_INT 16
99961: PUSH
99962: LD_INT 17
99964: PUSH
99965: LD_INT 18
99967: PUSH
99968: LD_INT 19
99970: PUSH
99971: LD_INT 20
99973: PUSH
99974: LD_INT 21
99976: PUSH
99977: LD_INT 22
99979: PUSH
99980: LD_INT 23
99982: PUSH
99983: LD_INT 24
99985: PUSH
99986: LD_INT 25
99988: PUSH
99989: LD_INT 26
99991: PUSH
99992: LD_INT 27
99994: PUSH
99995: LD_INT 28
99997: PUSH
99998: LD_INT 29
100000: PUSH
100001: LD_INT 30
100003: PUSH
100004: LD_INT 31
100006: PUSH
100007: LD_INT 32
100009: PUSH
100010: LD_INT 33
100012: PUSH
100013: LD_INT 34
100015: PUSH
100016: LD_INT 36
100018: PUSH
100019: EMPTY
100020: LIST
100021: LIST
100022: LIST
100023: LIST
100024: LIST
100025: LIST
100026: LIST
100027: LIST
100028: LIST
100029: LIST
100030: LIST
100031: LIST
100032: LIST
100033: LIST
100034: LIST
100035: LIST
100036: LIST
100037: LIST
100038: LIST
100039: LIST
100040: LIST
100041: LIST
100042: LIST
100043: LIST
100044: LIST
100045: LIST
100046: LIST
100047: LIST
100048: LIST
100049: LIST
100050: LIST
100051: LIST
100052: LIST
100053: LIST
100054: LIST
100055: PUSH
100056: LD_INT 101
100058: PUSH
100059: LD_INT 102
100061: PUSH
100062: LD_INT 103
100064: PUSH
100065: LD_INT 104
100067: PUSH
100068: LD_INT 105
100070: PUSH
100071: LD_INT 106
100073: PUSH
100074: LD_INT 107
100076: PUSH
100077: LD_INT 108
100079: PUSH
100080: LD_INT 109
100082: PUSH
100083: LD_INT 110
100085: PUSH
100086: LD_INT 111
100088: PUSH
100089: LD_INT 112
100091: PUSH
100092: LD_INT 113
100094: PUSH
100095: LD_INT 114
100097: PUSH
100098: LD_INT 116
100100: PUSH
100101: LD_INT 117
100103: PUSH
100104: LD_INT 118
100106: PUSH
100107: EMPTY
100108: LIST
100109: LIST
100110: LIST
100111: LIST
100112: LIST
100113: LIST
100114: LIST
100115: LIST
100116: LIST
100117: LIST
100118: LIST
100119: LIST
100120: LIST
100121: LIST
100122: LIST
100123: LIST
100124: LIST
100125: PUSH
100126: EMPTY
100127: LIST
100128: LIST
100129: ST_TO_ADDR
100130: GO 101137
100132: LD_INT 15
100134: DOUBLE
100135: EQUAL
100136: IFTRUE 100140
100138: GO 100364
100140: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
100141: LD_ADDR_VAR 0 2
100145: PUSH
100146: LD_INT 1
100148: PUSH
100149: LD_INT 2
100151: PUSH
100152: LD_INT 3
100154: PUSH
100155: LD_INT 4
100157: PUSH
100158: LD_INT 5
100160: PUSH
100161: LD_INT 6
100163: PUSH
100164: LD_INT 7
100166: PUSH
100167: LD_INT 8
100169: PUSH
100170: LD_INT 9
100172: PUSH
100173: LD_INT 10
100175: PUSH
100176: LD_INT 11
100178: PUSH
100179: LD_INT 12
100181: PUSH
100182: LD_INT 13
100184: PUSH
100185: LD_INT 14
100187: PUSH
100188: LD_INT 15
100190: PUSH
100191: LD_INT 16
100193: PUSH
100194: LD_INT 17
100196: PUSH
100197: LD_INT 18
100199: PUSH
100200: LD_INT 19
100202: PUSH
100203: LD_INT 20
100205: PUSH
100206: LD_INT 21
100208: PUSH
100209: LD_INT 22
100211: PUSH
100212: LD_INT 23
100214: PUSH
100215: LD_INT 24
100217: PUSH
100218: LD_INT 25
100220: PUSH
100221: LD_INT 26
100223: PUSH
100224: LD_INT 27
100226: PUSH
100227: LD_INT 28
100229: PUSH
100230: LD_INT 29
100232: PUSH
100233: LD_INT 30
100235: PUSH
100236: LD_INT 31
100238: PUSH
100239: LD_INT 32
100241: PUSH
100242: LD_INT 33
100244: PUSH
100245: LD_INT 34
100247: PUSH
100248: LD_INT 36
100250: PUSH
100251: EMPTY
100252: LIST
100253: LIST
100254: LIST
100255: LIST
100256: LIST
100257: LIST
100258: LIST
100259: LIST
100260: LIST
100261: LIST
100262: LIST
100263: LIST
100264: LIST
100265: LIST
100266: LIST
100267: LIST
100268: LIST
100269: LIST
100270: LIST
100271: LIST
100272: LIST
100273: LIST
100274: LIST
100275: LIST
100276: LIST
100277: LIST
100278: LIST
100279: LIST
100280: LIST
100281: LIST
100282: LIST
100283: LIST
100284: LIST
100285: LIST
100286: LIST
100287: PUSH
100288: LD_INT 101
100290: PUSH
100291: LD_INT 102
100293: PUSH
100294: LD_INT 103
100296: PUSH
100297: LD_INT 104
100299: PUSH
100300: LD_INT 105
100302: PUSH
100303: LD_INT 106
100305: PUSH
100306: LD_INT 107
100308: PUSH
100309: LD_INT 108
100311: PUSH
100312: LD_INT 109
100314: PUSH
100315: LD_INT 110
100317: PUSH
100318: LD_INT 111
100320: PUSH
100321: LD_INT 112
100323: PUSH
100324: LD_INT 113
100326: PUSH
100327: LD_INT 114
100329: PUSH
100330: LD_INT 116
100332: PUSH
100333: LD_INT 117
100335: PUSH
100336: LD_INT 118
100338: PUSH
100339: EMPTY
100340: LIST
100341: LIST
100342: LIST
100343: LIST
100344: LIST
100345: LIST
100346: LIST
100347: LIST
100348: LIST
100349: LIST
100350: LIST
100351: LIST
100352: LIST
100353: LIST
100354: LIST
100355: LIST
100356: LIST
100357: PUSH
100358: EMPTY
100359: LIST
100360: LIST
100361: ST_TO_ADDR
100362: GO 101137
100364: LD_INT 16
100366: DOUBLE
100367: EQUAL
100368: IFTRUE 100372
100370: GO 100508
100372: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
100373: LD_ADDR_VAR 0 2
100377: PUSH
100378: LD_INT 2
100380: PUSH
100381: LD_INT 4
100383: PUSH
100384: LD_INT 5
100386: PUSH
100387: LD_INT 7
100389: PUSH
100390: LD_INT 11
100392: PUSH
100393: LD_INT 12
100395: PUSH
100396: LD_INT 15
100398: PUSH
100399: LD_INT 16
100401: PUSH
100402: LD_INT 20
100404: PUSH
100405: LD_INT 21
100407: PUSH
100408: LD_INT 22
100410: PUSH
100411: LD_INT 23
100413: PUSH
100414: LD_INT 25
100416: PUSH
100417: LD_INT 26
100419: PUSH
100420: LD_INT 30
100422: PUSH
100423: LD_INT 31
100425: PUSH
100426: LD_INT 32
100428: PUSH
100429: LD_INT 33
100431: PUSH
100432: LD_INT 34
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: LIST
100439: LIST
100440: LIST
100441: LIST
100442: LIST
100443: LIST
100444: LIST
100445: LIST
100446: LIST
100447: LIST
100448: LIST
100449: LIST
100450: LIST
100451: LIST
100452: LIST
100453: LIST
100454: LIST
100455: PUSH
100456: LD_INT 101
100458: PUSH
100459: LD_INT 102
100461: PUSH
100462: LD_INT 103
100464: PUSH
100465: LD_INT 106
100467: PUSH
100468: LD_INT 108
100470: PUSH
100471: LD_INT 112
100473: PUSH
100474: LD_INT 113
100476: PUSH
100477: LD_INT 114
100479: PUSH
100480: LD_INT 116
100482: PUSH
100483: LD_INT 117
100485: PUSH
100486: LD_INT 118
100488: PUSH
100489: EMPTY
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: PUSH
100502: EMPTY
100503: LIST
100504: LIST
100505: ST_TO_ADDR
100506: GO 101137
100508: LD_INT 17
100510: DOUBLE
100511: EQUAL
100512: IFTRUE 100516
100514: GO 100740
100516: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
100517: LD_ADDR_VAR 0 2
100521: PUSH
100522: LD_INT 1
100524: PUSH
100525: LD_INT 2
100527: PUSH
100528: LD_INT 3
100530: PUSH
100531: LD_INT 4
100533: PUSH
100534: LD_INT 5
100536: PUSH
100537: LD_INT 6
100539: PUSH
100540: LD_INT 7
100542: PUSH
100543: LD_INT 8
100545: PUSH
100546: LD_INT 9
100548: PUSH
100549: LD_INT 10
100551: PUSH
100552: LD_INT 11
100554: PUSH
100555: LD_INT 12
100557: PUSH
100558: LD_INT 13
100560: PUSH
100561: LD_INT 14
100563: PUSH
100564: LD_INT 15
100566: PUSH
100567: LD_INT 16
100569: PUSH
100570: LD_INT 17
100572: PUSH
100573: LD_INT 18
100575: PUSH
100576: LD_INT 19
100578: PUSH
100579: LD_INT 20
100581: PUSH
100582: LD_INT 21
100584: PUSH
100585: LD_INT 22
100587: PUSH
100588: LD_INT 23
100590: PUSH
100591: LD_INT 24
100593: PUSH
100594: LD_INT 25
100596: PUSH
100597: LD_INT 26
100599: PUSH
100600: LD_INT 27
100602: PUSH
100603: LD_INT 28
100605: PUSH
100606: LD_INT 29
100608: PUSH
100609: LD_INT 30
100611: PUSH
100612: LD_INT 31
100614: PUSH
100615: LD_INT 32
100617: PUSH
100618: LD_INT 33
100620: PUSH
100621: LD_INT 34
100623: PUSH
100624: LD_INT 36
100626: PUSH
100627: EMPTY
100628: LIST
100629: LIST
100630: LIST
100631: LIST
100632: LIST
100633: LIST
100634: LIST
100635: LIST
100636: LIST
100637: LIST
100638: LIST
100639: LIST
100640: LIST
100641: LIST
100642: LIST
100643: LIST
100644: LIST
100645: LIST
100646: LIST
100647: LIST
100648: LIST
100649: LIST
100650: LIST
100651: LIST
100652: LIST
100653: LIST
100654: LIST
100655: LIST
100656: LIST
100657: LIST
100658: LIST
100659: LIST
100660: LIST
100661: LIST
100662: LIST
100663: PUSH
100664: LD_INT 101
100666: PUSH
100667: LD_INT 102
100669: PUSH
100670: LD_INT 103
100672: PUSH
100673: LD_INT 104
100675: PUSH
100676: LD_INT 105
100678: PUSH
100679: LD_INT 106
100681: PUSH
100682: LD_INT 107
100684: PUSH
100685: LD_INT 108
100687: PUSH
100688: LD_INT 109
100690: PUSH
100691: LD_INT 110
100693: PUSH
100694: LD_INT 111
100696: PUSH
100697: LD_INT 112
100699: PUSH
100700: LD_INT 113
100702: PUSH
100703: LD_INT 114
100705: PUSH
100706: LD_INT 116
100708: PUSH
100709: LD_INT 117
100711: PUSH
100712: LD_INT 118
100714: PUSH
100715: EMPTY
100716: LIST
100717: LIST
100718: LIST
100719: LIST
100720: LIST
100721: LIST
100722: LIST
100723: LIST
100724: LIST
100725: LIST
100726: LIST
100727: LIST
100728: LIST
100729: LIST
100730: LIST
100731: LIST
100732: LIST
100733: PUSH
100734: EMPTY
100735: LIST
100736: LIST
100737: ST_TO_ADDR
100738: GO 101137
100740: LD_INT 18
100742: DOUBLE
100743: EQUAL
100744: IFTRUE 100748
100746: GO 100896
100748: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
100749: LD_ADDR_VAR 0 2
100753: PUSH
100754: LD_INT 2
100756: PUSH
100757: LD_INT 4
100759: PUSH
100760: LD_INT 5
100762: PUSH
100763: LD_INT 7
100765: PUSH
100766: LD_INT 11
100768: PUSH
100769: LD_INT 12
100771: PUSH
100772: LD_INT 15
100774: PUSH
100775: LD_INT 16
100777: PUSH
100778: LD_INT 20
100780: PUSH
100781: LD_INT 21
100783: PUSH
100784: LD_INT 22
100786: PUSH
100787: LD_INT 23
100789: PUSH
100790: LD_INT 25
100792: PUSH
100793: LD_INT 26
100795: PUSH
100796: LD_INT 30
100798: PUSH
100799: LD_INT 31
100801: PUSH
100802: LD_INT 32
100804: PUSH
100805: LD_INT 33
100807: PUSH
100808: LD_INT 34
100810: PUSH
100811: LD_INT 35
100813: PUSH
100814: LD_INT 36
100816: PUSH
100817: EMPTY
100818: LIST
100819: LIST
100820: LIST
100821: LIST
100822: LIST
100823: LIST
100824: LIST
100825: LIST
100826: LIST
100827: LIST
100828: LIST
100829: LIST
100830: LIST
100831: LIST
100832: LIST
100833: LIST
100834: LIST
100835: LIST
100836: LIST
100837: LIST
100838: LIST
100839: PUSH
100840: LD_INT 101
100842: PUSH
100843: LD_INT 102
100845: PUSH
100846: LD_INT 103
100848: PUSH
100849: LD_INT 106
100851: PUSH
100852: LD_INT 108
100854: PUSH
100855: LD_INT 112
100857: PUSH
100858: LD_INT 113
100860: PUSH
100861: LD_INT 114
100863: PUSH
100864: LD_INT 115
100866: PUSH
100867: LD_INT 116
100869: PUSH
100870: LD_INT 117
100872: PUSH
100873: LD_INT 118
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: LIST
100880: LIST
100881: LIST
100882: LIST
100883: LIST
100884: LIST
100885: LIST
100886: LIST
100887: LIST
100888: LIST
100889: PUSH
100890: EMPTY
100891: LIST
100892: LIST
100893: ST_TO_ADDR
100894: GO 101137
100896: LD_INT 19
100898: DOUBLE
100899: EQUAL
100900: IFTRUE 100904
100902: GO 101136
100904: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
100905: LD_ADDR_VAR 0 2
100909: PUSH
100910: LD_INT 1
100912: PUSH
100913: LD_INT 2
100915: PUSH
100916: LD_INT 3
100918: PUSH
100919: LD_INT 4
100921: PUSH
100922: LD_INT 5
100924: PUSH
100925: LD_INT 6
100927: PUSH
100928: LD_INT 7
100930: PUSH
100931: LD_INT 8
100933: PUSH
100934: LD_INT 9
100936: PUSH
100937: LD_INT 10
100939: PUSH
100940: LD_INT 11
100942: PUSH
100943: LD_INT 12
100945: PUSH
100946: LD_INT 13
100948: PUSH
100949: LD_INT 14
100951: PUSH
100952: LD_INT 15
100954: PUSH
100955: LD_INT 16
100957: PUSH
100958: LD_INT 17
100960: PUSH
100961: LD_INT 18
100963: PUSH
100964: LD_INT 19
100966: PUSH
100967: LD_INT 20
100969: PUSH
100970: LD_INT 21
100972: PUSH
100973: LD_INT 22
100975: PUSH
100976: LD_INT 23
100978: PUSH
100979: LD_INT 24
100981: PUSH
100982: LD_INT 25
100984: PUSH
100985: LD_INT 26
100987: PUSH
100988: LD_INT 27
100990: PUSH
100991: LD_INT 28
100993: PUSH
100994: LD_INT 29
100996: PUSH
100997: LD_INT 30
100999: PUSH
101000: LD_INT 31
101002: PUSH
101003: LD_INT 32
101005: PUSH
101006: LD_INT 33
101008: PUSH
101009: LD_INT 34
101011: PUSH
101012: LD_INT 35
101014: PUSH
101015: LD_INT 36
101017: PUSH
101018: EMPTY
101019: LIST
101020: LIST
101021: LIST
101022: LIST
101023: LIST
101024: LIST
101025: LIST
101026: LIST
101027: LIST
101028: LIST
101029: LIST
101030: LIST
101031: LIST
101032: LIST
101033: LIST
101034: LIST
101035: LIST
101036: LIST
101037: LIST
101038: LIST
101039: LIST
101040: LIST
101041: LIST
101042: LIST
101043: LIST
101044: LIST
101045: LIST
101046: LIST
101047: LIST
101048: LIST
101049: LIST
101050: LIST
101051: LIST
101052: LIST
101053: LIST
101054: LIST
101055: PUSH
101056: LD_INT 101
101058: PUSH
101059: LD_INT 102
101061: PUSH
101062: LD_INT 103
101064: PUSH
101065: LD_INT 104
101067: PUSH
101068: LD_INT 105
101070: PUSH
101071: LD_INT 106
101073: PUSH
101074: LD_INT 107
101076: PUSH
101077: LD_INT 108
101079: PUSH
101080: LD_INT 109
101082: PUSH
101083: LD_INT 110
101085: PUSH
101086: LD_INT 111
101088: PUSH
101089: LD_INT 112
101091: PUSH
101092: LD_INT 113
101094: PUSH
101095: LD_INT 114
101097: PUSH
101098: LD_INT 115
101100: PUSH
101101: LD_INT 116
101103: PUSH
101104: LD_INT 117
101106: PUSH
101107: LD_INT 118
101109: PUSH
101110: EMPTY
101111: LIST
101112: LIST
101113: LIST
101114: LIST
101115: LIST
101116: LIST
101117: LIST
101118: LIST
101119: LIST
101120: LIST
101121: LIST
101122: LIST
101123: LIST
101124: LIST
101125: LIST
101126: LIST
101127: LIST
101128: LIST
101129: PUSH
101130: EMPTY
101131: LIST
101132: LIST
101133: ST_TO_ADDR
101134: GO 101137
101136: POP
// end else
101137: GO 101368
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
101139: LD_ADDR_VAR 0 2
101143: PUSH
101144: LD_INT 1
101146: PUSH
101147: LD_INT 2
101149: PUSH
101150: LD_INT 3
101152: PUSH
101153: LD_INT 4
101155: PUSH
101156: LD_INT 5
101158: PUSH
101159: LD_INT 6
101161: PUSH
101162: LD_INT 7
101164: PUSH
101165: LD_INT 8
101167: PUSH
101168: LD_INT 9
101170: PUSH
101171: LD_INT 10
101173: PUSH
101174: LD_INT 11
101176: PUSH
101177: LD_INT 12
101179: PUSH
101180: LD_INT 13
101182: PUSH
101183: LD_INT 14
101185: PUSH
101186: LD_INT 15
101188: PUSH
101189: LD_INT 16
101191: PUSH
101192: LD_INT 17
101194: PUSH
101195: LD_INT 18
101197: PUSH
101198: LD_INT 19
101200: PUSH
101201: LD_INT 20
101203: PUSH
101204: LD_INT 21
101206: PUSH
101207: LD_INT 22
101209: PUSH
101210: LD_INT 23
101212: PUSH
101213: LD_INT 24
101215: PUSH
101216: LD_INT 25
101218: PUSH
101219: LD_INT 26
101221: PUSH
101222: LD_INT 27
101224: PUSH
101225: LD_INT 28
101227: PUSH
101228: LD_INT 29
101230: PUSH
101231: LD_INT 30
101233: PUSH
101234: LD_INT 31
101236: PUSH
101237: LD_INT 32
101239: PUSH
101240: LD_INT 33
101242: PUSH
101243: LD_INT 34
101245: PUSH
101246: LD_INT 35
101248: PUSH
101249: LD_INT 36
101251: PUSH
101252: EMPTY
101253: LIST
101254: LIST
101255: LIST
101256: LIST
101257: LIST
101258: LIST
101259: LIST
101260: LIST
101261: LIST
101262: LIST
101263: LIST
101264: LIST
101265: LIST
101266: LIST
101267: LIST
101268: LIST
101269: LIST
101270: LIST
101271: LIST
101272: LIST
101273: LIST
101274: LIST
101275: LIST
101276: LIST
101277: LIST
101278: LIST
101279: LIST
101280: LIST
101281: LIST
101282: LIST
101283: LIST
101284: LIST
101285: LIST
101286: LIST
101287: LIST
101288: LIST
101289: PUSH
101290: LD_INT 101
101292: PUSH
101293: LD_INT 102
101295: PUSH
101296: LD_INT 103
101298: PUSH
101299: LD_INT 104
101301: PUSH
101302: LD_INT 105
101304: PUSH
101305: LD_INT 106
101307: PUSH
101308: LD_INT 107
101310: PUSH
101311: LD_INT 108
101313: PUSH
101314: LD_INT 109
101316: PUSH
101317: LD_INT 110
101319: PUSH
101320: LD_INT 111
101322: PUSH
101323: LD_INT 112
101325: PUSH
101326: LD_INT 113
101328: PUSH
101329: LD_INT 114
101331: PUSH
101332: LD_INT 115
101334: PUSH
101335: LD_INT 116
101337: PUSH
101338: LD_INT 117
101340: PUSH
101341: LD_INT 118
101343: PUSH
101344: EMPTY
101345: LIST
101346: LIST
101347: LIST
101348: LIST
101349: LIST
101350: LIST
101351: LIST
101352: LIST
101353: LIST
101354: LIST
101355: LIST
101356: LIST
101357: LIST
101358: LIST
101359: LIST
101360: LIST
101361: LIST
101362: LIST
101363: PUSH
101364: EMPTY
101365: LIST
101366: LIST
101367: ST_TO_ADDR
// if result then
101368: LD_VAR 0 2
101372: IFFALSE 102158
// begin normal :=  ;
101374: LD_ADDR_VAR 0 5
101378: PUSH
101379: LD_STRING 
101381: ST_TO_ADDR
// hardcore :=  ;
101382: LD_ADDR_VAR 0 6
101386: PUSH
101387: LD_STRING 
101389: ST_TO_ADDR
// active :=  ;
101390: LD_ADDR_VAR 0 7
101394: PUSH
101395: LD_STRING 
101397: ST_TO_ADDR
// for i = 1 to normalCounter do
101398: LD_ADDR_VAR 0 8
101402: PUSH
101403: DOUBLE
101404: LD_INT 1
101406: DEC
101407: ST_TO_ADDR
101408: LD_EXP 125
101412: PUSH
101413: FOR_TO
101414: IFFALSE 101515
// begin tmp := 0 ;
101416: LD_ADDR_VAR 0 3
101420: PUSH
101421: LD_STRING 0
101423: ST_TO_ADDR
// if result [ 1 ] then
101424: LD_VAR 0 2
101428: PUSH
101429: LD_INT 1
101431: ARRAY
101432: IFFALSE 101497
// if result [ 1 ] [ 1 ] = i then
101434: LD_VAR 0 2
101438: PUSH
101439: LD_INT 1
101441: ARRAY
101442: PUSH
101443: LD_INT 1
101445: ARRAY
101446: PUSH
101447: LD_VAR 0 8
101451: EQUAL
101452: IFFALSE 101497
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
101454: LD_ADDR_VAR 0 2
101458: PUSH
101459: LD_VAR 0 2
101463: PPUSH
101464: LD_INT 1
101466: PPUSH
101467: LD_VAR 0 2
101471: PUSH
101472: LD_INT 1
101474: ARRAY
101475: PPUSH
101476: LD_INT 1
101478: PPUSH
101479: CALL_OW 3
101483: PPUSH
101484: CALL_OW 1
101488: ST_TO_ADDR
// tmp := 1 ;
101489: LD_ADDR_VAR 0 3
101493: PUSH
101494: LD_STRING 1
101496: ST_TO_ADDR
// end ; normal := normal & tmp ;
101497: LD_ADDR_VAR 0 5
101501: PUSH
101502: LD_VAR 0 5
101506: PUSH
101507: LD_VAR 0 3
101511: STR
101512: ST_TO_ADDR
// end ;
101513: GO 101413
101515: POP
101516: POP
// for i = 1 to hardcoreCounter do
101517: LD_ADDR_VAR 0 8
101521: PUSH
101522: DOUBLE
101523: LD_INT 1
101525: DEC
101526: ST_TO_ADDR
101527: LD_EXP 126
101531: PUSH
101532: FOR_TO
101533: IFFALSE 101638
// begin tmp := 0 ;
101535: LD_ADDR_VAR 0 3
101539: PUSH
101540: LD_STRING 0
101542: ST_TO_ADDR
// if result [ 2 ] then
101543: LD_VAR 0 2
101547: PUSH
101548: LD_INT 2
101550: ARRAY
101551: IFFALSE 101620
// if result [ 2 ] [ 1 ] = 100 + i then
101553: LD_VAR 0 2
101557: PUSH
101558: LD_INT 2
101560: ARRAY
101561: PUSH
101562: LD_INT 1
101564: ARRAY
101565: PUSH
101566: LD_INT 100
101568: PUSH
101569: LD_VAR 0 8
101573: PLUS
101574: EQUAL
101575: IFFALSE 101620
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
101577: LD_ADDR_VAR 0 2
101581: PUSH
101582: LD_VAR 0 2
101586: PPUSH
101587: LD_INT 2
101589: PPUSH
101590: LD_VAR 0 2
101594: PUSH
101595: LD_INT 2
101597: ARRAY
101598: PPUSH
101599: LD_INT 1
101601: PPUSH
101602: CALL_OW 3
101606: PPUSH
101607: CALL_OW 1
101611: ST_TO_ADDR
// tmp := 1 ;
101612: LD_ADDR_VAR 0 3
101616: PUSH
101617: LD_STRING 1
101619: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
101620: LD_ADDR_VAR 0 6
101624: PUSH
101625: LD_VAR 0 6
101629: PUSH
101630: LD_VAR 0 3
101634: STR
101635: ST_TO_ADDR
// end ;
101636: GO 101532
101638: POP
101639: POP
// if isGameLoad then
101640: LD_VAR 0 1
101644: IFFALSE 102119
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
101646: LD_ADDR_VAR 0 4
101650: PUSH
101651: LD_EXP 129
101655: PUSH
101656: LD_EXP 128
101660: PUSH
101661: LD_EXP 130
101665: PUSH
101666: LD_EXP 127
101670: PUSH
101671: LD_EXP 131
101675: PUSH
101676: LD_EXP 132
101680: PUSH
101681: LD_EXP 133
101685: PUSH
101686: LD_EXP 134
101690: PUSH
101691: LD_EXP 135
101695: PUSH
101696: LD_EXP 136
101700: PUSH
101701: LD_EXP 137
101705: PUSH
101706: LD_EXP 138
101710: PUSH
101711: LD_EXP 139
101715: PUSH
101716: LD_EXP 140
101720: PUSH
101721: LD_EXP 148
101725: PUSH
101726: LD_EXP 149
101730: PUSH
101731: LD_EXP 150
101735: PUSH
101736: LD_EXP 151
101740: PUSH
101741: LD_EXP 153
101745: PUSH
101746: LD_EXP 154
101750: PUSH
101751: LD_EXP 155
101755: PUSH
101756: LD_EXP 158
101760: PUSH
101761: LD_EXP 160
101765: PUSH
101766: LD_EXP 161
101770: PUSH
101771: LD_EXP 162
101775: PUSH
101776: LD_EXP 164
101780: PUSH
101781: LD_EXP 165
101785: PUSH
101786: LD_EXP 168
101790: PUSH
101791: LD_EXP 169
101795: PUSH
101796: LD_EXP 170
101800: PUSH
101801: LD_EXP 171
101805: PUSH
101806: LD_EXP 172
101810: PUSH
101811: LD_EXP 173
101815: PUSH
101816: LD_EXP 174
101820: PUSH
101821: LD_EXP 175
101825: PUSH
101826: LD_EXP 176
101830: PUSH
101831: LD_EXP 141
101835: PUSH
101836: LD_EXP 142
101840: PUSH
101841: LD_EXP 145
101845: PUSH
101846: LD_EXP 146
101850: PUSH
101851: LD_EXP 147
101855: PUSH
101856: LD_EXP 143
101860: PUSH
101861: LD_EXP 144
101865: PUSH
101866: LD_EXP 152
101870: PUSH
101871: LD_EXP 156
101875: PUSH
101876: LD_EXP 157
101880: PUSH
101881: LD_EXP 159
101885: PUSH
101886: LD_EXP 163
101890: PUSH
101891: LD_EXP 166
101895: PUSH
101896: LD_EXP 167
101900: PUSH
101901: LD_EXP 177
101905: PUSH
101906: LD_EXP 178
101910: PUSH
101911: LD_EXP 179
101915: PUSH
101916: LD_EXP 180
101920: PUSH
101921: EMPTY
101922: LIST
101923: LIST
101924: LIST
101925: LIST
101926: LIST
101927: LIST
101928: LIST
101929: LIST
101930: LIST
101931: LIST
101932: LIST
101933: LIST
101934: LIST
101935: LIST
101936: LIST
101937: LIST
101938: LIST
101939: LIST
101940: LIST
101941: LIST
101942: LIST
101943: LIST
101944: LIST
101945: LIST
101946: LIST
101947: LIST
101948: LIST
101949: LIST
101950: LIST
101951: LIST
101952: LIST
101953: LIST
101954: LIST
101955: LIST
101956: LIST
101957: LIST
101958: LIST
101959: LIST
101960: LIST
101961: LIST
101962: LIST
101963: LIST
101964: LIST
101965: LIST
101966: LIST
101967: LIST
101968: LIST
101969: LIST
101970: LIST
101971: LIST
101972: LIST
101973: LIST
101974: LIST
101975: LIST
101976: ST_TO_ADDR
// tmp :=  ;
101977: LD_ADDR_VAR 0 3
101981: PUSH
101982: LD_STRING 
101984: ST_TO_ADDR
// for i = 1 to normalCounter do
101985: LD_ADDR_VAR 0 8
101989: PUSH
101990: DOUBLE
101991: LD_INT 1
101993: DEC
101994: ST_TO_ADDR
101995: LD_EXP 125
101999: PUSH
102000: FOR_TO
102001: IFFALSE 102037
// begin if flags [ i ] then
102003: LD_VAR 0 4
102007: PUSH
102008: LD_VAR 0 8
102012: ARRAY
102013: IFFALSE 102035
// tmp := tmp & i & ; ;
102015: LD_ADDR_VAR 0 3
102019: PUSH
102020: LD_VAR 0 3
102024: PUSH
102025: LD_VAR 0 8
102029: STR
102030: PUSH
102031: LD_STRING ;
102033: STR
102034: ST_TO_ADDR
// end ;
102035: GO 102000
102037: POP
102038: POP
// for i = 1 to hardcoreCounter do
102039: LD_ADDR_VAR 0 8
102043: PUSH
102044: DOUBLE
102045: LD_INT 1
102047: DEC
102048: ST_TO_ADDR
102049: LD_EXP 126
102053: PUSH
102054: FOR_TO
102055: IFFALSE 102101
// begin if flags [ normalCounter + i ] then
102057: LD_VAR 0 4
102061: PUSH
102062: LD_EXP 125
102066: PUSH
102067: LD_VAR 0 8
102071: PLUS
102072: ARRAY
102073: IFFALSE 102099
// tmp := tmp & ( 100 + i ) & ; ;
102075: LD_ADDR_VAR 0 3
102079: PUSH
102080: LD_VAR 0 3
102084: PUSH
102085: LD_INT 100
102087: PUSH
102088: LD_VAR 0 8
102092: PLUS
102093: STR
102094: PUSH
102095: LD_STRING ;
102097: STR
102098: ST_TO_ADDR
// end ;
102099: GO 102054
102101: POP
102102: POP
// if tmp then
102103: LD_VAR 0 3
102107: IFFALSE 102119
// active := tmp ;
102109: LD_ADDR_VAR 0 7
102113: PUSH
102114: LD_VAR 0 3
102118: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
102119: LD_STRING getStreamItemsFromMission("
102121: PUSH
102122: LD_VAR 0 5
102126: STR
102127: PUSH
102128: LD_STRING ","
102130: STR
102131: PUSH
102132: LD_VAR 0 6
102136: STR
102137: PUSH
102138: LD_STRING ","
102140: STR
102141: PUSH
102142: LD_VAR 0 7
102146: STR
102147: PUSH
102148: LD_STRING ")
102150: STR
102151: PPUSH
102152: CALL_OW 559
// end else
102156: GO 102165
// ToLua ( getStreamItemsFromMission("","","") ) ;
102158: LD_STRING getStreamItemsFromMission("","","")
102160: PPUSH
102161: CALL_OW 559
// end ;
102165: LD_VAR 0 2
102169: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
102170: LD_EXP 124
102174: PUSH
102175: LD_EXP 129
102179: AND
102180: IFFALSE 102304
102182: GO 102184
102184: DISABLE
102185: LD_INT 0
102187: PPUSH
102188: PPUSH
// begin enable ;
102189: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
102190: LD_ADDR_VAR 0 2
102194: PUSH
102195: LD_INT 22
102197: PUSH
102198: LD_OWVAR 2
102202: PUSH
102203: EMPTY
102204: LIST
102205: LIST
102206: PUSH
102207: LD_INT 2
102209: PUSH
102210: LD_INT 34
102212: PUSH
102213: LD_INT 7
102215: PUSH
102216: EMPTY
102217: LIST
102218: LIST
102219: PUSH
102220: LD_INT 34
102222: PUSH
102223: LD_INT 45
102225: PUSH
102226: EMPTY
102227: LIST
102228: LIST
102229: PUSH
102230: LD_INT 34
102232: PUSH
102233: LD_INT 28
102235: PUSH
102236: EMPTY
102237: LIST
102238: LIST
102239: PUSH
102240: LD_INT 34
102242: PUSH
102243: LD_INT 47
102245: PUSH
102246: EMPTY
102247: LIST
102248: LIST
102249: PUSH
102250: EMPTY
102251: LIST
102252: LIST
102253: LIST
102254: LIST
102255: LIST
102256: PUSH
102257: EMPTY
102258: LIST
102259: LIST
102260: PPUSH
102261: CALL_OW 69
102265: ST_TO_ADDR
// if not tmp then
102266: LD_VAR 0 2
102270: NOT
102271: IFFALSE 102275
// exit ;
102273: GO 102304
// for i in tmp do
102275: LD_ADDR_VAR 0 1
102279: PUSH
102280: LD_VAR 0 2
102284: PUSH
102285: FOR_IN
102286: IFFALSE 102302
// begin SetLives ( i , 0 ) ;
102288: LD_VAR 0 1
102292: PPUSH
102293: LD_INT 0
102295: PPUSH
102296: CALL_OW 234
// end ;
102300: GO 102285
102302: POP
102303: POP
// end ;
102304: PPOPN 2
102306: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
102307: LD_EXP 124
102311: PUSH
102312: LD_EXP 130
102316: AND
102317: IFFALSE 102401
102319: GO 102321
102321: DISABLE
102322: LD_INT 0
102324: PPUSH
102325: PPUSH
// begin enable ;
102326: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
102327: LD_ADDR_VAR 0 2
102331: PUSH
102332: LD_INT 22
102334: PUSH
102335: LD_OWVAR 2
102339: PUSH
102340: EMPTY
102341: LIST
102342: LIST
102343: PUSH
102344: LD_INT 32
102346: PUSH
102347: LD_INT 3
102349: PUSH
102350: EMPTY
102351: LIST
102352: LIST
102353: PUSH
102354: EMPTY
102355: LIST
102356: LIST
102357: PPUSH
102358: CALL_OW 69
102362: ST_TO_ADDR
// if not tmp then
102363: LD_VAR 0 2
102367: NOT
102368: IFFALSE 102372
// exit ;
102370: GO 102401
// for i in tmp do
102372: LD_ADDR_VAR 0 1
102376: PUSH
102377: LD_VAR 0 2
102381: PUSH
102382: FOR_IN
102383: IFFALSE 102399
// begin SetLives ( i , 0 ) ;
102385: LD_VAR 0 1
102389: PPUSH
102390: LD_INT 0
102392: PPUSH
102393: CALL_OW 234
// end ;
102397: GO 102382
102399: POP
102400: POP
// end ;
102401: PPOPN 2
102403: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
102404: LD_EXP 124
102408: PUSH
102409: LD_EXP 127
102413: AND
102414: IFFALSE 102507
102416: GO 102418
102418: DISABLE
102419: LD_INT 0
102421: PPUSH
// begin enable ;
102422: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
102423: LD_ADDR_VAR 0 1
102427: PUSH
102428: LD_INT 22
102430: PUSH
102431: LD_OWVAR 2
102435: PUSH
102436: EMPTY
102437: LIST
102438: LIST
102439: PUSH
102440: LD_INT 2
102442: PUSH
102443: LD_INT 25
102445: PUSH
102446: LD_INT 5
102448: PUSH
102449: EMPTY
102450: LIST
102451: LIST
102452: PUSH
102453: LD_INT 25
102455: PUSH
102456: LD_INT 9
102458: PUSH
102459: EMPTY
102460: LIST
102461: LIST
102462: PUSH
102463: LD_INT 25
102465: PUSH
102466: LD_INT 8
102468: PUSH
102469: EMPTY
102470: LIST
102471: LIST
102472: PUSH
102473: EMPTY
102474: LIST
102475: LIST
102476: LIST
102477: LIST
102478: PUSH
102479: EMPTY
102480: LIST
102481: LIST
102482: PPUSH
102483: CALL_OW 69
102487: PUSH
102488: FOR_IN
102489: IFFALSE 102505
// begin SetClass ( i , 1 ) ;
102491: LD_VAR 0 1
102495: PPUSH
102496: LD_INT 1
102498: PPUSH
102499: CALL_OW 336
// end ;
102503: GO 102488
102505: POP
102506: POP
// end ;
102507: PPOPN 1
102509: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
102510: LD_EXP 124
102514: PUSH
102515: LD_EXP 128
102519: AND
102520: PUSH
102521: LD_OWVAR 65
102525: PUSH
102526: LD_INT 7
102528: LESS
102529: AND
102530: IFFALSE 102544
102532: GO 102534
102534: DISABLE
// begin enable ;
102535: ENABLE
// game_speed := 7 ;
102536: LD_ADDR_OWVAR 65
102540: PUSH
102541: LD_INT 7
102543: ST_TO_ADDR
// end ;
102544: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
102545: LD_EXP 124
102549: PUSH
102550: LD_EXP 131
102554: AND
102555: IFFALSE 102757
102557: GO 102559
102559: DISABLE
102560: LD_INT 0
102562: PPUSH
102563: PPUSH
102564: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102565: LD_ADDR_VAR 0 3
102569: PUSH
102570: LD_INT 81
102572: PUSH
102573: LD_OWVAR 2
102577: PUSH
102578: EMPTY
102579: LIST
102580: LIST
102581: PUSH
102582: LD_INT 21
102584: PUSH
102585: LD_INT 1
102587: PUSH
102588: EMPTY
102589: LIST
102590: LIST
102591: PUSH
102592: EMPTY
102593: LIST
102594: LIST
102595: PPUSH
102596: CALL_OW 69
102600: ST_TO_ADDR
// if not tmp then
102601: LD_VAR 0 3
102605: NOT
102606: IFFALSE 102610
// exit ;
102608: GO 102757
// if tmp > 5 then
102610: LD_VAR 0 3
102614: PUSH
102615: LD_INT 5
102617: GREATER
102618: IFFALSE 102630
// k := 5 else
102620: LD_ADDR_VAR 0 2
102624: PUSH
102625: LD_INT 5
102627: ST_TO_ADDR
102628: GO 102640
// k := tmp ;
102630: LD_ADDR_VAR 0 2
102634: PUSH
102635: LD_VAR 0 3
102639: ST_TO_ADDR
// for i := 1 to k do
102640: LD_ADDR_VAR 0 1
102644: PUSH
102645: DOUBLE
102646: LD_INT 1
102648: DEC
102649: ST_TO_ADDR
102650: LD_VAR 0 2
102654: PUSH
102655: FOR_TO
102656: IFFALSE 102755
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
102658: LD_VAR 0 3
102662: PUSH
102663: LD_VAR 0 1
102667: ARRAY
102668: PPUSH
102669: LD_VAR 0 1
102673: PUSH
102674: LD_INT 4
102676: MOD
102677: PUSH
102678: LD_INT 1
102680: PLUS
102681: PPUSH
102682: CALL_OW 259
102686: PUSH
102687: LD_INT 10
102689: LESS
102690: IFFALSE 102753
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
102692: LD_VAR 0 3
102696: PUSH
102697: LD_VAR 0 1
102701: ARRAY
102702: PPUSH
102703: LD_VAR 0 1
102707: PUSH
102708: LD_INT 4
102710: MOD
102711: PUSH
102712: LD_INT 1
102714: PLUS
102715: PPUSH
102716: LD_VAR 0 3
102720: PUSH
102721: LD_VAR 0 1
102725: ARRAY
102726: PPUSH
102727: LD_VAR 0 1
102731: PUSH
102732: LD_INT 4
102734: MOD
102735: PUSH
102736: LD_INT 1
102738: PLUS
102739: PPUSH
102740: CALL_OW 259
102744: PUSH
102745: LD_INT 1
102747: PLUS
102748: PPUSH
102749: CALL_OW 237
102753: GO 102655
102755: POP
102756: POP
// end ;
102757: PPOPN 3
102759: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
102760: LD_EXP 124
102764: PUSH
102765: LD_EXP 132
102769: AND
102770: IFFALSE 102790
102772: GO 102774
102774: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
102775: LD_INT 4
102777: PPUSH
102778: LD_OWVAR 2
102782: PPUSH
102783: LD_INT 0
102785: PPUSH
102786: CALL_OW 324
102790: END
// every 0 0$1 trigger StreamModeActive and sShovel do
102791: LD_EXP 124
102795: PUSH
102796: LD_EXP 161
102800: AND
102801: IFFALSE 102821
102803: GO 102805
102805: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
102806: LD_INT 19
102808: PPUSH
102809: LD_OWVAR 2
102813: PPUSH
102814: LD_INT 0
102816: PPUSH
102817: CALL_OW 324
102821: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
102822: LD_EXP 124
102826: PUSH
102827: LD_EXP 133
102831: AND
102832: IFFALSE 102934
102834: GO 102836
102836: DISABLE
102837: LD_INT 0
102839: PPUSH
102840: PPUSH
// begin enable ;
102841: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
102842: LD_ADDR_VAR 0 2
102846: PUSH
102847: LD_INT 22
102849: PUSH
102850: LD_OWVAR 2
102854: PUSH
102855: EMPTY
102856: LIST
102857: LIST
102858: PUSH
102859: LD_INT 2
102861: PUSH
102862: LD_INT 34
102864: PUSH
102865: LD_INT 11
102867: PUSH
102868: EMPTY
102869: LIST
102870: LIST
102871: PUSH
102872: LD_INT 34
102874: PUSH
102875: LD_INT 30
102877: PUSH
102878: EMPTY
102879: LIST
102880: LIST
102881: PUSH
102882: EMPTY
102883: LIST
102884: LIST
102885: LIST
102886: PUSH
102887: EMPTY
102888: LIST
102889: LIST
102890: PPUSH
102891: CALL_OW 69
102895: ST_TO_ADDR
// if not tmp then
102896: LD_VAR 0 2
102900: NOT
102901: IFFALSE 102905
// exit ;
102903: GO 102934
// for i in tmp do
102905: LD_ADDR_VAR 0 1
102909: PUSH
102910: LD_VAR 0 2
102914: PUSH
102915: FOR_IN
102916: IFFALSE 102932
// begin SetLives ( i , 0 ) ;
102918: LD_VAR 0 1
102922: PPUSH
102923: LD_INT 0
102925: PPUSH
102926: CALL_OW 234
// end ;
102930: GO 102915
102932: POP
102933: POP
// end ;
102934: PPOPN 2
102936: END
// every 0 0$1 trigger StreamModeActive and sBunker do
102937: LD_EXP 124
102941: PUSH
102942: LD_EXP 134
102946: AND
102947: IFFALSE 102967
102949: GO 102951
102951: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
102952: LD_INT 32
102954: PPUSH
102955: LD_OWVAR 2
102959: PPUSH
102960: LD_INT 0
102962: PPUSH
102963: CALL_OW 324
102967: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
102968: LD_EXP 124
102972: PUSH
102973: LD_EXP 135
102977: AND
102978: IFFALSE 103159
102980: GO 102982
102982: DISABLE
102983: LD_INT 0
102985: PPUSH
102986: PPUSH
102987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
102988: LD_ADDR_VAR 0 2
102992: PUSH
102993: LD_INT 22
102995: PUSH
102996: LD_OWVAR 2
103000: PUSH
103001: EMPTY
103002: LIST
103003: LIST
103004: PUSH
103005: LD_INT 33
103007: PUSH
103008: LD_INT 3
103010: PUSH
103011: EMPTY
103012: LIST
103013: LIST
103014: PUSH
103015: EMPTY
103016: LIST
103017: LIST
103018: PPUSH
103019: CALL_OW 69
103023: ST_TO_ADDR
// if not tmp then
103024: LD_VAR 0 2
103028: NOT
103029: IFFALSE 103033
// exit ;
103031: GO 103159
// side := 0 ;
103033: LD_ADDR_VAR 0 3
103037: PUSH
103038: LD_INT 0
103040: ST_TO_ADDR
// for i := 1 to 8 do
103041: LD_ADDR_VAR 0 1
103045: PUSH
103046: DOUBLE
103047: LD_INT 1
103049: DEC
103050: ST_TO_ADDR
103051: LD_INT 8
103053: PUSH
103054: FOR_TO
103055: IFFALSE 103103
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
103057: LD_OWVAR 2
103061: PUSH
103062: LD_VAR 0 1
103066: NONEQUAL
103067: PUSH
103068: LD_OWVAR 2
103072: PPUSH
103073: LD_VAR 0 1
103077: PPUSH
103078: CALL_OW 81
103082: PUSH
103083: LD_INT 2
103085: EQUAL
103086: AND
103087: IFFALSE 103101
// begin side := i ;
103089: LD_ADDR_VAR 0 3
103093: PUSH
103094: LD_VAR 0 1
103098: ST_TO_ADDR
// break ;
103099: GO 103103
// end ;
103101: GO 103054
103103: POP
103104: POP
// if not side then
103105: LD_VAR 0 3
103109: NOT
103110: IFFALSE 103114
// exit ;
103112: GO 103159
// for i := 1 to tmp do
103114: LD_ADDR_VAR 0 1
103118: PUSH
103119: DOUBLE
103120: LD_INT 1
103122: DEC
103123: ST_TO_ADDR
103124: LD_VAR 0 2
103128: PUSH
103129: FOR_TO
103130: IFFALSE 103157
// if Prob ( 60 ) then
103132: LD_INT 60
103134: PPUSH
103135: CALL_OW 13
103139: IFFALSE 103155
// SetSide ( i , side ) ;
103141: LD_VAR 0 1
103145: PPUSH
103146: LD_VAR 0 3
103150: PPUSH
103151: CALL_OW 235
103155: GO 103129
103157: POP
103158: POP
// end ;
103159: PPOPN 3
103161: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
103162: LD_EXP 124
103166: PUSH
103167: LD_EXP 137
103171: AND
103172: IFFALSE 103291
103174: GO 103176
103176: DISABLE
103177: LD_INT 0
103179: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
103180: LD_ADDR_VAR 0 1
103184: PUSH
103185: LD_INT 22
103187: PUSH
103188: LD_OWVAR 2
103192: PUSH
103193: EMPTY
103194: LIST
103195: LIST
103196: PUSH
103197: LD_INT 21
103199: PUSH
103200: LD_INT 1
103202: PUSH
103203: EMPTY
103204: LIST
103205: LIST
103206: PUSH
103207: LD_INT 3
103209: PUSH
103210: LD_INT 23
103212: PUSH
103213: LD_INT 0
103215: PUSH
103216: EMPTY
103217: LIST
103218: LIST
103219: PUSH
103220: EMPTY
103221: LIST
103222: LIST
103223: PUSH
103224: EMPTY
103225: LIST
103226: LIST
103227: LIST
103228: PPUSH
103229: CALL_OW 69
103233: PUSH
103234: FOR_IN
103235: IFFALSE 103289
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
103237: LD_VAR 0 1
103241: PPUSH
103242: CALL_OW 257
103246: PUSH
103247: LD_INT 1
103249: PUSH
103250: LD_INT 2
103252: PUSH
103253: LD_INT 3
103255: PUSH
103256: LD_INT 4
103258: PUSH
103259: EMPTY
103260: LIST
103261: LIST
103262: LIST
103263: LIST
103264: IN
103265: IFFALSE 103287
// SetClass ( un , rand ( 1 , 4 ) ) ;
103267: LD_VAR 0 1
103271: PPUSH
103272: LD_INT 1
103274: PPUSH
103275: LD_INT 4
103277: PPUSH
103278: CALL_OW 12
103282: PPUSH
103283: CALL_OW 336
103287: GO 103234
103289: POP
103290: POP
// end ;
103291: PPOPN 1
103293: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
103294: LD_EXP 124
103298: PUSH
103299: LD_EXP 136
103303: AND
103304: IFFALSE 103383
103306: GO 103308
103308: DISABLE
103309: LD_INT 0
103311: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103312: LD_ADDR_VAR 0 1
103316: PUSH
103317: LD_INT 22
103319: PUSH
103320: LD_OWVAR 2
103324: PUSH
103325: EMPTY
103326: LIST
103327: LIST
103328: PUSH
103329: LD_INT 21
103331: PUSH
103332: LD_INT 3
103334: PUSH
103335: EMPTY
103336: LIST
103337: LIST
103338: PUSH
103339: EMPTY
103340: LIST
103341: LIST
103342: PPUSH
103343: CALL_OW 69
103347: ST_TO_ADDR
// if not tmp then
103348: LD_VAR 0 1
103352: NOT
103353: IFFALSE 103357
// exit ;
103355: GO 103383
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
103357: LD_VAR 0 1
103361: PUSH
103362: LD_INT 1
103364: PPUSH
103365: LD_VAR 0 1
103369: PPUSH
103370: CALL_OW 12
103374: ARRAY
103375: PPUSH
103376: LD_INT 100
103378: PPUSH
103379: CALL_OW 234
// end ;
103383: PPOPN 1
103385: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
103386: LD_EXP 124
103390: PUSH
103391: LD_EXP 138
103395: AND
103396: IFFALSE 103494
103398: GO 103400
103400: DISABLE
103401: LD_INT 0
103403: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103404: LD_ADDR_VAR 0 1
103408: PUSH
103409: LD_INT 22
103411: PUSH
103412: LD_OWVAR 2
103416: PUSH
103417: EMPTY
103418: LIST
103419: LIST
103420: PUSH
103421: LD_INT 21
103423: PUSH
103424: LD_INT 1
103426: PUSH
103427: EMPTY
103428: LIST
103429: LIST
103430: PUSH
103431: EMPTY
103432: LIST
103433: LIST
103434: PPUSH
103435: CALL_OW 69
103439: ST_TO_ADDR
// if not tmp then
103440: LD_VAR 0 1
103444: NOT
103445: IFFALSE 103449
// exit ;
103447: GO 103494
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
103449: LD_VAR 0 1
103453: PUSH
103454: LD_INT 1
103456: PPUSH
103457: LD_VAR 0 1
103461: PPUSH
103462: CALL_OW 12
103466: ARRAY
103467: PPUSH
103468: LD_INT 1
103470: PPUSH
103471: LD_INT 4
103473: PPUSH
103474: CALL_OW 12
103478: PPUSH
103479: LD_INT 3000
103481: PPUSH
103482: LD_INT 9000
103484: PPUSH
103485: CALL_OW 12
103489: PPUSH
103490: CALL_OW 492
// end ;
103494: PPOPN 1
103496: END
// every 0 0$1 trigger StreamModeActive and sDepot do
103497: LD_EXP 124
103501: PUSH
103502: LD_EXP 139
103506: AND
103507: IFFALSE 103527
103509: GO 103511
103511: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
103512: LD_INT 1
103514: PPUSH
103515: LD_OWVAR 2
103519: PPUSH
103520: LD_INT 0
103522: PPUSH
103523: CALL_OW 324
103527: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
103528: LD_EXP 124
103532: PUSH
103533: LD_EXP 140
103537: AND
103538: IFFALSE 103621
103540: GO 103542
103542: DISABLE
103543: LD_INT 0
103545: PPUSH
103546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103547: LD_ADDR_VAR 0 2
103551: PUSH
103552: LD_INT 22
103554: PUSH
103555: LD_OWVAR 2
103559: PUSH
103560: EMPTY
103561: LIST
103562: LIST
103563: PUSH
103564: LD_INT 21
103566: PUSH
103567: LD_INT 3
103569: PUSH
103570: EMPTY
103571: LIST
103572: LIST
103573: PUSH
103574: EMPTY
103575: LIST
103576: LIST
103577: PPUSH
103578: CALL_OW 69
103582: ST_TO_ADDR
// if not tmp then
103583: LD_VAR 0 2
103587: NOT
103588: IFFALSE 103592
// exit ;
103590: GO 103621
// for i in tmp do
103592: LD_ADDR_VAR 0 1
103596: PUSH
103597: LD_VAR 0 2
103601: PUSH
103602: FOR_IN
103603: IFFALSE 103619
// SetBLevel ( i , 10 ) ;
103605: LD_VAR 0 1
103609: PPUSH
103610: LD_INT 10
103612: PPUSH
103613: CALL_OW 241
103617: GO 103602
103619: POP
103620: POP
// end ;
103621: PPOPN 2
103623: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
103624: LD_EXP 124
103628: PUSH
103629: LD_EXP 141
103633: AND
103634: IFFALSE 103745
103636: GO 103638
103638: DISABLE
103639: LD_INT 0
103641: PPUSH
103642: PPUSH
103643: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103644: LD_ADDR_VAR 0 3
103648: PUSH
103649: LD_INT 22
103651: PUSH
103652: LD_OWVAR 2
103656: PUSH
103657: EMPTY
103658: LIST
103659: LIST
103660: PUSH
103661: LD_INT 25
103663: PUSH
103664: LD_INT 1
103666: PUSH
103667: EMPTY
103668: LIST
103669: LIST
103670: PUSH
103671: EMPTY
103672: LIST
103673: LIST
103674: PPUSH
103675: CALL_OW 69
103679: ST_TO_ADDR
// if not tmp then
103680: LD_VAR 0 3
103684: NOT
103685: IFFALSE 103689
// exit ;
103687: GO 103745
// un := tmp [ rand ( 1 , tmp ) ] ;
103689: LD_ADDR_VAR 0 2
103693: PUSH
103694: LD_VAR 0 3
103698: PUSH
103699: LD_INT 1
103701: PPUSH
103702: LD_VAR 0 3
103706: PPUSH
103707: CALL_OW 12
103711: ARRAY
103712: ST_TO_ADDR
// if Crawls ( un ) then
103713: LD_VAR 0 2
103717: PPUSH
103718: CALL_OW 318
103722: IFFALSE 103733
// ComWalk ( un ) ;
103724: LD_VAR 0 2
103728: PPUSH
103729: CALL_OW 138
// SetClass ( un , class_sniper ) ;
103733: LD_VAR 0 2
103737: PPUSH
103738: LD_INT 5
103740: PPUSH
103741: CALL_OW 336
// end ;
103745: PPOPN 3
103747: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
103748: LD_EXP 124
103752: PUSH
103753: LD_EXP 142
103757: AND
103758: PUSH
103759: LD_OWVAR 67
103763: PUSH
103764: LD_INT 4
103766: LESS
103767: AND
103768: IFFALSE 103787
103770: GO 103772
103772: DISABLE
// begin Difficulty := Difficulty + 1 ;
103773: LD_ADDR_OWVAR 67
103777: PUSH
103778: LD_OWVAR 67
103782: PUSH
103783: LD_INT 1
103785: PLUS
103786: ST_TO_ADDR
// end ;
103787: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
103788: LD_EXP 124
103792: PUSH
103793: LD_EXP 143
103797: AND
103798: IFFALSE 103901
103800: GO 103802
103802: DISABLE
103803: LD_INT 0
103805: PPUSH
// begin for i := 1 to 5 do
103806: LD_ADDR_VAR 0 1
103810: PUSH
103811: DOUBLE
103812: LD_INT 1
103814: DEC
103815: ST_TO_ADDR
103816: LD_INT 5
103818: PUSH
103819: FOR_TO
103820: IFFALSE 103899
// begin uc_nation := nation_nature ;
103822: LD_ADDR_OWVAR 21
103826: PUSH
103827: LD_INT 0
103829: ST_TO_ADDR
// uc_side := 0 ;
103830: LD_ADDR_OWVAR 20
103834: PUSH
103835: LD_INT 0
103837: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
103838: LD_ADDR_OWVAR 29
103842: PUSH
103843: LD_INT 12
103845: PUSH
103846: LD_INT 12
103848: PUSH
103849: EMPTY
103850: LIST
103851: LIST
103852: ST_TO_ADDR
// hc_agressivity := 20 ;
103853: LD_ADDR_OWVAR 35
103857: PUSH
103858: LD_INT 20
103860: ST_TO_ADDR
// hc_class := class_tiger ;
103861: LD_ADDR_OWVAR 28
103865: PUSH
103866: LD_INT 14
103868: ST_TO_ADDR
// hc_gallery :=  ;
103869: LD_ADDR_OWVAR 33
103873: PUSH
103874: LD_STRING 
103876: ST_TO_ADDR
// hc_name :=  ;
103877: LD_ADDR_OWVAR 26
103881: PUSH
103882: LD_STRING 
103884: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
103885: CALL_OW 44
103889: PPUSH
103890: LD_INT 0
103892: PPUSH
103893: CALL_OW 51
// end ;
103897: GO 103819
103899: POP
103900: POP
// end ;
103901: PPOPN 1
103903: END
// every 0 0$1 trigger StreamModeActive and sBomb do
103904: LD_EXP 124
103908: PUSH
103909: LD_EXP 144
103913: AND
103914: IFFALSE 103923
103916: GO 103918
103918: DISABLE
// StreamSibBomb ;
103919: CALL 103924 0 0
103923: END
// export function StreamSibBomb ; var i , x , y ; begin
103924: LD_INT 0
103926: PPUSH
103927: PPUSH
103928: PPUSH
103929: PPUSH
// result := false ;
103930: LD_ADDR_VAR 0 1
103934: PUSH
103935: LD_INT 0
103937: ST_TO_ADDR
// for i := 1 to 16 do
103938: LD_ADDR_VAR 0 2
103942: PUSH
103943: DOUBLE
103944: LD_INT 1
103946: DEC
103947: ST_TO_ADDR
103948: LD_INT 16
103950: PUSH
103951: FOR_TO
103952: IFFALSE 104151
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
103954: LD_ADDR_VAR 0 3
103958: PUSH
103959: LD_INT 10
103961: PUSH
103962: LD_INT 20
103964: PUSH
103965: LD_INT 30
103967: PUSH
103968: LD_INT 40
103970: PUSH
103971: LD_INT 50
103973: PUSH
103974: LD_INT 60
103976: PUSH
103977: LD_INT 70
103979: PUSH
103980: LD_INT 80
103982: PUSH
103983: LD_INT 90
103985: PUSH
103986: LD_INT 100
103988: PUSH
103989: LD_INT 110
103991: PUSH
103992: LD_INT 120
103994: PUSH
103995: LD_INT 130
103997: PUSH
103998: LD_INT 140
104000: PUSH
104001: LD_INT 150
104003: PUSH
104004: EMPTY
104005: LIST
104006: LIST
104007: LIST
104008: LIST
104009: LIST
104010: LIST
104011: LIST
104012: LIST
104013: LIST
104014: LIST
104015: LIST
104016: LIST
104017: LIST
104018: LIST
104019: LIST
104020: PUSH
104021: LD_INT 1
104023: PPUSH
104024: LD_INT 15
104026: PPUSH
104027: CALL_OW 12
104031: ARRAY
104032: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104033: LD_ADDR_VAR 0 4
104037: PUSH
104038: LD_INT 10
104040: PUSH
104041: LD_INT 20
104043: PUSH
104044: LD_INT 30
104046: PUSH
104047: LD_INT 40
104049: PUSH
104050: LD_INT 50
104052: PUSH
104053: LD_INT 60
104055: PUSH
104056: LD_INT 70
104058: PUSH
104059: LD_INT 80
104061: PUSH
104062: LD_INT 90
104064: PUSH
104065: LD_INT 100
104067: PUSH
104068: LD_INT 110
104070: PUSH
104071: LD_INT 120
104073: PUSH
104074: LD_INT 130
104076: PUSH
104077: LD_INT 140
104079: PUSH
104080: LD_INT 150
104082: PUSH
104083: EMPTY
104084: LIST
104085: LIST
104086: LIST
104087: LIST
104088: LIST
104089: LIST
104090: LIST
104091: LIST
104092: LIST
104093: LIST
104094: LIST
104095: LIST
104096: LIST
104097: LIST
104098: LIST
104099: PUSH
104100: LD_INT 1
104102: PPUSH
104103: LD_INT 15
104105: PPUSH
104106: CALL_OW 12
104110: ARRAY
104111: ST_TO_ADDR
// if ValidHex ( x , y ) then
104112: LD_VAR 0 3
104116: PPUSH
104117: LD_VAR 0 4
104121: PPUSH
104122: CALL_OW 488
104126: IFFALSE 104149
// begin result := [ x , y ] ;
104128: LD_ADDR_VAR 0 1
104132: PUSH
104133: LD_VAR 0 3
104137: PUSH
104138: LD_VAR 0 4
104142: PUSH
104143: EMPTY
104144: LIST
104145: LIST
104146: ST_TO_ADDR
// break ;
104147: GO 104151
// end ; end ;
104149: GO 103951
104151: POP
104152: POP
// if result then
104153: LD_VAR 0 1
104157: IFFALSE 104217
// begin ToLua ( playSibBomb() ) ;
104159: LD_STRING playSibBomb()
104161: PPUSH
104162: CALL_OW 559
// wait ( 0 0$14 ) ;
104166: LD_INT 490
104168: PPUSH
104169: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
104173: LD_VAR 0 1
104177: PUSH
104178: LD_INT 1
104180: ARRAY
104181: PPUSH
104182: LD_VAR 0 1
104186: PUSH
104187: LD_INT 2
104189: ARRAY
104190: PPUSH
104191: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
104195: LD_VAR 0 1
104199: PUSH
104200: LD_INT 1
104202: ARRAY
104203: PPUSH
104204: LD_VAR 0 1
104208: PUSH
104209: LD_INT 2
104211: ARRAY
104212: PPUSH
104213: CALL_OW 429
// end ; end ;
104217: LD_VAR 0 1
104221: RET
// every 0 0$1 trigger StreamModeActive and sReset do
104222: LD_EXP 124
104226: PUSH
104227: LD_EXP 146
104231: AND
104232: IFFALSE 104244
104234: GO 104236
104236: DISABLE
// YouLost (  ) ;
104237: LD_STRING 
104239: PPUSH
104240: CALL_OW 104
104244: END
// every 0 0$1 trigger StreamModeActive and sFog do
104245: LD_EXP 124
104249: PUSH
104250: LD_EXP 145
104254: AND
104255: IFFALSE 104269
104257: GO 104259
104259: DISABLE
// FogOff ( your_side ) ;
104260: LD_OWVAR 2
104264: PPUSH
104265: CALL_OW 344
104269: END
// every 0 0$1 trigger StreamModeActive and sSun do
104270: LD_EXP 124
104274: PUSH
104275: LD_EXP 147
104279: AND
104280: IFFALSE 104308
104282: GO 104284
104284: DISABLE
// begin solar_recharge_percent := 0 ;
104285: LD_ADDR_OWVAR 79
104289: PUSH
104290: LD_INT 0
104292: ST_TO_ADDR
// wait ( 5 5$00 ) ;
104293: LD_INT 10500
104295: PPUSH
104296: CALL_OW 67
// solar_recharge_percent := 100 ;
104300: LD_ADDR_OWVAR 79
104304: PUSH
104305: LD_INT 100
104307: ST_TO_ADDR
// end ;
104308: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
104309: LD_EXP 124
104313: PUSH
104314: LD_EXP 148
104318: AND
104319: IFFALSE 104558
104321: GO 104323
104323: DISABLE
104324: LD_INT 0
104326: PPUSH
104327: PPUSH
104328: PPUSH
// begin tmp := [ ] ;
104329: LD_ADDR_VAR 0 3
104333: PUSH
104334: EMPTY
104335: ST_TO_ADDR
// for i := 1 to 6 do
104336: LD_ADDR_VAR 0 1
104340: PUSH
104341: DOUBLE
104342: LD_INT 1
104344: DEC
104345: ST_TO_ADDR
104346: LD_INT 6
104348: PUSH
104349: FOR_TO
104350: IFFALSE 104455
// begin uc_nation := nation_nature ;
104352: LD_ADDR_OWVAR 21
104356: PUSH
104357: LD_INT 0
104359: ST_TO_ADDR
// uc_side := 0 ;
104360: LD_ADDR_OWVAR 20
104364: PUSH
104365: LD_INT 0
104367: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
104368: LD_ADDR_OWVAR 29
104372: PUSH
104373: LD_INT 12
104375: PUSH
104376: LD_INT 12
104378: PUSH
104379: EMPTY
104380: LIST
104381: LIST
104382: ST_TO_ADDR
// hc_agressivity := 20 ;
104383: LD_ADDR_OWVAR 35
104387: PUSH
104388: LD_INT 20
104390: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
104391: LD_ADDR_OWVAR 28
104395: PUSH
104396: LD_INT 17
104398: ST_TO_ADDR
// hc_gallery :=  ;
104399: LD_ADDR_OWVAR 33
104403: PUSH
104404: LD_STRING 
104406: ST_TO_ADDR
// hc_name :=  ;
104407: LD_ADDR_OWVAR 26
104411: PUSH
104412: LD_STRING 
104414: ST_TO_ADDR
// un := CreateHuman ;
104415: LD_ADDR_VAR 0 2
104419: PUSH
104420: CALL_OW 44
104424: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
104425: LD_VAR 0 2
104429: PPUSH
104430: LD_INT 1
104432: PPUSH
104433: CALL_OW 51
// tmp := tmp ^ un ;
104437: LD_ADDR_VAR 0 3
104441: PUSH
104442: LD_VAR 0 3
104446: PUSH
104447: LD_VAR 0 2
104451: ADD
104452: ST_TO_ADDR
// end ;
104453: GO 104349
104455: POP
104456: POP
// repeat wait ( 0 0$1 ) ;
104457: LD_INT 35
104459: PPUSH
104460: CALL_OW 67
// for un in tmp do
104464: LD_ADDR_VAR 0 2
104468: PUSH
104469: LD_VAR 0 3
104473: PUSH
104474: FOR_IN
104475: IFFALSE 104549
// begin if IsDead ( un ) then
104477: LD_VAR 0 2
104481: PPUSH
104482: CALL_OW 301
104486: IFFALSE 104506
// begin tmp := tmp diff un ;
104488: LD_ADDR_VAR 0 3
104492: PUSH
104493: LD_VAR 0 3
104497: PUSH
104498: LD_VAR 0 2
104502: DIFF
104503: ST_TO_ADDR
// continue ;
104504: GO 104474
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
104506: LD_VAR 0 2
104510: PPUSH
104511: LD_INT 3
104513: PUSH
104514: LD_INT 22
104516: PUSH
104517: LD_INT 0
104519: PUSH
104520: EMPTY
104521: LIST
104522: LIST
104523: PUSH
104524: EMPTY
104525: LIST
104526: LIST
104527: PPUSH
104528: CALL_OW 69
104532: PPUSH
104533: LD_VAR 0 2
104537: PPUSH
104538: CALL_OW 74
104542: PPUSH
104543: CALL_OW 115
// end ;
104547: GO 104474
104549: POP
104550: POP
// until not tmp ;
104551: LD_VAR 0 3
104555: NOT
104556: IFFALSE 104457
// end ;
104558: PPOPN 3
104560: END
// every 0 0$1 trigger StreamModeActive and sTroll do
104561: LD_EXP 124
104565: PUSH
104566: LD_EXP 149
104570: AND
104571: IFFALSE 104625
104573: GO 104575
104575: DISABLE
// begin ToLua ( displayTroll(); ) ;
104576: LD_STRING displayTroll();
104578: PPUSH
104579: CALL_OW 559
// wait ( 3 3$00 ) ;
104583: LD_INT 6300
104585: PPUSH
104586: CALL_OW 67
// ToLua ( hideTroll(); ) ;
104590: LD_STRING hideTroll();
104592: PPUSH
104593: CALL_OW 559
// wait ( 1 1$00 ) ;
104597: LD_INT 2100
104599: PPUSH
104600: CALL_OW 67
// ToLua ( displayTroll(); ) ;
104604: LD_STRING displayTroll();
104606: PPUSH
104607: CALL_OW 559
// wait ( 1 1$00 ) ;
104611: LD_INT 2100
104613: PPUSH
104614: CALL_OW 67
// ToLua ( hideTroll(); ) ;
104618: LD_STRING hideTroll();
104620: PPUSH
104621: CALL_OW 559
// end ;
104625: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
104626: LD_EXP 124
104630: PUSH
104631: LD_EXP 150
104635: AND
104636: IFFALSE 104699
104638: GO 104640
104640: DISABLE
104641: LD_INT 0
104643: PPUSH
// begin p := 0 ;
104644: LD_ADDR_VAR 0 1
104648: PUSH
104649: LD_INT 0
104651: ST_TO_ADDR
// repeat game_speed := 1 ;
104652: LD_ADDR_OWVAR 65
104656: PUSH
104657: LD_INT 1
104659: ST_TO_ADDR
// wait ( 0 0$1 ) ;
104660: LD_INT 35
104662: PPUSH
104663: CALL_OW 67
// p := p + 1 ;
104667: LD_ADDR_VAR 0 1
104671: PUSH
104672: LD_VAR 0 1
104676: PUSH
104677: LD_INT 1
104679: PLUS
104680: ST_TO_ADDR
// until p >= 60 ;
104681: LD_VAR 0 1
104685: PUSH
104686: LD_INT 60
104688: GREATEREQUAL
104689: IFFALSE 104652
// game_speed := 4 ;
104691: LD_ADDR_OWVAR 65
104695: PUSH
104696: LD_INT 4
104698: ST_TO_ADDR
// end ;
104699: PPOPN 1
104701: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
104702: LD_EXP 124
104706: PUSH
104707: LD_EXP 151
104711: AND
104712: IFFALSE 104858
104714: GO 104716
104716: DISABLE
104717: LD_INT 0
104719: PPUSH
104720: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104721: LD_ADDR_VAR 0 1
104725: PUSH
104726: LD_INT 22
104728: PUSH
104729: LD_OWVAR 2
104733: PUSH
104734: EMPTY
104735: LIST
104736: LIST
104737: PUSH
104738: LD_INT 2
104740: PUSH
104741: LD_INT 30
104743: PUSH
104744: LD_INT 0
104746: PUSH
104747: EMPTY
104748: LIST
104749: LIST
104750: PUSH
104751: LD_INT 30
104753: PUSH
104754: LD_INT 1
104756: PUSH
104757: EMPTY
104758: LIST
104759: LIST
104760: PUSH
104761: EMPTY
104762: LIST
104763: LIST
104764: LIST
104765: PUSH
104766: EMPTY
104767: LIST
104768: LIST
104769: PPUSH
104770: CALL_OW 69
104774: ST_TO_ADDR
// if not depot then
104775: LD_VAR 0 1
104779: NOT
104780: IFFALSE 104784
// exit ;
104782: GO 104858
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
104784: LD_ADDR_VAR 0 2
104788: PUSH
104789: LD_VAR 0 1
104793: PUSH
104794: LD_INT 1
104796: PPUSH
104797: LD_VAR 0 1
104801: PPUSH
104802: CALL_OW 12
104806: ARRAY
104807: PPUSH
104808: CALL_OW 274
104812: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
104813: LD_VAR 0 2
104817: PPUSH
104818: LD_INT 1
104820: PPUSH
104821: LD_INT 0
104823: PPUSH
104824: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
104828: LD_VAR 0 2
104832: PPUSH
104833: LD_INT 2
104835: PPUSH
104836: LD_INT 0
104838: PPUSH
104839: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
104843: LD_VAR 0 2
104847: PPUSH
104848: LD_INT 3
104850: PPUSH
104851: LD_INT 0
104853: PPUSH
104854: CALL_OW 277
// end ;
104858: PPOPN 2
104860: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
104861: LD_EXP 124
104865: PUSH
104866: LD_EXP 152
104870: AND
104871: IFFALSE 104968
104873: GO 104875
104875: DISABLE
104876: LD_INT 0
104878: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104879: LD_ADDR_VAR 0 1
104883: PUSH
104884: LD_INT 22
104886: PUSH
104887: LD_OWVAR 2
104891: PUSH
104892: EMPTY
104893: LIST
104894: LIST
104895: PUSH
104896: LD_INT 21
104898: PUSH
104899: LD_INT 1
104901: PUSH
104902: EMPTY
104903: LIST
104904: LIST
104905: PUSH
104906: LD_INT 3
104908: PUSH
104909: LD_INT 23
104911: PUSH
104912: LD_INT 0
104914: PUSH
104915: EMPTY
104916: LIST
104917: LIST
104918: PUSH
104919: EMPTY
104920: LIST
104921: LIST
104922: PUSH
104923: EMPTY
104924: LIST
104925: LIST
104926: LIST
104927: PPUSH
104928: CALL_OW 69
104932: ST_TO_ADDR
// if not tmp then
104933: LD_VAR 0 1
104937: NOT
104938: IFFALSE 104942
// exit ;
104940: GO 104968
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
104942: LD_VAR 0 1
104946: PUSH
104947: LD_INT 1
104949: PPUSH
104950: LD_VAR 0 1
104954: PPUSH
104955: CALL_OW 12
104959: ARRAY
104960: PPUSH
104961: LD_INT 200
104963: PPUSH
104964: CALL_OW 234
// end ;
104968: PPOPN 1
104970: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
104971: LD_EXP 124
104975: PUSH
104976: LD_EXP 153
104980: AND
104981: IFFALSE 105060
104983: GO 104985
104985: DISABLE
104986: LD_INT 0
104988: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
104989: LD_ADDR_VAR 0 1
104993: PUSH
104994: LD_INT 22
104996: PUSH
104997: LD_OWVAR 2
105001: PUSH
105002: EMPTY
105003: LIST
105004: LIST
105005: PUSH
105006: LD_INT 21
105008: PUSH
105009: LD_INT 2
105011: PUSH
105012: EMPTY
105013: LIST
105014: LIST
105015: PUSH
105016: EMPTY
105017: LIST
105018: LIST
105019: PPUSH
105020: CALL_OW 69
105024: ST_TO_ADDR
// if not tmp then
105025: LD_VAR 0 1
105029: NOT
105030: IFFALSE 105034
// exit ;
105032: GO 105060
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
105034: LD_VAR 0 1
105038: PUSH
105039: LD_INT 1
105041: PPUSH
105042: LD_VAR 0 1
105046: PPUSH
105047: CALL_OW 12
105051: ARRAY
105052: PPUSH
105053: LD_INT 60
105055: PPUSH
105056: CALL_OW 234
// end ;
105060: PPOPN 1
105062: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
105063: LD_EXP 124
105067: PUSH
105068: LD_EXP 154
105072: AND
105073: IFFALSE 105172
105075: GO 105077
105077: DISABLE
105078: LD_INT 0
105080: PPUSH
105081: PPUSH
// begin enable ;
105082: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
105083: LD_ADDR_VAR 0 1
105087: PUSH
105088: LD_INT 22
105090: PUSH
105091: LD_OWVAR 2
105095: PUSH
105096: EMPTY
105097: LIST
105098: LIST
105099: PUSH
105100: LD_INT 61
105102: PUSH
105103: EMPTY
105104: LIST
105105: PUSH
105106: LD_INT 33
105108: PUSH
105109: LD_INT 2
105111: PUSH
105112: EMPTY
105113: LIST
105114: LIST
105115: PUSH
105116: EMPTY
105117: LIST
105118: LIST
105119: LIST
105120: PPUSH
105121: CALL_OW 69
105125: ST_TO_ADDR
// if not tmp then
105126: LD_VAR 0 1
105130: NOT
105131: IFFALSE 105135
// exit ;
105133: GO 105172
// for i in tmp do
105135: LD_ADDR_VAR 0 2
105139: PUSH
105140: LD_VAR 0 1
105144: PUSH
105145: FOR_IN
105146: IFFALSE 105170
// if IsControledBy ( i ) then
105148: LD_VAR 0 2
105152: PPUSH
105153: CALL_OW 312
105157: IFFALSE 105168
// ComUnlink ( i ) ;
105159: LD_VAR 0 2
105163: PPUSH
105164: CALL_OW 136
105168: GO 105145
105170: POP
105171: POP
// end ;
105172: PPOPN 2
105174: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
105175: LD_EXP 124
105179: PUSH
105180: LD_EXP 155
105184: AND
105185: IFFALSE 105325
105187: GO 105189
105189: DISABLE
105190: LD_INT 0
105192: PPUSH
105193: PPUSH
// begin ToLua ( displayPowell(); ) ;
105194: LD_STRING displayPowell();
105196: PPUSH
105197: CALL_OW 559
// uc_side := 0 ;
105201: LD_ADDR_OWVAR 20
105205: PUSH
105206: LD_INT 0
105208: ST_TO_ADDR
// uc_nation := 2 ;
105209: LD_ADDR_OWVAR 21
105213: PUSH
105214: LD_INT 2
105216: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
105217: LD_ADDR_OWVAR 37
105221: PUSH
105222: LD_INT 14
105224: ST_TO_ADDR
// vc_engine := engine_siberite ;
105225: LD_ADDR_OWVAR 39
105229: PUSH
105230: LD_INT 3
105232: ST_TO_ADDR
// vc_control := control_apeman ;
105233: LD_ADDR_OWVAR 38
105237: PUSH
105238: LD_INT 5
105240: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
105241: LD_ADDR_OWVAR 40
105245: PUSH
105246: LD_INT 29
105248: ST_TO_ADDR
// un := CreateVehicle ;
105249: LD_ADDR_VAR 0 2
105253: PUSH
105254: CALL_OW 45
105258: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105259: LD_VAR 0 2
105263: PPUSH
105264: LD_INT 1
105266: PPUSH
105267: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105271: LD_INT 35
105273: PPUSH
105274: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105278: LD_VAR 0 2
105282: PPUSH
105283: LD_INT 22
105285: PUSH
105286: LD_OWVAR 2
105290: PUSH
105291: EMPTY
105292: LIST
105293: LIST
105294: PPUSH
105295: CALL_OW 69
105299: PPUSH
105300: LD_VAR 0 2
105304: PPUSH
105305: CALL_OW 74
105309: PPUSH
105310: CALL_OW 115
// until IsDead ( un ) ;
105314: LD_VAR 0 2
105318: PPUSH
105319: CALL_OW 301
105323: IFFALSE 105271
// end ;
105325: PPOPN 2
105327: END
// every 0 0$1 trigger StreamModeActive and sStu do
105328: LD_EXP 124
105332: PUSH
105333: LD_EXP 163
105337: AND
105338: IFFALSE 105354
105340: GO 105342
105342: DISABLE
// begin ToLua ( displayStucuk(); ) ;
105343: LD_STRING displayStucuk();
105345: PPUSH
105346: CALL_OW 559
// ResetFog ;
105350: CALL_OW 335
// end ;
105354: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
105355: LD_EXP 124
105359: PUSH
105360: LD_EXP 156
105364: AND
105365: IFFALSE 105506
105367: GO 105369
105369: DISABLE
105370: LD_INT 0
105372: PPUSH
105373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105374: LD_ADDR_VAR 0 2
105378: PUSH
105379: LD_INT 22
105381: PUSH
105382: LD_OWVAR 2
105386: PUSH
105387: EMPTY
105388: LIST
105389: LIST
105390: PUSH
105391: LD_INT 21
105393: PUSH
105394: LD_INT 1
105396: PUSH
105397: EMPTY
105398: LIST
105399: LIST
105400: PUSH
105401: EMPTY
105402: LIST
105403: LIST
105404: PPUSH
105405: CALL_OW 69
105409: ST_TO_ADDR
// if not tmp then
105410: LD_VAR 0 2
105414: NOT
105415: IFFALSE 105419
// exit ;
105417: GO 105506
// un := tmp [ rand ( 1 , tmp ) ] ;
105419: LD_ADDR_VAR 0 1
105423: PUSH
105424: LD_VAR 0 2
105428: PUSH
105429: LD_INT 1
105431: PPUSH
105432: LD_VAR 0 2
105436: PPUSH
105437: CALL_OW 12
105441: ARRAY
105442: ST_TO_ADDR
// SetSide ( un , 0 ) ;
105443: LD_VAR 0 1
105447: PPUSH
105448: LD_INT 0
105450: PPUSH
105451: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
105455: LD_VAR 0 1
105459: PPUSH
105460: LD_OWVAR 3
105464: PUSH
105465: LD_VAR 0 1
105469: DIFF
105470: PPUSH
105471: LD_VAR 0 1
105475: PPUSH
105476: CALL_OW 74
105480: PPUSH
105481: CALL_OW 115
// wait ( 0 0$20 ) ;
105485: LD_INT 700
105487: PPUSH
105488: CALL_OW 67
// SetSide ( un , your_side ) ;
105492: LD_VAR 0 1
105496: PPUSH
105497: LD_OWVAR 2
105501: PPUSH
105502: CALL_OW 235
// end ;
105506: PPOPN 2
105508: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
105509: LD_EXP 124
105513: PUSH
105514: LD_EXP 157
105518: AND
105519: IFFALSE 105625
105521: GO 105523
105523: DISABLE
105524: LD_INT 0
105526: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105527: LD_ADDR_VAR 0 1
105531: PUSH
105532: LD_INT 22
105534: PUSH
105535: LD_OWVAR 2
105539: PUSH
105540: EMPTY
105541: LIST
105542: LIST
105543: PUSH
105544: LD_INT 2
105546: PUSH
105547: LD_INT 30
105549: PUSH
105550: LD_INT 0
105552: PUSH
105553: EMPTY
105554: LIST
105555: LIST
105556: PUSH
105557: LD_INT 30
105559: PUSH
105560: LD_INT 1
105562: PUSH
105563: EMPTY
105564: LIST
105565: LIST
105566: PUSH
105567: EMPTY
105568: LIST
105569: LIST
105570: LIST
105571: PUSH
105572: EMPTY
105573: LIST
105574: LIST
105575: PPUSH
105576: CALL_OW 69
105580: ST_TO_ADDR
// if not depot then
105581: LD_VAR 0 1
105585: NOT
105586: IFFALSE 105590
// exit ;
105588: GO 105625
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
105590: LD_VAR 0 1
105594: PUSH
105595: LD_INT 1
105597: ARRAY
105598: PPUSH
105599: CALL_OW 250
105603: PPUSH
105604: LD_VAR 0 1
105608: PUSH
105609: LD_INT 1
105611: ARRAY
105612: PPUSH
105613: CALL_OW 251
105617: PPUSH
105618: LD_INT 70
105620: PPUSH
105621: CALL_OW 495
// end ;
105625: PPOPN 1
105627: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
105628: LD_EXP 124
105632: PUSH
105633: LD_EXP 158
105637: AND
105638: IFFALSE 105849
105640: GO 105642
105642: DISABLE
105643: LD_INT 0
105645: PPUSH
105646: PPUSH
105647: PPUSH
105648: PPUSH
105649: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105650: LD_ADDR_VAR 0 5
105654: PUSH
105655: LD_INT 22
105657: PUSH
105658: LD_OWVAR 2
105662: PUSH
105663: EMPTY
105664: LIST
105665: LIST
105666: PUSH
105667: LD_INT 21
105669: PUSH
105670: LD_INT 1
105672: PUSH
105673: EMPTY
105674: LIST
105675: LIST
105676: PUSH
105677: EMPTY
105678: LIST
105679: LIST
105680: PPUSH
105681: CALL_OW 69
105685: ST_TO_ADDR
// if not tmp then
105686: LD_VAR 0 5
105690: NOT
105691: IFFALSE 105695
// exit ;
105693: GO 105849
// for i in tmp do
105695: LD_ADDR_VAR 0 1
105699: PUSH
105700: LD_VAR 0 5
105704: PUSH
105705: FOR_IN
105706: IFFALSE 105847
// begin d := rand ( 0 , 5 ) ;
105708: LD_ADDR_VAR 0 4
105712: PUSH
105713: LD_INT 0
105715: PPUSH
105716: LD_INT 5
105718: PPUSH
105719: CALL_OW 12
105723: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
105724: LD_ADDR_VAR 0 2
105728: PUSH
105729: LD_VAR 0 1
105733: PPUSH
105734: CALL_OW 250
105738: PPUSH
105739: LD_VAR 0 4
105743: PPUSH
105744: LD_INT 3
105746: PPUSH
105747: LD_INT 12
105749: PPUSH
105750: CALL_OW 12
105754: PPUSH
105755: CALL_OW 272
105759: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
105760: LD_ADDR_VAR 0 3
105764: PUSH
105765: LD_VAR 0 1
105769: PPUSH
105770: CALL_OW 251
105774: PPUSH
105775: LD_VAR 0 4
105779: PPUSH
105780: LD_INT 3
105782: PPUSH
105783: LD_INT 12
105785: PPUSH
105786: CALL_OW 12
105790: PPUSH
105791: CALL_OW 273
105795: ST_TO_ADDR
// if ValidHex ( x , y ) then
105796: LD_VAR 0 2
105800: PPUSH
105801: LD_VAR 0 3
105805: PPUSH
105806: CALL_OW 488
105810: IFFALSE 105845
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
105812: LD_VAR 0 1
105816: PPUSH
105817: LD_VAR 0 2
105821: PPUSH
105822: LD_VAR 0 3
105826: PPUSH
105827: LD_INT 3
105829: PPUSH
105830: LD_INT 6
105832: PPUSH
105833: CALL_OW 12
105837: PPUSH
105838: LD_INT 1
105840: PPUSH
105841: CALL_OW 483
// end ;
105845: GO 105705
105847: POP
105848: POP
// end ;
105849: PPOPN 5
105851: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
105852: LD_EXP 124
105856: PUSH
105857: LD_EXP 159
105861: AND
105862: IFFALSE 105956
105864: GO 105866
105866: DISABLE
105867: LD_INT 0
105869: PPUSH
105870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
105871: LD_ADDR_VAR 0 2
105875: PUSH
105876: LD_INT 22
105878: PUSH
105879: LD_OWVAR 2
105883: PUSH
105884: EMPTY
105885: LIST
105886: LIST
105887: PUSH
105888: LD_INT 32
105890: PUSH
105891: LD_INT 1
105893: PUSH
105894: EMPTY
105895: LIST
105896: LIST
105897: PUSH
105898: LD_INT 21
105900: PUSH
105901: LD_INT 2
105903: PUSH
105904: EMPTY
105905: LIST
105906: LIST
105907: PUSH
105908: EMPTY
105909: LIST
105910: LIST
105911: LIST
105912: PPUSH
105913: CALL_OW 69
105917: ST_TO_ADDR
// if not tmp then
105918: LD_VAR 0 2
105922: NOT
105923: IFFALSE 105927
// exit ;
105925: GO 105956
// for i in tmp do
105927: LD_ADDR_VAR 0 1
105931: PUSH
105932: LD_VAR 0 2
105936: PUSH
105937: FOR_IN
105938: IFFALSE 105954
// SetFuel ( i , 0 ) ;
105940: LD_VAR 0 1
105944: PPUSH
105945: LD_INT 0
105947: PPUSH
105948: CALL_OW 240
105952: GO 105937
105954: POP
105955: POP
// end ;
105956: PPOPN 2
105958: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
105959: LD_EXP 124
105963: PUSH
105964: LD_EXP 160
105968: AND
105969: IFFALSE 106035
105971: GO 105973
105973: DISABLE
105974: LD_INT 0
105976: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105977: LD_ADDR_VAR 0 1
105981: PUSH
105982: LD_INT 22
105984: PUSH
105985: LD_OWVAR 2
105989: PUSH
105990: EMPTY
105991: LIST
105992: LIST
105993: PUSH
105994: LD_INT 30
105996: PUSH
105997: LD_INT 29
105999: PUSH
106000: EMPTY
106001: LIST
106002: LIST
106003: PUSH
106004: EMPTY
106005: LIST
106006: LIST
106007: PPUSH
106008: CALL_OW 69
106012: ST_TO_ADDR
// if not tmp then
106013: LD_VAR 0 1
106017: NOT
106018: IFFALSE 106022
// exit ;
106020: GO 106035
// DestroyUnit ( tmp [ 1 ] ) ;
106022: LD_VAR 0 1
106026: PUSH
106027: LD_INT 1
106029: ARRAY
106030: PPUSH
106031: CALL_OW 65
// end ;
106035: PPOPN 1
106037: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
106038: LD_EXP 124
106042: PUSH
106043: LD_EXP 162
106047: AND
106048: IFFALSE 106177
106050: GO 106052
106052: DISABLE
106053: LD_INT 0
106055: PPUSH
// begin uc_side := 0 ;
106056: LD_ADDR_OWVAR 20
106060: PUSH
106061: LD_INT 0
106063: ST_TO_ADDR
// uc_nation := nation_arabian ;
106064: LD_ADDR_OWVAR 21
106068: PUSH
106069: LD_INT 2
106071: ST_TO_ADDR
// hc_gallery :=  ;
106072: LD_ADDR_OWVAR 33
106076: PUSH
106077: LD_STRING 
106079: ST_TO_ADDR
// hc_name :=  ;
106080: LD_ADDR_OWVAR 26
106084: PUSH
106085: LD_STRING 
106087: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
106088: LD_INT 1
106090: PPUSH
106091: LD_INT 11
106093: PPUSH
106094: LD_INT 10
106096: PPUSH
106097: CALL_OW 380
// un := CreateHuman ;
106101: LD_ADDR_VAR 0 1
106105: PUSH
106106: CALL_OW 44
106110: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106111: LD_VAR 0 1
106115: PPUSH
106116: LD_INT 1
106118: PPUSH
106119: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
106123: LD_INT 35
106125: PPUSH
106126: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
106130: LD_VAR 0 1
106134: PPUSH
106135: LD_INT 22
106137: PUSH
106138: LD_OWVAR 2
106142: PUSH
106143: EMPTY
106144: LIST
106145: LIST
106146: PPUSH
106147: CALL_OW 69
106151: PPUSH
106152: LD_VAR 0 1
106156: PPUSH
106157: CALL_OW 74
106161: PPUSH
106162: CALL_OW 115
// until IsDead ( un ) ;
106166: LD_VAR 0 1
106170: PPUSH
106171: CALL_OW 301
106175: IFFALSE 106123
// end ;
106177: PPOPN 1
106179: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
106180: LD_EXP 124
106184: PUSH
106185: LD_EXP 164
106189: AND
106190: IFFALSE 106202
106192: GO 106194
106194: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
106195: LD_STRING earthquake(getX(game), 0, 32)
106197: PPUSH
106198: CALL_OW 559
106202: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
106203: LD_EXP 124
106207: PUSH
106208: LD_EXP 165
106212: AND
106213: IFFALSE 106304
106215: GO 106217
106217: DISABLE
106218: LD_INT 0
106220: PPUSH
// begin enable ;
106221: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
106222: LD_ADDR_VAR 0 1
106226: PUSH
106227: LD_INT 22
106229: PUSH
106230: LD_OWVAR 2
106234: PUSH
106235: EMPTY
106236: LIST
106237: LIST
106238: PUSH
106239: LD_INT 21
106241: PUSH
106242: LD_INT 2
106244: PUSH
106245: EMPTY
106246: LIST
106247: LIST
106248: PUSH
106249: LD_INT 33
106251: PUSH
106252: LD_INT 3
106254: PUSH
106255: EMPTY
106256: LIST
106257: LIST
106258: PUSH
106259: EMPTY
106260: LIST
106261: LIST
106262: LIST
106263: PPUSH
106264: CALL_OW 69
106268: ST_TO_ADDR
// if not tmp then
106269: LD_VAR 0 1
106273: NOT
106274: IFFALSE 106278
// exit ;
106276: GO 106304
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
106278: LD_VAR 0 1
106282: PUSH
106283: LD_INT 1
106285: PPUSH
106286: LD_VAR 0 1
106290: PPUSH
106291: CALL_OW 12
106295: ARRAY
106296: PPUSH
106297: LD_INT 1
106299: PPUSH
106300: CALL_OW 234
// end ;
106304: PPOPN 1
106306: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
106307: LD_EXP 124
106311: PUSH
106312: LD_EXP 166
106316: AND
106317: IFFALSE 106458
106319: GO 106321
106321: DISABLE
106322: LD_INT 0
106324: PPUSH
106325: PPUSH
106326: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106327: LD_ADDR_VAR 0 3
106331: PUSH
106332: LD_INT 22
106334: PUSH
106335: LD_OWVAR 2
106339: PUSH
106340: EMPTY
106341: LIST
106342: LIST
106343: PUSH
106344: LD_INT 25
106346: PUSH
106347: LD_INT 1
106349: PUSH
106350: EMPTY
106351: LIST
106352: LIST
106353: PUSH
106354: EMPTY
106355: LIST
106356: LIST
106357: PPUSH
106358: CALL_OW 69
106362: ST_TO_ADDR
// if not tmp then
106363: LD_VAR 0 3
106367: NOT
106368: IFFALSE 106372
// exit ;
106370: GO 106458
// un := tmp [ rand ( 1 , tmp ) ] ;
106372: LD_ADDR_VAR 0 2
106376: PUSH
106377: LD_VAR 0 3
106381: PUSH
106382: LD_INT 1
106384: PPUSH
106385: LD_VAR 0 3
106389: PPUSH
106390: CALL_OW 12
106394: ARRAY
106395: ST_TO_ADDR
// if Crawls ( un ) then
106396: LD_VAR 0 2
106400: PPUSH
106401: CALL_OW 318
106405: IFFALSE 106416
// ComWalk ( un ) ;
106407: LD_VAR 0 2
106411: PPUSH
106412: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
106416: LD_VAR 0 2
106420: PPUSH
106421: LD_INT 9
106423: PPUSH
106424: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
106428: LD_INT 28
106430: PPUSH
106431: LD_OWVAR 2
106435: PPUSH
106436: LD_INT 2
106438: PPUSH
106439: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
106443: LD_INT 29
106445: PPUSH
106446: LD_OWVAR 2
106450: PPUSH
106451: LD_INT 2
106453: PPUSH
106454: CALL_OW 322
// end ;
106458: PPOPN 3
106460: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
106461: LD_EXP 124
106465: PUSH
106466: LD_EXP 167
106470: AND
106471: IFFALSE 106582
106473: GO 106475
106475: DISABLE
106476: LD_INT 0
106478: PPUSH
106479: PPUSH
106480: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106481: LD_ADDR_VAR 0 3
106485: PUSH
106486: LD_INT 22
106488: PUSH
106489: LD_OWVAR 2
106493: PUSH
106494: EMPTY
106495: LIST
106496: LIST
106497: PUSH
106498: LD_INT 25
106500: PUSH
106501: LD_INT 1
106503: PUSH
106504: EMPTY
106505: LIST
106506: LIST
106507: PUSH
106508: EMPTY
106509: LIST
106510: LIST
106511: PPUSH
106512: CALL_OW 69
106516: ST_TO_ADDR
// if not tmp then
106517: LD_VAR 0 3
106521: NOT
106522: IFFALSE 106526
// exit ;
106524: GO 106582
// un := tmp [ rand ( 1 , tmp ) ] ;
106526: LD_ADDR_VAR 0 2
106530: PUSH
106531: LD_VAR 0 3
106535: PUSH
106536: LD_INT 1
106538: PPUSH
106539: LD_VAR 0 3
106543: PPUSH
106544: CALL_OW 12
106548: ARRAY
106549: ST_TO_ADDR
// if Crawls ( un ) then
106550: LD_VAR 0 2
106554: PPUSH
106555: CALL_OW 318
106559: IFFALSE 106570
// ComWalk ( un ) ;
106561: LD_VAR 0 2
106565: PPUSH
106566: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106570: LD_VAR 0 2
106574: PPUSH
106575: LD_INT 8
106577: PPUSH
106578: CALL_OW 336
// end ;
106582: PPOPN 3
106584: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
106585: LD_EXP 124
106589: PUSH
106590: LD_EXP 168
106594: AND
106595: IFFALSE 106739
106597: GO 106599
106599: DISABLE
106600: LD_INT 0
106602: PPUSH
106603: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
106604: LD_ADDR_VAR 0 2
106608: PUSH
106609: LD_INT 22
106611: PUSH
106612: LD_OWVAR 2
106616: PUSH
106617: EMPTY
106618: LIST
106619: LIST
106620: PUSH
106621: LD_INT 21
106623: PUSH
106624: LD_INT 2
106626: PUSH
106627: EMPTY
106628: LIST
106629: LIST
106630: PUSH
106631: LD_INT 2
106633: PUSH
106634: LD_INT 34
106636: PUSH
106637: LD_INT 12
106639: PUSH
106640: EMPTY
106641: LIST
106642: LIST
106643: PUSH
106644: LD_INT 34
106646: PUSH
106647: LD_INT 51
106649: PUSH
106650: EMPTY
106651: LIST
106652: LIST
106653: PUSH
106654: LD_INT 34
106656: PUSH
106657: LD_INT 32
106659: PUSH
106660: EMPTY
106661: LIST
106662: LIST
106663: PUSH
106664: EMPTY
106665: LIST
106666: LIST
106667: LIST
106668: LIST
106669: PUSH
106670: EMPTY
106671: LIST
106672: LIST
106673: LIST
106674: PPUSH
106675: CALL_OW 69
106679: ST_TO_ADDR
// if not tmp then
106680: LD_VAR 0 2
106684: NOT
106685: IFFALSE 106689
// exit ;
106687: GO 106739
// for i in tmp do
106689: LD_ADDR_VAR 0 1
106693: PUSH
106694: LD_VAR 0 2
106698: PUSH
106699: FOR_IN
106700: IFFALSE 106737
// if GetCargo ( i , mat_artifact ) = 0 then
106702: LD_VAR 0 1
106706: PPUSH
106707: LD_INT 4
106709: PPUSH
106710: CALL_OW 289
106714: PUSH
106715: LD_INT 0
106717: EQUAL
106718: IFFALSE 106735
// SetCargo ( i , mat_siberit , 100 ) ;
106720: LD_VAR 0 1
106724: PPUSH
106725: LD_INT 3
106727: PPUSH
106728: LD_INT 100
106730: PPUSH
106731: CALL_OW 290
106735: GO 106699
106737: POP
106738: POP
// end ;
106739: PPOPN 2
106741: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
106742: LD_EXP 124
106746: PUSH
106747: LD_EXP 169
106751: AND
106752: IFFALSE 106935
106754: GO 106756
106756: DISABLE
106757: LD_INT 0
106759: PPUSH
106760: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106761: LD_ADDR_VAR 0 2
106765: PUSH
106766: LD_INT 22
106768: PUSH
106769: LD_OWVAR 2
106773: PUSH
106774: EMPTY
106775: LIST
106776: LIST
106777: PPUSH
106778: CALL_OW 69
106782: ST_TO_ADDR
// if not tmp then
106783: LD_VAR 0 2
106787: NOT
106788: IFFALSE 106792
// exit ;
106790: GO 106935
// for i := 1 to 2 do
106792: LD_ADDR_VAR 0 1
106796: PUSH
106797: DOUBLE
106798: LD_INT 1
106800: DEC
106801: ST_TO_ADDR
106802: LD_INT 2
106804: PUSH
106805: FOR_TO
106806: IFFALSE 106933
// begin uc_side := your_side ;
106808: LD_ADDR_OWVAR 20
106812: PUSH
106813: LD_OWVAR 2
106817: ST_TO_ADDR
// uc_nation := nation_american ;
106818: LD_ADDR_OWVAR 21
106822: PUSH
106823: LD_INT 1
106825: ST_TO_ADDR
// vc_chassis := us_morphling ;
106826: LD_ADDR_OWVAR 37
106830: PUSH
106831: LD_INT 5
106833: ST_TO_ADDR
// vc_engine := engine_siberite ;
106834: LD_ADDR_OWVAR 39
106838: PUSH
106839: LD_INT 3
106841: ST_TO_ADDR
// vc_control := control_computer ;
106842: LD_ADDR_OWVAR 38
106846: PUSH
106847: LD_INT 3
106849: ST_TO_ADDR
// vc_weapon := us_double_laser ;
106850: LD_ADDR_OWVAR 40
106854: PUSH
106855: LD_INT 10
106857: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
106858: LD_VAR 0 2
106862: PUSH
106863: LD_INT 1
106865: ARRAY
106866: PPUSH
106867: CALL_OW 310
106871: NOT
106872: IFFALSE 106919
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
106874: CALL_OW 45
106878: PPUSH
106879: LD_VAR 0 2
106883: PUSH
106884: LD_INT 1
106886: ARRAY
106887: PPUSH
106888: CALL_OW 250
106892: PPUSH
106893: LD_VAR 0 2
106897: PUSH
106898: LD_INT 1
106900: ARRAY
106901: PPUSH
106902: CALL_OW 251
106906: PPUSH
106907: LD_INT 12
106909: PPUSH
106910: LD_INT 1
106912: PPUSH
106913: CALL_OW 50
106917: GO 106931
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
106919: CALL_OW 45
106923: PPUSH
106924: LD_INT 1
106926: PPUSH
106927: CALL_OW 51
// end ;
106931: GO 106805
106933: POP
106934: POP
// end ;
106935: PPOPN 2
106937: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
106938: LD_EXP 124
106942: PUSH
106943: LD_EXP 170
106947: AND
106948: IFFALSE 107170
106950: GO 106952
106952: DISABLE
106953: LD_INT 0
106955: PPUSH
106956: PPUSH
106957: PPUSH
106958: PPUSH
106959: PPUSH
106960: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106961: LD_ADDR_VAR 0 6
106965: PUSH
106966: LD_INT 22
106968: PUSH
106969: LD_OWVAR 2
106973: PUSH
106974: EMPTY
106975: LIST
106976: LIST
106977: PUSH
106978: LD_INT 21
106980: PUSH
106981: LD_INT 1
106983: PUSH
106984: EMPTY
106985: LIST
106986: LIST
106987: PUSH
106988: LD_INT 3
106990: PUSH
106991: LD_INT 23
106993: PUSH
106994: LD_INT 0
106996: PUSH
106997: EMPTY
106998: LIST
106999: LIST
107000: PUSH
107001: EMPTY
107002: LIST
107003: LIST
107004: PUSH
107005: EMPTY
107006: LIST
107007: LIST
107008: LIST
107009: PPUSH
107010: CALL_OW 69
107014: ST_TO_ADDR
// if not tmp then
107015: LD_VAR 0 6
107019: NOT
107020: IFFALSE 107024
// exit ;
107022: GO 107170
// s1 := rand ( 1 , 4 ) ;
107024: LD_ADDR_VAR 0 2
107028: PUSH
107029: LD_INT 1
107031: PPUSH
107032: LD_INT 4
107034: PPUSH
107035: CALL_OW 12
107039: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
107040: LD_ADDR_VAR 0 4
107044: PUSH
107045: LD_VAR 0 6
107049: PUSH
107050: LD_INT 1
107052: ARRAY
107053: PPUSH
107054: LD_VAR 0 2
107058: PPUSH
107059: CALL_OW 259
107063: ST_TO_ADDR
// if s1 = 1 then
107064: LD_VAR 0 2
107068: PUSH
107069: LD_INT 1
107071: EQUAL
107072: IFFALSE 107092
// s2 := rand ( 2 , 4 ) else
107074: LD_ADDR_VAR 0 3
107078: PUSH
107079: LD_INT 2
107081: PPUSH
107082: LD_INT 4
107084: PPUSH
107085: CALL_OW 12
107089: ST_TO_ADDR
107090: GO 107100
// s2 := 1 ;
107092: LD_ADDR_VAR 0 3
107096: PUSH
107097: LD_INT 1
107099: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
107100: LD_ADDR_VAR 0 5
107104: PUSH
107105: LD_VAR 0 6
107109: PUSH
107110: LD_INT 1
107112: ARRAY
107113: PPUSH
107114: LD_VAR 0 3
107118: PPUSH
107119: CALL_OW 259
107123: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
107124: LD_VAR 0 6
107128: PUSH
107129: LD_INT 1
107131: ARRAY
107132: PPUSH
107133: LD_VAR 0 2
107137: PPUSH
107138: LD_VAR 0 5
107142: PPUSH
107143: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
107147: LD_VAR 0 6
107151: PUSH
107152: LD_INT 1
107154: ARRAY
107155: PPUSH
107156: LD_VAR 0 3
107160: PPUSH
107161: LD_VAR 0 4
107165: PPUSH
107166: CALL_OW 237
// end ;
107170: PPOPN 6
107172: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
107173: LD_EXP 124
107177: PUSH
107178: LD_EXP 171
107182: AND
107183: IFFALSE 107262
107185: GO 107187
107187: DISABLE
107188: LD_INT 0
107190: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
107191: LD_ADDR_VAR 0 1
107195: PUSH
107196: LD_INT 22
107198: PUSH
107199: LD_OWVAR 2
107203: PUSH
107204: EMPTY
107205: LIST
107206: LIST
107207: PUSH
107208: LD_INT 30
107210: PUSH
107211: LD_INT 3
107213: PUSH
107214: EMPTY
107215: LIST
107216: LIST
107217: PUSH
107218: EMPTY
107219: LIST
107220: LIST
107221: PPUSH
107222: CALL_OW 69
107226: ST_TO_ADDR
// if not tmp then
107227: LD_VAR 0 1
107231: NOT
107232: IFFALSE 107236
// exit ;
107234: GO 107262
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
107236: LD_VAR 0 1
107240: PUSH
107241: LD_INT 1
107243: PPUSH
107244: LD_VAR 0 1
107248: PPUSH
107249: CALL_OW 12
107253: ARRAY
107254: PPUSH
107255: LD_INT 1
107257: PPUSH
107258: CALL_OW 234
// end ;
107262: PPOPN 1
107264: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
107265: LD_EXP 124
107269: PUSH
107270: LD_EXP 172
107274: AND
107275: IFFALSE 107387
107277: GO 107279
107279: DISABLE
107280: LD_INT 0
107282: PPUSH
107283: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
107284: LD_ADDR_VAR 0 2
107288: PUSH
107289: LD_INT 22
107291: PUSH
107292: LD_OWVAR 2
107296: PUSH
107297: EMPTY
107298: LIST
107299: LIST
107300: PUSH
107301: LD_INT 2
107303: PUSH
107304: LD_INT 30
107306: PUSH
107307: LD_INT 27
107309: PUSH
107310: EMPTY
107311: LIST
107312: LIST
107313: PUSH
107314: LD_INT 30
107316: PUSH
107317: LD_INT 26
107319: PUSH
107320: EMPTY
107321: LIST
107322: LIST
107323: PUSH
107324: LD_INT 30
107326: PUSH
107327: LD_INT 28
107329: PUSH
107330: EMPTY
107331: LIST
107332: LIST
107333: PUSH
107334: EMPTY
107335: LIST
107336: LIST
107337: LIST
107338: LIST
107339: PUSH
107340: EMPTY
107341: LIST
107342: LIST
107343: PPUSH
107344: CALL_OW 69
107348: ST_TO_ADDR
// if not tmp then
107349: LD_VAR 0 2
107353: NOT
107354: IFFALSE 107358
// exit ;
107356: GO 107387
// for i in tmp do
107358: LD_ADDR_VAR 0 1
107362: PUSH
107363: LD_VAR 0 2
107367: PUSH
107368: FOR_IN
107369: IFFALSE 107385
// SetLives ( i , 1 ) ;
107371: LD_VAR 0 1
107375: PPUSH
107376: LD_INT 1
107378: PPUSH
107379: CALL_OW 234
107383: GO 107368
107385: POP
107386: POP
// end ;
107387: PPOPN 2
107389: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
107390: LD_EXP 124
107394: PUSH
107395: LD_EXP 173
107399: AND
107400: IFFALSE 107687
107402: GO 107404
107404: DISABLE
107405: LD_INT 0
107407: PPUSH
107408: PPUSH
107409: PPUSH
// begin i := rand ( 1 , 7 ) ;
107410: LD_ADDR_VAR 0 1
107414: PUSH
107415: LD_INT 1
107417: PPUSH
107418: LD_INT 7
107420: PPUSH
107421: CALL_OW 12
107425: ST_TO_ADDR
// case i of 1 :
107426: LD_VAR 0 1
107430: PUSH
107431: LD_INT 1
107433: DOUBLE
107434: EQUAL
107435: IFTRUE 107439
107437: GO 107449
107439: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
107440: LD_STRING earthquake(getX(game), 0, 32)
107442: PPUSH
107443: CALL_OW 559
107447: GO 107687
107449: LD_INT 2
107451: DOUBLE
107452: EQUAL
107453: IFTRUE 107457
107455: GO 107471
107457: POP
// begin ToLua ( displayStucuk(); ) ;
107458: LD_STRING displayStucuk();
107460: PPUSH
107461: CALL_OW 559
// ResetFog ;
107465: CALL_OW 335
// end ; 3 :
107469: GO 107687
107471: LD_INT 3
107473: DOUBLE
107474: EQUAL
107475: IFTRUE 107479
107477: GO 107583
107479: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107480: LD_ADDR_VAR 0 2
107484: PUSH
107485: LD_INT 22
107487: PUSH
107488: LD_OWVAR 2
107492: PUSH
107493: EMPTY
107494: LIST
107495: LIST
107496: PUSH
107497: LD_INT 25
107499: PUSH
107500: LD_INT 1
107502: PUSH
107503: EMPTY
107504: LIST
107505: LIST
107506: PUSH
107507: EMPTY
107508: LIST
107509: LIST
107510: PPUSH
107511: CALL_OW 69
107515: ST_TO_ADDR
// if not tmp then
107516: LD_VAR 0 2
107520: NOT
107521: IFFALSE 107525
// exit ;
107523: GO 107687
// un := tmp [ rand ( 1 , tmp ) ] ;
107525: LD_ADDR_VAR 0 3
107529: PUSH
107530: LD_VAR 0 2
107534: PUSH
107535: LD_INT 1
107537: PPUSH
107538: LD_VAR 0 2
107542: PPUSH
107543: CALL_OW 12
107547: ARRAY
107548: ST_TO_ADDR
// if Crawls ( un ) then
107549: LD_VAR 0 3
107553: PPUSH
107554: CALL_OW 318
107558: IFFALSE 107569
// ComWalk ( un ) ;
107560: LD_VAR 0 3
107564: PPUSH
107565: CALL_OW 138
// SetClass ( un , class_mortar ) ;
107569: LD_VAR 0 3
107573: PPUSH
107574: LD_INT 8
107576: PPUSH
107577: CALL_OW 336
// end ; 4 :
107581: GO 107687
107583: LD_INT 4
107585: DOUBLE
107586: EQUAL
107587: IFTRUE 107591
107589: GO 107665
107591: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
107592: LD_ADDR_VAR 0 2
107596: PUSH
107597: LD_INT 22
107599: PUSH
107600: LD_OWVAR 2
107604: PUSH
107605: EMPTY
107606: LIST
107607: LIST
107608: PUSH
107609: LD_INT 30
107611: PUSH
107612: LD_INT 29
107614: PUSH
107615: EMPTY
107616: LIST
107617: LIST
107618: PUSH
107619: EMPTY
107620: LIST
107621: LIST
107622: PPUSH
107623: CALL_OW 69
107627: ST_TO_ADDR
// if not tmp then
107628: LD_VAR 0 2
107632: NOT
107633: IFFALSE 107637
// exit ;
107635: GO 107687
// CenterNowOnUnits ( tmp [ 1 ] ) ;
107637: LD_VAR 0 2
107641: PUSH
107642: LD_INT 1
107644: ARRAY
107645: PPUSH
107646: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
107650: LD_VAR 0 2
107654: PUSH
107655: LD_INT 1
107657: ARRAY
107658: PPUSH
107659: CALL_OW 65
// end ; 5 .. 7 :
107663: GO 107687
107665: LD_INT 5
107667: DOUBLE
107668: GREATEREQUAL
107669: IFFALSE 107677
107671: LD_INT 7
107673: DOUBLE
107674: LESSEQUAL
107675: IFTRUE 107679
107677: GO 107686
107679: POP
// StreamSibBomb ; end ;
107680: CALL 103924 0 0
107684: GO 107687
107686: POP
// end ;
107687: PPOPN 3
107689: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
107690: LD_EXP 124
107694: PUSH
107695: LD_EXP 174
107699: AND
107700: IFFALSE 107856
107702: GO 107704
107704: DISABLE
107705: LD_INT 0
107707: PPUSH
107708: PPUSH
107709: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
107710: LD_ADDR_VAR 0 2
107714: PUSH
107715: LD_INT 81
107717: PUSH
107718: LD_OWVAR 2
107722: PUSH
107723: EMPTY
107724: LIST
107725: LIST
107726: PUSH
107727: LD_INT 2
107729: PUSH
107730: LD_INT 21
107732: PUSH
107733: LD_INT 1
107735: PUSH
107736: EMPTY
107737: LIST
107738: LIST
107739: PUSH
107740: LD_INT 21
107742: PUSH
107743: LD_INT 2
107745: PUSH
107746: EMPTY
107747: LIST
107748: LIST
107749: PUSH
107750: EMPTY
107751: LIST
107752: LIST
107753: LIST
107754: PUSH
107755: EMPTY
107756: LIST
107757: LIST
107758: PPUSH
107759: CALL_OW 69
107763: ST_TO_ADDR
// if not tmp then
107764: LD_VAR 0 2
107768: NOT
107769: IFFALSE 107773
// exit ;
107771: GO 107856
// p := 0 ;
107773: LD_ADDR_VAR 0 3
107777: PUSH
107778: LD_INT 0
107780: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
107781: LD_INT 35
107783: PPUSH
107784: CALL_OW 67
// p := p + 1 ;
107788: LD_ADDR_VAR 0 3
107792: PUSH
107793: LD_VAR 0 3
107797: PUSH
107798: LD_INT 1
107800: PLUS
107801: ST_TO_ADDR
// for i in tmp do
107802: LD_ADDR_VAR 0 1
107806: PUSH
107807: LD_VAR 0 2
107811: PUSH
107812: FOR_IN
107813: IFFALSE 107844
// if GetLives ( i ) < 1000 then
107815: LD_VAR 0 1
107819: PPUSH
107820: CALL_OW 256
107824: PUSH
107825: LD_INT 1000
107827: LESS
107828: IFFALSE 107842
// SetLives ( i , 1000 ) ;
107830: LD_VAR 0 1
107834: PPUSH
107835: LD_INT 1000
107837: PPUSH
107838: CALL_OW 234
107842: GO 107812
107844: POP
107845: POP
// until p > 20 ;
107846: LD_VAR 0 3
107850: PUSH
107851: LD_INT 20
107853: GREATER
107854: IFFALSE 107781
// end ;
107856: PPOPN 3
107858: END
// every 0 0$1 trigger StreamModeActive and sTime do
107859: LD_EXP 124
107863: PUSH
107864: LD_EXP 175
107868: AND
107869: IFFALSE 107904
107871: GO 107873
107873: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
107874: LD_INT 28
107876: PPUSH
107877: LD_OWVAR 2
107881: PPUSH
107882: LD_INT 2
107884: PPUSH
107885: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
107889: LD_INT 30
107891: PPUSH
107892: LD_OWVAR 2
107896: PPUSH
107897: LD_INT 2
107899: PPUSH
107900: CALL_OW 322
// end ;
107904: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
107905: LD_EXP 124
107909: PUSH
107910: LD_EXP 176
107914: AND
107915: IFFALSE 108036
107917: GO 107919
107919: DISABLE
107920: LD_INT 0
107922: PPUSH
107923: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
107924: LD_ADDR_VAR 0 2
107928: PUSH
107929: LD_INT 22
107931: PUSH
107932: LD_OWVAR 2
107936: PUSH
107937: EMPTY
107938: LIST
107939: LIST
107940: PUSH
107941: LD_INT 21
107943: PUSH
107944: LD_INT 1
107946: PUSH
107947: EMPTY
107948: LIST
107949: LIST
107950: PUSH
107951: LD_INT 3
107953: PUSH
107954: LD_INT 23
107956: PUSH
107957: LD_INT 0
107959: PUSH
107960: EMPTY
107961: LIST
107962: LIST
107963: PUSH
107964: EMPTY
107965: LIST
107966: LIST
107967: PUSH
107968: EMPTY
107969: LIST
107970: LIST
107971: LIST
107972: PPUSH
107973: CALL_OW 69
107977: ST_TO_ADDR
// if not tmp then
107978: LD_VAR 0 2
107982: NOT
107983: IFFALSE 107987
// exit ;
107985: GO 108036
// for i in tmp do
107987: LD_ADDR_VAR 0 1
107991: PUSH
107992: LD_VAR 0 2
107996: PUSH
107997: FOR_IN
107998: IFFALSE 108034
// begin if Crawls ( i ) then
108000: LD_VAR 0 1
108004: PPUSH
108005: CALL_OW 318
108009: IFFALSE 108020
// ComWalk ( i ) ;
108011: LD_VAR 0 1
108015: PPUSH
108016: CALL_OW 138
// SetClass ( i , 2 ) ;
108020: LD_VAR 0 1
108024: PPUSH
108025: LD_INT 2
108027: PPUSH
108028: CALL_OW 336
// end ;
108032: GO 107997
108034: POP
108035: POP
// end ;
108036: PPOPN 2
108038: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
108039: LD_EXP 124
108043: PUSH
108044: LD_EXP 177
108048: AND
108049: IFFALSE 108337
108051: GO 108053
108053: DISABLE
108054: LD_INT 0
108056: PPUSH
108057: PPUSH
108058: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
108059: LD_OWVAR 2
108063: PPUSH
108064: LD_INT 9
108066: PPUSH
108067: LD_INT 1
108069: PPUSH
108070: LD_INT 1
108072: PPUSH
108073: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
108077: LD_INT 9
108079: PPUSH
108080: LD_OWVAR 2
108084: PPUSH
108085: CALL_OW 343
// uc_side := 9 ;
108089: LD_ADDR_OWVAR 20
108093: PUSH
108094: LD_INT 9
108096: ST_TO_ADDR
// uc_nation := 2 ;
108097: LD_ADDR_OWVAR 21
108101: PUSH
108102: LD_INT 2
108104: ST_TO_ADDR
// hc_name := Dark Warrior ;
108105: LD_ADDR_OWVAR 26
108109: PUSH
108110: LD_STRING Dark Warrior
108112: ST_TO_ADDR
// hc_gallery :=  ;
108113: LD_ADDR_OWVAR 33
108117: PUSH
108118: LD_STRING 
108120: ST_TO_ADDR
// hc_noskilllimit := true ;
108121: LD_ADDR_OWVAR 76
108125: PUSH
108126: LD_INT 1
108128: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
108129: LD_ADDR_OWVAR 31
108133: PUSH
108134: LD_INT 30
108136: PUSH
108137: LD_INT 30
108139: PUSH
108140: LD_INT 30
108142: PUSH
108143: LD_INT 30
108145: PUSH
108146: EMPTY
108147: LIST
108148: LIST
108149: LIST
108150: LIST
108151: ST_TO_ADDR
// un := CreateHuman ;
108152: LD_ADDR_VAR 0 3
108156: PUSH
108157: CALL_OW 44
108161: ST_TO_ADDR
// hc_noskilllimit := false ;
108162: LD_ADDR_OWVAR 76
108166: PUSH
108167: LD_INT 0
108169: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
108170: LD_VAR 0 3
108174: PPUSH
108175: LD_INT 1
108177: PPUSH
108178: CALL_OW 51
// ToLua ( playRanger() ) ;
108182: LD_STRING playRanger()
108184: PPUSH
108185: CALL_OW 559
// p := 0 ;
108189: LD_ADDR_VAR 0 2
108193: PUSH
108194: LD_INT 0
108196: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108197: LD_INT 35
108199: PPUSH
108200: CALL_OW 67
// p := p + 1 ;
108204: LD_ADDR_VAR 0 2
108208: PUSH
108209: LD_VAR 0 2
108213: PUSH
108214: LD_INT 1
108216: PLUS
108217: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
108218: LD_VAR 0 3
108222: PPUSH
108223: CALL_OW 256
108227: PUSH
108228: LD_INT 1000
108230: LESS
108231: IFFALSE 108245
// SetLives ( un , 1000 ) ;
108233: LD_VAR 0 3
108237: PPUSH
108238: LD_INT 1000
108240: PPUSH
108241: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
108245: LD_VAR 0 3
108249: PPUSH
108250: LD_INT 81
108252: PUSH
108253: LD_OWVAR 2
108257: PUSH
108258: EMPTY
108259: LIST
108260: LIST
108261: PUSH
108262: LD_INT 91
108264: PUSH
108265: LD_VAR 0 3
108269: PUSH
108270: LD_INT 30
108272: PUSH
108273: EMPTY
108274: LIST
108275: LIST
108276: LIST
108277: PUSH
108278: EMPTY
108279: LIST
108280: LIST
108281: PPUSH
108282: CALL_OW 69
108286: PPUSH
108287: LD_VAR 0 3
108291: PPUSH
108292: CALL_OW 74
108296: PPUSH
108297: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
108301: LD_VAR 0 2
108305: PUSH
108306: LD_INT 80
108308: GREATER
108309: PUSH
108310: LD_VAR 0 3
108314: PPUSH
108315: CALL_OW 301
108319: OR
108320: IFFALSE 108197
// if un then
108322: LD_VAR 0 3
108326: IFFALSE 108337
// RemoveUnit ( un ) ;
108328: LD_VAR 0 3
108332: PPUSH
108333: CALL_OW 64
// end ;
108337: PPOPN 3
108339: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
108340: LD_EXP 178
108344: IFFALSE 108460
108346: GO 108348
108348: DISABLE
108349: LD_INT 0
108351: PPUSH
108352: PPUSH
108353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
108354: LD_ADDR_VAR 0 2
108358: PUSH
108359: LD_INT 81
108361: PUSH
108362: LD_OWVAR 2
108366: PUSH
108367: EMPTY
108368: LIST
108369: LIST
108370: PUSH
108371: LD_INT 21
108373: PUSH
108374: LD_INT 1
108376: PUSH
108377: EMPTY
108378: LIST
108379: LIST
108380: PUSH
108381: EMPTY
108382: LIST
108383: LIST
108384: PPUSH
108385: CALL_OW 69
108389: ST_TO_ADDR
// ToLua ( playComputer() ) ;
108390: LD_STRING playComputer()
108392: PPUSH
108393: CALL_OW 559
// if not tmp then
108397: LD_VAR 0 2
108401: NOT
108402: IFFALSE 108406
// exit ;
108404: GO 108460
// for i in tmp do
108406: LD_ADDR_VAR 0 1
108410: PUSH
108411: LD_VAR 0 2
108415: PUSH
108416: FOR_IN
108417: IFFALSE 108458
// for j := 1 to 4 do
108419: LD_ADDR_VAR 0 3
108423: PUSH
108424: DOUBLE
108425: LD_INT 1
108427: DEC
108428: ST_TO_ADDR
108429: LD_INT 4
108431: PUSH
108432: FOR_TO
108433: IFFALSE 108454
// SetSkill ( i , j , 10 ) ;
108435: LD_VAR 0 1
108439: PPUSH
108440: LD_VAR 0 3
108444: PPUSH
108445: LD_INT 10
108447: PPUSH
108448: CALL_OW 237
108452: GO 108432
108454: POP
108455: POP
108456: GO 108416
108458: POP
108459: POP
// end ;
108460: PPOPN 3
108462: END
// every 0 0$1 trigger s30 do var i , tmp ;
108463: LD_EXP 179
108467: IFFALSE 108536
108469: GO 108471
108471: DISABLE
108472: LD_INT 0
108474: PPUSH
108475: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108476: LD_ADDR_VAR 0 2
108480: PUSH
108481: LD_INT 22
108483: PUSH
108484: LD_OWVAR 2
108488: PUSH
108489: EMPTY
108490: LIST
108491: LIST
108492: PPUSH
108493: CALL_OW 69
108497: ST_TO_ADDR
// if not tmp then
108498: LD_VAR 0 2
108502: NOT
108503: IFFALSE 108507
// exit ;
108505: GO 108536
// for i in tmp do
108507: LD_ADDR_VAR 0 1
108511: PUSH
108512: LD_VAR 0 2
108516: PUSH
108517: FOR_IN
108518: IFFALSE 108534
// SetLives ( i , 300 ) ;
108520: LD_VAR 0 1
108524: PPUSH
108525: LD_INT 300
108527: PPUSH
108528: CALL_OW 234
108532: GO 108517
108534: POP
108535: POP
// end ;
108536: PPOPN 2
108538: END
// every 0 0$1 trigger s60 do var i , tmp ;
108539: LD_EXP 180
108543: IFFALSE 108612
108545: GO 108547
108547: DISABLE
108548: LD_INT 0
108550: PPUSH
108551: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108552: LD_ADDR_VAR 0 2
108556: PUSH
108557: LD_INT 22
108559: PUSH
108560: LD_OWVAR 2
108564: PUSH
108565: EMPTY
108566: LIST
108567: LIST
108568: PPUSH
108569: CALL_OW 69
108573: ST_TO_ADDR
// if not tmp then
108574: LD_VAR 0 2
108578: NOT
108579: IFFALSE 108583
// exit ;
108581: GO 108612
// for i in tmp do
108583: LD_ADDR_VAR 0 1
108587: PUSH
108588: LD_VAR 0 2
108592: PUSH
108593: FOR_IN
108594: IFFALSE 108610
// SetLives ( i , 600 ) ;
108596: LD_VAR 0 1
108600: PPUSH
108601: LD_INT 600
108603: PPUSH
108604: CALL_OW 234
108608: GO 108593
108610: POP
108611: POP
// end ;
108612: PPOPN 2
108614: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108615: LD_INT 0
108617: PPUSH
// case cmd of 301 :
108618: LD_VAR 0 1
108622: PUSH
108623: LD_INT 301
108625: DOUBLE
108626: EQUAL
108627: IFTRUE 108631
108629: GO 108663
108631: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
108632: LD_VAR 0 6
108636: PPUSH
108637: LD_VAR 0 7
108641: PPUSH
108642: LD_VAR 0 8
108646: PPUSH
108647: LD_VAR 0 4
108651: PPUSH
108652: LD_VAR 0 5
108656: PPUSH
108657: CALL 109872 0 5
108661: GO 108784
108663: LD_INT 302
108665: DOUBLE
108666: EQUAL
108667: IFTRUE 108671
108669: GO 108708
108671: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
108672: LD_VAR 0 6
108676: PPUSH
108677: LD_VAR 0 7
108681: PPUSH
108682: LD_VAR 0 8
108686: PPUSH
108687: LD_VAR 0 9
108691: PPUSH
108692: LD_VAR 0 4
108696: PPUSH
108697: LD_VAR 0 5
108701: PPUSH
108702: CALL 109963 0 6
108706: GO 108784
108708: LD_INT 303
108710: DOUBLE
108711: EQUAL
108712: IFTRUE 108716
108714: GO 108753
108716: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
108717: LD_VAR 0 6
108721: PPUSH
108722: LD_VAR 0 7
108726: PPUSH
108727: LD_VAR 0 8
108731: PPUSH
108732: LD_VAR 0 9
108736: PPUSH
108737: LD_VAR 0 4
108741: PPUSH
108742: LD_VAR 0 5
108746: PPUSH
108747: CALL 108789 0 6
108751: GO 108784
108753: LD_INT 304
108755: DOUBLE
108756: EQUAL
108757: IFTRUE 108761
108759: GO 108783
108761: POP
// hHackTeleport ( unit , x , y ) ; end ;
108762: LD_VAR 0 2
108766: PPUSH
108767: LD_VAR 0 4
108771: PPUSH
108772: LD_VAR 0 5
108776: PPUSH
108777: CALL 110556 0 3
108781: GO 108784
108783: POP
// end ;
108784: LD_VAR 0 12
108788: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
108789: LD_INT 0
108791: PPUSH
108792: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
108793: LD_VAR 0 1
108797: PUSH
108798: LD_INT 1
108800: LESS
108801: PUSH
108802: LD_VAR 0 1
108806: PUSH
108807: LD_INT 3
108809: GREATER
108810: OR
108811: PUSH
108812: LD_VAR 0 5
108816: PPUSH
108817: LD_VAR 0 6
108821: PPUSH
108822: CALL_OW 428
108826: OR
108827: IFFALSE 108831
// exit ;
108829: GO 109559
// uc_side := your_side ;
108831: LD_ADDR_OWVAR 20
108835: PUSH
108836: LD_OWVAR 2
108840: ST_TO_ADDR
// uc_nation := nation ;
108841: LD_ADDR_OWVAR 21
108845: PUSH
108846: LD_VAR 0 1
108850: ST_TO_ADDR
// bc_level = 1 ;
108851: LD_ADDR_OWVAR 43
108855: PUSH
108856: LD_INT 1
108858: ST_TO_ADDR
// case btype of 1 :
108859: LD_VAR 0 2
108863: PUSH
108864: LD_INT 1
108866: DOUBLE
108867: EQUAL
108868: IFTRUE 108872
108870: GO 108883
108872: POP
// bc_type := b_depot ; 2 :
108873: LD_ADDR_OWVAR 42
108877: PUSH
108878: LD_INT 0
108880: ST_TO_ADDR
108881: GO 109503
108883: LD_INT 2
108885: DOUBLE
108886: EQUAL
108887: IFTRUE 108891
108889: GO 108902
108891: POP
// bc_type := b_warehouse ; 3 :
108892: LD_ADDR_OWVAR 42
108896: PUSH
108897: LD_INT 1
108899: ST_TO_ADDR
108900: GO 109503
108902: LD_INT 3
108904: DOUBLE
108905: EQUAL
108906: IFTRUE 108910
108908: GO 108921
108910: POP
// bc_type := b_lab ; 4 .. 9 :
108911: LD_ADDR_OWVAR 42
108915: PUSH
108916: LD_INT 6
108918: ST_TO_ADDR
108919: GO 109503
108921: LD_INT 4
108923: DOUBLE
108924: GREATEREQUAL
108925: IFFALSE 108933
108927: LD_INT 9
108929: DOUBLE
108930: LESSEQUAL
108931: IFTRUE 108935
108933: GO 108995
108935: POP
// begin bc_type := b_lab_half ;
108936: LD_ADDR_OWVAR 42
108940: PUSH
108941: LD_INT 7
108943: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
108944: LD_ADDR_OWVAR 44
108948: PUSH
108949: LD_INT 10
108951: PUSH
108952: LD_INT 11
108954: PUSH
108955: LD_INT 12
108957: PUSH
108958: LD_INT 15
108960: PUSH
108961: LD_INT 14
108963: PUSH
108964: LD_INT 13
108966: PUSH
108967: EMPTY
108968: LIST
108969: LIST
108970: LIST
108971: LIST
108972: LIST
108973: LIST
108974: PUSH
108975: LD_VAR 0 2
108979: PUSH
108980: LD_INT 3
108982: MINUS
108983: ARRAY
108984: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
108985: LD_ADDR_OWVAR 45
108989: PUSH
108990: LD_INT 9
108992: ST_TO_ADDR
// end ; 10 .. 13 :
108993: GO 109503
108995: LD_INT 10
108997: DOUBLE
108998: GREATEREQUAL
108999: IFFALSE 109007
109001: LD_INT 13
109003: DOUBLE
109004: LESSEQUAL
109005: IFTRUE 109009
109007: GO 109086
109009: POP
// begin bc_type := b_lab_full ;
109010: LD_ADDR_OWVAR 42
109014: PUSH
109015: LD_INT 8
109017: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
109018: LD_ADDR_OWVAR 44
109022: PUSH
109023: LD_INT 10
109025: PUSH
109026: LD_INT 12
109028: PUSH
109029: LD_INT 14
109031: PUSH
109032: LD_INT 13
109034: PUSH
109035: EMPTY
109036: LIST
109037: LIST
109038: LIST
109039: LIST
109040: PUSH
109041: LD_VAR 0 2
109045: PUSH
109046: LD_INT 9
109048: MINUS
109049: ARRAY
109050: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
109051: LD_ADDR_OWVAR 45
109055: PUSH
109056: LD_INT 11
109058: PUSH
109059: LD_INT 15
109061: PUSH
109062: LD_INT 12
109064: PUSH
109065: LD_INT 15
109067: PUSH
109068: EMPTY
109069: LIST
109070: LIST
109071: LIST
109072: LIST
109073: PUSH
109074: LD_VAR 0 2
109078: PUSH
109079: LD_INT 9
109081: MINUS
109082: ARRAY
109083: ST_TO_ADDR
// end ; 14 :
109084: GO 109503
109086: LD_INT 14
109088: DOUBLE
109089: EQUAL
109090: IFTRUE 109094
109092: GO 109105
109094: POP
// bc_type := b_workshop ; 15 :
109095: LD_ADDR_OWVAR 42
109099: PUSH
109100: LD_INT 2
109102: ST_TO_ADDR
109103: GO 109503
109105: LD_INT 15
109107: DOUBLE
109108: EQUAL
109109: IFTRUE 109113
109111: GO 109124
109113: POP
// bc_type := b_factory ; 16 :
109114: LD_ADDR_OWVAR 42
109118: PUSH
109119: LD_INT 3
109121: ST_TO_ADDR
109122: GO 109503
109124: LD_INT 16
109126: DOUBLE
109127: EQUAL
109128: IFTRUE 109132
109130: GO 109143
109132: POP
// bc_type := b_ext_gun ; 17 :
109133: LD_ADDR_OWVAR 42
109137: PUSH
109138: LD_INT 17
109140: ST_TO_ADDR
109141: GO 109503
109143: LD_INT 17
109145: DOUBLE
109146: EQUAL
109147: IFTRUE 109151
109149: GO 109179
109151: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
109152: LD_ADDR_OWVAR 42
109156: PUSH
109157: LD_INT 19
109159: PUSH
109160: LD_INT 23
109162: PUSH
109163: LD_INT 19
109165: PUSH
109166: EMPTY
109167: LIST
109168: LIST
109169: LIST
109170: PUSH
109171: LD_VAR 0 1
109175: ARRAY
109176: ST_TO_ADDR
109177: GO 109503
109179: LD_INT 18
109181: DOUBLE
109182: EQUAL
109183: IFTRUE 109187
109185: GO 109198
109187: POP
// bc_type := b_ext_radar ; 19 :
109188: LD_ADDR_OWVAR 42
109192: PUSH
109193: LD_INT 20
109195: ST_TO_ADDR
109196: GO 109503
109198: LD_INT 19
109200: DOUBLE
109201: EQUAL
109202: IFTRUE 109206
109204: GO 109217
109206: POP
// bc_type := b_ext_radio ; 20 :
109207: LD_ADDR_OWVAR 42
109211: PUSH
109212: LD_INT 22
109214: ST_TO_ADDR
109215: GO 109503
109217: LD_INT 20
109219: DOUBLE
109220: EQUAL
109221: IFTRUE 109225
109223: GO 109236
109225: POP
// bc_type := b_ext_siberium ; 21 :
109226: LD_ADDR_OWVAR 42
109230: PUSH
109231: LD_INT 21
109233: ST_TO_ADDR
109234: GO 109503
109236: LD_INT 21
109238: DOUBLE
109239: EQUAL
109240: IFTRUE 109244
109242: GO 109255
109244: POP
// bc_type := b_ext_computer ; 22 :
109245: LD_ADDR_OWVAR 42
109249: PUSH
109250: LD_INT 24
109252: ST_TO_ADDR
109253: GO 109503
109255: LD_INT 22
109257: DOUBLE
109258: EQUAL
109259: IFTRUE 109263
109261: GO 109274
109263: POP
// bc_type := b_ext_track ; 23 :
109264: LD_ADDR_OWVAR 42
109268: PUSH
109269: LD_INT 16
109271: ST_TO_ADDR
109272: GO 109503
109274: LD_INT 23
109276: DOUBLE
109277: EQUAL
109278: IFTRUE 109282
109280: GO 109293
109282: POP
// bc_type := b_ext_laser ; 24 :
109283: LD_ADDR_OWVAR 42
109287: PUSH
109288: LD_INT 25
109290: ST_TO_ADDR
109291: GO 109503
109293: LD_INT 24
109295: DOUBLE
109296: EQUAL
109297: IFTRUE 109301
109299: GO 109312
109301: POP
// bc_type := b_control_tower ; 25 :
109302: LD_ADDR_OWVAR 42
109306: PUSH
109307: LD_INT 36
109309: ST_TO_ADDR
109310: GO 109503
109312: LD_INT 25
109314: DOUBLE
109315: EQUAL
109316: IFTRUE 109320
109318: GO 109331
109320: POP
// bc_type := b_breastwork ; 26 :
109321: LD_ADDR_OWVAR 42
109325: PUSH
109326: LD_INT 31
109328: ST_TO_ADDR
109329: GO 109503
109331: LD_INT 26
109333: DOUBLE
109334: EQUAL
109335: IFTRUE 109339
109337: GO 109350
109339: POP
// bc_type := b_bunker ; 27 :
109340: LD_ADDR_OWVAR 42
109344: PUSH
109345: LD_INT 32
109347: ST_TO_ADDR
109348: GO 109503
109350: LD_INT 27
109352: DOUBLE
109353: EQUAL
109354: IFTRUE 109358
109356: GO 109369
109358: POP
// bc_type := b_turret ; 28 :
109359: LD_ADDR_OWVAR 42
109363: PUSH
109364: LD_INT 33
109366: ST_TO_ADDR
109367: GO 109503
109369: LD_INT 28
109371: DOUBLE
109372: EQUAL
109373: IFTRUE 109377
109375: GO 109388
109377: POP
// bc_type := b_armoury ; 29 :
109378: LD_ADDR_OWVAR 42
109382: PUSH
109383: LD_INT 4
109385: ST_TO_ADDR
109386: GO 109503
109388: LD_INT 29
109390: DOUBLE
109391: EQUAL
109392: IFTRUE 109396
109394: GO 109407
109396: POP
// bc_type := b_barracks ; 30 :
109397: LD_ADDR_OWVAR 42
109401: PUSH
109402: LD_INT 5
109404: ST_TO_ADDR
109405: GO 109503
109407: LD_INT 30
109409: DOUBLE
109410: EQUAL
109411: IFTRUE 109415
109413: GO 109426
109415: POP
// bc_type := b_solar_power ; 31 :
109416: LD_ADDR_OWVAR 42
109420: PUSH
109421: LD_INT 27
109423: ST_TO_ADDR
109424: GO 109503
109426: LD_INT 31
109428: DOUBLE
109429: EQUAL
109430: IFTRUE 109434
109432: GO 109445
109434: POP
// bc_type := b_oil_power ; 32 :
109435: LD_ADDR_OWVAR 42
109439: PUSH
109440: LD_INT 26
109442: ST_TO_ADDR
109443: GO 109503
109445: LD_INT 32
109447: DOUBLE
109448: EQUAL
109449: IFTRUE 109453
109451: GO 109464
109453: POP
// bc_type := b_siberite_power ; 33 :
109454: LD_ADDR_OWVAR 42
109458: PUSH
109459: LD_INT 28
109461: ST_TO_ADDR
109462: GO 109503
109464: LD_INT 33
109466: DOUBLE
109467: EQUAL
109468: IFTRUE 109472
109470: GO 109483
109472: POP
// bc_type := b_oil_mine ; 34 :
109473: LD_ADDR_OWVAR 42
109477: PUSH
109478: LD_INT 29
109480: ST_TO_ADDR
109481: GO 109503
109483: LD_INT 34
109485: DOUBLE
109486: EQUAL
109487: IFTRUE 109491
109489: GO 109502
109491: POP
// bc_type := b_siberite_mine ; end ;
109492: LD_ADDR_OWVAR 42
109496: PUSH
109497: LD_INT 30
109499: ST_TO_ADDR
109500: GO 109503
109502: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
109503: LD_ADDR_VAR 0 8
109507: PUSH
109508: LD_VAR 0 5
109512: PPUSH
109513: LD_VAR 0 6
109517: PPUSH
109518: LD_VAR 0 3
109522: PPUSH
109523: CALL_OW 47
109527: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
109528: LD_OWVAR 42
109532: PUSH
109533: LD_INT 32
109535: PUSH
109536: LD_INT 33
109538: PUSH
109539: EMPTY
109540: LIST
109541: LIST
109542: IN
109543: IFFALSE 109559
// PlaceWeaponTurret ( b , weapon ) ;
109545: LD_VAR 0 8
109549: PPUSH
109550: LD_VAR 0 4
109554: PPUSH
109555: CALL_OW 431
// end ;
109559: LD_VAR 0 7
109563: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
109564: LD_INT 0
109566: PPUSH
109567: PPUSH
109568: PPUSH
109569: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109570: LD_ADDR_VAR 0 4
109574: PUSH
109575: LD_INT 22
109577: PUSH
109578: LD_OWVAR 2
109582: PUSH
109583: EMPTY
109584: LIST
109585: LIST
109586: PUSH
109587: LD_INT 2
109589: PUSH
109590: LD_INT 30
109592: PUSH
109593: LD_INT 0
109595: PUSH
109596: EMPTY
109597: LIST
109598: LIST
109599: PUSH
109600: LD_INT 30
109602: PUSH
109603: LD_INT 1
109605: PUSH
109606: EMPTY
109607: LIST
109608: LIST
109609: PUSH
109610: EMPTY
109611: LIST
109612: LIST
109613: LIST
109614: PUSH
109615: EMPTY
109616: LIST
109617: LIST
109618: PPUSH
109619: CALL_OW 69
109623: ST_TO_ADDR
// if not tmp then
109624: LD_VAR 0 4
109628: NOT
109629: IFFALSE 109633
// exit ;
109631: GO 109692
// for i in tmp do
109633: LD_ADDR_VAR 0 2
109637: PUSH
109638: LD_VAR 0 4
109642: PUSH
109643: FOR_IN
109644: IFFALSE 109690
// for j = 1 to 3 do
109646: LD_ADDR_VAR 0 3
109650: PUSH
109651: DOUBLE
109652: LD_INT 1
109654: DEC
109655: ST_TO_ADDR
109656: LD_INT 3
109658: PUSH
109659: FOR_TO
109660: IFFALSE 109686
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
109662: LD_VAR 0 2
109666: PPUSH
109667: CALL_OW 274
109671: PPUSH
109672: LD_VAR 0 3
109676: PPUSH
109677: LD_INT 99999
109679: PPUSH
109680: CALL_OW 277
109684: GO 109659
109686: POP
109687: POP
109688: GO 109643
109690: POP
109691: POP
// end ;
109692: LD_VAR 0 1
109696: RET
// export function hHackSetLevel10 ; var i , j ; begin
109697: LD_INT 0
109699: PPUSH
109700: PPUSH
109701: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109702: LD_ADDR_VAR 0 2
109706: PUSH
109707: LD_INT 21
109709: PUSH
109710: LD_INT 1
109712: PUSH
109713: EMPTY
109714: LIST
109715: LIST
109716: PPUSH
109717: CALL_OW 69
109721: PUSH
109722: FOR_IN
109723: IFFALSE 109775
// if IsSelected ( i ) then
109725: LD_VAR 0 2
109729: PPUSH
109730: CALL_OW 306
109734: IFFALSE 109773
// begin for j := 1 to 4 do
109736: LD_ADDR_VAR 0 3
109740: PUSH
109741: DOUBLE
109742: LD_INT 1
109744: DEC
109745: ST_TO_ADDR
109746: LD_INT 4
109748: PUSH
109749: FOR_TO
109750: IFFALSE 109771
// SetSkill ( i , j , 10 ) ;
109752: LD_VAR 0 2
109756: PPUSH
109757: LD_VAR 0 3
109761: PPUSH
109762: LD_INT 10
109764: PPUSH
109765: CALL_OW 237
109769: GO 109749
109771: POP
109772: POP
// end ;
109773: GO 109722
109775: POP
109776: POP
// end ;
109777: LD_VAR 0 1
109781: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
109782: LD_INT 0
109784: PPUSH
109785: PPUSH
109786: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
109787: LD_ADDR_VAR 0 2
109791: PUSH
109792: LD_INT 22
109794: PUSH
109795: LD_OWVAR 2
109799: PUSH
109800: EMPTY
109801: LIST
109802: LIST
109803: PUSH
109804: LD_INT 21
109806: PUSH
109807: LD_INT 1
109809: PUSH
109810: EMPTY
109811: LIST
109812: LIST
109813: PUSH
109814: EMPTY
109815: LIST
109816: LIST
109817: PPUSH
109818: CALL_OW 69
109822: PUSH
109823: FOR_IN
109824: IFFALSE 109865
// begin for j := 1 to 4 do
109826: LD_ADDR_VAR 0 3
109830: PUSH
109831: DOUBLE
109832: LD_INT 1
109834: DEC
109835: ST_TO_ADDR
109836: LD_INT 4
109838: PUSH
109839: FOR_TO
109840: IFFALSE 109861
// SetSkill ( i , j , 10 ) ;
109842: LD_VAR 0 2
109846: PPUSH
109847: LD_VAR 0 3
109851: PPUSH
109852: LD_INT 10
109854: PPUSH
109855: CALL_OW 237
109859: GO 109839
109861: POP
109862: POP
// end ;
109863: GO 109823
109865: POP
109866: POP
// end ;
109867: LD_VAR 0 1
109871: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
109872: LD_INT 0
109874: PPUSH
// uc_side := your_side ;
109875: LD_ADDR_OWVAR 20
109879: PUSH
109880: LD_OWVAR 2
109884: ST_TO_ADDR
// uc_nation := nation ;
109885: LD_ADDR_OWVAR 21
109889: PUSH
109890: LD_VAR 0 1
109894: ST_TO_ADDR
// InitHc ;
109895: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
109899: LD_INT 0
109901: PPUSH
109902: LD_VAR 0 2
109906: PPUSH
109907: LD_VAR 0 3
109911: PPUSH
109912: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
109916: LD_VAR 0 4
109920: PPUSH
109921: LD_VAR 0 5
109925: PPUSH
109926: CALL_OW 428
109930: PUSH
109931: LD_INT 0
109933: EQUAL
109934: IFFALSE 109958
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
109936: CALL_OW 44
109940: PPUSH
109941: LD_VAR 0 4
109945: PPUSH
109946: LD_VAR 0 5
109950: PPUSH
109951: LD_INT 1
109953: PPUSH
109954: CALL_OW 48
// end ;
109958: LD_VAR 0 6
109962: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
109963: LD_INT 0
109965: PPUSH
109966: PPUSH
// uc_side := your_side ;
109967: LD_ADDR_OWVAR 20
109971: PUSH
109972: LD_OWVAR 2
109976: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
109977: LD_VAR 0 1
109981: PUSH
109982: LD_INT 1
109984: PUSH
109985: LD_INT 2
109987: PUSH
109988: LD_INT 3
109990: PUSH
109991: LD_INT 4
109993: PUSH
109994: LD_INT 5
109996: PUSH
109997: EMPTY
109998: LIST
109999: LIST
110000: LIST
110001: LIST
110002: LIST
110003: IN
110004: IFFALSE 110016
// uc_nation := nation_american else
110006: LD_ADDR_OWVAR 21
110010: PUSH
110011: LD_INT 1
110013: ST_TO_ADDR
110014: GO 110059
// if chassis in [ 11 , 12 , 13 , 14 ] then
110016: LD_VAR 0 1
110020: PUSH
110021: LD_INT 11
110023: PUSH
110024: LD_INT 12
110026: PUSH
110027: LD_INT 13
110029: PUSH
110030: LD_INT 14
110032: PUSH
110033: EMPTY
110034: LIST
110035: LIST
110036: LIST
110037: LIST
110038: IN
110039: IFFALSE 110051
// uc_nation := nation_arabian else
110041: LD_ADDR_OWVAR 21
110045: PUSH
110046: LD_INT 2
110048: ST_TO_ADDR
110049: GO 110059
// uc_nation := nation_russian ;
110051: LD_ADDR_OWVAR 21
110055: PUSH
110056: LD_INT 3
110058: ST_TO_ADDR
// vc_chassis := chassis ;
110059: LD_ADDR_OWVAR 37
110063: PUSH
110064: LD_VAR 0 1
110068: ST_TO_ADDR
// vc_engine := engine ;
110069: LD_ADDR_OWVAR 39
110073: PUSH
110074: LD_VAR 0 2
110078: ST_TO_ADDR
// vc_control := control ;
110079: LD_ADDR_OWVAR 38
110083: PUSH
110084: LD_VAR 0 3
110088: ST_TO_ADDR
// vc_weapon := weapon ;
110089: LD_ADDR_OWVAR 40
110093: PUSH
110094: LD_VAR 0 4
110098: ST_TO_ADDR
// un := CreateVehicle ;
110099: LD_ADDR_VAR 0 8
110103: PUSH
110104: CALL_OW 45
110108: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
110109: LD_VAR 0 8
110113: PPUSH
110114: LD_INT 0
110116: PPUSH
110117: LD_INT 5
110119: PPUSH
110120: CALL_OW 12
110124: PPUSH
110125: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
110129: LD_VAR 0 8
110133: PPUSH
110134: LD_VAR 0 5
110138: PPUSH
110139: LD_VAR 0 6
110143: PPUSH
110144: LD_INT 1
110146: PPUSH
110147: CALL_OW 48
// end ;
110151: LD_VAR 0 7
110155: RET
// export hInvincible ; every 1 do
110156: GO 110158
110158: DISABLE
// hInvincible := [ ] ;
110159: LD_ADDR_EXP 181
110163: PUSH
110164: EMPTY
110165: ST_TO_ADDR
110166: END
// every 10 do var i ;
110167: GO 110169
110169: DISABLE
110170: LD_INT 0
110172: PPUSH
// begin enable ;
110173: ENABLE
// if not hInvincible then
110174: LD_EXP 181
110178: NOT
110179: IFFALSE 110183
// exit ;
110181: GO 110227
// for i in hInvincible do
110183: LD_ADDR_VAR 0 1
110187: PUSH
110188: LD_EXP 181
110192: PUSH
110193: FOR_IN
110194: IFFALSE 110225
// if GetLives ( i ) < 1000 then
110196: LD_VAR 0 1
110200: PPUSH
110201: CALL_OW 256
110205: PUSH
110206: LD_INT 1000
110208: LESS
110209: IFFALSE 110223
// SetLives ( i , 1000 ) ;
110211: LD_VAR 0 1
110215: PPUSH
110216: LD_INT 1000
110218: PPUSH
110219: CALL_OW 234
110223: GO 110193
110225: POP
110226: POP
// end ;
110227: PPOPN 1
110229: END
// export function hHackInvincible ; var i ; begin
110230: LD_INT 0
110232: PPUSH
110233: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
110234: LD_ADDR_VAR 0 2
110238: PUSH
110239: LD_INT 2
110241: PUSH
110242: LD_INT 21
110244: PUSH
110245: LD_INT 1
110247: PUSH
110248: EMPTY
110249: LIST
110250: LIST
110251: PUSH
110252: LD_INT 21
110254: PUSH
110255: LD_INT 2
110257: PUSH
110258: EMPTY
110259: LIST
110260: LIST
110261: PUSH
110262: EMPTY
110263: LIST
110264: LIST
110265: LIST
110266: PPUSH
110267: CALL_OW 69
110271: PUSH
110272: FOR_IN
110273: IFFALSE 110334
// if IsSelected ( i ) then
110275: LD_VAR 0 2
110279: PPUSH
110280: CALL_OW 306
110284: IFFALSE 110332
// begin if i in hInvincible then
110286: LD_VAR 0 2
110290: PUSH
110291: LD_EXP 181
110295: IN
110296: IFFALSE 110316
// hInvincible := hInvincible diff i else
110298: LD_ADDR_EXP 181
110302: PUSH
110303: LD_EXP 181
110307: PUSH
110308: LD_VAR 0 2
110312: DIFF
110313: ST_TO_ADDR
110314: GO 110332
// hInvincible := hInvincible union i ;
110316: LD_ADDR_EXP 181
110320: PUSH
110321: LD_EXP 181
110325: PUSH
110326: LD_VAR 0 2
110330: UNION
110331: ST_TO_ADDR
// end ;
110332: GO 110272
110334: POP
110335: POP
// end ;
110336: LD_VAR 0 1
110340: RET
// export function hHackInvisible ; var i , j ; begin
110341: LD_INT 0
110343: PPUSH
110344: PPUSH
110345: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
110346: LD_ADDR_VAR 0 2
110350: PUSH
110351: LD_INT 21
110353: PUSH
110354: LD_INT 1
110356: PUSH
110357: EMPTY
110358: LIST
110359: LIST
110360: PPUSH
110361: CALL_OW 69
110365: PUSH
110366: FOR_IN
110367: IFFALSE 110391
// if IsSelected ( i ) then
110369: LD_VAR 0 2
110373: PPUSH
110374: CALL_OW 306
110378: IFFALSE 110389
// ComForceInvisible ( i ) ;
110380: LD_VAR 0 2
110384: PPUSH
110385: CALL_OW 496
110389: GO 110366
110391: POP
110392: POP
// end ;
110393: LD_VAR 0 1
110397: RET
// export function hHackChangeYourSide ; begin
110398: LD_INT 0
110400: PPUSH
// if your_side = 8 then
110401: LD_OWVAR 2
110405: PUSH
110406: LD_INT 8
110408: EQUAL
110409: IFFALSE 110421
// your_side := 0 else
110411: LD_ADDR_OWVAR 2
110415: PUSH
110416: LD_INT 0
110418: ST_TO_ADDR
110419: GO 110435
// your_side := your_side + 1 ;
110421: LD_ADDR_OWVAR 2
110425: PUSH
110426: LD_OWVAR 2
110430: PUSH
110431: LD_INT 1
110433: PLUS
110434: ST_TO_ADDR
// end ;
110435: LD_VAR 0 1
110439: RET
// export function hHackChangeUnitSide ; var i , j ; begin
110440: LD_INT 0
110442: PPUSH
110443: PPUSH
110444: PPUSH
// for i in all_units do
110445: LD_ADDR_VAR 0 2
110449: PUSH
110450: LD_OWVAR 3
110454: PUSH
110455: FOR_IN
110456: IFFALSE 110534
// if IsSelected ( i ) then
110458: LD_VAR 0 2
110462: PPUSH
110463: CALL_OW 306
110467: IFFALSE 110532
// begin j := GetSide ( i ) ;
110469: LD_ADDR_VAR 0 3
110473: PUSH
110474: LD_VAR 0 2
110478: PPUSH
110479: CALL_OW 255
110483: ST_TO_ADDR
// if j = 8 then
110484: LD_VAR 0 3
110488: PUSH
110489: LD_INT 8
110491: EQUAL
110492: IFFALSE 110504
// j := 0 else
110494: LD_ADDR_VAR 0 3
110498: PUSH
110499: LD_INT 0
110501: ST_TO_ADDR
110502: GO 110518
// j := j + 1 ;
110504: LD_ADDR_VAR 0 3
110508: PUSH
110509: LD_VAR 0 3
110513: PUSH
110514: LD_INT 1
110516: PLUS
110517: ST_TO_ADDR
// SetSide ( i , j ) ;
110518: LD_VAR 0 2
110522: PPUSH
110523: LD_VAR 0 3
110527: PPUSH
110528: CALL_OW 235
// end ;
110532: GO 110455
110534: POP
110535: POP
// end ;
110536: LD_VAR 0 1
110540: RET
// export function hHackFog ; begin
110541: LD_INT 0
110543: PPUSH
// FogOff ( true ) ;
110544: LD_INT 1
110546: PPUSH
110547: CALL_OW 344
// end ;
110551: LD_VAR 0 1
110555: RET
// export function hHackTeleport ( unit , x , y ) ; begin
110556: LD_INT 0
110558: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
110559: LD_VAR 0 1
110563: PPUSH
110564: LD_VAR 0 2
110568: PPUSH
110569: LD_VAR 0 3
110573: PPUSH
110574: LD_INT 1
110576: PPUSH
110577: LD_INT 1
110579: PPUSH
110580: CALL_OW 483
// CenterOnXY ( x , y ) ;
110584: LD_VAR 0 2
110588: PPUSH
110589: LD_VAR 0 3
110593: PPUSH
110594: CALL_OW 84
// end ;
110598: LD_VAR 0 4
110602: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
110603: LD_INT 0
110605: PPUSH
110606: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
110607: LD_VAR 0 1
110611: NOT
110612: PUSH
110613: LD_VAR 0 2
110617: PPUSH
110618: LD_VAR 0 3
110622: PPUSH
110623: CALL_OW 488
110627: NOT
110628: OR
110629: PUSH
110630: LD_VAR 0 1
110634: PPUSH
110635: CALL_OW 266
110639: PUSH
110640: LD_INT 3
110642: NONEQUAL
110643: PUSH
110644: LD_VAR 0 1
110648: PPUSH
110649: CALL_OW 247
110653: PUSH
110654: LD_INT 1
110656: EQUAL
110657: NOT
110658: AND
110659: OR
110660: IFFALSE 110664
// exit ;
110662: GO 110813
// if GetType ( factory ) = unit_human then
110664: LD_VAR 0 1
110668: PPUSH
110669: CALL_OW 247
110673: PUSH
110674: LD_INT 1
110676: EQUAL
110677: IFFALSE 110694
// factory := IsInUnit ( factory ) ;
110679: LD_ADDR_VAR 0 1
110683: PUSH
110684: LD_VAR 0 1
110688: PPUSH
110689: CALL_OW 310
110693: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
110694: LD_VAR 0 1
110698: PPUSH
110699: CALL_OW 266
110703: PUSH
110704: LD_INT 3
110706: NONEQUAL
110707: IFFALSE 110711
// exit ;
110709: GO 110813
// if HexInfo ( x , y ) = factory then
110711: LD_VAR 0 2
110715: PPUSH
110716: LD_VAR 0 3
110720: PPUSH
110721: CALL_OW 428
110725: PUSH
110726: LD_VAR 0 1
110730: EQUAL
110731: IFFALSE 110758
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
110733: LD_ADDR_EXP 182
110737: PUSH
110738: LD_EXP 182
110742: PPUSH
110743: LD_VAR 0 1
110747: PPUSH
110748: LD_INT 0
110750: PPUSH
110751: CALL_OW 1
110755: ST_TO_ADDR
110756: GO 110809
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
110758: LD_ADDR_EXP 182
110762: PUSH
110763: LD_EXP 182
110767: PPUSH
110768: LD_VAR 0 1
110772: PPUSH
110773: LD_VAR 0 1
110777: PPUSH
110778: CALL_OW 255
110782: PUSH
110783: LD_VAR 0 1
110787: PUSH
110788: LD_VAR 0 2
110792: PUSH
110793: LD_VAR 0 3
110797: PUSH
110798: EMPTY
110799: LIST
110800: LIST
110801: LIST
110802: LIST
110803: PPUSH
110804: CALL_OW 1
110808: ST_TO_ADDR
// UpdateFactoryWaypoints ;
110809: CALL 110818 0 0
// end ;
110813: LD_VAR 0 4
110817: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
110818: LD_INT 0
110820: PPUSH
110821: PPUSH
110822: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
110823: LD_STRING resetFactoryWaypoint();
110825: PPUSH
110826: CALL_OW 559
// if factoryWaypoints then
110830: LD_EXP 182
110834: IFFALSE 110960
// begin list := PrepareArray ( factoryWaypoints ) ;
110836: LD_ADDR_VAR 0 3
110840: PUSH
110841: LD_EXP 182
110845: PPUSH
110846: CALL 94773 0 1
110850: ST_TO_ADDR
// for i := 1 to list do
110851: LD_ADDR_VAR 0 2
110855: PUSH
110856: DOUBLE
110857: LD_INT 1
110859: DEC
110860: ST_TO_ADDR
110861: LD_VAR 0 3
110865: PUSH
110866: FOR_TO
110867: IFFALSE 110958
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
110869: LD_STRING setFactoryWaypointXY(
110871: PUSH
110872: LD_VAR 0 3
110876: PUSH
110877: LD_VAR 0 2
110881: ARRAY
110882: PUSH
110883: LD_INT 1
110885: ARRAY
110886: STR
110887: PUSH
110888: LD_STRING ,
110890: STR
110891: PUSH
110892: LD_VAR 0 3
110896: PUSH
110897: LD_VAR 0 2
110901: ARRAY
110902: PUSH
110903: LD_INT 2
110905: ARRAY
110906: STR
110907: PUSH
110908: LD_STRING ,
110910: STR
110911: PUSH
110912: LD_VAR 0 3
110916: PUSH
110917: LD_VAR 0 2
110921: ARRAY
110922: PUSH
110923: LD_INT 3
110925: ARRAY
110926: STR
110927: PUSH
110928: LD_STRING ,
110930: STR
110931: PUSH
110932: LD_VAR 0 3
110936: PUSH
110937: LD_VAR 0 2
110941: ARRAY
110942: PUSH
110943: LD_INT 4
110945: ARRAY
110946: STR
110947: PUSH
110948: LD_STRING )
110950: STR
110951: PPUSH
110952: CALL_OW 559
110956: GO 110866
110958: POP
110959: POP
// end ; end ;
110960: LD_VAR 0 1
110964: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
110965: LD_INT 0
110967: PPUSH
// if HexInfo ( x , y ) = warehouse then
110968: LD_VAR 0 2
110972: PPUSH
110973: LD_VAR 0 3
110977: PPUSH
110978: CALL_OW 428
110982: PUSH
110983: LD_VAR 0 1
110987: EQUAL
110988: IFFALSE 111015
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
110990: LD_ADDR_EXP 183
110994: PUSH
110995: LD_EXP 183
110999: PPUSH
111000: LD_VAR 0 1
111004: PPUSH
111005: LD_INT 0
111007: PPUSH
111008: CALL_OW 1
111012: ST_TO_ADDR
111013: GO 111066
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
111015: LD_ADDR_EXP 183
111019: PUSH
111020: LD_EXP 183
111024: PPUSH
111025: LD_VAR 0 1
111029: PPUSH
111030: LD_VAR 0 1
111034: PPUSH
111035: CALL_OW 255
111039: PUSH
111040: LD_VAR 0 1
111044: PUSH
111045: LD_VAR 0 2
111049: PUSH
111050: LD_VAR 0 3
111054: PUSH
111055: EMPTY
111056: LIST
111057: LIST
111058: LIST
111059: LIST
111060: PPUSH
111061: CALL_OW 1
111065: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
111066: CALL 111075 0 0
// end ;
111070: LD_VAR 0 4
111074: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
111075: LD_INT 0
111077: PPUSH
111078: PPUSH
111079: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
111080: LD_STRING resetWarehouseGatheringPoints();
111082: PPUSH
111083: CALL_OW 559
// if warehouseGatheringPoints then
111087: LD_EXP 183
111091: IFFALSE 111217
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
111093: LD_ADDR_VAR 0 3
111097: PUSH
111098: LD_EXP 183
111102: PPUSH
111103: CALL 94773 0 1
111107: ST_TO_ADDR
// for i := 1 to list do
111108: LD_ADDR_VAR 0 2
111112: PUSH
111113: DOUBLE
111114: LD_INT 1
111116: DEC
111117: ST_TO_ADDR
111118: LD_VAR 0 3
111122: PUSH
111123: FOR_TO
111124: IFFALSE 111215
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111126: LD_STRING setWarehouseGatheringPointXY(
111128: PUSH
111129: LD_VAR 0 3
111133: PUSH
111134: LD_VAR 0 2
111138: ARRAY
111139: PUSH
111140: LD_INT 1
111142: ARRAY
111143: STR
111144: PUSH
111145: LD_STRING ,
111147: STR
111148: PUSH
111149: LD_VAR 0 3
111153: PUSH
111154: LD_VAR 0 2
111158: ARRAY
111159: PUSH
111160: LD_INT 2
111162: ARRAY
111163: STR
111164: PUSH
111165: LD_STRING ,
111167: STR
111168: PUSH
111169: LD_VAR 0 3
111173: PUSH
111174: LD_VAR 0 2
111178: ARRAY
111179: PUSH
111180: LD_INT 3
111182: ARRAY
111183: STR
111184: PUSH
111185: LD_STRING ,
111187: STR
111188: PUSH
111189: LD_VAR 0 3
111193: PUSH
111194: LD_VAR 0 2
111198: ARRAY
111199: PUSH
111200: LD_INT 4
111202: ARRAY
111203: STR
111204: PUSH
111205: LD_STRING )
111207: STR
111208: PPUSH
111209: CALL_OW 559
111213: GO 111123
111215: POP
111216: POP
// end ; end ;
111217: LD_VAR 0 1
111221: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
111222: LD_EXP 183
111226: IFFALSE 111911
111228: GO 111230
111230: DISABLE
111231: LD_INT 0
111233: PPUSH
111234: PPUSH
111235: PPUSH
111236: PPUSH
111237: PPUSH
111238: PPUSH
111239: PPUSH
111240: PPUSH
111241: PPUSH
// begin enable ;
111242: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
111243: LD_ADDR_VAR 0 3
111247: PUSH
111248: LD_EXP 183
111252: PPUSH
111253: CALL 94773 0 1
111257: ST_TO_ADDR
// if not list then
111258: LD_VAR 0 3
111262: NOT
111263: IFFALSE 111267
// exit ;
111265: GO 111911
// for i := 1 to list do
111267: LD_ADDR_VAR 0 1
111271: PUSH
111272: DOUBLE
111273: LD_INT 1
111275: DEC
111276: ST_TO_ADDR
111277: LD_VAR 0 3
111281: PUSH
111282: FOR_TO
111283: IFFALSE 111909
// begin depot := list [ i ] [ 2 ] ;
111285: LD_ADDR_VAR 0 8
111289: PUSH
111290: LD_VAR 0 3
111294: PUSH
111295: LD_VAR 0 1
111299: ARRAY
111300: PUSH
111301: LD_INT 2
111303: ARRAY
111304: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
111305: LD_ADDR_VAR 0 5
111309: PUSH
111310: LD_VAR 0 3
111314: PUSH
111315: LD_VAR 0 1
111319: ARRAY
111320: PUSH
111321: LD_INT 1
111323: ARRAY
111324: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
111325: LD_VAR 0 8
111329: PPUSH
111330: CALL_OW 301
111334: PUSH
111335: LD_VAR 0 5
111339: PUSH
111340: LD_VAR 0 8
111344: PPUSH
111345: CALL_OW 255
111349: NONEQUAL
111350: OR
111351: IFFALSE 111380
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
111353: LD_ADDR_EXP 183
111357: PUSH
111358: LD_EXP 183
111362: PPUSH
111363: LD_VAR 0 8
111367: PPUSH
111368: LD_INT 0
111370: PPUSH
111371: CALL_OW 1
111375: ST_TO_ADDR
// exit ;
111376: POP
111377: POP
111378: GO 111911
// end ; x := list [ i ] [ 3 ] ;
111380: LD_ADDR_VAR 0 6
111384: PUSH
111385: LD_VAR 0 3
111389: PUSH
111390: LD_VAR 0 1
111394: ARRAY
111395: PUSH
111396: LD_INT 3
111398: ARRAY
111399: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
111400: LD_ADDR_VAR 0 7
111404: PUSH
111405: LD_VAR 0 3
111409: PUSH
111410: LD_VAR 0 1
111414: ARRAY
111415: PUSH
111416: LD_INT 4
111418: ARRAY
111419: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
111420: LD_ADDR_VAR 0 9
111424: PUSH
111425: LD_VAR 0 6
111429: PPUSH
111430: LD_VAR 0 7
111434: PPUSH
111435: LD_INT 16
111437: PPUSH
111438: CALL 93361 0 3
111442: ST_TO_ADDR
// if not cratesNearbyPoint then
111443: LD_VAR 0 9
111447: NOT
111448: IFFALSE 111454
// exit ;
111450: POP
111451: POP
111452: GO 111911
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
111454: LD_ADDR_VAR 0 4
111458: PUSH
111459: LD_INT 22
111461: PUSH
111462: LD_VAR 0 5
111466: PUSH
111467: EMPTY
111468: LIST
111469: LIST
111470: PUSH
111471: LD_INT 3
111473: PUSH
111474: LD_INT 60
111476: PUSH
111477: EMPTY
111478: LIST
111479: PUSH
111480: EMPTY
111481: LIST
111482: LIST
111483: PUSH
111484: LD_INT 91
111486: PUSH
111487: LD_VAR 0 8
111491: PUSH
111492: LD_INT 6
111494: PUSH
111495: EMPTY
111496: LIST
111497: LIST
111498: LIST
111499: PUSH
111500: LD_INT 2
111502: PUSH
111503: LD_INT 25
111505: PUSH
111506: LD_INT 2
111508: PUSH
111509: EMPTY
111510: LIST
111511: LIST
111512: PUSH
111513: LD_INT 25
111515: PUSH
111516: LD_INT 16
111518: PUSH
111519: EMPTY
111520: LIST
111521: LIST
111522: PUSH
111523: EMPTY
111524: LIST
111525: LIST
111526: LIST
111527: PUSH
111528: EMPTY
111529: LIST
111530: LIST
111531: LIST
111532: LIST
111533: PPUSH
111534: CALL_OW 69
111538: PUSH
111539: LD_VAR 0 8
111543: PPUSH
111544: CALL_OW 313
111548: PPUSH
111549: LD_INT 3
111551: PUSH
111552: LD_INT 60
111554: PUSH
111555: EMPTY
111556: LIST
111557: PUSH
111558: EMPTY
111559: LIST
111560: LIST
111561: PUSH
111562: LD_INT 2
111564: PUSH
111565: LD_INT 25
111567: PUSH
111568: LD_INT 2
111570: PUSH
111571: EMPTY
111572: LIST
111573: LIST
111574: PUSH
111575: LD_INT 25
111577: PUSH
111578: LD_INT 16
111580: PUSH
111581: EMPTY
111582: LIST
111583: LIST
111584: PUSH
111585: EMPTY
111586: LIST
111587: LIST
111588: LIST
111589: PUSH
111590: EMPTY
111591: LIST
111592: LIST
111593: PPUSH
111594: CALL_OW 72
111598: UNION
111599: ST_TO_ADDR
// if tmp then
111600: LD_VAR 0 4
111604: IFFALSE 111684
// begin tmp := ShrinkArray ( tmp , 3 ) ;
111606: LD_ADDR_VAR 0 4
111610: PUSH
111611: LD_VAR 0 4
111615: PPUSH
111616: LD_INT 3
111618: PPUSH
111619: CALL 91330 0 2
111623: ST_TO_ADDR
// for j in tmp do
111624: LD_ADDR_VAR 0 2
111628: PUSH
111629: LD_VAR 0 4
111633: PUSH
111634: FOR_IN
111635: IFFALSE 111678
// begin if IsInUnit ( j ) then
111637: LD_VAR 0 2
111641: PPUSH
111642: CALL_OW 310
111646: IFFALSE 111657
// ComExit ( j ) ;
111648: LD_VAR 0 2
111652: PPUSH
111653: CALL 91413 0 1
// AddComCollect ( j , x , y ) ;
111657: LD_VAR 0 2
111661: PPUSH
111662: LD_VAR 0 6
111666: PPUSH
111667: LD_VAR 0 7
111671: PPUSH
111672: CALL_OW 177
// end ;
111676: GO 111634
111678: POP
111679: POP
// exit ;
111680: POP
111681: POP
111682: GO 111911
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
111684: LD_ADDR_VAR 0 4
111688: PUSH
111689: LD_INT 22
111691: PUSH
111692: LD_VAR 0 5
111696: PUSH
111697: EMPTY
111698: LIST
111699: LIST
111700: PUSH
111701: LD_INT 91
111703: PUSH
111704: LD_VAR 0 8
111708: PUSH
111709: LD_INT 8
111711: PUSH
111712: EMPTY
111713: LIST
111714: LIST
111715: LIST
111716: PUSH
111717: LD_INT 2
111719: PUSH
111720: LD_INT 34
111722: PUSH
111723: LD_INT 12
111725: PUSH
111726: EMPTY
111727: LIST
111728: LIST
111729: PUSH
111730: LD_INT 34
111732: PUSH
111733: LD_INT 51
111735: PUSH
111736: EMPTY
111737: LIST
111738: LIST
111739: PUSH
111740: LD_INT 34
111742: PUSH
111743: LD_INT 32
111745: PUSH
111746: EMPTY
111747: LIST
111748: LIST
111749: PUSH
111750: LD_INT 34
111752: PUSH
111753: LD_INT 89
111755: PUSH
111756: EMPTY
111757: LIST
111758: LIST
111759: PUSH
111760: EMPTY
111761: LIST
111762: LIST
111763: LIST
111764: LIST
111765: LIST
111766: PUSH
111767: EMPTY
111768: LIST
111769: LIST
111770: LIST
111771: PPUSH
111772: CALL_OW 69
111776: ST_TO_ADDR
// if tmp then
111777: LD_VAR 0 4
111781: IFFALSE 111907
// begin for j in tmp do
111783: LD_ADDR_VAR 0 2
111787: PUSH
111788: LD_VAR 0 4
111792: PUSH
111793: FOR_IN
111794: IFFALSE 111905
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
111796: LD_VAR 0 2
111800: PPUSH
111801: CALL_OW 262
111805: PUSH
111806: LD_INT 3
111808: EQUAL
111809: PUSH
111810: LD_VAR 0 2
111814: PPUSH
111815: CALL_OW 261
111819: PUSH
111820: LD_INT 20
111822: GREATER
111823: OR
111824: PUSH
111825: LD_VAR 0 2
111829: PPUSH
111830: CALL_OW 314
111834: NOT
111835: AND
111836: PUSH
111837: LD_VAR 0 2
111841: PPUSH
111842: CALL_OW 263
111846: PUSH
111847: LD_INT 1
111849: NONEQUAL
111850: PUSH
111851: LD_VAR 0 2
111855: PPUSH
111856: CALL_OW 311
111860: OR
111861: AND
111862: IFFALSE 111903
// begin ComCollect ( j , x , y ) ;
111864: LD_VAR 0 2
111868: PPUSH
111869: LD_VAR 0 6
111873: PPUSH
111874: LD_VAR 0 7
111878: PPUSH
111879: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
111883: LD_VAR 0 2
111887: PPUSH
111888: LD_VAR 0 8
111892: PPUSH
111893: CALL_OW 172
// exit ;
111897: POP
111898: POP
111899: POP
111900: POP
111901: GO 111911
// end ;
111903: GO 111793
111905: POP
111906: POP
// end ; end ;
111907: GO 111282
111909: POP
111910: POP
// end ; end_of_file
111911: PPOPN 9
111913: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
111914: LD_INT 0
111916: PPUSH
111917: PPUSH
111918: PPUSH
111919: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
111920: LD_VAR 0 1
111924: PPUSH
111925: CALL_OW 264
111929: PUSH
111930: LD_INT 91
111932: EQUAL
111933: IFFALSE 112005
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
111935: LD_INT 68
111937: PPUSH
111938: LD_VAR 0 1
111942: PPUSH
111943: CALL_OW 255
111947: PPUSH
111948: CALL_OW 321
111952: PUSH
111953: LD_INT 2
111955: EQUAL
111956: IFFALSE 111968
// eff := 70 else
111958: LD_ADDR_VAR 0 4
111962: PUSH
111963: LD_INT 70
111965: ST_TO_ADDR
111966: GO 111976
// eff := 30 ;
111968: LD_ADDR_VAR 0 4
111972: PUSH
111973: LD_INT 30
111975: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
111976: LD_VAR 0 1
111980: PPUSH
111981: CALL_OW 250
111985: PPUSH
111986: LD_VAR 0 1
111990: PPUSH
111991: CALL_OW 251
111995: PPUSH
111996: LD_VAR 0 4
112000: PPUSH
112001: CALL_OW 495
// end ; end ;
112005: LD_VAR 0 2
112009: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
112010: LD_INT 0
112012: PPUSH
// end ;
112013: LD_VAR 0 4
112017: RET
// export function SOS_Command ( cmd ) ; begin
112018: LD_INT 0
112020: PPUSH
// end ;
112021: LD_VAR 0 2
112025: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
112026: LD_INT 0
112028: PPUSH
// end ;
112029: LD_VAR 0 6
112033: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
112034: LD_INT 0
112036: PPUSH
112037: PPUSH
// if not vehicle or not factory then
112038: LD_VAR 0 1
112042: NOT
112043: PUSH
112044: LD_VAR 0 2
112048: NOT
112049: OR
112050: IFFALSE 112054
// exit ;
112052: GO 112285
// if factoryWaypoints >= factory then
112054: LD_EXP 182
112058: PUSH
112059: LD_VAR 0 2
112063: GREATEREQUAL
112064: IFFALSE 112285
// if factoryWaypoints [ factory ] then
112066: LD_EXP 182
112070: PUSH
112071: LD_VAR 0 2
112075: ARRAY
112076: IFFALSE 112285
// begin if GetControl ( vehicle ) = control_manual then
112078: LD_VAR 0 1
112082: PPUSH
112083: CALL_OW 263
112087: PUSH
112088: LD_INT 1
112090: EQUAL
112091: IFFALSE 112172
// begin driver := IsDrivenBy ( vehicle ) ;
112093: LD_ADDR_VAR 0 4
112097: PUSH
112098: LD_VAR 0 1
112102: PPUSH
112103: CALL_OW 311
112107: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
112108: LD_VAR 0 4
112112: PPUSH
112113: LD_EXP 182
112117: PUSH
112118: LD_VAR 0 2
112122: ARRAY
112123: PUSH
112124: LD_INT 3
112126: ARRAY
112127: PPUSH
112128: LD_EXP 182
112132: PUSH
112133: LD_VAR 0 2
112137: ARRAY
112138: PUSH
112139: LD_INT 4
112141: ARRAY
112142: PPUSH
112143: CALL_OW 171
// AddComExitVehicle ( driver ) ;
112147: LD_VAR 0 4
112151: PPUSH
112152: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
112156: LD_VAR 0 4
112160: PPUSH
112161: LD_VAR 0 2
112165: PPUSH
112166: CALL_OW 180
// end else
112170: GO 112285
// if GetControl ( vehicle ) = control_remote then
112172: LD_VAR 0 1
112176: PPUSH
112177: CALL_OW 263
112181: PUSH
112182: LD_INT 2
112184: EQUAL
112185: IFFALSE 112246
// begin wait ( 0 0$2 ) ;
112187: LD_INT 70
112189: PPUSH
112190: CALL_OW 67
// if Connect ( vehicle ) then
112194: LD_VAR 0 1
112198: PPUSH
112199: CALL 61632 0 1
112203: IFFALSE 112244
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
112205: LD_VAR 0 1
112209: PPUSH
112210: LD_EXP 182
112214: PUSH
112215: LD_VAR 0 2
112219: ARRAY
112220: PUSH
112221: LD_INT 3
112223: ARRAY
112224: PPUSH
112225: LD_EXP 182
112229: PUSH
112230: LD_VAR 0 2
112234: ARRAY
112235: PUSH
112236: LD_INT 4
112238: ARRAY
112239: PPUSH
112240: CALL_OW 171
// end else
112244: GO 112285
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
112246: LD_VAR 0 1
112250: PPUSH
112251: LD_EXP 182
112255: PUSH
112256: LD_VAR 0 2
112260: ARRAY
112261: PUSH
112262: LD_INT 3
112264: ARRAY
112265: PPUSH
112266: LD_EXP 182
112270: PUSH
112271: LD_VAR 0 2
112275: ARRAY
112276: PUSH
112277: LD_INT 4
112279: ARRAY
112280: PPUSH
112281: CALL_OW 171
// end ; end ;
112285: LD_VAR 0 3
112289: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
112290: LD_INT 0
112292: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
112293: LD_VAR 0 1
112297: PUSH
112298: LD_INT 250
112300: EQUAL
112301: PUSH
112302: LD_VAR 0 2
112306: PPUSH
112307: CALL_OW 264
112311: PUSH
112312: LD_INT 81
112314: EQUAL
112315: AND
112316: IFFALSE 112337
// MinerPlaceMine ( unit , x , y ) ;
112318: LD_VAR 0 2
112322: PPUSH
112323: LD_VAR 0 4
112327: PPUSH
112328: LD_VAR 0 5
112332: PPUSH
112333: CALL 115327 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
112337: LD_VAR 0 1
112341: PUSH
112342: LD_INT 251
112344: EQUAL
112345: PUSH
112346: LD_VAR 0 2
112350: PPUSH
112351: CALL_OW 264
112355: PUSH
112356: LD_INT 81
112358: EQUAL
112359: AND
112360: IFFALSE 112381
// MinerDetonateMine ( unit , x , y ) ;
112362: LD_VAR 0 2
112366: PPUSH
112367: LD_VAR 0 4
112371: PPUSH
112372: LD_VAR 0 5
112376: PPUSH
112377: CALL 115602 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
112381: LD_VAR 0 1
112385: PUSH
112386: LD_INT 252
112388: EQUAL
112389: PUSH
112390: LD_VAR 0 2
112394: PPUSH
112395: CALL_OW 264
112399: PUSH
112400: LD_INT 81
112402: EQUAL
112403: AND
112404: IFFALSE 112425
// MinerCreateMinefield ( unit , x , y ) ;
112406: LD_VAR 0 2
112410: PPUSH
112411: LD_VAR 0 4
112415: PPUSH
112416: LD_VAR 0 5
112420: PPUSH
112421: CALL 116019 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
112425: LD_VAR 0 1
112429: PUSH
112430: LD_INT 253
112432: EQUAL
112433: PUSH
112434: LD_VAR 0 2
112438: PPUSH
112439: CALL_OW 257
112443: PUSH
112444: LD_INT 5
112446: EQUAL
112447: AND
112448: IFFALSE 112469
// ComBinocular ( unit , x , y ) ;
112450: LD_VAR 0 2
112454: PPUSH
112455: LD_VAR 0 4
112459: PPUSH
112460: LD_VAR 0 5
112464: PPUSH
112465: CALL 116388 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
112469: LD_VAR 0 1
112473: PUSH
112474: LD_INT 254
112476: EQUAL
112477: PUSH
112478: LD_VAR 0 2
112482: PPUSH
112483: CALL_OW 264
112487: PUSH
112488: LD_INT 99
112490: EQUAL
112491: AND
112492: PUSH
112493: LD_VAR 0 3
112497: PPUSH
112498: CALL_OW 263
112502: PUSH
112503: LD_INT 3
112505: EQUAL
112506: AND
112507: IFFALSE 112523
// HackDestroyVehicle ( unit , selectedUnit ) ;
112509: LD_VAR 0 2
112513: PPUSH
112514: LD_VAR 0 3
112518: PPUSH
112519: CALL 114691 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
112523: LD_VAR 0 1
112527: PUSH
112528: LD_INT 255
112530: EQUAL
112531: PUSH
112532: LD_VAR 0 2
112536: PPUSH
112537: CALL_OW 264
112541: PUSH
112542: LD_INT 14
112544: PUSH
112545: LD_INT 53
112547: PUSH
112548: EMPTY
112549: LIST
112550: LIST
112551: IN
112552: AND
112553: PUSH
112554: LD_VAR 0 4
112558: PPUSH
112559: LD_VAR 0 5
112563: PPUSH
112564: CALL_OW 488
112568: AND
112569: IFFALSE 112593
// CutTreeXYR ( unit , x , y , 12 ) ;
112571: LD_VAR 0 2
112575: PPUSH
112576: LD_VAR 0 4
112580: PPUSH
112581: LD_VAR 0 5
112585: PPUSH
112586: LD_INT 12
112588: PPUSH
112589: CALL 112688 0 4
// if cmd = 256 then
112593: LD_VAR 0 1
112597: PUSH
112598: LD_INT 256
112600: EQUAL
112601: IFFALSE 112622
// SetFactoryWaypoint ( unit , x , y ) ;
112603: LD_VAR 0 2
112607: PPUSH
112608: LD_VAR 0 4
112612: PPUSH
112613: LD_VAR 0 5
112617: PPUSH
112618: CALL 110603 0 3
// if cmd = 257 then
112622: LD_VAR 0 1
112626: PUSH
112627: LD_INT 257
112629: EQUAL
112630: IFFALSE 112651
// SetWarehouseGatheringPoint ( unit , x , y ) ;
112632: LD_VAR 0 2
112636: PPUSH
112637: LD_VAR 0 4
112641: PPUSH
112642: LD_VAR 0 5
112646: PPUSH
112647: CALL 110965 0 3
// if cmd = 258 then
112651: LD_VAR 0 1
112655: PUSH
112656: LD_INT 258
112658: EQUAL
112659: IFFALSE 112683
// BurnTreeXYR ( unit , x , y , 8 ) ;
112661: LD_VAR 0 2
112665: PPUSH
112666: LD_VAR 0 4
112670: PPUSH
112671: LD_VAR 0 5
112675: PPUSH
112676: LD_INT 8
112678: PPUSH
112679: CALL 113082 0 4
// end ;
112683: LD_VAR 0 6
112687: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
112688: LD_INT 0
112690: PPUSH
112691: PPUSH
112692: PPUSH
112693: PPUSH
112694: PPUSH
112695: PPUSH
112696: PPUSH
112697: PPUSH
112698: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
112699: LD_VAR 0 1
112703: PPUSH
112704: CALL_OW 302
112708: NOT
112709: PUSH
112710: LD_VAR 0 2
112714: PPUSH
112715: LD_VAR 0 3
112719: PPUSH
112720: CALL_OW 488
112724: NOT
112725: OR
112726: PUSH
112727: LD_VAR 0 4
112731: NOT
112732: OR
112733: IFFALSE 112737
// exit ;
112735: GO 113077
// list := [ ] ;
112737: LD_ADDR_VAR 0 13
112741: PUSH
112742: EMPTY
112743: ST_TO_ADDR
// if x - r < 0 then
112744: LD_VAR 0 2
112748: PUSH
112749: LD_VAR 0 4
112753: MINUS
112754: PUSH
112755: LD_INT 0
112757: LESS
112758: IFFALSE 112770
// min_x := 0 else
112760: LD_ADDR_VAR 0 7
112764: PUSH
112765: LD_INT 0
112767: ST_TO_ADDR
112768: GO 112786
// min_x := x - r ;
112770: LD_ADDR_VAR 0 7
112774: PUSH
112775: LD_VAR 0 2
112779: PUSH
112780: LD_VAR 0 4
112784: MINUS
112785: ST_TO_ADDR
// if y - r < 0 then
112786: LD_VAR 0 3
112790: PUSH
112791: LD_VAR 0 4
112795: MINUS
112796: PUSH
112797: LD_INT 0
112799: LESS
112800: IFFALSE 112812
// min_y := 0 else
112802: LD_ADDR_VAR 0 8
112806: PUSH
112807: LD_INT 0
112809: ST_TO_ADDR
112810: GO 112828
// min_y := y - r ;
112812: LD_ADDR_VAR 0 8
112816: PUSH
112817: LD_VAR 0 3
112821: PUSH
112822: LD_VAR 0 4
112826: MINUS
112827: ST_TO_ADDR
// max_x := x + r ;
112828: LD_ADDR_VAR 0 9
112832: PUSH
112833: LD_VAR 0 2
112837: PUSH
112838: LD_VAR 0 4
112842: PLUS
112843: ST_TO_ADDR
// max_y := y + r ;
112844: LD_ADDR_VAR 0 10
112848: PUSH
112849: LD_VAR 0 3
112853: PUSH
112854: LD_VAR 0 4
112858: PLUS
112859: ST_TO_ADDR
// for _x = min_x to max_x do
112860: LD_ADDR_VAR 0 11
112864: PUSH
112865: DOUBLE
112866: LD_VAR 0 7
112870: DEC
112871: ST_TO_ADDR
112872: LD_VAR 0 9
112876: PUSH
112877: FOR_TO
112878: IFFALSE 112995
// for _y = min_y to max_y do
112880: LD_ADDR_VAR 0 12
112884: PUSH
112885: DOUBLE
112886: LD_VAR 0 8
112890: DEC
112891: ST_TO_ADDR
112892: LD_VAR 0 10
112896: PUSH
112897: FOR_TO
112898: IFFALSE 112991
// begin if not ValidHex ( _x , _y ) then
112900: LD_VAR 0 11
112904: PPUSH
112905: LD_VAR 0 12
112909: PPUSH
112910: CALL_OW 488
112914: NOT
112915: IFFALSE 112919
// continue ;
112917: GO 112897
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112919: LD_VAR 0 11
112923: PPUSH
112924: LD_VAR 0 12
112928: PPUSH
112929: CALL_OW 351
112933: PUSH
112934: LD_VAR 0 11
112938: PPUSH
112939: LD_VAR 0 12
112943: PPUSH
112944: CALL_OW 554
112948: AND
112949: IFFALSE 112989
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112951: LD_ADDR_VAR 0 13
112955: PUSH
112956: LD_VAR 0 13
112960: PPUSH
112961: LD_VAR 0 13
112965: PUSH
112966: LD_INT 1
112968: PLUS
112969: PPUSH
112970: LD_VAR 0 11
112974: PUSH
112975: LD_VAR 0 12
112979: PUSH
112980: EMPTY
112981: LIST
112982: LIST
112983: PPUSH
112984: CALL_OW 2
112988: ST_TO_ADDR
// end ;
112989: GO 112897
112991: POP
112992: POP
112993: GO 112877
112995: POP
112996: POP
// if not list then
112997: LD_VAR 0 13
113001: NOT
113002: IFFALSE 113006
// exit ;
113004: GO 113077
// for i in list do
113006: LD_ADDR_VAR 0 6
113010: PUSH
113011: LD_VAR 0 13
113015: PUSH
113016: FOR_IN
113017: IFFALSE 113075
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
113019: LD_VAR 0 1
113023: PPUSH
113024: LD_STRING M
113026: PUSH
113027: LD_VAR 0 6
113031: PUSH
113032: LD_INT 1
113034: ARRAY
113035: PUSH
113036: LD_VAR 0 6
113040: PUSH
113041: LD_INT 2
113043: ARRAY
113044: PUSH
113045: LD_INT 0
113047: PUSH
113048: LD_INT 0
113050: PUSH
113051: LD_INT 0
113053: PUSH
113054: LD_INT 0
113056: PUSH
113057: EMPTY
113058: LIST
113059: LIST
113060: LIST
113061: LIST
113062: LIST
113063: LIST
113064: LIST
113065: PUSH
113066: EMPTY
113067: LIST
113068: PPUSH
113069: CALL_OW 447
113073: GO 113016
113075: POP
113076: POP
// end ;
113077: LD_VAR 0 5
113081: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
113082: LD_INT 0
113084: PPUSH
113085: PPUSH
113086: PPUSH
113087: PPUSH
113088: PPUSH
113089: PPUSH
113090: PPUSH
113091: PPUSH
113092: PPUSH
113093: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
113094: LD_VAR 0 1
113098: PPUSH
113099: CALL_OW 302
113103: NOT
113104: PUSH
113105: LD_VAR 0 2
113109: PPUSH
113110: LD_VAR 0 3
113114: PPUSH
113115: CALL_OW 488
113119: NOT
113120: OR
113121: PUSH
113122: LD_VAR 0 4
113126: NOT
113127: OR
113128: IFFALSE 113132
// exit ;
113130: GO 113645
// list := [ ] ;
113132: LD_ADDR_VAR 0 13
113136: PUSH
113137: EMPTY
113138: ST_TO_ADDR
// if x - r < 0 then
113139: LD_VAR 0 2
113143: PUSH
113144: LD_VAR 0 4
113148: MINUS
113149: PUSH
113150: LD_INT 0
113152: LESS
113153: IFFALSE 113165
// min_x := 0 else
113155: LD_ADDR_VAR 0 7
113159: PUSH
113160: LD_INT 0
113162: ST_TO_ADDR
113163: GO 113181
// min_x := x - r ;
113165: LD_ADDR_VAR 0 7
113169: PUSH
113170: LD_VAR 0 2
113174: PUSH
113175: LD_VAR 0 4
113179: MINUS
113180: ST_TO_ADDR
// if y - r < 0 then
113181: LD_VAR 0 3
113185: PUSH
113186: LD_VAR 0 4
113190: MINUS
113191: PUSH
113192: LD_INT 0
113194: LESS
113195: IFFALSE 113207
// min_y := 0 else
113197: LD_ADDR_VAR 0 8
113201: PUSH
113202: LD_INT 0
113204: ST_TO_ADDR
113205: GO 113223
// min_y := y - r ;
113207: LD_ADDR_VAR 0 8
113211: PUSH
113212: LD_VAR 0 3
113216: PUSH
113217: LD_VAR 0 4
113221: MINUS
113222: ST_TO_ADDR
// max_x := x + r ;
113223: LD_ADDR_VAR 0 9
113227: PUSH
113228: LD_VAR 0 2
113232: PUSH
113233: LD_VAR 0 4
113237: PLUS
113238: ST_TO_ADDR
// max_y := y + r ;
113239: LD_ADDR_VAR 0 10
113243: PUSH
113244: LD_VAR 0 3
113248: PUSH
113249: LD_VAR 0 4
113253: PLUS
113254: ST_TO_ADDR
// for _x = min_x to max_x do
113255: LD_ADDR_VAR 0 11
113259: PUSH
113260: DOUBLE
113261: LD_VAR 0 7
113265: DEC
113266: ST_TO_ADDR
113267: LD_VAR 0 9
113271: PUSH
113272: FOR_TO
113273: IFFALSE 113390
// for _y = min_y to max_y do
113275: LD_ADDR_VAR 0 12
113279: PUSH
113280: DOUBLE
113281: LD_VAR 0 8
113285: DEC
113286: ST_TO_ADDR
113287: LD_VAR 0 10
113291: PUSH
113292: FOR_TO
113293: IFFALSE 113386
// begin if not ValidHex ( _x , _y ) then
113295: LD_VAR 0 11
113299: PPUSH
113300: LD_VAR 0 12
113304: PPUSH
113305: CALL_OW 488
113309: NOT
113310: IFFALSE 113314
// continue ;
113312: GO 113292
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
113314: LD_VAR 0 11
113318: PPUSH
113319: LD_VAR 0 12
113323: PPUSH
113324: CALL_OW 351
113328: PUSH
113329: LD_VAR 0 11
113333: PPUSH
113334: LD_VAR 0 12
113338: PPUSH
113339: CALL_OW 554
113343: AND
113344: IFFALSE 113384
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
113346: LD_ADDR_VAR 0 13
113350: PUSH
113351: LD_VAR 0 13
113355: PPUSH
113356: LD_VAR 0 13
113360: PUSH
113361: LD_INT 1
113363: PLUS
113364: PPUSH
113365: LD_VAR 0 11
113369: PUSH
113370: LD_VAR 0 12
113374: PUSH
113375: EMPTY
113376: LIST
113377: LIST
113378: PPUSH
113379: CALL_OW 2
113383: ST_TO_ADDR
// end ;
113384: GO 113292
113386: POP
113387: POP
113388: GO 113272
113390: POP
113391: POP
// if not list then
113392: LD_VAR 0 13
113396: NOT
113397: IFFALSE 113401
// exit ;
113399: GO 113645
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
113401: LD_ADDR_VAR 0 13
113405: PUSH
113406: LD_VAR 0 1
113410: PPUSH
113411: LD_VAR 0 13
113415: PPUSH
113416: LD_INT 1
113418: PPUSH
113419: LD_INT 1
113421: PPUSH
113422: CALL 58774 0 4
113426: ST_TO_ADDR
// ComStop ( flame ) ;
113427: LD_VAR 0 1
113431: PPUSH
113432: CALL_OW 141
// for i in list do
113436: LD_ADDR_VAR 0 6
113440: PUSH
113441: LD_VAR 0 13
113445: PUSH
113446: FOR_IN
113447: IFFALSE 113478
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
113449: LD_VAR 0 1
113453: PPUSH
113454: LD_VAR 0 6
113458: PUSH
113459: LD_INT 1
113461: ARRAY
113462: PPUSH
113463: LD_VAR 0 6
113467: PUSH
113468: LD_INT 2
113470: ARRAY
113471: PPUSH
113472: CALL_OW 176
113476: GO 113446
113478: POP
113479: POP
// repeat wait ( 0 0$1 ) ;
113480: LD_INT 35
113482: PPUSH
113483: CALL_OW 67
// task := GetTaskList ( flame ) ;
113487: LD_ADDR_VAR 0 14
113491: PUSH
113492: LD_VAR 0 1
113496: PPUSH
113497: CALL_OW 437
113501: ST_TO_ADDR
// if not task then
113502: LD_VAR 0 14
113506: NOT
113507: IFFALSE 113511
// exit ;
113509: GO 113645
// if task [ 1 ] [ 1 ] <> | then
113511: LD_VAR 0 14
113515: PUSH
113516: LD_INT 1
113518: ARRAY
113519: PUSH
113520: LD_INT 1
113522: ARRAY
113523: PUSH
113524: LD_STRING |
113526: NONEQUAL
113527: IFFALSE 113531
// exit ;
113529: GO 113645
// _x := task [ 1 ] [ 2 ] ;
113531: LD_ADDR_VAR 0 11
113535: PUSH
113536: LD_VAR 0 14
113540: PUSH
113541: LD_INT 1
113543: ARRAY
113544: PUSH
113545: LD_INT 2
113547: ARRAY
113548: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
113549: LD_ADDR_VAR 0 12
113553: PUSH
113554: LD_VAR 0 14
113558: PUSH
113559: LD_INT 1
113561: ARRAY
113562: PUSH
113563: LD_INT 3
113565: ARRAY
113566: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
113567: LD_VAR 0 11
113571: PPUSH
113572: LD_VAR 0 12
113576: PPUSH
113577: CALL_OW 351
113581: NOT
113582: PUSH
113583: LD_VAR 0 11
113587: PPUSH
113588: LD_VAR 0 12
113592: PPUSH
113593: CALL_OW 554
113597: NOT
113598: OR
113599: IFFALSE 113633
// begin task := Delete ( task , 1 ) ;
113601: LD_ADDR_VAR 0 14
113605: PUSH
113606: LD_VAR 0 14
113610: PPUSH
113611: LD_INT 1
113613: PPUSH
113614: CALL_OW 3
113618: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
113619: LD_VAR 0 1
113623: PPUSH
113624: LD_VAR 0 14
113628: PPUSH
113629: CALL_OW 446
// end ; until not HasTask ( flame ) ;
113633: LD_VAR 0 1
113637: PPUSH
113638: CALL_OW 314
113642: NOT
113643: IFFALSE 113480
// end ;
113645: LD_VAR 0 5
113649: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
113650: LD_EXP 185
113654: NOT
113655: IFFALSE 113705
113657: GO 113659
113659: DISABLE
// begin initHack := true ;
113660: LD_ADDR_EXP 185
113664: PUSH
113665: LD_INT 1
113667: ST_TO_ADDR
// hackTanks := [ ] ;
113668: LD_ADDR_EXP 186
113672: PUSH
113673: EMPTY
113674: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
113675: LD_ADDR_EXP 187
113679: PUSH
113680: EMPTY
113681: ST_TO_ADDR
// hackLimit := 3 ;
113682: LD_ADDR_EXP 188
113686: PUSH
113687: LD_INT 3
113689: ST_TO_ADDR
// hackDist := 12 ;
113690: LD_ADDR_EXP 189
113694: PUSH
113695: LD_INT 12
113697: ST_TO_ADDR
// hackCounter := [ ] ;
113698: LD_ADDR_EXP 190
113702: PUSH
113703: EMPTY
113704: ST_TO_ADDR
// end ;
113705: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
113706: LD_EXP 185
113710: PUSH
113711: LD_INT 34
113713: PUSH
113714: LD_INT 99
113716: PUSH
113717: EMPTY
113718: LIST
113719: LIST
113720: PPUSH
113721: CALL_OW 69
113725: AND
113726: IFFALSE 113979
113728: GO 113730
113730: DISABLE
113731: LD_INT 0
113733: PPUSH
113734: PPUSH
// begin enable ;
113735: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
113736: LD_ADDR_VAR 0 1
113740: PUSH
113741: LD_INT 34
113743: PUSH
113744: LD_INT 99
113746: PUSH
113747: EMPTY
113748: LIST
113749: LIST
113750: PPUSH
113751: CALL_OW 69
113755: PUSH
113756: FOR_IN
113757: IFFALSE 113977
// begin if not i in hackTanks then
113759: LD_VAR 0 1
113763: PUSH
113764: LD_EXP 186
113768: IN
113769: NOT
113770: IFFALSE 113853
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
113772: LD_ADDR_EXP 186
113776: PUSH
113777: LD_EXP 186
113781: PPUSH
113782: LD_EXP 186
113786: PUSH
113787: LD_INT 1
113789: PLUS
113790: PPUSH
113791: LD_VAR 0 1
113795: PPUSH
113796: CALL_OW 1
113800: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
113801: LD_ADDR_EXP 187
113805: PUSH
113806: LD_EXP 187
113810: PPUSH
113811: LD_EXP 187
113815: PUSH
113816: LD_INT 1
113818: PLUS
113819: PPUSH
113820: EMPTY
113821: PPUSH
113822: CALL_OW 1
113826: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
113827: LD_ADDR_EXP 190
113831: PUSH
113832: LD_EXP 190
113836: PPUSH
113837: LD_EXP 190
113841: PUSH
113842: LD_INT 1
113844: PLUS
113845: PPUSH
113846: EMPTY
113847: PPUSH
113848: CALL_OW 1
113852: ST_TO_ADDR
// end ; if not IsOk ( i ) then
113853: LD_VAR 0 1
113857: PPUSH
113858: CALL_OW 302
113862: NOT
113863: IFFALSE 113876
// begin HackUnlinkAll ( i ) ;
113865: LD_VAR 0 1
113869: PPUSH
113870: CALL 113982 0 1
// continue ;
113874: GO 113756
// end ; HackCheckCapturedStatus ( i ) ;
113876: LD_VAR 0 1
113880: PPUSH
113881: CALL 114425 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
113885: LD_ADDR_VAR 0 2
113889: PUSH
113890: LD_INT 81
113892: PUSH
113893: LD_VAR 0 1
113897: PPUSH
113898: CALL_OW 255
113902: PUSH
113903: EMPTY
113904: LIST
113905: LIST
113906: PUSH
113907: LD_INT 33
113909: PUSH
113910: LD_INT 3
113912: PUSH
113913: EMPTY
113914: LIST
113915: LIST
113916: PUSH
113917: LD_INT 91
113919: PUSH
113920: LD_VAR 0 1
113924: PUSH
113925: LD_EXP 189
113929: PUSH
113930: EMPTY
113931: LIST
113932: LIST
113933: LIST
113934: PUSH
113935: LD_INT 50
113937: PUSH
113938: EMPTY
113939: LIST
113940: PUSH
113941: EMPTY
113942: LIST
113943: LIST
113944: LIST
113945: LIST
113946: PPUSH
113947: CALL_OW 69
113951: ST_TO_ADDR
// if not tmp then
113952: LD_VAR 0 2
113956: NOT
113957: IFFALSE 113961
// continue ;
113959: GO 113756
// HackLink ( i , tmp ) ;
113961: LD_VAR 0 1
113965: PPUSH
113966: LD_VAR 0 2
113970: PPUSH
113971: CALL 114118 0 2
// end ;
113975: GO 113756
113977: POP
113978: POP
// end ;
113979: PPOPN 2
113981: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
113982: LD_INT 0
113984: PPUSH
113985: PPUSH
113986: PPUSH
// if not hack in hackTanks then
113987: LD_VAR 0 1
113991: PUSH
113992: LD_EXP 186
113996: IN
113997: NOT
113998: IFFALSE 114002
// exit ;
114000: GO 114113
// index := GetElementIndex ( hackTanks , hack ) ;
114002: LD_ADDR_VAR 0 4
114006: PUSH
114007: LD_EXP 186
114011: PPUSH
114012: LD_VAR 0 1
114016: PPUSH
114017: CALL 58071 0 2
114021: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
114022: LD_EXP 187
114026: PUSH
114027: LD_VAR 0 4
114031: ARRAY
114032: IFFALSE 114113
// begin for i in hackTanksCaptured [ index ] do
114034: LD_ADDR_VAR 0 3
114038: PUSH
114039: LD_EXP 187
114043: PUSH
114044: LD_VAR 0 4
114048: ARRAY
114049: PUSH
114050: FOR_IN
114051: IFFALSE 114077
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
114053: LD_VAR 0 3
114057: PUSH
114058: LD_INT 1
114060: ARRAY
114061: PPUSH
114062: LD_VAR 0 3
114066: PUSH
114067: LD_INT 2
114069: ARRAY
114070: PPUSH
114071: CALL_OW 235
114075: GO 114050
114077: POP
114078: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
114079: LD_ADDR_EXP 187
114083: PUSH
114084: LD_EXP 187
114088: PPUSH
114089: LD_VAR 0 4
114093: PPUSH
114094: EMPTY
114095: PPUSH
114096: CALL_OW 1
114100: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
114101: LD_VAR 0 1
114105: PPUSH
114106: LD_INT 0
114108: PPUSH
114109: CALL_OW 505
// end ; end ;
114113: LD_VAR 0 2
114117: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
114118: LD_INT 0
114120: PPUSH
114121: PPUSH
114122: PPUSH
// if not hack in hackTanks or not vehicles then
114123: LD_VAR 0 1
114127: PUSH
114128: LD_EXP 186
114132: IN
114133: NOT
114134: PUSH
114135: LD_VAR 0 2
114139: NOT
114140: OR
114141: IFFALSE 114145
// exit ;
114143: GO 114420
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
114145: LD_ADDR_VAR 0 2
114149: PUSH
114150: LD_VAR 0 1
114154: PPUSH
114155: LD_VAR 0 2
114159: PPUSH
114160: LD_INT 1
114162: PPUSH
114163: LD_INT 1
114165: PPUSH
114166: CALL 58721 0 4
114170: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
114171: LD_ADDR_VAR 0 5
114175: PUSH
114176: LD_EXP 186
114180: PPUSH
114181: LD_VAR 0 1
114185: PPUSH
114186: CALL 58071 0 2
114190: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
114191: LD_EXP 187
114195: PUSH
114196: LD_VAR 0 5
114200: ARRAY
114201: PUSH
114202: LD_EXP 188
114206: LESS
114207: IFFALSE 114396
// begin for i := 1 to vehicles do
114209: LD_ADDR_VAR 0 4
114213: PUSH
114214: DOUBLE
114215: LD_INT 1
114217: DEC
114218: ST_TO_ADDR
114219: LD_VAR 0 2
114223: PUSH
114224: FOR_TO
114225: IFFALSE 114394
// begin if hackTanksCaptured [ index ] = hackLimit then
114227: LD_EXP 187
114231: PUSH
114232: LD_VAR 0 5
114236: ARRAY
114237: PUSH
114238: LD_EXP 188
114242: EQUAL
114243: IFFALSE 114247
// break ;
114245: GO 114394
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
114247: LD_ADDR_EXP 190
114251: PUSH
114252: LD_EXP 190
114256: PPUSH
114257: LD_VAR 0 5
114261: PPUSH
114262: LD_EXP 190
114266: PUSH
114267: LD_VAR 0 5
114271: ARRAY
114272: PUSH
114273: LD_INT 1
114275: PLUS
114276: PPUSH
114277: CALL_OW 1
114281: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
114282: LD_ADDR_EXP 187
114286: PUSH
114287: LD_EXP 187
114291: PPUSH
114292: LD_VAR 0 5
114296: PUSH
114297: LD_EXP 187
114301: PUSH
114302: LD_VAR 0 5
114306: ARRAY
114307: PUSH
114308: LD_INT 1
114310: PLUS
114311: PUSH
114312: EMPTY
114313: LIST
114314: LIST
114315: PPUSH
114316: LD_VAR 0 2
114320: PUSH
114321: LD_VAR 0 4
114325: ARRAY
114326: PUSH
114327: LD_VAR 0 2
114331: PUSH
114332: LD_VAR 0 4
114336: ARRAY
114337: PPUSH
114338: CALL_OW 255
114342: PUSH
114343: EMPTY
114344: LIST
114345: LIST
114346: PPUSH
114347: CALL 58286 0 3
114351: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
114352: LD_VAR 0 2
114356: PUSH
114357: LD_VAR 0 4
114361: ARRAY
114362: PPUSH
114363: LD_VAR 0 1
114367: PPUSH
114368: CALL_OW 255
114372: PPUSH
114373: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
114377: LD_VAR 0 2
114381: PUSH
114382: LD_VAR 0 4
114386: ARRAY
114387: PPUSH
114388: CALL_OW 141
// end ;
114392: GO 114224
114394: POP
114395: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
114396: LD_VAR 0 1
114400: PPUSH
114401: LD_EXP 187
114405: PUSH
114406: LD_VAR 0 5
114410: ARRAY
114411: PUSH
114412: LD_INT 0
114414: PLUS
114415: PPUSH
114416: CALL_OW 505
// end ;
114420: LD_VAR 0 3
114424: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
114425: LD_INT 0
114427: PPUSH
114428: PPUSH
114429: PPUSH
114430: PPUSH
// if not hack in hackTanks then
114431: LD_VAR 0 1
114435: PUSH
114436: LD_EXP 186
114440: IN
114441: NOT
114442: IFFALSE 114446
// exit ;
114444: GO 114686
// index := GetElementIndex ( hackTanks , hack ) ;
114446: LD_ADDR_VAR 0 4
114450: PUSH
114451: LD_EXP 186
114455: PPUSH
114456: LD_VAR 0 1
114460: PPUSH
114461: CALL 58071 0 2
114465: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
114466: LD_ADDR_VAR 0 3
114470: PUSH
114471: DOUBLE
114472: LD_EXP 187
114476: PUSH
114477: LD_VAR 0 4
114481: ARRAY
114482: INC
114483: ST_TO_ADDR
114484: LD_INT 1
114486: PUSH
114487: FOR_DOWNTO
114488: IFFALSE 114660
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
114490: LD_ADDR_VAR 0 5
114494: PUSH
114495: LD_EXP 187
114499: PUSH
114500: LD_VAR 0 4
114504: ARRAY
114505: PUSH
114506: LD_VAR 0 3
114510: ARRAY
114511: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
114512: LD_VAR 0 5
114516: PUSH
114517: LD_INT 1
114519: ARRAY
114520: PPUSH
114521: CALL_OW 302
114525: NOT
114526: PUSH
114527: LD_VAR 0 5
114531: PUSH
114532: LD_INT 1
114534: ARRAY
114535: PPUSH
114536: CALL_OW 255
114540: PUSH
114541: LD_VAR 0 1
114545: PPUSH
114546: CALL_OW 255
114550: NONEQUAL
114551: OR
114552: IFFALSE 114658
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
114554: LD_VAR 0 5
114558: PUSH
114559: LD_INT 1
114561: ARRAY
114562: PPUSH
114563: CALL_OW 305
114567: PUSH
114568: LD_VAR 0 5
114572: PUSH
114573: LD_INT 1
114575: ARRAY
114576: PPUSH
114577: CALL_OW 255
114581: PUSH
114582: LD_VAR 0 1
114586: PPUSH
114587: CALL_OW 255
114591: EQUAL
114592: AND
114593: IFFALSE 114617
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
114595: LD_VAR 0 5
114599: PUSH
114600: LD_INT 1
114602: ARRAY
114603: PPUSH
114604: LD_VAR 0 5
114608: PUSH
114609: LD_INT 2
114611: ARRAY
114612: PPUSH
114613: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
114617: LD_ADDR_EXP 187
114621: PUSH
114622: LD_EXP 187
114626: PPUSH
114627: LD_VAR 0 4
114631: PPUSH
114632: LD_EXP 187
114636: PUSH
114637: LD_VAR 0 4
114641: ARRAY
114642: PPUSH
114643: LD_VAR 0 3
114647: PPUSH
114648: CALL_OW 3
114652: PPUSH
114653: CALL_OW 1
114657: ST_TO_ADDR
// end ; end ;
114658: GO 114487
114660: POP
114661: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
114662: LD_VAR 0 1
114666: PPUSH
114667: LD_EXP 187
114671: PUSH
114672: LD_VAR 0 4
114676: ARRAY
114677: PUSH
114678: LD_INT 0
114680: PLUS
114681: PPUSH
114682: CALL_OW 505
// end ;
114686: LD_VAR 0 2
114690: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
114691: LD_INT 0
114693: PPUSH
114694: PPUSH
114695: PPUSH
114696: PPUSH
// if not hack in hackTanks then
114697: LD_VAR 0 1
114701: PUSH
114702: LD_EXP 186
114706: IN
114707: NOT
114708: IFFALSE 114712
// exit ;
114710: GO 114797
// index := GetElementIndex ( hackTanks , hack ) ;
114712: LD_ADDR_VAR 0 5
114716: PUSH
114717: LD_EXP 186
114721: PPUSH
114722: LD_VAR 0 1
114726: PPUSH
114727: CALL 58071 0 2
114731: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
114732: LD_ADDR_VAR 0 4
114736: PUSH
114737: DOUBLE
114738: LD_INT 1
114740: DEC
114741: ST_TO_ADDR
114742: LD_EXP 187
114746: PUSH
114747: LD_VAR 0 5
114751: ARRAY
114752: PUSH
114753: FOR_TO
114754: IFFALSE 114795
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
114756: LD_EXP 187
114760: PUSH
114761: LD_VAR 0 5
114765: ARRAY
114766: PUSH
114767: LD_VAR 0 4
114771: ARRAY
114772: PUSH
114773: LD_INT 1
114775: ARRAY
114776: PUSH
114777: LD_VAR 0 2
114781: EQUAL
114782: IFFALSE 114793
// KillUnit ( vehicle ) ;
114784: LD_VAR 0 2
114788: PPUSH
114789: CALL_OW 66
114793: GO 114753
114795: POP
114796: POP
// end ;
114797: LD_VAR 0 3
114801: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
114802: LD_EXP 191
114806: NOT
114807: IFFALSE 114842
114809: GO 114811
114811: DISABLE
// begin initMiner := true ;
114812: LD_ADDR_EXP 191
114816: PUSH
114817: LD_INT 1
114819: ST_TO_ADDR
// minersList := [ ] ;
114820: LD_ADDR_EXP 192
114824: PUSH
114825: EMPTY
114826: ST_TO_ADDR
// minerMinesList := [ ] ;
114827: LD_ADDR_EXP 193
114831: PUSH
114832: EMPTY
114833: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
114834: LD_ADDR_EXP 194
114838: PUSH
114839: LD_INT 5
114841: ST_TO_ADDR
// end ;
114842: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
114843: LD_EXP 191
114847: PUSH
114848: LD_INT 34
114850: PUSH
114851: LD_INT 81
114853: PUSH
114854: EMPTY
114855: LIST
114856: LIST
114857: PPUSH
114858: CALL_OW 69
114862: AND
114863: IFFALSE 115324
114865: GO 114867
114867: DISABLE
114868: LD_INT 0
114870: PPUSH
114871: PPUSH
114872: PPUSH
114873: PPUSH
// begin enable ;
114874: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
114875: LD_ADDR_VAR 0 1
114879: PUSH
114880: LD_INT 34
114882: PUSH
114883: LD_INT 81
114885: PUSH
114886: EMPTY
114887: LIST
114888: LIST
114889: PPUSH
114890: CALL_OW 69
114894: PUSH
114895: FOR_IN
114896: IFFALSE 114968
// begin if not i in minersList then
114898: LD_VAR 0 1
114902: PUSH
114903: LD_EXP 192
114907: IN
114908: NOT
114909: IFFALSE 114966
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
114911: LD_ADDR_EXP 192
114915: PUSH
114916: LD_EXP 192
114920: PPUSH
114921: LD_EXP 192
114925: PUSH
114926: LD_INT 1
114928: PLUS
114929: PPUSH
114930: LD_VAR 0 1
114934: PPUSH
114935: CALL_OW 1
114939: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
114940: LD_ADDR_EXP 193
114944: PUSH
114945: LD_EXP 193
114949: PPUSH
114950: LD_EXP 193
114954: PUSH
114955: LD_INT 1
114957: PLUS
114958: PPUSH
114959: EMPTY
114960: PPUSH
114961: CALL_OW 1
114965: ST_TO_ADDR
// end end ;
114966: GO 114895
114968: POP
114969: POP
// for i := minerMinesList downto 1 do
114970: LD_ADDR_VAR 0 1
114974: PUSH
114975: DOUBLE
114976: LD_EXP 193
114980: INC
114981: ST_TO_ADDR
114982: LD_INT 1
114984: PUSH
114985: FOR_DOWNTO
114986: IFFALSE 115322
// begin if IsLive ( minersList [ i ] ) then
114988: LD_EXP 192
114992: PUSH
114993: LD_VAR 0 1
114997: ARRAY
114998: PPUSH
114999: CALL_OW 300
115003: IFFALSE 115031
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
115005: LD_EXP 192
115009: PUSH
115010: LD_VAR 0 1
115014: ARRAY
115015: PPUSH
115016: LD_EXP 193
115020: PUSH
115021: LD_VAR 0 1
115025: ARRAY
115026: PPUSH
115027: CALL_OW 505
// if not minerMinesList [ i ] then
115031: LD_EXP 193
115035: PUSH
115036: LD_VAR 0 1
115040: ARRAY
115041: NOT
115042: IFFALSE 115046
// continue ;
115044: GO 114985
// for j := minerMinesList [ i ] downto 1 do
115046: LD_ADDR_VAR 0 2
115050: PUSH
115051: DOUBLE
115052: LD_EXP 193
115056: PUSH
115057: LD_VAR 0 1
115061: ARRAY
115062: INC
115063: ST_TO_ADDR
115064: LD_INT 1
115066: PUSH
115067: FOR_DOWNTO
115068: IFFALSE 115318
// begin side := GetSide ( minersList [ i ] ) ;
115070: LD_ADDR_VAR 0 3
115074: PUSH
115075: LD_EXP 192
115079: PUSH
115080: LD_VAR 0 1
115084: ARRAY
115085: PPUSH
115086: CALL_OW 255
115090: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
115091: LD_ADDR_VAR 0 4
115095: PUSH
115096: LD_EXP 193
115100: PUSH
115101: LD_VAR 0 1
115105: ARRAY
115106: PUSH
115107: LD_VAR 0 2
115111: ARRAY
115112: PUSH
115113: LD_INT 1
115115: ARRAY
115116: PPUSH
115117: LD_EXP 193
115121: PUSH
115122: LD_VAR 0 1
115126: ARRAY
115127: PUSH
115128: LD_VAR 0 2
115132: ARRAY
115133: PUSH
115134: LD_INT 2
115136: ARRAY
115137: PPUSH
115138: CALL_OW 428
115142: ST_TO_ADDR
// if not tmp then
115143: LD_VAR 0 4
115147: NOT
115148: IFFALSE 115152
// continue ;
115150: GO 115067
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
115152: LD_VAR 0 4
115156: PUSH
115157: LD_INT 81
115159: PUSH
115160: LD_VAR 0 3
115164: PUSH
115165: EMPTY
115166: LIST
115167: LIST
115168: PPUSH
115169: CALL_OW 69
115173: IN
115174: PUSH
115175: LD_EXP 193
115179: PUSH
115180: LD_VAR 0 1
115184: ARRAY
115185: PUSH
115186: LD_VAR 0 2
115190: ARRAY
115191: PUSH
115192: LD_INT 1
115194: ARRAY
115195: PPUSH
115196: LD_EXP 193
115200: PUSH
115201: LD_VAR 0 1
115205: ARRAY
115206: PUSH
115207: LD_VAR 0 2
115211: ARRAY
115212: PUSH
115213: LD_INT 2
115215: ARRAY
115216: PPUSH
115217: CALL_OW 458
115221: AND
115222: IFFALSE 115316
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
115224: LD_EXP 193
115228: PUSH
115229: LD_VAR 0 1
115233: ARRAY
115234: PUSH
115235: LD_VAR 0 2
115239: ARRAY
115240: PUSH
115241: LD_INT 1
115243: ARRAY
115244: PPUSH
115245: LD_EXP 193
115249: PUSH
115250: LD_VAR 0 1
115254: ARRAY
115255: PUSH
115256: LD_VAR 0 2
115260: ARRAY
115261: PUSH
115262: LD_INT 2
115264: ARRAY
115265: PPUSH
115266: LD_VAR 0 3
115270: PPUSH
115271: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
115275: LD_ADDR_EXP 193
115279: PUSH
115280: LD_EXP 193
115284: PPUSH
115285: LD_VAR 0 1
115289: PPUSH
115290: LD_EXP 193
115294: PUSH
115295: LD_VAR 0 1
115299: ARRAY
115300: PPUSH
115301: LD_VAR 0 2
115305: PPUSH
115306: CALL_OW 3
115310: PPUSH
115311: CALL_OW 1
115315: ST_TO_ADDR
// end ; end ;
115316: GO 115067
115318: POP
115319: POP
// end ;
115320: GO 114985
115322: POP
115323: POP
// end ;
115324: PPOPN 4
115326: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
115327: LD_INT 0
115329: PPUSH
115330: PPUSH
// result := false ;
115331: LD_ADDR_VAR 0 4
115335: PUSH
115336: LD_INT 0
115338: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
115339: LD_VAR 0 1
115343: PPUSH
115344: CALL_OW 264
115348: PUSH
115349: LD_INT 81
115351: EQUAL
115352: NOT
115353: IFFALSE 115357
// exit ;
115355: GO 115597
// index := GetElementIndex ( minersList , unit ) ;
115357: LD_ADDR_VAR 0 5
115361: PUSH
115362: LD_EXP 192
115366: PPUSH
115367: LD_VAR 0 1
115371: PPUSH
115372: CALL 58071 0 2
115376: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
115377: LD_EXP 193
115381: PUSH
115382: LD_VAR 0 5
115386: ARRAY
115387: PUSH
115388: LD_EXP 194
115392: GREATEREQUAL
115393: IFFALSE 115397
// exit ;
115395: GO 115597
// ComMoveXY ( unit , x , y ) ;
115397: LD_VAR 0 1
115401: PPUSH
115402: LD_VAR 0 2
115406: PPUSH
115407: LD_VAR 0 3
115411: PPUSH
115412: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
115416: LD_INT 35
115418: PPUSH
115419: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
115423: LD_VAR 0 1
115427: PPUSH
115428: LD_VAR 0 2
115432: PPUSH
115433: LD_VAR 0 3
115437: PPUSH
115438: CALL 89812 0 3
115442: NOT
115443: PUSH
115444: LD_VAR 0 1
115448: PPUSH
115449: CALL_OW 314
115453: AND
115454: IFFALSE 115458
// exit ;
115456: GO 115597
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
115458: LD_VAR 0 2
115462: PPUSH
115463: LD_VAR 0 3
115467: PPUSH
115468: CALL_OW 428
115472: PUSH
115473: LD_VAR 0 1
115477: EQUAL
115478: PUSH
115479: LD_VAR 0 1
115483: PPUSH
115484: CALL_OW 314
115488: NOT
115489: AND
115490: IFFALSE 115416
// PlaySoundXY ( x , y , PlantMine ) ;
115492: LD_VAR 0 2
115496: PPUSH
115497: LD_VAR 0 3
115501: PPUSH
115502: LD_STRING PlantMine
115504: PPUSH
115505: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
115509: LD_VAR 0 2
115513: PPUSH
115514: LD_VAR 0 3
115518: PPUSH
115519: LD_VAR 0 1
115523: PPUSH
115524: CALL_OW 255
115528: PPUSH
115529: LD_INT 0
115531: PPUSH
115532: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
115536: LD_ADDR_EXP 193
115540: PUSH
115541: LD_EXP 193
115545: PPUSH
115546: LD_VAR 0 5
115550: PUSH
115551: LD_EXP 193
115555: PUSH
115556: LD_VAR 0 5
115560: ARRAY
115561: PUSH
115562: LD_INT 1
115564: PLUS
115565: PUSH
115566: EMPTY
115567: LIST
115568: LIST
115569: PPUSH
115570: LD_VAR 0 2
115574: PUSH
115575: LD_VAR 0 3
115579: PUSH
115580: EMPTY
115581: LIST
115582: LIST
115583: PPUSH
115584: CALL 58286 0 3
115588: ST_TO_ADDR
// result := true ;
115589: LD_ADDR_VAR 0 4
115593: PUSH
115594: LD_INT 1
115596: ST_TO_ADDR
// end ;
115597: LD_VAR 0 4
115601: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
115602: LD_INT 0
115604: PPUSH
115605: PPUSH
115606: PPUSH
// if not unit in minersList then
115607: LD_VAR 0 1
115611: PUSH
115612: LD_EXP 192
115616: IN
115617: NOT
115618: IFFALSE 115622
// exit ;
115620: GO 116014
// index := GetElementIndex ( minersList , unit ) ;
115622: LD_ADDR_VAR 0 6
115626: PUSH
115627: LD_EXP 192
115631: PPUSH
115632: LD_VAR 0 1
115636: PPUSH
115637: CALL 58071 0 2
115641: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
115642: LD_ADDR_VAR 0 5
115646: PUSH
115647: DOUBLE
115648: LD_EXP 193
115652: PUSH
115653: LD_VAR 0 6
115657: ARRAY
115658: INC
115659: ST_TO_ADDR
115660: LD_INT 1
115662: PUSH
115663: FOR_DOWNTO
115664: IFFALSE 115825
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
115666: LD_EXP 193
115670: PUSH
115671: LD_VAR 0 6
115675: ARRAY
115676: PUSH
115677: LD_VAR 0 5
115681: ARRAY
115682: PUSH
115683: LD_INT 1
115685: ARRAY
115686: PUSH
115687: LD_VAR 0 2
115691: EQUAL
115692: PUSH
115693: LD_EXP 193
115697: PUSH
115698: LD_VAR 0 6
115702: ARRAY
115703: PUSH
115704: LD_VAR 0 5
115708: ARRAY
115709: PUSH
115710: LD_INT 2
115712: ARRAY
115713: PUSH
115714: LD_VAR 0 3
115718: EQUAL
115719: AND
115720: IFFALSE 115823
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
115722: LD_EXP 193
115726: PUSH
115727: LD_VAR 0 6
115731: ARRAY
115732: PUSH
115733: LD_VAR 0 5
115737: ARRAY
115738: PUSH
115739: LD_INT 1
115741: ARRAY
115742: PPUSH
115743: LD_EXP 193
115747: PUSH
115748: LD_VAR 0 6
115752: ARRAY
115753: PUSH
115754: LD_VAR 0 5
115758: ARRAY
115759: PUSH
115760: LD_INT 2
115762: ARRAY
115763: PPUSH
115764: LD_VAR 0 1
115768: PPUSH
115769: CALL_OW 255
115773: PPUSH
115774: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
115778: LD_ADDR_EXP 193
115782: PUSH
115783: LD_EXP 193
115787: PPUSH
115788: LD_VAR 0 6
115792: PPUSH
115793: LD_EXP 193
115797: PUSH
115798: LD_VAR 0 6
115802: ARRAY
115803: PPUSH
115804: LD_VAR 0 5
115808: PPUSH
115809: CALL_OW 3
115813: PPUSH
115814: CALL_OW 1
115818: ST_TO_ADDR
// exit ;
115819: POP
115820: POP
115821: GO 116014
// end ; end ;
115823: GO 115663
115825: POP
115826: POP
// for i := minerMinesList [ index ] downto 1 do
115827: LD_ADDR_VAR 0 5
115831: PUSH
115832: DOUBLE
115833: LD_EXP 193
115837: PUSH
115838: LD_VAR 0 6
115842: ARRAY
115843: INC
115844: ST_TO_ADDR
115845: LD_INT 1
115847: PUSH
115848: FOR_DOWNTO
115849: IFFALSE 116012
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
115851: LD_EXP 193
115855: PUSH
115856: LD_VAR 0 6
115860: ARRAY
115861: PUSH
115862: LD_VAR 0 5
115866: ARRAY
115867: PUSH
115868: LD_INT 1
115870: ARRAY
115871: PPUSH
115872: LD_EXP 193
115876: PUSH
115877: LD_VAR 0 6
115881: ARRAY
115882: PUSH
115883: LD_VAR 0 5
115887: ARRAY
115888: PUSH
115889: LD_INT 2
115891: ARRAY
115892: PPUSH
115893: LD_VAR 0 2
115897: PPUSH
115898: LD_VAR 0 3
115902: PPUSH
115903: CALL_OW 298
115907: PUSH
115908: LD_INT 6
115910: LESS
115911: IFFALSE 116010
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
115913: LD_EXP 193
115917: PUSH
115918: LD_VAR 0 6
115922: ARRAY
115923: PUSH
115924: LD_VAR 0 5
115928: ARRAY
115929: PUSH
115930: LD_INT 1
115932: ARRAY
115933: PPUSH
115934: LD_EXP 193
115938: PUSH
115939: LD_VAR 0 6
115943: ARRAY
115944: PUSH
115945: LD_VAR 0 5
115949: ARRAY
115950: PUSH
115951: LD_INT 2
115953: ARRAY
115954: PPUSH
115955: LD_VAR 0 1
115959: PPUSH
115960: CALL_OW 255
115964: PPUSH
115965: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
115969: LD_ADDR_EXP 193
115973: PUSH
115974: LD_EXP 193
115978: PPUSH
115979: LD_VAR 0 6
115983: PPUSH
115984: LD_EXP 193
115988: PUSH
115989: LD_VAR 0 6
115993: ARRAY
115994: PPUSH
115995: LD_VAR 0 5
115999: PPUSH
116000: CALL_OW 3
116004: PPUSH
116005: CALL_OW 1
116009: ST_TO_ADDR
// end ; end ;
116010: GO 115848
116012: POP
116013: POP
// end ;
116014: LD_VAR 0 4
116018: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
116019: LD_INT 0
116021: PPUSH
116022: PPUSH
116023: PPUSH
116024: PPUSH
116025: PPUSH
116026: PPUSH
116027: PPUSH
116028: PPUSH
116029: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
116030: LD_VAR 0 1
116034: PPUSH
116035: CALL_OW 264
116039: PUSH
116040: LD_INT 81
116042: EQUAL
116043: NOT
116044: PUSH
116045: LD_VAR 0 1
116049: PUSH
116050: LD_EXP 192
116054: IN
116055: NOT
116056: OR
116057: IFFALSE 116061
// exit ;
116059: GO 116383
// index := GetElementIndex ( minersList , unit ) ;
116061: LD_ADDR_VAR 0 6
116065: PUSH
116066: LD_EXP 192
116070: PPUSH
116071: LD_VAR 0 1
116075: PPUSH
116076: CALL 58071 0 2
116080: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
116081: LD_ADDR_VAR 0 8
116085: PUSH
116086: LD_EXP 194
116090: PUSH
116091: LD_EXP 193
116095: PUSH
116096: LD_VAR 0 6
116100: ARRAY
116101: MINUS
116102: ST_TO_ADDR
// if not minesFreeAmount then
116103: LD_VAR 0 8
116107: NOT
116108: IFFALSE 116112
// exit ;
116110: GO 116383
// tmp := [ ] ;
116112: LD_ADDR_VAR 0 7
116116: PUSH
116117: EMPTY
116118: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
116119: LD_ADDR_VAR 0 5
116123: PUSH
116124: DOUBLE
116125: LD_INT 1
116127: DEC
116128: ST_TO_ADDR
116129: LD_VAR 0 8
116133: PUSH
116134: FOR_TO
116135: IFFALSE 116330
// begin _d := rand ( 0 , 5 ) ;
116137: LD_ADDR_VAR 0 11
116141: PUSH
116142: LD_INT 0
116144: PPUSH
116145: LD_INT 5
116147: PPUSH
116148: CALL_OW 12
116152: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
116153: LD_ADDR_VAR 0 12
116157: PUSH
116158: LD_INT 2
116160: PPUSH
116161: LD_INT 6
116163: PPUSH
116164: CALL_OW 12
116168: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
116169: LD_ADDR_VAR 0 9
116173: PUSH
116174: LD_VAR 0 2
116178: PPUSH
116179: LD_VAR 0 11
116183: PPUSH
116184: LD_VAR 0 12
116188: PPUSH
116189: CALL_OW 272
116193: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
116194: LD_ADDR_VAR 0 10
116198: PUSH
116199: LD_VAR 0 3
116203: PPUSH
116204: LD_VAR 0 11
116208: PPUSH
116209: LD_VAR 0 12
116213: PPUSH
116214: CALL_OW 273
116218: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
116219: LD_VAR 0 9
116223: PPUSH
116224: LD_VAR 0 10
116228: PPUSH
116229: CALL_OW 488
116233: PUSH
116234: LD_VAR 0 9
116238: PUSH
116239: LD_VAR 0 10
116243: PUSH
116244: EMPTY
116245: LIST
116246: LIST
116247: PUSH
116248: LD_VAR 0 7
116252: IN
116253: NOT
116254: AND
116255: PUSH
116256: LD_VAR 0 9
116260: PPUSH
116261: LD_VAR 0 10
116265: PPUSH
116266: CALL_OW 458
116270: NOT
116271: AND
116272: IFFALSE 116314
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
116274: LD_ADDR_VAR 0 7
116278: PUSH
116279: LD_VAR 0 7
116283: PPUSH
116284: LD_VAR 0 7
116288: PUSH
116289: LD_INT 1
116291: PLUS
116292: PPUSH
116293: LD_VAR 0 9
116297: PUSH
116298: LD_VAR 0 10
116302: PUSH
116303: EMPTY
116304: LIST
116305: LIST
116306: PPUSH
116307: CALL_OW 1
116311: ST_TO_ADDR
116312: GO 116328
// i := i - 1 ;
116314: LD_ADDR_VAR 0 5
116318: PUSH
116319: LD_VAR 0 5
116323: PUSH
116324: LD_INT 1
116326: MINUS
116327: ST_TO_ADDR
// end ;
116328: GO 116134
116330: POP
116331: POP
// for i in tmp do
116332: LD_ADDR_VAR 0 5
116336: PUSH
116337: LD_VAR 0 7
116341: PUSH
116342: FOR_IN
116343: IFFALSE 116381
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
116345: LD_VAR 0 1
116349: PPUSH
116350: LD_VAR 0 5
116354: PUSH
116355: LD_INT 1
116357: ARRAY
116358: PPUSH
116359: LD_VAR 0 5
116363: PUSH
116364: LD_INT 2
116366: ARRAY
116367: PPUSH
116368: CALL 115327 0 3
116372: NOT
116373: IFFALSE 116379
// exit ;
116375: POP
116376: POP
116377: GO 116383
116379: GO 116342
116381: POP
116382: POP
// end ;
116383: LD_VAR 0 4
116387: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
116388: LD_INT 0
116390: PPUSH
116391: PPUSH
116392: PPUSH
116393: PPUSH
116394: PPUSH
116395: PPUSH
116396: PPUSH
// if not GetClass ( unit ) = class_sniper then
116397: LD_VAR 0 1
116401: PPUSH
116402: CALL_OW 257
116406: PUSH
116407: LD_INT 5
116409: EQUAL
116410: NOT
116411: IFFALSE 116415
// exit ;
116413: GO 116803
// dist := 8 ;
116415: LD_ADDR_VAR 0 5
116419: PUSH
116420: LD_INT 8
116422: ST_TO_ADDR
// viewRange := 12 ;
116423: LD_ADDR_VAR 0 7
116427: PUSH
116428: LD_INT 12
116430: ST_TO_ADDR
// side := GetSide ( unit ) ;
116431: LD_ADDR_VAR 0 6
116435: PUSH
116436: LD_VAR 0 1
116440: PPUSH
116441: CALL_OW 255
116445: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
116446: LD_INT 61
116448: PPUSH
116449: LD_VAR 0 6
116453: PPUSH
116454: CALL_OW 321
116458: PUSH
116459: LD_INT 2
116461: EQUAL
116462: IFFALSE 116472
// viewRange := 16 ;
116464: LD_ADDR_VAR 0 7
116468: PUSH
116469: LD_INT 16
116471: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
116472: LD_VAR 0 1
116476: PPUSH
116477: LD_VAR 0 2
116481: PPUSH
116482: LD_VAR 0 3
116486: PPUSH
116487: CALL_OW 297
116491: PUSH
116492: LD_VAR 0 5
116496: GREATER
116497: IFFALSE 116576
// begin ComMoveXY ( unit , x , y ) ;
116499: LD_VAR 0 1
116503: PPUSH
116504: LD_VAR 0 2
116508: PPUSH
116509: LD_VAR 0 3
116513: PPUSH
116514: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
116518: LD_INT 35
116520: PPUSH
116521: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
116525: LD_VAR 0 1
116529: PPUSH
116530: LD_VAR 0 2
116534: PPUSH
116535: LD_VAR 0 3
116539: PPUSH
116540: CALL 89812 0 3
116544: NOT
116545: IFFALSE 116549
// exit ;
116547: GO 116803
// until GetDistUnitXY ( unit , x , y ) < dist ;
116549: LD_VAR 0 1
116553: PPUSH
116554: LD_VAR 0 2
116558: PPUSH
116559: LD_VAR 0 3
116563: PPUSH
116564: CALL_OW 297
116568: PUSH
116569: LD_VAR 0 5
116573: LESS
116574: IFFALSE 116518
// end ; ComTurnXY ( unit , x , y ) ;
116576: LD_VAR 0 1
116580: PPUSH
116581: LD_VAR 0 2
116585: PPUSH
116586: LD_VAR 0 3
116590: PPUSH
116591: CALL_OW 118
// wait ( 5 ) ;
116595: LD_INT 5
116597: PPUSH
116598: CALL_OW 67
// _d := GetDir ( unit ) ;
116602: LD_ADDR_VAR 0 10
116606: PUSH
116607: LD_VAR 0 1
116611: PPUSH
116612: CALL_OW 254
116616: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
116617: LD_ADDR_VAR 0 8
116621: PUSH
116622: LD_VAR 0 1
116626: PPUSH
116627: CALL_OW 250
116631: PPUSH
116632: LD_VAR 0 10
116636: PPUSH
116637: LD_VAR 0 5
116641: PPUSH
116642: CALL_OW 272
116646: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
116647: LD_ADDR_VAR 0 9
116651: PUSH
116652: LD_VAR 0 1
116656: PPUSH
116657: CALL_OW 251
116661: PPUSH
116662: LD_VAR 0 10
116666: PPUSH
116667: LD_VAR 0 5
116671: PPUSH
116672: CALL_OW 273
116676: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
116677: LD_VAR 0 8
116681: PPUSH
116682: LD_VAR 0 9
116686: PPUSH
116687: CALL_OW 488
116691: NOT
116692: IFFALSE 116696
// exit ;
116694: GO 116803
// ComAnimCustom ( unit , 1 ) ;
116696: LD_VAR 0 1
116700: PPUSH
116701: LD_INT 1
116703: PPUSH
116704: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
116708: LD_VAR 0 8
116712: PPUSH
116713: LD_VAR 0 9
116717: PPUSH
116718: LD_VAR 0 6
116722: PPUSH
116723: LD_VAR 0 7
116727: PPUSH
116728: CALL_OW 330
// repeat wait ( 1 ) ;
116732: LD_INT 1
116734: PPUSH
116735: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
116739: LD_VAR 0 1
116743: PPUSH
116744: CALL_OW 316
116748: PUSH
116749: LD_VAR 0 1
116753: PPUSH
116754: CALL_OW 314
116758: OR
116759: PUSH
116760: LD_VAR 0 1
116764: PPUSH
116765: CALL_OW 302
116769: NOT
116770: OR
116771: PUSH
116772: LD_VAR 0 1
116776: PPUSH
116777: CALL_OW 301
116781: OR
116782: IFFALSE 116732
// RemoveSeeing ( _x , _y , side ) ;
116784: LD_VAR 0 8
116788: PPUSH
116789: LD_VAR 0 9
116793: PPUSH
116794: LD_VAR 0 6
116798: PPUSH
116799: CALL_OW 331
// end ; end_of_file
116803: LD_VAR 0 4
116807: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
116808: LD_INT 0
116810: PPUSH
116811: PPUSH
116812: PPUSH
116813: PPUSH
116814: PPUSH
116815: PPUSH
116816: PPUSH
116817: PPUSH
116818: PPUSH
116819: PPUSH
116820: PPUSH
116821: PPUSH
116822: PPUSH
116823: PPUSH
116824: PPUSH
116825: PPUSH
116826: PPUSH
116827: PPUSH
116828: PPUSH
116829: PPUSH
116830: PPUSH
116831: PPUSH
116832: PPUSH
116833: PPUSH
116834: PPUSH
116835: PPUSH
116836: PPUSH
116837: PPUSH
116838: PPUSH
116839: PPUSH
116840: PPUSH
116841: PPUSH
116842: PPUSH
116843: PPUSH
// if not list then
116844: LD_VAR 0 1
116848: NOT
116849: IFFALSE 116853
// exit ;
116851: GO 121512
// base := list [ 1 ] ;
116853: LD_ADDR_VAR 0 3
116857: PUSH
116858: LD_VAR 0 1
116862: PUSH
116863: LD_INT 1
116865: ARRAY
116866: ST_TO_ADDR
// group := list [ 2 ] ;
116867: LD_ADDR_VAR 0 4
116871: PUSH
116872: LD_VAR 0 1
116876: PUSH
116877: LD_INT 2
116879: ARRAY
116880: ST_TO_ADDR
// path := list [ 3 ] ;
116881: LD_ADDR_VAR 0 5
116885: PUSH
116886: LD_VAR 0 1
116890: PUSH
116891: LD_INT 3
116893: ARRAY
116894: ST_TO_ADDR
// flags := list [ 4 ] ;
116895: LD_ADDR_VAR 0 6
116899: PUSH
116900: LD_VAR 0 1
116904: PUSH
116905: LD_INT 4
116907: ARRAY
116908: ST_TO_ADDR
// mined := [ ] ;
116909: LD_ADDR_VAR 0 27
116913: PUSH
116914: EMPTY
116915: ST_TO_ADDR
// bombed := [ ] ;
116916: LD_ADDR_VAR 0 28
116920: PUSH
116921: EMPTY
116922: ST_TO_ADDR
// healers := [ ] ;
116923: LD_ADDR_VAR 0 31
116927: PUSH
116928: EMPTY
116929: ST_TO_ADDR
// to_heal := [ ] ;
116930: LD_ADDR_VAR 0 30
116934: PUSH
116935: EMPTY
116936: ST_TO_ADDR
// repairs := [ ] ;
116937: LD_ADDR_VAR 0 33
116941: PUSH
116942: EMPTY
116943: ST_TO_ADDR
// to_repair := [ ] ;
116944: LD_ADDR_VAR 0 32
116948: PUSH
116949: EMPTY
116950: ST_TO_ADDR
// if not group or not path then
116951: LD_VAR 0 4
116955: NOT
116956: PUSH
116957: LD_VAR 0 5
116961: NOT
116962: OR
116963: IFFALSE 116967
// exit ;
116965: GO 121512
// side := GetSide ( group [ 1 ] ) ;
116967: LD_ADDR_VAR 0 35
116971: PUSH
116972: LD_VAR 0 4
116976: PUSH
116977: LD_INT 1
116979: ARRAY
116980: PPUSH
116981: CALL_OW 255
116985: ST_TO_ADDR
// if flags then
116986: LD_VAR 0 6
116990: IFFALSE 117134
// begin f_ignore_area := flags [ 1 ] ;
116992: LD_ADDR_VAR 0 17
116996: PUSH
116997: LD_VAR 0 6
117001: PUSH
117002: LD_INT 1
117004: ARRAY
117005: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
117006: LD_ADDR_VAR 0 18
117010: PUSH
117011: LD_VAR 0 6
117015: PUSH
117016: LD_INT 2
117018: ARRAY
117019: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
117020: LD_ADDR_VAR 0 19
117024: PUSH
117025: LD_VAR 0 6
117029: PUSH
117030: LD_INT 3
117032: ARRAY
117033: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
117034: LD_ADDR_VAR 0 20
117038: PUSH
117039: LD_VAR 0 6
117043: PUSH
117044: LD_INT 4
117046: ARRAY
117047: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
117048: LD_ADDR_VAR 0 21
117052: PUSH
117053: LD_VAR 0 6
117057: PUSH
117058: LD_INT 5
117060: ARRAY
117061: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
117062: LD_ADDR_VAR 0 22
117066: PUSH
117067: LD_VAR 0 6
117071: PUSH
117072: LD_INT 6
117074: ARRAY
117075: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
117076: LD_ADDR_VAR 0 23
117080: PUSH
117081: LD_VAR 0 6
117085: PUSH
117086: LD_INT 7
117088: ARRAY
117089: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
117090: LD_ADDR_VAR 0 24
117094: PUSH
117095: LD_VAR 0 6
117099: PUSH
117100: LD_INT 8
117102: ARRAY
117103: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
117104: LD_ADDR_VAR 0 25
117108: PUSH
117109: LD_VAR 0 6
117113: PUSH
117114: LD_INT 9
117116: ARRAY
117117: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
117118: LD_ADDR_VAR 0 26
117122: PUSH
117123: LD_VAR 0 6
117127: PUSH
117128: LD_INT 10
117130: ARRAY
117131: ST_TO_ADDR
// end else
117132: GO 117214
// begin f_ignore_area := false ;
117134: LD_ADDR_VAR 0 17
117138: PUSH
117139: LD_INT 0
117141: ST_TO_ADDR
// f_capture := false ;
117142: LD_ADDR_VAR 0 18
117146: PUSH
117147: LD_INT 0
117149: ST_TO_ADDR
// f_ignore_civ := false ;
117150: LD_ADDR_VAR 0 19
117154: PUSH
117155: LD_INT 0
117157: ST_TO_ADDR
// f_murder := false ;
117158: LD_ADDR_VAR 0 20
117162: PUSH
117163: LD_INT 0
117165: ST_TO_ADDR
// f_mines := false ;
117166: LD_ADDR_VAR 0 21
117170: PUSH
117171: LD_INT 0
117173: ST_TO_ADDR
// f_repair := false ;
117174: LD_ADDR_VAR 0 22
117178: PUSH
117179: LD_INT 0
117181: ST_TO_ADDR
// f_heal := false ;
117182: LD_ADDR_VAR 0 23
117186: PUSH
117187: LD_INT 0
117189: ST_TO_ADDR
// f_spacetime := false ;
117190: LD_ADDR_VAR 0 24
117194: PUSH
117195: LD_INT 0
117197: ST_TO_ADDR
// f_attack_depot := false ;
117198: LD_ADDR_VAR 0 25
117202: PUSH
117203: LD_INT 0
117205: ST_TO_ADDR
// f_crawl := false ;
117206: LD_ADDR_VAR 0 26
117210: PUSH
117211: LD_INT 0
117213: ST_TO_ADDR
// end ; if f_heal then
117214: LD_VAR 0 23
117218: IFFALSE 117245
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
117220: LD_ADDR_VAR 0 31
117224: PUSH
117225: LD_VAR 0 4
117229: PPUSH
117230: LD_INT 25
117232: PUSH
117233: LD_INT 4
117235: PUSH
117236: EMPTY
117237: LIST
117238: LIST
117239: PPUSH
117240: CALL_OW 72
117244: ST_TO_ADDR
// if f_repair then
117245: LD_VAR 0 22
117249: IFFALSE 117276
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
117251: LD_ADDR_VAR 0 33
117255: PUSH
117256: LD_VAR 0 4
117260: PPUSH
117261: LD_INT 25
117263: PUSH
117264: LD_INT 3
117266: PUSH
117267: EMPTY
117268: LIST
117269: LIST
117270: PPUSH
117271: CALL_OW 72
117275: ST_TO_ADDR
// units_path := [ ] ;
117276: LD_ADDR_VAR 0 16
117280: PUSH
117281: EMPTY
117282: ST_TO_ADDR
// for i = 1 to group do
117283: LD_ADDR_VAR 0 7
117287: PUSH
117288: DOUBLE
117289: LD_INT 1
117291: DEC
117292: ST_TO_ADDR
117293: LD_VAR 0 4
117297: PUSH
117298: FOR_TO
117299: IFFALSE 117328
// units_path := Replace ( units_path , i , path ) ;
117301: LD_ADDR_VAR 0 16
117305: PUSH
117306: LD_VAR 0 16
117310: PPUSH
117311: LD_VAR 0 7
117315: PPUSH
117316: LD_VAR 0 5
117320: PPUSH
117321: CALL_OW 1
117325: ST_TO_ADDR
117326: GO 117298
117328: POP
117329: POP
// repeat for i = group downto 1 do
117330: LD_ADDR_VAR 0 7
117334: PUSH
117335: DOUBLE
117336: LD_VAR 0 4
117340: INC
117341: ST_TO_ADDR
117342: LD_INT 1
117344: PUSH
117345: FOR_DOWNTO
117346: IFFALSE 121468
// begin wait ( 5 ) ;
117348: LD_INT 5
117350: PPUSH
117351: CALL_OW 67
// tmp := [ ] ;
117355: LD_ADDR_VAR 0 14
117359: PUSH
117360: EMPTY
117361: ST_TO_ADDR
// attacking := false ;
117362: LD_ADDR_VAR 0 29
117366: PUSH
117367: LD_INT 0
117369: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
117370: LD_VAR 0 4
117374: PUSH
117375: LD_VAR 0 7
117379: ARRAY
117380: PPUSH
117381: CALL_OW 301
117385: PUSH
117386: LD_VAR 0 4
117390: PUSH
117391: LD_VAR 0 7
117395: ARRAY
117396: NOT
117397: OR
117398: IFFALSE 117507
// begin if GetType ( group [ i ] ) = unit_human then
117400: LD_VAR 0 4
117404: PUSH
117405: LD_VAR 0 7
117409: ARRAY
117410: PPUSH
117411: CALL_OW 247
117415: PUSH
117416: LD_INT 1
117418: EQUAL
117419: IFFALSE 117465
// begin to_heal := to_heal diff group [ i ] ;
117421: LD_ADDR_VAR 0 30
117425: PUSH
117426: LD_VAR 0 30
117430: PUSH
117431: LD_VAR 0 4
117435: PUSH
117436: LD_VAR 0 7
117440: ARRAY
117441: DIFF
117442: ST_TO_ADDR
// healers := healers diff group [ i ] ;
117443: LD_ADDR_VAR 0 31
117447: PUSH
117448: LD_VAR 0 31
117452: PUSH
117453: LD_VAR 0 4
117457: PUSH
117458: LD_VAR 0 7
117462: ARRAY
117463: DIFF
117464: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
117465: LD_ADDR_VAR 0 4
117469: PUSH
117470: LD_VAR 0 4
117474: PPUSH
117475: LD_VAR 0 7
117479: PPUSH
117480: CALL_OW 3
117484: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
117485: LD_ADDR_VAR 0 16
117489: PUSH
117490: LD_VAR 0 16
117494: PPUSH
117495: LD_VAR 0 7
117499: PPUSH
117500: CALL_OW 3
117504: ST_TO_ADDR
// continue ;
117505: GO 117345
// end ; if f_repair then
117507: LD_VAR 0 22
117511: IFFALSE 118000
// begin if GetType ( group [ i ] ) = unit_vehicle then
117513: LD_VAR 0 4
117517: PUSH
117518: LD_VAR 0 7
117522: ARRAY
117523: PPUSH
117524: CALL_OW 247
117528: PUSH
117529: LD_INT 2
117531: EQUAL
117532: IFFALSE 117722
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
117534: LD_VAR 0 4
117538: PUSH
117539: LD_VAR 0 7
117543: ARRAY
117544: PPUSH
117545: CALL_OW 256
117549: PUSH
117550: LD_INT 700
117552: LESS
117553: PUSH
117554: LD_VAR 0 4
117558: PUSH
117559: LD_VAR 0 7
117563: ARRAY
117564: PUSH
117565: LD_VAR 0 32
117569: IN
117570: NOT
117571: AND
117572: IFFALSE 117596
// to_repair := to_repair union group [ i ] ;
117574: LD_ADDR_VAR 0 32
117578: PUSH
117579: LD_VAR 0 32
117583: PUSH
117584: LD_VAR 0 4
117588: PUSH
117589: LD_VAR 0 7
117593: ARRAY
117594: UNION
117595: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
117596: LD_VAR 0 4
117600: PUSH
117601: LD_VAR 0 7
117605: ARRAY
117606: PPUSH
117607: CALL_OW 256
117611: PUSH
117612: LD_INT 1000
117614: EQUAL
117615: PUSH
117616: LD_VAR 0 4
117620: PUSH
117621: LD_VAR 0 7
117625: ARRAY
117626: PUSH
117627: LD_VAR 0 32
117631: IN
117632: AND
117633: IFFALSE 117657
// to_repair := to_repair diff group [ i ] ;
117635: LD_ADDR_VAR 0 32
117639: PUSH
117640: LD_VAR 0 32
117644: PUSH
117645: LD_VAR 0 4
117649: PUSH
117650: LD_VAR 0 7
117654: ARRAY
117655: DIFF
117656: ST_TO_ADDR
// if group [ i ] in to_repair then
117657: LD_VAR 0 4
117661: PUSH
117662: LD_VAR 0 7
117666: ARRAY
117667: PUSH
117668: LD_VAR 0 32
117672: IN
117673: IFFALSE 117720
// begin if not IsInArea ( group [ i ] , f_repair ) then
117675: LD_VAR 0 4
117679: PUSH
117680: LD_VAR 0 7
117684: ARRAY
117685: PPUSH
117686: LD_VAR 0 22
117690: PPUSH
117691: CALL_OW 308
117695: NOT
117696: IFFALSE 117718
// ComMoveToArea ( group [ i ] , f_repair ) ;
117698: LD_VAR 0 4
117702: PUSH
117703: LD_VAR 0 7
117707: ARRAY
117708: PPUSH
117709: LD_VAR 0 22
117713: PPUSH
117714: CALL_OW 113
// continue ;
117718: GO 117345
// end ; end else
117720: GO 118000
// if group [ i ] in repairs then
117722: LD_VAR 0 4
117726: PUSH
117727: LD_VAR 0 7
117731: ARRAY
117732: PUSH
117733: LD_VAR 0 33
117737: IN
117738: IFFALSE 118000
// begin if IsInUnit ( group [ i ] ) then
117740: LD_VAR 0 4
117744: PUSH
117745: LD_VAR 0 7
117749: ARRAY
117750: PPUSH
117751: CALL_OW 310
117755: IFFALSE 117823
// begin z := IsInUnit ( group [ i ] ) ;
117757: LD_ADDR_VAR 0 13
117761: PUSH
117762: LD_VAR 0 4
117766: PUSH
117767: LD_VAR 0 7
117771: ARRAY
117772: PPUSH
117773: CALL_OW 310
117777: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
117778: LD_VAR 0 13
117782: PUSH
117783: LD_VAR 0 32
117787: IN
117788: PUSH
117789: LD_VAR 0 13
117793: PPUSH
117794: LD_VAR 0 22
117798: PPUSH
117799: CALL_OW 308
117803: AND
117804: IFFALSE 117821
// ComExitVehicle ( group [ i ] ) ;
117806: LD_VAR 0 4
117810: PUSH
117811: LD_VAR 0 7
117815: ARRAY
117816: PPUSH
117817: CALL_OW 121
// end else
117821: GO 118000
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
117823: LD_ADDR_VAR 0 13
117827: PUSH
117828: LD_VAR 0 4
117832: PPUSH
117833: LD_INT 95
117835: PUSH
117836: LD_VAR 0 22
117840: PUSH
117841: EMPTY
117842: LIST
117843: LIST
117844: PUSH
117845: LD_INT 58
117847: PUSH
117848: EMPTY
117849: LIST
117850: PUSH
117851: EMPTY
117852: LIST
117853: LIST
117854: PPUSH
117855: CALL_OW 72
117859: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
117860: LD_VAR 0 4
117864: PUSH
117865: LD_VAR 0 7
117869: ARRAY
117870: PPUSH
117871: CALL_OW 314
117875: NOT
117876: IFFALSE 117998
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
117878: LD_ADDR_VAR 0 10
117882: PUSH
117883: LD_VAR 0 13
117887: PPUSH
117888: LD_VAR 0 4
117892: PUSH
117893: LD_VAR 0 7
117897: ARRAY
117898: PPUSH
117899: CALL_OW 74
117903: ST_TO_ADDR
// if not x then
117904: LD_VAR 0 10
117908: NOT
117909: IFFALSE 117913
// continue ;
117911: GO 117345
// if GetLives ( x ) < 1000 then
117913: LD_VAR 0 10
117917: PPUSH
117918: CALL_OW 256
117922: PUSH
117923: LD_INT 1000
117925: LESS
117926: IFFALSE 117950
// ComRepairVehicle ( group [ i ] , x ) else
117928: LD_VAR 0 4
117932: PUSH
117933: LD_VAR 0 7
117937: ARRAY
117938: PPUSH
117939: LD_VAR 0 10
117943: PPUSH
117944: CALL_OW 129
117948: GO 117998
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
117950: LD_VAR 0 23
117954: PUSH
117955: LD_VAR 0 4
117959: PUSH
117960: LD_VAR 0 7
117964: ARRAY
117965: PPUSH
117966: CALL_OW 256
117970: PUSH
117971: LD_INT 1000
117973: LESS
117974: AND
117975: NOT
117976: IFFALSE 117998
// ComEnterUnit ( group [ i ] , x ) ;
117978: LD_VAR 0 4
117982: PUSH
117983: LD_VAR 0 7
117987: ARRAY
117988: PPUSH
117989: LD_VAR 0 10
117993: PPUSH
117994: CALL_OW 120
// end ; continue ;
117998: GO 117345
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
118000: LD_VAR 0 23
118004: PUSH
118005: LD_VAR 0 4
118009: PUSH
118010: LD_VAR 0 7
118014: ARRAY
118015: PPUSH
118016: CALL_OW 247
118020: PUSH
118021: LD_INT 1
118023: EQUAL
118024: AND
118025: IFFALSE 118503
// begin if group [ i ] in healers then
118027: LD_VAR 0 4
118031: PUSH
118032: LD_VAR 0 7
118036: ARRAY
118037: PUSH
118038: LD_VAR 0 31
118042: IN
118043: IFFALSE 118316
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
118045: LD_VAR 0 4
118049: PUSH
118050: LD_VAR 0 7
118054: ARRAY
118055: PPUSH
118056: LD_VAR 0 23
118060: PPUSH
118061: CALL_OW 308
118065: NOT
118066: PUSH
118067: LD_VAR 0 4
118071: PUSH
118072: LD_VAR 0 7
118076: ARRAY
118077: PPUSH
118078: CALL_OW 314
118082: NOT
118083: AND
118084: IFFALSE 118108
// ComMoveToArea ( group [ i ] , f_heal ) else
118086: LD_VAR 0 4
118090: PUSH
118091: LD_VAR 0 7
118095: ARRAY
118096: PPUSH
118097: LD_VAR 0 23
118101: PPUSH
118102: CALL_OW 113
118106: GO 118314
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
118108: LD_VAR 0 4
118112: PUSH
118113: LD_VAR 0 7
118117: ARRAY
118118: PPUSH
118119: CALL 88395 0 1
118123: PPUSH
118124: CALL_OW 256
118128: PUSH
118129: LD_INT 1000
118131: EQUAL
118132: IFFALSE 118151
// ComStop ( group [ i ] ) else
118134: LD_VAR 0 4
118138: PUSH
118139: LD_VAR 0 7
118143: ARRAY
118144: PPUSH
118145: CALL_OW 141
118149: GO 118314
// if not HasTask ( group [ i ] ) and to_heal then
118151: LD_VAR 0 4
118155: PUSH
118156: LD_VAR 0 7
118160: ARRAY
118161: PPUSH
118162: CALL_OW 314
118166: NOT
118167: PUSH
118168: LD_VAR 0 30
118172: AND
118173: IFFALSE 118314
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
118175: LD_ADDR_VAR 0 13
118179: PUSH
118180: LD_VAR 0 30
118184: PPUSH
118185: LD_INT 3
118187: PUSH
118188: LD_INT 54
118190: PUSH
118191: EMPTY
118192: LIST
118193: PUSH
118194: EMPTY
118195: LIST
118196: LIST
118197: PPUSH
118198: CALL_OW 72
118202: PPUSH
118203: LD_VAR 0 4
118207: PUSH
118208: LD_VAR 0 7
118212: ARRAY
118213: PPUSH
118214: CALL_OW 74
118218: ST_TO_ADDR
// if z then
118219: LD_VAR 0 13
118223: IFFALSE 118314
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
118225: LD_INT 91
118227: PUSH
118228: LD_VAR 0 13
118232: PUSH
118233: LD_INT 10
118235: PUSH
118236: EMPTY
118237: LIST
118238: LIST
118239: LIST
118240: PUSH
118241: LD_INT 81
118243: PUSH
118244: LD_VAR 0 13
118248: PPUSH
118249: CALL_OW 255
118253: PUSH
118254: EMPTY
118255: LIST
118256: LIST
118257: PUSH
118258: EMPTY
118259: LIST
118260: LIST
118261: PPUSH
118262: CALL_OW 69
118266: PUSH
118267: LD_INT 0
118269: EQUAL
118270: IFFALSE 118294
// ComHeal ( group [ i ] , z ) else
118272: LD_VAR 0 4
118276: PUSH
118277: LD_VAR 0 7
118281: ARRAY
118282: PPUSH
118283: LD_VAR 0 13
118287: PPUSH
118288: CALL_OW 128
118292: GO 118314
// ComMoveToArea ( group [ i ] , f_heal ) ;
118294: LD_VAR 0 4
118298: PUSH
118299: LD_VAR 0 7
118303: ARRAY
118304: PPUSH
118305: LD_VAR 0 23
118309: PPUSH
118310: CALL_OW 113
// end ; continue ;
118314: GO 117345
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
118316: LD_VAR 0 4
118320: PUSH
118321: LD_VAR 0 7
118325: ARRAY
118326: PPUSH
118327: CALL_OW 256
118331: PUSH
118332: LD_INT 700
118334: LESS
118335: PUSH
118336: LD_VAR 0 4
118340: PUSH
118341: LD_VAR 0 7
118345: ARRAY
118346: PUSH
118347: LD_VAR 0 30
118351: IN
118352: NOT
118353: AND
118354: IFFALSE 118378
// to_heal := to_heal union group [ i ] ;
118356: LD_ADDR_VAR 0 30
118360: PUSH
118361: LD_VAR 0 30
118365: PUSH
118366: LD_VAR 0 4
118370: PUSH
118371: LD_VAR 0 7
118375: ARRAY
118376: UNION
118377: ST_TO_ADDR
// if group [ i ] in to_heal then
118378: LD_VAR 0 4
118382: PUSH
118383: LD_VAR 0 7
118387: ARRAY
118388: PUSH
118389: LD_VAR 0 30
118393: IN
118394: IFFALSE 118503
// begin if GetLives ( group [ i ] ) = 1000 then
118396: LD_VAR 0 4
118400: PUSH
118401: LD_VAR 0 7
118405: ARRAY
118406: PPUSH
118407: CALL_OW 256
118411: PUSH
118412: LD_INT 1000
118414: EQUAL
118415: IFFALSE 118441
// to_heal := to_heal diff group [ i ] else
118417: LD_ADDR_VAR 0 30
118421: PUSH
118422: LD_VAR 0 30
118426: PUSH
118427: LD_VAR 0 4
118431: PUSH
118432: LD_VAR 0 7
118436: ARRAY
118437: DIFF
118438: ST_TO_ADDR
118439: GO 118503
// begin if not IsInArea ( group [ i ] , to_heal ) then
118441: LD_VAR 0 4
118445: PUSH
118446: LD_VAR 0 7
118450: ARRAY
118451: PPUSH
118452: LD_VAR 0 30
118456: PPUSH
118457: CALL_OW 308
118461: NOT
118462: IFFALSE 118486
// ComMoveToArea ( group [ i ] , f_heal ) else
118464: LD_VAR 0 4
118468: PUSH
118469: LD_VAR 0 7
118473: ARRAY
118474: PPUSH
118475: LD_VAR 0 23
118479: PPUSH
118480: CALL_OW 113
118484: GO 118501
// ComHold ( group [ i ] ) ;
118486: LD_VAR 0 4
118490: PUSH
118491: LD_VAR 0 7
118495: ARRAY
118496: PPUSH
118497: CALL_OW 140
// continue ;
118501: GO 117345
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
118503: LD_VAR 0 4
118507: PUSH
118508: LD_VAR 0 7
118512: ARRAY
118513: PPUSH
118514: LD_INT 10
118516: PPUSH
118517: CALL 86177 0 2
118521: NOT
118522: PUSH
118523: LD_VAR 0 16
118527: PUSH
118528: LD_VAR 0 7
118532: ARRAY
118533: PUSH
118534: EMPTY
118535: EQUAL
118536: NOT
118537: AND
118538: IFFALSE 118804
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
118540: LD_VAR 0 4
118544: PUSH
118545: LD_VAR 0 7
118549: ARRAY
118550: PPUSH
118551: CALL_OW 262
118555: PUSH
118556: LD_INT 1
118558: PUSH
118559: LD_INT 2
118561: PUSH
118562: EMPTY
118563: LIST
118564: LIST
118565: IN
118566: IFFALSE 118607
// if GetFuel ( group [ i ] ) < 10 then
118568: LD_VAR 0 4
118572: PUSH
118573: LD_VAR 0 7
118577: ARRAY
118578: PPUSH
118579: CALL_OW 261
118583: PUSH
118584: LD_INT 10
118586: LESS
118587: IFFALSE 118607
// SetFuel ( group [ i ] , 12 ) ;
118589: LD_VAR 0 4
118593: PUSH
118594: LD_VAR 0 7
118598: ARRAY
118599: PPUSH
118600: LD_INT 12
118602: PPUSH
118603: CALL_OW 240
// if units_path [ i ] then
118607: LD_VAR 0 16
118611: PUSH
118612: LD_VAR 0 7
118616: ARRAY
118617: IFFALSE 118802
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
118619: LD_VAR 0 4
118623: PUSH
118624: LD_VAR 0 7
118628: ARRAY
118629: PPUSH
118630: LD_VAR 0 16
118634: PUSH
118635: LD_VAR 0 7
118639: ARRAY
118640: PUSH
118641: LD_INT 1
118643: ARRAY
118644: PUSH
118645: LD_INT 1
118647: ARRAY
118648: PPUSH
118649: LD_VAR 0 16
118653: PUSH
118654: LD_VAR 0 7
118658: ARRAY
118659: PUSH
118660: LD_INT 1
118662: ARRAY
118663: PUSH
118664: LD_INT 2
118666: ARRAY
118667: PPUSH
118668: CALL_OW 297
118672: PUSH
118673: LD_INT 6
118675: GREATER
118676: IFFALSE 118751
// begin if not HasTask ( group [ i ] ) then
118678: LD_VAR 0 4
118682: PUSH
118683: LD_VAR 0 7
118687: ARRAY
118688: PPUSH
118689: CALL_OW 314
118693: NOT
118694: IFFALSE 118749
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
118696: LD_VAR 0 4
118700: PUSH
118701: LD_VAR 0 7
118705: ARRAY
118706: PPUSH
118707: LD_VAR 0 16
118711: PUSH
118712: LD_VAR 0 7
118716: ARRAY
118717: PUSH
118718: LD_INT 1
118720: ARRAY
118721: PUSH
118722: LD_INT 1
118724: ARRAY
118725: PPUSH
118726: LD_VAR 0 16
118730: PUSH
118731: LD_VAR 0 7
118735: ARRAY
118736: PUSH
118737: LD_INT 1
118739: ARRAY
118740: PUSH
118741: LD_INT 2
118743: ARRAY
118744: PPUSH
118745: CALL_OW 114
// end else
118749: GO 118802
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
118751: LD_ADDR_VAR 0 15
118755: PUSH
118756: LD_VAR 0 16
118760: PUSH
118761: LD_VAR 0 7
118765: ARRAY
118766: PPUSH
118767: LD_INT 1
118769: PPUSH
118770: CALL_OW 3
118774: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
118775: LD_ADDR_VAR 0 16
118779: PUSH
118780: LD_VAR 0 16
118784: PPUSH
118785: LD_VAR 0 7
118789: PPUSH
118790: LD_VAR 0 15
118794: PPUSH
118795: CALL_OW 1
118799: ST_TO_ADDR
// continue ;
118800: GO 117345
// end ; end ; end else
118802: GO 121466
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
118804: LD_ADDR_VAR 0 14
118808: PUSH
118809: LD_INT 81
118811: PUSH
118812: LD_VAR 0 4
118816: PUSH
118817: LD_VAR 0 7
118821: ARRAY
118822: PPUSH
118823: CALL_OW 255
118827: PUSH
118828: EMPTY
118829: LIST
118830: LIST
118831: PPUSH
118832: CALL_OW 69
118836: ST_TO_ADDR
// if not tmp then
118837: LD_VAR 0 14
118841: NOT
118842: IFFALSE 118846
// continue ;
118844: GO 117345
// if f_ignore_area then
118846: LD_VAR 0 17
118850: IFFALSE 118938
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
118852: LD_ADDR_VAR 0 15
118856: PUSH
118857: LD_VAR 0 14
118861: PPUSH
118862: LD_INT 3
118864: PUSH
118865: LD_INT 92
118867: PUSH
118868: LD_VAR 0 17
118872: PUSH
118873: LD_INT 1
118875: ARRAY
118876: PUSH
118877: LD_VAR 0 17
118881: PUSH
118882: LD_INT 2
118884: ARRAY
118885: PUSH
118886: LD_VAR 0 17
118890: PUSH
118891: LD_INT 3
118893: ARRAY
118894: PUSH
118895: EMPTY
118896: LIST
118897: LIST
118898: LIST
118899: LIST
118900: PUSH
118901: EMPTY
118902: LIST
118903: LIST
118904: PPUSH
118905: CALL_OW 72
118909: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
118910: LD_VAR 0 14
118914: PUSH
118915: LD_VAR 0 15
118919: DIFF
118920: IFFALSE 118938
// tmp := tmp diff tmp2 ;
118922: LD_ADDR_VAR 0 14
118926: PUSH
118927: LD_VAR 0 14
118931: PUSH
118932: LD_VAR 0 15
118936: DIFF
118937: ST_TO_ADDR
// end ; if not f_murder then
118938: LD_VAR 0 20
118942: NOT
118943: IFFALSE 119001
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
118945: LD_ADDR_VAR 0 15
118949: PUSH
118950: LD_VAR 0 14
118954: PPUSH
118955: LD_INT 3
118957: PUSH
118958: LD_INT 50
118960: PUSH
118961: EMPTY
118962: LIST
118963: PUSH
118964: EMPTY
118965: LIST
118966: LIST
118967: PPUSH
118968: CALL_OW 72
118972: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
118973: LD_VAR 0 14
118977: PUSH
118978: LD_VAR 0 15
118982: DIFF
118983: IFFALSE 119001
// tmp := tmp diff tmp2 ;
118985: LD_ADDR_VAR 0 14
118989: PUSH
118990: LD_VAR 0 14
118994: PUSH
118995: LD_VAR 0 15
118999: DIFF
119000: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
119001: LD_ADDR_VAR 0 14
119005: PUSH
119006: LD_VAR 0 4
119010: PUSH
119011: LD_VAR 0 7
119015: ARRAY
119016: PPUSH
119017: LD_VAR 0 14
119021: PPUSH
119022: LD_INT 1
119024: PPUSH
119025: LD_INT 1
119027: PPUSH
119028: CALL 58721 0 4
119032: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
119033: LD_VAR 0 4
119037: PUSH
119038: LD_VAR 0 7
119042: ARRAY
119043: PPUSH
119044: CALL_OW 257
119048: PUSH
119049: LD_INT 1
119051: EQUAL
119052: IFFALSE 119500
// begin if WantPlant ( group [ i ] ) then
119054: LD_VAR 0 4
119058: PUSH
119059: LD_VAR 0 7
119063: ARRAY
119064: PPUSH
119065: CALL 58222 0 1
119069: IFFALSE 119073
// continue ;
119071: GO 117345
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
119073: LD_VAR 0 18
119077: PUSH
119078: LD_VAR 0 4
119082: PUSH
119083: LD_VAR 0 7
119087: ARRAY
119088: PPUSH
119089: CALL_OW 310
119093: NOT
119094: AND
119095: PUSH
119096: LD_VAR 0 14
119100: PUSH
119101: LD_INT 1
119103: ARRAY
119104: PUSH
119105: LD_VAR 0 14
119109: PPUSH
119110: LD_INT 21
119112: PUSH
119113: LD_INT 2
119115: PUSH
119116: EMPTY
119117: LIST
119118: LIST
119119: PUSH
119120: LD_INT 58
119122: PUSH
119123: EMPTY
119124: LIST
119125: PUSH
119126: EMPTY
119127: LIST
119128: LIST
119129: PPUSH
119130: CALL_OW 72
119134: IN
119135: AND
119136: IFFALSE 119172
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
119138: LD_VAR 0 4
119142: PUSH
119143: LD_VAR 0 7
119147: ARRAY
119148: PPUSH
119149: LD_VAR 0 14
119153: PUSH
119154: LD_INT 1
119156: ARRAY
119157: PPUSH
119158: CALL_OW 120
// attacking := true ;
119162: LD_ADDR_VAR 0 29
119166: PUSH
119167: LD_INT 1
119169: ST_TO_ADDR
// continue ;
119170: GO 117345
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
119172: LD_VAR 0 26
119176: PUSH
119177: LD_VAR 0 4
119181: PUSH
119182: LD_VAR 0 7
119186: ARRAY
119187: PPUSH
119188: CALL_OW 257
119192: PUSH
119193: LD_INT 1
119195: EQUAL
119196: AND
119197: PUSH
119198: LD_VAR 0 4
119202: PUSH
119203: LD_VAR 0 7
119207: ARRAY
119208: PPUSH
119209: CALL_OW 256
119213: PUSH
119214: LD_INT 800
119216: LESS
119217: AND
119218: PUSH
119219: LD_VAR 0 4
119223: PUSH
119224: LD_VAR 0 7
119228: ARRAY
119229: PPUSH
119230: CALL_OW 318
119234: NOT
119235: AND
119236: IFFALSE 119253
// ComCrawl ( group [ i ] ) ;
119238: LD_VAR 0 4
119242: PUSH
119243: LD_VAR 0 7
119247: ARRAY
119248: PPUSH
119249: CALL_OW 137
// if f_mines then
119253: LD_VAR 0 21
119257: IFFALSE 119500
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
119259: LD_VAR 0 14
119263: PUSH
119264: LD_INT 1
119266: ARRAY
119267: PPUSH
119268: CALL_OW 247
119272: PUSH
119273: LD_INT 3
119275: EQUAL
119276: PUSH
119277: LD_VAR 0 14
119281: PUSH
119282: LD_INT 1
119284: ARRAY
119285: PUSH
119286: LD_VAR 0 27
119290: IN
119291: NOT
119292: AND
119293: IFFALSE 119500
// begin x := GetX ( tmp [ 1 ] ) ;
119295: LD_ADDR_VAR 0 10
119299: PUSH
119300: LD_VAR 0 14
119304: PUSH
119305: LD_INT 1
119307: ARRAY
119308: PPUSH
119309: CALL_OW 250
119313: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
119314: LD_ADDR_VAR 0 11
119318: PUSH
119319: LD_VAR 0 14
119323: PUSH
119324: LD_INT 1
119326: ARRAY
119327: PPUSH
119328: CALL_OW 251
119332: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
119333: LD_ADDR_VAR 0 12
119337: PUSH
119338: LD_VAR 0 4
119342: PUSH
119343: LD_VAR 0 7
119347: ARRAY
119348: PPUSH
119349: CALL 86262 0 1
119353: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
119354: LD_VAR 0 4
119358: PUSH
119359: LD_VAR 0 7
119363: ARRAY
119364: PPUSH
119365: LD_VAR 0 10
119369: PPUSH
119370: LD_VAR 0 11
119374: PPUSH
119375: LD_VAR 0 14
119379: PUSH
119380: LD_INT 1
119382: ARRAY
119383: PPUSH
119384: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
119388: LD_VAR 0 4
119392: PUSH
119393: LD_VAR 0 7
119397: ARRAY
119398: PPUSH
119399: LD_VAR 0 10
119403: PPUSH
119404: LD_VAR 0 12
119408: PPUSH
119409: LD_INT 7
119411: PPUSH
119412: CALL_OW 272
119416: PPUSH
119417: LD_VAR 0 11
119421: PPUSH
119422: LD_VAR 0 12
119426: PPUSH
119427: LD_INT 7
119429: PPUSH
119430: CALL_OW 273
119434: PPUSH
119435: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
119439: LD_VAR 0 4
119443: PUSH
119444: LD_VAR 0 7
119448: ARRAY
119449: PPUSH
119450: LD_INT 71
119452: PPUSH
119453: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
119457: LD_ADDR_VAR 0 27
119461: PUSH
119462: LD_VAR 0 27
119466: PPUSH
119467: LD_VAR 0 27
119471: PUSH
119472: LD_INT 1
119474: PLUS
119475: PPUSH
119476: LD_VAR 0 14
119480: PUSH
119481: LD_INT 1
119483: ARRAY
119484: PPUSH
119485: CALL_OW 1
119489: ST_TO_ADDR
// attacking := true ;
119490: LD_ADDR_VAR 0 29
119494: PUSH
119495: LD_INT 1
119497: ST_TO_ADDR
// continue ;
119498: GO 117345
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
119500: LD_VAR 0 4
119504: PUSH
119505: LD_VAR 0 7
119509: ARRAY
119510: PPUSH
119511: CALL_OW 257
119515: PUSH
119516: LD_INT 17
119518: EQUAL
119519: PUSH
119520: LD_VAR 0 4
119524: PUSH
119525: LD_VAR 0 7
119529: ARRAY
119530: PPUSH
119531: CALL_OW 110
119535: PUSH
119536: LD_INT 71
119538: EQUAL
119539: NOT
119540: AND
119541: IFFALSE 119687
// begin attacking := false ;
119543: LD_ADDR_VAR 0 29
119547: PUSH
119548: LD_INT 0
119550: ST_TO_ADDR
// k := 5 ;
119551: LD_ADDR_VAR 0 9
119555: PUSH
119556: LD_INT 5
119558: ST_TO_ADDR
// if tmp < k then
119559: LD_VAR 0 14
119563: PUSH
119564: LD_VAR 0 9
119568: LESS
119569: IFFALSE 119581
// k := tmp ;
119571: LD_ADDR_VAR 0 9
119575: PUSH
119576: LD_VAR 0 14
119580: ST_TO_ADDR
// for j = 1 to k do
119581: LD_ADDR_VAR 0 8
119585: PUSH
119586: DOUBLE
119587: LD_INT 1
119589: DEC
119590: ST_TO_ADDR
119591: LD_VAR 0 9
119595: PUSH
119596: FOR_TO
119597: IFFALSE 119685
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
119599: LD_VAR 0 14
119603: PUSH
119604: LD_VAR 0 8
119608: ARRAY
119609: PUSH
119610: LD_VAR 0 14
119614: PPUSH
119615: LD_INT 58
119617: PUSH
119618: EMPTY
119619: LIST
119620: PPUSH
119621: CALL_OW 72
119625: IN
119626: NOT
119627: IFFALSE 119683
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119629: LD_VAR 0 4
119633: PUSH
119634: LD_VAR 0 7
119638: ARRAY
119639: PPUSH
119640: LD_VAR 0 14
119644: PUSH
119645: LD_VAR 0 8
119649: ARRAY
119650: PPUSH
119651: CALL_OW 115
// attacking := true ;
119655: LD_ADDR_VAR 0 29
119659: PUSH
119660: LD_INT 1
119662: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
119663: LD_VAR 0 4
119667: PUSH
119668: LD_VAR 0 7
119672: ARRAY
119673: PPUSH
119674: LD_INT 71
119676: PPUSH
119677: CALL_OW 109
// continue ;
119681: GO 119596
// end ; end ;
119683: GO 119596
119685: POP
119686: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
119687: LD_VAR 0 4
119691: PUSH
119692: LD_VAR 0 7
119696: ARRAY
119697: PPUSH
119698: CALL_OW 257
119702: PUSH
119703: LD_INT 8
119705: EQUAL
119706: PUSH
119707: LD_VAR 0 4
119711: PUSH
119712: LD_VAR 0 7
119716: ARRAY
119717: PPUSH
119718: CALL_OW 264
119722: PUSH
119723: LD_INT 28
119725: PUSH
119726: LD_INT 45
119728: PUSH
119729: LD_INT 7
119731: PUSH
119732: LD_INT 47
119734: PUSH
119735: EMPTY
119736: LIST
119737: LIST
119738: LIST
119739: LIST
119740: IN
119741: OR
119742: IFFALSE 119998
// begin attacking := false ;
119744: LD_ADDR_VAR 0 29
119748: PUSH
119749: LD_INT 0
119751: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
119752: LD_VAR 0 14
119756: PUSH
119757: LD_INT 1
119759: ARRAY
119760: PPUSH
119761: CALL_OW 266
119765: PUSH
119766: LD_INT 32
119768: PUSH
119769: LD_INT 31
119771: PUSH
119772: LD_INT 33
119774: PUSH
119775: LD_INT 4
119777: PUSH
119778: LD_INT 5
119780: PUSH
119781: EMPTY
119782: LIST
119783: LIST
119784: LIST
119785: LIST
119786: LIST
119787: IN
119788: IFFALSE 119974
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
119790: LD_ADDR_VAR 0 9
119794: PUSH
119795: LD_VAR 0 14
119799: PUSH
119800: LD_INT 1
119802: ARRAY
119803: PPUSH
119804: CALL_OW 266
119808: PPUSH
119809: LD_VAR 0 14
119813: PUSH
119814: LD_INT 1
119816: ARRAY
119817: PPUSH
119818: CALL_OW 250
119822: PPUSH
119823: LD_VAR 0 14
119827: PUSH
119828: LD_INT 1
119830: ARRAY
119831: PPUSH
119832: CALL_OW 251
119836: PPUSH
119837: LD_VAR 0 14
119841: PUSH
119842: LD_INT 1
119844: ARRAY
119845: PPUSH
119846: CALL_OW 254
119850: PPUSH
119851: LD_VAR 0 14
119855: PUSH
119856: LD_INT 1
119858: ARRAY
119859: PPUSH
119860: CALL_OW 248
119864: PPUSH
119865: LD_INT 0
119867: PPUSH
119868: CALL 67632 0 6
119872: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
119873: LD_ADDR_VAR 0 8
119877: PUSH
119878: LD_VAR 0 4
119882: PUSH
119883: LD_VAR 0 7
119887: ARRAY
119888: PPUSH
119889: LD_VAR 0 9
119893: PPUSH
119894: CALL 86375 0 2
119898: ST_TO_ADDR
// if j then
119899: LD_VAR 0 8
119903: IFFALSE 119972
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
119905: LD_VAR 0 8
119909: PUSH
119910: LD_INT 1
119912: ARRAY
119913: PPUSH
119914: LD_VAR 0 8
119918: PUSH
119919: LD_INT 2
119921: ARRAY
119922: PPUSH
119923: CALL_OW 488
119927: IFFALSE 119972
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
119929: LD_VAR 0 4
119933: PUSH
119934: LD_VAR 0 7
119938: ARRAY
119939: PPUSH
119940: LD_VAR 0 8
119944: PUSH
119945: LD_INT 1
119947: ARRAY
119948: PPUSH
119949: LD_VAR 0 8
119953: PUSH
119954: LD_INT 2
119956: ARRAY
119957: PPUSH
119958: CALL_OW 116
// attacking := true ;
119962: LD_ADDR_VAR 0 29
119966: PUSH
119967: LD_INT 1
119969: ST_TO_ADDR
// continue ;
119970: GO 117345
// end ; end else
119972: GO 119998
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119974: LD_VAR 0 4
119978: PUSH
119979: LD_VAR 0 7
119983: ARRAY
119984: PPUSH
119985: LD_VAR 0 14
119989: PUSH
119990: LD_INT 1
119992: ARRAY
119993: PPUSH
119994: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
119998: LD_VAR 0 4
120002: PUSH
120003: LD_VAR 0 7
120007: ARRAY
120008: PPUSH
120009: CALL_OW 265
120013: PUSH
120014: LD_INT 11
120016: EQUAL
120017: IFFALSE 120295
// begin k := 10 ;
120019: LD_ADDR_VAR 0 9
120023: PUSH
120024: LD_INT 10
120026: ST_TO_ADDR
// x := 0 ;
120027: LD_ADDR_VAR 0 10
120031: PUSH
120032: LD_INT 0
120034: ST_TO_ADDR
// if tmp < k then
120035: LD_VAR 0 14
120039: PUSH
120040: LD_VAR 0 9
120044: LESS
120045: IFFALSE 120057
// k := tmp ;
120047: LD_ADDR_VAR 0 9
120051: PUSH
120052: LD_VAR 0 14
120056: ST_TO_ADDR
// for j = k downto 1 do
120057: LD_ADDR_VAR 0 8
120061: PUSH
120062: DOUBLE
120063: LD_VAR 0 9
120067: INC
120068: ST_TO_ADDR
120069: LD_INT 1
120071: PUSH
120072: FOR_DOWNTO
120073: IFFALSE 120148
// begin if GetType ( tmp [ j ] ) = unit_human then
120075: LD_VAR 0 14
120079: PUSH
120080: LD_VAR 0 8
120084: ARRAY
120085: PPUSH
120086: CALL_OW 247
120090: PUSH
120091: LD_INT 1
120093: EQUAL
120094: IFFALSE 120146
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
120096: LD_VAR 0 4
120100: PUSH
120101: LD_VAR 0 7
120105: ARRAY
120106: PPUSH
120107: LD_VAR 0 14
120111: PUSH
120112: LD_VAR 0 8
120116: ARRAY
120117: PPUSH
120118: CALL 86629 0 2
// x := tmp [ j ] ;
120122: LD_ADDR_VAR 0 10
120126: PUSH
120127: LD_VAR 0 14
120131: PUSH
120132: LD_VAR 0 8
120136: ARRAY
120137: ST_TO_ADDR
// attacking := true ;
120138: LD_ADDR_VAR 0 29
120142: PUSH
120143: LD_INT 1
120145: ST_TO_ADDR
// end ; end ;
120146: GO 120072
120148: POP
120149: POP
// if not x then
120150: LD_VAR 0 10
120154: NOT
120155: IFFALSE 120295
// begin attacking := true ;
120157: LD_ADDR_VAR 0 29
120161: PUSH
120162: LD_INT 1
120164: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
120165: LD_VAR 0 4
120169: PUSH
120170: LD_VAR 0 7
120174: ARRAY
120175: PPUSH
120176: CALL_OW 250
120180: PPUSH
120181: LD_VAR 0 4
120185: PUSH
120186: LD_VAR 0 7
120190: ARRAY
120191: PPUSH
120192: CALL_OW 251
120196: PPUSH
120197: CALL_OW 546
120201: PUSH
120202: LD_INT 2
120204: ARRAY
120205: PUSH
120206: LD_VAR 0 14
120210: PUSH
120211: LD_INT 1
120213: ARRAY
120214: PPUSH
120215: CALL_OW 250
120219: PPUSH
120220: LD_VAR 0 14
120224: PUSH
120225: LD_INT 1
120227: ARRAY
120228: PPUSH
120229: CALL_OW 251
120233: PPUSH
120234: CALL_OW 546
120238: PUSH
120239: LD_INT 2
120241: ARRAY
120242: EQUAL
120243: IFFALSE 120271
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
120245: LD_VAR 0 4
120249: PUSH
120250: LD_VAR 0 7
120254: ARRAY
120255: PPUSH
120256: LD_VAR 0 14
120260: PUSH
120261: LD_INT 1
120263: ARRAY
120264: PPUSH
120265: CALL 86629 0 2
120269: GO 120295
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120271: LD_VAR 0 4
120275: PUSH
120276: LD_VAR 0 7
120280: ARRAY
120281: PPUSH
120282: LD_VAR 0 14
120286: PUSH
120287: LD_INT 1
120289: ARRAY
120290: PPUSH
120291: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
120295: LD_VAR 0 4
120299: PUSH
120300: LD_VAR 0 7
120304: ARRAY
120305: PPUSH
120306: CALL_OW 264
120310: PUSH
120311: LD_INT 29
120313: EQUAL
120314: IFFALSE 120680
// begin if WantsToAttack ( group [ i ] ) in bombed then
120316: LD_VAR 0 4
120320: PUSH
120321: LD_VAR 0 7
120325: ARRAY
120326: PPUSH
120327: CALL_OW 319
120331: PUSH
120332: LD_VAR 0 28
120336: IN
120337: IFFALSE 120341
// continue ;
120339: GO 117345
// k := 8 ;
120341: LD_ADDR_VAR 0 9
120345: PUSH
120346: LD_INT 8
120348: ST_TO_ADDR
// x := 0 ;
120349: LD_ADDR_VAR 0 10
120353: PUSH
120354: LD_INT 0
120356: ST_TO_ADDR
// if tmp < k then
120357: LD_VAR 0 14
120361: PUSH
120362: LD_VAR 0 9
120366: LESS
120367: IFFALSE 120379
// k := tmp ;
120369: LD_ADDR_VAR 0 9
120373: PUSH
120374: LD_VAR 0 14
120378: ST_TO_ADDR
// for j = 1 to k do
120379: LD_ADDR_VAR 0 8
120383: PUSH
120384: DOUBLE
120385: LD_INT 1
120387: DEC
120388: ST_TO_ADDR
120389: LD_VAR 0 9
120393: PUSH
120394: FOR_TO
120395: IFFALSE 120527
// begin if GetType ( tmp [ j ] ) = unit_building then
120397: LD_VAR 0 14
120401: PUSH
120402: LD_VAR 0 8
120406: ARRAY
120407: PPUSH
120408: CALL_OW 247
120412: PUSH
120413: LD_INT 3
120415: EQUAL
120416: IFFALSE 120525
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
120418: LD_VAR 0 14
120422: PUSH
120423: LD_VAR 0 8
120427: ARRAY
120428: PUSH
120429: LD_VAR 0 28
120433: IN
120434: NOT
120435: PUSH
120436: LD_VAR 0 14
120440: PUSH
120441: LD_VAR 0 8
120445: ARRAY
120446: PPUSH
120447: CALL_OW 313
120451: AND
120452: IFFALSE 120525
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120454: LD_VAR 0 4
120458: PUSH
120459: LD_VAR 0 7
120463: ARRAY
120464: PPUSH
120465: LD_VAR 0 14
120469: PUSH
120470: LD_VAR 0 8
120474: ARRAY
120475: PPUSH
120476: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
120480: LD_ADDR_VAR 0 28
120484: PUSH
120485: LD_VAR 0 28
120489: PPUSH
120490: LD_VAR 0 28
120494: PUSH
120495: LD_INT 1
120497: PLUS
120498: PPUSH
120499: LD_VAR 0 14
120503: PUSH
120504: LD_VAR 0 8
120508: ARRAY
120509: PPUSH
120510: CALL_OW 1
120514: ST_TO_ADDR
// attacking := true ;
120515: LD_ADDR_VAR 0 29
120519: PUSH
120520: LD_INT 1
120522: ST_TO_ADDR
// break ;
120523: GO 120527
// end ; end ;
120525: GO 120394
120527: POP
120528: POP
// if not attacking and f_attack_depot then
120529: LD_VAR 0 29
120533: NOT
120534: PUSH
120535: LD_VAR 0 25
120539: AND
120540: IFFALSE 120635
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120542: LD_ADDR_VAR 0 13
120546: PUSH
120547: LD_VAR 0 14
120551: PPUSH
120552: LD_INT 2
120554: PUSH
120555: LD_INT 30
120557: PUSH
120558: LD_INT 0
120560: PUSH
120561: EMPTY
120562: LIST
120563: LIST
120564: PUSH
120565: LD_INT 30
120567: PUSH
120568: LD_INT 1
120570: PUSH
120571: EMPTY
120572: LIST
120573: LIST
120574: PUSH
120575: EMPTY
120576: LIST
120577: LIST
120578: LIST
120579: PPUSH
120580: CALL_OW 72
120584: ST_TO_ADDR
// if z then
120585: LD_VAR 0 13
120589: IFFALSE 120635
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
120591: LD_VAR 0 4
120595: PUSH
120596: LD_VAR 0 7
120600: ARRAY
120601: PPUSH
120602: LD_VAR 0 13
120606: PPUSH
120607: LD_VAR 0 4
120611: PUSH
120612: LD_VAR 0 7
120616: ARRAY
120617: PPUSH
120618: CALL_OW 74
120622: PPUSH
120623: CALL_OW 115
// attacking := true ;
120627: LD_ADDR_VAR 0 29
120631: PUSH
120632: LD_INT 1
120634: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
120635: LD_VAR 0 4
120639: PUSH
120640: LD_VAR 0 7
120644: ARRAY
120645: PPUSH
120646: CALL_OW 256
120650: PUSH
120651: LD_INT 500
120653: LESS
120654: IFFALSE 120680
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120656: LD_VAR 0 4
120660: PUSH
120661: LD_VAR 0 7
120665: ARRAY
120666: PPUSH
120667: LD_VAR 0 14
120671: PUSH
120672: LD_INT 1
120674: ARRAY
120675: PPUSH
120676: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
120680: LD_VAR 0 4
120684: PUSH
120685: LD_VAR 0 7
120689: ARRAY
120690: PPUSH
120691: CALL_OW 264
120695: PUSH
120696: LD_INT 49
120698: EQUAL
120699: IFFALSE 120820
// begin if not HasTask ( group [ i ] ) then
120701: LD_VAR 0 4
120705: PUSH
120706: LD_VAR 0 7
120710: ARRAY
120711: PPUSH
120712: CALL_OW 314
120716: NOT
120717: IFFALSE 120820
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
120719: LD_ADDR_VAR 0 9
120723: PUSH
120724: LD_INT 81
120726: PUSH
120727: LD_VAR 0 4
120731: PUSH
120732: LD_VAR 0 7
120736: ARRAY
120737: PPUSH
120738: CALL_OW 255
120742: PUSH
120743: EMPTY
120744: LIST
120745: LIST
120746: PPUSH
120747: CALL_OW 69
120751: PPUSH
120752: LD_VAR 0 4
120756: PUSH
120757: LD_VAR 0 7
120761: ARRAY
120762: PPUSH
120763: CALL_OW 74
120767: ST_TO_ADDR
// if k then
120768: LD_VAR 0 9
120772: IFFALSE 120820
// if GetDistUnits ( group [ i ] , k ) > 10 then
120774: LD_VAR 0 4
120778: PUSH
120779: LD_VAR 0 7
120783: ARRAY
120784: PPUSH
120785: LD_VAR 0 9
120789: PPUSH
120790: CALL_OW 296
120794: PUSH
120795: LD_INT 10
120797: GREATER
120798: IFFALSE 120820
// ComMoveUnit ( group [ i ] , k ) ;
120800: LD_VAR 0 4
120804: PUSH
120805: LD_VAR 0 7
120809: ARRAY
120810: PPUSH
120811: LD_VAR 0 9
120815: PPUSH
120816: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
120820: LD_VAR 0 4
120824: PUSH
120825: LD_VAR 0 7
120829: ARRAY
120830: PPUSH
120831: CALL_OW 256
120835: PUSH
120836: LD_INT 250
120838: LESS
120839: PUSH
120840: LD_VAR 0 4
120844: PUSH
120845: LD_VAR 0 7
120849: ARRAY
120850: PUSH
120851: LD_INT 21
120853: PUSH
120854: LD_INT 2
120856: PUSH
120857: EMPTY
120858: LIST
120859: LIST
120860: PUSH
120861: LD_INT 23
120863: PUSH
120864: LD_INT 2
120866: PUSH
120867: EMPTY
120868: LIST
120869: LIST
120870: PUSH
120871: EMPTY
120872: LIST
120873: LIST
120874: PPUSH
120875: CALL_OW 69
120879: IN
120880: AND
120881: IFFALSE 121006
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
120883: LD_ADDR_VAR 0 9
120887: PUSH
120888: LD_OWVAR 3
120892: PUSH
120893: LD_VAR 0 4
120897: PUSH
120898: LD_VAR 0 7
120902: ARRAY
120903: DIFF
120904: PPUSH
120905: LD_VAR 0 4
120909: PUSH
120910: LD_VAR 0 7
120914: ARRAY
120915: PPUSH
120916: CALL_OW 74
120920: ST_TO_ADDR
// if not k then
120921: LD_VAR 0 9
120925: NOT
120926: IFFALSE 120930
// continue ;
120928: GO 117345
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
120930: LD_VAR 0 9
120934: PUSH
120935: LD_INT 81
120937: PUSH
120938: LD_VAR 0 4
120942: PUSH
120943: LD_VAR 0 7
120947: ARRAY
120948: PPUSH
120949: CALL_OW 255
120953: PUSH
120954: EMPTY
120955: LIST
120956: LIST
120957: PPUSH
120958: CALL_OW 69
120962: IN
120963: PUSH
120964: LD_VAR 0 9
120968: PPUSH
120969: LD_VAR 0 4
120973: PUSH
120974: LD_VAR 0 7
120978: ARRAY
120979: PPUSH
120980: CALL_OW 296
120984: PUSH
120985: LD_INT 5
120987: LESS
120988: AND
120989: IFFALSE 121006
// ComAutodestruct ( group [ i ] ) ;
120991: LD_VAR 0 4
120995: PUSH
120996: LD_VAR 0 7
121000: ARRAY
121001: PPUSH
121002: CALL 86527 0 1
// end ; if f_attack_depot then
121006: LD_VAR 0 25
121010: IFFALSE 121122
// begin k := 6 ;
121012: LD_ADDR_VAR 0 9
121016: PUSH
121017: LD_INT 6
121019: ST_TO_ADDR
// if tmp < k then
121020: LD_VAR 0 14
121024: PUSH
121025: LD_VAR 0 9
121029: LESS
121030: IFFALSE 121042
// k := tmp ;
121032: LD_ADDR_VAR 0 9
121036: PUSH
121037: LD_VAR 0 14
121041: ST_TO_ADDR
// for j = 1 to k do
121042: LD_ADDR_VAR 0 8
121046: PUSH
121047: DOUBLE
121048: LD_INT 1
121050: DEC
121051: ST_TO_ADDR
121052: LD_VAR 0 9
121056: PUSH
121057: FOR_TO
121058: IFFALSE 121120
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
121060: LD_VAR 0 8
121064: PPUSH
121065: CALL_OW 266
121069: PUSH
121070: LD_INT 0
121072: PUSH
121073: LD_INT 1
121075: PUSH
121076: EMPTY
121077: LIST
121078: LIST
121079: IN
121080: IFFALSE 121118
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
121082: LD_VAR 0 4
121086: PUSH
121087: LD_VAR 0 7
121091: ARRAY
121092: PPUSH
121093: LD_VAR 0 14
121097: PUSH
121098: LD_VAR 0 8
121102: ARRAY
121103: PPUSH
121104: CALL_OW 115
// attacking := true ;
121108: LD_ADDR_VAR 0 29
121112: PUSH
121113: LD_INT 1
121115: ST_TO_ADDR
// break ;
121116: GO 121120
// end ;
121118: GO 121057
121120: POP
121121: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
121122: LD_VAR 0 4
121126: PUSH
121127: LD_VAR 0 7
121131: ARRAY
121132: PPUSH
121133: CALL_OW 302
121137: PUSH
121138: LD_VAR 0 29
121142: NOT
121143: AND
121144: IFFALSE 121466
// begin if GetTag ( group [ i ] ) = 71 then
121146: LD_VAR 0 4
121150: PUSH
121151: LD_VAR 0 7
121155: ARRAY
121156: PPUSH
121157: CALL_OW 110
121161: PUSH
121162: LD_INT 71
121164: EQUAL
121165: IFFALSE 121206
// begin if HasTask ( group [ i ] ) then
121167: LD_VAR 0 4
121171: PUSH
121172: LD_VAR 0 7
121176: ARRAY
121177: PPUSH
121178: CALL_OW 314
121182: IFFALSE 121188
// continue else
121184: GO 117345
121186: GO 121206
// SetTag ( group [ i ] , 0 ) ;
121188: LD_VAR 0 4
121192: PUSH
121193: LD_VAR 0 7
121197: ARRAY
121198: PPUSH
121199: LD_INT 0
121201: PPUSH
121202: CALL_OW 109
// end ; k := 8 ;
121206: LD_ADDR_VAR 0 9
121210: PUSH
121211: LD_INT 8
121213: ST_TO_ADDR
// x := 0 ;
121214: LD_ADDR_VAR 0 10
121218: PUSH
121219: LD_INT 0
121221: ST_TO_ADDR
// if tmp < k then
121222: LD_VAR 0 14
121226: PUSH
121227: LD_VAR 0 9
121231: LESS
121232: IFFALSE 121244
// k := tmp ;
121234: LD_ADDR_VAR 0 9
121238: PUSH
121239: LD_VAR 0 14
121243: ST_TO_ADDR
// for j = 1 to k do
121244: LD_ADDR_VAR 0 8
121248: PUSH
121249: DOUBLE
121250: LD_INT 1
121252: DEC
121253: ST_TO_ADDR
121254: LD_VAR 0 9
121258: PUSH
121259: FOR_TO
121260: IFFALSE 121358
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
121262: LD_VAR 0 14
121266: PUSH
121267: LD_VAR 0 8
121271: ARRAY
121272: PPUSH
121273: CALL_OW 247
121277: PUSH
121278: LD_INT 1
121280: EQUAL
121281: PUSH
121282: LD_VAR 0 14
121286: PUSH
121287: LD_VAR 0 8
121291: ARRAY
121292: PPUSH
121293: CALL_OW 256
121297: PUSH
121298: LD_INT 250
121300: LESS
121301: PUSH
121302: LD_VAR 0 20
121306: AND
121307: PUSH
121308: LD_VAR 0 20
121312: NOT
121313: PUSH
121314: LD_VAR 0 14
121318: PUSH
121319: LD_VAR 0 8
121323: ARRAY
121324: PPUSH
121325: CALL_OW 256
121329: PUSH
121330: LD_INT 250
121332: GREATEREQUAL
121333: AND
121334: OR
121335: AND
121336: IFFALSE 121356
// begin x := tmp [ j ] ;
121338: LD_ADDR_VAR 0 10
121342: PUSH
121343: LD_VAR 0 14
121347: PUSH
121348: LD_VAR 0 8
121352: ARRAY
121353: ST_TO_ADDR
// break ;
121354: GO 121358
// end ;
121356: GO 121259
121358: POP
121359: POP
// if x then
121360: LD_VAR 0 10
121364: IFFALSE 121388
// ComAttackUnit ( group [ i ] , x ) else
121366: LD_VAR 0 4
121370: PUSH
121371: LD_VAR 0 7
121375: ARRAY
121376: PPUSH
121377: LD_VAR 0 10
121381: PPUSH
121382: CALL_OW 115
121386: GO 121412
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121388: LD_VAR 0 4
121392: PUSH
121393: LD_VAR 0 7
121397: ARRAY
121398: PPUSH
121399: LD_VAR 0 14
121403: PUSH
121404: LD_INT 1
121406: ARRAY
121407: PPUSH
121408: CALL_OW 115
// if not HasTask ( group [ i ] ) then
121412: LD_VAR 0 4
121416: PUSH
121417: LD_VAR 0 7
121421: ARRAY
121422: PPUSH
121423: CALL_OW 314
121427: NOT
121428: IFFALSE 121466
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
121430: LD_VAR 0 4
121434: PUSH
121435: LD_VAR 0 7
121439: ARRAY
121440: PPUSH
121441: LD_VAR 0 14
121445: PPUSH
121446: LD_VAR 0 4
121450: PUSH
121451: LD_VAR 0 7
121455: ARRAY
121456: PPUSH
121457: CALL_OW 74
121461: PPUSH
121462: CALL_OW 115
// end ; end ; end ;
121466: GO 117345
121468: POP
121469: POP
// wait ( 0 0$2 ) ;
121470: LD_INT 70
121472: PPUSH
121473: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
121477: LD_VAR 0 4
121481: NOT
121482: PUSH
121483: LD_VAR 0 4
121487: PUSH
121488: EMPTY
121489: EQUAL
121490: OR
121491: PUSH
121492: LD_INT 81
121494: PUSH
121495: LD_VAR 0 35
121499: PUSH
121500: EMPTY
121501: LIST
121502: LIST
121503: PPUSH
121504: CALL_OW 69
121508: NOT
121509: OR
121510: IFFALSE 117330
// end ;
121512: LD_VAR 0 2
121516: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
121517: LD_INT 0
121519: PPUSH
121520: PPUSH
121521: PPUSH
121522: PPUSH
121523: PPUSH
121524: PPUSH
// if not base or not mc_bases [ base ] or not solds then
121525: LD_VAR 0 1
121529: NOT
121530: PUSH
121531: LD_EXP 78
121535: PUSH
121536: LD_VAR 0 1
121540: ARRAY
121541: NOT
121542: OR
121543: PUSH
121544: LD_VAR 0 2
121548: NOT
121549: OR
121550: IFFALSE 121554
// exit ;
121552: GO 122108
// side := mc_sides [ base ] ;
121554: LD_ADDR_VAR 0 6
121558: PUSH
121559: LD_EXP 104
121563: PUSH
121564: LD_VAR 0 1
121568: ARRAY
121569: ST_TO_ADDR
// if not side then
121570: LD_VAR 0 6
121574: NOT
121575: IFFALSE 121579
// exit ;
121577: GO 122108
// for i in solds do
121579: LD_ADDR_VAR 0 7
121583: PUSH
121584: LD_VAR 0 2
121588: PUSH
121589: FOR_IN
121590: IFFALSE 121651
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
121592: LD_VAR 0 7
121596: PPUSH
121597: CALL_OW 310
121601: PPUSH
121602: CALL_OW 266
121606: PUSH
121607: LD_INT 32
121609: PUSH
121610: LD_INT 31
121612: PUSH
121613: EMPTY
121614: LIST
121615: LIST
121616: IN
121617: IFFALSE 121637
// solds := solds diff i else
121619: LD_ADDR_VAR 0 2
121623: PUSH
121624: LD_VAR 0 2
121628: PUSH
121629: LD_VAR 0 7
121633: DIFF
121634: ST_TO_ADDR
121635: GO 121649
// SetTag ( i , 18 ) ;
121637: LD_VAR 0 7
121641: PPUSH
121642: LD_INT 18
121644: PPUSH
121645: CALL_OW 109
121649: GO 121589
121651: POP
121652: POP
// if not solds then
121653: LD_VAR 0 2
121657: NOT
121658: IFFALSE 121662
// exit ;
121660: GO 122108
// repeat wait ( 0 0$2 ) ;
121662: LD_INT 70
121664: PPUSH
121665: CALL_OW 67
// enemy := mc_scan [ base ] ;
121669: LD_ADDR_VAR 0 4
121673: PUSH
121674: LD_EXP 101
121678: PUSH
121679: LD_VAR 0 1
121683: ARRAY
121684: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121685: LD_EXP 78
121689: PUSH
121690: LD_VAR 0 1
121694: ARRAY
121695: NOT
121696: PUSH
121697: LD_EXP 78
121701: PUSH
121702: LD_VAR 0 1
121706: ARRAY
121707: PUSH
121708: EMPTY
121709: EQUAL
121710: OR
121711: IFFALSE 121748
// begin for i in solds do
121713: LD_ADDR_VAR 0 7
121717: PUSH
121718: LD_VAR 0 2
121722: PUSH
121723: FOR_IN
121724: IFFALSE 121737
// ComStop ( i ) ;
121726: LD_VAR 0 7
121730: PPUSH
121731: CALL_OW 141
121735: GO 121723
121737: POP
121738: POP
// solds := [ ] ;
121739: LD_ADDR_VAR 0 2
121743: PUSH
121744: EMPTY
121745: ST_TO_ADDR
// exit ;
121746: GO 122108
// end ; for i in solds do
121748: LD_ADDR_VAR 0 7
121752: PUSH
121753: LD_VAR 0 2
121757: PUSH
121758: FOR_IN
121759: IFFALSE 122080
// begin if IsInUnit ( i ) then
121761: LD_VAR 0 7
121765: PPUSH
121766: CALL_OW 310
121770: IFFALSE 121781
// ComExitBuilding ( i ) ;
121772: LD_VAR 0 7
121776: PPUSH
121777: CALL_OW 122
// if GetLives ( i ) > 500 then
121781: LD_VAR 0 7
121785: PPUSH
121786: CALL_OW 256
121790: PUSH
121791: LD_INT 500
121793: GREATER
121794: IFFALSE 121847
// begin e := NearestUnitToUnit ( enemy , i ) ;
121796: LD_ADDR_VAR 0 5
121800: PUSH
121801: LD_VAR 0 4
121805: PPUSH
121806: LD_VAR 0 7
121810: PPUSH
121811: CALL_OW 74
121815: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
121816: LD_VAR 0 7
121820: PPUSH
121821: LD_VAR 0 5
121825: PPUSH
121826: CALL_OW 250
121830: PPUSH
121831: LD_VAR 0 5
121835: PPUSH
121836: CALL_OW 251
121840: PPUSH
121841: CALL_OW 114
// end else
121845: GO 122078
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
121847: LD_VAR 0 7
121851: PPUSH
121852: LD_EXP 78
121856: PUSH
121857: LD_VAR 0 1
121861: ARRAY
121862: PPUSH
121863: LD_INT 2
121865: PUSH
121866: LD_INT 30
121868: PUSH
121869: LD_INT 0
121871: PUSH
121872: EMPTY
121873: LIST
121874: LIST
121875: PUSH
121876: LD_INT 30
121878: PUSH
121879: LD_INT 1
121881: PUSH
121882: EMPTY
121883: LIST
121884: LIST
121885: PUSH
121886: LD_INT 30
121888: PUSH
121889: LD_INT 6
121891: PUSH
121892: EMPTY
121893: LIST
121894: LIST
121895: PUSH
121896: EMPTY
121897: LIST
121898: LIST
121899: LIST
121900: LIST
121901: PPUSH
121902: CALL_OW 72
121906: PPUSH
121907: LD_VAR 0 7
121911: PPUSH
121912: CALL_OW 74
121916: PPUSH
121917: CALL_OW 296
121921: PUSH
121922: LD_INT 10
121924: GREATER
121925: IFFALSE 122078
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
121927: LD_ADDR_VAR 0 8
121931: PUSH
121932: LD_EXP 78
121936: PUSH
121937: LD_VAR 0 1
121941: ARRAY
121942: PPUSH
121943: LD_INT 2
121945: PUSH
121946: LD_INT 30
121948: PUSH
121949: LD_INT 0
121951: PUSH
121952: EMPTY
121953: LIST
121954: LIST
121955: PUSH
121956: LD_INT 30
121958: PUSH
121959: LD_INT 1
121961: PUSH
121962: EMPTY
121963: LIST
121964: LIST
121965: PUSH
121966: LD_INT 30
121968: PUSH
121969: LD_INT 6
121971: PUSH
121972: EMPTY
121973: LIST
121974: LIST
121975: PUSH
121976: EMPTY
121977: LIST
121978: LIST
121979: LIST
121980: LIST
121981: PPUSH
121982: CALL_OW 72
121986: PPUSH
121987: LD_VAR 0 7
121991: PPUSH
121992: CALL_OW 74
121996: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
121997: LD_VAR 0 7
122001: PPUSH
122002: LD_VAR 0 8
122006: PPUSH
122007: CALL_OW 250
122011: PPUSH
122012: LD_INT 3
122014: PPUSH
122015: LD_INT 5
122017: PPUSH
122018: CALL_OW 272
122022: PPUSH
122023: LD_VAR 0 8
122027: PPUSH
122028: CALL_OW 251
122032: PPUSH
122033: LD_INT 3
122035: PPUSH
122036: LD_INT 5
122038: PPUSH
122039: CALL_OW 273
122043: PPUSH
122044: CALL_OW 111
// SetTag ( i , 0 ) ;
122048: LD_VAR 0 7
122052: PPUSH
122053: LD_INT 0
122055: PPUSH
122056: CALL_OW 109
// solds := solds diff i ;
122060: LD_ADDR_VAR 0 2
122064: PUSH
122065: LD_VAR 0 2
122069: PUSH
122070: LD_VAR 0 7
122074: DIFF
122075: ST_TO_ADDR
// continue ;
122076: GO 121758
// end ; end ;
122078: GO 121758
122080: POP
122081: POP
// until not solds or not enemy ;
122082: LD_VAR 0 2
122086: NOT
122087: PUSH
122088: LD_VAR 0 4
122092: NOT
122093: OR
122094: IFFALSE 121662
// MC_Reset ( base , 18 ) ;
122096: LD_VAR 0 1
122100: PPUSH
122101: LD_INT 18
122103: PPUSH
122104: CALL 26785 0 2
// end ;
122108: LD_VAR 0 3
122112: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
122113: LD_INT 0
122115: PPUSH
122116: PPUSH
122117: PPUSH
122118: PPUSH
122119: PPUSH
122120: PPUSH
122121: PPUSH
122122: PPUSH
122123: PPUSH
122124: PPUSH
122125: PPUSH
122126: PPUSH
122127: PPUSH
122128: PPUSH
122129: PPUSH
122130: PPUSH
122131: PPUSH
122132: PPUSH
122133: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
122134: LD_ADDR_VAR 0 12
122138: PUSH
122139: LD_EXP 78
122143: PUSH
122144: LD_VAR 0 1
122148: ARRAY
122149: PPUSH
122150: LD_INT 25
122152: PUSH
122153: LD_INT 3
122155: PUSH
122156: EMPTY
122157: LIST
122158: LIST
122159: PPUSH
122160: CALL_OW 72
122164: ST_TO_ADDR
// if mc_remote_driver [ base ] then
122165: LD_EXP 118
122169: PUSH
122170: LD_VAR 0 1
122174: ARRAY
122175: IFFALSE 122199
// mechs := mechs diff mc_remote_driver [ base ] ;
122177: LD_ADDR_VAR 0 12
122181: PUSH
122182: LD_VAR 0 12
122186: PUSH
122187: LD_EXP 118
122191: PUSH
122192: LD_VAR 0 1
122196: ARRAY
122197: DIFF
122198: ST_TO_ADDR
// for i in mechs do
122199: LD_ADDR_VAR 0 4
122203: PUSH
122204: LD_VAR 0 12
122208: PUSH
122209: FOR_IN
122210: IFFALSE 122245
// if GetTag ( i ) > 0 then
122212: LD_VAR 0 4
122216: PPUSH
122217: CALL_OW 110
122221: PUSH
122222: LD_INT 0
122224: GREATER
122225: IFFALSE 122243
// mechs := mechs diff i ;
122227: LD_ADDR_VAR 0 12
122231: PUSH
122232: LD_VAR 0 12
122236: PUSH
122237: LD_VAR 0 4
122241: DIFF
122242: ST_TO_ADDR
122243: GO 122209
122245: POP
122246: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
122247: LD_ADDR_VAR 0 8
122251: PUSH
122252: LD_EXP 78
122256: PUSH
122257: LD_VAR 0 1
122261: ARRAY
122262: PPUSH
122263: LD_INT 2
122265: PUSH
122266: LD_INT 25
122268: PUSH
122269: LD_INT 1
122271: PUSH
122272: EMPTY
122273: LIST
122274: LIST
122275: PUSH
122276: LD_INT 25
122278: PUSH
122279: LD_INT 5
122281: PUSH
122282: EMPTY
122283: LIST
122284: LIST
122285: PUSH
122286: LD_INT 25
122288: PUSH
122289: LD_INT 8
122291: PUSH
122292: EMPTY
122293: LIST
122294: LIST
122295: PUSH
122296: LD_INT 25
122298: PUSH
122299: LD_INT 9
122301: PUSH
122302: EMPTY
122303: LIST
122304: LIST
122305: PUSH
122306: EMPTY
122307: LIST
122308: LIST
122309: LIST
122310: LIST
122311: LIST
122312: PPUSH
122313: CALL_OW 72
122317: ST_TO_ADDR
// if not defenders and not solds then
122318: LD_VAR 0 2
122322: NOT
122323: PUSH
122324: LD_VAR 0 8
122328: NOT
122329: AND
122330: IFFALSE 122334
// exit ;
122332: GO 124104
// depot_under_attack := false ;
122334: LD_ADDR_VAR 0 16
122338: PUSH
122339: LD_INT 0
122341: ST_TO_ADDR
// sold_defenders := [ ] ;
122342: LD_ADDR_VAR 0 17
122346: PUSH
122347: EMPTY
122348: ST_TO_ADDR
// if mechs then
122349: LD_VAR 0 12
122353: IFFALSE 122506
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
122355: LD_ADDR_VAR 0 4
122359: PUSH
122360: LD_VAR 0 2
122364: PPUSH
122365: LD_INT 21
122367: PUSH
122368: LD_INT 2
122370: PUSH
122371: EMPTY
122372: LIST
122373: LIST
122374: PPUSH
122375: CALL_OW 72
122379: PUSH
122380: FOR_IN
122381: IFFALSE 122504
// begin if GetTag ( i ) <> 20 then
122383: LD_VAR 0 4
122387: PPUSH
122388: CALL_OW 110
122392: PUSH
122393: LD_INT 20
122395: NONEQUAL
122396: IFFALSE 122410
// SetTag ( i , 20 ) ;
122398: LD_VAR 0 4
122402: PPUSH
122403: LD_INT 20
122405: PPUSH
122406: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
122410: LD_VAR 0 4
122414: PPUSH
122415: CALL_OW 263
122419: PUSH
122420: LD_INT 1
122422: EQUAL
122423: PUSH
122424: LD_VAR 0 4
122428: PPUSH
122429: CALL_OW 311
122433: NOT
122434: AND
122435: IFFALSE 122502
// begin un := mechs [ 1 ] ;
122437: LD_ADDR_VAR 0 10
122441: PUSH
122442: LD_VAR 0 12
122446: PUSH
122447: LD_INT 1
122449: ARRAY
122450: ST_TO_ADDR
// ComExit ( un ) ;
122451: LD_VAR 0 10
122455: PPUSH
122456: CALL 91413 0 1
// AddComEnterUnit ( un , i ) ;
122460: LD_VAR 0 10
122464: PPUSH
122465: LD_VAR 0 4
122469: PPUSH
122470: CALL_OW 180
// SetTag ( un , 19 ) ;
122474: LD_VAR 0 10
122478: PPUSH
122479: LD_INT 19
122481: PPUSH
122482: CALL_OW 109
// mechs := mechs diff un ;
122486: LD_ADDR_VAR 0 12
122490: PUSH
122491: LD_VAR 0 12
122495: PUSH
122496: LD_VAR 0 10
122500: DIFF
122501: ST_TO_ADDR
// end ; end ;
122502: GO 122380
122504: POP
122505: POP
// if solds then
122506: LD_VAR 0 8
122510: IFFALSE 122569
// for i in solds do
122512: LD_ADDR_VAR 0 4
122516: PUSH
122517: LD_VAR 0 8
122521: PUSH
122522: FOR_IN
122523: IFFALSE 122567
// if not GetTag ( i ) then
122525: LD_VAR 0 4
122529: PPUSH
122530: CALL_OW 110
122534: NOT
122535: IFFALSE 122565
// begin defenders := defenders union i ;
122537: LD_ADDR_VAR 0 2
122541: PUSH
122542: LD_VAR 0 2
122546: PUSH
122547: LD_VAR 0 4
122551: UNION
122552: ST_TO_ADDR
// SetTag ( i , 18 ) ;
122553: LD_VAR 0 4
122557: PPUSH
122558: LD_INT 18
122560: PPUSH
122561: CALL_OW 109
// end ;
122565: GO 122522
122567: POP
122568: POP
// repeat wait ( 0 0$2 ) ;
122569: LD_INT 70
122571: PPUSH
122572: CALL_OW 67
// enemy := mc_scan [ base ] ;
122576: LD_ADDR_VAR 0 21
122580: PUSH
122581: LD_EXP 101
122585: PUSH
122586: LD_VAR 0 1
122590: ARRAY
122591: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122592: LD_EXP 78
122596: PUSH
122597: LD_VAR 0 1
122601: ARRAY
122602: NOT
122603: PUSH
122604: LD_EXP 78
122608: PUSH
122609: LD_VAR 0 1
122613: ARRAY
122614: PUSH
122615: EMPTY
122616: EQUAL
122617: OR
122618: IFFALSE 122655
// begin for i in defenders do
122620: LD_ADDR_VAR 0 4
122624: PUSH
122625: LD_VAR 0 2
122629: PUSH
122630: FOR_IN
122631: IFFALSE 122644
// ComStop ( i ) ;
122633: LD_VAR 0 4
122637: PPUSH
122638: CALL_OW 141
122642: GO 122630
122644: POP
122645: POP
// defenders := [ ] ;
122646: LD_ADDR_VAR 0 2
122650: PUSH
122651: EMPTY
122652: ST_TO_ADDR
// exit ;
122653: GO 124104
// end ; for i in defenders do
122655: LD_ADDR_VAR 0 4
122659: PUSH
122660: LD_VAR 0 2
122664: PUSH
122665: FOR_IN
122666: IFFALSE 123564
// begin e := NearestUnitToUnit ( enemy , i ) ;
122668: LD_ADDR_VAR 0 13
122672: PUSH
122673: LD_VAR 0 21
122677: PPUSH
122678: LD_VAR 0 4
122682: PPUSH
122683: CALL_OW 74
122687: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
122688: LD_ADDR_VAR 0 7
122692: PUSH
122693: LD_EXP 78
122697: PUSH
122698: LD_VAR 0 1
122702: ARRAY
122703: PPUSH
122704: LD_INT 2
122706: PUSH
122707: LD_INT 30
122709: PUSH
122710: LD_INT 0
122712: PUSH
122713: EMPTY
122714: LIST
122715: LIST
122716: PUSH
122717: LD_INT 30
122719: PUSH
122720: LD_INT 1
122722: PUSH
122723: EMPTY
122724: LIST
122725: LIST
122726: PUSH
122727: EMPTY
122728: LIST
122729: LIST
122730: LIST
122731: PPUSH
122732: CALL_OW 72
122736: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
122737: LD_ADDR_VAR 0 16
122741: PUSH
122742: LD_VAR 0 7
122746: NOT
122747: PUSH
122748: LD_VAR 0 7
122752: PPUSH
122753: LD_INT 3
122755: PUSH
122756: LD_INT 24
122758: PUSH
122759: LD_INT 600
122761: PUSH
122762: EMPTY
122763: LIST
122764: LIST
122765: PUSH
122766: EMPTY
122767: LIST
122768: LIST
122769: PPUSH
122770: CALL_OW 72
122774: OR
122775: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
122776: LD_VAR 0 4
122780: PPUSH
122781: CALL_OW 247
122785: PUSH
122786: LD_INT 2
122788: DOUBLE
122789: EQUAL
122790: IFTRUE 122794
122792: GO 123190
122794: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
122795: LD_VAR 0 4
122799: PPUSH
122800: CALL_OW 256
122804: PUSH
122805: LD_INT 1000
122807: EQUAL
122808: PUSH
122809: LD_VAR 0 4
122813: PPUSH
122814: LD_VAR 0 13
122818: PPUSH
122819: CALL_OW 296
122823: PUSH
122824: LD_INT 40
122826: LESS
122827: PUSH
122828: LD_VAR 0 13
122832: PPUSH
122833: LD_EXP 103
122837: PUSH
122838: LD_VAR 0 1
122842: ARRAY
122843: PPUSH
122844: CALL_OW 308
122848: OR
122849: AND
122850: IFFALSE 122972
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
122852: LD_VAR 0 4
122856: PPUSH
122857: CALL_OW 262
122861: PUSH
122862: LD_INT 1
122864: EQUAL
122865: PUSH
122866: LD_VAR 0 4
122870: PPUSH
122871: CALL_OW 261
122875: PUSH
122876: LD_INT 30
122878: LESS
122879: AND
122880: PUSH
122881: LD_VAR 0 7
122885: AND
122886: IFFALSE 122956
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
122888: LD_VAR 0 4
122892: PPUSH
122893: LD_VAR 0 7
122897: PPUSH
122898: LD_VAR 0 4
122902: PPUSH
122903: CALL_OW 74
122907: PPUSH
122908: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
122912: LD_VAR 0 4
122916: PPUSH
122917: LD_VAR 0 7
122921: PPUSH
122922: LD_VAR 0 4
122926: PPUSH
122927: CALL_OW 74
122931: PPUSH
122932: CALL_OW 296
122936: PUSH
122937: LD_INT 6
122939: LESS
122940: IFFALSE 122954
// SetFuel ( i , 100 ) ;
122942: LD_VAR 0 4
122946: PPUSH
122947: LD_INT 100
122949: PPUSH
122950: CALL_OW 240
// end else
122954: GO 122970
// ComAttackUnit ( i , e ) ;
122956: LD_VAR 0 4
122960: PPUSH
122961: LD_VAR 0 13
122965: PPUSH
122966: CALL_OW 115
// end else
122970: GO 123073
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
122972: LD_VAR 0 13
122976: PPUSH
122977: LD_EXP 103
122981: PUSH
122982: LD_VAR 0 1
122986: ARRAY
122987: PPUSH
122988: CALL_OW 308
122992: NOT
122993: PUSH
122994: LD_VAR 0 4
122998: PPUSH
122999: LD_VAR 0 13
123003: PPUSH
123004: CALL_OW 296
123008: PUSH
123009: LD_INT 40
123011: GREATEREQUAL
123012: AND
123013: PUSH
123014: LD_VAR 0 4
123018: PPUSH
123019: CALL_OW 256
123023: PUSH
123024: LD_INT 650
123026: LESSEQUAL
123027: OR
123028: PUSH
123029: LD_VAR 0 4
123033: PPUSH
123034: LD_EXP 102
123038: PUSH
123039: LD_VAR 0 1
123043: ARRAY
123044: PPUSH
123045: CALL_OW 308
123049: NOT
123050: AND
123051: IFFALSE 123073
// ComMoveToArea ( i , mc_parking [ base ] ) ;
123053: LD_VAR 0 4
123057: PPUSH
123058: LD_EXP 102
123062: PUSH
123063: LD_VAR 0 1
123067: ARRAY
123068: PPUSH
123069: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
123073: LD_VAR 0 4
123077: PPUSH
123078: CALL_OW 256
123082: PUSH
123083: LD_INT 1000
123085: LESS
123086: PUSH
123087: LD_VAR 0 4
123091: PPUSH
123092: CALL_OW 263
123096: PUSH
123097: LD_INT 1
123099: EQUAL
123100: AND
123101: PUSH
123102: LD_VAR 0 4
123106: PPUSH
123107: CALL_OW 311
123111: AND
123112: PUSH
123113: LD_VAR 0 4
123117: PPUSH
123118: LD_EXP 102
123122: PUSH
123123: LD_VAR 0 1
123127: ARRAY
123128: PPUSH
123129: CALL_OW 308
123133: AND
123134: IFFALSE 123188
// begin mech := IsDrivenBy ( i ) ;
123136: LD_ADDR_VAR 0 9
123140: PUSH
123141: LD_VAR 0 4
123145: PPUSH
123146: CALL_OW 311
123150: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
123151: LD_VAR 0 9
123155: PPUSH
123156: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
123160: LD_VAR 0 9
123164: PPUSH
123165: LD_VAR 0 4
123169: PPUSH
123170: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
123174: LD_VAR 0 9
123178: PPUSH
123179: LD_VAR 0 4
123183: PPUSH
123184: CALL_OW 180
// end ; end ; unit_human :
123188: GO 123535
123190: LD_INT 1
123192: DOUBLE
123193: EQUAL
123194: IFTRUE 123198
123196: GO 123534
123198: POP
// begin b := IsInUnit ( i ) ;
123199: LD_ADDR_VAR 0 18
123203: PUSH
123204: LD_VAR 0 4
123208: PPUSH
123209: CALL_OW 310
123213: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
123214: LD_ADDR_VAR 0 19
123218: PUSH
123219: LD_VAR 0 18
123223: NOT
123224: PUSH
123225: LD_VAR 0 18
123229: PPUSH
123230: CALL_OW 266
123234: PUSH
123235: LD_INT 32
123237: PUSH
123238: LD_INT 31
123240: PUSH
123241: EMPTY
123242: LIST
123243: LIST
123244: IN
123245: OR
123246: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
123247: LD_VAR 0 18
123251: PPUSH
123252: CALL_OW 266
123256: PUSH
123257: LD_INT 5
123259: EQUAL
123260: PUSH
123261: LD_VAR 0 4
123265: PPUSH
123266: CALL_OW 257
123270: PUSH
123271: LD_INT 1
123273: PUSH
123274: LD_INT 2
123276: PUSH
123277: LD_INT 3
123279: PUSH
123280: LD_INT 4
123282: PUSH
123283: EMPTY
123284: LIST
123285: LIST
123286: LIST
123287: LIST
123288: IN
123289: AND
123290: IFFALSE 123327
// begin class := AllowSpecClass ( i ) ;
123292: LD_ADDR_VAR 0 20
123296: PUSH
123297: LD_VAR 0 4
123301: PPUSH
123302: CALL 55110 0 1
123306: ST_TO_ADDR
// if class then
123307: LD_VAR 0 20
123311: IFFALSE 123327
// ComChangeProfession ( i , class ) ;
123313: LD_VAR 0 4
123317: PPUSH
123318: LD_VAR 0 20
123322: PPUSH
123323: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
123327: LD_VAR 0 16
123331: PUSH
123332: LD_VAR 0 2
123336: PPUSH
123337: LD_INT 21
123339: PUSH
123340: LD_INT 2
123342: PUSH
123343: EMPTY
123344: LIST
123345: LIST
123346: PPUSH
123347: CALL_OW 72
123351: PUSH
123352: LD_INT 1
123354: LESSEQUAL
123355: OR
123356: PUSH
123357: LD_VAR 0 19
123361: AND
123362: PUSH
123363: LD_VAR 0 4
123367: PUSH
123368: LD_VAR 0 17
123372: IN
123373: NOT
123374: AND
123375: IFFALSE 123468
// begin if b then
123377: LD_VAR 0 18
123381: IFFALSE 123430
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
123383: LD_VAR 0 18
123387: PPUSH
123388: LD_VAR 0 21
123392: PPUSH
123393: LD_VAR 0 18
123397: PPUSH
123398: CALL_OW 74
123402: PPUSH
123403: CALL_OW 296
123407: PUSH
123408: LD_INT 10
123410: LESS
123411: PUSH
123412: LD_VAR 0 18
123416: PPUSH
123417: CALL_OW 461
123421: PUSH
123422: LD_INT 7
123424: NONEQUAL
123425: AND
123426: IFFALSE 123430
// continue ;
123428: GO 122665
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
123430: LD_ADDR_VAR 0 17
123434: PUSH
123435: LD_VAR 0 17
123439: PPUSH
123440: LD_VAR 0 17
123444: PUSH
123445: LD_INT 1
123447: PLUS
123448: PPUSH
123449: LD_VAR 0 4
123453: PPUSH
123454: CALL_OW 1
123458: ST_TO_ADDR
// ComExitBuilding ( i ) ;
123459: LD_VAR 0 4
123463: PPUSH
123464: CALL_OW 122
// end ; if sold_defenders then
123468: LD_VAR 0 17
123472: IFFALSE 123532
// if i in sold_defenders then
123474: LD_VAR 0 4
123478: PUSH
123479: LD_VAR 0 17
123483: IN
123484: IFFALSE 123532
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
123486: LD_VAR 0 4
123490: PPUSH
123491: CALL_OW 314
123495: NOT
123496: PUSH
123497: LD_VAR 0 4
123501: PPUSH
123502: LD_VAR 0 13
123506: PPUSH
123507: CALL_OW 296
123511: PUSH
123512: LD_INT 30
123514: LESS
123515: AND
123516: IFFALSE 123532
// ComAttackUnit ( i , e ) ;
123518: LD_VAR 0 4
123522: PPUSH
123523: LD_VAR 0 13
123527: PPUSH
123528: CALL_OW 115
// end ; end ; end ;
123532: GO 123535
123534: POP
// if IsDead ( i ) then
123535: LD_VAR 0 4
123539: PPUSH
123540: CALL_OW 301
123544: IFFALSE 123562
// defenders := defenders diff i ;
123546: LD_ADDR_VAR 0 2
123550: PUSH
123551: LD_VAR 0 2
123555: PUSH
123556: LD_VAR 0 4
123560: DIFF
123561: ST_TO_ADDR
// end ;
123562: GO 122665
123564: POP
123565: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
123566: LD_VAR 0 21
123570: NOT
123571: PUSH
123572: LD_VAR 0 2
123576: NOT
123577: OR
123578: PUSH
123579: LD_EXP 78
123583: PUSH
123584: LD_VAR 0 1
123588: ARRAY
123589: NOT
123590: OR
123591: IFFALSE 122569
// MC_Reset ( base , 18 ) ;
123593: LD_VAR 0 1
123597: PPUSH
123598: LD_INT 18
123600: PPUSH
123601: CALL 26785 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
123605: LD_ADDR_VAR 0 2
123609: PUSH
123610: LD_VAR 0 2
123614: PUSH
123615: LD_VAR 0 2
123619: PPUSH
123620: LD_INT 2
123622: PUSH
123623: LD_INT 25
123625: PUSH
123626: LD_INT 1
123628: PUSH
123629: EMPTY
123630: LIST
123631: LIST
123632: PUSH
123633: LD_INT 25
123635: PUSH
123636: LD_INT 5
123638: PUSH
123639: EMPTY
123640: LIST
123641: LIST
123642: PUSH
123643: LD_INT 25
123645: PUSH
123646: LD_INT 8
123648: PUSH
123649: EMPTY
123650: LIST
123651: LIST
123652: PUSH
123653: LD_INT 25
123655: PUSH
123656: LD_INT 9
123658: PUSH
123659: EMPTY
123660: LIST
123661: LIST
123662: PUSH
123663: EMPTY
123664: LIST
123665: LIST
123666: LIST
123667: LIST
123668: LIST
123669: PPUSH
123670: CALL_OW 72
123674: DIFF
123675: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
123676: LD_VAR 0 21
123680: NOT
123681: PUSH
123682: LD_VAR 0 2
123686: PPUSH
123687: LD_INT 21
123689: PUSH
123690: LD_INT 2
123692: PUSH
123693: EMPTY
123694: LIST
123695: LIST
123696: PPUSH
123697: CALL_OW 72
123701: AND
123702: IFFALSE 124040
// begin tmp := FilterByTag ( defenders , 19 ) ;
123704: LD_ADDR_VAR 0 11
123708: PUSH
123709: LD_VAR 0 2
123713: PPUSH
123714: LD_INT 19
123716: PPUSH
123717: CALL 88584 0 2
123721: ST_TO_ADDR
// if tmp then
123722: LD_VAR 0 11
123726: IFFALSE 123796
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
123728: LD_ADDR_VAR 0 11
123732: PUSH
123733: LD_VAR 0 11
123737: PPUSH
123738: LD_INT 25
123740: PUSH
123741: LD_INT 3
123743: PUSH
123744: EMPTY
123745: LIST
123746: LIST
123747: PPUSH
123748: CALL_OW 72
123752: ST_TO_ADDR
// if tmp then
123753: LD_VAR 0 11
123757: IFFALSE 123796
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
123759: LD_ADDR_EXP 90
123763: PUSH
123764: LD_EXP 90
123768: PPUSH
123769: LD_VAR 0 1
123773: PPUSH
123774: LD_EXP 90
123778: PUSH
123779: LD_VAR 0 1
123783: ARRAY
123784: PUSH
123785: LD_VAR 0 11
123789: UNION
123790: PPUSH
123791: CALL_OW 1
123795: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
123796: LD_VAR 0 1
123800: PPUSH
123801: LD_INT 19
123803: PPUSH
123804: CALL 26785 0 2
// repeat wait ( 0 0$1 ) ;
123808: LD_INT 35
123810: PPUSH
123811: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
123815: LD_EXP 78
123819: PUSH
123820: LD_VAR 0 1
123824: ARRAY
123825: NOT
123826: PUSH
123827: LD_EXP 78
123831: PUSH
123832: LD_VAR 0 1
123836: ARRAY
123837: PUSH
123838: EMPTY
123839: EQUAL
123840: OR
123841: IFFALSE 123878
// begin for i in defenders do
123843: LD_ADDR_VAR 0 4
123847: PUSH
123848: LD_VAR 0 2
123852: PUSH
123853: FOR_IN
123854: IFFALSE 123867
// ComStop ( i ) ;
123856: LD_VAR 0 4
123860: PPUSH
123861: CALL_OW 141
123865: GO 123853
123867: POP
123868: POP
// defenders := [ ] ;
123869: LD_ADDR_VAR 0 2
123873: PUSH
123874: EMPTY
123875: ST_TO_ADDR
// exit ;
123876: GO 124104
// end ; for i in defenders do
123878: LD_ADDR_VAR 0 4
123882: PUSH
123883: LD_VAR 0 2
123887: PUSH
123888: FOR_IN
123889: IFFALSE 123978
// begin if not IsInArea ( i , mc_parking [ base ] ) then
123891: LD_VAR 0 4
123895: PPUSH
123896: LD_EXP 102
123900: PUSH
123901: LD_VAR 0 1
123905: ARRAY
123906: PPUSH
123907: CALL_OW 308
123911: NOT
123912: IFFALSE 123936
// ComMoveToArea ( i , mc_parking [ base ] ) else
123914: LD_VAR 0 4
123918: PPUSH
123919: LD_EXP 102
123923: PUSH
123924: LD_VAR 0 1
123928: ARRAY
123929: PPUSH
123930: CALL_OW 113
123934: GO 123976
// if GetControl ( i ) = control_manual then
123936: LD_VAR 0 4
123940: PPUSH
123941: CALL_OW 263
123945: PUSH
123946: LD_INT 1
123948: EQUAL
123949: IFFALSE 123976
// if IsDrivenBy ( i ) then
123951: LD_VAR 0 4
123955: PPUSH
123956: CALL_OW 311
123960: IFFALSE 123976
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
123962: LD_VAR 0 4
123966: PPUSH
123967: CALL_OW 311
123971: PPUSH
123972: CALL_OW 121
// end ;
123976: GO 123888
123978: POP
123979: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
123980: LD_VAR 0 2
123984: PPUSH
123985: LD_INT 95
123987: PUSH
123988: LD_EXP 102
123992: PUSH
123993: LD_VAR 0 1
123997: ARRAY
123998: PUSH
123999: EMPTY
124000: LIST
124001: LIST
124002: PPUSH
124003: CALL_OW 72
124007: PUSH
124008: LD_VAR 0 2
124012: EQUAL
124013: PUSH
124014: LD_EXP 101
124018: PUSH
124019: LD_VAR 0 1
124023: ARRAY
124024: OR
124025: PUSH
124026: LD_EXP 78
124030: PUSH
124031: LD_VAR 0 1
124035: ARRAY
124036: NOT
124037: OR
124038: IFFALSE 123808
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
124040: LD_ADDR_EXP 100
124044: PUSH
124045: LD_EXP 100
124049: PPUSH
124050: LD_VAR 0 1
124054: PPUSH
124055: LD_VAR 0 2
124059: PPUSH
124060: LD_INT 21
124062: PUSH
124063: LD_INT 2
124065: PUSH
124066: EMPTY
124067: LIST
124068: LIST
124069: PPUSH
124070: CALL_OW 72
124074: PPUSH
124075: CALL_OW 1
124079: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
124080: LD_VAR 0 1
124084: PPUSH
124085: LD_INT 19
124087: PPUSH
124088: CALL 26785 0 2
// MC_Reset ( base , 20 ) ;
124092: LD_VAR 0 1
124096: PPUSH
124097: LD_INT 20
124099: PPUSH
124100: CALL 26785 0 2
// end ; end_of_file
124104: LD_VAR 0 3
124108: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
124109: LD_VAR 0 1
124113: PUSH
124114: LD_INT 200
124116: DOUBLE
124117: GREATEREQUAL
124118: IFFALSE 124126
124120: LD_INT 299
124122: DOUBLE
124123: LESSEQUAL
124124: IFTRUE 124128
124126: GO 124160
124128: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
124129: LD_VAR 0 1
124133: PPUSH
124134: LD_VAR 0 2
124138: PPUSH
124139: LD_VAR 0 3
124143: PPUSH
124144: LD_VAR 0 4
124148: PPUSH
124149: LD_VAR 0 5
124153: PPUSH
124154: CALL 112290 0 5
124158: GO 124237
124160: LD_INT 300
124162: DOUBLE
124163: GREATEREQUAL
124164: IFFALSE 124172
124166: LD_INT 399
124168: DOUBLE
124169: LESSEQUAL
124170: IFTRUE 124174
124172: GO 124236
124174: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
124175: LD_VAR 0 1
124179: PPUSH
124180: LD_VAR 0 2
124184: PPUSH
124185: LD_VAR 0 3
124189: PPUSH
124190: LD_VAR 0 4
124194: PPUSH
124195: LD_VAR 0 5
124199: PPUSH
124200: LD_VAR 0 6
124204: PPUSH
124205: LD_VAR 0 7
124209: PPUSH
124210: LD_VAR 0 8
124214: PPUSH
124215: LD_VAR 0 9
124219: PPUSH
124220: LD_VAR 0 10
124224: PPUSH
124225: LD_VAR 0 11
124229: PPUSH
124230: CALL 108615 0 11
124234: GO 124237
124236: POP
// end ;
124237: PPOPN 11
124239: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
124240: LD_VAR 0 1
124244: PPUSH
124245: LD_VAR 0 2
124249: PPUSH
124250: LD_VAR 0 3
124254: PPUSH
124255: LD_VAR 0 4
124259: PPUSH
124260: LD_VAR 0 5
124264: PPUSH
124265: CALL 112026 0 5
// end ; end_of_file
124269: PPOPN 5
124271: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
124272: LD_VAR 0 1
124276: PPUSH
124277: LD_VAR 0 2
124281: PPUSH
124282: LD_VAR 0 3
124286: PPUSH
124287: LD_VAR 0 4
124291: PPUSH
124292: LD_VAR 0 5
124296: PPUSH
124297: LD_VAR 0 6
124301: PPUSH
124302: CALL 96267 0 6
// end ;
124306: PPOPN 6
124308: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
124309: LD_INT 0
124311: PPUSH
// begin if not units then
124312: LD_VAR 0 1
124316: NOT
124317: IFFALSE 124321
// exit ;
124319: GO 124321
// end ;
124321: PPOPN 7
124323: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
124324: CALL 96154 0 0
// end ;
124328: PPOPN 1
124330: END
