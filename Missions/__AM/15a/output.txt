// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 21518 0 0
// InitNature ;
  19: CALL 18184 0 0
// InitArtifact ;
  23: CALL 18801 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5102 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 6871 0 0
// PrepareRussian ;
  52: CALL 8957 0 0
// PrepareLegion ;
  56: CALL 7368 0 0
// Action ;
  60: CALL 11747 0 0
// MC_Start ( ) ;
  64: CALL 23698 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 102
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 103
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 45401 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 46480 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 46573 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 107
 353: PUSH
 354: LD_EXP 107
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 45738 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 45923 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 46480 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 46573 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 45738 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 45923 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 46353 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 45401 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 46480 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 46573 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 107
 843: PUSH
 844: LD_EXP 107
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 45738 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 45923 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 46480 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 46573 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 46891 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 46685 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 45738 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 45923 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 46304 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// uc_side := 7 ;
1443: LD_ADDR_OWVAR 20
1447: PUSH
1448: LD_INT 7
1450: ST_TO_ADDR
// tmp := [ ] ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: EMPTY
1457: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1458: LD_ADDR_EXP 19
1462: PUSH
1463: LD_STRING JMM
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: LD_STRING 14a_
1474: PPUSH
1475: CALL 52212 0 3
1479: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1480: LD_ADDR_EXP 52
1484: PUSH
1485: LD_STRING Burlak
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: LD_STRING 14a_
1496: PPUSH
1497: CALL 52212 0 3
1501: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1502: LD_ADDR_EXP 34
1506: PUSH
1507: LD_STRING Joan
1509: PPUSH
1510: LD_EXP 1
1514: NOT
1515: PPUSH
1516: LD_STRING 13a_
1518: PPUSH
1519: CALL 52212 0 3
1523: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1524: LD_ADDR_EXP 20
1528: PUSH
1529: LD_STRING Roth
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_STRING 13a_
1540: PPUSH
1541: CALL 52212 0 3
1545: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1546: LD_ADDR_EXP 38
1550: PUSH
1551: LD_STRING Gossudarov
1553: PPUSH
1554: LD_EXP 1
1558: NOT
1559: PPUSH
1560: LD_STRING 13a_
1562: PPUSH
1563: CALL 52212 0 3
1567: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1568: LD_ADDR_EXP 25
1572: PUSH
1573: LD_STRING Denis
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 13a_
1584: PPUSH
1585: CALL 52212 0 3
1589: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING DeltaDoctor
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 13a_
1606: PPUSH
1607: CALL 52212 0 3
1611: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1612: LD_ADDR_EXP 37
1616: PUSH
1617: LD_STRING Mike
1619: PPUSH
1620: LD_EXP 1
1624: NOT
1625: PPUSH
1626: LD_STRING 13a_
1628: PPUSH
1629: CALL 52212 0 3
1633: ST_TO_ADDR
// if DeltaDoctor then
1634: LD_EXP 35
1638: IFFALSE 1656
// tmp := tmp ^ DeltaDoctor ;
1640: LD_ADDR_VAR 0 5
1644: PUSH
1645: LD_VAR 0 5
1649: PUSH
1650: LD_EXP 35
1654: ADD
1655: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1656: LD_ADDR_EXP 33
1660: PUSH
1661: LD_STRING Simms
1663: PPUSH
1664: LD_EXP 1
1668: NOT
1669: PPUSH
1670: LD_STRING 13a_
1672: PPUSH
1673: CALL 52212 0 3
1677: ST_TO_ADDR
// if Simms then
1678: LD_EXP 33
1682: IFFALSE 1700
// tmp := tmp ^ Simms ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_VAR 0 5
1693: PUSH
1694: LD_EXP 33
1698: ADD
1699: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1700: LD_ADDR_EXP 31
1704: PUSH
1705: LD_STRING Frank
1707: PPUSH
1708: LD_EXP 1
1712: NOT
1713: PPUSH
1714: LD_STRING 13a_
1716: PPUSH
1717: CALL 52212 0 3
1721: ST_TO_ADDR
// if Frank then
1722: LD_EXP 31
1726: IFFALSE 1744
// tmp := tmp ^ Frank ;
1728: LD_ADDR_VAR 0 5
1732: PUSH
1733: LD_VAR 0 5
1737: PUSH
1738: LD_EXP 31
1742: ADD
1743: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1744: LD_ADDR_EXP 39
1748: PUSH
1749: LD_STRING Kirilenkova
1751: PPUSH
1752: LD_EXP 1
1756: NOT
1757: PPUSH
1758: LD_STRING 13a_
1760: PPUSH
1761: CALL 52212 0 3
1765: ST_TO_ADDR
// if Kirilenkova then
1766: LD_EXP 39
1770: IFFALSE 1788
// tmp := tmp ^ Kirilenkova ;
1772: LD_ADDR_VAR 0 5
1776: PUSH
1777: LD_VAR 0 5
1781: PUSH
1782: LD_EXP 39
1786: ADD
1787: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1788: LD_ADDR_EXP 40
1792: PUSH
1793: LD_STRING Titov
1795: PPUSH
1796: LD_EXP 1
1800: NOT
1801: PPUSH
1802: LD_STRING 13a_
1804: PPUSH
1805: CALL 52212 0 3
1809: ST_TO_ADDR
// if Titov then
1810: LD_EXP 40
1814: IFFALSE 1832
// tmp := tmp ^ Titov ;
1816: LD_ADDR_VAR 0 5
1820: PUSH
1821: LD_VAR 0 5
1825: PUSH
1826: LD_EXP 40
1830: ADD
1831: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1832: LD_ADDR_EXP 41
1836: PUSH
1837: LD_STRING Fadeev
1839: PPUSH
1840: LD_EXP 1
1844: NOT
1845: PPUSH
1846: LD_STRING 13a_
1848: PPUSH
1849: CALL 52212 0 3
1853: ST_TO_ADDR
// if Fadeev then
1854: LD_EXP 41
1858: IFFALSE 1876
// tmp := tmp ^ Fadeev ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_EXP 41
1874: ADD
1875: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1876: LD_ADDR_EXP 42
1880: PUSH
1881: LD_STRING Dolgov
1883: PPUSH
1884: LD_EXP 1
1888: NOT
1889: PPUSH
1890: LD_STRING 13a_
1892: PPUSH
1893: CALL 52212 0 3
1897: ST_TO_ADDR
// if Dolgov then
1898: LD_EXP 42
1902: IFFALSE 1920
// tmp := tmp ^ Dolgov ;
1904: LD_ADDR_VAR 0 5
1908: PUSH
1909: LD_VAR 0 5
1913: PUSH
1914: LD_EXP 42
1918: ADD
1919: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1920: LD_ADDR_EXP 43
1924: PUSH
1925: LD_STRING Petrosyan
1927: PPUSH
1928: LD_EXP 1
1932: NOT
1933: PPUSH
1934: LD_STRING 13a_
1936: PPUSH
1937: CALL 52212 0 3
1941: ST_TO_ADDR
// if Petrosyan then
1942: LD_EXP 43
1946: IFFALSE 1964
// tmp := tmp ^ Petrosyan ;
1948: LD_ADDR_VAR 0 5
1952: PUSH
1953: LD_VAR 0 5
1957: PUSH
1958: LD_EXP 43
1962: ADD
1963: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1964: LD_ADDR_EXP 44
1968: PUSH
1969: LD_STRING Scholtze
1971: PPUSH
1972: LD_EXP 1
1976: NOT
1977: PPUSH
1978: LD_STRING 13a_
1980: PPUSH
1981: CALL 52212 0 3
1985: ST_TO_ADDR
// if Scholtze then
1986: LD_EXP 44
1990: IFFALSE 2008
// tmp := tmp ^ Scholtze ;
1992: LD_ADDR_VAR 0 5
1996: PUSH
1997: LD_VAR 0 5
2001: PUSH
2002: LD_EXP 44
2006: ADD
2007: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2008: LD_ADDR_EXP 45
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: LD_EXP 1
2020: NOT
2021: PPUSH
2022: LD_STRING 13a_
2024: PPUSH
2025: CALL 52212 0 3
2029: ST_TO_ADDR
// if Oblukov then
2030: LD_EXP 45
2034: IFFALSE 2052
// tmp := tmp ^ Oblukov ;
2036: LD_ADDR_VAR 0 5
2040: PUSH
2041: LD_VAR 0 5
2045: PUSH
2046: LD_EXP 45
2050: ADD
2051: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2052: LD_ADDR_EXP 46
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: LD_EXP 1
2064: NOT
2065: PPUSH
2066: LD_STRING 13a_
2068: PPUSH
2069: CALL 52212 0 3
2073: ST_TO_ADDR
// if Kapitsova then
2074: LD_EXP 46
2078: IFFALSE 2096
// tmp := tmp ^ Kapitsova ;
2080: LD_ADDR_VAR 0 5
2084: PUSH
2085: LD_VAR 0 5
2089: PUSH
2090: LD_EXP 46
2094: ADD
2095: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2096: LD_ADDR_EXP 47
2100: PUSH
2101: LD_STRING Lipshchin
2103: PPUSH
2104: LD_EXP 1
2108: NOT
2109: PPUSH
2110: LD_STRING 13a_
2112: PPUSH
2113: CALL 52212 0 3
2117: ST_TO_ADDR
// if Lipshchin then
2118: LD_EXP 47
2122: IFFALSE 2140
// tmp := tmp ^ Lipshchin ;
2124: LD_ADDR_VAR 0 5
2128: PUSH
2129: LD_VAR 0 5
2133: PUSH
2134: LD_EXP 47
2138: ADD
2139: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2140: LD_ADDR_EXP 48
2144: PUSH
2145: LD_STRING Petrovova
2147: PPUSH
2148: LD_EXP 1
2152: NOT
2153: PPUSH
2154: LD_STRING 13a_
2156: PPUSH
2157: CALL 52212 0 3
2161: ST_TO_ADDR
// if Petrovova then
2162: LD_EXP 48
2166: IFFALSE 2184
// tmp := tmp ^ Petrovova ;
2168: LD_ADDR_VAR 0 5
2172: PUSH
2173: LD_VAR 0 5
2177: PUSH
2178: LD_EXP 48
2182: ADD
2183: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2184: LD_ADDR_EXP 49
2188: PUSH
2189: LD_STRING Kovalyuk
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13a_
2200: PPUSH
2201: CALL 52212 0 3
2205: ST_TO_ADDR
// if Kovalyuk then
2206: LD_EXP 49
2210: IFFALSE 2228
// tmp := tmp ^ Kovalyuk ;
2212: LD_ADDR_VAR 0 5
2216: PUSH
2217: LD_VAR 0 5
2221: PUSH
2222: LD_EXP 49
2226: ADD
2227: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2228: LD_ADDR_EXP 50
2232: PUSH
2233: LD_STRING Kuzmov
2235: PPUSH
2236: LD_EXP 1
2240: NOT
2241: PPUSH
2242: LD_STRING 13a_
2244: PPUSH
2245: CALL 52212 0 3
2249: ST_TO_ADDR
// if Kuzmov then
2250: LD_EXP 50
2254: IFFALSE 2272
// tmp := tmp ^ Kuzmov ;
2256: LD_ADDR_VAR 0 5
2260: PUSH
2261: LD_VAR 0 5
2265: PUSH
2266: LD_EXP 50
2270: ADD
2271: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2272: LD_ADDR_EXP 51
2276: PUSH
2277: LD_STRING Karamazov
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: LD_STRING 13a_
2288: PPUSH
2289: CALL 52212 0 3
2293: ST_TO_ADDR
// if Karamazov then
2294: LD_EXP 51
2298: IFFALSE 2316
// tmp := tmp ^ Karamazov ;
2300: LD_ADDR_VAR 0 5
2304: PUSH
2305: LD_VAR 0 5
2309: PUSH
2310: LD_EXP 51
2314: ADD
2315: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2316: LD_ADDR_EXP 53
2320: PUSH
2321: LD_STRING Belkov
2323: PPUSH
2324: LD_EXP 1
2328: NOT
2329: PPUSH
2330: LD_STRING 13a_
2332: PPUSH
2333: CALL 52212 0 3
2337: ST_TO_ADDR
// if Belkov then
2338: LD_EXP 53
2342: IFFALSE 2360
// tmp := tmp ^ Belkov ;
2344: LD_ADDR_VAR 0 5
2348: PUSH
2349: LD_VAR 0 5
2353: PUSH
2354: LD_EXP 53
2358: ADD
2359: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 54
2364: PUSH
2365: LD_STRING Gnyevko
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 52212 0 3
2381: ST_TO_ADDR
// if Gnyevko then
2382: LD_EXP 54
2386: IFFALSE 2404
// tmp := tmp ^ Gnyevko ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 54
2402: ADD
2403: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2404: LD_ADDR_EXP 36
2408: PUSH
2409: LD_STRING Coonie
2411: PPUSH
2412: CALL_OW 25
2416: ST_TO_ADDR
// if not Lisa then
2417: LD_EXP 21
2421: NOT
2422: IFFALSE 2468
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2424: LD_ADDR_EXP 21
2428: PUSH
2429: LD_STRING Lisa
2431: PPUSH
2432: LD_EXP 1
2436: NOT
2437: PPUSH
2438: LD_STRING 13a_
2440: PPUSH
2441: CALL 52212 0 3
2445: ST_TO_ADDR
// if Lisa then
2446: LD_EXP 21
2450: IFFALSE 2468
// tmp := tmp ^ Lisa ;
2452: LD_ADDR_VAR 0 5
2456: PUSH
2457: LD_VAR 0 5
2461: PUSH
2462: LD_EXP 21
2466: ADD
2467: ST_TO_ADDR
// end ; if not Donaldson then
2468: LD_EXP 22
2472: NOT
2473: IFFALSE 2519
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2475: LD_ADDR_EXP 22
2479: PUSH
2480: LD_STRING Donaldson
2482: PPUSH
2483: LD_EXP 1
2487: NOT
2488: PPUSH
2489: LD_STRING 13a_
2491: PPUSH
2492: CALL 52212 0 3
2496: ST_TO_ADDR
// if Donaldson then
2497: LD_EXP 22
2501: IFFALSE 2519
// tmp := tmp ^ Donaldson ;
2503: LD_ADDR_VAR 0 5
2507: PUSH
2508: LD_VAR 0 5
2512: PUSH
2513: LD_EXP 22
2517: ADD
2518: ST_TO_ADDR
// end ; if not Bobby then
2519: LD_EXP 23
2523: NOT
2524: IFFALSE 2570
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2526: LD_ADDR_EXP 23
2530: PUSH
2531: LD_STRING Bobby
2533: PPUSH
2534: LD_EXP 1
2538: NOT
2539: PPUSH
2540: LD_STRING 13a_
2542: PPUSH
2543: CALL 52212 0 3
2547: ST_TO_ADDR
// if Bobby then
2548: LD_EXP 23
2552: IFFALSE 2570
// tmp := tmp ^ Bobby ;
2554: LD_ADDR_VAR 0 5
2558: PUSH
2559: LD_VAR 0 5
2563: PUSH
2564: LD_EXP 23
2568: ADD
2569: ST_TO_ADDR
// end ; if not Cyrus then
2570: LD_EXP 24
2574: NOT
2575: IFFALSE 2621
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2577: LD_ADDR_EXP 24
2581: PUSH
2582: LD_STRING Cyrus
2584: PPUSH
2585: LD_EXP 1
2589: NOT
2590: PPUSH
2591: LD_STRING 13a_
2593: PPUSH
2594: CALL 52212 0 3
2598: ST_TO_ADDR
// if Cyrus then
2599: LD_EXP 24
2603: IFFALSE 2621
// tmp := tmp ^ Cyrus ;
2605: LD_ADDR_VAR 0 5
2609: PUSH
2610: LD_VAR 0 5
2614: PUSH
2615: LD_EXP 24
2619: ADD
2620: ST_TO_ADDR
// end ; if not Brown then
2621: LD_EXP 26
2625: NOT
2626: IFFALSE 2672
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2628: LD_ADDR_EXP 26
2632: PUSH
2633: LD_STRING Brown
2635: PPUSH
2636: LD_EXP 1
2640: NOT
2641: PPUSH
2642: LD_STRING 13a_
2644: PPUSH
2645: CALL 52212 0 3
2649: ST_TO_ADDR
// if Brown then
2650: LD_EXP 26
2654: IFFALSE 2672
// tmp := tmp ^ Brown ;
2656: LD_ADDR_VAR 0 5
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_EXP 26
2670: ADD
2671: ST_TO_ADDR
// end ; if not Gladstone then
2672: LD_EXP 27
2676: NOT
2677: IFFALSE 2723
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2679: LD_ADDR_EXP 27
2683: PUSH
2684: LD_STRING Gladstone
2686: PPUSH
2687: LD_EXP 1
2691: NOT
2692: PPUSH
2693: LD_STRING 13a_
2695: PPUSH
2696: CALL 52212 0 3
2700: ST_TO_ADDR
// if Gladstone then
2701: LD_EXP 27
2705: IFFALSE 2723
// tmp := tmp ^ Gladstone ;
2707: LD_ADDR_VAR 0 5
2711: PUSH
2712: LD_VAR 0 5
2716: PUSH
2717: LD_EXP 27
2721: ADD
2722: ST_TO_ADDR
// end ; if not Cornel then
2723: LD_EXP 29
2727: NOT
2728: IFFALSE 2774
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2730: LD_ADDR_EXP 29
2734: PUSH
2735: LD_STRING Cornel
2737: PPUSH
2738: LD_EXP 1
2742: NOT
2743: PPUSH
2744: LD_STRING 13a_
2746: PPUSH
2747: CALL 52212 0 3
2751: ST_TO_ADDR
// if Cornel then
2752: LD_EXP 29
2756: IFFALSE 2774
// tmp := tmp ^ Cornel ;
2758: LD_ADDR_VAR 0 5
2762: PUSH
2763: LD_VAR 0 5
2767: PUSH
2768: LD_EXP 29
2772: ADD
2773: ST_TO_ADDR
// end ; if not Houten then
2774: LD_EXP 28
2778: NOT
2779: IFFALSE 2825
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2781: LD_ADDR_EXP 28
2785: PUSH
2786: LD_STRING Houten
2788: PPUSH
2789: LD_EXP 1
2793: NOT
2794: PPUSH
2795: LD_STRING 13a_
2797: PPUSH
2798: CALL 52212 0 3
2802: ST_TO_ADDR
// if Houten then
2803: LD_EXP 28
2807: IFFALSE 2825
// tmp := tmp ^ Houten ;
2809: LD_ADDR_VAR 0 5
2813: PUSH
2814: LD_VAR 0 5
2818: PUSH
2819: LD_EXP 28
2823: ADD
2824: ST_TO_ADDR
// end ; if not Gary then
2825: LD_EXP 30
2829: NOT
2830: IFFALSE 2876
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2832: LD_ADDR_EXP 30
2836: PUSH
2837: LD_STRING Gary
2839: PPUSH
2840: LD_EXP 1
2844: NOT
2845: PPUSH
2846: LD_STRING 13a_
2848: PPUSH
2849: CALL 52212 0 3
2853: ST_TO_ADDR
// if Gary then
2854: LD_EXP 30
2858: IFFALSE 2876
// tmp := tmp ^ Gary ;
2860: LD_ADDR_VAR 0 5
2864: PUSH
2865: LD_VAR 0 5
2869: PUSH
2870: LD_EXP 30
2874: ADD
2875: ST_TO_ADDR
// end ; if not Kikuchi then
2876: LD_EXP 32
2880: NOT
2881: IFFALSE 2927
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2883: LD_ADDR_EXP 32
2887: PUSH
2888: LD_STRING Kikuchi
2890: PPUSH
2891: LD_EXP 1
2895: NOT
2896: PPUSH
2897: LD_STRING 13a_
2899: PPUSH
2900: CALL 52212 0 3
2904: ST_TO_ADDR
// if Kikuchi then
2905: LD_EXP 32
2909: IFFALSE 2927
// tmp := tmp ^ Kikuchi ;
2911: LD_ADDR_VAR 0 5
2915: PUSH
2916: LD_VAR 0 5
2920: PUSH
2921: LD_EXP 32
2925: ADD
2926: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2927: LD_ADDR_VAR 0 5
2931: PUSH
2932: LD_VAR 0 5
2936: PUSH
2937: LD_STRING 13a_others
2939: PPUSH
2940: CALL_OW 31
2944: UNION
2945: ST_TO_ADDR
// tmp := tmp diff 0 ;
2946: LD_ADDR_VAR 0 5
2950: PUSH
2951: LD_VAR 0 5
2955: PUSH
2956: LD_INT 0
2958: DIFF
2959: ST_TO_ADDR
// if tmp < 15 then
2960: LD_VAR 0 5
2964: PUSH
2965: LD_INT 15
2967: LESS
2968: IFFALSE 3056
// for i = 15 downto tmp do
2970: LD_ADDR_VAR 0 2
2974: PUSH
2975: DOUBLE
2976: LD_INT 15
2978: INC
2979: ST_TO_ADDR
2980: LD_VAR 0 5
2984: PUSH
2985: FOR_DOWNTO
2986: IFFALSE 3054
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2988: LD_ADDR_OWVAR 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: PUSH
3003: LD_INT 1
3005: PPUSH
3006: LD_INT 2
3008: PPUSH
3009: CALL_OW 12
3013: ARRAY
3014: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3015: LD_INT 0
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: LD_INT 4
3023: PPUSH
3024: CALL_OW 12
3028: PPUSH
3029: LD_INT 8
3031: PPUSH
3032: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3036: LD_ADDR_VAR 0 5
3040: PUSH
3041: LD_VAR 0 5
3045: PUSH
3046: CALL_OW 44
3050: ADD
3051: ST_TO_ADDR
// end ;
3052: GO 2985
3054: POP
3055: POP
// if not debug then
3056: LD_EXP 1
3060: NOT
3061: IFFALSE 3241
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3063: LD_ADDR_VAR 0 4
3067: PUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_INT 14
3073: PUSH
3074: LD_INT 13
3076: PUSH
3077: LD_INT 12
3079: PUSH
3080: LD_INT 11
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: LD_OWVAR 67
3093: ARRAY
3094: PPUSH
3095: LD_INT 14
3097: PUSH
3098: LD_INT 13
3100: PUSH
3101: LD_INT 12
3103: PUSH
3104: LD_INT 11
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: LD_INT -5
3121: PUSH
3122: LD_EXP 19
3126: PUSH
3127: LD_EXP 52
3131: PUSH
3132: LD_EXP 20
3136: PUSH
3137: LD_EXP 34
3141: PUSH
3142: LD_EXP 25
3146: PUSH
3147: LD_EXP 38
3151: PUSH
3152: LD_INT -2
3154: PUSH
3155: LD_INT -3
3157: PUSH
3158: LD_INT -5
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: PUSH
3173: LD_VAR 0 5
3177: ADD
3178: PPUSH
3179: LD_INT 1
3181: PUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 1
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 3
3197: PUSH
3198: LD_INT 5
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 9
3214: PUSH
3215: LD_INT 0
3217: PUSH
3218: LD_INT 3
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: PPUSH
3234: CALL_OW 42
3238: ST_TO_ADDR
3239: GO 3290
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3241: LD_ADDR_VAR 0 4
3245: PUSH
3246: LD_EXP 40
3250: PUSH
3251: LD_EXP 41
3255: PUSH
3256: LD_EXP 42
3260: PUSH
3261: LD_EXP 43
3265: PUSH
3266: LD_EXP 44
3270: PUSH
3271: LD_EXP 45
3275: PUSH
3276: LD_EXP 46
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3290: LD_ADDR_EXP 17
3294: PUSH
3295: LD_VAR 0 5
3299: PUSH
3300: LD_VAR 0 4
3304: DIFF
3305: ST_TO_ADDR
// uc_nation := 1 ;
3306: LD_ADDR_OWVAR 21
3310: PUSH
3311: LD_INT 1
3313: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3314: LD_INT 5
3316: PPUSH
3317: LD_INT 3
3319: PPUSH
3320: LD_INT 1
3322: PPUSH
3323: LD_INT 6
3325: PPUSH
3326: LD_INT 100
3328: PPUSH
3329: CALL 57052 0 5
// veh := CreateVehicle ;
3333: LD_ADDR_VAR 0 3
3337: PUSH
3338: CALL_OW 45
3342: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3343: LD_VAR 0 3
3347: PPUSH
3348: LD_INT 7
3350: NEG
3351: PPUSH
3352: CALL_OW 242
// SetDir ( veh , 3 ) ;
3356: LD_VAR 0 3
3360: PPUSH
3361: LD_INT 3
3363: PPUSH
3364: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3368: LD_VAR 0 3
3372: PPUSH
3373: LD_INT 31
3375: PPUSH
3376: LD_INT 0
3378: PPUSH
3379: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3383: LD_EXP 19
3387: PPUSH
3388: LD_VAR 0 3
3392: PPUSH
3393: CALL_OW 52
// if Joan then
3397: LD_EXP 34
3401: IFFALSE 3473
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3403: LD_INT 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: LD_INT 1
3411: PPUSH
3412: LD_INT 11
3414: PPUSH
3415: LD_INT 100
3417: PPUSH
3418: CALL 57052 0 5
// veh := CreateVehicle ;
3422: LD_ADDR_VAR 0 3
3426: PUSH
3427: CALL_OW 45
3431: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3432: LD_VAR 0 3
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3444: LD_VAR 0 3
3448: PPUSH
3449: LD_INT 30
3451: PPUSH
3452: LD_INT 0
3454: PPUSH
3455: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3459: LD_EXP 34
3463: PPUSH
3464: LD_VAR 0 3
3468: PPUSH
3469: CALL_OW 52
// end ; if Roth then
3473: LD_EXP 20
3477: IFFALSE 3549
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3479: LD_INT 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: LD_INT 11
3490: PPUSH
3491: LD_INT 100
3493: PPUSH
3494: CALL 57052 0 5
// veh := CreateVehicle ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: CALL_OW 45
3507: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3508: LD_VAR 0 3
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3520: LD_VAR 0 3
3524: PPUSH
3525: LD_INT 30
3527: PPUSH
3528: LD_INT 0
3530: PPUSH
3531: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3535: LD_EXP 20
3539: PPUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: CALL_OW 52
// end ; if Denis then
3549: LD_EXP 25
3553: IFFALSE 3625
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3555: LD_INT 5
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: LD_INT 1
3563: PPUSH
3564: LD_INT 9
3566: PPUSH
3567: LD_INT 100
3569: PPUSH
3570: CALL 57052 0 5
// veh := CreateVehicle ;
3574: LD_ADDR_VAR 0 3
3578: PUSH
3579: CALL_OW 45
3583: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3584: LD_VAR 0 3
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3596: LD_VAR 0 3
3600: PPUSH
3601: LD_INT 30
3603: PPUSH
3604: LD_INT 0
3606: PPUSH
3607: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3611: LD_EXP 25
3615: PPUSH
3616: LD_VAR 0 3
3620: PPUSH
3621: CALL_OW 52
// end ; uc_nation := 3 ;
3625: LD_ADDR_OWVAR 21
3629: PUSH
3630: LD_INT 3
3632: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3633: LD_INT 22
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: LD_INT 1
3641: PPUSH
3642: LD_INT 45
3644: PPUSH
3645: LD_INT 100
3647: PPUSH
3648: CALL 57052 0 5
// veh := CreateVehicle ;
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: CALL_OW 45
3661: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3662: LD_VAR 0 3
3666: PPUSH
3667: LD_INT 7
3669: NEG
3670: PPUSH
3671: CALL_OW 242
// SetDir ( veh , 3 ) ;
3675: LD_VAR 0 3
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3687: LD_VAR 0 3
3691: PPUSH
3692: LD_INT 31
3694: PPUSH
3695: LD_INT 0
3697: PPUSH
3698: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3702: LD_EXP 52
3706: PPUSH
3707: LD_VAR 0 3
3711: PPUSH
3712: CALL_OW 52
// if Gossudarov then
3716: LD_EXP 38
3720: IFFALSE 3807
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3722: LD_INT 22
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: LD_INT 51
3733: PPUSH
3734: LD_INT 100
3736: PPUSH
3737: CALL 57052 0 5
// veh := CreateVehicle ;
3741: LD_ADDR_VAR 0 3
3745: PUSH
3746: CALL_OW 45
3750: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3751: LD_VAR 0 3
3755: PPUSH
3756: LD_INT 3
3758: PPUSH
3759: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3763: LD_VAR 0 3
3767: PPUSH
3768: LD_INT 30
3770: PPUSH
3771: LD_INT 0
3773: PPUSH
3774: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3778: LD_EXP 38
3782: PPUSH
3783: LD_VAR 0 3
3787: PPUSH
3788: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3792: LD_VAR 0 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL_OW 290
// end ; if Mike then
3807: LD_EXP 37
3811: IFFALSE 3828
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3813: LD_EXP 37
3817: PPUSH
3818: LD_INT 30
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 49
// for i in selected do
3828: LD_ADDR_VAR 0 2
3832: PUSH
3833: LD_VAR 0 4
3837: PUSH
3838: FOR_IN
3839: IFFALSE 4397
// begin uc_nation := GetNation ( i ) ;
3841: LD_ADDR_OWVAR 21
3845: PUSH
3846: LD_VAR 0 2
3850: PPUSH
3851: CALL_OW 248
3855: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3856: LD_VAR 0 2
3860: PUSH
3861: LD_EXP 21
3865: PUSH
3866: LD_EXP 22
3870: PUSH
3871: LD_EXP 24
3875: PUSH
3876: LD_EXP 23
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: IN
3887: IFFALSE 3910
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3889: LD_INT 5
3891: PPUSH
3892: LD_INT 3
3894: PPUSH
3895: LD_INT 1
3897: PPUSH
3898: LD_INT 6
3900: PPUSH
3901: LD_INT 100
3903: PPUSH
3904: CALL 57052 0 5
3908: GO 4344
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3910: LD_VAR 0 2
3914: PUSH
3915: LD_EXP 45
3919: PUSH
3920: LD_EXP 50
3924: PUSH
3925: LD_EXP 48
3929: PUSH
3930: LD_EXP 40
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: IN
3941: IFFALSE 3972
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3943: LD_INT 24
3945: PPUSH
3946: LD_INT 1
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: LD_INT 46
3954: PPUSH
3955: LD_INT 65
3957: PPUSH
3958: LD_INT 75
3960: PPUSH
3961: CALL_OW 12
3965: PPUSH
3966: CALL 57052 0 5
3970: GO 4344
// if i = Karamazov then
3972: LD_VAR 0 2
3976: PUSH
3977: LD_EXP 51
3981: EQUAL
3982: IFFALSE 4005
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3984: LD_INT 22
3986: PPUSH
3987: LD_INT 3
3989: PPUSH
3990: LD_INT 1
3992: PPUSH
3993: LD_INT 52
3995: PPUSH
3996: LD_INT 100
3998: PPUSH
3999: CALL 57052 0 5
4003: GO 4344
// if i = Brown then
4005: LD_VAR 0 2
4009: PUSH
4010: LD_EXP 26
4014: EQUAL
4015: IFFALSE 4038
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4017: LD_INT 3
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 1
4025: PPUSH
4026: LD_INT 13
4028: PPUSH
4029: LD_INT 100
4031: PPUSH
4032: CALL 57052 0 5
4036: GO 4344
// if uc_nation = nation_american then
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 1
4045: EQUAL
4046: IFFALSE 4197
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4048: LD_INT 3
4050: PUSH
4051: LD_INT 5
4053: PUSH
4054: LD_INT 5
4056: PUSH
4057: EMPTY
4058: LIST
4059: LIST
4060: LIST
4061: PUSH
4062: LD_OWVAR 21
4066: PUSH
4067: LD_INT 3
4069: MOD
4070: PUSH
4071: LD_INT 1
4073: PLUS
4074: ARRAY
4075: PPUSH
4076: LD_INT 1
4078: PUSH
4079: LD_INT 3
4081: PUSH
4082: LD_INT 1
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PUSH
4090: LD_OWVAR 21
4094: PUSH
4095: LD_INT 3
4097: MOD
4098: PUSH
4099: LD_INT 1
4101: PLUS
4102: ARRAY
4103: PPUSH
4104: LD_INT 1
4106: PPUSH
4107: LD_INT 11
4109: PUSH
4110: LD_INT 4
4112: PUSH
4113: LD_INT 5
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: LD_INT 6
4123: PUSH
4124: LD_INT 7
4126: PUSH
4127: LD_INT 9
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: PUSH
4135: LD_INT 6
4137: PUSH
4138: LD_INT 9
4140: PUSH
4141: LD_INT 12
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: LIST
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: LD_OWVAR 21
4158: PUSH
4159: LD_INT 3
4161: MOD
4162: PUSH
4163: LD_INT 1
4165: PLUS
4166: ARRAY
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 3
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 65
4182: PPUSH
4183: LD_INT 75
4185: PPUSH
4186: CALL_OW 12
4190: PPUSH
4191: CALL 57052 0 5
// end else
4195: GO 4344
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4197: LD_INT 22
4199: PUSH
4200: LD_INT 23
4202: PUSH
4203: LD_INT 23
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: PUSH
4211: LD_OWVAR 21
4215: PUSH
4216: LD_INT 3
4218: MOD
4219: PUSH
4220: LD_INT 1
4222: PLUS
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PUSH
4228: LD_INT 3
4230: PUSH
4231: LD_INT 1
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: LIST
4238: PUSH
4239: LD_OWVAR 21
4243: PUSH
4244: LD_INT 3
4246: MOD
4247: PUSH
4248: LD_INT 1
4250: PLUS
4251: ARRAY
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 43
4261: PUSH
4262: LD_INT 44
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 46
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 44
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 46
4286: PUSH
4287: LD_INT 43
4289: PUSH
4290: LD_INT 45
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: LIST
4302: PUSH
4303: LD_OWVAR 21
4307: PUSH
4308: LD_INT 3
4310: MOD
4311: PUSH
4312: LD_INT 1
4314: PLUS
4315: ARRAY
4316: PUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 3
4322: PPUSH
4323: CALL_OW 12
4327: ARRAY
4328: PPUSH
4329: LD_INT 65
4331: PPUSH
4332: LD_INT 75
4334: PPUSH
4335: CALL_OW 12
4339: PPUSH
4340: CALL 57052 0 5
// end ; veh := CreateVehicle ;
4344: LD_ADDR_VAR 0 3
4348: PUSH
4349: CALL_OW 45
4353: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4354: LD_VAR 0 3
4358: PPUSH
4359: LD_INT 3
4361: PPUSH
4362: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4366: LD_VAR 0 3
4370: PPUSH
4371: LD_INT 30
4373: PPUSH
4374: LD_INT 0
4376: PPUSH
4377: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 3
4390: PPUSH
4391: CALL_OW 52
// end ;
4395: GO 3838
4397: POP
4398: POP
// if artifactArCaptured then
4399: LD_EXP 9
4403: IFFALSE 4489
// begin uc_nation := nation_american ;
4405: LD_ADDR_OWVAR 21
4409: PUSH
4410: LD_INT 1
4412: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4413: LD_INT 3
4415: PPUSH
4416: LD_INT 3
4418: PPUSH
4419: LD_INT 3
4421: PPUSH
4422: LD_INT 12
4424: PPUSH
4425: LD_INT 100
4427: PPUSH
4428: CALL 57052 0 5
// veh := CreateVehicle ;
4432: LD_ADDR_VAR 0 3
4436: PUSH
4437: CALL_OW 45
4441: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4442: LD_VAR 0 3
4446: PPUSH
4447: LD_INT 3
4449: PPUSH
4450: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4454: LD_VAR 0 3
4458: PPUSH
4459: LD_INT 198
4461: PPUSH
4462: LD_INT 22
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 4
4479: PPUSH
4480: LD_INT 50
4482: PPUSH
4483: CALL_OW 290
// end else
4487: GO 4508
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4489: LD_INT 4
4491: PPUSH
4492: LD_INT 5
4494: PPUSH
4495: LD_INT 267
4497: PPUSH
4498: LD_INT 226
4500: PPUSH
4501: LD_INT 0
4503: PPUSH
4504: CALL_OW 58
// end ; uc_nation := nation_american ;
4508: LD_ADDR_OWVAR 21
4512: PUSH
4513: LD_INT 1
4515: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4516: LD_INT 3
4518: PPUSH
4519: LD_INT 3
4521: PPUSH
4522: LD_INT 3
4524: PPUSH
4525: LD_INT 12
4527: PPUSH
4528: LD_INT 100
4530: PPUSH
4531: CALL 57052 0 5
// veh := CreateVehicle ;
4535: LD_ADDR_VAR 0 3
4539: PUSH
4540: CALL_OW 45
4544: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4545: LD_VAR 0 3
4549: PPUSH
4550: LD_INT 3
4552: PPUSH
4553: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4557: LD_VAR 0 3
4561: PPUSH
4562: LD_INT 218
4564: PPUSH
4565: LD_INT 23
4567: PPUSH
4568: LD_INT 0
4570: PPUSH
4571: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 4
4582: PPUSH
4583: LD_INT 30
4585: PPUSH
4586: CALL_OW 290
// uc_nation := nation_russian ;
4590: LD_ADDR_OWVAR 21
4594: PUSH
4595: LD_INT 3
4597: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4598: LD_INT 22
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: LD_INT 3
4606: PPUSH
4607: LD_INT 51
4609: PPUSH
4610: LD_INT 100
4612: PPUSH
4613: CALL 57052 0 5
// veh := CreateVehicle ;
4617: LD_ADDR_VAR 0 3
4621: PUSH
4622: CALL_OW 45
4626: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4627: LD_VAR 0 3
4631: PPUSH
4632: LD_INT 3
4634: PPUSH
4635: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4639: LD_VAR 0 3
4643: PPUSH
4644: LD_INT 214
4646: PPUSH
4647: LD_INT 20
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4657: LD_VAR 0 3
4661: PPUSH
4662: LD_INT 4
4664: PPUSH
4665: LD_INT 40
4667: PPUSH
4668: CALL_OW 290
// end ;
4672: LD_VAR 0 1
4676: RET
// export function AllianceSupport ; var i , veh ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if not allianceTeam then
4682: LD_EXP 17
4686: NOT
4687: IFFALSE 4691
// exit ;
4689: GO 5097
// for i := 1 to 6 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 6
4703: PUSH
4704: FOR_TO
4705: IFFALSE 5001
// begin uc_side := 7 ;
4707: LD_ADDR_OWVAR 20
4711: PUSH
4712: LD_INT 7
4714: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4715: LD_ADDR_OWVAR 21
4719: PUSH
4720: LD_INT 1
4722: PUSH
4723: LD_INT 3
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_VAR 0 2
4734: PUSH
4735: LD_INT 2
4737: MOD
4738: PUSH
4739: LD_INT 1
4741: PLUS
4742: ARRAY
4743: ST_TO_ADDR
// if uc_nation = 1 then
4744: LD_OWVAR 21
4748: PUSH
4749: LD_INT 1
4751: EQUAL
4752: IFFALSE 4794
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4754: LD_INT 5
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 1
4762: PPUSH
4763: LD_INT 6
4765: PUSH
4766: LD_INT 7
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 2
4778: PPUSH
4779: CALL_OW 12
4783: ARRAY
4784: PPUSH
4785: LD_INT 100
4787: PPUSH
4788: CALL 57052 0 5
4792: GO 4832
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4794: LD_INT 23
4796: PPUSH
4797: LD_INT 3
4799: PPUSH
4800: LD_INT 1
4802: PPUSH
4803: LD_INT 46
4805: PUSH
4806: LD_INT 47
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: PUSH
4813: LD_INT 1
4815: PPUSH
4816: LD_INT 2
4818: PPUSH
4819: CALL_OW 12
4823: ARRAY
4824: PPUSH
4825: LD_INT 100
4827: PPUSH
4828: CALL 57052 0 5
// if not allianceTeam then
4832: LD_EXP 17
4836: NOT
4837: IFFALSE 4841
// break ;
4839: GO 5001
// veh := CreateVehicle ;
4841: LD_ADDR_VAR 0 3
4845: PUSH
4846: CALL_OW 45
4850: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4851: LD_VAR 0 3
4855: PPUSH
4856: LD_INT 4
4858: PPUSH
4859: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4863: LD_VAR 0 3
4867: PPUSH
4868: LD_INT 38
4870: PPUSH
4871: LD_INT 0
4873: PPUSH
4874: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4878: LD_EXP 17
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: LD_INT 3
4889: PPUSH
4890: CALL_OW 259
4894: PUSH
4895: LD_INT 4
4897: GREATER
4898: IFFALSE 4916
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4900: LD_EXP 17
4904: PUSH
4905: LD_INT 1
4907: ARRAY
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4916: LD_EXP 17
4920: PUSH
4921: LD_INT 1
4923: ARRAY
4924: PPUSH
4925: LD_INT 4
4927: PPUSH
4928: CALL_OW 259
4932: PUSH
4933: LD_INT 8
4935: GREATER
4936: IFFALSE 4954
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4938: LD_EXP 17
4942: PUSH
4943: LD_INT 1
4945: ARRAY
4946: PPUSH
4947: LD_INT 4
4949: PPUSH
4950: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4954: LD_EXP 17
4958: PUSH
4959: LD_INT 1
4961: ARRAY
4962: PPUSH
4963: LD_VAR 0 3
4967: PPUSH
4968: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4972: LD_ADDR_EXP 17
4976: PUSH
4977: LD_EXP 17
4981: PPUSH
4982: LD_INT 1
4984: PPUSH
4985: CALL_OW 3
4989: ST_TO_ADDR
// ComHold ( veh ) ;
4990: LD_VAR 0 3
4994: PPUSH
4995: CALL_OW 140
// end ;
4999: GO 4704
5001: POP
5002: POP
// uc_side := 7 ;
5003: LD_ADDR_OWVAR 20
5007: PUSH
5008: LD_INT 7
5010: ST_TO_ADDR
// uc_nation := 1 ;
5011: LD_ADDR_OWVAR 21
5015: PUSH
5016: LD_INT 1
5018: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5019: LD_INT 5
5021: PPUSH
5022: LD_INT 3
5024: PPUSH
5025: LD_INT 3
5027: PPUSH
5028: LD_INT 11
5030: PPUSH
5031: LD_INT 100
5033: PPUSH
5034: CALL 57052 0 5
// veh := CreateVehicle ;
5038: LD_ADDR_VAR 0 3
5042: PUSH
5043: CALL_OW 45
5047: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5048: LD_VAR 0 3
5052: PPUSH
5053: LD_INT 4
5055: PPUSH
5056: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 305
5067: PPUSH
5068: LD_INT 218
5070: PPUSH
5071: LD_INT 0
5073: PPUSH
5074: CALL_OW 48
// ComHold ( veh ) ;
5078: LD_VAR 0 3
5082: PPUSH
5083: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5087: LD_INT 313
5089: PPUSH
5090: LD_INT 220
5092: PPUSH
5093: CALL_OW 86
// end ; end_of_file
5097: LD_VAR 0 1
5101: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5102: LD_INT 0
5104: PPUSH
5105: PPUSH
5106: PPUSH
5107: PPUSH
5108: PPUSH
5109: PPUSH
5110: PPUSH
5111: PPUSH
5112: PPUSH
5113: PPUSH
// InitHc ;
5114: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5118: LD_INT 387
5120: PPUSH
5121: LD_STRING sigma
5123: PPUSH
5124: CALL_OW 500
// uc_side := 1 ;
5128: LD_ADDR_OWVAR 20
5132: PUSH
5133: LD_INT 1
5135: ST_TO_ADDR
// uc_nation := 1 ;
5136: LD_ADDR_OWVAR 21
5140: PUSH
5141: LD_INT 1
5143: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5144: LD_ADDR_VAR 0 2
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_INT 1
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 21
5161: PUSH
5162: LD_INT 3
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PPUSH
5173: CALL_OW 69
5177: PUSH
5178: FOR_IN
5179: IFFALSE 5195
// SetBLevel ( i , 10 ) ;
5181: LD_VAR 0 2
5185: PPUSH
5186: LD_INT 10
5188: PPUSH
5189: CALL_OW 241
5193: GO 5178
5195: POP
5196: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5197: LD_INT 387
5199: PPUSH
5200: CALL_OW 274
5204: PPUSH
5205: LD_INT 1
5207: PPUSH
5208: LD_INT 7500
5210: PPUSH
5211: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5215: LD_INT 387
5217: PPUSH
5218: CALL_OW 274
5222: PPUSH
5223: LD_INT 2
5225: PPUSH
5226: LD_INT 4000
5228: PPUSH
5229: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5233: LD_INT 387
5235: PPUSH
5236: CALL_OW 274
5240: PPUSH
5241: LD_INT 3
5243: PPUSH
5244: LD_INT 50
5246: PPUSH
5247: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5251: LD_INT 476
5253: PPUSH
5254: CALL_OW 274
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: LD_INT 5500
5264: PPUSH
5265: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5269: LD_INT 476
5271: PPUSH
5272: CALL_OW 274
5276: PPUSH
5277: LD_INT 2
5279: PPUSH
5280: LD_INT 4000
5282: PPUSH
5283: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5287: LD_INT 476
5289: PPUSH
5290: CALL_OW 274
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 10
5300: PPUSH
5301: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5305: LD_ADDR_EXP 55
5309: PUSH
5310: LD_STRING Powell
5312: PPUSH
5313: CALL_OW 25
5317: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5318: LD_EXP 55
5322: PPUSH
5323: LD_INT 387
5325: PPUSH
5326: CALL_OW 52
// tmp := [ ] ;
5330: LD_ADDR_VAR 0 6
5334: PUSH
5335: EMPTY
5336: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5337: LD_ADDR_EXP 21
5341: PUSH
5342: LD_STRING Lisa
5344: PPUSH
5345: LD_EXP 1
5349: NOT
5350: PPUSH
5351: LD_STRING 12p_
5353: PPUSH
5354: CALL 52212 0 3
5358: ST_TO_ADDR
// if Lisa then
5359: LD_EXP 21
5363: IFFALSE 5381
// tmp := tmp ^ Lisa ;
5365: LD_ADDR_VAR 0 6
5369: PUSH
5370: LD_VAR 0 6
5374: PUSH
5375: LD_EXP 21
5379: ADD
5380: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5381: LD_ADDR_EXP 22
5385: PUSH
5386: LD_STRING Donaldson
5388: PPUSH
5389: LD_EXP 1
5393: NOT
5394: PPUSH
5395: LD_STRING 12p_
5397: PPUSH
5398: CALL 52212 0 3
5402: ST_TO_ADDR
// if Donaldson then
5403: LD_EXP 22
5407: IFFALSE 5425
// tmp := tmp ^ Donaldson ;
5409: LD_ADDR_VAR 0 6
5413: PUSH
5414: LD_VAR 0 6
5418: PUSH
5419: LD_EXP 22
5423: ADD
5424: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5425: LD_ADDR_EXP 23
5429: PUSH
5430: LD_STRING Bobby
5432: PPUSH
5433: LD_EXP 1
5437: NOT
5438: PPUSH
5439: LD_STRING 12p_
5441: PPUSH
5442: CALL 52212 0 3
5446: ST_TO_ADDR
// if Bobby then
5447: LD_EXP 23
5451: IFFALSE 5469
// tmp := tmp ^ Bobby ;
5453: LD_ADDR_VAR 0 6
5457: PUSH
5458: LD_VAR 0 6
5462: PUSH
5463: LD_EXP 23
5467: ADD
5468: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5469: LD_ADDR_EXP 24
5473: PUSH
5474: LD_STRING Cyrus
5476: PPUSH
5477: LD_EXP 1
5481: NOT
5482: PPUSH
5483: LD_STRING 12p_
5485: PPUSH
5486: CALL 52212 0 3
5490: ST_TO_ADDR
// if Cyrus then
5491: LD_EXP 24
5495: IFFALSE 5513
// tmp := tmp ^ Cyrus ;
5497: LD_ADDR_VAR 0 6
5501: PUSH
5502: LD_VAR 0 6
5506: PUSH
5507: LD_EXP 24
5511: ADD
5512: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5513: LD_ADDR_EXP 26
5517: PUSH
5518: LD_STRING Brown
5520: PPUSH
5521: LD_EXP 1
5525: NOT
5526: PPUSH
5527: LD_STRING 12p_
5529: PPUSH
5530: CALL 52212 0 3
5534: ST_TO_ADDR
// if Brown then
5535: LD_EXP 26
5539: IFFALSE 5557
// tmp := tmp ^ Brown ;
5541: LD_ADDR_VAR 0 6
5545: PUSH
5546: LD_VAR 0 6
5550: PUSH
5551: LD_EXP 26
5555: ADD
5556: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5557: LD_ADDR_EXP 27
5561: PUSH
5562: LD_STRING Gladstone
5564: PPUSH
5565: LD_EXP 1
5569: NOT
5570: PPUSH
5571: LD_STRING 12p_
5573: PPUSH
5574: CALL 52212 0 3
5578: ST_TO_ADDR
// if Gladstone then
5579: LD_EXP 27
5583: IFFALSE 5601
// tmp := tmp ^ Gladstone ;
5585: LD_ADDR_VAR 0 6
5589: PUSH
5590: LD_VAR 0 6
5594: PUSH
5595: LD_EXP 27
5599: ADD
5600: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5601: LD_ADDR_EXP 28
5605: PUSH
5606: LD_STRING Houten
5608: PPUSH
5609: LD_EXP 1
5613: NOT
5614: PPUSH
5615: LD_STRING 12p_
5617: PPUSH
5618: CALL 52212 0 3
5622: ST_TO_ADDR
// if Houten then
5623: LD_EXP 28
5627: IFFALSE 5645
// tmp := tmp ^ Houten ;
5629: LD_ADDR_VAR 0 6
5633: PUSH
5634: LD_VAR 0 6
5638: PUSH
5639: LD_EXP 28
5643: ADD
5644: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5645: LD_ADDR_EXP 29
5649: PUSH
5650: LD_STRING Cornel
5652: PPUSH
5653: LD_EXP 1
5657: NOT
5658: PPUSH
5659: LD_STRING 12p_
5661: PPUSH
5662: CALL 52212 0 3
5666: ST_TO_ADDR
// if Cornel then
5667: LD_EXP 29
5671: IFFALSE 5689
// tmp := tmp ^ Cornel ;
5673: LD_ADDR_VAR 0 6
5677: PUSH
5678: LD_VAR 0 6
5682: PUSH
5683: LD_EXP 29
5687: ADD
5688: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5689: LD_ADDR_EXP 30
5693: PUSH
5694: LD_STRING Gary
5696: PPUSH
5697: LD_EXP 1
5701: NOT
5702: PPUSH
5703: LD_STRING 12p_
5705: PPUSH
5706: CALL 52212 0 3
5710: ST_TO_ADDR
// if Gary then
5711: LD_EXP 30
5715: IFFALSE 5733
// tmp := tmp ^ Gary ;
5717: LD_ADDR_VAR 0 6
5721: PUSH
5722: LD_VAR 0 6
5726: PUSH
5727: LD_EXP 30
5731: ADD
5732: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5733: LD_ADDR_EXP 32
5737: PUSH
5738: LD_STRING Kikuchi
5740: PPUSH
5741: LD_EXP 1
5745: NOT
5746: PPUSH
5747: LD_STRING 12p_
5749: PPUSH
5750: CALL 52212 0 3
5754: ST_TO_ADDR
// if Kikuchi then
5755: LD_EXP 32
5759: IFFALSE 5777
// tmp := tmp ^ Kikuchi ;
5761: LD_ADDR_VAR 0 6
5765: PUSH
5766: LD_VAR 0 6
5770: PUSH
5771: LD_EXP 32
5775: ADD
5776: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5777: LD_ADDR_VAR 0 6
5781: PUSH
5782: LD_VAR 0 6
5786: PUSH
5787: LD_STRING 12p_others
5789: PPUSH
5790: CALL_OW 31
5794: UNION
5795: ST_TO_ADDR
// if tmp < 36 then
5796: LD_VAR 0 6
5800: PUSH
5801: LD_INT 36
5803: LESS
5804: IFFALSE 5871
// for i = 1 to 36 - tmp do
5806: LD_ADDR_VAR 0 2
5810: PUSH
5811: DOUBLE
5812: LD_INT 1
5814: DEC
5815: ST_TO_ADDR
5816: LD_INT 36
5818: PUSH
5819: LD_VAR 0 6
5823: MINUS
5824: PUSH
5825: FOR_TO
5826: IFFALSE 5869
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5828: LD_INT 1
5830: PPUSH
5831: LD_VAR 0 2
5835: PUSH
5836: LD_INT 4
5838: MOD
5839: PUSH
5840: LD_INT 1
5842: PLUS
5843: PPUSH
5844: LD_INT 10
5846: PPUSH
5847: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5851: LD_ADDR_VAR 0 6
5855: PUSH
5856: LD_VAR 0 6
5860: PUSH
5861: CALL_OW 44
5865: ADD
5866: ST_TO_ADDR
// end ;
5867: GO 5825
5869: POP
5870: POP
// for i in tmp do
5871: LD_ADDR_VAR 0 2
5875: PUSH
5876: LD_VAR 0 6
5880: PUSH
5881: FOR_IN
5882: IFFALSE 5907
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5884: LD_VAR 0 2
5888: PPUSH
5889: LD_INT 62
5891: PPUSH
5892: LD_INT 93
5894: PPUSH
5895: LD_INT 9
5897: PPUSH
5898: LD_INT 0
5900: PPUSH
5901: CALL_OW 50
5905: GO 5881
5907: POP
5908: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5909: LD_ADDR_EXP 78
5913: PUSH
5914: LD_EXP 78
5918: PPUSH
5919: LD_INT 4
5921: PPUSH
5922: LD_INT 22
5924: PUSH
5925: LD_INT 1
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 69
5936: PUSH
5937: LD_EXP 55
5941: DIFF
5942: PPUSH
5943: CALL_OW 1
5947: ST_TO_ADDR
// uc_side := 0 ;
5948: LD_ADDR_OWVAR 20
5952: PUSH
5953: LD_INT 0
5955: ST_TO_ADDR
// uc_nation := 0 ;
5956: LD_ADDR_OWVAR 21
5960: PUSH
5961: LD_INT 0
5963: ST_TO_ADDR
// for i = 1 to 4 do
5964: LD_ADDR_VAR 0 2
5968: PUSH
5969: DOUBLE
5970: LD_INT 1
5972: DEC
5973: ST_TO_ADDR
5974: LD_INT 4
5976: PUSH
5977: FOR_TO
5978: IFFALSE 6009
// begin InitHc ;
5980: CALL_OW 19
// hc_class := class_apeman ;
5984: LD_ADDR_OWVAR 28
5988: PUSH
5989: LD_INT 12
5991: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5992: CALL_OW 44
5996: PPUSH
5997: LD_INT 11
5999: PPUSH
6000: LD_INT 0
6002: PPUSH
6003: CALL_OW 49
// end ;
6007: GO 5977
6009: POP
6010: POP
// end ;
6011: LD_VAR 0 1
6015: RET
// every 9 9$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target ;
6016: LD_EXP 4
6020: NOT
6021: IFFALSE 6793
6023: GO 6025
6025: DISABLE
6026: LD_INT 0
6028: PPUSH
6029: PPUSH
6030: PPUSH
// begin enable ;
6031: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6032: LD_INT 22
6034: PUSH
6035: LD_INT 1
6037: PUSH
6038: EMPTY
6039: LIST
6040: LIST
6041: PUSH
6042: LD_INT 23
6044: PUSH
6045: LD_INT 1
6047: PUSH
6048: EMPTY
6049: LIST
6050: LIST
6051: PUSH
6052: LD_INT 30
6054: PUSH
6055: LD_INT 3
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: PPUSH
6067: CALL_OW 69
6071: NOT
6072: IFFALSE 6076
// exit ;
6074: GO 6793
// if Prob ( 40 ) then
6076: LD_INT 40
6078: PPUSH
6079: CALL_OW 13
6083: IFFALSE 6210
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6085: LD_INT 4
6087: PPUSH
6088: LD_INT 5
6090: PUSH
6091: LD_INT 1
6093: PUSH
6094: LD_INT 2
6096: PUSH
6097: LD_INT 7
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 5
6108: PUSH
6109: LD_INT 1
6111: PUSH
6112: LD_INT 2
6114: PUSH
6115: LD_INT 7
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: PUSH
6124: LD_INT 5
6126: PUSH
6127: LD_INT 1
6129: PUSH
6130: LD_INT 2
6132: PUSH
6133: LD_INT 7
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: PUSH
6142: LD_INT 5
6144: PUSH
6145: LD_INT 1
6147: PUSH
6148: LD_INT 2
6150: PUSH
6151: LD_INT 6
6153: PUSH
6154: EMPTY
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: PUSH
6160: LD_INT 5
6162: PUSH
6163: LD_INT 1
6165: PUSH
6166: LD_INT 2
6168: PUSH
6169: LD_INT 6
6171: PUSH
6172: EMPTY
6173: LIST
6174: LIST
6175: LIST
6176: LIST
6177: PUSH
6178: LD_INT 5
6180: PUSH
6181: LD_INT 1
6183: PUSH
6184: LD_INT 2
6186: PUSH
6187: LD_INT 6
6189: PUSH
6190: EMPTY
6191: LIST
6192: LIST
6193: LIST
6194: LIST
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: LIST
6202: LIST
6203: PPUSH
6204: CALL 45786 0 2
// end else
6208: GO 6333
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6210: LD_INT 4
6212: PPUSH
6213: LD_INT 5
6215: PUSH
6216: LD_INT 1
6218: PUSH
6219: LD_INT 2
6221: PUSH
6222: LD_INT 7
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: LIST
6229: LIST
6230: PUSH
6231: LD_INT 5
6233: PUSH
6234: LD_INT 1
6236: PUSH
6237: LD_INT 2
6239: PUSH
6240: LD_INT 9
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: LIST
6247: LIST
6248: PUSH
6249: LD_INT 5
6251: PUSH
6252: LD_INT 1
6254: PUSH
6255: LD_INT 2
6257: PUSH
6258: LD_INT 9
6260: PUSH
6261: EMPTY
6262: LIST
6263: LIST
6264: LIST
6265: LIST
6266: PUSH
6267: LD_INT 5
6269: PUSH
6270: LD_INT 1
6272: PUSH
6273: LD_INT 2
6275: PUSH
6276: LD_INT 6
6278: PUSH
6279: EMPTY
6280: LIST
6281: LIST
6282: LIST
6283: LIST
6284: PUSH
6285: LD_INT 5
6287: PUSH
6288: LD_INT 1
6290: PUSH
6291: LD_INT 2
6293: PUSH
6294: LD_INT 6
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: LIST
6301: LIST
6302: PUSH
6303: LD_INT 5
6305: PUSH
6306: LD_INT 1
6308: PUSH
6309: LD_INT 2
6311: PUSH
6312: LD_INT 6
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: LIST
6319: LIST
6320: PUSH
6321: EMPTY
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: PPUSH
6329: CALL 45786 0 2
// end ; repeat wait ( 0 0$1 ) ;
6333: LD_INT 35
6335: PPUSH
6336: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6340: LD_INT 4
6342: PPUSH
6343: LD_INT 1
6345: PPUSH
6346: CALL 47204 0 2
6350: PUSH
6351: LD_INT 6
6353: GREATEREQUAL
6354: IFFALSE 6333
// wait ( 0 0$30 ) ;
6356: LD_INT 1050
6358: PPUSH
6359: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6363: LD_ADDR_VAR 0 2
6367: PUSH
6368: LD_INT 4
6370: PPUSH
6371: LD_INT 1
6373: PPUSH
6374: CALL 47204 0 2
6378: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6379: LD_ADDR_EXP 97
6383: PUSH
6384: LD_EXP 97
6388: PPUSH
6389: LD_INT 4
6391: PPUSH
6392: LD_EXP 97
6396: PUSH
6397: LD_INT 4
6399: ARRAY
6400: PUSH
6401: LD_VAR 0 2
6405: DIFF
6406: PPUSH
6407: CALL_OW 1
6411: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6412: LD_ADDR_VAR 0 3
6416: PUSH
6417: LD_INT 0
6419: PPUSH
6420: LD_INT 2
6422: PPUSH
6423: CALL_OW 12
6427: ST_TO_ADDR
// if target then
6428: LD_VAR 0 3
6432: IFFALSE 6560
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6434: LD_ADDR_VAR 0 2
6438: PUSH
6439: LD_VAR 0 2
6443: PPUSH
6444: LD_INT 24
6446: PUSH
6447: LD_INT 250
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PPUSH
6454: CALL_OW 72
6458: ST_TO_ADDR
// for i in tmp do
6459: LD_ADDR_VAR 0 1
6463: PUSH
6464: LD_VAR 0 2
6468: PUSH
6469: FOR_IN
6470: IFFALSE 6510
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6472: LD_VAR 0 1
6476: PPUSH
6477: LD_INT 114
6479: PPUSH
6480: LD_INT 108
6482: PPUSH
6483: CALL_OW 297
6487: PUSH
6488: LD_INT 9
6490: GREATER
6491: IFFALSE 6508
// ComMoveXY ( i , 114 , 108 ) ;
6493: LD_VAR 0 1
6497: PPUSH
6498: LD_INT 114
6500: PPUSH
6501: LD_INT 108
6503: PPUSH
6504: CALL_OW 111
6508: GO 6469
6510: POP
6511: POP
// wait ( 0 0$1 ) ;
6512: LD_INT 35
6514: PPUSH
6515: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6519: LD_VAR 0 2
6523: PPUSH
6524: LD_INT 92
6526: PUSH
6527: LD_INT 114
6529: PUSH
6530: LD_INT 108
6532: PUSH
6533: LD_INT 9
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: LIST
6540: LIST
6541: PPUSH
6542: CALL_OW 72
6546: PUSH
6547: LD_VAR 0 2
6551: PUSH
6552: LD_INT 1
6554: MINUS
6555: GREATEREQUAL
6556: IFFALSE 6434
// end else
6558: GO 6684
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: LD_VAR 0 2
6569: PPUSH
6570: LD_INT 24
6572: PUSH
6573: LD_INT 250
6575: PUSH
6576: EMPTY
6577: LIST
6578: LIST
6579: PPUSH
6580: CALL_OW 72
6584: ST_TO_ADDR
// for i in tmp do
6585: LD_ADDR_VAR 0 1
6589: PUSH
6590: LD_VAR 0 2
6594: PUSH
6595: FOR_IN
6596: IFFALSE 6636
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6598: LD_VAR 0 1
6602: PPUSH
6603: LD_INT 129
6605: PPUSH
6606: LD_INT 139
6608: PPUSH
6609: CALL_OW 297
6613: PUSH
6614: LD_INT 9
6616: GREATER
6617: IFFALSE 6634
// ComMoveXY ( i , 129 , 139 ) ;
6619: LD_VAR 0 1
6623: PPUSH
6624: LD_INT 129
6626: PPUSH
6627: LD_INT 139
6629: PPUSH
6630: CALL_OW 111
6634: GO 6595
6636: POP
6637: POP
// wait ( 0 0$1 ) ;
6638: LD_INT 35
6640: PPUSH
6641: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6645: LD_VAR 0 2
6649: PPUSH
6650: LD_INT 92
6652: PUSH
6653: LD_INT 129
6655: PUSH
6656: LD_INT 139
6658: PUSH
6659: LD_INT 9
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: LIST
6666: LIST
6667: PPUSH
6668: CALL_OW 72
6672: PUSH
6673: LD_VAR 0 2
6677: PUSH
6678: LD_INT 1
6680: MINUS
6681: GREATEREQUAL
6682: IFFALSE 6560
// end ; repeat wait ( 0 0$1 ) ;
6684: LD_INT 35
6686: PPUSH
6687: CALL_OW 67
// for i in tmp do
6691: LD_ADDR_VAR 0 1
6695: PUSH
6696: LD_VAR 0 2
6700: PUSH
6701: FOR_IN
6702: IFFALSE 6784
// begin if GetLives ( i ) > 251 then
6704: LD_VAR 0 1
6708: PPUSH
6709: CALL_OW 256
6713: PUSH
6714: LD_INT 251
6716: GREATER
6717: IFFALSE 6755
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6719: LD_VAR 0 1
6723: PPUSH
6724: LD_INT 81
6726: PUSH
6727: LD_INT 1
6729: PUSH
6730: EMPTY
6731: LIST
6732: LIST
6733: PPUSH
6734: CALL_OW 69
6738: PPUSH
6739: LD_VAR 0 1
6743: PPUSH
6744: CALL_OW 74
6748: PPUSH
6749: CALL_OW 115
6753: GO 6782
// if IsDead ( i ) then
6755: LD_VAR 0 1
6759: PPUSH
6760: CALL_OW 301
6764: IFFALSE 6782
// tmp := tmp diff i ;
6766: LD_ADDR_VAR 0 2
6770: PUSH
6771: LD_VAR 0 2
6775: PUSH
6776: LD_VAR 0 1
6780: DIFF
6781: ST_TO_ADDR
// end ;
6782: GO 6701
6784: POP
6785: POP
// until not tmp ;
6786: LD_VAR 0 2
6790: NOT
6791: IFFALSE 6684
// end ;
6793: PPOPN 3
6795: END
// every 30 30$00 trigger not americanDestroyed do
6796: LD_EXP 4
6800: NOT
6801: IFFALSE 6870
6803: GO 6805
6805: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6806: LD_INT 63000
6808: PUSH
6809: LD_INT 42000
6811: PUSH
6812: LD_INT 31500
6814: PUSH
6815: LD_INT 21000
6817: PUSH
6818: EMPTY
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: PUSH
6824: LD_OWVAR 67
6828: ARRAY
6829: PPUSH
6830: CALL_OW 67
// if americanDestroyed then
6834: LD_EXP 4
6838: IFFALSE 6842
// exit ;
6840: GO 6870
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6842: LD_INT 4
6844: PPUSH
6845: LD_INT 5
6847: PUSH
6848: LD_INT 3
6850: PUSH
6851: LD_INT 1
6853: PUSH
6854: LD_INT 8
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: LIST
6861: LIST
6862: PUSH
6863: EMPTY
6864: LIST
6865: PPUSH
6866: CALL 45786 0 2
// end ; end_of_file
6870: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6871: LD_INT 0
6873: PPUSH
6874: PPUSH
6875: PPUSH
6876: PPUSH
6877: PPUSH
// side := 2 ;
6878: LD_ADDR_VAR 0 5
6882: PUSH
6883: LD_INT 2
6885: ST_TO_ADDR
// InitHc ;
6886: CALL_OW 19
// uc_side := side ;
6890: LD_ADDR_OWVAR 20
6894: PUSH
6895: LD_VAR 0 5
6899: ST_TO_ADDR
// uc_nation := 2 ;
6900: LD_ADDR_OWVAR 21
6904: PUSH
6905: LD_INT 2
6907: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6908: LD_ADDR_VAR 0 2
6912: PUSH
6913: LD_INT 22
6915: PUSH
6916: LD_INT 2
6918: PUSH
6919: EMPTY
6920: LIST
6921: LIST
6922: PUSH
6923: LD_INT 21
6925: PUSH
6926: LD_INT 3
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: PPUSH
6937: CALL_OW 69
6941: PUSH
6942: FOR_IN
6943: IFFALSE 6959
// SetBLevel ( i , 10 ) ;
6945: LD_VAR 0 2
6949: PPUSH
6950: LD_INT 10
6952: PPUSH
6953: CALL_OW 241
6957: GO 6942
6959: POP
6960: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6961: LD_ADDR_VAR 0 4
6965: PUSH
6966: LD_INT 22
6968: PUSH
6969: LD_VAR 0 5
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PUSH
6978: LD_INT 30
6980: PUSH
6981: LD_INT 32
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PUSH
6988: LD_INT 58
6990: PUSH
6991: EMPTY
6992: LIST
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: LIST
6998: PPUSH
6999: CALL_OW 69
7003: ST_TO_ADDR
// for i = 1 to 10 do
7004: LD_ADDR_VAR 0 2
7008: PUSH
7009: DOUBLE
7010: LD_INT 1
7012: DEC
7013: ST_TO_ADDR
7014: LD_INT 10
7016: PUSH
7017: FOR_TO
7018: IFFALSE 7090
// begin uc_nation := nation_nature ;
7020: LD_ADDR_OWVAR 21
7024: PUSH
7025: LD_INT 0
7027: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7028: LD_ADDR_OWVAR 28
7032: PUSH
7033: LD_INT 15
7035: ST_TO_ADDR
// hc_gallery :=  ;
7036: LD_ADDR_OWVAR 33
7040: PUSH
7041: LD_STRING 
7043: ST_TO_ADDR
// hc_name :=  ;
7044: LD_ADDR_OWVAR 26
7048: PUSH
7049: LD_STRING 
7051: ST_TO_ADDR
// un := CreateHuman ;
7052: LD_ADDR_VAR 0 3
7056: PUSH
7057: CALL_OW 44
7061: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7062: LD_VAR 0 3
7066: PPUSH
7067: LD_VAR 0 4
7071: PUSH
7072: LD_VAR 0 4
7076: PUSH
7077: LD_VAR 0 2
7081: MINUS
7082: ARRAY
7083: PPUSH
7084: CALL_OW 52
// end ;
7088: GO 7017
7090: POP
7091: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7092: LD_INT 503
7094: PPUSH
7095: LD_INT 27
7097: PPUSH
7098: LD_STRING 
7100: PPUSH
7101: LD_INT 8
7103: PUSH
7104: LD_INT 9
7106: PUSH
7107: LD_INT 10
7109: PUSH
7110: LD_INT 10
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: LIST
7117: LIST
7118: PUSH
7119: LD_OWVAR 67
7123: ARRAY
7124: PPUSH
7125: LD_INT 3000
7127: PUSH
7128: LD_INT 500
7130: PUSH
7131: LD_INT 150
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: LIST
7138: PPUSH
7139: LD_INT 16
7141: PUSH
7142: LD_INT 6
7144: PUSH
7145: LD_INT 6
7147: PUSH
7148: LD_INT 6
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL 60496 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7161: LD_ADDR_EXP 78
7165: PUSH
7166: LD_EXP 78
7170: PPUSH
7171: LD_INT 1
7173: PPUSH
7174: LD_INT 22
7176: PUSH
7177: LD_VAR 0 5
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: PUSH
7186: LD_INT 23
7188: PUSH
7189: LD_INT 2
7191: PUSH
7192: EMPTY
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 3
7198: PUSH
7199: LD_INT 21
7201: PUSH
7202: LD_INT 2
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: LIST
7217: PPUSH
7218: CALL_OW 69
7222: PPUSH
7223: CALL_OW 1
7227: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7228: LD_INT 216
7230: PPUSH
7231: LD_INT 228
7233: PPUSH
7234: LD_INT 2
7236: PPUSH
7237: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7241: LD_INT 223
7243: PPUSH
7244: LD_INT 241
7246: PPUSH
7247: LD_INT 2
7249: PPUSH
7250: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7254: LD_INT 216
7256: PPUSH
7257: LD_INT 217
7259: PPUSH
7260: LD_INT 2
7262: PPUSH
7263: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7267: LD_INT 233
7269: PPUSH
7270: LD_INT 257
7272: PPUSH
7273: LD_INT 2
7275: PPUSH
7276: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7280: LD_INT 230
7282: PPUSH
7283: LD_INT 199
7285: PPUSH
7286: LD_INT 2
7288: PPUSH
7289: CALL_OW 244
// end ;
7293: LD_VAR 0 1
7297: RET
// export Omar ; export function PrepareOmarAli ; begin
7298: LD_INT 0
7300: PPUSH
// uc_side := 5 ;
7301: LD_ADDR_OWVAR 20
7305: PUSH
7306: LD_INT 5
7308: ST_TO_ADDR
// uc_nation := 2 ;
7309: LD_ADDR_OWVAR 21
7313: PUSH
7314: LD_INT 2
7316: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7317: LD_ADDR_EXP 56
7321: PUSH
7322: LD_STRING Omar
7324: PPUSH
7325: CALL_OW 25
7329: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7330: LD_EXP 56
7334: PPUSH
7335: LD_INT 330
7337: PPUSH
7338: LD_INT 244
7340: PPUSH
7341: LD_INT 0
7343: PPUSH
7344: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7348: LD_EXP 56
7352: PPUSH
7353: LD_INT 252
7355: PPUSH
7356: LD_INT 220
7358: PPUSH
7359: CALL_OW 111
// end ; end_of_file
7363: LD_VAR 0 1
7367: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7368: LD_INT 0
7370: PPUSH
7371: PPUSH
7372: PPUSH
7373: PPUSH
7374: PPUSH
// side := 8 ;
7375: LD_ADDR_VAR 0 3
7379: PUSH
7380: LD_INT 8
7382: ST_TO_ADDR
// InitHc ;
7383: CALL_OW 19
// uc_side := side ;
7387: LD_ADDR_OWVAR 20
7391: PUSH
7392: LD_VAR 0 3
7396: ST_TO_ADDR
// uc_nation := 2 ;
7397: LD_ADDR_OWVAR 21
7401: PUSH
7402: LD_INT 2
7404: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7405: LD_ADDR_VAR 0 2
7409: PUSH
7410: LD_INT 22
7412: PUSH
7413: LD_VAR 0 3
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: PUSH
7422: LD_INT 21
7424: PUSH
7425: LD_INT 3
7427: PUSH
7428: EMPTY
7429: LIST
7430: LIST
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: PPUSH
7436: CALL_OW 69
7440: PUSH
7441: FOR_IN
7442: IFFALSE 7458
// SetBLevel ( i , 10 ) ;
7444: LD_VAR 0 2
7448: PPUSH
7449: LD_INT 10
7451: PPUSH
7452: CALL_OW 241
7456: GO 7441
7458: POP
7459: POP
// Schulz := NewCharacter ( Schulz ) ;
7460: LD_ADDR_EXP 57
7464: PUSH
7465: LD_STRING Schulz
7467: PPUSH
7468: CALL_OW 25
7472: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7473: LD_ADDR_EXP 59
7477: PUSH
7478: LD_STRING Kaia
7480: PPUSH
7481: CALL_OW 25
7485: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7486: LD_EXP 59
7490: PPUSH
7491: LD_INT 324
7493: PPUSH
7494: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7498: LD_ADDR_EXP 58
7502: PUSH
7503: LD_STRING Kozlov
7505: PPUSH
7506: LD_INT 0
7508: PPUSH
7509: LD_STRING 
7511: PPUSH
7512: CALL 52212 0 3
7516: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7517: LD_EXP 58
7521: PPUSH
7522: LD_INT 22
7524: PUSH
7525: LD_INT 8
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: PUSH
7532: LD_INT 23
7534: PUSH
7535: LD_INT 3
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 30
7544: PUSH
7545: LD_INT 8
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PPUSH
7557: CALL_OW 69
7561: PUSH
7562: LD_INT 1
7564: ARRAY
7565: PPUSH
7566: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7570: LD_EXP 58
7574: PPUSH
7575: LD_INT 3
7577: PPUSH
7578: LD_INT 10
7580: PPUSH
7581: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7585: LD_ADDR_VAR 0 5
7589: PUSH
7590: LD_INT 22
7592: PUSH
7593: LD_VAR 0 3
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 30
7604: PUSH
7605: LD_INT 32
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 58
7614: PUSH
7615: EMPTY
7616: LIST
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: LIST
7622: PPUSH
7623: CALL_OW 69
7627: ST_TO_ADDR
// for i = 1 to 10 do
7628: LD_ADDR_VAR 0 2
7632: PUSH
7633: DOUBLE
7634: LD_INT 1
7636: DEC
7637: ST_TO_ADDR
7638: LD_INT 10
7640: PUSH
7641: FOR_TO
7642: IFFALSE 7714
// begin uc_nation := nation_nature ;
7644: LD_ADDR_OWVAR 21
7648: PUSH
7649: LD_INT 0
7651: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7652: LD_ADDR_OWVAR 28
7656: PUSH
7657: LD_INT 15
7659: ST_TO_ADDR
// hc_gallery :=  ;
7660: LD_ADDR_OWVAR 33
7664: PUSH
7665: LD_STRING 
7667: ST_TO_ADDR
// hc_name :=  ;
7668: LD_ADDR_OWVAR 26
7672: PUSH
7673: LD_STRING 
7675: ST_TO_ADDR
// un := CreateHuman ;
7676: LD_ADDR_VAR 0 4
7680: PUSH
7681: CALL_OW 44
7685: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7686: LD_VAR 0 4
7690: PPUSH
7691: LD_VAR 0 5
7695: PUSH
7696: LD_VAR 0 5
7700: PUSH
7701: LD_VAR 0 2
7705: MINUS
7706: ARRAY
7707: PPUSH
7708: CALL_OW 52
// end ;
7712: GO 7641
7714: POP
7715: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7716: LD_INT 324
7718: PPUSH
7719: LD_INT 3
7721: PPUSH
7722: LD_STRING 
7724: PPUSH
7725: LD_INT 8
7727: PUSH
7728: LD_INT 9
7730: PUSH
7731: LD_INT 10
7733: PUSH
7734: LD_INT 10
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: LD_OWVAR 67
7747: ARRAY
7748: PPUSH
7749: LD_INT 3000
7751: PUSH
7752: LD_INT 500
7754: PUSH
7755: LD_INT 150
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: PPUSH
7763: LD_INT 16
7765: PUSH
7766: LD_INT 6
7768: PUSH
7769: LD_INT 6
7771: PUSH
7772: LD_INT 8
7774: PUSH
7775: EMPTY
7776: LIST
7777: LIST
7778: LIST
7779: LIST
7780: PPUSH
7781: CALL 60496 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7785: LD_ADDR_EXP 78
7789: PUSH
7790: LD_EXP 78
7794: PPUSH
7795: LD_INT 3
7797: PPUSH
7798: LD_INT 22
7800: PUSH
7801: LD_VAR 0 3
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: PUSH
7810: LD_INT 23
7812: PUSH
7813: LD_INT 2
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PUSH
7820: LD_INT 3
7822: PUSH
7823: LD_INT 21
7825: PUSH
7826: LD_INT 2
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: LIST
7841: PPUSH
7842: CALL_OW 69
7846: PUSH
7847: LD_EXP 57
7851: DIFF
7852: PPUSH
7853: CALL_OW 1
7857: ST_TO_ADDR
// end ;
7858: LD_VAR 0 1
7862: RET
// export function BuildKozlovBomb ; begin
7863: LD_INT 0
7865: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7866: LD_INT 332
7868: PPUSH
7869: CALL_OW 302
7873: NOT
7874: PUSH
7875: LD_INT 336
7877: PPUSH
7878: CALL_OW 302
7882: NOT
7883: OR
7884: IFFALSE 7888
// exit ;
7886: GO 7985
// ComChangeProfession ( Kozlov , 4 ) ;
7888: LD_EXP 58
7892: PPUSH
7893: LD_INT 4
7895: PPUSH
7896: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7900: LD_INT 336
7902: PPUSH
7903: LD_INT 25
7905: PPUSH
7906: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7910: LD_INT 35
7912: PPUSH
7913: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7917: LD_INT 25
7919: PPUSH
7920: LD_INT 8
7922: PPUSH
7923: CALL_OW 321
7927: PUSH
7928: LD_INT 2
7930: EQUAL
7931: IFFALSE 7910
// ComExitBuilding ( Kozlov ) ;
7933: LD_EXP 58
7937: PPUSH
7938: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7942: LD_EXP 58
7946: PPUSH
7947: LD_INT 332
7949: PPUSH
7950: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7954: LD_EXP 58
7958: PPUSH
7959: LD_INT 3
7961: PPUSH
7962: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7966: LD_INT 332
7968: PPUSH
7969: LD_INT 23
7971: PPUSH
7972: LD_INT 3
7974: PPUSH
7975: LD_INT 1
7977: PPUSH
7978: LD_INT 48
7980: PPUSH
7981: CALL_OW 125
// end ;
7985: LD_VAR 0 1
7989: RET
// every 9 9$30 + 7 7$00 trigger not legionDestroyed do var i , tmp , target ;
7990: LD_EXP 3
7994: NOT
7995: IFFALSE 8851
7997: GO 7999
7999: DISABLE
8000: LD_INT 0
8002: PPUSH
8003: PPUSH
8004: PPUSH
// begin enable ;
8005: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8006: LD_INT 22
8008: PUSH
8009: LD_INT 8
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 23
8018: PUSH
8019: LD_INT 2
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 30
8028: PUSH
8029: LD_INT 3
8031: PUSH
8032: EMPTY
8033: LIST
8034: LIST
8035: PUSH
8036: EMPTY
8037: LIST
8038: LIST
8039: LIST
8040: PPUSH
8041: CALL_OW 69
8045: NOT
8046: IFFALSE 8050
// exit ;
8048: GO 8851
// if Prob ( 40 ) then
8050: LD_INT 40
8052: PPUSH
8053: CALL_OW 13
8057: IFFALSE 8184
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8059: LD_INT 3
8061: PPUSH
8062: LD_INT 14
8064: PUSH
8065: LD_INT 1
8067: PUSH
8068: LD_INT 2
8070: PUSH
8071: LD_INT 28
8073: PUSH
8074: EMPTY
8075: LIST
8076: LIST
8077: LIST
8078: LIST
8079: PUSH
8080: LD_INT 14
8082: PUSH
8083: LD_INT 1
8085: PUSH
8086: LD_INT 2
8088: PUSH
8089: LD_INT 28
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: LIST
8096: LIST
8097: PUSH
8098: LD_INT 14
8100: PUSH
8101: LD_INT 1
8103: PUSH
8104: LD_INT 2
8106: PUSH
8107: LD_INT 28
8109: PUSH
8110: EMPTY
8111: LIST
8112: LIST
8113: LIST
8114: LIST
8115: PUSH
8116: LD_INT 14
8118: PUSH
8119: LD_INT 1
8121: PUSH
8122: LD_INT 2
8124: PUSH
8125: LD_INT 28
8127: PUSH
8128: EMPTY
8129: LIST
8130: LIST
8131: LIST
8132: LIST
8133: PUSH
8134: LD_INT 14
8136: PUSH
8137: LD_INT 1
8139: PUSH
8140: LD_INT 2
8142: PUSH
8143: LD_INT 28
8145: PUSH
8146: EMPTY
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 14
8154: PUSH
8155: LD_INT 1
8157: PUSH
8158: LD_INT 2
8160: PUSH
8161: LD_INT 26
8163: PUSH
8164: EMPTY
8165: LIST
8166: LIST
8167: LIST
8168: LIST
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: PPUSH
8178: CALL 45786 0 2
// end else
8182: GO 8391
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8184: LD_INT 3
8186: PPUSH
8187: LD_INT 14
8189: PUSH
8190: LD_INT 1
8192: PUSH
8193: LD_INT 2
8195: PUSH
8196: LD_INT 27
8198: PUSH
8199: LD_INT 26
8201: PUSH
8202: LD_INT 26
8204: PUSH
8205: LD_INT 28
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_OWVAR 67
8218: ARRAY
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: PUSH
8226: LD_INT 14
8228: PUSH
8229: LD_INT 1
8231: PUSH
8232: LD_INT 2
8234: PUSH
8235: LD_INT 27
8237: PUSH
8238: LD_INT 26
8240: PUSH
8241: LD_INT 26
8243: PUSH
8244: LD_INT 26
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: LIST
8251: LIST
8252: PUSH
8253: LD_OWVAR 67
8257: ARRAY
8258: PUSH
8259: EMPTY
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 14
8267: PUSH
8268: LD_INT 1
8270: PUSH
8271: LD_INT 2
8273: PUSH
8274: LD_INT 26
8276: PUSH
8277: LD_INT 26
8279: PUSH
8280: LD_INT 29
8282: PUSH
8283: LD_INT 29
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: LIST
8290: LIST
8291: PUSH
8292: LD_OWVAR 67
8296: ARRAY
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 13
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 2
8312: PUSH
8313: LD_INT 26
8315: PUSH
8316: LD_INT 29
8318: PUSH
8319: LD_INT 29
8321: PUSH
8322: LD_INT 29
8324: PUSH
8325: EMPTY
8326: LIST
8327: LIST
8328: LIST
8329: LIST
8330: PUSH
8331: LD_OWVAR 67
8335: ARRAY
8336: PUSH
8337: EMPTY
8338: LIST
8339: LIST
8340: LIST
8341: LIST
8342: PUSH
8343: LD_INT 13
8345: PUSH
8346: LD_INT 1
8348: PUSH
8349: LD_INT 2
8351: PUSH
8352: LD_INT 29
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: PUSH
8361: LD_INT 14
8363: PUSH
8364: LD_INT 1
8366: PUSH
8367: LD_INT 2
8369: PUSH
8370: LD_INT 26
8372: PUSH
8373: EMPTY
8374: LIST
8375: LIST
8376: LIST
8377: LIST
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: LIST
8386: PPUSH
8387: CALL 45786 0 2
// end ; repeat wait ( 0 0$1 ) ;
8391: LD_INT 35
8393: PPUSH
8394: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8398: LD_INT 3
8400: PPUSH
8401: LD_INT 1
8403: PPUSH
8404: CALL 47204 0 2
8408: PUSH
8409: LD_INT 6
8411: GREATEREQUAL
8412: IFFALSE 8391
// wait ( 0 0$30 ) ;
8414: LD_INT 1050
8416: PPUSH
8417: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8421: LD_ADDR_VAR 0 2
8425: PUSH
8426: LD_INT 3
8428: PPUSH
8429: LD_INT 1
8431: PPUSH
8432: CALL 47204 0 2
8436: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8437: LD_ADDR_EXP 97
8441: PUSH
8442: LD_EXP 97
8446: PPUSH
8447: LD_INT 3
8449: PPUSH
8450: LD_EXP 97
8454: PUSH
8455: LD_INT 3
8457: ARRAY
8458: PUSH
8459: LD_VAR 0 2
8463: DIFF
8464: PPUSH
8465: CALL_OW 1
8469: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8470: LD_ADDR_VAR 0 3
8474: PUSH
8475: LD_INT 0
8477: PPUSH
8478: LD_INT 2
8480: PPUSH
8481: CALL_OW 12
8485: ST_TO_ADDR
// if target then
8486: LD_VAR 0 3
8490: IFFALSE 8618
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8492: LD_ADDR_VAR 0 2
8496: PUSH
8497: LD_VAR 0 2
8501: PPUSH
8502: LD_INT 24
8504: PUSH
8505: LD_INT 250
8507: PUSH
8508: EMPTY
8509: LIST
8510: LIST
8511: PPUSH
8512: CALL_OW 72
8516: ST_TO_ADDR
// for i in tmp do
8517: LD_ADDR_VAR 0 1
8521: PUSH
8522: LD_VAR 0 2
8526: PUSH
8527: FOR_IN
8528: IFFALSE 8568
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8530: LD_VAR 0 1
8534: PPUSH
8535: LD_INT 89
8537: PPUSH
8538: LD_INT 71
8540: PPUSH
8541: CALL_OW 297
8545: PUSH
8546: LD_INT 9
8548: GREATER
8549: IFFALSE 8566
// ComMoveXY ( i , 89 , 71 ) ;
8551: LD_VAR 0 1
8555: PPUSH
8556: LD_INT 89
8558: PPUSH
8559: LD_INT 71
8561: PPUSH
8562: CALL_OW 111
8566: GO 8527
8568: POP
8569: POP
// wait ( 0 0$1 ) ;
8570: LD_INT 35
8572: PPUSH
8573: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8577: LD_VAR 0 2
8581: PPUSH
8582: LD_INT 92
8584: PUSH
8585: LD_INT 89
8587: PUSH
8588: LD_INT 71
8590: PUSH
8591: LD_INT 9
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PPUSH
8600: CALL_OW 72
8604: PUSH
8605: LD_VAR 0 2
8609: PUSH
8610: LD_INT 1
8612: MINUS
8613: GREATEREQUAL
8614: IFFALSE 8492
// end else
8616: GO 8742
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8618: LD_ADDR_VAR 0 2
8622: PUSH
8623: LD_VAR 0 2
8627: PPUSH
8628: LD_INT 24
8630: PUSH
8631: LD_INT 250
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: PPUSH
8638: CALL_OW 72
8642: ST_TO_ADDR
// for i in tmp do
8643: LD_ADDR_VAR 0 1
8647: PUSH
8648: LD_VAR 0 2
8652: PUSH
8653: FOR_IN
8654: IFFALSE 8694
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8656: LD_VAR 0 1
8660: PPUSH
8661: LD_INT 147
8663: PPUSH
8664: LD_INT 4
8666: PPUSH
8667: CALL_OW 297
8671: PUSH
8672: LD_INT 9
8674: GREATER
8675: IFFALSE 8692
// ComMoveXY ( i , 147 , 4 ) ;
8677: LD_VAR 0 1
8681: PPUSH
8682: LD_INT 147
8684: PPUSH
8685: LD_INT 4
8687: PPUSH
8688: CALL_OW 111
8692: GO 8653
8694: POP
8695: POP
// wait ( 0 0$1 ) ;
8696: LD_INT 35
8698: PPUSH
8699: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8703: LD_VAR 0 2
8707: PPUSH
8708: LD_INT 92
8710: PUSH
8711: LD_INT 147
8713: PUSH
8714: LD_INT 4
8716: PUSH
8717: LD_INT 9
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: LIST
8724: LIST
8725: PPUSH
8726: CALL_OW 72
8730: PUSH
8731: LD_VAR 0 2
8735: PUSH
8736: LD_INT 1
8738: MINUS
8739: GREATEREQUAL
8740: IFFALSE 8618
// end ; repeat wait ( 0 0$1 ) ;
8742: LD_INT 35
8744: PPUSH
8745: CALL_OW 67
// for i in tmp do
8749: LD_ADDR_VAR 0 1
8753: PUSH
8754: LD_VAR 0 2
8758: PUSH
8759: FOR_IN
8760: IFFALSE 8842
// begin if GetLives ( i ) > 251 then
8762: LD_VAR 0 1
8766: PPUSH
8767: CALL_OW 256
8771: PUSH
8772: LD_INT 251
8774: GREATER
8775: IFFALSE 8813
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8777: LD_VAR 0 1
8781: PPUSH
8782: LD_INT 81
8784: PUSH
8785: LD_INT 8
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PPUSH
8792: CALL_OW 69
8796: PPUSH
8797: LD_VAR 0 1
8801: PPUSH
8802: CALL_OW 74
8806: PPUSH
8807: CALL_OW 115
8811: GO 8840
// if IsDead ( i ) then
8813: LD_VAR 0 1
8817: PPUSH
8818: CALL_OW 301
8822: IFFALSE 8840
// tmp := tmp diff i ;
8824: LD_ADDR_VAR 0 2
8828: PUSH
8829: LD_VAR 0 2
8833: PUSH
8834: LD_VAR 0 1
8838: DIFF
8839: ST_TO_ADDR
// end ;
8840: GO 8759
8842: POP
8843: POP
// until not tmp ;
8844: LD_VAR 0 2
8848: NOT
8849: IFFALSE 8742
// end ;
8851: PPOPN 3
8853: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8854: LD_EXP 58
8858: PPUSH
8859: CALL_OW 302
8863: PUSH
8864: LD_EXP 3
8868: NOT
8869: AND
8870: IFFALSE 8879
8872: GO 8874
8874: DISABLE
// BuildKozlovBomb ;
8875: CALL 7863 0 0
8879: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8880: LD_INT 22
8882: PUSH
8883: LD_INT 8
8885: PUSH
8886: EMPTY
8887: LIST
8888: LIST
8889: PUSH
8890: LD_INT 34
8892: PUSH
8893: LD_INT 48
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: EMPTY
8901: LIST
8902: LIST
8903: PPUSH
8904: CALL_OW 69
8908: IFFALSE 8956
8910: GO 8912
8912: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8913: LD_INT 22
8915: PUSH
8916: LD_INT 8
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: PUSH
8923: LD_INT 34
8925: PUSH
8926: LD_INT 48
8928: PUSH
8929: EMPTY
8930: LIST
8931: LIST
8932: PUSH
8933: EMPTY
8934: LIST
8935: LIST
8936: PPUSH
8937: CALL_OW 69
8941: PUSH
8942: LD_INT 1
8944: ARRAY
8945: PPUSH
8946: LD_INT 173
8948: PPUSH
8949: LD_INT 96
8951: PPUSH
8952: CALL_OW 116
// end ; end_of_file
8956: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
8957: LD_INT 0
8959: PPUSH
8960: PPUSH
8961: PPUSH
8962: PPUSH
8963: PPUSH
8964: PPUSH
8965: PPUSH
8966: PPUSH
8967: PPUSH
8968: PPUSH
// side := 3 ;
8969: LD_ADDR_VAR 0 6
8973: PUSH
8974: LD_INT 3
8976: ST_TO_ADDR
// InitHc ;
8977: CALL_OW 19
// uc_side := side ;
8981: LD_ADDR_OWVAR 20
8985: PUSH
8986: LD_VAR 0 6
8990: ST_TO_ADDR
// uc_nation := 3 ;
8991: LD_ADDR_OWVAR 21
8995: PUSH
8996: LD_INT 3
8998: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8999: LD_ADDR_VAR 0 2
9003: PUSH
9004: LD_INT 22
9006: PUSH
9007: LD_VAR 0 6
9011: PUSH
9012: EMPTY
9013: LIST
9014: LIST
9015: PUSH
9016: LD_INT 21
9018: PUSH
9019: LD_INT 3
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PUSH
9026: EMPTY
9027: LIST
9028: LIST
9029: PPUSH
9030: CALL_OW 69
9034: PUSH
9035: FOR_IN
9036: IFFALSE 9052
// SetBLevel ( i , 10 ) ;
9038: LD_VAR 0 2
9042: PPUSH
9043: LD_INT 10
9045: PPUSH
9046: CALL_OW 241
9050: GO 9035
9052: POP
9053: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9054: LD_ADDR_VAR 0 10
9058: PUSH
9059: LD_INT 22
9061: PUSH
9062: LD_VAR 0 6
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: PUSH
9071: LD_INT 30
9073: PUSH
9074: LD_INT 34
9076: PUSH
9077: EMPTY
9078: LIST
9079: LIST
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: PPUSH
9085: CALL_OW 69
9089: ST_TO_ADDR
// if teleport then
9090: LD_VAR 0 10
9094: IFFALSE 9115
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9096: LD_VAR 0 10
9100: PUSH
9101: LD_INT 1
9103: ARRAY
9104: PPUSH
9105: LD_INT 123
9107: PPUSH
9108: LD_INT 122
9110: PPUSH
9111: CALL_OW 243
// hc_importance := 0 ;
9115: LD_ADDR_OWVAR 32
9119: PUSH
9120: LD_INT 0
9122: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9123: LD_ADDR_EXP 60
9127: PUSH
9128: LD_STRING Platonov
9130: PPUSH
9131: CALL_OW 25
9135: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9136: LD_ADDR_EXP 61
9140: PUSH
9141: LD_STRING Yakotich
9143: PPUSH
9144: LD_EXP 1
9148: NOT
9149: PPUSH
9150: LD_STRING 09_
9152: PPUSH
9153: CALL 52212 0 3
9157: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9158: LD_ADDR_EXP 62
9162: PUSH
9163: LD_STRING Gleb
9165: PPUSH
9166: CALL_OW 25
9170: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9171: LD_STRING 03_Cornel
9173: PPUSH
9174: CALL_OW 28
9178: IFFALSE 9226
// begin Bierezov := NewCharacter ( Mikhail ) ;
9180: LD_ADDR_EXP 63
9184: PUSH
9185: LD_STRING Mikhail
9187: PPUSH
9188: CALL_OW 25
9192: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9193: LD_EXP 63
9197: PPUSH
9198: LD_INT 197
9200: PPUSH
9201: LD_INT 111
9203: PPUSH
9204: LD_INT 9
9206: PPUSH
9207: LD_INT 0
9209: PPUSH
9210: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9214: LD_EXP 63
9218: PPUSH
9219: LD_INT 3
9221: PPUSH
9222: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9226: LD_EXP 60
9230: PPUSH
9231: LD_INT 126
9233: PPUSH
9234: CALL_OW 52
// if Yakotich then
9238: LD_EXP 61
9242: IFFALSE 9265
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9244: LD_EXP 61
9248: PPUSH
9249: LD_INT 197
9251: PPUSH
9252: LD_INT 111
9254: PPUSH
9255: LD_INT 9
9257: PPUSH
9258: LD_INT 0
9260: PPUSH
9261: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9265: LD_EXP 62
9269: PPUSH
9270: LD_INT 197
9272: PPUSH
9273: LD_INT 111
9275: PPUSH
9276: LD_INT 9
9278: PPUSH
9279: LD_INT 0
9281: PPUSH
9282: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9286: LD_ADDR_VAR 0 5
9290: PUSH
9291: LD_INT 126
9293: PPUSH
9294: LD_INT 2
9296: PPUSH
9297: LD_STRING zhukov
9299: PPUSH
9300: LD_INT 9
9302: PUSH
9303: LD_INT 10
9305: PUSH
9306: LD_INT 10
9308: PUSH
9309: LD_INT 10
9311: PUSH
9312: EMPTY
9313: LIST
9314: LIST
9315: LIST
9316: LIST
9317: PUSH
9318: LD_OWVAR 67
9322: ARRAY
9323: PPUSH
9324: LD_INT 9000
9326: PUSH
9327: LD_INT 1000
9329: PUSH
9330: LD_INT 300
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: LIST
9337: PPUSH
9338: LD_INT 21
9340: PUSH
9341: LD_INT 8
9343: PUSH
9344: LD_INT 13
9346: PUSH
9347: LD_INT 8
9349: PUSH
9350: EMPTY
9351: LIST
9352: LIST
9353: LIST
9354: LIST
9355: PPUSH
9356: CALL 60496 0 6
9360: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9361: LD_ADDR_EXP 78
9365: PUSH
9366: LD_EXP 78
9370: PPUSH
9371: LD_INT 2
9373: PPUSH
9374: LD_VAR 0 5
9378: PUSH
9379: LD_EXP 61
9383: PUSH
9384: LD_EXP 62
9388: PUSH
9389: LD_EXP 63
9393: PUSH
9394: EMPTY
9395: LIST
9396: LIST
9397: LIST
9398: UNION
9399: PPUSH
9400: CALL_OW 1
9404: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9405: LD_ADDR_VAR 0 4
9409: PUSH
9410: LD_INT 267
9412: PPUSH
9413: CALL_OW 274
9417: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9418: LD_VAR 0 4
9422: PPUSH
9423: LD_INT 1
9425: PPUSH
9426: LD_INT 5000
9428: PPUSH
9429: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9433: LD_VAR 0 4
9437: PPUSH
9438: LD_INT 2
9440: PPUSH
9441: LD_INT 200
9443: PPUSH
9444: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9448: LD_VAR 0 4
9452: PPUSH
9453: LD_INT 3
9455: PPUSH
9456: LD_INT 200
9458: PPUSH
9459: CALL_OW 277
// for i := 1 to 6 do
9463: LD_ADDR_VAR 0 2
9467: PUSH
9468: DOUBLE
9469: LD_INT 1
9471: DEC
9472: ST_TO_ADDR
9473: LD_INT 6
9475: PUSH
9476: FOR_TO
9477: IFFALSE 9560
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
9479: LD_INT 0
9481: PPUSH
9482: LD_INT 8
9484: PUSH
9485: LD_INT 9
9487: PUSH
9488: LD_INT 10
9490: PUSH
9491: LD_INT 10
9493: PUSH
9494: EMPTY
9495: LIST
9496: LIST
9497: LIST
9498: LIST
9499: PUSH
9500: LD_OWVAR 67
9504: ARRAY
9505: PPUSH
9506: CALL_OW 381
// un := CreateHuman ;
9510: LD_ADDR_VAR 0 8
9514: PUSH
9515: CALL_OW 44
9519: ST_TO_ADDR
// if i mod 2 = 0 then
9520: LD_VAR 0 2
9524: PUSH
9525: LD_INT 2
9527: MOD
9528: PUSH
9529: LD_INT 0
9531: EQUAL
9532: IFFALSE 9546
// SetClass ( un , class_bazooker ) ;
9534: LD_VAR 0 8
9538: PPUSH
9539: LD_INT 9
9541: PPUSH
9542: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
9546: LD_VAR 0 8
9550: PPUSH
9551: LD_INT 674
9553: PPUSH
9554: CALL_OW 52
// end ;
9558: GO 9476
9560: POP
9561: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
9562: LD_INT 21
9564: PPUSH
9565: LD_INT 3
9567: PPUSH
9568: LD_INT 3
9570: PPUSH
9571: LD_INT 52
9573: PPUSH
9574: LD_INT 100
9576: PPUSH
9577: CALL 57052 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
9581: CALL_OW 45
9585: PPUSH
9586: LD_INT 259
9588: PPUSH
9589: LD_INT 145
9591: PPUSH
9592: LD_INT 3
9594: PPUSH
9595: LD_INT 0
9597: PPUSH
9598: CALL 91644 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
9602: CALL_OW 45
9606: PPUSH
9607: LD_INT 245
9609: PPUSH
9610: LD_INT 139
9612: PPUSH
9613: LD_INT 3
9615: PPUSH
9616: LD_INT 0
9618: PPUSH
9619: CALL 91644 0 5
// behemoths := [ ] ;
9623: LD_ADDR_EXP 64
9627: PUSH
9628: EMPTY
9629: ST_TO_ADDR
// behemothBuilders := [ ] ;
9630: LD_ADDR_EXP 65
9634: PUSH
9635: EMPTY
9636: ST_TO_ADDR
// j := 3 ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_INT 3
9644: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9645: LD_ADDR_VAR 0 2
9649: PUSH
9650: LD_INT 22
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: LD_INT 25
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PPUSH
9674: CALL_OW 69
9678: PUSH
9679: FOR_IN
9680: IFFALSE 9730
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9682: LD_ADDR_EXP 65
9686: PUSH
9687: LD_EXP 65
9691: PPUSH
9692: LD_VAR 0 2
9696: PPUSH
9697: CALL 89504 0 2
9701: ST_TO_ADDR
// j := j - 1 ;
9702: LD_ADDR_VAR 0 3
9706: PUSH
9707: LD_VAR 0 3
9711: PUSH
9712: LD_INT 1
9714: MINUS
9715: ST_TO_ADDR
// if j = 0 then
9716: LD_VAR 0 3
9720: PUSH
9721: LD_INT 0
9723: EQUAL
9724: IFFALSE 9728
// break ;
9726: GO 9730
// end ;
9728: GO 9679
9730: POP
9731: POP
// end ;
9732: LD_VAR 0 1
9736: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9737: LD_INT 0
9739: PPUSH
9740: PPUSH
9741: PPUSH
9742: PPUSH
9743: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9744: LD_ADDR_VAR 0 4
9748: PUSH
9749: LD_INT 209
9751: PUSH
9752: LD_INT 149
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: PUSH
9759: LD_INT 219
9761: PUSH
9762: LD_INT 154
9764: PUSH
9765: EMPTY
9766: LIST
9767: LIST
9768: PUSH
9769: LD_INT 223
9771: PUSH
9772: LD_INT 149
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: PUSH
9779: LD_INT 232
9781: PUSH
9782: LD_INT 155
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: LIST
9793: LIST
9794: ST_TO_ADDR
// if not behemothBuilders then
9795: LD_EXP 65
9799: NOT
9800: IFFALSE 9804
// exit ;
9802: GO 9908
// j := 1 ;
9804: LD_ADDR_VAR 0 3
9808: PUSH
9809: LD_INT 1
9811: ST_TO_ADDR
// for i in behemothBuilders do
9812: LD_ADDR_VAR 0 2
9816: PUSH
9817: LD_EXP 65
9821: PUSH
9822: FOR_IN
9823: IFFALSE 9906
// begin if IsInUnit ( i ) then
9825: LD_VAR 0 2
9829: PPUSH
9830: CALL_OW 310
9834: IFFALSE 9845
// ComExitBuilding ( i ) ;
9836: LD_VAR 0 2
9840: PPUSH
9841: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9845: LD_VAR 0 2
9849: PPUSH
9850: LD_INT 37
9852: PPUSH
9853: LD_VAR 0 4
9857: PUSH
9858: LD_VAR 0 3
9862: ARRAY
9863: PUSH
9864: LD_INT 1
9866: ARRAY
9867: PPUSH
9868: LD_VAR 0 4
9872: PUSH
9873: LD_VAR 0 3
9877: ARRAY
9878: PUSH
9879: LD_INT 2
9881: ARRAY
9882: PPUSH
9883: LD_INT 0
9885: PPUSH
9886: CALL_OW 230
// j := j + 1 ;
9890: LD_ADDR_VAR 0 3
9894: PUSH
9895: LD_VAR 0 3
9899: PUSH
9900: LD_INT 1
9902: PLUS
9903: ST_TO_ADDR
// end ;
9904: GO 9822
9906: POP
9907: POP
// end ;
9908: LD_VAR 0 1
9912: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9913: LD_INT 3
9915: PPUSH
9916: CALL 89565 0 1
9920: PUSH
9921: LD_INT 22
9923: PUSH
9924: LD_INT 3
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: PUSH
9931: LD_INT 30
9933: PUSH
9934: LD_INT 37
9936: PUSH
9937: EMPTY
9938: LIST
9939: LIST
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: PPUSH
9945: CALL_OW 69
9949: NOT
9950: AND
9951: IFFALSE 10137
9953: GO 9955
9955: DISABLE
9956: LD_INT 0
9958: PPUSH
9959: PPUSH
// begin enable ;
9960: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9961: LD_ADDR_VAR 0 2
9965: PUSH
9966: LD_INT 3
9968: PPUSH
9969: CALL 89565 0 1
9973: ST_TO_ADDR
// for i in tmp do
9974: LD_ADDR_VAR 0 1
9978: PUSH
9979: LD_VAR 0 2
9983: PUSH
9984: FOR_IN
9985: IFFALSE 10135
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9987: LD_VAR 0 1
9991: PPUSH
9992: LD_INT 7
9994: PPUSH
9995: CALL_OW 308
9999: PUSH
10000: LD_VAR 0 1
10004: PPUSH
10005: CALL_OW 110
10009: PUSH
10010: LD_INT 2
10012: EQUAL
10013: NOT
10014: AND
10015: IFFALSE 10029
// SetTag ( i , 2 ) ;
10017: LD_VAR 0 1
10021: PPUSH
10022: LD_INT 2
10024: PPUSH
10025: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10029: LD_INT 81
10031: PUSH
10032: LD_INT 3
10034: PUSH
10035: EMPTY
10036: LIST
10037: LIST
10038: PUSH
10039: LD_INT 91
10041: PUSH
10042: LD_VAR 0 1
10046: PUSH
10047: LD_INT 12
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: LIST
10054: PUSH
10055: EMPTY
10056: LIST
10057: LIST
10058: PPUSH
10059: CALL_OW 69
10063: NOT
10064: PUSH
10065: LD_VAR 0 1
10069: PPUSH
10070: CALL_OW 110
10074: PUSH
10075: LD_INT 2
10077: EQUAL
10078: NOT
10079: AND
10080: IFFALSE 10099
// ComAgressiveMove ( i , 64 , 93 ) else
10082: LD_VAR 0 1
10086: PPUSH
10087: LD_INT 64
10089: PPUSH
10090: LD_INT 93
10092: PPUSH
10093: CALL_OW 114
10097: GO 10133
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10099: LD_VAR 0 1
10103: PPUSH
10104: LD_INT 81
10106: PUSH
10107: LD_INT 3
10109: PUSH
10110: EMPTY
10111: LIST
10112: LIST
10113: PPUSH
10114: CALL_OW 69
10118: PPUSH
10119: LD_VAR 0 1
10123: PPUSH
10124: CALL_OW 74
10128: PPUSH
10129: CALL_OW 115
// end ;
10133: GO 9984
10135: POP
10136: POP
// end ;
10137: PPOPN 2
10139: END
// every 9 9$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport ;
10140: LD_EXP 2
10144: NOT
10145: IFFALSE 11069
10147: GO 10149
10149: DISABLE
10150: LD_INT 0
10152: PPUSH
10153: PPUSH
10154: PPUSH
10155: PPUSH
// begin enable ;
10156: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10157: LD_INT 22
10159: PUSH
10160: LD_INT 3
10162: PUSH
10163: EMPTY
10164: LIST
10165: LIST
10166: PUSH
10167: LD_INT 30
10169: PUSH
10170: LD_INT 3
10172: PUSH
10173: EMPTY
10174: LIST
10175: LIST
10176: PUSH
10177: EMPTY
10178: LIST
10179: LIST
10180: PPUSH
10181: CALL_OW 69
10185: NOT
10186: IFFALSE 10190
// exit ;
10188: GO 11069
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10190: LD_ADDR_VAR 0 4
10194: PUSH
10195: LD_INT 22
10197: PUSH
10198: LD_INT 3
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PUSH
10205: LD_INT 30
10207: PUSH
10208: LD_INT 34
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL_OW 69
10223: ST_TO_ADDR
// if Prob ( 40 ) then
10224: LD_INT 40
10226: PPUSH
10227: CALL_OW 13
10231: IFFALSE 10358
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10233: LD_INT 2
10235: PPUSH
10236: LD_INT 22
10238: PUSH
10239: LD_INT 3
10241: PUSH
10242: LD_INT 3
10244: PUSH
10245: LD_INT 49
10247: PUSH
10248: EMPTY
10249: LIST
10250: LIST
10251: LIST
10252: LIST
10253: PUSH
10254: LD_INT 22
10256: PUSH
10257: LD_INT 3
10259: PUSH
10260: LD_INT 3
10262: PUSH
10263: LD_INT 49
10265: PUSH
10266: EMPTY
10267: LIST
10268: LIST
10269: LIST
10270: LIST
10271: PUSH
10272: LD_INT 22
10274: PUSH
10275: LD_INT 3
10277: PUSH
10278: LD_INT 3
10280: PUSH
10281: LD_INT 49
10283: PUSH
10284: EMPTY
10285: LIST
10286: LIST
10287: LIST
10288: LIST
10289: PUSH
10290: LD_INT 24
10292: PUSH
10293: LD_INT 3
10295: PUSH
10296: LD_INT 3
10298: PUSH
10299: LD_INT 46
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: LIST
10306: LIST
10307: PUSH
10308: LD_INT 24
10310: PUSH
10311: LD_INT 3
10313: PUSH
10314: LD_INT 3
10316: PUSH
10317: LD_INT 46
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: PUSH
10326: LD_INT 24
10328: PUSH
10329: LD_INT 3
10331: PUSH
10332: LD_INT 3
10334: PUSH
10335: LD_INT 46
10337: PUSH
10338: EMPTY
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: PUSH
10344: EMPTY
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: PPUSH
10352: CALL 45786 0 2
// end else
10356: GO 10481
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10358: LD_INT 2
10360: PPUSH
10361: LD_INT 24
10363: PUSH
10364: LD_INT 3
10366: PUSH
10367: LD_INT 3
10369: PUSH
10370: LD_INT 47
10372: PUSH
10373: EMPTY
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: PUSH
10379: LD_INT 24
10381: PUSH
10382: LD_INT 3
10384: PUSH
10385: LD_INT 3
10387: PUSH
10388: LD_INT 47
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: LIST
10395: LIST
10396: PUSH
10397: LD_INT 24
10399: PUSH
10400: LD_INT 3
10402: PUSH
10403: LD_INT 3
10405: PUSH
10406: LD_INT 47
10408: PUSH
10409: EMPTY
10410: LIST
10411: LIST
10412: LIST
10413: LIST
10414: PUSH
10415: LD_INT 24
10417: PUSH
10418: LD_INT 3
10420: PUSH
10421: LD_INT 3
10423: PUSH
10424: LD_INT 46
10426: PUSH
10427: EMPTY
10428: LIST
10429: LIST
10430: LIST
10431: LIST
10432: PUSH
10433: LD_INT 24
10435: PUSH
10436: LD_INT 3
10438: PUSH
10439: LD_INT 3
10441: PUSH
10442: LD_INT 46
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: LIST
10449: LIST
10450: PUSH
10451: LD_INT 24
10453: PUSH
10454: LD_INT 3
10456: PUSH
10457: LD_INT 3
10459: PUSH
10460: LD_INT 46
10462: PUSH
10463: EMPTY
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: PUSH
10469: EMPTY
10470: LIST
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: PPUSH
10477: CALL 45786 0 2
// end ; if Difficulty > 1 then
10481: LD_OWVAR 67
10485: PUSH
10486: LD_INT 1
10488: GREATER
10489: IFFALSE 10519
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10491: LD_INT 2
10493: PPUSH
10494: LD_INT 24
10496: PUSH
10497: LD_INT 3
10499: PUSH
10500: LD_INT 3
10502: PUSH
10503: LD_INT 47
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: LIST
10510: LIST
10511: PUSH
10512: EMPTY
10513: LIST
10514: PPUSH
10515: CALL 45786 0 2
// repeat wait ( 0 0$1 ) ;
10519: LD_INT 35
10521: PPUSH
10522: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10526: LD_INT 2
10528: PPUSH
10529: LD_INT 1
10531: PPUSH
10532: CALL 47204 0 2
10536: PUSH
10537: LD_INT 6
10539: PUSH
10540: LD_INT 7
10542: PUSH
10543: LD_INT 7
10545: PUSH
10546: LD_INT 7
10548: PUSH
10549: EMPTY
10550: LIST
10551: LIST
10552: LIST
10553: LIST
10554: PUSH
10555: LD_OWVAR 67
10559: ARRAY
10560: GREATEREQUAL
10561: IFFALSE 10519
// wait ( 0 0$30 ) ;
10563: LD_INT 1050
10565: PPUSH
10566: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10570: LD_ADDR_VAR 0 2
10574: PUSH
10575: LD_INT 2
10577: PPUSH
10578: LD_INT 1
10580: PPUSH
10581: CALL 47204 0 2
10585: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10586: LD_ADDR_EXP 97
10590: PUSH
10591: LD_EXP 97
10595: PPUSH
10596: LD_INT 2
10598: PPUSH
10599: LD_EXP 97
10603: PUSH
10604: LD_INT 2
10606: ARRAY
10607: PUSH
10608: LD_VAR 0 2
10612: DIFF
10613: PPUSH
10614: CALL_OW 1
10618: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10619: LD_ADDR_VAR 0 3
10623: PUSH
10624: LD_INT 0
10626: PPUSH
10627: LD_INT 1
10629: PPUSH
10630: CALL_OW 12
10634: ST_TO_ADDR
// if target then
10635: LD_VAR 0 3
10639: IFFALSE 10767
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10641: LD_ADDR_VAR 0 2
10645: PUSH
10646: LD_VAR 0 2
10650: PPUSH
10651: LD_INT 24
10653: PUSH
10654: LD_INT 250
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: PPUSH
10661: CALL_OW 72
10665: ST_TO_ADDR
// for i in tmp do
10666: LD_ADDR_VAR 0 1
10670: PUSH
10671: LD_VAR 0 2
10675: PUSH
10676: FOR_IN
10677: IFFALSE 10717
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10679: LD_VAR 0 1
10683: PPUSH
10684: LD_INT 139
10686: PPUSH
10687: LD_INT 89
10689: PPUSH
10690: CALL_OW 297
10694: PUSH
10695: LD_INT 9
10697: GREATER
10698: IFFALSE 10715
// ComMoveXY ( i , 139 , 89 ) ;
10700: LD_VAR 0 1
10704: PPUSH
10705: LD_INT 139
10707: PPUSH
10708: LD_INT 89
10710: PPUSH
10711: CALL_OW 111
10715: GO 10676
10717: POP
10718: POP
// wait ( 0 0$1 ) ;
10719: LD_INT 35
10721: PPUSH
10722: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10726: LD_VAR 0 2
10730: PPUSH
10731: LD_INT 92
10733: PUSH
10734: LD_INT 139
10736: PUSH
10737: LD_INT 89
10739: PUSH
10740: LD_INT 9
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: PPUSH
10749: CALL_OW 72
10753: PUSH
10754: LD_VAR 0 2
10758: PUSH
10759: LD_INT 1
10761: MINUS
10762: GREATEREQUAL
10763: IFFALSE 10641
// end else
10765: GO 10909
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10767: LD_VAR 0 2
10771: PPUSH
10772: LD_VAR 0 4
10776: PUSH
10777: LD_INT 1
10779: ARRAY
10780: PPUSH
10781: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10785: LD_ADDR_VAR 0 2
10789: PUSH
10790: LD_VAR 0 2
10794: PPUSH
10795: LD_INT 24
10797: PUSH
10798: LD_INT 250
10800: PUSH
10801: EMPTY
10802: LIST
10803: LIST
10804: PPUSH
10805: CALL_OW 72
10809: ST_TO_ADDR
// for i in tmp do
10810: LD_ADDR_VAR 0 1
10814: PUSH
10815: LD_VAR 0 2
10819: PUSH
10820: FOR_IN
10821: IFFALSE 10861
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10823: LD_VAR 0 1
10827: PPUSH
10828: LD_INT 124
10830: PPUSH
10831: LD_INT 139
10833: PPUSH
10834: CALL_OW 297
10838: PUSH
10839: LD_INT 9
10841: GREATER
10842: IFFALSE 10859
// ComMoveXY ( i , 124 , 139 ) ;
10844: LD_VAR 0 1
10848: PPUSH
10849: LD_INT 124
10851: PPUSH
10852: LD_INT 139
10854: PPUSH
10855: CALL_OW 111
10859: GO 10820
10861: POP
10862: POP
// wait ( 0 0$1 ) ;
10863: LD_INT 35
10865: PPUSH
10866: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10870: LD_VAR 0 2
10874: PPUSH
10875: LD_INT 92
10877: PUSH
10878: LD_INT 124
10880: PUSH
10881: LD_INT 139
10883: PUSH
10884: LD_INT 9
10886: PUSH
10887: EMPTY
10888: LIST
10889: LIST
10890: LIST
10891: LIST
10892: PPUSH
10893: CALL_OW 72
10897: PUSH
10898: LD_VAR 0 2
10902: PUSH
10903: LD_INT 1
10905: MINUS
10906: GREATEREQUAL
10907: IFFALSE 10785
// end ; repeat wait ( 0 0$1 ) ;
10909: LD_INT 35
10911: PPUSH
10912: CALL_OW 67
// for i in tmp do
10916: LD_ADDR_VAR 0 1
10920: PUSH
10921: LD_VAR 0 2
10925: PUSH
10926: FOR_IN
10927: IFFALSE 11060
// begin if GetLives ( i ) > 251 then
10929: LD_VAR 0 1
10933: PPUSH
10934: CALL_OW 256
10938: PUSH
10939: LD_INT 251
10941: GREATER
10942: IFFALSE 11031
// begin if GetWeapon ( i ) = ru_time_lapser then
10944: LD_VAR 0 1
10948: PPUSH
10949: CALL_OW 264
10953: PUSH
10954: LD_INT 49
10956: EQUAL
10957: IFFALSE 10995
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10959: LD_VAR 0 1
10963: PPUSH
10964: LD_INT 81
10966: PUSH
10967: LD_INT 3
10969: PUSH
10970: EMPTY
10971: LIST
10972: LIST
10973: PPUSH
10974: CALL_OW 69
10978: PPUSH
10979: LD_VAR 0 1
10983: PPUSH
10984: CALL_OW 74
10988: PPUSH
10989: CALL_OW 112
10993: GO 11029
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10995: LD_VAR 0 1
10999: PPUSH
11000: LD_INT 81
11002: PUSH
11003: LD_INT 3
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PPUSH
11010: CALL_OW 69
11014: PPUSH
11015: LD_VAR 0 1
11019: PPUSH
11020: CALL_OW 74
11024: PPUSH
11025: CALL_OW 115
// end else
11029: GO 11058
// if IsDead ( i ) then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 301
11040: IFFALSE 11058
// tmp := tmp diff i ;
11042: LD_ADDR_VAR 0 2
11046: PUSH
11047: LD_VAR 0 2
11051: PUSH
11052: LD_VAR 0 1
11056: DIFF
11057: ST_TO_ADDR
// end ;
11058: GO 10926
11060: POP
11061: POP
// until not tmp ;
11062: LD_VAR 0 2
11066: NOT
11067: IFFALSE 10909
// end ;
11069: PPOPN 4
11071: END
// every 30 30$00 trigger not russianDestroyed do
11072: LD_EXP 2
11076: NOT
11077: IFFALSE 11146
11079: GO 11081
11081: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11082: LD_INT 105000
11084: PUSH
11085: LD_INT 84000
11087: PUSH
11088: LD_INT 63000
11090: PUSH
11091: LD_INT 52500
11093: PUSH
11094: EMPTY
11095: LIST
11096: LIST
11097: LIST
11098: LIST
11099: PUSH
11100: LD_OWVAR 67
11104: ARRAY
11105: PPUSH
11106: CALL_OW 67
// if russianDestroyed then
11110: LD_EXP 2
11114: IFFALSE 11118
// exit ;
11116: GO 11146
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11118: LD_INT 2
11120: PPUSH
11121: LD_INT 23
11123: PUSH
11124: LD_INT 3
11126: PUSH
11127: LD_INT 1
11129: PUSH
11130: LD_INT 48
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: LIST
11137: LIST
11138: PUSH
11139: EMPTY
11140: LIST
11141: PPUSH
11142: CALL 45786 0 2
// end ; end_of_file
11146: END
// export function CustomEvent ( event ) ; begin
11147: LD_INT 0
11149: PPUSH
// end ;
11150: LD_VAR 0 2
11154: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11155: LD_VAR 0 2
11159: PPUSH
11160: LD_VAR 0 3
11164: PPUSH
11165: LD_INT 15
11167: PPUSH
11168: CALL_OW 309
11172: IFFALSE 11181
// YouLost ( MothContaminate ) ;
11174: LD_STRING MothContaminate
11176: PPUSH
11177: CALL_OW 104
// end ;
11181: PPOPN 3
11183: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11184: LD_VAR 0 2
11188: PPUSH
11189: LD_VAR 0 3
11193: PPUSH
11194: LD_INT 15
11196: PPUSH
11197: CALL_OW 309
11201: IFFALSE 11217
// begin wait ( 0 0$6 ) ;
11203: LD_INT 210
11205: PPUSH
11206: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11210: LD_STRING MothContaminateBomb
11212: PPUSH
11213: CALL_OW 104
// end ; end ;
11217: PPOPN 3
11219: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11220: LD_VAR 0 1
11224: PPUSH
11225: CALL 109370 0 1
// if un = JMM then
11229: LD_VAR 0 1
11233: PUSH
11234: LD_EXP 19
11238: EQUAL
11239: IFFALSE 11250
// begin YouLost ( JMM ) ;
11241: LD_STRING JMM
11243: PPUSH
11244: CALL_OW 104
// exit ;
11248: GO 11379
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11250: LD_VAR 0 1
11254: PPUSH
11255: CALL_OW 255
11259: PUSH
11260: LD_INT 2
11262: EQUAL
11263: PUSH
11264: LD_EXP 18
11268: NOT
11269: AND
11270: IFFALSE 11280
// arabianAttacked := true ;
11272: LD_ADDR_EXP 18
11276: PUSH
11277: LD_INT 1
11279: ST_TO_ADDR
// if un = Powell then
11280: LD_VAR 0 1
11284: PUSH
11285: LD_EXP 55
11289: EQUAL
11290: IFFALSE 11300
// americanDestroyed := true ;
11292: LD_ADDR_EXP 4
11296: PUSH
11297: LD_INT 1
11299: ST_TO_ADDR
// if un = Platonov then
11300: LD_VAR 0 1
11304: PUSH
11305: LD_EXP 60
11309: EQUAL
11310: IFFALSE 11320
// russianDestroyed := true ;
11312: LD_ADDR_EXP 2
11316: PUSH
11317: LD_INT 1
11319: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11320: LD_VAR 0 1
11324: PUSH
11325: LD_INT 22
11327: PUSH
11328: LD_INT 7
11330: PUSH
11331: EMPTY
11332: LIST
11333: LIST
11334: PUSH
11335: LD_INT 21
11337: PUSH
11338: LD_INT 2
11340: PUSH
11341: EMPTY
11342: LIST
11343: LIST
11344: PUSH
11345: EMPTY
11346: LIST
11347: LIST
11348: PPUSH
11349: CALL_OW 69
11353: IN
11354: IFFALSE 11370
// vehicleLostCounter := vehicleLostCounter + 1 ;
11356: LD_ADDR_EXP 15
11360: PUSH
11361: LD_EXP 15
11365: PUSH
11366: LD_INT 1
11368: PLUS
11369: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11370: LD_VAR 0 1
11374: PPUSH
11375: CALL 49228 0 1
// end ;
11379: PPOPN 1
11381: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11382: LD_VAR 0 1
11386: PPUSH
11387: LD_VAR 0 2
11391: PPUSH
11392: CALL 51560 0 2
// end ;
11396: PPOPN 2
11398: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11399: LD_VAR 0 1
11403: PPUSH
11404: CALL 50628 0 1
// end ;
11408: PPOPN 1
11410: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11411: LD_VAR 0 1
11415: PUSH
11416: LD_INT 22
11418: PUSH
11419: LD_INT 8
11421: PUSH
11422: EMPTY
11423: LIST
11424: LIST
11425: PUSH
11426: LD_INT 30
11428: PUSH
11429: LD_INT 2
11431: PUSH
11432: EMPTY
11433: LIST
11434: LIST
11435: PUSH
11436: LD_INT 23
11438: PUSH
11439: LD_INT 3
11441: PUSH
11442: EMPTY
11443: LIST
11444: LIST
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: LIST
11450: PPUSH
11451: CALL_OW 69
11455: IN
11456: IFFALSE 11483
// begin ComUpgrade ( building ) ;
11458: LD_VAR 0 1
11462: PPUSH
11463: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11467: LD_EXP 58
11471: PPUSH
11472: LD_VAR 0 1
11476: PPUSH
11477: CALL 60035 0 2
// exit ;
11481: GO 11492
// end ; MCE_BuildingComplete ( building ) ;
11483: LD_VAR 0 1
11487: PPUSH
11488: CALL 50869 0 1
// end ;
11492: PPOPN 1
11494: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11495: LD_VAR 0 1
11499: PPUSH
11500: LD_VAR 0 2
11504: PPUSH
11505: CALL 48924 0 2
// end ;
11509: PPOPN 2
11511: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11512: LD_VAR 0 1
11516: PPUSH
11517: LD_VAR 0 2
11521: PPUSH
11522: LD_VAR 0 3
11526: PPUSH
11527: LD_VAR 0 4
11531: PPUSH
11532: LD_VAR 0 5
11536: PPUSH
11537: CALL 48544 0 5
// end ;
11541: PPOPN 5
11543: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11544: LD_VAR 0 1
11548: PPUSH
11549: LD_VAR 0 2
11553: PPUSH
11554: CALL 109490 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11558: LD_VAR 0 1
11562: PPUSH
11563: LD_VAR 0 2
11567: PPUSH
11568: CALL 48097 0 2
// end ;
11572: PPOPN 2
11574: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11575: LD_VAR 0 1
11579: PPUSH
11580: LD_VAR 0 2
11584: PPUSH
11585: LD_VAR 0 3
11589: PPUSH
11590: LD_VAR 0 4
11594: PPUSH
11595: CALL 47935 0 4
// end ;
11599: PPOPN 4
11601: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11602: LD_VAR 0 1
11606: PPUSH
11607: LD_VAR 0 2
11611: PPUSH
11612: LD_VAR 0 3
11616: PPUSH
11617: CALL 47710 0 3
// end ;
11621: PPOPN 3
11623: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11624: LD_VAR 0 1
11628: PPUSH
11629: LD_VAR 0 2
11633: PPUSH
11634: CALL 47595 0 2
// end ;
11638: PPOPN 2
11640: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11641: LD_VAR 0 1
11645: PPUSH
11646: LD_VAR 0 2
11650: PPUSH
11651: CALL 51855 0 2
// end ;
11655: PPOPN 2
11657: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
11658: LD_VAR 0 1
11662: PUSH
11663: LD_INT 674
11665: EQUAL
11666: IFFALSE 11688
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
11668: LD_VAR 0 2
11672: PPUSH
11673: LD_INT 227
11675: PPUSH
11676: LD_INT 136
11678: PPUSH
11679: CALL_OW 428
11683: PPUSH
11684: CALL_OW 120
// end ;
11688: PPOPN 2
11690: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: LD_VAR 0 3
11705: PPUSH
11706: LD_VAR 0 4
11710: PPUSH
11711: CALL 52071 0 4
// end ;
11715: PPOPN 4
11717: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11718: LD_VAR 0 1
11722: PPUSH
11723: LD_VAR 0 2
11727: PPUSH
11728: CALL 47404 0 2
// end ;
11732: PPOPN 2
11734: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11735: LD_VAR 0 1
11739: PPUSH
11740: CALL 109474 0 1
// end ; end_of_file
11744: PPOPN 1
11746: END
// export function Action ; begin
11747: LD_INT 0
11749: PPUSH
// InGameOn ;
11750: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11754: LD_INT 206
11756: PPUSH
11757: LD_INT 11
11759: PPUSH
11760: CALL_OW 86
// wait ( 0 0$1 ) ;
11764: LD_INT 35
11766: PPUSH
11767: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11771: LD_EXP 19
11775: PPUSH
11776: LD_STRING DStart-JMM-JMM-1
11778: PPUSH
11779: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11783: LD_EXP 52
11787: PPUSH
11788: LD_STRING DStart-JMM-Bur-1
11790: PPUSH
11791: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11795: LD_EXP 19
11799: PPUSH
11800: LD_STRING DStart-JMM-JMM-2
11802: PPUSH
11803: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11807: LD_EXP 52
11811: PPUSH
11812: LD_STRING DStart-JMM-Bur-2
11814: PPUSH
11815: CALL_OW 88
// InGameOff ;
11819: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11823: LD_STRING MStart
11825: PPUSH
11826: CALL_OW 337
// SaveForQuickRestart ;
11830: CALL_OW 22
// end ;
11834: LD_VAR 0 1
11838: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11839: LD_INT 7
11841: PPUSH
11842: LD_INT 255
11844: PPUSH
11845: LD_INT 219
11847: PPUSH
11848: CALL_OW 293
11852: IFFALSE 12461
11854: GO 11856
11856: DISABLE
11857: LD_INT 0
11859: PPUSH
// begin wait ( 0 0$3 ) ;
11860: LD_INT 105
11862: PPUSH
11863: CALL_OW 67
// alienSpotted := true ;
11867: LD_ADDR_EXP 10
11871: PUSH
11872: LD_INT 1
11874: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11875: LD_ADDR_VAR 0 1
11879: PUSH
11880: LD_INT 22
11882: PUSH
11883: LD_INT 7
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: LD_INT 23
11892: PUSH
11893: LD_INT 3
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: PUSH
11900: LD_INT 21
11902: PUSH
11903: LD_INT 1
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 26
11912: PUSH
11913: LD_INT 1
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: PPUSH
11926: CALL_OW 69
11930: PUSH
11931: LD_EXP 52
11935: PUSH
11936: LD_EXP 40
11940: PUSH
11941: LD_EXP 42
11945: PUSH
11946: LD_EXP 43
11950: PUSH
11951: LD_EXP 50
11955: PUSH
11956: LD_EXP 49
11960: PUSH
11961: LD_EXP 44
11965: PUSH
11966: EMPTY
11967: LIST
11968: LIST
11969: LIST
11970: LIST
11971: LIST
11972: LIST
11973: LIST
11974: DIFF
11975: ST_TO_ADDR
// DialogueOn ;
11976: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11980: LD_INT 255
11982: PPUSH
11983: LD_INT 219
11985: PPUSH
11986: LD_INT 7
11988: PPUSH
11989: LD_INT 20
11991: NEG
11992: PPUSH
11993: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11997: LD_INT 255
11999: PPUSH
12000: LD_INT 219
12002: PPUSH
12003: CALL_OW 86
// if speaker then
12007: LD_VAR 0 1
12011: IFFALSE 12029
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12013: LD_VAR 0 1
12017: PUSH
12018: LD_INT 1
12020: ARRAY
12021: PPUSH
12022: LD_STRING DAlienBase-RSol1-1
12024: PPUSH
12025: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12029: LD_EXP 19
12033: PPUSH
12034: LD_STRING DAlienBase-JMM-1
12036: PPUSH
12037: CALL_OW 88
// if IsOk ( Burlak ) then
12041: LD_EXP 52
12045: PPUSH
12046: CALL_OW 302
12050: IFFALSE 12071
// begin dwait ( 0 0$1 ) ;
12052: LD_INT 35
12054: PPUSH
12055: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12059: LD_EXP 52
12063: PPUSH
12064: LD_STRING DAlienBase-Bur-1
12066: PPUSH
12067: CALL_OW 88
// end ; if IsOk ( Roth ) then
12071: LD_EXP 20
12075: PPUSH
12076: CALL_OW 302
12080: IFFALSE 12094
// Say ( Roth , DAlienBase-Roth-1 ) ;
12082: LD_EXP 20
12086: PPUSH
12087: LD_STRING DAlienBase-Roth-1
12089: PPUSH
12090: CALL_OW 88
// if IsOk ( Gossudarov ) then
12094: LD_EXP 38
12098: PPUSH
12099: CALL_OW 302
12103: IFFALSE 12119
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12105: LD_EXP 38
12109: PPUSH
12110: LD_STRING DAlienBase-Gos-1
12112: PPUSH
12113: CALL_OW 88
12117: GO 12236
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12119: LD_ADDR_VAR 0 1
12123: PUSH
12124: LD_INT 22
12126: PUSH
12127: LD_INT 7
12129: PUSH
12130: EMPTY
12131: LIST
12132: LIST
12133: PUSH
12134: LD_INT 25
12136: PUSH
12137: LD_INT 4
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PUSH
12144: LD_INT 21
12146: PUSH
12147: LD_INT 1
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PUSH
12154: LD_INT 26
12156: PUSH
12157: LD_INT 1
12159: PUSH
12160: EMPTY
12161: LIST
12162: LIST
12163: PUSH
12164: EMPTY
12165: LIST
12166: LIST
12167: LIST
12168: LIST
12169: PPUSH
12170: CALL_OW 69
12174: PUSH
12175: LD_EXP 20
12179: PUSH
12180: LD_EXP 19
12184: PUSH
12185: LD_EXP 52
12189: PUSH
12190: LD_EXP 40
12194: PUSH
12195: LD_EXP 50
12199: PUSH
12200: LD_EXP 49
12204: PUSH
12205: EMPTY
12206: LIST
12207: LIST
12208: LIST
12209: LIST
12210: LIST
12211: LIST
12212: DIFF
12213: ST_TO_ADDR
// if speaker then
12214: LD_VAR 0 1
12218: IFFALSE 12236
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12220: LD_VAR 0 1
12224: PUSH
12225: LD_INT 1
12227: ARRAY
12228: PPUSH
12229: LD_STRING DAlienBase-Sci1-1
12231: PPUSH
12232: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12236: LD_INT 255
12238: PPUSH
12239: LD_INT 219
12241: PPUSH
12242: LD_INT 7
12244: PPUSH
12245: CALL_OW 331
// DialogueOff ;
12249: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12253: LD_INT 35
12255: PPUSH
12256: CALL_OW 67
// until IsSelected ( alien ) ;
12260: LD_INT 1
12262: PPUSH
12263: CALL_OW 306
12267: IFFALSE 12253
// if not artifactIResearched or not artifactIIResearched then
12269: LD_EXP 12
12273: NOT
12274: PUSH
12275: LD_EXP 13
12279: NOT
12280: OR
12281: IFFALSE 12461
// begin if IsOk ( Roth ) then
12283: LD_EXP 20
12287: PPUSH
12288: CALL_OW 302
12292: IFFALSE 12308
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12294: LD_EXP 20
12298: PPUSH
12299: LD_STRING DAlieBaseNotReady-Roth-1
12301: PPUSH
12302: CALL_OW 88
12306: GO 12461
// if IsOk ( Gossudarov ) then
12308: LD_EXP 38
12312: PPUSH
12313: CALL_OW 302
12317: IFFALSE 12333
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12319: LD_EXP 38
12323: PPUSH
12324: LD_STRING DAlieBaseNotReady-Gos-1
12326: PPUSH
12327: CALL_OW 88
12331: GO 12461
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12333: LD_ADDR_VAR 0 1
12337: PUSH
12338: LD_INT 22
12340: PUSH
12341: LD_INT 7
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: PUSH
12348: LD_INT 23
12350: PUSH
12351: LD_INT 3
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_INT 25
12360: PUSH
12361: LD_INT 4
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: LD_INT 21
12370: PUSH
12371: LD_INT 1
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PUSH
12378: LD_INT 26
12380: PUSH
12381: LD_INT 1
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: PPUSH
12395: CALL_OW 69
12399: PUSH
12400: LD_EXP 20
12404: PUSH
12405: LD_EXP 19
12409: PUSH
12410: LD_EXP 52
12414: PUSH
12415: LD_EXP 40
12419: PUSH
12420: LD_EXP 50
12424: PUSH
12425: LD_EXP 49
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: LIST
12434: LIST
12435: LIST
12436: LIST
12437: DIFF
12438: ST_TO_ADDR
// if speaker then
12439: LD_VAR 0 1
12443: IFFALSE 12461
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12445: LD_VAR 0 1
12449: PUSH
12450: LD_INT 1
12452: ARRAY
12453: PPUSH
12454: LD_STRING DAlieBaseNotReady-RSci1-1
12456: PPUSH
12457: CALL_OW 88
// end ; end ; end ;
12461: PPOPN 1
12463: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12464: LD_INT 24
12466: PPUSH
12467: LD_INT 7
12469: PPUSH
12470: CALL_OW 321
12474: PUSH
12475: LD_INT 2
12477: EQUAL
12478: IFFALSE 13169
12480: GO 12482
12482: DISABLE
12483: LD_INT 0
12485: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12486: LD_ADDR_VAR 0 1
12490: PUSH
12491: LD_INT 22
12493: PUSH
12494: LD_INT 7
12496: PUSH
12497: EMPTY
12498: LIST
12499: LIST
12500: PUSH
12501: LD_INT 23
12503: PUSH
12504: LD_INT 3
12506: PUSH
12507: EMPTY
12508: LIST
12509: LIST
12510: PUSH
12511: LD_INT 25
12513: PUSH
12514: LD_INT 4
12516: PUSH
12517: EMPTY
12518: LIST
12519: LIST
12520: PUSH
12521: LD_INT 21
12523: PUSH
12524: LD_INT 1
12526: PUSH
12527: EMPTY
12528: LIST
12529: LIST
12530: PUSH
12531: LD_INT 26
12533: PUSH
12534: LD_INT 1
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: PUSH
12541: EMPTY
12542: LIST
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: PPUSH
12548: CALL_OW 69
12552: PUSH
12553: LD_EXP 20
12557: PUSH
12558: LD_EXP 19
12562: PUSH
12563: LD_EXP 52
12567: PUSH
12568: LD_EXP 40
12572: PUSH
12573: LD_EXP 50
12577: PUSH
12578: LD_EXP 49
12582: PUSH
12583: EMPTY
12584: LIST
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: LIST
12590: DIFF
12591: ST_TO_ADDR
// if not speaker then
12592: LD_VAR 0 1
12596: NOT
12597: IFFALSE 12601
// exit ;
12599: GO 13169
// DialogueOn ;
12601: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12605: LD_VAR 0 1
12609: PUSH
12610: LD_INT 1
12612: ARRAY
12613: PPUSH
12614: LD_STRING DArtefTechnology-RSci1-1
12616: PPUSH
12617: CALL_OW 88
// if IsOk ( Burlak ) then
12621: LD_EXP 52
12625: PPUSH
12626: CALL_OW 302
12630: IFFALSE 12644
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12632: LD_EXP 52
12636: PPUSH
12637: LD_STRING DArtefTechnology-Bur-1
12639: PPUSH
12640: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12644: LD_VAR 0 1
12648: PUSH
12649: LD_INT 1
12651: ARRAY
12652: PPUSH
12653: LD_STRING DArtefTechnology-RSci1-2
12655: PPUSH
12656: CALL_OW 88
// if Denis then
12660: LD_EXP 25
12664: IFFALSE 12681
// speaker := [ Denis ] else
12666: LD_ADDR_VAR 0 1
12670: PUSH
12671: LD_EXP 25
12675: PUSH
12676: EMPTY
12677: LIST
12678: ST_TO_ADDR
12679: GO 12787
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12681: LD_ADDR_VAR 0 1
12685: PUSH
12686: LD_INT 22
12688: PUSH
12689: LD_INT 7
12691: PUSH
12692: EMPTY
12693: LIST
12694: LIST
12695: PUSH
12696: LD_INT 23
12698: PUSH
12699: LD_INT 1
12701: PUSH
12702: EMPTY
12703: LIST
12704: LIST
12705: PUSH
12706: LD_INT 25
12708: PUSH
12709: LD_INT 4
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: PUSH
12716: LD_INT 21
12718: PUSH
12719: LD_INT 1
12721: PUSH
12722: EMPTY
12723: LIST
12724: LIST
12725: PUSH
12726: LD_INT 26
12728: PUSH
12729: LD_INT 1
12731: PUSH
12732: EMPTY
12733: LIST
12734: LIST
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: LIST
12740: LIST
12741: LIST
12742: PPUSH
12743: CALL_OW 69
12747: PUSH
12748: LD_EXP 20
12752: PUSH
12753: LD_EXP 19
12757: PUSH
12758: LD_EXP 52
12762: PUSH
12763: LD_EXP 40
12767: PUSH
12768: LD_EXP 50
12772: PUSH
12773: LD_EXP 49
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: DIFF
12786: ST_TO_ADDR
// if speaker then
12787: LD_VAR 0 1
12791: IFFALSE 12809
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12793: LD_VAR 0 1
12797: PUSH
12798: LD_INT 1
12800: ARRAY
12801: PPUSH
12802: LD_STRING DArtefTechnology-Sci1-2
12804: PPUSH
12805: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12809: LD_ADDR_VAR 0 1
12813: PUSH
12814: LD_INT 22
12816: PUSH
12817: LD_INT 7
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: LD_INT 23
12826: PUSH
12827: LD_INT 3
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: PUSH
12834: LD_INT 25
12836: PUSH
12837: LD_INT 4
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: PUSH
12844: LD_INT 21
12846: PUSH
12847: LD_INT 1
12849: PUSH
12850: EMPTY
12851: LIST
12852: LIST
12853: PUSH
12854: LD_INT 26
12856: PUSH
12857: LD_INT 1
12859: PUSH
12860: EMPTY
12861: LIST
12862: LIST
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: LIST
12870: PPUSH
12871: CALL_OW 69
12875: PUSH
12876: LD_EXP 20
12880: PUSH
12881: LD_EXP 19
12885: PUSH
12886: LD_EXP 52
12890: PUSH
12891: LD_EXP 40
12895: PUSH
12896: LD_EXP 50
12900: PUSH
12901: LD_EXP 49
12905: PUSH
12906: EMPTY
12907: LIST
12908: LIST
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: DIFF
12914: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12915: LD_VAR 0 1
12919: PUSH
12920: LD_EXP 9
12924: PUSH
12925: LD_EXP 5
12929: OR
12930: AND
12931: IFFALSE 13165
// begin if arabianDestroyed and IsOk ( Burlak ) then
12933: LD_EXP 5
12937: PUSH
12938: LD_EXP 52
12942: PPUSH
12943: CALL_OW 302
12947: AND
12948: IFFALSE 12964
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12950: LD_EXP 52
12954: PPUSH
12955: LD_STRING DArtefTechnology-Bur-2
12957: PPUSH
12958: CALL_OW 88
12962: GO 12976
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12964: LD_EXP 19
12968: PPUSH
12969: LD_STRING DArtefTechnology-JMM-2
12971: PPUSH
12972: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12976: LD_VAR 0 1
12980: PUSH
12981: LD_INT 1
12983: ARRAY
12984: PPUSH
12985: LD_STRING DArtefTechnology-RSci1-3
12987: PPUSH
12988: CALL_OW 88
// if Denis then
12992: LD_EXP 25
12996: IFFALSE 13013
// speaker := [ Denis ] else
12998: LD_ADDR_VAR 0 1
13002: PUSH
13003: LD_EXP 25
13007: PUSH
13008: EMPTY
13009: LIST
13010: ST_TO_ADDR
13011: GO 13119
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13013: LD_ADDR_VAR 0 1
13017: PUSH
13018: LD_INT 22
13020: PUSH
13021: LD_INT 7
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 23
13030: PUSH
13031: LD_INT 1
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 25
13040: PUSH
13041: LD_INT 4
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: PUSH
13048: LD_INT 21
13050: PUSH
13051: LD_INT 1
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: PUSH
13058: LD_INT 26
13060: PUSH
13061: LD_INT 1
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: LIST
13074: PPUSH
13075: CALL_OW 69
13079: PUSH
13080: LD_EXP 20
13084: PUSH
13085: LD_EXP 19
13089: PUSH
13090: LD_EXP 52
13094: PUSH
13095: LD_EXP 40
13099: PUSH
13100: LD_EXP 50
13104: PUSH
13105: LD_EXP 49
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: DIFF
13118: ST_TO_ADDR
// if speaker then
13119: LD_VAR 0 1
13123: IFFALSE 13165
// if alienSpotted then
13125: LD_EXP 10
13129: IFFALSE 13149
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13131: LD_VAR 0 1
13135: PUSH
13136: LD_INT 1
13138: ARRAY
13139: PPUSH
13140: LD_STRING DArtefTechnology-Sci1-3
13142: PPUSH
13143: CALL_OW 88
13147: GO 13165
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13149: LD_VAR 0 1
13153: PUSH
13154: LD_INT 1
13156: ARRAY
13157: PPUSH
13158: LD_STRING DArtefTechnology-Sci1-3a
13160: PPUSH
13161: CALL_OW 88
// end ; DialogueOff ;
13165: CALL_OW 7
// end ;
13169: PPOPN 1
13171: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13172: LD_EXP 12
13176: IFFALSE 13379
13178: GO 13180
13180: DISABLE
13181: LD_INT 0
13183: PPUSH
// begin if Denis then
13184: LD_EXP 25
13188: IFFALSE 13205
// speaker := [ Denis ] else
13190: LD_ADDR_VAR 0 1
13194: PUSH
13195: LD_EXP 25
13199: PUSH
13200: EMPTY
13201: LIST
13202: ST_TO_ADDR
13203: GO 13311
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13205: LD_ADDR_VAR 0 1
13209: PUSH
13210: LD_INT 22
13212: PUSH
13213: LD_INT 7
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: PUSH
13220: LD_INT 23
13222: PUSH
13223: LD_INT 1
13225: PUSH
13226: EMPTY
13227: LIST
13228: LIST
13229: PUSH
13230: LD_INT 25
13232: PUSH
13233: LD_INT 4
13235: PUSH
13236: EMPTY
13237: LIST
13238: LIST
13239: PUSH
13240: LD_INT 21
13242: PUSH
13243: LD_INT 1
13245: PUSH
13246: EMPTY
13247: LIST
13248: LIST
13249: PUSH
13250: LD_INT 26
13252: PUSH
13253: LD_INT 1
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: LIST
13266: PPUSH
13267: CALL_OW 69
13271: PUSH
13272: LD_EXP 20
13276: PUSH
13277: LD_EXP 19
13281: PUSH
13282: LD_EXP 52
13286: PUSH
13287: LD_EXP 40
13291: PUSH
13292: LD_EXP 50
13296: PUSH
13297: LD_EXP 49
13301: PUSH
13302: EMPTY
13303: LIST
13304: LIST
13305: LIST
13306: LIST
13307: LIST
13308: LIST
13309: DIFF
13310: ST_TO_ADDR
// if not speaker then
13311: LD_VAR 0 1
13315: NOT
13316: IFFALSE 13320
// exit ;
13318: GO 13379
// DialogueOn ;
13320: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13324: LD_VAR 0 1
13328: PUSH
13329: LD_INT 1
13331: ARRAY
13332: PPUSH
13333: LD_STRING DArtefTechnologyAm-Sci1-1
13335: PPUSH
13336: CALL_OW 88
// if IsOk ( Burlak ) then
13340: LD_EXP 52
13344: PPUSH
13345: CALL_OW 302
13349: IFFALSE 13363
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13351: LD_EXP 52
13355: PPUSH
13356: LD_STRING DArtefTechnologyAm-Bur-1
13358: PPUSH
13359: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13363: LD_EXP 19
13367: PPUSH
13368: LD_STRING DArtefTechnologyAm-JMM-1
13370: PPUSH
13371: CALL_OW 88
// DialogueOff ;
13375: CALL_OW 7
// end ;
13379: PPOPN 1
13381: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13382: LD_EXP 13
13386: IFFALSE 13588
13388: GO 13390
13390: DISABLE
13391: LD_INT 0
13393: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13394: LD_ADDR_VAR 0 1
13398: PUSH
13399: LD_INT 22
13401: PUSH
13402: LD_INT 7
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PUSH
13409: LD_INT 23
13411: PUSH
13412: LD_INT 3
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: LD_INT 25
13421: PUSH
13422: LD_INT 4
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PUSH
13429: LD_INT 21
13431: PUSH
13432: LD_INT 1
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PUSH
13439: LD_INT 26
13441: PUSH
13442: LD_INT 1
13444: PUSH
13445: EMPTY
13446: LIST
13447: LIST
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: LIST
13455: PPUSH
13456: CALL_OW 69
13460: PUSH
13461: LD_EXP 20
13465: PUSH
13466: LD_EXP 19
13470: PUSH
13471: LD_EXP 52
13475: PUSH
13476: LD_EXP 40
13480: PUSH
13481: LD_EXP 50
13485: PUSH
13486: LD_EXP 49
13490: PUSH
13491: EMPTY
13492: LIST
13493: LIST
13494: LIST
13495: LIST
13496: LIST
13497: LIST
13498: DIFF
13499: ST_TO_ADDR
// if not speaker then
13500: LD_VAR 0 1
13504: NOT
13505: IFFALSE 13509
// exit ;
13507: GO 13588
// DialogueOn ;
13509: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13513: LD_VAR 0 1
13517: PUSH
13518: LD_VAR 0 1
13522: ARRAY
13523: PPUSH
13524: LD_STRING DArtefTechnologyRu-RSci1-1
13526: PPUSH
13527: CALL_OW 88
// if IsOk ( Burlak ) then
13531: LD_EXP 52
13535: PPUSH
13536: CALL_OW 302
13540: IFFALSE 13554
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13542: LD_EXP 52
13546: PPUSH
13547: LD_STRING DArtefTechnologyRu-Bur-1
13549: PPUSH
13550: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13554: LD_VAR 0 1
13558: PUSH
13559: LD_VAR 0 1
13563: ARRAY
13564: PPUSH
13565: LD_STRING DArtefTechnologyRu-RSci1-2
13567: PPUSH
13568: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13572: LD_EXP 19
13576: PPUSH
13577: LD_STRING DArtefTechnologyRu-JMM-1
13579: PPUSH
13580: CALL_OW 88
// DialogueOff ;
13584: CALL_OW 7
// end ;
13588: PPOPN 1
13590: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13591: LD_INT 24
13593: PPUSH
13594: LD_INT 7
13596: PPUSH
13597: CALL_OW 321
13601: PUSH
13602: LD_INT 2
13604: EQUAL
13605: PUSH
13606: LD_INT 1
13608: PPUSH
13609: CALL_OW 255
13613: PUSH
13614: LD_INT 7
13616: EQUAL
13617: AND
13618: IFFALSE 13786
13620: GO 13622
13622: DISABLE
13623: LD_INT 0
13625: PPUSH
// begin if Denis then
13626: LD_EXP 25
13630: IFFALSE 13647
// speaker := [ Denis ] else
13632: LD_ADDR_VAR 0 1
13636: PUSH
13637: LD_EXP 25
13641: PUSH
13642: EMPTY
13643: LIST
13644: ST_TO_ADDR
13645: GO 13753
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13647: LD_ADDR_VAR 0 1
13651: PUSH
13652: LD_INT 22
13654: PUSH
13655: LD_INT 7
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: PUSH
13662: LD_INT 23
13664: PUSH
13665: LD_INT 1
13667: PUSH
13668: EMPTY
13669: LIST
13670: LIST
13671: PUSH
13672: LD_INT 25
13674: PUSH
13675: LD_INT 4
13677: PUSH
13678: EMPTY
13679: LIST
13680: LIST
13681: PUSH
13682: LD_INT 21
13684: PUSH
13685: LD_INT 1
13687: PUSH
13688: EMPTY
13689: LIST
13690: LIST
13691: PUSH
13692: LD_INT 26
13694: PUSH
13695: LD_INT 1
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PUSH
13702: EMPTY
13703: LIST
13704: LIST
13705: LIST
13706: LIST
13707: LIST
13708: PPUSH
13709: CALL_OW 69
13713: PUSH
13714: LD_EXP 20
13718: PUSH
13719: LD_EXP 19
13723: PUSH
13724: LD_EXP 52
13728: PUSH
13729: LD_EXP 40
13733: PUSH
13734: LD_EXP 50
13738: PUSH
13739: LD_EXP 49
13743: PUSH
13744: EMPTY
13745: LIST
13746: LIST
13747: LIST
13748: LIST
13749: LIST
13750: LIST
13751: DIFF
13752: ST_TO_ADDR
// if not speaker then
13753: LD_VAR 0 1
13757: NOT
13758: IFFALSE 13762
// exit ;
13760: GO 13786
// DialogueOn ;
13762: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13766: LD_VAR 0 1
13770: PUSH
13771: LD_INT 1
13773: ARRAY
13774: PPUSH
13775: LD_STRING DArtefTechnologyArStart-Sci1-1
13777: PPUSH
13778: CALL_OW 88
// DialogueOff ;
13782: CALL_OW 7
// end ;
13786: PPOPN 1
13788: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13789: LD_EXP 14
13793: IFFALSE 14074
13795: GO 13797
13797: DISABLE
13798: LD_INT 0
13800: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13801: LD_ADDR_VAR 0 1
13805: PUSH
13806: LD_INT 22
13808: PUSH
13809: LD_INT 7
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PUSH
13816: LD_INT 23
13818: PUSH
13819: LD_INT 3
13821: PUSH
13822: EMPTY
13823: LIST
13824: LIST
13825: PUSH
13826: LD_INT 25
13828: PUSH
13829: LD_INT 4
13831: PUSH
13832: EMPTY
13833: LIST
13834: LIST
13835: PUSH
13836: LD_INT 21
13838: PUSH
13839: LD_INT 1
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: PUSH
13846: LD_INT 26
13848: PUSH
13849: LD_INT 1
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PUSH
13856: EMPTY
13857: LIST
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: PPUSH
13863: CALL_OW 69
13867: PUSH
13868: LD_EXP 20
13872: PUSH
13873: LD_EXP 19
13877: PUSH
13878: LD_EXP 52
13882: PUSH
13883: LD_EXP 40
13887: PUSH
13888: LD_EXP 50
13892: PUSH
13893: LD_EXP 49
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: DIFF
13906: ST_TO_ADDR
// if not speaker then
13907: LD_VAR 0 1
13911: NOT
13912: IFFALSE 13916
// exit ;
13914: GO 14074
// DialogueOn ;
13916: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13920: LD_VAR 0 1
13924: PUSH
13925: LD_INT 1
13927: ARRAY
13928: PPUSH
13929: LD_STRING DArtefTechnologyAr-RSci1-1
13931: PPUSH
13932: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13936: LD_EXP 19
13940: PPUSH
13941: LD_STRING DArtefTechnologyAr-JMM-1
13943: PPUSH
13944: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13948: LD_VAR 0 1
13952: PUSH
13953: LD_INT 1
13955: ARRAY
13956: PPUSH
13957: LD_STRING DArtefTechnologyAr-RSci1-2
13959: PPUSH
13960: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13964: LD_EXP 19
13968: PPUSH
13969: LD_STRING DArtefTechnologyAr-JMM-2
13971: PPUSH
13972: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13976: LD_VAR 0 1
13980: PUSH
13981: LD_INT 1
13983: ARRAY
13984: PPUSH
13985: LD_STRING DArtefTechnologyAr-RSci1-3
13987: PPUSH
13988: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13992: LD_EXP 19
13996: PPUSH
13997: LD_STRING DArtefTechnologyAr-JMM-3
13999: PPUSH
14000: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14004: LD_VAR 0 1
14008: PUSH
14009: LD_INT 1
14011: ARRAY
14012: PPUSH
14013: LD_STRING DArtefTechnologyAr-RSci1-4
14015: PPUSH
14016: CALL_OW 88
// if IsOk ( Burlak ) then
14020: LD_EXP 52
14024: PPUSH
14025: CALL_OW 302
14029: IFFALSE 14043
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14031: LD_EXP 52
14035: PPUSH
14036: LD_STRING DArtefTechnologyAr-Bur-4
14038: PPUSH
14039: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14043: LD_EXP 19
14047: PPUSH
14048: LD_STRING DArtefTechnologyAr-JMM-4
14050: PPUSH
14051: CALL_OW 88
// DialogueOff ;
14055: CALL_OW 7
// wait ( 0 0$45 ) ;
14059: LD_INT 1575
14061: PPUSH
14062: CALL_OW 67
// spawnOmar := true ;
14066: LD_ADDR_EXP 11
14070: PUSH
14071: LD_INT 1
14073: ST_TO_ADDR
// end ;
14074: PPOPN 1
14076: END
// every 0 0$1 trigger spawnOmar do
14077: LD_EXP 11
14081: IFFALSE 14461
14083: GO 14085
14085: DISABLE
// begin PrepareOmarAli ;
14086: CALL 7298 0 0
// if not HasTask ( Omar ) then
14090: LD_EXP 56
14094: PPUSH
14095: CALL_OW 314
14099: NOT
14100: IFFALSE 14117
// ComMoveXY ( Omar , 252 , 220 ) ;
14102: LD_EXP 56
14106: PPUSH
14107: LD_INT 252
14109: PPUSH
14110: LD_INT 220
14112: PPUSH
14113: CALL_OW 111
// if not Omar then
14117: LD_EXP 56
14121: NOT
14122: IFFALSE 14126
// exit ;
14124: GO 14461
// repeat wait ( 0 0$1 ) ;
14126: LD_INT 35
14128: PPUSH
14129: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14133: LD_EXP 56
14137: PPUSH
14138: CALL_OW 314
14142: NOT
14143: PUSH
14144: LD_EXP 56
14148: PPUSH
14149: LD_INT 252
14151: PPUSH
14152: LD_INT 220
14154: PPUSH
14155: CALL_OW 297
14159: PUSH
14160: LD_INT 6
14162: GREATER
14163: AND
14164: IFFALSE 14181
// ComMoveXY ( Omar , 252 , 220 ) ;
14166: LD_EXP 56
14170: PPUSH
14171: LD_INT 252
14173: PPUSH
14174: LD_INT 220
14176: PPUSH
14177: CALL_OW 111
// until See ( 7 , Omar ) ;
14181: LD_INT 7
14183: PPUSH
14184: LD_EXP 56
14188: PPUSH
14189: CALL_OW 292
14193: IFFALSE 14126
// CenterNowOnUnits ( Omar ) ;
14195: LD_EXP 56
14199: PPUSH
14200: CALL_OW 87
// DialogueOn ;
14204: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14208: LD_EXP 56
14212: PPUSH
14213: LD_STRING DOmar-Omar-1
14215: PPUSH
14216: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14220: LD_EXP 19
14224: PPUSH
14225: LD_STRING DOmar-JMM-1
14227: PPUSH
14228: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14232: LD_EXP 56
14236: PPUSH
14237: LD_STRING DOmar-Omar-2
14239: PPUSH
14240: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14244: LD_EXP 19
14248: PPUSH
14249: LD_STRING DOmar-JMM-2
14251: PPUSH
14252: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14256: LD_EXP 56
14260: PPUSH
14261: LD_STRING DOmar-Omar-3
14263: PPUSH
14264: CALL_OW 88
// if IsOk ( Burlak ) then
14268: LD_EXP 52
14272: PPUSH
14273: CALL_OW 302
14277: IFFALSE 14293
// Say ( Burlak , DOmar-Bur-3 ) else
14279: LD_EXP 52
14283: PPUSH
14284: LD_STRING DOmar-Bur-3
14286: PPUSH
14287: CALL_OW 88
14291: GO 14305
// Say ( JMM , DOmar-JMM-3 ) ;
14293: LD_EXP 19
14297: PPUSH
14298: LD_STRING DOmar-JMM-3
14300: PPUSH
14301: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14305: LD_EXP 56
14309: PPUSH
14310: LD_STRING DOmar-Omar-4
14312: PPUSH
14313: CALL_OW 88
// case Query ( QAccept ) of 1 :
14317: LD_STRING QAccept
14319: PPUSH
14320: CALL_OW 97
14324: PUSH
14325: LD_INT 1
14327: DOUBLE
14328: EQUAL
14329: IFTRUE 14333
14331: GO 14369
14333: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14334: LD_EXP 19
14338: PPUSH
14339: LD_STRING DQrAccept#1-JMM-1
14341: PPUSH
14342: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14346: LD_EXP 56
14350: PPUSH
14351: LD_INT 7
14353: PPUSH
14354: CALL_OW 235
// ComStop ( Omar ) ;
14358: LD_EXP 56
14362: PPUSH
14363: CALL_OW 141
// end ; 2 :
14367: GO 14418
14369: LD_INT 2
14371: DOUBLE
14372: EQUAL
14373: IFTRUE 14377
14375: GO 14417
14377: POP
// begin if IsOk ( Burlak ) then
14378: LD_EXP 52
14382: PPUSH
14383: CALL_OW 302
14387: IFFALSE 14403
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14389: LD_EXP 52
14393: PPUSH
14394: LD_STRING DQrAccept#2-Bur-1
14396: PPUSH
14397: CALL_OW 88
14401: GO 14415
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14403: LD_EXP 19
14407: PPUSH
14408: LD_STRING DQrAccept#2-JMM-1
14410: PPUSH
14411: CALL_OW 88
// end ; end ;
14415: GO 14418
14417: POP
// DialogueOff ;
14418: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14422: LD_EXP 56
14426: PPUSH
14427: CALL_OW 255
14431: PUSH
14432: LD_INT 7
14434: EQUAL
14435: IFFALSE 14446
// begin SetAchievement ( ACH_OMAR ) ;
14437: LD_STRING ACH_OMAR
14439: PPUSH
14440: CALL_OW 543
// exit ;
14444: GO 14461
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14446: LD_EXP 56
14450: PPUSH
14451: LD_INT 202
14453: PPUSH
14454: LD_INT 115
14456: PPUSH
14457: CALL_OW 111
// end ;
14461: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14462: LD_EXP 56
14466: PPUSH
14467: LD_INT 200
14469: PPUSH
14470: LD_INT 98
14472: PPUSH
14473: CALL_OW 297
14477: PUSH
14478: LD_INT 40
14480: LESS
14481: PUSH
14482: LD_EXP 2
14486: AND
14487: IFFALSE 14705
14489: GO 14491
14491: DISABLE
// begin SetSide ( Omar , 5 ) ;
14492: LD_EXP 56
14496: PPUSH
14497: LD_INT 5
14499: PPUSH
14500: CALL_OW 235
// if IsInUnit ( Omar ) then
14504: LD_EXP 56
14508: PPUSH
14509: CALL_OW 310
14513: IFFALSE 14524
// ComExitVehicle ( Omar ) ;
14515: LD_EXP 56
14519: PPUSH
14520: CALL_OW 121
// if IsInUnit ( Omar ) then
14524: LD_EXP 56
14528: PPUSH
14529: CALL_OW 310
14533: IFFALSE 14544
// ComExitBuilding ( Omar ) ;
14535: LD_EXP 56
14539: PPUSH
14540: CALL_OW 122
// wait ( 0 0$1 ) ;
14544: LD_INT 35
14546: PPUSH
14547: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14551: LD_EXP 56
14555: PPUSH
14556: LD_INT 203
14558: PPUSH
14559: LD_INT 120
14561: PPUSH
14562: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14566: LD_INT 35
14568: PPUSH
14569: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14573: LD_EXP 56
14577: PPUSH
14578: CALL_OW 306
14582: PUSH
14583: LD_EXP 56
14587: PPUSH
14588: LD_INT 203
14590: PPUSH
14591: LD_INT 120
14593: PPUSH
14594: CALL_OW 297
14598: PUSH
14599: LD_INT 6
14601: LESS
14602: OR
14603: IFFALSE 14566
// CenterNowOnUnits ( Omar ) ;
14605: LD_EXP 56
14609: PPUSH
14610: CALL_OW 87
// DialogueOn ;
14614: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14618: LD_EXP 19
14622: PPUSH
14623: LD_STRING DOmarContam-JMM-1
14625: PPUSH
14626: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14630: LD_EXP 56
14634: PPUSH
14635: LD_STRING DOmarContam-Omar-1
14637: PPUSH
14638: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14642: LD_EXP 19
14646: PPUSH
14647: LD_STRING DOmarContam-JMM-2
14649: PPUSH
14650: CALL_OW 88
// DialogueOff ;
14654: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14658: LD_INT 5
14660: PPUSH
14661: LD_INT 7
14663: PPUSH
14664: LD_INT 2
14666: PPUSH
14667: LD_INT 1
14669: PPUSH
14670: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14674: LD_INT 105
14676: PPUSH
14677: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14681: LD_EXP 56
14685: PPUSH
14686: LD_INT 203
14688: PPUSH
14689: LD_INT 120
14691: PPUSH
14692: CALL_OW 307
14696: IFFALSE 14674
// YouLost ( MothContaminate ) ;
14698: LD_STRING MothContaminate
14700: PPUSH
14701: CALL_OW 104
// end ;
14705: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14706: LD_EXP 4
14710: NOT
14711: PUSH
14712: LD_INT 22
14714: PUSH
14715: LD_INT 1
14717: PUSH
14718: EMPTY
14719: LIST
14720: LIST
14721: PUSH
14722: LD_INT 34
14724: PUSH
14725: LD_INT 8
14727: PUSH
14728: EMPTY
14729: LIST
14730: LIST
14731: PUSH
14732: EMPTY
14733: LIST
14734: LIST
14735: PPUSH
14736: CALL_OW 69
14740: AND
14741: IFFALSE 14860
14743: GO 14745
14745: DISABLE
// begin wait ( 0 0$5 ) ;
14746: LD_INT 175
14748: PPUSH
14749: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14753: LD_EXP 55
14757: PPUSH
14758: CALL_OW 302
14762: NOT
14763: PUSH
14764: LD_INT 22
14766: PUSH
14767: LD_INT 1
14769: PUSH
14770: EMPTY
14771: LIST
14772: LIST
14773: PUSH
14774: LD_INT 34
14776: PUSH
14777: LD_INT 8
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: PPUSH
14788: CALL_OW 69
14792: NOT
14793: OR
14794: IFFALSE 14798
// exit ;
14796: GO 14860
// DialogueOn ;
14798: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14802: LD_EXP 55
14806: PPUSH
14807: LD_STRING DWinAmericans-Pow-1
14809: PPUSH
14810: CALL_OW 94
// if IsOk ( Burlak ) then
14814: LD_EXP 52
14818: PPUSH
14819: CALL_OW 302
14823: IFFALSE 14837
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14825: LD_EXP 52
14829: PPUSH
14830: LD_STRING DWinAmericans-Bur-1
14832: PPUSH
14833: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14837: LD_EXP 19
14841: PPUSH
14842: LD_STRING DWinAmericans-JMM-1
14844: PPUSH
14845: CALL_OW 88
// DialogueOff ;
14849: CALL_OW 7
// YouLost ( AmBomb ) ;
14853: LD_STRING AmBomb
14855: PPUSH
14856: CALL_OW 104
// end ;
14860: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14861: LD_EXP 2
14865: NOT
14866: PUSH
14867: LD_INT 22
14869: PUSH
14870: LD_INT 3
14872: PUSH
14873: EMPTY
14874: LIST
14875: LIST
14876: PUSH
14877: LD_INT 34
14879: PUSH
14880: LD_INT 48
14882: PUSH
14883: EMPTY
14884: LIST
14885: LIST
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: PPUSH
14891: CALL_OW 69
14895: AND
14896: IFFALSE 15015
14898: GO 14900
14900: DISABLE
// begin wait ( 0 0$5 ) ;
14901: LD_INT 175
14903: PPUSH
14904: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14908: LD_EXP 60
14912: PPUSH
14913: CALL_OW 302
14917: NOT
14918: PUSH
14919: LD_INT 22
14921: PUSH
14922: LD_INT 3
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PUSH
14929: LD_INT 34
14931: PUSH
14932: LD_INT 48
14934: PUSH
14935: EMPTY
14936: LIST
14937: LIST
14938: PUSH
14939: EMPTY
14940: LIST
14941: LIST
14942: PPUSH
14943: CALL_OW 69
14947: NOT
14948: OR
14949: IFFALSE 14953
// exit ;
14951: GO 15015
// DialogueOn ;
14953: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14957: LD_EXP 60
14961: PPUSH
14962: LD_STRING DWinRussians-Pla-1
14964: PPUSH
14965: CALL_OW 94
// if IsOk ( Burlak ) then
14969: LD_EXP 52
14973: PPUSH
14974: CALL_OW 302
14978: IFFALSE 14992
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14980: LD_EXP 52
14984: PPUSH
14985: LD_STRING DWinRussians-Bur-1
14987: PPUSH
14988: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14992: LD_EXP 19
14996: PPUSH
14997: LD_STRING DWinRussians-JMM-1
14999: PPUSH
15000: CALL_OW 88
// DialogueOff ;
15004: CALL_OW 7
// YouLost ( RuBomb ) ;
15008: LD_STRING RuBomb
15010: PPUSH
15011: CALL_OW 104
// end ;
15015: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
15016: LD_INT 7
15018: PPUSH
15019: LD_INT 22
15021: PUSH
15022: LD_INT 7
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: PPUSH
15029: CALL_OW 70
15033: PUSH
15034: LD_EXP 4
15038: NOT
15039: AND
15040: IFFALSE 15069
15042: GO 15044
15044: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
15045: LD_EXP 55
15049: PPUSH
15050: LD_STRING DSurrenderAmericans-Pow-1
15052: PPUSH
15053: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
15057: LD_EXP 19
15061: PPUSH
15062: LD_STRING DSurrenderAmericans-JMM-1
15064: PPUSH
15065: CALL_OW 88
// end ;
15069: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
15070: LD_INT 2
15072: PPUSH
15073: LD_INT 22
15075: PUSH
15076: LD_INT 7
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PPUSH
15083: CALL_OW 70
15087: PUSH
15088: LD_EXP 2
15092: NOT
15093: AND
15094: PUSH
15095: LD_EXP 52
15099: AND
15100: IFFALSE 15129
15102: GO 15104
15104: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
15105: LD_EXP 60
15109: PPUSH
15110: LD_STRING DSurrenderRussians-Pla-1
15112: PPUSH
15113: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15117: LD_EXP 52
15121: PPUSH
15122: LD_STRING DSurrenderRussians-Bur-1
15124: PPUSH
15125: CALL_OW 88
// end ;
15129: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
15130: LD_EXP 4
15134: IFFALSE 15517
15136: GO 15138
15138: DISABLE
15139: LD_INT 0
15141: PPUSH
15142: PPUSH
15143: PPUSH
// begin MC_Kill ( 4 ) ;
15144: LD_INT 4
15146: PPUSH
15147: CALL 21775 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
15151: LD_INT 1
15153: PPUSH
15154: LD_INT 7
15156: PPUSH
15157: LD_INT 1
15159: PPUSH
15160: LD_INT 1
15162: PPUSH
15163: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
15167: LD_ADDR_VAR 0 3
15171: PUSH
15172: LD_INT 22
15174: PUSH
15175: LD_INT 1
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: PUSH
15182: LD_INT 26
15184: PUSH
15185: LD_INT 1
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: PUSH
15192: LD_INT 23
15194: PUSH
15195: LD_INT 1
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: LIST
15206: PPUSH
15207: CALL_OW 69
15211: PUSH
15212: LD_EXP 55
15216: PUSH
15217: LD_EXP 27
15221: PUSH
15222: LD_EXP 24
15226: PUSH
15227: LD_EXP 23
15231: PUSH
15232: LD_EXP 30
15236: PUSH
15237: LD_EXP 28
15241: PUSH
15242: EMPTY
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: DIFF
15250: ST_TO_ADDR
// if speaker then
15251: LD_VAR 0 3
15255: IFFALSE 15281
// begin DialogueOn ;
15257: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
15261: LD_VAR 0 3
15265: PUSH
15266: LD_INT 1
15268: ARRAY
15269: PPUSH
15270: LD_STRING DSurrenderAmericans-Sol1-1a
15272: PPUSH
15273: CALL_OW 94
// DialogueOff ;
15277: CALL_OW 7
// end ; americanCapitulated := true ;
15281: LD_ADDR_EXP 6
15285: PUSH
15286: LD_INT 1
15288: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15289: LD_ADDR_VAR 0 2
15293: PUSH
15294: LD_INT 22
15296: PUSH
15297: LD_INT 1
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: PUSH
15304: LD_INT 21
15306: PUSH
15307: LD_INT 1
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PPUSH
15318: CALL_OW 69
15322: PUSH
15323: LD_INT 22
15325: PUSH
15326: LD_INT 1
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: PUSH
15333: LD_INT 21
15335: PUSH
15336: LD_INT 2
15338: PUSH
15339: EMPTY
15340: LIST
15341: LIST
15342: PUSH
15343: LD_INT 1
15345: PUSH
15346: EMPTY
15347: LIST
15348: PUSH
15349: EMPTY
15350: LIST
15351: LIST
15352: LIST
15353: PPUSH
15354: CALL_OW 69
15358: ADD
15359: ST_TO_ADDR
// if tmp then
15360: LD_VAR 0 2
15364: IFFALSE 15517
// repeat wait ( 0 0$1 ) ;
15366: LD_INT 35
15368: PPUSH
15369: CALL_OW 67
// for i in tmp do
15373: LD_ADDR_VAR 0 1
15377: PUSH
15378: LD_VAR 0 2
15382: PUSH
15383: FOR_IN
15384: IFFALSE 15466
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15386: LD_VAR 0 1
15390: PPUSH
15391: CALL_OW 310
15395: PUSH
15396: LD_VAR 0 1
15400: PPUSH
15401: CALL_OW 310
15405: PPUSH
15406: CALL_OW 247
15410: PUSH
15411: LD_INT 3
15413: EQUAL
15414: AND
15415: IFFALSE 15426
// ComExitBuilding ( i ) ;
15417: LD_VAR 0 1
15421: PPUSH
15422: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15426: LD_VAR 0 1
15430: PPUSH
15431: LD_INT 122
15433: PPUSH
15434: LD_INT 242
15436: PPUSH
15437: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15441: LD_VAR 0 1
15445: PPUSH
15446: LD_INT 35
15448: PPUSH
15449: CALL_OW 308
15453: IFFALSE 15464
// RemoveUnit ( i ) ;
15455: LD_VAR 0 1
15459: PPUSH
15460: CALL_OW 64
// end ;
15464: GO 15383
15466: POP
15467: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15468: LD_INT 22
15470: PUSH
15471: LD_INT 1
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: PUSH
15478: LD_INT 2
15480: PUSH
15481: LD_INT 21
15483: PUSH
15484: LD_INT 1
15486: PUSH
15487: EMPTY
15488: LIST
15489: LIST
15490: PUSH
15491: LD_INT 33
15493: PUSH
15494: LD_INT 1
15496: PUSH
15497: EMPTY
15498: LIST
15499: LIST
15500: PUSH
15501: EMPTY
15502: LIST
15503: LIST
15504: LIST
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PPUSH
15510: CALL_OW 69
15514: NOT
15515: IFFALSE 15366
// end ;
15517: PPOPN 3
15519: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15520: LD_EXP 2
15524: IFFALSE 15925
15526: GO 15528
15528: DISABLE
15529: LD_INT 0
15531: PPUSH
15532: PPUSH
15533: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15534: LD_INT 35
15536: PPUSH
15537: CALL_OW 67
// until IsDead ( Yakotich ) ;
15541: LD_EXP 61
15545: PPUSH
15546: CALL_OW 301
15550: IFFALSE 15534
// MC_Kill ( 2 ) ;
15552: LD_INT 2
15554: PPUSH
15555: CALL 21775 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15559: LD_INT 3
15561: PPUSH
15562: LD_INT 7
15564: PPUSH
15565: LD_INT 1
15567: PPUSH
15568: LD_INT 1
15570: PPUSH
15571: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15575: LD_ADDR_VAR 0 3
15579: PUSH
15580: LD_INT 22
15582: PUSH
15583: LD_INT 3
15585: PUSH
15586: EMPTY
15587: LIST
15588: LIST
15589: PUSH
15590: LD_INT 26
15592: PUSH
15593: LD_INT 1
15595: PUSH
15596: EMPTY
15597: LIST
15598: LIST
15599: PUSH
15600: LD_INT 23
15602: PUSH
15603: LD_INT 3
15605: PUSH
15606: EMPTY
15607: LIST
15608: LIST
15609: PUSH
15610: EMPTY
15611: LIST
15612: LIST
15613: LIST
15614: PPUSH
15615: CALL_OW 69
15619: PUSH
15620: LD_EXP 60
15624: PUSH
15625: LD_EXP 61
15629: PUSH
15630: EMPTY
15631: LIST
15632: LIST
15633: DIFF
15634: ST_TO_ADDR
// if speaker then
15635: LD_VAR 0 3
15639: IFFALSE 15689
// begin DialogueOn ;
15641: CALL_OW 6
// if Burlak then
15645: LD_EXP 52
15649: IFFALSE 15669
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15651: LD_VAR 0 3
15655: PUSH
15656: LD_INT 1
15658: ARRAY
15659: PPUSH
15660: LD_STRING DSurrenderRussians-RSol1-1
15662: PPUSH
15663: CALL_OW 94
15667: GO 15685
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15669: LD_VAR 0 3
15673: PUSH
15674: LD_INT 1
15676: ARRAY
15677: PPUSH
15678: LD_STRING DSurrenderRussians-RSol1-1a
15680: PPUSH
15681: CALL_OW 94
// DialogueOff ;
15685: CALL_OW 7
// end ; russianCapitulated := true ;
15689: LD_ADDR_EXP 7
15693: PUSH
15694: LD_INT 1
15696: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15697: LD_ADDR_VAR 0 2
15701: PUSH
15702: LD_INT 22
15704: PUSH
15705: LD_INT 3
15707: PUSH
15708: EMPTY
15709: LIST
15710: LIST
15711: PUSH
15712: LD_INT 21
15714: PUSH
15715: LD_INT 1
15717: PUSH
15718: EMPTY
15719: LIST
15720: LIST
15721: PUSH
15722: EMPTY
15723: LIST
15724: LIST
15725: PPUSH
15726: CALL_OW 69
15730: PUSH
15731: LD_INT 22
15733: PUSH
15734: LD_INT 3
15736: PUSH
15737: EMPTY
15738: LIST
15739: LIST
15740: PUSH
15741: LD_INT 21
15743: PUSH
15744: LD_INT 2
15746: PUSH
15747: EMPTY
15748: LIST
15749: LIST
15750: PUSH
15751: LD_INT 1
15753: PUSH
15754: EMPTY
15755: LIST
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: LIST
15761: PPUSH
15762: CALL_OW 69
15766: ADD
15767: ST_TO_ADDR
// if tmp then
15768: LD_VAR 0 2
15772: IFFALSE 15925
// repeat wait ( 0 0$1 ) ;
15774: LD_INT 35
15776: PPUSH
15777: CALL_OW 67
// for i in tmp do
15781: LD_ADDR_VAR 0 1
15785: PUSH
15786: LD_VAR 0 2
15790: PUSH
15791: FOR_IN
15792: IFFALSE 15874
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15794: LD_VAR 0 1
15798: PPUSH
15799: CALL_OW 310
15803: PUSH
15804: LD_VAR 0 1
15808: PPUSH
15809: CALL_OW 310
15813: PPUSH
15814: CALL_OW 247
15818: PUSH
15819: LD_INT 3
15821: EQUAL
15822: AND
15823: IFFALSE 15834
// ComExitBuilding ( i ) ;
15825: LD_VAR 0 1
15829: PPUSH
15830: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15834: LD_VAR 0 1
15838: PPUSH
15839: LD_INT 154
15841: PPUSH
15842: LD_INT 1
15844: PPUSH
15845: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15849: LD_VAR 0 1
15853: PPUSH
15854: LD_INT 36
15856: PPUSH
15857: CALL_OW 308
15861: IFFALSE 15872
// RemoveUnit ( i ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 64
// end ;
15872: GO 15791
15874: POP
15875: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15876: LD_INT 22
15878: PUSH
15879: LD_INT 3
15881: PUSH
15882: EMPTY
15883: LIST
15884: LIST
15885: PUSH
15886: LD_INT 2
15888: PUSH
15889: LD_INT 21
15891: PUSH
15892: LD_INT 1
15894: PUSH
15895: EMPTY
15896: LIST
15897: LIST
15898: PUSH
15899: LD_INT 33
15901: PUSH
15902: LD_INT 1
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: LIST
15913: PUSH
15914: EMPTY
15915: LIST
15916: LIST
15917: PPUSH
15918: CALL_OW 69
15922: NOT
15923: IFFALSE 15774
// end ;
15925: PPOPN 3
15927: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15928: LD_INT 22
15930: PUSH
15931: LD_INT 8
15933: PUSH
15934: EMPTY
15935: LIST
15936: LIST
15937: PUSH
15938: LD_INT 21
15940: PUSH
15941: LD_INT 1
15943: PUSH
15944: EMPTY
15945: LIST
15946: LIST
15947: PUSH
15948: LD_INT 23
15950: PUSH
15951: LD_INT 2
15953: PUSH
15954: EMPTY
15955: LIST
15956: LIST
15957: PUSH
15958: EMPTY
15959: LIST
15960: LIST
15961: LIST
15962: PPUSH
15963: CALL_OW 69
15967: PUSH
15968: LD_INT 18
15970: LESS
15971: PUSH
15972: LD_EXP 58
15976: PPUSH
15977: CALL_OW 301
15981: OR
15982: PUSH
15983: LD_INT 324
15985: PPUSH
15986: CALL_OW 255
15990: PUSH
15991: LD_INT 7
15993: EQUAL
15994: OR
15995: IFFALSE 16008
15997: GO 15999
15999: DISABLE
// legionDestroyed := true ;
16000: LD_ADDR_EXP 3
16004: PUSH
16005: LD_INT 1
16007: ST_TO_ADDR
16008: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
16009: LD_INT 22
16011: PUSH
16012: LD_INT 2
16014: PUSH
16015: EMPTY
16016: LIST
16017: LIST
16018: PUSH
16019: LD_INT 21
16021: PUSH
16022: LD_INT 1
16024: PUSH
16025: EMPTY
16026: LIST
16027: LIST
16028: PUSH
16029: LD_INT 23
16031: PUSH
16032: LD_INT 2
16034: PUSH
16035: EMPTY
16036: LIST
16037: LIST
16038: PUSH
16039: EMPTY
16040: LIST
16041: LIST
16042: LIST
16043: PPUSH
16044: CALL_OW 69
16048: PUSH
16049: LD_INT 9
16051: LESS
16052: IFFALSE 16065
16054: GO 16056
16056: DISABLE
// arabianDestroyed := true ;
16057: LD_ADDR_EXP 5
16061: PUSH
16062: LD_INT 1
16064: ST_TO_ADDR
16065: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
16066: LD_EXP 5
16070: IFFALSE 16314
16072: GO 16074
16074: DISABLE
16075: LD_INT 0
16077: PPUSH
16078: PPUSH
// begin MC_Kill ( 1 ) ;
16079: LD_INT 1
16081: PPUSH
16082: CALL 21775 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16086: LD_ADDR_VAR 0 2
16090: PUSH
16091: LD_INT 22
16093: PUSH
16094: LD_INT 2
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: LD_INT 21
16103: PUSH
16104: LD_INT 1
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: PUSH
16111: EMPTY
16112: LIST
16113: LIST
16114: PPUSH
16115: CALL_OW 69
16119: PUSH
16120: LD_INT 22
16122: PUSH
16123: LD_INT 8
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: PUSH
16130: LD_INT 21
16132: PUSH
16133: LD_INT 2
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: PUSH
16140: LD_INT 1
16142: PUSH
16143: EMPTY
16144: LIST
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: LIST
16150: PPUSH
16151: CALL_OW 69
16155: ADD
16156: ST_TO_ADDR
// if tmp then
16157: LD_VAR 0 2
16161: IFFALSE 16314
// repeat wait ( 0 0$1 ) ;
16163: LD_INT 35
16165: PPUSH
16166: CALL_OW 67
// for i in tmp do
16170: LD_ADDR_VAR 0 1
16174: PUSH
16175: LD_VAR 0 2
16179: PUSH
16180: FOR_IN
16181: IFFALSE 16263
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16183: LD_VAR 0 1
16187: PPUSH
16188: CALL_OW 310
16192: PUSH
16193: LD_VAR 0 1
16197: PPUSH
16198: CALL_OW 310
16202: PPUSH
16203: CALL_OW 247
16207: PUSH
16208: LD_INT 3
16210: EQUAL
16211: AND
16212: IFFALSE 16223
// ComExitBuilding ( i ) ;
16214: LD_VAR 0 1
16218: PPUSH
16219: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
16223: LD_VAR 0 1
16227: PPUSH
16228: LD_INT 254
16230: PPUSH
16231: LD_INT 268
16233: PPUSH
16234: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
16238: LD_VAR 0 1
16242: PPUSH
16243: LD_INT 34
16245: PPUSH
16246: CALL_OW 308
16250: IFFALSE 16261
// RemoveUnit ( i ) ;
16252: LD_VAR 0 1
16256: PPUSH
16257: CALL_OW 64
// end ;
16261: GO 16180
16263: POP
16264: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16265: LD_INT 22
16267: PUSH
16268: LD_INT 2
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: PUSH
16275: LD_INT 2
16277: PUSH
16278: LD_INT 21
16280: PUSH
16281: LD_INT 1
16283: PUSH
16284: EMPTY
16285: LIST
16286: LIST
16287: PUSH
16288: LD_INT 33
16290: PUSH
16291: LD_INT 1
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: PUSH
16298: EMPTY
16299: LIST
16300: LIST
16301: LIST
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: PPUSH
16307: CALL_OW 69
16311: NOT
16312: IFFALSE 16163
// end ;
16314: PPOPN 2
16316: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16317: LD_EXP 3
16321: IFFALSE 16673
16323: GO 16325
16325: DISABLE
16326: LD_INT 0
16328: PPUSH
16329: PPUSH
// begin MC_Kill ( 3 ) ;
16330: LD_INT 3
16332: PPUSH
16333: CALL 21775 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16337: LD_INT 8
16339: PPUSH
16340: LD_INT 7
16342: PPUSH
16343: LD_INT 1
16345: PPUSH
16346: LD_INT 1
16348: PPUSH
16349: CALL_OW 80
// DialogueOn ;
16353: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16357: LD_EXP 57
16361: PPUSH
16362: LD_STRING D15-Szulc-1
16364: PPUSH
16365: CALL_OW 94
// DialogueOff ;
16369: CALL_OW 7
// legionCapitulated := true ;
16373: LD_ADDR_EXP 8
16377: PUSH
16378: LD_INT 1
16380: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16381: LD_ADDR_VAR 0 1
16385: PUSH
16386: LD_INT 22
16388: PUSH
16389: LD_INT 8
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 21
16398: PUSH
16399: LD_INT 3
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PUSH
16406: LD_INT 23
16408: PUSH
16409: LD_INT 3
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: PPUSH
16421: CALL_OW 69
16425: PUSH
16426: FOR_IN
16427: IFFALSE 16443
// SetLives ( i , 3 ) ;
16429: LD_VAR 0 1
16433: PPUSH
16434: LD_INT 3
16436: PPUSH
16437: CALL_OW 234
16441: GO 16426
16443: POP
16444: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16445: LD_ADDR_VAR 0 2
16449: PUSH
16450: LD_INT 22
16452: PUSH
16453: LD_INT 8
16455: PUSH
16456: EMPTY
16457: LIST
16458: LIST
16459: PUSH
16460: LD_INT 21
16462: PUSH
16463: LD_INT 1
16465: PUSH
16466: EMPTY
16467: LIST
16468: LIST
16469: PUSH
16470: EMPTY
16471: LIST
16472: LIST
16473: PPUSH
16474: CALL_OW 69
16478: PUSH
16479: LD_INT 22
16481: PUSH
16482: LD_INT 8
16484: PUSH
16485: EMPTY
16486: LIST
16487: LIST
16488: PUSH
16489: LD_INT 21
16491: PUSH
16492: LD_INT 2
16494: PUSH
16495: EMPTY
16496: LIST
16497: LIST
16498: PUSH
16499: LD_INT 1
16501: PUSH
16502: EMPTY
16503: LIST
16504: PUSH
16505: EMPTY
16506: LIST
16507: LIST
16508: LIST
16509: PPUSH
16510: CALL_OW 69
16514: ADD
16515: ST_TO_ADDR
// if tmp then
16516: LD_VAR 0 2
16520: IFFALSE 16673
// repeat wait ( 0 0$1 ) ;
16522: LD_INT 35
16524: PPUSH
16525: CALL_OW 67
// for i in tmp do
16529: LD_ADDR_VAR 0 1
16533: PUSH
16534: LD_VAR 0 2
16538: PUSH
16539: FOR_IN
16540: IFFALSE 16622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16542: LD_VAR 0 1
16546: PPUSH
16547: CALL_OW 310
16551: PUSH
16552: LD_VAR 0 1
16556: PPUSH
16557: CALL_OW 310
16561: PPUSH
16562: CALL_OW 247
16566: PUSH
16567: LD_INT 3
16569: EQUAL
16570: AND
16571: IFFALSE 16582
// ComExitBuilding ( i ) ;
16573: LD_VAR 0 1
16577: PPUSH
16578: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16582: LD_VAR 0 1
16586: PPUSH
16587: LD_INT 10
16589: PPUSH
16590: LD_INT 1
16592: PPUSH
16593: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16597: LD_VAR 0 1
16601: PPUSH
16602: LD_INT 32
16604: PPUSH
16605: CALL_OW 308
16609: IFFALSE 16620
// RemoveUnit ( i ) ;
16611: LD_VAR 0 1
16615: PPUSH
16616: CALL_OW 64
// end ;
16620: GO 16539
16622: POP
16623: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16624: LD_INT 22
16626: PUSH
16627: LD_INT 8
16629: PUSH
16630: EMPTY
16631: LIST
16632: LIST
16633: PUSH
16634: LD_INT 2
16636: PUSH
16637: LD_INT 21
16639: PUSH
16640: LD_INT 1
16642: PUSH
16643: EMPTY
16644: LIST
16645: LIST
16646: PUSH
16647: LD_INT 33
16649: PUSH
16650: LD_INT 1
16652: PUSH
16653: EMPTY
16654: LIST
16655: LIST
16656: PUSH
16657: EMPTY
16658: LIST
16659: LIST
16660: LIST
16661: PUSH
16662: EMPTY
16663: LIST
16664: LIST
16665: PPUSH
16666: CALL_OW 69
16670: NOT
16671: IFFALSE 16522
// end ;
16673: PPOPN 2
16675: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 do
16676: LD_EXP 5
16680: NOT
16681: PUSH
16682: LD_OWVAR 1
16686: PUSH
16687: LD_INT 63000
16689: GREATEREQUAL
16690: AND
16691: IFFALSE 16700
16693: GO 16695
16695: DISABLE
// AllianceSupport ;
16696: CALL 4677 0 0
16700: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16701: LD_EXP 4
16705: PUSH
16706: LD_EXP 2
16710: AND
16711: PUSH
16712: LD_EXP 3
16716: AND
16717: PUSH
16718: LD_EXP 5
16722: AND
16723: PUSH
16724: LD_EXP 6
16728: AND
16729: PUSH
16730: LD_EXP 7
16734: AND
16735: PUSH
16736: LD_EXP 8
16740: AND
16741: PUSH
16742: LD_EXP 56
16746: PPUSH
16747: CALL_OW 255
16751: PUSH
16752: LD_INT 5
16754: NONEQUAL
16755: PUSH
16756: LD_EXP 56
16760: PPUSH
16761: CALL_OW 301
16765: OR
16766: PUSH
16767: LD_EXP 56
16771: PPUSH
16772: CALL_OW 305
16776: NOT
16777: OR
16778: AND
16779: IFFALSE 18181
16781: GO 16783
16783: DISABLE
16784: LD_INT 0
16786: PPUSH
16787: PPUSH
// begin wait ( 0 0$5 ) ;
16788: LD_INT 175
16790: PPUSH
16791: CALL_OW 67
// music_class := 5 ;
16795: LD_ADDR_OWVAR 72
16799: PUSH
16800: LD_INT 5
16802: ST_TO_ADDR
// music_nat := 5 ;
16803: LD_ADDR_OWVAR 71
16807: PUSH
16808: LD_INT 5
16810: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16811: LD_EXP 15
16815: PUSH
16816: LD_INT 3
16818: LESS
16819: IFFALSE 16828
// SetAchievement ( ACH_ECONOMY ) ;
16821: LD_STRING ACH_ECONOMY
16823: PPUSH
16824: CALL_OW 543
// if tick < 60 60$00 then
16828: LD_OWVAR 1
16832: PUSH
16833: LD_INT 126000
16835: LESS
16836: IFFALSE 16852
// begin wait ( 3 ) ;
16838: LD_INT 3
16840: PPUSH
16841: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16845: LD_STRING ACH_ASPEED_19
16847: PPUSH
16848: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16852: LD_EXP 19
16856: PPUSH
16857: CALL_OW 87
// InGameOn ;
16861: CALL_OW 8
// DialogueOn ;
16865: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16869: LD_EXP 19
16873: PPUSH
16874: LD_STRING DEnd-JMM-JMM-1
16876: PPUSH
16877: CALL_OW 88
// if Joan then
16881: LD_EXP 34
16885: IFFALSE 16901
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16887: LD_EXP 34
16891: PPUSH
16892: LD_STRING DEnd-JMM-Joan-1
16894: PPUSH
16895: CALL_OW 88
16899: GO 16945
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16901: LD_EXP 21
16905: PUSH
16906: LD_EXP 21
16910: PPUSH
16911: CALL_OW 255
16915: PUSH
16916: LD_INT 7
16918: EQUAL
16919: AND
16920: PUSH
16921: LD_EXP 21
16925: PPUSH
16926: CALL_OW 305
16930: AND
16931: IFFALSE 16945
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16933: LD_EXP 21
16937: PPUSH
16938: LD_STRING DEnd-JMM-Lisa-1
16940: PPUSH
16941: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16945: LD_EXP 31
16949: PUSH
16950: LD_EXP 31
16954: PPUSH
16955: CALL_OW 305
16959: AND
16960: IFFALSE 16974
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16962: LD_EXP 31
16966: PPUSH
16967: LD_STRING DEnd-JMM-Frank-1
16969: PPUSH
16970: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16974: LD_EXP 24
16978: PUSH
16979: LD_EXP 24
16983: PPUSH
16984: CALL_OW 255
16988: PUSH
16989: LD_INT 7
16991: EQUAL
16992: AND
16993: PUSH
16994: LD_EXP 24
16998: PPUSH
16999: CALL_OW 305
17003: AND
17004: IFFALSE 17018
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17006: LD_EXP 24
17010: PPUSH
17011: LD_STRING DEnd-JMM-Cyrus-1
17013: PPUSH
17014: CALL_OW 88
// if Burlak then
17018: LD_EXP 52
17022: IFFALSE 17036
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17024: LD_EXP 52
17028: PPUSH
17029: LD_STRING DEnd-JMM-Bur-1
17031: PPUSH
17032: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
17036: LD_EXP 34
17040: PUSH
17041: LD_EXP 21
17045: AND
17046: PUSH
17047: LD_EXP 21
17051: PPUSH
17052: CALL_OW 255
17056: PUSH
17057: LD_INT 7
17059: EQUAL
17060: AND
17061: PUSH
17062: LD_EXP 21
17066: PPUSH
17067: CALL_OW 305
17071: AND
17072: PUSH
17073: LD_EXP 52
17077: PPUSH
17078: CALL_OW 302
17082: AND
17083: IFFALSE 17097
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
17085: LD_EXP 21
17089: PPUSH
17090: LD_STRING DEnd-Burlak-Lisa-1
17092: PPUSH
17093: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
17097: LD_EXP 53
17101: PUSH
17102: LD_EXP 53
17106: PPUSH
17107: CALL_OW 305
17111: AND
17112: IFFALSE 17126
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
17114: LD_EXP 53
17118: PPUSH
17119: LD_STRING DEnd-JMM-Bel-1
17121: PPUSH
17122: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
17126: LD_EXP 54
17130: PUSH
17131: LD_EXP 54
17135: PPUSH
17136: CALL_OW 305
17140: AND
17141: IFFALSE 17155
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
17143: LD_EXP 54
17147: PPUSH
17148: LD_STRING DEnd-JMM-Gny-1
17150: PPUSH
17151: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
17155: LD_EXP 29
17159: PUSH
17160: LD_EXP 29
17164: PPUSH
17165: CALL_OW 255
17169: PUSH
17170: LD_INT 7
17172: EQUAL
17173: AND
17174: PUSH
17175: LD_EXP 29
17179: PPUSH
17180: CALL_OW 305
17184: AND
17185: IFFALSE 17199
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
17187: LD_EXP 29
17191: PPUSH
17192: LD_STRING DEnd-JMM-Corn-1
17194: PPUSH
17195: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
17199: LD_EXP 22
17203: PUSH
17204: LD_EXP 22
17208: PPUSH
17209: CALL_OW 255
17213: PUSH
17214: LD_INT 7
17216: EQUAL
17217: AND
17218: PUSH
17219: LD_EXP 22
17223: PPUSH
17224: CALL_OW 305
17228: AND
17229: IFFALSE 17243
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17231: LD_EXP 22
17235: PPUSH
17236: LD_STRING DEnd-JMM-Don-1
17238: PPUSH
17239: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
17243: LD_EXP 23
17247: PUSH
17248: LD_EXP 23
17252: PPUSH
17253: CALL_OW 255
17257: PUSH
17258: LD_INT 7
17260: EQUAL
17261: AND
17262: PUSH
17263: LD_EXP 23
17267: PPUSH
17268: CALL_OW 305
17272: AND
17273: IFFALSE 17287
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17275: LD_EXP 23
17279: PPUSH
17280: LD_STRING DEnd-JMM-Bobby-1
17282: PPUSH
17283: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17287: LD_EXP 25
17291: PUSH
17292: LD_EXP 25
17296: PPUSH
17297: CALL_OW 255
17301: PUSH
17302: LD_INT 7
17304: EQUAL
17305: AND
17306: PUSH
17307: LD_EXP 25
17311: PPUSH
17312: CALL_OW 305
17316: AND
17317: IFFALSE 17331
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17319: LD_EXP 25
17323: PPUSH
17324: LD_STRING DEnd-JMM-Den-1
17326: PPUSH
17327: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17331: LD_EXP 27
17335: PUSH
17336: LD_EXP 27
17340: PPUSH
17341: CALL_OW 255
17345: PUSH
17346: LD_INT 7
17348: EQUAL
17349: AND
17350: PUSH
17351: LD_EXP 27
17355: PPUSH
17356: CALL_OW 305
17360: AND
17361: IFFALSE 17375
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17363: LD_EXP 27
17367: PPUSH
17368: LD_STRING DEnd-JMM-Glad-1
17370: PPUSH
17371: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17375: LD_EXP 32
17379: PUSH
17380: LD_EXP 32
17384: PPUSH
17385: CALL_OW 255
17389: PUSH
17390: LD_INT 7
17392: EQUAL
17393: AND
17394: PUSH
17395: LD_EXP 32
17399: PPUSH
17400: CALL_OW 305
17404: AND
17405: IFFALSE 17419
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17407: LD_EXP 32
17411: PPUSH
17412: LD_STRING DEnd-JMM-Yam-1
17414: PPUSH
17415: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17419: LD_EXP 26
17423: PUSH
17424: LD_EXP 26
17428: PPUSH
17429: CALL_OW 255
17433: PUSH
17434: LD_INT 7
17436: EQUAL
17437: AND
17438: PUSH
17439: LD_EXP 26
17443: PPUSH
17444: CALL_OW 305
17448: AND
17449: IFFALSE 17463
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17451: LD_EXP 26
17455: PPUSH
17456: LD_STRING DEnd-JMM-Brown-1
17458: PPUSH
17459: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17463: LD_EXP 36
17467: PUSH
17468: LD_EXP 36
17472: PPUSH
17473: CALL_OW 255
17477: PUSH
17478: LD_INT 7
17480: EQUAL
17481: AND
17482: PUSH
17483: LD_EXP 36
17487: PPUSH
17488: CALL_OW 305
17492: AND
17493: IFFALSE 17507
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17495: LD_EXP 36
17499: PPUSH
17500: LD_STRING DEnd-JMM-Con-1
17502: PPUSH
17503: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17507: LD_EXP 30
17511: PUSH
17512: LD_EXP 30
17516: PPUSH
17517: CALL_OW 255
17521: PUSH
17522: LD_INT 7
17524: EQUAL
17525: AND
17526: PUSH
17527: LD_EXP 30
17531: PPUSH
17532: CALL_OW 305
17536: AND
17537: IFFALSE 17551
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17539: LD_EXP 30
17543: PPUSH
17544: LD_STRING DEnd-JMM-Gary-1
17546: PPUSH
17547: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17551: LD_EXP 33
17555: PUSH
17556: LD_EXP 20
17560: AND
17561: PUSH
17562: LD_EXP 33
17566: PPUSH
17567: CALL_OW 305
17571: AND
17572: IFFALSE 17586
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17574: LD_EXP 33
17578: PPUSH
17579: LD_STRING DEnd-JMM-Sim-1
17581: PPUSH
17582: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17586: LD_EXP 28
17590: PUSH
17591: LD_EXP 28
17595: PPUSH
17596: CALL_OW 255
17600: PUSH
17601: LD_INT 7
17603: EQUAL
17604: AND
17605: PUSH
17606: LD_EXP 28
17610: PPUSH
17611: CALL_OW 305
17615: AND
17616: IFFALSE 17630
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17618: LD_EXP 28
17622: PPUSH
17623: LD_STRING DEnd-JMM-VanH-1
17625: PPUSH
17626: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17630: LD_EXP 42
17634: PUSH
17635: LD_EXP 42
17639: PPUSH
17640: CALL_OW 305
17644: AND
17645: IFFALSE 17659
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17647: LD_EXP 42
17651: PPUSH
17652: LD_STRING DEnd-JMM-Dol-1
17654: PPUSH
17655: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17659: LD_EXP 46
17663: PUSH
17664: LD_EXP 46
17668: PPUSH
17669: CALL_OW 305
17673: AND
17674: IFFALSE 17688
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17676: LD_EXP 46
17680: PPUSH
17681: LD_STRING DEnd-JMM-Kap-1
17683: PPUSH
17684: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17688: LD_EXP 49
17692: PUSH
17693: LD_EXP 49
17697: PPUSH
17698: CALL_OW 305
17702: AND
17703: IFFALSE 17717
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17705: LD_EXP 49
17709: PPUSH
17710: LD_STRING DEnd-JMM-Kov-1
17712: PPUSH
17713: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17717: LD_EXP 44
17721: PUSH
17722: LD_EXP 44
17726: PPUSH
17727: CALL_OW 305
17731: AND
17732: IFFALSE 17746
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17734: LD_EXP 44
17738: PPUSH
17739: LD_STRING DEnd-JMM-Sch-1
17741: PPUSH
17742: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17746: LD_EXP 40
17750: PUSH
17751: LD_EXP 40
17755: PPUSH
17756: CALL_OW 305
17760: AND
17761: IFFALSE 17775
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17763: LD_EXP 40
17767: PPUSH
17768: LD_STRING DEnd-JMM-Tit-1
17770: PPUSH
17771: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17775: LD_EXP 45
17779: PUSH
17780: LD_EXP 45
17784: PPUSH
17785: CALL_OW 305
17789: AND
17790: IFFALSE 17804
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17792: LD_EXP 45
17796: PPUSH
17797: LD_STRING DEnd-JMM-Obl-1
17799: PPUSH
17800: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17804: LD_EXP 47
17808: PUSH
17809: LD_EXP 47
17813: PPUSH
17814: CALL_OW 305
17818: AND
17819: IFFALSE 17833
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17821: LD_EXP 47
17825: PPUSH
17826: LD_STRING DEnd-JMM-Lip-1
17828: PPUSH
17829: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17833: LD_EXP 41
17837: PUSH
17838: LD_EXP 41
17842: PPUSH
17843: CALL_OW 305
17847: AND
17848: PUSH
17849: LD_EXP 52
17853: AND
17854: IFFALSE 17868
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17856: LD_EXP 41
17860: PPUSH
17861: LD_STRING DEnd-Burlak-Fad-1
17863: PPUSH
17864: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17868: LD_EXP 48
17872: PUSH
17873: LD_EXP 48
17877: PPUSH
17878: CALL_OW 305
17882: AND
17883: IFFALSE 17897
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17885: LD_EXP 48
17889: PPUSH
17890: LD_STRING DEnd-Burlak-Ptr-1
17892: PPUSH
17893: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17897: LD_EXP 50
17901: PUSH
17902: LD_EXP 50
17906: PPUSH
17907: CALL_OW 305
17911: AND
17912: IFFALSE 17926
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17914: LD_EXP 50
17918: PPUSH
17919: LD_STRING DEnd-Burlak-Kuz-1
17921: PPUSH
17922: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17926: LD_EXP 39
17930: PUSH
17931: LD_EXP 39
17935: PPUSH
17936: CALL_OW 305
17940: AND
17941: PUSH
17942: LD_EXP 52
17946: AND
17947: IFFALSE 17961
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17949: LD_EXP 39
17953: PPUSH
17954: LD_STRING DEnd-Burlak-Kir-1
17956: PPUSH
17957: CALL_OW 88
// if Burlak then
17961: LD_EXP 52
17965: IFFALSE 17979
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17967: LD_EXP 19
17971: PPUSH
17972: LD_STRING DEnd-Burlak-JMM-1
17974: PPUSH
17975: CALL_OW 88
// dwait ( 0 0$2 ) ;
17979: LD_INT 70
17981: PPUSH
17982: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17986: LD_EXP 57
17990: PPUSH
17991: LD_STRING DEnd-Szulc
17993: PPUSH
17994: CALL_OW 94
// dwait ( 0 0$1 ) ;
17998: LD_INT 35
18000: PPUSH
18001: CALL_OW 68
// if IsLive ( Burlak ) then
18005: LD_EXP 52
18009: PPUSH
18010: CALL_OW 300
18014: IFFALSE 18026
// med1 := 1 else
18016: LD_ADDR_VAR 0 1
18020: PUSH
18021: LD_INT 1
18023: ST_TO_ADDR
18024: GO 18035
// med1 := - 1 ;
18026: LD_ADDR_VAR 0 1
18030: PUSH
18031: LD_INT 1
18033: NEG
18034: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
18035: LD_EXP 12
18039: PUSH
18040: LD_EXP 13
18044: AND
18045: PUSH
18046: LD_EXP 14
18050: AND
18051: IFFALSE 18063
// med2 := 1 else
18053: LD_ADDR_VAR 0 2
18057: PUSH
18058: LD_INT 1
18060: ST_TO_ADDR
18061: GO 18072
// med2 := - 1 ;
18063: LD_ADDR_VAR 0 2
18067: PUSH
18068: LD_INT 1
18070: NEG
18071: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
18072: LD_STRING Hero
18074: PPUSH
18075: LD_INT 1
18077: PPUSH
18078: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
18082: LD_STRING Artefact
18084: PPUSH
18085: LD_VAR 0 2
18089: PPUSH
18090: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
18094: LD_STRING ReconcileBurlak
18096: PPUSH
18097: LD_VAR 0 1
18101: PPUSH
18102: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
18106: LD_OWVAR 67
18110: PUSH
18111: LD_INT 3
18113: GREATEREQUAL
18114: PUSH
18115: LD_VAR 0 1
18119: PUSH
18120: LD_INT 1
18122: EQUAL
18123: AND
18124: PUSH
18125: LD_VAR 0 2
18129: PUSH
18130: LD_INT 1
18132: EQUAL
18133: AND
18134: IFFALSE 18146
// SetAchievementEX ( ACH_AMER , 19 ) ;
18136: LD_STRING ACH_AMER
18138: PPUSH
18139: LD_INT 19
18141: PPUSH
18142: CALL_OW 564
// GiveMedals ( MAIN ) ;
18146: LD_STRING MAIN
18148: PPUSH
18149: CALL_OW 102
// InGameOff ;
18153: CALL_OW 9
// DialogueOff ;
18157: CALL_OW 7
// music_nat := 1 ;
18161: LD_ADDR_OWVAR 71
18165: PUSH
18166: LD_INT 1
18168: ST_TO_ADDR
// music_class := 4 ;
18169: LD_ADDR_OWVAR 72
18173: PUSH
18174: LD_INT 4
18176: ST_TO_ADDR
// YouWin ;
18177: CALL_OW 103
// end ; end_of_file
18181: PPOPN 2
18183: END
// export function InitNature ; begin
18184: LD_INT 0
18186: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
18187: LD_INT 3
18189: PPUSH
18190: LD_INT 3
18192: PPUSH
18193: LD_INT 2
18195: PPUSH
18196: LD_INT 1
18198: PPUSH
18199: LD_INT 1
18201: PPUSH
18202: LD_INT 0
18204: PPUSH
18205: LD_INT 0
18207: PPUSH
18208: LD_INT 17
18210: PPUSH
18211: LD_INT 0
18213: PPUSH
18214: CALL 86194 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
18218: LD_INT 2
18220: PPUSH
18221: LD_INT 1
18223: PPUSH
18224: LD_INT 1
18226: PPUSH
18227: LD_INT 1
18229: PPUSH
18230: LD_INT 1
18232: PPUSH
18233: LD_INT 0
18235: PPUSH
18236: LD_INT 0
18238: PPUSH
18239: LD_INT 18
18241: PPUSH
18242: LD_INT 0
18244: PPUSH
18245: CALL 86194 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
18249: LD_INT 4
18251: PPUSH
18252: LD_INT 1
18254: PPUSH
18255: LD_INT 2
18257: PPUSH
18258: LD_INT 4
18260: PPUSH
18261: LD_INT 2
18263: PPUSH
18264: LD_INT 1
18266: PPUSH
18267: LD_INT 0
18269: PPUSH
18270: LD_INT 19
18272: PPUSH
18273: LD_INT 0
18275: PPUSH
18276: CALL 86194 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18280: LD_INT 0
18282: PPUSH
18283: LD_INT 0
18285: PPUSH
18286: LD_INT 0
18288: PPUSH
18289: LD_INT 0
18291: PPUSH
18292: LD_INT 0
18294: PPUSH
18295: LD_INT 0
18297: PPUSH
18298: LD_INT 9
18300: PPUSH
18301: LD_INT 0
18303: PPUSH
18304: LD_INT 20
18306: PPUSH
18307: CALL 86194 0 9
// end ; end_of_file
18311: LD_VAR 0 1
18315: RET
// every 0 0$30 do var time ;
18316: GO 18318
18318: DISABLE
18319: LD_INT 0
18321: PPUSH
// begin time := 0 0$30 ;
18322: LD_ADDR_VAR 0 1
18326: PUSH
18327: LD_INT 1050
18329: ST_TO_ADDR
// repeat wait ( time ) ;
18330: LD_VAR 0 1
18334: PPUSH
18335: CALL_OW 67
// if Prob ( 50 ) then
18339: LD_INT 50
18341: PPUSH
18342: CALL_OW 13
18346: IFFALSE 18375
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18348: LD_INT 1
18350: PPUSH
18351: LD_INT 5
18353: PPUSH
18354: CALL_OW 12
18358: PPUSH
18359: LD_INT 106
18361: PPUSH
18362: LD_INT 89
18364: PPUSH
18365: LD_INT 45
18367: PPUSH
18368: LD_INT 1
18370: PPUSH
18371: CALL_OW 56
// time := time + 0 0$3 ;
18375: LD_ADDR_VAR 0 1
18379: PUSH
18380: LD_VAR 0 1
18384: PUSH
18385: LD_INT 105
18387: PLUS
18388: ST_TO_ADDR
// if Prob ( 30 ) then
18389: LD_INT 30
18391: PPUSH
18392: CALL_OW 13
18396: IFFALSE 18442
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18398: LD_INT 525
18400: PPUSH
18401: LD_INT 735
18403: PPUSH
18404: CALL_OW 12
18408: PPUSH
18409: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18413: LD_INT 1
18415: PPUSH
18416: LD_INT 5
18418: PPUSH
18419: CALL_OW 12
18423: PPUSH
18424: LD_INT 21
18426: PPUSH
18427: LD_INT 26
18429: PPUSH
18430: LD_INT 12
18432: PPUSH
18433: LD_INT 1
18435: PPUSH
18436: CALL_OW 56
// end else
18440: GO 18478
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18442: LD_INT 700
18444: PPUSH
18445: LD_INT 1225
18447: PPUSH
18448: CALL_OW 12
18452: PPUSH
18453: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18457: LD_INT 1
18459: PPUSH
18460: LD_INT 5
18462: PPUSH
18463: CALL_OW 12
18467: PPUSH
18468: LD_INT 14
18470: PPUSH
18471: LD_INT 1
18473: PPUSH
18474: CALL_OW 55
// end ; if Prob ( 50 ) then
18478: LD_INT 50
18480: PPUSH
18481: CALL_OW 13
18485: IFFALSE 18531
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18487: LD_INT 700
18489: PPUSH
18490: LD_INT 1050
18492: PPUSH
18493: CALL_OW 12
18497: PPUSH
18498: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18502: LD_INT 1
18504: PPUSH
18505: LD_INT 5
18507: PPUSH
18508: CALL_OW 12
18512: PPUSH
18513: LD_INT 181
18515: PPUSH
18516: LD_INT 218
18518: PPUSH
18519: LD_INT 16
18521: PPUSH
18522: LD_INT 1
18524: PPUSH
18525: CALL_OW 56
// end else
18529: GO 18603
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18531: LD_INT 350
18533: PPUSH
18534: LD_INT 525
18536: PPUSH
18537: CALL_OW 12
18541: PPUSH
18542: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18546: LD_INT 1
18548: PPUSH
18549: LD_INT 5
18551: PPUSH
18552: CALL_OW 12
18556: PPUSH
18557: LD_INT 13
18559: PPUSH
18560: LD_INT 1
18562: PPUSH
18563: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18567: LD_INT 350
18569: PPUSH
18570: LD_INT 700
18572: PPUSH
18573: CALL_OW 12
18577: PPUSH
18578: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18582: LD_INT 1
18584: PPUSH
18585: LD_INT 5
18587: PPUSH
18588: CALL_OW 12
18592: PPUSH
18593: LD_INT 33
18595: PPUSH
18596: LD_INT 1
18598: PPUSH
18599: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18603: LD_INT 65
18605: PUSH
18606: LD_INT 62
18608: PUSH
18609: LD_INT 55
18611: PUSH
18612: LD_INT 50
18614: PUSH
18615: EMPTY
18616: LIST
18617: LIST
18618: LIST
18619: LIST
18620: PUSH
18621: LD_OWVAR 67
18625: ARRAY
18626: PPUSH
18627: CALL_OW 13
18631: IFFALSE 18677
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18633: LD_INT 525
18635: PPUSH
18636: LD_INT 875
18638: PPUSH
18639: CALL_OW 12
18643: PPUSH
18644: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18648: LD_INT 1
18650: PPUSH
18651: LD_INT 5
18653: PPUSH
18654: CALL_OW 12
18658: PPUSH
18659: LD_INT 294
18661: PPUSH
18662: LD_INT 211
18664: PPUSH
18665: LD_INT 30
18667: PPUSH
18668: LD_INT 1
18670: PPUSH
18671: CALL_OW 56
// end else
18675: GO 18719
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18677: LD_INT 420
18679: PPUSH
18680: LD_INT 770
18682: PPUSH
18683: CALL_OW 12
18687: PPUSH
18688: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18692: LD_INT 1
18694: PPUSH
18695: LD_INT 5
18697: PPUSH
18698: CALL_OW 12
18702: PPUSH
18703: LD_INT 294
18705: PPUSH
18706: LD_INT 211
18708: PPUSH
18709: LD_INT 30
18711: PPUSH
18712: LD_INT 1
18714: PPUSH
18715: CALL_OW 56
// end ; if time > 2 2$20 then
18719: LD_VAR 0 1
18723: PUSH
18724: LD_INT 4900
18726: GREATER
18727: IFFALSE 18737
// time := 0 0$50 ;
18729: LD_ADDR_VAR 0 1
18733: PUSH
18734: LD_INT 1750
18736: ST_TO_ADDR
// until false ;
18737: LD_INT 0
18739: IFFALSE 18330
// end ;
18741: PPOPN 1
18743: END
// every 0 0$45 trigger tick < 10 10$00 do
18744: LD_OWVAR 1
18748: PUSH
18749: LD_INT 21000
18751: LESS
18752: IFFALSE 18800
18754: GO 18756
18756: DISABLE
// begin enable ;
18757: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18758: LD_INT 350
18760: PPUSH
18761: LD_INT 700
18763: PPUSH
18764: CALL_OW 12
18768: PPUSH
18769: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18773: LD_INT 3
18775: PPUSH
18776: LD_INT 5
18778: PPUSH
18779: CALL_OW 12
18783: PPUSH
18784: LD_INT 181
18786: PPUSH
18787: LD_INT 13
18789: PPUSH
18790: LD_INT 20
18792: PPUSH
18793: LD_INT 1
18795: PPUSH
18796: CALL_OW 56
// end ; end_of_file
18800: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18801: LD_INT 0
18803: PPUSH
// SetArtifactRes ( 7 , true ) ;
18804: LD_INT 7
18806: PPUSH
18807: LD_INT 1
18809: PPUSH
18810: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18814: LD_ADDR_EXP 66
18818: PUSH
18819: EMPTY
18820: PUSH
18821: EMPTY
18822: PUSH
18823: EMPTY
18824: PUSH
18825: EMPTY
18826: LIST
18827: LIST
18828: LIST
18829: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18830: LD_ADDR_EXP 67
18834: PUSH
18835: LD_INT 1050
18837: PUSH
18838: LD_OWVAR 67
18842: MUL
18843: PUSH
18844: LD_INT 2800
18846: PUSH
18847: LD_OWVAR 67
18851: MUL
18852: PUSH
18853: LD_INT 1
18855: NEG
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: LIST
18861: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18862: LD_ADDR_EXP 68
18866: PUSH
18867: LD_INT 10
18869: PUSH
18870: LD_INT 35
18872: PUSH
18873: LD_INT 100
18875: PUSH
18876: EMPTY
18877: LIST
18878: LIST
18879: LIST
18880: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18881: LD_ADDR_EXP 69
18885: PUSH
18886: LD_INT 0
18888: PUSH
18889: LD_INT 0
18891: PUSH
18892: LD_INT 0
18894: PUSH
18895: EMPTY
18896: LIST
18897: LIST
18898: LIST
18899: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18900: LD_ADDR_EXP 71
18904: PUSH
18905: LD_INT 300
18907: PUSH
18908: LD_INT 500
18910: PUSH
18911: LD_INT 800
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: LIST
18918: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18919: LD_ADDR_EXP 72
18923: PUSH
18924: LD_INT 0
18926: PUSH
18927: LD_INT 0
18929: PUSH
18930: LD_INT 0
18932: PUSH
18933: EMPTY
18934: LIST
18935: LIST
18936: LIST
18937: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18938: LD_ADDR_EXP 73
18942: PUSH
18943: LD_INT 0
18945: PUSH
18946: LD_INT 0
18948: PUSH
18949: LD_INT 0
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: LIST
18956: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18957: LD_ADDR_EXP 70
18961: PUSH
18962: LD_INT 0
18964: PUSH
18965: LD_INT 0
18967: PUSH
18968: LD_INT 0
18970: PUSH
18971: EMPTY
18972: LIST
18973: LIST
18974: LIST
18975: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18976: LD_ADDR_EXP 74
18980: PUSH
18981: LD_INT 4
18983: PUSH
18984: LD_INT 3
18986: PUSH
18987: LD_INT 1
18989: PUSH
18990: EMPTY
18991: LIST
18992: LIST
18993: LIST
18994: PUSH
18995: LD_INT 5
18997: PUSH
18998: LD_INT 4
19000: PUSH
19001: LD_INT 2
19003: PUSH
19004: EMPTY
19005: LIST
19006: LIST
19007: LIST
19008: PUSH
19009: LD_INT 6
19011: PUSH
19012: LD_INT 3
19014: PUSH
19015: LD_INT 3
19017: PUSH
19018: EMPTY
19019: LIST
19020: LIST
19021: LIST
19022: PUSH
19023: EMPTY
19024: LIST
19025: LIST
19026: LIST
19027: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
19028: LD_ADDR_EXP 75
19032: PUSH
19033: LD_INT 0
19035: PUSH
19036: LD_INT 0
19038: PUSH
19039: LD_INT 0
19041: PUSH
19042: EMPTY
19043: LIST
19044: LIST
19045: LIST
19046: ST_TO_ADDR
// end ;
19047: LD_VAR 0 1
19051: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
19052: LD_INT 24
19054: PPUSH
19055: LD_INT 7
19057: PPUSH
19058: CALL_OW 321
19062: PUSH
19063: LD_INT 2
19065: EQUAL
19066: IFFALSE 19992
19068: GO 19070
19070: DISABLE
19071: LD_INT 0
19073: PPUSH
19074: PPUSH
19075: PPUSH
19076: PPUSH
19077: PPUSH
// begin enable ;
19078: ENABLE
// for i = 1 to 3 do
19079: LD_ADDR_VAR 0 1
19083: PUSH
19084: DOUBLE
19085: LD_INT 1
19087: DEC
19088: ST_TO_ADDR
19089: LD_INT 3
19091: PUSH
19092: FOR_TO
19093: IFFALSE 19990
// begin pos := FindArtifact ( i + 2 ) ;
19095: LD_ADDR_VAR 0 2
19099: PUSH
19100: LD_VAR 0 1
19104: PUSH
19105: LD_INT 2
19107: PLUS
19108: PPUSH
19109: CALL_OW 469
19113: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
19114: LD_ADDR_EXP 66
19118: PUSH
19119: LD_EXP 66
19123: PPUSH
19124: LD_VAR 0 1
19128: PPUSH
19129: LD_VAR 0 2
19133: PPUSH
19134: CALL_OW 1
19138: ST_TO_ADDR
// if pos then
19139: LD_VAR 0 2
19143: IFFALSE 19851
// begin case i of 1 :
19145: LD_VAR 0 1
19149: PUSH
19150: LD_INT 1
19152: DOUBLE
19153: EQUAL
19154: IFTRUE 19158
19156: GO 19235
19158: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
19159: LD_ADDR_VAR 0 4
19163: PUSH
19164: LD_INT 22
19166: PUSH
19167: LD_INT 7
19169: PUSH
19170: EMPTY
19171: LIST
19172: LIST
19173: PUSH
19174: LD_INT 23
19176: PUSH
19177: LD_INT 1
19179: PUSH
19180: EMPTY
19181: LIST
19182: LIST
19183: PUSH
19184: LD_INT 2
19186: PUSH
19187: LD_INT 30
19189: PUSH
19190: LD_INT 8
19192: PUSH
19193: EMPTY
19194: LIST
19195: LIST
19196: PUSH
19197: LD_INT 30
19199: PUSH
19200: LD_INT 7
19202: PUSH
19203: EMPTY
19204: LIST
19205: LIST
19206: PUSH
19207: LD_INT 30
19209: PUSH
19210: LD_INT 11
19212: PUSH
19213: EMPTY
19214: LIST
19215: LIST
19216: PUSH
19217: EMPTY
19218: LIST
19219: LIST
19220: LIST
19221: LIST
19222: PUSH
19223: EMPTY
19224: LIST
19225: LIST
19226: LIST
19227: PPUSH
19228: CALL_OW 69
19232: ST_TO_ADDR
19233: GO 19343
19235: LD_INT 2
19237: DOUBLE
19238: EQUAL
19239: IFTRUE 19243
19241: GO 19320
19243: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
19244: LD_ADDR_VAR 0 4
19248: PUSH
19249: LD_INT 22
19251: PUSH
19252: LD_INT 7
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: PUSH
19259: LD_INT 23
19261: PUSH
19262: LD_INT 3
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: PUSH
19269: LD_INT 2
19271: PUSH
19272: LD_INT 30
19274: PUSH
19275: LD_INT 8
19277: PUSH
19278: EMPTY
19279: LIST
19280: LIST
19281: PUSH
19282: LD_INT 30
19284: PUSH
19285: LD_INT 7
19287: PUSH
19288: EMPTY
19289: LIST
19290: LIST
19291: PUSH
19292: LD_INT 30
19294: PUSH
19295: LD_INT 11
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: LIST
19306: LIST
19307: PUSH
19308: EMPTY
19309: LIST
19310: LIST
19311: LIST
19312: PPUSH
19313: CALL_OW 69
19317: ST_TO_ADDR
19318: GO 19343
19320: LD_INT 3
19322: DOUBLE
19323: EQUAL
19324: IFTRUE 19328
19326: GO 19342
19328: POP
// labs := [ alien ] ; end ;
19329: LD_ADDR_VAR 0 4
19333: PUSH
19334: LD_INT 1
19336: PUSH
19337: EMPTY
19338: LIST
19339: ST_TO_ADDR
19340: GO 19343
19342: POP
// if not labs then
19343: LD_VAR 0 4
19347: NOT
19348: IFFALSE 19352
// continue ;
19350: GO 19092
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19352: LD_ADDR_VAR 0 5
19356: PUSH
19357: LD_VAR 0 4
19361: PPUSH
19362: LD_EXP 66
19366: PUSH
19367: LD_VAR 0 1
19371: ARRAY
19372: PUSH
19373: LD_INT 1
19375: ARRAY
19376: PPUSH
19377: LD_EXP 66
19381: PUSH
19382: LD_VAR 0 1
19386: ARRAY
19387: PUSH
19388: LD_INT 2
19390: ARRAY
19391: PPUSH
19392: CALL_OW 73
19396: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19397: LD_VAR 0 5
19401: NOT
19402: PUSH
19403: LD_VAR 0 5
19407: PUSH
19408: LD_EXP 73
19412: PUSH
19413: LD_VAR 0 1
19417: ARRAY
19418: NONEQUAL
19419: OR
19420: IFFALSE 19525
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19422: LD_INT 7
19424: PPUSH
19425: LD_EXP 74
19429: PUSH
19430: LD_VAR 0 1
19434: ARRAY
19435: PUSH
19436: LD_INT 3
19438: ARRAY
19439: PPUSH
19440: LD_INT 0
19442: PPUSH
19443: LD_EXP 73
19447: PUSH
19448: LD_VAR 0 1
19452: ARRAY
19453: PPUSH
19454: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19458: LD_INT 7
19460: PPUSH
19461: LD_EXP 74
19465: PUSH
19466: LD_VAR 0 1
19470: ARRAY
19471: PUSH
19472: LD_INT 1
19474: ARRAY
19475: PPUSH
19476: LD_INT 0
19478: PPUSH
19479: LD_EXP 73
19483: PUSH
19484: LD_VAR 0 1
19488: ARRAY
19489: PPUSH
19490: CALL_OW 468
// if nearestLab then
19494: LD_VAR 0 5
19498: IFFALSE 19525
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19500: LD_ADDR_EXP 73
19504: PUSH
19505: LD_EXP 73
19509: PPUSH
19510: LD_VAR 0 1
19514: PPUSH
19515: LD_VAR 0 5
19519: PPUSH
19520: CALL_OW 1
19524: ST_TO_ADDR
// end ; if not nearestLab then
19525: LD_VAR 0 5
19529: NOT
19530: IFFALSE 19534
// continue ;
19532: GO 19092
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19534: LD_VAR 0 5
19538: PPUSH
19539: LD_EXP 66
19543: PUSH
19544: LD_VAR 0 1
19548: ARRAY
19549: PUSH
19550: LD_INT 1
19552: ARRAY
19553: PPUSH
19554: LD_EXP 66
19558: PUSH
19559: LD_VAR 0 1
19563: ARRAY
19564: PUSH
19565: LD_INT 2
19567: ARRAY
19568: PPUSH
19569: CALL_OW 297
19573: PUSH
19574: LD_INT 8
19576: LESS
19577: IFFALSE 19774
// begin if not artifactsResearched [ i ] then
19579: LD_EXP 69
19583: PUSH
19584: LD_VAR 0 1
19588: ARRAY
19589: NOT
19590: IFFALSE 19671
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19592: LD_VAR 0 5
19596: PPUSH
19597: CALL_OW 461
19601: PUSH
19602: LD_INT 2
19604: EQUAL
19605: IFFALSE 19639
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19607: LD_INT 7
19609: PPUSH
19610: LD_EXP 74
19614: PUSH
19615: LD_VAR 0 1
19619: ARRAY
19620: PUSH
19621: LD_INT 3
19623: ARRAY
19624: PPUSH
19625: LD_INT 2
19627: PPUSH
19628: LD_VAR 0 5
19632: PPUSH
19633: CALL_OW 468
19637: GO 19669
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19639: LD_INT 7
19641: PPUSH
19642: LD_EXP 74
19646: PUSH
19647: LD_VAR 0 1
19651: ARRAY
19652: PUSH
19653: LD_INT 3
19655: ARRAY
19656: PPUSH
19657: LD_INT 1
19659: PPUSH
19660: LD_VAR 0 5
19664: PPUSH
19665: CALL_OW 468
// end else
19669: GO 19772
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19671: LD_VAR 0 5
19675: PPUSH
19676: CALL_OW 461
19680: PUSH
19681: LD_INT 2
19683: EQUAL
19684: PUSH
19685: LD_EXP 75
19689: PUSH
19690: LD_VAR 0 1
19694: ARRAY
19695: AND
19696: IFFALSE 19742
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19698: LD_INT 7
19700: PPUSH
19701: LD_EXP 74
19705: PUSH
19706: LD_VAR 0 1
19710: ARRAY
19711: PUSH
19712: LD_INT 1
19714: ARRAY
19715: PPUSH
19716: LD_EXP 74
19720: PUSH
19721: LD_VAR 0 1
19725: ARRAY
19726: PUSH
19727: LD_INT 2
19729: ARRAY
19730: PPUSH
19731: LD_VAR 0 5
19735: PPUSH
19736: CALL_OW 468
19740: GO 19772
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19742: LD_INT 7
19744: PPUSH
19745: LD_EXP 74
19749: PUSH
19750: LD_VAR 0 1
19754: ARRAY
19755: PUSH
19756: LD_INT 1
19758: ARRAY
19759: PPUSH
19760: LD_INT 1
19762: PPUSH
19763: LD_VAR 0 5
19767: PPUSH
19768: CALL_OW 468
// end else
19772: GO 19849
// begin if not artifactsResearched [ i ] then
19774: LD_EXP 69
19778: PUSH
19779: LD_VAR 0 1
19783: ARRAY
19784: NOT
19785: IFFALSE 19819
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19787: LD_INT 7
19789: PPUSH
19790: LD_EXP 74
19794: PUSH
19795: LD_VAR 0 1
19799: ARRAY
19800: PUSH
19801: LD_INT 3
19803: ARRAY
19804: PPUSH
19805: LD_INT 0
19807: PPUSH
19808: LD_VAR 0 5
19812: PPUSH
19813: CALL_OW 468
19817: GO 19849
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19819: LD_INT 7
19821: PPUSH
19822: LD_EXP 74
19826: PUSH
19827: LD_VAR 0 1
19831: ARRAY
19832: PUSH
19833: LD_INT 1
19835: ARRAY
19836: PPUSH
19837: LD_INT 0
19839: PPUSH
19840: LD_VAR 0 5
19844: PPUSH
19845: CALL_OW 468
// end ; end else
19849: GO 19988
// begin if not artifactsLabs [ i ] then
19851: LD_EXP 73
19855: PUSH
19856: LD_VAR 0 1
19860: ARRAY
19861: NOT
19862: IFFALSE 19866
// continue ;
19864: GO 19092
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19866: LD_INT 7
19868: PPUSH
19869: LD_EXP 74
19873: PUSH
19874: LD_VAR 0 1
19878: ARRAY
19879: PUSH
19880: LD_INT 3
19882: ARRAY
19883: PPUSH
19884: LD_INT 0
19886: PPUSH
19887: LD_EXP 73
19891: PUSH
19892: LD_VAR 0 1
19896: ARRAY
19897: PPUSH
19898: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19902: LD_INT 7
19904: PPUSH
19905: LD_EXP 74
19909: PUSH
19910: LD_VAR 0 1
19914: ARRAY
19915: PUSH
19916: LD_INT 1
19918: ARRAY
19919: PPUSH
19920: LD_INT 0
19922: PPUSH
19923: LD_EXP 73
19927: PUSH
19928: LD_VAR 0 1
19932: ARRAY
19933: PPUSH
19934: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19938: LD_EXP 70
19942: PUSH
19943: LD_VAR 0 1
19947: ARRAY
19948: IFFALSE 19988
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19950: LD_ADDR_EXP 70
19954: PUSH
19955: LD_EXP 70
19959: PPUSH
19960: LD_VAR 0 1
19964: PPUSH
19965: LD_INT 0
19967: PPUSH
19968: CALL_OW 1
19972: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19973: LD_EXP 73
19977: PUSH
19978: LD_VAR 0 1
19982: ARRAY
19983: PPUSH
19984: CALL_OW 127
// end ; end ; end ;
19988: GO 19092
19990: POP
19991: POP
// end ;
19992: PPOPN 5
19994: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19995: LD_INT 0
19997: PPUSH
19998: PPUSH
19999: PPUSH
20000: PPUSH
20001: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
20002: LD_VAR 0 2
20006: PUSH
20007: LD_EXP 74
20011: PUSH
20012: LD_INT 1
20014: ARRAY
20015: PUSH
20016: LD_INT 3
20018: ARRAY
20019: EQUAL
20020: IFFALSE 20143
// begin lab := artifactsLabs [ 1 ] ;
20022: LD_ADDR_VAR 0 6
20026: PUSH
20027: LD_EXP 73
20031: PUSH
20032: LD_INT 1
20034: ARRAY
20035: ST_TO_ADDR
// if not lab then
20036: LD_VAR 0 6
20040: NOT
20041: IFFALSE 20045
// exit ;
20043: GO 21123
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
20045: LD_VAR 0 6
20049: PPUSH
20050: LD_EXP 71
20054: PUSH
20055: LD_INT 1
20057: ARRAY
20058: PPUSH
20059: LD_INT 1
20061: PPUSH
20062: CALL_OW 486
// if artifactsResProgress [ 1 ] then
20066: LD_EXP 72
20070: PUSH
20071: LD_INT 1
20073: ARRAY
20074: IFFALSE 20094
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
20076: LD_VAR 0 6
20080: PPUSH
20081: LD_EXP 72
20085: PUSH
20086: LD_INT 1
20088: ARRAY
20089: PPUSH
20090: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
20094: LD_ADDR_EXP 70
20098: PUSH
20099: LD_EXP 70
20103: PPUSH
20104: LD_INT 1
20106: PPUSH
20107: LD_INT 1
20109: PPUSH
20110: CALL_OW 1
20114: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
20115: LD_INT 7
20117: PPUSH
20118: LD_EXP 74
20122: PUSH
20123: LD_INT 1
20125: ARRAY
20126: PUSH
20127: LD_INT 3
20129: ARRAY
20130: PPUSH
20131: LD_INT 0
20133: PPUSH
20134: LD_VAR 0 6
20138: PPUSH
20139: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
20143: LD_VAR 0 2
20147: PUSH
20148: LD_EXP 74
20152: PUSH
20153: LD_INT 2
20155: ARRAY
20156: PUSH
20157: LD_INT 3
20159: ARRAY
20160: EQUAL
20161: IFFALSE 20284
// begin lab := artifactsLabs [ 2 ] ;
20163: LD_ADDR_VAR 0 6
20167: PUSH
20168: LD_EXP 73
20172: PUSH
20173: LD_INT 2
20175: ARRAY
20176: ST_TO_ADDR
// if not lab then
20177: LD_VAR 0 6
20181: NOT
20182: IFFALSE 20186
// exit ;
20184: GO 21123
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
20186: LD_VAR 0 6
20190: PPUSH
20191: LD_EXP 71
20195: PUSH
20196: LD_INT 2
20198: ARRAY
20199: PPUSH
20200: LD_INT 1
20202: PPUSH
20203: CALL_OW 486
// if artifactsResProgress [ 2 ] then
20207: LD_EXP 72
20211: PUSH
20212: LD_INT 2
20214: ARRAY
20215: IFFALSE 20235
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
20217: LD_VAR 0 6
20221: PPUSH
20222: LD_EXP 72
20226: PUSH
20227: LD_INT 2
20229: ARRAY
20230: PPUSH
20231: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
20235: LD_ADDR_EXP 70
20239: PUSH
20240: LD_EXP 70
20244: PPUSH
20245: LD_INT 2
20247: PPUSH
20248: LD_INT 1
20250: PPUSH
20251: CALL_OW 1
20255: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
20256: LD_INT 7
20258: PPUSH
20259: LD_EXP 74
20263: PUSH
20264: LD_INT 2
20266: ARRAY
20267: PUSH
20268: LD_INT 3
20270: ARRAY
20271: PPUSH
20272: LD_INT 0
20274: PPUSH
20275: LD_VAR 0 6
20279: PPUSH
20280: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20284: LD_VAR 0 2
20288: PUSH
20289: LD_EXP 74
20293: PUSH
20294: LD_INT 3
20296: ARRAY
20297: PUSH
20298: LD_INT 3
20300: ARRAY
20301: EQUAL
20302: IFFALSE 20425
// begin lab := artifactsLabs [ 3 ] ;
20304: LD_ADDR_VAR 0 6
20308: PUSH
20309: LD_EXP 73
20313: PUSH
20314: LD_INT 3
20316: ARRAY
20317: ST_TO_ADDR
// if not lab then
20318: LD_VAR 0 6
20322: NOT
20323: IFFALSE 20327
// exit ;
20325: GO 21123
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20327: LD_VAR 0 6
20331: PPUSH
20332: LD_EXP 71
20336: PUSH
20337: LD_INT 3
20339: ARRAY
20340: PPUSH
20341: LD_INT 1
20343: PPUSH
20344: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20348: LD_EXP 72
20352: PUSH
20353: LD_INT 3
20355: ARRAY
20356: IFFALSE 20376
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20358: LD_VAR 0 6
20362: PPUSH
20363: LD_EXP 72
20367: PUSH
20368: LD_INT 3
20370: ARRAY
20371: PPUSH
20372: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20376: LD_ADDR_EXP 70
20380: PUSH
20381: LD_EXP 70
20385: PPUSH
20386: LD_INT 3
20388: PPUSH
20389: LD_INT 1
20391: PPUSH
20392: CALL_OW 1
20396: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20397: LD_INT 7
20399: PPUSH
20400: LD_EXP 74
20404: PUSH
20405: LD_INT 3
20407: ARRAY
20408: PUSH
20409: LD_INT 3
20411: ARRAY
20412: PPUSH
20413: LD_INT 0
20415: PPUSH
20416: LD_VAR 0 6
20420: PPUSH
20421: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20425: LD_VAR 0 2
20429: PUSH
20430: LD_EXP 74
20434: PUSH
20435: LD_INT 1
20437: ARRAY
20438: PUSH
20439: LD_INT 1
20441: ARRAY
20442: EQUAL
20443: IFFALSE 20601
// begin lab := artifactsLabs [ 1 ] ;
20445: LD_ADDR_VAR 0 6
20449: PUSH
20450: LD_EXP 73
20454: PUSH
20455: LD_INT 1
20457: ARRAY
20458: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20459: LD_VAR 0 6
20463: PPUSH
20464: CALL_OW 274
20468: PPUSH
20469: CALL 89734 0 1
20473: PUSH
20474: LD_INT 3
20476: ARRAY
20477: PUSH
20478: LD_EXP 68
20482: PUSH
20483: LD_INT 1
20485: ARRAY
20486: LESS
20487: IFFALSE 20501
// begin HintSpec ( ArtifactCost , 2 ) ;
20489: LD_STRING ArtifactCost
20491: PPUSH
20492: LD_INT 2
20494: PPUSH
20495: CALL_OW 338
// exit ;
20499: GO 21123
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20501: LD_ADDR_EXP 75
20505: PUSH
20506: LD_EXP 75
20510: PPUSH
20511: LD_INT 1
20513: PPUSH
20514: LD_INT 0
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20522: LD_VAR 0 3
20526: PPUSH
20527: LD_VAR 0 4
20531: PPUSH
20532: LD_INT 7
20534: PPUSH
20535: LD_INT 12
20537: NEG
20538: PPUSH
20539: CALL_OW 330
// wait ( 0 0$30 ) ;
20543: LD_INT 1050
20545: PPUSH
20546: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20550: LD_VAR 0 3
20554: PPUSH
20555: LD_VAR 0 4
20559: PPUSH
20560: LD_INT 7
20562: PPUSH
20563: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20567: LD_EXP 67
20571: PUSH
20572: LD_INT 1
20574: ARRAY
20575: PPUSH
20576: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20580: LD_ADDR_EXP 75
20584: PUSH
20585: LD_EXP 75
20589: PPUSH
20590: LD_INT 1
20592: PPUSH
20593: LD_INT 1
20595: PPUSH
20596: CALL_OW 1
20600: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20601: LD_VAR 0 2
20605: PUSH
20606: LD_EXP 74
20610: PUSH
20611: LD_INT 2
20613: ARRAY
20614: PUSH
20615: LD_INT 1
20617: ARRAY
20618: EQUAL
20619: IFFALSE 20856
// begin lab := artifactsLabs [ 2 ] ;
20621: LD_ADDR_VAR 0 6
20625: PUSH
20626: LD_EXP 73
20630: PUSH
20631: LD_INT 2
20633: ARRAY
20634: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20635: LD_VAR 0 3
20639: PUSH
20640: LD_INT 81
20642: PUSH
20643: LD_INT 7
20645: PUSH
20646: EMPTY
20647: LIST
20648: LIST
20649: PUSH
20650: LD_INT 2
20652: PUSH
20653: LD_INT 32
20655: PUSH
20656: LD_INT 3
20658: PUSH
20659: EMPTY
20660: LIST
20661: LIST
20662: PUSH
20663: LD_INT 30
20665: PUSH
20666: LD_INT 28
20668: PUSH
20669: EMPTY
20670: LIST
20671: LIST
20672: PUSH
20673: LD_INT 30
20675: PUSH
20676: LD_INT 30
20678: PUSH
20679: EMPTY
20680: LIST
20681: LIST
20682: PUSH
20683: LD_INT 35
20685: PUSH
20686: LD_INT 49
20688: PUSH
20689: EMPTY
20690: LIST
20691: LIST
20692: PUSH
20693: LD_INT 34
20695: PUSH
20696: LD_INT 49
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: PUSH
20703: LD_INT 30
20705: PUSH
20706: LD_INT 21
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: PUSH
20713: EMPTY
20714: LIST
20715: LIST
20716: LIST
20717: LIST
20718: LIST
20719: LIST
20720: LIST
20721: PUSH
20722: EMPTY
20723: LIST
20724: LIST
20725: PPUSH
20726: CALL_OW 69
20730: IN
20731: NOT
20732: IFFALSE 20736
// exit ;
20734: GO 21123
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20736: LD_VAR 0 6
20740: PPUSH
20741: CALL_OW 274
20745: PPUSH
20746: CALL 89734 0 1
20750: PUSH
20751: LD_INT 3
20753: ARRAY
20754: PUSH
20755: LD_EXP 68
20759: PUSH
20760: LD_INT 2
20762: ARRAY
20763: LESS
20764: IFFALSE 20778
// begin HintSpec ( ArtifactCost , 2 ) ;
20766: LD_STRING ArtifactCost
20768: PPUSH
20769: LD_INT 2
20771: PPUSH
20772: CALL_OW 338
// exit ;
20776: GO 21123
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20778: LD_ADDR_EXP 75
20782: PUSH
20783: LD_EXP 75
20787: PPUSH
20788: LD_INT 2
20790: PPUSH
20791: LD_INT 0
20793: PPUSH
20794: CALL_OW 1
20798: ST_TO_ADDR
// KillUnit ( x ) ;
20799: LD_VAR 0 3
20803: PPUSH
20804: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20808: LD_ADDR_EXP 16
20812: PUSH
20813: LD_EXP 16
20817: PUSH
20818: LD_INT 1
20820: PLUS
20821: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20822: LD_EXP 67
20826: PUSH
20827: LD_INT 2
20829: ARRAY
20830: PPUSH
20831: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20835: LD_ADDR_EXP 75
20839: PUSH
20840: LD_EXP 75
20844: PPUSH
20845: LD_INT 2
20847: PPUSH
20848: LD_INT 1
20850: PPUSH
20851: CALL_OW 1
20855: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20856: LD_VAR 0 2
20860: PUSH
20861: LD_EXP 74
20865: PUSH
20866: LD_INT 3
20868: ARRAY
20869: PUSH
20870: LD_INT 1
20872: ARRAY
20873: EQUAL
20874: IFFALSE 21123
// begin lab := artifactsLabs [ 3 ] ;
20876: LD_ADDR_VAR 0 6
20880: PUSH
20881: LD_EXP 73
20885: PUSH
20886: LD_INT 3
20888: ARRAY
20889: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20890: LD_VAR 0 6
20894: PPUSH
20895: CALL_OW 274
20899: PPUSH
20900: CALL 89734 0 1
20904: PUSH
20905: LD_INT 3
20907: ARRAY
20908: PUSH
20909: LD_EXP 68
20913: PUSH
20914: LD_INT 3
20916: ARRAY
20917: LESS
20918: IFFALSE 20932
// begin HintSpec ( ArtifactCost , 2 ) ;
20920: LD_STRING ArtifactCost
20922: PPUSH
20923: LD_INT 2
20925: PPUSH
20926: CALL_OW 338
// exit ;
20930: GO 21123
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20932: LD_INT 37
20934: PPUSH
20935: LD_INT 1
20937: PPUSH
20938: CALL_OW 424
// time := 0 0$30 ;
20942: LD_ADDR_VAR 0 7
20946: PUSH
20947: LD_INT 1050
20949: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20950: LD_ADDR_EXP 75
20954: PUSH
20955: LD_EXP 75
20959: PPUSH
20960: LD_INT 3
20962: PPUSH
20963: LD_INT 0
20965: PPUSH
20966: CALL_OW 1
20970: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20971: LD_ADDR_OWVAR 47
20975: PUSH
20976: LD_STRING #Am15a-1
20978: PUSH
20979: LD_VAR 0 7
20983: PUSH
20984: EMPTY
20985: LIST
20986: LIST
20987: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20988: LD_INT 35
20990: PPUSH
20991: CALL_OW 67
// time := time - 0 0$1 ;
20995: LD_ADDR_VAR 0 7
20999: PUSH
21000: LD_VAR 0 7
21004: PUSH
21005: LD_INT 35
21007: MINUS
21008: ST_TO_ADDR
// until time = 0 0$00 ;
21009: LD_VAR 0 7
21013: PUSH
21014: LD_INT 0
21016: EQUAL
21017: IFFALSE 20971
// display_strings :=  ;
21019: LD_ADDR_OWVAR 47
21023: PUSH
21024: LD_STRING 
21026: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
21027: LD_INT 37
21029: PPUSH
21030: LD_INT 0
21032: PPUSH
21033: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
21037: LD_ADDR_VAR 0 8
21041: PUSH
21042: LD_INT 37
21044: PPUSH
21045: LD_INT 3
21047: PUSH
21048: LD_INT 21
21050: PUSH
21051: LD_INT 3
21053: PUSH
21054: EMPTY
21055: LIST
21056: LIST
21057: PUSH
21058: EMPTY
21059: LIST
21060: LIST
21061: PPUSH
21062: CALL_OW 70
21066: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
21067: LD_VAR 0 3
21071: PPUSH
21072: LD_VAR 0 4
21076: PPUSH
21077: CALL_OW 84
// for un in list do
21081: LD_ADDR_VAR 0 9
21085: PUSH
21086: LD_VAR 0 8
21090: PUSH
21091: FOR_IN
21092: IFFALSE 21121
// TeleportUnit ( un , x , y , 12 , true ) ;
21094: LD_VAR 0 9
21098: PPUSH
21099: LD_VAR 0 3
21103: PPUSH
21104: LD_VAR 0 4
21108: PPUSH
21109: LD_INT 12
21111: PPUSH
21112: LD_INT 1
21114: PPUSH
21115: CALL_OW 483
21119: GO 21091
21121: POP
21122: POP
// end ; end ;
21123: PPOPN 9
21125: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
21126: LD_INT 0
21128: PPUSH
21129: PPUSH
// begin labNum := 0 ;
21130: LD_ADDR_VAR 0 4
21134: PUSH
21135: LD_INT 0
21137: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21138: LD_ADDR_VAR 0 3
21142: PUSH
21143: DOUBLE
21144: LD_INT 1
21146: DEC
21147: ST_TO_ADDR
21148: LD_EXP 73
21152: PUSH
21153: FOR_TO
21154: IFFALSE 21188
// if artifactsLabs [ i ] = lab then
21156: LD_EXP 73
21160: PUSH
21161: LD_VAR 0 3
21165: ARRAY
21166: PUSH
21167: LD_VAR 0 1
21171: EQUAL
21172: IFFALSE 21186
// begin labNum := i ;
21174: LD_ADDR_VAR 0 4
21178: PUSH
21179: LD_VAR 0 3
21183: ST_TO_ADDR
// break ;
21184: GO 21188
// end ;
21186: GO 21153
21188: POP
21189: POP
// if not labNum then
21190: LD_VAR 0 4
21194: NOT
21195: IFFALSE 21199
// exit ;
21197: GO 21277
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
21199: LD_INT 7
21201: PPUSH
21202: LD_EXP 74
21206: PUSH
21207: LD_VAR 0 4
21211: ARRAY
21212: PUSH
21213: LD_INT 3
21215: ARRAY
21216: PPUSH
21217: LD_INT 2
21219: PPUSH
21220: LD_VAR 0 1
21224: PPUSH
21225: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
21229: LD_ADDR_EXP 72
21233: PUSH
21234: LD_EXP 72
21238: PPUSH
21239: LD_VAR 0 4
21243: PPUSH
21244: LD_VAR 0 2
21248: PPUSH
21249: CALL_OW 1
21253: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
21254: LD_ADDR_EXP 70
21258: PUSH
21259: LD_EXP 70
21263: PPUSH
21264: LD_VAR 0 4
21268: PPUSH
21269: LD_INT 0
21271: PPUSH
21272: CALL_OW 1
21276: ST_TO_ADDR
// end ;
21277: PPOPN 4
21279: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21280: LD_INT 0
21282: PPUSH
21283: PPUSH
// begin labNum := 0 ;
21284: LD_ADDR_VAR 0 3
21288: PUSH
21289: LD_INT 0
21291: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21292: LD_ADDR_VAR 0 2
21296: PUSH
21297: DOUBLE
21298: LD_INT 1
21300: DEC
21301: ST_TO_ADDR
21302: LD_EXP 73
21306: PUSH
21307: FOR_TO
21308: IFFALSE 21342
// if artifactsLabs [ i ] = lab then
21310: LD_EXP 73
21314: PUSH
21315: LD_VAR 0 2
21319: ARRAY
21320: PUSH
21321: LD_VAR 0 1
21325: EQUAL
21326: IFFALSE 21340
// begin labNum := i ;
21328: LD_ADDR_VAR 0 3
21332: PUSH
21333: LD_VAR 0 2
21337: ST_TO_ADDR
// break ;
21338: GO 21342
// end ;
21340: GO 21307
21342: POP
21343: POP
// if not labNum then
21344: LD_VAR 0 3
21348: NOT
21349: IFFALSE 21353
// exit ;
21351: GO 21515
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21353: LD_INT 7
21355: PPUSH
21356: LD_EXP 74
21360: PUSH
21361: LD_VAR 0 3
21365: ARRAY
21366: PUSH
21367: LD_INT 3
21369: ARRAY
21370: PPUSH
21371: LD_INT 0
21373: PPUSH
21374: LD_VAR 0 1
21378: PPUSH
21379: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21383: LD_ADDR_EXP 69
21387: PUSH
21388: LD_EXP 69
21392: PPUSH
21393: LD_VAR 0 3
21397: PPUSH
21398: LD_INT 1
21400: PPUSH
21401: CALL_OW 1
21405: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21406: LD_ADDR_EXP 75
21410: PUSH
21411: LD_EXP 75
21415: PPUSH
21416: LD_VAR 0 3
21420: PPUSH
21421: LD_INT 1
21423: PPUSH
21424: CALL_OW 1
21428: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21429: LD_ADDR_EXP 70
21433: PUSH
21434: LD_EXP 70
21438: PPUSH
21439: LD_VAR 0 3
21443: PPUSH
21444: LD_INT 0
21446: PPUSH
21447: CALL_OW 1
21451: ST_TO_ADDR
// case labNum of 1 :
21452: LD_VAR 0 3
21456: PUSH
21457: LD_INT 1
21459: DOUBLE
21460: EQUAL
21461: IFTRUE 21465
21463: GO 21476
21465: POP
// artifactIResearched := true ; 2 :
21466: LD_ADDR_EXP 12
21470: PUSH
21471: LD_INT 1
21473: ST_TO_ADDR
21474: GO 21515
21476: LD_INT 2
21478: DOUBLE
21479: EQUAL
21480: IFTRUE 21484
21482: GO 21495
21484: POP
// artifactIIResearched := true ; 3 :
21485: LD_ADDR_EXP 13
21489: PUSH
21490: LD_INT 1
21492: ST_TO_ADDR
21493: GO 21515
21495: LD_INT 3
21497: DOUBLE
21498: EQUAL
21499: IFTRUE 21503
21501: GO 21514
21503: POP
// artifactIIIResearched := true ; end ;
21504: LD_ADDR_EXP 14
21508: PUSH
21509: LD_INT 1
21511: ST_TO_ADDR
21512: GO 21515
21514: POP
// end ; end_of_file
21515: PPOPN 3
21517: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
21518: LD_INT 0
21520: PPUSH
21521: PPUSH
// skirmish := false ;
21522: LD_ADDR_EXP 76
21526: PUSH
21527: LD_INT 0
21529: ST_TO_ADDR
// debug_mc := false ;
21530: LD_ADDR_EXP 77
21534: PUSH
21535: LD_INT 0
21537: ST_TO_ADDR
// mc_bases := [ ] ;
21538: LD_ADDR_EXP 78
21542: PUSH
21543: EMPTY
21544: ST_TO_ADDR
// mc_sides := [ ] ;
21545: LD_ADDR_EXP 104
21549: PUSH
21550: EMPTY
21551: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21552: LD_ADDR_EXP 79
21556: PUSH
21557: EMPTY
21558: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21559: LD_ADDR_EXP 80
21563: PUSH
21564: EMPTY
21565: ST_TO_ADDR
// mc_need_heal := [ ] ;
21566: LD_ADDR_EXP 81
21570: PUSH
21571: EMPTY
21572: ST_TO_ADDR
// mc_healers := [ ] ;
21573: LD_ADDR_EXP 82
21577: PUSH
21578: EMPTY
21579: ST_TO_ADDR
// mc_build_list := [ ] ;
21580: LD_ADDR_EXP 83
21584: PUSH
21585: EMPTY
21586: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21587: LD_ADDR_EXP 110
21591: PUSH
21592: EMPTY
21593: ST_TO_ADDR
// mc_builders := [ ] ;
21594: LD_ADDR_EXP 84
21598: PUSH
21599: EMPTY
21600: ST_TO_ADDR
// mc_construct_list := [ ] ;
21601: LD_ADDR_EXP 85
21605: PUSH
21606: EMPTY
21607: ST_TO_ADDR
// mc_turret_list := [ ] ;
21608: LD_ADDR_EXP 86
21612: PUSH
21613: EMPTY
21614: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21615: LD_ADDR_EXP 87
21619: PUSH
21620: EMPTY
21621: ST_TO_ADDR
// mc_miners := [ ] ;
21622: LD_ADDR_EXP 92
21626: PUSH
21627: EMPTY
21628: ST_TO_ADDR
// mc_mines := [ ] ;
21629: LD_ADDR_EXP 91
21633: PUSH
21634: EMPTY
21635: ST_TO_ADDR
// mc_minefields := [ ] ;
21636: LD_ADDR_EXP 93
21640: PUSH
21641: EMPTY
21642: ST_TO_ADDR
// mc_crates := [ ] ;
21643: LD_ADDR_EXP 94
21647: PUSH
21648: EMPTY
21649: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21650: LD_ADDR_EXP 95
21654: PUSH
21655: EMPTY
21656: ST_TO_ADDR
// mc_crates_area := [ ] ;
21657: LD_ADDR_EXP 96
21661: PUSH
21662: EMPTY
21663: ST_TO_ADDR
// mc_vehicles := [ ] ;
21664: LD_ADDR_EXP 97
21668: PUSH
21669: EMPTY
21670: ST_TO_ADDR
// mc_attack := [ ] ;
21671: LD_ADDR_EXP 98
21675: PUSH
21676: EMPTY
21677: ST_TO_ADDR
// mc_produce := [ ] ;
21678: LD_ADDR_EXP 99
21682: PUSH
21683: EMPTY
21684: ST_TO_ADDR
// mc_defender := [ ] ;
21685: LD_ADDR_EXP 100
21689: PUSH
21690: EMPTY
21691: ST_TO_ADDR
// mc_parking := [ ] ;
21692: LD_ADDR_EXP 102
21696: PUSH
21697: EMPTY
21698: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21699: LD_ADDR_EXP 88
21703: PUSH
21704: EMPTY
21705: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21706: LD_ADDR_EXP 90
21710: PUSH
21711: EMPTY
21712: ST_TO_ADDR
// mc_scan := [ ] ;
21713: LD_ADDR_EXP 101
21717: PUSH
21718: EMPTY
21719: ST_TO_ADDR
// mc_scan_area := [ ] ;
21720: LD_ADDR_EXP 103
21724: PUSH
21725: EMPTY
21726: ST_TO_ADDR
// mc_tech := [ ] ;
21727: LD_ADDR_EXP 105
21731: PUSH
21732: EMPTY
21733: ST_TO_ADDR
// mc_class := [ ] ;
21734: LD_ADDR_EXP 119
21738: PUSH
21739: EMPTY
21740: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21741: LD_ADDR_EXP 120
21745: PUSH
21746: EMPTY
21747: ST_TO_ADDR
// mc_is_defending := [ ] ;
21748: LD_ADDR_EXP 121
21752: PUSH
21753: EMPTY
21754: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
21755: LD_ADDR_EXP 112
21759: PUSH
21760: EMPTY
21761: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
21762: LD_ADDR_EXP 122
21766: PUSH
21767: LD_INT 0
21769: ST_TO_ADDR
// end ;
21770: LD_VAR 0 1
21774: RET
// export function MC_Kill ( base ) ; begin
21775: LD_INT 0
21777: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21778: LD_ADDR_EXP 78
21782: PUSH
21783: LD_EXP 78
21787: PPUSH
21788: LD_VAR 0 1
21792: PPUSH
21793: EMPTY
21794: PPUSH
21795: CALL_OW 1
21799: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21800: LD_ADDR_EXP 79
21804: PUSH
21805: LD_EXP 79
21809: PPUSH
21810: LD_VAR 0 1
21814: PPUSH
21815: EMPTY
21816: PPUSH
21817: CALL_OW 1
21821: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21822: LD_ADDR_EXP 80
21826: PUSH
21827: LD_EXP 80
21831: PPUSH
21832: LD_VAR 0 1
21836: PPUSH
21837: EMPTY
21838: PPUSH
21839: CALL_OW 1
21843: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21844: LD_ADDR_EXP 81
21848: PUSH
21849: LD_EXP 81
21853: PPUSH
21854: LD_VAR 0 1
21858: PPUSH
21859: EMPTY
21860: PPUSH
21861: CALL_OW 1
21865: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21866: LD_ADDR_EXP 82
21870: PUSH
21871: LD_EXP 82
21875: PPUSH
21876: LD_VAR 0 1
21880: PPUSH
21881: EMPTY
21882: PPUSH
21883: CALL_OW 1
21887: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21888: LD_ADDR_EXP 83
21892: PUSH
21893: LD_EXP 83
21897: PPUSH
21898: LD_VAR 0 1
21902: PPUSH
21903: EMPTY
21904: PPUSH
21905: CALL_OW 1
21909: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21910: LD_ADDR_EXP 84
21914: PUSH
21915: LD_EXP 84
21919: PPUSH
21920: LD_VAR 0 1
21924: PPUSH
21925: EMPTY
21926: PPUSH
21927: CALL_OW 1
21931: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21932: LD_ADDR_EXP 85
21936: PUSH
21937: LD_EXP 85
21941: PPUSH
21942: LD_VAR 0 1
21946: PPUSH
21947: EMPTY
21948: PPUSH
21949: CALL_OW 1
21953: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21954: LD_ADDR_EXP 86
21958: PUSH
21959: LD_EXP 86
21963: PPUSH
21964: LD_VAR 0 1
21968: PPUSH
21969: EMPTY
21970: PPUSH
21971: CALL_OW 1
21975: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21976: LD_ADDR_EXP 87
21980: PUSH
21981: LD_EXP 87
21985: PPUSH
21986: LD_VAR 0 1
21990: PPUSH
21991: EMPTY
21992: PPUSH
21993: CALL_OW 1
21997: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21998: LD_ADDR_EXP 88
22002: PUSH
22003: LD_EXP 88
22007: PPUSH
22008: LD_VAR 0 1
22012: PPUSH
22013: EMPTY
22014: PPUSH
22015: CALL_OW 1
22019: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22020: LD_ADDR_EXP 89
22024: PUSH
22025: LD_EXP 89
22029: PPUSH
22030: LD_VAR 0 1
22034: PPUSH
22035: LD_INT 0
22037: PPUSH
22038: CALL_OW 1
22042: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22043: LD_ADDR_EXP 90
22047: PUSH
22048: LD_EXP 90
22052: PPUSH
22053: LD_VAR 0 1
22057: PPUSH
22058: EMPTY
22059: PPUSH
22060: CALL_OW 1
22064: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22065: LD_ADDR_EXP 91
22069: PUSH
22070: LD_EXP 91
22074: PPUSH
22075: LD_VAR 0 1
22079: PPUSH
22080: EMPTY
22081: PPUSH
22082: CALL_OW 1
22086: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22087: LD_ADDR_EXP 92
22091: PUSH
22092: LD_EXP 92
22096: PPUSH
22097: LD_VAR 0 1
22101: PPUSH
22102: EMPTY
22103: PPUSH
22104: CALL_OW 1
22108: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22109: LD_ADDR_EXP 93
22113: PUSH
22114: LD_EXP 93
22118: PPUSH
22119: LD_VAR 0 1
22123: PPUSH
22124: EMPTY
22125: PPUSH
22126: CALL_OW 1
22130: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22131: LD_ADDR_EXP 94
22135: PUSH
22136: LD_EXP 94
22140: PPUSH
22141: LD_VAR 0 1
22145: PPUSH
22146: EMPTY
22147: PPUSH
22148: CALL_OW 1
22152: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22153: LD_ADDR_EXP 95
22157: PUSH
22158: LD_EXP 95
22162: PPUSH
22163: LD_VAR 0 1
22167: PPUSH
22168: EMPTY
22169: PPUSH
22170: CALL_OW 1
22174: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22175: LD_ADDR_EXP 96
22179: PUSH
22180: LD_EXP 96
22184: PPUSH
22185: LD_VAR 0 1
22189: PPUSH
22190: EMPTY
22191: PPUSH
22192: CALL_OW 1
22196: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22197: LD_ADDR_EXP 97
22201: PUSH
22202: LD_EXP 97
22206: PPUSH
22207: LD_VAR 0 1
22211: PPUSH
22212: EMPTY
22213: PPUSH
22214: CALL_OW 1
22218: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22219: LD_ADDR_EXP 98
22223: PUSH
22224: LD_EXP 98
22228: PPUSH
22229: LD_VAR 0 1
22233: PPUSH
22234: EMPTY
22235: PPUSH
22236: CALL_OW 1
22240: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22241: LD_ADDR_EXP 99
22245: PUSH
22246: LD_EXP 99
22250: PPUSH
22251: LD_VAR 0 1
22255: PPUSH
22256: EMPTY
22257: PPUSH
22258: CALL_OW 1
22262: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22263: LD_ADDR_EXP 100
22267: PUSH
22268: LD_EXP 100
22272: PPUSH
22273: LD_VAR 0 1
22277: PPUSH
22278: EMPTY
22279: PPUSH
22280: CALL_OW 1
22284: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22285: LD_ADDR_EXP 101
22289: PUSH
22290: LD_EXP 101
22294: PPUSH
22295: LD_VAR 0 1
22299: PPUSH
22300: EMPTY
22301: PPUSH
22302: CALL_OW 1
22306: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22307: LD_ADDR_EXP 102
22311: PUSH
22312: LD_EXP 102
22316: PPUSH
22317: LD_VAR 0 1
22321: PPUSH
22322: EMPTY
22323: PPUSH
22324: CALL_OW 1
22328: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22329: LD_ADDR_EXP 103
22333: PUSH
22334: LD_EXP 103
22338: PPUSH
22339: LD_VAR 0 1
22343: PPUSH
22344: EMPTY
22345: PPUSH
22346: CALL_OW 1
22350: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22351: LD_ADDR_EXP 105
22355: PUSH
22356: LD_EXP 105
22360: PPUSH
22361: LD_VAR 0 1
22365: PPUSH
22366: EMPTY
22367: PPUSH
22368: CALL_OW 1
22372: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22373: LD_ADDR_EXP 107
22377: PUSH
22378: LD_EXP 107
22382: PPUSH
22383: LD_VAR 0 1
22387: PPUSH
22388: EMPTY
22389: PPUSH
22390: CALL_OW 1
22394: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22395: LD_ADDR_EXP 108
22399: PUSH
22400: LD_EXP 108
22404: PPUSH
22405: LD_VAR 0 1
22409: PPUSH
22410: EMPTY
22411: PPUSH
22412: CALL_OW 1
22416: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22417: LD_ADDR_EXP 109
22421: PUSH
22422: LD_EXP 109
22426: PPUSH
22427: LD_VAR 0 1
22431: PPUSH
22432: EMPTY
22433: PPUSH
22434: CALL_OW 1
22438: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22439: LD_ADDR_EXP 110
22443: PUSH
22444: LD_EXP 110
22448: PPUSH
22449: LD_VAR 0 1
22453: PPUSH
22454: EMPTY
22455: PPUSH
22456: CALL_OW 1
22460: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22461: LD_ADDR_EXP 111
22465: PUSH
22466: LD_EXP 111
22470: PPUSH
22471: LD_VAR 0 1
22475: PPUSH
22476: EMPTY
22477: PPUSH
22478: CALL_OW 1
22482: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22483: LD_ADDR_EXP 112
22487: PUSH
22488: LD_EXP 112
22492: PPUSH
22493: LD_VAR 0 1
22497: PPUSH
22498: EMPTY
22499: PPUSH
22500: CALL_OW 1
22504: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22505: LD_ADDR_EXP 113
22509: PUSH
22510: LD_EXP 113
22514: PPUSH
22515: LD_VAR 0 1
22519: PPUSH
22520: EMPTY
22521: PPUSH
22522: CALL_OW 1
22526: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22527: LD_ADDR_EXP 114
22531: PUSH
22532: LD_EXP 114
22536: PPUSH
22537: LD_VAR 0 1
22541: PPUSH
22542: EMPTY
22543: PPUSH
22544: CALL_OW 1
22548: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22549: LD_ADDR_EXP 115
22553: PUSH
22554: LD_EXP 115
22558: PPUSH
22559: LD_VAR 0 1
22563: PPUSH
22564: EMPTY
22565: PPUSH
22566: CALL_OW 1
22570: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22571: LD_ADDR_EXP 116
22575: PUSH
22576: LD_EXP 116
22580: PPUSH
22581: LD_VAR 0 1
22585: PPUSH
22586: EMPTY
22587: PPUSH
22588: CALL_OW 1
22592: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22593: LD_ADDR_EXP 117
22597: PUSH
22598: LD_EXP 117
22602: PPUSH
22603: LD_VAR 0 1
22607: PPUSH
22608: EMPTY
22609: PPUSH
22610: CALL_OW 1
22614: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22615: LD_ADDR_EXP 118
22619: PUSH
22620: LD_EXP 118
22624: PPUSH
22625: LD_VAR 0 1
22629: PPUSH
22630: EMPTY
22631: PPUSH
22632: CALL_OW 1
22636: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22637: LD_ADDR_EXP 119
22641: PUSH
22642: LD_EXP 119
22646: PPUSH
22647: LD_VAR 0 1
22651: PPUSH
22652: EMPTY
22653: PPUSH
22654: CALL_OW 1
22658: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22659: LD_ADDR_EXP 120
22663: PUSH
22664: LD_EXP 120
22668: PPUSH
22669: LD_VAR 0 1
22673: PPUSH
22674: LD_INT 0
22676: PPUSH
22677: CALL_OW 1
22681: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22682: LD_ADDR_EXP 121
22686: PUSH
22687: LD_EXP 121
22691: PPUSH
22692: LD_VAR 0 1
22696: PPUSH
22697: LD_INT 0
22699: PPUSH
22700: CALL_OW 1
22704: ST_TO_ADDR
// end ;
22705: LD_VAR 0 2
22709: RET
// export function MC_Add ( side , units ) ; var base ; begin
22710: LD_INT 0
22712: PPUSH
22713: PPUSH
// base := mc_bases + 1 ;
22714: LD_ADDR_VAR 0 4
22718: PUSH
22719: LD_EXP 78
22723: PUSH
22724: LD_INT 1
22726: PLUS
22727: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22728: LD_ADDR_EXP 104
22732: PUSH
22733: LD_EXP 104
22737: PPUSH
22738: LD_VAR 0 4
22742: PPUSH
22743: LD_VAR 0 1
22747: PPUSH
22748: CALL_OW 1
22752: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22753: LD_ADDR_EXP 78
22757: PUSH
22758: LD_EXP 78
22762: PPUSH
22763: LD_VAR 0 4
22767: PPUSH
22768: LD_VAR 0 2
22772: PPUSH
22773: CALL_OW 1
22777: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22778: LD_ADDR_EXP 79
22782: PUSH
22783: LD_EXP 79
22787: PPUSH
22788: LD_VAR 0 4
22792: PPUSH
22793: EMPTY
22794: PPUSH
22795: CALL_OW 1
22799: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22800: LD_ADDR_EXP 80
22804: PUSH
22805: LD_EXP 80
22809: PPUSH
22810: LD_VAR 0 4
22814: PPUSH
22815: EMPTY
22816: PPUSH
22817: CALL_OW 1
22821: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22822: LD_ADDR_EXP 81
22826: PUSH
22827: LD_EXP 81
22831: PPUSH
22832: LD_VAR 0 4
22836: PPUSH
22837: EMPTY
22838: PPUSH
22839: CALL_OW 1
22843: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22844: LD_ADDR_EXP 82
22848: PUSH
22849: LD_EXP 82
22853: PPUSH
22854: LD_VAR 0 4
22858: PPUSH
22859: EMPTY
22860: PPUSH
22861: CALL_OW 1
22865: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22866: LD_ADDR_EXP 83
22870: PUSH
22871: LD_EXP 83
22875: PPUSH
22876: LD_VAR 0 4
22880: PPUSH
22881: EMPTY
22882: PPUSH
22883: CALL_OW 1
22887: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22888: LD_ADDR_EXP 84
22892: PUSH
22893: LD_EXP 84
22897: PPUSH
22898: LD_VAR 0 4
22902: PPUSH
22903: EMPTY
22904: PPUSH
22905: CALL_OW 1
22909: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22910: LD_ADDR_EXP 85
22914: PUSH
22915: LD_EXP 85
22919: PPUSH
22920: LD_VAR 0 4
22924: PPUSH
22925: EMPTY
22926: PPUSH
22927: CALL_OW 1
22931: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22932: LD_ADDR_EXP 86
22936: PUSH
22937: LD_EXP 86
22941: PPUSH
22942: LD_VAR 0 4
22946: PPUSH
22947: EMPTY
22948: PPUSH
22949: CALL_OW 1
22953: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22954: LD_ADDR_EXP 87
22958: PUSH
22959: LD_EXP 87
22963: PPUSH
22964: LD_VAR 0 4
22968: PPUSH
22969: EMPTY
22970: PPUSH
22971: CALL_OW 1
22975: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22976: LD_ADDR_EXP 88
22980: PUSH
22981: LD_EXP 88
22985: PPUSH
22986: LD_VAR 0 4
22990: PPUSH
22991: EMPTY
22992: PPUSH
22993: CALL_OW 1
22997: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22998: LD_ADDR_EXP 89
23002: PUSH
23003: LD_EXP 89
23007: PPUSH
23008: LD_VAR 0 4
23012: PPUSH
23013: LD_INT 0
23015: PPUSH
23016: CALL_OW 1
23020: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23021: LD_ADDR_EXP 90
23025: PUSH
23026: LD_EXP 90
23030: PPUSH
23031: LD_VAR 0 4
23035: PPUSH
23036: EMPTY
23037: PPUSH
23038: CALL_OW 1
23042: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23043: LD_ADDR_EXP 91
23047: PUSH
23048: LD_EXP 91
23052: PPUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: EMPTY
23059: PPUSH
23060: CALL_OW 1
23064: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23065: LD_ADDR_EXP 92
23069: PUSH
23070: LD_EXP 92
23074: PPUSH
23075: LD_VAR 0 4
23079: PPUSH
23080: EMPTY
23081: PPUSH
23082: CALL_OW 1
23086: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23087: LD_ADDR_EXP 93
23091: PUSH
23092: LD_EXP 93
23096: PPUSH
23097: LD_VAR 0 4
23101: PPUSH
23102: EMPTY
23103: PPUSH
23104: CALL_OW 1
23108: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23109: LD_ADDR_EXP 94
23113: PUSH
23114: LD_EXP 94
23118: PPUSH
23119: LD_VAR 0 4
23123: PPUSH
23124: EMPTY
23125: PPUSH
23126: CALL_OW 1
23130: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23131: LD_ADDR_EXP 95
23135: PUSH
23136: LD_EXP 95
23140: PPUSH
23141: LD_VAR 0 4
23145: PPUSH
23146: EMPTY
23147: PPUSH
23148: CALL_OW 1
23152: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23153: LD_ADDR_EXP 96
23157: PUSH
23158: LD_EXP 96
23162: PPUSH
23163: LD_VAR 0 4
23167: PPUSH
23168: EMPTY
23169: PPUSH
23170: CALL_OW 1
23174: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23175: LD_ADDR_EXP 97
23179: PUSH
23180: LD_EXP 97
23184: PPUSH
23185: LD_VAR 0 4
23189: PPUSH
23190: EMPTY
23191: PPUSH
23192: CALL_OW 1
23196: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23197: LD_ADDR_EXP 98
23201: PUSH
23202: LD_EXP 98
23206: PPUSH
23207: LD_VAR 0 4
23211: PPUSH
23212: EMPTY
23213: PPUSH
23214: CALL_OW 1
23218: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23219: LD_ADDR_EXP 99
23223: PUSH
23224: LD_EXP 99
23228: PPUSH
23229: LD_VAR 0 4
23233: PPUSH
23234: EMPTY
23235: PPUSH
23236: CALL_OW 1
23240: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23241: LD_ADDR_EXP 100
23245: PUSH
23246: LD_EXP 100
23250: PPUSH
23251: LD_VAR 0 4
23255: PPUSH
23256: EMPTY
23257: PPUSH
23258: CALL_OW 1
23262: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23263: LD_ADDR_EXP 101
23267: PUSH
23268: LD_EXP 101
23272: PPUSH
23273: LD_VAR 0 4
23277: PPUSH
23278: EMPTY
23279: PPUSH
23280: CALL_OW 1
23284: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23285: LD_ADDR_EXP 102
23289: PUSH
23290: LD_EXP 102
23294: PPUSH
23295: LD_VAR 0 4
23299: PPUSH
23300: EMPTY
23301: PPUSH
23302: CALL_OW 1
23306: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23307: LD_ADDR_EXP 103
23311: PUSH
23312: LD_EXP 103
23316: PPUSH
23317: LD_VAR 0 4
23321: PPUSH
23322: EMPTY
23323: PPUSH
23324: CALL_OW 1
23328: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23329: LD_ADDR_EXP 105
23333: PUSH
23334: LD_EXP 105
23338: PPUSH
23339: LD_VAR 0 4
23343: PPUSH
23344: EMPTY
23345: PPUSH
23346: CALL_OW 1
23350: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23351: LD_ADDR_EXP 107
23355: PUSH
23356: LD_EXP 107
23360: PPUSH
23361: LD_VAR 0 4
23365: PPUSH
23366: EMPTY
23367: PPUSH
23368: CALL_OW 1
23372: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23373: LD_ADDR_EXP 108
23377: PUSH
23378: LD_EXP 108
23382: PPUSH
23383: LD_VAR 0 4
23387: PPUSH
23388: EMPTY
23389: PPUSH
23390: CALL_OW 1
23394: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23395: LD_ADDR_EXP 109
23399: PUSH
23400: LD_EXP 109
23404: PPUSH
23405: LD_VAR 0 4
23409: PPUSH
23410: EMPTY
23411: PPUSH
23412: CALL_OW 1
23416: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23417: LD_ADDR_EXP 110
23421: PUSH
23422: LD_EXP 110
23426: PPUSH
23427: LD_VAR 0 4
23431: PPUSH
23432: EMPTY
23433: PPUSH
23434: CALL_OW 1
23438: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23439: LD_ADDR_EXP 111
23443: PUSH
23444: LD_EXP 111
23448: PPUSH
23449: LD_VAR 0 4
23453: PPUSH
23454: EMPTY
23455: PPUSH
23456: CALL_OW 1
23460: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23461: LD_ADDR_EXP 112
23465: PUSH
23466: LD_EXP 112
23470: PPUSH
23471: LD_VAR 0 4
23475: PPUSH
23476: EMPTY
23477: PPUSH
23478: CALL_OW 1
23482: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23483: LD_ADDR_EXP 113
23487: PUSH
23488: LD_EXP 113
23492: PPUSH
23493: LD_VAR 0 4
23497: PPUSH
23498: EMPTY
23499: PPUSH
23500: CALL_OW 1
23504: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23505: LD_ADDR_EXP 114
23509: PUSH
23510: LD_EXP 114
23514: PPUSH
23515: LD_VAR 0 4
23519: PPUSH
23520: EMPTY
23521: PPUSH
23522: CALL_OW 1
23526: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23527: LD_ADDR_EXP 115
23531: PUSH
23532: LD_EXP 115
23536: PPUSH
23537: LD_VAR 0 4
23541: PPUSH
23542: EMPTY
23543: PPUSH
23544: CALL_OW 1
23548: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23549: LD_ADDR_EXP 116
23553: PUSH
23554: LD_EXP 116
23558: PPUSH
23559: LD_VAR 0 4
23563: PPUSH
23564: EMPTY
23565: PPUSH
23566: CALL_OW 1
23570: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23571: LD_ADDR_EXP 117
23575: PUSH
23576: LD_EXP 117
23580: PPUSH
23581: LD_VAR 0 4
23585: PPUSH
23586: EMPTY
23587: PPUSH
23588: CALL_OW 1
23592: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23593: LD_ADDR_EXP 118
23597: PUSH
23598: LD_EXP 118
23602: PPUSH
23603: LD_VAR 0 4
23607: PPUSH
23608: EMPTY
23609: PPUSH
23610: CALL_OW 1
23614: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23615: LD_ADDR_EXP 119
23619: PUSH
23620: LD_EXP 119
23624: PPUSH
23625: LD_VAR 0 4
23629: PPUSH
23630: EMPTY
23631: PPUSH
23632: CALL_OW 1
23636: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23637: LD_ADDR_EXP 120
23641: PUSH
23642: LD_EXP 120
23646: PPUSH
23647: LD_VAR 0 4
23651: PPUSH
23652: LD_INT 0
23654: PPUSH
23655: CALL_OW 1
23659: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23660: LD_ADDR_EXP 121
23664: PUSH
23665: LD_EXP 121
23669: PPUSH
23670: LD_VAR 0 4
23674: PPUSH
23675: LD_INT 0
23677: PPUSH
23678: CALL_OW 1
23682: ST_TO_ADDR
// result := base ;
23683: LD_ADDR_VAR 0 3
23687: PUSH
23688: LD_VAR 0 4
23692: ST_TO_ADDR
// end ;
23693: LD_VAR 0 3
23697: RET
// export function MC_Start ( ) ; var i ; begin
23698: LD_INT 0
23700: PPUSH
23701: PPUSH
// for i = 1 to mc_bases do
23702: LD_ADDR_VAR 0 2
23706: PUSH
23707: DOUBLE
23708: LD_INT 1
23710: DEC
23711: ST_TO_ADDR
23712: LD_EXP 78
23716: PUSH
23717: FOR_TO
23718: IFFALSE 24818
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23720: LD_ADDR_EXP 78
23724: PUSH
23725: LD_EXP 78
23729: PPUSH
23730: LD_VAR 0 2
23734: PPUSH
23735: LD_EXP 78
23739: PUSH
23740: LD_VAR 0 2
23744: ARRAY
23745: PUSH
23746: LD_INT 0
23748: DIFF
23749: PPUSH
23750: CALL_OW 1
23754: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23755: LD_ADDR_EXP 79
23759: PUSH
23760: LD_EXP 79
23764: PPUSH
23765: LD_VAR 0 2
23769: PPUSH
23770: EMPTY
23771: PPUSH
23772: CALL_OW 1
23776: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23777: LD_ADDR_EXP 80
23781: PUSH
23782: LD_EXP 80
23786: PPUSH
23787: LD_VAR 0 2
23791: PPUSH
23792: EMPTY
23793: PPUSH
23794: CALL_OW 1
23798: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23799: LD_ADDR_EXP 81
23803: PUSH
23804: LD_EXP 81
23808: PPUSH
23809: LD_VAR 0 2
23813: PPUSH
23814: EMPTY
23815: PPUSH
23816: CALL_OW 1
23820: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23821: LD_ADDR_EXP 82
23825: PUSH
23826: LD_EXP 82
23830: PPUSH
23831: LD_VAR 0 2
23835: PPUSH
23836: EMPTY
23837: PUSH
23838: EMPTY
23839: PUSH
23840: EMPTY
23841: LIST
23842: LIST
23843: PPUSH
23844: CALL_OW 1
23848: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23849: LD_ADDR_EXP 83
23853: PUSH
23854: LD_EXP 83
23858: PPUSH
23859: LD_VAR 0 2
23863: PPUSH
23864: EMPTY
23865: PPUSH
23866: CALL_OW 1
23870: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23871: LD_ADDR_EXP 110
23875: PUSH
23876: LD_EXP 110
23880: PPUSH
23881: LD_VAR 0 2
23885: PPUSH
23886: EMPTY
23887: PPUSH
23888: CALL_OW 1
23892: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23893: LD_ADDR_EXP 84
23897: PUSH
23898: LD_EXP 84
23902: PPUSH
23903: LD_VAR 0 2
23907: PPUSH
23908: EMPTY
23909: PPUSH
23910: CALL_OW 1
23914: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23915: LD_ADDR_EXP 85
23919: PUSH
23920: LD_EXP 85
23924: PPUSH
23925: LD_VAR 0 2
23929: PPUSH
23930: EMPTY
23931: PPUSH
23932: CALL_OW 1
23936: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23937: LD_ADDR_EXP 86
23941: PUSH
23942: LD_EXP 86
23946: PPUSH
23947: LD_VAR 0 2
23951: PPUSH
23952: LD_EXP 78
23956: PUSH
23957: LD_VAR 0 2
23961: ARRAY
23962: PPUSH
23963: LD_INT 2
23965: PUSH
23966: LD_INT 30
23968: PUSH
23969: LD_INT 32
23971: PUSH
23972: EMPTY
23973: LIST
23974: LIST
23975: PUSH
23976: LD_INT 30
23978: PUSH
23979: LD_INT 33
23981: PUSH
23982: EMPTY
23983: LIST
23984: LIST
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: LIST
23990: PPUSH
23991: CALL_OW 72
23995: PPUSH
23996: CALL_OW 1
24000: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
24001: LD_ADDR_EXP 87
24005: PUSH
24006: LD_EXP 87
24010: PPUSH
24011: LD_VAR 0 2
24015: PPUSH
24016: LD_EXP 78
24020: PUSH
24021: LD_VAR 0 2
24025: ARRAY
24026: PPUSH
24027: LD_INT 2
24029: PUSH
24030: LD_INT 30
24032: PUSH
24033: LD_INT 32
24035: PUSH
24036: EMPTY
24037: LIST
24038: LIST
24039: PUSH
24040: LD_INT 30
24042: PUSH
24043: LD_INT 31
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: PUSH
24050: EMPTY
24051: LIST
24052: LIST
24053: LIST
24054: PUSH
24055: LD_INT 58
24057: PUSH
24058: EMPTY
24059: LIST
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PPUSH
24065: CALL_OW 72
24069: PPUSH
24070: CALL_OW 1
24074: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
24075: LD_ADDR_EXP 88
24079: PUSH
24080: LD_EXP 88
24084: PPUSH
24085: LD_VAR 0 2
24089: PPUSH
24090: EMPTY
24091: PPUSH
24092: CALL_OW 1
24096: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
24097: LD_ADDR_EXP 92
24101: PUSH
24102: LD_EXP 92
24106: PPUSH
24107: LD_VAR 0 2
24111: PPUSH
24112: EMPTY
24113: PPUSH
24114: CALL_OW 1
24118: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
24119: LD_ADDR_EXP 91
24123: PUSH
24124: LD_EXP 91
24128: PPUSH
24129: LD_VAR 0 2
24133: PPUSH
24134: EMPTY
24135: PPUSH
24136: CALL_OW 1
24140: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24141: LD_ADDR_EXP 93
24145: PUSH
24146: LD_EXP 93
24150: PPUSH
24151: LD_VAR 0 2
24155: PPUSH
24156: EMPTY
24157: PPUSH
24158: CALL_OW 1
24162: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24163: LD_ADDR_EXP 94
24167: PUSH
24168: LD_EXP 94
24172: PPUSH
24173: LD_VAR 0 2
24177: PPUSH
24178: EMPTY
24179: PPUSH
24180: CALL_OW 1
24184: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24185: LD_ADDR_EXP 95
24189: PUSH
24190: LD_EXP 95
24194: PPUSH
24195: LD_VAR 0 2
24199: PPUSH
24200: EMPTY
24201: PPUSH
24202: CALL_OW 1
24206: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24207: LD_ADDR_EXP 96
24211: PUSH
24212: LD_EXP 96
24216: PPUSH
24217: LD_VAR 0 2
24221: PPUSH
24222: EMPTY
24223: PPUSH
24224: CALL_OW 1
24228: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24229: LD_ADDR_EXP 97
24233: PUSH
24234: LD_EXP 97
24238: PPUSH
24239: LD_VAR 0 2
24243: PPUSH
24244: EMPTY
24245: PPUSH
24246: CALL_OW 1
24250: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24251: LD_ADDR_EXP 98
24255: PUSH
24256: LD_EXP 98
24260: PPUSH
24261: LD_VAR 0 2
24265: PPUSH
24266: EMPTY
24267: PPUSH
24268: CALL_OW 1
24272: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24273: LD_ADDR_EXP 99
24277: PUSH
24278: LD_EXP 99
24282: PPUSH
24283: LD_VAR 0 2
24287: PPUSH
24288: EMPTY
24289: PPUSH
24290: CALL_OW 1
24294: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24295: LD_ADDR_EXP 100
24299: PUSH
24300: LD_EXP 100
24304: PPUSH
24305: LD_VAR 0 2
24309: PPUSH
24310: EMPTY
24311: PPUSH
24312: CALL_OW 1
24316: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24317: LD_ADDR_EXP 89
24321: PUSH
24322: LD_EXP 89
24326: PPUSH
24327: LD_VAR 0 2
24331: PPUSH
24332: LD_INT 0
24334: PPUSH
24335: CALL_OW 1
24339: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24340: LD_ADDR_EXP 102
24344: PUSH
24345: LD_EXP 102
24349: PPUSH
24350: LD_VAR 0 2
24354: PPUSH
24355: LD_INT 0
24357: PPUSH
24358: CALL_OW 1
24362: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24363: LD_ADDR_EXP 90
24367: PUSH
24368: LD_EXP 90
24372: PPUSH
24373: LD_VAR 0 2
24377: PPUSH
24378: EMPTY
24379: PPUSH
24380: CALL_OW 1
24384: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24385: LD_ADDR_EXP 101
24389: PUSH
24390: LD_EXP 101
24394: PPUSH
24395: LD_VAR 0 2
24399: PPUSH
24400: LD_INT 0
24402: PPUSH
24403: CALL_OW 1
24407: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24408: LD_ADDR_EXP 103
24412: PUSH
24413: LD_EXP 103
24417: PPUSH
24418: LD_VAR 0 2
24422: PPUSH
24423: EMPTY
24424: PPUSH
24425: CALL_OW 1
24429: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24430: LD_ADDR_EXP 106
24434: PUSH
24435: LD_EXP 106
24439: PPUSH
24440: LD_VAR 0 2
24444: PPUSH
24445: LD_INT 0
24447: PPUSH
24448: CALL_OW 1
24452: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24453: LD_ADDR_EXP 107
24457: PUSH
24458: LD_EXP 107
24462: PPUSH
24463: LD_VAR 0 2
24467: PPUSH
24468: EMPTY
24469: PPUSH
24470: CALL_OW 1
24474: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24475: LD_ADDR_EXP 108
24479: PUSH
24480: LD_EXP 108
24484: PPUSH
24485: LD_VAR 0 2
24489: PPUSH
24490: EMPTY
24491: PPUSH
24492: CALL_OW 1
24496: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24497: LD_ADDR_EXP 109
24501: PUSH
24502: LD_EXP 109
24506: PPUSH
24507: LD_VAR 0 2
24511: PPUSH
24512: EMPTY
24513: PPUSH
24514: CALL_OW 1
24518: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24519: LD_ADDR_EXP 111
24523: PUSH
24524: LD_EXP 111
24528: PPUSH
24529: LD_VAR 0 2
24533: PPUSH
24534: LD_EXP 78
24538: PUSH
24539: LD_VAR 0 2
24543: ARRAY
24544: PPUSH
24545: LD_INT 2
24547: PUSH
24548: LD_INT 30
24550: PUSH
24551: LD_INT 6
24553: PUSH
24554: EMPTY
24555: LIST
24556: LIST
24557: PUSH
24558: LD_INT 30
24560: PUSH
24561: LD_INT 7
24563: PUSH
24564: EMPTY
24565: LIST
24566: LIST
24567: PUSH
24568: LD_INT 30
24570: PUSH
24571: LD_INT 8
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PUSH
24578: EMPTY
24579: LIST
24580: LIST
24581: LIST
24582: LIST
24583: PPUSH
24584: CALL_OW 72
24588: PPUSH
24589: CALL_OW 1
24593: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24594: LD_ADDR_EXP 112
24598: PUSH
24599: LD_EXP 112
24603: PPUSH
24604: LD_VAR 0 2
24608: PPUSH
24609: EMPTY
24610: PPUSH
24611: CALL_OW 1
24615: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24616: LD_ADDR_EXP 113
24620: PUSH
24621: LD_EXP 113
24625: PPUSH
24626: LD_VAR 0 2
24630: PPUSH
24631: EMPTY
24632: PPUSH
24633: CALL_OW 1
24637: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24638: LD_ADDR_EXP 114
24642: PUSH
24643: LD_EXP 114
24647: PPUSH
24648: LD_VAR 0 2
24652: PPUSH
24653: EMPTY
24654: PPUSH
24655: CALL_OW 1
24659: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24660: LD_ADDR_EXP 115
24664: PUSH
24665: LD_EXP 115
24669: PPUSH
24670: LD_VAR 0 2
24674: PPUSH
24675: EMPTY
24676: PPUSH
24677: CALL_OW 1
24681: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24682: LD_ADDR_EXP 116
24686: PUSH
24687: LD_EXP 116
24691: PPUSH
24692: LD_VAR 0 2
24696: PPUSH
24697: EMPTY
24698: PPUSH
24699: CALL_OW 1
24703: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24704: LD_ADDR_EXP 117
24708: PUSH
24709: LD_EXP 117
24713: PPUSH
24714: LD_VAR 0 2
24718: PPUSH
24719: EMPTY
24720: PPUSH
24721: CALL_OW 1
24725: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24726: LD_ADDR_EXP 118
24730: PUSH
24731: LD_EXP 118
24735: PPUSH
24736: LD_VAR 0 2
24740: PPUSH
24741: EMPTY
24742: PPUSH
24743: CALL_OW 1
24747: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24748: LD_ADDR_EXP 119
24752: PUSH
24753: LD_EXP 119
24757: PPUSH
24758: LD_VAR 0 2
24762: PPUSH
24763: EMPTY
24764: PPUSH
24765: CALL_OW 1
24769: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24770: LD_ADDR_EXP 120
24774: PUSH
24775: LD_EXP 120
24779: PPUSH
24780: LD_VAR 0 2
24784: PPUSH
24785: LD_INT 0
24787: PPUSH
24788: CALL_OW 1
24792: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24793: LD_ADDR_EXP 121
24797: PUSH
24798: LD_EXP 121
24802: PPUSH
24803: LD_VAR 0 2
24807: PPUSH
24808: LD_INT 0
24810: PPUSH
24811: CALL_OW 1
24815: ST_TO_ADDR
// end ;
24816: GO 23717
24818: POP
24819: POP
// MC_InitSides ( ) ;
24820: CALL 25106 0 0
// MC_InitResearch ( ) ;
24824: CALL 24845 0 0
// CustomInitMacro ( ) ;
24828: CALL 228 0 0
// skirmish := true ;
24832: LD_ADDR_EXP 76
24836: PUSH
24837: LD_INT 1
24839: ST_TO_ADDR
// end ;
24840: LD_VAR 0 1
24844: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24845: LD_INT 0
24847: PPUSH
24848: PPUSH
24849: PPUSH
24850: PPUSH
24851: PPUSH
24852: PPUSH
// if not mc_bases then
24853: LD_EXP 78
24857: NOT
24858: IFFALSE 24862
// exit ;
24860: GO 25101
// for i = 1 to 8 do
24862: LD_ADDR_VAR 0 2
24866: PUSH
24867: DOUBLE
24868: LD_INT 1
24870: DEC
24871: ST_TO_ADDR
24872: LD_INT 8
24874: PUSH
24875: FOR_TO
24876: IFFALSE 24902
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24878: LD_ADDR_EXP 105
24882: PUSH
24883: LD_EXP 105
24887: PPUSH
24888: LD_VAR 0 2
24892: PPUSH
24893: EMPTY
24894: PPUSH
24895: CALL_OW 1
24899: ST_TO_ADDR
24900: GO 24875
24902: POP
24903: POP
// tmp := [ ] ;
24904: LD_ADDR_VAR 0 5
24908: PUSH
24909: EMPTY
24910: ST_TO_ADDR
// for i = 1 to mc_sides do
24911: LD_ADDR_VAR 0 2
24915: PUSH
24916: DOUBLE
24917: LD_INT 1
24919: DEC
24920: ST_TO_ADDR
24921: LD_EXP 104
24925: PUSH
24926: FOR_TO
24927: IFFALSE 24985
// if not mc_sides [ i ] in tmp then
24929: LD_EXP 104
24933: PUSH
24934: LD_VAR 0 2
24938: ARRAY
24939: PUSH
24940: LD_VAR 0 5
24944: IN
24945: NOT
24946: IFFALSE 24983
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24948: LD_ADDR_VAR 0 5
24952: PUSH
24953: LD_VAR 0 5
24957: PPUSH
24958: LD_VAR 0 5
24962: PUSH
24963: LD_INT 1
24965: PLUS
24966: PPUSH
24967: LD_EXP 104
24971: PUSH
24972: LD_VAR 0 2
24976: ARRAY
24977: PPUSH
24978: CALL_OW 2
24982: ST_TO_ADDR
24983: GO 24926
24985: POP
24986: POP
// if not tmp then
24987: LD_VAR 0 5
24991: NOT
24992: IFFALSE 24996
// exit ;
24994: GO 25101
// for j in tmp do
24996: LD_ADDR_VAR 0 3
25000: PUSH
25001: LD_VAR 0 5
25005: PUSH
25006: FOR_IN
25007: IFFALSE 25099
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
25009: LD_ADDR_VAR 0 6
25013: PUSH
25014: LD_INT 22
25016: PUSH
25017: LD_VAR 0 3
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: PPUSH
25026: CALL_OW 69
25030: ST_TO_ADDR
// if not un then
25031: LD_VAR 0 6
25035: NOT
25036: IFFALSE 25040
// continue ;
25038: GO 25006
// nation := GetNation ( un [ 1 ] ) ;
25040: LD_ADDR_VAR 0 4
25044: PUSH
25045: LD_VAR 0 6
25049: PUSH
25050: LD_INT 1
25052: ARRAY
25053: PPUSH
25054: CALL_OW 248
25058: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
25059: LD_ADDR_EXP 105
25063: PUSH
25064: LD_EXP 105
25068: PPUSH
25069: LD_VAR 0 3
25073: PPUSH
25074: LD_VAR 0 3
25078: PPUSH
25079: LD_VAR 0 4
25083: PPUSH
25084: LD_INT 1
25086: PPUSH
25087: CALL 52275 0 3
25091: PPUSH
25092: CALL_OW 1
25096: ST_TO_ADDR
// end ;
25097: GO 25006
25099: POP
25100: POP
// end ;
25101: LD_VAR 0 1
25105: RET
// export function MC_InitSides ( ) ; var i ; begin
25106: LD_INT 0
25108: PPUSH
25109: PPUSH
// if not mc_bases then
25110: LD_EXP 78
25114: NOT
25115: IFFALSE 25119
// exit ;
25117: GO 25193
// for i = 1 to mc_bases do
25119: LD_ADDR_VAR 0 2
25123: PUSH
25124: DOUBLE
25125: LD_INT 1
25127: DEC
25128: ST_TO_ADDR
25129: LD_EXP 78
25133: PUSH
25134: FOR_TO
25135: IFFALSE 25191
// if mc_bases [ i ] then
25137: LD_EXP 78
25141: PUSH
25142: LD_VAR 0 2
25146: ARRAY
25147: IFFALSE 25189
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25149: LD_ADDR_EXP 104
25153: PUSH
25154: LD_EXP 104
25158: PPUSH
25159: LD_VAR 0 2
25163: PPUSH
25164: LD_EXP 78
25168: PUSH
25169: LD_VAR 0 2
25173: ARRAY
25174: PUSH
25175: LD_INT 1
25177: ARRAY
25178: PPUSH
25179: CALL_OW 255
25183: PPUSH
25184: CALL_OW 1
25188: ST_TO_ADDR
25189: GO 25134
25191: POP
25192: POP
// end ;
25193: LD_VAR 0 1
25197: RET
// every 0 0$03 trigger skirmish do
25198: LD_EXP 76
25202: IFFALSE 25356
25204: GO 25206
25206: DISABLE
// begin enable ;
25207: ENABLE
// MC_CheckBuildings ( ) ;
25208: CALL 29854 0 0
// MC_CheckPeopleLife ( ) ;
25212: CALL 30015 0 0
// RaiseSailEvent ( 100 ) ;
25216: LD_INT 100
25218: PPUSH
25219: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25223: LD_INT 103
25225: PPUSH
25226: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25230: LD_INT 104
25232: PPUSH
25233: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25237: LD_INT 105
25239: PPUSH
25240: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25244: LD_INT 106
25246: PPUSH
25247: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25251: LD_INT 107
25253: PPUSH
25254: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25258: LD_INT 108
25260: PPUSH
25261: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25265: LD_INT 109
25267: PPUSH
25268: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25272: LD_INT 110
25274: PPUSH
25275: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25279: LD_INT 111
25281: PPUSH
25282: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25286: LD_INT 112
25288: PPUSH
25289: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25293: LD_INT 113
25295: PPUSH
25296: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25300: LD_INT 120
25302: PPUSH
25303: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25307: LD_INT 121
25309: PPUSH
25310: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25314: LD_INT 122
25316: PPUSH
25317: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25321: LD_INT 123
25323: PPUSH
25324: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25328: LD_INT 124
25330: PPUSH
25331: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25335: LD_INT 125
25337: PPUSH
25338: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25342: LD_INT 126
25344: PPUSH
25345: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25349: LD_INT 200
25351: PPUSH
25352: CALL_OW 427
// end ;
25356: END
// on SailEvent ( event ) do begin if event < 100 then
25357: LD_VAR 0 1
25361: PUSH
25362: LD_INT 100
25364: LESS
25365: IFFALSE 25376
// CustomEvent ( event ) ;
25367: LD_VAR 0 1
25371: PPUSH
25372: CALL 11147 0 1
// if event = 100 then
25376: LD_VAR 0 1
25380: PUSH
25381: LD_INT 100
25383: EQUAL
25384: IFFALSE 25390
// MC_ClassManager ( ) ;
25386: CALL 25782 0 0
// if event = 101 then
25390: LD_VAR 0 1
25394: PUSH
25395: LD_INT 101
25397: EQUAL
25398: IFFALSE 25404
// MC_RepairBuildings ( ) ;
25400: CALL 30600 0 0
// if event = 102 then
25404: LD_VAR 0 1
25408: PUSH
25409: LD_INT 102
25411: EQUAL
25412: IFFALSE 25418
// MC_Heal ( ) ;
25414: CALL 31535 0 0
// if event = 103 then
25418: LD_VAR 0 1
25422: PUSH
25423: LD_INT 103
25425: EQUAL
25426: IFFALSE 25432
// MC_Build ( ) ;
25428: CALL 31957 0 0
// if event = 104 then
25432: LD_VAR 0 1
25436: PUSH
25437: LD_INT 104
25439: EQUAL
25440: IFFALSE 25446
// MC_TurretWeapon ( ) ;
25442: CALL 33591 0 0
// if event = 105 then
25446: LD_VAR 0 1
25450: PUSH
25451: LD_INT 105
25453: EQUAL
25454: IFFALSE 25460
// MC_BuildUpgrade ( ) ;
25456: CALL 33142 0 0
// if event = 106 then
25460: LD_VAR 0 1
25464: PUSH
25465: LD_INT 106
25467: EQUAL
25468: IFFALSE 25474
// MC_PlantMines ( ) ;
25470: CALL 34021 0 0
// if event = 107 then
25474: LD_VAR 0 1
25478: PUSH
25479: LD_INT 107
25481: EQUAL
25482: IFFALSE 25488
// MC_CollectCrates ( ) ;
25484: CALL 34819 0 0
// if event = 108 then
25488: LD_VAR 0 1
25492: PUSH
25493: LD_INT 108
25495: EQUAL
25496: IFFALSE 25502
// MC_LinkRemoteControl ( ) ;
25498: CALL 36669 0 0
// if event = 109 then
25502: LD_VAR 0 1
25506: PUSH
25507: LD_INT 109
25509: EQUAL
25510: IFFALSE 25516
// MC_ProduceVehicle ( ) ;
25512: CALL 36850 0 0
// if event = 110 then
25516: LD_VAR 0 1
25520: PUSH
25521: LD_INT 110
25523: EQUAL
25524: IFFALSE 25530
// MC_SendAttack ( ) ;
25526: CALL 37316 0 0
// if event = 111 then
25530: LD_VAR 0 1
25534: PUSH
25535: LD_INT 111
25537: EQUAL
25538: IFFALSE 25544
// MC_Defend ( ) ;
25540: CALL 37424 0 0
// if event = 112 then
25544: LD_VAR 0 1
25548: PUSH
25549: LD_INT 112
25551: EQUAL
25552: IFFALSE 25558
// MC_Research ( ) ;
25554: CALL 38304 0 0
// if event = 113 then
25558: LD_VAR 0 1
25562: PUSH
25563: LD_INT 113
25565: EQUAL
25566: IFFALSE 25572
// MC_MinesTrigger ( ) ;
25568: CALL 39418 0 0
// if event = 120 then
25572: LD_VAR 0 1
25576: PUSH
25577: LD_INT 120
25579: EQUAL
25580: IFFALSE 25586
// MC_RepairVehicle ( ) ;
25582: CALL 39517 0 0
// if event = 121 then
25586: LD_VAR 0 1
25590: PUSH
25591: LD_INT 121
25593: EQUAL
25594: IFFALSE 25600
// MC_TameApe ( ) ;
25596: CALL 40286 0 0
// if event = 122 then
25600: LD_VAR 0 1
25604: PUSH
25605: LD_INT 122
25607: EQUAL
25608: IFFALSE 25614
// MC_ChangeApeClass ( ) ;
25610: CALL 41115 0 0
// if event = 123 then
25614: LD_VAR 0 1
25618: PUSH
25619: LD_INT 123
25621: EQUAL
25622: IFFALSE 25628
// MC_Bazooka ( ) ;
25624: CALL 41765 0 0
// if event = 124 then
25628: LD_VAR 0 1
25632: PUSH
25633: LD_INT 124
25635: EQUAL
25636: IFFALSE 25642
// MC_TeleportExit ( ) ;
25638: CALL 41963 0 0
// if event = 125 then
25642: LD_VAR 0 1
25646: PUSH
25647: LD_INT 125
25649: EQUAL
25650: IFFALSE 25656
// MC_Deposits ( ) ;
25652: CALL 42610 0 0
// if event = 126 then
25656: LD_VAR 0 1
25660: PUSH
25661: LD_INT 126
25663: EQUAL
25664: IFFALSE 25670
// MC_RemoteDriver ( ) ;
25666: CALL 43235 0 0
// if event = 200 then
25670: LD_VAR 0 1
25674: PUSH
25675: LD_INT 200
25677: EQUAL
25678: IFFALSE 25684
// MC_Idle ( ) ;
25680: CALL 45142 0 0
// end ;
25684: PPOPN 1
25686: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25687: LD_INT 0
25689: PPUSH
25690: PPUSH
// if not mc_bases [ base ] or not tag then
25691: LD_EXP 78
25695: PUSH
25696: LD_VAR 0 1
25700: ARRAY
25701: NOT
25702: PUSH
25703: LD_VAR 0 2
25707: NOT
25708: OR
25709: IFFALSE 25713
// exit ;
25711: GO 25777
// for i in mc_bases [ base ] union mc_ape [ base ] do
25713: LD_ADDR_VAR 0 4
25717: PUSH
25718: LD_EXP 78
25722: PUSH
25723: LD_VAR 0 1
25727: ARRAY
25728: PUSH
25729: LD_EXP 107
25733: PUSH
25734: LD_VAR 0 1
25738: ARRAY
25739: UNION
25740: PUSH
25741: FOR_IN
25742: IFFALSE 25775
// if GetTag ( i ) = tag then
25744: LD_VAR 0 4
25748: PPUSH
25749: CALL_OW 110
25753: PUSH
25754: LD_VAR 0 2
25758: EQUAL
25759: IFFALSE 25773
// SetTag ( i , 0 ) ;
25761: LD_VAR 0 4
25765: PPUSH
25766: LD_INT 0
25768: PPUSH
25769: CALL_OW 109
25773: GO 25741
25775: POP
25776: POP
// end ;
25777: LD_VAR 0 3
25781: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25782: LD_INT 0
25784: PPUSH
25785: PPUSH
25786: PPUSH
25787: PPUSH
25788: PPUSH
25789: PPUSH
25790: PPUSH
25791: PPUSH
// if not mc_bases then
25792: LD_EXP 78
25796: NOT
25797: IFFALSE 25801
// exit ;
25799: GO 26259
// for i = 1 to mc_bases do
25801: LD_ADDR_VAR 0 2
25805: PUSH
25806: DOUBLE
25807: LD_INT 1
25809: DEC
25810: ST_TO_ADDR
25811: LD_EXP 78
25815: PUSH
25816: FOR_TO
25817: IFFALSE 26257
// begin tmp := MC_ClassCheckReq ( i ) ;
25819: LD_ADDR_VAR 0 4
25823: PUSH
25824: LD_VAR 0 2
25828: PPUSH
25829: CALL 26264 0 1
25833: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25834: LD_ADDR_EXP 119
25838: PUSH
25839: LD_EXP 119
25843: PPUSH
25844: LD_VAR 0 2
25848: PPUSH
25849: LD_VAR 0 4
25853: PPUSH
25854: CALL_OW 1
25858: ST_TO_ADDR
// if not tmp then
25859: LD_VAR 0 4
25863: NOT
25864: IFFALSE 25868
// continue ;
25866: GO 25816
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25868: LD_ADDR_VAR 0 6
25872: PUSH
25873: LD_EXP 78
25877: PUSH
25878: LD_VAR 0 2
25882: ARRAY
25883: PPUSH
25884: LD_INT 2
25886: PUSH
25887: LD_INT 30
25889: PUSH
25890: LD_INT 4
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: PUSH
25897: LD_INT 30
25899: PUSH
25900: LD_INT 5
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: EMPTY
25908: LIST
25909: LIST
25910: LIST
25911: PPUSH
25912: CALL_OW 72
25916: PUSH
25917: LD_EXP 78
25921: PUSH
25922: LD_VAR 0 2
25926: ARRAY
25927: PPUSH
25928: LD_INT 2
25930: PUSH
25931: LD_INT 30
25933: PUSH
25934: LD_INT 0
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: PUSH
25941: LD_INT 30
25943: PUSH
25944: LD_INT 1
25946: PUSH
25947: EMPTY
25948: LIST
25949: LIST
25950: PUSH
25951: EMPTY
25952: LIST
25953: LIST
25954: LIST
25955: PPUSH
25956: CALL_OW 72
25960: PUSH
25961: LD_EXP 78
25965: PUSH
25966: LD_VAR 0 2
25970: ARRAY
25971: PPUSH
25972: LD_INT 30
25974: PUSH
25975: LD_INT 3
25977: PUSH
25978: EMPTY
25979: LIST
25980: LIST
25981: PPUSH
25982: CALL_OW 72
25986: PUSH
25987: LD_EXP 78
25991: PUSH
25992: LD_VAR 0 2
25996: ARRAY
25997: PPUSH
25998: LD_INT 2
26000: PUSH
26001: LD_INT 30
26003: PUSH
26004: LD_INT 6
26006: PUSH
26007: EMPTY
26008: LIST
26009: LIST
26010: PUSH
26011: LD_INT 30
26013: PUSH
26014: LD_INT 7
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PUSH
26021: LD_INT 30
26023: PUSH
26024: LD_INT 8
26026: PUSH
26027: EMPTY
26028: LIST
26029: LIST
26030: PUSH
26031: EMPTY
26032: LIST
26033: LIST
26034: LIST
26035: LIST
26036: PPUSH
26037: CALL_OW 72
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: LIST
26046: LIST
26047: ST_TO_ADDR
// for j = 1 to 4 do
26048: LD_ADDR_VAR 0 3
26052: PUSH
26053: DOUBLE
26054: LD_INT 1
26056: DEC
26057: ST_TO_ADDR
26058: LD_INT 4
26060: PUSH
26061: FOR_TO
26062: IFFALSE 26253
// begin if not tmp [ j ] then
26064: LD_VAR 0 4
26068: PUSH
26069: LD_VAR 0 3
26073: ARRAY
26074: NOT
26075: IFFALSE 26079
// continue ;
26077: GO 26061
// for p in tmp [ j ] do
26079: LD_ADDR_VAR 0 5
26083: PUSH
26084: LD_VAR 0 4
26088: PUSH
26089: LD_VAR 0 3
26093: ARRAY
26094: PUSH
26095: FOR_IN
26096: IFFALSE 26249
// begin if not b [ j ] then
26098: LD_VAR 0 6
26102: PUSH
26103: LD_VAR 0 3
26107: ARRAY
26108: NOT
26109: IFFALSE 26113
// break ;
26111: GO 26249
// e := 0 ;
26113: LD_ADDR_VAR 0 7
26117: PUSH
26118: LD_INT 0
26120: ST_TO_ADDR
// for k in b [ j ] do
26121: LD_ADDR_VAR 0 8
26125: PUSH
26126: LD_VAR 0 6
26130: PUSH
26131: LD_VAR 0 3
26135: ARRAY
26136: PUSH
26137: FOR_IN
26138: IFFALSE 26165
// if IsNotFull ( k ) then
26140: LD_VAR 0 8
26144: PPUSH
26145: CALL 54396 0 1
26149: IFFALSE 26163
// begin e := k ;
26151: LD_ADDR_VAR 0 7
26155: PUSH
26156: LD_VAR 0 8
26160: ST_TO_ADDR
// break ;
26161: GO 26165
// end ;
26163: GO 26137
26165: POP
26166: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26167: LD_VAR 0 7
26171: PUSH
26172: LD_VAR 0 5
26176: PPUSH
26177: LD_VAR 0 7
26181: PPUSH
26182: CALL 88149 0 2
26186: NOT
26187: AND
26188: IFFALSE 26247
// begin if IsInUnit ( p ) then
26190: LD_VAR 0 5
26194: PPUSH
26195: CALL_OW 310
26199: IFFALSE 26210
// ComExitBuilding ( p ) ;
26201: LD_VAR 0 5
26205: PPUSH
26206: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26210: LD_VAR 0 5
26214: PPUSH
26215: LD_VAR 0 7
26219: PPUSH
26220: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26224: LD_VAR 0 5
26228: PPUSH
26229: LD_VAR 0 3
26233: PPUSH
26234: CALL_OW 183
// AddComExitBuilding ( p ) ;
26238: LD_VAR 0 5
26242: PPUSH
26243: CALL_OW 182
// end ; end ;
26247: GO 26095
26249: POP
26250: POP
// end ;
26251: GO 26061
26253: POP
26254: POP
// end ;
26255: GO 25816
26257: POP
26258: POP
// end ;
26259: LD_VAR 0 1
26263: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26264: LD_INT 0
26266: PPUSH
26267: PPUSH
26268: PPUSH
26269: PPUSH
26270: PPUSH
26271: PPUSH
26272: PPUSH
26273: PPUSH
26274: PPUSH
26275: PPUSH
26276: PPUSH
26277: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26278: LD_VAR 0 1
26282: NOT
26283: PUSH
26284: LD_EXP 78
26288: PUSH
26289: LD_VAR 0 1
26293: ARRAY
26294: NOT
26295: OR
26296: PUSH
26297: LD_EXP 78
26301: PUSH
26302: LD_VAR 0 1
26306: ARRAY
26307: PPUSH
26308: LD_INT 2
26310: PUSH
26311: LD_INT 30
26313: PUSH
26314: LD_INT 0
26316: PUSH
26317: EMPTY
26318: LIST
26319: LIST
26320: PUSH
26321: LD_INT 30
26323: PUSH
26324: LD_INT 1
26326: PUSH
26327: EMPTY
26328: LIST
26329: LIST
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: PPUSH
26336: CALL_OW 72
26340: NOT
26341: OR
26342: IFFALSE 26346
// exit ;
26344: GO 29849
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26346: LD_ADDR_VAR 0 4
26350: PUSH
26351: LD_EXP 78
26355: PUSH
26356: LD_VAR 0 1
26360: ARRAY
26361: PPUSH
26362: LD_INT 2
26364: PUSH
26365: LD_INT 25
26367: PUSH
26368: LD_INT 1
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: PUSH
26375: LD_INT 25
26377: PUSH
26378: LD_INT 2
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: LD_INT 25
26387: PUSH
26388: LD_INT 3
26390: PUSH
26391: EMPTY
26392: LIST
26393: LIST
26394: PUSH
26395: LD_INT 25
26397: PUSH
26398: LD_INT 4
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 25
26407: PUSH
26408: LD_INT 5
26410: PUSH
26411: EMPTY
26412: LIST
26413: LIST
26414: PUSH
26415: LD_INT 25
26417: PUSH
26418: LD_INT 8
26420: PUSH
26421: EMPTY
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 25
26427: PUSH
26428: LD_INT 9
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: PPUSH
26445: CALL_OW 72
26449: ST_TO_ADDR
// if not tmp then
26450: LD_VAR 0 4
26454: NOT
26455: IFFALSE 26459
// exit ;
26457: GO 29849
// for i in tmp do
26459: LD_ADDR_VAR 0 3
26463: PUSH
26464: LD_VAR 0 4
26468: PUSH
26469: FOR_IN
26470: IFFALSE 26501
// if GetTag ( i ) then
26472: LD_VAR 0 3
26476: PPUSH
26477: CALL_OW 110
26481: IFFALSE 26499
// tmp := tmp diff i ;
26483: LD_ADDR_VAR 0 4
26487: PUSH
26488: LD_VAR 0 4
26492: PUSH
26493: LD_VAR 0 3
26497: DIFF
26498: ST_TO_ADDR
26499: GO 26469
26501: POP
26502: POP
// if not tmp then
26503: LD_VAR 0 4
26507: NOT
26508: IFFALSE 26512
// exit ;
26510: GO 29849
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26512: LD_ADDR_VAR 0 5
26516: PUSH
26517: LD_EXP 78
26521: PUSH
26522: LD_VAR 0 1
26526: ARRAY
26527: PPUSH
26528: LD_INT 2
26530: PUSH
26531: LD_INT 25
26533: PUSH
26534: LD_INT 1
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: LD_INT 25
26543: PUSH
26544: LD_INT 5
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PUSH
26551: LD_INT 25
26553: PUSH
26554: LD_INT 8
26556: PUSH
26557: EMPTY
26558: LIST
26559: LIST
26560: PUSH
26561: LD_INT 25
26563: PUSH
26564: LD_INT 9
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: LIST
26575: LIST
26576: LIST
26577: PPUSH
26578: CALL_OW 72
26582: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26583: LD_ADDR_VAR 0 6
26587: PUSH
26588: LD_EXP 78
26592: PUSH
26593: LD_VAR 0 1
26597: ARRAY
26598: PPUSH
26599: LD_INT 25
26601: PUSH
26602: LD_INT 2
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PPUSH
26609: CALL_OW 72
26613: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26614: LD_ADDR_VAR 0 7
26618: PUSH
26619: LD_EXP 78
26623: PUSH
26624: LD_VAR 0 1
26628: ARRAY
26629: PPUSH
26630: LD_INT 25
26632: PUSH
26633: LD_INT 3
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: PPUSH
26640: CALL_OW 72
26644: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26645: LD_ADDR_VAR 0 8
26649: PUSH
26650: LD_EXP 78
26654: PUSH
26655: LD_VAR 0 1
26659: ARRAY
26660: PPUSH
26661: LD_INT 25
26663: PUSH
26664: LD_INT 4
26666: PUSH
26667: EMPTY
26668: LIST
26669: LIST
26670: PUSH
26671: LD_INT 24
26673: PUSH
26674: LD_INT 251
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PPUSH
26685: CALL_OW 72
26689: ST_TO_ADDR
// if mc_is_defending [ base ] then
26690: LD_EXP 121
26694: PUSH
26695: LD_VAR 0 1
26699: ARRAY
26700: IFFALSE 27161
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26702: LD_ADDR_EXP 120
26706: PUSH
26707: LD_EXP 120
26711: PPUSH
26712: LD_VAR 0 1
26716: PPUSH
26717: LD_INT 4
26719: PPUSH
26720: CALL_OW 1
26724: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26725: LD_ADDR_VAR 0 12
26729: PUSH
26730: LD_EXP 78
26734: PUSH
26735: LD_VAR 0 1
26739: ARRAY
26740: PPUSH
26741: LD_INT 2
26743: PUSH
26744: LD_INT 30
26746: PUSH
26747: LD_INT 4
26749: PUSH
26750: EMPTY
26751: LIST
26752: LIST
26753: PUSH
26754: LD_INT 30
26756: PUSH
26757: LD_INT 5
26759: PUSH
26760: EMPTY
26761: LIST
26762: LIST
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: LIST
26768: PPUSH
26769: CALL_OW 72
26773: ST_TO_ADDR
// if not b then
26774: LD_VAR 0 12
26778: NOT
26779: IFFALSE 26783
// exit ;
26781: GO 29849
// p := [ ] ;
26783: LD_ADDR_VAR 0 11
26787: PUSH
26788: EMPTY
26789: ST_TO_ADDR
// if sci >= 2 then
26790: LD_VAR 0 8
26794: PUSH
26795: LD_INT 2
26797: GREATEREQUAL
26798: IFFALSE 26829
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26800: LD_ADDR_VAR 0 8
26804: PUSH
26805: LD_VAR 0 8
26809: PUSH
26810: LD_INT 1
26812: ARRAY
26813: PUSH
26814: LD_VAR 0 8
26818: PUSH
26819: LD_INT 2
26821: ARRAY
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: ST_TO_ADDR
26827: GO 26890
// if sci = 1 then
26829: LD_VAR 0 8
26833: PUSH
26834: LD_INT 1
26836: EQUAL
26837: IFFALSE 26858
// sci := [ sci [ 1 ] ] else
26839: LD_ADDR_VAR 0 8
26843: PUSH
26844: LD_VAR 0 8
26848: PUSH
26849: LD_INT 1
26851: ARRAY
26852: PUSH
26853: EMPTY
26854: LIST
26855: ST_TO_ADDR
26856: GO 26890
// if sci = 0 then
26858: LD_VAR 0 8
26862: PUSH
26863: LD_INT 0
26865: EQUAL
26866: IFFALSE 26890
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26868: LD_ADDR_VAR 0 11
26872: PUSH
26873: LD_VAR 0 4
26877: PPUSH
26878: LD_INT 4
26880: PPUSH
26881: CALL 88021 0 2
26885: PUSH
26886: LD_INT 1
26888: ARRAY
26889: ST_TO_ADDR
// if eng > 4 then
26890: LD_VAR 0 6
26894: PUSH
26895: LD_INT 4
26897: GREATER
26898: IFFALSE 26944
// for i = eng downto 4 do
26900: LD_ADDR_VAR 0 3
26904: PUSH
26905: DOUBLE
26906: LD_VAR 0 6
26910: INC
26911: ST_TO_ADDR
26912: LD_INT 4
26914: PUSH
26915: FOR_DOWNTO
26916: IFFALSE 26942
// eng := eng diff eng [ i ] ;
26918: LD_ADDR_VAR 0 6
26922: PUSH
26923: LD_VAR 0 6
26927: PUSH
26928: LD_VAR 0 6
26932: PUSH
26933: LD_VAR 0 3
26937: ARRAY
26938: DIFF
26939: ST_TO_ADDR
26940: GO 26915
26942: POP
26943: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26944: LD_ADDR_VAR 0 4
26948: PUSH
26949: LD_VAR 0 4
26953: PUSH
26954: LD_VAR 0 5
26958: PUSH
26959: LD_VAR 0 6
26963: UNION
26964: PUSH
26965: LD_VAR 0 7
26969: UNION
26970: PUSH
26971: LD_VAR 0 8
26975: UNION
26976: DIFF
26977: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26978: LD_ADDR_VAR 0 13
26982: PUSH
26983: LD_EXP 78
26987: PUSH
26988: LD_VAR 0 1
26992: ARRAY
26993: PPUSH
26994: LD_INT 2
26996: PUSH
26997: LD_INT 30
26999: PUSH
27000: LD_INT 32
27002: PUSH
27003: EMPTY
27004: LIST
27005: LIST
27006: PUSH
27007: LD_INT 30
27009: PUSH
27010: LD_INT 31
27012: PUSH
27013: EMPTY
27014: LIST
27015: LIST
27016: PUSH
27017: EMPTY
27018: LIST
27019: LIST
27020: LIST
27021: PPUSH
27022: CALL_OW 72
27026: PUSH
27027: LD_EXP 78
27031: PUSH
27032: LD_VAR 0 1
27036: ARRAY
27037: PPUSH
27038: LD_INT 2
27040: PUSH
27041: LD_INT 30
27043: PUSH
27044: LD_INT 4
27046: PUSH
27047: EMPTY
27048: LIST
27049: LIST
27050: PUSH
27051: LD_INT 30
27053: PUSH
27054: LD_INT 5
27056: PUSH
27057: EMPTY
27058: LIST
27059: LIST
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: LIST
27065: PPUSH
27066: CALL_OW 72
27070: PUSH
27071: LD_INT 6
27073: MUL
27074: PLUS
27075: ST_TO_ADDR
// if bcount < tmp then
27076: LD_VAR 0 13
27080: PUSH
27081: LD_VAR 0 4
27085: LESS
27086: IFFALSE 27132
// for i = tmp downto bcount do
27088: LD_ADDR_VAR 0 3
27092: PUSH
27093: DOUBLE
27094: LD_VAR 0 4
27098: INC
27099: ST_TO_ADDR
27100: LD_VAR 0 13
27104: PUSH
27105: FOR_DOWNTO
27106: IFFALSE 27130
// tmp := Delete ( tmp , tmp ) ;
27108: LD_ADDR_VAR 0 4
27112: PUSH
27113: LD_VAR 0 4
27117: PPUSH
27118: LD_VAR 0 4
27122: PPUSH
27123: CALL_OW 3
27127: ST_TO_ADDR
27128: GO 27105
27130: POP
27131: POP
// result := [ tmp , 0 , 0 , p ] ;
27132: LD_ADDR_VAR 0 2
27136: PUSH
27137: LD_VAR 0 4
27141: PUSH
27142: LD_INT 0
27144: PUSH
27145: LD_INT 0
27147: PUSH
27148: LD_VAR 0 11
27152: PUSH
27153: EMPTY
27154: LIST
27155: LIST
27156: LIST
27157: LIST
27158: ST_TO_ADDR
// exit ;
27159: GO 29849
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27161: LD_EXP 78
27165: PUSH
27166: LD_VAR 0 1
27170: ARRAY
27171: PPUSH
27172: LD_INT 2
27174: PUSH
27175: LD_INT 30
27177: PUSH
27178: LD_INT 6
27180: PUSH
27181: EMPTY
27182: LIST
27183: LIST
27184: PUSH
27185: LD_INT 30
27187: PUSH
27188: LD_INT 7
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 30
27197: PUSH
27198: LD_INT 8
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: EMPTY
27206: LIST
27207: LIST
27208: LIST
27209: LIST
27210: PPUSH
27211: CALL_OW 72
27215: NOT
27216: PUSH
27217: LD_EXP 78
27221: PUSH
27222: LD_VAR 0 1
27226: ARRAY
27227: PPUSH
27228: LD_INT 30
27230: PUSH
27231: LD_INT 3
27233: PUSH
27234: EMPTY
27235: LIST
27236: LIST
27237: PPUSH
27238: CALL_OW 72
27242: NOT
27243: AND
27244: IFFALSE 27316
// begin if eng = tmp then
27246: LD_VAR 0 6
27250: PUSH
27251: LD_VAR 0 4
27255: EQUAL
27256: IFFALSE 27260
// exit ;
27258: GO 29849
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27260: LD_ADDR_EXP 120
27264: PUSH
27265: LD_EXP 120
27269: PPUSH
27270: LD_VAR 0 1
27274: PPUSH
27275: LD_INT 1
27277: PPUSH
27278: CALL_OW 1
27282: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27283: LD_ADDR_VAR 0 2
27287: PUSH
27288: LD_INT 0
27290: PUSH
27291: LD_VAR 0 4
27295: PUSH
27296: LD_VAR 0 6
27300: DIFF
27301: PUSH
27302: LD_INT 0
27304: PUSH
27305: LD_INT 0
27307: PUSH
27308: EMPTY
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: ST_TO_ADDR
// exit ;
27314: GO 29849
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27316: LD_EXP 105
27320: PUSH
27321: LD_EXP 104
27325: PUSH
27326: LD_VAR 0 1
27330: ARRAY
27331: ARRAY
27332: PUSH
27333: LD_EXP 78
27337: PUSH
27338: LD_VAR 0 1
27342: ARRAY
27343: PPUSH
27344: LD_INT 2
27346: PUSH
27347: LD_INT 30
27349: PUSH
27350: LD_INT 6
27352: PUSH
27353: EMPTY
27354: LIST
27355: LIST
27356: PUSH
27357: LD_INT 30
27359: PUSH
27360: LD_INT 7
27362: PUSH
27363: EMPTY
27364: LIST
27365: LIST
27366: PUSH
27367: LD_INT 30
27369: PUSH
27370: LD_INT 8
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: LIST
27381: LIST
27382: PPUSH
27383: CALL_OW 72
27387: AND
27388: PUSH
27389: LD_EXP 78
27393: PUSH
27394: LD_VAR 0 1
27398: ARRAY
27399: PPUSH
27400: LD_INT 30
27402: PUSH
27403: LD_INT 3
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PPUSH
27410: CALL_OW 72
27414: NOT
27415: AND
27416: IFFALSE 27630
// begin if sci >= 6 then
27418: LD_VAR 0 8
27422: PUSH
27423: LD_INT 6
27425: GREATEREQUAL
27426: IFFALSE 27430
// exit ;
27428: GO 29849
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27430: LD_ADDR_EXP 120
27434: PUSH
27435: LD_EXP 120
27439: PPUSH
27440: LD_VAR 0 1
27444: PPUSH
27445: LD_INT 2
27447: PPUSH
27448: CALL_OW 1
27452: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27453: LD_ADDR_VAR 0 9
27457: PUSH
27458: LD_VAR 0 4
27462: PUSH
27463: LD_VAR 0 8
27467: DIFF
27468: PPUSH
27469: LD_INT 4
27471: PPUSH
27472: CALL 88021 0 2
27476: ST_TO_ADDR
// p := [ ] ;
27477: LD_ADDR_VAR 0 11
27481: PUSH
27482: EMPTY
27483: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27484: LD_VAR 0 8
27488: PUSH
27489: LD_INT 6
27491: LESS
27492: PUSH
27493: LD_VAR 0 9
27497: PUSH
27498: LD_INT 6
27500: GREATER
27501: AND
27502: IFFALSE 27583
// begin for i = 1 to 6 - sci do
27504: LD_ADDR_VAR 0 3
27508: PUSH
27509: DOUBLE
27510: LD_INT 1
27512: DEC
27513: ST_TO_ADDR
27514: LD_INT 6
27516: PUSH
27517: LD_VAR 0 8
27521: MINUS
27522: PUSH
27523: FOR_TO
27524: IFFALSE 27579
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27526: LD_ADDR_VAR 0 11
27530: PUSH
27531: LD_VAR 0 11
27535: PPUSH
27536: LD_VAR 0 11
27540: PUSH
27541: LD_INT 1
27543: PLUS
27544: PPUSH
27545: LD_VAR 0 9
27549: PUSH
27550: LD_INT 1
27552: ARRAY
27553: PPUSH
27554: CALL_OW 2
27558: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27559: LD_ADDR_VAR 0 9
27563: PUSH
27564: LD_VAR 0 9
27568: PPUSH
27569: LD_INT 1
27571: PPUSH
27572: CALL_OW 3
27576: ST_TO_ADDR
// end ;
27577: GO 27523
27579: POP
27580: POP
// end else
27581: GO 27603
// if sort then
27583: LD_VAR 0 9
27587: IFFALSE 27603
// p := sort [ 1 ] ;
27589: LD_ADDR_VAR 0 11
27593: PUSH
27594: LD_VAR 0 9
27598: PUSH
27599: LD_INT 1
27601: ARRAY
27602: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27603: LD_ADDR_VAR 0 2
27607: PUSH
27608: LD_INT 0
27610: PUSH
27611: LD_INT 0
27613: PUSH
27614: LD_INT 0
27616: PUSH
27617: LD_VAR 0 11
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: LIST
27626: LIST
27627: ST_TO_ADDR
// exit ;
27628: GO 29849
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27630: LD_EXP 105
27634: PUSH
27635: LD_EXP 104
27639: PUSH
27640: LD_VAR 0 1
27644: ARRAY
27645: ARRAY
27646: PUSH
27647: LD_EXP 78
27651: PUSH
27652: LD_VAR 0 1
27656: ARRAY
27657: PPUSH
27658: LD_INT 2
27660: PUSH
27661: LD_INT 30
27663: PUSH
27664: LD_INT 6
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: PUSH
27671: LD_INT 30
27673: PUSH
27674: LD_INT 7
27676: PUSH
27677: EMPTY
27678: LIST
27679: LIST
27680: PUSH
27681: LD_INT 30
27683: PUSH
27684: LD_INT 8
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: LIST
27695: LIST
27696: PPUSH
27697: CALL_OW 72
27701: AND
27702: PUSH
27703: LD_EXP 78
27707: PUSH
27708: LD_VAR 0 1
27712: ARRAY
27713: PPUSH
27714: LD_INT 30
27716: PUSH
27717: LD_INT 3
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PPUSH
27724: CALL_OW 72
27728: AND
27729: IFFALSE 28463
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27731: LD_ADDR_EXP 120
27735: PUSH
27736: LD_EXP 120
27740: PPUSH
27741: LD_VAR 0 1
27745: PPUSH
27746: LD_INT 3
27748: PPUSH
27749: CALL_OW 1
27753: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27754: LD_ADDR_VAR 0 2
27758: PUSH
27759: LD_INT 0
27761: PUSH
27762: LD_INT 0
27764: PUSH
27765: LD_INT 0
27767: PUSH
27768: LD_INT 0
27770: PUSH
27771: EMPTY
27772: LIST
27773: LIST
27774: LIST
27775: LIST
27776: ST_TO_ADDR
// if not eng then
27777: LD_VAR 0 6
27781: NOT
27782: IFFALSE 27845
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27784: LD_ADDR_VAR 0 11
27788: PUSH
27789: LD_VAR 0 4
27793: PPUSH
27794: LD_INT 2
27796: PPUSH
27797: CALL 88021 0 2
27801: PUSH
27802: LD_INT 1
27804: ARRAY
27805: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27806: LD_ADDR_VAR 0 2
27810: PUSH
27811: LD_VAR 0 2
27815: PPUSH
27816: LD_INT 2
27818: PPUSH
27819: LD_VAR 0 11
27823: PPUSH
27824: CALL_OW 1
27828: ST_TO_ADDR
// tmp := tmp diff p ;
27829: LD_ADDR_VAR 0 4
27833: PUSH
27834: LD_VAR 0 4
27838: PUSH
27839: LD_VAR 0 11
27843: DIFF
27844: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27845: LD_VAR 0 4
27849: PUSH
27850: LD_VAR 0 8
27854: PUSH
27855: LD_INT 6
27857: LESS
27858: AND
27859: IFFALSE 28047
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27861: LD_ADDR_VAR 0 9
27865: PUSH
27866: LD_VAR 0 4
27870: PUSH
27871: LD_VAR 0 8
27875: PUSH
27876: LD_VAR 0 7
27880: UNION
27881: DIFF
27882: PPUSH
27883: LD_INT 4
27885: PPUSH
27886: CALL 88021 0 2
27890: ST_TO_ADDR
// p := [ ] ;
27891: LD_ADDR_VAR 0 11
27895: PUSH
27896: EMPTY
27897: ST_TO_ADDR
// if sort then
27898: LD_VAR 0 9
27902: IFFALSE 28018
// for i = 1 to 6 - sci do
27904: LD_ADDR_VAR 0 3
27908: PUSH
27909: DOUBLE
27910: LD_INT 1
27912: DEC
27913: ST_TO_ADDR
27914: LD_INT 6
27916: PUSH
27917: LD_VAR 0 8
27921: MINUS
27922: PUSH
27923: FOR_TO
27924: IFFALSE 28016
// begin if i = sort then
27926: LD_VAR 0 3
27930: PUSH
27931: LD_VAR 0 9
27935: EQUAL
27936: IFFALSE 27940
// break ;
27938: GO 28016
// if GetClass ( i ) = 4 then
27940: LD_VAR 0 3
27944: PPUSH
27945: CALL_OW 257
27949: PUSH
27950: LD_INT 4
27952: EQUAL
27953: IFFALSE 27957
// continue ;
27955: GO 27923
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27957: LD_ADDR_VAR 0 11
27961: PUSH
27962: LD_VAR 0 11
27966: PPUSH
27967: LD_VAR 0 11
27971: PUSH
27972: LD_INT 1
27974: PLUS
27975: PPUSH
27976: LD_VAR 0 9
27980: PUSH
27981: LD_VAR 0 3
27985: ARRAY
27986: PPUSH
27987: CALL_OW 2
27991: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27992: LD_ADDR_VAR 0 4
27996: PUSH
27997: LD_VAR 0 4
28001: PUSH
28002: LD_VAR 0 9
28006: PUSH
28007: LD_VAR 0 3
28011: ARRAY
28012: DIFF
28013: ST_TO_ADDR
// end ;
28014: GO 27923
28016: POP
28017: POP
// if p then
28018: LD_VAR 0 11
28022: IFFALSE 28047
// result := Replace ( result , 4 , p ) ;
28024: LD_ADDR_VAR 0 2
28028: PUSH
28029: LD_VAR 0 2
28033: PPUSH
28034: LD_INT 4
28036: PPUSH
28037: LD_VAR 0 11
28041: PPUSH
28042: CALL_OW 1
28046: ST_TO_ADDR
// end ; if tmp and mech < 6 then
28047: LD_VAR 0 4
28051: PUSH
28052: LD_VAR 0 7
28056: PUSH
28057: LD_INT 6
28059: LESS
28060: AND
28061: IFFALSE 28249
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28063: LD_ADDR_VAR 0 9
28067: PUSH
28068: LD_VAR 0 4
28072: PUSH
28073: LD_VAR 0 8
28077: PUSH
28078: LD_VAR 0 7
28082: UNION
28083: DIFF
28084: PPUSH
28085: LD_INT 3
28087: PPUSH
28088: CALL 88021 0 2
28092: ST_TO_ADDR
// p := [ ] ;
28093: LD_ADDR_VAR 0 11
28097: PUSH
28098: EMPTY
28099: ST_TO_ADDR
// if sort then
28100: LD_VAR 0 9
28104: IFFALSE 28220
// for i = 1 to 6 - mech do
28106: LD_ADDR_VAR 0 3
28110: PUSH
28111: DOUBLE
28112: LD_INT 1
28114: DEC
28115: ST_TO_ADDR
28116: LD_INT 6
28118: PUSH
28119: LD_VAR 0 7
28123: MINUS
28124: PUSH
28125: FOR_TO
28126: IFFALSE 28218
// begin if i = sort then
28128: LD_VAR 0 3
28132: PUSH
28133: LD_VAR 0 9
28137: EQUAL
28138: IFFALSE 28142
// break ;
28140: GO 28218
// if GetClass ( i ) = 3 then
28142: LD_VAR 0 3
28146: PPUSH
28147: CALL_OW 257
28151: PUSH
28152: LD_INT 3
28154: EQUAL
28155: IFFALSE 28159
// continue ;
28157: GO 28125
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28159: LD_ADDR_VAR 0 11
28163: PUSH
28164: LD_VAR 0 11
28168: PPUSH
28169: LD_VAR 0 11
28173: PUSH
28174: LD_INT 1
28176: PLUS
28177: PPUSH
28178: LD_VAR 0 9
28182: PUSH
28183: LD_VAR 0 3
28187: ARRAY
28188: PPUSH
28189: CALL_OW 2
28193: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28194: LD_ADDR_VAR 0 4
28198: PUSH
28199: LD_VAR 0 4
28203: PUSH
28204: LD_VAR 0 9
28208: PUSH
28209: LD_VAR 0 3
28213: ARRAY
28214: DIFF
28215: ST_TO_ADDR
// end ;
28216: GO 28125
28218: POP
28219: POP
// if p then
28220: LD_VAR 0 11
28224: IFFALSE 28249
// result := Replace ( result , 3 , p ) ;
28226: LD_ADDR_VAR 0 2
28230: PUSH
28231: LD_VAR 0 2
28235: PPUSH
28236: LD_INT 3
28238: PPUSH
28239: LD_VAR 0 11
28243: PPUSH
28244: CALL_OW 1
28248: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28249: LD_VAR 0 4
28253: PUSH
28254: LD_INT 6
28256: GREATER
28257: PUSH
28258: LD_VAR 0 6
28262: PUSH
28263: LD_INT 6
28265: LESS
28266: AND
28267: IFFALSE 28461
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28269: LD_ADDR_VAR 0 9
28273: PUSH
28274: LD_VAR 0 4
28278: PUSH
28279: LD_VAR 0 8
28283: PUSH
28284: LD_VAR 0 7
28288: UNION
28289: PUSH
28290: LD_VAR 0 6
28294: UNION
28295: DIFF
28296: PPUSH
28297: LD_INT 2
28299: PPUSH
28300: CALL 88021 0 2
28304: ST_TO_ADDR
// p := [ ] ;
28305: LD_ADDR_VAR 0 11
28309: PUSH
28310: EMPTY
28311: ST_TO_ADDR
// if sort then
28312: LD_VAR 0 9
28316: IFFALSE 28432
// for i = 1 to 6 - eng do
28318: LD_ADDR_VAR 0 3
28322: PUSH
28323: DOUBLE
28324: LD_INT 1
28326: DEC
28327: ST_TO_ADDR
28328: LD_INT 6
28330: PUSH
28331: LD_VAR 0 6
28335: MINUS
28336: PUSH
28337: FOR_TO
28338: IFFALSE 28430
// begin if i = sort then
28340: LD_VAR 0 3
28344: PUSH
28345: LD_VAR 0 9
28349: EQUAL
28350: IFFALSE 28354
// break ;
28352: GO 28430
// if GetClass ( i ) = 2 then
28354: LD_VAR 0 3
28358: PPUSH
28359: CALL_OW 257
28363: PUSH
28364: LD_INT 2
28366: EQUAL
28367: IFFALSE 28371
// continue ;
28369: GO 28337
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28371: LD_ADDR_VAR 0 11
28375: PUSH
28376: LD_VAR 0 11
28380: PPUSH
28381: LD_VAR 0 11
28385: PUSH
28386: LD_INT 1
28388: PLUS
28389: PPUSH
28390: LD_VAR 0 9
28394: PUSH
28395: LD_VAR 0 3
28399: ARRAY
28400: PPUSH
28401: CALL_OW 2
28405: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28406: LD_ADDR_VAR 0 4
28410: PUSH
28411: LD_VAR 0 4
28415: PUSH
28416: LD_VAR 0 9
28420: PUSH
28421: LD_VAR 0 3
28425: ARRAY
28426: DIFF
28427: ST_TO_ADDR
// end ;
28428: GO 28337
28430: POP
28431: POP
// if p then
28432: LD_VAR 0 11
28436: IFFALSE 28461
// result := Replace ( result , 2 , p ) ;
28438: LD_ADDR_VAR 0 2
28442: PUSH
28443: LD_VAR 0 2
28447: PPUSH
28448: LD_INT 2
28450: PPUSH
28451: LD_VAR 0 11
28455: PPUSH
28456: CALL_OW 1
28460: ST_TO_ADDR
// end ; exit ;
28461: GO 29849
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28463: LD_EXP 105
28467: PUSH
28468: LD_EXP 104
28472: PUSH
28473: LD_VAR 0 1
28477: ARRAY
28478: ARRAY
28479: NOT
28480: PUSH
28481: LD_EXP 78
28485: PUSH
28486: LD_VAR 0 1
28490: ARRAY
28491: PPUSH
28492: LD_INT 30
28494: PUSH
28495: LD_INT 3
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PPUSH
28502: CALL_OW 72
28506: AND
28507: PUSH
28508: LD_EXP 83
28512: PUSH
28513: LD_VAR 0 1
28517: ARRAY
28518: AND
28519: IFFALSE 29127
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28521: LD_ADDR_EXP 120
28525: PUSH
28526: LD_EXP 120
28530: PPUSH
28531: LD_VAR 0 1
28535: PPUSH
28536: LD_INT 5
28538: PPUSH
28539: CALL_OW 1
28543: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28544: LD_ADDR_VAR 0 2
28548: PUSH
28549: LD_INT 0
28551: PUSH
28552: LD_INT 0
28554: PUSH
28555: LD_INT 0
28557: PUSH
28558: LD_INT 0
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: LIST
28565: LIST
28566: ST_TO_ADDR
// if sci > 1 then
28567: LD_VAR 0 8
28571: PUSH
28572: LD_INT 1
28574: GREATER
28575: IFFALSE 28603
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28577: LD_ADDR_VAR 0 4
28581: PUSH
28582: LD_VAR 0 4
28586: PUSH
28587: LD_VAR 0 8
28591: PUSH
28592: LD_VAR 0 8
28596: PUSH
28597: LD_INT 1
28599: ARRAY
28600: DIFF
28601: DIFF
28602: ST_TO_ADDR
// if tmp and not sci then
28603: LD_VAR 0 4
28607: PUSH
28608: LD_VAR 0 8
28612: NOT
28613: AND
28614: IFFALSE 28683
// begin sort := SortBySkill ( tmp , 4 ) ;
28616: LD_ADDR_VAR 0 9
28620: PUSH
28621: LD_VAR 0 4
28625: PPUSH
28626: LD_INT 4
28628: PPUSH
28629: CALL 88021 0 2
28633: ST_TO_ADDR
// if sort then
28634: LD_VAR 0 9
28638: IFFALSE 28654
// p := sort [ 1 ] ;
28640: LD_ADDR_VAR 0 11
28644: PUSH
28645: LD_VAR 0 9
28649: PUSH
28650: LD_INT 1
28652: ARRAY
28653: ST_TO_ADDR
// if p then
28654: LD_VAR 0 11
28658: IFFALSE 28683
// result := Replace ( result , 4 , p ) ;
28660: LD_ADDR_VAR 0 2
28664: PUSH
28665: LD_VAR 0 2
28669: PPUSH
28670: LD_INT 4
28672: PPUSH
28673: LD_VAR 0 11
28677: PPUSH
28678: CALL_OW 1
28682: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28683: LD_ADDR_VAR 0 4
28687: PUSH
28688: LD_VAR 0 4
28692: PUSH
28693: LD_VAR 0 7
28697: DIFF
28698: ST_TO_ADDR
// if tmp and mech < 6 then
28699: LD_VAR 0 4
28703: PUSH
28704: LD_VAR 0 7
28708: PUSH
28709: LD_INT 6
28711: LESS
28712: AND
28713: IFFALSE 28901
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28715: LD_ADDR_VAR 0 9
28719: PUSH
28720: LD_VAR 0 4
28724: PUSH
28725: LD_VAR 0 8
28729: PUSH
28730: LD_VAR 0 7
28734: UNION
28735: DIFF
28736: PPUSH
28737: LD_INT 3
28739: PPUSH
28740: CALL 88021 0 2
28744: ST_TO_ADDR
// p := [ ] ;
28745: LD_ADDR_VAR 0 11
28749: PUSH
28750: EMPTY
28751: ST_TO_ADDR
// if sort then
28752: LD_VAR 0 9
28756: IFFALSE 28872
// for i = 1 to 6 - mech do
28758: LD_ADDR_VAR 0 3
28762: PUSH
28763: DOUBLE
28764: LD_INT 1
28766: DEC
28767: ST_TO_ADDR
28768: LD_INT 6
28770: PUSH
28771: LD_VAR 0 7
28775: MINUS
28776: PUSH
28777: FOR_TO
28778: IFFALSE 28870
// begin if i = sort then
28780: LD_VAR 0 3
28784: PUSH
28785: LD_VAR 0 9
28789: EQUAL
28790: IFFALSE 28794
// break ;
28792: GO 28870
// if GetClass ( i ) = 3 then
28794: LD_VAR 0 3
28798: PPUSH
28799: CALL_OW 257
28803: PUSH
28804: LD_INT 3
28806: EQUAL
28807: IFFALSE 28811
// continue ;
28809: GO 28777
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28811: LD_ADDR_VAR 0 11
28815: PUSH
28816: LD_VAR 0 11
28820: PPUSH
28821: LD_VAR 0 11
28825: PUSH
28826: LD_INT 1
28828: PLUS
28829: PPUSH
28830: LD_VAR 0 9
28834: PUSH
28835: LD_VAR 0 3
28839: ARRAY
28840: PPUSH
28841: CALL_OW 2
28845: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28846: LD_ADDR_VAR 0 4
28850: PUSH
28851: LD_VAR 0 4
28855: PUSH
28856: LD_VAR 0 9
28860: PUSH
28861: LD_VAR 0 3
28865: ARRAY
28866: DIFF
28867: ST_TO_ADDR
// end ;
28868: GO 28777
28870: POP
28871: POP
// if p then
28872: LD_VAR 0 11
28876: IFFALSE 28901
// result := Replace ( result , 3 , p ) ;
28878: LD_ADDR_VAR 0 2
28882: PUSH
28883: LD_VAR 0 2
28887: PPUSH
28888: LD_INT 3
28890: PPUSH
28891: LD_VAR 0 11
28895: PPUSH
28896: CALL_OW 1
28900: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28901: LD_ADDR_VAR 0 4
28905: PUSH
28906: LD_VAR 0 4
28910: PUSH
28911: LD_VAR 0 6
28915: DIFF
28916: ST_TO_ADDR
// if tmp and eng < 6 then
28917: LD_VAR 0 4
28921: PUSH
28922: LD_VAR 0 6
28926: PUSH
28927: LD_INT 6
28929: LESS
28930: AND
28931: IFFALSE 29125
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28933: LD_ADDR_VAR 0 9
28937: PUSH
28938: LD_VAR 0 4
28942: PUSH
28943: LD_VAR 0 8
28947: PUSH
28948: LD_VAR 0 7
28952: UNION
28953: PUSH
28954: LD_VAR 0 6
28958: UNION
28959: DIFF
28960: PPUSH
28961: LD_INT 2
28963: PPUSH
28964: CALL 88021 0 2
28968: ST_TO_ADDR
// p := [ ] ;
28969: LD_ADDR_VAR 0 11
28973: PUSH
28974: EMPTY
28975: ST_TO_ADDR
// if sort then
28976: LD_VAR 0 9
28980: IFFALSE 29096
// for i = 1 to 6 - eng do
28982: LD_ADDR_VAR 0 3
28986: PUSH
28987: DOUBLE
28988: LD_INT 1
28990: DEC
28991: ST_TO_ADDR
28992: LD_INT 6
28994: PUSH
28995: LD_VAR 0 6
28999: MINUS
29000: PUSH
29001: FOR_TO
29002: IFFALSE 29094
// begin if i = sort then
29004: LD_VAR 0 3
29008: PUSH
29009: LD_VAR 0 9
29013: EQUAL
29014: IFFALSE 29018
// break ;
29016: GO 29094
// if GetClass ( i ) = 2 then
29018: LD_VAR 0 3
29022: PPUSH
29023: CALL_OW 257
29027: PUSH
29028: LD_INT 2
29030: EQUAL
29031: IFFALSE 29035
// continue ;
29033: GO 29001
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29035: LD_ADDR_VAR 0 11
29039: PUSH
29040: LD_VAR 0 11
29044: PPUSH
29045: LD_VAR 0 11
29049: PUSH
29050: LD_INT 1
29052: PLUS
29053: PPUSH
29054: LD_VAR 0 9
29058: PUSH
29059: LD_VAR 0 3
29063: ARRAY
29064: PPUSH
29065: CALL_OW 2
29069: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29070: LD_ADDR_VAR 0 4
29074: PUSH
29075: LD_VAR 0 4
29079: PUSH
29080: LD_VAR 0 9
29084: PUSH
29085: LD_VAR 0 3
29089: ARRAY
29090: DIFF
29091: ST_TO_ADDR
// end ;
29092: GO 29001
29094: POP
29095: POP
// if p then
29096: LD_VAR 0 11
29100: IFFALSE 29125
// result := Replace ( result , 2 , p ) ;
29102: LD_ADDR_VAR 0 2
29106: PUSH
29107: LD_VAR 0 2
29111: PPUSH
29112: LD_INT 2
29114: PPUSH
29115: LD_VAR 0 11
29119: PPUSH
29120: CALL_OW 1
29124: ST_TO_ADDR
// end ; exit ;
29125: GO 29849
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
29127: LD_EXP 105
29131: PUSH
29132: LD_EXP 104
29136: PUSH
29137: LD_VAR 0 1
29141: ARRAY
29142: ARRAY
29143: NOT
29144: PUSH
29145: LD_EXP 78
29149: PUSH
29150: LD_VAR 0 1
29154: ARRAY
29155: PPUSH
29156: LD_INT 30
29158: PUSH
29159: LD_INT 3
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PPUSH
29166: CALL_OW 72
29170: AND
29171: PUSH
29172: LD_EXP 83
29176: PUSH
29177: LD_VAR 0 1
29181: ARRAY
29182: NOT
29183: AND
29184: IFFALSE 29849
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29186: LD_ADDR_EXP 120
29190: PUSH
29191: LD_EXP 120
29195: PPUSH
29196: LD_VAR 0 1
29200: PPUSH
29201: LD_INT 6
29203: PPUSH
29204: CALL_OW 1
29208: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29209: LD_ADDR_VAR 0 2
29213: PUSH
29214: LD_INT 0
29216: PUSH
29217: LD_INT 0
29219: PUSH
29220: LD_INT 0
29222: PUSH
29223: LD_INT 0
29225: PUSH
29226: EMPTY
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: ST_TO_ADDR
// if sci >= 1 then
29232: LD_VAR 0 8
29236: PUSH
29237: LD_INT 1
29239: GREATEREQUAL
29240: IFFALSE 29262
// tmp := tmp diff sci [ 1 ] ;
29242: LD_ADDR_VAR 0 4
29246: PUSH
29247: LD_VAR 0 4
29251: PUSH
29252: LD_VAR 0 8
29256: PUSH
29257: LD_INT 1
29259: ARRAY
29260: DIFF
29261: ST_TO_ADDR
// if tmp and not sci then
29262: LD_VAR 0 4
29266: PUSH
29267: LD_VAR 0 8
29271: NOT
29272: AND
29273: IFFALSE 29342
// begin sort := SortBySkill ( tmp , 4 ) ;
29275: LD_ADDR_VAR 0 9
29279: PUSH
29280: LD_VAR 0 4
29284: PPUSH
29285: LD_INT 4
29287: PPUSH
29288: CALL 88021 0 2
29292: ST_TO_ADDR
// if sort then
29293: LD_VAR 0 9
29297: IFFALSE 29313
// p := sort [ 1 ] ;
29299: LD_ADDR_VAR 0 11
29303: PUSH
29304: LD_VAR 0 9
29308: PUSH
29309: LD_INT 1
29311: ARRAY
29312: ST_TO_ADDR
// if p then
29313: LD_VAR 0 11
29317: IFFALSE 29342
// result := Replace ( result , 4 , p ) ;
29319: LD_ADDR_VAR 0 2
29323: PUSH
29324: LD_VAR 0 2
29328: PPUSH
29329: LD_INT 4
29331: PPUSH
29332: LD_VAR 0 11
29336: PPUSH
29337: CALL_OW 1
29341: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29342: LD_ADDR_VAR 0 4
29346: PUSH
29347: LD_VAR 0 4
29351: PUSH
29352: LD_VAR 0 7
29356: DIFF
29357: ST_TO_ADDR
// if tmp and mech < 6 then
29358: LD_VAR 0 4
29362: PUSH
29363: LD_VAR 0 7
29367: PUSH
29368: LD_INT 6
29370: LESS
29371: AND
29372: IFFALSE 29554
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29374: LD_ADDR_VAR 0 9
29378: PUSH
29379: LD_VAR 0 4
29383: PUSH
29384: LD_VAR 0 7
29388: DIFF
29389: PPUSH
29390: LD_INT 3
29392: PPUSH
29393: CALL 88021 0 2
29397: ST_TO_ADDR
// p := [ ] ;
29398: LD_ADDR_VAR 0 11
29402: PUSH
29403: EMPTY
29404: ST_TO_ADDR
// if sort then
29405: LD_VAR 0 9
29409: IFFALSE 29525
// for i = 1 to 6 - mech do
29411: LD_ADDR_VAR 0 3
29415: PUSH
29416: DOUBLE
29417: LD_INT 1
29419: DEC
29420: ST_TO_ADDR
29421: LD_INT 6
29423: PUSH
29424: LD_VAR 0 7
29428: MINUS
29429: PUSH
29430: FOR_TO
29431: IFFALSE 29523
// begin if i = sort then
29433: LD_VAR 0 3
29437: PUSH
29438: LD_VAR 0 9
29442: EQUAL
29443: IFFALSE 29447
// break ;
29445: GO 29523
// if GetClass ( i ) = 3 then
29447: LD_VAR 0 3
29451: PPUSH
29452: CALL_OW 257
29456: PUSH
29457: LD_INT 3
29459: EQUAL
29460: IFFALSE 29464
// continue ;
29462: GO 29430
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29464: LD_ADDR_VAR 0 11
29468: PUSH
29469: LD_VAR 0 11
29473: PPUSH
29474: LD_VAR 0 11
29478: PUSH
29479: LD_INT 1
29481: PLUS
29482: PPUSH
29483: LD_VAR 0 9
29487: PUSH
29488: LD_VAR 0 3
29492: ARRAY
29493: PPUSH
29494: CALL_OW 2
29498: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29499: LD_ADDR_VAR 0 4
29503: PUSH
29504: LD_VAR 0 4
29508: PUSH
29509: LD_VAR 0 9
29513: PUSH
29514: LD_VAR 0 3
29518: ARRAY
29519: DIFF
29520: ST_TO_ADDR
// end ;
29521: GO 29430
29523: POP
29524: POP
// if p then
29525: LD_VAR 0 11
29529: IFFALSE 29554
// result := Replace ( result , 3 , p ) ;
29531: LD_ADDR_VAR 0 2
29535: PUSH
29536: LD_VAR 0 2
29540: PPUSH
29541: LD_INT 3
29543: PPUSH
29544: LD_VAR 0 11
29548: PPUSH
29549: CALL_OW 1
29553: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29554: LD_ADDR_VAR 0 4
29558: PUSH
29559: LD_VAR 0 4
29563: PUSH
29564: LD_VAR 0 6
29568: DIFF
29569: ST_TO_ADDR
// if tmp and eng < 4 then
29570: LD_VAR 0 4
29574: PUSH
29575: LD_VAR 0 6
29579: PUSH
29580: LD_INT 4
29582: LESS
29583: AND
29584: IFFALSE 29774
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29586: LD_ADDR_VAR 0 9
29590: PUSH
29591: LD_VAR 0 4
29595: PUSH
29596: LD_VAR 0 7
29600: PUSH
29601: LD_VAR 0 6
29605: UNION
29606: DIFF
29607: PPUSH
29608: LD_INT 2
29610: PPUSH
29611: CALL 88021 0 2
29615: ST_TO_ADDR
// p := [ ] ;
29616: LD_ADDR_VAR 0 11
29620: PUSH
29621: EMPTY
29622: ST_TO_ADDR
// if sort then
29623: LD_VAR 0 9
29627: IFFALSE 29743
// for i = 1 to 4 - eng do
29629: LD_ADDR_VAR 0 3
29633: PUSH
29634: DOUBLE
29635: LD_INT 1
29637: DEC
29638: ST_TO_ADDR
29639: LD_INT 4
29641: PUSH
29642: LD_VAR 0 6
29646: MINUS
29647: PUSH
29648: FOR_TO
29649: IFFALSE 29741
// begin if i = sort then
29651: LD_VAR 0 3
29655: PUSH
29656: LD_VAR 0 9
29660: EQUAL
29661: IFFALSE 29665
// break ;
29663: GO 29741
// if GetClass ( i ) = 2 then
29665: LD_VAR 0 3
29669: PPUSH
29670: CALL_OW 257
29674: PUSH
29675: LD_INT 2
29677: EQUAL
29678: IFFALSE 29682
// continue ;
29680: GO 29648
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29682: LD_ADDR_VAR 0 11
29686: PUSH
29687: LD_VAR 0 11
29691: PPUSH
29692: LD_VAR 0 11
29696: PUSH
29697: LD_INT 1
29699: PLUS
29700: PPUSH
29701: LD_VAR 0 9
29705: PUSH
29706: LD_VAR 0 3
29710: ARRAY
29711: PPUSH
29712: CALL_OW 2
29716: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29717: LD_ADDR_VAR 0 4
29721: PUSH
29722: LD_VAR 0 4
29726: PUSH
29727: LD_VAR 0 9
29731: PUSH
29732: LD_VAR 0 3
29736: ARRAY
29737: DIFF
29738: ST_TO_ADDR
// end ;
29739: GO 29648
29741: POP
29742: POP
// if p then
29743: LD_VAR 0 11
29747: IFFALSE 29772
// result := Replace ( result , 2 , p ) ;
29749: LD_ADDR_VAR 0 2
29753: PUSH
29754: LD_VAR 0 2
29758: PPUSH
29759: LD_INT 2
29761: PPUSH
29762: LD_VAR 0 11
29766: PPUSH
29767: CALL_OW 1
29771: ST_TO_ADDR
// end else
29772: GO 29818
// for i = eng downto 5 do
29774: LD_ADDR_VAR 0 3
29778: PUSH
29779: DOUBLE
29780: LD_VAR 0 6
29784: INC
29785: ST_TO_ADDR
29786: LD_INT 5
29788: PUSH
29789: FOR_DOWNTO
29790: IFFALSE 29816
// tmp := tmp union eng [ i ] ;
29792: LD_ADDR_VAR 0 4
29796: PUSH
29797: LD_VAR 0 4
29801: PUSH
29802: LD_VAR 0 6
29806: PUSH
29807: LD_VAR 0 3
29811: ARRAY
29812: UNION
29813: ST_TO_ADDR
29814: GO 29789
29816: POP
29817: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29818: LD_ADDR_VAR 0 2
29822: PUSH
29823: LD_VAR 0 2
29827: PPUSH
29828: LD_INT 1
29830: PPUSH
29831: LD_VAR 0 4
29835: PUSH
29836: LD_VAR 0 5
29840: DIFF
29841: PPUSH
29842: CALL_OW 1
29846: ST_TO_ADDR
// exit ;
29847: GO 29849
// end ; end ;
29849: LD_VAR 0 2
29853: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29854: LD_INT 0
29856: PPUSH
29857: PPUSH
29858: PPUSH
// if not mc_bases then
29859: LD_EXP 78
29863: NOT
29864: IFFALSE 29868
// exit ;
29866: GO 30010
// for i = 1 to mc_bases do
29868: LD_ADDR_VAR 0 2
29872: PUSH
29873: DOUBLE
29874: LD_INT 1
29876: DEC
29877: ST_TO_ADDR
29878: LD_EXP 78
29882: PUSH
29883: FOR_TO
29884: IFFALSE 30001
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29886: LD_ADDR_VAR 0 3
29890: PUSH
29891: LD_EXP 78
29895: PUSH
29896: LD_VAR 0 2
29900: ARRAY
29901: PPUSH
29902: LD_INT 21
29904: PUSH
29905: LD_INT 3
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 3
29914: PUSH
29915: LD_INT 2
29917: PUSH
29918: LD_INT 30
29920: PUSH
29921: LD_INT 29
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: PUSH
29928: LD_INT 30
29930: PUSH
29931: LD_INT 30
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: LIST
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 3
29949: PUSH
29950: LD_INT 24
29952: PUSH
29953: LD_INT 1000
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: LIST
29968: PPUSH
29969: CALL_OW 72
29973: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29974: LD_ADDR_EXP 79
29978: PUSH
29979: LD_EXP 79
29983: PPUSH
29984: LD_VAR 0 2
29988: PPUSH
29989: LD_VAR 0 3
29993: PPUSH
29994: CALL_OW 1
29998: ST_TO_ADDR
// end ;
29999: GO 29883
30001: POP
30002: POP
// RaiseSailEvent ( 101 ) ;
30003: LD_INT 101
30005: PPUSH
30006: CALL_OW 427
// end ;
30010: LD_VAR 0 1
30014: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
30015: LD_INT 0
30017: PPUSH
30018: PPUSH
30019: PPUSH
30020: PPUSH
30021: PPUSH
30022: PPUSH
30023: PPUSH
// if not mc_bases then
30024: LD_EXP 78
30028: NOT
30029: IFFALSE 30033
// exit ;
30031: GO 30595
// for i = 1 to mc_bases do
30033: LD_ADDR_VAR 0 2
30037: PUSH
30038: DOUBLE
30039: LD_INT 1
30041: DEC
30042: ST_TO_ADDR
30043: LD_EXP 78
30047: PUSH
30048: FOR_TO
30049: IFFALSE 30586
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
30051: LD_ADDR_VAR 0 5
30055: PUSH
30056: LD_EXP 78
30060: PUSH
30061: LD_VAR 0 2
30065: ARRAY
30066: PUSH
30067: LD_EXP 107
30071: PUSH
30072: LD_VAR 0 2
30076: ARRAY
30077: UNION
30078: PPUSH
30079: LD_INT 21
30081: PUSH
30082: LD_INT 1
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 1
30091: PUSH
30092: LD_INT 3
30094: PUSH
30095: LD_INT 54
30097: PUSH
30098: EMPTY
30099: LIST
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: PUSH
30105: LD_INT 3
30107: PUSH
30108: LD_INT 24
30110: PUSH
30111: LD_INT 1000
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: LIST
30126: PUSH
30127: EMPTY
30128: LIST
30129: LIST
30130: PPUSH
30131: CALL_OW 72
30135: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30136: LD_ADDR_VAR 0 6
30140: PUSH
30141: LD_EXP 78
30145: PUSH
30146: LD_VAR 0 2
30150: ARRAY
30151: PPUSH
30152: LD_INT 21
30154: PUSH
30155: LD_INT 1
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 1
30164: PUSH
30165: LD_INT 3
30167: PUSH
30168: LD_INT 54
30170: PUSH
30171: EMPTY
30172: LIST
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 3
30180: PUSH
30181: LD_INT 24
30183: PUSH
30184: LD_INT 250
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: LIST
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PPUSH
30204: CALL_OW 72
30208: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30209: LD_ADDR_VAR 0 7
30213: PUSH
30214: LD_VAR 0 5
30218: PUSH
30219: LD_VAR 0 6
30223: DIFF
30224: ST_TO_ADDR
// if not need_heal_1 then
30225: LD_VAR 0 6
30229: NOT
30230: IFFALSE 30263
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30232: LD_ADDR_EXP 81
30236: PUSH
30237: LD_EXP 81
30241: PPUSH
30242: LD_VAR 0 2
30246: PUSH
30247: LD_INT 1
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PPUSH
30254: EMPTY
30255: PPUSH
30256: CALL 57174 0 3
30260: ST_TO_ADDR
30261: GO 30333
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30263: LD_ADDR_EXP 81
30267: PUSH
30268: LD_EXP 81
30272: PPUSH
30273: LD_VAR 0 2
30277: PUSH
30278: LD_INT 1
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PPUSH
30285: LD_EXP 81
30289: PUSH
30290: LD_VAR 0 2
30294: ARRAY
30295: PUSH
30296: LD_INT 1
30298: ARRAY
30299: PPUSH
30300: LD_INT 3
30302: PUSH
30303: LD_INT 24
30305: PUSH
30306: LD_INT 1000
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PPUSH
30317: CALL_OW 72
30321: PUSH
30322: LD_VAR 0 6
30326: UNION
30327: PPUSH
30328: CALL 57174 0 3
30332: ST_TO_ADDR
// if not need_heal_2 then
30333: LD_VAR 0 7
30337: NOT
30338: IFFALSE 30371
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30340: LD_ADDR_EXP 81
30344: PUSH
30345: LD_EXP 81
30349: PPUSH
30350: LD_VAR 0 2
30354: PUSH
30355: LD_INT 2
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PPUSH
30362: EMPTY
30363: PPUSH
30364: CALL 57174 0 3
30368: ST_TO_ADDR
30369: GO 30403
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30371: LD_ADDR_EXP 81
30375: PUSH
30376: LD_EXP 81
30380: PPUSH
30381: LD_VAR 0 2
30385: PUSH
30386: LD_INT 2
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PPUSH
30393: LD_VAR 0 7
30397: PPUSH
30398: CALL 57174 0 3
30402: ST_TO_ADDR
// if need_heal_2 then
30403: LD_VAR 0 7
30407: IFFALSE 30568
// for j in need_heal_2 do
30409: LD_ADDR_VAR 0 3
30413: PUSH
30414: LD_VAR 0 7
30418: PUSH
30419: FOR_IN
30420: IFFALSE 30566
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30422: LD_ADDR_VAR 0 5
30426: PUSH
30427: LD_EXP 78
30431: PUSH
30432: LD_VAR 0 2
30436: ARRAY
30437: PPUSH
30438: LD_INT 2
30440: PUSH
30441: LD_INT 30
30443: PUSH
30444: LD_INT 6
30446: PUSH
30447: EMPTY
30448: LIST
30449: LIST
30450: PUSH
30451: LD_INT 30
30453: PUSH
30454: LD_INT 7
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 30
30463: PUSH
30464: LD_INT 8
30466: PUSH
30467: EMPTY
30468: LIST
30469: LIST
30470: PUSH
30471: LD_INT 30
30473: PUSH
30474: LD_INT 0
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 30
30483: PUSH
30484: LD_INT 1
30486: PUSH
30487: EMPTY
30488: LIST
30489: LIST
30490: PUSH
30491: EMPTY
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: PPUSH
30499: CALL_OW 72
30503: ST_TO_ADDR
// if tmp then
30504: LD_VAR 0 5
30508: IFFALSE 30564
// begin k := NearestUnitToUnit ( tmp , j ) ;
30510: LD_ADDR_VAR 0 4
30514: PUSH
30515: LD_VAR 0 5
30519: PPUSH
30520: LD_VAR 0 3
30524: PPUSH
30525: CALL_OW 74
30529: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30530: LD_VAR 0 3
30534: PPUSH
30535: LD_VAR 0 4
30539: PPUSH
30540: CALL_OW 296
30544: PUSH
30545: LD_INT 5
30547: GREATER
30548: IFFALSE 30564
// ComMoveToNearbyEntrance ( j , k ) ;
30550: LD_VAR 0 3
30554: PPUSH
30555: LD_VAR 0 4
30559: PPUSH
30560: CALL 90381 0 2
// end ; end ;
30564: GO 30419
30566: POP
30567: POP
// if not need_heal_1 and not need_heal_2 then
30568: LD_VAR 0 6
30572: NOT
30573: PUSH
30574: LD_VAR 0 7
30578: NOT
30579: AND
30580: IFFALSE 30584
// continue ;
30582: GO 30048
// end ;
30584: GO 30048
30586: POP
30587: POP
// RaiseSailEvent ( 102 ) ;
30588: LD_INT 102
30590: PPUSH
30591: CALL_OW 427
// end ;
30595: LD_VAR 0 1
30599: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30600: LD_INT 0
30602: PPUSH
30603: PPUSH
30604: PPUSH
30605: PPUSH
30606: PPUSH
30607: PPUSH
30608: PPUSH
30609: PPUSH
// if not mc_bases then
30610: LD_EXP 78
30614: NOT
30615: IFFALSE 30619
// exit ;
30617: GO 31530
// for i = 1 to mc_bases do
30619: LD_ADDR_VAR 0 2
30623: PUSH
30624: DOUBLE
30625: LD_INT 1
30627: DEC
30628: ST_TO_ADDR
30629: LD_EXP 78
30633: PUSH
30634: FOR_TO
30635: IFFALSE 31528
// begin if not mc_building_need_repair [ i ] then
30637: LD_EXP 79
30641: PUSH
30642: LD_VAR 0 2
30646: ARRAY
30647: NOT
30648: IFFALSE 30833
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30650: LD_ADDR_VAR 0 6
30654: PUSH
30655: LD_EXP 97
30659: PUSH
30660: LD_VAR 0 2
30664: ARRAY
30665: PPUSH
30666: LD_INT 3
30668: PUSH
30669: LD_INT 24
30671: PUSH
30672: LD_INT 1000
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 2
30685: PUSH
30686: LD_INT 34
30688: PUSH
30689: LD_INT 13
30691: PUSH
30692: EMPTY
30693: LIST
30694: LIST
30695: PUSH
30696: LD_INT 34
30698: PUSH
30699: LD_INT 52
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 34
30708: PUSH
30709: LD_INT 88
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PPUSH
30726: CALL_OW 72
30730: ST_TO_ADDR
// if cranes then
30731: LD_VAR 0 6
30735: IFFALSE 30797
// for j in cranes do
30737: LD_ADDR_VAR 0 3
30741: PUSH
30742: LD_VAR 0 6
30746: PUSH
30747: FOR_IN
30748: IFFALSE 30795
// if not IsInArea ( j , mc_parking [ i ] ) then
30750: LD_VAR 0 3
30754: PPUSH
30755: LD_EXP 102
30759: PUSH
30760: LD_VAR 0 2
30764: ARRAY
30765: PPUSH
30766: CALL_OW 308
30770: NOT
30771: IFFALSE 30793
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30773: LD_VAR 0 3
30777: PPUSH
30778: LD_EXP 102
30782: PUSH
30783: LD_VAR 0 2
30787: ARRAY
30788: PPUSH
30789: CALL_OW 113
30793: GO 30747
30795: POP
30796: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30797: LD_ADDR_EXP 80
30801: PUSH
30802: LD_EXP 80
30806: PPUSH
30807: LD_VAR 0 2
30811: PPUSH
30812: EMPTY
30813: PPUSH
30814: CALL_OW 1
30818: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30819: LD_VAR 0 2
30823: PPUSH
30824: LD_INT 101
30826: PPUSH
30827: CALL 25687 0 2
// continue ;
30831: GO 30634
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30833: LD_ADDR_EXP 84
30837: PUSH
30838: LD_EXP 84
30842: PPUSH
30843: LD_VAR 0 2
30847: PPUSH
30848: EMPTY
30849: PPUSH
30850: CALL_OW 1
30854: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30855: LD_VAR 0 2
30859: PPUSH
30860: LD_INT 103
30862: PPUSH
30863: CALL 25687 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30867: LD_ADDR_VAR 0 5
30871: PUSH
30872: LD_EXP 78
30876: PUSH
30877: LD_VAR 0 2
30881: ARRAY
30882: PUSH
30883: LD_EXP 107
30887: PUSH
30888: LD_VAR 0 2
30892: ARRAY
30893: UNION
30894: PPUSH
30895: LD_INT 2
30897: PUSH
30898: LD_INT 25
30900: PUSH
30901: LD_INT 2
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 25
30910: PUSH
30911: LD_INT 16
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: EMPTY
30919: LIST
30920: LIST
30921: LIST
30922: PUSH
30923: EMPTY
30924: LIST
30925: PPUSH
30926: CALL_OW 72
30930: ST_TO_ADDR
// if mc_need_heal [ i ] then
30931: LD_EXP 81
30935: PUSH
30936: LD_VAR 0 2
30940: ARRAY
30941: IFFALSE 30985
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30943: LD_ADDR_VAR 0 5
30947: PUSH
30948: LD_VAR 0 5
30952: PUSH
30953: LD_EXP 81
30957: PUSH
30958: LD_VAR 0 2
30962: ARRAY
30963: PUSH
30964: LD_INT 1
30966: ARRAY
30967: PUSH
30968: LD_EXP 81
30972: PUSH
30973: LD_VAR 0 2
30977: ARRAY
30978: PUSH
30979: LD_INT 2
30981: ARRAY
30982: UNION
30983: DIFF
30984: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30985: LD_ADDR_VAR 0 6
30989: PUSH
30990: LD_EXP 97
30994: PUSH
30995: LD_VAR 0 2
30999: ARRAY
31000: PPUSH
31001: LD_INT 2
31003: PUSH
31004: LD_INT 34
31006: PUSH
31007: LD_INT 13
31009: PUSH
31010: EMPTY
31011: LIST
31012: LIST
31013: PUSH
31014: LD_INT 34
31016: PUSH
31017: LD_INT 52
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: LD_INT 34
31026: PUSH
31027: LD_INT 88
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: LIST
31038: LIST
31039: PPUSH
31040: CALL_OW 72
31044: ST_TO_ADDR
// if cranes then
31045: LD_VAR 0 6
31049: IFFALSE 31217
// begin for j in cranes do
31051: LD_ADDR_VAR 0 3
31055: PUSH
31056: LD_VAR 0 6
31060: PUSH
31061: FOR_IN
31062: IFFALSE 31215
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
31064: LD_VAR 0 3
31068: PPUSH
31069: CALL_OW 256
31073: PUSH
31074: LD_INT 1000
31076: EQUAL
31077: PUSH
31078: LD_VAR 0 3
31082: PPUSH
31083: CALL_OW 314
31087: NOT
31088: AND
31089: IFFALSE 31155
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
31091: LD_ADDR_VAR 0 8
31095: PUSH
31096: LD_EXP 79
31100: PUSH
31101: LD_VAR 0 2
31105: ARRAY
31106: PPUSH
31107: LD_VAR 0 3
31111: PPUSH
31112: CALL_OW 74
31116: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31117: LD_VAR 0 8
31121: PPUSH
31122: LD_INT 16
31124: PPUSH
31125: CALL 59771 0 2
31129: PUSH
31130: LD_INT 4
31132: ARRAY
31133: PUSH
31134: LD_INT 10
31136: LESS
31137: IFFALSE 31153
// ComRepairBuilding ( j , to_repair ) ;
31139: LD_VAR 0 3
31143: PPUSH
31144: LD_VAR 0 8
31148: PPUSH
31149: CALL_OW 130
// end else
31153: GO 31213
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
31155: LD_VAR 0 3
31159: PPUSH
31160: CALL_OW 256
31164: PUSH
31165: LD_INT 500
31167: LESS
31168: PUSH
31169: LD_VAR 0 3
31173: PPUSH
31174: LD_EXP 102
31178: PUSH
31179: LD_VAR 0 2
31183: ARRAY
31184: PPUSH
31185: CALL_OW 308
31189: NOT
31190: AND
31191: IFFALSE 31213
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31193: LD_VAR 0 3
31197: PPUSH
31198: LD_EXP 102
31202: PUSH
31203: LD_VAR 0 2
31207: ARRAY
31208: PPUSH
31209: CALL_OW 113
// end ;
31213: GO 31061
31215: POP
31216: POP
// end ; if tmp > 3 then
31217: LD_VAR 0 5
31221: PUSH
31222: LD_INT 3
31224: GREATER
31225: IFFALSE 31245
// tmp := ShrinkArray ( tmp , 4 ) ;
31227: LD_ADDR_VAR 0 5
31231: PUSH
31232: LD_VAR 0 5
31236: PPUSH
31237: LD_INT 4
31239: PPUSH
31240: CALL 89819 0 2
31244: ST_TO_ADDR
// if not tmp then
31245: LD_VAR 0 5
31249: NOT
31250: IFFALSE 31254
// continue ;
31252: GO 30634
// for j in tmp do
31254: LD_ADDR_VAR 0 3
31258: PUSH
31259: LD_VAR 0 5
31263: PUSH
31264: FOR_IN
31265: IFFALSE 31524
// begin if IsInUnit ( j ) then
31267: LD_VAR 0 3
31271: PPUSH
31272: CALL_OW 310
31276: IFFALSE 31287
// ComExitBuilding ( j ) ;
31278: LD_VAR 0 3
31282: PPUSH
31283: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31287: LD_VAR 0 3
31291: PUSH
31292: LD_EXP 80
31296: PUSH
31297: LD_VAR 0 2
31301: ARRAY
31302: IN
31303: NOT
31304: IFFALSE 31362
// begin SetTag ( j , 101 ) ;
31306: LD_VAR 0 3
31310: PPUSH
31311: LD_INT 101
31313: PPUSH
31314: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31318: LD_ADDR_EXP 80
31322: PUSH
31323: LD_EXP 80
31327: PPUSH
31328: LD_VAR 0 2
31332: PUSH
31333: LD_EXP 80
31337: PUSH
31338: LD_VAR 0 2
31342: ARRAY
31343: PUSH
31344: LD_INT 1
31346: PLUS
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: PPUSH
31352: LD_VAR 0 3
31356: PPUSH
31357: CALL 57174 0 3
31361: ST_TO_ADDR
// end ; wait ( 1 ) ;
31362: LD_INT 1
31364: PPUSH
31365: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31369: LD_ADDR_VAR 0 7
31373: PUSH
31374: LD_EXP 79
31378: PUSH
31379: LD_VAR 0 2
31383: ARRAY
31384: ST_TO_ADDR
// if mc_scan [ i ] then
31385: LD_EXP 101
31389: PUSH
31390: LD_VAR 0 2
31394: ARRAY
31395: IFFALSE 31457
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31397: LD_ADDR_VAR 0 7
31401: PUSH
31402: LD_EXP 79
31406: PUSH
31407: LD_VAR 0 2
31411: ARRAY
31412: PPUSH
31413: LD_INT 3
31415: PUSH
31416: LD_INT 30
31418: PUSH
31419: LD_INT 32
31421: PUSH
31422: EMPTY
31423: LIST
31424: LIST
31425: PUSH
31426: LD_INT 30
31428: PUSH
31429: LD_INT 33
31431: PUSH
31432: EMPTY
31433: LIST
31434: LIST
31435: PUSH
31436: LD_INT 30
31438: PUSH
31439: LD_INT 31
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: LIST
31450: LIST
31451: PPUSH
31452: CALL_OW 72
31456: ST_TO_ADDR
// if not to_repair_tmp then
31457: LD_VAR 0 7
31461: NOT
31462: IFFALSE 31466
// continue ;
31464: GO 31264
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31466: LD_ADDR_VAR 0 8
31470: PUSH
31471: LD_VAR 0 7
31475: PPUSH
31476: LD_VAR 0 3
31480: PPUSH
31481: CALL_OW 74
31485: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
31486: LD_VAR 0 8
31490: PPUSH
31491: LD_INT 16
31493: PPUSH
31494: CALL 59771 0 2
31498: PUSH
31499: LD_INT 4
31501: ARRAY
31502: PUSH
31503: LD_INT 14
31505: LESS
31506: IFFALSE 31522
// ComRepairBuilding ( j , to_repair ) ;
31508: LD_VAR 0 3
31512: PPUSH
31513: LD_VAR 0 8
31517: PPUSH
31518: CALL_OW 130
// end ;
31522: GO 31264
31524: POP
31525: POP
// end ;
31526: GO 30634
31528: POP
31529: POP
// end ;
31530: LD_VAR 0 1
31534: RET
// export function MC_Heal ; var i , j , tmp ; begin
31535: LD_INT 0
31537: PPUSH
31538: PPUSH
31539: PPUSH
31540: PPUSH
// if not mc_bases then
31541: LD_EXP 78
31545: NOT
31546: IFFALSE 31550
// exit ;
31548: GO 31952
// for i = 1 to mc_bases do
31550: LD_ADDR_VAR 0 2
31554: PUSH
31555: DOUBLE
31556: LD_INT 1
31558: DEC
31559: ST_TO_ADDR
31560: LD_EXP 78
31564: PUSH
31565: FOR_TO
31566: IFFALSE 31950
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31568: LD_EXP 81
31572: PUSH
31573: LD_VAR 0 2
31577: ARRAY
31578: PUSH
31579: LD_INT 1
31581: ARRAY
31582: NOT
31583: PUSH
31584: LD_EXP 81
31588: PUSH
31589: LD_VAR 0 2
31593: ARRAY
31594: PUSH
31595: LD_INT 2
31597: ARRAY
31598: NOT
31599: AND
31600: IFFALSE 31638
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31602: LD_ADDR_EXP 82
31606: PUSH
31607: LD_EXP 82
31611: PPUSH
31612: LD_VAR 0 2
31616: PPUSH
31617: EMPTY
31618: PPUSH
31619: CALL_OW 1
31623: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31624: LD_VAR 0 2
31628: PPUSH
31629: LD_INT 102
31631: PPUSH
31632: CALL 25687 0 2
// continue ;
31636: GO 31565
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31638: LD_ADDR_VAR 0 4
31642: PUSH
31643: LD_EXP 78
31647: PUSH
31648: LD_VAR 0 2
31652: ARRAY
31653: PPUSH
31654: LD_INT 25
31656: PUSH
31657: LD_INT 4
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PPUSH
31664: CALL_OW 72
31668: ST_TO_ADDR
// if not tmp then
31669: LD_VAR 0 4
31673: NOT
31674: IFFALSE 31678
// continue ;
31676: GO 31565
// if mc_taming [ i ] then
31678: LD_EXP 109
31682: PUSH
31683: LD_VAR 0 2
31687: ARRAY
31688: IFFALSE 31712
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31690: LD_ADDR_EXP 109
31694: PUSH
31695: LD_EXP 109
31699: PPUSH
31700: LD_VAR 0 2
31704: PPUSH
31705: EMPTY
31706: PPUSH
31707: CALL_OW 1
31711: ST_TO_ADDR
// for j in tmp do
31712: LD_ADDR_VAR 0 3
31716: PUSH
31717: LD_VAR 0 4
31721: PUSH
31722: FOR_IN
31723: IFFALSE 31946
// begin if IsInUnit ( j ) then
31725: LD_VAR 0 3
31729: PPUSH
31730: CALL_OW 310
31734: IFFALSE 31745
// ComExitBuilding ( j ) ;
31736: LD_VAR 0 3
31740: PPUSH
31741: CALL_OW 122
// if not j in mc_healers [ i ] then
31745: LD_VAR 0 3
31749: PUSH
31750: LD_EXP 82
31754: PUSH
31755: LD_VAR 0 2
31759: ARRAY
31760: IN
31761: NOT
31762: IFFALSE 31808
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31764: LD_ADDR_EXP 82
31768: PUSH
31769: LD_EXP 82
31773: PPUSH
31774: LD_VAR 0 2
31778: PUSH
31779: LD_EXP 82
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: PUSH
31790: LD_INT 1
31792: PLUS
31793: PUSH
31794: EMPTY
31795: LIST
31796: LIST
31797: PPUSH
31798: LD_VAR 0 3
31802: PPUSH
31803: CALL 57174 0 3
31807: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31808: LD_VAR 0 3
31812: PPUSH
31813: CALL_OW 110
31817: PUSH
31818: LD_INT 102
31820: NONEQUAL
31821: IFFALSE 31835
// SetTag ( j , 102 ) ;
31823: LD_VAR 0 3
31827: PPUSH
31828: LD_INT 102
31830: PPUSH
31831: CALL_OW 109
// Wait ( 3 ) ;
31835: LD_INT 3
31837: PPUSH
31838: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31842: LD_EXP 81
31846: PUSH
31847: LD_VAR 0 2
31851: ARRAY
31852: PUSH
31853: LD_INT 1
31855: ARRAY
31856: IFFALSE 31888
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31858: LD_VAR 0 3
31862: PPUSH
31863: LD_EXP 81
31867: PUSH
31868: LD_VAR 0 2
31872: ARRAY
31873: PUSH
31874: LD_INT 1
31876: ARRAY
31877: PUSH
31878: LD_INT 1
31880: ARRAY
31881: PPUSH
31882: CALL_OW 128
31886: GO 31944
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31888: LD_VAR 0 3
31892: PPUSH
31893: CALL_OW 314
31897: NOT
31898: PUSH
31899: LD_EXP 81
31903: PUSH
31904: LD_VAR 0 2
31908: ARRAY
31909: PUSH
31910: LD_INT 2
31912: ARRAY
31913: AND
31914: IFFALSE 31944
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31916: LD_VAR 0 3
31920: PPUSH
31921: LD_EXP 81
31925: PUSH
31926: LD_VAR 0 2
31930: ARRAY
31931: PUSH
31932: LD_INT 2
31934: ARRAY
31935: PUSH
31936: LD_INT 1
31938: ARRAY
31939: PPUSH
31940: CALL_OW 128
// end ;
31944: GO 31722
31946: POP
31947: POP
// end ;
31948: GO 31565
31950: POP
31951: POP
// end ;
31952: LD_VAR 0 1
31956: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
31957: LD_INT 0
31959: PPUSH
31960: PPUSH
31961: PPUSH
31962: PPUSH
31963: PPUSH
31964: PPUSH
// if not mc_bases then
31965: LD_EXP 78
31969: NOT
31970: IFFALSE 31974
// exit ;
31972: GO 33137
// for i = 1 to mc_bases do
31974: LD_ADDR_VAR 0 2
31978: PUSH
31979: DOUBLE
31980: LD_INT 1
31982: DEC
31983: ST_TO_ADDR
31984: LD_EXP 78
31988: PUSH
31989: FOR_TO
31990: IFFALSE 33135
// begin if mc_scan [ i ] then
31992: LD_EXP 101
31996: PUSH
31997: LD_VAR 0 2
32001: ARRAY
32002: IFFALSE 32006
// continue ;
32004: GO 31989
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
32006: LD_EXP 83
32010: PUSH
32011: LD_VAR 0 2
32015: ARRAY
32016: NOT
32017: PUSH
32018: LD_EXP 85
32022: PUSH
32023: LD_VAR 0 2
32027: ARRAY
32028: NOT
32029: AND
32030: PUSH
32031: LD_EXP 84
32035: PUSH
32036: LD_VAR 0 2
32040: ARRAY
32041: AND
32042: IFFALSE 32080
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
32044: LD_ADDR_EXP 84
32048: PUSH
32049: LD_EXP 84
32053: PPUSH
32054: LD_VAR 0 2
32058: PPUSH
32059: EMPTY
32060: PPUSH
32061: CALL_OW 1
32065: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32066: LD_VAR 0 2
32070: PPUSH
32071: LD_INT 103
32073: PPUSH
32074: CALL 25687 0 2
// continue ;
32078: GO 31989
// end ; if mc_construct_list [ i ] then
32080: LD_EXP 85
32084: PUSH
32085: LD_VAR 0 2
32089: ARRAY
32090: IFFALSE 32310
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32092: LD_ADDR_VAR 0 5
32096: PUSH
32097: LD_EXP 78
32101: PUSH
32102: LD_VAR 0 2
32106: ARRAY
32107: PPUSH
32108: LD_INT 25
32110: PUSH
32111: LD_INT 2
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PPUSH
32118: CALL_OW 72
32122: PUSH
32123: LD_EXP 80
32127: PUSH
32128: LD_VAR 0 2
32132: ARRAY
32133: DIFF
32134: ST_TO_ADDR
// if not tmp then
32135: LD_VAR 0 5
32139: NOT
32140: IFFALSE 32144
// continue ;
32142: GO 31989
// for j in tmp do
32144: LD_ADDR_VAR 0 3
32148: PUSH
32149: LD_VAR 0 5
32153: PUSH
32154: FOR_IN
32155: IFFALSE 32306
// begin if not mc_builders [ i ] then
32157: LD_EXP 84
32161: PUSH
32162: LD_VAR 0 2
32166: ARRAY
32167: NOT
32168: IFFALSE 32226
// begin SetTag ( j , 103 ) ;
32170: LD_VAR 0 3
32174: PPUSH
32175: LD_INT 103
32177: PPUSH
32178: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32182: LD_ADDR_EXP 84
32186: PUSH
32187: LD_EXP 84
32191: PPUSH
32192: LD_VAR 0 2
32196: PUSH
32197: LD_EXP 84
32201: PUSH
32202: LD_VAR 0 2
32206: ARRAY
32207: PUSH
32208: LD_INT 1
32210: PLUS
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PPUSH
32216: LD_VAR 0 3
32220: PPUSH
32221: CALL 57174 0 3
32225: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32226: LD_VAR 0 3
32230: PPUSH
32231: CALL_OW 310
32235: IFFALSE 32246
// ComExitBuilding ( j ) ;
32237: LD_VAR 0 3
32241: PPUSH
32242: CALL_OW 122
// wait ( 3 ) ;
32246: LD_INT 3
32248: PPUSH
32249: CALL_OW 67
// if not mc_construct_list [ i ] then
32253: LD_EXP 85
32257: PUSH
32258: LD_VAR 0 2
32262: ARRAY
32263: NOT
32264: IFFALSE 32268
// break ;
32266: GO 32306
// if not HasTask ( j ) then
32268: LD_VAR 0 3
32272: PPUSH
32273: CALL_OW 314
32277: NOT
32278: IFFALSE 32304
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32280: LD_VAR 0 3
32284: PPUSH
32285: LD_EXP 85
32289: PUSH
32290: LD_VAR 0 2
32294: ARRAY
32295: PUSH
32296: LD_INT 1
32298: ARRAY
32299: PPUSH
32300: CALL 60035 0 2
// end ;
32304: GO 32154
32306: POP
32307: POP
// end else
32308: GO 33133
// if mc_build_list [ i ] then
32310: LD_EXP 83
32314: PUSH
32315: LD_VAR 0 2
32319: ARRAY
32320: IFFALSE 33133
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32322: LD_EXP 83
32326: PUSH
32327: LD_VAR 0 2
32331: ARRAY
32332: PUSH
32333: LD_INT 1
32335: ARRAY
32336: PUSH
32337: LD_INT 1
32339: ARRAY
32340: PPUSH
32341: CALL 59859 0 1
32345: PUSH
32346: LD_EXP 78
32350: PUSH
32351: LD_VAR 0 2
32355: ARRAY
32356: PPUSH
32357: LD_INT 2
32359: PUSH
32360: LD_INT 30
32362: PUSH
32363: LD_INT 2
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 30
32372: PUSH
32373: LD_INT 3
32375: PUSH
32376: EMPTY
32377: LIST
32378: LIST
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: LIST
32384: PPUSH
32385: CALL_OW 72
32389: NOT
32390: AND
32391: IFFALSE 32496
// begin for j = 1 to mc_build_list [ i ] do
32393: LD_ADDR_VAR 0 3
32397: PUSH
32398: DOUBLE
32399: LD_INT 1
32401: DEC
32402: ST_TO_ADDR
32403: LD_EXP 83
32407: PUSH
32408: LD_VAR 0 2
32412: ARRAY
32413: PUSH
32414: FOR_TO
32415: IFFALSE 32494
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32417: LD_EXP 83
32421: PUSH
32422: LD_VAR 0 2
32426: ARRAY
32427: PUSH
32428: LD_VAR 0 3
32432: ARRAY
32433: PUSH
32434: LD_INT 1
32436: ARRAY
32437: PUSH
32438: LD_INT 2
32440: EQUAL
32441: IFFALSE 32492
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32443: LD_ADDR_EXP 83
32447: PUSH
32448: LD_EXP 83
32452: PPUSH
32453: LD_VAR 0 2
32457: PPUSH
32458: LD_EXP 83
32462: PUSH
32463: LD_VAR 0 2
32467: ARRAY
32468: PPUSH
32469: LD_VAR 0 3
32473: PPUSH
32474: LD_INT 1
32476: PPUSH
32477: LD_INT 0
32479: PPUSH
32480: CALL 56592 0 4
32484: PPUSH
32485: CALL_OW 1
32489: ST_TO_ADDR
// break ;
32490: GO 32494
// end ;
32492: GO 32414
32494: POP
32495: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32496: LD_ADDR_VAR 0 6
32500: PUSH
32501: LD_EXP 78
32505: PUSH
32506: LD_VAR 0 2
32510: ARRAY
32511: PPUSH
32512: LD_INT 2
32514: PUSH
32515: LD_INT 30
32517: PUSH
32518: LD_INT 0
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 30
32527: PUSH
32528: LD_INT 1
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: LIST
32539: PPUSH
32540: CALL_OW 72
32544: ST_TO_ADDR
// for k := 1 to depot do
32545: LD_ADDR_VAR 0 4
32549: PUSH
32550: DOUBLE
32551: LD_INT 1
32553: DEC
32554: ST_TO_ADDR
32555: LD_VAR 0 6
32559: PUSH
32560: FOR_TO
32561: IFFALSE 33131
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
32563: LD_EXP 83
32567: PUSH
32568: LD_VAR 0 2
32572: ARRAY
32573: PUSH
32574: LD_INT 1
32576: ARRAY
32577: PUSH
32578: LD_INT 1
32580: ARRAY
32581: PUSH
32582: LD_INT 0
32584: EQUAL
32585: PUSH
32586: LD_VAR 0 6
32590: PUSH
32591: LD_VAR 0 4
32595: ARRAY
32596: PPUSH
32597: LD_EXP 83
32601: PUSH
32602: LD_VAR 0 2
32606: ARRAY
32607: PUSH
32608: LD_INT 1
32610: ARRAY
32611: PUSH
32612: LD_INT 1
32614: ARRAY
32615: PPUSH
32616: LD_EXP 83
32620: PUSH
32621: LD_VAR 0 2
32625: ARRAY
32626: PUSH
32627: LD_INT 1
32629: ARRAY
32630: PUSH
32631: LD_INT 2
32633: ARRAY
32634: PPUSH
32635: LD_EXP 83
32639: PUSH
32640: LD_VAR 0 2
32644: ARRAY
32645: PUSH
32646: LD_INT 1
32648: ARRAY
32649: PUSH
32650: LD_INT 3
32652: ARRAY
32653: PPUSH
32654: LD_EXP 83
32658: PUSH
32659: LD_VAR 0 2
32663: ARRAY
32664: PUSH
32665: LD_INT 1
32667: ARRAY
32668: PUSH
32669: LD_INT 4
32671: ARRAY
32672: PPUSH
32673: CALL 65271 0 5
32677: OR
32678: IFFALSE 32959
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32680: LD_ADDR_VAR 0 5
32684: PUSH
32685: LD_EXP 78
32689: PUSH
32690: LD_VAR 0 2
32694: ARRAY
32695: PPUSH
32696: LD_INT 25
32698: PUSH
32699: LD_INT 2
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PPUSH
32706: CALL_OW 72
32710: PUSH
32711: LD_EXP 80
32715: PUSH
32716: LD_VAR 0 2
32720: ARRAY
32721: DIFF
32722: ST_TO_ADDR
// if not tmp then
32723: LD_VAR 0 5
32727: NOT
32728: IFFALSE 32732
// continue ;
32730: GO 32560
// for j in tmp do
32732: LD_ADDR_VAR 0 3
32736: PUSH
32737: LD_VAR 0 5
32741: PUSH
32742: FOR_IN
32743: IFFALSE 32955
// begin if not mc_builders [ i ] then
32745: LD_EXP 84
32749: PUSH
32750: LD_VAR 0 2
32754: ARRAY
32755: NOT
32756: IFFALSE 32814
// begin SetTag ( j , 103 ) ;
32758: LD_VAR 0 3
32762: PPUSH
32763: LD_INT 103
32765: PPUSH
32766: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32770: LD_ADDR_EXP 84
32774: PUSH
32775: LD_EXP 84
32779: PPUSH
32780: LD_VAR 0 2
32784: PUSH
32785: LD_EXP 84
32789: PUSH
32790: LD_VAR 0 2
32794: ARRAY
32795: PUSH
32796: LD_INT 1
32798: PLUS
32799: PUSH
32800: EMPTY
32801: LIST
32802: LIST
32803: PPUSH
32804: LD_VAR 0 3
32808: PPUSH
32809: CALL 57174 0 3
32813: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32814: LD_VAR 0 3
32818: PPUSH
32819: CALL_OW 310
32823: IFFALSE 32834
// ComExitBuilding ( j ) ;
32825: LD_VAR 0 3
32829: PPUSH
32830: CALL_OW 122
// wait ( 3 ) ;
32834: LD_INT 3
32836: PPUSH
32837: CALL_OW 67
// if not mc_build_list [ i ] then
32841: LD_EXP 83
32845: PUSH
32846: LD_VAR 0 2
32850: ARRAY
32851: NOT
32852: IFFALSE 32856
// break ;
32854: GO 32955
// if not HasTask ( j ) then
32856: LD_VAR 0 3
32860: PPUSH
32861: CALL_OW 314
32865: NOT
32866: IFFALSE 32953
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32868: LD_VAR 0 3
32872: PPUSH
32873: LD_EXP 83
32877: PUSH
32878: LD_VAR 0 2
32882: ARRAY
32883: PUSH
32884: LD_INT 1
32886: ARRAY
32887: PUSH
32888: LD_INT 1
32890: ARRAY
32891: PPUSH
32892: LD_EXP 83
32896: PUSH
32897: LD_VAR 0 2
32901: ARRAY
32902: PUSH
32903: LD_INT 1
32905: ARRAY
32906: PUSH
32907: LD_INT 2
32909: ARRAY
32910: PPUSH
32911: LD_EXP 83
32915: PUSH
32916: LD_VAR 0 2
32920: ARRAY
32921: PUSH
32922: LD_INT 1
32924: ARRAY
32925: PUSH
32926: LD_INT 3
32928: ARRAY
32929: PPUSH
32930: LD_EXP 83
32934: PUSH
32935: LD_VAR 0 2
32939: ARRAY
32940: PUSH
32941: LD_INT 1
32943: ARRAY
32944: PUSH
32945: LD_INT 4
32947: ARRAY
32948: PPUSH
32949: CALL_OW 145
// end ;
32953: GO 32742
32955: POP
32956: POP
// end else
32957: GO 33129
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32959: LD_EXP 78
32963: PUSH
32964: LD_VAR 0 2
32968: ARRAY
32969: PPUSH
32970: LD_EXP 83
32974: PUSH
32975: LD_VAR 0 2
32979: ARRAY
32980: PUSH
32981: LD_INT 1
32983: ARRAY
32984: PUSH
32985: LD_INT 1
32987: ARRAY
32988: PPUSH
32989: LD_EXP 83
32993: PUSH
32994: LD_VAR 0 2
32998: ARRAY
32999: PUSH
33000: LD_INT 1
33002: ARRAY
33003: PUSH
33004: LD_INT 2
33006: ARRAY
33007: PPUSH
33008: LD_EXP 83
33012: PUSH
33013: LD_VAR 0 2
33017: ARRAY
33018: PUSH
33019: LD_INT 1
33021: ARRAY
33022: PUSH
33023: LD_INT 3
33025: ARRAY
33026: PPUSH
33027: LD_EXP 83
33031: PUSH
33032: LD_VAR 0 2
33036: ARRAY
33037: PUSH
33038: LD_INT 1
33040: ARRAY
33041: PUSH
33042: LD_INT 4
33044: ARRAY
33045: PPUSH
33046: LD_EXP 78
33050: PUSH
33051: LD_VAR 0 2
33055: ARRAY
33056: PPUSH
33057: LD_INT 21
33059: PUSH
33060: LD_INT 3
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PPUSH
33067: CALL_OW 72
33071: PPUSH
33072: EMPTY
33073: PPUSH
33074: CALL 64025 0 7
33078: NOT
33079: IFFALSE 33129
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
33081: LD_ADDR_EXP 83
33085: PUSH
33086: LD_EXP 83
33090: PPUSH
33091: LD_VAR 0 2
33095: PPUSH
33096: LD_EXP 83
33100: PUSH
33101: LD_VAR 0 2
33105: ARRAY
33106: PPUSH
33107: LD_INT 1
33109: PPUSH
33110: LD_INT 1
33112: NEG
33113: PPUSH
33114: LD_INT 0
33116: PPUSH
33117: CALL 56592 0 4
33121: PPUSH
33122: CALL_OW 1
33126: ST_TO_ADDR
// continue ;
33127: GO 32560
// end ; end ;
33129: GO 32560
33131: POP
33132: POP
// end ; end ;
33133: GO 31989
33135: POP
33136: POP
// end ;
33137: LD_VAR 0 1
33141: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
33142: LD_INT 0
33144: PPUSH
33145: PPUSH
33146: PPUSH
33147: PPUSH
33148: PPUSH
33149: PPUSH
// if not mc_bases then
33150: LD_EXP 78
33154: NOT
33155: IFFALSE 33159
// exit ;
33157: GO 33586
// for i = 1 to mc_bases do
33159: LD_ADDR_VAR 0 2
33163: PUSH
33164: DOUBLE
33165: LD_INT 1
33167: DEC
33168: ST_TO_ADDR
33169: LD_EXP 78
33173: PUSH
33174: FOR_TO
33175: IFFALSE 33584
// begin tmp := mc_build_upgrade [ i ] ;
33177: LD_ADDR_VAR 0 4
33181: PUSH
33182: LD_EXP 110
33186: PUSH
33187: LD_VAR 0 2
33191: ARRAY
33192: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33193: LD_ADDR_VAR 0 6
33197: PUSH
33198: LD_EXP 111
33202: PUSH
33203: LD_VAR 0 2
33207: ARRAY
33208: PPUSH
33209: LD_INT 2
33211: PUSH
33212: LD_INT 30
33214: PUSH
33215: LD_INT 6
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 30
33224: PUSH
33225: LD_INT 7
33227: PUSH
33228: EMPTY
33229: LIST
33230: LIST
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: LIST
33236: PPUSH
33237: CALL_OW 72
33241: ST_TO_ADDR
// if not tmp and not lab then
33242: LD_VAR 0 4
33246: NOT
33247: PUSH
33248: LD_VAR 0 6
33252: NOT
33253: AND
33254: IFFALSE 33258
// continue ;
33256: GO 33174
// if tmp then
33258: LD_VAR 0 4
33262: IFFALSE 33382
// for j in tmp do
33264: LD_ADDR_VAR 0 3
33268: PUSH
33269: LD_VAR 0 4
33273: PUSH
33274: FOR_IN
33275: IFFALSE 33380
// begin if UpgradeCost ( j ) then
33277: LD_VAR 0 3
33281: PPUSH
33282: CALL 63685 0 1
33286: IFFALSE 33378
// begin ComUpgrade ( j ) ;
33288: LD_VAR 0 3
33292: PPUSH
33293: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33297: LD_ADDR_EXP 110
33301: PUSH
33302: LD_EXP 110
33306: PPUSH
33307: LD_VAR 0 2
33311: PPUSH
33312: LD_EXP 110
33316: PUSH
33317: LD_VAR 0 2
33321: ARRAY
33322: PUSH
33323: LD_VAR 0 3
33327: DIFF
33328: PPUSH
33329: CALL_OW 1
33333: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33334: LD_ADDR_EXP 85
33338: PUSH
33339: LD_EXP 85
33343: PPUSH
33344: LD_VAR 0 2
33348: PUSH
33349: LD_EXP 85
33353: PUSH
33354: LD_VAR 0 2
33358: ARRAY
33359: PUSH
33360: LD_INT 1
33362: PLUS
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PPUSH
33368: LD_VAR 0 3
33372: PPUSH
33373: CALL 57174 0 3
33377: ST_TO_ADDR
// end ; end ;
33378: GO 33274
33380: POP
33381: POP
// if not lab or not mc_lab_upgrade [ i ] then
33382: LD_VAR 0 6
33386: NOT
33387: PUSH
33388: LD_EXP 112
33392: PUSH
33393: LD_VAR 0 2
33397: ARRAY
33398: NOT
33399: OR
33400: IFFALSE 33404
// continue ;
33402: GO 33174
// for j in lab do
33404: LD_ADDR_VAR 0 3
33408: PUSH
33409: LD_VAR 0 6
33413: PUSH
33414: FOR_IN
33415: IFFALSE 33580
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33417: LD_VAR 0 3
33421: PPUSH
33422: CALL_OW 266
33426: PUSH
33427: LD_INT 6
33429: PUSH
33430: LD_INT 7
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: IN
33437: PUSH
33438: LD_VAR 0 3
33442: PPUSH
33443: CALL_OW 461
33447: PUSH
33448: LD_INT 1
33450: NONEQUAL
33451: AND
33452: IFFALSE 33578
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33454: LD_VAR 0 3
33458: PPUSH
33459: LD_EXP 112
33463: PUSH
33464: LD_VAR 0 2
33468: ARRAY
33469: PUSH
33470: LD_INT 1
33472: ARRAY
33473: PPUSH
33474: CALL 63890 0 2
33478: IFFALSE 33578
// begin ComCancel ( j ) ;
33480: LD_VAR 0 3
33484: PPUSH
33485: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33489: LD_VAR 0 3
33493: PPUSH
33494: LD_EXP 112
33498: PUSH
33499: LD_VAR 0 2
33503: ARRAY
33504: PUSH
33505: LD_INT 1
33507: ARRAY
33508: PPUSH
33509: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33513: LD_VAR 0 3
33517: PUSH
33518: LD_EXP 85
33522: PUSH
33523: LD_VAR 0 2
33527: ARRAY
33528: IN
33529: NOT
33530: IFFALSE 33576
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33532: LD_ADDR_EXP 85
33536: PUSH
33537: LD_EXP 85
33541: PPUSH
33542: LD_VAR 0 2
33546: PUSH
33547: LD_EXP 85
33551: PUSH
33552: LD_VAR 0 2
33556: ARRAY
33557: PUSH
33558: LD_INT 1
33560: PLUS
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PPUSH
33566: LD_VAR 0 3
33570: PPUSH
33571: CALL 57174 0 3
33575: ST_TO_ADDR
// break ;
33576: GO 33580
// end ; end ; end ;
33578: GO 33414
33580: POP
33581: POP
// end ;
33582: GO 33174
33584: POP
33585: POP
// end ;
33586: LD_VAR 0 1
33590: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33591: LD_INT 0
33593: PPUSH
33594: PPUSH
33595: PPUSH
33596: PPUSH
33597: PPUSH
33598: PPUSH
33599: PPUSH
33600: PPUSH
33601: PPUSH
// if not mc_bases then
33602: LD_EXP 78
33606: NOT
33607: IFFALSE 33611
// exit ;
33609: GO 34016
// for i = 1 to mc_bases do
33611: LD_ADDR_VAR 0 2
33615: PUSH
33616: DOUBLE
33617: LD_INT 1
33619: DEC
33620: ST_TO_ADDR
33621: LD_EXP 78
33625: PUSH
33626: FOR_TO
33627: IFFALSE 34014
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33629: LD_EXP 86
33633: PUSH
33634: LD_VAR 0 2
33638: ARRAY
33639: NOT
33640: PUSH
33641: LD_EXP 78
33645: PUSH
33646: LD_VAR 0 2
33650: ARRAY
33651: PPUSH
33652: LD_INT 30
33654: PUSH
33655: LD_INT 3
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: PPUSH
33662: CALL_OW 72
33666: NOT
33667: OR
33668: IFFALSE 33672
// continue ;
33670: GO 33626
// busy := false ;
33672: LD_ADDR_VAR 0 8
33676: PUSH
33677: LD_INT 0
33679: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33680: LD_ADDR_VAR 0 4
33684: PUSH
33685: LD_EXP 78
33689: PUSH
33690: LD_VAR 0 2
33694: ARRAY
33695: PPUSH
33696: LD_INT 30
33698: PUSH
33699: LD_INT 3
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PPUSH
33706: CALL_OW 72
33710: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33711: LD_ADDR_VAR 0 6
33715: PUSH
33716: LD_EXP 86
33720: PUSH
33721: LD_VAR 0 2
33725: ARRAY
33726: PPUSH
33727: LD_INT 2
33729: PUSH
33730: LD_INT 30
33732: PUSH
33733: LD_INT 32
33735: PUSH
33736: EMPTY
33737: LIST
33738: LIST
33739: PUSH
33740: LD_INT 30
33742: PUSH
33743: LD_INT 33
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: LIST
33754: PPUSH
33755: CALL_OW 72
33759: ST_TO_ADDR
// if not t then
33760: LD_VAR 0 6
33764: NOT
33765: IFFALSE 33769
// continue ;
33767: GO 33626
// for j in tmp do
33769: LD_ADDR_VAR 0 3
33773: PUSH
33774: LD_VAR 0 4
33778: PUSH
33779: FOR_IN
33780: IFFALSE 33810
// if not BuildingStatus ( j ) = bs_idle then
33782: LD_VAR 0 3
33786: PPUSH
33787: CALL_OW 461
33791: PUSH
33792: LD_INT 2
33794: EQUAL
33795: NOT
33796: IFFALSE 33808
// begin busy := true ;
33798: LD_ADDR_VAR 0 8
33802: PUSH
33803: LD_INT 1
33805: ST_TO_ADDR
// break ;
33806: GO 33810
// end ;
33808: GO 33779
33810: POP
33811: POP
// if busy then
33812: LD_VAR 0 8
33816: IFFALSE 33820
// continue ;
33818: GO 33626
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33820: LD_ADDR_VAR 0 7
33824: PUSH
33825: LD_VAR 0 6
33829: PPUSH
33830: LD_INT 35
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PPUSH
33840: CALL_OW 72
33844: ST_TO_ADDR
// if tw then
33845: LD_VAR 0 7
33849: IFFALSE 33926
// begin tw := tw [ 1 ] ;
33851: LD_ADDR_VAR 0 7
33855: PUSH
33856: LD_VAR 0 7
33860: PUSH
33861: LD_INT 1
33863: ARRAY
33864: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33865: LD_ADDR_VAR 0 9
33869: PUSH
33870: LD_VAR 0 7
33874: PPUSH
33875: LD_EXP 103
33879: PUSH
33880: LD_VAR 0 2
33884: ARRAY
33885: PPUSH
33886: CALL 62182 0 2
33890: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33891: LD_EXP 117
33895: PUSH
33896: LD_VAR 0 2
33900: ARRAY
33901: IFFALSE 33924
// if not weapon in mc_allowed_tower_weapons [ i ] then
33903: LD_VAR 0 9
33907: PUSH
33908: LD_EXP 117
33912: PUSH
33913: LD_VAR 0 2
33917: ARRAY
33918: IN
33919: NOT
33920: IFFALSE 33924
// continue ;
33922: GO 33626
// end else
33924: GO 33989
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33926: LD_ADDR_VAR 0 5
33930: PUSH
33931: LD_EXP 86
33935: PUSH
33936: LD_VAR 0 2
33940: ARRAY
33941: PPUSH
33942: LD_VAR 0 4
33946: PPUSH
33947: CALL 89052 0 2
33951: ST_TO_ADDR
// if not tmp2 then
33952: LD_VAR 0 5
33956: NOT
33957: IFFALSE 33961
// continue ;
33959: GO 33626
// tw := tmp2 [ 1 ] ;
33961: LD_ADDR_VAR 0 7
33965: PUSH
33966: LD_VAR 0 5
33970: PUSH
33971: LD_INT 1
33973: ARRAY
33974: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33975: LD_ADDR_VAR 0 9
33979: PUSH
33980: LD_VAR 0 5
33984: PUSH
33985: LD_INT 2
33987: ARRAY
33988: ST_TO_ADDR
// end ; if not weapon then
33989: LD_VAR 0 9
33993: NOT
33994: IFFALSE 33998
// continue ;
33996: GO 33626
// ComPlaceWeapon ( tw , weapon ) ;
33998: LD_VAR 0 7
34002: PPUSH
34003: LD_VAR 0 9
34007: PPUSH
34008: CALL_OW 148
// end ;
34012: GO 33626
34014: POP
34015: POP
// end ;
34016: LD_VAR 0 1
34020: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
34021: LD_INT 0
34023: PPUSH
34024: PPUSH
34025: PPUSH
34026: PPUSH
34027: PPUSH
34028: PPUSH
34029: PPUSH
// if not mc_bases then
34030: LD_EXP 78
34034: NOT
34035: IFFALSE 34039
// exit ;
34037: GO 34814
// for i = 1 to mc_bases do
34039: LD_ADDR_VAR 0 2
34043: PUSH
34044: DOUBLE
34045: LD_INT 1
34047: DEC
34048: ST_TO_ADDR
34049: LD_EXP 78
34053: PUSH
34054: FOR_TO
34055: IFFALSE 34812
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
34057: LD_EXP 91
34061: PUSH
34062: LD_VAR 0 2
34066: ARRAY
34067: NOT
34068: PUSH
34069: LD_EXP 91
34073: PUSH
34074: LD_VAR 0 2
34078: ARRAY
34079: PUSH
34080: LD_EXP 92
34084: PUSH
34085: LD_VAR 0 2
34089: ARRAY
34090: EQUAL
34091: OR
34092: PUSH
34093: LD_EXP 101
34097: PUSH
34098: LD_VAR 0 2
34102: ARRAY
34103: OR
34104: IFFALSE 34108
// continue ;
34106: GO 34054
// if mc_miners [ i ] then
34108: LD_EXP 92
34112: PUSH
34113: LD_VAR 0 2
34117: ARRAY
34118: IFFALSE 34499
// begin for j = mc_miners [ i ] downto 1 do
34120: LD_ADDR_VAR 0 3
34124: PUSH
34125: DOUBLE
34126: LD_EXP 92
34130: PUSH
34131: LD_VAR 0 2
34135: ARRAY
34136: INC
34137: ST_TO_ADDR
34138: LD_INT 1
34140: PUSH
34141: FOR_DOWNTO
34142: IFFALSE 34497
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
34144: LD_EXP 92
34148: PUSH
34149: LD_VAR 0 2
34153: ARRAY
34154: PUSH
34155: LD_VAR 0 3
34159: ARRAY
34160: PPUSH
34161: CALL_OW 301
34165: PUSH
34166: LD_EXP 92
34170: PUSH
34171: LD_VAR 0 2
34175: ARRAY
34176: PUSH
34177: LD_VAR 0 3
34181: ARRAY
34182: PPUSH
34183: CALL_OW 257
34187: PUSH
34188: LD_INT 1
34190: NONEQUAL
34191: OR
34192: IFFALSE 34255
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34194: LD_ADDR_VAR 0 5
34198: PUSH
34199: LD_EXP 92
34203: PUSH
34204: LD_VAR 0 2
34208: ARRAY
34209: PUSH
34210: LD_EXP 92
34214: PUSH
34215: LD_VAR 0 2
34219: ARRAY
34220: PUSH
34221: LD_VAR 0 3
34225: ARRAY
34226: DIFF
34227: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34228: LD_ADDR_EXP 92
34232: PUSH
34233: LD_EXP 92
34237: PPUSH
34238: LD_VAR 0 2
34242: PPUSH
34243: LD_VAR 0 5
34247: PPUSH
34248: CALL_OW 1
34252: ST_TO_ADDR
// continue ;
34253: GO 34141
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34255: LD_EXP 92
34259: PUSH
34260: LD_VAR 0 2
34264: ARRAY
34265: PUSH
34266: LD_VAR 0 3
34270: ARRAY
34271: PPUSH
34272: CALL_OW 257
34276: PUSH
34277: LD_INT 1
34279: EQUAL
34280: PUSH
34281: LD_EXP 92
34285: PUSH
34286: LD_VAR 0 2
34290: ARRAY
34291: PUSH
34292: LD_VAR 0 3
34296: ARRAY
34297: PPUSH
34298: CALL_OW 459
34302: NOT
34303: AND
34304: PUSH
34305: LD_EXP 92
34309: PUSH
34310: LD_VAR 0 2
34314: ARRAY
34315: PUSH
34316: LD_VAR 0 3
34320: ARRAY
34321: PPUSH
34322: CALL_OW 314
34326: NOT
34327: AND
34328: IFFALSE 34495
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34330: LD_EXP 92
34334: PUSH
34335: LD_VAR 0 2
34339: ARRAY
34340: PUSH
34341: LD_VAR 0 3
34345: ARRAY
34346: PPUSH
34347: CALL_OW 310
34351: IFFALSE 34374
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34353: LD_EXP 92
34357: PUSH
34358: LD_VAR 0 2
34362: ARRAY
34363: PUSH
34364: LD_VAR 0 3
34368: ARRAY
34369: PPUSH
34370: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34374: LD_EXP 92
34378: PUSH
34379: LD_VAR 0 2
34383: ARRAY
34384: PUSH
34385: LD_VAR 0 3
34389: ARRAY
34390: PPUSH
34391: CALL_OW 314
34395: NOT
34396: IFFALSE 34495
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
34398: LD_ADDR_VAR 0 7
34402: PUSH
34403: LD_VAR 0 3
34407: PUSH
34408: LD_EXP 91
34412: PUSH
34413: LD_VAR 0 2
34417: ARRAY
34418: PPUSH
34419: CALL 54314 0 1
34423: MOD
34424: PUSH
34425: LD_INT 1
34427: PLUS
34428: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34429: LD_EXP 92
34433: PUSH
34434: LD_VAR 0 2
34438: ARRAY
34439: PUSH
34440: LD_VAR 0 3
34444: ARRAY
34445: PPUSH
34446: LD_EXP 91
34450: PUSH
34451: LD_VAR 0 2
34455: ARRAY
34456: PUSH
34457: LD_VAR 0 7
34461: ARRAY
34462: PUSH
34463: LD_INT 1
34465: ARRAY
34466: PPUSH
34467: LD_EXP 91
34471: PUSH
34472: LD_VAR 0 2
34476: ARRAY
34477: PUSH
34478: LD_VAR 0 7
34482: ARRAY
34483: PUSH
34484: LD_INT 2
34486: ARRAY
34487: PPUSH
34488: LD_INT 0
34490: PPUSH
34491: CALL_OW 193
// end ; end ; end ;
34495: GO 34141
34497: POP
34498: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34499: LD_ADDR_VAR 0 5
34503: PUSH
34504: LD_EXP 78
34508: PUSH
34509: LD_VAR 0 2
34513: ARRAY
34514: PPUSH
34515: LD_INT 2
34517: PUSH
34518: LD_INT 30
34520: PUSH
34521: LD_INT 4
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 30
34530: PUSH
34531: LD_INT 5
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 30
34540: PUSH
34541: LD_INT 32
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: PPUSH
34554: CALL_OW 72
34558: ST_TO_ADDR
// if not tmp then
34559: LD_VAR 0 5
34563: NOT
34564: IFFALSE 34568
// continue ;
34566: GO 34054
// list := [ ] ;
34568: LD_ADDR_VAR 0 6
34572: PUSH
34573: EMPTY
34574: ST_TO_ADDR
// for j in tmp do
34575: LD_ADDR_VAR 0 3
34579: PUSH
34580: LD_VAR 0 5
34584: PUSH
34585: FOR_IN
34586: IFFALSE 34655
// begin for k in UnitsInside ( j ) do
34588: LD_ADDR_VAR 0 4
34592: PUSH
34593: LD_VAR 0 3
34597: PPUSH
34598: CALL_OW 313
34602: PUSH
34603: FOR_IN
34604: IFFALSE 34651
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34606: LD_VAR 0 4
34610: PPUSH
34611: CALL_OW 257
34615: PUSH
34616: LD_INT 1
34618: EQUAL
34619: PUSH
34620: LD_VAR 0 4
34624: PPUSH
34625: CALL_OW 459
34629: NOT
34630: AND
34631: IFFALSE 34649
// list := list ^ k ;
34633: LD_ADDR_VAR 0 6
34637: PUSH
34638: LD_VAR 0 6
34642: PUSH
34643: LD_VAR 0 4
34647: ADD
34648: ST_TO_ADDR
34649: GO 34603
34651: POP
34652: POP
// end ;
34653: GO 34585
34655: POP
34656: POP
// list := list diff mc_miners [ i ] ;
34657: LD_ADDR_VAR 0 6
34661: PUSH
34662: LD_VAR 0 6
34666: PUSH
34667: LD_EXP 92
34671: PUSH
34672: LD_VAR 0 2
34676: ARRAY
34677: DIFF
34678: ST_TO_ADDR
// if not list then
34679: LD_VAR 0 6
34683: NOT
34684: IFFALSE 34688
// continue ;
34686: GO 34054
// k := mc_mines [ i ] - mc_miners [ i ] ;
34688: LD_ADDR_VAR 0 4
34692: PUSH
34693: LD_EXP 91
34697: PUSH
34698: LD_VAR 0 2
34702: ARRAY
34703: PUSH
34704: LD_EXP 92
34708: PUSH
34709: LD_VAR 0 2
34713: ARRAY
34714: MINUS
34715: ST_TO_ADDR
// if k > list then
34716: LD_VAR 0 4
34720: PUSH
34721: LD_VAR 0 6
34725: GREATER
34726: IFFALSE 34738
// k := list ;
34728: LD_ADDR_VAR 0 4
34732: PUSH
34733: LD_VAR 0 6
34737: ST_TO_ADDR
// for j = 1 to k do
34738: LD_ADDR_VAR 0 3
34742: PUSH
34743: DOUBLE
34744: LD_INT 1
34746: DEC
34747: ST_TO_ADDR
34748: LD_VAR 0 4
34752: PUSH
34753: FOR_TO
34754: IFFALSE 34808
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34756: LD_ADDR_EXP 92
34760: PUSH
34761: LD_EXP 92
34765: PPUSH
34766: LD_VAR 0 2
34770: PUSH
34771: LD_EXP 92
34775: PUSH
34776: LD_VAR 0 2
34780: ARRAY
34781: PUSH
34782: LD_INT 1
34784: PLUS
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PPUSH
34790: LD_VAR 0 6
34794: PUSH
34795: LD_VAR 0 3
34799: ARRAY
34800: PPUSH
34801: CALL 57174 0 3
34805: ST_TO_ADDR
34806: GO 34753
34808: POP
34809: POP
// end ;
34810: GO 34054
34812: POP
34813: POP
// end ;
34814: LD_VAR 0 1
34818: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34819: LD_INT 0
34821: PPUSH
34822: PPUSH
34823: PPUSH
34824: PPUSH
34825: PPUSH
34826: PPUSH
34827: PPUSH
34828: PPUSH
34829: PPUSH
34830: PPUSH
34831: PPUSH
// if not mc_bases then
34832: LD_EXP 78
34836: NOT
34837: IFFALSE 34841
// exit ;
34839: GO 36664
// for i = 1 to mc_bases do
34841: LD_ADDR_VAR 0 2
34845: PUSH
34846: DOUBLE
34847: LD_INT 1
34849: DEC
34850: ST_TO_ADDR
34851: LD_EXP 78
34855: PUSH
34856: FOR_TO
34857: IFFALSE 36662
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34859: LD_EXP 78
34863: PUSH
34864: LD_VAR 0 2
34868: ARRAY
34869: NOT
34870: PUSH
34871: LD_EXP 85
34875: PUSH
34876: LD_VAR 0 2
34880: ARRAY
34881: OR
34882: IFFALSE 34886
// continue ;
34884: GO 34856
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34886: LD_EXP 94
34890: PUSH
34891: LD_VAR 0 2
34895: ARRAY
34896: NOT
34897: PUSH
34898: LD_EXP 95
34902: PUSH
34903: LD_VAR 0 2
34907: ARRAY
34908: AND
34909: IFFALSE 34947
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34911: LD_ADDR_EXP 95
34915: PUSH
34916: LD_EXP 95
34920: PPUSH
34921: LD_VAR 0 2
34925: PPUSH
34926: EMPTY
34927: PPUSH
34928: CALL_OW 1
34932: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34933: LD_VAR 0 2
34937: PPUSH
34938: LD_INT 107
34940: PPUSH
34941: CALL 25687 0 2
// continue ;
34945: GO 34856
// end ; target := [ ] ;
34947: LD_ADDR_VAR 0 7
34951: PUSH
34952: EMPTY
34953: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34954: LD_ADDR_VAR 0 6
34958: PUSH
34959: LD_EXP 78
34963: PUSH
34964: LD_VAR 0 2
34968: ARRAY
34969: PUSH
34970: LD_INT 1
34972: ARRAY
34973: PPUSH
34974: CALL_OW 255
34978: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34979: LD_ADDR_VAR 0 9
34983: PUSH
34984: LD_EXP 78
34988: PUSH
34989: LD_VAR 0 2
34993: ARRAY
34994: PPUSH
34995: LD_INT 2
34997: PUSH
34998: LD_INT 30
35000: PUSH
35001: LD_INT 0
35003: PUSH
35004: EMPTY
35005: LIST
35006: LIST
35007: PUSH
35008: LD_INT 30
35010: PUSH
35011: LD_INT 1
35013: PUSH
35014: EMPTY
35015: LIST
35016: LIST
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: LIST
35022: PPUSH
35023: CALL_OW 72
35027: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
35028: LD_ADDR_VAR 0 3
35032: PUSH
35033: DOUBLE
35034: LD_EXP 94
35038: PUSH
35039: LD_VAR 0 2
35043: ARRAY
35044: INC
35045: ST_TO_ADDR
35046: LD_INT 1
35048: PUSH
35049: FOR_DOWNTO
35050: IFFALSE 35295
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
35052: LD_EXP 94
35056: PUSH
35057: LD_VAR 0 2
35061: ARRAY
35062: PUSH
35063: LD_VAR 0 3
35067: ARRAY
35068: PUSH
35069: LD_INT 2
35071: ARRAY
35072: PPUSH
35073: LD_EXP 94
35077: PUSH
35078: LD_VAR 0 2
35082: ARRAY
35083: PUSH
35084: LD_VAR 0 3
35088: ARRAY
35089: PUSH
35090: LD_INT 3
35092: ARRAY
35093: PPUSH
35094: CALL_OW 488
35098: PUSH
35099: LD_EXP 94
35103: PUSH
35104: LD_VAR 0 2
35108: ARRAY
35109: PUSH
35110: LD_VAR 0 3
35114: ARRAY
35115: PUSH
35116: LD_INT 2
35118: ARRAY
35119: PPUSH
35120: LD_EXP 94
35124: PUSH
35125: LD_VAR 0 2
35129: ARRAY
35130: PUSH
35131: LD_VAR 0 3
35135: ARRAY
35136: PUSH
35137: LD_INT 3
35139: ARRAY
35140: PPUSH
35141: CALL_OW 284
35145: PUSH
35146: LD_INT 0
35148: EQUAL
35149: AND
35150: IFFALSE 35205
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
35152: LD_ADDR_VAR 0 5
35156: PUSH
35157: LD_EXP 94
35161: PUSH
35162: LD_VAR 0 2
35166: ARRAY
35167: PPUSH
35168: LD_VAR 0 3
35172: PPUSH
35173: CALL_OW 3
35177: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35178: LD_ADDR_EXP 94
35182: PUSH
35183: LD_EXP 94
35187: PPUSH
35188: LD_VAR 0 2
35192: PPUSH
35193: LD_VAR 0 5
35197: PPUSH
35198: CALL_OW 1
35202: ST_TO_ADDR
// continue ;
35203: GO 35049
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35205: LD_VAR 0 6
35209: PPUSH
35210: LD_EXP 94
35214: PUSH
35215: LD_VAR 0 2
35219: ARRAY
35220: PUSH
35221: LD_VAR 0 3
35225: ARRAY
35226: PUSH
35227: LD_INT 2
35229: ARRAY
35230: PPUSH
35231: LD_EXP 94
35235: PUSH
35236: LD_VAR 0 2
35240: ARRAY
35241: PUSH
35242: LD_VAR 0 3
35246: ARRAY
35247: PUSH
35248: LD_INT 3
35250: ARRAY
35251: PPUSH
35252: LD_INT 30
35254: PPUSH
35255: CALL 58070 0 4
35259: PUSH
35260: LD_INT 4
35262: ARRAY
35263: PUSH
35264: LD_INT 0
35266: EQUAL
35267: IFFALSE 35293
// begin target := mc_crates [ i ] [ j ] ;
35269: LD_ADDR_VAR 0 7
35273: PUSH
35274: LD_EXP 94
35278: PUSH
35279: LD_VAR 0 2
35283: ARRAY
35284: PUSH
35285: LD_VAR 0 3
35289: ARRAY
35290: ST_TO_ADDR
// break ;
35291: GO 35295
// end ; end ;
35293: GO 35049
35295: POP
35296: POP
// if not target then
35297: LD_VAR 0 7
35301: NOT
35302: IFFALSE 35306
// continue ;
35304: GO 34856
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35306: LD_ADDR_VAR 0 8
35310: PUSH
35311: LD_EXP 97
35315: PUSH
35316: LD_VAR 0 2
35320: ARRAY
35321: PPUSH
35322: LD_INT 2
35324: PUSH
35325: LD_INT 3
35327: PUSH
35328: LD_INT 58
35330: PUSH
35331: EMPTY
35332: LIST
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 61
35340: PUSH
35341: EMPTY
35342: LIST
35343: PUSH
35344: LD_INT 33
35346: PUSH
35347: LD_INT 5
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 33
35356: PUSH
35357: LD_INT 3
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: LIST
35368: LIST
35369: LIST
35370: PUSH
35371: LD_INT 2
35373: PUSH
35374: LD_INT 34
35376: PUSH
35377: LD_INT 32
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 34
35386: PUSH
35387: LD_INT 51
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 34
35396: PUSH
35397: LD_INT 12
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PPUSH
35414: CALL_OW 72
35418: ST_TO_ADDR
// if not cargo then
35419: LD_VAR 0 8
35423: NOT
35424: IFFALSE 36130
// begin if mc_crates_collector [ i ] < 5 then
35426: LD_EXP 95
35430: PUSH
35431: LD_VAR 0 2
35435: ARRAY
35436: PUSH
35437: LD_INT 5
35439: LESS
35440: IFFALSE 35806
// begin if mc_ape [ i ] then
35442: LD_EXP 107
35446: PUSH
35447: LD_VAR 0 2
35451: ARRAY
35452: IFFALSE 35499
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35454: LD_ADDR_VAR 0 5
35458: PUSH
35459: LD_EXP 107
35463: PUSH
35464: LD_VAR 0 2
35468: ARRAY
35469: PPUSH
35470: LD_INT 25
35472: PUSH
35473: LD_INT 16
35475: PUSH
35476: EMPTY
35477: LIST
35478: LIST
35479: PUSH
35480: LD_INT 24
35482: PUSH
35483: LD_INT 750
35485: PUSH
35486: EMPTY
35487: LIST
35488: LIST
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PPUSH
35494: CALL_OW 72
35498: ST_TO_ADDR
// if not tmp then
35499: LD_VAR 0 5
35503: NOT
35504: IFFALSE 35551
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35506: LD_ADDR_VAR 0 5
35510: PUSH
35511: LD_EXP 78
35515: PUSH
35516: LD_VAR 0 2
35520: ARRAY
35521: PPUSH
35522: LD_INT 25
35524: PUSH
35525: LD_INT 2
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 24
35534: PUSH
35535: LD_INT 750
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: EMPTY
35543: LIST
35544: LIST
35545: PPUSH
35546: CALL_OW 72
35550: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35551: LD_EXP 107
35555: PUSH
35556: LD_VAR 0 2
35560: ARRAY
35561: PUSH
35562: LD_EXP 78
35566: PUSH
35567: LD_VAR 0 2
35571: ARRAY
35572: PPUSH
35573: LD_INT 25
35575: PUSH
35576: LD_INT 2
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 24
35585: PUSH
35586: LD_INT 750
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PPUSH
35597: CALL_OW 72
35601: AND
35602: PUSH
35603: LD_VAR 0 5
35607: PUSH
35608: LD_INT 5
35610: LESS
35611: AND
35612: IFFALSE 35694
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35614: LD_ADDR_VAR 0 3
35618: PUSH
35619: LD_EXP 78
35623: PUSH
35624: LD_VAR 0 2
35628: ARRAY
35629: PPUSH
35630: LD_INT 25
35632: PUSH
35633: LD_INT 2
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 24
35642: PUSH
35643: LD_INT 750
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PPUSH
35654: CALL_OW 72
35658: PUSH
35659: FOR_IN
35660: IFFALSE 35692
// begin tmp := tmp union j ;
35662: LD_ADDR_VAR 0 5
35666: PUSH
35667: LD_VAR 0 5
35671: PUSH
35672: LD_VAR 0 3
35676: UNION
35677: ST_TO_ADDR
// if tmp >= 5 then
35678: LD_VAR 0 5
35682: PUSH
35683: LD_INT 5
35685: GREATEREQUAL
35686: IFFALSE 35690
// break ;
35688: GO 35692
// end ;
35690: GO 35659
35692: POP
35693: POP
// end ; if not tmp then
35694: LD_VAR 0 5
35698: NOT
35699: IFFALSE 35703
// continue ;
35701: GO 34856
// for j in tmp do
35703: LD_ADDR_VAR 0 3
35707: PUSH
35708: LD_VAR 0 5
35712: PUSH
35713: FOR_IN
35714: IFFALSE 35804
// if not GetTag ( j ) then
35716: LD_VAR 0 3
35720: PPUSH
35721: CALL_OW 110
35725: NOT
35726: IFFALSE 35802
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35728: LD_ADDR_EXP 95
35732: PUSH
35733: LD_EXP 95
35737: PPUSH
35738: LD_VAR 0 2
35742: PUSH
35743: LD_EXP 95
35747: PUSH
35748: LD_VAR 0 2
35752: ARRAY
35753: PUSH
35754: LD_INT 1
35756: PLUS
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PPUSH
35762: LD_VAR 0 3
35766: PPUSH
35767: CALL 57174 0 3
35771: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35772: LD_VAR 0 3
35776: PPUSH
35777: LD_INT 107
35779: PPUSH
35780: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35784: LD_EXP 95
35788: PUSH
35789: LD_VAR 0 2
35793: ARRAY
35794: PUSH
35795: LD_INT 5
35797: GREATEREQUAL
35798: IFFALSE 35802
// break ;
35800: GO 35804
// end ;
35802: GO 35713
35804: POP
35805: POP
// end ; if mc_crates_collector [ i ] and target then
35806: LD_EXP 95
35810: PUSH
35811: LD_VAR 0 2
35815: ARRAY
35816: PUSH
35817: LD_VAR 0 7
35821: AND
35822: IFFALSE 36128
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35824: LD_EXP 95
35828: PUSH
35829: LD_VAR 0 2
35833: ARRAY
35834: PUSH
35835: LD_VAR 0 7
35839: PUSH
35840: LD_INT 1
35842: ARRAY
35843: LESS
35844: IFFALSE 35864
// tmp := mc_crates_collector [ i ] else
35846: LD_ADDR_VAR 0 5
35850: PUSH
35851: LD_EXP 95
35855: PUSH
35856: LD_VAR 0 2
35860: ARRAY
35861: ST_TO_ADDR
35862: GO 35878
// tmp := target [ 1 ] ;
35864: LD_ADDR_VAR 0 5
35868: PUSH
35869: LD_VAR 0 7
35873: PUSH
35874: LD_INT 1
35876: ARRAY
35877: ST_TO_ADDR
// k := 0 ;
35878: LD_ADDR_VAR 0 4
35882: PUSH
35883: LD_INT 0
35885: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35886: LD_ADDR_VAR 0 3
35890: PUSH
35891: LD_EXP 95
35895: PUSH
35896: LD_VAR 0 2
35900: ARRAY
35901: PUSH
35902: FOR_IN
35903: IFFALSE 36126
// begin k := k + 1 ;
35905: LD_ADDR_VAR 0 4
35909: PUSH
35910: LD_VAR 0 4
35914: PUSH
35915: LD_INT 1
35917: PLUS
35918: ST_TO_ADDR
// if k > tmp then
35919: LD_VAR 0 4
35923: PUSH
35924: LD_VAR 0 5
35928: GREATER
35929: IFFALSE 35933
// break ;
35931: GO 36126
// if not GetClass ( j ) in [ 2 , 16 ] then
35933: LD_VAR 0 3
35937: PPUSH
35938: CALL_OW 257
35942: PUSH
35943: LD_INT 2
35945: PUSH
35946: LD_INT 16
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: IN
35953: NOT
35954: IFFALSE 36007
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35956: LD_ADDR_EXP 95
35960: PUSH
35961: LD_EXP 95
35965: PPUSH
35966: LD_VAR 0 2
35970: PPUSH
35971: LD_EXP 95
35975: PUSH
35976: LD_VAR 0 2
35980: ARRAY
35981: PUSH
35982: LD_VAR 0 3
35986: DIFF
35987: PPUSH
35988: CALL_OW 1
35992: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35993: LD_VAR 0 3
35997: PPUSH
35998: LD_INT 0
36000: PPUSH
36001: CALL_OW 109
// continue ;
36005: GO 35902
// end ; if IsInUnit ( j ) then
36007: LD_VAR 0 3
36011: PPUSH
36012: CALL_OW 310
36016: IFFALSE 36027
// ComExitBuilding ( j ) ;
36018: LD_VAR 0 3
36022: PPUSH
36023: CALL_OW 122
// wait ( 3 ) ;
36027: LD_INT 3
36029: PPUSH
36030: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
36034: LD_VAR 0 3
36038: PPUSH
36039: CALL_OW 314
36043: PUSH
36044: LD_VAR 0 6
36048: PPUSH
36049: LD_VAR 0 7
36053: PUSH
36054: LD_INT 2
36056: ARRAY
36057: PPUSH
36058: LD_VAR 0 7
36062: PUSH
36063: LD_INT 3
36065: ARRAY
36066: PPUSH
36067: LD_INT 30
36069: PPUSH
36070: CALL 58070 0 4
36074: PUSH
36075: LD_INT 4
36077: ARRAY
36078: AND
36079: IFFALSE 36097
// ComStandNearbyBuilding ( j , depot ) else
36081: LD_VAR 0 3
36085: PPUSH
36086: LD_VAR 0 9
36090: PPUSH
36091: CALL 53776 0 2
36095: GO 36124
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36097: LD_VAR 0 3
36101: PPUSH
36102: LD_VAR 0 7
36106: PUSH
36107: LD_INT 2
36109: ARRAY
36110: PPUSH
36111: LD_VAR 0 7
36115: PUSH
36116: LD_INT 3
36118: ARRAY
36119: PPUSH
36120: CALL_OW 117
// end ;
36124: GO 35902
36126: POP
36127: POP
// end ; end else
36128: GO 36660
// begin for j in cargo do
36130: LD_ADDR_VAR 0 3
36134: PUSH
36135: LD_VAR 0 8
36139: PUSH
36140: FOR_IN
36141: IFFALSE 36658
// begin if GetTag ( j ) <> 0 then
36143: LD_VAR 0 3
36147: PPUSH
36148: CALL_OW 110
36152: PUSH
36153: LD_INT 0
36155: NONEQUAL
36156: IFFALSE 36160
// continue ;
36158: GO 36140
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
36160: LD_VAR 0 3
36164: PPUSH
36165: CALL_OW 256
36169: PUSH
36170: LD_INT 1000
36172: LESS
36173: PUSH
36174: LD_VAR 0 3
36178: PPUSH
36179: LD_EXP 102
36183: PUSH
36184: LD_VAR 0 2
36188: ARRAY
36189: PPUSH
36190: CALL_OW 308
36194: NOT
36195: AND
36196: IFFALSE 36218
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36198: LD_VAR 0 3
36202: PPUSH
36203: LD_EXP 102
36207: PUSH
36208: LD_VAR 0 2
36212: ARRAY
36213: PPUSH
36214: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36218: LD_VAR 0 3
36222: PPUSH
36223: CALL_OW 256
36227: PUSH
36228: LD_INT 1000
36230: LESS
36231: PUSH
36232: LD_VAR 0 3
36236: PPUSH
36237: LD_EXP 102
36241: PUSH
36242: LD_VAR 0 2
36246: ARRAY
36247: PPUSH
36248: CALL_OW 308
36252: AND
36253: IFFALSE 36257
// continue ;
36255: GO 36140
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36257: LD_VAR 0 3
36261: PPUSH
36262: CALL_OW 262
36266: PUSH
36267: LD_INT 2
36269: EQUAL
36270: PUSH
36271: LD_VAR 0 3
36275: PPUSH
36276: CALL_OW 261
36280: PUSH
36281: LD_INT 15
36283: LESS
36284: AND
36285: IFFALSE 36289
// continue ;
36287: GO 36140
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36289: LD_VAR 0 3
36293: PPUSH
36294: CALL_OW 262
36298: PUSH
36299: LD_INT 1
36301: EQUAL
36302: PUSH
36303: LD_VAR 0 3
36307: PPUSH
36308: CALL_OW 261
36312: PUSH
36313: LD_INT 10
36315: LESS
36316: AND
36317: IFFALSE 36597
// begin if not depot then
36319: LD_VAR 0 9
36323: NOT
36324: IFFALSE 36328
// continue ;
36326: GO 36140
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36328: LD_VAR 0 3
36332: PPUSH
36333: LD_VAR 0 9
36337: PPUSH
36338: LD_VAR 0 3
36342: PPUSH
36343: CALL_OW 74
36347: PPUSH
36348: CALL_OW 296
36352: PUSH
36353: LD_INT 6
36355: LESS
36356: IFFALSE 36372
// SetFuel ( j , 100 ) else
36358: LD_VAR 0 3
36362: PPUSH
36363: LD_INT 100
36365: PPUSH
36366: CALL_OW 240
36370: GO 36597
// if GetFuel ( j ) = 0 then
36372: LD_VAR 0 3
36376: PPUSH
36377: CALL_OW 261
36381: PUSH
36382: LD_INT 0
36384: EQUAL
36385: IFFALSE 36597
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36387: LD_ADDR_EXP 97
36391: PUSH
36392: LD_EXP 97
36396: PPUSH
36397: LD_VAR 0 2
36401: PPUSH
36402: LD_EXP 97
36406: PUSH
36407: LD_VAR 0 2
36411: ARRAY
36412: PUSH
36413: LD_VAR 0 3
36417: DIFF
36418: PPUSH
36419: CALL_OW 1
36423: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36424: LD_VAR 0 3
36428: PPUSH
36429: CALL_OW 263
36433: PUSH
36434: LD_INT 1
36436: EQUAL
36437: IFFALSE 36453
// ComExitVehicle ( IsInUnit ( j ) ) ;
36439: LD_VAR 0 3
36443: PPUSH
36444: CALL_OW 310
36448: PPUSH
36449: CALL_OW 121
// if GetControl ( j ) = control_remote then
36453: LD_VAR 0 3
36457: PPUSH
36458: CALL_OW 263
36462: PUSH
36463: LD_INT 2
36465: EQUAL
36466: IFFALSE 36477
// ComUnlink ( j ) ;
36468: LD_VAR 0 3
36472: PPUSH
36473: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36477: LD_ADDR_VAR 0 10
36481: PUSH
36482: LD_VAR 0 2
36486: PPUSH
36487: LD_INT 3
36489: PPUSH
36490: CALL 46241 0 2
36494: ST_TO_ADDR
// if fac then
36495: LD_VAR 0 10
36499: IFFALSE 36595
// begin for k in fac do
36501: LD_ADDR_VAR 0 4
36505: PUSH
36506: LD_VAR 0 10
36510: PUSH
36511: FOR_IN
36512: IFFALSE 36593
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36514: LD_ADDR_VAR 0 11
36518: PUSH
36519: LD_VAR 0 10
36523: PPUSH
36524: LD_VAR 0 3
36528: PPUSH
36529: CALL_OW 265
36533: PPUSH
36534: LD_VAR 0 3
36538: PPUSH
36539: CALL_OW 262
36543: PPUSH
36544: LD_VAR 0 3
36548: PPUSH
36549: CALL_OW 263
36553: PPUSH
36554: LD_VAR 0 3
36558: PPUSH
36559: CALL_OW 264
36563: PPUSH
36564: CALL 54672 0 5
36568: ST_TO_ADDR
// if components then
36569: LD_VAR 0 11
36573: IFFALSE 36591
// begin MC_InsertProduceList ( i , components ) ;
36575: LD_VAR 0 2
36579: PPUSH
36580: LD_VAR 0 11
36584: PPUSH
36585: CALL 45786 0 2
// break ;
36589: GO 36593
// end ; end ;
36591: GO 36511
36593: POP
36594: POP
// end ; continue ;
36595: GO 36140
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36597: LD_VAR 0 3
36601: PPUSH
36602: LD_INT 1
36604: PPUSH
36605: CALL_OW 289
36609: PUSH
36610: LD_INT 100
36612: LESS
36613: PUSH
36614: LD_VAR 0 3
36618: PPUSH
36619: CALL_OW 314
36623: NOT
36624: AND
36625: IFFALSE 36654
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36627: LD_VAR 0 3
36631: PPUSH
36632: LD_VAR 0 7
36636: PUSH
36637: LD_INT 2
36639: ARRAY
36640: PPUSH
36641: LD_VAR 0 7
36645: PUSH
36646: LD_INT 3
36648: ARRAY
36649: PPUSH
36650: CALL_OW 117
// break ;
36654: GO 36658
// end ;
36656: GO 36140
36658: POP
36659: POP
// end ; end ;
36660: GO 34856
36662: POP
36663: POP
// end ;
36664: LD_VAR 0 1
36668: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36669: LD_INT 0
36671: PPUSH
36672: PPUSH
36673: PPUSH
36674: PPUSH
// if not mc_bases then
36675: LD_EXP 78
36679: NOT
36680: IFFALSE 36684
// exit ;
36682: GO 36845
// for i = 1 to mc_bases do
36684: LD_ADDR_VAR 0 2
36688: PUSH
36689: DOUBLE
36690: LD_INT 1
36692: DEC
36693: ST_TO_ADDR
36694: LD_EXP 78
36698: PUSH
36699: FOR_TO
36700: IFFALSE 36843
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36702: LD_ADDR_VAR 0 4
36706: PUSH
36707: LD_EXP 97
36711: PUSH
36712: LD_VAR 0 2
36716: ARRAY
36717: PUSH
36718: LD_EXP 100
36722: PUSH
36723: LD_VAR 0 2
36727: ARRAY
36728: UNION
36729: PPUSH
36730: LD_INT 33
36732: PUSH
36733: LD_INT 2
36735: PUSH
36736: EMPTY
36737: LIST
36738: LIST
36739: PPUSH
36740: CALL_OW 72
36744: ST_TO_ADDR
// if tmp then
36745: LD_VAR 0 4
36749: IFFALSE 36841
// for j in tmp do
36751: LD_ADDR_VAR 0 3
36755: PUSH
36756: LD_VAR 0 4
36760: PUSH
36761: FOR_IN
36762: IFFALSE 36839
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36764: LD_VAR 0 3
36768: PPUSH
36769: CALL_OW 312
36773: NOT
36774: PUSH
36775: LD_VAR 0 3
36779: PPUSH
36780: CALL_OW 256
36784: PUSH
36785: LD_INT 250
36787: GREATEREQUAL
36788: AND
36789: IFFALSE 36802
// Connect ( j ) else
36791: LD_VAR 0 3
36795: PPUSH
36796: CALL 60143 0 1
36800: GO 36837
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36802: LD_VAR 0 3
36806: PPUSH
36807: CALL_OW 256
36811: PUSH
36812: LD_INT 250
36814: LESS
36815: PUSH
36816: LD_VAR 0 3
36820: PPUSH
36821: CALL_OW 312
36825: AND
36826: IFFALSE 36837
// ComUnlink ( j ) ;
36828: LD_VAR 0 3
36832: PPUSH
36833: CALL_OW 136
36837: GO 36761
36839: POP
36840: POP
// end ;
36841: GO 36699
36843: POP
36844: POP
// end ;
36845: LD_VAR 0 1
36849: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36850: LD_INT 0
36852: PPUSH
36853: PPUSH
36854: PPUSH
36855: PPUSH
36856: PPUSH
// if not mc_bases then
36857: LD_EXP 78
36861: NOT
36862: IFFALSE 36866
// exit ;
36864: GO 37311
// for i = 1 to mc_bases do
36866: LD_ADDR_VAR 0 2
36870: PUSH
36871: DOUBLE
36872: LD_INT 1
36874: DEC
36875: ST_TO_ADDR
36876: LD_EXP 78
36880: PUSH
36881: FOR_TO
36882: IFFALSE 37309
// begin if not mc_produce [ i ] then
36884: LD_EXP 99
36888: PUSH
36889: LD_VAR 0 2
36893: ARRAY
36894: NOT
36895: IFFALSE 36899
// continue ;
36897: GO 36881
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36899: LD_ADDR_VAR 0 5
36903: PUSH
36904: LD_EXP 78
36908: PUSH
36909: LD_VAR 0 2
36913: ARRAY
36914: PPUSH
36915: LD_INT 30
36917: PUSH
36918: LD_INT 3
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PPUSH
36925: CALL_OW 72
36929: ST_TO_ADDR
// if not fac then
36930: LD_VAR 0 5
36934: NOT
36935: IFFALSE 36939
// continue ;
36937: GO 36881
// for j in fac do
36939: LD_ADDR_VAR 0 3
36943: PUSH
36944: LD_VAR 0 5
36948: PUSH
36949: FOR_IN
36950: IFFALSE 37305
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36952: LD_VAR 0 3
36956: PPUSH
36957: CALL_OW 461
36961: PUSH
36962: LD_INT 2
36964: NONEQUAL
36965: PUSH
36966: LD_VAR 0 3
36970: PPUSH
36971: LD_INT 15
36973: PPUSH
36974: CALL 59771 0 2
36978: PUSH
36979: LD_INT 4
36981: ARRAY
36982: OR
36983: IFFALSE 36987
// continue ;
36985: GO 36949
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36987: LD_VAR 0 3
36991: PPUSH
36992: LD_EXP 99
36996: PUSH
36997: LD_VAR 0 2
37001: ARRAY
37002: PUSH
37003: LD_INT 1
37005: ARRAY
37006: PUSH
37007: LD_INT 1
37009: ARRAY
37010: PPUSH
37011: LD_EXP 99
37015: PUSH
37016: LD_VAR 0 2
37020: ARRAY
37021: PUSH
37022: LD_INT 1
37024: ARRAY
37025: PUSH
37026: LD_INT 2
37028: ARRAY
37029: PPUSH
37030: LD_EXP 99
37034: PUSH
37035: LD_VAR 0 2
37039: ARRAY
37040: PUSH
37041: LD_INT 1
37043: ARRAY
37044: PUSH
37045: LD_INT 3
37047: ARRAY
37048: PPUSH
37049: LD_EXP 99
37053: PUSH
37054: LD_VAR 0 2
37058: ARRAY
37059: PUSH
37060: LD_INT 1
37062: ARRAY
37063: PUSH
37064: LD_INT 4
37066: ARRAY
37067: PPUSH
37068: CALL_OW 448
37072: PUSH
37073: LD_VAR 0 3
37077: PPUSH
37078: LD_EXP 99
37082: PUSH
37083: LD_VAR 0 2
37087: ARRAY
37088: PUSH
37089: LD_INT 1
37091: ARRAY
37092: PUSH
37093: LD_INT 1
37095: ARRAY
37096: PUSH
37097: LD_EXP 99
37101: PUSH
37102: LD_VAR 0 2
37106: ARRAY
37107: PUSH
37108: LD_INT 1
37110: ARRAY
37111: PUSH
37112: LD_INT 2
37114: ARRAY
37115: PUSH
37116: LD_EXP 99
37120: PUSH
37121: LD_VAR 0 2
37125: ARRAY
37126: PUSH
37127: LD_INT 1
37129: ARRAY
37130: PUSH
37131: LD_INT 3
37133: ARRAY
37134: PUSH
37135: LD_EXP 99
37139: PUSH
37140: LD_VAR 0 2
37144: ARRAY
37145: PUSH
37146: LD_INT 1
37148: ARRAY
37149: PUSH
37150: LD_INT 4
37152: ARRAY
37153: PUSH
37154: EMPTY
37155: LIST
37156: LIST
37157: LIST
37158: LIST
37159: PPUSH
37160: CALL 63538 0 2
37164: AND
37165: IFFALSE 37303
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37167: LD_VAR 0 3
37171: PPUSH
37172: LD_EXP 99
37176: PUSH
37177: LD_VAR 0 2
37181: ARRAY
37182: PUSH
37183: LD_INT 1
37185: ARRAY
37186: PUSH
37187: LD_INT 1
37189: ARRAY
37190: PPUSH
37191: LD_EXP 99
37195: PUSH
37196: LD_VAR 0 2
37200: ARRAY
37201: PUSH
37202: LD_INT 1
37204: ARRAY
37205: PUSH
37206: LD_INT 2
37208: ARRAY
37209: PPUSH
37210: LD_EXP 99
37214: PUSH
37215: LD_VAR 0 2
37219: ARRAY
37220: PUSH
37221: LD_INT 1
37223: ARRAY
37224: PUSH
37225: LD_INT 3
37227: ARRAY
37228: PPUSH
37229: LD_EXP 99
37233: PUSH
37234: LD_VAR 0 2
37238: ARRAY
37239: PUSH
37240: LD_INT 1
37242: ARRAY
37243: PUSH
37244: LD_INT 4
37246: ARRAY
37247: PPUSH
37248: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37252: LD_ADDR_VAR 0 4
37256: PUSH
37257: LD_EXP 99
37261: PUSH
37262: LD_VAR 0 2
37266: ARRAY
37267: PPUSH
37268: LD_INT 1
37270: PPUSH
37271: CALL_OW 3
37275: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37276: LD_ADDR_EXP 99
37280: PUSH
37281: LD_EXP 99
37285: PPUSH
37286: LD_VAR 0 2
37290: PPUSH
37291: LD_VAR 0 4
37295: PPUSH
37296: CALL_OW 1
37300: ST_TO_ADDR
// break ;
37301: GO 37305
// end ; end ;
37303: GO 36949
37305: POP
37306: POP
// end ;
37307: GO 36881
37309: POP
37310: POP
// end ;
37311: LD_VAR 0 1
37315: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37316: LD_INT 0
37318: PPUSH
37319: PPUSH
37320: PPUSH
// if not mc_bases then
37321: LD_EXP 78
37325: NOT
37326: IFFALSE 37330
// exit ;
37328: GO 37419
// for i = 1 to mc_bases do
37330: LD_ADDR_VAR 0 2
37334: PUSH
37335: DOUBLE
37336: LD_INT 1
37338: DEC
37339: ST_TO_ADDR
37340: LD_EXP 78
37344: PUSH
37345: FOR_TO
37346: IFFALSE 37417
// begin if mc_attack [ i ] then
37348: LD_EXP 98
37352: PUSH
37353: LD_VAR 0 2
37357: ARRAY
37358: IFFALSE 37415
// begin tmp := mc_attack [ i ] [ 1 ] ;
37360: LD_ADDR_VAR 0 3
37364: PUSH
37365: LD_EXP 98
37369: PUSH
37370: LD_VAR 0 2
37374: ARRAY
37375: PUSH
37376: LD_INT 1
37378: ARRAY
37379: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37380: LD_ADDR_EXP 98
37384: PUSH
37385: LD_EXP 98
37389: PPUSH
37390: LD_VAR 0 2
37394: PPUSH
37395: EMPTY
37396: PPUSH
37397: CALL_OW 1
37401: ST_TO_ADDR
// Attack ( tmp ) ;
37402: LD_VAR 0 3
37406: PPUSH
37407: CALL 113659 0 1
// exit ;
37411: POP
37412: POP
37413: GO 37419
// end ; end ;
37415: GO 37345
37417: POP
37418: POP
// end ;
37419: LD_VAR 0 1
37423: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37424: LD_INT 0
37426: PPUSH
37427: PPUSH
37428: PPUSH
37429: PPUSH
37430: PPUSH
37431: PPUSH
37432: PPUSH
// if not mc_bases then
37433: LD_EXP 78
37437: NOT
37438: IFFALSE 37442
// exit ;
37440: GO 38299
// for i = 1 to mc_bases do
37442: LD_ADDR_VAR 0 2
37446: PUSH
37447: DOUBLE
37448: LD_INT 1
37450: DEC
37451: ST_TO_ADDR
37452: LD_EXP 78
37456: PUSH
37457: FOR_TO
37458: IFFALSE 38297
// begin if not mc_bases [ i ] then
37460: LD_EXP 78
37464: PUSH
37465: LD_VAR 0 2
37469: ARRAY
37470: NOT
37471: IFFALSE 37475
// continue ;
37473: GO 37457
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37475: LD_ADDR_VAR 0 7
37479: PUSH
37480: LD_EXP 78
37484: PUSH
37485: LD_VAR 0 2
37489: ARRAY
37490: PUSH
37491: LD_INT 1
37493: ARRAY
37494: PPUSH
37495: CALL 53998 0 1
37499: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37500: LD_ADDR_EXP 101
37504: PUSH
37505: LD_EXP 101
37509: PPUSH
37510: LD_VAR 0 2
37514: PPUSH
37515: LD_EXP 78
37519: PUSH
37520: LD_VAR 0 2
37524: ARRAY
37525: PUSH
37526: LD_INT 1
37528: ARRAY
37529: PPUSH
37530: CALL_OW 255
37534: PPUSH
37535: LD_EXP 103
37539: PUSH
37540: LD_VAR 0 2
37544: ARRAY
37545: PPUSH
37546: CALL 53963 0 2
37550: PPUSH
37551: CALL_OW 1
37555: ST_TO_ADDR
// if not mc_scan [ i ] then
37556: LD_EXP 101
37560: PUSH
37561: LD_VAR 0 2
37565: ARRAY
37566: NOT
37567: IFFALSE 37745
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37569: LD_ADDR_EXP 121
37573: PUSH
37574: LD_EXP 121
37578: PPUSH
37579: LD_VAR 0 2
37583: PPUSH
37584: LD_INT 0
37586: PPUSH
37587: CALL_OW 1
37591: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37592: LD_ADDR_VAR 0 4
37596: PUSH
37597: LD_EXP 78
37601: PUSH
37602: LD_VAR 0 2
37606: ARRAY
37607: PPUSH
37608: LD_INT 2
37610: PUSH
37611: LD_INT 25
37613: PUSH
37614: LD_INT 5
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 25
37623: PUSH
37624: LD_INT 8
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 25
37633: PUSH
37634: LD_INT 9
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: EMPTY
37642: LIST
37643: LIST
37644: LIST
37645: LIST
37646: PPUSH
37647: CALL_OW 72
37651: ST_TO_ADDR
// if not tmp then
37652: LD_VAR 0 4
37656: NOT
37657: IFFALSE 37661
// continue ;
37659: GO 37457
// for j in tmp do
37661: LD_ADDR_VAR 0 3
37665: PUSH
37666: LD_VAR 0 4
37670: PUSH
37671: FOR_IN
37672: IFFALSE 37743
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37674: LD_VAR 0 3
37678: PPUSH
37679: CALL_OW 310
37683: PPUSH
37684: CALL_OW 266
37688: PUSH
37689: LD_INT 5
37691: EQUAL
37692: PUSH
37693: LD_VAR 0 3
37697: PPUSH
37698: CALL_OW 257
37702: PUSH
37703: LD_INT 1
37705: EQUAL
37706: AND
37707: PUSH
37708: LD_VAR 0 3
37712: PPUSH
37713: CALL_OW 459
37717: NOT
37718: AND
37719: PUSH
37720: LD_VAR 0 7
37724: AND
37725: IFFALSE 37741
// ComChangeProfession ( j , class ) ;
37727: LD_VAR 0 3
37731: PPUSH
37732: LD_VAR 0 7
37736: PPUSH
37737: CALL_OW 123
37741: GO 37671
37743: POP
37744: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37745: LD_EXP 101
37749: PUSH
37750: LD_VAR 0 2
37754: ARRAY
37755: PUSH
37756: LD_EXP 121
37760: PUSH
37761: LD_VAR 0 2
37765: ARRAY
37766: NOT
37767: AND
37768: PUSH
37769: LD_EXP 100
37773: PUSH
37774: LD_VAR 0 2
37778: ARRAY
37779: NOT
37780: AND
37781: PUSH
37782: LD_EXP 78
37786: PUSH
37787: LD_VAR 0 2
37791: ARRAY
37792: PPUSH
37793: LD_INT 50
37795: PUSH
37796: EMPTY
37797: LIST
37798: PUSH
37799: LD_INT 2
37801: PUSH
37802: LD_INT 30
37804: PUSH
37805: LD_INT 32
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 30
37814: PUSH
37815: LD_INT 33
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 30
37824: PUSH
37825: LD_INT 4
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PUSH
37832: LD_INT 30
37834: PUSH
37835: LD_INT 5
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: LIST
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PPUSH
37853: CALL_OW 72
37857: PUSH
37858: LD_INT 4
37860: LESS
37861: PUSH
37862: LD_EXP 78
37866: PUSH
37867: LD_VAR 0 2
37871: ARRAY
37872: PPUSH
37873: LD_INT 3
37875: PUSH
37876: LD_INT 24
37878: PUSH
37879: LD_INT 1000
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 2
37892: PUSH
37893: LD_INT 30
37895: PUSH
37896: LD_INT 0
37898: PUSH
37899: EMPTY
37900: LIST
37901: LIST
37902: PUSH
37903: LD_INT 30
37905: PUSH
37906: LD_INT 1
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: LIST
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PPUSH
37922: CALL_OW 72
37926: OR
37927: AND
37928: IFFALSE 38179
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37930: LD_ADDR_EXP 121
37934: PUSH
37935: LD_EXP 121
37939: PPUSH
37940: LD_VAR 0 2
37944: PPUSH
37945: LD_INT 1
37947: PPUSH
37948: CALL_OW 1
37952: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37953: LD_ADDR_VAR 0 4
37957: PUSH
37958: LD_EXP 78
37962: PUSH
37963: LD_VAR 0 2
37967: ARRAY
37968: PPUSH
37969: LD_INT 2
37971: PUSH
37972: LD_INT 25
37974: PUSH
37975: LD_INT 1
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PUSH
37982: LD_INT 25
37984: PUSH
37985: LD_INT 5
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 25
37994: PUSH
37995: LD_INT 8
37997: PUSH
37998: EMPTY
37999: LIST
38000: LIST
38001: PUSH
38002: LD_INT 25
38004: PUSH
38005: LD_INT 9
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: LIST
38016: LIST
38017: LIST
38018: PPUSH
38019: CALL_OW 72
38023: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
38024: LD_ADDR_VAR 0 4
38028: PUSH
38029: LD_VAR 0 4
38033: PUSH
38034: LD_VAR 0 4
38038: PPUSH
38039: LD_INT 18
38041: PPUSH
38042: CALL 87086 0 2
38046: DIFF
38047: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
38048: LD_VAR 0 4
38052: NOT
38053: PUSH
38054: LD_EXP 78
38058: PUSH
38059: LD_VAR 0 2
38063: ARRAY
38064: PPUSH
38065: LD_INT 2
38067: PUSH
38068: LD_INT 30
38070: PUSH
38071: LD_INT 4
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: LD_INT 30
38080: PUSH
38081: LD_INT 5
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: LIST
38092: PPUSH
38093: CALL_OW 72
38097: NOT
38098: AND
38099: IFFALSE 38161
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
38101: LD_ADDR_VAR 0 4
38105: PUSH
38106: LD_EXP 78
38110: PUSH
38111: LD_VAR 0 2
38115: ARRAY
38116: PPUSH
38117: LD_INT 2
38119: PUSH
38120: LD_INT 25
38122: PUSH
38123: LD_INT 2
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 25
38132: PUSH
38133: LD_INT 3
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 25
38142: PUSH
38143: LD_INT 4
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: LIST
38154: LIST
38155: PPUSH
38156: CALL_OW 72
38160: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38161: LD_VAR 0 2
38165: PPUSH
38166: LD_VAR 0 4
38170: PPUSH
38171: CALL 118368 0 2
// exit ;
38175: POP
38176: POP
38177: GO 38299
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38179: LD_EXP 101
38183: PUSH
38184: LD_VAR 0 2
38188: ARRAY
38189: PUSH
38190: LD_EXP 121
38194: PUSH
38195: LD_VAR 0 2
38199: ARRAY
38200: NOT
38201: AND
38202: PUSH
38203: LD_EXP 100
38207: PUSH
38208: LD_VAR 0 2
38212: ARRAY
38213: AND
38214: IFFALSE 38295
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38216: LD_ADDR_EXP 121
38220: PUSH
38221: LD_EXP 121
38225: PPUSH
38226: LD_VAR 0 2
38230: PPUSH
38231: LD_INT 1
38233: PPUSH
38234: CALL_OW 1
38238: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38239: LD_ADDR_VAR 0 4
38243: PUSH
38244: LD_EXP 100
38248: PUSH
38249: LD_VAR 0 2
38253: ARRAY
38254: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38255: LD_ADDR_EXP 100
38259: PUSH
38260: LD_EXP 100
38264: PPUSH
38265: LD_VAR 0 2
38269: PPUSH
38270: EMPTY
38271: PPUSH
38272: CALL_OW 1
38276: ST_TO_ADDR
// Defend ( i , tmp ) ;
38277: LD_VAR 0 2
38281: PPUSH
38282: LD_VAR 0 4
38286: PPUSH
38287: CALL 118964 0 2
// exit ;
38291: POP
38292: POP
38293: GO 38299
// end ; end ;
38295: GO 37457
38297: POP
38298: POP
// end ;
38299: LD_VAR 0 1
38303: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38304: LD_INT 0
38306: PPUSH
38307: PPUSH
38308: PPUSH
38309: PPUSH
38310: PPUSH
38311: PPUSH
38312: PPUSH
38313: PPUSH
38314: PPUSH
38315: PPUSH
38316: PPUSH
// if not mc_bases then
38317: LD_EXP 78
38321: NOT
38322: IFFALSE 38326
// exit ;
38324: GO 39413
// for i = 1 to mc_bases do
38326: LD_ADDR_VAR 0 2
38330: PUSH
38331: DOUBLE
38332: LD_INT 1
38334: DEC
38335: ST_TO_ADDR
38336: LD_EXP 78
38340: PUSH
38341: FOR_TO
38342: IFFALSE 39411
// begin tmp := mc_lab [ i ] ;
38344: LD_ADDR_VAR 0 6
38348: PUSH
38349: LD_EXP 111
38353: PUSH
38354: LD_VAR 0 2
38358: ARRAY
38359: ST_TO_ADDR
// if not tmp then
38360: LD_VAR 0 6
38364: NOT
38365: IFFALSE 38369
// continue ;
38367: GO 38341
// idle_lab := 0 ;
38369: LD_ADDR_VAR 0 11
38373: PUSH
38374: LD_INT 0
38376: ST_TO_ADDR
// for j in tmp do
38377: LD_ADDR_VAR 0 3
38381: PUSH
38382: LD_VAR 0 6
38386: PUSH
38387: FOR_IN
38388: IFFALSE 39407
// begin researching := false ;
38390: LD_ADDR_VAR 0 10
38394: PUSH
38395: LD_INT 0
38397: ST_TO_ADDR
// side := GetSide ( j ) ;
38398: LD_ADDR_VAR 0 4
38402: PUSH
38403: LD_VAR 0 3
38407: PPUSH
38408: CALL_OW 255
38412: ST_TO_ADDR
// if not mc_tech [ side ] then
38413: LD_EXP 105
38417: PUSH
38418: LD_VAR 0 4
38422: ARRAY
38423: NOT
38424: IFFALSE 38428
// continue ;
38426: GO 38387
// if BuildingStatus ( j ) = bs_idle then
38428: LD_VAR 0 3
38432: PPUSH
38433: CALL_OW 461
38437: PUSH
38438: LD_INT 2
38440: EQUAL
38441: IFFALSE 38629
// begin if idle_lab and UnitsInside ( j ) < 6 then
38443: LD_VAR 0 11
38447: PUSH
38448: LD_VAR 0 3
38452: PPUSH
38453: CALL_OW 313
38457: PUSH
38458: LD_INT 6
38460: LESS
38461: AND
38462: IFFALSE 38533
// begin tmp2 := UnitsInside ( idle_lab ) ;
38464: LD_ADDR_VAR 0 9
38468: PUSH
38469: LD_VAR 0 11
38473: PPUSH
38474: CALL_OW 313
38478: ST_TO_ADDR
// if tmp2 then
38479: LD_VAR 0 9
38483: IFFALSE 38525
// for x in tmp2 do
38485: LD_ADDR_VAR 0 7
38489: PUSH
38490: LD_VAR 0 9
38494: PUSH
38495: FOR_IN
38496: IFFALSE 38523
// begin ComExitBuilding ( x ) ;
38498: LD_VAR 0 7
38502: PPUSH
38503: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38507: LD_VAR 0 7
38511: PPUSH
38512: LD_VAR 0 3
38516: PPUSH
38517: CALL_OW 180
// end ;
38521: GO 38495
38523: POP
38524: POP
// idle_lab := 0 ;
38525: LD_ADDR_VAR 0 11
38529: PUSH
38530: LD_INT 0
38532: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38533: LD_ADDR_VAR 0 5
38537: PUSH
38538: LD_EXP 105
38542: PUSH
38543: LD_VAR 0 4
38547: ARRAY
38548: PUSH
38549: FOR_IN
38550: IFFALSE 38610
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38552: LD_VAR 0 3
38556: PPUSH
38557: LD_VAR 0 5
38561: PPUSH
38562: CALL_OW 430
38566: PUSH
38567: LD_VAR 0 4
38571: PPUSH
38572: LD_VAR 0 5
38576: PPUSH
38577: CALL 53068 0 2
38581: AND
38582: IFFALSE 38608
// begin researching := true ;
38584: LD_ADDR_VAR 0 10
38588: PUSH
38589: LD_INT 1
38591: ST_TO_ADDR
// ComResearch ( j , t ) ;
38592: LD_VAR 0 3
38596: PPUSH
38597: LD_VAR 0 5
38601: PPUSH
38602: CALL_OW 124
// break ;
38606: GO 38610
// end ;
38608: GO 38549
38610: POP
38611: POP
// if not researching then
38612: LD_VAR 0 10
38616: NOT
38617: IFFALSE 38629
// idle_lab := j ;
38619: LD_ADDR_VAR 0 11
38623: PUSH
38624: LD_VAR 0 3
38628: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38629: LD_VAR 0 3
38633: PPUSH
38634: CALL_OW 461
38638: PUSH
38639: LD_INT 10
38641: EQUAL
38642: IFFALSE 39230
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38644: LD_EXP 107
38648: PUSH
38649: LD_VAR 0 2
38653: ARRAY
38654: NOT
38655: PUSH
38656: LD_EXP 108
38660: PUSH
38661: LD_VAR 0 2
38665: ARRAY
38666: NOT
38667: AND
38668: PUSH
38669: LD_EXP 105
38673: PUSH
38674: LD_VAR 0 4
38678: ARRAY
38679: PUSH
38680: LD_INT 1
38682: GREATER
38683: AND
38684: IFFALSE 38815
// begin ComCancel ( j ) ;
38686: LD_VAR 0 3
38690: PPUSH
38691: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38695: LD_ADDR_EXP 105
38699: PUSH
38700: LD_EXP 105
38704: PPUSH
38705: LD_VAR 0 4
38709: PPUSH
38710: LD_EXP 105
38714: PUSH
38715: LD_VAR 0 4
38719: ARRAY
38720: PPUSH
38721: LD_EXP 105
38725: PUSH
38726: LD_VAR 0 4
38730: ARRAY
38731: PUSH
38732: LD_INT 1
38734: MINUS
38735: PPUSH
38736: LD_EXP 105
38740: PUSH
38741: LD_VAR 0 4
38745: ARRAY
38746: PPUSH
38747: LD_INT 0
38749: PPUSH
38750: CALL 56592 0 4
38754: PPUSH
38755: CALL_OW 1
38759: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38760: LD_ADDR_EXP 105
38764: PUSH
38765: LD_EXP 105
38769: PPUSH
38770: LD_VAR 0 4
38774: PPUSH
38775: LD_EXP 105
38779: PUSH
38780: LD_VAR 0 4
38784: ARRAY
38785: PPUSH
38786: LD_EXP 105
38790: PUSH
38791: LD_VAR 0 4
38795: ARRAY
38796: PPUSH
38797: LD_INT 1
38799: PPUSH
38800: LD_INT 0
38802: PPUSH
38803: CALL 56592 0 4
38807: PPUSH
38808: CALL_OW 1
38812: ST_TO_ADDR
// continue ;
38813: GO 38387
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38815: LD_EXP 107
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_EXP 108
38830: PUSH
38831: LD_VAR 0 2
38835: ARRAY
38836: NOT
38837: AND
38838: IFFALSE 38965
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38840: LD_ADDR_EXP 108
38844: PUSH
38845: LD_EXP 108
38849: PPUSH
38850: LD_VAR 0 2
38854: PUSH
38855: LD_EXP 108
38859: PUSH
38860: LD_VAR 0 2
38864: ARRAY
38865: PUSH
38866: LD_INT 1
38868: PLUS
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PPUSH
38874: LD_EXP 107
38878: PUSH
38879: LD_VAR 0 2
38883: ARRAY
38884: PUSH
38885: LD_INT 1
38887: ARRAY
38888: PPUSH
38889: CALL 57174 0 3
38893: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38894: LD_EXP 107
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: PUSH
38905: LD_INT 1
38907: ARRAY
38908: PPUSH
38909: LD_INT 112
38911: PPUSH
38912: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38916: LD_ADDR_VAR 0 9
38920: PUSH
38921: LD_EXP 107
38925: PUSH
38926: LD_VAR 0 2
38930: ARRAY
38931: PPUSH
38932: LD_INT 1
38934: PPUSH
38935: CALL_OW 3
38939: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38940: LD_ADDR_EXP 107
38944: PUSH
38945: LD_EXP 107
38949: PPUSH
38950: LD_VAR 0 2
38954: PPUSH
38955: LD_VAR 0 9
38959: PPUSH
38960: CALL_OW 1
38964: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38965: LD_EXP 107
38969: PUSH
38970: LD_VAR 0 2
38974: ARRAY
38975: PUSH
38976: LD_EXP 108
38980: PUSH
38981: LD_VAR 0 2
38985: ARRAY
38986: AND
38987: PUSH
38988: LD_EXP 108
38992: PUSH
38993: LD_VAR 0 2
38997: ARRAY
38998: PUSH
38999: LD_INT 1
39001: ARRAY
39002: PPUSH
39003: CALL_OW 310
39007: NOT
39008: AND
39009: PUSH
39010: LD_VAR 0 3
39014: PPUSH
39015: CALL_OW 313
39019: PUSH
39020: LD_INT 6
39022: EQUAL
39023: AND
39024: IFFALSE 39080
// begin tmp2 := UnitsInside ( j ) ;
39026: LD_ADDR_VAR 0 9
39030: PUSH
39031: LD_VAR 0 3
39035: PPUSH
39036: CALL_OW 313
39040: ST_TO_ADDR
// if tmp2 = 6 then
39041: LD_VAR 0 9
39045: PUSH
39046: LD_INT 6
39048: EQUAL
39049: IFFALSE 39080
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
39051: LD_VAR 0 9
39055: PUSH
39056: LD_INT 1
39058: ARRAY
39059: PPUSH
39060: LD_INT 112
39062: PPUSH
39063: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
39067: LD_VAR 0 9
39071: PUSH
39072: LD_INT 1
39074: ARRAY
39075: PPUSH
39076: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
39080: LD_EXP 108
39084: PUSH
39085: LD_VAR 0 2
39089: ARRAY
39090: PUSH
39091: LD_EXP 108
39095: PUSH
39096: LD_VAR 0 2
39100: ARRAY
39101: PUSH
39102: LD_INT 1
39104: ARRAY
39105: PPUSH
39106: CALL_OW 314
39110: NOT
39111: AND
39112: PUSH
39113: LD_EXP 108
39117: PUSH
39118: LD_VAR 0 2
39122: ARRAY
39123: PUSH
39124: LD_INT 1
39126: ARRAY
39127: PPUSH
39128: CALL_OW 310
39132: NOT
39133: AND
39134: IFFALSE 39160
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
39136: LD_EXP 108
39140: PUSH
39141: LD_VAR 0 2
39145: ARRAY
39146: PUSH
39147: LD_INT 1
39149: ARRAY
39150: PPUSH
39151: LD_VAR 0 3
39155: PPUSH
39156: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
39160: LD_EXP 108
39164: PUSH
39165: LD_VAR 0 2
39169: ARRAY
39170: PUSH
39171: LD_INT 1
39173: ARRAY
39174: PPUSH
39175: CALL_OW 310
39179: PUSH
39180: LD_EXP 108
39184: PUSH
39185: LD_VAR 0 2
39189: ARRAY
39190: PUSH
39191: LD_INT 1
39193: ARRAY
39194: PPUSH
39195: CALL_OW 310
39199: PPUSH
39200: CALL_OW 461
39204: PUSH
39205: LD_INT 3
39207: NONEQUAL
39208: AND
39209: IFFALSE 39230
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39211: LD_EXP 108
39215: PUSH
39216: LD_VAR 0 2
39220: ARRAY
39221: PUSH
39222: LD_INT 1
39224: ARRAY
39225: PPUSH
39226: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39230: LD_VAR 0 3
39234: PPUSH
39235: CALL_OW 461
39239: PUSH
39240: LD_INT 6
39242: EQUAL
39243: PUSH
39244: LD_VAR 0 6
39248: PUSH
39249: LD_INT 1
39251: GREATER
39252: AND
39253: IFFALSE 39405
// begin sci := [ ] ;
39255: LD_ADDR_VAR 0 8
39259: PUSH
39260: EMPTY
39261: ST_TO_ADDR
// for x in ( tmp diff j ) do
39262: LD_ADDR_VAR 0 7
39266: PUSH
39267: LD_VAR 0 6
39271: PUSH
39272: LD_VAR 0 3
39276: DIFF
39277: PUSH
39278: FOR_IN
39279: IFFALSE 39331
// begin if sci = 6 then
39281: LD_VAR 0 8
39285: PUSH
39286: LD_INT 6
39288: EQUAL
39289: IFFALSE 39293
// break ;
39291: GO 39331
// if BuildingStatus ( x ) = bs_idle then
39293: LD_VAR 0 7
39297: PPUSH
39298: CALL_OW 461
39302: PUSH
39303: LD_INT 2
39305: EQUAL
39306: IFFALSE 39329
// sci := sci ^ UnitsInside ( x ) ;
39308: LD_ADDR_VAR 0 8
39312: PUSH
39313: LD_VAR 0 8
39317: PUSH
39318: LD_VAR 0 7
39322: PPUSH
39323: CALL_OW 313
39327: ADD
39328: ST_TO_ADDR
// end ;
39329: GO 39278
39331: POP
39332: POP
// if not sci then
39333: LD_VAR 0 8
39337: NOT
39338: IFFALSE 39342
// continue ;
39340: GO 38387
// for x in sci do
39342: LD_ADDR_VAR 0 7
39346: PUSH
39347: LD_VAR 0 8
39351: PUSH
39352: FOR_IN
39353: IFFALSE 39403
// if IsInUnit ( x ) and not HasTask ( x ) then
39355: LD_VAR 0 7
39359: PPUSH
39360: CALL_OW 310
39364: PUSH
39365: LD_VAR 0 7
39369: PPUSH
39370: CALL_OW 314
39374: NOT
39375: AND
39376: IFFALSE 39401
// begin ComExitBuilding ( x ) ;
39378: LD_VAR 0 7
39382: PPUSH
39383: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39387: LD_VAR 0 7
39391: PPUSH
39392: LD_VAR 0 3
39396: PPUSH
39397: CALL_OW 180
// end ;
39401: GO 39352
39403: POP
39404: POP
// end ; end ;
39405: GO 38387
39407: POP
39408: POP
// end ;
39409: GO 38341
39411: POP
39412: POP
// end ;
39413: LD_VAR 0 1
39417: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39418: LD_INT 0
39420: PPUSH
39421: PPUSH
// if not mc_bases then
39422: LD_EXP 78
39426: NOT
39427: IFFALSE 39431
// exit ;
39429: GO 39512
// for i = 1 to mc_bases do
39431: LD_ADDR_VAR 0 2
39435: PUSH
39436: DOUBLE
39437: LD_INT 1
39439: DEC
39440: ST_TO_ADDR
39441: LD_EXP 78
39445: PUSH
39446: FOR_TO
39447: IFFALSE 39510
// if mc_mines [ i ] and mc_miners [ i ] then
39449: LD_EXP 91
39453: PUSH
39454: LD_VAR 0 2
39458: ARRAY
39459: PUSH
39460: LD_EXP 92
39464: PUSH
39465: LD_VAR 0 2
39469: ARRAY
39470: AND
39471: IFFALSE 39508
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39473: LD_EXP 92
39477: PUSH
39478: LD_VAR 0 2
39482: ARRAY
39483: PUSH
39484: LD_INT 1
39486: ARRAY
39487: PPUSH
39488: CALL_OW 255
39492: PPUSH
39493: LD_EXP 91
39497: PUSH
39498: LD_VAR 0 2
39502: ARRAY
39503: PPUSH
39504: CALL 54151 0 2
39508: GO 39446
39510: POP
39511: POP
// end ;
39512: LD_VAR 0 1
39516: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39517: LD_INT 0
39519: PPUSH
39520: PPUSH
39521: PPUSH
39522: PPUSH
39523: PPUSH
39524: PPUSH
39525: PPUSH
39526: PPUSH
// if not mc_bases or not mc_parking then
39527: LD_EXP 78
39531: NOT
39532: PUSH
39533: LD_EXP 102
39537: NOT
39538: OR
39539: IFFALSE 39543
// exit ;
39541: GO 40281
// for i = 1 to mc_bases do
39543: LD_ADDR_VAR 0 2
39547: PUSH
39548: DOUBLE
39549: LD_INT 1
39551: DEC
39552: ST_TO_ADDR
39553: LD_EXP 78
39557: PUSH
39558: FOR_TO
39559: IFFALSE 40279
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39561: LD_EXP 78
39565: PUSH
39566: LD_VAR 0 2
39570: ARRAY
39571: NOT
39572: PUSH
39573: LD_EXP 102
39577: PUSH
39578: LD_VAR 0 2
39582: ARRAY
39583: NOT
39584: OR
39585: IFFALSE 39589
// continue ;
39587: GO 39558
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39589: LD_ADDR_VAR 0 5
39593: PUSH
39594: LD_EXP 78
39598: PUSH
39599: LD_VAR 0 2
39603: ARRAY
39604: PUSH
39605: LD_INT 1
39607: ARRAY
39608: PPUSH
39609: CALL_OW 255
39613: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39614: LD_ADDR_VAR 0 6
39618: PUSH
39619: LD_EXP 78
39623: PUSH
39624: LD_VAR 0 2
39628: ARRAY
39629: PPUSH
39630: LD_INT 30
39632: PUSH
39633: LD_INT 3
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PPUSH
39640: CALL_OW 72
39644: ST_TO_ADDR
// if not fac then
39645: LD_VAR 0 6
39649: NOT
39650: IFFALSE 39701
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39652: LD_ADDR_VAR 0 6
39656: PUSH
39657: LD_EXP 78
39661: PUSH
39662: LD_VAR 0 2
39666: ARRAY
39667: PPUSH
39668: LD_INT 2
39670: PUSH
39671: LD_INT 30
39673: PUSH
39674: LD_INT 0
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 30
39683: PUSH
39684: LD_INT 1
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: LIST
39695: PPUSH
39696: CALL_OW 72
39700: ST_TO_ADDR
// if not fac then
39701: LD_VAR 0 6
39705: NOT
39706: IFFALSE 39710
// continue ;
39708: GO 39558
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39710: LD_ADDR_VAR 0 7
39714: PUSH
39715: LD_EXP 102
39719: PUSH
39720: LD_VAR 0 2
39724: ARRAY
39725: PPUSH
39726: LD_INT 22
39728: PUSH
39729: LD_VAR 0 5
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 21
39740: PUSH
39741: LD_INT 2
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 3
39750: PUSH
39751: LD_INT 60
39753: PUSH
39754: EMPTY
39755: LIST
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 3
39763: PUSH
39764: LD_INT 24
39766: PUSH
39767: LD_INT 1000
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: LIST
39782: LIST
39783: PPUSH
39784: CALL_OW 70
39788: ST_TO_ADDR
// for j in fac do
39789: LD_ADDR_VAR 0 3
39793: PUSH
39794: LD_VAR 0 6
39798: PUSH
39799: FOR_IN
39800: IFFALSE 39895
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39802: LD_ADDR_VAR 0 7
39806: PUSH
39807: LD_VAR 0 7
39811: PUSH
39812: LD_INT 22
39814: PUSH
39815: LD_VAR 0 5
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 91
39826: PUSH
39827: LD_VAR 0 3
39831: PUSH
39832: LD_INT 15
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: LIST
39839: PUSH
39840: LD_INT 21
39842: PUSH
39843: LD_INT 2
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 3
39852: PUSH
39853: LD_INT 60
39855: PUSH
39856: EMPTY
39857: LIST
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 3
39865: PUSH
39866: LD_INT 24
39868: PUSH
39869: LD_INT 1000
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: PPUSH
39887: CALL_OW 69
39891: UNION
39892: ST_TO_ADDR
39893: GO 39799
39895: POP
39896: POP
// if not vehs then
39897: LD_VAR 0 7
39901: NOT
39902: IFFALSE 39928
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39904: LD_ADDR_EXP 90
39908: PUSH
39909: LD_EXP 90
39913: PPUSH
39914: LD_VAR 0 2
39918: PPUSH
39919: EMPTY
39920: PPUSH
39921: CALL_OW 1
39925: ST_TO_ADDR
// continue ;
39926: GO 39558
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39928: LD_ADDR_VAR 0 8
39932: PUSH
39933: LD_EXP 78
39937: PUSH
39938: LD_VAR 0 2
39942: ARRAY
39943: PPUSH
39944: LD_INT 30
39946: PUSH
39947: LD_INT 3
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PPUSH
39954: CALL_OW 72
39958: ST_TO_ADDR
// if tmp then
39959: LD_VAR 0 8
39963: IFFALSE 40066
// begin for j in tmp do
39965: LD_ADDR_VAR 0 3
39969: PUSH
39970: LD_VAR 0 8
39974: PUSH
39975: FOR_IN
39976: IFFALSE 40064
// for k in UnitsInside ( j ) do
39978: LD_ADDR_VAR 0 4
39982: PUSH
39983: LD_VAR 0 3
39987: PPUSH
39988: CALL_OW 313
39992: PUSH
39993: FOR_IN
39994: IFFALSE 40060
// if k then
39996: LD_VAR 0 4
40000: IFFALSE 40058
// if not k in mc_repair_vehicle [ i ] then
40002: LD_VAR 0 4
40006: PUSH
40007: LD_EXP 90
40011: PUSH
40012: LD_VAR 0 2
40016: ARRAY
40017: IN
40018: NOT
40019: IFFALSE 40058
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
40021: LD_ADDR_EXP 90
40025: PUSH
40026: LD_EXP 90
40030: PPUSH
40031: LD_VAR 0 2
40035: PPUSH
40036: LD_EXP 90
40040: PUSH
40041: LD_VAR 0 2
40045: ARRAY
40046: PUSH
40047: LD_VAR 0 4
40051: UNION
40052: PPUSH
40053: CALL_OW 1
40057: ST_TO_ADDR
40058: GO 39993
40060: POP
40061: POP
40062: GO 39975
40064: POP
40065: POP
// end ; if not mc_repair_vehicle [ i ] then
40066: LD_EXP 90
40070: PUSH
40071: LD_VAR 0 2
40075: ARRAY
40076: NOT
40077: IFFALSE 40081
// continue ;
40079: GO 39558
// for j in mc_repair_vehicle [ i ] do
40081: LD_ADDR_VAR 0 3
40085: PUSH
40086: LD_EXP 90
40090: PUSH
40091: LD_VAR 0 2
40095: ARRAY
40096: PUSH
40097: FOR_IN
40098: IFFALSE 40275
// begin if GetClass ( j ) <> 3 then
40100: LD_VAR 0 3
40104: PPUSH
40105: CALL_OW 257
40109: PUSH
40110: LD_INT 3
40112: NONEQUAL
40113: IFFALSE 40154
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
40115: LD_ADDR_EXP 90
40119: PUSH
40120: LD_EXP 90
40124: PPUSH
40125: LD_VAR 0 2
40129: PPUSH
40130: LD_EXP 90
40134: PUSH
40135: LD_VAR 0 2
40139: ARRAY
40140: PUSH
40141: LD_VAR 0 3
40145: DIFF
40146: PPUSH
40147: CALL_OW 1
40151: ST_TO_ADDR
// continue ;
40152: GO 40097
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40154: LD_VAR 0 3
40158: PPUSH
40159: CALL_OW 311
40163: NOT
40164: PUSH
40165: LD_VAR 0 3
40169: PUSH
40170: LD_EXP 81
40174: PUSH
40175: LD_VAR 0 2
40179: ARRAY
40180: PUSH
40181: LD_INT 1
40183: ARRAY
40184: IN
40185: NOT
40186: AND
40187: PUSH
40188: LD_VAR 0 3
40192: PUSH
40193: LD_EXP 81
40197: PUSH
40198: LD_VAR 0 2
40202: ARRAY
40203: PUSH
40204: LD_INT 2
40206: ARRAY
40207: IN
40208: NOT
40209: AND
40210: IFFALSE 40273
// begin if IsInUnit ( j ) then
40212: LD_VAR 0 3
40216: PPUSH
40217: CALL_OW 310
40221: IFFALSE 40234
// ComExitBuilding ( j ) else
40223: LD_VAR 0 3
40227: PPUSH
40228: CALL_OW 122
40232: GO 40273
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40234: LD_VAR 0 3
40238: PPUSH
40239: LD_VAR 0 7
40243: PUSH
40244: LD_INT 1
40246: ARRAY
40247: PPUSH
40248: CALL 91569 0 2
40252: NOT
40253: IFFALSE 40273
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40255: LD_VAR 0 3
40259: PPUSH
40260: LD_VAR 0 7
40264: PUSH
40265: LD_INT 1
40267: ARRAY
40268: PPUSH
40269: CALL_OW 129
// end ; end ;
40273: GO 40097
40275: POP
40276: POP
// end ;
40277: GO 39558
40279: POP
40280: POP
// end ;
40281: LD_VAR 0 1
40285: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40286: LD_INT 0
40288: PPUSH
40289: PPUSH
40290: PPUSH
40291: PPUSH
40292: PPUSH
40293: PPUSH
40294: PPUSH
40295: PPUSH
40296: PPUSH
40297: PPUSH
40298: PPUSH
// if not mc_bases then
40299: LD_EXP 78
40303: NOT
40304: IFFALSE 40308
// exit ;
40306: GO 41110
// for i = 1 to mc_bases do
40308: LD_ADDR_VAR 0 2
40312: PUSH
40313: DOUBLE
40314: LD_INT 1
40316: DEC
40317: ST_TO_ADDR
40318: LD_EXP 78
40322: PUSH
40323: FOR_TO
40324: IFFALSE 41108
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40326: LD_EXP 106
40330: PUSH
40331: LD_VAR 0 2
40335: ARRAY
40336: NOT
40337: PUSH
40338: LD_EXP 81
40342: PUSH
40343: LD_VAR 0 2
40347: ARRAY
40348: PUSH
40349: LD_INT 1
40351: ARRAY
40352: OR
40353: PUSH
40354: LD_EXP 81
40358: PUSH
40359: LD_VAR 0 2
40363: ARRAY
40364: PUSH
40365: LD_INT 2
40367: ARRAY
40368: OR
40369: PUSH
40370: LD_EXP 104
40374: PUSH
40375: LD_VAR 0 2
40379: ARRAY
40380: PPUSH
40381: LD_INT 1
40383: PPUSH
40384: CALL_OW 325
40388: NOT
40389: OR
40390: PUSH
40391: LD_EXP 101
40395: PUSH
40396: LD_VAR 0 2
40400: ARRAY
40401: OR
40402: IFFALSE 40406
// continue ;
40404: GO 40323
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40406: LD_ADDR_VAR 0 8
40410: PUSH
40411: LD_EXP 78
40415: PUSH
40416: LD_VAR 0 2
40420: ARRAY
40421: PPUSH
40422: LD_INT 25
40424: PUSH
40425: LD_INT 4
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: LD_INT 50
40434: PUSH
40435: EMPTY
40436: LIST
40437: PUSH
40438: LD_INT 3
40440: PUSH
40441: LD_INT 60
40443: PUSH
40444: EMPTY
40445: LIST
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: LIST
40455: PPUSH
40456: CALL_OW 72
40460: PUSH
40461: LD_EXP 82
40465: PUSH
40466: LD_VAR 0 2
40470: ARRAY
40471: DIFF
40472: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40473: LD_ADDR_VAR 0 9
40477: PUSH
40478: LD_EXP 78
40482: PUSH
40483: LD_VAR 0 2
40487: ARRAY
40488: PPUSH
40489: LD_INT 2
40491: PUSH
40492: LD_INT 30
40494: PUSH
40495: LD_INT 0
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 30
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: LIST
40516: PPUSH
40517: CALL_OW 72
40521: ST_TO_ADDR
// if not tmp or not dep then
40522: LD_VAR 0 8
40526: NOT
40527: PUSH
40528: LD_VAR 0 9
40532: NOT
40533: OR
40534: IFFALSE 40538
// continue ;
40536: GO 40323
// side := GetSide ( tmp [ 1 ] ) ;
40538: LD_ADDR_VAR 0 11
40542: PUSH
40543: LD_VAR 0 8
40547: PUSH
40548: LD_INT 1
40550: ARRAY
40551: PPUSH
40552: CALL_OW 255
40556: ST_TO_ADDR
// dep := dep [ 1 ] ;
40557: LD_ADDR_VAR 0 9
40561: PUSH
40562: LD_VAR 0 9
40566: PUSH
40567: LD_INT 1
40569: ARRAY
40570: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40571: LD_ADDR_VAR 0 7
40575: PUSH
40576: LD_EXP 106
40580: PUSH
40581: LD_VAR 0 2
40585: ARRAY
40586: PPUSH
40587: LD_INT 22
40589: PUSH
40590: LD_INT 0
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 25
40599: PUSH
40600: LD_INT 12
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PPUSH
40611: CALL_OW 70
40615: PUSH
40616: LD_INT 22
40618: PUSH
40619: LD_INT 0
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: PUSH
40626: LD_INT 25
40628: PUSH
40629: LD_INT 12
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: PUSH
40636: LD_INT 91
40638: PUSH
40639: LD_VAR 0 9
40643: PUSH
40644: LD_INT 20
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: LIST
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: LIST
40656: PPUSH
40657: CALL_OW 69
40661: UNION
40662: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40663: LD_ADDR_VAR 0 10
40667: PUSH
40668: LD_EXP 106
40672: PUSH
40673: LD_VAR 0 2
40677: ARRAY
40678: PPUSH
40679: LD_INT 81
40681: PUSH
40682: LD_VAR 0 11
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PPUSH
40691: CALL_OW 70
40695: ST_TO_ADDR
// if not apes or danger_at_area then
40696: LD_VAR 0 7
40700: NOT
40701: PUSH
40702: LD_VAR 0 10
40706: OR
40707: IFFALSE 40757
// begin if mc_taming [ i ] then
40709: LD_EXP 109
40713: PUSH
40714: LD_VAR 0 2
40718: ARRAY
40719: IFFALSE 40755
// begin MC_Reset ( i , 121 ) ;
40721: LD_VAR 0 2
40725: PPUSH
40726: LD_INT 121
40728: PPUSH
40729: CALL 25687 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40733: LD_ADDR_EXP 109
40737: PUSH
40738: LD_EXP 109
40742: PPUSH
40743: LD_VAR 0 2
40747: PPUSH
40748: EMPTY
40749: PPUSH
40750: CALL_OW 1
40754: ST_TO_ADDR
// end ; continue ;
40755: GO 40323
// end ; for j in tmp do
40757: LD_ADDR_VAR 0 3
40761: PUSH
40762: LD_VAR 0 8
40766: PUSH
40767: FOR_IN
40768: IFFALSE 41104
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40770: LD_VAR 0 3
40774: PUSH
40775: LD_EXP 109
40779: PUSH
40780: LD_VAR 0 2
40784: ARRAY
40785: IN
40786: NOT
40787: PUSH
40788: LD_EXP 109
40792: PUSH
40793: LD_VAR 0 2
40797: ARRAY
40798: PUSH
40799: LD_INT 3
40801: LESS
40802: AND
40803: IFFALSE 40861
// begin SetTag ( j , 121 ) ;
40805: LD_VAR 0 3
40809: PPUSH
40810: LD_INT 121
40812: PPUSH
40813: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40817: LD_ADDR_EXP 109
40821: PUSH
40822: LD_EXP 109
40826: PPUSH
40827: LD_VAR 0 2
40831: PUSH
40832: LD_EXP 109
40836: PUSH
40837: LD_VAR 0 2
40841: ARRAY
40842: PUSH
40843: LD_INT 1
40845: PLUS
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PPUSH
40851: LD_VAR 0 3
40855: PPUSH
40856: CALL 57174 0 3
40860: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40861: LD_VAR 0 3
40865: PUSH
40866: LD_EXP 109
40870: PUSH
40871: LD_VAR 0 2
40875: ARRAY
40876: IN
40877: IFFALSE 41102
// begin if GetClass ( j ) <> 4 then
40879: LD_VAR 0 3
40883: PPUSH
40884: CALL_OW 257
40888: PUSH
40889: LD_INT 4
40891: NONEQUAL
40892: IFFALSE 40945
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40894: LD_ADDR_EXP 109
40898: PUSH
40899: LD_EXP 109
40903: PPUSH
40904: LD_VAR 0 2
40908: PPUSH
40909: LD_EXP 109
40913: PUSH
40914: LD_VAR 0 2
40918: ARRAY
40919: PUSH
40920: LD_VAR 0 3
40924: DIFF
40925: PPUSH
40926: CALL_OW 1
40930: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40931: LD_VAR 0 3
40935: PPUSH
40936: LD_INT 0
40938: PPUSH
40939: CALL_OW 109
// continue ;
40943: GO 40767
// end ; if IsInUnit ( j ) then
40945: LD_VAR 0 3
40949: PPUSH
40950: CALL_OW 310
40954: IFFALSE 40965
// ComExitBuilding ( j ) ;
40956: LD_VAR 0 3
40960: PPUSH
40961: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40965: LD_ADDR_VAR 0 6
40969: PUSH
40970: LD_VAR 0 7
40974: PPUSH
40975: LD_VAR 0 3
40979: PPUSH
40980: CALL_OW 74
40984: ST_TO_ADDR
// if not ape then
40985: LD_VAR 0 6
40989: NOT
40990: IFFALSE 40994
// break ;
40992: GO 41104
// x := GetX ( ape ) ;
40994: LD_ADDR_VAR 0 4
40998: PUSH
40999: LD_VAR 0 6
41003: PPUSH
41004: CALL_OW 250
41008: ST_TO_ADDR
// y := GetY ( ape ) ;
41009: LD_ADDR_VAR 0 5
41013: PUSH
41014: LD_VAR 0 6
41018: PPUSH
41019: CALL_OW 251
41023: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
41024: LD_VAR 0 4
41028: PPUSH
41029: LD_VAR 0 5
41033: PPUSH
41034: CALL_OW 488
41038: NOT
41039: PUSH
41040: LD_VAR 0 11
41044: PPUSH
41045: LD_VAR 0 4
41049: PPUSH
41050: LD_VAR 0 5
41054: PPUSH
41055: LD_INT 20
41057: PPUSH
41058: CALL 58070 0 4
41062: PUSH
41063: LD_INT 4
41065: ARRAY
41066: OR
41067: IFFALSE 41071
// break ;
41069: GO 41104
// if not HasTask ( j ) then
41071: LD_VAR 0 3
41075: PPUSH
41076: CALL_OW 314
41080: NOT
41081: IFFALSE 41102
// ComTameXY ( j , x , y ) ;
41083: LD_VAR 0 3
41087: PPUSH
41088: LD_VAR 0 4
41092: PPUSH
41093: LD_VAR 0 5
41097: PPUSH
41098: CALL_OW 131
// end ; end ;
41102: GO 40767
41104: POP
41105: POP
// end ;
41106: GO 40323
41108: POP
41109: POP
// end ;
41110: LD_VAR 0 1
41114: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
41115: LD_INT 0
41117: PPUSH
41118: PPUSH
41119: PPUSH
41120: PPUSH
41121: PPUSH
41122: PPUSH
41123: PPUSH
41124: PPUSH
// if not mc_bases then
41125: LD_EXP 78
41129: NOT
41130: IFFALSE 41134
// exit ;
41132: GO 41760
// for i = 1 to mc_bases do
41134: LD_ADDR_VAR 0 2
41138: PUSH
41139: DOUBLE
41140: LD_INT 1
41142: DEC
41143: ST_TO_ADDR
41144: LD_EXP 78
41148: PUSH
41149: FOR_TO
41150: IFFALSE 41758
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
41152: LD_EXP 107
41156: PUSH
41157: LD_VAR 0 2
41161: ARRAY
41162: NOT
41163: PUSH
41164: LD_EXP 107
41168: PUSH
41169: LD_VAR 0 2
41173: ARRAY
41174: PPUSH
41175: LD_INT 25
41177: PUSH
41178: LD_INT 12
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PPUSH
41185: CALL_OW 72
41189: NOT
41190: OR
41191: IFFALSE 41195
// continue ;
41193: GO 41149
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41195: LD_ADDR_VAR 0 5
41199: PUSH
41200: LD_EXP 107
41204: PUSH
41205: LD_VAR 0 2
41209: ARRAY
41210: PUSH
41211: LD_INT 1
41213: ARRAY
41214: PPUSH
41215: CALL_OW 255
41219: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41220: LD_VAR 0 5
41224: PPUSH
41225: LD_INT 2
41227: PPUSH
41228: CALL_OW 325
41232: IFFALSE 41485
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41234: LD_ADDR_VAR 0 4
41238: PUSH
41239: LD_EXP 107
41243: PUSH
41244: LD_VAR 0 2
41248: ARRAY
41249: PPUSH
41250: LD_INT 25
41252: PUSH
41253: LD_INT 16
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PPUSH
41260: CALL_OW 72
41264: ST_TO_ADDR
// if tmp < 6 then
41265: LD_VAR 0 4
41269: PUSH
41270: LD_INT 6
41272: LESS
41273: IFFALSE 41485
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41275: LD_ADDR_VAR 0 6
41279: PUSH
41280: LD_EXP 78
41284: PUSH
41285: LD_VAR 0 2
41289: ARRAY
41290: PPUSH
41291: LD_INT 2
41293: PUSH
41294: LD_INT 30
41296: PUSH
41297: LD_INT 0
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 30
41306: PUSH
41307: LD_INT 1
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: LIST
41318: PPUSH
41319: CALL_OW 72
41323: ST_TO_ADDR
// if depot then
41324: LD_VAR 0 6
41328: IFFALSE 41485
// begin selected := 0 ;
41330: LD_ADDR_VAR 0 7
41334: PUSH
41335: LD_INT 0
41337: ST_TO_ADDR
// for j in depot do
41338: LD_ADDR_VAR 0 3
41342: PUSH
41343: LD_VAR 0 6
41347: PUSH
41348: FOR_IN
41349: IFFALSE 41380
// begin if UnitsInside ( j ) < 6 then
41351: LD_VAR 0 3
41355: PPUSH
41356: CALL_OW 313
41360: PUSH
41361: LD_INT 6
41363: LESS
41364: IFFALSE 41378
// begin selected := j ;
41366: LD_ADDR_VAR 0 7
41370: PUSH
41371: LD_VAR 0 3
41375: ST_TO_ADDR
// break ;
41376: GO 41380
// end ; end ;
41378: GO 41348
41380: POP
41381: POP
// if selected then
41382: LD_VAR 0 7
41386: IFFALSE 41485
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41388: LD_ADDR_VAR 0 3
41392: PUSH
41393: LD_EXP 107
41397: PUSH
41398: LD_VAR 0 2
41402: ARRAY
41403: PPUSH
41404: LD_INT 25
41406: PUSH
41407: LD_INT 12
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: PPUSH
41414: CALL_OW 72
41418: PUSH
41419: FOR_IN
41420: IFFALSE 41483
// if not HasTask ( j ) then
41422: LD_VAR 0 3
41426: PPUSH
41427: CALL_OW 314
41431: NOT
41432: IFFALSE 41481
// begin if not IsInUnit ( j ) then
41434: LD_VAR 0 3
41438: PPUSH
41439: CALL_OW 310
41443: NOT
41444: IFFALSE 41460
// ComEnterUnit ( j , selected ) ;
41446: LD_VAR 0 3
41450: PPUSH
41451: LD_VAR 0 7
41455: PPUSH
41456: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41460: LD_VAR 0 3
41464: PPUSH
41465: LD_INT 16
41467: PPUSH
41468: CALL_OW 183
// AddComExitBuilding ( j ) ;
41472: LD_VAR 0 3
41476: PPUSH
41477: CALL_OW 182
// end ;
41481: GO 41419
41483: POP
41484: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41485: LD_VAR 0 5
41489: PPUSH
41490: LD_INT 11
41492: PPUSH
41493: CALL_OW 325
41497: IFFALSE 41756
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41499: LD_ADDR_VAR 0 4
41503: PUSH
41504: LD_EXP 107
41508: PUSH
41509: LD_VAR 0 2
41513: ARRAY
41514: PPUSH
41515: LD_INT 25
41517: PUSH
41518: LD_INT 16
41520: PUSH
41521: EMPTY
41522: LIST
41523: LIST
41524: PPUSH
41525: CALL_OW 72
41529: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41530: LD_VAR 0 4
41534: PUSH
41535: LD_INT 6
41537: GREATEREQUAL
41538: PUSH
41539: LD_VAR 0 5
41543: PPUSH
41544: LD_INT 2
41546: PPUSH
41547: CALL_OW 325
41551: NOT
41552: OR
41553: IFFALSE 41756
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41555: LD_ADDR_VAR 0 8
41559: PUSH
41560: LD_EXP 78
41564: PUSH
41565: LD_VAR 0 2
41569: ARRAY
41570: PPUSH
41571: LD_INT 2
41573: PUSH
41574: LD_INT 30
41576: PUSH
41577: LD_INT 4
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 30
41586: PUSH
41587: LD_INT 5
41589: PUSH
41590: EMPTY
41591: LIST
41592: LIST
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: LIST
41598: PPUSH
41599: CALL_OW 72
41603: ST_TO_ADDR
// if barracks then
41604: LD_VAR 0 8
41608: IFFALSE 41756
// begin selected := 0 ;
41610: LD_ADDR_VAR 0 7
41614: PUSH
41615: LD_INT 0
41617: ST_TO_ADDR
// for j in barracks do
41618: LD_ADDR_VAR 0 3
41622: PUSH
41623: LD_VAR 0 8
41627: PUSH
41628: FOR_IN
41629: IFFALSE 41660
// begin if UnitsInside ( j ) < 6 then
41631: LD_VAR 0 3
41635: PPUSH
41636: CALL_OW 313
41640: PUSH
41641: LD_INT 6
41643: LESS
41644: IFFALSE 41658
// begin selected := j ;
41646: LD_ADDR_VAR 0 7
41650: PUSH
41651: LD_VAR 0 3
41655: ST_TO_ADDR
// break ;
41656: GO 41660
// end ; end ;
41658: GO 41628
41660: POP
41661: POP
// if selected then
41662: LD_VAR 0 7
41666: IFFALSE 41756
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41668: LD_ADDR_VAR 0 3
41672: PUSH
41673: LD_EXP 107
41677: PUSH
41678: LD_VAR 0 2
41682: ARRAY
41683: PPUSH
41684: LD_INT 25
41686: PUSH
41687: LD_INT 12
41689: PUSH
41690: EMPTY
41691: LIST
41692: LIST
41693: PPUSH
41694: CALL_OW 72
41698: PUSH
41699: FOR_IN
41700: IFFALSE 41754
// if not IsInUnit ( j ) and not HasTask ( j ) then
41702: LD_VAR 0 3
41706: PPUSH
41707: CALL_OW 310
41711: NOT
41712: PUSH
41713: LD_VAR 0 3
41717: PPUSH
41718: CALL_OW 314
41722: NOT
41723: AND
41724: IFFALSE 41752
// begin ComEnterUnit ( j , selected ) ;
41726: LD_VAR 0 3
41730: PPUSH
41731: LD_VAR 0 7
41735: PPUSH
41736: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41740: LD_VAR 0 3
41744: PPUSH
41745: LD_INT 15
41747: PPUSH
41748: CALL_OW 183
// end ;
41752: GO 41699
41754: POP
41755: POP
// end ; end ; end ; end ; end ;
41756: GO 41149
41758: POP
41759: POP
// end ;
41760: LD_VAR 0 1
41764: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41765: LD_INT 0
41767: PPUSH
41768: PPUSH
41769: PPUSH
41770: PPUSH
// if not mc_bases then
41771: LD_EXP 78
41775: NOT
41776: IFFALSE 41780
// exit ;
41778: GO 41958
// for i = 1 to mc_bases do
41780: LD_ADDR_VAR 0 2
41784: PUSH
41785: DOUBLE
41786: LD_INT 1
41788: DEC
41789: ST_TO_ADDR
41790: LD_EXP 78
41794: PUSH
41795: FOR_TO
41796: IFFALSE 41956
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41798: LD_ADDR_VAR 0 4
41802: PUSH
41803: LD_EXP 78
41807: PUSH
41808: LD_VAR 0 2
41812: ARRAY
41813: PPUSH
41814: LD_INT 25
41816: PUSH
41817: LD_INT 9
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PPUSH
41824: CALL_OW 72
41828: ST_TO_ADDR
// if not tmp then
41829: LD_VAR 0 4
41833: NOT
41834: IFFALSE 41838
// continue ;
41836: GO 41795
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41838: LD_EXP 104
41842: PUSH
41843: LD_VAR 0 2
41847: ARRAY
41848: PPUSH
41849: LD_INT 29
41851: PPUSH
41852: CALL_OW 325
41856: NOT
41857: PUSH
41858: LD_EXP 104
41862: PUSH
41863: LD_VAR 0 2
41867: ARRAY
41868: PPUSH
41869: LD_INT 28
41871: PPUSH
41872: CALL_OW 325
41876: NOT
41877: AND
41878: IFFALSE 41882
// continue ;
41880: GO 41795
// for j in tmp do
41882: LD_ADDR_VAR 0 3
41886: PUSH
41887: LD_VAR 0 4
41891: PUSH
41892: FOR_IN
41893: IFFALSE 41952
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41895: LD_VAR 0 3
41899: PUSH
41900: LD_EXP 81
41904: PUSH
41905: LD_VAR 0 2
41909: ARRAY
41910: PUSH
41911: LD_INT 1
41913: ARRAY
41914: IN
41915: NOT
41916: PUSH
41917: LD_VAR 0 3
41921: PUSH
41922: LD_EXP 81
41926: PUSH
41927: LD_VAR 0 2
41931: ARRAY
41932: PUSH
41933: LD_INT 2
41935: ARRAY
41936: IN
41937: NOT
41938: AND
41939: IFFALSE 41950
// ComSpaceTimeShoot ( j ) ;
41941: LD_VAR 0 3
41945: PPUSH
41946: CALL 53159 0 1
41950: GO 41892
41952: POP
41953: POP
// end ;
41954: GO 41795
41956: POP
41957: POP
// end ;
41958: LD_VAR 0 1
41962: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41963: LD_INT 0
41965: PPUSH
41966: PPUSH
41967: PPUSH
41968: PPUSH
41969: PPUSH
41970: PPUSH
41971: PPUSH
41972: PPUSH
41973: PPUSH
// if not mc_bases then
41974: LD_EXP 78
41978: NOT
41979: IFFALSE 41983
// exit ;
41981: GO 42605
// for i = 1 to mc_bases do
41983: LD_ADDR_VAR 0 2
41987: PUSH
41988: DOUBLE
41989: LD_INT 1
41991: DEC
41992: ST_TO_ADDR
41993: LD_EXP 78
41997: PUSH
41998: FOR_TO
41999: IFFALSE 42603
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
42001: LD_EXP 113
42005: PUSH
42006: LD_VAR 0 2
42010: ARRAY
42011: NOT
42012: PUSH
42013: LD_INT 38
42015: PPUSH
42016: LD_EXP 104
42020: PUSH
42021: LD_VAR 0 2
42025: ARRAY
42026: PPUSH
42027: CALL_OW 321
42031: PUSH
42032: LD_INT 2
42034: NONEQUAL
42035: OR
42036: IFFALSE 42040
// continue ;
42038: GO 41998
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
42040: LD_ADDR_VAR 0 8
42044: PUSH
42045: LD_EXP 78
42049: PUSH
42050: LD_VAR 0 2
42054: ARRAY
42055: PPUSH
42056: LD_INT 30
42058: PUSH
42059: LD_INT 34
42061: PUSH
42062: EMPTY
42063: LIST
42064: LIST
42065: PPUSH
42066: CALL_OW 72
42070: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
42071: LD_ADDR_VAR 0 9
42075: PUSH
42076: LD_EXP 78
42080: PUSH
42081: LD_VAR 0 2
42085: ARRAY
42086: PPUSH
42087: LD_INT 25
42089: PUSH
42090: LD_INT 4
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: PPUSH
42097: CALL_OW 72
42101: PPUSH
42102: LD_INT 0
42104: PPUSH
42105: CALL 87086 0 2
42109: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
42110: LD_VAR 0 9
42114: NOT
42115: PUSH
42116: LD_VAR 0 8
42120: NOT
42121: OR
42122: PUSH
42123: LD_EXP 78
42127: PUSH
42128: LD_VAR 0 2
42132: ARRAY
42133: PPUSH
42134: LD_INT 124
42136: PPUSH
42137: CALL 87086 0 2
42141: OR
42142: IFFALSE 42146
// continue ;
42144: GO 41998
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
42146: LD_EXP 114
42150: PUSH
42151: LD_VAR 0 2
42155: ARRAY
42156: PUSH
42157: LD_EXP 113
42161: PUSH
42162: LD_VAR 0 2
42166: ARRAY
42167: LESS
42168: PUSH
42169: LD_EXP 114
42173: PUSH
42174: LD_VAR 0 2
42178: ARRAY
42179: PUSH
42180: LD_VAR 0 8
42184: LESS
42185: AND
42186: IFFALSE 42601
// begin tmp := sci [ 1 ] ;
42188: LD_ADDR_VAR 0 7
42192: PUSH
42193: LD_VAR 0 9
42197: PUSH
42198: LD_INT 1
42200: ARRAY
42201: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42202: LD_VAR 0 7
42206: PPUSH
42207: LD_INT 124
42209: PPUSH
42210: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42214: LD_ADDR_VAR 0 3
42218: PUSH
42219: DOUBLE
42220: LD_EXP 113
42224: PUSH
42225: LD_VAR 0 2
42229: ARRAY
42230: INC
42231: ST_TO_ADDR
42232: LD_EXP 113
42236: PUSH
42237: LD_VAR 0 2
42241: ARRAY
42242: PUSH
42243: FOR_DOWNTO
42244: IFFALSE 42587
// begin if IsInUnit ( tmp ) then
42246: LD_VAR 0 7
42250: PPUSH
42251: CALL_OW 310
42255: IFFALSE 42266
// ComExitBuilding ( tmp ) ;
42257: LD_VAR 0 7
42261: PPUSH
42262: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42266: LD_INT 35
42268: PPUSH
42269: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42273: LD_VAR 0 7
42277: PPUSH
42278: CALL_OW 310
42282: NOT
42283: PUSH
42284: LD_VAR 0 7
42288: PPUSH
42289: CALL_OW 314
42293: NOT
42294: AND
42295: IFFALSE 42266
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42297: LD_ADDR_VAR 0 6
42301: PUSH
42302: LD_VAR 0 7
42306: PPUSH
42307: CALL_OW 250
42311: PUSH
42312: LD_VAR 0 7
42316: PPUSH
42317: CALL_OW 251
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42326: LD_INT 35
42328: PPUSH
42329: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42333: LD_ADDR_VAR 0 4
42337: PUSH
42338: LD_EXP 113
42342: PUSH
42343: LD_VAR 0 2
42347: ARRAY
42348: PUSH
42349: LD_VAR 0 3
42353: ARRAY
42354: PUSH
42355: LD_INT 1
42357: ARRAY
42358: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42359: LD_ADDR_VAR 0 5
42363: PUSH
42364: LD_EXP 113
42368: PUSH
42369: LD_VAR 0 2
42373: ARRAY
42374: PUSH
42375: LD_VAR 0 3
42379: ARRAY
42380: PUSH
42381: LD_INT 2
42383: ARRAY
42384: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42385: LD_VAR 0 7
42389: PPUSH
42390: LD_INT 10
42392: PPUSH
42393: CALL 59771 0 2
42397: PUSH
42398: LD_INT 4
42400: ARRAY
42401: IFFALSE 42439
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42403: LD_VAR 0 7
42407: PPUSH
42408: LD_VAR 0 6
42412: PUSH
42413: LD_INT 1
42415: ARRAY
42416: PPUSH
42417: LD_VAR 0 6
42421: PUSH
42422: LD_INT 2
42424: ARRAY
42425: PPUSH
42426: CALL_OW 111
// wait ( 0 0$10 ) ;
42430: LD_INT 350
42432: PPUSH
42433: CALL_OW 67
// end else
42437: GO 42465
// begin ComMoveXY ( tmp , x , y ) ;
42439: LD_VAR 0 7
42443: PPUSH
42444: LD_VAR 0 4
42448: PPUSH
42449: LD_VAR 0 5
42453: PPUSH
42454: CALL_OW 111
// wait ( 0 0$3 ) ;
42458: LD_INT 105
42460: PPUSH
42461: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42465: LD_VAR 0 7
42469: PPUSH
42470: LD_VAR 0 4
42474: PPUSH
42475: LD_VAR 0 5
42479: PPUSH
42480: CALL_OW 307
42484: IFFALSE 42326
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42486: LD_VAR 0 7
42490: PPUSH
42491: LD_VAR 0 4
42495: PPUSH
42496: LD_VAR 0 5
42500: PPUSH
42501: LD_VAR 0 8
42505: PUSH
42506: LD_VAR 0 3
42510: ARRAY
42511: PPUSH
42512: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42516: LD_INT 35
42518: PPUSH
42519: CALL_OW 67
// until not HasTask ( tmp ) ;
42523: LD_VAR 0 7
42527: PPUSH
42528: CALL_OW 314
42532: NOT
42533: IFFALSE 42516
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42535: LD_ADDR_EXP 114
42539: PUSH
42540: LD_EXP 114
42544: PPUSH
42545: LD_VAR 0 2
42549: PUSH
42550: LD_EXP 114
42554: PUSH
42555: LD_VAR 0 2
42559: ARRAY
42560: PUSH
42561: LD_INT 1
42563: PLUS
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PPUSH
42569: LD_VAR 0 8
42573: PUSH
42574: LD_VAR 0 3
42578: ARRAY
42579: PPUSH
42580: CALL 57174 0 3
42584: ST_TO_ADDR
// end ;
42585: GO 42243
42587: POP
42588: POP
// MC_Reset ( i , 124 ) ;
42589: LD_VAR 0 2
42593: PPUSH
42594: LD_INT 124
42596: PPUSH
42597: CALL 25687 0 2
// end ; end ;
42601: GO 41998
42603: POP
42604: POP
// end ;
42605: LD_VAR 0 1
42609: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42610: LD_INT 0
42612: PPUSH
42613: PPUSH
42614: PPUSH
// if not mc_bases then
42615: LD_EXP 78
42619: NOT
42620: IFFALSE 42624
// exit ;
42622: GO 43230
// for i = 1 to mc_bases do
42624: LD_ADDR_VAR 0 2
42628: PUSH
42629: DOUBLE
42630: LD_INT 1
42632: DEC
42633: ST_TO_ADDR
42634: LD_EXP 78
42638: PUSH
42639: FOR_TO
42640: IFFALSE 43228
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42642: LD_ADDR_VAR 0 3
42646: PUSH
42647: LD_EXP 78
42651: PUSH
42652: LD_VAR 0 2
42656: ARRAY
42657: PPUSH
42658: LD_INT 25
42660: PUSH
42661: LD_INT 4
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PPUSH
42668: CALL_OW 72
42672: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42673: LD_VAR 0 3
42677: NOT
42678: PUSH
42679: LD_EXP 115
42683: PUSH
42684: LD_VAR 0 2
42688: ARRAY
42689: NOT
42690: OR
42691: PUSH
42692: LD_EXP 78
42696: PUSH
42697: LD_VAR 0 2
42701: ARRAY
42702: PPUSH
42703: LD_INT 2
42705: PUSH
42706: LD_INT 30
42708: PUSH
42709: LD_INT 0
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: LD_INT 30
42718: PUSH
42719: LD_INT 1
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: LIST
42730: PPUSH
42731: CALL_OW 72
42735: NOT
42736: OR
42737: IFFALSE 42787
// begin if mc_deposits_finder [ i ] then
42739: LD_EXP 116
42743: PUSH
42744: LD_VAR 0 2
42748: ARRAY
42749: IFFALSE 42785
// begin MC_Reset ( i , 125 ) ;
42751: LD_VAR 0 2
42755: PPUSH
42756: LD_INT 125
42758: PPUSH
42759: CALL 25687 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42763: LD_ADDR_EXP 116
42767: PUSH
42768: LD_EXP 116
42772: PPUSH
42773: LD_VAR 0 2
42777: PPUSH
42778: EMPTY
42779: PPUSH
42780: CALL_OW 1
42784: ST_TO_ADDR
// end ; continue ;
42785: GO 42639
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42787: LD_EXP 115
42791: PUSH
42792: LD_VAR 0 2
42796: ARRAY
42797: PUSH
42798: LD_INT 1
42800: ARRAY
42801: PUSH
42802: LD_INT 3
42804: ARRAY
42805: PUSH
42806: LD_INT 1
42808: EQUAL
42809: PUSH
42810: LD_INT 20
42812: PPUSH
42813: LD_EXP 104
42817: PUSH
42818: LD_VAR 0 2
42822: ARRAY
42823: PPUSH
42824: CALL_OW 321
42828: PUSH
42829: LD_INT 2
42831: NONEQUAL
42832: AND
42833: IFFALSE 42883
// begin if mc_deposits_finder [ i ] then
42835: LD_EXP 116
42839: PUSH
42840: LD_VAR 0 2
42844: ARRAY
42845: IFFALSE 42881
// begin MC_Reset ( i , 125 ) ;
42847: LD_VAR 0 2
42851: PPUSH
42852: LD_INT 125
42854: PPUSH
42855: CALL 25687 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42859: LD_ADDR_EXP 116
42863: PUSH
42864: LD_EXP 116
42868: PPUSH
42869: LD_VAR 0 2
42873: PPUSH
42874: EMPTY
42875: PPUSH
42876: CALL_OW 1
42880: ST_TO_ADDR
// end ; continue ;
42881: GO 42639
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42883: LD_EXP 115
42887: PUSH
42888: LD_VAR 0 2
42892: ARRAY
42893: PUSH
42894: LD_INT 1
42896: ARRAY
42897: PUSH
42898: LD_INT 1
42900: ARRAY
42901: PPUSH
42902: LD_EXP 115
42906: PUSH
42907: LD_VAR 0 2
42911: ARRAY
42912: PUSH
42913: LD_INT 1
42915: ARRAY
42916: PUSH
42917: LD_INT 2
42919: ARRAY
42920: PPUSH
42921: LD_EXP 104
42925: PUSH
42926: LD_VAR 0 2
42930: ARRAY
42931: PPUSH
42932: CALL_OW 440
42936: IFFALSE 42979
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42938: LD_ADDR_EXP 115
42942: PUSH
42943: LD_EXP 115
42947: PPUSH
42948: LD_VAR 0 2
42952: PPUSH
42953: LD_EXP 115
42957: PUSH
42958: LD_VAR 0 2
42962: ARRAY
42963: PPUSH
42964: LD_INT 1
42966: PPUSH
42967: CALL_OW 3
42971: PPUSH
42972: CALL_OW 1
42976: ST_TO_ADDR
42977: GO 43226
// begin if not mc_deposits_finder [ i ] then
42979: LD_EXP 116
42983: PUSH
42984: LD_VAR 0 2
42988: ARRAY
42989: NOT
42990: IFFALSE 43042
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42992: LD_ADDR_EXP 116
42996: PUSH
42997: LD_EXP 116
43001: PPUSH
43002: LD_VAR 0 2
43006: PPUSH
43007: LD_VAR 0 3
43011: PUSH
43012: LD_INT 1
43014: ARRAY
43015: PUSH
43016: EMPTY
43017: LIST
43018: PPUSH
43019: CALL_OW 1
43023: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
43024: LD_VAR 0 3
43028: PUSH
43029: LD_INT 1
43031: ARRAY
43032: PPUSH
43033: LD_INT 125
43035: PPUSH
43036: CALL_OW 109
// end else
43040: GO 43226
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
43042: LD_EXP 116
43046: PUSH
43047: LD_VAR 0 2
43051: ARRAY
43052: PUSH
43053: LD_INT 1
43055: ARRAY
43056: PPUSH
43057: CALL_OW 310
43061: IFFALSE 43084
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
43063: LD_EXP 116
43067: PUSH
43068: LD_VAR 0 2
43072: ARRAY
43073: PUSH
43074: LD_INT 1
43076: ARRAY
43077: PPUSH
43078: CALL_OW 122
43082: GO 43226
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
43084: LD_EXP 116
43088: PUSH
43089: LD_VAR 0 2
43093: ARRAY
43094: PUSH
43095: LD_INT 1
43097: ARRAY
43098: PPUSH
43099: CALL_OW 314
43103: NOT
43104: PUSH
43105: LD_EXP 116
43109: PUSH
43110: LD_VAR 0 2
43114: ARRAY
43115: PUSH
43116: LD_INT 1
43118: ARRAY
43119: PPUSH
43120: LD_EXP 115
43124: PUSH
43125: LD_VAR 0 2
43129: ARRAY
43130: PUSH
43131: LD_INT 1
43133: ARRAY
43134: PUSH
43135: LD_INT 1
43137: ARRAY
43138: PPUSH
43139: LD_EXP 115
43143: PUSH
43144: LD_VAR 0 2
43148: ARRAY
43149: PUSH
43150: LD_INT 1
43152: ARRAY
43153: PUSH
43154: LD_INT 2
43156: ARRAY
43157: PPUSH
43158: CALL_OW 297
43162: PUSH
43163: LD_INT 6
43165: GREATER
43166: AND
43167: IFFALSE 43226
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
43169: LD_EXP 116
43173: PUSH
43174: LD_VAR 0 2
43178: ARRAY
43179: PUSH
43180: LD_INT 1
43182: ARRAY
43183: PPUSH
43184: LD_EXP 115
43188: PUSH
43189: LD_VAR 0 2
43193: ARRAY
43194: PUSH
43195: LD_INT 1
43197: ARRAY
43198: PUSH
43199: LD_INT 1
43201: ARRAY
43202: PPUSH
43203: LD_EXP 115
43207: PUSH
43208: LD_VAR 0 2
43212: ARRAY
43213: PUSH
43214: LD_INT 1
43216: ARRAY
43217: PUSH
43218: LD_INT 2
43220: ARRAY
43221: PPUSH
43222: CALL_OW 111
// end ; end ; end ;
43226: GO 42639
43228: POP
43229: POP
// end ;
43230: LD_VAR 0 1
43234: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43235: LD_INT 0
43237: PPUSH
43238: PPUSH
43239: PPUSH
43240: PPUSH
43241: PPUSH
43242: PPUSH
43243: PPUSH
43244: PPUSH
43245: PPUSH
43246: PPUSH
43247: PPUSH
// if not mc_bases then
43248: LD_EXP 78
43252: NOT
43253: IFFALSE 43257
// exit ;
43255: GO 44197
// for i = 1 to mc_bases do
43257: LD_ADDR_VAR 0 2
43261: PUSH
43262: DOUBLE
43263: LD_INT 1
43265: DEC
43266: ST_TO_ADDR
43267: LD_EXP 78
43271: PUSH
43272: FOR_TO
43273: IFFALSE 44195
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43275: LD_EXP 78
43279: PUSH
43280: LD_VAR 0 2
43284: ARRAY
43285: NOT
43286: PUSH
43287: LD_EXP 101
43291: PUSH
43292: LD_VAR 0 2
43296: ARRAY
43297: OR
43298: IFFALSE 43302
// continue ;
43300: GO 43272
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43302: LD_ADDR_VAR 0 7
43306: PUSH
43307: LD_EXP 78
43311: PUSH
43312: LD_VAR 0 2
43316: ARRAY
43317: PUSH
43318: LD_INT 1
43320: ARRAY
43321: PPUSH
43322: CALL_OW 248
43326: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43327: LD_VAR 0 7
43331: PUSH
43332: LD_INT 3
43334: EQUAL
43335: PUSH
43336: LD_EXP 97
43340: PUSH
43341: LD_VAR 0 2
43345: ARRAY
43346: PUSH
43347: LD_EXP 100
43351: PUSH
43352: LD_VAR 0 2
43356: ARRAY
43357: UNION
43358: PPUSH
43359: LD_INT 33
43361: PUSH
43362: LD_INT 2
43364: PUSH
43365: EMPTY
43366: LIST
43367: LIST
43368: PPUSH
43369: CALL_OW 72
43373: NOT
43374: OR
43375: IFFALSE 43379
// continue ;
43377: GO 43272
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43379: LD_ADDR_VAR 0 9
43383: PUSH
43384: LD_EXP 78
43388: PUSH
43389: LD_VAR 0 2
43393: ARRAY
43394: PPUSH
43395: LD_INT 30
43397: PUSH
43398: LD_INT 36
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PPUSH
43405: CALL_OW 72
43409: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43410: LD_ADDR_VAR 0 10
43414: PUSH
43415: LD_EXP 97
43419: PUSH
43420: LD_VAR 0 2
43424: ARRAY
43425: PPUSH
43426: LD_INT 34
43428: PUSH
43429: LD_INT 31
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: PPUSH
43436: CALL_OW 72
43440: ST_TO_ADDR
// if not cts and not mcts then
43441: LD_VAR 0 9
43445: NOT
43446: PUSH
43447: LD_VAR 0 10
43451: NOT
43452: AND
43453: IFFALSE 43457
// continue ;
43455: GO 43272
// x := cts ;
43457: LD_ADDR_VAR 0 11
43461: PUSH
43462: LD_VAR 0 9
43466: ST_TO_ADDR
// if not x then
43467: LD_VAR 0 11
43471: NOT
43472: IFFALSE 43484
// x := mcts ;
43474: LD_ADDR_VAR 0 11
43478: PUSH
43479: LD_VAR 0 10
43483: ST_TO_ADDR
// if not x then
43484: LD_VAR 0 11
43488: NOT
43489: IFFALSE 43493
// continue ;
43491: GO 43272
// if mc_remote_driver [ i ] then
43493: LD_EXP 118
43497: PUSH
43498: LD_VAR 0 2
43502: ARRAY
43503: IFFALSE 43890
// for j in mc_remote_driver [ i ] do
43505: LD_ADDR_VAR 0 3
43509: PUSH
43510: LD_EXP 118
43514: PUSH
43515: LD_VAR 0 2
43519: ARRAY
43520: PUSH
43521: FOR_IN
43522: IFFALSE 43888
// begin if GetClass ( j ) <> 3 then
43524: LD_VAR 0 3
43528: PPUSH
43529: CALL_OW 257
43533: PUSH
43534: LD_INT 3
43536: NONEQUAL
43537: IFFALSE 43590
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43539: LD_ADDR_EXP 118
43543: PUSH
43544: LD_EXP 118
43548: PPUSH
43549: LD_VAR 0 2
43553: PPUSH
43554: LD_EXP 118
43558: PUSH
43559: LD_VAR 0 2
43563: ARRAY
43564: PUSH
43565: LD_VAR 0 3
43569: DIFF
43570: PPUSH
43571: CALL_OW 1
43575: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43576: LD_VAR 0 3
43580: PPUSH
43581: LD_INT 0
43583: PPUSH
43584: CALL_OW 109
// continue ;
43588: GO 43521
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43590: LD_EXP 97
43594: PUSH
43595: LD_VAR 0 2
43599: ARRAY
43600: PPUSH
43601: LD_INT 34
43603: PUSH
43604: LD_INT 31
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: LD_INT 58
43613: PUSH
43614: EMPTY
43615: LIST
43616: PUSH
43617: EMPTY
43618: LIST
43619: LIST
43620: PPUSH
43621: CALL_OW 72
43625: PUSH
43626: LD_VAR 0 3
43630: PPUSH
43631: CALL 87121 0 1
43635: NOT
43636: AND
43637: IFFALSE 43708
// begin if IsInUnit ( j ) then
43639: LD_VAR 0 3
43643: PPUSH
43644: CALL_OW 310
43648: IFFALSE 43659
// ComExitBuilding ( j ) ;
43650: LD_VAR 0 3
43654: PPUSH
43655: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43659: LD_VAR 0 3
43663: PPUSH
43664: LD_EXP 97
43668: PUSH
43669: LD_VAR 0 2
43673: ARRAY
43674: PPUSH
43675: LD_INT 34
43677: PUSH
43678: LD_INT 31
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: LD_INT 58
43687: PUSH
43688: EMPTY
43689: LIST
43690: PUSH
43691: EMPTY
43692: LIST
43693: LIST
43694: PPUSH
43695: CALL_OW 72
43699: PUSH
43700: LD_INT 1
43702: ARRAY
43703: PPUSH
43704: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43708: LD_VAR 0 3
43712: PPUSH
43713: CALL_OW 310
43717: NOT
43718: PUSH
43719: LD_VAR 0 3
43723: PPUSH
43724: CALL_OW 310
43728: PPUSH
43729: CALL_OW 266
43733: PUSH
43734: LD_INT 36
43736: NONEQUAL
43737: PUSH
43738: LD_VAR 0 3
43742: PPUSH
43743: CALL 87121 0 1
43747: NOT
43748: AND
43749: OR
43750: IFFALSE 43886
// begin if IsInUnit ( j ) then
43752: LD_VAR 0 3
43756: PPUSH
43757: CALL_OW 310
43761: IFFALSE 43772
// ComExitBuilding ( j ) ;
43763: LD_VAR 0 3
43767: PPUSH
43768: CALL_OW 122
// ct := 0 ;
43772: LD_ADDR_VAR 0 8
43776: PUSH
43777: LD_INT 0
43779: ST_TO_ADDR
// for k in x do
43780: LD_ADDR_VAR 0 4
43784: PUSH
43785: LD_VAR 0 11
43789: PUSH
43790: FOR_IN
43791: IFFALSE 43864
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43793: LD_VAR 0 4
43797: PPUSH
43798: CALL_OW 264
43802: PUSH
43803: LD_INT 31
43805: EQUAL
43806: PUSH
43807: LD_VAR 0 4
43811: PPUSH
43812: CALL_OW 311
43816: NOT
43817: AND
43818: PUSH
43819: LD_VAR 0 4
43823: PPUSH
43824: CALL_OW 266
43828: PUSH
43829: LD_INT 36
43831: EQUAL
43832: PUSH
43833: LD_VAR 0 4
43837: PPUSH
43838: CALL_OW 313
43842: PUSH
43843: LD_INT 3
43845: LESS
43846: AND
43847: OR
43848: IFFALSE 43862
// begin ct := k ;
43850: LD_ADDR_VAR 0 8
43854: PUSH
43855: LD_VAR 0 4
43859: ST_TO_ADDR
// break ;
43860: GO 43864
// end ;
43862: GO 43790
43864: POP
43865: POP
// if ct then
43866: LD_VAR 0 8
43870: IFFALSE 43886
// ComEnterUnit ( j , ct ) ;
43872: LD_VAR 0 3
43876: PPUSH
43877: LD_VAR 0 8
43881: PPUSH
43882: CALL_OW 120
// end ; end ;
43886: GO 43521
43888: POP
43889: POP
// places := 0 ;
43890: LD_ADDR_VAR 0 5
43894: PUSH
43895: LD_INT 0
43897: ST_TO_ADDR
// for j = 1 to x do
43898: LD_ADDR_VAR 0 3
43902: PUSH
43903: DOUBLE
43904: LD_INT 1
43906: DEC
43907: ST_TO_ADDR
43908: LD_VAR 0 11
43912: PUSH
43913: FOR_TO
43914: IFFALSE 43990
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43916: LD_VAR 0 11
43920: PUSH
43921: LD_VAR 0 3
43925: ARRAY
43926: PPUSH
43927: CALL_OW 264
43931: PUSH
43932: LD_INT 31
43934: EQUAL
43935: IFFALSE 43953
// places := places + 1 else
43937: LD_ADDR_VAR 0 5
43941: PUSH
43942: LD_VAR 0 5
43946: PUSH
43947: LD_INT 1
43949: PLUS
43950: ST_TO_ADDR
43951: GO 43988
// if GetBType ( x [ j ] ) = b_control_tower then
43953: LD_VAR 0 11
43957: PUSH
43958: LD_VAR 0 3
43962: ARRAY
43963: PPUSH
43964: CALL_OW 266
43968: PUSH
43969: LD_INT 36
43971: EQUAL
43972: IFFALSE 43988
// places := places + 3 ;
43974: LD_ADDR_VAR 0 5
43978: PUSH
43979: LD_VAR 0 5
43983: PUSH
43984: LD_INT 3
43986: PLUS
43987: ST_TO_ADDR
43988: GO 43913
43990: POP
43991: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43992: LD_VAR 0 5
43996: PUSH
43997: LD_INT 0
43999: EQUAL
44000: PUSH
44001: LD_VAR 0 5
44005: PUSH
44006: LD_EXP 118
44010: PUSH
44011: LD_VAR 0 2
44015: ARRAY
44016: LESSEQUAL
44017: OR
44018: IFFALSE 44022
// continue ;
44020: GO 43272
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
44022: LD_ADDR_VAR 0 6
44026: PUSH
44027: LD_EXP 78
44031: PUSH
44032: LD_VAR 0 2
44036: ARRAY
44037: PPUSH
44038: LD_INT 25
44040: PUSH
44041: LD_INT 3
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PPUSH
44048: CALL_OW 72
44052: PUSH
44053: LD_EXP 118
44057: PUSH
44058: LD_VAR 0 2
44062: ARRAY
44063: DIFF
44064: PPUSH
44065: LD_INT 3
44067: PPUSH
44068: CALL 88021 0 2
44072: ST_TO_ADDR
// for j in tmp do
44073: LD_ADDR_VAR 0 3
44077: PUSH
44078: LD_VAR 0 6
44082: PUSH
44083: FOR_IN
44084: IFFALSE 44119
// if GetTag ( j ) > 0 then
44086: LD_VAR 0 3
44090: PPUSH
44091: CALL_OW 110
44095: PUSH
44096: LD_INT 0
44098: GREATER
44099: IFFALSE 44117
// tmp := tmp diff j ;
44101: LD_ADDR_VAR 0 6
44105: PUSH
44106: LD_VAR 0 6
44110: PUSH
44111: LD_VAR 0 3
44115: DIFF
44116: ST_TO_ADDR
44117: GO 44083
44119: POP
44120: POP
// if not tmp then
44121: LD_VAR 0 6
44125: NOT
44126: IFFALSE 44130
// continue ;
44128: GO 43272
// if places then
44130: LD_VAR 0 5
44134: IFFALSE 44193
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
44136: LD_ADDR_EXP 118
44140: PUSH
44141: LD_EXP 118
44145: PPUSH
44146: LD_VAR 0 2
44150: PPUSH
44151: LD_EXP 118
44155: PUSH
44156: LD_VAR 0 2
44160: ARRAY
44161: PUSH
44162: LD_VAR 0 6
44166: PUSH
44167: LD_INT 1
44169: ARRAY
44170: UNION
44171: PPUSH
44172: CALL_OW 1
44176: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
44177: LD_VAR 0 6
44181: PUSH
44182: LD_INT 1
44184: ARRAY
44185: PPUSH
44186: LD_INT 126
44188: PPUSH
44189: CALL_OW 109
// end ; end ;
44193: GO 43272
44195: POP
44196: POP
// end ;
44197: LD_VAR 0 1
44201: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44202: LD_INT 0
44204: PPUSH
44205: PPUSH
44206: PPUSH
44207: PPUSH
44208: PPUSH
44209: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44210: LD_VAR 0 1
44214: NOT
44215: PUSH
44216: LD_VAR 0 2
44220: NOT
44221: OR
44222: PUSH
44223: LD_VAR 0 3
44227: NOT
44228: OR
44229: PUSH
44230: LD_VAR 0 4
44234: PUSH
44235: LD_INT 1
44237: PUSH
44238: LD_INT 2
44240: PUSH
44241: LD_INT 3
44243: PUSH
44244: LD_INT 4
44246: PUSH
44247: LD_INT 5
44249: PUSH
44250: LD_INT 8
44252: PUSH
44253: LD_INT 9
44255: PUSH
44256: LD_INT 15
44258: PUSH
44259: LD_INT 16
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: IN
44273: NOT
44274: OR
44275: IFFALSE 44279
// exit ;
44277: GO 45137
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44279: LD_ADDR_VAR 0 2
44283: PUSH
44284: LD_VAR 0 2
44288: PPUSH
44289: LD_INT 21
44291: PUSH
44292: LD_INT 3
44294: PUSH
44295: EMPTY
44296: LIST
44297: LIST
44298: PUSH
44299: LD_INT 24
44301: PUSH
44302: LD_INT 250
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: PPUSH
44313: CALL_OW 72
44317: ST_TO_ADDR
// case class of 1 , 15 :
44318: LD_VAR 0 4
44322: PUSH
44323: LD_INT 1
44325: DOUBLE
44326: EQUAL
44327: IFTRUE 44337
44329: LD_INT 15
44331: DOUBLE
44332: EQUAL
44333: IFTRUE 44337
44335: GO 44422
44337: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44338: LD_ADDR_VAR 0 8
44342: PUSH
44343: LD_VAR 0 2
44347: PPUSH
44348: LD_INT 2
44350: PUSH
44351: LD_INT 30
44353: PUSH
44354: LD_INT 32
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: LD_INT 30
44363: PUSH
44364: LD_INT 31
44366: PUSH
44367: EMPTY
44368: LIST
44369: LIST
44370: PUSH
44371: EMPTY
44372: LIST
44373: LIST
44374: LIST
44375: PPUSH
44376: CALL_OW 72
44380: PUSH
44381: LD_VAR 0 2
44385: PPUSH
44386: LD_INT 2
44388: PUSH
44389: LD_INT 30
44391: PUSH
44392: LD_INT 4
44394: PUSH
44395: EMPTY
44396: LIST
44397: LIST
44398: PUSH
44399: LD_INT 30
44401: PUSH
44402: LD_INT 5
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: EMPTY
44410: LIST
44411: LIST
44412: LIST
44413: PPUSH
44414: CALL_OW 72
44418: ADD
44419: ST_TO_ADDR
44420: GO 44668
44422: LD_INT 2
44424: DOUBLE
44425: EQUAL
44426: IFTRUE 44436
44428: LD_INT 16
44430: DOUBLE
44431: EQUAL
44432: IFTRUE 44436
44434: GO 44482
44436: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44437: LD_ADDR_VAR 0 8
44441: PUSH
44442: LD_VAR 0 2
44446: PPUSH
44447: LD_INT 2
44449: PUSH
44450: LD_INT 30
44452: PUSH
44453: LD_INT 0
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: PUSH
44460: LD_INT 30
44462: PUSH
44463: LD_INT 1
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: LIST
44474: PPUSH
44475: CALL_OW 72
44479: ST_TO_ADDR
44480: GO 44668
44482: LD_INT 3
44484: DOUBLE
44485: EQUAL
44486: IFTRUE 44490
44488: GO 44536
44490: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44491: LD_ADDR_VAR 0 8
44495: PUSH
44496: LD_VAR 0 2
44500: PPUSH
44501: LD_INT 2
44503: PUSH
44504: LD_INT 30
44506: PUSH
44507: LD_INT 2
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: LD_INT 30
44516: PUSH
44517: LD_INT 3
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: LIST
44528: PPUSH
44529: CALL_OW 72
44533: ST_TO_ADDR
44534: GO 44668
44536: LD_INT 4
44538: DOUBLE
44539: EQUAL
44540: IFTRUE 44544
44542: GO 44601
44544: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44545: LD_ADDR_VAR 0 8
44549: PUSH
44550: LD_VAR 0 2
44554: PPUSH
44555: LD_INT 2
44557: PUSH
44558: LD_INT 30
44560: PUSH
44561: LD_INT 6
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 30
44570: PUSH
44571: LD_INT 7
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 30
44580: PUSH
44581: LD_INT 8
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: LIST
44592: LIST
44593: PPUSH
44594: CALL_OW 72
44598: ST_TO_ADDR
44599: GO 44668
44601: LD_INT 5
44603: DOUBLE
44604: EQUAL
44605: IFTRUE 44621
44607: LD_INT 8
44609: DOUBLE
44610: EQUAL
44611: IFTRUE 44621
44613: LD_INT 9
44615: DOUBLE
44616: EQUAL
44617: IFTRUE 44621
44619: GO 44667
44621: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44622: LD_ADDR_VAR 0 8
44626: PUSH
44627: LD_VAR 0 2
44631: PPUSH
44632: LD_INT 2
44634: PUSH
44635: LD_INT 30
44637: PUSH
44638: LD_INT 4
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 30
44647: PUSH
44648: LD_INT 5
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: LIST
44659: PPUSH
44660: CALL_OW 72
44664: ST_TO_ADDR
44665: GO 44668
44667: POP
// if not tmp then
44668: LD_VAR 0 8
44672: NOT
44673: IFFALSE 44677
// exit ;
44675: GO 45137
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44677: LD_VAR 0 4
44681: PUSH
44682: LD_INT 1
44684: PUSH
44685: LD_INT 15
44687: PUSH
44688: EMPTY
44689: LIST
44690: LIST
44691: IN
44692: PUSH
44693: LD_EXP 87
44697: PUSH
44698: LD_VAR 0 1
44702: ARRAY
44703: AND
44704: IFFALSE 44860
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44706: LD_ADDR_VAR 0 9
44710: PUSH
44711: LD_EXP 87
44715: PUSH
44716: LD_VAR 0 1
44720: ARRAY
44721: PUSH
44722: LD_INT 1
44724: ARRAY
44725: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44726: LD_VAR 0 9
44730: PUSH
44731: LD_EXP 88
44735: PUSH
44736: LD_VAR 0 1
44740: ARRAY
44741: IN
44742: NOT
44743: IFFALSE 44858
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44745: LD_ADDR_EXP 88
44749: PUSH
44750: LD_EXP 88
44754: PPUSH
44755: LD_VAR 0 1
44759: PUSH
44760: LD_EXP 88
44764: PUSH
44765: LD_VAR 0 1
44769: ARRAY
44770: PUSH
44771: LD_INT 1
44773: PLUS
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PPUSH
44779: LD_VAR 0 9
44783: PPUSH
44784: CALL 57174 0 3
44788: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44789: LD_ADDR_EXP 87
44793: PUSH
44794: LD_EXP 87
44798: PPUSH
44799: LD_VAR 0 1
44803: PPUSH
44804: LD_EXP 87
44808: PUSH
44809: LD_VAR 0 1
44813: ARRAY
44814: PUSH
44815: LD_VAR 0 9
44819: DIFF
44820: PPUSH
44821: CALL_OW 1
44825: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44826: LD_VAR 0 3
44830: PPUSH
44831: LD_EXP 88
44835: PUSH
44836: LD_VAR 0 1
44840: ARRAY
44841: PUSH
44842: LD_EXP 88
44846: PUSH
44847: LD_VAR 0 1
44851: ARRAY
44852: ARRAY
44853: PPUSH
44854: CALL_OW 120
// end ; exit ;
44858: GO 45137
// end ; if tmp > 1 then
44860: LD_VAR 0 8
44864: PUSH
44865: LD_INT 1
44867: GREATER
44868: IFFALSE 44972
// for i = 2 to tmp do
44870: LD_ADDR_VAR 0 6
44874: PUSH
44875: DOUBLE
44876: LD_INT 2
44878: DEC
44879: ST_TO_ADDR
44880: LD_VAR 0 8
44884: PUSH
44885: FOR_TO
44886: IFFALSE 44970
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44888: LD_VAR 0 8
44892: PUSH
44893: LD_VAR 0 6
44897: ARRAY
44898: PPUSH
44899: CALL_OW 461
44903: PUSH
44904: LD_INT 6
44906: EQUAL
44907: IFFALSE 44968
// begin x := tmp [ i ] ;
44909: LD_ADDR_VAR 0 9
44913: PUSH
44914: LD_VAR 0 8
44918: PUSH
44919: LD_VAR 0 6
44923: ARRAY
44924: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44925: LD_ADDR_VAR 0 8
44929: PUSH
44930: LD_VAR 0 8
44934: PPUSH
44935: LD_VAR 0 6
44939: PPUSH
44940: CALL_OW 3
44944: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44945: LD_ADDR_VAR 0 8
44949: PUSH
44950: LD_VAR 0 8
44954: PPUSH
44955: LD_INT 1
44957: PPUSH
44958: LD_VAR 0 9
44962: PPUSH
44963: CALL_OW 2
44967: ST_TO_ADDR
// end ;
44968: GO 44885
44970: POP
44971: POP
// for i in tmp do
44972: LD_ADDR_VAR 0 6
44976: PUSH
44977: LD_VAR 0 8
44981: PUSH
44982: FOR_IN
44983: IFFALSE 45010
// begin if IsNotFull ( i ) then
44985: LD_VAR 0 6
44989: PPUSH
44990: CALL 54396 0 1
44994: IFFALSE 45008
// begin j := i ;
44996: LD_ADDR_VAR 0 7
45000: PUSH
45001: LD_VAR 0 6
45005: ST_TO_ADDR
// break ;
45006: GO 45010
// end ; end ;
45008: GO 44982
45010: POP
45011: POP
// if j then
45012: LD_VAR 0 7
45016: IFFALSE 45034
// ComEnterUnit ( unit , j ) else
45018: LD_VAR 0 3
45022: PPUSH
45023: LD_VAR 0 7
45027: PPUSH
45028: CALL_OW 120
45032: GO 45137
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45034: LD_ADDR_VAR 0 10
45038: PUSH
45039: LD_VAR 0 2
45043: PPUSH
45044: LD_INT 2
45046: PUSH
45047: LD_INT 30
45049: PUSH
45050: LD_INT 0
45052: PUSH
45053: EMPTY
45054: LIST
45055: LIST
45056: PUSH
45057: LD_INT 30
45059: PUSH
45060: LD_INT 1
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: LIST
45071: PPUSH
45072: CALL_OW 72
45076: ST_TO_ADDR
// if depot then
45077: LD_VAR 0 10
45081: IFFALSE 45137
// begin depot := NearestUnitToUnit ( depot , unit ) ;
45083: LD_ADDR_VAR 0 10
45087: PUSH
45088: LD_VAR 0 10
45092: PPUSH
45093: LD_VAR 0 3
45097: PPUSH
45098: CALL_OW 74
45102: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
45103: LD_VAR 0 3
45107: PPUSH
45108: LD_VAR 0 10
45112: PPUSH
45113: CALL_OW 296
45117: PUSH
45118: LD_INT 10
45120: GREATER
45121: IFFALSE 45137
// ComStandNearbyBuilding ( unit , depot ) ;
45123: LD_VAR 0 3
45127: PPUSH
45128: LD_VAR 0 10
45132: PPUSH
45133: CALL 53776 0 2
// end ; end ; end ;
45137: LD_VAR 0 5
45141: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
45142: LD_INT 0
45144: PPUSH
45145: PPUSH
45146: PPUSH
45147: PPUSH
// if not mc_bases then
45148: LD_EXP 78
45152: NOT
45153: IFFALSE 45157
// exit ;
45155: GO 45396
// for i = 1 to mc_bases do
45157: LD_ADDR_VAR 0 2
45161: PUSH
45162: DOUBLE
45163: LD_INT 1
45165: DEC
45166: ST_TO_ADDR
45167: LD_EXP 78
45171: PUSH
45172: FOR_TO
45173: IFFALSE 45394
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45175: LD_ADDR_VAR 0 4
45179: PUSH
45180: LD_EXP 78
45184: PUSH
45185: LD_VAR 0 2
45189: ARRAY
45190: PPUSH
45191: LD_INT 21
45193: PUSH
45194: LD_INT 1
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: PPUSH
45201: CALL_OW 72
45205: PUSH
45206: LD_EXP 107
45210: PUSH
45211: LD_VAR 0 2
45215: ARRAY
45216: UNION
45217: ST_TO_ADDR
// if not tmp then
45218: LD_VAR 0 4
45222: NOT
45223: IFFALSE 45227
// continue ;
45225: GO 45172
// for j in tmp do
45227: LD_ADDR_VAR 0 3
45231: PUSH
45232: LD_VAR 0 4
45236: PUSH
45237: FOR_IN
45238: IFFALSE 45390
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45240: LD_VAR 0 3
45244: PPUSH
45245: CALL_OW 110
45249: NOT
45250: PUSH
45251: LD_VAR 0 3
45255: PPUSH
45256: CALL_OW 314
45260: NOT
45261: AND
45262: PUSH
45263: LD_VAR 0 3
45267: PPUSH
45268: CALL_OW 311
45272: NOT
45273: AND
45274: PUSH
45275: LD_VAR 0 3
45279: PPUSH
45280: CALL_OW 310
45284: NOT
45285: AND
45286: PUSH
45287: LD_VAR 0 3
45291: PUSH
45292: LD_EXP 81
45296: PUSH
45297: LD_VAR 0 2
45301: ARRAY
45302: PUSH
45303: LD_INT 1
45305: ARRAY
45306: IN
45307: NOT
45308: AND
45309: PUSH
45310: LD_VAR 0 3
45314: PUSH
45315: LD_EXP 81
45319: PUSH
45320: LD_VAR 0 2
45324: ARRAY
45325: PUSH
45326: LD_INT 2
45328: ARRAY
45329: IN
45330: NOT
45331: AND
45332: PUSH
45333: LD_VAR 0 3
45337: PUSH
45338: LD_EXP 90
45342: PUSH
45343: LD_VAR 0 2
45347: ARRAY
45348: IN
45349: NOT
45350: AND
45351: IFFALSE 45388
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45353: LD_VAR 0 2
45357: PPUSH
45358: LD_EXP 78
45362: PUSH
45363: LD_VAR 0 2
45367: ARRAY
45368: PPUSH
45369: LD_VAR 0 3
45373: PPUSH
45374: LD_VAR 0 3
45378: PPUSH
45379: CALL_OW 257
45383: PPUSH
45384: CALL 44202 0 4
// end ;
45388: GO 45237
45390: POP
45391: POP
// end ;
45392: GO 45172
45394: POP
45395: POP
// end ;
45396: LD_VAR 0 1
45400: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
45401: LD_INT 0
45403: PPUSH
45404: PPUSH
45405: PPUSH
45406: PPUSH
45407: PPUSH
45408: PPUSH
// if not mc_bases [ base ] then
45409: LD_EXP 78
45413: PUSH
45414: LD_VAR 0 1
45418: ARRAY
45419: NOT
45420: IFFALSE 45424
// exit ;
45422: GO 45625
// tmp := [ ] ;
45424: LD_ADDR_VAR 0 6
45428: PUSH
45429: EMPTY
45430: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45431: LD_ADDR_VAR 0 7
45435: PUSH
45436: LD_VAR 0 3
45440: PPUSH
45441: LD_INT 0
45443: PPUSH
45444: CALL_OW 517
45448: ST_TO_ADDR
// if not list then
45449: LD_VAR 0 7
45453: NOT
45454: IFFALSE 45458
// exit ;
45456: GO 45625
// c := Count ( list [ 1 ] ) ;
45458: LD_ADDR_VAR 0 9
45462: PUSH
45463: LD_VAR 0 7
45467: PUSH
45468: LD_INT 1
45470: ARRAY
45471: PPUSH
45472: CALL 54314 0 1
45476: ST_TO_ADDR
// if amount > c then
45477: LD_VAR 0 2
45481: PUSH
45482: LD_VAR 0 9
45486: GREATER
45487: IFFALSE 45499
// amount := c ;
45489: LD_ADDR_VAR 0 2
45493: PUSH
45494: LD_VAR 0 9
45498: ST_TO_ADDR
// for i := 1 to amount do
45499: LD_ADDR_VAR 0 5
45503: PUSH
45504: DOUBLE
45505: LD_INT 1
45507: DEC
45508: ST_TO_ADDR
45509: LD_VAR 0 2
45513: PUSH
45514: FOR_TO
45515: IFFALSE 45573
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
45517: LD_ADDR_VAR 0 6
45521: PUSH
45522: LD_VAR 0 6
45526: PPUSH
45527: LD_VAR 0 5
45531: PPUSH
45532: LD_VAR 0 7
45536: PUSH
45537: LD_INT 1
45539: ARRAY
45540: PUSH
45541: LD_VAR 0 5
45545: ARRAY
45546: PUSH
45547: LD_VAR 0 7
45551: PUSH
45552: LD_INT 2
45554: ARRAY
45555: PUSH
45556: LD_VAR 0 5
45560: ARRAY
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PPUSH
45566: CALL_OW 1
45570: ST_TO_ADDR
45571: GO 45514
45573: POP
45574: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45575: LD_ADDR_EXP 91
45579: PUSH
45580: LD_EXP 91
45584: PPUSH
45585: LD_VAR 0 1
45589: PPUSH
45590: LD_VAR 0 6
45594: PPUSH
45595: CALL_OW 1
45599: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45600: LD_ADDR_EXP 93
45604: PUSH
45605: LD_EXP 93
45609: PPUSH
45610: LD_VAR 0 1
45614: PPUSH
45615: LD_VAR 0 3
45619: PPUSH
45620: CALL_OW 1
45624: ST_TO_ADDR
// end ;
45625: LD_VAR 0 4
45629: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45630: LD_INT 0
45632: PPUSH
// if not mc_bases [ base ] then
45633: LD_EXP 78
45637: PUSH
45638: LD_VAR 0 1
45642: ARRAY
45643: NOT
45644: IFFALSE 45648
// exit ;
45646: GO 45673
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45648: LD_ADDR_EXP 83
45652: PUSH
45653: LD_EXP 83
45657: PPUSH
45658: LD_VAR 0 1
45662: PPUSH
45663: LD_VAR 0 2
45667: PPUSH
45668: CALL_OW 1
45672: ST_TO_ADDR
// end ;
45673: LD_VAR 0 3
45677: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45678: LD_INT 0
45680: PPUSH
// if not mc_bases [ base ] then
45681: LD_EXP 78
45685: PUSH
45686: LD_VAR 0 1
45690: ARRAY
45691: NOT
45692: IFFALSE 45696
// exit ;
45694: GO 45733
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45696: LD_ADDR_EXP 83
45700: PUSH
45701: LD_EXP 83
45705: PPUSH
45706: LD_VAR 0 1
45710: PPUSH
45711: LD_EXP 83
45715: PUSH
45716: LD_VAR 0 1
45720: ARRAY
45721: PUSH
45722: LD_VAR 0 2
45726: UNION
45727: PPUSH
45728: CALL_OW 1
45732: ST_TO_ADDR
// end ;
45733: LD_VAR 0 3
45737: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45738: LD_INT 0
45740: PPUSH
// if not mc_bases [ base ] then
45741: LD_EXP 78
45745: PUSH
45746: LD_VAR 0 1
45750: ARRAY
45751: NOT
45752: IFFALSE 45756
// exit ;
45754: GO 45781
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45756: LD_ADDR_EXP 99
45760: PUSH
45761: LD_EXP 99
45765: PPUSH
45766: LD_VAR 0 1
45770: PPUSH
45771: LD_VAR 0 2
45775: PPUSH
45776: CALL_OW 1
45780: ST_TO_ADDR
// end ;
45781: LD_VAR 0 3
45785: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45786: LD_INT 0
45788: PPUSH
// if not mc_bases [ base ] then
45789: LD_EXP 78
45793: PUSH
45794: LD_VAR 0 1
45798: ARRAY
45799: NOT
45800: IFFALSE 45804
// exit ;
45802: GO 45841
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45804: LD_ADDR_EXP 99
45808: PUSH
45809: LD_EXP 99
45813: PPUSH
45814: LD_VAR 0 1
45818: PPUSH
45819: LD_EXP 99
45823: PUSH
45824: LD_VAR 0 1
45828: ARRAY
45829: PUSH
45830: LD_VAR 0 2
45834: ADD
45835: PPUSH
45836: CALL_OW 1
45840: ST_TO_ADDR
// end ;
45841: LD_VAR 0 3
45845: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45846: LD_INT 0
45848: PPUSH
// if not mc_bases [ base ] then
45849: LD_EXP 78
45853: PUSH
45854: LD_VAR 0 1
45858: ARRAY
45859: NOT
45860: IFFALSE 45864
// exit ;
45862: GO 45918
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45864: LD_ADDR_EXP 100
45868: PUSH
45869: LD_EXP 100
45873: PPUSH
45874: LD_VAR 0 1
45878: PPUSH
45879: LD_VAR 0 2
45883: PPUSH
45884: CALL_OW 1
45888: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45889: LD_ADDR_EXP 89
45893: PUSH
45894: LD_EXP 89
45898: PPUSH
45899: LD_VAR 0 1
45903: PPUSH
45904: LD_VAR 0 2
45908: PUSH
45909: LD_INT 0
45911: PLUS
45912: PPUSH
45913: CALL_OW 1
45917: ST_TO_ADDR
// end ;
45918: LD_VAR 0 3
45922: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45923: LD_INT 0
45925: PPUSH
// if not mc_bases [ base ] then
45926: LD_EXP 78
45930: PUSH
45931: LD_VAR 0 1
45935: ARRAY
45936: NOT
45937: IFFALSE 45941
// exit ;
45939: GO 45966
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45941: LD_ADDR_EXP 89
45945: PUSH
45946: LD_EXP 89
45950: PPUSH
45951: LD_VAR 0 1
45955: PPUSH
45956: LD_VAR 0 2
45960: PPUSH
45961: CALL_OW 1
45965: ST_TO_ADDR
// end ;
45966: LD_VAR 0 3
45970: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45971: LD_INT 0
45973: PPUSH
45974: PPUSH
45975: PPUSH
45976: PPUSH
// if not mc_bases [ base ] then
45977: LD_EXP 78
45981: PUSH
45982: LD_VAR 0 1
45986: ARRAY
45987: NOT
45988: IFFALSE 45992
// exit ;
45990: GO 46057
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45992: LD_ADDR_EXP 98
45996: PUSH
45997: LD_EXP 98
46001: PPUSH
46002: LD_VAR 0 1
46006: PUSH
46007: LD_EXP 98
46011: PUSH
46012: LD_VAR 0 1
46016: ARRAY
46017: PUSH
46018: LD_INT 1
46020: PLUS
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: PPUSH
46026: LD_VAR 0 1
46030: PUSH
46031: LD_VAR 0 2
46035: PUSH
46036: LD_VAR 0 3
46040: PUSH
46041: LD_VAR 0 4
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: PPUSH
46052: CALL 57174 0 3
46056: ST_TO_ADDR
// end ;
46057: LD_VAR 0 5
46061: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
46062: LD_INT 0
46064: PPUSH
// if not mc_bases [ base ] then
46065: LD_EXP 78
46069: PUSH
46070: LD_VAR 0 1
46074: ARRAY
46075: NOT
46076: IFFALSE 46080
// exit ;
46078: GO 46105
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
46080: LD_ADDR_EXP 115
46084: PUSH
46085: LD_EXP 115
46089: PPUSH
46090: LD_VAR 0 1
46094: PPUSH
46095: LD_VAR 0 2
46099: PPUSH
46100: CALL_OW 1
46104: ST_TO_ADDR
// end ;
46105: LD_VAR 0 3
46109: RET
// export function MC_GetMinesField ( base ) ; begin
46110: LD_INT 0
46112: PPUSH
// result := mc_mines [ base ] ;
46113: LD_ADDR_VAR 0 2
46117: PUSH
46118: LD_EXP 91
46122: PUSH
46123: LD_VAR 0 1
46127: ARRAY
46128: ST_TO_ADDR
// end ;
46129: LD_VAR 0 2
46133: RET
// export function MC_GetProduceList ( base ) ; begin
46134: LD_INT 0
46136: PPUSH
// result := mc_produce [ base ] ;
46137: LD_ADDR_VAR 0 2
46141: PUSH
46142: LD_EXP 99
46146: PUSH
46147: LD_VAR 0 1
46151: ARRAY
46152: ST_TO_ADDR
// end ;
46153: LD_VAR 0 2
46157: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
46158: LD_INT 0
46160: PPUSH
46161: PPUSH
// if not mc_bases then
46162: LD_EXP 78
46166: NOT
46167: IFFALSE 46171
// exit ;
46169: GO 46236
// if mc_bases [ base ] then
46171: LD_EXP 78
46175: PUSH
46176: LD_VAR 0 1
46180: ARRAY
46181: IFFALSE 46236
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46183: LD_ADDR_VAR 0 3
46187: PUSH
46188: LD_EXP 78
46192: PUSH
46193: LD_VAR 0 1
46197: ARRAY
46198: PPUSH
46199: LD_INT 30
46201: PUSH
46202: LD_VAR 0 2
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PPUSH
46211: CALL_OW 72
46215: ST_TO_ADDR
// if result then
46216: LD_VAR 0 3
46220: IFFALSE 46236
// result := result [ 1 ] ;
46222: LD_ADDR_VAR 0 3
46226: PUSH
46227: LD_VAR 0 3
46231: PUSH
46232: LD_INT 1
46234: ARRAY
46235: ST_TO_ADDR
// end ; end ;
46236: LD_VAR 0 3
46240: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46241: LD_INT 0
46243: PPUSH
46244: PPUSH
// if not mc_bases then
46245: LD_EXP 78
46249: NOT
46250: IFFALSE 46254
// exit ;
46252: GO 46299
// if mc_bases [ base ] then
46254: LD_EXP 78
46258: PUSH
46259: LD_VAR 0 1
46263: ARRAY
46264: IFFALSE 46299
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46266: LD_ADDR_VAR 0 3
46270: PUSH
46271: LD_EXP 78
46275: PUSH
46276: LD_VAR 0 1
46280: ARRAY
46281: PPUSH
46282: LD_INT 30
46284: PUSH
46285: LD_VAR 0 2
46289: PUSH
46290: EMPTY
46291: LIST
46292: LIST
46293: PPUSH
46294: CALL_OW 72
46298: ST_TO_ADDR
// end ;
46299: LD_VAR 0 3
46303: RET
// export function MC_SetTame ( base , area ) ; begin
46304: LD_INT 0
46306: PPUSH
// if not mc_bases or not base then
46307: LD_EXP 78
46311: NOT
46312: PUSH
46313: LD_VAR 0 1
46317: NOT
46318: OR
46319: IFFALSE 46323
// exit ;
46321: GO 46348
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46323: LD_ADDR_EXP 106
46327: PUSH
46328: LD_EXP 106
46332: PPUSH
46333: LD_VAR 0 1
46337: PPUSH
46338: LD_VAR 0 2
46342: PPUSH
46343: CALL_OW 1
46347: ST_TO_ADDR
// end ;
46348: LD_VAR 0 3
46352: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46353: LD_INT 0
46355: PPUSH
46356: PPUSH
// if not mc_bases or not base then
46357: LD_EXP 78
46361: NOT
46362: PUSH
46363: LD_VAR 0 1
46367: NOT
46368: OR
46369: IFFALSE 46373
// exit ;
46371: GO 46475
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46373: LD_ADDR_VAR 0 4
46377: PUSH
46378: LD_EXP 78
46382: PUSH
46383: LD_VAR 0 1
46387: ARRAY
46388: PPUSH
46389: LD_INT 30
46391: PUSH
46392: LD_VAR 0 2
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PPUSH
46401: CALL_OW 72
46405: ST_TO_ADDR
// if not tmp then
46406: LD_VAR 0 4
46410: NOT
46411: IFFALSE 46415
// exit ;
46413: GO 46475
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46415: LD_ADDR_EXP 110
46419: PUSH
46420: LD_EXP 110
46424: PPUSH
46425: LD_VAR 0 1
46429: PPUSH
46430: LD_EXP 110
46434: PUSH
46435: LD_VAR 0 1
46439: ARRAY
46440: PPUSH
46441: LD_EXP 110
46445: PUSH
46446: LD_VAR 0 1
46450: ARRAY
46451: PUSH
46452: LD_INT 1
46454: PLUS
46455: PPUSH
46456: LD_VAR 0 4
46460: PUSH
46461: LD_INT 1
46463: ARRAY
46464: PPUSH
46465: CALL_OW 2
46469: PPUSH
46470: CALL_OW 1
46474: ST_TO_ADDR
// end ;
46475: LD_VAR 0 3
46479: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46480: LD_INT 0
46482: PPUSH
46483: PPUSH
// if not mc_bases or not base or not kinds then
46484: LD_EXP 78
46488: NOT
46489: PUSH
46490: LD_VAR 0 1
46494: NOT
46495: OR
46496: PUSH
46497: LD_VAR 0 2
46501: NOT
46502: OR
46503: IFFALSE 46507
// exit ;
46505: GO 46568
// for i in kinds do
46507: LD_ADDR_VAR 0 4
46511: PUSH
46512: LD_VAR 0 2
46516: PUSH
46517: FOR_IN
46518: IFFALSE 46566
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46520: LD_ADDR_EXP 112
46524: PUSH
46525: LD_EXP 112
46529: PPUSH
46530: LD_VAR 0 1
46534: PUSH
46535: LD_EXP 112
46539: PUSH
46540: LD_VAR 0 1
46544: ARRAY
46545: PUSH
46546: LD_INT 1
46548: PLUS
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PPUSH
46554: LD_VAR 0 4
46558: PPUSH
46559: CALL 57174 0 3
46563: ST_TO_ADDR
46564: GO 46517
46566: POP
46567: POP
// end ;
46568: LD_VAR 0 3
46572: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46573: LD_INT 0
46575: PPUSH
// if not mc_bases or not base or not areas then
46576: LD_EXP 78
46580: NOT
46581: PUSH
46582: LD_VAR 0 1
46586: NOT
46587: OR
46588: PUSH
46589: LD_VAR 0 2
46593: NOT
46594: OR
46595: IFFALSE 46599
// exit ;
46597: GO 46624
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46599: LD_ADDR_EXP 96
46603: PUSH
46604: LD_EXP 96
46608: PPUSH
46609: LD_VAR 0 1
46613: PPUSH
46614: LD_VAR 0 2
46618: PPUSH
46619: CALL_OW 1
46623: ST_TO_ADDR
// end ;
46624: LD_VAR 0 3
46628: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46629: LD_INT 0
46631: PPUSH
// if not mc_bases or not base or not teleports_exit then
46632: LD_EXP 78
46636: NOT
46637: PUSH
46638: LD_VAR 0 1
46642: NOT
46643: OR
46644: PUSH
46645: LD_VAR 0 2
46649: NOT
46650: OR
46651: IFFALSE 46655
// exit ;
46653: GO 46680
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46655: LD_ADDR_EXP 113
46659: PUSH
46660: LD_EXP 113
46664: PPUSH
46665: LD_VAR 0 1
46669: PPUSH
46670: LD_VAR 0 2
46674: PPUSH
46675: CALL_OW 1
46679: ST_TO_ADDR
// end ;
46680: LD_VAR 0 3
46684: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46685: LD_INT 0
46687: PPUSH
46688: PPUSH
46689: PPUSH
// if not mc_bases or not base or not ext_list then
46690: LD_EXP 78
46694: NOT
46695: PUSH
46696: LD_VAR 0 1
46700: NOT
46701: OR
46702: PUSH
46703: LD_VAR 0 5
46707: NOT
46708: OR
46709: IFFALSE 46713
// exit ;
46711: GO 46886
// tmp := GetFacExtXYD ( x , y , d ) ;
46713: LD_ADDR_VAR 0 8
46717: PUSH
46718: LD_VAR 0 2
46722: PPUSH
46723: LD_VAR 0 3
46727: PPUSH
46728: LD_VAR 0 4
46732: PPUSH
46733: CALL 87151 0 3
46737: ST_TO_ADDR
// if not tmp then
46738: LD_VAR 0 8
46742: NOT
46743: IFFALSE 46747
// exit ;
46745: GO 46886
// for i in tmp do
46747: LD_ADDR_VAR 0 7
46751: PUSH
46752: LD_VAR 0 8
46756: PUSH
46757: FOR_IN
46758: IFFALSE 46884
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46760: LD_ADDR_EXP 83
46764: PUSH
46765: LD_EXP 83
46769: PPUSH
46770: LD_VAR 0 1
46774: PPUSH
46775: LD_EXP 83
46779: PUSH
46780: LD_VAR 0 1
46784: ARRAY
46785: PPUSH
46786: LD_EXP 83
46790: PUSH
46791: LD_VAR 0 1
46795: ARRAY
46796: PUSH
46797: LD_INT 1
46799: PLUS
46800: PPUSH
46801: LD_VAR 0 5
46805: PUSH
46806: LD_INT 1
46808: ARRAY
46809: PUSH
46810: LD_VAR 0 7
46814: PUSH
46815: LD_INT 1
46817: ARRAY
46818: PUSH
46819: LD_VAR 0 7
46823: PUSH
46824: LD_INT 2
46826: ARRAY
46827: PUSH
46828: LD_VAR 0 7
46832: PUSH
46833: LD_INT 3
46835: ARRAY
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: PPUSH
46843: CALL_OW 2
46847: PPUSH
46848: CALL_OW 1
46852: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46853: LD_ADDR_VAR 0 5
46857: PUSH
46858: LD_VAR 0 5
46862: PPUSH
46863: LD_INT 1
46865: PPUSH
46866: CALL_OW 3
46870: ST_TO_ADDR
// if not ext_list then
46871: LD_VAR 0 5
46875: NOT
46876: IFFALSE 46882
// exit ;
46878: POP
46879: POP
46880: GO 46886
// end ;
46882: GO 46757
46884: POP
46885: POP
// end ;
46886: LD_VAR 0 6
46890: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46891: LD_INT 0
46893: PPUSH
// if not mc_bases or not base or not weapon_list then
46894: LD_EXP 78
46898: NOT
46899: PUSH
46900: LD_VAR 0 1
46904: NOT
46905: OR
46906: PUSH
46907: LD_VAR 0 2
46911: NOT
46912: OR
46913: IFFALSE 46917
// exit ;
46915: GO 46942
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46917: LD_ADDR_EXP 117
46921: PUSH
46922: LD_EXP 117
46926: PPUSH
46927: LD_VAR 0 1
46931: PPUSH
46932: LD_VAR 0 2
46936: PPUSH
46937: CALL_OW 1
46941: ST_TO_ADDR
// end ;
46942: LD_VAR 0 3
46946: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46947: LD_INT 0
46949: PPUSH
// if not mc_bases or not base or not tech_list then
46950: LD_EXP 78
46954: NOT
46955: PUSH
46956: LD_VAR 0 1
46960: NOT
46961: OR
46962: PUSH
46963: LD_VAR 0 2
46967: NOT
46968: OR
46969: IFFALSE 46973
// exit ;
46971: GO 46998
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46973: LD_ADDR_EXP 105
46977: PUSH
46978: LD_EXP 105
46982: PPUSH
46983: LD_VAR 0 1
46987: PPUSH
46988: LD_VAR 0 2
46992: PPUSH
46993: CALL_OW 1
46997: ST_TO_ADDR
// end ;
46998: LD_VAR 0 3
47002: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
47003: LD_INT 0
47005: PPUSH
// if not mc_bases or not parking_area or not base then
47006: LD_EXP 78
47010: NOT
47011: PUSH
47012: LD_VAR 0 2
47016: NOT
47017: OR
47018: PUSH
47019: LD_VAR 0 1
47023: NOT
47024: OR
47025: IFFALSE 47029
// exit ;
47027: GO 47054
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
47029: LD_ADDR_EXP 102
47033: PUSH
47034: LD_EXP 102
47038: PPUSH
47039: LD_VAR 0 1
47043: PPUSH
47044: LD_VAR 0 2
47048: PPUSH
47049: CALL_OW 1
47053: ST_TO_ADDR
// end ;
47054: LD_VAR 0 3
47058: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
47059: LD_INT 0
47061: PPUSH
// if not mc_bases or not base or not scan_area then
47062: LD_EXP 78
47066: NOT
47067: PUSH
47068: LD_VAR 0 1
47072: NOT
47073: OR
47074: PUSH
47075: LD_VAR 0 2
47079: NOT
47080: OR
47081: IFFALSE 47085
// exit ;
47083: GO 47110
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
47085: LD_ADDR_EXP 103
47089: PUSH
47090: LD_EXP 103
47094: PPUSH
47095: LD_VAR 0 1
47099: PPUSH
47100: LD_VAR 0 2
47104: PPUSH
47105: CALL_OW 1
47109: ST_TO_ADDR
// end ;
47110: LD_VAR 0 3
47114: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
47115: LD_INT 0
47117: PPUSH
47118: PPUSH
// if not mc_bases or not base then
47119: LD_EXP 78
47123: NOT
47124: PUSH
47125: LD_VAR 0 1
47129: NOT
47130: OR
47131: IFFALSE 47135
// exit ;
47133: GO 47199
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
47135: LD_ADDR_VAR 0 3
47139: PUSH
47140: LD_INT 1
47142: PUSH
47143: LD_INT 2
47145: PUSH
47146: LD_INT 3
47148: PUSH
47149: LD_INT 4
47151: PUSH
47152: LD_INT 11
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: LIST
47159: LIST
47160: LIST
47161: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
47162: LD_ADDR_EXP 105
47166: PUSH
47167: LD_EXP 105
47171: PPUSH
47172: LD_VAR 0 1
47176: PPUSH
47177: LD_EXP 105
47181: PUSH
47182: LD_VAR 0 1
47186: ARRAY
47187: PUSH
47188: LD_VAR 0 3
47192: DIFF
47193: PPUSH
47194: CALL_OW 1
47198: ST_TO_ADDR
// end ;
47199: LD_VAR 0 2
47203: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47204: LD_INT 0
47206: PPUSH
// result := mc_vehicles [ base ] ;
47207: LD_ADDR_VAR 0 3
47211: PUSH
47212: LD_EXP 97
47216: PUSH
47217: LD_VAR 0 1
47221: ARRAY
47222: ST_TO_ADDR
// if onlyCombat then
47223: LD_VAR 0 2
47227: IFFALSE 47399
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47229: LD_ADDR_VAR 0 3
47233: PUSH
47234: LD_VAR 0 3
47238: PUSH
47239: LD_VAR 0 3
47243: PPUSH
47244: LD_INT 2
47246: PUSH
47247: LD_INT 34
47249: PUSH
47250: LD_INT 12
47252: PUSH
47253: EMPTY
47254: LIST
47255: LIST
47256: PUSH
47257: LD_INT 34
47259: PUSH
47260: LD_INT 51
47262: PUSH
47263: EMPTY
47264: LIST
47265: LIST
47266: PUSH
47267: LD_INT 34
47269: PUSH
47270: LD_INT 89
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: LD_INT 34
47279: PUSH
47280: LD_INT 32
47282: PUSH
47283: EMPTY
47284: LIST
47285: LIST
47286: PUSH
47287: LD_INT 34
47289: PUSH
47290: LD_INT 13
47292: PUSH
47293: EMPTY
47294: LIST
47295: LIST
47296: PUSH
47297: LD_INT 34
47299: PUSH
47300: LD_INT 52
47302: PUSH
47303: EMPTY
47304: LIST
47305: LIST
47306: PUSH
47307: LD_INT 34
47309: PUSH
47310: LD_INT 88
47312: PUSH
47313: EMPTY
47314: LIST
47315: LIST
47316: PUSH
47317: LD_INT 34
47319: PUSH
47320: LD_INT 14
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: PUSH
47327: LD_INT 34
47329: PUSH
47330: LD_INT 53
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: LD_INT 34
47339: PUSH
47340: LD_INT 98
47342: PUSH
47343: EMPTY
47344: LIST
47345: LIST
47346: PUSH
47347: LD_INT 34
47349: PUSH
47350: LD_INT 31
47352: PUSH
47353: EMPTY
47354: LIST
47355: LIST
47356: PUSH
47357: LD_INT 34
47359: PUSH
47360: LD_INT 48
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: LD_INT 34
47369: PUSH
47370: LD_INT 8
47372: PUSH
47373: EMPTY
47374: LIST
47375: LIST
47376: PUSH
47377: EMPTY
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: PPUSH
47393: CALL_OW 72
47397: DIFF
47398: ST_TO_ADDR
// end ; end_of_file
47399: LD_VAR 0 3
47403: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47404: LD_INT 0
47406: PPUSH
47407: PPUSH
47408: PPUSH
// if not mc_bases or not skirmish then
47409: LD_EXP 78
47413: NOT
47414: PUSH
47415: LD_EXP 76
47419: NOT
47420: OR
47421: IFFALSE 47425
// exit ;
47423: GO 47590
// for i = 1 to mc_bases do
47425: LD_ADDR_VAR 0 4
47429: PUSH
47430: DOUBLE
47431: LD_INT 1
47433: DEC
47434: ST_TO_ADDR
47435: LD_EXP 78
47439: PUSH
47440: FOR_TO
47441: IFFALSE 47588
// begin if sci in mc_bases [ i ] then
47443: LD_VAR 0 2
47447: PUSH
47448: LD_EXP 78
47452: PUSH
47453: LD_VAR 0 4
47457: ARRAY
47458: IN
47459: IFFALSE 47586
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47461: LD_ADDR_EXP 107
47465: PUSH
47466: LD_EXP 107
47470: PPUSH
47471: LD_VAR 0 4
47475: PUSH
47476: LD_EXP 107
47480: PUSH
47481: LD_VAR 0 4
47485: ARRAY
47486: PUSH
47487: LD_INT 1
47489: PLUS
47490: PUSH
47491: EMPTY
47492: LIST
47493: LIST
47494: PPUSH
47495: LD_VAR 0 1
47499: PPUSH
47500: CALL 57174 0 3
47504: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47505: LD_ADDR_VAR 0 5
47509: PUSH
47510: LD_EXP 78
47514: PUSH
47515: LD_VAR 0 4
47519: ARRAY
47520: PPUSH
47521: LD_INT 2
47523: PUSH
47524: LD_INT 30
47526: PUSH
47527: LD_INT 0
47529: PUSH
47530: EMPTY
47531: LIST
47532: LIST
47533: PUSH
47534: LD_INT 30
47536: PUSH
47537: LD_INT 1
47539: PUSH
47540: EMPTY
47541: LIST
47542: LIST
47543: PUSH
47544: EMPTY
47545: LIST
47546: LIST
47547: LIST
47548: PPUSH
47549: CALL_OW 72
47553: PPUSH
47554: LD_VAR 0 1
47558: PPUSH
47559: CALL_OW 74
47563: ST_TO_ADDR
// if tmp then
47564: LD_VAR 0 5
47568: IFFALSE 47584
// ComStandNearbyBuilding ( ape , tmp ) ;
47570: LD_VAR 0 1
47574: PPUSH
47575: LD_VAR 0 5
47579: PPUSH
47580: CALL 53776 0 2
// break ;
47584: GO 47588
// end ; end ;
47586: GO 47440
47588: POP
47589: POP
// end ;
47590: LD_VAR 0 3
47594: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47595: LD_INT 0
47597: PPUSH
47598: PPUSH
47599: PPUSH
// if not mc_bases or not skirmish then
47600: LD_EXP 78
47604: NOT
47605: PUSH
47606: LD_EXP 76
47610: NOT
47611: OR
47612: IFFALSE 47616
// exit ;
47614: GO 47705
// for i = 1 to mc_bases do
47616: LD_ADDR_VAR 0 4
47620: PUSH
47621: DOUBLE
47622: LD_INT 1
47624: DEC
47625: ST_TO_ADDR
47626: LD_EXP 78
47630: PUSH
47631: FOR_TO
47632: IFFALSE 47703
// begin if building in mc_busy_turret_list [ i ] then
47634: LD_VAR 0 1
47638: PUSH
47639: LD_EXP 88
47643: PUSH
47644: LD_VAR 0 4
47648: ARRAY
47649: IN
47650: IFFALSE 47701
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47652: LD_ADDR_VAR 0 5
47656: PUSH
47657: LD_EXP 88
47661: PUSH
47662: LD_VAR 0 4
47666: ARRAY
47667: PUSH
47668: LD_VAR 0 1
47672: DIFF
47673: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47674: LD_ADDR_EXP 88
47678: PUSH
47679: LD_EXP 88
47683: PPUSH
47684: LD_VAR 0 4
47688: PPUSH
47689: LD_VAR 0 5
47693: PPUSH
47694: CALL_OW 1
47698: ST_TO_ADDR
// break ;
47699: GO 47703
// end ; end ;
47701: GO 47631
47703: POP
47704: POP
// end ;
47705: LD_VAR 0 3
47709: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47710: LD_INT 0
47712: PPUSH
47713: PPUSH
47714: PPUSH
// if not mc_bases or not skirmish then
47715: LD_EXP 78
47719: NOT
47720: PUSH
47721: LD_EXP 76
47725: NOT
47726: OR
47727: IFFALSE 47731
// exit ;
47729: GO 47930
// for i = 1 to mc_bases do
47731: LD_ADDR_VAR 0 5
47735: PUSH
47736: DOUBLE
47737: LD_INT 1
47739: DEC
47740: ST_TO_ADDR
47741: LD_EXP 78
47745: PUSH
47746: FOR_TO
47747: IFFALSE 47928
// if building in mc_bases [ i ] then
47749: LD_VAR 0 1
47753: PUSH
47754: LD_EXP 78
47758: PUSH
47759: LD_VAR 0 5
47763: ARRAY
47764: IN
47765: IFFALSE 47926
// begin tmp := mc_bases [ i ] diff building ;
47767: LD_ADDR_VAR 0 6
47771: PUSH
47772: LD_EXP 78
47776: PUSH
47777: LD_VAR 0 5
47781: ARRAY
47782: PUSH
47783: LD_VAR 0 1
47787: DIFF
47788: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47789: LD_ADDR_EXP 78
47793: PUSH
47794: LD_EXP 78
47798: PPUSH
47799: LD_VAR 0 5
47803: PPUSH
47804: LD_VAR 0 6
47808: PPUSH
47809: CALL_OW 1
47813: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47814: LD_VAR 0 1
47818: PUSH
47819: LD_EXP 86
47823: PUSH
47824: LD_VAR 0 5
47828: ARRAY
47829: IN
47830: IFFALSE 47869
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47832: LD_ADDR_EXP 86
47836: PUSH
47837: LD_EXP 86
47841: PPUSH
47842: LD_VAR 0 5
47846: PPUSH
47847: LD_EXP 86
47851: PUSH
47852: LD_VAR 0 5
47856: ARRAY
47857: PUSH
47858: LD_VAR 0 1
47862: DIFF
47863: PPUSH
47864: CALL_OW 1
47868: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47869: LD_VAR 0 1
47873: PUSH
47874: LD_EXP 87
47878: PUSH
47879: LD_VAR 0 5
47883: ARRAY
47884: IN
47885: IFFALSE 47924
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47887: LD_ADDR_EXP 87
47891: PUSH
47892: LD_EXP 87
47896: PPUSH
47897: LD_VAR 0 5
47901: PPUSH
47902: LD_EXP 87
47906: PUSH
47907: LD_VAR 0 5
47911: ARRAY
47912: PUSH
47913: LD_VAR 0 1
47917: DIFF
47918: PPUSH
47919: CALL_OW 1
47923: ST_TO_ADDR
// break ;
47924: GO 47928
// end ;
47926: GO 47746
47928: POP
47929: POP
// end ;
47930: LD_VAR 0 4
47934: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47935: LD_INT 0
47937: PPUSH
47938: PPUSH
47939: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47940: LD_EXP 78
47944: NOT
47945: PUSH
47946: LD_EXP 76
47950: NOT
47951: OR
47952: PUSH
47953: LD_VAR 0 3
47957: PUSH
47958: LD_EXP 104
47962: IN
47963: NOT
47964: OR
47965: IFFALSE 47969
// exit ;
47967: GO 48092
// for i = 1 to mc_vehicles do
47969: LD_ADDR_VAR 0 6
47973: PUSH
47974: DOUBLE
47975: LD_INT 1
47977: DEC
47978: ST_TO_ADDR
47979: LD_EXP 97
47983: PUSH
47984: FOR_TO
47985: IFFALSE 48090
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47987: LD_VAR 0 2
47991: PUSH
47992: LD_EXP 97
47996: PUSH
47997: LD_VAR 0 6
48001: ARRAY
48002: IN
48003: PUSH
48004: LD_VAR 0 1
48008: PUSH
48009: LD_EXP 97
48013: PUSH
48014: LD_VAR 0 6
48018: ARRAY
48019: IN
48020: OR
48021: IFFALSE 48088
// begin tmp := mc_vehicles [ i ] diff old ;
48023: LD_ADDR_VAR 0 7
48027: PUSH
48028: LD_EXP 97
48032: PUSH
48033: LD_VAR 0 6
48037: ARRAY
48038: PUSH
48039: LD_VAR 0 2
48043: DIFF
48044: ST_TO_ADDR
// tmp := tmp diff new ;
48045: LD_ADDR_VAR 0 7
48049: PUSH
48050: LD_VAR 0 7
48054: PUSH
48055: LD_VAR 0 1
48059: DIFF
48060: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
48061: LD_ADDR_EXP 97
48065: PUSH
48066: LD_EXP 97
48070: PPUSH
48071: LD_VAR 0 6
48075: PPUSH
48076: LD_VAR 0 7
48080: PPUSH
48081: CALL_OW 1
48085: ST_TO_ADDR
// break ;
48086: GO 48090
// end ;
48088: GO 47984
48090: POP
48091: POP
// end ;
48092: LD_VAR 0 5
48096: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
48097: LD_INT 0
48099: PPUSH
48100: PPUSH
48101: PPUSH
48102: PPUSH
// if not mc_bases or not skirmish then
48103: LD_EXP 78
48107: NOT
48108: PUSH
48109: LD_EXP 76
48113: NOT
48114: OR
48115: IFFALSE 48119
// exit ;
48117: GO 48539
// repeat wait ( 0 0$1 ) ;
48119: LD_INT 35
48121: PPUSH
48122: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
48126: LD_EXP 122
48130: NOT
48131: IFFALSE 48119
// mc_block_vehicle_constructed_thread := true ;
48133: LD_ADDR_EXP 122
48137: PUSH
48138: LD_INT 1
48140: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
48141: LD_ADDR_VAR 0 5
48145: PUSH
48146: LD_VAR 0 1
48150: PPUSH
48151: CALL_OW 255
48155: ST_TO_ADDR
// for i = 1 to mc_bases do
48156: LD_ADDR_VAR 0 4
48160: PUSH
48161: DOUBLE
48162: LD_INT 1
48164: DEC
48165: ST_TO_ADDR
48166: LD_EXP 78
48170: PUSH
48171: FOR_TO
48172: IFFALSE 48529
// begin if factory in mc_bases [ i ] then
48174: LD_VAR 0 2
48178: PUSH
48179: LD_EXP 78
48183: PUSH
48184: LD_VAR 0 4
48188: ARRAY
48189: IN
48190: IFFALSE 48527
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48192: LD_EXP 100
48196: PUSH
48197: LD_VAR 0 4
48201: ARRAY
48202: PUSH
48203: LD_EXP 89
48207: PUSH
48208: LD_VAR 0 4
48212: ARRAY
48213: LESS
48214: PUSH
48215: LD_VAR 0 1
48219: PPUSH
48220: CALL_OW 264
48224: PUSH
48225: LD_INT 31
48227: PUSH
48228: LD_INT 32
48230: PUSH
48231: LD_INT 51
48233: PUSH
48234: LD_INT 89
48236: PUSH
48237: LD_INT 12
48239: PUSH
48240: LD_INT 30
48242: PUSH
48243: LD_INT 98
48245: PUSH
48246: LD_INT 11
48248: PUSH
48249: LD_INT 53
48251: PUSH
48252: LD_INT 14
48254: PUSH
48255: LD_INT 91
48257: PUSH
48258: LD_INT 29
48260: PUSH
48261: LD_INT 99
48263: PUSH
48264: LD_INT 13
48266: PUSH
48267: LD_INT 52
48269: PUSH
48270: LD_INT 88
48272: PUSH
48273: LD_INT 48
48275: PUSH
48276: LD_INT 8
48278: PUSH
48279: EMPTY
48280: LIST
48281: LIST
48282: LIST
48283: LIST
48284: LIST
48285: LIST
48286: LIST
48287: LIST
48288: LIST
48289: LIST
48290: LIST
48291: LIST
48292: LIST
48293: LIST
48294: LIST
48295: LIST
48296: LIST
48297: LIST
48298: IN
48299: NOT
48300: AND
48301: IFFALSE 48349
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48303: LD_ADDR_EXP 100
48307: PUSH
48308: LD_EXP 100
48312: PPUSH
48313: LD_VAR 0 4
48317: PUSH
48318: LD_EXP 100
48322: PUSH
48323: LD_VAR 0 4
48327: ARRAY
48328: PUSH
48329: LD_INT 1
48331: PLUS
48332: PUSH
48333: EMPTY
48334: LIST
48335: LIST
48336: PPUSH
48337: LD_VAR 0 1
48341: PPUSH
48342: CALL 57174 0 3
48346: ST_TO_ADDR
48347: GO 48393
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48349: LD_ADDR_EXP 97
48353: PUSH
48354: LD_EXP 97
48358: PPUSH
48359: LD_VAR 0 4
48363: PUSH
48364: LD_EXP 97
48368: PUSH
48369: LD_VAR 0 4
48373: ARRAY
48374: PUSH
48375: LD_INT 1
48377: PLUS
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PPUSH
48383: LD_VAR 0 1
48387: PPUSH
48388: CALL 57174 0 3
48392: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
48393: LD_ADDR_EXP 122
48397: PUSH
48398: LD_INT 0
48400: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48401: LD_VAR 0 1
48405: PPUSH
48406: CALL_OW 263
48410: PUSH
48411: LD_INT 2
48413: EQUAL
48414: IFFALSE 48443
// begin repeat wait ( 0 0$3 ) ;
48416: LD_INT 105
48418: PPUSH
48419: CALL_OW 67
// Connect ( vehicle ) ;
48423: LD_VAR 0 1
48427: PPUSH
48428: CALL 60143 0 1
// until IsControledBy ( vehicle ) ;
48432: LD_VAR 0 1
48436: PPUSH
48437: CALL_OW 312
48441: IFFALSE 48416
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48443: LD_VAR 0 1
48447: PPUSH
48448: LD_EXP 102
48452: PUSH
48453: LD_VAR 0 4
48457: ARRAY
48458: PPUSH
48459: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48463: LD_VAR 0 1
48467: PPUSH
48468: CALL_OW 263
48472: PUSH
48473: LD_INT 1
48475: NONEQUAL
48476: IFFALSE 48480
// break ;
48478: GO 48529
// repeat wait ( 0 0$1 ) ;
48480: LD_INT 35
48482: PPUSH
48483: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48487: LD_VAR 0 1
48491: PPUSH
48492: LD_EXP 102
48496: PUSH
48497: LD_VAR 0 4
48501: ARRAY
48502: PPUSH
48503: CALL_OW 308
48507: IFFALSE 48480
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48509: LD_VAR 0 1
48513: PPUSH
48514: CALL_OW 311
48518: PPUSH
48519: CALL_OW 121
// exit ;
48523: POP
48524: POP
48525: GO 48539
// end ; end ;
48527: GO 48171
48529: POP
48530: POP
// mc_block_vehicle_constructed_thread := false ;
48531: LD_ADDR_EXP 122
48535: PUSH
48536: LD_INT 0
48538: ST_TO_ADDR
// end ;
48539: LD_VAR 0 3
48543: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48544: LD_INT 0
48546: PPUSH
48547: PPUSH
48548: PPUSH
48549: PPUSH
// if not mc_bases or not skirmish then
48550: LD_EXP 78
48554: NOT
48555: PUSH
48556: LD_EXP 76
48560: NOT
48561: OR
48562: IFFALSE 48566
// exit ;
48564: GO 48919
// repeat wait ( 0 0$1 ) ;
48566: LD_INT 35
48568: PPUSH
48569: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48573: LD_VAR 0 2
48577: PPUSH
48578: LD_VAR 0 3
48582: PPUSH
48583: CALL_OW 284
48587: IFFALSE 48566
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48589: LD_VAR 0 2
48593: PPUSH
48594: LD_VAR 0 3
48598: PPUSH
48599: CALL_OW 283
48603: PUSH
48604: LD_INT 4
48606: EQUAL
48607: IFFALSE 48611
// exit ;
48609: GO 48919
// for i = 1 to mc_bases do
48611: LD_ADDR_VAR 0 7
48615: PUSH
48616: DOUBLE
48617: LD_INT 1
48619: DEC
48620: ST_TO_ADDR
48621: LD_EXP 78
48625: PUSH
48626: FOR_TO
48627: IFFALSE 48917
// begin if mc_crates_area [ i ] then
48629: LD_EXP 96
48633: PUSH
48634: LD_VAR 0 7
48638: ARRAY
48639: IFFALSE 48750
// for j in mc_crates_area [ i ] do
48641: LD_ADDR_VAR 0 8
48645: PUSH
48646: LD_EXP 96
48650: PUSH
48651: LD_VAR 0 7
48655: ARRAY
48656: PUSH
48657: FOR_IN
48658: IFFALSE 48748
// if InArea ( x , y , j ) then
48660: LD_VAR 0 2
48664: PPUSH
48665: LD_VAR 0 3
48669: PPUSH
48670: LD_VAR 0 8
48674: PPUSH
48675: CALL_OW 309
48679: IFFALSE 48746
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48681: LD_ADDR_EXP 94
48685: PUSH
48686: LD_EXP 94
48690: PPUSH
48691: LD_VAR 0 7
48695: PUSH
48696: LD_EXP 94
48700: PUSH
48701: LD_VAR 0 7
48705: ARRAY
48706: PUSH
48707: LD_INT 1
48709: PLUS
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PPUSH
48715: LD_VAR 0 4
48719: PUSH
48720: LD_VAR 0 2
48724: PUSH
48725: LD_VAR 0 3
48729: PUSH
48730: EMPTY
48731: LIST
48732: LIST
48733: LIST
48734: PPUSH
48735: CALL 57174 0 3
48739: ST_TO_ADDR
// exit ;
48740: POP
48741: POP
48742: POP
48743: POP
48744: GO 48919
// end ;
48746: GO 48657
48748: POP
48749: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48750: LD_ADDR_VAR 0 9
48754: PUSH
48755: LD_EXP 78
48759: PUSH
48760: LD_VAR 0 7
48764: ARRAY
48765: PPUSH
48766: LD_INT 2
48768: PUSH
48769: LD_INT 30
48771: PUSH
48772: LD_INT 0
48774: PUSH
48775: EMPTY
48776: LIST
48777: LIST
48778: PUSH
48779: LD_INT 30
48781: PUSH
48782: LD_INT 1
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: PUSH
48789: EMPTY
48790: LIST
48791: LIST
48792: LIST
48793: PPUSH
48794: CALL_OW 72
48798: ST_TO_ADDR
// if not depot then
48799: LD_VAR 0 9
48803: NOT
48804: IFFALSE 48808
// continue ;
48806: GO 48626
// for j in depot do
48808: LD_ADDR_VAR 0 8
48812: PUSH
48813: LD_VAR 0 9
48817: PUSH
48818: FOR_IN
48819: IFFALSE 48913
// if GetDistUnitXY ( j , x , y ) < 30 then
48821: LD_VAR 0 8
48825: PPUSH
48826: LD_VAR 0 2
48830: PPUSH
48831: LD_VAR 0 3
48835: PPUSH
48836: CALL_OW 297
48840: PUSH
48841: LD_INT 30
48843: LESS
48844: IFFALSE 48911
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48846: LD_ADDR_EXP 94
48850: PUSH
48851: LD_EXP 94
48855: PPUSH
48856: LD_VAR 0 7
48860: PUSH
48861: LD_EXP 94
48865: PUSH
48866: LD_VAR 0 7
48870: ARRAY
48871: PUSH
48872: LD_INT 1
48874: PLUS
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PPUSH
48880: LD_VAR 0 4
48884: PUSH
48885: LD_VAR 0 2
48889: PUSH
48890: LD_VAR 0 3
48894: PUSH
48895: EMPTY
48896: LIST
48897: LIST
48898: LIST
48899: PPUSH
48900: CALL 57174 0 3
48904: ST_TO_ADDR
// exit ;
48905: POP
48906: POP
48907: POP
48908: POP
48909: GO 48919
// end ;
48911: GO 48818
48913: POP
48914: POP
// end ;
48915: GO 48626
48917: POP
48918: POP
// end ;
48919: LD_VAR 0 6
48923: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48924: LD_INT 0
48926: PPUSH
48927: PPUSH
48928: PPUSH
48929: PPUSH
// if not mc_bases or not skirmish then
48930: LD_EXP 78
48934: NOT
48935: PUSH
48936: LD_EXP 76
48940: NOT
48941: OR
48942: IFFALSE 48946
// exit ;
48944: GO 49223
// side := GetSide ( lab ) ;
48946: LD_ADDR_VAR 0 4
48950: PUSH
48951: LD_VAR 0 2
48955: PPUSH
48956: CALL_OW 255
48960: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48961: LD_VAR 0 4
48965: PUSH
48966: LD_EXP 104
48970: IN
48971: NOT
48972: PUSH
48973: LD_EXP 105
48977: NOT
48978: OR
48979: PUSH
48980: LD_EXP 78
48984: NOT
48985: OR
48986: IFFALSE 48990
// exit ;
48988: GO 49223
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48990: LD_ADDR_EXP 105
48994: PUSH
48995: LD_EXP 105
48999: PPUSH
49000: LD_VAR 0 4
49004: PPUSH
49005: LD_EXP 105
49009: PUSH
49010: LD_VAR 0 4
49014: ARRAY
49015: PUSH
49016: LD_VAR 0 1
49020: DIFF
49021: PPUSH
49022: CALL_OW 1
49026: ST_TO_ADDR
// for i = 1 to mc_bases do
49027: LD_ADDR_VAR 0 5
49031: PUSH
49032: DOUBLE
49033: LD_INT 1
49035: DEC
49036: ST_TO_ADDR
49037: LD_EXP 78
49041: PUSH
49042: FOR_TO
49043: IFFALSE 49221
// begin if lab in mc_bases [ i ] then
49045: LD_VAR 0 2
49049: PUSH
49050: LD_EXP 78
49054: PUSH
49055: LD_VAR 0 5
49059: ARRAY
49060: IN
49061: IFFALSE 49219
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
49063: LD_VAR 0 1
49067: PUSH
49068: LD_INT 11
49070: PUSH
49071: LD_INT 4
49073: PUSH
49074: LD_INT 3
49076: PUSH
49077: LD_INT 2
49079: PUSH
49080: EMPTY
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: IN
49086: PUSH
49087: LD_EXP 108
49091: PUSH
49092: LD_VAR 0 5
49096: ARRAY
49097: AND
49098: IFFALSE 49219
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
49100: LD_ADDR_VAR 0 6
49104: PUSH
49105: LD_EXP 108
49109: PUSH
49110: LD_VAR 0 5
49114: ARRAY
49115: PUSH
49116: LD_INT 1
49118: ARRAY
49119: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49120: LD_ADDR_EXP 108
49124: PUSH
49125: LD_EXP 108
49129: PPUSH
49130: LD_VAR 0 5
49134: PPUSH
49135: EMPTY
49136: PPUSH
49137: CALL_OW 1
49141: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
49142: LD_VAR 0 6
49146: PPUSH
49147: LD_INT 0
49149: PPUSH
49150: CALL_OW 109
// ComExitBuilding ( tmp ) ;
49154: LD_VAR 0 6
49158: PPUSH
49159: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
49163: LD_ADDR_EXP 107
49167: PUSH
49168: LD_EXP 107
49172: PPUSH
49173: LD_VAR 0 5
49177: PPUSH
49178: LD_EXP 107
49182: PUSH
49183: LD_VAR 0 5
49187: ARRAY
49188: PPUSH
49189: LD_INT 1
49191: PPUSH
49192: LD_VAR 0 6
49196: PPUSH
49197: CALL_OW 2
49201: PPUSH
49202: CALL_OW 1
49206: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49207: LD_VAR 0 5
49211: PPUSH
49212: LD_INT 112
49214: PPUSH
49215: CALL 25687 0 2
// end ; end ; end ;
49219: GO 49042
49221: POP
49222: POP
// end ;
49223: LD_VAR 0 3
49227: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49228: LD_INT 0
49230: PPUSH
49231: PPUSH
49232: PPUSH
49233: PPUSH
49234: PPUSH
49235: PPUSH
49236: PPUSH
49237: PPUSH
// if not mc_bases or not skirmish then
49238: LD_EXP 78
49242: NOT
49243: PUSH
49244: LD_EXP 76
49248: NOT
49249: OR
49250: IFFALSE 49254
// exit ;
49252: GO 50623
// for i = 1 to mc_bases do
49254: LD_ADDR_VAR 0 3
49258: PUSH
49259: DOUBLE
49260: LD_INT 1
49262: DEC
49263: ST_TO_ADDR
49264: LD_EXP 78
49268: PUSH
49269: FOR_TO
49270: IFFALSE 50621
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49272: LD_VAR 0 1
49276: PUSH
49277: LD_EXP 78
49281: PUSH
49282: LD_VAR 0 3
49286: ARRAY
49287: IN
49288: PUSH
49289: LD_VAR 0 1
49293: PUSH
49294: LD_EXP 85
49298: PUSH
49299: LD_VAR 0 3
49303: ARRAY
49304: IN
49305: OR
49306: PUSH
49307: LD_VAR 0 1
49311: PUSH
49312: LD_EXP 100
49316: PUSH
49317: LD_VAR 0 3
49321: ARRAY
49322: IN
49323: OR
49324: PUSH
49325: LD_VAR 0 1
49329: PUSH
49330: LD_EXP 97
49334: PUSH
49335: LD_VAR 0 3
49339: ARRAY
49340: IN
49341: OR
49342: PUSH
49343: LD_VAR 0 1
49347: PUSH
49348: LD_EXP 107
49352: PUSH
49353: LD_VAR 0 3
49357: ARRAY
49358: IN
49359: OR
49360: PUSH
49361: LD_VAR 0 1
49365: PUSH
49366: LD_EXP 108
49370: PUSH
49371: LD_VAR 0 3
49375: ARRAY
49376: IN
49377: OR
49378: IFFALSE 50619
// begin if un in mc_ape [ i ] then
49380: LD_VAR 0 1
49384: PUSH
49385: LD_EXP 107
49389: PUSH
49390: LD_VAR 0 3
49394: ARRAY
49395: IN
49396: IFFALSE 49435
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49398: LD_ADDR_EXP 107
49402: PUSH
49403: LD_EXP 107
49407: PPUSH
49408: LD_VAR 0 3
49412: PPUSH
49413: LD_EXP 107
49417: PUSH
49418: LD_VAR 0 3
49422: ARRAY
49423: PUSH
49424: LD_VAR 0 1
49428: DIFF
49429: PPUSH
49430: CALL_OW 1
49434: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49435: LD_VAR 0 1
49439: PUSH
49440: LD_EXP 108
49444: PUSH
49445: LD_VAR 0 3
49449: ARRAY
49450: IN
49451: IFFALSE 49475
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49453: LD_ADDR_EXP 108
49457: PUSH
49458: LD_EXP 108
49462: PPUSH
49463: LD_VAR 0 3
49467: PPUSH
49468: EMPTY
49469: PPUSH
49470: CALL_OW 1
49474: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49475: LD_VAR 0 1
49479: PPUSH
49480: CALL_OW 247
49484: PUSH
49485: LD_INT 2
49487: EQUAL
49488: PUSH
49489: LD_VAR 0 1
49493: PPUSH
49494: CALL_OW 110
49498: PUSH
49499: LD_INT 20
49501: EQUAL
49502: PUSH
49503: LD_VAR 0 1
49507: PUSH
49508: LD_EXP 100
49512: PUSH
49513: LD_VAR 0 3
49517: ARRAY
49518: IN
49519: OR
49520: PUSH
49521: LD_VAR 0 1
49525: PPUSH
49526: CALL_OW 264
49530: PUSH
49531: LD_INT 12
49533: PUSH
49534: LD_INT 51
49536: PUSH
49537: LD_INT 89
49539: PUSH
49540: LD_INT 32
49542: PUSH
49543: LD_INT 13
49545: PUSH
49546: LD_INT 52
49548: PUSH
49549: LD_INT 31
49551: PUSH
49552: EMPTY
49553: LIST
49554: LIST
49555: LIST
49556: LIST
49557: LIST
49558: LIST
49559: LIST
49560: IN
49561: OR
49562: AND
49563: IFFALSE 49871
// begin if un in mc_defender [ i ] then
49565: LD_VAR 0 1
49569: PUSH
49570: LD_EXP 100
49574: PUSH
49575: LD_VAR 0 3
49579: ARRAY
49580: IN
49581: IFFALSE 49620
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49583: LD_ADDR_EXP 100
49587: PUSH
49588: LD_EXP 100
49592: PPUSH
49593: LD_VAR 0 3
49597: PPUSH
49598: LD_EXP 100
49602: PUSH
49603: LD_VAR 0 3
49607: ARRAY
49608: PUSH
49609: LD_VAR 0 1
49613: DIFF
49614: PPUSH
49615: CALL_OW 1
49619: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49620: LD_ADDR_VAR 0 8
49624: PUSH
49625: LD_VAR 0 3
49629: PPUSH
49630: LD_INT 3
49632: PPUSH
49633: CALL 46241 0 2
49637: ST_TO_ADDR
// if fac then
49638: LD_VAR 0 8
49642: IFFALSE 49871
// begin for j in fac do
49644: LD_ADDR_VAR 0 4
49648: PUSH
49649: LD_VAR 0 8
49653: PUSH
49654: FOR_IN
49655: IFFALSE 49869
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49657: LD_ADDR_VAR 0 9
49661: PUSH
49662: LD_VAR 0 8
49666: PPUSH
49667: LD_VAR 0 1
49671: PPUSH
49672: CALL_OW 265
49676: PPUSH
49677: LD_VAR 0 1
49681: PPUSH
49682: CALL_OW 262
49686: PPUSH
49687: LD_VAR 0 1
49691: PPUSH
49692: CALL_OW 263
49696: PPUSH
49697: LD_VAR 0 1
49701: PPUSH
49702: CALL_OW 264
49706: PPUSH
49707: CALL 54672 0 5
49711: ST_TO_ADDR
// if components then
49712: LD_VAR 0 9
49716: IFFALSE 49867
// begin if GetWeapon ( un ) = ar_control_tower then
49718: LD_VAR 0 1
49722: PPUSH
49723: CALL_OW 264
49727: PUSH
49728: LD_INT 31
49730: EQUAL
49731: IFFALSE 49848
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49733: LD_VAR 0 1
49737: PPUSH
49738: CALL_OW 311
49742: PPUSH
49743: LD_INT 0
49745: PPUSH
49746: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49750: LD_ADDR_EXP 118
49754: PUSH
49755: LD_EXP 118
49759: PPUSH
49760: LD_VAR 0 3
49764: PPUSH
49765: LD_EXP 118
49769: PUSH
49770: LD_VAR 0 3
49774: ARRAY
49775: PUSH
49776: LD_VAR 0 1
49780: PPUSH
49781: CALL_OW 311
49785: DIFF
49786: PPUSH
49787: CALL_OW 1
49791: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49792: LD_ADDR_VAR 0 7
49796: PUSH
49797: LD_EXP 99
49801: PUSH
49802: LD_VAR 0 3
49806: ARRAY
49807: PPUSH
49808: LD_INT 1
49810: PPUSH
49811: LD_VAR 0 9
49815: PPUSH
49816: CALL_OW 2
49820: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49821: LD_ADDR_EXP 99
49825: PUSH
49826: LD_EXP 99
49830: PPUSH
49831: LD_VAR 0 3
49835: PPUSH
49836: LD_VAR 0 7
49840: PPUSH
49841: CALL_OW 1
49845: ST_TO_ADDR
// end else
49846: GO 49865
// MC_InsertProduceList ( i , [ components ] ) ;
49848: LD_VAR 0 3
49852: PPUSH
49853: LD_VAR 0 9
49857: PUSH
49858: EMPTY
49859: LIST
49860: PPUSH
49861: CALL 45786 0 2
// break ;
49865: GO 49869
// end ; end ;
49867: GO 49654
49869: POP
49870: POP
// end ; end ; if GetType ( un ) = unit_building then
49871: LD_VAR 0 1
49875: PPUSH
49876: CALL_OW 247
49880: PUSH
49881: LD_INT 3
49883: EQUAL
49884: IFFALSE 50287
// begin btype := GetBType ( un ) ;
49886: LD_ADDR_VAR 0 5
49890: PUSH
49891: LD_VAR 0 1
49895: PPUSH
49896: CALL_OW 266
49900: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49901: LD_VAR 0 5
49905: PUSH
49906: LD_INT 29
49908: PUSH
49909: LD_INT 30
49911: PUSH
49912: EMPTY
49913: LIST
49914: LIST
49915: IN
49916: IFFALSE 49989
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49918: LD_VAR 0 1
49922: PPUSH
49923: CALL_OW 250
49927: PPUSH
49928: LD_VAR 0 1
49932: PPUSH
49933: CALL_OW 251
49937: PPUSH
49938: LD_VAR 0 1
49942: PPUSH
49943: CALL_OW 255
49947: PPUSH
49948: CALL_OW 440
49952: NOT
49953: IFFALSE 49989
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49955: LD_VAR 0 1
49959: PPUSH
49960: CALL_OW 250
49964: PPUSH
49965: LD_VAR 0 1
49969: PPUSH
49970: CALL_OW 251
49974: PPUSH
49975: LD_VAR 0 1
49979: PPUSH
49980: CALL_OW 255
49984: PPUSH
49985: CALL_OW 441
// end ; if btype = b_warehouse then
49989: LD_VAR 0 5
49993: PUSH
49994: LD_INT 1
49996: EQUAL
49997: IFFALSE 50015
// begin btype := b_depot ;
49999: LD_ADDR_VAR 0 5
50003: PUSH
50004: LD_INT 0
50006: ST_TO_ADDR
// pos := 1 ;
50007: LD_ADDR_VAR 0 6
50011: PUSH
50012: LD_INT 1
50014: ST_TO_ADDR
// end ; if btype = b_factory then
50015: LD_VAR 0 5
50019: PUSH
50020: LD_INT 3
50022: EQUAL
50023: IFFALSE 50041
// begin btype := b_workshop ;
50025: LD_ADDR_VAR 0 5
50029: PUSH
50030: LD_INT 2
50032: ST_TO_ADDR
// pos := 1 ;
50033: LD_ADDR_VAR 0 6
50037: PUSH
50038: LD_INT 1
50040: ST_TO_ADDR
// end ; if btype = b_barracks then
50041: LD_VAR 0 5
50045: PUSH
50046: LD_INT 5
50048: EQUAL
50049: IFFALSE 50059
// btype := b_armoury ;
50051: LD_ADDR_VAR 0 5
50055: PUSH
50056: LD_INT 4
50058: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
50059: LD_VAR 0 5
50063: PUSH
50064: LD_INT 7
50066: PUSH
50067: LD_INT 8
50069: PUSH
50070: EMPTY
50071: LIST
50072: LIST
50073: IN
50074: IFFALSE 50084
// btype := b_lab ;
50076: LD_ADDR_VAR 0 5
50080: PUSH
50081: LD_INT 6
50083: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
50084: LD_ADDR_EXP 83
50088: PUSH
50089: LD_EXP 83
50093: PPUSH
50094: LD_VAR 0 3
50098: PUSH
50099: LD_EXP 83
50103: PUSH
50104: LD_VAR 0 3
50108: ARRAY
50109: PUSH
50110: LD_INT 1
50112: PLUS
50113: PUSH
50114: EMPTY
50115: LIST
50116: LIST
50117: PPUSH
50118: LD_VAR 0 5
50122: PUSH
50123: LD_VAR 0 1
50127: PPUSH
50128: CALL_OW 250
50132: PUSH
50133: LD_VAR 0 1
50137: PPUSH
50138: CALL_OW 251
50142: PUSH
50143: LD_VAR 0 1
50147: PPUSH
50148: CALL_OW 254
50152: PUSH
50153: EMPTY
50154: LIST
50155: LIST
50156: LIST
50157: LIST
50158: PPUSH
50159: CALL 57174 0 3
50163: ST_TO_ADDR
// if pos = 1 then
50164: LD_VAR 0 6
50168: PUSH
50169: LD_INT 1
50171: EQUAL
50172: IFFALSE 50287
// begin tmp := mc_build_list [ i ] ;
50174: LD_ADDR_VAR 0 7
50178: PUSH
50179: LD_EXP 83
50183: PUSH
50184: LD_VAR 0 3
50188: ARRAY
50189: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50190: LD_VAR 0 7
50194: PPUSH
50195: LD_INT 2
50197: PUSH
50198: LD_INT 30
50200: PUSH
50201: LD_INT 0
50203: PUSH
50204: EMPTY
50205: LIST
50206: LIST
50207: PUSH
50208: LD_INT 30
50210: PUSH
50211: LD_INT 1
50213: PUSH
50214: EMPTY
50215: LIST
50216: LIST
50217: PUSH
50218: EMPTY
50219: LIST
50220: LIST
50221: LIST
50222: PPUSH
50223: CALL_OW 72
50227: IFFALSE 50237
// pos := 2 ;
50229: LD_ADDR_VAR 0 6
50233: PUSH
50234: LD_INT 2
50236: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50237: LD_ADDR_VAR 0 7
50241: PUSH
50242: LD_VAR 0 7
50246: PPUSH
50247: LD_VAR 0 6
50251: PPUSH
50252: LD_VAR 0 7
50256: PPUSH
50257: CALL 57500 0 3
50261: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50262: LD_ADDR_EXP 83
50266: PUSH
50267: LD_EXP 83
50271: PPUSH
50272: LD_VAR 0 3
50276: PPUSH
50277: LD_VAR 0 7
50281: PPUSH
50282: CALL_OW 1
50286: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50287: LD_VAR 0 1
50291: PUSH
50292: LD_EXP 78
50296: PUSH
50297: LD_VAR 0 3
50301: ARRAY
50302: IN
50303: IFFALSE 50342
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50305: LD_ADDR_EXP 78
50309: PUSH
50310: LD_EXP 78
50314: PPUSH
50315: LD_VAR 0 3
50319: PPUSH
50320: LD_EXP 78
50324: PUSH
50325: LD_VAR 0 3
50329: ARRAY
50330: PUSH
50331: LD_VAR 0 1
50335: DIFF
50336: PPUSH
50337: CALL_OW 1
50341: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50342: LD_VAR 0 1
50346: PUSH
50347: LD_EXP 85
50351: PUSH
50352: LD_VAR 0 3
50356: ARRAY
50357: IN
50358: IFFALSE 50397
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50360: LD_ADDR_EXP 85
50364: PUSH
50365: LD_EXP 85
50369: PPUSH
50370: LD_VAR 0 3
50374: PPUSH
50375: LD_EXP 85
50379: PUSH
50380: LD_VAR 0 3
50384: ARRAY
50385: PUSH
50386: LD_VAR 0 1
50390: DIFF
50391: PPUSH
50392: CALL_OW 1
50396: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50397: LD_VAR 0 1
50401: PUSH
50402: LD_EXP 97
50406: PUSH
50407: LD_VAR 0 3
50411: ARRAY
50412: IN
50413: IFFALSE 50452
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50415: LD_ADDR_EXP 97
50419: PUSH
50420: LD_EXP 97
50424: PPUSH
50425: LD_VAR 0 3
50429: PPUSH
50430: LD_EXP 97
50434: PUSH
50435: LD_VAR 0 3
50439: ARRAY
50440: PUSH
50441: LD_VAR 0 1
50445: DIFF
50446: PPUSH
50447: CALL_OW 1
50451: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50452: LD_VAR 0 1
50456: PUSH
50457: LD_EXP 100
50461: PUSH
50462: LD_VAR 0 3
50466: ARRAY
50467: IN
50468: IFFALSE 50507
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50470: LD_ADDR_EXP 100
50474: PUSH
50475: LD_EXP 100
50479: PPUSH
50480: LD_VAR 0 3
50484: PPUSH
50485: LD_EXP 100
50489: PUSH
50490: LD_VAR 0 3
50494: ARRAY
50495: PUSH
50496: LD_VAR 0 1
50500: DIFF
50501: PPUSH
50502: CALL_OW 1
50506: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50507: LD_VAR 0 1
50511: PUSH
50512: LD_EXP 87
50516: PUSH
50517: LD_VAR 0 3
50521: ARRAY
50522: IN
50523: IFFALSE 50562
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50525: LD_ADDR_EXP 87
50529: PUSH
50530: LD_EXP 87
50534: PPUSH
50535: LD_VAR 0 3
50539: PPUSH
50540: LD_EXP 87
50544: PUSH
50545: LD_VAR 0 3
50549: ARRAY
50550: PUSH
50551: LD_VAR 0 1
50555: DIFF
50556: PPUSH
50557: CALL_OW 1
50561: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50562: LD_VAR 0 1
50566: PUSH
50567: LD_EXP 86
50571: PUSH
50572: LD_VAR 0 3
50576: ARRAY
50577: IN
50578: IFFALSE 50617
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50580: LD_ADDR_EXP 86
50584: PUSH
50585: LD_EXP 86
50589: PPUSH
50590: LD_VAR 0 3
50594: PPUSH
50595: LD_EXP 86
50599: PUSH
50600: LD_VAR 0 3
50604: ARRAY
50605: PUSH
50606: LD_VAR 0 1
50610: DIFF
50611: PPUSH
50612: CALL_OW 1
50616: ST_TO_ADDR
// end ; break ;
50617: GO 50621
// end ;
50619: GO 49269
50621: POP
50622: POP
// end ;
50623: LD_VAR 0 2
50627: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50628: LD_INT 0
50630: PPUSH
50631: PPUSH
50632: PPUSH
// if not mc_bases or not skirmish then
50633: LD_EXP 78
50637: NOT
50638: PUSH
50639: LD_EXP 76
50643: NOT
50644: OR
50645: IFFALSE 50649
// exit ;
50647: GO 50864
// for i = 1 to mc_bases do
50649: LD_ADDR_VAR 0 3
50653: PUSH
50654: DOUBLE
50655: LD_INT 1
50657: DEC
50658: ST_TO_ADDR
50659: LD_EXP 78
50663: PUSH
50664: FOR_TO
50665: IFFALSE 50862
// begin if building in mc_construct_list [ i ] then
50667: LD_VAR 0 1
50671: PUSH
50672: LD_EXP 85
50676: PUSH
50677: LD_VAR 0 3
50681: ARRAY
50682: IN
50683: IFFALSE 50860
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50685: LD_ADDR_EXP 85
50689: PUSH
50690: LD_EXP 85
50694: PPUSH
50695: LD_VAR 0 3
50699: PPUSH
50700: LD_EXP 85
50704: PUSH
50705: LD_VAR 0 3
50709: ARRAY
50710: PUSH
50711: LD_VAR 0 1
50715: DIFF
50716: PPUSH
50717: CALL_OW 1
50721: ST_TO_ADDR
// if building in mc_lab [ i ] then
50722: LD_VAR 0 1
50726: PUSH
50727: LD_EXP 111
50731: PUSH
50732: LD_VAR 0 3
50736: ARRAY
50737: IN
50738: IFFALSE 50793
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50740: LD_ADDR_EXP 112
50744: PUSH
50745: LD_EXP 112
50749: PPUSH
50750: LD_VAR 0 3
50754: PPUSH
50755: LD_EXP 112
50759: PUSH
50760: LD_VAR 0 3
50764: ARRAY
50765: PPUSH
50766: LD_INT 1
50768: PPUSH
50769: LD_EXP 112
50773: PUSH
50774: LD_VAR 0 3
50778: ARRAY
50779: PPUSH
50780: LD_INT 0
50782: PPUSH
50783: CALL 56592 0 4
50787: PPUSH
50788: CALL_OW 1
50792: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50793: LD_VAR 0 1
50797: PUSH
50798: LD_EXP 78
50802: PUSH
50803: LD_VAR 0 3
50807: ARRAY
50808: IN
50809: NOT
50810: IFFALSE 50856
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50812: LD_ADDR_EXP 78
50816: PUSH
50817: LD_EXP 78
50821: PPUSH
50822: LD_VAR 0 3
50826: PUSH
50827: LD_EXP 78
50831: PUSH
50832: LD_VAR 0 3
50836: ARRAY
50837: PUSH
50838: LD_INT 1
50840: PLUS
50841: PUSH
50842: EMPTY
50843: LIST
50844: LIST
50845: PPUSH
50846: LD_VAR 0 1
50850: PPUSH
50851: CALL 57174 0 3
50855: ST_TO_ADDR
// exit ;
50856: POP
50857: POP
50858: GO 50864
// end ; end ;
50860: GO 50664
50862: POP
50863: POP
// end ;
50864: LD_VAR 0 2
50868: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50869: LD_INT 0
50871: PPUSH
50872: PPUSH
50873: PPUSH
50874: PPUSH
50875: PPUSH
50876: PPUSH
50877: PPUSH
// if not mc_bases or not skirmish then
50878: LD_EXP 78
50882: NOT
50883: PUSH
50884: LD_EXP 76
50888: NOT
50889: OR
50890: IFFALSE 50894
// exit ;
50892: GO 51555
// for i = 1 to mc_bases do
50894: LD_ADDR_VAR 0 3
50898: PUSH
50899: DOUBLE
50900: LD_INT 1
50902: DEC
50903: ST_TO_ADDR
50904: LD_EXP 78
50908: PUSH
50909: FOR_TO
50910: IFFALSE 51553
// begin if building in mc_construct_list [ i ] then
50912: LD_VAR 0 1
50916: PUSH
50917: LD_EXP 85
50921: PUSH
50922: LD_VAR 0 3
50926: ARRAY
50927: IN
50928: IFFALSE 51551
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50930: LD_ADDR_EXP 85
50934: PUSH
50935: LD_EXP 85
50939: PPUSH
50940: LD_VAR 0 3
50944: PPUSH
50945: LD_EXP 85
50949: PUSH
50950: LD_VAR 0 3
50954: ARRAY
50955: PUSH
50956: LD_VAR 0 1
50960: DIFF
50961: PPUSH
50962: CALL_OW 1
50966: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50967: LD_ADDR_EXP 78
50971: PUSH
50972: LD_EXP 78
50976: PPUSH
50977: LD_VAR 0 3
50981: PUSH
50982: LD_EXP 78
50986: PUSH
50987: LD_VAR 0 3
50991: ARRAY
50992: PUSH
50993: LD_INT 1
50995: PLUS
50996: PUSH
50997: EMPTY
50998: LIST
50999: LIST
51000: PPUSH
51001: LD_VAR 0 1
51005: PPUSH
51006: CALL 57174 0 3
51010: ST_TO_ADDR
// btype := GetBType ( building ) ;
51011: LD_ADDR_VAR 0 5
51015: PUSH
51016: LD_VAR 0 1
51020: PPUSH
51021: CALL_OW 266
51025: ST_TO_ADDR
// side := GetSide ( building ) ;
51026: LD_ADDR_VAR 0 8
51030: PUSH
51031: LD_VAR 0 1
51035: PPUSH
51036: CALL_OW 255
51040: ST_TO_ADDR
// if btype = b_lab then
51041: LD_VAR 0 5
51045: PUSH
51046: LD_INT 6
51048: EQUAL
51049: IFFALSE 51099
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
51051: LD_ADDR_EXP 111
51055: PUSH
51056: LD_EXP 111
51060: PPUSH
51061: LD_VAR 0 3
51065: PUSH
51066: LD_EXP 111
51070: PUSH
51071: LD_VAR 0 3
51075: ARRAY
51076: PUSH
51077: LD_INT 1
51079: PLUS
51080: PUSH
51081: EMPTY
51082: LIST
51083: LIST
51084: PPUSH
51085: LD_VAR 0 1
51089: PPUSH
51090: CALL 57174 0 3
51094: ST_TO_ADDR
// exit ;
51095: POP
51096: POP
51097: GO 51555
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
51099: LD_VAR 0 5
51103: PUSH
51104: LD_INT 0
51106: PUSH
51107: LD_INT 2
51109: PUSH
51110: LD_INT 4
51112: PUSH
51113: EMPTY
51114: LIST
51115: LIST
51116: LIST
51117: IN
51118: IFFALSE 51242
// begin if btype = b_armoury then
51120: LD_VAR 0 5
51124: PUSH
51125: LD_INT 4
51127: EQUAL
51128: IFFALSE 51138
// btype := b_barracks ;
51130: LD_ADDR_VAR 0 5
51134: PUSH
51135: LD_INT 5
51137: ST_TO_ADDR
// if btype = b_depot then
51138: LD_VAR 0 5
51142: PUSH
51143: LD_INT 0
51145: EQUAL
51146: IFFALSE 51156
// btype := b_warehouse ;
51148: LD_ADDR_VAR 0 5
51152: PUSH
51153: LD_INT 1
51155: ST_TO_ADDR
// if btype = b_workshop then
51156: LD_VAR 0 5
51160: PUSH
51161: LD_INT 2
51163: EQUAL
51164: IFFALSE 51174
// btype := b_factory ;
51166: LD_ADDR_VAR 0 5
51170: PUSH
51171: LD_INT 3
51173: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
51174: LD_VAR 0 5
51178: PPUSH
51179: LD_VAR 0 8
51183: PPUSH
51184: CALL_OW 323
51188: PUSH
51189: LD_INT 1
51191: EQUAL
51192: IFFALSE 51238
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51194: LD_ADDR_EXP 110
51198: PUSH
51199: LD_EXP 110
51203: PPUSH
51204: LD_VAR 0 3
51208: PUSH
51209: LD_EXP 110
51213: PUSH
51214: LD_VAR 0 3
51218: ARRAY
51219: PUSH
51220: LD_INT 1
51222: PLUS
51223: PUSH
51224: EMPTY
51225: LIST
51226: LIST
51227: PPUSH
51228: LD_VAR 0 1
51232: PPUSH
51233: CALL 57174 0 3
51237: ST_TO_ADDR
// exit ;
51238: POP
51239: POP
51240: GO 51555
// end ; if btype in [ b_bunker , b_turret ] then
51242: LD_VAR 0 5
51246: PUSH
51247: LD_INT 32
51249: PUSH
51250: LD_INT 33
51252: PUSH
51253: EMPTY
51254: LIST
51255: LIST
51256: IN
51257: IFFALSE 51547
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51259: LD_ADDR_EXP 86
51263: PUSH
51264: LD_EXP 86
51268: PPUSH
51269: LD_VAR 0 3
51273: PUSH
51274: LD_EXP 86
51278: PUSH
51279: LD_VAR 0 3
51283: ARRAY
51284: PUSH
51285: LD_INT 1
51287: PLUS
51288: PUSH
51289: EMPTY
51290: LIST
51291: LIST
51292: PPUSH
51293: LD_VAR 0 1
51297: PPUSH
51298: CALL 57174 0 3
51302: ST_TO_ADDR
// if btype = b_bunker then
51303: LD_VAR 0 5
51307: PUSH
51308: LD_INT 32
51310: EQUAL
51311: IFFALSE 51547
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51313: LD_ADDR_EXP 87
51317: PUSH
51318: LD_EXP 87
51322: PPUSH
51323: LD_VAR 0 3
51327: PUSH
51328: LD_EXP 87
51332: PUSH
51333: LD_VAR 0 3
51337: ARRAY
51338: PUSH
51339: LD_INT 1
51341: PLUS
51342: PUSH
51343: EMPTY
51344: LIST
51345: LIST
51346: PPUSH
51347: LD_VAR 0 1
51351: PPUSH
51352: CALL 57174 0 3
51356: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51357: LD_ADDR_VAR 0 6
51361: PUSH
51362: LD_EXP 78
51366: PUSH
51367: LD_VAR 0 3
51371: ARRAY
51372: PPUSH
51373: LD_INT 25
51375: PUSH
51376: LD_INT 1
51378: PUSH
51379: EMPTY
51380: LIST
51381: LIST
51382: PUSH
51383: LD_INT 3
51385: PUSH
51386: LD_INT 54
51388: PUSH
51389: EMPTY
51390: LIST
51391: PUSH
51392: EMPTY
51393: LIST
51394: LIST
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: PPUSH
51400: CALL_OW 72
51404: ST_TO_ADDR
// if tmp then
51405: LD_VAR 0 6
51409: IFFALSE 51415
// exit ;
51411: POP
51412: POP
51413: GO 51555
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51415: LD_ADDR_VAR 0 6
51419: PUSH
51420: LD_EXP 78
51424: PUSH
51425: LD_VAR 0 3
51429: ARRAY
51430: PPUSH
51431: LD_INT 2
51433: PUSH
51434: LD_INT 30
51436: PUSH
51437: LD_INT 4
51439: PUSH
51440: EMPTY
51441: LIST
51442: LIST
51443: PUSH
51444: LD_INT 30
51446: PUSH
51447: LD_INT 5
51449: PUSH
51450: EMPTY
51451: LIST
51452: LIST
51453: PUSH
51454: EMPTY
51455: LIST
51456: LIST
51457: LIST
51458: PPUSH
51459: CALL_OW 72
51463: ST_TO_ADDR
// if not tmp then
51464: LD_VAR 0 6
51468: NOT
51469: IFFALSE 51475
// exit ;
51471: POP
51472: POP
51473: GO 51555
// for j in tmp do
51475: LD_ADDR_VAR 0 4
51479: PUSH
51480: LD_VAR 0 6
51484: PUSH
51485: FOR_IN
51486: IFFALSE 51545
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51488: LD_ADDR_VAR 0 7
51492: PUSH
51493: LD_VAR 0 4
51497: PPUSH
51498: CALL_OW 313
51502: PPUSH
51503: LD_INT 25
51505: PUSH
51506: LD_INT 1
51508: PUSH
51509: EMPTY
51510: LIST
51511: LIST
51512: PPUSH
51513: CALL_OW 72
51517: ST_TO_ADDR
// if units then
51518: LD_VAR 0 7
51522: IFFALSE 51543
// begin ComExitBuilding ( units [ 1 ] ) ;
51524: LD_VAR 0 7
51528: PUSH
51529: LD_INT 1
51531: ARRAY
51532: PPUSH
51533: CALL_OW 122
// exit ;
51537: POP
51538: POP
51539: POP
51540: POP
51541: GO 51555
// end ; end ;
51543: GO 51485
51545: POP
51546: POP
// end ; end ; exit ;
51547: POP
51548: POP
51549: GO 51555
// end ; end ;
51551: GO 50909
51553: POP
51554: POP
// end ;
51555: LD_VAR 0 2
51559: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51560: LD_INT 0
51562: PPUSH
51563: PPUSH
51564: PPUSH
51565: PPUSH
51566: PPUSH
51567: PPUSH
51568: PPUSH
// if not mc_bases or not skirmish then
51569: LD_EXP 78
51573: NOT
51574: PUSH
51575: LD_EXP 76
51579: NOT
51580: OR
51581: IFFALSE 51585
// exit ;
51583: GO 51850
// btype := GetBType ( building ) ;
51585: LD_ADDR_VAR 0 6
51589: PUSH
51590: LD_VAR 0 1
51594: PPUSH
51595: CALL_OW 266
51599: ST_TO_ADDR
// x := GetX ( building ) ;
51600: LD_ADDR_VAR 0 7
51604: PUSH
51605: LD_VAR 0 1
51609: PPUSH
51610: CALL_OW 250
51614: ST_TO_ADDR
// y := GetY ( building ) ;
51615: LD_ADDR_VAR 0 8
51619: PUSH
51620: LD_VAR 0 1
51624: PPUSH
51625: CALL_OW 251
51629: ST_TO_ADDR
// d := GetDir ( building ) ;
51630: LD_ADDR_VAR 0 9
51634: PUSH
51635: LD_VAR 0 1
51639: PPUSH
51640: CALL_OW 254
51644: ST_TO_ADDR
// for i = 1 to mc_bases do
51645: LD_ADDR_VAR 0 4
51649: PUSH
51650: DOUBLE
51651: LD_INT 1
51653: DEC
51654: ST_TO_ADDR
51655: LD_EXP 78
51659: PUSH
51660: FOR_TO
51661: IFFALSE 51848
// begin if not mc_build_list [ i ] then
51663: LD_EXP 83
51667: PUSH
51668: LD_VAR 0 4
51672: ARRAY
51673: NOT
51674: IFFALSE 51678
// continue ;
51676: GO 51660
// for j := 1 to mc_build_list [ i ] do
51678: LD_ADDR_VAR 0 5
51682: PUSH
51683: DOUBLE
51684: LD_INT 1
51686: DEC
51687: ST_TO_ADDR
51688: LD_EXP 83
51692: PUSH
51693: LD_VAR 0 4
51697: ARRAY
51698: PUSH
51699: FOR_TO
51700: IFFALSE 51844
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51702: LD_VAR 0 6
51706: PUSH
51707: LD_VAR 0 7
51711: PUSH
51712: LD_VAR 0 8
51716: PUSH
51717: LD_VAR 0 9
51721: PUSH
51722: EMPTY
51723: LIST
51724: LIST
51725: LIST
51726: LIST
51727: PPUSH
51728: LD_EXP 83
51732: PUSH
51733: LD_VAR 0 4
51737: ARRAY
51738: PUSH
51739: LD_VAR 0 5
51743: ARRAY
51744: PPUSH
51745: CALL 63354 0 2
51749: IFFALSE 51842
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51751: LD_ADDR_EXP 83
51755: PUSH
51756: LD_EXP 83
51760: PPUSH
51761: LD_VAR 0 4
51765: PPUSH
51766: LD_EXP 83
51770: PUSH
51771: LD_VAR 0 4
51775: ARRAY
51776: PPUSH
51777: LD_VAR 0 5
51781: PPUSH
51782: CALL_OW 3
51786: PPUSH
51787: CALL_OW 1
51791: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51792: LD_ADDR_EXP 85
51796: PUSH
51797: LD_EXP 85
51801: PPUSH
51802: LD_VAR 0 4
51806: PUSH
51807: LD_EXP 85
51811: PUSH
51812: LD_VAR 0 4
51816: ARRAY
51817: PUSH
51818: LD_INT 1
51820: PLUS
51821: PUSH
51822: EMPTY
51823: LIST
51824: LIST
51825: PPUSH
51826: LD_VAR 0 1
51830: PPUSH
51831: CALL 57174 0 3
51835: ST_TO_ADDR
// exit ;
51836: POP
51837: POP
51838: POP
51839: POP
51840: GO 51850
// end ;
51842: GO 51699
51844: POP
51845: POP
// end ;
51846: GO 51660
51848: POP
51849: POP
// end ;
51850: LD_VAR 0 3
51854: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51855: LD_INT 0
51857: PPUSH
51858: PPUSH
51859: PPUSH
// if not mc_bases or not skirmish then
51860: LD_EXP 78
51864: NOT
51865: PUSH
51866: LD_EXP 76
51870: NOT
51871: OR
51872: IFFALSE 51876
// exit ;
51874: GO 52066
// for i = 1 to mc_bases do
51876: LD_ADDR_VAR 0 4
51880: PUSH
51881: DOUBLE
51882: LD_INT 1
51884: DEC
51885: ST_TO_ADDR
51886: LD_EXP 78
51890: PUSH
51891: FOR_TO
51892: IFFALSE 51979
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51894: LD_VAR 0 1
51898: PUSH
51899: LD_EXP 86
51903: PUSH
51904: LD_VAR 0 4
51908: ARRAY
51909: IN
51910: PUSH
51911: LD_VAR 0 1
51915: PUSH
51916: LD_EXP 87
51920: PUSH
51921: LD_VAR 0 4
51925: ARRAY
51926: IN
51927: NOT
51928: AND
51929: IFFALSE 51977
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51931: LD_ADDR_EXP 87
51935: PUSH
51936: LD_EXP 87
51940: PPUSH
51941: LD_VAR 0 4
51945: PUSH
51946: LD_EXP 87
51950: PUSH
51951: LD_VAR 0 4
51955: ARRAY
51956: PUSH
51957: LD_INT 1
51959: PLUS
51960: PUSH
51961: EMPTY
51962: LIST
51963: LIST
51964: PPUSH
51965: LD_VAR 0 1
51969: PPUSH
51970: CALL 57174 0 3
51974: ST_TO_ADDR
// break ;
51975: GO 51979
// end ; end ;
51977: GO 51891
51979: POP
51980: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51981: LD_VAR 0 1
51985: PPUSH
51986: CALL_OW 257
51990: PUSH
51991: LD_EXP 104
51995: IN
51996: PUSH
51997: LD_VAR 0 1
52001: PPUSH
52002: CALL_OW 266
52006: PUSH
52007: LD_INT 5
52009: EQUAL
52010: AND
52011: PUSH
52012: LD_VAR 0 2
52016: PPUSH
52017: CALL_OW 110
52021: PUSH
52022: LD_INT 18
52024: NONEQUAL
52025: AND
52026: IFFALSE 52066
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
52028: LD_VAR 0 2
52032: PPUSH
52033: CALL_OW 257
52037: PUSH
52038: LD_INT 5
52040: PUSH
52041: LD_INT 8
52043: PUSH
52044: LD_INT 9
52046: PUSH
52047: EMPTY
52048: LIST
52049: LIST
52050: LIST
52051: IN
52052: IFFALSE 52066
// SetClass ( unit , 1 ) ;
52054: LD_VAR 0 2
52058: PPUSH
52059: LD_INT 1
52061: PPUSH
52062: CALL_OW 336
// end ;
52066: LD_VAR 0 3
52070: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
52071: LD_INT 0
52073: PPUSH
52074: PPUSH
// if not mc_bases or not skirmish then
52075: LD_EXP 78
52079: NOT
52080: PUSH
52081: LD_EXP 76
52085: NOT
52086: OR
52087: IFFALSE 52091
// exit ;
52089: GO 52207
// if GetLives ( abandoned_vehicle ) > 250 then
52091: LD_VAR 0 2
52095: PPUSH
52096: CALL_OW 256
52100: PUSH
52101: LD_INT 250
52103: GREATER
52104: IFFALSE 52108
// exit ;
52106: GO 52207
// for i = 1 to mc_bases do
52108: LD_ADDR_VAR 0 6
52112: PUSH
52113: DOUBLE
52114: LD_INT 1
52116: DEC
52117: ST_TO_ADDR
52118: LD_EXP 78
52122: PUSH
52123: FOR_TO
52124: IFFALSE 52205
// begin if driver in mc_bases [ i ] then
52126: LD_VAR 0 1
52130: PUSH
52131: LD_EXP 78
52135: PUSH
52136: LD_VAR 0 6
52140: ARRAY
52141: IN
52142: IFFALSE 52203
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
52144: LD_VAR 0 1
52148: PPUSH
52149: LD_EXP 78
52153: PUSH
52154: LD_VAR 0 6
52158: ARRAY
52159: PPUSH
52160: LD_INT 2
52162: PUSH
52163: LD_INT 30
52165: PUSH
52166: LD_INT 0
52168: PUSH
52169: EMPTY
52170: LIST
52171: LIST
52172: PUSH
52173: LD_INT 30
52175: PUSH
52176: LD_INT 1
52178: PUSH
52179: EMPTY
52180: LIST
52181: LIST
52182: PUSH
52183: EMPTY
52184: LIST
52185: LIST
52186: LIST
52187: PPUSH
52188: CALL_OW 72
52192: PUSH
52193: LD_INT 1
52195: ARRAY
52196: PPUSH
52197: CALL 90381 0 2
// break ;
52201: GO 52205
// end ; end ;
52203: GO 52123
52205: POP
52206: POP
// end ; end_of_file
52207: LD_VAR 0 5
52211: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52212: LD_INT 0
52214: PPUSH
52215: PPUSH
// if exist_mode then
52216: LD_VAR 0 2
52220: IFFALSE 52245
// unit := CreateCharacter ( prefix & ident ) else
52222: LD_ADDR_VAR 0 5
52226: PUSH
52227: LD_VAR 0 3
52231: PUSH
52232: LD_VAR 0 1
52236: STR
52237: PPUSH
52238: CALL_OW 34
52242: ST_TO_ADDR
52243: GO 52260
// unit := NewCharacter ( ident ) ;
52245: LD_ADDR_VAR 0 5
52249: PUSH
52250: LD_VAR 0 1
52254: PPUSH
52255: CALL_OW 25
52259: ST_TO_ADDR
// result := unit ;
52260: LD_ADDR_VAR 0 4
52264: PUSH
52265: LD_VAR 0 5
52269: ST_TO_ADDR
// end ;
52270: LD_VAR 0 4
52274: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52275: LD_INT 0
52277: PPUSH
52278: PPUSH
// if not side or not nation then
52279: LD_VAR 0 1
52283: NOT
52284: PUSH
52285: LD_VAR 0 2
52289: NOT
52290: OR
52291: IFFALSE 52295
// exit ;
52293: GO 53063
// case nation of nation_american :
52295: LD_VAR 0 2
52299: PUSH
52300: LD_INT 1
52302: DOUBLE
52303: EQUAL
52304: IFTRUE 52308
52306: GO 52522
52308: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52309: LD_ADDR_VAR 0 4
52313: PUSH
52314: LD_INT 35
52316: PUSH
52317: LD_INT 45
52319: PUSH
52320: LD_INT 46
52322: PUSH
52323: LD_INT 47
52325: PUSH
52326: LD_INT 82
52328: PUSH
52329: LD_INT 83
52331: PUSH
52332: LD_INT 84
52334: PUSH
52335: LD_INT 85
52337: PUSH
52338: LD_INT 86
52340: PUSH
52341: LD_INT 1
52343: PUSH
52344: LD_INT 2
52346: PUSH
52347: LD_INT 6
52349: PUSH
52350: LD_INT 15
52352: PUSH
52353: LD_INT 16
52355: PUSH
52356: LD_INT 7
52358: PUSH
52359: LD_INT 12
52361: PUSH
52362: LD_INT 13
52364: PUSH
52365: LD_INT 10
52367: PUSH
52368: LD_INT 14
52370: PUSH
52371: LD_INT 20
52373: PUSH
52374: LD_INT 21
52376: PUSH
52377: LD_INT 22
52379: PUSH
52380: LD_INT 25
52382: PUSH
52383: LD_INT 32
52385: PUSH
52386: LD_INT 27
52388: PUSH
52389: LD_INT 36
52391: PUSH
52392: LD_INT 69
52394: PUSH
52395: LD_INT 39
52397: PUSH
52398: LD_INT 34
52400: PUSH
52401: LD_INT 40
52403: PUSH
52404: LD_INT 48
52406: PUSH
52407: LD_INT 49
52409: PUSH
52410: LD_INT 50
52412: PUSH
52413: LD_INT 51
52415: PUSH
52416: LD_INT 52
52418: PUSH
52419: LD_INT 53
52421: PUSH
52422: LD_INT 54
52424: PUSH
52425: LD_INT 55
52427: PUSH
52428: LD_INT 56
52430: PUSH
52431: LD_INT 57
52433: PUSH
52434: LD_INT 58
52436: PUSH
52437: LD_INT 59
52439: PUSH
52440: LD_INT 60
52442: PUSH
52443: LD_INT 61
52445: PUSH
52446: LD_INT 62
52448: PUSH
52449: LD_INT 80
52451: PUSH
52452: LD_INT 82
52454: PUSH
52455: LD_INT 83
52457: PUSH
52458: LD_INT 84
52460: PUSH
52461: LD_INT 85
52463: PUSH
52464: LD_INT 86
52466: PUSH
52467: EMPTY
52468: LIST
52469: LIST
52470: LIST
52471: LIST
52472: LIST
52473: LIST
52474: LIST
52475: LIST
52476: LIST
52477: LIST
52478: LIST
52479: LIST
52480: LIST
52481: LIST
52482: LIST
52483: LIST
52484: LIST
52485: LIST
52486: LIST
52487: LIST
52488: LIST
52489: LIST
52490: LIST
52491: LIST
52492: LIST
52493: LIST
52494: LIST
52495: LIST
52496: LIST
52497: LIST
52498: LIST
52499: LIST
52500: LIST
52501: LIST
52502: LIST
52503: LIST
52504: LIST
52505: LIST
52506: LIST
52507: LIST
52508: LIST
52509: LIST
52510: LIST
52511: LIST
52512: LIST
52513: LIST
52514: LIST
52515: LIST
52516: LIST
52517: LIST
52518: LIST
52519: ST_TO_ADDR
52520: GO 52987
52522: LD_INT 2
52524: DOUBLE
52525: EQUAL
52526: IFTRUE 52530
52528: GO 52756
52530: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52531: LD_ADDR_VAR 0 4
52535: PUSH
52536: LD_INT 35
52538: PUSH
52539: LD_INT 45
52541: PUSH
52542: LD_INT 46
52544: PUSH
52545: LD_INT 47
52547: PUSH
52548: LD_INT 82
52550: PUSH
52551: LD_INT 83
52553: PUSH
52554: LD_INT 84
52556: PUSH
52557: LD_INT 85
52559: PUSH
52560: LD_INT 87
52562: PUSH
52563: LD_INT 70
52565: PUSH
52566: LD_INT 1
52568: PUSH
52569: LD_INT 11
52571: PUSH
52572: LD_INT 3
52574: PUSH
52575: LD_INT 4
52577: PUSH
52578: LD_INT 5
52580: PUSH
52581: LD_INT 6
52583: PUSH
52584: LD_INT 15
52586: PUSH
52587: LD_INT 18
52589: PUSH
52590: LD_INT 7
52592: PUSH
52593: LD_INT 17
52595: PUSH
52596: LD_INT 8
52598: PUSH
52599: LD_INT 20
52601: PUSH
52602: LD_INT 21
52604: PUSH
52605: LD_INT 22
52607: PUSH
52608: LD_INT 72
52610: PUSH
52611: LD_INT 26
52613: PUSH
52614: LD_INT 69
52616: PUSH
52617: LD_INT 39
52619: PUSH
52620: LD_INT 40
52622: PUSH
52623: LD_INT 41
52625: PUSH
52626: LD_INT 42
52628: PUSH
52629: LD_INT 43
52631: PUSH
52632: LD_INT 48
52634: PUSH
52635: LD_INT 49
52637: PUSH
52638: LD_INT 50
52640: PUSH
52641: LD_INT 51
52643: PUSH
52644: LD_INT 52
52646: PUSH
52647: LD_INT 53
52649: PUSH
52650: LD_INT 54
52652: PUSH
52653: LD_INT 55
52655: PUSH
52656: LD_INT 56
52658: PUSH
52659: LD_INT 60
52661: PUSH
52662: LD_INT 61
52664: PUSH
52665: LD_INT 62
52667: PUSH
52668: LD_INT 66
52670: PUSH
52671: LD_INT 67
52673: PUSH
52674: LD_INT 68
52676: PUSH
52677: LD_INT 81
52679: PUSH
52680: LD_INT 82
52682: PUSH
52683: LD_INT 83
52685: PUSH
52686: LD_INT 84
52688: PUSH
52689: LD_INT 85
52691: PUSH
52692: LD_INT 87
52694: PUSH
52695: LD_INT 88
52697: PUSH
52698: EMPTY
52699: LIST
52700: LIST
52701: LIST
52702: LIST
52703: LIST
52704: LIST
52705: LIST
52706: LIST
52707: LIST
52708: LIST
52709: LIST
52710: LIST
52711: LIST
52712: LIST
52713: LIST
52714: LIST
52715: LIST
52716: LIST
52717: LIST
52718: LIST
52719: LIST
52720: LIST
52721: LIST
52722: LIST
52723: LIST
52724: LIST
52725: LIST
52726: LIST
52727: LIST
52728: LIST
52729: LIST
52730: LIST
52731: LIST
52732: LIST
52733: LIST
52734: LIST
52735: LIST
52736: LIST
52737: LIST
52738: LIST
52739: LIST
52740: LIST
52741: LIST
52742: LIST
52743: LIST
52744: LIST
52745: LIST
52746: LIST
52747: LIST
52748: LIST
52749: LIST
52750: LIST
52751: LIST
52752: LIST
52753: ST_TO_ADDR
52754: GO 52987
52756: LD_INT 3
52758: DOUBLE
52759: EQUAL
52760: IFTRUE 52764
52762: GO 52986
52764: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52765: LD_ADDR_VAR 0 4
52769: PUSH
52770: LD_INT 46
52772: PUSH
52773: LD_INT 47
52775: PUSH
52776: LD_INT 1
52778: PUSH
52779: LD_INT 2
52781: PUSH
52782: LD_INT 82
52784: PUSH
52785: LD_INT 83
52787: PUSH
52788: LD_INT 84
52790: PUSH
52791: LD_INT 85
52793: PUSH
52794: LD_INT 86
52796: PUSH
52797: LD_INT 11
52799: PUSH
52800: LD_INT 9
52802: PUSH
52803: LD_INT 20
52805: PUSH
52806: LD_INT 19
52808: PUSH
52809: LD_INT 21
52811: PUSH
52812: LD_INT 24
52814: PUSH
52815: LD_INT 22
52817: PUSH
52818: LD_INT 25
52820: PUSH
52821: LD_INT 28
52823: PUSH
52824: LD_INT 29
52826: PUSH
52827: LD_INT 30
52829: PUSH
52830: LD_INT 31
52832: PUSH
52833: LD_INT 37
52835: PUSH
52836: LD_INT 38
52838: PUSH
52839: LD_INT 32
52841: PUSH
52842: LD_INT 27
52844: PUSH
52845: LD_INT 33
52847: PUSH
52848: LD_INT 69
52850: PUSH
52851: LD_INT 39
52853: PUSH
52854: LD_INT 34
52856: PUSH
52857: LD_INT 40
52859: PUSH
52860: LD_INT 71
52862: PUSH
52863: LD_INT 23
52865: PUSH
52866: LD_INT 44
52868: PUSH
52869: LD_INT 48
52871: PUSH
52872: LD_INT 49
52874: PUSH
52875: LD_INT 50
52877: PUSH
52878: LD_INT 51
52880: PUSH
52881: LD_INT 52
52883: PUSH
52884: LD_INT 53
52886: PUSH
52887: LD_INT 54
52889: PUSH
52890: LD_INT 55
52892: PUSH
52893: LD_INT 56
52895: PUSH
52896: LD_INT 57
52898: PUSH
52899: LD_INT 58
52901: PUSH
52902: LD_INT 59
52904: PUSH
52905: LD_INT 63
52907: PUSH
52908: LD_INT 64
52910: PUSH
52911: LD_INT 65
52913: PUSH
52914: LD_INT 82
52916: PUSH
52917: LD_INT 83
52919: PUSH
52920: LD_INT 84
52922: PUSH
52923: LD_INT 85
52925: PUSH
52926: LD_INT 86
52928: PUSH
52929: EMPTY
52930: LIST
52931: LIST
52932: LIST
52933: LIST
52934: LIST
52935: LIST
52936: LIST
52937: LIST
52938: LIST
52939: LIST
52940: LIST
52941: LIST
52942: LIST
52943: LIST
52944: LIST
52945: LIST
52946: LIST
52947: LIST
52948: LIST
52949: LIST
52950: LIST
52951: LIST
52952: LIST
52953: LIST
52954: LIST
52955: LIST
52956: LIST
52957: LIST
52958: LIST
52959: LIST
52960: LIST
52961: LIST
52962: LIST
52963: LIST
52964: LIST
52965: LIST
52966: LIST
52967: LIST
52968: LIST
52969: LIST
52970: LIST
52971: LIST
52972: LIST
52973: LIST
52974: LIST
52975: LIST
52976: LIST
52977: LIST
52978: LIST
52979: LIST
52980: LIST
52981: LIST
52982: LIST
52983: ST_TO_ADDR
52984: GO 52987
52986: POP
// if state > - 1 and state < 3 then
52987: LD_VAR 0 3
52991: PUSH
52992: LD_INT 1
52994: NEG
52995: GREATER
52996: PUSH
52997: LD_VAR 0 3
53001: PUSH
53002: LD_INT 3
53004: LESS
53005: AND
53006: IFFALSE 53063
// for i in result do
53008: LD_ADDR_VAR 0 5
53012: PUSH
53013: LD_VAR 0 4
53017: PUSH
53018: FOR_IN
53019: IFFALSE 53061
// if GetTech ( i , side ) <> state then
53021: LD_VAR 0 5
53025: PPUSH
53026: LD_VAR 0 1
53030: PPUSH
53031: CALL_OW 321
53035: PUSH
53036: LD_VAR 0 3
53040: NONEQUAL
53041: IFFALSE 53059
// result := result diff i ;
53043: LD_ADDR_VAR 0 4
53047: PUSH
53048: LD_VAR 0 4
53052: PUSH
53053: LD_VAR 0 5
53057: DIFF
53058: ST_TO_ADDR
53059: GO 53018
53061: POP
53062: POP
// end ;
53063: LD_VAR 0 4
53067: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
53068: LD_INT 0
53070: PPUSH
53071: PPUSH
53072: PPUSH
// result := true ;
53073: LD_ADDR_VAR 0 3
53077: PUSH
53078: LD_INT 1
53080: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
53081: LD_ADDR_VAR 0 5
53085: PUSH
53086: LD_VAR 0 2
53090: PPUSH
53091: CALL_OW 480
53095: ST_TO_ADDR
// if not tmp then
53096: LD_VAR 0 5
53100: NOT
53101: IFFALSE 53105
// exit ;
53103: GO 53154
// for i in tmp do
53105: LD_ADDR_VAR 0 4
53109: PUSH
53110: LD_VAR 0 5
53114: PUSH
53115: FOR_IN
53116: IFFALSE 53152
// if GetTech ( i , side ) <> state_researched then
53118: LD_VAR 0 4
53122: PPUSH
53123: LD_VAR 0 1
53127: PPUSH
53128: CALL_OW 321
53132: PUSH
53133: LD_INT 2
53135: NONEQUAL
53136: IFFALSE 53150
// begin result := false ;
53138: LD_ADDR_VAR 0 3
53142: PUSH
53143: LD_INT 0
53145: ST_TO_ADDR
// exit ;
53146: POP
53147: POP
53148: GO 53154
// end ;
53150: GO 53115
53152: POP
53153: POP
// end ;
53154: LD_VAR 0 3
53158: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
53159: LD_INT 0
53161: PPUSH
53162: PPUSH
53163: PPUSH
53164: PPUSH
53165: PPUSH
53166: PPUSH
53167: PPUSH
53168: PPUSH
53169: PPUSH
53170: PPUSH
53171: PPUSH
53172: PPUSH
53173: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
53174: LD_VAR 0 1
53178: NOT
53179: PUSH
53180: LD_VAR 0 1
53184: PPUSH
53185: CALL_OW 257
53189: PUSH
53190: LD_INT 9
53192: NONEQUAL
53193: OR
53194: IFFALSE 53198
// exit ;
53196: GO 53771
// side := GetSide ( unit ) ;
53198: LD_ADDR_VAR 0 9
53202: PUSH
53203: LD_VAR 0 1
53207: PPUSH
53208: CALL_OW 255
53212: ST_TO_ADDR
// tech_space := tech_spacanom ;
53213: LD_ADDR_VAR 0 12
53217: PUSH
53218: LD_INT 29
53220: ST_TO_ADDR
// tech_time := tech_taurad ;
53221: LD_ADDR_VAR 0 13
53225: PUSH
53226: LD_INT 28
53228: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53229: LD_ADDR_VAR 0 11
53233: PUSH
53234: LD_VAR 0 1
53238: PPUSH
53239: CALL_OW 310
53243: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53244: LD_VAR 0 11
53248: PPUSH
53249: CALL_OW 247
53253: PUSH
53254: LD_INT 2
53256: EQUAL
53257: IFFALSE 53261
// exit ;
53259: GO 53771
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53261: LD_ADDR_VAR 0 8
53265: PUSH
53266: LD_INT 81
53268: PUSH
53269: LD_VAR 0 9
53273: PUSH
53274: EMPTY
53275: LIST
53276: LIST
53277: PUSH
53278: LD_INT 3
53280: PUSH
53281: LD_INT 21
53283: PUSH
53284: LD_INT 3
53286: PUSH
53287: EMPTY
53288: LIST
53289: LIST
53290: PUSH
53291: EMPTY
53292: LIST
53293: LIST
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: PPUSH
53299: CALL_OW 69
53303: ST_TO_ADDR
// if not tmp then
53304: LD_VAR 0 8
53308: NOT
53309: IFFALSE 53313
// exit ;
53311: GO 53771
// if in_unit then
53313: LD_VAR 0 11
53317: IFFALSE 53341
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53319: LD_ADDR_VAR 0 10
53323: PUSH
53324: LD_VAR 0 8
53328: PPUSH
53329: LD_VAR 0 11
53333: PPUSH
53334: CALL_OW 74
53338: ST_TO_ADDR
53339: GO 53361
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53341: LD_ADDR_VAR 0 10
53345: PUSH
53346: LD_VAR 0 8
53350: PPUSH
53351: LD_VAR 0 1
53355: PPUSH
53356: CALL_OW 74
53360: ST_TO_ADDR
// if not enemy then
53361: LD_VAR 0 10
53365: NOT
53366: IFFALSE 53370
// exit ;
53368: GO 53771
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53370: LD_VAR 0 11
53374: PUSH
53375: LD_VAR 0 11
53379: PPUSH
53380: LD_VAR 0 10
53384: PPUSH
53385: CALL_OW 296
53389: PUSH
53390: LD_INT 13
53392: GREATER
53393: AND
53394: PUSH
53395: LD_VAR 0 1
53399: PPUSH
53400: LD_VAR 0 10
53404: PPUSH
53405: CALL_OW 296
53409: PUSH
53410: LD_INT 12
53412: GREATER
53413: OR
53414: IFFALSE 53418
// exit ;
53416: GO 53771
// missile := [ 1 ] ;
53418: LD_ADDR_VAR 0 14
53422: PUSH
53423: LD_INT 1
53425: PUSH
53426: EMPTY
53427: LIST
53428: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53429: LD_VAR 0 9
53433: PPUSH
53434: LD_VAR 0 12
53438: PPUSH
53439: CALL_OW 325
53443: IFFALSE 53472
// missile := Replace ( missile , missile + 1 , 2 ) ;
53445: LD_ADDR_VAR 0 14
53449: PUSH
53450: LD_VAR 0 14
53454: PPUSH
53455: LD_VAR 0 14
53459: PUSH
53460: LD_INT 1
53462: PLUS
53463: PPUSH
53464: LD_INT 2
53466: PPUSH
53467: CALL_OW 1
53471: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53472: LD_VAR 0 9
53476: PPUSH
53477: LD_VAR 0 13
53481: PPUSH
53482: CALL_OW 325
53486: PUSH
53487: LD_VAR 0 10
53491: PPUSH
53492: CALL_OW 255
53496: PPUSH
53497: LD_VAR 0 13
53501: PPUSH
53502: CALL_OW 325
53506: NOT
53507: AND
53508: IFFALSE 53537
// missile := Replace ( missile , missile + 1 , 3 ) ;
53510: LD_ADDR_VAR 0 14
53514: PUSH
53515: LD_VAR 0 14
53519: PPUSH
53520: LD_VAR 0 14
53524: PUSH
53525: LD_INT 1
53527: PLUS
53528: PPUSH
53529: LD_INT 3
53531: PPUSH
53532: CALL_OW 1
53536: ST_TO_ADDR
// if missile < 2 then
53537: LD_VAR 0 14
53541: PUSH
53542: LD_INT 2
53544: LESS
53545: IFFALSE 53549
// exit ;
53547: GO 53771
// x := GetX ( enemy ) ;
53549: LD_ADDR_VAR 0 4
53553: PUSH
53554: LD_VAR 0 10
53558: PPUSH
53559: CALL_OW 250
53563: ST_TO_ADDR
// y := GetY ( enemy ) ;
53564: LD_ADDR_VAR 0 5
53568: PUSH
53569: LD_VAR 0 10
53573: PPUSH
53574: CALL_OW 251
53578: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53579: LD_ADDR_VAR 0 6
53583: PUSH
53584: LD_VAR 0 4
53588: PUSH
53589: LD_INT 1
53591: NEG
53592: PPUSH
53593: LD_INT 1
53595: PPUSH
53596: CALL_OW 12
53600: PLUS
53601: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53602: LD_ADDR_VAR 0 7
53606: PUSH
53607: LD_VAR 0 5
53611: PUSH
53612: LD_INT 1
53614: NEG
53615: PPUSH
53616: LD_INT 1
53618: PPUSH
53619: CALL_OW 12
53623: PLUS
53624: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53625: LD_VAR 0 6
53629: PPUSH
53630: LD_VAR 0 7
53634: PPUSH
53635: CALL_OW 488
53639: NOT
53640: IFFALSE 53662
// begin _x := x ;
53642: LD_ADDR_VAR 0 6
53646: PUSH
53647: LD_VAR 0 4
53651: ST_TO_ADDR
// _y := y ;
53652: LD_ADDR_VAR 0 7
53656: PUSH
53657: LD_VAR 0 5
53661: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53662: LD_ADDR_VAR 0 3
53666: PUSH
53667: LD_INT 1
53669: PPUSH
53670: LD_VAR 0 14
53674: PPUSH
53675: CALL_OW 12
53679: ST_TO_ADDR
// case i of 1 :
53680: LD_VAR 0 3
53684: PUSH
53685: LD_INT 1
53687: DOUBLE
53688: EQUAL
53689: IFTRUE 53693
53691: GO 53710
53693: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53694: LD_VAR 0 1
53698: PPUSH
53699: LD_VAR 0 10
53703: PPUSH
53704: CALL_OW 115
53708: GO 53771
53710: LD_INT 2
53712: DOUBLE
53713: EQUAL
53714: IFTRUE 53718
53716: GO 53740
53718: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53719: LD_VAR 0 1
53723: PPUSH
53724: LD_VAR 0 6
53728: PPUSH
53729: LD_VAR 0 7
53733: PPUSH
53734: CALL_OW 153
53738: GO 53771
53740: LD_INT 3
53742: DOUBLE
53743: EQUAL
53744: IFTRUE 53748
53746: GO 53770
53748: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53749: LD_VAR 0 1
53753: PPUSH
53754: LD_VAR 0 6
53758: PPUSH
53759: LD_VAR 0 7
53763: PPUSH
53764: CALL_OW 154
53768: GO 53771
53770: POP
// end ;
53771: LD_VAR 0 2
53775: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53776: LD_INT 0
53778: PPUSH
53779: PPUSH
53780: PPUSH
53781: PPUSH
53782: PPUSH
53783: PPUSH
// if not unit or not building then
53784: LD_VAR 0 1
53788: NOT
53789: PUSH
53790: LD_VAR 0 2
53794: NOT
53795: OR
53796: IFFALSE 53800
// exit ;
53798: GO 53958
// x := GetX ( building ) ;
53800: LD_ADDR_VAR 0 5
53804: PUSH
53805: LD_VAR 0 2
53809: PPUSH
53810: CALL_OW 250
53814: ST_TO_ADDR
// y := GetY ( building ) ;
53815: LD_ADDR_VAR 0 6
53819: PUSH
53820: LD_VAR 0 2
53824: PPUSH
53825: CALL_OW 251
53829: ST_TO_ADDR
// for i = 0 to 5 do
53830: LD_ADDR_VAR 0 4
53834: PUSH
53835: DOUBLE
53836: LD_INT 0
53838: DEC
53839: ST_TO_ADDR
53840: LD_INT 5
53842: PUSH
53843: FOR_TO
53844: IFFALSE 53956
// begin _x := ShiftX ( x , i , 3 ) ;
53846: LD_ADDR_VAR 0 7
53850: PUSH
53851: LD_VAR 0 5
53855: PPUSH
53856: LD_VAR 0 4
53860: PPUSH
53861: LD_INT 3
53863: PPUSH
53864: CALL_OW 272
53868: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53869: LD_ADDR_VAR 0 8
53873: PUSH
53874: LD_VAR 0 6
53878: PPUSH
53879: LD_VAR 0 4
53883: PPUSH
53884: LD_INT 3
53886: PPUSH
53887: CALL_OW 273
53891: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53892: LD_VAR 0 7
53896: PPUSH
53897: LD_VAR 0 8
53901: PPUSH
53902: CALL_OW 488
53906: NOT
53907: IFFALSE 53911
// continue ;
53909: GO 53843
// if HexInfo ( _x , _y ) = 0 then
53911: LD_VAR 0 7
53915: PPUSH
53916: LD_VAR 0 8
53920: PPUSH
53921: CALL_OW 428
53925: PUSH
53926: LD_INT 0
53928: EQUAL
53929: IFFALSE 53954
// begin ComMoveXY ( unit , _x , _y ) ;
53931: LD_VAR 0 1
53935: PPUSH
53936: LD_VAR 0 7
53940: PPUSH
53941: LD_VAR 0 8
53945: PPUSH
53946: CALL_OW 111
// exit ;
53950: POP
53951: POP
53952: GO 53958
// end ; end ;
53954: GO 53843
53956: POP
53957: POP
// end ;
53958: LD_VAR 0 3
53962: RET
// export function ScanBase ( side , base_area ) ; begin
53963: LD_INT 0
53965: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53966: LD_ADDR_VAR 0 3
53970: PUSH
53971: LD_VAR 0 2
53975: PPUSH
53976: LD_INT 81
53978: PUSH
53979: LD_VAR 0 1
53983: PUSH
53984: EMPTY
53985: LIST
53986: LIST
53987: PPUSH
53988: CALL_OW 70
53992: ST_TO_ADDR
// end ;
53993: LD_VAR 0 3
53997: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53998: LD_INT 0
54000: PPUSH
54001: PPUSH
54002: PPUSH
54003: PPUSH
// result := false ;
54004: LD_ADDR_VAR 0 2
54008: PUSH
54009: LD_INT 0
54011: ST_TO_ADDR
// side := GetSide ( unit ) ;
54012: LD_ADDR_VAR 0 3
54016: PUSH
54017: LD_VAR 0 1
54021: PPUSH
54022: CALL_OW 255
54026: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54027: LD_ADDR_VAR 0 4
54031: PUSH
54032: LD_VAR 0 1
54036: PPUSH
54037: CALL_OW 248
54041: ST_TO_ADDR
// case nat of 1 :
54042: LD_VAR 0 4
54046: PUSH
54047: LD_INT 1
54049: DOUBLE
54050: EQUAL
54051: IFTRUE 54055
54053: GO 54066
54055: POP
// tech := tech_lassight ; 2 :
54056: LD_ADDR_VAR 0 5
54060: PUSH
54061: LD_INT 12
54063: ST_TO_ADDR
54064: GO 54105
54066: LD_INT 2
54068: DOUBLE
54069: EQUAL
54070: IFTRUE 54074
54072: GO 54085
54074: POP
// tech := tech_mortar ; 3 :
54075: LD_ADDR_VAR 0 5
54079: PUSH
54080: LD_INT 41
54082: ST_TO_ADDR
54083: GO 54105
54085: LD_INT 3
54087: DOUBLE
54088: EQUAL
54089: IFTRUE 54093
54091: GO 54104
54093: POP
// tech := tech_bazooka ; end ;
54094: LD_ADDR_VAR 0 5
54098: PUSH
54099: LD_INT 44
54101: ST_TO_ADDR
54102: GO 54105
54104: POP
// if Researched ( side , tech ) then
54105: LD_VAR 0 3
54109: PPUSH
54110: LD_VAR 0 5
54114: PPUSH
54115: CALL_OW 325
54119: IFFALSE 54146
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54121: LD_ADDR_VAR 0 2
54125: PUSH
54126: LD_INT 5
54128: PUSH
54129: LD_INT 8
54131: PUSH
54132: LD_INT 9
54134: PUSH
54135: EMPTY
54136: LIST
54137: LIST
54138: LIST
54139: PUSH
54140: LD_VAR 0 4
54144: ARRAY
54145: ST_TO_ADDR
// end ;
54146: LD_VAR 0 2
54150: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54151: LD_INT 0
54153: PPUSH
54154: PPUSH
54155: PPUSH
// if not mines then
54156: LD_VAR 0 2
54160: NOT
54161: IFFALSE 54165
// exit ;
54163: GO 54309
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54165: LD_ADDR_VAR 0 5
54169: PUSH
54170: LD_INT 81
54172: PUSH
54173: LD_VAR 0 1
54177: PUSH
54178: EMPTY
54179: LIST
54180: LIST
54181: PUSH
54182: LD_INT 3
54184: PUSH
54185: LD_INT 21
54187: PUSH
54188: LD_INT 3
54190: PUSH
54191: EMPTY
54192: LIST
54193: LIST
54194: PUSH
54195: EMPTY
54196: LIST
54197: LIST
54198: PUSH
54199: EMPTY
54200: LIST
54201: LIST
54202: PPUSH
54203: CALL_OW 69
54207: ST_TO_ADDR
// for i in mines do
54208: LD_ADDR_VAR 0 4
54212: PUSH
54213: LD_VAR 0 2
54217: PUSH
54218: FOR_IN
54219: IFFALSE 54307
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54221: LD_VAR 0 4
54225: PUSH
54226: LD_INT 1
54228: ARRAY
54229: PPUSH
54230: LD_VAR 0 4
54234: PUSH
54235: LD_INT 2
54237: ARRAY
54238: PPUSH
54239: CALL_OW 458
54243: NOT
54244: IFFALSE 54248
// continue ;
54246: GO 54218
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54248: LD_VAR 0 4
54252: PUSH
54253: LD_INT 1
54255: ARRAY
54256: PPUSH
54257: LD_VAR 0 4
54261: PUSH
54262: LD_INT 2
54264: ARRAY
54265: PPUSH
54266: CALL_OW 428
54270: PUSH
54271: LD_VAR 0 5
54275: IN
54276: IFFALSE 54305
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54278: LD_VAR 0 4
54282: PUSH
54283: LD_INT 1
54285: ARRAY
54286: PPUSH
54287: LD_VAR 0 4
54291: PUSH
54292: LD_INT 2
54294: ARRAY
54295: PPUSH
54296: LD_VAR 0 1
54300: PPUSH
54301: CALL_OW 456
// end ;
54305: GO 54218
54307: POP
54308: POP
// end ;
54309: LD_VAR 0 3
54313: RET
// export function Count ( array ) ; begin
54314: LD_INT 0
54316: PPUSH
// result := array + 0 ;
54317: LD_ADDR_VAR 0 2
54321: PUSH
54322: LD_VAR 0 1
54326: PUSH
54327: LD_INT 0
54329: PLUS
54330: ST_TO_ADDR
// end ;
54331: LD_VAR 0 2
54335: RET
// export function IsEmpty ( building ) ; begin
54336: LD_INT 0
54338: PPUSH
// if not building then
54339: LD_VAR 0 1
54343: NOT
54344: IFFALSE 54348
// exit ;
54346: GO 54391
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54348: LD_ADDR_VAR 0 2
54352: PUSH
54353: LD_VAR 0 1
54357: PUSH
54358: LD_INT 22
54360: PUSH
54361: LD_VAR 0 1
54365: PPUSH
54366: CALL_OW 255
54370: PUSH
54371: EMPTY
54372: LIST
54373: LIST
54374: PUSH
54375: LD_INT 58
54377: PUSH
54378: EMPTY
54379: LIST
54380: PUSH
54381: EMPTY
54382: LIST
54383: LIST
54384: PPUSH
54385: CALL_OW 69
54389: IN
54390: ST_TO_ADDR
// end ;
54391: LD_VAR 0 2
54395: RET
// export function IsNotFull ( building ) ; var places ; begin
54396: LD_INT 0
54398: PPUSH
54399: PPUSH
// if not building then
54400: LD_VAR 0 1
54404: NOT
54405: IFFALSE 54409
// exit ;
54407: GO 54437
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
54409: LD_ADDR_VAR 0 2
54413: PUSH
54414: LD_VAR 0 1
54418: PPUSH
54419: LD_INT 3
54421: PUSH
54422: LD_INT 62
54424: PUSH
54425: EMPTY
54426: LIST
54427: PUSH
54428: EMPTY
54429: LIST
54430: LIST
54431: PPUSH
54432: CALL_OW 72
54436: ST_TO_ADDR
// end ;
54437: LD_VAR 0 2
54441: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54442: LD_INT 0
54444: PPUSH
54445: PPUSH
54446: PPUSH
54447: PPUSH
// tmp := [ ] ;
54448: LD_ADDR_VAR 0 3
54452: PUSH
54453: EMPTY
54454: ST_TO_ADDR
// list := [ ] ;
54455: LD_ADDR_VAR 0 5
54459: PUSH
54460: EMPTY
54461: ST_TO_ADDR
// for i = 16 to 25 do
54462: LD_ADDR_VAR 0 4
54466: PUSH
54467: DOUBLE
54468: LD_INT 16
54470: DEC
54471: ST_TO_ADDR
54472: LD_INT 25
54474: PUSH
54475: FOR_TO
54476: IFFALSE 54549
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54478: LD_ADDR_VAR 0 3
54482: PUSH
54483: LD_VAR 0 3
54487: PUSH
54488: LD_INT 22
54490: PUSH
54491: LD_VAR 0 1
54495: PPUSH
54496: CALL_OW 255
54500: PUSH
54501: EMPTY
54502: LIST
54503: LIST
54504: PUSH
54505: LD_INT 91
54507: PUSH
54508: LD_VAR 0 1
54512: PUSH
54513: LD_INT 6
54515: PUSH
54516: EMPTY
54517: LIST
54518: LIST
54519: LIST
54520: PUSH
54521: LD_INT 30
54523: PUSH
54524: LD_VAR 0 4
54528: PUSH
54529: EMPTY
54530: LIST
54531: LIST
54532: PUSH
54533: EMPTY
54534: LIST
54535: LIST
54536: LIST
54537: PUSH
54538: EMPTY
54539: LIST
54540: PPUSH
54541: CALL_OW 69
54545: ADD
54546: ST_TO_ADDR
54547: GO 54475
54549: POP
54550: POP
// for i = 1 to tmp do
54551: LD_ADDR_VAR 0 4
54555: PUSH
54556: DOUBLE
54557: LD_INT 1
54559: DEC
54560: ST_TO_ADDR
54561: LD_VAR 0 3
54565: PUSH
54566: FOR_TO
54567: IFFALSE 54655
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54569: LD_ADDR_VAR 0 5
54573: PUSH
54574: LD_VAR 0 5
54578: PUSH
54579: LD_VAR 0 3
54583: PUSH
54584: LD_VAR 0 4
54588: ARRAY
54589: PPUSH
54590: CALL_OW 266
54594: PUSH
54595: LD_VAR 0 3
54599: PUSH
54600: LD_VAR 0 4
54604: ARRAY
54605: PPUSH
54606: CALL_OW 250
54610: PUSH
54611: LD_VAR 0 3
54615: PUSH
54616: LD_VAR 0 4
54620: ARRAY
54621: PPUSH
54622: CALL_OW 251
54626: PUSH
54627: LD_VAR 0 3
54631: PUSH
54632: LD_VAR 0 4
54636: ARRAY
54637: PPUSH
54638: CALL_OW 254
54642: PUSH
54643: EMPTY
54644: LIST
54645: LIST
54646: LIST
54647: LIST
54648: PUSH
54649: EMPTY
54650: LIST
54651: ADD
54652: ST_TO_ADDR
54653: GO 54566
54655: POP
54656: POP
// result := list ;
54657: LD_ADDR_VAR 0 2
54661: PUSH
54662: LD_VAR 0 5
54666: ST_TO_ADDR
// end ;
54667: LD_VAR 0 2
54671: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54672: LD_INT 0
54674: PPUSH
54675: PPUSH
54676: PPUSH
54677: PPUSH
54678: PPUSH
54679: PPUSH
54680: PPUSH
// if not factory then
54681: LD_VAR 0 1
54685: NOT
54686: IFFALSE 54690
// exit ;
54688: GO 55283
// if control = control_apeman then
54690: LD_VAR 0 4
54694: PUSH
54695: LD_INT 5
54697: EQUAL
54698: IFFALSE 54807
// begin tmp := UnitsInside ( factory ) ;
54700: LD_ADDR_VAR 0 8
54704: PUSH
54705: LD_VAR 0 1
54709: PPUSH
54710: CALL_OW 313
54714: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54715: LD_VAR 0 8
54719: PPUSH
54720: LD_INT 25
54722: PUSH
54723: LD_INT 12
54725: PUSH
54726: EMPTY
54727: LIST
54728: LIST
54729: PPUSH
54730: CALL_OW 72
54734: NOT
54735: IFFALSE 54745
// control := control_manual ;
54737: LD_ADDR_VAR 0 4
54741: PUSH
54742: LD_INT 1
54744: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54745: LD_ADDR_VAR 0 8
54749: PUSH
54750: LD_VAR 0 1
54754: PPUSH
54755: CALL 54442 0 1
54759: ST_TO_ADDR
// if tmp then
54760: LD_VAR 0 8
54764: IFFALSE 54807
// begin for i in tmp do
54766: LD_ADDR_VAR 0 7
54770: PUSH
54771: LD_VAR 0 8
54775: PUSH
54776: FOR_IN
54777: IFFALSE 54805
// if i [ 1 ] = b_ext_radio then
54779: LD_VAR 0 7
54783: PUSH
54784: LD_INT 1
54786: ARRAY
54787: PUSH
54788: LD_INT 22
54790: EQUAL
54791: IFFALSE 54803
// begin control := control_remote ;
54793: LD_ADDR_VAR 0 4
54797: PUSH
54798: LD_INT 2
54800: ST_TO_ADDR
// break ;
54801: GO 54805
// end ;
54803: GO 54776
54805: POP
54806: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54807: LD_VAR 0 1
54811: PPUSH
54812: LD_VAR 0 2
54816: PPUSH
54817: LD_VAR 0 3
54821: PPUSH
54822: LD_VAR 0 4
54826: PPUSH
54827: LD_VAR 0 5
54831: PPUSH
54832: CALL_OW 448
54836: IFFALSE 54871
// begin result := [ chassis , engine , control , weapon ] ;
54838: LD_ADDR_VAR 0 6
54842: PUSH
54843: LD_VAR 0 2
54847: PUSH
54848: LD_VAR 0 3
54852: PUSH
54853: LD_VAR 0 4
54857: PUSH
54858: LD_VAR 0 5
54862: PUSH
54863: EMPTY
54864: LIST
54865: LIST
54866: LIST
54867: LIST
54868: ST_TO_ADDR
// exit ;
54869: GO 55283
// end ; _chassis := AvailableChassisList ( factory ) ;
54871: LD_ADDR_VAR 0 9
54875: PUSH
54876: LD_VAR 0 1
54880: PPUSH
54881: CALL_OW 475
54885: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54886: LD_ADDR_VAR 0 11
54890: PUSH
54891: LD_VAR 0 1
54895: PPUSH
54896: CALL_OW 476
54900: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54901: LD_ADDR_VAR 0 12
54905: PUSH
54906: LD_VAR 0 1
54910: PPUSH
54911: CALL_OW 477
54915: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54916: LD_ADDR_VAR 0 10
54920: PUSH
54921: LD_VAR 0 1
54925: PPUSH
54926: CALL_OW 478
54930: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54931: LD_VAR 0 9
54935: NOT
54936: PUSH
54937: LD_VAR 0 11
54941: NOT
54942: OR
54943: PUSH
54944: LD_VAR 0 12
54948: NOT
54949: OR
54950: PUSH
54951: LD_VAR 0 10
54955: NOT
54956: OR
54957: IFFALSE 54992
// begin result := [ chassis , engine , control , weapon ] ;
54959: LD_ADDR_VAR 0 6
54963: PUSH
54964: LD_VAR 0 2
54968: PUSH
54969: LD_VAR 0 3
54973: PUSH
54974: LD_VAR 0 4
54978: PUSH
54979: LD_VAR 0 5
54983: PUSH
54984: EMPTY
54985: LIST
54986: LIST
54987: LIST
54988: LIST
54989: ST_TO_ADDR
// exit ;
54990: GO 55283
// end ; if not chassis in _chassis then
54992: LD_VAR 0 2
54996: PUSH
54997: LD_VAR 0 9
55001: IN
55002: NOT
55003: IFFALSE 55029
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55005: LD_ADDR_VAR 0 2
55009: PUSH
55010: LD_VAR 0 9
55014: PUSH
55015: LD_INT 1
55017: PPUSH
55018: LD_VAR 0 9
55022: PPUSH
55023: CALL_OW 12
55027: ARRAY
55028: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55029: LD_VAR 0 2
55033: PPUSH
55034: LD_VAR 0 3
55038: PPUSH
55039: CALL 55288 0 2
55043: NOT
55044: IFFALSE 55103
// repeat engine := _engine [ 1 ] ;
55046: LD_ADDR_VAR 0 3
55050: PUSH
55051: LD_VAR 0 11
55055: PUSH
55056: LD_INT 1
55058: ARRAY
55059: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55060: LD_ADDR_VAR 0 11
55064: PUSH
55065: LD_VAR 0 11
55069: PPUSH
55070: LD_INT 1
55072: PPUSH
55073: CALL_OW 3
55077: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55078: LD_VAR 0 2
55082: PPUSH
55083: LD_VAR 0 3
55087: PPUSH
55088: CALL 55288 0 2
55092: PUSH
55093: LD_VAR 0 11
55097: PUSH
55098: EMPTY
55099: EQUAL
55100: OR
55101: IFFALSE 55046
// if not control in _control then
55103: LD_VAR 0 4
55107: PUSH
55108: LD_VAR 0 12
55112: IN
55113: NOT
55114: IFFALSE 55140
// control := _control [ rand ( 1 , _control ) ] ;
55116: LD_ADDR_VAR 0 4
55120: PUSH
55121: LD_VAR 0 12
55125: PUSH
55126: LD_INT 1
55128: PPUSH
55129: LD_VAR 0 12
55133: PPUSH
55134: CALL_OW 12
55138: ARRAY
55139: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55140: LD_VAR 0 2
55144: PPUSH
55145: LD_VAR 0 5
55149: PPUSH
55150: CALL 55508 0 2
55154: NOT
55155: IFFALSE 55214
// repeat weapon := _weapon [ 1 ] ;
55157: LD_ADDR_VAR 0 5
55161: PUSH
55162: LD_VAR 0 10
55166: PUSH
55167: LD_INT 1
55169: ARRAY
55170: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55171: LD_ADDR_VAR 0 10
55175: PUSH
55176: LD_VAR 0 10
55180: PPUSH
55181: LD_INT 1
55183: PPUSH
55184: CALL_OW 3
55188: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55189: LD_VAR 0 2
55193: PPUSH
55194: LD_VAR 0 5
55198: PPUSH
55199: CALL 55508 0 2
55203: PUSH
55204: LD_VAR 0 10
55208: PUSH
55209: EMPTY
55210: EQUAL
55211: OR
55212: IFFALSE 55157
// result := [ ] ;
55214: LD_ADDR_VAR 0 6
55218: PUSH
55219: EMPTY
55220: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55221: LD_VAR 0 1
55225: PPUSH
55226: LD_VAR 0 2
55230: PPUSH
55231: LD_VAR 0 3
55235: PPUSH
55236: LD_VAR 0 4
55240: PPUSH
55241: LD_VAR 0 5
55245: PPUSH
55246: CALL_OW 448
55250: IFFALSE 55283
// result := [ chassis , engine , control , weapon ] ;
55252: LD_ADDR_VAR 0 6
55256: PUSH
55257: LD_VAR 0 2
55261: PUSH
55262: LD_VAR 0 3
55266: PUSH
55267: LD_VAR 0 4
55271: PUSH
55272: LD_VAR 0 5
55276: PUSH
55277: EMPTY
55278: LIST
55279: LIST
55280: LIST
55281: LIST
55282: ST_TO_ADDR
// end ;
55283: LD_VAR 0 6
55287: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55288: LD_INT 0
55290: PPUSH
// if not chassis or not engine then
55291: LD_VAR 0 1
55295: NOT
55296: PUSH
55297: LD_VAR 0 2
55301: NOT
55302: OR
55303: IFFALSE 55307
// exit ;
55305: GO 55503
// case engine of engine_solar :
55307: LD_VAR 0 2
55311: PUSH
55312: LD_INT 2
55314: DOUBLE
55315: EQUAL
55316: IFTRUE 55320
55318: GO 55358
55320: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55321: LD_ADDR_VAR 0 3
55325: PUSH
55326: LD_INT 11
55328: PUSH
55329: LD_INT 12
55331: PUSH
55332: LD_INT 13
55334: PUSH
55335: LD_INT 14
55337: PUSH
55338: LD_INT 1
55340: PUSH
55341: LD_INT 2
55343: PUSH
55344: LD_INT 3
55346: PUSH
55347: EMPTY
55348: LIST
55349: LIST
55350: LIST
55351: LIST
55352: LIST
55353: LIST
55354: LIST
55355: ST_TO_ADDR
55356: GO 55487
55358: LD_INT 1
55360: DOUBLE
55361: EQUAL
55362: IFTRUE 55366
55364: GO 55428
55366: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55367: LD_ADDR_VAR 0 3
55371: PUSH
55372: LD_INT 11
55374: PUSH
55375: LD_INT 12
55377: PUSH
55378: LD_INT 13
55380: PUSH
55381: LD_INT 14
55383: PUSH
55384: LD_INT 1
55386: PUSH
55387: LD_INT 2
55389: PUSH
55390: LD_INT 3
55392: PUSH
55393: LD_INT 4
55395: PUSH
55396: LD_INT 5
55398: PUSH
55399: LD_INT 21
55401: PUSH
55402: LD_INT 23
55404: PUSH
55405: LD_INT 22
55407: PUSH
55408: LD_INT 24
55410: PUSH
55411: EMPTY
55412: LIST
55413: LIST
55414: LIST
55415: LIST
55416: LIST
55417: LIST
55418: LIST
55419: LIST
55420: LIST
55421: LIST
55422: LIST
55423: LIST
55424: LIST
55425: ST_TO_ADDR
55426: GO 55487
55428: LD_INT 3
55430: DOUBLE
55431: EQUAL
55432: IFTRUE 55436
55434: GO 55486
55436: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55437: LD_ADDR_VAR 0 3
55441: PUSH
55442: LD_INT 13
55444: PUSH
55445: LD_INT 14
55447: PUSH
55448: LD_INT 2
55450: PUSH
55451: LD_INT 3
55453: PUSH
55454: LD_INT 4
55456: PUSH
55457: LD_INT 5
55459: PUSH
55460: LD_INT 21
55462: PUSH
55463: LD_INT 22
55465: PUSH
55466: LD_INT 23
55468: PUSH
55469: LD_INT 24
55471: PUSH
55472: EMPTY
55473: LIST
55474: LIST
55475: LIST
55476: LIST
55477: LIST
55478: LIST
55479: LIST
55480: LIST
55481: LIST
55482: LIST
55483: ST_TO_ADDR
55484: GO 55487
55486: POP
// result := ( chassis in result ) ;
55487: LD_ADDR_VAR 0 3
55491: PUSH
55492: LD_VAR 0 1
55496: PUSH
55497: LD_VAR 0 3
55501: IN
55502: ST_TO_ADDR
// end ;
55503: LD_VAR 0 3
55507: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55508: LD_INT 0
55510: PPUSH
// if not chassis or not weapon then
55511: LD_VAR 0 1
55515: NOT
55516: PUSH
55517: LD_VAR 0 2
55521: NOT
55522: OR
55523: IFFALSE 55527
// exit ;
55525: GO 56587
// case weapon of us_machine_gun :
55527: LD_VAR 0 2
55531: PUSH
55532: LD_INT 2
55534: DOUBLE
55535: EQUAL
55536: IFTRUE 55540
55538: GO 55570
55540: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55541: LD_ADDR_VAR 0 3
55545: PUSH
55546: LD_INT 1
55548: PUSH
55549: LD_INT 2
55551: PUSH
55552: LD_INT 3
55554: PUSH
55555: LD_INT 4
55557: PUSH
55558: LD_INT 5
55560: PUSH
55561: EMPTY
55562: LIST
55563: LIST
55564: LIST
55565: LIST
55566: LIST
55567: ST_TO_ADDR
55568: GO 56571
55570: LD_INT 3
55572: DOUBLE
55573: EQUAL
55574: IFTRUE 55578
55576: GO 55608
55578: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55579: LD_ADDR_VAR 0 3
55583: PUSH
55584: LD_INT 1
55586: PUSH
55587: LD_INT 2
55589: PUSH
55590: LD_INT 3
55592: PUSH
55593: LD_INT 4
55595: PUSH
55596: LD_INT 5
55598: PUSH
55599: EMPTY
55600: LIST
55601: LIST
55602: LIST
55603: LIST
55604: LIST
55605: ST_TO_ADDR
55606: GO 56571
55608: LD_INT 11
55610: DOUBLE
55611: EQUAL
55612: IFTRUE 55616
55614: GO 55646
55616: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55617: LD_ADDR_VAR 0 3
55621: PUSH
55622: LD_INT 1
55624: PUSH
55625: LD_INT 2
55627: PUSH
55628: LD_INT 3
55630: PUSH
55631: LD_INT 4
55633: PUSH
55634: LD_INT 5
55636: PUSH
55637: EMPTY
55638: LIST
55639: LIST
55640: LIST
55641: LIST
55642: LIST
55643: ST_TO_ADDR
55644: GO 56571
55646: LD_INT 4
55648: DOUBLE
55649: EQUAL
55650: IFTRUE 55654
55652: GO 55680
55654: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55655: LD_ADDR_VAR 0 3
55659: PUSH
55660: LD_INT 2
55662: PUSH
55663: LD_INT 3
55665: PUSH
55666: LD_INT 4
55668: PUSH
55669: LD_INT 5
55671: PUSH
55672: EMPTY
55673: LIST
55674: LIST
55675: LIST
55676: LIST
55677: ST_TO_ADDR
55678: GO 56571
55680: LD_INT 5
55682: DOUBLE
55683: EQUAL
55684: IFTRUE 55688
55686: GO 55714
55688: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55689: LD_ADDR_VAR 0 3
55693: PUSH
55694: LD_INT 2
55696: PUSH
55697: LD_INT 3
55699: PUSH
55700: LD_INT 4
55702: PUSH
55703: LD_INT 5
55705: PUSH
55706: EMPTY
55707: LIST
55708: LIST
55709: LIST
55710: LIST
55711: ST_TO_ADDR
55712: GO 56571
55714: LD_INT 9
55716: DOUBLE
55717: EQUAL
55718: IFTRUE 55722
55720: GO 55748
55722: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55723: LD_ADDR_VAR 0 3
55727: PUSH
55728: LD_INT 2
55730: PUSH
55731: LD_INT 3
55733: PUSH
55734: LD_INT 4
55736: PUSH
55737: LD_INT 5
55739: PUSH
55740: EMPTY
55741: LIST
55742: LIST
55743: LIST
55744: LIST
55745: ST_TO_ADDR
55746: GO 56571
55748: LD_INT 7
55750: DOUBLE
55751: EQUAL
55752: IFTRUE 55756
55754: GO 55782
55756: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55757: LD_ADDR_VAR 0 3
55761: PUSH
55762: LD_INT 2
55764: PUSH
55765: LD_INT 3
55767: PUSH
55768: LD_INT 4
55770: PUSH
55771: LD_INT 5
55773: PUSH
55774: EMPTY
55775: LIST
55776: LIST
55777: LIST
55778: LIST
55779: ST_TO_ADDR
55780: GO 56571
55782: LD_INT 12
55784: DOUBLE
55785: EQUAL
55786: IFTRUE 55790
55788: GO 55816
55790: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55791: LD_ADDR_VAR 0 3
55795: PUSH
55796: LD_INT 2
55798: PUSH
55799: LD_INT 3
55801: PUSH
55802: LD_INT 4
55804: PUSH
55805: LD_INT 5
55807: PUSH
55808: EMPTY
55809: LIST
55810: LIST
55811: LIST
55812: LIST
55813: ST_TO_ADDR
55814: GO 56571
55816: LD_INT 13
55818: DOUBLE
55819: EQUAL
55820: IFTRUE 55824
55822: GO 55850
55824: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55825: LD_ADDR_VAR 0 3
55829: PUSH
55830: LD_INT 2
55832: PUSH
55833: LD_INT 3
55835: PUSH
55836: LD_INT 4
55838: PUSH
55839: LD_INT 5
55841: PUSH
55842: EMPTY
55843: LIST
55844: LIST
55845: LIST
55846: LIST
55847: ST_TO_ADDR
55848: GO 56571
55850: LD_INT 14
55852: DOUBLE
55853: EQUAL
55854: IFTRUE 55858
55856: GO 55876
55858: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55859: LD_ADDR_VAR 0 3
55863: PUSH
55864: LD_INT 4
55866: PUSH
55867: LD_INT 5
55869: PUSH
55870: EMPTY
55871: LIST
55872: LIST
55873: ST_TO_ADDR
55874: GO 56571
55876: LD_INT 6
55878: DOUBLE
55879: EQUAL
55880: IFTRUE 55884
55882: GO 55902
55884: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55885: LD_ADDR_VAR 0 3
55889: PUSH
55890: LD_INT 4
55892: PUSH
55893: LD_INT 5
55895: PUSH
55896: EMPTY
55897: LIST
55898: LIST
55899: ST_TO_ADDR
55900: GO 56571
55902: LD_INT 10
55904: DOUBLE
55905: EQUAL
55906: IFTRUE 55910
55908: GO 55928
55910: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55911: LD_ADDR_VAR 0 3
55915: PUSH
55916: LD_INT 4
55918: PUSH
55919: LD_INT 5
55921: PUSH
55922: EMPTY
55923: LIST
55924: LIST
55925: ST_TO_ADDR
55926: GO 56571
55928: LD_INT 22
55930: DOUBLE
55931: EQUAL
55932: IFTRUE 55936
55934: GO 55962
55936: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55937: LD_ADDR_VAR 0 3
55941: PUSH
55942: LD_INT 11
55944: PUSH
55945: LD_INT 12
55947: PUSH
55948: LD_INT 13
55950: PUSH
55951: LD_INT 14
55953: PUSH
55954: EMPTY
55955: LIST
55956: LIST
55957: LIST
55958: LIST
55959: ST_TO_ADDR
55960: GO 56571
55962: LD_INT 23
55964: DOUBLE
55965: EQUAL
55966: IFTRUE 55970
55968: GO 55996
55970: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55971: LD_ADDR_VAR 0 3
55975: PUSH
55976: LD_INT 11
55978: PUSH
55979: LD_INT 12
55981: PUSH
55982: LD_INT 13
55984: PUSH
55985: LD_INT 14
55987: PUSH
55988: EMPTY
55989: LIST
55990: LIST
55991: LIST
55992: LIST
55993: ST_TO_ADDR
55994: GO 56571
55996: LD_INT 24
55998: DOUBLE
55999: EQUAL
56000: IFTRUE 56004
56002: GO 56030
56004: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56005: LD_ADDR_VAR 0 3
56009: PUSH
56010: LD_INT 11
56012: PUSH
56013: LD_INT 12
56015: PUSH
56016: LD_INT 13
56018: PUSH
56019: LD_INT 14
56021: PUSH
56022: EMPTY
56023: LIST
56024: LIST
56025: LIST
56026: LIST
56027: ST_TO_ADDR
56028: GO 56571
56030: LD_INT 30
56032: DOUBLE
56033: EQUAL
56034: IFTRUE 56038
56036: GO 56064
56038: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56039: LD_ADDR_VAR 0 3
56043: PUSH
56044: LD_INT 11
56046: PUSH
56047: LD_INT 12
56049: PUSH
56050: LD_INT 13
56052: PUSH
56053: LD_INT 14
56055: PUSH
56056: EMPTY
56057: LIST
56058: LIST
56059: LIST
56060: LIST
56061: ST_TO_ADDR
56062: GO 56571
56064: LD_INT 25
56066: DOUBLE
56067: EQUAL
56068: IFTRUE 56072
56070: GO 56090
56072: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56073: LD_ADDR_VAR 0 3
56077: PUSH
56078: LD_INT 13
56080: PUSH
56081: LD_INT 14
56083: PUSH
56084: EMPTY
56085: LIST
56086: LIST
56087: ST_TO_ADDR
56088: GO 56571
56090: LD_INT 27
56092: DOUBLE
56093: EQUAL
56094: IFTRUE 56098
56096: GO 56116
56098: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
56099: LD_ADDR_VAR 0 3
56103: PUSH
56104: LD_INT 13
56106: PUSH
56107: LD_INT 14
56109: PUSH
56110: EMPTY
56111: LIST
56112: LIST
56113: ST_TO_ADDR
56114: GO 56571
56116: LD_INT 92
56118: DOUBLE
56119: EQUAL
56120: IFTRUE 56124
56122: GO 56150
56124: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56125: LD_ADDR_VAR 0 3
56129: PUSH
56130: LD_INT 11
56132: PUSH
56133: LD_INT 12
56135: PUSH
56136: LD_INT 13
56138: PUSH
56139: LD_INT 14
56141: PUSH
56142: EMPTY
56143: LIST
56144: LIST
56145: LIST
56146: LIST
56147: ST_TO_ADDR
56148: GO 56571
56150: LD_INT 28
56152: DOUBLE
56153: EQUAL
56154: IFTRUE 56158
56156: GO 56176
56158: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56159: LD_ADDR_VAR 0 3
56163: PUSH
56164: LD_INT 13
56166: PUSH
56167: LD_INT 14
56169: PUSH
56170: EMPTY
56171: LIST
56172: LIST
56173: ST_TO_ADDR
56174: GO 56571
56176: LD_INT 29
56178: DOUBLE
56179: EQUAL
56180: IFTRUE 56184
56182: GO 56202
56184: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56185: LD_ADDR_VAR 0 3
56189: PUSH
56190: LD_INT 13
56192: PUSH
56193: LD_INT 14
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: ST_TO_ADDR
56200: GO 56571
56202: LD_INT 31
56204: DOUBLE
56205: EQUAL
56206: IFTRUE 56210
56208: GO 56228
56210: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56211: LD_ADDR_VAR 0 3
56215: PUSH
56216: LD_INT 13
56218: PUSH
56219: LD_INT 14
56221: PUSH
56222: EMPTY
56223: LIST
56224: LIST
56225: ST_TO_ADDR
56226: GO 56571
56228: LD_INT 26
56230: DOUBLE
56231: EQUAL
56232: IFTRUE 56236
56234: GO 56254
56236: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56237: LD_ADDR_VAR 0 3
56241: PUSH
56242: LD_INT 13
56244: PUSH
56245: LD_INT 14
56247: PUSH
56248: EMPTY
56249: LIST
56250: LIST
56251: ST_TO_ADDR
56252: GO 56571
56254: LD_INT 42
56256: DOUBLE
56257: EQUAL
56258: IFTRUE 56262
56260: GO 56288
56262: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56263: LD_ADDR_VAR 0 3
56267: PUSH
56268: LD_INT 21
56270: PUSH
56271: LD_INT 22
56273: PUSH
56274: LD_INT 23
56276: PUSH
56277: LD_INT 24
56279: PUSH
56280: EMPTY
56281: LIST
56282: LIST
56283: LIST
56284: LIST
56285: ST_TO_ADDR
56286: GO 56571
56288: LD_INT 43
56290: DOUBLE
56291: EQUAL
56292: IFTRUE 56296
56294: GO 56322
56296: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56297: LD_ADDR_VAR 0 3
56301: PUSH
56302: LD_INT 21
56304: PUSH
56305: LD_INT 22
56307: PUSH
56308: LD_INT 23
56310: PUSH
56311: LD_INT 24
56313: PUSH
56314: EMPTY
56315: LIST
56316: LIST
56317: LIST
56318: LIST
56319: ST_TO_ADDR
56320: GO 56571
56322: LD_INT 44
56324: DOUBLE
56325: EQUAL
56326: IFTRUE 56330
56328: GO 56356
56330: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56331: LD_ADDR_VAR 0 3
56335: PUSH
56336: LD_INT 21
56338: PUSH
56339: LD_INT 22
56341: PUSH
56342: LD_INT 23
56344: PUSH
56345: LD_INT 24
56347: PUSH
56348: EMPTY
56349: LIST
56350: LIST
56351: LIST
56352: LIST
56353: ST_TO_ADDR
56354: GO 56571
56356: LD_INT 45
56358: DOUBLE
56359: EQUAL
56360: IFTRUE 56364
56362: GO 56390
56364: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56365: LD_ADDR_VAR 0 3
56369: PUSH
56370: LD_INT 21
56372: PUSH
56373: LD_INT 22
56375: PUSH
56376: LD_INT 23
56378: PUSH
56379: LD_INT 24
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: LIST
56386: LIST
56387: ST_TO_ADDR
56388: GO 56571
56390: LD_INT 49
56392: DOUBLE
56393: EQUAL
56394: IFTRUE 56398
56396: GO 56424
56398: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56399: LD_ADDR_VAR 0 3
56403: PUSH
56404: LD_INT 21
56406: PUSH
56407: LD_INT 22
56409: PUSH
56410: LD_INT 23
56412: PUSH
56413: LD_INT 24
56415: PUSH
56416: EMPTY
56417: LIST
56418: LIST
56419: LIST
56420: LIST
56421: ST_TO_ADDR
56422: GO 56571
56424: LD_INT 51
56426: DOUBLE
56427: EQUAL
56428: IFTRUE 56432
56430: GO 56458
56432: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56433: LD_ADDR_VAR 0 3
56437: PUSH
56438: LD_INT 21
56440: PUSH
56441: LD_INT 22
56443: PUSH
56444: LD_INT 23
56446: PUSH
56447: LD_INT 24
56449: PUSH
56450: EMPTY
56451: LIST
56452: LIST
56453: LIST
56454: LIST
56455: ST_TO_ADDR
56456: GO 56571
56458: LD_INT 52
56460: DOUBLE
56461: EQUAL
56462: IFTRUE 56466
56464: GO 56492
56466: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56467: LD_ADDR_VAR 0 3
56471: PUSH
56472: LD_INT 21
56474: PUSH
56475: LD_INT 22
56477: PUSH
56478: LD_INT 23
56480: PUSH
56481: LD_INT 24
56483: PUSH
56484: EMPTY
56485: LIST
56486: LIST
56487: LIST
56488: LIST
56489: ST_TO_ADDR
56490: GO 56571
56492: LD_INT 53
56494: DOUBLE
56495: EQUAL
56496: IFTRUE 56500
56498: GO 56518
56500: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56501: LD_ADDR_VAR 0 3
56505: PUSH
56506: LD_INT 23
56508: PUSH
56509: LD_INT 24
56511: PUSH
56512: EMPTY
56513: LIST
56514: LIST
56515: ST_TO_ADDR
56516: GO 56571
56518: LD_INT 46
56520: DOUBLE
56521: EQUAL
56522: IFTRUE 56526
56524: GO 56544
56526: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56527: LD_ADDR_VAR 0 3
56531: PUSH
56532: LD_INT 23
56534: PUSH
56535: LD_INT 24
56537: PUSH
56538: EMPTY
56539: LIST
56540: LIST
56541: ST_TO_ADDR
56542: GO 56571
56544: LD_INT 47
56546: DOUBLE
56547: EQUAL
56548: IFTRUE 56552
56550: GO 56570
56552: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56553: LD_ADDR_VAR 0 3
56557: PUSH
56558: LD_INT 23
56560: PUSH
56561: LD_INT 24
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: ST_TO_ADDR
56568: GO 56571
56570: POP
// result := ( chassis in result ) ;
56571: LD_ADDR_VAR 0 3
56575: PUSH
56576: LD_VAR 0 1
56580: PUSH
56581: LD_VAR 0 3
56585: IN
56586: ST_TO_ADDR
// end ;
56587: LD_VAR 0 3
56591: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56592: LD_INT 0
56594: PPUSH
56595: PPUSH
56596: PPUSH
56597: PPUSH
56598: PPUSH
56599: PPUSH
56600: PPUSH
// result := array ;
56601: LD_ADDR_VAR 0 5
56605: PUSH
56606: LD_VAR 0 1
56610: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56611: LD_VAR 0 1
56615: NOT
56616: PUSH
56617: LD_VAR 0 2
56621: NOT
56622: OR
56623: PUSH
56624: LD_VAR 0 3
56628: NOT
56629: OR
56630: PUSH
56631: LD_VAR 0 2
56635: PUSH
56636: LD_VAR 0 1
56640: GREATER
56641: OR
56642: PUSH
56643: LD_VAR 0 3
56647: PUSH
56648: LD_VAR 0 1
56652: GREATER
56653: OR
56654: IFFALSE 56658
// exit ;
56656: GO 56954
// if direction then
56658: LD_VAR 0 4
56662: IFFALSE 56726
// begin d := 1 ;
56664: LD_ADDR_VAR 0 9
56668: PUSH
56669: LD_INT 1
56671: ST_TO_ADDR
// if i_from > i_to then
56672: LD_VAR 0 2
56676: PUSH
56677: LD_VAR 0 3
56681: GREATER
56682: IFFALSE 56708
// length := ( array - i_from ) + i_to else
56684: LD_ADDR_VAR 0 11
56688: PUSH
56689: LD_VAR 0 1
56693: PUSH
56694: LD_VAR 0 2
56698: MINUS
56699: PUSH
56700: LD_VAR 0 3
56704: PLUS
56705: ST_TO_ADDR
56706: GO 56724
// length := i_to - i_from ;
56708: LD_ADDR_VAR 0 11
56712: PUSH
56713: LD_VAR 0 3
56717: PUSH
56718: LD_VAR 0 2
56722: MINUS
56723: ST_TO_ADDR
// end else
56724: GO 56787
// begin d := - 1 ;
56726: LD_ADDR_VAR 0 9
56730: PUSH
56731: LD_INT 1
56733: NEG
56734: ST_TO_ADDR
// if i_from > i_to then
56735: LD_VAR 0 2
56739: PUSH
56740: LD_VAR 0 3
56744: GREATER
56745: IFFALSE 56765
// length := i_from - i_to else
56747: LD_ADDR_VAR 0 11
56751: PUSH
56752: LD_VAR 0 2
56756: PUSH
56757: LD_VAR 0 3
56761: MINUS
56762: ST_TO_ADDR
56763: GO 56787
// length := ( array - i_to ) + i_from ;
56765: LD_ADDR_VAR 0 11
56769: PUSH
56770: LD_VAR 0 1
56774: PUSH
56775: LD_VAR 0 3
56779: MINUS
56780: PUSH
56781: LD_VAR 0 2
56785: PLUS
56786: ST_TO_ADDR
// end ; if not length then
56787: LD_VAR 0 11
56791: NOT
56792: IFFALSE 56796
// exit ;
56794: GO 56954
// tmp := array ;
56796: LD_ADDR_VAR 0 10
56800: PUSH
56801: LD_VAR 0 1
56805: ST_TO_ADDR
// for i = 1 to length do
56806: LD_ADDR_VAR 0 6
56810: PUSH
56811: DOUBLE
56812: LD_INT 1
56814: DEC
56815: ST_TO_ADDR
56816: LD_VAR 0 11
56820: PUSH
56821: FOR_TO
56822: IFFALSE 56942
// begin for j = 1 to array do
56824: LD_ADDR_VAR 0 7
56828: PUSH
56829: DOUBLE
56830: LD_INT 1
56832: DEC
56833: ST_TO_ADDR
56834: LD_VAR 0 1
56838: PUSH
56839: FOR_TO
56840: IFFALSE 56928
// begin k := j + d ;
56842: LD_ADDR_VAR 0 8
56846: PUSH
56847: LD_VAR 0 7
56851: PUSH
56852: LD_VAR 0 9
56856: PLUS
56857: ST_TO_ADDR
// if k > array then
56858: LD_VAR 0 8
56862: PUSH
56863: LD_VAR 0 1
56867: GREATER
56868: IFFALSE 56878
// k := 1 ;
56870: LD_ADDR_VAR 0 8
56874: PUSH
56875: LD_INT 1
56877: ST_TO_ADDR
// if not k then
56878: LD_VAR 0 8
56882: NOT
56883: IFFALSE 56895
// k := array ;
56885: LD_ADDR_VAR 0 8
56889: PUSH
56890: LD_VAR 0 1
56894: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56895: LD_ADDR_VAR 0 10
56899: PUSH
56900: LD_VAR 0 10
56904: PPUSH
56905: LD_VAR 0 8
56909: PPUSH
56910: LD_VAR 0 1
56914: PUSH
56915: LD_VAR 0 7
56919: ARRAY
56920: PPUSH
56921: CALL_OW 1
56925: ST_TO_ADDR
// end ;
56926: GO 56839
56928: POP
56929: POP
// array := tmp ;
56930: LD_ADDR_VAR 0 1
56934: PUSH
56935: LD_VAR 0 10
56939: ST_TO_ADDR
// end ;
56940: GO 56821
56942: POP
56943: POP
// result := array ;
56944: LD_ADDR_VAR 0 5
56948: PUSH
56949: LD_VAR 0 1
56953: ST_TO_ADDR
// end ;
56954: LD_VAR 0 5
56958: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56959: LD_INT 0
56961: PPUSH
56962: PPUSH
// result := 0 ;
56963: LD_ADDR_VAR 0 3
56967: PUSH
56968: LD_INT 0
56970: ST_TO_ADDR
// if not array or not value in array then
56971: LD_VAR 0 1
56975: NOT
56976: PUSH
56977: LD_VAR 0 2
56981: PUSH
56982: LD_VAR 0 1
56986: IN
56987: NOT
56988: OR
56989: IFFALSE 56993
// exit ;
56991: GO 57047
// for i = 1 to array do
56993: LD_ADDR_VAR 0 4
56997: PUSH
56998: DOUBLE
56999: LD_INT 1
57001: DEC
57002: ST_TO_ADDR
57003: LD_VAR 0 1
57007: PUSH
57008: FOR_TO
57009: IFFALSE 57045
// if value = array [ i ] then
57011: LD_VAR 0 2
57015: PUSH
57016: LD_VAR 0 1
57020: PUSH
57021: LD_VAR 0 4
57025: ARRAY
57026: EQUAL
57027: IFFALSE 57043
// begin result := i ;
57029: LD_ADDR_VAR 0 3
57033: PUSH
57034: LD_VAR 0 4
57038: ST_TO_ADDR
// exit ;
57039: POP
57040: POP
57041: GO 57047
// end ;
57043: GO 57008
57045: POP
57046: POP
// end ;
57047: LD_VAR 0 3
57051: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57052: LD_INT 0
57054: PPUSH
// vc_chassis := chassis ;
57055: LD_ADDR_OWVAR 37
57059: PUSH
57060: LD_VAR 0 1
57064: ST_TO_ADDR
// vc_engine := engine ;
57065: LD_ADDR_OWVAR 39
57069: PUSH
57070: LD_VAR 0 2
57074: ST_TO_ADDR
// vc_control := control ;
57075: LD_ADDR_OWVAR 38
57079: PUSH
57080: LD_VAR 0 3
57084: ST_TO_ADDR
// vc_weapon := weapon ;
57085: LD_ADDR_OWVAR 40
57089: PUSH
57090: LD_VAR 0 4
57094: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57095: LD_ADDR_OWVAR 41
57099: PUSH
57100: LD_VAR 0 5
57104: ST_TO_ADDR
// end ;
57105: LD_VAR 0 6
57109: RET
// export function WantPlant ( unit ) ; var task ; begin
57110: LD_INT 0
57112: PPUSH
57113: PPUSH
// result := false ;
57114: LD_ADDR_VAR 0 2
57118: PUSH
57119: LD_INT 0
57121: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57122: LD_ADDR_VAR 0 3
57126: PUSH
57127: LD_VAR 0 1
57131: PPUSH
57132: CALL_OW 437
57136: ST_TO_ADDR
// if task then
57137: LD_VAR 0 3
57141: IFFALSE 57169
// if task [ 1 ] [ 1 ] = p then
57143: LD_VAR 0 3
57147: PUSH
57148: LD_INT 1
57150: ARRAY
57151: PUSH
57152: LD_INT 1
57154: ARRAY
57155: PUSH
57156: LD_STRING p
57158: EQUAL
57159: IFFALSE 57169
// result := true ;
57161: LD_ADDR_VAR 0 2
57165: PUSH
57166: LD_INT 1
57168: ST_TO_ADDR
// end ;
57169: LD_VAR 0 2
57173: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57174: LD_INT 0
57176: PPUSH
57177: PPUSH
57178: PPUSH
57179: PPUSH
// if pos < 1 then
57180: LD_VAR 0 2
57184: PUSH
57185: LD_INT 1
57187: LESS
57188: IFFALSE 57192
// exit ;
57190: GO 57495
// if pos = 1 then
57192: LD_VAR 0 2
57196: PUSH
57197: LD_INT 1
57199: EQUAL
57200: IFFALSE 57233
// result := Replace ( arr , pos [ 1 ] , value ) else
57202: LD_ADDR_VAR 0 4
57206: PUSH
57207: LD_VAR 0 1
57211: PPUSH
57212: LD_VAR 0 2
57216: PUSH
57217: LD_INT 1
57219: ARRAY
57220: PPUSH
57221: LD_VAR 0 3
57225: PPUSH
57226: CALL_OW 1
57230: ST_TO_ADDR
57231: GO 57495
// begin tmp := arr ;
57233: LD_ADDR_VAR 0 6
57237: PUSH
57238: LD_VAR 0 1
57242: ST_TO_ADDR
// s_arr := [ tmp ] ;
57243: LD_ADDR_VAR 0 7
57247: PUSH
57248: LD_VAR 0 6
57252: PUSH
57253: EMPTY
57254: LIST
57255: ST_TO_ADDR
// for i = 1 to pos - 1 do
57256: LD_ADDR_VAR 0 5
57260: PUSH
57261: DOUBLE
57262: LD_INT 1
57264: DEC
57265: ST_TO_ADDR
57266: LD_VAR 0 2
57270: PUSH
57271: LD_INT 1
57273: MINUS
57274: PUSH
57275: FOR_TO
57276: IFFALSE 57321
// begin tmp := tmp [ pos [ i ] ] ;
57278: LD_ADDR_VAR 0 6
57282: PUSH
57283: LD_VAR 0 6
57287: PUSH
57288: LD_VAR 0 2
57292: PUSH
57293: LD_VAR 0 5
57297: ARRAY
57298: ARRAY
57299: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57300: LD_ADDR_VAR 0 7
57304: PUSH
57305: LD_VAR 0 7
57309: PUSH
57310: LD_VAR 0 6
57314: PUSH
57315: EMPTY
57316: LIST
57317: ADD
57318: ST_TO_ADDR
// end ;
57319: GO 57275
57321: POP
57322: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57323: LD_ADDR_VAR 0 6
57327: PUSH
57328: LD_VAR 0 6
57332: PPUSH
57333: LD_VAR 0 2
57337: PUSH
57338: LD_VAR 0 2
57342: ARRAY
57343: PPUSH
57344: LD_VAR 0 3
57348: PPUSH
57349: CALL_OW 1
57353: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57354: LD_ADDR_VAR 0 7
57358: PUSH
57359: LD_VAR 0 7
57363: PPUSH
57364: LD_VAR 0 7
57368: PPUSH
57369: LD_VAR 0 6
57373: PPUSH
57374: CALL_OW 1
57378: ST_TO_ADDR
// for i = s_arr downto 2 do
57379: LD_ADDR_VAR 0 5
57383: PUSH
57384: DOUBLE
57385: LD_VAR 0 7
57389: INC
57390: ST_TO_ADDR
57391: LD_INT 2
57393: PUSH
57394: FOR_DOWNTO
57395: IFFALSE 57479
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57397: LD_ADDR_VAR 0 6
57401: PUSH
57402: LD_VAR 0 7
57406: PUSH
57407: LD_VAR 0 5
57411: PUSH
57412: LD_INT 1
57414: MINUS
57415: ARRAY
57416: PPUSH
57417: LD_VAR 0 2
57421: PUSH
57422: LD_VAR 0 5
57426: PUSH
57427: LD_INT 1
57429: MINUS
57430: ARRAY
57431: PPUSH
57432: LD_VAR 0 7
57436: PUSH
57437: LD_VAR 0 5
57441: ARRAY
57442: PPUSH
57443: CALL_OW 1
57447: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57448: LD_ADDR_VAR 0 7
57452: PUSH
57453: LD_VAR 0 7
57457: PPUSH
57458: LD_VAR 0 5
57462: PUSH
57463: LD_INT 1
57465: MINUS
57466: PPUSH
57467: LD_VAR 0 6
57471: PPUSH
57472: CALL_OW 1
57476: ST_TO_ADDR
// end ;
57477: GO 57394
57479: POP
57480: POP
// result := s_arr [ 1 ] ;
57481: LD_ADDR_VAR 0 4
57485: PUSH
57486: LD_VAR 0 7
57490: PUSH
57491: LD_INT 1
57493: ARRAY
57494: ST_TO_ADDR
// end ; end ;
57495: LD_VAR 0 4
57499: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57500: LD_INT 0
57502: PPUSH
57503: PPUSH
// if not list then
57504: LD_VAR 0 1
57508: NOT
57509: IFFALSE 57513
// exit ;
57511: GO 57604
// i := list [ pos1 ] ;
57513: LD_ADDR_VAR 0 5
57517: PUSH
57518: LD_VAR 0 1
57522: PUSH
57523: LD_VAR 0 2
57527: ARRAY
57528: ST_TO_ADDR
// if not i then
57529: LD_VAR 0 5
57533: NOT
57534: IFFALSE 57538
// exit ;
57536: GO 57604
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57538: LD_ADDR_VAR 0 1
57542: PUSH
57543: LD_VAR 0 1
57547: PPUSH
57548: LD_VAR 0 2
57552: PPUSH
57553: LD_VAR 0 1
57557: PUSH
57558: LD_VAR 0 3
57562: ARRAY
57563: PPUSH
57564: CALL_OW 1
57568: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57569: LD_ADDR_VAR 0 1
57573: PUSH
57574: LD_VAR 0 1
57578: PPUSH
57579: LD_VAR 0 3
57583: PPUSH
57584: LD_VAR 0 5
57588: PPUSH
57589: CALL_OW 1
57593: ST_TO_ADDR
// result := list ;
57594: LD_ADDR_VAR 0 4
57598: PUSH
57599: LD_VAR 0 1
57603: ST_TO_ADDR
// end ;
57604: LD_VAR 0 4
57608: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57609: LD_INT 0
57611: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57612: LD_ADDR_VAR 0 5
57616: PUSH
57617: LD_VAR 0 1
57621: PPUSH
57622: CALL_OW 250
57626: PPUSH
57627: LD_VAR 0 1
57631: PPUSH
57632: CALL_OW 251
57636: PPUSH
57637: LD_VAR 0 2
57641: PPUSH
57642: LD_VAR 0 3
57646: PPUSH
57647: LD_VAR 0 4
57651: PPUSH
57652: CALL 57662 0 5
57656: ST_TO_ADDR
// end ;
57657: LD_VAR 0 5
57661: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57662: LD_INT 0
57664: PPUSH
57665: PPUSH
57666: PPUSH
57667: PPUSH
// if not list then
57668: LD_VAR 0 3
57672: NOT
57673: IFFALSE 57677
// exit ;
57675: GO 58065
// result := [ ] ;
57677: LD_ADDR_VAR 0 6
57681: PUSH
57682: EMPTY
57683: ST_TO_ADDR
// for i in list do
57684: LD_ADDR_VAR 0 7
57688: PUSH
57689: LD_VAR 0 3
57693: PUSH
57694: FOR_IN
57695: IFFALSE 57897
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57697: LD_ADDR_VAR 0 9
57701: PUSH
57702: LD_VAR 0 7
57706: PPUSH
57707: LD_VAR 0 1
57711: PPUSH
57712: LD_VAR 0 2
57716: PPUSH
57717: CALL_OW 297
57721: ST_TO_ADDR
// if not result then
57722: LD_VAR 0 6
57726: NOT
57727: IFFALSE 57753
// result := [ [ i , tmp ] ] else
57729: LD_ADDR_VAR 0 6
57733: PUSH
57734: LD_VAR 0 7
57738: PUSH
57739: LD_VAR 0 9
57743: PUSH
57744: EMPTY
57745: LIST
57746: LIST
57747: PUSH
57748: EMPTY
57749: LIST
57750: ST_TO_ADDR
57751: GO 57895
// begin if result [ result ] [ 2 ] < tmp then
57753: LD_VAR 0 6
57757: PUSH
57758: LD_VAR 0 6
57762: ARRAY
57763: PUSH
57764: LD_INT 2
57766: ARRAY
57767: PUSH
57768: LD_VAR 0 9
57772: LESS
57773: IFFALSE 57815
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57775: LD_ADDR_VAR 0 6
57779: PUSH
57780: LD_VAR 0 6
57784: PPUSH
57785: LD_VAR 0 6
57789: PUSH
57790: LD_INT 1
57792: PLUS
57793: PPUSH
57794: LD_VAR 0 7
57798: PUSH
57799: LD_VAR 0 9
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: PPUSH
57808: CALL_OW 2
57812: ST_TO_ADDR
57813: GO 57895
// for j = 1 to result do
57815: LD_ADDR_VAR 0 8
57819: PUSH
57820: DOUBLE
57821: LD_INT 1
57823: DEC
57824: ST_TO_ADDR
57825: LD_VAR 0 6
57829: PUSH
57830: FOR_TO
57831: IFFALSE 57893
// begin if tmp < result [ j ] [ 2 ] then
57833: LD_VAR 0 9
57837: PUSH
57838: LD_VAR 0 6
57842: PUSH
57843: LD_VAR 0 8
57847: ARRAY
57848: PUSH
57849: LD_INT 2
57851: ARRAY
57852: LESS
57853: IFFALSE 57891
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57855: LD_ADDR_VAR 0 6
57859: PUSH
57860: LD_VAR 0 6
57864: PPUSH
57865: LD_VAR 0 8
57869: PPUSH
57870: LD_VAR 0 7
57874: PUSH
57875: LD_VAR 0 9
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: PPUSH
57884: CALL_OW 2
57888: ST_TO_ADDR
// break ;
57889: GO 57893
// end ; end ;
57891: GO 57830
57893: POP
57894: POP
// end ; end ;
57895: GO 57694
57897: POP
57898: POP
// if result and not asc then
57899: LD_VAR 0 6
57903: PUSH
57904: LD_VAR 0 4
57908: NOT
57909: AND
57910: IFFALSE 57985
// begin tmp := result ;
57912: LD_ADDR_VAR 0 9
57916: PUSH
57917: LD_VAR 0 6
57921: ST_TO_ADDR
// for i = tmp downto 1 do
57922: LD_ADDR_VAR 0 7
57926: PUSH
57927: DOUBLE
57928: LD_VAR 0 9
57932: INC
57933: ST_TO_ADDR
57934: LD_INT 1
57936: PUSH
57937: FOR_DOWNTO
57938: IFFALSE 57983
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57940: LD_ADDR_VAR 0 6
57944: PUSH
57945: LD_VAR 0 6
57949: PPUSH
57950: LD_VAR 0 9
57954: PUSH
57955: LD_VAR 0 7
57959: MINUS
57960: PUSH
57961: LD_INT 1
57963: PLUS
57964: PPUSH
57965: LD_VAR 0 9
57969: PUSH
57970: LD_VAR 0 7
57974: ARRAY
57975: PPUSH
57976: CALL_OW 1
57980: ST_TO_ADDR
57981: GO 57937
57983: POP
57984: POP
// end ; tmp := [ ] ;
57985: LD_ADDR_VAR 0 9
57989: PUSH
57990: EMPTY
57991: ST_TO_ADDR
// if mode then
57992: LD_VAR 0 5
57996: IFFALSE 58065
// begin for i = 1 to result do
57998: LD_ADDR_VAR 0 7
58002: PUSH
58003: DOUBLE
58004: LD_INT 1
58006: DEC
58007: ST_TO_ADDR
58008: LD_VAR 0 6
58012: PUSH
58013: FOR_TO
58014: IFFALSE 58053
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58016: LD_ADDR_VAR 0 9
58020: PUSH
58021: LD_VAR 0 9
58025: PPUSH
58026: LD_VAR 0 7
58030: PPUSH
58031: LD_VAR 0 6
58035: PUSH
58036: LD_VAR 0 7
58040: ARRAY
58041: PUSH
58042: LD_INT 1
58044: ARRAY
58045: PPUSH
58046: CALL_OW 1
58050: ST_TO_ADDR
58051: GO 58013
58053: POP
58054: POP
// result := tmp ;
58055: LD_ADDR_VAR 0 6
58059: PUSH
58060: LD_VAR 0 9
58064: ST_TO_ADDR
// end ; end ;
58065: LD_VAR 0 6
58069: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58070: LD_INT 0
58072: PPUSH
58073: PPUSH
58074: PPUSH
58075: PPUSH
58076: PPUSH
58077: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58078: LD_ADDR_VAR 0 5
58082: PUSH
58083: LD_INT 0
58085: PUSH
58086: LD_INT 0
58088: PUSH
58089: LD_INT 0
58091: PUSH
58092: EMPTY
58093: PUSH
58094: EMPTY
58095: LIST
58096: LIST
58097: LIST
58098: LIST
58099: ST_TO_ADDR
// if not x or not y then
58100: LD_VAR 0 2
58104: NOT
58105: PUSH
58106: LD_VAR 0 3
58110: NOT
58111: OR
58112: IFFALSE 58116
// exit ;
58114: GO 59766
// if not range then
58116: LD_VAR 0 4
58120: NOT
58121: IFFALSE 58131
// range := 10 ;
58123: LD_ADDR_VAR 0 4
58127: PUSH
58128: LD_INT 10
58130: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58131: LD_ADDR_VAR 0 8
58135: PUSH
58136: LD_INT 81
58138: PUSH
58139: LD_VAR 0 1
58143: PUSH
58144: EMPTY
58145: LIST
58146: LIST
58147: PUSH
58148: LD_INT 92
58150: PUSH
58151: LD_VAR 0 2
58155: PUSH
58156: LD_VAR 0 3
58160: PUSH
58161: LD_VAR 0 4
58165: PUSH
58166: EMPTY
58167: LIST
58168: LIST
58169: LIST
58170: LIST
58171: PUSH
58172: LD_INT 3
58174: PUSH
58175: LD_INT 21
58177: PUSH
58178: LD_INT 3
58180: PUSH
58181: EMPTY
58182: LIST
58183: LIST
58184: PUSH
58185: EMPTY
58186: LIST
58187: LIST
58188: PUSH
58189: EMPTY
58190: LIST
58191: LIST
58192: LIST
58193: PPUSH
58194: CALL_OW 69
58198: ST_TO_ADDR
// if not tmp then
58199: LD_VAR 0 8
58203: NOT
58204: IFFALSE 58208
// exit ;
58206: GO 59766
// for i in tmp do
58208: LD_ADDR_VAR 0 6
58212: PUSH
58213: LD_VAR 0 8
58217: PUSH
58218: FOR_IN
58219: IFFALSE 59741
// begin points := [ 0 , 0 , 0 ] ;
58221: LD_ADDR_VAR 0 9
58225: PUSH
58226: LD_INT 0
58228: PUSH
58229: LD_INT 0
58231: PUSH
58232: LD_INT 0
58234: PUSH
58235: EMPTY
58236: LIST
58237: LIST
58238: LIST
58239: ST_TO_ADDR
// bpoints := 1 ;
58240: LD_ADDR_VAR 0 10
58244: PUSH
58245: LD_INT 1
58247: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58248: LD_VAR 0 6
58252: PPUSH
58253: CALL_OW 247
58257: PUSH
58258: LD_INT 1
58260: DOUBLE
58261: EQUAL
58262: IFTRUE 58266
58264: GO 58844
58266: POP
// begin if GetClass ( i ) = 1 then
58267: LD_VAR 0 6
58271: PPUSH
58272: CALL_OW 257
58276: PUSH
58277: LD_INT 1
58279: EQUAL
58280: IFFALSE 58301
// points := [ 10 , 5 , 3 ] ;
58282: LD_ADDR_VAR 0 9
58286: PUSH
58287: LD_INT 10
58289: PUSH
58290: LD_INT 5
58292: PUSH
58293: LD_INT 3
58295: PUSH
58296: EMPTY
58297: LIST
58298: LIST
58299: LIST
58300: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58301: LD_VAR 0 6
58305: PPUSH
58306: CALL_OW 257
58310: PUSH
58311: LD_INT 2
58313: PUSH
58314: LD_INT 3
58316: PUSH
58317: LD_INT 4
58319: PUSH
58320: EMPTY
58321: LIST
58322: LIST
58323: LIST
58324: IN
58325: IFFALSE 58346
// points := [ 3 , 2 , 1 ] ;
58327: LD_ADDR_VAR 0 9
58331: PUSH
58332: LD_INT 3
58334: PUSH
58335: LD_INT 2
58337: PUSH
58338: LD_INT 1
58340: PUSH
58341: EMPTY
58342: LIST
58343: LIST
58344: LIST
58345: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58346: LD_VAR 0 6
58350: PPUSH
58351: CALL_OW 257
58355: PUSH
58356: LD_INT 5
58358: EQUAL
58359: IFFALSE 58380
// points := [ 130 , 5 , 2 ] ;
58361: LD_ADDR_VAR 0 9
58365: PUSH
58366: LD_INT 130
58368: PUSH
58369: LD_INT 5
58371: PUSH
58372: LD_INT 2
58374: PUSH
58375: EMPTY
58376: LIST
58377: LIST
58378: LIST
58379: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58380: LD_VAR 0 6
58384: PPUSH
58385: CALL_OW 257
58389: PUSH
58390: LD_INT 8
58392: EQUAL
58393: IFFALSE 58414
// points := [ 35 , 35 , 30 ] ;
58395: LD_ADDR_VAR 0 9
58399: PUSH
58400: LD_INT 35
58402: PUSH
58403: LD_INT 35
58405: PUSH
58406: LD_INT 30
58408: PUSH
58409: EMPTY
58410: LIST
58411: LIST
58412: LIST
58413: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58414: LD_VAR 0 6
58418: PPUSH
58419: CALL_OW 257
58423: PUSH
58424: LD_INT 9
58426: EQUAL
58427: IFFALSE 58448
// points := [ 20 , 55 , 40 ] ;
58429: LD_ADDR_VAR 0 9
58433: PUSH
58434: LD_INT 20
58436: PUSH
58437: LD_INT 55
58439: PUSH
58440: LD_INT 40
58442: PUSH
58443: EMPTY
58444: LIST
58445: LIST
58446: LIST
58447: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58448: LD_VAR 0 6
58452: PPUSH
58453: CALL_OW 257
58457: PUSH
58458: LD_INT 12
58460: PUSH
58461: LD_INT 16
58463: PUSH
58464: EMPTY
58465: LIST
58466: LIST
58467: IN
58468: IFFALSE 58489
// points := [ 5 , 3 , 2 ] ;
58470: LD_ADDR_VAR 0 9
58474: PUSH
58475: LD_INT 5
58477: PUSH
58478: LD_INT 3
58480: PUSH
58481: LD_INT 2
58483: PUSH
58484: EMPTY
58485: LIST
58486: LIST
58487: LIST
58488: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58489: LD_VAR 0 6
58493: PPUSH
58494: CALL_OW 257
58498: PUSH
58499: LD_INT 17
58501: EQUAL
58502: IFFALSE 58523
// points := [ 100 , 50 , 75 ] ;
58504: LD_ADDR_VAR 0 9
58508: PUSH
58509: LD_INT 100
58511: PUSH
58512: LD_INT 50
58514: PUSH
58515: LD_INT 75
58517: PUSH
58518: EMPTY
58519: LIST
58520: LIST
58521: LIST
58522: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58523: LD_VAR 0 6
58527: PPUSH
58528: CALL_OW 257
58532: PUSH
58533: LD_INT 15
58535: EQUAL
58536: IFFALSE 58557
// points := [ 10 , 5 , 3 ] ;
58538: LD_ADDR_VAR 0 9
58542: PUSH
58543: LD_INT 10
58545: PUSH
58546: LD_INT 5
58548: PUSH
58549: LD_INT 3
58551: PUSH
58552: EMPTY
58553: LIST
58554: LIST
58555: LIST
58556: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58557: LD_VAR 0 6
58561: PPUSH
58562: CALL_OW 257
58566: PUSH
58567: LD_INT 14
58569: EQUAL
58570: IFFALSE 58591
// points := [ 10 , 0 , 0 ] ;
58572: LD_ADDR_VAR 0 9
58576: PUSH
58577: LD_INT 10
58579: PUSH
58580: LD_INT 0
58582: PUSH
58583: LD_INT 0
58585: PUSH
58586: EMPTY
58587: LIST
58588: LIST
58589: LIST
58590: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58591: LD_VAR 0 6
58595: PPUSH
58596: CALL_OW 257
58600: PUSH
58601: LD_INT 11
58603: EQUAL
58604: IFFALSE 58625
// points := [ 30 , 10 , 5 ] ;
58606: LD_ADDR_VAR 0 9
58610: PUSH
58611: LD_INT 30
58613: PUSH
58614: LD_INT 10
58616: PUSH
58617: LD_INT 5
58619: PUSH
58620: EMPTY
58621: LIST
58622: LIST
58623: LIST
58624: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58625: LD_VAR 0 1
58629: PPUSH
58630: LD_INT 5
58632: PPUSH
58633: CALL_OW 321
58637: PUSH
58638: LD_INT 2
58640: EQUAL
58641: IFFALSE 58658
// bpoints := bpoints * 1.8 ;
58643: LD_ADDR_VAR 0 10
58647: PUSH
58648: LD_VAR 0 10
58652: PUSH
58653: LD_REAL  1.80000000000000E+0000
58656: MUL
58657: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58658: LD_VAR 0 6
58662: PPUSH
58663: CALL_OW 257
58667: PUSH
58668: LD_INT 1
58670: PUSH
58671: LD_INT 2
58673: PUSH
58674: LD_INT 3
58676: PUSH
58677: LD_INT 4
58679: PUSH
58680: EMPTY
58681: LIST
58682: LIST
58683: LIST
58684: LIST
58685: IN
58686: PUSH
58687: LD_VAR 0 1
58691: PPUSH
58692: LD_INT 51
58694: PPUSH
58695: CALL_OW 321
58699: PUSH
58700: LD_INT 2
58702: EQUAL
58703: AND
58704: IFFALSE 58721
// bpoints := bpoints * 1.2 ;
58706: LD_ADDR_VAR 0 10
58710: PUSH
58711: LD_VAR 0 10
58715: PUSH
58716: LD_REAL  1.20000000000000E+0000
58719: MUL
58720: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58721: LD_VAR 0 6
58725: PPUSH
58726: CALL_OW 257
58730: PUSH
58731: LD_INT 5
58733: PUSH
58734: LD_INT 7
58736: PUSH
58737: LD_INT 9
58739: PUSH
58740: EMPTY
58741: LIST
58742: LIST
58743: LIST
58744: IN
58745: PUSH
58746: LD_VAR 0 1
58750: PPUSH
58751: LD_INT 52
58753: PPUSH
58754: CALL_OW 321
58758: PUSH
58759: LD_INT 2
58761: EQUAL
58762: AND
58763: IFFALSE 58780
// bpoints := bpoints * 1.5 ;
58765: LD_ADDR_VAR 0 10
58769: PUSH
58770: LD_VAR 0 10
58774: PUSH
58775: LD_REAL  1.50000000000000E+0000
58778: MUL
58779: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58780: LD_VAR 0 1
58784: PPUSH
58785: LD_INT 66
58787: PPUSH
58788: CALL_OW 321
58792: PUSH
58793: LD_INT 2
58795: EQUAL
58796: IFFALSE 58813
// bpoints := bpoints * 1.1 ;
58798: LD_ADDR_VAR 0 10
58802: PUSH
58803: LD_VAR 0 10
58807: PUSH
58808: LD_REAL  1.10000000000000E+0000
58811: MUL
58812: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58813: LD_ADDR_VAR 0 10
58817: PUSH
58818: LD_VAR 0 10
58822: PUSH
58823: LD_VAR 0 6
58827: PPUSH
58828: LD_INT 1
58830: PPUSH
58831: CALL_OW 259
58835: PUSH
58836: LD_REAL  1.15000000000000E+0000
58839: MUL
58840: MUL
58841: ST_TO_ADDR
// end ; unit_vehicle :
58842: GO 59670
58844: LD_INT 2
58846: DOUBLE
58847: EQUAL
58848: IFTRUE 58852
58850: GO 59658
58852: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58853: LD_VAR 0 6
58857: PPUSH
58858: CALL_OW 264
58862: PUSH
58863: LD_INT 2
58865: PUSH
58866: LD_INT 42
58868: PUSH
58869: LD_INT 24
58871: PUSH
58872: EMPTY
58873: LIST
58874: LIST
58875: LIST
58876: IN
58877: IFFALSE 58898
// points := [ 25 , 5 , 3 ] ;
58879: LD_ADDR_VAR 0 9
58883: PUSH
58884: LD_INT 25
58886: PUSH
58887: LD_INT 5
58889: PUSH
58890: LD_INT 3
58892: PUSH
58893: EMPTY
58894: LIST
58895: LIST
58896: LIST
58897: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58898: LD_VAR 0 6
58902: PPUSH
58903: CALL_OW 264
58907: PUSH
58908: LD_INT 4
58910: PUSH
58911: LD_INT 43
58913: PUSH
58914: LD_INT 25
58916: PUSH
58917: EMPTY
58918: LIST
58919: LIST
58920: LIST
58921: IN
58922: IFFALSE 58943
// points := [ 40 , 15 , 5 ] ;
58924: LD_ADDR_VAR 0 9
58928: PUSH
58929: LD_INT 40
58931: PUSH
58932: LD_INT 15
58934: PUSH
58935: LD_INT 5
58937: PUSH
58938: EMPTY
58939: LIST
58940: LIST
58941: LIST
58942: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58943: LD_VAR 0 6
58947: PPUSH
58948: CALL_OW 264
58952: PUSH
58953: LD_INT 3
58955: PUSH
58956: LD_INT 23
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: IN
58963: IFFALSE 58984
// points := [ 7 , 25 , 8 ] ;
58965: LD_ADDR_VAR 0 9
58969: PUSH
58970: LD_INT 7
58972: PUSH
58973: LD_INT 25
58975: PUSH
58976: LD_INT 8
58978: PUSH
58979: EMPTY
58980: LIST
58981: LIST
58982: LIST
58983: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58984: LD_VAR 0 6
58988: PPUSH
58989: CALL_OW 264
58993: PUSH
58994: LD_INT 5
58996: PUSH
58997: LD_INT 27
58999: PUSH
59000: LD_INT 44
59002: PUSH
59003: EMPTY
59004: LIST
59005: LIST
59006: LIST
59007: IN
59008: IFFALSE 59029
// points := [ 14 , 50 , 16 ] ;
59010: LD_ADDR_VAR 0 9
59014: PUSH
59015: LD_INT 14
59017: PUSH
59018: LD_INT 50
59020: PUSH
59021: LD_INT 16
59023: PUSH
59024: EMPTY
59025: LIST
59026: LIST
59027: LIST
59028: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59029: LD_VAR 0 6
59033: PPUSH
59034: CALL_OW 264
59038: PUSH
59039: LD_INT 6
59041: PUSH
59042: LD_INT 46
59044: PUSH
59045: EMPTY
59046: LIST
59047: LIST
59048: IN
59049: IFFALSE 59070
// points := [ 32 , 120 , 70 ] ;
59051: LD_ADDR_VAR 0 9
59055: PUSH
59056: LD_INT 32
59058: PUSH
59059: LD_INT 120
59061: PUSH
59062: LD_INT 70
59064: PUSH
59065: EMPTY
59066: LIST
59067: LIST
59068: LIST
59069: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
59070: LD_VAR 0 6
59074: PPUSH
59075: CALL_OW 264
59079: PUSH
59080: LD_INT 7
59082: PUSH
59083: LD_INT 28
59085: PUSH
59086: LD_INT 45
59088: PUSH
59089: LD_INT 92
59091: PUSH
59092: EMPTY
59093: LIST
59094: LIST
59095: LIST
59096: LIST
59097: IN
59098: IFFALSE 59119
// points := [ 35 , 20 , 45 ] ;
59100: LD_ADDR_VAR 0 9
59104: PUSH
59105: LD_INT 35
59107: PUSH
59108: LD_INT 20
59110: PUSH
59111: LD_INT 45
59113: PUSH
59114: EMPTY
59115: LIST
59116: LIST
59117: LIST
59118: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59119: LD_VAR 0 6
59123: PPUSH
59124: CALL_OW 264
59128: PUSH
59129: LD_INT 47
59131: PUSH
59132: EMPTY
59133: LIST
59134: IN
59135: IFFALSE 59156
// points := [ 67 , 45 , 75 ] ;
59137: LD_ADDR_VAR 0 9
59141: PUSH
59142: LD_INT 67
59144: PUSH
59145: LD_INT 45
59147: PUSH
59148: LD_INT 75
59150: PUSH
59151: EMPTY
59152: LIST
59153: LIST
59154: LIST
59155: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59156: LD_VAR 0 6
59160: PPUSH
59161: CALL_OW 264
59165: PUSH
59166: LD_INT 26
59168: PUSH
59169: EMPTY
59170: LIST
59171: IN
59172: IFFALSE 59193
// points := [ 120 , 30 , 80 ] ;
59174: LD_ADDR_VAR 0 9
59178: PUSH
59179: LD_INT 120
59181: PUSH
59182: LD_INT 30
59184: PUSH
59185: LD_INT 80
59187: PUSH
59188: EMPTY
59189: LIST
59190: LIST
59191: LIST
59192: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59193: LD_VAR 0 6
59197: PPUSH
59198: CALL_OW 264
59202: PUSH
59203: LD_INT 22
59205: PUSH
59206: EMPTY
59207: LIST
59208: IN
59209: IFFALSE 59230
// points := [ 40 , 1 , 1 ] ;
59211: LD_ADDR_VAR 0 9
59215: PUSH
59216: LD_INT 40
59218: PUSH
59219: LD_INT 1
59221: PUSH
59222: LD_INT 1
59224: PUSH
59225: EMPTY
59226: LIST
59227: LIST
59228: LIST
59229: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59230: LD_VAR 0 6
59234: PPUSH
59235: CALL_OW 264
59239: PUSH
59240: LD_INT 29
59242: PUSH
59243: EMPTY
59244: LIST
59245: IN
59246: IFFALSE 59267
// points := [ 70 , 200 , 400 ] ;
59248: LD_ADDR_VAR 0 9
59252: PUSH
59253: LD_INT 70
59255: PUSH
59256: LD_INT 200
59258: PUSH
59259: LD_INT 400
59261: PUSH
59262: EMPTY
59263: LIST
59264: LIST
59265: LIST
59266: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59267: LD_VAR 0 6
59271: PPUSH
59272: CALL_OW 264
59276: PUSH
59277: LD_INT 14
59279: PUSH
59280: LD_INT 53
59282: PUSH
59283: EMPTY
59284: LIST
59285: LIST
59286: IN
59287: IFFALSE 59308
// points := [ 40 , 10 , 20 ] ;
59289: LD_ADDR_VAR 0 9
59293: PUSH
59294: LD_INT 40
59296: PUSH
59297: LD_INT 10
59299: PUSH
59300: LD_INT 20
59302: PUSH
59303: EMPTY
59304: LIST
59305: LIST
59306: LIST
59307: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59308: LD_VAR 0 6
59312: PPUSH
59313: CALL_OW 264
59317: PUSH
59318: LD_INT 9
59320: PUSH
59321: EMPTY
59322: LIST
59323: IN
59324: IFFALSE 59345
// points := [ 5 , 70 , 20 ] ;
59326: LD_ADDR_VAR 0 9
59330: PUSH
59331: LD_INT 5
59333: PUSH
59334: LD_INT 70
59336: PUSH
59337: LD_INT 20
59339: PUSH
59340: EMPTY
59341: LIST
59342: LIST
59343: LIST
59344: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59345: LD_VAR 0 6
59349: PPUSH
59350: CALL_OW 264
59354: PUSH
59355: LD_INT 10
59357: PUSH
59358: EMPTY
59359: LIST
59360: IN
59361: IFFALSE 59382
// points := [ 35 , 110 , 70 ] ;
59363: LD_ADDR_VAR 0 9
59367: PUSH
59368: LD_INT 35
59370: PUSH
59371: LD_INT 110
59373: PUSH
59374: LD_INT 70
59376: PUSH
59377: EMPTY
59378: LIST
59379: LIST
59380: LIST
59381: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59382: LD_VAR 0 6
59386: PPUSH
59387: CALL_OW 265
59391: PUSH
59392: LD_INT 25
59394: EQUAL
59395: IFFALSE 59416
// points := [ 80 , 65 , 100 ] ;
59397: LD_ADDR_VAR 0 9
59401: PUSH
59402: LD_INT 80
59404: PUSH
59405: LD_INT 65
59407: PUSH
59408: LD_INT 100
59410: PUSH
59411: EMPTY
59412: LIST
59413: LIST
59414: LIST
59415: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59416: LD_VAR 0 6
59420: PPUSH
59421: CALL_OW 263
59425: PUSH
59426: LD_INT 1
59428: EQUAL
59429: IFFALSE 59464
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59431: LD_ADDR_VAR 0 10
59435: PUSH
59436: LD_VAR 0 10
59440: PUSH
59441: LD_VAR 0 6
59445: PPUSH
59446: CALL_OW 311
59450: PPUSH
59451: LD_INT 3
59453: PPUSH
59454: CALL_OW 259
59458: PUSH
59459: LD_INT 4
59461: MUL
59462: MUL
59463: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59464: LD_VAR 0 6
59468: PPUSH
59469: CALL_OW 263
59473: PUSH
59474: LD_INT 2
59476: EQUAL
59477: IFFALSE 59528
// begin j := IsControledBy ( i ) ;
59479: LD_ADDR_VAR 0 7
59483: PUSH
59484: LD_VAR 0 6
59488: PPUSH
59489: CALL_OW 312
59493: ST_TO_ADDR
// if j then
59494: LD_VAR 0 7
59498: IFFALSE 59528
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59500: LD_ADDR_VAR 0 10
59504: PUSH
59505: LD_VAR 0 10
59509: PUSH
59510: LD_VAR 0 7
59514: PPUSH
59515: LD_INT 3
59517: PPUSH
59518: CALL_OW 259
59522: PUSH
59523: LD_INT 3
59525: MUL
59526: MUL
59527: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59528: LD_VAR 0 6
59532: PPUSH
59533: CALL_OW 264
59537: PUSH
59538: LD_INT 5
59540: PUSH
59541: LD_INT 6
59543: PUSH
59544: LD_INT 46
59546: PUSH
59547: LD_INT 44
59549: PUSH
59550: LD_INT 47
59552: PUSH
59553: LD_INT 45
59555: PUSH
59556: LD_INT 28
59558: PUSH
59559: LD_INT 7
59561: PUSH
59562: LD_INT 27
59564: PUSH
59565: LD_INT 29
59567: PUSH
59568: EMPTY
59569: LIST
59570: LIST
59571: LIST
59572: LIST
59573: LIST
59574: LIST
59575: LIST
59576: LIST
59577: LIST
59578: LIST
59579: IN
59580: PUSH
59581: LD_VAR 0 1
59585: PPUSH
59586: LD_INT 52
59588: PPUSH
59589: CALL_OW 321
59593: PUSH
59594: LD_INT 2
59596: EQUAL
59597: AND
59598: IFFALSE 59615
// bpoints := bpoints * 1.2 ;
59600: LD_ADDR_VAR 0 10
59604: PUSH
59605: LD_VAR 0 10
59609: PUSH
59610: LD_REAL  1.20000000000000E+0000
59613: MUL
59614: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59615: LD_VAR 0 6
59619: PPUSH
59620: CALL_OW 264
59624: PUSH
59625: LD_INT 6
59627: PUSH
59628: LD_INT 46
59630: PUSH
59631: LD_INT 47
59633: PUSH
59634: EMPTY
59635: LIST
59636: LIST
59637: LIST
59638: IN
59639: IFFALSE 59656
// bpoints := bpoints * 1.2 ;
59641: LD_ADDR_VAR 0 10
59645: PUSH
59646: LD_VAR 0 10
59650: PUSH
59651: LD_REAL  1.20000000000000E+0000
59654: MUL
59655: ST_TO_ADDR
// end ; unit_building :
59656: GO 59670
59658: LD_INT 3
59660: DOUBLE
59661: EQUAL
59662: IFTRUE 59666
59664: GO 59669
59666: POP
// ; end ;
59667: GO 59670
59669: POP
// for j = 1 to 3 do
59670: LD_ADDR_VAR 0 7
59674: PUSH
59675: DOUBLE
59676: LD_INT 1
59678: DEC
59679: ST_TO_ADDR
59680: LD_INT 3
59682: PUSH
59683: FOR_TO
59684: IFFALSE 59737
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59686: LD_ADDR_VAR 0 5
59690: PUSH
59691: LD_VAR 0 5
59695: PPUSH
59696: LD_VAR 0 7
59700: PPUSH
59701: LD_VAR 0 5
59705: PUSH
59706: LD_VAR 0 7
59710: ARRAY
59711: PUSH
59712: LD_VAR 0 9
59716: PUSH
59717: LD_VAR 0 7
59721: ARRAY
59722: PUSH
59723: LD_VAR 0 10
59727: MUL
59728: PLUS
59729: PPUSH
59730: CALL_OW 1
59734: ST_TO_ADDR
59735: GO 59683
59737: POP
59738: POP
// end ;
59739: GO 58218
59741: POP
59742: POP
// result := Replace ( result , 4 , tmp ) ;
59743: LD_ADDR_VAR 0 5
59747: PUSH
59748: LD_VAR 0 5
59752: PPUSH
59753: LD_INT 4
59755: PPUSH
59756: LD_VAR 0 8
59760: PPUSH
59761: CALL_OW 1
59765: ST_TO_ADDR
// end ;
59766: LD_VAR 0 5
59770: RET
// export function DangerAtRange ( unit , range ) ; begin
59771: LD_INT 0
59773: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59774: LD_ADDR_VAR 0 3
59778: PUSH
59779: LD_VAR 0 1
59783: PPUSH
59784: CALL_OW 255
59788: PPUSH
59789: LD_VAR 0 1
59793: PPUSH
59794: CALL_OW 250
59798: PPUSH
59799: LD_VAR 0 1
59803: PPUSH
59804: CALL_OW 251
59808: PPUSH
59809: LD_VAR 0 2
59813: PPUSH
59814: CALL 58070 0 4
59818: ST_TO_ADDR
// end ;
59819: LD_VAR 0 3
59823: RET
// export function DangerInArea ( side , area ) ; begin
59824: LD_INT 0
59826: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59827: LD_ADDR_VAR 0 3
59831: PUSH
59832: LD_VAR 0 2
59836: PPUSH
59837: LD_INT 81
59839: PUSH
59840: LD_VAR 0 1
59844: PUSH
59845: EMPTY
59846: LIST
59847: LIST
59848: PPUSH
59849: CALL_OW 70
59853: ST_TO_ADDR
// end ;
59854: LD_VAR 0 3
59858: RET
// export function IsExtension ( b ) ; begin
59859: LD_INT 0
59861: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59862: LD_ADDR_VAR 0 2
59866: PUSH
59867: LD_VAR 0 1
59871: PUSH
59872: LD_INT 23
59874: PUSH
59875: LD_INT 20
59877: PUSH
59878: LD_INT 22
59880: PUSH
59881: LD_INT 17
59883: PUSH
59884: LD_INT 24
59886: PUSH
59887: LD_INT 21
59889: PUSH
59890: LD_INT 19
59892: PUSH
59893: LD_INT 16
59895: PUSH
59896: LD_INT 25
59898: PUSH
59899: LD_INT 18
59901: PUSH
59902: EMPTY
59903: LIST
59904: LIST
59905: LIST
59906: LIST
59907: LIST
59908: LIST
59909: LIST
59910: LIST
59911: LIST
59912: LIST
59913: IN
59914: ST_TO_ADDR
// end ;
59915: LD_VAR 0 2
59919: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59920: LD_INT 0
59922: PPUSH
59923: PPUSH
59924: PPUSH
// result := [ ] ;
59925: LD_ADDR_VAR 0 4
59929: PUSH
59930: EMPTY
59931: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59932: LD_ADDR_VAR 0 5
59936: PUSH
59937: LD_VAR 0 2
59941: PPUSH
59942: LD_INT 21
59944: PUSH
59945: LD_INT 3
59947: PUSH
59948: EMPTY
59949: LIST
59950: LIST
59951: PPUSH
59952: CALL_OW 70
59956: ST_TO_ADDR
// if not tmp then
59957: LD_VAR 0 5
59961: NOT
59962: IFFALSE 59966
// exit ;
59964: GO 60030
// if checkLink then
59966: LD_VAR 0 3
59970: IFFALSE 60020
// begin for i in tmp do
59972: LD_ADDR_VAR 0 6
59976: PUSH
59977: LD_VAR 0 5
59981: PUSH
59982: FOR_IN
59983: IFFALSE 60018
// if GetBase ( i ) <> base then
59985: LD_VAR 0 6
59989: PPUSH
59990: CALL_OW 274
59994: PUSH
59995: LD_VAR 0 1
59999: NONEQUAL
60000: IFFALSE 60016
// ComLinkToBase ( base , i ) ;
60002: LD_VAR 0 1
60006: PPUSH
60007: LD_VAR 0 6
60011: PPUSH
60012: CALL_OW 169
60016: GO 59982
60018: POP
60019: POP
// end ; result := tmp ;
60020: LD_ADDR_VAR 0 4
60024: PUSH
60025: LD_VAR 0 5
60029: ST_TO_ADDR
// end ;
60030: LD_VAR 0 4
60034: RET
// export function ComComplete ( units , b ) ; var i ; begin
60035: LD_INT 0
60037: PPUSH
60038: PPUSH
// if not units then
60039: LD_VAR 0 1
60043: NOT
60044: IFFALSE 60048
// exit ;
60046: GO 60138
// for i in units do
60048: LD_ADDR_VAR 0 4
60052: PUSH
60053: LD_VAR 0 1
60057: PUSH
60058: FOR_IN
60059: IFFALSE 60136
// if BuildingStatus ( b ) = bs_build then
60061: LD_VAR 0 2
60065: PPUSH
60066: CALL_OW 461
60070: PUSH
60071: LD_INT 1
60073: EQUAL
60074: IFFALSE 60134
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60076: LD_VAR 0 4
60080: PPUSH
60081: LD_STRING h
60083: PUSH
60084: LD_VAR 0 2
60088: PPUSH
60089: CALL_OW 250
60093: PUSH
60094: LD_VAR 0 2
60098: PPUSH
60099: CALL_OW 251
60103: PUSH
60104: LD_VAR 0 2
60108: PUSH
60109: LD_INT 0
60111: PUSH
60112: LD_INT 0
60114: PUSH
60115: LD_INT 0
60117: PUSH
60118: EMPTY
60119: LIST
60120: LIST
60121: LIST
60122: LIST
60123: LIST
60124: LIST
60125: LIST
60126: PUSH
60127: EMPTY
60128: LIST
60129: PPUSH
60130: CALL_OW 446
60134: GO 60058
60136: POP
60137: POP
// end ;
60138: LD_VAR 0 3
60142: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60143: LD_INT 0
60145: PPUSH
60146: PPUSH
60147: PPUSH
60148: PPUSH
60149: PPUSH
60150: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
60151: LD_VAR 0 1
60155: NOT
60156: PUSH
60157: LD_VAR 0 1
60161: PPUSH
60162: CALL_OW 263
60166: PUSH
60167: LD_INT 2
60169: NONEQUAL
60170: OR
60171: IFFALSE 60175
// exit ;
60173: GO 60491
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60175: LD_ADDR_VAR 0 6
60179: PUSH
60180: LD_INT 22
60182: PUSH
60183: LD_VAR 0 1
60187: PPUSH
60188: CALL_OW 255
60192: PUSH
60193: EMPTY
60194: LIST
60195: LIST
60196: PUSH
60197: LD_INT 2
60199: PUSH
60200: LD_INT 30
60202: PUSH
60203: LD_INT 36
60205: PUSH
60206: EMPTY
60207: LIST
60208: LIST
60209: PUSH
60210: LD_INT 34
60212: PUSH
60213: LD_INT 31
60215: PUSH
60216: EMPTY
60217: LIST
60218: LIST
60219: PUSH
60220: EMPTY
60221: LIST
60222: LIST
60223: LIST
60224: PUSH
60225: EMPTY
60226: LIST
60227: LIST
60228: PPUSH
60229: CALL_OW 69
60233: ST_TO_ADDR
// if not tmp then
60234: LD_VAR 0 6
60238: NOT
60239: IFFALSE 60243
// exit ;
60241: GO 60491
// result := [ ] ;
60243: LD_ADDR_VAR 0 2
60247: PUSH
60248: EMPTY
60249: ST_TO_ADDR
// for i in tmp do
60250: LD_ADDR_VAR 0 3
60254: PUSH
60255: LD_VAR 0 6
60259: PUSH
60260: FOR_IN
60261: IFFALSE 60332
// begin t := UnitsInside ( i ) ;
60263: LD_ADDR_VAR 0 4
60267: PUSH
60268: LD_VAR 0 3
60272: PPUSH
60273: CALL_OW 313
60277: ST_TO_ADDR
// if t then
60278: LD_VAR 0 4
60282: IFFALSE 60330
// for j in t do
60284: LD_ADDR_VAR 0 7
60288: PUSH
60289: LD_VAR 0 4
60293: PUSH
60294: FOR_IN
60295: IFFALSE 60328
// result := Replace ( result , result + 1 , j ) ;
60297: LD_ADDR_VAR 0 2
60301: PUSH
60302: LD_VAR 0 2
60306: PPUSH
60307: LD_VAR 0 2
60311: PUSH
60312: LD_INT 1
60314: PLUS
60315: PPUSH
60316: LD_VAR 0 7
60320: PPUSH
60321: CALL_OW 1
60325: ST_TO_ADDR
60326: GO 60294
60328: POP
60329: POP
// end ;
60330: GO 60260
60332: POP
60333: POP
// if not result then
60334: LD_VAR 0 2
60338: NOT
60339: IFFALSE 60343
// exit ;
60341: GO 60491
// mech := result [ 1 ] ;
60343: LD_ADDR_VAR 0 5
60347: PUSH
60348: LD_VAR 0 2
60352: PUSH
60353: LD_INT 1
60355: ARRAY
60356: ST_TO_ADDR
// if result > 1 then
60357: LD_VAR 0 2
60361: PUSH
60362: LD_INT 1
60364: GREATER
60365: IFFALSE 60477
// begin for i = 2 to result do
60367: LD_ADDR_VAR 0 3
60371: PUSH
60372: DOUBLE
60373: LD_INT 2
60375: DEC
60376: ST_TO_ADDR
60377: LD_VAR 0 2
60381: PUSH
60382: FOR_TO
60383: IFFALSE 60475
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60385: LD_ADDR_VAR 0 4
60389: PUSH
60390: LD_VAR 0 2
60394: PUSH
60395: LD_VAR 0 3
60399: ARRAY
60400: PPUSH
60401: LD_INT 3
60403: PPUSH
60404: CALL_OW 259
60408: PUSH
60409: LD_VAR 0 2
60413: PUSH
60414: LD_VAR 0 3
60418: ARRAY
60419: PPUSH
60420: CALL_OW 432
60424: MINUS
60425: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60426: LD_VAR 0 4
60430: PUSH
60431: LD_VAR 0 5
60435: PPUSH
60436: LD_INT 3
60438: PPUSH
60439: CALL_OW 259
60443: PUSH
60444: LD_VAR 0 5
60448: PPUSH
60449: CALL_OW 432
60453: MINUS
60454: GREATEREQUAL
60455: IFFALSE 60473
// mech := result [ i ] ;
60457: LD_ADDR_VAR 0 5
60461: PUSH
60462: LD_VAR 0 2
60466: PUSH
60467: LD_VAR 0 3
60471: ARRAY
60472: ST_TO_ADDR
// end ;
60473: GO 60382
60475: POP
60476: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60477: LD_VAR 0 1
60481: PPUSH
60482: LD_VAR 0 5
60486: PPUSH
60487: CALL_OW 135
// end ;
60491: LD_VAR 0 2
60495: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60496: LD_INT 0
60498: PPUSH
60499: PPUSH
60500: PPUSH
60501: PPUSH
60502: PPUSH
60503: PPUSH
60504: PPUSH
60505: PPUSH
60506: PPUSH
60507: PPUSH
60508: PPUSH
60509: PPUSH
60510: PPUSH
// result := [ ] ;
60511: LD_ADDR_VAR 0 7
60515: PUSH
60516: EMPTY
60517: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60518: LD_VAR 0 1
60522: PPUSH
60523: CALL_OW 266
60527: PUSH
60528: LD_INT 0
60530: PUSH
60531: LD_INT 1
60533: PUSH
60534: EMPTY
60535: LIST
60536: LIST
60537: IN
60538: NOT
60539: IFFALSE 60543
// exit ;
60541: GO 62177
// if name then
60543: LD_VAR 0 3
60547: IFFALSE 60563
// SetBName ( base_dep , name ) ;
60549: LD_VAR 0 1
60553: PPUSH
60554: LD_VAR 0 3
60558: PPUSH
60559: CALL_OW 500
// base := GetBase ( base_dep ) ;
60563: LD_ADDR_VAR 0 15
60567: PUSH
60568: LD_VAR 0 1
60572: PPUSH
60573: CALL_OW 274
60577: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60578: LD_ADDR_VAR 0 16
60582: PUSH
60583: LD_VAR 0 1
60587: PPUSH
60588: CALL_OW 255
60592: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60593: LD_ADDR_VAR 0 17
60597: PUSH
60598: LD_VAR 0 1
60602: PPUSH
60603: CALL_OW 248
60607: ST_TO_ADDR
// if sources then
60608: LD_VAR 0 5
60612: IFFALSE 60659
// for i = 1 to 3 do
60614: LD_ADDR_VAR 0 8
60618: PUSH
60619: DOUBLE
60620: LD_INT 1
60622: DEC
60623: ST_TO_ADDR
60624: LD_INT 3
60626: PUSH
60627: FOR_TO
60628: IFFALSE 60657
// AddResourceType ( base , i , sources [ i ] ) ;
60630: LD_VAR 0 15
60634: PPUSH
60635: LD_VAR 0 8
60639: PPUSH
60640: LD_VAR 0 5
60644: PUSH
60645: LD_VAR 0 8
60649: ARRAY
60650: PPUSH
60651: CALL_OW 276
60655: GO 60627
60657: POP
60658: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60659: LD_ADDR_VAR 0 18
60663: PUSH
60664: LD_VAR 0 15
60668: PPUSH
60669: LD_VAR 0 2
60673: PPUSH
60674: LD_INT 1
60676: PPUSH
60677: CALL 59920 0 3
60681: ST_TO_ADDR
// InitHc ;
60682: CALL_OW 19
// InitUc ;
60686: CALL_OW 18
// uc_side := side ;
60690: LD_ADDR_OWVAR 20
60694: PUSH
60695: LD_VAR 0 16
60699: ST_TO_ADDR
// uc_nation := nation ;
60700: LD_ADDR_OWVAR 21
60704: PUSH
60705: LD_VAR 0 17
60709: ST_TO_ADDR
// if buildings then
60710: LD_VAR 0 18
60714: IFFALSE 62036
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60716: LD_ADDR_VAR 0 19
60720: PUSH
60721: LD_VAR 0 18
60725: PPUSH
60726: LD_INT 2
60728: PUSH
60729: LD_INT 30
60731: PUSH
60732: LD_INT 29
60734: PUSH
60735: EMPTY
60736: LIST
60737: LIST
60738: PUSH
60739: LD_INT 30
60741: PUSH
60742: LD_INT 30
60744: PUSH
60745: EMPTY
60746: LIST
60747: LIST
60748: PUSH
60749: EMPTY
60750: LIST
60751: LIST
60752: LIST
60753: PPUSH
60754: CALL_OW 72
60758: ST_TO_ADDR
// if tmp then
60759: LD_VAR 0 19
60763: IFFALSE 60811
// for i in tmp do
60765: LD_ADDR_VAR 0 8
60769: PUSH
60770: LD_VAR 0 19
60774: PUSH
60775: FOR_IN
60776: IFFALSE 60809
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60778: LD_VAR 0 8
60782: PPUSH
60783: CALL_OW 250
60787: PPUSH
60788: LD_VAR 0 8
60792: PPUSH
60793: CALL_OW 251
60797: PPUSH
60798: LD_VAR 0 16
60802: PPUSH
60803: CALL_OW 441
60807: GO 60775
60809: POP
60810: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60811: LD_VAR 0 18
60815: PPUSH
60816: LD_INT 2
60818: PUSH
60819: LD_INT 30
60821: PUSH
60822: LD_INT 32
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PUSH
60829: LD_INT 30
60831: PUSH
60832: LD_INT 33
60834: PUSH
60835: EMPTY
60836: LIST
60837: LIST
60838: PUSH
60839: EMPTY
60840: LIST
60841: LIST
60842: LIST
60843: PPUSH
60844: CALL_OW 72
60848: IFFALSE 60936
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60850: LD_ADDR_VAR 0 8
60854: PUSH
60855: LD_VAR 0 18
60859: PPUSH
60860: LD_INT 2
60862: PUSH
60863: LD_INT 30
60865: PUSH
60866: LD_INT 32
60868: PUSH
60869: EMPTY
60870: LIST
60871: LIST
60872: PUSH
60873: LD_INT 30
60875: PUSH
60876: LD_INT 33
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: PUSH
60883: EMPTY
60884: LIST
60885: LIST
60886: LIST
60887: PPUSH
60888: CALL_OW 72
60892: PUSH
60893: FOR_IN
60894: IFFALSE 60934
// begin if not GetBWeapon ( i ) then
60896: LD_VAR 0 8
60900: PPUSH
60901: CALL_OW 269
60905: NOT
60906: IFFALSE 60932
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60908: LD_VAR 0 8
60912: PPUSH
60913: LD_VAR 0 8
60917: PPUSH
60918: LD_VAR 0 2
60922: PPUSH
60923: CALL 62182 0 2
60927: PPUSH
60928: CALL_OW 431
// end ;
60932: GO 60893
60934: POP
60935: POP
// end ; for i = 1 to personel do
60936: LD_ADDR_VAR 0 8
60940: PUSH
60941: DOUBLE
60942: LD_INT 1
60944: DEC
60945: ST_TO_ADDR
60946: LD_VAR 0 6
60950: PUSH
60951: FOR_TO
60952: IFFALSE 62016
// begin if i > 4 then
60954: LD_VAR 0 8
60958: PUSH
60959: LD_INT 4
60961: GREATER
60962: IFFALSE 60966
// break ;
60964: GO 62016
// case i of 1 :
60966: LD_VAR 0 8
60970: PUSH
60971: LD_INT 1
60973: DOUBLE
60974: EQUAL
60975: IFTRUE 60979
60977: GO 61059
60979: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60980: LD_ADDR_VAR 0 12
60984: PUSH
60985: LD_VAR 0 18
60989: PPUSH
60990: LD_INT 22
60992: PUSH
60993: LD_VAR 0 16
60997: PUSH
60998: EMPTY
60999: LIST
61000: LIST
61001: PUSH
61002: LD_INT 58
61004: PUSH
61005: EMPTY
61006: LIST
61007: PUSH
61008: LD_INT 2
61010: PUSH
61011: LD_INT 30
61013: PUSH
61014: LD_INT 32
61016: PUSH
61017: EMPTY
61018: LIST
61019: LIST
61020: PUSH
61021: LD_INT 30
61023: PUSH
61024: LD_INT 4
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: PUSH
61031: LD_INT 30
61033: PUSH
61034: LD_INT 5
61036: PUSH
61037: EMPTY
61038: LIST
61039: LIST
61040: PUSH
61041: EMPTY
61042: LIST
61043: LIST
61044: LIST
61045: LIST
61046: PUSH
61047: EMPTY
61048: LIST
61049: LIST
61050: LIST
61051: PPUSH
61052: CALL_OW 72
61056: ST_TO_ADDR
61057: GO 61281
61059: LD_INT 2
61061: DOUBLE
61062: EQUAL
61063: IFTRUE 61067
61065: GO 61129
61067: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61068: LD_ADDR_VAR 0 12
61072: PUSH
61073: LD_VAR 0 18
61077: PPUSH
61078: LD_INT 22
61080: PUSH
61081: LD_VAR 0 16
61085: PUSH
61086: EMPTY
61087: LIST
61088: LIST
61089: PUSH
61090: LD_INT 2
61092: PUSH
61093: LD_INT 30
61095: PUSH
61096: LD_INT 0
61098: PUSH
61099: EMPTY
61100: LIST
61101: LIST
61102: PUSH
61103: LD_INT 30
61105: PUSH
61106: LD_INT 1
61108: PUSH
61109: EMPTY
61110: LIST
61111: LIST
61112: PUSH
61113: EMPTY
61114: LIST
61115: LIST
61116: LIST
61117: PUSH
61118: EMPTY
61119: LIST
61120: LIST
61121: PPUSH
61122: CALL_OW 72
61126: ST_TO_ADDR
61127: GO 61281
61129: LD_INT 3
61131: DOUBLE
61132: EQUAL
61133: IFTRUE 61137
61135: GO 61199
61137: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61138: LD_ADDR_VAR 0 12
61142: PUSH
61143: LD_VAR 0 18
61147: PPUSH
61148: LD_INT 22
61150: PUSH
61151: LD_VAR 0 16
61155: PUSH
61156: EMPTY
61157: LIST
61158: LIST
61159: PUSH
61160: LD_INT 2
61162: PUSH
61163: LD_INT 30
61165: PUSH
61166: LD_INT 2
61168: PUSH
61169: EMPTY
61170: LIST
61171: LIST
61172: PUSH
61173: LD_INT 30
61175: PUSH
61176: LD_INT 3
61178: PUSH
61179: EMPTY
61180: LIST
61181: LIST
61182: PUSH
61183: EMPTY
61184: LIST
61185: LIST
61186: LIST
61187: PUSH
61188: EMPTY
61189: LIST
61190: LIST
61191: PPUSH
61192: CALL_OW 72
61196: ST_TO_ADDR
61197: GO 61281
61199: LD_INT 4
61201: DOUBLE
61202: EQUAL
61203: IFTRUE 61207
61205: GO 61280
61207: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61208: LD_ADDR_VAR 0 12
61212: PUSH
61213: LD_VAR 0 18
61217: PPUSH
61218: LD_INT 22
61220: PUSH
61221: LD_VAR 0 16
61225: PUSH
61226: EMPTY
61227: LIST
61228: LIST
61229: PUSH
61230: LD_INT 2
61232: PUSH
61233: LD_INT 30
61235: PUSH
61236: LD_INT 6
61238: PUSH
61239: EMPTY
61240: LIST
61241: LIST
61242: PUSH
61243: LD_INT 30
61245: PUSH
61246: LD_INT 7
61248: PUSH
61249: EMPTY
61250: LIST
61251: LIST
61252: PUSH
61253: LD_INT 30
61255: PUSH
61256: LD_INT 8
61258: PUSH
61259: EMPTY
61260: LIST
61261: LIST
61262: PUSH
61263: EMPTY
61264: LIST
61265: LIST
61266: LIST
61267: LIST
61268: PUSH
61269: EMPTY
61270: LIST
61271: LIST
61272: PPUSH
61273: CALL_OW 72
61277: ST_TO_ADDR
61278: GO 61281
61280: POP
// if i = 1 then
61281: LD_VAR 0 8
61285: PUSH
61286: LD_INT 1
61288: EQUAL
61289: IFFALSE 61400
// begin tmp := [ ] ;
61291: LD_ADDR_VAR 0 19
61295: PUSH
61296: EMPTY
61297: ST_TO_ADDR
// for j in f do
61298: LD_ADDR_VAR 0 9
61302: PUSH
61303: LD_VAR 0 12
61307: PUSH
61308: FOR_IN
61309: IFFALSE 61382
// if GetBType ( j ) = b_bunker then
61311: LD_VAR 0 9
61315: PPUSH
61316: CALL_OW 266
61320: PUSH
61321: LD_INT 32
61323: EQUAL
61324: IFFALSE 61351
// tmp := Insert ( tmp , 1 , j ) else
61326: LD_ADDR_VAR 0 19
61330: PUSH
61331: LD_VAR 0 19
61335: PPUSH
61336: LD_INT 1
61338: PPUSH
61339: LD_VAR 0 9
61343: PPUSH
61344: CALL_OW 2
61348: ST_TO_ADDR
61349: GO 61380
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61351: LD_ADDR_VAR 0 19
61355: PUSH
61356: LD_VAR 0 19
61360: PPUSH
61361: LD_VAR 0 19
61365: PUSH
61366: LD_INT 1
61368: PLUS
61369: PPUSH
61370: LD_VAR 0 9
61374: PPUSH
61375: CALL_OW 2
61379: ST_TO_ADDR
61380: GO 61308
61382: POP
61383: POP
// if tmp then
61384: LD_VAR 0 19
61388: IFFALSE 61400
// f := tmp ;
61390: LD_ADDR_VAR 0 12
61394: PUSH
61395: LD_VAR 0 19
61399: ST_TO_ADDR
// end ; x := personel [ i ] ;
61400: LD_ADDR_VAR 0 13
61404: PUSH
61405: LD_VAR 0 6
61409: PUSH
61410: LD_VAR 0 8
61414: ARRAY
61415: ST_TO_ADDR
// if x = - 1 then
61416: LD_VAR 0 13
61420: PUSH
61421: LD_INT 1
61423: NEG
61424: EQUAL
61425: IFFALSE 61634
// begin for j in f do
61427: LD_ADDR_VAR 0 9
61431: PUSH
61432: LD_VAR 0 12
61436: PUSH
61437: FOR_IN
61438: IFFALSE 61630
// repeat InitHc ;
61440: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61444: LD_VAR 0 9
61448: PPUSH
61449: CALL_OW 266
61453: PUSH
61454: LD_INT 5
61456: EQUAL
61457: IFFALSE 61527
// begin if UnitsInside ( j ) < 3 then
61459: LD_VAR 0 9
61463: PPUSH
61464: CALL_OW 313
61468: PUSH
61469: LD_INT 3
61471: LESS
61472: IFFALSE 61508
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61474: LD_INT 0
61476: PPUSH
61477: LD_INT 5
61479: PUSH
61480: LD_INT 8
61482: PUSH
61483: LD_INT 9
61485: PUSH
61486: EMPTY
61487: LIST
61488: LIST
61489: LIST
61490: PUSH
61491: LD_VAR 0 17
61495: ARRAY
61496: PPUSH
61497: LD_VAR 0 4
61501: PPUSH
61502: CALL_OW 380
61506: GO 61525
// PrepareHuman ( false , i , skill ) ;
61508: LD_INT 0
61510: PPUSH
61511: LD_VAR 0 8
61515: PPUSH
61516: LD_VAR 0 4
61520: PPUSH
61521: CALL_OW 380
// end else
61525: GO 61544
// PrepareHuman ( false , i , skill ) ;
61527: LD_INT 0
61529: PPUSH
61530: LD_VAR 0 8
61534: PPUSH
61535: LD_VAR 0 4
61539: PPUSH
61540: CALL_OW 380
// un := CreateHuman ;
61544: LD_ADDR_VAR 0 14
61548: PUSH
61549: CALL_OW 44
61553: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61554: LD_ADDR_VAR 0 7
61558: PUSH
61559: LD_VAR 0 7
61563: PPUSH
61564: LD_INT 1
61566: PPUSH
61567: LD_VAR 0 14
61571: PPUSH
61572: CALL_OW 2
61576: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61577: LD_VAR 0 14
61581: PPUSH
61582: LD_VAR 0 9
61586: PPUSH
61587: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61591: LD_VAR 0 9
61595: PPUSH
61596: CALL_OW 313
61600: PUSH
61601: LD_INT 6
61603: EQUAL
61604: PUSH
61605: LD_VAR 0 9
61609: PPUSH
61610: CALL_OW 266
61614: PUSH
61615: LD_INT 32
61617: PUSH
61618: LD_INT 31
61620: PUSH
61621: EMPTY
61622: LIST
61623: LIST
61624: IN
61625: OR
61626: IFFALSE 61440
61628: GO 61437
61630: POP
61631: POP
// end else
61632: GO 62014
// for j = 1 to x do
61634: LD_ADDR_VAR 0 9
61638: PUSH
61639: DOUBLE
61640: LD_INT 1
61642: DEC
61643: ST_TO_ADDR
61644: LD_VAR 0 13
61648: PUSH
61649: FOR_TO
61650: IFFALSE 62012
// begin InitHc ;
61652: CALL_OW 19
// if not f then
61656: LD_VAR 0 12
61660: NOT
61661: IFFALSE 61750
// begin PrepareHuman ( false , i , skill ) ;
61663: LD_INT 0
61665: PPUSH
61666: LD_VAR 0 8
61670: PPUSH
61671: LD_VAR 0 4
61675: PPUSH
61676: CALL_OW 380
// un := CreateHuman ;
61680: LD_ADDR_VAR 0 14
61684: PUSH
61685: CALL_OW 44
61689: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61690: LD_ADDR_VAR 0 7
61694: PUSH
61695: LD_VAR 0 7
61699: PPUSH
61700: LD_INT 1
61702: PPUSH
61703: LD_VAR 0 14
61707: PPUSH
61708: CALL_OW 2
61712: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61713: LD_VAR 0 14
61717: PPUSH
61718: LD_VAR 0 1
61722: PPUSH
61723: CALL_OW 250
61727: PPUSH
61728: LD_VAR 0 1
61732: PPUSH
61733: CALL_OW 251
61737: PPUSH
61738: LD_INT 10
61740: PPUSH
61741: LD_INT 0
61743: PPUSH
61744: CALL_OW 50
// continue ;
61748: GO 61649
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61750: LD_VAR 0 12
61754: PUSH
61755: LD_INT 1
61757: ARRAY
61758: PPUSH
61759: CALL_OW 313
61763: PUSH
61764: LD_VAR 0 12
61768: PUSH
61769: LD_INT 1
61771: ARRAY
61772: PPUSH
61773: CALL_OW 266
61777: PUSH
61778: LD_INT 32
61780: PUSH
61781: LD_INT 31
61783: PUSH
61784: EMPTY
61785: LIST
61786: LIST
61787: IN
61788: AND
61789: PUSH
61790: LD_VAR 0 12
61794: PUSH
61795: LD_INT 1
61797: ARRAY
61798: PPUSH
61799: CALL_OW 313
61803: PUSH
61804: LD_INT 6
61806: EQUAL
61807: OR
61808: IFFALSE 61828
// f := Delete ( f , 1 ) ;
61810: LD_ADDR_VAR 0 12
61814: PUSH
61815: LD_VAR 0 12
61819: PPUSH
61820: LD_INT 1
61822: PPUSH
61823: CALL_OW 3
61827: ST_TO_ADDR
// if not f then
61828: LD_VAR 0 12
61832: NOT
61833: IFFALSE 61851
// begin x := x + 2 ;
61835: LD_ADDR_VAR 0 13
61839: PUSH
61840: LD_VAR 0 13
61844: PUSH
61845: LD_INT 2
61847: PLUS
61848: ST_TO_ADDR
// continue ;
61849: GO 61649
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61851: LD_VAR 0 12
61855: PUSH
61856: LD_INT 1
61858: ARRAY
61859: PPUSH
61860: CALL_OW 266
61864: PUSH
61865: LD_INT 5
61867: EQUAL
61868: IFFALSE 61942
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61870: LD_VAR 0 12
61874: PUSH
61875: LD_INT 1
61877: ARRAY
61878: PPUSH
61879: CALL_OW 313
61883: PUSH
61884: LD_INT 3
61886: LESS
61887: IFFALSE 61923
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61889: LD_INT 0
61891: PPUSH
61892: LD_INT 5
61894: PUSH
61895: LD_INT 8
61897: PUSH
61898: LD_INT 9
61900: PUSH
61901: EMPTY
61902: LIST
61903: LIST
61904: LIST
61905: PUSH
61906: LD_VAR 0 17
61910: ARRAY
61911: PPUSH
61912: LD_VAR 0 4
61916: PPUSH
61917: CALL_OW 380
61921: GO 61940
// PrepareHuman ( false , i , skill ) ;
61923: LD_INT 0
61925: PPUSH
61926: LD_VAR 0 8
61930: PPUSH
61931: LD_VAR 0 4
61935: PPUSH
61936: CALL_OW 380
// end else
61940: GO 61959
// PrepareHuman ( false , i , skill ) ;
61942: LD_INT 0
61944: PPUSH
61945: LD_VAR 0 8
61949: PPUSH
61950: LD_VAR 0 4
61954: PPUSH
61955: CALL_OW 380
// un := CreateHuman ;
61959: LD_ADDR_VAR 0 14
61963: PUSH
61964: CALL_OW 44
61968: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61969: LD_ADDR_VAR 0 7
61973: PUSH
61974: LD_VAR 0 7
61978: PPUSH
61979: LD_INT 1
61981: PPUSH
61982: LD_VAR 0 14
61986: PPUSH
61987: CALL_OW 2
61991: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61992: LD_VAR 0 14
61996: PPUSH
61997: LD_VAR 0 12
62001: PUSH
62002: LD_INT 1
62004: ARRAY
62005: PPUSH
62006: CALL_OW 52
// end ;
62010: GO 61649
62012: POP
62013: POP
// end ;
62014: GO 60951
62016: POP
62017: POP
// result := result ^ buildings ;
62018: LD_ADDR_VAR 0 7
62022: PUSH
62023: LD_VAR 0 7
62027: PUSH
62028: LD_VAR 0 18
62032: ADD
62033: ST_TO_ADDR
// end else
62034: GO 62177
// begin for i = 1 to personel do
62036: LD_ADDR_VAR 0 8
62040: PUSH
62041: DOUBLE
62042: LD_INT 1
62044: DEC
62045: ST_TO_ADDR
62046: LD_VAR 0 6
62050: PUSH
62051: FOR_TO
62052: IFFALSE 62175
// begin if i > 4 then
62054: LD_VAR 0 8
62058: PUSH
62059: LD_INT 4
62061: GREATER
62062: IFFALSE 62066
// break ;
62064: GO 62175
// x := personel [ i ] ;
62066: LD_ADDR_VAR 0 13
62070: PUSH
62071: LD_VAR 0 6
62075: PUSH
62076: LD_VAR 0 8
62080: ARRAY
62081: ST_TO_ADDR
// if x = - 1 then
62082: LD_VAR 0 13
62086: PUSH
62087: LD_INT 1
62089: NEG
62090: EQUAL
62091: IFFALSE 62095
// continue ;
62093: GO 62051
// PrepareHuman ( false , i , skill ) ;
62095: LD_INT 0
62097: PPUSH
62098: LD_VAR 0 8
62102: PPUSH
62103: LD_VAR 0 4
62107: PPUSH
62108: CALL_OW 380
// un := CreateHuman ;
62112: LD_ADDR_VAR 0 14
62116: PUSH
62117: CALL_OW 44
62121: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62122: LD_VAR 0 14
62126: PPUSH
62127: LD_VAR 0 1
62131: PPUSH
62132: CALL_OW 250
62136: PPUSH
62137: LD_VAR 0 1
62141: PPUSH
62142: CALL_OW 251
62146: PPUSH
62147: LD_INT 10
62149: PPUSH
62150: LD_INT 0
62152: PPUSH
62153: CALL_OW 50
// result := result ^ un ;
62157: LD_ADDR_VAR 0 7
62161: PUSH
62162: LD_VAR 0 7
62166: PUSH
62167: LD_VAR 0 14
62171: ADD
62172: ST_TO_ADDR
// end ;
62173: GO 62051
62175: POP
62176: POP
// end ; end ;
62177: LD_VAR 0 7
62181: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62182: LD_INT 0
62184: PPUSH
62185: PPUSH
62186: PPUSH
62187: PPUSH
62188: PPUSH
62189: PPUSH
62190: PPUSH
62191: PPUSH
62192: PPUSH
62193: PPUSH
62194: PPUSH
62195: PPUSH
62196: PPUSH
62197: PPUSH
62198: PPUSH
62199: PPUSH
// result := false ;
62200: LD_ADDR_VAR 0 3
62204: PUSH
62205: LD_INT 0
62207: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62208: LD_VAR 0 1
62212: NOT
62213: PUSH
62214: LD_VAR 0 1
62218: PPUSH
62219: CALL_OW 266
62223: PUSH
62224: LD_INT 32
62226: PUSH
62227: LD_INT 33
62229: PUSH
62230: EMPTY
62231: LIST
62232: LIST
62233: IN
62234: NOT
62235: OR
62236: IFFALSE 62240
// exit ;
62238: GO 63349
// nat := GetNation ( tower ) ;
62240: LD_ADDR_VAR 0 12
62244: PUSH
62245: LD_VAR 0 1
62249: PPUSH
62250: CALL_OW 248
62254: ST_TO_ADDR
// side := GetSide ( tower ) ;
62255: LD_ADDR_VAR 0 16
62259: PUSH
62260: LD_VAR 0 1
62264: PPUSH
62265: CALL_OW 255
62269: ST_TO_ADDR
// x := GetX ( tower ) ;
62270: LD_ADDR_VAR 0 10
62274: PUSH
62275: LD_VAR 0 1
62279: PPUSH
62280: CALL_OW 250
62284: ST_TO_ADDR
// y := GetY ( tower ) ;
62285: LD_ADDR_VAR 0 11
62289: PUSH
62290: LD_VAR 0 1
62294: PPUSH
62295: CALL_OW 251
62299: ST_TO_ADDR
// if not x or not y then
62300: LD_VAR 0 10
62304: NOT
62305: PUSH
62306: LD_VAR 0 11
62310: NOT
62311: OR
62312: IFFALSE 62316
// exit ;
62314: GO 63349
// weapon := 0 ;
62316: LD_ADDR_VAR 0 18
62320: PUSH
62321: LD_INT 0
62323: ST_TO_ADDR
// fac_list := [ ] ;
62324: LD_ADDR_VAR 0 17
62328: PUSH
62329: EMPTY
62330: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62331: LD_ADDR_VAR 0 6
62335: PUSH
62336: LD_VAR 0 1
62340: PPUSH
62341: CALL_OW 274
62345: PPUSH
62346: LD_VAR 0 2
62350: PPUSH
62351: LD_INT 0
62353: PPUSH
62354: CALL 59920 0 3
62358: PPUSH
62359: LD_INT 30
62361: PUSH
62362: LD_INT 3
62364: PUSH
62365: EMPTY
62366: LIST
62367: LIST
62368: PPUSH
62369: CALL_OW 72
62373: ST_TO_ADDR
// if not factories then
62374: LD_VAR 0 6
62378: NOT
62379: IFFALSE 62383
// exit ;
62381: GO 63349
// for i in factories do
62383: LD_ADDR_VAR 0 8
62387: PUSH
62388: LD_VAR 0 6
62392: PUSH
62393: FOR_IN
62394: IFFALSE 62419
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62396: LD_ADDR_VAR 0 17
62400: PUSH
62401: LD_VAR 0 17
62405: PUSH
62406: LD_VAR 0 8
62410: PPUSH
62411: CALL_OW 478
62415: UNION
62416: ST_TO_ADDR
62417: GO 62393
62419: POP
62420: POP
// if not fac_list then
62421: LD_VAR 0 17
62425: NOT
62426: IFFALSE 62430
// exit ;
62428: GO 63349
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62430: LD_ADDR_VAR 0 5
62434: PUSH
62435: LD_INT 4
62437: PUSH
62438: LD_INT 5
62440: PUSH
62441: LD_INT 9
62443: PUSH
62444: LD_INT 10
62446: PUSH
62447: LD_INT 6
62449: PUSH
62450: LD_INT 7
62452: PUSH
62453: LD_INT 11
62455: PUSH
62456: EMPTY
62457: LIST
62458: LIST
62459: LIST
62460: LIST
62461: LIST
62462: LIST
62463: LIST
62464: PUSH
62465: LD_INT 27
62467: PUSH
62468: LD_INT 28
62470: PUSH
62471: LD_INT 26
62473: PUSH
62474: LD_INT 30
62476: PUSH
62477: EMPTY
62478: LIST
62479: LIST
62480: LIST
62481: LIST
62482: PUSH
62483: LD_INT 43
62485: PUSH
62486: LD_INT 44
62488: PUSH
62489: LD_INT 46
62491: PUSH
62492: LD_INT 45
62494: PUSH
62495: LD_INT 47
62497: PUSH
62498: LD_INT 49
62500: PUSH
62501: EMPTY
62502: LIST
62503: LIST
62504: LIST
62505: LIST
62506: LIST
62507: LIST
62508: PUSH
62509: EMPTY
62510: LIST
62511: LIST
62512: LIST
62513: PUSH
62514: LD_VAR 0 12
62518: ARRAY
62519: ST_TO_ADDR
// list := list isect fac_list ;
62520: LD_ADDR_VAR 0 5
62524: PUSH
62525: LD_VAR 0 5
62529: PUSH
62530: LD_VAR 0 17
62534: ISECT
62535: ST_TO_ADDR
// if not list then
62536: LD_VAR 0 5
62540: NOT
62541: IFFALSE 62545
// exit ;
62543: GO 63349
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62545: LD_VAR 0 12
62549: PUSH
62550: LD_INT 3
62552: EQUAL
62553: PUSH
62554: LD_INT 49
62556: PUSH
62557: LD_VAR 0 5
62561: IN
62562: AND
62563: PUSH
62564: LD_INT 31
62566: PPUSH
62567: LD_VAR 0 16
62571: PPUSH
62572: CALL_OW 321
62576: PUSH
62577: LD_INT 2
62579: EQUAL
62580: AND
62581: IFFALSE 62641
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62583: LD_INT 22
62585: PUSH
62586: LD_VAR 0 16
62590: PUSH
62591: EMPTY
62592: LIST
62593: LIST
62594: PUSH
62595: LD_INT 35
62597: PUSH
62598: LD_INT 49
62600: PUSH
62601: EMPTY
62602: LIST
62603: LIST
62604: PUSH
62605: LD_INT 91
62607: PUSH
62608: LD_VAR 0 1
62612: PUSH
62613: LD_INT 10
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: LIST
62620: PUSH
62621: EMPTY
62622: LIST
62623: LIST
62624: LIST
62625: PPUSH
62626: CALL_OW 69
62630: NOT
62631: IFFALSE 62641
// weapon := ru_time_lapser ;
62633: LD_ADDR_VAR 0 18
62637: PUSH
62638: LD_INT 49
62640: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62641: LD_VAR 0 12
62645: PUSH
62646: LD_INT 1
62648: PUSH
62649: LD_INT 2
62651: PUSH
62652: EMPTY
62653: LIST
62654: LIST
62655: IN
62656: PUSH
62657: LD_INT 11
62659: PUSH
62660: LD_VAR 0 5
62664: IN
62665: PUSH
62666: LD_INT 30
62668: PUSH
62669: LD_VAR 0 5
62673: IN
62674: OR
62675: AND
62676: PUSH
62677: LD_INT 6
62679: PPUSH
62680: LD_VAR 0 16
62684: PPUSH
62685: CALL_OW 321
62689: PUSH
62690: LD_INT 2
62692: EQUAL
62693: AND
62694: IFFALSE 62859
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62696: LD_INT 22
62698: PUSH
62699: LD_VAR 0 16
62703: PUSH
62704: EMPTY
62705: LIST
62706: LIST
62707: PUSH
62708: LD_INT 2
62710: PUSH
62711: LD_INT 35
62713: PUSH
62714: LD_INT 11
62716: PUSH
62717: EMPTY
62718: LIST
62719: LIST
62720: PUSH
62721: LD_INT 35
62723: PUSH
62724: LD_INT 30
62726: PUSH
62727: EMPTY
62728: LIST
62729: LIST
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: LIST
62735: PUSH
62736: LD_INT 91
62738: PUSH
62739: LD_VAR 0 1
62743: PUSH
62744: LD_INT 18
62746: PUSH
62747: EMPTY
62748: LIST
62749: LIST
62750: LIST
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: LIST
62756: PPUSH
62757: CALL_OW 69
62761: NOT
62762: PUSH
62763: LD_INT 22
62765: PUSH
62766: LD_VAR 0 16
62770: PUSH
62771: EMPTY
62772: LIST
62773: LIST
62774: PUSH
62775: LD_INT 2
62777: PUSH
62778: LD_INT 30
62780: PUSH
62781: LD_INT 32
62783: PUSH
62784: EMPTY
62785: LIST
62786: LIST
62787: PUSH
62788: LD_INT 30
62790: PUSH
62791: LD_INT 33
62793: PUSH
62794: EMPTY
62795: LIST
62796: LIST
62797: PUSH
62798: EMPTY
62799: LIST
62800: LIST
62801: LIST
62802: PUSH
62803: LD_INT 91
62805: PUSH
62806: LD_VAR 0 1
62810: PUSH
62811: LD_INT 12
62813: PUSH
62814: EMPTY
62815: LIST
62816: LIST
62817: LIST
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: LIST
62823: PUSH
62824: EMPTY
62825: LIST
62826: PPUSH
62827: CALL_OW 69
62831: PUSH
62832: LD_INT 2
62834: GREATER
62835: AND
62836: IFFALSE 62859
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62838: LD_ADDR_VAR 0 18
62842: PUSH
62843: LD_INT 11
62845: PUSH
62846: LD_INT 30
62848: PUSH
62849: EMPTY
62850: LIST
62851: LIST
62852: PUSH
62853: LD_VAR 0 12
62857: ARRAY
62858: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62859: LD_VAR 0 18
62863: NOT
62864: PUSH
62865: LD_INT 40
62867: PPUSH
62868: LD_VAR 0 16
62872: PPUSH
62873: CALL_OW 321
62877: PUSH
62878: LD_INT 2
62880: EQUAL
62881: AND
62882: PUSH
62883: LD_INT 7
62885: PUSH
62886: LD_VAR 0 5
62890: IN
62891: PUSH
62892: LD_INT 28
62894: PUSH
62895: LD_VAR 0 5
62899: IN
62900: OR
62901: PUSH
62902: LD_INT 45
62904: PUSH
62905: LD_VAR 0 5
62909: IN
62910: OR
62911: AND
62912: IFFALSE 63166
// begin hex := GetHexInfo ( x , y ) ;
62914: LD_ADDR_VAR 0 4
62918: PUSH
62919: LD_VAR 0 10
62923: PPUSH
62924: LD_VAR 0 11
62928: PPUSH
62929: CALL_OW 546
62933: ST_TO_ADDR
// if hex [ 1 ] then
62934: LD_VAR 0 4
62938: PUSH
62939: LD_INT 1
62941: ARRAY
62942: IFFALSE 62946
// exit ;
62944: GO 63349
// height := hex [ 2 ] ;
62946: LD_ADDR_VAR 0 15
62950: PUSH
62951: LD_VAR 0 4
62955: PUSH
62956: LD_INT 2
62958: ARRAY
62959: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62960: LD_ADDR_VAR 0 14
62964: PUSH
62965: LD_INT 0
62967: PUSH
62968: LD_INT 2
62970: PUSH
62971: LD_INT 3
62973: PUSH
62974: LD_INT 5
62976: PUSH
62977: EMPTY
62978: LIST
62979: LIST
62980: LIST
62981: LIST
62982: ST_TO_ADDR
// for i in tmp do
62983: LD_ADDR_VAR 0 8
62987: PUSH
62988: LD_VAR 0 14
62992: PUSH
62993: FOR_IN
62994: IFFALSE 63164
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62996: LD_ADDR_VAR 0 9
63000: PUSH
63001: LD_VAR 0 10
63005: PPUSH
63006: LD_VAR 0 8
63010: PPUSH
63011: LD_INT 5
63013: PPUSH
63014: CALL_OW 272
63018: PUSH
63019: LD_VAR 0 11
63023: PPUSH
63024: LD_VAR 0 8
63028: PPUSH
63029: LD_INT 5
63031: PPUSH
63032: CALL_OW 273
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63041: LD_VAR 0 9
63045: PUSH
63046: LD_INT 1
63048: ARRAY
63049: PPUSH
63050: LD_VAR 0 9
63054: PUSH
63055: LD_INT 2
63057: ARRAY
63058: PPUSH
63059: CALL_OW 488
63063: IFFALSE 63162
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63065: LD_ADDR_VAR 0 4
63069: PUSH
63070: LD_VAR 0 9
63074: PUSH
63075: LD_INT 1
63077: ARRAY
63078: PPUSH
63079: LD_VAR 0 9
63083: PUSH
63084: LD_INT 2
63086: ARRAY
63087: PPUSH
63088: CALL_OW 546
63092: ST_TO_ADDR
// if hex [ 1 ] then
63093: LD_VAR 0 4
63097: PUSH
63098: LD_INT 1
63100: ARRAY
63101: IFFALSE 63105
// continue ;
63103: GO 62993
// h := hex [ 2 ] ;
63105: LD_ADDR_VAR 0 13
63109: PUSH
63110: LD_VAR 0 4
63114: PUSH
63115: LD_INT 2
63117: ARRAY
63118: ST_TO_ADDR
// if h + 7 < height then
63119: LD_VAR 0 13
63123: PUSH
63124: LD_INT 7
63126: PLUS
63127: PUSH
63128: LD_VAR 0 15
63132: LESS
63133: IFFALSE 63162
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63135: LD_ADDR_VAR 0 18
63139: PUSH
63140: LD_INT 7
63142: PUSH
63143: LD_INT 28
63145: PUSH
63146: LD_INT 45
63148: PUSH
63149: EMPTY
63150: LIST
63151: LIST
63152: LIST
63153: PUSH
63154: LD_VAR 0 12
63158: ARRAY
63159: ST_TO_ADDR
// break ;
63160: GO 63164
// end ; end ; end ;
63162: GO 62993
63164: POP
63165: POP
// end ; if not weapon then
63166: LD_VAR 0 18
63170: NOT
63171: IFFALSE 63231
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63173: LD_ADDR_VAR 0 5
63177: PUSH
63178: LD_VAR 0 5
63182: PUSH
63183: LD_INT 11
63185: PUSH
63186: LD_INT 30
63188: PUSH
63189: LD_INT 49
63191: PUSH
63192: EMPTY
63193: LIST
63194: LIST
63195: LIST
63196: DIFF
63197: ST_TO_ADDR
// if not list then
63198: LD_VAR 0 5
63202: NOT
63203: IFFALSE 63207
// exit ;
63205: GO 63349
// weapon := list [ rand ( 1 , list ) ] ;
63207: LD_ADDR_VAR 0 18
63211: PUSH
63212: LD_VAR 0 5
63216: PUSH
63217: LD_INT 1
63219: PPUSH
63220: LD_VAR 0 5
63224: PPUSH
63225: CALL_OW 12
63229: ARRAY
63230: ST_TO_ADDR
// end ; if weapon then
63231: LD_VAR 0 18
63235: IFFALSE 63349
// begin tmp := CostOfWeapon ( weapon ) ;
63237: LD_ADDR_VAR 0 14
63241: PUSH
63242: LD_VAR 0 18
63246: PPUSH
63247: CALL_OW 451
63251: ST_TO_ADDR
// j := GetBase ( tower ) ;
63252: LD_ADDR_VAR 0 9
63256: PUSH
63257: LD_VAR 0 1
63261: PPUSH
63262: CALL_OW 274
63266: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63267: LD_VAR 0 9
63271: PPUSH
63272: LD_INT 1
63274: PPUSH
63275: CALL_OW 275
63279: PUSH
63280: LD_VAR 0 14
63284: PUSH
63285: LD_INT 1
63287: ARRAY
63288: GREATEREQUAL
63289: PUSH
63290: LD_VAR 0 9
63294: PPUSH
63295: LD_INT 2
63297: PPUSH
63298: CALL_OW 275
63302: PUSH
63303: LD_VAR 0 14
63307: PUSH
63308: LD_INT 2
63310: ARRAY
63311: GREATEREQUAL
63312: AND
63313: PUSH
63314: LD_VAR 0 9
63318: PPUSH
63319: LD_INT 3
63321: PPUSH
63322: CALL_OW 275
63326: PUSH
63327: LD_VAR 0 14
63331: PUSH
63332: LD_INT 3
63334: ARRAY
63335: GREATEREQUAL
63336: AND
63337: IFFALSE 63349
// result := weapon ;
63339: LD_ADDR_VAR 0 3
63343: PUSH
63344: LD_VAR 0 18
63348: ST_TO_ADDR
// end ; end ;
63349: LD_VAR 0 3
63353: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63354: LD_INT 0
63356: PPUSH
63357: PPUSH
// result := true ;
63358: LD_ADDR_VAR 0 3
63362: PUSH
63363: LD_INT 1
63365: ST_TO_ADDR
// if array1 = array2 then
63366: LD_VAR 0 1
63370: PUSH
63371: LD_VAR 0 2
63375: EQUAL
63376: IFFALSE 63436
// begin for i = 1 to array1 do
63378: LD_ADDR_VAR 0 4
63382: PUSH
63383: DOUBLE
63384: LD_INT 1
63386: DEC
63387: ST_TO_ADDR
63388: LD_VAR 0 1
63392: PUSH
63393: FOR_TO
63394: IFFALSE 63432
// if array1 [ i ] <> array2 [ i ] then
63396: LD_VAR 0 1
63400: PUSH
63401: LD_VAR 0 4
63405: ARRAY
63406: PUSH
63407: LD_VAR 0 2
63411: PUSH
63412: LD_VAR 0 4
63416: ARRAY
63417: NONEQUAL
63418: IFFALSE 63430
// begin result := false ;
63420: LD_ADDR_VAR 0 3
63424: PUSH
63425: LD_INT 0
63427: ST_TO_ADDR
// break ;
63428: GO 63432
// end ;
63430: GO 63393
63432: POP
63433: POP
// end else
63434: GO 63444
// result := false ;
63436: LD_ADDR_VAR 0 3
63440: PUSH
63441: LD_INT 0
63443: ST_TO_ADDR
// end ;
63444: LD_VAR 0 3
63448: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63449: LD_INT 0
63451: PPUSH
63452: PPUSH
// if not array1 or not array2 then
63453: LD_VAR 0 1
63457: NOT
63458: PUSH
63459: LD_VAR 0 2
63463: NOT
63464: OR
63465: IFFALSE 63469
// exit ;
63467: GO 63533
// result := true ;
63469: LD_ADDR_VAR 0 3
63473: PUSH
63474: LD_INT 1
63476: ST_TO_ADDR
// for i = 1 to array1 do
63477: LD_ADDR_VAR 0 4
63481: PUSH
63482: DOUBLE
63483: LD_INT 1
63485: DEC
63486: ST_TO_ADDR
63487: LD_VAR 0 1
63491: PUSH
63492: FOR_TO
63493: IFFALSE 63531
// if array1 [ i ] <> array2 [ i ] then
63495: LD_VAR 0 1
63499: PUSH
63500: LD_VAR 0 4
63504: ARRAY
63505: PUSH
63506: LD_VAR 0 2
63510: PUSH
63511: LD_VAR 0 4
63515: ARRAY
63516: NONEQUAL
63517: IFFALSE 63529
// begin result := false ;
63519: LD_ADDR_VAR 0 3
63523: PUSH
63524: LD_INT 0
63526: ST_TO_ADDR
// break ;
63527: GO 63531
// end ;
63529: GO 63492
63531: POP
63532: POP
// end ;
63533: LD_VAR 0 3
63537: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63538: LD_INT 0
63540: PPUSH
63541: PPUSH
63542: PPUSH
// pom := GetBase ( fac ) ;
63543: LD_ADDR_VAR 0 5
63547: PUSH
63548: LD_VAR 0 1
63552: PPUSH
63553: CALL_OW 274
63557: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63558: LD_ADDR_VAR 0 4
63562: PUSH
63563: LD_VAR 0 2
63567: PUSH
63568: LD_INT 1
63570: ARRAY
63571: PPUSH
63572: LD_VAR 0 2
63576: PUSH
63577: LD_INT 2
63579: ARRAY
63580: PPUSH
63581: LD_VAR 0 2
63585: PUSH
63586: LD_INT 3
63588: ARRAY
63589: PPUSH
63590: LD_VAR 0 2
63594: PUSH
63595: LD_INT 4
63597: ARRAY
63598: PPUSH
63599: CALL_OW 449
63603: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63604: LD_ADDR_VAR 0 3
63608: PUSH
63609: LD_VAR 0 5
63613: PPUSH
63614: LD_INT 1
63616: PPUSH
63617: CALL_OW 275
63621: PUSH
63622: LD_VAR 0 4
63626: PUSH
63627: LD_INT 1
63629: ARRAY
63630: GREATEREQUAL
63631: PUSH
63632: LD_VAR 0 5
63636: PPUSH
63637: LD_INT 2
63639: PPUSH
63640: CALL_OW 275
63644: PUSH
63645: LD_VAR 0 4
63649: PUSH
63650: LD_INT 2
63652: ARRAY
63653: GREATEREQUAL
63654: AND
63655: PUSH
63656: LD_VAR 0 5
63660: PPUSH
63661: LD_INT 3
63663: PPUSH
63664: CALL_OW 275
63668: PUSH
63669: LD_VAR 0 4
63673: PUSH
63674: LD_INT 3
63676: ARRAY
63677: GREATEREQUAL
63678: AND
63679: ST_TO_ADDR
// end ;
63680: LD_VAR 0 3
63684: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63685: LD_INT 0
63687: PPUSH
63688: PPUSH
63689: PPUSH
63690: PPUSH
// pom := GetBase ( building ) ;
63691: LD_ADDR_VAR 0 3
63695: PUSH
63696: LD_VAR 0 1
63700: PPUSH
63701: CALL_OW 274
63705: ST_TO_ADDR
// if not pom then
63706: LD_VAR 0 3
63710: NOT
63711: IFFALSE 63715
// exit ;
63713: GO 63885
// btype := GetBType ( building ) ;
63715: LD_ADDR_VAR 0 5
63719: PUSH
63720: LD_VAR 0 1
63724: PPUSH
63725: CALL_OW 266
63729: ST_TO_ADDR
// if btype = b_armoury then
63730: LD_VAR 0 5
63734: PUSH
63735: LD_INT 4
63737: EQUAL
63738: IFFALSE 63748
// btype := b_barracks ;
63740: LD_ADDR_VAR 0 5
63744: PUSH
63745: LD_INT 5
63747: ST_TO_ADDR
// if btype = b_depot then
63748: LD_VAR 0 5
63752: PUSH
63753: LD_INT 0
63755: EQUAL
63756: IFFALSE 63766
// btype := b_warehouse ;
63758: LD_ADDR_VAR 0 5
63762: PUSH
63763: LD_INT 1
63765: ST_TO_ADDR
// if btype = b_workshop then
63766: LD_VAR 0 5
63770: PUSH
63771: LD_INT 2
63773: EQUAL
63774: IFFALSE 63784
// btype := b_factory ;
63776: LD_ADDR_VAR 0 5
63780: PUSH
63781: LD_INT 3
63783: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63784: LD_ADDR_VAR 0 4
63788: PUSH
63789: LD_VAR 0 5
63793: PPUSH
63794: LD_VAR 0 1
63798: PPUSH
63799: CALL_OW 248
63803: PPUSH
63804: CALL_OW 450
63808: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63809: LD_ADDR_VAR 0 2
63813: PUSH
63814: LD_VAR 0 3
63818: PPUSH
63819: LD_INT 1
63821: PPUSH
63822: CALL_OW 275
63826: PUSH
63827: LD_VAR 0 4
63831: PUSH
63832: LD_INT 1
63834: ARRAY
63835: GREATEREQUAL
63836: PUSH
63837: LD_VAR 0 3
63841: PPUSH
63842: LD_INT 2
63844: PPUSH
63845: CALL_OW 275
63849: PUSH
63850: LD_VAR 0 4
63854: PUSH
63855: LD_INT 2
63857: ARRAY
63858: GREATEREQUAL
63859: AND
63860: PUSH
63861: LD_VAR 0 3
63865: PPUSH
63866: LD_INT 3
63868: PPUSH
63869: CALL_OW 275
63873: PUSH
63874: LD_VAR 0 4
63878: PUSH
63879: LD_INT 3
63881: ARRAY
63882: GREATEREQUAL
63883: AND
63884: ST_TO_ADDR
// end ;
63885: LD_VAR 0 2
63889: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63890: LD_INT 0
63892: PPUSH
63893: PPUSH
63894: PPUSH
// pom := GetBase ( building ) ;
63895: LD_ADDR_VAR 0 4
63899: PUSH
63900: LD_VAR 0 1
63904: PPUSH
63905: CALL_OW 274
63909: ST_TO_ADDR
// if not pom then
63910: LD_VAR 0 4
63914: NOT
63915: IFFALSE 63919
// exit ;
63917: GO 64020
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63919: LD_ADDR_VAR 0 5
63923: PUSH
63924: LD_VAR 0 2
63928: PPUSH
63929: LD_VAR 0 1
63933: PPUSH
63934: CALL_OW 248
63938: PPUSH
63939: CALL_OW 450
63943: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63944: LD_ADDR_VAR 0 3
63948: PUSH
63949: LD_VAR 0 4
63953: PPUSH
63954: LD_INT 1
63956: PPUSH
63957: CALL_OW 275
63961: PUSH
63962: LD_VAR 0 5
63966: PUSH
63967: LD_INT 1
63969: ARRAY
63970: GREATEREQUAL
63971: PUSH
63972: LD_VAR 0 4
63976: PPUSH
63977: LD_INT 2
63979: PPUSH
63980: CALL_OW 275
63984: PUSH
63985: LD_VAR 0 5
63989: PUSH
63990: LD_INT 2
63992: ARRAY
63993: GREATEREQUAL
63994: AND
63995: PUSH
63996: LD_VAR 0 4
64000: PPUSH
64001: LD_INT 3
64003: PPUSH
64004: CALL_OW 275
64008: PUSH
64009: LD_VAR 0 5
64013: PUSH
64014: LD_INT 3
64016: ARRAY
64017: GREATEREQUAL
64018: AND
64019: ST_TO_ADDR
// end ;
64020: LD_VAR 0 3
64024: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
64025: LD_INT 0
64027: PPUSH
64028: PPUSH
64029: PPUSH
64030: PPUSH
64031: PPUSH
64032: PPUSH
64033: PPUSH
64034: PPUSH
64035: PPUSH
64036: PPUSH
64037: PPUSH
// result := false ;
64038: LD_ADDR_VAR 0 8
64042: PUSH
64043: LD_INT 0
64045: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
64046: LD_VAR 0 5
64050: NOT
64051: PUSH
64052: LD_VAR 0 1
64056: NOT
64057: OR
64058: PUSH
64059: LD_VAR 0 2
64063: NOT
64064: OR
64065: PUSH
64066: LD_VAR 0 3
64070: NOT
64071: OR
64072: IFFALSE 64076
// exit ;
64074: GO 64890
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
64076: LD_ADDR_VAR 0 14
64080: PUSH
64081: LD_VAR 0 1
64085: PPUSH
64086: LD_VAR 0 2
64090: PPUSH
64091: LD_VAR 0 3
64095: PPUSH
64096: LD_VAR 0 4
64100: PPUSH
64101: LD_VAR 0 5
64105: PUSH
64106: LD_INT 1
64108: ARRAY
64109: PPUSH
64110: CALL_OW 248
64114: PPUSH
64115: LD_INT 0
64117: PPUSH
64118: CALL 66123 0 6
64122: ST_TO_ADDR
// if not hexes then
64123: LD_VAR 0 14
64127: NOT
64128: IFFALSE 64132
// exit ;
64130: GO 64890
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64132: LD_ADDR_VAR 0 17
64136: PUSH
64137: LD_VAR 0 5
64141: PPUSH
64142: LD_INT 22
64144: PUSH
64145: LD_VAR 0 13
64149: PPUSH
64150: CALL_OW 255
64154: PUSH
64155: EMPTY
64156: LIST
64157: LIST
64158: PUSH
64159: LD_INT 2
64161: PUSH
64162: LD_INT 30
64164: PUSH
64165: LD_INT 0
64167: PUSH
64168: EMPTY
64169: LIST
64170: LIST
64171: PUSH
64172: LD_INT 30
64174: PUSH
64175: LD_INT 1
64177: PUSH
64178: EMPTY
64179: LIST
64180: LIST
64181: PUSH
64182: EMPTY
64183: LIST
64184: LIST
64185: LIST
64186: PUSH
64187: EMPTY
64188: LIST
64189: LIST
64190: PPUSH
64191: CALL_OW 72
64195: ST_TO_ADDR
// for i = 1 to hexes do
64196: LD_ADDR_VAR 0 9
64200: PUSH
64201: DOUBLE
64202: LD_INT 1
64204: DEC
64205: ST_TO_ADDR
64206: LD_VAR 0 14
64210: PUSH
64211: FOR_TO
64212: IFFALSE 64888
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64214: LD_ADDR_VAR 0 13
64218: PUSH
64219: LD_VAR 0 14
64223: PUSH
64224: LD_VAR 0 9
64228: ARRAY
64229: PUSH
64230: LD_INT 1
64232: ARRAY
64233: PPUSH
64234: LD_VAR 0 14
64238: PUSH
64239: LD_VAR 0 9
64243: ARRAY
64244: PUSH
64245: LD_INT 2
64247: ARRAY
64248: PPUSH
64249: CALL_OW 428
64253: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64254: LD_VAR 0 14
64258: PUSH
64259: LD_VAR 0 9
64263: ARRAY
64264: PUSH
64265: LD_INT 1
64267: ARRAY
64268: PPUSH
64269: LD_VAR 0 14
64273: PUSH
64274: LD_VAR 0 9
64278: ARRAY
64279: PUSH
64280: LD_INT 2
64282: ARRAY
64283: PPUSH
64284: CALL_OW 351
64288: PUSH
64289: LD_VAR 0 14
64293: PUSH
64294: LD_VAR 0 9
64298: ARRAY
64299: PUSH
64300: LD_INT 1
64302: ARRAY
64303: PPUSH
64304: LD_VAR 0 14
64308: PUSH
64309: LD_VAR 0 9
64313: ARRAY
64314: PUSH
64315: LD_INT 2
64317: ARRAY
64318: PPUSH
64319: CALL_OW 488
64323: NOT
64324: OR
64325: PUSH
64326: LD_VAR 0 13
64330: PPUSH
64331: CALL_OW 247
64335: PUSH
64336: LD_INT 3
64338: EQUAL
64339: OR
64340: IFFALSE 64346
// exit ;
64342: POP
64343: POP
64344: GO 64890
// if not tmp then
64346: LD_VAR 0 13
64350: NOT
64351: IFFALSE 64355
// continue ;
64353: GO 64211
// result := true ;
64355: LD_ADDR_VAR 0 8
64359: PUSH
64360: LD_INT 1
64362: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64363: LD_VAR 0 6
64367: PUSH
64368: LD_VAR 0 13
64372: PPUSH
64373: CALL_OW 247
64377: PUSH
64378: LD_INT 2
64380: EQUAL
64381: AND
64382: PUSH
64383: LD_VAR 0 13
64387: PPUSH
64388: CALL_OW 263
64392: PUSH
64393: LD_INT 1
64395: EQUAL
64396: AND
64397: IFFALSE 64561
// begin if IsDrivenBy ( tmp ) then
64399: LD_VAR 0 13
64403: PPUSH
64404: CALL_OW 311
64408: IFFALSE 64412
// continue ;
64410: GO 64211
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64412: LD_VAR 0 6
64416: PPUSH
64417: LD_INT 3
64419: PUSH
64420: LD_INT 60
64422: PUSH
64423: EMPTY
64424: LIST
64425: PUSH
64426: EMPTY
64427: LIST
64428: LIST
64429: PUSH
64430: LD_INT 3
64432: PUSH
64433: LD_INT 55
64435: PUSH
64436: EMPTY
64437: LIST
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: EMPTY
64444: LIST
64445: LIST
64446: PPUSH
64447: CALL_OW 72
64451: IFFALSE 64559
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64453: LD_ADDR_VAR 0 18
64457: PUSH
64458: LD_VAR 0 6
64462: PPUSH
64463: LD_INT 3
64465: PUSH
64466: LD_INT 60
64468: PUSH
64469: EMPTY
64470: LIST
64471: PUSH
64472: EMPTY
64473: LIST
64474: LIST
64475: PUSH
64476: LD_INT 3
64478: PUSH
64479: LD_INT 55
64481: PUSH
64482: EMPTY
64483: LIST
64484: PUSH
64485: EMPTY
64486: LIST
64487: LIST
64488: PUSH
64489: EMPTY
64490: LIST
64491: LIST
64492: PPUSH
64493: CALL_OW 72
64497: PUSH
64498: LD_INT 1
64500: ARRAY
64501: ST_TO_ADDR
// if IsInUnit ( driver ) then
64502: LD_VAR 0 18
64506: PPUSH
64507: CALL_OW 310
64511: IFFALSE 64522
// ComExit ( driver ) ;
64513: LD_VAR 0 18
64517: PPUSH
64518: CALL 89902 0 1
// AddComEnterUnit ( driver , tmp ) ;
64522: LD_VAR 0 18
64526: PPUSH
64527: LD_VAR 0 13
64531: PPUSH
64532: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64536: LD_VAR 0 18
64540: PPUSH
64541: LD_VAR 0 7
64545: PPUSH
64546: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64550: LD_VAR 0 18
64554: PPUSH
64555: CALL_OW 181
// end ; continue ;
64559: GO 64211
// end ; if not cleaners or not tmp in cleaners then
64561: LD_VAR 0 6
64565: NOT
64566: PUSH
64567: LD_VAR 0 13
64571: PUSH
64572: LD_VAR 0 6
64576: IN
64577: NOT
64578: OR
64579: IFFALSE 64886
// begin if dep then
64581: LD_VAR 0 17
64585: IFFALSE 64721
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64587: LD_ADDR_VAR 0 16
64591: PUSH
64592: LD_VAR 0 17
64596: PUSH
64597: LD_INT 1
64599: ARRAY
64600: PPUSH
64601: CALL_OW 250
64605: PPUSH
64606: LD_VAR 0 17
64610: PUSH
64611: LD_INT 1
64613: ARRAY
64614: PPUSH
64615: CALL_OW 254
64619: PPUSH
64620: LD_INT 5
64622: PPUSH
64623: CALL_OW 272
64627: PUSH
64628: LD_VAR 0 17
64632: PUSH
64633: LD_INT 1
64635: ARRAY
64636: PPUSH
64637: CALL_OW 251
64641: PPUSH
64642: LD_VAR 0 17
64646: PUSH
64647: LD_INT 1
64649: ARRAY
64650: PPUSH
64651: CALL_OW 254
64655: PPUSH
64656: LD_INT 5
64658: PPUSH
64659: CALL_OW 273
64663: PUSH
64664: EMPTY
64665: LIST
64666: LIST
64667: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64668: LD_VAR 0 16
64672: PUSH
64673: LD_INT 1
64675: ARRAY
64676: PPUSH
64677: LD_VAR 0 16
64681: PUSH
64682: LD_INT 2
64684: ARRAY
64685: PPUSH
64686: CALL_OW 488
64690: IFFALSE 64721
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64692: LD_VAR 0 13
64696: PPUSH
64697: LD_VAR 0 16
64701: PUSH
64702: LD_INT 1
64704: ARRAY
64705: PPUSH
64706: LD_VAR 0 16
64710: PUSH
64711: LD_INT 2
64713: ARRAY
64714: PPUSH
64715: CALL_OW 111
// continue ;
64719: GO 64211
// end ; end ; r := GetDir ( tmp ) ;
64721: LD_ADDR_VAR 0 15
64725: PUSH
64726: LD_VAR 0 13
64730: PPUSH
64731: CALL_OW 254
64735: ST_TO_ADDR
// if r = 5 then
64736: LD_VAR 0 15
64740: PUSH
64741: LD_INT 5
64743: EQUAL
64744: IFFALSE 64754
// r := 0 ;
64746: LD_ADDR_VAR 0 15
64750: PUSH
64751: LD_INT 0
64753: ST_TO_ADDR
// for j = r to 5 do
64754: LD_ADDR_VAR 0 10
64758: PUSH
64759: DOUBLE
64760: LD_VAR 0 15
64764: DEC
64765: ST_TO_ADDR
64766: LD_INT 5
64768: PUSH
64769: FOR_TO
64770: IFFALSE 64884
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64772: LD_ADDR_VAR 0 11
64776: PUSH
64777: LD_VAR 0 13
64781: PPUSH
64782: CALL_OW 250
64786: PPUSH
64787: LD_VAR 0 10
64791: PPUSH
64792: LD_INT 2
64794: PPUSH
64795: CALL_OW 272
64799: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64800: LD_ADDR_VAR 0 12
64804: PUSH
64805: LD_VAR 0 13
64809: PPUSH
64810: CALL_OW 251
64814: PPUSH
64815: LD_VAR 0 10
64819: PPUSH
64820: LD_INT 2
64822: PPUSH
64823: CALL_OW 273
64827: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64828: LD_VAR 0 11
64832: PPUSH
64833: LD_VAR 0 12
64837: PPUSH
64838: CALL_OW 488
64842: PUSH
64843: LD_VAR 0 11
64847: PPUSH
64848: LD_VAR 0 12
64852: PPUSH
64853: CALL_OW 428
64857: NOT
64858: AND
64859: IFFALSE 64882
// begin ComMoveXY ( tmp , _x , _y ) ;
64861: LD_VAR 0 13
64865: PPUSH
64866: LD_VAR 0 11
64870: PPUSH
64871: LD_VAR 0 12
64875: PPUSH
64876: CALL_OW 111
// break ;
64880: GO 64884
// end ; end ;
64882: GO 64769
64884: POP
64885: POP
// end ; end ;
64886: GO 64211
64888: POP
64889: POP
// end ;
64890: LD_VAR 0 8
64894: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64895: LD_INT 0
64897: PPUSH
// result := true ;
64898: LD_ADDR_VAR 0 3
64902: PUSH
64903: LD_INT 1
64905: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64906: LD_VAR 0 2
64910: PUSH
64911: LD_INT 24
64913: DOUBLE
64914: EQUAL
64915: IFTRUE 64925
64917: LD_INT 33
64919: DOUBLE
64920: EQUAL
64921: IFTRUE 64925
64923: GO 64950
64925: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64926: LD_ADDR_VAR 0 3
64930: PUSH
64931: LD_INT 32
64933: PPUSH
64934: LD_VAR 0 1
64938: PPUSH
64939: CALL_OW 321
64943: PUSH
64944: LD_INT 2
64946: EQUAL
64947: ST_TO_ADDR
64948: GO 65266
64950: LD_INT 20
64952: DOUBLE
64953: EQUAL
64954: IFTRUE 64958
64956: GO 64983
64958: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64959: LD_ADDR_VAR 0 3
64963: PUSH
64964: LD_INT 6
64966: PPUSH
64967: LD_VAR 0 1
64971: PPUSH
64972: CALL_OW 321
64976: PUSH
64977: LD_INT 2
64979: EQUAL
64980: ST_TO_ADDR
64981: GO 65266
64983: LD_INT 22
64985: DOUBLE
64986: EQUAL
64987: IFTRUE 64997
64989: LD_INT 36
64991: DOUBLE
64992: EQUAL
64993: IFTRUE 64997
64995: GO 65022
64997: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64998: LD_ADDR_VAR 0 3
65002: PUSH
65003: LD_INT 15
65005: PPUSH
65006: LD_VAR 0 1
65010: PPUSH
65011: CALL_OW 321
65015: PUSH
65016: LD_INT 2
65018: EQUAL
65019: ST_TO_ADDR
65020: GO 65266
65022: LD_INT 30
65024: DOUBLE
65025: EQUAL
65026: IFTRUE 65030
65028: GO 65055
65030: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
65031: LD_ADDR_VAR 0 3
65035: PUSH
65036: LD_INT 20
65038: PPUSH
65039: LD_VAR 0 1
65043: PPUSH
65044: CALL_OW 321
65048: PUSH
65049: LD_INT 2
65051: EQUAL
65052: ST_TO_ADDR
65053: GO 65266
65055: LD_INT 28
65057: DOUBLE
65058: EQUAL
65059: IFTRUE 65069
65061: LD_INT 21
65063: DOUBLE
65064: EQUAL
65065: IFTRUE 65069
65067: GO 65094
65069: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
65070: LD_ADDR_VAR 0 3
65074: PUSH
65075: LD_INT 21
65077: PPUSH
65078: LD_VAR 0 1
65082: PPUSH
65083: CALL_OW 321
65087: PUSH
65088: LD_INT 2
65090: EQUAL
65091: ST_TO_ADDR
65092: GO 65266
65094: LD_INT 16
65096: DOUBLE
65097: EQUAL
65098: IFTRUE 65102
65100: GO 65127
65102: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
65103: LD_ADDR_VAR 0 3
65107: PUSH
65108: LD_INT 84
65110: PPUSH
65111: LD_VAR 0 1
65115: PPUSH
65116: CALL_OW 321
65120: PUSH
65121: LD_INT 2
65123: EQUAL
65124: ST_TO_ADDR
65125: GO 65266
65127: LD_INT 19
65129: DOUBLE
65130: EQUAL
65131: IFTRUE 65141
65133: LD_INT 23
65135: DOUBLE
65136: EQUAL
65137: IFTRUE 65141
65139: GO 65166
65141: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
65142: LD_ADDR_VAR 0 3
65146: PUSH
65147: LD_INT 83
65149: PPUSH
65150: LD_VAR 0 1
65154: PPUSH
65155: CALL_OW 321
65159: PUSH
65160: LD_INT 2
65162: EQUAL
65163: ST_TO_ADDR
65164: GO 65266
65166: LD_INT 17
65168: DOUBLE
65169: EQUAL
65170: IFTRUE 65174
65172: GO 65199
65174: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65175: LD_ADDR_VAR 0 3
65179: PUSH
65180: LD_INT 39
65182: PPUSH
65183: LD_VAR 0 1
65187: PPUSH
65188: CALL_OW 321
65192: PUSH
65193: LD_INT 2
65195: EQUAL
65196: ST_TO_ADDR
65197: GO 65266
65199: LD_INT 18
65201: DOUBLE
65202: EQUAL
65203: IFTRUE 65207
65205: GO 65232
65207: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65208: LD_ADDR_VAR 0 3
65212: PUSH
65213: LD_INT 40
65215: PPUSH
65216: LD_VAR 0 1
65220: PPUSH
65221: CALL_OW 321
65225: PUSH
65226: LD_INT 2
65228: EQUAL
65229: ST_TO_ADDR
65230: GO 65266
65232: LD_INT 27
65234: DOUBLE
65235: EQUAL
65236: IFTRUE 65240
65238: GO 65265
65240: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65241: LD_ADDR_VAR 0 3
65245: PUSH
65246: LD_INT 35
65248: PPUSH
65249: LD_VAR 0 1
65253: PPUSH
65254: CALL_OW 321
65258: PUSH
65259: LD_INT 2
65261: EQUAL
65262: ST_TO_ADDR
65263: GO 65266
65265: POP
// end ;
65266: LD_VAR 0 3
65270: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65271: LD_INT 0
65273: PPUSH
65274: PPUSH
65275: PPUSH
65276: PPUSH
65277: PPUSH
65278: PPUSH
65279: PPUSH
65280: PPUSH
65281: PPUSH
65282: PPUSH
65283: PPUSH
// result := false ;
65284: LD_ADDR_VAR 0 6
65288: PUSH
65289: LD_INT 0
65291: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65292: LD_VAR 0 1
65296: NOT
65297: PUSH
65298: LD_VAR 0 1
65302: PPUSH
65303: CALL_OW 266
65307: PUSH
65308: LD_INT 0
65310: PUSH
65311: LD_INT 1
65313: PUSH
65314: EMPTY
65315: LIST
65316: LIST
65317: IN
65318: NOT
65319: OR
65320: PUSH
65321: LD_VAR 0 2
65325: NOT
65326: OR
65327: PUSH
65328: LD_VAR 0 5
65332: PUSH
65333: LD_INT 0
65335: PUSH
65336: LD_INT 1
65338: PUSH
65339: LD_INT 2
65341: PUSH
65342: LD_INT 3
65344: PUSH
65345: LD_INT 4
65347: PUSH
65348: LD_INT 5
65350: PUSH
65351: EMPTY
65352: LIST
65353: LIST
65354: LIST
65355: LIST
65356: LIST
65357: LIST
65358: IN
65359: NOT
65360: OR
65361: PUSH
65362: LD_VAR 0 3
65366: PPUSH
65367: LD_VAR 0 4
65371: PPUSH
65372: CALL_OW 488
65376: NOT
65377: OR
65378: IFFALSE 65382
// exit ;
65380: GO 66118
// side := GetSide ( depot ) ;
65382: LD_ADDR_VAR 0 9
65386: PUSH
65387: LD_VAR 0 1
65391: PPUSH
65392: CALL_OW 255
65396: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65397: LD_VAR 0 9
65401: PPUSH
65402: LD_VAR 0 2
65406: PPUSH
65407: CALL 64895 0 2
65411: NOT
65412: IFFALSE 65416
// exit ;
65414: GO 66118
// pom := GetBase ( depot ) ;
65416: LD_ADDR_VAR 0 10
65420: PUSH
65421: LD_VAR 0 1
65425: PPUSH
65426: CALL_OW 274
65430: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65431: LD_ADDR_VAR 0 11
65435: PUSH
65436: LD_VAR 0 2
65440: PPUSH
65441: LD_VAR 0 1
65445: PPUSH
65446: CALL_OW 248
65450: PPUSH
65451: CALL_OW 450
65455: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65456: LD_VAR 0 10
65460: PPUSH
65461: LD_INT 1
65463: PPUSH
65464: CALL_OW 275
65468: PUSH
65469: LD_VAR 0 11
65473: PUSH
65474: LD_INT 1
65476: ARRAY
65477: GREATEREQUAL
65478: PUSH
65479: LD_VAR 0 10
65483: PPUSH
65484: LD_INT 2
65486: PPUSH
65487: CALL_OW 275
65491: PUSH
65492: LD_VAR 0 11
65496: PUSH
65497: LD_INT 2
65499: ARRAY
65500: GREATEREQUAL
65501: AND
65502: PUSH
65503: LD_VAR 0 10
65507: PPUSH
65508: LD_INT 3
65510: PPUSH
65511: CALL_OW 275
65515: PUSH
65516: LD_VAR 0 11
65520: PUSH
65521: LD_INT 3
65523: ARRAY
65524: GREATEREQUAL
65525: AND
65526: NOT
65527: IFFALSE 65531
// exit ;
65529: GO 66118
// if GetBType ( depot ) = b_depot then
65531: LD_VAR 0 1
65535: PPUSH
65536: CALL_OW 266
65540: PUSH
65541: LD_INT 0
65543: EQUAL
65544: IFFALSE 65556
// dist := 28 else
65546: LD_ADDR_VAR 0 14
65550: PUSH
65551: LD_INT 28
65553: ST_TO_ADDR
65554: GO 65564
// dist := 36 ;
65556: LD_ADDR_VAR 0 14
65560: PUSH
65561: LD_INT 36
65563: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65564: LD_VAR 0 1
65568: PPUSH
65569: LD_VAR 0 3
65573: PPUSH
65574: LD_VAR 0 4
65578: PPUSH
65579: CALL_OW 297
65583: PUSH
65584: LD_VAR 0 14
65588: GREATER
65589: IFFALSE 65593
// exit ;
65591: GO 66118
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65593: LD_ADDR_VAR 0 12
65597: PUSH
65598: LD_VAR 0 2
65602: PPUSH
65603: LD_VAR 0 3
65607: PPUSH
65608: LD_VAR 0 4
65612: PPUSH
65613: LD_VAR 0 5
65617: PPUSH
65618: LD_VAR 0 1
65622: PPUSH
65623: CALL_OW 248
65627: PPUSH
65628: LD_INT 0
65630: PPUSH
65631: CALL 66123 0 6
65635: ST_TO_ADDR
// if not hexes then
65636: LD_VAR 0 12
65640: NOT
65641: IFFALSE 65645
// exit ;
65643: GO 66118
// hex := GetHexInfo ( x , y ) ;
65645: LD_ADDR_VAR 0 15
65649: PUSH
65650: LD_VAR 0 3
65654: PPUSH
65655: LD_VAR 0 4
65659: PPUSH
65660: CALL_OW 546
65664: ST_TO_ADDR
// if hex [ 1 ] then
65665: LD_VAR 0 15
65669: PUSH
65670: LD_INT 1
65672: ARRAY
65673: IFFALSE 65677
// exit ;
65675: GO 66118
// height := hex [ 2 ] ;
65677: LD_ADDR_VAR 0 13
65681: PUSH
65682: LD_VAR 0 15
65686: PUSH
65687: LD_INT 2
65689: ARRAY
65690: ST_TO_ADDR
// for i = 1 to hexes do
65691: LD_ADDR_VAR 0 7
65695: PUSH
65696: DOUBLE
65697: LD_INT 1
65699: DEC
65700: ST_TO_ADDR
65701: LD_VAR 0 12
65705: PUSH
65706: FOR_TO
65707: IFFALSE 66037
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65709: LD_VAR 0 12
65713: PUSH
65714: LD_VAR 0 7
65718: ARRAY
65719: PUSH
65720: LD_INT 1
65722: ARRAY
65723: PPUSH
65724: LD_VAR 0 12
65728: PUSH
65729: LD_VAR 0 7
65733: ARRAY
65734: PUSH
65735: LD_INT 2
65737: ARRAY
65738: PPUSH
65739: CALL_OW 488
65743: NOT
65744: PUSH
65745: LD_VAR 0 12
65749: PUSH
65750: LD_VAR 0 7
65754: ARRAY
65755: PUSH
65756: LD_INT 1
65758: ARRAY
65759: PPUSH
65760: LD_VAR 0 12
65764: PUSH
65765: LD_VAR 0 7
65769: ARRAY
65770: PUSH
65771: LD_INT 2
65773: ARRAY
65774: PPUSH
65775: CALL_OW 428
65779: PUSH
65780: LD_INT 0
65782: GREATER
65783: OR
65784: PUSH
65785: LD_VAR 0 12
65789: PUSH
65790: LD_VAR 0 7
65794: ARRAY
65795: PUSH
65796: LD_INT 1
65798: ARRAY
65799: PPUSH
65800: LD_VAR 0 12
65804: PUSH
65805: LD_VAR 0 7
65809: ARRAY
65810: PUSH
65811: LD_INT 2
65813: ARRAY
65814: PPUSH
65815: CALL_OW 351
65819: OR
65820: IFFALSE 65826
// exit ;
65822: POP
65823: POP
65824: GO 66118
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65826: LD_ADDR_VAR 0 8
65830: PUSH
65831: LD_VAR 0 12
65835: PUSH
65836: LD_VAR 0 7
65840: ARRAY
65841: PUSH
65842: LD_INT 1
65844: ARRAY
65845: PPUSH
65846: LD_VAR 0 12
65850: PUSH
65851: LD_VAR 0 7
65855: ARRAY
65856: PUSH
65857: LD_INT 2
65859: ARRAY
65860: PPUSH
65861: CALL_OW 546
65865: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65866: LD_VAR 0 8
65870: PUSH
65871: LD_INT 1
65873: ARRAY
65874: PUSH
65875: LD_VAR 0 8
65879: PUSH
65880: LD_INT 2
65882: ARRAY
65883: PUSH
65884: LD_VAR 0 13
65888: PUSH
65889: LD_INT 2
65891: PLUS
65892: GREATER
65893: OR
65894: PUSH
65895: LD_VAR 0 8
65899: PUSH
65900: LD_INT 2
65902: ARRAY
65903: PUSH
65904: LD_VAR 0 13
65908: PUSH
65909: LD_INT 2
65911: MINUS
65912: LESS
65913: OR
65914: PUSH
65915: LD_VAR 0 8
65919: PUSH
65920: LD_INT 3
65922: ARRAY
65923: PUSH
65924: LD_INT 0
65926: PUSH
65927: LD_INT 8
65929: PUSH
65930: LD_INT 9
65932: PUSH
65933: LD_INT 10
65935: PUSH
65936: LD_INT 11
65938: PUSH
65939: LD_INT 12
65941: PUSH
65942: LD_INT 13
65944: PUSH
65945: LD_INT 16
65947: PUSH
65948: LD_INT 17
65950: PUSH
65951: LD_INT 18
65953: PUSH
65954: LD_INT 19
65956: PUSH
65957: LD_INT 20
65959: PUSH
65960: LD_INT 21
65962: PUSH
65963: EMPTY
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: LIST
65971: LIST
65972: LIST
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: IN
65978: NOT
65979: OR
65980: PUSH
65981: LD_VAR 0 8
65985: PUSH
65986: LD_INT 5
65988: ARRAY
65989: NOT
65990: OR
65991: PUSH
65992: LD_VAR 0 8
65996: PUSH
65997: LD_INT 6
65999: ARRAY
66000: PUSH
66001: LD_INT 1
66003: PUSH
66004: LD_INT 2
66006: PUSH
66007: LD_INT 7
66009: PUSH
66010: LD_INT 9
66012: PUSH
66013: LD_INT 10
66015: PUSH
66016: LD_INT 11
66018: PUSH
66019: EMPTY
66020: LIST
66021: LIST
66022: LIST
66023: LIST
66024: LIST
66025: LIST
66026: IN
66027: NOT
66028: OR
66029: IFFALSE 66035
// exit ;
66031: POP
66032: POP
66033: GO 66118
// end ;
66035: GO 65706
66037: POP
66038: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66039: LD_VAR 0 9
66043: PPUSH
66044: LD_VAR 0 3
66048: PPUSH
66049: LD_VAR 0 4
66053: PPUSH
66054: LD_INT 20
66056: PPUSH
66057: CALL 58070 0 4
66061: PUSH
66062: LD_INT 4
66064: ARRAY
66065: IFFALSE 66069
// exit ;
66067: GO 66118
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
66069: LD_VAR 0 2
66073: PUSH
66074: LD_INT 29
66076: PUSH
66077: LD_INT 30
66079: PUSH
66080: EMPTY
66081: LIST
66082: LIST
66083: IN
66084: PUSH
66085: LD_VAR 0 3
66089: PPUSH
66090: LD_VAR 0 4
66094: PPUSH
66095: LD_VAR 0 9
66099: PPUSH
66100: CALL_OW 440
66104: NOT
66105: AND
66106: IFFALSE 66110
// exit ;
66108: GO 66118
// result := true ;
66110: LD_ADDR_VAR 0 6
66114: PUSH
66115: LD_INT 1
66117: ST_TO_ADDR
// end ;
66118: LD_VAR 0 6
66122: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
66123: LD_INT 0
66125: PPUSH
66126: PPUSH
66127: PPUSH
66128: PPUSH
66129: PPUSH
66130: PPUSH
66131: PPUSH
66132: PPUSH
66133: PPUSH
66134: PPUSH
66135: PPUSH
66136: PPUSH
66137: PPUSH
66138: PPUSH
66139: PPUSH
66140: PPUSH
66141: PPUSH
66142: PPUSH
66143: PPUSH
66144: PPUSH
66145: PPUSH
66146: PPUSH
66147: PPUSH
66148: PPUSH
66149: PPUSH
66150: PPUSH
66151: PPUSH
66152: PPUSH
66153: PPUSH
66154: PPUSH
66155: PPUSH
66156: PPUSH
66157: PPUSH
66158: PPUSH
66159: PPUSH
66160: PPUSH
66161: PPUSH
66162: PPUSH
66163: PPUSH
66164: PPUSH
66165: PPUSH
66166: PPUSH
66167: PPUSH
66168: PPUSH
66169: PPUSH
66170: PPUSH
66171: PPUSH
66172: PPUSH
66173: PPUSH
66174: PPUSH
66175: PPUSH
66176: PPUSH
66177: PPUSH
66178: PPUSH
66179: PPUSH
66180: PPUSH
66181: PPUSH
66182: PPUSH
// result = [ ] ;
66183: LD_ADDR_VAR 0 7
66187: PUSH
66188: EMPTY
66189: ST_TO_ADDR
// temp_list = [ ] ;
66190: LD_ADDR_VAR 0 9
66194: PUSH
66195: EMPTY
66196: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66197: LD_VAR 0 4
66201: PUSH
66202: LD_INT 0
66204: PUSH
66205: LD_INT 1
66207: PUSH
66208: LD_INT 2
66210: PUSH
66211: LD_INT 3
66213: PUSH
66214: LD_INT 4
66216: PUSH
66217: LD_INT 5
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: IN
66228: NOT
66229: PUSH
66230: LD_VAR 0 1
66234: PUSH
66235: LD_INT 0
66237: PUSH
66238: LD_INT 1
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: IN
66245: PUSH
66246: LD_VAR 0 5
66250: PUSH
66251: LD_INT 1
66253: PUSH
66254: LD_INT 2
66256: PUSH
66257: LD_INT 3
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: LIST
66264: IN
66265: NOT
66266: AND
66267: OR
66268: IFFALSE 66272
// exit ;
66270: GO 84663
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66272: LD_VAR 0 1
66276: PUSH
66277: LD_INT 6
66279: PUSH
66280: LD_INT 7
66282: PUSH
66283: LD_INT 8
66285: PUSH
66286: LD_INT 13
66288: PUSH
66289: LD_INT 12
66291: PUSH
66292: LD_INT 15
66294: PUSH
66295: LD_INT 11
66297: PUSH
66298: LD_INT 14
66300: PUSH
66301: LD_INT 10
66303: PUSH
66304: EMPTY
66305: LIST
66306: LIST
66307: LIST
66308: LIST
66309: LIST
66310: LIST
66311: LIST
66312: LIST
66313: LIST
66314: IN
66315: IFFALSE 66325
// btype = b_lab ;
66317: LD_ADDR_VAR 0 1
66321: PUSH
66322: LD_INT 6
66324: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66325: LD_VAR 0 6
66329: PUSH
66330: LD_INT 0
66332: PUSH
66333: LD_INT 1
66335: PUSH
66336: LD_INT 2
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: LIST
66343: IN
66344: NOT
66345: PUSH
66346: LD_VAR 0 1
66350: PUSH
66351: LD_INT 0
66353: PUSH
66354: LD_INT 1
66356: PUSH
66357: LD_INT 2
66359: PUSH
66360: LD_INT 3
66362: PUSH
66363: LD_INT 6
66365: PUSH
66366: LD_INT 36
66368: PUSH
66369: LD_INT 4
66371: PUSH
66372: LD_INT 5
66374: PUSH
66375: LD_INT 31
66377: PUSH
66378: LD_INT 32
66380: PUSH
66381: LD_INT 33
66383: PUSH
66384: EMPTY
66385: LIST
66386: LIST
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: LIST
66396: IN
66397: NOT
66398: PUSH
66399: LD_VAR 0 6
66403: PUSH
66404: LD_INT 1
66406: EQUAL
66407: AND
66408: OR
66409: PUSH
66410: LD_VAR 0 1
66414: PUSH
66415: LD_INT 2
66417: PUSH
66418: LD_INT 3
66420: PUSH
66421: EMPTY
66422: LIST
66423: LIST
66424: IN
66425: NOT
66426: PUSH
66427: LD_VAR 0 6
66431: PUSH
66432: LD_INT 2
66434: EQUAL
66435: AND
66436: OR
66437: IFFALSE 66447
// mode = 0 ;
66439: LD_ADDR_VAR 0 6
66443: PUSH
66444: LD_INT 0
66446: ST_TO_ADDR
// case mode of 0 :
66447: LD_VAR 0 6
66451: PUSH
66452: LD_INT 0
66454: DOUBLE
66455: EQUAL
66456: IFTRUE 66460
66458: GO 77913
66460: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66461: LD_ADDR_VAR 0 11
66465: PUSH
66466: LD_INT 0
66468: PUSH
66469: LD_INT 0
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 0
66478: PUSH
66479: LD_INT 1
66481: NEG
66482: PUSH
66483: EMPTY
66484: LIST
66485: LIST
66486: PUSH
66487: LD_INT 1
66489: PUSH
66490: LD_INT 0
66492: PUSH
66493: EMPTY
66494: LIST
66495: LIST
66496: PUSH
66497: LD_INT 1
66499: PUSH
66500: LD_INT 1
66502: PUSH
66503: EMPTY
66504: LIST
66505: LIST
66506: PUSH
66507: LD_INT 0
66509: PUSH
66510: LD_INT 1
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PUSH
66517: LD_INT 1
66519: NEG
66520: PUSH
66521: LD_INT 0
66523: PUSH
66524: EMPTY
66525: LIST
66526: LIST
66527: PUSH
66528: LD_INT 1
66530: NEG
66531: PUSH
66532: LD_INT 1
66534: NEG
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 1
66542: NEG
66543: PUSH
66544: LD_INT 2
66546: NEG
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 0
66554: PUSH
66555: LD_INT 2
66557: NEG
66558: PUSH
66559: EMPTY
66560: LIST
66561: LIST
66562: PUSH
66563: LD_INT 1
66565: PUSH
66566: LD_INT 1
66568: NEG
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PUSH
66574: LD_INT 1
66576: PUSH
66577: LD_INT 2
66579: PUSH
66580: EMPTY
66581: LIST
66582: LIST
66583: PUSH
66584: LD_INT 0
66586: PUSH
66587: LD_INT 2
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PUSH
66594: LD_INT 1
66596: NEG
66597: PUSH
66598: LD_INT 1
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PUSH
66605: LD_INT 1
66607: PUSH
66608: LD_INT 3
66610: PUSH
66611: EMPTY
66612: LIST
66613: LIST
66614: PUSH
66615: LD_INT 0
66617: PUSH
66618: LD_INT 3
66620: PUSH
66621: EMPTY
66622: LIST
66623: LIST
66624: PUSH
66625: LD_INT 1
66627: NEG
66628: PUSH
66629: LD_INT 2
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PUSH
66636: EMPTY
66637: LIST
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66654: LD_ADDR_VAR 0 12
66658: PUSH
66659: LD_INT 0
66661: PUSH
66662: LD_INT 0
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: PUSH
66669: LD_INT 0
66671: PUSH
66672: LD_INT 1
66674: NEG
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: PUSH
66680: LD_INT 1
66682: PUSH
66683: LD_INT 0
66685: PUSH
66686: EMPTY
66687: LIST
66688: LIST
66689: PUSH
66690: LD_INT 1
66692: PUSH
66693: LD_INT 1
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: LD_INT 0
66702: PUSH
66703: LD_INT 1
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: LD_INT 1
66712: NEG
66713: PUSH
66714: LD_INT 0
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: LD_INT 1
66723: NEG
66724: PUSH
66725: LD_INT 1
66727: NEG
66728: PUSH
66729: EMPTY
66730: LIST
66731: LIST
66732: PUSH
66733: LD_INT 1
66735: PUSH
66736: LD_INT 1
66738: NEG
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: PUSH
66744: LD_INT 2
66746: PUSH
66747: LD_INT 0
66749: PUSH
66750: EMPTY
66751: LIST
66752: LIST
66753: PUSH
66754: LD_INT 2
66756: PUSH
66757: LD_INT 1
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PUSH
66764: LD_INT 1
66766: NEG
66767: PUSH
66768: LD_INT 1
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: PUSH
66775: LD_INT 2
66777: NEG
66778: PUSH
66779: LD_INT 0
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: PUSH
66786: LD_INT 2
66788: NEG
66789: PUSH
66790: LD_INT 1
66792: NEG
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 2
66800: NEG
66801: PUSH
66802: LD_INT 1
66804: PUSH
66805: EMPTY
66806: LIST
66807: LIST
66808: PUSH
66809: LD_INT 3
66811: NEG
66812: PUSH
66813: LD_INT 0
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 3
66822: NEG
66823: PUSH
66824: LD_INT 1
66826: NEG
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: LIST
66836: LIST
66837: LIST
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66850: LD_ADDR_VAR 0 13
66854: PUSH
66855: LD_INT 0
66857: PUSH
66858: LD_INT 0
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 0
66867: PUSH
66868: LD_INT 1
66870: NEG
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: PUSH
66876: LD_INT 1
66878: PUSH
66879: LD_INT 0
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: LD_INT 1
66888: PUSH
66889: LD_INT 1
66891: PUSH
66892: EMPTY
66893: LIST
66894: LIST
66895: PUSH
66896: LD_INT 0
66898: PUSH
66899: LD_INT 1
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 1
66908: NEG
66909: PUSH
66910: LD_INT 0
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: LD_INT 1
66919: NEG
66920: PUSH
66921: LD_INT 1
66923: NEG
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 1
66931: NEG
66932: PUSH
66933: LD_INT 2
66935: NEG
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 2
66943: PUSH
66944: LD_INT 1
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: PUSH
66951: LD_INT 2
66953: PUSH
66954: LD_INT 2
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: PUSH
66961: LD_INT 1
66963: PUSH
66964: LD_INT 2
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PUSH
66971: LD_INT 2
66973: NEG
66974: PUSH
66975: LD_INT 1
66977: NEG
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 2
66985: NEG
66986: PUSH
66987: LD_INT 2
66989: NEG
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: LD_INT 2
66997: NEG
66998: PUSH
66999: LD_INT 3
67001: NEG
67002: PUSH
67003: EMPTY
67004: LIST
67005: LIST
67006: PUSH
67007: LD_INT 3
67009: NEG
67010: PUSH
67011: LD_INT 2
67013: NEG
67014: PUSH
67015: EMPTY
67016: LIST
67017: LIST
67018: PUSH
67019: LD_INT 3
67021: NEG
67022: PUSH
67023: LD_INT 3
67025: NEG
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67049: LD_ADDR_VAR 0 14
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: LD_INT 0
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: LD_INT 0
67066: PUSH
67067: LD_INT 1
67069: NEG
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 1
67077: PUSH
67078: LD_INT 0
67080: PUSH
67081: EMPTY
67082: LIST
67083: LIST
67084: PUSH
67085: LD_INT 1
67087: PUSH
67088: LD_INT 1
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: PUSH
67095: LD_INT 0
67097: PUSH
67098: LD_INT 1
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: PUSH
67105: LD_INT 1
67107: NEG
67108: PUSH
67109: LD_INT 0
67111: PUSH
67112: EMPTY
67113: LIST
67114: LIST
67115: PUSH
67116: LD_INT 1
67118: NEG
67119: PUSH
67120: LD_INT 1
67122: NEG
67123: PUSH
67124: EMPTY
67125: LIST
67126: LIST
67127: PUSH
67128: LD_INT 1
67130: NEG
67131: PUSH
67132: LD_INT 2
67134: NEG
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 0
67142: PUSH
67143: LD_INT 2
67145: NEG
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: PUSH
67151: LD_INT 1
67153: PUSH
67154: LD_INT 1
67156: NEG
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PUSH
67162: LD_INT 1
67164: PUSH
67165: LD_INT 2
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PUSH
67172: LD_INT 0
67174: PUSH
67175: LD_INT 2
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 1
67184: NEG
67185: PUSH
67186: LD_INT 1
67188: PUSH
67189: EMPTY
67190: LIST
67191: LIST
67192: PUSH
67193: LD_INT 1
67195: NEG
67196: PUSH
67197: LD_INT 3
67199: NEG
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 0
67207: PUSH
67208: LD_INT 3
67210: NEG
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: LD_INT 1
67218: PUSH
67219: LD_INT 2
67221: NEG
67222: PUSH
67223: EMPTY
67224: LIST
67225: LIST
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: LIST
67231: LIST
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67245: LD_ADDR_VAR 0 15
67249: PUSH
67250: LD_INT 0
67252: PUSH
67253: LD_INT 0
67255: PUSH
67256: EMPTY
67257: LIST
67258: LIST
67259: PUSH
67260: LD_INT 0
67262: PUSH
67263: LD_INT 1
67265: NEG
67266: PUSH
67267: EMPTY
67268: LIST
67269: LIST
67270: PUSH
67271: LD_INT 1
67273: PUSH
67274: LD_INT 0
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PUSH
67281: LD_INT 1
67283: PUSH
67284: LD_INT 1
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: PUSH
67291: LD_INT 0
67293: PUSH
67294: LD_INT 1
67296: PUSH
67297: EMPTY
67298: LIST
67299: LIST
67300: PUSH
67301: LD_INT 1
67303: NEG
67304: PUSH
67305: LD_INT 0
67307: PUSH
67308: EMPTY
67309: LIST
67310: LIST
67311: PUSH
67312: LD_INT 1
67314: NEG
67315: PUSH
67316: LD_INT 1
67318: NEG
67319: PUSH
67320: EMPTY
67321: LIST
67322: LIST
67323: PUSH
67324: LD_INT 1
67326: PUSH
67327: LD_INT 1
67329: NEG
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: PUSH
67335: LD_INT 2
67337: PUSH
67338: LD_INT 0
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 2
67347: PUSH
67348: LD_INT 1
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 1
67357: NEG
67358: PUSH
67359: LD_INT 1
67361: PUSH
67362: EMPTY
67363: LIST
67364: LIST
67365: PUSH
67366: LD_INT 2
67368: NEG
67369: PUSH
67370: LD_INT 0
67372: PUSH
67373: EMPTY
67374: LIST
67375: LIST
67376: PUSH
67377: LD_INT 2
67379: NEG
67380: PUSH
67381: LD_INT 1
67383: NEG
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: PUSH
67389: LD_INT 2
67391: PUSH
67392: LD_INT 1
67394: NEG
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 3
67402: PUSH
67403: LD_INT 0
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 3
67412: PUSH
67413: LD_INT 1
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: EMPTY
67421: LIST
67422: LIST
67423: LIST
67424: LIST
67425: LIST
67426: LIST
67427: LIST
67428: LIST
67429: LIST
67430: LIST
67431: LIST
67432: LIST
67433: LIST
67434: LIST
67435: LIST
67436: LIST
67437: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67438: LD_ADDR_VAR 0 16
67442: PUSH
67443: LD_INT 0
67445: PUSH
67446: LD_INT 0
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 0
67455: PUSH
67456: LD_INT 1
67458: NEG
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 1
67466: PUSH
67467: LD_INT 0
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 1
67476: PUSH
67477: LD_INT 1
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: LD_INT 0
67486: PUSH
67487: LD_INT 1
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 1
67496: NEG
67497: PUSH
67498: LD_INT 0
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: PUSH
67505: LD_INT 1
67507: NEG
67508: PUSH
67509: LD_INT 1
67511: NEG
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 1
67519: NEG
67520: PUSH
67521: LD_INT 2
67523: NEG
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: PUSH
67529: LD_INT 2
67531: PUSH
67532: LD_INT 1
67534: PUSH
67535: EMPTY
67536: LIST
67537: LIST
67538: PUSH
67539: LD_INT 2
67541: PUSH
67542: LD_INT 2
67544: PUSH
67545: EMPTY
67546: LIST
67547: LIST
67548: PUSH
67549: LD_INT 1
67551: PUSH
67552: LD_INT 2
67554: PUSH
67555: EMPTY
67556: LIST
67557: LIST
67558: PUSH
67559: LD_INT 2
67561: NEG
67562: PUSH
67563: LD_INT 1
67565: NEG
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 2
67573: NEG
67574: PUSH
67575: LD_INT 2
67577: NEG
67578: PUSH
67579: EMPTY
67580: LIST
67581: LIST
67582: PUSH
67583: LD_INT 3
67585: PUSH
67586: LD_INT 2
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PUSH
67593: LD_INT 3
67595: PUSH
67596: LD_INT 3
67598: PUSH
67599: EMPTY
67600: LIST
67601: LIST
67602: PUSH
67603: LD_INT 2
67605: PUSH
67606: LD_INT 3
67608: PUSH
67609: EMPTY
67610: LIST
67611: LIST
67612: PUSH
67613: EMPTY
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67631: LD_ADDR_VAR 0 17
67635: PUSH
67636: LD_INT 0
67638: PUSH
67639: LD_INT 0
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: LD_INT 0
67648: PUSH
67649: LD_INT 1
67651: NEG
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: LD_INT 1
67659: PUSH
67660: LD_INT 0
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: LD_INT 1
67669: PUSH
67670: LD_INT 1
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: PUSH
67677: LD_INT 0
67679: PUSH
67680: LD_INT 1
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PUSH
67687: LD_INT 1
67689: NEG
67690: PUSH
67691: LD_INT 0
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: LD_INT 1
67700: NEG
67701: PUSH
67702: LD_INT 1
67704: NEG
67705: PUSH
67706: EMPTY
67707: LIST
67708: LIST
67709: PUSH
67710: LD_INT 1
67712: NEG
67713: PUSH
67714: LD_INT 2
67716: NEG
67717: PUSH
67718: EMPTY
67719: LIST
67720: LIST
67721: PUSH
67722: LD_INT 0
67724: PUSH
67725: LD_INT 2
67727: NEG
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: PUSH
67733: LD_INT 1
67735: PUSH
67736: LD_INT 1
67738: NEG
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: LD_INT 2
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 2
67756: PUSH
67757: LD_INT 1
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PUSH
67764: LD_INT 2
67766: PUSH
67767: LD_INT 2
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 1
67776: PUSH
67777: LD_INT 2
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 0
67786: PUSH
67787: LD_INT 2
67789: PUSH
67790: EMPTY
67791: LIST
67792: LIST
67793: PUSH
67794: LD_INT 1
67796: NEG
67797: PUSH
67798: LD_INT 1
67800: PUSH
67801: EMPTY
67802: LIST
67803: LIST
67804: PUSH
67805: LD_INT 2
67807: NEG
67808: PUSH
67809: LD_INT 0
67811: PUSH
67812: EMPTY
67813: LIST
67814: LIST
67815: PUSH
67816: LD_INT 2
67818: NEG
67819: PUSH
67820: LD_INT 1
67822: NEG
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: PUSH
67828: LD_INT 2
67830: NEG
67831: PUSH
67832: LD_INT 2
67834: NEG
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: PUSH
67840: EMPTY
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67861: LD_ADDR_VAR 0 18
67865: PUSH
67866: LD_INT 0
67868: PUSH
67869: LD_INT 0
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PUSH
67876: LD_INT 0
67878: PUSH
67879: LD_INT 1
67881: NEG
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: PUSH
67887: LD_INT 1
67889: PUSH
67890: LD_INT 0
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PUSH
67897: LD_INT 1
67899: PUSH
67900: LD_INT 1
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: LD_INT 0
67909: PUSH
67910: LD_INT 1
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: PUSH
67917: LD_INT 1
67919: NEG
67920: PUSH
67921: LD_INT 0
67923: PUSH
67924: EMPTY
67925: LIST
67926: LIST
67927: PUSH
67928: LD_INT 1
67930: NEG
67931: PUSH
67932: LD_INT 1
67934: NEG
67935: PUSH
67936: EMPTY
67937: LIST
67938: LIST
67939: PUSH
67940: LD_INT 1
67942: NEG
67943: PUSH
67944: LD_INT 2
67946: NEG
67947: PUSH
67948: EMPTY
67949: LIST
67950: LIST
67951: PUSH
67952: LD_INT 0
67954: PUSH
67955: LD_INT 2
67957: NEG
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: LD_INT 1
67965: PUSH
67966: LD_INT 1
67968: NEG
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 2
67976: PUSH
67977: LD_INT 0
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 2
67986: PUSH
67987: LD_INT 1
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 2
67996: PUSH
67997: LD_INT 2
67999: PUSH
68000: EMPTY
68001: LIST
68002: LIST
68003: PUSH
68004: LD_INT 1
68006: PUSH
68007: LD_INT 2
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: PUSH
68014: LD_INT 0
68016: PUSH
68017: LD_INT 2
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PUSH
68024: LD_INT 1
68026: NEG
68027: PUSH
68028: LD_INT 1
68030: PUSH
68031: EMPTY
68032: LIST
68033: LIST
68034: PUSH
68035: LD_INT 2
68037: NEG
68038: PUSH
68039: LD_INT 0
68041: PUSH
68042: EMPTY
68043: LIST
68044: LIST
68045: PUSH
68046: LD_INT 2
68048: NEG
68049: PUSH
68050: LD_INT 1
68052: NEG
68053: PUSH
68054: EMPTY
68055: LIST
68056: LIST
68057: PUSH
68058: LD_INT 2
68060: NEG
68061: PUSH
68062: LD_INT 2
68064: NEG
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68091: LD_ADDR_VAR 0 19
68095: PUSH
68096: LD_INT 0
68098: PUSH
68099: LD_INT 0
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PUSH
68106: LD_INT 0
68108: PUSH
68109: LD_INT 1
68111: NEG
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: LD_INT 1
68119: PUSH
68120: LD_INT 0
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: PUSH
68127: LD_INT 1
68129: PUSH
68130: LD_INT 1
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: PUSH
68137: LD_INT 0
68139: PUSH
68140: LD_INT 1
68142: PUSH
68143: EMPTY
68144: LIST
68145: LIST
68146: PUSH
68147: LD_INT 1
68149: NEG
68150: PUSH
68151: LD_INT 0
68153: PUSH
68154: EMPTY
68155: LIST
68156: LIST
68157: PUSH
68158: LD_INT 1
68160: NEG
68161: PUSH
68162: LD_INT 1
68164: NEG
68165: PUSH
68166: EMPTY
68167: LIST
68168: LIST
68169: PUSH
68170: LD_INT 1
68172: NEG
68173: PUSH
68174: LD_INT 2
68176: NEG
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: PUSH
68182: LD_INT 0
68184: PUSH
68185: LD_INT 2
68187: NEG
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 1
68195: PUSH
68196: LD_INT 1
68198: NEG
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 2
68206: PUSH
68207: LD_INT 0
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 2
68216: PUSH
68217: LD_INT 1
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 2
68226: PUSH
68227: LD_INT 2
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 1
68236: PUSH
68237: LD_INT 2
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 0
68246: PUSH
68247: LD_INT 2
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PUSH
68254: LD_INT 1
68256: NEG
68257: PUSH
68258: LD_INT 1
68260: PUSH
68261: EMPTY
68262: LIST
68263: LIST
68264: PUSH
68265: LD_INT 2
68267: NEG
68268: PUSH
68269: LD_INT 0
68271: PUSH
68272: EMPTY
68273: LIST
68274: LIST
68275: PUSH
68276: LD_INT 2
68278: NEG
68279: PUSH
68280: LD_INT 1
68282: NEG
68283: PUSH
68284: EMPTY
68285: LIST
68286: LIST
68287: PUSH
68288: LD_INT 2
68290: NEG
68291: PUSH
68292: LD_INT 2
68294: NEG
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68321: LD_ADDR_VAR 0 20
68325: PUSH
68326: LD_INT 0
68328: PUSH
68329: LD_INT 0
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 0
68338: PUSH
68339: LD_INT 1
68341: NEG
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: PUSH
68347: LD_INT 1
68349: PUSH
68350: LD_INT 0
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 1
68359: PUSH
68360: LD_INT 1
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 0
68369: PUSH
68370: LD_INT 1
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 1
68379: NEG
68380: PUSH
68381: LD_INT 0
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 1
68390: NEG
68391: PUSH
68392: LD_INT 1
68394: NEG
68395: PUSH
68396: EMPTY
68397: LIST
68398: LIST
68399: PUSH
68400: LD_INT 1
68402: NEG
68403: PUSH
68404: LD_INT 2
68406: NEG
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 0
68414: PUSH
68415: LD_INT 2
68417: NEG
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 1
68425: PUSH
68426: LD_INT 1
68428: NEG
68429: PUSH
68430: EMPTY
68431: LIST
68432: LIST
68433: PUSH
68434: LD_INT 2
68436: PUSH
68437: LD_INT 0
68439: PUSH
68440: EMPTY
68441: LIST
68442: LIST
68443: PUSH
68444: LD_INT 2
68446: PUSH
68447: LD_INT 1
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: LD_INT 2
68456: PUSH
68457: LD_INT 2
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 1
68466: PUSH
68467: LD_INT 2
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 0
68476: PUSH
68477: LD_INT 2
68479: PUSH
68480: EMPTY
68481: LIST
68482: LIST
68483: PUSH
68484: LD_INT 1
68486: NEG
68487: PUSH
68488: LD_INT 1
68490: PUSH
68491: EMPTY
68492: LIST
68493: LIST
68494: PUSH
68495: LD_INT 2
68497: NEG
68498: PUSH
68499: LD_INT 0
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: PUSH
68506: LD_INT 2
68508: NEG
68509: PUSH
68510: LD_INT 1
68512: NEG
68513: PUSH
68514: EMPTY
68515: LIST
68516: LIST
68517: PUSH
68518: LD_INT 2
68520: NEG
68521: PUSH
68522: LD_INT 2
68524: NEG
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: LIST
68540: LIST
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: LIST
68546: LIST
68547: LIST
68548: LIST
68549: LIST
68550: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68551: LD_ADDR_VAR 0 21
68555: PUSH
68556: LD_INT 0
68558: PUSH
68559: LD_INT 0
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: PUSH
68566: LD_INT 0
68568: PUSH
68569: LD_INT 1
68571: NEG
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: PUSH
68577: LD_INT 1
68579: PUSH
68580: LD_INT 0
68582: PUSH
68583: EMPTY
68584: LIST
68585: LIST
68586: PUSH
68587: LD_INT 1
68589: PUSH
68590: LD_INT 1
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: PUSH
68597: LD_INT 0
68599: PUSH
68600: LD_INT 1
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 1
68609: NEG
68610: PUSH
68611: LD_INT 0
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: PUSH
68618: LD_INT 1
68620: NEG
68621: PUSH
68622: LD_INT 1
68624: NEG
68625: PUSH
68626: EMPTY
68627: LIST
68628: LIST
68629: PUSH
68630: LD_INT 1
68632: NEG
68633: PUSH
68634: LD_INT 2
68636: NEG
68637: PUSH
68638: EMPTY
68639: LIST
68640: LIST
68641: PUSH
68642: LD_INT 0
68644: PUSH
68645: LD_INT 2
68647: NEG
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 1
68655: PUSH
68656: LD_INT 1
68658: NEG
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 2
68666: PUSH
68667: LD_INT 0
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: PUSH
68674: LD_INT 2
68676: PUSH
68677: LD_INT 1
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: LD_INT 2
68686: PUSH
68687: LD_INT 2
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: LD_INT 1
68696: PUSH
68697: LD_INT 2
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 0
68706: PUSH
68707: LD_INT 2
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: PUSH
68714: LD_INT 1
68716: NEG
68717: PUSH
68718: LD_INT 1
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 2
68727: NEG
68728: PUSH
68729: LD_INT 0
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 2
68738: NEG
68739: PUSH
68740: LD_INT 1
68742: NEG
68743: PUSH
68744: EMPTY
68745: LIST
68746: LIST
68747: PUSH
68748: LD_INT 2
68750: NEG
68751: PUSH
68752: LD_INT 2
68754: NEG
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: LIST
68768: LIST
68769: LIST
68770: LIST
68771: LIST
68772: LIST
68773: LIST
68774: LIST
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: LIST
68780: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68781: LD_ADDR_VAR 0 22
68785: PUSH
68786: LD_INT 0
68788: PUSH
68789: LD_INT 0
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: LD_INT 0
68798: PUSH
68799: LD_INT 1
68801: NEG
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 1
68809: PUSH
68810: LD_INT 0
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 1
68819: PUSH
68820: LD_INT 1
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 0
68829: PUSH
68830: LD_INT 1
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 1
68839: NEG
68840: PUSH
68841: LD_INT 0
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: LD_INT 1
68850: NEG
68851: PUSH
68852: LD_INT 1
68854: NEG
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: LD_INT 1
68862: NEG
68863: PUSH
68864: LD_INT 2
68866: NEG
68867: PUSH
68868: EMPTY
68869: LIST
68870: LIST
68871: PUSH
68872: LD_INT 0
68874: PUSH
68875: LD_INT 2
68877: NEG
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 1
68885: PUSH
68886: LD_INT 1
68888: NEG
68889: PUSH
68890: EMPTY
68891: LIST
68892: LIST
68893: PUSH
68894: LD_INT 2
68896: PUSH
68897: LD_INT 0
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: PUSH
68904: LD_INT 2
68906: PUSH
68907: LD_INT 1
68909: PUSH
68910: EMPTY
68911: LIST
68912: LIST
68913: PUSH
68914: LD_INT 2
68916: PUSH
68917: LD_INT 2
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 1
68926: PUSH
68927: LD_INT 2
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 0
68936: PUSH
68937: LD_INT 2
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 1
68946: NEG
68947: PUSH
68948: LD_INT 1
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 2
68957: NEG
68958: PUSH
68959: LD_INT 0
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: PUSH
68966: LD_INT 2
68968: NEG
68969: PUSH
68970: LD_INT 1
68972: NEG
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: PUSH
68978: LD_INT 2
68980: NEG
68981: PUSH
68982: LD_INT 2
68984: NEG
68985: PUSH
68986: EMPTY
68987: LIST
68988: LIST
68989: PUSH
68990: EMPTY
68991: LIST
68992: LIST
68993: LIST
68994: LIST
68995: LIST
68996: LIST
68997: LIST
68998: LIST
68999: LIST
69000: LIST
69001: LIST
69002: LIST
69003: LIST
69004: LIST
69005: LIST
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69011: LD_ADDR_VAR 0 23
69015: PUSH
69016: LD_INT 0
69018: PUSH
69019: LD_INT 0
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PUSH
69026: LD_INT 0
69028: PUSH
69029: LD_INT 1
69031: NEG
69032: PUSH
69033: EMPTY
69034: LIST
69035: LIST
69036: PUSH
69037: LD_INT 1
69039: PUSH
69040: LD_INT 0
69042: PUSH
69043: EMPTY
69044: LIST
69045: LIST
69046: PUSH
69047: LD_INT 1
69049: PUSH
69050: LD_INT 1
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: LD_INT 0
69059: PUSH
69060: LD_INT 1
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: LD_INT 1
69069: NEG
69070: PUSH
69071: LD_INT 0
69073: PUSH
69074: EMPTY
69075: LIST
69076: LIST
69077: PUSH
69078: LD_INT 1
69080: NEG
69081: PUSH
69082: LD_INT 1
69084: NEG
69085: PUSH
69086: EMPTY
69087: LIST
69088: LIST
69089: PUSH
69090: LD_INT 1
69092: NEG
69093: PUSH
69094: LD_INT 2
69096: NEG
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 0
69104: PUSH
69105: LD_INT 2
69107: NEG
69108: PUSH
69109: EMPTY
69110: LIST
69111: LIST
69112: PUSH
69113: LD_INT 1
69115: PUSH
69116: LD_INT 1
69118: NEG
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: PUSH
69124: LD_INT 2
69126: PUSH
69127: LD_INT 0
69129: PUSH
69130: EMPTY
69131: LIST
69132: LIST
69133: PUSH
69134: LD_INT 2
69136: PUSH
69137: LD_INT 1
69139: PUSH
69140: EMPTY
69141: LIST
69142: LIST
69143: PUSH
69144: LD_INT 2
69146: PUSH
69147: LD_INT 2
69149: PUSH
69150: EMPTY
69151: LIST
69152: LIST
69153: PUSH
69154: LD_INT 1
69156: PUSH
69157: LD_INT 2
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: LD_INT 0
69166: PUSH
69167: LD_INT 2
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: LD_INT 1
69176: NEG
69177: PUSH
69178: LD_INT 1
69180: PUSH
69181: EMPTY
69182: LIST
69183: LIST
69184: PUSH
69185: LD_INT 2
69187: NEG
69188: PUSH
69189: LD_INT 0
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PUSH
69196: LD_INT 2
69198: NEG
69199: PUSH
69200: LD_INT 1
69202: NEG
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 2
69210: NEG
69211: PUSH
69212: LD_INT 2
69214: NEG
69215: PUSH
69216: EMPTY
69217: LIST
69218: LIST
69219: PUSH
69220: LD_INT 2
69222: NEG
69223: PUSH
69224: LD_INT 3
69226: NEG
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 1
69234: NEG
69235: PUSH
69236: LD_INT 3
69238: NEG
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PUSH
69244: LD_INT 1
69246: PUSH
69247: LD_INT 2
69249: NEG
69250: PUSH
69251: EMPTY
69252: LIST
69253: LIST
69254: PUSH
69255: LD_INT 2
69257: PUSH
69258: LD_INT 1
69260: NEG
69261: PUSH
69262: EMPTY
69263: LIST
69264: LIST
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: LIST
69270: LIST
69271: LIST
69272: LIST
69273: LIST
69274: LIST
69275: LIST
69276: LIST
69277: LIST
69278: LIST
69279: LIST
69280: LIST
69281: LIST
69282: LIST
69283: LIST
69284: LIST
69285: LIST
69286: LIST
69287: LIST
69288: LIST
69289: LIST
69290: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69291: LD_ADDR_VAR 0 24
69295: PUSH
69296: LD_INT 0
69298: PUSH
69299: LD_INT 0
69301: PUSH
69302: EMPTY
69303: LIST
69304: LIST
69305: PUSH
69306: LD_INT 0
69308: PUSH
69309: LD_INT 1
69311: NEG
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 1
69319: PUSH
69320: LD_INT 0
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: PUSH
69327: LD_INT 1
69329: PUSH
69330: LD_INT 1
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: LD_INT 0
69339: PUSH
69340: LD_INT 1
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: PUSH
69347: LD_INT 1
69349: NEG
69350: PUSH
69351: LD_INT 0
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: PUSH
69358: LD_INT 1
69360: NEG
69361: PUSH
69362: LD_INT 1
69364: NEG
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: LD_INT 1
69372: NEG
69373: PUSH
69374: LD_INT 2
69376: NEG
69377: PUSH
69378: EMPTY
69379: LIST
69380: LIST
69381: PUSH
69382: LD_INT 0
69384: PUSH
69385: LD_INT 2
69387: NEG
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 1
69395: PUSH
69396: LD_INT 1
69398: NEG
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 2
69406: PUSH
69407: LD_INT 0
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 2
69416: PUSH
69417: LD_INT 1
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: LD_INT 2
69426: PUSH
69427: LD_INT 2
69429: PUSH
69430: EMPTY
69431: LIST
69432: LIST
69433: PUSH
69434: LD_INT 1
69436: PUSH
69437: LD_INT 2
69439: PUSH
69440: EMPTY
69441: LIST
69442: LIST
69443: PUSH
69444: LD_INT 0
69446: PUSH
69447: LD_INT 2
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 1
69456: NEG
69457: PUSH
69458: LD_INT 1
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: PUSH
69465: LD_INT 2
69467: NEG
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 2
69478: NEG
69479: PUSH
69480: LD_INT 1
69482: NEG
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 2
69490: NEG
69491: PUSH
69492: LD_INT 2
69494: NEG
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: LD_INT 1
69502: PUSH
69503: LD_INT 2
69505: NEG
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PUSH
69511: LD_INT 2
69513: PUSH
69514: LD_INT 1
69516: NEG
69517: PUSH
69518: EMPTY
69519: LIST
69520: LIST
69521: PUSH
69522: LD_INT 3
69524: PUSH
69525: LD_INT 1
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 3
69534: PUSH
69535: LD_INT 2
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: LIST
69553: LIST
69554: LIST
69555: LIST
69556: LIST
69557: LIST
69558: LIST
69559: LIST
69560: LIST
69561: LIST
69562: LIST
69563: LIST
69564: LIST
69565: LIST
69566: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69567: LD_ADDR_VAR 0 25
69571: PUSH
69572: LD_INT 0
69574: PUSH
69575: LD_INT 0
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 0
69584: PUSH
69585: LD_INT 1
69587: NEG
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 1
69595: PUSH
69596: LD_INT 0
69598: PUSH
69599: EMPTY
69600: LIST
69601: LIST
69602: PUSH
69603: LD_INT 1
69605: PUSH
69606: LD_INT 1
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 0
69615: PUSH
69616: LD_INT 1
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: PUSH
69623: LD_INT 1
69625: NEG
69626: PUSH
69627: LD_INT 0
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: PUSH
69634: LD_INT 1
69636: NEG
69637: PUSH
69638: LD_INT 1
69640: NEG
69641: PUSH
69642: EMPTY
69643: LIST
69644: LIST
69645: PUSH
69646: LD_INT 1
69648: NEG
69649: PUSH
69650: LD_INT 2
69652: NEG
69653: PUSH
69654: EMPTY
69655: LIST
69656: LIST
69657: PUSH
69658: LD_INT 0
69660: PUSH
69661: LD_INT 2
69663: NEG
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: PUSH
69669: LD_INT 1
69671: PUSH
69672: LD_INT 1
69674: NEG
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 2
69682: PUSH
69683: LD_INT 0
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: LD_INT 2
69692: PUSH
69693: LD_INT 1
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: PUSH
69700: LD_INT 2
69702: PUSH
69703: LD_INT 2
69705: PUSH
69706: EMPTY
69707: LIST
69708: LIST
69709: PUSH
69710: LD_INT 1
69712: PUSH
69713: LD_INT 2
69715: PUSH
69716: EMPTY
69717: LIST
69718: LIST
69719: PUSH
69720: LD_INT 0
69722: PUSH
69723: LD_INT 2
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: LD_INT 1
69732: NEG
69733: PUSH
69734: LD_INT 1
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 2
69743: NEG
69744: PUSH
69745: LD_INT 0
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 2
69754: NEG
69755: PUSH
69756: LD_INT 1
69758: NEG
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 2
69766: NEG
69767: PUSH
69768: LD_INT 2
69770: NEG
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 3
69778: PUSH
69779: LD_INT 1
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: PUSH
69786: LD_INT 3
69788: PUSH
69789: LD_INT 2
69791: PUSH
69792: EMPTY
69793: LIST
69794: LIST
69795: PUSH
69796: LD_INT 2
69798: PUSH
69799: LD_INT 3
69801: PUSH
69802: EMPTY
69803: LIST
69804: LIST
69805: PUSH
69806: LD_INT 1
69808: PUSH
69809: LD_INT 3
69811: PUSH
69812: EMPTY
69813: LIST
69814: LIST
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: LIST
69820: LIST
69821: LIST
69822: LIST
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: LIST
69831: LIST
69832: LIST
69833: LIST
69834: LIST
69835: LIST
69836: LIST
69837: LIST
69838: LIST
69839: LIST
69840: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69841: LD_ADDR_VAR 0 26
69845: PUSH
69846: LD_INT 0
69848: PUSH
69849: LD_INT 0
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: PUSH
69856: LD_INT 0
69858: PUSH
69859: LD_INT 1
69861: NEG
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: PUSH
69867: LD_INT 1
69869: PUSH
69870: LD_INT 0
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 1
69879: PUSH
69880: LD_INT 1
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 0
69889: PUSH
69890: LD_INT 1
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 1
69899: NEG
69900: PUSH
69901: LD_INT 0
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 1
69910: NEG
69911: PUSH
69912: LD_INT 1
69914: NEG
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: PUSH
69920: LD_INT 1
69922: NEG
69923: PUSH
69924: LD_INT 2
69926: NEG
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PUSH
69932: LD_INT 0
69934: PUSH
69935: LD_INT 2
69937: NEG
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 1
69945: PUSH
69946: LD_INT 1
69948: NEG
69949: PUSH
69950: EMPTY
69951: LIST
69952: LIST
69953: PUSH
69954: LD_INT 2
69956: PUSH
69957: LD_INT 0
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: LD_INT 2
69966: PUSH
69967: LD_INT 1
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: PUSH
69974: LD_INT 2
69976: PUSH
69977: LD_INT 2
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: LD_INT 1
69986: PUSH
69987: LD_INT 2
69989: PUSH
69990: EMPTY
69991: LIST
69992: LIST
69993: PUSH
69994: LD_INT 0
69996: PUSH
69997: LD_INT 2
69999: PUSH
70000: EMPTY
70001: LIST
70002: LIST
70003: PUSH
70004: LD_INT 1
70006: NEG
70007: PUSH
70008: LD_INT 1
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: PUSH
70015: LD_INT 2
70017: NEG
70018: PUSH
70019: LD_INT 0
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: PUSH
70026: LD_INT 2
70028: NEG
70029: PUSH
70030: LD_INT 1
70032: NEG
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: PUSH
70038: LD_INT 2
70040: NEG
70041: PUSH
70042: LD_INT 2
70044: NEG
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: LD_INT 2
70052: PUSH
70053: LD_INT 3
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: PUSH
70060: LD_INT 1
70062: PUSH
70063: LD_INT 3
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 1
70072: NEG
70073: PUSH
70074: LD_INT 2
70076: PUSH
70077: EMPTY
70078: LIST
70079: LIST
70080: PUSH
70081: LD_INT 2
70083: NEG
70084: PUSH
70085: LD_INT 1
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: LIST
70096: LIST
70097: LIST
70098: LIST
70099: LIST
70100: LIST
70101: LIST
70102: LIST
70103: LIST
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: LIST
70109: LIST
70110: LIST
70111: LIST
70112: LIST
70113: LIST
70114: LIST
70115: LIST
70116: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70117: LD_ADDR_VAR 0 27
70121: PUSH
70122: LD_INT 0
70124: PUSH
70125: LD_INT 0
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 0
70134: PUSH
70135: LD_INT 1
70137: NEG
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: PUSH
70143: LD_INT 1
70145: PUSH
70146: LD_INT 0
70148: PUSH
70149: EMPTY
70150: LIST
70151: LIST
70152: PUSH
70153: LD_INT 1
70155: PUSH
70156: LD_INT 1
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 0
70165: PUSH
70166: LD_INT 1
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 1
70175: NEG
70176: PUSH
70177: LD_INT 0
70179: PUSH
70180: EMPTY
70181: LIST
70182: LIST
70183: PUSH
70184: LD_INT 1
70186: NEG
70187: PUSH
70188: LD_INT 1
70190: NEG
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 1
70198: NEG
70199: PUSH
70200: LD_INT 2
70202: NEG
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PUSH
70208: LD_INT 0
70210: PUSH
70211: LD_INT 2
70213: NEG
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 1
70221: PUSH
70222: LD_INT 1
70224: NEG
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 2
70232: PUSH
70233: LD_INT 0
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 2
70242: PUSH
70243: LD_INT 1
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: LD_INT 2
70252: PUSH
70253: LD_INT 2
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 1
70262: PUSH
70263: LD_INT 2
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 0
70272: PUSH
70273: LD_INT 2
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 1
70282: NEG
70283: PUSH
70284: LD_INT 1
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: LD_INT 2
70293: NEG
70294: PUSH
70295: LD_INT 0
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: LD_INT 2
70304: NEG
70305: PUSH
70306: LD_INT 1
70308: NEG
70309: PUSH
70310: EMPTY
70311: LIST
70312: LIST
70313: PUSH
70314: LD_INT 2
70316: NEG
70317: PUSH
70318: LD_INT 2
70320: NEG
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 1
70328: NEG
70329: PUSH
70330: LD_INT 2
70332: PUSH
70333: EMPTY
70334: LIST
70335: LIST
70336: PUSH
70337: LD_INT 2
70339: NEG
70340: PUSH
70341: LD_INT 1
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PUSH
70348: LD_INT 3
70350: NEG
70351: PUSH
70352: LD_INT 1
70354: NEG
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 3
70362: NEG
70363: PUSH
70364: LD_INT 2
70366: NEG
70367: PUSH
70368: EMPTY
70369: LIST
70370: LIST
70371: PUSH
70372: EMPTY
70373: LIST
70374: LIST
70375: LIST
70376: LIST
70377: LIST
70378: LIST
70379: LIST
70380: LIST
70381: LIST
70382: LIST
70383: LIST
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: LIST
70389: LIST
70390: LIST
70391: LIST
70392: LIST
70393: LIST
70394: LIST
70395: LIST
70396: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70397: LD_ADDR_VAR 0 28
70401: PUSH
70402: LD_INT 0
70404: PUSH
70405: LD_INT 0
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: PUSH
70412: LD_INT 0
70414: PUSH
70415: LD_INT 1
70417: NEG
70418: PUSH
70419: EMPTY
70420: LIST
70421: LIST
70422: PUSH
70423: LD_INT 1
70425: PUSH
70426: LD_INT 0
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: LD_INT 1
70435: PUSH
70436: LD_INT 1
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 0
70445: PUSH
70446: LD_INT 1
70448: PUSH
70449: EMPTY
70450: LIST
70451: LIST
70452: PUSH
70453: LD_INT 1
70455: NEG
70456: PUSH
70457: LD_INT 0
70459: PUSH
70460: EMPTY
70461: LIST
70462: LIST
70463: PUSH
70464: LD_INT 1
70466: NEG
70467: PUSH
70468: LD_INT 1
70470: NEG
70471: PUSH
70472: EMPTY
70473: LIST
70474: LIST
70475: PUSH
70476: LD_INT 1
70478: NEG
70479: PUSH
70480: LD_INT 2
70482: NEG
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: PUSH
70488: LD_INT 0
70490: PUSH
70491: LD_INT 2
70493: NEG
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PUSH
70499: LD_INT 1
70501: PUSH
70502: LD_INT 1
70504: NEG
70505: PUSH
70506: EMPTY
70507: LIST
70508: LIST
70509: PUSH
70510: LD_INT 2
70512: PUSH
70513: LD_INT 0
70515: PUSH
70516: EMPTY
70517: LIST
70518: LIST
70519: PUSH
70520: LD_INT 2
70522: PUSH
70523: LD_INT 1
70525: PUSH
70526: EMPTY
70527: LIST
70528: LIST
70529: PUSH
70530: LD_INT 2
70532: PUSH
70533: LD_INT 2
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: PUSH
70540: LD_INT 1
70542: PUSH
70543: LD_INT 2
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: PUSH
70550: LD_INT 0
70552: PUSH
70553: LD_INT 2
70555: PUSH
70556: EMPTY
70557: LIST
70558: LIST
70559: PUSH
70560: LD_INT 1
70562: NEG
70563: PUSH
70564: LD_INT 1
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PUSH
70571: LD_INT 2
70573: NEG
70574: PUSH
70575: LD_INT 0
70577: PUSH
70578: EMPTY
70579: LIST
70580: LIST
70581: PUSH
70582: LD_INT 2
70584: NEG
70585: PUSH
70586: LD_INT 1
70588: NEG
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: PUSH
70594: LD_INT 2
70596: NEG
70597: PUSH
70598: LD_INT 2
70600: NEG
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 2
70608: NEG
70609: PUSH
70610: LD_INT 3
70612: NEG
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: LD_INT 1
70620: NEG
70621: PUSH
70622: LD_INT 3
70624: NEG
70625: PUSH
70626: EMPTY
70627: LIST
70628: LIST
70629: PUSH
70630: LD_INT 3
70632: NEG
70633: PUSH
70634: LD_INT 1
70636: NEG
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: PUSH
70642: LD_INT 3
70644: NEG
70645: PUSH
70646: LD_INT 2
70648: NEG
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70679: LD_ADDR_VAR 0 29
70683: PUSH
70684: LD_INT 0
70686: PUSH
70687: LD_INT 0
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: PUSH
70694: LD_INT 0
70696: PUSH
70697: LD_INT 1
70699: NEG
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: LD_INT 1
70707: PUSH
70708: LD_INT 0
70710: PUSH
70711: EMPTY
70712: LIST
70713: LIST
70714: PUSH
70715: LD_INT 1
70717: PUSH
70718: LD_INT 1
70720: PUSH
70721: EMPTY
70722: LIST
70723: LIST
70724: PUSH
70725: LD_INT 0
70727: PUSH
70728: LD_INT 1
70730: PUSH
70731: EMPTY
70732: LIST
70733: LIST
70734: PUSH
70735: LD_INT 1
70737: NEG
70738: PUSH
70739: LD_INT 0
70741: PUSH
70742: EMPTY
70743: LIST
70744: LIST
70745: PUSH
70746: LD_INT 1
70748: NEG
70749: PUSH
70750: LD_INT 1
70752: NEG
70753: PUSH
70754: EMPTY
70755: LIST
70756: LIST
70757: PUSH
70758: LD_INT 1
70760: NEG
70761: PUSH
70762: LD_INT 2
70764: NEG
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 0
70772: PUSH
70773: LD_INT 2
70775: NEG
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: PUSH
70781: LD_INT 1
70783: PUSH
70784: LD_INT 1
70786: NEG
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: PUSH
70792: LD_INT 2
70794: PUSH
70795: LD_INT 0
70797: PUSH
70798: EMPTY
70799: LIST
70800: LIST
70801: PUSH
70802: LD_INT 2
70804: PUSH
70805: LD_INT 1
70807: PUSH
70808: EMPTY
70809: LIST
70810: LIST
70811: PUSH
70812: LD_INT 1
70814: PUSH
70815: LD_INT 2
70817: PUSH
70818: EMPTY
70819: LIST
70820: LIST
70821: PUSH
70822: LD_INT 0
70824: PUSH
70825: LD_INT 2
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 1
70834: NEG
70835: PUSH
70836: LD_INT 1
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 2
70845: NEG
70846: PUSH
70847: LD_INT 1
70849: NEG
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 2
70857: NEG
70858: PUSH
70859: LD_INT 2
70861: NEG
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PUSH
70867: LD_INT 2
70869: NEG
70870: PUSH
70871: LD_INT 3
70873: NEG
70874: PUSH
70875: EMPTY
70876: LIST
70877: LIST
70878: PUSH
70879: LD_INT 2
70881: PUSH
70882: LD_INT 1
70884: NEG
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: PUSH
70890: LD_INT 3
70892: PUSH
70893: LD_INT 1
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 1
70902: PUSH
70903: LD_INT 3
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: LD_INT 1
70912: NEG
70913: PUSH
70914: LD_INT 2
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: PUSH
70921: LD_INT 3
70923: NEG
70924: PUSH
70925: LD_INT 2
70927: NEG
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: LIST
70937: LIST
70938: LIST
70939: LIST
70940: LIST
70941: LIST
70942: LIST
70943: LIST
70944: LIST
70945: LIST
70946: LIST
70947: LIST
70948: LIST
70949: LIST
70950: LIST
70951: LIST
70952: LIST
70953: LIST
70954: LIST
70955: LIST
70956: LIST
70957: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70958: LD_ADDR_VAR 0 30
70962: PUSH
70963: LD_INT 0
70965: PUSH
70966: LD_INT 0
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: LD_INT 0
70975: PUSH
70976: LD_INT 1
70978: NEG
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 1
70986: PUSH
70987: LD_INT 0
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 1
70996: PUSH
70997: LD_INT 1
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: LD_INT 0
71006: PUSH
71007: LD_INT 1
71009: PUSH
71010: EMPTY
71011: LIST
71012: LIST
71013: PUSH
71014: LD_INT 1
71016: NEG
71017: PUSH
71018: LD_INT 0
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: PUSH
71025: LD_INT 1
71027: NEG
71028: PUSH
71029: LD_INT 1
71031: NEG
71032: PUSH
71033: EMPTY
71034: LIST
71035: LIST
71036: PUSH
71037: LD_INT 1
71039: NEG
71040: PUSH
71041: LD_INT 2
71043: NEG
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PUSH
71049: LD_INT 0
71051: PUSH
71052: LD_INT 2
71054: NEG
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: LD_INT 1
71062: PUSH
71063: LD_INT 1
71065: NEG
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 2
71073: PUSH
71074: LD_INT 0
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: PUSH
71081: LD_INT 2
71083: PUSH
71084: LD_INT 1
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 2
71093: PUSH
71094: LD_INT 2
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: PUSH
71101: LD_INT 1
71103: PUSH
71104: LD_INT 2
71106: PUSH
71107: EMPTY
71108: LIST
71109: LIST
71110: PUSH
71111: LD_INT 1
71113: NEG
71114: PUSH
71115: LD_INT 1
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PUSH
71122: LD_INT 2
71124: NEG
71125: PUSH
71126: LD_INT 0
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PUSH
71133: LD_INT 2
71135: NEG
71136: PUSH
71137: LD_INT 1
71139: NEG
71140: PUSH
71141: EMPTY
71142: LIST
71143: LIST
71144: PUSH
71145: LD_INT 1
71147: NEG
71148: PUSH
71149: LD_INT 3
71151: NEG
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 1
71159: PUSH
71160: LD_INT 2
71162: NEG
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PUSH
71168: LD_INT 3
71170: PUSH
71171: LD_INT 2
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PUSH
71178: LD_INT 2
71180: PUSH
71181: LD_INT 3
71183: PUSH
71184: EMPTY
71185: LIST
71186: LIST
71187: PUSH
71188: LD_INT 2
71190: NEG
71191: PUSH
71192: LD_INT 1
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 3
71201: NEG
71202: PUSH
71203: LD_INT 1
71205: NEG
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: LIST
71215: LIST
71216: LIST
71217: LIST
71218: LIST
71219: LIST
71220: LIST
71221: LIST
71222: LIST
71223: LIST
71224: LIST
71225: LIST
71226: LIST
71227: LIST
71228: LIST
71229: LIST
71230: LIST
71231: LIST
71232: LIST
71233: LIST
71234: LIST
71235: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71236: LD_ADDR_VAR 0 31
71240: PUSH
71241: LD_INT 0
71243: PUSH
71244: LD_INT 0
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 0
71253: PUSH
71254: LD_INT 1
71256: NEG
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 1
71264: PUSH
71265: LD_INT 0
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: PUSH
71272: LD_INT 1
71274: PUSH
71275: LD_INT 1
71277: PUSH
71278: EMPTY
71279: LIST
71280: LIST
71281: PUSH
71282: LD_INT 0
71284: PUSH
71285: LD_INT 1
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 1
71294: NEG
71295: PUSH
71296: LD_INT 0
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 1
71305: NEG
71306: PUSH
71307: LD_INT 1
71309: NEG
71310: PUSH
71311: EMPTY
71312: LIST
71313: LIST
71314: PUSH
71315: LD_INT 1
71317: NEG
71318: PUSH
71319: LD_INT 2
71321: NEG
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: PUSH
71327: LD_INT 1
71329: PUSH
71330: LD_INT 1
71332: NEG
71333: PUSH
71334: EMPTY
71335: LIST
71336: LIST
71337: PUSH
71338: LD_INT 2
71340: PUSH
71341: LD_INT 0
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: PUSH
71348: LD_INT 2
71350: PUSH
71351: LD_INT 1
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: PUSH
71358: LD_INT 2
71360: PUSH
71361: LD_INT 2
71363: PUSH
71364: EMPTY
71365: LIST
71366: LIST
71367: PUSH
71368: LD_INT 1
71370: PUSH
71371: LD_INT 2
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 0
71380: PUSH
71381: LD_INT 2
71383: PUSH
71384: EMPTY
71385: LIST
71386: LIST
71387: PUSH
71388: LD_INT 1
71390: NEG
71391: PUSH
71392: LD_INT 1
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: PUSH
71399: LD_INT 2
71401: NEG
71402: PUSH
71403: LD_INT 1
71405: NEG
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: PUSH
71411: LD_INT 2
71413: NEG
71414: PUSH
71415: LD_INT 2
71417: NEG
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PUSH
71423: LD_INT 2
71425: NEG
71426: PUSH
71427: LD_INT 3
71429: NEG
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: PUSH
71435: LD_INT 2
71437: PUSH
71438: LD_INT 1
71440: NEG
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PUSH
71446: LD_INT 3
71448: PUSH
71449: LD_INT 1
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: PUSH
71456: LD_INT 1
71458: PUSH
71459: LD_INT 3
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: PUSH
71466: LD_INT 1
71468: NEG
71469: PUSH
71470: LD_INT 2
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 3
71479: NEG
71480: PUSH
71481: LD_INT 2
71483: NEG
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: LIST
71495: LIST
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: LIST
71501: LIST
71502: LIST
71503: LIST
71504: LIST
71505: LIST
71506: LIST
71507: LIST
71508: LIST
71509: LIST
71510: LIST
71511: LIST
71512: LIST
71513: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71514: LD_ADDR_VAR 0 32
71518: PUSH
71519: LD_INT 0
71521: PUSH
71522: LD_INT 0
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 0
71531: PUSH
71532: LD_INT 1
71534: NEG
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 1
71542: PUSH
71543: LD_INT 0
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 1
71552: PUSH
71553: LD_INT 1
71555: PUSH
71556: EMPTY
71557: LIST
71558: LIST
71559: PUSH
71560: LD_INT 0
71562: PUSH
71563: LD_INT 1
71565: PUSH
71566: EMPTY
71567: LIST
71568: LIST
71569: PUSH
71570: LD_INT 1
71572: NEG
71573: PUSH
71574: LD_INT 0
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 1
71583: NEG
71584: PUSH
71585: LD_INT 1
71587: NEG
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 1
71595: NEG
71596: PUSH
71597: LD_INT 2
71599: NEG
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: PUSH
71605: LD_INT 0
71607: PUSH
71608: LD_INT 2
71610: NEG
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: PUSH
71616: LD_INT 1
71618: PUSH
71619: LD_INT 1
71621: NEG
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 2
71629: PUSH
71630: LD_INT 1
71632: PUSH
71633: EMPTY
71634: LIST
71635: LIST
71636: PUSH
71637: LD_INT 2
71639: PUSH
71640: LD_INT 2
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: PUSH
71647: LD_INT 1
71649: PUSH
71650: LD_INT 2
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: PUSH
71657: LD_INT 0
71659: PUSH
71660: LD_INT 2
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: PUSH
71667: LD_INT 1
71669: NEG
71670: PUSH
71671: LD_INT 1
71673: PUSH
71674: EMPTY
71675: LIST
71676: LIST
71677: PUSH
71678: LD_INT 2
71680: NEG
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 2
71691: NEG
71692: PUSH
71693: LD_INT 1
71695: NEG
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: LD_INT 1
71703: NEG
71704: PUSH
71705: LD_INT 3
71707: NEG
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 1
71715: PUSH
71716: LD_INT 2
71718: NEG
71719: PUSH
71720: EMPTY
71721: LIST
71722: LIST
71723: PUSH
71724: LD_INT 3
71726: PUSH
71727: LD_INT 2
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: PUSH
71734: LD_INT 2
71736: PUSH
71737: LD_INT 3
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: PUSH
71744: LD_INT 2
71746: NEG
71747: PUSH
71748: LD_INT 1
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PUSH
71755: LD_INT 3
71757: NEG
71758: PUSH
71759: LD_INT 1
71761: NEG
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71792: LD_ADDR_VAR 0 33
71796: PUSH
71797: LD_INT 0
71799: PUSH
71800: LD_INT 0
71802: PUSH
71803: EMPTY
71804: LIST
71805: LIST
71806: PUSH
71807: LD_INT 0
71809: PUSH
71810: LD_INT 1
71812: NEG
71813: PUSH
71814: EMPTY
71815: LIST
71816: LIST
71817: PUSH
71818: LD_INT 1
71820: PUSH
71821: LD_INT 0
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: LD_INT 1
71830: PUSH
71831: LD_INT 1
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 0
71840: PUSH
71841: LD_INT 1
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 1
71850: NEG
71851: PUSH
71852: LD_INT 0
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 1
71861: NEG
71862: PUSH
71863: LD_INT 1
71865: NEG
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: LD_INT 1
71873: NEG
71874: PUSH
71875: LD_INT 2
71877: NEG
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: PUSH
71883: LD_INT 1
71885: PUSH
71886: LD_INT 1
71888: NEG
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 2
71896: PUSH
71897: LD_INT 0
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 2
71906: PUSH
71907: LD_INT 1
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 1
71916: PUSH
71917: LD_INT 2
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: LD_INT 0
71926: PUSH
71927: LD_INT 2
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 1
71936: NEG
71937: PUSH
71938: LD_INT 1
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PUSH
71945: LD_INT 2
71947: NEG
71948: PUSH
71949: LD_INT 0
71951: PUSH
71952: EMPTY
71953: LIST
71954: LIST
71955: PUSH
71956: LD_INT 2
71958: NEG
71959: PUSH
71960: LD_INT 1
71962: NEG
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: LD_INT 2
71970: NEG
71971: PUSH
71972: LD_INT 2
71974: NEG
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: PUSH
71980: LD_INT 2
71982: NEG
71983: PUSH
71984: LD_INT 3
71986: NEG
71987: PUSH
71988: EMPTY
71989: LIST
71990: LIST
71991: PUSH
71992: LD_INT 2
71994: PUSH
71995: LD_INT 1
71997: NEG
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PUSH
72003: LD_INT 3
72005: PUSH
72006: LD_INT 1
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 1
72015: PUSH
72016: LD_INT 3
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 1
72025: NEG
72026: PUSH
72027: LD_INT 2
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: LD_INT 3
72036: NEG
72037: PUSH
72038: LD_INT 2
72040: NEG
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: LIST
72055: LIST
72056: LIST
72057: LIST
72058: LIST
72059: LIST
72060: LIST
72061: LIST
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72071: LD_ADDR_VAR 0 34
72075: PUSH
72076: LD_INT 0
72078: PUSH
72079: LD_INT 0
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: LD_INT 0
72088: PUSH
72089: LD_INT 1
72091: NEG
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: LD_INT 1
72099: PUSH
72100: LD_INT 0
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 1
72109: PUSH
72110: LD_INT 1
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 0
72119: PUSH
72120: LD_INT 1
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 1
72129: NEG
72130: PUSH
72131: LD_INT 0
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 1
72140: NEG
72141: PUSH
72142: LD_INT 1
72144: NEG
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PUSH
72150: LD_INT 1
72152: NEG
72153: PUSH
72154: LD_INT 2
72156: NEG
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: PUSH
72162: LD_INT 0
72164: PUSH
72165: LD_INT 2
72167: NEG
72168: PUSH
72169: EMPTY
72170: LIST
72171: LIST
72172: PUSH
72173: LD_INT 1
72175: PUSH
72176: LD_INT 1
72178: NEG
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: LD_INT 2
72186: PUSH
72187: LD_INT 1
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 2
72196: PUSH
72197: LD_INT 2
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 1
72206: PUSH
72207: LD_INT 2
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: PUSH
72214: LD_INT 1
72216: NEG
72217: PUSH
72218: LD_INT 1
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 2
72227: NEG
72228: PUSH
72229: LD_INT 0
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 2
72238: NEG
72239: PUSH
72240: LD_INT 1
72242: NEG
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 2
72250: NEG
72251: PUSH
72252: LD_INT 2
72254: NEG
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PUSH
72260: LD_INT 1
72262: NEG
72263: PUSH
72264: LD_INT 3
72266: NEG
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PUSH
72272: LD_INT 1
72274: PUSH
72275: LD_INT 2
72277: NEG
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PUSH
72283: LD_INT 3
72285: PUSH
72286: LD_INT 2
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 2
72295: PUSH
72296: LD_INT 3
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 2
72305: NEG
72306: PUSH
72307: LD_INT 1
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 3
72316: NEG
72317: PUSH
72318: LD_INT 1
72320: NEG
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: LIST
72332: LIST
72333: LIST
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: LIST
72339: LIST
72340: LIST
72341: LIST
72342: LIST
72343: LIST
72344: LIST
72345: LIST
72346: LIST
72347: LIST
72348: LIST
72349: LIST
72350: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72351: LD_ADDR_VAR 0 35
72355: PUSH
72356: LD_INT 0
72358: PUSH
72359: LD_INT 0
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 0
72368: PUSH
72369: LD_INT 1
72371: NEG
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 1
72379: PUSH
72380: LD_INT 0
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PUSH
72387: LD_INT 1
72389: PUSH
72390: LD_INT 1
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: PUSH
72397: LD_INT 0
72399: PUSH
72400: LD_INT 1
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PUSH
72407: LD_INT 1
72409: NEG
72410: PUSH
72411: LD_INT 0
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 1
72420: NEG
72421: PUSH
72422: LD_INT 1
72424: NEG
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 2
72432: PUSH
72433: LD_INT 1
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PUSH
72440: LD_INT 2
72442: NEG
72443: PUSH
72444: LD_INT 1
72446: NEG
72447: PUSH
72448: EMPTY
72449: LIST
72450: LIST
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72463: LD_ADDR_VAR 0 36
72467: PUSH
72468: LD_INT 0
72470: PUSH
72471: LD_INT 0
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: LD_INT 0
72480: PUSH
72481: LD_INT 1
72483: NEG
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PUSH
72489: LD_INT 1
72491: PUSH
72492: LD_INT 0
72494: PUSH
72495: EMPTY
72496: LIST
72497: LIST
72498: PUSH
72499: LD_INT 1
72501: PUSH
72502: LD_INT 1
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 0
72511: PUSH
72512: LD_INT 1
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 1
72521: NEG
72522: PUSH
72523: LD_INT 0
72525: PUSH
72526: EMPTY
72527: LIST
72528: LIST
72529: PUSH
72530: LD_INT 1
72532: NEG
72533: PUSH
72534: LD_INT 1
72536: NEG
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 1
72544: NEG
72545: PUSH
72546: LD_INT 2
72548: NEG
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 1
72556: PUSH
72557: LD_INT 2
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: LIST
72568: LIST
72569: LIST
72570: LIST
72571: LIST
72572: LIST
72573: LIST
72574: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72575: LD_ADDR_VAR 0 37
72579: PUSH
72580: LD_INT 0
72582: PUSH
72583: LD_INT 0
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: PUSH
72590: LD_INT 0
72592: PUSH
72593: LD_INT 1
72595: NEG
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: PUSH
72601: LD_INT 1
72603: PUSH
72604: LD_INT 0
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: PUSH
72611: LD_INT 1
72613: PUSH
72614: LD_INT 1
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: PUSH
72621: LD_INT 0
72623: PUSH
72624: LD_INT 1
72626: PUSH
72627: EMPTY
72628: LIST
72629: LIST
72630: PUSH
72631: LD_INT 1
72633: NEG
72634: PUSH
72635: LD_INT 0
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PUSH
72642: LD_INT 1
72644: NEG
72645: PUSH
72646: LD_INT 1
72648: NEG
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: LD_INT 1
72656: PUSH
72657: LD_INT 1
72659: NEG
72660: PUSH
72661: EMPTY
72662: LIST
72663: LIST
72664: PUSH
72665: LD_INT 1
72667: NEG
72668: PUSH
72669: LD_INT 1
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: LIST
72680: LIST
72681: LIST
72682: LIST
72683: LIST
72684: LIST
72685: LIST
72686: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72687: LD_ADDR_VAR 0 38
72691: PUSH
72692: LD_INT 0
72694: PUSH
72695: LD_INT 0
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 0
72704: PUSH
72705: LD_INT 1
72707: NEG
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: LD_INT 1
72715: PUSH
72716: LD_INT 0
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: LD_INT 1
72725: PUSH
72726: LD_INT 1
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 0
72735: PUSH
72736: LD_INT 1
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 1
72745: NEG
72746: PUSH
72747: LD_INT 0
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PUSH
72754: LD_INT 1
72756: NEG
72757: PUSH
72758: LD_INT 1
72760: NEG
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: PUSH
72766: LD_INT 2
72768: PUSH
72769: LD_INT 1
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: LD_INT 2
72778: NEG
72779: PUSH
72780: LD_INT 1
72782: NEG
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: LIST
72792: LIST
72793: LIST
72794: LIST
72795: LIST
72796: LIST
72797: LIST
72798: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72799: LD_ADDR_VAR 0 39
72803: PUSH
72804: LD_INT 0
72806: PUSH
72807: LD_INT 0
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: LD_INT 0
72816: PUSH
72817: LD_INT 1
72819: NEG
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PUSH
72825: LD_INT 1
72827: PUSH
72828: LD_INT 0
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PUSH
72835: LD_INT 1
72837: PUSH
72838: LD_INT 1
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 0
72847: PUSH
72848: LD_INT 1
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 1
72857: NEG
72858: PUSH
72859: LD_INT 0
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 1
72868: NEG
72869: PUSH
72870: LD_INT 1
72872: NEG
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: PUSH
72878: LD_INT 1
72880: NEG
72881: PUSH
72882: LD_INT 2
72884: NEG
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: PUSH
72890: LD_INT 1
72892: PUSH
72893: LD_INT 2
72895: PUSH
72896: EMPTY
72897: LIST
72898: LIST
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: LIST
72904: LIST
72905: LIST
72906: LIST
72907: LIST
72908: LIST
72909: LIST
72910: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72911: LD_ADDR_VAR 0 40
72915: PUSH
72916: LD_INT 0
72918: PUSH
72919: LD_INT 0
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 0
72928: PUSH
72929: LD_INT 1
72931: NEG
72932: PUSH
72933: EMPTY
72934: LIST
72935: LIST
72936: PUSH
72937: LD_INT 1
72939: PUSH
72940: LD_INT 0
72942: PUSH
72943: EMPTY
72944: LIST
72945: LIST
72946: PUSH
72947: LD_INT 1
72949: PUSH
72950: LD_INT 1
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 0
72959: PUSH
72960: LD_INT 1
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 1
72969: NEG
72970: PUSH
72971: LD_INT 0
72973: PUSH
72974: EMPTY
72975: LIST
72976: LIST
72977: PUSH
72978: LD_INT 1
72980: NEG
72981: PUSH
72982: LD_INT 1
72984: NEG
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PUSH
72990: LD_INT 1
72992: PUSH
72993: LD_INT 1
72995: NEG
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: PUSH
73001: LD_INT 1
73003: NEG
73004: PUSH
73005: LD_INT 1
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: LIST
73016: LIST
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: LIST
73022: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73023: LD_ADDR_VAR 0 41
73027: PUSH
73028: LD_INT 0
73030: PUSH
73031: LD_INT 0
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 0
73040: PUSH
73041: LD_INT 1
73043: NEG
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 1
73051: PUSH
73052: LD_INT 0
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 1
73061: PUSH
73062: LD_INT 1
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 0
73071: PUSH
73072: LD_INT 1
73074: PUSH
73075: EMPTY
73076: LIST
73077: LIST
73078: PUSH
73079: LD_INT 1
73081: NEG
73082: PUSH
73083: LD_INT 0
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 1
73092: NEG
73093: PUSH
73094: LD_INT 1
73096: NEG
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: LD_INT 1
73104: NEG
73105: PUSH
73106: LD_INT 2
73108: NEG
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: LD_INT 1
73116: PUSH
73117: LD_INT 1
73119: NEG
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: PUSH
73125: LD_INT 2
73127: PUSH
73128: LD_INT 0
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: PUSH
73135: LD_INT 2
73137: PUSH
73138: LD_INT 1
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 2
73147: PUSH
73148: LD_INT 2
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PUSH
73155: LD_INT 1
73157: PUSH
73158: LD_INT 2
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 1
73167: NEG
73168: PUSH
73169: LD_INT 1
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 2
73178: NEG
73179: PUSH
73180: LD_INT 0
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: LD_INT 2
73189: NEG
73190: PUSH
73191: LD_INT 1
73193: NEG
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: PUSH
73199: LD_INT 2
73201: NEG
73202: PUSH
73203: LD_INT 2
73205: NEG
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 2
73213: NEG
73214: PUSH
73215: LD_INT 3
73217: NEG
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: LD_INT 2
73225: PUSH
73226: LD_INT 1
73228: NEG
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 3
73236: PUSH
73237: LD_INT 0
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 3
73246: PUSH
73247: LD_INT 1
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: PUSH
73254: LD_INT 3
73256: PUSH
73257: LD_INT 2
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PUSH
73264: LD_INT 3
73266: PUSH
73267: LD_INT 3
73269: PUSH
73270: EMPTY
73271: LIST
73272: LIST
73273: PUSH
73274: LD_INT 2
73276: PUSH
73277: LD_INT 3
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: PUSH
73284: LD_INT 2
73286: NEG
73287: PUSH
73288: LD_INT 1
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: LD_INT 3
73297: NEG
73298: PUSH
73299: LD_INT 0
73301: PUSH
73302: EMPTY
73303: LIST
73304: LIST
73305: PUSH
73306: LD_INT 3
73308: NEG
73309: PUSH
73310: LD_INT 1
73312: NEG
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: PUSH
73318: LD_INT 3
73320: NEG
73321: PUSH
73322: LD_INT 2
73324: NEG
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 3
73332: NEG
73333: PUSH
73334: LD_INT 3
73336: NEG
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: LIST
73346: LIST
73347: LIST
73348: LIST
73349: LIST
73350: LIST
73351: LIST
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73373: LD_ADDR_VAR 0 42
73377: PUSH
73378: LD_INT 0
73380: PUSH
73381: LD_INT 0
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 0
73390: PUSH
73391: LD_INT 1
73393: NEG
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 1
73401: PUSH
73402: LD_INT 0
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 1
73411: PUSH
73412: LD_INT 1
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PUSH
73419: LD_INT 0
73421: PUSH
73422: LD_INT 1
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 1
73431: NEG
73432: PUSH
73433: LD_INT 0
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 1
73442: NEG
73443: PUSH
73444: LD_INT 1
73446: NEG
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 1
73454: NEG
73455: PUSH
73456: LD_INT 2
73458: NEG
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: PUSH
73464: LD_INT 0
73466: PUSH
73467: LD_INT 2
73469: NEG
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: LD_INT 1
73477: PUSH
73478: LD_INT 1
73480: NEG
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 2
73488: PUSH
73489: LD_INT 1
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 2
73498: PUSH
73499: LD_INT 2
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PUSH
73506: LD_INT 1
73508: PUSH
73509: LD_INT 2
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: PUSH
73516: LD_INT 0
73518: PUSH
73519: LD_INT 2
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: LD_INT 1
73528: NEG
73529: PUSH
73530: LD_INT 1
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 2
73539: NEG
73540: PUSH
73541: LD_INT 1
73543: NEG
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: LD_INT 2
73551: NEG
73552: PUSH
73553: LD_INT 2
73555: NEG
73556: PUSH
73557: EMPTY
73558: LIST
73559: LIST
73560: PUSH
73561: LD_INT 2
73563: NEG
73564: PUSH
73565: LD_INT 3
73567: NEG
73568: PUSH
73569: EMPTY
73570: LIST
73571: LIST
73572: PUSH
73573: LD_INT 1
73575: NEG
73576: PUSH
73577: LD_INT 3
73579: NEG
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 0
73587: PUSH
73588: LD_INT 3
73590: NEG
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 1
73598: PUSH
73599: LD_INT 2
73601: NEG
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: PUSH
73607: LD_INT 3
73609: PUSH
73610: LD_INT 2
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 3
73619: PUSH
73620: LD_INT 3
73622: PUSH
73623: EMPTY
73624: LIST
73625: LIST
73626: PUSH
73627: LD_INT 2
73629: PUSH
73630: LD_INT 3
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: PUSH
73637: LD_INT 1
73639: PUSH
73640: LD_INT 3
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 0
73649: PUSH
73650: LD_INT 3
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: LD_INT 1
73659: NEG
73660: PUSH
73661: LD_INT 2
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: PUSH
73668: LD_INT 3
73670: NEG
73671: PUSH
73672: LD_INT 2
73674: NEG
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: PUSH
73680: LD_INT 3
73682: NEG
73683: PUSH
73684: LD_INT 3
73686: NEG
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: LIST
73696: LIST
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: LIST
73704: LIST
73705: LIST
73706: LIST
73707: LIST
73708: LIST
73709: LIST
73710: LIST
73711: LIST
73712: LIST
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: LIST
73718: LIST
73719: LIST
73720: LIST
73721: LIST
73722: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73723: LD_ADDR_VAR 0 43
73727: PUSH
73728: LD_INT 0
73730: PUSH
73731: LD_INT 0
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 0
73740: PUSH
73741: LD_INT 1
73743: NEG
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PUSH
73749: LD_INT 1
73751: PUSH
73752: LD_INT 0
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: LD_INT 1
73761: PUSH
73762: LD_INT 1
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: PUSH
73769: LD_INT 0
73771: PUSH
73772: LD_INT 1
73774: PUSH
73775: EMPTY
73776: LIST
73777: LIST
73778: PUSH
73779: LD_INT 1
73781: NEG
73782: PUSH
73783: LD_INT 0
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 1
73792: NEG
73793: PUSH
73794: LD_INT 1
73796: NEG
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: PUSH
73802: LD_INT 1
73804: NEG
73805: PUSH
73806: LD_INT 2
73808: NEG
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 0
73816: PUSH
73817: LD_INT 2
73819: NEG
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: PUSH
73825: LD_INT 1
73827: PUSH
73828: LD_INT 1
73830: NEG
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 2
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 2
73848: PUSH
73849: LD_INT 1
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 1
73858: PUSH
73859: LD_INT 2
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 0
73868: PUSH
73869: LD_INT 2
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: PUSH
73876: LD_INT 1
73878: NEG
73879: PUSH
73880: LD_INT 1
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: LD_INT 2
73889: NEG
73890: PUSH
73891: LD_INT 0
73893: PUSH
73894: EMPTY
73895: LIST
73896: LIST
73897: PUSH
73898: LD_INT 2
73900: NEG
73901: PUSH
73902: LD_INT 1
73904: NEG
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 1
73912: NEG
73913: PUSH
73914: LD_INT 3
73916: NEG
73917: PUSH
73918: EMPTY
73919: LIST
73920: LIST
73921: PUSH
73922: LD_INT 0
73924: PUSH
73925: LD_INT 3
73927: NEG
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 1
73935: PUSH
73936: LD_INT 2
73938: NEG
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: PUSH
73944: LD_INT 2
73946: PUSH
73947: LD_INT 1
73949: NEG
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: PUSH
73955: LD_INT 3
73957: PUSH
73958: LD_INT 0
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 3
73967: PUSH
73968: LD_INT 1
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: PUSH
73975: LD_INT 1
73977: PUSH
73978: LD_INT 3
73980: PUSH
73981: EMPTY
73982: LIST
73983: LIST
73984: PUSH
73985: LD_INT 0
73987: PUSH
73988: LD_INT 3
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: LD_INT 1
73997: NEG
73998: PUSH
73999: LD_INT 2
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: LD_INT 2
74008: NEG
74009: PUSH
74010: LD_INT 1
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 3
74019: NEG
74020: PUSH
74021: LD_INT 0
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 3
74030: NEG
74031: PUSH
74032: LD_INT 1
74034: NEG
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74071: LD_ADDR_VAR 0 44
74075: PUSH
74076: LD_INT 0
74078: PUSH
74079: LD_INT 0
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 0
74088: PUSH
74089: LD_INT 1
74091: NEG
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: PUSH
74097: LD_INT 1
74099: PUSH
74100: LD_INT 0
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 1
74109: PUSH
74110: LD_INT 1
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: PUSH
74117: LD_INT 0
74119: PUSH
74120: LD_INT 1
74122: PUSH
74123: EMPTY
74124: LIST
74125: LIST
74126: PUSH
74127: LD_INT 1
74129: NEG
74130: PUSH
74131: LD_INT 0
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 1
74140: NEG
74141: PUSH
74142: LD_INT 1
74144: NEG
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: LD_INT 1
74152: NEG
74153: PUSH
74154: LD_INT 2
74156: NEG
74157: PUSH
74158: EMPTY
74159: LIST
74160: LIST
74161: PUSH
74162: LD_INT 1
74164: PUSH
74165: LD_INT 1
74167: NEG
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: LD_INT 2
74175: PUSH
74176: LD_INT 0
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: LD_INT 2
74185: PUSH
74186: LD_INT 1
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: LD_INT 2
74195: PUSH
74196: LD_INT 2
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: PUSH
74203: LD_INT 1
74205: PUSH
74206: LD_INT 2
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 1
74215: NEG
74216: PUSH
74217: LD_INT 1
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PUSH
74224: LD_INT 2
74226: NEG
74227: PUSH
74228: LD_INT 0
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: LD_INT 2
74237: NEG
74238: PUSH
74239: LD_INT 1
74241: NEG
74242: PUSH
74243: EMPTY
74244: LIST
74245: LIST
74246: PUSH
74247: LD_INT 2
74249: NEG
74250: PUSH
74251: LD_INT 2
74253: NEG
74254: PUSH
74255: EMPTY
74256: LIST
74257: LIST
74258: PUSH
74259: LD_INT 2
74261: NEG
74262: PUSH
74263: LD_INT 3
74265: NEG
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: PUSH
74271: LD_INT 2
74273: PUSH
74274: LD_INT 1
74276: NEG
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: LD_INT 3
74284: PUSH
74285: LD_INT 0
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 3
74294: PUSH
74295: LD_INT 1
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: PUSH
74302: LD_INT 3
74304: PUSH
74305: LD_INT 2
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PUSH
74312: LD_INT 3
74314: PUSH
74315: LD_INT 3
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: PUSH
74322: LD_INT 2
74324: PUSH
74325: LD_INT 3
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: PUSH
74332: LD_INT 2
74334: NEG
74335: PUSH
74336: LD_INT 1
74338: PUSH
74339: EMPTY
74340: LIST
74341: LIST
74342: PUSH
74343: LD_INT 3
74345: NEG
74346: PUSH
74347: LD_INT 0
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: PUSH
74354: LD_INT 3
74356: NEG
74357: PUSH
74358: LD_INT 1
74360: NEG
74361: PUSH
74362: EMPTY
74363: LIST
74364: LIST
74365: PUSH
74366: LD_INT 3
74368: NEG
74369: PUSH
74370: LD_INT 2
74372: NEG
74373: PUSH
74374: EMPTY
74375: LIST
74376: LIST
74377: PUSH
74378: LD_INT 3
74380: NEG
74381: PUSH
74382: LD_INT 3
74384: NEG
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: LIST
74394: LIST
74395: LIST
74396: LIST
74397: LIST
74398: LIST
74399: LIST
74400: LIST
74401: LIST
74402: LIST
74403: LIST
74404: LIST
74405: LIST
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74421: LD_ADDR_VAR 0 45
74425: PUSH
74426: LD_INT 0
74428: PUSH
74429: LD_INT 0
74431: PUSH
74432: EMPTY
74433: LIST
74434: LIST
74435: PUSH
74436: LD_INT 0
74438: PUSH
74439: LD_INT 1
74441: NEG
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: PUSH
74447: LD_INT 1
74449: PUSH
74450: LD_INT 0
74452: PUSH
74453: EMPTY
74454: LIST
74455: LIST
74456: PUSH
74457: LD_INT 1
74459: PUSH
74460: LD_INT 1
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PUSH
74467: LD_INT 0
74469: PUSH
74470: LD_INT 1
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 1
74479: NEG
74480: PUSH
74481: LD_INT 0
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 1
74490: NEG
74491: PUSH
74492: LD_INT 1
74494: NEG
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: LD_INT 1
74502: NEG
74503: PUSH
74504: LD_INT 2
74506: NEG
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: PUSH
74512: LD_INT 0
74514: PUSH
74515: LD_INT 2
74517: NEG
74518: PUSH
74519: EMPTY
74520: LIST
74521: LIST
74522: PUSH
74523: LD_INT 1
74525: PUSH
74526: LD_INT 1
74528: NEG
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 2
74536: PUSH
74537: LD_INT 1
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PUSH
74544: LD_INT 2
74546: PUSH
74547: LD_INT 2
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 1
74556: PUSH
74557: LD_INT 2
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: PUSH
74564: LD_INT 0
74566: PUSH
74567: LD_INT 2
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: LD_INT 1
74576: NEG
74577: PUSH
74578: LD_INT 1
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: PUSH
74585: LD_INT 2
74587: NEG
74588: PUSH
74589: LD_INT 1
74591: NEG
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 2
74599: NEG
74600: PUSH
74601: LD_INT 2
74603: NEG
74604: PUSH
74605: EMPTY
74606: LIST
74607: LIST
74608: PUSH
74609: LD_INT 2
74611: NEG
74612: PUSH
74613: LD_INT 3
74615: NEG
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: LD_INT 1
74623: NEG
74624: PUSH
74625: LD_INT 3
74627: NEG
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: PUSH
74633: LD_INT 0
74635: PUSH
74636: LD_INT 3
74638: NEG
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 1
74646: PUSH
74647: LD_INT 2
74649: NEG
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: LD_INT 3
74657: PUSH
74658: LD_INT 2
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 3
74667: PUSH
74668: LD_INT 3
74670: PUSH
74671: EMPTY
74672: LIST
74673: LIST
74674: PUSH
74675: LD_INT 2
74677: PUSH
74678: LD_INT 3
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: PUSH
74685: LD_INT 1
74687: PUSH
74688: LD_INT 3
74690: PUSH
74691: EMPTY
74692: LIST
74693: LIST
74694: PUSH
74695: LD_INT 0
74697: PUSH
74698: LD_INT 3
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: PUSH
74705: LD_INT 1
74707: NEG
74708: PUSH
74709: LD_INT 2
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: PUSH
74716: LD_INT 3
74718: NEG
74719: PUSH
74720: LD_INT 2
74722: NEG
74723: PUSH
74724: EMPTY
74725: LIST
74726: LIST
74727: PUSH
74728: LD_INT 3
74730: NEG
74731: PUSH
74732: LD_INT 3
74734: NEG
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: LIST
74750: LIST
74751: LIST
74752: LIST
74753: LIST
74754: LIST
74755: LIST
74756: LIST
74757: LIST
74758: LIST
74759: LIST
74760: LIST
74761: LIST
74762: LIST
74763: LIST
74764: LIST
74765: LIST
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74771: LD_ADDR_VAR 0 46
74775: PUSH
74776: LD_INT 0
74778: PUSH
74779: LD_INT 0
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: PUSH
74786: LD_INT 0
74788: PUSH
74789: LD_INT 1
74791: NEG
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 1
74799: PUSH
74800: LD_INT 0
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 1
74809: PUSH
74810: LD_INT 1
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 0
74819: PUSH
74820: LD_INT 1
74822: PUSH
74823: EMPTY
74824: LIST
74825: LIST
74826: PUSH
74827: LD_INT 1
74829: NEG
74830: PUSH
74831: LD_INT 0
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 1
74840: NEG
74841: PUSH
74842: LD_INT 1
74844: NEG
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: LD_INT 1
74852: NEG
74853: PUSH
74854: LD_INT 2
74856: NEG
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PUSH
74862: LD_INT 0
74864: PUSH
74865: LD_INT 2
74867: NEG
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: PUSH
74873: LD_INT 1
74875: PUSH
74876: LD_INT 1
74878: NEG
74879: PUSH
74880: EMPTY
74881: LIST
74882: LIST
74883: PUSH
74884: LD_INT 2
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: PUSH
74894: LD_INT 2
74896: PUSH
74897: LD_INT 1
74899: PUSH
74900: EMPTY
74901: LIST
74902: LIST
74903: PUSH
74904: LD_INT 1
74906: PUSH
74907: LD_INT 2
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 0
74916: PUSH
74917: LD_INT 2
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: PUSH
74924: LD_INT 1
74926: NEG
74927: PUSH
74928: LD_INT 1
74930: PUSH
74931: EMPTY
74932: LIST
74933: LIST
74934: PUSH
74935: LD_INT 2
74937: NEG
74938: PUSH
74939: LD_INT 0
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: PUSH
74946: LD_INT 2
74948: NEG
74949: PUSH
74950: LD_INT 1
74952: NEG
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: PUSH
74958: LD_INT 1
74960: NEG
74961: PUSH
74962: LD_INT 3
74964: NEG
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: PUSH
74970: LD_INT 0
74972: PUSH
74973: LD_INT 3
74975: NEG
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: PUSH
74981: LD_INT 1
74983: PUSH
74984: LD_INT 2
74986: NEG
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: LD_INT 2
74994: PUSH
74995: LD_INT 1
74997: NEG
74998: PUSH
74999: EMPTY
75000: LIST
75001: LIST
75002: PUSH
75003: LD_INT 3
75005: PUSH
75006: LD_INT 0
75008: PUSH
75009: EMPTY
75010: LIST
75011: LIST
75012: PUSH
75013: LD_INT 3
75015: PUSH
75016: LD_INT 1
75018: PUSH
75019: EMPTY
75020: LIST
75021: LIST
75022: PUSH
75023: LD_INT 1
75025: PUSH
75026: LD_INT 3
75028: PUSH
75029: EMPTY
75030: LIST
75031: LIST
75032: PUSH
75033: LD_INT 0
75035: PUSH
75036: LD_INT 3
75038: PUSH
75039: EMPTY
75040: LIST
75041: LIST
75042: PUSH
75043: LD_INT 1
75045: NEG
75046: PUSH
75047: LD_INT 2
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: PUSH
75054: LD_INT 2
75056: NEG
75057: PUSH
75058: LD_INT 1
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: LD_INT 3
75067: NEG
75068: PUSH
75069: LD_INT 0
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: LD_INT 3
75078: NEG
75079: PUSH
75080: LD_INT 1
75082: NEG
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: LIST
75092: LIST
75093: LIST
75094: LIST
75095: LIST
75096: LIST
75097: LIST
75098: LIST
75099: LIST
75100: LIST
75101: LIST
75102: LIST
75103: LIST
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: LIST
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75119: LD_ADDR_VAR 0 47
75123: PUSH
75124: LD_INT 0
75126: PUSH
75127: LD_INT 0
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 0
75136: PUSH
75137: LD_INT 1
75139: NEG
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: PUSH
75145: LD_INT 1
75147: PUSH
75148: LD_INT 0
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: PUSH
75155: LD_INT 1
75157: PUSH
75158: LD_INT 1
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PUSH
75165: LD_INT 0
75167: PUSH
75168: LD_INT 1
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: PUSH
75175: LD_INT 1
75177: NEG
75178: PUSH
75179: LD_INT 0
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: PUSH
75186: LD_INT 1
75188: NEG
75189: PUSH
75190: LD_INT 1
75192: NEG
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: PUSH
75198: LD_INT 1
75200: NEG
75201: PUSH
75202: LD_INT 2
75204: NEG
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 0
75212: PUSH
75213: LD_INT 2
75215: NEG
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: PUSH
75221: LD_INT 1
75223: PUSH
75224: LD_INT 1
75226: NEG
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 2
75234: NEG
75235: PUSH
75236: LD_INT 1
75238: NEG
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 2
75246: NEG
75247: PUSH
75248: LD_INT 2
75250: NEG
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: LIST
75260: LIST
75261: LIST
75262: LIST
75263: LIST
75264: LIST
75265: LIST
75266: LIST
75267: LIST
75268: LIST
75269: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75270: LD_ADDR_VAR 0 48
75274: PUSH
75275: LD_INT 0
75277: PUSH
75278: LD_INT 0
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: PUSH
75285: LD_INT 0
75287: PUSH
75288: LD_INT 1
75290: NEG
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: LD_INT 1
75298: PUSH
75299: LD_INT 0
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 1
75308: PUSH
75309: LD_INT 1
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PUSH
75316: LD_INT 0
75318: PUSH
75319: LD_INT 1
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 1
75328: NEG
75329: PUSH
75330: LD_INT 0
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: PUSH
75337: LD_INT 1
75339: NEG
75340: PUSH
75341: LD_INT 1
75343: NEG
75344: PUSH
75345: EMPTY
75346: LIST
75347: LIST
75348: PUSH
75349: LD_INT 1
75351: NEG
75352: PUSH
75353: LD_INT 2
75355: NEG
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: PUSH
75361: LD_INT 0
75363: PUSH
75364: LD_INT 2
75366: NEG
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 1
75374: PUSH
75375: LD_INT 1
75377: NEG
75378: PUSH
75379: EMPTY
75380: LIST
75381: LIST
75382: PUSH
75383: LD_INT 2
75385: PUSH
75386: LD_INT 0
75388: PUSH
75389: EMPTY
75390: LIST
75391: LIST
75392: PUSH
75393: LD_INT 2
75395: PUSH
75396: LD_INT 1
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: LIST
75409: LIST
75410: LIST
75411: LIST
75412: LIST
75413: LIST
75414: LIST
75415: LIST
75416: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75417: LD_ADDR_VAR 0 49
75421: PUSH
75422: LD_INT 0
75424: PUSH
75425: LD_INT 0
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 0
75434: PUSH
75435: LD_INT 1
75437: NEG
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 1
75445: PUSH
75446: LD_INT 0
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 1
75455: PUSH
75456: LD_INT 1
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 0
75465: PUSH
75466: LD_INT 1
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: LD_INT 1
75475: NEG
75476: PUSH
75477: LD_INT 0
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 1
75486: NEG
75487: PUSH
75488: LD_INT 1
75490: NEG
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: PUSH
75496: LD_INT 1
75498: PUSH
75499: LD_INT 1
75501: NEG
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: LD_INT 2
75509: PUSH
75510: LD_INT 0
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: LD_INT 2
75519: PUSH
75520: LD_INT 1
75522: PUSH
75523: EMPTY
75524: LIST
75525: LIST
75526: PUSH
75527: LD_INT 2
75529: PUSH
75530: LD_INT 2
75532: PUSH
75533: EMPTY
75534: LIST
75535: LIST
75536: PUSH
75537: LD_INT 1
75539: PUSH
75540: LD_INT 2
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: LIST
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75561: LD_ADDR_VAR 0 50
75565: PUSH
75566: LD_INT 0
75568: PUSH
75569: LD_INT 0
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: LD_INT 0
75578: PUSH
75579: LD_INT 1
75581: NEG
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 1
75589: PUSH
75590: LD_INT 0
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: LD_INT 1
75599: PUSH
75600: LD_INT 1
75602: PUSH
75603: EMPTY
75604: LIST
75605: LIST
75606: PUSH
75607: LD_INT 0
75609: PUSH
75610: LD_INT 1
75612: PUSH
75613: EMPTY
75614: LIST
75615: LIST
75616: PUSH
75617: LD_INT 1
75619: NEG
75620: PUSH
75621: LD_INT 0
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 1
75630: NEG
75631: PUSH
75632: LD_INT 1
75634: NEG
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 2
75642: PUSH
75643: LD_INT 1
75645: PUSH
75646: EMPTY
75647: LIST
75648: LIST
75649: PUSH
75650: LD_INT 2
75652: PUSH
75653: LD_INT 2
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PUSH
75660: LD_INT 1
75662: PUSH
75663: LD_INT 2
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 0
75672: PUSH
75673: LD_INT 2
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 1
75682: NEG
75683: PUSH
75684: LD_INT 1
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: LIST
75695: LIST
75696: LIST
75697: LIST
75698: LIST
75699: LIST
75700: LIST
75701: LIST
75702: LIST
75703: LIST
75704: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75705: LD_ADDR_VAR 0 51
75709: PUSH
75710: LD_INT 0
75712: PUSH
75713: LD_INT 0
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PUSH
75720: LD_INT 0
75722: PUSH
75723: LD_INT 1
75725: NEG
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: PUSH
75731: LD_INT 1
75733: PUSH
75734: LD_INT 0
75736: PUSH
75737: EMPTY
75738: LIST
75739: LIST
75740: PUSH
75741: LD_INT 1
75743: PUSH
75744: LD_INT 1
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PUSH
75751: LD_INT 0
75753: PUSH
75754: LD_INT 1
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: PUSH
75761: LD_INT 1
75763: NEG
75764: PUSH
75765: LD_INT 0
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 1
75774: NEG
75775: PUSH
75776: LD_INT 1
75778: NEG
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: LD_INT 1
75786: PUSH
75787: LD_INT 2
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: LD_INT 0
75796: PUSH
75797: LD_INT 2
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: LD_INT 1
75806: NEG
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 2
75817: NEG
75818: PUSH
75819: LD_INT 0
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: PUSH
75826: LD_INT 2
75828: NEG
75829: PUSH
75830: LD_INT 1
75832: NEG
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: LIST
75848: LIST
75849: LIST
75850: LIST
75851: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75852: LD_ADDR_VAR 0 52
75856: PUSH
75857: LD_INT 0
75859: PUSH
75860: LD_INT 0
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: PUSH
75867: LD_INT 0
75869: PUSH
75870: LD_INT 1
75872: NEG
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: PUSH
75878: LD_INT 1
75880: PUSH
75881: LD_INT 0
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 1
75890: PUSH
75891: LD_INT 1
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: LD_INT 0
75900: PUSH
75901: LD_INT 1
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: LD_INT 1
75910: NEG
75911: PUSH
75912: LD_INT 0
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: PUSH
75919: LD_INT 1
75921: NEG
75922: PUSH
75923: LD_INT 1
75925: NEG
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 1
75933: NEG
75934: PUSH
75935: LD_INT 2
75937: NEG
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 1
75945: NEG
75946: PUSH
75947: LD_INT 1
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 2
75956: NEG
75957: PUSH
75958: LD_INT 0
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 2
75967: NEG
75968: PUSH
75969: LD_INT 1
75971: NEG
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 2
75979: NEG
75980: PUSH
75981: LD_INT 2
75983: NEG
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: LIST
75993: LIST
75994: LIST
75995: LIST
75996: LIST
75997: LIST
75998: LIST
75999: LIST
76000: LIST
76001: LIST
76002: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76003: LD_ADDR_VAR 0 53
76007: PUSH
76008: LD_INT 0
76010: PUSH
76011: LD_INT 0
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: PUSH
76018: LD_INT 0
76020: PUSH
76021: LD_INT 1
76023: NEG
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 1
76031: PUSH
76032: LD_INT 0
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: PUSH
76039: LD_INT 1
76041: PUSH
76042: LD_INT 1
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PUSH
76049: LD_INT 0
76051: PUSH
76052: LD_INT 1
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PUSH
76059: LD_INT 1
76061: NEG
76062: PUSH
76063: LD_INT 0
76065: PUSH
76066: EMPTY
76067: LIST
76068: LIST
76069: PUSH
76070: LD_INT 1
76072: NEG
76073: PUSH
76074: LD_INT 1
76076: NEG
76077: PUSH
76078: EMPTY
76079: LIST
76080: LIST
76081: PUSH
76082: LD_INT 1
76084: NEG
76085: PUSH
76086: LD_INT 2
76088: NEG
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: LD_INT 0
76096: PUSH
76097: LD_INT 2
76099: NEG
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 1
76107: PUSH
76108: LD_INT 1
76110: NEG
76111: PUSH
76112: EMPTY
76113: LIST
76114: LIST
76115: PUSH
76116: LD_INT 2
76118: PUSH
76119: LD_INT 0
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: PUSH
76126: LD_INT 2
76128: PUSH
76129: LD_INT 1
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 2
76138: PUSH
76139: LD_INT 2
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 1
76148: PUSH
76149: LD_INT 2
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 0
76158: PUSH
76159: LD_INT 2
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: LD_INT 1
76168: NEG
76169: PUSH
76170: LD_INT 1
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 2
76179: NEG
76180: PUSH
76181: LD_INT 0
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: LD_INT 2
76190: NEG
76191: PUSH
76192: LD_INT 1
76194: NEG
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 2
76202: NEG
76203: PUSH
76204: LD_INT 2
76206: NEG
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: LIST
76222: LIST
76223: LIST
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: LIST
76229: LIST
76230: LIST
76231: LIST
76232: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76233: LD_ADDR_VAR 0 54
76237: PUSH
76238: LD_INT 0
76240: PUSH
76241: LD_INT 0
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: PUSH
76248: LD_INT 0
76250: PUSH
76251: LD_INT 1
76253: NEG
76254: PUSH
76255: EMPTY
76256: LIST
76257: LIST
76258: PUSH
76259: LD_INT 1
76261: PUSH
76262: LD_INT 0
76264: PUSH
76265: EMPTY
76266: LIST
76267: LIST
76268: PUSH
76269: LD_INT 1
76271: PUSH
76272: LD_INT 1
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: LD_INT 0
76281: PUSH
76282: LD_INT 1
76284: PUSH
76285: EMPTY
76286: LIST
76287: LIST
76288: PUSH
76289: LD_INT 1
76291: NEG
76292: PUSH
76293: LD_INT 0
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: PUSH
76300: LD_INT 1
76302: NEG
76303: PUSH
76304: LD_INT 1
76306: NEG
76307: PUSH
76308: EMPTY
76309: LIST
76310: LIST
76311: PUSH
76312: LD_INT 1
76314: NEG
76315: PUSH
76316: LD_INT 2
76318: NEG
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 0
76326: PUSH
76327: LD_INT 2
76329: NEG
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: LD_INT 1
76337: PUSH
76338: LD_INT 1
76340: NEG
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 2
76348: PUSH
76349: LD_INT 0
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 2
76358: PUSH
76359: LD_INT 1
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 2
76368: PUSH
76369: LD_INT 2
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 1
76378: PUSH
76379: LD_INT 2
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PUSH
76386: LD_INT 0
76388: PUSH
76389: LD_INT 2
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: LD_INT 1
76398: NEG
76399: PUSH
76400: LD_INT 1
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: PUSH
76407: LD_INT 2
76409: NEG
76410: PUSH
76411: LD_INT 0
76413: PUSH
76414: EMPTY
76415: LIST
76416: LIST
76417: PUSH
76418: LD_INT 2
76420: NEG
76421: PUSH
76422: LD_INT 1
76424: NEG
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: LD_INT 2
76436: NEG
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: LIST
76451: LIST
76452: LIST
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: LIST
76458: LIST
76459: LIST
76460: LIST
76461: LIST
76462: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76463: LD_ADDR_VAR 0 55
76467: PUSH
76468: LD_INT 0
76470: PUSH
76471: LD_INT 0
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: PUSH
76478: LD_INT 0
76480: PUSH
76481: LD_INT 1
76483: NEG
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: PUSH
76489: LD_INT 1
76491: PUSH
76492: LD_INT 0
76494: PUSH
76495: EMPTY
76496: LIST
76497: LIST
76498: PUSH
76499: LD_INT 1
76501: PUSH
76502: LD_INT 1
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: LD_INT 0
76511: PUSH
76512: LD_INT 1
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: LD_INT 1
76521: NEG
76522: PUSH
76523: LD_INT 0
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 1
76532: NEG
76533: PUSH
76534: LD_INT 1
76536: NEG
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: PUSH
76542: LD_INT 1
76544: NEG
76545: PUSH
76546: LD_INT 2
76548: NEG
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 0
76556: PUSH
76557: LD_INT 2
76559: NEG
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: PUSH
76565: LD_INT 1
76567: PUSH
76568: LD_INT 1
76570: NEG
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: LD_INT 2
76578: PUSH
76579: LD_INT 0
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: LD_INT 2
76588: PUSH
76589: LD_INT 1
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: LD_INT 2
76598: PUSH
76599: LD_INT 2
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: PUSH
76606: LD_INT 1
76608: PUSH
76609: LD_INT 2
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: LD_INT 0
76618: PUSH
76619: LD_INT 2
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PUSH
76626: LD_INT 1
76628: NEG
76629: PUSH
76630: LD_INT 1
76632: PUSH
76633: EMPTY
76634: LIST
76635: LIST
76636: PUSH
76637: LD_INT 2
76639: NEG
76640: PUSH
76641: LD_INT 0
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: PUSH
76648: LD_INT 2
76650: NEG
76651: PUSH
76652: LD_INT 1
76654: NEG
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: LD_INT 2
76662: NEG
76663: PUSH
76664: LD_INT 2
76666: NEG
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: LIST
76682: LIST
76683: LIST
76684: LIST
76685: LIST
76686: LIST
76687: LIST
76688: LIST
76689: LIST
76690: LIST
76691: LIST
76692: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76693: LD_ADDR_VAR 0 56
76697: PUSH
76698: LD_INT 0
76700: PUSH
76701: LD_INT 0
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 0
76710: PUSH
76711: LD_INT 1
76713: NEG
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 1
76721: PUSH
76722: LD_INT 0
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 1
76731: PUSH
76732: LD_INT 1
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 0
76741: PUSH
76742: LD_INT 1
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: PUSH
76749: LD_INT 1
76751: NEG
76752: PUSH
76753: LD_INT 0
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PUSH
76760: LD_INT 1
76762: NEG
76763: PUSH
76764: LD_INT 1
76766: NEG
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PUSH
76772: LD_INT 1
76774: NEG
76775: PUSH
76776: LD_INT 2
76778: NEG
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: LD_INT 0
76786: PUSH
76787: LD_INT 2
76789: NEG
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: LD_INT 1
76797: PUSH
76798: LD_INT 1
76800: NEG
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 2
76808: PUSH
76809: LD_INT 0
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 2
76818: PUSH
76819: LD_INT 1
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 2
76828: PUSH
76829: LD_INT 2
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 1
76838: PUSH
76839: LD_INT 2
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 0
76848: PUSH
76849: LD_INT 2
76851: PUSH
76852: EMPTY
76853: LIST
76854: LIST
76855: PUSH
76856: LD_INT 1
76858: NEG
76859: PUSH
76860: LD_INT 1
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: LD_INT 2
76869: NEG
76870: PUSH
76871: LD_INT 0
76873: PUSH
76874: EMPTY
76875: LIST
76876: LIST
76877: PUSH
76878: LD_INT 2
76880: NEG
76881: PUSH
76882: LD_INT 1
76884: NEG
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 2
76892: NEG
76893: PUSH
76894: LD_INT 2
76896: NEG
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: LIST
76906: LIST
76907: LIST
76908: LIST
76909: LIST
76910: LIST
76911: LIST
76912: LIST
76913: LIST
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: LIST
76921: LIST
76922: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76923: LD_ADDR_VAR 0 57
76927: PUSH
76928: LD_INT 0
76930: PUSH
76931: LD_INT 0
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: LD_INT 0
76940: PUSH
76941: LD_INT 1
76943: NEG
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: PUSH
76949: LD_INT 1
76951: PUSH
76952: LD_INT 0
76954: PUSH
76955: EMPTY
76956: LIST
76957: LIST
76958: PUSH
76959: LD_INT 1
76961: PUSH
76962: LD_INT 1
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 0
76971: PUSH
76972: LD_INT 1
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 1
76981: NEG
76982: PUSH
76983: LD_INT 0
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 1
76992: NEG
76993: PUSH
76994: LD_INT 1
76996: NEG
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: PUSH
77002: LD_INT 1
77004: NEG
77005: PUSH
77006: LD_INT 2
77008: NEG
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 0
77016: PUSH
77017: LD_INT 2
77019: NEG
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: PUSH
77025: LD_INT 1
77027: PUSH
77028: LD_INT 1
77030: NEG
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 2
77038: PUSH
77039: LD_INT 0
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: LD_INT 1
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 2
77058: PUSH
77059: LD_INT 2
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 1
77068: PUSH
77069: LD_INT 2
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PUSH
77076: LD_INT 0
77078: PUSH
77079: LD_INT 2
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PUSH
77086: LD_INT 1
77088: NEG
77089: PUSH
77090: LD_INT 1
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 2
77099: NEG
77100: PUSH
77101: LD_INT 0
77103: PUSH
77104: EMPTY
77105: LIST
77106: LIST
77107: PUSH
77108: LD_INT 2
77110: NEG
77111: PUSH
77112: LD_INT 1
77114: NEG
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: LD_INT 2
77122: NEG
77123: PUSH
77124: LD_INT 2
77126: NEG
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: LIST
77136: LIST
77137: LIST
77138: LIST
77139: LIST
77140: LIST
77141: LIST
77142: LIST
77143: LIST
77144: LIST
77145: LIST
77146: LIST
77147: LIST
77148: LIST
77149: LIST
77150: LIST
77151: LIST
77152: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77153: LD_ADDR_VAR 0 58
77157: PUSH
77158: LD_INT 0
77160: PUSH
77161: LD_INT 0
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PUSH
77168: LD_INT 0
77170: PUSH
77171: LD_INT 1
77173: NEG
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 1
77181: PUSH
77182: LD_INT 0
77184: PUSH
77185: EMPTY
77186: LIST
77187: LIST
77188: PUSH
77189: LD_INT 1
77191: PUSH
77192: LD_INT 1
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: PUSH
77199: LD_INT 0
77201: PUSH
77202: LD_INT 1
77204: PUSH
77205: EMPTY
77206: LIST
77207: LIST
77208: PUSH
77209: LD_INT 1
77211: NEG
77212: PUSH
77213: LD_INT 0
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: PUSH
77220: LD_INT 1
77222: NEG
77223: PUSH
77224: LD_INT 1
77226: NEG
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: PUSH
77232: LD_INT 1
77234: NEG
77235: PUSH
77236: LD_INT 2
77238: NEG
77239: PUSH
77240: EMPTY
77241: LIST
77242: LIST
77243: PUSH
77244: LD_INT 0
77246: PUSH
77247: LD_INT 2
77249: NEG
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: PUSH
77255: LD_INT 1
77257: PUSH
77258: LD_INT 1
77260: NEG
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: LD_INT 2
77268: PUSH
77269: LD_INT 0
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 2
77278: PUSH
77279: LD_INT 1
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 2
77288: PUSH
77289: LD_INT 2
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 1
77298: PUSH
77299: LD_INT 2
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 0
77308: PUSH
77309: LD_INT 2
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 1
77318: NEG
77319: PUSH
77320: LD_INT 1
77322: PUSH
77323: EMPTY
77324: LIST
77325: LIST
77326: PUSH
77327: LD_INT 2
77329: NEG
77330: PUSH
77331: LD_INT 0
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 2
77340: NEG
77341: PUSH
77342: LD_INT 1
77344: NEG
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: LD_INT 2
77352: NEG
77353: PUSH
77354: LD_INT 2
77356: NEG
77357: PUSH
77358: EMPTY
77359: LIST
77360: LIST
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: LIST
77366: LIST
77367: LIST
77368: LIST
77369: LIST
77370: LIST
77371: LIST
77372: LIST
77373: LIST
77374: LIST
77375: LIST
77376: LIST
77377: LIST
77378: LIST
77379: LIST
77380: LIST
77381: LIST
77382: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77383: LD_ADDR_VAR 0 59
77387: PUSH
77388: LD_INT 0
77390: PUSH
77391: LD_INT 0
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PUSH
77398: LD_INT 0
77400: PUSH
77401: LD_INT 1
77403: NEG
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PUSH
77409: LD_INT 1
77411: PUSH
77412: LD_INT 0
77414: PUSH
77415: EMPTY
77416: LIST
77417: LIST
77418: PUSH
77419: LD_INT 1
77421: PUSH
77422: LD_INT 1
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 0
77431: PUSH
77432: LD_INT 1
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: PUSH
77439: LD_INT 1
77441: NEG
77442: PUSH
77443: LD_INT 0
77445: PUSH
77446: EMPTY
77447: LIST
77448: LIST
77449: PUSH
77450: LD_INT 1
77452: NEG
77453: PUSH
77454: LD_INT 1
77456: NEG
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: LIST
77466: LIST
77467: LIST
77468: LIST
77469: LIST
77470: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77471: LD_ADDR_VAR 0 60
77475: PUSH
77476: LD_INT 0
77478: PUSH
77479: LD_INT 0
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: LD_INT 0
77488: PUSH
77489: LD_INT 1
77491: NEG
77492: PUSH
77493: EMPTY
77494: LIST
77495: LIST
77496: PUSH
77497: LD_INT 1
77499: PUSH
77500: LD_INT 0
77502: PUSH
77503: EMPTY
77504: LIST
77505: LIST
77506: PUSH
77507: LD_INT 1
77509: PUSH
77510: LD_INT 1
77512: PUSH
77513: EMPTY
77514: LIST
77515: LIST
77516: PUSH
77517: LD_INT 0
77519: PUSH
77520: LD_INT 1
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PUSH
77527: LD_INT 1
77529: NEG
77530: PUSH
77531: LD_INT 0
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: LD_INT 1
77540: NEG
77541: PUSH
77542: LD_INT 1
77544: NEG
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: LIST
77554: LIST
77555: LIST
77556: LIST
77557: LIST
77558: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77559: LD_ADDR_VAR 0 61
77563: PUSH
77564: LD_INT 0
77566: PUSH
77567: LD_INT 0
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PUSH
77574: LD_INT 0
77576: PUSH
77577: LD_INT 1
77579: NEG
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_INT 1
77587: PUSH
77588: LD_INT 0
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 1
77597: PUSH
77598: LD_INT 1
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 0
77607: PUSH
77608: LD_INT 1
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: LD_INT 1
77617: NEG
77618: PUSH
77619: LD_INT 0
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: LD_INT 1
77628: NEG
77629: PUSH
77630: LD_INT 1
77632: NEG
77633: PUSH
77634: EMPTY
77635: LIST
77636: LIST
77637: PUSH
77638: EMPTY
77639: LIST
77640: LIST
77641: LIST
77642: LIST
77643: LIST
77644: LIST
77645: LIST
77646: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77647: LD_ADDR_VAR 0 62
77651: PUSH
77652: LD_INT 0
77654: PUSH
77655: LD_INT 0
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: LD_INT 0
77664: PUSH
77665: LD_INT 1
77667: NEG
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 1
77675: PUSH
77676: LD_INT 0
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_INT 1
77685: PUSH
77686: LD_INT 1
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 0
77695: PUSH
77696: LD_INT 1
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: LD_INT 1
77705: NEG
77706: PUSH
77707: LD_INT 0
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: PUSH
77714: LD_INT 1
77716: NEG
77717: PUSH
77718: LD_INT 1
77720: NEG
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77735: LD_ADDR_VAR 0 63
77739: PUSH
77740: LD_INT 0
77742: PUSH
77743: LD_INT 0
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: LD_INT 0
77752: PUSH
77753: LD_INT 1
77755: NEG
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PUSH
77761: LD_INT 1
77763: PUSH
77764: LD_INT 0
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: PUSH
77771: LD_INT 1
77773: PUSH
77774: LD_INT 1
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: PUSH
77781: LD_INT 0
77783: PUSH
77784: LD_INT 1
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: PUSH
77791: LD_INT 1
77793: NEG
77794: PUSH
77795: LD_INT 0
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 1
77804: NEG
77805: PUSH
77806: LD_INT 1
77808: NEG
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: PUSH
77814: EMPTY
77815: LIST
77816: LIST
77817: LIST
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77823: LD_ADDR_VAR 0 64
77827: PUSH
77828: LD_INT 0
77830: PUSH
77831: LD_INT 0
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 0
77840: PUSH
77841: LD_INT 1
77843: NEG
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 1
77851: PUSH
77852: LD_INT 0
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_INT 1
77861: PUSH
77862: LD_INT 1
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: LD_INT 0
77871: PUSH
77872: LD_INT 1
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 1
77881: NEG
77882: PUSH
77883: LD_INT 0
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 1
77892: NEG
77893: PUSH
77894: LD_INT 1
77896: NEG
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: LIST
77906: LIST
77907: LIST
77908: LIST
77909: LIST
77910: ST_TO_ADDR
// end ; 1 :
77911: GO 83808
77913: LD_INT 1
77915: DOUBLE
77916: EQUAL
77917: IFTRUE 77921
77919: GO 80544
77921: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77922: LD_ADDR_VAR 0 11
77926: PUSH
77927: LD_INT 1
77929: NEG
77930: PUSH
77931: LD_INT 3
77933: NEG
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 0
77941: PUSH
77942: LD_INT 3
77944: NEG
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: LD_INT 1
77952: PUSH
77953: LD_INT 2
77955: NEG
77956: PUSH
77957: EMPTY
77958: LIST
77959: LIST
77960: PUSH
77961: EMPTY
77962: LIST
77963: LIST
77964: LIST
77965: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77966: LD_ADDR_VAR 0 12
77970: PUSH
77971: LD_INT 2
77973: PUSH
77974: LD_INT 1
77976: NEG
77977: PUSH
77978: EMPTY
77979: LIST
77980: LIST
77981: PUSH
77982: LD_INT 3
77984: PUSH
77985: LD_INT 0
77987: PUSH
77988: EMPTY
77989: LIST
77990: LIST
77991: PUSH
77992: LD_INT 3
77994: PUSH
77995: LD_INT 1
77997: PUSH
77998: EMPTY
77999: LIST
78000: LIST
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: LIST
78006: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78007: LD_ADDR_VAR 0 13
78011: PUSH
78012: LD_INT 3
78014: PUSH
78015: LD_INT 2
78017: PUSH
78018: EMPTY
78019: LIST
78020: LIST
78021: PUSH
78022: LD_INT 3
78024: PUSH
78025: LD_INT 3
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 2
78034: PUSH
78035: LD_INT 3
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: LIST
78046: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78047: LD_ADDR_VAR 0 14
78051: PUSH
78052: LD_INT 1
78054: PUSH
78055: LD_INT 3
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: LD_INT 0
78064: PUSH
78065: LD_INT 3
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PUSH
78072: LD_INT 1
78074: NEG
78075: PUSH
78076: LD_INT 2
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: LIST
78087: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78088: LD_ADDR_VAR 0 15
78092: PUSH
78093: LD_INT 2
78095: NEG
78096: PUSH
78097: LD_INT 1
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 3
78106: NEG
78107: PUSH
78108: LD_INT 0
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 3
78117: NEG
78118: PUSH
78119: LD_INT 1
78121: NEG
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: LIST
78131: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78132: LD_ADDR_VAR 0 16
78136: PUSH
78137: LD_INT 2
78139: NEG
78140: PUSH
78141: LD_INT 3
78143: NEG
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 3
78151: NEG
78152: PUSH
78153: LD_INT 2
78155: NEG
78156: PUSH
78157: EMPTY
78158: LIST
78159: LIST
78160: PUSH
78161: LD_INT 3
78163: NEG
78164: PUSH
78165: LD_INT 3
78167: NEG
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: LIST
78177: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78178: LD_ADDR_VAR 0 17
78182: PUSH
78183: LD_INT 1
78185: NEG
78186: PUSH
78187: LD_INT 3
78189: NEG
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 0
78197: PUSH
78198: LD_INT 3
78200: NEG
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 1
78208: PUSH
78209: LD_INT 2
78211: NEG
78212: PUSH
78213: EMPTY
78214: LIST
78215: LIST
78216: PUSH
78217: EMPTY
78218: LIST
78219: LIST
78220: LIST
78221: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78222: LD_ADDR_VAR 0 18
78226: PUSH
78227: LD_INT 2
78229: PUSH
78230: LD_INT 1
78232: NEG
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 3
78240: PUSH
78241: LD_INT 0
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: PUSH
78248: LD_INT 3
78250: PUSH
78251: LD_INT 1
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: LIST
78262: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78263: LD_ADDR_VAR 0 19
78267: PUSH
78268: LD_INT 3
78270: PUSH
78271: LD_INT 2
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: LD_INT 3
78280: PUSH
78281: LD_INT 3
78283: PUSH
78284: EMPTY
78285: LIST
78286: LIST
78287: PUSH
78288: LD_INT 2
78290: PUSH
78291: LD_INT 3
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: LIST
78302: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78303: LD_ADDR_VAR 0 20
78307: PUSH
78308: LD_INT 1
78310: PUSH
78311: LD_INT 3
78313: PUSH
78314: EMPTY
78315: LIST
78316: LIST
78317: PUSH
78318: LD_INT 0
78320: PUSH
78321: LD_INT 3
78323: PUSH
78324: EMPTY
78325: LIST
78326: LIST
78327: PUSH
78328: LD_INT 1
78330: NEG
78331: PUSH
78332: LD_INT 2
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: LIST
78343: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78344: LD_ADDR_VAR 0 21
78348: PUSH
78349: LD_INT 2
78351: NEG
78352: PUSH
78353: LD_INT 1
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: LD_INT 3
78362: NEG
78363: PUSH
78364: LD_INT 0
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: PUSH
78371: LD_INT 3
78373: NEG
78374: PUSH
78375: LD_INT 1
78377: NEG
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: LIST
78387: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78388: LD_ADDR_VAR 0 22
78392: PUSH
78393: LD_INT 2
78395: NEG
78396: PUSH
78397: LD_INT 3
78399: NEG
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: PUSH
78405: LD_INT 3
78407: NEG
78408: PUSH
78409: LD_INT 2
78411: NEG
78412: PUSH
78413: EMPTY
78414: LIST
78415: LIST
78416: PUSH
78417: LD_INT 3
78419: NEG
78420: PUSH
78421: LD_INT 3
78423: NEG
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: LIST
78433: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78434: LD_ADDR_VAR 0 23
78438: PUSH
78439: LD_INT 0
78441: PUSH
78442: LD_INT 3
78444: NEG
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 1
78452: NEG
78453: PUSH
78454: LD_INT 4
78456: NEG
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 1
78464: PUSH
78465: LD_INT 3
78467: NEG
78468: PUSH
78469: EMPTY
78470: LIST
78471: LIST
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: LIST
78477: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78478: LD_ADDR_VAR 0 24
78482: PUSH
78483: LD_INT 3
78485: PUSH
78486: LD_INT 0
78488: PUSH
78489: EMPTY
78490: LIST
78491: LIST
78492: PUSH
78493: LD_INT 3
78495: PUSH
78496: LD_INT 1
78498: NEG
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PUSH
78504: LD_INT 4
78506: PUSH
78507: LD_INT 1
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: LIST
78518: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78519: LD_ADDR_VAR 0 25
78523: PUSH
78524: LD_INT 3
78526: PUSH
78527: LD_INT 3
78529: PUSH
78530: EMPTY
78531: LIST
78532: LIST
78533: PUSH
78534: LD_INT 4
78536: PUSH
78537: LD_INT 3
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: PUSH
78544: LD_INT 3
78546: PUSH
78547: LD_INT 4
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: LIST
78558: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78559: LD_ADDR_VAR 0 26
78563: PUSH
78564: LD_INT 0
78566: PUSH
78567: LD_INT 3
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 1
78576: PUSH
78577: LD_INT 4
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 1
78586: NEG
78587: PUSH
78588: LD_INT 3
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: LIST
78599: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78600: LD_ADDR_VAR 0 27
78604: PUSH
78605: LD_INT 3
78607: NEG
78608: PUSH
78609: LD_INT 0
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PUSH
78616: LD_INT 3
78618: NEG
78619: PUSH
78620: LD_INT 1
78622: PUSH
78623: EMPTY
78624: LIST
78625: LIST
78626: PUSH
78627: LD_INT 4
78629: NEG
78630: PUSH
78631: LD_INT 1
78633: NEG
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: LIST
78643: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78644: LD_ADDR_VAR 0 28
78648: PUSH
78649: LD_INT 3
78651: NEG
78652: PUSH
78653: LD_INT 3
78655: NEG
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 3
78663: NEG
78664: PUSH
78665: LD_INT 4
78667: NEG
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 4
78675: NEG
78676: PUSH
78677: LD_INT 3
78679: NEG
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: LIST
78689: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78690: LD_ADDR_VAR 0 29
78694: PUSH
78695: LD_INT 1
78697: NEG
78698: PUSH
78699: LD_INT 3
78701: NEG
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: LD_INT 0
78709: PUSH
78710: LD_INT 3
78712: NEG
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 1
78720: PUSH
78721: LD_INT 2
78723: NEG
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 1
78731: NEG
78732: PUSH
78733: LD_INT 4
78735: NEG
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: PUSH
78741: LD_INT 0
78743: PUSH
78744: LD_INT 4
78746: NEG
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 1
78754: PUSH
78755: LD_INT 3
78757: NEG
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: LD_INT 1
78765: NEG
78766: PUSH
78767: LD_INT 5
78769: NEG
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 0
78777: PUSH
78778: LD_INT 5
78780: NEG
78781: PUSH
78782: EMPTY
78783: LIST
78784: LIST
78785: PUSH
78786: LD_INT 1
78788: PUSH
78789: LD_INT 4
78791: NEG
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PUSH
78797: LD_INT 1
78799: NEG
78800: PUSH
78801: LD_INT 6
78803: NEG
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 0
78811: PUSH
78812: LD_INT 6
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 1
78822: PUSH
78823: LD_INT 5
78825: NEG
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: EMPTY
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: LIST
78837: LIST
78838: LIST
78839: LIST
78840: LIST
78841: LIST
78842: LIST
78843: LIST
78844: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78845: LD_ADDR_VAR 0 30
78849: PUSH
78850: LD_INT 2
78852: PUSH
78853: LD_INT 1
78855: NEG
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PUSH
78861: LD_INT 3
78863: PUSH
78864: LD_INT 0
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: PUSH
78871: LD_INT 3
78873: PUSH
78874: LD_INT 1
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: LD_INT 3
78883: PUSH
78884: LD_INT 1
78886: NEG
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 4
78894: PUSH
78895: LD_INT 0
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PUSH
78902: LD_INT 4
78904: PUSH
78905: LD_INT 1
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 4
78914: PUSH
78915: LD_INT 1
78917: NEG
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: LD_INT 5
78925: PUSH
78926: LD_INT 0
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: LD_INT 5
78935: PUSH
78936: LD_INT 1
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 5
78945: PUSH
78946: LD_INT 1
78948: NEG
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 6
78956: PUSH
78957: LD_INT 0
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 6
78966: PUSH
78967: LD_INT 1
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: LIST
78978: LIST
78979: LIST
78980: LIST
78981: LIST
78982: LIST
78983: LIST
78984: LIST
78985: LIST
78986: LIST
78987: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78988: LD_ADDR_VAR 0 31
78992: PUSH
78993: LD_INT 3
78995: PUSH
78996: LD_INT 2
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 3
79005: PUSH
79006: LD_INT 3
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 2
79015: PUSH
79016: LD_INT 3
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: PUSH
79023: LD_INT 4
79025: PUSH
79026: LD_INT 3
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 4
79035: PUSH
79036: LD_INT 4
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 3
79045: PUSH
79046: LD_INT 4
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 5
79055: PUSH
79056: LD_INT 4
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: LD_INT 5
79065: PUSH
79066: LD_INT 5
79068: PUSH
79069: EMPTY
79070: LIST
79071: LIST
79072: PUSH
79073: LD_INT 4
79075: PUSH
79076: LD_INT 5
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 6
79085: PUSH
79086: LD_INT 5
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 6
79095: PUSH
79096: LD_INT 6
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: LD_INT 5
79105: PUSH
79106: LD_INT 6
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: LIST
79123: LIST
79124: LIST
79125: LIST
79126: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79127: LD_ADDR_VAR 0 32
79131: PUSH
79132: LD_INT 1
79134: PUSH
79135: LD_INT 3
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: LD_INT 0
79144: PUSH
79145: LD_INT 3
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: LD_INT 1
79154: NEG
79155: PUSH
79156: LD_INT 2
79158: PUSH
79159: EMPTY
79160: LIST
79161: LIST
79162: PUSH
79163: LD_INT 1
79165: PUSH
79166: LD_INT 4
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 0
79175: PUSH
79176: LD_INT 4
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 1
79185: NEG
79186: PUSH
79187: LD_INT 3
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 1
79196: PUSH
79197: LD_INT 5
79199: PUSH
79200: EMPTY
79201: LIST
79202: LIST
79203: PUSH
79204: LD_INT 0
79206: PUSH
79207: LD_INT 5
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 1
79216: NEG
79217: PUSH
79218: LD_INT 4
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 1
79227: PUSH
79228: LD_INT 6
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 0
79237: PUSH
79238: LD_INT 6
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 1
79247: NEG
79248: PUSH
79249: LD_INT 5
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: LIST
79263: LIST
79264: LIST
79265: LIST
79266: LIST
79267: LIST
79268: LIST
79269: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79270: LD_ADDR_VAR 0 33
79274: PUSH
79275: LD_INT 2
79277: NEG
79278: PUSH
79279: LD_INT 1
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 3
79288: NEG
79289: PUSH
79290: LD_INT 0
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 3
79299: NEG
79300: PUSH
79301: LD_INT 1
79303: NEG
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 3
79311: NEG
79312: PUSH
79313: LD_INT 1
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 4
79322: NEG
79323: PUSH
79324: LD_INT 0
79326: PUSH
79327: EMPTY
79328: LIST
79329: LIST
79330: PUSH
79331: LD_INT 4
79333: NEG
79334: PUSH
79335: LD_INT 1
79337: NEG
79338: PUSH
79339: EMPTY
79340: LIST
79341: LIST
79342: PUSH
79343: LD_INT 4
79345: NEG
79346: PUSH
79347: LD_INT 1
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 5
79356: NEG
79357: PUSH
79358: LD_INT 0
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: PUSH
79365: LD_INT 5
79367: NEG
79368: PUSH
79369: LD_INT 1
79371: NEG
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: PUSH
79377: LD_INT 5
79379: NEG
79380: PUSH
79381: LD_INT 1
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 6
79390: NEG
79391: PUSH
79392: LD_INT 0
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 6
79401: NEG
79402: PUSH
79403: LD_INT 1
79405: NEG
79406: PUSH
79407: EMPTY
79408: LIST
79409: LIST
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79425: LD_ADDR_VAR 0 34
79429: PUSH
79430: LD_INT 2
79432: NEG
79433: PUSH
79434: LD_INT 3
79436: NEG
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PUSH
79442: LD_INT 3
79444: NEG
79445: PUSH
79446: LD_INT 2
79448: NEG
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: PUSH
79454: LD_INT 3
79456: NEG
79457: PUSH
79458: LD_INT 3
79460: NEG
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: LD_INT 3
79468: NEG
79469: PUSH
79470: LD_INT 4
79472: NEG
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 4
79480: NEG
79481: PUSH
79482: LD_INT 3
79484: NEG
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 4
79492: NEG
79493: PUSH
79494: LD_INT 4
79496: NEG
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PUSH
79502: LD_INT 4
79504: NEG
79505: PUSH
79506: LD_INT 5
79508: NEG
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 5
79516: NEG
79517: PUSH
79518: LD_INT 4
79520: NEG
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PUSH
79526: LD_INT 5
79528: NEG
79529: PUSH
79530: LD_INT 5
79532: NEG
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 5
79540: NEG
79541: PUSH
79542: LD_INT 6
79544: NEG
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 6
79552: NEG
79553: PUSH
79554: LD_INT 5
79556: NEG
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 6
79564: NEG
79565: PUSH
79566: LD_INT 6
79568: NEG
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: LIST
79578: LIST
79579: LIST
79580: LIST
79581: LIST
79582: LIST
79583: LIST
79584: LIST
79585: LIST
79586: LIST
79587: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79588: LD_ADDR_VAR 0 41
79592: PUSH
79593: LD_INT 0
79595: PUSH
79596: LD_INT 2
79598: NEG
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 1
79606: NEG
79607: PUSH
79608: LD_INT 3
79610: NEG
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 1
79618: PUSH
79619: LD_INT 2
79621: NEG
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: LIST
79631: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79632: LD_ADDR_VAR 0 42
79636: PUSH
79637: LD_INT 2
79639: PUSH
79640: LD_INT 0
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: LD_INT 2
79649: PUSH
79650: LD_INT 1
79652: NEG
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 3
79660: PUSH
79661: LD_INT 1
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: LIST
79672: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79673: LD_ADDR_VAR 0 43
79677: PUSH
79678: LD_INT 2
79680: PUSH
79681: LD_INT 2
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 3
79690: PUSH
79691: LD_INT 2
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 2
79700: PUSH
79701: LD_INT 3
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: LIST
79712: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79713: LD_ADDR_VAR 0 44
79717: PUSH
79718: LD_INT 0
79720: PUSH
79721: LD_INT 2
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: LD_INT 1
79730: PUSH
79731: LD_INT 3
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 1
79740: NEG
79741: PUSH
79742: LD_INT 2
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: LIST
79753: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79754: LD_ADDR_VAR 0 45
79758: PUSH
79759: LD_INT 2
79761: NEG
79762: PUSH
79763: LD_INT 0
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 2
79772: NEG
79773: PUSH
79774: LD_INT 1
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 3
79783: NEG
79784: PUSH
79785: LD_INT 1
79787: NEG
79788: PUSH
79789: EMPTY
79790: LIST
79791: LIST
79792: PUSH
79793: EMPTY
79794: LIST
79795: LIST
79796: LIST
79797: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79798: LD_ADDR_VAR 0 46
79802: PUSH
79803: LD_INT 2
79805: NEG
79806: PUSH
79807: LD_INT 2
79809: NEG
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: PUSH
79815: LD_INT 2
79817: NEG
79818: PUSH
79819: LD_INT 3
79821: NEG
79822: PUSH
79823: EMPTY
79824: LIST
79825: LIST
79826: PUSH
79827: LD_INT 3
79829: NEG
79830: PUSH
79831: LD_INT 2
79833: NEG
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: LIST
79843: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79844: LD_ADDR_VAR 0 47
79848: PUSH
79849: LD_INT 2
79851: NEG
79852: PUSH
79853: LD_INT 3
79855: NEG
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 1
79863: NEG
79864: PUSH
79865: LD_INT 3
79867: NEG
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: EMPTY
79874: LIST
79875: LIST
79876: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79877: LD_ADDR_VAR 0 48
79881: PUSH
79882: LD_INT 1
79884: PUSH
79885: LD_INT 2
79887: NEG
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 2
79895: PUSH
79896: LD_INT 1
79898: NEG
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79908: LD_ADDR_VAR 0 49
79912: PUSH
79913: LD_INT 3
79915: PUSH
79916: LD_INT 1
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PUSH
79923: LD_INT 3
79925: PUSH
79926: LD_INT 2
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79937: LD_ADDR_VAR 0 50
79941: PUSH
79942: LD_INT 2
79944: PUSH
79945: LD_INT 3
79947: PUSH
79948: EMPTY
79949: LIST
79950: LIST
79951: PUSH
79952: LD_INT 1
79954: PUSH
79955: LD_INT 3
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79966: LD_ADDR_VAR 0 51
79970: PUSH
79971: LD_INT 1
79973: NEG
79974: PUSH
79975: LD_INT 2
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: LD_INT 2
79984: NEG
79985: PUSH
79986: LD_INT 1
79988: PUSH
79989: EMPTY
79990: LIST
79991: LIST
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79997: LD_ADDR_VAR 0 52
80001: PUSH
80002: LD_INT 3
80004: NEG
80005: PUSH
80006: LD_INT 1
80008: NEG
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 3
80016: NEG
80017: PUSH
80018: LD_INT 2
80020: NEG
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: EMPTY
80027: LIST
80028: LIST
80029: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80030: LD_ADDR_VAR 0 53
80034: PUSH
80035: LD_INT 1
80037: NEG
80038: PUSH
80039: LD_INT 3
80041: NEG
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 0
80049: PUSH
80050: LD_INT 3
80052: NEG
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 1
80060: PUSH
80061: LD_INT 2
80063: NEG
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: EMPTY
80070: LIST
80071: LIST
80072: LIST
80073: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80074: LD_ADDR_VAR 0 54
80078: PUSH
80079: LD_INT 2
80081: PUSH
80082: LD_INT 1
80084: NEG
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 3
80092: PUSH
80093: LD_INT 0
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: PUSH
80100: LD_INT 3
80102: PUSH
80103: LD_INT 1
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: LIST
80114: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80115: LD_ADDR_VAR 0 55
80119: PUSH
80120: LD_INT 3
80122: PUSH
80123: LD_INT 2
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 3
80132: PUSH
80133: LD_INT 3
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 2
80142: PUSH
80143: LD_INT 3
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: LIST
80154: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80155: LD_ADDR_VAR 0 56
80159: PUSH
80160: LD_INT 1
80162: PUSH
80163: LD_INT 3
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 0
80172: PUSH
80173: LD_INT 3
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 1
80182: NEG
80183: PUSH
80184: LD_INT 2
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: LIST
80195: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80196: LD_ADDR_VAR 0 57
80200: PUSH
80201: LD_INT 2
80203: NEG
80204: PUSH
80205: LD_INT 1
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 3
80214: NEG
80215: PUSH
80216: LD_INT 0
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 3
80225: NEG
80226: PUSH
80227: LD_INT 1
80229: NEG
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: LIST
80239: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80240: LD_ADDR_VAR 0 58
80244: PUSH
80245: LD_INT 2
80247: NEG
80248: PUSH
80249: LD_INT 3
80251: NEG
80252: PUSH
80253: EMPTY
80254: LIST
80255: LIST
80256: PUSH
80257: LD_INT 3
80259: NEG
80260: PUSH
80261: LD_INT 2
80263: NEG
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 3
80271: NEG
80272: PUSH
80273: LD_INT 3
80275: NEG
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: LIST
80285: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80286: LD_ADDR_VAR 0 59
80290: PUSH
80291: LD_INT 1
80293: NEG
80294: PUSH
80295: LD_INT 2
80297: NEG
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 0
80305: PUSH
80306: LD_INT 2
80308: NEG
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 1
80316: PUSH
80317: LD_INT 1
80319: NEG
80320: PUSH
80321: EMPTY
80322: LIST
80323: LIST
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: LIST
80329: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80330: LD_ADDR_VAR 0 60
80334: PUSH
80335: LD_INT 1
80337: PUSH
80338: LD_INT 1
80340: NEG
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 2
80348: PUSH
80349: LD_INT 0
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 2
80358: PUSH
80359: LD_INT 1
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: LIST
80370: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80371: LD_ADDR_VAR 0 61
80375: PUSH
80376: LD_INT 2
80378: PUSH
80379: LD_INT 1
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: PUSH
80386: LD_INT 2
80388: PUSH
80389: LD_INT 2
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PUSH
80396: LD_INT 1
80398: PUSH
80399: LD_INT 2
80401: PUSH
80402: EMPTY
80403: LIST
80404: LIST
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: LIST
80410: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80411: LD_ADDR_VAR 0 62
80415: PUSH
80416: LD_INT 1
80418: PUSH
80419: LD_INT 2
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 0
80428: PUSH
80429: LD_INT 2
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 1
80438: NEG
80439: PUSH
80440: LD_INT 1
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: LIST
80451: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80452: LD_ADDR_VAR 0 63
80456: PUSH
80457: LD_INT 1
80459: NEG
80460: PUSH
80461: LD_INT 1
80463: PUSH
80464: EMPTY
80465: LIST
80466: LIST
80467: PUSH
80468: LD_INT 2
80470: NEG
80471: PUSH
80472: LD_INT 0
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: PUSH
80479: LD_INT 2
80481: NEG
80482: PUSH
80483: LD_INT 1
80485: NEG
80486: PUSH
80487: EMPTY
80488: LIST
80489: LIST
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: LIST
80495: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80496: LD_ADDR_VAR 0 64
80500: PUSH
80501: LD_INT 1
80503: NEG
80504: PUSH
80505: LD_INT 2
80507: NEG
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 2
80515: NEG
80516: PUSH
80517: LD_INT 1
80519: NEG
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 2
80527: NEG
80528: PUSH
80529: LD_INT 2
80531: NEG
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: LIST
80541: ST_TO_ADDR
// end ; 2 :
80542: GO 83808
80544: LD_INT 2
80546: DOUBLE
80547: EQUAL
80548: IFTRUE 80552
80550: GO 83807
80552: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80553: LD_ADDR_VAR 0 29
80557: PUSH
80558: LD_INT 4
80560: PUSH
80561: LD_INT 0
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 4
80570: PUSH
80571: LD_INT 1
80573: NEG
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: LD_INT 5
80581: PUSH
80582: LD_INT 0
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 5
80591: PUSH
80592: LD_INT 1
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 4
80601: PUSH
80602: LD_INT 1
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 3
80611: PUSH
80612: LD_INT 0
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 3
80621: PUSH
80622: LD_INT 1
80624: NEG
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 3
80632: PUSH
80633: LD_INT 2
80635: NEG
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 5
80643: PUSH
80644: LD_INT 2
80646: PUSH
80647: EMPTY
80648: LIST
80649: LIST
80650: PUSH
80651: LD_INT 3
80653: PUSH
80654: LD_INT 3
80656: PUSH
80657: EMPTY
80658: LIST
80659: LIST
80660: PUSH
80661: LD_INT 3
80663: PUSH
80664: LD_INT 2
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: PUSH
80671: LD_INT 4
80673: PUSH
80674: LD_INT 3
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 4
80683: PUSH
80684: LD_INT 4
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 3
80693: PUSH
80694: LD_INT 4
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 2
80703: PUSH
80704: LD_INT 3
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 2
80713: PUSH
80714: LD_INT 2
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 4
80723: PUSH
80724: LD_INT 2
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 2
80733: PUSH
80734: LD_INT 4
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: PUSH
80741: LD_INT 0
80743: PUSH
80744: LD_INT 4
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: LD_INT 0
80753: PUSH
80754: LD_INT 3
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: PUSH
80761: LD_INT 1
80763: PUSH
80764: LD_INT 4
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 1
80773: PUSH
80774: LD_INT 5
80776: PUSH
80777: EMPTY
80778: LIST
80779: LIST
80780: PUSH
80781: LD_INT 0
80783: PUSH
80784: LD_INT 5
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: PUSH
80791: LD_INT 1
80793: NEG
80794: PUSH
80795: LD_INT 4
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PUSH
80802: LD_INT 1
80804: NEG
80805: PUSH
80806: LD_INT 3
80808: PUSH
80809: EMPTY
80810: LIST
80811: LIST
80812: PUSH
80813: LD_INT 2
80815: PUSH
80816: LD_INT 5
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 2
80825: NEG
80826: PUSH
80827: LD_INT 3
80829: PUSH
80830: EMPTY
80831: LIST
80832: LIST
80833: PUSH
80834: LD_INT 3
80836: NEG
80837: PUSH
80838: LD_INT 0
80840: PUSH
80841: EMPTY
80842: LIST
80843: LIST
80844: PUSH
80845: LD_INT 3
80847: NEG
80848: PUSH
80849: LD_INT 1
80851: NEG
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 2
80859: NEG
80860: PUSH
80861: LD_INT 0
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: LD_INT 2
80870: NEG
80871: PUSH
80872: LD_INT 1
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: PUSH
80879: LD_INT 3
80881: NEG
80882: PUSH
80883: LD_INT 1
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PUSH
80890: LD_INT 4
80892: NEG
80893: PUSH
80894: LD_INT 0
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: PUSH
80901: LD_INT 4
80903: NEG
80904: PUSH
80905: LD_INT 1
80907: NEG
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 4
80915: NEG
80916: PUSH
80917: LD_INT 2
80919: NEG
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 2
80927: NEG
80928: PUSH
80929: LD_INT 2
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PUSH
80936: LD_INT 4
80938: NEG
80939: PUSH
80940: LD_INT 4
80942: NEG
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 4
80950: NEG
80951: PUSH
80952: LD_INT 5
80954: NEG
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 3
80962: NEG
80963: PUSH
80964: LD_INT 4
80966: NEG
80967: PUSH
80968: EMPTY
80969: LIST
80970: LIST
80971: PUSH
80972: LD_INT 3
80974: NEG
80975: PUSH
80976: LD_INT 3
80978: NEG
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: LD_INT 4
80986: NEG
80987: PUSH
80988: LD_INT 3
80990: NEG
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 5
80998: NEG
80999: PUSH
81000: LD_INT 4
81002: NEG
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: PUSH
81008: LD_INT 5
81010: NEG
81011: PUSH
81012: LD_INT 5
81014: NEG
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 3
81022: NEG
81023: PUSH
81024: LD_INT 5
81026: NEG
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 5
81034: NEG
81035: PUSH
81036: LD_INT 3
81038: NEG
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
81091: LD_ADDR_VAR 0 30
81095: PUSH
81096: LD_INT 4
81098: PUSH
81099: LD_INT 4
81101: PUSH
81102: EMPTY
81103: LIST
81104: LIST
81105: PUSH
81106: LD_INT 4
81108: PUSH
81109: LD_INT 3
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: LD_INT 5
81118: PUSH
81119: LD_INT 4
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 5
81128: PUSH
81129: LD_INT 5
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: LD_INT 4
81138: PUSH
81139: LD_INT 5
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 3
81148: PUSH
81149: LD_INT 4
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 3
81158: PUSH
81159: LD_INT 3
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 5
81168: PUSH
81169: LD_INT 3
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: PUSH
81176: LD_INT 3
81178: PUSH
81179: LD_INT 5
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PUSH
81186: LD_INT 0
81188: PUSH
81189: LD_INT 3
81191: PUSH
81192: EMPTY
81193: LIST
81194: LIST
81195: PUSH
81196: LD_INT 0
81198: PUSH
81199: LD_INT 2
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: PUSH
81206: LD_INT 1
81208: PUSH
81209: LD_INT 3
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 1
81218: PUSH
81219: LD_INT 4
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 0
81228: PUSH
81229: LD_INT 4
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: LD_INT 1
81238: NEG
81239: PUSH
81240: LD_INT 3
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 1
81249: NEG
81250: PUSH
81251: LD_INT 2
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 2
81260: PUSH
81261: LD_INT 4
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 2
81270: NEG
81271: PUSH
81272: LD_INT 2
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 4
81281: NEG
81282: PUSH
81283: LD_INT 0
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 4
81292: NEG
81293: PUSH
81294: LD_INT 1
81296: NEG
81297: PUSH
81298: EMPTY
81299: LIST
81300: LIST
81301: PUSH
81302: LD_INT 3
81304: NEG
81305: PUSH
81306: LD_INT 0
81308: PUSH
81309: EMPTY
81310: LIST
81311: LIST
81312: PUSH
81313: LD_INT 3
81315: NEG
81316: PUSH
81317: LD_INT 1
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 4
81326: NEG
81327: PUSH
81328: LD_INT 1
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 5
81337: NEG
81338: PUSH
81339: LD_INT 0
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: LD_INT 5
81348: NEG
81349: PUSH
81350: LD_INT 1
81352: NEG
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: LD_INT 5
81360: NEG
81361: PUSH
81362: LD_INT 2
81364: NEG
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 3
81372: NEG
81373: PUSH
81374: LD_INT 2
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: PUSH
81381: LD_INT 3
81383: NEG
81384: PUSH
81385: LD_INT 3
81387: NEG
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 3
81395: NEG
81396: PUSH
81397: LD_INT 4
81399: NEG
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 2
81407: NEG
81408: PUSH
81409: LD_INT 3
81411: NEG
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: PUSH
81417: LD_INT 2
81419: NEG
81420: PUSH
81421: LD_INT 2
81423: NEG
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: LD_INT 3
81431: NEG
81432: PUSH
81433: LD_INT 2
81435: NEG
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 4
81443: NEG
81444: PUSH
81445: LD_INT 3
81447: NEG
81448: PUSH
81449: EMPTY
81450: LIST
81451: LIST
81452: PUSH
81453: LD_INT 4
81455: NEG
81456: PUSH
81457: LD_INT 4
81459: NEG
81460: PUSH
81461: EMPTY
81462: LIST
81463: LIST
81464: PUSH
81465: LD_INT 2
81467: NEG
81468: PUSH
81469: LD_INT 4
81471: NEG
81472: PUSH
81473: EMPTY
81474: LIST
81475: LIST
81476: PUSH
81477: LD_INT 4
81479: NEG
81480: PUSH
81481: LD_INT 2
81483: NEG
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 0
81491: PUSH
81492: LD_INT 4
81494: NEG
81495: PUSH
81496: EMPTY
81497: LIST
81498: LIST
81499: PUSH
81500: LD_INT 0
81502: PUSH
81503: LD_INT 5
81505: NEG
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 1
81513: PUSH
81514: LD_INT 4
81516: NEG
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PUSH
81522: LD_INT 1
81524: PUSH
81525: LD_INT 3
81527: NEG
81528: PUSH
81529: EMPTY
81530: LIST
81531: LIST
81532: PUSH
81533: LD_INT 0
81535: PUSH
81536: LD_INT 3
81538: NEG
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: PUSH
81544: LD_INT 1
81546: NEG
81547: PUSH
81548: LD_INT 4
81550: NEG
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 1
81558: NEG
81559: PUSH
81560: LD_INT 5
81562: NEG
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: PUSH
81568: LD_INT 2
81570: PUSH
81571: LD_INT 3
81573: NEG
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 2
81581: NEG
81582: PUSH
81583: LD_INT 5
81585: NEG
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: LIST
81637: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81638: LD_ADDR_VAR 0 31
81642: PUSH
81643: LD_INT 0
81645: PUSH
81646: LD_INT 4
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 0
81655: PUSH
81656: LD_INT 3
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 1
81665: PUSH
81666: LD_INT 4
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 1
81675: PUSH
81676: LD_INT 5
81678: PUSH
81679: EMPTY
81680: LIST
81681: LIST
81682: PUSH
81683: LD_INT 0
81685: PUSH
81686: LD_INT 5
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PUSH
81693: LD_INT 1
81695: NEG
81696: PUSH
81697: LD_INT 4
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 1
81706: NEG
81707: PUSH
81708: LD_INT 3
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 2
81717: PUSH
81718: LD_INT 5
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 2
81727: NEG
81728: PUSH
81729: LD_INT 3
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 3
81738: NEG
81739: PUSH
81740: LD_INT 0
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 3
81749: NEG
81750: PUSH
81751: LD_INT 1
81753: NEG
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 2
81761: NEG
81762: PUSH
81763: LD_INT 0
81765: PUSH
81766: EMPTY
81767: LIST
81768: LIST
81769: PUSH
81770: LD_INT 2
81772: NEG
81773: PUSH
81774: LD_INT 1
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 3
81783: NEG
81784: PUSH
81785: LD_INT 1
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: PUSH
81792: LD_INT 4
81794: NEG
81795: PUSH
81796: LD_INT 0
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 4
81805: NEG
81806: PUSH
81807: LD_INT 1
81809: NEG
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 4
81817: NEG
81818: PUSH
81819: LD_INT 2
81821: NEG
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 2
81829: NEG
81830: PUSH
81831: LD_INT 2
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 4
81840: NEG
81841: PUSH
81842: LD_INT 4
81844: NEG
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 4
81852: NEG
81853: PUSH
81854: LD_INT 5
81856: NEG
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 3
81864: NEG
81865: PUSH
81866: LD_INT 4
81868: NEG
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: PUSH
81874: LD_INT 3
81876: NEG
81877: PUSH
81878: LD_INT 3
81880: NEG
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 4
81888: NEG
81889: PUSH
81890: LD_INT 3
81892: NEG
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: LD_INT 5
81900: NEG
81901: PUSH
81902: LD_INT 4
81904: NEG
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 5
81912: NEG
81913: PUSH
81914: LD_INT 5
81916: NEG
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 3
81924: NEG
81925: PUSH
81926: LD_INT 5
81928: NEG
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 5
81936: NEG
81937: PUSH
81938: LD_INT 3
81940: NEG
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 0
81948: PUSH
81949: LD_INT 3
81951: NEG
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 0
81959: PUSH
81960: LD_INT 4
81962: NEG
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 1
81970: PUSH
81971: LD_INT 3
81973: NEG
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 1
81981: PUSH
81982: LD_INT 2
81984: NEG
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: LD_INT 0
81992: PUSH
81993: LD_INT 2
81995: NEG
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 1
82003: NEG
82004: PUSH
82005: LD_INT 3
82007: NEG
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 1
82015: NEG
82016: PUSH
82017: LD_INT 4
82019: NEG
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 2
82027: PUSH
82028: LD_INT 2
82030: NEG
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 2
82038: NEG
82039: PUSH
82040: LD_INT 4
82042: NEG
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 4
82050: PUSH
82051: LD_INT 0
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 4
82060: PUSH
82061: LD_INT 1
82063: NEG
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_INT 5
82071: PUSH
82072: LD_INT 0
82074: PUSH
82075: EMPTY
82076: LIST
82077: LIST
82078: PUSH
82079: LD_INT 5
82081: PUSH
82082: LD_INT 1
82084: PUSH
82085: EMPTY
82086: LIST
82087: LIST
82088: PUSH
82089: LD_INT 4
82091: PUSH
82092: LD_INT 1
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 3
82101: PUSH
82102: LD_INT 0
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 3
82111: PUSH
82112: LD_INT 1
82114: NEG
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 3
82122: PUSH
82123: LD_INT 2
82125: NEG
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 5
82133: PUSH
82134: LD_INT 2
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82188: LD_ADDR_VAR 0 32
82192: PUSH
82193: LD_INT 4
82195: NEG
82196: PUSH
82197: LD_INT 0
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 4
82206: NEG
82207: PUSH
82208: LD_INT 1
82210: NEG
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 3
82218: NEG
82219: PUSH
82220: LD_INT 0
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: LD_INT 3
82229: NEG
82230: PUSH
82231: LD_INT 1
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: LD_INT 4
82240: NEG
82241: PUSH
82242: LD_INT 1
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 5
82251: NEG
82252: PUSH
82253: LD_INT 0
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 5
82262: NEG
82263: PUSH
82264: LD_INT 1
82266: NEG
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 5
82274: NEG
82275: PUSH
82276: LD_INT 2
82278: NEG
82279: PUSH
82280: EMPTY
82281: LIST
82282: LIST
82283: PUSH
82284: LD_INT 3
82286: NEG
82287: PUSH
82288: LD_INT 2
82290: PUSH
82291: EMPTY
82292: LIST
82293: LIST
82294: PUSH
82295: LD_INT 3
82297: NEG
82298: PUSH
82299: LD_INT 3
82301: NEG
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: PUSH
82307: LD_INT 3
82309: NEG
82310: PUSH
82311: LD_INT 4
82313: NEG
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 2
82321: NEG
82322: PUSH
82323: LD_INT 3
82325: NEG
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 2
82333: NEG
82334: PUSH
82335: LD_INT 2
82337: NEG
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 3
82345: NEG
82346: PUSH
82347: LD_INT 2
82349: NEG
82350: PUSH
82351: EMPTY
82352: LIST
82353: LIST
82354: PUSH
82355: LD_INT 4
82357: NEG
82358: PUSH
82359: LD_INT 3
82361: NEG
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 4
82369: NEG
82370: PUSH
82371: LD_INT 4
82373: NEG
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 2
82381: NEG
82382: PUSH
82383: LD_INT 4
82385: NEG
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: PUSH
82391: LD_INT 4
82393: NEG
82394: PUSH
82395: LD_INT 2
82397: NEG
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 0
82405: PUSH
82406: LD_INT 4
82408: NEG
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 0
82416: PUSH
82417: LD_INT 5
82419: NEG
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: PUSH
82425: LD_INT 1
82427: PUSH
82428: LD_INT 4
82430: NEG
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: LD_INT 1
82438: PUSH
82439: LD_INT 3
82441: NEG
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: LD_INT 0
82449: PUSH
82450: LD_INT 3
82452: NEG
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PUSH
82458: LD_INT 1
82460: NEG
82461: PUSH
82462: LD_INT 4
82464: NEG
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 1
82472: NEG
82473: PUSH
82474: LD_INT 5
82476: NEG
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 2
82484: PUSH
82485: LD_INT 3
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 2
82495: NEG
82496: PUSH
82497: LD_INT 5
82499: NEG
82500: PUSH
82501: EMPTY
82502: LIST
82503: LIST
82504: PUSH
82505: LD_INT 3
82507: PUSH
82508: LD_INT 0
82510: PUSH
82511: EMPTY
82512: LIST
82513: LIST
82514: PUSH
82515: LD_INT 3
82517: PUSH
82518: LD_INT 1
82520: NEG
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 4
82528: PUSH
82529: LD_INT 0
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: PUSH
82536: LD_INT 4
82538: PUSH
82539: LD_INT 1
82541: PUSH
82542: EMPTY
82543: LIST
82544: LIST
82545: PUSH
82546: LD_INT 3
82548: PUSH
82549: LD_INT 1
82551: PUSH
82552: EMPTY
82553: LIST
82554: LIST
82555: PUSH
82556: LD_INT 2
82558: PUSH
82559: LD_INT 0
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: LD_INT 2
82568: PUSH
82569: LD_INT 1
82571: NEG
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: LD_INT 2
82579: PUSH
82580: LD_INT 2
82582: NEG
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: PUSH
82588: LD_INT 4
82590: PUSH
82591: LD_INT 2
82593: PUSH
82594: EMPTY
82595: LIST
82596: LIST
82597: PUSH
82598: LD_INT 4
82600: PUSH
82601: LD_INT 4
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: LD_INT 4
82610: PUSH
82611: LD_INT 3
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: PUSH
82618: LD_INT 5
82620: PUSH
82621: LD_INT 4
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 5
82630: PUSH
82631: LD_INT 5
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 4
82640: PUSH
82641: LD_INT 5
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 3
82650: PUSH
82651: LD_INT 4
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 3
82660: PUSH
82661: LD_INT 3
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 5
82670: PUSH
82671: LD_INT 3
82673: PUSH
82674: EMPTY
82675: LIST
82676: LIST
82677: PUSH
82678: LD_INT 3
82680: PUSH
82681: LD_INT 5
82683: PUSH
82684: EMPTY
82685: LIST
82686: LIST
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: LIST
82692: LIST
82693: LIST
82694: LIST
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82735: LD_ADDR_VAR 0 33
82739: PUSH
82740: LD_INT 4
82742: NEG
82743: PUSH
82744: LD_INT 4
82746: NEG
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 4
82754: NEG
82755: PUSH
82756: LD_INT 5
82758: NEG
82759: PUSH
82760: EMPTY
82761: LIST
82762: LIST
82763: PUSH
82764: LD_INT 3
82766: NEG
82767: PUSH
82768: LD_INT 4
82770: NEG
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 3
82778: NEG
82779: PUSH
82780: LD_INT 3
82782: NEG
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 4
82790: NEG
82791: PUSH
82792: LD_INT 3
82794: NEG
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 5
82802: NEG
82803: PUSH
82804: LD_INT 4
82806: NEG
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 5
82814: NEG
82815: PUSH
82816: LD_INT 5
82818: NEG
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: PUSH
82824: LD_INT 3
82826: NEG
82827: PUSH
82828: LD_INT 5
82830: NEG
82831: PUSH
82832: EMPTY
82833: LIST
82834: LIST
82835: PUSH
82836: LD_INT 5
82838: NEG
82839: PUSH
82840: LD_INT 3
82842: NEG
82843: PUSH
82844: EMPTY
82845: LIST
82846: LIST
82847: PUSH
82848: LD_INT 0
82850: PUSH
82851: LD_INT 3
82853: NEG
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 0
82861: PUSH
82862: LD_INT 4
82864: NEG
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 1
82872: PUSH
82873: LD_INT 3
82875: NEG
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: LD_INT 1
82883: PUSH
82884: LD_INT 2
82886: NEG
82887: PUSH
82888: EMPTY
82889: LIST
82890: LIST
82891: PUSH
82892: LD_INT 0
82894: PUSH
82895: LD_INT 2
82897: NEG
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 1
82905: NEG
82906: PUSH
82907: LD_INT 3
82909: NEG
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 1
82917: NEG
82918: PUSH
82919: LD_INT 4
82921: NEG
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 2
82929: PUSH
82930: LD_INT 2
82932: NEG
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 2
82940: NEG
82941: PUSH
82942: LD_INT 4
82944: NEG
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 4
82952: PUSH
82953: LD_INT 0
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 4
82962: PUSH
82963: LD_INT 1
82965: NEG
82966: PUSH
82967: EMPTY
82968: LIST
82969: LIST
82970: PUSH
82971: LD_INT 5
82973: PUSH
82974: LD_INT 0
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: LD_INT 5
82983: PUSH
82984: LD_INT 1
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 4
82993: PUSH
82994: LD_INT 1
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_INT 3
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: EMPTY
83008: LIST
83009: LIST
83010: PUSH
83011: LD_INT 3
83013: PUSH
83014: LD_INT 1
83016: NEG
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 3
83024: PUSH
83025: LD_INT 2
83027: NEG
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 5
83035: PUSH
83036: LD_INT 2
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 3
83045: PUSH
83046: LD_INT 3
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 3
83055: PUSH
83056: LD_INT 2
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 4
83065: PUSH
83066: LD_INT 3
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 4
83075: PUSH
83076: LD_INT 4
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: PUSH
83083: LD_INT 3
83085: PUSH
83086: LD_INT 4
83088: PUSH
83089: EMPTY
83090: LIST
83091: LIST
83092: PUSH
83093: LD_INT 2
83095: PUSH
83096: LD_INT 3
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 2
83105: PUSH
83106: LD_INT 2
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: PUSH
83113: LD_INT 4
83115: PUSH
83116: LD_INT 2
83118: PUSH
83119: EMPTY
83120: LIST
83121: LIST
83122: PUSH
83123: LD_INT 2
83125: PUSH
83126: LD_INT 4
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 0
83135: PUSH
83136: LD_INT 4
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: PUSH
83143: LD_INT 0
83145: PUSH
83146: LD_INT 3
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: PUSH
83153: LD_INT 1
83155: PUSH
83156: LD_INT 4
83158: PUSH
83159: EMPTY
83160: LIST
83161: LIST
83162: PUSH
83163: LD_INT 1
83165: PUSH
83166: LD_INT 5
83168: PUSH
83169: EMPTY
83170: LIST
83171: LIST
83172: PUSH
83173: LD_INT 0
83175: PUSH
83176: LD_INT 5
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 1
83185: NEG
83186: PUSH
83187: LD_INT 4
83189: PUSH
83190: EMPTY
83191: LIST
83192: LIST
83193: PUSH
83194: LD_INT 1
83196: NEG
83197: PUSH
83198: LD_INT 3
83200: PUSH
83201: EMPTY
83202: LIST
83203: LIST
83204: PUSH
83205: LD_INT 2
83207: PUSH
83208: LD_INT 5
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: PUSH
83215: LD_INT 2
83217: NEG
83218: PUSH
83219: LD_INT 3
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: EMPTY
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83273: LD_ADDR_VAR 0 34
83277: PUSH
83278: LD_INT 0
83280: PUSH
83281: LD_INT 4
83283: NEG
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 0
83291: PUSH
83292: LD_INT 5
83294: NEG
83295: PUSH
83296: EMPTY
83297: LIST
83298: LIST
83299: PUSH
83300: LD_INT 1
83302: PUSH
83303: LD_INT 4
83305: NEG
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 1
83313: PUSH
83314: LD_INT 3
83316: NEG
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 0
83324: PUSH
83325: LD_INT 3
83327: NEG
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 1
83335: NEG
83336: PUSH
83337: LD_INT 4
83339: NEG
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: LD_INT 1
83347: NEG
83348: PUSH
83349: LD_INT 5
83351: NEG
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: LD_INT 2
83359: PUSH
83360: LD_INT 3
83362: NEG
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: PUSH
83368: LD_INT 2
83370: NEG
83371: PUSH
83372: LD_INT 5
83374: NEG
83375: PUSH
83376: EMPTY
83377: LIST
83378: LIST
83379: PUSH
83380: LD_INT 3
83382: PUSH
83383: LD_INT 0
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 3
83392: PUSH
83393: LD_INT 1
83395: NEG
83396: PUSH
83397: EMPTY
83398: LIST
83399: LIST
83400: PUSH
83401: LD_INT 4
83403: PUSH
83404: LD_INT 0
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: PUSH
83411: LD_INT 4
83413: PUSH
83414: LD_INT 1
83416: PUSH
83417: EMPTY
83418: LIST
83419: LIST
83420: PUSH
83421: LD_INT 3
83423: PUSH
83424: LD_INT 1
83426: PUSH
83427: EMPTY
83428: LIST
83429: LIST
83430: PUSH
83431: LD_INT 2
83433: PUSH
83434: LD_INT 0
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: PUSH
83441: LD_INT 2
83443: PUSH
83444: LD_INT 1
83446: NEG
83447: PUSH
83448: EMPTY
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 2
83454: PUSH
83455: LD_INT 2
83457: NEG
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 4
83465: PUSH
83466: LD_INT 2
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 4
83475: PUSH
83476: LD_INT 4
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: PUSH
83483: LD_INT 4
83485: PUSH
83486: LD_INT 3
83488: PUSH
83489: EMPTY
83490: LIST
83491: LIST
83492: PUSH
83493: LD_INT 5
83495: PUSH
83496: LD_INT 4
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 5
83505: PUSH
83506: LD_INT 5
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: LD_INT 4
83515: PUSH
83516: LD_INT 5
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 3
83525: PUSH
83526: LD_INT 4
83528: PUSH
83529: EMPTY
83530: LIST
83531: LIST
83532: PUSH
83533: LD_INT 3
83535: PUSH
83536: LD_INT 3
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: LD_INT 5
83545: PUSH
83546: LD_INT 3
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: PUSH
83553: LD_INT 3
83555: PUSH
83556: LD_INT 5
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 0
83565: PUSH
83566: LD_INT 3
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 0
83575: PUSH
83576: LD_INT 2
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PUSH
83583: LD_INT 1
83585: PUSH
83586: LD_INT 3
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 1
83595: PUSH
83596: LD_INT 4
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 0
83605: PUSH
83606: LD_INT 4
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: PUSH
83613: LD_INT 1
83615: NEG
83616: PUSH
83617: LD_INT 3
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 1
83626: NEG
83627: PUSH
83628: LD_INT 2
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: PUSH
83635: LD_INT 2
83637: PUSH
83638: LD_INT 4
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: PUSH
83645: LD_INT 2
83647: NEG
83648: PUSH
83649: LD_INT 2
83651: PUSH
83652: EMPTY
83653: LIST
83654: LIST
83655: PUSH
83656: LD_INT 4
83658: NEG
83659: PUSH
83660: LD_INT 0
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: PUSH
83667: LD_INT 4
83669: NEG
83670: PUSH
83671: LD_INT 1
83673: NEG
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PUSH
83679: LD_INT 3
83681: NEG
83682: PUSH
83683: LD_INT 0
83685: PUSH
83686: EMPTY
83687: LIST
83688: LIST
83689: PUSH
83690: LD_INT 3
83692: NEG
83693: PUSH
83694: LD_INT 1
83696: PUSH
83697: EMPTY
83698: LIST
83699: LIST
83700: PUSH
83701: LD_INT 4
83703: NEG
83704: PUSH
83705: LD_INT 1
83707: PUSH
83708: EMPTY
83709: LIST
83710: LIST
83711: PUSH
83712: LD_INT 5
83714: NEG
83715: PUSH
83716: LD_INT 0
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: PUSH
83723: LD_INT 5
83725: NEG
83726: PUSH
83727: LD_INT 1
83729: NEG
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: PUSH
83735: LD_INT 5
83737: NEG
83738: PUSH
83739: LD_INT 2
83741: NEG
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: LD_INT 3
83749: NEG
83750: PUSH
83751: LD_INT 2
83753: PUSH
83754: EMPTY
83755: LIST
83756: LIST
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: ST_TO_ADDR
// end ; end ;
83805: GO 83808
83807: POP
// case btype of b_depot , b_warehouse :
83808: LD_VAR 0 1
83812: PUSH
83813: LD_INT 0
83815: DOUBLE
83816: EQUAL
83817: IFTRUE 83827
83819: LD_INT 1
83821: DOUBLE
83822: EQUAL
83823: IFTRUE 83827
83825: GO 84028
83827: POP
// case nation of nation_american :
83828: LD_VAR 0 5
83832: PUSH
83833: LD_INT 1
83835: DOUBLE
83836: EQUAL
83837: IFTRUE 83841
83839: GO 83897
83841: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83842: LD_ADDR_VAR 0 9
83846: PUSH
83847: LD_VAR 0 11
83851: PUSH
83852: LD_VAR 0 12
83856: PUSH
83857: LD_VAR 0 13
83861: PUSH
83862: LD_VAR 0 14
83866: PUSH
83867: LD_VAR 0 15
83871: PUSH
83872: LD_VAR 0 16
83876: PUSH
83877: EMPTY
83878: LIST
83879: LIST
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: PUSH
83885: LD_VAR 0 4
83889: PUSH
83890: LD_INT 1
83892: PLUS
83893: ARRAY
83894: ST_TO_ADDR
83895: GO 84026
83897: LD_INT 2
83899: DOUBLE
83900: EQUAL
83901: IFTRUE 83905
83903: GO 83961
83905: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83906: LD_ADDR_VAR 0 9
83910: PUSH
83911: LD_VAR 0 17
83915: PUSH
83916: LD_VAR 0 18
83920: PUSH
83921: LD_VAR 0 19
83925: PUSH
83926: LD_VAR 0 20
83930: PUSH
83931: LD_VAR 0 21
83935: PUSH
83936: LD_VAR 0 22
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: PUSH
83949: LD_VAR 0 4
83953: PUSH
83954: LD_INT 1
83956: PLUS
83957: ARRAY
83958: ST_TO_ADDR
83959: GO 84026
83961: LD_INT 3
83963: DOUBLE
83964: EQUAL
83965: IFTRUE 83969
83967: GO 84025
83969: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83970: LD_ADDR_VAR 0 9
83974: PUSH
83975: LD_VAR 0 23
83979: PUSH
83980: LD_VAR 0 24
83984: PUSH
83985: LD_VAR 0 25
83989: PUSH
83990: LD_VAR 0 26
83994: PUSH
83995: LD_VAR 0 27
83999: PUSH
84000: LD_VAR 0 28
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: PUSH
84013: LD_VAR 0 4
84017: PUSH
84018: LD_INT 1
84020: PLUS
84021: ARRAY
84022: ST_TO_ADDR
84023: GO 84026
84025: POP
84026: GO 84581
84028: LD_INT 2
84030: DOUBLE
84031: EQUAL
84032: IFTRUE 84042
84034: LD_INT 3
84036: DOUBLE
84037: EQUAL
84038: IFTRUE 84042
84040: GO 84098
84042: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
84043: LD_ADDR_VAR 0 9
84047: PUSH
84048: LD_VAR 0 29
84052: PUSH
84053: LD_VAR 0 30
84057: PUSH
84058: LD_VAR 0 31
84062: PUSH
84063: LD_VAR 0 32
84067: PUSH
84068: LD_VAR 0 33
84072: PUSH
84073: LD_VAR 0 34
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: PUSH
84086: LD_VAR 0 4
84090: PUSH
84091: LD_INT 1
84093: PLUS
84094: ARRAY
84095: ST_TO_ADDR
84096: GO 84581
84098: LD_INT 16
84100: DOUBLE
84101: EQUAL
84102: IFTRUE 84160
84104: LD_INT 17
84106: DOUBLE
84107: EQUAL
84108: IFTRUE 84160
84110: LD_INT 18
84112: DOUBLE
84113: EQUAL
84114: IFTRUE 84160
84116: LD_INT 19
84118: DOUBLE
84119: EQUAL
84120: IFTRUE 84160
84122: LD_INT 22
84124: DOUBLE
84125: EQUAL
84126: IFTRUE 84160
84128: LD_INT 20
84130: DOUBLE
84131: EQUAL
84132: IFTRUE 84160
84134: LD_INT 21
84136: DOUBLE
84137: EQUAL
84138: IFTRUE 84160
84140: LD_INT 23
84142: DOUBLE
84143: EQUAL
84144: IFTRUE 84160
84146: LD_INT 24
84148: DOUBLE
84149: EQUAL
84150: IFTRUE 84160
84152: LD_INT 25
84154: DOUBLE
84155: EQUAL
84156: IFTRUE 84160
84158: GO 84216
84160: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84161: LD_ADDR_VAR 0 9
84165: PUSH
84166: LD_VAR 0 35
84170: PUSH
84171: LD_VAR 0 36
84175: PUSH
84176: LD_VAR 0 37
84180: PUSH
84181: LD_VAR 0 38
84185: PUSH
84186: LD_VAR 0 39
84190: PUSH
84191: LD_VAR 0 40
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: PUSH
84204: LD_VAR 0 4
84208: PUSH
84209: LD_INT 1
84211: PLUS
84212: ARRAY
84213: ST_TO_ADDR
84214: GO 84581
84216: LD_INT 6
84218: DOUBLE
84219: EQUAL
84220: IFTRUE 84272
84222: LD_INT 7
84224: DOUBLE
84225: EQUAL
84226: IFTRUE 84272
84228: LD_INT 8
84230: DOUBLE
84231: EQUAL
84232: IFTRUE 84272
84234: LD_INT 13
84236: DOUBLE
84237: EQUAL
84238: IFTRUE 84272
84240: LD_INT 12
84242: DOUBLE
84243: EQUAL
84244: IFTRUE 84272
84246: LD_INT 15
84248: DOUBLE
84249: EQUAL
84250: IFTRUE 84272
84252: LD_INT 11
84254: DOUBLE
84255: EQUAL
84256: IFTRUE 84272
84258: LD_INT 14
84260: DOUBLE
84261: EQUAL
84262: IFTRUE 84272
84264: LD_INT 10
84266: DOUBLE
84267: EQUAL
84268: IFTRUE 84272
84270: GO 84328
84272: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84273: LD_ADDR_VAR 0 9
84277: PUSH
84278: LD_VAR 0 41
84282: PUSH
84283: LD_VAR 0 42
84287: PUSH
84288: LD_VAR 0 43
84292: PUSH
84293: LD_VAR 0 44
84297: PUSH
84298: LD_VAR 0 45
84302: PUSH
84303: LD_VAR 0 46
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: PUSH
84316: LD_VAR 0 4
84320: PUSH
84321: LD_INT 1
84323: PLUS
84324: ARRAY
84325: ST_TO_ADDR
84326: GO 84581
84328: LD_INT 36
84330: DOUBLE
84331: EQUAL
84332: IFTRUE 84336
84334: GO 84392
84336: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84337: LD_ADDR_VAR 0 9
84341: PUSH
84342: LD_VAR 0 47
84346: PUSH
84347: LD_VAR 0 48
84351: PUSH
84352: LD_VAR 0 49
84356: PUSH
84357: LD_VAR 0 50
84361: PUSH
84362: LD_VAR 0 51
84366: PUSH
84367: LD_VAR 0 52
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: PUSH
84380: LD_VAR 0 4
84384: PUSH
84385: LD_INT 1
84387: PLUS
84388: ARRAY
84389: ST_TO_ADDR
84390: GO 84581
84392: LD_INT 4
84394: DOUBLE
84395: EQUAL
84396: IFTRUE 84418
84398: LD_INT 5
84400: DOUBLE
84401: EQUAL
84402: IFTRUE 84418
84404: LD_INT 34
84406: DOUBLE
84407: EQUAL
84408: IFTRUE 84418
84410: LD_INT 37
84412: DOUBLE
84413: EQUAL
84414: IFTRUE 84418
84416: GO 84474
84418: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84419: LD_ADDR_VAR 0 9
84423: PUSH
84424: LD_VAR 0 53
84428: PUSH
84429: LD_VAR 0 54
84433: PUSH
84434: LD_VAR 0 55
84438: PUSH
84439: LD_VAR 0 56
84443: PUSH
84444: LD_VAR 0 57
84448: PUSH
84449: LD_VAR 0 58
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: LIST
84458: LIST
84459: LIST
84460: LIST
84461: PUSH
84462: LD_VAR 0 4
84466: PUSH
84467: LD_INT 1
84469: PLUS
84470: ARRAY
84471: ST_TO_ADDR
84472: GO 84581
84474: LD_INT 31
84476: DOUBLE
84477: EQUAL
84478: IFTRUE 84524
84480: LD_INT 32
84482: DOUBLE
84483: EQUAL
84484: IFTRUE 84524
84486: LD_INT 33
84488: DOUBLE
84489: EQUAL
84490: IFTRUE 84524
84492: LD_INT 27
84494: DOUBLE
84495: EQUAL
84496: IFTRUE 84524
84498: LD_INT 26
84500: DOUBLE
84501: EQUAL
84502: IFTRUE 84524
84504: LD_INT 28
84506: DOUBLE
84507: EQUAL
84508: IFTRUE 84524
84510: LD_INT 29
84512: DOUBLE
84513: EQUAL
84514: IFTRUE 84524
84516: LD_INT 30
84518: DOUBLE
84519: EQUAL
84520: IFTRUE 84524
84522: GO 84580
84524: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84525: LD_ADDR_VAR 0 9
84529: PUSH
84530: LD_VAR 0 59
84534: PUSH
84535: LD_VAR 0 60
84539: PUSH
84540: LD_VAR 0 61
84544: PUSH
84545: LD_VAR 0 62
84549: PUSH
84550: LD_VAR 0 63
84554: PUSH
84555: LD_VAR 0 64
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: PUSH
84568: LD_VAR 0 4
84572: PUSH
84573: LD_INT 1
84575: PLUS
84576: ARRAY
84577: ST_TO_ADDR
84578: GO 84581
84580: POP
// temp_list2 = [ ] ;
84581: LD_ADDR_VAR 0 10
84585: PUSH
84586: EMPTY
84587: ST_TO_ADDR
// for i in temp_list do
84588: LD_ADDR_VAR 0 8
84592: PUSH
84593: LD_VAR 0 9
84597: PUSH
84598: FOR_IN
84599: IFFALSE 84651
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84601: LD_ADDR_VAR 0 10
84605: PUSH
84606: LD_VAR 0 10
84610: PUSH
84611: LD_VAR 0 8
84615: PUSH
84616: LD_INT 1
84618: ARRAY
84619: PUSH
84620: LD_VAR 0 2
84624: PLUS
84625: PUSH
84626: LD_VAR 0 8
84630: PUSH
84631: LD_INT 2
84633: ARRAY
84634: PUSH
84635: LD_VAR 0 3
84639: PLUS
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: EMPTY
84646: LIST
84647: ADD
84648: ST_TO_ADDR
84649: GO 84598
84651: POP
84652: POP
// result = temp_list2 ;
84653: LD_ADDR_VAR 0 7
84657: PUSH
84658: LD_VAR 0 10
84662: ST_TO_ADDR
// end ;
84663: LD_VAR 0 7
84667: RET
// export function EnemyInRange ( unit , dist ) ; begin
84668: LD_INT 0
84670: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84671: LD_ADDR_VAR 0 3
84675: PUSH
84676: LD_VAR 0 1
84680: PPUSH
84681: CALL_OW 255
84685: PPUSH
84686: LD_VAR 0 1
84690: PPUSH
84691: CALL_OW 250
84695: PPUSH
84696: LD_VAR 0 1
84700: PPUSH
84701: CALL_OW 251
84705: PPUSH
84706: LD_VAR 0 2
84710: PPUSH
84711: CALL 58070 0 4
84715: PUSH
84716: LD_INT 4
84718: ARRAY
84719: ST_TO_ADDR
// end ;
84720: LD_VAR 0 3
84724: RET
// export function PlayerSeeMe ( unit ) ; begin
84725: LD_INT 0
84727: PPUSH
// result := See ( your_side , unit ) ;
84728: LD_ADDR_VAR 0 2
84732: PUSH
84733: LD_OWVAR 2
84737: PPUSH
84738: LD_VAR 0 1
84742: PPUSH
84743: CALL_OW 292
84747: ST_TO_ADDR
// end ;
84748: LD_VAR 0 2
84752: RET
// export function ReverseDir ( unit ) ; begin
84753: LD_INT 0
84755: PPUSH
// if not unit then
84756: LD_VAR 0 1
84760: NOT
84761: IFFALSE 84765
// exit ;
84763: GO 84788
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84765: LD_ADDR_VAR 0 2
84769: PUSH
84770: LD_VAR 0 1
84774: PPUSH
84775: CALL_OW 254
84779: PUSH
84780: LD_INT 3
84782: PLUS
84783: PUSH
84784: LD_INT 6
84786: MOD
84787: ST_TO_ADDR
// end ;
84788: LD_VAR 0 2
84792: RET
// export function ReverseArray ( array ) ; var i ; begin
84793: LD_INT 0
84795: PPUSH
84796: PPUSH
// if not array then
84797: LD_VAR 0 1
84801: NOT
84802: IFFALSE 84806
// exit ;
84804: GO 84861
// result := [ ] ;
84806: LD_ADDR_VAR 0 2
84810: PUSH
84811: EMPTY
84812: ST_TO_ADDR
// for i := array downto 1 do
84813: LD_ADDR_VAR 0 3
84817: PUSH
84818: DOUBLE
84819: LD_VAR 0 1
84823: INC
84824: ST_TO_ADDR
84825: LD_INT 1
84827: PUSH
84828: FOR_DOWNTO
84829: IFFALSE 84859
// result := Join ( result , array [ i ] ) ;
84831: LD_ADDR_VAR 0 2
84835: PUSH
84836: LD_VAR 0 2
84840: PPUSH
84841: LD_VAR 0 1
84845: PUSH
84846: LD_VAR 0 3
84850: ARRAY
84851: PPUSH
84852: CALL 89504 0 2
84856: ST_TO_ADDR
84857: GO 84828
84859: POP
84860: POP
// end ;
84861: LD_VAR 0 2
84865: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
84866: LD_INT 0
84868: PPUSH
84869: PPUSH
84870: PPUSH
84871: PPUSH
84872: PPUSH
84873: PPUSH
// if not unit or not hexes then
84874: LD_VAR 0 1
84878: NOT
84879: PUSH
84880: LD_VAR 0 2
84884: NOT
84885: OR
84886: IFFALSE 84890
// exit ;
84888: GO 85013
// dist := 9999 ;
84890: LD_ADDR_VAR 0 5
84894: PUSH
84895: LD_INT 9999
84897: ST_TO_ADDR
// for i = 1 to hexes do
84898: LD_ADDR_VAR 0 4
84902: PUSH
84903: DOUBLE
84904: LD_INT 1
84906: DEC
84907: ST_TO_ADDR
84908: LD_VAR 0 2
84912: PUSH
84913: FOR_TO
84914: IFFALSE 85001
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84916: LD_ADDR_VAR 0 6
84920: PUSH
84921: LD_VAR 0 1
84925: PPUSH
84926: LD_VAR 0 2
84930: PUSH
84931: LD_VAR 0 4
84935: ARRAY
84936: PUSH
84937: LD_INT 1
84939: ARRAY
84940: PPUSH
84941: LD_VAR 0 2
84945: PUSH
84946: LD_VAR 0 4
84950: ARRAY
84951: PUSH
84952: LD_INT 2
84954: ARRAY
84955: PPUSH
84956: CALL_OW 297
84960: ST_TO_ADDR
// if tdist < dist then
84961: LD_VAR 0 6
84965: PUSH
84966: LD_VAR 0 5
84970: LESS
84971: IFFALSE 84999
// begin hex := hexes [ i ] ;
84973: LD_ADDR_VAR 0 8
84977: PUSH
84978: LD_VAR 0 2
84982: PUSH
84983: LD_VAR 0 4
84987: ARRAY
84988: ST_TO_ADDR
// dist := tdist ;
84989: LD_ADDR_VAR 0 5
84993: PUSH
84994: LD_VAR 0 6
84998: ST_TO_ADDR
// end ; end ;
84999: GO 84913
85001: POP
85002: POP
// result := hex ;
85003: LD_ADDR_VAR 0 3
85007: PUSH
85008: LD_VAR 0 8
85012: ST_TO_ADDR
// end ;
85013: LD_VAR 0 3
85017: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
85018: LD_INT 0
85020: PPUSH
85021: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85022: LD_VAR 0 1
85026: NOT
85027: PUSH
85028: LD_VAR 0 1
85032: PUSH
85033: LD_INT 21
85035: PUSH
85036: LD_INT 2
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: PUSH
85043: LD_INT 23
85045: PUSH
85046: LD_INT 2
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PPUSH
85057: CALL_OW 69
85061: IN
85062: NOT
85063: OR
85064: IFFALSE 85068
// exit ;
85066: GO 85115
// for i = 1 to 3 do
85068: LD_ADDR_VAR 0 3
85072: PUSH
85073: DOUBLE
85074: LD_INT 1
85076: DEC
85077: ST_TO_ADDR
85078: LD_INT 3
85080: PUSH
85081: FOR_TO
85082: IFFALSE 85113
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
85084: LD_VAR 0 1
85088: PPUSH
85089: CALL_OW 250
85093: PPUSH
85094: LD_VAR 0 1
85098: PPUSH
85099: CALL_OW 251
85103: PPUSH
85104: LD_INT 1
85106: PPUSH
85107: CALL_OW 453
85111: GO 85081
85113: POP
85114: POP
// end ;
85115: LD_VAR 0 2
85119: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
85120: LD_INT 0
85122: PPUSH
85123: PPUSH
85124: PPUSH
85125: PPUSH
85126: PPUSH
85127: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
85128: LD_VAR 0 1
85132: NOT
85133: PUSH
85134: LD_VAR 0 2
85138: NOT
85139: OR
85140: PUSH
85141: LD_VAR 0 1
85145: PPUSH
85146: CALL_OW 314
85150: OR
85151: IFFALSE 85155
// exit ;
85153: GO 85622
// if GetLives ( i ) < 250 then
85155: LD_VAR 0 4
85159: PPUSH
85160: CALL_OW 256
85164: PUSH
85165: LD_INT 250
85167: LESS
85168: IFFALSE 85181
// begin ComAutodestruct ( i ) ;
85170: LD_VAR 0 4
85174: PPUSH
85175: CALL 85018 0 1
// exit ;
85179: GO 85622
// end ; x := GetX ( enemy_unit ) ;
85181: LD_ADDR_VAR 0 7
85185: PUSH
85186: LD_VAR 0 2
85190: PPUSH
85191: CALL_OW 250
85195: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85196: LD_ADDR_VAR 0 8
85200: PUSH
85201: LD_VAR 0 2
85205: PPUSH
85206: CALL_OW 251
85210: ST_TO_ADDR
// if not x or not y then
85211: LD_VAR 0 7
85215: NOT
85216: PUSH
85217: LD_VAR 0 8
85221: NOT
85222: OR
85223: IFFALSE 85227
// exit ;
85225: GO 85622
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85227: LD_ADDR_VAR 0 6
85231: PUSH
85232: LD_VAR 0 7
85236: PPUSH
85237: LD_INT 0
85239: PPUSH
85240: LD_INT 4
85242: PPUSH
85243: CALL_OW 272
85247: PUSH
85248: LD_VAR 0 8
85252: PPUSH
85253: LD_INT 0
85255: PPUSH
85256: LD_INT 4
85258: PPUSH
85259: CALL_OW 273
85263: PUSH
85264: EMPTY
85265: LIST
85266: LIST
85267: PUSH
85268: LD_VAR 0 7
85272: PPUSH
85273: LD_INT 1
85275: PPUSH
85276: LD_INT 4
85278: PPUSH
85279: CALL_OW 272
85283: PUSH
85284: LD_VAR 0 8
85288: PPUSH
85289: LD_INT 1
85291: PPUSH
85292: LD_INT 4
85294: PPUSH
85295: CALL_OW 273
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: LD_VAR 0 7
85308: PPUSH
85309: LD_INT 2
85311: PPUSH
85312: LD_INT 4
85314: PPUSH
85315: CALL_OW 272
85319: PUSH
85320: LD_VAR 0 8
85324: PPUSH
85325: LD_INT 2
85327: PPUSH
85328: LD_INT 4
85330: PPUSH
85331: CALL_OW 273
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_VAR 0 7
85344: PPUSH
85345: LD_INT 3
85347: PPUSH
85348: LD_INT 4
85350: PPUSH
85351: CALL_OW 272
85355: PUSH
85356: LD_VAR 0 8
85360: PPUSH
85361: LD_INT 3
85363: PPUSH
85364: LD_INT 4
85366: PPUSH
85367: CALL_OW 273
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_VAR 0 7
85380: PPUSH
85381: LD_INT 4
85383: PPUSH
85384: LD_INT 4
85386: PPUSH
85387: CALL_OW 272
85391: PUSH
85392: LD_VAR 0 8
85396: PPUSH
85397: LD_INT 4
85399: PPUSH
85400: LD_INT 4
85402: PPUSH
85403: CALL_OW 273
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: PUSH
85412: LD_VAR 0 7
85416: PPUSH
85417: LD_INT 5
85419: PPUSH
85420: LD_INT 4
85422: PPUSH
85423: CALL_OW 272
85427: PUSH
85428: LD_VAR 0 8
85432: PPUSH
85433: LD_INT 5
85435: PPUSH
85436: LD_INT 4
85438: PPUSH
85439: CALL_OW 273
85443: PUSH
85444: EMPTY
85445: LIST
85446: LIST
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: LIST
85452: LIST
85453: LIST
85454: LIST
85455: ST_TO_ADDR
// for i = tmp downto 1 do
85456: LD_ADDR_VAR 0 4
85460: PUSH
85461: DOUBLE
85462: LD_VAR 0 6
85466: INC
85467: ST_TO_ADDR
85468: LD_INT 1
85470: PUSH
85471: FOR_DOWNTO
85472: IFFALSE 85573
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85474: LD_VAR 0 6
85478: PUSH
85479: LD_VAR 0 4
85483: ARRAY
85484: PUSH
85485: LD_INT 1
85487: ARRAY
85488: PPUSH
85489: LD_VAR 0 6
85493: PUSH
85494: LD_VAR 0 4
85498: ARRAY
85499: PUSH
85500: LD_INT 2
85502: ARRAY
85503: PPUSH
85504: CALL_OW 488
85508: NOT
85509: PUSH
85510: LD_VAR 0 6
85514: PUSH
85515: LD_VAR 0 4
85519: ARRAY
85520: PUSH
85521: LD_INT 1
85523: ARRAY
85524: PPUSH
85525: LD_VAR 0 6
85529: PUSH
85530: LD_VAR 0 4
85534: ARRAY
85535: PUSH
85536: LD_INT 2
85538: ARRAY
85539: PPUSH
85540: CALL_OW 428
85544: PUSH
85545: LD_INT 0
85547: NONEQUAL
85548: OR
85549: IFFALSE 85571
// tmp := Delete ( tmp , i ) ;
85551: LD_ADDR_VAR 0 6
85555: PUSH
85556: LD_VAR 0 6
85560: PPUSH
85561: LD_VAR 0 4
85565: PPUSH
85566: CALL_OW 3
85570: ST_TO_ADDR
85571: GO 85471
85573: POP
85574: POP
// j := GetClosestHex ( unit , tmp ) ;
85575: LD_ADDR_VAR 0 5
85579: PUSH
85580: LD_VAR 0 1
85584: PPUSH
85585: LD_VAR 0 6
85589: PPUSH
85590: CALL 84866 0 2
85594: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85595: LD_VAR 0 1
85599: PPUSH
85600: LD_VAR 0 5
85604: PUSH
85605: LD_INT 1
85607: ARRAY
85608: PPUSH
85609: LD_VAR 0 5
85613: PUSH
85614: LD_INT 2
85616: ARRAY
85617: PPUSH
85618: CALL_OW 111
// end ;
85622: LD_VAR 0 3
85626: RET
// export function PrepareApemanSoldier ( ) ; begin
85627: LD_INT 0
85629: PPUSH
// uc_nation := 0 ;
85630: LD_ADDR_OWVAR 21
85634: PUSH
85635: LD_INT 0
85637: ST_TO_ADDR
// hc_sex := sex_male ;
85638: LD_ADDR_OWVAR 27
85642: PUSH
85643: LD_INT 1
85645: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
85646: LD_ADDR_OWVAR 28
85650: PUSH
85651: LD_INT 15
85653: ST_TO_ADDR
// hc_gallery :=  ;
85654: LD_ADDR_OWVAR 33
85658: PUSH
85659: LD_STRING 
85661: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85662: LD_ADDR_OWVAR 31
85666: PUSH
85667: LD_INT 0
85669: PPUSH
85670: LD_INT 3
85672: PPUSH
85673: CALL_OW 12
85677: PUSH
85678: LD_INT 0
85680: PPUSH
85681: LD_INT 3
85683: PPUSH
85684: CALL_OW 12
85688: PUSH
85689: LD_INT 0
85691: PUSH
85692: LD_INT 0
85694: PUSH
85695: EMPTY
85696: LIST
85697: LIST
85698: LIST
85699: LIST
85700: ST_TO_ADDR
// end ;
85701: LD_VAR 0 1
85705: RET
// export function PrepareApemanEngineer ( ) ; begin
85706: LD_INT 0
85708: PPUSH
// uc_nation := 0 ;
85709: LD_ADDR_OWVAR 21
85713: PUSH
85714: LD_INT 0
85716: ST_TO_ADDR
// hc_sex := sex_male ;
85717: LD_ADDR_OWVAR 27
85721: PUSH
85722: LD_INT 1
85724: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
85725: LD_ADDR_OWVAR 28
85729: PUSH
85730: LD_INT 16
85732: ST_TO_ADDR
// hc_gallery :=  ;
85733: LD_ADDR_OWVAR 33
85737: PUSH
85738: LD_STRING 
85740: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85741: LD_ADDR_OWVAR 31
85745: PUSH
85746: LD_INT 0
85748: PPUSH
85749: LD_INT 3
85751: PPUSH
85752: CALL_OW 12
85756: PUSH
85757: LD_INT 0
85759: PPUSH
85760: LD_INT 3
85762: PPUSH
85763: CALL_OW 12
85767: PUSH
85768: LD_INT 0
85770: PUSH
85771: LD_INT 0
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: ST_TO_ADDR
// end ;
85780: LD_VAR 0 1
85784: RET
// export function PrepareApeman ( agressivity ) ; begin
85785: LD_INT 0
85787: PPUSH
// uc_side := 0 ;
85788: LD_ADDR_OWVAR 20
85792: PUSH
85793: LD_INT 0
85795: ST_TO_ADDR
// uc_nation := 0 ;
85796: LD_ADDR_OWVAR 21
85800: PUSH
85801: LD_INT 0
85803: ST_TO_ADDR
// hc_sex := sex_male ;
85804: LD_ADDR_OWVAR 27
85808: PUSH
85809: LD_INT 1
85811: ST_TO_ADDR
// hc_class := class_apeman ;
85812: LD_ADDR_OWVAR 28
85816: PUSH
85817: LD_INT 12
85819: ST_TO_ADDR
// hc_gallery :=  ;
85820: LD_ADDR_OWVAR 33
85824: PUSH
85825: LD_STRING 
85827: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85828: LD_ADDR_OWVAR 35
85832: PUSH
85833: LD_VAR 0 1
85837: NEG
85838: PPUSH
85839: LD_VAR 0 1
85843: PPUSH
85844: CALL_OW 12
85848: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85849: LD_ADDR_OWVAR 31
85853: PUSH
85854: LD_INT 0
85856: PPUSH
85857: LD_INT 3
85859: PPUSH
85860: CALL_OW 12
85864: PUSH
85865: LD_INT 0
85867: PPUSH
85868: LD_INT 3
85870: PPUSH
85871: CALL_OW 12
85875: PUSH
85876: LD_INT 0
85878: PUSH
85879: LD_INT 0
85881: PUSH
85882: EMPTY
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: ST_TO_ADDR
// end ;
85888: LD_VAR 0 2
85892: RET
// export function PrepareTiger ( agressivity ) ; begin
85893: LD_INT 0
85895: PPUSH
// uc_side := 0 ;
85896: LD_ADDR_OWVAR 20
85900: PUSH
85901: LD_INT 0
85903: ST_TO_ADDR
// uc_nation := 0 ;
85904: LD_ADDR_OWVAR 21
85908: PUSH
85909: LD_INT 0
85911: ST_TO_ADDR
// hc_class := class_tiger ;
85912: LD_ADDR_OWVAR 28
85916: PUSH
85917: LD_INT 14
85919: ST_TO_ADDR
// hc_gallery :=  ;
85920: LD_ADDR_OWVAR 33
85924: PUSH
85925: LD_STRING 
85927: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85928: LD_ADDR_OWVAR 35
85932: PUSH
85933: LD_VAR 0 1
85937: NEG
85938: PPUSH
85939: LD_VAR 0 1
85943: PPUSH
85944: CALL_OW 12
85948: ST_TO_ADDR
// end ;
85949: LD_VAR 0 2
85953: RET
// export function PrepareEnchidna ( ) ; begin
85954: LD_INT 0
85956: PPUSH
// uc_side := 0 ;
85957: LD_ADDR_OWVAR 20
85961: PUSH
85962: LD_INT 0
85964: ST_TO_ADDR
// uc_nation := 0 ;
85965: LD_ADDR_OWVAR 21
85969: PUSH
85970: LD_INT 0
85972: ST_TO_ADDR
// hc_class := class_baggie ;
85973: LD_ADDR_OWVAR 28
85977: PUSH
85978: LD_INT 13
85980: ST_TO_ADDR
// hc_gallery :=  ;
85981: LD_ADDR_OWVAR 33
85985: PUSH
85986: LD_STRING 
85988: ST_TO_ADDR
// end ;
85989: LD_VAR 0 1
85993: RET
// export function PrepareFrog ( ) ; begin
85994: LD_INT 0
85996: PPUSH
// uc_side := 0 ;
85997: LD_ADDR_OWVAR 20
86001: PUSH
86002: LD_INT 0
86004: ST_TO_ADDR
// uc_nation := 0 ;
86005: LD_ADDR_OWVAR 21
86009: PUSH
86010: LD_INT 0
86012: ST_TO_ADDR
// hc_class := class_frog ;
86013: LD_ADDR_OWVAR 28
86017: PUSH
86018: LD_INT 19
86020: ST_TO_ADDR
// hc_gallery :=  ;
86021: LD_ADDR_OWVAR 33
86025: PUSH
86026: LD_STRING 
86028: ST_TO_ADDR
// end ;
86029: LD_VAR 0 1
86033: RET
// export function PrepareFish ( ) ; begin
86034: LD_INT 0
86036: PPUSH
// uc_side := 0 ;
86037: LD_ADDR_OWVAR 20
86041: PUSH
86042: LD_INT 0
86044: ST_TO_ADDR
// uc_nation := 0 ;
86045: LD_ADDR_OWVAR 21
86049: PUSH
86050: LD_INT 0
86052: ST_TO_ADDR
// hc_class := class_fish ;
86053: LD_ADDR_OWVAR 28
86057: PUSH
86058: LD_INT 20
86060: ST_TO_ADDR
// hc_gallery :=  ;
86061: LD_ADDR_OWVAR 33
86065: PUSH
86066: LD_STRING 
86068: ST_TO_ADDR
// end ;
86069: LD_VAR 0 1
86073: RET
// export function PrepareBird ( ) ; begin
86074: LD_INT 0
86076: PPUSH
// uc_side := 0 ;
86077: LD_ADDR_OWVAR 20
86081: PUSH
86082: LD_INT 0
86084: ST_TO_ADDR
// uc_nation := 0 ;
86085: LD_ADDR_OWVAR 21
86089: PUSH
86090: LD_INT 0
86092: ST_TO_ADDR
// hc_class := class_phororhacos ;
86093: LD_ADDR_OWVAR 28
86097: PUSH
86098: LD_INT 18
86100: ST_TO_ADDR
// hc_gallery :=  ;
86101: LD_ADDR_OWVAR 33
86105: PUSH
86106: LD_STRING 
86108: ST_TO_ADDR
// end ;
86109: LD_VAR 0 1
86113: RET
// export function PrepareHorse ( ) ; begin
86114: LD_INT 0
86116: PPUSH
// uc_side := 0 ;
86117: LD_ADDR_OWVAR 20
86121: PUSH
86122: LD_INT 0
86124: ST_TO_ADDR
// uc_nation := 0 ;
86125: LD_ADDR_OWVAR 21
86129: PUSH
86130: LD_INT 0
86132: ST_TO_ADDR
// hc_class := class_horse ;
86133: LD_ADDR_OWVAR 28
86137: PUSH
86138: LD_INT 21
86140: ST_TO_ADDR
// hc_gallery :=  ;
86141: LD_ADDR_OWVAR 33
86145: PUSH
86146: LD_STRING 
86148: ST_TO_ADDR
// end ;
86149: LD_VAR 0 1
86153: RET
// export function PrepareMastodont ( ) ; begin
86154: LD_INT 0
86156: PPUSH
// uc_side := 0 ;
86157: LD_ADDR_OWVAR 20
86161: PUSH
86162: LD_INT 0
86164: ST_TO_ADDR
// uc_nation := 0 ;
86165: LD_ADDR_OWVAR 21
86169: PUSH
86170: LD_INT 0
86172: ST_TO_ADDR
// vc_chassis := class_mastodont ;
86173: LD_ADDR_OWVAR 37
86177: PUSH
86178: LD_INT 31
86180: ST_TO_ADDR
// vc_control := control_rider ;
86181: LD_ADDR_OWVAR 38
86185: PUSH
86186: LD_INT 4
86188: ST_TO_ADDR
// end ;
86189: LD_VAR 0 1
86193: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
86194: LD_INT 0
86196: PPUSH
86197: PPUSH
86198: PPUSH
// uc_side = 0 ;
86199: LD_ADDR_OWVAR 20
86203: PUSH
86204: LD_INT 0
86206: ST_TO_ADDR
// uc_nation = 0 ;
86207: LD_ADDR_OWVAR 21
86211: PUSH
86212: LD_INT 0
86214: ST_TO_ADDR
// InitHc_All ( ) ;
86215: CALL_OW 584
// InitVc ;
86219: CALL_OW 20
// if mastodonts then
86223: LD_VAR 0 6
86227: IFFALSE 86294
// for i = 1 to mastodonts do
86229: LD_ADDR_VAR 0 11
86233: PUSH
86234: DOUBLE
86235: LD_INT 1
86237: DEC
86238: ST_TO_ADDR
86239: LD_VAR 0 6
86243: PUSH
86244: FOR_TO
86245: IFFALSE 86292
// begin vc_chassis := 31 ;
86247: LD_ADDR_OWVAR 37
86251: PUSH
86252: LD_INT 31
86254: ST_TO_ADDR
// vc_control := control_rider ;
86255: LD_ADDR_OWVAR 38
86259: PUSH
86260: LD_INT 4
86262: ST_TO_ADDR
// animal := CreateVehicle ;
86263: LD_ADDR_VAR 0 12
86267: PUSH
86268: CALL_OW 45
86272: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86273: LD_VAR 0 12
86277: PPUSH
86278: LD_VAR 0 8
86282: PPUSH
86283: LD_INT 0
86285: PPUSH
86286: CALL 88422 0 3
// end ;
86290: GO 86244
86292: POP
86293: POP
// if horses then
86294: LD_VAR 0 5
86298: IFFALSE 86365
// for i = 1 to horses do
86300: LD_ADDR_VAR 0 11
86304: PUSH
86305: DOUBLE
86306: LD_INT 1
86308: DEC
86309: ST_TO_ADDR
86310: LD_VAR 0 5
86314: PUSH
86315: FOR_TO
86316: IFFALSE 86363
// begin hc_class := 21 ;
86318: LD_ADDR_OWVAR 28
86322: PUSH
86323: LD_INT 21
86325: ST_TO_ADDR
// hc_gallery :=  ;
86326: LD_ADDR_OWVAR 33
86330: PUSH
86331: LD_STRING 
86333: ST_TO_ADDR
// animal := CreateHuman ;
86334: LD_ADDR_VAR 0 12
86338: PUSH
86339: CALL_OW 44
86343: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86344: LD_VAR 0 12
86348: PPUSH
86349: LD_VAR 0 8
86353: PPUSH
86354: LD_INT 0
86356: PPUSH
86357: CALL 88422 0 3
// end ;
86361: GO 86315
86363: POP
86364: POP
// if birds then
86365: LD_VAR 0 1
86369: IFFALSE 86436
// for i = 1 to birds do
86371: LD_ADDR_VAR 0 11
86375: PUSH
86376: DOUBLE
86377: LD_INT 1
86379: DEC
86380: ST_TO_ADDR
86381: LD_VAR 0 1
86385: PUSH
86386: FOR_TO
86387: IFFALSE 86434
// begin hc_class = 18 ;
86389: LD_ADDR_OWVAR 28
86393: PUSH
86394: LD_INT 18
86396: ST_TO_ADDR
// hc_gallery =  ;
86397: LD_ADDR_OWVAR 33
86401: PUSH
86402: LD_STRING 
86404: ST_TO_ADDR
// animal := CreateHuman ;
86405: LD_ADDR_VAR 0 12
86409: PUSH
86410: CALL_OW 44
86414: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86415: LD_VAR 0 12
86419: PPUSH
86420: LD_VAR 0 8
86424: PPUSH
86425: LD_INT 0
86427: PPUSH
86428: CALL 88422 0 3
// end ;
86432: GO 86386
86434: POP
86435: POP
// if tigers then
86436: LD_VAR 0 2
86440: IFFALSE 86524
// for i = 1 to tigers do
86442: LD_ADDR_VAR 0 11
86446: PUSH
86447: DOUBLE
86448: LD_INT 1
86450: DEC
86451: ST_TO_ADDR
86452: LD_VAR 0 2
86456: PUSH
86457: FOR_TO
86458: IFFALSE 86522
// begin hc_class = class_tiger ;
86460: LD_ADDR_OWVAR 28
86464: PUSH
86465: LD_INT 14
86467: ST_TO_ADDR
// hc_gallery =  ;
86468: LD_ADDR_OWVAR 33
86472: PUSH
86473: LD_STRING 
86475: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
86476: LD_ADDR_OWVAR 35
86480: PUSH
86481: LD_INT 7
86483: NEG
86484: PPUSH
86485: LD_INT 7
86487: PPUSH
86488: CALL_OW 12
86492: ST_TO_ADDR
// animal := CreateHuman ;
86493: LD_ADDR_VAR 0 12
86497: PUSH
86498: CALL_OW 44
86502: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86503: LD_VAR 0 12
86507: PPUSH
86508: LD_VAR 0 8
86512: PPUSH
86513: LD_INT 0
86515: PPUSH
86516: CALL 88422 0 3
// end ;
86520: GO 86457
86522: POP
86523: POP
// if apemans then
86524: LD_VAR 0 3
86528: IFFALSE 86651
// for i = 1 to apemans do
86530: LD_ADDR_VAR 0 11
86534: PUSH
86535: DOUBLE
86536: LD_INT 1
86538: DEC
86539: ST_TO_ADDR
86540: LD_VAR 0 3
86544: PUSH
86545: FOR_TO
86546: IFFALSE 86649
// begin hc_class = class_apeman ;
86548: LD_ADDR_OWVAR 28
86552: PUSH
86553: LD_INT 12
86555: ST_TO_ADDR
// hc_gallery =  ;
86556: LD_ADDR_OWVAR 33
86560: PUSH
86561: LD_STRING 
86563: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
86564: LD_ADDR_OWVAR 35
86568: PUSH
86569: LD_INT 2
86571: NEG
86572: PPUSH
86573: LD_INT 2
86575: PPUSH
86576: CALL_OW 12
86580: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
86581: LD_ADDR_OWVAR 31
86585: PUSH
86586: LD_INT 1
86588: PPUSH
86589: LD_INT 3
86591: PPUSH
86592: CALL_OW 12
86596: PUSH
86597: LD_INT 1
86599: PPUSH
86600: LD_INT 3
86602: PPUSH
86603: CALL_OW 12
86607: PUSH
86608: LD_INT 0
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: LIST
86618: LIST
86619: ST_TO_ADDR
// animal := CreateHuman ;
86620: LD_ADDR_VAR 0 12
86624: PUSH
86625: CALL_OW 44
86629: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86630: LD_VAR 0 12
86634: PPUSH
86635: LD_VAR 0 8
86639: PPUSH
86640: LD_INT 0
86642: PPUSH
86643: CALL 88422 0 3
// end ;
86647: GO 86545
86649: POP
86650: POP
// if enchidnas then
86651: LD_VAR 0 4
86655: IFFALSE 86722
// for i = 1 to enchidnas do
86657: LD_ADDR_VAR 0 11
86661: PUSH
86662: DOUBLE
86663: LD_INT 1
86665: DEC
86666: ST_TO_ADDR
86667: LD_VAR 0 4
86671: PUSH
86672: FOR_TO
86673: IFFALSE 86720
// begin hc_class = 13 ;
86675: LD_ADDR_OWVAR 28
86679: PUSH
86680: LD_INT 13
86682: ST_TO_ADDR
// hc_gallery =  ;
86683: LD_ADDR_OWVAR 33
86687: PUSH
86688: LD_STRING 
86690: ST_TO_ADDR
// animal := CreateHuman ;
86691: LD_ADDR_VAR 0 12
86695: PUSH
86696: CALL_OW 44
86700: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86701: LD_VAR 0 12
86705: PPUSH
86706: LD_VAR 0 8
86710: PPUSH
86711: LD_INT 0
86713: PPUSH
86714: CALL 88422 0 3
// end ;
86718: GO 86672
86720: POP
86721: POP
// if fishes then
86722: LD_VAR 0 7
86726: IFFALSE 86793
// for i = 1 to fishes do
86728: LD_ADDR_VAR 0 11
86732: PUSH
86733: DOUBLE
86734: LD_INT 1
86736: DEC
86737: ST_TO_ADDR
86738: LD_VAR 0 7
86742: PUSH
86743: FOR_TO
86744: IFFALSE 86791
// begin hc_class = 20 ;
86746: LD_ADDR_OWVAR 28
86750: PUSH
86751: LD_INT 20
86753: ST_TO_ADDR
// hc_gallery =  ;
86754: LD_ADDR_OWVAR 33
86758: PUSH
86759: LD_STRING 
86761: ST_TO_ADDR
// animal := CreateHuman ;
86762: LD_ADDR_VAR 0 12
86766: PUSH
86767: CALL_OW 44
86771: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
86772: LD_VAR 0 12
86776: PPUSH
86777: LD_VAR 0 9
86781: PPUSH
86782: LD_INT 0
86784: PPUSH
86785: CALL 88422 0 3
// end ;
86789: GO 86743
86791: POP
86792: POP
// end ;
86793: LD_VAR 0 10
86797: RET
// export function WantHeal ( sci , unit ) ; begin
86798: LD_INT 0
86800: PPUSH
// if GetTaskList ( sci ) > 0 then
86801: LD_VAR 0 1
86805: PPUSH
86806: CALL_OW 437
86810: PUSH
86811: LD_INT 0
86813: GREATER
86814: IFFALSE 86884
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86816: LD_VAR 0 1
86820: PPUSH
86821: CALL_OW 437
86825: PUSH
86826: LD_INT 1
86828: ARRAY
86829: PUSH
86830: LD_INT 1
86832: ARRAY
86833: PUSH
86834: LD_STRING l
86836: EQUAL
86837: PUSH
86838: LD_VAR 0 1
86842: PPUSH
86843: CALL_OW 437
86847: PUSH
86848: LD_INT 1
86850: ARRAY
86851: PUSH
86852: LD_INT 4
86854: ARRAY
86855: PUSH
86856: LD_VAR 0 2
86860: EQUAL
86861: AND
86862: IFFALSE 86874
// result := true else
86864: LD_ADDR_VAR 0 3
86868: PUSH
86869: LD_INT 1
86871: ST_TO_ADDR
86872: GO 86882
// result := false ;
86874: LD_ADDR_VAR 0 3
86878: PUSH
86879: LD_INT 0
86881: ST_TO_ADDR
// end else
86882: GO 86892
// result := false ;
86884: LD_ADDR_VAR 0 3
86888: PUSH
86889: LD_INT 0
86891: ST_TO_ADDR
// end ;
86892: LD_VAR 0 3
86896: RET
// export function HealTarget ( sci ) ; begin
86897: LD_INT 0
86899: PPUSH
// if not sci then
86900: LD_VAR 0 1
86904: NOT
86905: IFFALSE 86909
// exit ;
86907: GO 86974
// result := 0 ;
86909: LD_ADDR_VAR 0 2
86913: PUSH
86914: LD_INT 0
86916: ST_TO_ADDR
// if GetTaskList ( sci ) then
86917: LD_VAR 0 1
86921: PPUSH
86922: CALL_OW 437
86926: IFFALSE 86974
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86928: LD_VAR 0 1
86932: PPUSH
86933: CALL_OW 437
86937: PUSH
86938: LD_INT 1
86940: ARRAY
86941: PUSH
86942: LD_INT 1
86944: ARRAY
86945: PUSH
86946: LD_STRING l
86948: EQUAL
86949: IFFALSE 86974
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86951: LD_ADDR_VAR 0 2
86955: PUSH
86956: LD_VAR 0 1
86960: PPUSH
86961: CALL_OW 437
86965: PUSH
86966: LD_INT 1
86968: ARRAY
86969: PUSH
86970: LD_INT 4
86972: ARRAY
86973: ST_TO_ADDR
// end ;
86974: LD_VAR 0 2
86978: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86979: LD_INT 0
86981: PPUSH
86982: PPUSH
86983: PPUSH
86984: PPUSH
// if not base_units then
86985: LD_VAR 0 1
86989: NOT
86990: IFFALSE 86994
// exit ;
86992: GO 87081
// result := false ;
86994: LD_ADDR_VAR 0 2
86998: PUSH
86999: LD_INT 0
87001: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87002: LD_ADDR_VAR 0 5
87006: PUSH
87007: LD_VAR 0 1
87011: PPUSH
87012: LD_INT 21
87014: PUSH
87015: LD_INT 3
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PPUSH
87022: CALL_OW 72
87026: ST_TO_ADDR
// if not tmp then
87027: LD_VAR 0 5
87031: NOT
87032: IFFALSE 87036
// exit ;
87034: GO 87081
// for i in tmp do
87036: LD_ADDR_VAR 0 3
87040: PUSH
87041: LD_VAR 0 5
87045: PUSH
87046: FOR_IN
87047: IFFALSE 87079
// begin result := EnemyInRange ( i , 22 ) ;
87049: LD_ADDR_VAR 0 2
87053: PUSH
87054: LD_VAR 0 3
87058: PPUSH
87059: LD_INT 22
87061: PPUSH
87062: CALL 84668 0 2
87066: ST_TO_ADDR
// if result then
87067: LD_VAR 0 2
87071: IFFALSE 87077
// exit ;
87073: POP
87074: POP
87075: GO 87081
// end ;
87077: GO 87046
87079: POP
87080: POP
// end ;
87081: LD_VAR 0 2
87085: RET
// export function FilterByTag ( units , tag ) ; begin
87086: LD_INT 0
87088: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
87089: LD_ADDR_VAR 0 3
87093: PUSH
87094: LD_VAR 0 1
87098: PPUSH
87099: LD_INT 120
87101: PUSH
87102: LD_VAR 0 2
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: PPUSH
87111: CALL_OW 72
87115: ST_TO_ADDR
// end ;
87116: LD_VAR 0 3
87120: RET
// export function IsDriver ( un ) ; begin
87121: LD_INT 0
87123: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87124: LD_ADDR_VAR 0 2
87128: PUSH
87129: LD_VAR 0 1
87133: PUSH
87134: LD_INT 55
87136: PUSH
87137: EMPTY
87138: LIST
87139: PPUSH
87140: CALL_OW 69
87144: IN
87145: ST_TO_ADDR
// end ;
87146: LD_VAR 0 2
87150: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87151: LD_INT 0
87153: PPUSH
87154: PPUSH
// list := [ ] ;
87155: LD_ADDR_VAR 0 5
87159: PUSH
87160: EMPTY
87161: ST_TO_ADDR
// case d of 0 :
87162: LD_VAR 0 3
87166: PUSH
87167: LD_INT 0
87169: DOUBLE
87170: EQUAL
87171: IFTRUE 87175
87173: GO 87308
87175: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87176: LD_ADDR_VAR 0 5
87180: PUSH
87181: LD_VAR 0 1
87185: PUSH
87186: LD_INT 4
87188: MINUS
87189: PUSH
87190: LD_VAR 0 2
87194: PUSH
87195: LD_INT 4
87197: MINUS
87198: PUSH
87199: LD_INT 2
87201: PUSH
87202: EMPTY
87203: LIST
87204: LIST
87205: LIST
87206: PUSH
87207: LD_VAR 0 1
87211: PUSH
87212: LD_INT 3
87214: MINUS
87215: PUSH
87216: LD_VAR 0 2
87220: PUSH
87221: LD_INT 1
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: LIST
87228: PUSH
87229: LD_VAR 0 1
87233: PUSH
87234: LD_INT 4
87236: PLUS
87237: PUSH
87238: LD_VAR 0 2
87242: PUSH
87243: LD_INT 4
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: LIST
87250: PUSH
87251: LD_VAR 0 1
87255: PUSH
87256: LD_INT 3
87258: PLUS
87259: PUSH
87260: LD_VAR 0 2
87264: PUSH
87265: LD_INT 3
87267: PLUS
87268: PUSH
87269: LD_INT 5
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: LIST
87276: PUSH
87277: LD_VAR 0 1
87281: PUSH
87282: LD_VAR 0 2
87286: PUSH
87287: LD_INT 4
87289: PLUS
87290: PUSH
87291: LD_INT 0
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: LIST
87298: PUSH
87299: EMPTY
87300: LIST
87301: LIST
87302: LIST
87303: LIST
87304: LIST
87305: ST_TO_ADDR
// end ; 1 :
87306: GO 88006
87308: LD_INT 1
87310: DOUBLE
87311: EQUAL
87312: IFTRUE 87316
87314: GO 87449
87316: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87317: LD_ADDR_VAR 0 5
87321: PUSH
87322: LD_VAR 0 1
87326: PUSH
87327: LD_VAR 0 2
87331: PUSH
87332: LD_INT 4
87334: MINUS
87335: PUSH
87336: LD_INT 3
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: LIST
87343: PUSH
87344: LD_VAR 0 1
87348: PUSH
87349: LD_INT 3
87351: MINUS
87352: PUSH
87353: LD_VAR 0 2
87357: PUSH
87358: LD_INT 3
87360: MINUS
87361: PUSH
87362: LD_INT 2
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: LIST
87369: PUSH
87370: LD_VAR 0 1
87374: PUSH
87375: LD_INT 4
87377: MINUS
87378: PUSH
87379: LD_VAR 0 2
87383: PUSH
87384: LD_INT 1
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: LIST
87391: PUSH
87392: LD_VAR 0 1
87396: PUSH
87397: LD_VAR 0 2
87401: PUSH
87402: LD_INT 3
87404: PLUS
87405: PUSH
87406: LD_INT 0
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: LIST
87413: PUSH
87414: LD_VAR 0 1
87418: PUSH
87419: LD_INT 4
87421: PLUS
87422: PUSH
87423: LD_VAR 0 2
87427: PUSH
87428: LD_INT 4
87430: PLUS
87431: PUSH
87432: LD_INT 5
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: LIST
87439: PUSH
87440: EMPTY
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: ST_TO_ADDR
// end ; 2 :
87447: GO 88006
87449: LD_INT 2
87451: DOUBLE
87452: EQUAL
87453: IFTRUE 87457
87455: GO 87586
87457: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
87458: LD_ADDR_VAR 0 5
87462: PUSH
87463: LD_VAR 0 1
87467: PUSH
87468: LD_VAR 0 2
87472: PUSH
87473: LD_INT 3
87475: MINUS
87476: PUSH
87477: LD_INT 3
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: LIST
87484: PUSH
87485: LD_VAR 0 1
87489: PUSH
87490: LD_INT 4
87492: PLUS
87493: PUSH
87494: LD_VAR 0 2
87498: PUSH
87499: LD_INT 4
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: LIST
87506: PUSH
87507: LD_VAR 0 1
87511: PUSH
87512: LD_VAR 0 2
87516: PUSH
87517: LD_INT 4
87519: PLUS
87520: PUSH
87521: LD_INT 0
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: LIST
87528: PUSH
87529: LD_VAR 0 1
87533: PUSH
87534: LD_INT 3
87536: MINUS
87537: PUSH
87538: LD_VAR 0 2
87542: PUSH
87543: LD_INT 1
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: LIST
87550: PUSH
87551: LD_VAR 0 1
87555: PUSH
87556: LD_INT 4
87558: MINUS
87559: PUSH
87560: LD_VAR 0 2
87564: PUSH
87565: LD_INT 4
87567: MINUS
87568: PUSH
87569: LD_INT 2
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: LIST
87576: PUSH
87577: EMPTY
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: ST_TO_ADDR
// end ; 3 :
87584: GO 88006
87586: LD_INT 3
87588: DOUBLE
87589: EQUAL
87590: IFTRUE 87594
87592: GO 87727
87594: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
87595: LD_ADDR_VAR 0 5
87599: PUSH
87600: LD_VAR 0 1
87604: PUSH
87605: LD_INT 3
87607: PLUS
87608: PUSH
87609: LD_VAR 0 2
87613: PUSH
87614: LD_INT 4
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: LIST
87621: PUSH
87622: LD_VAR 0 1
87626: PUSH
87627: LD_INT 4
87629: PLUS
87630: PUSH
87631: LD_VAR 0 2
87635: PUSH
87636: LD_INT 4
87638: PLUS
87639: PUSH
87640: LD_INT 5
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: LIST
87647: PUSH
87648: LD_VAR 0 1
87652: PUSH
87653: LD_INT 4
87655: MINUS
87656: PUSH
87657: LD_VAR 0 2
87661: PUSH
87662: LD_INT 1
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: LIST
87669: PUSH
87670: LD_VAR 0 1
87674: PUSH
87675: LD_VAR 0 2
87679: PUSH
87680: LD_INT 4
87682: MINUS
87683: PUSH
87684: LD_INT 3
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: LIST
87691: PUSH
87692: LD_VAR 0 1
87696: PUSH
87697: LD_INT 3
87699: MINUS
87700: PUSH
87701: LD_VAR 0 2
87705: PUSH
87706: LD_INT 3
87708: MINUS
87709: PUSH
87710: LD_INT 2
87712: PUSH
87713: EMPTY
87714: LIST
87715: LIST
87716: LIST
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: ST_TO_ADDR
// end ; 4 :
87725: GO 88006
87727: LD_INT 4
87729: DOUBLE
87730: EQUAL
87731: IFTRUE 87735
87733: GO 87868
87735: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
87736: LD_ADDR_VAR 0 5
87740: PUSH
87741: LD_VAR 0 1
87745: PUSH
87746: LD_VAR 0 2
87750: PUSH
87751: LD_INT 4
87753: PLUS
87754: PUSH
87755: LD_INT 0
87757: PUSH
87758: EMPTY
87759: LIST
87760: LIST
87761: LIST
87762: PUSH
87763: LD_VAR 0 1
87767: PUSH
87768: LD_INT 3
87770: PLUS
87771: PUSH
87772: LD_VAR 0 2
87776: PUSH
87777: LD_INT 3
87779: PLUS
87780: PUSH
87781: LD_INT 5
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: LIST
87788: PUSH
87789: LD_VAR 0 1
87793: PUSH
87794: LD_INT 4
87796: PLUS
87797: PUSH
87798: LD_VAR 0 2
87802: PUSH
87803: LD_INT 4
87805: PUSH
87806: EMPTY
87807: LIST
87808: LIST
87809: LIST
87810: PUSH
87811: LD_VAR 0 1
87815: PUSH
87816: LD_VAR 0 2
87820: PUSH
87821: LD_INT 3
87823: MINUS
87824: PUSH
87825: LD_INT 3
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: LIST
87832: PUSH
87833: LD_VAR 0 1
87837: PUSH
87838: LD_INT 4
87840: MINUS
87841: PUSH
87842: LD_VAR 0 2
87846: PUSH
87847: LD_INT 4
87849: MINUS
87850: PUSH
87851: LD_INT 2
87853: PUSH
87854: EMPTY
87855: LIST
87856: LIST
87857: LIST
87858: PUSH
87859: EMPTY
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: ST_TO_ADDR
// end ; 5 :
87866: GO 88006
87868: LD_INT 5
87870: DOUBLE
87871: EQUAL
87872: IFTRUE 87876
87874: GO 88005
87876: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87877: LD_ADDR_VAR 0 5
87881: PUSH
87882: LD_VAR 0 1
87886: PUSH
87887: LD_INT 4
87889: MINUS
87890: PUSH
87891: LD_VAR 0 2
87895: PUSH
87896: LD_INT 1
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: LIST
87903: PUSH
87904: LD_VAR 0 1
87908: PUSH
87909: LD_VAR 0 2
87913: PUSH
87914: LD_INT 4
87916: MINUS
87917: PUSH
87918: LD_INT 3
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: LIST
87925: PUSH
87926: LD_VAR 0 1
87930: PUSH
87931: LD_INT 4
87933: PLUS
87934: PUSH
87935: LD_VAR 0 2
87939: PUSH
87940: LD_INT 4
87942: PLUS
87943: PUSH
87944: LD_INT 5
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: LIST
87951: PUSH
87952: LD_VAR 0 1
87956: PUSH
87957: LD_INT 3
87959: PLUS
87960: PUSH
87961: LD_VAR 0 2
87965: PUSH
87966: LD_INT 4
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: LIST
87973: PUSH
87974: LD_VAR 0 1
87978: PUSH
87979: LD_VAR 0 2
87983: PUSH
87984: LD_INT 3
87986: PLUS
87987: PUSH
87988: LD_INT 0
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: LIST
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: ST_TO_ADDR
// end ; end ;
88003: GO 88006
88005: POP
// result := list ;
88006: LD_ADDR_VAR 0 4
88010: PUSH
88011: LD_VAR 0 5
88015: ST_TO_ADDR
// end ;
88016: LD_VAR 0 4
88020: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88021: LD_INT 0
88023: PPUSH
88024: PPUSH
88025: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88026: LD_VAR 0 1
88030: NOT
88031: PUSH
88032: LD_VAR 0 2
88036: PUSH
88037: LD_INT 1
88039: PUSH
88040: LD_INT 2
88042: PUSH
88043: LD_INT 3
88045: PUSH
88046: LD_INT 4
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: IN
88055: NOT
88056: OR
88057: IFFALSE 88061
// exit ;
88059: GO 88144
// tmp := [ ] ;
88061: LD_ADDR_VAR 0 5
88065: PUSH
88066: EMPTY
88067: ST_TO_ADDR
// for i in units do
88068: LD_ADDR_VAR 0 4
88072: PUSH
88073: LD_VAR 0 1
88077: PUSH
88078: FOR_IN
88079: IFFALSE 88113
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
88081: LD_ADDR_VAR 0 5
88085: PUSH
88086: LD_VAR 0 5
88090: PPUSH
88091: LD_VAR 0 4
88095: PPUSH
88096: LD_VAR 0 2
88100: PPUSH
88101: CALL_OW 259
88105: PPUSH
88106: CALL 89504 0 2
88110: ST_TO_ADDR
88111: GO 88078
88113: POP
88114: POP
// if not tmp then
88115: LD_VAR 0 5
88119: NOT
88120: IFFALSE 88124
// exit ;
88122: GO 88144
// result := SortListByListDesc ( units , tmp ) ;
88124: LD_ADDR_VAR 0 3
88128: PUSH
88129: LD_VAR 0 1
88133: PPUSH
88134: LD_VAR 0 5
88138: PPUSH
88139: CALL_OW 77
88143: ST_TO_ADDR
// end ;
88144: LD_VAR 0 3
88148: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88149: LD_INT 0
88151: PPUSH
88152: PPUSH
88153: PPUSH
// result := false ;
88154: LD_ADDR_VAR 0 3
88158: PUSH
88159: LD_INT 0
88161: ST_TO_ADDR
// if not building then
88162: LD_VAR 0 2
88166: NOT
88167: IFFALSE 88171
// exit ;
88169: GO 88309
// x := GetX ( building ) ;
88171: LD_ADDR_VAR 0 4
88175: PUSH
88176: LD_VAR 0 2
88180: PPUSH
88181: CALL_OW 250
88185: ST_TO_ADDR
// y := GetY ( building ) ;
88186: LD_ADDR_VAR 0 5
88190: PUSH
88191: LD_VAR 0 2
88195: PPUSH
88196: CALL_OW 251
88200: ST_TO_ADDR
// if not x or not y then
88201: LD_VAR 0 4
88205: NOT
88206: PUSH
88207: LD_VAR 0 5
88211: NOT
88212: OR
88213: IFFALSE 88217
// exit ;
88215: GO 88309
// if GetTaskList ( unit ) then
88217: LD_VAR 0 1
88221: PPUSH
88222: CALL_OW 437
88226: IFFALSE 88309
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88228: LD_STRING e
88230: PUSH
88231: LD_VAR 0 1
88235: PPUSH
88236: CALL_OW 437
88240: PUSH
88241: LD_INT 1
88243: ARRAY
88244: PUSH
88245: LD_INT 1
88247: ARRAY
88248: EQUAL
88249: PUSH
88250: LD_VAR 0 4
88254: PUSH
88255: LD_VAR 0 1
88259: PPUSH
88260: CALL_OW 437
88264: PUSH
88265: LD_INT 1
88267: ARRAY
88268: PUSH
88269: LD_INT 2
88271: ARRAY
88272: EQUAL
88273: AND
88274: PUSH
88275: LD_VAR 0 5
88279: PUSH
88280: LD_VAR 0 1
88284: PPUSH
88285: CALL_OW 437
88289: PUSH
88290: LD_INT 1
88292: ARRAY
88293: PUSH
88294: LD_INT 3
88296: ARRAY
88297: EQUAL
88298: AND
88299: IFFALSE 88309
// result := true end ;
88301: LD_ADDR_VAR 0 3
88305: PUSH
88306: LD_INT 1
88308: ST_TO_ADDR
// end ;
88309: LD_VAR 0 3
88313: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
88314: LD_INT 0
88316: PPUSH
// result := false ;
88317: LD_ADDR_VAR 0 4
88321: PUSH
88322: LD_INT 0
88324: ST_TO_ADDR
// if GetTaskList ( unit ) then
88325: LD_VAR 0 1
88329: PPUSH
88330: CALL_OW 437
88334: IFFALSE 88417
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88336: LD_STRING M
88338: PUSH
88339: LD_VAR 0 1
88343: PPUSH
88344: CALL_OW 437
88348: PUSH
88349: LD_INT 1
88351: ARRAY
88352: PUSH
88353: LD_INT 1
88355: ARRAY
88356: EQUAL
88357: PUSH
88358: LD_VAR 0 2
88362: PUSH
88363: LD_VAR 0 1
88367: PPUSH
88368: CALL_OW 437
88372: PUSH
88373: LD_INT 1
88375: ARRAY
88376: PUSH
88377: LD_INT 2
88379: ARRAY
88380: EQUAL
88381: AND
88382: PUSH
88383: LD_VAR 0 3
88387: PUSH
88388: LD_VAR 0 1
88392: PPUSH
88393: CALL_OW 437
88397: PUSH
88398: LD_INT 1
88400: ARRAY
88401: PUSH
88402: LD_INT 3
88404: ARRAY
88405: EQUAL
88406: AND
88407: IFFALSE 88417
// result := true ;
88409: LD_ADDR_VAR 0 4
88413: PUSH
88414: LD_INT 1
88416: ST_TO_ADDR
// end ; end ;
88417: LD_VAR 0 4
88421: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
88422: LD_INT 0
88424: PPUSH
88425: PPUSH
88426: PPUSH
88427: PPUSH
// if not unit or not area then
88428: LD_VAR 0 1
88432: NOT
88433: PUSH
88434: LD_VAR 0 2
88438: NOT
88439: OR
88440: IFFALSE 88444
// exit ;
88442: GO 88607
// tmp := AreaToList ( area , i ) ;
88444: LD_ADDR_VAR 0 6
88448: PUSH
88449: LD_VAR 0 2
88453: PPUSH
88454: LD_VAR 0 5
88458: PPUSH
88459: CALL_OW 517
88463: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
88464: LD_ADDR_VAR 0 5
88468: PUSH
88469: DOUBLE
88470: LD_INT 1
88472: DEC
88473: ST_TO_ADDR
88474: LD_VAR 0 6
88478: PUSH
88479: LD_INT 1
88481: ARRAY
88482: PUSH
88483: FOR_TO
88484: IFFALSE 88605
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
88486: LD_ADDR_VAR 0 7
88490: PUSH
88491: LD_VAR 0 6
88495: PUSH
88496: LD_INT 1
88498: ARRAY
88499: PUSH
88500: LD_VAR 0 5
88504: ARRAY
88505: PUSH
88506: LD_VAR 0 6
88510: PUSH
88511: LD_INT 2
88513: ARRAY
88514: PUSH
88515: LD_VAR 0 5
88519: ARRAY
88520: PUSH
88521: EMPTY
88522: LIST
88523: LIST
88524: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
88525: LD_INT 92
88527: PUSH
88528: LD_VAR 0 7
88532: PUSH
88533: LD_INT 1
88535: ARRAY
88536: PUSH
88537: LD_VAR 0 7
88541: PUSH
88542: LD_INT 2
88544: ARRAY
88545: PUSH
88546: LD_INT 3
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: PPUSH
88555: CALL_OW 69
88559: PUSH
88560: LD_INT 0
88562: EQUAL
88563: IFFALSE 88603
// begin PlaceUnitArea ( unit , area , mode ) ;
88565: LD_VAR 0 1
88569: PPUSH
88570: LD_VAR 0 2
88574: PPUSH
88575: LD_VAR 0 3
88579: PPUSH
88580: CALL_OW 49
// result := IsPlaced ( unit ) ;
88584: LD_ADDR_VAR 0 4
88588: PUSH
88589: LD_VAR 0 1
88593: PPUSH
88594: CALL_OW 305
88598: ST_TO_ADDR
// exit ;
88599: POP
88600: POP
88601: GO 88607
// end ; end ;
88603: GO 88483
88605: POP
88606: POP
// end ;
88607: LD_VAR 0 4
88611: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
88612: LD_INT 0
88614: PPUSH
88615: PPUSH
88616: PPUSH
// if not side or side > 8 then
88617: LD_VAR 0 1
88621: NOT
88622: PUSH
88623: LD_VAR 0 1
88627: PUSH
88628: LD_INT 8
88630: GREATER
88631: OR
88632: IFFALSE 88636
// exit ;
88634: GO 88823
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
88636: LD_ADDR_VAR 0 4
88640: PUSH
88641: LD_INT 22
88643: PUSH
88644: LD_VAR 0 1
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: PUSH
88653: LD_INT 21
88655: PUSH
88656: LD_INT 3
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: PPUSH
88667: CALL_OW 69
88671: ST_TO_ADDR
// if not tmp then
88672: LD_VAR 0 4
88676: NOT
88677: IFFALSE 88681
// exit ;
88679: GO 88823
// enable_addtolog := true ;
88681: LD_ADDR_OWVAR 81
88685: PUSH
88686: LD_INT 1
88688: ST_TO_ADDR
// AddToLog ( [ ) ;
88689: LD_STRING [
88691: PPUSH
88692: CALL_OW 561
// for i in tmp do
88696: LD_ADDR_VAR 0 3
88700: PUSH
88701: LD_VAR 0 4
88705: PUSH
88706: FOR_IN
88707: IFFALSE 88814
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
88709: LD_STRING [
88711: PUSH
88712: LD_VAR 0 3
88716: PPUSH
88717: CALL_OW 266
88721: STR
88722: PUSH
88723: LD_STRING , 
88725: STR
88726: PUSH
88727: LD_VAR 0 3
88731: PPUSH
88732: CALL_OW 250
88736: STR
88737: PUSH
88738: LD_STRING , 
88740: STR
88741: PUSH
88742: LD_VAR 0 3
88746: PPUSH
88747: CALL_OW 251
88751: STR
88752: PUSH
88753: LD_STRING , 
88755: STR
88756: PUSH
88757: LD_VAR 0 3
88761: PPUSH
88762: CALL_OW 254
88766: STR
88767: PUSH
88768: LD_STRING , 
88770: STR
88771: PUSH
88772: LD_VAR 0 3
88776: PPUSH
88777: LD_INT 1
88779: PPUSH
88780: CALL_OW 268
88784: STR
88785: PUSH
88786: LD_STRING , 
88788: STR
88789: PUSH
88790: LD_VAR 0 3
88794: PPUSH
88795: LD_INT 2
88797: PPUSH
88798: CALL_OW 268
88802: STR
88803: PUSH
88804: LD_STRING ],
88806: STR
88807: PPUSH
88808: CALL_OW 561
// end ;
88812: GO 88706
88814: POP
88815: POP
// AddToLog ( ]; ) ;
88816: LD_STRING ];
88818: PPUSH
88819: CALL_OW 561
// end ;
88823: LD_VAR 0 2
88827: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88828: LD_INT 0
88830: PPUSH
88831: PPUSH
88832: PPUSH
88833: PPUSH
88834: PPUSH
// if not area or not rate or not max then
88835: LD_VAR 0 1
88839: NOT
88840: PUSH
88841: LD_VAR 0 2
88845: NOT
88846: OR
88847: PUSH
88848: LD_VAR 0 4
88852: NOT
88853: OR
88854: IFFALSE 88858
// exit ;
88856: GO 89047
// while 1 do
88858: LD_INT 1
88860: IFFALSE 89047
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88862: LD_ADDR_VAR 0 9
88866: PUSH
88867: LD_VAR 0 1
88871: PPUSH
88872: LD_INT 1
88874: PPUSH
88875: CALL_OW 287
88879: PUSH
88880: LD_INT 10
88882: MUL
88883: ST_TO_ADDR
// r := rate / 10 ;
88884: LD_ADDR_VAR 0 7
88888: PUSH
88889: LD_VAR 0 2
88893: PUSH
88894: LD_INT 10
88896: DIVREAL
88897: ST_TO_ADDR
// time := 1 1$00 ;
88898: LD_ADDR_VAR 0 8
88902: PUSH
88903: LD_INT 2100
88905: ST_TO_ADDR
// if amount < min then
88906: LD_VAR 0 9
88910: PUSH
88911: LD_VAR 0 3
88915: LESS
88916: IFFALSE 88934
// r := r * 2 else
88918: LD_ADDR_VAR 0 7
88922: PUSH
88923: LD_VAR 0 7
88927: PUSH
88928: LD_INT 2
88930: MUL
88931: ST_TO_ADDR
88932: GO 88960
// if amount > max then
88934: LD_VAR 0 9
88938: PUSH
88939: LD_VAR 0 4
88943: GREATER
88944: IFFALSE 88960
// r := r / 2 ;
88946: LD_ADDR_VAR 0 7
88950: PUSH
88951: LD_VAR 0 7
88955: PUSH
88956: LD_INT 2
88958: DIVREAL
88959: ST_TO_ADDR
// time := time / r ;
88960: LD_ADDR_VAR 0 8
88964: PUSH
88965: LD_VAR 0 8
88969: PUSH
88970: LD_VAR 0 7
88974: DIVREAL
88975: ST_TO_ADDR
// if time < 0 then
88976: LD_VAR 0 8
88980: PUSH
88981: LD_INT 0
88983: LESS
88984: IFFALSE 89001
// time := time * - 1 ;
88986: LD_ADDR_VAR 0 8
88990: PUSH
88991: LD_VAR 0 8
88995: PUSH
88996: LD_INT 1
88998: NEG
88999: MUL
89000: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
89001: LD_VAR 0 8
89005: PUSH
89006: LD_INT 35
89008: PPUSH
89009: LD_INT 875
89011: PPUSH
89012: CALL_OW 12
89016: PLUS
89017: PPUSH
89018: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89022: LD_INT 1
89024: PPUSH
89025: LD_INT 5
89027: PPUSH
89028: CALL_OW 12
89032: PPUSH
89033: LD_VAR 0 1
89037: PPUSH
89038: LD_INT 1
89040: PPUSH
89041: CALL_OW 55
// end ;
89045: GO 88858
// end ;
89047: LD_VAR 0 5
89051: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89052: LD_INT 0
89054: PPUSH
89055: PPUSH
89056: PPUSH
89057: PPUSH
89058: PPUSH
89059: PPUSH
89060: PPUSH
89061: PPUSH
// if not turrets or not factories then
89062: LD_VAR 0 1
89066: NOT
89067: PUSH
89068: LD_VAR 0 2
89072: NOT
89073: OR
89074: IFFALSE 89078
// exit ;
89076: GO 89385
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89078: LD_ADDR_VAR 0 10
89082: PUSH
89083: LD_INT 5
89085: PUSH
89086: LD_INT 6
89088: PUSH
89089: EMPTY
89090: LIST
89091: LIST
89092: PUSH
89093: LD_INT 2
89095: PUSH
89096: LD_INT 4
89098: PUSH
89099: EMPTY
89100: LIST
89101: LIST
89102: PUSH
89103: LD_INT 3
89105: PUSH
89106: LD_INT 5
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: LIST
89117: PUSH
89118: LD_INT 24
89120: PUSH
89121: LD_INT 25
89123: PUSH
89124: EMPTY
89125: LIST
89126: LIST
89127: PUSH
89128: LD_INT 23
89130: PUSH
89131: LD_INT 27
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PUSH
89142: LD_INT 42
89144: PUSH
89145: LD_INT 43
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 44
89154: PUSH
89155: LD_INT 46
89157: PUSH
89158: EMPTY
89159: LIST
89160: LIST
89161: PUSH
89162: LD_INT 45
89164: PUSH
89165: LD_INT 47
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: LIST
89176: PUSH
89177: EMPTY
89178: LIST
89179: LIST
89180: LIST
89181: ST_TO_ADDR
// result := [ ] ;
89182: LD_ADDR_VAR 0 3
89186: PUSH
89187: EMPTY
89188: ST_TO_ADDR
// for i in turrets do
89189: LD_ADDR_VAR 0 4
89193: PUSH
89194: LD_VAR 0 1
89198: PUSH
89199: FOR_IN
89200: IFFALSE 89383
// begin nat := GetNation ( i ) ;
89202: LD_ADDR_VAR 0 7
89206: PUSH
89207: LD_VAR 0 4
89211: PPUSH
89212: CALL_OW 248
89216: ST_TO_ADDR
// weapon := 0 ;
89217: LD_ADDR_VAR 0 8
89221: PUSH
89222: LD_INT 0
89224: ST_TO_ADDR
// if not nat then
89225: LD_VAR 0 7
89229: NOT
89230: IFFALSE 89234
// continue ;
89232: GO 89199
// for j in list [ nat ] do
89234: LD_ADDR_VAR 0 5
89238: PUSH
89239: LD_VAR 0 10
89243: PUSH
89244: LD_VAR 0 7
89248: ARRAY
89249: PUSH
89250: FOR_IN
89251: IFFALSE 89292
// if GetBWeapon ( i ) = j [ 1 ] then
89253: LD_VAR 0 4
89257: PPUSH
89258: CALL_OW 269
89262: PUSH
89263: LD_VAR 0 5
89267: PUSH
89268: LD_INT 1
89270: ARRAY
89271: EQUAL
89272: IFFALSE 89290
// begin weapon := j [ 2 ] ;
89274: LD_ADDR_VAR 0 8
89278: PUSH
89279: LD_VAR 0 5
89283: PUSH
89284: LD_INT 2
89286: ARRAY
89287: ST_TO_ADDR
// break ;
89288: GO 89292
// end ;
89290: GO 89250
89292: POP
89293: POP
// if not weapon then
89294: LD_VAR 0 8
89298: NOT
89299: IFFALSE 89303
// continue ;
89301: GO 89199
// for k in factories do
89303: LD_ADDR_VAR 0 6
89307: PUSH
89308: LD_VAR 0 2
89312: PUSH
89313: FOR_IN
89314: IFFALSE 89379
// begin weapons := AvailableWeaponList ( k ) ;
89316: LD_ADDR_VAR 0 9
89320: PUSH
89321: LD_VAR 0 6
89325: PPUSH
89326: CALL_OW 478
89330: ST_TO_ADDR
// if not weapons then
89331: LD_VAR 0 9
89335: NOT
89336: IFFALSE 89340
// continue ;
89338: GO 89313
// if weapon in weapons then
89340: LD_VAR 0 8
89344: PUSH
89345: LD_VAR 0 9
89349: IN
89350: IFFALSE 89377
// begin result := [ i , weapon ] ;
89352: LD_ADDR_VAR 0 3
89356: PUSH
89357: LD_VAR 0 4
89361: PUSH
89362: LD_VAR 0 8
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: ST_TO_ADDR
// exit ;
89371: POP
89372: POP
89373: POP
89374: POP
89375: GO 89385
// end ; end ;
89377: GO 89313
89379: POP
89380: POP
// end ;
89381: GO 89199
89383: POP
89384: POP
// end ;
89385: LD_VAR 0 3
89389: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
89390: LD_INT 0
89392: PPUSH
// if not side or side > 8 then
89393: LD_VAR 0 3
89397: NOT
89398: PUSH
89399: LD_VAR 0 3
89403: PUSH
89404: LD_INT 8
89406: GREATER
89407: OR
89408: IFFALSE 89412
// exit ;
89410: GO 89471
// if not range then
89412: LD_VAR 0 4
89416: NOT
89417: IFFALSE 89428
// range := - 12 ;
89419: LD_ADDR_VAR 0 4
89423: PUSH
89424: LD_INT 12
89426: NEG
89427: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
89428: LD_VAR 0 1
89432: PPUSH
89433: LD_VAR 0 2
89437: PPUSH
89438: LD_VAR 0 3
89442: PPUSH
89443: LD_VAR 0 4
89447: PPUSH
89448: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
89452: LD_VAR 0 1
89456: PPUSH
89457: LD_VAR 0 2
89461: PPUSH
89462: LD_VAR 0 3
89466: PPUSH
89467: CALL_OW 331
// end ;
89471: LD_VAR 0 5
89475: RET
// export function Video ( mode ) ; begin
89476: LD_INT 0
89478: PPUSH
// ingame_video = mode ;
89479: LD_ADDR_OWVAR 52
89483: PUSH
89484: LD_VAR 0 1
89488: ST_TO_ADDR
// interface_hidden = mode ;
89489: LD_ADDR_OWVAR 54
89493: PUSH
89494: LD_VAR 0 1
89498: ST_TO_ADDR
// end ;
89499: LD_VAR 0 2
89503: RET
// export function Join ( array , element ) ; begin
89504: LD_INT 0
89506: PPUSH
// result := Replace ( array , array + 1 , element ) ;
89507: LD_ADDR_VAR 0 3
89511: PUSH
89512: LD_VAR 0 1
89516: PPUSH
89517: LD_VAR 0 1
89521: PUSH
89522: LD_INT 1
89524: PLUS
89525: PPUSH
89526: LD_VAR 0 2
89530: PPUSH
89531: CALL_OW 1
89535: ST_TO_ADDR
// end ;
89536: LD_VAR 0 3
89540: RET
// export function JoinUnion ( array , element ) ; begin
89541: LD_INT 0
89543: PPUSH
// result := array union element ;
89544: LD_ADDR_VAR 0 3
89548: PUSH
89549: LD_VAR 0 1
89553: PUSH
89554: LD_VAR 0 2
89558: UNION
89559: ST_TO_ADDR
// end ;
89560: LD_VAR 0 3
89564: RET
// export function GetBehemoths ( side ) ; begin
89565: LD_INT 0
89567: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
89568: LD_ADDR_VAR 0 2
89572: PUSH
89573: LD_INT 22
89575: PUSH
89576: LD_VAR 0 1
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: PUSH
89585: LD_INT 31
89587: PUSH
89588: LD_INT 25
89590: PUSH
89591: EMPTY
89592: LIST
89593: LIST
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PPUSH
89599: CALL_OW 69
89603: ST_TO_ADDR
// end ;
89604: LD_VAR 0 2
89608: RET
// export function Shuffle ( array ) ; var i , index ; begin
89609: LD_INT 0
89611: PPUSH
89612: PPUSH
89613: PPUSH
// result := [ ] ;
89614: LD_ADDR_VAR 0 2
89618: PUSH
89619: EMPTY
89620: ST_TO_ADDR
// if not array then
89621: LD_VAR 0 1
89625: NOT
89626: IFFALSE 89630
// exit ;
89628: GO 89729
// Randomize ;
89630: CALL_OW 10
// for i = array downto 1 do
89634: LD_ADDR_VAR 0 3
89638: PUSH
89639: DOUBLE
89640: LD_VAR 0 1
89644: INC
89645: ST_TO_ADDR
89646: LD_INT 1
89648: PUSH
89649: FOR_DOWNTO
89650: IFFALSE 89727
// begin index := rand ( 1 , array ) ;
89652: LD_ADDR_VAR 0 4
89656: PUSH
89657: LD_INT 1
89659: PPUSH
89660: LD_VAR 0 1
89664: PPUSH
89665: CALL_OW 12
89669: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
89670: LD_ADDR_VAR 0 2
89674: PUSH
89675: LD_VAR 0 2
89679: PPUSH
89680: LD_VAR 0 2
89684: PUSH
89685: LD_INT 1
89687: PLUS
89688: PPUSH
89689: LD_VAR 0 1
89693: PUSH
89694: LD_VAR 0 4
89698: ARRAY
89699: PPUSH
89700: CALL_OW 2
89704: ST_TO_ADDR
// array := Delete ( array , index ) ;
89705: LD_ADDR_VAR 0 1
89709: PUSH
89710: LD_VAR 0 1
89714: PPUSH
89715: LD_VAR 0 4
89719: PPUSH
89720: CALL_OW 3
89724: ST_TO_ADDR
// end ;
89725: GO 89649
89727: POP
89728: POP
// end ;
89729: LD_VAR 0 2
89733: RET
// export function GetBaseMaterials ( base ) ; begin
89734: LD_INT 0
89736: PPUSH
// result := [ 0 , 0 , 0 ] ;
89737: LD_ADDR_VAR 0 2
89741: PUSH
89742: LD_INT 0
89744: PUSH
89745: LD_INT 0
89747: PUSH
89748: LD_INT 0
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: LIST
89755: ST_TO_ADDR
// if not base then
89756: LD_VAR 0 1
89760: NOT
89761: IFFALSE 89765
// exit ;
89763: GO 89814
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89765: LD_ADDR_VAR 0 2
89769: PUSH
89770: LD_VAR 0 1
89774: PPUSH
89775: LD_INT 1
89777: PPUSH
89778: CALL_OW 275
89782: PUSH
89783: LD_VAR 0 1
89787: PPUSH
89788: LD_INT 2
89790: PPUSH
89791: CALL_OW 275
89795: PUSH
89796: LD_VAR 0 1
89800: PPUSH
89801: LD_INT 3
89803: PPUSH
89804: CALL_OW 275
89808: PUSH
89809: EMPTY
89810: LIST
89811: LIST
89812: LIST
89813: ST_TO_ADDR
// end ;
89814: LD_VAR 0 2
89818: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89819: LD_INT 0
89821: PPUSH
89822: PPUSH
// result := array ;
89823: LD_ADDR_VAR 0 3
89827: PUSH
89828: LD_VAR 0 1
89832: ST_TO_ADDR
// if size >= result then
89833: LD_VAR 0 2
89837: PUSH
89838: LD_VAR 0 3
89842: GREATEREQUAL
89843: IFFALSE 89847
// exit ;
89845: GO 89897
// if size then
89847: LD_VAR 0 2
89851: IFFALSE 89897
// for i := array downto size do
89853: LD_ADDR_VAR 0 4
89857: PUSH
89858: DOUBLE
89859: LD_VAR 0 1
89863: INC
89864: ST_TO_ADDR
89865: LD_VAR 0 2
89869: PUSH
89870: FOR_DOWNTO
89871: IFFALSE 89895
// result := Delete ( result , result ) ;
89873: LD_ADDR_VAR 0 3
89877: PUSH
89878: LD_VAR 0 3
89882: PPUSH
89883: LD_VAR 0 3
89887: PPUSH
89888: CALL_OW 3
89892: ST_TO_ADDR
89893: GO 89870
89895: POP
89896: POP
// end ;
89897: LD_VAR 0 3
89901: RET
// export function ComExit ( unit ) ; var tmp ; begin
89902: LD_INT 0
89904: PPUSH
89905: PPUSH
// if not IsInUnit ( unit ) then
89906: LD_VAR 0 1
89910: PPUSH
89911: CALL_OW 310
89915: NOT
89916: IFFALSE 89920
// exit ;
89918: GO 89980
// tmp := IsInUnit ( unit ) ;
89920: LD_ADDR_VAR 0 3
89924: PUSH
89925: LD_VAR 0 1
89929: PPUSH
89930: CALL_OW 310
89934: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89935: LD_VAR 0 3
89939: PPUSH
89940: CALL_OW 247
89944: PUSH
89945: LD_INT 2
89947: EQUAL
89948: IFFALSE 89961
// ComExitVehicle ( unit ) else
89950: LD_VAR 0 1
89954: PPUSH
89955: CALL_OW 121
89959: GO 89970
// ComExitBuilding ( unit ) ;
89961: LD_VAR 0 1
89965: PPUSH
89966: CALL_OW 122
// result := tmp ;
89970: LD_ADDR_VAR 0 2
89974: PUSH
89975: LD_VAR 0 3
89979: ST_TO_ADDR
// end ;
89980: LD_VAR 0 2
89984: RET
// export function ComExitAll ( units ) ; var i ; begin
89985: LD_INT 0
89987: PPUSH
89988: PPUSH
// if not units then
89989: LD_VAR 0 1
89993: NOT
89994: IFFALSE 89998
// exit ;
89996: GO 90024
// for i in units do
89998: LD_ADDR_VAR 0 3
90002: PUSH
90003: LD_VAR 0 1
90007: PUSH
90008: FOR_IN
90009: IFFALSE 90022
// ComExit ( i ) ;
90011: LD_VAR 0 3
90015: PPUSH
90016: CALL 89902 0 1
90020: GO 90008
90022: POP
90023: POP
// end ;
90024: LD_VAR 0 2
90028: RET
// export function ResetHc ; begin
90029: LD_INT 0
90031: PPUSH
// InitHc ;
90032: CALL_OW 19
// hc_importance := 0 ;
90036: LD_ADDR_OWVAR 32
90040: PUSH
90041: LD_INT 0
90043: ST_TO_ADDR
// end ;
90044: LD_VAR 0 1
90048: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
90049: LD_INT 0
90051: PPUSH
90052: PPUSH
90053: PPUSH
// _x := ( x1 + x2 ) div 2 ;
90054: LD_ADDR_VAR 0 6
90058: PUSH
90059: LD_VAR 0 1
90063: PUSH
90064: LD_VAR 0 3
90068: PLUS
90069: PUSH
90070: LD_INT 2
90072: DIV
90073: ST_TO_ADDR
// if _x < 0 then
90074: LD_VAR 0 6
90078: PUSH
90079: LD_INT 0
90081: LESS
90082: IFFALSE 90099
// _x := _x * - 1 ;
90084: LD_ADDR_VAR 0 6
90088: PUSH
90089: LD_VAR 0 6
90093: PUSH
90094: LD_INT 1
90096: NEG
90097: MUL
90098: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
90099: LD_ADDR_VAR 0 7
90103: PUSH
90104: LD_VAR 0 2
90108: PUSH
90109: LD_VAR 0 4
90113: PLUS
90114: PUSH
90115: LD_INT 2
90117: DIV
90118: ST_TO_ADDR
// if _y < 0 then
90119: LD_VAR 0 7
90123: PUSH
90124: LD_INT 0
90126: LESS
90127: IFFALSE 90144
// _y := _y * - 1 ;
90129: LD_ADDR_VAR 0 7
90133: PUSH
90134: LD_VAR 0 7
90138: PUSH
90139: LD_INT 1
90141: NEG
90142: MUL
90143: ST_TO_ADDR
// result := [ _x , _y ] ;
90144: LD_ADDR_VAR 0 5
90148: PUSH
90149: LD_VAR 0 6
90153: PUSH
90154: LD_VAR 0 7
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: ST_TO_ADDR
// end ;
90163: LD_VAR 0 5
90167: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
90168: LD_INT 0
90170: PPUSH
90171: PPUSH
90172: PPUSH
90173: PPUSH
// task := GetTaskList ( unit ) ;
90174: LD_ADDR_VAR 0 7
90178: PUSH
90179: LD_VAR 0 1
90183: PPUSH
90184: CALL_OW 437
90188: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
90189: LD_VAR 0 7
90193: NOT
90194: PUSH
90195: LD_VAR 0 1
90199: PPUSH
90200: LD_VAR 0 2
90204: PPUSH
90205: CALL_OW 308
90209: NOT
90210: AND
90211: IFFALSE 90215
// exit ;
90213: GO 90333
// if IsInArea ( unit , area ) then
90215: LD_VAR 0 1
90219: PPUSH
90220: LD_VAR 0 2
90224: PPUSH
90225: CALL_OW 308
90229: IFFALSE 90247
// begin ComMoveToArea ( unit , goAway ) ;
90231: LD_VAR 0 1
90235: PPUSH
90236: LD_VAR 0 3
90240: PPUSH
90241: CALL_OW 113
// exit ;
90245: GO 90333
// end ; if task [ 1 ] [ 1 ] <> M then
90247: LD_VAR 0 7
90251: PUSH
90252: LD_INT 1
90254: ARRAY
90255: PUSH
90256: LD_INT 1
90258: ARRAY
90259: PUSH
90260: LD_STRING M
90262: NONEQUAL
90263: IFFALSE 90267
// exit ;
90265: GO 90333
// x := task [ 1 ] [ 2 ] ;
90267: LD_ADDR_VAR 0 5
90271: PUSH
90272: LD_VAR 0 7
90276: PUSH
90277: LD_INT 1
90279: ARRAY
90280: PUSH
90281: LD_INT 2
90283: ARRAY
90284: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
90285: LD_ADDR_VAR 0 6
90289: PUSH
90290: LD_VAR 0 7
90294: PUSH
90295: LD_INT 1
90297: ARRAY
90298: PUSH
90299: LD_INT 3
90301: ARRAY
90302: ST_TO_ADDR
// if InArea ( x , y , area ) then
90303: LD_VAR 0 5
90307: PPUSH
90308: LD_VAR 0 6
90312: PPUSH
90313: LD_VAR 0 2
90317: PPUSH
90318: CALL_OW 309
90322: IFFALSE 90333
// ComStop ( unit ) ;
90324: LD_VAR 0 1
90328: PPUSH
90329: CALL_OW 141
// end ;
90333: LD_VAR 0 4
90337: RET
// export function Abs ( value ) ; begin
90338: LD_INT 0
90340: PPUSH
// result := value ;
90341: LD_ADDR_VAR 0 2
90345: PUSH
90346: LD_VAR 0 1
90350: ST_TO_ADDR
// if value < 0 then
90351: LD_VAR 0 1
90355: PUSH
90356: LD_INT 0
90358: LESS
90359: IFFALSE 90376
// result := value * - 1 ;
90361: LD_ADDR_VAR 0 2
90365: PUSH
90366: LD_VAR 0 1
90370: PUSH
90371: LD_INT 1
90373: NEG
90374: MUL
90375: ST_TO_ADDR
// end ;
90376: LD_VAR 0 2
90380: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
90381: LD_INT 0
90383: PPUSH
90384: PPUSH
90385: PPUSH
90386: PPUSH
90387: PPUSH
90388: PPUSH
90389: PPUSH
90390: PPUSH
// if not unit or not building then
90391: LD_VAR 0 1
90395: NOT
90396: PUSH
90397: LD_VAR 0 2
90401: NOT
90402: OR
90403: IFFALSE 90407
// exit ;
90405: GO 90633
// x := GetX ( building ) ;
90407: LD_ADDR_VAR 0 4
90411: PUSH
90412: LD_VAR 0 2
90416: PPUSH
90417: CALL_OW 250
90421: ST_TO_ADDR
// y := GetY ( building ) ;
90422: LD_ADDR_VAR 0 6
90426: PUSH
90427: LD_VAR 0 2
90431: PPUSH
90432: CALL_OW 251
90436: ST_TO_ADDR
// d := GetDir ( building ) ;
90437: LD_ADDR_VAR 0 8
90441: PUSH
90442: LD_VAR 0 2
90446: PPUSH
90447: CALL_OW 254
90451: ST_TO_ADDR
// r := 4 ;
90452: LD_ADDR_VAR 0 9
90456: PUSH
90457: LD_INT 4
90459: ST_TO_ADDR
// for i := 1 to 5 do
90460: LD_ADDR_VAR 0 10
90464: PUSH
90465: DOUBLE
90466: LD_INT 1
90468: DEC
90469: ST_TO_ADDR
90470: LD_INT 5
90472: PUSH
90473: FOR_TO
90474: IFFALSE 90631
// begin _x := ShiftX ( x , d , r + i ) ;
90476: LD_ADDR_VAR 0 5
90480: PUSH
90481: LD_VAR 0 4
90485: PPUSH
90486: LD_VAR 0 8
90490: PPUSH
90491: LD_VAR 0 9
90495: PUSH
90496: LD_VAR 0 10
90500: PLUS
90501: PPUSH
90502: CALL_OW 272
90506: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
90507: LD_ADDR_VAR 0 7
90511: PUSH
90512: LD_VAR 0 6
90516: PPUSH
90517: LD_VAR 0 8
90521: PPUSH
90522: LD_VAR 0 9
90526: PUSH
90527: LD_VAR 0 10
90531: PLUS
90532: PPUSH
90533: CALL_OW 273
90537: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
90538: LD_VAR 0 5
90542: PPUSH
90543: LD_VAR 0 7
90547: PPUSH
90548: CALL_OW 488
90552: PUSH
90553: LD_VAR 0 5
90557: PPUSH
90558: LD_VAR 0 7
90562: PPUSH
90563: CALL_OW 428
90567: PPUSH
90568: CALL_OW 247
90572: PUSH
90573: LD_INT 3
90575: PUSH
90576: LD_INT 2
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: IN
90583: NOT
90584: AND
90585: IFFALSE 90629
// begin ComMoveXY ( unit , _x , _y ) ;
90587: LD_VAR 0 1
90591: PPUSH
90592: LD_VAR 0 5
90596: PPUSH
90597: LD_VAR 0 7
90601: PPUSH
90602: CALL_OW 111
// result := [ _x , _y ] ;
90606: LD_ADDR_VAR 0 3
90610: PUSH
90611: LD_VAR 0 5
90615: PUSH
90616: LD_VAR 0 7
90620: PUSH
90621: EMPTY
90622: LIST
90623: LIST
90624: ST_TO_ADDR
// exit ;
90625: POP
90626: POP
90627: GO 90633
// end ; end ;
90629: GO 90473
90631: POP
90632: POP
// end ;
90633: LD_VAR 0 3
90637: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
90638: LD_INT 0
90640: PPUSH
90641: PPUSH
90642: PPUSH
// result := 0 ;
90643: LD_ADDR_VAR 0 3
90647: PUSH
90648: LD_INT 0
90650: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
90651: LD_VAR 0 1
90655: PUSH
90656: LD_INT 0
90658: LESS
90659: PUSH
90660: LD_VAR 0 1
90664: PUSH
90665: LD_INT 8
90667: GREATER
90668: OR
90669: PUSH
90670: LD_VAR 0 2
90674: PUSH
90675: LD_INT 0
90677: LESS
90678: OR
90679: PUSH
90680: LD_VAR 0 2
90684: PUSH
90685: LD_INT 8
90687: GREATER
90688: OR
90689: IFFALSE 90693
// exit ;
90691: GO 90768
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
90693: LD_ADDR_VAR 0 4
90697: PUSH
90698: LD_INT 22
90700: PUSH
90701: LD_VAR 0 2
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: PPUSH
90710: CALL_OW 69
90714: PUSH
90715: FOR_IN
90716: IFFALSE 90766
// begin un := UnitShoot ( i ) ;
90718: LD_ADDR_VAR 0 5
90722: PUSH
90723: LD_VAR 0 4
90727: PPUSH
90728: CALL_OW 504
90732: ST_TO_ADDR
// if GetSide ( un ) = side1 then
90733: LD_VAR 0 5
90737: PPUSH
90738: CALL_OW 255
90742: PUSH
90743: LD_VAR 0 1
90747: EQUAL
90748: IFFALSE 90764
// begin result := un ;
90750: LD_ADDR_VAR 0 3
90754: PUSH
90755: LD_VAR 0 5
90759: ST_TO_ADDR
// exit ;
90760: POP
90761: POP
90762: GO 90768
// end ; end ;
90764: GO 90715
90766: POP
90767: POP
// end ;
90768: LD_VAR 0 3
90772: RET
// export function GetCargoBay ( units ) ; begin
90773: LD_INT 0
90775: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
90776: LD_ADDR_VAR 0 2
90780: PUSH
90781: LD_VAR 0 1
90785: PPUSH
90786: LD_INT 2
90788: PUSH
90789: LD_INT 34
90791: PUSH
90792: LD_INT 12
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: PUSH
90799: LD_INT 34
90801: PUSH
90802: LD_INT 51
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 34
90811: PUSH
90812: LD_INT 32
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: LD_INT 34
90821: PUSH
90822: LD_INT 89
90824: PUSH
90825: EMPTY
90826: LIST
90827: LIST
90828: PUSH
90829: EMPTY
90830: LIST
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: PPUSH
90836: CALL_OW 72
90840: ST_TO_ADDR
// end ;
90841: LD_VAR 0 2
90845: RET
// export function Negate ( value ) ; begin
90846: LD_INT 0
90848: PPUSH
// result := not value ;
90849: LD_ADDR_VAR 0 2
90853: PUSH
90854: LD_VAR 0 1
90858: NOT
90859: ST_TO_ADDR
// end ;
90860: LD_VAR 0 2
90864: RET
// export function Inc ( value ) ; begin
90865: LD_INT 0
90867: PPUSH
// result := value + 1 ;
90868: LD_ADDR_VAR 0 2
90872: PUSH
90873: LD_VAR 0 1
90877: PUSH
90878: LD_INT 1
90880: PLUS
90881: ST_TO_ADDR
// end ;
90882: LD_VAR 0 2
90886: RET
// export function Dec ( value ) ; begin
90887: LD_INT 0
90889: PPUSH
// result := value - 1 ;
90890: LD_ADDR_VAR 0 2
90894: PUSH
90895: LD_VAR 0 1
90899: PUSH
90900: LD_INT 1
90902: MINUS
90903: ST_TO_ADDR
// end ;
90904: LD_VAR 0 2
90908: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
90909: LD_INT 0
90911: PPUSH
90912: PPUSH
90913: PPUSH
90914: PPUSH
90915: PPUSH
90916: PPUSH
90917: PPUSH
90918: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
90919: LD_VAR 0 1
90923: PPUSH
90924: LD_VAR 0 2
90928: PPUSH
90929: CALL_OW 488
90933: NOT
90934: PUSH
90935: LD_VAR 0 3
90939: PPUSH
90940: LD_VAR 0 4
90944: PPUSH
90945: CALL_OW 488
90949: NOT
90950: OR
90951: IFFALSE 90964
// begin result := - 1 ;
90953: LD_ADDR_VAR 0 5
90957: PUSH
90958: LD_INT 1
90960: NEG
90961: ST_TO_ADDR
// exit ;
90962: GO 91199
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
90964: LD_ADDR_VAR 0 12
90968: PUSH
90969: LD_VAR 0 1
90973: PPUSH
90974: LD_VAR 0 2
90978: PPUSH
90979: LD_VAR 0 3
90983: PPUSH
90984: LD_VAR 0 4
90988: PPUSH
90989: CALL 90049 0 4
90993: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
90994: LD_ADDR_VAR 0 11
90998: PUSH
90999: LD_VAR 0 1
91003: PPUSH
91004: LD_VAR 0 2
91008: PPUSH
91009: LD_VAR 0 12
91013: PUSH
91014: LD_INT 1
91016: ARRAY
91017: PPUSH
91018: LD_VAR 0 12
91022: PUSH
91023: LD_INT 2
91025: ARRAY
91026: PPUSH
91027: CALL_OW 298
91031: ST_TO_ADDR
// distance := 9999 ;
91032: LD_ADDR_VAR 0 10
91036: PUSH
91037: LD_INT 9999
91039: ST_TO_ADDR
// for i := 0 to 5 do
91040: LD_ADDR_VAR 0 6
91044: PUSH
91045: DOUBLE
91046: LD_INT 0
91048: DEC
91049: ST_TO_ADDR
91050: LD_INT 5
91052: PUSH
91053: FOR_TO
91054: IFFALSE 91197
// begin _x := ShiftX ( x1 , i , centerDist ) ;
91056: LD_ADDR_VAR 0 7
91060: PUSH
91061: LD_VAR 0 1
91065: PPUSH
91066: LD_VAR 0 6
91070: PPUSH
91071: LD_VAR 0 11
91075: PPUSH
91076: CALL_OW 272
91080: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
91081: LD_ADDR_VAR 0 8
91085: PUSH
91086: LD_VAR 0 2
91090: PPUSH
91091: LD_VAR 0 6
91095: PPUSH
91096: LD_VAR 0 11
91100: PPUSH
91101: CALL_OW 273
91105: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91106: LD_VAR 0 7
91110: PPUSH
91111: LD_VAR 0 8
91115: PPUSH
91116: CALL_OW 488
91120: NOT
91121: IFFALSE 91125
// continue ;
91123: GO 91053
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
91125: LD_ADDR_VAR 0 9
91129: PUSH
91130: LD_VAR 0 12
91134: PUSH
91135: LD_INT 1
91137: ARRAY
91138: PPUSH
91139: LD_VAR 0 12
91143: PUSH
91144: LD_INT 2
91146: ARRAY
91147: PPUSH
91148: LD_VAR 0 7
91152: PPUSH
91153: LD_VAR 0 8
91157: PPUSH
91158: CALL_OW 298
91162: ST_TO_ADDR
// if tmp < distance then
91163: LD_VAR 0 9
91167: PUSH
91168: LD_VAR 0 10
91172: LESS
91173: IFFALSE 91195
// begin result := i ;
91175: LD_ADDR_VAR 0 5
91179: PUSH
91180: LD_VAR 0 6
91184: ST_TO_ADDR
// distance := tmp ;
91185: LD_ADDR_VAR 0 10
91189: PUSH
91190: LD_VAR 0 9
91194: ST_TO_ADDR
// end ; end ;
91195: GO 91053
91197: POP
91198: POP
// end ;
91199: LD_VAR 0 5
91203: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91204: LD_INT 0
91206: PPUSH
91207: PPUSH
// if not driver or not IsInUnit ( driver ) then
91208: LD_VAR 0 1
91212: NOT
91213: PUSH
91214: LD_VAR 0 1
91218: PPUSH
91219: CALL_OW 310
91223: NOT
91224: OR
91225: IFFALSE 91229
// exit ;
91227: GO 91319
// vehicle := IsInUnit ( driver ) ;
91229: LD_ADDR_VAR 0 3
91233: PUSH
91234: LD_VAR 0 1
91238: PPUSH
91239: CALL_OW 310
91243: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91244: LD_VAR 0 1
91248: PPUSH
91249: LD_STRING \
91251: PUSH
91252: LD_INT 0
91254: PUSH
91255: LD_INT 0
91257: PUSH
91258: LD_INT 0
91260: PUSH
91261: LD_INT 0
91263: PUSH
91264: LD_INT 0
91266: PUSH
91267: LD_INT 0
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: PUSH
91279: LD_STRING E
91281: PUSH
91282: LD_INT 0
91284: PUSH
91285: LD_INT 0
91287: PUSH
91288: LD_VAR 0 3
91292: PUSH
91293: LD_INT 0
91295: PUSH
91296: LD_INT 0
91298: PUSH
91299: LD_INT 0
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PPUSH
91315: CALL_OW 446
// end ;
91319: LD_VAR 0 2
91323: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91324: LD_INT 0
91326: PPUSH
91327: PPUSH
// if not driver or not IsInUnit ( driver ) then
91328: LD_VAR 0 1
91332: NOT
91333: PUSH
91334: LD_VAR 0 1
91338: PPUSH
91339: CALL_OW 310
91343: NOT
91344: OR
91345: IFFALSE 91349
// exit ;
91347: GO 91439
// vehicle := IsInUnit ( driver ) ;
91349: LD_ADDR_VAR 0 3
91353: PUSH
91354: LD_VAR 0 1
91358: PPUSH
91359: CALL_OW 310
91363: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91364: LD_VAR 0 1
91368: PPUSH
91369: LD_STRING \
91371: PUSH
91372: LD_INT 0
91374: PUSH
91375: LD_INT 0
91377: PUSH
91378: LD_INT 0
91380: PUSH
91381: LD_INT 0
91383: PUSH
91384: LD_INT 0
91386: PUSH
91387: LD_INT 0
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: PUSH
91399: LD_STRING E
91401: PUSH
91402: LD_INT 0
91404: PUSH
91405: LD_INT 0
91407: PUSH
91408: LD_VAR 0 3
91412: PUSH
91413: LD_INT 0
91415: PUSH
91416: LD_INT 0
91418: PUSH
91419: LD_INT 0
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: PUSH
91431: EMPTY
91432: LIST
91433: LIST
91434: PPUSH
91435: CALL_OW 447
// end ;
91439: LD_VAR 0 2
91443: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
91444: LD_INT 0
91446: PPUSH
91447: PPUSH
91448: PPUSH
// tmp := [ ] ;
91449: LD_ADDR_VAR 0 5
91453: PUSH
91454: EMPTY
91455: ST_TO_ADDR
// for i in units do
91456: LD_ADDR_VAR 0 4
91460: PUSH
91461: LD_VAR 0 1
91465: PUSH
91466: FOR_IN
91467: IFFALSE 91505
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
91469: LD_ADDR_VAR 0 5
91473: PUSH
91474: LD_VAR 0 5
91478: PPUSH
91479: LD_VAR 0 5
91483: PUSH
91484: LD_INT 1
91486: PLUS
91487: PPUSH
91488: LD_VAR 0 4
91492: PPUSH
91493: CALL_OW 256
91497: PPUSH
91498: CALL_OW 2
91502: ST_TO_ADDR
91503: GO 91466
91505: POP
91506: POP
// if not tmp then
91507: LD_VAR 0 5
91511: NOT
91512: IFFALSE 91516
// exit ;
91514: GO 91564
// if asc then
91516: LD_VAR 0 2
91520: IFFALSE 91544
// result := SortListByListAsc ( units , tmp ) else
91522: LD_ADDR_VAR 0 3
91526: PUSH
91527: LD_VAR 0 1
91531: PPUSH
91532: LD_VAR 0 5
91536: PPUSH
91537: CALL_OW 76
91541: ST_TO_ADDR
91542: GO 91564
// result := SortListByListDesc ( units , tmp ) ;
91544: LD_ADDR_VAR 0 3
91548: PUSH
91549: LD_VAR 0 1
91553: PPUSH
91554: LD_VAR 0 5
91558: PPUSH
91559: CALL_OW 77
91563: ST_TO_ADDR
// end ;
91564: LD_VAR 0 3
91568: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
91569: LD_INT 0
91571: PPUSH
91572: PPUSH
// task := GetTaskList ( mech ) ;
91573: LD_ADDR_VAR 0 4
91577: PUSH
91578: LD_VAR 0 1
91582: PPUSH
91583: CALL_OW 437
91587: ST_TO_ADDR
// if not task then
91588: LD_VAR 0 4
91592: NOT
91593: IFFALSE 91597
// exit ;
91595: GO 91639
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
91597: LD_ADDR_VAR 0 3
91601: PUSH
91602: LD_VAR 0 4
91606: PUSH
91607: LD_INT 1
91609: ARRAY
91610: PUSH
91611: LD_INT 1
91613: ARRAY
91614: PUSH
91615: LD_STRING r
91617: EQUAL
91618: PUSH
91619: LD_VAR 0 4
91623: PUSH
91624: LD_INT 1
91626: ARRAY
91627: PUSH
91628: LD_INT 4
91630: ARRAY
91631: PUSH
91632: LD_VAR 0 2
91636: EQUAL
91637: AND
91638: ST_TO_ADDR
// end ;
91639: LD_VAR 0 3
91643: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
91644: LD_INT 0
91646: PPUSH
// SetDir ( unit , d ) ;
91647: LD_VAR 0 1
91651: PPUSH
91652: LD_VAR 0 4
91656: PPUSH
91657: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
91661: LD_VAR 0 1
91665: PPUSH
91666: LD_VAR 0 2
91670: PPUSH
91671: LD_VAR 0 3
91675: PPUSH
91676: LD_VAR 0 5
91680: PPUSH
91681: CALL_OW 48
// end ;
91685: LD_VAR 0 6
91689: RET
// export function ToNaturalNumber ( number ) ; begin
91690: LD_INT 0
91692: PPUSH
// result := number div 1 ;
91693: LD_ADDR_VAR 0 2
91697: PUSH
91698: LD_VAR 0 1
91702: PUSH
91703: LD_INT 1
91705: DIV
91706: ST_TO_ADDR
// if number < 0 then
91707: LD_VAR 0 1
91711: PUSH
91712: LD_INT 0
91714: LESS
91715: IFFALSE 91725
// result := 0 ;
91717: LD_ADDR_VAR 0 2
91721: PUSH
91722: LD_INT 0
91724: ST_TO_ADDR
// end ;
91725: LD_VAR 0 2
91729: RET
// export function SortByClass ( units , class ) ; var un ; begin
91730: LD_INT 0
91732: PPUSH
91733: PPUSH
// if not units or not class then
91734: LD_VAR 0 1
91738: NOT
91739: PUSH
91740: LD_VAR 0 2
91744: NOT
91745: OR
91746: IFFALSE 91750
// exit ;
91748: GO 91845
// result := [ ] ;
91750: LD_ADDR_VAR 0 3
91754: PUSH
91755: EMPTY
91756: ST_TO_ADDR
// for un in units do
91757: LD_ADDR_VAR 0 4
91761: PUSH
91762: LD_VAR 0 1
91766: PUSH
91767: FOR_IN
91768: IFFALSE 91843
// if GetClass ( un ) = class then
91770: LD_VAR 0 4
91774: PPUSH
91775: CALL_OW 257
91779: PUSH
91780: LD_VAR 0 2
91784: EQUAL
91785: IFFALSE 91812
// result := Insert ( result , 1 , un ) else
91787: LD_ADDR_VAR 0 3
91791: PUSH
91792: LD_VAR 0 3
91796: PPUSH
91797: LD_INT 1
91799: PPUSH
91800: LD_VAR 0 4
91804: PPUSH
91805: CALL_OW 2
91809: ST_TO_ADDR
91810: GO 91841
// result := Replace ( result , result + 1 , un ) ;
91812: LD_ADDR_VAR 0 3
91816: PUSH
91817: LD_VAR 0 3
91821: PPUSH
91822: LD_VAR 0 3
91826: PUSH
91827: LD_INT 1
91829: PLUS
91830: PPUSH
91831: LD_VAR 0 4
91835: PPUSH
91836: CALL_OW 1
91840: ST_TO_ADDR
91841: GO 91767
91843: POP
91844: POP
// end ;
91845: LD_VAR 0 3
91849: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
91850: LD_INT 0
91852: PPUSH
91853: PPUSH
91854: PPUSH
91855: PPUSH
91856: PPUSH
91857: PPUSH
91858: PPUSH
// result := [ ] ;
91859: LD_ADDR_VAR 0 4
91863: PUSH
91864: EMPTY
91865: ST_TO_ADDR
// if x - r < 0 then
91866: LD_VAR 0 1
91870: PUSH
91871: LD_VAR 0 3
91875: MINUS
91876: PUSH
91877: LD_INT 0
91879: LESS
91880: IFFALSE 91892
// min_x := 0 else
91882: LD_ADDR_VAR 0 8
91886: PUSH
91887: LD_INT 0
91889: ST_TO_ADDR
91890: GO 91908
// min_x := x - r ;
91892: LD_ADDR_VAR 0 8
91896: PUSH
91897: LD_VAR 0 1
91901: PUSH
91902: LD_VAR 0 3
91906: MINUS
91907: ST_TO_ADDR
// if y - r < 0 then
91908: LD_VAR 0 2
91912: PUSH
91913: LD_VAR 0 3
91917: MINUS
91918: PUSH
91919: LD_INT 0
91921: LESS
91922: IFFALSE 91934
// min_y := 0 else
91924: LD_ADDR_VAR 0 7
91928: PUSH
91929: LD_INT 0
91931: ST_TO_ADDR
91932: GO 91950
// min_y := y - r ;
91934: LD_ADDR_VAR 0 7
91938: PUSH
91939: LD_VAR 0 2
91943: PUSH
91944: LD_VAR 0 3
91948: MINUS
91949: ST_TO_ADDR
// max_x := x + r ;
91950: LD_ADDR_VAR 0 9
91954: PUSH
91955: LD_VAR 0 1
91959: PUSH
91960: LD_VAR 0 3
91964: PLUS
91965: ST_TO_ADDR
// max_y := y + r ;
91966: LD_ADDR_VAR 0 10
91970: PUSH
91971: LD_VAR 0 2
91975: PUSH
91976: LD_VAR 0 3
91980: PLUS
91981: ST_TO_ADDR
// for _x = min_x to max_x do
91982: LD_ADDR_VAR 0 5
91986: PUSH
91987: DOUBLE
91988: LD_VAR 0 8
91992: DEC
91993: ST_TO_ADDR
91994: LD_VAR 0 9
91998: PUSH
91999: FOR_TO
92000: IFFALSE 92101
// for _y = min_y to max_y do
92002: LD_ADDR_VAR 0 6
92006: PUSH
92007: DOUBLE
92008: LD_VAR 0 7
92012: DEC
92013: ST_TO_ADDR
92014: LD_VAR 0 10
92018: PUSH
92019: FOR_TO
92020: IFFALSE 92097
// begin if not ValidHex ( _x , _y ) then
92022: LD_VAR 0 5
92026: PPUSH
92027: LD_VAR 0 6
92031: PPUSH
92032: CALL_OW 488
92036: NOT
92037: IFFALSE 92041
// continue ;
92039: GO 92019
// if GetResourceTypeXY ( _x , _y ) then
92041: LD_VAR 0 5
92045: PPUSH
92046: LD_VAR 0 6
92050: PPUSH
92051: CALL_OW 283
92055: IFFALSE 92095
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
92057: LD_ADDR_VAR 0 4
92061: PUSH
92062: LD_VAR 0 4
92066: PPUSH
92067: LD_VAR 0 4
92071: PUSH
92072: LD_INT 1
92074: PLUS
92075: PPUSH
92076: LD_VAR 0 5
92080: PUSH
92081: LD_VAR 0 6
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: PPUSH
92090: CALL_OW 1
92094: ST_TO_ADDR
// end ;
92095: GO 92019
92097: POP
92098: POP
92099: GO 91999
92101: POP
92102: POP
// end ;
92103: LD_VAR 0 4
92107: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
92108: LD_INT 0
92110: PPUSH
92111: PPUSH
92112: PPUSH
92113: PPUSH
92114: PPUSH
92115: PPUSH
92116: PPUSH
92117: PPUSH
// if not units then
92118: LD_VAR 0 1
92122: NOT
92123: IFFALSE 92127
// exit ;
92125: GO 92651
// result := UnitFilter ( units , [ f_ok ] ) ;
92127: LD_ADDR_VAR 0 3
92131: PUSH
92132: LD_VAR 0 1
92136: PPUSH
92137: LD_INT 50
92139: PUSH
92140: EMPTY
92141: LIST
92142: PPUSH
92143: CALL_OW 72
92147: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
92148: LD_ADDR_VAR 0 8
92152: PUSH
92153: LD_VAR 0 1
92157: PUSH
92158: LD_INT 1
92160: ARRAY
92161: PPUSH
92162: CALL_OW 255
92166: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
92167: LD_ADDR_VAR 0 10
92171: PUSH
92172: LD_INT 29
92174: PUSH
92175: LD_INT 91
92177: PUSH
92178: LD_INT 49
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: LIST
92185: ST_TO_ADDR
// if not result then
92186: LD_VAR 0 3
92190: NOT
92191: IFFALSE 92195
// exit ;
92193: GO 92651
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
92195: LD_ADDR_VAR 0 5
92199: PUSH
92200: LD_INT 81
92202: PUSH
92203: LD_VAR 0 8
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: PPUSH
92212: CALL_OW 69
92216: ST_TO_ADDR
// for i in result do
92217: LD_ADDR_VAR 0 4
92221: PUSH
92222: LD_VAR 0 3
92226: PUSH
92227: FOR_IN
92228: IFFALSE 92649
// begin tag := GetTag ( i ) + 1 ;
92230: LD_ADDR_VAR 0 9
92234: PUSH
92235: LD_VAR 0 4
92239: PPUSH
92240: CALL_OW 110
92244: PUSH
92245: LD_INT 1
92247: PLUS
92248: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
92249: LD_ADDR_VAR 0 7
92253: PUSH
92254: LD_VAR 0 4
92258: PPUSH
92259: CALL_OW 250
92263: PPUSH
92264: LD_VAR 0 4
92268: PPUSH
92269: CALL_OW 251
92273: PPUSH
92274: LD_INT 6
92276: PPUSH
92277: CALL 91850 0 3
92281: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
92282: LD_VAR 0 4
92286: PPUSH
92287: CALL_OW 247
92291: PUSH
92292: LD_INT 2
92294: EQUAL
92295: PUSH
92296: LD_VAR 0 7
92300: AND
92301: PUSH
92302: LD_VAR 0 4
92306: PPUSH
92307: CALL_OW 264
92311: PUSH
92312: LD_VAR 0 10
92316: IN
92317: NOT
92318: AND
92319: IFFALSE 92358
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
92321: LD_VAR 0 4
92325: PPUSH
92326: LD_VAR 0 7
92330: PUSH
92331: LD_INT 1
92333: ARRAY
92334: PUSH
92335: LD_INT 1
92337: ARRAY
92338: PPUSH
92339: LD_VAR 0 7
92343: PUSH
92344: LD_INT 1
92346: ARRAY
92347: PUSH
92348: LD_INT 2
92350: ARRAY
92351: PPUSH
92352: CALL_OW 116
92356: GO 92647
// if path > tag then
92358: LD_VAR 0 2
92362: PUSH
92363: LD_VAR 0 9
92367: GREATER
92368: IFFALSE 92576
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
92370: LD_ADDR_VAR 0 6
92374: PUSH
92375: LD_VAR 0 5
92379: PPUSH
92380: LD_INT 91
92382: PUSH
92383: LD_VAR 0 4
92387: PUSH
92388: LD_INT 8
92390: PUSH
92391: EMPTY
92392: LIST
92393: LIST
92394: LIST
92395: PPUSH
92396: CALL_OW 72
92400: ST_TO_ADDR
// if nearEnemy then
92401: LD_VAR 0 6
92405: IFFALSE 92474
// begin if GetWeapon ( i ) = ru_time_lapser then
92407: LD_VAR 0 4
92411: PPUSH
92412: CALL_OW 264
92416: PUSH
92417: LD_INT 49
92419: EQUAL
92420: IFFALSE 92448
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
92422: LD_VAR 0 4
92426: PPUSH
92427: LD_VAR 0 6
92431: PPUSH
92432: LD_VAR 0 4
92436: PPUSH
92437: CALL_OW 74
92441: PPUSH
92442: CALL_OW 112
92446: GO 92472
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
92448: LD_VAR 0 4
92452: PPUSH
92453: LD_VAR 0 6
92457: PPUSH
92458: LD_VAR 0 4
92462: PPUSH
92463: CALL_OW 74
92467: PPUSH
92468: CALL_OW 115
// end else
92472: GO 92574
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
92474: LD_VAR 0 4
92478: PPUSH
92479: LD_VAR 0 2
92483: PUSH
92484: LD_VAR 0 9
92488: ARRAY
92489: PUSH
92490: LD_INT 1
92492: ARRAY
92493: PPUSH
92494: LD_VAR 0 2
92498: PUSH
92499: LD_VAR 0 9
92503: ARRAY
92504: PUSH
92505: LD_INT 2
92507: ARRAY
92508: PPUSH
92509: CALL_OW 297
92513: PUSH
92514: LD_INT 6
92516: GREATER
92517: IFFALSE 92560
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
92519: LD_VAR 0 4
92523: PPUSH
92524: LD_VAR 0 2
92528: PUSH
92529: LD_VAR 0 9
92533: ARRAY
92534: PUSH
92535: LD_INT 1
92537: ARRAY
92538: PPUSH
92539: LD_VAR 0 2
92543: PUSH
92544: LD_VAR 0 9
92548: ARRAY
92549: PUSH
92550: LD_INT 2
92552: ARRAY
92553: PPUSH
92554: CALL_OW 114
92558: GO 92574
// SetTag ( i , tag ) ;
92560: LD_VAR 0 4
92564: PPUSH
92565: LD_VAR 0 9
92569: PPUSH
92570: CALL_OW 109
// end else
92574: GO 92647
// if enemy then
92576: LD_VAR 0 5
92580: IFFALSE 92647
// begin if GetWeapon ( i ) = ru_time_lapser then
92582: LD_VAR 0 4
92586: PPUSH
92587: CALL_OW 264
92591: PUSH
92592: LD_INT 49
92594: EQUAL
92595: IFFALSE 92623
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
92597: LD_VAR 0 4
92601: PPUSH
92602: LD_VAR 0 5
92606: PPUSH
92607: LD_VAR 0 4
92611: PPUSH
92612: CALL_OW 74
92616: PPUSH
92617: CALL_OW 112
92621: GO 92647
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
92623: LD_VAR 0 4
92627: PPUSH
92628: LD_VAR 0 5
92632: PPUSH
92633: LD_VAR 0 4
92637: PPUSH
92638: CALL_OW 74
92642: PPUSH
92643: CALL_OW 115
// end ; end ;
92647: GO 92227
92649: POP
92650: POP
// end ;
92651: LD_VAR 0 3
92655: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
92656: LD_INT 0
92658: PPUSH
92659: PPUSH
92660: PPUSH
// if not unit or IsInUnit ( unit ) then
92661: LD_VAR 0 1
92665: NOT
92666: PUSH
92667: LD_VAR 0 1
92671: PPUSH
92672: CALL_OW 310
92676: OR
92677: IFFALSE 92681
// exit ;
92679: GO 92772
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
92681: LD_ADDR_VAR 0 4
92685: PUSH
92686: LD_VAR 0 1
92690: PPUSH
92691: CALL_OW 250
92695: PPUSH
92696: LD_VAR 0 2
92700: PPUSH
92701: LD_INT 1
92703: PPUSH
92704: CALL_OW 272
92708: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
92709: LD_ADDR_VAR 0 5
92713: PUSH
92714: LD_VAR 0 1
92718: PPUSH
92719: CALL_OW 251
92723: PPUSH
92724: LD_VAR 0 2
92728: PPUSH
92729: LD_INT 1
92731: PPUSH
92732: CALL_OW 273
92736: ST_TO_ADDR
// if ValidHex ( x , y ) then
92737: LD_VAR 0 4
92741: PPUSH
92742: LD_VAR 0 5
92746: PPUSH
92747: CALL_OW 488
92751: IFFALSE 92772
// ComTurnXY ( unit , x , y ) ;
92753: LD_VAR 0 1
92757: PPUSH
92758: LD_VAR 0 4
92762: PPUSH
92763: LD_VAR 0 5
92767: PPUSH
92768: CALL_OW 118
// end ;
92772: LD_VAR 0 3
92776: RET
// export function SeeUnits ( side , units ) ; var i ; begin
92777: LD_INT 0
92779: PPUSH
92780: PPUSH
// result := false ;
92781: LD_ADDR_VAR 0 3
92785: PUSH
92786: LD_INT 0
92788: ST_TO_ADDR
// if not units then
92789: LD_VAR 0 2
92793: NOT
92794: IFFALSE 92798
// exit ;
92796: GO 92843
// for i in units do
92798: LD_ADDR_VAR 0 4
92802: PUSH
92803: LD_VAR 0 2
92807: PUSH
92808: FOR_IN
92809: IFFALSE 92841
// if See ( side , i ) then
92811: LD_VAR 0 1
92815: PPUSH
92816: LD_VAR 0 4
92820: PPUSH
92821: CALL_OW 292
92825: IFFALSE 92839
// begin result := true ;
92827: LD_ADDR_VAR 0 3
92831: PUSH
92832: LD_INT 1
92834: ST_TO_ADDR
// exit ;
92835: POP
92836: POP
92837: GO 92843
// end ;
92839: GO 92808
92841: POP
92842: POP
// end ;
92843: LD_VAR 0 3
92847: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
92848: LD_INT 0
92850: PPUSH
92851: PPUSH
92852: PPUSH
92853: PPUSH
// if not unit or not points then
92854: LD_VAR 0 1
92858: NOT
92859: PUSH
92860: LD_VAR 0 2
92864: NOT
92865: OR
92866: IFFALSE 92870
// exit ;
92868: GO 92960
// dist := 99999 ;
92870: LD_ADDR_VAR 0 5
92874: PUSH
92875: LD_INT 99999
92877: ST_TO_ADDR
// for i in points do
92878: LD_ADDR_VAR 0 4
92882: PUSH
92883: LD_VAR 0 2
92887: PUSH
92888: FOR_IN
92889: IFFALSE 92958
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
92891: LD_ADDR_VAR 0 6
92895: PUSH
92896: LD_VAR 0 1
92900: PPUSH
92901: LD_VAR 0 4
92905: PUSH
92906: LD_INT 1
92908: ARRAY
92909: PPUSH
92910: LD_VAR 0 4
92914: PUSH
92915: LD_INT 2
92917: ARRAY
92918: PPUSH
92919: CALL_OW 297
92923: ST_TO_ADDR
// if tmpDist < dist then
92924: LD_VAR 0 6
92928: PUSH
92929: LD_VAR 0 5
92933: LESS
92934: IFFALSE 92956
// begin result := i ;
92936: LD_ADDR_VAR 0 3
92940: PUSH
92941: LD_VAR 0 4
92945: ST_TO_ADDR
// dist := tmpDist ;
92946: LD_ADDR_VAR 0 5
92950: PUSH
92951: LD_VAR 0 6
92955: ST_TO_ADDR
// end ; end ;
92956: GO 92888
92958: POP
92959: POP
// end ;
92960: LD_VAR 0 3
92964: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
92965: LD_INT 0
92967: PPUSH
// uc_side := side ;
92968: LD_ADDR_OWVAR 20
92972: PUSH
92973: LD_VAR 0 1
92977: ST_TO_ADDR
// uc_nation := 3 ;
92978: LD_ADDR_OWVAR 21
92982: PUSH
92983: LD_INT 3
92985: ST_TO_ADDR
// vc_chassis := 25 ;
92986: LD_ADDR_OWVAR 37
92990: PUSH
92991: LD_INT 25
92993: ST_TO_ADDR
// vc_engine := engine_siberite ;
92994: LD_ADDR_OWVAR 39
92998: PUSH
92999: LD_INT 3
93001: ST_TO_ADDR
// vc_control := control_computer ;
93002: LD_ADDR_OWVAR 38
93006: PUSH
93007: LD_INT 3
93009: ST_TO_ADDR
// vc_weapon := 59 ;
93010: LD_ADDR_OWVAR 40
93014: PUSH
93015: LD_INT 59
93017: ST_TO_ADDR
// result := CreateVehicle ;
93018: LD_ADDR_VAR 0 5
93022: PUSH
93023: CALL_OW 45
93027: ST_TO_ADDR
// SetDir ( result , d ) ;
93028: LD_VAR 0 5
93032: PPUSH
93033: LD_VAR 0 4
93037: PPUSH
93038: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
93042: LD_VAR 0 5
93046: PPUSH
93047: LD_VAR 0 2
93051: PPUSH
93052: LD_VAR 0 3
93056: PPUSH
93057: LD_INT 0
93059: PPUSH
93060: CALL_OW 48
// end ;
93064: LD_VAR 0 5
93068: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
93069: LD_INT 0
93071: PPUSH
93072: PPUSH
93073: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
93074: LD_ADDR_VAR 0 2
93078: PUSH
93079: LD_INT 0
93081: PUSH
93082: LD_INT 0
93084: PUSH
93085: LD_INT 0
93087: PUSH
93088: LD_INT 0
93090: PUSH
93091: EMPTY
93092: LIST
93093: LIST
93094: LIST
93095: LIST
93096: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
93097: LD_VAR 0 1
93101: NOT
93102: PUSH
93103: LD_VAR 0 1
93107: PPUSH
93108: CALL_OW 264
93112: PUSH
93113: LD_INT 12
93115: PUSH
93116: LD_INT 51
93118: PUSH
93119: LD_INT 32
93121: PUSH
93122: LD_INT 89
93124: PUSH
93125: EMPTY
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: IN
93131: NOT
93132: OR
93133: IFFALSE 93137
// exit ;
93135: GO 93235
// for i := 1 to 3 do
93137: LD_ADDR_VAR 0 3
93141: PUSH
93142: DOUBLE
93143: LD_INT 1
93145: DEC
93146: ST_TO_ADDR
93147: LD_INT 3
93149: PUSH
93150: FOR_TO
93151: IFFALSE 93233
// begin tmp := GetCargo ( cargo , i ) ;
93153: LD_ADDR_VAR 0 4
93157: PUSH
93158: LD_VAR 0 1
93162: PPUSH
93163: LD_VAR 0 3
93167: PPUSH
93168: CALL_OW 289
93172: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
93173: LD_ADDR_VAR 0 2
93177: PUSH
93178: LD_VAR 0 2
93182: PPUSH
93183: LD_VAR 0 3
93187: PPUSH
93188: LD_VAR 0 4
93192: PPUSH
93193: CALL_OW 1
93197: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
93198: LD_ADDR_VAR 0 2
93202: PUSH
93203: LD_VAR 0 2
93207: PPUSH
93208: LD_INT 4
93210: PPUSH
93211: LD_VAR 0 2
93215: PUSH
93216: LD_INT 4
93218: ARRAY
93219: PUSH
93220: LD_VAR 0 4
93224: PLUS
93225: PPUSH
93226: CALL_OW 1
93230: ST_TO_ADDR
// end ;
93231: GO 93150
93233: POP
93234: POP
// end ;
93235: LD_VAR 0 2
93239: RET
// export function Length ( array ) ; begin
93240: LD_INT 0
93242: PPUSH
// result := array + 0 ;
93243: LD_ADDR_VAR 0 2
93247: PUSH
93248: LD_VAR 0 1
93252: PUSH
93253: LD_INT 0
93255: PLUS
93256: ST_TO_ADDR
// end ;
93257: LD_VAR 0 2
93261: RET
// export function PrepareArray ( array ) ; begin
93262: LD_INT 0
93264: PPUSH
// result := array diff 0 ;
93265: LD_ADDR_VAR 0 2
93269: PUSH
93270: LD_VAR 0 1
93274: PUSH
93275: LD_INT 0
93277: DIFF
93278: ST_TO_ADDR
// if not result [ 1 ] then
93279: LD_VAR 0 2
93283: PUSH
93284: LD_INT 1
93286: ARRAY
93287: NOT
93288: IFFALSE 93308
// result := Delete ( result , 1 ) ;
93290: LD_ADDR_VAR 0 2
93294: PUSH
93295: LD_VAR 0 2
93299: PPUSH
93300: LD_INT 1
93302: PPUSH
93303: CALL_OW 3
93307: ST_TO_ADDR
// end ;
93308: LD_VAR 0 2
93312: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
93313: LD_INT 0
93315: PPUSH
93316: PPUSH
93317: PPUSH
93318: PPUSH
// sibRocketRange := 25 ;
93319: LD_ADDR_VAR 0 6
93323: PUSH
93324: LD_INT 25
93326: ST_TO_ADDR
// result := false ;
93327: LD_ADDR_VAR 0 4
93331: PUSH
93332: LD_INT 0
93334: ST_TO_ADDR
// for i := 0 to 5 do
93335: LD_ADDR_VAR 0 5
93339: PUSH
93340: DOUBLE
93341: LD_INT 0
93343: DEC
93344: ST_TO_ADDR
93345: LD_INT 5
93347: PUSH
93348: FOR_TO
93349: IFFALSE 93416
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
93351: LD_VAR 0 1
93355: PPUSH
93356: LD_VAR 0 5
93360: PPUSH
93361: LD_VAR 0 6
93365: PPUSH
93366: CALL_OW 272
93370: PPUSH
93371: LD_VAR 0 2
93375: PPUSH
93376: LD_VAR 0 5
93380: PPUSH
93381: LD_VAR 0 6
93385: PPUSH
93386: CALL_OW 273
93390: PPUSH
93391: LD_VAR 0 3
93395: PPUSH
93396: CALL_OW 309
93400: IFFALSE 93414
// begin result := true ;
93402: LD_ADDR_VAR 0 4
93406: PUSH
93407: LD_INT 1
93409: ST_TO_ADDR
// exit ;
93410: POP
93411: POP
93412: GO 93418
// end ;
93414: GO 93348
93416: POP
93417: POP
// end ;
93418: LD_VAR 0 4
93422: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
93423: LD_INT 0
93425: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
93426: LD_VAR 0 1
93430: PPUSH
93431: LD_VAR 0 2
93435: PPUSH
93436: LD_INT 0
93438: PPUSH
93439: LD_INT 0
93441: PPUSH
93442: LD_INT 1
93444: PPUSH
93445: LD_INT 0
93447: PPUSH
93448: CALL_OW 587
// end ;
93452: LD_VAR 0 3
93456: RET
// export function CenterOnNow ( unit ) ; begin
93457: LD_INT 0
93459: PPUSH
// result := IsInUnit ( unit ) ;
93460: LD_ADDR_VAR 0 2
93464: PUSH
93465: LD_VAR 0 1
93469: PPUSH
93470: CALL_OW 310
93474: ST_TO_ADDR
// if not result then
93475: LD_VAR 0 2
93479: NOT
93480: IFFALSE 93492
// result := unit ;
93482: LD_ADDR_VAR 0 2
93486: PUSH
93487: LD_VAR 0 1
93491: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
93492: LD_VAR 0 1
93496: PPUSH
93497: CALL_OW 87
// end ;
93501: LD_VAR 0 2
93505: RET
// export function ComMoveHex ( unit , hex ) ; begin
93506: LD_INT 0
93508: PPUSH
// if not hex then
93509: LD_VAR 0 2
93513: NOT
93514: IFFALSE 93518
// exit ;
93516: GO 93571
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
93518: LD_VAR 0 2
93522: PUSH
93523: LD_INT 1
93525: ARRAY
93526: PPUSH
93527: LD_VAR 0 2
93531: PUSH
93532: LD_INT 2
93534: ARRAY
93535: PPUSH
93536: CALL_OW 428
93540: IFFALSE 93544
// exit ;
93542: GO 93571
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
93544: LD_VAR 0 1
93548: PPUSH
93549: LD_VAR 0 2
93553: PUSH
93554: LD_INT 1
93556: ARRAY
93557: PPUSH
93558: LD_VAR 0 2
93562: PUSH
93563: LD_INT 2
93565: ARRAY
93566: PPUSH
93567: CALL_OW 111
// end ; end_of_file end_of_file
93571: LD_VAR 0 3
93575: RET
// export globalGameSaveCounter ; every 0 0$1 do
93576: GO 93578
93578: DISABLE
// begin enable ;
93579: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93580: LD_STRING updateTimer(
93582: PUSH
93583: LD_OWVAR 1
93587: STR
93588: PUSH
93589: LD_STRING );
93591: STR
93592: PPUSH
93593: CALL_OW 559
// end ;
93597: END
// every 0 0$1 do
93598: GO 93600
93600: DISABLE
// begin globalGameSaveCounter := 0 ;
93601: LD_ADDR_EXP 123
93605: PUSH
93606: LD_INT 0
93608: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
93609: LD_STRING setGameSaveCounter(0)
93611: PPUSH
93612: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
93616: LD_STRING initStreamRollete();
93618: PPUSH
93619: CALL_OW 559
// InitStreamMode ;
93623: CALL 94949 0 0
// DefineStreamItems ( false ) ;
93627: LD_INT 0
93629: PPUSH
93630: CALL 95413 0 1
// end ;
93634: END
// export function SOS_MapStart ( ) ; begin
93635: LD_INT 0
93637: PPUSH
// if streamModeActive then
93638: LD_EXP 124
93642: IFFALSE 93651
// DefineStreamItems ( true ) ;
93644: LD_INT 1
93646: PPUSH
93647: CALL 95413 0 1
// UpdateLuaVariables ( ) ;
93651: CALL 93668 0 0
// UpdateFactoryWaypoints ( ) ;
93655: CALL 108274 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93659: CALL 108531 0 0
// end ;
93663: LD_VAR 0 1
93667: RET
// function UpdateLuaVariables ( ) ; begin
93668: LD_INT 0
93670: PPUSH
// if globalGameSaveCounter then
93671: LD_EXP 123
93675: IFFALSE 93709
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
93677: LD_ADDR_EXP 123
93681: PUSH
93682: LD_EXP 123
93686: PPUSH
93687: CALL 90865 0 1
93691: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93692: LD_STRING setGameSaveCounter(
93694: PUSH
93695: LD_EXP 123
93699: STR
93700: PUSH
93701: LD_STRING )
93703: STR
93704: PPUSH
93705: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
93709: LD_STRING setGameDifficulty(
93711: PUSH
93712: LD_OWVAR 67
93716: STR
93717: PUSH
93718: LD_STRING )
93720: STR
93721: PPUSH
93722: CALL_OW 559
// end ;
93726: LD_VAR 0 1
93730: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93731: LD_INT 0
93733: PPUSH
// if p2 = stream_mode then
93734: LD_VAR 0 2
93738: PUSH
93739: LD_INT 100
93741: EQUAL
93742: IFFALSE 94745
// begin if not StreamModeActive then
93744: LD_EXP 124
93748: NOT
93749: IFFALSE 93759
// StreamModeActive := true ;
93751: LD_ADDR_EXP 124
93755: PUSH
93756: LD_INT 1
93758: ST_TO_ADDR
// if p3 = 0 then
93759: LD_VAR 0 3
93763: PUSH
93764: LD_INT 0
93766: EQUAL
93767: IFFALSE 93773
// InitStreamMode ;
93769: CALL 94949 0 0
// if p3 = 1 then
93773: LD_VAR 0 3
93777: PUSH
93778: LD_INT 1
93780: EQUAL
93781: IFFALSE 93791
// sRocket := true ;
93783: LD_ADDR_EXP 129
93787: PUSH
93788: LD_INT 1
93790: ST_TO_ADDR
// if p3 = 2 then
93791: LD_VAR 0 3
93795: PUSH
93796: LD_INT 2
93798: EQUAL
93799: IFFALSE 93809
// sSpeed := true ;
93801: LD_ADDR_EXP 128
93805: PUSH
93806: LD_INT 1
93808: ST_TO_ADDR
// if p3 = 3 then
93809: LD_VAR 0 3
93813: PUSH
93814: LD_INT 3
93816: EQUAL
93817: IFFALSE 93827
// sEngine := true ;
93819: LD_ADDR_EXP 130
93823: PUSH
93824: LD_INT 1
93826: ST_TO_ADDR
// if p3 = 4 then
93827: LD_VAR 0 3
93831: PUSH
93832: LD_INT 4
93834: EQUAL
93835: IFFALSE 93845
// sSpec := true ;
93837: LD_ADDR_EXP 127
93841: PUSH
93842: LD_INT 1
93844: ST_TO_ADDR
// if p3 = 5 then
93845: LD_VAR 0 3
93849: PUSH
93850: LD_INT 5
93852: EQUAL
93853: IFFALSE 93863
// sLevel := true ;
93855: LD_ADDR_EXP 131
93859: PUSH
93860: LD_INT 1
93862: ST_TO_ADDR
// if p3 = 6 then
93863: LD_VAR 0 3
93867: PUSH
93868: LD_INT 6
93870: EQUAL
93871: IFFALSE 93881
// sArmoury := true ;
93873: LD_ADDR_EXP 132
93877: PUSH
93878: LD_INT 1
93880: ST_TO_ADDR
// if p3 = 7 then
93881: LD_VAR 0 3
93885: PUSH
93886: LD_INT 7
93888: EQUAL
93889: IFFALSE 93899
// sRadar := true ;
93891: LD_ADDR_EXP 133
93895: PUSH
93896: LD_INT 1
93898: ST_TO_ADDR
// if p3 = 8 then
93899: LD_VAR 0 3
93903: PUSH
93904: LD_INT 8
93906: EQUAL
93907: IFFALSE 93917
// sBunker := true ;
93909: LD_ADDR_EXP 134
93913: PUSH
93914: LD_INT 1
93916: ST_TO_ADDR
// if p3 = 9 then
93917: LD_VAR 0 3
93921: PUSH
93922: LD_INT 9
93924: EQUAL
93925: IFFALSE 93935
// sHack := true ;
93927: LD_ADDR_EXP 135
93931: PUSH
93932: LD_INT 1
93934: ST_TO_ADDR
// if p3 = 10 then
93935: LD_VAR 0 3
93939: PUSH
93940: LD_INT 10
93942: EQUAL
93943: IFFALSE 93953
// sFire := true ;
93945: LD_ADDR_EXP 136
93949: PUSH
93950: LD_INT 1
93952: ST_TO_ADDR
// if p3 = 11 then
93953: LD_VAR 0 3
93957: PUSH
93958: LD_INT 11
93960: EQUAL
93961: IFFALSE 93971
// sRefresh := true ;
93963: LD_ADDR_EXP 137
93967: PUSH
93968: LD_INT 1
93970: ST_TO_ADDR
// if p3 = 12 then
93971: LD_VAR 0 3
93975: PUSH
93976: LD_INT 12
93978: EQUAL
93979: IFFALSE 93989
// sExp := true ;
93981: LD_ADDR_EXP 138
93985: PUSH
93986: LD_INT 1
93988: ST_TO_ADDR
// if p3 = 13 then
93989: LD_VAR 0 3
93993: PUSH
93994: LD_INT 13
93996: EQUAL
93997: IFFALSE 94007
// sDepot := true ;
93999: LD_ADDR_EXP 139
94003: PUSH
94004: LD_INT 1
94006: ST_TO_ADDR
// if p3 = 14 then
94007: LD_VAR 0 3
94011: PUSH
94012: LD_INT 14
94014: EQUAL
94015: IFFALSE 94025
// sFlag := true ;
94017: LD_ADDR_EXP 140
94021: PUSH
94022: LD_INT 1
94024: ST_TO_ADDR
// if p3 = 15 then
94025: LD_VAR 0 3
94029: PUSH
94030: LD_INT 15
94032: EQUAL
94033: IFFALSE 94043
// sKamikadze := true ;
94035: LD_ADDR_EXP 148
94039: PUSH
94040: LD_INT 1
94042: ST_TO_ADDR
// if p3 = 16 then
94043: LD_VAR 0 3
94047: PUSH
94048: LD_INT 16
94050: EQUAL
94051: IFFALSE 94061
// sTroll := true ;
94053: LD_ADDR_EXP 149
94057: PUSH
94058: LD_INT 1
94060: ST_TO_ADDR
// if p3 = 17 then
94061: LD_VAR 0 3
94065: PUSH
94066: LD_INT 17
94068: EQUAL
94069: IFFALSE 94079
// sSlow := true ;
94071: LD_ADDR_EXP 150
94075: PUSH
94076: LD_INT 1
94078: ST_TO_ADDR
// if p3 = 18 then
94079: LD_VAR 0 3
94083: PUSH
94084: LD_INT 18
94086: EQUAL
94087: IFFALSE 94097
// sLack := true ;
94089: LD_ADDR_EXP 151
94093: PUSH
94094: LD_INT 1
94096: ST_TO_ADDR
// if p3 = 19 then
94097: LD_VAR 0 3
94101: PUSH
94102: LD_INT 19
94104: EQUAL
94105: IFFALSE 94115
// sTank := true ;
94107: LD_ADDR_EXP 153
94111: PUSH
94112: LD_INT 1
94114: ST_TO_ADDR
// if p3 = 20 then
94115: LD_VAR 0 3
94119: PUSH
94120: LD_INT 20
94122: EQUAL
94123: IFFALSE 94133
// sRemote := true ;
94125: LD_ADDR_EXP 154
94129: PUSH
94130: LD_INT 1
94132: ST_TO_ADDR
// if p3 = 21 then
94133: LD_VAR 0 3
94137: PUSH
94138: LD_INT 21
94140: EQUAL
94141: IFFALSE 94151
// sPowell := true ;
94143: LD_ADDR_EXP 155
94147: PUSH
94148: LD_INT 1
94150: ST_TO_ADDR
// if p3 = 22 then
94151: LD_VAR 0 3
94155: PUSH
94156: LD_INT 22
94158: EQUAL
94159: IFFALSE 94169
// sTeleport := true ;
94161: LD_ADDR_EXP 158
94165: PUSH
94166: LD_INT 1
94168: ST_TO_ADDR
// if p3 = 23 then
94169: LD_VAR 0 3
94173: PUSH
94174: LD_INT 23
94176: EQUAL
94177: IFFALSE 94187
// sOilTower := true ;
94179: LD_ADDR_EXP 160
94183: PUSH
94184: LD_INT 1
94186: ST_TO_ADDR
// if p3 = 24 then
94187: LD_VAR 0 3
94191: PUSH
94192: LD_INT 24
94194: EQUAL
94195: IFFALSE 94205
// sShovel := true ;
94197: LD_ADDR_EXP 161
94201: PUSH
94202: LD_INT 1
94204: ST_TO_ADDR
// if p3 = 25 then
94205: LD_VAR 0 3
94209: PUSH
94210: LD_INT 25
94212: EQUAL
94213: IFFALSE 94223
// sSheik := true ;
94215: LD_ADDR_EXP 162
94219: PUSH
94220: LD_INT 1
94222: ST_TO_ADDR
// if p3 = 26 then
94223: LD_VAR 0 3
94227: PUSH
94228: LD_INT 26
94230: EQUAL
94231: IFFALSE 94241
// sEarthquake := true ;
94233: LD_ADDR_EXP 164
94237: PUSH
94238: LD_INT 1
94240: ST_TO_ADDR
// if p3 = 27 then
94241: LD_VAR 0 3
94245: PUSH
94246: LD_INT 27
94248: EQUAL
94249: IFFALSE 94259
// sAI := true ;
94251: LD_ADDR_EXP 165
94255: PUSH
94256: LD_INT 1
94258: ST_TO_ADDR
// if p3 = 28 then
94259: LD_VAR 0 3
94263: PUSH
94264: LD_INT 28
94266: EQUAL
94267: IFFALSE 94277
// sCargo := true ;
94269: LD_ADDR_EXP 168
94273: PUSH
94274: LD_INT 1
94276: ST_TO_ADDR
// if p3 = 29 then
94277: LD_VAR 0 3
94281: PUSH
94282: LD_INT 29
94284: EQUAL
94285: IFFALSE 94295
// sDLaser := true ;
94287: LD_ADDR_EXP 169
94291: PUSH
94292: LD_INT 1
94294: ST_TO_ADDR
// if p3 = 30 then
94295: LD_VAR 0 3
94299: PUSH
94300: LD_INT 30
94302: EQUAL
94303: IFFALSE 94313
// sExchange := true ;
94305: LD_ADDR_EXP 170
94309: PUSH
94310: LD_INT 1
94312: ST_TO_ADDR
// if p3 = 31 then
94313: LD_VAR 0 3
94317: PUSH
94318: LD_INT 31
94320: EQUAL
94321: IFFALSE 94331
// sFac := true ;
94323: LD_ADDR_EXP 171
94327: PUSH
94328: LD_INT 1
94330: ST_TO_ADDR
// if p3 = 32 then
94331: LD_VAR 0 3
94335: PUSH
94336: LD_INT 32
94338: EQUAL
94339: IFFALSE 94349
// sPower := true ;
94341: LD_ADDR_EXP 172
94345: PUSH
94346: LD_INT 1
94348: ST_TO_ADDR
// if p3 = 33 then
94349: LD_VAR 0 3
94353: PUSH
94354: LD_INT 33
94356: EQUAL
94357: IFFALSE 94367
// sRandom := true ;
94359: LD_ADDR_EXP 173
94363: PUSH
94364: LD_INT 1
94366: ST_TO_ADDR
// if p3 = 34 then
94367: LD_VAR 0 3
94371: PUSH
94372: LD_INT 34
94374: EQUAL
94375: IFFALSE 94385
// sShield := true ;
94377: LD_ADDR_EXP 174
94381: PUSH
94382: LD_INT 1
94384: ST_TO_ADDR
// if p3 = 35 then
94385: LD_VAR 0 3
94389: PUSH
94390: LD_INT 35
94392: EQUAL
94393: IFFALSE 94403
// sTime := true ;
94395: LD_ADDR_EXP 175
94399: PUSH
94400: LD_INT 1
94402: ST_TO_ADDR
// if p3 = 36 then
94403: LD_VAR 0 3
94407: PUSH
94408: LD_INT 36
94410: EQUAL
94411: IFFALSE 94421
// sTools := true ;
94413: LD_ADDR_EXP 176
94417: PUSH
94418: LD_INT 1
94420: ST_TO_ADDR
// if p3 = 101 then
94421: LD_VAR 0 3
94425: PUSH
94426: LD_INT 101
94428: EQUAL
94429: IFFALSE 94439
// sSold := true ;
94431: LD_ADDR_EXP 141
94435: PUSH
94436: LD_INT 1
94438: ST_TO_ADDR
// if p3 = 102 then
94439: LD_VAR 0 3
94443: PUSH
94444: LD_INT 102
94446: EQUAL
94447: IFFALSE 94457
// sDiff := true ;
94449: LD_ADDR_EXP 142
94453: PUSH
94454: LD_INT 1
94456: ST_TO_ADDR
// if p3 = 103 then
94457: LD_VAR 0 3
94461: PUSH
94462: LD_INT 103
94464: EQUAL
94465: IFFALSE 94475
// sFog := true ;
94467: LD_ADDR_EXP 145
94471: PUSH
94472: LD_INT 1
94474: ST_TO_ADDR
// if p3 = 104 then
94475: LD_VAR 0 3
94479: PUSH
94480: LD_INT 104
94482: EQUAL
94483: IFFALSE 94493
// sReset := true ;
94485: LD_ADDR_EXP 146
94489: PUSH
94490: LD_INT 1
94492: ST_TO_ADDR
// if p3 = 105 then
94493: LD_VAR 0 3
94497: PUSH
94498: LD_INT 105
94500: EQUAL
94501: IFFALSE 94511
// sSun := true ;
94503: LD_ADDR_EXP 147
94507: PUSH
94508: LD_INT 1
94510: ST_TO_ADDR
// if p3 = 106 then
94511: LD_VAR 0 3
94515: PUSH
94516: LD_INT 106
94518: EQUAL
94519: IFFALSE 94529
// sTiger := true ;
94521: LD_ADDR_EXP 143
94525: PUSH
94526: LD_INT 1
94528: ST_TO_ADDR
// if p3 = 107 then
94529: LD_VAR 0 3
94533: PUSH
94534: LD_INT 107
94536: EQUAL
94537: IFFALSE 94547
// sBomb := true ;
94539: LD_ADDR_EXP 144
94543: PUSH
94544: LD_INT 1
94546: ST_TO_ADDR
// if p3 = 108 then
94547: LD_VAR 0 3
94551: PUSH
94552: LD_INT 108
94554: EQUAL
94555: IFFALSE 94565
// sWound := true ;
94557: LD_ADDR_EXP 152
94561: PUSH
94562: LD_INT 1
94564: ST_TO_ADDR
// if p3 = 109 then
94565: LD_VAR 0 3
94569: PUSH
94570: LD_INT 109
94572: EQUAL
94573: IFFALSE 94583
// sBetray := true ;
94575: LD_ADDR_EXP 156
94579: PUSH
94580: LD_INT 1
94582: ST_TO_ADDR
// if p3 = 110 then
94583: LD_VAR 0 3
94587: PUSH
94588: LD_INT 110
94590: EQUAL
94591: IFFALSE 94601
// sContamin := true ;
94593: LD_ADDR_EXP 157
94597: PUSH
94598: LD_INT 1
94600: ST_TO_ADDR
// if p3 = 111 then
94601: LD_VAR 0 3
94605: PUSH
94606: LD_INT 111
94608: EQUAL
94609: IFFALSE 94619
// sOil := true ;
94611: LD_ADDR_EXP 159
94615: PUSH
94616: LD_INT 1
94618: ST_TO_ADDR
// if p3 = 112 then
94619: LD_VAR 0 3
94623: PUSH
94624: LD_INT 112
94626: EQUAL
94627: IFFALSE 94637
// sStu := true ;
94629: LD_ADDR_EXP 163
94633: PUSH
94634: LD_INT 1
94636: ST_TO_ADDR
// if p3 = 113 then
94637: LD_VAR 0 3
94641: PUSH
94642: LD_INT 113
94644: EQUAL
94645: IFFALSE 94655
// sBazooka := true ;
94647: LD_ADDR_EXP 166
94651: PUSH
94652: LD_INT 1
94654: ST_TO_ADDR
// if p3 = 114 then
94655: LD_VAR 0 3
94659: PUSH
94660: LD_INT 114
94662: EQUAL
94663: IFFALSE 94673
// sMortar := true ;
94665: LD_ADDR_EXP 167
94669: PUSH
94670: LD_INT 1
94672: ST_TO_ADDR
// if p3 = 115 then
94673: LD_VAR 0 3
94677: PUSH
94678: LD_INT 115
94680: EQUAL
94681: IFFALSE 94691
// sRanger := true ;
94683: LD_ADDR_EXP 177
94687: PUSH
94688: LD_INT 1
94690: ST_TO_ADDR
// if p3 = 116 then
94691: LD_VAR 0 3
94695: PUSH
94696: LD_INT 116
94698: EQUAL
94699: IFFALSE 94709
// sComputer := true ;
94701: LD_ADDR_EXP 178
94705: PUSH
94706: LD_INT 1
94708: ST_TO_ADDR
// if p3 = 117 then
94709: LD_VAR 0 3
94713: PUSH
94714: LD_INT 117
94716: EQUAL
94717: IFFALSE 94727
// s30 := true ;
94719: LD_ADDR_EXP 179
94723: PUSH
94724: LD_INT 1
94726: ST_TO_ADDR
// if p3 = 118 then
94727: LD_VAR 0 3
94731: PUSH
94732: LD_INT 118
94734: EQUAL
94735: IFFALSE 94745
// s60 := true ;
94737: LD_ADDR_EXP 180
94741: PUSH
94742: LD_INT 1
94744: ST_TO_ADDR
// end ; if p2 = hack_mode then
94745: LD_VAR 0 2
94749: PUSH
94750: LD_INT 101
94752: EQUAL
94753: IFFALSE 94881
// begin case p3 of 1 :
94755: LD_VAR 0 3
94759: PUSH
94760: LD_INT 1
94762: DOUBLE
94763: EQUAL
94764: IFTRUE 94768
94766: GO 94775
94768: POP
// hHackUnlimitedResources ; 2 :
94769: CALL 107020 0 0
94773: GO 94881
94775: LD_INT 2
94777: DOUBLE
94778: EQUAL
94779: IFTRUE 94783
94781: GO 94790
94783: POP
// hHackSetLevel10 ; 3 :
94784: CALL 107153 0 0
94788: GO 94881
94790: LD_INT 3
94792: DOUBLE
94793: EQUAL
94794: IFTRUE 94798
94796: GO 94805
94798: POP
// hHackSetLevel10YourUnits ; 4 :
94799: CALL 107238 0 0
94803: GO 94881
94805: LD_INT 4
94807: DOUBLE
94808: EQUAL
94809: IFTRUE 94813
94811: GO 94820
94813: POP
// hHackInvincible ; 5 :
94814: CALL 107686 0 0
94818: GO 94881
94820: LD_INT 5
94822: DOUBLE
94823: EQUAL
94824: IFTRUE 94828
94826: GO 94835
94828: POP
// hHackInvisible ; 6 :
94829: CALL 107797 0 0
94833: GO 94881
94835: LD_INT 6
94837: DOUBLE
94838: EQUAL
94839: IFTRUE 94843
94841: GO 94850
94843: POP
// hHackChangeYourSide ; 7 :
94844: CALL 107854 0 0
94848: GO 94881
94850: LD_INT 7
94852: DOUBLE
94853: EQUAL
94854: IFTRUE 94858
94856: GO 94865
94858: POP
// hHackChangeUnitSide ; 8 :
94859: CALL 107896 0 0
94863: GO 94881
94865: LD_INT 8
94867: DOUBLE
94868: EQUAL
94869: IFTRUE 94873
94871: GO 94880
94873: POP
// hHackFog ; end ;
94874: CALL 107997 0 0
94878: GO 94881
94880: POP
// end ; if p2 = game_save_mode then
94881: LD_VAR 0 2
94885: PUSH
94886: LD_INT 102
94888: EQUAL
94889: IFFALSE 94944
// begin if p3 = 1 then
94891: LD_VAR 0 3
94895: PUSH
94896: LD_INT 1
94898: EQUAL
94899: IFFALSE 94911
// globalGameSaveCounter := p4 ;
94901: LD_ADDR_EXP 123
94905: PUSH
94906: LD_VAR 0 4
94910: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
94911: LD_VAR 0 3
94915: PUSH
94916: LD_INT 2
94918: EQUAL
94919: PUSH
94920: LD_EXP 123
94924: AND
94925: IFFALSE 94944
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94927: LD_STRING setGameSaveCounter(
94929: PUSH
94930: LD_EXP 123
94934: STR
94935: PUSH
94936: LD_STRING )
94938: STR
94939: PPUSH
94940: CALL_OW 559
// end ; end ;
94944: LD_VAR 0 7
94948: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
94949: LD_INT 0
94951: PPUSH
// streamModeActive := false ;
94952: LD_ADDR_EXP 124
94956: PUSH
94957: LD_INT 0
94959: ST_TO_ADDR
// normalCounter := 36 ;
94960: LD_ADDR_EXP 125
94964: PUSH
94965: LD_INT 36
94967: ST_TO_ADDR
// hardcoreCounter := 18 ;
94968: LD_ADDR_EXP 126
94972: PUSH
94973: LD_INT 18
94975: ST_TO_ADDR
// sRocket := false ;
94976: LD_ADDR_EXP 129
94980: PUSH
94981: LD_INT 0
94983: ST_TO_ADDR
// sSpeed := false ;
94984: LD_ADDR_EXP 128
94988: PUSH
94989: LD_INT 0
94991: ST_TO_ADDR
// sEngine := false ;
94992: LD_ADDR_EXP 130
94996: PUSH
94997: LD_INT 0
94999: ST_TO_ADDR
// sSpec := false ;
95000: LD_ADDR_EXP 127
95004: PUSH
95005: LD_INT 0
95007: ST_TO_ADDR
// sLevel := false ;
95008: LD_ADDR_EXP 131
95012: PUSH
95013: LD_INT 0
95015: ST_TO_ADDR
// sArmoury := false ;
95016: LD_ADDR_EXP 132
95020: PUSH
95021: LD_INT 0
95023: ST_TO_ADDR
// sRadar := false ;
95024: LD_ADDR_EXP 133
95028: PUSH
95029: LD_INT 0
95031: ST_TO_ADDR
// sBunker := false ;
95032: LD_ADDR_EXP 134
95036: PUSH
95037: LD_INT 0
95039: ST_TO_ADDR
// sHack := false ;
95040: LD_ADDR_EXP 135
95044: PUSH
95045: LD_INT 0
95047: ST_TO_ADDR
// sFire := false ;
95048: LD_ADDR_EXP 136
95052: PUSH
95053: LD_INT 0
95055: ST_TO_ADDR
// sRefresh := false ;
95056: LD_ADDR_EXP 137
95060: PUSH
95061: LD_INT 0
95063: ST_TO_ADDR
// sExp := false ;
95064: LD_ADDR_EXP 138
95068: PUSH
95069: LD_INT 0
95071: ST_TO_ADDR
// sDepot := false ;
95072: LD_ADDR_EXP 139
95076: PUSH
95077: LD_INT 0
95079: ST_TO_ADDR
// sFlag := false ;
95080: LD_ADDR_EXP 140
95084: PUSH
95085: LD_INT 0
95087: ST_TO_ADDR
// sKamikadze := false ;
95088: LD_ADDR_EXP 148
95092: PUSH
95093: LD_INT 0
95095: ST_TO_ADDR
// sTroll := false ;
95096: LD_ADDR_EXP 149
95100: PUSH
95101: LD_INT 0
95103: ST_TO_ADDR
// sSlow := false ;
95104: LD_ADDR_EXP 150
95108: PUSH
95109: LD_INT 0
95111: ST_TO_ADDR
// sLack := false ;
95112: LD_ADDR_EXP 151
95116: PUSH
95117: LD_INT 0
95119: ST_TO_ADDR
// sTank := false ;
95120: LD_ADDR_EXP 153
95124: PUSH
95125: LD_INT 0
95127: ST_TO_ADDR
// sRemote := false ;
95128: LD_ADDR_EXP 154
95132: PUSH
95133: LD_INT 0
95135: ST_TO_ADDR
// sPowell := false ;
95136: LD_ADDR_EXP 155
95140: PUSH
95141: LD_INT 0
95143: ST_TO_ADDR
// sTeleport := false ;
95144: LD_ADDR_EXP 158
95148: PUSH
95149: LD_INT 0
95151: ST_TO_ADDR
// sOilTower := false ;
95152: LD_ADDR_EXP 160
95156: PUSH
95157: LD_INT 0
95159: ST_TO_ADDR
// sShovel := false ;
95160: LD_ADDR_EXP 161
95164: PUSH
95165: LD_INT 0
95167: ST_TO_ADDR
// sSheik := false ;
95168: LD_ADDR_EXP 162
95172: PUSH
95173: LD_INT 0
95175: ST_TO_ADDR
// sEarthquake := false ;
95176: LD_ADDR_EXP 164
95180: PUSH
95181: LD_INT 0
95183: ST_TO_ADDR
// sAI := false ;
95184: LD_ADDR_EXP 165
95188: PUSH
95189: LD_INT 0
95191: ST_TO_ADDR
// sCargo := false ;
95192: LD_ADDR_EXP 168
95196: PUSH
95197: LD_INT 0
95199: ST_TO_ADDR
// sDLaser := false ;
95200: LD_ADDR_EXP 169
95204: PUSH
95205: LD_INT 0
95207: ST_TO_ADDR
// sExchange := false ;
95208: LD_ADDR_EXP 170
95212: PUSH
95213: LD_INT 0
95215: ST_TO_ADDR
// sFac := false ;
95216: LD_ADDR_EXP 171
95220: PUSH
95221: LD_INT 0
95223: ST_TO_ADDR
// sPower := false ;
95224: LD_ADDR_EXP 172
95228: PUSH
95229: LD_INT 0
95231: ST_TO_ADDR
// sRandom := false ;
95232: LD_ADDR_EXP 173
95236: PUSH
95237: LD_INT 0
95239: ST_TO_ADDR
// sShield := false ;
95240: LD_ADDR_EXP 174
95244: PUSH
95245: LD_INT 0
95247: ST_TO_ADDR
// sTime := false ;
95248: LD_ADDR_EXP 175
95252: PUSH
95253: LD_INT 0
95255: ST_TO_ADDR
// sTools := false ;
95256: LD_ADDR_EXP 176
95260: PUSH
95261: LD_INT 0
95263: ST_TO_ADDR
// sSold := false ;
95264: LD_ADDR_EXP 141
95268: PUSH
95269: LD_INT 0
95271: ST_TO_ADDR
// sDiff := false ;
95272: LD_ADDR_EXP 142
95276: PUSH
95277: LD_INT 0
95279: ST_TO_ADDR
// sFog := false ;
95280: LD_ADDR_EXP 145
95284: PUSH
95285: LD_INT 0
95287: ST_TO_ADDR
// sReset := false ;
95288: LD_ADDR_EXP 146
95292: PUSH
95293: LD_INT 0
95295: ST_TO_ADDR
// sSun := false ;
95296: LD_ADDR_EXP 147
95300: PUSH
95301: LD_INT 0
95303: ST_TO_ADDR
// sTiger := false ;
95304: LD_ADDR_EXP 143
95308: PUSH
95309: LD_INT 0
95311: ST_TO_ADDR
// sBomb := false ;
95312: LD_ADDR_EXP 144
95316: PUSH
95317: LD_INT 0
95319: ST_TO_ADDR
// sWound := false ;
95320: LD_ADDR_EXP 152
95324: PUSH
95325: LD_INT 0
95327: ST_TO_ADDR
// sBetray := false ;
95328: LD_ADDR_EXP 156
95332: PUSH
95333: LD_INT 0
95335: ST_TO_ADDR
// sContamin := false ;
95336: LD_ADDR_EXP 157
95340: PUSH
95341: LD_INT 0
95343: ST_TO_ADDR
// sOil := false ;
95344: LD_ADDR_EXP 159
95348: PUSH
95349: LD_INT 0
95351: ST_TO_ADDR
// sStu := false ;
95352: LD_ADDR_EXP 163
95356: PUSH
95357: LD_INT 0
95359: ST_TO_ADDR
// sBazooka := false ;
95360: LD_ADDR_EXP 166
95364: PUSH
95365: LD_INT 0
95367: ST_TO_ADDR
// sMortar := false ;
95368: LD_ADDR_EXP 167
95372: PUSH
95373: LD_INT 0
95375: ST_TO_ADDR
// sRanger := false ;
95376: LD_ADDR_EXP 177
95380: PUSH
95381: LD_INT 0
95383: ST_TO_ADDR
// sComputer := false ;
95384: LD_ADDR_EXP 178
95388: PUSH
95389: LD_INT 0
95391: ST_TO_ADDR
// s30 := false ;
95392: LD_ADDR_EXP 179
95396: PUSH
95397: LD_INT 0
95399: ST_TO_ADDR
// s60 := false ;
95400: LD_ADDR_EXP 180
95404: PUSH
95405: LD_INT 0
95407: ST_TO_ADDR
// end ;
95408: LD_VAR 0 1
95412: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
95413: LD_INT 0
95415: PPUSH
95416: PPUSH
95417: PPUSH
95418: PPUSH
95419: PPUSH
95420: PPUSH
95421: PPUSH
// result := [ ] ;
95422: LD_ADDR_VAR 0 2
95426: PUSH
95427: EMPTY
95428: ST_TO_ADDR
// if campaign_id = 1 then
95429: LD_OWVAR 69
95433: PUSH
95434: LD_INT 1
95436: EQUAL
95437: IFFALSE 98603
// begin case mission_number of 1 :
95439: LD_OWVAR 70
95443: PUSH
95444: LD_INT 1
95446: DOUBLE
95447: EQUAL
95448: IFTRUE 95452
95450: GO 95528
95452: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95453: LD_ADDR_VAR 0 2
95457: PUSH
95458: LD_INT 2
95460: PUSH
95461: LD_INT 4
95463: PUSH
95464: LD_INT 11
95466: PUSH
95467: LD_INT 12
95469: PUSH
95470: LD_INT 15
95472: PUSH
95473: LD_INT 16
95475: PUSH
95476: LD_INT 22
95478: PUSH
95479: LD_INT 23
95481: PUSH
95482: LD_INT 26
95484: PUSH
95485: EMPTY
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 101
95498: PUSH
95499: LD_INT 102
95501: PUSH
95502: LD_INT 106
95504: PUSH
95505: LD_INT 116
95507: PUSH
95508: LD_INT 117
95510: PUSH
95511: LD_INT 118
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: ST_TO_ADDR
95526: GO 98601
95528: LD_INT 2
95530: DOUBLE
95531: EQUAL
95532: IFTRUE 95536
95534: GO 95620
95536: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95537: LD_ADDR_VAR 0 2
95541: PUSH
95542: LD_INT 2
95544: PUSH
95545: LD_INT 4
95547: PUSH
95548: LD_INT 11
95550: PUSH
95551: LD_INT 12
95553: PUSH
95554: LD_INT 15
95556: PUSH
95557: LD_INT 16
95559: PUSH
95560: LD_INT 22
95562: PUSH
95563: LD_INT 23
95565: PUSH
95566: LD_INT 26
95568: PUSH
95569: EMPTY
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: LIST
95579: PUSH
95580: LD_INT 101
95582: PUSH
95583: LD_INT 102
95585: PUSH
95586: LD_INT 105
95588: PUSH
95589: LD_INT 106
95591: PUSH
95592: LD_INT 108
95594: PUSH
95595: LD_INT 116
95597: PUSH
95598: LD_INT 117
95600: PUSH
95601: LD_INT 118
95603: PUSH
95604: EMPTY
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: PUSH
95614: EMPTY
95615: LIST
95616: LIST
95617: ST_TO_ADDR
95618: GO 98601
95620: LD_INT 3
95622: DOUBLE
95623: EQUAL
95624: IFTRUE 95628
95626: GO 95716
95628: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95629: LD_ADDR_VAR 0 2
95633: PUSH
95634: LD_INT 2
95636: PUSH
95637: LD_INT 4
95639: PUSH
95640: LD_INT 5
95642: PUSH
95643: LD_INT 11
95645: PUSH
95646: LD_INT 12
95648: PUSH
95649: LD_INT 15
95651: PUSH
95652: LD_INT 16
95654: PUSH
95655: LD_INT 22
95657: PUSH
95658: LD_INT 26
95660: PUSH
95661: LD_INT 36
95663: PUSH
95664: EMPTY
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: PUSH
95676: LD_INT 101
95678: PUSH
95679: LD_INT 102
95681: PUSH
95682: LD_INT 105
95684: PUSH
95685: LD_INT 106
95687: PUSH
95688: LD_INT 108
95690: PUSH
95691: LD_INT 116
95693: PUSH
95694: LD_INT 117
95696: PUSH
95697: LD_INT 118
95699: PUSH
95700: EMPTY
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: PUSH
95710: EMPTY
95711: LIST
95712: LIST
95713: ST_TO_ADDR
95714: GO 98601
95716: LD_INT 4
95718: DOUBLE
95719: EQUAL
95720: IFTRUE 95724
95722: GO 95820
95724: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95725: LD_ADDR_VAR 0 2
95729: PUSH
95730: LD_INT 2
95732: PUSH
95733: LD_INT 4
95735: PUSH
95736: LD_INT 5
95738: PUSH
95739: LD_INT 8
95741: PUSH
95742: LD_INT 11
95744: PUSH
95745: LD_INT 12
95747: PUSH
95748: LD_INT 15
95750: PUSH
95751: LD_INT 16
95753: PUSH
95754: LD_INT 22
95756: PUSH
95757: LD_INT 23
95759: PUSH
95760: LD_INT 26
95762: PUSH
95763: LD_INT 36
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: PUSH
95780: LD_INT 101
95782: PUSH
95783: LD_INT 102
95785: PUSH
95786: LD_INT 105
95788: PUSH
95789: LD_INT 106
95791: PUSH
95792: LD_INT 108
95794: PUSH
95795: LD_INT 116
95797: PUSH
95798: LD_INT 117
95800: PUSH
95801: LD_INT 118
95803: PUSH
95804: EMPTY
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: PUSH
95814: EMPTY
95815: LIST
95816: LIST
95817: ST_TO_ADDR
95818: GO 98601
95820: LD_INT 5
95822: DOUBLE
95823: EQUAL
95824: IFTRUE 95828
95826: GO 95940
95828: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95829: LD_ADDR_VAR 0 2
95833: PUSH
95834: LD_INT 2
95836: PUSH
95837: LD_INT 4
95839: PUSH
95840: LD_INT 5
95842: PUSH
95843: LD_INT 6
95845: PUSH
95846: LD_INT 8
95848: PUSH
95849: LD_INT 11
95851: PUSH
95852: LD_INT 12
95854: PUSH
95855: LD_INT 15
95857: PUSH
95858: LD_INT 16
95860: PUSH
95861: LD_INT 22
95863: PUSH
95864: LD_INT 23
95866: PUSH
95867: LD_INT 25
95869: PUSH
95870: LD_INT 26
95872: PUSH
95873: LD_INT 36
95875: PUSH
95876: EMPTY
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: PUSH
95892: LD_INT 101
95894: PUSH
95895: LD_INT 102
95897: PUSH
95898: LD_INT 105
95900: PUSH
95901: LD_INT 106
95903: PUSH
95904: LD_INT 108
95906: PUSH
95907: LD_INT 109
95909: PUSH
95910: LD_INT 112
95912: PUSH
95913: LD_INT 116
95915: PUSH
95916: LD_INT 117
95918: PUSH
95919: LD_INT 118
95921: PUSH
95922: EMPTY
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: ST_TO_ADDR
95938: GO 98601
95940: LD_INT 6
95942: DOUBLE
95943: EQUAL
95944: IFTRUE 95948
95946: GO 96080
95948: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
95949: LD_ADDR_VAR 0 2
95953: PUSH
95954: LD_INT 2
95956: PUSH
95957: LD_INT 4
95959: PUSH
95960: LD_INT 5
95962: PUSH
95963: LD_INT 6
95965: PUSH
95966: LD_INT 8
95968: PUSH
95969: LD_INT 11
95971: PUSH
95972: LD_INT 12
95974: PUSH
95975: LD_INT 15
95977: PUSH
95978: LD_INT 16
95980: PUSH
95981: LD_INT 20
95983: PUSH
95984: LD_INT 21
95986: PUSH
95987: LD_INT 22
95989: PUSH
95990: LD_INT 23
95992: PUSH
95993: LD_INT 25
95995: PUSH
95996: LD_INT 26
95998: PUSH
95999: LD_INT 30
96001: PUSH
96002: LD_INT 31
96004: PUSH
96005: LD_INT 32
96007: PUSH
96008: LD_INT 36
96010: PUSH
96011: EMPTY
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: LIST
96029: LIST
96030: LIST
96031: PUSH
96032: LD_INT 101
96034: PUSH
96035: LD_INT 102
96037: PUSH
96038: LD_INT 105
96040: PUSH
96041: LD_INT 106
96043: PUSH
96044: LD_INT 108
96046: PUSH
96047: LD_INT 109
96049: PUSH
96050: LD_INT 112
96052: PUSH
96053: LD_INT 116
96055: PUSH
96056: LD_INT 117
96058: PUSH
96059: LD_INT 118
96061: PUSH
96062: EMPTY
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: PUSH
96074: EMPTY
96075: LIST
96076: LIST
96077: ST_TO_ADDR
96078: GO 98601
96080: LD_INT 7
96082: DOUBLE
96083: EQUAL
96084: IFTRUE 96088
96086: GO 96200
96088: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
96089: LD_ADDR_VAR 0 2
96093: PUSH
96094: LD_INT 2
96096: PUSH
96097: LD_INT 4
96099: PUSH
96100: LD_INT 5
96102: PUSH
96103: LD_INT 7
96105: PUSH
96106: LD_INT 11
96108: PUSH
96109: LD_INT 12
96111: PUSH
96112: LD_INT 15
96114: PUSH
96115: LD_INT 16
96117: PUSH
96118: LD_INT 20
96120: PUSH
96121: LD_INT 21
96123: PUSH
96124: LD_INT 22
96126: PUSH
96127: LD_INT 23
96129: PUSH
96130: LD_INT 25
96132: PUSH
96133: LD_INT 26
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 101
96154: PUSH
96155: LD_INT 102
96157: PUSH
96158: LD_INT 103
96160: PUSH
96161: LD_INT 105
96163: PUSH
96164: LD_INT 106
96166: PUSH
96167: LD_INT 108
96169: PUSH
96170: LD_INT 112
96172: PUSH
96173: LD_INT 116
96175: PUSH
96176: LD_INT 117
96178: PUSH
96179: LD_INT 118
96181: PUSH
96182: EMPTY
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: PUSH
96194: EMPTY
96195: LIST
96196: LIST
96197: ST_TO_ADDR
96198: GO 98601
96200: LD_INT 8
96202: DOUBLE
96203: EQUAL
96204: IFTRUE 96208
96206: GO 96348
96208: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
96209: LD_ADDR_VAR 0 2
96213: PUSH
96214: LD_INT 2
96216: PUSH
96217: LD_INT 4
96219: PUSH
96220: LD_INT 5
96222: PUSH
96223: LD_INT 6
96225: PUSH
96226: LD_INT 7
96228: PUSH
96229: LD_INT 8
96231: PUSH
96232: LD_INT 11
96234: PUSH
96235: LD_INT 12
96237: PUSH
96238: LD_INT 15
96240: PUSH
96241: LD_INT 16
96243: PUSH
96244: LD_INT 20
96246: PUSH
96247: LD_INT 21
96249: PUSH
96250: LD_INT 22
96252: PUSH
96253: LD_INT 23
96255: PUSH
96256: LD_INT 25
96258: PUSH
96259: LD_INT 26
96261: PUSH
96262: LD_INT 30
96264: PUSH
96265: LD_INT 31
96267: PUSH
96268: LD_INT 32
96270: PUSH
96271: LD_INT 36
96273: PUSH
96274: EMPTY
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: PUSH
96296: LD_INT 101
96298: PUSH
96299: LD_INT 102
96301: PUSH
96302: LD_INT 103
96304: PUSH
96305: LD_INT 105
96307: PUSH
96308: LD_INT 106
96310: PUSH
96311: LD_INT 108
96313: PUSH
96314: LD_INT 109
96316: PUSH
96317: LD_INT 112
96319: PUSH
96320: LD_INT 116
96322: PUSH
96323: LD_INT 117
96325: PUSH
96326: LD_INT 118
96328: PUSH
96329: EMPTY
96330: LIST
96331: LIST
96332: LIST
96333: LIST
96334: LIST
96335: LIST
96336: LIST
96337: LIST
96338: LIST
96339: LIST
96340: LIST
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: ST_TO_ADDR
96346: GO 98601
96348: LD_INT 9
96350: DOUBLE
96351: EQUAL
96352: IFTRUE 96356
96354: GO 96504
96356: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96357: LD_ADDR_VAR 0 2
96361: PUSH
96362: LD_INT 2
96364: PUSH
96365: LD_INT 4
96367: PUSH
96368: LD_INT 5
96370: PUSH
96371: LD_INT 6
96373: PUSH
96374: LD_INT 7
96376: PUSH
96377: LD_INT 8
96379: PUSH
96380: LD_INT 11
96382: PUSH
96383: LD_INT 12
96385: PUSH
96386: LD_INT 15
96388: PUSH
96389: LD_INT 16
96391: PUSH
96392: LD_INT 20
96394: PUSH
96395: LD_INT 21
96397: PUSH
96398: LD_INT 22
96400: PUSH
96401: LD_INT 23
96403: PUSH
96404: LD_INT 25
96406: PUSH
96407: LD_INT 26
96409: PUSH
96410: LD_INT 28
96412: PUSH
96413: LD_INT 30
96415: PUSH
96416: LD_INT 31
96418: PUSH
96419: LD_INT 32
96421: PUSH
96422: LD_INT 36
96424: PUSH
96425: EMPTY
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: PUSH
96448: LD_INT 101
96450: PUSH
96451: LD_INT 102
96453: PUSH
96454: LD_INT 103
96456: PUSH
96457: LD_INT 105
96459: PUSH
96460: LD_INT 106
96462: PUSH
96463: LD_INT 108
96465: PUSH
96466: LD_INT 109
96468: PUSH
96469: LD_INT 112
96471: PUSH
96472: LD_INT 114
96474: PUSH
96475: LD_INT 116
96477: PUSH
96478: LD_INT 117
96480: PUSH
96481: LD_INT 118
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: PUSH
96498: EMPTY
96499: LIST
96500: LIST
96501: ST_TO_ADDR
96502: GO 98601
96504: LD_INT 10
96506: DOUBLE
96507: EQUAL
96508: IFTRUE 96512
96510: GO 96708
96512: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96513: LD_ADDR_VAR 0 2
96517: PUSH
96518: LD_INT 2
96520: PUSH
96521: LD_INT 4
96523: PUSH
96524: LD_INT 5
96526: PUSH
96527: LD_INT 6
96529: PUSH
96530: LD_INT 7
96532: PUSH
96533: LD_INT 8
96535: PUSH
96536: LD_INT 9
96538: PUSH
96539: LD_INT 10
96541: PUSH
96542: LD_INT 11
96544: PUSH
96545: LD_INT 12
96547: PUSH
96548: LD_INT 13
96550: PUSH
96551: LD_INT 14
96553: PUSH
96554: LD_INT 15
96556: PUSH
96557: LD_INT 16
96559: PUSH
96560: LD_INT 17
96562: PUSH
96563: LD_INT 18
96565: PUSH
96566: LD_INT 19
96568: PUSH
96569: LD_INT 20
96571: PUSH
96572: LD_INT 21
96574: PUSH
96575: LD_INT 22
96577: PUSH
96578: LD_INT 23
96580: PUSH
96581: LD_INT 24
96583: PUSH
96584: LD_INT 25
96586: PUSH
96587: LD_INT 26
96589: PUSH
96590: LD_INT 28
96592: PUSH
96593: LD_INT 30
96595: PUSH
96596: LD_INT 31
96598: PUSH
96599: LD_INT 32
96601: PUSH
96602: LD_INT 36
96604: PUSH
96605: EMPTY
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: PUSH
96636: LD_INT 101
96638: PUSH
96639: LD_INT 102
96641: PUSH
96642: LD_INT 103
96644: PUSH
96645: LD_INT 104
96647: PUSH
96648: LD_INT 105
96650: PUSH
96651: LD_INT 106
96653: PUSH
96654: LD_INT 107
96656: PUSH
96657: LD_INT 108
96659: PUSH
96660: LD_INT 109
96662: PUSH
96663: LD_INT 110
96665: PUSH
96666: LD_INT 111
96668: PUSH
96669: LD_INT 112
96671: PUSH
96672: LD_INT 114
96674: PUSH
96675: LD_INT 116
96677: PUSH
96678: LD_INT 117
96680: PUSH
96681: LD_INT 118
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: PUSH
96702: EMPTY
96703: LIST
96704: LIST
96705: ST_TO_ADDR
96706: GO 98601
96708: LD_INT 11
96710: DOUBLE
96711: EQUAL
96712: IFTRUE 96716
96714: GO 96920
96716: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96717: LD_ADDR_VAR 0 2
96721: PUSH
96722: LD_INT 2
96724: PUSH
96725: LD_INT 3
96727: PUSH
96728: LD_INT 4
96730: PUSH
96731: LD_INT 5
96733: PUSH
96734: LD_INT 6
96736: PUSH
96737: LD_INT 7
96739: PUSH
96740: LD_INT 8
96742: PUSH
96743: LD_INT 9
96745: PUSH
96746: LD_INT 10
96748: PUSH
96749: LD_INT 11
96751: PUSH
96752: LD_INT 12
96754: PUSH
96755: LD_INT 13
96757: PUSH
96758: LD_INT 14
96760: PUSH
96761: LD_INT 15
96763: PUSH
96764: LD_INT 16
96766: PUSH
96767: LD_INT 17
96769: PUSH
96770: LD_INT 18
96772: PUSH
96773: LD_INT 19
96775: PUSH
96776: LD_INT 20
96778: PUSH
96779: LD_INT 21
96781: PUSH
96782: LD_INT 22
96784: PUSH
96785: LD_INT 23
96787: PUSH
96788: LD_INT 24
96790: PUSH
96791: LD_INT 25
96793: PUSH
96794: LD_INT 26
96796: PUSH
96797: LD_INT 28
96799: PUSH
96800: LD_INT 30
96802: PUSH
96803: LD_INT 31
96805: PUSH
96806: LD_INT 32
96808: PUSH
96809: LD_INT 34
96811: PUSH
96812: LD_INT 36
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: PUSH
96848: LD_INT 101
96850: PUSH
96851: LD_INT 102
96853: PUSH
96854: LD_INT 103
96856: PUSH
96857: LD_INT 104
96859: PUSH
96860: LD_INT 105
96862: PUSH
96863: LD_INT 106
96865: PUSH
96866: LD_INT 107
96868: PUSH
96869: LD_INT 108
96871: PUSH
96872: LD_INT 109
96874: PUSH
96875: LD_INT 110
96877: PUSH
96878: LD_INT 111
96880: PUSH
96881: LD_INT 112
96883: PUSH
96884: LD_INT 114
96886: PUSH
96887: LD_INT 116
96889: PUSH
96890: LD_INT 117
96892: PUSH
96893: LD_INT 118
96895: PUSH
96896: EMPTY
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: ST_TO_ADDR
96918: GO 98601
96920: LD_INT 12
96922: DOUBLE
96923: EQUAL
96924: IFTRUE 96928
96926: GO 97148
96928: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
96929: LD_ADDR_VAR 0 2
96933: PUSH
96934: LD_INT 1
96936: PUSH
96937: LD_INT 2
96939: PUSH
96940: LD_INT 3
96942: PUSH
96943: LD_INT 4
96945: PUSH
96946: LD_INT 5
96948: PUSH
96949: LD_INT 6
96951: PUSH
96952: LD_INT 7
96954: PUSH
96955: LD_INT 8
96957: PUSH
96958: LD_INT 9
96960: PUSH
96961: LD_INT 10
96963: PUSH
96964: LD_INT 11
96966: PUSH
96967: LD_INT 12
96969: PUSH
96970: LD_INT 13
96972: PUSH
96973: LD_INT 14
96975: PUSH
96976: LD_INT 15
96978: PUSH
96979: LD_INT 16
96981: PUSH
96982: LD_INT 17
96984: PUSH
96985: LD_INT 18
96987: PUSH
96988: LD_INT 19
96990: PUSH
96991: LD_INT 20
96993: PUSH
96994: LD_INT 21
96996: PUSH
96997: LD_INT 22
96999: PUSH
97000: LD_INT 23
97002: PUSH
97003: LD_INT 24
97005: PUSH
97006: LD_INT 25
97008: PUSH
97009: LD_INT 26
97011: PUSH
97012: LD_INT 27
97014: PUSH
97015: LD_INT 28
97017: PUSH
97018: LD_INT 30
97020: PUSH
97021: LD_INT 31
97023: PUSH
97024: LD_INT 32
97026: PUSH
97027: LD_INT 33
97029: PUSH
97030: LD_INT 34
97032: PUSH
97033: LD_INT 36
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: LIST
97053: LIST
97054: LIST
97055: LIST
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: PUSH
97072: LD_INT 101
97074: PUSH
97075: LD_INT 102
97077: PUSH
97078: LD_INT 103
97080: PUSH
97081: LD_INT 104
97083: PUSH
97084: LD_INT 105
97086: PUSH
97087: LD_INT 106
97089: PUSH
97090: LD_INT 107
97092: PUSH
97093: LD_INT 108
97095: PUSH
97096: LD_INT 109
97098: PUSH
97099: LD_INT 110
97101: PUSH
97102: LD_INT 111
97104: PUSH
97105: LD_INT 112
97107: PUSH
97108: LD_INT 113
97110: PUSH
97111: LD_INT 114
97113: PUSH
97114: LD_INT 116
97116: PUSH
97117: LD_INT 117
97119: PUSH
97120: LD_INT 118
97122: PUSH
97123: EMPTY
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: PUSH
97142: EMPTY
97143: LIST
97144: LIST
97145: ST_TO_ADDR
97146: GO 98601
97148: LD_INT 13
97150: DOUBLE
97151: EQUAL
97152: IFTRUE 97156
97154: GO 97364
97156: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97157: LD_ADDR_VAR 0 2
97161: PUSH
97162: LD_INT 1
97164: PUSH
97165: LD_INT 2
97167: PUSH
97168: LD_INT 3
97170: PUSH
97171: LD_INT 4
97173: PUSH
97174: LD_INT 5
97176: PUSH
97177: LD_INT 8
97179: PUSH
97180: LD_INT 9
97182: PUSH
97183: LD_INT 10
97185: PUSH
97186: LD_INT 11
97188: PUSH
97189: LD_INT 12
97191: PUSH
97192: LD_INT 14
97194: PUSH
97195: LD_INT 15
97197: PUSH
97198: LD_INT 16
97200: PUSH
97201: LD_INT 17
97203: PUSH
97204: LD_INT 18
97206: PUSH
97207: LD_INT 19
97209: PUSH
97210: LD_INT 20
97212: PUSH
97213: LD_INT 21
97215: PUSH
97216: LD_INT 22
97218: PUSH
97219: LD_INT 23
97221: PUSH
97222: LD_INT 24
97224: PUSH
97225: LD_INT 25
97227: PUSH
97228: LD_INT 26
97230: PUSH
97231: LD_INT 27
97233: PUSH
97234: LD_INT 28
97236: PUSH
97237: LD_INT 30
97239: PUSH
97240: LD_INT 31
97242: PUSH
97243: LD_INT 32
97245: PUSH
97246: LD_INT 33
97248: PUSH
97249: LD_INT 34
97251: PUSH
97252: LD_INT 36
97254: PUSH
97255: EMPTY
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: LIST
97279: LIST
97280: LIST
97281: LIST
97282: LIST
97283: LIST
97284: LIST
97285: LIST
97286: LIST
97287: PUSH
97288: LD_INT 101
97290: PUSH
97291: LD_INT 102
97293: PUSH
97294: LD_INT 103
97296: PUSH
97297: LD_INT 104
97299: PUSH
97300: LD_INT 105
97302: PUSH
97303: LD_INT 106
97305: PUSH
97306: LD_INT 107
97308: PUSH
97309: LD_INT 108
97311: PUSH
97312: LD_INT 109
97314: PUSH
97315: LD_INT 110
97317: PUSH
97318: LD_INT 111
97320: PUSH
97321: LD_INT 112
97323: PUSH
97324: LD_INT 113
97326: PUSH
97327: LD_INT 114
97329: PUSH
97330: LD_INT 116
97332: PUSH
97333: LD_INT 117
97335: PUSH
97336: LD_INT 118
97338: PUSH
97339: EMPTY
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: PUSH
97358: EMPTY
97359: LIST
97360: LIST
97361: ST_TO_ADDR
97362: GO 98601
97364: LD_INT 14
97366: DOUBLE
97367: EQUAL
97368: IFTRUE 97372
97370: GO 97596
97372: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97373: LD_ADDR_VAR 0 2
97377: PUSH
97378: LD_INT 1
97380: PUSH
97381: LD_INT 2
97383: PUSH
97384: LD_INT 3
97386: PUSH
97387: LD_INT 4
97389: PUSH
97390: LD_INT 5
97392: PUSH
97393: LD_INT 6
97395: PUSH
97396: LD_INT 7
97398: PUSH
97399: LD_INT 8
97401: PUSH
97402: LD_INT 9
97404: PUSH
97405: LD_INT 10
97407: PUSH
97408: LD_INT 11
97410: PUSH
97411: LD_INT 12
97413: PUSH
97414: LD_INT 13
97416: PUSH
97417: LD_INT 14
97419: PUSH
97420: LD_INT 15
97422: PUSH
97423: LD_INT 16
97425: PUSH
97426: LD_INT 17
97428: PUSH
97429: LD_INT 18
97431: PUSH
97432: LD_INT 19
97434: PUSH
97435: LD_INT 20
97437: PUSH
97438: LD_INT 21
97440: PUSH
97441: LD_INT 22
97443: PUSH
97444: LD_INT 23
97446: PUSH
97447: LD_INT 24
97449: PUSH
97450: LD_INT 25
97452: PUSH
97453: LD_INT 26
97455: PUSH
97456: LD_INT 27
97458: PUSH
97459: LD_INT 28
97461: PUSH
97462: LD_INT 29
97464: PUSH
97465: LD_INT 30
97467: PUSH
97468: LD_INT 31
97470: PUSH
97471: LD_INT 32
97473: PUSH
97474: LD_INT 33
97476: PUSH
97477: LD_INT 34
97479: PUSH
97480: LD_INT 36
97482: PUSH
97483: EMPTY
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: PUSH
97520: LD_INT 101
97522: PUSH
97523: LD_INT 102
97525: PUSH
97526: LD_INT 103
97528: PUSH
97529: LD_INT 104
97531: PUSH
97532: LD_INT 105
97534: PUSH
97535: LD_INT 106
97537: PUSH
97538: LD_INT 107
97540: PUSH
97541: LD_INT 108
97543: PUSH
97544: LD_INT 109
97546: PUSH
97547: LD_INT 110
97549: PUSH
97550: LD_INT 111
97552: PUSH
97553: LD_INT 112
97555: PUSH
97556: LD_INT 113
97558: PUSH
97559: LD_INT 114
97561: PUSH
97562: LD_INT 116
97564: PUSH
97565: LD_INT 117
97567: PUSH
97568: LD_INT 118
97570: PUSH
97571: EMPTY
97572: LIST
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: PUSH
97590: EMPTY
97591: LIST
97592: LIST
97593: ST_TO_ADDR
97594: GO 98601
97596: LD_INT 15
97598: DOUBLE
97599: EQUAL
97600: IFTRUE 97604
97602: GO 97828
97604: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97605: LD_ADDR_VAR 0 2
97609: PUSH
97610: LD_INT 1
97612: PUSH
97613: LD_INT 2
97615: PUSH
97616: LD_INT 3
97618: PUSH
97619: LD_INT 4
97621: PUSH
97622: LD_INT 5
97624: PUSH
97625: LD_INT 6
97627: PUSH
97628: LD_INT 7
97630: PUSH
97631: LD_INT 8
97633: PUSH
97634: LD_INT 9
97636: PUSH
97637: LD_INT 10
97639: PUSH
97640: LD_INT 11
97642: PUSH
97643: LD_INT 12
97645: PUSH
97646: LD_INT 13
97648: PUSH
97649: LD_INT 14
97651: PUSH
97652: LD_INT 15
97654: PUSH
97655: LD_INT 16
97657: PUSH
97658: LD_INT 17
97660: PUSH
97661: LD_INT 18
97663: PUSH
97664: LD_INT 19
97666: PUSH
97667: LD_INT 20
97669: PUSH
97670: LD_INT 21
97672: PUSH
97673: LD_INT 22
97675: PUSH
97676: LD_INT 23
97678: PUSH
97679: LD_INT 24
97681: PUSH
97682: LD_INT 25
97684: PUSH
97685: LD_INT 26
97687: PUSH
97688: LD_INT 27
97690: PUSH
97691: LD_INT 28
97693: PUSH
97694: LD_INT 29
97696: PUSH
97697: LD_INT 30
97699: PUSH
97700: LD_INT 31
97702: PUSH
97703: LD_INT 32
97705: PUSH
97706: LD_INT 33
97708: PUSH
97709: LD_INT 34
97711: PUSH
97712: LD_INT 36
97714: PUSH
97715: EMPTY
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: PUSH
97752: LD_INT 101
97754: PUSH
97755: LD_INT 102
97757: PUSH
97758: LD_INT 103
97760: PUSH
97761: LD_INT 104
97763: PUSH
97764: LD_INT 105
97766: PUSH
97767: LD_INT 106
97769: PUSH
97770: LD_INT 107
97772: PUSH
97773: LD_INT 108
97775: PUSH
97776: LD_INT 109
97778: PUSH
97779: LD_INT 110
97781: PUSH
97782: LD_INT 111
97784: PUSH
97785: LD_INT 112
97787: PUSH
97788: LD_INT 113
97790: PUSH
97791: LD_INT 114
97793: PUSH
97794: LD_INT 116
97796: PUSH
97797: LD_INT 117
97799: PUSH
97800: LD_INT 118
97802: PUSH
97803: EMPTY
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: PUSH
97822: EMPTY
97823: LIST
97824: LIST
97825: ST_TO_ADDR
97826: GO 98601
97828: LD_INT 16
97830: DOUBLE
97831: EQUAL
97832: IFTRUE 97836
97834: GO 97972
97836: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97837: LD_ADDR_VAR 0 2
97841: PUSH
97842: LD_INT 2
97844: PUSH
97845: LD_INT 4
97847: PUSH
97848: LD_INT 5
97850: PUSH
97851: LD_INT 7
97853: PUSH
97854: LD_INT 11
97856: PUSH
97857: LD_INT 12
97859: PUSH
97860: LD_INT 15
97862: PUSH
97863: LD_INT 16
97865: PUSH
97866: LD_INT 20
97868: PUSH
97869: LD_INT 21
97871: PUSH
97872: LD_INT 22
97874: PUSH
97875: LD_INT 23
97877: PUSH
97878: LD_INT 25
97880: PUSH
97881: LD_INT 26
97883: PUSH
97884: LD_INT 30
97886: PUSH
97887: LD_INT 31
97889: PUSH
97890: LD_INT 32
97892: PUSH
97893: LD_INT 33
97895: PUSH
97896: LD_INT 34
97898: PUSH
97899: EMPTY
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: PUSH
97920: LD_INT 101
97922: PUSH
97923: LD_INT 102
97925: PUSH
97926: LD_INT 103
97928: PUSH
97929: LD_INT 106
97931: PUSH
97932: LD_INT 108
97934: PUSH
97935: LD_INT 112
97937: PUSH
97938: LD_INT 113
97940: PUSH
97941: LD_INT 114
97943: PUSH
97944: LD_INT 116
97946: PUSH
97947: LD_INT 117
97949: PUSH
97950: LD_INT 118
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: LIST
97957: LIST
97958: LIST
97959: LIST
97960: LIST
97961: LIST
97962: LIST
97963: LIST
97964: LIST
97965: PUSH
97966: EMPTY
97967: LIST
97968: LIST
97969: ST_TO_ADDR
97970: GO 98601
97972: LD_INT 17
97974: DOUBLE
97975: EQUAL
97976: IFTRUE 97980
97978: GO 98204
97980: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97981: LD_ADDR_VAR 0 2
97985: PUSH
97986: LD_INT 1
97988: PUSH
97989: LD_INT 2
97991: PUSH
97992: LD_INT 3
97994: PUSH
97995: LD_INT 4
97997: PUSH
97998: LD_INT 5
98000: PUSH
98001: LD_INT 6
98003: PUSH
98004: LD_INT 7
98006: PUSH
98007: LD_INT 8
98009: PUSH
98010: LD_INT 9
98012: PUSH
98013: LD_INT 10
98015: PUSH
98016: LD_INT 11
98018: PUSH
98019: LD_INT 12
98021: PUSH
98022: LD_INT 13
98024: PUSH
98025: LD_INT 14
98027: PUSH
98028: LD_INT 15
98030: PUSH
98031: LD_INT 16
98033: PUSH
98034: LD_INT 17
98036: PUSH
98037: LD_INT 18
98039: PUSH
98040: LD_INT 19
98042: PUSH
98043: LD_INT 20
98045: PUSH
98046: LD_INT 21
98048: PUSH
98049: LD_INT 22
98051: PUSH
98052: LD_INT 23
98054: PUSH
98055: LD_INT 24
98057: PUSH
98058: LD_INT 25
98060: PUSH
98061: LD_INT 26
98063: PUSH
98064: LD_INT 27
98066: PUSH
98067: LD_INT 28
98069: PUSH
98070: LD_INT 29
98072: PUSH
98073: LD_INT 30
98075: PUSH
98076: LD_INT 31
98078: PUSH
98079: LD_INT 32
98081: PUSH
98082: LD_INT 33
98084: PUSH
98085: LD_INT 34
98087: PUSH
98088: LD_INT 36
98090: PUSH
98091: EMPTY
98092: LIST
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: PUSH
98128: LD_INT 101
98130: PUSH
98131: LD_INT 102
98133: PUSH
98134: LD_INT 103
98136: PUSH
98137: LD_INT 104
98139: PUSH
98140: LD_INT 105
98142: PUSH
98143: LD_INT 106
98145: PUSH
98146: LD_INT 107
98148: PUSH
98149: LD_INT 108
98151: PUSH
98152: LD_INT 109
98154: PUSH
98155: LD_INT 110
98157: PUSH
98158: LD_INT 111
98160: PUSH
98161: LD_INT 112
98163: PUSH
98164: LD_INT 113
98166: PUSH
98167: LD_INT 114
98169: PUSH
98170: LD_INT 116
98172: PUSH
98173: LD_INT 117
98175: PUSH
98176: LD_INT 118
98178: PUSH
98179: EMPTY
98180: LIST
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: PUSH
98198: EMPTY
98199: LIST
98200: LIST
98201: ST_TO_ADDR
98202: GO 98601
98204: LD_INT 18
98206: DOUBLE
98207: EQUAL
98208: IFTRUE 98212
98210: GO 98360
98212: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
98213: LD_ADDR_VAR 0 2
98217: PUSH
98218: LD_INT 2
98220: PUSH
98221: LD_INT 4
98223: PUSH
98224: LD_INT 5
98226: PUSH
98227: LD_INT 7
98229: PUSH
98230: LD_INT 11
98232: PUSH
98233: LD_INT 12
98235: PUSH
98236: LD_INT 15
98238: PUSH
98239: LD_INT 16
98241: PUSH
98242: LD_INT 20
98244: PUSH
98245: LD_INT 21
98247: PUSH
98248: LD_INT 22
98250: PUSH
98251: LD_INT 23
98253: PUSH
98254: LD_INT 25
98256: PUSH
98257: LD_INT 26
98259: PUSH
98260: LD_INT 30
98262: PUSH
98263: LD_INT 31
98265: PUSH
98266: LD_INT 32
98268: PUSH
98269: LD_INT 33
98271: PUSH
98272: LD_INT 34
98274: PUSH
98275: LD_INT 35
98277: PUSH
98278: LD_INT 36
98280: PUSH
98281: EMPTY
98282: LIST
98283: LIST
98284: LIST
98285: LIST
98286: LIST
98287: LIST
98288: LIST
98289: LIST
98290: LIST
98291: LIST
98292: LIST
98293: LIST
98294: LIST
98295: LIST
98296: LIST
98297: LIST
98298: LIST
98299: LIST
98300: LIST
98301: LIST
98302: LIST
98303: PUSH
98304: LD_INT 101
98306: PUSH
98307: LD_INT 102
98309: PUSH
98310: LD_INT 103
98312: PUSH
98313: LD_INT 106
98315: PUSH
98316: LD_INT 108
98318: PUSH
98319: LD_INT 112
98321: PUSH
98322: LD_INT 113
98324: PUSH
98325: LD_INT 114
98327: PUSH
98328: LD_INT 115
98330: PUSH
98331: LD_INT 116
98333: PUSH
98334: LD_INT 117
98336: PUSH
98337: LD_INT 118
98339: PUSH
98340: EMPTY
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: PUSH
98354: EMPTY
98355: LIST
98356: LIST
98357: ST_TO_ADDR
98358: GO 98601
98360: LD_INT 19
98362: DOUBLE
98363: EQUAL
98364: IFTRUE 98368
98366: GO 98600
98368: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98369: LD_ADDR_VAR 0 2
98373: PUSH
98374: LD_INT 1
98376: PUSH
98377: LD_INT 2
98379: PUSH
98380: LD_INT 3
98382: PUSH
98383: LD_INT 4
98385: PUSH
98386: LD_INT 5
98388: PUSH
98389: LD_INT 6
98391: PUSH
98392: LD_INT 7
98394: PUSH
98395: LD_INT 8
98397: PUSH
98398: LD_INT 9
98400: PUSH
98401: LD_INT 10
98403: PUSH
98404: LD_INT 11
98406: PUSH
98407: LD_INT 12
98409: PUSH
98410: LD_INT 13
98412: PUSH
98413: LD_INT 14
98415: PUSH
98416: LD_INT 15
98418: PUSH
98419: LD_INT 16
98421: PUSH
98422: LD_INT 17
98424: PUSH
98425: LD_INT 18
98427: PUSH
98428: LD_INT 19
98430: PUSH
98431: LD_INT 20
98433: PUSH
98434: LD_INT 21
98436: PUSH
98437: LD_INT 22
98439: PUSH
98440: LD_INT 23
98442: PUSH
98443: LD_INT 24
98445: PUSH
98446: LD_INT 25
98448: PUSH
98449: LD_INT 26
98451: PUSH
98452: LD_INT 27
98454: PUSH
98455: LD_INT 28
98457: PUSH
98458: LD_INT 29
98460: PUSH
98461: LD_INT 30
98463: PUSH
98464: LD_INT 31
98466: PUSH
98467: LD_INT 32
98469: PUSH
98470: LD_INT 33
98472: PUSH
98473: LD_INT 34
98475: PUSH
98476: LD_INT 35
98478: PUSH
98479: LD_INT 36
98481: PUSH
98482: EMPTY
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: LIST
98489: LIST
98490: LIST
98491: LIST
98492: LIST
98493: LIST
98494: LIST
98495: LIST
98496: LIST
98497: LIST
98498: LIST
98499: LIST
98500: LIST
98501: LIST
98502: LIST
98503: LIST
98504: LIST
98505: LIST
98506: LIST
98507: LIST
98508: LIST
98509: LIST
98510: LIST
98511: LIST
98512: LIST
98513: LIST
98514: LIST
98515: LIST
98516: LIST
98517: LIST
98518: LIST
98519: PUSH
98520: LD_INT 101
98522: PUSH
98523: LD_INT 102
98525: PUSH
98526: LD_INT 103
98528: PUSH
98529: LD_INT 104
98531: PUSH
98532: LD_INT 105
98534: PUSH
98535: LD_INT 106
98537: PUSH
98538: LD_INT 107
98540: PUSH
98541: LD_INT 108
98543: PUSH
98544: LD_INT 109
98546: PUSH
98547: LD_INT 110
98549: PUSH
98550: LD_INT 111
98552: PUSH
98553: LD_INT 112
98555: PUSH
98556: LD_INT 113
98558: PUSH
98559: LD_INT 114
98561: PUSH
98562: LD_INT 115
98564: PUSH
98565: LD_INT 116
98567: PUSH
98568: LD_INT 117
98570: PUSH
98571: LD_INT 118
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: LIST
98586: LIST
98587: LIST
98588: LIST
98589: LIST
98590: LIST
98591: LIST
98592: LIST
98593: PUSH
98594: EMPTY
98595: LIST
98596: LIST
98597: ST_TO_ADDR
98598: GO 98601
98600: POP
// end else
98601: GO 98832
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98603: LD_ADDR_VAR 0 2
98607: PUSH
98608: LD_INT 1
98610: PUSH
98611: LD_INT 2
98613: PUSH
98614: LD_INT 3
98616: PUSH
98617: LD_INT 4
98619: PUSH
98620: LD_INT 5
98622: PUSH
98623: LD_INT 6
98625: PUSH
98626: LD_INT 7
98628: PUSH
98629: LD_INT 8
98631: PUSH
98632: LD_INT 9
98634: PUSH
98635: LD_INT 10
98637: PUSH
98638: LD_INT 11
98640: PUSH
98641: LD_INT 12
98643: PUSH
98644: LD_INT 13
98646: PUSH
98647: LD_INT 14
98649: PUSH
98650: LD_INT 15
98652: PUSH
98653: LD_INT 16
98655: PUSH
98656: LD_INT 17
98658: PUSH
98659: LD_INT 18
98661: PUSH
98662: LD_INT 19
98664: PUSH
98665: LD_INT 20
98667: PUSH
98668: LD_INT 21
98670: PUSH
98671: LD_INT 22
98673: PUSH
98674: LD_INT 23
98676: PUSH
98677: LD_INT 24
98679: PUSH
98680: LD_INT 25
98682: PUSH
98683: LD_INT 26
98685: PUSH
98686: LD_INT 27
98688: PUSH
98689: LD_INT 28
98691: PUSH
98692: LD_INT 29
98694: PUSH
98695: LD_INT 30
98697: PUSH
98698: LD_INT 31
98700: PUSH
98701: LD_INT 32
98703: PUSH
98704: LD_INT 33
98706: PUSH
98707: LD_INT 34
98709: PUSH
98710: LD_INT 35
98712: PUSH
98713: LD_INT 36
98715: PUSH
98716: EMPTY
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: PUSH
98754: LD_INT 101
98756: PUSH
98757: LD_INT 102
98759: PUSH
98760: LD_INT 103
98762: PUSH
98763: LD_INT 104
98765: PUSH
98766: LD_INT 105
98768: PUSH
98769: LD_INT 106
98771: PUSH
98772: LD_INT 107
98774: PUSH
98775: LD_INT 108
98777: PUSH
98778: LD_INT 109
98780: PUSH
98781: LD_INT 110
98783: PUSH
98784: LD_INT 111
98786: PUSH
98787: LD_INT 112
98789: PUSH
98790: LD_INT 113
98792: PUSH
98793: LD_INT 114
98795: PUSH
98796: LD_INT 115
98798: PUSH
98799: LD_INT 116
98801: PUSH
98802: LD_INT 117
98804: PUSH
98805: LD_INT 118
98807: PUSH
98808: EMPTY
98809: LIST
98810: LIST
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: PUSH
98828: EMPTY
98829: LIST
98830: LIST
98831: ST_TO_ADDR
// if result then
98832: LD_VAR 0 2
98836: IFFALSE 99622
// begin normal :=  ;
98838: LD_ADDR_VAR 0 5
98842: PUSH
98843: LD_STRING 
98845: ST_TO_ADDR
// hardcore :=  ;
98846: LD_ADDR_VAR 0 6
98850: PUSH
98851: LD_STRING 
98853: ST_TO_ADDR
// active :=  ;
98854: LD_ADDR_VAR 0 7
98858: PUSH
98859: LD_STRING 
98861: ST_TO_ADDR
// for i = 1 to normalCounter do
98862: LD_ADDR_VAR 0 8
98866: PUSH
98867: DOUBLE
98868: LD_INT 1
98870: DEC
98871: ST_TO_ADDR
98872: LD_EXP 125
98876: PUSH
98877: FOR_TO
98878: IFFALSE 98979
// begin tmp := 0 ;
98880: LD_ADDR_VAR 0 3
98884: PUSH
98885: LD_STRING 0
98887: ST_TO_ADDR
// if result [ 1 ] then
98888: LD_VAR 0 2
98892: PUSH
98893: LD_INT 1
98895: ARRAY
98896: IFFALSE 98961
// if result [ 1 ] [ 1 ] = i then
98898: LD_VAR 0 2
98902: PUSH
98903: LD_INT 1
98905: ARRAY
98906: PUSH
98907: LD_INT 1
98909: ARRAY
98910: PUSH
98911: LD_VAR 0 8
98915: EQUAL
98916: IFFALSE 98961
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
98918: LD_ADDR_VAR 0 2
98922: PUSH
98923: LD_VAR 0 2
98927: PPUSH
98928: LD_INT 1
98930: PPUSH
98931: LD_VAR 0 2
98935: PUSH
98936: LD_INT 1
98938: ARRAY
98939: PPUSH
98940: LD_INT 1
98942: PPUSH
98943: CALL_OW 3
98947: PPUSH
98948: CALL_OW 1
98952: ST_TO_ADDR
// tmp := 1 ;
98953: LD_ADDR_VAR 0 3
98957: PUSH
98958: LD_STRING 1
98960: ST_TO_ADDR
// end ; normal := normal & tmp ;
98961: LD_ADDR_VAR 0 5
98965: PUSH
98966: LD_VAR 0 5
98970: PUSH
98971: LD_VAR 0 3
98975: STR
98976: ST_TO_ADDR
// end ;
98977: GO 98877
98979: POP
98980: POP
// for i = 1 to hardcoreCounter do
98981: LD_ADDR_VAR 0 8
98985: PUSH
98986: DOUBLE
98987: LD_INT 1
98989: DEC
98990: ST_TO_ADDR
98991: LD_EXP 126
98995: PUSH
98996: FOR_TO
98997: IFFALSE 99102
// begin tmp := 0 ;
98999: LD_ADDR_VAR 0 3
99003: PUSH
99004: LD_STRING 0
99006: ST_TO_ADDR
// if result [ 2 ] then
99007: LD_VAR 0 2
99011: PUSH
99012: LD_INT 2
99014: ARRAY
99015: IFFALSE 99084
// if result [ 2 ] [ 1 ] = 100 + i then
99017: LD_VAR 0 2
99021: PUSH
99022: LD_INT 2
99024: ARRAY
99025: PUSH
99026: LD_INT 1
99028: ARRAY
99029: PUSH
99030: LD_INT 100
99032: PUSH
99033: LD_VAR 0 8
99037: PLUS
99038: EQUAL
99039: IFFALSE 99084
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
99041: LD_ADDR_VAR 0 2
99045: PUSH
99046: LD_VAR 0 2
99050: PPUSH
99051: LD_INT 2
99053: PPUSH
99054: LD_VAR 0 2
99058: PUSH
99059: LD_INT 2
99061: ARRAY
99062: PPUSH
99063: LD_INT 1
99065: PPUSH
99066: CALL_OW 3
99070: PPUSH
99071: CALL_OW 1
99075: ST_TO_ADDR
// tmp := 1 ;
99076: LD_ADDR_VAR 0 3
99080: PUSH
99081: LD_STRING 1
99083: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
99084: LD_ADDR_VAR 0 6
99088: PUSH
99089: LD_VAR 0 6
99093: PUSH
99094: LD_VAR 0 3
99098: STR
99099: ST_TO_ADDR
// end ;
99100: GO 98996
99102: POP
99103: POP
// if isGameLoad then
99104: LD_VAR 0 1
99108: IFFALSE 99583
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99110: LD_ADDR_VAR 0 4
99114: PUSH
99115: LD_EXP 129
99119: PUSH
99120: LD_EXP 128
99124: PUSH
99125: LD_EXP 130
99129: PUSH
99130: LD_EXP 127
99134: PUSH
99135: LD_EXP 131
99139: PUSH
99140: LD_EXP 132
99144: PUSH
99145: LD_EXP 133
99149: PUSH
99150: LD_EXP 134
99154: PUSH
99155: LD_EXP 135
99159: PUSH
99160: LD_EXP 136
99164: PUSH
99165: LD_EXP 137
99169: PUSH
99170: LD_EXP 138
99174: PUSH
99175: LD_EXP 139
99179: PUSH
99180: LD_EXP 140
99184: PUSH
99185: LD_EXP 148
99189: PUSH
99190: LD_EXP 149
99194: PUSH
99195: LD_EXP 150
99199: PUSH
99200: LD_EXP 151
99204: PUSH
99205: LD_EXP 153
99209: PUSH
99210: LD_EXP 154
99214: PUSH
99215: LD_EXP 155
99219: PUSH
99220: LD_EXP 158
99224: PUSH
99225: LD_EXP 160
99229: PUSH
99230: LD_EXP 161
99234: PUSH
99235: LD_EXP 162
99239: PUSH
99240: LD_EXP 164
99244: PUSH
99245: LD_EXP 165
99249: PUSH
99250: LD_EXP 168
99254: PUSH
99255: LD_EXP 169
99259: PUSH
99260: LD_EXP 170
99264: PUSH
99265: LD_EXP 171
99269: PUSH
99270: LD_EXP 172
99274: PUSH
99275: LD_EXP 173
99279: PUSH
99280: LD_EXP 174
99284: PUSH
99285: LD_EXP 175
99289: PUSH
99290: LD_EXP 176
99294: PUSH
99295: LD_EXP 141
99299: PUSH
99300: LD_EXP 142
99304: PUSH
99305: LD_EXP 145
99309: PUSH
99310: LD_EXP 146
99314: PUSH
99315: LD_EXP 147
99319: PUSH
99320: LD_EXP 143
99324: PUSH
99325: LD_EXP 144
99329: PUSH
99330: LD_EXP 152
99334: PUSH
99335: LD_EXP 156
99339: PUSH
99340: LD_EXP 157
99344: PUSH
99345: LD_EXP 159
99349: PUSH
99350: LD_EXP 163
99354: PUSH
99355: LD_EXP 166
99359: PUSH
99360: LD_EXP 167
99364: PUSH
99365: LD_EXP 177
99369: PUSH
99370: LD_EXP 178
99374: PUSH
99375: LD_EXP 179
99379: PUSH
99380: LD_EXP 180
99384: PUSH
99385: EMPTY
99386: LIST
99387: LIST
99388: LIST
99389: LIST
99390: LIST
99391: LIST
99392: LIST
99393: LIST
99394: LIST
99395: LIST
99396: LIST
99397: LIST
99398: LIST
99399: LIST
99400: LIST
99401: LIST
99402: LIST
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: LIST
99430: LIST
99431: LIST
99432: LIST
99433: LIST
99434: LIST
99435: LIST
99436: LIST
99437: LIST
99438: LIST
99439: LIST
99440: ST_TO_ADDR
// tmp :=  ;
99441: LD_ADDR_VAR 0 3
99445: PUSH
99446: LD_STRING 
99448: ST_TO_ADDR
// for i = 1 to normalCounter do
99449: LD_ADDR_VAR 0 8
99453: PUSH
99454: DOUBLE
99455: LD_INT 1
99457: DEC
99458: ST_TO_ADDR
99459: LD_EXP 125
99463: PUSH
99464: FOR_TO
99465: IFFALSE 99501
// begin if flags [ i ] then
99467: LD_VAR 0 4
99471: PUSH
99472: LD_VAR 0 8
99476: ARRAY
99477: IFFALSE 99499
// tmp := tmp & i & ; ;
99479: LD_ADDR_VAR 0 3
99483: PUSH
99484: LD_VAR 0 3
99488: PUSH
99489: LD_VAR 0 8
99493: STR
99494: PUSH
99495: LD_STRING ;
99497: STR
99498: ST_TO_ADDR
// end ;
99499: GO 99464
99501: POP
99502: POP
// for i = 1 to hardcoreCounter do
99503: LD_ADDR_VAR 0 8
99507: PUSH
99508: DOUBLE
99509: LD_INT 1
99511: DEC
99512: ST_TO_ADDR
99513: LD_EXP 126
99517: PUSH
99518: FOR_TO
99519: IFFALSE 99565
// begin if flags [ normalCounter + i ] then
99521: LD_VAR 0 4
99525: PUSH
99526: LD_EXP 125
99530: PUSH
99531: LD_VAR 0 8
99535: PLUS
99536: ARRAY
99537: IFFALSE 99563
// tmp := tmp & ( 100 + i ) & ; ;
99539: LD_ADDR_VAR 0 3
99543: PUSH
99544: LD_VAR 0 3
99548: PUSH
99549: LD_INT 100
99551: PUSH
99552: LD_VAR 0 8
99556: PLUS
99557: STR
99558: PUSH
99559: LD_STRING ;
99561: STR
99562: ST_TO_ADDR
// end ;
99563: GO 99518
99565: POP
99566: POP
// if tmp then
99567: LD_VAR 0 3
99571: IFFALSE 99583
// active := tmp ;
99573: LD_ADDR_VAR 0 7
99577: PUSH
99578: LD_VAR 0 3
99582: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99583: LD_STRING getStreamItemsFromMission("
99585: PUSH
99586: LD_VAR 0 5
99590: STR
99591: PUSH
99592: LD_STRING ","
99594: STR
99595: PUSH
99596: LD_VAR 0 6
99600: STR
99601: PUSH
99602: LD_STRING ","
99604: STR
99605: PUSH
99606: LD_VAR 0 7
99610: STR
99611: PUSH
99612: LD_STRING ")
99614: STR
99615: PPUSH
99616: CALL_OW 559
// end else
99620: GO 99629
// ToLua ( getStreamItemsFromMission("","","") ) ;
99622: LD_STRING getStreamItemsFromMission("","","")
99624: PPUSH
99625: CALL_OW 559
// end ;
99629: LD_VAR 0 2
99633: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99634: LD_EXP 124
99638: PUSH
99639: LD_EXP 129
99643: AND
99644: IFFALSE 99768
99646: GO 99648
99648: DISABLE
99649: LD_INT 0
99651: PPUSH
99652: PPUSH
// begin enable ;
99653: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99654: LD_ADDR_VAR 0 2
99658: PUSH
99659: LD_INT 22
99661: PUSH
99662: LD_OWVAR 2
99666: PUSH
99667: EMPTY
99668: LIST
99669: LIST
99670: PUSH
99671: LD_INT 2
99673: PUSH
99674: LD_INT 34
99676: PUSH
99677: LD_INT 7
99679: PUSH
99680: EMPTY
99681: LIST
99682: LIST
99683: PUSH
99684: LD_INT 34
99686: PUSH
99687: LD_INT 45
99689: PUSH
99690: EMPTY
99691: LIST
99692: LIST
99693: PUSH
99694: LD_INT 34
99696: PUSH
99697: LD_INT 28
99699: PUSH
99700: EMPTY
99701: LIST
99702: LIST
99703: PUSH
99704: LD_INT 34
99706: PUSH
99707: LD_INT 47
99709: PUSH
99710: EMPTY
99711: LIST
99712: LIST
99713: PUSH
99714: EMPTY
99715: LIST
99716: LIST
99717: LIST
99718: LIST
99719: LIST
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: PPUSH
99725: CALL_OW 69
99729: ST_TO_ADDR
// if not tmp then
99730: LD_VAR 0 2
99734: NOT
99735: IFFALSE 99739
// exit ;
99737: GO 99768
// for i in tmp do
99739: LD_ADDR_VAR 0 1
99743: PUSH
99744: LD_VAR 0 2
99748: PUSH
99749: FOR_IN
99750: IFFALSE 99766
// begin SetLives ( i , 0 ) ;
99752: LD_VAR 0 1
99756: PPUSH
99757: LD_INT 0
99759: PPUSH
99760: CALL_OW 234
// end ;
99764: GO 99749
99766: POP
99767: POP
// end ;
99768: PPOPN 2
99770: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99771: LD_EXP 124
99775: PUSH
99776: LD_EXP 130
99780: AND
99781: IFFALSE 99865
99783: GO 99785
99785: DISABLE
99786: LD_INT 0
99788: PPUSH
99789: PPUSH
// begin enable ;
99790: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99791: LD_ADDR_VAR 0 2
99795: PUSH
99796: LD_INT 22
99798: PUSH
99799: LD_OWVAR 2
99803: PUSH
99804: EMPTY
99805: LIST
99806: LIST
99807: PUSH
99808: LD_INT 32
99810: PUSH
99811: LD_INT 3
99813: PUSH
99814: EMPTY
99815: LIST
99816: LIST
99817: PUSH
99818: EMPTY
99819: LIST
99820: LIST
99821: PPUSH
99822: CALL_OW 69
99826: ST_TO_ADDR
// if not tmp then
99827: LD_VAR 0 2
99831: NOT
99832: IFFALSE 99836
// exit ;
99834: GO 99865
// for i in tmp do
99836: LD_ADDR_VAR 0 1
99840: PUSH
99841: LD_VAR 0 2
99845: PUSH
99846: FOR_IN
99847: IFFALSE 99863
// begin SetLives ( i , 0 ) ;
99849: LD_VAR 0 1
99853: PPUSH
99854: LD_INT 0
99856: PPUSH
99857: CALL_OW 234
// end ;
99861: GO 99846
99863: POP
99864: POP
// end ;
99865: PPOPN 2
99867: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
99868: LD_EXP 124
99872: PUSH
99873: LD_EXP 127
99877: AND
99878: IFFALSE 99971
99880: GO 99882
99882: DISABLE
99883: LD_INT 0
99885: PPUSH
// begin enable ;
99886: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
99887: LD_ADDR_VAR 0 1
99891: PUSH
99892: LD_INT 22
99894: PUSH
99895: LD_OWVAR 2
99899: PUSH
99900: EMPTY
99901: LIST
99902: LIST
99903: PUSH
99904: LD_INT 2
99906: PUSH
99907: LD_INT 25
99909: PUSH
99910: LD_INT 5
99912: PUSH
99913: EMPTY
99914: LIST
99915: LIST
99916: PUSH
99917: LD_INT 25
99919: PUSH
99920: LD_INT 9
99922: PUSH
99923: EMPTY
99924: LIST
99925: LIST
99926: PUSH
99927: LD_INT 25
99929: PUSH
99930: LD_INT 8
99932: PUSH
99933: EMPTY
99934: LIST
99935: LIST
99936: PUSH
99937: EMPTY
99938: LIST
99939: LIST
99940: LIST
99941: LIST
99942: PUSH
99943: EMPTY
99944: LIST
99945: LIST
99946: PPUSH
99947: CALL_OW 69
99951: PUSH
99952: FOR_IN
99953: IFFALSE 99969
// begin SetClass ( i , 1 ) ;
99955: LD_VAR 0 1
99959: PPUSH
99960: LD_INT 1
99962: PPUSH
99963: CALL_OW 336
// end ;
99967: GO 99952
99969: POP
99970: POP
// end ;
99971: PPOPN 1
99973: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
99974: LD_EXP 124
99978: PUSH
99979: LD_EXP 128
99983: AND
99984: PUSH
99985: LD_OWVAR 65
99989: PUSH
99990: LD_INT 7
99992: LESS
99993: AND
99994: IFFALSE 100008
99996: GO 99998
99998: DISABLE
// begin enable ;
99999: ENABLE
// game_speed := 7 ;
100000: LD_ADDR_OWVAR 65
100004: PUSH
100005: LD_INT 7
100007: ST_TO_ADDR
// end ;
100008: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100009: LD_EXP 124
100013: PUSH
100014: LD_EXP 131
100018: AND
100019: IFFALSE 100221
100021: GO 100023
100023: DISABLE
100024: LD_INT 0
100026: PPUSH
100027: PPUSH
100028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100029: LD_ADDR_VAR 0 3
100033: PUSH
100034: LD_INT 81
100036: PUSH
100037: LD_OWVAR 2
100041: PUSH
100042: EMPTY
100043: LIST
100044: LIST
100045: PUSH
100046: LD_INT 21
100048: PUSH
100049: LD_INT 1
100051: PUSH
100052: EMPTY
100053: LIST
100054: LIST
100055: PUSH
100056: EMPTY
100057: LIST
100058: LIST
100059: PPUSH
100060: CALL_OW 69
100064: ST_TO_ADDR
// if not tmp then
100065: LD_VAR 0 3
100069: NOT
100070: IFFALSE 100074
// exit ;
100072: GO 100221
// if tmp > 5 then
100074: LD_VAR 0 3
100078: PUSH
100079: LD_INT 5
100081: GREATER
100082: IFFALSE 100094
// k := 5 else
100084: LD_ADDR_VAR 0 2
100088: PUSH
100089: LD_INT 5
100091: ST_TO_ADDR
100092: GO 100104
// k := tmp ;
100094: LD_ADDR_VAR 0 2
100098: PUSH
100099: LD_VAR 0 3
100103: ST_TO_ADDR
// for i := 1 to k do
100104: LD_ADDR_VAR 0 1
100108: PUSH
100109: DOUBLE
100110: LD_INT 1
100112: DEC
100113: ST_TO_ADDR
100114: LD_VAR 0 2
100118: PUSH
100119: FOR_TO
100120: IFFALSE 100219
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100122: LD_VAR 0 3
100126: PUSH
100127: LD_VAR 0 1
100131: ARRAY
100132: PPUSH
100133: LD_VAR 0 1
100137: PUSH
100138: LD_INT 4
100140: MOD
100141: PUSH
100142: LD_INT 1
100144: PLUS
100145: PPUSH
100146: CALL_OW 259
100150: PUSH
100151: LD_INT 10
100153: LESS
100154: IFFALSE 100217
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100156: LD_VAR 0 3
100160: PUSH
100161: LD_VAR 0 1
100165: ARRAY
100166: PPUSH
100167: LD_VAR 0 1
100171: PUSH
100172: LD_INT 4
100174: MOD
100175: PUSH
100176: LD_INT 1
100178: PLUS
100179: PPUSH
100180: LD_VAR 0 3
100184: PUSH
100185: LD_VAR 0 1
100189: ARRAY
100190: PPUSH
100191: LD_VAR 0 1
100195: PUSH
100196: LD_INT 4
100198: MOD
100199: PUSH
100200: LD_INT 1
100202: PLUS
100203: PPUSH
100204: CALL_OW 259
100208: PUSH
100209: LD_INT 1
100211: PLUS
100212: PPUSH
100213: CALL_OW 237
100217: GO 100119
100219: POP
100220: POP
// end ;
100221: PPOPN 3
100223: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
100224: LD_EXP 124
100228: PUSH
100229: LD_EXP 132
100233: AND
100234: IFFALSE 100254
100236: GO 100238
100238: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
100239: LD_INT 4
100241: PPUSH
100242: LD_OWVAR 2
100246: PPUSH
100247: LD_INT 0
100249: PPUSH
100250: CALL_OW 324
100254: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100255: LD_EXP 124
100259: PUSH
100260: LD_EXP 161
100264: AND
100265: IFFALSE 100285
100267: GO 100269
100269: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100270: LD_INT 19
100272: PPUSH
100273: LD_OWVAR 2
100277: PPUSH
100278: LD_INT 0
100280: PPUSH
100281: CALL_OW 324
100285: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100286: LD_EXP 124
100290: PUSH
100291: LD_EXP 133
100295: AND
100296: IFFALSE 100398
100298: GO 100300
100300: DISABLE
100301: LD_INT 0
100303: PPUSH
100304: PPUSH
// begin enable ;
100305: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100306: LD_ADDR_VAR 0 2
100310: PUSH
100311: LD_INT 22
100313: PUSH
100314: LD_OWVAR 2
100318: PUSH
100319: EMPTY
100320: LIST
100321: LIST
100322: PUSH
100323: LD_INT 2
100325: PUSH
100326: LD_INT 34
100328: PUSH
100329: LD_INT 11
100331: PUSH
100332: EMPTY
100333: LIST
100334: LIST
100335: PUSH
100336: LD_INT 34
100338: PUSH
100339: LD_INT 30
100341: PUSH
100342: EMPTY
100343: LIST
100344: LIST
100345: PUSH
100346: EMPTY
100347: LIST
100348: LIST
100349: LIST
100350: PUSH
100351: EMPTY
100352: LIST
100353: LIST
100354: PPUSH
100355: CALL_OW 69
100359: ST_TO_ADDR
// if not tmp then
100360: LD_VAR 0 2
100364: NOT
100365: IFFALSE 100369
// exit ;
100367: GO 100398
// for i in tmp do
100369: LD_ADDR_VAR 0 1
100373: PUSH
100374: LD_VAR 0 2
100378: PUSH
100379: FOR_IN
100380: IFFALSE 100396
// begin SetLives ( i , 0 ) ;
100382: LD_VAR 0 1
100386: PPUSH
100387: LD_INT 0
100389: PPUSH
100390: CALL_OW 234
// end ;
100394: GO 100379
100396: POP
100397: POP
// end ;
100398: PPOPN 2
100400: END
// every 0 0$1 trigger StreamModeActive and sBunker do
100401: LD_EXP 124
100405: PUSH
100406: LD_EXP 134
100410: AND
100411: IFFALSE 100431
100413: GO 100415
100415: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
100416: LD_INT 32
100418: PPUSH
100419: LD_OWVAR 2
100423: PPUSH
100424: LD_INT 0
100426: PPUSH
100427: CALL_OW 324
100431: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
100432: LD_EXP 124
100436: PUSH
100437: LD_EXP 135
100441: AND
100442: IFFALSE 100623
100444: GO 100446
100446: DISABLE
100447: LD_INT 0
100449: PPUSH
100450: PPUSH
100451: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
100452: LD_ADDR_VAR 0 2
100456: PUSH
100457: LD_INT 22
100459: PUSH
100460: LD_OWVAR 2
100464: PUSH
100465: EMPTY
100466: LIST
100467: LIST
100468: PUSH
100469: LD_INT 33
100471: PUSH
100472: LD_INT 3
100474: PUSH
100475: EMPTY
100476: LIST
100477: LIST
100478: PUSH
100479: EMPTY
100480: LIST
100481: LIST
100482: PPUSH
100483: CALL_OW 69
100487: ST_TO_ADDR
// if not tmp then
100488: LD_VAR 0 2
100492: NOT
100493: IFFALSE 100497
// exit ;
100495: GO 100623
// side := 0 ;
100497: LD_ADDR_VAR 0 3
100501: PUSH
100502: LD_INT 0
100504: ST_TO_ADDR
// for i := 1 to 8 do
100505: LD_ADDR_VAR 0 1
100509: PUSH
100510: DOUBLE
100511: LD_INT 1
100513: DEC
100514: ST_TO_ADDR
100515: LD_INT 8
100517: PUSH
100518: FOR_TO
100519: IFFALSE 100567
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100521: LD_OWVAR 2
100525: PUSH
100526: LD_VAR 0 1
100530: NONEQUAL
100531: PUSH
100532: LD_OWVAR 2
100536: PPUSH
100537: LD_VAR 0 1
100541: PPUSH
100542: CALL_OW 81
100546: PUSH
100547: LD_INT 2
100549: EQUAL
100550: AND
100551: IFFALSE 100565
// begin side := i ;
100553: LD_ADDR_VAR 0 3
100557: PUSH
100558: LD_VAR 0 1
100562: ST_TO_ADDR
// break ;
100563: GO 100567
// end ;
100565: GO 100518
100567: POP
100568: POP
// if not side then
100569: LD_VAR 0 3
100573: NOT
100574: IFFALSE 100578
// exit ;
100576: GO 100623
// for i := 1 to tmp do
100578: LD_ADDR_VAR 0 1
100582: PUSH
100583: DOUBLE
100584: LD_INT 1
100586: DEC
100587: ST_TO_ADDR
100588: LD_VAR 0 2
100592: PUSH
100593: FOR_TO
100594: IFFALSE 100621
// if Prob ( 60 ) then
100596: LD_INT 60
100598: PPUSH
100599: CALL_OW 13
100603: IFFALSE 100619
// SetSide ( i , side ) ;
100605: LD_VAR 0 1
100609: PPUSH
100610: LD_VAR 0 3
100614: PPUSH
100615: CALL_OW 235
100619: GO 100593
100621: POP
100622: POP
// end ;
100623: PPOPN 3
100625: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100626: LD_EXP 124
100630: PUSH
100631: LD_EXP 137
100635: AND
100636: IFFALSE 100755
100638: GO 100640
100640: DISABLE
100641: LD_INT 0
100643: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100644: LD_ADDR_VAR 0 1
100648: PUSH
100649: LD_INT 22
100651: PUSH
100652: LD_OWVAR 2
100656: PUSH
100657: EMPTY
100658: LIST
100659: LIST
100660: PUSH
100661: LD_INT 21
100663: PUSH
100664: LD_INT 1
100666: PUSH
100667: EMPTY
100668: LIST
100669: LIST
100670: PUSH
100671: LD_INT 3
100673: PUSH
100674: LD_INT 23
100676: PUSH
100677: LD_INT 0
100679: PUSH
100680: EMPTY
100681: LIST
100682: LIST
100683: PUSH
100684: EMPTY
100685: LIST
100686: LIST
100687: PUSH
100688: EMPTY
100689: LIST
100690: LIST
100691: LIST
100692: PPUSH
100693: CALL_OW 69
100697: PUSH
100698: FOR_IN
100699: IFFALSE 100753
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100701: LD_VAR 0 1
100705: PPUSH
100706: CALL_OW 257
100710: PUSH
100711: LD_INT 1
100713: PUSH
100714: LD_INT 2
100716: PUSH
100717: LD_INT 3
100719: PUSH
100720: LD_INT 4
100722: PUSH
100723: EMPTY
100724: LIST
100725: LIST
100726: LIST
100727: LIST
100728: IN
100729: IFFALSE 100751
// SetClass ( un , rand ( 1 , 4 ) ) ;
100731: LD_VAR 0 1
100735: PPUSH
100736: LD_INT 1
100738: PPUSH
100739: LD_INT 4
100741: PPUSH
100742: CALL_OW 12
100746: PPUSH
100747: CALL_OW 336
100751: GO 100698
100753: POP
100754: POP
// end ;
100755: PPOPN 1
100757: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100758: LD_EXP 124
100762: PUSH
100763: LD_EXP 136
100767: AND
100768: IFFALSE 100847
100770: GO 100772
100772: DISABLE
100773: LD_INT 0
100775: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100776: LD_ADDR_VAR 0 1
100780: PUSH
100781: LD_INT 22
100783: PUSH
100784: LD_OWVAR 2
100788: PUSH
100789: EMPTY
100790: LIST
100791: LIST
100792: PUSH
100793: LD_INT 21
100795: PUSH
100796: LD_INT 3
100798: PUSH
100799: EMPTY
100800: LIST
100801: LIST
100802: PUSH
100803: EMPTY
100804: LIST
100805: LIST
100806: PPUSH
100807: CALL_OW 69
100811: ST_TO_ADDR
// if not tmp then
100812: LD_VAR 0 1
100816: NOT
100817: IFFALSE 100821
// exit ;
100819: GO 100847
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100821: LD_VAR 0 1
100825: PUSH
100826: LD_INT 1
100828: PPUSH
100829: LD_VAR 0 1
100833: PPUSH
100834: CALL_OW 12
100838: ARRAY
100839: PPUSH
100840: LD_INT 100
100842: PPUSH
100843: CALL_OW 234
// end ;
100847: PPOPN 1
100849: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
100850: LD_EXP 124
100854: PUSH
100855: LD_EXP 138
100859: AND
100860: IFFALSE 100958
100862: GO 100864
100864: DISABLE
100865: LD_INT 0
100867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100868: LD_ADDR_VAR 0 1
100872: PUSH
100873: LD_INT 22
100875: PUSH
100876: LD_OWVAR 2
100880: PUSH
100881: EMPTY
100882: LIST
100883: LIST
100884: PUSH
100885: LD_INT 21
100887: PUSH
100888: LD_INT 1
100890: PUSH
100891: EMPTY
100892: LIST
100893: LIST
100894: PUSH
100895: EMPTY
100896: LIST
100897: LIST
100898: PPUSH
100899: CALL_OW 69
100903: ST_TO_ADDR
// if not tmp then
100904: LD_VAR 0 1
100908: NOT
100909: IFFALSE 100913
// exit ;
100911: GO 100958
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
100913: LD_VAR 0 1
100917: PUSH
100918: LD_INT 1
100920: PPUSH
100921: LD_VAR 0 1
100925: PPUSH
100926: CALL_OW 12
100930: ARRAY
100931: PPUSH
100932: LD_INT 1
100934: PPUSH
100935: LD_INT 4
100937: PPUSH
100938: CALL_OW 12
100942: PPUSH
100943: LD_INT 3000
100945: PPUSH
100946: LD_INT 9000
100948: PPUSH
100949: CALL_OW 12
100953: PPUSH
100954: CALL_OW 492
// end ;
100958: PPOPN 1
100960: END
// every 0 0$1 trigger StreamModeActive and sDepot do
100961: LD_EXP 124
100965: PUSH
100966: LD_EXP 139
100970: AND
100971: IFFALSE 100991
100973: GO 100975
100975: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
100976: LD_INT 1
100978: PPUSH
100979: LD_OWVAR 2
100983: PPUSH
100984: LD_INT 0
100986: PPUSH
100987: CALL_OW 324
100991: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
100992: LD_EXP 124
100996: PUSH
100997: LD_EXP 140
101001: AND
101002: IFFALSE 101085
101004: GO 101006
101006: DISABLE
101007: LD_INT 0
101009: PPUSH
101010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101011: LD_ADDR_VAR 0 2
101015: PUSH
101016: LD_INT 22
101018: PUSH
101019: LD_OWVAR 2
101023: PUSH
101024: EMPTY
101025: LIST
101026: LIST
101027: PUSH
101028: LD_INT 21
101030: PUSH
101031: LD_INT 3
101033: PUSH
101034: EMPTY
101035: LIST
101036: LIST
101037: PUSH
101038: EMPTY
101039: LIST
101040: LIST
101041: PPUSH
101042: CALL_OW 69
101046: ST_TO_ADDR
// if not tmp then
101047: LD_VAR 0 2
101051: NOT
101052: IFFALSE 101056
// exit ;
101054: GO 101085
// for i in tmp do
101056: LD_ADDR_VAR 0 1
101060: PUSH
101061: LD_VAR 0 2
101065: PUSH
101066: FOR_IN
101067: IFFALSE 101083
// SetBLevel ( i , 10 ) ;
101069: LD_VAR 0 1
101073: PPUSH
101074: LD_INT 10
101076: PPUSH
101077: CALL_OW 241
101081: GO 101066
101083: POP
101084: POP
// end ;
101085: PPOPN 2
101087: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
101088: LD_EXP 124
101092: PUSH
101093: LD_EXP 141
101097: AND
101098: IFFALSE 101209
101100: GO 101102
101102: DISABLE
101103: LD_INT 0
101105: PPUSH
101106: PPUSH
101107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101108: LD_ADDR_VAR 0 3
101112: PUSH
101113: LD_INT 22
101115: PUSH
101116: LD_OWVAR 2
101120: PUSH
101121: EMPTY
101122: LIST
101123: LIST
101124: PUSH
101125: LD_INT 25
101127: PUSH
101128: LD_INT 1
101130: PUSH
101131: EMPTY
101132: LIST
101133: LIST
101134: PUSH
101135: EMPTY
101136: LIST
101137: LIST
101138: PPUSH
101139: CALL_OW 69
101143: ST_TO_ADDR
// if not tmp then
101144: LD_VAR 0 3
101148: NOT
101149: IFFALSE 101153
// exit ;
101151: GO 101209
// un := tmp [ rand ( 1 , tmp ) ] ;
101153: LD_ADDR_VAR 0 2
101157: PUSH
101158: LD_VAR 0 3
101162: PUSH
101163: LD_INT 1
101165: PPUSH
101166: LD_VAR 0 3
101170: PPUSH
101171: CALL_OW 12
101175: ARRAY
101176: ST_TO_ADDR
// if Crawls ( un ) then
101177: LD_VAR 0 2
101181: PPUSH
101182: CALL_OW 318
101186: IFFALSE 101197
// ComWalk ( un ) ;
101188: LD_VAR 0 2
101192: PPUSH
101193: CALL_OW 138
// SetClass ( un , class_sniper ) ;
101197: LD_VAR 0 2
101201: PPUSH
101202: LD_INT 5
101204: PPUSH
101205: CALL_OW 336
// end ;
101209: PPOPN 3
101211: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
101212: LD_EXP 124
101216: PUSH
101217: LD_EXP 142
101221: AND
101222: PUSH
101223: LD_OWVAR 67
101227: PUSH
101228: LD_INT 4
101230: LESS
101231: AND
101232: IFFALSE 101251
101234: GO 101236
101236: DISABLE
// begin Difficulty := Difficulty + 1 ;
101237: LD_ADDR_OWVAR 67
101241: PUSH
101242: LD_OWVAR 67
101246: PUSH
101247: LD_INT 1
101249: PLUS
101250: ST_TO_ADDR
// end ;
101251: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101252: LD_EXP 124
101256: PUSH
101257: LD_EXP 143
101261: AND
101262: IFFALSE 101365
101264: GO 101266
101266: DISABLE
101267: LD_INT 0
101269: PPUSH
// begin for i := 1 to 5 do
101270: LD_ADDR_VAR 0 1
101274: PUSH
101275: DOUBLE
101276: LD_INT 1
101278: DEC
101279: ST_TO_ADDR
101280: LD_INT 5
101282: PUSH
101283: FOR_TO
101284: IFFALSE 101363
// begin uc_nation := nation_nature ;
101286: LD_ADDR_OWVAR 21
101290: PUSH
101291: LD_INT 0
101293: ST_TO_ADDR
// uc_side := 0 ;
101294: LD_ADDR_OWVAR 20
101298: PUSH
101299: LD_INT 0
101301: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101302: LD_ADDR_OWVAR 29
101306: PUSH
101307: LD_INT 12
101309: PUSH
101310: LD_INT 12
101312: PUSH
101313: EMPTY
101314: LIST
101315: LIST
101316: ST_TO_ADDR
// hc_agressivity := 20 ;
101317: LD_ADDR_OWVAR 35
101321: PUSH
101322: LD_INT 20
101324: ST_TO_ADDR
// hc_class := class_tiger ;
101325: LD_ADDR_OWVAR 28
101329: PUSH
101330: LD_INT 14
101332: ST_TO_ADDR
// hc_gallery :=  ;
101333: LD_ADDR_OWVAR 33
101337: PUSH
101338: LD_STRING 
101340: ST_TO_ADDR
// hc_name :=  ;
101341: LD_ADDR_OWVAR 26
101345: PUSH
101346: LD_STRING 
101348: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101349: CALL_OW 44
101353: PPUSH
101354: LD_INT 0
101356: PPUSH
101357: CALL_OW 51
// end ;
101361: GO 101283
101363: POP
101364: POP
// end ;
101365: PPOPN 1
101367: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101368: LD_EXP 124
101372: PUSH
101373: LD_EXP 144
101377: AND
101378: IFFALSE 101387
101380: GO 101382
101382: DISABLE
// StreamSibBomb ;
101383: CALL 101388 0 0
101387: END
// export function StreamSibBomb ; var i , x , y ; begin
101388: LD_INT 0
101390: PPUSH
101391: PPUSH
101392: PPUSH
101393: PPUSH
// result := false ;
101394: LD_ADDR_VAR 0 1
101398: PUSH
101399: LD_INT 0
101401: ST_TO_ADDR
// for i := 1 to 16 do
101402: LD_ADDR_VAR 0 2
101406: PUSH
101407: DOUBLE
101408: LD_INT 1
101410: DEC
101411: ST_TO_ADDR
101412: LD_INT 16
101414: PUSH
101415: FOR_TO
101416: IFFALSE 101615
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101418: LD_ADDR_VAR 0 3
101422: PUSH
101423: LD_INT 10
101425: PUSH
101426: LD_INT 20
101428: PUSH
101429: LD_INT 30
101431: PUSH
101432: LD_INT 40
101434: PUSH
101435: LD_INT 50
101437: PUSH
101438: LD_INT 60
101440: PUSH
101441: LD_INT 70
101443: PUSH
101444: LD_INT 80
101446: PUSH
101447: LD_INT 90
101449: PUSH
101450: LD_INT 100
101452: PUSH
101453: LD_INT 110
101455: PUSH
101456: LD_INT 120
101458: PUSH
101459: LD_INT 130
101461: PUSH
101462: LD_INT 140
101464: PUSH
101465: LD_INT 150
101467: PUSH
101468: EMPTY
101469: LIST
101470: LIST
101471: LIST
101472: LIST
101473: LIST
101474: LIST
101475: LIST
101476: LIST
101477: LIST
101478: LIST
101479: LIST
101480: LIST
101481: LIST
101482: LIST
101483: LIST
101484: PUSH
101485: LD_INT 1
101487: PPUSH
101488: LD_INT 15
101490: PPUSH
101491: CALL_OW 12
101495: ARRAY
101496: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101497: LD_ADDR_VAR 0 4
101501: PUSH
101502: LD_INT 10
101504: PUSH
101505: LD_INT 20
101507: PUSH
101508: LD_INT 30
101510: PUSH
101511: LD_INT 40
101513: PUSH
101514: LD_INT 50
101516: PUSH
101517: LD_INT 60
101519: PUSH
101520: LD_INT 70
101522: PUSH
101523: LD_INT 80
101525: PUSH
101526: LD_INT 90
101528: PUSH
101529: LD_INT 100
101531: PUSH
101532: LD_INT 110
101534: PUSH
101535: LD_INT 120
101537: PUSH
101538: LD_INT 130
101540: PUSH
101541: LD_INT 140
101543: PUSH
101544: LD_INT 150
101546: PUSH
101547: EMPTY
101548: LIST
101549: LIST
101550: LIST
101551: LIST
101552: LIST
101553: LIST
101554: LIST
101555: LIST
101556: LIST
101557: LIST
101558: LIST
101559: LIST
101560: LIST
101561: LIST
101562: LIST
101563: PUSH
101564: LD_INT 1
101566: PPUSH
101567: LD_INT 15
101569: PPUSH
101570: CALL_OW 12
101574: ARRAY
101575: ST_TO_ADDR
// if ValidHex ( x , y ) then
101576: LD_VAR 0 3
101580: PPUSH
101581: LD_VAR 0 4
101585: PPUSH
101586: CALL_OW 488
101590: IFFALSE 101613
// begin result := [ x , y ] ;
101592: LD_ADDR_VAR 0 1
101596: PUSH
101597: LD_VAR 0 3
101601: PUSH
101602: LD_VAR 0 4
101606: PUSH
101607: EMPTY
101608: LIST
101609: LIST
101610: ST_TO_ADDR
// break ;
101611: GO 101615
// end ; end ;
101613: GO 101415
101615: POP
101616: POP
// if result then
101617: LD_VAR 0 1
101621: IFFALSE 101681
// begin ToLua ( playSibBomb() ) ;
101623: LD_STRING playSibBomb()
101625: PPUSH
101626: CALL_OW 559
// wait ( 0 0$14 ) ;
101630: LD_INT 490
101632: PPUSH
101633: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101637: LD_VAR 0 1
101641: PUSH
101642: LD_INT 1
101644: ARRAY
101645: PPUSH
101646: LD_VAR 0 1
101650: PUSH
101651: LD_INT 2
101653: ARRAY
101654: PPUSH
101655: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101659: LD_VAR 0 1
101663: PUSH
101664: LD_INT 1
101666: ARRAY
101667: PPUSH
101668: LD_VAR 0 1
101672: PUSH
101673: LD_INT 2
101675: ARRAY
101676: PPUSH
101677: CALL_OW 429
// end ; end ;
101681: LD_VAR 0 1
101685: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101686: LD_EXP 124
101690: PUSH
101691: LD_EXP 146
101695: AND
101696: IFFALSE 101708
101698: GO 101700
101700: DISABLE
// YouLost (  ) ;
101701: LD_STRING 
101703: PPUSH
101704: CALL_OW 104
101708: END
// every 0 0$1 trigger StreamModeActive and sFog do
101709: LD_EXP 124
101713: PUSH
101714: LD_EXP 145
101718: AND
101719: IFFALSE 101733
101721: GO 101723
101723: DISABLE
// FogOff ( your_side ) ;
101724: LD_OWVAR 2
101728: PPUSH
101729: CALL_OW 344
101733: END
// every 0 0$1 trigger StreamModeActive and sSun do
101734: LD_EXP 124
101738: PUSH
101739: LD_EXP 147
101743: AND
101744: IFFALSE 101772
101746: GO 101748
101748: DISABLE
// begin solar_recharge_percent := 0 ;
101749: LD_ADDR_OWVAR 79
101753: PUSH
101754: LD_INT 0
101756: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101757: LD_INT 10500
101759: PPUSH
101760: CALL_OW 67
// solar_recharge_percent := 100 ;
101764: LD_ADDR_OWVAR 79
101768: PUSH
101769: LD_INT 100
101771: ST_TO_ADDR
// end ;
101772: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101773: LD_EXP 124
101777: PUSH
101778: LD_EXP 148
101782: AND
101783: IFFALSE 102022
101785: GO 101787
101787: DISABLE
101788: LD_INT 0
101790: PPUSH
101791: PPUSH
101792: PPUSH
// begin tmp := [ ] ;
101793: LD_ADDR_VAR 0 3
101797: PUSH
101798: EMPTY
101799: ST_TO_ADDR
// for i := 1 to 6 do
101800: LD_ADDR_VAR 0 1
101804: PUSH
101805: DOUBLE
101806: LD_INT 1
101808: DEC
101809: ST_TO_ADDR
101810: LD_INT 6
101812: PUSH
101813: FOR_TO
101814: IFFALSE 101919
// begin uc_nation := nation_nature ;
101816: LD_ADDR_OWVAR 21
101820: PUSH
101821: LD_INT 0
101823: ST_TO_ADDR
// uc_side := 0 ;
101824: LD_ADDR_OWVAR 20
101828: PUSH
101829: LD_INT 0
101831: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101832: LD_ADDR_OWVAR 29
101836: PUSH
101837: LD_INT 12
101839: PUSH
101840: LD_INT 12
101842: PUSH
101843: EMPTY
101844: LIST
101845: LIST
101846: ST_TO_ADDR
// hc_agressivity := 20 ;
101847: LD_ADDR_OWVAR 35
101851: PUSH
101852: LD_INT 20
101854: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
101855: LD_ADDR_OWVAR 28
101859: PUSH
101860: LD_INT 17
101862: ST_TO_ADDR
// hc_gallery :=  ;
101863: LD_ADDR_OWVAR 33
101867: PUSH
101868: LD_STRING 
101870: ST_TO_ADDR
// hc_name :=  ;
101871: LD_ADDR_OWVAR 26
101875: PUSH
101876: LD_STRING 
101878: ST_TO_ADDR
// un := CreateHuman ;
101879: LD_ADDR_VAR 0 2
101883: PUSH
101884: CALL_OW 44
101888: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
101889: LD_VAR 0 2
101893: PPUSH
101894: LD_INT 1
101896: PPUSH
101897: CALL_OW 51
// tmp := tmp ^ un ;
101901: LD_ADDR_VAR 0 3
101905: PUSH
101906: LD_VAR 0 3
101910: PUSH
101911: LD_VAR 0 2
101915: ADD
101916: ST_TO_ADDR
// end ;
101917: GO 101813
101919: POP
101920: POP
// repeat wait ( 0 0$1 ) ;
101921: LD_INT 35
101923: PPUSH
101924: CALL_OW 67
// for un in tmp do
101928: LD_ADDR_VAR 0 2
101932: PUSH
101933: LD_VAR 0 3
101937: PUSH
101938: FOR_IN
101939: IFFALSE 102013
// begin if IsDead ( un ) then
101941: LD_VAR 0 2
101945: PPUSH
101946: CALL_OW 301
101950: IFFALSE 101970
// begin tmp := tmp diff un ;
101952: LD_ADDR_VAR 0 3
101956: PUSH
101957: LD_VAR 0 3
101961: PUSH
101962: LD_VAR 0 2
101966: DIFF
101967: ST_TO_ADDR
// continue ;
101968: GO 101938
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
101970: LD_VAR 0 2
101974: PPUSH
101975: LD_INT 3
101977: PUSH
101978: LD_INT 22
101980: PUSH
101981: LD_INT 0
101983: PUSH
101984: EMPTY
101985: LIST
101986: LIST
101987: PUSH
101988: EMPTY
101989: LIST
101990: LIST
101991: PPUSH
101992: CALL_OW 69
101996: PPUSH
101997: LD_VAR 0 2
102001: PPUSH
102002: CALL_OW 74
102006: PPUSH
102007: CALL_OW 115
// end ;
102011: GO 101938
102013: POP
102014: POP
// until not tmp ;
102015: LD_VAR 0 3
102019: NOT
102020: IFFALSE 101921
// end ;
102022: PPOPN 3
102024: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102025: LD_EXP 124
102029: PUSH
102030: LD_EXP 149
102034: AND
102035: IFFALSE 102089
102037: GO 102039
102039: DISABLE
// begin ToLua ( displayTroll(); ) ;
102040: LD_STRING displayTroll();
102042: PPUSH
102043: CALL_OW 559
// wait ( 3 3$00 ) ;
102047: LD_INT 6300
102049: PPUSH
102050: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102054: LD_STRING hideTroll();
102056: PPUSH
102057: CALL_OW 559
// wait ( 1 1$00 ) ;
102061: LD_INT 2100
102063: PPUSH
102064: CALL_OW 67
// ToLua ( displayTroll(); ) ;
102068: LD_STRING displayTroll();
102070: PPUSH
102071: CALL_OW 559
// wait ( 1 1$00 ) ;
102075: LD_INT 2100
102077: PPUSH
102078: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102082: LD_STRING hideTroll();
102084: PPUSH
102085: CALL_OW 559
// end ;
102089: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
102090: LD_EXP 124
102094: PUSH
102095: LD_EXP 150
102099: AND
102100: IFFALSE 102163
102102: GO 102104
102104: DISABLE
102105: LD_INT 0
102107: PPUSH
// begin p := 0 ;
102108: LD_ADDR_VAR 0 1
102112: PUSH
102113: LD_INT 0
102115: ST_TO_ADDR
// repeat game_speed := 1 ;
102116: LD_ADDR_OWVAR 65
102120: PUSH
102121: LD_INT 1
102123: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102124: LD_INT 35
102126: PPUSH
102127: CALL_OW 67
// p := p + 1 ;
102131: LD_ADDR_VAR 0 1
102135: PUSH
102136: LD_VAR 0 1
102140: PUSH
102141: LD_INT 1
102143: PLUS
102144: ST_TO_ADDR
// until p >= 60 ;
102145: LD_VAR 0 1
102149: PUSH
102150: LD_INT 60
102152: GREATEREQUAL
102153: IFFALSE 102116
// game_speed := 4 ;
102155: LD_ADDR_OWVAR 65
102159: PUSH
102160: LD_INT 4
102162: ST_TO_ADDR
// end ;
102163: PPOPN 1
102165: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
102166: LD_EXP 124
102170: PUSH
102171: LD_EXP 151
102175: AND
102176: IFFALSE 102322
102178: GO 102180
102180: DISABLE
102181: LD_INT 0
102183: PPUSH
102184: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102185: LD_ADDR_VAR 0 1
102189: PUSH
102190: LD_INT 22
102192: PUSH
102193: LD_OWVAR 2
102197: PUSH
102198: EMPTY
102199: LIST
102200: LIST
102201: PUSH
102202: LD_INT 2
102204: PUSH
102205: LD_INT 30
102207: PUSH
102208: LD_INT 0
102210: PUSH
102211: EMPTY
102212: LIST
102213: LIST
102214: PUSH
102215: LD_INT 30
102217: PUSH
102218: LD_INT 1
102220: PUSH
102221: EMPTY
102222: LIST
102223: LIST
102224: PUSH
102225: EMPTY
102226: LIST
102227: LIST
102228: LIST
102229: PUSH
102230: EMPTY
102231: LIST
102232: LIST
102233: PPUSH
102234: CALL_OW 69
102238: ST_TO_ADDR
// if not depot then
102239: LD_VAR 0 1
102243: NOT
102244: IFFALSE 102248
// exit ;
102246: GO 102322
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102248: LD_ADDR_VAR 0 2
102252: PUSH
102253: LD_VAR 0 1
102257: PUSH
102258: LD_INT 1
102260: PPUSH
102261: LD_VAR 0 1
102265: PPUSH
102266: CALL_OW 12
102270: ARRAY
102271: PPUSH
102272: CALL_OW 274
102276: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102277: LD_VAR 0 2
102281: PPUSH
102282: LD_INT 1
102284: PPUSH
102285: LD_INT 0
102287: PPUSH
102288: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102292: LD_VAR 0 2
102296: PPUSH
102297: LD_INT 2
102299: PPUSH
102300: LD_INT 0
102302: PPUSH
102303: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102307: LD_VAR 0 2
102311: PPUSH
102312: LD_INT 3
102314: PPUSH
102315: LD_INT 0
102317: PPUSH
102318: CALL_OW 277
// end ;
102322: PPOPN 2
102324: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102325: LD_EXP 124
102329: PUSH
102330: LD_EXP 152
102334: AND
102335: IFFALSE 102432
102337: GO 102339
102339: DISABLE
102340: LD_INT 0
102342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102343: LD_ADDR_VAR 0 1
102347: PUSH
102348: LD_INT 22
102350: PUSH
102351: LD_OWVAR 2
102355: PUSH
102356: EMPTY
102357: LIST
102358: LIST
102359: PUSH
102360: LD_INT 21
102362: PUSH
102363: LD_INT 1
102365: PUSH
102366: EMPTY
102367: LIST
102368: LIST
102369: PUSH
102370: LD_INT 3
102372: PUSH
102373: LD_INT 23
102375: PUSH
102376: LD_INT 0
102378: PUSH
102379: EMPTY
102380: LIST
102381: LIST
102382: PUSH
102383: EMPTY
102384: LIST
102385: LIST
102386: PUSH
102387: EMPTY
102388: LIST
102389: LIST
102390: LIST
102391: PPUSH
102392: CALL_OW 69
102396: ST_TO_ADDR
// if not tmp then
102397: LD_VAR 0 1
102401: NOT
102402: IFFALSE 102406
// exit ;
102404: GO 102432
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
102406: LD_VAR 0 1
102410: PUSH
102411: LD_INT 1
102413: PPUSH
102414: LD_VAR 0 1
102418: PPUSH
102419: CALL_OW 12
102423: ARRAY
102424: PPUSH
102425: LD_INT 200
102427: PPUSH
102428: CALL_OW 234
// end ;
102432: PPOPN 1
102434: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
102435: LD_EXP 124
102439: PUSH
102440: LD_EXP 153
102444: AND
102445: IFFALSE 102524
102447: GO 102449
102449: DISABLE
102450: LD_INT 0
102452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
102453: LD_ADDR_VAR 0 1
102457: PUSH
102458: LD_INT 22
102460: PUSH
102461: LD_OWVAR 2
102465: PUSH
102466: EMPTY
102467: LIST
102468: LIST
102469: PUSH
102470: LD_INT 21
102472: PUSH
102473: LD_INT 2
102475: PUSH
102476: EMPTY
102477: LIST
102478: LIST
102479: PUSH
102480: EMPTY
102481: LIST
102482: LIST
102483: PPUSH
102484: CALL_OW 69
102488: ST_TO_ADDR
// if not tmp then
102489: LD_VAR 0 1
102493: NOT
102494: IFFALSE 102498
// exit ;
102496: GO 102524
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102498: LD_VAR 0 1
102502: PUSH
102503: LD_INT 1
102505: PPUSH
102506: LD_VAR 0 1
102510: PPUSH
102511: CALL_OW 12
102515: ARRAY
102516: PPUSH
102517: LD_INT 60
102519: PPUSH
102520: CALL_OW 234
// end ;
102524: PPOPN 1
102526: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102527: LD_EXP 124
102531: PUSH
102532: LD_EXP 154
102536: AND
102537: IFFALSE 102636
102539: GO 102541
102541: DISABLE
102542: LD_INT 0
102544: PPUSH
102545: PPUSH
// begin enable ;
102546: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102547: LD_ADDR_VAR 0 1
102551: PUSH
102552: LD_INT 22
102554: PUSH
102555: LD_OWVAR 2
102559: PUSH
102560: EMPTY
102561: LIST
102562: LIST
102563: PUSH
102564: LD_INT 61
102566: PUSH
102567: EMPTY
102568: LIST
102569: PUSH
102570: LD_INT 33
102572: PUSH
102573: LD_INT 2
102575: PUSH
102576: EMPTY
102577: LIST
102578: LIST
102579: PUSH
102580: EMPTY
102581: LIST
102582: LIST
102583: LIST
102584: PPUSH
102585: CALL_OW 69
102589: ST_TO_ADDR
// if not tmp then
102590: LD_VAR 0 1
102594: NOT
102595: IFFALSE 102599
// exit ;
102597: GO 102636
// for i in tmp do
102599: LD_ADDR_VAR 0 2
102603: PUSH
102604: LD_VAR 0 1
102608: PUSH
102609: FOR_IN
102610: IFFALSE 102634
// if IsControledBy ( i ) then
102612: LD_VAR 0 2
102616: PPUSH
102617: CALL_OW 312
102621: IFFALSE 102632
// ComUnlink ( i ) ;
102623: LD_VAR 0 2
102627: PPUSH
102628: CALL_OW 136
102632: GO 102609
102634: POP
102635: POP
// end ;
102636: PPOPN 2
102638: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102639: LD_EXP 124
102643: PUSH
102644: LD_EXP 155
102648: AND
102649: IFFALSE 102789
102651: GO 102653
102653: DISABLE
102654: LD_INT 0
102656: PPUSH
102657: PPUSH
// begin ToLua ( displayPowell(); ) ;
102658: LD_STRING displayPowell();
102660: PPUSH
102661: CALL_OW 559
// uc_side := 0 ;
102665: LD_ADDR_OWVAR 20
102669: PUSH
102670: LD_INT 0
102672: ST_TO_ADDR
// uc_nation := 2 ;
102673: LD_ADDR_OWVAR 21
102677: PUSH
102678: LD_INT 2
102680: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102681: LD_ADDR_OWVAR 37
102685: PUSH
102686: LD_INT 14
102688: ST_TO_ADDR
// vc_engine := engine_siberite ;
102689: LD_ADDR_OWVAR 39
102693: PUSH
102694: LD_INT 3
102696: ST_TO_ADDR
// vc_control := control_apeman ;
102697: LD_ADDR_OWVAR 38
102701: PUSH
102702: LD_INT 5
102704: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102705: LD_ADDR_OWVAR 40
102709: PUSH
102710: LD_INT 29
102712: ST_TO_ADDR
// un := CreateVehicle ;
102713: LD_ADDR_VAR 0 2
102717: PUSH
102718: CALL_OW 45
102722: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102723: LD_VAR 0 2
102727: PPUSH
102728: LD_INT 1
102730: PPUSH
102731: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102735: LD_INT 35
102737: PPUSH
102738: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102742: LD_VAR 0 2
102746: PPUSH
102747: LD_INT 22
102749: PUSH
102750: LD_OWVAR 2
102754: PUSH
102755: EMPTY
102756: LIST
102757: LIST
102758: PPUSH
102759: CALL_OW 69
102763: PPUSH
102764: LD_VAR 0 2
102768: PPUSH
102769: CALL_OW 74
102773: PPUSH
102774: CALL_OW 115
// until IsDead ( un ) ;
102778: LD_VAR 0 2
102782: PPUSH
102783: CALL_OW 301
102787: IFFALSE 102735
// end ;
102789: PPOPN 2
102791: END
// every 0 0$1 trigger StreamModeActive and sStu do
102792: LD_EXP 124
102796: PUSH
102797: LD_EXP 163
102801: AND
102802: IFFALSE 102818
102804: GO 102806
102806: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102807: LD_STRING displayStucuk();
102809: PPUSH
102810: CALL_OW 559
// ResetFog ;
102814: CALL_OW 335
// end ;
102818: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102819: LD_EXP 124
102823: PUSH
102824: LD_EXP 156
102828: AND
102829: IFFALSE 102970
102831: GO 102833
102833: DISABLE
102834: LD_INT 0
102836: PPUSH
102837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102838: LD_ADDR_VAR 0 2
102842: PUSH
102843: LD_INT 22
102845: PUSH
102846: LD_OWVAR 2
102850: PUSH
102851: EMPTY
102852: LIST
102853: LIST
102854: PUSH
102855: LD_INT 21
102857: PUSH
102858: LD_INT 1
102860: PUSH
102861: EMPTY
102862: LIST
102863: LIST
102864: PUSH
102865: EMPTY
102866: LIST
102867: LIST
102868: PPUSH
102869: CALL_OW 69
102873: ST_TO_ADDR
// if not tmp then
102874: LD_VAR 0 2
102878: NOT
102879: IFFALSE 102883
// exit ;
102881: GO 102970
// un := tmp [ rand ( 1 , tmp ) ] ;
102883: LD_ADDR_VAR 0 1
102887: PUSH
102888: LD_VAR 0 2
102892: PUSH
102893: LD_INT 1
102895: PPUSH
102896: LD_VAR 0 2
102900: PPUSH
102901: CALL_OW 12
102905: ARRAY
102906: ST_TO_ADDR
// SetSide ( un , 0 ) ;
102907: LD_VAR 0 1
102911: PPUSH
102912: LD_INT 0
102914: PPUSH
102915: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
102919: LD_VAR 0 1
102923: PPUSH
102924: LD_OWVAR 3
102928: PUSH
102929: LD_VAR 0 1
102933: DIFF
102934: PPUSH
102935: LD_VAR 0 1
102939: PPUSH
102940: CALL_OW 74
102944: PPUSH
102945: CALL_OW 115
// wait ( 0 0$20 ) ;
102949: LD_INT 700
102951: PPUSH
102952: CALL_OW 67
// SetSide ( un , your_side ) ;
102956: LD_VAR 0 1
102960: PPUSH
102961: LD_OWVAR 2
102965: PPUSH
102966: CALL_OW 235
// end ;
102970: PPOPN 2
102972: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
102973: LD_EXP 124
102977: PUSH
102978: LD_EXP 157
102982: AND
102983: IFFALSE 103089
102985: GO 102987
102987: DISABLE
102988: LD_INT 0
102990: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102991: LD_ADDR_VAR 0 1
102995: PUSH
102996: LD_INT 22
102998: PUSH
102999: LD_OWVAR 2
103003: PUSH
103004: EMPTY
103005: LIST
103006: LIST
103007: PUSH
103008: LD_INT 2
103010: PUSH
103011: LD_INT 30
103013: PUSH
103014: LD_INT 0
103016: PUSH
103017: EMPTY
103018: LIST
103019: LIST
103020: PUSH
103021: LD_INT 30
103023: PUSH
103024: LD_INT 1
103026: PUSH
103027: EMPTY
103028: LIST
103029: LIST
103030: PUSH
103031: EMPTY
103032: LIST
103033: LIST
103034: LIST
103035: PUSH
103036: EMPTY
103037: LIST
103038: LIST
103039: PPUSH
103040: CALL_OW 69
103044: ST_TO_ADDR
// if not depot then
103045: LD_VAR 0 1
103049: NOT
103050: IFFALSE 103054
// exit ;
103052: GO 103089
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
103054: LD_VAR 0 1
103058: PUSH
103059: LD_INT 1
103061: ARRAY
103062: PPUSH
103063: CALL_OW 250
103067: PPUSH
103068: LD_VAR 0 1
103072: PUSH
103073: LD_INT 1
103075: ARRAY
103076: PPUSH
103077: CALL_OW 251
103081: PPUSH
103082: LD_INT 70
103084: PPUSH
103085: CALL_OW 495
// end ;
103089: PPOPN 1
103091: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
103092: LD_EXP 124
103096: PUSH
103097: LD_EXP 158
103101: AND
103102: IFFALSE 103313
103104: GO 103106
103106: DISABLE
103107: LD_INT 0
103109: PPUSH
103110: PPUSH
103111: PPUSH
103112: PPUSH
103113: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103114: LD_ADDR_VAR 0 5
103118: PUSH
103119: LD_INT 22
103121: PUSH
103122: LD_OWVAR 2
103126: PUSH
103127: EMPTY
103128: LIST
103129: LIST
103130: PUSH
103131: LD_INT 21
103133: PUSH
103134: LD_INT 1
103136: PUSH
103137: EMPTY
103138: LIST
103139: LIST
103140: PUSH
103141: EMPTY
103142: LIST
103143: LIST
103144: PPUSH
103145: CALL_OW 69
103149: ST_TO_ADDR
// if not tmp then
103150: LD_VAR 0 5
103154: NOT
103155: IFFALSE 103159
// exit ;
103157: GO 103313
// for i in tmp do
103159: LD_ADDR_VAR 0 1
103163: PUSH
103164: LD_VAR 0 5
103168: PUSH
103169: FOR_IN
103170: IFFALSE 103311
// begin d := rand ( 0 , 5 ) ;
103172: LD_ADDR_VAR 0 4
103176: PUSH
103177: LD_INT 0
103179: PPUSH
103180: LD_INT 5
103182: PPUSH
103183: CALL_OW 12
103187: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
103188: LD_ADDR_VAR 0 2
103192: PUSH
103193: LD_VAR 0 1
103197: PPUSH
103198: CALL_OW 250
103202: PPUSH
103203: LD_VAR 0 4
103207: PPUSH
103208: LD_INT 3
103210: PPUSH
103211: LD_INT 12
103213: PPUSH
103214: CALL_OW 12
103218: PPUSH
103219: CALL_OW 272
103223: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
103224: LD_ADDR_VAR 0 3
103228: PUSH
103229: LD_VAR 0 1
103233: PPUSH
103234: CALL_OW 251
103238: PPUSH
103239: LD_VAR 0 4
103243: PPUSH
103244: LD_INT 3
103246: PPUSH
103247: LD_INT 12
103249: PPUSH
103250: CALL_OW 12
103254: PPUSH
103255: CALL_OW 273
103259: ST_TO_ADDR
// if ValidHex ( x , y ) then
103260: LD_VAR 0 2
103264: PPUSH
103265: LD_VAR 0 3
103269: PPUSH
103270: CALL_OW 488
103274: IFFALSE 103309
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103276: LD_VAR 0 1
103280: PPUSH
103281: LD_VAR 0 2
103285: PPUSH
103286: LD_VAR 0 3
103290: PPUSH
103291: LD_INT 3
103293: PPUSH
103294: LD_INT 6
103296: PPUSH
103297: CALL_OW 12
103301: PPUSH
103302: LD_INT 1
103304: PPUSH
103305: CALL_OW 483
// end ;
103309: GO 103169
103311: POP
103312: POP
// end ;
103313: PPOPN 5
103315: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103316: LD_EXP 124
103320: PUSH
103321: LD_EXP 159
103325: AND
103326: IFFALSE 103420
103328: GO 103330
103330: DISABLE
103331: LD_INT 0
103333: PPUSH
103334: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103335: LD_ADDR_VAR 0 2
103339: PUSH
103340: LD_INT 22
103342: PUSH
103343: LD_OWVAR 2
103347: PUSH
103348: EMPTY
103349: LIST
103350: LIST
103351: PUSH
103352: LD_INT 32
103354: PUSH
103355: LD_INT 1
103357: PUSH
103358: EMPTY
103359: LIST
103360: LIST
103361: PUSH
103362: LD_INT 21
103364: PUSH
103365: LD_INT 2
103367: PUSH
103368: EMPTY
103369: LIST
103370: LIST
103371: PUSH
103372: EMPTY
103373: LIST
103374: LIST
103375: LIST
103376: PPUSH
103377: CALL_OW 69
103381: ST_TO_ADDR
// if not tmp then
103382: LD_VAR 0 2
103386: NOT
103387: IFFALSE 103391
// exit ;
103389: GO 103420
// for i in tmp do
103391: LD_ADDR_VAR 0 1
103395: PUSH
103396: LD_VAR 0 2
103400: PUSH
103401: FOR_IN
103402: IFFALSE 103418
// SetFuel ( i , 0 ) ;
103404: LD_VAR 0 1
103408: PPUSH
103409: LD_INT 0
103411: PPUSH
103412: CALL_OW 240
103416: GO 103401
103418: POP
103419: POP
// end ;
103420: PPOPN 2
103422: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
103423: LD_EXP 124
103427: PUSH
103428: LD_EXP 160
103432: AND
103433: IFFALSE 103499
103435: GO 103437
103437: DISABLE
103438: LD_INT 0
103440: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103441: LD_ADDR_VAR 0 1
103445: PUSH
103446: LD_INT 22
103448: PUSH
103449: LD_OWVAR 2
103453: PUSH
103454: EMPTY
103455: LIST
103456: LIST
103457: PUSH
103458: LD_INT 30
103460: PUSH
103461: LD_INT 29
103463: PUSH
103464: EMPTY
103465: LIST
103466: LIST
103467: PUSH
103468: EMPTY
103469: LIST
103470: LIST
103471: PPUSH
103472: CALL_OW 69
103476: ST_TO_ADDR
// if not tmp then
103477: LD_VAR 0 1
103481: NOT
103482: IFFALSE 103486
// exit ;
103484: GO 103499
// DestroyUnit ( tmp [ 1 ] ) ;
103486: LD_VAR 0 1
103490: PUSH
103491: LD_INT 1
103493: ARRAY
103494: PPUSH
103495: CALL_OW 65
// end ;
103499: PPOPN 1
103501: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103502: LD_EXP 124
103506: PUSH
103507: LD_EXP 162
103511: AND
103512: IFFALSE 103641
103514: GO 103516
103516: DISABLE
103517: LD_INT 0
103519: PPUSH
// begin uc_side := 0 ;
103520: LD_ADDR_OWVAR 20
103524: PUSH
103525: LD_INT 0
103527: ST_TO_ADDR
// uc_nation := nation_arabian ;
103528: LD_ADDR_OWVAR 21
103532: PUSH
103533: LD_INT 2
103535: ST_TO_ADDR
// hc_gallery :=  ;
103536: LD_ADDR_OWVAR 33
103540: PUSH
103541: LD_STRING 
103543: ST_TO_ADDR
// hc_name :=  ;
103544: LD_ADDR_OWVAR 26
103548: PUSH
103549: LD_STRING 
103551: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103552: LD_INT 1
103554: PPUSH
103555: LD_INT 11
103557: PPUSH
103558: LD_INT 10
103560: PPUSH
103561: CALL_OW 380
// un := CreateHuman ;
103565: LD_ADDR_VAR 0 1
103569: PUSH
103570: CALL_OW 44
103574: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103575: LD_VAR 0 1
103579: PPUSH
103580: LD_INT 1
103582: PPUSH
103583: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103587: LD_INT 35
103589: PPUSH
103590: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103594: LD_VAR 0 1
103598: PPUSH
103599: LD_INT 22
103601: PUSH
103602: LD_OWVAR 2
103606: PUSH
103607: EMPTY
103608: LIST
103609: LIST
103610: PPUSH
103611: CALL_OW 69
103615: PPUSH
103616: LD_VAR 0 1
103620: PPUSH
103621: CALL_OW 74
103625: PPUSH
103626: CALL_OW 115
// until IsDead ( un ) ;
103630: LD_VAR 0 1
103634: PPUSH
103635: CALL_OW 301
103639: IFFALSE 103587
// end ;
103641: PPOPN 1
103643: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103644: LD_EXP 124
103648: PUSH
103649: LD_EXP 164
103653: AND
103654: IFFALSE 103666
103656: GO 103658
103658: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103659: LD_STRING earthquake(getX(game), 0, 32)
103661: PPUSH
103662: CALL_OW 559
103666: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103667: LD_EXP 124
103671: PUSH
103672: LD_EXP 165
103676: AND
103677: IFFALSE 103768
103679: GO 103681
103681: DISABLE
103682: LD_INT 0
103684: PPUSH
// begin enable ;
103685: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103686: LD_ADDR_VAR 0 1
103690: PUSH
103691: LD_INT 22
103693: PUSH
103694: LD_OWVAR 2
103698: PUSH
103699: EMPTY
103700: LIST
103701: LIST
103702: PUSH
103703: LD_INT 21
103705: PUSH
103706: LD_INT 2
103708: PUSH
103709: EMPTY
103710: LIST
103711: LIST
103712: PUSH
103713: LD_INT 33
103715: PUSH
103716: LD_INT 3
103718: PUSH
103719: EMPTY
103720: LIST
103721: LIST
103722: PUSH
103723: EMPTY
103724: LIST
103725: LIST
103726: LIST
103727: PPUSH
103728: CALL_OW 69
103732: ST_TO_ADDR
// if not tmp then
103733: LD_VAR 0 1
103737: NOT
103738: IFFALSE 103742
// exit ;
103740: GO 103768
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103742: LD_VAR 0 1
103746: PUSH
103747: LD_INT 1
103749: PPUSH
103750: LD_VAR 0 1
103754: PPUSH
103755: CALL_OW 12
103759: ARRAY
103760: PPUSH
103761: LD_INT 1
103763: PPUSH
103764: CALL_OW 234
// end ;
103768: PPOPN 1
103770: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103771: LD_EXP 124
103775: PUSH
103776: LD_EXP 166
103780: AND
103781: IFFALSE 103922
103783: GO 103785
103785: DISABLE
103786: LD_INT 0
103788: PPUSH
103789: PPUSH
103790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103791: LD_ADDR_VAR 0 3
103795: PUSH
103796: LD_INT 22
103798: PUSH
103799: LD_OWVAR 2
103803: PUSH
103804: EMPTY
103805: LIST
103806: LIST
103807: PUSH
103808: LD_INT 25
103810: PUSH
103811: LD_INT 1
103813: PUSH
103814: EMPTY
103815: LIST
103816: LIST
103817: PUSH
103818: EMPTY
103819: LIST
103820: LIST
103821: PPUSH
103822: CALL_OW 69
103826: ST_TO_ADDR
// if not tmp then
103827: LD_VAR 0 3
103831: NOT
103832: IFFALSE 103836
// exit ;
103834: GO 103922
// un := tmp [ rand ( 1 , tmp ) ] ;
103836: LD_ADDR_VAR 0 2
103840: PUSH
103841: LD_VAR 0 3
103845: PUSH
103846: LD_INT 1
103848: PPUSH
103849: LD_VAR 0 3
103853: PPUSH
103854: CALL_OW 12
103858: ARRAY
103859: ST_TO_ADDR
// if Crawls ( un ) then
103860: LD_VAR 0 2
103864: PPUSH
103865: CALL_OW 318
103869: IFFALSE 103880
// ComWalk ( un ) ;
103871: LD_VAR 0 2
103875: PPUSH
103876: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
103880: LD_VAR 0 2
103884: PPUSH
103885: LD_INT 9
103887: PPUSH
103888: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
103892: LD_INT 28
103894: PPUSH
103895: LD_OWVAR 2
103899: PPUSH
103900: LD_INT 2
103902: PPUSH
103903: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
103907: LD_INT 29
103909: PPUSH
103910: LD_OWVAR 2
103914: PPUSH
103915: LD_INT 2
103917: PPUSH
103918: CALL_OW 322
// end ;
103922: PPOPN 3
103924: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
103925: LD_EXP 124
103929: PUSH
103930: LD_EXP 167
103934: AND
103935: IFFALSE 104046
103937: GO 103939
103939: DISABLE
103940: LD_INT 0
103942: PPUSH
103943: PPUSH
103944: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103945: LD_ADDR_VAR 0 3
103949: PUSH
103950: LD_INT 22
103952: PUSH
103953: LD_OWVAR 2
103957: PUSH
103958: EMPTY
103959: LIST
103960: LIST
103961: PUSH
103962: LD_INT 25
103964: PUSH
103965: LD_INT 1
103967: PUSH
103968: EMPTY
103969: LIST
103970: LIST
103971: PUSH
103972: EMPTY
103973: LIST
103974: LIST
103975: PPUSH
103976: CALL_OW 69
103980: ST_TO_ADDR
// if not tmp then
103981: LD_VAR 0 3
103985: NOT
103986: IFFALSE 103990
// exit ;
103988: GO 104046
// un := tmp [ rand ( 1 , tmp ) ] ;
103990: LD_ADDR_VAR 0 2
103994: PUSH
103995: LD_VAR 0 3
103999: PUSH
104000: LD_INT 1
104002: PPUSH
104003: LD_VAR 0 3
104007: PPUSH
104008: CALL_OW 12
104012: ARRAY
104013: ST_TO_ADDR
// if Crawls ( un ) then
104014: LD_VAR 0 2
104018: PPUSH
104019: CALL_OW 318
104023: IFFALSE 104034
// ComWalk ( un ) ;
104025: LD_VAR 0 2
104029: PPUSH
104030: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104034: LD_VAR 0 2
104038: PPUSH
104039: LD_INT 8
104041: PPUSH
104042: CALL_OW 336
// end ;
104046: PPOPN 3
104048: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
104049: LD_EXP 124
104053: PUSH
104054: LD_EXP 168
104058: AND
104059: IFFALSE 104203
104061: GO 104063
104063: DISABLE
104064: LD_INT 0
104066: PPUSH
104067: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
104068: LD_ADDR_VAR 0 2
104072: PUSH
104073: LD_INT 22
104075: PUSH
104076: LD_OWVAR 2
104080: PUSH
104081: EMPTY
104082: LIST
104083: LIST
104084: PUSH
104085: LD_INT 21
104087: PUSH
104088: LD_INT 2
104090: PUSH
104091: EMPTY
104092: LIST
104093: LIST
104094: PUSH
104095: LD_INT 2
104097: PUSH
104098: LD_INT 34
104100: PUSH
104101: LD_INT 12
104103: PUSH
104104: EMPTY
104105: LIST
104106: LIST
104107: PUSH
104108: LD_INT 34
104110: PUSH
104111: LD_INT 51
104113: PUSH
104114: EMPTY
104115: LIST
104116: LIST
104117: PUSH
104118: LD_INT 34
104120: PUSH
104121: LD_INT 32
104123: PUSH
104124: EMPTY
104125: LIST
104126: LIST
104127: PUSH
104128: EMPTY
104129: LIST
104130: LIST
104131: LIST
104132: LIST
104133: PUSH
104134: EMPTY
104135: LIST
104136: LIST
104137: LIST
104138: PPUSH
104139: CALL_OW 69
104143: ST_TO_ADDR
// if not tmp then
104144: LD_VAR 0 2
104148: NOT
104149: IFFALSE 104153
// exit ;
104151: GO 104203
// for i in tmp do
104153: LD_ADDR_VAR 0 1
104157: PUSH
104158: LD_VAR 0 2
104162: PUSH
104163: FOR_IN
104164: IFFALSE 104201
// if GetCargo ( i , mat_artifact ) = 0 then
104166: LD_VAR 0 1
104170: PPUSH
104171: LD_INT 4
104173: PPUSH
104174: CALL_OW 289
104178: PUSH
104179: LD_INT 0
104181: EQUAL
104182: IFFALSE 104199
// SetCargo ( i , mat_siberit , 100 ) ;
104184: LD_VAR 0 1
104188: PPUSH
104189: LD_INT 3
104191: PPUSH
104192: LD_INT 100
104194: PPUSH
104195: CALL_OW 290
104199: GO 104163
104201: POP
104202: POP
// end ;
104203: PPOPN 2
104205: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
104206: LD_EXP 124
104210: PUSH
104211: LD_EXP 169
104215: AND
104216: IFFALSE 104399
104218: GO 104220
104220: DISABLE
104221: LD_INT 0
104223: PPUSH
104224: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104225: LD_ADDR_VAR 0 2
104229: PUSH
104230: LD_INT 22
104232: PUSH
104233: LD_OWVAR 2
104237: PUSH
104238: EMPTY
104239: LIST
104240: LIST
104241: PPUSH
104242: CALL_OW 69
104246: ST_TO_ADDR
// if not tmp then
104247: LD_VAR 0 2
104251: NOT
104252: IFFALSE 104256
// exit ;
104254: GO 104399
// for i := 1 to 2 do
104256: LD_ADDR_VAR 0 1
104260: PUSH
104261: DOUBLE
104262: LD_INT 1
104264: DEC
104265: ST_TO_ADDR
104266: LD_INT 2
104268: PUSH
104269: FOR_TO
104270: IFFALSE 104397
// begin uc_side := your_side ;
104272: LD_ADDR_OWVAR 20
104276: PUSH
104277: LD_OWVAR 2
104281: ST_TO_ADDR
// uc_nation := nation_american ;
104282: LD_ADDR_OWVAR 21
104286: PUSH
104287: LD_INT 1
104289: ST_TO_ADDR
// vc_chassis := us_morphling ;
104290: LD_ADDR_OWVAR 37
104294: PUSH
104295: LD_INT 5
104297: ST_TO_ADDR
// vc_engine := engine_siberite ;
104298: LD_ADDR_OWVAR 39
104302: PUSH
104303: LD_INT 3
104305: ST_TO_ADDR
// vc_control := control_computer ;
104306: LD_ADDR_OWVAR 38
104310: PUSH
104311: LD_INT 3
104313: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104314: LD_ADDR_OWVAR 40
104318: PUSH
104319: LD_INT 10
104321: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104322: LD_VAR 0 2
104326: PUSH
104327: LD_INT 1
104329: ARRAY
104330: PPUSH
104331: CALL_OW 310
104335: NOT
104336: IFFALSE 104383
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104338: CALL_OW 45
104342: PPUSH
104343: LD_VAR 0 2
104347: PUSH
104348: LD_INT 1
104350: ARRAY
104351: PPUSH
104352: CALL_OW 250
104356: PPUSH
104357: LD_VAR 0 2
104361: PUSH
104362: LD_INT 1
104364: ARRAY
104365: PPUSH
104366: CALL_OW 251
104370: PPUSH
104371: LD_INT 12
104373: PPUSH
104374: LD_INT 1
104376: PPUSH
104377: CALL_OW 50
104381: GO 104395
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104383: CALL_OW 45
104387: PPUSH
104388: LD_INT 1
104390: PPUSH
104391: CALL_OW 51
// end ;
104395: GO 104269
104397: POP
104398: POP
// end ;
104399: PPOPN 2
104401: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
104402: LD_EXP 124
104406: PUSH
104407: LD_EXP 170
104411: AND
104412: IFFALSE 104634
104414: GO 104416
104416: DISABLE
104417: LD_INT 0
104419: PPUSH
104420: PPUSH
104421: PPUSH
104422: PPUSH
104423: PPUSH
104424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104425: LD_ADDR_VAR 0 6
104429: PUSH
104430: LD_INT 22
104432: PUSH
104433: LD_OWVAR 2
104437: PUSH
104438: EMPTY
104439: LIST
104440: LIST
104441: PUSH
104442: LD_INT 21
104444: PUSH
104445: LD_INT 1
104447: PUSH
104448: EMPTY
104449: LIST
104450: LIST
104451: PUSH
104452: LD_INT 3
104454: PUSH
104455: LD_INT 23
104457: PUSH
104458: LD_INT 0
104460: PUSH
104461: EMPTY
104462: LIST
104463: LIST
104464: PUSH
104465: EMPTY
104466: LIST
104467: LIST
104468: PUSH
104469: EMPTY
104470: LIST
104471: LIST
104472: LIST
104473: PPUSH
104474: CALL_OW 69
104478: ST_TO_ADDR
// if not tmp then
104479: LD_VAR 0 6
104483: NOT
104484: IFFALSE 104488
// exit ;
104486: GO 104634
// s1 := rand ( 1 , 4 ) ;
104488: LD_ADDR_VAR 0 2
104492: PUSH
104493: LD_INT 1
104495: PPUSH
104496: LD_INT 4
104498: PPUSH
104499: CALL_OW 12
104503: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104504: LD_ADDR_VAR 0 4
104508: PUSH
104509: LD_VAR 0 6
104513: PUSH
104514: LD_INT 1
104516: ARRAY
104517: PPUSH
104518: LD_VAR 0 2
104522: PPUSH
104523: CALL_OW 259
104527: ST_TO_ADDR
// if s1 = 1 then
104528: LD_VAR 0 2
104532: PUSH
104533: LD_INT 1
104535: EQUAL
104536: IFFALSE 104556
// s2 := rand ( 2 , 4 ) else
104538: LD_ADDR_VAR 0 3
104542: PUSH
104543: LD_INT 2
104545: PPUSH
104546: LD_INT 4
104548: PPUSH
104549: CALL_OW 12
104553: ST_TO_ADDR
104554: GO 104564
// s2 := 1 ;
104556: LD_ADDR_VAR 0 3
104560: PUSH
104561: LD_INT 1
104563: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104564: LD_ADDR_VAR 0 5
104568: PUSH
104569: LD_VAR 0 6
104573: PUSH
104574: LD_INT 1
104576: ARRAY
104577: PPUSH
104578: LD_VAR 0 3
104582: PPUSH
104583: CALL_OW 259
104587: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104588: LD_VAR 0 6
104592: PUSH
104593: LD_INT 1
104595: ARRAY
104596: PPUSH
104597: LD_VAR 0 2
104601: PPUSH
104602: LD_VAR 0 5
104606: PPUSH
104607: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104611: LD_VAR 0 6
104615: PUSH
104616: LD_INT 1
104618: ARRAY
104619: PPUSH
104620: LD_VAR 0 3
104624: PPUSH
104625: LD_VAR 0 4
104629: PPUSH
104630: CALL_OW 237
// end ;
104634: PPOPN 6
104636: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104637: LD_EXP 124
104641: PUSH
104642: LD_EXP 171
104646: AND
104647: IFFALSE 104726
104649: GO 104651
104651: DISABLE
104652: LD_INT 0
104654: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104655: LD_ADDR_VAR 0 1
104659: PUSH
104660: LD_INT 22
104662: PUSH
104663: LD_OWVAR 2
104667: PUSH
104668: EMPTY
104669: LIST
104670: LIST
104671: PUSH
104672: LD_INT 30
104674: PUSH
104675: LD_INT 3
104677: PUSH
104678: EMPTY
104679: LIST
104680: LIST
104681: PUSH
104682: EMPTY
104683: LIST
104684: LIST
104685: PPUSH
104686: CALL_OW 69
104690: ST_TO_ADDR
// if not tmp then
104691: LD_VAR 0 1
104695: NOT
104696: IFFALSE 104700
// exit ;
104698: GO 104726
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104700: LD_VAR 0 1
104704: PUSH
104705: LD_INT 1
104707: PPUSH
104708: LD_VAR 0 1
104712: PPUSH
104713: CALL_OW 12
104717: ARRAY
104718: PPUSH
104719: LD_INT 1
104721: PPUSH
104722: CALL_OW 234
// end ;
104726: PPOPN 1
104728: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104729: LD_EXP 124
104733: PUSH
104734: LD_EXP 172
104738: AND
104739: IFFALSE 104851
104741: GO 104743
104743: DISABLE
104744: LD_INT 0
104746: PPUSH
104747: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104748: LD_ADDR_VAR 0 2
104752: PUSH
104753: LD_INT 22
104755: PUSH
104756: LD_OWVAR 2
104760: PUSH
104761: EMPTY
104762: LIST
104763: LIST
104764: PUSH
104765: LD_INT 2
104767: PUSH
104768: LD_INT 30
104770: PUSH
104771: LD_INT 27
104773: PUSH
104774: EMPTY
104775: LIST
104776: LIST
104777: PUSH
104778: LD_INT 30
104780: PUSH
104781: LD_INT 26
104783: PUSH
104784: EMPTY
104785: LIST
104786: LIST
104787: PUSH
104788: LD_INT 30
104790: PUSH
104791: LD_INT 28
104793: PUSH
104794: EMPTY
104795: LIST
104796: LIST
104797: PUSH
104798: EMPTY
104799: LIST
104800: LIST
104801: LIST
104802: LIST
104803: PUSH
104804: EMPTY
104805: LIST
104806: LIST
104807: PPUSH
104808: CALL_OW 69
104812: ST_TO_ADDR
// if not tmp then
104813: LD_VAR 0 2
104817: NOT
104818: IFFALSE 104822
// exit ;
104820: GO 104851
// for i in tmp do
104822: LD_ADDR_VAR 0 1
104826: PUSH
104827: LD_VAR 0 2
104831: PUSH
104832: FOR_IN
104833: IFFALSE 104849
// SetLives ( i , 1 ) ;
104835: LD_VAR 0 1
104839: PPUSH
104840: LD_INT 1
104842: PPUSH
104843: CALL_OW 234
104847: GO 104832
104849: POP
104850: POP
// end ;
104851: PPOPN 2
104853: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
104854: LD_EXP 124
104858: PUSH
104859: LD_EXP 173
104863: AND
104864: IFFALSE 105151
104866: GO 104868
104868: DISABLE
104869: LD_INT 0
104871: PPUSH
104872: PPUSH
104873: PPUSH
// begin i := rand ( 1 , 7 ) ;
104874: LD_ADDR_VAR 0 1
104878: PUSH
104879: LD_INT 1
104881: PPUSH
104882: LD_INT 7
104884: PPUSH
104885: CALL_OW 12
104889: ST_TO_ADDR
// case i of 1 :
104890: LD_VAR 0 1
104894: PUSH
104895: LD_INT 1
104897: DOUBLE
104898: EQUAL
104899: IFTRUE 104903
104901: GO 104913
104903: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
104904: LD_STRING earthquake(getX(game), 0, 32)
104906: PPUSH
104907: CALL_OW 559
104911: GO 105151
104913: LD_INT 2
104915: DOUBLE
104916: EQUAL
104917: IFTRUE 104921
104919: GO 104935
104921: POP
// begin ToLua ( displayStucuk(); ) ;
104922: LD_STRING displayStucuk();
104924: PPUSH
104925: CALL_OW 559
// ResetFog ;
104929: CALL_OW 335
// end ; 3 :
104933: GO 105151
104935: LD_INT 3
104937: DOUBLE
104938: EQUAL
104939: IFTRUE 104943
104941: GO 105047
104943: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104944: LD_ADDR_VAR 0 2
104948: PUSH
104949: LD_INT 22
104951: PUSH
104952: LD_OWVAR 2
104956: PUSH
104957: EMPTY
104958: LIST
104959: LIST
104960: PUSH
104961: LD_INT 25
104963: PUSH
104964: LD_INT 1
104966: PUSH
104967: EMPTY
104968: LIST
104969: LIST
104970: PUSH
104971: EMPTY
104972: LIST
104973: LIST
104974: PPUSH
104975: CALL_OW 69
104979: ST_TO_ADDR
// if not tmp then
104980: LD_VAR 0 2
104984: NOT
104985: IFFALSE 104989
// exit ;
104987: GO 105151
// un := tmp [ rand ( 1 , tmp ) ] ;
104989: LD_ADDR_VAR 0 3
104993: PUSH
104994: LD_VAR 0 2
104998: PUSH
104999: LD_INT 1
105001: PPUSH
105002: LD_VAR 0 2
105006: PPUSH
105007: CALL_OW 12
105011: ARRAY
105012: ST_TO_ADDR
// if Crawls ( un ) then
105013: LD_VAR 0 3
105017: PPUSH
105018: CALL_OW 318
105022: IFFALSE 105033
// ComWalk ( un ) ;
105024: LD_VAR 0 3
105028: PPUSH
105029: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105033: LD_VAR 0 3
105037: PPUSH
105038: LD_INT 8
105040: PPUSH
105041: CALL_OW 336
// end ; 4 :
105045: GO 105151
105047: LD_INT 4
105049: DOUBLE
105050: EQUAL
105051: IFTRUE 105055
105053: GO 105129
105055: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105056: LD_ADDR_VAR 0 2
105060: PUSH
105061: LD_INT 22
105063: PUSH
105064: LD_OWVAR 2
105068: PUSH
105069: EMPTY
105070: LIST
105071: LIST
105072: PUSH
105073: LD_INT 30
105075: PUSH
105076: LD_INT 29
105078: PUSH
105079: EMPTY
105080: LIST
105081: LIST
105082: PUSH
105083: EMPTY
105084: LIST
105085: LIST
105086: PPUSH
105087: CALL_OW 69
105091: ST_TO_ADDR
// if not tmp then
105092: LD_VAR 0 2
105096: NOT
105097: IFFALSE 105101
// exit ;
105099: GO 105151
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105101: LD_VAR 0 2
105105: PUSH
105106: LD_INT 1
105108: ARRAY
105109: PPUSH
105110: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105114: LD_VAR 0 2
105118: PUSH
105119: LD_INT 1
105121: ARRAY
105122: PPUSH
105123: CALL_OW 65
// end ; 5 .. 7 :
105127: GO 105151
105129: LD_INT 5
105131: DOUBLE
105132: GREATEREQUAL
105133: IFFALSE 105141
105135: LD_INT 7
105137: DOUBLE
105138: LESSEQUAL
105139: IFTRUE 105143
105141: GO 105150
105143: POP
// StreamSibBomb ; end ;
105144: CALL 101388 0 0
105148: GO 105151
105150: POP
// end ;
105151: PPOPN 3
105153: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105154: LD_EXP 124
105158: PUSH
105159: LD_EXP 174
105163: AND
105164: IFFALSE 105320
105166: GO 105168
105168: DISABLE
105169: LD_INT 0
105171: PPUSH
105172: PPUSH
105173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
105174: LD_ADDR_VAR 0 2
105178: PUSH
105179: LD_INT 81
105181: PUSH
105182: LD_OWVAR 2
105186: PUSH
105187: EMPTY
105188: LIST
105189: LIST
105190: PUSH
105191: LD_INT 2
105193: PUSH
105194: LD_INT 21
105196: PUSH
105197: LD_INT 1
105199: PUSH
105200: EMPTY
105201: LIST
105202: LIST
105203: PUSH
105204: LD_INT 21
105206: PUSH
105207: LD_INT 2
105209: PUSH
105210: EMPTY
105211: LIST
105212: LIST
105213: PUSH
105214: EMPTY
105215: LIST
105216: LIST
105217: LIST
105218: PUSH
105219: EMPTY
105220: LIST
105221: LIST
105222: PPUSH
105223: CALL_OW 69
105227: ST_TO_ADDR
// if not tmp then
105228: LD_VAR 0 2
105232: NOT
105233: IFFALSE 105237
// exit ;
105235: GO 105320
// p := 0 ;
105237: LD_ADDR_VAR 0 3
105241: PUSH
105242: LD_INT 0
105244: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105245: LD_INT 35
105247: PPUSH
105248: CALL_OW 67
// p := p + 1 ;
105252: LD_ADDR_VAR 0 3
105256: PUSH
105257: LD_VAR 0 3
105261: PUSH
105262: LD_INT 1
105264: PLUS
105265: ST_TO_ADDR
// for i in tmp do
105266: LD_ADDR_VAR 0 1
105270: PUSH
105271: LD_VAR 0 2
105275: PUSH
105276: FOR_IN
105277: IFFALSE 105308
// if GetLives ( i ) < 1000 then
105279: LD_VAR 0 1
105283: PPUSH
105284: CALL_OW 256
105288: PUSH
105289: LD_INT 1000
105291: LESS
105292: IFFALSE 105306
// SetLives ( i , 1000 ) ;
105294: LD_VAR 0 1
105298: PPUSH
105299: LD_INT 1000
105301: PPUSH
105302: CALL_OW 234
105306: GO 105276
105308: POP
105309: POP
// until p > 20 ;
105310: LD_VAR 0 3
105314: PUSH
105315: LD_INT 20
105317: GREATER
105318: IFFALSE 105245
// end ;
105320: PPOPN 3
105322: END
// every 0 0$1 trigger StreamModeActive and sTime do
105323: LD_EXP 124
105327: PUSH
105328: LD_EXP 175
105332: AND
105333: IFFALSE 105368
105335: GO 105337
105337: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105338: LD_INT 28
105340: PPUSH
105341: LD_OWVAR 2
105345: PPUSH
105346: LD_INT 2
105348: PPUSH
105349: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105353: LD_INT 30
105355: PPUSH
105356: LD_OWVAR 2
105360: PPUSH
105361: LD_INT 2
105363: PPUSH
105364: CALL_OW 322
// end ;
105368: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105369: LD_EXP 124
105373: PUSH
105374: LD_EXP 176
105378: AND
105379: IFFALSE 105500
105381: GO 105383
105383: DISABLE
105384: LD_INT 0
105386: PPUSH
105387: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105388: LD_ADDR_VAR 0 2
105392: PUSH
105393: LD_INT 22
105395: PUSH
105396: LD_OWVAR 2
105400: PUSH
105401: EMPTY
105402: LIST
105403: LIST
105404: PUSH
105405: LD_INT 21
105407: PUSH
105408: LD_INT 1
105410: PUSH
105411: EMPTY
105412: LIST
105413: LIST
105414: PUSH
105415: LD_INT 3
105417: PUSH
105418: LD_INT 23
105420: PUSH
105421: LD_INT 0
105423: PUSH
105424: EMPTY
105425: LIST
105426: LIST
105427: PUSH
105428: EMPTY
105429: LIST
105430: LIST
105431: PUSH
105432: EMPTY
105433: LIST
105434: LIST
105435: LIST
105436: PPUSH
105437: CALL_OW 69
105441: ST_TO_ADDR
// if not tmp then
105442: LD_VAR 0 2
105446: NOT
105447: IFFALSE 105451
// exit ;
105449: GO 105500
// for i in tmp do
105451: LD_ADDR_VAR 0 1
105455: PUSH
105456: LD_VAR 0 2
105460: PUSH
105461: FOR_IN
105462: IFFALSE 105498
// begin if Crawls ( i ) then
105464: LD_VAR 0 1
105468: PPUSH
105469: CALL_OW 318
105473: IFFALSE 105484
// ComWalk ( i ) ;
105475: LD_VAR 0 1
105479: PPUSH
105480: CALL_OW 138
// SetClass ( i , 2 ) ;
105484: LD_VAR 0 1
105488: PPUSH
105489: LD_INT 2
105491: PPUSH
105492: CALL_OW 336
// end ;
105496: GO 105461
105498: POP
105499: POP
// end ;
105500: PPOPN 2
105502: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105503: LD_EXP 124
105507: PUSH
105508: LD_EXP 177
105512: AND
105513: IFFALSE 105801
105515: GO 105517
105517: DISABLE
105518: LD_INT 0
105520: PPUSH
105521: PPUSH
105522: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105523: LD_OWVAR 2
105527: PPUSH
105528: LD_INT 9
105530: PPUSH
105531: LD_INT 1
105533: PPUSH
105534: LD_INT 1
105536: PPUSH
105537: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105541: LD_INT 9
105543: PPUSH
105544: LD_OWVAR 2
105548: PPUSH
105549: CALL_OW 343
// uc_side := 9 ;
105553: LD_ADDR_OWVAR 20
105557: PUSH
105558: LD_INT 9
105560: ST_TO_ADDR
// uc_nation := 2 ;
105561: LD_ADDR_OWVAR 21
105565: PUSH
105566: LD_INT 2
105568: ST_TO_ADDR
// hc_name := Dark Warrior ;
105569: LD_ADDR_OWVAR 26
105573: PUSH
105574: LD_STRING Dark Warrior
105576: ST_TO_ADDR
// hc_gallery :=  ;
105577: LD_ADDR_OWVAR 33
105581: PUSH
105582: LD_STRING 
105584: ST_TO_ADDR
// hc_noskilllimit := true ;
105585: LD_ADDR_OWVAR 76
105589: PUSH
105590: LD_INT 1
105592: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105593: LD_ADDR_OWVAR 31
105597: PUSH
105598: LD_INT 30
105600: PUSH
105601: LD_INT 30
105603: PUSH
105604: LD_INT 30
105606: PUSH
105607: LD_INT 30
105609: PUSH
105610: EMPTY
105611: LIST
105612: LIST
105613: LIST
105614: LIST
105615: ST_TO_ADDR
// un := CreateHuman ;
105616: LD_ADDR_VAR 0 3
105620: PUSH
105621: CALL_OW 44
105625: ST_TO_ADDR
// hc_noskilllimit := false ;
105626: LD_ADDR_OWVAR 76
105630: PUSH
105631: LD_INT 0
105633: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105634: LD_VAR 0 3
105638: PPUSH
105639: LD_INT 1
105641: PPUSH
105642: CALL_OW 51
// ToLua ( playRanger() ) ;
105646: LD_STRING playRanger()
105648: PPUSH
105649: CALL_OW 559
// p := 0 ;
105653: LD_ADDR_VAR 0 2
105657: PUSH
105658: LD_INT 0
105660: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105661: LD_INT 35
105663: PPUSH
105664: CALL_OW 67
// p := p + 1 ;
105668: LD_ADDR_VAR 0 2
105672: PUSH
105673: LD_VAR 0 2
105677: PUSH
105678: LD_INT 1
105680: PLUS
105681: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105682: LD_VAR 0 3
105686: PPUSH
105687: CALL_OW 256
105691: PUSH
105692: LD_INT 1000
105694: LESS
105695: IFFALSE 105709
// SetLives ( un , 1000 ) ;
105697: LD_VAR 0 3
105701: PPUSH
105702: LD_INT 1000
105704: PPUSH
105705: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105709: LD_VAR 0 3
105713: PPUSH
105714: LD_INT 81
105716: PUSH
105717: LD_OWVAR 2
105721: PUSH
105722: EMPTY
105723: LIST
105724: LIST
105725: PUSH
105726: LD_INT 91
105728: PUSH
105729: LD_VAR 0 3
105733: PUSH
105734: LD_INT 30
105736: PUSH
105737: EMPTY
105738: LIST
105739: LIST
105740: LIST
105741: PUSH
105742: EMPTY
105743: LIST
105744: LIST
105745: PPUSH
105746: CALL_OW 69
105750: PPUSH
105751: LD_VAR 0 3
105755: PPUSH
105756: CALL_OW 74
105760: PPUSH
105761: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105765: LD_VAR 0 2
105769: PUSH
105770: LD_INT 80
105772: GREATER
105773: PUSH
105774: LD_VAR 0 3
105778: PPUSH
105779: CALL_OW 301
105783: OR
105784: IFFALSE 105661
// if un then
105786: LD_VAR 0 3
105790: IFFALSE 105801
// RemoveUnit ( un ) ;
105792: LD_VAR 0 3
105796: PPUSH
105797: CALL_OW 64
// end ;
105801: PPOPN 3
105803: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105804: LD_EXP 178
105808: IFFALSE 105924
105810: GO 105812
105812: DISABLE
105813: LD_INT 0
105815: PPUSH
105816: PPUSH
105817: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105818: LD_ADDR_VAR 0 2
105822: PUSH
105823: LD_INT 81
105825: PUSH
105826: LD_OWVAR 2
105830: PUSH
105831: EMPTY
105832: LIST
105833: LIST
105834: PUSH
105835: LD_INT 21
105837: PUSH
105838: LD_INT 1
105840: PUSH
105841: EMPTY
105842: LIST
105843: LIST
105844: PUSH
105845: EMPTY
105846: LIST
105847: LIST
105848: PPUSH
105849: CALL_OW 69
105853: ST_TO_ADDR
// ToLua ( playComputer() ) ;
105854: LD_STRING playComputer()
105856: PPUSH
105857: CALL_OW 559
// if not tmp then
105861: LD_VAR 0 2
105865: NOT
105866: IFFALSE 105870
// exit ;
105868: GO 105924
// for i in tmp do
105870: LD_ADDR_VAR 0 1
105874: PUSH
105875: LD_VAR 0 2
105879: PUSH
105880: FOR_IN
105881: IFFALSE 105922
// for j := 1 to 4 do
105883: LD_ADDR_VAR 0 3
105887: PUSH
105888: DOUBLE
105889: LD_INT 1
105891: DEC
105892: ST_TO_ADDR
105893: LD_INT 4
105895: PUSH
105896: FOR_TO
105897: IFFALSE 105918
// SetSkill ( i , j , 10 ) ;
105899: LD_VAR 0 1
105903: PPUSH
105904: LD_VAR 0 3
105908: PPUSH
105909: LD_INT 10
105911: PPUSH
105912: CALL_OW 237
105916: GO 105896
105918: POP
105919: POP
105920: GO 105880
105922: POP
105923: POP
// end ;
105924: PPOPN 3
105926: END
// every 0 0$1 trigger s30 do var i , tmp ;
105927: LD_EXP 179
105931: IFFALSE 106000
105933: GO 105935
105935: DISABLE
105936: LD_INT 0
105938: PPUSH
105939: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105940: LD_ADDR_VAR 0 2
105944: PUSH
105945: LD_INT 22
105947: PUSH
105948: LD_OWVAR 2
105952: PUSH
105953: EMPTY
105954: LIST
105955: LIST
105956: PPUSH
105957: CALL_OW 69
105961: ST_TO_ADDR
// if not tmp then
105962: LD_VAR 0 2
105966: NOT
105967: IFFALSE 105971
// exit ;
105969: GO 106000
// for i in tmp do
105971: LD_ADDR_VAR 0 1
105975: PUSH
105976: LD_VAR 0 2
105980: PUSH
105981: FOR_IN
105982: IFFALSE 105998
// SetLives ( i , 300 ) ;
105984: LD_VAR 0 1
105988: PPUSH
105989: LD_INT 300
105991: PPUSH
105992: CALL_OW 234
105996: GO 105981
105998: POP
105999: POP
// end ;
106000: PPOPN 2
106002: END
// every 0 0$1 trigger s60 do var i , tmp ;
106003: LD_EXP 180
106007: IFFALSE 106076
106009: GO 106011
106011: DISABLE
106012: LD_INT 0
106014: PPUSH
106015: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106016: LD_ADDR_VAR 0 2
106020: PUSH
106021: LD_INT 22
106023: PUSH
106024: LD_OWVAR 2
106028: PUSH
106029: EMPTY
106030: LIST
106031: LIST
106032: PPUSH
106033: CALL_OW 69
106037: ST_TO_ADDR
// if not tmp then
106038: LD_VAR 0 2
106042: NOT
106043: IFFALSE 106047
// exit ;
106045: GO 106076
// for i in tmp do
106047: LD_ADDR_VAR 0 1
106051: PUSH
106052: LD_VAR 0 2
106056: PUSH
106057: FOR_IN
106058: IFFALSE 106074
// SetLives ( i , 600 ) ;
106060: LD_VAR 0 1
106064: PPUSH
106065: LD_INT 600
106067: PPUSH
106068: CALL_OW 234
106072: GO 106057
106074: POP
106075: POP
// end ;
106076: PPOPN 2
106078: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106079: LD_INT 0
106081: PPUSH
// case cmd of 301 :
106082: LD_VAR 0 1
106086: PUSH
106087: LD_INT 301
106089: DOUBLE
106090: EQUAL
106091: IFTRUE 106095
106093: GO 106127
106095: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106096: LD_VAR 0 6
106100: PPUSH
106101: LD_VAR 0 7
106105: PPUSH
106106: LD_VAR 0 8
106110: PPUSH
106111: LD_VAR 0 4
106115: PPUSH
106116: LD_VAR 0 5
106120: PPUSH
106121: CALL 107328 0 5
106125: GO 106248
106127: LD_INT 302
106129: DOUBLE
106130: EQUAL
106131: IFTRUE 106135
106133: GO 106172
106135: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106136: LD_VAR 0 6
106140: PPUSH
106141: LD_VAR 0 7
106145: PPUSH
106146: LD_VAR 0 8
106150: PPUSH
106151: LD_VAR 0 9
106155: PPUSH
106156: LD_VAR 0 4
106160: PPUSH
106161: LD_VAR 0 5
106165: PPUSH
106166: CALL 107419 0 6
106170: GO 106248
106172: LD_INT 303
106174: DOUBLE
106175: EQUAL
106176: IFTRUE 106180
106178: GO 106217
106180: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
106181: LD_VAR 0 6
106185: PPUSH
106186: LD_VAR 0 7
106190: PPUSH
106191: LD_VAR 0 8
106195: PPUSH
106196: LD_VAR 0 9
106200: PPUSH
106201: LD_VAR 0 4
106205: PPUSH
106206: LD_VAR 0 5
106210: PPUSH
106211: CALL 106253 0 6
106215: GO 106248
106217: LD_INT 304
106219: DOUBLE
106220: EQUAL
106221: IFTRUE 106225
106223: GO 106247
106225: POP
// hHackTeleport ( unit , x , y ) ; end ;
106226: LD_VAR 0 2
106230: PPUSH
106231: LD_VAR 0 4
106235: PPUSH
106236: LD_VAR 0 5
106240: PPUSH
106241: CALL 108012 0 3
106245: GO 106248
106247: POP
// end ;
106248: LD_VAR 0 12
106252: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106253: LD_INT 0
106255: PPUSH
106256: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106257: LD_VAR 0 1
106261: PUSH
106262: LD_INT 1
106264: LESS
106265: PUSH
106266: LD_VAR 0 1
106270: PUSH
106271: LD_INT 3
106273: GREATER
106274: OR
106275: PUSH
106276: LD_VAR 0 5
106280: PPUSH
106281: LD_VAR 0 6
106285: PPUSH
106286: CALL_OW 428
106290: OR
106291: IFFALSE 106295
// exit ;
106293: GO 107015
// uc_side := your_side ;
106295: LD_ADDR_OWVAR 20
106299: PUSH
106300: LD_OWVAR 2
106304: ST_TO_ADDR
// uc_nation := nation ;
106305: LD_ADDR_OWVAR 21
106309: PUSH
106310: LD_VAR 0 1
106314: ST_TO_ADDR
// bc_level = 1 ;
106315: LD_ADDR_OWVAR 43
106319: PUSH
106320: LD_INT 1
106322: ST_TO_ADDR
// case btype of 1 :
106323: LD_VAR 0 2
106327: PUSH
106328: LD_INT 1
106330: DOUBLE
106331: EQUAL
106332: IFTRUE 106336
106334: GO 106347
106336: POP
// bc_type := b_depot ; 2 :
106337: LD_ADDR_OWVAR 42
106341: PUSH
106342: LD_INT 0
106344: ST_TO_ADDR
106345: GO 106959
106347: LD_INT 2
106349: DOUBLE
106350: EQUAL
106351: IFTRUE 106355
106353: GO 106366
106355: POP
// bc_type := b_warehouse ; 3 :
106356: LD_ADDR_OWVAR 42
106360: PUSH
106361: LD_INT 1
106363: ST_TO_ADDR
106364: GO 106959
106366: LD_INT 3
106368: DOUBLE
106369: EQUAL
106370: IFTRUE 106374
106372: GO 106385
106374: POP
// bc_type := b_lab ; 4 .. 9 :
106375: LD_ADDR_OWVAR 42
106379: PUSH
106380: LD_INT 6
106382: ST_TO_ADDR
106383: GO 106959
106385: LD_INT 4
106387: DOUBLE
106388: GREATEREQUAL
106389: IFFALSE 106397
106391: LD_INT 9
106393: DOUBLE
106394: LESSEQUAL
106395: IFTRUE 106399
106397: GO 106451
106399: POP
// begin bc_type := b_lab_half ;
106400: LD_ADDR_OWVAR 42
106404: PUSH
106405: LD_INT 7
106407: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
106408: LD_ADDR_OWVAR 44
106412: PUSH
106413: LD_INT 10
106415: PUSH
106416: LD_INT 11
106418: PUSH
106419: LD_INT 12
106421: PUSH
106422: LD_INT 15
106424: PUSH
106425: LD_INT 14
106427: PUSH
106428: LD_INT 13
106430: PUSH
106431: EMPTY
106432: LIST
106433: LIST
106434: LIST
106435: LIST
106436: LIST
106437: LIST
106438: PUSH
106439: LD_VAR 0 2
106443: PUSH
106444: LD_INT 3
106446: MINUS
106447: ARRAY
106448: ST_TO_ADDR
// end ; 10 .. 13 :
106449: GO 106959
106451: LD_INT 10
106453: DOUBLE
106454: GREATEREQUAL
106455: IFFALSE 106463
106457: LD_INT 13
106459: DOUBLE
106460: LESSEQUAL
106461: IFTRUE 106465
106463: GO 106542
106465: POP
// begin bc_type := b_lab_full ;
106466: LD_ADDR_OWVAR 42
106470: PUSH
106471: LD_INT 8
106473: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106474: LD_ADDR_OWVAR 44
106478: PUSH
106479: LD_INT 10
106481: PUSH
106482: LD_INT 12
106484: PUSH
106485: LD_INT 14
106487: PUSH
106488: LD_INT 13
106490: PUSH
106491: EMPTY
106492: LIST
106493: LIST
106494: LIST
106495: LIST
106496: PUSH
106497: LD_VAR 0 2
106501: PUSH
106502: LD_INT 9
106504: MINUS
106505: ARRAY
106506: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106507: LD_ADDR_OWVAR 45
106511: PUSH
106512: LD_INT 11
106514: PUSH
106515: LD_INT 15
106517: PUSH
106518: LD_INT 12
106520: PUSH
106521: LD_INT 15
106523: PUSH
106524: EMPTY
106525: LIST
106526: LIST
106527: LIST
106528: LIST
106529: PUSH
106530: LD_VAR 0 2
106534: PUSH
106535: LD_INT 9
106537: MINUS
106538: ARRAY
106539: ST_TO_ADDR
// end ; 14 :
106540: GO 106959
106542: LD_INT 14
106544: DOUBLE
106545: EQUAL
106546: IFTRUE 106550
106548: GO 106561
106550: POP
// bc_type := b_workshop ; 15 :
106551: LD_ADDR_OWVAR 42
106555: PUSH
106556: LD_INT 2
106558: ST_TO_ADDR
106559: GO 106959
106561: LD_INT 15
106563: DOUBLE
106564: EQUAL
106565: IFTRUE 106569
106567: GO 106580
106569: POP
// bc_type := b_factory ; 16 :
106570: LD_ADDR_OWVAR 42
106574: PUSH
106575: LD_INT 3
106577: ST_TO_ADDR
106578: GO 106959
106580: LD_INT 16
106582: DOUBLE
106583: EQUAL
106584: IFTRUE 106588
106586: GO 106599
106588: POP
// bc_type := b_ext_gun ; 17 :
106589: LD_ADDR_OWVAR 42
106593: PUSH
106594: LD_INT 17
106596: ST_TO_ADDR
106597: GO 106959
106599: LD_INT 17
106601: DOUBLE
106602: EQUAL
106603: IFTRUE 106607
106605: GO 106635
106607: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106608: LD_ADDR_OWVAR 42
106612: PUSH
106613: LD_INT 19
106615: PUSH
106616: LD_INT 23
106618: PUSH
106619: LD_INT 19
106621: PUSH
106622: EMPTY
106623: LIST
106624: LIST
106625: LIST
106626: PUSH
106627: LD_VAR 0 1
106631: ARRAY
106632: ST_TO_ADDR
106633: GO 106959
106635: LD_INT 18
106637: DOUBLE
106638: EQUAL
106639: IFTRUE 106643
106641: GO 106654
106643: POP
// bc_type := b_ext_radar ; 19 :
106644: LD_ADDR_OWVAR 42
106648: PUSH
106649: LD_INT 20
106651: ST_TO_ADDR
106652: GO 106959
106654: LD_INT 19
106656: DOUBLE
106657: EQUAL
106658: IFTRUE 106662
106660: GO 106673
106662: POP
// bc_type := b_ext_radio ; 20 :
106663: LD_ADDR_OWVAR 42
106667: PUSH
106668: LD_INT 22
106670: ST_TO_ADDR
106671: GO 106959
106673: LD_INT 20
106675: DOUBLE
106676: EQUAL
106677: IFTRUE 106681
106679: GO 106692
106681: POP
// bc_type := b_ext_siberium ; 21 :
106682: LD_ADDR_OWVAR 42
106686: PUSH
106687: LD_INT 21
106689: ST_TO_ADDR
106690: GO 106959
106692: LD_INT 21
106694: DOUBLE
106695: EQUAL
106696: IFTRUE 106700
106698: GO 106711
106700: POP
// bc_type := b_ext_computer ; 22 :
106701: LD_ADDR_OWVAR 42
106705: PUSH
106706: LD_INT 24
106708: ST_TO_ADDR
106709: GO 106959
106711: LD_INT 22
106713: DOUBLE
106714: EQUAL
106715: IFTRUE 106719
106717: GO 106730
106719: POP
// bc_type := b_ext_track ; 23 :
106720: LD_ADDR_OWVAR 42
106724: PUSH
106725: LD_INT 16
106727: ST_TO_ADDR
106728: GO 106959
106730: LD_INT 23
106732: DOUBLE
106733: EQUAL
106734: IFTRUE 106738
106736: GO 106749
106738: POP
// bc_type := b_ext_laser ; 24 :
106739: LD_ADDR_OWVAR 42
106743: PUSH
106744: LD_INT 25
106746: ST_TO_ADDR
106747: GO 106959
106749: LD_INT 24
106751: DOUBLE
106752: EQUAL
106753: IFTRUE 106757
106755: GO 106768
106757: POP
// bc_type := b_control_tower ; 25 :
106758: LD_ADDR_OWVAR 42
106762: PUSH
106763: LD_INT 36
106765: ST_TO_ADDR
106766: GO 106959
106768: LD_INT 25
106770: DOUBLE
106771: EQUAL
106772: IFTRUE 106776
106774: GO 106787
106776: POP
// bc_type := b_breastwork ; 26 :
106777: LD_ADDR_OWVAR 42
106781: PUSH
106782: LD_INT 31
106784: ST_TO_ADDR
106785: GO 106959
106787: LD_INT 26
106789: DOUBLE
106790: EQUAL
106791: IFTRUE 106795
106793: GO 106806
106795: POP
// bc_type := b_bunker ; 27 :
106796: LD_ADDR_OWVAR 42
106800: PUSH
106801: LD_INT 32
106803: ST_TO_ADDR
106804: GO 106959
106806: LD_INT 27
106808: DOUBLE
106809: EQUAL
106810: IFTRUE 106814
106812: GO 106825
106814: POP
// bc_type := b_turret ; 28 :
106815: LD_ADDR_OWVAR 42
106819: PUSH
106820: LD_INT 33
106822: ST_TO_ADDR
106823: GO 106959
106825: LD_INT 28
106827: DOUBLE
106828: EQUAL
106829: IFTRUE 106833
106831: GO 106844
106833: POP
// bc_type := b_armoury ; 29 :
106834: LD_ADDR_OWVAR 42
106838: PUSH
106839: LD_INT 4
106841: ST_TO_ADDR
106842: GO 106959
106844: LD_INT 29
106846: DOUBLE
106847: EQUAL
106848: IFTRUE 106852
106850: GO 106863
106852: POP
// bc_type := b_barracks ; 30 :
106853: LD_ADDR_OWVAR 42
106857: PUSH
106858: LD_INT 5
106860: ST_TO_ADDR
106861: GO 106959
106863: LD_INT 30
106865: DOUBLE
106866: EQUAL
106867: IFTRUE 106871
106869: GO 106882
106871: POP
// bc_type := b_solar_power ; 31 :
106872: LD_ADDR_OWVAR 42
106876: PUSH
106877: LD_INT 27
106879: ST_TO_ADDR
106880: GO 106959
106882: LD_INT 31
106884: DOUBLE
106885: EQUAL
106886: IFTRUE 106890
106888: GO 106901
106890: POP
// bc_type := b_oil_power ; 32 :
106891: LD_ADDR_OWVAR 42
106895: PUSH
106896: LD_INT 26
106898: ST_TO_ADDR
106899: GO 106959
106901: LD_INT 32
106903: DOUBLE
106904: EQUAL
106905: IFTRUE 106909
106907: GO 106920
106909: POP
// bc_type := b_siberite_power ; 33 :
106910: LD_ADDR_OWVAR 42
106914: PUSH
106915: LD_INT 28
106917: ST_TO_ADDR
106918: GO 106959
106920: LD_INT 33
106922: DOUBLE
106923: EQUAL
106924: IFTRUE 106928
106926: GO 106939
106928: POP
// bc_type := b_oil_mine ; 34 :
106929: LD_ADDR_OWVAR 42
106933: PUSH
106934: LD_INT 29
106936: ST_TO_ADDR
106937: GO 106959
106939: LD_INT 34
106941: DOUBLE
106942: EQUAL
106943: IFTRUE 106947
106945: GO 106958
106947: POP
// bc_type := b_siberite_mine ; end ;
106948: LD_ADDR_OWVAR 42
106952: PUSH
106953: LD_INT 30
106955: ST_TO_ADDR
106956: GO 106959
106958: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
106959: LD_ADDR_VAR 0 8
106963: PUSH
106964: LD_VAR 0 5
106968: PPUSH
106969: LD_VAR 0 6
106973: PPUSH
106974: LD_VAR 0 3
106978: PPUSH
106979: CALL_OW 47
106983: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
106984: LD_OWVAR 42
106988: PUSH
106989: LD_INT 32
106991: PUSH
106992: LD_INT 33
106994: PUSH
106995: EMPTY
106996: LIST
106997: LIST
106998: IN
106999: IFFALSE 107015
// PlaceWeaponTurret ( b , weapon ) ;
107001: LD_VAR 0 8
107005: PPUSH
107006: LD_VAR 0 4
107010: PPUSH
107011: CALL_OW 431
// end ;
107015: LD_VAR 0 7
107019: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107020: LD_INT 0
107022: PPUSH
107023: PPUSH
107024: PPUSH
107025: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107026: LD_ADDR_VAR 0 4
107030: PUSH
107031: LD_INT 22
107033: PUSH
107034: LD_OWVAR 2
107038: PUSH
107039: EMPTY
107040: LIST
107041: LIST
107042: PUSH
107043: LD_INT 2
107045: PUSH
107046: LD_INT 30
107048: PUSH
107049: LD_INT 0
107051: PUSH
107052: EMPTY
107053: LIST
107054: LIST
107055: PUSH
107056: LD_INT 30
107058: PUSH
107059: LD_INT 1
107061: PUSH
107062: EMPTY
107063: LIST
107064: LIST
107065: PUSH
107066: EMPTY
107067: LIST
107068: LIST
107069: LIST
107070: PUSH
107071: EMPTY
107072: LIST
107073: LIST
107074: PPUSH
107075: CALL_OW 69
107079: ST_TO_ADDR
// if not tmp then
107080: LD_VAR 0 4
107084: NOT
107085: IFFALSE 107089
// exit ;
107087: GO 107148
// for i in tmp do
107089: LD_ADDR_VAR 0 2
107093: PUSH
107094: LD_VAR 0 4
107098: PUSH
107099: FOR_IN
107100: IFFALSE 107146
// for j = 1 to 3 do
107102: LD_ADDR_VAR 0 3
107106: PUSH
107107: DOUBLE
107108: LD_INT 1
107110: DEC
107111: ST_TO_ADDR
107112: LD_INT 3
107114: PUSH
107115: FOR_TO
107116: IFFALSE 107142
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107118: LD_VAR 0 2
107122: PPUSH
107123: CALL_OW 274
107127: PPUSH
107128: LD_VAR 0 3
107132: PPUSH
107133: LD_INT 99999
107135: PPUSH
107136: CALL_OW 277
107140: GO 107115
107142: POP
107143: POP
107144: GO 107099
107146: POP
107147: POP
// end ;
107148: LD_VAR 0 1
107152: RET
// export function hHackSetLevel10 ; var i , j ; begin
107153: LD_INT 0
107155: PPUSH
107156: PPUSH
107157: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107158: LD_ADDR_VAR 0 2
107162: PUSH
107163: LD_INT 21
107165: PUSH
107166: LD_INT 1
107168: PUSH
107169: EMPTY
107170: LIST
107171: LIST
107172: PPUSH
107173: CALL_OW 69
107177: PUSH
107178: FOR_IN
107179: IFFALSE 107231
// if IsSelected ( i ) then
107181: LD_VAR 0 2
107185: PPUSH
107186: CALL_OW 306
107190: IFFALSE 107229
// begin for j := 1 to 4 do
107192: LD_ADDR_VAR 0 3
107196: PUSH
107197: DOUBLE
107198: LD_INT 1
107200: DEC
107201: ST_TO_ADDR
107202: LD_INT 4
107204: PUSH
107205: FOR_TO
107206: IFFALSE 107227
// SetSkill ( i , j , 10 ) ;
107208: LD_VAR 0 2
107212: PPUSH
107213: LD_VAR 0 3
107217: PPUSH
107218: LD_INT 10
107220: PPUSH
107221: CALL_OW 237
107225: GO 107205
107227: POP
107228: POP
// end ;
107229: GO 107178
107231: POP
107232: POP
// end ;
107233: LD_VAR 0 1
107237: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107238: LD_INT 0
107240: PPUSH
107241: PPUSH
107242: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107243: LD_ADDR_VAR 0 2
107247: PUSH
107248: LD_INT 22
107250: PUSH
107251: LD_OWVAR 2
107255: PUSH
107256: EMPTY
107257: LIST
107258: LIST
107259: PUSH
107260: LD_INT 21
107262: PUSH
107263: LD_INT 1
107265: PUSH
107266: EMPTY
107267: LIST
107268: LIST
107269: PUSH
107270: EMPTY
107271: LIST
107272: LIST
107273: PPUSH
107274: CALL_OW 69
107278: PUSH
107279: FOR_IN
107280: IFFALSE 107321
// begin for j := 1 to 4 do
107282: LD_ADDR_VAR 0 3
107286: PUSH
107287: DOUBLE
107288: LD_INT 1
107290: DEC
107291: ST_TO_ADDR
107292: LD_INT 4
107294: PUSH
107295: FOR_TO
107296: IFFALSE 107317
// SetSkill ( i , j , 10 ) ;
107298: LD_VAR 0 2
107302: PPUSH
107303: LD_VAR 0 3
107307: PPUSH
107308: LD_INT 10
107310: PPUSH
107311: CALL_OW 237
107315: GO 107295
107317: POP
107318: POP
// end ;
107319: GO 107279
107321: POP
107322: POP
// end ;
107323: LD_VAR 0 1
107327: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107328: LD_INT 0
107330: PPUSH
// uc_side := your_side ;
107331: LD_ADDR_OWVAR 20
107335: PUSH
107336: LD_OWVAR 2
107340: ST_TO_ADDR
// uc_nation := nation ;
107341: LD_ADDR_OWVAR 21
107345: PUSH
107346: LD_VAR 0 1
107350: ST_TO_ADDR
// InitHc ;
107351: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107355: LD_INT 0
107357: PPUSH
107358: LD_VAR 0 2
107362: PPUSH
107363: LD_VAR 0 3
107367: PPUSH
107368: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107372: LD_VAR 0 4
107376: PPUSH
107377: LD_VAR 0 5
107381: PPUSH
107382: CALL_OW 428
107386: PUSH
107387: LD_INT 0
107389: EQUAL
107390: IFFALSE 107414
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
107392: CALL_OW 44
107396: PPUSH
107397: LD_VAR 0 4
107401: PPUSH
107402: LD_VAR 0 5
107406: PPUSH
107407: LD_INT 1
107409: PPUSH
107410: CALL_OW 48
// end ;
107414: LD_VAR 0 6
107418: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
107419: LD_INT 0
107421: PPUSH
107422: PPUSH
// uc_side := your_side ;
107423: LD_ADDR_OWVAR 20
107427: PUSH
107428: LD_OWVAR 2
107432: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
107433: LD_VAR 0 1
107437: PUSH
107438: LD_INT 1
107440: PUSH
107441: LD_INT 2
107443: PUSH
107444: LD_INT 3
107446: PUSH
107447: LD_INT 4
107449: PUSH
107450: LD_INT 5
107452: PUSH
107453: EMPTY
107454: LIST
107455: LIST
107456: LIST
107457: LIST
107458: LIST
107459: IN
107460: IFFALSE 107472
// uc_nation := nation_american else
107462: LD_ADDR_OWVAR 21
107466: PUSH
107467: LD_INT 1
107469: ST_TO_ADDR
107470: GO 107515
// if chassis in [ 11 , 12 , 13 , 14 ] then
107472: LD_VAR 0 1
107476: PUSH
107477: LD_INT 11
107479: PUSH
107480: LD_INT 12
107482: PUSH
107483: LD_INT 13
107485: PUSH
107486: LD_INT 14
107488: PUSH
107489: EMPTY
107490: LIST
107491: LIST
107492: LIST
107493: LIST
107494: IN
107495: IFFALSE 107507
// uc_nation := nation_arabian else
107497: LD_ADDR_OWVAR 21
107501: PUSH
107502: LD_INT 2
107504: ST_TO_ADDR
107505: GO 107515
// uc_nation := nation_russian ;
107507: LD_ADDR_OWVAR 21
107511: PUSH
107512: LD_INT 3
107514: ST_TO_ADDR
// vc_chassis := chassis ;
107515: LD_ADDR_OWVAR 37
107519: PUSH
107520: LD_VAR 0 1
107524: ST_TO_ADDR
// vc_engine := engine ;
107525: LD_ADDR_OWVAR 39
107529: PUSH
107530: LD_VAR 0 2
107534: ST_TO_ADDR
// vc_control := control ;
107535: LD_ADDR_OWVAR 38
107539: PUSH
107540: LD_VAR 0 3
107544: ST_TO_ADDR
// vc_weapon := weapon ;
107545: LD_ADDR_OWVAR 40
107549: PUSH
107550: LD_VAR 0 4
107554: ST_TO_ADDR
// un := CreateVehicle ;
107555: LD_ADDR_VAR 0 8
107559: PUSH
107560: CALL_OW 45
107564: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107565: LD_VAR 0 8
107569: PPUSH
107570: LD_INT 0
107572: PPUSH
107573: LD_INT 5
107575: PPUSH
107576: CALL_OW 12
107580: PPUSH
107581: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107585: LD_VAR 0 8
107589: PPUSH
107590: LD_VAR 0 5
107594: PPUSH
107595: LD_VAR 0 6
107599: PPUSH
107600: LD_INT 1
107602: PPUSH
107603: CALL_OW 48
// end ;
107607: LD_VAR 0 7
107611: RET
// export hInvincible ; every 1 do
107612: GO 107614
107614: DISABLE
// hInvincible := [ ] ;
107615: LD_ADDR_EXP 181
107619: PUSH
107620: EMPTY
107621: ST_TO_ADDR
107622: END
// every 10 do var i ;
107623: GO 107625
107625: DISABLE
107626: LD_INT 0
107628: PPUSH
// begin enable ;
107629: ENABLE
// if not hInvincible then
107630: LD_EXP 181
107634: NOT
107635: IFFALSE 107639
// exit ;
107637: GO 107683
// for i in hInvincible do
107639: LD_ADDR_VAR 0 1
107643: PUSH
107644: LD_EXP 181
107648: PUSH
107649: FOR_IN
107650: IFFALSE 107681
// if GetLives ( i ) < 1000 then
107652: LD_VAR 0 1
107656: PPUSH
107657: CALL_OW 256
107661: PUSH
107662: LD_INT 1000
107664: LESS
107665: IFFALSE 107679
// SetLives ( i , 1000 ) ;
107667: LD_VAR 0 1
107671: PPUSH
107672: LD_INT 1000
107674: PPUSH
107675: CALL_OW 234
107679: GO 107649
107681: POP
107682: POP
// end ;
107683: PPOPN 1
107685: END
// export function hHackInvincible ; var i ; begin
107686: LD_INT 0
107688: PPUSH
107689: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107690: LD_ADDR_VAR 0 2
107694: PUSH
107695: LD_INT 2
107697: PUSH
107698: LD_INT 21
107700: PUSH
107701: LD_INT 1
107703: PUSH
107704: EMPTY
107705: LIST
107706: LIST
107707: PUSH
107708: LD_INT 21
107710: PUSH
107711: LD_INT 2
107713: PUSH
107714: EMPTY
107715: LIST
107716: LIST
107717: PUSH
107718: EMPTY
107719: LIST
107720: LIST
107721: LIST
107722: PPUSH
107723: CALL_OW 69
107727: PUSH
107728: FOR_IN
107729: IFFALSE 107790
// if IsSelected ( i ) then
107731: LD_VAR 0 2
107735: PPUSH
107736: CALL_OW 306
107740: IFFALSE 107788
// begin if i in hInvincible then
107742: LD_VAR 0 2
107746: PUSH
107747: LD_EXP 181
107751: IN
107752: IFFALSE 107772
// hInvincible := hInvincible diff i else
107754: LD_ADDR_EXP 181
107758: PUSH
107759: LD_EXP 181
107763: PUSH
107764: LD_VAR 0 2
107768: DIFF
107769: ST_TO_ADDR
107770: GO 107788
// hInvincible := hInvincible union i ;
107772: LD_ADDR_EXP 181
107776: PUSH
107777: LD_EXP 181
107781: PUSH
107782: LD_VAR 0 2
107786: UNION
107787: ST_TO_ADDR
// end ;
107788: GO 107728
107790: POP
107791: POP
// end ;
107792: LD_VAR 0 1
107796: RET
// export function hHackInvisible ; var i , j ; begin
107797: LD_INT 0
107799: PPUSH
107800: PPUSH
107801: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107802: LD_ADDR_VAR 0 2
107806: PUSH
107807: LD_INT 21
107809: PUSH
107810: LD_INT 1
107812: PUSH
107813: EMPTY
107814: LIST
107815: LIST
107816: PPUSH
107817: CALL_OW 69
107821: PUSH
107822: FOR_IN
107823: IFFALSE 107847
// if IsSelected ( i ) then
107825: LD_VAR 0 2
107829: PPUSH
107830: CALL_OW 306
107834: IFFALSE 107845
// ComForceInvisible ( i ) ;
107836: LD_VAR 0 2
107840: PPUSH
107841: CALL_OW 496
107845: GO 107822
107847: POP
107848: POP
// end ;
107849: LD_VAR 0 1
107853: RET
// export function hHackChangeYourSide ; begin
107854: LD_INT 0
107856: PPUSH
// if your_side = 8 then
107857: LD_OWVAR 2
107861: PUSH
107862: LD_INT 8
107864: EQUAL
107865: IFFALSE 107877
// your_side := 0 else
107867: LD_ADDR_OWVAR 2
107871: PUSH
107872: LD_INT 0
107874: ST_TO_ADDR
107875: GO 107891
// your_side := your_side + 1 ;
107877: LD_ADDR_OWVAR 2
107881: PUSH
107882: LD_OWVAR 2
107886: PUSH
107887: LD_INT 1
107889: PLUS
107890: ST_TO_ADDR
// end ;
107891: LD_VAR 0 1
107895: RET
// export function hHackChangeUnitSide ; var i , j ; begin
107896: LD_INT 0
107898: PPUSH
107899: PPUSH
107900: PPUSH
// for i in all_units do
107901: LD_ADDR_VAR 0 2
107905: PUSH
107906: LD_OWVAR 3
107910: PUSH
107911: FOR_IN
107912: IFFALSE 107990
// if IsSelected ( i ) then
107914: LD_VAR 0 2
107918: PPUSH
107919: CALL_OW 306
107923: IFFALSE 107988
// begin j := GetSide ( i ) ;
107925: LD_ADDR_VAR 0 3
107929: PUSH
107930: LD_VAR 0 2
107934: PPUSH
107935: CALL_OW 255
107939: ST_TO_ADDR
// if j = 8 then
107940: LD_VAR 0 3
107944: PUSH
107945: LD_INT 8
107947: EQUAL
107948: IFFALSE 107960
// j := 0 else
107950: LD_ADDR_VAR 0 3
107954: PUSH
107955: LD_INT 0
107957: ST_TO_ADDR
107958: GO 107974
// j := j + 1 ;
107960: LD_ADDR_VAR 0 3
107964: PUSH
107965: LD_VAR 0 3
107969: PUSH
107970: LD_INT 1
107972: PLUS
107973: ST_TO_ADDR
// SetSide ( i , j ) ;
107974: LD_VAR 0 2
107978: PPUSH
107979: LD_VAR 0 3
107983: PPUSH
107984: CALL_OW 235
// end ;
107988: GO 107911
107990: POP
107991: POP
// end ;
107992: LD_VAR 0 1
107996: RET
// export function hHackFog ; begin
107997: LD_INT 0
107999: PPUSH
// FogOff ( true ) ;
108000: LD_INT 1
108002: PPUSH
108003: CALL_OW 344
// end ;
108007: LD_VAR 0 1
108011: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108012: LD_INT 0
108014: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108015: LD_VAR 0 1
108019: PPUSH
108020: LD_VAR 0 2
108024: PPUSH
108025: LD_VAR 0 3
108029: PPUSH
108030: LD_INT 1
108032: PPUSH
108033: LD_INT 1
108035: PPUSH
108036: CALL_OW 483
// CenterOnXY ( x , y ) ;
108040: LD_VAR 0 2
108044: PPUSH
108045: LD_VAR 0 3
108049: PPUSH
108050: CALL_OW 84
// end ;
108054: LD_VAR 0 4
108058: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
108059: LD_INT 0
108061: PPUSH
108062: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
108063: LD_VAR 0 1
108067: NOT
108068: PUSH
108069: LD_VAR 0 2
108073: PPUSH
108074: LD_VAR 0 3
108078: PPUSH
108079: CALL_OW 488
108083: NOT
108084: OR
108085: PUSH
108086: LD_VAR 0 1
108090: PPUSH
108091: CALL_OW 266
108095: PUSH
108096: LD_INT 3
108098: NONEQUAL
108099: PUSH
108100: LD_VAR 0 1
108104: PPUSH
108105: CALL_OW 247
108109: PUSH
108110: LD_INT 1
108112: EQUAL
108113: NOT
108114: AND
108115: OR
108116: IFFALSE 108120
// exit ;
108118: GO 108269
// if GetType ( factory ) = unit_human then
108120: LD_VAR 0 1
108124: PPUSH
108125: CALL_OW 247
108129: PUSH
108130: LD_INT 1
108132: EQUAL
108133: IFFALSE 108150
// factory := IsInUnit ( factory ) ;
108135: LD_ADDR_VAR 0 1
108139: PUSH
108140: LD_VAR 0 1
108144: PPUSH
108145: CALL_OW 310
108149: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108150: LD_VAR 0 1
108154: PPUSH
108155: CALL_OW 266
108159: PUSH
108160: LD_INT 3
108162: NONEQUAL
108163: IFFALSE 108167
// exit ;
108165: GO 108269
// if HexInfo ( x , y ) = factory then
108167: LD_VAR 0 2
108171: PPUSH
108172: LD_VAR 0 3
108176: PPUSH
108177: CALL_OW 428
108181: PUSH
108182: LD_VAR 0 1
108186: EQUAL
108187: IFFALSE 108214
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
108189: LD_ADDR_EXP 182
108193: PUSH
108194: LD_EXP 182
108198: PPUSH
108199: LD_VAR 0 1
108203: PPUSH
108204: LD_INT 0
108206: PPUSH
108207: CALL_OW 1
108211: ST_TO_ADDR
108212: GO 108265
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
108214: LD_ADDR_EXP 182
108218: PUSH
108219: LD_EXP 182
108223: PPUSH
108224: LD_VAR 0 1
108228: PPUSH
108229: LD_VAR 0 1
108233: PPUSH
108234: CALL_OW 255
108238: PUSH
108239: LD_VAR 0 1
108243: PUSH
108244: LD_VAR 0 2
108248: PUSH
108249: LD_VAR 0 3
108253: PUSH
108254: EMPTY
108255: LIST
108256: LIST
108257: LIST
108258: LIST
108259: PPUSH
108260: CALL_OW 1
108264: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108265: CALL 108274 0 0
// end ;
108269: LD_VAR 0 4
108273: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
108274: LD_INT 0
108276: PPUSH
108277: PPUSH
108278: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
108279: LD_STRING resetFactoryWaypoint();
108281: PPUSH
108282: CALL_OW 559
// if factoryWaypoints then
108286: LD_EXP 182
108290: IFFALSE 108416
// begin list := PrepareArray ( factoryWaypoints ) ;
108292: LD_ADDR_VAR 0 3
108296: PUSH
108297: LD_EXP 182
108301: PPUSH
108302: CALL 93262 0 1
108306: ST_TO_ADDR
// for i := 1 to list do
108307: LD_ADDR_VAR 0 2
108311: PUSH
108312: DOUBLE
108313: LD_INT 1
108315: DEC
108316: ST_TO_ADDR
108317: LD_VAR 0 3
108321: PUSH
108322: FOR_TO
108323: IFFALSE 108414
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108325: LD_STRING setFactoryWaypointXY(
108327: PUSH
108328: LD_VAR 0 3
108332: PUSH
108333: LD_VAR 0 2
108337: ARRAY
108338: PUSH
108339: LD_INT 1
108341: ARRAY
108342: STR
108343: PUSH
108344: LD_STRING ,
108346: STR
108347: PUSH
108348: LD_VAR 0 3
108352: PUSH
108353: LD_VAR 0 2
108357: ARRAY
108358: PUSH
108359: LD_INT 2
108361: ARRAY
108362: STR
108363: PUSH
108364: LD_STRING ,
108366: STR
108367: PUSH
108368: LD_VAR 0 3
108372: PUSH
108373: LD_VAR 0 2
108377: ARRAY
108378: PUSH
108379: LD_INT 3
108381: ARRAY
108382: STR
108383: PUSH
108384: LD_STRING ,
108386: STR
108387: PUSH
108388: LD_VAR 0 3
108392: PUSH
108393: LD_VAR 0 2
108397: ARRAY
108398: PUSH
108399: LD_INT 4
108401: ARRAY
108402: STR
108403: PUSH
108404: LD_STRING )
108406: STR
108407: PPUSH
108408: CALL_OW 559
108412: GO 108322
108414: POP
108415: POP
// end ; end ;
108416: LD_VAR 0 1
108420: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
108421: LD_INT 0
108423: PPUSH
// if HexInfo ( x , y ) = warehouse then
108424: LD_VAR 0 2
108428: PPUSH
108429: LD_VAR 0 3
108433: PPUSH
108434: CALL_OW 428
108438: PUSH
108439: LD_VAR 0 1
108443: EQUAL
108444: IFFALSE 108471
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
108446: LD_ADDR_EXP 183
108450: PUSH
108451: LD_EXP 183
108455: PPUSH
108456: LD_VAR 0 1
108460: PPUSH
108461: LD_INT 0
108463: PPUSH
108464: CALL_OW 1
108468: ST_TO_ADDR
108469: GO 108522
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
108471: LD_ADDR_EXP 183
108475: PUSH
108476: LD_EXP 183
108480: PPUSH
108481: LD_VAR 0 1
108485: PPUSH
108486: LD_VAR 0 1
108490: PPUSH
108491: CALL_OW 255
108495: PUSH
108496: LD_VAR 0 1
108500: PUSH
108501: LD_VAR 0 2
108505: PUSH
108506: LD_VAR 0 3
108510: PUSH
108511: EMPTY
108512: LIST
108513: LIST
108514: LIST
108515: LIST
108516: PPUSH
108517: CALL_OW 1
108521: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
108522: CALL 108531 0 0
// end ;
108526: LD_VAR 0 4
108530: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
108531: LD_INT 0
108533: PPUSH
108534: PPUSH
108535: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
108536: LD_STRING resetWarehouseGatheringPoints();
108538: PPUSH
108539: CALL_OW 559
// if warehouseGatheringPoints then
108543: LD_EXP 183
108547: IFFALSE 108673
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
108549: LD_ADDR_VAR 0 3
108553: PUSH
108554: LD_EXP 183
108558: PPUSH
108559: CALL 93262 0 1
108563: ST_TO_ADDR
// for i := 1 to list do
108564: LD_ADDR_VAR 0 2
108568: PUSH
108569: DOUBLE
108570: LD_INT 1
108572: DEC
108573: ST_TO_ADDR
108574: LD_VAR 0 3
108578: PUSH
108579: FOR_TO
108580: IFFALSE 108671
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108582: LD_STRING setWarehouseGatheringPointXY(
108584: PUSH
108585: LD_VAR 0 3
108589: PUSH
108590: LD_VAR 0 2
108594: ARRAY
108595: PUSH
108596: LD_INT 1
108598: ARRAY
108599: STR
108600: PUSH
108601: LD_STRING ,
108603: STR
108604: PUSH
108605: LD_VAR 0 3
108609: PUSH
108610: LD_VAR 0 2
108614: ARRAY
108615: PUSH
108616: LD_INT 2
108618: ARRAY
108619: STR
108620: PUSH
108621: LD_STRING ,
108623: STR
108624: PUSH
108625: LD_VAR 0 3
108629: PUSH
108630: LD_VAR 0 2
108634: ARRAY
108635: PUSH
108636: LD_INT 3
108638: ARRAY
108639: STR
108640: PUSH
108641: LD_STRING ,
108643: STR
108644: PUSH
108645: LD_VAR 0 3
108649: PUSH
108650: LD_VAR 0 2
108654: ARRAY
108655: PUSH
108656: LD_INT 4
108658: ARRAY
108659: STR
108660: PUSH
108661: LD_STRING )
108663: STR
108664: PPUSH
108665: CALL_OW 559
108669: GO 108579
108671: POP
108672: POP
// end ; end ;
108673: LD_VAR 0 1
108677: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108678: LD_EXP 183
108682: IFFALSE 109367
108684: GO 108686
108686: DISABLE
108687: LD_INT 0
108689: PPUSH
108690: PPUSH
108691: PPUSH
108692: PPUSH
108693: PPUSH
108694: PPUSH
108695: PPUSH
108696: PPUSH
108697: PPUSH
// begin enable ;
108698: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108699: LD_ADDR_VAR 0 3
108703: PUSH
108704: LD_EXP 183
108708: PPUSH
108709: CALL 93262 0 1
108713: ST_TO_ADDR
// if not list then
108714: LD_VAR 0 3
108718: NOT
108719: IFFALSE 108723
// exit ;
108721: GO 109367
// for i := 1 to list do
108723: LD_ADDR_VAR 0 1
108727: PUSH
108728: DOUBLE
108729: LD_INT 1
108731: DEC
108732: ST_TO_ADDR
108733: LD_VAR 0 3
108737: PUSH
108738: FOR_TO
108739: IFFALSE 109365
// begin depot := list [ i ] [ 2 ] ;
108741: LD_ADDR_VAR 0 8
108745: PUSH
108746: LD_VAR 0 3
108750: PUSH
108751: LD_VAR 0 1
108755: ARRAY
108756: PUSH
108757: LD_INT 2
108759: ARRAY
108760: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108761: LD_ADDR_VAR 0 5
108765: PUSH
108766: LD_VAR 0 3
108770: PUSH
108771: LD_VAR 0 1
108775: ARRAY
108776: PUSH
108777: LD_INT 1
108779: ARRAY
108780: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108781: LD_VAR 0 8
108785: PPUSH
108786: CALL_OW 301
108790: PUSH
108791: LD_VAR 0 5
108795: PUSH
108796: LD_VAR 0 8
108800: PPUSH
108801: CALL_OW 255
108805: NONEQUAL
108806: OR
108807: IFFALSE 108836
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108809: LD_ADDR_EXP 183
108813: PUSH
108814: LD_EXP 183
108818: PPUSH
108819: LD_VAR 0 8
108823: PPUSH
108824: LD_INT 0
108826: PPUSH
108827: CALL_OW 1
108831: ST_TO_ADDR
// exit ;
108832: POP
108833: POP
108834: GO 109367
// end ; x := list [ i ] [ 3 ] ;
108836: LD_ADDR_VAR 0 6
108840: PUSH
108841: LD_VAR 0 3
108845: PUSH
108846: LD_VAR 0 1
108850: ARRAY
108851: PUSH
108852: LD_INT 3
108854: ARRAY
108855: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
108856: LD_ADDR_VAR 0 7
108860: PUSH
108861: LD_VAR 0 3
108865: PUSH
108866: LD_VAR 0 1
108870: ARRAY
108871: PUSH
108872: LD_INT 4
108874: ARRAY
108875: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
108876: LD_ADDR_VAR 0 9
108880: PUSH
108881: LD_VAR 0 6
108885: PPUSH
108886: LD_VAR 0 7
108890: PPUSH
108891: LD_INT 16
108893: PPUSH
108894: CALL 91850 0 3
108898: ST_TO_ADDR
// if not cratesNearbyPoint then
108899: LD_VAR 0 9
108903: NOT
108904: IFFALSE 108910
// exit ;
108906: POP
108907: POP
108908: GO 109367
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
108910: LD_ADDR_VAR 0 4
108914: PUSH
108915: LD_INT 22
108917: PUSH
108918: LD_VAR 0 5
108922: PUSH
108923: EMPTY
108924: LIST
108925: LIST
108926: PUSH
108927: LD_INT 3
108929: PUSH
108930: LD_INT 60
108932: PUSH
108933: EMPTY
108934: LIST
108935: PUSH
108936: EMPTY
108937: LIST
108938: LIST
108939: PUSH
108940: LD_INT 91
108942: PUSH
108943: LD_VAR 0 8
108947: PUSH
108948: LD_INT 6
108950: PUSH
108951: EMPTY
108952: LIST
108953: LIST
108954: LIST
108955: PUSH
108956: LD_INT 2
108958: PUSH
108959: LD_INT 25
108961: PUSH
108962: LD_INT 2
108964: PUSH
108965: EMPTY
108966: LIST
108967: LIST
108968: PUSH
108969: LD_INT 25
108971: PUSH
108972: LD_INT 16
108974: PUSH
108975: EMPTY
108976: LIST
108977: LIST
108978: PUSH
108979: EMPTY
108980: LIST
108981: LIST
108982: LIST
108983: PUSH
108984: EMPTY
108985: LIST
108986: LIST
108987: LIST
108988: LIST
108989: PPUSH
108990: CALL_OW 69
108994: PUSH
108995: LD_VAR 0 8
108999: PPUSH
109000: CALL_OW 313
109004: PPUSH
109005: LD_INT 3
109007: PUSH
109008: LD_INT 60
109010: PUSH
109011: EMPTY
109012: LIST
109013: PUSH
109014: EMPTY
109015: LIST
109016: LIST
109017: PUSH
109018: LD_INT 2
109020: PUSH
109021: LD_INT 25
109023: PUSH
109024: LD_INT 2
109026: PUSH
109027: EMPTY
109028: LIST
109029: LIST
109030: PUSH
109031: LD_INT 25
109033: PUSH
109034: LD_INT 16
109036: PUSH
109037: EMPTY
109038: LIST
109039: LIST
109040: PUSH
109041: EMPTY
109042: LIST
109043: LIST
109044: LIST
109045: PUSH
109046: EMPTY
109047: LIST
109048: LIST
109049: PPUSH
109050: CALL_OW 72
109054: UNION
109055: ST_TO_ADDR
// if tmp then
109056: LD_VAR 0 4
109060: IFFALSE 109140
// begin tmp := ShrinkArray ( tmp , 3 ) ;
109062: LD_ADDR_VAR 0 4
109066: PUSH
109067: LD_VAR 0 4
109071: PPUSH
109072: LD_INT 3
109074: PPUSH
109075: CALL 89819 0 2
109079: ST_TO_ADDR
// for j in tmp do
109080: LD_ADDR_VAR 0 2
109084: PUSH
109085: LD_VAR 0 4
109089: PUSH
109090: FOR_IN
109091: IFFALSE 109134
// begin if IsInUnit ( j ) then
109093: LD_VAR 0 2
109097: PPUSH
109098: CALL_OW 310
109102: IFFALSE 109113
// ComExit ( j ) ;
109104: LD_VAR 0 2
109108: PPUSH
109109: CALL 89902 0 1
// AddComCollect ( j , x , y ) ;
109113: LD_VAR 0 2
109117: PPUSH
109118: LD_VAR 0 6
109122: PPUSH
109123: LD_VAR 0 7
109127: PPUSH
109128: CALL_OW 177
// end ;
109132: GO 109090
109134: POP
109135: POP
// exit ;
109136: POP
109137: POP
109138: GO 109367
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109140: LD_ADDR_VAR 0 4
109144: PUSH
109145: LD_INT 22
109147: PUSH
109148: LD_VAR 0 5
109152: PUSH
109153: EMPTY
109154: LIST
109155: LIST
109156: PUSH
109157: LD_INT 91
109159: PUSH
109160: LD_VAR 0 8
109164: PUSH
109165: LD_INT 8
109167: PUSH
109168: EMPTY
109169: LIST
109170: LIST
109171: LIST
109172: PUSH
109173: LD_INT 2
109175: PUSH
109176: LD_INT 34
109178: PUSH
109179: LD_INT 12
109181: PUSH
109182: EMPTY
109183: LIST
109184: LIST
109185: PUSH
109186: LD_INT 34
109188: PUSH
109189: LD_INT 51
109191: PUSH
109192: EMPTY
109193: LIST
109194: LIST
109195: PUSH
109196: LD_INT 34
109198: PUSH
109199: LD_INT 32
109201: PUSH
109202: EMPTY
109203: LIST
109204: LIST
109205: PUSH
109206: LD_INT 34
109208: PUSH
109209: LD_INT 89
109211: PUSH
109212: EMPTY
109213: LIST
109214: LIST
109215: PUSH
109216: EMPTY
109217: LIST
109218: LIST
109219: LIST
109220: LIST
109221: LIST
109222: PUSH
109223: EMPTY
109224: LIST
109225: LIST
109226: LIST
109227: PPUSH
109228: CALL_OW 69
109232: ST_TO_ADDR
// if tmp then
109233: LD_VAR 0 4
109237: IFFALSE 109363
// begin for j in tmp do
109239: LD_ADDR_VAR 0 2
109243: PUSH
109244: LD_VAR 0 4
109248: PUSH
109249: FOR_IN
109250: IFFALSE 109361
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
109252: LD_VAR 0 2
109256: PPUSH
109257: CALL_OW 262
109261: PUSH
109262: LD_INT 3
109264: EQUAL
109265: PUSH
109266: LD_VAR 0 2
109270: PPUSH
109271: CALL_OW 261
109275: PUSH
109276: LD_INT 20
109278: GREATER
109279: OR
109280: PUSH
109281: LD_VAR 0 2
109285: PPUSH
109286: CALL_OW 314
109290: NOT
109291: AND
109292: PUSH
109293: LD_VAR 0 2
109297: PPUSH
109298: CALL_OW 263
109302: PUSH
109303: LD_INT 1
109305: NONEQUAL
109306: PUSH
109307: LD_VAR 0 2
109311: PPUSH
109312: CALL_OW 311
109316: OR
109317: AND
109318: IFFALSE 109359
// begin ComCollect ( j , x , y ) ;
109320: LD_VAR 0 2
109324: PPUSH
109325: LD_VAR 0 6
109329: PPUSH
109330: LD_VAR 0 7
109334: PPUSH
109335: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
109339: LD_VAR 0 2
109343: PPUSH
109344: LD_VAR 0 8
109348: PPUSH
109349: CALL_OW 172
// exit ;
109353: POP
109354: POP
109355: POP
109356: POP
109357: GO 109367
// end ;
109359: GO 109249
109361: POP
109362: POP
// end ; end ;
109363: GO 108738
109365: POP
109366: POP
// end ; end_of_file
109367: PPOPN 9
109369: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
109370: LD_INT 0
109372: PPUSH
109373: PPUSH
109374: PPUSH
109375: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
109376: LD_VAR 0 1
109380: PPUSH
109381: CALL_OW 264
109385: PUSH
109386: LD_INT 91
109388: EQUAL
109389: IFFALSE 109461
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
109391: LD_INT 68
109393: PPUSH
109394: LD_VAR 0 1
109398: PPUSH
109399: CALL_OW 255
109403: PPUSH
109404: CALL_OW 321
109408: PUSH
109409: LD_INT 2
109411: EQUAL
109412: IFFALSE 109424
// eff := 70 else
109414: LD_ADDR_VAR 0 4
109418: PUSH
109419: LD_INT 70
109421: ST_TO_ADDR
109422: GO 109432
// eff := 30 ;
109424: LD_ADDR_VAR 0 4
109428: PUSH
109429: LD_INT 30
109431: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
109432: LD_VAR 0 1
109436: PPUSH
109437: CALL_OW 250
109441: PPUSH
109442: LD_VAR 0 1
109446: PPUSH
109447: CALL_OW 251
109451: PPUSH
109452: LD_VAR 0 4
109456: PPUSH
109457: CALL_OW 495
// end ; end ;
109461: LD_VAR 0 2
109465: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
109466: LD_INT 0
109468: PPUSH
// end ;
109469: LD_VAR 0 4
109473: RET
// export function SOS_Command ( cmd ) ; begin
109474: LD_INT 0
109476: PPUSH
// end ;
109477: LD_VAR 0 2
109481: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
109482: LD_INT 0
109484: PPUSH
// end ;
109485: LD_VAR 0 6
109489: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
109490: LD_INT 0
109492: PPUSH
109493: PPUSH
// if not vehicle or not factory then
109494: LD_VAR 0 1
109498: NOT
109499: PUSH
109500: LD_VAR 0 2
109504: NOT
109505: OR
109506: IFFALSE 109510
// exit ;
109508: GO 109741
// if factoryWaypoints >= factory then
109510: LD_EXP 182
109514: PUSH
109515: LD_VAR 0 2
109519: GREATEREQUAL
109520: IFFALSE 109741
// if factoryWaypoints [ factory ] then
109522: LD_EXP 182
109526: PUSH
109527: LD_VAR 0 2
109531: ARRAY
109532: IFFALSE 109741
// begin if GetControl ( vehicle ) = control_manual then
109534: LD_VAR 0 1
109538: PPUSH
109539: CALL_OW 263
109543: PUSH
109544: LD_INT 1
109546: EQUAL
109547: IFFALSE 109628
// begin driver := IsDrivenBy ( vehicle ) ;
109549: LD_ADDR_VAR 0 4
109553: PUSH
109554: LD_VAR 0 1
109558: PPUSH
109559: CALL_OW 311
109563: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109564: LD_VAR 0 4
109568: PPUSH
109569: LD_EXP 182
109573: PUSH
109574: LD_VAR 0 2
109578: ARRAY
109579: PUSH
109580: LD_INT 3
109582: ARRAY
109583: PPUSH
109584: LD_EXP 182
109588: PUSH
109589: LD_VAR 0 2
109593: ARRAY
109594: PUSH
109595: LD_INT 4
109597: ARRAY
109598: PPUSH
109599: CALL_OW 171
// AddComExitVehicle ( driver ) ;
109603: LD_VAR 0 4
109607: PPUSH
109608: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
109612: LD_VAR 0 4
109616: PPUSH
109617: LD_VAR 0 2
109621: PPUSH
109622: CALL_OW 180
// end else
109626: GO 109741
// if GetControl ( vehicle ) = control_remote then
109628: LD_VAR 0 1
109632: PPUSH
109633: CALL_OW 263
109637: PUSH
109638: LD_INT 2
109640: EQUAL
109641: IFFALSE 109702
// begin wait ( 0 0$2 ) ;
109643: LD_INT 70
109645: PPUSH
109646: CALL_OW 67
// if Connect ( vehicle ) then
109650: LD_VAR 0 1
109654: PPUSH
109655: CALL 60143 0 1
109659: IFFALSE 109700
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109661: LD_VAR 0 1
109665: PPUSH
109666: LD_EXP 182
109670: PUSH
109671: LD_VAR 0 2
109675: ARRAY
109676: PUSH
109677: LD_INT 3
109679: ARRAY
109680: PPUSH
109681: LD_EXP 182
109685: PUSH
109686: LD_VAR 0 2
109690: ARRAY
109691: PUSH
109692: LD_INT 4
109694: ARRAY
109695: PPUSH
109696: CALL_OW 171
// end else
109700: GO 109741
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109702: LD_VAR 0 1
109706: PPUSH
109707: LD_EXP 182
109711: PUSH
109712: LD_VAR 0 2
109716: ARRAY
109717: PUSH
109718: LD_INT 3
109720: ARRAY
109721: PPUSH
109722: LD_EXP 182
109726: PUSH
109727: LD_VAR 0 2
109731: ARRAY
109732: PUSH
109733: LD_INT 4
109735: ARRAY
109736: PPUSH
109737: CALL_OW 171
// end ; end ;
109741: LD_VAR 0 3
109745: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
109746: LD_INT 0
109748: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
109749: LD_VAR 0 1
109753: PUSH
109754: LD_INT 250
109756: EQUAL
109757: PUSH
109758: LD_VAR 0 2
109762: PPUSH
109763: CALL_OW 264
109767: PUSH
109768: LD_INT 81
109770: EQUAL
109771: AND
109772: IFFALSE 109793
// MinerPlaceMine ( unit , x , y ) ;
109774: LD_VAR 0 2
109778: PPUSH
109779: LD_VAR 0 4
109783: PPUSH
109784: LD_VAR 0 5
109788: PPUSH
109789: CALL 112178 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
109793: LD_VAR 0 1
109797: PUSH
109798: LD_INT 251
109800: EQUAL
109801: PUSH
109802: LD_VAR 0 2
109806: PPUSH
109807: CALL_OW 264
109811: PUSH
109812: LD_INT 81
109814: EQUAL
109815: AND
109816: IFFALSE 109837
// MinerDetonateMine ( unit , x , y ) ;
109818: LD_VAR 0 2
109822: PPUSH
109823: LD_VAR 0 4
109827: PPUSH
109828: LD_VAR 0 5
109832: PPUSH
109833: CALL 112453 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
109837: LD_VAR 0 1
109841: PUSH
109842: LD_INT 252
109844: EQUAL
109845: PUSH
109846: LD_VAR 0 2
109850: PPUSH
109851: CALL_OW 264
109855: PUSH
109856: LD_INT 81
109858: EQUAL
109859: AND
109860: IFFALSE 109881
// MinerCreateMinefield ( unit , x , y ) ;
109862: LD_VAR 0 2
109866: PPUSH
109867: LD_VAR 0 4
109871: PPUSH
109872: LD_VAR 0 5
109876: PPUSH
109877: CALL 112870 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
109881: LD_VAR 0 1
109885: PUSH
109886: LD_INT 253
109888: EQUAL
109889: PUSH
109890: LD_VAR 0 2
109894: PPUSH
109895: CALL_OW 257
109899: PUSH
109900: LD_INT 5
109902: EQUAL
109903: AND
109904: IFFALSE 109925
// ComBinocular ( unit , x , y ) ;
109906: LD_VAR 0 2
109910: PPUSH
109911: LD_VAR 0 4
109915: PPUSH
109916: LD_VAR 0 5
109920: PPUSH
109921: CALL 113239 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
109925: LD_VAR 0 1
109929: PUSH
109930: LD_INT 254
109932: EQUAL
109933: PUSH
109934: LD_VAR 0 2
109938: PPUSH
109939: CALL_OW 264
109943: PUSH
109944: LD_INT 99
109946: EQUAL
109947: AND
109948: PUSH
109949: LD_VAR 0 3
109953: PPUSH
109954: CALL_OW 263
109958: PUSH
109959: LD_INT 3
109961: EQUAL
109962: AND
109963: IFFALSE 109979
// HackDestroyVehicle ( unit , selectedUnit ) ;
109965: LD_VAR 0 2
109969: PPUSH
109970: LD_VAR 0 3
109974: PPUSH
109975: CALL 111542 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
109979: LD_VAR 0 1
109983: PUSH
109984: LD_INT 255
109986: EQUAL
109987: PUSH
109988: LD_VAR 0 2
109992: PPUSH
109993: CALL_OW 264
109997: PUSH
109998: LD_INT 14
110000: PUSH
110001: LD_INT 53
110003: PUSH
110004: EMPTY
110005: LIST
110006: LIST
110007: IN
110008: AND
110009: PUSH
110010: LD_VAR 0 4
110014: PPUSH
110015: LD_VAR 0 5
110019: PPUSH
110020: CALL_OW 488
110024: AND
110025: IFFALSE 110049
// CutTreeXYR ( unit , x , y , 12 ) ;
110027: LD_VAR 0 2
110031: PPUSH
110032: LD_VAR 0 4
110036: PPUSH
110037: LD_VAR 0 5
110041: PPUSH
110042: LD_INT 12
110044: PPUSH
110045: CALL 110112 0 4
// if cmd = 256 then
110049: LD_VAR 0 1
110053: PUSH
110054: LD_INT 256
110056: EQUAL
110057: IFFALSE 110078
// SetFactoryWaypoint ( unit , x , y ) ;
110059: LD_VAR 0 2
110063: PPUSH
110064: LD_VAR 0 4
110068: PPUSH
110069: LD_VAR 0 5
110073: PPUSH
110074: CALL 108059 0 3
// if cmd = 257 then
110078: LD_VAR 0 1
110082: PUSH
110083: LD_INT 257
110085: EQUAL
110086: IFFALSE 110107
// SetWarehouseGatheringPoint ( unit , x , y ) ;
110088: LD_VAR 0 2
110092: PPUSH
110093: LD_VAR 0 4
110097: PPUSH
110098: LD_VAR 0 5
110102: PPUSH
110103: CALL 108421 0 3
// end ;
110107: LD_VAR 0 6
110111: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
110112: LD_INT 0
110114: PPUSH
110115: PPUSH
110116: PPUSH
110117: PPUSH
110118: PPUSH
110119: PPUSH
110120: PPUSH
110121: PPUSH
110122: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
110123: LD_VAR 0 1
110127: NOT
110128: PUSH
110129: LD_VAR 0 2
110133: PPUSH
110134: LD_VAR 0 3
110138: PPUSH
110139: CALL_OW 488
110143: NOT
110144: OR
110145: PUSH
110146: LD_VAR 0 4
110150: NOT
110151: OR
110152: IFFALSE 110156
// exit ;
110154: GO 110496
// list := [ ] ;
110156: LD_ADDR_VAR 0 13
110160: PUSH
110161: EMPTY
110162: ST_TO_ADDR
// if x - r < 0 then
110163: LD_VAR 0 2
110167: PUSH
110168: LD_VAR 0 4
110172: MINUS
110173: PUSH
110174: LD_INT 0
110176: LESS
110177: IFFALSE 110189
// min_x := 0 else
110179: LD_ADDR_VAR 0 7
110183: PUSH
110184: LD_INT 0
110186: ST_TO_ADDR
110187: GO 110205
// min_x := x - r ;
110189: LD_ADDR_VAR 0 7
110193: PUSH
110194: LD_VAR 0 2
110198: PUSH
110199: LD_VAR 0 4
110203: MINUS
110204: ST_TO_ADDR
// if y - r < 0 then
110205: LD_VAR 0 3
110209: PUSH
110210: LD_VAR 0 4
110214: MINUS
110215: PUSH
110216: LD_INT 0
110218: LESS
110219: IFFALSE 110231
// min_y := 0 else
110221: LD_ADDR_VAR 0 8
110225: PUSH
110226: LD_INT 0
110228: ST_TO_ADDR
110229: GO 110247
// min_y := y - r ;
110231: LD_ADDR_VAR 0 8
110235: PUSH
110236: LD_VAR 0 3
110240: PUSH
110241: LD_VAR 0 4
110245: MINUS
110246: ST_TO_ADDR
// max_x := x + r ;
110247: LD_ADDR_VAR 0 9
110251: PUSH
110252: LD_VAR 0 2
110256: PUSH
110257: LD_VAR 0 4
110261: PLUS
110262: ST_TO_ADDR
// max_y := y + r ;
110263: LD_ADDR_VAR 0 10
110267: PUSH
110268: LD_VAR 0 3
110272: PUSH
110273: LD_VAR 0 4
110277: PLUS
110278: ST_TO_ADDR
// for _x = min_x to max_x do
110279: LD_ADDR_VAR 0 11
110283: PUSH
110284: DOUBLE
110285: LD_VAR 0 7
110289: DEC
110290: ST_TO_ADDR
110291: LD_VAR 0 9
110295: PUSH
110296: FOR_TO
110297: IFFALSE 110414
// for _y = min_y to max_y do
110299: LD_ADDR_VAR 0 12
110303: PUSH
110304: DOUBLE
110305: LD_VAR 0 8
110309: DEC
110310: ST_TO_ADDR
110311: LD_VAR 0 10
110315: PUSH
110316: FOR_TO
110317: IFFALSE 110410
// begin if not ValidHex ( _x , _y ) then
110319: LD_VAR 0 11
110323: PPUSH
110324: LD_VAR 0 12
110328: PPUSH
110329: CALL_OW 488
110333: NOT
110334: IFFALSE 110338
// continue ;
110336: GO 110316
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
110338: LD_VAR 0 11
110342: PPUSH
110343: LD_VAR 0 12
110347: PPUSH
110348: CALL_OW 351
110352: PUSH
110353: LD_VAR 0 11
110357: PPUSH
110358: LD_VAR 0 12
110362: PPUSH
110363: CALL_OW 554
110367: AND
110368: IFFALSE 110408
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
110370: LD_ADDR_VAR 0 13
110374: PUSH
110375: LD_VAR 0 13
110379: PPUSH
110380: LD_VAR 0 13
110384: PUSH
110385: LD_INT 1
110387: PLUS
110388: PPUSH
110389: LD_VAR 0 11
110393: PUSH
110394: LD_VAR 0 12
110398: PUSH
110399: EMPTY
110400: LIST
110401: LIST
110402: PPUSH
110403: CALL_OW 2
110407: ST_TO_ADDR
// end ;
110408: GO 110316
110410: POP
110411: POP
110412: GO 110296
110414: POP
110415: POP
// if not list then
110416: LD_VAR 0 13
110420: NOT
110421: IFFALSE 110425
// exit ;
110423: GO 110496
// for i in list do
110425: LD_ADDR_VAR 0 6
110429: PUSH
110430: LD_VAR 0 13
110434: PUSH
110435: FOR_IN
110436: IFFALSE 110494
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
110438: LD_VAR 0 1
110442: PPUSH
110443: LD_STRING M
110445: PUSH
110446: LD_VAR 0 6
110450: PUSH
110451: LD_INT 1
110453: ARRAY
110454: PUSH
110455: LD_VAR 0 6
110459: PUSH
110460: LD_INT 2
110462: ARRAY
110463: PUSH
110464: LD_INT 0
110466: PUSH
110467: LD_INT 0
110469: PUSH
110470: LD_INT 0
110472: PUSH
110473: LD_INT 0
110475: PUSH
110476: EMPTY
110477: LIST
110478: LIST
110479: LIST
110480: LIST
110481: LIST
110482: LIST
110483: LIST
110484: PUSH
110485: EMPTY
110486: LIST
110487: PPUSH
110488: CALL_OW 447
110492: GO 110435
110494: POP
110495: POP
// end ;
110496: LD_VAR 0 5
110500: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
110501: LD_EXP 185
110505: NOT
110506: IFFALSE 110556
110508: GO 110510
110510: DISABLE
// begin initHack := true ;
110511: LD_ADDR_EXP 185
110515: PUSH
110516: LD_INT 1
110518: ST_TO_ADDR
// hackTanks := [ ] ;
110519: LD_ADDR_EXP 186
110523: PUSH
110524: EMPTY
110525: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
110526: LD_ADDR_EXP 187
110530: PUSH
110531: EMPTY
110532: ST_TO_ADDR
// hackLimit := 3 ;
110533: LD_ADDR_EXP 188
110537: PUSH
110538: LD_INT 3
110540: ST_TO_ADDR
// hackDist := 12 ;
110541: LD_ADDR_EXP 189
110545: PUSH
110546: LD_INT 12
110548: ST_TO_ADDR
// hackCounter := [ ] ;
110549: LD_ADDR_EXP 190
110553: PUSH
110554: EMPTY
110555: ST_TO_ADDR
// end ;
110556: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
110557: LD_EXP 185
110561: PUSH
110562: LD_INT 34
110564: PUSH
110565: LD_INT 99
110567: PUSH
110568: EMPTY
110569: LIST
110570: LIST
110571: PPUSH
110572: CALL_OW 69
110576: AND
110577: IFFALSE 110830
110579: GO 110581
110581: DISABLE
110582: LD_INT 0
110584: PPUSH
110585: PPUSH
// begin enable ;
110586: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
110587: LD_ADDR_VAR 0 1
110591: PUSH
110592: LD_INT 34
110594: PUSH
110595: LD_INT 99
110597: PUSH
110598: EMPTY
110599: LIST
110600: LIST
110601: PPUSH
110602: CALL_OW 69
110606: PUSH
110607: FOR_IN
110608: IFFALSE 110828
// begin if not i in hackTanks then
110610: LD_VAR 0 1
110614: PUSH
110615: LD_EXP 186
110619: IN
110620: NOT
110621: IFFALSE 110704
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110623: LD_ADDR_EXP 186
110627: PUSH
110628: LD_EXP 186
110632: PPUSH
110633: LD_EXP 186
110637: PUSH
110638: LD_INT 1
110640: PLUS
110641: PPUSH
110642: LD_VAR 0 1
110646: PPUSH
110647: CALL_OW 1
110651: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
110652: LD_ADDR_EXP 187
110656: PUSH
110657: LD_EXP 187
110661: PPUSH
110662: LD_EXP 187
110666: PUSH
110667: LD_INT 1
110669: PLUS
110670: PPUSH
110671: EMPTY
110672: PPUSH
110673: CALL_OW 1
110677: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110678: LD_ADDR_EXP 190
110682: PUSH
110683: LD_EXP 190
110687: PPUSH
110688: LD_EXP 190
110692: PUSH
110693: LD_INT 1
110695: PLUS
110696: PPUSH
110697: EMPTY
110698: PPUSH
110699: CALL_OW 1
110703: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110704: LD_VAR 0 1
110708: PPUSH
110709: CALL_OW 302
110713: NOT
110714: IFFALSE 110727
// begin HackUnlinkAll ( i ) ;
110716: LD_VAR 0 1
110720: PPUSH
110721: CALL 110833 0 1
// continue ;
110725: GO 110607
// end ; HackCheckCapturedStatus ( i ) ;
110727: LD_VAR 0 1
110731: PPUSH
110732: CALL 111276 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110736: LD_ADDR_VAR 0 2
110740: PUSH
110741: LD_INT 81
110743: PUSH
110744: LD_VAR 0 1
110748: PPUSH
110749: CALL_OW 255
110753: PUSH
110754: EMPTY
110755: LIST
110756: LIST
110757: PUSH
110758: LD_INT 33
110760: PUSH
110761: LD_INT 3
110763: PUSH
110764: EMPTY
110765: LIST
110766: LIST
110767: PUSH
110768: LD_INT 91
110770: PUSH
110771: LD_VAR 0 1
110775: PUSH
110776: LD_EXP 189
110780: PUSH
110781: EMPTY
110782: LIST
110783: LIST
110784: LIST
110785: PUSH
110786: LD_INT 50
110788: PUSH
110789: EMPTY
110790: LIST
110791: PUSH
110792: EMPTY
110793: LIST
110794: LIST
110795: LIST
110796: LIST
110797: PPUSH
110798: CALL_OW 69
110802: ST_TO_ADDR
// if not tmp then
110803: LD_VAR 0 2
110807: NOT
110808: IFFALSE 110812
// continue ;
110810: GO 110607
// HackLink ( i , tmp ) ;
110812: LD_VAR 0 1
110816: PPUSH
110817: LD_VAR 0 2
110821: PPUSH
110822: CALL 110969 0 2
// end ;
110826: GO 110607
110828: POP
110829: POP
// end ;
110830: PPOPN 2
110832: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110833: LD_INT 0
110835: PPUSH
110836: PPUSH
110837: PPUSH
// if not hack in hackTanks then
110838: LD_VAR 0 1
110842: PUSH
110843: LD_EXP 186
110847: IN
110848: NOT
110849: IFFALSE 110853
// exit ;
110851: GO 110964
// index := GetElementIndex ( hackTanks , hack ) ;
110853: LD_ADDR_VAR 0 4
110857: PUSH
110858: LD_EXP 186
110862: PPUSH
110863: LD_VAR 0 1
110867: PPUSH
110868: CALL 56959 0 2
110872: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110873: LD_EXP 187
110877: PUSH
110878: LD_VAR 0 4
110882: ARRAY
110883: IFFALSE 110964
// begin for i in hackTanksCaptured [ index ] do
110885: LD_ADDR_VAR 0 3
110889: PUSH
110890: LD_EXP 187
110894: PUSH
110895: LD_VAR 0 4
110899: ARRAY
110900: PUSH
110901: FOR_IN
110902: IFFALSE 110928
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110904: LD_VAR 0 3
110908: PUSH
110909: LD_INT 1
110911: ARRAY
110912: PPUSH
110913: LD_VAR 0 3
110917: PUSH
110918: LD_INT 2
110920: ARRAY
110921: PPUSH
110922: CALL_OW 235
110926: GO 110901
110928: POP
110929: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110930: LD_ADDR_EXP 187
110934: PUSH
110935: LD_EXP 187
110939: PPUSH
110940: LD_VAR 0 4
110944: PPUSH
110945: EMPTY
110946: PPUSH
110947: CALL_OW 1
110951: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110952: LD_VAR 0 1
110956: PPUSH
110957: LD_INT 0
110959: PPUSH
110960: CALL_OW 505
// end ; end ;
110964: LD_VAR 0 2
110968: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110969: LD_INT 0
110971: PPUSH
110972: PPUSH
110973: PPUSH
// if not hack in hackTanks or not vehicles then
110974: LD_VAR 0 1
110978: PUSH
110979: LD_EXP 186
110983: IN
110984: NOT
110985: PUSH
110986: LD_VAR 0 2
110990: NOT
110991: OR
110992: IFFALSE 110996
// exit ;
110994: GO 111271
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110996: LD_ADDR_VAR 0 2
111000: PUSH
111001: LD_VAR 0 1
111005: PPUSH
111006: LD_VAR 0 2
111010: PPUSH
111011: LD_INT 1
111013: PPUSH
111014: LD_INT 1
111016: PPUSH
111017: CALL 57609 0 4
111021: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
111022: LD_ADDR_VAR 0 5
111026: PUSH
111027: LD_EXP 186
111031: PPUSH
111032: LD_VAR 0 1
111036: PPUSH
111037: CALL 56959 0 2
111041: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
111042: LD_EXP 187
111046: PUSH
111047: LD_VAR 0 5
111051: ARRAY
111052: PUSH
111053: LD_EXP 188
111057: LESS
111058: IFFALSE 111247
// begin for i := 1 to vehicles do
111060: LD_ADDR_VAR 0 4
111064: PUSH
111065: DOUBLE
111066: LD_INT 1
111068: DEC
111069: ST_TO_ADDR
111070: LD_VAR 0 2
111074: PUSH
111075: FOR_TO
111076: IFFALSE 111245
// begin if hackTanksCaptured [ index ] = hackLimit then
111078: LD_EXP 187
111082: PUSH
111083: LD_VAR 0 5
111087: ARRAY
111088: PUSH
111089: LD_EXP 188
111093: EQUAL
111094: IFFALSE 111098
// break ;
111096: GO 111245
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
111098: LD_ADDR_EXP 190
111102: PUSH
111103: LD_EXP 190
111107: PPUSH
111108: LD_VAR 0 5
111112: PPUSH
111113: LD_EXP 190
111117: PUSH
111118: LD_VAR 0 5
111122: ARRAY
111123: PUSH
111124: LD_INT 1
111126: PLUS
111127: PPUSH
111128: CALL_OW 1
111132: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
111133: LD_ADDR_EXP 187
111137: PUSH
111138: LD_EXP 187
111142: PPUSH
111143: LD_VAR 0 5
111147: PUSH
111148: LD_EXP 187
111152: PUSH
111153: LD_VAR 0 5
111157: ARRAY
111158: PUSH
111159: LD_INT 1
111161: PLUS
111162: PUSH
111163: EMPTY
111164: LIST
111165: LIST
111166: PPUSH
111167: LD_VAR 0 2
111171: PUSH
111172: LD_VAR 0 4
111176: ARRAY
111177: PUSH
111178: LD_VAR 0 2
111182: PUSH
111183: LD_VAR 0 4
111187: ARRAY
111188: PPUSH
111189: CALL_OW 255
111193: PUSH
111194: EMPTY
111195: LIST
111196: LIST
111197: PPUSH
111198: CALL 57174 0 3
111202: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
111203: LD_VAR 0 2
111207: PUSH
111208: LD_VAR 0 4
111212: ARRAY
111213: PPUSH
111214: LD_VAR 0 1
111218: PPUSH
111219: CALL_OW 255
111223: PPUSH
111224: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
111228: LD_VAR 0 2
111232: PUSH
111233: LD_VAR 0 4
111237: ARRAY
111238: PPUSH
111239: CALL_OW 141
// end ;
111243: GO 111075
111245: POP
111246: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111247: LD_VAR 0 1
111251: PPUSH
111252: LD_EXP 187
111256: PUSH
111257: LD_VAR 0 5
111261: ARRAY
111262: PUSH
111263: LD_INT 0
111265: PLUS
111266: PPUSH
111267: CALL_OW 505
// end ;
111271: LD_VAR 0 3
111275: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
111276: LD_INT 0
111278: PPUSH
111279: PPUSH
111280: PPUSH
111281: PPUSH
// if not hack in hackTanks then
111282: LD_VAR 0 1
111286: PUSH
111287: LD_EXP 186
111291: IN
111292: NOT
111293: IFFALSE 111297
// exit ;
111295: GO 111537
// index := GetElementIndex ( hackTanks , hack ) ;
111297: LD_ADDR_VAR 0 4
111301: PUSH
111302: LD_EXP 186
111306: PPUSH
111307: LD_VAR 0 1
111311: PPUSH
111312: CALL 56959 0 2
111316: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
111317: LD_ADDR_VAR 0 3
111321: PUSH
111322: DOUBLE
111323: LD_EXP 187
111327: PUSH
111328: LD_VAR 0 4
111332: ARRAY
111333: INC
111334: ST_TO_ADDR
111335: LD_INT 1
111337: PUSH
111338: FOR_DOWNTO
111339: IFFALSE 111511
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
111341: LD_ADDR_VAR 0 5
111345: PUSH
111346: LD_EXP 187
111350: PUSH
111351: LD_VAR 0 4
111355: ARRAY
111356: PUSH
111357: LD_VAR 0 3
111361: ARRAY
111362: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
111363: LD_VAR 0 5
111367: PUSH
111368: LD_INT 1
111370: ARRAY
111371: PPUSH
111372: CALL_OW 302
111376: NOT
111377: PUSH
111378: LD_VAR 0 5
111382: PUSH
111383: LD_INT 1
111385: ARRAY
111386: PPUSH
111387: CALL_OW 255
111391: PUSH
111392: LD_VAR 0 1
111396: PPUSH
111397: CALL_OW 255
111401: NONEQUAL
111402: OR
111403: IFFALSE 111509
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
111405: LD_VAR 0 5
111409: PUSH
111410: LD_INT 1
111412: ARRAY
111413: PPUSH
111414: CALL_OW 305
111418: PUSH
111419: LD_VAR 0 5
111423: PUSH
111424: LD_INT 1
111426: ARRAY
111427: PPUSH
111428: CALL_OW 255
111432: PUSH
111433: LD_VAR 0 1
111437: PPUSH
111438: CALL_OW 255
111442: EQUAL
111443: AND
111444: IFFALSE 111468
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
111446: LD_VAR 0 5
111450: PUSH
111451: LD_INT 1
111453: ARRAY
111454: PPUSH
111455: LD_VAR 0 5
111459: PUSH
111460: LD_INT 2
111462: ARRAY
111463: PPUSH
111464: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
111468: LD_ADDR_EXP 187
111472: PUSH
111473: LD_EXP 187
111477: PPUSH
111478: LD_VAR 0 4
111482: PPUSH
111483: LD_EXP 187
111487: PUSH
111488: LD_VAR 0 4
111492: ARRAY
111493: PPUSH
111494: LD_VAR 0 3
111498: PPUSH
111499: CALL_OW 3
111503: PPUSH
111504: CALL_OW 1
111508: ST_TO_ADDR
// end ; end ;
111509: GO 111338
111511: POP
111512: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111513: LD_VAR 0 1
111517: PPUSH
111518: LD_EXP 187
111522: PUSH
111523: LD_VAR 0 4
111527: ARRAY
111528: PUSH
111529: LD_INT 0
111531: PLUS
111532: PPUSH
111533: CALL_OW 505
// end ;
111537: LD_VAR 0 2
111541: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
111542: LD_INT 0
111544: PPUSH
111545: PPUSH
111546: PPUSH
111547: PPUSH
// if not hack in hackTanks then
111548: LD_VAR 0 1
111552: PUSH
111553: LD_EXP 186
111557: IN
111558: NOT
111559: IFFALSE 111563
// exit ;
111561: GO 111648
// index := GetElementIndex ( hackTanks , hack ) ;
111563: LD_ADDR_VAR 0 5
111567: PUSH
111568: LD_EXP 186
111572: PPUSH
111573: LD_VAR 0 1
111577: PPUSH
111578: CALL 56959 0 2
111582: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
111583: LD_ADDR_VAR 0 4
111587: PUSH
111588: DOUBLE
111589: LD_INT 1
111591: DEC
111592: ST_TO_ADDR
111593: LD_EXP 187
111597: PUSH
111598: LD_VAR 0 5
111602: ARRAY
111603: PUSH
111604: FOR_TO
111605: IFFALSE 111646
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
111607: LD_EXP 187
111611: PUSH
111612: LD_VAR 0 5
111616: ARRAY
111617: PUSH
111618: LD_VAR 0 4
111622: ARRAY
111623: PUSH
111624: LD_INT 1
111626: ARRAY
111627: PUSH
111628: LD_VAR 0 2
111632: EQUAL
111633: IFFALSE 111644
// KillUnit ( vehicle ) ;
111635: LD_VAR 0 2
111639: PPUSH
111640: CALL_OW 66
111644: GO 111604
111646: POP
111647: POP
// end ;
111648: LD_VAR 0 3
111652: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
111653: LD_EXP 191
111657: NOT
111658: IFFALSE 111693
111660: GO 111662
111662: DISABLE
// begin initMiner := true ;
111663: LD_ADDR_EXP 191
111667: PUSH
111668: LD_INT 1
111670: ST_TO_ADDR
// minersList := [ ] ;
111671: LD_ADDR_EXP 192
111675: PUSH
111676: EMPTY
111677: ST_TO_ADDR
// minerMinesList := [ ] ;
111678: LD_ADDR_EXP 193
111682: PUSH
111683: EMPTY
111684: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
111685: LD_ADDR_EXP 194
111689: PUSH
111690: LD_INT 5
111692: ST_TO_ADDR
// end ;
111693: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111694: LD_EXP 191
111698: PUSH
111699: LD_INT 34
111701: PUSH
111702: LD_INT 81
111704: PUSH
111705: EMPTY
111706: LIST
111707: LIST
111708: PPUSH
111709: CALL_OW 69
111713: AND
111714: IFFALSE 112175
111716: GO 111718
111718: DISABLE
111719: LD_INT 0
111721: PPUSH
111722: PPUSH
111723: PPUSH
111724: PPUSH
// begin enable ;
111725: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111726: LD_ADDR_VAR 0 1
111730: PUSH
111731: LD_INT 34
111733: PUSH
111734: LD_INT 81
111736: PUSH
111737: EMPTY
111738: LIST
111739: LIST
111740: PPUSH
111741: CALL_OW 69
111745: PUSH
111746: FOR_IN
111747: IFFALSE 111819
// begin if not i in minersList then
111749: LD_VAR 0 1
111753: PUSH
111754: LD_EXP 192
111758: IN
111759: NOT
111760: IFFALSE 111817
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111762: LD_ADDR_EXP 192
111766: PUSH
111767: LD_EXP 192
111771: PPUSH
111772: LD_EXP 192
111776: PUSH
111777: LD_INT 1
111779: PLUS
111780: PPUSH
111781: LD_VAR 0 1
111785: PPUSH
111786: CALL_OW 1
111790: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111791: LD_ADDR_EXP 193
111795: PUSH
111796: LD_EXP 193
111800: PPUSH
111801: LD_EXP 193
111805: PUSH
111806: LD_INT 1
111808: PLUS
111809: PPUSH
111810: EMPTY
111811: PPUSH
111812: CALL_OW 1
111816: ST_TO_ADDR
// end end ;
111817: GO 111746
111819: POP
111820: POP
// for i := minerMinesList downto 1 do
111821: LD_ADDR_VAR 0 1
111825: PUSH
111826: DOUBLE
111827: LD_EXP 193
111831: INC
111832: ST_TO_ADDR
111833: LD_INT 1
111835: PUSH
111836: FOR_DOWNTO
111837: IFFALSE 112173
// begin if IsLive ( minersList [ i ] ) then
111839: LD_EXP 192
111843: PUSH
111844: LD_VAR 0 1
111848: ARRAY
111849: PPUSH
111850: CALL_OW 300
111854: IFFALSE 111882
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111856: LD_EXP 192
111860: PUSH
111861: LD_VAR 0 1
111865: ARRAY
111866: PPUSH
111867: LD_EXP 193
111871: PUSH
111872: LD_VAR 0 1
111876: ARRAY
111877: PPUSH
111878: CALL_OW 505
// if not minerMinesList [ i ] then
111882: LD_EXP 193
111886: PUSH
111887: LD_VAR 0 1
111891: ARRAY
111892: NOT
111893: IFFALSE 111897
// continue ;
111895: GO 111836
// for j := minerMinesList [ i ] downto 1 do
111897: LD_ADDR_VAR 0 2
111901: PUSH
111902: DOUBLE
111903: LD_EXP 193
111907: PUSH
111908: LD_VAR 0 1
111912: ARRAY
111913: INC
111914: ST_TO_ADDR
111915: LD_INT 1
111917: PUSH
111918: FOR_DOWNTO
111919: IFFALSE 112169
// begin side := GetSide ( minersList [ i ] ) ;
111921: LD_ADDR_VAR 0 3
111925: PUSH
111926: LD_EXP 192
111930: PUSH
111931: LD_VAR 0 1
111935: ARRAY
111936: PPUSH
111937: CALL_OW 255
111941: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111942: LD_ADDR_VAR 0 4
111946: PUSH
111947: LD_EXP 193
111951: PUSH
111952: LD_VAR 0 1
111956: ARRAY
111957: PUSH
111958: LD_VAR 0 2
111962: ARRAY
111963: PUSH
111964: LD_INT 1
111966: ARRAY
111967: PPUSH
111968: LD_EXP 193
111972: PUSH
111973: LD_VAR 0 1
111977: ARRAY
111978: PUSH
111979: LD_VAR 0 2
111983: ARRAY
111984: PUSH
111985: LD_INT 2
111987: ARRAY
111988: PPUSH
111989: CALL_OW 428
111993: ST_TO_ADDR
// if not tmp then
111994: LD_VAR 0 4
111998: NOT
111999: IFFALSE 112003
// continue ;
112001: GO 111918
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
112003: LD_VAR 0 4
112007: PUSH
112008: LD_INT 81
112010: PUSH
112011: LD_VAR 0 3
112015: PUSH
112016: EMPTY
112017: LIST
112018: LIST
112019: PPUSH
112020: CALL_OW 69
112024: IN
112025: PUSH
112026: LD_EXP 193
112030: PUSH
112031: LD_VAR 0 1
112035: ARRAY
112036: PUSH
112037: LD_VAR 0 2
112041: ARRAY
112042: PUSH
112043: LD_INT 1
112045: ARRAY
112046: PPUSH
112047: LD_EXP 193
112051: PUSH
112052: LD_VAR 0 1
112056: ARRAY
112057: PUSH
112058: LD_VAR 0 2
112062: ARRAY
112063: PUSH
112064: LD_INT 2
112066: ARRAY
112067: PPUSH
112068: CALL_OW 458
112072: AND
112073: IFFALSE 112167
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
112075: LD_EXP 193
112079: PUSH
112080: LD_VAR 0 1
112084: ARRAY
112085: PUSH
112086: LD_VAR 0 2
112090: ARRAY
112091: PUSH
112092: LD_INT 1
112094: ARRAY
112095: PPUSH
112096: LD_EXP 193
112100: PUSH
112101: LD_VAR 0 1
112105: ARRAY
112106: PUSH
112107: LD_VAR 0 2
112111: ARRAY
112112: PUSH
112113: LD_INT 2
112115: ARRAY
112116: PPUSH
112117: LD_VAR 0 3
112121: PPUSH
112122: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
112126: LD_ADDR_EXP 193
112130: PUSH
112131: LD_EXP 193
112135: PPUSH
112136: LD_VAR 0 1
112140: PPUSH
112141: LD_EXP 193
112145: PUSH
112146: LD_VAR 0 1
112150: ARRAY
112151: PPUSH
112152: LD_VAR 0 2
112156: PPUSH
112157: CALL_OW 3
112161: PPUSH
112162: CALL_OW 1
112166: ST_TO_ADDR
// end ; end ;
112167: GO 111918
112169: POP
112170: POP
// end ;
112171: GO 111836
112173: POP
112174: POP
// end ;
112175: PPOPN 4
112177: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
112178: LD_INT 0
112180: PPUSH
112181: PPUSH
// result := false ;
112182: LD_ADDR_VAR 0 4
112186: PUSH
112187: LD_INT 0
112189: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
112190: LD_VAR 0 1
112194: PPUSH
112195: CALL_OW 264
112199: PUSH
112200: LD_INT 81
112202: EQUAL
112203: NOT
112204: IFFALSE 112208
// exit ;
112206: GO 112448
// index := GetElementIndex ( minersList , unit ) ;
112208: LD_ADDR_VAR 0 5
112212: PUSH
112213: LD_EXP 192
112217: PPUSH
112218: LD_VAR 0 1
112222: PPUSH
112223: CALL 56959 0 2
112227: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
112228: LD_EXP 193
112232: PUSH
112233: LD_VAR 0 5
112237: ARRAY
112238: PUSH
112239: LD_EXP 194
112243: GREATEREQUAL
112244: IFFALSE 112248
// exit ;
112246: GO 112448
// ComMoveXY ( unit , x , y ) ;
112248: LD_VAR 0 1
112252: PPUSH
112253: LD_VAR 0 2
112257: PPUSH
112258: LD_VAR 0 3
112262: PPUSH
112263: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112267: LD_INT 35
112269: PPUSH
112270: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
112274: LD_VAR 0 1
112278: PPUSH
112279: LD_VAR 0 2
112283: PPUSH
112284: LD_VAR 0 3
112288: PPUSH
112289: CALL 88314 0 3
112293: NOT
112294: PUSH
112295: LD_VAR 0 1
112299: PPUSH
112300: CALL_OW 314
112304: AND
112305: IFFALSE 112309
// exit ;
112307: GO 112448
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
112309: LD_VAR 0 2
112313: PPUSH
112314: LD_VAR 0 3
112318: PPUSH
112319: CALL_OW 428
112323: PUSH
112324: LD_VAR 0 1
112328: EQUAL
112329: PUSH
112330: LD_VAR 0 1
112334: PPUSH
112335: CALL_OW 314
112339: NOT
112340: AND
112341: IFFALSE 112267
// PlaySoundXY ( x , y , PlantMine ) ;
112343: LD_VAR 0 2
112347: PPUSH
112348: LD_VAR 0 3
112352: PPUSH
112353: LD_STRING PlantMine
112355: PPUSH
112356: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
112360: LD_VAR 0 2
112364: PPUSH
112365: LD_VAR 0 3
112369: PPUSH
112370: LD_VAR 0 1
112374: PPUSH
112375: CALL_OW 255
112379: PPUSH
112380: LD_INT 0
112382: PPUSH
112383: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
112387: LD_ADDR_EXP 193
112391: PUSH
112392: LD_EXP 193
112396: PPUSH
112397: LD_VAR 0 5
112401: PUSH
112402: LD_EXP 193
112406: PUSH
112407: LD_VAR 0 5
112411: ARRAY
112412: PUSH
112413: LD_INT 1
112415: PLUS
112416: PUSH
112417: EMPTY
112418: LIST
112419: LIST
112420: PPUSH
112421: LD_VAR 0 2
112425: PUSH
112426: LD_VAR 0 3
112430: PUSH
112431: EMPTY
112432: LIST
112433: LIST
112434: PPUSH
112435: CALL 57174 0 3
112439: ST_TO_ADDR
// result := true ;
112440: LD_ADDR_VAR 0 4
112444: PUSH
112445: LD_INT 1
112447: ST_TO_ADDR
// end ;
112448: LD_VAR 0 4
112452: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
112453: LD_INT 0
112455: PPUSH
112456: PPUSH
112457: PPUSH
// if not unit in minersList then
112458: LD_VAR 0 1
112462: PUSH
112463: LD_EXP 192
112467: IN
112468: NOT
112469: IFFALSE 112473
// exit ;
112471: GO 112865
// index := GetElementIndex ( minersList , unit ) ;
112473: LD_ADDR_VAR 0 6
112477: PUSH
112478: LD_EXP 192
112482: PPUSH
112483: LD_VAR 0 1
112487: PPUSH
112488: CALL 56959 0 2
112492: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
112493: LD_ADDR_VAR 0 5
112497: PUSH
112498: DOUBLE
112499: LD_EXP 193
112503: PUSH
112504: LD_VAR 0 6
112508: ARRAY
112509: INC
112510: ST_TO_ADDR
112511: LD_INT 1
112513: PUSH
112514: FOR_DOWNTO
112515: IFFALSE 112676
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
112517: LD_EXP 193
112521: PUSH
112522: LD_VAR 0 6
112526: ARRAY
112527: PUSH
112528: LD_VAR 0 5
112532: ARRAY
112533: PUSH
112534: LD_INT 1
112536: ARRAY
112537: PUSH
112538: LD_VAR 0 2
112542: EQUAL
112543: PUSH
112544: LD_EXP 193
112548: PUSH
112549: LD_VAR 0 6
112553: ARRAY
112554: PUSH
112555: LD_VAR 0 5
112559: ARRAY
112560: PUSH
112561: LD_INT 2
112563: ARRAY
112564: PUSH
112565: LD_VAR 0 3
112569: EQUAL
112570: AND
112571: IFFALSE 112674
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112573: LD_EXP 193
112577: PUSH
112578: LD_VAR 0 6
112582: ARRAY
112583: PUSH
112584: LD_VAR 0 5
112588: ARRAY
112589: PUSH
112590: LD_INT 1
112592: ARRAY
112593: PPUSH
112594: LD_EXP 193
112598: PUSH
112599: LD_VAR 0 6
112603: ARRAY
112604: PUSH
112605: LD_VAR 0 5
112609: ARRAY
112610: PUSH
112611: LD_INT 2
112613: ARRAY
112614: PPUSH
112615: LD_VAR 0 1
112619: PPUSH
112620: CALL_OW 255
112624: PPUSH
112625: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112629: LD_ADDR_EXP 193
112633: PUSH
112634: LD_EXP 193
112638: PPUSH
112639: LD_VAR 0 6
112643: PPUSH
112644: LD_EXP 193
112648: PUSH
112649: LD_VAR 0 6
112653: ARRAY
112654: PPUSH
112655: LD_VAR 0 5
112659: PPUSH
112660: CALL_OW 3
112664: PPUSH
112665: CALL_OW 1
112669: ST_TO_ADDR
// exit ;
112670: POP
112671: POP
112672: GO 112865
// end ; end ;
112674: GO 112514
112676: POP
112677: POP
// for i := minerMinesList [ index ] downto 1 do
112678: LD_ADDR_VAR 0 5
112682: PUSH
112683: DOUBLE
112684: LD_EXP 193
112688: PUSH
112689: LD_VAR 0 6
112693: ARRAY
112694: INC
112695: ST_TO_ADDR
112696: LD_INT 1
112698: PUSH
112699: FOR_DOWNTO
112700: IFFALSE 112863
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112702: LD_EXP 193
112706: PUSH
112707: LD_VAR 0 6
112711: ARRAY
112712: PUSH
112713: LD_VAR 0 5
112717: ARRAY
112718: PUSH
112719: LD_INT 1
112721: ARRAY
112722: PPUSH
112723: LD_EXP 193
112727: PUSH
112728: LD_VAR 0 6
112732: ARRAY
112733: PUSH
112734: LD_VAR 0 5
112738: ARRAY
112739: PUSH
112740: LD_INT 2
112742: ARRAY
112743: PPUSH
112744: LD_VAR 0 2
112748: PPUSH
112749: LD_VAR 0 3
112753: PPUSH
112754: CALL_OW 298
112758: PUSH
112759: LD_INT 6
112761: LESS
112762: IFFALSE 112861
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112764: LD_EXP 193
112768: PUSH
112769: LD_VAR 0 6
112773: ARRAY
112774: PUSH
112775: LD_VAR 0 5
112779: ARRAY
112780: PUSH
112781: LD_INT 1
112783: ARRAY
112784: PPUSH
112785: LD_EXP 193
112789: PUSH
112790: LD_VAR 0 6
112794: ARRAY
112795: PUSH
112796: LD_VAR 0 5
112800: ARRAY
112801: PUSH
112802: LD_INT 2
112804: ARRAY
112805: PPUSH
112806: LD_VAR 0 1
112810: PPUSH
112811: CALL_OW 255
112815: PPUSH
112816: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112820: LD_ADDR_EXP 193
112824: PUSH
112825: LD_EXP 193
112829: PPUSH
112830: LD_VAR 0 6
112834: PPUSH
112835: LD_EXP 193
112839: PUSH
112840: LD_VAR 0 6
112844: ARRAY
112845: PPUSH
112846: LD_VAR 0 5
112850: PPUSH
112851: CALL_OW 3
112855: PPUSH
112856: CALL_OW 1
112860: ST_TO_ADDR
// end ; end ;
112861: GO 112699
112863: POP
112864: POP
// end ;
112865: LD_VAR 0 4
112869: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112870: LD_INT 0
112872: PPUSH
112873: PPUSH
112874: PPUSH
112875: PPUSH
112876: PPUSH
112877: PPUSH
112878: PPUSH
112879: PPUSH
112880: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112881: LD_VAR 0 1
112885: PPUSH
112886: CALL_OW 264
112890: PUSH
112891: LD_INT 81
112893: EQUAL
112894: NOT
112895: PUSH
112896: LD_VAR 0 1
112900: PUSH
112901: LD_EXP 192
112905: IN
112906: NOT
112907: OR
112908: IFFALSE 112912
// exit ;
112910: GO 113234
// index := GetElementIndex ( minersList , unit ) ;
112912: LD_ADDR_VAR 0 6
112916: PUSH
112917: LD_EXP 192
112921: PPUSH
112922: LD_VAR 0 1
112926: PPUSH
112927: CALL 56959 0 2
112931: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112932: LD_ADDR_VAR 0 8
112936: PUSH
112937: LD_EXP 194
112941: PUSH
112942: LD_EXP 193
112946: PUSH
112947: LD_VAR 0 6
112951: ARRAY
112952: MINUS
112953: ST_TO_ADDR
// if not minesFreeAmount then
112954: LD_VAR 0 8
112958: NOT
112959: IFFALSE 112963
// exit ;
112961: GO 113234
// tmp := [ ] ;
112963: LD_ADDR_VAR 0 7
112967: PUSH
112968: EMPTY
112969: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112970: LD_ADDR_VAR 0 5
112974: PUSH
112975: DOUBLE
112976: LD_INT 1
112978: DEC
112979: ST_TO_ADDR
112980: LD_VAR 0 8
112984: PUSH
112985: FOR_TO
112986: IFFALSE 113181
// begin _d := rand ( 0 , 5 ) ;
112988: LD_ADDR_VAR 0 11
112992: PUSH
112993: LD_INT 0
112995: PPUSH
112996: LD_INT 5
112998: PPUSH
112999: CALL_OW 12
113003: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
113004: LD_ADDR_VAR 0 12
113008: PUSH
113009: LD_INT 2
113011: PPUSH
113012: LD_INT 6
113014: PPUSH
113015: CALL_OW 12
113019: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
113020: LD_ADDR_VAR 0 9
113024: PUSH
113025: LD_VAR 0 2
113029: PPUSH
113030: LD_VAR 0 11
113034: PPUSH
113035: LD_VAR 0 12
113039: PPUSH
113040: CALL_OW 272
113044: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
113045: LD_ADDR_VAR 0 10
113049: PUSH
113050: LD_VAR 0 3
113054: PPUSH
113055: LD_VAR 0 11
113059: PPUSH
113060: LD_VAR 0 12
113064: PPUSH
113065: CALL_OW 273
113069: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
113070: LD_VAR 0 9
113074: PPUSH
113075: LD_VAR 0 10
113079: PPUSH
113080: CALL_OW 488
113084: PUSH
113085: LD_VAR 0 9
113089: PUSH
113090: LD_VAR 0 10
113094: PUSH
113095: EMPTY
113096: LIST
113097: LIST
113098: PUSH
113099: LD_VAR 0 7
113103: IN
113104: NOT
113105: AND
113106: PUSH
113107: LD_VAR 0 9
113111: PPUSH
113112: LD_VAR 0 10
113116: PPUSH
113117: CALL_OW 458
113121: NOT
113122: AND
113123: IFFALSE 113165
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
113125: LD_ADDR_VAR 0 7
113129: PUSH
113130: LD_VAR 0 7
113134: PPUSH
113135: LD_VAR 0 7
113139: PUSH
113140: LD_INT 1
113142: PLUS
113143: PPUSH
113144: LD_VAR 0 9
113148: PUSH
113149: LD_VAR 0 10
113153: PUSH
113154: EMPTY
113155: LIST
113156: LIST
113157: PPUSH
113158: CALL_OW 1
113162: ST_TO_ADDR
113163: GO 113179
// i := i - 1 ;
113165: LD_ADDR_VAR 0 5
113169: PUSH
113170: LD_VAR 0 5
113174: PUSH
113175: LD_INT 1
113177: MINUS
113178: ST_TO_ADDR
// end ;
113179: GO 112985
113181: POP
113182: POP
// for i in tmp do
113183: LD_ADDR_VAR 0 5
113187: PUSH
113188: LD_VAR 0 7
113192: PUSH
113193: FOR_IN
113194: IFFALSE 113232
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
113196: LD_VAR 0 1
113200: PPUSH
113201: LD_VAR 0 5
113205: PUSH
113206: LD_INT 1
113208: ARRAY
113209: PPUSH
113210: LD_VAR 0 5
113214: PUSH
113215: LD_INT 2
113217: ARRAY
113218: PPUSH
113219: CALL 112178 0 3
113223: NOT
113224: IFFALSE 113230
// exit ;
113226: POP
113227: POP
113228: GO 113234
113230: GO 113193
113232: POP
113233: POP
// end ;
113234: LD_VAR 0 4
113238: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
113239: LD_INT 0
113241: PPUSH
113242: PPUSH
113243: PPUSH
113244: PPUSH
113245: PPUSH
113246: PPUSH
113247: PPUSH
// if not GetClass ( unit ) = class_sniper then
113248: LD_VAR 0 1
113252: PPUSH
113253: CALL_OW 257
113257: PUSH
113258: LD_INT 5
113260: EQUAL
113261: NOT
113262: IFFALSE 113266
// exit ;
113264: GO 113654
// dist := 8 ;
113266: LD_ADDR_VAR 0 5
113270: PUSH
113271: LD_INT 8
113273: ST_TO_ADDR
// viewRange := 12 ;
113274: LD_ADDR_VAR 0 7
113278: PUSH
113279: LD_INT 12
113281: ST_TO_ADDR
// side := GetSide ( unit ) ;
113282: LD_ADDR_VAR 0 6
113286: PUSH
113287: LD_VAR 0 1
113291: PPUSH
113292: CALL_OW 255
113296: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
113297: LD_INT 61
113299: PPUSH
113300: LD_VAR 0 6
113304: PPUSH
113305: CALL_OW 321
113309: PUSH
113310: LD_INT 2
113312: EQUAL
113313: IFFALSE 113323
// viewRange := 16 ;
113315: LD_ADDR_VAR 0 7
113319: PUSH
113320: LD_INT 16
113322: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
113323: LD_VAR 0 1
113327: PPUSH
113328: LD_VAR 0 2
113332: PPUSH
113333: LD_VAR 0 3
113337: PPUSH
113338: CALL_OW 297
113342: PUSH
113343: LD_VAR 0 5
113347: GREATER
113348: IFFALSE 113427
// begin ComMoveXY ( unit , x , y ) ;
113350: LD_VAR 0 1
113354: PPUSH
113355: LD_VAR 0 2
113359: PPUSH
113360: LD_VAR 0 3
113364: PPUSH
113365: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113369: LD_INT 35
113371: PPUSH
113372: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
113376: LD_VAR 0 1
113380: PPUSH
113381: LD_VAR 0 2
113385: PPUSH
113386: LD_VAR 0 3
113390: PPUSH
113391: CALL 88314 0 3
113395: NOT
113396: IFFALSE 113400
// exit ;
113398: GO 113654
// until GetDistUnitXY ( unit , x , y ) < dist ;
113400: LD_VAR 0 1
113404: PPUSH
113405: LD_VAR 0 2
113409: PPUSH
113410: LD_VAR 0 3
113414: PPUSH
113415: CALL_OW 297
113419: PUSH
113420: LD_VAR 0 5
113424: LESS
113425: IFFALSE 113369
// end ; ComTurnXY ( unit , x , y ) ;
113427: LD_VAR 0 1
113431: PPUSH
113432: LD_VAR 0 2
113436: PPUSH
113437: LD_VAR 0 3
113441: PPUSH
113442: CALL_OW 118
// wait ( 5 ) ;
113446: LD_INT 5
113448: PPUSH
113449: CALL_OW 67
// _d := GetDir ( unit ) ;
113453: LD_ADDR_VAR 0 10
113457: PUSH
113458: LD_VAR 0 1
113462: PPUSH
113463: CALL_OW 254
113467: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
113468: LD_ADDR_VAR 0 8
113472: PUSH
113473: LD_VAR 0 1
113477: PPUSH
113478: CALL_OW 250
113482: PPUSH
113483: LD_VAR 0 10
113487: PPUSH
113488: LD_VAR 0 5
113492: PPUSH
113493: CALL_OW 272
113497: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
113498: LD_ADDR_VAR 0 9
113502: PUSH
113503: LD_VAR 0 1
113507: PPUSH
113508: CALL_OW 251
113512: PPUSH
113513: LD_VAR 0 10
113517: PPUSH
113518: LD_VAR 0 5
113522: PPUSH
113523: CALL_OW 273
113527: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
113528: LD_VAR 0 8
113532: PPUSH
113533: LD_VAR 0 9
113537: PPUSH
113538: CALL_OW 488
113542: NOT
113543: IFFALSE 113547
// exit ;
113545: GO 113654
// ComAnimCustom ( unit , 1 ) ;
113547: LD_VAR 0 1
113551: PPUSH
113552: LD_INT 1
113554: PPUSH
113555: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
113559: LD_VAR 0 8
113563: PPUSH
113564: LD_VAR 0 9
113568: PPUSH
113569: LD_VAR 0 6
113573: PPUSH
113574: LD_VAR 0 7
113578: PPUSH
113579: CALL_OW 330
// repeat wait ( 1 ) ;
113583: LD_INT 1
113585: PPUSH
113586: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
113590: LD_VAR 0 1
113594: PPUSH
113595: CALL_OW 316
113599: PUSH
113600: LD_VAR 0 1
113604: PPUSH
113605: CALL_OW 314
113609: OR
113610: PUSH
113611: LD_VAR 0 1
113615: PPUSH
113616: CALL_OW 302
113620: NOT
113621: OR
113622: PUSH
113623: LD_VAR 0 1
113627: PPUSH
113628: CALL_OW 301
113632: OR
113633: IFFALSE 113583
// RemoveSeeing ( _x , _y , side ) ;
113635: LD_VAR 0 8
113639: PPUSH
113640: LD_VAR 0 9
113644: PPUSH
113645: LD_VAR 0 6
113649: PPUSH
113650: CALL_OW 331
// end ; end_of_file
113654: LD_VAR 0 4
113658: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113659: LD_INT 0
113661: PPUSH
113662: PPUSH
113663: PPUSH
113664: PPUSH
113665: PPUSH
113666: PPUSH
113667: PPUSH
113668: PPUSH
113669: PPUSH
113670: PPUSH
113671: PPUSH
113672: PPUSH
113673: PPUSH
113674: PPUSH
113675: PPUSH
113676: PPUSH
113677: PPUSH
113678: PPUSH
113679: PPUSH
113680: PPUSH
113681: PPUSH
113682: PPUSH
113683: PPUSH
113684: PPUSH
113685: PPUSH
113686: PPUSH
113687: PPUSH
113688: PPUSH
113689: PPUSH
113690: PPUSH
113691: PPUSH
113692: PPUSH
113693: PPUSH
113694: PPUSH
// if not list then
113695: LD_VAR 0 1
113699: NOT
113700: IFFALSE 113704
// exit ;
113702: GO 118363
// base := list [ 1 ] ;
113704: LD_ADDR_VAR 0 3
113708: PUSH
113709: LD_VAR 0 1
113713: PUSH
113714: LD_INT 1
113716: ARRAY
113717: ST_TO_ADDR
// group := list [ 2 ] ;
113718: LD_ADDR_VAR 0 4
113722: PUSH
113723: LD_VAR 0 1
113727: PUSH
113728: LD_INT 2
113730: ARRAY
113731: ST_TO_ADDR
// path := list [ 3 ] ;
113732: LD_ADDR_VAR 0 5
113736: PUSH
113737: LD_VAR 0 1
113741: PUSH
113742: LD_INT 3
113744: ARRAY
113745: ST_TO_ADDR
// flags := list [ 4 ] ;
113746: LD_ADDR_VAR 0 6
113750: PUSH
113751: LD_VAR 0 1
113755: PUSH
113756: LD_INT 4
113758: ARRAY
113759: ST_TO_ADDR
// mined := [ ] ;
113760: LD_ADDR_VAR 0 27
113764: PUSH
113765: EMPTY
113766: ST_TO_ADDR
// bombed := [ ] ;
113767: LD_ADDR_VAR 0 28
113771: PUSH
113772: EMPTY
113773: ST_TO_ADDR
// healers := [ ] ;
113774: LD_ADDR_VAR 0 31
113778: PUSH
113779: EMPTY
113780: ST_TO_ADDR
// to_heal := [ ] ;
113781: LD_ADDR_VAR 0 30
113785: PUSH
113786: EMPTY
113787: ST_TO_ADDR
// repairs := [ ] ;
113788: LD_ADDR_VAR 0 33
113792: PUSH
113793: EMPTY
113794: ST_TO_ADDR
// to_repair := [ ] ;
113795: LD_ADDR_VAR 0 32
113799: PUSH
113800: EMPTY
113801: ST_TO_ADDR
// if not group or not path then
113802: LD_VAR 0 4
113806: NOT
113807: PUSH
113808: LD_VAR 0 5
113812: NOT
113813: OR
113814: IFFALSE 113818
// exit ;
113816: GO 118363
// side := GetSide ( group [ 1 ] ) ;
113818: LD_ADDR_VAR 0 35
113822: PUSH
113823: LD_VAR 0 4
113827: PUSH
113828: LD_INT 1
113830: ARRAY
113831: PPUSH
113832: CALL_OW 255
113836: ST_TO_ADDR
// if flags then
113837: LD_VAR 0 6
113841: IFFALSE 113985
// begin f_ignore_area := flags [ 1 ] ;
113843: LD_ADDR_VAR 0 17
113847: PUSH
113848: LD_VAR 0 6
113852: PUSH
113853: LD_INT 1
113855: ARRAY
113856: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113857: LD_ADDR_VAR 0 18
113861: PUSH
113862: LD_VAR 0 6
113866: PUSH
113867: LD_INT 2
113869: ARRAY
113870: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113871: LD_ADDR_VAR 0 19
113875: PUSH
113876: LD_VAR 0 6
113880: PUSH
113881: LD_INT 3
113883: ARRAY
113884: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113885: LD_ADDR_VAR 0 20
113889: PUSH
113890: LD_VAR 0 6
113894: PUSH
113895: LD_INT 4
113897: ARRAY
113898: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113899: LD_ADDR_VAR 0 21
113903: PUSH
113904: LD_VAR 0 6
113908: PUSH
113909: LD_INT 5
113911: ARRAY
113912: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113913: LD_ADDR_VAR 0 22
113917: PUSH
113918: LD_VAR 0 6
113922: PUSH
113923: LD_INT 6
113925: ARRAY
113926: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113927: LD_ADDR_VAR 0 23
113931: PUSH
113932: LD_VAR 0 6
113936: PUSH
113937: LD_INT 7
113939: ARRAY
113940: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113941: LD_ADDR_VAR 0 24
113945: PUSH
113946: LD_VAR 0 6
113950: PUSH
113951: LD_INT 8
113953: ARRAY
113954: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113955: LD_ADDR_VAR 0 25
113959: PUSH
113960: LD_VAR 0 6
113964: PUSH
113965: LD_INT 9
113967: ARRAY
113968: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113969: LD_ADDR_VAR 0 26
113973: PUSH
113974: LD_VAR 0 6
113978: PUSH
113979: LD_INT 10
113981: ARRAY
113982: ST_TO_ADDR
// end else
113983: GO 114065
// begin f_ignore_area := false ;
113985: LD_ADDR_VAR 0 17
113989: PUSH
113990: LD_INT 0
113992: ST_TO_ADDR
// f_capture := false ;
113993: LD_ADDR_VAR 0 18
113997: PUSH
113998: LD_INT 0
114000: ST_TO_ADDR
// f_ignore_civ := false ;
114001: LD_ADDR_VAR 0 19
114005: PUSH
114006: LD_INT 0
114008: ST_TO_ADDR
// f_murder := false ;
114009: LD_ADDR_VAR 0 20
114013: PUSH
114014: LD_INT 0
114016: ST_TO_ADDR
// f_mines := false ;
114017: LD_ADDR_VAR 0 21
114021: PUSH
114022: LD_INT 0
114024: ST_TO_ADDR
// f_repair := false ;
114025: LD_ADDR_VAR 0 22
114029: PUSH
114030: LD_INT 0
114032: ST_TO_ADDR
// f_heal := false ;
114033: LD_ADDR_VAR 0 23
114037: PUSH
114038: LD_INT 0
114040: ST_TO_ADDR
// f_spacetime := false ;
114041: LD_ADDR_VAR 0 24
114045: PUSH
114046: LD_INT 0
114048: ST_TO_ADDR
// f_attack_depot := false ;
114049: LD_ADDR_VAR 0 25
114053: PUSH
114054: LD_INT 0
114056: ST_TO_ADDR
// f_crawl := false ;
114057: LD_ADDR_VAR 0 26
114061: PUSH
114062: LD_INT 0
114064: ST_TO_ADDR
// end ; if f_heal then
114065: LD_VAR 0 23
114069: IFFALSE 114096
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
114071: LD_ADDR_VAR 0 31
114075: PUSH
114076: LD_VAR 0 4
114080: PPUSH
114081: LD_INT 25
114083: PUSH
114084: LD_INT 4
114086: PUSH
114087: EMPTY
114088: LIST
114089: LIST
114090: PPUSH
114091: CALL_OW 72
114095: ST_TO_ADDR
// if f_repair then
114096: LD_VAR 0 22
114100: IFFALSE 114127
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
114102: LD_ADDR_VAR 0 33
114106: PUSH
114107: LD_VAR 0 4
114111: PPUSH
114112: LD_INT 25
114114: PUSH
114115: LD_INT 3
114117: PUSH
114118: EMPTY
114119: LIST
114120: LIST
114121: PPUSH
114122: CALL_OW 72
114126: ST_TO_ADDR
// units_path := [ ] ;
114127: LD_ADDR_VAR 0 16
114131: PUSH
114132: EMPTY
114133: ST_TO_ADDR
// for i = 1 to group do
114134: LD_ADDR_VAR 0 7
114138: PUSH
114139: DOUBLE
114140: LD_INT 1
114142: DEC
114143: ST_TO_ADDR
114144: LD_VAR 0 4
114148: PUSH
114149: FOR_TO
114150: IFFALSE 114179
// units_path := Replace ( units_path , i , path ) ;
114152: LD_ADDR_VAR 0 16
114156: PUSH
114157: LD_VAR 0 16
114161: PPUSH
114162: LD_VAR 0 7
114166: PPUSH
114167: LD_VAR 0 5
114171: PPUSH
114172: CALL_OW 1
114176: ST_TO_ADDR
114177: GO 114149
114179: POP
114180: POP
// repeat for i = group downto 1 do
114181: LD_ADDR_VAR 0 7
114185: PUSH
114186: DOUBLE
114187: LD_VAR 0 4
114191: INC
114192: ST_TO_ADDR
114193: LD_INT 1
114195: PUSH
114196: FOR_DOWNTO
114197: IFFALSE 118319
// begin wait ( 5 ) ;
114199: LD_INT 5
114201: PPUSH
114202: CALL_OW 67
// tmp := [ ] ;
114206: LD_ADDR_VAR 0 14
114210: PUSH
114211: EMPTY
114212: ST_TO_ADDR
// attacking := false ;
114213: LD_ADDR_VAR 0 29
114217: PUSH
114218: LD_INT 0
114220: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
114221: LD_VAR 0 4
114225: PUSH
114226: LD_VAR 0 7
114230: ARRAY
114231: PPUSH
114232: CALL_OW 301
114236: PUSH
114237: LD_VAR 0 4
114241: PUSH
114242: LD_VAR 0 7
114246: ARRAY
114247: NOT
114248: OR
114249: IFFALSE 114358
// begin if GetType ( group [ i ] ) = unit_human then
114251: LD_VAR 0 4
114255: PUSH
114256: LD_VAR 0 7
114260: ARRAY
114261: PPUSH
114262: CALL_OW 247
114266: PUSH
114267: LD_INT 1
114269: EQUAL
114270: IFFALSE 114316
// begin to_heal := to_heal diff group [ i ] ;
114272: LD_ADDR_VAR 0 30
114276: PUSH
114277: LD_VAR 0 30
114281: PUSH
114282: LD_VAR 0 4
114286: PUSH
114287: LD_VAR 0 7
114291: ARRAY
114292: DIFF
114293: ST_TO_ADDR
// healers := healers diff group [ i ] ;
114294: LD_ADDR_VAR 0 31
114298: PUSH
114299: LD_VAR 0 31
114303: PUSH
114304: LD_VAR 0 4
114308: PUSH
114309: LD_VAR 0 7
114313: ARRAY
114314: DIFF
114315: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
114316: LD_ADDR_VAR 0 4
114320: PUSH
114321: LD_VAR 0 4
114325: PPUSH
114326: LD_VAR 0 7
114330: PPUSH
114331: CALL_OW 3
114335: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
114336: LD_ADDR_VAR 0 16
114340: PUSH
114341: LD_VAR 0 16
114345: PPUSH
114346: LD_VAR 0 7
114350: PPUSH
114351: CALL_OW 3
114355: ST_TO_ADDR
// continue ;
114356: GO 114196
// end ; if f_repair then
114358: LD_VAR 0 22
114362: IFFALSE 114851
// begin if GetType ( group [ i ] ) = unit_vehicle then
114364: LD_VAR 0 4
114368: PUSH
114369: LD_VAR 0 7
114373: ARRAY
114374: PPUSH
114375: CALL_OW 247
114379: PUSH
114380: LD_INT 2
114382: EQUAL
114383: IFFALSE 114573
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
114385: LD_VAR 0 4
114389: PUSH
114390: LD_VAR 0 7
114394: ARRAY
114395: PPUSH
114396: CALL_OW 256
114400: PUSH
114401: LD_INT 700
114403: LESS
114404: PUSH
114405: LD_VAR 0 4
114409: PUSH
114410: LD_VAR 0 7
114414: ARRAY
114415: PUSH
114416: LD_VAR 0 32
114420: IN
114421: NOT
114422: AND
114423: IFFALSE 114447
// to_repair := to_repair union group [ i ] ;
114425: LD_ADDR_VAR 0 32
114429: PUSH
114430: LD_VAR 0 32
114434: PUSH
114435: LD_VAR 0 4
114439: PUSH
114440: LD_VAR 0 7
114444: ARRAY
114445: UNION
114446: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
114447: LD_VAR 0 4
114451: PUSH
114452: LD_VAR 0 7
114456: ARRAY
114457: PPUSH
114458: CALL_OW 256
114462: PUSH
114463: LD_INT 1000
114465: EQUAL
114466: PUSH
114467: LD_VAR 0 4
114471: PUSH
114472: LD_VAR 0 7
114476: ARRAY
114477: PUSH
114478: LD_VAR 0 32
114482: IN
114483: AND
114484: IFFALSE 114508
// to_repair := to_repair diff group [ i ] ;
114486: LD_ADDR_VAR 0 32
114490: PUSH
114491: LD_VAR 0 32
114495: PUSH
114496: LD_VAR 0 4
114500: PUSH
114501: LD_VAR 0 7
114505: ARRAY
114506: DIFF
114507: ST_TO_ADDR
// if group [ i ] in to_repair then
114508: LD_VAR 0 4
114512: PUSH
114513: LD_VAR 0 7
114517: ARRAY
114518: PUSH
114519: LD_VAR 0 32
114523: IN
114524: IFFALSE 114571
// begin if not IsInArea ( group [ i ] , f_repair ) then
114526: LD_VAR 0 4
114530: PUSH
114531: LD_VAR 0 7
114535: ARRAY
114536: PPUSH
114537: LD_VAR 0 22
114541: PPUSH
114542: CALL_OW 308
114546: NOT
114547: IFFALSE 114569
// ComMoveToArea ( group [ i ] , f_repair ) ;
114549: LD_VAR 0 4
114553: PUSH
114554: LD_VAR 0 7
114558: ARRAY
114559: PPUSH
114560: LD_VAR 0 22
114564: PPUSH
114565: CALL_OW 113
// continue ;
114569: GO 114196
// end ; end else
114571: GO 114851
// if group [ i ] in repairs then
114573: LD_VAR 0 4
114577: PUSH
114578: LD_VAR 0 7
114582: ARRAY
114583: PUSH
114584: LD_VAR 0 33
114588: IN
114589: IFFALSE 114851
// begin if IsInUnit ( group [ i ] ) then
114591: LD_VAR 0 4
114595: PUSH
114596: LD_VAR 0 7
114600: ARRAY
114601: PPUSH
114602: CALL_OW 310
114606: IFFALSE 114674
// begin z := IsInUnit ( group [ i ] ) ;
114608: LD_ADDR_VAR 0 13
114612: PUSH
114613: LD_VAR 0 4
114617: PUSH
114618: LD_VAR 0 7
114622: ARRAY
114623: PPUSH
114624: CALL_OW 310
114628: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114629: LD_VAR 0 13
114633: PUSH
114634: LD_VAR 0 32
114638: IN
114639: PUSH
114640: LD_VAR 0 13
114644: PPUSH
114645: LD_VAR 0 22
114649: PPUSH
114650: CALL_OW 308
114654: AND
114655: IFFALSE 114672
// ComExitVehicle ( group [ i ] ) ;
114657: LD_VAR 0 4
114661: PUSH
114662: LD_VAR 0 7
114666: ARRAY
114667: PPUSH
114668: CALL_OW 121
// end else
114672: GO 114851
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114674: LD_ADDR_VAR 0 13
114678: PUSH
114679: LD_VAR 0 4
114683: PPUSH
114684: LD_INT 95
114686: PUSH
114687: LD_VAR 0 22
114691: PUSH
114692: EMPTY
114693: LIST
114694: LIST
114695: PUSH
114696: LD_INT 58
114698: PUSH
114699: EMPTY
114700: LIST
114701: PUSH
114702: EMPTY
114703: LIST
114704: LIST
114705: PPUSH
114706: CALL_OW 72
114710: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114711: LD_VAR 0 4
114715: PUSH
114716: LD_VAR 0 7
114720: ARRAY
114721: PPUSH
114722: CALL_OW 314
114726: NOT
114727: IFFALSE 114849
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114729: LD_ADDR_VAR 0 10
114733: PUSH
114734: LD_VAR 0 13
114738: PPUSH
114739: LD_VAR 0 4
114743: PUSH
114744: LD_VAR 0 7
114748: ARRAY
114749: PPUSH
114750: CALL_OW 74
114754: ST_TO_ADDR
// if not x then
114755: LD_VAR 0 10
114759: NOT
114760: IFFALSE 114764
// continue ;
114762: GO 114196
// if GetLives ( x ) < 1000 then
114764: LD_VAR 0 10
114768: PPUSH
114769: CALL_OW 256
114773: PUSH
114774: LD_INT 1000
114776: LESS
114777: IFFALSE 114801
// ComRepairVehicle ( group [ i ] , x ) else
114779: LD_VAR 0 4
114783: PUSH
114784: LD_VAR 0 7
114788: ARRAY
114789: PPUSH
114790: LD_VAR 0 10
114794: PPUSH
114795: CALL_OW 129
114799: GO 114849
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114801: LD_VAR 0 23
114805: PUSH
114806: LD_VAR 0 4
114810: PUSH
114811: LD_VAR 0 7
114815: ARRAY
114816: PPUSH
114817: CALL_OW 256
114821: PUSH
114822: LD_INT 1000
114824: LESS
114825: AND
114826: NOT
114827: IFFALSE 114849
// ComEnterUnit ( group [ i ] , x ) ;
114829: LD_VAR 0 4
114833: PUSH
114834: LD_VAR 0 7
114838: ARRAY
114839: PPUSH
114840: LD_VAR 0 10
114844: PPUSH
114845: CALL_OW 120
// end ; continue ;
114849: GO 114196
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114851: LD_VAR 0 23
114855: PUSH
114856: LD_VAR 0 4
114860: PUSH
114861: LD_VAR 0 7
114865: ARRAY
114866: PPUSH
114867: CALL_OW 247
114871: PUSH
114872: LD_INT 1
114874: EQUAL
114875: AND
114876: IFFALSE 115354
// begin if group [ i ] in healers then
114878: LD_VAR 0 4
114882: PUSH
114883: LD_VAR 0 7
114887: ARRAY
114888: PUSH
114889: LD_VAR 0 31
114893: IN
114894: IFFALSE 115167
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114896: LD_VAR 0 4
114900: PUSH
114901: LD_VAR 0 7
114905: ARRAY
114906: PPUSH
114907: LD_VAR 0 23
114911: PPUSH
114912: CALL_OW 308
114916: NOT
114917: PUSH
114918: LD_VAR 0 4
114922: PUSH
114923: LD_VAR 0 7
114927: ARRAY
114928: PPUSH
114929: CALL_OW 314
114933: NOT
114934: AND
114935: IFFALSE 114959
// ComMoveToArea ( group [ i ] , f_heal ) else
114937: LD_VAR 0 4
114941: PUSH
114942: LD_VAR 0 7
114946: ARRAY
114947: PPUSH
114948: LD_VAR 0 23
114952: PPUSH
114953: CALL_OW 113
114957: GO 115165
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114959: LD_VAR 0 4
114963: PUSH
114964: LD_VAR 0 7
114968: ARRAY
114969: PPUSH
114970: CALL 86897 0 1
114974: PPUSH
114975: CALL_OW 256
114979: PUSH
114980: LD_INT 1000
114982: EQUAL
114983: IFFALSE 115002
// ComStop ( group [ i ] ) else
114985: LD_VAR 0 4
114989: PUSH
114990: LD_VAR 0 7
114994: ARRAY
114995: PPUSH
114996: CALL_OW 141
115000: GO 115165
// if not HasTask ( group [ i ] ) and to_heal then
115002: LD_VAR 0 4
115006: PUSH
115007: LD_VAR 0 7
115011: ARRAY
115012: PPUSH
115013: CALL_OW 314
115017: NOT
115018: PUSH
115019: LD_VAR 0 30
115023: AND
115024: IFFALSE 115165
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
115026: LD_ADDR_VAR 0 13
115030: PUSH
115031: LD_VAR 0 30
115035: PPUSH
115036: LD_INT 3
115038: PUSH
115039: LD_INT 54
115041: PUSH
115042: EMPTY
115043: LIST
115044: PUSH
115045: EMPTY
115046: LIST
115047: LIST
115048: PPUSH
115049: CALL_OW 72
115053: PPUSH
115054: LD_VAR 0 4
115058: PUSH
115059: LD_VAR 0 7
115063: ARRAY
115064: PPUSH
115065: CALL_OW 74
115069: ST_TO_ADDR
// if z then
115070: LD_VAR 0 13
115074: IFFALSE 115165
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
115076: LD_INT 91
115078: PUSH
115079: LD_VAR 0 13
115083: PUSH
115084: LD_INT 10
115086: PUSH
115087: EMPTY
115088: LIST
115089: LIST
115090: LIST
115091: PUSH
115092: LD_INT 81
115094: PUSH
115095: LD_VAR 0 13
115099: PPUSH
115100: CALL_OW 255
115104: PUSH
115105: EMPTY
115106: LIST
115107: LIST
115108: PUSH
115109: EMPTY
115110: LIST
115111: LIST
115112: PPUSH
115113: CALL_OW 69
115117: PUSH
115118: LD_INT 0
115120: EQUAL
115121: IFFALSE 115145
// ComHeal ( group [ i ] , z ) else
115123: LD_VAR 0 4
115127: PUSH
115128: LD_VAR 0 7
115132: ARRAY
115133: PPUSH
115134: LD_VAR 0 13
115138: PPUSH
115139: CALL_OW 128
115143: GO 115165
// ComMoveToArea ( group [ i ] , f_heal ) ;
115145: LD_VAR 0 4
115149: PUSH
115150: LD_VAR 0 7
115154: ARRAY
115155: PPUSH
115156: LD_VAR 0 23
115160: PPUSH
115161: CALL_OW 113
// end ; continue ;
115165: GO 114196
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
115167: LD_VAR 0 4
115171: PUSH
115172: LD_VAR 0 7
115176: ARRAY
115177: PPUSH
115178: CALL_OW 256
115182: PUSH
115183: LD_INT 700
115185: LESS
115186: PUSH
115187: LD_VAR 0 4
115191: PUSH
115192: LD_VAR 0 7
115196: ARRAY
115197: PUSH
115198: LD_VAR 0 30
115202: IN
115203: NOT
115204: AND
115205: IFFALSE 115229
// to_heal := to_heal union group [ i ] ;
115207: LD_ADDR_VAR 0 30
115211: PUSH
115212: LD_VAR 0 30
115216: PUSH
115217: LD_VAR 0 4
115221: PUSH
115222: LD_VAR 0 7
115226: ARRAY
115227: UNION
115228: ST_TO_ADDR
// if group [ i ] in to_heal then
115229: LD_VAR 0 4
115233: PUSH
115234: LD_VAR 0 7
115238: ARRAY
115239: PUSH
115240: LD_VAR 0 30
115244: IN
115245: IFFALSE 115354
// begin if GetLives ( group [ i ] ) = 1000 then
115247: LD_VAR 0 4
115251: PUSH
115252: LD_VAR 0 7
115256: ARRAY
115257: PPUSH
115258: CALL_OW 256
115262: PUSH
115263: LD_INT 1000
115265: EQUAL
115266: IFFALSE 115292
// to_heal := to_heal diff group [ i ] else
115268: LD_ADDR_VAR 0 30
115272: PUSH
115273: LD_VAR 0 30
115277: PUSH
115278: LD_VAR 0 4
115282: PUSH
115283: LD_VAR 0 7
115287: ARRAY
115288: DIFF
115289: ST_TO_ADDR
115290: GO 115354
// begin if not IsInArea ( group [ i ] , to_heal ) then
115292: LD_VAR 0 4
115296: PUSH
115297: LD_VAR 0 7
115301: ARRAY
115302: PPUSH
115303: LD_VAR 0 30
115307: PPUSH
115308: CALL_OW 308
115312: NOT
115313: IFFALSE 115337
// ComMoveToArea ( group [ i ] , f_heal ) else
115315: LD_VAR 0 4
115319: PUSH
115320: LD_VAR 0 7
115324: ARRAY
115325: PPUSH
115326: LD_VAR 0 23
115330: PPUSH
115331: CALL_OW 113
115335: GO 115352
// ComHold ( group [ i ] ) ;
115337: LD_VAR 0 4
115341: PUSH
115342: LD_VAR 0 7
115346: ARRAY
115347: PPUSH
115348: CALL_OW 140
// continue ;
115352: GO 114196
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
115354: LD_VAR 0 4
115358: PUSH
115359: LD_VAR 0 7
115363: ARRAY
115364: PPUSH
115365: LD_INT 10
115367: PPUSH
115368: CALL 84668 0 2
115372: NOT
115373: PUSH
115374: LD_VAR 0 16
115378: PUSH
115379: LD_VAR 0 7
115383: ARRAY
115384: PUSH
115385: EMPTY
115386: EQUAL
115387: NOT
115388: AND
115389: IFFALSE 115655
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
115391: LD_VAR 0 4
115395: PUSH
115396: LD_VAR 0 7
115400: ARRAY
115401: PPUSH
115402: CALL_OW 262
115406: PUSH
115407: LD_INT 1
115409: PUSH
115410: LD_INT 2
115412: PUSH
115413: EMPTY
115414: LIST
115415: LIST
115416: IN
115417: IFFALSE 115458
// if GetFuel ( group [ i ] ) < 10 then
115419: LD_VAR 0 4
115423: PUSH
115424: LD_VAR 0 7
115428: ARRAY
115429: PPUSH
115430: CALL_OW 261
115434: PUSH
115435: LD_INT 10
115437: LESS
115438: IFFALSE 115458
// SetFuel ( group [ i ] , 12 ) ;
115440: LD_VAR 0 4
115444: PUSH
115445: LD_VAR 0 7
115449: ARRAY
115450: PPUSH
115451: LD_INT 12
115453: PPUSH
115454: CALL_OW 240
// if units_path [ i ] then
115458: LD_VAR 0 16
115462: PUSH
115463: LD_VAR 0 7
115467: ARRAY
115468: IFFALSE 115653
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
115470: LD_VAR 0 4
115474: PUSH
115475: LD_VAR 0 7
115479: ARRAY
115480: PPUSH
115481: LD_VAR 0 16
115485: PUSH
115486: LD_VAR 0 7
115490: ARRAY
115491: PUSH
115492: LD_INT 1
115494: ARRAY
115495: PUSH
115496: LD_INT 1
115498: ARRAY
115499: PPUSH
115500: LD_VAR 0 16
115504: PUSH
115505: LD_VAR 0 7
115509: ARRAY
115510: PUSH
115511: LD_INT 1
115513: ARRAY
115514: PUSH
115515: LD_INT 2
115517: ARRAY
115518: PPUSH
115519: CALL_OW 297
115523: PUSH
115524: LD_INT 6
115526: GREATER
115527: IFFALSE 115602
// begin if not HasTask ( group [ i ] ) then
115529: LD_VAR 0 4
115533: PUSH
115534: LD_VAR 0 7
115538: ARRAY
115539: PPUSH
115540: CALL_OW 314
115544: NOT
115545: IFFALSE 115600
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
115547: LD_VAR 0 4
115551: PUSH
115552: LD_VAR 0 7
115556: ARRAY
115557: PPUSH
115558: LD_VAR 0 16
115562: PUSH
115563: LD_VAR 0 7
115567: ARRAY
115568: PUSH
115569: LD_INT 1
115571: ARRAY
115572: PUSH
115573: LD_INT 1
115575: ARRAY
115576: PPUSH
115577: LD_VAR 0 16
115581: PUSH
115582: LD_VAR 0 7
115586: ARRAY
115587: PUSH
115588: LD_INT 1
115590: ARRAY
115591: PUSH
115592: LD_INT 2
115594: ARRAY
115595: PPUSH
115596: CALL_OW 114
// end else
115600: GO 115653
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
115602: LD_ADDR_VAR 0 15
115606: PUSH
115607: LD_VAR 0 16
115611: PUSH
115612: LD_VAR 0 7
115616: ARRAY
115617: PPUSH
115618: LD_INT 1
115620: PPUSH
115621: CALL_OW 3
115625: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115626: LD_ADDR_VAR 0 16
115630: PUSH
115631: LD_VAR 0 16
115635: PPUSH
115636: LD_VAR 0 7
115640: PPUSH
115641: LD_VAR 0 15
115645: PPUSH
115646: CALL_OW 1
115650: ST_TO_ADDR
// continue ;
115651: GO 114196
// end ; end ; end else
115653: GO 118317
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115655: LD_ADDR_VAR 0 14
115659: PUSH
115660: LD_INT 81
115662: PUSH
115663: LD_VAR 0 4
115667: PUSH
115668: LD_VAR 0 7
115672: ARRAY
115673: PPUSH
115674: CALL_OW 255
115678: PUSH
115679: EMPTY
115680: LIST
115681: LIST
115682: PPUSH
115683: CALL_OW 69
115687: ST_TO_ADDR
// if not tmp then
115688: LD_VAR 0 14
115692: NOT
115693: IFFALSE 115697
// continue ;
115695: GO 114196
// if f_ignore_area then
115697: LD_VAR 0 17
115701: IFFALSE 115789
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115703: LD_ADDR_VAR 0 15
115707: PUSH
115708: LD_VAR 0 14
115712: PPUSH
115713: LD_INT 3
115715: PUSH
115716: LD_INT 92
115718: PUSH
115719: LD_VAR 0 17
115723: PUSH
115724: LD_INT 1
115726: ARRAY
115727: PUSH
115728: LD_VAR 0 17
115732: PUSH
115733: LD_INT 2
115735: ARRAY
115736: PUSH
115737: LD_VAR 0 17
115741: PUSH
115742: LD_INT 3
115744: ARRAY
115745: PUSH
115746: EMPTY
115747: LIST
115748: LIST
115749: LIST
115750: LIST
115751: PUSH
115752: EMPTY
115753: LIST
115754: LIST
115755: PPUSH
115756: CALL_OW 72
115760: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115761: LD_VAR 0 14
115765: PUSH
115766: LD_VAR 0 15
115770: DIFF
115771: IFFALSE 115789
// tmp := tmp diff tmp2 ;
115773: LD_ADDR_VAR 0 14
115777: PUSH
115778: LD_VAR 0 14
115782: PUSH
115783: LD_VAR 0 15
115787: DIFF
115788: ST_TO_ADDR
// end ; if not f_murder then
115789: LD_VAR 0 20
115793: NOT
115794: IFFALSE 115852
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115796: LD_ADDR_VAR 0 15
115800: PUSH
115801: LD_VAR 0 14
115805: PPUSH
115806: LD_INT 3
115808: PUSH
115809: LD_INT 50
115811: PUSH
115812: EMPTY
115813: LIST
115814: PUSH
115815: EMPTY
115816: LIST
115817: LIST
115818: PPUSH
115819: CALL_OW 72
115823: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115824: LD_VAR 0 14
115828: PUSH
115829: LD_VAR 0 15
115833: DIFF
115834: IFFALSE 115852
// tmp := tmp diff tmp2 ;
115836: LD_ADDR_VAR 0 14
115840: PUSH
115841: LD_VAR 0 14
115845: PUSH
115846: LD_VAR 0 15
115850: DIFF
115851: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115852: LD_ADDR_VAR 0 14
115856: PUSH
115857: LD_VAR 0 4
115861: PUSH
115862: LD_VAR 0 7
115866: ARRAY
115867: PPUSH
115868: LD_VAR 0 14
115872: PPUSH
115873: LD_INT 1
115875: PPUSH
115876: LD_INT 1
115878: PPUSH
115879: CALL 57609 0 4
115883: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115884: LD_VAR 0 4
115888: PUSH
115889: LD_VAR 0 7
115893: ARRAY
115894: PPUSH
115895: CALL_OW 257
115899: PUSH
115900: LD_INT 1
115902: EQUAL
115903: IFFALSE 116351
// begin if WantPlant ( group [ i ] ) then
115905: LD_VAR 0 4
115909: PUSH
115910: LD_VAR 0 7
115914: ARRAY
115915: PPUSH
115916: CALL 57110 0 1
115920: IFFALSE 115924
// continue ;
115922: GO 114196
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115924: LD_VAR 0 18
115928: PUSH
115929: LD_VAR 0 4
115933: PUSH
115934: LD_VAR 0 7
115938: ARRAY
115939: PPUSH
115940: CALL_OW 310
115944: NOT
115945: AND
115946: PUSH
115947: LD_VAR 0 14
115951: PUSH
115952: LD_INT 1
115954: ARRAY
115955: PUSH
115956: LD_VAR 0 14
115960: PPUSH
115961: LD_INT 21
115963: PUSH
115964: LD_INT 2
115966: PUSH
115967: EMPTY
115968: LIST
115969: LIST
115970: PUSH
115971: LD_INT 58
115973: PUSH
115974: EMPTY
115975: LIST
115976: PUSH
115977: EMPTY
115978: LIST
115979: LIST
115980: PPUSH
115981: CALL_OW 72
115985: IN
115986: AND
115987: IFFALSE 116023
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115989: LD_VAR 0 4
115993: PUSH
115994: LD_VAR 0 7
115998: ARRAY
115999: PPUSH
116000: LD_VAR 0 14
116004: PUSH
116005: LD_INT 1
116007: ARRAY
116008: PPUSH
116009: CALL_OW 120
// attacking := true ;
116013: LD_ADDR_VAR 0 29
116017: PUSH
116018: LD_INT 1
116020: ST_TO_ADDR
// continue ;
116021: GO 114196
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
116023: LD_VAR 0 26
116027: PUSH
116028: LD_VAR 0 4
116032: PUSH
116033: LD_VAR 0 7
116037: ARRAY
116038: PPUSH
116039: CALL_OW 257
116043: PUSH
116044: LD_INT 1
116046: EQUAL
116047: AND
116048: PUSH
116049: LD_VAR 0 4
116053: PUSH
116054: LD_VAR 0 7
116058: ARRAY
116059: PPUSH
116060: CALL_OW 256
116064: PUSH
116065: LD_INT 800
116067: LESS
116068: AND
116069: PUSH
116070: LD_VAR 0 4
116074: PUSH
116075: LD_VAR 0 7
116079: ARRAY
116080: PPUSH
116081: CALL_OW 318
116085: NOT
116086: AND
116087: IFFALSE 116104
// ComCrawl ( group [ i ] ) ;
116089: LD_VAR 0 4
116093: PUSH
116094: LD_VAR 0 7
116098: ARRAY
116099: PPUSH
116100: CALL_OW 137
// if f_mines then
116104: LD_VAR 0 21
116108: IFFALSE 116351
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
116110: LD_VAR 0 14
116114: PUSH
116115: LD_INT 1
116117: ARRAY
116118: PPUSH
116119: CALL_OW 247
116123: PUSH
116124: LD_INT 3
116126: EQUAL
116127: PUSH
116128: LD_VAR 0 14
116132: PUSH
116133: LD_INT 1
116135: ARRAY
116136: PUSH
116137: LD_VAR 0 27
116141: IN
116142: NOT
116143: AND
116144: IFFALSE 116351
// begin x := GetX ( tmp [ 1 ] ) ;
116146: LD_ADDR_VAR 0 10
116150: PUSH
116151: LD_VAR 0 14
116155: PUSH
116156: LD_INT 1
116158: ARRAY
116159: PPUSH
116160: CALL_OW 250
116164: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
116165: LD_ADDR_VAR 0 11
116169: PUSH
116170: LD_VAR 0 14
116174: PUSH
116175: LD_INT 1
116177: ARRAY
116178: PPUSH
116179: CALL_OW 251
116183: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
116184: LD_ADDR_VAR 0 12
116188: PUSH
116189: LD_VAR 0 4
116193: PUSH
116194: LD_VAR 0 7
116198: ARRAY
116199: PPUSH
116200: CALL 84753 0 1
116204: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
116205: LD_VAR 0 4
116209: PUSH
116210: LD_VAR 0 7
116214: ARRAY
116215: PPUSH
116216: LD_VAR 0 10
116220: PPUSH
116221: LD_VAR 0 11
116225: PPUSH
116226: LD_VAR 0 14
116230: PUSH
116231: LD_INT 1
116233: ARRAY
116234: PPUSH
116235: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
116239: LD_VAR 0 4
116243: PUSH
116244: LD_VAR 0 7
116248: ARRAY
116249: PPUSH
116250: LD_VAR 0 10
116254: PPUSH
116255: LD_VAR 0 12
116259: PPUSH
116260: LD_INT 7
116262: PPUSH
116263: CALL_OW 272
116267: PPUSH
116268: LD_VAR 0 11
116272: PPUSH
116273: LD_VAR 0 12
116277: PPUSH
116278: LD_INT 7
116280: PPUSH
116281: CALL_OW 273
116285: PPUSH
116286: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
116290: LD_VAR 0 4
116294: PUSH
116295: LD_VAR 0 7
116299: ARRAY
116300: PPUSH
116301: LD_INT 71
116303: PPUSH
116304: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
116308: LD_ADDR_VAR 0 27
116312: PUSH
116313: LD_VAR 0 27
116317: PPUSH
116318: LD_VAR 0 27
116322: PUSH
116323: LD_INT 1
116325: PLUS
116326: PPUSH
116327: LD_VAR 0 14
116331: PUSH
116332: LD_INT 1
116334: ARRAY
116335: PPUSH
116336: CALL_OW 1
116340: ST_TO_ADDR
// attacking := true ;
116341: LD_ADDR_VAR 0 29
116345: PUSH
116346: LD_INT 1
116348: ST_TO_ADDR
// continue ;
116349: GO 114196
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
116351: LD_VAR 0 4
116355: PUSH
116356: LD_VAR 0 7
116360: ARRAY
116361: PPUSH
116362: CALL_OW 257
116366: PUSH
116367: LD_INT 17
116369: EQUAL
116370: PUSH
116371: LD_VAR 0 4
116375: PUSH
116376: LD_VAR 0 7
116380: ARRAY
116381: PPUSH
116382: CALL_OW 110
116386: PUSH
116387: LD_INT 71
116389: EQUAL
116390: NOT
116391: AND
116392: IFFALSE 116538
// begin attacking := false ;
116394: LD_ADDR_VAR 0 29
116398: PUSH
116399: LD_INT 0
116401: ST_TO_ADDR
// k := 5 ;
116402: LD_ADDR_VAR 0 9
116406: PUSH
116407: LD_INT 5
116409: ST_TO_ADDR
// if tmp < k then
116410: LD_VAR 0 14
116414: PUSH
116415: LD_VAR 0 9
116419: LESS
116420: IFFALSE 116432
// k := tmp ;
116422: LD_ADDR_VAR 0 9
116426: PUSH
116427: LD_VAR 0 14
116431: ST_TO_ADDR
// for j = 1 to k do
116432: LD_ADDR_VAR 0 8
116436: PUSH
116437: DOUBLE
116438: LD_INT 1
116440: DEC
116441: ST_TO_ADDR
116442: LD_VAR 0 9
116446: PUSH
116447: FOR_TO
116448: IFFALSE 116536
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
116450: LD_VAR 0 14
116454: PUSH
116455: LD_VAR 0 8
116459: ARRAY
116460: PUSH
116461: LD_VAR 0 14
116465: PPUSH
116466: LD_INT 58
116468: PUSH
116469: EMPTY
116470: LIST
116471: PPUSH
116472: CALL_OW 72
116476: IN
116477: NOT
116478: IFFALSE 116534
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116480: LD_VAR 0 4
116484: PUSH
116485: LD_VAR 0 7
116489: ARRAY
116490: PPUSH
116491: LD_VAR 0 14
116495: PUSH
116496: LD_VAR 0 8
116500: ARRAY
116501: PPUSH
116502: CALL_OW 115
// attacking := true ;
116506: LD_ADDR_VAR 0 29
116510: PUSH
116511: LD_INT 1
116513: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
116514: LD_VAR 0 4
116518: PUSH
116519: LD_VAR 0 7
116523: ARRAY
116524: PPUSH
116525: LD_INT 71
116527: PPUSH
116528: CALL_OW 109
// continue ;
116532: GO 116447
// end ; end ;
116534: GO 116447
116536: POP
116537: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
116538: LD_VAR 0 4
116542: PUSH
116543: LD_VAR 0 7
116547: ARRAY
116548: PPUSH
116549: CALL_OW 257
116553: PUSH
116554: LD_INT 8
116556: EQUAL
116557: PUSH
116558: LD_VAR 0 4
116562: PUSH
116563: LD_VAR 0 7
116567: ARRAY
116568: PPUSH
116569: CALL_OW 264
116573: PUSH
116574: LD_INT 28
116576: PUSH
116577: LD_INT 45
116579: PUSH
116580: LD_INT 7
116582: PUSH
116583: LD_INT 47
116585: PUSH
116586: EMPTY
116587: LIST
116588: LIST
116589: LIST
116590: LIST
116591: IN
116592: OR
116593: IFFALSE 116849
// begin attacking := false ;
116595: LD_ADDR_VAR 0 29
116599: PUSH
116600: LD_INT 0
116602: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
116603: LD_VAR 0 14
116607: PUSH
116608: LD_INT 1
116610: ARRAY
116611: PPUSH
116612: CALL_OW 266
116616: PUSH
116617: LD_INT 32
116619: PUSH
116620: LD_INT 31
116622: PUSH
116623: LD_INT 33
116625: PUSH
116626: LD_INT 4
116628: PUSH
116629: LD_INT 5
116631: PUSH
116632: EMPTY
116633: LIST
116634: LIST
116635: LIST
116636: LIST
116637: LIST
116638: IN
116639: IFFALSE 116825
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116641: LD_ADDR_VAR 0 9
116645: PUSH
116646: LD_VAR 0 14
116650: PUSH
116651: LD_INT 1
116653: ARRAY
116654: PPUSH
116655: CALL_OW 266
116659: PPUSH
116660: LD_VAR 0 14
116664: PUSH
116665: LD_INT 1
116667: ARRAY
116668: PPUSH
116669: CALL_OW 250
116673: PPUSH
116674: LD_VAR 0 14
116678: PUSH
116679: LD_INT 1
116681: ARRAY
116682: PPUSH
116683: CALL_OW 251
116687: PPUSH
116688: LD_VAR 0 14
116692: PUSH
116693: LD_INT 1
116695: ARRAY
116696: PPUSH
116697: CALL_OW 254
116701: PPUSH
116702: LD_VAR 0 14
116706: PUSH
116707: LD_INT 1
116709: ARRAY
116710: PPUSH
116711: CALL_OW 248
116715: PPUSH
116716: LD_INT 0
116718: PPUSH
116719: CALL 66123 0 6
116723: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116724: LD_ADDR_VAR 0 8
116728: PUSH
116729: LD_VAR 0 4
116733: PUSH
116734: LD_VAR 0 7
116738: ARRAY
116739: PPUSH
116740: LD_VAR 0 9
116744: PPUSH
116745: CALL 84866 0 2
116749: ST_TO_ADDR
// if j then
116750: LD_VAR 0 8
116754: IFFALSE 116823
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116756: LD_VAR 0 8
116760: PUSH
116761: LD_INT 1
116763: ARRAY
116764: PPUSH
116765: LD_VAR 0 8
116769: PUSH
116770: LD_INT 2
116772: ARRAY
116773: PPUSH
116774: CALL_OW 488
116778: IFFALSE 116823
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116780: LD_VAR 0 4
116784: PUSH
116785: LD_VAR 0 7
116789: ARRAY
116790: PPUSH
116791: LD_VAR 0 8
116795: PUSH
116796: LD_INT 1
116798: ARRAY
116799: PPUSH
116800: LD_VAR 0 8
116804: PUSH
116805: LD_INT 2
116807: ARRAY
116808: PPUSH
116809: CALL_OW 116
// attacking := true ;
116813: LD_ADDR_VAR 0 29
116817: PUSH
116818: LD_INT 1
116820: ST_TO_ADDR
// continue ;
116821: GO 114196
// end ; end else
116823: GO 116849
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116825: LD_VAR 0 4
116829: PUSH
116830: LD_VAR 0 7
116834: ARRAY
116835: PPUSH
116836: LD_VAR 0 14
116840: PUSH
116841: LD_INT 1
116843: ARRAY
116844: PPUSH
116845: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116849: LD_VAR 0 4
116853: PUSH
116854: LD_VAR 0 7
116858: ARRAY
116859: PPUSH
116860: CALL_OW 265
116864: PUSH
116865: LD_INT 11
116867: EQUAL
116868: IFFALSE 117146
// begin k := 10 ;
116870: LD_ADDR_VAR 0 9
116874: PUSH
116875: LD_INT 10
116877: ST_TO_ADDR
// x := 0 ;
116878: LD_ADDR_VAR 0 10
116882: PUSH
116883: LD_INT 0
116885: ST_TO_ADDR
// if tmp < k then
116886: LD_VAR 0 14
116890: PUSH
116891: LD_VAR 0 9
116895: LESS
116896: IFFALSE 116908
// k := tmp ;
116898: LD_ADDR_VAR 0 9
116902: PUSH
116903: LD_VAR 0 14
116907: ST_TO_ADDR
// for j = k downto 1 do
116908: LD_ADDR_VAR 0 8
116912: PUSH
116913: DOUBLE
116914: LD_VAR 0 9
116918: INC
116919: ST_TO_ADDR
116920: LD_INT 1
116922: PUSH
116923: FOR_DOWNTO
116924: IFFALSE 116999
// begin if GetType ( tmp [ j ] ) = unit_human then
116926: LD_VAR 0 14
116930: PUSH
116931: LD_VAR 0 8
116935: ARRAY
116936: PPUSH
116937: CALL_OW 247
116941: PUSH
116942: LD_INT 1
116944: EQUAL
116945: IFFALSE 116997
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116947: LD_VAR 0 4
116951: PUSH
116952: LD_VAR 0 7
116956: ARRAY
116957: PPUSH
116958: LD_VAR 0 14
116962: PUSH
116963: LD_VAR 0 8
116967: ARRAY
116968: PPUSH
116969: CALL 85120 0 2
// x := tmp [ j ] ;
116973: LD_ADDR_VAR 0 10
116977: PUSH
116978: LD_VAR 0 14
116982: PUSH
116983: LD_VAR 0 8
116987: ARRAY
116988: ST_TO_ADDR
// attacking := true ;
116989: LD_ADDR_VAR 0 29
116993: PUSH
116994: LD_INT 1
116996: ST_TO_ADDR
// end ; end ;
116997: GO 116923
116999: POP
117000: POP
// if not x then
117001: LD_VAR 0 10
117005: NOT
117006: IFFALSE 117146
// begin attacking := true ;
117008: LD_ADDR_VAR 0 29
117012: PUSH
117013: LD_INT 1
117015: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
117016: LD_VAR 0 4
117020: PUSH
117021: LD_VAR 0 7
117025: ARRAY
117026: PPUSH
117027: CALL_OW 250
117031: PPUSH
117032: LD_VAR 0 4
117036: PUSH
117037: LD_VAR 0 7
117041: ARRAY
117042: PPUSH
117043: CALL_OW 251
117047: PPUSH
117048: CALL_OW 546
117052: PUSH
117053: LD_INT 2
117055: ARRAY
117056: PUSH
117057: LD_VAR 0 14
117061: PUSH
117062: LD_INT 1
117064: ARRAY
117065: PPUSH
117066: CALL_OW 250
117070: PPUSH
117071: LD_VAR 0 14
117075: PUSH
117076: LD_INT 1
117078: ARRAY
117079: PPUSH
117080: CALL_OW 251
117084: PPUSH
117085: CALL_OW 546
117089: PUSH
117090: LD_INT 2
117092: ARRAY
117093: EQUAL
117094: IFFALSE 117122
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
117096: LD_VAR 0 4
117100: PUSH
117101: LD_VAR 0 7
117105: ARRAY
117106: PPUSH
117107: LD_VAR 0 14
117111: PUSH
117112: LD_INT 1
117114: ARRAY
117115: PPUSH
117116: CALL 85120 0 2
117120: GO 117146
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117122: LD_VAR 0 4
117126: PUSH
117127: LD_VAR 0 7
117131: ARRAY
117132: PPUSH
117133: LD_VAR 0 14
117137: PUSH
117138: LD_INT 1
117140: ARRAY
117141: PPUSH
117142: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
117146: LD_VAR 0 4
117150: PUSH
117151: LD_VAR 0 7
117155: ARRAY
117156: PPUSH
117157: CALL_OW 264
117161: PUSH
117162: LD_INT 29
117164: EQUAL
117165: IFFALSE 117531
// begin if WantsToAttack ( group [ i ] ) in bombed then
117167: LD_VAR 0 4
117171: PUSH
117172: LD_VAR 0 7
117176: ARRAY
117177: PPUSH
117178: CALL_OW 319
117182: PUSH
117183: LD_VAR 0 28
117187: IN
117188: IFFALSE 117192
// continue ;
117190: GO 114196
// k := 8 ;
117192: LD_ADDR_VAR 0 9
117196: PUSH
117197: LD_INT 8
117199: ST_TO_ADDR
// x := 0 ;
117200: LD_ADDR_VAR 0 10
117204: PUSH
117205: LD_INT 0
117207: ST_TO_ADDR
// if tmp < k then
117208: LD_VAR 0 14
117212: PUSH
117213: LD_VAR 0 9
117217: LESS
117218: IFFALSE 117230
// k := tmp ;
117220: LD_ADDR_VAR 0 9
117224: PUSH
117225: LD_VAR 0 14
117229: ST_TO_ADDR
// for j = 1 to k do
117230: LD_ADDR_VAR 0 8
117234: PUSH
117235: DOUBLE
117236: LD_INT 1
117238: DEC
117239: ST_TO_ADDR
117240: LD_VAR 0 9
117244: PUSH
117245: FOR_TO
117246: IFFALSE 117378
// begin if GetType ( tmp [ j ] ) = unit_building then
117248: LD_VAR 0 14
117252: PUSH
117253: LD_VAR 0 8
117257: ARRAY
117258: PPUSH
117259: CALL_OW 247
117263: PUSH
117264: LD_INT 3
117266: EQUAL
117267: IFFALSE 117376
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
117269: LD_VAR 0 14
117273: PUSH
117274: LD_VAR 0 8
117278: ARRAY
117279: PUSH
117280: LD_VAR 0 28
117284: IN
117285: NOT
117286: PUSH
117287: LD_VAR 0 14
117291: PUSH
117292: LD_VAR 0 8
117296: ARRAY
117297: PPUSH
117298: CALL_OW 313
117302: AND
117303: IFFALSE 117376
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117305: LD_VAR 0 4
117309: PUSH
117310: LD_VAR 0 7
117314: ARRAY
117315: PPUSH
117316: LD_VAR 0 14
117320: PUSH
117321: LD_VAR 0 8
117325: ARRAY
117326: PPUSH
117327: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
117331: LD_ADDR_VAR 0 28
117335: PUSH
117336: LD_VAR 0 28
117340: PPUSH
117341: LD_VAR 0 28
117345: PUSH
117346: LD_INT 1
117348: PLUS
117349: PPUSH
117350: LD_VAR 0 14
117354: PUSH
117355: LD_VAR 0 8
117359: ARRAY
117360: PPUSH
117361: CALL_OW 1
117365: ST_TO_ADDR
// attacking := true ;
117366: LD_ADDR_VAR 0 29
117370: PUSH
117371: LD_INT 1
117373: ST_TO_ADDR
// break ;
117374: GO 117378
// end ; end ;
117376: GO 117245
117378: POP
117379: POP
// if not attacking and f_attack_depot then
117380: LD_VAR 0 29
117384: NOT
117385: PUSH
117386: LD_VAR 0 25
117390: AND
117391: IFFALSE 117486
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117393: LD_ADDR_VAR 0 13
117397: PUSH
117398: LD_VAR 0 14
117402: PPUSH
117403: LD_INT 2
117405: PUSH
117406: LD_INT 30
117408: PUSH
117409: LD_INT 0
117411: PUSH
117412: EMPTY
117413: LIST
117414: LIST
117415: PUSH
117416: LD_INT 30
117418: PUSH
117419: LD_INT 1
117421: PUSH
117422: EMPTY
117423: LIST
117424: LIST
117425: PUSH
117426: EMPTY
117427: LIST
117428: LIST
117429: LIST
117430: PPUSH
117431: CALL_OW 72
117435: ST_TO_ADDR
// if z then
117436: LD_VAR 0 13
117440: IFFALSE 117486
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
117442: LD_VAR 0 4
117446: PUSH
117447: LD_VAR 0 7
117451: ARRAY
117452: PPUSH
117453: LD_VAR 0 13
117457: PPUSH
117458: LD_VAR 0 4
117462: PUSH
117463: LD_VAR 0 7
117467: ARRAY
117468: PPUSH
117469: CALL_OW 74
117473: PPUSH
117474: CALL_OW 115
// attacking := true ;
117478: LD_ADDR_VAR 0 29
117482: PUSH
117483: LD_INT 1
117485: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
117486: LD_VAR 0 4
117490: PUSH
117491: LD_VAR 0 7
117495: ARRAY
117496: PPUSH
117497: CALL_OW 256
117501: PUSH
117502: LD_INT 500
117504: LESS
117505: IFFALSE 117531
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117507: LD_VAR 0 4
117511: PUSH
117512: LD_VAR 0 7
117516: ARRAY
117517: PPUSH
117518: LD_VAR 0 14
117522: PUSH
117523: LD_INT 1
117525: ARRAY
117526: PPUSH
117527: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
117531: LD_VAR 0 4
117535: PUSH
117536: LD_VAR 0 7
117540: ARRAY
117541: PPUSH
117542: CALL_OW 264
117546: PUSH
117547: LD_INT 49
117549: EQUAL
117550: IFFALSE 117671
// begin if not HasTask ( group [ i ] ) then
117552: LD_VAR 0 4
117556: PUSH
117557: LD_VAR 0 7
117561: ARRAY
117562: PPUSH
117563: CALL_OW 314
117567: NOT
117568: IFFALSE 117671
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
117570: LD_ADDR_VAR 0 9
117574: PUSH
117575: LD_INT 81
117577: PUSH
117578: LD_VAR 0 4
117582: PUSH
117583: LD_VAR 0 7
117587: ARRAY
117588: PPUSH
117589: CALL_OW 255
117593: PUSH
117594: EMPTY
117595: LIST
117596: LIST
117597: PPUSH
117598: CALL_OW 69
117602: PPUSH
117603: LD_VAR 0 4
117607: PUSH
117608: LD_VAR 0 7
117612: ARRAY
117613: PPUSH
117614: CALL_OW 74
117618: ST_TO_ADDR
// if k then
117619: LD_VAR 0 9
117623: IFFALSE 117671
// if GetDistUnits ( group [ i ] , k ) > 10 then
117625: LD_VAR 0 4
117629: PUSH
117630: LD_VAR 0 7
117634: ARRAY
117635: PPUSH
117636: LD_VAR 0 9
117640: PPUSH
117641: CALL_OW 296
117645: PUSH
117646: LD_INT 10
117648: GREATER
117649: IFFALSE 117671
// ComMoveUnit ( group [ i ] , k ) ;
117651: LD_VAR 0 4
117655: PUSH
117656: LD_VAR 0 7
117660: ARRAY
117661: PPUSH
117662: LD_VAR 0 9
117666: PPUSH
117667: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117671: LD_VAR 0 4
117675: PUSH
117676: LD_VAR 0 7
117680: ARRAY
117681: PPUSH
117682: CALL_OW 256
117686: PUSH
117687: LD_INT 250
117689: LESS
117690: PUSH
117691: LD_VAR 0 4
117695: PUSH
117696: LD_VAR 0 7
117700: ARRAY
117701: PUSH
117702: LD_INT 21
117704: PUSH
117705: LD_INT 2
117707: PUSH
117708: EMPTY
117709: LIST
117710: LIST
117711: PUSH
117712: LD_INT 23
117714: PUSH
117715: LD_INT 2
117717: PUSH
117718: EMPTY
117719: LIST
117720: LIST
117721: PUSH
117722: EMPTY
117723: LIST
117724: LIST
117725: PPUSH
117726: CALL_OW 69
117730: IN
117731: AND
117732: IFFALSE 117857
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117734: LD_ADDR_VAR 0 9
117738: PUSH
117739: LD_OWVAR 3
117743: PUSH
117744: LD_VAR 0 4
117748: PUSH
117749: LD_VAR 0 7
117753: ARRAY
117754: DIFF
117755: PPUSH
117756: LD_VAR 0 4
117760: PUSH
117761: LD_VAR 0 7
117765: ARRAY
117766: PPUSH
117767: CALL_OW 74
117771: ST_TO_ADDR
// if not k then
117772: LD_VAR 0 9
117776: NOT
117777: IFFALSE 117781
// continue ;
117779: GO 114196
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117781: LD_VAR 0 9
117785: PUSH
117786: LD_INT 81
117788: PUSH
117789: LD_VAR 0 4
117793: PUSH
117794: LD_VAR 0 7
117798: ARRAY
117799: PPUSH
117800: CALL_OW 255
117804: PUSH
117805: EMPTY
117806: LIST
117807: LIST
117808: PPUSH
117809: CALL_OW 69
117813: IN
117814: PUSH
117815: LD_VAR 0 9
117819: PPUSH
117820: LD_VAR 0 4
117824: PUSH
117825: LD_VAR 0 7
117829: ARRAY
117830: PPUSH
117831: CALL_OW 296
117835: PUSH
117836: LD_INT 5
117838: LESS
117839: AND
117840: IFFALSE 117857
// ComAutodestruct ( group [ i ] ) ;
117842: LD_VAR 0 4
117846: PUSH
117847: LD_VAR 0 7
117851: ARRAY
117852: PPUSH
117853: CALL 85018 0 1
// end ; if f_attack_depot then
117857: LD_VAR 0 25
117861: IFFALSE 117973
// begin k := 6 ;
117863: LD_ADDR_VAR 0 9
117867: PUSH
117868: LD_INT 6
117870: ST_TO_ADDR
// if tmp < k then
117871: LD_VAR 0 14
117875: PUSH
117876: LD_VAR 0 9
117880: LESS
117881: IFFALSE 117893
// k := tmp ;
117883: LD_ADDR_VAR 0 9
117887: PUSH
117888: LD_VAR 0 14
117892: ST_TO_ADDR
// for j = 1 to k do
117893: LD_ADDR_VAR 0 8
117897: PUSH
117898: DOUBLE
117899: LD_INT 1
117901: DEC
117902: ST_TO_ADDR
117903: LD_VAR 0 9
117907: PUSH
117908: FOR_TO
117909: IFFALSE 117971
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117911: LD_VAR 0 8
117915: PPUSH
117916: CALL_OW 266
117920: PUSH
117921: LD_INT 0
117923: PUSH
117924: LD_INT 1
117926: PUSH
117927: EMPTY
117928: LIST
117929: LIST
117930: IN
117931: IFFALSE 117969
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117933: LD_VAR 0 4
117937: PUSH
117938: LD_VAR 0 7
117942: ARRAY
117943: PPUSH
117944: LD_VAR 0 14
117948: PUSH
117949: LD_VAR 0 8
117953: ARRAY
117954: PPUSH
117955: CALL_OW 115
// attacking := true ;
117959: LD_ADDR_VAR 0 29
117963: PUSH
117964: LD_INT 1
117966: ST_TO_ADDR
// break ;
117967: GO 117971
// end ;
117969: GO 117908
117971: POP
117972: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117973: LD_VAR 0 4
117977: PUSH
117978: LD_VAR 0 7
117982: ARRAY
117983: PPUSH
117984: CALL_OW 302
117988: PUSH
117989: LD_VAR 0 29
117993: NOT
117994: AND
117995: IFFALSE 118317
// begin if GetTag ( group [ i ] ) = 71 then
117997: LD_VAR 0 4
118001: PUSH
118002: LD_VAR 0 7
118006: ARRAY
118007: PPUSH
118008: CALL_OW 110
118012: PUSH
118013: LD_INT 71
118015: EQUAL
118016: IFFALSE 118057
// begin if HasTask ( group [ i ] ) then
118018: LD_VAR 0 4
118022: PUSH
118023: LD_VAR 0 7
118027: ARRAY
118028: PPUSH
118029: CALL_OW 314
118033: IFFALSE 118039
// continue else
118035: GO 114196
118037: GO 118057
// SetTag ( group [ i ] , 0 ) ;
118039: LD_VAR 0 4
118043: PUSH
118044: LD_VAR 0 7
118048: ARRAY
118049: PPUSH
118050: LD_INT 0
118052: PPUSH
118053: CALL_OW 109
// end ; k := 8 ;
118057: LD_ADDR_VAR 0 9
118061: PUSH
118062: LD_INT 8
118064: ST_TO_ADDR
// x := 0 ;
118065: LD_ADDR_VAR 0 10
118069: PUSH
118070: LD_INT 0
118072: ST_TO_ADDR
// if tmp < k then
118073: LD_VAR 0 14
118077: PUSH
118078: LD_VAR 0 9
118082: LESS
118083: IFFALSE 118095
// k := tmp ;
118085: LD_ADDR_VAR 0 9
118089: PUSH
118090: LD_VAR 0 14
118094: ST_TO_ADDR
// for j = 1 to k do
118095: LD_ADDR_VAR 0 8
118099: PUSH
118100: DOUBLE
118101: LD_INT 1
118103: DEC
118104: ST_TO_ADDR
118105: LD_VAR 0 9
118109: PUSH
118110: FOR_TO
118111: IFFALSE 118209
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
118113: LD_VAR 0 14
118117: PUSH
118118: LD_VAR 0 8
118122: ARRAY
118123: PPUSH
118124: CALL_OW 247
118128: PUSH
118129: LD_INT 1
118131: EQUAL
118132: PUSH
118133: LD_VAR 0 14
118137: PUSH
118138: LD_VAR 0 8
118142: ARRAY
118143: PPUSH
118144: CALL_OW 256
118148: PUSH
118149: LD_INT 250
118151: LESS
118152: PUSH
118153: LD_VAR 0 20
118157: AND
118158: PUSH
118159: LD_VAR 0 20
118163: NOT
118164: PUSH
118165: LD_VAR 0 14
118169: PUSH
118170: LD_VAR 0 8
118174: ARRAY
118175: PPUSH
118176: CALL_OW 256
118180: PUSH
118181: LD_INT 250
118183: GREATEREQUAL
118184: AND
118185: OR
118186: AND
118187: IFFALSE 118207
// begin x := tmp [ j ] ;
118189: LD_ADDR_VAR 0 10
118193: PUSH
118194: LD_VAR 0 14
118198: PUSH
118199: LD_VAR 0 8
118203: ARRAY
118204: ST_TO_ADDR
// break ;
118205: GO 118209
// end ;
118207: GO 118110
118209: POP
118210: POP
// if x then
118211: LD_VAR 0 10
118215: IFFALSE 118239
// ComAttackUnit ( group [ i ] , x ) else
118217: LD_VAR 0 4
118221: PUSH
118222: LD_VAR 0 7
118226: ARRAY
118227: PPUSH
118228: LD_VAR 0 10
118232: PPUSH
118233: CALL_OW 115
118237: GO 118263
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118239: LD_VAR 0 4
118243: PUSH
118244: LD_VAR 0 7
118248: ARRAY
118249: PPUSH
118250: LD_VAR 0 14
118254: PUSH
118255: LD_INT 1
118257: ARRAY
118258: PPUSH
118259: CALL_OW 115
// if not HasTask ( group [ i ] ) then
118263: LD_VAR 0 4
118267: PUSH
118268: LD_VAR 0 7
118272: ARRAY
118273: PPUSH
118274: CALL_OW 314
118278: NOT
118279: IFFALSE 118317
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
118281: LD_VAR 0 4
118285: PUSH
118286: LD_VAR 0 7
118290: ARRAY
118291: PPUSH
118292: LD_VAR 0 14
118296: PPUSH
118297: LD_VAR 0 4
118301: PUSH
118302: LD_VAR 0 7
118306: ARRAY
118307: PPUSH
118308: CALL_OW 74
118312: PPUSH
118313: CALL_OW 115
// end ; end ; end ;
118317: GO 114196
118319: POP
118320: POP
// wait ( 0 0$2 ) ;
118321: LD_INT 70
118323: PPUSH
118324: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
118328: LD_VAR 0 4
118332: NOT
118333: PUSH
118334: LD_VAR 0 4
118338: PUSH
118339: EMPTY
118340: EQUAL
118341: OR
118342: PUSH
118343: LD_INT 81
118345: PUSH
118346: LD_VAR 0 35
118350: PUSH
118351: EMPTY
118352: LIST
118353: LIST
118354: PPUSH
118355: CALL_OW 69
118359: NOT
118360: OR
118361: IFFALSE 114181
// end ;
118363: LD_VAR 0 2
118367: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
118368: LD_INT 0
118370: PPUSH
118371: PPUSH
118372: PPUSH
118373: PPUSH
118374: PPUSH
118375: PPUSH
// if not base or not mc_bases [ base ] or not solds then
118376: LD_VAR 0 1
118380: NOT
118381: PUSH
118382: LD_EXP 78
118386: PUSH
118387: LD_VAR 0 1
118391: ARRAY
118392: NOT
118393: OR
118394: PUSH
118395: LD_VAR 0 2
118399: NOT
118400: OR
118401: IFFALSE 118405
// exit ;
118403: GO 118959
// side := mc_sides [ base ] ;
118405: LD_ADDR_VAR 0 6
118409: PUSH
118410: LD_EXP 104
118414: PUSH
118415: LD_VAR 0 1
118419: ARRAY
118420: ST_TO_ADDR
// if not side then
118421: LD_VAR 0 6
118425: NOT
118426: IFFALSE 118430
// exit ;
118428: GO 118959
// for i in solds do
118430: LD_ADDR_VAR 0 7
118434: PUSH
118435: LD_VAR 0 2
118439: PUSH
118440: FOR_IN
118441: IFFALSE 118502
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
118443: LD_VAR 0 7
118447: PPUSH
118448: CALL_OW 310
118452: PPUSH
118453: CALL_OW 266
118457: PUSH
118458: LD_INT 32
118460: PUSH
118461: LD_INT 31
118463: PUSH
118464: EMPTY
118465: LIST
118466: LIST
118467: IN
118468: IFFALSE 118488
// solds := solds diff i else
118470: LD_ADDR_VAR 0 2
118474: PUSH
118475: LD_VAR 0 2
118479: PUSH
118480: LD_VAR 0 7
118484: DIFF
118485: ST_TO_ADDR
118486: GO 118500
// SetTag ( i , 18 ) ;
118488: LD_VAR 0 7
118492: PPUSH
118493: LD_INT 18
118495: PPUSH
118496: CALL_OW 109
118500: GO 118440
118502: POP
118503: POP
// if not solds then
118504: LD_VAR 0 2
118508: NOT
118509: IFFALSE 118513
// exit ;
118511: GO 118959
// repeat wait ( 0 0$2 ) ;
118513: LD_INT 70
118515: PPUSH
118516: CALL_OW 67
// enemy := mc_scan [ base ] ;
118520: LD_ADDR_VAR 0 4
118524: PUSH
118525: LD_EXP 101
118529: PUSH
118530: LD_VAR 0 1
118534: ARRAY
118535: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118536: LD_EXP 78
118540: PUSH
118541: LD_VAR 0 1
118545: ARRAY
118546: NOT
118547: PUSH
118548: LD_EXP 78
118552: PUSH
118553: LD_VAR 0 1
118557: ARRAY
118558: PUSH
118559: EMPTY
118560: EQUAL
118561: OR
118562: IFFALSE 118599
// begin for i in solds do
118564: LD_ADDR_VAR 0 7
118568: PUSH
118569: LD_VAR 0 2
118573: PUSH
118574: FOR_IN
118575: IFFALSE 118588
// ComStop ( i ) ;
118577: LD_VAR 0 7
118581: PPUSH
118582: CALL_OW 141
118586: GO 118574
118588: POP
118589: POP
// solds := [ ] ;
118590: LD_ADDR_VAR 0 2
118594: PUSH
118595: EMPTY
118596: ST_TO_ADDR
// exit ;
118597: GO 118959
// end ; for i in solds do
118599: LD_ADDR_VAR 0 7
118603: PUSH
118604: LD_VAR 0 2
118608: PUSH
118609: FOR_IN
118610: IFFALSE 118931
// begin if IsInUnit ( i ) then
118612: LD_VAR 0 7
118616: PPUSH
118617: CALL_OW 310
118621: IFFALSE 118632
// ComExitBuilding ( i ) ;
118623: LD_VAR 0 7
118627: PPUSH
118628: CALL_OW 122
// if GetLives ( i ) > 500 then
118632: LD_VAR 0 7
118636: PPUSH
118637: CALL_OW 256
118641: PUSH
118642: LD_INT 500
118644: GREATER
118645: IFFALSE 118698
// begin e := NearestUnitToUnit ( enemy , i ) ;
118647: LD_ADDR_VAR 0 5
118651: PUSH
118652: LD_VAR 0 4
118656: PPUSH
118657: LD_VAR 0 7
118661: PPUSH
118662: CALL_OW 74
118666: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
118667: LD_VAR 0 7
118671: PPUSH
118672: LD_VAR 0 5
118676: PPUSH
118677: CALL_OW 250
118681: PPUSH
118682: LD_VAR 0 5
118686: PPUSH
118687: CALL_OW 251
118691: PPUSH
118692: CALL_OW 114
// end else
118696: GO 118929
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
118698: LD_VAR 0 7
118702: PPUSH
118703: LD_EXP 78
118707: PUSH
118708: LD_VAR 0 1
118712: ARRAY
118713: PPUSH
118714: LD_INT 2
118716: PUSH
118717: LD_INT 30
118719: PUSH
118720: LD_INT 0
118722: PUSH
118723: EMPTY
118724: LIST
118725: LIST
118726: PUSH
118727: LD_INT 30
118729: PUSH
118730: LD_INT 1
118732: PUSH
118733: EMPTY
118734: LIST
118735: LIST
118736: PUSH
118737: LD_INT 30
118739: PUSH
118740: LD_INT 6
118742: PUSH
118743: EMPTY
118744: LIST
118745: LIST
118746: PUSH
118747: EMPTY
118748: LIST
118749: LIST
118750: LIST
118751: LIST
118752: PPUSH
118753: CALL_OW 72
118757: PPUSH
118758: LD_VAR 0 7
118762: PPUSH
118763: CALL_OW 74
118767: PPUSH
118768: CALL_OW 296
118772: PUSH
118773: LD_INT 10
118775: GREATER
118776: IFFALSE 118929
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118778: LD_ADDR_VAR 0 8
118782: PUSH
118783: LD_EXP 78
118787: PUSH
118788: LD_VAR 0 1
118792: ARRAY
118793: PPUSH
118794: LD_INT 2
118796: PUSH
118797: LD_INT 30
118799: PUSH
118800: LD_INT 0
118802: PUSH
118803: EMPTY
118804: LIST
118805: LIST
118806: PUSH
118807: LD_INT 30
118809: PUSH
118810: LD_INT 1
118812: PUSH
118813: EMPTY
118814: LIST
118815: LIST
118816: PUSH
118817: LD_INT 30
118819: PUSH
118820: LD_INT 6
118822: PUSH
118823: EMPTY
118824: LIST
118825: LIST
118826: PUSH
118827: EMPTY
118828: LIST
118829: LIST
118830: LIST
118831: LIST
118832: PPUSH
118833: CALL_OW 72
118837: PPUSH
118838: LD_VAR 0 7
118842: PPUSH
118843: CALL_OW 74
118847: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118848: LD_VAR 0 7
118852: PPUSH
118853: LD_VAR 0 8
118857: PPUSH
118858: CALL_OW 250
118862: PPUSH
118863: LD_INT 3
118865: PPUSH
118866: LD_INT 5
118868: PPUSH
118869: CALL_OW 272
118873: PPUSH
118874: LD_VAR 0 8
118878: PPUSH
118879: CALL_OW 251
118883: PPUSH
118884: LD_INT 3
118886: PPUSH
118887: LD_INT 5
118889: PPUSH
118890: CALL_OW 273
118894: PPUSH
118895: CALL_OW 111
// SetTag ( i , 0 ) ;
118899: LD_VAR 0 7
118903: PPUSH
118904: LD_INT 0
118906: PPUSH
118907: CALL_OW 109
// solds := solds diff i ;
118911: LD_ADDR_VAR 0 2
118915: PUSH
118916: LD_VAR 0 2
118920: PUSH
118921: LD_VAR 0 7
118925: DIFF
118926: ST_TO_ADDR
// continue ;
118927: GO 118609
// end ; end ;
118929: GO 118609
118931: POP
118932: POP
// until not solds or not enemy ;
118933: LD_VAR 0 2
118937: NOT
118938: PUSH
118939: LD_VAR 0 4
118943: NOT
118944: OR
118945: IFFALSE 118513
// MC_Reset ( base , 18 ) ;
118947: LD_VAR 0 1
118951: PPUSH
118952: LD_INT 18
118954: PPUSH
118955: CALL 25687 0 2
// end ;
118959: LD_VAR 0 3
118963: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
118964: LD_INT 0
118966: PPUSH
118967: PPUSH
118968: PPUSH
118969: PPUSH
118970: PPUSH
118971: PPUSH
118972: PPUSH
118973: PPUSH
118974: PPUSH
118975: PPUSH
118976: PPUSH
118977: PPUSH
118978: PPUSH
118979: PPUSH
118980: PPUSH
118981: PPUSH
118982: PPUSH
118983: PPUSH
118984: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118985: LD_ADDR_VAR 0 12
118989: PUSH
118990: LD_EXP 78
118994: PUSH
118995: LD_VAR 0 1
118999: ARRAY
119000: PPUSH
119001: LD_INT 25
119003: PUSH
119004: LD_INT 3
119006: PUSH
119007: EMPTY
119008: LIST
119009: LIST
119010: PPUSH
119011: CALL_OW 72
119015: ST_TO_ADDR
// if mc_remote_driver [ base ] then
119016: LD_EXP 118
119020: PUSH
119021: LD_VAR 0 1
119025: ARRAY
119026: IFFALSE 119050
// mechs := mechs diff mc_remote_driver [ base ] ;
119028: LD_ADDR_VAR 0 12
119032: PUSH
119033: LD_VAR 0 12
119037: PUSH
119038: LD_EXP 118
119042: PUSH
119043: LD_VAR 0 1
119047: ARRAY
119048: DIFF
119049: ST_TO_ADDR
// for i in mechs do
119050: LD_ADDR_VAR 0 4
119054: PUSH
119055: LD_VAR 0 12
119059: PUSH
119060: FOR_IN
119061: IFFALSE 119096
// if GetTag ( i ) > 0 then
119063: LD_VAR 0 4
119067: PPUSH
119068: CALL_OW 110
119072: PUSH
119073: LD_INT 0
119075: GREATER
119076: IFFALSE 119094
// mechs := mechs diff i ;
119078: LD_ADDR_VAR 0 12
119082: PUSH
119083: LD_VAR 0 12
119087: PUSH
119088: LD_VAR 0 4
119092: DIFF
119093: ST_TO_ADDR
119094: GO 119060
119096: POP
119097: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119098: LD_ADDR_VAR 0 8
119102: PUSH
119103: LD_EXP 78
119107: PUSH
119108: LD_VAR 0 1
119112: ARRAY
119113: PPUSH
119114: LD_INT 2
119116: PUSH
119117: LD_INT 25
119119: PUSH
119120: LD_INT 1
119122: PUSH
119123: EMPTY
119124: LIST
119125: LIST
119126: PUSH
119127: LD_INT 25
119129: PUSH
119130: LD_INT 5
119132: PUSH
119133: EMPTY
119134: LIST
119135: LIST
119136: PUSH
119137: LD_INT 25
119139: PUSH
119140: LD_INT 8
119142: PUSH
119143: EMPTY
119144: LIST
119145: LIST
119146: PUSH
119147: LD_INT 25
119149: PUSH
119150: LD_INT 9
119152: PUSH
119153: EMPTY
119154: LIST
119155: LIST
119156: PUSH
119157: EMPTY
119158: LIST
119159: LIST
119160: LIST
119161: LIST
119162: LIST
119163: PPUSH
119164: CALL_OW 72
119168: ST_TO_ADDR
// if not defenders and not solds then
119169: LD_VAR 0 2
119173: NOT
119174: PUSH
119175: LD_VAR 0 8
119179: NOT
119180: AND
119181: IFFALSE 119185
// exit ;
119183: GO 120955
// depot_under_attack := false ;
119185: LD_ADDR_VAR 0 16
119189: PUSH
119190: LD_INT 0
119192: ST_TO_ADDR
// sold_defenders := [ ] ;
119193: LD_ADDR_VAR 0 17
119197: PUSH
119198: EMPTY
119199: ST_TO_ADDR
// if mechs then
119200: LD_VAR 0 12
119204: IFFALSE 119357
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
119206: LD_ADDR_VAR 0 4
119210: PUSH
119211: LD_VAR 0 2
119215: PPUSH
119216: LD_INT 21
119218: PUSH
119219: LD_INT 2
119221: PUSH
119222: EMPTY
119223: LIST
119224: LIST
119225: PPUSH
119226: CALL_OW 72
119230: PUSH
119231: FOR_IN
119232: IFFALSE 119355
// begin if GetTag ( i ) <> 20 then
119234: LD_VAR 0 4
119238: PPUSH
119239: CALL_OW 110
119243: PUSH
119244: LD_INT 20
119246: NONEQUAL
119247: IFFALSE 119261
// SetTag ( i , 20 ) ;
119249: LD_VAR 0 4
119253: PPUSH
119254: LD_INT 20
119256: PPUSH
119257: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
119261: LD_VAR 0 4
119265: PPUSH
119266: CALL_OW 263
119270: PUSH
119271: LD_INT 1
119273: EQUAL
119274: PUSH
119275: LD_VAR 0 4
119279: PPUSH
119280: CALL_OW 311
119284: NOT
119285: AND
119286: IFFALSE 119353
// begin un := mechs [ 1 ] ;
119288: LD_ADDR_VAR 0 10
119292: PUSH
119293: LD_VAR 0 12
119297: PUSH
119298: LD_INT 1
119300: ARRAY
119301: ST_TO_ADDR
// ComExit ( un ) ;
119302: LD_VAR 0 10
119306: PPUSH
119307: CALL 89902 0 1
// AddComEnterUnit ( un , i ) ;
119311: LD_VAR 0 10
119315: PPUSH
119316: LD_VAR 0 4
119320: PPUSH
119321: CALL_OW 180
// SetTag ( un , 19 ) ;
119325: LD_VAR 0 10
119329: PPUSH
119330: LD_INT 19
119332: PPUSH
119333: CALL_OW 109
// mechs := mechs diff un ;
119337: LD_ADDR_VAR 0 12
119341: PUSH
119342: LD_VAR 0 12
119346: PUSH
119347: LD_VAR 0 10
119351: DIFF
119352: ST_TO_ADDR
// end ; end ;
119353: GO 119231
119355: POP
119356: POP
// if solds then
119357: LD_VAR 0 8
119361: IFFALSE 119420
// for i in solds do
119363: LD_ADDR_VAR 0 4
119367: PUSH
119368: LD_VAR 0 8
119372: PUSH
119373: FOR_IN
119374: IFFALSE 119418
// if not GetTag ( i ) then
119376: LD_VAR 0 4
119380: PPUSH
119381: CALL_OW 110
119385: NOT
119386: IFFALSE 119416
// begin defenders := defenders union i ;
119388: LD_ADDR_VAR 0 2
119392: PUSH
119393: LD_VAR 0 2
119397: PUSH
119398: LD_VAR 0 4
119402: UNION
119403: ST_TO_ADDR
// SetTag ( i , 18 ) ;
119404: LD_VAR 0 4
119408: PPUSH
119409: LD_INT 18
119411: PPUSH
119412: CALL_OW 109
// end ;
119416: GO 119373
119418: POP
119419: POP
// repeat wait ( 0 0$2 ) ;
119420: LD_INT 70
119422: PPUSH
119423: CALL_OW 67
// enemy := mc_scan [ base ] ;
119427: LD_ADDR_VAR 0 21
119431: PUSH
119432: LD_EXP 101
119436: PUSH
119437: LD_VAR 0 1
119441: ARRAY
119442: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119443: LD_EXP 78
119447: PUSH
119448: LD_VAR 0 1
119452: ARRAY
119453: NOT
119454: PUSH
119455: LD_EXP 78
119459: PUSH
119460: LD_VAR 0 1
119464: ARRAY
119465: PUSH
119466: EMPTY
119467: EQUAL
119468: OR
119469: IFFALSE 119506
// begin for i in defenders do
119471: LD_ADDR_VAR 0 4
119475: PUSH
119476: LD_VAR 0 2
119480: PUSH
119481: FOR_IN
119482: IFFALSE 119495
// ComStop ( i ) ;
119484: LD_VAR 0 4
119488: PPUSH
119489: CALL_OW 141
119493: GO 119481
119495: POP
119496: POP
// defenders := [ ] ;
119497: LD_ADDR_VAR 0 2
119501: PUSH
119502: EMPTY
119503: ST_TO_ADDR
// exit ;
119504: GO 120955
// end ; for i in defenders do
119506: LD_ADDR_VAR 0 4
119510: PUSH
119511: LD_VAR 0 2
119515: PUSH
119516: FOR_IN
119517: IFFALSE 120415
// begin e := NearestUnitToUnit ( enemy , i ) ;
119519: LD_ADDR_VAR 0 13
119523: PUSH
119524: LD_VAR 0 21
119528: PPUSH
119529: LD_VAR 0 4
119533: PPUSH
119534: CALL_OW 74
119538: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119539: LD_ADDR_VAR 0 7
119543: PUSH
119544: LD_EXP 78
119548: PUSH
119549: LD_VAR 0 1
119553: ARRAY
119554: PPUSH
119555: LD_INT 2
119557: PUSH
119558: LD_INT 30
119560: PUSH
119561: LD_INT 0
119563: PUSH
119564: EMPTY
119565: LIST
119566: LIST
119567: PUSH
119568: LD_INT 30
119570: PUSH
119571: LD_INT 1
119573: PUSH
119574: EMPTY
119575: LIST
119576: LIST
119577: PUSH
119578: EMPTY
119579: LIST
119580: LIST
119581: LIST
119582: PPUSH
119583: CALL_OW 72
119587: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
119588: LD_ADDR_VAR 0 16
119592: PUSH
119593: LD_VAR 0 7
119597: NOT
119598: PUSH
119599: LD_VAR 0 7
119603: PPUSH
119604: LD_INT 3
119606: PUSH
119607: LD_INT 24
119609: PUSH
119610: LD_INT 600
119612: PUSH
119613: EMPTY
119614: LIST
119615: LIST
119616: PUSH
119617: EMPTY
119618: LIST
119619: LIST
119620: PPUSH
119621: CALL_OW 72
119625: OR
119626: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
119627: LD_VAR 0 4
119631: PPUSH
119632: CALL_OW 247
119636: PUSH
119637: LD_INT 2
119639: DOUBLE
119640: EQUAL
119641: IFTRUE 119645
119643: GO 120041
119645: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
119646: LD_VAR 0 4
119650: PPUSH
119651: CALL_OW 256
119655: PUSH
119656: LD_INT 1000
119658: EQUAL
119659: PUSH
119660: LD_VAR 0 4
119664: PPUSH
119665: LD_VAR 0 13
119669: PPUSH
119670: CALL_OW 296
119674: PUSH
119675: LD_INT 40
119677: LESS
119678: PUSH
119679: LD_VAR 0 13
119683: PPUSH
119684: LD_EXP 103
119688: PUSH
119689: LD_VAR 0 1
119693: ARRAY
119694: PPUSH
119695: CALL_OW 308
119699: OR
119700: AND
119701: IFFALSE 119823
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119703: LD_VAR 0 4
119707: PPUSH
119708: CALL_OW 262
119712: PUSH
119713: LD_INT 1
119715: EQUAL
119716: PUSH
119717: LD_VAR 0 4
119721: PPUSH
119722: CALL_OW 261
119726: PUSH
119727: LD_INT 30
119729: LESS
119730: AND
119731: PUSH
119732: LD_VAR 0 7
119736: AND
119737: IFFALSE 119807
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119739: LD_VAR 0 4
119743: PPUSH
119744: LD_VAR 0 7
119748: PPUSH
119749: LD_VAR 0 4
119753: PPUSH
119754: CALL_OW 74
119758: PPUSH
119759: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119763: LD_VAR 0 4
119767: PPUSH
119768: LD_VAR 0 7
119772: PPUSH
119773: LD_VAR 0 4
119777: PPUSH
119778: CALL_OW 74
119782: PPUSH
119783: CALL_OW 296
119787: PUSH
119788: LD_INT 6
119790: LESS
119791: IFFALSE 119805
// SetFuel ( i , 100 ) ;
119793: LD_VAR 0 4
119797: PPUSH
119798: LD_INT 100
119800: PPUSH
119801: CALL_OW 240
// end else
119805: GO 119821
// ComAttackUnit ( i , e ) ;
119807: LD_VAR 0 4
119811: PPUSH
119812: LD_VAR 0 13
119816: PPUSH
119817: CALL_OW 115
// end else
119821: GO 119924
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119823: LD_VAR 0 13
119827: PPUSH
119828: LD_EXP 103
119832: PUSH
119833: LD_VAR 0 1
119837: ARRAY
119838: PPUSH
119839: CALL_OW 308
119843: NOT
119844: PUSH
119845: LD_VAR 0 4
119849: PPUSH
119850: LD_VAR 0 13
119854: PPUSH
119855: CALL_OW 296
119859: PUSH
119860: LD_INT 40
119862: GREATEREQUAL
119863: AND
119864: PUSH
119865: LD_VAR 0 4
119869: PPUSH
119870: CALL_OW 256
119874: PUSH
119875: LD_INT 650
119877: LESSEQUAL
119878: OR
119879: PUSH
119880: LD_VAR 0 4
119884: PPUSH
119885: LD_EXP 102
119889: PUSH
119890: LD_VAR 0 1
119894: ARRAY
119895: PPUSH
119896: CALL_OW 308
119900: NOT
119901: AND
119902: IFFALSE 119924
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119904: LD_VAR 0 4
119908: PPUSH
119909: LD_EXP 102
119913: PUSH
119914: LD_VAR 0 1
119918: ARRAY
119919: PPUSH
119920: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119924: LD_VAR 0 4
119928: PPUSH
119929: CALL_OW 256
119933: PUSH
119934: LD_INT 1000
119936: LESS
119937: PUSH
119938: LD_VAR 0 4
119942: PPUSH
119943: CALL_OW 263
119947: PUSH
119948: LD_INT 1
119950: EQUAL
119951: AND
119952: PUSH
119953: LD_VAR 0 4
119957: PPUSH
119958: CALL_OW 311
119962: AND
119963: PUSH
119964: LD_VAR 0 4
119968: PPUSH
119969: LD_EXP 102
119973: PUSH
119974: LD_VAR 0 1
119978: ARRAY
119979: PPUSH
119980: CALL_OW 308
119984: AND
119985: IFFALSE 120039
// begin mech := IsDrivenBy ( i ) ;
119987: LD_ADDR_VAR 0 9
119991: PUSH
119992: LD_VAR 0 4
119996: PPUSH
119997: CALL_OW 311
120001: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
120002: LD_VAR 0 9
120006: PPUSH
120007: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
120011: LD_VAR 0 9
120015: PPUSH
120016: LD_VAR 0 4
120020: PPUSH
120021: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
120025: LD_VAR 0 9
120029: PPUSH
120030: LD_VAR 0 4
120034: PPUSH
120035: CALL_OW 180
// end ; end ; unit_human :
120039: GO 120386
120041: LD_INT 1
120043: DOUBLE
120044: EQUAL
120045: IFTRUE 120049
120047: GO 120385
120049: POP
// begin b := IsInUnit ( i ) ;
120050: LD_ADDR_VAR 0 18
120054: PUSH
120055: LD_VAR 0 4
120059: PPUSH
120060: CALL_OW 310
120064: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
120065: LD_ADDR_VAR 0 19
120069: PUSH
120070: LD_VAR 0 18
120074: NOT
120075: PUSH
120076: LD_VAR 0 18
120080: PPUSH
120081: CALL_OW 266
120085: PUSH
120086: LD_INT 32
120088: PUSH
120089: LD_INT 31
120091: PUSH
120092: EMPTY
120093: LIST
120094: LIST
120095: IN
120096: OR
120097: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
120098: LD_VAR 0 18
120102: PPUSH
120103: CALL_OW 266
120107: PUSH
120108: LD_INT 5
120110: EQUAL
120111: PUSH
120112: LD_VAR 0 4
120116: PPUSH
120117: CALL_OW 257
120121: PUSH
120122: LD_INT 1
120124: PUSH
120125: LD_INT 2
120127: PUSH
120128: LD_INT 3
120130: PUSH
120131: LD_INT 4
120133: PUSH
120134: EMPTY
120135: LIST
120136: LIST
120137: LIST
120138: LIST
120139: IN
120140: AND
120141: IFFALSE 120178
// begin class := AllowSpecClass ( i ) ;
120143: LD_ADDR_VAR 0 20
120147: PUSH
120148: LD_VAR 0 4
120152: PPUSH
120153: CALL 53998 0 1
120157: ST_TO_ADDR
// if class then
120158: LD_VAR 0 20
120162: IFFALSE 120178
// ComChangeProfession ( i , class ) ;
120164: LD_VAR 0 4
120168: PPUSH
120169: LD_VAR 0 20
120173: PPUSH
120174: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
120178: LD_VAR 0 16
120182: PUSH
120183: LD_VAR 0 2
120187: PPUSH
120188: LD_INT 21
120190: PUSH
120191: LD_INT 2
120193: PUSH
120194: EMPTY
120195: LIST
120196: LIST
120197: PPUSH
120198: CALL_OW 72
120202: PUSH
120203: LD_INT 1
120205: LESSEQUAL
120206: OR
120207: PUSH
120208: LD_VAR 0 19
120212: AND
120213: PUSH
120214: LD_VAR 0 4
120218: PUSH
120219: LD_VAR 0 17
120223: IN
120224: NOT
120225: AND
120226: IFFALSE 120319
// begin if b then
120228: LD_VAR 0 18
120232: IFFALSE 120281
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
120234: LD_VAR 0 18
120238: PPUSH
120239: LD_VAR 0 21
120243: PPUSH
120244: LD_VAR 0 18
120248: PPUSH
120249: CALL_OW 74
120253: PPUSH
120254: CALL_OW 296
120258: PUSH
120259: LD_INT 10
120261: LESS
120262: PUSH
120263: LD_VAR 0 18
120267: PPUSH
120268: CALL_OW 461
120272: PUSH
120273: LD_INT 7
120275: NONEQUAL
120276: AND
120277: IFFALSE 120281
// continue ;
120279: GO 119516
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
120281: LD_ADDR_VAR 0 17
120285: PUSH
120286: LD_VAR 0 17
120290: PPUSH
120291: LD_VAR 0 17
120295: PUSH
120296: LD_INT 1
120298: PLUS
120299: PPUSH
120300: LD_VAR 0 4
120304: PPUSH
120305: CALL_OW 1
120309: ST_TO_ADDR
// ComExitBuilding ( i ) ;
120310: LD_VAR 0 4
120314: PPUSH
120315: CALL_OW 122
// end ; if sold_defenders then
120319: LD_VAR 0 17
120323: IFFALSE 120383
// if i in sold_defenders then
120325: LD_VAR 0 4
120329: PUSH
120330: LD_VAR 0 17
120334: IN
120335: IFFALSE 120383
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
120337: LD_VAR 0 4
120341: PPUSH
120342: CALL_OW 314
120346: NOT
120347: PUSH
120348: LD_VAR 0 4
120352: PPUSH
120353: LD_VAR 0 13
120357: PPUSH
120358: CALL_OW 296
120362: PUSH
120363: LD_INT 30
120365: LESS
120366: AND
120367: IFFALSE 120383
// ComAttackUnit ( i , e ) ;
120369: LD_VAR 0 4
120373: PPUSH
120374: LD_VAR 0 13
120378: PPUSH
120379: CALL_OW 115
// end ; end ; end ;
120383: GO 120386
120385: POP
// if IsDead ( i ) then
120386: LD_VAR 0 4
120390: PPUSH
120391: CALL_OW 301
120395: IFFALSE 120413
// defenders := defenders diff i ;
120397: LD_ADDR_VAR 0 2
120401: PUSH
120402: LD_VAR 0 2
120406: PUSH
120407: LD_VAR 0 4
120411: DIFF
120412: ST_TO_ADDR
// end ;
120413: GO 119516
120415: POP
120416: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
120417: LD_VAR 0 21
120421: NOT
120422: PUSH
120423: LD_VAR 0 2
120427: NOT
120428: OR
120429: PUSH
120430: LD_EXP 78
120434: PUSH
120435: LD_VAR 0 1
120439: ARRAY
120440: NOT
120441: OR
120442: IFFALSE 119420
// MC_Reset ( base , 18 ) ;
120444: LD_VAR 0 1
120448: PPUSH
120449: LD_INT 18
120451: PPUSH
120452: CALL 25687 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
120456: LD_ADDR_VAR 0 2
120460: PUSH
120461: LD_VAR 0 2
120465: PUSH
120466: LD_VAR 0 2
120470: PPUSH
120471: LD_INT 2
120473: PUSH
120474: LD_INT 25
120476: PUSH
120477: LD_INT 1
120479: PUSH
120480: EMPTY
120481: LIST
120482: LIST
120483: PUSH
120484: LD_INT 25
120486: PUSH
120487: LD_INT 5
120489: PUSH
120490: EMPTY
120491: LIST
120492: LIST
120493: PUSH
120494: LD_INT 25
120496: PUSH
120497: LD_INT 8
120499: PUSH
120500: EMPTY
120501: LIST
120502: LIST
120503: PUSH
120504: LD_INT 25
120506: PUSH
120507: LD_INT 9
120509: PUSH
120510: EMPTY
120511: LIST
120512: LIST
120513: PUSH
120514: EMPTY
120515: LIST
120516: LIST
120517: LIST
120518: LIST
120519: LIST
120520: PPUSH
120521: CALL_OW 72
120525: DIFF
120526: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
120527: LD_VAR 0 21
120531: NOT
120532: PUSH
120533: LD_VAR 0 2
120537: PPUSH
120538: LD_INT 21
120540: PUSH
120541: LD_INT 2
120543: PUSH
120544: EMPTY
120545: LIST
120546: LIST
120547: PPUSH
120548: CALL_OW 72
120552: AND
120553: IFFALSE 120891
// begin tmp := FilterByTag ( defenders , 19 ) ;
120555: LD_ADDR_VAR 0 11
120559: PUSH
120560: LD_VAR 0 2
120564: PPUSH
120565: LD_INT 19
120567: PPUSH
120568: CALL 87086 0 2
120572: ST_TO_ADDR
// if tmp then
120573: LD_VAR 0 11
120577: IFFALSE 120647
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
120579: LD_ADDR_VAR 0 11
120583: PUSH
120584: LD_VAR 0 11
120588: PPUSH
120589: LD_INT 25
120591: PUSH
120592: LD_INT 3
120594: PUSH
120595: EMPTY
120596: LIST
120597: LIST
120598: PPUSH
120599: CALL_OW 72
120603: ST_TO_ADDR
// if tmp then
120604: LD_VAR 0 11
120608: IFFALSE 120647
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
120610: LD_ADDR_EXP 90
120614: PUSH
120615: LD_EXP 90
120619: PPUSH
120620: LD_VAR 0 1
120624: PPUSH
120625: LD_EXP 90
120629: PUSH
120630: LD_VAR 0 1
120634: ARRAY
120635: PUSH
120636: LD_VAR 0 11
120640: UNION
120641: PPUSH
120642: CALL_OW 1
120646: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
120647: LD_VAR 0 1
120651: PPUSH
120652: LD_INT 19
120654: PPUSH
120655: CALL 25687 0 2
// repeat wait ( 0 0$1 ) ;
120659: LD_INT 35
120661: PPUSH
120662: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120666: LD_EXP 78
120670: PUSH
120671: LD_VAR 0 1
120675: ARRAY
120676: NOT
120677: PUSH
120678: LD_EXP 78
120682: PUSH
120683: LD_VAR 0 1
120687: ARRAY
120688: PUSH
120689: EMPTY
120690: EQUAL
120691: OR
120692: IFFALSE 120729
// begin for i in defenders do
120694: LD_ADDR_VAR 0 4
120698: PUSH
120699: LD_VAR 0 2
120703: PUSH
120704: FOR_IN
120705: IFFALSE 120718
// ComStop ( i ) ;
120707: LD_VAR 0 4
120711: PPUSH
120712: CALL_OW 141
120716: GO 120704
120718: POP
120719: POP
// defenders := [ ] ;
120720: LD_ADDR_VAR 0 2
120724: PUSH
120725: EMPTY
120726: ST_TO_ADDR
// exit ;
120727: GO 120955
// end ; for i in defenders do
120729: LD_ADDR_VAR 0 4
120733: PUSH
120734: LD_VAR 0 2
120738: PUSH
120739: FOR_IN
120740: IFFALSE 120829
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120742: LD_VAR 0 4
120746: PPUSH
120747: LD_EXP 102
120751: PUSH
120752: LD_VAR 0 1
120756: ARRAY
120757: PPUSH
120758: CALL_OW 308
120762: NOT
120763: IFFALSE 120787
// ComMoveToArea ( i , mc_parking [ base ] ) else
120765: LD_VAR 0 4
120769: PPUSH
120770: LD_EXP 102
120774: PUSH
120775: LD_VAR 0 1
120779: ARRAY
120780: PPUSH
120781: CALL_OW 113
120785: GO 120827
// if GetControl ( i ) = control_manual then
120787: LD_VAR 0 4
120791: PPUSH
120792: CALL_OW 263
120796: PUSH
120797: LD_INT 1
120799: EQUAL
120800: IFFALSE 120827
// if IsDrivenBy ( i ) then
120802: LD_VAR 0 4
120806: PPUSH
120807: CALL_OW 311
120811: IFFALSE 120827
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120813: LD_VAR 0 4
120817: PPUSH
120818: CALL_OW 311
120822: PPUSH
120823: CALL_OW 121
// end ;
120827: GO 120739
120829: POP
120830: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120831: LD_VAR 0 2
120835: PPUSH
120836: LD_INT 95
120838: PUSH
120839: LD_EXP 102
120843: PUSH
120844: LD_VAR 0 1
120848: ARRAY
120849: PUSH
120850: EMPTY
120851: LIST
120852: LIST
120853: PPUSH
120854: CALL_OW 72
120858: PUSH
120859: LD_VAR 0 2
120863: EQUAL
120864: PUSH
120865: LD_EXP 101
120869: PUSH
120870: LD_VAR 0 1
120874: ARRAY
120875: OR
120876: PUSH
120877: LD_EXP 78
120881: PUSH
120882: LD_VAR 0 1
120886: ARRAY
120887: NOT
120888: OR
120889: IFFALSE 120659
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
120891: LD_ADDR_EXP 100
120895: PUSH
120896: LD_EXP 100
120900: PPUSH
120901: LD_VAR 0 1
120905: PPUSH
120906: LD_VAR 0 2
120910: PPUSH
120911: LD_INT 21
120913: PUSH
120914: LD_INT 2
120916: PUSH
120917: EMPTY
120918: LIST
120919: LIST
120920: PPUSH
120921: CALL_OW 72
120925: PPUSH
120926: CALL_OW 1
120930: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
120931: LD_VAR 0 1
120935: PPUSH
120936: LD_INT 19
120938: PPUSH
120939: CALL 25687 0 2
// MC_Reset ( base , 20 ) ;
120943: LD_VAR 0 1
120947: PPUSH
120948: LD_INT 20
120950: PPUSH
120951: CALL 25687 0 2
// end ; end_of_file
120955: LD_VAR 0 3
120959: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
120960: LD_VAR 0 1
120964: PUSH
120965: LD_INT 200
120967: DOUBLE
120968: GREATEREQUAL
120969: IFFALSE 120977
120971: LD_INT 299
120973: DOUBLE
120974: LESSEQUAL
120975: IFTRUE 120979
120977: GO 121011
120979: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
120980: LD_VAR 0 1
120984: PPUSH
120985: LD_VAR 0 2
120989: PPUSH
120990: LD_VAR 0 3
120994: PPUSH
120995: LD_VAR 0 4
120999: PPUSH
121000: LD_VAR 0 5
121004: PPUSH
121005: CALL 109746 0 5
121009: GO 121088
121011: LD_INT 300
121013: DOUBLE
121014: GREATEREQUAL
121015: IFFALSE 121023
121017: LD_INT 399
121019: DOUBLE
121020: LESSEQUAL
121021: IFTRUE 121025
121023: GO 121087
121025: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
121026: LD_VAR 0 1
121030: PPUSH
121031: LD_VAR 0 2
121035: PPUSH
121036: LD_VAR 0 3
121040: PPUSH
121041: LD_VAR 0 4
121045: PPUSH
121046: LD_VAR 0 5
121050: PPUSH
121051: LD_VAR 0 6
121055: PPUSH
121056: LD_VAR 0 7
121060: PPUSH
121061: LD_VAR 0 8
121065: PPUSH
121066: LD_VAR 0 9
121070: PPUSH
121071: LD_VAR 0 10
121075: PPUSH
121076: LD_VAR 0 11
121080: PPUSH
121081: CALL 106079 0 11
121085: GO 121088
121087: POP
// end ;
121088: PPOPN 11
121090: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
121091: LD_VAR 0 1
121095: PPUSH
121096: LD_VAR 0 2
121100: PPUSH
121101: LD_VAR 0 3
121105: PPUSH
121106: LD_VAR 0 4
121110: PPUSH
121111: LD_VAR 0 5
121115: PPUSH
121116: CALL 109482 0 5
// end ; end_of_file
121120: PPOPN 5
121122: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
121123: LD_VAR 0 1
121127: PPUSH
121128: LD_VAR 0 2
121132: PPUSH
121133: LD_VAR 0 3
121137: PPUSH
121138: LD_VAR 0 4
121142: PPUSH
121143: LD_VAR 0 5
121147: PPUSH
121148: LD_VAR 0 6
121152: PPUSH
121153: CALL 93731 0 6
// end ;
121157: PPOPN 6
121159: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
121160: LD_INT 0
121162: PPUSH
// begin if not units then
121163: LD_VAR 0 1
121167: NOT
121168: IFFALSE 121172
// exit ;
121170: GO 121172
// end ;
121172: PPOPN 7
121174: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
121175: CALL 93635 0 0
// end ;
121179: PPOPN 1
121181: END
