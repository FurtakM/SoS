// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20256 0 0
// InitNature ;
  19: CALL 16914 0 0
// InitArtifact ;
  23: CALL 17527 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4533 0 0
// PrepareAlliance ;
  44: CALL 1351 0 0
// PrepareArabian ;
  48: CALL 6242 0 0
// PrepareRussian ;
  52: CALL 8193 0 0
// PrepareLegion ;
  56: CALL 6636 0 0
// Action ;
  60: CALL 10746 0 0
// MC_Start ( ) ;
  64: CALL 22368 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 168: LD_ADDR_EXP 12
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 176: LD_ADDR_EXP 13
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// end ;
 184: LD_VAR 0 1
 188: RET
// export function CustomInitMacro ( ) ; begin
 189: LD_INT 0
 191: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 192: LD_ADDR_EXP 100
 196: PUSH
 197: LD_INT 26
 199: PUSH
 200: LD_INT 1
 202: PUSH
 203: LD_INT 4
 205: PUSH
 206: LD_INT 8
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 215: LD_ADDR_EXP 101
 219: PUSH
 220: LD_INT 27
 222: PUSH
 223: LD_INT 2
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 7
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_INT 6
 243: PUSH
 244: LD_INT 7
 246: PUSH
 247: LD_INT 9
 249: PUSH
 250: EMPTY
 251: LIST
 252: LIST
 253: LIST
 254: PUSH
 255: LD_OWVAR 67
 259: ARRAY
 260: PPUSH
 261: LD_INT 28
 263: PPUSH
 264: CALL 43585 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 268: LD_INT 1
 270: PPUSH
 271: LD_INT 10
 273: PUSH
 274: LD_INT 11
 276: PUSH
 277: LD_INT 13
 279: PUSH
 280: LD_INT 15
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: LIST
 287: LIST
 288: PPUSH
 289: CALL 44645 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 293: LD_INT 1
 295: PPUSH
 296: LD_INT 29
 298: PUSH
 299: EMPTY
 300: LIST
 301: PPUSH
 302: CALL 44738 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 306: LD_ADDR_EXP 105
 310: PUSH
 311: LD_EXP 105
 315: PPUSH
 316: LD_INT 1
 318: PPUSH
 319: LD_INT 22
 321: PUSH
 322: LD_INT 2
 324: PUSH
 325: EMPTY
 326: LIST
 327: LIST
 328: PUSH
 329: LD_INT 25
 331: PUSH
 332: LD_INT 15
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PUSH
 339: EMPTY
 340: LIST
 341: LIST
 342: PPUSH
 343: CALL_OW 69
 347: PPUSH
 348: CALL_OW 1
 352: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 353: LD_INT 1
 355: PPUSH
 356: LD_INT 13
 358: PUSH
 359: LD_INT 2
 361: PUSH
 362: LD_INT 1
 364: PUSH
 365: LD_INT 31
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: LIST
 372: LIST
 373: PUSH
 374: LD_INT 13
 376: PUSH
 377: LD_INT 2
 379: PUSH
 380: LD_INT 1
 382: PUSH
 383: LD_INT 31
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: PUSH
 392: LD_INT 13
 394: PUSH
 395: LD_INT 1
 397: PUSH
 398: LD_INT 1
 400: PUSH
 401: LD_INT 28
 403: PUSH
 404: EMPTY
 405: LIST
 406: LIST
 407: LIST
 408: LIST
 409: PUSH
 410: LD_INT 13
 412: PUSH
 413: LD_INT 1
 415: PUSH
 416: LD_INT 1
 418: PUSH
 419: LD_INT 28
 421: PUSH
 422: EMPTY
 423: LIST
 424: LIST
 425: LIST
 426: LIST
 427: PUSH
 428: LD_INT 13
 430: PUSH
 431: LD_INT 1
 433: PUSH
 434: LD_INT 1
 436: PUSH
 437: LD_INT 28
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: PUSH
 446: LD_INT 13
 448: PUSH
 449: LD_INT 1
 451: PUSH
 452: LD_INT 1
 454: PUSH
 455: LD_INT 28
 457: PUSH
 458: EMPTY
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PPUSH
 472: CALL 43903 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 476: LD_INT 1
 478: PPUSH
 479: LD_INT 4
 481: PPUSH
 482: CALL 44088 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 486: LD_INT 2
 488: PPUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: LD_INT 12
 497: PUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 44645 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 511: LD_INT 2
 513: PPUSH
 514: LD_INT 14
 516: PUSH
 517: EMPTY
 518: LIST
 519: PPUSH
 520: CALL 44738 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 524: LD_INT 2
 526: PPUSH
 527: LD_INT 21
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 3
 535: PUSH
 536: LD_INT 51
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PUSH
 545: LD_INT 22
 547: PUSH
 548: LD_INT 3
 550: PUSH
 551: LD_INT 3
 553: PUSH
 554: LD_INT 52
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PUSH
 563: LD_INT 22
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 52
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 3
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 3
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: LD_INT 24
 655: PUSH
 656: LD_INT 3
 658: PUSH
 659: LD_INT 3
 661: PUSH
 662: LD_INT 47
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 43903 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 685: LD_INT 2
 687: PPUSH
 688: LD_INT 5
 690: PPUSH
 691: CALL 44088 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 695: LD_INT 2
 697: PPUSH
 698: LD_INT 0
 700: PPUSH
 701: CALL 44518 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 705: LD_INT 3
 707: PPUSH
 708: LD_INT 10
 710: PUSH
 711: LD_INT 12
 713: PUSH
 714: LD_INT 15
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_OWVAR 67
 726: ARRAY
 727: PPUSH
 728: LD_INT 24
 730: PPUSH
 731: CALL 43585 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 735: LD_INT 3
 737: PPUSH
 738: LD_INT 10
 740: PUSH
 741: LD_INT 11
 743: PUSH
 744: LD_INT 13
 746: PUSH
 747: LD_INT 15
 749: PUSH
 750: EMPTY
 751: LIST
 752: LIST
 753: LIST
 754: LIST
 755: PPUSH
 756: CALL 44645 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 760: LD_INT 3
 762: PPUSH
 763: LD_INT 13
 765: PUSH
 766: EMPTY
 767: LIST
 768: PPUSH
 769: CALL 44738 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 773: LD_ADDR_EXP 105
 777: PUSH
 778: LD_EXP 105
 782: PPUSH
 783: LD_INT 3
 785: PPUSH
 786: LD_INT 22
 788: PUSH
 789: LD_INT 8
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 25
 798: PUSH
 799: LD_INT 15
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: PPUSH
 810: CALL_OW 69
 814: PPUSH
 815: CALL_OW 1
 819: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 820: LD_INT 3
 822: PPUSH
 823: LD_INT 13
 825: PUSH
 826: LD_INT 2
 828: PUSH
 829: LD_INT 1
 831: PUSH
 832: LD_INT 31
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 13
 843: PUSH
 844: LD_INT 2
 846: PUSH
 847: LD_INT 1
 849: PUSH
 850: LD_INT 31
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PUSH
 859: LD_INT 13
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: LD_INT 32
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_INT 14
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 1
 885: PUSH
 886: LD_INT 28
 888: PUSH
 889: EMPTY
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: PUSH
 895: LD_INT 14
 897: PUSH
 898: LD_INT 1
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 28
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 14
 915: PUSH
 916: LD_INT 1
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 28
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 14
 933: PUSH
 934: LD_INT 1
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 28
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: PPUSH
 958: CALL 43903 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 962: LD_INT 3
 964: PPUSH
 965: LD_INT 4
 967: PPUSH
 968: CALL 44088 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 972: LD_INT 4
 974: PPUSH
 975: LD_INT 10
 977: PUSH
 978: LD_INT 12
 980: PUSH
 981: LD_INT 11
 983: PUSH
 984: LD_INT 15
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL 44645 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 997: LD_INT 4
 999: PPUSH
1000: LD_INT 33
1002: PUSH
1003: EMPTY
1004: LIST
1005: PPUSH
1006: CALL 44738 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1010: LD_INT 4
1012: PPUSH
1013: LD_INT 5
1015: PUSH
1016: LD_INT 6
1018: PUSH
1019: LD_INT 7
1021: PUSH
1022: LD_INT 9
1024: PUSH
1025: LD_INT 10
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 45056 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 54
1044: PPUSH
1045: LD_INT 85
1047: PPUSH
1048: LD_INT 2
1050: PPUSH
1051: LD_INT 25
1053: PUSH
1054: LD_INT 16
1056: PUSH
1057: LD_INT 17
1059: PUSH
1060: LD_INT 18
1062: PUSH
1063: LD_INT 22
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: PPUSH
1073: CALL 44850 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1077: LD_INT 4
1079: PPUSH
1080: LD_INT 5
1082: PUSH
1083: LD_INT 1
1085: PUSH
1086: LD_INT 1
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: LIST
1096: LIST
1097: PUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 1
1103: PUSH
1104: LD_INT 1
1106: PUSH
1107: LD_INT 6
1109: PUSH
1110: EMPTY
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: PUSH
1116: LD_INT 5
1118: PUSH
1119: LD_INT 1
1121: PUSH
1122: LD_INT 1
1124: PUSH
1125: LD_INT 7
1127: PUSH
1128: EMPTY
1129: LIST
1130: LIST
1131: LIST
1132: LIST
1133: PUSH
1134: LD_INT 5
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 1
1142: PUSH
1143: LD_INT 6
1145: PUSH
1146: EMPTY
1147: LIST
1148: LIST
1149: LIST
1150: LIST
1151: PUSH
1152: LD_INT 5
1154: PUSH
1155: LD_INT 1
1157: PUSH
1158: LD_INT 3
1160: PUSH
1161: LD_INT 12
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: PUSH
1170: LD_INT 3
1172: PUSH
1173: LD_INT 1
1175: PUSH
1176: LD_INT 3
1178: PUSH
1179: LD_INT 13
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: LIST
1194: LIST
1195: PPUSH
1196: CALL 43903 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1200: LD_INT 4
1202: PPUSH
1203: LD_INT 4
1205: PPUSH
1206: CALL 44088 0 2
// MC_SetTame ( 4 , powellApe ) ;
1210: LD_INT 4
1212: PPUSH
1213: LD_INT 11
1215: PPUSH
1216: CALL 44469 0 2
// end ;
1220: LD_VAR 0 1
1224: RET
// every 0 0$1 trigger debug do var i ;
1225: LD_EXP 1
1229: IFFALSE 1327
1231: GO 1233
1233: DISABLE
1234: LD_INT 0
1236: PPUSH
// begin enable ;
1237: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1238: LD_ADDR_VAR 0 1
1242: PUSH
1243: LD_INT 22
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: LD_INT 21
1258: PUSH
1259: LD_INT 1
1261: PUSH
1262: EMPTY
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 21
1268: PUSH
1269: LD_INT 2
1271: PUSH
1272: EMPTY
1273: LIST
1274: LIST
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: LIST
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: LD_INT 24
1286: PUSH
1287: LD_INT 1000
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: PUSH
1294: EMPTY
1295: LIST
1296: LIST
1297: PUSH
1298: EMPTY
1299: LIST
1300: LIST
1301: LIST
1302: PPUSH
1303: CALL_OW 69
1307: PUSH
1308: FOR_IN
1309: IFFALSE 1325
// SetLives ( i , 1000 ) ;
1311: LD_VAR 0 1
1315: PPUSH
1316: LD_INT 1000
1318: PPUSH
1319: CALL_OW 234
1323: GO 1308
1325: POP
1326: POP
// end ;
1327: PPOPN 1
1329: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1330: LD_EXP 13
1334: PUSH
1335: LD_INT 5
1337: GREATEREQUAL
1338: IFFALSE 1350
1340: GO 1342
1342: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1343: LD_STRING ACH_ARTIFACT
1345: PPUSH
1346: CALL_OW 543
1350: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1351: LD_INT 0
1353: PPUSH
1354: PPUSH
1355: PPUSH
1356: PPUSH
1357: PPUSH
// uc_side := 7 ;
1358: LD_ADDR_OWVAR 20
1362: PUSH
1363: LD_INT 7
1365: ST_TO_ADDR
// tmp := [ ] ;
1366: LD_ADDR_VAR 0 5
1370: PUSH
1371: EMPTY
1372: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1373: LD_ADDR_EXP 14
1377: PUSH
1378: LD_STRING JMM
1380: PPUSH
1381: LD_EXP 1
1385: NOT
1386: PPUSH
1387: LD_STRING 14a_
1389: PPUSH
1390: CALL 50295 0 3
1394: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1395: LD_ADDR_EXP 46
1399: PUSH
1400: LD_STRING Burlak
1402: PPUSH
1403: LD_EXP 1
1407: NOT
1408: PPUSH
1409: LD_STRING 14a_
1411: PPUSH
1412: CALL 50295 0 3
1416: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1417: LD_ADDR_EXP 29
1421: PUSH
1422: LD_STRING Joan
1424: PPUSH
1425: LD_EXP 1
1429: NOT
1430: PPUSH
1431: LD_STRING 13a_
1433: PPUSH
1434: CALL 50295 0 3
1438: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1439: LD_ADDR_EXP 15
1443: PUSH
1444: LD_STRING Roth
1446: PPUSH
1447: LD_EXP 1
1451: NOT
1452: PPUSH
1453: LD_STRING 13a_
1455: PPUSH
1456: CALL 50295 0 3
1460: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1461: LD_ADDR_EXP 32
1465: PUSH
1466: LD_STRING Gossudarov
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 13a_
1477: PPUSH
1478: CALL 50295 0 3
1482: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1483: LD_ADDR_EXP 30
1487: PUSH
1488: LD_STRING DeltaDoctor
1490: PPUSH
1491: LD_EXP 1
1495: NOT
1496: PPUSH
1497: LD_STRING 13a_
1499: PPUSH
1500: CALL 50295 0 3
1504: ST_TO_ADDR
// if DeltaDoctor then
1505: LD_EXP 30
1509: IFFALSE 1527
// tmp := tmp ^ DeltaDoctor ;
1511: LD_ADDR_VAR 0 5
1515: PUSH
1516: LD_VAR 0 5
1520: PUSH
1521: LD_EXP 30
1525: ADD
1526: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1527: LD_ADDR_EXP 28
1531: PUSH
1532: LD_STRING Simms
1534: PPUSH
1535: LD_EXP 1
1539: NOT
1540: PPUSH
1541: LD_STRING 13a_
1543: PPUSH
1544: CALL 50295 0 3
1548: ST_TO_ADDR
// if Simms then
1549: LD_EXP 28
1553: IFFALSE 1571
// tmp := tmp ^ Simms ;
1555: LD_ADDR_VAR 0 5
1559: PUSH
1560: LD_VAR 0 5
1564: PUSH
1565: LD_EXP 28
1569: ADD
1570: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1571: LD_ADDR_EXP 26
1575: PUSH
1576: LD_STRING Frank
1578: PPUSH
1579: LD_EXP 1
1583: NOT
1584: PPUSH
1585: LD_STRING 13a_
1587: PPUSH
1588: CALL 50295 0 3
1592: ST_TO_ADDR
// if Frank then
1593: LD_EXP 26
1597: IFFALSE 1615
// tmp := tmp ^ Frank ;
1599: LD_ADDR_VAR 0 5
1603: PUSH
1604: LD_VAR 0 5
1608: PUSH
1609: LD_EXP 26
1613: ADD
1614: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1615: LD_ADDR_EXP 33
1619: PUSH
1620: LD_STRING Kirilenkova
1622: PPUSH
1623: LD_EXP 1
1627: NOT
1628: PPUSH
1629: LD_STRING 13a_
1631: PPUSH
1632: CALL 50295 0 3
1636: ST_TO_ADDR
// if Kirilenkova then
1637: LD_EXP 33
1641: IFFALSE 1659
// tmp := tmp ^ Kirilenkova ;
1643: LD_ADDR_VAR 0 5
1647: PUSH
1648: LD_VAR 0 5
1652: PUSH
1653: LD_EXP 33
1657: ADD
1658: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1659: LD_ADDR_EXP 34
1663: PUSH
1664: LD_STRING Titov
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 13a_
1675: PPUSH
1676: CALL 50295 0 3
1680: ST_TO_ADDR
// if Titov then
1681: LD_EXP 34
1685: IFFALSE 1703
// tmp := tmp ^ Titov ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: LD_EXP 34
1701: ADD
1702: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1703: LD_ADDR_EXP 35
1707: PUSH
1708: LD_STRING Fadeev
1710: PPUSH
1711: LD_EXP 1
1715: NOT
1716: PPUSH
1717: LD_STRING 13a_
1719: PPUSH
1720: CALL 50295 0 3
1724: ST_TO_ADDR
// if Fadeev then
1725: LD_EXP 35
1729: IFFALSE 1747
// tmp := tmp ^ Fadeev ;
1731: LD_ADDR_VAR 0 5
1735: PUSH
1736: LD_VAR 0 5
1740: PUSH
1741: LD_EXP 35
1745: ADD
1746: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1747: LD_ADDR_EXP 36
1751: PUSH
1752: LD_STRING Dolgov
1754: PPUSH
1755: LD_EXP 1
1759: NOT
1760: PPUSH
1761: LD_STRING 13a_
1763: PPUSH
1764: CALL 50295 0 3
1768: ST_TO_ADDR
// if Dolgov then
1769: LD_EXP 36
1773: IFFALSE 1791
// tmp := tmp ^ Dolgov ;
1775: LD_ADDR_VAR 0 5
1779: PUSH
1780: LD_VAR 0 5
1784: PUSH
1785: LD_EXP 36
1789: ADD
1790: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1791: LD_ADDR_EXP 37
1795: PUSH
1796: LD_STRING Petrosyan
1798: PPUSH
1799: LD_EXP 1
1803: NOT
1804: PPUSH
1805: LD_STRING 13a_
1807: PPUSH
1808: CALL 50295 0 3
1812: ST_TO_ADDR
// if Petrosyan then
1813: LD_EXP 37
1817: IFFALSE 1835
// tmp := tmp ^ Petrosyan ;
1819: LD_ADDR_VAR 0 5
1823: PUSH
1824: LD_VAR 0 5
1828: PUSH
1829: LD_EXP 37
1833: ADD
1834: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1835: LD_ADDR_EXP 38
1839: PUSH
1840: LD_STRING Scholtze
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 13a_
1851: PPUSH
1852: CALL 50295 0 3
1856: ST_TO_ADDR
// if Scholtze then
1857: LD_EXP 38
1861: IFFALSE 1879
// tmp := tmp ^ Scholtze ;
1863: LD_ADDR_VAR 0 5
1867: PUSH
1868: LD_VAR 0 5
1872: PUSH
1873: LD_EXP 38
1877: ADD
1878: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1879: LD_ADDR_EXP 39
1883: PUSH
1884: LD_STRING Oblukov
1886: PPUSH
1887: LD_EXP 1
1891: NOT
1892: PPUSH
1893: LD_STRING 13a_
1895: PPUSH
1896: CALL 50295 0 3
1900: ST_TO_ADDR
// if Oblukov then
1901: LD_EXP 39
1905: IFFALSE 1923
// tmp := tmp ^ Oblukov ;
1907: LD_ADDR_VAR 0 5
1911: PUSH
1912: LD_VAR 0 5
1916: PUSH
1917: LD_EXP 39
1921: ADD
1922: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1923: LD_ADDR_EXP 40
1927: PUSH
1928: LD_STRING Kapitsova
1930: PPUSH
1931: LD_EXP 1
1935: NOT
1936: PPUSH
1937: LD_STRING 13a_
1939: PPUSH
1940: CALL 50295 0 3
1944: ST_TO_ADDR
// if Kapitsova then
1945: LD_EXP 40
1949: IFFALSE 1967
// tmp := tmp ^ Kapitsova ;
1951: LD_ADDR_VAR 0 5
1955: PUSH
1956: LD_VAR 0 5
1960: PUSH
1961: LD_EXP 40
1965: ADD
1966: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1967: LD_ADDR_EXP 41
1971: PUSH
1972: LD_STRING Lipshchin
1974: PPUSH
1975: LD_EXP 1
1979: NOT
1980: PPUSH
1981: LD_STRING 13a_
1983: PPUSH
1984: CALL 50295 0 3
1988: ST_TO_ADDR
// if Lipshchin then
1989: LD_EXP 41
1993: IFFALSE 2011
// tmp := tmp ^ Lipshchin ;
1995: LD_ADDR_VAR 0 5
1999: PUSH
2000: LD_VAR 0 5
2004: PUSH
2005: LD_EXP 41
2009: ADD
2010: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2011: LD_ADDR_EXP 42
2015: PUSH
2016: LD_STRING Petrovova
2018: PPUSH
2019: LD_EXP 1
2023: NOT
2024: PPUSH
2025: LD_STRING 13a_
2027: PPUSH
2028: CALL 50295 0 3
2032: ST_TO_ADDR
// if Petrovova then
2033: LD_EXP 42
2037: IFFALSE 2055
// tmp := tmp ^ Petrovova ;
2039: LD_ADDR_VAR 0 5
2043: PUSH
2044: LD_VAR 0 5
2048: PUSH
2049: LD_EXP 42
2053: ADD
2054: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2055: LD_ADDR_EXP 43
2059: PUSH
2060: LD_STRING Kovalyuk
2062: PPUSH
2063: LD_EXP 1
2067: NOT
2068: PPUSH
2069: LD_STRING 13a_
2071: PPUSH
2072: CALL 50295 0 3
2076: ST_TO_ADDR
// if Kovalyuk then
2077: LD_EXP 43
2081: IFFALSE 2099
// tmp := tmp ^ Kovalyuk ;
2083: LD_ADDR_VAR 0 5
2087: PUSH
2088: LD_VAR 0 5
2092: PUSH
2093: LD_EXP 43
2097: ADD
2098: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2099: LD_ADDR_EXP 44
2103: PUSH
2104: LD_STRING Kuzmov
2106: PPUSH
2107: LD_EXP 1
2111: NOT
2112: PPUSH
2113: LD_STRING 13a_
2115: PPUSH
2116: CALL 50295 0 3
2120: ST_TO_ADDR
// if Kuzmov then
2121: LD_EXP 44
2125: IFFALSE 2143
// tmp := tmp ^ Kuzmov ;
2127: LD_ADDR_VAR 0 5
2131: PUSH
2132: LD_VAR 0 5
2136: PUSH
2137: LD_EXP 44
2141: ADD
2142: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2143: LD_ADDR_EXP 45
2147: PUSH
2148: LD_STRING Karamazov
2150: PPUSH
2151: LD_EXP 1
2155: NOT
2156: PPUSH
2157: LD_STRING 13a_
2159: PPUSH
2160: CALL 50295 0 3
2164: ST_TO_ADDR
// if Karamazov then
2165: LD_EXP 45
2169: IFFALSE 2187
// tmp := tmp ^ Karamazov ;
2171: LD_ADDR_VAR 0 5
2175: PUSH
2176: LD_VAR 0 5
2180: PUSH
2181: LD_EXP 45
2185: ADD
2186: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2187: LD_ADDR_EXP 47
2191: PUSH
2192: LD_STRING Belkov
2194: PPUSH
2195: LD_EXP 1
2199: NOT
2200: PPUSH
2201: LD_STRING 13a_
2203: PPUSH
2204: CALL 50295 0 3
2208: ST_TO_ADDR
// if Belkov then
2209: LD_EXP 47
2213: IFFALSE 2231
// tmp := tmp ^ Belkov ;
2215: LD_ADDR_VAR 0 5
2219: PUSH
2220: LD_VAR 0 5
2224: PUSH
2225: LD_EXP 47
2229: ADD
2230: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2231: LD_ADDR_EXP 48
2235: PUSH
2236: LD_STRING Gnyevko
2238: PPUSH
2239: LD_EXP 1
2243: NOT
2244: PPUSH
2245: LD_STRING 13a_
2247: PPUSH
2248: CALL 50295 0 3
2252: ST_TO_ADDR
// if Gnyevko then
2253: LD_EXP 48
2257: IFFALSE 2275
// tmp := tmp ^ Gnyevko ;
2259: LD_ADDR_VAR 0 5
2263: PUSH
2264: LD_VAR 0 5
2268: PUSH
2269: LD_EXP 48
2273: ADD
2274: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2275: LD_ADDR_EXP 31
2279: PUSH
2280: LD_STRING Coonie
2282: PPUSH
2283: CALL_OW 25
2287: ST_TO_ADDR
// if not Lisa then
2288: LD_EXP 16
2292: NOT
2293: IFFALSE 2339
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2295: LD_ADDR_EXP 16
2299: PUSH
2300: LD_STRING Lisa
2302: PPUSH
2303: LD_EXP 1
2307: NOT
2308: PPUSH
2309: LD_STRING 13a_
2311: PPUSH
2312: CALL 50295 0 3
2316: ST_TO_ADDR
// if Lisa then
2317: LD_EXP 16
2321: IFFALSE 2339
// tmp := tmp ^ Lisa ;
2323: LD_ADDR_VAR 0 5
2327: PUSH
2328: LD_VAR 0 5
2332: PUSH
2333: LD_EXP 16
2337: ADD
2338: ST_TO_ADDR
// end ; if not Donaldson then
2339: LD_EXP 17
2343: NOT
2344: IFFALSE 2390
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2346: LD_ADDR_EXP 17
2350: PUSH
2351: LD_STRING Donaldson
2353: PPUSH
2354: LD_EXP 1
2358: NOT
2359: PPUSH
2360: LD_STRING 13a_
2362: PPUSH
2363: CALL 50295 0 3
2367: ST_TO_ADDR
// if Donaldson then
2368: LD_EXP 17
2372: IFFALSE 2390
// tmp := tmp ^ Donaldson ;
2374: LD_ADDR_VAR 0 5
2378: PUSH
2379: LD_VAR 0 5
2383: PUSH
2384: LD_EXP 17
2388: ADD
2389: ST_TO_ADDR
// end ; if not Bobby then
2390: LD_EXP 18
2394: NOT
2395: IFFALSE 2441
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2397: LD_ADDR_EXP 18
2401: PUSH
2402: LD_STRING Bobby
2404: PPUSH
2405: LD_EXP 1
2409: NOT
2410: PPUSH
2411: LD_STRING 13a_
2413: PPUSH
2414: CALL 50295 0 3
2418: ST_TO_ADDR
// if Bobby then
2419: LD_EXP 18
2423: IFFALSE 2441
// tmp := tmp ^ Bobby ;
2425: LD_ADDR_VAR 0 5
2429: PUSH
2430: LD_VAR 0 5
2434: PUSH
2435: LD_EXP 18
2439: ADD
2440: ST_TO_ADDR
// end ; if not Cyrus then
2441: LD_EXP 19
2445: NOT
2446: IFFALSE 2492
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2448: LD_ADDR_EXP 19
2452: PUSH
2453: LD_STRING Cyrus
2455: PPUSH
2456: LD_EXP 1
2460: NOT
2461: PPUSH
2462: LD_STRING 13a_
2464: PPUSH
2465: CALL 50295 0 3
2469: ST_TO_ADDR
// if Cyrus then
2470: LD_EXP 19
2474: IFFALSE 2492
// tmp := tmp ^ Cyrus ;
2476: LD_ADDR_VAR 0 5
2480: PUSH
2481: LD_VAR 0 5
2485: PUSH
2486: LD_EXP 19
2490: ADD
2491: ST_TO_ADDR
// end ; if not Brown then
2492: LD_EXP 21
2496: NOT
2497: IFFALSE 2543
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2499: LD_ADDR_EXP 21
2503: PUSH
2504: LD_STRING Brown
2506: PPUSH
2507: LD_EXP 1
2511: NOT
2512: PPUSH
2513: LD_STRING 13a_
2515: PPUSH
2516: CALL 50295 0 3
2520: ST_TO_ADDR
// if Brown then
2521: LD_EXP 21
2525: IFFALSE 2543
// tmp := tmp ^ Brown ;
2527: LD_ADDR_VAR 0 5
2531: PUSH
2532: LD_VAR 0 5
2536: PUSH
2537: LD_EXP 21
2541: ADD
2542: ST_TO_ADDR
// end ; if not Gladstone then
2543: LD_EXP 22
2547: NOT
2548: IFFALSE 2594
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2550: LD_ADDR_EXP 22
2554: PUSH
2555: LD_STRING Gladstone
2557: PPUSH
2558: LD_EXP 1
2562: NOT
2563: PPUSH
2564: LD_STRING 13a_
2566: PPUSH
2567: CALL 50295 0 3
2571: ST_TO_ADDR
// if Gladstone then
2572: LD_EXP 22
2576: IFFALSE 2594
// tmp := tmp ^ Gladstone ;
2578: LD_ADDR_VAR 0 5
2582: PUSH
2583: LD_VAR 0 5
2587: PUSH
2588: LD_EXP 22
2592: ADD
2593: ST_TO_ADDR
// end ; if not Cornel then
2594: LD_EXP 24
2598: NOT
2599: IFFALSE 2645
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2601: LD_ADDR_EXP 24
2605: PUSH
2606: LD_STRING Cornel
2608: PPUSH
2609: LD_EXP 1
2613: NOT
2614: PPUSH
2615: LD_STRING 13a_
2617: PPUSH
2618: CALL 50295 0 3
2622: ST_TO_ADDR
// if Cornel then
2623: LD_EXP 24
2627: IFFALSE 2645
// tmp := tmp ^ Cornel ;
2629: LD_ADDR_VAR 0 5
2633: PUSH
2634: LD_VAR 0 5
2638: PUSH
2639: LD_EXP 24
2643: ADD
2644: ST_TO_ADDR
// end ; if not Houten then
2645: LD_EXP 23
2649: NOT
2650: IFFALSE 2696
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2652: LD_ADDR_EXP 23
2656: PUSH
2657: LD_STRING Houten
2659: PPUSH
2660: LD_EXP 1
2664: NOT
2665: PPUSH
2666: LD_STRING 13a_
2668: PPUSH
2669: CALL 50295 0 3
2673: ST_TO_ADDR
// if Houten then
2674: LD_EXP 23
2678: IFFALSE 2696
// tmp := tmp ^ Houten ;
2680: LD_ADDR_VAR 0 5
2684: PUSH
2685: LD_VAR 0 5
2689: PUSH
2690: LD_EXP 23
2694: ADD
2695: ST_TO_ADDR
// end ; if not Gary then
2696: LD_EXP 25
2700: NOT
2701: IFFALSE 2747
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2703: LD_ADDR_EXP 25
2707: PUSH
2708: LD_STRING Gary
2710: PPUSH
2711: LD_EXP 1
2715: NOT
2716: PPUSH
2717: LD_STRING 13a_
2719: PPUSH
2720: CALL 50295 0 3
2724: ST_TO_ADDR
// if Gary then
2725: LD_EXP 25
2729: IFFALSE 2747
// tmp := tmp ^ Gary ;
2731: LD_ADDR_VAR 0 5
2735: PUSH
2736: LD_VAR 0 5
2740: PUSH
2741: LD_EXP 25
2745: ADD
2746: ST_TO_ADDR
// end ; if not Kikuchi then
2747: LD_EXP 27
2751: NOT
2752: IFFALSE 2798
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2754: LD_ADDR_EXP 27
2758: PUSH
2759: LD_STRING Kikuchi
2761: PPUSH
2762: LD_EXP 1
2766: NOT
2767: PPUSH
2768: LD_STRING 13a_
2770: PPUSH
2771: CALL 50295 0 3
2775: ST_TO_ADDR
// if Kikuchi then
2776: LD_EXP 27
2780: IFFALSE 2798
// tmp := tmp ^ Kikuchi ;
2782: LD_ADDR_VAR 0 5
2786: PUSH
2787: LD_VAR 0 5
2791: PUSH
2792: LD_EXP 27
2796: ADD
2797: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2798: LD_ADDR_VAR 0 5
2802: PUSH
2803: LD_VAR 0 5
2807: PUSH
2808: LD_STRING 13a_others
2810: PPUSH
2811: CALL_OW 31
2815: UNION
2816: ST_TO_ADDR
// tmp := tmp diff 0 ;
2817: LD_ADDR_VAR 0 5
2821: PUSH
2822: LD_VAR 0 5
2826: PUSH
2827: LD_INT 0
2829: DIFF
2830: ST_TO_ADDR
// if tmp < 15 then
2831: LD_VAR 0 5
2835: PUSH
2836: LD_INT 15
2838: LESS
2839: IFFALSE 2927
// for i = 15 downto tmp do
2841: LD_ADDR_VAR 0 2
2845: PUSH
2846: DOUBLE
2847: LD_INT 15
2849: INC
2850: ST_TO_ADDR
2851: LD_VAR 0 5
2855: PUSH
2856: FOR_DOWNTO
2857: IFFALSE 2925
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2859: LD_ADDR_OWVAR 21
2863: PUSH
2864: LD_INT 1
2866: PUSH
2867: LD_INT 3
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: PUSH
2874: LD_INT 1
2876: PPUSH
2877: LD_INT 2
2879: PPUSH
2880: CALL_OW 12
2884: ARRAY
2885: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2886: LD_INT 0
2888: PPUSH
2889: LD_INT 1
2891: PPUSH
2892: LD_INT 4
2894: PPUSH
2895: CALL_OW 12
2899: PPUSH
2900: LD_INT 8
2902: PPUSH
2903: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2907: LD_ADDR_VAR 0 5
2911: PUSH
2912: LD_VAR 0 5
2916: PUSH
2917: CALL_OW 44
2921: ADD
2922: ST_TO_ADDR
// end ;
2923: GO 2856
2925: POP
2926: POP
// if not debug then
2927: LD_EXP 1
2931: NOT
2932: IFFALSE 3104
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2934: LD_ADDR_VAR 0 4
2938: PUSH
2939: LD_STRING 
2941: PPUSH
2942: LD_INT 15
2944: PUSH
2945: LD_INT 14
2947: PUSH
2948: LD_INT 13
2950: PUSH
2951: EMPTY
2952: LIST
2953: LIST
2954: LIST
2955: PUSH
2956: LD_OWVAR 67
2960: ARRAY
2961: PPUSH
2962: LD_INT 15
2964: PUSH
2965: LD_INT 14
2967: PUSH
2968: LD_INT 13
2970: PUSH
2971: EMPTY
2972: LIST
2973: LIST
2974: LIST
2975: PUSH
2976: LD_OWVAR 67
2980: ARRAY
2981: PPUSH
2982: LD_INT -6
2984: PUSH
2985: LD_EXP 14
2989: PUSH
2990: LD_EXP 46
2994: PUSH
2995: LD_EXP 15
2999: PUSH
3000: LD_EXP 29
3004: PUSH
3005: LD_EXP 20
3009: PUSH
3010: LD_EXP 32
3014: PUSH
3015: LD_INT -2
3017: PUSH
3018: LD_INT -3
3020: PUSH
3021: LD_INT -5
3023: PUSH
3024: EMPTY
3025: LIST
3026: LIST
3027: LIST
3028: LIST
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: LIST
3034: LIST
3035: PUSH
3036: LD_VAR 0 5
3040: ADD
3041: PPUSH
3042: LD_INT 1
3044: PUSH
3045: LD_INT 4
3047: PUSH
3048: LD_INT 2
3050: PUSH
3051: LD_INT 1
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 5
3063: PUSH
3064: LD_INT 0
3066: PUSH
3067: LD_INT 3
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: PUSH
3075: LD_INT 9
3077: PUSH
3078: LD_INT 0
3080: PUSH
3081: LD_INT 3
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: PPUSH
3097: CALL_OW 42
3101: ST_TO_ADDR
3102: GO 3183
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3104: LD_ADDR_VAR 0 4
3108: PUSH
3109: LD_EXP 34
3113: PUSH
3114: LD_EXP 35
3118: PUSH
3119: LD_EXP 36
3123: PUSH
3124: LD_EXP 37
3128: PUSH
3129: LD_EXP 38
3133: PUSH
3134: LD_EXP 39
3138: PUSH
3139: LD_EXP 40
3143: PUSH
3144: LD_EXP 41
3148: PUSH
3149: LD_EXP 42
3153: PUSH
3154: LD_EXP 43
3158: PUSH
3159: LD_EXP 44
3163: PUSH
3164: LD_EXP 45
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: ST_TO_ADDR
// uc_nation := 1 ;
3183: LD_ADDR_OWVAR 21
3187: PUSH
3188: LD_INT 1
3190: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3191: LD_INT 5
3193: PPUSH
3194: LD_INT 3
3196: PPUSH
3197: LD_INT 1
3199: PPUSH
3200: LD_INT 6
3202: PPUSH
3203: LD_INT 100
3205: PPUSH
3206: CALL 57410 0 5
// veh := CreateVehicle ;
3210: LD_ADDR_VAR 0 3
3214: PUSH
3215: CALL_OW 45
3219: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3220: LD_VAR 0 3
3224: PPUSH
3225: LD_INT 7
3227: NEG
3228: PPUSH
3229: CALL_OW 242
// SetDir ( veh , 3 ) ;
3233: LD_VAR 0 3
3237: PPUSH
3238: LD_INT 3
3240: PPUSH
3241: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3245: LD_VAR 0 3
3249: PPUSH
3250: LD_INT 31
3252: PPUSH
3253: LD_INT 0
3255: PPUSH
3256: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3260: LD_EXP 14
3264: PPUSH
3265: LD_VAR 0 3
3269: PPUSH
3270: CALL_OW 52
// if Joan then
3274: LD_EXP 29
3278: IFFALSE 3350
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3280: LD_INT 3
3282: PPUSH
3283: LD_INT 3
3285: PPUSH
3286: LD_INT 1
3288: PPUSH
3289: LD_INT 11
3291: PPUSH
3292: LD_INT 100
3294: PPUSH
3295: CALL 57410 0 5
// veh := CreateVehicle ;
3299: LD_ADDR_VAR 0 3
3303: PUSH
3304: CALL_OW 45
3308: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3309: LD_VAR 0 3
3313: PPUSH
3314: LD_INT 3
3316: PPUSH
3317: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3321: LD_VAR 0 3
3325: PPUSH
3326: LD_INT 30
3328: PPUSH
3329: LD_INT 0
3331: PPUSH
3332: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3336: LD_EXP 29
3340: PPUSH
3341: LD_VAR 0 3
3345: PPUSH
3346: CALL_OW 52
// end ; if Roth then
3350: LD_EXP 15
3354: IFFALSE 3426
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3356: LD_INT 3
3358: PPUSH
3359: LD_INT 3
3361: PPUSH
3362: LD_INT 1
3364: PPUSH
3365: LD_INT 11
3367: PPUSH
3368: LD_INT 100
3370: PPUSH
3371: CALL 57410 0 5
// veh := CreateVehicle ;
3375: LD_ADDR_VAR 0 3
3379: PUSH
3380: CALL_OW 45
3384: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3385: LD_VAR 0 3
3389: PPUSH
3390: LD_INT 3
3392: PPUSH
3393: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3397: LD_VAR 0 3
3401: PPUSH
3402: LD_INT 30
3404: PPUSH
3405: LD_INT 0
3407: PPUSH
3408: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3412: LD_EXP 15
3416: PPUSH
3417: LD_VAR 0 3
3421: PPUSH
3422: CALL_OW 52
// end ; if Denis then
3426: LD_EXP 20
3430: IFFALSE 3502
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3432: LD_INT 5
3434: PPUSH
3435: LD_INT 3
3437: PPUSH
3438: LD_INT 1
3440: PPUSH
3441: LD_INT 9
3443: PPUSH
3444: LD_INT 100
3446: PPUSH
3447: CALL 57410 0 5
// veh := CreateVehicle ;
3451: LD_ADDR_VAR 0 3
3455: PUSH
3456: CALL_OW 45
3460: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3461: LD_VAR 0 3
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3473: LD_VAR 0 3
3477: PPUSH
3478: LD_INT 30
3480: PPUSH
3481: LD_INT 0
3483: PPUSH
3484: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3488: LD_EXP 20
3492: PPUSH
3493: LD_VAR 0 3
3497: PPUSH
3498: CALL_OW 52
// end ; uc_nation := 3 ;
3502: LD_ADDR_OWVAR 21
3506: PUSH
3507: LD_INT 3
3509: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3510: LD_INT 22
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 1
3518: PPUSH
3519: LD_INT 45
3521: PPUSH
3522: LD_INT 100
3524: PPUSH
3525: CALL 57410 0 5
// veh := CreateVehicle ;
3529: LD_ADDR_VAR 0 3
3533: PUSH
3534: CALL_OW 45
3538: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3539: LD_VAR 0 3
3543: PPUSH
3544: LD_INT 7
3546: NEG
3547: PPUSH
3548: CALL_OW 242
// SetDir ( veh , 3 ) ;
3552: LD_VAR 0 3
3556: PPUSH
3557: LD_INT 3
3559: PPUSH
3560: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3564: LD_VAR 0 3
3568: PPUSH
3569: LD_INT 31
3571: PPUSH
3572: LD_INT 0
3574: PPUSH
3575: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3579: LD_EXP 46
3583: PPUSH
3584: LD_VAR 0 3
3588: PPUSH
3589: CALL_OW 52
// if Gossudarov then
3593: LD_EXP 32
3597: IFFALSE 3684
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3599: LD_INT 22
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: LD_INT 51
3610: PPUSH
3611: LD_INT 100
3613: PPUSH
3614: CALL 57410 0 5
// veh := CreateVehicle ;
3618: LD_ADDR_VAR 0 3
3622: PUSH
3623: CALL_OW 45
3627: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3628: LD_VAR 0 3
3632: PPUSH
3633: LD_INT 3
3635: PPUSH
3636: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3640: LD_VAR 0 3
3644: PPUSH
3645: LD_INT 30
3647: PPUSH
3648: LD_INT 0
3650: PPUSH
3651: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3655: LD_EXP 32
3659: PPUSH
3660: LD_VAR 0 3
3664: PPUSH
3665: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3669: LD_VAR 0 3
3673: PPUSH
3674: LD_INT 1
3676: PPUSH
3677: LD_INT 100
3679: PPUSH
3680: CALL_OW 290
// end ; for i in selected do
3684: LD_ADDR_VAR 0 2
3688: PUSH
3689: LD_VAR 0 4
3693: PUSH
3694: FOR_IN
3695: IFFALSE 4253
// begin uc_nation := GetNation ( i ) ;
3697: LD_ADDR_OWVAR 21
3701: PUSH
3702: LD_VAR 0 2
3706: PPUSH
3707: CALL_OW 248
3711: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3712: LD_VAR 0 2
3716: PUSH
3717: LD_EXP 16
3721: PUSH
3722: LD_EXP 17
3726: PUSH
3727: LD_EXP 19
3731: PUSH
3732: LD_EXP 18
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: LIST
3741: LIST
3742: IN
3743: IFFALSE 3766
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3745: LD_INT 5
3747: PPUSH
3748: LD_INT 3
3750: PPUSH
3751: LD_INT 1
3753: PPUSH
3754: LD_INT 6
3756: PPUSH
3757: LD_INT 100
3759: PPUSH
3760: CALL 57410 0 5
3764: GO 4200
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3766: LD_VAR 0 2
3770: PUSH
3771: LD_EXP 39
3775: PUSH
3776: LD_EXP 44
3780: PUSH
3781: LD_EXP 42
3785: PUSH
3786: LD_EXP 34
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: IN
3797: IFFALSE 3828
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3799: LD_INT 24
3801: PPUSH
3802: LD_INT 1
3804: PPUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 46
3810: PPUSH
3811: LD_INT 65
3813: PPUSH
3814: LD_INT 75
3816: PPUSH
3817: CALL_OW 12
3821: PPUSH
3822: CALL 57410 0 5
3826: GO 4200
// if i = Karamazov then
3828: LD_VAR 0 2
3832: PUSH
3833: LD_EXP 45
3837: EQUAL
3838: IFFALSE 3861
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3840: LD_INT 22
3842: PPUSH
3843: LD_INT 3
3845: PPUSH
3846: LD_INT 1
3848: PPUSH
3849: LD_INT 52
3851: PPUSH
3852: LD_INT 100
3854: PPUSH
3855: CALL 57410 0 5
3859: GO 4200
// if i = Brown then
3861: LD_VAR 0 2
3865: PUSH
3866: LD_EXP 21
3870: EQUAL
3871: IFFALSE 3894
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3873: LD_INT 3
3875: PPUSH
3876: LD_INT 3
3878: PPUSH
3879: LD_INT 1
3881: PPUSH
3882: LD_INT 13
3884: PPUSH
3885: LD_INT 100
3887: PPUSH
3888: CALL 57410 0 5
3892: GO 4200
// if uc_nation = nation_american then
3894: LD_OWVAR 21
3898: PUSH
3899: LD_INT 1
3901: EQUAL
3902: IFFALSE 4053
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3904: LD_INT 3
3906: PUSH
3907: LD_INT 5
3909: PUSH
3910: LD_INT 5
3912: PUSH
3913: EMPTY
3914: LIST
3915: LIST
3916: LIST
3917: PUSH
3918: LD_OWVAR 21
3922: PUSH
3923: LD_INT 3
3925: MOD
3926: PUSH
3927: LD_INT 1
3929: PLUS
3930: ARRAY
3931: PPUSH
3932: LD_INT 1
3934: PUSH
3935: LD_INT 3
3937: PUSH
3938: LD_INT 1
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: LIST
3945: PUSH
3946: LD_OWVAR 21
3950: PUSH
3951: LD_INT 3
3953: MOD
3954: PUSH
3955: LD_INT 1
3957: PLUS
3958: ARRAY
3959: PPUSH
3960: LD_INT 1
3962: PPUSH
3963: LD_INT 11
3965: PUSH
3966: LD_INT 4
3968: PUSH
3969: LD_INT 5
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_INT 6
3979: PUSH
3980: LD_INT 7
3982: PUSH
3983: LD_INT 9
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: LIST
3990: PUSH
3991: LD_INT 6
3993: PUSH
3994: LD_INT 9
3996: PUSH
3997: LD_INT 12
3999: PUSH
4000: EMPTY
4001: LIST
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_OWVAR 21
4014: PUSH
4015: LD_INT 3
4017: MOD
4018: PUSH
4019: LD_INT 1
4021: PLUS
4022: ARRAY
4023: PUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 3
4029: PPUSH
4030: CALL_OW 12
4034: ARRAY
4035: PPUSH
4036: LD_INT 65
4038: PPUSH
4039: LD_INT 75
4041: PPUSH
4042: CALL_OW 12
4046: PPUSH
4047: CALL 57410 0 5
// end else
4051: GO 4200
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4053: LD_INT 22
4055: PUSH
4056: LD_INT 23
4058: PUSH
4059: LD_INT 23
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: LIST
4066: PUSH
4067: LD_OWVAR 21
4071: PUSH
4072: LD_INT 3
4074: MOD
4075: PUSH
4076: LD_INT 1
4078: PLUS
4079: ARRAY
4080: PPUSH
4081: LD_INT 1
4083: PUSH
4084: LD_INT 3
4086: PUSH
4087: LD_INT 1
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: LIST
4094: PUSH
4095: LD_OWVAR 21
4099: PUSH
4100: LD_INT 3
4102: MOD
4103: PUSH
4104: LD_INT 1
4106: PLUS
4107: ARRAY
4108: PPUSH
4109: LD_INT 1
4111: PPUSH
4112: LD_INT 45
4114: PUSH
4115: LD_INT 43
4117: PUSH
4118: LD_INT 44
4120: PUSH
4121: EMPTY
4122: LIST
4123: LIST
4124: LIST
4125: PUSH
4126: LD_INT 46
4128: PUSH
4129: LD_INT 45
4131: PUSH
4132: LD_INT 44
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: LIST
4139: PUSH
4140: LD_INT 46
4142: PUSH
4143: LD_INT 43
4145: PUSH
4146: LD_INT 45
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_OWVAR 21
4163: PUSH
4164: LD_INT 3
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: ARRAY
4172: PUSH
4173: LD_INT 1
4175: PPUSH
4176: LD_INT 3
4178: PPUSH
4179: CALL_OW 12
4183: ARRAY
4184: PPUSH
4185: LD_INT 65
4187: PPUSH
4188: LD_INT 75
4190: PPUSH
4191: CALL_OW 12
4195: PPUSH
4196: CALL 57410 0 5
// end ; veh := CreateVehicle ;
4200: LD_ADDR_VAR 0 3
4204: PUSH
4205: CALL_OW 45
4209: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4210: LD_VAR 0 3
4214: PPUSH
4215: LD_INT 3
4217: PPUSH
4218: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4222: LD_VAR 0 3
4226: PPUSH
4227: LD_INT 30
4229: PPUSH
4230: LD_INT 0
4232: PPUSH
4233: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4237: LD_VAR 0 2
4241: PPUSH
4242: LD_VAR 0 3
4246: PPUSH
4247: CALL_OW 52
// end ;
4251: GO 3694
4253: POP
4254: POP
// if artifactArCaptured then
4255: LD_EXP 6
4259: IFFALSE 4345
// begin uc_nation := nation_american ;
4261: LD_ADDR_OWVAR 21
4265: PUSH
4266: LD_INT 1
4268: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4269: LD_INT 3
4271: PPUSH
4272: LD_INT 3
4274: PPUSH
4275: LD_INT 3
4277: PPUSH
4278: LD_INT 12
4280: PPUSH
4281: LD_INT 100
4283: PPUSH
4284: CALL 57410 0 5
// veh := CreateVehicle ;
4288: LD_ADDR_VAR 0 3
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4298: LD_VAR 0 3
4302: PPUSH
4303: LD_INT 3
4305: PPUSH
4306: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4310: LD_VAR 0 3
4314: PPUSH
4315: LD_INT 198
4317: PPUSH
4318: LD_INT 22
4320: PPUSH
4321: LD_INT 0
4323: PPUSH
4324: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4328: LD_VAR 0 3
4332: PPUSH
4333: LD_INT 4
4335: PPUSH
4336: LD_INT 50
4338: PPUSH
4339: CALL_OW 290
// end else
4343: GO 4364
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4345: LD_INT 4
4347: PPUSH
4348: LD_INT 267
4350: PPUSH
4351: LD_INT 226
4353: PPUSH
4354: LD_INT 5
4356: PPUSH
4357: LD_INT 0
4359: PPUSH
4360: CALL_OW 58
// end ; uc_nation := nation_american ;
4364: LD_ADDR_OWVAR 21
4368: PUSH
4369: LD_INT 1
4371: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4372: LD_INT 3
4374: PPUSH
4375: LD_INT 3
4377: PPUSH
4378: LD_INT 3
4380: PPUSH
4381: LD_INT 12
4383: PPUSH
4384: LD_INT 100
4386: PPUSH
4387: CALL 57410 0 5
// veh := CreateVehicle ;
4391: LD_ADDR_VAR 0 3
4395: PUSH
4396: CALL_OW 45
4400: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4401: LD_VAR 0 3
4405: PPUSH
4406: LD_INT 3
4408: PPUSH
4409: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4413: LD_VAR 0 3
4417: PPUSH
4418: LD_INT 218
4420: PPUSH
4421: LD_INT 23
4423: PPUSH
4424: LD_INT 0
4426: PPUSH
4427: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4431: LD_VAR 0 3
4435: PPUSH
4436: LD_INT 4
4438: PPUSH
4439: LD_INT 30
4441: PPUSH
4442: CALL_OW 290
// uc_nation := nation_russian ;
4446: LD_ADDR_OWVAR 21
4450: PUSH
4451: LD_INT 3
4453: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4454: LD_INT 22
4456: PPUSH
4457: LD_INT 3
4459: PPUSH
4460: LD_INT 3
4462: PPUSH
4463: LD_INT 51
4465: PPUSH
4466: LD_INT 100
4468: PPUSH
4469: CALL 57410 0 5
// veh := CreateVehicle ;
4473: LD_ADDR_VAR 0 3
4477: PUSH
4478: CALL_OW 45
4482: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4483: LD_VAR 0 3
4487: PPUSH
4488: LD_INT 3
4490: PPUSH
4491: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4495: LD_VAR 0 3
4499: PPUSH
4500: LD_INT 214
4502: PPUSH
4503: LD_INT 20
4505: PPUSH
4506: LD_INT 0
4508: PPUSH
4509: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4513: LD_VAR 0 3
4517: PPUSH
4518: LD_INT 4
4520: PPUSH
4521: LD_INT 40
4523: PPUSH
4524: CALL_OW 290
// end ; end_of_file
4528: LD_VAR 0 1
4532: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4533: LD_INT 0
4535: PPUSH
4536: PPUSH
4537: PPUSH
4538: PPUSH
4539: PPUSH
4540: PPUSH
4541: PPUSH
4542: PPUSH
4543: PPUSH
4544: PPUSH
// InitHc ;
4545: CALL_OW 19
// uc_side := 1 ;
4549: LD_ADDR_OWVAR 20
4553: PUSH
4554: LD_INT 1
4556: ST_TO_ADDR
// uc_nation := 1 ;
4557: LD_ADDR_OWVAR 21
4561: PUSH
4562: LD_INT 1
4564: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4565: LD_INT 387
4567: PPUSH
4568: CALL_OW 274
4572: PPUSH
4573: LD_INT 1
4575: PPUSH
4576: LD_INT 25500
4578: PPUSH
4579: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4583: LD_INT 387
4585: PPUSH
4586: CALL_OW 274
4590: PPUSH
4591: LD_INT 2
4593: PPUSH
4594: LD_INT 4000
4596: PPUSH
4597: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4601: LD_INT 387
4603: PPUSH
4604: CALL_OW 274
4608: PPUSH
4609: LD_INT 3
4611: PPUSH
4612: LD_INT 50
4614: PPUSH
4615: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4619: LD_INT 476
4621: PPUSH
4622: CALL_OW 274
4626: PPUSH
4627: LD_INT 1
4629: PPUSH
4630: LD_INT 7500
4632: PPUSH
4633: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4637: LD_INT 476
4639: PPUSH
4640: CALL_OW 274
4644: PPUSH
4645: LD_INT 2
4647: PPUSH
4648: LD_INT 4000
4650: PPUSH
4651: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4655: LD_INT 476
4657: PPUSH
4658: CALL_OW 274
4662: PPUSH
4663: LD_INT 3
4665: PPUSH
4666: LD_INT 10
4668: PPUSH
4669: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4673: LD_ADDR_EXP 49
4677: PUSH
4678: LD_STRING Powell
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4686: LD_EXP 49
4690: PPUSH
4691: LD_INT 387
4693: PPUSH
4694: CALL_OW 52
// tmp := [ ] ;
4698: LD_ADDR_VAR 0 6
4702: PUSH
4703: EMPTY
4704: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4705: LD_ADDR_EXP 16
4709: PUSH
4710: LD_STRING Lisa
4712: PPUSH
4713: LD_EXP 1
4717: NOT
4718: PPUSH
4719: LD_STRING 12p_
4721: PPUSH
4722: CALL 50295 0 3
4726: ST_TO_ADDR
// if Lisa then
4727: LD_EXP 16
4731: IFFALSE 4749
// tmp := tmp ^ Lisa ;
4733: LD_ADDR_VAR 0 6
4737: PUSH
4738: LD_VAR 0 6
4742: PUSH
4743: LD_EXP 16
4747: ADD
4748: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4749: LD_ADDR_EXP 17
4753: PUSH
4754: LD_STRING Donaldson
4756: PPUSH
4757: LD_EXP 1
4761: NOT
4762: PPUSH
4763: LD_STRING 12p_
4765: PPUSH
4766: CALL 50295 0 3
4770: ST_TO_ADDR
// if Donaldson then
4771: LD_EXP 17
4775: IFFALSE 4793
// tmp := tmp ^ Donaldson ;
4777: LD_ADDR_VAR 0 6
4781: PUSH
4782: LD_VAR 0 6
4786: PUSH
4787: LD_EXP 17
4791: ADD
4792: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4793: LD_ADDR_EXP 18
4797: PUSH
4798: LD_STRING Bobby
4800: PPUSH
4801: LD_EXP 1
4805: NOT
4806: PPUSH
4807: LD_STRING 12p_
4809: PPUSH
4810: CALL 50295 0 3
4814: ST_TO_ADDR
// if Bobby then
4815: LD_EXP 18
4819: IFFALSE 4837
// tmp := tmp ^ Bobby ;
4821: LD_ADDR_VAR 0 6
4825: PUSH
4826: LD_VAR 0 6
4830: PUSH
4831: LD_EXP 18
4835: ADD
4836: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4837: LD_ADDR_EXP 19
4841: PUSH
4842: LD_STRING Cyrus
4844: PPUSH
4845: LD_EXP 1
4849: NOT
4850: PPUSH
4851: LD_STRING 12p_
4853: PPUSH
4854: CALL 50295 0 3
4858: ST_TO_ADDR
// if Cyrus then
4859: LD_EXP 19
4863: IFFALSE 4881
// tmp := tmp ^ Cyrus ;
4865: LD_ADDR_VAR 0 6
4869: PUSH
4870: LD_VAR 0 6
4874: PUSH
4875: LD_EXP 19
4879: ADD
4880: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4881: LD_ADDR_EXP 21
4885: PUSH
4886: LD_STRING Brown
4888: PPUSH
4889: LD_EXP 1
4893: NOT
4894: PPUSH
4895: LD_STRING 12p_
4897: PPUSH
4898: CALL 50295 0 3
4902: ST_TO_ADDR
// if Brown then
4903: LD_EXP 21
4907: IFFALSE 4925
// tmp := tmp ^ Brown ;
4909: LD_ADDR_VAR 0 6
4913: PUSH
4914: LD_VAR 0 6
4918: PUSH
4919: LD_EXP 21
4923: ADD
4924: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4925: LD_ADDR_EXP 22
4929: PUSH
4930: LD_STRING Gladstone
4932: PPUSH
4933: LD_EXP 1
4937: NOT
4938: PPUSH
4939: LD_STRING 12p_
4941: PPUSH
4942: CALL 50295 0 3
4946: ST_TO_ADDR
// if Gladstone then
4947: LD_EXP 22
4951: IFFALSE 4969
// tmp := tmp ^ Gladstone ;
4953: LD_ADDR_VAR 0 6
4957: PUSH
4958: LD_VAR 0 6
4962: PUSH
4963: LD_EXP 22
4967: ADD
4968: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4969: LD_ADDR_EXP 23
4973: PUSH
4974: LD_STRING Houten
4976: PPUSH
4977: LD_EXP 1
4981: NOT
4982: PPUSH
4983: LD_STRING 12p_
4985: PPUSH
4986: CALL 50295 0 3
4990: ST_TO_ADDR
// if Houten then
4991: LD_EXP 23
4995: IFFALSE 5013
// tmp := tmp ^ Houten ;
4997: LD_ADDR_VAR 0 6
5001: PUSH
5002: LD_VAR 0 6
5006: PUSH
5007: LD_EXP 23
5011: ADD
5012: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5013: LD_ADDR_EXP 24
5017: PUSH
5018: LD_STRING Cornel
5020: PPUSH
5021: LD_EXP 1
5025: NOT
5026: PPUSH
5027: LD_STRING 12p_
5029: PPUSH
5030: CALL 50295 0 3
5034: ST_TO_ADDR
// if Cornel then
5035: LD_EXP 24
5039: IFFALSE 5057
// tmp := tmp ^ Cornel ;
5041: LD_ADDR_VAR 0 6
5045: PUSH
5046: LD_VAR 0 6
5050: PUSH
5051: LD_EXP 24
5055: ADD
5056: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5057: LD_ADDR_EXP 25
5061: PUSH
5062: LD_STRING Gary
5064: PPUSH
5065: LD_EXP 1
5069: NOT
5070: PPUSH
5071: LD_STRING 12p_
5073: PPUSH
5074: CALL 50295 0 3
5078: ST_TO_ADDR
// if Gary then
5079: LD_EXP 25
5083: IFFALSE 5101
// tmp := tmp ^ Gary ;
5085: LD_ADDR_VAR 0 6
5089: PUSH
5090: LD_VAR 0 6
5094: PUSH
5095: LD_EXP 25
5099: ADD
5100: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5101: LD_ADDR_EXP 27
5105: PUSH
5106: LD_STRING Kikuchi
5108: PPUSH
5109: LD_EXP 1
5113: NOT
5114: PPUSH
5115: LD_STRING 12p_
5117: PPUSH
5118: CALL 50295 0 3
5122: ST_TO_ADDR
// if Kikuchi then
5123: LD_EXP 27
5127: IFFALSE 5145
// tmp := tmp ^ Kikuchi ;
5129: LD_ADDR_VAR 0 6
5133: PUSH
5134: LD_VAR 0 6
5138: PUSH
5139: LD_EXP 27
5143: ADD
5144: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5145: LD_ADDR_VAR 0 6
5149: PUSH
5150: LD_VAR 0 6
5154: PUSH
5155: LD_STRING 12p_others
5157: PPUSH
5158: CALL_OW 31
5162: UNION
5163: ST_TO_ADDR
// if tmp < 36 then
5164: LD_VAR 0 6
5168: PUSH
5169: LD_INT 36
5171: LESS
5172: IFFALSE 5239
// for i = 1 to 36 - tmp do
5174: LD_ADDR_VAR 0 2
5178: PUSH
5179: DOUBLE
5180: LD_INT 1
5182: DEC
5183: ST_TO_ADDR
5184: LD_INT 36
5186: PUSH
5187: LD_VAR 0 6
5191: MINUS
5192: PUSH
5193: FOR_TO
5194: IFFALSE 5237
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5196: LD_INT 1
5198: PPUSH
5199: LD_VAR 0 2
5203: PUSH
5204: LD_INT 4
5206: MOD
5207: PUSH
5208: LD_INT 1
5210: PLUS
5211: PPUSH
5212: LD_INT 10
5214: PPUSH
5215: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5219: LD_ADDR_VAR 0 6
5223: PUSH
5224: LD_VAR 0 6
5228: PUSH
5229: CALL_OW 44
5233: ADD
5234: ST_TO_ADDR
// end ;
5235: GO 5193
5237: POP
5238: POP
// for i in tmp do
5239: LD_ADDR_VAR 0 2
5243: PUSH
5244: LD_VAR 0 6
5248: PUSH
5249: FOR_IN
5250: IFFALSE 5275
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5252: LD_VAR 0 2
5256: PPUSH
5257: LD_INT 62
5259: PPUSH
5260: LD_INT 93
5262: PPUSH
5263: LD_INT 9
5265: PPUSH
5266: LD_INT 0
5268: PPUSH
5269: CALL_OW 50
5273: GO 5249
5275: POP
5276: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
5277: LD_ADDR_EXP 76
5281: PUSH
5282: LD_EXP 76
5286: PPUSH
5287: LD_INT 4
5289: PPUSH
5290: LD_INT 22
5292: PUSH
5293: LD_INT 1
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: PPUSH
5305: CALL_OW 1
5309: ST_TO_ADDR
// uc_side := 0 ;
5310: LD_ADDR_OWVAR 20
5314: PUSH
5315: LD_INT 0
5317: ST_TO_ADDR
// uc_nation := 0 ;
5318: LD_ADDR_OWVAR 21
5322: PUSH
5323: LD_INT 0
5325: ST_TO_ADDR
// for i = 1 to 4 do
5326: LD_ADDR_VAR 0 2
5330: PUSH
5331: DOUBLE
5332: LD_INT 1
5334: DEC
5335: ST_TO_ADDR
5336: LD_INT 4
5338: PUSH
5339: FOR_TO
5340: IFFALSE 5371
// begin InitHc ;
5342: CALL_OW 19
// hc_class := class_apeman ;
5346: LD_ADDR_OWVAR 28
5350: PUSH
5351: LD_INT 12
5353: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5354: CALL_OW 44
5358: PPUSH
5359: LD_INT 11
5361: PPUSH
5362: LD_INT 0
5364: PPUSH
5365: CALL_OW 49
// end ;
5369: GO 5339
5371: POP
5372: POP
// end ;
5373: LD_VAR 0 1
5377: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5378: LD_EXP 4
5382: NOT
5383: PUSH
5384: LD_INT 4
5386: PPUSH
5387: LD_INT 1
5389: PPUSH
5390: CALL 45369 0 2
5394: NOT
5395: AND
5396: IFFALSE 6168
5398: GO 5400
5400: DISABLE
5401: LD_INT 0
5403: PPUSH
5404: PPUSH
5405: PPUSH
// begin enable ;
5406: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5407: LD_INT 22
5409: PUSH
5410: LD_INT 1
5412: PUSH
5413: EMPTY
5414: LIST
5415: LIST
5416: PUSH
5417: LD_INT 23
5419: PUSH
5420: LD_INT 1
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: PUSH
5427: LD_INT 30
5429: PUSH
5430: LD_INT 3
5432: PUSH
5433: EMPTY
5434: LIST
5435: LIST
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: LIST
5441: PPUSH
5442: CALL_OW 69
5446: NOT
5447: IFFALSE 5451
// exit ;
5449: GO 6168
// if Prob ( 40 ) then
5451: LD_INT 40
5453: PPUSH
5454: CALL_OW 13
5458: IFFALSE 5585
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5460: LD_INT 4
5462: PPUSH
5463: LD_INT 5
5465: PUSH
5466: LD_INT 1
5468: PUSH
5469: LD_INT 2
5471: PUSH
5472: LD_INT 7
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: PUSH
5481: LD_INT 5
5483: PUSH
5484: LD_INT 1
5486: PUSH
5487: LD_INT 2
5489: PUSH
5490: LD_INT 7
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: LIST
5497: LIST
5498: PUSH
5499: LD_INT 5
5501: PUSH
5502: LD_INT 1
5504: PUSH
5505: LD_INT 2
5507: PUSH
5508: LD_INT 7
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 5
5519: PUSH
5520: LD_INT 1
5522: PUSH
5523: LD_INT 2
5525: PUSH
5526: LD_INT 6
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: LIST
5533: LIST
5534: PUSH
5535: LD_INT 5
5537: PUSH
5538: LD_INT 1
5540: PUSH
5541: LD_INT 2
5543: PUSH
5544: LD_INT 6
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: LIST
5552: PUSH
5553: LD_INT 5
5555: PUSH
5556: LD_INT 1
5558: PUSH
5559: LD_INT 2
5561: PUSH
5562: LD_INT 6
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: LIST
5575: LIST
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL 43951 0 2
// end else
5583: GO 5708
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5585: LD_INT 4
5587: PPUSH
5588: LD_INT 5
5590: PUSH
5591: LD_INT 1
5593: PUSH
5594: LD_INT 2
5596: PUSH
5597: LD_INT 7
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: LD_INT 5
5608: PUSH
5609: LD_INT 1
5611: PUSH
5612: LD_INT 2
5614: PUSH
5615: LD_INT 9
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 5
5626: PUSH
5627: LD_INT 1
5629: PUSH
5630: LD_INT 2
5632: PUSH
5633: LD_INT 9
5635: PUSH
5636: EMPTY
5637: LIST
5638: LIST
5639: LIST
5640: LIST
5641: PUSH
5642: LD_INT 5
5644: PUSH
5645: LD_INT 1
5647: PUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 6
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: LIST
5658: LIST
5659: PUSH
5660: LD_INT 5
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 6
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 5
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 6
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PPUSH
5704: CALL 43951 0 2
// end ; repeat wait ( 0 0$1 ) ;
5708: LD_INT 35
5710: PPUSH
5711: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5715: LD_INT 4
5717: PPUSH
5718: LD_INT 1
5720: PPUSH
5721: CALL 45369 0 2
5725: PUSH
5726: LD_INT 6
5728: GREATEREQUAL
5729: IFFALSE 5708
// wait ( 0 0$30 ) ;
5731: LD_INT 1050
5733: PPUSH
5734: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5738: LD_ADDR_VAR 0 2
5742: PUSH
5743: LD_INT 4
5745: PPUSH
5746: LD_INT 1
5748: PPUSH
5749: CALL 45369 0 2
5753: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5754: LD_ADDR_EXP 95
5758: PUSH
5759: LD_EXP 95
5763: PPUSH
5764: LD_INT 4
5766: PPUSH
5767: LD_EXP 95
5771: PUSH
5772: LD_INT 4
5774: ARRAY
5775: PUSH
5776: LD_VAR 0 2
5780: DIFF
5781: PPUSH
5782: CALL_OW 1
5786: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5787: LD_ADDR_VAR 0 3
5791: PUSH
5792: LD_INT 0
5794: PPUSH
5795: LD_INT 2
5797: PPUSH
5798: CALL_OW 12
5802: ST_TO_ADDR
// if target then
5803: LD_VAR 0 3
5807: IFFALSE 5935
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5809: LD_ADDR_VAR 0 2
5813: PUSH
5814: LD_VAR 0 2
5818: PPUSH
5819: LD_INT 24
5821: PUSH
5822: LD_INT 250
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: PPUSH
5829: CALL_OW 72
5833: ST_TO_ADDR
// for i in tmp do
5834: LD_ADDR_VAR 0 1
5838: PUSH
5839: LD_VAR 0 2
5843: PUSH
5844: FOR_IN
5845: IFFALSE 5885
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5847: LD_VAR 0 1
5851: PPUSH
5852: LD_INT 114
5854: PPUSH
5855: LD_INT 108
5857: PPUSH
5858: CALL_OW 297
5862: PUSH
5863: LD_INT 9
5865: GREATER
5866: IFFALSE 5883
// ComMoveXY ( i , 114 , 108 ) ;
5868: LD_VAR 0 1
5872: PPUSH
5873: LD_INT 114
5875: PPUSH
5876: LD_INT 108
5878: PPUSH
5879: CALL_OW 111
5883: GO 5844
5885: POP
5886: POP
// wait ( 0 0$1 ) ;
5887: LD_INT 35
5889: PPUSH
5890: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5894: LD_VAR 0 2
5898: PPUSH
5899: LD_INT 92
5901: PUSH
5902: LD_INT 114
5904: PUSH
5905: LD_INT 108
5907: PUSH
5908: LD_INT 9
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PPUSH
5917: CALL_OW 72
5921: PUSH
5922: LD_VAR 0 2
5926: PUSH
5927: LD_INT 1
5929: MINUS
5930: GREATEREQUAL
5931: IFFALSE 5809
// end else
5933: GO 6059
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5935: LD_ADDR_VAR 0 2
5939: PUSH
5940: LD_VAR 0 2
5944: PPUSH
5945: LD_INT 24
5947: PUSH
5948: LD_INT 250
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PPUSH
5955: CALL_OW 72
5959: ST_TO_ADDR
// for i in tmp do
5960: LD_ADDR_VAR 0 1
5964: PUSH
5965: LD_VAR 0 2
5969: PUSH
5970: FOR_IN
5971: IFFALSE 6011
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5973: LD_VAR 0 1
5977: PPUSH
5978: LD_INT 129
5980: PPUSH
5981: LD_INT 139
5983: PPUSH
5984: CALL_OW 297
5988: PUSH
5989: LD_INT 9
5991: GREATER
5992: IFFALSE 6009
// ComMoveXY ( i , 129 , 139 ) ;
5994: LD_VAR 0 1
5998: PPUSH
5999: LD_INT 129
6001: PPUSH
6002: LD_INT 139
6004: PPUSH
6005: CALL_OW 111
6009: GO 5970
6011: POP
6012: POP
// wait ( 0 0$1 ) ;
6013: LD_INT 35
6015: PPUSH
6016: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6020: LD_VAR 0 2
6024: PPUSH
6025: LD_INT 92
6027: PUSH
6028: LD_INT 129
6030: PUSH
6031: LD_INT 139
6033: PUSH
6034: LD_INT 9
6036: PUSH
6037: EMPTY
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: PPUSH
6043: CALL_OW 72
6047: PUSH
6048: LD_VAR 0 2
6052: PUSH
6053: LD_INT 1
6055: MINUS
6056: GREATEREQUAL
6057: IFFALSE 5935
// end ; repeat wait ( 0 0$1 ) ;
6059: LD_INT 35
6061: PPUSH
6062: CALL_OW 67
// for i in tmp do
6066: LD_ADDR_VAR 0 1
6070: PUSH
6071: LD_VAR 0 2
6075: PUSH
6076: FOR_IN
6077: IFFALSE 6159
// begin if GetLives ( i ) > 251 then
6079: LD_VAR 0 1
6083: PPUSH
6084: CALL_OW 256
6088: PUSH
6089: LD_INT 251
6091: GREATER
6092: IFFALSE 6130
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6094: LD_VAR 0 1
6098: PPUSH
6099: LD_INT 81
6101: PUSH
6102: LD_INT 1
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PPUSH
6109: CALL_OW 69
6113: PPUSH
6114: LD_VAR 0 1
6118: PPUSH
6119: CALL_OW 74
6123: PPUSH
6124: CALL_OW 115
6128: GO 6157
// if IsDead ( i ) then
6130: LD_VAR 0 1
6134: PPUSH
6135: CALL_OW 301
6139: IFFALSE 6157
// tmp := tmp diff i ;
6141: LD_ADDR_VAR 0 2
6145: PUSH
6146: LD_VAR 0 2
6150: PUSH
6151: LD_VAR 0 1
6155: DIFF
6156: ST_TO_ADDR
// end ;
6157: GO 6076
6159: POP
6160: POP
// until not tmp ;
6161: LD_VAR 0 2
6165: NOT
6166: IFFALSE 6059
// end ;
6168: PPOPN 3
6170: END
// every 30 30$00 trigger not americanDestroyed do
6171: LD_EXP 4
6175: NOT
6176: IFFALSE 6241
6178: GO 6180
6180: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6181: LD_INT 63000
6183: PUSH
6184: LD_INT 42000
6186: PUSH
6187: LD_INT 21000
6189: PUSH
6190: EMPTY
6191: LIST
6192: LIST
6193: LIST
6194: PUSH
6195: LD_OWVAR 67
6199: ARRAY
6200: PPUSH
6201: CALL_OW 67
// if americanDestroyed then
6205: LD_EXP 4
6209: IFFALSE 6213
// exit ;
6211: GO 6241
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6213: LD_INT 4
6215: PPUSH
6216: LD_INT 5
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: LD_INT 1
6224: PUSH
6225: LD_INT 8
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: EMPTY
6235: LIST
6236: PPUSH
6237: CALL 43951 0 2
// end ; end_of_file
6241: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6242: LD_INT 0
6244: PPUSH
6245: PPUSH
6246: PPUSH
6247: PPUSH
6248: PPUSH
// side := 2 ;
6249: LD_ADDR_VAR 0 5
6253: PUSH
6254: LD_INT 2
6256: ST_TO_ADDR
// InitHc ;
6257: CALL_OW 19
// uc_side := side ;
6261: LD_ADDR_OWVAR 20
6265: PUSH
6266: LD_VAR 0 5
6270: ST_TO_ADDR
// uc_nation := 2 ;
6271: LD_ADDR_OWVAR 21
6275: PUSH
6276: LD_INT 2
6278: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6279: LD_ADDR_VAR 0 4
6283: PUSH
6284: LD_INT 22
6286: PUSH
6287: LD_VAR 0 5
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PUSH
6296: LD_INT 30
6298: PUSH
6299: LD_INT 32
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: PUSH
6306: LD_INT 58
6308: PUSH
6309: EMPTY
6310: LIST
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: PPUSH
6317: CALL_OW 69
6321: ST_TO_ADDR
// for i = 1 to 10 do
6322: LD_ADDR_VAR 0 2
6326: PUSH
6327: DOUBLE
6328: LD_INT 1
6330: DEC
6331: ST_TO_ADDR
6332: LD_INT 10
6334: PUSH
6335: FOR_TO
6336: IFFALSE 6408
// begin uc_nation := nation_nature ;
6338: LD_ADDR_OWVAR 21
6342: PUSH
6343: LD_INT 0
6345: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6346: LD_ADDR_OWVAR 28
6350: PUSH
6351: LD_INT 15
6353: ST_TO_ADDR
// hc_gallery :=  ;
6354: LD_ADDR_OWVAR 33
6358: PUSH
6359: LD_STRING 
6361: ST_TO_ADDR
// hc_name :=  ;
6362: LD_ADDR_OWVAR 26
6366: PUSH
6367: LD_STRING 
6369: ST_TO_ADDR
// un := CreateHuman ;
6370: LD_ADDR_VAR 0 3
6374: PUSH
6375: CALL_OW 44
6379: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6380: LD_VAR 0 3
6384: PPUSH
6385: LD_VAR 0 4
6389: PUSH
6390: LD_VAR 0 4
6394: PUSH
6395: LD_VAR 0 2
6399: MINUS
6400: ARRAY
6401: PPUSH
6402: CALL_OW 52
// end ;
6406: GO 6335
6408: POP
6409: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6410: LD_INT 503
6412: PPUSH
6413: LD_INT 27
6415: PPUSH
6416: LD_STRING 
6418: PPUSH
6419: LD_INT 8
6421: PUSH
6422: LD_INT 9
6424: PUSH
6425: LD_INT 10
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: LIST
6432: PUSH
6433: LD_OWVAR 67
6437: ARRAY
6438: PPUSH
6439: LD_INT 3000
6441: PUSH
6442: LD_INT 500
6444: PUSH
6445: LD_INT 150
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: PPUSH
6453: LD_INT 16
6455: PUSH
6456: LD_INT 6
6458: PUSH
6459: LD_INT 6
6461: PUSH
6462: LD_INT 6
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: PPUSH
6471: CALL 60819 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6475: LD_ADDR_EXP 76
6479: PUSH
6480: LD_EXP 76
6484: PPUSH
6485: LD_INT 1
6487: PPUSH
6488: LD_INT 22
6490: PUSH
6491: LD_VAR 0 5
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 23
6502: PUSH
6503: LD_INT 2
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 3
6512: PUSH
6513: LD_INT 21
6515: PUSH
6516: LD_INT 2
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: PUSH
6523: EMPTY
6524: LIST
6525: LIST
6526: PUSH
6527: EMPTY
6528: LIST
6529: LIST
6530: LIST
6531: PPUSH
6532: CALL_OW 69
6536: PPUSH
6537: CALL_OW 1
6541: ST_TO_ADDR
// end ;
6542: LD_VAR 0 1
6546: RET
// export Omar ; export function PrepareOmarAli ; begin
6547: LD_INT 0
6549: PPUSH
// uc_side := 5 ;
6550: LD_ADDR_OWVAR 20
6554: PUSH
6555: LD_INT 5
6557: ST_TO_ADDR
// uc_nation := 2 ;
6558: LD_ADDR_OWVAR 21
6562: PUSH
6563: LD_INT 2
6565: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6566: LD_ADDR_EXP 50
6570: PUSH
6571: LD_STRING Omar
6573: PPUSH
6574: CALL_OW 25
6578: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6579: LD_EXP 50
6583: PPUSH
6584: LD_INT 330
6586: PPUSH
6587: LD_INT 244
6589: PPUSH
6590: LD_INT 0
6592: PPUSH
6593: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6597: LD_EXP 50
6601: PPUSH
6602: LD_INT 22
6604: PUSH
6605: LD_INT 7
6607: PUSH
6608: EMPTY
6609: LIST
6610: LIST
6611: PPUSH
6612: CALL_OW 69
6616: PPUSH
6617: LD_EXP 50
6621: PPUSH
6622: CALL_OW 74
6626: PPUSH
6627: CALL_OW 112
// end ; end_of_file
6631: LD_VAR 0 1
6635: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6636: LD_INT 0
6638: PPUSH
6639: PPUSH
6640: PPUSH
6641: PPUSH
6642: PPUSH
// side := 8 ;
6643: LD_ADDR_VAR 0 3
6647: PUSH
6648: LD_INT 8
6650: ST_TO_ADDR
// InitHc ;
6651: CALL_OW 19
// uc_side := side ;
6655: LD_ADDR_OWVAR 20
6659: PUSH
6660: LD_VAR 0 3
6664: ST_TO_ADDR
// uc_nation := 2 ;
6665: LD_ADDR_OWVAR 21
6669: PUSH
6670: LD_INT 2
6672: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6673: LD_ADDR_VAR 0 2
6677: PUSH
6678: LD_INT 22
6680: PUSH
6681: LD_VAR 0 3
6685: PUSH
6686: EMPTY
6687: LIST
6688: LIST
6689: PUSH
6690: LD_INT 21
6692: PUSH
6693: LD_INT 3
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PPUSH
6704: CALL_OW 69
6708: PUSH
6709: FOR_IN
6710: IFFALSE 6726
// SetBLevel ( i , 10 ) ;
6712: LD_VAR 0 2
6716: PPUSH
6717: LD_INT 10
6719: PPUSH
6720: CALL_OW 241
6724: GO 6709
6726: POP
6727: POP
// Schulz := NewCharacter ( Schulz ) ;
6728: LD_ADDR_EXP 51
6732: PUSH
6733: LD_STRING Schulz
6735: PPUSH
6736: CALL_OW 25
6740: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6741: LD_ADDR_EXP 52
6745: PUSH
6746: LD_STRING Kozlov
6748: PPUSH
6749: LD_INT 0
6751: PPUSH
6752: LD_STRING 
6754: PPUSH
6755: CALL 50295 0 3
6759: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6760: LD_EXP 52
6764: PPUSH
6765: LD_INT 22
6767: PUSH
6768: LD_INT 8
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: PUSH
6775: LD_INT 23
6777: PUSH
6778: LD_INT 3
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: PUSH
6785: LD_INT 30
6787: PUSH
6788: LD_INT 8
6790: PUSH
6791: EMPTY
6792: LIST
6793: LIST
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PUSH
6805: LD_INT 1
6807: ARRAY
6808: PPUSH
6809: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6813: LD_EXP 52
6817: PPUSH
6818: LD_INT 3
6820: PPUSH
6821: LD_INT 10
6823: PPUSH
6824: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6828: LD_ADDR_VAR 0 5
6832: PUSH
6833: LD_INT 22
6835: PUSH
6836: LD_VAR 0 3
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: PUSH
6845: LD_INT 30
6847: PUSH
6848: LD_INT 32
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PUSH
6855: LD_INT 58
6857: PUSH
6858: EMPTY
6859: LIST
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: LIST
6865: PPUSH
6866: CALL_OW 69
6870: ST_TO_ADDR
// for i = 1 to 10 do
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: DOUBLE
6877: LD_INT 1
6879: DEC
6880: ST_TO_ADDR
6881: LD_INT 10
6883: PUSH
6884: FOR_TO
6885: IFFALSE 6957
// begin uc_nation := nation_nature ;
6887: LD_ADDR_OWVAR 21
6891: PUSH
6892: LD_INT 0
6894: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6895: LD_ADDR_OWVAR 28
6899: PUSH
6900: LD_INT 15
6902: ST_TO_ADDR
// hc_gallery :=  ;
6903: LD_ADDR_OWVAR 33
6907: PUSH
6908: LD_STRING 
6910: ST_TO_ADDR
// hc_name :=  ;
6911: LD_ADDR_OWVAR 26
6915: PUSH
6916: LD_STRING 
6918: ST_TO_ADDR
// un := CreateHuman ;
6919: LD_ADDR_VAR 0 4
6923: PUSH
6924: CALL_OW 44
6928: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6929: LD_VAR 0 4
6933: PPUSH
6934: LD_VAR 0 5
6938: PUSH
6939: LD_VAR 0 5
6943: PUSH
6944: LD_VAR 0 2
6948: MINUS
6949: ARRAY
6950: PPUSH
6951: CALL_OW 52
// end ;
6955: GO 6884
6957: POP
6958: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6959: LD_INT 324
6961: PPUSH
6962: LD_INT 3
6964: PPUSH
6965: LD_STRING 
6967: PPUSH
6968: LD_INT 8
6970: PUSH
6971: LD_INT 9
6973: PUSH
6974: LD_INT 10
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: LIST
6981: PUSH
6982: LD_OWVAR 67
6986: ARRAY
6987: PPUSH
6988: LD_INT 3000
6990: PUSH
6991: LD_INT 500
6993: PUSH
6994: LD_INT 150
6996: PUSH
6997: EMPTY
6998: LIST
6999: LIST
7000: LIST
7001: PPUSH
7002: LD_INT 16
7004: PUSH
7005: LD_INT 6
7007: PUSH
7008: LD_INT 6
7010: PUSH
7011: LD_INT 8
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: LIST
7018: LIST
7019: PPUSH
7020: CALL 60819 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7024: LD_ADDR_EXP 76
7028: PUSH
7029: LD_EXP 76
7033: PPUSH
7034: LD_INT 3
7036: PPUSH
7037: LD_INT 22
7039: PUSH
7040: LD_VAR 0 3
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PUSH
7049: LD_INT 23
7051: PUSH
7052: LD_INT 2
7054: PUSH
7055: EMPTY
7056: LIST
7057: LIST
7058: PUSH
7059: LD_INT 3
7061: PUSH
7062: LD_INT 21
7064: PUSH
7065: LD_INT 2
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: LIST
7080: PPUSH
7081: CALL_OW 69
7085: PUSH
7086: LD_EXP 51
7090: DIFF
7091: PPUSH
7092: CALL_OW 1
7096: ST_TO_ADDR
// end ;
7097: LD_VAR 0 1
7101: RET
// export function BuildKozlovBomb ; begin
7102: LD_INT 0
7104: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7105: LD_INT 332
7107: PPUSH
7108: CALL_OW 302
7112: NOT
7113: PUSH
7114: LD_INT 336
7116: PPUSH
7117: CALL_OW 302
7121: NOT
7122: OR
7123: IFFALSE 7127
// exit ;
7125: GO 7224
// ComChangeProfession ( Kozlov , 4 ) ;
7127: LD_EXP 52
7131: PPUSH
7132: LD_INT 4
7134: PPUSH
7135: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7139: LD_INT 336
7141: PPUSH
7142: LD_INT 25
7144: PPUSH
7145: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7149: LD_INT 35
7151: PPUSH
7152: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7156: LD_INT 25
7158: PPUSH
7159: LD_INT 8
7161: PPUSH
7162: CALL_OW 321
7166: PUSH
7167: LD_INT 2
7169: EQUAL
7170: IFFALSE 7149
// ComExitBuilding ( Kozlov ) ;
7172: LD_EXP 52
7176: PPUSH
7177: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7181: LD_EXP 52
7185: PPUSH
7186: LD_INT 332
7188: PPUSH
7189: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7193: LD_EXP 52
7197: PPUSH
7198: LD_INT 3
7200: PPUSH
7201: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7205: LD_INT 332
7207: PPUSH
7208: LD_INT 23
7210: PPUSH
7211: LD_INT 3
7213: PPUSH
7214: LD_INT 1
7216: PPUSH
7217: LD_INT 48
7219: PPUSH
7220: CALL_OW 125
// end ;
7224: LD_VAR 0 1
7228: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7229: LD_EXP 3
7233: NOT
7234: PUSH
7235: LD_INT 3
7237: PPUSH
7238: LD_INT 1
7240: PPUSH
7241: CALL 45369 0 2
7245: NOT
7246: AND
7247: IFFALSE 8087
7249: GO 7251
7251: DISABLE
7252: LD_INT 0
7254: PPUSH
7255: PPUSH
7256: PPUSH
// begin enable ;
7257: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7258: LD_INT 22
7260: PUSH
7261: LD_INT 8
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: PUSH
7268: LD_INT 23
7270: PUSH
7271: LD_INT 2
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 30
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: EMPTY
7285: LIST
7286: LIST
7287: PUSH
7288: EMPTY
7289: LIST
7290: LIST
7291: LIST
7292: PPUSH
7293: CALL_OW 69
7297: NOT
7298: IFFALSE 7302
// exit ;
7300: GO 8087
// if Prob ( 40 ) then
7302: LD_INT 40
7304: PPUSH
7305: CALL_OW 13
7309: IFFALSE 7436
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7311: LD_INT 3
7313: PPUSH
7314: LD_INT 14
7316: PUSH
7317: LD_INT 1
7319: PUSH
7320: LD_INT 2
7322: PUSH
7323: LD_INT 28
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: LIST
7330: LIST
7331: PUSH
7332: LD_INT 14
7334: PUSH
7335: LD_INT 1
7337: PUSH
7338: LD_INT 2
7340: PUSH
7341: LD_INT 28
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: LIST
7348: LIST
7349: PUSH
7350: LD_INT 14
7352: PUSH
7353: LD_INT 1
7355: PUSH
7356: LD_INT 2
7358: PUSH
7359: LD_INT 28
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: LIST
7367: PUSH
7368: LD_INT 14
7370: PUSH
7371: LD_INT 1
7373: PUSH
7374: LD_INT 2
7376: PUSH
7377: LD_INT 28
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: PUSH
7386: LD_INT 14
7388: PUSH
7389: LD_INT 1
7391: PUSH
7392: LD_INT 2
7394: PUSH
7395: LD_INT 28
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: PUSH
7404: LD_INT 14
7406: PUSH
7407: LD_INT 1
7409: PUSH
7410: LD_INT 2
7412: PUSH
7413: LD_INT 26
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: LIST
7420: LIST
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: PPUSH
7430: CALL 43951 0 2
// end else
7434: GO 7627
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7436: LD_INT 3
7438: PPUSH
7439: LD_INT 14
7441: PUSH
7442: LD_INT 1
7444: PUSH
7445: LD_INT 2
7447: PUSH
7448: LD_INT 27
7450: PUSH
7451: LD_INT 26
7453: PUSH
7454: LD_INT 26
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: LIST
7461: PUSH
7462: LD_OWVAR 67
7466: ARRAY
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: LD_INT 14
7476: PUSH
7477: LD_INT 1
7479: PUSH
7480: LD_INT 2
7482: PUSH
7483: LD_INT 27
7485: PUSH
7486: LD_INT 26
7488: PUSH
7489: LD_INT 26
7491: PUSH
7492: EMPTY
7493: LIST
7494: LIST
7495: LIST
7496: PUSH
7497: LD_OWVAR 67
7501: ARRAY
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 14
7511: PUSH
7512: LD_INT 1
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: LD_INT 26
7520: PUSH
7521: LD_INT 26
7523: PUSH
7524: LD_INT 29
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: LIST
7531: PUSH
7532: LD_OWVAR 67
7536: ARRAY
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: LIST
7542: LIST
7543: PUSH
7544: LD_INT 13
7546: PUSH
7547: LD_INT 1
7549: PUSH
7550: LD_INT 2
7552: PUSH
7553: LD_INT 26
7555: PUSH
7556: LD_INT 29
7558: PUSH
7559: LD_INT 29
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: LIST
7566: PUSH
7567: LD_OWVAR 67
7571: ARRAY
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: LIST
7577: LIST
7578: PUSH
7579: LD_INT 13
7581: PUSH
7582: LD_INT 1
7584: PUSH
7585: LD_INT 2
7587: PUSH
7588: LD_INT 29
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: PUSH
7597: LD_INT 14
7599: PUSH
7600: LD_INT 1
7602: PUSH
7603: LD_INT 2
7605: PUSH
7606: LD_INT 26
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: PPUSH
7623: CALL 43951 0 2
// end ; repeat wait ( 0 0$1 ) ;
7627: LD_INT 35
7629: PPUSH
7630: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7634: LD_INT 3
7636: PPUSH
7637: LD_INT 1
7639: PPUSH
7640: CALL 45369 0 2
7644: PUSH
7645: LD_INT 6
7647: GREATEREQUAL
7648: IFFALSE 7627
// wait ( 0 0$30 ) ;
7650: LD_INT 1050
7652: PPUSH
7653: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7657: LD_ADDR_VAR 0 2
7661: PUSH
7662: LD_INT 3
7664: PPUSH
7665: LD_INT 1
7667: PPUSH
7668: CALL 45369 0 2
7672: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7673: LD_ADDR_EXP 95
7677: PUSH
7678: LD_EXP 95
7682: PPUSH
7683: LD_INT 3
7685: PPUSH
7686: LD_EXP 95
7690: PUSH
7691: LD_INT 3
7693: ARRAY
7694: PUSH
7695: LD_VAR 0 2
7699: DIFF
7700: PPUSH
7701: CALL_OW 1
7705: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7706: LD_ADDR_VAR 0 3
7710: PUSH
7711: LD_INT 0
7713: PPUSH
7714: LD_INT 2
7716: PPUSH
7717: CALL_OW 12
7721: ST_TO_ADDR
// if target then
7722: LD_VAR 0 3
7726: IFFALSE 7854
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7728: LD_ADDR_VAR 0 2
7732: PUSH
7733: LD_VAR 0 2
7737: PPUSH
7738: LD_INT 24
7740: PUSH
7741: LD_INT 250
7743: PUSH
7744: EMPTY
7745: LIST
7746: LIST
7747: PPUSH
7748: CALL_OW 72
7752: ST_TO_ADDR
// for i in tmp do
7753: LD_ADDR_VAR 0 1
7757: PUSH
7758: LD_VAR 0 2
7762: PUSH
7763: FOR_IN
7764: IFFALSE 7804
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7766: LD_VAR 0 1
7770: PPUSH
7771: LD_INT 89
7773: PPUSH
7774: LD_INT 71
7776: PPUSH
7777: CALL_OW 297
7781: PUSH
7782: LD_INT 9
7784: GREATER
7785: IFFALSE 7802
// ComMoveXY ( i , 89 , 71 ) ;
7787: LD_VAR 0 1
7791: PPUSH
7792: LD_INT 89
7794: PPUSH
7795: LD_INT 71
7797: PPUSH
7798: CALL_OW 111
7802: GO 7763
7804: POP
7805: POP
// wait ( 0 0$1 ) ;
7806: LD_INT 35
7808: PPUSH
7809: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7813: LD_VAR 0 2
7817: PPUSH
7818: LD_INT 92
7820: PUSH
7821: LD_INT 89
7823: PUSH
7824: LD_INT 71
7826: PUSH
7827: LD_INT 9
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: PPUSH
7836: CALL_OW 72
7840: PUSH
7841: LD_VAR 0 2
7845: PUSH
7846: LD_INT 1
7848: MINUS
7849: GREATEREQUAL
7850: IFFALSE 7728
// end else
7852: GO 7978
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7854: LD_ADDR_VAR 0 2
7858: PUSH
7859: LD_VAR 0 2
7863: PPUSH
7864: LD_INT 24
7866: PUSH
7867: LD_INT 250
7869: PUSH
7870: EMPTY
7871: LIST
7872: LIST
7873: PPUSH
7874: CALL_OW 72
7878: ST_TO_ADDR
// for i in tmp do
7879: LD_ADDR_VAR 0 1
7883: PUSH
7884: LD_VAR 0 2
7888: PUSH
7889: FOR_IN
7890: IFFALSE 7930
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7892: LD_VAR 0 1
7896: PPUSH
7897: LD_INT 147
7899: PPUSH
7900: LD_INT 4
7902: PPUSH
7903: CALL_OW 297
7907: PUSH
7908: LD_INT 9
7910: GREATER
7911: IFFALSE 7928
// ComMoveXY ( i , 147 , 4 ) ;
7913: LD_VAR 0 1
7917: PPUSH
7918: LD_INT 147
7920: PPUSH
7921: LD_INT 4
7923: PPUSH
7924: CALL_OW 111
7928: GO 7889
7930: POP
7931: POP
// wait ( 0 0$1 ) ;
7932: LD_INT 35
7934: PPUSH
7935: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7939: LD_VAR 0 2
7943: PPUSH
7944: LD_INT 92
7946: PUSH
7947: LD_INT 147
7949: PUSH
7950: LD_INT 4
7952: PUSH
7953: LD_INT 9
7955: PUSH
7956: EMPTY
7957: LIST
7958: LIST
7959: LIST
7960: LIST
7961: PPUSH
7962: CALL_OW 72
7966: PUSH
7967: LD_VAR 0 2
7971: PUSH
7972: LD_INT 1
7974: MINUS
7975: GREATEREQUAL
7976: IFFALSE 7854
// end ; repeat wait ( 0 0$1 ) ;
7978: LD_INT 35
7980: PPUSH
7981: CALL_OW 67
// for i in tmp do
7985: LD_ADDR_VAR 0 1
7989: PUSH
7990: LD_VAR 0 2
7994: PUSH
7995: FOR_IN
7996: IFFALSE 8078
// begin if GetLives ( i ) > 251 then
7998: LD_VAR 0 1
8002: PPUSH
8003: CALL_OW 256
8007: PUSH
8008: LD_INT 251
8010: GREATER
8011: IFFALSE 8049
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8013: LD_VAR 0 1
8017: PPUSH
8018: LD_INT 81
8020: PUSH
8021: LD_INT 8
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PPUSH
8028: CALL_OW 69
8032: PPUSH
8033: LD_VAR 0 1
8037: PPUSH
8038: CALL_OW 74
8042: PPUSH
8043: CALL_OW 115
8047: GO 8076
// if IsDead ( i ) then
8049: LD_VAR 0 1
8053: PPUSH
8054: CALL_OW 301
8058: IFFALSE 8076
// tmp := tmp diff i ;
8060: LD_ADDR_VAR 0 2
8064: PUSH
8065: LD_VAR 0 2
8069: PUSH
8070: LD_VAR 0 1
8074: DIFF
8075: ST_TO_ADDR
// end ;
8076: GO 7995
8078: POP
8079: POP
// until not tmp ;
8080: LD_VAR 0 2
8084: NOT
8085: IFFALSE 7978
// end ;
8087: PPOPN 3
8089: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8090: LD_EXP 52
8094: PPUSH
8095: CALL_OW 302
8099: PUSH
8100: LD_EXP 3
8104: NOT
8105: AND
8106: IFFALSE 8115
8108: GO 8110
8110: DISABLE
// BuildKozlovBomb ;
8111: CALL 7102 0 0
8115: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8116: LD_INT 22
8118: PUSH
8119: LD_INT 8
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: PUSH
8126: LD_INT 34
8128: PUSH
8129: LD_INT 48
8131: PUSH
8132: EMPTY
8133: LIST
8134: LIST
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: PPUSH
8140: CALL_OW 69
8144: IFFALSE 8192
8146: GO 8148
8148: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8149: LD_INT 22
8151: PUSH
8152: LD_INT 8
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: PUSH
8159: LD_INT 34
8161: PUSH
8162: LD_INT 48
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PPUSH
8173: CALL_OW 69
8177: PUSH
8178: LD_INT 1
8180: ARRAY
8181: PPUSH
8182: LD_INT 173
8184: PPUSH
8185: LD_INT 96
8187: PPUSH
8188: CALL_OW 116
// end ; end_of_file
8192: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8193: LD_INT 0
8195: PPUSH
8196: PPUSH
8197: PPUSH
8198: PPUSH
8199: PPUSH
8200: PPUSH
8201: PPUSH
8202: PPUSH
8203: PPUSH
// side := 3 ;
8204: LD_ADDR_VAR 0 6
8208: PUSH
8209: LD_INT 3
8211: ST_TO_ADDR
// InitHc ;
8212: CALL_OW 19
// uc_side := side ;
8216: LD_ADDR_OWVAR 20
8220: PUSH
8221: LD_VAR 0 6
8225: ST_TO_ADDR
// uc_nation := 3 ;
8226: LD_ADDR_OWVAR 21
8230: PUSH
8231: LD_INT 3
8233: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8234: LD_ADDR_VAR 0 2
8238: PUSH
8239: LD_INT 22
8241: PUSH
8242: LD_VAR 0 6
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: LD_INT 21
8253: PUSH
8254: LD_INT 3
8256: PUSH
8257: EMPTY
8258: LIST
8259: LIST
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PPUSH
8265: CALL_OW 69
8269: PUSH
8270: FOR_IN
8271: IFFALSE 8287
// SetBLevel ( i , 10 ) ;
8273: LD_VAR 0 2
8277: PPUSH
8278: LD_INT 10
8280: PPUSH
8281: CALL_OW 241
8285: GO 8270
8287: POP
8288: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8289: LD_ADDR_VAR 0 9
8293: PUSH
8294: LD_INT 22
8296: PUSH
8297: LD_VAR 0 6
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: PUSH
8306: LD_INT 30
8308: PUSH
8309: LD_INT 34
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: PPUSH
8320: CALL_OW 69
8324: ST_TO_ADDR
// if teleport then
8325: LD_VAR 0 9
8329: IFFALSE 8350
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8331: LD_VAR 0 9
8335: PUSH
8336: LD_INT 1
8338: ARRAY
8339: PPUSH
8340: LD_INT 123
8342: PPUSH
8343: LD_INT 122
8345: PPUSH
8346: CALL_OW 243
// hc_importance := 0 ;
8350: LD_ADDR_OWVAR 32
8354: PUSH
8355: LD_INT 0
8357: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8358: LD_ADDR_EXP 53
8362: PUSH
8363: LD_STRING Platonov
8365: PPUSH
8366: CALL_OW 25
8370: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8371: LD_ADDR_EXP 54
8375: PUSH
8376: LD_STRING Yakotich
8378: PPUSH
8379: CALL_OW 25
8383: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8384: LD_ADDR_EXP 55
8388: PUSH
8389: LD_STRING Gleb
8391: PPUSH
8392: CALL_OW 25
8396: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8397: LD_STRING 03_Cornel
8399: PPUSH
8400: CALL_OW 28
8404: IFFALSE 8452
// begin Bierezov := NewCharacter ( Mikhail ) ;
8406: LD_ADDR_EXP 56
8410: PUSH
8411: LD_STRING Mikhail
8413: PPUSH
8414: CALL_OW 25
8418: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8419: LD_EXP 56
8423: PPUSH
8424: LD_INT 197
8426: PPUSH
8427: LD_INT 111
8429: PPUSH
8430: LD_INT 9
8432: PPUSH
8433: LD_INT 0
8435: PPUSH
8436: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8440: LD_EXP 56
8444: PPUSH
8445: LD_INT 3
8447: PPUSH
8448: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8452: LD_EXP 53
8456: PPUSH
8457: LD_INT 126
8459: PPUSH
8460: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8464: LD_EXP 54
8468: PPUSH
8469: LD_INT 197
8471: PPUSH
8472: LD_INT 111
8474: PPUSH
8475: LD_INT 9
8477: PPUSH
8478: LD_INT 0
8480: PPUSH
8481: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8485: LD_EXP 55
8489: PPUSH
8490: LD_INT 197
8492: PPUSH
8493: LD_INT 111
8495: PPUSH
8496: LD_INT 9
8498: PPUSH
8499: LD_INT 0
8501: PPUSH
8502: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8506: LD_ADDR_VAR 0 5
8510: PUSH
8511: LD_INT 126
8513: PPUSH
8514: LD_INT 2
8516: PPUSH
8517: LD_STRING zhukov
8519: PPUSH
8520: LD_INT 9
8522: PUSH
8523: LD_INT 10
8525: PUSH
8526: LD_INT 10
8528: PUSH
8529: EMPTY
8530: LIST
8531: LIST
8532: LIST
8533: PUSH
8534: LD_OWVAR 67
8538: ARRAY
8539: PPUSH
8540: LD_INT 90000
8542: PUSH
8543: LD_INT 1000
8545: PUSH
8546: LD_INT 300
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: LIST
8553: PPUSH
8554: LD_INT 21
8556: PUSH
8557: LD_INT 8
8559: PUSH
8560: LD_INT 13
8562: PUSH
8563: LD_INT 8
8565: PUSH
8566: EMPTY
8567: LIST
8568: LIST
8569: LIST
8570: LIST
8571: PPUSH
8572: CALL 60819 0 6
8576: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8577: LD_ADDR_VAR 0 4
8581: PUSH
8582: LD_INT 267
8584: PPUSH
8585: CALL_OW 274
8589: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8590: LD_VAR 0 4
8594: PPUSH
8595: LD_INT 1
8597: PPUSH
8598: LD_INT 5000
8600: PPUSH
8601: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8605: LD_VAR 0 4
8609: PPUSH
8610: LD_INT 2
8612: PPUSH
8613: LD_INT 200
8615: PPUSH
8616: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8620: LD_VAR 0 4
8624: PPUSH
8625: LD_INT 3
8627: PPUSH
8628: LD_INT 200
8630: PPUSH
8631: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8635: LD_ADDR_EXP 76
8639: PUSH
8640: LD_EXP 76
8644: PPUSH
8645: LD_INT 2
8647: PPUSH
8648: LD_VAR 0 5
8652: PUSH
8653: LD_INT 22
8655: PUSH
8656: LD_VAR 0 6
8660: PUSH
8661: EMPTY
8662: LIST
8663: LIST
8664: PUSH
8665: LD_INT 3
8667: PUSH
8668: LD_INT 21
8670: PUSH
8671: LD_INT 2
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: PPUSH
8686: CALL_OW 69
8690: UNION
8691: PUSH
8692: LD_EXP 53
8696: DIFF
8697: PPUSH
8698: CALL_OW 1
8702: ST_TO_ADDR
// behemoths := [ ] ;
8703: LD_ADDR_EXP 57
8707: PUSH
8708: EMPTY
8709: ST_TO_ADDR
// behemothBuilders := [ ] ;
8710: LD_ADDR_EXP 58
8714: PUSH
8715: EMPTY
8716: ST_TO_ADDR
// j := 3 ;
8717: LD_ADDR_VAR 0 3
8721: PUSH
8722: LD_INT 3
8724: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8725: LD_ADDR_VAR 0 2
8729: PUSH
8730: LD_INT 22
8732: PUSH
8733: LD_INT 3
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: PUSH
8740: LD_INT 25
8742: PUSH
8743: LD_INT 3
8745: PUSH
8746: EMPTY
8747: LIST
8748: LIST
8749: PUSH
8750: EMPTY
8751: LIST
8752: LIST
8753: PPUSH
8754: CALL_OW 69
8758: PUSH
8759: FOR_IN
8760: IFFALSE 8810
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8762: LD_ADDR_EXP 58
8766: PUSH
8767: LD_EXP 58
8771: PPUSH
8772: LD_VAR 0 2
8776: PPUSH
8777: CALL 93181 0 2
8781: ST_TO_ADDR
// j := j - 1 ;
8782: LD_ADDR_VAR 0 3
8786: PUSH
8787: LD_VAR 0 3
8791: PUSH
8792: LD_INT 1
8794: MINUS
8795: ST_TO_ADDR
// if j = 0 then
8796: LD_VAR 0 3
8800: PUSH
8801: LD_INT 0
8803: EQUAL
8804: IFFALSE 8808
// break ;
8806: GO 8810
// end ;
8808: GO 8759
8810: POP
8811: POP
// end ;
8812: LD_VAR 0 1
8816: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8817: LD_INT 0
8819: PPUSH
8820: PPUSH
8821: PPUSH
8822: PPUSH
8823: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8824: LD_ADDR_VAR 0 4
8828: PUSH
8829: LD_INT 209
8831: PUSH
8832: LD_INT 149
8834: PUSH
8835: EMPTY
8836: LIST
8837: LIST
8838: PUSH
8839: LD_INT 219
8841: PUSH
8842: LD_INT 154
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PUSH
8849: LD_INT 223
8851: PUSH
8852: LD_INT 149
8854: PUSH
8855: EMPTY
8856: LIST
8857: LIST
8858: PUSH
8859: LD_INT 232
8861: PUSH
8862: LD_INT 155
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: LIST
8873: LIST
8874: ST_TO_ADDR
// if not behemothBuilders then
8875: LD_EXP 58
8879: NOT
8880: IFFALSE 8884
// exit ;
8882: GO 8988
// j := 1 ;
8884: LD_ADDR_VAR 0 3
8888: PUSH
8889: LD_INT 1
8891: ST_TO_ADDR
// for i in behemothBuilders do
8892: LD_ADDR_VAR 0 2
8896: PUSH
8897: LD_EXP 58
8901: PUSH
8902: FOR_IN
8903: IFFALSE 8986
// begin if IsInUnit ( i ) then
8905: LD_VAR 0 2
8909: PPUSH
8910: CALL_OW 310
8914: IFFALSE 8925
// ComExitBuilding ( i ) ;
8916: LD_VAR 0 2
8920: PPUSH
8921: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8925: LD_VAR 0 2
8929: PPUSH
8930: LD_INT 37
8932: PPUSH
8933: LD_VAR 0 4
8937: PUSH
8938: LD_VAR 0 3
8942: ARRAY
8943: PUSH
8944: LD_INT 1
8946: ARRAY
8947: PPUSH
8948: LD_VAR 0 4
8952: PUSH
8953: LD_VAR 0 3
8957: ARRAY
8958: PUSH
8959: LD_INT 2
8961: ARRAY
8962: PPUSH
8963: LD_INT 0
8965: PPUSH
8966: CALL_OW 230
// j := j + 1 ;
8970: LD_ADDR_VAR 0 3
8974: PUSH
8975: LD_VAR 0 3
8979: PUSH
8980: LD_INT 1
8982: PLUS
8983: ST_TO_ADDR
// end ;
8984: GO 8902
8986: POP
8987: POP
// end ;
8988: LD_VAR 0 1
8992: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8993: LD_INT 3
8995: PPUSH
8996: CALL 93229 0 1
9000: PUSH
9001: LD_INT 22
9003: PUSH
9004: LD_INT 3
9006: PUSH
9007: EMPTY
9008: LIST
9009: LIST
9010: PUSH
9011: LD_INT 30
9013: PUSH
9014: LD_INT 37
9016: PUSH
9017: EMPTY
9018: LIST
9019: LIST
9020: PUSH
9021: EMPTY
9022: LIST
9023: LIST
9024: PPUSH
9025: CALL_OW 69
9029: NOT
9030: AND
9031: IFFALSE 9217
9033: GO 9035
9035: DISABLE
9036: LD_INT 0
9038: PPUSH
9039: PPUSH
// begin enable ;
9040: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9041: LD_ADDR_VAR 0 2
9045: PUSH
9046: LD_INT 3
9048: PPUSH
9049: CALL 93229 0 1
9053: ST_TO_ADDR
// for i in tmp do
9054: LD_ADDR_VAR 0 1
9058: PUSH
9059: LD_VAR 0 2
9063: PUSH
9064: FOR_IN
9065: IFFALSE 9215
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9067: LD_VAR 0 1
9071: PPUSH
9072: LD_INT 7
9074: PPUSH
9075: CALL_OW 308
9079: PUSH
9080: LD_VAR 0 1
9084: PPUSH
9085: CALL_OW 110
9089: PUSH
9090: LD_INT 2
9092: EQUAL
9093: NOT
9094: AND
9095: IFFALSE 9109
// SetTag ( i , 2 ) ;
9097: LD_VAR 0 1
9101: PPUSH
9102: LD_INT 2
9104: PPUSH
9105: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9109: LD_INT 81
9111: PUSH
9112: LD_INT 3
9114: PUSH
9115: EMPTY
9116: LIST
9117: LIST
9118: PUSH
9119: LD_INT 91
9121: PUSH
9122: LD_VAR 0 1
9126: PUSH
9127: LD_INT 12
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: LIST
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: PPUSH
9139: CALL_OW 69
9143: NOT
9144: PUSH
9145: LD_VAR 0 1
9149: PPUSH
9150: CALL_OW 110
9154: PUSH
9155: LD_INT 2
9157: EQUAL
9158: NOT
9159: AND
9160: IFFALSE 9179
// ComAgressiveMove ( i , 64 , 93 ) else
9162: LD_VAR 0 1
9166: PPUSH
9167: LD_INT 64
9169: PPUSH
9170: LD_INT 93
9172: PPUSH
9173: CALL_OW 114
9177: GO 9213
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9179: LD_VAR 0 1
9183: PPUSH
9184: LD_INT 81
9186: PUSH
9187: LD_INT 3
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: PPUSH
9194: CALL_OW 69
9198: PPUSH
9199: LD_VAR 0 1
9203: PPUSH
9204: CALL_OW 74
9208: PPUSH
9209: CALL_OW 115
// end ;
9213: GO 9064
9215: POP
9216: POP
// end ;
9217: PPOPN 2
9219: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9220: LD_EXP 2
9224: NOT
9225: PUSH
9226: LD_INT 2
9228: PPUSH
9229: LD_INT 1
9231: PPUSH
9232: CALL 45369 0 2
9236: NOT
9237: AND
9238: IFFALSE 10158
9240: GO 9242
9242: DISABLE
9243: LD_INT 0
9245: PPUSH
9246: PPUSH
9247: PPUSH
9248: PPUSH
// begin enable ;
9249: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9250: LD_INT 22
9252: PUSH
9253: LD_INT 3
9255: PUSH
9256: EMPTY
9257: LIST
9258: LIST
9259: PUSH
9260: LD_INT 30
9262: PUSH
9263: LD_INT 3
9265: PUSH
9266: EMPTY
9267: LIST
9268: LIST
9269: PUSH
9270: EMPTY
9271: LIST
9272: LIST
9273: PPUSH
9274: CALL_OW 69
9278: NOT
9279: IFFALSE 9283
// exit ;
9281: GO 10158
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9283: LD_ADDR_VAR 0 4
9287: PUSH
9288: LD_INT 22
9290: PUSH
9291: LD_INT 3
9293: PUSH
9294: EMPTY
9295: LIST
9296: LIST
9297: PUSH
9298: LD_INT 30
9300: PUSH
9301: LD_INT 34
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: PPUSH
9312: CALL_OW 69
9316: ST_TO_ADDR
// if Prob ( 40 ) then
9317: LD_INT 40
9319: PPUSH
9320: CALL_OW 13
9324: IFFALSE 9451
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9326: LD_INT 2
9328: PPUSH
9329: LD_INT 22
9331: PUSH
9332: LD_INT 3
9334: PUSH
9335: LD_INT 3
9337: PUSH
9338: LD_INT 49
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: PUSH
9347: LD_INT 22
9349: PUSH
9350: LD_INT 3
9352: PUSH
9353: LD_INT 3
9355: PUSH
9356: LD_INT 49
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: LIST
9364: PUSH
9365: LD_INT 22
9367: PUSH
9368: LD_INT 3
9370: PUSH
9371: LD_INT 3
9373: PUSH
9374: LD_INT 49
9376: PUSH
9377: EMPTY
9378: LIST
9379: LIST
9380: LIST
9381: LIST
9382: PUSH
9383: LD_INT 24
9385: PUSH
9386: LD_INT 3
9388: PUSH
9389: LD_INT 3
9391: PUSH
9392: LD_INT 46
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: LIST
9400: PUSH
9401: LD_INT 24
9403: PUSH
9404: LD_INT 3
9406: PUSH
9407: LD_INT 3
9409: PUSH
9410: LD_INT 46
9412: PUSH
9413: EMPTY
9414: LIST
9415: LIST
9416: LIST
9417: LIST
9418: PUSH
9419: LD_INT 24
9421: PUSH
9422: LD_INT 3
9424: PUSH
9425: LD_INT 3
9427: PUSH
9428: LD_INT 46
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: LIST
9435: LIST
9436: PUSH
9437: EMPTY
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: PPUSH
9445: CALL 43951 0 2
// end else
9449: GO 9574
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9451: LD_INT 2
9453: PPUSH
9454: LD_INT 24
9456: PUSH
9457: LD_INT 3
9459: PUSH
9460: LD_INT 3
9462: PUSH
9463: LD_INT 47
9465: PUSH
9466: EMPTY
9467: LIST
9468: LIST
9469: LIST
9470: LIST
9471: PUSH
9472: LD_INT 24
9474: PUSH
9475: LD_INT 3
9477: PUSH
9478: LD_INT 3
9480: PUSH
9481: LD_INT 47
9483: PUSH
9484: EMPTY
9485: LIST
9486: LIST
9487: LIST
9488: LIST
9489: PUSH
9490: LD_INT 24
9492: PUSH
9493: LD_INT 3
9495: PUSH
9496: LD_INT 3
9498: PUSH
9499: LD_INT 47
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: PUSH
9508: LD_INT 24
9510: PUSH
9511: LD_INT 3
9513: PUSH
9514: LD_INT 3
9516: PUSH
9517: LD_INT 46
9519: PUSH
9520: EMPTY
9521: LIST
9522: LIST
9523: LIST
9524: LIST
9525: PUSH
9526: LD_INT 24
9528: PUSH
9529: LD_INT 3
9531: PUSH
9532: LD_INT 3
9534: PUSH
9535: LD_INT 46
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: LIST
9542: LIST
9543: PUSH
9544: LD_INT 24
9546: PUSH
9547: LD_INT 3
9549: PUSH
9550: LD_INT 3
9552: PUSH
9553: LD_INT 46
9555: PUSH
9556: EMPTY
9557: LIST
9558: LIST
9559: LIST
9560: LIST
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: LIST
9568: LIST
9569: PPUSH
9570: CALL 43951 0 2
// end ; if Difficulty > 1 then
9574: LD_OWVAR 67
9578: PUSH
9579: LD_INT 1
9581: GREATER
9582: IFFALSE 9612
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9584: LD_INT 2
9586: PPUSH
9587: LD_INT 24
9589: PUSH
9590: LD_INT 3
9592: PUSH
9593: LD_INT 3
9595: PUSH
9596: LD_INT 47
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: LIST
9603: LIST
9604: PUSH
9605: EMPTY
9606: LIST
9607: PPUSH
9608: CALL 43951 0 2
// repeat wait ( 0 0$1 ) ;
9612: LD_INT 35
9614: PPUSH
9615: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9619: LD_INT 2
9621: PPUSH
9622: LD_INT 1
9624: PPUSH
9625: CALL 45369 0 2
9629: PUSH
9630: LD_INT 6
9632: PUSH
9633: LD_INT 7
9635: PUSH
9636: LD_INT 7
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: PUSH
9644: LD_OWVAR 67
9648: ARRAY
9649: GREATEREQUAL
9650: IFFALSE 9612
// wait ( 0 0$30 ) ;
9652: LD_INT 1050
9654: PPUSH
9655: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9659: LD_ADDR_VAR 0 2
9663: PUSH
9664: LD_INT 2
9666: PPUSH
9667: LD_INT 1
9669: PPUSH
9670: CALL 45369 0 2
9674: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9675: LD_ADDR_EXP 95
9679: PUSH
9680: LD_EXP 95
9684: PPUSH
9685: LD_INT 2
9687: PPUSH
9688: LD_EXP 95
9692: PUSH
9693: LD_INT 2
9695: ARRAY
9696: PUSH
9697: LD_VAR 0 2
9701: DIFF
9702: PPUSH
9703: CALL_OW 1
9707: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9708: LD_ADDR_VAR 0 3
9712: PUSH
9713: LD_INT 0
9715: PPUSH
9716: LD_INT 1
9718: PPUSH
9719: CALL_OW 12
9723: ST_TO_ADDR
// if target then
9724: LD_VAR 0 3
9728: IFFALSE 9856
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9730: LD_ADDR_VAR 0 2
9734: PUSH
9735: LD_VAR 0 2
9739: PPUSH
9740: LD_INT 24
9742: PUSH
9743: LD_INT 250
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: PPUSH
9750: CALL_OW 72
9754: ST_TO_ADDR
// for i in tmp do
9755: LD_ADDR_VAR 0 1
9759: PUSH
9760: LD_VAR 0 2
9764: PUSH
9765: FOR_IN
9766: IFFALSE 9806
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9768: LD_VAR 0 1
9772: PPUSH
9773: LD_INT 139
9775: PPUSH
9776: LD_INT 89
9778: PPUSH
9779: CALL_OW 297
9783: PUSH
9784: LD_INT 9
9786: GREATER
9787: IFFALSE 9804
// ComMoveXY ( i , 139 , 89 ) ;
9789: LD_VAR 0 1
9793: PPUSH
9794: LD_INT 139
9796: PPUSH
9797: LD_INT 89
9799: PPUSH
9800: CALL_OW 111
9804: GO 9765
9806: POP
9807: POP
// wait ( 0 0$1 ) ;
9808: LD_INT 35
9810: PPUSH
9811: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9815: LD_VAR 0 2
9819: PPUSH
9820: LD_INT 92
9822: PUSH
9823: LD_INT 139
9825: PUSH
9826: LD_INT 89
9828: PUSH
9829: LD_INT 9
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: PPUSH
9838: CALL_OW 72
9842: PUSH
9843: LD_VAR 0 2
9847: PUSH
9848: LD_INT 1
9850: MINUS
9851: GREATEREQUAL
9852: IFFALSE 9730
// end else
9854: GO 9998
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9856: LD_VAR 0 2
9860: PPUSH
9861: LD_VAR 0 4
9865: PUSH
9866: LD_INT 1
9868: ARRAY
9869: PPUSH
9870: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9874: LD_ADDR_VAR 0 2
9878: PUSH
9879: LD_VAR 0 2
9883: PPUSH
9884: LD_INT 24
9886: PUSH
9887: LD_INT 250
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PPUSH
9894: CALL_OW 72
9898: ST_TO_ADDR
// for i in tmp do
9899: LD_ADDR_VAR 0 1
9903: PUSH
9904: LD_VAR 0 2
9908: PUSH
9909: FOR_IN
9910: IFFALSE 9950
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9912: LD_VAR 0 1
9916: PPUSH
9917: LD_INT 124
9919: PPUSH
9920: LD_INT 139
9922: PPUSH
9923: CALL_OW 297
9927: PUSH
9928: LD_INT 9
9930: GREATER
9931: IFFALSE 9948
// ComMoveXY ( i , 124 , 139 ) ;
9933: LD_VAR 0 1
9937: PPUSH
9938: LD_INT 124
9940: PPUSH
9941: LD_INT 139
9943: PPUSH
9944: CALL_OW 111
9948: GO 9909
9950: POP
9951: POP
// wait ( 0 0$1 ) ;
9952: LD_INT 35
9954: PPUSH
9955: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9959: LD_VAR 0 2
9963: PPUSH
9964: LD_INT 92
9966: PUSH
9967: LD_INT 124
9969: PUSH
9970: LD_INT 139
9972: PUSH
9973: LD_INT 9
9975: PUSH
9976: EMPTY
9977: LIST
9978: LIST
9979: LIST
9980: LIST
9981: PPUSH
9982: CALL_OW 72
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 1
9994: MINUS
9995: GREATEREQUAL
9996: IFFALSE 9874
// end ; repeat wait ( 0 0$1 ) ;
9998: LD_INT 35
10000: PPUSH
10001: CALL_OW 67
// for i in tmp do
10005: LD_ADDR_VAR 0 1
10009: PUSH
10010: LD_VAR 0 2
10014: PUSH
10015: FOR_IN
10016: IFFALSE 10149
// begin if GetLives ( i ) > 251 then
10018: LD_VAR 0 1
10022: PPUSH
10023: CALL_OW 256
10027: PUSH
10028: LD_INT 251
10030: GREATER
10031: IFFALSE 10120
// begin if GetWeapon ( i ) = ru_time_lapser then
10033: LD_VAR 0 1
10037: PPUSH
10038: CALL_OW 264
10042: PUSH
10043: LD_INT 49
10045: EQUAL
10046: IFFALSE 10084
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10048: LD_VAR 0 1
10052: PPUSH
10053: LD_INT 81
10055: PUSH
10056: LD_INT 3
10058: PUSH
10059: EMPTY
10060: LIST
10061: LIST
10062: PPUSH
10063: CALL_OW 69
10067: PPUSH
10068: LD_VAR 0 1
10072: PPUSH
10073: CALL_OW 74
10077: PPUSH
10078: CALL_OW 112
10082: GO 10118
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10084: LD_VAR 0 1
10088: PPUSH
10089: LD_INT 81
10091: PUSH
10092: LD_INT 3
10094: PUSH
10095: EMPTY
10096: LIST
10097: LIST
10098: PPUSH
10099: CALL_OW 69
10103: PPUSH
10104: LD_VAR 0 1
10108: PPUSH
10109: CALL_OW 74
10113: PPUSH
10114: CALL_OW 115
// end else
10118: GO 10147
// if IsDead ( i ) then
10120: LD_VAR 0 1
10124: PPUSH
10125: CALL_OW 301
10129: IFFALSE 10147
// tmp := tmp diff i ;
10131: LD_ADDR_VAR 0 2
10135: PUSH
10136: LD_VAR 0 2
10140: PUSH
10141: LD_VAR 0 1
10145: DIFF
10146: ST_TO_ADDR
// end ;
10147: GO 10015
10149: POP
10150: POP
// until not tmp ;
10151: LD_VAR 0 2
10155: NOT
10156: IFFALSE 9998
// end ;
10158: PPOPN 4
10160: END
// every 30 30$00 trigger not russianDestroyed do
10161: LD_EXP 2
10165: NOT
10166: IFFALSE 10231
10168: GO 10170
10170: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10171: LD_INT 105000
10173: PUSH
10174: LD_INT 84000
10176: PUSH
10177: LD_INT 63000
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: LIST
10184: PUSH
10185: LD_OWVAR 67
10189: ARRAY
10190: PPUSH
10191: CALL_OW 67
// if russianDestroyed then
10195: LD_EXP 2
10199: IFFALSE 10203
// exit ;
10201: GO 10231
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10203: LD_INT 2
10205: PPUSH
10206: LD_INT 23
10208: PUSH
10209: LD_INT 3
10211: PUSH
10212: LD_INT 1
10214: PUSH
10215: LD_INT 48
10217: PUSH
10218: EMPTY
10219: LIST
10220: LIST
10221: LIST
10222: LIST
10223: PUSH
10224: EMPTY
10225: LIST
10226: PPUSH
10227: CALL 43951 0 2
// end ; end_of_file
10231: END
// export function CustomEvent ( event ) ; begin
10232: LD_INT 0
10234: PPUSH
// end ;
10235: LD_VAR 0 2
10239: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10240: LD_VAR 0 2
10244: PPUSH
10245: LD_VAR 0 3
10249: PPUSH
10250: LD_INT 15
10252: PPUSH
10253: CALL_OW 309
10257: IFFALSE 10266
// YouLost ( MothContaminate ) ;
10259: LD_STRING MothContaminate
10261: PPUSH
10262: CALL_OW 104
// end ;
10266: PPOPN 3
10268: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10269: LD_VAR 0 2
10273: PPUSH
10274: LD_VAR 0 3
10278: PPUSH
10279: LD_INT 15
10281: PPUSH
10282: CALL_OW 309
10286: IFFALSE 10302
// begin wait ( 0 0$6 ) ;
10288: LD_INT 210
10290: PPUSH
10291: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10295: LD_STRING MothContaminateBomb
10297: PPUSH
10298: CALL_OW 104
// end ; end ;
10302: PPOPN 3
10304: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10305: LD_VAR 0 1
10309: PUSH
10310: LD_EXP 14
10314: EQUAL
10315: IFFALSE 10326
// begin YouLost ( JMM ) ;
10317: LD_STRING JMM
10319: PPUSH
10320: CALL_OW 104
// exit ;
10324: GO 10425
// end ; if un = Powell then
10326: LD_VAR 0 1
10330: PUSH
10331: LD_EXP 49
10335: EQUAL
10336: IFFALSE 10346
// americanDestroyed := true ;
10338: LD_ADDR_EXP 4
10342: PUSH
10343: LD_INT 1
10345: ST_TO_ADDR
// if un = Platonov then
10346: LD_VAR 0 1
10350: PUSH
10351: LD_EXP 53
10355: EQUAL
10356: IFFALSE 10366
// russianDestroyed := true ;
10358: LD_ADDR_EXP 2
10362: PUSH
10363: LD_INT 1
10365: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10366: LD_VAR 0 1
10370: PUSH
10371: LD_INT 22
10373: PUSH
10374: LD_INT 7
10376: PUSH
10377: EMPTY
10378: LIST
10379: LIST
10380: PUSH
10381: LD_INT 21
10383: PUSH
10384: LD_INT 2
10386: PUSH
10387: EMPTY
10388: LIST
10389: LIST
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: PPUSH
10395: CALL_OW 69
10399: IN
10400: IFFALSE 10416
// vehicleLostCounter := vehicleLostCounter + 1 ;
10402: LD_ADDR_EXP 12
10406: PUSH
10407: LD_EXP 12
10411: PUSH
10412: LD_INT 1
10414: PLUS
10415: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10416: LD_VAR 0 1
10420: PPUSH
10421: CALL 47343 0 1
// end ;
10425: PPOPN 1
10427: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10428: LD_VAR 0 1
10432: PPUSH
10433: LD_VAR 0 2
10437: PPUSH
10438: CALL 49677 0 2
// end ;
10442: PPOPN 2
10444: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10445: LD_VAR 0 1
10449: PPUSH
10450: CALL 48745 0 1
// end ;
10454: PPOPN 1
10456: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10457: LD_VAR 0 1
10461: PUSH
10462: LD_INT 22
10464: PUSH
10465: LD_INT 8
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: PUSH
10472: LD_INT 30
10474: PUSH
10475: LD_INT 2
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PUSH
10482: LD_INT 23
10484: PUSH
10485: LD_INT 3
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: LIST
10496: PPUSH
10497: CALL_OW 69
10501: IN
10502: IFFALSE 10529
// begin ComUpgrade ( building ) ;
10504: LD_VAR 0 1
10508: PPUSH
10509: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10513: LD_EXP 52
10517: PPUSH
10518: LD_VAR 0 1
10522: PPUSH
10523: CALL 60383 0 2
// exit ;
10527: GO 10538
// end ; MCE_BuildingComplete ( building ) ;
10529: LD_VAR 0 1
10533: PPUSH
10534: CALL 48986 0 1
// end ;
10538: PPOPN 1
10540: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10541: LD_VAR 0 1
10545: PPUSH
10546: LD_VAR 0 2
10550: PPUSH
10551: CALL 47039 0 2
// end ;
10555: PPOPN 2
10557: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10558: LD_VAR 0 1
10562: PPUSH
10563: LD_VAR 0 2
10567: PPUSH
10568: LD_VAR 0 3
10572: PPUSH
10573: LD_VAR 0 4
10577: PPUSH
10578: LD_VAR 0 5
10582: PPUSH
10583: CALL 46659 0 5
// end ;
10587: PPOPN 5
10589: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10590: LD_VAR 0 1
10594: PPUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: CALL 46255 0 2
// end ;
10604: PPOPN 2
10606: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10607: LD_VAR 0 1
10611: PPUSH
10612: LD_VAR 0 2
10616: PPUSH
10617: LD_VAR 0 3
10621: PPUSH
10622: LD_VAR 0 4
10626: PPUSH
10627: CALL 46093 0 4
// end ;
10631: PPOPN 4
10633: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10634: LD_VAR 0 1
10638: PPUSH
10639: LD_VAR 0 2
10643: PPUSH
10644: LD_VAR 0 3
10648: PPUSH
10649: CALL 45868 0 3
// end ;
10653: PPOPN 3
10655: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10656: LD_VAR 0 1
10660: PPUSH
10661: LD_VAR 0 2
10665: PPUSH
10666: CALL 45753 0 2
// end ;
10670: PPOPN 2
10672: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10673: LD_VAR 0 1
10677: PPUSH
10678: LD_VAR 0 2
10682: PPUSH
10683: CALL 49938 0 2
// end ;
10687: PPOPN 2
10689: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10690: LD_VAR 0 1
10694: PPUSH
10695: LD_VAR 0 2
10699: PPUSH
10700: LD_VAR 0 3
10704: PPUSH
10705: LD_VAR 0 4
10709: PPUSH
10710: CALL 50154 0 4
// end ;
10714: PPOPN 4
10716: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10717: LD_VAR 0 1
10721: PPUSH
10722: LD_VAR 0 2
10726: PPUSH
10727: CALL 45562 0 2
// end ;
10731: PPOPN 2
10733: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10734: LD_VAR 0 1
10738: PPUSH
10739: CALL 93581 0 1
// end ; end_of_file
10743: PPOPN 1
10745: END
// export function Action ; begin
10746: LD_INT 0
10748: PPUSH
// InGameOn ;
10749: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10753: LD_INT 206
10755: PPUSH
10756: LD_INT 11
10758: PPUSH
10759: CALL_OW 86
// wait ( 0 0$1 ) ;
10763: LD_INT 35
10765: PPUSH
10766: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10770: LD_EXP 14
10774: PPUSH
10775: LD_STRING DStart-JMM-JMM-1
10777: PPUSH
10778: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10782: LD_EXP 46
10786: PPUSH
10787: LD_STRING DStart-JMM-Bur-1
10789: PPUSH
10790: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10794: LD_EXP 14
10798: PPUSH
10799: LD_STRING DStart-JMM-JMM-2
10801: PPUSH
10802: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10806: LD_EXP 46
10810: PPUSH
10811: LD_STRING DStart-JMM-Bur-2
10813: PPUSH
10814: CALL_OW 88
// InGameOff ;
10818: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10822: LD_STRING MStart
10824: PPUSH
10825: CALL_OW 337
// end ;
10829: LD_VAR 0 1
10833: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10834: LD_INT 7
10836: PPUSH
10837: LD_INT 255
10839: PPUSH
10840: LD_INT 219
10842: PPUSH
10843: CALL_OW 293
10847: IFFALSE 11456
10849: GO 10851
10851: DISABLE
10852: LD_INT 0
10854: PPUSH
// begin wait ( 0 0$3 ) ;
10855: LD_INT 105
10857: PPUSH
10858: CALL_OW 67
// alienSpotted := true ;
10862: LD_ADDR_EXP 7
10866: PUSH
10867: LD_INT 1
10869: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10870: LD_ADDR_VAR 0 1
10874: PUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 7
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PUSH
10885: LD_INT 23
10887: PUSH
10888: LD_INT 3
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: LD_INT 21
10897: PUSH
10898: LD_INT 1
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: PUSH
10905: LD_INT 26
10907: PUSH
10908: LD_INT 1
10910: PUSH
10911: EMPTY
10912: LIST
10913: LIST
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: LIST
10919: LIST
10920: PPUSH
10921: CALL_OW 69
10925: PUSH
10926: LD_EXP 46
10930: PUSH
10931: LD_EXP 34
10935: PUSH
10936: LD_EXP 36
10940: PUSH
10941: LD_EXP 37
10945: PUSH
10946: LD_EXP 44
10950: PUSH
10951: LD_EXP 43
10955: PUSH
10956: LD_EXP 38
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: LIST
10965: LIST
10966: LIST
10967: LIST
10968: LIST
10969: DIFF
10970: ST_TO_ADDR
// DialogueOn ;
10971: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
10975: LD_INT 255
10977: PPUSH
10978: LD_INT 219
10980: PPUSH
10981: LD_INT 7
10983: PPUSH
10984: LD_INT 20
10986: NEG
10987: PPUSH
10988: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
10992: LD_INT 255
10994: PPUSH
10995: LD_INT 219
10997: PPUSH
10998: CALL_OW 86
// if speaker then
11002: LD_VAR 0 1
11006: IFFALSE 11024
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11008: LD_VAR 0 1
11012: PUSH
11013: LD_INT 1
11015: ARRAY
11016: PPUSH
11017: LD_STRING DAlienBase-RSol1-1
11019: PPUSH
11020: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11024: LD_EXP 14
11028: PPUSH
11029: LD_STRING DAlienBase-JMM-1
11031: PPUSH
11032: CALL_OW 88
// if IsOk ( Burlak ) then
11036: LD_EXP 46
11040: PPUSH
11041: CALL_OW 302
11045: IFFALSE 11066
// begin dwait ( 0 0$1 ) ;
11047: LD_INT 35
11049: PPUSH
11050: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11054: LD_EXP 46
11058: PPUSH
11059: LD_STRING DAlienBase-Bur-1
11061: PPUSH
11062: CALL_OW 88
// end ; if IsOk ( Roth ) then
11066: LD_EXP 15
11070: PPUSH
11071: CALL_OW 302
11075: IFFALSE 11089
// Say ( Roth , DAlienBase-Roth-1 ) ;
11077: LD_EXP 15
11081: PPUSH
11082: LD_STRING DAlienBase-Roth-1
11084: PPUSH
11085: CALL_OW 88
// if IsOk ( Gossudarov ) then
11089: LD_EXP 32
11093: PPUSH
11094: CALL_OW 302
11098: IFFALSE 11114
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11100: LD_EXP 32
11104: PPUSH
11105: LD_STRING DAlienBase-Gos-1
11107: PPUSH
11108: CALL_OW 88
11112: GO 11231
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11114: LD_ADDR_VAR 0 1
11118: PUSH
11119: LD_INT 22
11121: PUSH
11122: LD_INT 7
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: PUSH
11129: LD_INT 25
11131: PUSH
11132: LD_INT 4
11134: PUSH
11135: EMPTY
11136: LIST
11137: LIST
11138: PUSH
11139: LD_INT 21
11141: PUSH
11142: LD_INT 1
11144: PUSH
11145: EMPTY
11146: LIST
11147: LIST
11148: PUSH
11149: LD_INT 26
11151: PUSH
11152: LD_INT 1
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: EMPTY
11160: LIST
11161: LIST
11162: LIST
11163: LIST
11164: PPUSH
11165: CALL_OW 69
11169: PUSH
11170: LD_EXP 15
11174: PUSH
11175: LD_EXP 14
11179: PUSH
11180: LD_EXP 46
11184: PUSH
11185: LD_EXP 34
11189: PUSH
11190: LD_EXP 44
11194: PUSH
11195: LD_EXP 43
11199: PUSH
11200: EMPTY
11201: LIST
11202: LIST
11203: LIST
11204: LIST
11205: LIST
11206: LIST
11207: DIFF
11208: ST_TO_ADDR
// if speaker then
11209: LD_VAR 0 1
11213: IFFALSE 11231
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11215: LD_VAR 0 1
11219: PUSH
11220: LD_INT 1
11222: ARRAY
11223: PPUSH
11224: LD_STRING DAlienBase-Sci1-1
11226: PPUSH
11227: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11231: LD_INT 255
11233: PPUSH
11234: LD_INT 219
11236: PPUSH
11237: LD_INT 7
11239: PPUSH
11240: CALL_OW 331
// DialogueOff ;
11244: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11248: LD_INT 35
11250: PPUSH
11251: CALL_OW 67
// until IsSelected ( alien ) ;
11255: LD_INT 1
11257: PPUSH
11258: CALL_OW 306
11262: IFFALSE 11248
// if not artifactIResearched or not artifactIIResearched then
11264: LD_EXP 9
11268: NOT
11269: PUSH
11270: LD_EXP 10
11274: NOT
11275: OR
11276: IFFALSE 11456
// begin if IsOk ( Roth ) then
11278: LD_EXP 15
11282: PPUSH
11283: CALL_OW 302
11287: IFFALSE 11303
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11289: LD_EXP 15
11293: PPUSH
11294: LD_STRING DAlieBaseNotReady-Roth-1
11296: PPUSH
11297: CALL_OW 88
11301: GO 11456
// if IsOk ( Gossudarov ) then
11303: LD_EXP 32
11307: PPUSH
11308: CALL_OW 302
11312: IFFALSE 11328
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11314: LD_EXP 32
11318: PPUSH
11319: LD_STRING DAlieBaseNotReady-Gos-1
11321: PPUSH
11322: CALL_OW 88
11326: GO 11456
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11328: LD_ADDR_VAR 0 1
11332: PUSH
11333: LD_INT 22
11335: PUSH
11336: LD_INT 7
11338: PUSH
11339: EMPTY
11340: LIST
11341: LIST
11342: PUSH
11343: LD_INT 23
11345: PUSH
11346: LD_INT 3
11348: PUSH
11349: EMPTY
11350: LIST
11351: LIST
11352: PUSH
11353: LD_INT 25
11355: PUSH
11356: LD_INT 4
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 21
11365: PUSH
11366: LD_INT 1
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 26
11375: PUSH
11376: LD_INT 1
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: LIST
11389: PPUSH
11390: CALL_OW 69
11394: PUSH
11395: LD_EXP 15
11399: PUSH
11400: LD_EXP 14
11404: PUSH
11405: LD_EXP 46
11409: PUSH
11410: LD_EXP 34
11414: PUSH
11415: LD_EXP 44
11419: PUSH
11420: LD_EXP 43
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: DIFF
11433: ST_TO_ADDR
// if speaker then
11434: LD_VAR 0 1
11438: IFFALSE 11456
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11440: LD_VAR 0 1
11444: PUSH
11445: LD_INT 1
11447: ARRAY
11448: PPUSH
11449: LD_STRING DAlieBaseNotReady-RSci1-1
11451: PPUSH
11452: CALL_OW 88
// end ; end ; end ;
11456: PPOPN 1
11458: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11459: LD_INT 24
11461: PPUSH
11462: LD_INT 7
11464: PPUSH
11465: CALL_OW 321
11469: PUSH
11470: LD_INT 2
11472: EQUAL
11473: IFFALSE 12164
11475: GO 11477
11477: DISABLE
11478: LD_INT 0
11480: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11481: LD_ADDR_VAR 0 1
11485: PUSH
11486: LD_INT 22
11488: PUSH
11489: LD_INT 7
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: PUSH
11496: LD_INT 23
11498: PUSH
11499: LD_INT 3
11501: PUSH
11502: EMPTY
11503: LIST
11504: LIST
11505: PUSH
11506: LD_INT 25
11508: PUSH
11509: LD_INT 4
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: PUSH
11516: LD_INT 21
11518: PUSH
11519: LD_INT 1
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: PUSH
11526: LD_INT 26
11528: PUSH
11529: LD_INT 1
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: PUSH
11536: EMPTY
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: PPUSH
11543: CALL_OW 69
11547: PUSH
11548: LD_EXP 15
11552: PUSH
11553: LD_EXP 14
11557: PUSH
11558: LD_EXP 46
11562: PUSH
11563: LD_EXP 34
11567: PUSH
11568: LD_EXP 44
11572: PUSH
11573: LD_EXP 43
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: LIST
11585: DIFF
11586: ST_TO_ADDR
// if not speaker then
11587: LD_VAR 0 1
11591: NOT
11592: IFFALSE 11596
// exit ;
11594: GO 12164
// DialogueOn ;
11596: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11600: LD_VAR 0 1
11604: PUSH
11605: LD_INT 1
11607: ARRAY
11608: PPUSH
11609: LD_STRING DArtefTechnology-RSci1-1
11611: PPUSH
11612: CALL_OW 88
// if IsOk ( Burlak ) then
11616: LD_EXP 46
11620: PPUSH
11621: CALL_OW 302
11625: IFFALSE 11639
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11627: LD_EXP 46
11631: PPUSH
11632: LD_STRING DArtefTechnology-Bur-1
11634: PPUSH
11635: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11639: LD_VAR 0 1
11643: PUSH
11644: LD_INT 1
11646: ARRAY
11647: PPUSH
11648: LD_STRING DArtefTechnology-RSci1-2
11650: PPUSH
11651: CALL_OW 88
// if Denis then
11655: LD_EXP 20
11659: IFFALSE 11676
// speaker := [ Denis ] else
11661: LD_ADDR_VAR 0 1
11665: PUSH
11666: LD_EXP 20
11670: PUSH
11671: EMPTY
11672: LIST
11673: ST_TO_ADDR
11674: GO 11782
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11676: LD_ADDR_VAR 0 1
11680: PUSH
11681: LD_INT 22
11683: PUSH
11684: LD_INT 7
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: LD_INT 23
11693: PUSH
11694: LD_INT 1
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: PUSH
11701: LD_INT 25
11703: PUSH
11704: LD_INT 4
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: PUSH
11711: LD_INT 21
11713: PUSH
11714: LD_INT 1
11716: PUSH
11717: EMPTY
11718: LIST
11719: LIST
11720: PUSH
11721: LD_INT 26
11723: PUSH
11724: LD_INT 1
11726: PUSH
11727: EMPTY
11728: LIST
11729: LIST
11730: PUSH
11731: EMPTY
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: PPUSH
11738: CALL_OW 69
11742: PUSH
11743: LD_EXP 15
11747: PUSH
11748: LD_EXP 14
11752: PUSH
11753: LD_EXP 46
11757: PUSH
11758: LD_EXP 34
11762: PUSH
11763: LD_EXP 44
11767: PUSH
11768: LD_EXP 43
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: DIFF
11781: ST_TO_ADDR
// if speaker then
11782: LD_VAR 0 1
11786: IFFALSE 11804
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11788: LD_VAR 0 1
11792: PUSH
11793: LD_INT 1
11795: ARRAY
11796: PPUSH
11797: LD_STRING DArtefTechnology-Sci1-2
11799: PPUSH
11800: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11804: LD_ADDR_VAR 0 1
11808: PUSH
11809: LD_INT 22
11811: PUSH
11812: LD_INT 7
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 23
11821: PUSH
11822: LD_INT 3
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 25
11831: PUSH
11832: LD_INT 4
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 21
11841: PUSH
11842: LD_INT 1
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: LD_INT 26
11851: PUSH
11852: LD_INT 1
11854: PUSH
11855: EMPTY
11856: LIST
11857: LIST
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL_OW 69
11870: PUSH
11871: LD_EXP 15
11875: PUSH
11876: LD_EXP 14
11880: PUSH
11881: LD_EXP 46
11885: PUSH
11886: LD_EXP 34
11890: PUSH
11891: LD_EXP 44
11895: PUSH
11896: LD_EXP 43
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: LIST
11905: LIST
11906: LIST
11907: LIST
11908: DIFF
11909: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
11910: LD_VAR 0 1
11914: PUSH
11915: LD_EXP 6
11919: PUSH
11920: LD_EXP 5
11924: OR
11925: AND
11926: IFFALSE 12160
// begin if arabianDestroyed and IsOk ( Burlak ) then
11928: LD_EXP 5
11932: PUSH
11933: LD_EXP 46
11937: PPUSH
11938: CALL_OW 302
11942: AND
11943: IFFALSE 11959
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
11945: LD_EXP 46
11949: PPUSH
11950: LD_STRING DArtefTechnology-Bur-2
11952: PPUSH
11953: CALL_OW 88
11957: GO 11971
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
11959: LD_EXP 14
11963: PPUSH
11964: LD_STRING DArtefTechnology-JMM-2
11966: PPUSH
11967: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
11971: LD_VAR 0 1
11975: PUSH
11976: LD_INT 1
11978: ARRAY
11979: PPUSH
11980: LD_STRING DArtefTechnology-RSci1-3
11982: PPUSH
11983: CALL_OW 88
// if Denis then
11987: LD_EXP 20
11991: IFFALSE 12008
// speaker := [ Denis ] else
11993: LD_ADDR_VAR 0 1
11997: PUSH
11998: LD_EXP 20
12002: PUSH
12003: EMPTY
12004: LIST
12005: ST_TO_ADDR
12006: GO 12114
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12008: LD_ADDR_VAR 0 1
12012: PUSH
12013: LD_INT 22
12015: PUSH
12016: LD_INT 7
12018: PUSH
12019: EMPTY
12020: LIST
12021: LIST
12022: PUSH
12023: LD_INT 23
12025: PUSH
12026: LD_INT 1
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PUSH
12033: LD_INT 25
12035: PUSH
12036: LD_INT 4
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: PUSH
12043: LD_INT 21
12045: PUSH
12046: LD_INT 1
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: PUSH
12053: LD_INT 26
12055: PUSH
12056: LD_INT 1
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PPUSH
12070: CALL_OW 69
12074: PUSH
12075: LD_EXP 15
12079: PUSH
12080: LD_EXP 14
12084: PUSH
12085: LD_EXP 46
12089: PUSH
12090: LD_EXP 34
12094: PUSH
12095: LD_EXP 44
12099: PUSH
12100: LD_EXP 43
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: DIFF
12113: ST_TO_ADDR
// if speaker then
12114: LD_VAR 0 1
12118: IFFALSE 12160
// if alienSpotted then
12120: LD_EXP 7
12124: IFFALSE 12144
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12126: LD_VAR 0 1
12130: PUSH
12131: LD_INT 1
12133: ARRAY
12134: PPUSH
12135: LD_STRING DArtefTechnology-Sci1-3
12137: PPUSH
12138: CALL_OW 88
12142: GO 12160
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12144: LD_VAR 0 1
12148: PUSH
12149: LD_INT 1
12151: ARRAY
12152: PPUSH
12153: LD_STRING DArtefTechnology-Sci1-3a
12155: PPUSH
12156: CALL_OW 88
// end ; DialogueOff ;
12160: CALL_OW 7
// end ;
12164: PPOPN 1
12166: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12167: LD_EXP 9
12171: IFFALSE 12366
12173: GO 12175
12175: DISABLE
12176: LD_INT 0
12178: PPUSH
// begin if Denis then
12179: LD_EXP 20
12183: IFFALSE 12200
// speaker := [ Denis ] else
12185: LD_ADDR_VAR 0 1
12189: PUSH
12190: LD_EXP 20
12194: PUSH
12195: EMPTY
12196: LIST
12197: ST_TO_ADDR
12198: GO 12306
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12200: LD_ADDR_VAR 0 1
12204: PUSH
12205: LD_INT 22
12207: PUSH
12208: LD_INT 7
12210: PUSH
12211: EMPTY
12212: LIST
12213: LIST
12214: PUSH
12215: LD_INT 23
12217: PUSH
12218: LD_INT 1
12220: PUSH
12221: EMPTY
12222: LIST
12223: LIST
12224: PUSH
12225: LD_INT 25
12227: PUSH
12228: LD_INT 4
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: LD_INT 21
12237: PUSH
12238: LD_INT 1
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: LD_INT 26
12247: PUSH
12248: LD_INT 1
12250: PUSH
12251: EMPTY
12252: LIST
12253: LIST
12254: PUSH
12255: EMPTY
12256: LIST
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: PPUSH
12262: CALL_OW 69
12266: PUSH
12267: LD_EXP 15
12271: PUSH
12272: LD_EXP 14
12276: PUSH
12277: LD_EXP 46
12281: PUSH
12282: LD_EXP 34
12286: PUSH
12287: LD_EXP 44
12291: PUSH
12292: LD_EXP 43
12296: PUSH
12297: EMPTY
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: DIFF
12305: ST_TO_ADDR
// if not speaker then
12306: LD_VAR 0 1
12310: NOT
12311: IFFALSE 12315
// exit ;
12313: GO 12366
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12315: LD_VAR 0 1
12319: PUSH
12320: LD_INT 1
12322: ARRAY
12323: PPUSH
12324: LD_STRING DArtefTechnologyAm-Sci1-1
12326: PPUSH
12327: CALL_OW 88
// if IsOk ( Burlak ) then
12331: LD_EXP 46
12335: PPUSH
12336: CALL_OW 302
12340: IFFALSE 12354
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12342: LD_EXP 46
12346: PPUSH
12347: LD_STRING DArtefTechnologyAm-Bur-1
12349: PPUSH
12350: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12354: LD_EXP 14
12358: PPUSH
12359: LD_STRING DArtefTechnologyAm-JMM-1
12361: PPUSH
12362: CALL_OW 88
// end ;
12366: PPOPN 1
12368: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12369: LD_EXP 10
12373: IFFALSE 12584
12375: GO 12377
12377: DISABLE
12378: LD_INT 0
12380: PPUSH
// begin if Denis then
12381: LD_EXP 20
12385: IFFALSE 12402
// speaker := [ Denis ] else
12387: LD_ADDR_VAR 0 1
12391: PUSH
12392: LD_EXP 20
12396: PUSH
12397: EMPTY
12398: LIST
12399: ST_TO_ADDR
12400: GO 12508
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12402: LD_ADDR_VAR 0 1
12406: PUSH
12407: LD_INT 22
12409: PUSH
12410: LD_INT 7
12412: PUSH
12413: EMPTY
12414: LIST
12415: LIST
12416: PUSH
12417: LD_INT 23
12419: PUSH
12420: LD_INT 3
12422: PUSH
12423: EMPTY
12424: LIST
12425: LIST
12426: PUSH
12427: LD_INT 25
12429: PUSH
12430: LD_INT 4
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: PUSH
12437: LD_INT 21
12439: PUSH
12440: LD_INT 1
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PUSH
12447: LD_INT 26
12449: PUSH
12450: LD_INT 1
12452: PUSH
12453: EMPTY
12454: LIST
12455: LIST
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: LIST
12463: PPUSH
12464: CALL_OW 69
12468: PUSH
12469: LD_EXP 15
12473: PUSH
12474: LD_EXP 14
12478: PUSH
12479: LD_EXP 46
12483: PUSH
12484: LD_EXP 34
12488: PUSH
12489: LD_EXP 44
12493: PUSH
12494: LD_EXP 43
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: DIFF
12507: ST_TO_ADDR
// if not speaker then
12508: LD_VAR 0 1
12512: NOT
12513: IFFALSE 12517
// exit ;
12515: GO 12584
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12517: LD_VAR 0 1
12521: PUSH
12522: LD_INT 1
12524: ARRAY
12525: PPUSH
12526: LD_STRING DArtefTechnologyRu-RSci1-1
12528: PPUSH
12529: CALL_OW 88
// if IsOk ( Burlak ) then
12533: LD_EXP 46
12537: PPUSH
12538: CALL_OW 302
12542: IFFALSE 12556
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12544: LD_EXP 46
12548: PPUSH
12549: LD_STRING DArtefTechnologyRu-Bur-1
12551: PPUSH
12552: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12556: LD_VAR 0 1
12560: PUSH
12561: LD_INT 1
12563: ARRAY
12564: PPUSH
12565: LD_STRING DArtefTechnologyRu-RSci1-2
12567: PPUSH
12568: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12572: LD_EXP 14
12576: PPUSH
12577: LD_STRING DArtefTechnologyRu-JMM-1
12579: PPUSH
12580: CALL_OW 88
// end ;
12584: PPOPN 1
12586: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12587: LD_INT 24
12589: PPUSH
12590: LD_INT 7
12592: PPUSH
12593: CALL_OW 321
12597: PUSH
12598: LD_INT 2
12600: EQUAL
12601: PUSH
12602: LD_INT 1
12604: PPUSH
12605: CALL_OW 255
12609: PUSH
12610: LD_INT 7
12612: EQUAL
12613: AND
12614: IFFALSE 12774
12616: GO 12618
12618: DISABLE
12619: LD_INT 0
12621: PPUSH
// begin if Denis then
12622: LD_EXP 20
12626: IFFALSE 12643
// speaker := [ Denis ] else
12628: LD_ADDR_VAR 0 1
12632: PUSH
12633: LD_EXP 20
12637: PUSH
12638: EMPTY
12639: LIST
12640: ST_TO_ADDR
12641: GO 12749
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12643: LD_ADDR_VAR 0 1
12647: PUSH
12648: LD_INT 22
12650: PUSH
12651: LD_INT 7
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: PUSH
12658: LD_INT 23
12660: PUSH
12661: LD_INT 1
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: PUSH
12668: LD_INT 25
12670: PUSH
12671: LD_INT 4
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: PUSH
12678: LD_INT 21
12680: PUSH
12681: LD_INT 1
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: PUSH
12688: LD_INT 26
12690: PUSH
12691: LD_INT 1
12693: PUSH
12694: EMPTY
12695: LIST
12696: LIST
12697: PUSH
12698: EMPTY
12699: LIST
12700: LIST
12701: LIST
12702: LIST
12703: LIST
12704: PPUSH
12705: CALL_OW 69
12709: PUSH
12710: LD_EXP 15
12714: PUSH
12715: LD_EXP 14
12719: PUSH
12720: LD_EXP 46
12724: PUSH
12725: LD_EXP 34
12729: PUSH
12730: LD_EXP 44
12734: PUSH
12735: LD_EXP 43
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: LIST
12744: LIST
12745: LIST
12746: LIST
12747: DIFF
12748: ST_TO_ADDR
// if not speaker then
12749: LD_VAR 0 1
12753: NOT
12754: IFFALSE 12758
// exit ;
12756: GO 12774
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12758: LD_VAR 0 1
12762: PUSH
12763: LD_INT 1
12765: ARRAY
12766: PPUSH
12767: LD_STRING DArtefTechnologyArStart-Sci1-1
12769: PPUSH
12770: CALL_OW 88
// end ;
12774: PPOPN 1
12776: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12777: LD_EXP 11
12781: IFFALSE 13062
12783: GO 12785
12785: DISABLE
12786: LD_INT 0
12788: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12789: LD_ADDR_VAR 0 1
12793: PUSH
12794: LD_INT 22
12796: PUSH
12797: LD_INT 7
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 23
12806: PUSH
12807: LD_INT 3
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 25
12816: PUSH
12817: LD_INT 4
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: LD_INT 21
12826: PUSH
12827: LD_INT 1
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: PUSH
12834: LD_INT 26
12836: PUSH
12837: LD_INT 1
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: PUSH
12844: EMPTY
12845: LIST
12846: LIST
12847: LIST
12848: LIST
12849: LIST
12850: PPUSH
12851: CALL_OW 69
12855: PUSH
12856: LD_EXP 15
12860: PUSH
12861: LD_EXP 14
12865: PUSH
12866: LD_EXP 46
12870: PUSH
12871: LD_EXP 34
12875: PUSH
12876: LD_EXP 44
12880: PUSH
12881: LD_EXP 43
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: LIST
12893: DIFF
12894: ST_TO_ADDR
// if not speaker then
12895: LD_VAR 0 1
12899: NOT
12900: IFFALSE 12904
// exit ;
12902: GO 13062
// DialogueOn ;
12904: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
12908: LD_VAR 0 1
12912: PUSH
12913: LD_INT 1
12915: ARRAY
12916: PPUSH
12917: LD_STRING DArtefTechnologyAr-RSci1-1
12919: PPUSH
12920: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
12924: LD_EXP 14
12928: PPUSH
12929: LD_STRING DArtefTechnologyAr-JMM-1
12931: PPUSH
12932: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
12936: LD_VAR 0 1
12940: PUSH
12941: LD_INT 1
12943: ARRAY
12944: PPUSH
12945: LD_STRING DArtefTechnologyAr-RSci1-2
12947: PPUSH
12948: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
12952: LD_EXP 14
12956: PPUSH
12957: LD_STRING DArtefTechnologyAr-JMM-2
12959: PPUSH
12960: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
12964: LD_VAR 0 1
12968: PUSH
12969: LD_INT 1
12971: ARRAY
12972: PPUSH
12973: LD_STRING DArtefTechnologyAr-RSci1-3
12975: PPUSH
12976: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
12980: LD_EXP 14
12984: PPUSH
12985: LD_STRING DArtefTechnologyAr-JMM-3
12987: PPUSH
12988: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
12992: LD_VAR 0 1
12996: PUSH
12997: LD_INT 1
12999: ARRAY
13000: PPUSH
13001: LD_STRING DArtefTechnologyAr-RSci1-4
13003: PPUSH
13004: CALL_OW 88
// if IsOk ( Burlak ) then
13008: LD_EXP 46
13012: PPUSH
13013: CALL_OW 302
13017: IFFALSE 13031
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13019: LD_EXP 46
13023: PPUSH
13024: LD_STRING DArtefTechnologyAr-Bur-4
13026: PPUSH
13027: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13031: LD_EXP 14
13035: PPUSH
13036: LD_STRING DArtefTechnologyAr-JMM-4
13038: PPUSH
13039: CALL_OW 88
// DialogueOff ;
13043: CALL_OW 7
// wait ( 0 0$45 ) ;
13047: LD_INT 1575
13049: PPUSH
13050: CALL_OW 67
// spawnOmar := true ;
13054: LD_ADDR_EXP 8
13058: PUSH
13059: LD_INT 1
13061: ST_TO_ADDR
// end ;
13062: PPOPN 1
13064: END
// every 0 0$1 trigger spawnOmar do
13065: LD_EXP 8
13069: IFFALSE 13374
13071: GO 13073
13073: DISABLE
// begin PrepareOmarAli ;
13074: CALL 6547 0 0
// if not Omar then
13078: LD_EXP 50
13082: NOT
13083: IFFALSE 13087
// exit ;
13085: GO 13374
// repeat wait ( 0 0$1 ) ;
13087: LD_INT 35
13089: PPUSH
13090: CALL_OW 67
// until See ( 7 , Omar ) ;
13094: LD_INT 7
13096: PPUSH
13097: LD_EXP 50
13101: PPUSH
13102: CALL_OW 292
13106: IFFALSE 13087
// CenterNowOnUnits ( Omar ) ;
13108: LD_EXP 50
13112: PPUSH
13113: CALL_OW 87
// DialogueOn ;
13117: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13121: LD_EXP 50
13125: PPUSH
13126: LD_STRING DOmar-Omar-1
13128: PPUSH
13129: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13133: LD_EXP 14
13137: PPUSH
13138: LD_STRING DOmar-JMM-1
13140: PPUSH
13141: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13145: LD_EXP 50
13149: PPUSH
13150: LD_STRING DOmar-Omar-2
13152: PPUSH
13153: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13157: LD_EXP 14
13161: PPUSH
13162: LD_STRING DOmar-JMM-2
13164: PPUSH
13165: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13169: LD_EXP 50
13173: PPUSH
13174: LD_STRING DOmar-Omar-3
13176: PPUSH
13177: CALL_OW 88
// if IsOk ( Burlak ) then
13181: LD_EXP 46
13185: PPUSH
13186: CALL_OW 302
13190: IFFALSE 13206
// Say ( Burlak , DOmar-Bur-3 ) else
13192: LD_EXP 46
13196: PPUSH
13197: LD_STRING DOmar-Bur-3
13199: PPUSH
13200: CALL_OW 88
13204: GO 13218
// Say ( JMM , DOmar-JMM-3 ) ;
13206: LD_EXP 14
13210: PPUSH
13211: LD_STRING DOmar-JMM-3
13213: PPUSH
13214: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13218: LD_EXP 50
13222: PPUSH
13223: LD_STRING DOmar-Omar-4
13225: PPUSH
13226: CALL_OW 88
// case Query ( QAccept ) of 1 :
13230: LD_STRING QAccept
13232: PPUSH
13233: CALL_OW 97
13237: PUSH
13238: LD_INT 1
13240: DOUBLE
13241: EQUAL
13242: IFTRUE 13246
13244: GO 13282
13246: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13247: LD_EXP 14
13251: PPUSH
13252: LD_STRING DQrAccept#1-JMM-1
13254: PPUSH
13255: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13259: LD_EXP 50
13263: PPUSH
13264: LD_INT 7
13266: PPUSH
13267: CALL_OW 235
// ComStop ( Omar ) ;
13271: LD_EXP 50
13275: PPUSH
13276: CALL_OW 141
// end ; 2 :
13280: GO 13331
13282: LD_INT 2
13284: DOUBLE
13285: EQUAL
13286: IFTRUE 13290
13288: GO 13330
13290: POP
// begin if IsOk ( Burlak ) then
13291: LD_EXP 46
13295: PPUSH
13296: CALL_OW 302
13300: IFFALSE 13316
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13302: LD_EXP 46
13306: PPUSH
13307: LD_STRING DQrAccept#2-Bur-1
13309: PPUSH
13310: CALL_OW 88
13314: GO 13328
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13316: LD_EXP 14
13320: PPUSH
13321: LD_STRING DQrAccept#2-JMM-1
13323: PPUSH
13324: CALL_OW 88
// end ; end ;
13328: GO 13331
13330: POP
// DialogueOff ;
13331: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13335: LD_EXP 50
13339: PPUSH
13340: CALL_OW 255
13344: PUSH
13345: LD_INT 7
13347: EQUAL
13348: IFFALSE 13359
// begin SetAchievement ( ACH_OMAR ) ;
13350: LD_STRING ACH_OMAR
13352: PPUSH
13353: CALL_OW 543
// exit ;
13357: GO 13374
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13359: LD_EXP 50
13363: PPUSH
13364: LD_INT 202
13366: PPUSH
13367: LD_INT 115
13369: PPUSH
13370: CALL_OW 111
// end ;
13374: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13375: LD_EXP 50
13379: PPUSH
13380: LD_INT 200
13382: PPUSH
13383: LD_INT 98
13385: PPUSH
13386: CALL_OW 297
13390: PUSH
13391: LD_INT 40
13393: LESS
13394: PUSH
13395: LD_EXP 2
13399: AND
13400: IFFALSE 13618
13402: GO 13404
13404: DISABLE
// begin SetSide ( Omar , 5 ) ;
13405: LD_EXP 50
13409: PPUSH
13410: LD_INT 5
13412: PPUSH
13413: CALL_OW 235
// if IsInUnit ( Omar ) then
13417: LD_EXP 50
13421: PPUSH
13422: CALL_OW 310
13426: IFFALSE 13437
// ComExitVehicle ( Omar ) ;
13428: LD_EXP 50
13432: PPUSH
13433: CALL_OW 121
// if IsInUnit ( Omar ) then
13437: LD_EXP 50
13441: PPUSH
13442: CALL_OW 310
13446: IFFALSE 13457
// ComExitBuilding ( Omar ) ;
13448: LD_EXP 50
13452: PPUSH
13453: CALL_OW 122
// wait ( 0 0$1 ) ;
13457: LD_INT 35
13459: PPUSH
13460: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13464: LD_EXP 50
13468: PPUSH
13469: LD_INT 203
13471: PPUSH
13472: LD_INT 120
13474: PPUSH
13475: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13479: LD_INT 35
13481: PPUSH
13482: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13486: LD_EXP 50
13490: PPUSH
13491: CALL_OW 306
13495: PUSH
13496: LD_EXP 50
13500: PPUSH
13501: LD_INT 203
13503: PPUSH
13504: LD_INT 120
13506: PPUSH
13507: CALL_OW 297
13511: PUSH
13512: LD_INT 6
13514: LESS
13515: OR
13516: IFFALSE 13479
// CenterNowOnUnits ( Omar ) ;
13518: LD_EXP 50
13522: PPUSH
13523: CALL_OW 87
// DialogueOn ;
13527: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13531: LD_EXP 14
13535: PPUSH
13536: LD_STRING DOmarContam-JMM-1
13538: PPUSH
13539: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13543: LD_EXP 50
13547: PPUSH
13548: LD_STRING DOmarContam-Omar-1
13550: PPUSH
13551: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13555: LD_EXP 14
13559: PPUSH
13560: LD_STRING DOmarContam-JMM-2
13562: PPUSH
13563: CALL_OW 88
// DialogueOff ;
13567: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13571: LD_INT 5
13573: PPUSH
13574: LD_INT 7
13576: PPUSH
13577: LD_INT 2
13579: PPUSH
13580: LD_INT 1
13582: PPUSH
13583: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13587: LD_INT 105
13589: PPUSH
13590: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13594: LD_EXP 50
13598: PPUSH
13599: LD_INT 203
13601: PPUSH
13602: LD_INT 120
13604: PPUSH
13605: CALL_OW 307
13609: IFFALSE 13587
// YouLost ( MothContaminate ) ;
13611: LD_STRING MothContaminate
13613: PPUSH
13614: CALL_OW 104
// end ;
13618: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13619: LD_EXP 4
13623: NOT
13624: PUSH
13625: LD_INT 22
13627: PUSH
13628: LD_INT 1
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PUSH
13635: LD_INT 34
13637: PUSH
13638: LD_INT 8
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: PPUSH
13649: CALL_OW 69
13653: AND
13654: IFFALSE 13735
13656: GO 13658
13658: DISABLE
// begin if not IsOk ( Powell ) then
13659: LD_EXP 49
13663: PPUSH
13664: CALL_OW 302
13668: NOT
13669: IFFALSE 13673
// exit ;
13671: GO 13735
// DialogueOn ;
13673: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13677: LD_EXP 49
13681: PPUSH
13682: LD_STRING DWinAmericans-Pow-1
13684: PPUSH
13685: CALL_OW 94
// if IsOk ( Burlak ) then
13689: LD_EXP 46
13693: PPUSH
13694: CALL_OW 302
13698: IFFALSE 13712
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13700: LD_EXP 46
13704: PPUSH
13705: LD_STRING DWinAmericans-Bur-1
13707: PPUSH
13708: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13712: LD_EXP 14
13716: PPUSH
13717: LD_STRING DWinAmericans-JMM-1
13719: PPUSH
13720: CALL_OW 88
// DialogueOff ;
13724: CALL_OW 7
// YouLost ( AmBomb ) ;
13728: LD_STRING AmBomb
13730: PPUSH
13731: CALL_OW 104
// end ;
13735: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13736: LD_EXP 2
13740: NOT
13741: PUSH
13742: LD_INT 22
13744: PUSH
13745: LD_INT 3
13747: PUSH
13748: EMPTY
13749: LIST
13750: LIST
13751: PUSH
13752: LD_INT 34
13754: PUSH
13755: LD_INT 48
13757: PUSH
13758: EMPTY
13759: LIST
13760: LIST
13761: PUSH
13762: EMPTY
13763: LIST
13764: LIST
13765: PPUSH
13766: CALL_OW 69
13770: AND
13771: IFFALSE 13852
13773: GO 13775
13775: DISABLE
// begin if not IsOk ( Platonov ) then
13776: LD_EXP 53
13780: PPUSH
13781: CALL_OW 302
13785: NOT
13786: IFFALSE 13790
// exit ;
13788: GO 13852
// DialogueOn ;
13790: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13794: LD_EXP 53
13798: PPUSH
13799: LD_STRING DWinRussians-Pla-1
13801: PPUSH
13802: CALL_OW 94
// if IsOk ( Burlak ) then
13806: LD_EXP 46
13810: PPUSH
13811: CALL_OW 302
13815: IFFALSE 13829
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13817: LD_EXP 46
13821: PPUSH
13822: LD_STRING DWinRussians-Bur-1
13824: PPUSH
13825: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13829: LD_EXP 14
13833: PPUSH
13834: LD_STRING DWinRussians-JMM-1
13836: PPUSH
13837: CALL_OW 88
// DialogueOff ;
13841: CALL_OW 7
// YouLost ( RuBomb ) ;
13845: LD_STRING RuBomb
13847: PPUSH
13848: CALL_OW 104
// end ;
13852: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13853: LD_INT 7
13855: PPUSH
13856: LD_INT 22
13858: PUSH
13859: LD_INT 7
13861: PUSH
13862: EMPTY
13863: LIST
13864: LIST
13865: PPUSH
13866: CALL_OW 70
13870: PUSH
13871: LD_EXP 4
13875: NOT
13876: AND
13877: IFFALSE 13906
13879: GO 13881
13881: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13882: LD_EXP 49
13886: PPUSH
13887: LD_STRING DSurrenderAmericans-Pow-1
13889: PPUSH
13890: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
13894: LD_EXP 14
13898: PPUSH
13899: LD_STRING DSurrenderAmericans-JMM-1
13901: PPUSH
13902: CALL_OW 88
// end ;
13906: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
13907: LD_INT 2
13909: PPUSH
13910: LD_INT 22
13912: PUSH
13913: LD_INT 7
13915: PUSH
13916: EMPTY
13917: LIST
13918: LIST
13919: PPUSH
13920: CALL_OW 70
13924: PUSH
13925: LD_EXP 2
13929: NOT
13930: AND
13931: PUSH
13932: LD_EXP 46
13936: AND
13937: IFFALSE 13966
13939: GO 13941
13941: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
13942: LD_EXP 53
13946: PPUSH
13947: LD_STRING DSurrenderRussians-Pla-1
13949: PPUSH
13950: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
13954: LD_EXP 46
13958: PPUSH
13959: LD_STRING DSurrenderRussians-Bur-1
13961: PPUSH
13962: CALL_OW 88
// end ;
13966: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
13967: LD_EXP 4
13971: IFFALSE 14346
13973: GO 13975
13975: DISABLE
13976: LD_INT 0
13978: PPUSH
13979: PPUSH
13980: PPUSH
// begin MC_Kill ( 4 ) ;
13981: LD_INT 4
13983: PPUSH
13984: CALL 20491 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
13988: LD_INT 1
13990: PPUSH
13991: LD_INT 7
13993: PPUSH
13994: LD_INT 1
13996: PPUSH
13997: LD_INT 1
13999: PPUSH
14000: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14004: LD_ADDR_VAR 0 3
14008: PUSH
14009: LD_INT 22
14011: PUSH
14012: LD_INT 1
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: PUSH
14019: LD_INT 26
14021: PUSH
14022: LD_INT 1
14024: PUSH
14025: EMPTY
14026: LIST
14027: LIST
14028: PUSH
14029: LD_INT 23
14031: PUSH
14032: LD_INT 1
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: LIST
14043: PPUSH
14044: CALL_OW 69
14048: PUSH
14049: LD_EXP 49
14053: PUSH
14054: LD_EXP 22
14058: PUSH
14059: LD_EXP 19
14063: PUSH
14064: LD_EXP 18
14068: PUSH
14069: LD_EXP 25
14073: PUSH
14074: LD_EXP 23
14078: PUSH
14079: EMPTY
14080: LIST
14081: LIST
14082: LIST
14083: LIST
14084: LIST
14085: LIST
14086: DIFF
14087: ST_TO_ADDR
// if speaker then
14088: LD_VAR 0 3
14092: IFFALSE 14118
// begin DialogueOn ;
14094: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14098: LD_VAR 0 3
14102: PUSH
14103: LD_INT 1
14105: ARRAY
14106: PPUSH
14107: LD_STRING DSurrenderAmericans-Sol1-1a
14109: PPUSH
14110: CALL_OW 94
// DialogueOff ;
14114: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14118: LD_ADDR_VAR 0 2
14122: PUSH
14123: LD_INT 22
14125: PUSH
14126: LD_INT 1
14128: PUSH
14129: EMPTY
14130: LIST
14131: LIST
14132: PUSH
14133: LD_INT 21
14135: PUSH
14136: LD_INT 1
14138: PUSH
14139: EMPTY
14140: LIST
14141: LIST
14142: PUSH
14143: EMPTY
14144: LIST
14145: LIST
14146: PPUSH
14147: CALL_OW 69
14151: PUSH
14152: LD_INT 22
14154: PUSH
14155: LD_INT 1
14157: PUSH
14158: EMPTY
14159: LIST
14160: LIST
14161: PUSH
14162: LD_INT 21
14164: PUSH
14165: LD_INT 2
14167: PUSH
14168: EMPTY
14169: LIST
14170: LIST
14171: PUSH
14172: LD_INT 1
14174: PUSH
14175: EMPTY
14176: LIST
14177: PUSH
14178: EMPTY
14179: LIST
14180: LIST
14181: LIST
14182: PPUSH
14183: CALL_OW 69
14187: ADD
14188: ST_TO_ADDR
// if tmp then
14189: LD_VAR 0 2
14193: IFFALSE 14346
// repeat wait ( 0 0$1 ) ;
14195: LD_INT 35
14197: PPUSH
14198: CALL_OW 67
// for i in tmp do
14202: LD_ADDR_VAR 0 1
14206: PUSH
14207: LD_VAR 0 2
14211: PUSH
14212: FOR_IN
14213: IFFALSE 14295
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14215: LD_VAR 0 1
14219: PPUSH
14220: CALL_OW 310
14224: PUSH
14225: LD_VAR 0 1
14229: PPUSH
14230: CALL_OW 310
14234: PPUSH
14235: CALL_OW 247
14239: PUSH
14240: LD_INT 3
14242: EQUAL
14243: AND
14244: IFFALSE 14255
// ComExitBuilding ( i ) ;
14246: LD_VAR 0 1
14250: PPUSH
14251: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14255: LD_VAR 0 1
14259: PPUSH
14260: LD_INT 122
14262: PPUSH
14263: LD_INT 242
14265: PPUSH
14266: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14270: LD_VAR 0 1
14274: PPUSH
14275: LD_INT 35
14277: PPUSH
14278: CALL_OW 308
14282: IFFALSE 14293
// RemoveUnit ( i ) ;
14284: LD_VAR 0 1
14288: PPUSH
14289: CALL_OW 64
// end ;
14293: GO 14212
14295: POP
14296: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14297: LD_INT 22
14299: PUSH
14300: LD_INT 1
14302: PUSH
14303: EMPTY
14304: LIST
14305: LIST
14306: PUSH
14307: LD_INT 2
14309: PUSH
14310: LD_INT 21
14312: PUSH
14313: LD_INT 1
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: PUSH
14320: LD_INT 33
14322: PUSH
14323: LD_INT 1
14325: PUSH
14326: EMPTY
14327: LIST
14328: LIST
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: LIST
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: PPUSH
14339: CALL_OW 69
14343: NOT
14344: IFFALSE 14195
// end ;
14346: PPOPN 3
14348: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14349: LD_EXP 2
14353: IFFALSE 14746
14355: GO 14357
14357: DISABLE
14358: LD_INT 0
14360: PPUSH
14361: PPUSH
14362: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14363: LD_INT 35
14365: PPUSH
14366: CALL_OW 67
// until IsDead ( Yakotich ) ;
14370: LD_EXP 54
14374: PPUSH
14375: CALL_OW 301
14379: IFFALSE 14363
// MC_Kill ( 2 ) ;
14381: LD_INT 2
14383: PPUSH
14384: CALL 20491 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14388: LD_INT 3
14390: PPUSH
14391: LD_INT 7
14393: PPUSH
14394: LD_INT 1
14396: PPUSH
14397: LD_INT 1
14399: PPUSH
14400: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14404: LD_ADDR_VAR 0 3
14408: PUSH
14409: LD_INT 22
14411: PUSH
14412: LD_INT 3
14414: PUSH
14415: EMPTY
14416: LIST
14417: LIST
14418: PUSH
14419: LD_INT 26
14421: PUSH
14422: LD_INT 1
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: PUSH
14429: LD_INT 23
14431: PUSH
14432: LD_INT 3
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: LIST
14443: PPUSH
14444: CALL_OW 69
14448: PUSH
14449: LD_EXP 53
14453: PUSH
14454: LD_EXP 54
14458: PUSH
14459: EMPTY
14460: LIST
14461: LIST
14462: DIFF
14463: ST_TO_ADDR
// if speaker then
14464: LD_VAR 0 3
14468: IFFALSE 14518
// begin DialogueOn ;
14470: CALL_OW 6
// if Burlak then
14474: LD_EXP 46
14478: IFFALSE 14498
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14480: LD_VAR 0 3
14484: PUSH
14485: LD_INT 1
14487: ARRAY
14488: PPUSH
14489: LD_STRING DSurrenderRussians-RSol1-1
14491: PPUSH
14492: CALL_OW 94
14496: GO 14514
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14498: LD_VAR 0 3
14502: PUSH
14503: LD_INT 1
14505: ARRAY
14506: PPUSH
14507: LD_STRING DSurrenderRussians-RSol1-1a
14509: PPUSH
14510: CALL_OW 94
// DialogueOff ;
14514: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14518: LD_ADDR_VAR 0 2
14522: PUSH
14523: LD_INT 22
14525: PUSH
14526: LD_INT 3
14528: PUSH
14529: EMPTY
14530: LIST
14531: LIST
14532: PUSH
14533: LD_INT 21
14535: PUSH
14536: LD_INT 1
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: PPUSH
14547: CALL_OW 69
14551: PUSH
14552: LD_INT 22
14554: PUSH
14555: LD_INT 3
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: PUSH
14562: LD_INT 21
14564: PUSH
14565: LD_INT 2
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PUSH
14572: LD_INT 1
14574: PUSH
14575: EMPTY
14576: LIST
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: LIST
14582: PPUSH
14583: CALL_OW 69
14587: ADD
14588: ST_TO_ADDR
// if tmp then
14589: LD_VAR 0 2
14593: IFFALSE 14746
// repeat wait ( 0 0$1 ) ;
14595: LD_INT 35
14597: PPUSH
14598: CALL_OW 67
// for i in tmp do
14602: LD_ADDR_VAR 0 1
14606: PUSH
14607: LD_VAR 0 2
14611: PUSH
14612: FOR_IN
14613: IFFALSE 14695
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14615: LD_VAR 0 1
14619: PPUSH
14620: CALL_OW 310
14624: PUSH
14625: LD_VAR 0 1
14629: PPUSH
14630: CALL_OW 310
14634: PPUSH
14635: CALL_OW 247
14639: PUSH
14640: LD_INT 3
14642: EQUAL
14643: AND
14644: IFFALSE 14655
// ComExitBuilding ( i ) ;
14646: LD_VAR 0 1
14650: PPUSH
14651: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14655: LD_VAR 0 1
14659: PPUSH
14660: LD_INT 154
14662: PPUSH
14663: LD_INT 1
14665: PPUSH
14666: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14670: LD_VAR 0 1
14674: PPUSH
14675: LD_INT 36
14677: PPUSH
14678: CALL_OW 308
14682: IFFALSE 14693
// RemoveUnit ( i ) ;
14684: LD_VAR 0 1
14688: PPUSH
14689: CALL_OW 64
// end ;
14693: GO 14612
14695: POP
14696: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14697: LD_INT 22
14699: PUSH
14700: LD_INT 3
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: PUSH
14707: LD_INT 2
14709: PUSH
14710: LD_INT 21
14712: PUSH
14713: LD_INT 1
14715: PUSH
14716: EMPTY
14717: LIST
14718: LIST
14719: PUSH
14720: LD_INT 33
14722: PUSH
14723: LD_INT 1
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: LIST
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: PPUSH
14739: CALL_OW 69
14743: NOT
14744: IFFALSE 14595
// end ;
14746: PPOPN 3
14748: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14749: LD_INT 22
14751: PUSH
14752: LD_INT 8
14754: PUSH
14755: EMPTY
14756: LIST
14757: LIST
14758: PUSH
14759: LD_INT 21
14761: PUSH
14762: LD_INT 1
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: PUSH
14769: LD_INT 23
14771: PUSH
14772: LD_INT 2
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: EMPTY
14780: LIST
14781: LIST
14782: LIST
14783: PPUSH
14784: CALL_OW 69
14788: PUSH
14789: LD_INT 18
14791: LESS
14792: PUSH
14793: LD_EXP 52
14797: PPUSH
14798: CALL_OW 301
14802: OR
14803: PUSH
14804: LD_INT 324
14806: PPUSH
14807: CALL_OW 255
14811: PUSH
14812: LD_INT 7
14814: EQUAL
14815: OR
14816: IFFALSE 14829
14818: GO 14820
14820: DISABLE
// legionDestroyed := true ;
14821: LD_ADDR_EXP 3
14825: PUSH
14826: LD_INT 1
14828: ST_TO_ADDR
14829: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14830: LD_INT 22
14832: PUSH
14833: LD_INT 2
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: PUSH
14840: LD_INT 21
14842: PUSH
14843: LD_INT 1
14845: PUSH
14846: EMPTY
14847: LIST
14848: LIST
14849: PUSH
14850: LD_INT 23
14852: PUSH
14853: LD_INT 2
14855: PUSH
14856: EMPTY
14857: LIST
14858: LIST
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: LIST
14864: PPUSH
14865: CALL_OW 69
14869: PUSH
14870: LD_INT 9
14872: LESS
14873: IFFALSE 14886
14875: GO 14877
14877: DISABLE
// arabianDestroyed := true ;
14878: LD_ADDR_EXP 5
14882: PUSH
14883: LD_INT 1
14885: ST_TO_ADDR
14886: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14887: LD_EXP 5
14891: IFFALSE 15151
14893: GO 14895
14895: DISABLE
14896: LD_INT 0
14898: PPUSH
14899: PPUSH
// begin MC_Kill ( 1 ) ;
14900: LD_INT 1
14902: PPUSH
14903: CALL 20491 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
14907: LD_INT 2
14909: PPUSH
14910: LD_INT 7
14912: PPUSH
14913: LD_INT 1
14915: PPUSH
14916: LD_INT 1
14918: PPUSH
14919: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14923: LD_ADDR_VAR 0 2
14927: PUSH
14928: LD_INT 22
14930: PUSH
14931: LD_INT 2
14933: PUSH
14934: EMPTY
14935: LIST
14936: LIST
14937: PUSH
14938: LD_INT 21
14940: PUSH
14941: LD_INT 1
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PUSH
14948: EMPTY
14949: LIST
14950: LIST
14951: PPUSH
14952: CALL_OW 69
14956: PUSH
14957: LD_INT 22
14959: PUSH
14960: LD_INT 8
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PUSH
14967: LD_INT 21
14969: PUSH
14970: LD_INT 2
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: PUSH
14977: LD_INT 1
14979: PUSH
14980: EMPTY
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: LIST
14987: PPUSH
14988: CALL_OW 69
14992: ADD
14993: ST_TO_ADDR
// if tmp then
14994: LD_VAR 0 2
14998: IFFALSE 15151
// repeat wait ( 0 0$1 ) ;
15000: LD_INT 35
15002: PPUSH
15003: CALL_OW 67
// for i in tmp do
15007: LD_ADDR_VAR 0 1
15011: PUSH
15012: LD_VAR 0 2
15016: PUSH
15017: FOR_IN
15018: IFFALSE 15100
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15020: LD_VAR 0 1
15024: PPUSH
15025: CALL_OW 310
15029: PUSH
15030: LD_VAR 0 1
15034: PPUSH
15035: CALL_OW 310
15039: PPUSH
15040: CALL_OW 247
15044: PUSH
15045: LD_INT 3
15047: EQUAL
15048: AND
15049: IFFALSE 15060
// ComExitBuilding ( i ) ;
15051: LD_VAR 0 1
15055: PPUSH
15056: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15060: LD_VAR 0 1
15064: PPUSH
15065: LD_INT 254
15067: PPUSH
15068: LD_INT 268
15070: PPUSH
15071: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15075: LD_VAR 0 1
15079: PPUSH
15080: LD_INT 34
15082: PPUSH
15083: CALL_OW 308
15087: IFFALSE 15098
// RemoveUnit ( i ) ;
15089: LD_VAR 0 1
15093: PPUSH
15094: CALL_OW 64
// end ;
15098: GO 15017
15100: POP
15101: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15102: LD_INT 22
15104: PUSH
15105: LD_INT 2
15107: PUSH
15108: EMPTY
15109: LIST
15110: LIST
15111: PUSH
15112: LD_INT 2
15114: PUSH
15115: LD_INT 21
15117: PUSH
15118: LD_INT 1
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: PUSH
15125: LD_INT 33
15127: PUSH
15128: LD_INT 1
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: LIST
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PPUSH
15144: CALL_OW 69
15148: NOT
15149: IFFALSE 15000
// end ;
15151: PPOPN 2
15153: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15154: LD_EXP 3
15158: IFFALSE 15502
15160: GO 15162
15162: DISABLE
15163: LD_INT 0
15165: PPUSH
15166: PPUSH
// begin MC_Kill ( 3 ) ;
15167: LD_INT 3
15169: PPUSH
15170: CALL 20491 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15174: LD_INT 8
15176: PPUSH
15177: LD_INT 7
15179: PPUSH
15180: LD_INT 1
15182: PPUSH
15183: LD_INT 1
15185: PPUSH
15186: CALL_OW 80
// DialogueOn ;
15190: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15194: LD_EXP 51
15198: PPUSH
15199: LD_STRING D15-Szulc-1
15201: PPUSH
15202: CALL_OW 94
// DialogueOff ;
15206: CALL_OW 7
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15210: LD_ADDR_VAR 0 1
15214: PUSH
15215: LD_INT 22
15217: PUSH
15218: LD_INT 8
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: PUSH
15225: LD_INT 21
15227: PUSH
15228: LD_INT 3
15230: PUSH
15231: EMPTY
15232: LIST
15233: LIST
15234: PUSH
15235: LD_INT 23
15237: PUSH
15238: LD_INT 3
15240: PUSH
15241: EMPTY
15242: LIST
15243: LIST
15244: PUSH
15245: EMPTY
15246: LIST
15247: LIST
15248: LIST
15249: PPUSH
15250: CALL_OW 69
15254: PUSH
15255: FOR_IN
15256: IFFALSE 15272
// SetLives ( i , 3 ) ;
15258: LD_VAR 0 1
15262: PPUSH
15263: LD_INT 3
15265: PPUSH
15266: CALL_OW 234
15270: GO 15255
15272: POP
15273: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15274: LD_ADDR_VAR 0 2
15278: PUSH
15279: LD_INT 22
15281: PUSH
15282: LD_INT 8
15284: PUSH
15285: EMPTY
15286: LIST
15287: LIST
15288: PUSH
15289: LD_INT 21
15291: PUSH
15292: LD_INT 1
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: PUSH
15299: EMPTY
15300: LIST
15301: LIST
15302: PPUSH
15303: CALL_OW 69
15307: PUSH
15308: LD_INT 22
15310: PUSH
15311: LD_INT 8
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PUSH
15318: LD_INT 21
15320: PUSH
15321: LD_INT 2
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PUSH
15328: LD_INT 1
15330: PUSH
15331: EMPTY
15332: LIST
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: LIST
15338: PPUSH
15339: CALL_OW 69
15343: ADD
15344: ST_TO_ADDR
// if tmp then
15345: LD_VAR 0 2
15349: IFFALSE 15502
// repeat wait ( 0 0$1 ) ;
15351: LD_INT 35
15353: PPUSH
15354: CALL_OW 67
// for i in tmp do
15358: LD_ADDR_VAR 0 1
15362: PUSH
15363: LD_VAR 0 2
15367: PUSH
15368: FOR_IN
15369: IFFALSE 15451
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15371: LD_VAR 0 1
15375: PPUSH
15376: CALL_OW 310
15380: PUSH
15381: LD_VAR 0 1
15385: PPUSH
15386: CALL_OW 310
15390: PPUSH
15391: CALL_OW 247
15395: PUSH
15396: LD_INT 3
15398: EQUAL
15399: AND
15400: IFFALSE 15411
// ComExitBuilding ( i ) ;
15402: LD_VAR 0 1
15406: PPUSH
15407: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15411: LD_VAR 0 1
15415: PPUSH
15416: LD_INT 10
15418: PPUSH
15419: LD_INT 1
15421: PPUSH
15422: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15426: LD_VAR 0 1
15430: PPUSH
15431: LD_INT 32
15433: PPUSH
15434: CALL_OW 308
15438: IFFALSE 15449
// RemoveUnit ( i ) ;
15440: LD_VAR 0 1
15444: PPUSH
15445: CALL_OW 64
// end ;
15449: GO 15368
15451: POP
15452: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15453: LD_INT 22
15455: PUSH
15456: LD_INT 8
15458: PUSH
15459: EMPTY
15460: LIST
15461: LIST
15462: PUSH
15463: LD_INT 2
15465: PUSH
15466: LD_INT 21
15468: PUSH
15469: LD_INT 1
15471: PUSH
15472: EMPTY
15473: LIST
15474: LIST
15475: PUSH
15476: LD_INT 33
15478: PUSH
15479: LD_INT 1
15481: PUSH
15482: EMPTY
15483: LIST
15484: LIST
15485: PUSH
15486: EMPTY
15487: LIST
15488: LIST
15489: LIST
15490: PUSH
15491: EMPTY
15492: LIST
15493: LIST
15494: PPUSH
15495: CALL_OW 69
15499: NOT
15500: IFFALSE 15351
// end ;
15502: PPOPN 2
15504: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do var med1 , med2 ;
15505: LD_EXP 4
15509: PUSH
15510: LD_EXP 2
15514: AND
15515: PUSH
15516: LD_EXP 3
15520: AND
15521: PUSH
15522: LD_EXP 5
15526: AND
15527: IFFALSE 16911
15529: GO 15531
15531: DISABLE
15532: LD_INT 0
15534: PPUSH
15535: PPUSH
// begin music_class := 5 ;
15536: LD_ADDR_OWVAR 72
15540: PUSH
15541: LD_INT 5
15543: ST_TO_ADDR
// music_nat := 5 ;
15544: LD_ADDR_OWVAR 71
15548: PUSH
15549: LD_INT 5
15551: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15552: LD_EXP 12
15556: PUSH
15557: LD_INT 3
15559: LESS
15560: IFFALSE 15569
// SetAchievement ( ACH_ECONOMY ) ;
15562: LD_STRING ACH_ECONOMY
15564: PPUSH
15565: CALL_OW 543
// if tick < 60 60$00 then
15569: LD_OWVAR 1
15573: PUSH
15574: LD_INT 126000
15576: LESS
15577: IFFALSE 15593
// begin wait ( 3 ) ;
15579: LD_INT 3
15581: PPUSH
15582: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15586: LD_STRING ACH_ASPEED_19
15588: PPUSH
15589: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15593: LD_EXP 14
15597: PPUSH
15598: CALL_OW 87
// InGameOn ;
15602: CALL_OW 8
// DialogueOn ;
15606: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15610: LD_EXP 14
15614: PPUSH
15615: LD_STRING DEnd-JMM-JMM-1
15617: PPUSH
15618: CALL_OW 88
// if Joan then
15622: LD_EXP 29
15626: IFFALSE 15642
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15628: LD_EXP 29
15632: PPUSH
15633: LD_STRING DEnd-JMM-Joan-1
15635: PPUSH
15636: CALL_OW 88
15640: GO 15686
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15642: LD_EXP 16
15646: PUSH
15647: LD_EXP 16
15651: PPUSH
15652: CALL_OW 255
15656: PUSH
15657: LD_INT 7
15659: EQUAL
15660: AND
15661: PUSH
15662: LD_EXP 16
15666: PPUSH
15667: CALL_OW 305
15671: AND
15672: IFFALSE 15686
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15674: LD_EXP 16
15678: PPUSH
15679: LD_STRING DEnd-JMM-Lisa-1
15681: PPUSH
15682: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15686: LD_EXP 26
15690: PUSH
15691: LD_EXP 26
15695: PPUSH
15696: CALL_OW 305
15700: AND
15701: IFFALSE 15715
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15703: LD_EXP 26
15707: PPUSH
15708: LD_STRING DEnd-JMM-Frank-1
15710: PPUSH
15711: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15715: LD_EXP 19
15719: PUSH
15720: LD_EXP 19
15724: PPUSH
15725: CALL_OW 255
15729: PUSH
15730: LD_INT 7
15732: EQUAL
15733: AND
15734: PUSH
15735: LD_EXP 19
15739: PPUSH
15740: CALL_OW 305
15744: AND
15745: IFFALSE 15759
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15747: LD_EXP 19
15751: PPUSH
15752: LD_STRING DEnd-JMM-Cyrus-1
15754: PPUSH
15755: CALL_OW 88
// if Burlak then
15759: LD_EXP 46
15763: IFFALSE 15777
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15765: LD_EXP 46
15769: PPUSH
15770: LD_STRING DEnd-JMM-Bur-1
15772: PPUSH
15773: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15777: LD_EXP 29
15781: PUSH
15782: LD_EXP 16
15786: AND
15787: PUSH
15788: LD_EXP 16
15792: PPUSH
15793: CALL_OW 255
15797: PUSH
15798: LD_INT 7
15800: EQUAL
15801: AND
15802: PUSH
15803: LD_EXP 16
15807: PPUSH
15808: CALL_OW 305
15812: AND
15813: IFFALSE 15827
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15815: LD_EXP 16
15819: PPUSH
15820: LD_STRING DEnd-Burlak-Lisa-1
15822: PPUSH
15823: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15827: LD_EXP 47
15831: PUSH
15832: LD_EXP 47
15836: PPUSH
15837: CALL_OW 305
15841: AND
15842: IFFALSE 15856
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15844: LD_EXP 47
15848: PPUSH
15849: LD_STRING DEnd-JMM-Bel-1
15851: PPUSH
15852: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15856: LD_EXP 48
15860: PUSH
15861: LD_EXP 48
15865: PPUSH
15866: CALL_OW 305
15870: AND
15871: IFFALSE 15885
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15873: LD_EXP 48
15877: PPUSH
15878: LD_STRING DEnd-JMM-Gny-1
15880: PPUSH
15881: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15885: LD_EXP 24
15889: PUSH
15890: LD_EXP 24
15894: PPUSH
15895: CALL_OW 255
15899: PUSH
15900: LD_INT 7
15902: EQUAL
15903: AND
15904: PUSH
15905: LD_EXP 24
15909: PPUSH
15910: CALL_OW 305
15914: AND
15915: IFFALSE 15929
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
15917: LD_EXP 24
15921: PPUSH
15922: LD_STRING DEnd-JMM-Corn-1
15924: PPUSH
15925: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
15929: LD_EXP 17
15933: PUSH
15934: LD_EXP 17
15938: PPUSH
15939: CALL_OW 255
15943: PUSH
15944: LD_INT 7
15946: EQUAL
15947: AND
15948: PUSH
15949: LD_EXP 17
15953: PPUSH
15954: CALL_OW 305
15958: AND
15959: IFFALSE 15973
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
15961: LD_EXP 17
15965: PPUSH
15966: LD_STRING DEnd-JMM-Don-1
15968: PPUSH
15969: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
15973: LD_EXP 18
15977: PUSH
15978: LD_EXP 18
15982: PPUSH
15983: CALL_OW 255
15987: PUSH
15988: LD_INT 7
15990: EQUAL
15991: AND
15992: PUSH
15993: LD_EXP 18
15997: PPUSH
15998: CALL_OW 305
16002: AND
16003: IFFALSE 16017
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16005: LD_EXP 18
16009: PPUSH
16010: LD_STRING DEnd-JMM-Bobby-1
16012: PPUSH
16013: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16017: LD_EXP 20
16021: PUSH
16022: LD_EXP 20
16026: PPUSH
16027: CALL_OW 255
16031: PUSH
16032: LD_INT 7
16034: EQUAL
16035: AND
16036: PUSH
16037: LD_EXP 20
16041: PPUSH
16042: CALL_OW 305
16046: AND
16047: IFFALSE 16061
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16049: LD_EXP 20
16053: PPUSH
16054: LD_STRING DEnd-JMM-Den-1
16056: PPUSH
16057: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16061: LD_EXP 22
16065: PUSH
16066: LD_EXP 22
16070: PPUSH
16071: CALL_OW 255
16075: PUSH
16076: LD_INT 7
16078: EQUAL
16079: AND
16080: PUSH
16081: LD_EXP 22
16085: PPUSH
16086: CALL_OW 305
16090: AND
16091: IFFALSE 16105
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16093: LD_EXP 22
16097: PPUSH
16098: LD_STRING DEnd-JMM-Glad-1
16100: PPUSH
16101: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16105: LD_EXP 27
16109: PUSH
16110: LD_EXP 27
16114: PPUSH
16115: CALL_OW 255
16119: PUSH
16120: LD_INT 7
16122: EQUAL
16123: AND
16124: PUSH
16125: LD_EXP 27
16129: PPUSH
16130: CALL_OW 305
16134: AND
16135: IFFALSE 16149
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16137: LD_EXP 27
16141: PPUSH
16142: LD_STRING DEnd-JMM-Yam-1
16144: PPUSH
16145: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16149: LD_EXP 21
16153: PUSH
16154: LD_EXP 21
16158: PPUSH
16159: CALL_OW 255
16163: PUSH
16164: LD_INT 7
16166: EQUAL
16167: AND
16168: PUSH
16169: LD_EXP 21
16173: PPUSH
16174: CALL_OW 305
16178: AND
16179: IFFALSE 16193
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16181: LD_EXP 21
16185: PPUSH
16186: LD_STRING DEnd-JMM-Brown-1
16188: PPUSH
16189: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16193: LD_EXP 31
16197: PUSH
16198: LD_EXP 31
16202: PPUSH
16203: CALL_OW 255
16207: PUSH
16208: LD_INT 7
16210: EQUAL
16211: AND
16212: PUSH
16213: LD_EXP 31
16217: PPUSH
16218: CALL_OW 305
16222: AND
16223: IFFALSE 16237
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16225: LD_EXP 31
16229: PPUSH
16230: LD_STRING DEnd-JMM-Con-1
16232: PPUSH
16233: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16237: LD_EXP 25
16241: PUSH
16242: LD_EXP 25
16246: PPUSH
16247: CALL_OW 255
16251: PUSH
16252: LD_INT 7
16254: EQUAL
16255: AND
16256: PUSH
16257: LD_EXP 25
16261: PPUSH
16262: CALL_OW 305
16266: AND
16267: IFFALSE 16281
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16269: LD_EXP 25
16273: PPUSH
16274: LD_STRING DEnd-JMM-Gary-1
16276: PPUSH
16277: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16281: LD_EXP 28
16285: PUSH
16286: LD_EXP 15
16290: AND
16291: PUSH
16292: LD_EXP 28
16296: PPUSH
16297: CALL_OW 305
16301: AND
16302: IFFALSE 16316
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16304: LD_EXP 28
16308: PPUSH
16309: LD_STRING DEnd-JMM-Sim-1
16311: PPUSH
16312: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16316: LD_EXP 23
16320: PUSH
16321: LD_EXP 23
16325: PPUSH
16326: CALL_OW 255
16330: PUSH
16331: LD_INT 7
16333: EQUAL
16334: AND
16335: PUSH
16336: LD_EXP 23
16340: PPUSH
16341: CALL_OW 305
16345: AND
16346: IFFALSE 16360
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16348: LD_EXP 23
16352: PPUSH
16353: LD_STRING DEnd-JMM-VanH-1
16355: PPUSH
16356: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16360: LD_EXP 36
16364: PUSH
16365: LD_EXP 36
16369: PPUSH
16370: CALL_OW 305
16374: AND
16375: IFFALSE 16389
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16377: LD_EXP 36
16381: PPUSH
16382: LD_STRING DEnd-JMM-Dol-1
16384: PPUSH
16385: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16389: LD_EXP 40
16393: PUSH
16394: LD_EXP 40
16398: PPUSH
16399: CALL_OW 305
16403: AND
16404: IFFALSE 16418
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16406: LD_EXP 40
16410: PPUSH
16411: LD_STRING DEnd-JMM-Kap-1
16413: PPUSH
16414: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16418: LD_EXP 43
16422: PUSH
16423: LD_EXP 43
16427: PPUSH
16428: CALL_OW 305
16432: AND
16433: IFFALSE 16447
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16435: LD_EXP 43
16439: PPUSH
16440: LD_STRING DEnd-JMM-Kov-1
16442: PPUSH
16443: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16447: LD_EXP 38
16451: PUSH
16452: LD_EXP 38
16456: PPUSH
16457: CALL_OW 305
16461: AND
16462: IFFALSE 16476
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16464: LD_EXP 38
16468: PPUSH
16469: LD_STRING DEnd-JMM-Sch-1
16471: PPUSH
16472: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16476: LD_EXP 34
16480: PUSH
16481: LD_EXP 34
16485: PPUSH
16486: CALL_OW 305
16490: AND
16491: IFFALSE 16505
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16493: LD_EXP 34
16497: PPUSH
16498: LD_STRING DEnd-JMM-Tit-1
16500: PPUSH
16501: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16505: LD_EXP 39
16509: PUSH
16510: LD_EXP 39
16514: PPUSH
16515: CALL_OW 305
16519: AND
16520: IFFALSE 16534
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16522: LD_EXP 39
16526: PPUSH
16527: LD_STRING DEnd-JMM-Obl-1
16529: PPUSH
16530: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16534: LD_EXP 41
16538: PUSH
16539: LD_EXP 41
16543: PPUSH
16544: CALL_OW 305
16548: AND
16549: IFFALSE 16563
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16551: LD_EXP 41
16555: PPUSH
16556: LD_STRING DEnd-JMM-Lip-1
16558: PPUSH
16559: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16563: LD_EXP 35
16567: PUSH
16568: LD_EXP 35
16572: PPUSH
16573: CALL_OW 305
16577: AND
16578: PUSH
16579: LD_EXP 46
16583: AND
16584: IFFALSE 16598
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16586: LD_EXP 35
16590: PPUSH
16591: LD_STRING DEnd-Burlak-Fad-1
16593: PPUSH
16594: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16598: LD_EXP 42
16602: PUSH
16603: LD_EXP 42
16607: PPUSH
16608: CALL_OW 305
16612: AND
16613: IFFALSE 16627
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16615: LD_EXP 42
16619: PPUSH
16620: LD_STRING DEnd-Burlak-Ptr-1
16622: PPUSH
16623: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16627: LD_EXP 44
16631: PUSH
16632: LD_EXP 44
16636: PPUSH
16637: CALL_OW 305
16641: AND
16642: IFFALSE 16656
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16644: LD_EXP 44
16648: PPUSH
16649: LD_STRING DEnd-Burlak-Kuz-1
16651: PPUSH
16652: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16656: LD_EXP 33
16660: PUSH
16661: LD_EXP 33
16665: PPUSH
16666: CALL_OW 305
16670: AND
16671: PUSH
16672: LD_EXP 46
16676: AND
16677: IFFALSE 16691
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16679: LD_EXP 33
16683: PPUSH
16684: LD_STRING DEnd-Burlak-Kir-1
16686: PPUSH
16687: CALL_OW 88
// if Burlak then
16691: LD_EXP 46
16695: IFFALSE 16709
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16697: LD_EXP 14
16701: PPUSH
16702: LD_STRING DEnd-Burlak-JMM-1
16704: PPUSH
16705: CALL_OW 88
// dwait ( 0 0$2 ) ;
16709: LD_INT 70
16711: PPUSH
16712: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16716: LD_EXP 51
16720: PPUSH
16721: LD_STRING DEnd-Szulc
16723: PPUSH
16724: CALL_OW 94
// dwait ( 0 0$1 ) ;
16728: LD_INT 35
16730: PPUSH
16731: CALL_OW 68
// if IsLive ( Burlak ) then
16735: LD_EXP 46
16739: PPUSH
16740: CALL_OW 300
16744: IFFALSE 16756
// med1 := 1 else
16746: LD_ADDR_VAR 0 1
16750: PUSH
16751: LD_INT 1
16753: ST_TO_ADDR
16754: GO 16765
// med1 := - 1 ;
16756: LD_ADDR_VAR 0 1
16760: PUSH
16761: LD_INT 1
16763: NEG
16764: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16765: LD_EXP 9
16769: PUSH
16770: LD_EXP 10
16774: AND
16775: PUSH
16776: LD_EXP 11
16780: AND
16781: IFFALSE 16793
// med2 := 1 else
16783: LD_ADDR_VAR 0 2
16787: PUSH
16788: LD_INT 1
16790: ST_TO_ADDR
16791: GO 16802
// med2 := - 1 ;
16793: LD_ADDR_VAR 0 2
16797: PUSH
16798: LD_INT 1
16800: NEG
16801: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
16802: LD_STRING Hero
16804: PPUSH
16805: LD_INT 1
16807: PPUSH
16808: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
16812: LD_STRING Artefact
16814: PPUSH
16815: LD_VAR 0 2
16819: PPUSH
16820: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
16824: LD_STRING ReconcileBurlak
16826: PPUSH
16827: LD_VAR 0 1
16831: PPUSH
16832: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
16836: LD_OWVAR 67
16840: PUSH
16841: LD_INT 3
16843: EQUAL
16844: PUSH
16845: LD_VAR 0 1
16849: PUSH
16850: LD_INT 1
16852: EQUAL
16853: AND
16854: PUSH
16855: LD_VAR 0 2
16859: PUSH
16860: LD_INT 1
16862: EQUAL
16863: AND
16864: IFFALSE 16876
// SetAchievementEX ( ACH_AMER , 19 ) ;
16866: LD_STRING ACH_AMER
16868: PPUSH
16869: LD_INT 19
16871: PPUSH
16872: CALL_OW 564
// GiveMedals ( MAIN ) ;
16876: LD_STRING MAIN
16878: PPUSH
16879: CALL_OW 102
// InGameOff ;
16883: CALL_OW 9
// DialogueOff ;
16887: CALL_OW 7
// music_nat := 1 ;
16891: LD_ADDR_OWVAR 71
16895: PUSH
16896: LD_INT 1
16898: ST_TO_ADDR
// music_class := 4 ;
16899: LD_ADDR_OWVAR 72
16903: PUSH
16904: LD_INT 4
16906: ST_TO_ADDR
// YouWin ;
16907: CALL_OW 103
// end ; end_of_file
16911: PPOPN 2
16913: END
// export function InitNature ; begin
16914: LD_INT 0
16916: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
16917: LD_INT 3
16919: PPUSH
16920: LD_INT 3
16922: PPUSH
16923: LD_INT 2
16925: PPUSH
16926: LD_INT 1
16928: PPUSH
16929: LD_INT 1
16931: PPUSH
16932: LD_INT 0
16934: PPUSH
16935: LD_INT 0
16937: PPUSH
16938: LD_INT 17
16940: PPUSH
16941: LD_INT 0
16943: PPUSH
16944: CALL 85224 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
16948: LD_INT 2
16950: PPUSH
16951: LD_INT 1
16953: PPUSH
16954: LD_INT 1
16956: PPUSH
16957: LD_INT 1
16959: PPUSH
16960: LD_INT 1
16962: PPUSH
16963: LD_INT 0
16965: PPUSH
16966: LD_INT 0
16968: PPUSH
16969: LD_INT 18
16971: PPUSH
16972: LD_INT 0
16974: PPUSH
16975: CALL 85224 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
16979: LD_INT 4
16981: PPUSH
16982: LD_INT 1
16984: PPUSH
16985: LD_INT 2
16987: PPUSH
16988: LD_INT 4
16990: PPUSH
16991: LD_INT 2
16993: PPUSH
16994: LD_INT 1
16996: PPUSH
16997: LD_INT 0
16999: PPUSH
17000: LD_INT 19
17002: PPUSH
17003: LD_INT 0
17005: PPUSH
17006: CALL 85224 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17010: LD_INT 0
17012: PPUSH
17013: LD_INT 0
17015: PPUSH
17016: LD_INT 0
17018: PPUSH
17019: LD_INT 0
17021: PPUSH
17022: LD_INT 0
17024: PPUSH
17025: LD_INT 0
17027: PPUSH
17028: LD_INT 9
17030: PPUSH
17031: LD_INT 0
17033: PPUSH
17034: LD_INT 20
17036: PPUSH
17037: CALL 85224 0 9
// end ; end_of_file
17041: LD_VAR 0 1
17045: RET
// every 0 0$30 do var time ;
17046: GO 17048
17048: DISABLE
17049: LD_INT 0
17051: PPUSH
// begin time := 0 0$50 ;
17052: LD_ADDR_VAR 0 1
17056: PUSH
17057: LD_INT 1750
17059: ST_TO_ADDR
// repeat wait ( time ) ;
17060: LD_VAR 0 1
17064: PPUSH
17065: CALL_OW 67
// if Prob ( 50 ) then
17069: LD_INT 50
17071: PPUSH
17072: CALL_OW 13
17076: IFFALSE 17105
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17078: LD_INT 1
17080: PPUSH
17081: LD_INT 5
17083: PPUSH
17084: CALL_OW 12
17088: PPUSH
17089: LD_INT 106
17091: PPUSH
17092: LD_INT 89
17094: PPUSH
17095: LD_INT 45
17097: PPUSH
17098: LD_INT 1
17100: PPUSH
17101: CALL_OW 56
// time := time + 0 0$3 ;
17105: LD_ADDR_VAR 0 1
17109: PUSH
17110: LD_VAR 0 1
17114: PUSH
17115: LD_INT 105
17117: PLUS
17118: ST_TO_ADDR
// if Prob ( 30 ) then
17119: LD_INT 30
17121: PPUSH
17122: CALL_OW 13
17126: IFFALSE 17172
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17128: LD_INT 525
17130: PPUSH
17131: LD_INT 735
17133: PPUSH
17134: CALL_OW 12
17138: PPUSH
17139: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17143: LD_INT 1
17145: PPUSH
17146: LD_INT 5
17148: PPUSH
17149: CALL_OW 12
17153: PPUSH
17154: LD_INT 21
17156: PPUSH
17157: LD_INT 26
17159: PPUSH
17160: LD_INT 12
17162: PPUSH
17163: LD_INT 1
17165: PPUSH
17166: CALL_OW 56
// end else
17170: GO 17208
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17172: LD_INT 700
17174: PPUSH
17175: LD_INT 1225
17177: PPUSH
17178: CALL_OW 12
17182: PPUSH
17183: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17187: LD_INT 1
17189: PPUSH
17190: LD_INT 5
17192: PPUSH
17193: CALL_OW 12
17197: PPUSH
17198: LD_INT 14
17200: PPUSH
17201: LD_INT 1
17203: PPUSH
17204: CALL_OW 55
// end ; if Prob ( 50 ) then
17208: LD_INT 50
17210: PPUSH
17211: CALL_OW 13
17215: IFFALSE 17261
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17217: LD_INT 700
17219: PPUSH
17220: LD_INT 1050
17222: PPUSH
17223: CALL_OW 12
17227: PPUSH
17228: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17232: LD_INT 1
17234: PPUSH
17235: LD_INT 5
17237: PPUSH
17238: CALL_OW 12
17242: PPUSH
17243: LD_INT 181
17245: PPUSH
17246: LD_INT 218
17248: PPUSH
17249: LD_INT 16
17251: PPUSH
17252: LD_INT 1
17254: PPUSH
17255: CALL_OW 56
// end else
17259: GO 17333
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17261: LD_INT 350
17263: PPUSH
17264: LD_INT 525
17266: PPUSH
17267: CALL_OW 12
17271: PPUSH
17272: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17276: LD_INT 1
17278: PPUSH
17279: LD_INT 5
17281: PPUSH
17282: CALL_OW 12
17286: PPUSH
17287: LD_INT 13
17289: PPUSH
17290: LD_INT 1
17292: PPUSH
17293: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17297: LD_INT 350
17299: PPUSH
17300: LD_INT 700
17302: PPUSH
17303: CALL_OW 12
17307: PPUSH
17308: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17312: LD_INT 1
17314: PPUSH
17315: LD_INT 5
17317: PPUSH
17318: CALL_OW 12
17322: PPUSH
17323: LD_INT 33
17325: PPUSH
17326: LD_INT 1
17328: PPUSH
17329: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17333: LD_INT 65
17335: PUSH
17336: LD_INT 62
17338: PUSH
17339: LD_INT 55
17341: PUSH
17342: EMPTY
17343: LIST
17344: LIST
17345: LIST
17346: PUSH
17347: LD_OWVAR 67
17351: ARRAY
17352: PPUSH
17353: CALL_OW 13
17357: IFFALSE 17403
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17359: LD_INT 525
17361: PPUSH
17362: LD_INT 875
17364: PPUSH
17365: CALL_OW 12
17369: PPUSH
17370: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17374: LD_INT 1
17376: PPUSH
17377: LD_INT 5
17379: PPUSH
17380: CALL_OW 12
17384: PPUSH
17385: LD_INT 294
17387: PPUSH
17388: LD_INT 211
17390: PPUSH
17391: LD_INT 30
17393: PPUSH
17394: LD_INT 1
17396: PPUSH
17397: CALL_OW 56
// end else
17401: GO 17445
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17403: LD_INT 420
17405: PPUSH
17406: LD_INT 770
17408: PPUSH
17409: CALL_OW 12
17413: PPUSH
17414: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17418: LD_INT 1
17420: PPUSH
17421: LD_INT 5
17423: PPUSH
17424: CALL_OW 12
17428: PPUSH
17429: LD_INT 294
17431: PPUSH
17432: LD_INT 211
17434: PPUSH
17435: LD_INT 30
17437: PPUSH
17438: LD_INT 1
17440: PPUSH
17441: CALL_OW 56
// end ; if time > 2 2$20 then
17445: LD_VAR 0 1
17449: PUSH
17450: LD_INT 4900
17452: GREATER
17453: IFFALSE 17463
// time := 0 0$50 ;
17455: LD_ADDR_VAR 0 1
17459: PUSH
17460: LD_INT 1750
17462: ST_TO_ADDR
// until false ;
17463: LD_INT 0
17465: IFFALSE 17060
// end ;
17467: PPOPN 1
17469: END
// every 0 0$45 trigger tick < 10 10$00 do
17470: LD_OWVAR 1
17474: PUSH
17475: LD_INT 21000
17477: LESS
17478: IFFALSE 17526
17480: GO 17482
17482: DISABLE
// begin enable ;
17483: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17484: LD_INT 350
17486: PPUSH
17487: LD_INT 700
17489: PPUSH
17490: CALL_OW 12
17494: PPUSH
17495: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17499: LD_INT 3
17501: PPUSH
17502: LD_INT 5
17504: PPUSH
17505: CALL_OW 12
17509: PPUSH
17510: LD_INT 181
17512: PPUSH
17513: LD_INT 13
17515: PPUSH
17516: LD_INT 20
17518: PPUSH
17519: LD_INT 1
17521: PPUSH
17522: CALL_OW 56
// end ; end_of_file
17526: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17527: LD_INT 0
17529: PPUSH
// SetArtifactRes ( 7 , true ) ;
17530: LD_INT 7
17532: PPUSH
17533: LD_INT 1
17535: PPUSH
17536: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17540: LD_ADDR_EXP 59
17544: PUSH
17545: EMPTY
17546: PUSH
17547: EMPTY
17548: PUSH
17549: EMPTY
17550: PUSH
17551: EMPTY
17552: LIST
17553: LIST
17554: LIST
17555: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17556: LD_ADDR_EXP 60
17560: PUSH
17561: LD_INT 1050
17563: PUSH
17564: LD_OWVAR 67
17568: MUL
17569: PUSH
17570: LD_INT 2800
17572: PUSH
17573: LD_OWVAR 67
17577: MUL
17578: PUSH
17579: LD_INT 1
17581: NEG
17582: PUSH
17583: EMPTY
17584: LIST
17585: LIST
17586: LIST
17587: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17588: LD_ADDR_EXP 61
17592: PUSH
17593: LD_INT 10
17595: PUSH
17596: LD_INT 35
17598: PUSH
17599: LD_INT 100
17601: PUSH
17602: EMPTY
17603: LIST
17604: LIST
17605: LIST
17606: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17607: LD_ADDR_EXP 62
17611: PUSH
17612: LD_INT 0
17614: PUSH
17615: LD_INT 0
17617: PUSH
17618: LD_INT 0
17620: PUSH
17621: EMPTY
17622: LIST
17623: LIST
17624: LIST
17625: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17626: LD_ADDR_EXP 64
17630: PUSH
17631: LD_INT 300
17633: PUSH
17634: LD_INT 500
17636: PUSH
17637: LD_INT 800
17639: PUSH
17640: EMPTY
17641: LIST
17642: LIST
17643: LIST
17644: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17645: LD_ADDR_EXP 65
17649: PUSH
17650: LD_INT 0
17652: PUSH
17653: LD_INT 0
17655: PUSH
17656: LD_INT 0
17658: PUSH
17659: EMPTY
17660: LIST
17661: LIST
17662: LIST
17663: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17664: LD_ADDR_EXP 66
17668: PUSH
17669: LD_INT 0
17671: PUSH
17672: LD_INT 0
17674: PUSH
17675: LD_INT 0
17677: PUSH
17678: EMPTY
17679: LIST
17680: LIST
17681: LIST
17682: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17683: LD_ADDR_EXP 63
17687: PUSH
17688: LD_INT 0
17690: PUSH
17691: LD_INT 0
17693: PUSH
17694: LD_INT 0
17696: PUSH
17697: EMPTY
17698: LIST
17699: LIST
17700: LIST
17701: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17702: LD_ADDR_EXP 67
17706: PUSH
17707: LD_INT 4
17709: PUSH
17710: LD_INT 3
17712: PUSH
17713: LD_INT 1
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: LIST
17720: PUSH
17721: LD_INT 5
17723: PUSH
17724: LD_INT 4
17726: PUSH
17727: LD_INT 2
17729: PUSH
17730: EMPTY
17731: LIST
17732: LIST
17733: LIST
17734: PUSH
17735: LD_INT 6
17737: PUSH
17738: LD_INT 3
17740: PUSH
17741: LD_INT 3
17743: PUSH
17744: EMPTY
17745: LIST
17746: LIST
17747: LIST
17748: PUSH
17749: EMPTY
17750: LIST
17751: LIST
17752: LIST
17753: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17754: LD_ADDR_EXP 68
17758: PUSH
17759: LD_INT 0
17761: PUSH
17762: LD_INT 0
17764: PUSH
17765: LD_INT 0
17767: PUSH
17768: EMPTY
17769: LIST
17770: LIST
17771: LIST
17772: ST_TO_ADDR
// end ;
17773: LD_VAR 0 1
17777: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17778: LD_INT 24
17780: PPUSH
17781: LD_INT 7
17783: PPUSH
17784: CALL_OW 321
17788: PUSH
17789: LD_INT 2
17791: EQUAL
17792: IFFALSE 18718
17794: GO 17796
17796: DISABLE
17797: LD_INT 0
17799: PPUSH
17800: PPUSH
17801: PPUSH
17802: PPUSH
17803: PPUSH
// begin enable ;
17804: ENABLE
// for i = 1 to 3 do
17805: LD_ADDR_VAR 0 1
17809: PUSH
17810: DOUBLE
17811: LD_INT 1
17813: DEC
17814: ST_TO_ADDR
17815: LD_INT 3
17817: PUSH
17818: FOR_TO
17819: IFFALSE 18716
// begin pos := FindArtifact ( i + 2 ) ;
17821: LD_ADDR_VAR 0 2
17825: PUSH
17826: LD_VAR 0 1
17830: PUSH
17831: LD_INT 2
17833: PLUS
17834: PPUSH
17835: CALL_OW 469
17839: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17840: LD_ADDR_EXP 59
17844: PUSH
17845: LD_EXP 59
17849: PPUSH
17850: LD_VAR 0 1
17854: PPUSH
17855: LD_VAR 0 2
17859: PPUSH
17860: CALL_OW 1
17864: ST_TO_ADDR
// if pos then
17865: LD_VAR 0 2
17869: IFFALSE 18577
// begin case i of 1 :
17871: LD_VAR 0 1
17875: PUSH
17876: LD_INT 1
17878: DOUBLE
17879: EQUAL
17880: IFTRUE 17884
17882: GO 17961
17884: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17885: LD_ADDR_VAR 0 4
17889: PUSH
17890: LD_INT 22
17892: PUSH
17893: LD_INT 7
17895: PUSH
17896: EMPTY
17897: LIST
17898: LIST
17899: PUSH
17900: LD_INT 23
17902: PUSH
17903: LD_INT 1
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: PUSH
17910: LD_INT 2
17912: PUSH
17913: LD_INT 30
17915: PUSH
17916: LD_INT 8
17918: PUSH
17919: EMPTY
17920: LIST
17921: LIST
17922: PUSH
17923: LD_INT 30
17925: PUSH
17926: LD_INT 7
17928: PUSH
17929: EMPTY
17930: LIST
17931: LIST
17932: PUSH
17933: LD_INT 30
17935: PUSH
17936: LD_INT 11
17938: PUSH
17939: EMPTY
17940: LIST
17941: LIST
17942: PUSH
17943: EMPTY
17944: LIST
17945: LIST
17946: LIST
17947: LIST
17948: PUSH
17949: EMPTY
17950: LIST
17951: LIST
17952: LIST
17953: PPUSH
17954: CALL_OW 69
17958: ST_TO_ADDR
17959: GO 18069
17961: LD_INT 2
17963: DOUBLE
17964: EQUAL
17965: IFTRUE 17969
17967: GO 18046
17969: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
17970: LD_ADDR_VAR 0 4
17974: PUSH
17975: LD_INT 22
17977: PUSH
17978: LD_INT 7
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PUSH
17985: LD_INT 23
17987: PUSH
17988: LD_INT 3
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PUSH
17995: LD_INT 2
17997: PUSH
17998: LD_INT 30
18000: PUSH
18001: LD_INT 8
18003: PUSH
18004: EMPTY
18005: LIST
18006: LIST
18007: PUSH
18008: LD_INT 30
18010: PUSH
18011: LD_INT 7
18013: PUSH
18014: EMPTY
18015: LIST
18016: LIST
18017: PUSH
18018: LD_INT 30
18020: PUSH
18021: LD_INT 11
18023: PUSH
18024: EMPTY
18025: LIST
18026: LIST
18027: PUSH
18028: EMPTY
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: LIST
18038: PPUSH
18039: CALL_OW 69
18043: ST_TO_ADDR
18044: GO 18069
18046: LD_INT 3
18048: DOUBLE
18049: EQUAL
18050: IFTRUE 18054
18052: GO 18068
18054: POP
// labs := [ alien ] ; end ;
18055: LD_ADDR_VAR 0 4
18059: PUSH
18060: LD_INT 1
18062: PUSH
18063: EMPTY
18064: LIST
18065: ST_TO_ADDR
18066: GO 18069
18068: POP
// if not labs then
18069: LD_VAR 0 4
18073: NOT
18074: IFFALSE 18078
// continue ;
18076: GO 17818
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18078: LD_ADDR_VAR 0 5
18082: PUSH
18083: LD_VAR 0 4
18087: PPUSH
18088: LD_EXP 59
18092: PUSH
18093: LD_VAR 0 1
18097: ARRAY
18098: PUSH
18099: LD_INT 1
18101: ARRAY
18102: PPUSH
18103: LD_EXP 59
18107: PUSH
18108: LD_VAR 0 1
18112: ARRAY
18113: PUSH
18114: LD_INT 2
18116: ARRAY
18117: PPUSH
18118: CALL_OW 73
18122: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18123: LD_VAR 0 5
18127: NOT
18128: PUSH
18129: LD_VAR 0 5
18133: PUSH
18134: LD_EXP 66
18138: PUSH
18139: LD_VAR 0 1
18143: ARRAY
18144: NONEQUAL
18145: OR
18146: IFFALSE 18251
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18148: LD_INT 7
18150: PPUSH
18151: LD_EXP 67
18155: PUSH
18156: LD_VAR 0 1
18160: ARRAY
18161: PUSH
18162: LD_INT 3
18164: ARRAY
18165: PPUSH
18166: LD_INT 0
18168: PPUSH
18169: LD_EXP 66
18173: PUSH
18174: LD_VAR 0 1
18178: ARRAY
18179: PPUSH
18180: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18184: LD_INT 7
18186: PPUSH
18187: LD_EXP 67
18191: PUSH
18192: LD_VAR 0 1
18196: ARRAY
18197: PUSH
18198: LD_INT 1
18200: ARRAY
18201: PPUSH
18202: LD_INT 0
18204: PPUSH
18205: LD_EXP 66
18209: PUSH
18210: LD_VAR 0 1
18214: ARRAY
18215: PPUSH
18216: CALL_OW 468
// if nearestLab then
18220: LD_VAR 0 5
18224: IFFALSE 18251
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18226: LD_ADDR_EXP 66
18230: PUSH
18231: LD_EXP 66
18235: PPUSH
18236: LD_VAR 0 1
18240: PPUSH
18241: LD_VAR 0 5
18245: PPUSH
18246: CALL_OW 1
18250: ST_TO_ADDR
// end ; if not nearestLab then
18251: LD_VAR 0 5
18255: NOT
18256: IFFALSE 18260
// continue ;
18258: GO 17818
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18260: LD_VAR 0 5
18264: PPUSH
18265: LD_EXP 59
18269: PUSH
18270: LD_VAR 0 1
18274: ARRAY
18275: PUSH
18276: LD_INT 1
18278: ARRAY
18279: PPUSH
18280: LD_EXP 59
18284: PUSH
18285: LD_VAR 0 1
18289: ARRAY
18290: PUSH
18291: LD_INT 2
18293: ARRAY
18294: PPUSH
18295: CALL_OW 297
18299: PUSH
18300: LD_INT 8
18302: LESS
18303: IFFALSE 18500
// begin if not artifactsResearched [ i ] then
18305: LD_EXP 62
18309: PUSH
18310: LD_VAR 0 1
18314: ARRAY
18315: NOT
18316: IFFALSE 18397
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18318: LD_VAR 0 5
18322: PPUSH
18323: CALL_OW 461
18327: PUSH
18328: LD_INT 2
18330: EQUAL
18331: IFFALSE 18365
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18333: LD_INT 7
18335: PPUSH
18336: LD_EXP 67
18340: PUSH
18341: LD_VAR 0 1
18345: ARRAY
18346: PUSH
18347: LD_INT 3
18349: ARRAY
18350: PPUSH
18351: LD_INT 2
18353: PPUSH
18354: LD_VAR 0 5
18358: PPUSH
18359: CALL_OW 468
18363: GO 18395
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18365: LD_INT 7
18367: PPUSH
18368: LD_EXP 67
18372: PUSH
18373: LD_VAR 0 1
18377: ARRAY
18378: PUSH
18379: LD_INT 3
18381: ARRAY
18382: PPUSH
18383: LD_INT 1
18385: PPUSH
18386: LD_VAR 0 5
18390: PPUSH
18391: CALL_OW 468
// end else
18395: GO 18498
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18397: LD_VAR 0 5
18401: PPUSH
18402: CALL_OW 461
18406: PUSH
18407: LD_INT 2
18409: EQUAL
18410: PUSH
18411: LD_EXP 68
18415: PUSH
18416: LD_VAR 0 1
18420: ARRAY
18421: AND
18422: IFFALSE 18468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18424: LD_INT 7
18426: PPUSH
18427: LD_EXP 67
18431: PUSH
18432: LD_VAR 0 1
18436: ARRAY
18437: PUSH
18438: LD_INT 1
18440: ARRAY
18441: PPUSH
18442: LD_EXP 67
18446: PUSH
18447: LD_VAR 0 1
18451: ARRAY
18452: PUSH
18453: LD_INT 2
18455: ARRAY
18456: PPUSH
18457: LD_VAR 0 5
18461: PPUSH
18462: CALL_OW 468
18466: GO 18498
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18468: LD_INT 7
18470: PPUSH
18471: LD_EXP 67
18475: PUSH
18476: LD_VAR 0 1
18480: ARRAY
18481: PUSH
18482: LD_INT 1
18484: ARRAY
18485: PPUSH
18486: LD_INT 1
18488: PPUSH
18489: LD_VAR 0 5
18493: PPUSH
18494: CALL_OW 468
// end else
18498: GO 18575
// begin if not artifactsResearched [ i ] then
18500: LD_EXP 62
18504: PUSH
18505: LD_VAR 0 1
18509: ARRAY
18510: NOT
18511: IFFALSE 18545
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18513: LD_INT 7
18515: PPUSH
18516: LD_EXP 67
18520: PUSH
18521: LD_VAR 0 1
18525: ARRAY
18526: PUSH
18527: LD_INT 3
18529: ARRAY
18530: PPUSH
18531: LD_INT 0
18533: PPUSH
18534: LD_VAR 0 5
18538: PPUSH
18539: CALL_OW 468
18543: GO 18575
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18545: LD_INT 7
18547: PPUSH
18548: LD_EXP 67
18552: PUSH
18553: LD_VAR 0 1
18557: ARRAY
18558: PUSH
18559: LD_INT 1
18561: ARRAY
18562: PPUSH
18563: LD_INT 0
18565: PPUSH
18566: LD_VAR 0 5
18570: PPUSH
18571: CALL_OW 468
// end ; end else
18575: GO 18714
// begin if not artifactsLabs [ i ] then
18577: LD_EXP 66
18581: PUSH
18582: LD_VAR 0 1
18586: ARRAY
18587: NOT
18588: IFFALSE 18592
// continue ;
18590: GO 17818
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18592: LD_INT 7
18594: PPUSH
18595: LD_EXP 67
18599: PUSH
18600: LD_VAR 0 1
18604: ARRAY
18605: PUSH
18606: LD_INT 3
18608: ARRAY
18609: PPUSH
18610: LD_INT 0
18612: PPUSH
18613: LD_EXP 66
18617: PUSH
18618: LD_VAR 0 1
18622: ARRAY
18623: PPUSH
18624: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18628: LD_INT 7
18630: PPUSH
18631: LD_EXP 67
18635: PUSH
18636: LD_VAR 0 1
18640: ARRAY
18641: PUSH
18642: LD_INT 1
18644: ARRAY
18645: PPUSH
18646: LD_INT 0
18648: PPUSH
18649: LD_EXP 66
18653: PUSH
18654: LD_VAR 0 1
18658: ARRAY
18659: PPUSH
18660: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18664: LD_EXP 63
18668: PUSH
18669: LD_VAR 0 1
18673: ARRAY
18674: IFFALSE 18714
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18676: LD_ADDR_EXP 63
18680: PUSH
18681: LD_EXP 63
18685: PPUSH
18686: LD_VAR 0 1
18690: PPUSH
18691: LD_INT 0
18693: PPUSH
18694: CALL_OW 1
18698: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18699: LD_EXP 66
18703: PUSH
18704: LD_VAR 0 1
18708: ARRAY
18709: PPUSH
18710: CALL_OW 127
// end ; end ; end ;
18714: GO 17818
18716: POP
18717: POP
// end ;
18718: PPOPN 5
18720: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18721: LD_INT 0
18723: PPUSH
18724: PPUSH
18725: PPUSH
18726: PPUSH
18727: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18728: LD_VAR 0 2
18732: PUSH
18733: LD_EXP 67
18737: PUSH
18738: LD_INT 1
18740: ARRAY
18741: PUSH
18742: LD_INT 3
18744: ARRAY
18745: EQUAL
18746: IFFALSE 18869
// begin lab := artifactsLabs [ 1 ] ;
18748: LD_ADDR_VAR 0 6
18752: PUSH
18753: LD_EXP 66
18757: PUSH
18758: LD_INT 1
18760: ARRAY
18761: ST_TO_ADDR
// if not lab then
18762: LD_VAR 0 6
18766: NOT
18767: IFFALSE 18771
// exit ;
18769: GO 19817
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18771: LD_VAR 0 6
18775: PPUSH
18776: LD_EXP 64
18780: PUSH
18781: LD_INT 1
18783: ARRAY
18784: PPUSH
18785: LD_INT 1
18787: PPUSH
18788: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18792: LD_EXP 65
18796: PUSH
18797: LD_INT 1
18799: ARRAY
18800: IFFALSE 18820
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18802: LD_VAR 0 6
18806: PPUSH
18807: LD_EXP 65
18811: PUSH
18812: LD_INT 1
18814: ARRAY
18815: PPUSH
18816: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18820: LD_ADDR_EXP 63
18824: PUSH
18825: LD_EXP 63
18829: PPUSH
18830: LD_INT 1
18832: PPUSH
18833: LD_INT 1
18835: PPUSH
18836: CALL_OW 1
18840: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18841: LD_INT 7
18843: PPUSH
18844: LD_EXP 67
18848: PUSH
18849: LD_INT 1
18851: ARRAY
18852: PUSH
18853: LD_INT 3
18855: ARRAY
18856: PPUSH
18857: LD_INT 0
18859: PPUSH
18860: LD_VAR 0 6
18864: PPUSH
18865: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18869: LD_VAR 0 2
18873: PUSH
18874: LD_EXP 67
18878: PUSH
18879: LD_INT 2
18881: ARRAY
18882: PUSH
18883: LD_INT 3
18885: ARRAY
18886: EQUAL
18887: IFFALSE 19010
// begin lab := artifactsLabs [ 2 ] ;
18889: LD_ADDR_VAR 0 6
18893: PUSH
18894: LD_EXP 66
18898: PUSH
18899: LD_INT 2
18901: ARRAY
18902: ST_TO_ADDR
// if not lab then
18903: LD_VAR 0 6
18907: NOT
18908: IFFALSE 18912
// exit ;
18910: GO 19817
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
18912: LD_VAR 0 6
18916: PPUSH
18917: LD_EXP 64
18921: PUSH
18922: LD_INT 2
18924: ARRAY
18925: PPUSH
18926: LD_INT 1
18928: PPUSH
18929: CALL_OW 486
// if artifactsResProgress [ 2 ] then
18933: LD_EXP 65
18937: PUSH
18938: LD_INT 2
18940: ARRAY
18941: IFFALSE 18961
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
18943: LD_VAR 0 6
18947: PPUSH
18948: LD_EXP 65
18952: PUSH
18953: LD_INT 2
18955: ARRAY
18956: PPUSH
18957: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
18961: LD_ADDR_EXP 63
18965: PUSH
18966: LD_EXP 63
18970: PPUSH
18971: LD_INT 2
18973: PPUSH
18974: LD_INT 1
18976: PPUSH
18977: CALL_OW 1
18981: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
18982: LD_INT 7
18984: PPUSH
18985: LD_EXP 67
18989: PUSH
18990: LD_INT 2
18992: ARRAY
18993: PUSH
18994: LD_INT 3
18996: ARRAY
18997: PPUSH
18998: LD_INT 0
19000: PPUSH
19001: LD_VAR 0 6
19005: PPUSH
19006: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19010: LD_VAR 0 2
19014: PUSH
19015: LD_EXP 67
19019: PUSH
19020: LD_INT 3
19022: ARRAY
19023: PUSH
19024: LD_INT 3
19026: ARRAY
19027: EQUAL
19028: IFFALSE 19151
// begin lab := artifactsLabs [ 3 ] ;
19030: LD_ADDR_VAR 0 6
19034: PUSH
19035: LD_EXP 66
19039: PUSH
19040: LD_INT 3
19042: ARRAY
19043: ST_TO_ADDR
// if not lab then
19044: LD_VAR 0 6
19048: NOT
19049: IFFALSE 19053
// exit ;
19051: GO 19817
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19053: LD_VAR 0 6
19057: PPUSH
19058: LD_EXP 64
19062: PUSH
19063: LD_INT 3
19065: ARRAY
19066: PPUSH
19067: LD_INT 1
19069: PPUSH
19070: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19074: LD_EXP 65
19078: PUSH
19079: LD_INT 3
19081: ARRAY
19082: IFFALSE 19102
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19084: LD_VAR 0 6
19088: PPUSH
19089: LD_EXP 65
19093: PUSH
19094: LD_INT 3
19096: ARRAY
19097: PPUSH
19098: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19102: LD_ADDR_EXP 63
19106: PUSH
19107: LD_EXP 63
19111: PPUSH
19112: LD_INT 3
19114: PPUSH
19115: LD_INT 1
19117: PPUSH
19118: CALL_OW 1
19122: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19123: LD_INT 7
19125: PPUSH
19126: LD_EXP 67
19130: PUSH
19131: LD_INT 3
19133: ARRAY
19134: PUSH
19135: LD_INT 3
19137: ARRAY
19138: PPUSH
19139: LD_INT 0
19141: PPUSH
19142: LD_VAR 0 6
19146: PPUSH
19147: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19151: LD_VAR 0 2
19155: PUSH
19156: LD_EXP 67
19160: PUSH
19161: LD_INT 1
19163: ARRAY
19164: PUSH
19165: LD_INT 1
19167: ARRAY
19168: EQUAL
19169: IFFALSE 19327
// begin lab := artifactsLabs [ 1 ] ;
19171: LD_ADDR_VAR 0 6
19175: PUSH
19176: LD_EXP 66
19180: PUSH
19181: LD_INT 1
19183: ARRAY
19184: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19185: LD_VAR 0 6
19189: PPUSH
19190: CALL_OW 274
19194: PPUSH
19195: CALL 93398 0 1
19199: PUSH
19200: LD_INT 3
19202: ARRAY
19203: PUSH
19204: LD_EXP 61
19208: PUSH
19209: LD_INT 1
19211: ARRAY
19212: LESS
19213: IFFALSE 19227
// begin HintSpec ( ArtifactCost , 2 ) ;
19215: LD_STRING ArtifactCost
19217: PPUSH
19218: LD_INT 2
19220: PPUSH
19221: CALL_OW 338
// exit ;
19225: GO 19817
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19227: LD_ADDR_EXP 68
19231: PUSH
19232: LD_EXP 68
19236: PPUSH
19237: LD_INT 1
19239: PPUSH
19240: LD_INT 0
19242: PPUSH
19243: CALL_OW 1
19247: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19248: LD_VAR 0 3
19252: PPUSH
19253: LD_VAR 0 4
19257: PPUSH
19258: LD_INT 7
19260: PPUSH
19261: LD_INT 12
19263: NEG
19264: PPUSH
19265: CALL_OW 330
// wait ( 0 0$30 ) ;
19269: LD_INT 1050
19271: PPUSH
19272: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19276: LD_VAR 0 3
19280: PPUSH
19281: LD_VAR 0 4
19285: PPUSH
19286: LD_INT 7
19288: PPUSH
19289: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19293: LD_EXP 60
19297: PUSH
19298: LD_INT 1
19300: ARRAY
19301: PPUSH
19302: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19306: LD_ADDR_EXP 68
19310: PUSH
19311: LD_EXP 68
19315: PPUSH
19316: LD_INT 1
19318: PPUSH
19319: LD_INT 1
19321: PPUSH
19322: CALL_OW 1
19326: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19327: LD_VAR 0 2
19331: PUSH
19332: LD_EXP 67
19336: PUSH
19337: LD_INT 2
19339: ARRAY
19340: PUSH
19341: LD_INT 1
19343: ARRAY
19344: EQUAL
19345: IFFALSE 19571
// begin lab := artifactsLabs [ 2 ] ;
19347: LD_ADDR_VAR 0 6
19351: PUSH
19352: LD_EXP 66
19356: PUSH
19357: LD_INT 2
19359: ARRAY
19360: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
19361: LD_VAR 0 3
19365: PUSH
19366: LD_INT 81
19368: PUSH
19369: LD_INT 7
19371: PUSH
19372: EMPTY
19373: LIST
19374: LIST
19375: PUSH
19376: LD_INT 2
19378: PUSH
19379: LD_INT 32
19381: PUSH
19382: LD_INT 3
19384: PUSH
19385: EMPTY
19386: LIST
19387: LIST
19388: PUSH
19389: LD_INT 30
19391: PUSH
19392: LD_INT 28
19394: PUSH
19395: EMPTY
19396: LIST
19397: LIST
19398: PUSH
19399: LD_INT 30
19401: PUSH
19402: LD_INT 30
19404: PUSH
19405: EMPTY
19406: LIST
19407: LIST
19408: PUSH
19409: LD_INT 35
19411: PUSH
19412: LD_INT 49
19414: PUSH
19415: EMPTY
19416: LIST
19417: LIST
19418: PUSH
19419: LD_INT 34
19421: PUSH
19422: LD_INT 49
19424: PUSH
19425: EMPTY
19426: LIST
19427: LIST
19428: PUSH
19429: EMPTY
19430: LIST
19431: LIST
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: PUSH
19437: EMPTY
19438: LIST
19439: LIST
19440: PPUSH
19441: CALL_OW 69
19445: IN
19446: NOT
19447: IFFALSE 19451
// exit ;
19449: GO 19817
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19451: LD_VAR 0 6
19455: PPUSH
19456: CALL_OW 274
19460: PPUSH
19461: CALL 93398 0 1
19465: PUSH
19466: LD_INT 3
19468: ARRAY
19469: PUSH
19470: LD_EXP 61
19474: PUSH
19475: LD_INT 2
19477: ARRAY
19478: LESS
19479: IFFALSE 19493
// begin HintSpec ( ArtifactCost , 2 ) ;
19481: LD_STRING ArtifactCost
19483: PPUSH
19484: LD_INT 2
19486: PPUSH
19487: CALL_OW 338
// exit ;
19491: GO 19817
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19493: LD_ADDR_EXP 68
19497: PUSH
19498: LD_EXP 68
19502: PPUSH
19503: LD_INT 2
19505: PPUSH
19506: LD_INT 0
19508: PPUSH
19509: CALL_OW 1
19513: ST_TO_ADDR
// KillUnit ( x ) ;
19514: LD_VAR 0 3
19518: PPUSH
19519: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19523: LD_ADDR_EXP 13
19527: PUSH
19528: LD_EXP 13
19532: PUSH
19533: LD_INT 1
19535: PLUS
19536: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19537: LD_EXP 60
19541: PUSH
19542: LD_INT 2
19544: ARRAY
19545: PPUSH
19546: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19550: LD_ADDR_EXP 68
19554: PUSH
19555: LD_EXP 68
19559: PPUSH
19560: LD_INT 2
19562: PPUSH
19563: LD_INT 1
19565: PPUSH
19566: CALL_OW 1
19570: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19571: LD_VAR 0 2
19575: PUSH
19576: LD_EXP 67
19580: PUSH
19581: LD_INT 3
19583: ARRAY
19584: PUSH
19585: LD_INT 1
19587: ARRAY
19588: EQUAL
19589: IFFALSE 19817
// begin lab := artifactsLabs [ 3 ] ;
19591: LD_ADDR_VAR 0 6
19595: PUSH
19596: LD_EXP 66
19600: PUSH
19601: LD_INT 3
19603: ARRAY
19604: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19605: LD_VAR 0 6
19609: PPUSH
19610: CALL_OW 274
19614: PPUSH
19615: CALL 93398 0 1
19619: PUSH
19620: LD_INT 3
19622: ARRAY
19623: PUSH
19624: LD_EXP 61
19628: PUSH
19629: LD_INT 3
19631: ARRAY
19632: LESS
19633: IFFALSE 19647
// begin HintSpec ( ArtifactCost , 2 ) ;
19635: LD_STRING ArtifactCost
19637: PPUSH
19638: LD_INT 2
19640: PPUSH
19641: CALL_OW 338
// exit ;
19645: GO 19817
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19647: LD_INT 37
19649: PPUSH
19650: LD_INT 1
19652: PPUSH
19653: CALL_OW 424
// time := 0 0$30 ;
19657: LD_ADDR_VAR 0 7
19661: PUSH
19662: LD_INT 1050
19664: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
19665: LD_ADDR_OWVAR 47
19669: PUSH
19670: LD_STRING Am15a-1
19672: PUSH
19673: LD_VAR 0 7
19677: PUSH
19678: EMPTY
19679: LIST
19680: LIST
19681: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19682: LD_INT 35
19684: PPUSH
19685: CALL_OW 67
// time := time - 0 0$1 ;
19689: LD_ADDR_VAR 0 7
19693: PUSH
19694: LD_VAR 0 7
19698: PUSH
19699: LD_INT 35
19701: MINUS
19702: ST_TO_ADDR
// until time = 0 0$00 ;
19703: LD_VAR 0 7
19707: PUSH
19708: LD_INT 0
19710: EQUAL
19711: IFFALSE 19665
// display_strings :=  ;
19713: LD_ADDR_OWVAR 47
19717: PUSH
19718: LD_STRING 
19720: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19721: LD_INT 37
19723: PPUSH
19724: LD_INT 0
19726: PPUSH
19727: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19731: LD_ADDR_VAR 0 8
19735: PUSH
19736: LD_INT 37
19738: PPUSH
19739: LD_INT 3
19741: PUSH
19742: LD_INT 21
19744: PUSH
19745: LD_INT 3
19747: PUSH
19748: EMPTY
19749: LIST
19750: LIST
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PPUSH
19756: CALL_OW 70
19760: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19761: LD_VAR 0 3
19765: PPUSH
19766: LD_VAR 0 4
19770: PPUSH
19771: CALL_OW 84
// for un in list do
19775: LD_ADDR_VAR 0 9
19779: PUSH
19780: LD_VAR 0 8
19784: PUSH
19785: FOR_IN
19786: IFFALSE 19815
// TeleportUnit ( un , x , y , 12 , true ) ;
19788: LD_VAR 0 9
19792: PPUSH
19793: LD_VAR 0 3
19797: PPUSH
19798: LD_VAR 0 4
19802: PPUSH
19803: LD_INT 12
19805: PPUSH
19806: LD_INT 1
19808: PPUSH
19809: CALL_OW 483
19813: GO 19785
19815: POP
19816: POP
// end ; end ;
19817: PPOPN 9
19819: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19820: LD_INT 0
19822: PPUSH
19823: PPUSH
// begin labNum := 0 ;
19824: LD_ADDR_VAR 0 4
19828: PUSH
19829: LD_INT 0
19831: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19832: LD_ADDR_VAR 0 3
19836: PUSH
19837: DOUBLE
19838: LD_INT 1
19840: DEC
19841: ST_TO_ADDR
19842: LD_EXP 66
19846: PUSH
19847: FOR_TO
19848: IFFALSE 19882
// if artifactsLabs [ i ] = lab then
19850: LD_EXP 66
19854: PUSH
19855: LD_VAR 0 3
19859: ARRAY
19860: PUSH
19861: LD_VAR 0 1
19865: EQUAL
19866: IFFALSE 19880
// begin labNum := i ;
19868: LD_ADDR_VAR 0 4
19872: PUSH
19873: LD_VAR 0 3
19877: ST_TO_ADDR
// break ;
19878: GO 19882
// end ;
19880: GO 19847
19882: POP
19883: POP
// if not labNum then
19884: LD_VAR 0 4
19888: NOT
19889: IFFALSE 19893
// exit ;
19891: GO 19971
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
19893: LD_INT 7
19895: PPUSH
19896: LD_EXP 67
19900: PUSH
19901: LD_VAR 0 4
19905: ARRAY
19906: PUSH
19907: LD_INT 3
19909: ARRAY
19910: PPUSH
19911: LD_INT 2
19913: PPUSH
19914: LD_VAR 0 1
19918: PPUSH
19919: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
19923: LD_ADDR_EXP 65
19927: PUSH
19928: LD_EXP 65
19932: PPUSH
19933: LD_VAR 0 4
19937: PPUSH
19938: LD_VAR 0 2
19942: PPUSH
19943: CALL_OW 1
19947: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
19948: LD_ADDR_EXP 63
19952: PUSH
19953: LD_EXP 63
19957: PPUSH
19958: LD_VAR 0 4
19962: PPUSH
19963: LD_INT 0
19965: PPUSH
19966: CALL_OW 1
19970: ST_TO_ADDR
// end ;
19971: PPOPN 4
19973: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
19974: LD_INT 0
19976: PPUSH
19977: PPUSH
// begin labNum := 0 ;
19978: LD_ADDR_VAR 0 3
19982: PUSH
19983: LD_INT 0
19985: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19986: LD_ADDR_VAR 0 2
19990: PUSH
19991: DOUBLE
19992: LD_INT 1
19994: DEC
19995: ST_TO_ADDR
19996: LD_EXP 66
20000: PUSH
20001: FOR_TO
20002: IFFALSE 20036
// if artifactsLabs [ i ] = lab then
20004: LD_EXP 66
20008: PUSH
20009: LD_VAR 0 2
20013: ARRAY
20014: PUSH
20015: LD_VAR 0 1
20019: EQUAL
20020: IFFALSE 20034
// begin labNum := i ;
20022: LD_ADDR_VAR 0 3
20026: PUSH
20027: LD_VAR 0 2
20031: ST_TO_ADDR
// break ;
20032: GO 20036
// end ;
20034: GO 20001
20036: POP
20037: POP
// if not labNum then
20038: LD_VAR 0 3
20042: NOT
20043: IFFALSE 20047
// exit ;
20045: GO 20209
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20047: LD_INT 7
20049: PPUSH
20050: LD_EXP 67
20054: PUSH
20055: LD_VAR 0 3
20059: ARRAY
20060: PUSH
20061: LD_INT 3
20063: ARRAY
20064: PPUSH
20065: LD_INT 0
20067: PPUSH
20068: LD_VAR 0 1
20072: PPUSH
20073: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20077: LD_ADDR_EXP 62
20081: PUSH
20082: LD_EXP 62
20086: PPUSH
20087: LD_VAR 0 3
20091: PPUSH
20092: LD_INT 1
20094: PPUSH
20095: CALL_OW 1
20099: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20100: LD_ADDR_EXP 68
20104: PUSH
20105: LD_EXP 68
20109: PPUSH
20110: LD_VAR 0 3
20114: PPUSH
20115: LD_INT 1
20117: PPUSH
20118: CALL_OW 1
20122: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20123: LD_ADDR_EXP 63
20127: PUSH
20128: LD_EXP 63
20132: PPUSH
20133: LD_VAR 0 3
20137: PPUSH
20138: LD_INT 0
20140: PPUSH
20141: CALL_OW 1
20145: ST_TO_ADDR
// case labNum of 1 :
20146: LD_VAR 0 3
20150: PUSH
20151: LD_INT 1
20153: DOUBLE
20154: EQUAL
20155: IFTRUE 20159
20157: GO 20170
20159: POP
// artifactIResearched := true ; 2 :
20160: LD_ADDR_EXP 9
20164: PUSH
20165: LD_INT 1
20167: ST_TO_ADDR
20168: GO 20209
20170: LD_INT 2
20172: DOUBLE
20173: EQUAL
20174: IFTRUE 20178
20176: GO 20189
20178: POP
// artifactIIResearched := true ; 3 :
20179: LD_ADDR_EXP 10
20183: PUSH
20184: LD_INT 1
20186: ST_TO_ADDR
20187: GO 20209
20189: LD_INT 3
20191: DOUBLE
20192: EQUAL
20193: IFTRUE 20197
20195: GO 20208
20197: POP
// artifactIIIResearched := true ; end ;
20198: LD_ADDR_EXP 11
20202: PUSH
20203: LD_INT 1
20205: ST_TO_ADDR
20206: GO 20209
20208: POP
// end ; end_of_file
20209: PPOPN 3
20211: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20212: GO 20214
20214: DISABLE
// begin ru_radar := 98 ;
20215: LD_ADDR_EXP 69
20219: PUSH
20220: LD_INT 98
20222: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20223: LD_ADDR_EXP 70
20227: PUSH
20228: LD_INT 89
20230: ST_TO_ADDR
// us_hack := 99 ;
20231: LD_ADDR_EXP 71
20235: PUSH
20236: LD_INT 99
20238: ST_TO_ADDR
// us_artillery := 97 ;
20239: LD_ADDR_EXP 72
20243: PUSH
20244: LD_INT 97
20246: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20247: LD_ADDR_EXP 73
20251: PUSH
20252: LD_INT 91
20254: ST_TO_ADDR
// end ; end_of_file
20255: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20256: LD_INT 0
20258: PPUSH
20259: PPUSH
// skirmish := false ;
20260: LD_ADDR_EXP 74
20264: PUSH
20265: LD_INT 0
20267: ST_TO_ADDR
// debug_mc := false ;
20268: LD_ADDR_EXP 75
20272: PUSH
20273: LD_INT 0
20275: ST_TO_ADDR
// mc_bases := [ ] ;
20276: LD_ADDR_EXP 76
20280: PUSH
20281: EMPTY
20282: ST_TO_ADDR
// mc_sides := [ ] ;
20283: LD_ADDR_EXP 102
20287: PUSH
20288: EMPTY
20289: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20290: LD_ADDR_EXP 77
20294: PUSH
20295: EMPTY
20296: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20297: LD_ADDR_EXP 78
20301: PUSH
20302: EMPTY
20303: ST_TO_ADDR
// mc_need_heal := [ ] ;
20304: LD_ADDR_EXP 79
20308: PUSH
20309: EMPTY
20310: ST_TO_ADDR
// mc_healers := [ ] ;
20311: LD_ADDR_EXP 80
20315: PUSH
20316: EMPTY
20317: ST_TO_ADDR
// mc_build_list := [ ] ;
20318: LD_ADDR_EXP 81
20322: PUSH
20323: EMPTY
20324: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20325: LD_ADDR_EXP 108
20329: PUSH
20330: EMPTY
20331: ST_TO_ADDR
// mc_builders := [ ] ;
20332: LD_ADDR_EXP 82
20336: PUSH
20337: EMPTY
20338: ST_TO_ADDR
// mc_construct_list := [ ] ;
20339: LD_ADDR_EXP 83
20343: PUSH
20344: EMPTY
20345: ST_TO_ADDR
// mc_turret_list := [ ] ;
20346: LD_ADDR_EXP 84
20350: PUSH
20351: EMPTY
20352: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20353: LD_ADDR_EXP 85
20357: PUSH
20358: EMPTY
20359: ST_TO_ADDR
// mc_miners := [ ] ;
20360: LD_ADDR_EXP 90
20364: PUSH
20365: EMPTY
20366: ST_TO_ADDR
// mc_mines := [ ] ;
20367: LD_ADDR_EXP 89
20371: PUSH
20372: EMPTY
20373: ST_TO_ADDR
// mc_minefields := [ ] ;
20374: LD_ADDR_EXP 91
20378: PUSH
20379: EMPTY
20380: ST_TO_ADDR
// mc_crates := [ ] ;
20381: LD_ADDR_EXP 92
20385: PUSH
20386: EMPTY
20387: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20388: LD_ADDR_EXP 93
20392: PUSH
20393: EMPTY
20394: ST_TO_ADDR
// mc_crates_area := [ ] ;
20395: LD_ADDR_EXP 94
20399: PUSH
20400: EMPTY
20401: ST_TO_ADDR
// mc_vehicles := [ ] ;
20402: LD_ADDR_EXP 95
20406: PUSH
20407: EMPTY
20408: ST_TO_ADDR
// mc_attack := [ ] ;
20409: LD_ADDR_EXP 96
20413: PUSH
20414: EMPTY
20415: ST_TO_ADDR
// mc_produce := [ ] ;
20416: LD_ADDR_EXP 97
20420: PUSH
20421: EMPTY
20422: ST_TO_ADDR
// mc_defender := [ ] ;
20423: LD_ADDR_EXP 98
20427: PUSH
20428: EMPTY
20429: ST_TO_ADDR
// mc_parking := [ ] ;
20430: LD_ADDR_EXP 100
20434: PUSH
20435: EMPTY
20436: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20437: LD_ADDR_EXP 86
20441: PUSH
20442: EMPTY
20443: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20444: LD_ADDR_EXP 88
20448: PUSH
20449: EMPTY
20450: ST_TO_ADDR
// mc_scan := [ ] ;
20451: LD_ADDR_EXP 99
20455: PUSH
20456: EMPTY
20457: ST_TO_ADDR
// mc_scan_area := [ ] ;
20458: LD_ADDR_EXP 101
20462: PUSH
20463: EMPTY
20464: ST_TO_ADDR
// mc_tech := [ ] ;
20465: LD_ADDR_EXP 103
20469: PUSH
20470: EMPTY
20471: ST_TO_ADDR
// mc_class := [ ] ;
20472: LD_ADDR_EXP 117
20476: PUSH
20477: EMPTY
20478: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20479: LD_ADDR_EXP 118
20483: PUSH
20484: EMPTY
20485: ST_TO_ADDR
// end ;
20486: LD_VAR 0 1
20490: RET
// export function MC_Kill ( base ) ; begin
20491: LD_INT 0
20493: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20494: LD_ADDR_EXP 76
20498: PUSH
20499: LD_EXP 76
20503: PPUSH
20504: LD_VAR 0 1
20508: PPUSH
20509: EMPTY
20510: PPUSH
20511: CALL_OW 1
20515: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20516: LD_ADDR_EXP 77
20520: PUSH
20521: LD_EXP 77
20525: PPUSH
20526: LD_VAR 0 1
20530: PPUSH
20531: EMPTY
20532: PPUSH
20533: CALL_OW 1
20537: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20538: LD_ADDR_EXP 78
20542: PUSH
20543: LD_EXP 78
20547: PPUSH
20548: LD_VAR 0 1
20552: PPUSH
20553: EMPTY
20554: PPUSH
20555: CALL_OW 1
20559: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20560: LD_ADDR_EXP 79
20564: PUSH
20565: LD_EXP 79
20569: PPUSH
20570: LD_VAR 0 1
20574: PPUSH
20575: EMPTY
20576: PPUSH
20577: CALL_OW 1
20581: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20582: LD_ADDR_EXP 80
20586: PUSH
20587: LD_EXP 80
20591: PPUSH
20592: LD_VAR 0 1
20596: PPUSH
20597: EMPTY
20598: PPUSH
20599: CALL_OW 1
20603: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20604: LD_ADDR_EXP 81
20608: PUSH
20609: LD_EXP 81
20613: PPUSH
20614: LD_VAR 0 1
20618: PPUSH
20619: EMPTY
20620: PPUSH
20621: CALL_OW 1
20625: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20626: LD_ADDR_EXP 82
20630: PUSH
20631: LD_EXP 82
20635: PPUSH
20636: LD_VAR 0 1
20640: PPUSH
20641: EMPTY
20642: PPUSH
20643: CALL_OW 1
20647: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20648: LD_ADDR_EXP 83
20652: PUSH
20653: LD_EXP 83
20657: PPUSH
20658: LD_VAR 0 1
20662: PPUSH
20663: EMPTY
20664: PPUSH
20665: CALL_OW 1
20669: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20670: LD_ADDR_EXP 84
20674: PUSH
20675: LD_EXP 84
20679: PPUSH
20680: LD_VAR 0 1
20684: PPUSH
20685: EMPTY
20686: PPUSH
20687: CALL_OW 1
20691: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20692: LD_ADDR_EXP 85
20696: PUSH
20697: LD_EXP 85
20701: PPUSH
20702: LD_VAR 0 1
20706: PPUSH
20707: EMPTY
20708: PPUSH
20709: CALL_OW 1
20713: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20714: LD_ADDR_EXP 86
20718: PUSH
20719: LD_EXP 86
20723: PPUSH
20724: LD_VAR 0 1
20728: PPUSH
20729: EMPTY
20730: PPUSH
20731: CALL_OW 1
20735: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20736: LD_ADDR_EXP 87
20740: PUSH
20741: LD_EXP 87
20745: PPUSH
20746: LD_VAR 0 1
20750: PPUSH
20751: LD_INT 0
20753: PPUSH
20754: CALL_OW 1
20758: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20759: LD_ADDR_EXP 88
20763: PUSH
20764: LD_EXP 88
20768: PPUSH
20769: LD_VAR 0 1
20773: PPUSH
20774: EMPTY
20775: PPUSH
20776: CALL_OW 1
20780: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20781: LD_ADDR_EXP 89
20785: PUSH
20786: LD_EXP 89
20790: PPUSH
20791: LD_VAR 0 1
20795: PPUSH
20796: EMPTY
20797: PPUSH
20798: CALL_OW 1
20802: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20803: LD_ADDR_EXP 90
20807: PUSH
20808: LD_EXP 90
20812: PPUSH
20813: LD_VAR 0 1
20817: PPUSH
20818: EMPTY
20819: PPUSH
20820: CALL_OW 1
20824: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20825: LD_ADDR_EXP 91
20829: PUSH
20830: LD_EXP 91
20834: PPUSH
20835: LD_VAR 0 1
20839: PPUSH
20840: EMPTY
20841: PPUSH
20842: CALL_OW 1
20846: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20847: LD_ADDR_EXP 92
20851: PUSH
20852: LD_EXP 92
20856: PPUSH
20857: LD_VAR 0 1
20861: PPUSH
20862: EMPTY
20863: PPUSH
20864: CALL_OW 1
20868: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20869: LD_ADDR_EXP 93
20873: PUSH
20874: LD_EXP 93
20878: PPUSH
20879: LD_VAR 0 1
20883: PPUSH
20884: EMPTY
20885: PPUSH
20886: CALL_OW 1
20890: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20891: LD_ADDR_EXP 94
20895: PUSH
20896: LD_EXP 94
20900: PPUSH
20901: LD_VAR 0 1
20905: PPUSH
20906: EMPTY
20907: PPUSH
20908: CALL_OW 1
20912: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20913: LD_ADDR_EXP 95
20917: PUSH
20918: LD_EXP 95
20922: PPUSH
20923: LD_VAR 0 1
20927: PPUSH
20928: EMPTY
20929: PPUSH
20930: CALL_OW 1
20934: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20935: LD_ADDR_EXP 96
20939: PUSH
20940: LD_EXP 96
20944: PPUSH
20945: LD_VAR 0 1
20949: PPUSH
20950: EMPTY
20951: PPUSH
20952: CALL_OW 1
20956: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20957: LD_ADDR_EXP 97
20961: PUSH
20962: LD_EXP 97
20966: PPUSH
20967: LD_VAR 0 1
20971: PPUSH
20972: EMPTY
20973: PPUSH
20974: CALL_OW 1
20978: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20979: LD_ADDR_EXP 98
20983: PUSH
20984: LD_EXP 98
20988: PPUSH
20989: LD_VAR 0 1
20993: PPUSH
20994: EMPTY
20995: PPUSH
20996: CALL_OW 1
21000: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21001: LD_ADDR_EXP 99
21005: PUSH
21006: LD_EXP 99
21010: PPUSH
21011: LD_VAR 0 1
21015: PPUSH
21016: EMPTY
21017: PPUSH
21018: CALL_OW 1
21022: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21023: LD_ADDR_EXP 100
21027: PUSH
21028: LD_EXP 100
21032: PPUSH
21033: LD_VAR 0 1
21037: PPUSH
21038: EMPTY
21039: PPUSH
21040: CALL_OW 1
21044: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21045: LD_ADDR_EXP 101
21049: PUSH
21050: LD_EXP 101
21054: PPUSH
21055: LD_VAR 0 1
21059: PPUSH
21060: EMPTY
21061: PPUSH
21062: CALL_OW 1
21066: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21067: LD_ADDR_EXP 103
21071: PUSH
21072: LD_EXP 103
21076: PPUSH
21077: LD_VAR 0 1
21081: PPUSH
21082: EMPTY
21083: PPUSH
21084: CALL_OW 1
21088: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21089: LD_ADDR_EXP 105
21093: PUSH
21094: LD_EXP 105
21098: PPUSH
21099: LD_VAR 0 1
21103: PPUSH
21104: EMPTY
21105: PPUSH
21106: CALL_OW 1
21110: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21111: LD_ADDR_EXP 106
21115: PUSH
21116: LD_EXP 106
21120: PPUSH
21121: LD_VAR 0 1
21125: PPUSH
21126: EMPTY
21127: PPUSH
21128: CALL_OW 1
21132: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21133: LD_ADDR_EXP 107
21137: PUSH
21138: LD_EXP 107
21142: PPUSH
21143: LD_VAR 0 1
21147: PPUSH
21148: EMPTY
21149: PPUSH
21150: CALL_OW 1
21154: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21155: LD_ADDR_EXP 108
21159: PUSH
21160: LD_EXP 108
21164: PPUSH
21165: LD_VAR 0 1
21169: PPUSH
21170: EMPTY
21171: PPUSH
21172: CALL_OW 1
21176: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21177: LD_ADDR_EXP 109
21181: PUSH
21182: LD_EXP 109
21186: PPUSH
21187: LD_VAR 0 1
21191: PPUSH
21192: EMPTY
21193: PPUSH
21194: CALL_OW 1
21198: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21199: LD_ADDR_EXP 110
21203: PUSH
21204: LD_EXP 110
21208: PPUSH
21209: LD_VAR 0 1
21213: PPUSH
21214: EMPTY
21215: PPUSH
21216: CALL_OW 1
21220: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21221: LD_ADDR_EXP 111
21225: PUSH
21226: LD_EXP 111
21230: PPUSH
21231: LD_VAR 0 1
21235: PPUSH
21236: EMPTY
21237: PPUSH
21238: CALL_OW 1
21242: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21243: LD_ADDR_EXP 112
21247: PUSH
21248: LD_EXP 112
21252: PPUSH
21253: LD_VAR 0 1
21257: PPUSH
21258: EMPTY
21259: PPUSH
21260: CALL_OW 1
21264: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21265: LD_ADDR_EXP 113
21269: PUSH
21270: LD_EXP 113
21274: PPUSH
21275: LD_VAR 0 1
21279: PPUSH
21280: EMPTY
21281: PPUSH
21282: CALL_OW 1
21286: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21287: LD_ADDR_EXP 114
21291: PUSH
21292: LD_EXP 114
21296: PPUSH
21297: LD_VAR 0 1
21301: PPUSH
21302: EMPTY
21303: PPUSH
21304: CALL_OW 1
21308: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21309: LD_ADDR_EXP 115
21313: PUSH
21314: LD_EXP 115
21318: PPUSH
21319: LD_VAR 0 1
21323: PPUSH
21324: EMPTY
21325: PPUSH
21326: CALL_OW 1
21330: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21331: LD_ADDR_EXP 116
21335: PUSH
21336: LD_EXP 116
21340: PPUSH
21341: LD_VAR 0 1
21345: PPUSH
21346: EMPTY
21347: PPUSH
21348: CALL_OW 1
21352: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21353: LD_ADDR_EXP 117
21357: PUSH
21358: LD_EXP 117
21362: PPUSH
21363: LD_VAR 0 1
21367: PPUSH
21368: EMPTY
21369: PPUSH
21370: CALL_OW 1
21374: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21375: LD_ADDR_EXP 118
21379: PUSH
21380: LD_EXP 118
21384: PPUSH
21385: LD_VAR 0 1
21389: PPUSH
21390: LD_INT 0
21392: PPUSH
21393: CALL_OW 1
21397: ST_TO_ADDR
// end ;
21398: LD_VAR 0 2
21402: RET
// export function MC_Add ( side , units ) ; var base ; begin
21403: LD_INT 0
21405: PPUSH
21406: PPUSH
// base := mc_bases + 1 ;
21407: LD_ADDR_VAR 0 4
21411: PUSH
21412: LD_EXP 76
21416: PUSH
21417: LD_INT 1
21419: PLUS
21420: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21421: LD_ADDR_EXP 102
21425: PUSH
21426: LD_EXP 102
21430: PPUSH
21431: LD_VAR 0 4
21435: PPUSH
21436: LD_VAR 0 1
21440: PPUSH
21441: CALL_OW 1
21445: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21446: LD_ADDR_EXP 76
21450: PUSH
21451: LD_EXP 76
21455: PPUSH
21456: LD_VAR 0 4
21460: PPUSH
21461: LD_VAR 0 2
21465: PPUSH
21466: CALL_OW 1
21470: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21471: LD_ADDR_EXP 77
21475: PUSH
21476: LD_EXP 77
21480: PPUSH
21481: LD_VAR 0 4
21485: PPUSH
21486: EMPTY
21487: PPUSH
21488: CALL_OW 1
21492: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21493: LD_ADDR_EXP 78
21497: PUSH
21498: LD_EXP 78
21502: PPUSH
21503: LD_VAR 0 4
21507: PPUSH
21508: EMPTY
21509: PPUSH
21510: CALL_OW 1
21514: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21515: LD_ADDR_EXP 79
21519: PUSH
21520: LD_EXP 79
21524: PPUSH
21525: LD_VAR 0 4
21529: PPUSH
21530: EMPTY
21531: PPUSH
21532: CALL_OW 1
21536: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21537: LD_ADDR_EXP 80
21541: PUSH
21542: LD_EXP 80
21546: PPUSH
21547: LD_VAR 0 4
21551: PPUSH
21552: EMPTY
21553: PPUSH
21554: CALL_OW 1
21558: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21559: LD_ADDR_EXP 81
21563: PUSH
21564: LD_EXP 81
21568: PPUSH
21569: LD_VAR 0 4
21573: PPUSH
21574: EMPTY
21575: PPUSH
21576: CALL_OW 1
21580: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21581: LD_ADDR_EXP 82
21585: PUSH
21586: LD_EXP 82
21590: PPUSH
21591: LD_VAR 0 4
21595: PPUSH
21596: EMPTY
21597: PPUSH
21598: CALL_OW 1
21602: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21603: LD_ADDR_EXP 83
21607: PUSH
21608: LD_EXP 83
21612: PPUSH
21613: LD_VAR 0 4
21617: PPUSH
21618: EMPTY
21619: PPUSH
21620: CALL_OW 1
21624: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21625: LD_ADDR_EXP 84
21629: PUSH
21630: LD_EXP 84
21634: PPUSH
21635: LD_VAR 0 4
21639: PPUSH
21640: EMPTY
21641: PPUSH
21642: CALL_OW 1
21646: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21647: LD_ADDR_EXP 85
21651: PUSH
21652: LD_EXP 85
21656: PPUSH
21657: LD_VAR 0 4
21661: PPUSH
21662: EMPTY
21663: PPUSH
21664: CALL_OW 1
21668: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21669: LD_ADDR_EXP 86
21673: PUSH
21674: LD_EXP 86
21678: PPUSH
21679: LD_VAR 0 4
21683: PPUSH
21684: EMPTY
21685: PPUSH
21686: CALL_OW 1
21690: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21691: LD_ADDR_EXP 87
21695: PUSH
21696: LD_EXP 87
21700: PPUSH
21701: LD_VAR 0 4
21705: PPUSH
21706: LD_INT 0
21708: PPUSH
21709: CALL_OW 1
21713: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21714: LD_ADDR_EXP 88
21718: PUSH
21719: LD_EXP 88
21723: PPUSH
21724: LD_VAR 0 4
21728: PPUSH
21729: EMPTY
21730: PPUSH
21731: CALL_OW 1
21735: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21736: LD_ADDR_EXP 89
21740: PUSH
21741: LD_EXP 89
21745: PPUSH
21746: LD_VAR 0 4
21750: PPUSH
21751: EMPTY
21752: PPUSH
21753: CALL_OW 1
21757: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21758: LD_ADDR_EXP 90
21762: PUSH
21763: LD_EXP 90
21767: PPUSH
21768: LD_VAR 0 4
21772: PPUSH
21773: EMPTY
21774: PPUSH
21775: CALL_OW 1
21779: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21780: LD_ADDR_EXP 91
21784: PUSH
21785: LD_EXP 91
21789: PPUSH
21790: LD_VAR 0 4
21794: PPUSH
21795: EMPTY
21796: PPUSH
21797: CALL_OW 1
21801: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21802: LD_ADDR_EXP 92
21806: PUSH
21807: LD_EXP 92
21811: PPUSH
21812: LD_VAR 0 4
21816: PPUSH
21817: EMPTY
21818: PPUSH
21819: CALL_OW 1
21823: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21824: LD_ADDR_EXP 93
21828: PUSH
21829: LD_EXP 93
21833: PPUSH
21834: LD_VAR 0 4
21838: PPUSH
21839: EMPTY
21840: PPUSH
21841: CALL_OW 1
21845: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21846: LD_ADDR_EXP 94
21850: PUSH
21851: LD_EXP 94
21855: PPUSH
21856: LD_VAR 0 4
21860: PPUSH
21861: EMPTY
21862: PPUSH
21863: CALL_OW 1
21867: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21868: LD_ADDR_EXP 95
21872: PUSH
21873: LD_EXP 95
21877: PPUSH
21878: LD_VAR 0 4
21882: PPUSH
21883: EMPTY
21884: PPUSH
21885: CALL_OW 1
21889: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21890: LD_ADDR_EXP 96
21894: PUSH
21895: LD_EXP 96
21899: PPUSH
21900: LD_VAR 0 4
21904: PPUSH
21905: EMPTY
21906: PPUSH
21907: CALL_OW 1
21911: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21912: LD_ADDR_EXP 97
21916: PUSH
21917: LD_EXP 97
21921: PPUSH
21922: LD_VAR 0 4
21926: PPUSH
21927: EMPTY
21928: PPUSH
21929: CALL_OW 1
21933: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21934: LD_ADDR_EXP 98
21938: PUSH
21939: LD_EXP 98
21943: PPUSH
21944: LD_VAR 0 4
21948: PPUSH
21949: EMPTY
21950: PPUSH
21951: CALL_OW 1
21955: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21956: LD_ADDR_EXP 99
21960: PUSH
21961: LD_EXP 99
21965: PPUSH
21966: LD_VAR 0 4
21970: PPUSH
21971: EMPTY
21972: PPUSH
21973: CALL_OW 1
21977: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21978: LD_ADDR_EXP 100
21982: PUSH
21983: LD_EXP 100
21987: PPUSH
21988: LD_VAR 0 4
21992: PPUSH
21993: EMPTY
21994: PPUSH
21995: CALL_OW 1
21999: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22000: LD_ADDR_EXP 101
22004: PUSH
22005: LD_EXP 101
22009: PPUSH
22010: LD_VAR 0 4
22014: PPUSH
22015: EMPTY
22016: PPUSH
22017: CALL_OW 1
22021: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22022: LD_ADDR_EXP 103
22026: PUSH
22027: LD_EXP 103
22031: PPUSH
22032: LD_VAR 0 4
22036: PPUSH
22037: EMPTY
22038: PPUSH
22039: CALL_OW 1
22043: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22044: LD_ADDR_EXP 105
22048: PUSH
22049: LD_EXP 105
22053: PPUSH
22054: LD_VAR 0 4
22058: PPUSH
22059: EMPTY
22060: PPUSH
22061: CALL_OW 1
22065: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22066: LD_ADDR_EXP 106
22070: PUSH
22071: LD_EXP 106
22075: PPUSH
22076: LD_VAR 0 4
22080: PPUSH
22081: EMPTY
22082: PPUSH
22083: CALL_OW 1
22087: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22088: LD_ADDR_EXP 107
22092: PUSH
22093: LD_EXP 107
22097: PPUSH
22098: LD_VAR 0 4
22102: PPUSH
22103: EMPTY
22104: PPUSH
22105: CALL_OW 1
22109: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22110: LD_ADDR_EXP 108
22114: PUSH
22115: LD_EXP 108
22119: PPUSH
22120: LD_VAR 0 4
22124: PPUSH
22125: EMPTY
22126: PPUSH
22127: CALL_OW 1
22131: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22132: LD_ADDR_EXP 109
22136: PUSH
22137: LD_EXP 109
22141: PPUSH
22142: LD_VAR 0 4
22146: PPUSH
22147: EMPTY
22148: PPUSH
22149: CALL_OW 1
22153: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22154: LD_ADDR_EXP 110
22158: PUSH
22159: LD_EXP 110
22163: PPUSH
22164: LD_VAR 0 4
22168: PPUSH
22169: EMPTY
22170: PPUSH
22171: CALL_OW 1
22175: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22176: LD_ADDR_EXP 111
22180: PUSH
22181: LD_EXP 111
22185: PPUSH
22186: LD_VAR 0 4
22190: PPUSH
22191: EMPTY
22192: PPUSH
22193: CALL_OW 1
22197: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22198: LD_ADDR_EXP 112
22202: PUSH
22203: LD_EXP 112
22207: PPUSH
22208: LD_VAR 0 4
22212: PPUSH
22213: EMPTY
22214: PPUSH
22215: CALL_OW 1
22219: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22220: LD_ADDR_EXP 113
22224: PUSH
22225: LD_EXP 113
22229: PPUSH
22230: LD_VAR 0 4
22234: PPUSH
22235: EMPTY
22236: PPUSH
22237: CALL_OW 1
22241: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22242: LD_ADDR_EXP 114
22246: PUSH
22247: LD_EXP 114
22251: PPUSH
22252: LD_VAR 0 4
22256: PPUSH
22257: EMPTY
22258: PPUSH
22259: CALL_OW 1
22263: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22264: LD_ADDR_EXP 115
22268: PUSH
22269: LD_EXP 115
22273: PPUSH
22274: LD_VAR 0 4
22278: PPUSH
22279: EMPTY
22280: PPUSH
22281: CALL_OW 1
22285: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22286: LD_ADDR_EXP 116
22290: PUSH
22291: LD_EXP 116
22295: PPUSH
22296: LD_VAR 0 4
22300: PPUSH
22301: EMPTY
22302: PPUSH
22303: CALL_OW 1
22307: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22308: LD_ADDR_EXP 117
22312: PUSH
22313: LD_EXP 117
22317: PPUSH
22318: LD_VAR 0 4
22322: PPUSH
22323: EMPTY
22324: PPUSH
22325: CALL_OW 1
22329: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22330: LD_ADDR_EXP 118
22334: PUSH
22335: LD_EXP 118
22339: PPUSH
22340: LD_VAR 0 4
22344: PPUSH
22345: LD_INT 0
22347: PPUSH
22348: CALL_OW 1
22352: ST_TO_ADDR
// result := base ;
22353: LD_ADDR_VAR 0 3
22357: PUSH
22358: LD_VAR 0 4
22362: ST_TO_ADDR
// end ;
22363: LD_VAR 0 3
22367: RET
// export function MC_Start ( ) ; var i ; begin
22368: LD_INT 0
22370: PPUSH
22371: PPUSH
// for i = 1 to mc_bases do
22372: LD_ADDR_VAR 0 2
22376: PUSH
22377: DOUBLE
22378: LD_INT 1
22380: DEC
22381: ST_TO_ADDR
22382: LD_EXP 76
22386: PUSH
22387: FOR_TO
22388: IFFALSE 23465
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22390: LD_ADDR_EXP 76
22394: PUSH
22395: LD_EXP 76
22399: PPUSH
22400: LD_VAR 0 2
22404: PPUSH
22405: LD_EXP 76
22409: PUSH
22410: LD_VAR 0 2
22414: ARRAY
22415: PUSH
22416: LD_INT 0
22418: DIFF
22419: PPUSH
22420: CALL_OW 1
22424: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22425: LD_ADDR_EXP 77
22429: PUSH
22430: LD_EXP 77
22434: PPUSH
22435: LD_VAR 0 2
22439: PPUSH
22440: EMPTY
22441: PPUSH
22442: CALL_OW 1
22446: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22447: LD_ADDR_EXP 78
22451: PUSH
22452: LD_EXP 78
22456: PPUSH
22457: LD_VAR 0 2
22461: PPUSH
22462: EMPTY
22463: PPUSH
22464: CALL_OW 1
22468: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22469: LD_ADDR_EXP 79
22473: PUSH
22474: LD_EXP 79
22478: PPUSH
22479: LD_VAR 0 2
22483: PPUSH
22484: EMPTY
22485: PPUSH
22486: CALL_OW 1
22490: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22491: LD_ADDR_EXP 80
22495: PUSH
22496: LD_EXP 80
22500: PPUSH
22501: LD_VAR 0 2
22505: PPUSH
22506: EMPTY
22507: PUSH
22508: EMPTY
22509: PUSH
22510: EMPTY
22511: LIST
22512: LIST
22513: PPUSH
22514: CALL_OW 1
22518: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22519: LD_ADDR_EXP 81
22523: PUSH
22524: LD_EXP 81
22528: PPUSH
22529: LD_VAR 0 2
22533: PPUSH
22534: EMPTY
22535: PPUSH
22536: CALL_OW 1
22540: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22541: LD_ADDR_EXP 108
22545: PUSH
22546: LD_EXP 108
22550: PPUSH
22551: LD_VAR 0 2
22555: PPUSH
22556: EMPTY
22557: PPUSH
22558: CALL_OW 1
22562: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22563: LD_ADDR_EXP 82
22567: PUSH
22568: LD_EXP 82
22572: PPUSH
22573: LD_VAR 0 2
22577: PPUSH
22578: EMPTY
22579: PPUSH
22580: CALL_OW 1
22584: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22585: LD_ADDR_EXP 83
22589: PUSH
22590: LD_EXP 83
22594: PPUSH
22595: LD_VAR 0 2
22599: PPUSH
22600: EMPTY
22601: PPUSH
22602: CALL_OW 1
22606: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22607: LD_ADDR_EXP 84
22611: PUSH
22612: LD_EXP 84
22616: PPUSH
22617: LD_VAR 0 2
22621: PPUSH
22622: LD_EXP 76
22626: PUSH
22627: LD_VAR 0 2
22631: ARRAY
22632: PPUSH
22633: LD_INT 2
22635: PUSH
22636: LD_INT 30
22638: PUSH
22639: LD_INT 32
22641: PUSH
22642: EMPTY
22643: LIST
22644: LIST
22645: PUSH
22646: LD_INT 30
22648: PUSH
22649: LD_INT 33
22651: PUSH
22652: EMPTY
22653: LIST
22654: LIST
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: LIST
22660: PPUSH
22661: CALL_OW 72
22665: PPUSH
22666: CALL_OW 1
22670: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22671: LD_ADDR_EXP 85
22675: PUSH
22676: LD_EXP 85
22680: PPUSH
22681: LD_VAR 0 2
22685: PPUSH
22686: LD_EXP 76
22690: PUSH
22691: LD_VAR 0 2
22695: ARRAY
22696: PPUSH
22697: LD_INT 2
22699: PUSH
22700: LD_INT 30
22702: PUSH
22703: LD_INT 32
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: PUSH
22710: LD_INT 30
22712: PUSH
22713: LD_INT 31
22715: PUSH
22716: EMPTY
22717: LIST
22718: LIST
22719: PUSH
22720: EMPTY
22721: LIST
22722: LIST
22723: LIST
22724: PUSH
22725: LD_INT 58
22727: PUSH
22728: EMPTY
22729: LIST
22730: PUSH
22731: EMPTY
22732: LIST
22733: LIST
22734: PPUSH
22735: CALL_OW 72
22739: PPUSH
22740: CALL_OW 1
22744: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22745: LD_ADDR_EXP 86
22749: PUSH
22750: LD_EXP 86
22754: PPUSH
22755: LD_VAR 0 2
22759: PPUSH
22760: EMPTY
22761: PPUSH
22762: CALL_OW 1
22766: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22767: LD_ADDR_EXP 90
22771: PUSH
22772: LD_EXP 90
22776: PPUSH
22777: LD_VAR 0 2
22781: PPUSH
22782: EMPTY
22783: PPUSH
22784: CALL_OW 1
22788: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22789: LD_ADDR_EXP 89
22793: PUSH
22794: LD_EXP 89
22798: PPUSH
22799: LD_VAR 0 2
22803: PPUSH
22804: EMPTY
22805: PPUSH
22806: CALL_OW 1
22810: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22811: LD_ADDR_EXP 91
22815: PUSH
22816: LD_EXP 91
22820: PPUSH
22821: LD_VAR 0 2
22825: PPUSH
22826: EMPTY
22827: PPUSH
22828: CALL_OW 1
22832: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22833: LD_ADDR_EXP 92
22837: PUSH
22838: LD_EXP 92
22842: PPUSH
22843: LD_VAR 0 2
22847: PPUSH
22848: EMPTY
22849: PPUSH
22850: CALL_OW 1
22854: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22855: LD_ADDR_EXP 93
22859: PUSH
22860: LD_EXP 93
22864: PPUSH
22865: LD_VAR 0 2
22869: PPUSH
22870: EMPTY
22871: PPUSH
22872: CALL_OW 1
22876: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22877: LD_ADDR_EXP 94
22881: PUSH
22882: LD_EXP 94
22886: PPUSH
22887: LD_VAR 0 2
22891: PPUSH
22892: EMPTY
22893: PPUSH
22894: CALL_OW 1
22898: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
22899: LD_ADDR_EXP 95
22903: PUSH
22904: LD_EXP 95
22908: PPUSH
22909: LD_VAR 0 2
22913: PPUSH
22914: EMPTY
22915: PPUSH
22916: CALL_OW 1
22920: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22921: LD_ADDR_EXP 96
22925: PUSH
22926: LD_EXP 96
22930: PPUSH
22931: LD_VAR 0 2
22935: PPUSH
22936: EMPTY
22937: PPUSH
22938: CALL_OW 1
22942: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
22943: LD_ADDR_EXP 97
22947: PUSH
22948: LD_EXP 97
22952: PPUSH
22953: LD_VAR 0 2
22957: PPUSH
22958: EMPTY
22959: PPUSH
22960: CALL_OW 1
22964: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
22965: LD_ADDR_EXP 98
22969: PUSH
22970: LD_EXP 98
22974: PPUSH
22975: LD_VAR 0 2
22979: PPUSH
22980: EMPTY
22981: PPUSH
22982: CALL_OW 1
22986: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
22987: LD_ADDR_EXP 87
22991: PUSH
22992: LD_EXP 87
22996: PPUSH
22997: LD_VAR 0 2
23001: PPUSH
23002: LD_INT 0
23004: PPUSH
23005: CALL_OW 1
23009: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23010: LD_ADDR_EXP 100
23014: PUSH
23015: LD_EXP 100
23019: PPUSH
23020: LD_VAR 0 2
23024: PPUSH
23025: LD_INT 0
23027: PPUSH
23028: CALL_OW 1
23032: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23033: LD_ADDR_EXP 88
23037: PUSH
23038: LD_EXP 88
23042: PPUSH
23043: LD_VAR 0 2
23047: PPUSH
23048: EMPTY
23049: PPUSH
23050: CALL_OW 1
23054: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23055: LD_ADDR_EXP 99
23059: PUSH
23060: LD_EXP 99
23064: PPUSH
23065: LD_VAR 0 2
23069: PPUSH
23070: LD_INT 0
23072: PPUSH
23073: CALL_OW 1
23077: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23078: LD_ADDR_EXP 101
23082: PUSH
23083: LD_EXP 101
23087: PPUSH
23088: LD_VAR 0 2
23092: PPUSH
23093: EMPTY
23094: PPUSH
23095: CALL_OW 1
23099: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23100: LD_ADDR_EXP 104
23104: PUSH
23105: LD_EXP 104
23109: PPUSH
23110: LD_VAR 0 2
23114: PPUSH
23115: LD_INT 0
23117: PPUSH
23118: CALL_OW 1
23122: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23123: LD_ADDR_EXP 105
23127: PUSH
23128: LD_EXP 105
23132: PPUSH
23133: LD_VAR 0 2
23137: PPUSH
23138: EMPTY
23139: PPUSH
23140: CALL_OW 1
23144: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23145: LD_ADDR_EXP 106
23149: PUSH
23150: LD_EXP 106
23154: PPUSH
23155: LD_VAR 0 2
23159: PPUSH
23160: EMPTY
23161: PPUSH
23162: CALL_OW 1
23166: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23167: LD_ADDR_EXP 107
23171: PUSH
23172: LD_EXP 107
23176: PPUSH
23177: LD_VAR 0 2
23181: PPUSH
23182: EMPTY
23183: PPUSH
23184: CALL_OW 1
23188: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23189: LD_ADDR_EXP 109
23193: PUSH
23194: LD_EXP 109
23198: PPUSH
23199: LD_VAR 0 2
23203: PPUSH
23204: LD_EXP 76
23208: PUSH
23209: LD_VAR 0 2
23213: ARRAY
23214: PPUSH
23215: LD_INT 2
23217: PUSH
23218: LD_INT 30
23220: PUSH
23221: LD_INT 6
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: PUSH
23228: LD_INT 30
23230: PUSH
23231: LD_INT 7
23233: PUSH
23234: EMPTY
23235: LIST
23236: LIST
23237: PUSH
23238: LD_INT 30
23240: PUSH
23241: LD_INT 8
23243: PUSH
23244: EMPTY
23245: LIST
23246: LIST
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: LIST
23252: LIST
23253: PPUSH
23254: CALL_OW 72
23258: PPUSH
23259: CALL_OW 1
23263: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23264: LD_ADDR_EXP 110
23268: PUSH
23269: LD_EXP 110
23273: PPUSH
23274: LD_VAR 0 2
23278: PPUSH
23279: EMPTY
23280: PPUSH
23281: CALL_OW 1
23285: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23286: LD_ADDR_EXP 111
23290: PUSH
23291: LD_EXP 111
23295: PPUSH
23296: LD_VAR 0 2
23300: PPUSH
23301: EMPTY
23302: PPUSH
23303: CALL_OW 1
23307: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23308: LD_ADDR_EXP 112
23312: PUSH
23313: LD_EXP 112
23317: PPUSH
23318: LD_VAR 0 2
23322: PPUSH
23323: EMPTY
23324: PPUSH
23325: CALL_OW 1
23329: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23330: LD_ADDR_EXP 113
23334: PUSH
23335: LD_EXP 113
23339: PPUSH
23340: LD_VAR 0 2
23344: PPUSH
23345: EMPTY
23346: PPUSH
23347: CALL_OW 1
23351: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23352: LD_ADDR_EXP 114
23356: PUSH
23357: LD_EXP 114
23361: PPUSH
23362: LD_VAR 0 2
23366: PPUSH
23367: EMPTY
23368: PPUSH
23369: CALL_OW 1
23373: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23374: LD_ADDR_EXP 115
23378: PUSH
23379: LD_EXP 115
23383: PPUSH
23384: LD_VAR 0 2
23388: PPUSH
23389: EMPTY
23390: PPUSH
23391: CALL_OW 1
23395: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23396: LD_ADDR_EXP 116
23400: PUSH
23401: LD_EXP 116
23405: PPUSH
23406: LD_VAR 0 2
23410: PPUSH
23411: EMPTY
23412: PPUSH
23413: CALL_OW 1
23417: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23418: LD_ADDR_EXP 117
23422: PUSH
23423: LD_EXP 117
23427: PPUSH
23428: LD_VAR 0 2
23432: PPUSH
23433: EMPTY
23434: PPUSH
23435: CALL_OW 1
23439: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23440: LD_ADDR_EXP 118
23444: PUSH
23445: LD_EXP 118
23449: PPUSH
23450: LD_VAR 0 2
23454: PPUSH
23455: LD_INT 0
23457: PPUSH
23458: CALL_OW 1
23462: ST_TO_ADDR
// end ;
23463: GO 22387
23465: POP
23466: POP
// MC_InitSides ( ) ;
23467: CALL 23753 0 0
// MC_InitResearch ( ) ;
23471: CALL 23492 0 0
// CustomInitMacro ( ) ;
23475: CALL 189 0 0
// skirmish := true ;
23479: LD_ADDR_EXP 74
23483: PUSH
23484: LD_INT 1
23486: ST_TO_ADDR
// end ;
23487: LD_VAR 0 1
23491: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23492: LD_INT 0
23494: PPUSH
23495: PPUSH
23496: PPUSH
23497: PPUSH
23498: PPUSH
23499: PPUSH
// if not mc_bases then
23500: LD_EXP 76
23504: NOT
23505: IFFALSE 23509
// exit ;
23507: GO 23748
// for i = 1 to 8 do
23509: LD_ADDR_VAR 0 2
23513: PUSH
23514: DOUBLE
23515: LD_INT 1
23517: DEC
23518: ST_TO_ADDR
23519: LD_INT 8
23521: PUSH
23522: FOR_TO
23523: IFFALSE 23549
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23525: LD_ADDR_EXP 103
23529: PUSH
23530: LD_EXP 103
23534: PPUSH
23535: LD_VAR 0 2
23539: PPUSH
23540: EMPTY
23541: PPUSH
23542: CALL_OW 1
23546: ST_TO_ADDR
23547: GO 23522
23549: POP
23550: POP
// tmp := [ ] ;
23551: LD_ADDR_VAR 0 5
23555: PUSH
23556: EMPTY
23557: ST_TO_ADDR
// for i = 1 to mc_sides do
23558: LD_ADDR_VAR 0 2
23562: PUSH
23563: DOUBLE
23564: LD_INT 1
23566: DEC
23567: ST_TO_ADDR
23568: LD_EXP 102
23572: PUSH
23573: FOR_TO
23574: IFFALSE 23632
// if not mc_sides [ i ] in tmp then
23576: LD_EXP 102
23580: PUSH
23581: LD_VAR 0 2
23585: ARRAY
23586: PUSH
23587: LD_VAR 0 5
23591: IN
23592: NOT
23593: IFFALSE 23630
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23595: LD_ADDR_VAR 0 5
23599: PUSH
23600: LD_VAR 0 5
23604: PPUSH
23605: LD_VAR 0 5
23609: PUSH
23610: LD_INT 1
23612: PLUS
23613: PPUSH
23614: LD_EXP 102
23618: PUSH
23619: LD_VAR 0 2
23623: ARRAY
23624: PPUSH
23625: CALL_OW 2
23629: ST_TO_ADDR
23630: GO 23573
23632: POP
23633: POP
// if not tmp then
23634: LD_VAR 0 5
23638: NOT
23639: IFFALSE 23643
// exit ;
23641: GO 23748
// for j in tmp do
23643: LD_ADDR_VAR 0 3
23647: PUSH
23648: LD_VAR 0 5
23652: PUSH
23653: FOR_IN
23654: IFFALSE 23746
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23656: LD_ADDR_VAR 0 6
23660: PUSH
23661: LD_INT 22
23663: PUSH
23664: LD_VAR 0 3
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: PPUSH
23673: CALL_OW 69
23677: ST_TO_ADDR
// if not un then
23678: LD_VAR 0 6
23682: NOT
23683: IFFALSE 23687
// continue ;
23685: GO 23653
// nation := GetNation ( un [ 1 ] ) ;
23687: LD_ADDR_VAR 0 4
23691: PUSH
23692: LD_VAR 0 6
23696: PUSH
23697: LD_INT 1
23699: ARRAY
23700: PPUSH
23701: CALL_OW 248
23705: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23706: LD_ADDR_EXP 103
23710: PUSH
23711: LD_EXP 103
23715: PPUSH
23716: LD_VAR 0 3
23720: PPUSH
23721: LD_VAR 0 3
23725: PPUSH
23726: LD_VAR 0 4
23730: PPUSH
23731: LD_INT 1
23733: PPUSH
23734: CALL 50358 0 3
23738: PPUSH
23739: CALL_OW 1
23743: ST_TO_ADDR
// end ;
23744: GO 23653
23746: POP
23747: POP
// end ;
23748: LD_VAR 0 1
23752: RET
// export function MC_InitSides ( ) ; var i ; begin
23753: LD_INT 0
23755: PPUSH
23756: PPUSH
// if not mc_bases then
23757: LD_EXP 76
23761: NOT
23762: IFFALSE 23766
// exit ;
23764: GO 23840
// for i = 1 to mc_bases do
23766: LD_ADDR_VAR 0 2
23770: PUSH
23771: DOUBLE
23772: LD_INT 1
23774: DEC
23775: ST_TO_ADDR
23776: LD_EXP 76
23780: PUSH
23781: FOR_TO
23782: IFFALSE 23838
// if mc_bases [ i ] then
23784: LD_EXP 76
23788: PUSH
23789: LD_VAR 0 2
23793: ARRAY
23794: IFFALSE 23836
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23796: LD_ADDR_EXP 102
23800: PUSH
23801: LD_EXP 102
23805: PPUSH
23806: LD_VAR 0 2
23810: PPUSH
23811: LD_EXP 76
23815: PUSH
23816: LD_VAR 0 2
23820: ARRAY
23821: PUSH
23822: LD_INT 1
23824: ARRAY
23825: PPUSH
23826: CALL_OW 255
23830: PPUSH
23831: CALL_OW 1
23835: ST_TO_ADDR
23836: GO 23781
23838: POP
23839: POP
// end ;
23840: LD_VAR 0 1
23844: RET
// every 0 0$01 trigger skirmish do
23845: LD_EXP 74
23849: IFFALSE 24003
23851: GO 23853
23853: DISABLE
// begin enable ;
23854: ENABLE
// MC_CheckBuildings ( ) ;
23855: CALL 28501 0 0
// MC_CheckPeopleLife ( ) ;
23859: CALL 28626 0 0
// RaiseSailEvent ( 100 ) ;
23863: LD_INT 100
23865: PPUSH
23866: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23870: LD_INT 103
23872: PPUSH
23873: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23877: LD_INT 104
23879: PPUSH
23880: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23884: LD_INT 105
23886: PPUSH
23887: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
23891: LD_INT 106
23893: PPUSH
23894: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
23898: LD_INT 107
23900: PPUSH
23901: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
23905: LD_INT 108
23907: PPUSH
23908: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
23912: LD_INT 109
23914: PPUSH
23915: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
23919: LD_INT 110
23921: PPUSH
23922: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
23926: LD_INT 111
23928: PPUSH
23929: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
23933: LD_INT 112
23935: PPUSH
23936: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
23940: LD_INT 113
23942: PPUSH
23943: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
23947: LD_INT 120
23949: PPUSH
23950: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
23954: LD_INT 121
23956: PPUSH
23957: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
23961: LD_INT 122
23963: PPUSH
23964: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
23968: LD_INT 123
23970: PPUSH
23971: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
23975: LD_INT 124
23977: PPUSH
23978: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
23982: LD_INT 125
23984: PPUSH
23985: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
23989: LD_INT 126
23991: PPUSH
23992: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
23996: LD_INT 200
23998: PPUSH
23999: CALL_OW 427
// end ;
24003: END
// on SailEvent ( event ) do begin if event < 100 then
24004: LD_VAR 0 1
24008: PUSH
24009: LD_INT 100
24011: LESS
24012: IFFALSE 24023
// CustomEvent ( event ) ;
24014: LD_VAR 0 1
24018: PPUSH
24019: CALL 10232 0 1
// if event = 100 then
24023: LD_VAR 0 1
24027: PUSH
24028: LD_INT 100
24030: EQUAL
24031: IFFALSE 24037
// MC_ClassManager ( ) ;
24033: CALL 24429 0 0
// if event = 101 then
24037: LD_VAR 0 1
24041: PUSH
24042: LD_INT 101
24044: EQUAL
24045: IFFALSE 24051
// MC_RepairBuildings ( ) ;
24047: CALL 29222 0 0
// if event = 102 then
24051: LD_VAR 0 1
24055: PUSH
24056: LD_INT 102
24058: EQUAL
24059: IFFALSE 24065
// MC_Heal ( ) ;
24061: CALL 30086 0 0
// if event = 103 then
24065: LD_VAR 0 1
24069: PUSH
24070: LD_INT 103
24072: EQUAL
24073: IFFALSE 24079
// MC_Build ( ) ;
24075: CALL 30508 0 0
// if event = 104 then
24079: LD_VAR 0 1
24083: PUSH
24084: LD_INT 104
24086: EQUAL
24087: IFFALSE 24093
// MC_TurretWeapon ( ) ;
24089: CALL 32121 0 0
// if event = 105 then
24093: LD_VAR 0 1
24097: PUSH
24098: LD_INT 105
24100: EQUAL
24101: IFFALSE 24107
// MC_BuildUpgrade ( ) ;
24103: CALL 31672 0 0
// if event = 106 then
24107: LD_VAR 0 1
24111: PUSH
24112: LD_INT 106
24114: EQUAL
24115: IFFALSE 24121
// MC_PlantMines ( ) ;
24117: CALL 32551 0 0
// if event = 107 then
24121: LD_VAR 0 1
24125: PUSH
24126: LD_INT 107
24128: EQUAL
24129: IFFALSE 24135
// MC_CollectCrates ( ) ;
24131: CALL 33349 0 0
// if event = 108 then
24135: LD_VAR 0 1
24139: PUSH
24140: LD_INT 108
24142: EQUAL
24143: IFFALSE 24149
// MC_LinkRemoteControl ( ) ;
24145: CALL 35125 0 0
// if event = 109 then
24149: LD_VAR 0 1
24153: PUSH
24154: LD_INT 109
24156: EQUAL
24157: IFFALSE 24163
// MC_ProduceVehicle ( ) ;
24159: CALL 35306 0 0
// if event = 110 then
24163: LD_VAR 0 1
24167: PUSH
24168: LD_INT 110
24170: EQUAL
24171: IFFALSE 24177
// MC_SendAttack ( ) ;
24173: CALL 35772 0 0
// if event = 111 then
24177: LD_VAR 0 1
24181: PUSH
24182: LD_INT 111
24184: EQUAL
24185: IFFALSE 24191
// MC_Defend ( ) ;
24187: CALL 35880 0 0
// if event = 112 then
24191: LD_VAR 0 1
24195: PUSH
24196: LD_INT 112
24198: EQUAL
24199: IFFALSE 24205
// MC_Research ( ) ;
24201: CALL 36485 0 0
// if event = 113 then
24205: LD_VAR 0 1
24209: PUSH
24210: LD_INT 113
24212: EQUAL
24213: IFFALSE 24219
// MC_MinesTrigger ( ) ;
24215: CALL 37599 0 0
// if event = 120 then
24219: LD_VAR 0 1
24223: PUSH
24224: LD_INT 120
24226: EQUAL
24227: IFFALSE 24233
// MC_RepairVehicle ( ) ;
24229: CALL 37698 0 0
// if event = 121 then
24233: LD_VAR 0 1
24237: PUSH
24238: LD_INT 121
24240: EQUAL
24241: IFFALSE 24247
// MC_TameApe ( ) ;
24243: CALL 38428 0 0
// if event = 122 then
24247: LD_VAR 0 1
24251: PUSH
24252: LD_INT 122
24254: EQUAL
24255: IFFALSE 24261
// MC_ChangeApeClass ( ) ;
24257: CALL 39257 0 0
// if event = 123 then
24261: LD_VAR 0 1
24265: PUSH
24266: LD_INT 123
24268: EQUAL
24269: IFFALSE 24275
// MC_Bazooka ( ) ;
24271: CALL 39907 0 0
// if event = 124 then
24275: LD_VAR 0 1
24279: PUSH
24280: LD_INT 124
24282: EQUAL
24283: IFFALSE 24289
// MC_TeleportExit ( ) ;
24285: CALL 40105 0 0
// if event = 125 then
24289: LD_VAR 0 1
24293: PUSH
24294: LD_INT 125
24296: EQUAL
24297: IFFALSE 24303
// MC_Deposits ( ) ;
24299: CALL 40752 0 0
// if event = 126 then
24303: LD_VAR 0 1
24307: PUSH
24308: LD_INT 126
24310: EQUAL
24311: IFFALSE 24317
// MC_RemoteDriver ( ) ;
24313: CALL 41377 0 0
// if event = 200 then
24317: LD_VAR 0 1
24321: PUSH
24322: LD_INT 200
24324: EQUAL
24325: IFFALSE 24331
// MC_Idle ( ) ;
24327: CALL 43326 0 0
// end ;
24331: PPOPN 1
24333: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24334: LD_INT 0
24336: PPUSH
24337: PPUSH
// if not mc_bases [ base ] or not tag then
24338: LD_EXP 76
24342: PUSH
24343: LD_VAR 0 1
24347: ARRAY
24348: NOT
24349: PUSH
24350: LD_VAR 0 2
24354: NOT
24355: OR
24356: IFFALSE 24360
// exit ;
24358: GO 24424
// for i in mc_bases [ base ] union mc_ape [ base ] do
24360: LD_ADDR_VAR 0 4
24364: PUSH
24365: LD_EXP 76
24369: PUSH
24370: LD_VAR 0 1
24374: ARRAY
24375: PUSH
24376: LD_EXP 105
24380: PUSH
24381: LD_VAR 0 1
24385: ARRAY
24386: UNION
24387: PUSH
24388: FOR_IN
24389: IFFALSE 24422
// if GetTag ( i ) = tag then
24391: LD_VAR 0 4
24395: PPUSH
24396: CALL_OW 110
24400: PUSH
24401: LD_VAR 0 2
24405: EQUAL
24406: IFFALSE 24420
// SetTag ( i , 0 ) ;
24408: LD_VAR 0 4
24412: PPUSH
24413: LD_INT 0
24415: PPUSH
24416: CALL_OW 109
24420: GO 24388
24422: POP
24423: POP
// end ;
24424: LD_VAR 0 3
24428: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24429: LD_INT 0
24431: PPUSH
24432: PPUSH
24433: PPUSH
24434: PPUSH
24435: PPUSH
24436: PPUSH
24437: PPUSH
24438: PPUSH
// if not mc_bases then
24439: LD_EXP 76
24443: NOT
24444: IFFALSE 24448
// exit ;
24446: GO 24906
// for i = 1 to mc_bases do
24448: LD_ADDR_VAR 0 2
24452: PUSH
24453: DOUBLE
24454: LD_INT 1
24456: DEC
24457: ST_TO_ADDR
24458: LD_EXP 76
24462: PUSH
24463: FOR_TO
24464: IFFALSE 24904
// begin tmp := MC_ClassCheckReq ( i ) ;
24466: LD_ADDR_VAR 0 4
24470: PUSH
24471: LD_VAR 0 2
24475: PPUSH
24476: CALL 24911 0 1
24480: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24481: LD_ADDR_EXP 117
24485: PUSH
24486: LD_EXP 117
24490: PPUSH
24491: LD_VAR 0 2
24495: PPUSH
24496: LD_VAR 0 4
24500: PPUSH
24501: CALL_OW 1
24505: ST_TO_ADDR
// if not tmp then
24506: LD_VAR 0 4
24510: NOT
24511: IFFALSE 24515
// continue ;
24513: GO 24463
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24515: LD_ADDR_VAR 0 6
24519: PUSH
24520: LD_EXP 76
24524: PUSH
24525: LD_VAR 0 2
24529: ARRAY
24530: PPUSH
24531: LD_INT 2
24533: PUSH
24534: LD_INT 30
24536: PUSH
24537: LD_INT 4
24539: PUSH
24540: EMPTY
24541: LIST
24542: LIST
24543: PUSH
24544: LD_INT 30
24546: PUSH
24547: LD_INT 5
24549: PUSH
24550: EMPTY
24551: LIST
24552: LIST
24553: PUSH
24554: EMPTY
24555: LIST
24556: LIST
24557: LIST
24558: PPUSH
24559: CALL_OW 72
24563: PUSH
24564: LD_EXP 76
24568: PUSH
24569: LD_VAR 0 2
24573: ARRAY
24574: PPUSH
24575: LD_INT 2
24577: PUSH
24578: LD_INT 30
24580: PUSH
24581: LD_INT 0
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: PUSH
24588: LD_INT 30
24590: PUSH
24591: LD_INT 1
24593: PUSH
24594: EMPTY
24595: LIST
24596: LIST
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: LIST
24602: PPUSH
24603: CALL_OW 72
24607: PUSH
24608: LD_EXP 76
24612: PUSH
24613: LD_VAR 0 2
24617: ARRAY
24618: PPUSH
24619: LD_INT 30
24621: PUSH
24622: LD_INT 3
24624: PUSH
24625: EMPTY
24626: LIST
24627: LIST
24628: PPUSH
24629: CALL_OW 72
24633: PUSH
24634: LD_EXP 76
24638: PUSH
24639: LD_VAR 0 2
24643: ARRAY
24644: PPUSH
24645: LD_INT 2
24647: PUSH
24648: LD_INT 30
24650: PUSH
24651: LD_INT 6
24653: PUSH
24654: EMPTY
24655: LIST
24656: LIST
24657: PUSH
24658: LD_INT 30
24660: PUSH
24661: LD_INT 7
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: PUSH
24668: LD_INT 30
24670: PUSH
24671: LD_INT 8
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: PUSH
24678: EMPTY
24679: LIST
24680: LIST
24681: LIST
24682: LIST
24683: PPUSH
24684: CALL_OW 72
24688: PUSH
24689: EMPTY
24690: LIST
24691: LIST
24692: LIST
24693: LIST
24694: ST_TO_ADDR
// for j = 1 to 4 do
24695: LD_ADDR_VAR 0 3
24699: PUSH
24700: DOUBLE
24701: LD_INT 1
24703: DEC
24704: ST_TO_ADDR
24705: LD_INT 4
24707: PUSH
24708: FOR_TO
24709: IFFALSE 24900
// begin if not tmp [ j ] then
24711: LD_VAR 0 4
24715: PUSH
24716: LD_VAR 0 3
24720: ARRAY
24721: NOT
24722: IFFALSE 24726
// continue ;
24724: GO 24708
// for p in tmp [ j ] do
24726: LD_ADDR_VAR 0 5
24730: PUSH
24731: LD_VAR 0 4
24735: PUSH
24736: LD_VAR 0 3
24740: ARRAY
24741: PUSH
24742: FOR_IN
24743: IFFALSE 24896
// begin if not b [ j ] then
24745: LD_VAR 0 6
24749: PUSH
24750: LD_VAR 0 3
24754: ARRAY
24755: NOT
24756: IFFALSE 24760
// break ;
24758: GO 24896
// e := 0 ;
24760: LD_ADDR_VAR 0 7
24764: PUSH
24765: LD_INT 0
24767: ST_TO_ADDR
// for k in b [ j ] do
24768: LD_ADDR_VAR 0 8
24772: PUSH
24773: LD_VAR 0 6
24777: PUSH
24778: LD_VAR 0 3
24782: ARRAY
24783: PUSH
24784: FOR_IN
24785: IFFALSE 24812
// if IsNotFull ( k ) then
24787: LD_VAR 0 8
24791: PPUSH
24792: CALL 54798 0 1
24796: IFFALSE 24810
// begin e := k ;
24798: LD_ADDR_VAR 0 7
24802: PUSH
24803: LD_VAR 0 8
24807: ST_TO_ADDR
// break ;
24808: GO 24812
// end ;
24810: GO 24784
24812: POP
24813: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24814: LD_VAR 0 7
24818: PUSH
24819: LD_VAR 0 5
24823: PPUSH
24824: LD_VAR 0 7
24828: PPUSH
24829: CALL 91943 0 2
24833: NOT
24834: AND
24835: IFFALSE 24894
// begin if IsInUnit ( p ) then
24837: LD_VAR 0 5
24841: PPUSH
24842: CALL_OW 310
24846: IFFALSE 24857
// ComExitBuilding ( p ) ;
24848: LD_VAR 0 5
24852: PPUSH
24853: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24857: LD_VAR 0 5
24861: PPUSH
24862: LD_VAR 0 7
24866: PPUSH
24867: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24871: LD_VAR 0 5
24875: PPUSH
24876: LD_VAR 0 3
24880: PPUSH
24881: CALL_OW 183
// AddComExitBuilding ( p ) ;
24885: LD_VAR 0 5
24889: PPUSH
24890: CALL_OW 182
// end ; end ;
24894: GO 24742
24896: POP
24897: POP
// end ;
24898: GO 24708
24900: POP
24901: POP
// end ;
24902: GO 24463
24904: POP
24905: POP
// end ;
24906: LD_VAR 0 1
24910: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
24911: LD_INT 0
24913: PPUSH
24914: PPUSH
24915: PPUSH
24916: PPUSH
24917: PPUSH
24918: PPUSH
24919: PPUSH
24920: PPUSH
24921: PPUSH
24922: PPUSH
24923: PPUSH
24924: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24925: LD_VAR 0 1
24929: NOT
24930: PUSH
24931: LD_EXP 76
24935: PUSH
24936: LD_VAR 0 1
24940: ARRAY
24941: NOT
24942: OR
24943: PUSH
24944: LD_EXP 76
24948: PUSH
24949: LD_VAR 0 1
24953: ARRAY
24954: PPUSH
24955: LD_INT 2
24957: PUSH
24958: LD_INT 30
24960: PUSH
24961: LD_INT 0
24963: PUSH
24964: EMPTY
24965: LIST
24966: LIST
24967: PUSH
24968: LD_INT 30
24970: PUSH
24971: LD_INT 1
24973: PUSH
24974: EMPTY
24975: LIST
24976: LIST
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: LIST
24982: PPUSH
24983: CALL_OW 72
24987: NOT
24988: OR
24989: IFFALSE 24993
// exit ;
24991: GO 28496
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24993: LD_ADDR_VAR 0 4
24997: PUSH
24998: LD_EXP 76
25002: PUSH
25003: LD_VAR 0 1
25007: ARRAY
25008: PPUSH
25009: LD_INT 2
25011: PUSH
25012: LD_INT 25
25014: PUSH
25015: LD_INT 1
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: PUSH
25022: LD_INT 25
25024: PUSH
25025: LD_INT 2
25027: PUSH
25028: EMPTY
25029: LIST
25030: LIST
25031: PUSH
25032: LD_INT 25
25034: PUSH
25035: LD_INT 3
25037: PUSH
25038: EMPTY
25039: LIST
25040: LIST
25041: PUSH
25042: LD_INT 25
25044: PUSH
25045: LD_INT 4
25047: PUSH
25048: EMPTY
25049: LIST
25050: LIST
25051: PUSH
25052: LD_INT 25
25054: PUSH
25055: LD_INT 5
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: PUSH
25062: LD_INT 25
25064: PUSH
25065: LD_INT 8
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PUSH
25072: LD_INT 25
25074: PUSH
25075: LD_INT 9
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: LIST
25086: LIST
25087: LIST
25088: LIST
25089: LIST
25090: LIST
25091: PPUSH
25092: CALL_OW 72
25096: ST_TO_ADDR
// if not tmp then
25097: LD_VAR 0 4
25101: NOT
25102: IFFALSE 25106
// exit ;
25104: GO 28496
// for i in tmp do
25106: LD_ADDR_VAR 0 3
25110: PUSH
25111: LD_VAR 0 4
25115: PUSH
25116: FOR_IN
25117: IFFALSE 25148
// if GetTag ( i ) then
25119: LD_VAR 0 3
25123: PPUSH
25124: CALL_OW 110
25128: IFFALSE 25146
// tmp := tmp diff i ;
25130: LD_ADDR_VAR 0 4
25134: PUSH
25135: LD_VAR 0 4
25139: PUSH
25140: LD_VAR 0 3
25144: DIFF
25145: ST_TO_ADDR
25146: GO 25116
25148: POP
25149: POP
// if not tmp then
25150: LD_VAR 0 4
25154: NOT
25155: IFFALSE 25159
// exit ;
25157: GO 28496
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25159: LD_ADDR_VAR 0 5
25163: PUSH
25164: LD_EXP 76
25168: PUSH
25169: LD_VAR 0 1
25173: ARRAY
25174: PPUSH
25175: LD_INT 2
25177: PUSH
25178: LD_INT 25
25180: PUSH
25181: LD_INT 1
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: PUSH
25188: LD_INT 25
25190: PUSH
25191: LD_INT 5
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: PUSH
25198: LD_INT 25
25200: PUSH
25201: LD_INT 8
25203: PUSH
25204: EMPTY
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 25
25210: PUSH
25211: LD_INT 9
25213: PUSH
25214: EMPTY
25215: LIST
25216: LIST
25217: PUSH
25218: EMPTY
25219: LIST
25220: LIST
25221: LIST
25222: LIST
25223: LIST
25224: PPUSH
25225: CALL_OW 72
25229: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25230: LD_ADDR_VAR 0 6
25234: PUSH
25235: LD_EXP 76
25239: PUSH
25240: LD_VAR 0 1
25244: ARRAY
25245: PPUSH
25246: LD_INT 25
25248: PUSH
25249: LD_INT 2
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: PPUSH
25256: CALL_OW 72
25260: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25261: LD_ADDR_VAR 0 7
25265: PUSH
25266: LD_EXP 76
25270: PUSH
25271: LD_VAR 0 1
25275: ARRAY
25276: PPUSH
25277: LD_INT 25
25279: PUSH
25280: LD_INT 3
25282: PUSH
25283: EMPTY
25284: LIST
25285: LIST
25286: PPUSH
25287: CALL_OW 72
25291: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25292: LD_ADDR_VAR 0 8
25296: PUSH
25297: LD_EXP 76
25301: PUSH
25302: LD_VAR 0 1
25306: ARRAY
25307: PPUSH
25308: LD_INT 25
25310: PUSH
25311: LD_INT 4
25313: PUSH
25314: EMPTY
25315: LIST
25316: LIST
25317: PUSH
25318: LD_INT 24
25320: PUSH
25321: LD_INT 251
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: PPUSH
25332: CALL_OW 72
25336: ST_TO_ADDR
// if mc_scan [ base ] then
25337: LD_EXP 99
25341: PUSH
25342: LD_VAR 0 1
25346: ARRAY
25347: IFFALSE 25808
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25349: LD_ADDR_EXP 118
25353: PUSH
25354: LD_EXP 118
25358: PPUSH
25359: LD_VAR 0 1
25363: PPUSH
25364: LD_INT 4
25366: PPUSH
25367: CALL_OW 1
25371: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25372: LD_ADDR_VAR 0 12
25376: PUSH
25377: LD_EXP 76
25381: PUSH
25382: LD_VAR 0 1
25386: ARRAY
25387: PPUSH
25388: LD_INT 2
25390: PUSH
25391: LD_INT 30
25393: PUSH
25394: LD_INT 4
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: PUSH
25401: LD_INT 30
25403: PUSH
25404: LD_INT 5
25406: PUSH
25407: EMPTY
25408: LIST
25409: LIST
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: LIST
25415: PPUSH
25416: CALL_OW 72
25420: ST_TO_ADDR
// if not b then
25421: LD_VAR 0 12
25425: NOT
25426: IFFALSE 25430
// exit ;
25428: GO 28496
// p := [ ] ;
25430: LD_ADDR_VAR 0 11
25434: PUSH
25435: EMPTY
25436: ST_TO_ADDR
// if sci >= 2 then
25437: LD_VAR 0 8
25441: PUSH
25442: LD_INT 2
25444: GREATEREQUAL
25445: IFFALSE 25476
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25447: LD_ADDR_VAR 0 8
25451: PUSH
25452: LD_VAR 0 8
25456: PUSH
25457: LD_INT 1
25459: ARRAY
25460: PUSH
25461: LD_VAR 0 8
25465: PUSH
25466: LD_INT 2
25468: ARRAY
25469: PUSH
25470: EMPTY
25471: LIST
25472: LIST
25473: ST_TO_ADDR
25474: GO 25537
// if sci = 1 then
25476: LD_VAR 0 8
25480: PUSH
25481: LD_INT 1
25483: EQUAL
25484: IFFALSE 25505
// sci := [ sci [ 1 ] ] else
25486: LD_ADDR_VAR 0 8
25490: PUSH
25491: LD_VAR 0 8
25495: PUSH
25496: LD_INT 1
25498: ARRAY
25499: PUSH
25500: EMPTY
25501: LIST
25502: ST_TO_ADDR
25503: GO 25537
// if sci = 0 then
25505: LD_VAR 0 8
25509: PUSH
25510: LD_INT 0
25512: EQUAL
25513: IFFALSE 25537
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25515: LD_ADDR_VAR 0 11
25519: PUSH
25520: LD_VAR 0 4
25524: PPUSH
25525: LD_INT 4
25527: PPUSH
25528: CALL 91806 0 2
25532: PUSH
25533: LD_INT 1
25535: ARRAY
25536: ST_TO_ADDR
// if eng > 4 then
25537: LD_VAR 0 6
25541: PUSH
25542: LD_INT 4
25544: GREATER
25545: IFFALSE 25591
// for i = eng downto 4 do
25547: LD_ADDR_VAR 0 3
25551: PUSH
25552: DOUBLE
25553: LD_VAR 0 6
25557: INC
25558: ST_TO_ADDR
25559: LD_INT 4
25561: PUSH
25562: FOR_DOWNTO
25563: IFFALSE 25589
// eng := eng diff eng [ i ] ;
25565: LD_ADDR_VAR 0 6
25569: PUSH
25570: LD_VAR 0 6
25574: PUSH
25575: LD_VAR 0 6
25579: PUSH
25580: LD_VAR 0 3
25584: ARRAY
25585: DIFF
25586: ST_TO_ADDR
25587: GO 25562
25589: POP
25590: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25591: LD_ADDR_VAR 0 4
25595: PUSH
25596: LD_VAR 0 4
25600: PUSH
25601: LD_VAR 0 5
25605: PUSH
25606: LD_VAR 0 6
25610: UNION
25611: PUSH
25612: LD_VAR 0 7
25616: UNION
25617: PUSH
25618: LD_VAR 0 8
25622: UNION
25623: DIFF
25624: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25625: LD_ADDR_VAR 0 13
25629: PUSH
25630: LD_EXP 76
25634: PUSH
25635: LD_VAR 0 1
25639: ARRAY
25640: PPUSH
25641: LD_INT 2
25643: PUSH
25644: LD_INT 30
25646: PUSH
25647: LD_INT 32
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: LD_INT 30
25656: PUSH
25657: LD_INT 31
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: LIST
25668: PPUSH
25669: CALL_OW 72
25673: PUSH
25674: LD_EXP 76
25678: PUSH
25679: LD_VAR 0 1
25683: ARRAY
25684: PPUSH
25685: LD_INT 2
25687: PUSH
25688: LD_INT 30
25690: PUSH
25691: LD_INT 4
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 30
25700: PUSH
25701: LD_INT 5
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: EMPTY
25709: LIST
25710: LIST
25711: LIST
25712: PPUSH
25713: CALL_OW 72
25717: PUSH
25718: LD_INT 6
25720: MUL
25721: PLUS
25722: ST_TO_ADDR
// if bcount < tmp then
25723: LD_VAR 0 13
25727: PUSH
25728: LD_VAR 0 4
25732: LESS
25733: IFFALSE 25779
// for i = tmp downto bcount do
25735: LD_ADDR_VAR 0 3
25739: PUSH
25740: DOUBLE
25741: LD_VAR 0 4
25745: INC
25746: ST_TO_ADDR
25747: LD_VAR 0 13
25751: PUSH
25752: FOR_DOWNTO
25753: IFFALSE 25777
// tmp := Delete ( tmp , tmp ) ;
25755: LD_ADDR_VAR 0 4
25759: PUSH
25760: LD_VAR 0 4
25764: PPUSH
25765: LD_VAR 0 4
25769: PPUSH
25770: CALL_OW 3
25774: ST_TO_ADDR
25775: GO 25752
25777: POP
25778: POP
// result := [ tmp , 0 , 0 , p ] ;
25779: LD_ADDR_VAR 0 2
25783: PUSH
25784: LD_VAR 0 4
25788: PUSH
25789: LD_INT 0
25791: PUSH
25792: LD_INT 0
25794: PUSH
25795: LD_VAR 0 11
25799: PUSH
25800: EMPTY
25801: LIST
25802: LIST
25803: LIST
25804: LIST
25805: ST_TO_ADDR
// exit ;
25806: GO 28496
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25808: LD_EXP 76
25812: PUSH
25813: LD_VAR 0 1
25817: ARRAY
25818: PPUSH
25819: LD_INT 2
25821: PUSH
25822: LD_INT 30
25824: PUSH
25825: LD_INT 6
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: PUSH
25832: LD_INT 30
25834: PUSH
25835: LD_INT 7
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: PUSH
25842: LD_INT 30
25844: PUSH
25845: LD_INT 8
25847: PUSH
25848: EMPTY
25849: LIST
25850: LIST
25851: PUSH
25852: EMPTY
25853: LIST
25854: LIST
25855: LIST
25856: LIST
25857: PPUSH
25858: CALL_OW 72
25862: NOT
25863: PUSH
25864: LD_EXP 76
25868: PUSH
25869: LD_VAR 0 1
25873: ARRAY
25874: PPUSH
25875: LD_INT 30
25877: PUSH
25878: LD_INT 3
25880: PUSH
25881: EMPTY
25882: LIST
25883: LIST
25884: PPUSH
25885: CALL_OW 72
25889: NOT
25890: AND
25891: IFFALSE 25963
// begin if eng = tmp then
25893: LD_VAR 0 6
25897: PUSH
25898: LD_VAR 0 4
25902: EQUAL
25903: IFFALSE 25907
// exit ;
25905: GO 28496
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
25907: LD_ADDR_EXP 118
25911: PUSH
25912: LD_EXP 118
25916: PPUSH
25917: LD_VAR 0 1
25921: PPUSH
25922: LD_INT 1
25924: PPUSH
25925: CALL_OW 1
25929: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
25930: LD_ADDR_VAR 0 2
25934: PUSH
25935: LD_INT 0
25937: PUSH
25938: LD_VAR 0 4
25942: PUSH
25943: LD_VAR 0 6
25947: DIFF
25948: PUSH
25949: LD_INT 0
25951: PUSH
25952: LD_INT 0
25954: PUSH
25955: EMPTY
25956: LIST
25957: LIST
25958: LIST
25959: LIST
25960: ST_TO_ADDR
// exit ;
25961: GO 28496
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25963: LD_EXP 103
25967: PUSH
25968: LD_EXP 102
25972: PUSH
25973: LD_VAR 0 1
25977: ARRAY
25978: ARRAY
25979: PUSH
25980: LD_EXP 76
25984: PUSH
25985: LD_VAR 0 1
25989: ARRAY
25990: PPUSH
25991: LD_INT 2
25993: PUSH
25994: LD_INT 30
25996: PUSH
25997: LD_INT 6
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PUSH
26004: LD_INT 30
26006: PUSH
26007: LD_INT 7
26009: PUSH
26010: EMPTY
26011: LIST
26012: LIST
26013: PUSH
26014: LD_INT 30
26016: PUSH
26017: LD_INT 8
26019: PUSH
26020: EMPTY
26021: LIST
26022: LIST
26023: PUSH
26024: EMPTY
26025: LIST
26026: LIST
26027: LIST
26028: LIST
26029: PPUSH
26030: CALL_OW 72
26034: AND
26035: PUSH
26036: LD_EXP 76
26040: PUSH
26041: LD_VAR 0 1
26045: ARRAY
26046: PPUSH
26047: LD_INT 30
26049: PUSH
26050: LD_INT 3
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PPUSH
26057: CALL_OW 72
26061: NOT
26062: AND
26063: IFFALSE 26277
// begin if sci >= 6 then
26065: LD_VAR 0 8
26069: PUSH
26070: LD_INT 6
26072: GREATEREQUAL
26073: IFFALSE 26077
// exit ;
26075: GO 28496
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26077: LD_ADDR_EXP 118
26081: PUSH
26082: LD_EXP 118
26086: PPUSH
26087: LD_VAR 0 1
26091: PPUSH
26092: LD_INT 2
26094: PPUSH
26095: CALL_OW 1
26099: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26100: LD_ADDR_VAR 0 9
26104: PUSH
26105: LD_VAR 0 4
26109: PUSH
26110: LD_VAR 0 8
26114: DIFF
26115: PPUSH
26116: LD_INT 4
26118: PPUSH
26119: CALL 91806 0 2
26123: ST_TO_ADDR
// p := [ ] ;
26124: LD_ADDR_VAR 0 11
26128: PUSH
26129: EMPTY
26130: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26131: LD_VAR 0 8
26135: PUSH
26136: LD_INT 6
26138: LESS
26139: PUSH
26140: LD_VAR 0 9
26144: PUSH
26145: LD_INT 6
26147: GREATER
26148: AND
26149: IFFALSE 26230
// begin for i = 1 to 6 - sci do
26151: LD_ADDR_VAR 0 3
26155: PUSH
26156: DOUBLE
26157: LD_INT 1
26159: DEC
26160: ST_TO_ADDR
26161: LD_INT 6
26163: PUSH
26164: LD_VAR 0 8
26168: MINUS
26169: PUSH
26170: FOR_TO
26171: IFFALSE 26226
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26173: LD_ADDR_VAR 0 11
26177: PUSH
26178: LD_VAR 0 11
26182: PPUSH
26183: LD_VAR 0 11
26187: PUSH
26188: LD_INT 1
26190: PLUS
26191: PPUSH
26192: LD_VAR 0 9
26196: PUSH
26197: LD_INT 1
26199: ARRAY
26200: PPUSH
26201: CALL_OW 2
26205: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26206: LD_ADDR_VAR 0 9
26210: PUSH
26211: LD_VAR 0 9
26215: PPUSH
26216: LD_INT 1
26218: PPUSH
26219: CALL_OW 3
26223: ST_TO_ADDR
// end ;
26224: GO 26170
26226: POP
26227: POP
// end else
26228: GO 26250
// if sort then
26230: LD_VAR 0 9
26234: IFFALSE 26250
// p := sort [ 1 ] ;
26236: LD_ADDR_VAR 0 11
26240: PUSH
26241: LD_VAR 0 9
26245: PUSH
26246: LD_INT 1
26248: ARRAY
26249: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26250: LD_ADDR_VAR 0 2
26254: PUSH
26255: LD_INT 0
26257: PUSH
26258: LD_INT 0
26260: PUSH
26261: LD_INT 0
26263: PUSH
26264: LD_VAR 0 11
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: LIST
26273: LIST
26274: ST_TO_ADDR
// exit ;
26275: GO 28496
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26277: LD_EXP 103
26281: PUSH
26282: LD_EXP 102
26286: PUSH
26287: LD_VAR 0 1
26291: ARRAY
26292: ARRAY
26293: PUSH
26294: LD_EXP 76
26298: PUSH
26299: LD_VAR 0 1
26303: ARRAY
26304: PPUSH
26305: LD_INT 2
26307: PUSH
26308: LD_INT 30
26310: PUSH
26311: LD_INT 6
26313: PUSH
26314: EMPTY
26315: LIST
26316: LIST
26317: PUSH
26318: LD_INT 30
26320: PUSH
26321: LD_INT 7
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: PUSH
26328: LD_INT 30
26330: PUSH
26331: LD_INT 8
26333: PUSH
26334: EMPTY
26335: LIST
26336: LIST
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: LIST
26342: LIST
26343: PPUSH
26344: CALL_OW 72
26348: AND
26349: PUSH
26350: LD_EXP 76
26354: PUSH
26355: LD_VAR 0 1
26359: ARRAY
26360: PPUSH
26361: LD_INT 30
26363: PUSH
26364: LD_INT 3
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: PPUSH
26371: CALL_OW 72
26375: AND
26376: IFFALSE 27110
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26378: LD_ADDR_EXP 118
26382: PUSH
26383: LD_EXP 118
26387: PPUSH
26388: LD_VAR 0 1
26392: PPUSH
26393: LD_INT 3
26395: PPUSH
26396: CALL_OW 1
26400: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26401: LD_ADDR_VAR 0 2
26405: PUSH
26406: LD_INT 0
26408: PUSH
26409: LD_INT 0
26411: PUSH
26412: LD_INT 0
26414: PUSH
26415: LD_INT 0
26417: PUSH
26418: EMPTY
26419: LIST
26420: LIST
26421: LIST
26422: LIST
26423: ST_TO_ADDR
// if not eng then
26424: LD_VAR 0 6
26428: NOT
26429: IFFALSE 26492
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26431: LD_ADDR_VAR 0 11
26435: PUSH
26436: LD_VAR 0 4
26440: PPUSH
26441: LD_INT 2
26443: PPUSH
26444: CALL 91806 0 2
26448: PUSH
26449: LD_INT 1
26451: ARRAY
26452: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26453: LD_ADDR_VAR 0 2
26457: PUSH
26458: LD_VAR 0 2
26462: PPUSH
26463: LD_INT 2
26465: PPUSH
26466: LD_VAR 0 11
26470: PPUSH
26471: CALL_OW 1
26475: ST_TO_ADDR
// tmp := tmp diff p ;
26476: LD_ADDR_VAR 0 4
26480: PUSH
26481: LD_VAR 0 4
26485: PUSH
26486: LD_VAR 0 11
26490: DIFF
26491: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26492: LD_VAR 0 4
26496: PUSH
26497: LD_VAR 0 8
26501: PUSH
26502: LD_INT 6
26504: LESS
26505: AND
26506: IFFALSE 26694
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26508: LD_ADDR_VAR 0 9
26512: PUSH
26513: LD_VAR 0 4
26517: PUSH
26518: LD_VAR 0 8
26522: PUSH
26523: LD_VAR 0 7
26527: UNION
26528: DIFF
26529: PPUSH
26530: LD_INT 4
26532: PPUSH
26533: CALL 91806 0 2
26537: ST_TO_ADDR
// p := [ ] ;
26538: LD_ADDR_VAR 0 11
26542: PUSH
26543: EMPTY
26544: ST_TO_ADDR
// if sort then
26545: LD_VAR 0 9
26549: IFFALSE 26665
// for i = 1 to 6 - sci do
26551: LD_ADDR_VAR 0 3
26555: PUSH
26556: DOUBLE
26557: LD_INT 1
26559: DEC
26560: ST_TO_ADDR
26561: LD_INT 6
26563: PUSH
26564: LD_VAR 0 8
26568: MINUS
26569: PUSH
26570: FOR_TO
26571: IFFALSE 26663
// begin if i = sort then
26573: LD_VAR 0 3
26577: PUSH
26578: LD_VAR 0 9
26582: EQUAL
26583: IFFALSE 26587
// break ;
26585: GO 26663
// if GetClass ( i ) = 4 then
26587: LD_VAR 0 3
26591: PPUSH
26592: CALL_OW 257
26596: PUSH
26597: LD_INT 4
26599: EQUAL
26600: IFFALSE 26604
// continue ;
26602: GO 26570
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26604: LD_ADDR_VAR 0 11
26608: PUSH
26609: LD_VAR 0 11
26613: PPUSH
26614: LD_VAR 0 11
26618: PUSH
26619: LD_INT 1
26621: PLUS
26622: PPUSH
26623: LD_VAR 0 9
26627: PUSH
26628: LD_VAR 0 3
26632: ARRAY
26633: PPUSH
26634: CALL_OW 2
26638: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26639: LD_ADDR_VAR 0 4
26643: PUSH
26644: LD_VAR 0 4
26648: PUSH
26649: LD_VAR 0 9
26653: PUSH
26654: LD_VAR 0 3
26658: ARRAY
26659: DIFF
26660: ST_TO_ADDR
// end ;
26661: GO 26570
26663: POP
26664: POP
// if p then
26665: LD_VAR 0 11
26669: IFFALSE 26694
// result := Replace ( result , 4 , p ) ;
26671: LD_ADDR_VAR 0 2
26675: PUSH
26676: LD_VAR 0 2
26680: PPUSH
26681: LD_INT 4
26683: PPUSH
26684: LD_VAR 0 11
26688: PPUSH
26689: CALL_OW 1
26693: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26694: LD_VAR 0 4
26698: PUSH
26699: LD_VAR 0 7
26703: PUSH
26704: LD_INT 6
26706: LESS
26707: AND
26708: IFFALSE 26896
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26710: LD_ADDR_VAR 0 9
26714: PUSH
26715: LD_VAR 0 4
26719: PUSH
26720: LD_VAR 0 8
26724: PUSH
26725: LD_VAR 0 7
26729: UNION
26730: DIFF
26731: PPUSH
26732: LD_INT 3
26734: PPUSH
26735: CALL 91806 0 2
26739: ST_TO_ADDR
// p := [ ] ;
26740: LD_ADDR_VAR 0 11
26744: PUSH
26745: EMPTY
26746: ST_TO_ADDR
// if sort then
26747: LD_VAR 0 9
26751: IFFALSE 26867
// for i = 1 to 6 - mech do
26753: LD_ADDR_VAR 0 3
26757: PUSH
26758: DOUBLE
26759: LD_INT 1
26761: DEC
26762: ST_TO_ADDR
26763: LD_INT 6
26765: PUSH
26766: LD_VAR 0 7
26770: MINUS
26771: PUSH
26772: FOR_TO
26773: IFFALSE 26865
// begin if i = sort then
26775: LD_VAR 0 3
26779: PUSH
26780: LD_VAR 0 9
26784: EQUAL
26785: IFFALSE 26789
// break ;
26787: GO 26865
// if GetClass ( i ) = 3 then
26789: LD_VAR 0 3
26793: PPUSH
26794: CALL_OW 257
26798: PUSH
26799: LD_INT 3
26801: EQUAL
26802: IFFALSE 26806
// continue ;
26804: GO 26772
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26806: LD_ADDR_VAR 0 11
26810: PUSH
26811: LD_VAR 0 11
26815: PPUSH
26816: LD_VAR 0 11
26820: PUSH
26821: LD_INT 1
26823: PLUS
26824: PPUSH
26825: LD_VAR 0 9
26829: PUSH
26830: LD_VAR 0 3
26834: ARRAY
26835: PPUSH
26836: CALL_OW 2
26840: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26841: LD_ADDR_VAR 0 4
26845: PUSH
26846: LD_VAR 0 4
26850: PUSH
26851: LD_VAR 0 9
26855: PUSH
26856: LD_VAR 0 3
26860: ARRAY
26861: DIFF
26862: ST_TO_ADDR
// end ;
26863: GO 26772
26865: POP
26866: POP
// if p then
26867: LD_VAR 0 11
26871: IFFALSE 26896
// result := Replace ( result , 3 , p ) ;
26873: LD_ADDR_VAR 0 2
26877: PUSH
26878: LD_VAR 0 2
26882: PPUSH
26883: LD_INT 3
26885: PPUSH
26886: LD_VAR 0 11
26890: PPUSH
26891: CALL_OW 1
26895: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
26896: LD_VAR 0 4
26900: PUSH
26901: LD_INT 6
26903: GREATER
26904: PUSH
26905: LD_VAR 0 6
26909: PUSH
26910: LD_INT 6
26912: LESS
26913: AND
26914: IFFALSE 27108
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26916: LD_ADDR_VAR 0 9
26920: PUSH
26921: LD_VAR 0 4
26925: PUSH
26926: LD_VAR 0 8
26930: PUSH
26931: LD_VAR 0 7
26935: UNION
26936: PUSH
26937: LD_VAR 0 6
26941: UNION
26942: DIFF
26943: PPUSH
26944: LD_INT 2
26946: PPUSH
26947: CALL 91806 0 2
26951: ST_TO_ADDR
// p := [ ] ;
26952: LD_ADDR_VAR 0 11
26956: PUSH
26957: EMPTY
26958: ST_TO_ADDR
// if sort then
26959: LD_VAR 0 9
26963: IFFALSE 27079
// for i = 1 to 6 - eng do
26965: LD_ADDR_VAR 0 3
26969: PUSH
26970: DOUBLE
26971: LD_INT 1
26973: DEC
26974: ST_TO_ADDR
26975: LD_INT 6
26977: PUSH
26978: LD_VAR 0 6
26982: MINUS
26983: PUSH
26984: FOR_TO
26985: IFFALSE 27077
// begin if i = sort then
26987: LD_VAR 0 3
26991: PUSH
26992: LD_VAR 0 9
26996: EQUAL
26997: IFFALSE 27001
// break ;
26999: GO 27077
// if GetClass ( i ) = 2 then
27001: LD_VAR 0 3
27005: PPUSH
27006: CALL_OW 257
27010: PUSH
27011: LD_INT 2
27013: EQUAL
27014: IFFALSE 27018
// continue ;
27016: GO 26984
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27018: LD_ADDR_VAR 0 11
27022: PUSH
27023: LD_VAR 0 11
27027: PPUSH
27028: LD_VAR 0 11
27032: PUSH
27033: LD_INT 1
27035: PLUS
27036: PPUSH
27037: LD_VAR 0 9
27041: PUSH
27042: LD_VAR 0 3
27046: ARRAY
27047: PPUSH
27048: CALL_OW 2
27052: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27053: LD_ADDR_VAR 0 4
27057: PUSH
27058: LD_VAR 0 4
27062: PUSH
27063: LD_VAR 0 9
27067: PUSH
27068: LD_VAR 0 3
27072: ARRAY
27073: DIFF
27074: ST_TO_ADDR
// end ;
27075: GO 26984
27077: POP
27078: POP
// if p then
27079: LD_VAR 0 11
27083: IFFALSE 27108
// result := Replace ( result , 2 , p ) ;
27085: LD_ADDR_VAR 0 2
27089: PUSH
27090: LD_VAR 0 2
27094: PPUSH
27095: LD_INT 2
27097: PPUSH
27098: LD_VAR 0 11
27102: PPUSH
27103: CALL_OW 1
27107: ST_TO_ADDR
// end ; exit ;
27108: GO 28496
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27110: LD_EXP 103
27114: PUSH
27115: LD_EXP 102
27119: PUSH
27120: LD_VAR 0 1
27124: ARRAY
27125: ARRAY
27126: NOT
27127: PUSH
27128: LD_EXP 76
27132: PUSH
27133: LD_VAR 0 1
27137: ARRAY
27138: PPUSH
27139: LD_INT 30
27141: PUSH
27142: LD_INT 3
27144: PUSH
27145: EMPTY
27146: LIST
27147: LIST
27148: PPUSH
27149: CALL_OW 72
27153: AND
27154: PUSH
27155: LD_EXP 81
27159: PUSH
27160: LD_VAR 0 1
27164: ARRAY
27165: AND
27166: IFFALSE 27774
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27168: LD_ADDR_EXP 118
27172: PUSH
27173: LD_EXP 118
27177: PPUSH
27178: LD_VAR 0 1
27182: PPUSH
27183: LD_INT 5
27185: PPUSH
27186: CALL_OW 1
27190: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27191: LD_ADDR_VAR 0 2
27195: PUSH
27196: LD_INT 0
27198: PUSH
27199: LD_INT 0
27201: PUSH
27202: LD_INT 0
27204: PUSH
27205: LD_INT 0
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: LIST
27212: LIST
27213: ST_TO_ADDR
// if sci > 1 then
27214: LD_VAR 0 8
27218: PUSH
27219: LD_INT 1
27221: GREATER
27222: IFFALSE 27250
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27224: LD_ADDR_VAR 0 4
27228: PUSH
27229: LD_VAR 0 4
27233: PUSH
27234: LD_VAR 0 8
27238: PUSH
27239: LD_VAR 0 8
27243: PUSH
27244: LD_INT 1
27246: ARRAY
27247: DIFF
27248: DIFF
27249: ST_TO_ADDR
// if tmp and not sci then
27250: LD_VAR 0 4
27254: PUSH
27255: LD_VAR 0 8
27259: NOT
27260: AND
27261: IFFALSE 27330
// begin sort := SortBySkill ( tmp , 4 ) ;
27263: LD_ADDR_VAR 0 9
27267: PUSH
27268: LD_VAR 0 4
27272: PPUSH
27273: LD_INT 4
27275: PPUSH
27276: CALL 91806 0 2
27280: ST_TO_ADDR
// if sort then
27281: LD_VAR 0 9
27285: IFFALSE 27301
// p := sort [ 1 ] ;
27287: LD_ADDR_VAR 0 11
27291: PUSH
27292: LD_VAR 0 9
27296: PUSH
27297: LD_INT 1
27299: ARRAY
27300: ST_TO_ADDR
// if p then
27301: LD_VAR 0 11
27305: IFFALSE 27330
// result := Replace ( result , 4 , p ) ;
27307: LD_ADDR_VAR 0 2
27311: PUSH
27312: LD_VAR 0 2
27316: PPUSH
27317: LD_INT 4
27319: PPUSH
27320: LD_VAR 0 11
27324: PPUSH
27325: CALL_OW 1
27329: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27330: LD_ADDR_VAR 0 4
27334: PUSH
27335: LD_VAR 0 4
27339: PUSH
27340: LD_VAR 0 7
27344: DIFF
27345: ST_TO_ADDR
// if tmp and mech < 6 then
27346: LD_VAR 0 4
27350: PUSH
27351: LD_VAR 0 7
27355: PUSH
27356: LD_INT 6
27358: LESS
27359: AND
27360: IFFALSE 27548
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27362: LD_ADDR_VAR 0 9
27366: PUSH
27367: LD_VAR 0 4
27371: PUSH
27372: LD_VAR 0 8
27376: PUSH
27377: LD_VAR 0 7
27381: UNION
27382: DIFF
27383: PPUSH
27384: LD_INT 3
27386: PPUSH
27387: CALL 91806 0 2
27391: ST_TO_ADDR
// p := [ ] ;
27392: LD_ADDR_VAR 0 11
27396: PUSH
27397: EMPTY
27398: ST_TO_ADDR
// if sort then
27399: LD_VAR 0 9
27403: IFFALSE 27519
// for i = 1 to 6 - mech do
27405: LD_ADDR_VAR 0 3
27409: PUSH
27410: DOUBLE
27411: LD_INT 1
27413: DEC
27414: ST_TO_ADDR
27415: LD_INT 6
27417: PUSH
27418: LD_VAR 0 7
27422: MINUS
27423: PUSH
27424: FOR_TO
27425: IFFALSE 27517
// begin if i = sort then
27427: LD_VAR 0 3
27431: PUSH
27432: LD_VAR 0 9
27436: EQUAL
27437: IFFALSE 27441
// break ;
27439: GO 27517
// if GetClass ( i ) = 3 then
27441: LD_VAR 0 3
27445: PPUSH
27446: CALL_OW 257
27450: PUSH
27451: LD_INT 3
27453: EQUAL
27454: IFFALSE 27458
// continue ;
27456: GO 27424
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27458: LD_ADDR_VAR 0 11
27462: PUSH
27463: LD_VAR 0 11
27467: PPUSH
27468: LD_VAR 0 11
27472: PUSH
27473: LD_INT 1
27475: PLUS
27476: PPUSH
27477: LD_VAR 0 9
27481: PUSH
27482: LD_VAR 0 3
27486: ARRAY
27487: PPUSH
27488: CALL_OW 2
27492: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27493: LD_ADDR_VAR 0 4
27497: PUSH
27498: LD_VAR 0 4
27502: PUSH
27503: LD_VAR 0 9
27507: PUSH
27508: LD_VAR 0 3
27512: ARRAY
27513: DIFF
27514: ST_TO_ADDR
// end ;
27515: GO 27424
27517: POP
27518: POP
// if p then
27519: LD_VAR 0 11
27523: IFFALSE 27548
// result := Replace ( result , 3 , p ) ;
27525: LD_ADDR_VAR 0 2
27529: PUSH
27530: LD_VAR 0 2
27534: PPUSH
27535: LD_INT 3
27537: PPUSH
27538: LD_VAR 0 11
27542: PPUSH
27543: CALL_OW 1
27547: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27548: LD_ADDR_VAR 0 4
27552: PUSH
27553: LD_VAR 0 4
27557: PUSH
27558: LD_VAR 0 6
27562: DIFF
27563: ST_TO_ADDR
// if tmp and eng < 6 then
27564: LD_VAR 0 4
27568: PUSH
27569: LD_VAR 0 6
27573: PUSH
27574: LD_INT 6
27576: LESS
27577: AND
27578: IFFALSE 27772
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27580: LD_ADDR_VAR 0 9
27584: PUSH
27585: LD_VAR 0 4
27589: PUSH
27590: LD_VAR 0 8
27594: PUSH
27595: LD_VAR 0 7
27599: UNION
27600: PUSH
27601: LD_VAR 0 6
27605: UNION
27606: DIFF
27607: PPUSH
27608: LD_INT 2
27610: PPUSH
27611: CALL 91806 0 2
27615: ST_TO_ADDR
// p := [ ] ;
27616: LD_ADDR_VAR 0 11
27620: PUSH
27621: EMPTY
27622: ST_TO_ADDR
// if sort then
27623: LD_VAR 0 9
27627: IFFALSE 27743
// for i = 1 to 6 - eng do
27629: LD_ADDR_VAR 0 3
27633: PUSH
27634: DOUBLE
27635: LD_INT 1
27637: DEC
27638: ST_TO_ADDR
27639: LD_INT 6
27641: PUSH
27642: LD_VAR 0 6
27646: MINUS
27647: PUSH
27648: FOR_TO
27649: IFFALSE 27741
// begin if i = sort then
27651: LD_VAR 0 3
27655: PUSH
27656: LD_VAR 0 9
27660: EQUAL
27661: IFFALSE 27665
// break ;
27663: GO 27741
// if GetClass ( i ) = 2 then
27665: LD_VAR 0 3
27669: PPUSH
27670: CALL_OW 257
27674: PUSH
27675: LD_INT 2
27677: EQUAL
27678: IFFALSE 27682
// continue ;
27680: GO 27648
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27682: LD_ADDR_VAR 0 11
27686: PUSH
27687: LD_VAR 0 11
27691: PPUSH
27692: LD_VAR 0 11
27696: PUSH
27697: LD_INT 1
27699: PLUS
27700: PPUSH
27701: LD_VAR 0 9
27705: PUSH
27706: LD_VAR 0 3
27710: ARRAY
27711: PPUSH
27712: CALL_OW 2
27716: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27717: LD_ADDR_VAR 0 4
27721: PUSH
27722: LD_VAR 0 4
27726: PUSH
27727: LD_VAR 0 9
27731: PUSH
27732: LD_VAR 0 3
27736: ARRAY
27737: DIFF
27738: ST_TO_ADDR
// end ;
27739: GO 27648
27741: POP
27742: POP
// if p then
27743: LD_VAR 0 11
27747: IFFALSE 27772
// result := Replace ( result , 2 , p ) ;
27749: LD_ADDR_VAR 0 2
27753: PUSH
27754: LD_VAR 0 2
27758: PPUSH
27759: LD_INT 2
27761: PPUSH
27762: LD_VAR 0 11
27766: PPUSH
27767: CALL_OW 1
27771: ST_TO_ADDR
// end ; exit ;
27772: GO 28496
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27774: LD_EXP 103
27778: PUSH
27779: LD_EXP 102
27783: PUSH
27784: LD_VAR 0 1
27788: ARRAY
27789: ARRAY
27790: NOT
27791: PUSH
27792: LD_EXP 76
27796: PUSH
27797: LD_VAR 0 1
27801: ARRAY
27802: PPUSH
27803: LD_INT 30
27805: PUSH
27806: LD_INT 3
27808: PUSH
27809: EMPTY
27810: LIST
27811: LIST
27812: PPUSH
27813: CALL_OW 72
27817: AND
27818: PUSH
27819: LD_EXP 81
27823: PUSH
27824: LD_VAR 0 1
27828: ARRAY
27829: NOT
27830: AND
27831: IFFALSE 28496
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27833: LD_ADDR_EXP 118
27837: PUSH
27838: LD_EXP 118
27842: PPUSH
27843: LD_VAR 0 1
27847: PPUSH
27848: LD_INT 6
27850: PPUSH
27851: CALL_OW 1
27855: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27856: LD_ADDR_VAR 0 2
27860: PUSH
27861: LD_INT 0
27863: PUSH
27864: LD_INT 0
27866: PUSH
27867: LD_INT 0
27869: PUSH
27870: LD_INT 0
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: LIST
27877: LIST
27878: ST_TO_ADDR
// if sci >= 1 then
27879: LD_VAR 0 8
27883: PUSH
27884: LD_INT 1
27886: GREATEREQUAL
27887: IFFALSE 27909
// tmp := tmp diff sci [ 1 ] ;
27889: LD_ADDR_VAR 0 4
27893: PUSH
27894: LD_VAR 0 4
27898: PUSH
27899: LD_VAR 0 8
27903: PUSH
27904: LD_INT 1
27906: ARRAY
27907: DIFF
27908: ST_TO_ADDR
// if tmp and not sci then
27909: LD_VAR 0 4
27913: PUSH
27914: LD_VAR 0 8
27918: NOT
27919: AND
27920: IFFALSE 27989
// begin sort := SortBySkill ( tmp , 4 ) ;
27922: LD_ADDR_VAR 0 9
27926: PUSH
27927: LD_VAR 0 4
27931: PPUSH
27932: LD_INT 4
27934: PPUSH
27935: CALL 91806 0 2
27939: ST_TO_ADDR
// if sort then
27940: LD_VAR 0 9
27944: IFFALSE 27960
// p := sort [ 1 ] ;
27946: LD_ADDR_VAR 0 11
27950: PUSH
27951: LD_VAR 0 9
27955: PUSH
27956: LD_INT 1
27958: ARRAY
27959: ST_TO_ADDR
// if p then
27960: LD_VAR 0 11
27964: IFFALSE 27989
// result := Replace ( result , 4 , p ) ;
27966: LD_ADDR_VAR 0 2
27970: PUSH
27971: LD_VAR 0 2
27975: PPUSH
27976: LD_INT 4
27978: PPUSH
27979: LD_VAR 0 11
27983: PPUSH
27984: CALL_OW 1
27988: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27989: LD_ADDR_VAR 0 4
27993: PUSH
27994: LD_VAR 0 4
27998: PUSH
27999: LD_VAR 0 7
28003: DIFF
28004: ST_TO_ADDR
// if tmp and mech < 6 then
28005: LD_VAR 0 4
28009: PUSH
28010: LD_VAR 0 7
28014: PUSH
28015: LD_INT 6
28017: LESS
28018: AND
28019: IFFALSE 28201
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28021: LD_ADDR_VAR 0 9
28025: PUSH
28026: LD_VAR 0 4
28030: PUSH
28031: LD_VAR 0 7
28035: DIFF
28036: PPUSH
28037: LD_INT 3
28039: PPUSH
28040: CALL 91806 0 2
28044: ST_TO_ADDR
// p := [ ] ;
28045: LD_ADDR_VAR 0 11
28049: PUSH
28050: EMPTY
28051: ST_TO_ADDR
// if sort then
28052: LD_VAR 0 9
28056: IFFALSE 28172
// for i = 1 to 6 - mech do
28058: LD_ADDR_VAR 0 3
28062: PUSH
28063: DOUBLE
28064: LD_INT 1
28066: DEC
28067: ST_TO_ADDR
28068: LD_INT 6
28070: PUSH
28071: LD_VAR 0 7
28075: MINUS
28076: PUSH
28077: FOR_TO
28078: IFFALSE 28170
// begin if i = sort then
28080: LD_VAR 0 3
28084: PUSH
28085: LD_VAR 0 9
28089: EQUAL
28090: IFFALSE 28094
// break ;
28092: GO 28170
// if GetClass ( i ) = 3 then
28094: LD_VAR 0 3
28098: PPUSH
28099: CALL_OW 257
28103: PUSH
28104: LD_INT 3
28106: EQUAL
28107: IFFALSE 28111
// continue ;
28109: GO 28077
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28111: LD_ADDR_VAR 0 11
28115: PUSH
28116: LD_VAR 0 11
28120: PPUSH
28121: LD_VAR 0 11
28125: PUSH
28126: LD_INT 1
28128: PLUS
28129: PPUSH
28130: LD_VAR 0 9
28134: PUSH
28135: LD_VAR 0 3
28139: ARRAY
28140: PPUSH
28141: CALL_OW 2
28145: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28146: LD_ADDR_VAR 0 4
28150: PUSH
28151: LD_VAR 0 4
28155: PUSH
28156: LD_VAR 0 9
28160: PUSH
28161: LD_VAR 0 3
28165: ARRAY
28166: DIFF
28167: ST_TO_ADDR
// end ;
28168: GO 28077
28170: POP
28171: POP
// if p then
28172: LD_VAR 0 11
28176: IFFALSE 28201
// result := Replace ( result , 3 , p ) ;
28178: LD_ADDR_VAR 0 2
28182: PUSH
28183: LD_VAR 0 2
28187: PPUSH
28188: LD_INT 3
28190: PPUSH
28191: LD_VAR 0 11
28195: PPUSH
28196: CALL_OW 1
28200: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28201: LD_ADDR_VAR 0 4
28205: PUSH
28206: LD_VAR 0 4
28210: PUSH
28211: LD_VAR 0 6
28215: DIFF
28216: ST_TO_ADDR
// if tmp and eng < 4 then
28217: LD_VAR 0 4
28221: PUSH
28222: LD_VAR 0 6
28226: PUSH
28227: LD_INT 4
28229: LESS
28230: AND
28231: IFFALSE 28421
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28233: LD_ADDR_VAR 0 9
28237: PUSH
28238: LD_VAR 0 4
28242: PUSH
28243: LD_VAR 0 7
28247: PUSH
28248: LD_VAR 0 6
28252: UNION
28253: DIFF
28254: PPUSH
28255: LD_INT 2
28257: PPUSH
28258: CALL 91806 0 2
28262: ST_TO_ADDR
// p := [ ] ;
28263: LD_ADDR_VAR 0 11
28267: PUSH
28268: EMPTY
28269: ST_TO_ADDR
// if sort then
28270: LD_VAR 0 9
28274: IFFALSE 28390
// for i = 1 to 4 - eng do
28276: LD_ADDR_VAR 0 3
28280: PUSH
28281: DOUBLE
28282: LD_INT 1
28284: DEC
28285: ST_TO_ADDR
28286: LD_INT 4
28288: PUSH
28289: LD_VAR 0 6
28293: MINUS
28294: PUSH
28295: FOR_TO
28296: IFFALSE 28388
// begin if i = sort then
28298: LD_VAR 0 3
28302: PUSH
28303: LD_VAR 0 9
28307: EQUAL
28308: IFFALSE 28312
// break ;
28310: GO 28388
// if GetClass ( i ) = 2 then
28312: LD_VAR 0 3
28316: PPUSH
28317: CALL_OW 257
28321: PUSH
28322: LD_INT 2
28324: EQUAL
28325: IFFALSE 28329
// continue ;
28327: GO 28295
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28329: LD_ADDR_VAR 0 11
28333: PUSH
28334: LD_VAR 0 11
28338: PPUSH
28339: LD_VAR 0 11
28343: PUSH
28344: LD_INT 1
28346: PLUS
28347: PPUSH
28348: LD_VAR 0 9
28352: PUSH
28353: LD_VAR 0 3
28357: ARRAY
28358: PPUSH
28359: CALL_OW 2
28363: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28364: LD_ADDR_VAR 0 4
28368: PUSH
28369: LD_VAR 0 4
28373: PUSH
28374: LD_VAR 0 9
28378: PUSH
28379: LD_VAR 0 3
28383: ARRAY
28384: DIFF
28385: ST_TO_ADDR
// end ;
28386: GO 28295
28388: POP
28389: POP
// if p then
28390: LD_VAR 0 11
28394: IFFALSE 28419
// result := Replace ( result , 2 , p ) ;
28396: LD_ADDR_VAR 0 2
28400: PUSH
28401: LD_VAR 0 2
28405: PPUSH
28406: LD_INT 2
28408: PPUSH
28409: LD_VAR 0 11
28413: PPUSH
28414: CALL_OW 1
28418: ST_TO_ADDR
// end else
28419: GO 28465
// for i = eng downto 5 do
28421: LD_ADDR_VAR 0 3
28425: PUSH
28426: DOUBLE
28427: LD_VAR 0 6
28431: INC
28432: ST_TO_ADDR
28433: LD_INT 5
28435: PUSH
28436: FOR_DOWNTO
28437: IFFALSE 28463
// tmp := tmp union eng [ i ] ;
28439: LD_ADDR_VAR 0 4
28443: PUSH
28444: LD_VAR 0 4
28448: PUSH
28449: LD_VAR 0 6
28453: PUSH
28454: LD_VAR 0 3
28458: ARRAY
28459: UNION
28460: ST_TO_ADDR
28461: GO 28436
28463: POP
28464: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28465: LD_ADDR_VAR 0 2
28469: PUSH
28470: LD_VAR 0 2
28474: PPUSH
28475: LD_INT 1
28477: PPUSH
28478: LD_VAR 0 4
28482: PUSH
28483: LD_VAR 0 5
28487: DIFF
28488: PPUSH
28489: CALL_OW 1
28493: ST_TO_ADDR
// exit ;
28494: GO 28496
// end ; end ;
28496: LD_VAR 0 2
28500: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28501: LD_INT 0
28503: PPUSH
28504: PPUSH
28505: PPUSH
// if not mc_bases then
28506: LD_EXP 76
28510: NOT
28511: IFFALSE 28515
// exit ;
28513: GO 28621
// for i = 1 to mc_bases do
28515: LD_ADDR_VAR 0 2
28519: PUSH
28520: DOUBLE
28521: LD_INT 1
28523: DEC
28524: ST_TO_ADDR
28525: LD_EXP 76
28529: PUSH
28530: FOR_TO
28531: IFFALSE 28612
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28533: LD_ADDR_VAR 0 3
28537: PUSH
28538: LD_EXP 76
28542: PUSH
28543: LD_VAR 0 2
28547: ARRAY
28548: PPUSH
28549: LD_INT 21
28551: PUSH
28552: LD_INT 3
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 3
28561: PUSH
28562: LD_INT 24
28564: PUSH
28565: LD_INT 1000
28567: PUSH
28568: EMPTY
28569: LIST
28570: LIST
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PPUSH
28580: CALL_OW 72
28584: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28585: LD_ADDR_EXP 77
28589: PUSH
28590: LD_EXP 77
28594: PPUSH
28595: LD_VAR 0 2
28599: PPUSH
28600: LD_VAR 0 3
28604: PPUSH
28605: CALL_OW 1
28609: ST_TO_ADDR
// end ;
28610: GO 28530
28612: POP
28613: POP
// RaiseSailEvent ( 101 ) ;
28614: LD_INT 101
28616: PPUSH
28617: CALL_OW 427
// end ;
28621: LD_VAR 0 1
28625: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28626: LD_INT 0
28628: PPUSH
28629: PPUSH
28630: PPUSH
28631: PPUSH
28632: PPUSH
28633: PPUSH
28634: PPUSH
// if not mc_bases then
28635: LD_EXP 76
28639: NOT
28640: IFFALSE 28644
// exit ;
28642: GO 29217
// for i = 1 to mc_bases do
28644: LD_ADDR_VAR 0 2
28648: PUSH
28649: DOUBLE
28650: LD_INT 1
28652: DEC
28653: ST_TO_ADDR
28654: LD_EXP 76
28658: PUSH
28659: FOR_TO
28660: IFFALSE 29208
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28662: LD_ADDR_VAR 0 5
28666: PUSH
28667: LD_EXP 76
28671: PUSH
28672: LD_VAR 0 2
28676: ARRAY
28677: PUSH
28678: LD_EXP 105
28682: PUSH
28683: LD_VAR 0 2
28687: ARRAY
28688: UNION
28689: PPUSH
28690: LD_INT 21
28692: PUSH
28693: LD_INT 1
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 1
28702: PUSH
28703: LD_INT 3
28705: PUSH
28706: LD_INT 54
28708: PUSH
28709: EMPTY
28710: LIST
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PUSH
28716: LD_INT 3
28718: PUSH
28719: LD_INT 24
28721: PUSH
28722: LD_INT 800
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: PUSH
28733: EMPTY
28734: LIST
28735: LIST
28736: LIST
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PPUSH
28742: CALL_OW 72
28746: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28747: LD_ADDR_VAR 0 6
28751: PUSH
28752: LD_EXP 76
28756: PUSH
28757: LD_VAR 0 2
28761: ARRAY
28762: PPUSH
28763: LD_INT 21
28765: PUSH
28766: LD_INT 1
28768: PUSH
28769: EMPTY
28770: LIST
28771: LIST
28772: PUSH
28773: LD_INT 1
28775: PUSH
28776: LD_INT 3
28778: PUSH
28779: LD_INT 54
28781: PUSH
28782: EMPTY
28783: LIST
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 3
28791: PUSH
28792: LD_INT 24
28794: PUSH
28795: LD_INT 250
28797: PUSH
28798: EMPTY
28799: LIST
28800: LIST
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: EMPTY
28807: LIST
28808: LIST
28809: LIST
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PPUSH
28815: CALL_OW 72
28819: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28820: LD_ADDR_VAR 0 7
28824: PUSH
28825: LD_VAR 0 5
28829: PUSH
28830: LD_VAR 0 6
28834: DIFF
28835: ST_TO_ADDR
// if not need_heal_1 then
28836: LD_VAR 0 6
28840: NOT
28841: IFFALSE 28874
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28843: LD_ADDR_EXP 79
28847: PUSH
28848: LD_EXP 79
28852: PPUSH
28853: LD_VAR 0 2
28857: PUSH
28858: LD_INT 1
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PPUSH
28865: EMPTY
28866: PPUSH
28867: CALL 57532 0 3
28871: ST_TO_ADDR
28872: GO 28944
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28874: LD_ADDR_EXP 79
28878: PUSH
28879: LD_EXP 79
28883: PPUSH
28884: LD_VAR 0 2
28888: PUSH
28889: LD_INT 1
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PPUSH
28896: LD_EXP 79
28900: PUSH
28901: LD_VAR 0 2
28905: ARRAY
28906: PUSH
28907: LD_INT 1
28909: ARRAY
28910: PPUSH
28911: LD_INT 3
28913: PUSH
28914: LD_INT 24
28916: PUSH
28917: LD_INT 1000
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PPUSH
28928: CALL_OW 72
28932: PUSH
28933: LD_VAR 0 6
28937: UNION
28938: PPUSH
28939: CALL 57532 0 3
28943: ST_TO_ADDR
// if not need_heal_2 then
28944: LD_VAR 0 7
28948: NOT
28949: IFFALSE 28982
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
28951: LD_ADDR_EXP 79
28955: PUSH
28956: LD_EXP 79
28960: PPUSH
28961: LD_VAR 0 2
28965: PUSH
28966: LD_INT 2
28968: PUSH
28969: EMPTY
28970: LIST
28971: LIST
28972: PPUSH
28973: EMPTY
28974: PPUSH
28975: CALL 57532 0 3
28979: ST_TO_ADDR
28980: GO 29014
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
28982: LD_ADDR_EXP 79
28986: PUSH
28987: LD_EXP 79
28991: PPUSH
28992: LD_VAR 0 2
28996: PUSH
28997: LD_INT 2
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: PPUSH
29004: LD_VAR 0 7
29008: PPUSH
29009: CALL 57532 0 3
29013: ST_TO_ADDR
// if need_heal_2 then
29014: LD_VAR 0 7
29018: IFFALSE 29190
// for j in need_heal_2 do
29020: LD_ADDR_VAR 0 3
29024: PUSH
29025: LD_VAR 0 7
29029: PUSH
29030: FOR_IN
29031: IFFALSE 29188
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
29033: LD_ADDR_VAR 0 5
29037: PUSH
29038: LD_EXP 76
29042: PUSH
29043: LD_VAR 0 2
29047: ARRAY
29048: PPUSH
29049: LD_INT 2
29051: PUSH
29052: LD_INT 30
29054: PUSH
29055: LD_INT 6
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: PUSH
29062: LD_INT 30
29064: PUSH
29065: LD_INT 7
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 30
29074: PUSH
29075: LD_INT 8
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PUSH
29082: LD_INT 30
29084: PUSH
29085: LD_INT 0
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 30
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 25
29104: PUSH
29105: LD_INT 4
29107: PUSH
29108: EMPTY
29109: LIST
29110: LIST
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: LIST
29116: LIST
29117: LIST
29118: LIST
29119: LIST
29120: PPUSH
29121: CALL_OW 72
29125: ST_TO_ADDR
// if tmp then
29126: LD_VAR 0 5
29130: IFFALSE 29186
// begin k := NearestUnitToUnit ( tmp , j ) ;
29132: LD_ADDR_VAR 0 4
29136: PUSH
29137: LD_VAR 0 5
29141: PPUSH
29142: LD_VAR 0 3
29146: PPUSH
29147: CALL_OW 74
29151: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29152: LD_VAR 0 3
29156: PPUSH
29157: LD_VAR 0 4
29161: PPUSH
29162: CALL_OW 296
29166: PUSH
29167: LD_INT 7
29169: GREATER
29170: IFFALSE 29186
// ComMoveUnit ( j , k ) ;
29172: LD_VAR 0 3
29176: PPUSH
29177: LD_VAR 0 4
29181: PPUSH
29182: CALL_OW 112
// end ; end ;
29186: GO 29030
29188: POP
29189: POP
// if not need_heal_1 and not need_heal_2 then
29190: LD_VAR 0 6
29194: NOT
29195: PUSH
29196: LD_VAR 0 7
29200: NOT
29201: AND
29202: IFFALSE 29206
// continue ;
29204: GO 28659
// end ;
29206: GO 28659
29208: POP
29209: POP
// RaiseSailEvent ( 102 ) ;
29210: LD_INT 102
29212: PPUSH
29213: CALL_OW 427
// end ;
29217: LD_VAR 0 1
29221: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29222: LD_INT 0
29224: PPUSH
29225: PPUSH
29226: PPUSH
29227: PPUSH
29228: PPUSH
29229: PPUSH
29230: PPUSH
29231: PPUSH
// if not mc_bases then
29232: LD_EXP 76
29236: NOT
29237: IFFALSE 29241
// exit ;
29239: GO 30081
// for i = 1 to mc_bases do
29241: LD_ADDR_VAR 0 2
29245: PUSH
29246: DOUBLE
29247: LD_INT 1
29249: DEC
29250: ST_TO_ADDR
29251: LD_EXP 76
29255: PUSH
29256: FOR_TO
29257: IFFALSE 30079
// begin if not mc_building_need_repair [ i ] then
29259: LD_EXP 77
29263: PUSH
29264: LD_VAR 0 2
29268: ARRAY
29269: NOT
29270: IFFALSE 29444
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29272: LD_ADDR_VAR 0 6
29276: PUSH
29277: LD_EXP 95
29281: PUSH
29282: LD_VAR 0 2
29286: ARRAY
29287: PPUSH
29288: LD_INT 3
29290: PUSH
29291: LD_INT 24
29293: PUSH
29294: LD_INT 1000
29296: PUSH
29297: EMPTY
29298: LIST
29299: LIST
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: LD_INT 2
29307: PUSH
29308: LD_INT 34
29310: PUSH
29311: LD_INT 13
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 34
29320: PUSH
29321: LD_INT 52
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: LIST
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PPUSH
29337: CALL_OW 72
29341: ST_TO_ADDR
// if cranes then
29342: LD_VAR 0 6
29346: IFFALSE 29408
// for j in cranes do
29348: LD_ADDR_VAR 0 3
29352: PUSH
29353: LD_VAR 0 6
29357: PUSH
29358: FOR_IN
29359: IFFALSE 29406
// if not IsInArea ( j , mc_parking [ i ] ) then
29361: LD_VAR 0 3
29365: PPUSH
29366: LD_EXP 100
29370: PUSH
29371: LD_VAR 0 2
29375: ARRAY
29376: PPUSH
29377: CALL_OW 308
29381: NOT
29382: IFFALSE 29404
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29384: LD_VAR 0 3
29388: PPUSH
29389: LD_EXP 100
29393: PUSH
29394: LD_VAR 0 2
29398: ARRAY
29399: PPUSH
29400: CALL_OW 113
29404: GO 29358
29406: POP
29407: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29408: LD_ADDR_EXP 78
29412: PUSH
29413: LD_EXP 78
29417: PPUSH
29418: LD_VAR 0 2
29422: PPUSH
29423: EMPTY
29424: PPUSH
29425: CALL_OW 1
29429: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29430: LD_VAR 0 2
29434: PPUSH
29435: LD_INT 101
29437: PPUSH
29438: CALL 24334 0 2
// continue ;
29442: GO 29256
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29444: LD_ADDR_EXP 82
29448: PUSH
29449: LD_EXP 82
29453: PPUSH
29454: LD_VAR 0 2
29458: PPUSH
29459: EMPTY
29460: PPUSH
29461: CALL_OW 1
29465: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29466: LD_VAR 0 2
29470: PPUSH
29471: LD_INT 103
29473: PPUSH
29474: CALL 24334 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29478: LD_ADDR_VAR 0 5
29482: PUSH
29483: LD_EXP 76
29487: PUSH
29488: LD_VAR 0 2
29492: ARRAY
29493: PUSH
29494: LD_EXP 105
29498: PUSH
29499: LD_VAR 0 2
29503: ARRAY
29504: UNION
29505: PPUSH
29506: LD_INT 2
29508: PUSH
29509: LD_INT 25
29511: PUSH
29512: LD_INT 2
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 25
29521: PUSH
29522: LD_INT 16
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: LIST
29533: PUSH
29534: EMPTY
29535: LIST
29536: PPUSH
29537: CALL_OW 72
29541: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29542: LD_ADDR_VAR 0 6
29546: PUSH
29547: LD_EXP 95
29551: PUSH
29552: LD_VAR 0 2
29556: ARRAY
29557: PPUSH
29558: LD_INT 2
29560: PUSH
29561: LD_INT 34
29563: PUSH
29564: LD_INT 13
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: LD_INT 34
29573: PUSH
29574: LD_INT 52
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: LIST
29585: PPUSH
29586: CALL_OW 72
29590: ST_TO_ADDR
// if cranes then
29591: LD_VAR 0 6
29595: IFFALSE 29731
// begin for j in cranes do
29597: LD_ADDR_VAR 0 3
29601: PUSH
29602: LD_VAR 0 6
29606: PUSH
29607: FOR_IN
29608: IFFALSE 29729
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29610: LD_VAR 0 3
29614: PPUSH
29615: CALL_OW 256
29619: PUSH
29620: LD_INT 500
29622: GREATEREQUAL
29623: PUSH
29624: LD_VAR 0 3
29628: PPUSH
29629: CALL_OW 314
29633: NOT
29634: AND
29635: IFFALSE 29669
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29637: LD_VAR 0 3
29641: PPUSH
29642: LD_EXP 77
29646: PUSH
29647: LD_VAR 0 2
29651: ARRAY
29652: PPUSH
29653: LD_VAR 0 3
29657: PPUSH
29658: CALL_OW 74
29662: PPUSH
29663: CALL_OW 130
29667: GO 29727
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29669: LD_VAR 0 3
29673: PPUSH
29674: CALL_OW 256
29678: PUSH
29679: LD_INT 500
29681: LESS
29682: PUSH
29683: LD_VAR 0 3
29687: PPUSH
29688: LD_EXP 100
29692: PUSH
29693: LD_VAR 0 2
29697: ARRAY
29698: PPUSH
29699: CALL_OW 308
29703: NOT
29704: AND
29705: IFFALSE 29727
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29707: LD_VAR 0 3
29711: PPUSH
29712: LD_EXP 100
29716: PUSH
29717: LD_VAR 0 2
29721: ARRAY
29722: PPUSH
29723: CALL_OW 113
29727: GO 29607
29729: POP
29730: POP
// end ; if not tmp then
29731: LD_VAR 0 5
29735: NOT
29736: IFFALSE 29740
// continue ;
29738: GO 29256
// for j in tmp do
29740: LD_ADDR_VAR 0 3
29744: PUSH
29745: LD_VAR 0 5
29749: PUSH
29750: FOR_IN
29751: IFFALSE 30075
// begin if mc_need_heal [ i ] then
29753: LD_EXP 79
29757: PUSH
29758: LD_VAR 0 2
29762: ARRAY
29763: IFFALSE 29811
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29765: LD_VAR 0 3
29769: PUSH
29770: LD_EXP 79
29774: PUSH
29775: LD_VAR 0 2
29779: ARRAY
29780: PUSH
29781: LD_INT 1
29783: ARRAY
29784: IN
29785: PUSH
29786: LD_VAR 0 3
29790: PUSH
29791: LD_EXP 79
29795: PUSH
29796: LD_VAR 0 2
29800: ARRAY
29801: PUSH
29802: LD_INT 2
29804: ARRAY
29805: IN
29806: OR
29807: IFFALSE 29811
// continue ;
29809: GO 29750
// if IsInUnit ( j ) then
29811: LD_VAR 0 3
29815: PPUSH
29816: CALL_OW 310
29820: IFFALSE 29831
// ComExitBuilding ( j ) ;
29822: LD_VAR 0 3
29826: PPUSH
29827: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29831: LD_VAR 0 3
29835: PUSH
29836: LD_EXP 78
29840: PUSH
29841: LD_VAR 0 2
29845: ARRAY
29846: IN
29847: NOT
29848: IFFALSE 29906
// begin SetTag ( j , 101 ) ;
29850: LD_VAR 0 3
29854: PPUSH
29855: LD_INT 101
29857: PPUSH
29858: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29862: LD_ADDR_EXP 78
29866: PUSH
29867: LD_EXP 78
29871: PPUSH
29872: LD_VAR 0 2
29876: PUSH
29877: LD_EXP 78
29881: PUSH
29882: LD_VAR 0 2
29886: ARRAY
29887: PUSH
29888: LD_INT 1
29890: PLUS
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PPUSH
29896: LD_VAR 0 3
29900: PPUSH
29901: CALL 57532 0 3
29905: ST_TO_ADDR
// end ; wait ( 1 ) ;
29906: LD_INT 1
29908: PPUSH
29909: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
29913: LD_ADDR_VAR 0 7
29917: PUSH
29918: LD_EXP 77
29922: PUSH
29923: LD_VAR 0 2
29927: ARRAY
29928: ST_TO_ADDR
// if mc_scan [ i ] then
29929: LD_EXP 99
29933: PUSH
29934: LD_VAR 0 2
29938: ARRAY
29939: IFFALSE 30008
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
29941: LD_ADDR_VAR 0 7
29945: PUSH
29946: LD_EXP 77
29950: PUSH
29951: LD_VAR 0 2
29955: ARRAY
29956: PPUSH
29957: LD_INT 3
29959: PUSH
29960: LD_INT 2
29962: PUSH
29963: LD_INT 30
29965: PUSH
29966: LD_INT 32
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: LD_INT 30
29975: PUSH
29976: LD_INT 33
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 30
29985: PUSH
29986: LD_INT 31
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: LIST
29997: LIST
29998: PUSH
29999: EMPTY
30000: LIST
30001: LIST
30002: PPUSH
30003: CALL_OW 72
30007: ST_TO_ADDR
// if not to_repair_tmp then
30008: LD_VAR 0 7
30012: NOT
30013: IFFALSE 30017
// continue ;
30015: GO 29750
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30017: LD_ADDR_VAR 0 8
30021: PUSH
30022: LD_VAR 0 7
30026: PPUSH
30027: LD_VAR 0 3
30031: PPUSH
30032: CALL_OW 74
30036: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
30037: LD_VAR 0 8
30041: PPUSH
30042: LD_INT 14
30044: PPUSH
30045: CALL 60125 0 2
30049: PUSH
30050: LD_INT 4
30052: ARRAY
30053: PUSH
30054: LD_INT 5
30056: LESS
30057: IFFALSE 30073
// ComRepairBuilding ( j , to_repair ) ;
30059: LD_VAR 0 3
30063: PPUSH
30064: LD_VAR 0 8
30068: PPUSH
30069: CALL_OW 130
// end ;
30073: GO 29750
30075: POP
30076: POP
// end ;
30077: GO 29256
30079: POP
30080: POP
// end ;
30081: LD_VAR 0 1
30085: RET
// export function MC_Heal ; var i , j , tmp ; begin
30086: LD_INT 0
30088: PPUSH
30089: PPUSH
30090: PPUSH
30091: PPUSH
// if not mc_bases then
30092: LD_EXP 76
30096: NOT
30097: IFFALSE 30101
// exit ;
30099: GO 30503
// for i = 1 to mc_bases do
30101: LD_ADDR_VAR 0 2
30105: PUSH
30106: DOUBLE
30107: LD_INT 1
30109: DEC
30110: ST_TO_ADDR
30111: LD_EXP 76
30115: PUSH
30116: FOR_TO
30117: IFFALSE 30501
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30119: LD_EXP 79
30123: PUSH
30124: LD_VAR 0 2
30128: ARRAY
30129: PUSH
30130: LD_INT 1
30132: ARRAY
30133: NOT
30134: PUSH
30135: LD_EXP 79
30139: PUSH
30140: LD_VAR 0 2
30144: ARRAY
30145: PUSH
30146: LD_INT 2
30148: ARRAY
30149: NOT
30150: AND
30151: IFFALSE 30189
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30153: LD_ADDR_EXP 80
30157: PUSH
30158: LD_EXP 80
30162: PPUSH
30163: LD_VAR 0 2
30167: PPUSH
30168: EMPTY
30169: PPUSH
30170: CALL_OW 1
30174: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30175: LD_VAR 0 2
30179: PPUSH
30180: LD_INT 102
30182: PPUSH
30183: CALL 24334 0 2
// continue ;
30187: GO 30116
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30189: LD_ADDR_VAR 0 4
30193: PUSH
30194: LD_EXP 76
30198: PUSH
30199: LD_VAR 0 2
30203: ARRAY
30204: PPUSH
30205: LD_INT 25
30207: PUSH
30208: LD_INT 4
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PPUSH
30215: CALL_OW 72
30219: ST_TO_ADDR
// if not tmp then
30220: LD_VAR 0 4
30224: NOT
30225: IFFALSE 30229
// continue ;
30227: GO 30116
// if mc_taming [ i ] then
30229: LD_EXP 107
30233: PUSH
30234: LD_VAR 0 2
30238: ARRAY
30239: IFFALSE 30263
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30241: LD_ADDR_EXP 107
30245: PUSH
30246: LD_EXP 107
30250: PPUSH
30251: LD_VAR 0 2
30255: PPUSH
30256: EMPTY
30257: PPUSH
30258: CALL_OW 1
30262: ST_TO_ADDR
// for j in tmp do
30263: LD_ADDR_VAR 0 3
30267: PUSH
30268: LD_VAR 0 4
30272: PUSH
30273: FOR_IN
30274: IFFALSE 30497
// begin if IsInUnit ( j ) then
30276: LD_VAR 0 3
30280: PPUSH
30281: CALL_OW 310
30285: IFFALSE 30296
// ComExitBuilding ( j ) ;
30287: LD_VAR 0 3
30291: PPUSH
30292: CALL_OW 122
// if not j in mc_healers [ i ] then
30296: LD_VAR 0 3
30300: PUSH
30301: LD_EXP 80
30305: PUSH
30306: LD_VAR 0 2
30310: ARRAY
30311: IN
30312: NOT
30313: IFFALSE 30359
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30315: LD_ADDR_EXP 80
30319: PUSH
30320: LD_EXP 80
30324: PPUSH
30325: LD_VAR 0 2
30329: PUSH
30330: LD_EXP 80
30334: PUSH
30335: LD_VAR 0 2
30339: ARRAY
30340: PUSH
30341: LD_INT 1
30343: PLUS
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PPUSH
30349: LD_VAR 0 3
30353: PPUSH
30354: CALL 57532 0 3
30358: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30359: LD_VAR 0 3
30363: PPUSH
30364: CALL_OW 110
30368: PUSH
30369: LD_INT 102
30371: NONEQUAL
30372: IFFALSE 30386
// SetTag ( j , 102 ) ;
30374: LD_VAR 0 3
30378: PPUSH
30379: LD_INT 102
30381: PPUSH
30382: CALL_OW 109
// Wait ( 3 ) ;
30386: LD_INT 3
30388: PPUSH
30389: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30393: LD_EXP 79
30397: PUSH
30398: LD_VAR 0 2
30402: ARRAY
30403: PUSH
30404: LD_INT 1
30406: ARRAY
30407: IFFALSE 30439
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30409: LD_VAR 0 3
30413: PPUSH
30414: LD_EXP 79
30418: PUSH
30419: LD_VAR 0 2
30423: ARRAY
30424: PUSH
30425: LD_INT 1
30427: ARRAY
30428: PUSH
30429: LD_INT 1
30431: ARRAY
30432: PPUSH
30433: CALL_OW 128
30437: GO 30495
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30439: LD_VAR 0 3
30443: PPUSH
30444: CALL_OW 314
30448: NOT
30449: PUSH
30450: LD_EXP 79
30454: PUSH
30455: LD_VAR 0 2
30459: ARRAY
30460: PUSH
30461: LD_INT 2
30463: ARRAY
30464: AND
30465: IFFALSE 30495
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30467: LD_VAR 0 3
30471: PPUSH
30472: LD_EXP 79
30476: PUSH
30477: LD_VAR 0 2
30481: ARRAY
30482: PUSH
30483: LD_INT 2
30485: ARRAY
30486: PUSH
30487: LD_INT 1
30489: ARRAY
30490: PPUSH
30491: CALL_OW 128
// end ;
30495: GO 30273
30497: POP
30498: POP
// end ;
30499: GO 30116
30501: POP
30502: POP
// end ;
30503: LD_VAR 0 1
30507: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30508: LD_INT 0
30510: PPUSH
30511: PPUSH
30512: PPUSH
30513: PPUSH
30514: PPUSH
// if not mc_bases then
30515: LD_EXP 76
30519: NOT
30520: IFFALSE 30524
// exit ;
30522: GO 31667
// for i = 1 to mc_bases do
30524: LD_ADDR_VAR 0 2
30528: PUSH
30529: DOUBLE
30530: LD_INT 1
30532: DEC
30533: ST_TO_ADDR
30534: LD_EXP 76
30538: PUSH
30539: FOR_TO
30540: IFFALSE 31665
// begin if mc_scan [ i ] then
30542: LD_EXP 99
30546: PUSH
30547: LD_VAR 0 2
30551: ARRAY
30552: IFFALSE 30556
// continue ;
30554: GO 30539
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30556: LD_EXP 81
30560: PUSH
30561: LD_VAR 0 2
30565: ARRAY
30566: NOT
30567: PUSH
30568: LD_EXP 83
30572: PUSH
30573: LD_VAR 0 2
30577: ARRAY
30578: NOT
30579: AND
30580: PUSH
30581: LD_EXP 82
30585: PUSH
30586: LD_VAR 0 2
30590: ARRAY
30591: AND
30592: IFFALSE 30630
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30594: LD_ADDR_EXP 82
30598: PUSH
30599: LD_EXP 82
30603: PPUSH
30604: LD_VAR 0 2
30608: PPUSH
30609: EMPTY
30610: PPUSH
30611: CALL_OW 1
30615: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30616: LD_VAR 0 2
30620: PPUSH
30621: LD_INT 103
30623: PPUSH
30624: CALL 24334 0 2
// continue ;
30628: GO 30539
// end ; if mc_construct_list [ i ] then
30630: LD_EXP 83
30634: PUSH
30635: LD_VAR 0 2
30639: ARRAY
30640: IFFALSE 30860
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30642: LD_ADDR_VAR 0 4
30646: PUSH
30647: LD_EXP 76
30651: PUSH
30652: LD_VAR 0 2
30656: ARRAY
30657: PPUSH
30658: LD_INT 25
30660: PUSH
30661: LD_INT 2
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PPUSH
30668: CALL_OW 72
30672: PUSH
30673: LD_EXP 78
30677: PUSH
30678: LD_VAR 0 2
30682: ARRAY
30683: DIFF
30684: ST_TO_ADDR
// if not tmp then
30685: LD_VAR 0 4
30689: NOT
30690: IFFALSE 30694
// continue ;
30692: GO 30539
// for j in tmp do
30694: LD_ADDR_VAR 0 3
30698: PUSH
30699: LD_VAR 0 4
30703: PUSH
30704: FOR_IN
30705: IFFALSE 30856
// begin if not mc_builders [ i ] then
30707: LD_EXP 82
30711: PUSH
30712: LD_VAR 0 2
30716: ARRAY
30717: NOT
30718: IFFALSE 30776
// begin SetTag ( j , 103 ) ;
30720: LD_VAR 0 3
30724: PPUSH
30725: LD_INT 103
30727: PPUSH
30728: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30732: LD_ADDR_EXP 82
30736: PUSH
30737: LD_EXP 82
30741: PPUSH
30742: LD_VAR 0 2
30746: PUSH
30747: LD_EXP 82
30751: PUSH
30752: LD_VAR 0 2
30756: ARRAY
30757: PUSH
30758: LD_INT 1
30760: PLUS
30761: PUSH
30762: EMPTY
30763: LIST
30764: LIST
30765: PPUSH
30766: LD_VAR 0 3
30770: PPUSH
30771: CALL 57532 0 3
30775: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30776: LD_VAR 0 3
30780: PPUSH
30781: CALL_OW 310
30785: IFFALSE 30796
// ComExitBuilding ( j ) ;
30787: LD_VAR 0 3
30791: PPUSH
30792: CALL_OW 122
// wait ( 3 ) ;
30796: LD_INT 3
30798: PPUSH
30799: CALL_OW 67
// if not mc_construct_list [ i ] then
30803: LD_EXP 83
30807: PUSH
30808: LD_VAR 0 2
30812: ARRAY
30813: NOT
30814: IFFALSE 30818
// break ;
30816: GO 30856
// if not HasTask ( j ) then
30818: LD_VAR 0 3
30822: PPUSH
30823: CALL_OW 314
30827: NOT
30828: IFFALSE 30854
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30830: LD_VAR 0 3
30834: PPUSH
30835: LD_EXP 83
30839: PUSH
30840: LD_VAR 0 2
30844: ARRAY
30845: PUSH
30846: LD_INT 1
30848: ARRAY
30849: PPUSH
30850: CALL 60383 0 2
// end ;
30854: GO 30704
30856: POP
30857: POP
// end else
30858: GO 31663
// if mc_build_list [ i ] then
30860: LD_EXP 81
30864: PUSH
30865: LD_VAR 0 2
30869: ARRAY
30870: IFFALSE 31663
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30872: LD_ADDR_VAR 0 5
30876: PUSH
30877: LD_EXP 76
30881: PUSH
30882: LD_VAR 0 2
30886: ARRAY
30887: PPUSH
30888: LD_INT 2
30890: PUSH
30891: LD_INT 30
30893: PUSH
30894: LD_INT 0
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 30
30903: PUSH
30904: LD_INT 1
30906: PUSH
30907: EMPTY
30908: LIST
30909: LIST
30910: PUSH
30911: EMPTY
30912: LIST
30913: LIST
30914: LIST
30915: PPUSH
30916: CALL_OW 72
30920: ST_TO_ADDR
// if depot then
30921: LD_VAR 0 5
30925: IFFALSE 30943
// depot := depot [ 1 ] else
30927: LD_ADDR_VAR 0 5
30931: PUSH
30932: LD_VAR 0 5
30936: PUSH
30937: LD_INT 1
30939: ARRAY
30940: ST_TO_ADDR
30941: GO 30951
// depot := 0 ;
30943: LD_ADDR_VAR 0 5
30947: PUSH
30948: LD_INT 0
30950: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
30951: LD_EXP 81
30955: PUSH
30956: LD_VAR 0 2
30960: ARRAY
30961: PUSH
30962: LD_INT 1
30964: ARRAY
30965: PUSH
30966: LD_INT 1
30968: ARRAY
30969: PPUSH
30970: CALL 60213 0 1
30974: PUSH
30975: LD_EXP 76
30979: PUSH
30980: LD_VAR 0 2
30984: ARRAY
30985: PPUSH
30986: LD_INT 2
30988: PUSH
30989: LD_INT 30
30991: PUSH
30992: LD_INT 2
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: LD_INT 30
31001: PUSH
31002: LD_INT 3
31004: PUSH
31005: EMPTY
31006: LIST
31007: LIST
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: LIST
31013: PPUSH
31014: CALL_OW 72
31018: NOT
31019: AND
31020: IFFALSE 31125
// begin for j = 1 to mc_build_list [ i ] do
31022: LD_ADDR_VAR 0 3
31026: PUSH
31027: DOUBLE
31028: LD_INT 1
31030: DEC
31031: ST_TO_ADDR
31032: LD_EXP 81
31036: PUSH
31037: LD_VAR 0 2
31041: ARRAY
31042: PUSH
31043: FOR_TO
31044: IFFALSE 31123
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31046: LD_EXP 81
31050: PUSH
31051: LD_VAR 0 2
31055: ARRAY
31056: PUSH
31057: LD_VAR 0 3
31061: ARRAY
31062: PUSH
31063: LD_INT 1
31065: ARRAY
31066: PUSH
31067: LD_INT 2
31069: EQUAL
31070: IFFALSE 31121
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31072: LD_ADDR_EXP 81
31076: PUSH
31077: LD_EXP 81
31081: PPUSH
31082: LD_VAR 0 2
31086: PPUSH
31087: LD_EXP 81
31091: PUSH
31092: LD_VAR 0 2
31096: ARRAY
31097: PPUSH
31098: LD_VAR 0 3
31102: PPUSH
31103: LD_INT 1
31105: PPUSH
31106: LD_INT 0
31108: PPUSH
31109: CALL 56950 0 4
31113: PPUSH
31114: CALL_OW 1
31118: ST_TO_ADDR
// break ;
31119: GO 31123
// end ;
31121: GO 31043
31123: POP
31124: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31125: LD_EXP 81
31129: PUSH
31130: LD_VAR 0 2
31134: ARRAY
31135: PUSH
31136: LD_INT 1
31138: ARRAY
31139: PUSH
31140: LD_INT 1
31142: ARRAY
31143: PUSH
31144: LD_INT 0
31146: EQUAL
31147: PUSH
31148: LD_VAR 0 5
31152: PUSH
31153: LD_VAR 0 5
31157: PPUSH
31158: LD_EXP 81
31162: PUSH
31163: LD_VAR 0 2
31167: ARRAY
31168: PUSH
31169: LD_INT 1
31171: ARRAY
31172: PUSH
31173: LD_INT 1
31175: ARRAY
31176: PPUSH
31177: LD_EXP 81
31181: PUSH
31182: LD_VAR 0 2
31186: ARRAY
31187: PUSH
31188: LD_INT 1
31190: ARRAY
31191: PUSH
31192: LD_INT 2
31194: ARRAY
31195: PPUSH
31196: LD_EXP 81
31200: PUSH
31201: LD_VAR 0 2
31205: ARRAY
31206: PUSH
31207: LD_INT 1
31209: ARRAY
31210: PUSH
31211: LD_INT 3
31213: ARRAY
31214: PPUSH
31215: LD_EXP 81
31219: PUSH
31220: LD_VAR 0 2
31224: ARRAY
31225: PUSH
31226: LD_INT 1
31228: ARRAY
31229: PUSH
31230: LD_INT 4
31232: ARRAY
31233: PPUSH
31234: CALL 64947 0 5
31238: AND
31239: OR
31240: IFFALSE 31521
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31242: LD_ADDR_VAR 0 4
31246: PUSH
31247: LD_EXP 76
31251: PUSH
31252: LD_VAR 0 2
31256: ARRAY
31257: PPUSH
31258: LD_INT 25
31260: PUSH
31261: LD_INT 2
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PPUSH
31268: CALL_OW 72
31272: PUSH
31273: LD_EXP 78
31277: PUSH
31278: LD_VAR 0 2
31282: ARRAY
31283: DIFF
31284: ST_TO_ADDR
// if not tmp then
31285: LD_VAR 0 4
31289: NOT
31290: IFFALSE 31294
// continue ;
31292: GO 30539
// for j in tmp do
31294: LD_ADDR_VAR 0 3
31298: PUSH
31299: LD_VAR 0 4
31303: PUSH
31304: FOR_IN
31305: IFFALSE 31517
// begin if not mc_builders [ i ] then
31307: LD_EXP 82
31311: PUSH
31312: LD_VAR 0 2
31316: ARRAY
31317: NOT
31318: IFFALSE 31376
// begin SetTag ( j , 103 ) ;
31320: LD_VAR 0 3
31324: PPUSH
31325: LD_INT 103
31327: PPUSH
31328: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31332: LD_ADDR_EXP 82
31336: PUSH
31337: LD_EXP 82
31341: PPUSH
31342: LD_VAR 0 2
31346: PUSH
31347: LD_EXP 82
31351: PUSH
31352: LD_VAR 0 2
31356: ARRAY
31357: PUSH
31358: LD_INT 1
31360: PLUS
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PPUSH
31366: LD_VAR 0 3
31370: PPUSH
31371: CALL 57532 0 3
31375: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31376: LD_VAR 0 3
31380: PPUSH
31381: CALL_OW 310
31385: IFFALSE 31396
// ComExitBuilding ( j ) ;
31387: LD_VAR 0 3
31391: PPUSH
31392: CALL_OW 122
// wait ( 3 ) ;
31396: LD_INT 3
31398: PPUSH
31399: CALL_OW 67
// if not mc_build_list [ i ] then
31403: LD_EXP 81
31407: PUSH
31408: LD_VAR 0 2
31412: ARRAY
31413: NOT
31414: IFFALSE 31418
// break ;
31416: GO 31517
// if not HasTask ( j ) then
31418: LD_VAR 0 3
31422: PPUSH
31423: CALL_OW 314
31427: NOT
31428: IFFALSE 31515
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31430: LD_VAR 0 3
31434: PPUSH
31435: LD_EXP 81
31439: PUSH
31440: LD_VAR 0 2
31444: ARRAY
31445: PUSH
31446: LD_INT 1
31448: ARRAY
31449: PUSH
31450: LD_INT 1
31452: ARRAY
31453: PPUSH
31454: LD_EXP 81
31458: PUSH
31459: LD_VAR 0 2
31463: ARRAY
31464: PUSH
31465: LD_INT 1
31467: ARRAY
31468: PUSH
31469: LD_INT 2
31471: ARRAY
31472: PPUSH
31473: LD_EXP 81
31477: PUSH
31478: LD_VAR 0 2
31482: ARRAY
31483: PUSH
31484: LD_INT 1
31486: ARRAY
31487: PUSH
31488: LD_INT 3
31490: ARRAY
31491: PPUSH
31492: LD_EXP 81
31496: PUSH
31497: LD_VAR 0 2
31501: ARRAY
31502: PUSH
31503: LD_INT 1
31505: ARRAY
31506: PUSH
31507: LD_INT 4
31509: ARRAY
31510: PPUSH
31511: CALL_OW 145
// end ;
31515: GO 31304
31517: POP
31518: POP
// end else
31519: GO 31663
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31521: LD_EXP 76
31525: PUSH
31526: LD_VAR 0 2
31530: ARRAY
31531: PPUSH
31532: LD_EXP 81
31536: PUSH
31537: LD_VAR 0 2
31541: ARRAY
31542: PUSH
31543: LD_INT 1
31545: ARRAY
31546: PUSH
31547: LD_INT 1
31549: ARRAY
31550: PPUSH
31551: LD_EXP 81
31555: PUSH
31556: LD_VAR 0 2
31560: ARRAY
31561: PUSH
31562: LD_INT 1
31564: ARRAY
31565: PUSH
31566: LD_INT 2
31568: ARRAY
31569: PPUSH
31570: LD_EXP 81
31574: PUSH
31575: LD_VAR 0 2
31579: ARRAY
31580: PUSH
31581: LD_INT 1
31583: ARRAY
31584: PUSH
31585: LD_INT 3
31587: ARRAY
31588: PPUSH
31589: LD_EXP 81
31593: PUSH
31594: LD_VAR 0 2
31598: ARRAY
31599: PUSH
31600: LD_INT 1
31602: ARRAY
31603: PUSH
31604: LD_INT 4
31606: ARRAY
31607: PPUSH
31608: CALL 64283 0 5
31612: NOT
31613: IFFALSE 31663
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31615: LD_ADDR_EXP 81
31619: PUSH
31620: LD_EXP 81
31624: PPUSH
31625: LD_VAR 0 2
31629: PPUSH
31630: LD_EXP 81
31634: PUSH
31635: LD_VAR 0 2
31639: ARRAY
31640: PPUSH
31641: LD_INT 1
31643: PPUSH
31644: LD_INT 1
31646: NEG
31647: PPUSH
31648: LD_INT 0
31650: PPUSH
31651: CALL 56950 0 4
31655: PPUSH
31656: CALL_OW 1
31660: ST_TO_ADDR
// continue ;
31661: GO 30539
// end ; end ; end ;
31663: GO 30539
31665: POP
31666: POP
// end ;
31667: LD_VAR 0 1
31671: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31672: LD_INT 0
31674: PPUSH
31675: PPUSH
31676: PPUSH
31677: PPUSH
31678: PPUSH
31679: PPUSH
// if not mc_bases then
31680: LD_EXP 76
31684: NOT
31685: IFFALSE 31689
// exit ;
31687: GO 32116
// for i = 1 to mc_bases do
31689: LD_ADDR_VAR 0 2
31693: PUSH
31694: DOUBLE
31695: LD_INT 1
31697: DEC
31698: ST_TO_ADDR
31699: LD_EXP 76
31703: PUSH
31704: FOR_TO
31705: IFFALSE 32114
// begin tmp := mc_build_upgrade [ i ] ;
31707: LD_ADDR_VAR 0 4
31711: PUSH
31712: LD_EXP 108
31716: PUSH
31717: LD_VAR 0 2
31721: ARRAY
31722: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31723: LD_ADDR_VAR 0 6
31727: PUSH
31728: LD_EXP 109
31732: PUSH
31733: LD_VAR 0 2
31737: ARRAY
31738: PPUSH
31739: LD_INT 2
31741: PUSH
31742: LD_INT 30
31744: PUSH
31745: LD_INT 6
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 30
31754: PUSH
31755: LD_INT 7
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: LIST
31766: PPUSH
31767: CALL_OW 72
31771: ST_TO_ADDR
// if not tmp and not lab then
31772: LD_VAR 0 4
31776: NOT
31777: PUSH
31778: LD_VAR 0 6
31782: NOT
31783: AND
31784: IFFALSE 31788
// continue ;
31786: GO 31704
// if tmp then
31788: LD_VAR 0 4
31792: IFFALSE 31912
// for j in tmp do
31794: LD_ADDR_VAR 0 3
31798: PUSH
31799: LD_VAR 0 4
31803: PUSH
31804: FOR_IN
31805: IFFALSE 31910
// begin if UpgradeCost ( j ) then
31807: LD_VAR 0 3
31811: PPUSH
31812: CALL 63943 0 1
31816: IFFALSE 31908
// begin ComUpgrade ( j ) ;
31818: LD_VAR 0 3
31822: PPUSH
31823: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31827: LD_ADDR_EXP 108
31831: PUSH
31832: LD_EXP 108
31836: PPUSH
31837: LD_VAR 0 2
31841: PPUSH
31842: LD_EXP 108
31846: PUSH
31847: LD_VAR 0 2
31851: ARRAY
31852: PUSH
31853: LD_VAR 0 3
31857: DIFF
31858: PPUSH
31859: CALL_OW 1
31863: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31864: LD_ADDR_EXP 83
31868: PUSH
31869: LD_EXP 83
31873: PPUSH
31874: LD_VAR 0 2
31878: PUSH
31879: LD_EXP 83
31883: PUSH
31884: LD_VAR 0 2
31888: ARRAY
31889: PUSH
31890: LD_INT 1
31892: PLUS
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PPUSH
31898: LD_VAR 0 3
31902: PPUSH
31903: CALL 57532 0 3
31907: ST_TO_ADDR
// end ; end ;
31908: GO 31804
31910: POP
31911: POP
// if not lab or not mc_lab_upgrade [ i ] then
31912: LD_VAR 0 6
31916: NOT
31917: PUSH
31918: LD_EXP 110
31922: PUSH
31923: LD_VAR 0 2
31927: ARRAY
31928: NOT
31929: OR
31930: IFFALSE 31934
// continue ;
31932: GO 31704
// for j in lab do
31934: LD_ADDR_VAR 0 3
31938: PUSH
31939: LD_VAR 0 6
31943: PUSH
31944: FOR_IN
31945: IFFALSE 32110
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
31947: LD_VAR 0 3
31951: PPUSH
31952: CALL_OW 266
31956: PUSH
31957: LD_INT 6
31959: PUSH
31960: LD_INT 7
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: IN
31967: PUSH
31968: LD_VAR 0 3
31972: PPUSH
31973: CALL_OW 461
31977: PUSH
31978: LD_INT 1
31980: NONEQUAL
31981: AND
31982: IFFALSE 32108
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
31984: LD_VAR 0 3
31988: PPUSH
31989: LD_EXP 110
31993: PUSH
31994: LD_VAR 0 2
31998: ARRAY
31999: PUSH
32000: LD_INT 1
32002: ARRAY
32003: PPUSH
32004: CALL 64148 0 2
32008: IFFALSE 32108
// begin ComCancel ( j ) ;
32010: LD_VAR 0 3
32014: PPUSH
32015: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32019: LD_VAR 0 3
32023: PPUSH
32024: LD_EXP 110
32028: PUSH
32029: LD_VAR 0 2
32033: ARRAY
32034: PUSH
32035: LD_INT 1
32037: ARRAY
32038: PPUSH
32039: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32043: LD_VAR 0 3
32047: PUSH
32048: LD_EXP 83
32052: PUSH
32053: LD_VAR 0 2
32057: ARRAY
32058: IN
32059: NOT
32060: IFFALSE 32106
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32062: LD_ADDR_EXP 83
32066: PUSH
32067: LD_EXP 83
32071: PPUSH
32072: LD_VAR 0 2
32076: PUSH
32077: LD_EXP 83
32081: PUSH
32082: LD_VAR 0 2
32086: ARRAY
32087: PUSH
32088: LD_INT 1
32090: PLUS
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PPUSH
32096: LD_VAR 0 3
32100: PPUSH
32101: CALL 57532 0 3
32105: ST_TO_ADDR
// break ;
32106: GO 32110
// end ; end ; end ;
32108: GO 31944
32110: POP
32111: POP
// end ;
32112: GO 31704
32114: POP
32115: POP
// end ;
32116: LD_VAR 0 1
32120: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32121: LD_INT 0
32123: PPUSH
32124: PPUSH
32125: PPUSH
32126: PPUSH
32127: PPUSH
32128: PPUSH
32129: PPUSH
32130: PPUSH
32131: PPUSH
// if not mc_bases then
32132: LD_EXP 76
32136: NOT
32137: IFFALSE 32141
// exit ;
32139: GO 32546
// for i = 1 to mc_bases do
32141: LD_ADDR_VAR 0 2
32145: PUSH
32146: DOUBLE
32147: LD_INT 1
32149: DEC
32150: ST_TO_ADDR
32151: LD_EXP 76
32155: PUSH
32156: FOR_TO
32157: IFFALSE 32544
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32159: LD_EXP 84
32163: PUSH
32164: LD_VAR 0 2
32168: ARRAY
32169: NOT
32170: PUSH
32171: LD_EXP 76
32175: PUSH
32176: LD_VAR 0 2
32180: ARRAY
32181: PPUSH
32182: LD_INT 30
32184: PUSH
32185: LD_INT 3
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PPUSH
32192: CALL_OW 72
32196: NOT
32197: OR
32198: IFFALSE 32202
// continue ;
32200: GO 32156
// busy := false ;
32202: LD_ADDR_VAR 0 8
32206: PUSH
32207: LD_INT 0
32209: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32210: LD_ADDR_VAR 0 4
32214: PUSH
32215: LD_EXP 76
32219: PUSH
32220: LD_VAR 0 2
32224: ARRAY
32225: PPUSH
32226: LD_INT 30
32228: PUSH
32229: LD_INT 3
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PPUSH
32236: CALL_OW 72
32240: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32241: LD_ADDR_VAR 0 6
32245: PUSH
32246: LD_EXP 84
32250: PUSH
32251: LD_VAR 0 2
32255: ARRAY
32256: PPUSH
32257: LD_INT 2
32259: PUSH
32260: LD_INT 30
32262: PUSH
32263: LD_INT 32
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: LD_INT 30
32272: PUSH
32273: LD_INT 33
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: LIST
32284: PPUSH
32285: CALL_OW 72
32289: ST_TO_ADDR
// if not t then
32290: LD_VAR 0 6
32294: NOT
32295: IFFALSE 32299
// continue ;
32297: GO 32156
// for j in tmp do
32299: LD_ADDR_VAR 0 3
32303: PUSH
32304: LD_VAR 0 4
32308: PUSH
32309: FOR_IN
32310: IFFALSE 32340
// if not BuildingStatus ( j ) = bs_idle then
32312: LD_VAR 0 3
32316: PPUSH
32317: CALL_OW 461
32321: PUSH
32322: LD_INT 2
32324: EQUAL
32325: NOT
32326: IFFALSE 32338
// begin busy := true ;
32328: LD_ADDR_VAR 0 8
32332: PUSH
32333: LD_INT 1
32335: ST_TO_ADDR
// break ;
32336: GO 32340
// end ;
32338: GO 32309
32340: POP
32341: POP
// if busy then
32342: LD_VAR 0 8
32346: IFFALSE 32350
// continue ;
32348: GO 32156
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32350: LD_ADDR_VAR 0 7
32354: PUSH
32355: LD_VAR 0 6
32359: PPUSH
32360: LD_INT 35
32362: PUSH
32363: LD_INT 0
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PPUSH
32370: CALL_OW 72
32374: ST_TO_ADDR
// if tw then
32375: LD_VAR 0 7
32379: IFFALSE 32456
// begin tw := tw [ 1 ] ;
32381: LD_ADDR_VAR 0 7
32385: PUSH
32386: LD_VAR 0 7
32390: PUSH
32391: LD_INT 1
32393: ARRAY
32394: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32395: LD_ADDR_VAR 0 9
32399: PUSH
32400: LD_VAR 0 7
32404: PPUSH
32405: LD_EXP 101
32409: PUSH
32410: LD_VAR 0 2
32414: ARRAY
32415: PPUSH
32416: CALL 62502 0 2
32420: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32421: LD_EXP 115
32425: PUSH
32426: LD_VAR 0 2
32430: ARRAY
32431: IFFALSE 32454
// if not weapon in mc_allowed_tower_weapons [ i ] then
32433: LD_VAR 0 9
32437: PUSH
32438: LD_EXP 115
32442: PUSH
32443: LD_VAR 0 2
32447: ARRAY
32448: IN
32449: NOT
32450: IFFALSE 32454
// continue ;
32452: GO 32156
// end else
32454: GO 32519
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32456: LD_ADDR_VAR 0 5
32460: PUSH
32461: LD_EXP 84
32465: PUSH
32466: LD_VAR 0 2
32470: ARRAY
32471: PPUSH
32472: LD_VAR 0 4
32476: PPUSH
32477: CALL 92729 0 2
32481: ST_TO_ADDR
// if not tmp2 then
32482: LD_VAR 0 5
32486: NOT
32487: IFFALSE 32491
// continue ;
32489: GO 32156
// tw := tmp2 [ 1 ] ;
32491: LD_ADDR_VAR 0 7
32495: PUSH
32496: LD_VAR 0 5
32500: PUSH
32501: LD_INT 1
32503: ARRAY
32504: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32505: LD_ADDR_VAR 0 9
32509: PUSH
32510: LD_VAR 0 5
32514: PUSH
32515: LD_INT 2
32517: ARRAY
32518: ST_TO_ADDR
// end ; if not weapon then
32519: LD_VAR 0 9
32523: NOT
32524: IFFALSE 32528
// continue ;
32526: GO 32156
// ComPlaceWeapon ( tw , weapon ) ;
32528: LD_VAR 0 7
32532: PPUSH
32533: LD_VAR 0 9
32537: PPUSH
32538: CALL_OW 148
// end ;
32542: GO 32156
32544: POP
32545: POP
// end ;
32546: LD_VAR 0 1
32550: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32551: LD_INT 0
32553: PPUSH
32554: PPUSH
32555: PPUSH
32556: PPUSH
32557: PPUSH
32558: PPUSH
// if not mc_bases then
32559: LD_EXP 76
32563: NOT
32564: IFFALSE 32568
// exit ;
32566: GO 33344
// for i = 1 to mc_bases do
32568: LD_ADDR_VAR 0 2
32572: PUSH
32573: DOUBLE
32574: LD_INT 1
32576: DEC
32577: ST_TO_ADDR
32578: LD_EXP 76
32582: PUSH
32583: FOR_TO
32584: IFFALSE 33342
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
32586: LD_EXP 89
32590: PUSH
32591: LD_VAR 0 2
32595: ARRAY
32596: NOT
32597: PUSH
32598: LD_EXP 89
32602: PUSH
32603: LD_VAR 0 2
32607: ARRAY
32608: PUSH
32609: LD_EXP 90
32613: PUSH
32614: LD_VAR 0 2
32618: ARRAY
32619: EQUAL
32620: OR
32621: PUSH
32622: LD_EXP 99
32626: PUSH
32627: LD_VAR 0 2
32631: ARRAY
32632: OR
32633: IFFALSE 32637
// continue ;
32635: GO 32583
// if mc_miners [ i ] then
32637: LD_EXP 90
32641: PUSH
32642: LD_VAR 0 2
32646: ARRAY
32647: IFFALSE 33029
// begin for j = mc_miners [ i ] downto 1 do
32649: LD_ADDR_VAR 0 3
32653: PUSH
32654: DOUBLE
32655: LD_EXP 90
32659: PUSH
32660: LD_VAR 0 2
32664: ARRAY
32665: INC
32666: ST_TO_ADDR
32667: LD_INT 1
32669: PUSH
32670: FOR_DOWNTO
32671: IFFALSE 33027
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32673: LD_EXP 90
32677: PUSH
32678: LD_VAR 0 2
32682: ARRAY
32683: PUSH
32684: LD_VAR 0 3
32688: ARRAY
32689: PPUSH
32690: CALL_OW 301
32694: PUSH
32695: LD_EXP 90
32699: PUSH
32700: LD_VAR 0 2
32704: ARRAY
32705: PUSH
32706: LD_VAR 0 3
32710: ARRAY
32711: PPUSH
32712: CALL_OW 257
32716: PUSH
32717: LD_INT 1
32719: NONEQUAL
32720: OR
32721: IFFALSE 32784
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32723: LD_ADDR_VAR 0 5
32727: PUSH
32728: LD_EXP 90
32732: PUSH
32733: LD_VAR 0 2
32737: ARRAY
32738: PUSH
32739: LD_EXP 90
32743: PUSH
32744: LD_VAR 0 2
32748: ARRAY
32749: PUSH
32750: LD_VAR 0 3
32754: ARRAY
32755: DIFF
32756: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
32757: LD_ADDR_EXP 90
32761: PUSH
32762: LD_EXP 90
32766: PPUSH
32767: LD_VAR 0 2
32771: PPUSH
32772: LD_VAR 0 5
32776: PPUSH
32777: CALL_OW 1
32781: ST_TO_ADDR
// continue ;
32782: GO 32670
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
32784: LD_EXP 90
32788: PUSH
32789: LD_VAR 0 2
32793: ARRAY
32794: PUSH
32795: LD_VAR 0 3
32799: ARRAY
32800: PPUSH
32801: CALL_OW 257
32805: PUSH
32806: LD_INT 1
32808: EQUAL
32809: PUSH
32810: LD_EXP 90
32814: PUSH
32815: LD_VAR 0 2
32819: ARRAY
32820: PUSH
32821: LD_VAR 0 3
32825: ARRAY
32826: PPUSH
32827: CALL_OW 459
32831: NOT
32832: AND
32833: PUSH
32834: LD_EXP 90
32838: PUSH
32839: LD_VAR 0 2
32843: ARRAY
32844: PUSH
32845: LD_VAR 0 3
32849: ARRAY
32850: PPUSH
32851: CALL_OW 314
32855: NOT
32856: AND
32857: IFFALSE 33025
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32859: LD_EXP 90
32863: PUSH
32864: LD_VAR 0 2
32868: ARRAY
32869: PUSH
32870: LD_VAR 0 3
32874: ARRAY
32875: PPUSH
32876: CALL_OW 310
32880: IFFALSE 32903
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32882: LD_EXP 90
32886: PUSH
32887: LD_VAR 0 2
32891: ARRAY
32892: PUSH
32893: LD_VAR 0 3
32897: ARRAY
32898: PPUSH
32899: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
32903: LD_EXP 90
32907: PUSH
32908: LD_VAR 0 2
32912: ARRAY
32913: PUSH
32914: LD_VAR 0 3
32918: ARRAY
32919: PPUSH
32920: CALL_OW 314
32924: NOT
32925: IFFALSE 33025
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
32927: LD_EXP 90
32931: PUSH
32932: LD_VAR 0 2
32936: ARRAY
32937: PUSH
32938: LD_VAR 0 3
32942: ARRAY
32943: PPUSH
32944: LD_EXP 89
32948: PUSH
32949: LD_VAR 0 2
32953: ARRAY
32954: PUSH
32955: LD_VAR 0 3
32959: PUSH
32960: LD_EXP 89
32964: PUSH
32965: LD_VAR 0 2
32969: ARRAY
32970: MOD
32971: PUSH
32972: LD_INT 1
32974: PLUS
32975: ARRAY
32976: PUSH
32977: LD_INT 1
32979: ARRAY
32980: PPUSH
32981: LD_EXP 89
32985: PUSH
32986: LD_VAR 0 2
32990: ARRAY
32991: PUSH
32992: LD_VAR 0 3
32996: PUSH
32997: LD_EXP 89
33001: PUSH
33002: LD_VAR 0 2
33006: ARRAY
33007: MOD
33008: PUSH
33009: LD_INT 1
33011: PLUS
33012: ARRAY
33013: PUSH
33014: LD_INT 2
33016: ARRAY
33017: PPUSH
33018: LD_INT 0
33020: PPUSH
33021: CALL_OW 193
// end ; end ;
33025: GO 32670
33027: POP
33028: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33029: LD_ADDR_VAR 0 5
33033: PUSH
33034: LD_EXP 76
33038: PUSH
33039: LD_VAR 0 2
33043: ARRAY
33044: PPUSH
33045: LD_INT 2
33047: PUSH
33048: LD_INT 30
33050: PUSH
33051: LD_INT 4
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 30
33060: PUSH
33061: LD_INT 5
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PUSH
33068: LD_INT 30
33070: PUSH
33071: LD_INT 32
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: PPUSH
33084: CALL_OW 72
33088: ST_TO_ADDR
// if not tmp then
33089: LD_VAR 0 5
33093: NOT
33094: IFFALSE 33098
// continue ;
33096: GO 32583
// list := [ ] ;
33098: LD_ADDR_VAR 0 6
33102: PUSH
33103: EMPTY
33104: ST_TO_ADDR
// for j in tmp do
33105: LD_ADDR_VAR 0 3
33109: PUSH
33110: LD_VAR 0 5
33114: PUSH
33115: FOR_IN
33116: IFFALSE 33185
// begin for k in UnitsInside ( j ) do
33118: LD_ADDR_VAR 0 4
33122: PUSH
33123: LD_VAR 0 3
33127: PPUSH
33128: CALL_OW 313
33132: PUSH
33133: FOR_IN
33134: IFFALSE 33181
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33136: LD_VAR 0 4
33140: PPUSH
33141: CALL_OW 257
33145: PUSH
33146: LD_INT 1
33148: EQUAL
33149: PUSH
33150: LD_VAR 0 4
33154: PPUSH
33155: CALL_OW 459
33159: NOT
33160: AND
33161: IFFALSE 33179
// list := list ^ k ;
33163: LD_ADDR_VAR 0 6
33167: PUSH
33168: LD_VAR 0 6
33172: PUSH
33173: LD_VAR 0 4
33177: ADD
33178: ST_TO_ADDR
33179: GO 33133
33181: POP
33182: POP
// end ;
33183: GO 33115
33185: POP
33186: POP
// list := list diff mc_miners [ i ] ;
33187: LD_ADDR_VAR 0 6
33191: PUSH
33192: LD_VAR 0 6
33196: PUSH
33197: LD_EXP 90
33201: PUSH
33202: LD_VAR 0 2
33206: ARRAY
33207: DIFF
33208: ST_TO_ADDR
// if not list then
33209: LD_VAR 0 6
33213: NOT
33214: IFFALSE 33218
// continue ;
33216: GO 32583
// k := mc_mines [ i ] - mc_miners [ i ] ;
33218: LD_ADDR_VAR 0 4
33222: PUSH
33223: LD_EXP 89
33227: PUSH
33228: LD_VAR 0 2
33232: ARRAY
33233: PUSH
33234: LD_EXP 90
33238: PUSH
33239: LD_VAR 0 2
33243: ARRAY
33244: MINUS
33245: ST_TO_ADDR
// if k > list then
33246: LD_VAR 0 4
33250: PUSH
33251: LD_VAR 0 6
33255: GREATER
33256: IFFALSE 33268
// k := list ;
33258: LD_ADDR_VAR 0 4
33262: PUSH
33263: LD_VAR 0 6
33267: ST_TO_ADDR
// for j = 1 to k do
33268: LD_ADDR_VAR 0 3
33272: PUSH
33273: DOUBLE
33274: LD_INT 1
33276: DEC
33277: ST_TO_ADDR
33278: LD_VAR 0 4
33282: PUSH
33283: FOR_TO
33284: IFFALSE 33338
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33286: LD_ADDR_EXP 90
33290: PUSH
33291: LD_EXP 90
33295: PPUSH
33296: LD_VAR 0 2
33300: PUSH
33301: LD_EXP 90
33305: PUSH
33306: LD_VAR 0 2
33310: ARRAY
33311: PUSH
33312: LD_INT 1
33314: PLUS
33315: PUSH
33316: EMPTY
33317: LIST
33318: LIST
33319: PPUSH
33320: LD_VAR 0 6
33324: PUSH
33325: LD_VAR 0 3
33329: ARRAY
33330: PPUSH
33331: CALL 57532 0 3
33335: ST_TO_ADDR
33336: GO 33283
33338: POP
33339: POP
// end ;
33340: GO 32583
33342: POP
33343: POP
// end ;
33344: LD_VAR 0 1
33348: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33349: LD_INT 0
33351: PPUSH
33352: PPUSH
33353: PPUSH
33354: PPUSH
33355: PPUSH
33356: PPUSH
33357: PPUSH
33358: PPUSH
33359: PPUSH
33360: PPUSH
// if not mc_bases then
33361: LD_EXP 76
33365: NOT
33366: IFFALSE 33370
// exit ;
33368: GO 35120
// for i = 1 to mc_bases do
33370: LD_ADDR_VAR 0 2
33374: PUSH
33375: DOUBLE
33376: LD_INT 1
33378: DEC
33379: ST_TO_ADDR
33380: LD_EXP 76
33384: PUSH
33385: FOR_TO
33386: IFFALSE 35118
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33388: LD_EXP 76
33392: PUSH
33393: LD_VAR 0 2
33397: ARRAY
33398: NOT
33399: PUSH
33400: LD_EXP 83
33404: PUSH
33405: LD_VAR 0 2
33409: ARRAY
33410: OR
33411: IFFALSE 33415
// continue ;
33413: GO 33385
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33415: LD_EXP 92
33419: PUSH
33420: LD_VAR 0 2
33424: ARRAY
33425: NOT
33426: PUSH
33427: LD_EXP 93
33431: PUSH
33432: LD_VAR 0 2
33436: ARRAY
33437: AND
33438: IFFALSE 33476
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33440: LD_ADDR_EXP 93
33444: PUSH
33445: LD_EXP 93
33449: PPUSH
33450: LD_VAR 0 2
33454: PPUSH
33455: EMPTY
33456: PPUSH
33457: CALL_OW 1
33461: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33462: LD_VAR 0 2
33466: PPUSH
33467: LD_INT 107
33469: PPUSH
33470: CALL 24334 0 2
// continue ;
33474: GO 33385
// end ; target := [ ] ;
33476: LD_ADDR_VAR 0 6
33480: PUSH
33481: EMPTY
33482: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33483: LD_ADDR_VAR 0 3
33487: PUSH
33488: DOUBLE
33489: LD_EXP 92
33493: PUSH
33494: LD_VAR 0 2
33498: ARRAY
33499: INC
33500: ST_TO_ADDR
33501: LD_INT 1
33503: PUSH
33504: FOR_DOWNTO
33505: IFFALSE 33765
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33507: LD_EXP 92
33511: PUSH
33512: LD_VAR 0 2
33516: ARRAY
33517: PUSH
33518: LD_VAR 0 3
33522: ARRAY
33523: PUSH
33524: LD_INT 2
33526: ARRAY
33527: PPUSH
33528: LD_EXP 92
33532: PUSH
33533: LD_VAR 0 2
33537: ARRAY
33538: PUSH
33539: LD_VAR 0 3
33543: ARRAY
33544: PUSH
33545: LD_INT 3
33547: ARRAY
33548: PPUSH
33549: CALL_OW 488
33553: PUSH
33554: LD_EXP 92
33558: PUSH
33559: LD_VAR 0 2
33563: ARRAY
33564: PUSH
33565: LD_VAR 0 3
33569: ARRAY
33570: PUSH
33571: LD_INT 2
33573: ARRAY
33574: PPUSH
33575: LD_EXP 92
33579: PUSH
33580: LD_VAR 0 2
33584: ARRAY
33585: PUSH
33586: LD_VAR 0 3
33590: ARRAY
33591: PUSH
33592: LD_INT 3
33594: ARRAY
33595: PPUSH
33596: CALL_OW 284
33600: PUSH
33601: LD_INT 0
33603: EQUAL
33604: AND
33605: IFFALSE 33660
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33607: LD_ADDR_VAR 0 5
33611: PUSH
33612: LD_EXP 92
33616: PUSH
33617: LD_VAR 0 2
33621: ARRAY
33622: PPUSH
33623: LD_VAR 0 3
33627: PPUSH
33628: CALL_OW 3
33632: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33633: LD_ADDR_EXP 92
33637: PUSH
33638: LD_EXP 92
33642: PPUSH
33643: LD_VAR 0 2
33647: PPUSH
33648: LD_VAR 0 5
33652: PPUSH
33653: CALL_OW 1
33657: ST_TO_ADDR
// continue ;
33658: GO 33504
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33660: LD_EXP 76
33664: PUSH
33665: LD_VAR 0 2
33669: ARRAY
33670: PUSH
33671: LD_INT 1
33673: ARRAY
33674: PPUSH
33675: CALL_OW 255
33679: PPUSH
33680: LD_EXP 92
33684: PUSH
33685: LD_VAR 0 2
33689: ARRAY
33690: PUSH
33691: LD_VAR 0 3
33695: ARRAY
33696: PUSH
33697: LD_INT 2
33699: ARRAY
33700: PPUSH
33701: LD_EXP 92
33705: PUSH
33706: LD_VAR 0 2
33710: ARRAY
33711: PUSH
33712: LD_VAR 0 3
33716: ARRAY
33717: PUSH
33718: LD_INT 3
33720: ARRAY
33721: PPUSH
33722: LD_INT 30
33724: PPUSH
33725: CALL 58428 0 4
33729: PUSH
33730: LD_INT 4
33732: ARRAY
33733: PUSH
33734: LD_INT 0
33736: EQUAL
33737: IFFALSE 33763
// begin target := mc_crates [ i ] [ j ] ;
33739: LD_ADDR_VAR 0 6
33743: PUSH
33744: LD_EXP 92
33748: PUSH
33749: LD_VAR 0 2
33753: ARRAY
33754: PUSH
33755: LD_VAR 0 3
33759: ARRAY
33760: ST_TO_ADDR
// break ;
33761: GO 33765
// end ; end ;
33763: GO 33504
33765: POP
33766: POP
// if not target then
33767: LD_VAR 0 6
33771: NOT
33772: IFFALSE 33776
// continue ;
33774: GO 33385
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33776: LD_ADDR_VAR 0 7
33780: PUSH
33781: LD_EXP 95
33785: PUSH
33786: LD_VAR 0 2
33790: ARRAY
33791: PPUSH
33792: LD_INT 2
33794: PUSH
33795: LD_INT 3
33797: PUSH
33798: LD_INT 58
33800: PUSH
33801: EMPTY
33802: LIST
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 61
33810: PUSH
33811: EMPTY
33812: LIST
33813: PUSH
33814: LD_INT 33
33816: PUSH
33817: LD_INT 5
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: PUSH
33824: LD_INT 33
33826: PUSH
33827: LD_INT 3
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 2
33843: PUSH
33844: LD_INT 34
33846: PUSH
33847: LD_INT 32
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 34
33856: PUSH
33857: LD_INT 51
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 34
33866: PUSH
33867: LD_INT 12
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PPUSH
33884: CALL_OW 72
33888: ST_TO_ADDR
// if not cargo then
33889: LD_VAR 0 7
33893: NOT
33894: IFFALSE 34537
// begin if mc_crates_collector [ i ] < 5 then
33896: LD_EXP 93
33900: PUSH
33901: LD_VAR 0 2
33905: ARRAY
33906: PUSH
33907: LD_INT 5
33909: LESS
33910: IFFALSE 34276
// begin if mc_ape [ i ] then
33912: LD_EXP 105
33916: PUSH
33917: LD_VAR 0 2
33921: ARRAY
33922: IFFALSE 33969
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
33924: LD_ADDR_VAR 0 5
33928: PUSH
33929: LD_EXP 105
33933: PUSH
33934: LD_VAR 0 2
33938: ARRAY
33939: PPUSH
33940: LD_INT 25
33942: PUSH
33943: LD_INT 16
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: PUSH
33950: LD_INT 24
33952: PUSH
33953: LD_INT 750
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: EMPTY
33961: LIST
33962: LIST
33963: PPUSH
33964: CALL_OW 72
33968: ST_TO_ADDR
// if not tmp then
33969: LD_VAR 0 5
33973: NOT
33974: IFFALSE 34021
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
33976: LD_ADDR_VAR 0 5
33980: PUSH
33981: LD_EXP 76
33985: PUSH
33986: LD_VAR 0 2
33990: ARRAY
33991: PPUSH
33992: LD_INT 25
33994: PUSH
33995: LD_INT 2
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 24
34004: PUSH
34005: LD_INT 750
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PPUSH
34016: CALL_OW 72
34020: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34021: LD_EXP 105
34025: PUSH
34026: LD_VAR 0 2
34030: ARRAY
34031: PUSH
34032: LD_EXP 76
34036: PUSH
34037: LD_VAR 0 2
34041: ARRAY
34042: PPUSH
34043: LD_INT 25
34045: PUSH
34046: LD_INT 2
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 24
34055: PUSH
34056: LD_INT 750
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PPUSH
34067: CALL_OW 72
34071: AND
34072: PUSH
34073: LD_VAR 0 5
34077: PUSH
34078: LD_INT 5
34080: LESS
34081: AND
34082: IFFALSE 34164
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34084: LD_ADDR_VAR 0 3
34088: PUSH
34089: LD_EXP 76
34093: PUSH
34094: LD_VAR 0 2
34098: ARRAY
34099: PPUSH
34100: LD_INT 25
34102: PUSH
34103: LD_INT 2
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 24
34112: PUSH
34113: LD_INT 750
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PPUSH
34124: CALL_OW 72
34128: PUSH
34129: FOR_IN
34130: IFFALSE 34162
// begin tmp := tmp union j ;
34132: LD_ADDR_VAR 0 5
34136: PUSH
34137: LD_VAR 0 5
34141: PUSH
34142: LD_VAR 0 3
34146: UNION
34147: ST_TO_ADDR
// if tmp >= 5 then
34148: LD_VAR 0 5
34152: PUSH
34153: LD_INT 5
34155: GREATEREQUAL
34156: IFFALSE 34160
// break ;
34158: GO 34162
// end ;
34160: GO 34129
34162: POP
34163: POP
// end ; if not tmp then
34164: LD_VAR 0 5
34168: NOT
34169: IFFALSE 34173
// continue ;
34171: GO 33385
// for j in tmp do
34173: LD_ADDR_VAR 0 3
34177: PUSH
34178: LD_VAR 0 5
34182: PUSH
34183: FOR_IN
34184: IFFALSE 34274
// if not GetTag ( j ) then
34186: LD_VAR 0 3
34190: PPUSH
34191: CALL_OW 110
34195: NOT
34196: IFFALSE 34272
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34198: LD_ADDR_EXP 93
34202: PUSH
34203: LD_EXP 93
34207: PPUSH
34208: LD_VAR 0 2
34212: PUSH
34213: LD_EXP 93
34217: PUSH
34218: LD_VAR 0 2
34222: ARRAY
34223: PUSH
34224: LD_INT 1
34226: PLUS
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PPUSH
34232: LD_VAR 0 3
34236: PPUSH
34237: CALL 57532 0 3
34241: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34242: LD_VAR 0 3
34246: PPUSH
34247: LD_INT 107
34249: PPUSH
34250: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34254: LD_EXP 93
34258: PUSH
34259: LD_VAR 0 2
34263: ARRAY
34264: PUSH
34265: LD_INT 5
34267: GREATEREQUAL
34268: IFFALSE 34272
// break ;
34270: GO 34274
// end ;
34272: GO 34183
34274: POP
34275: POP
// end ; if mc_crates_collector [ i ] and target then
34276: LD_EXP 93
34280: PUSH
34281: LD_VAR 0 2
34285: ARRAY
34286: PUSH
34287: LD_VAR 0 6
34291: AND
34292: IFFALSE 34535
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34294: LD_EXP 93
34298: PUSH
34299: LD_VAR 0 2
34303: ARRAY
34304: PUSH
34305: LD_VAR 0 6
34309: PUSH
34310: LD_INT 1
34312: ARRAY
34313: LESS
34314: IFFALSE 34334
// tmp := mc_crates_collector [ i ] else
34316: LD_ADDR_VAR 0 5
34320: PUSH
34321: LD_EXP 93
34325: PUSH
34326: LD_VAR 0 2
34330: ARRAY
34331: ST_TO_ADDR
34332: GO 34348
// tmp := target [ 1 ] ;
34334: LD_ADDR_VAR 0 5
34338: PUSH
34339: LD_VAR 0 6
34343: PUSH
34344: LD_INT 1
34346: ARRAY
34347: ST_TO_ADDR
// k := 0 ;
34348: LD_ADDR_VAR 0 4
34352: PUSH
34353: LD_INT 0
34355: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34356: LD_ADDR_VAR 0 3
34360: PUSH
34361: LD_EXP 93
34365: PUSH
34366: LD_VAR 0 2
34370: ARRAY
34371: PUSH
34372: FOR_IN
34373: IFFALSE 34533
// begin k := k + 1 ;
34375: LD_ADDR_VAR 0 4
34379: PUSH
34380: LD_VAR 0 4
34384: PUSH
34385: LD_INT 1
34387: PLUS
34388: ST_TO_ADDR
// if k > tmp then
34389: LD_VAR 0 4
34393: PUSH
34394: LD_VAR 0 5
34398: GREATER
34399: IFFALSE 34403
// break ;
34401: GO 34533
// if not GetClass ( j ) in [ 2 , 16 ] then
34403: LD_VAR 0 3
34407: PPUSH
34408: CALL_OW 257
34412: PUSH
34413: LD_INT 2
34415: PUSH
34416: LD_INT 16
34418: PUSH
34419: EMPTY
34420: LIST
34421: LIST
34422: IN
34423: NOT
34424: IFFALSE 34477
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34426: LD_ADDR_EXP 93
34430: PUSH
34431: LD_EXP 93
34435: PPUSH
34436: LD_VAR 0 2
34440: PPUSH
34441: LD_EXP 93
34445: PUSH
34446: LD_VAR 0 2
34450: ARRAY
34451: PUSH
34452: LD_VAR 0 3
34456: DIFF
34457: PPUSH
34458: CALL_OW 1
34462: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34463: LD_VAR 0 3
34467: PPUSH
34468: LD_INT 0
34470: PPUSH
34471: CALL_OW 109
// continue ;
34475: GO 34372
// end ; if IsInUnit ( j ) then
34477: LD_VAR 0 3
34481: PPUSH
34482: CALL_OW 310
34486: IFFALSE 34497
// ComExitBuilding ( j ) ;
34488: LD_VAR 0 3
34492: PPUSH
34493: CALL_OW 122
// wait ( 3 ) ;
34497: LD_INT 3
34499: PPUSH
34500: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34504: LD_VAR 0 3
34508: PPUSH
34509: LD_VAR 0 6
34513: PUSH
34514: LD_INT 2
34516: ARRAY
34517: PPUSH
34518: LD_VAR 0 6
34522: PUSH
34523: LD_INT 3
34525: ARRAY
34526: PPUSH
34527: CALL_OW 117
// end ;
34531: GO 34372
34533: POP
34534: POP
// end ; end else
34535: GO 35116
// begin for j in cargo do
34537: LD_ADDR_VAR 0 3
34541: PUSH
34542: LD_VAR 0 7
34546: PUSH
34547: FOR_IN
34548: IFFALSE 35114
// begin if GetTag ( j ) <> 0 then
34550: LD_VAR 0 3
34554: PPUSH
34555: CALL_OW 110
34559: PUSH
34560: LD_INT 0
34562: NONEQUAL
34563: IFFALSE 34567
// continue ;
34565: GO 34547
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34567: LD_VAR 0 3
34571: PPUSH
34572: CALL_OW 256
34576: PUSH
34577: LD_INT 1000
34579: LESS
34580: PUSH
34581: LD_VAR 0 3
34585: PPUSH
34586: LD_EXP 100
34590: PUSH
34591: LD_VAR 0 2
34595: ARRAY
34596: PPUSH
34597: CALL_OW 308
34601: NOT
34602: AND
34603: IFFALSE 34625
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34605: LD_VAR 0 3
34609: PPUSH
34610: LD_EXP 100
34614: PUSH
34615: LD_VAR 0 2
34619: ARRAY
34620: PPUSH
34621: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34625: LD_VAR 0 3
34629: PPUSH
34630: CALL_OW 256
34634: PUSH
34635: LD_INT 1000
34637: LESS
34638: PUSH
34639: LD_VAR 0 3
34643: PPUSH
34644: LD_EXP 100
34648: PUSH
34649: LD_VAR 0 2
34653: ARRAY
34654: PPUSH
34655: CALL_OW 308
34659: AND
34660: IFFALSE 34664
// continue ;
34662: GO 34547
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34664: LD_VAR 0 3
34668: PPUSH
34669: CALL_OW 262
34673: PUSH
34674: LD_INT 2
34676: EQUAL
34677: PUSH
34678: LD_VAR 0 3
34682: PPUSH
34683: CALL_OW 261
34687: PUSH
34688: LD_INT 15
34690: LESS
34691: AND
34692: IFFALSE 34696
// continue ;
34694: GO 34547
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34696: LD_VAR 0 3
34700: PPUSH
34701: CALL_OW 262
34705: PUSH
34706: LD_INT 1
34708: EQUAL
34709: PUSH
34710: LD_VAR 0 3
34714: PPUSH
34715: CALL_OW 261
34719: PUSH
34720: LD_INT 10
34722: LESS
34723: AND
34724: IFFALSE 35053
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34726: LD_ADDR_VAR 0 8
34730: PUSH
34731: LD_EXP 76
34735: PUSH
34736: LD_VAR 0 2
34740: ARRAY
34741: PPUSH
34742: LD_INT 2
34744: PUSH
34745: LD_INT 30
34747: PUSH
34748: LD_INT 0
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 30
34757: PUSH
34758: LD_INT 1
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: LIST
34769: PPUSH
34770: CALL_OW 72
34774: ST_TO_ADDR
// if not depot then
34775: LD_VAR 0 8
34779: NOT
34780: IFFALSE 34784
// continue ;
34782: GO 34547
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34784: LD_VAR 0 3
34788: PPUSH
34789: LD_VAR 0 8
34793: PPUSH
34794: LD_VAR 0 3
34798: PPUSH
34799: CALL_OW 74
34803: PPUSH
34804: CALL_OW 296
34808: PUSH
34809: LD_INT 6
34811: LESS
34812: IFFALSE 34828
// SetFuel ( j , 100 ) else
34814: LD_VAR 0 3
34818: PPUSH
34819: LD_INT 100
34821: PPUSH
34822: CALL_OW 240
34826: GO 35053
// if GetFuel ( j ) = 0 then
34828: LD_VAR 0 3
34832: PPUSH
34833: CALL_OW 261
34837: PUSH
34838: LD_INT 0
34840: EQUAL
34841: IFFALSE 35053
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34843: LD_ADDR_EXP 95
34847: PUSH
34848: LD_EXP 95
34852: PPUSH
34853: LD_VAR 0 2
34857: PPUSH
34858: LD_EXP 95
34862: PUSH
34863: LD_VAR 0 2
34867: ARRAY
34868: PUSH
34869: LD_VAR 0 3
34873: DIFF
34874: PPUSH
34875: CALL_OW 1
34879: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34880: LD_VAR 0 3
34884: PPUSH
34885: CALL_OW 263
34889: PUSH
34890: LD_INT 1
34892: EQUAL
34893: IFFALSE 34909
// ComExitVehicle ( IsInUnit ( j ) ) ;
34895: LD_VAR 0 3
34899: PPUSH
34900: CALL_OW 310
34904: PPUSH
34905: CALL_OW 121
// if GetControl ( j ) = control_remote then
34909: LD_VAR 0 3
34913: PPUSH
34914: CALL_OW 263
34918: PUSH
34919: LD_INT 2
34921: EQUAL
34922: IFFALSE 34933
// ComUnlink ( j ) ;
34924: LD_VAR 0 3
34928: PPUSH
34929: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
34933: LD_ADDR_VAR 0 9
34937: PUSH
34938: LD_VAR 0 2
34942: PPUSH
34943: LD_INT 3
34945: PPUSH
34946: CALL 44406 0 2
34950: ST_TO_ADDR
// if fac then
34951: LD_VAR 0 9
34955: IFFALSE 35051
// begin for k in fac do
34957: LD_ADDR_VAR 0 4
34961: PUSH
34962: LD_VAR 0 9
34966: PUSH
34967: FOR_IN
34968: IFFALSE 35049
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
34970: LD_ADDR_VAR 0 10
34974: PUSH
34975: LD_VAR 0 9
34979: PPUSH
34980: LD_VAR 0 3
34984: PPUSH
34985: CALL_OW 265
34989: PPUSH
34990: LD_VAR 0 3
34994: PPUSH
34995: CALL_OW 262
34999: PPUSH
35000: LD_VAR 0 3
35004: PPUSH
35005: CALL_OW 263
35009: PPUSH
35010: LD_VAR 0 3
35014: PPUSH
35015: CALL_OW 264
35019: PPUSH
35020: CALL 55064 0 5
35024: ST_TO_ADDR
// if components then
35025: LD_VAR 0 10
35029: IFFALSE 35047
// begin MC_InsertProduceList ( i , components ) ;
35031: LD_VAR 0 2
35035: PPUSH
35036: LD_VAR 0 10
35040: PPUSH
35041: CALL 43951 0 2
// break ;
35045: GO 35049
// end ; end ;
35047: GO 34967
35049: POP
35050: POP
// end ; continue ;
35051: GO 34547
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35053: LD_VAR 0 3
35057: PPUSH
35058: LD_INT 1
35060: PPUSH
35061: CALL_OW 289
35065: PUSH
35066: LD_INT 100
35068: LESS
35069: PUSH
35070: LD_VAR 0 3
35074: PPUSH
35075: CALL_OW 314
35079: NOT
35080: AND
35081: IFFALSE 35110
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35083: LD_VAR 0 3
35087: PPUSH
35088: LD_VAR 0 6
35092: PUSH
35093: LD_INT 2
35095: ARRAY
35096: PPUSH
35097: LD_VAR 0 6
35101: PUSH
35102: LD_INT 3
35104: ARRAY
35105: PPUSH
35106: CALL_OW 117
// break ;
35110: GO 35114
// end ;
35112: GO 34547
35114: POP
35115: POP
// end ; end ;
35116: GO 33385
35118: POP
35119: POP
// end ;
35120: LD_VAR 0 1
35124: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35125: LD_INT 0
35127: PPUSH
35128: PPUSH
35129: PPUSH
35130: PPUSH
// if not mc_bases then
35131: LD_EXP 76
35135: NOT
35136: IFFALSE 35140
// exit ;
35138: GO 35301
// for i = 1 to mc_bases do
35140: LD_ADDR_VAR 0 2
35144: PUSH
35145: DOUBLE
35146: LD_INT 1
35148: DEC
35149: ST_TO_ADDR
35150: LD_EXP 76
35154: PUSH
35155: FOR_TO
35156: IFFALSE 35299
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35158: LD_ADDR_VAR 0 4
35162: PUSH
35163: LD_EXP 95
35167: PUSH
35168: LD_VAR 0 2
35172: ARRAY
35173: PUSH
35174: LD_EXP 98
35178: PUSH
35179: LD_VAR 0 2
35183: ARRAY
35184: UNION
35185: PPUSH
35186: LD_INT 33
35188: PUSH
35189: LD_INT 2
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PPUSH
35196: CALL_OW 72
35200: ST_TO_ADDR
// if tmp then
35201: LD_VAR 0 4
35205: IFFALSE 35297
// for j in tmp do
35207: LD_ADDR_VAR 0 3
35211: PUSH
35212: LD_VAR 0 4
35216: PUSH
35217: FOR_IN
35218: IFFALSE 35295
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35220: LD_VAR 0 3
35224: PPUSH
35225: CALL_OW 312
35229: NOT
35230: PUSH
35231: LD_VAR 0 3
35235: PPUSH
35236: CALL_OW 256
35240: PUSH
35241: LD_INT 250
35243: GREATEREQUAL
35244: AND
35245: IFFALSE 35258
// Connect ( j ) else
35247: LD_VAR 0 3
35251: PPUSH
35252: CALL 60465 0 1
35256: GO 35293
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35258: LD_VAR 0 3
35262: PPUSH
35263: CALL_OW 256
35267: PUSH
35268: LD_INT 250
35270: LESS
35271: PUSH
35272: LD_VAR 0 3
35276: PPUSH
35277: CALL_OW 312
35281: AND
35282: IFFALSE 35293
// ComUnlink ( j ) ;
35284: LD_VAR 0 3
35288: PPUSH
35289: CALL_OW 136
35293: GO 35217
35295: POP
35296: POP
// end ;
35297: GO 35155
35299: POP
35300: POP
// end ;
35301: LD_VAR 0 1
35305: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35306: LD_INT 0
35308: PPUSH
35309: PPUSH
35310: PPUSH
35311: PPUSH
35312: PPUSH
// if not mc_bases then
35313: LD_EXP 76
35317: NOT
35318: IFFALSE 35322
// exit ;
35320: GO 35767
// for i = 1 to mc_bases do
35322: LD_ADDR_VAR 0 2
35326: PUSH
35327: DOUBLE
35328: LD_INT 1
35330: DEC
35331: ST_TO_ADDR
35332: LD_EXP 76
35336: PUSH
35337: FOR_TO
35338: IFFALSE 35765
// begin if not mc_produce [ i ] then
35340: LD_EXP 97
35344: PUSH
35345: LD_VAR 0 2
35349: ARRAY
35350: NOT
35351: IFFALSE 35355
// continue ;
35353: GO 35337
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35355: LD_ADDR_VAR 0 5
35359: PUSH
35360: LD_EXP 76
35364: PUSH
35365: LD_VAR 0 2
35369: ARRAY
35370: PPUSH
35371: LD_INT 30
35373: PUSH
35374: LD_INT 3
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PPUSH
35381: CALL_OW 72
35385: ST_TO_ADDR
// if not fac then
35386: LD_VAR 0 5
35390: NOT
35391: IFFALSE 35395
// continue ;
35393: GO 35337
// for j in fac do
35395: LD_ADDR_VAR 0 3
35399: PUSH
35400: LD_VAR 0 5
35404: PUSH
35405: FOR_IN
35406: IFFALSE 35761
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35408: LD_VAR 0 3
35412: PPUSH
35413: CALL_OW 461
35417: PUSH
35418: LD_INT 2
35420: NONEQUAL
35421: PUSH
35422: LD_VAR 0 3
35426: PPUSH
35427: LD_INT 15
35429: PPUSH
35430: CALL 60125 0 2
35434: PUSH
35435: LD_INT 4
35437: ARRAY
35438: OR
35439: IFFALSE 35443
// continue ;
35441: GO 35405
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35443: LD_VAR 0 3
35447: PPUSH
35448: LD_EXP 97
35452: PUSH
35453: LD_VAR 0 2
35457: ARRAY
35458: PUSH
35459: LD_INT 1
35461: ARRAY
35462: PUSH
35463: LD_INT 1
35465: ARRAY
35466: PPUSH
35467: LD_EXP 97
35471: PUSH
35472: LD_VAR 0 2
35476: ARRAY
35477: PUSH
35478: LD_INT 1
35480: ARRAY
35481: PUSH
35482: LD_INT 2
35484: ARRAY
35485: PPUSH
35486: LD_EXP 97
35490: PUSH
35491: LD_VAR 0 2
35495: ARRAY
35496: PUSH
35497: LD_INT 1
35499: ARRAY
35500: PUSH
35501: LD_INT 3
35503: ARRAY
35504: PPUSH
35505: LD_EXP 97
35509: PUSH
35510: LD_VAR 0 2
35514: ARRAY
35515: PUSH
35516: LD_INT 1
35518: ARRAY
35519: PUSH
35520: LD_INT 4
35522: ARRAY
35523: PPUSH
35524: CALL_OW 448
35528: PUSH
35529: LD_VAR 0 3
35533: PPUSH
35534: LD_EXP 97
35538: PUSH
35539: LD_VAR 0 2
35543: ARRAY
35544: PUSH
35545: LD_INT 1
35547: ARRAY
35548: PUSH
35549: LD_INT 1
35551: ARRAY
35552: PUSH
35553: LD_EXP 97
35557: PUSH
35558: LD_VAR 0 2
35562: ARRAY
35563: PUSH
35564: LD_INT 1
35566: ARRAY
35567: PUSH
35568: LD_INT 2
35570: ARRAY
35571: PUSH
35572: LD_EXP 97
35576: PUSH
35577: LD_VAR 0 2
35581: ARRAY
35582: PUSH
35583: LD_INT 1
35585: ARRAY
35586: PUSH
35587: LD_INT 3
35589: ARRAY
35590: PUSH
35591: LD_EXP 97
35595: PUSH
35596: LD_VAR 0 2
35600: ARRAY
35601: PUSH
35602: LD_INT 1
35604: ARRAY
35605: PUSH
35606: LD_INT 4
35608: ARRAY
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: LIST
35614: LIST
35615: PPUSH
35616: CALL 63796 0 2
35620: AND
35621: IFFALSE 35759
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35623: LD_VAR 0 3
35627: PPUSH
35628: LD_EXP 97
35632: PUSH
35633: LD_VAR 0 2
35637: ARRAY
35638: PUSH
35639: LD_INT 1
35641: ARRAY
35642: PUSH
35643: LD_INT 1
35645: ARRAY
35646: PPUSH
35647: LD_EXP 97
35651: PUSH
35652: LD_VAR 0 2
35656: ARRAY
35657: PUSH
35658: LD_INT 1
35660: ARRAY
35661: PUSH
35662: LD_INT 2
35664: ARRAY
35665: PPUSH
35666: LD_EXP 97
35670: PUSH
35671: LD_VAR 0 2
35675: ARRAY
35676: PUSH
35677: LD_INT 1
35679: ARRAY
35680: PUSH
35681: LD_INT 3
35683: ARRAY
35684: PPUSH
35685: LD_EXP 97
35689: PUSH
35690: LD_VAR 0 2
35694: ARRAY
35695: PUSH
35696: LD_INT 1
35698: ARRAY
35699: PUSH
35700: LD_INT 4
35702: ARRAY
35703: PPUSH
35704: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35708: LD_ADDR_VAR 0 4
35712: PUSH
35713: LD_EXP 97
35717: PUSH
35718: LD_VAR 0 2
35722: ARRAY
35723: PPUSH
35724: LD_INT 1
35726: PPUSH
35727: CALL_OW 3
35731: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35732: LD_ADDR_EXP 97
35736: PUSH
35737: LD_EXP 97
35741: PPUSH
35742: LD_VAR 0 2
35746: PPUSH
35747: LD_VAR 0 4
35751: PPUSH
35752: CALL_OW 1
35756: ST_TO_ADDR
// break ;
35757: GO 35761
// end ; end ;
35759: GO 35405
35761: POP
35762: POP
// end ;
35763: GO 35337
35765: POP
35766: POP
// end ;
35767: LD_VAR 0 1
35771: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35772: LD_INT 0
35774: PPUSH
35775: PPUSH
35776: PPUSH
// if not mc_bases then
35777: LD_EXP 76
35781: NOT
35782: IFFALSE 35786
// exit ;
35784: GO 35875
// for i = 1 to mc_bases do
35786: LD_ADDR_VAR 0 2
35790: PUSH
35791: DOUBLE
35792: LD_INT 1
35794: DEC
35795: ST_TO_ADDR
35796: LD_EXP 76
35800: PUSH
35801: FOR_TO
35802: IFFALSE 35873
// begin if mc_attack [ i ] then
35804: LD_EXP 96
35808: PUSH
35809: LD_VAR 0 2
35813: ARRAY
35814: IFFALSE 35871
// begin tmp := mc_attack [ i ] [ 1 ] ;
35816: LD_ADDR_VAR 0 3
35820: PUSH
35821: LD_EXP 96
35825: PUSH
35826: LD_VAR 0 2
35830: ARRAY
35831: PUSH
35832: LD_INT 1
35834: ARRAY
35835: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35836: LD_ADDR_EXP 96
35840: PUSH
35841: LD_EXP 96
35845: PPUSH
35846: LD_VAR 0 2
35850: PPUSH
35851: EMPTY
35852: PPUSH
35853: CALL_OW 1
35857: ST_TO_ADDR
// Attack ( tmp ) ;
35858: LD_VAR 0 3
35862: PPUSH
35863: CALL 86009 0 1
// exit ;
35867: POP
35868: POP
35869: GO 35875
// end ; end ;
35871: GO 35801
35873: POP
35874: POP
// end ;
35875: LD_VAR 0 1
35879: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35880: LD_INT 0
35882: PPUSH
35883: PPUSH
35884: PPUSH
35885: PPUSH
35886: PPUSH
35887: PPUSH
35888: PPUSH
// if not mc_bases then
35889: LD_EXP 76
35893: NOT
35894: IFFALSE 35898
// exit ;
35896: GO 36480
// for i = 1 to mc_bases do
35898: LD_ADDR_VAR 0 2
35902: PUSH
35903: DOUBLE
35904: LD_INT 1
35906: DEC
35907: ST_TO_ADDR
35908: LD_EXP 76
35912: PUSH
35913: FOR_TO
35914: IFFALSE 36478
// begin if not mc_bases [ i ] then
35916: LD_EXP 76
35920: PUSH
35921: LD_VAR 0 2
35925: ARRAY
35926: NOT
35927: IFFALSE 35931
// continue ;
35929: GO 35913
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
35931: LD_ADDR_VAR 0 7
35935: PUSH
35936: LD_EXP 76
35940: PUSH
35941: LD_VAR 0 2
35945: ARRAY
35946: PUSH
35947: LD_INT 1
35949: ARRAY
35950: PPUSH
35951: CALL 54368 0 1
35955: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
35956: LD_ADDR_EXP 99
35960: PUSH
35961: LD_EXP 99
35965: PPUSH
35966: LD_VAR 0 2
35970: PPUSH
35971: LD_EXP 76
35975: PUSH
35976: LD_VAR 0 2
35980: ARRAY
35981: PUSH
35982: LD_INT 1
35984: ARRAY
35985: PPUSH
35986: CALL_OW 255
35990: PPUSH
35991: LD_EXP 101
35995: PUSH
35996: LD_VAR 0 2
36000: ARRAY
36001: PPUSH
36002: CALL 51922 0 2
36006: PPUSH
36007: CALL_OW 1
36011: ST_TO_ADDR
// if not mc_scan [ i ] then
36012: LD_EXP 99
36016: PUSH
36017: LD_VAR 0 2
36021: ARRAY
36022: NOT
36023: IFFALSE 36178
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36025: LD_ADDR_VAR 0 4
36029: PUSH
36030: LD_EXP 76
36034: PUSH
36035: LD_VAR 0 2
36039: ARRAY
36040: PPUSH
36041: LD_INT 2
36043: PUSH
36044: LD_INT 25
36046: PUSH
36047: LD_INT 5
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 25
36056: PUSH
36057: LD_INT 8
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 25
36066: PUSH
36067: LD_INT 9
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: LIST
36078: LIST
36079: PPUSH
36080: CALL_OW 72
36084: ST_TO_ADDR
// if not tmp then
36085: LD_VAR 0 4
36089: NOT
36090: IFFALSE 36094
// continue ;
36092: GO 35913
// for j in tmp do
36094: LD_ADDR_VAR 0 3
36098: PUSH
36099: LD_VAR 0 4
36103: PUSH
36104: FOR_IN
36105: IFFALSE 36176
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36107: LD_VAR 0 3
36111: PPUSH
36112: CALL_OW 310
36116: PPUSH
36117: CALL_OW 266
36121: PUSH
36122: LD_INT 5
36124: EQUAL
36125: PUSH
36126: LD_VAR 0 3
36130: PPUSH
36131: CALL_OW 257
36135: PUSH
36136: LD_INT 1
36138: EQUAL
36139: AND
36140: PUSH
36141: LD_VAR 0 3
36145: PPUSH
36146: CALL_OW 459
36150: NOT
36151: AND
36152: PUSH
36153: LD_VAR 0 7
36157: AND
36158: IFFALSE 36174
// ComChangeProfession ( j , class ) ;
36160: LD_VAR 0 3
36164: PPUSH
36165: LD_VAR 0 7
36169: PPUSH
36170: CALL_OW 123
36174: GO 36104
36176: POP
36177: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36178: LD_EXP 99
36182: PUSH
36183: LD_VAR 0 2
36187: ARRAY
36188: PUSH
36189: LD_EXP 98
36193: PUSH
36194: LD_VAR 0 2
36198: ARRAY
36199: NOT
36200: AND
36201: PUSH
36202: LD_EXP 76
36206: PUSH
36207: LD_VAR 0 2
36211: ARRAY
36212: PPUSH
36213: LD_INT 30
36215: PUSH
36216: LD_INT 32
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PPUSH
36223: CALL_OW 72
36227: NOT
36228: AND
36229: PUSH
36230: LD_EXP 76
36234: PUSH
36235: LD_VAR 0 2
36239: ARRAY
36240: PPUSH
36241: LD_INT 2
36243: PUSH
36244: LD_INT 30
36246: PUSH
36247: LD_INT 4
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 30
36256: PUSH
36257: LD_INT 5
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: LIST
36268: PPUSH
36269: CALL_OW 72
36273: NOT
36274: AND
36275: IFFALSE 36407
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36277: LD_ADDR_VAR 0 4
36281: PUSH
36282: LD_EXP 76
36286: PUSH
36287: LD_VAR 0 2
36291: ARRAY
36292: PPUSH
36293: LD_INT 2
36295: PUSH
36296: LD_INT 25
36298: PUSH
36299: LD_INT 1
36301: PUSH
36302: EMPTY
36303: LIST
36304: LIST
36305: PUSH
36306: LD_INT 25
36308: PUSH
36309: LD_INT 5
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 25
36318: PUSH
36319: LD_INT 8
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: PUSH
36326: LD_INT 25
36328: PUSH
36329: LD_INT 9
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: PPUSH
36343: CALL_OW 72
36347: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36348: LD_ADDR_VAR 0 4
36352: PUSH
36353: LD_VAR 0 4
36357: PUSH
36358: LD_VAR 0 4
36362: PPUSH
36363: LD_INT 18
36365: PPUSH
36366: CALL 90818 0 2
36370: DIFF
36371: ST_TO_ADDR
// if tmp then
36372: LD_VAR 0 4
36376: IFFALSE 36407
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36378: LD_VAR 0 2
36382: PPUSH
36383: LD_VAR 0 4
36387: PPUSH
36388: LD_EXP 101
36392: PUSH
36393: LD_VAR 0 2
36397: ARRAY
36398: PPUSH
36399: CALL 51957 0 3
// exit ;
36403: POP
36404: POP
36405: GO 36480
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36407: LD_EXP 99
36411: PUSH
36412: LD_VAR 0 2
36416: ARRAY
36417: PUSH
36418: LD_EXP 98
36422: PUSH
36423: LD_VAR 0 2
36427: ARRAY
36428: AND
36429: IFFALSE 36476
// begin tmp := mc_defender [ i ] ;
36431: LD_ADDR_VAR 0 4
36435: PUSH
36436: LD_EXP 98
36440: PUSH
36441: LD_VAR 0 2
36445: ARRAY
36446: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36447: LD_VAR 0 2
36451: PPUSH
36452: LD_VAR 0 4
36456: PPUSH
36457: LD_EXP 99
36461: PUSH
36462: LD_VAR 0 2
36466: ARRAY
36467: PPUSH
36468: CALL 52518 0 3
// exit ;
36472: POP
36473: POP
36474: GO 36480
// end ; end ;
36476: GO 35913
36478: POP
36479: POP
// end ;
36480: LD_VAR 0 1
36484: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36485: LD_INT 0
36487: PPUSH
36488: PPUSH
36489: PPUSH
36490: PPUSH
36491: PPUSH
36492: PPUSH
36493: PPUSH
36494: PPUSH
36495: PPUSH
36496: PPUSH
36497: PPUSH
// if not mc_bases then
36498: LD_EXP 76
36502: NOT
36503: IFFALSE 36507
// exit ;
36505: GO 37594
// for i = 1 to mc_bases do
36507: LD_ADDR_VAR 0 2
36511: PUSH
36512: DOUBLE
36513: LD_INT 1
36515: DEC
36516: ST_TO_ADDR
36517: LD_EXP 76
36521: PUSH
36522: FOR_TO
36523: IFFALSE 37592
// begin tmp := mc_lab [ i ] ;
36525: LD_ADDR_VAR 0 6
36529: PUSH
36530: LD_EXP 109
36534: PUSH
36535: LD_VAR 0 2
36539: ARRAY
36540: ST_TO_ADDR
// if not tmp then
36541: LD_VAR 0 6
36545: NOT
36546: IFFALSE 36550
// continue ;
36548: GO 36522
// idle_lab := 0 ;
36550: LD_ADDR_VAR 0 11
36554: PUSH
36555: LD_INT 0
36557: ST_TO_ADDR
// for j in tmp do
36558: LD_ADDR_VAR 0 3
36562: PUSH
36563: LD_VAR 0 6
36567: PUSH
36568: FOR_IN
36569: IFFALSE 37588
// begin researching := false ;
36571: LD_ADDR_VAR 0 10
36575: PUSH
36576: LD_INT 0
36578: ST_TO_ADDR
// side := GetSide ( j ) ;
36579: LD_ADDR_VAR 0 4
36583: PUSH
36584: LD_VAR 0 3
36588: PPUSH
36589: CALL_OW 255
36593: ST_TO_ADDR
// if not mc_tech [ side ] then
36594: LD_EXP 103
36598: PUSH
36599: LD_VAR 0 4
36603: ARRAY
36604: NOT
36605: IFFALSE 36609
// continue ;
36607: GO 36568
// if BuildingStatus ( j ) = bs_idle then
36609: LD_VAR 0 3
36613: PPUSH
36614: CALL_OW 461
36618: PUSH
36619: LD_INT 2
36621: EQUAL
36622: IFFALSE 36810
// begin if idle_lab and UnitsInside ( j ) < 6 then
36624: LD_VAR 0 11
36628: PUSH
36629: LD_VAR 0 3
36633: PPUSH
36634: CALL_OW 313
36638: PUSH
36639: LD_INT 6
36641: LESS
36642: AND
36643: IFFALSE 36714
// begin tmp2 := UnitsInside ( idle_lab ) ;
36645: LD_ADDR_VAR 0 9
36649: PUSH
36650: LD_VAR 0 11
36654: PPUSH
36655: CALL_OW 313
36659: ST_TO_ADDR
// if tmp2 then
36660: LD_VAR 0 9
36664: IFFALSE 36706
// for x in tmp2 do
36666: LD_ADDR_VAR 0 7
36670: PUSH
36671: LD_VAR 0 9
36675: PUSH
36676: FOR_IN
36677: IFFALSE 36704
// begin ComExitBuilding ( x ) ;
36679: LD_VAR 0 7
36683: PPUSH
36684: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36688: LD_VAR 0 7
36692: PPUSH
36693: LD_VAR 0 3
36697: PPUSH
36698: CALL_OW 180
// end ;
36702: GO 36676
36704: POP
36705: POP
// idle_lab := 0 ;
36706: LD_ADDR_VAR 0 11
36710: PUSH
36711: LD_INT 0
36713: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36714: LD_ADDR_VAR 0 5
36718: PUSH
36719: LD_EXP 103
36723: PUSH
36724: LD_VAR 0 4
36728: ARRAY
36729: PUSH
36730: FOR_IN
36731: IFFALSE 36791
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36733: LD_VAR 0 3
36737: PPUSH
36738: LD_VAR 0 5
36742: PPUSH
36743: CALL_OW 430
36747: PUSH
36748: LD_VAR 0 4
36752: PPUSH
36753: LD_VAR 0 5
36757: PPUSH
36758: CALL 51027 0 2
36762: AND
36763: IFFALSE 36789
// begin researching := true ;
36765: LD_ADDR_VAR 0 10
36769: PUSH
36770: LD_INT 1
36772: ST_TO_ADDR
// ComResearch ( j , t ) ;
36773: LD_VAR 0 3
36777: PPUSH
36778: LD_VAR 0 5
36782: PPUSH
36783: CALL_OW 124
// break ;
36787: GO 36791
// end ;
36789: GO 36730
36791: POP
36792: POP
// if not researching then
36793: LD_VAR 0 10
36797: NOT
36798: IFFALSE 36810
// idle_lab := j ;
36800: LD_ADDR_VAR 0 11
36804: PUSH
36805: LD_VAR 0 3
36809: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36810: LD_VAR 0 3
36814: PPUSH
36815: CALL_OW 461
36819: PUSH
36820: LD_INT 10
36822: EQUAL
36823: IFFALSE 37411
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36825: LD_EXP 105
36829: PUSH
36830: LD_VAR 0 2
36834: ARRAY
36835: NOT
36836: PUSH
36837: LD_EXP 106
36841: PUSH
36842: LD_VAR 0 2
36846: ARRAY
36847: NOT
36848: AND
36849: PUSH
36850: LD_EXP 103
36854: PUSH
36855: LD_VAR 0 4
36859: ARRAY
36860: PUSH
36861: LD_INT 1
36863: GREATER
36864: AND
36865: IFFALSE 36996
// begin ComCancel ( j ) ;
36867: LD_VAR 0 3
36871: PPUSH
36872: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36876: LD_ADDR_EXP 103
36880: PUSH
36881: LD_EXP 103
36885: PPUSH
36886: LD_VAR 0 4
36890: PPUSH
36891: LD_EXP 103
36895: PUSH
36896: LD_VAR 0 4
36900: ARRAY
36901: PPUSH
36902: LD_EXP 103
36906: PUSH
36907: LD_VAR 0 4
36911: ARRAY
36912: PUSH
36913: LD_INT 1
36915: MINUS
36916: PPUSH
36917: LD_EXP 103
36921: PUSH
36922: LD_VAR 0 4
36926: ARRAY
36927: PPUSH
36928: LD_INT 0
36930: PPUSH
36931: CALL 56950 0 4
36935: PPUSH
36936: CALL_OW 1
36940: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
36941: LD_ADDR_EXP 103
36945: PUSH
36946: LD_EXP 103
36950: PPUSH
36951: LD_VAR 0 4
36955: PPUSH
36956: LD_EXP 103
36960: PUSH
36961: LD_VAR 0 4
36965: ARRAY
36966: PPUSH
36967: LD_EXP 103
36971: PUSH
36972: LD_VAR 0 4
36976: ARRAY
36977: PPUSH
36978: LD_INT 1
36980: PPUSH
36981: LD_INT 0
36983: PPUSH
36984: CALL 56950 0 4
36988: PPUSH
36989: CALL_OW 1
36993: ST_TO_ADDR
// continue ;
36994: GO 36568
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
36996: LD_EXP 105
37000: PUSH
37001: LD_VAR 0 2
37005: ARRAY
37006: PUSH
37007: LD_EXP 106
37011: PUSH
37012: LD_VAR 0 2
37016: ARRAY
37017: NOT
37018: AND
37019: IFFALSE 37146
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37021: LD_ADDR_EXP 106
37025: PUSH
37026: LD_EXP 106
37030: PPUSH
37031: LD_VAR 0 2
37035: PUSH
37036: LD_EXP 106
37040: PUSH
37041: LD_VAR 0 2
37045: ARRAY
37046: PUSH
37047: LD_INT 1
37049: PLUS
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PPUSH
37055: LD_EXP 105
37059: PUSH
37060: LD_VAR 0 2
37064: ARRAY
37065: PUSH
37066: LD_INT 1
37068: ARRAY
37069: PPUSH
37070: CALL 57532 0 3
37074: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37075: LD_EXP 105
37079: PUSH
37080: LD_VAR 0 2
37084: ARRAY
37085: PUSH
37086: LD_INT 1
37088: ARRAY
37089: PPUSH
37090: LD_INT 112
37092: PPUSH
37093: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37097: LD_ADDR_VAR 0 9
37101: PUSH
37102: LD_EXP 105
37106: PUSH
37107: LD_VAR 0 2
37111: ARRAY
37112: PPUSH
37113: LD_INT 1
37115: PPUSH
37116: CALL_OW 3
37120: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37121: LD_ADDR_EXP 105
37125: PUSH
37126: LD_EXP 105
37130: PPUSH
37131: LD_VAR 0 2
37135: PPUSH
37136: LD_VAR 0 9
37140: PPUSH
37141: CALL_OW 1
37145: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37146: LD_EXP 105
37150: PUSH
37151: LD_VAR 0 2
37155: ARRAY
37156: PUSH
37157: LD_EXP 106
37161: PUSH
37162: LD_VAR 0 2
37166: ARRAY
37167: AND
37168: PUSH
37169: LD_EXP 106
37173: PUSH
37174: LD_VAR 0 2
37178: ARRAY
37179: PUSH
37180: LD_INT 1
37182: ARRAY
37183: PPUSH
37184: CALL_OW 310
37188: NOT
37189: AND
37190: PUSH
37191: LD_VAR 0 3
37195: PPUSH
37196: CALL_OW 313
37200: PUSH
37201: LD_INT 6
37203: EQUAL
37204: AND
37205: IFFALSE 37261
// begin tmp2 := UnitsInside ( j ) ;
37207: LD_ADDR_VAR 0 9
37211: PUSH
37212: LD_VAR 0 3
37216: PPUSH
37217: CALL_OW 313
37221: ST_TO_ADDR
// if tmp2 = 6 then
37222: LD_VAR 0 9
37226: PUSH
37227: LD_INT 6
37229: EQUAL
37230: IFFALSE 37261
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37232: LD_VAR 0 9
37236: PUSH
37237: LD_INT 1
37239: ARRAY
37240: PPUSH
37241: LD_INT 112
37243: PPUSH
37244: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37248: LD_VAR 0 9
37252: PUSH
37253: LD_INT 1
37255: ARRAY
37256: PPUSH
37257: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37261: LD_EXP 106
37265: PUSH
37266: LD_VAR 0 2
37270: ARRAY
37271: PUSH
37272: LD_EXP 106
37276: PUSH
37277: LD_VAR 0 2
37281: ARRAY
37282: PUSH
37283: LD_INT 1
37285: ARRAY
37286: PPUSH
37287: CALL_OW 314
37291: NOT
37292: AND
37293: PUSH
37294: LD_EXP 106
37298: PUSH
37299: LD_VAR 0 2
37303: ARRAY
37304: PUSH
37305: LD_INT 1
37307: ARRAY
37308: PPUSH
37309: CALL_OW 310
37313: NOT
37314: AND
37315: IFFALSE 37341
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37317: LD_EXP 106
37321: PUSH
37322: LD_VAR 0 2
37326: ARRAY
37327: PUSH
37328: LD_INT 1
37330: ARRAY
37331: PPUSH
37332: LD_VAR 0 3
37336: PPUSH
37337: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37341: LD_EXP 106
37345: PUSH
37346: LD_VAR 0 2
37350: ARRAY
37351: PUSH
37352: LD_INT 1
37354: ARRAY
37355: PPUSH
37356: CALL_OW 310
37360: PUSH
37361: LD_EXP 106
37365: PUSH
37366: LD_VAR 0 2
37370: ARRAY
37371: PUSH
37372: LD_INT 1
37374: ARRAY
37375: PPUSH
37376: CALL_OW 310
37380: PPUSH
37381: CALL_OW 461
37385: PUSH
37386: LD_INT 3
37388: NONEQUAL
37389: AND
37390: IFFALSE 37411
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37392: LD_EXP 106
37396: PUSH
37397: LD_VAR 0 2
37401: ARRAY
37402: PUSH
37403: LD_INT 1
37405: ARRAY
37406: PPUSH
37407: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37411: LD_VAR 0 3
37415: PPUSH
37416: CALL_OW 461
37420: PUSH
37421: LD_INT 6
37423: EQUAL
37424: PUSH
37425: LD_VAR 0 6
37429: PUSH
37430: LD_INT 1
37432: GREATER
37433: AND
37434: IFFALSE 37586
// begin sci := [ ] ;
37436: LD_ADDR_VAR 0 8
37440: PUSH
37441: EMPTY
37442: ST_TO_ADDR
// for x in ( tmp diff j ) do
37443: LD_ADDR_VAR 0 7
37447: PUSH
37448: LD_VAR 0 6
37452: PUSH
37453: LD_VAR 0 3
37457: DIFF
37458: PUSH
37459: FOR_IN
37460: IFFALSE 37512
// begin if sci = 6 then
37462: LD_VAR 0 8
37466: PUSH
37467: LD_INT 6
37469: EQUAL
37470: IFFALSE 37474
// break ;
37472: GO 37512
// if BuildingStatus ( x ) = bs_idle then
37474: LD_VAR 0 7
37478: PPUSH
37479: CALL_OW 461
37483: PUSH
37484: LD_INT 2
37486: EQUAL
37487: IFFALSE 37510
// sci := sci ^ UnitsInside ( x ) ;
37489: LD_ADDR_VAR 0 8
37493: PUSH
37494: LD_VAR 0 8
37498: PUSH
37499: LD_VAR 0 7
37503: PPUSH
37504: CALL_OW 313
37508: ADD
37509: ST_TO_ADDR
// end ;
37510: GO 37459
37512: POP
37513: POP
// if not sci then
37514: LD_VAR 0 8
37518: NOT
37519: IFFALSE 37523
// continue ;
37521: GO 36568
// for x in sci do
37523: LD_ADDR_VAR 0 7
37527: PUSH
37528: LD_VAR 0 8
37532: PUSH
37533: FOR_IN
37534: IFFALSE 37584
// if IsInUnit ( x ) and not HasTask ( x ) then
37536: LD_VAR 0 7
37540: PPUSH
37541: CALL_OW 310
37545: PUSH
37546: LD_VAR 0 7
37550: PPUSH
37551: CALL_OW 314
37555: NOT
37556: AND
37557: IFFALSE 37582
// begin ComExitBuilding ( x ) ;
37559: LD_VAR 0 7
37563: PPUSH
37564: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37568: LD_VAR 0 7
37572: PPUSH
37573: LD_VAR 0 3
37577: PPUSH
37578: CALL_OW 180
// end ;
37582: GO 37533
37584: POP
37585: POP
// end ; end ;
37586: GO 36568
37588: POP
37589: POP
// end ;
37590: GO 36522
37592: POP
37593: POP
// end ;
37594: LD_VAR 0 1
37598: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37599: LD_INT 0
37601: PPUSH
37602: PPUSH
// if not mc_bases then
37603: LD_EXP 76
37607: NOT
37608: IFFALSE 37612
// exit ;
37610: GO 37693
// for i = 1 to mc_bases do
37612: LD_ADDR_VAR 0 2
37616: PUSH
37617: DOUBLE
37618: LD_INT 1
37620: DEC
37621: ST_TO_ADDR
37622: LD_EXP 76
37626: PUSH
37627: FOR_TO
37628: IFFALSE 37691
// if mc_mines [ i ] and mc_miners [ i ] then
37630: LD_EXP 89
37634: PUSH
37635: LD_VAR 0 2
37639: ARRAY
37640: PUSH
37641: LD_EXP 90
37645: PUSH
37646: LD_VAR 0 2
37650: ARRAY
37651: AND
37652: IFFALSE 37689
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37654: LD_EXP 90
37658: PUSH
37659: LD_VAR 0 2
37663: ARRAY
37664: PUSH
37665: LD_INT 1
37667: ARRAY
37668: PPUSH
37669: CALL_OW 255
37673: PPUSH
37674: LD_EXP 89
37678: PUSH
37679: LD_VAR 0 2
37683: ARRAY
37684: PPUSH
37685: CALL 54521 0 2
37689: GO 37627
37691: POP
37692: POP
// end ;
37693: LD_VAR 0 1
37697: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37698: LD_INT 0
37700: PPUSH
37701: PPUSH
37702: PPUSH
37703: PPUSH
37704: PPUSH
37705: PPUSH
37706: PPUSH
37707: PPUSH
// if not mc_bases or not mc_parking then
37708: LD_EXP 76
37712: NOT
37713: PUSH
37714: LD_EXP 100
37718: NOT
37719: OR
37720: IFFALSE 37724
// exit ;
37722: GO 38423
// for i = 1 to mc_bases do
37724: LD_ADDR_VAR 0 2
37728: PUSH
37729: DOUBLE
37730: LD_INT 1
37732: DEC
37733: ST_TO_ADDR
37734: LD_EXP 76
37738: PUSH
37739: FOR_TO
37740: IFFALSE 38421
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37742: LD_EXP 76
37746: PUSH
37747: LD_VAR 0 2
37751: ARRAY
37752: NOT
37753: PUSH
37754: LD_EXP 100
37758: PUSH
37759: LD_VAR 0 2
37763: ARRAY
37764: NOT
37765: OR
37766: IFFALSE 37770
// continue ;
37768: GO 37739
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37770: LD_ADDR_VAR 0 5
37774: PUSH
37775: LD_EXP 76
37779: PUSH
37780: LD_VAR 0 2
37784: ARRAY
37785: PUSH
37786: LD_INT 1
37788: ARRAY
37789: PPUSH
37790: CALL_OW 255
37794: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37795: LD_ADDR_VAR 0 6
37799: PUSH
37800: LD_EXP 76
37804: PUSH
37805: LD_VAR 0 2
37809: ARRAY
37810: PPUSH
37811: LD_INT 30
37813: PUSH
37814: LD_INT 3
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PPUSH
37821: CALL_OW 72
37825: ST_TO_ADDR
// if not fac then
37826: LD_VAR 0 6
37830: NOT
37831: IFFALSE 37882
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37833: LD_ADDR_VAR 0 6
37837: PUSH
37838: LD_EXP 76
37842: PUSH
37843: LD_VAR 0 2
37847: ARRAY
37848: PPUSH
37849: LD_INT 2
37851: PUSH
37852: LD_INT 30
37854: PUSH
37855: LD_INT 0
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: LD_INT 30
37864: PUSH
37865: LD_INT 1
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: LIST
37876: PPUSH
37877: CALL_OW 72
37881: ST_TO_ADDR
// if not fac then
37882: LD_VAR 0 6
37886: NOT
37887: IFFALSE 37891
// continue ;
37889: GO 37739
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37891: LD_ADDR_VAR 0 7
37895: PUSH
37896: LD_EXP 100
37900: PUSH
37901: LD_VAR 0 2
37905: ARRAY
37906: PPUSH
37907: LD_INT 22
37909: PUSH
37910: LD_VAR 0 5
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 21
37921: PUSH
37922: LD_INT 2
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 3
37931: PUSH
37932: LD_INT 24
37934: PUSH
37935: LD_INT 1000
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: LIST
37950: PPUSH
37951: CALL_OW 70
37955: ST_TO_ADDR
// for j in fac do
37956: LD_ADDR_VAR 0 3
37960: PUSH
37961: LD_VAR 0 6
37965: PUSH
37966: FOR_IN
37967: IFFALSE 38048
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37969: LD_ADDR_VAR 0 7
37973: PUSH
37974: LD_VAR 0 7
37978: PUSH
37979: LD_INT 22
37981: PUSH
37982: LD_VAR 0 5
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: PUSH
37991: LD_INT 91
37993: PUSH
37994: LD_VAR 0 3
37998: PUSH
37999: LD_INT 15
38001: PUSH
38002: EMPTY
38003: LIST
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 21
38009: PUSH
38010: LD_INT 2
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PUSH
38017: LD_INT 3
38019: PUSH
38020: LD_INT 24
38022: PUSH
38023: LD_INT 1000
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: PPUSH
38040: CALL_OW 69
38044: UNION
38045: ST_TO_ADDR
38046: GO 37966
38048: POP
38049: POP
// if not vehs then
38050: LD_VAR 0 7
38054: NOT
38055: IFFALSE 38081
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38057: LD_ADDR_EXP 88
38061: PUSH
38062: LD_EXP 88
38066: PPUSH
38067: LD_VAR 0 2
38071: PPUSH
38072: EMPTY
38073: PPUSH
38074: CALL_OW 1
38078: ST_TO_ADDR
// continue ;
38079: GO 37739
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38081: LD_ADDR_VAR 0 8
38085: PUSH
38086: LD_EXP 76
38090: PUSH
38091: LD_VAR 0 2
38095: ARRAY
38096: PPUSH
38097: LD_INT 30
38099: PUSH
38100: LD_INT 3
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PPUSH
38107: CALL_OW 72
38111: ST_TO_ADDR
// if tmp then
38112: LD_VAR 0 8
38116: IFFALSE 38219
// begin for j in tmp do
38118: LD_ADDR_VAR 0 3
38122: PUSH
38123: LD_VAR 0 8
38127: PUSH
38128: FOR_IN
38129: IFFALSE 38217
// for k in UnitsInside ( j ) do
38131: LD_ADDR_VAR 0 4
38135: PUSH
38136: LD_VAR 0 3
38140: PPUSH
38141: CALL_OW 313
38145: PUSH
38146: FOR_IN
38147: IFFALSE 38213
// if k then
38149: LD_VAR 0 4
38153: IFFALSE 38211
// if not k in mc_repair_vehicle [ i ] then
38155: LD_VAR 0 4
38159: PUSH
38160: LD_EXP 88
38164: PUSH
38165: LD_VAR 0 2
38169: ARRAY
38170: IN
38171: NOT
38172: IFFALSE 38211
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38174: LD_ADDR_EXP 88
38178: PUSH
38179: LD_EXP 88
38183: PPUSH
38184: LD_VAR 0 2
38188: PPUSH
38189: LD_EXP 88
38193: PUSH
38194: LD_VAR 0 2
38198: ARRAY
38199: PUSH
38200: LD_VAR 0 4
38204: UNION
38205: PPUSH
38206: CALL_OW 1
38210: ST_TO_ADDR
38211: GO 38146
38213: POP
38214: POP
38215: GO 38128
38217: POP
38218: POP
// end ; if not mc_repair_vehicle [ i ] then
38219: LD_EXP 88
38223: PUSH
38224: LD_VAR 0 2
38228: ARRAY
38229: NOT
38230: IFFALSE 38234
// continue ;
38232: GO 37739
// for j in mc_repair_vehicle [ i ] do
38234: LD_ADDR_VAR 0 3
38238: PUSH
38239: LD_EXP 88
38243: PUSH
38244: LD_VAR 0 2
38248: ARRAY
38249: PUSH
38250: FOR_IN
38251: IFFALSE 38417
// begin if GetClass ( j ) <> 3 then
38253: LD_VAR 0 3
38257: PPUSH
38258: CALL_OW 257
38262: PUSH
38263: LD_INT 3
38265: NONEQUAL
38266: IFFALSE 38307
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38268: LD_ADDR_EXP 88
38272: PUSH
38273: LD_EXP 88
38277: PPUSH
38278: LD_VAR 0 2
38282: PPUSH
38283: LD_EXP 88
38287: PUSH
38288: LD_VAR 0 2
38292: ARRAY
38293: PUSH
38294: LD_VAR 0 3
38298: DIFF
38299: PPUSH
38300: CALL_OW 1
38304: ST_TO_ADDR
// continue ;
38305: GO 38250
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38307: LD_VAR 0 3
38311: PPUSH
38312: CALL_OW 311
38316: NOT
38317: PUSH
38318: LD_VAR 0 3
38322: PUSH
38323: LD_EXP 79
38327: PUSH
38328: LD_VAR 0 2
38332: ARRAY
38333: PUSH
38334: LD_INT 1
38336: ARRAY
38337: IN
38338: NOT
38339: AND
38340: PUSH
38341: LD_VAR 0 3
38345: PUSH
38346: LD_EXP 79
38350: PUSH
38351: LD_VAR 0 2
38355: ARRAY
38356: PUSH
38357: LD_INT 2
38359: ARRAY
38360: IN
38361: NOT
38362: AND
38363: IFFALSE 38415
// begin if IsInUnit ( j ) then
38365: LD_VAR 0 3
38369: PPUSH
38370: CALL_OW 310
38374: IFFALSE 38385
// ComExitBuilding ( j ) ;
38376: LD_VAR 0 3
38380: PPUSH
38381: CALL_OW 122
// if not HasTask ( j ) then
38385: LD_VAR 0 3
38389: PPUSH
38390: CALL_OW 314
38394: NOT
38395: IFFALSE 38415
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38397: LD_VAR 0 3
38401: PPUSH
38402: LD_VAR 0 7
38406: PUSH
38407: LD_INT 1
38409: ARRAY
38410: PPUSH
38411: CALL_OW 189
// end ; end ;
38415: GO 38250
38417: POP
38418: POP
// end ;
38419: GO 37739
38421: POP
38422: POP
// end ;
38423: LD_VAR 0 1
38427: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38428: LD_INT 0
38430: PPUSH
38431: PPUSH
38432: PPUSH
38433: PPUSH
38434: PPUSH
38435: PPUSH
38436: PPUSH
38437: PPUSH
38438: PPUSH
38439: PPUSH
38440: PPUSH
// if not mc_bases then
38441: LD_EXP 76
38445: NOT
38446: IFFALSE 38450
// exit ;
38448: GO 39252
// for i = 1 to mc_bases do
38450: LD_ADDR_VAR 0 2
38454: PUSH
38455: DOUBLE
38456: LD_INT 1
38458: DEC
38459: ST_TO_ADDR
38460: LD_EXP 76
38464: PUSH
38465: FOR_TO
38466: IFFALSE 39250
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38468: LD_EXP 104
38472: PUSH
38473: LD_VAR 0 2
38477: ARRAY
38478: NOT
38479: PUSH
38480: LD_EXP 79
38484: PUSH
38485: LD_VAR 0 2
38489: ARRAY
38490: PUSH
38491: LD_INT 1
38493: ARRAY
38494: OR
38495: PUSH
38496: LD_EXP 79
38500: PUSH
38501: LD_VAR 0 2
38505: ARRAY
38506: PUSH
38507: LD_INT 2
38509: ARRAY
38510: OR
38511: PUSH
38512: LD_EXP 102
38516: PUSH
38517: LD_VAR 0 2
38521: ARRAY
38522: PPUSH
38523: LD_INT 1
38525: PPUSH
38526: CALL_OW 325
38530: NOT
38531: OR
38532: PUSH
38533: LD_EXP 99
38537: PUSH
38538: LD_VAR 0 2
38542: ARRAY
38543: OR
38544: IFFALSE 38548
// continue ;
38546: GO 38465
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38548: LD_ADDR_VAR 0 8
38552: PUSH
38553: LD_EXP 76
38557: PUSH
38558: LD_VAR 0 2
38562: ARRAY
38563: PPUSH
38564: LD_INT 25
38566: PUSH
38567: LD_INT 4
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: LD_INT 50
38576: PUSH
38577: EMPTY
38578: LIST
38579: PUSH
38580: LD_INT 3
38582: PUSH
38583: LD_INT 60
38585: PUSH
38586: EMPTY
38587: LIST
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: LIST
38597: PPUSH
38598: CALL_OW 72
38602: PUSH
38603: LD_EXP 80
38607: PUSH
38608: LD_VAR 0 2
38612: ARRAY
38613: DIFF
38614: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38615: LD_ADDR_VAR 0 9
38619: PUSH
38620: LD_EXP 76
38624: PUSH
38625: LD_VAR 0 2
38629: ARRAY
38630: PPUSH
38631: LD_INT 2
38633: PUSH
38634: LD_INT 30
38636: PUSH
38637: LD_INT 0
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: LD_INT 30
38646: PUSH
38647: LD_INT 1
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: LIST
38658: PPUSH
38659: CALL_OW 72
38663: ST_TO_ADDR
// if not tmp or not dep then
38664: LD_VAR 0 8
38668: NOT
38669: PUSH
38670: LD_VAR 0 9
38674: NOT
38675: OR
38676: IFFALSE 38680
// continue ;
38678: GO 38465
// side := GetSide ( tmp [ 1 ] ) ;
38680: LD_ADDR_VAR 0 11
38684: PUSH
38685: LD_VAR 0 8
38689: PUSH
38690: LD_INT 1
38692: ARRAY
38693: PPUSH
38694: CALL_OW 255
38698: ST_TO_ADDR
// dep := dep [ 1 ] ;
38699: LD_ADDR_VAR 0 9
38703: PUSH
38704: LD_VAR 0 9
38708: PUSH
38709: LD_INT 1
38711: ARRAY
38712: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38713: LD_ADDR_VAR 0 7
38717: PUSH
38718: LD_EXP 104
38722: PUSH
38723: LD_VAR 0 2
38727: ARRAY
38728: PPUSH
38729: LD_INT 22
38731: PUSH
38732: LD_INT 0
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 25
38741: PUSH
38742: LD_INT 12
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: PPUSH
38753: CALL_OW 70
38757: PUSH
38758: LD_INT 22
38760: PUSH
38761: LD_INT 0
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 25
38770: PUSH
38771: LD_INT 12
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 91
38780: PUSH
38781: LD_VAR 0 9
38785: PUSH
38786: LD_INT 20
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: LIST
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: LIST
38798: PPUSH
38799: CALL_OW 69
38803: UNION
38804: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38805: LD_ADDR_VAR 0 10
38809: PUSH
38810: LD_EXP 104
38814: PUSH
38815: LD_VAR 0 2
38819: ARRAY
38820: PPUSH
38821: LD_INT 81
38823: PUSH
38824: LD_VAR 0 11
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PPUSH
38833: CALL_OW 70
38837: ST_TO_ADDR
// if not apes or danger_at_area then
38838: LD_VAR 0 7
38842: NOT
38843: PUSH
38844: LD_VAR 0 10
38848: OR
38849: IFFALSE 38899
// begin if mc_taming [ i ] then
38851: LD_EXP 107
38855: PUSH
38856: LD_VAR 0 2
38860: ARRAY
38861: IFFALSE 38897
// begin MC_Reset ( i , 121 ) ;
38863: LD_VAR 0 2
38867: PPUSH
38868: LD_INT 121
38870: PPUSH
38871: CALL 24334 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38875: LD_ADDR_EXP 107
38879: PUSH
38880: LD_EXP 107
38884: PPUSH
38885: LD_VAR 0 2
38889: PPUSH
38890: EMPTY
38891: PPUSH
38892: CALL_OW 1
38896: ST_TO_ADDR
// end ; continue ;
38897: GO 38465
// end ; for j in tmp do
38899: LD_ADDR_VAR 0 3
38903: PUSH
38904: LD_VAR 0 8
38908: PUSH
38909: FOR_IN
38910: IFFALSE 39246
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
38912: LD_VAR 0 3
38916: PUSH
38917: LD_EXP 107
38921: PUSH
38922: LD_VAR 0 2
38926: ARRAY
38927: IN
38928: NOT
38929: PUSH
38930: LD_EXP 107
38934: PUSH
38935: LD_VAR 0 2
38939: ARRAY
38940: PUSH
38941: LD_INT 3
38943: LESS
38944: AND
38945: IFFALSE 39003
// begin SetTag ( j , 121 ) ;
38947: LD_VAR 0 3
38951: PPUSH
38952: LD_INT 121
38954: PPUSH
38955: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
38959: LD_ADDR_EXP 107
38963: PUSH
38964: LD_EXP 107
38968: PPUSH
38969: LD_VAR 0 2
38973: PUSH
38974: LD_EXP 107
38978: PUSH
38979: LD_VAR 0 2
38983: ARRAY
38984: PUSH
38985: LD_INT 1
38987: PLUS
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PPUSH
38993: LD_VAR 0 3
38997: PPUSH
38998: CALL 57532 0 3
39002: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39003: LD_VAR 0 3
39007: PUSH
39008: LD_EXP 107
39012: PUSH
39013: LD_VAR 0 2
39017: ARRAY
39018: IN
39019: IFFALSE 39244
// begin if GetClass ( j ) <> 4 then
39021: LD_VAR 0 3
39025: PPUSH
39026: CALL_OW 257
39030: PUSH
39031: LD_INT 4
39033: NONEQUAL
39034: IFFALSE 39087
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39036: LD_ADDR_EXP 107
39040: PUSH
39041: LD_EXP 107
39045: PPUSH
39046: LD_VAR 0 2
39050: PPUSH
39051: LD_EXP 107
39055: PUSH
39056: LD_VAR 0 2
39060: ARRAY
39061: PUSH
39062: LD_VAR 0 3
39066: DIFF
39067: PPUSH
39068: CALL_OW 1
39072: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39073: LD_VAR 0 3
39077: PPUSH
39078: LD_INT 0
39080: PPUSH
39081: CALL_OW 109
// continue ;
39085: GO 38909
// end ; if IsInUnit ( j ) then
39087: LD_VAR 0 3
39091: PPUSH
39092: CALL_OW 310
39096: IFFALSE 39107
// ComExitBuilding ( j ) ;
39098: LD_VAR 0 3
39102: PPUSH
39103: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39107: LD_ADDR_VAR 0 6
39111: PUSH
39112: LD_VAR 0 7
39116: PPUSH
39117: LD_VAR 0 3
39121: PPUSH
39122: CALL_OW 74
39126: ST_TO_ADDR
// if not ape then
39127: LD_VAR 0 6
39131: NOT
39132: IFFALSE 39136
// break ;
39134: GO 39246
// x := GetX ( ape ) ;
39136: LD_ADDR_VAR 0 4
39140: PUSH
39141: LD_VAR 0 6
39145: PPUSH
39146: CALL_OW 250
39150: ST_TO_ADDR
// y := GetY ( ape ) ;
39151: LD_ADDR_VAR 0 5
39155: PUSH
39156: LD_VAR 0 6
39160: PPUSH
39161: CALL_OW 251
39165: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39166: LD_VAR 0 4
39170: PPUSH
39171: LD_VAR 0 5
39175: PPUSH
39176: CALL_OW 488
39180: NOT
39181: PUSH
39182: LD_VAR 0 11
39186: PPUSH
39187: LD_VAR 0 4
39191: PPUSH
39192: LD_VAR 0 5
39196: PPUSH
39197: LD_INT 20
39199: PPUSH
39200: CALL 58428 0 4
39204: PUSH
39205: LD_INT 4
39207: ARRAY
39208: OR
39209: IFFALSE 39213
// break ;
39211: GO 39246
// if not HasTask ( j ) then
39213: LD_VAR 0 3
39217: PPUSH
39218: CALL_OW 314
39222: NOT
39223: IFFALSE 39244
// ComTameXY ( j , x , y ) ;
39225: LD_VAR 0 3
39229: PPUSH
39230: LD_VAR 0 4
39234: PPUSH
39235: LD_VAR 0 5
39239: PPUSH
39240: CALL_OW 131
// end ; end ;
39244: GO 38909
39246: POP
39247: POP
// end ;
39248: GO 38465
39250: POP
39251: POP
// end ;
39252: LD_VAR 0 1
39256: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39257: LD_INT 0
39259: PPUSH
39260: PPUSH
39261: PPUSH
39262: PPUSH
39263: PPUSH
39264: PPUSH
39265: PPUSH
39266: PPUSH
// if not mc_bases then
39267: LD_EXP 76
39271: NOT
39272: IFFALSE 39276
// exit ;
39274: GO 39902
// for i = 1 to mc_bases do
39276: LD_ADDR_VAR 0 2
39280: PUSH
39281: DOUBLE
39282: LD_INT 1
39284: DEC
39285: ST_TO_ADDR
39286: LD_EXP 76
39290: PUSH
39291: FOR_TO
39292: IFFALSE 39900
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39294: LD_EXP 105
39298: PUSH
39299: LD_VAR 0 2
39303: ARRAY
39304: NOT
39305: PUSH
39306: LD_EXP 105
39310: PUSH
39311: LD_VAR 0 2
39315: ARRAY
39316: PPUSH
39317: LD_INT 25
39319: PUSH
39320: LD_INT 12
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: PPUSH
39327: CALL_OW 72
39331: NOT
39332: OR
39333: IFFALSE 39337
// continue ;
39335: GO 39291
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39337: LD_ADDR_VAR 0 5
39341: PUSH
39342: LD_EXP 105
39346: PUSH
39347: LD_VAR 0 2
39351: ARRAY
39352: PUSH
39353: LD_INT 1
39355: ARRAY
39356: PPUSH
39357: CALL_OW 255
39361: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39362: LD_VAR 0 5
39366: PPUSH
39367: LD_INT 2
39369: PPUSH
39370: CALL_OW 325
39374: IFFALSE 39627
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39376: LD_ADDR_VAR 0 4
39380: PUSH
39381: LD_EXP 105
39385: PUSH
39386: LD_VAR 0 2
39390: ARRAY
39391: PPUSH
39392: LD_INT 25
39394: PUSH
39395: LD_INT 16
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PPUSH
39402: CALL_OW 72
39406: ST_TO_ADDR
// if tmp < 6 then
39407: LD_VAR 0 4
39411: PUSH
39412: LD_INT 6
39414: LESS
39415: IFFALSE 39627
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39417: LD_ADDR_VAR 0 6
39421: PUSH
39422: LD_EXP 76
39426: PUSH
39427: LD_VAR 0 2
39431: ARRAY
39432: PPUSH
39433: LD_INT 2
39435: PUSH
39436: LD_INT 30
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: PUSH
39446: LD_INT 30
39448: PUSH
39449: LD_INT 1
39451: PUSH
39452: EMPTY
39453: LIST
39454: LIST
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: LIST
39460: PPUSH
39461: CALL_OW 72
39465: ST_TO_ADDR
// if depot then
39466: LD_VAR 0 6
39470: IFFALSE 39627
// begin selected := 0 ;
39472: LD_ADDR_VAR 0 7
39476: PUSH
39477: LD_INT 0
39479: ST_TO_ADDR
// for j in depot do
39480: LD_ADDR_VAR 0 3
39484: PUSH
39485: LD_VAR 0 6
39489: PUSH
39490: FOR_IN
39491: IFFALSE 39522
// begin if UnitsInside ( j ) < 6 then
39493: LD_VAR 0 3
39497: PPUSH
39498: CALL_OW 313
39502: PUSH
39503: LD_INT 6
39505: LESS
39506: IFFALSE 39520
// begin selected := j ;
39508: LD_ADDR_VAR 0 7
39512: PUSH
39513: LD_VAR 0 3
39517: ST_TO_ADDR
// break ;
39518: GO 39522
// end ; end ;
39520: GO 39490
39522: POP
39523: POP
// if selected then
39524: LD_VAR 0 7
39528: IFFALSE 39627
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39530: LD_ADDR_VAR 0 3
39534: PUSH
39535: LD_EXP 105
39539: PUSH
39540: LD_VAR 0 2
39544: ARRAY
39545: PPUSH
39546: LD_INT 25
39548: PUSH
39549: LD_INT 12
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PPUSH
39556: CALL_OW 72
39560: PUSH
39561: FOR_IN
39562: IFFALSE 39625
// if not HasTask ( j ) then
39564: LD_VAR 0 3
39568: PPUSH
39569: CALL_OW 314
39573: NOT
39574: IFFALSE 39623
// begin if not IsInUnit ( j ) then
39576: LD_VAR 0 3
39580: PPUSH
39581: CALL_OW 310
39585: NOT
39586: IFFALSE 39602
// ComEnterUnit ( j , selected ) ;
39588: LD_VAR 0 3
39592: PPUSH
39593: LD_VAR 0 7
39597: PPUSH
39598: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39602: LD_VAR 0 3
39606: PPUSH
39607: LD_INT 16
39609: PPUSH
39610: CALL_OW 183
// AddComExitBuilding ( j ) ;
39614: LD_VAR 0 3
39618: PPUSH
39619: CALL_OW 182
// end ;
39623: GO 39561
39625: POP
39626: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39627: LD_VAR 0 5
39631: PPUSH
39632: LD_INT 11
39634: PPUSH
39635: CALL_OW 325
39639: IFFALSE 39898
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39641: LD_ADDR_VAR 0 4
39645: PUSH
39646: LD_EXP 105
39650: PUSH
39651: LD_VAR 0 2
39655: ARRAY
39656: PPUSH
39657: LD_INT 25
39659: PUSH
39660: LD_INT 16
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PPUSH
39667: CALL_OW 72
39671: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39672: LD_VAR 0 4
39676: PUSH
39677: LD_INT 6
39679: GREATEREQUAL
39680: PUSH
39681: LD_VAR 0 5
39685: PPUSH
39686: LD_INT 2
39688: PPUSH
39689: CALL_OW 325
39693: NOT
39694: OR
39695: IFFALSE 39898
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39697: LD_ADDR_VAR 0 8
39701: PUSH
39702: LD_EXP 76
39706: PUSH
39707: LD_VAR 0 2
39711: ARRAY
39712: PPUSH
39713: LD_INT 2
39715: PUSH
39716: LD_INT 30
39718: PUSH
39719: LD_INT 4
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 30
39728: PUSH
39729: LD_INT 5
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: LIST
39740: PPUSH
39741: CALL_OW 72
39745: ST_TO_ADDR
// if barracks then
39746: LD_VAR 0 8
39750: IFFALSE 39898
// begin selected := 0 ;
39752: LD_ADDR_VAR 0 7
39756: PUSH
39757: LD_INT 0
39759: ST_TO_ADDR
// for j in barracks do
39760: LD_ADDR_VAR 0 3
39764: PUSH
39765: LD_VAR 0 8
39769: PUSH
39770: FOR_IN
39771: IFFALSE 39802
// begin if UnitsInside ( j ) < 6 then
39773: LD_VAR 0 3
39777: PPUSH
39778: CALL_OW 313
39782: PUSH
39783: LD_INT 6
39785: LESS
39786: IFFALSE 39800
// begin selected := j ;
39788: LD_ADDR_VAR 0 7
39792: PUSH
39793: LD_VAR 0 3
39797: ST_TO_ADDR
// break ;
39798: GO 39802
// end ; end ;
39800: GO 39770
39802: POP
39803: POP
// if selected then
39804: LD_VAR 0 7
39808: IFFALSE 39898
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39810: LD_ADDR_VAR 0 3
39814: PUSH
39815: LD_EXP 105
39819: PUSH
39820: LD_VAR 0 2
39824: ARRAY
39825: PPUSH
39826: LD_INT 25
39828: PUSH
39829: LD_INT 12
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PPUSH
39836: CALL_OW 72
39840: PUSH
39841: FOR_IN
39842: IFFALSE 39896
// if not IsInUnit ( j ) and not HasTask ( j ) then
39844: LD_VAR 0 3
39848: PPUSH
39849: CALL_OW 310
39853: NOT
39854: PUSH
39855: LD_VAR 0 3
39859: PPUSH
39860: CALL_OW 314
39864: NOT
39865: AND
39866: IFFALSE 39894
// begin ComEnterUnit ( j , selected ) ;
39868: LD_VAR 0 3
39872: PPUSH
39873: LD_VAR 0 7
39877: PPUSH
39878: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39882: LD_VAR 0 3
39886: PPUSH
39887: LD_INT 15
39889: PPUSH
39890: CALL_OW 183
// end ;
39894: GO 39841
39896: POP
39897: POP
// end ; end ; end ; end ; end ;
39898: GO 39291
39900: POP
39901: POP
// end ;
39902: LD_VAR 0 1
39906: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
39907: LD_INT 0
39909: PPUSH
39910: PPUSH
39911: PPUSH
39912: PPUSH
// if not mc_bases then
39913: LD_EXP 76
39917: NOT
39918: IFFALSE 39922
// exit ;
39920: GO 40100
// for i = 1 to mc_bases do
39922: LD_ADDR_VAR 0 2
39926: PUSH
39927: DOUBLE
39928: LD_INT 1
39930: DEC
39931: ST_TO_ADDR
39932: LD_EXP 76
39936: PUSH
39937: FOR_TO
39938: IFFALSE 40098
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
39940: LD_ADDR_VAR 0 4
39944: PUSH
39945: LD_EXP 76
39949: PUSH
39950: LD_VAR 0 2
39954: ARRAY
39955: PPUSH
39956: LD_INT 25
39958: PUSH
39959: LD_INT 9
39961: PUSH
39962: EMPTY
39963: LIST
39964: LIST
39965: PPUSH
39966: CALL_OW 72
39970: ST_TO_ADDR
// if not tmp then
39971: LD_VAR 0 4
39975: NOT
39976: IFFALSE 39980
// continue ;
39978: GO 39937
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
39980: LD_EXP 102
39984: PUSH
39985: LD_VAR 0 2
39989: ARRAY
39990: PPUSH
39991: LD_INT 29
39993: PPUSH
39994: CALL_OW 325
39998: NOT
39999: PUSH
40000: LD_EXP 102
40004: PUSH
40005: LD_VAR 0 2
40009: ARRAY
40010: PPUSH
40011: LD_INT 28
40013: PPUSH
40014: CALL_OW 325
40018: NOT
40019: AND
40020: IFFALSE 40024
// continue ;
40022: GO 39937
// for j in tmp do
40024: LD_ADDR_VAR 0 3
40028: PUSH
40029: LD_VAR 0 4
40033: PUSH
40034: FOR_IN
40035: IFFALSE 40094
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40037: LD_VAR 0 3
40041: PUSH
40042: LD_EXP 79
40046: PUSH
40047: LD_VAR 0 2
40051: ARRAY
40052: PUSH
40053: LD_INT 1
40055: ARRAY
40056: IN
40057: NOT
40058: PUSH
40059: LD_VAR 0 3
40063: PUSH
40064: LD_EXP 79
40068: PUSH
40069: LD_VAR 0 2
40073: ARRAY
40074: PUSH
40075: LD_INT 2
40077: ARRAY
40078: IN
40079: NOT
40080: AND
40081: IFFALSE 40092
// ComSpaceTimeShoot ( j ) ;
40083: LD_VAR 0 3
40087: PPUSH
40088: CALL 51118 0 1
40092: GO 40034
40094: POP
40095: POP
// end ;
40096: GO 39937
40098: POP
40099: POP
// end ;
40100: LD_VAR 0 1
40104: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40105: LD_INT 0
40107: PPUSH
40108: PPUSH
40109: PPUSH
40110: PPUSH
40111: PPUSH
40112: PPUSH
40113: PPUSH
40114: PPUSH
40115: PPUSH
// if not mc_bases then
40116: LD_EXP 76
40120: NOT
40121: IFFALSE 40125
// exit ;
40123: GO 40747
// for i = 1 to mc_bases do
40125: LD_ADDR_VAR 0 2
40129: PUSH
40130: DOUBLE
40131: LD_INT 1
40133: DEC
40134: ST_TO_ADDR
40135: LD_EXP 76
40139: PUSH
40140: FOR_TO
40141: IFFALSE 40745
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40143: LD_EXP 111
40147: PUSH
40148: LD_VAR 0 2
40152: ARRAY
40153: NOT
40154: PUSH
40155: LD_INT 38
40157: PPUSH
40158: LD_EXP 102
40162: PUSH
40163: LD_VAR 0 2
40167: ARRAY
40168: PPUSH
40169: CALL_OW 321
40173: PUSH
40174: LD_INT 2
40176: NONEQUAL
40177: OR
40178: IFFALSE 40182
// continue ;
40180: GO 40140
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40182: LD_ADDR_VAR 0 8
40186: PUSH
40187: LD_EXP 76
40191: PUSH
40192: LD_VAR 0 2
40196: ARRAY
40197: PPUSH
40198: LD_INT 30
40200: PUSH
40201: LD_INT 34
40203: PUSH
40204: EMPTY
40205: LIST
40206: LIST
40207: PPUSH
40208: CALL_OW 72
40212: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40213: LD_ADDR_VAR 0 9
40217: PUSH
40218: LD_EXP 76
40222: PUSH
40223: LD_VAR 0 2
40227: ARRAY
40228: PPUSH
40229: LD_INT 25
40231: PUSH
40232: LD_INT 4
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PPUSH
40239: CALL_OW 72
40243: PPUSH
40244: LD_INT 0
40246: PPUSH
40247: CALL 90818 0 2
40251: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40252: LD_VAR 0 9
40256: NOT
40257: PUSH
40258: LD_VAR 0 8
40262: NOT
40263: OR
40264: PUSH
40265: LD_EXP 76
40269: PUSH
40270: LD_VAR 0 2
40274: ARRAY
40275: PPUSH
40276: LD_INT 124
40278: PPUSH
40279: CALL 90818 0 2
40283: OR
40284: IFFALSE 40288
// continue ;
40286: GO 40140
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40288: LD_EXP 112
40292: PUSH
40293: LD_VAR 0 2
40297: ARRAY
40298: PUSH
40299: LD_EXP 111
40303: PUSH
40304: LD_VAR 0 2
40308: ARRAY
40309: LESS
40310: PUSH
40311: LD_EXP 112
40315: PUSH
40316: LD_VAR 0 2
40320: ARRAY
40321: PUSH
40322: LD_VAR 0 8
40326: LESS
40327: AND
40328: IFFALSE 40743
// begin tmp := sci [ 1 ] ;
40330: LD_ADDR_VAR 0 7
40334: PUSH
40335: LD_VAR 0 9
40339: PUSH
40340: LD_INT 1
40342: ARRAY
40343: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40344: LD_VAR 0 7
40348: PPUSH
40349: LD_INT 124
40351: PPUSH
40352: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40356: LD_ADDR_VAR 0 3
40360: PUSH
40361: DOUBLE
40362: LD_EXP 111
40366: PUSH
40367: LD_VAR 0 2
40371: ARRAY
40372: INC
40373: ST_TO_ADDR
40374: LD_EXP 111
40378: PUSH
40379: LD_VAR 0 2
40383: ARRAY
40384: PUSH
40385: FOR_DOWNTO
40386: IFFALSE 40729
// begin if IsInUnit ( tmp ) then
40388: LD_VAR 0 7
40392: PPUSH
40393: CALL_OW 310
40397: IFFALSE 40408
// ComExitBuilding ( tmp ) ;
40399: LD_VAR 0 7
40403: PPUSH
40404: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40408: LD_INT 35
40410: PPUSH
40411: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40415: LD_VAR 0 7
40419: PPUSH
40420: CALL_OW 310
40424: NOT
40425: PUSH
40426: LD_VAR 0 7
40430: PPUSH
40431: CALL_OW 314
40435: NOT
40436: AND
40437: IFFALSE 40408
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40439: LD_ADDR_VAR 0 6
40443: PUSH
40444: LD_VAR 0 7
40448: PPUSH
40449: CALL_OW 250
40453: PUSH
40454: LD_VAR 0 7
40458: PPUSH
40459: CALL_OW 251
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40468: LD_INT 35
40470: PPUSH
40471: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40475: LD_ADDR_VAR 0 4
40479: PUSH
40480: LD_EXP 111
40484: PUSH
40485: LD_VAR 0 2
40489: ARRAY
40490: PUSH
40491: LD_VAR 0 3
40495: ARRAY
40496: PUSH
40497: LD_INT 1
40499: ARRAY
40500: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40501: LD_ADDR_VAR 0 5
40505: PUSH
40506: LD_EXP 111
40510: PUSH
40511: LD_VAR 0 2
40515: ARRAY
40516: PUSH
40517: LD_VAR 0 3
40521: ARRAY
40522: PUSH
40523: LD_INT 2
40525: ARRAY
40526: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40527: LD_VAR 0 7
40531: PPUSH
40532: LD_INT 10
40534: PPUSH
40535: CALL 60125 0 2
40539: PUSH
40540: LD_INT 4
40542: ARRAY
40543: IFFALSE 40581
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40545: LD_VAR 0 7
40549: PPUSH
40550: LD_VAR 0 6
40554: PUSH
40555: LD_INT 1
40557: ARRAY
40558: PPUSH
40559: LD_VAR 0 6
40563: PUSH
40564: LD_INT 2
40566: ARRAY
40567: PPUSH
40568: CALL_OW 111
// wait ( 0 0$10 ) ;
40572: LD_INT 350
40574: PPUSH
40575: CALL_OW 67
// end else
40579: GO 40607
// begin ComMoveXY ( tmp , x , y ) ;
40581: LD_VAR 0 7
40585: PPUSH
40586: LD_VAR 0 4
40590: PPUSH
40591: LD_VAR 0 5
40595: PPUSH
40596: CALL_OW 111
// wait ( 0 0$3 ) ;
40600: LD_INT 105
40602: PPUSH
40603: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40607: LD_VAR 0 7
40611: PPUSH
40612: LD_VAR 0 4
40616: PPUSH
40617: LD_VAR 0 5
40621: PPUSH
40622: CALL_OW 307
40626: IFFALSE 40468
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40628: LD_VAR 0 7
40632: PPUSH
40633: LD_VAR 0 4
40637: PPUSH
40638: LD_VAR 0 5
40642: PPUSH
40643: LD_VAR 0 8
40647: PUSH
40648: LD_VAR 0 3
40652: ARRAY
40653: PPUSH
40654: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40658: LD_INT 35
40660: PPUSH
40661: CALL_OW 67
// until not HasTask ( tmp ) ;
40665: LD_VAR 0 7
40669: PPUSH
40670: CALL_OW 314
40674: NOT
40675: IFFALSE 40658
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40677: LD_ADDR_EXP 112
40681: PUSH
40682: LD_EXP 112
40686: PPUSH
40687: LD_VAR 0 2
40691: PUSH
40692: LD_EXP 112
40696: PUSH
40697: LD_VAR 0 2
40701: ARRAY
40702: PUSH
40703: LD_INT 1
40705: PLUS
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PPUSH
40711: LD_VAR 0 8
40715: PUSH
40716: LD_VAR 0 3
40720: ARRAY
40721: PPUSH
40722: CALL 57532 0 3
40726: ST_TO_ADDR
// end ;
40727: GO 40385
40729: POP
40730: POP
// MC_Reset ( i , 124 ) ;
40731: LD_VAR 0 2
40735: PPUSH
40736: LD_INT 124
40738: PPUSH
40739: CALL 24334 0 2
// end ; end ;
40743: GO 40140
40745: POP
40746: POP
// end ;
40747: LD_VAR 0 1
40751: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40752: LD_INT 0
40754: PPUSH
40755: PPUSH
40756: PPUSH
// if not mc_bases then
40757: LD_EXP 76
40761: NOT
40762: IFFALSE 40766
// exit ;
40764: GO 41372
// for i = 1 to mc_bases do
40766: LD_ADDR_VAR 0 2
40770: PUSH
40771: DOUBLE
40772: LD_INT 1
40774: DEC
40775: ST_TO_ADDR
40776: LD_EXP 76
40780: PUSH
40781: FOR_TO
40782: IFFALSE 41370
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40784: LD_ADDR_VAR 0 3
40788: PUSH
40789: LD_EXP 76
40793: PUSH
40794: LD_VAR 0 2
40798: ARRAY
40799: PPUSH
40800: LD_INT 25
40802: PUSH
40803: LD_INT 4
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PPUSH
40810: CALL_OW 72
40814: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40815: LD_VAR 0 3
40819: NOT
40820: PUSH
40821: LD_EXP 113
40825: PUSH
40826: LD_VAR 0 2
40830: ARRAY
40831: NOT
40832: OR
40833: PUSH
40834: LD_EXP 76
40838: PUSH
40839: LD_VAR 0 2
40843: ARRAY
40844: PPUSH
40845: LD_INT 2
40847: PUSH
40848: LD_INT 30
40850: PUSH
40851: LD_INT 0
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 30
40860: PUSH
40861: LD_INT 1
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: LIST
40872: PPUSH
40873: CALL_OW 72
40877: NOT
40878: OR
40879: IFFALSE 40929
// begin if mc_deposits_finder [ i ] then
40881: LD_EXP 114
40885: PUSH
40886: LD_VAR 0 2
40890: ARRAY
40891: IFFALSE 40927
// begin MC_Reset ( i , 125 ) ;
40893: LD_VAR 0 2
40897: PPUSH
40898: LD_INT 125
40900: PPUSH
40901: CALL 24334 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40905: LD_ADDR_EXP 114
40909: PUSH
40910: LD_EXP 114
40914: PPUSH
40915: LD_VAR 0 2
40919: PPUSH
40920: EMPTY
40921: PPUSH
40922: CALL_OW 1
40926: ST_TO_ADDR
// end ; continue ;
40927: GO 40781
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
40929: LD_EXP 113
40933: PUSH
40934: LD_VAR 0 2
40938: ARRAY
40939: PUSH
40940: LD_INT 1
40942: ARRAY
40943: PUSH
40944: LD_INT 3
40946: ARRAY
40947: PUSH
40948: LD_INT 1
40950: EQUAL
40951: PUSH
40952: LD_INT 20
40954: PPUSH
40955: LD_EXP 102
40959: PUSH
40960: LD_VAR 0 2
40964: ARRAY
40965: PPUSH
40966: CALL_OW 321
40970: PUSH
40971: LD_INT 2
40973: NONEQUAL
40974: AND
40975: IFFALSE 41025
// begin if mc_deposits_finder [ i ] then
40977: LD_EXP 114
40981: PUSH
40982: LD_VAR 0 2
40986: ARRAY
40987: IFFALSE 41023
// begin MC_Reset ( i , 125 ) ;
40989: LD_VAR 0 2
40993: PPUSH
40994: LD_INT 125
40996: PPUSH
40997: CALL 24334 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41001: LD_ADDR_EXP 114
41005: PUSH
41006: LD_EXP 114
41010: PPUSH
41011: LD_VAR 0 2
41015: PPUSH
41016: EMPTY
41017: PPUSH
41018: CALL_OW 1
41022: ST_TO_ADDR
// end ; continue ;
41023: GO 40781
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41025: LD_EXP 113
41029: PUSH
41030: LD_VAR 0 2
41034: ARRAY
41035: PUSH
41036: LD_INT 1
41038: ARRAY
41039: PUSH
41040: LD_INT 1
41042: ARRAY
41043: PPUSH
41044: LD_EXP 113
41048: PUSH
41049: LD_VAR 0 2
41053: ARRAY
41054: PUSH
41055: LD_INT 1
41057: ARRAY
41058: PUSH
41059: LD_INT 2
41061: ARRAY
41062: PPUSH
41063: LD_EXP 102
41067: PUSH
41068: LD_VAR 0 2
41072: ARRAY
41073: PPUSH
41074: CALL_OW 440
41078: IFFALSE 41121
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41080: LD_ADDR_EXP 113
41084: PUSH
41085: LD_EXP 113
41089: PPUSH
41090: LD_VAR 0 2
41094: PPUSH
41095: LD_EXP 113
41099: PUSH
41100: LD_VAR 0 2
41104: ARRAY
41105: PPUSH
41106: LD_INT 1
41108: PPUSH
41109: CALL_OW 3
41113: PPUSH
41114: CALL_OW 1
41118: ST_TO_ADDR
41119: GO 41368
// begin if not mc_deposits_finder [ i ] then
41121: LD_EXP 114
41125: PUSH
41126: LD_VAR 0 2
41130: ARRAY
41131: NOT
41132: IFFALSE 41184
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41134: LD_ADDR_EXP 114
41138: PUSH
41139: LD_EXP 114
41143: PPUSH
41144: LD_VAR 0 2
41148: PPUSH
41149: LD_VAR 0 3
41153: PUSH
41154: LD_INT 1
41156: ARRAY
41157: PUSH
41158: EMPTY
41159: LIST
41160: PPUSH
41161: CALL_OW 1
41165: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41166: LD_VAR 0 3
41170: PUSH
41171: LD_INT 1
41173: ARRAY
41174: PPUSH
41175: LD_INT 125
41177: PPUSH
41178: CALL_OW 109
// end else
41182: GO 41368
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41184: LD_EXP 114
41188: PUSH
41189: LD_VAR 0 2
41193: ARRAY
41194: PUSH
41195: LD_INT 1
41197: ARRAY
41198: PPUSH
41199: CALL_OW 310
41203: IFFALSE 41226
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41205: LD_EXP 114
41209: PUSH
41210: LD_VAR 0 2
41214: ARRAY
41215: PUSH
41216: LD_INT 1
41218: ARRAY
41219: PPUSH
41220: CALL_OW 122
41224: GO 41368
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41226: LD_EXP 114
41230: PUSH
41231: LD_VAR 0 2
41235: ARRAY
41236: PUSH
41237: LD_INT 1
41239: ARRAY
41240: PPUSH
41241: CALL_OW 314
41245: NOT
41246: PUSH
41247: LD_EXP 114
41251: PUSH
41252: LD_VAR 0 2
41256: ARRAY
41257: PUSH
41258: LD_INT 1
41260: ARRAY
41261: PPUSH
41262: LD_EXP 113
41266: PUSH
41267: LD_VAR 0 2
41271: ARRAY
41272: PUSH
41273: LD_INT 1
41275: ARRAY
41276: PUSH
41277: LD_INT 1
41279: ARRAY
41280: PPUSH
41281: LD_EXP 113
41285: PUSH
41286: LD_VAR 0 2
41290: ARRAY
41291: PUSH
41292: LD_INT 1
41294: ARRAY
41295: PUSH
41296: LD_INT 2
41298: ARRAY
41299: PPUSH
41300: CALL_OW 297
41304: PUSH
41305: LD_INT 6
41307: GREATER
41308: AND
41309: IFFALSE 41368
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41311: LD_EXP 114
41315: PUSH
41316: LD_VAR 0 2
41320: ARRAY
41321: PUSH
41322: LD_INT 1
41324: ARRAY
41325: PPUSH
41326: LD_EXP 113
41330: PUSH
41331: LD_VAR 0 2
41335: ARRAY
41336: PUSH
41337: LD_INT 1
41339: ARRAY
41340: PUSH
41341: LD_INT 1
41343: ARRAY
41344: PPUSH
41345: LD_EXP 113
41349: PUSH
41350: LD_VAR 0 2
41354: ARRAY
41355: PUSH
41356: LD_INT 1
41358: ARRAY
41359: PUSH
41360: LD_INT 2
41362: ARRAY
41363: PPUSH
41364: CALL_OW 111
// end ; end ; end ;
41368: GO 40781
41370: POP
41371: POP
// end ;
41372: LD_VAR 0 1
41376: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41377: LD_INT 0
41379: PPUSH
41380: PPUSH
41381: PPUSH
41382: PPUSH
41383: PPUSH
41384: PPUSH
41385: PPUSH
41386: PPUSH
41387: PPUSH
41388: PPUSH
41389: PPUSH
// if not mc_bases then
41390: LD_EXP 76
41394: NOT
41395: IFFALSE 41399
// exit ;
41397: GO 42339
// for i = 1 to mc_bases do
41399: LD_ADDR_VAR 0 2
41403: PUSH
41404: DOUBLE
41405: LD_INT 1
41407: DEC
41408: ST_TO_ADDR
41409: LD_EXP 76
41413: PUSH
41414: FOR_TO
41415: IFFALSE 42337
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41417: LD_EXP 76
41421: PUSH
41422: LD_VAR 0 2
41426: ARRAY
41427: NOT
41428: PUSH
41429: LD_EXP 99
41433: PUSH
41434: LD_VAR 0 2
41438: ARRAY
41439: OR
41440: IFFALSE 41444
// continue ;
41442: GO 41414
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41444: LD_ADDR_VAR 0 7
41448: PUSH
41449: LD_EXP 76
41453: PUSH
41454: LD_VAR 0 2
41458: ARRAY
41459: PUSH
41460: LD_INT 1
41462: ARRAY
41463: PPUSH
41464: CALL_OW 248
41468: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41469: LD_VAR 0 7
41473: PUSH
41474: LD_INT 3
41476: EQUAL
41477: PUSH
41478: LD_EXP 95
41482: PUSH
41483: LD_VAR 0 2
41487: ARRAY
41488: PUSH
41489: LD_EXP 98
41493: PUSH
41494: LD_VAR 0 2
41498: ARRAY
41499: UNION
41500: PPUSH
41501: LD_INT 33
41503: PUSH
41504: LD_INT 2
41506: PUSH
41507: EMPTY
41508: LIST
41509: LIST
41510: PPUSH
41511: CALL_OW 72
41515: NOT
41516: OR
41517: IFFALSE 41521
// continue ;
41519: GO 41414
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41521: LD_ADDR_VAR 0 9
41525: PUSH
41526: LD_EXP 76
41530: PUSH
41531: LD_VAR 0 2
41535: ARRAY
41536: PPUSH
41537: LD_INT 30
41539: PUSH
41540: LD_INT 36
41542: PUSH
41543: EMPTY
41544: LIST
41545: LIST
41546: PPUSH
41547: CALL_OW 72
41551: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41552: LD_ADDR_VAR 0 10
41556: PUSH
41557: LD_EXP 95
41561: PUSH
41562: LD_VAR 0 2
41566: ARRAY
41567: PPUSH
41568: LD_INT 34
41570: PUSH
41571: LD_INT 31
41573: PUSH
41574: EMPTY
41575: LIST
41576: LIST
41577: PPUSH
41578: CALL_OW 72
41582: ST_TO_ADDR
// if not cts and not mcts then
41583: LD_VAR 0 9
41587: NOT
41588: PUSH
41589: LD_VAR 0 10
41593: NOT
41594: AND
41595: IFFALSE 41599
// continue ;
41597: GO 41414
// x := cts ;
41599: LD_ADDR_VAR 0 11
41603: PUSH
41604: LD_VAR 0 9
41608: ST_TO_ADDR
// if not x then
41609: LD_VAR 0 11
41613: NOT
41614: IFFALSE 41626
// x := mcts ;
41616: LD_ADDR_VAR 0 11
41620: PUSH
41621: LD_VAR 0 10
41625: ST_TO_ADDR
// if not x then
41626: LD_VAR 0 11
41630: NOT
41631: IFFALSE 41635
// continue ;
41633: GO 41414
// if mc_remote_driver [ i ] then
41635: LD_EXP 116
41639: PUSH
41640: LD_VAR 0 2
41644: ARRAY
41645: IFFALSE 42032
// for j in mc_remote_driver [ i ] do
41647: LD_ADDR_VAR 0 3
41651: PUSH
41652: LD_EXP 116
41656: PUSH
41657: LD_VAR 0 2
41661: ARRAY
41662: PUSH
41663: FOR_IN
41664: IFFALSE 42030
// begin if GetClass ( j ) <> 3 then
41666: LD_VAR 0 3
41670: PPUSH
41671: CALL_OW 257
41675: PUSH
41676: LD_INT 3
41678: NONEQUAL
41679: IFFALSE 41732
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41681: LD_ADDR_EXP 116
41685: PUSH
41686: LD_EXP 116
41690: PPUSH
41691: LD_VAR 0 2
41695: PPUSH
41696: LD_EXP 116
41700: PUSH
41701: LD_VAR 0 2
41705: ARRAY
41706: PUSH
41707: LD_VAR 0 3
41711: DIFF
41712: PPUSH
41713: CALL_OW 1
41717: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41718: LD_VAR 0 3
41722: PPUSH
41723: LD_INT 0
41725: PPUSH
41726: CALL_OW 109
// continue ;
41730: GO 41663
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
41732: LD_EXP 95
41736: PUSH
41737: LD_VAR 0 2
41741: ARRAY
41742: PPUSH
41743: LD_INT 34
41745: PUSH
41746: LD_INT 31
41748: PUSH
41749: EMPTY
41750: LIST
41751: LIST
41752: PUSH
41753: LD_INT 58
41755: PUSH
41756: EMPTY
41757: LIST
41758: PUSH
41759: EMPTY
41760: LIST
41761: LIST
41762: PPUSH
41763: CALL_OW 72
41767: PUSH
41768: LD_VAR 0 3
41772: PPUSH
41773: CALL 90906 0 1
41777: NOT
41778: AND
41779: IFFALSE 41850
// begin if IsInUnit ( j ) then
41781: LD_VAR 0 3
41785: PPUSH
41786: CALL_OW 310
41790: IFFALSE 41801
// ComExitBuilding ( j ) ;
41792: LD_VAR 0 3
41796: PPUSH
41797: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
41801: LD_VAR 0 3
41805: PPUSH
41806: LD_EXP 95
41810: PUSH
41811: LD_VAR 0 2
41815: ARRAY
41816: PPUSH
41817: LD_INT 34
41819: PUSH
41820: LD_INT 31
41822: PUSH
41823: EMPTY
41824: LIST
41825: LIST
41826: PUSH
41827: LD_INT 58
41829: PUSH
41830: EMPTY
41831: LIST
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PPUSH
41837: CALL_OW 72
41841: PUSH
41842: LD_INT 1
41844: ARRAY
41845: PPUSH
41846: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41850: LD_VAR 0 3
41854: PPUSH
41855: CALL_OW 310
41859: NOT
41860: PUSH
41861: LD_VAR 0 3
41865: PPUSH
41866: CALL_OW 310
41870: PPUSH
41871: CALL_OW 266
41875: PUSH
41876: LD_INT 36
41878: NONEQUAL
41879: PUSH
41880: LD_VAR 0 3
41884: PPUSH
41885: CALL 90906 0 1
41889: NOT
41890: AND
41891: OR
41892: IFFALSE 42028
// begin if IsInUnit ( j ) then
41894: LD_VAR 0 3
41898: PPUSH
41899: CALL_OW 310
41903: IFFALSE 41914
// ComExitBuilding ( j ) ;
41905: LD_VAR 0 3
41909: PPUSH
41910: CALL_OW 122
// ct := 0 ;
41914: LD_ADDR_VAR 0 8
41918: PUSH
41919: LD_INT 0
41921: ST_TO_ADDR
// for k in x do
41922: LD_ADDR_VAR 0 4
41926: PUSH
41927: LD_VAR 0 11
41931: PUSH
41932: FOR_IN
41933: IFFALSE 42006
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
41935: LD_VAR 0 4
41939: PPUSH
41940: CALL_OW 264
41944: PUSH
41945: LD_INT 31
41947: EQUAL
41948: PUSH
41949: LD_VAR 0 4
41953: PPUSH
41954: CALL_OW 311
41958: NOT
41959: AND
41960: PUSH
41961: LD_VAR 0 4
41965: PPUSH
41966: CALL_OW 266
41970: PUSH
41971: LD_INT 36
41973: EQUAL
41974: PUSH
41975: LD_VAR 0 4
41979: PPUSH
41980: CALL_OW 313
41984: PUSH
41985: LD_INT 3
41987: LESS
41988: AND
41989: OR
41990: IFFALSE 42004
// begin ct := k ;
41992: LD_ADDR_VAR 0 8
41996: PUSH
41997: LD_VAR 0 4
42001: ST_TO_ADDR
// break ;
42002: GO 42006
// end ;
42004: GO 41932
42006: POP
42007: POP
// if ct then
42008: LD_VAR 0 8
42012: IFFALSE 42028
// ComEnterUnit ( j , ct ) ;
42014: LD_VAR 0 3
42018: PPUSH
42019: LD_VAR 0 8
42023: PPUSH
42024: CALL_OW 120
// end ; end ;
42028: GO 41663
42030: POP
42031: POP
// places := 0 ;
42032: LD_ADDR_VAR 0 5
42036: PUSH
42037: LD_INT 0
42039: ST_TO_ADDR
// for j = 1 to x do
42040: LD_ADDR_VAR 0 3
42044: PUSH
42045: DOUBLE
42046: LD_INT 1
42048: DEC
42049: ST_TO_ADDR
42050: LD_VAR 0 11
42054: PUSH
42055: FOR_TO
42056: IFFALSE 42132
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42058: LD_VAR 0 11
42062: PUSH
42063: LD_VAR 0 3
42067: ARRAY
42068: PPUSH
42069: CALL_OW 264
42073: PUSH
42074: LD_INT 31
42076: EQUAL
42077: IFFALSE 42095
// places := places + 1 else
42079: LD_ADDR_VAR 0 5
42083: PUSH
42084: LD_VAR 0 5
42088: PUSH
42089: LD_INT 1
42091: PLUS
42092: ST_TO_ADDR
42093: GO 42130
// if GetBType ( x [ j ] ) = b_control_tower then
42095: LD_VAR 0 11
42099: PUSH
42100: LD_VAR 0 3
42104: ARRAY
42105: PPUSH
42106: CALL_OW 266
42110: PUSH
42111: LD_INT 36
42113: EQUAL
42114: IFFALSE 42130
// places := places + 3 ;
42116: LD_ADDR_VAR 0 5
42120: PUSH
42121: LD_VAR 0 5
42125: PUSH
42126: LD_INT 3
42128: PLUS
42129: ST_TO_ADDR
42130: GO 42055
42132: POP
42133: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42134: LD_VAR 0 5
42138: PUSH
42139: LD_INT 0
42141: EQUAL
42142: PUSH
42143: LD_VAR 0 5
42147: PUSH
42148: LD_EXP 116
42152: PUSH
42153: LD_VAR 0 2
42157: ARRAY
42158: LESSEQUAL
42159: OR
42160: IFFALSE 42164
// continue ;
42162: GO 41414
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42164: LD_ADDR_VAR 0 6
42168: PUSH
42169: LD_EXP 76
42173: PUSH
42174: LD_VAR 0 2
42178: ARRAY
42179: PPUSH
42180: LD_INT 25
42182: PUSH
42183: LD_INT 3
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PPUSH
42190: CALL_OW 72
42194: PUSH
42195: LD_EXP 116
42199: PUSH
42200: LD_VAR 0 2
42204: ARRAY
42205: DIFF
42206: PPUSH
42207: LD_INT 3
42209: PPUSH
42210: CALL 91806 0 2
42214: ST_TO_ADDR
// for j in tmp do
42215: LD_ADDR_VAR 0 3
42219: PUSH
42220: LD_VAR 0 6
42224: PUSH
42225: FOR_IN
42226: IFFALSE 42261
// if GetTag ( j ) > 0 then
42228: LD_VAR 0 3
42232: PPUSH
42233: CALL_OW 110
42237: PUSH
42238: LD_INT 0
42240: GREATER
42241: IFFALSE 42259
// tmp := tmp diff j ;
42243: LD_ADDR_VAR 0 6
42247: PUSH
42248: LD_VAR 0 6
42252: PUSH
42253: LD_VAR 0 3
42257: DIFF
42258: ST_TO_ADDR
42259: GO 42225
42261: POP
42262: POP
// if not tmp then
42263: LD_VAR 0 6
42267: NOT
42268: IFFALSE 42272
// continue ;
42270: GO 41414
// if places then
42272: LD_VAR 0 5
42276: IFFALSE 42335
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42278: LD_ADDR_EXP 116
42282: PUSH
42283: LD_EXP 116
42287: PPUSH
42288: LD_VAR 0 2
42292: PPUSH
42293: LD_EXP 116
42297: PUSH
42298: LD_VAR 0 2
42302: ARRAY
42303: PUSH
42304: LD_VAR 0 6
42308: PUSH
42309: LD_INT 1
42311: ARRAY
42312: UNION
42313: PPUSH
42314: CALL_OW 1
42318: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42319: LD_VAR 0 6
42323: PUSH
42324: LD_INT 1
42326: ARRAY
42327: PPUSH
42328: LD_INT 126
42330: PPUSH
42331: CALL_OW 109
// end ; end ;
42335: GO 41414
42337: POP
42338: POP
// end ;
42339: LD_VAR 0 1
42343: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42344: LD_INT 0
42346: PPUSH
42347: PPUSH
42348: PPUSH
42349: PPUSH
42350: PPUSH
42351: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42352: LD_VAR 0 1
42356: NOT
42357: PUSH
42358: LD_VAR 0 2
42362: NOT
42363: OR
42364: PUSH
42365: LD_VAR 0 3
42369: NOT
42370: OR
42371: PUSH
42372: LD_VAR 0 4
42376: PUSH
42377: LD_INT 1
42379: PUSH
42380: LD_INT 2
42382: PUSH
42383: LD_INT 3
42385: PUSH
42386: LD_INT 4
42388: PUSH
42389: LD_INT 5
42391: PUSH
42392: LD_INT 8
42394: PUSH
42395: LD_INT 9
42397: PUSH
42398: LD_INT 15
42400: PUSH
42401: LD_INT 16
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: LIST
42408: LIST
42409: LIST
42410: LIST
42411: LIST
42412: LIST
42413: LIST
42414: IN
42415: NOT
42416: OR
42417: IFFALSE 42421
// exit ;
42419: GO 43321
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42421: LD_ADDR_VAR 0 2
42425: PUSH
42426: LD_VAR 0 2
42430: PPUSH
42431: LD_INT 21
42433: PUSH
42434: LD_INT 3
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 24
42443: PUSH
42444: LD_INT 250
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PPUSH
42455: CALL_OW 72
42459: ST_TO_ADDR
// case class of 1 , 15 :
42460: LD_VAR 0 4
42464: PUSH
42465: LD_INT 1
42467: DOUBLE
42468: EQUAL
42469: IFTRUE 42479
42471: LD_INT 15
42473: DOUBLE
42474: EQUAL
42475: IFTRUE 42479
42477: GO 42564
42479: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42480: LD_ADDR_VAR 0 8
42484: PUSH
42485: LD_VAR 0 2
42489: PPUSH
42490: LD_INT 2
42492: PUSH
42493: LD_INT 30
42495: PUSH
42496: LD_INT 32
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: LD_INT 30
42505: PUSH
42506: LD_INT 31
42508: PUSH
42509: EMPTY
42510: LIST
42511: LIST
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: LIST
42517: PPUSH
42518: CALL_OW 72
42522: PUSH
42523: LD_VAR 0 2
42527: PPUSH
42528: LD_INT 2
42530: PUSH
42531: LD_INT 30
42533: PUSH
42534: LD_INT 4
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 30
42543: PUSH
42544: LD_INT 5
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: LIST
42555: PPUSH
42556: CALL_OW 72
42560: ADD
42561: ST_TO_ADDR
42562: GO 42810
42564: LD_INT 2
42566: DOUBLE
42567: EQUAL
42568: IFTRUE 42578
42570: LD_INT 16
42572: DOUBLE
42573: EQUAL
42574: IFTRUE 42578
42576: GO 42624
42578: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42579: LD_ADDR_VAR 0 8
42583: PUSH
42584: LD_VAR 0 2
42588: PPUSH
42589: LD_INT 2
42591: PUSH
42592: LD_INT 30
42594: PUSH
42595: LD_INT 0
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PUSH
42602: LD_INT 30
42604: PUSH
42605: LD_INT 1
42607: PUSH
42608: EMPTY
42609: LIST
42610: LIST
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: LIST
42616: PPUSH
42617: CALL_OW 72
42621: ST_TO_ADDR
42622: GO 42810
42624: LD_INT 3
42626: DOUBLE
42627: EQUAL
42628: IFTRUE 42632
42630: GO 42678
42632: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42633: LD_ADDR_VAR 0 8
42637: PUSH
42638: LD_VAR 0 2
42642: PPUSH
42643: LD_INT 2
42645: PUSH
42646: LD_INT 30
42648: PUSH
42649: LD_INT 2
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 30
42658: PUSH
42659: LD_INT 3
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: LIST
42670: PPUSH
42671: CALL_OW 72
42675: ST_TO_ADDR
42676: GO 42810
42678: LD_INT 4
42680: DOUBLE
42681: EQUAL
42682: IFTRUE 42686
42684: GO 42743
42686: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42687: LD_ADDR_VAR 0 8
42691: PUSH
42692: LD_VAR 0 2
42696: PPUSH
42697: LD_INT 2
42699: PUSH
42700: LD_INT 30
42702: PUSH
42703: LD_INT 6
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 30
42712: PUSH
42713: LD_INT 7
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 30
42722: PUSH
42723: LD_INT 8
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: LIST
42734: LIST
42735: PPUSH
42736: CALL_OW 72
42740: ST_TO_ADDR
42741: GO 42810
42743: LD_INT 5
42745: DOUBLE
42746: EQUAL
42747: IFTRUE 42763
42749: LD_INT 8
42751: DOUBLE
42752: EQUAL
42753: IFTRUE 42763
42755: LD_INT 9
42757: DOUBLE
42758: EQUAL
42759: IFTRUE 42763
42761: GO 42809
42763: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42764: LD_ADDR_VAR 0 8
42768: PUSH
42769: LD_VAR 0 2
42773: PPUSH
42774: LD_INT 2
42776: PUSH
42777: LD_INT 30
42779: PUSH
42780: LD_INT 4
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 30
42789: PUSH
42790: LD_INT 5
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: LIST
42801: PPUSH
42802: CALL_OW 72
42806: ST_TO_ADDR
42807: GO 42810
42809: POP
// if not tmp then
42810: LD_VAR 0 8
42814: NOT
42815: IFFALSE 42819
// exit ;
42817: GO 43321
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42819: LD_VAR 0 4
42823: PUSH
42824: LD_INT 1
42826: PUSH
42827: LD_INT 15
42829: PUSH
42830: EMPTY
42831: LIST
42832: LIST
42833: IN
42834: PUSH
42835: LD_EXP 85
42839: PUSH
42840: LD_VAR 0 1
42844: ARRAY
42845: AND
42846: IFFALSE 43002
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42848: LD_ADDR_VAR 0 9
42852: PUSH
42853: LD_EXP 85
42857: PUSH
42858: LD_VAR 0 1
42862: ARRAY
42863: PUSH
42864: LD_INT 1
42866: ARRAY
42867: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42868: LD_VAR 0 9
42872: PUSH
42873: LD_EXP 86
42877: PUSH
42878: LD_VAR 0 1
42882: ARRAY
42883: IN
42884: NOT
42885: IFFALSE 43000
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42887: LD_ADDR_EXP 86
42891: PUSH
42892: LD_EXP 86
42896: PPUSH
42897: LD_VAR 0 1
42901: PUSH
42902: LD_EXP 86
42906: PUSH
42907: LD_VAR 0 1
42911: ARRAY
42912: PUSH
42913: LD_INT 1
42915: PLUS
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PPUSH
42921: LD_VAR 0 9
42925: PPUSH
42926: CALL 57532 0 3
42930: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
42931: LD_ADDR_EXP 85
42935: PUSH
42936: LD_EXP 85
42940: PPUSH
42941: LD_VAR 0 1
42945: PPUSH
42946: LD_EXP 85
42950: PUSH
42951: LD_VAR 0 1
42955: ARRAY
42956: PUSH
42957: LD_VAR 0 9
42961: DIFF
42962: PPUSH
42963: CALL_OW 1
42967: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
42968: LD_VAR 0 3
42972: PPUSH
42973: LD_EXP 86
42977: PUSH
42978: LD_VAR 0 1
42982: ARRAY
42983: PUSH
42984: LD_EXP 86
42988: PUSH
42989: LD_VAR 0 1
42993: ARRAY
42994: ARRAY
42995: PPUSH
42996: CALL_OW 120
// end ; exit ;
43000: GO 43321
// end ; if tmp > 1 then
43002: LD_VAR 0 8
43006: PUSH
43007: LD_INT 1
43009: GREATER
43010: IFFALSE 43114
// for i = 2 to tmp do
43012: LD_ADDR_VAR 0 6
43016: PUSH
43017: DOUBLE
43018: LD_INT 2
43020: DEC
43021: ST_TO_ADDR
43022: LD_VAR 0 8
43026: PUSH
43027: FOR_TO
43028: IFFALSE 43112
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43030: LD_VAR 0 8
43034: PUSH
43035: LD_VAR 0 6
43039: ARRAY
43040: PPUSH
43041: CALL_OW 461
43045: PUSH
43046: LD_INT 6
43048: EQUAL
43049: IFFALSE 43110
// begin x := tmp [ i ] ;
43051: LD_ADDR_VAR 0 9
43055: PUSH
43056: LD_VAR 0 8
43060: PUSH
43061: LD_VAR 0 6
43065: ARRAY
43066: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43067: LD_ADDR_VAR 0 8
43071: PUSH
43072: LD_VAR 0 8
43076: PPUSH
43077: LD_VAR 0 6
43081: PPUSH
43082: CALL_OW 3
43086: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43087: LD_ADDR_VAR 0 8
43091: PUSH
43092: LD_VAR 0 8
43096: PPUSH
43097: LD_INT 1
43099: PPUSH
43100: LD_VAR 0 9
43104: PPUSH
43105: CALL_OW 2
43109: ST_TO_ADDR
// end ;
43110: GO 43027
43112: POP
43113: POP
// for i in tmp do
43114: LD_ADDR_VAR 0 6
43118: PUSH
43119: LD_VAR 0 8
43123: PUSH
43124: FOR_IN
43125: IFFALSE 43194
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43127: LD_VAR 0 6
43131: PPUSH
43132: CALL_OW 313
43136: PUSH
43137: LD_INT 6
43139: LESS
43140: PUSH
43141: LD_VAR 0 6
43145: PPUSH
43146: CALL_OW 266
43150: PUSH
43151: LD_INT 31
43153: PUSH
43154: LD_INT 32
43156: PUSH
43157: EMPTY
43158: LIST
43159: LIST
43160: IN
43161: NOT
43162: AND
43163: PUSH
43164: LD_VAR 0 6
43168: PPUSH
43169: CALL_OW 313
43173: PUSH
43174: LD_INT 0
43176: EQUAL
43177: OR
43178: IFFALSE 43192
// begin j := i ;
43180: LD_ADDR_VAR 0 7
43184: PUSH
43185: LD_VAR 0 6
43189: ST_TO_ADDR
// break ;
43190: GO 43194
// end ; end ;
43192: GO 43124
43194: POP
43195: POP
// if j then
43196: LD_VAR 0 7
43200: IFFALSE 43218
// ComEnterUnit ( unit , j ) else
43202: LD_VAR 0 3
43206: PPUSH
43207: LD_VAR 0 7
43211: PPUSH
43212: CALL_OW 120
43216: GO 43321
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43218: LD_ADDR_VAR 0 10
43222: PUSH
43223: LD_VAR 0 2
43227: PPUSH
43228: LD_INT 2
43230: PUSH
43231: LD_INT 30
43233: PUSH
43234: LD_INT 0
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: PUSH
43241: LD_INT 30
43243: PUSH
43244: LD_INT 1
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: LIST
43255: PPUSH
43256: CALL_OW 72
43260: ST_TO_ADDR
// if depot then
43261: LD_VAR 0 10
43265: IFFALSE 43321
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43267: LD_ADDR_VAR 0 10
43271: PUSH
43272: LD_VAR 0 10
43276: PPUSH
43277: LD_VAR 0 3
43281: PPUSH
43282: CALL_OW 74
43286: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43287: LD_VAR 0 3
43291: PPUSH
43292: LD_VAR 0 10
43296: PPUSH
43297: CALL_OW 296
43301: PUSH
43302: LD_INT 10
43304: GREATER
43305: IFFALSE 43321
// ComStandNearbyBuilding ( unit , depot ) ;
43307: LD_VAR 0 3
43311: PPUSH
43312: LD_VAR 0 10
43316: PPUSH
43317: CALL 51735 0 2
// end ; end ; end ;
43321: LD_VAR 0 5
43325: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43326: LD_INT 0
43328: PPUSH
43329: PPUSH
43330: PPUSH
43331: PPUSH
// if not mc_bases then
43332: LD_EXP 76
43336: NOT
43337: IFFALSE 43341
// exit ;
43339: GO 43580
// for i = 1 to mc_bases do
43341: LD_ADDR_VAR 0 2
43345: PUSH
43346: DOUBLE
43347: LD_INT 1
43349: DEC
43350: ST_TO_ADDR
43351: LD_EXP 76
43355: PUSH
43356: FOR_TO
43357: IFFALSE 43578
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43359: LD_ADDR_VAR 0 4
43363: PUSH
43364: LD_EXP 76
43368: PUSH
43369: LD_VAR 0 2
43373: ARRAY
43374: PPUSH
43375: LD_INT 21
43377: PUSH
43378: LD_INT 1
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PPUSH
43385: CALL_OW 72
43389: PUSH
43390: LD_EXP 105
43394: PUSH
43395: LD_VAR 0 2
43399: ARRAY
43400: UNION
43401: ST_TO_ADDR
// if not tmp then
43402: LD_VAR 0 4
43406: NOT
43407: IFFALSE 43411
// continue ;
43409: GO 43356
// for j in tmp do
43411: LD_ADDR_VAR 0 3
43415: PUSH
43416: LD_VAR 0 4
43420: PUSH
43421: FOR_IN
43422: IFFALSE 43574
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43424: LD_VAR 0 3
43428: PPUSH
43429: CALL_OW 110
43433: NOT
43434: PUSH
43435: LD_VAR 0 3
43439: PPUSH
43440: CALL_OW 314
43444: NOT
43445: AND
43446: PUSH
43447: LD_VAR 0 3
43451: PPUSH
43452: CALL_OW 311
43456: NOT
43457: AND
43458: PUSH
43459: LD_VAR 0 3
43463: PPUSH
43464: CALL_OW 310
43468: NOT
43469: AND
43470: PUSH
43471: LD_VAR 0 3
43475: PUSH
43476: LD_EXP 79
43480: PUSH
43481: LD_VAR 0 2
43485: ARRAY
43486: PUSH
43487: LD_INT 1
43489: ARRAY
43490: IN
43491: NOT
43492: AND
43493: PUSH
43494: LD_VAR 0 3
43498: PUSH
43499: LD_EXP 79
43503: PUSH
43504: LD_VAR 0 2
43508: ARRAY
43509: PUSH
43510: LD_INT 2
43512: ARRAY
43513: IN
43514: NOT
43515: AND
43516: PUSH
43517: LD_VAR 0 3
43521: PUSH
43522: LD_EXP 88
43526: PUSH
43527: LD_VAR 0 2
43531: ARRAY
43532: IN
43533: NOT
43534: AND
43535: IFFALSE 43572
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43537: LD_VAR 0 2
43541: PPUSH
43542: LD_EXP 76
43546: PUSH
43547: LD_VAR 0 2
43551: ARRAY
43552: PPUSH
43553: LD_VAR 0 3
43557: PPUSH
43558: LD_VAR 0 3
43562: PPUSH
43563: CALL_OW 257
43567: PPUSH
43568: CALL 42344 0 4
// end ;
43572: GO 43421
43574: POP
43575: POP
// end ;
43576: GO 43356
43578: POP
43579: POP
// end ;
43580: LD_VAR 0 1
43584: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43585: LD_INT 0
43587: PPUSH
43588: PPUSH
43589: PPUSH
43590: PPUSH
43591: PPUSH
43592: PPUSH
// if not mc_bases [ base ] then
43593: LD_EXP 76
43597: PUSH
43598: LD_VAR 0 1
43602: ARRAY
43603: NOT
43604: IFFALSE 43608
// exit ;
43606: GO 43790
// tmp := [ ] ;
43608: LD_ADDR_VAR 0 6
43612: PUSH
43613: EMPTY
43614: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43615: LD_ADDR_VAR 0 7
43619: PUSH
43620: LD_VAR 0 3
43624: PPUSH
43625: LD_INT 0
43627: PPUSH
43628: CALL_OW 517
43632: ST_TO_ADDR
// if not list then
43633: LD_VAR 0 7
43637: NOT
43638: IFFALSE 43642
// exit ;
43640: GO 43790
// for i = 1 to amount do
43642: LD_ADDR_VAR 0 5
43646: PUSH
43647: DOUBLE
43648: LD_INT 1
43650: DEC
43651: ST_TO_ADDR
43652: LD_VAR 0 2
43656: PUSH
43657: FOR_TO
43658: IFFALSE 43738
// begin x := rand ( 1 , list [ 1 ] ) ;
43660: LD_ADDR_VAR 0 8
43664: PUSH
43665: LD_INT 1
43667: PPUSH
43668: LD_VAR 0 7
43672: PUSH
43673: LD_INT 1
43675: ARRAY
43676: PPUSH
43677: CALL_OW 12
43681: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43682: LD_ADDR_VAR 0 6
43686: PUSH
43687: LD_VAR 0 6
43691: PPUSH
43692: LD_VAR 0 5
43696: PPUSH
43697: LD_VAR 0 7
43701: PUSH
43702: LD_INT 1
43704: ARRAY
43705: PUSH
43706: LD_VAR 0 8
43710: ARRAY
43711: PUSH
43712: LD_VAR 0 7
43716: PUSH
43717: LD_INT 2
43719: ARRAY
43720: PUSH
43721: LD_VAR 0 8
43725: ARRAY
43726: PUSH
43727: EMPTY
43728: LIST
43729: LIST
43730: PPUSH
43731: CALL_OW 1
43735: ST_TO_ADDR
// end ;
43736: GO 43657
43738: POP
43739: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43740: LD_ADDR_EXP 89
43744: PUSH
43745: LD_EXP 89
43749: PPUSH
43750: LD_VAR 0 1
43754: PPUSH
43755: LD_VAR 0 6
43759: PPUSH
43760: CALL_OW 1
43764: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43765: LD_ADDR_EXP 91
43769: PUSH
43770: LD_EXP 91
43774: PPUSH
43775: LD_VAR 0 1
43779: PPUSH
43780: LD_VAR 0 3
43784: PPUSH
43785: CALL_OW 1
43789: ST_TO_ADDR
// end ;
43790: LD_VAR 0 4
43794: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
43795: LD_INT 0
43797: PPUSH
// if not mc_bases [ base ] then
43798: LD_EXP 76
43802: PUSH
43803: LD_VAR 0 1
43807: ARRAY
43808: NOT
43809: IFFALSE 43813
// exit ;
43811: GO 43838
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43813: LD_ADDR_EXP 81
43817: PUSH
43818: LD_EXP 81
43822: PPUSH
43823: LD_VAR 0 1
43827: PPUSH
43828: LD_VAR 0 2
43832: PPUSH
43833: CALL_OW 1
43837: ST_TO_ADDR
// end ;
43838: LD_VAR 0 3
43842: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43843: LD_INT 0
43845: PPUSH
// if not mc_bases [ base ] then
43846: LD_EXP 76
43850: PUSH
43851: LD_VAR 0 1
43855: ARRAY
43856: NOT
43857: IFFALSE 43861
// exit ;
43859: GO 43898
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43861: LD_ADDR_EXP 81
43865: PUSH
43866: LD_EXP 81
43870: PPUSH
43871: LD_VAR 0 1
43875: PPUSH
43876: LD_EXP 81
43880: PUSH
43881: LD_VAR 0 1
43885: ARRAY
43886: PUSH
43887: LD_VAR 0 2
43891: UNION
43892: PPUSH
43893: CALL_OW 1
43897: ST_TO_ADDR
// end ;
43898: LD_VAR 0 3
43902: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
43903: LD_INT 0
43905: PPUSH
// if not mc_bases [ base ] then
43906: LD_EXP 76
43910: PUSH
43911: LD_VAR 0 1
43915: ARRAY
43916: NOT
43917: IFFALSE 43921
// exit ;
43919: GO 43946
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
43921: LD_ADDR_EXP 97
43925: PUSH
43926: LD_EXP 97
43930: PPUSH
43931: LD_VAR 0 1
43935: PPUSH
43936: LD_VAR 0 2
43940: PPUSH
43941: CALL_OW 1
43945: ST_TO_ADDR
// end ;
43946: LD_VAR 0 3
43950: RET
// export function MC_InsertProduceList ( base , components ) ; begin
43951: LD_INT 0
43953: PPUSH
// if not mc_bases [ base ] then
43954: LD_EXP 76
43958: PUSH
43959: LD_VAR 0 1
43963: ARRAY
43964: NOT
43965: IFFALSE 43969
// exit ;
43967: GO 44006
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
43969: LD_ADDR_EXP 97
43973: PUSH
43974: LD_EXP 97
43978: PPUSH
43979: LD_VAR 0 1
43983: PPUSH
43984: LD_EXP 97
43988: PUSH
43989: LD_VAR 0 1
43993: ARRAY
43994: PUSH
43995: LD_VAR 0 2
43999: ADD
44000: PPUSH
44001: CALL_OW 1
44005: ST_TO_ADDR
// end ;
44006: LD_VAR 0 3
44010: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44011: LD_INT 0
44013: PPUSH
// if not mc_bases [ base ] then
44014: LD_EXP 76
44018: PUSH
44019: LD_VAR 0 1
44023: ARRAY
44024: NOT
44025: IFFALSE 44029
// exit ;
44027: GO 44083
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44029: LD_ADDR_EXP 98
44033: PUSH
44034: LD_EXP 98
44038: PPUSH
44039: LD_VAR 0 1
44043: PPUSH
44044: LD_VAR 0 2
44048: PPUSH
44049: CALL_OW 1
44053: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44054: LD_ADDR_EXP 87
44058: PUSH
44059: LD_EXP 87
44063: PPUSH
44064: LD_VAR 0 1
44068: PPUSH
44069: LD_VAR 0 2
44073: PUSH
44074: LD_INT 0
44076: PLUS
44077: PPUSH
44078: CALL_OW 1
44082: ST_TO_ADDR
// end ;
44083: LD_VAR 0 3
44087: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44088: LD_INT 0
44090: PPUSH
// if not mc_bases [ base ] then
44091: LD_EXP 76
44095: PUSH
44096: LD_VAR 0 1
44100: ARRAY
44101: NOT
44102: IFFALSE 44106
// exit ;
44104: GO 44131
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44106: LD_ADDR_EXP 87
44110: PUSH
44111: LD_EXP 87
44115: PPUSH
44116: LD_VAR 0 1
44120: PPUSH
44121: LD_VAR 0 2
44125: PPUSH
44126: CALL_OW 1
44130: ST_TO_ADDR
// end ;
44131: LD_VAR 0 3
44135: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44136: LD_INT 0
44138: PPUSH
44139: PPUSH
44140: PPUSH
44141: PPUSH
// if not mc_bases [ base ] then
44142: LD_EXP 76
44146: PUSH
44147: LD_VAR 0 1
44151: ARRAY
44152: NOT
44153: IFFALSE 44157
// exit ;
44155: GO 44222
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44157: LD_ADDR_EXP 96
44161: PUSH
44162: LD_EXP 96
44166: PPUSH
44167: LD_VAR 0 1
44171: PUSH
44172: LD_EXP 96
44176: PUSH
44177: LD_VAR 0 1
44181: ARRAY
44182: PUSH
44183: LD_INT 1
44185: PLUS
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PPUSH
44191: LD_VAR 0 1
44195: PUSH
44196: LD_VAR 0 2
44200: PUSH
44201: LD_VAR 0 3
44205: PUSH
44206: LD_VAR 0 4
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: LIST
44215: LIST
44216: PPUSH
44217: CALL 57532 0 3
44221: ST_TO_ADDR
// end ;
44222: LD_VAR 0 5
44226: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44227: LD_INT 0
44229: PPUSH
// if not mc_bases [ base ] then
44230: LD_EXP 76
44234: PUSH
44235: LD_VAR 0 1
44239: ARRAY
44240: NOT
44241: IFFALSE 44245
// exit ;
44243: GO 44270
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44245: LD_ADDR_EXP 113
44249: PUSH
44250: LD_EXP 113
44254: PPUSH
44255: LD_VAR 0 1
44259: PPUSH
44260: LD_VAR 0 2
44264: PPUSH
44265: CALL_OW 1
44269: ST_TO_ADDR
// end ;
44270: LD_VAR 0 3
44274: RET
// export function MC_GetMinesField ( base ) ; begin
44275: LD_INT 0
44277: PPUSH
// result := mc_mines [ base ] ;
44278: LD_ADDR_VAR 0 2
44282: PUSH
44283: LD_EXP 89
44287: PUSH
44288: LD_VAR 0 1
44292: ARRAY
44293: ST_TO_ADDR
// end ;
44294: LD_VAR 0 2
44298: RET
// export function MC_GetProduceList ( base ) ; begin
44299: LD_INT 0
44301: PPUSH
// result := mc_produce [ base ] ;
44302: LD_ADDR_VAR 0 2
44306: PUSH
44307: LD_EXP 97
44311: PUSH
44312: LD_VAR 0 1
44316: ARRAY
44317: ST_TO_ADDR
// end ;
44318: LD_VAR 0 2
44322: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44323: LD_INT 0
44325: PPUSH
44326: PPUSH
// if not mc_bases then
44327: LD_EXP 76
44331: NOT
44332: IFFALSE 44336
// exit ;
44334: GO 44401
// if mc_bases [ base ] then
44336: LD_EXP 76
44340: PUSH
44341: LD_VAR 0 1
44345: ARRAY
44346: IFFALSE 44401
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44348: LD_ADDR_VAR 0 3
44352: PUSH
44353: LD_EXP 76
44357: PUSH
44358: LD_VAR 0 1
44362: ARRAY
44363: PPUSH
44364: LD_INT 30
44366: PUSH
44367: LD_VAR 0 2
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: PPUSH
44376: CALL_OW 72
44380: ST_TO_ADDR
// if result then
44381: LD_VAR 0 3
44385: IFFALSE 44401
// result := result [ 1 ] ;
44387: LD_ADDR_VAR 0 3
44391: PUSH
44392: LD_VAR 0 3
44396: PUSH
44397: LD_INT 1
44399: ARRAY
44400: ST_TO_ADDR
// end ; end ;
44401: LD_VAR 0 3
44405: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44406: LD_INT 0
44408: PPUSH
44409: PPUSH
// if not mc_bases then
44410: LD_EXP 76
44414: NOT
44415: IFFALSE 44419
// exit ;
44417: GO 44464
// if mc_bases [ base ] then
44419: LD_EXP 76
44423: PUSH
44424: LD_VAR 0 1
44428: ARRAY
44429: IFFALSE 44464
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44431: LD_ADDR_VAR 0 3
44435: PUSH
44436: LD_EXP 76
44440: PUSH
44441: LD_VAR 0 1
44445: ARRAY
44446: PPUSH
44447: LD_INT 30
44449: PUSH
44450: LD_VAR 0 2
44454: PUSH
44455: EMPTY
44456: LIST
44457: LIST
44458: PPUSH
44459: CALL_OW 72
44463: ST_TO_ADDR
// end ;
44464: LD_VAR 0 3
44468: RET
// export function MC_SetTame ( base , area ) ; begin
44469: LD_INT 0
44471: PPUSH
// if not mc_bases or not base then
44472: LD_EXP 76
44476: NOT
44477: PUSH
44478: LD_VAR 0 1
44482: NOT
44483: OR
44484: IFFALSE 44488
// exit ;
44486: GO 44513
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44488: LD_ADDR_EXP 104
44492: PUSH
44493: LD_EXP 104
44497: PPUSH
44498: LD_VAR 0 1
44502: PPUSH
44503: LD_VAR 0 2
44507: PPUSH
44508: CALL_OW 1
44512: ST_TO_ADDR
// end ;
44513: LD_VAR 0 3
44517: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44518: LD_INT 0
44520: PPUSH
44521: PPUSH
// if not mc_bases or not base then
44522: LD_EXP 76
44526: NOT
44527: PUSH
44528: LD_VAR 0 1
44532: NOT
44533: OR
44534: IFFALSE 44538
// exit ;
44536: GO 44640
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44538: LD_ADDR_VAR 0 4
44542: PUSH
44543: LD_EXP 76
44547: PUSH
44548: LD_VAR 0 1
44552: ARRAY
44553: PPUSH
44554: LD_INT 30
44556: PUSH
44557: LD_VAR 0 2
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PPUSH
44566: CALL_OW 72
44570: ST_TO_ADDR
// if not tmp then
44571: LD_VAR 0 4
44575: NOT
44576: IFFALSE 44580
// exit ;
44578: GO 44640
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44580: LD_ADDR_EXP 108
44584: PUSH
44585: LD_EXP 108
44589: PPUSH
44590: LD_VAR 0 1
44594: PPUSH
44595: LD_EXP 108
44599: PUSH
44600: LD_VAR 0 1
44604: ARRAY
44605: PPUSH
44606: LD_EXP 108
44610: PUSH
44611: LD_VAR 0 1
44615: ARRAY
44616: PUSH
44617: LD_INT 1
44619: PLUS
44620: PPUSH
44621: LD_VAR 0 4
44625: PUSH
44626: LD_INT 1
44628: ARRAY
44629: PPUSH
44630: CALL_OW 2
44634: PPUSH
44635: CALL_OW 1
44639: ST_TO_ADDR
// end ;
44640: LD_VAR 0 3
44644: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44645: LD_INT 0
44647: PPUSH
44648: PPUSH
// if not mc_bases or not base or not kinds then
44649: LD_EXP 76
44653: NOT
44654: PUSH
44655: LD_VAR 0 1
44659: NOT
44660: OR
44661: PUSH
44662: LD_VAR 0 2
44666: NOT
44667: OR
44668: IFFALSE 44672
// exit ;
44670: GO 44733
// for i in kinds do
44672: LD_ADDR_VAR 0 4
44676: PUSH
44677: LD_VAR 0 2
44681: PUSH
44682: FOR_IN
44683: IFFALSE 44731
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44685: LD_ADDR_EXP 110
44689: PUSH
44690: LD_EXP 110
44694: PPUSH
44695: LD_VAR 0 1
44699: PUSH
44700: LD_EXP 110
44704: PUSH
44705: LD_VAR 0 1
44709: ARRAY
44710: PUSH
44711: LD_INT 1
44713: PLUS
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PPUSH
44719: LD_VAR 0 4
44723: PPUSH
44724: CALL 57532 0 3
44728: ST_TO_ADDR
44729: GO 44682
44731: POP
44732: POP
// end ;
44733: LD_VAR 0 3
44737: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44738: LD_INT 0
44740: PPUSH
// if not mc_bases or not base or not areas then
44741: LD_EXP 76
44745: NOT
44746: PUSH
44747: LD_VAR 0 1
44751: NOT
44752: OR
44753: PUSH
44754: LD_VAR 0 2
44758: NOT
44759: OR
44760: IFFALSE 44764
// exit ;
44762: GO 44789
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44764: LD_ADDR_EXP 94
44768: PUSH
44769: LD_EXP 94
44773: PPUSH
44774: LD_VAR 0 1
44778: PPUSH
44779: LD_VAR 0 2
44783: PPUSH
44784: CALL_OW 1
44788: ST_TO_ADDR
// end ;
44789: LD_VAR 0 3
44793: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
44794: LD_INT 0
44796: PPUSH
// if not mc_bases or not base or not teleports_exit then
44797: LD_EXP 76
44801: NOT
44802: PUSH
44803: LD_VAR 0 1
44807: NOT
44808: OR
44809: PUSH
44810: LD_VAR 0 2
44814: NOT
44815: OR
44816: IFFALSE 44820
// exit ;
44818: GO 44845
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44820: LD_ADDR_EXP 111
44824: PUSH
44825: LD_EXP 111
44829: PPUSH
44830: LD_VAR 0 1
44834: PPUSH
44835: LD_VAR 0 2
44839: PPUSH
44840: CALL_OW 1
44844: ST_TO_ADDR
// end ;
44845: LD_VAR 0 3
44849: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44850: LD_INT 0
44852: PPUSH
44853: PPUSH
44854: PPUSH
// if not mc_bases or not base or not ext_list then
44855: LD_EXP 76
44859: NOT
44860: PUSH
44861: LD_VAR 0 1
44865: NOT
44866: OR
44867: PUSH
44868: LD_VAR 0 5
44872: NOT
44873: OR
44874: IFFALSE 44878
// exit ;
44876: GO 45051
// tmp := GetFacExtXYD ( x , y , d ) ;
44878: LD_ADDR_VAR 0 8
44882: PUSH
44883: LD_VAR 0 2
44887: PPUSH
44888: LD_VAR 0 3
44892: PPUSH
44893: LD_VAR 0 4
44897: PPUSH
44898: CALL 90936 0 3
44902: ST_TO_ADDR
// if not tmp then
44903: LD_VAR 0 8
44907: NOT
44908: IFFALSE 44912
// exit ;
44910: GO 45051
// for i in tmp do
44912: LD_ADDR_VAR 0 7
44916: PUSH
44917: LD_VAR 0 8
44921: PUSH
44922: FOR_IN
44923: IFFALSE 45049
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
44925: LD_ADDR_EXP 81
44929: PUSH
44930: LD_EXP 81
44934: PPUSH
44935: LD_VAR 0 1
44939: PPUSH
44940: LD_EXP 81
44944: PUSH
44945: LD_VAR 0 1
44949: ARRAY
44950: PPUSH
44951: LD_EXP 81
44955: PUSH
44956: LD_VAR 0 1
44960: ARRAY
44961: PUSH
44962: LD_INT 1
44964: PLUS
44965: PPUSH
44966: LD_VAR 0 5
44970: PUSH
44971: LD_INT 1
44973: ARRAY
44974: PUSH
44975: LD_VAR 0 7
44979: PUSH
44980: LD_INT 1
44982: ARRAY
44983: PUSH
44984: LD_VAR 0 7
44988: PUSH
44989: LD_INT 2
44991: ARRAY
44992: PUSH
44993: LD_VAR 0 7
44997: PUSH
44998: LD_INT 3
45000: ARRAY
45001: PUSH
45002: EMPTY
45003: LIST
45004: LIST
45005: LIST
45006: LIST
45007: PPUSH
45008: CALL_OW 2
45012: PPUSH
45013: CALL_OW 1
45017: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45018: LD_ADDR_VAR 0 5
45022: PUSH
45023: LD_VAR 0 5
45027: PPUSH
45028: LD_INT 1
45030: PPUSH
45031: CALL_OW 3
45035: ST_TO_ADDR
// if not ext_list then
45036: LD_VAR 0 5
45040: NOT
45041: IFFALSE 45047
// exit ;
45043: POP
45044: POP
45045: GO 45051
// end ;
45047: GO 44922
45049: POP
45050: POP
// end ;
45051: LD_VAR 0 6
45055: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45056: LD_INT 0
45058: PPUSH
// if not mc_bases or not base or not weapon_list then
45059: LD_EXP 76
45063: NOT
45064: PUSH
45065: LD_VAR 0 1
45069: NOT
45070: OR
45071: PUSH
45072: LD_VAR 0 2
45076: NOT
45077: OR
45078: IFFALSE 45082
// exit ;
45080: GO 45107
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45082: LD_ADDR_EXP 115
45086: PUSH
45087: LD_EXP 115
45091: PPUSH
45092: LD_VAR 0 1
45096: PPUSH
45097: LD_VAR 0 2
45101: PPUSH
45102: CALL_OW 1
45106: ST_TO_ADDR
// end ;
45107: LD_VAR 0 3
45111: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45112: LD_INT 0
45114: PPUSH
// if not mc_bases or not base or not tech_list then
45115: LD_EXP 76
45119: NOT
45120: PUSH
45121: LD_VAR 0 1
45125: NOT
45126: OR
45127: PUSH
45128: LD_VAR 0 2
45132: NOT
45133: OR
45134: IFFALSE 45138
// exit ;
45136: GO 45163
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45138: LD_ADDR_EXP 103
45142: PUSH
45143: LD_EXP 103
45147: PPUSH
45148: LD_VAR 0 1
45152: PPUSH
45153: LD_VAR 0 2
45157: PPUSH
45158: CALL_OW 1
45162: ST_TO_ADDR
// end ;
45163: LD_VAR 0 3
45167: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45168: LD_INT 0
45170: PPUSH
// if not mc_bases or not parking_area or not base then
45171: LD_EXP 76
45175: NOT
45176: PUSH
45177: LD_VAR 0 2
45181: NOT
45182: OR
45183: PUSH
45184: LD_VAR 0 1
45188: NOT
45189: OR
45190: IFFALSE 45194
// exit ;
45192: GO 45219
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45194: LD_ADDR_EXP 100
45198: PUSH
45199: LD_EXP 100
45203: PPUSH
45204: LD_VAR 0 1
45208: PPUSH
45209: LD_VAR 0 2
45213: PPUSH
45214: CALL_OW 1
45218: ST_TO_ADDR
// end ;
45219: LD_VAR 0 3
45223: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45224: LD_INT 0
45226: PPUSH
// if not mc_bases or not base or not scan_area then
45227: LD_EXP 76
45231: NOT
45232: PUSH
45233: LD_VAR 0 1
45237: NOT
45238: OR
45239: PUSH
45240: LD_VAR 0 2
45244: NOT
45245: OR
45246: IFFALSE 45250
// exit ;
45248: GO 45275
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45250: LD_ADDR_EXP 101
45254: PUSH
45255: LD_EXP 101
45259: PPUSH
45260: LD_VAR 0 1
45264: PPUSH
45265: LD_VAR 0 2
45269: PPUSH
45270: CALL_OW 1
45274: ST_TO_ADDR
// end ;
45275: LD_VAR 0 3
45279: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45280: LD_INT 0
45282: PPUSH
45283: PPUSH
// if not mc_bases or not base then
45284: LD_EXP 76
45288: NOT
45289: PUSH
45290: LD_VAR 0 1
45294: NOT
45295: OR
45296: IFFALSE 45300
// exit ;
45298: GO 45364
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45300: LD_ADDR_VAR 0 3
45304: PUSH
45305: LD_INT 1
45307: PUSH
45308: LD_INT 2
45310: PUSH
45311: LD_INT 3
45313: PUSH
45314: LD_INT 4
45316: PUSH
45317: LD_INT 11
45319: PUSH
45320: EMPTY
45321: LIST
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45327: LD_ADDR_EXP 103
45331: PUSH
45332: LD_EXP 103
45336: PPUSH
45337: LD_VAR 0 1
45341: PPUSH
45342: LD_EXP 103
45346: PUSH
45347: LD_VAR 0 1
45351: ARRAY
45352: PUSH
45353: LD_VAR 0 3
45357: DIFF
45358: PPUSH
45359: CALL_OW 1
45363: ST_TO_ADDR
// end ;
45364: LD_VAR 0 2
45368: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45369: LD_INT 0
45371: PPUSH
// result := mc_vehicles [ base ] ;
45372: LD_ADDR_VAR 0 3
45376: PUSH
45377: LD_EXP 95
45381: PUSH
45382: LD_VAR 0 1
45386: ARRAY
45387: ST_TO_ADDR
// if onlyCombat then
45388: LD_VAR 0 2
45392: IFFALSE 45557
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45394: LD_ADDR_VAR 0 3
45398: PUSH
45399: LD_VAR 0 3
45403: PUSH
45404: LD_VAR 0 3
45408: PPUSH
45409: LD_INT 2
45411: PUSH
45412: LD_INT 34
45414: PUSH
45415: LD_INT 12
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 34
45424: PUSH
45425: LD_INT 51
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 34
45434: PUSH
45435: LD_EXP 70
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: PUSH
45444: LD_INT 34
45446: PUSH
45447: LD_INT 32
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: LD_INT 34
45456: PUSH
45457: LD_INT 13
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: PUSH
45464: LD_INT 34
45466: PUSH
45467: LD_INT 52
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: PUSH
45474: LD_INT 34
45476: PUSH
45477: LD_INT 14
45479: PUSH
45480: EMPTY
45481: LIST
45482: LIST
45483: PUSH
45484: LD_INT 34
45486: PUSH
45487: LD_INT 53
45489: PUSH
45490: EMPTY
45491: LIST
45492: LIST
45493: PUSH
45494: LD_INT 34
45496: PUSH
45497: LD_EXP 69
45501: PUSH
45502: EMPTY
45503: LIST
45504: LIST
45505: PUSH
45506: LD_INT 34
45508: PUSH
45509: LD_INT 31
45511: PUSH
45512: EMPTY
45513: LIST
45514: LIST
45515: PUSH
45516: LD_INT 34
45518: PUSH
45519: LD_INT 48
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: PUSH
45526: LD_INT 34
45528: PUSH
45529: LD_INT 8
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: PPUSH
45551: CALL_OW 72
45555: DIFF
45556: ST_TO_ADDR
// end ; end_of_file
45557: LD_VAR 0 3
45561: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45562: LD_INT 0
45564: PPUSH
45565: PPUSH
45566: PPUSH
// if not mc_bases or not skirmish then
45567: LD_EXP 76
45571: NOT
45572: PUSH
45573: LD_EXP 74
45577: NOT
45578: OR
45579: IFFALSE 45583
// exit ;
45581: GO 45748
// for i = 1 to mc_bases do
45583: LD_ADDR_VAR 0 4
45587: PUSH
45588: DOUBLE
45589: LD_INT 1
45591: DEC
45592: ST_TO_ADDR
45593: LD_EXP 76
45597: PUSH
45598: FOR_TO
45599: IFFALSE 45746
// begin if sci in mc_bases [ i ] then
45601: LD_VAR 0 2
45605: PUSH
45606: LD_EXP 76
45610: PUSH
45611: LD_VAR 0 4
45615: ARRAY
45616: IN
45617: IFFALSE 45744
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45619: LD_ADDR_EXP 105
45623: PUSH
45624: LD_EXP 105
45628: PPUSH
45629: LD_VAR 0 4
45633: PUSH
45634: LD_EXP 105
45638: PUSH
45639: LD_VAR 0 4
45643: ARRAY
45644: PUSH
45645: LD_INT 1
45647: PLUS
45648: PUSH
45649: EMPTY
45650: LIST
45651: LIST
45652: PPUSH
45653: LD_VAR 0 1
45657: PPUSH
45658: CALL 57532 0 3
45662: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45663: LD_ADDR_VAR 0 5
45667: PUSH
45668: LD_EXP 76
45672: PUSH
45673: LD_VAR 0 4
45677: ARRAY
45678: PPUSH
45679: LD_INT 2
45681: PUSH
45682: LD_INT 30
45684: PUSH
45685: LD_INT 0
45687: PUSH
45688: EMPTY
45689: LIST
45690: LIST
45691: PUSH
45692: LD_INT 30
45694: PUSH
45695: LD_INT 1
45697: PUSH
45698: EMPTY
45699: LIST
45700: LIST
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: LIST
45706: PPUSH
45707: CALL_OW 72
45711: PPUSH
45712: LD_VAR 0 1
45716: PPUSH
45717: CALL_OW 74
45721: ST_TO_ADDR
// if tmp then
45722: LD_VAR 0 5
45726: IFFALSE 45742
// ComStandNearbyBuilding ( ape , tmp ) ;
45728: LD_VAR 0 1
45732: PPUSH
45733: LD_VAR 0 5
45737: PPUSH
45738: CALL 51735 0 2
// break ;
45742: GO 45746
// end ; end ;
45744: GO 45598
45746: POP
45747: POP
// end ;
45748: LD_VAR 0 3
45752: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45753: LD_INT 0
45755: PPUSH
45756: PPUSH
45757: PPUSH
// if not mc_bases or not skirmish then
45758: LD_EXP 76
45762: NOT
45763: PUSH
45764: LD_EXP 74
45768: NOT
45769: OR
45770: IFFALSE 45774
// exit ;
45772: GO 45863
// for i = 1 to mc_bases do
45774: LD_ADDR_VAR 0 4
45778: PUSH
45779: DOUBLE
45780: LD_INT 1
45782: DEC
45783: ST_TO_ADDR
45784: LD_EXP 76
45788: PUSH
45789: FOR_TO
45790: IFFALSE 45861
// begin if building in mc_busy_turret_list [ i ] then
45792: LD_VAR 0 1
45796: PUSH
45797: LD_EXP 86
45801: PUSH
45802: LD_VAR 0 4
45806: ARRAY
45807: IN
45808: IFFALSE 45859
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45810: LD_ADDR_VAR 0 5
45814: PUSH
45815: LD_EXP 86
45819: PUSH
45820: LD_VAR 0 4
45824: ARRAY
45825: PUSH
45826: LD_VAR 0 1
45830: DIFF
45831: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45832: LD_ADDR_EXP 86
45836: PUSH
45837: LD_EXP 86
45841: PPUSH
45842: LD_VAR 0 4
45846: PPUSH
45847: LD_VAR 0 5
45851: PPUSH
45852: CALL_OW 1
45856: ST_TO_ADDR
// break ;
45857: GO 45861
// end ; end ;
45859: GO 45789
45861: POP
45862: POP
// end ;
45863: LD_VAR 0 3
45867: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45868: LD_INT 0
45870: PPUSH
45871: PPUSH
45872: PPUSH
// if not mc_bases or not skirmish then
45873: LD_EXP 76
45877: NOT
45878: PUSH
45879: LD_EXP 74
45883: NOT
45884: OR
45885: IFFALSE 45889
// exit ;
45887: GO 46088
// for i = 1 to mc_bases do
45889: LD_ADDR_VAR 0 5
45893: PUSH
45894: DOUBLE
45895: LD_INT 1
45897: DEC
45898: ST_TO_ADDR
45899: LD_EXP 76
45903: PUSH
45904: FOR_TO
45905: IFFALSE 46086
// if building in mc_bases [ i ] then
45907: LD_VAR 0 1
45911: PUSH
45912: LD_EXP 76
45916: PUSH
45917: LD_VAR 0 5
45921: ARRAY
45922: IN
45923: IFFALSE 46084
// begin tmp := mc_bases [ i ] diff building ;
45925: LD_ADDR_VAR 0 6
45929: PUSH
45930: LD_EXP 76
45934: PUSH
45935: LD_VAR 0 5
45939: ARRAY
45940: PUSH
45941: LD_VAR 0 1
45945: DIFF
45946: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
45947: LD_ADDR_EXP 76
45951: PUSH
45952: LD_EXP 76
45956: PPUSH
45957: LD_VAR 0 5
45961: PPUSH
45962: LD_VAR 0 6
45966: PPUSH
45967: CALL_OW 1
45971: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
45972: LD_VAR 0 1
45976: PUSH
45977: LD_EXP 84
45981: PUSH
45982: LD_VAR 0 5
45986: ARRAY
45987: IN
45988: IFFALSE 46027
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
45990: LD_ADDR_EXP 84
45994: PUSH
45995: LD_EXP 84
45999: PPUSH
46000: LD_VAR 0 5
46004: PPUSH
46005: LD_EXP 84
46009: PUSH
46010: LD_VAR 0 5
46014: ARRAY
46015: PUSH
46016: LD_VAR 0 1
46020: DIFF
46021: PPUSH
46022: CALL_OW 1
46026: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46027: LD_VAR 0 1
46031: PUSH
46032: LD_EXP 85
46036: PUSH
46037: LD_VAR 0 5
46041: ARRAY
46042: IN
46043: IFFALSE 46082
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46045: LD_ADDR_EXP 85
46049: PUSH
46050: LD_EXP 85
46054: PPUSH
46055: LD_VAR 0 5
46059: PPUSH
46060: LD_EXP 85
46064: PUSH
46065: LD_VAR 0 5
46069: ARRAY
46070: PUSH
46071: LD_VAR 0 1
46075: DIFF
46076: PPUSH
46077: CALL_OW 1
46081: ST_TO_ADDR
// break ;
46082: GO 46086
// end ;
46084: GO 45904
46086: POP
46087: POP
// end ;
46088: LD_VAR 0 4
46092: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46093: LD_INT 0
46095: PPUSH
46096: PPUSH
46097: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46098: LD_EXP 76
46102: NOT
46103: PUSH
46104: LD_EXP 74
46108: NOT
46109: OR
46110: PUSH
46111: LD_VAR 0 3
46115: PUSH
46116: LD_EXP 102
46120: IN
46121: NOT
46122: OR
46123: IFFALSE 46127
// exit ;
46125: GO 46250
// for i = 1 to mc_vehicles do
46127: LD_ADDR_VAR 0 6
46131: PUSH
46132: DOUBLE
46133: LD_INT 1
46135: DEC
46136: ST_TO_ADDR
46137: LD_EXP 95
46141: PUSH
46142: FOR_TO
46143: IFFALSE 46248
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46145: LD_VAR 0 2
46149: PUSH
46150: LD_EXP 95
46154: PUSH
46155: LD_VAR 0 6
46159: ARRAY
46160: IN
46161: PUSH
46162: LD_VAR 0 1
46166: PUSH
46167: LD_EXP 95
46171: PUSH
46172: LD_VAR 0 6
46176: ARRAY
46177: IN
46178: OR
46179: IFFALSE 46246
// begin tmp := mc_vehicles [ i ] diff old ;
46181: LD_ADDR_VAR 0 7
46185: PUSH
46186: LD_EXP 95
46190: PUSH
46191: LD_VAR 0 6
46195: ARRAY
46196: PUSH
46197: LD_VAR 0 2
46201: DIFF
46202: ST_TO_ADDR
// tmp := tmp diff new ;
46203: LD_ADDR_VAR 0 7
46207: PUSH
46208: LD_VAR 0 7
46212: PUSH
46213: LD_VAR 0 1
46217: DIFF
46218: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46219: LD_ADDR_EXP 95
46223: PUSH
46224: LD_EXP 95
46228: PPUSH
46229: LD_VAR 0 6
46233: PPUSH
46234: LD_VAR 0 7
46238: PPUSH
46239: CALL_OW 1
46243: ST_TO_ADDR
// break ;
46244: GO 46248
// end ;
46246: GO 46142
46248: POP
46249: POP
// end ;
46250: LD_VAR 0 5
46254: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46255: LD_INT 0
46257: PPUSH
46258: PPUSH
46259: PPUSH
46260: PPUSH
// if not mc_bases or not skirmish then
46261: LD_EXP 76
46265: NOT
46266: PUSH
46267: LD_EXP 74
46271: NOT
46272: OR
46273: IFFALSE 46277
// exit ;
46275: GO 46654
// side := GetSide ( vehicle ) ;
46277: LD_ADDR_VAR 0 5
46281: PUSH
46282: LD_VAR 0 1
46286: PPUSH
46287: CALL_OW 255
46291: ST_TO_ADDR
// for i = 1 to mc_bases do
46292: LD_ADDR_VAR 0 4
46296: PUSH
46297: DOUBLE
46298: LD_INT 1
46300: DEC
46301: ST_TO_ADDR
46302: LD_EXP 76
46306: PUSH
46307: FOR_TO
46308: IFFALSE 46652
// begin if factory in mc_bases [ i ] then
46310: LD_VAR 0 2
46314: PUSH
46315: LD_EXP 76
46319: PUSH
46320: LD_VAR 0 4
46324: ARRAY
46325: IN
46326: IFFALSE 46650
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46328: LD_EXP 98
46332: PUSH
46333: LD_VAR 0 4
46337: ARRAY
46338: PUSH
46339: LD_EXP 87
46343: PUSH
46344: LD_VAR 0 4
46348: ARRAY
46349: LESS
46350: PUSH
46351: LD_VAR 0 1
46355: PPUSH
46356: CALL_OW 264
46360: PUSH
46361: LD_INT 31
46363: PUSH
46364: LD_INT 32
46366: PUSH
46367: LD_INT 51
46369: PUSH
46370: LD_EXP 70
46374: PUSH
46375: LD_INT 12
46377: PUSH
46378: LD_INT 30
46380: PUSH
46381: LD_EXP 69
46385: PUSH
46386: LD_INT 11
46388: PUSH
46389: LD_INT 53
46391: PUSH
46392: LD_INT 14
46394: PUSH
46395: LD_EXP 73
46399: PUSH
46400: LD_INT 29
46402: PUSH
46403: LD_EXP 71
46407: PUSH
46408: LD_INT 13
46410: PUSH
46411: LD_INT 52
46413: PUSH
46414: LD_INT 48
46416: PUSH
46417: LD_INT 8
46419: PUSH
46420: EMPTY
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: LIST
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: LIST
46436: LIST
46437: LIST
46438: IN
46439: NOT
46440: AND
46441: IFFALSE 46489
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46443: LD_ADDR_EXP 98
46447: PUSH
46448: LD_EXP 98
46452: PPUSH
46453: LD_VAR 0 4
46457: PUSH
46458: LD_EXP 98
46462: PUSH
46463: LD_VAR 0 4
46467: ARRAY
46468: PUSH
46469: LD_INT 1
46471: PLUS
46472: PUSH
46473: EMPTY
46474: LIST
46475: LIST
46476: PPUSH
46477: LD_VAR 0 1
46481: PPUSH
46482: CALL 57532 0 3
46486: ST_TO_ADDR
46487: GO 46533
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46489: LD_ADDR_EXP 95
46493: PUSH
46494: LD_EXP 95
46498: PPUSH
46499: LD_VAR 0 4
46503: PUSH
46504: LD_EXP 95
46508: PUSH
46509: LD_VAR 0 4
46513: ARRAY
46514: PUSH
46515: LD_INT 1
46517: PLUS
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PPUSH
46523: LD_VAR 0 1
46527: PPUSH
46528: CALL 57532 0 3
46532: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46533: LD_VAR 0 1
46537: PPUSH
46538: CALL_OW 263
46542: PUSH
46543: LD_INT 2
46545: EQUAL
46546: IFFALSE 46566
// begin repeat wait ( 0 0$1 ) ;
46548: LD_INT 35
46550: PPUSH
46551: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46555: LD_VAR 0 1
46559: PPUSH
46560: CALL_OW 312
46564: IFFALSE 46548
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46566: LD_VAR 0 1
46570: PPUSH
46571: LD_EXP 100
46575: PUSH
46576: LD_VAR 0 4
46580: ARRAY
46581: PPUSH
46582: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46586: LD_VAR 0 1
46590: PPUSH
46591: CALL_OW 263
46595: PUSH
46596: LD_INT 1
46598: NONEQUAL
46599: IFFALSE 46603
// break ;
46601: GO 46652
// repeat wait ( 0 0$1 ) ;
46603: LD_INT 35
46605: PPUSH
46606: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46610: LD_VAR 0 1
46614: PPUSH
46615: LD_EXP 100
46619: PUSH
46620: LD_VAR 0 4
46624: ARRAY
46625: PPUSH
46626: CALL_OW 308
46630: IFFALSE 46603
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46632: LD_VAR 0 1
46636: PPUSH
46637: CALL_OW 311
46641: PPUSH
46642: CALL_OW 121
// exit ;
46646: POP
46647: POP
46648: GO 46654
// end ; end ;
46650: GO 46307
46652: POP
46653: POP
// end ;
46654: LD_VAR 0 3
46658: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46659: LD_INT 0
46661: PPUSH
46662: PPUSH
46663: PPUSH
46664: PPUSH
// if not mc_bases or not skirmish then
46665: LD_EXP 76
46669: NOT
46670: PUSH
46671: LD_EXP 74
46675: NOT
46676: OR
46677: IFFALSE 46681
// exit ;
46679: GO 47034
// repeat wait ( 0 0$1 ) ;
46681: LD_INT 35
46683: PPUSH
46684: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46688: LD_VAR 0 2
46692: PPUSH
46693: LD_VAR 0 3
46697: PPUSH
46698: CALL_OW 284
46702: IFFALSE 46681
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46704: LD_VAR 0 2
46708: PPUSH
46709: LD_VAR 0 3
46713: PPUSH
46714: CALL_OW 283
46718: PUSH
46719: LD_INT 4
46721: EQUAL
46722: IFFALSE 46726
// exit ;
46724: GO 47034
// for i = 1 to mc_bases do
46726: LD_ADDR_VAR 0 7
46730: PUSH
46731: DOUBLE
46732: LD_INT 1
46734: DEC
46735: ST_TO_ADDR
46736: LD_EXP 76
46740: PUSH
46741: FOR_TO
46742: IFFALSE 47032
// begin if mc_crates_area [ i ] then
46744: LD_EXP 94
46748: PUSH
46749: LD_VAR 0 7
46753: ARRAY
46754: IFFALSE 46865
// for j in mc_crates_area [ i ] do
46756: LD_ADDR_VAR 0 8
46760: PUSH
46761: LD_EXP 94
46765: PUSH
46766: LD_VAR 0 7
46770: ARRAY
46771: PUSH
46772: FOR_IN
46773: IFFALSE 46863
// if InArea ( x , y , j ) then
46775: LD_VAR 0 2
46779: PPUSH
46780: LD_VAR 0 3
46784: PPUSH
46785: LD_VAR 0 8
46789: PPUSH
46790: CALL_OW 309
46794: IFFALSE 46861
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46796: LD_ADDR_EXP 92
46800: PUSH
46801: LD_EXP 92
46805: PPUSH
46806: LD_VAR 0 7
46810: PUSH
46811: LD_EXP 92
46815: PUSH
46816: LD_VAR 0 7
46820: ARRAY
46821: PUSH
46822: LD_INT 1
46824: PLUS
46825: PUSH
46826: EMPTY
46827: LIST
46828: LIST
46829: PPUSH
46830: LD_VAR 0 4
46834: PUSH
46835: LD_VAR 0 2
46839: PUSH
46840: LD_VAR 0 3
46844: PUSH
46845: EMPTY
46846: LIST
46847: LIST
46848: LIST
46849: PPUSH
46850: CALL 57532 0 3
46854: ST_TO_ADDR
// exit ;
46855: POP
46856: POP
46857: POP
46858: POP
46859: GO 47034
// end ;
46861: GO 46772
46863: POP
46864: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46865: LD_ADDR_VAR 0 9
46869: PUSH
46870: LD_EXP 76
46874: PUSH
46875: LD_VAR 0 7
46879: ARRAY
46880: PPUSH
46881: LD_INT 2
46883: PUSH
46884: LD_INT 30
46886: PUSH
46887: LD_INT 0
46889: PUSH
46890: EMPTY
46891: LIST
46892: LIST
46893: PUSH
46894: LD_INT 30
46896: PUSH
46897: LD_INT 1
46899: PUSH
46900: EMPTY
46901: LIST
46902: LIST
46903: PUSH
46904: EMPTY
46905: LIST
46906: LIST
46907: LIST
46908: PPUSH
46909: CALL_OW 72
46913: ST_TO_ADDR
// if not depot then
46914: LD_VAR 0 9
46918: NOT
46919: IFFALSE 46923
// continue ;
46921: GO 46741
// for j in depot do
46923: LD_ADDR_VAR 0 8
46927: PUSH
46928: LD_VAR 0 9
46932: PUSH
46933: FOR_IN
46934: IFFALSE 47028
// if GetDistUnitXY ( j , x , y ) < 30 then
46936: LD_VAR 0 8
46940: PPUSH
46941: LD_VAR 0 2
46945: PPUSH
46946: LD_VAR 0 3
46950: PPUSH
46951: CALL_OW 297
46955: PUSH
46956: LD_INT 30
46958: LESS
46959: IFFALSE 47026
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46961: LD_ADDR_EXP 92
46965: PUSH
46966: LD_EXP 92
46970: PPUSH
46971: LD_VAR 0 7
46975: PUSH
46976: LD_EXP 92
46980: PUSH
46981: LD_VAR 0 7
46985: ARRAY
46986: PUSH
46987: LD_INT 1
46989: PLUS
46990: PUSH
46991: EMPTY
46992: LIST
46993: LIST
46994: PPUSH
46995: LD_VAR 0 4
46999: PUSH
47000: LD_VAR 0 2
47004: PUSH
47005: LD_VAR 0 3
47009: PUSH
47010: EMPTY
47011: LIST
47012: LIST
47013: LIST
47014: PPUSH
47015: CALL 57532 0 3
47019: ST_TO_ADDR
// exit ;
47020: POP
47021: POP
47022: POP
47023: POP
47024: GO 47034
// end ;
47026: GO 46933
47028: POP
47029: POP
// end ;
47030: GO 46741
47032: POP
47033: POP
// end ;
47034: LD_VAR 0 6
47038: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47039: LD_INT 0
47041: PPUSH
47042: PPUSH
47043: PPUSH
47044: PPUSH
// if not mc_bases or not skirmish then
47045: LD_EXP 76
47049: NOT
47050: PUSH
47051: LD_EXP 74
47055: NOT
47056: OR
47057: IFFALSE 47061
// exit ;
47059: GO 47338
// side := GetSide ( lab ) ;
47061: LD_ADDR_VAR 0 4
47065: PUSH
47066: LD_VAR 0 2
47070: PPUSH
47071: CALL_OW 255
47075: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47076: LD_VAR 0 4
47080: PUSH
47081: LD_EXP 102
47085: IN
47086: NOT
47087: PUSH
47088: LD_EXP 103
47092: NOT
47093: OR
47094: PUSH
47095: LD_EXP 76
47099: NOT
47100: OR
47101: IFFALSE 47105
// exit ;
47103: GO 47338
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47105: LD_ADDR_EXP 103
47109: PUSH
47110: LD_EXP 103
47114: PPUSH
47115: LD_VAR 0 4
47119: PPUSH
47120: LD_EXP 103
47124: PUSH
47125: LD_VAR 0 4
47129: ARRAY
47130: PUSH
47131: LD_VAR 0 1
47135: DIFF
47136: PPUSH
47137: CALL_OW 1
47141: ST_TO_ADDR
// for i = 1 to mc_bases do
47142: LD_ADDR_VAR 0 5
47146: PUSH
47147: DOUBLE
47148: LD_INT 1
47150: DEC
47151: ST_TO_ADDR
47152: LD_EXP 76
47156: PUSH
47157: FOR_TO
47158: IFFALSE 47336
// begin if lab in mc_bases [ i ] then
47160: LD_VAR 0 2
47164: PUSH
47165: LD_EXP 76
47169: PUSH
47170: LD_VAR 0 5
47174: ARRAY
47175: IN
47176: IFFALSE 47334
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47178: LD_VAR 0 1
47182: PUSH
47183: LD_INT 11
47185: PUSH
47186: LD_INT 4
47188: PUSH
47189: LD_INT 3
47191: PUSH
47192: LD_INT 2
47194: PUSH
47195: EMPTY
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: IN
47201: PUSH
47202: LD_EXP 106
47206: PUSH
47207: LD_VAR 0 5
47211: ARRAY
47212: AND
47213: IFFALSE 47334
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47215: LD_ADDR_VAR 0 6
47219: PUSH
47220: LD_EXP 106
47224: PUSH
47225: LD_VAR 0 5
47229: ARRAY
47230: PUSH
47231: LD_INT 1
47233: ARRAY
47234: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47235: LD_ADDR_EXP 106
47239: PUSH
47240: LD_EXP 106
47244: PPUSH
47245: LD_VAR 0 5
47249: PPUSH
47250: EMPTY
47251: PPUSH
47252: CALL_OW 1
47256: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47257: LD_VAR 0 6
47261: PPUSH
47262: LD_INT 0
47264: PPUSH
47265: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47269: LD_VAR 0 6
47273: PPUSH
47274: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47278: LD_ADDR_EXP 105
47282: PUSH
47283: LD_EXP 105
47287: PPUSH
47288: LD_VAR 0 5
47292: PPUSH
47293: LD_EXP 105
47297: PUSH
47298: LD_VAR 0 5
47302: ARRAY
47303: PPUSH
47304: LD_INT 1
47306: PPUSH
47307: LD_VAR 0 6
47311: PPUSH
47312: CALL_OW 2
47316: PPUSH
47317: CALL_OW 1
47321: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47322: LD_VAR 0 5
47326: PPUSH
47327: LD_INT 112
47329: PPUSH
47330: CALL 24334 0 2
// end ; end ; end ;
47334: GO 47157
47336: POP
47337: POP
// end ;
47338: LD_VAR 0 3
47342: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47343: LD_INT 0
47345: PPUSH
47346: PPUSH
47347: PPUSH
47348: PPUSH
47349: PPUSH
47350: PPUSH
47351: PPUSH
47352: PPUSH
// if not mc_bases or not skirmish then
47353: LD_EXP 76
47357: NOT
47358: PUSH
47359: LD_EXP 74
47363: NOT
47364: OR
47365: IFFALSE 47369
// exit ;
47367: GO 48740
// for i = 1 to mc_bases do
47369: LD_ADDR_VAR 0 3
47373: PUSH
47374: DOUBLE
47375: LD_INT 1
47377: DEC
47378: ST_TO_ADDR
47379: LD_EXP 76
47383: PUSH
47384: FOR_TO
47385: IFFALSE 48738
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47387: LD_VAR 0 1
47391: PUSH
47392: LD_EXP 76
47396: PUSH
47397: LD_VAR 0 3
47401: ARRAY
47402: IN
47403: PUSH
47404: LD_VAR 0 1
47408: PUSH
47409: LD_EXP 83
47413: PUSH
47414: LD_VAR 0 3
47418: ARRAY
47419: IN
47420: OR
47421: PUSH
47422: LD_VAR 0 1
47426: PUSH
47427: LD_EXP 98
47431: PUSH
47432: LD_VAR 0 3
47436: ARRAY
47437: IN
47438: OR
47439: PUSH
47440: LD_VAR 0 1
47444: PUSH
47445: LD_EXP 95
47449: PUSH
47450: LD_VAR 0 3
47454: ARRAY
47455: IN
47456: OR
47457: PUSH
47458: LD_VAR 0 1
47462: PUSH
47463: LD_EXP 105
47467: PUSH
47468: LD_VAR 0 3
47472: ARRAY
47473: IN
47474: OR
47475: PUSH
47476: LD_VAR 0 1
47480: PUSH
47481: LD_EXP 106
47485: PUSH
47486: LD_VAR 0 3
47490: ARRAY
47491: IN
47492: OR
47493: IFFALSE 48736
// begin if un in mc_ape [ i ] then
47495: LD_VAR 0 1
47499: PUSH
47500: LD_EXP 105
47504: PUSH
47505: LD_VAR 0 3
47509: ARRAY
47510: IN
47511: IFFALSE 47550
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47513: LD_ADDR_EXP 105
47517: PUSH
47518: LD_EXP 105
47522: PPUSH
47523: LD_VAR 0 3
47527: PPUSH
47528: LD_EXP 105
47532: PUSH
47533: LD_VAR 0 3
47537: ARRAY
47538: PUSH
47539: LD_VAR 0 1
47543: DIFF
47544: PPUSH
47545: CALL_OW 1
47549: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47550: LD_VAR 0 1
47554: PUSH
47555: LD_EXP 106
47559: PUSH
47560: LD_VAR 0 3
47564: ARRAY
47565: IN
47566: IFFALSE 47590
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47568: LD_ADDR_EXP 106
47572: PUSH
47573: LD_EXP 106
47577: PPUSH
47578: LD_VAR 0 3
47582: PPUSH
47583: EMPTY
47584: PPUSH
47585: CALL_OW 1
47589: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47590: LD_VAR 0 1
47594: PPUSH
47595: CALL_OW 247
47599: PUSH
47600: LD_INT 2
47602: EQUAL
47603: PUSH
47604: LD_VAR 0 1
47608: PPUSH
47609: CALL_OW 110
47613: PUSH
47614: LD_INT 20
47616: EQUAL
47617: PUSH
47618: LD_VAR 0 1
47622: PUSH
47623: LD_EXP 98
47627: PUSH
47628: LD_VAR 0 3
47632: ARRAY
47633: IN
47634: OR
47635: PUSH
47636: LD_VAR 0 1
47640: PPUSH
47641: CALL_OW 264
47645: PUSH
47646: LD_INT 12
47648: PUSH
47649: LD_INT 51
47651: PUSH
47652: LD_EXP 70
47656: PUSH
47657: LD_INT 32
47659: PUSH
47660: LD_INT 13
47662: PUSH
47663: LD_INT 52
47665: PUSH
47666: LD_INT 31
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: LIST
47673: LIST
47674: LIST
47675: LIST
47676: LIST
47677: IN
47678: OR
47679: AND
47680: IFFALSE 47988
// begin if un in mc_defender [ i ] then
47682: LD_VAR 0 1
47686: PUSH
47687: LD_EXP 98
47691: PUSH
47692: LD_VAR 0 3
47696: ARRAY
47697: IN
47698: IFFALSE 47737
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47700: LD_ADDR_EXP 98
47704: PUSH
47705: LD_EXP 98
47709: PPUSH
47710: LD_VAR 0 3
47714: PPUSH
47715: LD_EXP 98
47719: PUSH
47720: LD_VAR 0 3
47724: ARRAY
47725: PUSH
47726: LD_VAR 0 1
47730: DIFF
47731: PPUSH
47732: CALL_OW 1
47736: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47737: LD_ADDR_VAR 0 8
47741: PUSH
47742: LD_VAR 0 3
47746: PPUSH
47747: LD_INT 3
47749: PPUSH
47750: CALL 44406 0 2
47754: ST_TO_ADDR
// if fac then
47755: LD_VAR 0 8
47759: IFFALSE 47988
// begin for j in fac do
47761: LD_ADDR_VAR 0 4
47765: PUSH
47766: LD_VAR 0 8
47770: PUSH
47771: FOR_IN
47772: IFFALSE 47986
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47774: LD_ADDR_VAR 0 9
47778: PUSH
47779: LD_VAR 0 8
47783: PPUSH
47784: LD_VAR 0 1
47788: PPUSH
47789: CALL_OW 265
47793: PPUSH
47794: LD_VAR 0 1
47798: PPUSH
47799: CALL_OW 262
47803: PPUSH
47804: LD_VAR 0 1
47808: PPUSH
47809: CALL_OW 263
47813: PPUSH
47814: LD_VAR 0 1
47818: PPUSH
47819: CALL_OW 264
47823: PPUSH
47824: CALL 55064 0 5
47828: ST_TO_ADDR
// if components then
47829: LD_VAR 0 9
47833: IFFALSE 47984
// begin if GetWeapon ( un ) = ar_control_tower then
47835: LD_VAR 0 1
47839: PPUSH
47840: CALL_OW 264
47844: PUSH
47845: LD_INT 31
47847: EQUAL
47848: IFFALSE 47965
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
47850: LD_VAR 0 1
47854: PPUSH
47855: CALL_OW 311
47859: PPUSH
47860: LD_INT 0
47862: PPUSH
47863: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
47867: LD_ADDR_EXP 116
47871: PUSH
47872: LD_EXP 116
47876: PPUSH
47877: LD_VAR 0 3
47881: PPUSH
47882: LD_EXP 116
47886: PUSH
47887: LD_VAR 0 3
47891: ARRAY
47892: PUSH
47893: LD_VAR 0 1
47897: PPUSH
47898: CALL_OW 311
47902: DIFF
47903: PPUSH
47904: CALL_OW 1
47908: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
47909: LD_ADDR_VAR 0 7
47913: PUSH
47914: LD_EXP 97
47918: PUSH
47919: LD_VAR 0 3
47923: ARRAY
47924: PPUSH
47925: LD_INT 1
47927: PPUSH
47928: LD_VAR 0 9
47932: PPUSH
47933: CALL_OW 2
47937: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
47938: LD_ADDR_EXP 97
47942: PUSH
47943: LD_EXP 97
47947: PPUSH
47948: LD_VAR 0 3
47952: PPUSH
47953: LD_VAR 0 7
47957: PPUSH
47958: CALL_OW 1
47962: ST_TO_ADDR
// end else
47963: GO 47982
// MC_InsertProduceList ( i , [ components ] ) ;
47965: LD_VAR 0 3
47969: PPUSH
47970: LD_VAR 0 9
47974: PUSH
47975: EMPTY
47976: LIST
47977: PPUSH
47978: CALL 43951 0 2
// break ;
47982: GO 47986
// end ; end ;
47984: GO 47771
47986: POP
47987: POP
// end ; end ; if GetType ( un ) = unit_building then
47988: LD_VAR 0 1
47992: PPUSH
47993: CALL_OW 247
47997: PUSH
47998: LD_INT 3
48000: EQUAL
48001: IFFALSE 48404
// begin btype := GetBType ( un ) ;
48003: LD_ADDR_VAR 0 5
48007: PUSH
48008: LD_VAR 0 1
48012: PPUSH
48013: CALL_OW 266
48017: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48018: LD_VAR 0 5
48022: PUSH
48023: LD_INT 29
48025: PUSH
48026: LD_INT 30
48028: PUSH
48029: EMPTY
48030: LIST
48031: LIST
48032: IN
48033: IFFALSE 48106
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48035: LD_VAR 0 1
48039: PPUSH
48040: CALL_OW 250
48044: PPUSH
48045: LD_VAR 0 1
48049: PPUSH
48050: CALL_OW 251
48054: PPUSH
48055: LD_VAR 0 1
48059: PPUSH
48060: CALL_OW 255
48064: PPUSH
48065: CALL_OW 440
48069: NOT
48070: IFFALSE 48106
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48072: LD_VAR 0 1
48076: PPUSH
48077: CALL_OW 250
48081: PPUSH
48082: LD_VAR 0 1
48086: PPUSH
48087: CALL_OW 251
48091: PPUSH
48092: LD_VAR 0 1
48096: PPUSH
48097: CALL_OW 255
48101: PPUSH
48102: CALL_OW 441
// end ; if btype = b_warehouse then
48106: LD_VAR 0 5
48110: PUSH
48111: LD_INT 1
48113: EQUAL
48114: IFFALSE 48132
// begin btype := b_depot ;
48116: LD_ADDR_VAR 0 5
48120: PUSH
48121: LD_INT 0
48123: ST_TO_ADDR
// pos := 1 ;
48124: LD_ADDR_VAR 0 6
48128: PUSH
48129: LD_INT 1
48131: ST_TO_ADDR
// end ; if btype = b_factory then
48132: LD_VAR 0 5
48136: PUSH
48137: LD_INT 3
48139: EQUAL
48140: IFFALSE 48158
// begin btype := b_workshop ;
48142: LD_ADDR_VAR 0 5
48146: PUSH
48147: LD_INT 2
48149: ST_TO_ADDR
// pos := 1 ;
48150: LD_ADDR_VAR 0 6
48154: PUSH
48155: LD_INT 1
48157: ST_TO_ADDR
// end ; if btype = b_barracks then
48158: LD_VAR 0 5
48162: PUSH
48163: LD_INT 5
48165: EQUAL
48166: IFFALSE 48176
// btype := b_armoury ;
48168: LD_ADDR_VAR 0 5
48172: PUSH
48173: LD_INT 4
48175: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48176: LD_VAR 0 5
48180: PUSH
48181: LD_INT 7
48183: PUSH
48184: LD_INT 8
48186: PUSH
48187: EMPTY
48188: LIST
48189: LIST
48190: IN
48191: IFFALSE 48201
// btype := b_lab ;
48193: LD_ADDR_VAR 0 5
48197: PUSH
48198: LD_INT 6
48200: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48201: LD_ADDR_EXP 81
48205: PUSH
48206: LD_EXP 81
48210: PPUSH
48211: LD_VAR 0 3
48215: PUSH
48216: LD_EXP 81
48220: PUSH
48221: LD_VAR 0 3
48225: ARRAY
48226: PUSH
48227: LD_INT 1
48229: PLUS
48230: PUSH
48231: EMPTY
48232: LIST
48233: LIST
48234: PPUSH
48235: LD_VAR 0 5
48239: PUSH
48240: LD_VAR 0 1
48244: PPUSH
48245: CALL_OW 250
48249: PUSH
48250: LD_VAR 0 1
48254: PPUSH
48255: CALL_OW 251
48259: PUSH
48260: LD_VAR 0 1
48264: PPUSH
48265: CALL_OW 254
48269: PUSH
48270: EMPTY
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: PPUSH
48276: CALL 57532 0 3
48280: ST_TO_ADDR
// if pos = 1 then
48281: LD_VAR 0 6
48285: PUSH
48286: LD_INT 1
48288: EQUAL
48289: IFFALSE 48404
// begin tmp := mc_build_list [ i ] ;
48291: LD_ADDR_VAR 0 7
48295: PUSH
48296: LD_EXP 81
48300: PUSH
48301: LD_VAR 0 3
48305: ARRAY
48306: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48307: LD_VAR 0 7
48311: PPUSH
48312: LD_INT 2
48314: PUSH
48315: LD_INT 30
48317: PUSH
48318: LD_INT 0
48320: PUSH
48321: EMPTY
48322: LIST
48323: LIST
48324: PUSH
48325: LD_INT 30
48327: PUSH
48328: LD_INT 1
48330: PUSH
48331: EMPTY
48332: LIST
48333: LIST
48334: PUSH
48335: EMPTY
48336: LIST
48337: LIST
48338: LIST
48339: PPUSH
48340: CALL_OW 72
48344: IFFALSE 48354
// pos := 2 ;
48346: LD_ADDR_VAR 0 6
48350: PUSH
48351: LD_INT 2
48353: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48354: LD_ADDR_VAR 0 7
48358: PUSH
48359: LD_VAR 0 7
48363: PPUSH
48364: LD_VAR 0 6
48368: PPUSH
48369: LD_VAR 0 7
48373: PPUSH
48374: CALL 57858 0 3
48378: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48379: LD_ADDR_EXP 81
48383: PUSH
48384: LD_EXP 81
48388: PPUSH
48389: LD_VAR 0 3
48393: PPUSH
48394: LD_VAR 0 7
48398: PPUSH
48399: CALL_OW 1
48403: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48404: LD_VAR 0 1
48408: PUSH
48409: LD_EXP 76
48413: PUSH
48414: LD_VAR 0 3
48418: ARRAY
48419: IN
48420: IFFALSE 48459
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48422: LD_ADDR_EXP 76
48426: PUSH
48427: LD_EXP 76
48431: PPUSH
48432: LD_VAR 0 3
48436: PPUSH
48437: LD_EXP 76
48441: PUSH
48442: LD_VAR 0 3
48446: ARRAY
48447: PUSH
48448: LD_VAR 0 1
48452: DIFF
48453: PPUSH
48454: CALL_OW 1
48458: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48459: LD_VAR 0 1
48463: PUSH
48464: LD_EXP 83
48468: PUSH
48469: LD_VAR 0 3
48473: ARRAY
48474: IN
48475: IFFALSE 48514
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48477: LD_ADDR_EXP 83
48481: PUSH
48482: LD_EXP 83
48486: PPUSH
48487: LD_VAR 0 3
48491: PPUSH
48492: LD_EXP 83
48496: PUSH
48497: LD_VAR 0 3
48501: ARRAY
48502: PUSH
48503: LD_VAR 0 1
48507: DIFF
48508: PPUSH
48509: CALL_OW 1
48513: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48514: LD_VAR 0 1
48518: PUSH
48519: LD_EXP 95
48523: PUSH
48524: LD_VAR 0 3
48528: ARRAY
48529: IN
48530: IFFALSE 48569
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48532: LD_ADDR_EXP 95
48536: PUSH
48537: LD_EXP 95
48541: PPUSH
48542: LD_VAR 0 3
48546: PPUSH
48547: LD_EXP 95
48551: PUSH
48552: LD_VAR 0 3
48556: ARRAY
48557: PUSH
48558: LD_VAR 0 1
48562: DIFF
48563: PPUSH
48564: CALL_OW 1
48568: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48569: LD_VAR 0 1
48573: PUSH
48574: LD_EXP 98
48578: PUSH
48579: LD_VAR 0 3
48583: ARRAY
48584: IN
48585: IFFALSE 48624
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48587: LD_ADDR_EXP 98
48591: PUSH
48592: LD_EXP 98
48596: PPUSH
48597: LD_VAR 0 3
48601: PPUSH
48602: LD_EXP 98
48606: PUSH
48607: LD_VAR 0 3
48611: ARRAY
48612: PUSH
48613: LD_VAR 0 1
48617: DIFF
48618: PPUSH
48619: CALL_OW 1
48623: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48624: LD_VAR 0 1
48628: PUSH
48629: LD_EXP 85
48633: PUSH
48634: LD_VAR 0 3
48638: ARRAY
48639: IN
48640: IFFALSE 48679
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48642: LD_ADDR_EXP 85
48646: PUSH
48647: LD_EXP 85
48651: PPUSH
48652: LD_VAR 0 3
48656: PPUSH
48657: LD_EXP 85
48661: PUSH
48662: LD_VAR 0 3
48666: ARRAY
48667: PUSH
48668: LD_VAR 0 1
48672: DIFF
48673: PPUSH
48674: CALL_OW 1
48678: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48679: LD_VAR 0 1
48683: PUSH
48684: LD_EXP 84
48688: PUSH
48689: LD_VAR 0 3
48693: ARRAY
48694: IN
48695: IFFALSE 48734
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48697: LD_ADDR_EXP 84
48701: PUSH
48702: LD_EXP 84
48706: PPUSH
48707: LD_VAR 0 3
48711: PPUSH
48712: LD_EXP 84
48716: PUSH
48717: LD_VAR 0 3
48721: ARRAY
48722: PUSH
48723: LD_VAR 0 1
48727: DIFF
48728: PPUSH
48729: CALL_OW 1
48733: ST_TO_ADDR
// end ; break ;
48734: GO 48738
// end ;
48736: GO 47384
48738: POP
48739: POP
// end ;
48740: LD_VAR 0 2
48744: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48745: LD_INT 0
48747: PPUSH
48748: PPUSH
48749: PPUSH
// if not mc_bases or not skirmish then
48750: LD_EXP 76
48754: NOT
48755: PUSH
48756: LD_EXP 74
48760: NOT
48761: OR
48762: IFFALSE 48766
// exit ;
48764: GO 48981
// for i = 1 to mc_bases do
48766: LD_ADDR_VAR 0 3
48770: PUSH
48771: DOUBLE
48772: LD_INT 1
48774: DEC
48775: ST_TO_ADDR
48776: LD_EXP 76
48780: PUSH
48781: FOR_TO
48782: IFFALSE 48979
// begin if building in mc_construct_list [ i ] then
48784: LD_VAR 0 1
48788: PUSH
48789: LD_EXP 83
48793: PUSH
48794: LD_VAR 0 3
48798: ARRAY
48799: IN
48800: IFFALSE 48977
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48802: LD_ADDR_EXP 83
48806: PUSH
48807: LD_EXP 83
48811: PPUSH
48812: LD_VAR 0 3
48816: PPUSH
48817: LD_EXP 83
48821: PUSH
48822: LD_VAR 0 3
48826: ARRAY
48827: PUSH
48828: LD_VAR 0 1
48832: DIFF
48833: PPUSH
48834: CALL_OW 1
48838: ST_TO_ADDR
// if building in mc_lab [ i ] then
48839: LD_VAR 0 1
48843: PUSH
48844: LD_EXP 109
48848: PUSH
48849: LD_VAR 0 3
48853: ARRAY
48854: IN
48855: IFFALSE 48910
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
48857: LD_ADDR_EXP 110
48861: PUSH
48862: LD_EXP 110
48866: PPUSH
48867: LD_VAR 0 3
48871: PPUSH
48872: LD_EXP 110
48876: PUSH
48877: LD_VAR 0 3
48881: ARRAY
48882: PPUSH
48883: LD_INT 1
48885: PPUSH
48886: LD_EXP 110
48890: PUSH
48891: LD_VAR 0 3
48895: ARRAY
48896: PPUSH
48897: LD_INT 0
48899: PPUSH
48900: CALL 56950 0 4
48904: PPUSH
48905: CALL_OW 1
48909: ST_TO_ADDR
// if not building in mc_bases [ i ] then
48910: LD_VAR 0 1
48914: PUSH
48915: LD_EXP 76
48919: PUSH
48920: LD_VAR 0 3
48924: ARRAY
48925: IN
48926: NOT
48927: IFFALSE 48973
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48929: LD_ADDR_EXP 76
48933: PUSH
48934: LD_EXP 76
48938: PPUSH
48939: LD_VAR 0 3
48943: PUSH
48944: LD_EXP 76
48948: PUSH
48949: LD_VAR 0 3
48953: ARRAY
48954: PUSH
48955: LD_INT 1
48957: PLUS
48958: PUSH
48959: EMPTY
48960: LIST
48961: LIST
48962: PPUSH
48963: LD_VAR 0 1
48967: PPUSH
48968: CALL 57532 0 3
48972: ST_TO_ADDR
// exit ;
48973: POP
48974: POP
48975: GO 48981
// end ; end ;
48977: GO 48781
48979: POP
48980: POP
// end ;
48981: LD_VAR 0 2
48985: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
48986: LD_INT 0
48988: PPUSH
48989: PPUSH
48990: PPUSH
48991: PPUSH
48992: PPUSH
48993: PPUSH
48994: PPUSH
// if not mc_bases or not skirmish then
48995: LD_EXP 76
48999: NOT
49000: PUSH
49001: LD_EXP 74
49005: NOT
49006: OR
49007: IFFALSE 49011
// exit ;
49009: GO 49672
// for i = 1 to mc_bases do
49011: LD_ADDR_VAR 0 3
49015: PUSH
49016: DOUBLE
49017: LD_INT 1
49019: DEC
49020: ST_TO_ADDR
49021: LD_EXP 76
49025: PUSH
49026: FOR_TO
49027: IFFALSE 49670
// begin if building in mc_construct_list [ i ] then
49029: LD_VAR 0 1
49033: PUSH
49034: LD_EXP 83
49038: PUSH
49039: LD_VAR 0 3
49043: ARRAY
49044: IN
49045: IFFALSE 49668
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49047: LD_ADDR_EXP 83
49051: PUSH
49052: LD_EXP 83
49056: PPUSH
49057: LD_VAR 0 3
49061: PPUSH
49062: LD_EXP 83
49066: PUSH
49067: LD_VAR 0 3
49071: ARRAY
49072: PUSH
49073: LD_VAR 0 1
49077: DIFF
49078: PPUSH
49079: CALL_OW 1
49083: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49084: LD_ADDR_EXP 76
49088: PUSH
49089: LD_EXP 76
49093: PPUSH
49094: LD_VAR 0 3
49098: PUSH
49099: LD_EXP 76
49103: PUSH
49104: LD_VAR 0 3
49108: ARRAY
49109: PUSH
49110: LD_INT 1
49112: PLUS
49113: PUSH
49114: EMPTY
49115: LIST
49116: LIST
49117: PPUSH
49118: LD_VAR 0 1
49122: PPUSH
49123: CALL 57532 0 3
49127: ST_TO_ADDR
// btype := GetBType ( building ) ;
49128: LD_ADDR_VAR 0 5
49132: PUSH
49133: LD_VAR 0 1
49137: PPUSH
49138: CALL_OW 266
49142: ST_TO_ADDR
// side := GetSide ( building ) ;
49143: LD_ADDR_VAR 0 8
49147: PUSH
49148: LD_VAR 0 1
49152: PPUSH
49153: CALL_OW 255
49157: ST_TO_ADDR
// if btype = b_lab then
49158: LD_VAR 0 5
49162: PUSH
49163: LD_INT 6
49165: EQUAL
49166: IFFALSE 49216
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49168: LD_ADDR_EXP 109
49172: PUSH
49173: LD_EXP 109
49177: PPUSH
49178: LD_VAR 0 3
49182: PUSH
49183: LD_EXP 109
49187: PUSH
49188: LD_VAR 0 3
49192: ARRAY
49193: PUSH
49194: LD_INT 1
49196: PLUS
49197: PUSH
49198: EMPTY
49199: LIST
49200: LIST
49201: PPUSH
49202: LD_VAR 0 1
49206: PPUSH
49207: CALL 57532 0 3
49211: ST_TO_ADDR
// exit ;
49212: POP
49213: POP
49214: GO 49672
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49216: LD_VAR 0 5
49220: PUSH
49221: LD_INT 0
49223: PUSH
49224: LD_INT 2
49226: PUSH
49227: LD_INT 4
49229: PUSH
49230: EMPTY
49231: LIST
49232: LIST
49233: LIST
49234: IN
49235: IFFALSE 49359
// begin if btype = b_armoury then
49237: LD_VAR 0 5
49241: PUSH
49242: LD_INT 4
49244: EQUAL
49245: IFFALSE 49255
// btype := b_barracks ;
49247: LD_ADDR_VAR 0 5
49251: PUSH
49252: LD_INT 5
49254: ST_TO_ADDR
// if btype = b_depot then
49255: LD_VAR 0 5
49259: PUSH
49260: LD_INT 0
49262: EQUAL
49263: IFFALSE 49273
// btype := b_warehouse ;
49265: LD_ADDR_VAR 0 5
49269: PUSH
49270: LD_INT 1
49272: ST_TO_ADDR
// if btype = b_workshop then
49273: LD_VAR 0 5
49277: PUSH
49278: LD_INT 2
49280: EQUAL
49281: IFFALSE 49291
// btype := b_factory ;
49283: LD_ADDR_VAR 0 5
49287: PUSH
49288: LD_INT 3
49290: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49291: LD_VAR 0 5
49295: PPUSH
49296: LD_VAR 0 8
49300: PPUSH
49301: CALL_OW 323
49305: PUSH
49306: LD_INT 1
49308: EQUAL
49309: IFFALSE 49355
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49311: LD_ADDR_EXP 108
49315: PUSH
49316: LD_EXP 108
49320: PPUSH
49321: LD_VAR 0 3
49325: PUSH
49326: LD_EXP 108
49330: PUSH
49331: LD_VAR 0 3
49335: ARRAY
49336: PUSH
49337: LD_INT 1
49339: PLUS
49340: PUSH
49341: EMPTY
49342: LIST
49343: LIST
49344: PPUSH
49345: LD_VAR 0 1
49349: PPUSH
49350: CALL 57532 0 3
49354: ST_TO_ADDR
// exit ;
49355: POP
49356: POP
49357: GO 49672
// end ; if btype in [ b_bunker , b_turret ] then
49359: LD_VAR 0 5
49363: PUSH
49364: LD_INT 32
49366: PUSH
49367: LD_INT 33
49369: PUSH
49370: EMPTY
49371: LIST
49372: LIST
49373: IN
49374: IFFALSE 49664
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49376: LD_ADDR_EXP 84
49380: PUSH
49381: LD_EXP 84
49385: PPUSH
49386: LD_VAR 0 3
49390: PUSH
49391: LD_EXP 84
49395: PUSH
49396: LD_VAR 0 3
49400: ARRAY
49401: PUSH
49402: LD_INT 1
49404: PLUS
49405: PUSH
49406: EMPTY
49407: LIST
49408: LIST
49409: PPUSH
49410: LD_VAR 0 1
49414: PPUSH
49415: CALL 57532 0 3
49419: ST_TO_ADDR
// if btype = b_bunker then
49420: LD_VAR 0 5
49424: PUSH
49425: LD_INT 32
49427: EQUAL
49428: IFFALSE 49664
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49430: LD_ADDR_EXP 85
49434: PUSH
49435: LD_EXP 85
49439: PPUSH
49440: LD_VAR 0 3
49444: PUSH
49445: LD_EXP 85
49449: PUSH
49450: LD_VAR 0 3
49454: ARRAY
49455: PUSH
49456: LD_INT 1
49458: PLUS
49459: PUSH
49460: EMPTY
49461: LIST
49462: LIST
49463: PPUSH
49464: LD_VAR 0 1
49468: PPUSH
49469: CALL 57532 0 3
49473: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49474: LD_ADDR_VAR 0 6
49478: PUSH
49479: LD_EXP 76
49483: PUSH
49484: LD_VAR 0 3
49488: ARRAY
49489: PPUSH
49490: LD_INT 25
49492: PUSH
49493: LD_INT 1
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PUSH
49500: LD_INT 3
49502: PUSH
49503: LD_INT 54
49505: PUSH
49506: EMPTY
49507: LIST
49508: PUSH
49509: EMPTY
49510: LIST
49511: LIST
49512: PUSH
49513: EMPTY
49514: LIST
49515: LIST
49516: PPUSH
49517: CALL_OW 72
49521: ST_TO_ADDR
// if tmp then
49522: LD_VAR 0 6
49526: IFFALSE 49532
// exit ;
49528: POP
49529: POP
49530: GO 49672
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49532: LD_ADDR_VAR 0 6
49536: PUSH
49537: LD_EXP 76
49541: PUSH
49542: LD_VAR 0 3
49546: ARRAY
49547: PPUSH
49548: LD_INT 2
49550: PUSH
49551: LD_INT 30
49553: PUSH
49554: LD_INT 4
49556: PUSH
49557: EMPTY
49558: LIST
49559: LIST
49560: PUSH
49561: LD_INT 30
49563: PUSH
49564: LD_INT 5
49566: PUSH
49567: EMPTY
49568: LIST
49569: LIST
49570: PUSH
49571: EMPTY
49572: LIST
49573: LIST
49574: LIST
49575: PPUSH
49576: CALL_OW 72
49580: ST_TO_ADDR
// if not tmp then
49581: LD_VAR 0 6
49585: NOT
49586: IFFALSE 49592
// exit ;
49588: POP
49589: POP
49590: GO 49672
// for j in tmp do
49592: LD_ADDR_VAR 0 4
49596: PUSH
49597: LD_VAR 0 6
49601: PUSH
49602: FOR_IN
49603: IFFALSE 49662
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49605: LD_ADDR_VAR 0 7
49609: PUSH
49610: LD_VAR 0 4
49614: PPUSH
49615: CALL_OW 313
49619: PPUSH
49620: LD_INT 25
49622: PUSH
49623: LD_INT 1
49625: PUSH
49626: EMPTY
49627: LIST
49628: LIST
49629: PPUSH
49630: CALL_OW 72
49634: ST_TO_ADDR
// if units then
49635: LD_VAR 0 7
49639: IFFALSE 49660
// begin ComExitBuilding ( units [ 1 ] ) ;
49641: LD_VAR 0 7
49645: PUSH
49646: LD_INT 1
49648: ARRAY
49649: PPUSH
49650: CALL_OW 122
// exit ;
49654: POP
49655: POP
49656: POP
49657: POP
49658: GO 49672
// end ; end ;
49660: GO 49602
49662: POP
49663: POP
// end ; end ; exit ;
49664: POP
49665: POP
49666: GO 49672
// end ; end ;
49668: GO 49026
49670: POP
49671: POP
// end ;
49672: LD_VAR 0 2
49676: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49677: LD_INT 0
49679: PPUSH
49680: PPUSH
49681: PPUSH
49682: PPUSH
49683: PPUSH
49684: PPUSH
49685: PPUSH
// if not mc_bases or not skirmish then
49686: LD_EXP 76
49690: NOT
49691: PUSH
49692: LD_EXP 74
49696: NOT
49697: OR
49698: IFFALSE 49702
// exit ;
49700: GO 49933
// btype := GetBType ( building ) ;
49702: LD_ADDR_VAR 0 6
49706: PUSH
49707: LD_VAR 0 1
49711: PPUSH
49712: CALL_OW 266
49716: ST_TO_ADDR
// x := GetX ( building ) ;
49717: LD_ADDR_VAR 0 7
49721: PUSH
49722: LD_VAR 0 1
49726: PPUSH
49727: CALL_OW 250
49731: ST_TO_ADDR
// y := GetY ( building ) ;
49732: LD_ADDR_VAR 0 8
49736: PUSH
49737: LD_VAR 0 1
49741: PPUSH
49742: CALL_OW 251
49746: ST_TO_ADDR
// d := GetDir ( building ) ;
49747: LD_ADDR_VAR 0 9
49751: PUSH
49752: LD_VAR 0 1
49756: PPUSH
49757: CALL_OW 254
49761: ST_TO_ADDR
// for i = 1 to mc_bases do
49762: LD_ADDR_VAR 0 4
49766: PUSH
49767: DOUBLE
49768: LD_INT 1
49770: DEC
49771: ST_TO_ADDR
49772: LD_EXP 76
49776: PUSH
49777: FOR_TO
49778: IFFALSE 49931
// begin if not mc_build_list [ i ] then
49780: LD_EXP 81
49784: PUSH
49785: LD_VAR 0 4
49789: ARRAY
49790: NOT
49791: IFFALSE 49795
// continue ;
49793: GO 49777
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
49795: LD_VAR 0 6
49799: PUSH
49800: LD_VAR 0 7
49804: PUSH
49805: LD_VAR 0 8
49809: PUSH
49810: LD_VAR 0 9
49814: PUSH
49815: EMPTY
49816: LIST
49817: LIST
49818: LIST
49819: LIST
49820: PPUSH
49821: LD_EXP 81
49825: PUSH
49826: LD_VAR 0 4
49830: ARRAY
49831: PUSH
49832: LD_INT 1
49834: ARRAY
49835: PPUSH
49836: CALL 63701 0 2
49840: IFFALSE 49929
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
49842: LD_ADDR_EXP 81
49846: PUSH
49847: LD_EXP 81
49851: PPUSH
49852: LD_VAR 0 4
49856: PPUSH
49857: LD_EXP 81
49861: PUSH
49862: LD_VAR 0 4
49866: ARRAY
49867: PPUSH
49868: LD_INT 1
49870: PPUSH
49871: CALL_OW 3
49875: PPUSH
49876: CALL_OW 1
49880: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
49881: LD_ADDR_EXP 83
49885: PUSH
49886: LD_EXP 83
49890: PPUSH
49891: LD_VAR 0 4
49895: PUSH
49896: LD_EXP 83
49900: PUSH
49901: LD_VAR 0 4
49905: ARRAY
49906: PUSH
49907: LD_INT 1
49909: PLUS
49910: PUSH
49911: EMPTY
49912: LIST
49913: LIST
49914: PPUSH
49915: LD_VAR 0 1
49919: PPUSH
49920: CALL 57532 0 3
49924: ST_TO_ADDR
// exit ;
49925: POP
49926: POP
49927: GO 49933
// end ; end ;
49929: GO 49777
49931: POP
49932: POP
// end ;
49933: LD_VAR 0 3
49937: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
49938: LD_INT 0
49940: PPUSH
49941: PPUSH
49942: PPUSH
// if not mc_bases or not skirmish then
49943: LD_EXP 76
49947: NOT
49948: PUSH
49949: LD_EXP 74
49953: NOT
49954: OR
49955: IFFALSE 49959
// exit ;
49957: GO 50149
// for i = 1 to mc_bases do
49959: LD_ADDR_VAR 0 4
49963: PUSH
49964: DOUBLE
49965: LD_INT 1
49967: DEC
49968: ST_TO_ADDR
49969: LD_EXP 76
49973: PUSH
49974: FOR_TO
49975: IFFALSE 50062
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
49977: LD_VAR 0 1
49981: PUSH
49982: LD_EXP 84
49986: PUSH
49987: LD_VAR 0 4
49991: ARRAY
49992: IN
49993: PUSH
49994: LD_VAR 0 1
49998: PUSH
49999: LD_EXP 85
50003: PUSH
50004: LD_VAR 0 4
50008: ARRAY
50009: IN
50010: NOT
50011: AND
50012: IFFALSE 50060
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50014: LD_ADDR_EXP 85
50018: PUSH
50019: LD_EXP 85
50023: PPUSH
50024: LD_VAR 0 4
50028: PUSH
50029: LD_EXP 85
50033: PUSH
50034: LD_VAR 0 4
50038: ARRAY
50039: PUSH
50040: LD_INT 1
50042: PLUS
50043: PUSH
50044: EMPTY
50045: LIST
50046: LIST
50047: PPUSH
50048: LD_VAR 0 1
50052: PPUSH
50053: CALL 57532 0 3
50057: ST_TO_ADDR
// break ;
50058: GO 50062
// end ; end ;
50060: GO 49974
50062: POP
50063: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50064: LD_VAR 0 1
50068: PPUSH
50069: CALL_OW 257
50073: PUSH
50074: LD_EXP 102
50078: IN
50079: PUSH
50080: LD_VAR 0 1
50084: PPUSH
50085: CALL_OW 266
50089: PUSH
50090: LD_INT 5
50092: EQUAL
50093: AND
50094: PUSH
50095: LD_VAR 0 2
50099: PPUSH
50100: CALL_OW 110
50104: PUSH
50105: LD_INT 18
50107: NONEQUAL
50108: AND
50109: IFFALSE 50149
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50111: LD_VAR 0 2
50115: PPUSH
50116: CALL_OW 257
50120: PUSH
50121: LD_INT 5
50123: PUSH
50124: LD_INT 8
50126: PUSH
50127: LD_INT 9
50129: PUSH
50130: EMPTY
50131: LIST
50132: LIST
50133: LIST
50134: IN
50135: IFFALSE 50149
// SetClass ( unit , 1 ) ;
50137: LD_VAR 0 2
50141: PPUSH
50142: LD_INT 1
50144: PPUSH
50145: CALL_OW 336
// end ;
50149: LD_VAR 0 3
50153: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50154: LD_INT 0
50156: PPUSH
50157: PPUSH
// if not mc_bases or not skirmish then
50158: LD_EXP 76
50162: NOT
50163: PUSH
50164: LD_EXP 74
50168: NOT
50169: OR
50170: IFFALSE 50174
// exit ;
50172: GO 50290
// if GetLives ( abandoned_vehicle ) > 250 then
50174: LD_VAR 0 2
50178: PPUSH
50179: CALL_OW 256
50183: PUSH
50184: LD_INT 250
50186: GREATER
50187: IFFALSE 50191
// exit ;
50189: GO 50290
// for i = 1 to mc_bases do
50191: LD_ADDR_VAR 0 6
50195: PUSH
50196: DOUBLE
50197: LD_INT 1
50199: DEC
50200: ST_TO_ADDR
50201: LD_EXP 76
50205: PUSH
50206: FOR_TO
50207: IFFALSE 50288
// begin if driver in mc_bases [ i ] then
50209: LD_VAR 0 1
50213: PUSH
50214: LD_EXP 76
50218: PUSH
50219: LD_VAR 0 6
50223: ARRAY
50224: IN
50225: IFFALSE 50286
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50227: LD_VAR 0 1
50231: PPUSH
50232: LD_EXP 76
50236: PUSH
50237: LD_VAR 0 6
50241: ARRAY
50242: PPUSH
50243: LD_INT 2
50245: PUSH
50246: LD_INT 30
50248: PUSH
50249: LD_INT 0
50251: PUSH
50252: EMPTY
50253: LIST
50254: LIST
50255: PUSH
50256: LD_INT 30
50258: PUSH
50259: LD_INT 1
50261: PUSH
50262: EMPTY
50263: LIST
50264: LIST
50265: PUSH
50266: EMPTY
50267: LIST
50268: LIST
50269: LIST
50270: PPUSH
50271: CALL_OW 72
50275: PUSH
50276: LD_INT 1
50278: ARRAY
50279: PPUSH
50280: CALL_OW 112
// break ;
50284: GO 50288
// end ; end ;
50286: GO 50206
50288: POP
50289: POP
// end ; end_of_file
50290: LD_VAR 0 5
50294: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50295: LD_INT 0
50297: PPUSH
50298: PPUSH
// if exist_mode then
50299: LD_VAR 0 2
50303: IFFALSE 50328
// unit := CreateCharacter ( prefix & ident ) else
50305: LD_ADDR_VAR 0 5
50309: PUSH
50310: LD_VAR 0 3
50314: PUSH
50315: LD_VAR 0 1
50319: STR
50320: PPUSH
50321: CALL_OW 34
50325: ST_TO_ADDR
50326: GO 50343
// unit := NewCharacter ( ident ) ;
50328: LD_ADDR_VAR 0 5
50332: PUSH
50333: LD_VAR 0 1
50337: PPUSH
50338: CALL_OW 25
50342: ST_TO_ADDR
// result := unit ;
50343: LD_ADDR_VAR 0 4
50347: PUSH
50348: LD_VAR 0 5
50352: ST_TO_ADDR
// end ;
50353: LD_VAR 0 4
50357: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50358: LD_INT 0
50360: PPUSH
50361: PPUSH
// if not side or not nation then
50362: LD_VAR 0 1
50366: NOT
50367: PUSH
50368: LD_VAR 0 2
50372: NOT
50373: OR
50374: IFFALSE 50378
// exit ;
50376: GO 51022
// case nation of nation_american :
50378: LD_VAR 0 2
50382: PUSH
50383: LD_INT 1
50385: DOUBLE
50386: EQUAL
50387: IFTRUE 50391
50389: GO 50565
50391: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
50392: LD_ADDR_VAR 0 4
50396: PUSH
50397: LD_INT 35
50399: PUSH
50400: LD_INT 45
50402: PUSH
50403: LD_INT 46
50405: PUSH
50406: LD_INT 47
50408: PUSH
50409: LD_INT 1
50411: PUSH
50412: LD_INT 2
50414: PUSH
50415: LD_INT 6
50417: PUSH
50418: LD_INT 15
50420: PUSH
50421: LD_INT 16
50423: PUSH
50424: LD_INT 7
50426: PUSH
50427: LD_INT 12
50429: PUSH
50430: LD_INT 13
50432: PUSH
50433: LD_INT 10
50435: PUSH
50436: LD_INT 14
50438: PUSH
50439: LD_INT 20
50441: PUSH
50442: LD_INT 21
50444: PUSH
50445: LD_INT 22
50447: PUSH
50448: LD_INT 25
50450: PUSH
50451: LD_INT 32
50453: PUSH
50454: LD_INT 27
50456: PUSH
50457: LD_INT 36
50459: PUSH
50460: LD_INT 69
50462: PUSH
50463: LD_INT 39
50465: PUSH
50466: LD_INT 34
50468: PUSH
50469: LD_INT 40
50471: PUSH
50472: LD_INT 48
50474: PUSH
50475: LD_INT 49
50477: PUSH
50478: LD_INT 50
50480: PUSH
50481: LD_INT 51
50483: PUSH
50484: LD_INT 52
50486: PUSH
50487: LD_INT 53
50489: PUSH
50490: LD_INT 54
50492: PUSH
50493: LD_INT 55
50495: PUSH
50496: LD_INT 56
50498: PUSH
50499: LD_INT 57
50501: PUSH
50502: LD_INT 58
50504: PUSH
50505: LD_INT 59
50507: PUSH
50508: LD_INT 60
50510: PUSH
50511: LD_INT 61
50513: PUSH
50514: LD_INT 62
50516: PUSH
50517: LD_INT 80
50519: PUSH
50520: EMPTY
50521: LIST
50522: LIST
50523: LIST
50524: LIST
50525: LIST
50526: LIST
50527: LIST
50528: LIST
50529: LIST
50530: LIST
50531: LIST
50532: LIST
50533: LIST
50534: LIST
50535: LIST
50536: LIST
50537: LIST
50538: LIST
50539: LIST
50540: LIST
50541: LIST
50542: LIST
50543: LIST
50544: LIST
50545: LIST
50546: LIST
50547: LIST
50548: LIST
50549: LIST
50550: LIST
50551: LIST
50552: LIST
50553: LIST
50554: LIST
50555: LIST
50556: LIST
50557: LIST
50558: LIST
50559: LIST
50560: LIST
50561: LIST
50562: ST_TO_ADDR
50563: GO 50946
50565: LD_INT 2
50567: DOUBLE
50568: EQUAL
50569: IFTRUE 50573
50571: GO 50755
50573: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50574: LD_ADDR_VAR 0 4
50578: PUSH
50579: LD_INT 35
50581: PUSH
50582: LD_INT 45
50584: PUSH
50585: LD_INT 46
50587: PUSH
50588: LD_INT 47
50590: PUSH
50591: LD_INT 70
50593: PUSH
50594: LD_INT 1
50596: PUSH
50597: LD_INT 11
50599: PUSH
50600: LD_INT 3
50602: PUSH
50603: LD_INT 4
50605: PUSH
50606: LD_INT 5
50608: PUSH
50609: LD_INT 6
50611: PUSH
50612: LD_INT 15
50614: PUSH
50615: LD_INT 18
50617: PUSH
50618: LD_INT 7
50620: PUSH
50621: LD_INT 17
50623: PUSH
50624: LD_INT 8
50626: PUSH
50627: LD_INT 20
50629: PUSH
50630: LD_INT 21
50632: PUSH
50633: LD_INT 22
50635: PUSH
50636: LD_INT 72
50638: PUSH
50639: LD_INT 26
50641: PUSH
50642: LD_INT 69
50644: PUSH
50645: LD_INT 39
50647: PUSH
50648: LD_INT 40
50650: PUSH
50651: LD_INT 41
50653: PUSH
50654: LD_INT 42
50656: PUSH
50657: LD_INT 43
50659: PUSH
50660: LD_INT 48
50662: PUSH
50663: LD_INT 49
50665: PUSH
50666: LD_INT 50
50668: PUSH
50669: LD_INT 51
50671: PUSH
50672: LD_INT 52
50674: PUSH
50675: LD_INT 53
50677: PUSH
50678: LD_INT 54
50680: PUSH
50681: LD_INT 55
50683: PUSH
50684: LD_INT 56
50686: PUSH
50687: LD_INT 60
50689: PUSH
50690: LD_INT 61
50692: PUSH
50693: LD_INT 62
50695: PUSH
50696: LD_INT 66
50698: PUSH
50699: LD_INT 67
50701: PUSH
50702: LD_INT 68
50704: PUSH
50705: LD_INT 81
50707: PUSH
50708: EMPTY
50709: LIST
50710: LIST
50711: LIST
50712: LIST
50713: LIST
50714: LIST
50715: LIST
50716: LIST
50717: LIST
50718: LIST
50719: LIST
50720: LIST
50721: LIST
50722: LIST
50723: LIST
50724: LIST
50725: LIST
50726: LIST
50727: LIST
50728: LIST
50729: LIST
50730: LIST
50731: LIST
50732: LIST
50733: LIST
50734: LIST
50735: LIST
50736: LIST
50737: LIST
50738: LIST
50739: LIST
50740: LIST
50741: LIST
50742: LIST
50743: LIST
50744: LIST
50745: LIST
50746: LIST
50747: LIST
50748: LIST
50749: LIST
50750: LIST
50751: LIST
50752: ST_TO_ADDR
50753: GO 50946
50755: LD_INT 3
50757: DOUBLE
50758: EQUAL
50759: IFTRUE 50763
50761: GO 50945
50763: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
50764: LD_ADDR_VAR 0 4
50768: PUSH
50769: LD_INT 46
50771: PUSH
50772: LD_INT 47
50774: PUSH
50775: LD_INT 1
50777: PUSH
50778: LD_INT 2
50780: PUSH
50781: LD_INT 11
50783: PUSH
50784: LD_INT 9
50786: PUSH
50787: LD_INT 20
50789: PUSH
50790: LD_INT 19
50792: PUSH
50793: LD_INT 21
50795: PUSH
50796: LD_INT 24
50798: PUSH
50799: LD_INT 22
50801: PUSH
50802: LD_INT 25
50804: PUSH
50805: LD_INT 28
50807: PUSH
50808: LD_INT 29
50810: PUSH
50811: LD_INT 30
50813: PUSH
50814: LD_INT 31
50816: PUSH
50817: LD_INT 37
50819: PUSH
50820: LD_INT 38
50822: PUSH
50823: LD_INT 32
50825: PUSH
50826: LD_INT 27
50828: PUSH
50829: LD_INT 33
50831: PUSH
50832: LD_INT 69
50834: PUSH
50835: LD_INT 39
50837: PUSH
50838: LD_INT 34
50840: PUSH
50841: LD_INT 40
50843: PUSH
50844: LD_INT 71
50846: PUSH
50847: LD_INT 23
50849: PUSH
50850: LD_INT 44
50852: PUSH
50853: LD_INT 48
50855: PUSH
50856: LD_INT 49
50858: PUSH
50859: LD_INT 50
50861: PUSH
50862: LD_INT 51
50864: PUSH
50865: LD_INT 52
50867: PUSH
50868: LD_INT 53
50870: PUSH
50871: LD_INT 54
50873: PUSH
50874: LD_INT 55
50876: PUSH
50877: LD_INT 56
50879: PUSH
50880: LD_INT 57
50882: PUSH
50883: LD_INT 58
50885: PUSH
50886: LD_INT 59
50888: PUSH
50889: LD_INT 63
50891: PUSH
50892: LD_INT 64
50894: PUSH
50895: LD_INT 65
50897: PUSH
50898: EMPTY
50899: LIST
50900: LIST
50901: LIST
50902: LIST
50903: LIST
50904: LIST
50905: LIST
50906: LIST
50907: LIST
50908: LIST
50909: LIST
50910: LIST
50911: LIST
50912: LIST
50913: LIST
50914: LIST
50915: LIST
50916: LIST
50917: LIST
50918: LIST
50919: LIST
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: LIST
50927: LIST
50928: LIST
50929: LIST
50930: LIST
50931: LIST
50932: LIST
50933: LIST
50934: LIST
50935: LIST
50936: LIST
50937: LIST
50938: LIST
50939: LIST
50940: LIST
50941: LIST
50942: ST_TO_ADDR
50943: GO 50946
50945: POP
// if state > - 1 and state < 3 then
50946: LD_VAR 0 3
50950: PUSH
50951: LD_INT 1
50953: NEG
50954: GREATER
50955: PUSH
50956: LD_VAR 0 3
50960: PUSH
50961: LD_INT 3
50963: LESS
50964: AND
50965: IFFALSE 51022
// for i in result do
50967: LD_ADDR_VAR 0 5
50971: PUSH
50972: LD_VAR 0 4
50976: PUSH
50977: FOR_IN
50978: IFFALSE 51020
// if GetTech ( i , side ) <> state then
50980: LD_VAR 0 5
50984: PPUSH
50985: LD_VAR 0 1
50989: PPUSH
50990: CALL_OW 321
50994: PUSH
50995: LD_VAR 0 3
50999: NONEQUAL
51000: IFFALSE 51018
// result := result diff i ;
51002: LD_ADDR_VAR 0 4
51006: PUSH
51007: LD_VAR 0 4
51011: PUSH
51012: LD_VAR 0 5
51016: DIFF
51017: ST_TO_ADDR
51018: GO 50977
51020: POP
51021: POP
// end ;
51022: LD_VAR 0 4
51026: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51027: LD_INT 0
51029: PPUSH
51030: PPUSH
51031: PPUSH
// result := true ;
51032: LD_ADDR_VAR 0 3
51036: PUSH
51037: LD_INT 1
51039: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51040: LD_ADDR_VAR 0 5
51044: PUSH
51045: LD_VAR 0 2
51049: PPUSH
51050: CALL_OW 480
51054: ST_TO_ADDR
// if not tmp then
51055: LD_VAR 0 5
51059: NOT
51060: IFFALSE 51064
// exit ;
51062: GO 51113
// for i in tmp do
51064: LD_ADDR_VAR 0 4
51068: PUSH
51069: LD_VAR 0 5
51073: PUSH
51074: FOR_IN
51075: IFFALSE 51111
// if GetTech ( i , side ) <> state_researched then
51077: LD_VAR 0 4
51081: PPUSH
51082: LD_VAR 0 1
51086: PPUSH
51087: CALL_OW 321
51091: PUSH
51092: LD_INT 2
51094: NONEQUAL
51095: IFFALSE 51109
// begin result := false ;
51097: LD_ADDR_VAR 0 3
51101: PUSH
51102: LD_INT 0
51104: ST_TO_ADDR
// exit ;
51105: POP
51106: POP
51107: GO 51113
// end ;
51109: GO 51074
51111: POP
51112: POP
// end ;
51113: LD_VAR 0 3
51117: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51118: LD_INT 0
51120: PPUSH
51121: PPUSH
51122: PPUSH
51123: PPUSH
51124: PPUSH
51125: PPUSH
51126: PPUSH
51127: PPUSH
51128: PPUSH
51129: PPUSH
51130: PPUSH
51131: PPUSH
51132: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51133: LD_VAR 0 1
51137: NOT
51138: PUSH
51139: LD_VAR 0 1
51143: PPUSH
51144: CALL_OW 257
51148: PUSH
51149: LD_INT 9
51151: NONEQUAL
51152: OR
51153: IFFALSE 51157
// exit ;
51155: GO 51730
// side := GetSide ( unit ) ;
51157: LD_ADDR_VAR 0 9
51161: PUSH
51162: LD_VAR 0 1
51166: PPUSH
51167: CALL_OW 255
51171: ST_TO_ADDR
// tech_space := tech_spacanom ;
51172: LD_ADDR_VAR 0 12
51176: PUSH
51177: LD_INT 29
51179: ST_TO_ADDR
// tech_time := tech_taurad ;
51180: LD_ADDR_VAR 0 13
51184: PUSH
51185: LD_INT 28
51187: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51188: LD_ADDR_VAR 0 11
51192: PUSH
51193: LD_VAR 0 1
51197: PPUSH
51198: CALL_OW 310
51202: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51203: LD_VAR 0 11
51207: PPUSH
51208: CALL_OW 247
51212: PUSH
51213: LD_INT 2
51215: EQUAL
51216: IFFALSE 51220
// exit ;
51218: GO 51730
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51220: LD_ADDR_VAR 0 8
51224: PUSH
51225: LD_INT 81
51227: PUSH
51228: LD_VAR 0 9
51232: PUSH
51233: EMPTY
51234: LIST
51235: LIST
51236: PUSH
51237: LD_INT 3
51239: PUSH
51240: LD_INT 21
51242: PUSH
51243: LD_INT 3
51245: PUSH
51246: EMPTY
51247: LIST
51248: LIST
51249: PUSH
51250: EMPTY
51251: LIST
51252: LIST
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: PPUSH
51258: CALL_OW 69
51262: ST_TO_ADDR
// if not tmp then
51263: LD_VAR 0 8
51267: NOT
51268: IFFALSE 51272
// exit ;
51270: GO 51730
// if in_unit then
51272: LD_VAR 0 11
51276: IFFALSE 51300
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51278: LD_ADDR_VAR 0 10
51282: PUSH
51283: LD_VAR 0 8
51287: PPUSH
51288: LD_VAR 0 11
51292: PPUSH
51293: CALL_OW 74
51297: ST_TO_ADDR
51298: GO 51320
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51300: LD_ADDR_VAR 0 10
51304: PUSH
51305: LD_VAR 0 8
51309: PPUSH
51310: LD_VAR 0 1
51314: PPUSH
51315: CALL_OW 74
51319: ST_TO_ADDR
// if not enemy then
51320: LD_VAR 0 10
51324: NOT
51325: IFFALSE 51329
// exit ;
51327: GO 51730
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51329: LD_VAR 0 11
51333: PUSH
51334: LD_VAR 0 11
51338: PPUSH
51339: LD_VAR 0 10
51343: PPUSH
51344: CALL_OW 296
51348: PUSH
51349: LD_INT 13
51351: GREATER
51352: AND
51353: PUSH
51354: LD_VAR 0 1
51358: PPUSH
51359: LD_VAR 0 10
51363: PPUSH
51364: CALL_OW 296
51368: PUSH
51369: LD_INT 12
51371: GREATER
51372: OR
51373: IFFALSE 51377
// exit ;
51375: GO 51730
// missile := [ 1 ] ;
51377: LD_ADDR_VAR 0 14
51381: PUSH
51382: LD_INT 1
51384: PUSH
51385: EMPTY
51386: LIST
51387: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51388: LD_VAR 0 9
51392: PPUSH
51393: LD_VAR 0 12
51397: PPUSH
51398: CALL_OW 325
51402: IFFALSE 51431
// missile := Insert ( missile , missile + 1 , 2 ) ;
51404: LD_ADDR_VAR 0 14
51408: PUSH
51409: LD_VAR 0 14
51413: PPUSH
51414: LD_VAR 0 14
51418: PUSH
51419: LD_INT 1
51421: PLUS
51422: PPUSH
51423: LD_INT 2
51425: PPUSH
51426: CALL_OW 2
51430: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51431: LD_VAR 0 9
51435: PPUSH
51436: LD_VAR 0 13
51440: PPUSH
51441: CALL_OW 325
51445: PUSH
51446: LD_VAR 0 10
51450: PPUSH
51451: CALL_OW 255
51455: PPUSH
51456: LD_VAR 0 13
51460: PPUSH
51461: CALL_OW 325
51465: NOT
51466: AND
51467: IFFALSE 51496
// missile := Insert ( missile , missile + 1 , 3 ) ;
51469: LD_ADDR_VAR 0 14
51473: PUSH
51474: LD_VAR 0 14
51478: PPUSH
51479: LD_VAR 0 14
51483: PUSH
51484: LD_INT 1
51486: PLUS
51487: PPUSH
51488: LD_INT 3
51490: PPUSH
51491: CALL_OW 2
51495: ST_TO_ADDR
// if missile < 2 then
51496: LD_VAR 0 14
51500: PUSH
51501: LD_INT 2
51503: LESS
51504: IFFALSE 51508
// exit ;
51506: GO 51730
// x := GetX ( enemy ) ;
51508: LD_ADDR_VAR 0 4
51512: PUSH
51513: LD_VAR 0 10
51517: PPUSH
51518: CALL_OW 250
51522: ST_TO_ADDR
// y := GetY ( enemy ) ;
51523: LD_ADDR_VAR 0 5
51527: PUSH
51528: LD_VAR 0 10
51532: PPUSH
51533: CALL_OW 251
51537: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51538: LD_ADDR_VAR 0 6
51542: PUSH
51543: LD_VAR 0 4
51547: PUSH
51548: LD_INT 1
51550: NEG
51551: PPUSH
51552: LD_INT 1
51554: PPUSH
51555: CALL_OW 12
51559: PLUS
51560: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51561: LD_ADDR_VAR 0 7
51565: PUSH
51566: LD_VAR 0 5
51570: PUSH
51571: LD_INT 1
51573: NEG
51574: PPUSH
51575: LD_INT 1
51577: PPUSH
51578: CALL_OW 12
51582: PLUS
51583: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51584: LD_VAR 0 6
51588: PPUSH
51589: LD_VAR 0 7
51593: PPUSH
51594: CALL_OW 488
51598: NOT
51599: IFFALSE 51621
// begin _x := x ;
51601: LD_ADDR_VAR 0 6
51605: PUSH
51606: LD_VAR 0 4
51610: ST_TO_ADDR
// _y := y ;
51611: LD_ADDR_VAR 0 7
51615: PUSH
51616: LD_VAR 0 5
51620: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51621: LD_ADDR_VAR 0 3
51625: PUSH
51626: LD_INT 1
51628: PPUSH
51629: LD_VAR 0 14
51633: PPUSH
51634: CALL_OW 12
51638: ST_TO_ADDR
// case i of 1 :
51639: LD_VAR 0 3
51643: PUSH
51644: LD_INT 1
51646: DOUBLE
51647: EQUAL
51648: IFTRUE 51652
51650: GO 51669
51652: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51653: LD_VAR 0 1
51657: PPUSH
51658: LD_VAR 0 10
51662: PPUSH
51663: CALL_OW 115
51667: GO 51730
51669: LD_INT 2
51671: DOUBLE
51672: EQUAL
51673: IFTRUE 51677
51675: GO 51699
51677: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51678: LD_VAR 0 1
51682: PPUSH
51683: LD_VAR 0 6
51687: PPUSH
51688: LD_VAR 0 7
51692: PPUSH
51693: CALL_OW 153
51697: GO 51730
51699: LD_INT 3
51701: DOUBLE
51702: EQUAL
51703: IFTRUE 51707
51705: GO 51729
51707: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51708: LD_VAR 0 1
51712: PPUSH
51713: LD_VAR 0 6
51717: PPUSH
51718: LD_VAR 0 7
51722: PPUSH
51723: CALL_OW 154
51727: GO 51730
51729: POP
// end ;
51730: LD_VAR 0 2
51734: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51735: LD_INT 0
51737: PPUSH
51738: PPUSH
51739: PPUSH
51740: PPUSH
51741: PPUSH
51742: PPUSH
// if not unit or not building then
51743: LD_VAR 0 1
51747: NOT
51748: PUSH
51749: LD_VAR 0 2
51753: NOT
51754: OR
51755: IFFALSE 51759
// exit ;
51757: GO 51917
// x := GetX ( building ) ;
51759: LD_ADDR_VAR 0 5
51763: PUSH
51764: LD_VAR 0 2
51768: PPUSH
51769: CALL_OW 250
51773: ST_TO_ADDR
// y := GetY ( building ) ;
51774: LD_ADDR_VAR 0 6
51778: PUSH
51779: LD_VAR 0 2
51783: PPUSH
51784: CALL_OW 251
51788: ST_TO_ADDR
// for i = 0 to 5 do
51789: LD_ADDR_VAR 0 4
51793: PUSH
51794: DOUBLE
51795: LD_INT 0
51797: DEC
51798: ST_TO_ADDR
51799: LD_INT 5
51801: PUSH
51802: FOR_TO
51803: IFFALSE 51915
// begin _x := ShiftX ( x , i , 3 ) ;
51805: LD_ADDR_VAR 0 7
51809: PUSH
51810: LD_VAR 0 5
51814: PPUSH
51815: LD_VAR 0 4
51819: PPUSH
51820: LD_INT 3
51822: PPUSH
51823: CALL_OW 272
51827: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
51828: LD_ADDR_VAR 0 8
51832: PUSH
51833: LD_VAR 0 6
51837: PPUSH
51838: LD_VAR 0 4
51842: PPUSH
51843: LD_INT 3
51845: PPUSH
51846: CALL_OW 273
51850: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51851: LD_VAR 0 7
51855: PPUSH
51856: LD_VAR 0 8
51860: PPUSH
51861: CALL_OW 488
51865: NOT
51866: IFFALSE 51870
// continue ;
51868: GO 51802
// if HexInfo ( _x , _y ) = 0 then
51870: LD_VAR 0 7
51874: PPUSH
51875: LD_VAR 0 8
51879: PPUSH
51880: CALL_OW 428
51884: PUSH
51885: LD_INT 0
51887: EQUAL
51888: IFFALSE 51913
// begin ComMoveXY ( unit , _x , _y ) ;
51890: LD_VAR 0 1
51894: PPUSH
51895: LD_VAR 0 7
51899: PPUSH
51900: LD_VAR 0 8
51904: PPUSH
51905: CALL_OW 111
// exit ;
51909: POP
51910: POP
51911: GO 51917
// end ; end ;
51913: GO 51802
51915: POP
51916: POP
// end ;
51917: LD_VAR 0 3
51921: RET
// export function ScanBase ( side , base_area ) ; begin
51922: LD_INT 0
51924: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
51925: LD_ADDR_VAR 0 3
51929: PUSH
51930: LD_VAR 0 2
51934: PPUSH
51935: LD_INT 81
51937: PUSH
51938: LD_VAR 0 1
51942: PUSH
51943: EMPTY
51944: LIST
51945: LIST
51946: PPUSH
51947: CALL_OW 70
51951: ST_TO_ADDR
// end ;
51952: LD_VAR 0 3
51956: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
51957: LD_INT 0
51959: PPUSH
51960: PPUSH
51961: PPUSH
51962: PPUSH
51963: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
51964: LD_VAR 0 1
51968: NOT
51969: PUSH
51970: LD_EXP 76
51974: PUSH
51975: LD_VAR 0 1
51979: ARRAY
51980: NOT
51981: OR
51982: PUSH
51983: LD_VAR 0 2
51987: NOT
51988: OR
51989: PUSH
51990: LD_VAR 0 3
51994: NOT
51995: OR
51996: IFFALSE 52000
// exit ;
51998: GO 52513
// side := mc_sides [ base ] ;
52000: LD_ADDR_VAR 0 6
52004: PUSH
52005: LD_EXP 102
52009: PUSH
52010: LD_VAR 0 1
52014: ARRAY
52015: ST_TO_ADDR
// if not side then
52016: LD_VAR 0 6
52020: NOT
52021: IFFALSE 52025
// exit ;
52023: GO 52513
// for i in solds do
52025: LD_ADDR_VAR 0 7
52029: PUSH
52030: LD_VAR 0 2
52034: PUSH
52035: FOR_IN
52036: IFFALSE 52097
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
52038: LD_VAR 0 7
52042: PPUSH
52043: CALL_OW 310
52047: PPUSH
52048: CALL_OW 266
52052: PUSH
52053: LD_INT 32
52055: PUSH
52056: LD_INT 31
52058: PUSH
52059: EMPTY
52060: LIST
52061: LIST
52062: IN
52063: IFFALSE 52083
// solds := solds diff i else
52065: LD_ADDR_VAR 0 2
52069: PUSH
52070: LD_VAR 0 2
52074: PUSH
52075: LD_VAR 0 7
52079: DIFF
52080: ST_TO_ADDR
52081: GO 52095
// SetTag ( i , 18 ) ;
52083: LD_VAR 0 7
52087: PPUSH
52088: LD_INT 18
52090: PPUSH
52091: CALL_OW 109
52095: GO 52035
52097: POP
52098: POP
// if not solds then
52099: LD_VAR 0 2
52103: NOT
52104: IFFALSE 52108
// exit ;
52106: GO 52513
// repeat wait ( 0 0$1 ) ;
52108: LD_INT 35
52110: PPUSH
52111: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
52115: LD_ADDR_VAR 0 5
52119: PUSH
52120: LD_VAR 0 6
52124: PPUSH
52125: LD_VAR 0 3
52129: PPUSH
52130: CALL 51922 0 2
52134: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52135: LD_EXP 76
52139: PUSH
52140: LD_VAR 0 1
52144: ARRAY
52145: NOT
52146: PUSH
52147: LD_EXP 76
52151: PUSH
52152: LD_VAR 0 1
52156: ARRAY
52157: PUSH
52158: EMPTY
52159: EQUAL
52160: OR
52161: IFFALSE 52198
// begin for i in solds do
52163: LD_ADDR_VAR 0 7
52167: PUSH
52168: LD_VAR 0 2
52172: PUSH
52173: FOR_IN
52174: IFFALSE 52187
// ComStop ( i ) ;
52176: LD_VAR 0 7
52180: PPUSH
52181: CALL_OW 141
52185: GO 52173
52187: POP
52188: POP
// solds := [ ] ;
52189: LD_ADDR_VAR 0 2
52193: PUSH
52194: EMPTY
52195: ST_TO_ADDR
// exit ;
52196: GO 52513
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
52198: LD_VAR 0 5
52202: NOT
52203: PUSH
52204: LD_VAR 0 5
52208: PUSH
52209: LD_INT 3
52211: GREATER
52212: OR
52213: PUSH
52214: LD_EXP 98
52218: PUSH
52219: LD_VAR 0 1
52223: ARRAY
52224: OR
52225: IFFALSE 52266
// begin for i in solds do
52227: LD_ADDR_VAR 0 7
52231: PUSH
52232: LD_VAR 0 2
52236: PUSH
52237: FOR_IN
52238: IFFALSE 52262
// if HasTask ( i ) then
52240: LD_VAR 0 7
52244: PPUSH
52245: CALL_OW 314
52249: IFFALSE 52260
// ComStop ( i ) ;
52251: LD_VAR 0 7
52255: PPUSH
52256: CALL_OW 141
52260: GO 52237
52262: POP
52263: POP
// break ;
52264: GO 52501
// end ; for i in solds do
52266: LD_ADDR_VAR 0 7
52270: PUSH
52271: LD_VAR 0 2
52275: PUSH
52276: FOR_IN
52277: IFFALSE 52493
// begin if IsInUnit ( i ) then
52279: LD_VAR 0 7
52283: PPUSH
52284: CALL_OW 310
52288: IFFALSE 52299
// ComExitBuilding ( i ) ;
52290: LD_VAR 0 7
52294: PPUSH
52295: CALL_OW 122
// if GetLives ( i ) > 333 then
52299: LD_VAR 0 7
52303: PPUSH
52304: CALL_OW 256
52308: PUSH
52309: LD_INT 333
52311: GREATER
52312: IFFALSE 52340
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52314: LD_VAR 0 7
52318: PPUSH
52319: LD_VAR 0 5
52323: PPUSH
52324: LD_VAR 0 7
52328: PPUSH
52329: CALL_OW 74
52333: PPUSH
52334: CALL_OW 115
52338: GO 52491
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
52340: LD_ADDR_VAR 0 8
52344: PUSH
52345: LD_EXP 76
52349: PUSH
52350: LD_VAR 0 1
52354: ARRAY
52355: PPUSH
52356: LD_INT 2
52358: PUSH
52359: LD_INT 30
52361: PUSH
52362: LD_INT 0
52364: PUSH
52365: EMPTY
52366: LIST
52367: LIST
52368: PUSH
52369: LD_INT 30
52371: PUSH
52372: LD_INT 1
52374: PUSH
52375: EMPTY
52376: LIST
52377: LIST
52378: PUSH
52379: LD_INT 30
52381: PUSH
52382: LD_INT 6
52384: PUSH
52385: EMPTY
52386: LIST
52387: LIST
52388: PUSH
52389: EMPTY
52390: LIST
52391: LIST
52392: LIST
52393: LIST
52394: PPUSH
52395: CALL_OW 72
52399: PPUSH
52400: LD_VAR 0 7
52404: PPUSH
52405: CALL_OW 74
52409: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52410: LD_VAR 0 7
52414: PPUSH
52415: LD_VAR 0 8
52419: PPUSH
52420: CALL_OW 250
52424: PPUSH
52425: LD_INT 3
52427: PPUSH
52428: LD_INT 5
52430: PPUSH
52431: CALL_OW 272
52435: PPUSH
52436: LD_VAR 0 8
52440: PPUSH
52441: CALL_OW 251
52445: PPUSH
52446: LD_INT 3
52448: PPUSH
52449: LD_INT 5
52451: PPUSH
52452: CALL_OW 273
52456: PPUSH
52457: CALL_OW 111
// SetTag ( i , 0 ) ;
52461: LD_VAR 0 7
52465: PPUSH
52466: LD_INT 0
52468: PPUSH
52469: CALL_OW 109
// solds := solds diff i ;
52473: LD_ADDR_VAR 0 2
52477: PUSH
52478: LD_VAR 0 2
52482: PUSH
52483: LD_VAR 0 7
52487: DIFF
52488: ST_TO_ADDR
// continue ;
52489: GO 52276
// end ; end ;
52491: GO 52276
52493: POP
52494: POP
// until solds ;
52495: LD_VAR 0 2
52499: IFFALSE 52108
// MC_Reset ( base , 18 ) ;
52501: LD_VAR 0 1
52505: PPUSH
52506: LD_INT 18
52508: PPUSH
52509: CALL 24334 0 2
// end ;
52513: LD_VAR 0 4
52517: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52518: LD_INT 0
52520: PPUSH
52521: PPUSH
52522: PPUSH
52523: PPUSH
52524: PPUSH
52525: PPUSH
52526: PPUSH
52527: PPUSH
52528: PPUSH
52529: PPUSH
52530: PPUSH
52531: PPUSH
52532: PPUSH
52533: PPUSH
52534: PPUSH
52535: PPUSH
52536: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52537: LD_ADDR_VAR 0 13
52541: PUSH
52542: LD_EXP 76
52546: PUSH
52547: LD_VAR 0 1
52551: ARRAY
52552: PPUSH
52553: LD_INT 25
52555: PUSH
52556: LD_INT 3
52558: PUSH
52559: EMPTY
52560: LIST
52561: LIST
52562: PPUSH
52563: CALL_OW 72
52567: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52568: LD_EXP 116
52572: PUSH
52573: LD_VAR 0 1
52577: ARRAY
52578: IFFALSE 52602
// mechs := mechs diff mc_remote_driver [ base ] ;
52580: LD_ADDR_VAR 0 13
52584: PUSH
52585: LD_VAR 0 13
52589: PUSH
52590: LD_EXP 116
52594: PUSH
52595: LD_VAR 0 1
52599: ARRAY
52600: DIFF
52601: ST_TO_ADDR
// for i in mechs do
52602: LD_ADDR_VAR 0 5
52606: PUSH
52607: LD_VAR 0 13
52611: PUSH
52612: FOR_IN
52613: IFFALSE 52648
// if GetTag ( i ) > 0 then
52615: LD_VAR 0 5
52619: PPUSH
52620: CALL_OW 110
52624: PUSH
52625: LD_INT 0
52627: GREATER
52628: IFFALSE 52646
// mechs := mechs diff i ;
52630: LD_ADDR_VAR 0 13
52634: PUSH
52635: LD_VAR 0 13
52639: PUSH
52640: LD_VAR 0 5
52644: DIFF
52645: ST_TO_ADDR
52646: GO 52612
52648: POP
52649: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52650: LD_ADDR_VAR 0 9
52654: PUSH
52655: LD_EXP 76
52659: PUSH
52660: LD_VAR 0 1
52664: ARRAY
52665: PPUSH
52666: LD_INT 2
52668: PUSH
52669: LD_INT 25
52671: PUSH
52672: LD_INT 1
52674: PUSH
52675: EMPTY
52676: LIST
52677: LIST
52678: PUSH
52679: LD_INT 25
52681: PUSH
52682: LD_INT 5
52684: PUSH
52685: EMPTY
52686: LIST
52687: LIST
52688: PUSH
52689: LD_INT 25
52691: PUSH
52692: LD_INT 8
52694: PUSH
52695: EMPTY
52696: LIST
52697: LIST
52698: PUSH
52699: LD_INT 25
52701: PUSH
52702: LD_INT 9
52704: PUSH
52705: EMPTY
52706: LIST
52707: LIST
52708: PUSH
52709: EMPTY
52710: LIST
52711: LIST
52712: LIST
52713: LIST
52714: LIST
52715: PPUSH
52716: CALL_OW 72
52720: ST_TO_ADDR
// if not defenders and not solds then
52721: LD_VAR 0 2
52725: NOT
52726: PUSH
52727: LD_VAR 0 9
52731: NOT
52732: AND
52733: IFFALSE 52737
// exit ;
52735: GO 54363
// depot_under_attack := false ;
52737: LD_ADDR_VAR 0 17
52741: PUSH
52742: LD_INT 0
52744: ST_TO_ADDR
// sold_defenders := [ ] ;
52745: LD_ADDR_VAR 0 18
52749: PUSH
52750: EMPTY
52751: ST_TO_ADDR
// if mechs then
52752: LD_VAR 0 13
52756: IFFALSE 52885
// for i in defenders do
52758: LD_ADDR_VAR 0 5
52762: PUSH
52763: LD_VAR 0 2
52767: PUSH
52768: FOR_IN
52769: IFFALSE 52883
// begin SetTag ( i , 20 ) ;
52771: LD_VAR 0 5
52775: PPUSH
52776: LD_INT 20
52778: PPUSH
52779: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
52783: LD_VAR 0 5
52787: PPUSH
52788: CALL_OW 263
52792: PUSH
52793: LD_INT 1
52795: EQUAL
52796: PUSH
52797: LD_VAR 0 5
52801: PPUSH
52802: CALL_OW 311
52806: NOT
52807: AND
52808: PUSH
52809: LD_VAR 0 13
52813: AND
52814: IFFALSE 52881
// begin un := mechs [ 1 ] ;
52816: LD_ADDR_VAR 0 11
52820: PUSH
52821: LD_VAR 0 13
52825: PUSH
52826: LD_INT 1
52828: ARRAY
52829: ST_TO_ADDR
// ComExitBuilding ( un ) ;
52830: LD_VAR 0 11
52834: PPUSH
52835: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
52839: LD_VAR 0 11
52843: PPUSH
52844: LD_VAR 0 5
52848: PPUSH
52849: CALL_OW 180
// SetTag ( un , 19 ) ;
52853: LD_VAR 0 11
52857: PPUSH
52858: LD_INT 19
52860: PPUSH
52861: CALL_OW 109
// mechs := mechs diff un ;
52865: LD_ADDR_VAR 0 13
52869: PUSH
52870: LD_VAR 0 13
52874: PUSH
52875: LD_VAR 0 11
52879: DIFF
52880: ST_TO_ADDR
// end ; end ;
52881: GO 52768
52883: POP
52884: POP
// if solds then
52885: LD_VAR 0 9
52889: IFFALSE 52948
// for i in solds do
52891: LD_ADDR_VAR 0 5
52895: PUSH
52896: LD_VAR 0 9
52900: PUSH
52901: FOR_IN
52902: IFFALSE 52946
// if not GetTag ( i ) then
52904: LD_VAR 0 5
52908: PPUSH
52909: CALL_OW 110
52913: NOT
52914: IFFALSE 52944
// begin defenders := defenders union i ;
52916: LD_ADDR_VAR 0 2
52920: PUSH
52921: LD_VAR 0 2
52925: PUSH
52926: LD_VAR 0 5
52930: UNION
52931: ST_TO_ADDR
// SetTag ( i , 18 ) ;
52932: LD_VAR 0 5
52936: PPUSH
52937: LD_INT 18
52939: PPUSH
52940: CALL_OW 109
// end ;
52944: GO 52901
52946: POP
52947: POP
// repeat wait ( 0 0$1 ) ;
52948: LD_INT 35
52950: PPUSH
52951: CALL_OW 67
// enemy := mc_scan [ base ] ;
52955: LD_ADDR_VAR 0 3
52959: PUSH
52960: LD_EXP 99
52964: PUSH
52965: LD_VAR 0 1
52969: ARRAY
52970: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52971: LD_EXP 76
52975: PUSH
52976: LD_VAR 0 1
52980: ARRAY
52981: NOT
52982: PUSH
52983: LD_EXP 76
52987: PUSH
52988: LD_VAR 0 1
52992: ARRAY
52993: PUSH
52994: EMPTY
52995: EQUAL
52996: OR
52997: IFFALSE 53034
// begin for i in defenders do
52999: LD_ADDR_VAR 0 5
53003: PUSH
53004: LD_VAR 0 2
53008: PUSH
53009: FOR_IN
53010: IFFALSE 53023
// ComStop ( i ) ;
53012: LD_VAR 0 5
53016: PPUSH
53017: CALL_OW 141
53021: GO 53009
53023: POP
53024: POP
// defenders := [ ] ;
53025: LD_ADDR_VAR 0 2
53029: PUSH
53030: EMPTY
53031: ST_TO_ADDR
// exit ;
53032: GO 54363
// end ; for i in defenders do
53034: LD_ADDR_VAR 0 5
53038: PUSH
53039: LD_VAR 0 2
53043: PUSH
53044: FOR_IN
53045: IFFALSE 53863
// begin e := NearestUnitToUnit ( enemy , i ) ;
53047: LD_ADDR_VAR 0 14
53051: PUSH
53052: LD_VAR 0 3
53056: PPUSH
53057: LD_VAR 0 5
53061: PPUSH
53062: CALL_OW 74
53066: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53067: LD_ADDR_VAR 0 8
53071: PUSH
53072: LD_EXP 76
53076: PUSH
53077: LD_VAR 0 1
53081: ARRAY
53082: PPUSH
53083: LD_INT 2
53085: PUSH
53086: LD_INT 30
53088: PUSH
53089: LD_INT 0
53091: PUSH
53092: EMPTY
53093: LIST
53094: LIST
53095: PUSH
53096: LD_INT 30
53098: PUSH
53099: LD_INT 1
53101: PUSH
53102: EMPTY
53103: LIST
53104: LIST
53105: PUSH
53106: EMPTY
53107: LIST
53108: LIST
53109: LIST
53110: PPUSH
53111: CALL_OW 72
53115: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
53116: LD_ADDR_VAR 0 17
53120: PUSH
53121: LD_VAR 0 8
53125: NOT
53126: PUSH
53127: LD_VAR 0 8
53131: PPUSH
53132: LD_INT 3
53134: PUSH
53135: LD_INT 24
53137: PUSH
53138: LD_INT 600
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: PUSH
53145: EMPTY
53146: LIST
53147: LIST
53148: PPUSH
53149: CALL_OW 72
53153: OR
53154: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
53155: LD_VAR 0 5
53159: PPUSH
53160: CALL_OW 247
53164: PUSH
53165: LD_INT 2
53167: DOUBLE
53168: EQUAL
53169: IFTRUE 53173
53171: GO 53569
53173: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
53174: LD_VAR 0 5
53178: PPUSH
53179: CALL_OW 256
53183: PUSH
53184: LD_INT 650
53186: GREATER
53187: PUSH
53188: LD_VAR 0 5
53192: PPUSH
53193: LD_VAR 0 14
53197: PPUSH
53198: CALL_OW 296
53202: PUSH
53203: LD_INT 40
53205: LESS
53206: PUSH
53207: LD_VAR 0 14
53211: PPUSH
53212: LD_EXP 101
53216: PUSH
53217: LD_VAR 0 1
53221: ARRAY
53222: PPUSH
53223: CALL_OW 308
53227: OR
53228: AND
53229: IFFALSE 53351
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
53231: LD_VAR 0 5
53235: PPUSH
53236: CALL_OW 262
53240: PUSH
53241: LD_INT 1
53243: EQUAL
53244: PUSH
53245: LD_VAR 0 5
53249: PPUSH
53250: CALL_OW 261
53254: PUSH
53255: LD_INT 30
53257: LESS
53258: AND
53259: PUSH
53260: LD_VAR 0 8
53264: AND
53265: IFFALSE 53335
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
53267: LD_VAR 0 5
53271: PPUSH
53272: LD_VAR 0 8
53276: PPUSH
53277: LD_VAR 0 5
53281: PPUSH
53282: CALL_OW 74
53286: PPUSH
53287: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
53291: LD_VAR 0 5
53295: PPUSH
53296: LD_VAR 0 8
53300: PPUSH
53301: LD_VAR 0 5
53305: PPUSH
53306: CALL_OW 74
53310: PPUSH
53311: CALL_OW 296
53315: PUSH
53316: LD_INT 6
53318: LESS
53319: IFFALSE 53333
// SetFuel ( i , 100 ) ;
53321: LD_VAR 0 5
53325: PPUSH
53326: LD_INT 100
53328: PPUSH
53329: CALL_OW 240
// end else
53333: GO 53349
// ComAttackUnit ( i , e ) ;
53335: LD_VAR 0 5
53339: PPUSH
53340: LD_VAR 0 14
53344: PPUSH
53345: CALL_OW 115
// end else
53349: GO 53452
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
53351: LD_VAR 0 14
53355: PPUSH
53356: LD_EXP 101
53360: PUSH
53361: LD_VAR 0 1
53365: ARRAY
53366: PPUSH
53367: CALL_OW 308
53371: NOT
53372: PUSH
53373: LD_VAR 0 5
53377: PPUSH
53378: LD_VAR 0 14
53382: PPUSH
53383: CALL_OW 296
53387: PUSH
53388: LD_INT 40
53390: GREATEREQUAL
53391: AND
53392: PUSH
53393: LD_VAR 0 5
53397: PPUSH
53398: CALL_OW 256
53402: PUSH
53403: LD_INT 650
53405: LESSEQUAL
53406: OR
53407: PUSH
53408: LD_VAR 0 5
53412: PPUSH
53413: LD_EXP 100
53417: PUSH
53418: LD_VAR 0 1
53422: ARRAY
53423: PPUSH
53424: CALL_OW 308
53428: NOT
53429: AND
53430: IFFALSE 53452
// ComMoveToArea ( i , mc_parking [ base ] ) ;
53432: LD_VAR 0 5
53436: PPUSH
53437: LD_EXP 100
53441: PUSH
53442: LD_VAR 0 1
53446: ARRAY
53447: PPUSH
53448: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
53452: LD_VAR 0 5
53456: PPUSH
53457: CALL_OW 256
53461: PUSH
53462: LD_INT 998
53464: LESS
53465: PUSH
53466: LD_VAR 0 5
53470: PPUSH
53471: CALL_OW 263
53475: PUSH
53476: LD_INT 1
53478: EQUAL
53479: AND
53480: PUSH
53481: LD_VAR 0 5
53485: PPUSH
53486: CALL_OW 311
53490: AND
53491: PUSH
53492: LD_VAR 0 5
53496: PPUSH
53497: LD_EXP 100
53501: PUSH
53502: LD_VAR 0 1
53506: ARRAY
53507: PPUSH
53508: CALL_OW 308
53512: AND
53513: IFFALSE 53567
// begin mech := IsDrivenBy ( i ) ;
53515: LD_ADDR_VAR 0 10
53519: PUSH
53520: LD_VAR 0 5
53524: PPUSH
53525: CALL_OW 311
53529: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53530: LD_VAR 0 10
53534: PPUSH
53535: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53539: LD_VAR 0 10
53543: PPUSH
53544: LD_VAR 0 5
53548: PPUSH
53549: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53553: LD_VAR 0 10
53557: PPUSH
53558: LD_VAR 0 5
53562: PPUSH
53563: CALL_OW 180
// end ; end ; unit_human :
53567: GO 53834
53569: LD_INT 1
53571: DOUBLE
53572: EQUAL
53573: IFTRUE 53577
53575: GO 53833
53577: POP
// begin b := IsInUnit ( i ) ;
53578: LD_ADDR_VAR 0 19
53582: PUSH
53583: LD_VAR 0 5
53587: PPUSH
53588: CALL_OW 310
53592: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53593: LD_ADDR_VAR 0 20
53597: PUSH
53598: LD_VAR 0 19
53602: NOT
53603: PUSH
53604: LD_VAR 0 19
53608: PPUSH
53609: CALL_OW 266
53613: PUSH
53614: LD_INT 32
53616: PUSH
53617: LD_INT 31
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: IN
53624: OR
53625: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53626: LD_VAR 0 17
53630: PUSH
53631: LD_VAR 0 2
53635: PPUSH
53636: LD_INT 21
53638: PUSH
53639: LD_INT 2
53641: PUSH
53642: EMPTY
53643: LIST
53644: LIST
53645: PPUSH
53646: CALL_OW 72
53650: PUSH
53651: LD_INT 1
53653: LESSEQUAL
53654: OR
53655: PUSH
53656: LD_VAR 0 20
53660: AND
53661: PUSH
53662: LD_VAR 0 5
53666: PUSH
53667: LD_VAR 0 18
53671: IN
53672: NOT
53673: AND
53674: IFFALSE 53767
// begin if b then
53676: LD_VAR 0 19
53680: IFFALSE 53729
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53682: LD_VAR 0 19
53686: PPUSH
53687: LD_VAR 0 3
53691: PPUSH
53692: LD_VAR 0 19
53696: PPUSH
53697: CALL_OW 74
53701: PPUSH
53702: CALL_OW 296
53706: PUSH
53707: LD_INT 10
53709: LESS
53710: PUSH
53711: LD_VAR 0 19
53715: PPUSH
53716: CALL_OW 461
53720: PUSH
53721: LD_INT 7
53723: NONEQUAL
53724: AND
53725: IFFALSE 53729
// continue ;
53727: GO 53044
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53729: LD_ADDR_VAR 0 18
53733: PUSH
53734: LD_VAR 0 18
53738: PPUSH
53739: LD_VAR 0 18
53743: PUSH
53744: LD_INT 1
53746: PLUS
53747: PPUSH
53748: LD_VAR 0 5
53752: PPUSH
53753: CALL_OW 1
53757: ST_TO_ADDR
// ComExitBuilding ( i ) ;
53758: LD_VAR 0 5
53762: PPUSH
53763: CALL_OW 122
// end ; if sold_defenders then
53767: LD_VAR 0 18
53771: IFFALSE 53831
// if i in sold_defenders then
53773: LD_VAR 0 5
53777: PUSH
53778: LD_VAR 0 18
53782: IN
53783: IFFALSE 53831
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
53785: LD_VAR 0 5
53789: PPUSH
53790: CALL_OW 314
53794: NOT
53795: PUSH
53796: LD_VAR 0 5
53800: PPUSH
53801: LD_VAR 0 14
53805: PPUSH
53806: CALL_OW 296
53810: PUSH
53811: LD_INT 30
53813: LESS
53814: AND
53815: IFFALSE 53831
// ComAttackUnit ( i , e ) ;
53817: LD_VAR 0 5
53821: PPUSH
53822: LD_VAR 0 14
53826: PPUSH
53827: CALL_OW 115
// end ; end ; end ;
53831: GO 53834
53833: POP
// if IsDead ( i ) then
53834: LD_VAR 0 5
53838: PPUSH
53839: CALL_OW 301
53843: IFFALSE 53861
// defenders := defenders diff i ;
53845: LD_ADDR_VAR 0 2
53849: PUSH
53850: LD_VAR 0 2
53854: PUSH
53855: LD_VAR 0 5
53859: DIFF
53860: ST_TO_ADDR
// end ;
53861: GO 53044
53863: POP
53864: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
53865: LD_VAR 0 3
53869: NOT
53870: PUSH
53871: LD_VAR 0 2
53875: NOT
53876: OR
53877: PUSH
53878: LD_EXP 76
53882: PUSH
53883: LD_VAR 0 1
53887: ARRAY
53888: NOT
53889: OR
53890: IFFALSE 52948
// MC_Reset ( base , 18 ) ;
53892: LD_VAR 0 1
53896: PPUSH
53897: LD_INT 18
53899: PPUSH
53900: CALL 24334 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53904: LD_ADDR_VAR 0 2
53908: PUSH
53909: LD_VAR 0 2
53913: PUSH
53914: LD_VAR 0 2
53918: PPUSH
53919: LD_INT 2
53921: PUSH
53922: LD_INT 25
53924: PUSH
53925: LD_INT 1
53927: PUSH
53928: EMPTY
53929: LIST
53930: LIST
53931: PUSH
53932: LD_INT 25
53934: PUSH
53935: LD_INT 5
53937: PUSH
53938: EMPTY
53939: LIST
53940: LIST
53941: PUSH
53942: LD_INT 25
53944: PUSH
53945: LD_INT 8
53947: PUSH
53948: EMPTY
53949: LIST
53950: LIST
53951: PUSH
53952: LD_INT 25
53954: PUSH
53955: LD_INT 9
53957: PUSH
53958: EMPTY
53959: LIST
53960: LIST
53961: PUSH
53962: EMPTY
53963: LIST
53964: LIST
53965: LIST
53966: LIST
53967: LIST
53968: PPUSH
53969: CALL_OW 72
53973: DIFF
53974: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
53975: LD_VAR 0 3
53979: NOT
53980: PUSH
53981: LD_VAR 0 2
53985: PPUSH
53986: LD_INT 21
53988: PUSH
53989: LD_INT 2
53991: PUSH
53992: EMPTY
53993: LIST
53994: LIST
53995: PPUSH
53996: CALL_OW 72
54000: AND
54001: IFFALSE 54339
// begin tmp := FilterByTag ( defenders , 19 ) ;
54003: LD_ADDR_VAR 0 12
54007: PUSH
54008: LD_VAR 0 2
54012: PPUSH
54013: LD_INT 19
54015: PPUSH
54016: CALL 90818 0 2
54020: ST_TO_ADDR
// if tmp then
54021: LD_VAR 0 12
54025: IFFALSE 54095
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
54027: LD_ADDR_VAR 0 12
54031: PUSH
54032: LD_VAR 0 12
54036: PPUSH
54037: LD_INT 25
54039: PUSH
54040: LD_INT 3
54042: PUSH
54043: EMPTY
54044: LIST
54045: LIST
54046: PPUSH
54047: CALL_OW 72
54051: ST_TO_ADDR
// if tmp then
54052: LD_VAR 0 12
54056: IFFALSE 54095
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
54058: LD_ADDR_EXP 88
54062: PUSH
54063: LD_EXP 88
54067: PPUSH
54068: LD_VAR 0 1
54072: PPUSH
54073: LD_EXP 88
54077: PUSH
54078: LD_VAR 0 1
54082: ARRAY
54083: PUSH
54084: LD_VAR 0 12
54088: UNION
54089: PPUSH
54090: CALL_OW 1
54094: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
54095: LD_VAR 0 1
54099: PPUSH
54100: LD_INT 19
54102: PPUSH
54103: CALL 24334 0 2
// repeat wait ( 0 0$1 ) ;
54107: LD_INT 35
54109: PPUSH
54110: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
54114: LD_EXP 76
54118: PUSH
54119: LD_VAR 0 1
54123: ARRAY
54124: NOT
54125: PUSH
54126: LD_EXP 76
54130: PUSH
54131: LD_VAR 0 1
54135: ARRAY
54136: PUSH
54137: EMPTY
54138: EQUAL
54139: OR
54140: IFFALSE 54177
// begin for i in defenders do
54142: LD_ADDR_VAR 0 5
54146: PUSH
54147: LD_VAR 0 2
54151: PUSH
54152: FOR_IN
54153: IFFALSE 54166
// ComStop ( i ) ;
54155: LD_VAR 0 5
54159: PPUSH
54160: CALL_OW 141
54164: GO 54152
54166: POP
54167: POP
// defenders := [ ] ;
54168: LD_ADDR_VAR 0 2
54172: PUSH
54173: EMPTY
54174: ST_TO_ADDR
// exit ;
54175: GO 54363
// end ; for i in defenders do
54177: LD_ADDR_VAR 0 5
54181: PUSH
54182: LD_VAR 0 2
54186: PUSH
54187: FOR_IN
54188: IFFALSE 54277
// begin if not IsInArea ( i , mc_parking [ base ] ) then
54190: LD_VAR 0 5
54194: PPUSH
54195: LD_EXP 100
54199: PUSH
54200: LD_VAR 0 1
54204: ARRAY
54205: PPUSH
54206: CALL_OW 308
54210: NOT
54211: IFFALSE 54235
// ComMoveToArea ( i , mc_parking [ base ] ) else
54213: LD_VAR 0 5
54217: PPUSH
54218: LD_EXP 100
54222: PUSH
54223: LD_VAR 0 1
54227: ARRAY
54228: PPUSH
54229: CALL_OW 113
54233: GO 54275
// if GetControl ( i ) = control_manual then
54235: LD_VAR 0 5
54239: PPUSH
54240: CALL_OW 263
54244: PUSH
54245: LD_INT 1
54247: EQUAL
54248: IFFALSE 54275
// if IsDrivenBy ( i ) then
54250: LD_VAR 0 5
54254: PPUSH
54255: CALL_OW 311
54259: IFFALSE 54275
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
54261: LD_VAR 0 5
54265: PPUSH
54266: CALL_OW 311
54270: PPUSH
54271: CALL_OW 121
// end ;
54275: GO 54187
54277: POP
54278: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
54279: LD_VAR 0 2
54283: PPUSH
54284: LD_INT 95
54286: PUSH
54287: LD_EXP 100
54291: PUSH
54292: LD_VAR 0 1
54296: ARRAY
54297: PUSH
54298: EMPTY
54299: LIST
54300: LIST
54301: PPUSH
54302: CALL_OW 72
54306: PUSH
54307: LD_VAR 0 2
54311: EQUAL
54312: PUSH
54313: LD_EXP 99
54317: PUSH
54318: LD_VAR 0 1
54322: ARRAY
54323: OR
54324: PUSH
54325: LD_EXP 76
54329: PUSH
54330: LD_VAR 0 1
54334: ARRAY
54335: NOT
54336: OR
54337: IFFALSE 54107
// end ; MC_Reset ( base , 19 ) ;
54339: LD_VAR 0 1
54343: PPUSH
54344: LD_INT 19
54346: PPUSH
54347: CALL 24334 0 2
// MC_Reset ( base , 20 ) ;
54351: LD_VAR 0 1
54355: PPUSH
54356: LD_INT 20
54358: PPUSH
54359: CALL 24334 0 2
// end ;
54363: LD_VAR 0 4
54367: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54368: LD_INT 0
54370: PPUSH
54371: PPUSH
54372: PPUSH
54373: PPUSH
// result := false ;
54374: LD_ADDR_VAR 0 2
54378: PUSH
54379: LD_INT 0
54381: ST_TO_ADDR
// side := GetSide ( unit ) ;
54382: LD_ADDR_VAR 0 3
54386: PUSH
54387: LD_VAR 0 1
54391: PPUSH
54392: CALL_OW 255
54396: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54397: LD_ADDR_VAR 0 4
54401: PUSH
54402: LD_VAR 0 1
54406: PPUSH
54407: CALL_OW 248
54411: ST_TO_ADDR
// case nat of 1 :
54412: LD_VAR 0 4
54416: PUSH
54417: LD_INT 1
54419: DOUBLE
54420: EQUAL
54421: IFTRUE 54425
54423: GO 54436
54425: POP
// tech := tech_lassight ; 2 :
54426: LD_ADDR_VAR 0 5
54430: PUSH
54431: LD_INT 12
54433: ST_TO_ADDR
54434: GO 54475
54436: LD_INT 2
54438: DOUBLE
54439: EQUAL
54440: IFTRUE 54444
54442: GO 54455
54444: POP
// tech := tech_mortar ; 3 :
54445: LD_ADDR_VAR 0 5
54449: PUSH
54450: LD_INT 41
54452: ST_TO_ADDR
54453: GO 54475
54455: LD_INT 3
54457: DOUBLE
54458: EQUAL
54459: IFTRUE 54463
54461: GO 54474
54463: POP
// tech := tech_bazooka ; end ;
54464: LD_ADDR_VAR 0 5
54468: PUSH
54469: LD_INT 44
54471: ST_TO_ADDR
54472: GO 54475
54474: POP
// if Researched ( side , tech ) then
54475: LD_VAR 0 3
54479: PPUSH
54480: LD_VAR 0 5
54484: PPUSH
54485: CALL_OW 325
54489: IFFALSE 54516
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54491: LD_ADDR_VAR 0 2
54495: PUSH
54496: LD_INT 5
54498: PUSH
54499: LD_INT 8
54501: PUSH
54502: LD_INT 9
54504: PUSH
54505: EMPTY
54506: LIST
54507: LIST
54508: LIST
54509: PUSH
54510: LD_VAR 0 4
54514: ARRAY
54515: ST_TO_ADDR
// end ;
54516: LD_VAR 0 2
54520: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54521: LD_INT 0
54523: PPUSH
54524: PPUSH
54525: PPUSH
// if not mines then
54526: LD_VAR 0 2
54530: NOT
54531: IFFALSE 54535
// exit ;
54533: GO 54679
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54535: LD_ADDR_VAR 0 5
54539: PUSH
54540: LD_INT 81
54542: PUSH
54543: LD_VAR 0 1
54547: PUSH
54548: EMPTY
54549: LIST
54550: LIST
54551: PUSH
54552: LD_INT 3
54554: PUSH
54555: LD_INT 21
54557: PUSH
54558: LD_INT 3
54560: PUSH
54561: EMPTY
54562: LIST
54563: LIST
54564: PUSH
54565: EMPTY
54566: LIST
54567: LIST
54568: PUSH
54569: EMPTY
54570: LIST
54571: LIST
54572: PPUSH
54573: CALL_OW 69
54577: ST_TO_ADDR
// for i in mines do
54578: LD_ADDR_VAR 0 4
54582: PUSH
54583: LD_VAR 0 2
54587: PUSH
54588: FOR_IN
54589: IFFALSE 54677
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54591: LD_VAR 0 4
54595: PUSH
54596: LD_INT 1
54598: ARRAY
54599: PPUSH
54600: LD_VAR 0 4
54604: PUSH
54605: LD_INT 2
54607: ARRAY
54608: PPUSH
54609: CALL_OW 458
54613: NOT
54614: IFFALSE 54618
// continue ;
54616: GO 54588
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54618: LD_VAR 0 4
54622: PUSH
54623: LD_INT 1
54625: ARRAY
54626: PPUSH
54627: LD_VAR 0 4
54631: PUSH
54632: LD_INT 2
54634: ARRAY
54635: PPUSH
54636: CALL_OW 428
54640: PUSH
54641: LD_VAR 0 5
54645: IN
54646: IFFALSE 54675
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54648: LD_VAR 0 4
54652: PUSH
54653: LD_INT 1
54655: ARRAY
54656: PPUSH
54657: LD_VAR 0 4
54661: PUSH
54662: LD_INT 2
54664: ARRAY
54665: PPUSH
54666: LD_VAR 0 1
54670: PPUSH
54671: CALL_OW 456
// end ;
54675: GO 54588
54677: POP
54678: POP
// end ;
54679: LD_VAR 0 3
54683: RET
// export function Count ( array ) ; var i ; begin
54684: LD_INT 0
54686: PPUSH
54687: PPUSH
// result := 0 ;
54688: LD_ADDR_VAR 0 2
54692: PUSH
54693: LD_INT 0
54695: ST_TO_ADDR
// for i in array do
54696: LD_ADDR_VAR 0 3
54700: PUSH
54701: LD_VAR 0 1
54705: PUSH
54706: FOR_IN
54707: IFFALSE 54731
// if i then
54709: LD_VAR 0 3
54713: IFFALSE 54729
// result := result + 1 ;
54715: LD_ADDR_VAR 0 2
54719: PUSH
54720: LD_VAR 0 2
54724: PUSH
54725: LD_INT 1
54727: PLUS
54728: ST_TO_ADDR
54729: GO 54706
54731: POP
54732: POP
// end ;
54733: LD_VAR 0 2
54737: RET
// export function IsEmpty ( building ) ; begin
54738: LD_INT 0
54740: PPUSH
// if not building then
54741: LD_VAR 0 1
54745: NOT
54746: IFFALSE 54750
// exit ;
54748: GO 54793
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54750: LD_ADDR_VAR 0 2
54754: PUSH
54755: LD_VAR 0 1
54759: PUSH
54760: LD_INT 22
54762: PUSH
54763: LD_VAR 0 1
54767: PPUSH
54768: CALL_OW 255
54772: PUSH
54773: EMPTY
54774: LIST
54775: LIST
54776: PUSH
54777: LD_INT 58
54779: PUSH
54780: EMPTY
54781: LIST
54782: PUSH
54783: EMPTY
54784: LIST
54785: LIST
54786: PPUSH
54787: CALL_OW 69
54791: IN
54792: ST_TO_ADDR
// end ;
54793: LD_VAR 0 2
54797: RET
// export function IsNotFull ( building ) ; begin
54798: LD_INT 0
54800: PPUSH
// if not building then
54801: LD_VAR 0 1
54805: NOT
54806: IFFALSE 54810
// exit ;
54808: GO 54829
// result := UnitsInside ( building ) < 6 ;
54810: LD_ADDR_VAR 0 2
54814: PUSH
54815: LD_VAR 0 1
54819: PPUSH
54820: CALL_OW 313
54824: PUSH
54825: LD_INT 6
54827: LESS
54828: ST_TO_ADDR
// end ;
54829: LD_VAR 0 2
54833: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54834: LD_INT 0
54836: PPUSH
54837: PPUSH
54838: PPUSH
54839: PPUSH
// tmp := [ ] ;
54840: LD_ADDR_VAR 0 3
54844: PUSH
54845: EMPTY
54846: ST_TO_ADDR
// list := [ ] ;
54847: LD_ADDR_VAR 0 5
54851: PUSH
54852: EMPTY
54853: ST_TO_ADDR
// for i = 16 to 25 do
54854: LD_ADDR_VAR 0 4
54858: PUSH
54859: DOUBLE
54860: LD_INT 16
54862: DEC
54863: ST_TO_ADDR
54864: LD_INT 25
54866: PUSH
54867: FOR_TO
54868: IFFALSE 54941
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54870: LD_ADDR_VAR 0 3
54874: PUSH
54875: LD_VAR 0 3
54879: PUSH
54880: LD_INT 22
54882: PUSH
54883: LD_VAR 0 1
54887: PPUSH
54888: CALL_OW 255
54892: PUSH
54893: EMPTY
54894: LIST
54895: LIST
54896: PUSH
54897: LD_INT 91
54899: PUSH
54900: LD_VAR 0 1
54904: PUSH
54905: LD_INT 6
54907: PUSH
54908: EMPTY
54909: LIST
54910: LIST
54911: LIST
54912: PUSH
54913: LD_INT 30
54915: PUSH
54916: LD_VAR 0 4
54920: PUSH
54921: EMPTY
54922: LIST
54923: LIST
54924: PUSH
54925: EMPTY
54926: LIST
54927: LIST
54928: LIST
54929: PUSH
54930: EMPTY
54931: LIST
54932: PPUSH
54933: CALL_OW 69
54937: ADD
54938: ST_TO_ADDR
54939: GO 54867
54941: POP
54942: POP
// for i = 1 to tmp do
54943: LD_ADDR_VAR 0 4
54947: PUSH
54948: DOUBLE
54949: LD_INT 1
54951: DEC
54952: ST_TO_ADDR
54953: LD_VAR 0 3
54957: PUSH
54958: FOR_TO
54959: IFFALSE 55047
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54961: LD_ADDR_VAR 0 5
54965: PUSH
54966: LD_VAR 0 5
54970: PUSH
54971: LD_VAR 0 3
54975: PUSH
54976: LD_VAR 0 4
54980: ARRAY
54981: PPUSH
54982: CALL_OW 266
54986: PUSH
54987: LD_VAR 0 3
54991: PUSH
54992: LD_VAR 0 4
54996: ARRAY
54997: PPUSH
54998: CALL_OW 250
55002: PUSH
55003: LD_VAR 0 3
55007: PUSH
55008: LD_VAR 0 4
55012: ARRAY
55013: PPUSH
55014: CALL_OW 251
55018: PUSH
55019: LD_VAR 0 3
55023: PUSH
55024: LD_VAR 0 4
55028: ARRAY
55029: PPUSH
55030: CALL_OW 254
55034: PUSH
55035: EMPTY
55036: LIST
55037: LIST
55038: LIST
55039: LIST
55040: PUSH
55041: EMPTY
55042: LIST
55043: ADD
55044: ST_TO_ADDR
55045: GO 54958
55047: POP
55048: POP
// result := list ;
55049: LD_ADDR_VAR 0 2
55053: PUSH
55054: LD_VAR 0 5
55058: ST_TO_ADDR
// end ;
55059: LD_VAR 0 2
55063: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55064: LD_INT 0
55066: PPUSH
55067: PPUSH
55068: PPUSH
55069: PPUSH
55070: PPUSH
55071: PPUSH
55072: PPUSH
// if not factory then
55073: LD_VAR 0 1
55077: NOT
55078: IFFALSE 55082
// exit ;
55080: GO 55675
// if control = control_apeman then
55082: LD_VAR 0 4
55086: PUSH
55087: LD_INT 5
55089: EQUAL
55090: IFFALSE 55199
// begin tmp := UnitsInside ( factory ) ;
55092: LD_ADDR_VAR 0 8
55096: PUSH
55097: LD_VAR 0 1
55101: PPUSH
55102: CALL_OW 313
55106: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55107: LD_VAR 0 8
55111: PPUSH
55112: LD_INT 25
55114: PUSH
55115: LD_INT 12
55117: PUSH
55118: EMPTY
55119: LIST
55120: LIST
55121: PPUSH
55122: CALL_OW 72
55126: NOT
55127: IFFALSE 55137
// control := control_manual ;
55129: LD_ADDR_VAR 0 4
55133: PUSH
55134: LD_INT 1
55136: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55137: LD_ADDR_VAR 0 8
55141: PUSH
55142: LD_VAR 0 1
55146: PPUSH
55147: CALL 54834 0 1
55151: ST_TO_ADDR
// if tmp then
55152: LD_VAR 0 8
55156: IFFALSE 55199
// begin for i in tmp do
55158: LD_ADDR_VAR 0 7
55162: PUSH
55163: LD_VAR 0 8
55167: PUSH
55168: FOR_IN
55169: IFFALSE 55197
// if i [ 1 ] = b_ext_radio then
55171: LD_VAR 0 7
55175: PUSH
55176: LD_INT 1
55178: ARRAY
55179: PUSH
55180: LD_INT 22
55182: EQUAL
55183: IFFALSE 55195
// begin control := control_remote ;
55185: LD_ADDR_VAR 0 4
55189: PUSH
55190: LD_INT 2
55192: ST_TO_ADDR
// break ;
55193: GO 55197
// end ;
55195: GO 55168
55197: POP
55198: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55199: LD_VAR 0 1
55203: PPUSH
55204: LD_VAR 0 2
55208: PPUSH
55209: LD_VAR 0 3
55213: PPUSH
55214: LD_VAR 0 4
55218: PPUSH
55219: LD_VAR 0 5
55223: PPUSH
55224: CALL_OW 448
55228: IFFALSE 55263
// begin result := [ chassis , engine , control , weapon ] ;
55230: LD_ADDR_VAR 0 6
55234: PUSH
55235: LD_VAR 0 2
55239: PUSH
55240: LD_VAR 0 3
55244: PUSH
55245: LD_VAR 0 4
55249: PUSH
55250: LD_VAR 0 5
55254: PUSH
55255: EMPTY
55256: LIST
55257: LIST
55258: LIST
55259: LIST
55260: ST_TO_ADDR
// exit ;
55261: GO 55675
// end ; _chassis := AvailableChassisList ( factory ) ;
55263: LD_ADDR_VAR 0 9
55267: PUSH
55268: LD_VAR 0 1
55272: PPUSH
55273: CALL_OW 475
55277: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55278: LD_ADDR_VAR 0 11
55282: PUSH
55283: LD_VAR 0 1
55287: PPUSH
55288: CALL_OW 476
55292: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55293: LD_ADDR_VAR 0 12
55297: PUSH
55298: LD_VAR 0 1
55302: PPUSH
55303: CALL_OW 477
55307: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55308: LD_ADDR_VAR 0 10
55312: PUSH
55313: LD_VAR 0 1
55317: PPUSH
55318: CALL_OW 478
55322: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55323: LD_VAR 0 9
55327: NOT
55328: PUSH
55329: LD_VAR 0 11
55333: NOT
55334: OR
55335: PUSH
55336: LD_VAR 0 12
55340: NOT
55341: OR
55342: PUSH
55343: LD_VAR 0 10
55347: NOT
55348: OR
55349: IFFALSE 55384
// begin result := [ chassis , engine , control , weapon ] ;
55351: LD_ADDR_VAR 0 6
55355: PUSH
55356: LD_VAR 0 2
55360: PUSH
55361: LD_VAR 0 3
55365: PUSH
55366: LD_VAR 0 4
55370: PUSH
55371: LD_VAR 0 5
55375: PUSH
55376: EMPTY
55377: LIST
55378: LIST
55379: LIST
55380: LIST
55381: ST_TO_ADDR
// exit ;
55382: GO 55675
// end ; if not chassis in _chassis then
55384: LD_VAR 0 2
55388: PUSH
55389: LD_VAR 0 9
55393: IN
55394: NOT
55395: IFFALSE 55421
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55397: LD_ADDR_VAR 0 2
55401: PUSH
55402: LD_VAR 0 9
55406: PUSH
55407: LD_INT 1
55409: PPUSH
55410: LD_VAR 0 9
55414: PPUSH
55415: CALL_OW 12
55419: ARRAY
55420: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55421: LD_VAR 0 2
55425: PPUSH
55426: LD_VAR 0 3
55430: PPUSH
55431: CALL 55680 0 2
55435: NOT
55436: IFFALSE 55495
// repeat engine := _engine [ 1 ] ;
55438: LD_ADDR_VAR 0 3
55442: PUSH
55443: LD_VAR 0 11
55447: PUSH
55448: LD_INT 1
55450: ARRAY
55451: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55452: LD_ADDR_VAR 0 11
55456: PUSH
55457: LD_VAR 0 11
55461: PPUSH
55462: LD_INT 1
55464: PPUSH
55465: CALL_OW 3
55469: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55470: LD_VAR 0 2
55474: PPUSH
55475: LD_VAR 0 3
55479: PPUSH
55480: CALL 55680 0 2
55484: PUSH
55485: LD_VAR 0 11
55489: PUSH
55490: EMPTY
55491: EQUAL
55492: OR
55493: IFFALSE 55438
// if not control in _control then
55495: LD_VAR 0 4
55499: PUSH
55500: LD_VAR 0 12
55504: IN
55505: NOT
55506: IFFALSE 55532
// control := _control [ rand ( 1 , _control ) ] ;
55508: LD_ADDR_VAR 0 4
55512: PUSH
55513: LD_VAR 0 12
55517: PUSH
55518: LD_INT 1
55520: PPUSH
55521: LD_VAR 0 12
55525: PPUSH
55526: CALL_OW 12
55530: ARRAY
55531: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55532: LD_VAR 0 2
55536: PPUSH
55537: LD_VAR 0 5
55541: PPUSH
55542: CALL 55900 0 2
55546: NOT
55547: IFFALSE 55606
// repeat weapon := _weapon [ 1 ] ;
55549: LD_ADDR_VAR 0 5
55553: PUSH
55554: LD_VAR 0 10
55558: PUSH
55559: LD_INT 1
55561: ARRAY
55562: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55563: LD_ADDR_VAR 0 10
55567: PUSH
55568: LD_VAR 0 10
55572: PPUSH
55573: LD_INT 1
55575: PPUSH
55576: CALL_OW 3
55580: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55581: LD_VAR 0 2
55585: PPUSH
55586: LD_VAR 0 5
55590: PPUSH
55591: CALL 55900 0 2
55595: PUSH
55596: LD_VAR 0 10
55600: PUSH
55601: EMPTY
55602: EQUAL
55603: OR
55604: IFFALSE 55549
// result := [ ] ;
55606: LD_ADDR_VAR 0 6
55610: PUSH
55611: EMPTY
55612: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55613: LD_VAR 0 1
55617: PPUSH
55618: LD_VAR 0 2
55622: PPUSH
55623: LD_VAR 0 3
55627: PPUSH
55628: LD_VAR 0 4
55632: PPUSH
55633: LD_VAR 0 5
55637: PPUSH
55638: CALL_OW 448
55642: IFFALSE 55675
// result := [ chassis , engine , control , weapon ] ;
55644: LD_ADDR_VAR 0 6
55648: PUSH
55649: LD_VAR 0 2
55653: PUSH
55654: LD_VAR 0 3
55658: PUSH
55659: LD_VAR 0 4
55663: PUSH
55664: LD_VAR 0 5
55668: PUSH
55669: EMPTY
55670: LIST
55671: LIST
55672: LIST
55673: LIST
55674: ST_TO_ADDR
// end ;
55675: LD_VAR 0 6
55679: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55680: LD_INT 0
55682: PPUSH
// if not chassis or not engine then
55683: LD_VAR 0 1
55687: NOT
55688: PUSH
55689: LD_VAR 0 2
55693: NOT
55694: OR
55695: IFFALSE 55699
// exit ;
55697: GO 55895
// case engine of engine_solar :
55699: LD_VAR 0 2
55703: PUSH
55704: LD_INT 2
55706: DOUBLE
55707: EQUAL
55708: IFTRUE 55712
55710: GO 55750
55712: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55713: LD_ADDR_VAR 0 3
55717: PUSH
55718: LD_INT 11
55720: PUSH
55721: LD_INT 12
55723: PUSH
55724: LD_INT 13
55726: PUSH
55727: LD_INT 14
55729: PUSH
55730: LD_INT 1
55732: PUSH
55733: LD_INT 2
55735: PUSH
55736: LD_INT 3
55738: PUSH
55739: EMPTY
55740: LIST
55741: LIST
55742: LIST
55743: LIST
55744: LIST
55745: LIST
55746: LIST
55747: ST_TO_ADDR
55748: GO 55879
55750: LD_INT 1
55752: DOUBLE
55753: EQUAL
55754: IFTRUE 55758
55756: GO 55820
55758: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55759: LD_ADDR_VAR 0 3
55763: PUSH
55764: LD_INT 11
55766: PUSH
55767: LD_INT 12
55769: PUSH
55770: LD_INT 13
55772: PUSH
55773: LD_INT 14
55775: PUSH
55776: LD_INT 1
55778: PUSH
55779: LD_INT 2
55781: PUSH
55782: LD_INT 3
55784: PUSH
55785: LD_INT 4
55787: PUSH
55788: LD_INT 5
55790: PUSH
55791: LD_INT 21
55793: PUSH
55794: LD_INT 23
55796: PUSH
55797: LD_INT 22
55799: PUSH
55800: LD_INT 24
55802: PUSH
55803: EMPTY
55804: LIST
55805: LIST
55806: LIST
55807: LIST
55808: LIST
55809: LIST
55810: LIST
55811: LIST
55812: LIST
55813: LIST
55814: LIST
55815: LIST
55816: LIST
55817: ST_TO_ADDR
55818: GO 55879
55820: LD_INT 3
55822: DOUBLE
55823: EQUAL
55824: IFTRUE 55828
55826: GO 55878
55828: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55829: LD_ADDR_VAR 0 3
55833: PUSH
55834: LD_INT 13
55836: PUSH
55837: LD_INT 14
55839: PUSH
55840: LD_INT 2
55842: PUSH
55843: LD_INT 3
55845: PUSH
55846: LD_INT 4
55848: PUSH
55849: LD_INT 5
55851: PUSH
55852: LD_INT 21
55854: PUSH
55855: LD_INT 22
55857: PUSH
55858: LD_INT 23
55860: PUSH
55861: LD_INT 24
55863: PUSH
55864: EMPTY
55865: LIST
55866: LIST
55867: LIST
55868: LIST
55869: LIST
55870: LIST
55871: LIST
55872: LIST
55873: LIST
55874: LIST
55875: ST_TO_ADDR
55876: GO 55879
55878: POP
// result := ( chassis in result ) ;
55879: LD_ADDR_VAR 0 3
55883: PUSH
55884: LD_VAR 0 1
55888: PUSH
55889: LD_VAR 0 3
55893: IN
55894: ST_TO_ADDR
// end ;
55895: LD_VAR 0 3
55899: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55900: LD_INT 0
55902: PPUSH
// if not chassis or not weapon then
55903: LD_VAR 0 1
55907: NOT
55908: PUSH
55909: LD_VAR 0 2
55913: NOT
55914: OR
55915: IFFALSE 55919
// exit ;
55917: GO 56945
// case weapon of us_machine_gun :
55919: LD_VAR 0 2
55923: PUSH
55924: LD_INT 2
55926: DOUBLE
55927: EQUAL
55928: IFTRUE 55932
55930: GO 55962
55932: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55933: LD_ADDR_VAR 0 3
55937: PUSH
55938: LD_INT 1
55940: PUSH
55941: LD_INT 2
55943: PUSH
55944: LD_INT 3
55946: PUSH
55947: LD_INT 4
55949: PUSH
55950: LD_INT 5
55952: PUSH
55953: EMPTY
55954: LIST
55955: LIST
55956: LIST
55957: LIST
55958: LIST
55959: ST_TO_ADDR
55960: GO 56929
55962: LD_INT 3
55964: DOUBLE
55965: EQUAL
55966: IFTRUE 55970
55968: GO 56000
55970: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55971: LD_ADDR_VAR 0 3
55975: PUSH
55976: LD_INT 1
55978: PUSH
55979: LD_INT 2
55981: PUSH
55982: LD_INT 3
55984: PUSH
55985: LD_INT 4
55987: PUSH
55988: LD_INT 5
55990: PUSH
55991: EMPTY
55992: LIST
55993: LIST
55994: LIST
55995: LIST
55996: LIST
55997: ST_TO_ADDR
55998: GO 56929
56000: LD_INT 11
56002: DOUBLE
56003: EQUAL
56004: IFTRUE 56008
56006: GO 56038
56008: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56009: LD_ADDR_VAR 0 3
56013: PUSH
56014: LD_INT 1
56016: PUSH
56017: LD_INT 2
56019: PUSH
56020: LD_INT 3
56022: PUSH
56023: LD_INT 4
56025: PUSH
56026: LD_INT 5
56028: PUSH
56029: EMPTY
56030: LIST
56031: LIST
56032: LIST
56033: LIST
56034: LIST
56035: ST_TO_ADDR
56036: GO 56929
56038: LD_INT 4
56040: DOUBLE
56041: EQUAL
56042: IFTRUE 56046
56044: GO 56072
56046: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56047: LD_ADDR_VAR 0 3
56051: PUSH
56052: LD_INT 2
56054: PUSH
56055: LD_INT 3
56057: PUSH
56058: LD_INT 4
56060: PUSH
56061: LD_INT 5
56063: PUSH
56064: EMPTY
56065: LIST
56066: LIST
56067: LIST
56068: LIST
56069: ST_TO_ADDR
56070: GO 56929
56072: LD_INT 5
56074: DOUBLE
56075: EQUAL
56076: IFTRUE 56080
56078: GO 56106
56080: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56081: LD_ADDR_VAR 0 3
56085: PUSH
56086: LD_INT 2
56088: PUSH
56089: LD_INT 3
56091: PUSH
56092: LD_INT 4
56094: PUSH
56095: LD_INT 5
56097: PUSH
56098: EMPTY
56099: LIST
56100: LIST
56101: LIST
56102: LIST
56103: ST_TO_ADDR
56104: GO 56929
56106: LD_INT 9
56108: DOUBLE
56109: EQUAL
56110: IFTRUE 56114
56112: GO 56140
56114: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56115: LD_ADDR_VAR 0 3
56119: PUSH
56120: LD_INT 2
56122: PUSH
56123: LD_INT 3
56125: PUSH
56126: LD_INT 4
56128: PUSH
56129: LD_INT 5
56131: PUSH
56132: EMPTY
56133: LIST
56134: LIST
56135: LIST
56136: LIST
56137: ST_TO_ADDR
56138: GO 56929
56140: LD_INT 7
56142: DOUBLE
56143: EQUAL
56144: IFTRUE 56148
56146: GO 56174
56148: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56149: LD_ADDR_VAR 0 3
56153: PUSH
56154: LD_INT 2
56156: PUSH
56157: LD_INT 3
56159: PUSH
56160: LD_INT 4
56162: PUSH
56163: LD_INT 5
56165: PUSH
56166: EMPTY
56167: LIST
56168: LIST
56169: LIST
56170: LIST
56171: ST_TO_ADDR
56172: GO 56929
56174: LD_INT 12
56176: DOUBLE
56177: EQUAL
56178: IFTRUE 56182
56180: GO 56208
56182: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56183: LD_ADDR_VAR 0 3
56187: PUSH
56188: LD_INT 2
56190: PUSH
56191: LD_INT 3
56193: PUSH
56194: LD_INT 4
56196: PUSH
56197: LD_INT 5
56199: PUSH
56200: EMPTY
56201: LIST
56202: LIST
56203: LIST
56204: LIST
56205: ST_TO_ADDR
56206: GO 56929
56208: LD_INT 13
56210: DOUBLE
56211: EQUAL
56212: IFTRUE 56216
56214: GO 56242
56216: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56217: LD_ADDR_VAR 0 3
56221: PUSH
56222: LD_INT 2
56224: PUSH
56225: LD_INT 3
56227: PUSH
56228: LD_INT 4
56230: PUSH
56231: LD_INT 5
56233: PUSH
56234: EMPTY
56235: LIST
56236: LIST
56237: LIST
56238: LIST
56239: ST_TO_ADDR
56240: GO 56929
56242: LD_INT 14
56244: DOUBLE
56245: EQUAL
56246: IFTRUE 56250
56248: GO 56268
56250: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56251: LD_ADDR_VAR 0 3
56255: PUSH
56256: LD_INT 4
56258: PUSH
56259: LD_INT 5
56261: PUSH
56262: EMPTY
56263: LIST
56264: LIST
56265: ST_TO_ADDR
56266: GO 56929
56268: LD_INT 6
56270: DOUBLE
56271: EQUAL
56272: IFTRUE 56276
56274: GO 56294
56276: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56277: LD_ADDR_VAR 0 3
56281: PUSH
56282: LD_INT 4
56284: PUSH
56285: LD_INT 5
56287: PUSH
56288: EMPTY
56289: LIST
56290: LIST
56291: ST_TO_ADDR
56292: GO 56929
56294: LD_INT 10
56296: DOUBLE
56297: EQUAL
56298: IFTRUE 56302
56300: GO 56320
56302: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56303: LD_ADDR_VAR 0 3
56307: PUSH
56308: LD_INT 4
56310: PUSH
56311: LD_INT 5
56313: PUSH
56314: EMPTY
56315: LIST
56316: LIST
56317: ST_TO_ADDR
56318: GO 56929
56320: LD_INT 22
56322: DOUBLE
56323: EQUAL
56324: IFTRUE 56328
56326: GO 56354
56328: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56329: LD_ADDR_VAR 0 3
56333: PUSH
56334: LD_INT 11
56336: PUSH
56337: LD_INT 12
56339: PUSH
56340: LD_INT 13
56342: PUSH
56343: LD_INT 14
56345: PUSH
56346: EMPTY
56347: LIST
56348: LIST
56349: LIST
56350: LIST
56351: ST_TO_ADDR
56352: GO 56929
56354: LD_INT 23
56356: DOUBLE
56357: EQUAL
56358: IFTRUE 56362
56360: GO 56388
56362: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56363: LD_ADDR_VAR 0 3
56367: PUSH
56368: LD_INT 11
56370: PUSH
56371: LD_INT 12
56373: PUSH
56374: LD_INT 13
56376: PUSH
56377: LD_INT 14
56379: PUSH
56380: EMPTY
56381: LIST
56382: LIST
56383: LIST
56384: LIST
56385: ST_TO_ADDR
56386: GO 56929
56388: LD_INT 24
56390: DOUBLE
56391: EQUAL
56392: IFTRUE 56396
56394: GO 56422
56396: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56397: LD_ADDR_VAR 0 3
56401: PUSH
56402: LD_INT 11
56404: PUSH
56405: LD_INT 12
56407: PUSH
56408: LD_INT 13
56410: PUSH
56411: LD_INT 14
56413: PUSH
56414: EMPTY
56415: LIST
56416: LIST
56417: LIST
56418: LIST
56419: ST_TO_ADDR
56420: GO 56929
56422: LD_INT 30
56424: DOUBLE
56425: EQUAL
56426: IFTRUE 56430
56428: GO 56456
56430: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56431: LD_ADDR_VAR 0 3
56435: PUSH
56436: LD_INT 11
56438: PUSH
56439: LD_INT 12
56441: PUSH
56442: LD_INT 13
56444: PUSH
56445: LD_INT 14
56447: PUSH
56448: EMPTY
56449: LIST
56450: LIST
56451: LIST
56452: LIST
56453: ST_TO_ADDR
56454: GO 56929
56456: LD_INT 25
56458: DOUBLE
56459: EQUAL
56460: IFTRUE 56464
56462: GO 56482
56464: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56465: LD_ADDR_VAR 0 3
56469: PUSH
56470: LD_INT 13
56472: PUSH
56473: LD_INT 14
56475: PUSH
56476: EMPTY
56477: LIST
56478: LIST
56479: ST_TO_ADDR
56480: GO 56929
56482: LD_INT 27
56484: DOUBLE
56485: EQUAL
56486: IFTRUE 56490
56488: GO 56508
56490: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56491: LD_ADDR_VAR 0 3
56495: PUSH
56496: LD_INT 13
56498: PUSH
56499: LD_INT 14
56501: PUSH
56502: EMPTY
56503: LIST
56504: LIST
56505: ST_TO_ADDR
56506: GO 56929
56508: LD_INT 28
56510: DOUBLE
56511: EQUAL
56512: IFTRUE 56516
56514: GO 56534
56516: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56517: LD_ADDR_VAR 0 3
56521: PUSH
56522: LD_INT 13
56524: PUSH
56525: LD_INT 14
56527: PUSH
56528: EMPTY
56529: LIST
56530: LIST
56531: ST_TO_ADDR
56532: GO 56929
56534: LD_INT 29
56536: DOUBLE
56537: EQUAL
56538: IFTRUE 56542
56540: GO 56560
56542: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56543: LD_ADDR_VAR 0 3
56547: PUSH
56548: LD_INT 13
56550: PUSH
56551: LD_INT 14
56553: PUSH
56554: EMPTY
56555: LIST
56556: LIST
56557: ST_TO_ADDR
56558: GO 56929
56560: LD_INT 31
56562: DOUBLE
56563: EQUAL
56564: IFTRUE 56568
56566: GO 56586
56568: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56569: LD_ADDR_VAR 0 3
56573: PUSH
56574: LD_INT 13
56576: PUSH
56577: LD_INT 14
56579: PUSH
56580: EMPTY
56581: LIST
56582: LIST
56583: ST_TO_ADDR
56584: GO 56929
56586: LD_INT 26
56588: DOUBLE
56589: EQUAL
56590: IFTRUE 56594
56592: GO 56612
56594: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56595: LD_ADDR_VAR 0 3
56599: PUSH
56600: LD_INT 13
56602: PUSH
56603: LD_INT 14
56605: PUSH
56606: EMPTY
56607: LIST
56608: LIST
56609: ST_TO_ADDR
56610: GO 56929
56612: LD_INT 42
56614: DOUBLE
56615: EQUAL
56616: IFTRUE 56620
56618: GO 56646
56620: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56621: LD_ADDR_VAR 0 3
56625: PUSH
56626: LD_INT 21
56628: PUSH
56629: LD_INT 22
56631: PUSH
56632: LD_INT 23
56634: PUSH
56635: LD_INT 24
56637: PUSH
56638: EMPTY
56639: LIST
56640: LIST
56641: LIST
56642: LIST
56643: ST_TO_ADDR
56644: GO 56929
56646: LD_INT 43
56648: DOUBLE
56649: EQUAL
56650: IFTRUE 56654
56652: GO 56680
56654: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56655: LD_ADDR_VAR 0 3
56659: PUSH
56660: LD_INT 21
56662: PUSH
56663: LD_INT 22
56665: PUSH
56666: LD_INT 23
56668: PUSH
56669: LD_INT 24
56671: PUSH
56672: EMPTY
56673: LIST
56674: LIST
56675: LIST
56676: LIST
56677: ST_TO_ADDR
56678: GO 56929
56680: LD_INT 44
56682: DOUBLE
56683: EQUAL
56684: IFTRUE 56688
56686: GO 56714
56688: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56689: LD_ADDR_VAR 0 3
56693: PUSH
56694: LD_INT 21
56696: PUSH
56697: LD_INT 22
56699: PUSH
56700: LD_INT 23
56702: PUSH
56703: LD_INT 24
56705: PUSH
56706: EMPTY
56707: LIST
56708: LIST
56709: LIST
56710: LIST
56711: ST_TO_ADDR
56712: GO 56929
56714: LD_INT 45
56716: DOUBLE
56717: EQUAL
56718: IFTRUE 56722
56720: GO 56748
56722: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56723: LD_ADDR_VAR 0 3
56727: PUSH
56728: LD_INT 21
56730: PUSH
56731: LD_INT 22
56733: PUSH
56734: LD_INT 23
56736: PUSH
56737: LD_INT 24
56739: PUSH
56740: EMPTY
56741: LIST
56742: LIST
56743: LIST
56744: LIST
56745: ST_TO_ADDR
56746: GO 56929
56748: LD_INT 49
56750: DOUBLE
56751: EQUAL
56752: IFTRUE 56756
56754: GO 56782
56756: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56757: LD_ADDR_VAR 0 3
56761: PUSH
56762: LD_INT 21
56764: PUSH
56765: LD_INT 22
56767: PUSH
56768: LD_INT 23
56770: PUSH
56771: LD_INT 24
56773: PUSH
56774: EMPTY
56775: LIST
56776: LIST
56777: LIST
56778: LIST
56779: ST_TO_ADDR
56780: GO 56929
56782: LD_INT 51
56784: DOUBLE
56785: EQUAL
56786: IFTRUE 56790
56788: GO 56816
56790: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56791: LD_ADDR_VAR 0 3
56795: PUSH
56796: LD_INT 21
56798: PUSH
56799: LD_INT 22
56801: PUSH
56802: LD_INT 23
56804: PUSH
56805: LD_INT 24
56807: PUSH
56808: EMPTY
56809: LIST
56810: LIST
56811: LIST
56812: LIST
56813: ST_TO_ADDR
56814: GO 56929
56816: LD_INT 52
56818: DOUBLE
56819: EQUAL
56820: IFTRUE 56824
56822: GO 56850
56824: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56825: LD_ADDR_VAR 0 3
56829: PUSH
56830: LD_INT 21
56832: PUSH
56833: LD_INT 22
56835: PUSH
56836: LD_INT 23
56838: PUSH
56839: LD_INT 24
56841: PUSH
56842: EMPTY
56843: LIST
56844: LIST
56845: LIST
56846: LIST
56847: ST_TO_ADDR
56848: GO 56929
56850: LD_INT 53
56852: DOUBLE
56853: EQUAL
56854: IFTRUE 56858
56856: GO 56876
56858: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56859: LD_ADDR_VAR 0 3
56863: PUSH
56864: LD_INT 23
56866: PUSH
56867: LD_INT 24
56869: PUSH
56870: EMPTY
56871: LIST
56872: LIST
56873: ST_TO_ADDR
56874: GO 56929
56876: LD_INT 46
56878: DOUBLE
56879: EQUAL
56880: IFTRUE 56884
56882: GO 56902
56884: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56885: LD_ADDR_VAR 0 3
56889: PUSH
56890: LD_INT 23
56892: PUSH
56893: LD_INT 24
56895: PUSH
56896: EMPTY
56897: LIST
56898: LIST
56899: ST_TO_ADDR
56900: GO 56929
56902: LD_INT 47
56904: DOUBLE
56905: EQUAL
56906: IFTRUE 56910
56908: GO 56928
56910: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56911: LD_ADDR_VAR 0 3
56915: PUSH
56916: LD_INT 23
56918: PUSH
56919: LD_INT 24
56921: PUSH
56922: EMPTY
56923: LIST
56924: LIST
56925: ST_TO_ADDR
56926: GO 56929
56928: POP
// result := ( chassis in result ) ;
56929: LD_ADDR_VAR 0 3
56933: PUSH
56934: LD_VAR 0 1
56938: PUSH
56939: LD_VAR 0 3
56943: IN
56944: ST_TO_ADDR
// end ;
56945: LD_VAR 0 3
56949: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56950: LD_INT 0
56952: PPUSH
56953: PPUSH
56954: PPUSH
56955: PPUSH
56956: PPUSH
56957: PPUSH
56958: PPUSH
// result := array ;
56959: LD_ADDR_VAR 0 5
56963: PUSH
56964: LD_VAR 0 1
56968: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56969: LD_VAR 0 1
56973: NOT
56974: PUSH
56975: LD_VAR 0 2
56979: NOT
56980: OR
56981: PUSH
56982: LD_VAR 0 3
56986: NOT
56987: OR
56988: PUSH
56989: LD_VAR 0 2
56993: PUSH
56994: LD_VAR 0 1
56998: GREATER
56999: OR
57000: PUSH
57001: LD_VAR 0 3
57005: PUSH
57006: LD_VAR 0 1
57010: GREATER
57011: OR
57012: IFFALSE 57016
// exit ;
57014: GO 57312
// if direction then
57016: LD_VAR 0 4
57020: IFFALSE 57084
// begin d := 1 ;
57022: LD_ADDR_VAR 0 9
57026: PUSH
57027: LD_INT 1
57029: ST_TO_ADDR
// if i_from > i_to then
57030: LD_VAR 0 2
57034: PUSH
57035: LD_VAR 0 3
57039: GREATER
57040: IFFALSE 57066
// length := ( array - i_from ) + i_to else
57042: LD_ADDR_VAR 0 11
57046: PUSH
57047: LD_VAR 0 1
57051: PUSH
57052: LD_VAR 0 2
57056: MINUS
57057: PUSH
57058: LD_VAR 0 3
57062: PLUS
57063: ST_TO_ADDR
57064: GO 57082
// length := i_to - i_from ;
57066: LD_ADDR_VAR 0 11
57070: PUSH
57071: LD_VAR 0 3
57075: PUSH
57076: LD_VAR 0 2
57080: MINUS
57081: ST_TO_ADDR
// end else
57082: GO 57145
// begin d := - 1 ;
57084: LD_ADDR_VAR 0 9
57088: PUSH
57089: LD_INT 1
57091: NEG
57092: ST_TO_ADDR
// if i_from > i_to then
57093: LD_VAR 0 2
57097: PUSH
57098: LD_VAR 0 3
57102: GREATER
57103: IFFALSE 57123
// length := i_from - i_to else
57105: LD_ADDR_VAR 0 11
57109: PUSH
57110: LD_VAR 0 2
57114: PUSH
57115: LD_VAR 0 3
57119: MINUS
57120: ST_TO_ADDR
57121: GO 57145
// length := ( array - i_to ) + i_from ;
57123: LD_ADDR_VAR 0 11
57127: PUSH
57128: LD_VAR 0 1
57132: PUSH
57133: LD_VAR 0 3
57137: MINUS
57138: PUSH
57139: LD_VAR 0 2
57143: PLUS
57144: ST_TO_ADDR
// end ; if not length then
57145: LD_VAR 0 11
57149: NOT
57150: IFFALSE 57154
// exit ;
57152: GO 57312
// tmp := array ;
57154: LD_ADDR_VAR 0 10
57158: PUSH
57159: LD_VAR 0 1
57163: ST_TO_ADDR
// for i = 1 to length do
57164: LD_ADDR_VAR 0 6
57168: PUSH
57169: DOUBLE
57170: LD_INT 1
57172: DEC
57173: ST_TO_ADDR
57174: LD_VAR 0 11
57178: PUSH
57179: FOR_TO
57180: IFFALSE 57300
// begin for j = 1 to array do
57182: LD_ADDR_VAR 0 7
57186: PUSH
57187: DOUBLE
57188: LD_INT 1
57190: DEC
57191: ST_TO_ADDR
57192: LD_VAR 0 1
57196: PUSH
57197: FOR_TO
57198: IFFALSE 57286
// begin k := j + d ;
57200: LD_ADDR_VAR 0 8
57204: PUSH
57205: LD_VAR 0 7
57209: PUSH
57210: LD_VAR 0 9
57214: PLUS
57215: ST_TO_ADDR
// if k > array then
57216: LD_VAR 0 8
57220: PUSH
57221: LD_VAR 0 1
57225: GREATER
57226: IFFALSE 57236
// k := 1 ;
57228: LD_ADDR_VAR 0 8
57232: PUSH
57233: LD_INT 1
57235: ST_TO_ADDR
// if not k then
57236: LD_VAR 0 8
57240: NOT
57241: IFFALSE 57253
// k := array ;
57243: LD_ADDR_VAR 0 8
57247: PUSH
57248: LD_VAR 0 1
57252: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57253: LD_ADDR_VAR 0 10
57257: PUSH
57258: LD_VAR 0 10
57262: PPUSH
57263: LD_VAR 0 8
57267: PPUSH
57268: LD_VAR 0 1
57272: PUSH
57273: LD_VAR 0 7
57277: ARRAY
57278: PPUSH
57279: CALL_OW 1
57283: ST_TO_ADDR
// end ;
57284: GO 57197
57286: POP
57287: POP
// array := tmp ;
57288: LD_ADDR_VAR 0 1
57292: PUSH
57293: LD_VAR 0 10
57297: ST_TO_ADDR
// end ;
57298: GO 57179
57300: POP
57301: POP
// result := array ;
57302: LD_ADDR_VAR 0 5
57306: PUSH
57307: LD_VAR 0 1
57311: ST_TO_ADDR
// end ;
57312: LD_VAR 0 5
57316: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57317: LD_INT 0
57319: PPUSH
57320: PPUSH
// result := 0 ;
57321: LD_ADDR_VAR 0 3
57325: PUSH
57326: LD_INT 0
57328: ST_TO_ADDR
// if not array or not value in array then
57329: LD_VAR 0 1
57333: NOT
57334: PUSH
57335: LD_VAR 0 2
57339: PUSH
57340: LD_VAR 0 1
57344: IN
57345: NOT
57346: OR
57347: IFFALSE 57351
// exit ;
57349: GO 57405
// for i = 1 to array do
57351: LD_ADDR_VAR 0 4
57355: PUSH
57356: DOUBLE
57357: LD_INT 1
57359: DEC
57360: ST_TO_ADDR
57361: LD_VAR 0 1
57365: PUSH
57366: FOR_TO
57367: IFFALSE 57403
// if value = array [ i ] then
57369: LD_VAR 0 2
57373: PUSH
57374: LD_VAR 0 1
57378: PUSH
57379: LD_VAR 0 4
57383: ARRAY
57384: EQUAL
57385: IFFALSE 57401
// begin result := i ;
57387: LD_ADDR_VAR 0 3
57391: PUSH
57392: LD_VAR 0 4
57396: ST_TO_ADDR
// exit ;
57397: POP
57398: POP
57399: GO 57405
// end ;
57401: GO 57366
57403: POP
57404: POP
// end ;
57405: LD_VAR 0 3
57409: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57410: LD_INT 0
57412: PPUSH
// vc_chassis := chassis ;
57413: LD_ADDR_OWVAR 37
57417: PUSH
57418: LD_VAR 0 1
57422: ST_TO_ADDR
// vc_engine := engine ;
57423: LD_ADDR_OWVAR 39
57427: PUSH
57428: LD_VAR 0 2
57432: ST_TO_ADDR
// vc_control := control ;
57433: LD_ADDR_OWVAR 38
57437: PUSH
57438: LD_VAR 0 3
57442: ST_TO_ADDR
// vc_weapon := weapon ;
57443: LD_ADDR_OWVAR 40
57447: PUSH
57448: LD_VAR 0 4
57452: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57453: LD_ADDR_OWVAR 41
57457: PUSH
57458: LD_VAR 0 5
57462: ST_TO_ADDR
// end ;
57463: LD_VAR 0 6
57467: RET
// export function WantPlant ( unit ) ; var task ; begin
57468: LD_INT 0
57470: PPUSH
57471: PPUSH
// result := false ;
57472: LD_ADDR_VAR 0 2
57476: PUSH
57477: LD_INT 0
57479: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57480: LD_ADDR_VAR 0 3
57484: PUSH
57485: LD_VAR 0 1
57489: PPUSH
57490: CALL_OW 437
57494: ST_TO_ADDR
// if task then
57495: LD_VAR 0 3
57499: IFFALSE 57527
// if task [ 1 ] [ 1 ] = p then
57501: LD_VAR 0 3
57505: PUSH
57506: LD_INT 1
57508: ARRAY
57509: PUSH
57510: LD_INT 1
57512: ARRAY
57513: PUSH
57514: LD_STRING p
57516: EQUAL
57517: IFFALSE 57527
// result := true ;
57519: LD_ADDR_VAR 0 2
57523: PUSH
57524: LD_INT 1
57526: ST_TO_ADDR
// end ;
57527: LD_VAR 0 2
57531: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57532: LD_INT 0
57534: PPUSH
57535: PPUSH
57536: PPUSH
57537: PPUSH
// if pos < 1 then
57538: LD_VAR 0 2
57542: PUSH
57543: LD_INT 1
57545: LESS
57546: IFFALSE 57550
// exit ;
57548: GO 57853
// if pos = 1 then
57550: LD_VAR 0 2
57554: PUSH
57555: LD_INT 1
57557: EQUAL
57558: IFFALSE 57591
// result := Replace ( arr , pos [ 1 ] , value ) else
57560: LD_ADDR_VAR 0 4
57564: PUSH
57565: LD_VAR 0 1
57569: PPUSH
57570: LD_VAR 0 2
57574: PUSH
57575: LD_INT 1
57577: ARRAY
57578: PPUSH
57579: LD_VAR 0 3
57583: PPUSH
57584: CALL_OW 1
57588: ST_TO_ADDR
57589: GO 57853
// begin tmp := arr ;
57591: LD_ADDR_VAR 0 6
57595: PUSH
57596: LD_VAR 0 1
57600: ST_TO_ADDR
// s_arr := [ tmp ] ;
57601: LD_ADDR_VAR 0 7
57605: PUSH
57606: LD_VAR 0 6
57610: PUSH
57611: EMPTY
57612: LIST
57613: ST_TO_ADDR
// for i = 1 to pos - 1 do
57614: LD_ADDR_VAR 0 5
57618: PUSH
57619: DOUBLE
57620: LD_INT 1
57622: DEC
57623: ST_TO_ADDR
57624: LD_VAR 0 2
57628: PUSH
57629: LD_INT 1
57631: MINUS
57632: PUSH
57633: FOR_TO
57634: IFFALSE 57679
// begin tmp := tmp [ pos [ i ] ] ;
57636: LD_ADDR_VAR 0 6
57640: PUSH
57641: LD_VAR 0 6
57645: PUSH
57646: LD_VAR 0 2
57650: PUSH
57651: LD_VAR 0 5
57655: ARRAY
57656: ARRAY
57657: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57658: LD_ADDR_VAR 0 7
57662: PUSH
57663: LD_VAR 0 7
57667: PUSH
57668: LD_VAR 0 6
57672: PUSH
57673: EMPTY
57674: LIST
57675: ADD
57676: ST_TO_ADDR
// end ;
57677: GO 57633
57679: POP
57680: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57681: LD_ADDR_VAR 0 6
57685: PUSH
57686: LD_VAR 0 6
57690: PPUSH
57691: LD_VAR 0 2
57695: PUSH
57696: LD_VAR 0 2
57700: ARRAY
57701: PPUSH
57702: LD_VAR 0 3
57706: PPUSH
57707: CALL_OW 1
57711: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57712: LD_ADDR_VAR 0 7
57716: PUSH
57717: LD_VAR 0 7
57721: PPUSH
57722: LD_VAR 0 7
57726: PPUSH
57727: LD_VAR 0 6
57731: PPUSH
57732: CALL_OW 1
57736: ST_TO_ADDR
// for i = s_arr downto 2 do
57737: LD_ADDR_VAR 0 5
57741: PUSH
57742: DOUBLE
57743: LD_VAR 0 7
57747: INC
57748: ST_TO_ADDR
57749: LD_INT 2
57751: PUSH
57752: FOR_DOWNTO
57753: IFFALSE 57837
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57755: LD_ADDR_VAR 0 6
57759: PUSH
57760: LD_VAR 0 7
57764: PUSH
57765: LD_VAR 0 5
57769: PUSH
57770: LD_INT 1
57772: MINUS
57773: ARRAY
57774: PPUSH
57775: LD_VAR 0 2
57779: PUSH
57780: LD_VAR 0 5
57784: PUSH
57785: LD_INT 1
57787: MINUS
57788: ARRAY
57789: PPUSH
57790: LD_VAR 0 7
57794: PUSH
57795: LD_VAR 0 5
57799: ARRAY
57800: PPUSH
57801: CALL_OW 1
57805: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57806: LD_ADDR_VAR 0 7
57810: PUSH
57811: LD_VAR 0 7
57815: PPUSH
57816: LD_VAR 0 5
57820: PUSH
57821: LD_INT 1
57823: MINUS
57824: PPUSH
57825: LD_VAR 0 6
57829: PPUSH
57830: CALL_OW 1
57834: ST_TO_ADDR
// end ;
57835: GO 57752
57837: POP
57838: POP
// result := s_arr [ 1 ] ;
57839: LD_ADDR_VAR 0 4
57843: PUSH
57844: LD_VAR 0 7
57848: PUSH
57849: LD_INT 1
57851: ARRAY
57852: ST_TO_ADDR
// end ; end ;
57853: LD_VAR 0 4
57857: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57858: LD_INT 0
57860: PPUSH
57861: PPUSH
// if not list then
57862: LD_VAR 0 1
57866: NOT
57867: IFFALSE 57871
// exit ;
57869: GO 57962
// i := list [ pos1 ] ;
57871: LD_ADDR_VAR 0 5
57875: PUSH
57876: LD_VAR 0 1
57880: PUSH
57881: LD_VAR 0 2
57885: ARRAY
57886: ST_TO_ADDR
// if not i then
57887: LD_VAR 0 5
57891: NOT
57892: IFFALSE 57896
// exit ;
57894: GO 57962
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57896: LD_ADDR_VAR 0 1
57900: PUSH
57901: LD_VAR 0 1
57905: PPUSH
57906: LD_VAR 0 2
57910: PPUSH
57911: LD_VAR 0 1
57915: PUSH
57916: LD_VAR 0 3
57920: ARRAY
57921: PPUSH
57922: CALL_OW 1
57926: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57927: LD_ADDR_VAR 0 1
57931: PUSH
57932: LD_VAR 0 1
57936: PPUSH
57937: LD_VAR 0 3
57941: PPUSH
57942: LD_VAR 0 5
57946: PPUSH
57947: CALL_OW 1
57951: ST_TO_ADDR
// result := list ;
57952: LD_ADDR_VAR 0 4
57956: PUSH
57957: LD_VAR 0 1
57961: ST_TO_ADDR
// end ;
57962: LD_VAR 0 4
57966: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57967: LD_INT 0
57969: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57970: LD_ADDR_VAR 0 5
57974: PUSH
57975: LD_VAR 0 1
57979: PPUSH
57980: CALL_OW 250
57984: PPUSH
57985: LD_VAR 0 1
57989: PPUSH
57990: CALL_OW 251
57994: PPUSH
57995: LD_VAR 0 2
57999: PPUSH
58000: LD_VAR 0 3
58004: PPUSH
58005: LD_VAR 0 4
58009: PPUSH
58010: CALL 58020 0 5
58014: ST_TO_ADDR
// end ;
58015: LD_VAR 0 5
58019: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58020: LD_INT 0
58022: PPUSH
58023: PPUSH
58024: PPUSH
58025: PPUSH
// if not list then
58026: LD_VAR 0 3
58030: NOT
58031: IFFALSE 58035
// exit ;
58033: GO 58423
// result := [ ] ;
58035: LD_ADDR_VAR 0 6
58039: PUSH
58040: EMPTY
58041: ST_TO_ADDR
// for i in list do
58042: LD_ADDR_VAR 0 7
58046: PUSH
58047: LD_VAR 0 3
58051: PUSH
58052: FOR_IN
58053: IFFALSE 58255
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58055: LD_ADDR_VAR 0 9
58059: PUSH
58060: LD_VAR 0 7
58064: PPUSH
58065: LD_VAR 0 1
58069: PPUSH
58070: LD_VAR 0 2
58074: PPUSH
58075: CALL_OW 297
58079: ST_TO_ADDR
// if not result then
58080: LD_VAR 0 6
58084: NOT
58085: IFFALSE 58111
// result := [ [ i , tmp ] ] else
58087: LD_ADDR_VAR 0 6
58091: PUSH
58092: LD_VAR 0 7
58096: PUSH
58097: LD_VAR 0 9
58101: PUSH
58102: EMPTY
58103: LIST
58104: LIST
58105: PUSH
58106: EMPTY
58107: LIST
58108: ST_TO_ADDR
58109: GO 58253
// begin if result [ result ] [ 2 ] < tmp then
58111: LD_VAR 0 6
58115: PUSH
58116: LD_VAR 0 6
58120: ARRAY
58121: PUSH
58122: LD_INT 2
58124: ARRAY
58125: PUSH
58126: LD_VAR 0 9
58130: LESS
58131: IFFALSE 58173
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58133: LD_ADDR_VAR 0 6
58137: PUSH
58138: LD_VAR 0 6
58142: PPUSH
58143: LD_VAR 0 6
58147: PUSH
58148: LD_INT 1
58150: PLUS
58151: PPUSH
58152: LD_VAR 0 7
58156: PUSH
58157: LD_VAR 0 9
58161: PUSH
58162: EMPTY
58163: LIST
58164: LIST
58165: PPUSH
58166: CALL_OW 2
58170: ST_TO_ADDR
58171: GO 58253
// for j = 1 to result do
58173: LD_ADDR_VAR 0 8
58177: PUSH
58178: DOUBLE
58179: LD_INT 1
58181: DEC
58182: ST_TO_ADDR
58183: LD_VAR 0 6
58187: PUSH
58188: FOR_TO
58189: IFFALSE 58251
// begin if tmp < result [ j ] [ 2 ] then
58191: LD_VAR 0 9
58195: PUSH
58196: LD_VAR 0 6
58200: PUSH
58201: LD_VAR 0 8
58205: ARRAY
58206: PUSH
58207: LD_INT 2
58209: ARRAY
58210: LESS
58211: IFFALSE 58249
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58213: LD_ADDR_VAR 0 6
58217: PUSH
58218: LD_VAR 0 6
58222: PPUSH
58223: LD_VAR 0 8
58227: PPUSH
58228: LD_VAR 0 7
58232: PUSH
58233: LD_VAR 0 9
58237: PUSH
58238: EMPTY
58239: LIST
58240: LIST
58241: PPUSH
58242: CALL_OW 2
58246: ST_TO_ADDR
// break ;
58247: GO 58251
// end ; end ;
58249: GO 58188
58251: POP
58252: POP
// end ; end ;
58253: GO 58052
58255: POP
58256: POP
// if result and not asc then
58257: LD_VAR 0 6
58261: PUSH
58262: LD_VAR 0 4
58266: NOT
58267: AND
58268: IFFALSE 58343
// begin tmp := result ;
58270: LD_ADDR_VAR 0 9
58274: PUSH
58275: LD_VAR 0 6
58279: ST_TO_ADDR
// for i = tmp downto 1 do
58280: LD_ADDR_VAR 0 7
58284: PUSH
58285: DOUBLE
58286: LD_VAR 0 9
58290: INC
58291: ST_TO_ADDR
58292: LD_INT 1
58294: PUSH
58295: FOR_DOWNTO
58296: IFFALSE 58341
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58298: LD_ADDR_VAR 0 6
58302: PUSH
58303: LD_VAR 0 6
58307: PPUSH
58308: LD_VAR 0 9
58312: PUSH
58313: LD_VAR 0 7
58317: MINUS
58318: PUSH
58319: LD_INT 1
58321: PLUS
58322: PPUSH
58323: LD_VAR 0 9
58327: PUSH
58328: LD_VAR 0 7
58332: ARRAY
58333: PPUSH
58334: CALL_OW 1
58338: ST_TO_ADDR
58339: GO 58295
58341: POP
58342: POP
// end ; tmp := [ ] ;
58343: LD_ADDR_VAR 0 9
58347: PUSH
58348: EMPTY
58349: ST_TO_ADDR
// if mode then
58350: LD_VAR 0 5
58354: IFFALSE 58423
// begin for i = 1 to result do
58356: LD_ADDR_VAR 0 7
58360: PUSH
58361: DOUBLE
58362: LD_INT 1
58364: DEC
58365: ST_TO_ADDR
58366: LD_VAR 0 6
58370: PUSH
58371: FOR_TO
58372: IFFALSE 58411
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58374: LD_ADDR_VAR 0 9
58378: PUSH
58379: LD_VAR 0 9
58383: PPUSH
58384: LD_VAR 0 7
58388: PPUSH
58389: LD_VAR 0 6
58393: PUSH
58394: LD_VAR 0 7
58398: ARRAY
58399: PUSH
58400: LD_INT 1
58402: ARRAY
58403: PPUSH
58404: CALL_OW 1
58408: ST_TO_ADDR
58409: GO 58371
58411: POP
58412: POP
// result := tmp ;
58413: LD_ADDR_VAR 0 6
58417: PUSH
58418: LD_VAR 0 9
58422: ST_TO_ADDR
// end ; end ;
58423: LD_VAR 0 6
58427: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58428: LD_INT 0
58430: PPUSH
58431: PPUSH
58432: PPUSH
58433: PPUSH
58434: PPUSH
58435: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58436: LD_ADDR_VAR 0 5
58440: PUSH
58441: LD_INT 0
58443: PUSH
58444: LD_INT 0
58446: PUSH
58447: LD_INT 0
58449: PUSH
58450: EMPTY
58451: PUSH
58452: EMPTY
58453: LIST
58454: LIST
58455: LIST
58456: LIST
58457: ST_TO_ADDR
// if not x or not y then
58458: LD_VAR 0 2
58462: NOT
58463: PUSH
58464: LD_VAR 0 3
58468: NOT
58469: OR
58470: IFFALSE 58474
// exit ;
58472: GO 60120
// if not range then
58474: LD_VAR 0 4
58478: NOT
58479: IFFALSE 58489
// range := 10 ;
58481: LD_ADDR_VAR 0 4
58485: PUSH
58486: LD_INT 10
58488: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58489: LD_ADDR_VAR 0 8
58493: PUSH
58494: LD_INT 81
58496: PUSH
58497: LD_VAR 0 1
58501: PUSH
58502: EMPTY
58503: LIST
58504: LIST
58505: PUSH
58506: LD_INT 92
58508: PUSH
58509: LD_VAR 0 2
58513: PUSH
58514: LD_VAR 0 3
58518: PUSH
58519: LD_VAR 0 4
58523: PUSH
58524: EMPTY
58525: LIST
58526: LIST
58527: LIST
58528: LIST
58529: PUSH
58530: LD_INT 3
58532: PUSH
58533: LD_INT 21
58535: PUSH
58536: LD_INT 3
58538: PUSH
58539: EMPTY
58540: LIST
58541: LIST
58542: PUSH
58543: EMPTY
58544: LIST
58545: LIST
58546: PUSH
58547: EMPTY
58548: LIST
58549: LIST
58550: LIST
58551: PPUSH
58552: CALL_OW 69
58556: ST_TO_ADDR
// if not tmp then
58557: LD_VAR 0 8
58561: NOT
58562: IFFALSE 58566
// exit ;
58564: GO 60120
// for i in tmp do
58566: LD_ADDR_VAR 0 6
58570: PUSH
58571: LD_VAR 0 8
58575: PUSH
58576: FOR_IN
58577: IFFALSE 60095
// begin points := [ 0 , 0 , 0 ] ;
58579: LD_ADDR_VAR 0 9
58583: PUSH
58584: LD_INT 0
58586: PUSH
58587: LD_INT 0
58589: PUSH
58590: LD_INT 0
58592: PUSH
58593: EMPTY
58594: LIST
58595: LIST
58596: LIST
58597: ST_TO_ADDR
// bpoints := 1 ;
58598: LD_ADDR_VAR 0 10
58602: PUSH
58603: LD_INT 1
58605: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58606: LD_VAR 0 6
58610: PPUSH
58611: CALL_OW 247
58615: PUSH
58616: LD_INT 1
58618: DOUBLE
58619: EQUAL
58620: IFTRUE 58624
58622: GO 59202
58624: POP
// begin if GetClass ( i ) = 1 then
58625: LD_VAR 0 6
58629: PPUSH
58630: CALL_OW 257
58634: PUSH
58635: LD_INT 1
58637: EQUAL
58638: IFFALSE 58659
// points := [ 10 , 5 , 3 ] ;
58640: LD_ADDR_VAR 0 9
58644: PUSH
58645: LD_INT 10
58647: PUSH
58648: LD_INT 5
58650: PUSH
58651: LD_INT 3
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: LIST
58658: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58659: LD_VAR 0 6
58663: PPUSH
58664: CALL_OW 257
58668: PUSH
58669: LD_INT 2
58671: PUSH
58672: LD_INT 3
58674: PUSH
58675: LD_INT 4
58677: PUSH
58678: EMPTY
58679: LIST
58680: LIST
58681: LIST
58682: IN
58683: IFFALSE 58704
// points := [ 3 , 2 , 1 ] ;
58685: LD_ADDR_VAR 0 9
58689: PUSH
58690: LD_INT 3
58692: PUSH
58693: LD_INT 2
58695: PUSH
58696: LD_INT 1
58698: PUSH
58699: EMPTY
58700: LIST
58701: LIST
58702: LIST
58703: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58704: LD_VAR 0 6
58708: PPUSH
58709: CALL_OW 257
58713: PUSH
58714: LD_INT 5
58716: EQUAL
58717: IFFALSE 58738
// points := [ 130 , 5 , 2 ] ;
58719: LD_ADDR_VAR 0 9
58723: PUSH
58724: LD_INT 130
58726: PUSH
58727: LD_INT 5
58729: PUSH
58730: LD_INT 2
58732: PUSH
58733: EMPTY
58734: LIST
58735: LIST
58736: LIST
58737: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58738: LD_VAR 0 6
58742: PPUSH
58743: CALL_OW 257
58747: PUSH
58748: LD_INT 8
58750: EQUAL
58751: IFFALSE 58772
// points := [ 35 , 35 , 30 ] ;
58753: LD_ADDR_VAR 0 9
58757: PUSH
58758: LD_INT 35
58760: PUSH
58761: LD_INT 35
58763: PUSH
58764: LD_INT 30
58766: PUSH
58767: EMPTY
58768: LIST
58769: LIST
58770: LIST
58771: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58772: LD_VAR 0 6
58776: PPUSH
58777: CALL_OW 257
58781: PUSH
58782: LD_INT 9
58784: EQUAL
58785: IFFALSE 58806
// points := [ 20 , 55 , 40 ] ;
58787: LD_ADDR_VAR 0 9
58791: PUSH
58792: LD_INT 20
58794: PUSH
58795: LD_INT 55
58797: PUSH
58798: LD_INT 40
58800: PUSH
58801: EMPTY
58802: LIST
58803: LIST
58804: LIST
58805: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58806: LD_VAR 0 6
58810: PPUSH
58811: CALL_OW 257
58815: PUSH
58816: LD_INT 12
58818: PUSH
58819: LD_INT 16
58821: PUSH
58822: EMPTY
58823: LIST
58824: LIST
58825: IN
58826: IFFALSE 58847
// points := [ 5 , 3 , 2 ] ;
58828: LD_ADDR_VAR 0 9
58832: PUSH
58833: LD_INT 5
58835: PUSH
58836: LD_INT 3
58838: PUSH
58839: LD_INT 2
58841: PUSH
58842: EMPTY
58843: LIST
58844: LIST
58845: LIST
58846: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58847: LD_VAR 0 6
58851: PPUSH
58852: CALL_OW 257
58856: PUSH
58857: LD_INT 17
58859: EQUAL
58860: IFFALSE 58881
// points := [ 100 , 50 , 75 ] ;
58862: LD_ADDR_VAR 0 9
58866: PUSH
58867: LD_INT 100
58869: PUSH
58870: LD_INT 50
58872: PUSH
58873: LD_INT 75
58875: PUSH
58876: EMPTY
58877: LIST
58878: LIST
58879: LIST
58880: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58881: LD_VAR 0 6
58885: PPUSH
58886: CALL_OW 257
58890: PUSH
58891: LD_INT 15
58893: EQUAL
58894: IFFALSE 58915
// points := [ 10 , 5 , 3 ] ;
58896: LD_ADDR_VAR 0 9
58900: PUSH
58901: LD_INT 10
58903: PUSH
58904: LD_INT 5
58906: PUSH
58907: LD_INT 3
58909: PUSH
58910: EMPTY
58911: LIST
58912: LIST
58913: LIST
58914: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58915: LD_VAR 0 6
58919: PPUSH
58920: CALL_OW 257
58924: PUSH
58925: LD_INT 14
58927: EQUAL
58928: IFFALSE 58949
// points := [ 10 , 0 , 0 ] ;
58930: LD_ADDR_VAR 0 9
58934: PUSH
58935: LD_INT 10
58937: PUSH
58938: LD_INT 0
58940: PUSH
58941: LD_INT 0
58943: PUSH
58944: EMPTY
58945: LIST
58946: LIST
58947: LIST
58948: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58949: LD_VAR 0 6
58953: PPUSH
58954: CALL_OW 257
58958: PUSH
58959: LD_INT 11
58961: EQUAL
58962: IFFALSE 58983
// points := [ 30 , 10 , 5 ] ;
58964: LD_ADDR_VAR 0 9
58968: PUSH
58969: LD_INT 30
58971: PUSH
58972: LD_INT 10
58974: PUSH
58975: LD_INT 5
58977: PUSH
58978: EMPTY
58979: LIST
58980: LIST
58981: LIST
58982: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58983: LD_VAR 0 1
58987: PPUSH
58988: LD_INT 5
58990: PPUSH
58991: CALL_OW 321
58995: PUSH
58996: LD_INT 2
58998: EQUAL
58999: IFFALSE 59016
// bpoints := bpoints * 1.8 ;
59001: LD_ADDR_VAR 0 10
59005: PUSH
59006: LD_VAR 0 10
59010: PUSH
59011: LD_REAL  1.80000000000000E+0000
59014: MUL
59015: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59016: LD_VAR 0 6
59020: PPUSH
59021: CALL_OW 257
59025: PUSH
59026: LD_INT 1
59028: PUSH
59029: LD_INT 2
59031: PUSH
59032: LD_INT 3
59034: PUSH
59035: LD_INT 4
59037: PUSH
59038: EMPTY
59039: LIST
59040: LIST
59041: LIST
59042: LIST
59043: IN
59044: PUSH
59045: LD_VAR 0 1
59049: PPUSH
59050: LD_INT 51
59052: PPUSH
59053: CALL_OW 321
59057: PUSH
59058: LD_INT 2
59060: EQUAL
59061: AND
59062: IFFALSE 59079
// bpoints := bpoints * 1.2 ;
59064: LD_ADDR_VAR 0 10
59068: PUSH
59069: LD_VAR 0 10
59073: PUSH
59074: LD_REAL  1.20000000000000E+0000
59077: MUL
59078: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59079: LD_VAR 0 6
59083: PPUSH
59084: CALL_OW 257
59088: PUSH
59089: LD_INT 5
59091: PUSH
59092: LD_INT 7
59094: PUSH
59095: LD_INT 9
59097: PUSH
59098: EMPTY
59099: LIST
59100: LIST
59101: LIST
59102: IN
59103: PUSH
59104: LD_VAR 0 1
59108: PPUSH
59109: LD_INT 52
59111: PPUSH
59112: CALL_OW 321
59116: PUSH
59117: LD_INT 2
59119: EQUAL
59120: AND
59121: IFFALSE 59138
// bpoints := bpoints * 1.5 ;
59123: LD_ADDR_VAR 0 10
59127: PUSH
59128: LD_VAR 0 10
59132: PUSH
59133: LD_REAL  1.50000000000000E+0000
59136: MUL
59137: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59138: LD_VAR 0 1
59142: PPUSH
59143: LD_INT 66
59145: PPUSH
59146: CALL_OW 321
59150: PUSH
59151: LD_INT 2
59153: EQUAL
59154: IFFALSE 59171
// bpoints := bpoints * 1.1 ;
59156: LD_ADDR_VAR 0 10
59160: PUSH
59161: LD_VAR 0 10
59165: PUSH
59166: LD_REAL  1.10000000000000E+0000
59169: MUL
59170: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59171: LD_ADDR_VAR 0 10
59175: PUSH
59176: LD_VAR 0 10
59180: PUSH
59181: LD_VAR 0 6
59185: PPUSH
59186: LD_INT 1
59188: PPUSH
59189: CALL_OW 259
59193: PUSH
59194: LD_REAL  1.15000000000000E+0000
59197: MUL
59198: MUL
59199: ST_TO_ADDR
// end ; unit_vehicle :
59200: GO 60024
59202: LD_INT 2
59204: DOUBLE
59205: EQUAL
59206: IFTRUE 59210
59208: GO 60012
59210: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59211: LD_VAR 0 6
59215: PPUSH
59216: CALL_OW 264
59220: PUSH
59221: LD_INT 2
59223: PUSH
59224: LD_INT 42
59226: PUSH
59227: LD_INT 24
59229: PUSH
59230: EMPTY
59231: LIST
59232: LIST
59233: LIST
59234: IN
59235: IFFALSE 59256
// points := [ 25 , 5 , 3 ] ;
59237: LD_ADDR_VAR 0 9
59241: PUSH
59242: LD_INT 25
59244: PUSH
59245: LD_INT 5
59247: PUSH
59248: LD_INT 3
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: LIST
59255: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59256: LD_VAR 0 6
59260: PPUSH
59261: CALL_OW 264
59265: PUSH
59266: LD_INT 4
59268: PUSH
59269: LD_INT 43
59271: PUSH
59272: LD_INT 25
59274: PUSH
59275: EMPTY
59276: LIST
59277: LIST
59278: LIST
59279: IN
59280: IFFALSE 59301
// points := [ 40 , 15 , 5 ] ;
59282: LD_ADDR_VAR 0 9
59286: PUSH
59287: LD_INT 40
59289: PUSH
59290: LD_INT 15
59292: PUSH
59293: LD_INT 5
59295: PUSH
59296: EMPTY
59297: LIST
59298: LIST
59299: LIST
59300: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59301: LD_VAR 0 6
59305: PPUSH
59306: CALL_OW 264
59310: PUSH
59311: LD_INT 3
59313: PUSH
59314: LD_INT 23
59316: PUSH
59317: EMPTY
59318: LIST
59319: LIST
59320: IN
59321: IFFALSE 59342
// points := [ 7 , 25 , 8 ] ;
59323: LD_ADDR_VAR 0 9
59327: PUSH
59328: LD_INT 7
59330: PUSH
59331: LD_INT 25
59333: PUSH
59334: LD_INT 8
59336: PUSH
59337: EMPTY
59338: LIST
59339: LIST
59340: LIST
59341: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59342: LD_VAR 0 6
59346: PPUSH
59347: CALL_OW 264
59351: PUSH
59352: LD_INT 5
59354: PUSH
59355: LD_INT 27
59357: PUSH
59358: LD_INT 44
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: LIST
59365: IN
59366: IFFALSE 59387
// points := [ 14 , 50 , 16 ] ;
59368: LD_ADDR_VAR 0 9
59372: PUSH
59373: LD_INT 14
59375: PUSH
59376: LD_INT 50
59378: PUSH
59379: LD_INT 16
59381: PUSH
59382: EMPTY
59383: LIST
59384: LIST
59385: LIST
59386: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59387: LD_VAR 0 6
59391: PPUSH
59392: CALL_OW 264
59396: PUSH
59397: LD_INT 6
59399: PUSH
59400: LD_INT 46
59402: PUSH
59403: EMPTY
59404: LIST
59405: LIST
59406: IN
59407: IFFALSE 59428
// points := [ 32 , 120 , 70 ] ;
59409: LD_ADDR_VAR 0 9
59413: PUSH
59414: LD_INT 32
59416: PUSH
59417: LD_INT 120
59419: PUSH
59420: LD_INT 70
59422: PUSH
59423: EMPTY
59424: LIST
59425: LIST
59426: LIST
59427: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
59428: LD_VAR 0 6
59432: PPUSH
59433: CALL_OW 264
59437: PUSH
59438: LD_INT 7
59440: PUSH
59441: LD_INT 28
59443: PUSH
59444: LD_INT 45
59446: PUSH
59447: EMPTY
59448: LIST
59449: LIST
59450: LIST
59451: IN
59452: IFFALSE 59473
// points := [ 35 , 20 , 45 ] ;
59454: LD_ADDR_VAR 0 9
59458: PUSH
59459: LD_INT 35
59461: PUSH
59462: LD_INT 20
59464: PUSH
59465: LD_INT 45
59467: PUSH
59468: EMPTY
59469: LIST
59470: LIST
59471: LIST
59472: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59473: LD_VAR 0 6
59477: PPUSH
59478: CALL_OW 264
59482: PUSH
59483: LD_INT 47
59485: PUSH
59486: EMPTY
59487: LIST
59488: IN
59489: IFFALSE 59510
// points := [ 67 , 45 , 75 ] ;
59491: LD_ADDR_VAR 0 9
59495: PUSH
59496: LD_INT 67
59498: PUSH
59499: LD_INT 45
59501: PUSH
59502: LD_INT 75
59504: PUSH
59505: EMPTY
59506: LIST
59507: LIST
59508: LIST
59509: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59510: LD_VAR 0 6
59514: PPUSH
59515: CALL_OW 264
59519: PUSH
59520: LD_INT 26
59522: PUSH
59523: EMPTY
59524: LIST
59525: IN
59526: IFFALSE 59547
// points := [ 120 , 30 , 80 ] ;
59528: LD_ADDR_VAR 0 9
59532: PUSH
59533: LD_INT 120
59535: PUSH
59536: LD_INT 30
59538: PUSH
59539: LD_INT 80
59541: PUSH
59542: EMPTY
59543: LIST
59544: LIST
59545: LIST
59546: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59547: LD_VAR 0 6
59551: PPUSH
59552: CALL_OW 264
59556: PUSH
59557: LD_INT 22
59559: PUSH
59560: EMPTY
59561: LIST
59562: IN
59563: IFFALSE 59584
// points := [ 40 , 1 , 1 ] ;
59565: LD_ADDR_VAR 0 9
59569: PUSH
59570: LD_INT 40
59572: PUSH
59573: LD_INT 1
59575: PUSH
59576: LD_INT 1
59578: PUSH
59579: EMPTY
59580: LIST
59581: LIST
59582: LIST
59583: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59584: LD_VAR 0 6
59588: PPUSH
59589: CALL_OW 264
59593: PUSH
59594: LD_INT 29
59596: PUSH
59597: EMPTY
59598: LIST
59599: IN
59600: IFFALSE 59621
// points := [ 70 , 200 , 400 ] ;
59602: LD_ADDR_VAR 0 9
59606: PUSH
59607: LD_INT 70
59609: PUSH
59610: LD_INT 200
59612: PUSH
59613: LD_INT 400
59615: PUSH
59616: EMPTY
59617: LIST
59618: LIST
59619: LIST
59620: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59621: LD_VAR 0 6
59625: PPUSH
59626: CALL_OW 264
59630: PUSH
59631: LD_INT 14
59633: PUSH
59634: LD_INT 53
59636: PUSH
59637: EMPTY
59638: LIST
59639: LIST
59640: IN
59641: IFFALSE 59662
// points := [ 40 , 10 , 20 ] ;
59643: LD_ADDR_VAR 0 9
59647: PUSH
59648: LD_INT 40
59650: PUSH
59651: LD_INT 10
59653: PUSH
59654: LD_INT 20
59656: PUSH
59657: EMPTY
59658: LIST
59659: LIST
59660: LIST
59661: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59662: LD_VAR 0 6
59666: PPUSH
59667: CALL_OW 264
59671: PUSH
59672: LD_INT 9
59674: PUSH
59675: EMPTY
59676: LIST
59677: IN
59678: IFFALSE 59699
// points := [ 5 , 70 , 20 ] ;
59680: LD_ADDR_VAR 0 9
59684: PUSH
59685: LD_INT 5
59687: PUSH
59688: LD_INT 70
59690: PUSH
59691: LD_INT 20
59693: PUSH
59694: EMPTY
59695: LIST
59696: LIST
59697: LIST
59698: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59699: LD_VAR 0 6
59703: PPUSH
59704: CALL_OW 264
59708: PUSH
59709: LD_INT 10
59711: PUSH
59712: EMPTY
59713: LIST
59714: IN
59715: IFFALSE 59736
// points := [ 35 , 110 , 70 ] ;
59717: LD_ADDR_VAR 0 9
59721: PUSH
59722: LD_INT 35
59724: PUSH
59725: LD_INT 110
59727: PUSH
59728: LD_INT 70
59730: PUSH
59731: EMPTY
59732: LIST
59733: LIST
59734: LIST
59735: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59736: LD_VAR 0 6
59740: PPUSH
59741: CALL_OW 265
59745: PUSH
59746: LD_INT 25
59748: EQUAL
59749: IFFALSE 59770
// points := [ 80 , 65 , 100 ] ;
59751: LD_ADDR_VAR 0 9
59755: PUSH
59756: LD_INT 80
59758: PUSH
59759: LD_INT 65
59761: PUSH
59762: LD_INT 100
59764: PUSH
59765: EMPTY
59766: LIST
59767: LIST
59768: LIST
59769: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59770: LD_VAR 0 6
59774: PPUSH
59775: CALL_OW 263
59779: PUSH
59780: LD_INT 1
59782: EQUAL
59783: IFFALSE 59818
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59785: LD_ADDR_VAR 0 10
59789: PUSH
59790: LD_VAR 0 10
59794: PUSH
59795: LD_VAR 0 6
59799: PPUSH
59800: CALL_OW 311
59804: PPUSH
59805: LD_INT 3
59807: PPUSH
59808: CALL_OW 259
59812: PUSH
59813: LD_INT 4
59815: MUL
59816: MUL
59817: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59818: LD_VAR 0 6
59822: PPUSH
59823: CALL_OW 263
59827: PUSH
59828: LD_INT 2
59830: EQUAL
59831: IFFALSE 59882
// begin j := IsControledBy ( i ) ;
59833: LD_ADDR_VAR 0 7
59837: PUSH
59838: LD_VAR 0 6
59842: PPUSH
59843: CALL_OW 312
59847: ST_TO_ADDR
// if j then
59848: LD_VAR 0 7
59852: IFFALSE 59882
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59854: LD_ADDR_VAR 0 10
59858: PUSH
59859: LD_VAR 0 10
59863: PUSH
59864: LD_VAR 0 7
59868: PPUSH
59869: LD_INT 3
59871: PPUSH
59872: CALL_OW 259
59876: PUSH
59877: LD_INT 3
59879: MUL
59880: MUL
59881: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59882: LD_VAR 0 6
59886: PPUSH
59887: CALL_OW 264
59891: PUSH
59892: LD_INT 5
59894: PUSH
59895: LD_INT 6
59897: PUSH
59898: LD_INT 46
59900: PUSH
59901: LD_INT 44
59903: PUSH
59904: LD_INT 47
59906: PUSH
59907: LD_INT 45
59909: PUSH
59910: LD_INT 28
59912: PUSH
59913: LD_INT 7
59915: PUSH
59916: LD_INT 27
59918: PUSH
59919: LD_INT 29
59921: PUSH
59922: EMPTY
59923: LIST
59924: LIST
59925: LIST
59926: LIST
59927: LIST
59928: LIST
59929: LIST
59930: LIST
59931: LIST
59932: LIST
59933: IN
59934: PUSH
59935: LD_VAR 0 1
59939: PPUSH
59940: LD_INT 52
59942: PPUSH
59943: CALL_OW 321
59947: PUSH
59948: LD_INT 2
59950: EQUAL
59951: AND
59952: IFFALSE 59969
// bpoints := bpoints * 1.2 ;
59954: LD_ADDR_VAR 0 10
59958: PUSH
59959: LD_VAR 0 10
59963: PUSH
59964: LD_REAL  1.20000000000000E+0000
59967: MUL
59968: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59969: LD_VAR 0 6
59973: PPUSH
59974: CALL_OW 264
59978: PUSH
59979: LD_INT 6
59981: PUSH
59982: LD_INT 46
59984: PUSH
59985: LD_INT 47
59987: PUSH
59988: EMPTY
59989: LIST
59990: LIST
59991: LIST
59992: IN
59993: IFFALSE 60010
// bpoints := bpoints * 1.2 ;
59995: LD_ADDR_VAR 0 10
59999: PUSH
60000: LD_VAR 0 10
60004: PUSH
60005: LD_REAL  1.20000000000000E+0000
60008: MUL
60009: ST_TO_ADDR
// end ; unit_building :
60010: GO 60024
60012: LD_INT 3
60014: DOUBLE
60015: EQUAL
60016: IFTRUE 60020
60018: GO 60023
60020: POP
// ; end ;
60021: GO 60024
60023: POP
// for j = 1 to 3 do
60024: LD_ADDR_VAR 0 7
60028: PUSH
60029: DOUBLE
60030: LD_INT 1
60032: DEC
60033: ST_TO_ADDR
60034: LD_INT 3
60036: PUSH
60037: FOR_TO
60038: IFFALSE 60091
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60040: LD_ADDR_VAR 0 5
60044: PUSH
60045: LD_VAR 0 5
60049: PPUSH
60050: LD_VAR 0 7
60054: PPUSH
60055: LD_VAR 0 5
60059: PUSH
60060: LD_VAR 0 7
60064: ARRAY
60065: PUSH
60066: LD_VAR 0 9
60070: PUSH
60071: LD_VAR 0 7
60075: ARRAY
60076: PUSH
60077: LD_VAR 0 10
60081: MUL
60082: PLUS
60083: PPUSH
60084: CALL_OW 1
60088: ST_TO_ADDR
60089: GO 60037
60091: POP
60092: POP
// end ;
60093: GO 58576
60095: POP
60096: POP
// result := Replace ( result , 4 , tmp ) ;
60097: LD_ADDR_VAR 0 5
60101: PUSH
60102: LD_VAR 0 5
60106: PPUSH
60107: LD_INT 4
60109: PPUSH
60110: LD_VAR 0 8
60114: PPUSH
60115: CALL_OW 1
60119: ST_TO_ADDR
// end ;
60120: LD_VAR 0 5
60124: RET
// export function DangerAtRange ( unit , range ) ; begin
60125: LD_INT 0
60127: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60128: LD_ADDR_VAR 0 3
60132: PUSH
60133: LD_VAR 0 1
60137: PPUSH
60138: CALL_OW 255
60142: PPUSH
60143: LD_VAR 0 1
60147: PPUSH
60148: CALL_OW 250
60152: PPUSH
60153: LD_VAR 0 1
60157: PPUSH
60158: CALL_OW 251
60162: PPUSH
60163: LD_VAR 0 2
60167: PPUSH
60168: CALL 58428 0 4
60172: ST_TO_ADDR
// end ;
60173: LD_VAR 0 3
60177: RET
// export function DangerInArea ( side , area ) ; begin
60178: LD_INT 0
60180: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60181: LD_ADDR_VAR 0 3
60185: PUSH
60186: LD_VAR 0 2
60190: PPUSH
60191: LD_INT 81
60193: PUSH
60194: LD_VAR 0 1
60198: PUSH
60199: EMPTY
60200: LIST
60201: LIST
60202: PPUSH
60203: CALL_OW 70
60207: ST_TO_ADDR
// end ;
60208: LD_VAR 0 3
60212: RET
// export function IsExtension ( b ) ; begin
60213: LD_INT 0
60215: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60216: LD_ADDR_VAR 0 2
60220: PUSH
60221: LD_VAR 0 1
60225: PUSH
60226: LD_INT 23
60228: PUSH
60229: LD_INT 20
60231: PUSH
60232: LD_INT 22
60234: PUSH
60235: LD_INT 17
60237: PUSH
60238: LD_INT 24
60240: PUSH
60241: LD_INT 21
60243: PUSH
60244: LD_INT 19
60246: PUSH
60247: LD_INT 16
60249: PUSH
60250: LD_INT 25
60252: PUSH
60253: LD_INT 18
60255: PUSH
60256: EMPTY
60257: LIST
60258: LIST
60259: LIST
60260: LIST
60261: LIST
60262: LIST
60263: LIST
60264: LIST
60265: LIST
60266: LIST
60267: IN
60268: ST_TO_ADDR
// end ;
60269: LD_VAR 0 2
60273: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
60274: LD_INT 0
60276: PPUSH
60277: PPUSH
60278: PPUSH
// result := [ ] ;
60279: LD_ADDR_VAR 0 3
60283: PUSH
60284: EMPTY
60285: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60286: LD_ADDR_VAR 0 4
60290: PUSH
60291: LD_VAR 0 2
60295: PPUSH
60296: LD_INT 21
60298: PUSH
60299: LD_INT 3
60301: PUSH
60302: EMPTY
60303: LIST
60304: LIST
60305: PPUSH
60306: CALL_OW 70
60310: ST_TO_ADDR
// if not tmp then
60311: LD_VAR 0 4
60315: NOT
60316: IFFALSE 60320
// exit ;
60318: GO 60378
// for i in tmp do
60320: LD_ADDR_VAR 0 5
60324: PUSH
60325: LD_VAR 0 4
60329: PUSH
60330: FOR_IN
60331: IFFALSE 60366
// if GetBase ( i ) <> base then
60333: LD_VAR 0 5
60337: PPUSH
60338: CALL_OW 274
60342: PUSH
60343: LD_VAR 0 1
60347: NONEQUAL
60348: IFFALSE 60364
// ComLinkToBase ( base , i ) ;
60350: LD_VAR 0 1
60354: PPUSH
60355: LD_VAR 0 5
60359: PPUSH
60360: CALL_OW 169
60364: GO 60330
60366: POP
60367: POP
// result := tmp ;
60368: LD_ADDR_VAR 0 3
60372: PUSH
60373: LD_VAR 0 4
60377: ST_TO_ADDR
// end ;
60378: LD_VAR 0 3
60382: RET
// export function ComComplete ( unit , b ) ; var i ; begin
60383: LD_INT 0
60385: PPUSH
60386: PPUSH
// if BuildingStatus ( b ) = bs_build then
60387: LD_VAR 0 2
60391: PPUSH
60392: CALL_OW 461
60396: PUSH
60397: LD_INT 1
60399: EQUAL
60400: IFFALSE 60460
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60402: LD_VAR 0 1
60406: PPUSH
60407: LD_STRING h
60409: PUSH
60410: LD_VAR 0 2
60414: PPUSH
60415: CALL_OW 250
60419: PUSH
60420: LD_VAR 0 2
60424: PPUSH
60425: CALL_OW 251
60429: PUSH
60430: LD_VAR 0 2
60434: PUSH
60435: LD_INT 0
60437: PUSH
60438: LD_INT 0
60440: PUSH
60441: LD_INT 0
60443: PUSH
60444: EMPTY
60445: LIST
60446: LIST
60447: LIST
60448: LIST
60449: LIST
60450: LIST
60451: LIST
60452: PUSH
60453: EMPTY
60454: LIST
60455: PPUSH
60456: CALL_OW 446
// end ;
60460: LD_VAR 0 3
60464: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60465: LD_INT 0
60467: PPUSH
60468: PPUSH
60469: PPUSH
60470: PPUSH
60471: PPUSH
60472: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
60473: LD_VAR 0 1
60477: NOT
60478: PUSH
60479: LD_VAR 0 1
60483: PPUSH
60484: CALL_OW 263
60488: PUSH
60489: LD_INT 2
60491: EQUAL
60492: NOT
60493: OR
60494: IFFALSE 60498
// exit ;
60496: GO 60814
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60498: LD_ADDR_VAR 0 6
60502: PUSH
60503: LD_INT 22
60505: PUSH
60506: LD_VAR 0 1
60510: PPUSH
60511: CALL_OW 255
60515: PUSH
60516: EMPTY
60517: LIST
60518: LIST
60519: PUSH
60520: LD_INT 2
60522: PUSH
60523: LD_INT 30
60525: PUSH
60526: LD_INT 36
60528: PUSH
60529: EMPTY
60530: LIST
60531: LIST
60532: PUSH
60533: LD_INT 34
60535: PUSH
60536: LD_INT 31
60538: PUSH
60539: EMPTY
60540: LIST
60541: LIST
60542: PUSH
60543: EMPTY
60544: LIST
60545: LIST
60546: LIST
60547: PUSH
60548: EMPTY
60549: LIST
60550: LIST
60551: PPUSH
60552: CALL_OW 69
60556: ST_TO_ADDR
// if not tmp then
60557: LD_VAR 0 6
60561: NOT
60562: IFFALSE 60566
// exit ;
60564: GO 60814
// result := [ ] ;
60566: LD_ADDR_VAR 0 2
60570: PUSH
60571: EMPTY
60572: ST_TO_ADDR
// for i in tmp do
60573: LD_ADDR_VAR 0 3
60577: PUSH
60578: LD_VAR 0 6
60582: PUSH
60583: FOR_IN
60584: IFFALSE 60655
// begin t := UnitsInside ( i ) ;
60586: LD_ADDR_VAR 0 4
60590: PUSH
60591: LD_VAR 0 3
60595: PPUSH
60596: CALL_OW 313
60600: ST_TO_ADDR
// if t then
60601: LD_VAR 0 4
60605: IFFALSE 60653
// for j in t do
60607: LD_ADDR_VAR 0 7
60611: PUSH
60612: LD_VAR 0 4
60616: PUSH
60617: FOR_IN
60618: IFFALSE 60651
// result := Insert ( result , result + 1 , j ) ;
60620: LD_ADDR_VAR 0 2
60624: PUSH
60625: LD_VAR 0 2
60629: PPUSH
60630: LD_VAR 0 2
60634: PUSH
60635: LD_INT 1
60637: PLUS
60638: PPUSH
60639: LD_VAR 0 7
60643: PPUSH
60644: CALL_OW 2
60648: ST_TO_ADDR
60649: GO 60617
60651: POP
60652: POP
// end ;
60653: GO 60583
60655: POP
60656: POP
// if not result then
60657: LD_VAR 0 2
60661: NOT
60662: IFFALSE 60666
// exit ;
60664: GO 60814
// mech := result [ 1 ] ;
60666: LD_ADDR_VAR 0 5
60670: PUSH
60671: LD_VAR 0 2
60675: PUSH
60676: LD_INT 1
60678: ARRAY
60679: ST_TO_ADDR
// if result > 1 then
60680: LD_VAR 0 2
60684: PUSH
60685: LD_INT 1
60687: GREATER
60688: IFFALSE 60800
// for i = 2 to result do
60690: LD_ADDR_VAR 0 3
60694: PUSH
60695: DOUBLE
60696: LD_INT 2
60698: DEC
60699: ST_TO_ADDR
60700: LD_VAR 0 2
60704: PUSH
60705: FOR_TO
60706: IFFALSE 60798
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60708: LD_ADDR_VAR 0 4
60712: PUSH
60713: LD_VAR 0 2
60717: PUSH
60718: LD_VAR 0 3
60722: ARRAY
60723: PPUSH
60724: LD_INT 3
60726: PPUSH
60727: CALL_OW 259
60731: PUSH
60732: LD_VAR 0 2
60736: PUSH
60737: LD_VAR 0 3
60741: ARRAY
60742: PPUSH
60743: CALL_OW 432
60747: MINUS
60748: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60749: LD_VAR 0 4
60753: PUSH
60754: LD_VAR 0 5
60758: PPUSH
60759: LD_INT 3
60761: PPUSH
60762: CALL_OW 259
60766: PUSH
60767: LD_VAR 0 5
60771: PPUSH
60772: CALL_OW 432
60776: MINUS
60777: GREATEREQUAL
60778: IFFALSE 60796
// mech := result [ i ] ;
60780: LD_ADDR_VAR 0 5
60784: PUSH
60785: LD_VAR 0 2
60789: PUSH
60790: LD_VAR 0 3
60794: ARRAY
60795: ST_TO_ADDR
// end ;
60796: GO 60705
60798: POP
60799: POP
// ComLinkTo ( vehicle , mech ) ;
60800: LD_VAR 0 1
60804: PPUSH
60805: LD_VAR 0 5
60809: PPUSH
60810: CALL_OW 135
// end ;
60814: LD_VAR 0 2
60818: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60819: LD_INT 0
60821: PPUSH
60822: PPUSH
60823: PPUSH
60824: PPUSH
60825: PPUSH
60826: PPUSH
60827: PPUSH
60828: PPUSH
60829: PPUSH
60830: PPUSH
60831: PPUSH
60832: PPUSH
60833: PPUSH
// result := [ ] ;
60834: LD_ADDR_VAR 0 7
60838: PUSH
60839: EMPTY
60840: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60841: LD_VAR 0 1
60845: PPUSH
60846: CALL_OW 266
60850: PUSH
60851: LD_INT 0
60853: PUSH
60854: LD_INT 1
60856: PUSH
60857: EMPTY
60858: LIST
60859: LIST
60860: IN
60861: NOT
60862: IFFALSE 60866
// exit ;
60864: GO 62497
// if name then
60866: LD_VAR 0 3
60870: IFFALSE 60886
// SetBName ( base_dep , name ) ;
60872: LD_VAR 0 1
60876: PPUSH
60877: LD_VAR 0 3
60881: PPUSH
60882: CALL_OW 500
// base := GetBase ( base_dep ) ;
60886: LD_ADDR_VAR 0 15
60890: PUSH
60891: LD_VAR 0 1
60895: PPUSH
60896: CALL_OW 274
60900: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60901: LD_ADDR_VAR 0 16
60905: PUSH
60906: LD_VAR 0 1
60910: PPUSH
60911: CALL_OW 255
60915: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60916: LD_ADDR_VAR 0 17
60920: PUSH
60921: LD_VAR 0 1
60925: PPUSH
60926: CALL_OW 248
60930: ST_TO_ADDR
// if sources then
60931: LD_VAR 0 5
60935: IFFALSE 60982
// for i = 1 to 3 do
60937: LD_ADDR_VAR 0 8
60941: PUSH
60942: DOUBLE
60943: LD_INT 1
60945: DEC
60946: ST_TO_ADDR
60947: LD_INT 3
60949: PUSH
60950: FOR_TO
60951: IFFALSE 60980
// AddResourceType ( base , i , sources [ i ] ) ;
60953: LD_VAR 0 15
60957: PPUSH
60958: LD_VAR 0 8
60962: PPUSH
60963: LD_VAR 0 5
60967: PUSH
60968: LD_VAR 0 8
60972: ARRAY
60973: PPUSH
60974: CALL_OW 276
60978: GO 60950
60980: POP
60981: POP
// buildings := GetBaseBuildings ( base , area ) ;
60982: LD_ADDR_VAR 0 18
60986: PUSH
60987: LD_VAR 0 15
60991: PPUSH
60992: LD_VAR 0 2
60996: PPUSH
60997: CALL 60274 0 2
61001: ST_TO_ADDR
// InitHc ;
61002: CALL_OW 19
// InitUc ;
61006: CALL_OW 18
// uc_side := side ;
61010: LD_ADDR_OWVAR 20
61014: PUSH
61015: LD_VAR 0 16
61019: ST_TO_ADDR
// uc_nation := nation ;
61020: LD_ADDR_OWVAR 21
61024: PUSH
61025: LD_VAR 0 17
61029: ST_TO_ADDR
// if buildings then
61030: LD_VAR 0 18
61034: IFFALSE 62356
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61036: LD_ADDR_VAR 0 19
61040: PUSH
61041: LD_VAR 0 18
61045: PPUSH
61046: LD_INT 2
61048: PUSH
61049: LD_INT 30
61051: PUSH
61052: LD_INT 29
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: PUSH
61059: LD_INT 30
61061: PUSH
61062: LD_INT 30
61064: PUSH
61065: EMPTY
61066: LIST
61067: LIST
61068: PUSH
61069: EMPTY
61070: LIST
61071: LIST
61072: LIST
61073: PPUSH
61074: CALL_OW 72
61078: ST_TO_ADDR
// if tmp then
61079: LD_VAR 0 19
61083: IFFALSE 61131
// for i in tmp do
61085: LD_ADDR_VAR 0 8
61089: PUSH
61090: LD_VAR 0 19
61094: PUSH
61095: FOR_IN
61096: IFFALSE 61129
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61098: LD_VAR 0 8
61102: PPUSH
61103: CALL_OW 250
61107: PPUSH
61108: LD_VAR 0 8
61112: PPUSH
61113: CALL_OW 251
61117: PPUSH
61118: LD_VAR 0 16
61122: PPUSH
61123: CALL_OW 441
61127: GO 61095
61129: POP
61130: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61131: LD_VAR 0 18
61135: PPUSH
61136: LD_INT 2
61138: PUSH
61139: LD_INT 30
61141: PUSH
61142: LD_INT 32
61144: PUSH
61145: EMPTY
61146: LIST
61147: LIST
61148: PUSH
61149: LD_INT 30
61151: PUSH
61152: LD_INT 33
61154: PUSH
61155: EMPTY
61156: LIST
61157: LIST
61158: PUSH
61159: EMPTY
61160: LIST
61161: LIST
61162: LIST
61163: PPUSH
61164: CALL_OW 72
61168: IFFALSE 61256
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61170: LD_ADDR_VAR 0 8
61174: PUSH
61175: LD_VAR 0 18
61179: PPUSH
61180: LD_INT 2
61182: PUSH
61183: LD_INT 30
61185: PUSH
61186: LD_INT 32
61188: PUSH
61189: EMPTY
61190: LIST
61191: LIST
61192: PUSH
61193: LD_INT 30
61195: PUSH
61196: LD_INT 33
61198: PUSH
61199: EMPTY
61200: LIST
61201: LIST
61202: PUSH
61203: EMPTY
61204: LIST
61205: LIST
61206: LIST
61207: PPUSH
61208: CALL_OW 72
61212: PUSH
61213: FOR_IN
61214: IFFALSE 61254
// begin if not GetBWeapon ( i ) then
61216: LD_VAR 0 8
61220: PPUSH
61221: CALL_OW 269
61225: NOT
61226: IFFALSE 61252
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61228: LD_VAR 0 8
61232: PPUSH
61233: LD_VAR 0 8
61237: PPUSH
61238: LD_VAR 0 2
61242: PPUSH
61243: CALL 62502 0 2
61247: PPUSH
61248: CALL_OW 431
// end ;
61252: GO 61213
61254: POP
61255: POP
// end ; for i = 1 to personel do
61256: LD_ADDR_VAR 0 8
61260: PUSH
61261: DOUBLE
61262: LD_INT 1
61264: DEC
61265: ST_TO_ADDR
61266: LD_VAR 0 6
61270: PUSH
61271: FOR_TO
61272: IFFALSE 62336
// begin if i > 4 then
61274: LD_VAR 0 8
61278: PUSH
61279: LD_INT 4
61281: GREATER
61282: IFFALSE 61286
// break ;
61284: GO 62336
// case i of 1 :
61286: LD_VAR 0 8
61290: PUSH
61291: LD_INT 1
61293: DOUBLE
61294: EQUAL
61295: IFTRUE 61299
61297: GO 61379
61299: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61300: LD_ADDR_VAR 0 12
61304: PUSH
61305: LD_VAR 0 18
61309: PPUSH
61310: LD_INT 22
61312: PUSH
61313: LD_VAR 0 16
61317: PUSH
61318: EMPTY
61319: LIST
61320: LIST
61321: PUSH
61322: LD_INT 58
61324: PUSH
61325: EMPTY
61326: LIST
61327: PUSH
61328: LD_INT 2
61330: PUSH
61331: LD_INT 30
61333: PUSH
61334: LD_INT 32
61336: PUSH
61337: EMPTY
61338: LIST
61339: LIST
61340: PUSH
61341: LD_INT 30
61343: PUSH
61344: LD_INT 4
61346: PUSH
61347: EMPTY
61348: LIST
61349: LIST
61350: PUSH
61351: LD_INT 30
61353: PUSH
61354: LD_INT 5
61356: PUSH
61357: EMPTY
61358: LIST
61359: LIST
61360: PUSH
61361: EMPTY
61362: LIST
61363: LIST
61364: LIST
61365: LIST
61366: PUSH
61367: EMPTY
61368: LIST
61369: LIST
61370: LIST
61371: PPUSH
61372: CALL_OW 72
61376: ST_TO_ADDR
61377: GO 61601
61379: LD_INT 2
61381: DOUBLE
61382: EQUAL
61383: IFTRUE 61387
61385: GO 61449
61387: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61388: LD_ADDR_VAR 0 12
61392: PUSH
61393: LD_VAR 0 18
61397: PPUSH
61398: LD_INT 22
61400: PUSH
61401: LD_VAR 0 16
61405: PUSH
61406: EMPTY
61407: LIST
61408: LIST
61409: PUSH
61410: LD_INT 2
61412: PUSH
61413: LD_INT 30
61415: PUSH
61416: LD_INT 0
61418: PUSH
61419: EMPTY
61420: LIST
61421: LIST
61422: PUSH
61423: LD_INT 30
61425: PUSH
61426: LD_INT 1
61428: PUSH
61429: EMPTY
61430: LIST
61431: LIST
61432: PUSH
61433: EMPTY
61434: LIST
61435: LIST
61436: LIST
61437: PUSH
61438: EMPTY
61439: LIST
61440: LIST
61441: PPUSH
61442: CALL_OW 72
61446: ST_TO_ADDR
61447: GO 61601
61449: LD_INT 3
61451: DOUBLE
61452: EQUAL
61453: IFTRUE 61457
61455: GO 61519
61457: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61458: LD_ADDR_VAR 0 12
61462: PUSH
61463: LD_VAR 0 18
61467: PPUSH
61468: LD_INT 22
61470: PUSH
61471: LD_VAR 0 16
61475: PUSH
61476: EMPTY
61477: LIST
61478: LIST
61479: PUSH
61480: LD_INT 2
61482: PUSH
61483: LD_INT 30
61485: PUSH
61486: LD_INT 2
61488: PUSH
61489: EMPTY
61490: LIST
61491: LIST
61492: PUSH
61493: LD_INT 30
61495: PUSH
61496: LD_INT 3
61498: PUSH
61499: EMPTY
61500: LIST
61501: LIST
61502: PUSH
61503: EMPTY
61504: LIST
61505: LIST
61506: LIST
61507: PUSH
61508: EMPTY
61509: LIST
61510: LIST
61511: PPUSH
61512: CALL_OW 72
61516: ST_TO_ADDR
61517: GO 61601
61519: LD_INT 4
61521: DOUBLE
61522: EQUAL
61523: IFTRUE 61527
61525: GO 61600
61527: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61528: LD_ADDR_VAR 0 12
61532: PUSH
61533: LD_VAR 0 18
61537: PPUSH
61538: LD_INT 22
61540: PUSH
61541: LD_VAR 0 16
61545: PUSH
61546: EMPTY
61547: LIST
61548: LIST
61549: PUSH
61550: LD_INT 2
61552: PUSH
61553: LD_INT 30
61555: PUSH
61556: LD_INT 6
61558: PUSH
61559: EMPTY
61560: LIST
61561: LIST
61562: PUSH
61563: LD_INT 30
61565: PUSH
61566: LD_INT 7
61568: PUSH
61569: EMPTY
61570: LIST
61571: LIST
61572: PUSH
61573: LD_INT 30
61575: PUSH
61576: LD_INT 8
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PUSH
61583: EMPTY
61584: LIST
61585: LIST
61586: LIST
61587: LIST
61588: PUSH
61589: EMPTY
61590: LIST
61591: LIST
61592: PPUSH
61593: CALL_OW 72
61597: ST_TO_ADDR
61598: GO 61601
61600: POP
// if i = 1 then
61601: LD_VAR 0 8
61605: PUSH
61606: LD_INT 1
61608: EQUAL
61609: IFFALSE 61720
// begin tmp := [ ] ;
61611: LD_ADDR_VAR 0 19
61615: PUSH
61616: EMPTY
61617: ST_TO_ADDR
// for j in f do
61618: LD_ADDR_VAR 0 9
61622: PUSH
61623: LD_VAR 0 12
61627: PUSH
61628: FOR_IN
61629: IFFALSE 61702
// if GetBType ( j ) = b_bunker then
61631: LD_VAR 0 9
61635: PPUSH
61636: CALL_OW 266
61640: PUSH
61641: LD_INT 32
61643: EQUAL
61644: IFFALSE 61671
// tmp := Insert ( tmp , 1 , j ) else
61646: LD_ADDR_VAR 0 19
61650: PUSH
61651: LD_VAR 0 19
61655: PPUSH
61656: LD_INT 1
61658: PPUSH
61659: LD_VAR 0 9
61663: PPUSH
61664: CALL_OW 2
61668: ST_TO_ADDR
61669: GO 61700
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61671: LD_ADDR_VAR 0 19
61675: PUSH
61676: LD_VAR 0 19
61680: PPUSH
61681: LD_VAR 0 19
61685: PUSH
61686: LD_INT 1
61688: PLUS
61689: PPUSH
61690: LD_VAR 0 9
61694: PPUSH
61695: CALL_OW 2
61699: ST_TO_ADDR
61700: GO 61628
61702: POP
61703: POP
// if tmp then
61704: LD_VAR 0 19
61708: IFFALSE 61720
// f := tmp ;
61710: LD_ADDR_VAR 0 12
61714: PUSH
61715: LD_VAR 0 19
61719: ST_TO_ADDR
// end ; x := personel [ i ] ;
61720: LD_ADDR_VAR 0 13
61724: PUSH
61725: LD_VAR 0 6
61729: PUSH
61730: LD_VAR 0 8
61734: ARRAY
61735: ST_TO_ADDR
// if x = - 1 then
61736: LD_VAR 0 13
61740: PUSH
61741: LD_INT 1
61743: NEG
61744: EQUAL
61745: IFFALSE 61954
// begin for j in f do
61747: LD_ADDR_VAR 0 9
61751: PUSH
61752: LD_VAR 0 12
61756: PUSH
61757: FOR_IN
61758: IFFALSE 61950
// repeat InitHc ;
61760: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61764: LD_VAR 0 9
61768: PPUSH
61769: CALL_OW 266
61773: PUSH
61774: LD_INT 5
61776: EQUAL
61777: IFFALSE 61847
// begin if UnitsInside ( j ) < 3 then
61779: LD_VAR 0 9
61783: PPUSH
61784: CALL_OW 313
61788: PUSH
61789: LD_INT 3
61791: LESS
61792: IFFALSE 61828
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61794: LD_INT 0
61796: PPUSH
61797: LD_INT 5
61799: PUSH
61800: LD_INT 8
61802: PUSH
61803: LD_INT 9
61805: PUSH
61806: EMPTY
61807: LIST
61808: LIST
61809: LIST
61810: PUSH
61811: LD_VAR 0 17
61815: ARRAY
61816: PPUSH
61817: LD_VAR 0 4
61821: PPUSH
61822: CALL_OW 380
61826: GO 61845
// PrepareHuman ( false , i , skill ) ;
61828: LD_INT 0
61830: PPUSH
61831: LD_VAR 0 8
61835: PPUSH
61836: LD_VAR 0 4
61840: PPUSH
61841: CALL_OW 380
// end else
61845: GO 61864
// PrepareHuman ( false , i , skill ) ;
61847: LD_INT 0
61849: PPUSH
61850: LD_VAR 0 8
61854: PPUSH
61855: LD_VAR 0 4
61859: PPUSH
61860: CALL_OW 380
// un := CreateHuman ;
61864: LD_ADDR_VAR 0 14
61868: PUSH
61869: CALL_OW 44
61873: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61874: LD_ADDR_VAR 0 7
61878: PUSH
61879: LD_VAR 0 7
61883: PPUSH
61884: LD_INT 1
61886: PPUSH
61887: LD_VAR 0 14
61891: PPUSH
61892: CALL_OW 2
61896: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61897: LD_VAR 0 14
61901: PPUSH
61902: LD_VAR 0 9
61906: PPUSH
61907: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61911: LD_VAR 0 9
61915: PPUSH
61916: CALL_OW 313
61920: PUSH
61921: LD_INT 6
61923: EQUAL
61924: PUSH
61925: LD_VAR 0 9
61929: PPUSH
61930: CALL_OW 266
61934: PUSH
61935: LD_INT 32
61937: PUSH
61938: LD_INT 31
61940: PUSH
61941: EMPTY
61942: LIST
61943: LIST
61944: IN
61945: OR
61946: IFFALSE 61760
61948: GO 61757
61950: POP
61951: POP
// end else
61952: GO 62334
// for j = 1 to x do
61954: LD_ADDR_VAR 0 9
61958: PUSH
61959: DOUBLE
61960: LD_INT 1
61962: DEC
61963: ST_TO_ADDR
61964: LD_VAR 0 13
61968: PUSH
61969: FOR_TO
61970: IFFALSE 62332
// begin InitHc ;
61972: CALL_OW 19
// if not f then
61976: LD_VAR 0 12
61980: NOT
61981: IFFALSE 62070
// begin PrepareHuman ( false , i , skill ) ;
61983: LD_INT 0
61985: PPUSH
61986: LD_VAR 0 8
61990: PPUSH
61991: LD_VAR 0 4
61995: PPUSH
61996: CALL_OW 380
// un := CreateHuman ;
62000: LD_ADDR_VAR 0 14
62004: PUSH
62005: CALL_OW 44
62009: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62010: LD_ADDR_VAR 0 7
62014: PUSH
62015: LD_VAR 0 7
62019: PPUSH
62020: LD_INT 1
62022: PPUSH
62023: LD_VAR 0 14
62027: PPUSH
62028: CALL_OW 2
62032: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62033: LD_VAR 0 14
62037: PPUSH
62038: LD_VAR 0 1
62042: PPUSH
62043: CALL_OW 250
62047: PPUSH
62048: LD_VAR 0 1
62052: PPUSH
62053: CALL_OW 251
62057: PPUSH
62058: LD_INT 10
62060: PPUSH
62061: LD_INT 0
62063: PPUSH
62064: CALL_OW 50
// continue ;
62068: GO 61969
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62070: LD_VAR 0 12
62074: PUSH
62075: LD_INT 1
62077: ARRAY
62078: PPUSH
62079: CALL_OW 313
62083: PUSH
62084: LD_VAR 0 12
62088: PUSH
62089: LD_INT 1
62091: ARRAY
62092: PPUSH
62093: CALL_OW 266
62097: PUSH
62098: LD_INT 32
62100: PUSH
62101: LD_INT 31
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: IN
62108: AND
62109: PUSH
62110: LD_VAR 0 12
62114: PUSH
62115: LD_INT 1
62117: ARRAY
62118: PPUSH
62119: CALL_OW 313
62123: PUSH
62124: LD_INT 6
62126: EQUAL
62127: OR
62128: IFFALSE 62148
// f := Delete ( f , 1 ) ;
62130: LD_ADDR_VAR 0 12
62134: PUSH
62135: LD_VAR 0 12
62139: PPUSH
62140: LD_INT 1
62142: PPUSH
62143: CALL_OW 3
62147: ST_TO_ADDR
// if not f then
62148: LD_VAR 0 12
62152: NOT
62153: IFFALSE 62171
// begin x := x + 2 ;
62155: LD_ADDR_VAR 0 13
62159: PUSH
62160: LD_VAR 0 13
62164: PUSH
62165: LD_INT 2
62167: PLUS
62168: ST_TO_ADDR
// continue ;
62169: GO 61969
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62171: LD_VAR 0 12
62175: PUSH
62176: LD_INT 1
62178: ARRAY
62179: PPUSH
62180: CALL_OW 266
62184: PUSH
62185: LD_INT 5
62187: EQUAL
62188: IFFALSE 62262
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62190: LD_VAR 0 12
62194: PUSH
62195: LD_INT 1
62197: ARRAY
62198: PPUSH
62199: CALL_OW 313
62203: PUSH
62204: LD_INT 3
62206: LESS
62207: IFFALSE 62243
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62209: LD_INT 0
62211: PPUSH
62212: LD_INT 5
62214: PUSH
62215: LD_INT 8
62217: PUSH
62218: LD_INT 9
62220: PUSH
62221: EMPTY
62222: LIST
62223: LIST
62224: LIST
62225: PUSH
62226: LD_VAR 0 17
62230: ARRAY
62231: PPUSH
62232: LD_VAR 0 4
62236: PPUSH
62237: CALL_OW 380
62241: GO 62260
// PrepareHuman ( false , i , skill ) ;
62243: LD_INT 0
62245: PPUSH
62246: LD_VAR 0 8
62250: PPUSH
62251: LD_VAR 0 4
62255: PPUSH
62256: CALL_OW 380
// end else
62260: GO 62279
// PrepareHuman ( false , i , skill ) ;
62262: LD_INT 0
62264: PPUSH
62265: LD_VAR 0 8
62269: PPUSH
62270: LD_VAR 0 4
62274: PPUSH
62275: CALL_OW 380
// un := CreateHuman ;
62279: LD_ADDR_VAR 0 14
62283: PUSH
62284: CALL_OW 44
62288: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62289: LD_ADDR_VAR 0 7
62293: PUSH
62294: LD_VAR 0 7
62298: PPUSH
62299: LD_INT 1
62301: PPUSH
62302: LD_VAR 0 14
62306: PPUSH
62307: CALL_OW 2
62311: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62312: LD_VAR 0 14
62316: PPUSH
62317: LD_VAR 0 12
62321: PUSH
62322: LD_INT 1
62324: ARRAY
62325: PPUSH
62326: CALL_OW 52
// end ;
62330: GO 61969
62332: POP
62333: POP
// end ;
62334: GO 61271
62336: POP
62337: POP
// result := result ^ buildings ;
62338: LD_ADDR_VAR 0 7
62342: PUSH
62343: LD_VAR 0 7
62347: PUSH
62348: LD_VAR 0 18
62352: ADD
62353: ST_TO_ADDR
// end else
62354: GO 62497
// begin for i = 1 to personel do
62356: LD_ADDR_VAR 0 8
62360: PUSH
62361: DOUBLE
62362: LD_INT 1
62364: DEC
62365: ST_TO_ADDR
62366: LD_VAR 0 6
62370: PUSH
62371: FOR_TO
62372: IFFALSE 62495
// begin if i > 4 then
62374: LD_VAR 0 8
62378: PUSH
62379: LD_INT 4
62381: GREATER
62382: IFFALSE 62386
// break ;
62384: GO 62495
// x := personel [ i ] ;
62386: LD_ADDR_VAR 0 13
62390: PUSH
62391: LD_VAR 0 6
62395: PUSH
62396: LD_VAR 0 8
62400: ARRAY
62401: ST_TO_ADDR
// if x = - 1 then
62402: LD_VAR 0 13
62406: PUSH
62407: LD_INT 1
62409: NEG
62410: EQUAL
62411: IFFALSE 62415
// continue ;
62413: GO 62371
// PrepareHuman ( false , i , skill ) ;
62415: LD_INT 0
62417: PPUSH
62418: LD_VAR 0 8
62422: PPUSH
62423: LD_VAR 0 4
62427: PPUSH
62428: CALL_OW 380
// un := CreateHuman ;
62432: LD_ADDR_VAR 0 14
62436: PUSH
62437: CALL_OW 44
62441: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62442: LD_VAR 0 14
62446: PPUSH
62447: LD_VAR 0 1
62451: PPUSH
62452: CALL_OW 250
62456: PPUSH
62457: LD_VAR 0 1
62461: PPUSH
62462: CALL_OW 251
62466: PPUSH
62467: LD_INT 10
62469: PPUSH
62470: LD_INT 0
62472: PPUSH
62473: CALL_OW 50
// result := result ^ un ;
62477: LD_ADDR_VAR 0 7
62481: PUSH
62482: LD_VAR 0 7
62486: PUSH
62487: LD_VAR 0 14
62491: ADD
62492: ST_TO_ADDR
// end ;
62493: GO 62371
62495: POP
62496: POP
// end ; end ;
62497: LD_VAR 0 7
62501: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62502: LD_INT 0
62504: PPUSH
62505: PPUSH
62506: PPUSH
62507: PPUSH
62508: PPUSH
62509: PPUSH
62510: PPUSH
62511: PPUSH
62512: PPUSH
62513: PPUSH
62514: PPUSH
62515: PPUSH
62516: PPUSH
62517: PPUSH
62518: PPUSH
62519: PPUSH
// result := false ;
62520: LD_ADDR_VAR 0 3
62524: PUSH
62525: LD_INT 0
62527: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62528: LD_VAR 0 1
62532: NOT
62533: PUSH
62534: LD_VAR 0 1
62538: PPUSH
62539: CALL_OW 266
62543: PUSH
62544: LD_INT 32
62546: PUSH
62547: LD_INT 33
62549: PUSH
62550: EMPTY
62551: LIST
62552: LIST
62553: IN
62554: NOT
62555: OR
62556: IFFALSE 62560
// exit ;
62558: GO 63696
// nat := GetNation ( tower ) ;
62560: LD_ADDR_VAR 0 12
62564: PUSH
62565: LD_VAR 0 1
62569: PPUSH
62570: CALL_OW 248
62574: ST_TO_ADDR
// side := GetSide ( tower ) ;
62575: LD_ADDR_VAR 0 16
62579: PUSH
62580: LD_VAR 0 1
62584: PPUSH
62585: CALL_OW 255
62589: ST_TO_ADDR
// x := GetX ( tower ) ;
62590: LD_ADDR_VAR 0 10
62594: PUSH
62595: LD_VAR 0 1
62599: PPUSH
62600: CALL_OW 250
62604: ST_TO_ADDR
// y := GetY ( tower ) ;
62605: LD_ADDR_VAR 0 11
62609: PUSH
62610: LD_VAR 0 1
62614: PPUSH
62615: CALL_OW 251
62619: ST_TO_ADDR
// if not x or not y then
62620: LD_VAR 0 10
62624: NOT
62625: PUSH
62626: LD_VAR 0 11
62630: NOT
62631: OR
62632: IFFALSE 62636
// exit ;
62634: GO 63696
// weapon := 0 ;
62636: LD_ADDR_VAR 0 18
62640: PUSH
62641: LD_INT 0
62643: ST_TO_ADDR
// fac_list := [ ] ;
62644: LD_ADDR_VAR 0 17
62648: PUSH
62649: EMPTY
62650: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62651: LD_ADDR_VAR 0 6
62655: PUSH
62656: LD_VAR 0 1
62660: PPUSH
62661: CALL_OW 274
62665: PPUSH
62666: LD_VAR 0 2
62670: PPUSH
62671: CALL 60274 0 2
62675: PPUSH
62676: LD_INT 30
62678: PUSH
62679: LD_INT 3
62681: PUSH
62682: EMPTY
62683: LIST
62684: LIST
62685: PPUSH
62686: CALL_OW 72
62690: ST_TO_ADDR
// if not factories then
62691: LD_VAR 0 6
62695: NOT
62696: IFFALSE 62700
// exit ;
62698: GO 63696
// for i in factories do
62700: LD_ADDR_VAR 0 8
62704: PUSH
62705: LD_VAR 0 6
62709: PUSH
62710: FOR_IN
62711: IFFALSE 62736
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62713: LD_ADDR_VAR 0 17
62717: PUSH
62718: LD_VAR 0 17
62722: PUSH
62723: LD_VAR 0 8
62727: PPUSH
62728: CALL_OW 478
62732: UNION
62733: ST_TO_ADDR
62734: GO 62710
62736: POP
62737: POP
// if not fac_list then
62738: LD_VAR 0 17
62742: NOT
62743: IFFALSE 62747
// exit ;
62745: GO 63696
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62747: LD_ADDR_VAR 0 5
62751: PUSH
62752: LD_INT 4
62754: PUSH
62755: LD_INT 5
62757: PUSH
62758: LD_INT 9
62760: PUSH
62761: LD_INT 10
62763: PUSH
62764: LD_INT 6
62766: PUSH
62767: LD_INT 7
62769: PUSH
62770: LD_INT 11
62772: PUSH
62773: EMPTY
62774: LIST
62775: LIST
62776: LIST
62777: LIST
62778: LIST
62779: LIST
62780: LIST
62781: PUSH
62782: LD_INT 27
62784: PUSH
62785: LD_INT 28
62787: PUSH
62788: LD_INT 26
62790: PUSH
62791: LD_INT 30
62793: PUSH
62794: EMPTY
62795: LIST
62796: LIST
62797: LIST
62798: LIST
62799: PUSH
62800: LD_INT 43
62802: PUSH
62803: LD_INT 44
62805: PUSH
62806: LD_INT 46
62808: PUSH
62809: LD_INT 45
62811: PUSH
62812: LD_INT 47
62814: PUSH
62815: LD_INT 49
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: LIST
62822: LIST
62823: LIST
62824: LIST
62825: PUSH
62826: EMPTY
62827: LIST
62828: LIST
62829: LIST
62830: PUSH
62831: LD_VAR 0 12
62835: ARRAY
62836: ST_TO_ADDR
// for i in list do
62837: LD_ADDR_VAR 0 8
62841: PUSH
62842: LD_VAR 0 5
62846: PUSH
62847: FOR_IN
62848: IFFALSE 62881
// if not i in fac_list then
62850: LD_VAR 0 8
62854: PUSH
62855: LD_VAR 0 17
62859: IN
62860: NOT
62861: IFFALSE 62879
// list := list diff i ;
62863: LD_ADDR_VAR 0 5
62867: PUSH
62868: LD_VAR 0 5
62872: PUSH
62873: LD_VAR 0 8
62877: DIFF
62878: ST_TO_ADDR
62879: GO 62847
62881: POP
62882: POP
// if not list then
62883: LD_VAR 0 5
62887: NOT
62888: IFFALSE 62892
// exit ;
62890: GO 63696
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62892: LD_VAR 0 12
62896: PUSH
62897: LD_INT 3
62899: EQUAL
62900: PUSH
62901: LD_INT 49
62903: PUSH
62904: LD_VAR 0 5
62908: IN
62909: AND
62910: PUSH
62911: LD_INT 31
62913: PPUSH
62914: LD_VAR 0 16
62918: PPUSH
62919: CALL_OW 321
62923: PUSH
62924: LD_INT 2
62926: EQUAL
62927: AND
62928: IFFALSE 62988
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62930: LD_INT 22
62932: PUSH
62933: LD_VAR 0 16
62937: PUSH
62938: EMPTY
62939: LIST
62940: LIST
62941: PUSH
62942: LD_INT 35
62944: PUSH
62945: LD_INT 49
62947: PUSH
62948: EMPTY
62949: LIST
62950: LIST
62951: PUSH
62952: LD_INT 91
62954: PUSH
62955: LD_VAR 0 1
62959: PUSH
62960: LD_INT 10
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: LIST
62967: PUSH
62968: EMPTY
62969: LIST
62970: LIST
62971: LIST
62972: PPUSH
62973: CALL_OW 69
62977: NOT
62978: IFFALSE 62988
// weapon := ru_time_lapser ;
62980: LD_ADDR_VAR 0 18
62984: PUSH
62985: LD_INT 49
62987: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62988: LD_VAR 0 12
62992: PUSH
62993: LD_INT 1
62995: PUSH
62996: LD_INT 2
62998: PUSH
62999: EMPTY
63000: LIST
63001: LIST
63002: IN
63003: PUSH
63004: LD_INT 11
63006: PUSH
63007: LD_VAR 0 5
63011: IN
63012: PUSH
63013: LD_INT 30
63015: PUSH
63016: LD_VAR 0 5
63020: IN
63021: OR
63022: AND
63023: PUSH
63024: LD_INT 6
63026: PPUSH
63027: LD_VAR 0 16
63031: PPUSH
63032: CALL_OW 321
63036: PUSH
63037: LD_INT 2
63039: EQUAL
63040: AND
63041: IFFALSE 63206
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63043: LD_INT 22
63045: PUSH
63046: LD_VAR 0 16
63050: PUSH
63051: EMPTY
63052: LIST
63053: LIST
63054: PUSH
63055: LD_INT 2
63057: PUSH
63058: LD_INT 35
63060: PUSH
63061: LD_INT 11
63063: PUSH
63064: EMPTY
63065: LIST
63066: LIST
63067: PUSH
63068: LD_INT 35
63070: PUSH
63071: LD_INT 30
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: PUSH
63078: EMPTY
63079: LIST
63080: LIST
63081: LIST
63082: PUSH
63083: LD_INT 91
63085: PUSH
63086: LD_VAR 0 1
63090: PUSH
63091: LD_INT 18
63093: PUSH
63094: EMPTY
63095: LIST
63096: LIST
63097: LIST
63098: PUSH
63099: EMPTY
63100: LIST
63101: LIST
63102: LIST
63103: PPUSH
63104: CALL_OW 69
63108: NOT
63109: PUSH
63110: LD_INT 22
63112: PUSH
63113: LD_VAR 0 16
63117: PUSH
63118: EMPTY
63119: LIST
63120: LIST
63121: PUSH
63122: LD_INT 2
63124: PUSH
63125: LD_INT 30
63127: PUSH
63128: LD_INT 32
63130: PUSH
63131: EMPTY
63132: LIST
63133: LIST
63134: PUSH
63135: LD_INT 30
63137: PUSH
63138: LD_INT 33
63140: PUSH
63141: EMPTY
63142: LIST
63143: LIST
63144: PUSH
63145: EMPTY
63146: LIST
63147: LIST
63148: LIST
63149: PUSH
63150: LD_INT 91
63152: PUSH
63153: LD_VAR 0 1
63157: PUSH
63158: LD_INT 12
63160: PUSH
63161: EMPTY
63162: LIST
63163: LIST
63164: LIST
63165: PUSH
63166: EMPTY
63167: LIST
63168: LIST
63169: LIST
63170: PUSH
63171: EMPTY
63172: LIST
63173: PPUSH
63174: CALL_OW 69
63178: PUSH
63179: LD_INT 2
63181: GREATER
63182: AND
63183: IFFALSE 63206
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63185: LD_ADDR_VAR 0 18
63189: PUSH
63190: LD_INT 11
63192: PUSH
63193: LD_INT 30
63195: PUSH
63196: EMPTY
63197: LIST
63198: LIST
63199: PUSH
63200: LD_VAR 0 12
63204: ARRAY
63205: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63206: LD_VAR 0 18
63210: NOT
63211: PUSH
63212: LD_INT 40
63214: PPUSH
63215: LD_VAR 0 16
63219: PPUSH
63220: CALL_OW 321
63224: PUSH
63225: LD_INT 2
63227: EQUAL
63228: AND
63229: PUSH
63230: LD_INT 7
63232: PUSH
63233: LD_VAR 0 5
63237: IN
63238: PUSH
63239: LD_INT 28
63241: PUSH
63242: LD_VAR 0 5
63246: IN
63247: OR
63248: PUSH
63249: LD_INT 45
63251: PUSH
63252: LD_VAR 0 5
63256: IN
63257: OR
63258: AND
63259: IFFALSE 63513
// begin hex := GetHexInfo ( x , y ) ;
63261: LD_ADDR_VAR 0 4
63265: PUSH
63266: LD_VAR 0 10
63270: PPUSH
63271: LD_VAR 0 11
63275: PPUSH
63276: CALL_OW 546
63280: ST_TO_ADDR
// if hex [ 1 ] then
63281: LD_VAR 0 4
63285: PUSH
63286: LD_INT 1
63288: ARRAY
63289: IFFALSE 63293
// exit ;
63291: GO 63696
// height := hex [ 2 ] ;
63293: LD_ADDR_VAR 0 15
63297: PUSH
63298: LD_VAR 0 4
63302: PUSH
63303: LD_INT 2
63305: ARRAY
63306: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63307: LD_ADDR_VAR 0 14
63311: PUSH
63312: LD_INT 0
63314: PUSH
63315: LD_INT 2
63317: PUSH
63318: LD_INT 3
63320: PUSH
63321: LD_INT 5
63323: PUSH
63324: EMPTY
63325: LIST
63326: LIST
63327: LIST
63328: LIST
63329: ST_TO_ADDR
// for i in tmp do
63330: LD_ADDR_VAR 0 8
63334: PUSH
63335: LD_VAR 0 14
63339: PUSH
63340: FOR_IN
63341: IFFALSE 63511
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63343: LD_ADDR_VAR 0 9
63347: PUSH
63348: LD_VAR 0 10
63352: PPUSH
63353: LD_VAR 0 8
63357: PPUSH
63358: LD_INT 5
63360: PPUSH
63361: CALL_OW 272
63365: PUSH
63366: LD_VAR 0 11
63370: PPUSH
63371: LD_VAR 0 8
63375: PPUSH
63376: LD_INT 5
63378: PPUSH
63379: CALL_OW 273
63383: PUSH
63384: EMPTY
63385: LIST
63386: LIST
63387: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63388: LD_VAR 0 9
63392: PUSH
63393: LD_INT 1
63395: ARRAY
63396: PPUSH
63397: LD_VAR 0 9
63401: PUSH
63402: LD_INT 2
63404: ARRAY
63405: PPUSH
63406: CALL_OW 488
63410: IFFALSE 63509
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63412: LD_ADDR_VAR 0 4
63416: PUSH
63417: LD_VAR 0 9
63421: PUSH
63422: LD_INT 1
63424: ARRAY
63425: PPUSH
63426: LD_VAR 0 9
63430: PUSH
63431: LD_INT 2
63433: ARRAY
63434: PPUSH
63435: CALL_OW 546
63439: ST_TO_ADDR
// if hex [ 1 ] then
63440: LD_VAR 0 4
63444: PUSH
63445: LD_INT 1
63447: ARRAY
63448: IFFALSE 63452
// continue ;
63450: GO 63340
// h := hex [ 2 ] ;
63452: LD_ADDR_VAR 0 13
63456: PUSH
63457: LD_VAR 0 4
63461: PUSH
63462: LD_INT 2
63464: ARRAY
63465: ST_TO_ADDR
// if h + 7 < height then
63466: LD_VAR 0 13
63470: PUSH
63471: LD_INT 7
63473: PLUS
63474: PUSH
63475: LD_VAR 0 15
63479: LESS
63480: IFFALSE 63509
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63482: LD_ADDR_VAR 0 18
63486: PUSH
63487: LD_INT 7
63489: PUSH
63490: LD_INT 28
63492: PUSH
63493: LD_INT 45
63495: PUSH
63496: EMPTY
63497: LIST
63498: LIST
63499: LIST
63500: PUSH
63501: LD_VAR 0 12
63505: ARRAY
63506: ST_TO_ADDR
// break ;
63507: GO 63511
// end ; end ; end ;
63509: GO 63340
63511: POP
63512: POP
// end ; if not weapon then
63513: LD_VAR 0 18
63517: NOT
63518: IFFALSE 63578
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63520: LD_ADDR_VAR 0 5
63524: PUSH
63525: LD_VAR 0 5
63529: PUSH
63530: LD_INT 11
63532: PUSH
63533: LD_INT 30
63535: PUSH
63536: LD_INT 49
63538: PUSH
63539: EMPTY
63540: LIST
63541: LIST
63542: LIST
63543: DIFF
63544: ST_TO_ADDR
// if not list then
63545: LD_VAR 0 5
63549: NOT
63550: IFFALSE 63554
// exit ;
63552: GO 63696
// weapon := list [ rand ( 1 , list ) ] ;
63554: LD_ADDR_VAR 0 18
63558: PUSH
63559: LD_VAR 0 5
63563: PUSH
63564: LD_INT 1
63566: PPUSH
63567: LD_VAR 0 5
63571: PPUSH
63572: CALL_OW 12
63576: ARRAY
63577: ST_TO_ADDR
// end ; if weapon then
63578: LD_VAR 0 18
63582: IFFALSE 63696
// begin tmp := CostOfWeapon ( weapon ) ;
63584: LD_ADDR_VAR 0 14
63588: PUSH
63589: LD_VAR 0 18
63593: PPUSH
63594: CALL_OW 451
63598: ST_TO_ADDR
// j := GetBase ( tower ) ;
63599: LD_ADDR_VAR 0 9
63603: PUSH
63604: LD_VAR 0 1
63608: PPUSH
63609: CALL_OW 274
63613: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63614: LD_VAR 0 9
63618: PPUSH
63619: LD_INT 1
63621: PPUSH
63622: CALL_OW 275
63626: PUSH
63627: LD_VAR 0 14
63631: PUSH
63632: LD_INT 1
63634: ARRAY
63635: GREATEREQUAL
63636: PUSH
63637: LD_VAR 0 9
63641: PPUSH
63642: LD_INT 2
63644: PPUSH
63645: CALL_OW 275
63649: PUSH
63650: LD_VAR 0 14
63654: PUSH
63655: LD_INT 2
63657: ARRAY
63658: GREATEREQUAL
63659: AND
63660: PUSH
63661: LD_VAR 0 9
63665: PPUSH
63666: LD_INT 3
63668: PPUSH
63669: CALL_OW 275
63673: PUSH
63674: LD_VAR 0 14
63678: PUSH
63679: LD_INT 3
63681: ARRAY
63682: GREATEREQUAL
63683: AND
63684: IFFALSE 63696
// result := weapon ;
63686: LD_ADDR_VAR 0 3
63690: PUSH
63691: LD_VAR 0 18
63695: ST_TO_ADDR
// end ; end ;
63696: LD_VAR 0 3
63700: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63701: LD_INT 0
63703: PPUSH
63704: PPUSH
// result := true ;
63705: LD_ADDR_VAR 0 3
63709: PUSH
63710: LD_INT 1
63712: ST_TO_ADDR
// if array1 = array2 then
63713: LD_VAR 0 1
63717: PUSH
63718: LD_VAR 0 2
63722: EQUAL
63723: IFFALSE 63783
// begin for i = 1 to array1 do
63725: LD_ADDR_VAR 0 4
63729: PUSH
63730: DOUBLE
63731: LD_INT 1
63733: DEC
63734: ST_TO_ADDR
63735: LD_VAR 0 1
63739: PUSH
63740: FOR_TO
63741: IFFALSE 63779
// if array1 [ i ] <> array2 [ i ] then
63743: LD_VAR 0 1
63747: PUSH
63748: LD_VAR 0 4
63752: ARRAY
63753: PUSH
63754: LD_VAR 0 2
63758: PUSH
63759: LD_VAR 0 4
63763: ARRAY
63764: NONEQUAL
63765: IFFALSE 63777
// begin result := false ;
63767: LD_ADDR_VAR 0 3
63771: PUSH
63772: LD_INT 0
63774: ST_TO_ADDR
// break ;
63775: GO 63779
// end ;
63777: GO 63740
63779: POP
63780: POP
// end else
63781: GO 63791
// result := false ;
63783: LD_ADDR_VAR 0 3
63787: PUSH
63788: LD_INT 0
63790: ST_TO_ADDR
// end ;
63791: LD_VAR 0 3
63795: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63796: LD_INT 0
63798: PPUSH
63799: PPUSH
63800: PPUSH
// pom := GetBase ( fac ) ;
63801: LD_ADDR_VAR 0 5
63805: PUSH
63806: LD_VAR 0 1
63810: PPUSH
63811: CALL_OW 274
63815: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63816: LD_ADDR_VAR 0 4
63820: PUSH
63821: LD_VAR 0 2
63825: PUSH
63826: LD_INT 1
63828: ARRAY
63829: PPUSH
63830: LD_VAR 0 2
63834: PUSH
63835: LD_INT 2
63837: ARRAY
63838: PPUSH
63839: LD_VAR 0 2
63843: PUSH
63844: LD_INT 3
63846: ARRAY
63847: PPUSH
63848: LD_VAR 0 2
63852: PUSH
63853: LD_INT 4
63855: ARRAY
63856: PPUSH
63857: CALL_OW 449
63861: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63862: LD_ADDR_VAR 0 3
63866: PUSH
63867: LD_VAR 0 5
63871: PPUSH
63872: LD_INT 1
63874: PPUSH
63875: CALL_OW 275
63879: PUSH
63880: LD_VAR 0 4
63884: PUSH
63885: LD_INT 1
63887: ARRAY
63888: GREATEREQUAL
63889: PUSH
63890: LD_VAR 0 5
63894: PPUSH
63895: LD_INT 2
63897: PPUSH
63898: CALL_OW 275
63902: PUSH
63903: LD_VAR 0 4
63907: PUSH
63908: LD_INT 2
63910: ARRAY
63911: GREATEREQUAL
63912: AND
63913: PUSH
63914: LD_VAR 0 5
63918: PPUSH
63919: LD_INT 3
63921: PPUSH
63922: CALL_OW 275
63926: PUSH
63927: LD_VAR 0 4
63931: PUSH
63932: LD_INT 3
63934: ARRAY
63935: GREATEREQUAL
63936: AND
63937: ST_TO_ADDR
// end ;
63938: LD_VAR 0 3
63942: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63943: LD_INT 0
63945: PPUSH
63946: PPUSH
63947: PPUSH
63948: PPUSH
// pom := GetBase ( building ) ;
63949: LD_ADDR_VAR 0 3
63953: PUSH
63954: LD_VAR 0 1
63958: PPUSH
63959: CALL_OW 274
63963: ST_TO_ADDR
// if not pom then
63964: LD_VAR 0 3
63968: NOT
63969: IFFALSE 63973
// exit ;
63971: GO 64143
// btype := GetBType ( building ) ;
63973: LD_ADDR_VAR 0 5
63977: PUSH
63978: LD_VAR 0 1
63982: PPUSH
63983: CALL_OW 266
63987: ST_TO_ADDR
// if btype = b_armoury then
63988: LD_VAR 0 5
63992: PUSH
63993: LD_INT 4
63995: EQUAL
63996: IFFALSE 64006
// btype := b_barracks ;
63998: LD_ADDR_VAR 0 5
64002: PUSH
64003: LD_INT 5
64005: ST_TO_ADDR
// if btype = b_depot then
64006: LD_VAR 0 5
64010: PUSH
64011: LD_INT 0
64013: EQUAL
64014: IFFALSE 64024
// btype := b_warehouse ;
64016: LD_ADDR_VAR 0 5
64020: PUSH
64021: LD_INT 1
64023: ST_TO_ADDR
// if btype = b_workshop then
64024: LD_VAR 0 5
64028: PUSH
64029: LD_INT 2
64031: EQUAL
64032: IFFALSE 64042
// btype := b_factory ;
64034: LD_ADDR_VAR 0 5
64038: PUSH
64039: LD_INT 3
64041: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64042: LD_ADDR_VAR 0 4
64046: PUSH
64047: LD_VAR 0 5
64051: PPUSH
64052: LD_VAR 0 1
64056: PPUSH
64057: CALL_OW 248
64061: PPUSH
64062: CALL_OW 450
64066: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64067: LD_ADDR_VAR 0 2
64071: PUSH
64072: LD_VAR 0 3
64076: PPUSH
64077: LD_INT 1
64079: PPUSH
64080: CALL_OW 275
64084: PUSH
64085: LD_VAR 0 4
64089: PUSH
64090: LD_INT 1
64092: ARRAY
64093: GREATEREQUAL
64094: PUSH
64095: LD_VAR 0 3
64099: PPUSH
64100: LD_INT 2
64102: PPUSH
64103: CALL_OW 275
64107: PUSH
64108: LD_VAR 0 4
64112: PUSH
64113: LD_INT 2
64115: ARRAY
64116: GREATEREQUAL
64117: AND
64118: PUSH
64119: LD_VAR 0 3
64123: PPUSH
64124: LD_INT 3
64126: PPUSH
64127: CALL_OW 275
64131: PUSH
64132: LD_VAR 0 4
64136: PUSH
64137: LD_INT 3
64139: ARRAY
64140: GREATEREQUAL
64141: AND
64142: ST_TO_ADDR
// end ;
64143: LD_VAR 0 2
64147: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64148: LD_INT 0
64150: PPUSH
64151: PPUSH
64152: PPUSH
// pom := GetBase ( building ) ;
64153: LD_ADDR_VAR 0 4
64157: PUSH
64158: LD_VAR 0 1
64162: PPUSH
64163: CALL_OW 274
64167: ST_TO_ADDR
// if not pom then
64168: LD_VAR 0 4
64172: NOT
64173: IFFALSE 64177
// exit ;
64175: GO 64278
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64177: LD_ADDR_VAR 0 5
64181: PUSH
64182: LD_VAR 0 2
64186: PPUSH
64187: LD_VAR 0 1
64191: PPUSH
64192: CALL_OW 248
64196: PPUSH
64197: CALL_OW 450
64201: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64202: LD_ADDR_VAR 0 3
64206: PUSH
64207: LD_VAR 0 4
64211: PPUSH
64212: LD_INT 1
64214: PPUSH
64215: CALL_OW 275
64219: PUSH
64220: LD_VAR 0 5
64224: PUSH
64225: LD_INT 1
64227: ARRAY
64228: GREATEREQUAL
64229: PUSH
64230: LD_VAR 0 4
64234: PPUSH
64235: LD_INT 2
64237: PPUSH
64238: CALL_OW 275
64242: PUSH
64243: LD_VAR 0 5
64247: PUSH
64248: LD_INT 2
64250: ARRAY
64251: GREATEREQUAL
64252: AND
64253: PUSH
64254: LD_VAR 0 4
64258: PPUSH
64259: LD_INT 3
64261: PPUSH
64262: CALL_OW 275
64266: PUSH
64267: LD_VAR 0 5
64271: PUSH
64272: LD_INT 3
64274: ARRAY
64275: GREATEREQUAL
64276: AND
64277: ST_TO_ADDR
// end ;
64278: LD_VAR 0 3
64282: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
64283: LD_INT 0
64285: PPUSH
64286: PPUSH
64287: PPUSH
64288: PPUSH
64289: PPUSH
64290: PPUSH
64291: PPUSH
64292: PPUSH
64293: PPUSH
64294: PPUSH
// result := false ;
64295: LD_ADDR_VAR 0 6
64299: PUSH
64300: LD_INT 0
64302: ST_TO_ADDR
// if not base or not btype or not x or not y then
64303: LD_VAR 0 1
64307: NOT
64308: PUSH
64309: LD_VAR 0 2
64313: NOT
64314: OR
64315: PUSH
64316: LD_VAR 0 3
64320: NOT
64321: OR
64322: PUSH
64323: LD_VAR 0 4
64327: NOT
64328: OR
64329: IFFALSE 64333
// exit ;
64331: GO 64942
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
64333: LD_ADDR_VAR 0 12
64337: PUSH
64338: LD_VAR 0 2
64342: PPUSH
64343: LD_VAR 0 3
64347: PPUSH
64348: LD_VAR 0 4
64352: PPUSH
64353: LD_VAR 0 5
64357: PPUSH
64358: LD_VAR 0 1
64362: PUSH
64363: LD_INT 1
64365: ARRAY
64366: PPUSH
64367: CALL_OW 248
64371: PPUSH
64372: LD_INT 0
64374: PPUSH
64375: CALL 65779 0 6
64379: ST_TO_ADDR
// if not hexes then
64380: LD_VAR 0 12
64384: NOT
64385: IFFALSE 64389
// exit ;
64387: GO 64942
// for i = 1 to hexes do
64389: LD_ADDR_VAR 0 7
64393: PUSH
64394: DOUBLE
64395: LD_INT 1
64397: DEC
64398: ST_TO_ADDR
64399: LD_VAR 0 12
64403: PUSH
64404: FOR_TO
64405: IFFALSE 64940
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64407: LD_ADDR_VAR 0 11
64411: PUSH
64412: LD_VAR 0 12
64416: PUSH
64417: LD_VAR 0 7
64421: ARRAY
64422: PUSH
64423: LD_INT 1
64425: ARRAY
64426: PPUSH
64427: LD_VAR 0 12
64431: PUSH
64432: LD_VAR 0 7
64436: ARRAY
64437: PUSH
64438: LD_INT 2
64440: ARRAY
64441: PPUSH
64442: CALL_OW 428
64446: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64447: LD_VAR 0 12
64451: PUSH
64452: LD_VAR 0 7
64456: ARRAY
64457: PUSH
64458: LD_INT 1
64460: ARRAY
64461: PPUSH
64462: LD_VAR 0 12
64466: PUSH
64467: LD_VAR 0 7
64471: ARRAY
64472: PUSH
64473: LD_INT 2
64475: ARRAY
64476: PPUSH
64477: CALL_OW 351
64481: PUSH
64482: LD_VAR 0 12
64486: PUSH
64487: LD_VAR 0 7
64491: ARRAY
64492: PUSH
64493: LD_INT 1
64495: ARRAY
64496: PPUSH
64497: LD_VAR 0 12
64501: PUSH
64502: LD_VAR 0 7
64506: ARRAY
64507: PUSH
64508: LD_INT 2
64510: ARRAY
64511: PPUSH
64512: CALL_OW 488
64516: NOT
64517: OR
64518: PUSH
64519: LD_VAR 0 11
64523: PPUSH
64524: CALL_OW 247
64528: PUSH
64529: LD_INT 3
64531: EQUAL
64532: OR
64533: IFFALSE 64539
// exit ;
64535: POP
64536: POP
64537: GO 64942
// if not tmp or not tmp in base then
64539: LD_VAR 0 11
64543: NOT
64544: PUSH
64545: LD_VAR 0 11
64549: PUSH
64550: LD_VAR 0 1
64554: IN
64555: NOT
64556: OR
64557: IFFALSE 64561
// continue ;
64559: GO 64404
// result := true ;
64561: LD_ADDR_VAR 0 6
64565: PUSH
64566: LD_INT 1
64568: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64569: LD_ADDR_VAR 0 15
64573: PUSH
64574: LD_VAR 0 1
64578: PPUSH
64579: LD_INT 22
64581: PUSH
64582: LD_VAR 0 11
64586: PPUSH
64587: CALL_OW 255
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: PUSH
64596: LD_INT 2
64598: PUSH
64599: LD_INT 30
64601: PUSH
64602: LD_INT 0
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: PUSH
64609: LD_INT 30
64611: PUSH
64612: LD_INT 1
64614: PUSH
64615: EMPTY
64616: LIST
64617: LIST
64618: PUSH
64619: EMPTY
64620: LIST
64621: LIST
64622: LIST
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: PPUSH
64628: CALL_OW 72
64632: ST_TO_ADDR
// if dep then
64633: LD_VAR 0 15
64637: IFFALSE 64773
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64639: LD_ADDR_VAR 0 14
64643: PUSH
64644: LD_VAR 0 15
64648: PUSH
64649: LD_INT 1
64651: ARRAY
64652: PPUSH
64653: CALL_OW 250
64657: PPUSH
64658: LD_VAR 0 15
64662: PUSH
64663: LD_INT 1
64665: ARRAY
64666: PPUSH
64667: CALL_OW 254
64671: PPUSH
64672: LD_INT 5
64674: PPUSH
64675: CALL_OW 272
64679: PUSH
64680: LD_VAR 0 15
64684: PUSH
64685: LD_INT 1
64687: ARRAY
64688: PPUSH
64689: CALL_OW 251
64693: PPUSH
64694: LD_VAR 0 15
64698: PUSH
64699: LD_INT 1
64701: ARRAY
64702: PPUSH
64703: CALL_OW 254
64707: PPUSH
64708: LD_INT 5
64710: PPUSH
64711: CALL_OW 273
64715: PUSH
64716: EMPTY
64717: LIST
64718: LIST
64719: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64720: LD_VAR 0 14
64724: PUSH
64725: LD_INT 1
64727: ARRAY
64728: PPUSH
64729: LD_VAR 0 14
64733: PUSH
64734: LD_INT 2
64736: ARRAY
64737: PPUSH
64738: CALL_OW 488
64742: IFFALSE 64773
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64744: LD_VAR 0 11
64748: PPUSH
64749: LD_VAR 0 14
64753: PUSH
64754: LD_INT 1
64756: ARRAY
64757: PPUSH
64758: LD_VAR 0 14
64762: PUSH
64763: LD_INT 2
64765: ARRAY
64766: PPUSH
64767: CALL_OW 111
// continue ;
64771: GO 64404
// end ; end ; r := GetDir ( tmp ) ;
64773: LD_ADDR_VAR 0 13
64777: PUSH
64778: LD_VAR 0 11
64782: PPUSH
64783: CALL_OW 254
64787: ST_TO_ADDR
// if r = 5 then
64788: LD_VAR 0 13
64792: PUSH
64793: LD_INT 5
64795: EQUAL
64796: IFFALSE 64806
// r := 0 ;
64798: LD_ADDR_VAR 0 13
64802: PUSH
64803: LD_INT 0
64805: ST_TO_ADDR
// for j = r to 5 do
64806: LD_ADDR_VAR 0 8
64810: PUSH
64811: DOUBLE
64812: LD_VAR 0 13
64816: DEC
64817: ST_TO_ADDR
64818: LD_INT 5
64820: PUSH
64821: FOR_TO
64822: IFFALSE 64936
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64824: LD_ADDR_VAR 0 9
64828: PUSH
64829: LD_VAR 0 11
64833: PPUSH
64834: CALL_OW 250
64838: PPUSH
64839: LD_VAR 0 8
64843: PPUSH
64844: LD_INT 2
64846: PPUSH
64847: CALL_OW 272
64851: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64852: LD_ADDR_VAR 0 10
64856: PUSH
64857: LD_VAR 0 11
64861: PPUSH
64862: CALL_OW 251
64866: PPUSH
64867: LD_VAR 0 8
64871: PPUSH
64872: LD_INT 2
64874: PPUSH
64875: CALL_OW 273
64879: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64880: LD_VAR 0 9
64884: PPUSH
64885: LD_VAR 0 10
64889: PPUSH
64890: CALL_OW 488
64894: PUSH
64895: LD_VAR 0 9
64899: PPUSH
64900: LD_VAR 0 10
64904: PPUSH
64905: CALL_OW 428
64909: NOT
64910: AND
64911: IFFALSE 64934
// begin ComMoveXY ( tmp , _x , _y ) ;
64913: LD_VAR 0 11
64917: PPUSH
64918: LD_VAR 0 9
64922: PPUSH
64923: LD_VAR 0 10
64927: PPUSH
64928: CALL_OW 111
// break ;
64932: GO 64936
// end ; end ;
64934: GO 64821
64936: POP
64937: POP
// end ;
64938: GO 64404
64940: POP
64941: POP
// end ;
64942: LD_VAR 0 6
64946: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
64947: LD_INT 0
64949: PPUSH
64950: PPUSH
64951: PPUSH
64952: PPUSH
64953: PPUSH
64954: PPUSH
64955: PPUSH
64956: PPUSH
64957: PPUSH
64958: PPUSH
// result := false ;
64959: LD_ADDR_VAR 0 6
64963: PUSH
64964: LD_INT 0
64966: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64967: LD_VAR 0 1
64971: NOT
64972: PUSH
64973: LD_VAR 0 1
64977: PPUSH
64978: CALL_OW 266
64982: PUSH
64983: LD_INT 0
64985: PUSH
64986: LD_INT 1
64988: PUSH
64989: EMPTY
64990: LIST
64991: LIST
64992: IN
64993: NOT
64994: OR
64995: PUSH
64996: LD_VAR 0 2
65000: NOT
65001: OR
65002: PUSH
65003: LD_VAR 0 5
65007: PUSH
65008: LD_INT 0
65010: PUSH
65011: LD_INT 1
65013: PUSH
65014: LD_INT 2
65016: PUSH
65017: LD_INT 3
65019: PUSH
65020: LD_INT 4
65022: PUSH
65023: LD_INT 5
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: LIST
65030: LIST
65031: LIST
65032: LIST
65033: IN
65034: NOT
65035: OR
65036: PUSH
65037: LD_VAR 0 3
65041: PPUSH
65042: LD_VAR 0 4
65046: PPUSH
65047: CALL_OW 488
65051: NOT
65052: OR
65053: IFFALSE 65057
// exit ;
65055: GO 65774
// pom := GetBase ( depot ) ;
65057: LD_ADDR_VAR 0 10
65061: PUSH
65062: LD_VAR 0 1
65066: PPUSH
65067: CALL_OW 274
65071: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65072: LD_ADDR_VAR 0 11
65076: PUSH
65077: LD_VAR 0 2
65081: PPUSH
65082: LD_VAR 0 1
65086: PPUSH
65087: CALL_OW 248
65091: PPUSH
65092: CALL_OW 450
65096: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65097: LD_VAR 0 10
65101: PPUSH
65102: LD_INT 1
65104: PPUSH
65105: CALL_OW 275
65109: PUSH
65110: LD_VAR 0 11
65114: PUSH
65115: LD_INT 1
65117: ARRAY
65118: GREATEREQUAL
65119: PUSH
65120: LD_VAR 0 10
65124: PPUSH
65125: LD_INT 2
65127: PPUSH
65128: CALL_OW 275
65132: PUSH
65133: LD_VAR 0 11
65137: PUSH
65138: LD_INT 2
65140: ARRAY
65141: GREATEREQUAL
65142: AND
65143: PUSH
65144: LD_VAR 0 10
65148: PPUSH
65149: LD_INT 3
65151: PPUSH
65152: CALL_OW 275
65156: PUSH
65157: LD_VAR 0 11
65161: PUSH
65162: LD_INT 3
65164: ARRAY
65165: GREATEREQUAL
65166: AND
65167: NOT
65168: IFFALSE 65172
// exit ;
65170: GO 65774
// if GetBType ( depot ) = b_depot then
65172: LD_VAR 0 1
65176: PPUSH
65177: CALL_OW 266
65181: PUSH
65182: LD_INT 0
65184: EQUAL
65185: IFFALSE 65197
// dist := 28 else
65187: LD_ADDR_VAR 0 14
65191: PUSH
65192: LD_INT 28
65194: ST_TO_ADDR
65195: GO 65205
// dist := 36 ;
65197: LD_ADDR_VAR 0 14
65201: PUSH
65202: LD_INT 36
65204: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65205: LD_VAR 0 1
65209: PPUSH
65210: LD_VAR 0 3
65214: PPUSH
65215: LD_VAR 0 4
65219: PPUSH
65220: CALL_OW 297
65224: PUSH
65225: LD_VAR 0 14
65229: GREATER
65230: IFFALSE 65234
// exit ;
65232: GO 65774
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65234: LD_ADDR_VAR 0 12
65238: PUSH
65239: LD_VAR 0 2
65243: PPUSH
65244: LD_VAR 0 3
65248: PPUSH
65249: LD_VAR 0 4
65253: PPUSH
65254: LD_VAR 0 5
65258: PPUSH
65259: LD_VAR 0 1
65263: PPUSH
65264: CALL_OW 248
65268: PPUSH
65269: LD_INT 0
65271: PPUSH
65272: CALL 65779 0 6
65276: ST_TO_ADDR
// if not hexes then
65277: LD_VAR 0 12
65281: NOT
65282: IFFALSE 65286
// exit ;
65284: GO 65774
// hex := GetHexInfo ( x , y ) ;
65286: LD_ADDR_VAR 0 15
65290: PUSH
65291: LD_VAR 0 3
65295: PPUSH
65296: LD_VAR 0 4
65300: PPUSH
65301: CALL_OW 546
65305: ST_TO_ADDR
// if hex [ 1 ] then
65306: LD_VAR 0 15
65310: PUSH
65311: LD_INT 1
65313: ARRAY
65314: IFFALSE 65318
// exit ;
65316: GO 65774
// height := hex [ 2 ] ;
65318: LD_ADDR_VAR 0 13
65322: PUSH
65323: LD_VAR 0 15
65327: PUSH
65328: LD_INT 2
65330: ARRAY
65331: ST_TO_ADDR
// for i = 1 to hexes do
65332: LD_ADDR_VAR 0 7
65336: PUSH
65337: DOUBLE
65338: LD_INT 1
65340: DEC
65341: ST_TO_ADDR
65342: LD_VAR 0 12
65346: PUSH
65347: FOR_TO
65348: IFFALSE 65678
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65350: LD_VAR 0 12
65354: PUSH
65355: LD_VAR 0 7
65359: ARRAY
65360: PUSH
65361: LD_INT 1
65363: ARRAY
65364: PPUSH
65365: LD_VAR 0 12
65369: PUSH
65370: LD_VAR 0 7
65374: ARRAY
65375: PUSH
65376: LD_INT 2
65378: ARRAY
65379: PPUSH
65380: CALL_OW 488
65384: NOT
65385: PUSH
65386: LD_VAR 0 12
65390: PUSH
65391: LD_VAR 0 7
65395: ARRAY
65396: PUSH
65397: LD_INT 1
65399: ARRAY
65400: PPUSH
65401: LD_VAR 0 12
65405: PUSH
65406: LD_VAR 0 7
65410: ARRAY
65411: PUSH
65412: LD_INT 2
65414: ARRAY
65415: PPUSH
65416: CALL_OW 428
65420: PUSH
65421: LD_INT 0
65423: GREATER
65424: OR
65425: PUSH
65426: LD_VAR 0 12
65430: PUSH
65431: LD_VAR 0 7
65435: ARRAY
65436: PUSH
65437: LD_INT 1
65439: ARRAY
65440: PPUSH
65441: LD_VAR 0 12
65445: PUSH
65446: LD_VAR 0 7
65450: ARRAY
65451: PUSH
65452: LD_INT 2
65454: ARRAY
65455: PPUSH
65456: CALL_OW 351
65460: OR
65461: IFFALSE 65467
// exit ;
65463: POP
65464: POP
65465: GO 65774
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65467: LD_ADDR_VAR 0 8
65471: PUSH
65472: LD_VAR 0 12
65476: PUSH
65477: LD_VAR 0 7
65481: ARRAY
65482: PUSH
65483: LD_INT 1
65485: ARRAY
65486: PPUSH
65487: LD_VAR 0 12
65491: PUSH
65492: LD_VAR 0 7
65496: ARRAY
65497: PUSH
65498: LD_INT 2
65500: ARRAY
65501: PPUSH
65502: CALL_OW 546
65506: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65507: LD_VAR 0 8
65511: PUSH
65512: LD_INT 1
65514: ARRAY
65515: PUSH
65516: LD_VAR 0 8
65520: PUSH
65521: LD_INT 2
65523: ARRAY
65524: PUSH
65525: LD_VAR 0 13
65529: PUSH
65530: LD_INT 2
65532: PLUS
65533: GREATER
65534: OR
65535: PUSH
65536: LD_VAR 0 8
65540: PUSH
65541: LD_INT 2
65543: ARRAY
65544: PUSH
65545: LD_VAR 0 13
65549: PUSH
65550: LD_INT 2
65552: MINUS
65553: LESS
65554: OR
65555: PUSH
65556: LD_VAR 0 8
65560: PUSH
65561: LD_INT 3
65563: ARRAY
65564: PUSH
65565: LD_INT 0
65567: PUSH
65568: LD_INT 8
65570: PUSH
65571: LD_INT 9
65573: PUSH
65574: LD_INT 10
65576: PUSH
65577: LD_INT 11
65579: PUSH
65580: LD_INT 12
65582: PUSH
65583: LD_INT 13
65585: PUSH
65586: LD_INT 16
65588: PUSH
65589: LD_INT 17
65591: PUSH
65592: LD_INT 18
65594: PUSH
65595: LD_INT 19
65597: PUSH
65598: LD_INT 20
65600: PUSH
65601: LD_INT 21
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: IN
65619: NOT
65620: OR
65621: PUSH
65622: LD_VAR 0 8
65626: PUSH
65627: LD_INT 5
65629: ARRAY
65630: NOT
65631: OR
65632: PUSH
65633: LD_VAR 0 8
65637: PUSH
65638: LD_INT 6
65640: ARRAY
65641: PUSH
65642: LD_INT 1
65644: PUSH
65645: LD_INT 2
65647: PUSH
65648: LD_INT 7
65650: PUSH
65651: LD_INT 9
65653: PUSH
65654: LD_INT 10
65656: PUSH
65657: LD_INT 11
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: LIST
65664: LIST
65665: LIST
65666: LIST
65667: IN
65668: NOT
65669: OR
65670: IFFALSE 65676
// exit ;
65672: POP
65673: POP
65674: GO 65774
// end ;
65676: GO 65347
65678: POP
65679: POP
// side := GetSide ( depot ) ;
65680: LD_ADDR_VAR 0 9
65684: PUSH
65685: LD_VAR 0 1
65689: PPUSH
65690: CALL_OW 255
65694: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65695: LD_VAR 0 9
65699: PPUSH
65700: LD_VAR 0 3
65704: PPUSH
65705: LD_VAR 0 4
65709: PPUSH
65710: LD_INT 20
65712: PPUSH
65713: CALL 58428 0 4
65717: PUSH
65718: LD_INT 4
65720: ARRAY
65721: IFFALSE 65725
// exit ;
65723: GO 65774
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65725: LD_VAR 0 2
65729: PUSH
65730: LD_INT 29
65732: PUSH
65733: LD_INT 30
65735: PUSH
65736: EMPTY
65737: LIST
65738: LIST
65739: IN
65740: PUSH
65741: LD_VAR 0 3
65745: PPUSH
65746: LD_VAR 0 4
65750: PPUSH
65751: LD_VAR 0 9
65755: PPUSH
65756: CALL_OW 440
65760: NOT
65761: AND
65762: IFFALSE 65766
// exit ;
65764: GO 65774
// result := true ;
65766: LD_ADDR_VAR 0 6
65770: PUSH
65771: LD_INT 1
65773: ST_TO_ADDR
// end ;
65774: LD_VAR 0 6
65778: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
65779: LD_INT 0
65781: PPUSH
65782: PPUSH
65783: PPUSH
65784: PPUSH
65785: PPUSH
65786: PPUSH
65787: PPUSH
65788: PPUSH
65789: PPUSH
65790: PPUSH
65791: PPUSH
65792: PPUSH
65793: PPUSH
65794: PPUSH
65795: PPUSH
65796: PPUSH
65797: PPUSH
65798: PPUSH
65799: PPUSH
65800: PPUSH
65801: PPUSH
65802: PPUSH
65803: PPUSH
65804: PPUSH
65805: PPUSH
65806: PPUSH
65807: PPUSH
65808: PPUSH
65809: PPUSH
65810: PPUSH
65811: PPUSH
65812: PPUSH
65813: PPUSH
65814: PPUSH
65815: PPUSH
65816: PPUSH
65817: PPUSH
65818: PPUSH
65819: PPUSH
65820: PPUSH
65821: PPUSH
65822: PPUSH
65823: PPUSH
65824: PPUSH
65825: PPUSH
65826: PPUSH
65827: PPUSH
65828: PPUSH
65829: PPUSH
65830: PPUSH
65831: PPUSH
65832: PPUSH
65833: PPUSH
65834: PPUSH
65835: PPUSH
65836: PPUSH
65837: PPUSH
65838: PPUSH
// result = [ ] ;
65839: LD_ADDR_VAR 0 7
65843: PUSH
65844: EMPTY
65845: ST_TO_ADDR
// temp_list = [ ] ;
65846: LD_ADDR_VAR 0 9
65850: PUSH
65851: EMPTY
65852: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65853: LD_VAR 0 4
65857: PUSH
65858: LD_INT 0
65860: PUSH
65861: LD_INT 1
65863: PUSH
65864: LD_INT 2
65866: PUSH
65867: LD_INT 3
65869: PUSH
65870: LD_INT 4
65872: PUSH
65873: LD_INT 5
65875: PUSH
65876: EMPTY
65877: LIST
65878: LIST
65879: LIST
65880: LIST
65881: LIST
65882: LIST
65883: IN
65884: NOT
65885: PUSH
65886: LD_VAR 0 1
65890: PUSH
65891: LD_INT 0
65893: PUSH
65894: LD_INT 1
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: IN
65901: PUSH
65902: LD_VAR 0 5
65906: PUSH
65907: LD_INT 1
65909: PUSH
65910: LD_INT 2
65912: PUSH
65913: LD_INT 3
65915: PUSH
65916: EMPTY
65917: LIST
65918: LIST
65919: LIST
65920: IN
65921: NOT
65922: AND
65923: OR
65924: IFFALSE 65928
// exit ;
65926: GO 84319
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65928: LD_VAR 0 1
65932: PUSH
65933: LD_INT 6
65935: PUSH
65936: LD_INT 7
65938: PUSH
65939: LD_INT 8
65941: PUSH
65942: LD_INT 13
65944: PUSH
65945: LD_INT 12
65947: PUSH
65948: LD_INT 15
65950: PUSH
65951: LD_INT 11
65953: PUSH
65954: LD_INT 14
65956: PUSH
65957: LD_INT 10
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: IN
65971: IFFALSE 65981
// btype = b_lab ;
65973: LD_ADDR_VAR 0 1
65977: PUSH
65978: LD_INT 6
65980: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65981: LD_VAR 0 6
65985: PUSH
65986: LD_INT 0
65988: PUSH
65989: LD_INT 1
65991: PUSH
65992: LD_INT 2
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: LIST
65999: IN
66000: NOT
66001: PUSH
66002: LD_VAR 0 1
66006: PUSH
66007: LD_INT 0
66009: PUSH
66010: LD_INT 1
66012: PUSH
66013: LD_INT 2
66015: PUSH
66016: LD_INT 3
66018: PUSH
66019: LD_INT 6
66021: PUSH
66022: LD_INT 36
66024: PUSH
66025: LD_INT 4
66027: PUSH
66028: LD_INT 5
66030: PUSH
66031: LD_INT 31
66033: PUSH
66034: LD_INT 32
66036: PUSH
66037: LD_INT 33
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: LIST
66044: LIST
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: IN
66053: NOT
66054: PUSH
66055: LD_VAR 0 6
66059: PUSH
66060: LD_INT 1
66062: EQUAL
66063: AND
66064: OR
66065: PUSH
66066: LD_VAR 0 1
66070: PUSH
66071: LD_INT 2
66073: PUSH
66074: LD_INT 3
66076: PUSH
66077: EMPTY
66078: LIST
66079: LIST
66080: IN
66081: NOT
66082: PUSH
66083: LD_VAR 0 6
66087: PUSH
66088: LD_INT 2
66090: EQUAL
66091: AND
66092: OR
66093: IFFALSE 66103
// mode = 0 ;
66095: LD_ADDR_VAR 0 6
66099: PUSH
66100: LD_INT 0
66102: ST_TO_ADDR
// case mode of 0 :
66103: LD_VAR 0 6
66107: PUSH
66108: LD_INT 0
66110: DOUBLE
66111: EQUAL
66112: IFTRUE 66116
66114: GO 77569
66116: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66117: LD_ADDR_VAR 0 11
66121: PUSH
66122: LD_INT 0
66124: PUSH
66125: LD_INT 0
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: PUSH
66132: LD_INT 0
66134: PUSH
66135: LD_INT 1
66137: NEG
66138: PUSH
66139: EMPTY
66140: LIST
66141: LIST
66142: PUSH
66143: LD_INT 1
66145: PUSH
66146: LD_INT 0
66148: PUSH
66149: EMPTY
66150: LIST
66151: LIST
66152: PUSH
66153: LD_INT 1
66155: PUSH
66156: LD_INT 1
66158: PUSH
66159: EMPTY
66160: LIST
66161: LIST
66162: PUSH
66163: LD_INT 0
66165: PUSH
66166: LD_INT 1
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: PUSH
66173: LD_INT 1
66175: NEG
66176: PUSH
66177: LD_INT 0
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 1
66186: NEG
66187: PUSH
66188: LD_INT 1
66190: NEG
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 1
66198: NEG
66199: PUSH
66200: LD_INT 2
66202: NEG
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: PUSH
66208: LD_INT 0
66210: PUSH
66211: LD_INT 2
66213: NEG
66214: PUSH
66215: EMPTY
66216: LIST
66217: LIST
66218: PUSH
66219: LD_INT 1
66221: PUSH
66222: LD_INT 1
66224: NEG
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 1
66232: PUSH
66233: LD_INT 2
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 0
66242: PUSH
66243: LD_INT 2
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 1
66252: NEG
66253: PUSH
66254: LD_INT 1
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 1
66263: PUSH
66264: LD_INT 3
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PUSH
66271: LD_INT 0
66273: PUSH
66274: LD_INT 3
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 1
66283: NEG
66284: PUSH
66285: LD_INT 2
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: LIST
66296: LIST
66297: LIST
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: LIST
66307: LIST
66308: LIST
66309: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66310: LD_ADDR_VAR 0 12
66314: PUSH
66315: LD_INT 0
66317: PUSH
66318: LD_INT 0
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 0
66327: PUSH
66328: LD_INT 1
66330: NEG
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 1
66338: PUSH
66339: LD_INT 0
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 1
66348: PUSH
66349: LD_INT 1
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: PUSH
66356: LD_INT 0
66358: PUSH
66359: LD_INT 1
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: PUSH
66366: LD_INT 1
66368: NEG
66369: PUSH
66370: LD_INT 0
66372: PUSH
66373: EMPTY
66374: LIST
66375: LIST
66376: PUSH
66377: LD_INT 1
66379: NEG
66380: PUSH
66381: LD_INT 1
66383: NEG
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: PUSH
66389: LD_INT 1
66391: PUSH
66392: LD_INT 1
66394: NEG
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: PUSH
66400: LD_INT 2
66402: PUSH
66403: LD_INT 0
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: PUSH
66410: LD_INT 2
66412: PUSH
66413: LD_INT 1
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: PUSH
66420: LD_INT 1
66422: NEG
66423: PUSH
66424: LD_INT 1
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 2
66433: NEG
66434: PUSH
66435: LD_INT 0
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: PUSH
66442: LD_INT 2
66444: NEG
66445: PUSH
66446: LD_INT 1
66448: NEG
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 2
66456: NEG
66457: PUSH
66458: LD_INT 1
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: PUSH
66465: LD_INT 3
66467: NEG
66468: PUSH
66469: LD_INT 0
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 3
66478: NEG
66479: PUSH
66480: LD_INT 1
66482: NEG
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66506: LD_ADDR_VAR 0 13
66510: PUSH
66511: LD_INT 0
66513: PUSH
66514: LD_INT 0
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PUSH
66521: LD_INT 0
66523: PUSH
66524: LD_INT 1
66526: NEG
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 1
66534: PUSH
66535: LD_INT 0
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: LD_INT 1
66544: PUSH
66545: LD_INT 1
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 0
66554: PUSH
66555: LD_INT 1
66557: PUSH
66558: EMPTY
66559: LIST
66560: LIST
66561: PUSH
66562: LD_INT 1
66564: NEG
66565: PUSH
66566: LD_INT 0
66568: PUSH
66569: EMPTY
66570: LIST
66571: LIST
66572: PUSH
66573: LD_INT 1
66575: NEG
66576: PUSH
66577: LD_INT 1
66579: NEG
66580: PUSH
66581: EMPTY
66582: LIST
66583: LIST
66584: PUSH
66585: LD_INT 1
66587: NEG
66588: PUSH
66589: LD_INT 2
66591: NEG
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 2
66599: PUSH
66600: LD_INT 1
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 2
66609: PUSH
66610: LD_INT 2
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: LD_INT 1
66619: PUSH
66620: LD_INT 2
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 2
66629: NEG
66630: PUSH
66631: LD_INT 1
66633: NEG
66634: PUSH
66635: EMPTY
66636: LIST
66637: LIST
66638: PUSH
66639: LD_INT 2
66641: NEG
66642: PUSH
66643: LD_INT 2
66645: NEG
66646: PUSH
66647: EMPTY
66648: LIST
66649: LIST
66650: PUSH
66651: LD_INT 2
66653: NEG
66654: PUSH
66655: LD_INT 3
66657: NEG
66658: PUSH
66659: EMPTY
66660: LIST
66661: LIST
66662: PUSH
66663: LD_INT 3
66665: NEG
66666: PUSH
66667: LD_INT 2
66669: NEG
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 3
66677: NEG
66678: PUSH
66679: LD_INT 3
66681: NEG
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: EMPTY
66688: LIST
66689: LIST
66690: LIST
66691: LIST
66692: LIST
66693: LIST
66694: LIST
66695: LIST
66696: LIST
66697: LIST
66698: LIST
66699: LIST
66700: LIST
66701: LIST
66702: LIST
66703: LIST
66704: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66705: LD_ADDR_VAR 0 14
66709: PUSH
66710: LD_INT 0
66712: PUSH
66713: LD_INT 0
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: LD_INT 0
66722: PUSH
66723: LD_INT 1
66725: NEG
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: PUSH
66731: LD_INT 1
66733: PUSH
66734: LD_INT 0
66736: PUSH
66737: EMPTY
66738: LIST
66739: LIST
66740: PUSH
66741: LD_INT 1
66743: PUSH
66744: LD_INT 1
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PUSH
66751: LD_INT 0
66753: PUSH
66754: LD_INT 1
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 1
66763: NEG
66764: PUSH
66765: LD_INT 0
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: LD_INT 1
66774: NEG
66775: PUSH
66776: LD_INT 1
66778: NEG
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 1
66786: NEG
66787: PUSH
66788: LD_INT 2
66790: NEG
66791: PUSH
66792: EMPTY
66793: LIST
66794: LIST
66795: PUSH
66796: LD_INT 0
66798: PUSH
66799: LD_INT 2
66801: NEG
66802: PUSH
66803: EMPTY
66804: LIST
66805: LIST
66806: PUSH
66807: LD_INT 1
66809: PUSH
66810: LD_INT 1
66812: NEG
66813: PUSH
66814: EMPTY
66815: LIST
66816: LIST
66817: PUSH
66818: LD_INT 1
66820: PUSH
66821: LD_INT 2
66823: PUSH
66824: EMPTY
66825: LIST
66826: LIST
66827: PUSH
66828: LD_INT 0
66830: PUSH
66831: LD_INT 2
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: PUSH
66838: LD_INT 1
66840: NEG
66841: PUSH
66842: LD_INT 1
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PUSH
66853: LD_INT 3
66855: NEG
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 0
66863: PUSH
66864: LD_INT 3
66866: NEG
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 1
66874: PUSH
66875: LD_INT 2
66877: NEG
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: LIST
66893: LIST
66894: LIST
66895: LIST
66896: LIST
66897: LIST
66898: LIST
66899: LIST
66900: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66901: LD_ADDR_VAR 0 15
66905: PUSH
66906: LD_INT 0
66908: PUSH
66909: LD_INT 0
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 0
66918: PUSH
66919: LD_INT 1
66921: NEG
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 1
66929: PUSH
66930: LD_INT 0
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 1
66939: PUSH
66940: LD_INT 1
66942: PUSH
66943: EMPTY
66944: LIST
66945: LIST
66946: PUSH
66947: LD_INT 0
66949: PUSH
66950: LD_INT 1
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: PUSH
66957: LD_INT 1
66959: NEG
66960: PUSH
66961: LD_INT 0
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: LD_INT 1
66970: NEG
66971: PUSH
66972: LD_INT 1
66974: NEG
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 1
66982: PUSH
66983: LD_INT 1
66985: NEG
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: PUSH
66991: LD_INT 2
66993: PUSH
66994: LD_INT 0
66996: PUSH
66997: EMPTY
66998: LIST
66999: LIST
67000: PUSH
67001: LD_INT 2
67003: PUSH
67004: LD_INT 1
67006: PUSH
67007: EMPTY
67008: LIST
67009: LIST
67010: PUSH
67011: LD_INT 1
67013: NEG
67014: PUSH
67015: LD_INT 1
67017: PUSH
67018: EMPTY
67019: LIST
67020: LIST
67021: PUSH
67022: LD_INT 2
67024: NEG
67025: PUSH
67026: LD_INT 0
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: LD_INT 2
67035: NEG
67036: PUSH
67037: LD_INT 1
67039: NEG
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: PUSH
67045: LD_INT 2
67047: PUSH
67048: LD_INT 1
67050: NEG
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: LD_INT 3
67058: PUSH
67059: LD_INT 0
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 3
67068: PUSH
67069: LD_INT 1
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: LIST
67080: LIST
67081: LIST
67082: LIST
67083: LIST
67084: LIST
67085: LIST
67086: LIST
67087: LIST
67088: LIST
67089: LIST
67090: LIST
67091: LIST
67092: LIST
67093: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67094: LD_ADDR_VAR 0 16
67098: PUSH
67099: LD_INT 0
67101: PUSH
67102: LD_INT 0
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: PUSH
67109: LD_INT 0
67111: PUSH
67112: LD_INT 1
67114: NEG
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 1
67122: PUSH
67123: LD_INT 0
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 1
67132: PUSH
67133: LD_INT 1
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 0
67142: PUSH
67143: LD_INT 1
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: PUSH
67150: LD_INT 1
67152: NEG
67153: PUSH
67154: LD_INT 0
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PUSH
67161: LD_INT 1
67163: NEG
67164: PUSH
67165: LD_INT 1
67167: NEG
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: PUSH
67173: LD_INT 1
67175: NEG
67176: PUSH
67177: LD_INT 2
67179: NEG
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: PUSH
67185: LD_INT 2
67187: PUSH
67188: LD_INT 1
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 2
67197: PUSH
67198: LD_INT 2
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 1
67207: PUSH
67208: LD_INT 2
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: PUSH
67215: LD_INT 2
67217: NEG
67218: PUSH
67219: LD_INT 1
67221: NEG
67222: PUSH
67223: EMPTY
67224: LIST
67225: LIST
67226: PUSH
67227: LD_INT 2
67229: NEG
67230: PUSH
67231: LD_INT 2
67233: NEG
67234: PUSH
67235: EMPTY
67236: LIST
67237: LIST
67238: PUSH
67239: LD_INT 3
67241: PUSH
67242: LD_INT 2
67244: PUSH
67245: EMPTY
67246: LIST
67247: LIST
67248: PUSH
67249: LD_INT 3
67251: PUSH
67252: LD_INT 3
67254: PUSH
67255: EMPTY
67256: LIST
67257: LIST
67258: PUSH
67259: LD_INT 2
67261: PUSH
67262: LD_INT 3
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67287: LD_ADDR_VAR 0 17
67291: PUSH
67292: LD_INT 0
67294: PUSH
67295: LD_INT 0
67297: PUSH
67298: EMPTY
67299: LIST
67300: LIST
67301: PUSH
67302: LD_INT 0
67304: PUSH
67305: LD_INT 1
67307: NEG
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PUSH
67313: LD_INT 1
67315: PUSH
67316: LD_INT 0
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 1
67325: PUSH
67326: LD_INT 1
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 0
67335: PUSH
67336: LD_INT 1
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: LD_INT 1
67345: NEG
67346: PUSH
67347: LD_INT 0
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: LD_INT 1
67356: NEG
67357: PUSH
67358: LD_INT 1
67360: NEG
67361: PUSH
67362: EMPTY
67363: LIST
67364: LIST
67365: PUSH
67366: LD_INT 1
67368: NEG
67369: PUSH
67370: LD_INT 2
67372: NEG
67373: PUSH
67374: EMPTY
67375: LIST
67376: LIST
67377: PUSH
67378: LD_INT 0
67380: PUSH
67381: LD_INT 2
67383: NEG
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: PUSH
67389: LD_INT 1
67391: PUSH
67392: LD_INT 1
67394: NEG
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 2
67402: PUSH
67403: LD_INT 0
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 2
67412: PUSH
67413: LD_INT 1
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 2
67422: PUSH
67423: LD_INT 2
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: PUSH
67430: LD_INT 1
67432: PUSH
67433: LD_INT 2
67435: PUSH
67436: EMPTY
67437: LIST
67438: LIST
67439: PUSH
67440: LD_INT 0
67442: PUSH
67443: LD_INT 2
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: LD_INT 1
67452: NEG
67453: PUSH
67454: LD_INT 1
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: PUSH
67461: LD_INT 2
67463: NEG
67464: PUSH
67465: LD_INT 0
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: PUSH
67472: LD_INT 2
67474: NEG
67475: PUSH
67476: LD_INT 1
67478: NEG
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: LD_INT 2
67486: NEG
67487: PUSH
67488: LD_INT 2
67490: NEG
67491: PUSH
67492: EMPTY
67493: LIST
67494: LIST
67495: PUSH
67496: EMPTY
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: LIST
67511: LIST
67512: LIST
67513: LIST
67514: LIST
67515: LIST
67516: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67517: LD_ADDR_VAR 0 18
67521: PUSH
67522: LD_INT 0
67524: PUSH
67525: LD_INT 0
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: PUSH
67532: LD_INT 0
67534: PUSH
67535: LD_INT 1
67537: NEG
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: PUSH
67543: LD_INT 1
67545: PUSH
67546: LD_INT 0
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: PUSH
67553: LD_INT 1
67555: PUSH
67556: LD_INT 1
67558: PUSH
67559: EMPTY
67560: LIST
67561: LIST
67562: PUSH
67563: LD_INT 0
67565: PUSH
67566: LD_INT 1
67568: PUSH
67569: EMPTY
67570: LIST
67571: LIST
67572: PUSH
67573: LD_INT 1
67575: NEG
67576: PUSH
67577: LD_INT 0
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 1
67586: NEG
67587: PUSH
67588: LD_INT 1
67590: NEG
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: LD_INT 1
67598: NEG
67599: PUSH
67600: LD_INT 2
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 0
67610: PUSH
67611: LD_INT 2
67613: NEG
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: PUSH
67619: LD_INT 1
67621: PUSH
67622: LD_INT 1
67624: NEG
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 2
67632: PUSH
67633: LD_INT 0
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 2
67642: PUSH
67643: LD_INT 1
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 2
67652: PUSH
67653: LD_INT 2
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: PUSH
67660: LD_INT 1
67662: PUSH
67663: LD_INT 2
67665: PUSH
67666: EMPTY
67667: LIST
67668: LIST
67669: PUSH
67670: LD_INT 0
67672: PUSH
67673: LD_INT 2
67675: PUSH
67676: EMPTY
67677: LIST
67678: LIST
67679: PUSH
67680: LD_INT 1
67682: NEG
67683: PUSH
67684: LD_INT 1
67686: PUSH
67687: EMPTY
67688: LIST
67689: LIST
67690: PUSH
67691: LD_INT 2
67693: NEG
67694: PUSH
67695: LD_INT 0
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 2
67704: NEG
67705: PUSH
67706: LD_INT 1
67708: NEG
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: LD_INT 2
67716: NEG
67717: PUSH
67718: LD_INT 2
67720: NEG
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: PUSH
67726: EMPTY
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: LIST
67744: LIST
67745: LIST
67746: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67747: LD_ADDR_VAR 0 19
67751: PUSH
67752: LD_INT 0
67754: PUSH
67755: LD_INT 0
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: PUSH
67762: LD_INT 0
67764: PUSH
67765: LD_INT 1
67767: NEG
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: PUSH
67773: LD_INT 1
67775: PUSH
67776: LD_INT 0
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 1
67785: PUSH
67786: LD_INT 1
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 0
67795: PUSH
67796: LD_INT 1
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 1
67805: NEG
67806: PUSH
67807: LD_INT 0
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 1
67816: NEG
67817: PUSH
67818: LD_INT 1
67820: NEG
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: LD_INT 1
67828: NEG
67829: PUSH
67830: LD_INT 2
67832: NEG
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: LD_INT 0
67840: PUSH
67841: LD_INT 2
67843: NEG
67844: PUSH
67845: EMPTY
67846: LIST
67847: LIST
67848: PUSH
67849: LD_INT 1
67851: PUSH
67852: LD_INT 1
67854: NEG
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: LD_INT 2
67862: PUSH
67863: LD_INT 0
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: PUSH
67870: LD_INT 2
67872: PUSH
67873: LD_INT 1
67875: PUSH
67876: EMPTY
67877: LIST
67878: LIST
67879: PUSH
67880: LD_INT 2
67882: PUSH
67883: LD_INT 2
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: LD_INT 2
67895: PUSH
67896: EMPTY
67897: LIST
67898: LIST
67899: PUSH
67900: LD_INT 0
67902: PUSH
67903: LD_INT 2
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 1
67912: NEG
67913: PUSH
67914: LD_INT 1
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: PUSH
67921: LD_INT 2
67923: NEG
67924: PUSH
67925: LD_INT 0
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: PUSH
67932: LD_INT 2
67934: NEG
67935: PUSH
67936: LD_INT 1
67938: NEG
67939: PUSH
67940: EMPTY
67941: LIST
67942: LIST
67943: PUSH
67944: LD_INT 2
67946: NEG
67947: PUSH
67948: LD_INT 2
67950: NEG
67951: PUSH
67952: EMPTY
67953: LIST
67954: LIST
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: LIST
67960: LIST
67961: LIST
67962: LIST
67963: LIST
67964: LIST
67965: LIST
67966: LIST
67967: LIST
67968: LIST
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67977: LD_ADDR_VAR 0 20
67981: PUSH
67982: LD_INT 0
67984: PUSH
67985: LD_INT 0
67987: PUSH
67988: EMPTY
67989: LIST
67990: LIST
67991: PUSH
67992: LD_INT 0
67994: PUSH
67995: LD_INT 1
67997: NEG
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: PUSH
68003: LD_INT 1
68005: PUSH
68006: LD_INT 0
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 1
68015: PUSH
68016: LD_INT 1
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: LD_INT 0
68025: PUSH
68026: LD_INT 1
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 1
68035: NEG
68036: PUSH
68037: LD_INT 0
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 1
68046: NEG
68047: PUSH
68048: LD_INT 1
68050: NEG
68051: PUSH
68052: EMPTY
68053: LIST
68054: LIST
68055: PUSH
68056: LD_INT 1
68058: NEG
68059: PUSH
68060: LD_INT 2
68062: NEG
68063: PUSH
68064: EMPTY
68065: LIST
68066: LIST
68067: PUSH
68068: LD_INT 0
68070: PUSH
68071: LD_INT 2
68073: NEG
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: LD_INT 1
68081: PUSH
68082: LD_INT 1
68084: NEG
68085: PUSH
68086: EMPTY
68087: LIST
68088: LIST
68089: PUSH
68090: LD_INT 2
68092: PUSH
68093: LD_INT 0
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: PUSH
68100: LD_INT 2
68102: PUSH
68103: LD_INT 1
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 2
68112: PUSH
68113: LD_INT 2
68115: PUSH
68116: EMPTY
68117: LIST
68118: LIST
68119: PUSH
68120: LD_INT 1
68122: PUSH
68123: LD_INT 2
68125: PUSH
68126: EMPTY
68127: LIST
68128: LIST
68129: PUSH
68130: LD_INT 0
68132: PUSH
68133: LD_INT 2
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: LD_INT 1
68142: NEG
68143: PUSH
68144: LD_INT 1
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: LD_INT 2
68153: NEG
68154: PUSH
68155: LD_INT 0
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: LD_INT 2
68164: NEG
68165: PUSH
68166: LD_INT 1
68168: NEG
68169: PUSH
68170: EMPTY
68171: LIST
68172: LIST
68173: PUSH
68174: LD_INT 2
68176: NEG
68177: PUSH
68178: LD_INT 2
68180: NEG
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: PUSH
68186: EMPTY
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: LIST
68205: LIST
68206: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68207: LD_ADDR_VAR 0 21
68211: PUSH
68212: LD_INT 0
68214: PUSH
68215: LD_INT 0
68217: PUSH
68218: EMPTY
68219: LIST
68220: LIST
68221: PUSH
68222: LD_INT 0
68224: PUSH
68225: LD_INT 1
68227: NEG
68228: PUSH
68229: EMPTY
68230: LIST
68231: LIST
68232: PUSH
68233: LD_INT 1
68235: PUSH
68236: LD_INT 0
68238: PUSH
68239: EMPTY
68240: LIST
68241: LIST
68242: PUSH
68243: LD_INT 1
68245: PUSH
68246: LD_INT 1
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 0
68255: PUSH
68256: LD_INT 1
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 1
68265: NEG
68266: PUSH
68267: LD_INT 0
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: LD_INT 1
68276: NEG
68277: PUSH
68278: LD_INT 1
68280: NEG
68281: PUSH
68282: EMPTY
68283: LIST
68284: LIST
68285: PUSH
68286: LD_INT 1
68288: NEG
68289: PUSH
68290: LD_INT 2
68292: NEG
68293: PUSH
68294: EMPTY
68295: LIST
68296: LIST
68297: PUSH
68298: LD_INT 0
68300: PUSH
68301: LD_INT 2
68303: NEG
68304: PUSH
68305: EMPTY
68306: LIST
68307: LIST
68308: PUSH
68309: LD_INT 1
68311: PUSH
68312: LD_INT 1
68314: NEG
68315: PUSH
68316: EMPTY
68317: LIST
68318: LIST
68319: PUSH
68320: LD_INT 2
68322: PUSH
68323: LD_INT 0
68325: PUSH
68326: EMPTY
68327: LIST
68328: LIST
68329: PUSH
68330: LD_INT 2
68332: PUSH
68333: LD_INT 1
68335: PUSH
68336: EMPTY
68337: LIST
68338: LIST
68339: PUSH
68340: LD_INT 2
68342: PUSH
68343: LD_INT 2
68345: PUSH
68346: EMPTY
68347: LIST
68348: LIST
68349: PUSH
68350: LD_INT 1
68352: PUSH
68353: LD_INT 2
68355: PUSH
68356: EMPTY
68357: LIST
68358: LIST
68359: PUSH
68360: LD_INT 0
68362: PUSH
68363: LD_INT 2
68365: PUSH
68366: EMPTY
68367: LIST
68368: LIST
68369: PUSH
68370: LD_INT 1
68372: NEG
68373: PUSH
68374: LD_INT 1
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 2
68383: NEG
68384: PUSH
68385: LD_INT 0
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PUSH
68392: LD_INT 2
68394: NEG
68395: PUSH
68396: LD_INT 1
68398: NEG
68399: PUSH
68400: EMPTY
68401: LIST
68402: LIST
68403: PUSH
68404: LD_INT 2
68406: NEG
68407: PUSH
68408: LD_INT 2
68410: NEG
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: LIST
68420: LIST
68421: LIST
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: LIST
68436: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68437: LD_ADDR_VAR 0 22
68441: PUSH
68442: LD_INT 0
68444: PUSH
68445: LD_INT 0
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: PUSH
68452: LD_INT 0
68454: PUSH
68455: LD_INT 1
68457: NEG
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: LD_INT 1
68465: PUSH
68466: LD_INT 0
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: PUSH
68473: LD_INT 1
68475: PUSH
68476: LD_INT 1
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 0
68485: PUSH
68486: LD_INT 1
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: PUSH
68493: LD_INT 1
68495: NEG
68496: PUSH
68497: LD_INT 0
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 1
68506: NEG
68507: PUSH
68508: LD_INT 1
68510: NEG
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: LD_INT 1
68518: NEG
68519: PUSH
68520: LD_INT 2
68522: NEG
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 0
68530: PUSH
68531: LD_INT 2
68533: NEG
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: PUSH
68539: LD_INT 1
68541: PUSH
68542: LD_INT 1
68544: NEG
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: PUSH
68550: LD_INT 2
68552: PUSH
68553: LD_INT 0
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PUSH
68560: LD_INT 2
68562: PUSH
68563: LD_INT 1
68565: PUSH
68566: EMPTY
68567: LIST
68568: LIST
68569: PUSH
68570: LD_INT 2
68572: PUSH
68573: LD_INT 2
68575: PUSH
68576: EMPTY
68577: LIST
68578: LIST
68579: PUSH
68580: LD_INT 1
68582: PUSH
68583: LD_INT 2
68585: PUSH
68586: EMPTY
68587: LIST
68588: LIST
68589: PUSH
68590: LD_INT 0
68592: PUSH
68593: LD_INT 2
68595: PUSH
68596: EMPTY
68597: LIST
68598: LIST
68599: PUSH
68600: LD_INT 1
68602: NEG
68603: PUSH
68604: LD_INT 1
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: PUSH
68611: LD_INT 2
68613: NEG
68614: PUSH
68615: LD_INT 0
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: PUSH
68622: LD_INT 2
68624: NEG
68625: PUSH
68626: LD_INT 1
68628: NEG
68629: PUSH
68630: EMPTY
68631: LIST
68632: LIST
68633: PUSH
68634: LD_INT 2
68636: NEG
68637: PUSH
68638: LD_INT 2
68640: NEG
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: LIST
68650: LIST
68651: LIST
68652: LIST
68653: LIST
68654: LIST
68655: LIST
68656: LIST
68657: LIST
68658: LIST
68659: LIST
68660: LIST
68661: LIST
68662: LIST
68663: LIST
68664: LIST
68665: LIST
68666: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68667: LD_ADDR_VAR 0 23
68671: PUSH
68672: LD_INT 0
68674: PUSH
68675: LD_INT 0
68677: PUSH
68678: EMPTY
68679: LIST
68680: LIST
68681: PUSH
68682: LD_INT 0
68684: PUSH
68685: LD_INT 1
68687: NEG
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: PUSH
68693: LD_INT 1
68695: PUSH
68696: LD_INT 0
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: LD_INT 1
68705: PUSH
68706: LD_INT 1
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 0
68715: PUSH
68716: LD_INT 1
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 1
68725: NEG
68726: PUSH
68727: LD_INT 0
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 1
68736: NEG
68737: PUSH
68738: LD_INT 1
68740: NEG
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 1
68748: NEG
68749: PUSH
68750: LD_INT 2
68752: NEG
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: LD_INT 0
68760: PUSH
68761: LD_INT 2
68763: NEG
68764: PUSH
68765: EMPTY
68766: LIST
68767: LIST
68768: PUSH
68769: LD_INT 1
68771: PUSH
68772: LD_INT 1
68774: NEG
68775: PUSH
68776: EMPTY
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 2
68782: PUSH
68783: LD_INT 0
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: LD_INT 2
68792: PUSH
68793: LD_INT 1
68795: PUSH
68796: EMPTY
68797: LIST
68798: LIST
68799: PUSH
68800: LD_INT 2
68802: PUSH
68803: LD_INT 2
68805: PUSH
68806: EMPTY
68807: LIST
68808: LIST
68809: PUSH
68810: LD_INT 1
68812: PUSH
68813: LD_INT 2
68815: PUSH
68816: EMPTY
68817: LIST
68818: LIST
68819: PUSH
68820: LD_INT 0
68822: PUSH
68823: LD_INT 2
68825: PUSH
68826: EMPTY
68827: LIST
68828: LIST
68829: PUSH
68830: LD_INT 1
68832: NEG
68833: PUSH
68834: LD_INT 1
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 2
68843: NEG
68844: PUSH
68845: LD_INT 0
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 2
68854: NEG
68855: PUSH
68856: LD_INT 1
68858: NEG
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: PUSH
68864: LD_INT 2
68866: NEG
68867: PUSH
68868: LD_INT 2
68870: NEG
68871: PUSH
68872: EMPTY
68873: LIST
68874: LIST
68875: PUSH
68876: LD_INT 2
68878: NEG
68879: PUSH
68880: LD_INT 3
68882: NEG
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: PUSH
68888: LD_INT 1
68890: NEG
68891: PUSH
68892: LD_INT 3
68894: NEG
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: PUSH
68900: LD_INT 1
68902: PUSH
68903: LD_INT 2
68905: NEG
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 2
68913: PUSH
68914: LD_INT 1
68916: NEG
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: EMPTY
68923: LIST
68924: LIST
68925: LIST
68926: LIST
68927: LIST
68928: LIST
68929: LIST
68930: LIST
68931: LIST
68932: LIST
68933: LIST
68934: LIST
68935: LIST
68936: LIST
68937: LIST
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68947: LD_ADDR_VAR 0 24
68951: PUSH
68952: LD_INT 0
68954: PUSH
68955: LD_INT 0
68957: PUSH
68958: EMPTY
68959: LIST
68960: LIST
68961: PUSH
68962: LD_INT 0
68964: PUSH
68965: LD_INT 1
68967: NEG
68968: PUSH
68969: EMPTY
68970: LIST
68971: LIST
68972: PUSH
68973: LD_INT 1
68975: PUSH
68976: LD_INT 0
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: LD_INT 1
68985: PUSH
68986: LD_INT 1
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 0
68995: PUSH
68996: LD_INT 1
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 1
69005: NEG
69006: PUSH
69007: LD_INT 0
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 1
69016: NEG
69017: PUSH
69018: LD_INT 1
69020: NEG
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PUSH
69026: LD_INT 1
69028: NEG
69029: PUSH
69030: LD_INT 2
69032: NEG
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 0
69040: PUSH
69041: LD_INT 2
69043: NEG
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 1
69051: PUSH
69052: LD_INT 1
69054: NEG
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: LD_INT 2
69062: PUSH
69063: LD_INT 0
69065: PUSH
69066: EMPTY
69067: LIST
69068: LIST
69069: PUSH
69070: LD_INT 2
69072: PUSH
69073: LD_INT 1
69075: PUSH
69076: EMPTY
69077: LIST
69078: LIST
69079: PUSH
69080: LD_INT 2
69082: PUSH
69083: LD_INT 2
69085: PUSH
69086: EMPTY
69087: LIST
69088: LIST
69089: PUSH
69090: LD_INT 1
69092: PUSH
69093: LD_INT 2
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: PUSH
69100: LD_INT 0
69102: PUSH
69103: LD_INT 2
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 1
69112: NEG
69113: PUSH
69114: LD_INT 1
69116: PUSH
69117: EMPTY
69118: LIST
69119: LIST
69120: PUSH
69121: LD_INT 2
69123: NEG
69124: PUSH
69125: LD_INT 0
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 2
69134: NEG
69135: PUSH
69136: LD_INT 1
69138: NEG
69139: PUSH
69140: EMPTY
69141: LIST
69142: LIST
69143: PUSH
69144: LD_INT 2
69146: NEG
69147: PUSH
69148: LD_INT 2
69150: NEG
69151: PUSH
69152: EMPTY
69153: LIST
69154: LIST
69155: PUSH
69156: LD_INT 1
69158: PUSH
69159: LD_INT 2
69161: NEG
69162: PUSH
69163: EMPTY
69164: LIST
69165: LIST
69166: PUSH
69167: LD_INT 2
69169: PUSH
69170: LD_INT 1
69172: NEG
69173: PUSH
69174: EMPTY
69175: LIST
69176: LIST
69177: PUSH
69178: LD_INT 3
69180: PUSH
69181: LD_INT 1
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PUSH
69188: LD_INT 3
69190: PUSH
69191: LD_INT 2
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: LIST
69205: LIST
69206: LIST
69207: LIST
69208: LIST
69209: LIST
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: LIST
69215: LIST
69216: LIST
69217: LIST
69218: LIST
69219: LIST
69220: LIST
69221: LIST
69222: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69223: LD_ADDR_VAR 0 25
69227: PUSH
69228: LD_INT 0
69230: PUSH
69231: LD_INT 0
69233: PUSH
69234: EMPTY
69235: LIST
69236: LIST
69237: PUSH
69238: LD_INT 0
69240: PUSH
69241: LD_INT 1
69243: NEG
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 1
69251: PUSH
69252: LD_INT 0
69254: PUSH
69255: EMPTY
69256: LIST
69257: LIST
69258: PUSH
69259: LD_INT 1
69261: PUSH
69262: LD_INT 1
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PUSH
69269: LD_INT 0
69271: PUSH
69272: LD_INT 1
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PUSH
69279: LD_INT 1
69281: NEG
69282: PUSH
69283: LD_INT 0
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 1
69292: NEG
69293: PUSH
69294: LD_INT 1
69296: NEG
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 1
69304: NEG
69305: PUSH
69306: LD_INT 2
69308: NEG
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PUSH
69314: LD_INT 0
69316: PUSH
69317: LD_INT 2
69319: NEG
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 1
69327: PUSH
69328: LD_INT 1
69330: NEG
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 2
69338: PUSH
69339: LD_INT 0
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 2
69348: PUSH
69349: LD_INT 1
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: PUSH
69356: LD_INT 2
69358: PUSH
69359: LD_INT 2
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 1
69368: PUSH
69369: LD_INT 2
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 0
69378: PUSH
69379: LD_INT 2
69381: PUSH
69382: EMPTY
69383: LIST
69384: LIST
69385: PUSH
69386: LD_INT 1
69388: NEG
69389: PUSH
69390: LD_INT 1
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: LD_INT 2
69399: NEG
69400: PUSH
69401: LD_INT 0
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PUSH
69408: LD_INT 2
69410: NEG
69411: PUSH
69412: LD_INT 1
69414: NEG
69415: PUSH
69416: EMPTY
69417: LIST
69418: LIST
69419: PUSH
69420: LD_INT 2
69422: NEG
69423: PUSH
69424: LD_INT 2
69426: NEG
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: PUSH
69432: LD_INT 3
69434: PUSH
69435: LD_INT 1
69437: PUSH
69438: EMPTY
69439: LIST
69440: LIST
69441: PUSH
69442: LD_INT 3
69444: PUSH
69445: LD_INT 2
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 2
69454: PUSH
69455: LD_INT 3
69457: PUSH
69458: EMPTY
69459: LIST
69460: LIST
69461: PUSH
69462: LD_INT 1
69464: PUSH
69465: LD_INT 3
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: LIST
69476: LIST
69477: LIST
69478: LIST
69479: LIST
69480: LIST
69481: LIST
69482: LIST
69483: LIST
69484: LIST
69485: LIST
69486: LIST
69487: LIST
69488: LIST
69489: LIST
69490: LIST
69491: LIST
69492: LIST
69493: LIST
69494: LIST
69495: LIST
69496: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69497: LD_ADDR_VAR 0 26
69501: PUSH
69502: LD_INT 0
69504: PUSH
69505: LD_INT 0
69507: PUSH
69508: EMPTY
69509: LIST
69510: LIST
69511: PUSH
69512: LD_INT 0
69514: PUSH
69515: LD_INT 1
69517: NEG
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: LD_INT 1
69525: PUSH
69526: LD_INT 0
69528: PUSH
69529: EMPTY
69530: LIST
69531: LIST
69532: PUSH
69533: LD_INT 1
69535: PUSH
69536: LD_INT 1
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: LD_INT 0
69545: PUSH
69546: LD_INT 1
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 1
69555: NEG
69556: PUSH
69557: LD_INT 0
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 1
69566: NEG
69567: PUSH
69568: LD_INT 1
69570: NEG
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 1
69578: NEG
69579: PUSH
69580: LD_INT 2
69582: NEG
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: PUSH
69588: LD_INT 0
69590: PUSH
69591: LD_INT 2
69593: NEG
69594: PUSH
69595: EMPTY
69596: LIST
69597: LIST
69598: PUSH
69599: LD_INT 1
69601: PUSH
69602: LD_INT 1
69604: NEG
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PUSH
69610: LD_INT 2
69612: PUSH
69613: LD_INT 0
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 2
69622: PUSH
69623: LD_INT 1
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 2
69632: PUSH
69633: LD_INT 2
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 1
69642: PUSH
69643: LD_INT 2
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: LD_INT 0
69652: PUSH
69653: LD_INT 2
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: LD_INT 1
69662: NEG
69663: PUSH
69664: LD_INT 1
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 2
69673: NEG
69674: PUSH
69675: LD_INT 0
69677: PUSH
69678: EMPTY
69679: LIST
69680: LIST
69681: PUSH
69682: LD_INT 2
69684: NEG
69685: PUSH
69686: LD_INT 1
69688: NEG
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: LD_INT 2
69696: NEG
69697: PUSH
69698: LD_INT 2
69700: NEG
69701: PUSH
69702: EMPTY
69703: LIST
69704: LIST
69705: PUSH
69706: LD_INT 2
69708: PUSH
69709: LD_INT 3
69711: PUSH
69712: EMPTY
69713: LIST
69714: LIST
69715: PUSH
69716: LD_INT 1
69718: PUSH
69719: LD_INT 3
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 1
69728: NEG
69729: PUSH
69730: LD_INT 2
69732: PUSH
69733: EMPTY
69734: LIST
69735: LIST
69736: PUSH
69737: LD_INT 2
69739: NEG
69740: PUSH
69741: LD_INT 1
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: LIST
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: LIST
69766: LIST
69767: LIST
69768: LIST
69769: LIST
69770: LIST
69771: LIST
69772: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69773: LD_ADDR_VAR 0 27
69777: PUSH
69778: LD_INT 0
69780: PUSH
69781: LD_INT 0
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PUSH
69788: LD_INT 0
69790: PUSH
69791: LD_INT 1
69793: NEG
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 1
69801: PUSH
69802: LD_INT 0
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 1
69811: PUSH
69812: LD_INT 1
69814: PUSH
69815: EMPTY
69816: LIST
69817: LIST
69818: PUSH
69819: LD_INT 0
69821: PUSH
69822: LD_INT 1
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: PUSH
69829: LD_INT 1
69831: NEG
69832: PUSH
69833: LD_INT 0
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: PUSH
69840: LD_INT 1
69842: NEG
69843: PUSH
69844: LD_INT 1
69846: NEG
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: PUSH
69852: LD_INT 1
69854: NEG
69855: PUSH
69856: LD_INT 2
69858: NEG
69859: PUSH
69860: EMPTY
69861: LIST
69862: LIST
69863: PUSH
69864: LD_INT 0
69866: PUSH
69867: LD_INT 2
69869: NEG
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PUSH
69875: LD_INT 1
69877: PUSH
69878: LD_INT 1
69880: NEG
69881: PUSH
69882: EMPTY
69883: LIST
69884: LIST
69885: PUSH
69886: LD_INT 2
69888: PUSH
69889: LD_INT 0
69891: PUSH
69892: EMPTY
69893: LIST
69894: LIST
69895: PUSH
69896: LD_INT 2
69898: PUSH
69899: LD_INT 1
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: PUSH
69906: LD_INT 2
69908: PUSH
69909: LD_INT 2
69911: PUSH
69912: EMPTY
69913: LIST
69914: LIST
69915: PUSH
69916: LD_INT 1
69918: PUSH
69919: LD_INT 2
69921: PUSH
69922: EMPTY
69923: LIST
69924: LIST
69925: PUSH
69926: LD_INT 0
69928: PUSH
69929: LD_INT 2
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: PUSH
69936: LD_INT 1
69938: NEG
69939: PUSH
69940: LD_INT 1
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: PUSH
69947: LD_INT 2
69949: NEG
69950: PUSH
69951: LD_INT 0
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 2
69960: NEG
69961: PUSH
69962: LD_INT 1
69964: NEG
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: LD_INT 2
69972: NEG
69973: PUSH
69974: LD_INT 2
69976: NEG
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: PUSH
69982: LD_INT 1
69984: NEG
69985: PUSH
69986: LD_INT 2
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 2
69995: NEG
69996: PUSH
69997: LD_INT 1
69999: PUSH
70000: EMPTY
70001: LIST
70002: LIST
70003: PUSH
70004: LD_INT 3
70006: NEG
70007: PUSH
70008: LD_INT 1
70010: NEG
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: LD_INT 3
70018: NEG
70019: PUSH
70020: LD_INT 2
70022: NEG
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: EMPTY
70029: LIST
70030: LIST
70031: LIST
70032: LIST
70033: LIST
70034: LIST
70035: LIST
70036: LIST
70037: LIST
70038: LIST
70039: LIST
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70053: LD_ADDR_VAR 0 28
70057: PUSH
70058: LD_INT 0
70060: PUSH
70061: LD_INT 0
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: LD_INT 0
70070: PUSH
70071: LD_INT 1
70073: NEG
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 1
70081: PUSH
70082: LD_INT 0
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PUSH
70089: LD_INT 1
70091: PUSH
70092: LD_INT 1
70094: PUSH
70095: EMPTY
70096: LIST
70097: LIST
70098: PUSH
70099: LD_INT 0
70101: PUSH
70102: LD_INT 1
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: PUSH
70109: LD_INT 1
70111: NEG
70112: PUSH
70113: LD_INT 0
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: PUSH
70120: LD_INT 1
70122: NEG
70123: PUSH
70124: LD_INT 1
70126: NEG
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 1
70134: NEG
70135: PUSH
70136: LD_INT 2
70138: NEG
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: PUSH
70144: LD_INT 0
70146: PUSH
70147: LD_INT 2
70149: NEG
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PUSH
70155: LD_INT 1
70157: PUSH
70158: LD_INT 1
70160: NEG
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: LD_INT 2
70168: PUSH
70169: LD_INT 0
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 2
70178: PUSH
70179: LD_INT 1
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 2
70188: PUSH
70189: LD_INT 2
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 1
70198: PUSH
70199: LD_INT 2
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 0
70208: PUSH
70209: LD_INT 2
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 1
70218: NEG
70219: PUSH
70220: LD_INT 1
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 2
70229: NEG
70230: PUSH
70231: LD_INT 0
70233: PUSH
70234: EMPTY
70235: LIST
70236: LIST
70237: PUSH
70238: LD_INT 2
70240: NEG
70241: PUSH
70242: LD_INT 1
70244: NEG
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: LD_INT 2
70252: NEG
70253: PUSH
70254: LD_INT 2
70256: NEG
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PUSH
70262: LD_INT 2
70264: NEG
70265: PUSH
70266: LD_INT 3
70268: NEG
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: PUSH
70274: LD_INT 1
70276: NEG
70277: PUSH
70278: LD_INT 3
70280: NEG
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: PUSH
70286: LD_INT 3
70288: NEG
70289: PUSH
70290: LD_INT 1
70292: NEG
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: PUSH
70298: LD_INT 3
70300: NEG
70301: PUSH
70302: LD_INT 2
70304: NEG
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: EMPTY
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70335: LD_ADDR_VAR 0 29
70339: PUSH
70340: LD_INT 0
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 0
70352: PUSH
70353: LD_INT 1
70355: NEG
70356: PUSH
70357: EMPTY
70358: LIST
70359: LIST
70360: PUSH
70361: LD_INT 1
70363: PUSH
70364: LD_INT 0
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: LD_INT 1
70373: PUSH
70374: LD_INT 1
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 0
70383: PUSH
70384: LD_INT 1
70386: PUSH
70387: EMPTY
70388: LIST
70389: LIST
70390: PUSH
70391: LD_INT 1
70393: NEG
70394: PUSH
70395: LD_INT 0
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: PUSH
70402: LD_INT 1
70404: NEG
70405: PUSH
70406: LD_INT 1
70408: NEG
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: LD_INT 1
70416: NEG
70417: PUSH
70418: LD_INT 2
70420: NEG
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 0
70428: PUSH
70429: LD_INT 2
70431: NEG
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 1
70439: PUSH
70440: LD_INT 1
70442: NEG
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 2
70450: PUSH
70451: LD_INT 0
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 2
70460: PUSH
70461: LD_INT 1
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: PUSH
70468: LD_INT 1
70470: PUSH
70471: LD_INT 2
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 0
70480: PUSH
70481: LD_INT 2
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: PUSH
70488: LD_INT 1
70490: NEG
70491: PUSH
70492: LD_INT 1
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PUSH
70499: LD_INT 2
70501: NEG
70502: PUSH
70503: LD_INT 1
70505: NEG
70506: PUSH
70507: EMPTY
70508: LIST
70509: LIST
70510: PUSH
70511: LD_INT 2
70513: NEG
70514: PUSH
70515: LD_INT 2
70517: NEG
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 2
70525: NEG
70526: PUSH
70527: LD_INT 3
70529: NEG
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 2
70537: PUSH
70538: LD_INT 1
70540: NEG
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 3
70548: PUSH
70549: LD_INT 1
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 1
70558: PUSH
70559: LD_INT 3
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 1
70568: NEG
70569: PUSH
70570: LD_INT 2
70572: PUSH
70573: EMPTY
70574: LIST
70575: LIST
70576: PUSH
70577: LD_INT 3
70579: NEG
70580: PUSH
70581: LD_INT 2
70583: NEG
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: LIST
70593: LIST
70594: LIST
70595: LIST
70596: LIST
70597: LIST
70598: LIST
70599: LIST
70600: LIST
70601: LIST
70602: LIST
70603: LIST
70604: LIST
70605: LIST
70606: LIST
70607: LIST
70608: LIST
70609: LIST
70610: LIST
70611: LIST
70612: LIST
70613: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70614: LD_ADDR_VAR 0 30
70618: PUSH
70619: LD_INT 0
70621: PUSH
70622: LD_INT 0
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 0
70631: PUSH
70632: LD_INT 1
70634: NEG
70635: PUSH
70636: EMPTY
70637: LIST
70638: LIST
70639: PUSH
70640: LD_INT 1
70642: PUSH
70643: LD_INT 0
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: PUSH
70650: LD_INT 1
70652: PUSH
70653: LD_INT 1
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 0
70662: PUSH
70663: LD_INT 1
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: LD_INT 0
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 1
70683: NEG
70684: PUSH
70685: LD_INT 1
70687: NEG
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: PUSH
70693: LD_INT 1
70695: NEG
70696: PUSH
70697: LD_INT 2
70699: NEG
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: LD_INT 0
70707: PUSH
70708: LD_INT 2
70710: NEG
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: LD_INT 1
70718: PUSH
70719: LD_INT 1
70721: NEG
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: PUSH
70727: LD_INT 2
70729: PUSH
70730: LD_INT 0
70732: PUSH
70733: EMPTY
70734: LIST
70735: LIST
70736: PUSH
70737: LD_INT 2
70739: PUSH
70740: LD_INT 1
70742: PUSH
70743: EMPTY
70744: LIST
70745: LIST
70746: PUSH
70747: LD_INT 2
70749: PUSH
70750: LD_INT 2
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: PUSH
70757: LD_INT 1
70759: PUSH
70760: LD_INT 2
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PUSH
70767: LD_INT 1
70769: NEG
70770: PUSH
70771: LD_INT 1
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: PUSH
70778: LD_INT 2
70780: NEG
70781: PUSH
70782: LD_INT 0
70784: PUSH
70785: EMPTY
70786: LIST
70787: LIST
70788: PUSH
70789: LD_INT 2
70791: NEG
70792: PUSH
70793: LD_INT 1
70795: NEG
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 1
70803: NEG
70804: PUSH
70805: LD_INT 3
70807: NEG
70808: PUSH
70809: EMPTY
70810: LIST
70811: LIST
70812: PUSH
70813: LD_INT 1
70815: PUSH
70816: LD_INT 2
70818: NEG
70819: PUSH
70820: EMPTY
70821: LIST
70822: LIST
70823: PUSH
70824: LD_INT 3
70826: PUSH
70827: LD_INT 2
70829: PUSH
70830: EMPTY
70831: LIST
70832: LIST
70833: PUSH
70834: LD_INT 2
70836: PUSH
70837: LD_INT 3
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PUSH
70844: LD_INT 2
70846: NEG
70847: PUSH
70848: LD_INT 1
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 3
70857: NEG
70858: PUSH
70859: LD_INT 1
70861: NEG
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: LIST
70871: LIST
70872: LIST
70873: LIST
70874: LIST
70875: LIST
70876: LIST
70877: LIST
70878: LIST
70879: LIST
70880: LIST
70881: LIST
70882: LIST
70883: LIST
70884: LIST
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: LIST
70891: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70892: LD_ADDR_VAR 0 31
70896: PUSH
70897: LD_INT 0
70899: PUSH
70900: LD_INT 0
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 0
70909: PUSH
70910: LD_INT 1
70912: NEG
70913: PUSH
70914: EMPTY
70915: LIST
70916: LIST
70917: PUSH
70918: LD_INT 1
70920: PUSH
70921: LD_INT 0
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 1
70930: PUSH
70931: LD_INT 1
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: LD_INT 0
70940: PUSH
70941: LD_INT 1
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PUSH
70948: LD_INT 1
70950: NEG
70951: PUSH
70952: LD_INT 0
70954: PUSH
70955: EMPTY
70956: LIST
70957: LIST
70958: PUSH
70959: LD_INT 1
70961: NEG
70962: PUSH
70963: LD_INT 1
70965: NEG
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: PUSH
70971: LD_INT 1
70973: NEG
70974: PUSH
70975: LD_INT 2
70977: NEG
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: PUSH
70983: LD_INT 1
70985: PUSH
70986: LD_INT 1
70988: NEG
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 2
70996: PUSH
70997: LD_INT 0
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: LD_INT 2
71006: PUSH
71007: LD_INT 1
71009: PUSH
71010: EMPTY
71011: LIST
71012: LIST
71013: PUSH
71014: LD_INT 2
71016: PUSH
71017: LD_INT 2
71019: PUSH
71020: EMPTY
71021: LIST
71022: LIST
71023: PUSH
71024: LD_INT 1
71026: PUSH
71027: LD_INT 2
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 0
71036: PUSH
71037: LD_INT 2
71039: PUSH
71040: EMPTY
71041: LIST
71042: LIST
71043: PUSH
71044: LD_INT 1
71046: NEG
71047: PUSH
71048: LD_INT 1
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: PUSH
71055: LD_INT 2
71057: NEG
71058: PUSH
71059: LD_INT 1
71061: NEG
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: LD_INT 2
71069: NEG
71070: PUSH
71071: LD_INT 2
71073: NEG
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: PUSH
71079: LD_INT 2
71081: NEG
71082: PUSH
71083: LD_INT 3
71085: NEG
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 2
71093: PUSH
71094: LD_INT 1
71096: NEG
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PUSH
71102: LD_INT 3
71104: PUSH
71105: LD_INT 1
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 1
71114: PUSH
71115: LD_INT 3
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PUSH
71122: LD_INT 1
71124: NEG
71125: PUSH
71126: LD_INT 2
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PUSH
71133: LD_INT 3
71135: NEG
71136: PUSH
71137: LD_INT 2
71139: NEG
71140: PUSH
71141: EMPTY
71142: LIST
71143: LIST
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: LIST
71161: LIST
71162: LIST
71163: LIST
71164: LIST
71165: LIST
71166: LIST
71167: LIST
71168: LIST
71169: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71170: LD_ADDR_VAR 0 32
71174: PUSH
71175: LD_INT 0
71177: PUSH
71178: LD_INT 0
71180: PUSH
71181: EMPTY
71182: LIST
71183: LIST
71184: PUSH
71185: LD_INT 0
71187: PUSH
71188: LD_INT 1
71190: NEG
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: LD_INT 1
71198: PUSH
71199: LD_INT 0
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: PUSH
71206: LD_INT 1
71208: PUSH
71209: LD_INT 1
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 0
71218: PUSH
71219: LD_INT 1
71221: PUSH
71222: EMPTY
71223: LIST
71224: LIST
71225: PUSH
71226: LD_INT 1
71228: NEG
71229: PUSH
71230: LD_INT 0
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PUSH
71237: LD_INT 1
71239: NEG
71240: PUSH
71241: LD_INT 1
71243: NEG
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: LD_INT 1
71251: NEG
71252: PUSH
71253: LD_INT 2
71255: NEG
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 0
71263: PUSH
71264: LD_INT 2
71266: NEG
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: PUSH
71272: LD_INT 1
71274: PUSH
71275: LD_INT 1
71277: NEG
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PUSH
71283: LD_INT 2
71285: PUSH
71286: LD_INT 1
71288: PUSH
71289: EMPTY
71290: LIST
71291: LIST
71292: PUSH
71293: LD_INT 2
71295: PUSH
71296: LD_INT 2
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 1
71305: PUSH
71306: LD_INT 2
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 0
71315: PUSH
71316: LD_INT 2
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 1
71325: NEG
71326: PUSH
71327: LD_INT 1
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 2
71336: NEG
71337: PUSH
71338: LD_INT 0
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: LD_INT 2
71347: NEG
71348: PUSH
71349: LD_INT 1
71351: NEG
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: LD_INT 1
71359: NEG
71360: PUSH
71361: LD_INT 3
71363: NEG
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PUSH
71369: LD_INT 1
71371: PUSH
71372: LD_INT 2
71374: NEG
71375: PUSH
71376: EMPTY
71377: LIST
71378: LIST
71379: PUSH
71380: LD_INT 3
71382: PUSH
71383: LD_INT 2
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 2
71392: PUSH
71393: LD_INT 3
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: LD_INT 2
71402: NEG
71403: PUSH
71404: LD_INT 1
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: PUSH
71411: LD_INT 3
71413: NEG
71414: PUSH
71415: LD_INT 1
71417: NEG
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: LIST
71427: LIST
71428: LIST
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: LIST
71445: LIST
71446: LIST
71447: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71448: LD_ADDR_VAR 0 33
71452: PUSH
71453: LD_INT 0
71455: PUSH
71456: LD_INT 0
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: PUSH
71463: LD_INT 0
71465: PUSH
71466: LD_INT 1
71468: NEG
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: PUSH
71474: LD_INT 1
71476: PUSH
71477: LD_INT 0
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: PUSH
71484: LD_INT 1
71486: PUSH
71487: LD_INT 1
71489: PUSH
71490: EMPTY
71491: LIST
71492: LIST
71493: PUSH
71494: LD_INT 0
71496: PUSH
71497: LD_INT 1
71499: PUSH
71500: EMPTY
71501: LIST
71502: LIST
71503: PUSH
71504: LD_INT 1
71506: NEG
71507: PUSH
71508: LD_INT 0
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: LD_INT 1
71517: NEG
71518: PUSH
71519: LD_INT 1
71521: NEG
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PUSH
71527: LD_INT 1
71529: NEG
71530: PUSH
71531: LD_INT 2
71533: NEG
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PUSH
71539: LD_INT 1
71541: PUSH
71542: LD_INT 1
71544: NEG
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 2
71552: PUSH
71553: LD_INT 0
71555: PUSH
71556: EMPTY
71557: LIST
71558: LIST
71559: PUSH
71560: LD_INT 2
71562: PUSH
71563: LD_INT 1
71565: PUSH
71566: EMPTY
71567: LIST
71568: LIST
71569: PUSH
71570: LD_INT 1
71572: PUSH
71573: LD_INT 2
71575: PUSH
71576: EMPTY
71577: LIST
71578: LIST
71579: PUSH
71580: LD_INT 0
71582: PUSH
71583: LD_INT 2
71585: PUSH
71586: EMPTY
71587: LIST
71588: LIST
71589: PUSH
71590: LD_INT 1
71592: NEG
71593: PUSH
71594: LD_INT 1
71596: PUSH
71597: EMPTY
71598: LIST
71599: LIST
71600: PUSH
71601: LD_INT 2
71603: NEG
71604: PUSH
71605: LD_INT 0
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: PUSH
71612: LD_INT 2
71614: NEG
71615: PUSH
71616: LD_INT 1
71618: NEG
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: PUSH
71624: LD_INT 2
71626: NEG
71627: PUSH
71628: LD_INT 2
71630: NEG
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 2
71638: NEG
71639: PUSH
71640: LD_INT 3
71642: NEG
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 2
71650: PUSH
71651: LD_INT 1
71653: NEG
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: PUSH
71659: LD_INT 3
71661: PUSH
71662: LD_INT 1
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 1
71671: PUSH
71672: LD_INT 3
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: PUSH
71679: LD_INT 1
71681: NEG
71682: PUSH
71683: LD_INT 2
71685: PUSH
71686: EMPTY
71687: LIST
71688: LIST
71689: PUSH
71690: LD_INT 3
71692: NEG
71693: PUSH
71694: LD_INT 2
71696: NEG
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71727: LD_ADDR_VAR 0 34
71731: PUSH
71732: LD_INT 0
71734: PUSH
71735: LD_INT 0
71737: PUSH
71738: EMPTY
71739: LIST
71740: LIST
71741: PUSH
71742: LD_INT 0
71744: PUSH
71745: LD_INT 1
71747: NEG
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PUSH
71753: LD_INT 1
71755: PUSH
71756: LD_INT 0
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 1
71765: PUSH
71766: LD_INT 1
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: LD_INT 0
71775: PUSH
71776: LD_INT 1
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: PUSH
71783: LD_INT 1
71785: NEG
71786: PUSH
71787: LD_INT 0
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PUSH
71794: LD_INT 1
71796: NEG
71797: PUSH
71798: LD_INT 1
71800: NEG
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: LD_INT 1
71808: NEG
71809: PUSH
71810: LD_INT 2
71812: NEG
71813: PUSH
71814: EMPTY
71815: LIST
71816: LIST
71817: PUSH
71818: LD_INT 0
71820: PUSH
71821: LD_INT 2
71823: NEG
71824: PUSH
71825: EMPTY
71826: LIST
71827: LIST
71828: PUSH
71829: LD_INT 1
71831: PUSH
71832: LD_INT 1
71834: NEG
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: PUSH
71840: LD_INT 2
71842: PUSH
71843: LD_INT 1
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: PUSH
71850: LD_INT 2
71852: PUSH
71853: LD_INT 2
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 1
71862: PUSH
71863: LD_INT 2
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: PUSH
71870: LD_INT 1
71872: NEG
71873: PUSH
71874: LD_INT 1
71876: PUSH
71877: EMPTY
71878: LIST
71879: LIST
71880: PUSH
71881: LD_INT 2
71883: NEG
71884: PUSH
71885: LD_INT 0
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 2
71894: NEG
71895: PUSH
71896: LD_INT 1
71898: NEG
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 2
71906: NEG
71907: PUSH
71908: LD_INT 2
71910: NEG
71911: PUSH
71912: EMPTY
71913: LIST
71914: LIST
71915: PUSH
71916: LD_INT 1
71918: NEG
71919: PUSH
71920: LD_INT 3
71922: NEG
71923: PUSH
71924: EMPTY
71925: LIST
71926: LIST
71927: PUSH
71928: LD_INT 1
71930: PUSH
71931: LD_INT 2
71933: NEG
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PUSH
71939: LD_INT 3
71941: PUSH
71942: LD_INT 2
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 2
71951: PUSH
71952: LD_INT 3
71954: PUSH
71955: EMPTY
71956: LIST
71957: LIST
71958: PUSH
71959: LD_INT 2
71961: NEG
71962: PUSH
71963: LD_INT 1
71965: PUSH
71966: EMPTY
71967: LIST
71968: LIST
71969: PUSH
71970: LD_INT 3
71972: NEG
71973: PUSH
71974: LD_INT 1
71976: NEG
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: EMPTY
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: LIST
71989: LIST
71990: LIST
71991: LIST
71992: LIST
71993: LIST
71994: LIST
71995: LIST
71996: LIST
71997: LIST
71998: LIST
71999: LIST
72000: LIST
72001: LIST
72002: LIST
72003: LIST
72004: LIST
72005: LIST
72006: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72007: LD_ADDR_VAR 0 35
72011: PUSH
72012: LD_INT 0
72014: PUSH
72015: LD_INT 0
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: PUSH
72022: LD_INT 0
72024: PUSH
72025: LD_INT 1
72027: NEG
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 1
72035: PUSH
72036: LD_INT 0
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 1
72045: PUSH
72046: LD_INT 1
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 0
72055: PUSH
72056: LD_INT 1
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: LD_INT 1
72065: NEG
72066: PUSH
72067: LD_INT 0
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: LD_INT 1
72076: NEG
72077: PUSH
72078: LD_INT 1
72080: NEG
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: LD_INT 2
72088: PUSH
72089: LD_INT 1
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 2
72098: NEG
72099: PUSH
72100: LD_INT 1
72102: NEG
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PUSH
72108: EMPTY
72109: LIST
72110: LIST
72111: LIST
72112: LIST
72113: LIST
72114: LIST
72115: LIST
72116: LIST
72117: LIST
72118: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72119: LD_ADDR_VAR 0 36
72123: PUSH
72124: LD_INT 0
72126: PUSH
72127: LD_INT 0
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 0
72136: PUSH
72137: LD_INT 1
72139: NEG
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 1
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: PUSH
72155: LD_INT 1
72157: PUSH
72158: LD_INT 1
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: LD_INT 0
72167: PUSH
72168: LD_INT 1
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 1
72177: NEG
72178: PUSH
72179: LD_INT 0
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 1
72188: NEG
72189: PUSH
72190: LD_INT 1
72192: NEG
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 1
72200: NEG
72201: PUSH
72202: LD_INT 2
72204: NEG
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 1
72212: PUSH
72213: LD_INT 2
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: LIST
72224: LIST
72225: LIST
72226: LIST
72227: LIST
72228: LIST
72229: LIST
72230: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72231: LD_ADDR_VAR 0 37
72235: PUSH
72236: LD_INT 0
72238: PUSH
72239: LD_INT 0
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 0
72248: PUSH
72249: LD_INT 1
72251: NEG
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 1
72259: PUSH
72260: LD_INT 0
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 1
72269: PUSH
72270: LD_INT 1
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: LD_INT 1
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 1
72289: NEG
72290: PUSH
72291: LD_INT 0
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 1
72300: NEG
72301: PUSH
72302: LD_INT 1
72304: NEG
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: LD_INT 1
72312: PUSH
72313: LD_INT 1
72315: NEG
72316: PUSH
72317: EMPTY
72318: LIST
72319: LIST
72320: PUSH
72321: LD_INT 1
72323: NEG
72324: PUSH
72325: LD_INT 1
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: LIST
72339: LIST
72340: LIST
72341: LIST
72342: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72343: LD_ADDR_VAR 0 38
72347: PUSH
72348: LD_INT 0
72350: PUSH
72351: LD_INT 0
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PUSH
72358: LD_INT 0
72360: PUSH
72361: LD_INT 1
72363: NEG
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: PUSH
72369: LD_INT 1
72371: PUSH
72372: LD_INT 0
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: PUSH
72379: LD_INT 1
72381: PUSH
72382: LD_INT 1
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 0
72391: PUSH
72392: LD_INT 1
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 1
72401: NEG
72402: PUSH
72403: LD_INT 0
72405: PUSH
72406: EMPTY
72407: LIST
72408: LIST
72409: PUSH
72410: LD_INT 1
72412: NEG
72413: PUSH
72414: LD_INT 1
72416: NEG
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 2
72424: PUSH
72425: LD_INT 1
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: LD_INT 2
72434: NEG
72435: PUSH
72436: LD_INT 1
72438: NEG
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72455: LD_ADDR_VAR 0 39
72459: PUSH
72460: LD_INT 0
72462: PUSH
72463: LD_INT 0
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: LD_INT 1
72475: NEG
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: PUSH
72481: LD_INT 1
72483: PUSH
72484: LD_INT 0
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: PUSH
72491: LD_INT 1
72493: PUSH
72494: LD_INT 1
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 0
72503: PUSH
72504: LD_INT 1
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: LD_INT 1
72513: NEG
72514: PUSH
72515: LD_INT 0
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 1
72524: NEG
72525: PUSH
72526: LD_INT 1
72528: NEG
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 1
72536: NEG
72537: PUSH
72538: LD_INT 2
72540: NEG
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 1
72548: PUSH
72549: LD_INT 2
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: LIST
72560: LIST
72561: LIST
72562: LIST
72563: LIST
72564: LIST
72565: LIST
72566: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72567: LD_ADDR_VAR 0 40
72571: PUSH
72572: LD_INT 0
72574: PUSH
72575: LD_INT 0
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: LD_INT 0
72584: PUSH
72585: LD_INT 1
72587: NEG
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PUSH
72593: LD_INT 1
72595: PUSH
72596: LD_INT 0
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 1
72605: PUSH
72606: LD_INT 1
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: LD_INT 0
72615: PUSH
72616: LD_INT 1
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: LD_INT 1
72625: NEG
72626: PUSH
72627: LD_INT 0
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 1
72636: NEG
72637: PUSH
72638: LD_INT 1
72640: NEG
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: PUSH
72646: LD_INT 1
72648: PUSH
72649: LD_INT 1
72651: NEG
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: PUSH
72657: LD_INT 1
72659: NEG
72660: PUSH
72661: LD_INT 1
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72679: LD_ADDR_VAR 0 41
72683: PUSH
72684: LD_INT 0
72686: PUSH
72687: LD_INT 0
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 0
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 1
72707: PUSH
72708: LD_INT 0
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 1
72717: PUSH
72718: LD_INT 1
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 0
72727: PUSH
72728: LD_INT 1
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PUSH
72735: LD_INT 1
72737: NEG
72738: PUSH
72739: LD_INT 0
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 1
72748: NEG
72749: PUSH
72750: LD_INT 1
72752: NEG
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 1
72760: NEG
72761: PUSH
72762: LD_INT 2
72764: NEG
72765: PUSH
72766: EMPTY
72767: LIST
72768: LIST
72769: PUSH
72770: LD_INT 1
72772: PUSH
72773: LD_INT 1
72775: NEG
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 2
72783: PUSH
72784: LD_INT 0
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 2
72793: PUSH
72794: LD_INT 1
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 2
72803: PUSH
72804: LD_INT 2
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 1
72813: PUSH
72814: LD_INT 2
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PUSH
72821: LD_INT 1
72823: NEG
72824: PUSH
72825: LD_INT 1
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 2
72834: NEG
72835: PUSH
72836: LD_INT 0
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: PUSH
72843: LD_INT 2
72845: NEG
72846: PUSH
72847: LD_INT 1
72849: NEG
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 2
72857: NEG
72858: PUSH
72859: LD_INT 2
72861: NEG
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 2
72869: NEG
72870: PUSH
72871: LD_INT 3
72873: NEG
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: LD_INT 2
72881: PUSH
72882: LD_INT 1
72884: NEG
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: PUSH
72890: LD_INT 3
72892: PUSH
72893: LD_INT 0
72895: PUSH
72896: EMPTY
72897: LIST
72898: LIST
72899: PUSH
72900: LD_INT 3
72902: PUSH
72903: LD_INT 1
72905: PUSH
72906: EMPTY
72907: LIST
72908: LIST
72909: PUSH
72910: LD_INT 3
72912: PUSH
72913: LD_INT 2
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: PUSH
72920: LD_INT 3
72922: PUSH
72923: LD_INT 3
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 2
72932: PUSH
72933: LD_INT 3
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: LD_INT 2
72942: NEG
72943: PUSH
72944: LD_INT 1
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 3
72953: NEG
72954: PUSH
72955: LD_INT 0
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 3
72964: NEG
72965: PUSH
72966: LD_INT 1
72968: NEG
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 3
72976: NEG
72977: PUSH
72978: LD_INT 2
72980: NEG
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 3
72988: NEG
72989: PUSH
72990: LD_INT 3
72992: NEG
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: LIST
73015: LIST
73016: LIST
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: LIST
73022: LIST
73023: LIST
73024: LIST
73025: LIST
73026: LIST
73027: LIST
73028: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73029: LD_ADDR_VAR 0 42
73033: PUSH
73034: LD_INT 0
73036: PUSH
73037: LD_INT 0
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: LD_INT 0
73046: PUSH
73047: LD_INT 1
73049: NEG
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 1
73057: PUSH
73058: LD_INT 0
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 1
73067: PUSH
73068: LD_INT 1
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 0
73077: PUSH
73078: LD_INT 1
73080: PUSH
73081: EMPTY
73082: LIST
73083: LIST
73084: PUSH
73085: LD_INT 1
73087: NEG
73088: PUSH
73089: LD_INT 0
73091: PUSH
73092: EMPTY
73093: LIST
73094: LIST
73095: PUSH
73096: LD_INT 1
73098: NEG
73099: PUSH
73100: LD_INT 1
73102: NEG
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 1
73110: NEG
73111: PUSH
73112: LD_INT 2
73114: NEG
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: PUSH
73120: LD_INT 0
73122: PUSH
73123: LD_INT 2
73125: NEG
73126: PUSH
73127: EMPTY
73128: LIST
73129: LIST
73130: PUSH
73131: LD_INT 1
73133: PUSH
73134: LD_INT 1
73136: NEG
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 2
73144: PUSH
73145: LD_INT 1
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PUSH
73152: LD_INT 2
73154: PUSH
73155: LD_INT 2
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: LD_INT 1
73164: PUSH
73165: LD_INT 2
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 0
73174: PUSH
73175: LD_INT 2
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 1
73184: NEG
73185: PUSH
73186: LD_INT 1
73188: PUSH
73189: EMPTY
73190: LIST
73191: LIST
73192: PUSH
73193: LD_INT 2
73195: NEG
73196: PUSH
73197: LD_INT 1
73199: NEG
73200: PUSH
73201: EMPTY
73202: LIST
73203: LIST
73204: PUSH
73205: LD_INT 2
73207: NEG
73208: PUSH
73209: LD_INT 2
73211: NEG
73212: PUSH
73213: EMPTY
73214: LIST
73215: LIST
73216: PUSH
73217: LD_INT 2
73219: NEG
73220: PUSH
73221: LD_INT 3
73223: NEG
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PUSH
73229: LD_INT 1
73231: NEG
73232: PUSH
73233: LD_INT 3
73235: NEG
73236: PUSH
73237: EMPTY
73238: LIST
73239: LIST
73240: PUSH
73241: LD_INT 0
73243: PUSH
73244: LD_INT 3
73246: NEG
73247: PUSH
73248: EMPTY
73249: LIST
73250: LIST
73251: PUSH
73252: LD_INT 1
73254: PUSH
73255: LD_INT 2
73257: NEG
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 3
73265: PUSH
73266: LD_INT 2
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PUSH
73273: LD_INT 3
73275: PUSH
73276: LD_INT 3
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: LD_INT 2
73285: PUSH
73286: LD_INT 3
73288: PUSH
73289: EMPTY
73290: LIST
73291: LIST
73292: PUSH
73293: LD_INT 1
73295: PUSH
73296: LD_INT 3
73298: PUSH
73299: EMPTY
73300: LIST
73301: LIST
73302: PUSH
73303: LD_INT 0
73305: PUSH
73306: LD_INT 3
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 1
73315: NEG
73316: PUSH
73317: LD_INT 2
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: PUSH
73324: LD_INT 3
73326: NEG
73327: PUSH
73328: LD_INT 2
73330: NEG
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: PUSH
73336: LD_INT 3
73338: NEG
73339: PUSH
73340: LD_INT 3
73342: NEG
73343: PUSH
73344: EMPTY
73345: LIST
73346: LIST
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: LIST
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73379: LD_ADDR_VAR 0 43
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: PUSH
73394: LD_INT 0
73396: PUSH
73397: LD_INT 1
73399: NEG
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: PUSH
73405: LD_INT 1
73407: PUSH
73408: LD_INT 0
73410: PUSH
73411: EMPTY
73412: LIST
73413: LIST
73414: PUSH
73415: LD_INT 1
73417: PUSH
73418: LD_INT 1
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PUSH
73425: LD_INT 0
73427: PUSH
73428: LD_INT 1
73430: PUSH
73431: EMPTY
73432: LIST
73433: LIST
73434: PUSH
73435: LD_INT 1
73437: NEG
73438: PUSH
73439: LD_INT 0
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: LD_INT 1
73448: NEG
73449: PUSH
73450: LD_INT 1
73452: NEG
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: PUSH
73458: LD_INT 1
73460: NEG
73461: PUSH
73462: LD_INT 2
73464: NEG
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 0
73472: PUSH
73473: LD_INT 2
73475: NEG
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 1
73483: PUSH
73484: LD_INT 1
73486: NEG
73487: PUSH
73488: EMPTY
73489: LIST
73490: LIST
73491: PUSH
73492: LD_INT 2
73494: PUSH
73495: LD_INT 0
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: LD_INT 2
73504: PUSH
73505: LD_INT 1
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: PUSH
73512: LD_INT 1
73514: PUSH
73515: LD_INT 2
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 0
73524: PUSH
73525: LD_INT 2
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PUSH
73532: LD_INT 1
73534: NEG
73535: PUSH
73536: LD_INT 1
73538: PUSH
73539: EMPTY
73540: LIST
73541: LIST
73542: PUSH
73543: LD_INT 2
73545: NEG
73546: PUSH
73547: LD_INT 0
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: PUSH
73554: LD_INT 2
73556: NEG
73557: PUSH
73558: LD_INT 1
73560: NEG
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 1
73568: NEG
73569: PUSH
73570: LD_INT 3
73572: NEG
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 0
73580: PUSH
73581: LD_INT 3
73583: NEG
73584: PUSH
73585: EMPTY
73586: LIST
73587: LIST
73588: PUSH
73589: LD_INT 1
73591: PUSH
73592: LD_INT 2
73594: NEG
73595: PUSH
73596: EMPTY
73597: LIST
73598: LIST
73599: PUSH
73600: LD_INT 2
73602: PUSH
73603: LD_INT 1
73605: NEG
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: PUSH
73611: LD_INT 3
73613: PUSH
73614: LD_INT 0
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: LD_INT 3
73623: PUSH
73624: LD_INT 1
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PUSH
73631: LD_INT 1
73633: PUSH
73634: LD_INT 3
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 0
73643: PUSH
73644: LD_INT 3
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 1
73653: NEG
73654: PUSH
73655: LD_INT 2
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: PUSH
73662: LD_INT 2
73664: NEG
73665: PUSH
73666: LD_INT 1
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: LD_INT 3
73675: NEG
73676: PUSH
73677: LD_INT 0
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 3
73686: NEG
73687: PUSH
73688: LD_INT 1
73690: NEG
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: LIST
73704: LIST
73705: LIST
73706: LIST
73707: LIST
73708: LIST
73709: LIST
73710: LIST
73711: LIST
73712: LIST
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: LIST
73718: LIST
73719: LIST
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: LIST
73725: LIST
73726: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73727: LD_ADDR_VAR 0 44
73731: PUSH
73732: LD_INT 0
73734: PUSH
73735: LD_INT 0
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 0
73744: PUSH
73745: LD_INT 1
73747: NEG
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 1
73755: PUSH
73756: LD_INT 0
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: LD_INT 1
73765: PUSH
73766: LD_INT 1
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: PUSH
73773: LD_INT 0
73775: PUSH
73776: LD_INT 1
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: LD_INT 1
73785: NEG
73786: PUSH
73787: LD_INT 0
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 1
73796: NEG
73797: PUSH
73798: LD_INT 1
73800: NEG
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 1
73808: NEG
73809: PUSH
73810: LD_INT 2
73812: NEG
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: PUSH
73818: LD_INT 1
73820: PUSH
73821: LD_INT 1
73823: NEG
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 2
73831: PUSH
73832: LD_INT 0
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 2
73841: PUSH
73842: LD_INT 1
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 2
73851: PUSH
73852: LD_INT 2
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 1
73861: PUSH
73862: LD_INT 2
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 1
73871: NEG
73872: PUSH
73873: LD_INT 1
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 2
73882: NEG
73883: PUSH
73884: LD_INT 0
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 2
73893: NEG
73894: PUSH
73895: LD_INT 1
73897: NEG
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 2
73905: NEG
73906: PUSH
73907: LD_INT 2
73909: NEG
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 2
73917: NEG
73918: PUSH
73919: LD_INT 3
73921: NEG
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 2
73929: PUSH
73930: LD_INT 1
73932: NEG
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: LD_INT 3
73940: PUSH
73941: LD_INT 0
73943: PUSH
73944: EMPTY
73945: LIST
73946: LIST
73947: PUSH
73948: LD_INT 3
73950: PUSH
73951: LD_INT 1
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: LD_INT 3
73960: PUSH
73961: LD_INT 2
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 3
73970: PUSH
73971: LD_INT 3
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 2
73980: PUSH
73981: LD_INT 3
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: LD_INT 2
73990: NEG
73991: PUSH
73992: LD_INT 1
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 3
74001: NEG
74002: PUSH
74003: LD_INT 0
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: LD_INT 3
74012: NEG
74013: PUSH
74014: LD_INT 1
74016: NEG
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 3
74024: NEG
74025: PUSH
74026: LD_INT 2
74028: NEG
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 3
74036: NEG
74037: PUSH
74038: LD_INT 3
74040: NEG
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: LIST
74075: LIST
74076: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74077: LD_ADDR_VAR 0 45
74081: PUSH
74082: LD_INT 0
74084: PUSH
74085: LD_INT 0
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: PUSH
74092: LD_INT 0
74094: PUSH
74095: LD_INT 1
74097: NEG
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 1
74105: PUSH
74106: LD_INT 0
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: PUSH
74113: LD_INT 1
74115: PUSH
74116: LD_INT 1
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: LD_INT 1
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: PUSH
74133: LD_INT 1
74135: NEG
74136: PUSH
74137: LD_INT 0
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PUSH
74144: LD_INT 1
74146: NEG
74147: PUSH
74148: LD_INT 1
74150: NEG
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: LD_INT 1
74158: NEG
74159: PUSH
74160: LD_INT 2
74162: NEG
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 0
74170: PUSH
74171: LD_INT 2
74173: NEG
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: PUSH
74179: LD_INT 1
74181: PUSH
74182: LD_INT 1
74184: NEG
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: LD_INT 2
74192: PUSH
74193: LD_INT 1
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: LD_INT 2
74202: PUSH
74203: LD_INT 2
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 1
74212: PUSH
74213: LD_INT 2
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: LD_INT 0
74222: PUSH
74223: LD_INT 2
74225: PUSH
74226: EMPTY
74227: LIST
74228: LIST
74229: PUSH
74230: LD_INT 1
74232: NEG
74233: PUSH
74234: LD_INT 1
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PUSH
74241: LD_INT 2
74243: NEG
74244: PUSH
74245: LD_INT 1
74247: NEG
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 2
74255: NEG
74256: PUSH
74257: LD_INT 2
74259: NEG
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: PUSH
74265: LD_INT 2
74267: NEG
74268: PUSH
74269: LD_INT 3
74271: NEG
74272: PUSH
74273: EMPTY
74274: LIST
74275: LIST
74276: PUSH
74277: LD_INT 1
74279: NEG
74280: PUSH
74281: LD_INT 3
74283: NEG
74284: PUSH
74285: EMPTY
74286: LIST
74287: LIST
74288: PUSH
74289: LD_INT 0
74291: PUSH
74292: LD_INT 3
74294: NEG
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: PUSH
74300: LD_INT 1
74302: PUSH
74303: LD_INT 2
74305: NEG
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 3
74313: PUSH
74314: LD_INT 2
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 3
74323: PUSH
74324: LD_INT 3
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 2
74333: PUSH
74334: LD_INT 3
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 1
74343: PUSH
74344: LD_INT 3
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: PUSH
74351: LD_INT 0
74353: PUSH
74354: LD_INT 3
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: PUSH
74361: LD_INT 1
74363: NEG
74364: PUSH
74365: LD_INT 2
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 3
74374: NEG
74375: PUSH
74376: LD_INT 2
74378: NEG
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 3
74386: NEG
74387: PUSH
74388: LD_INT 3
74390: NEG
74391: PUSH
74392: EMPTY
74393: LIST
74394: LIST
74395: PUSH
74396: EMPTY
74397: LIST
74398: LIST
74399: LIST
74400: LIST
74401: LIST
74402: LIST
74403: LIST
74404: LIST
74405: LIST
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: LIST
74425: LIST
74426: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74427: LD_ADDR_VAR 0 46
74431: PUSH
74432: LD_INT 0
74434: PUSH
74435: LD_INT 0
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: PUSH
74442: LD_INT 0
74444: PUSH
74445: LD_INT 1
74447: NEG
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: LD_INT 1
74455: PUSH
74456: LD_INT 0
74458: PUSH
74459: EMPTY
74460: LIST
74461: LIST
74462: PUSH
74463: LD_INT 1
74465: PUSH
74466: LD_INT 1
74468: PUSH
74469: EMPTY
74470: LIST
74471: LIST
74472: PUSH
74473: LD_INT 0
74475: PUSH
74476: LD_INT 1
74478: PUSH
74479: EMPTY
74480: LIST
74481: LIST
74482: PUSH
74483: LD_INT 1
74485: NEG
74486: PUSH
74487: LD_INT 0
74489: PUSH
74490: EMPTY
74491: LIST
74492: LIST
74493: PUSH
74494: LD_INT 1
74496: NEG
74497: PUSH
74498: LD_INT 1
74500: NEG
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: LD_INT 1
74508: NEG
74509: PUSH
74510: LD_INT 2
74512: NEG
74513: PUSH
74514: EMPTY
74515: LIST
74516: LIST
74517: PUSH
74518: LD_INT 0
74520: PUSH
74521: LD_INT 2
74523: NEG
74524: PUSH
74525: EMPTY
74526: LIST
74527: LIST
74528: PUSH
74529: LD_INT 1
74531: PUSH
74532: LD_INT 1
74534: NEG
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 2
74542: PUSH
74543: LD_INT 0
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 2
74552: PUSH
74553: LD_INT 1
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: LD_INT 1
74562: PUSH
74563: LD_INT 2
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PUSH
74570: LD_INT 0
74572: PUSH
74573: LD_INT 2
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: PUSH
74580: LD_INT 1
74582: NEG
74583: PUSH
74584: LD_INT 1
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: PUSH
74591: LD_INT 2
74593: NEG
74594: PUSH
74595: LD_INT 0
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PUSH
74602: LD_INT 2
74604: NEG
74605: PUSH
74606: LD_INT 1
74608: NEG
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: LD_INT 1
74616: NEG
74617: PUSH
74618: LD_INT 3
74620: NEG
74621: PUSH
74622: EMPTY
74623: LIST
74624: LIST
74625: PUSH
74626: LD_INT 0
74628: PUSH
74629: LD_INT 3
74631: NEG
74632: PUSH
74633: EMPTY
74634: LIST
74635: LIST
74636: PUSH
74637: LD_INT 1
74639: PUSH
74640: LD_INT 2
74642: NEG
74643: PUSH
74644: EMPTY
74645: LIST
74646: LIST
74647: PUSH
74648: LD_INT 2
74650: PUSH
74651: LD_INT 1
74653: NEG
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: PUSH
74659: LD_INT 3
74661: PUSH
74662: LD_INT 0
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: PUSH
74669: LD_INT 3
74671: PUSH
74672: LD_INT 1
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: PUSH
74679: LD_INT 1
74681: PUSH
74682: LD_INT 3
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 0
74691: PUSH
74692: LD_INT 3
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 1
74701: NEG
74702: PUSH
74703: LD_INT 2
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 2
74712: NEG
74713: PUSH
74714: LD_INT 1
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PUSH
74721: LD_INT 3
74723: NEG
74724: PUSH
74725: LD_INT 0
74727: PUSH
74728: EMPTY
74729: LIST
74730: LIST
74731: PUSH
74732: LD_INT 3
74734: NEG
74735: PUSH
74736: LD_INT 1
74738: NEG
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: LIST
74750: LIST
74751: LIST
74752: LIST
74753: LIST
74754: LIST
74755: LIST
74756: LIST
74757: LIST
74758: LIST
74759: LIST
74760: LIST
74761: LIST
74762: LIST
74763: LIST
74764: LIST
74765: LIST
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74775: LD_ADDR_VAR 0 47
74779: PUSH
74780: LD_INT 0
74782: PUSH
74783: LD_INT 0
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 0
74792: PUSH
74793: LD_INT 1
74795: NEG
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 1
74803: PUSH
74804: LD_INT 0
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 1
74813: PUSH
74814: LD_INT 1
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: LD_INT 1
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 1
74833: NEG
74834: PUSH
74835: LD_INT 0
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 1
74844: NEG
74845: PUSH
74846: LD_INT 1
74848: NEG
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: LD_INT 1
74856: NEG
74857: PUSH
74858: LD_INT 2
74860: NEG
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: PUSH
74866: LD_INT 0
74868: PUSH
74869: LD_INT 2
74871: NEG
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 1
74879: PUSH
74880: LD_INT 1
74882: NEG
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: PUSH
74888: LD_INT 2
74890: NEG
74891: PUSH
74892: LD_INT 1
74894: NEG
74895: PUSH
74896: EMPTY
74897: LIST
74898: LIST
74899: PUSH
74900: LD_INT 2
74902: NEG
74903: PUSH
74904: LD_INT 2
74906: NEG
74907: PUSH
74908: EMPTY
74909: LIST
74910: LIST
74911: PUSH
74912: EMPTY
74913: LIST
74914: LIST
74915: LIST
74916: LIST
74917: LIST
74918: LIST
74919: LIST
74920: LIST
74921: LIST
74922: LIST
74923: LIST
74924: LIST
74925: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74926: LD_ADDR_VAR 0 48
74930: PUSH
74931: LD_INT 0
74933: PUSH
74934: LD_INT 0
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: PUSH
74941: LD_INT 0
74943: PUSH
74944: LD_INT 1
74946: NEG
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 1
74954: PUSH
74955: LD_INT 0
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: PUSH
74962: LD_INT 1
74964: PUSH
74965: LD_INT 1
74967: PUSH
74968: EMPTY
74969: LIST
74970: LIST
74971: PUSH
74972: LD_INT 0
74974: PUSH
74975: LD_INT 1
74977: PUSH
74978: EMPTY
74979: LIST
74980: LIST
74981: PUSH
74982: LD_INT 1
74984: NEG
74985: PUSH
74986: LD_INT 0
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: PUSH
74993: LD_INT 1
74995: NEG
74996: PUSH
74997: LD_INT 1
74999: NEG
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: LD_INT 1
75007: NEG
75008: PUSH
75009: LD_INT 2
75011: NEG
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 0
75019: PUSH
75020: LD_INT 2
75022: NEG
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: PUSH
75028: LD_INT 1
75030: PUSH
75031: LD_INT 1
75033: NEG
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PUSH
75039: LD_INT 2
75041: PUSH
75042: LD_INT 0
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: LD_INT 2
75051: PUSH
75052: LD_INT 1
75054: PUSH
75055: EMPTY
75056: LIST
75057: LIST
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: LIST
75063: LIST
75064: LIST
75065: LIST
75066: LIST
75067: LIST
75068: LIST
75069: LIST
75070: LIST
75071: LIST
75072: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75073: LD_ADDR_VAR 0 49
75077: PUSH
75078: LD_INT 0
75080: PUSH
75081: LD_INT 0
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: LD_INT 0
75090: PUSH
75091: LD_INT 1
75093: NEG
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: PUSH
75099: LD_INT 1
75101: PUSH
75102: LD_INT 0
75104: PUSH
75105: EMPTY
75106: LIST
75107: LIST
75108: PUSH
75109: LD_INT 1
75111: PUSH
75112: LD_INT 1
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PUSH
75119: LD_INT 0
75121: PUSH
75122: LD_INT 1
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 1
75131: NEG
75132: PUSH
75133: LD_INT 0
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: PUSH
75140: LD_INT 1
75142: NEG
75143: PUSH
75144: LD_INT 1
75146: NEG
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: LD_INT 1
75154: PUSH
75155: LD_INT 1
75157: NEG
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PUSH
75163: LD_INT 2
75165: PUSH
75166: LD_INT 0
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: LD_INT 2
75175: PUSH
75176: LD_INT 1
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 2
75185: PUSH
75186: LD_INT 2
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 1
75195: PUSH
75196: LD_INT 2
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: LIST
75212: LIST
75213: LIST
75214: LIST
75215: LIST
75216: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75217: LD_ADDR_VAR 0 50
75221: PUSH
75222: LD_INT 0
75224: PUSH
75225: LD_INT 0
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 0
75234: PUSH
75235: LD_INT 1
75237: NEG
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 1
75245: PUSH
75246: LD_INT 0
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: LD_INT 1
75255: PUSH
75256: LD_INT 1
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: PUSH
75263: LD_INT 0
75265: PUSH
75266: LD_INT 1
75268: PUSH
75269: EMPTY
75270: LIST
75271: LIST
75272: PUSH
75273: LD_INT 1
75275: NEG
75276: PUSH
75277: LD_INT 0
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: PUSH
75284: LD_INT 1
75286: NEG
75287: PUSH
75288: LD_INT 1
75290: NEG
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: LD_INT 2
75298: PUSH
75299: LD_INT 1
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 2
75308: PUSH
75309: LD_INT 2
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PUSH
75316: LD_INT 1
75318: PUSH
75319: LD_INT 2
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 0
75328: PUSH
75329: LD_INT 2
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 1
75338: NEG
75339: PUSH
75340: LD_INT 1
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75361: LD_ADDR_VAR 0 51
75365: PUSH
75366: LD_INT 0
75368: PUSH
75369: LD_INT 0
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 0
75378: PUSH
75379: LD_INT 1
75381: NEG
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PUSH
75387: LD_INT 1
75389: PUSH
75390: LD_INT 0
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 1
75399: PUSH
75400: LD_INT 1
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 0
75409: PUSH
75410: LD_INT 1
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: LD_INT 1
75419: NEG
75420: PUSH
75421: LD_INT 0
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 1
75430: NEG
75431: PUSH
75432: LD_INT 1
75434: NEG
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 1
75442: PUSH
75443: LD_INT 2
75445: PUSH
75446: EMPTY
75447: LIST
75448: LIST
75449: PUSH
75450: LD_INT 0
75452: PUSH
75453: LD_INT 2
75455: PUSH
75456: EMPTY
75457: LIST
75458: LIST
75459: PUSH
75460: LD_INT 1
75462: NEG
75463: PUSH
75464: LD_INT 1
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 2
75473: NEG
75474: PUSH
75475: LD_INT 0
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PUSH
75482: LD_INT 2
75484: NEG
75485: PUSH
75486: LD_INT 1
75488: NEG
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: LIST
75500: LIST
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: LIST
75506: LIST
75507: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75508: LD_ADDR_VAR 0 52
75512: PUSH
75513: LD_INT 0
75515: PUSH
75516: LD_INT 0
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: PUSH
75523: LD_INT 0
75525: PUSH
75526: LD_INT 1
75528: NEG
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 1
75536: PUSH
75537: LD_INT 0
75539: PUSH
75540: EMPTY
75541: LIST
75542: LIST
75543: PUSH
75544: LD_INT 1
75546: PUSH
75547: LD_INT 1
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: LD_INT 1
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 1
75566: NEG
75567: PUSH
75568: LD_INT 0
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 1
75577: NEG
75578: PUSH
75579: LD_INT 1
75581: NEG
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 1
75589: NEG
75590: PUSH
75591: LD_INT 2
75593: NEG
75594: PUSH
75595: EMPTY
75596: LIST
75597: LIST
75598: PUSH
75599: LD_INT 1
75601: NEG
75602: PUSH
75603: LD_INT 1
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: PUSH
75610: LD_INT 2
75612: NEG
75613: PUSH
75614: LD_INT 0
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 2
75623: NEG
75624: PUSH
75625: LD_INT 1
75627: NEG
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: LD_INT 2
75635: NEG
75636: PUSH
75637: LD_INT 2
75639: NEG
75640: PUSH
75641: EMPTY
75642: LIST
75643: LIST
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: LIST
75649: LIST
75650: LIST
75651: LIST
75652: LIST
75653: LIST
75654: LIST
75655: LIST
75656: LIST
75657: LIST
75658: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75659: LD_ADDR_VAR 0 53
75663: PUSH
75664: LD_INT 0
75666: PUSH
75667: LD_INT 0
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: LD_INT 0
75676: PUSH
75677: LD_INT 1
75679: NEG
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 1
75687: PUSH
75688: LD_INT 0
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: LD_INT 1
75697: PUSH
75698: LD_INT 1
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: LD_INT 0
75707: PUSH
75708: LD_INT 1
75710: PUSH
75711: EMPTY
75712: LIST
75713: LIST
75714: PUSH
75715: LD_INT 1
75717: NEG
75718: PUSH
75719: LD_INT 0
75721: PUSH
75722: EMPTY
75723: LIST
75724: LIST
75725: PUSH
75726: LD_INT 1
75728: NEG
75729: PUSH
75730: LD_INT 1
75732: NEG
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: PUSH
75738: LD_INT 1
75740: NEG
75741: PUSH
75742: LD_INT 2
75744: NEG
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 0
75752: PUSH
75753: LD_INT 2
75755: NEG
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: PUSH
75761: LD_INT 1
75763: PUSH
75764: LD_INT 1
75766: NEG
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 2
75774: PUSH
75775: LD_INT 0
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: PUSH
75782: LD_INT 2
75784: PUSH
75785: LD_INT 1
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: LD_INT 2
75794: PUSH
75795: LD_INT 2
75797: PUSH
75798: EMPTY
75799: LIST
75800: LIST
75801: PUSH
75802: LD_INT 1
75804: PUSH
75805: LD_INT 2
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: PUSH
75812: LD_INT 0
75814: PUSH
75815: LD_INT 2
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PUSH
75822: LD_INT 1
75824: NEG
75825: PUSH
75826: LD_INT 1
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PUSH
75833: LD_INT 2
75835: NEG
75836: PUSH
75837: LD_INT 0
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: LD_INT 2
75846: NEG
75847: PUSH
75848: LD_INT 1
75850: NEG
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: PUSH
75856: LD_INT 2
75858: NEG
75859: PUSH
75860: LD_INT 2
75862: NEG
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PUSH
75868: EMPTY
75869: LIST
75870: LIST
75871: LIST
75872: LIST
75873: LIST
75874: LIST
75875: LIST
75876: LIST
75877: LIST
75878: LIST
75879: LIST
75880: LIST
75881: LIST
75882: LIST
75883: LIST
75884: LIST
75885: LIST
75886: LIST
75887: LIST
75888: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75889: LD_ADDR_VAR 0 54
75893: PUSH
75894: LD_INT 0
75896: PUSH
75897: LD_INT 0
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: PUSH
75904: LD_INT 0
75906: PUSH
75907: LD_INT 1
75909: NEG
75910: PUSH
75911: EMPTY
75912: LIST
75913: LIST
75914: PUSH
75915: LD_INT 1
75917: PUSH
75918: LD_INT 0
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: PUSH
75925: LD_INT 1
75927: PUSH
75928: LD_INT 1
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 0
75937: PUSH
75938: LD_INT 1
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 1
75947: NEG
75948: PUSH
75949: LD_INT 0
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 1
75958: NEG
75959: PUSH
75960: LD_INT 1
75962: NEG
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: PUSH
75968: LD_INT 1
75970: NEG
75971: PUSH
75972: LD_INT 2
75974: NEG
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: LD_INT 0
75982: PUSH
75983: LD_INT 2
75985: NEG
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PUSH
75991: LD_INT 1
75993: PUSH
75994: LD_INT 1
75996: NEG
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: LD_INT 2
76004: PUSH
76005: LD_INT 0
76007: PUSH
76008: EMPTY
76009: LIST
76010: LIST
76011: PUSH
76012: LD_INT 2
76014: PUSH
76015: LD_INT 1
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 2
76024: PUSH
76025: LD_INT 2
76027: PUSH
76028: EMPTY
76029: LIST
76030: LIST
76031: PUSH
76032: LD_INT 1
76034: PUSH
76035: LD_INT 2
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 0
76044: PUSH
76045: LD_INT 2
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: LD_INT 1
76054: NEG
76055: PUSH
76056: LD_INT 1
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 2
76065: NEG
76066: PUSH
76067: LD_INT 0
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 2
76076: NEG
76077: PUSH
76078: LD_INT 1
76080: NEG
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: PUSH
76086: LD_INT 2
76088: NEG
76089: PUSH
76090: LD_INT 2
76092: NEG
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: PUSH
76098: EMPTY
76099: LIST
76100: LIST
76101: LIST
76102: LIST
76103: LIST
76104: LIST
76105: LIST
76106: LIST
76107: LIST
76108: LIST
76109: LIST
76110: LIST
76111: LIST
76112: LIST
76113: LIST
76114: LIST
76115: LIST
76116: LIST
76117: LIST
76118: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76119: LD_ADDR_VAR 0 55
76123: PUSH
76124: LD_INT 0
76126: PUSH
76127: LD_INT 0
76129: PUSH
76130: EMPTY
76131: LIST
76132: LIST
76133: PUSH
76134: LD_INT 0
76136: PUSH
76137: LD_INT 1
76139: NEG
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PUSH
76145: LD_INT 1
76147: PUSH
76148: LD_INT 0
76150: PUSH
76151: EMPTY
76152: LIST
76153: LIST
76154: PUSH
76155: LD_INT 1
76157: PUSH
76158: LD_INT 1
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 0
76167: PUSH
76168: LD_INT 1
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 1
76177: NEG
76178: PUSH
76179: LD_INT 0
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: LD_INT 1
76188: NEG
76189: PUSH
76190: LD_INT 1
76192: NEG
76193: PUSH
76194: EMPTY
76195: LIST
76196: LIST
76197: PUSH
76198: LD_INT 1
76200: NEG
76201: PUSH
76202: LD_INT 2
76204: NEG
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: PUSH
76210: LD_INT 0
76212: PUSH
76213: LD_INT 2
76215: NEG
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PUSH
76221: LD_INT 1
76223: PUSH
76224: LD_INT 1
76226: NEG
76227: PUSH
76228: EMPTY
76229: LIST
76230: LIST
76231: PUSH
76232: LD_INT 2
76234: PUSH
76235: LD_INT 0
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: LD_INT 2
76244: PUSH
76245: LD_INT 1
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: PUSH
76252: LD_INT 2
76254: PUSH
76255: LD_INT 2
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 1
76264: PUSH
76265: LD_INT 2
76267: PUSH
76268: EMPTY
76269: LIST
76270: LIST
76271: PUSH
76272: LD_INT 0
76274: PUSH
76275: LD_INT 2
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: PUSH
76282: LD_INT 1
76284: NEG
76285: PUSH
76286: LD_INT 1
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 2
76295: NEG
76296: PUSH
76297: LD_INT 0
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: LD_INT 2
76306: NEG
76307: PUSH
76308: LD_INT 1
76310: NEG
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 2
76318: NEG
76319: PUSH
76320: LD_INT 2
76322: NEG
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: LIST
76332: LIST
76333: LIST
76334: LIST
76335: LIST
76336: LIST
76337: LIST
76338: LIST
76339: LIST
76340: LIST
76341: LIST
76342: LIST
76343: LIST
76344: LIST
76345: LIST
76346: LIST
76347: LIST
76348: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76349: LD_ADDR_VAR 0 56
76353: PUSH
76354: LD_INT 0
76356: PUSH
76357: LD_INT 0
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: PUSH
76364: LD_INT 0
76366: PUSH
76367: LD_INT 1
76369: NEG
76370: PUSH
76371: EMPTY
76372: LIST
76373: LIST
76374: PUSH
76375: LD_INT 1
76377: PUSH
76378: LD_INT 0
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: PUSH
76385: LD_INT 1
76387: PUSH
76388: LD_INT 1
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 0
76397: PUSH
76398: LD_INT 1
76400: PUSH
76401: EMPTY
76402: LIST
76403: LIST
76404: PUSH
76405: LD_INT 1
76407: NEG
76408: PUSH
76409: LD_INT 0
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: LD_INT 1
76418: NEG
76419: PUSH
76420: LD_INT 1
76422: NEG
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: LD_INT 1
76430: NEG
76431: PUSH
76432: LD_INT 2
76434: NEG
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: LD_INT 0
76442: PUSH
76443: LD_INT 2
76445: NEG
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: PUSH
76451: LD_INT 1
76453: PUSH
76454: LD_INT 1
76456: NEG
76457: PUSH
76458: EMPTY
76459: LIST
76460: LIST
76461: PUSH
76462: LD_INT 2
76464: PUSH
76465: LD_INT 0
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: PUSH
76472: LD_INT 2
76474: PUSH
76475: LD_INT 1
76477: PUSH
76478: EMPTY
76479: LIST
76480: LIST
76481: PUSH
76482: LD_INT 2
76484: PUSH
76485: LD_INT 2
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: PUSH
76492: LD_INT 1
76494: PUSH
76495: LD_INT 2
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PUSH
76502: LD_INT 0
76504: PUSH
76505: LD_INT 2
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PUSH
76512: LD_INT 1
76514: NEG
76515: PUSH
76516: LD_INT 1
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: LD_INT 2
76525: NEG
76526: PUSH
76527: LD_INT 0
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: PUSH
76534: LD_INT 2
76536: NEG
76537: PUSH
76538: LD_INT 1
76540: NEG
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: LD_INT 2
76548: NEG
76549: PUSH
76550: LD_INT 2
76552: NEG
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: PUSH
76558: EMPTY
76559: LIST
76560: LIST
76561: LIST
76562: LIST
76563: LIST
76564: LIST
76565: LIST
76566: LIST
76567: LIST
76568: LIST
76569: LIST
76570: LIST
76571: LIST
76572: LIST
76573: LIST
76574: LIST
76575: LIST
76576: LIST
76577: LIST
76578: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76579: LD_ADDR_VAR 0 57
76583: PUSH
76584: LD_INT 0
76586: PUSH
76587: LD_INT 0
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: LD_INT 0
76596: PUSH
76597: LD_INT 1
76599: NEG
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: PUSH
76605: LD_INT 1
76607: PUSH
76608: LD_INT 0
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: PUSH
76615: LD_INT 1
76617: PUSH
76618: LD_INT 1
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 0
76627: PUSH
76628: LD_INT 1
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 1
76637: NEG
76638: PUSH
76639: LD_INT 0
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 1
76648: NEG
76649: PUSH
76650: LD_INT 1
76652: NEG
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: LD_INT 1
76660: NEG
76661: PUSH
76662: LD_INT 2
76664: NEG
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PUSH
76670: LD_INT 0
76672: PUSH
76673: LD_INT 2
76675: NEG
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PUSH
76681: LD_INT 1
76683: PUSH
76684: LD_INT 1
76686: NEG
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: PUSH
76692: LD_INT 2
76694: PUSH
76695: LD_INT 0
76697: PUSH
76698: EMPTY
76699: LIST
76700: LIST
76701: PUSH
76702: LD_INT 2
76704: PUSH
76705: LD_INT 1
76707: PUSH
76708: EMPTY
76709: LIST
76710: LIST
76711: PUSH
76712: LD_INT 2
76714: PUSH
76715: LD_INT 2
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PUSH
76722: LD_INT 1
76724: PUSH
76725: LD_INT 2
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 0
76734: PUSH
76735: LD_INT 2
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: LD_INT 1
76744: NEG
76745: PUSH
76746: LD_INT 1
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 2
76755: NEG
76756: PUSH
76757: LD_INT 0
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 2
76766: NEG
76767: PUSH
76768: LD_INT 1
76770: NEG
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: PUSH
76776: LD_INT 2
76778: NEG
76779: PUSH
76780: LD_INT 2
76782: NEG
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: LIST
76792: LIST
76793: LIST
76794: LIST
76795: LIST
76796: LIST
76797: LIST
76798: LIST
76799: LIST
76800: LIST
76801: LIST
76802: LIST
76803: LIST
76804: LIST
76805: LIST
76806: LIST
76807: LIST
76808: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76809: LD_ADDR_VAR 0 58
76813: PUSH
76814: LD_INT 0
76816: PUSH
76817: LD_INT 0
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 0
76826: PUSH
76827: LD_INT 1
76829: NEG
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: LD_INT 1
76837: PUSH
76838: LD_INT 0
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: LD_INT 1
76847: PUSH
76848: LD_INT 1
76850: PUSH
76851: EMPTY
76852: LIST
76853: LIST
76854: PUSH
76855: LD_INT 0
76857: PUSH
76858: LD_INT 1
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PUSH
76865: LD_INT 1
76867: NEG
76868: PUSH
76869: LD_INT 0
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: PUSH
76876: LD_INT 1
76878: NEG
76879: PUSH
76880: LD_INT 1
76882: NEG
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: PUSH
76888: LD_INT 1
76890: NEG
76891: PUSH
76892: LD_INT 2
76894: NEG
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: LD_INT 0
76902: PUSH
76903: LD_INT 2
76905: NEG
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: LD_INT 1
76913: PUSH
76914: LD_INT 1
76916: NEG
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: PUSH
76922: LD_INT 2
76924: PUSH
76925: LD_INT 0
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: LD_INT 2
76934: PUSH
76935: LD_INT 1
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: PUSH
76942: LD_INT 2
76944: PUSH
76945: LD_INT 2
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: LD_INT 1
76954: PUSH
76955: LD_INT 2
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: PUSH
76962: LD_INT 0
76964: PUSH
76965: LD_INT 2
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 1
76974: NEG
76975: PUSH
76976: LD_INT 1
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 2
76985: NEG
76986: PUSH
76987: LD_INT 0
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: PUSH
76994: LD_INT 2
76996: NEG
76997: PUSH
76998: LD_INT 1
77000: NEG
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: PUSH
77006: LD_INT 2
77008: NEG
77009: PUSH
77010: LD_INT 2
77012: NEG
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: LIST
77022: LIST
77023: LIST
77024: LIST
77025: LIST
77026: LIST
77027: LIST
77028: LIST
77029: LIST
77030: LIST
77031: LIST
77032: LIST
77033: LIST
77034: LIST
77035: LIST
77036: LIST
77037: LIST
77038: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77039: LD_ADDR_VAR 0 59
77043: PUSH
77044: LD_INT 0
77046: PUSH
77047: LD_INT 0
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 0
77056: PUSH
77057: LD_INT 1
77059: NEG
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: LD_INT 1
77067: PUSH
77068: LD_INT 0
77070: PUSH
77071: EMPTY
77072: LIST
77073: LIST
77074: PUSH
77075: LD_INT 1
77077: PUSH
77078: LD_INT 1
77080: PUSH
77081: EMPTY
77082: LIST
77083: LIST
77084: PUSH
77085: LD_INT 0
77087: PUSH
77088: LD_INT 1
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PUSH
77095: LD_INT 1
77097: NEG
77098: PUSH
77099: LD_INT 0
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 1
77108: NEG
77109: PUSH
77110: LD_INT 1
77112: NEG
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: LIST
77122: LIST
77123: LIST
77124: LIST
77125: LIST
77126: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77127: LD_ADDR_VAR 0 60
77131: PUSH
77132: LD_INT 0
77134: PUSH
77135: LD_INT 0
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: PUSH
77142: LD_INT 0
77144: PUSH
77145: LD_INT 1
77147: NEG
77148: PUSH
77149: EMPTY
77150: LIST
77151: LIST
77152: PUSH
77153: LD_INT 1
77155: PUSH
77156: LD_INT 0
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: LD_INT 1
77165: PUSH
77166: LD_INT 1
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PUSH
77173: LD_INT 0
77175: PUSH
77176: LD_INT 1
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 1
77185: NEG
77186: PUSH
77187: LD_INT 0
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 1
77196: NEG
77197: PUSH
77198: LD_INT 1
77200: NEG
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: LIST
77210: LIST
77211: LIST
77212: LIST
77213: LIST
77214: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77215: LD_ADDR_VAR 0 61
77219: PUSH
77220: LD_INT 0
77222: PUSH
77223: LD_INT 0
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: LD_INT 0
77232: PUSH
77233: LD_INT 1
77235: NEG
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 1
77243: PUSH
77244: LD_INT 0
77246: PUSH
77247: EMPTY
77248: LIST
77249: LIST
77250: PUSH
77251: LD_INT 1
77253: PUSH
77254: LD_INT 1
77256: PUSH
77257: EMPTY
77258: LIST
77259: LIST
77260: PUSH
77261: LD_INT 0
77263: PUSH
77264: LD_INT 1
77266: PUSH
77267: EMPTY
77268: LIST
77269: LIST
77270: PUSH
77271: LD_INT 1
77273: NEG
77274: PUSH
77275: LD_INT 0
77277: PUSH
77278: EMPTY
77279: LIST
77280: LIST
77281: PUSH
77282: LD_INT 1
77284: NEG
77285: PUSH
77286: LD_INT 1
77288: NEG
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: LIST
77298: LIST
77299: LIST
77300: LIST
77301: LIST
77302: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77303: LD_ADDR_VAR 0 62
77307: PUSH
77308: LD_INT 0
77310: PUSH
77311: LD_INT 0
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 0
77320: PUSH
77321: LD_INT 1
77323: NEG
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: LD_INT 1
77331: PUSH
77332: LD_INT 0
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: PUSH
77339: LD_INT 1
77341: PUSH
77342: LD_INT 1
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 0
77351: PUSH
77352: LD_INT 1
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 1
77361: NEG
77362: PUSH
77363: LD_INT 0
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: PUSH
77370: LD_INT 1
77372: NEG
77373: PUSH
77374: LD_INT 1
77376: NEG
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: LIST
77386: LIST
77387: LIST
77388: LIST
77389: LIST
77390: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77391: LD_ADDR_VAR 0 63
77395: PUSH
77396: LD_INT 0
77398: PUSH
77399: LD_INT 0
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 0
77408: PUSH
77409: LD_INT 1
77411: NEG
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 1
77419: PUSH
77420: LD_INT 0
77422: PUSH
77423: EMPTY
77424: LIST
77425: LIST
77426: PUSH
77427: LD_INT 1
77429: PUSH
77430: LD_INT 1
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: LD_INT 0
77439: PUSH
77440: LD_INT 1
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: LD_INT 1
77449: NEG
77450: PUSH
77451: LD_INT 0
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: PUSH
77458: LD_INT 1
77460: NEG
77461: PUSH
77462: LD_INT 1
77464: NEG
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: EMPTY
77471: LIST
77472: LIST
77473: LIST
77474: LIST
77475: LIST
77476: LIST
77477: LIST
77478: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77479: LD_ADDR_VAR 0 64
77483: PUSH
77484: LD_INT 0
77486: PUSH
77487: LD_INT 0
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: PUSH
77494: LD_INT 0
77496: PUSH
77497: LD_INT 1
77499: NEG
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 1
77507: PUSH
77508: LD_INT 0
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: LD_INT 1
77517: PUSH
77518: LD_INT 1
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 0
77527: PUSH
77528: LD_INT 1
77530: PUSH
77531: EMPTY
77532: LIST
77533: LIST
77534: PUSH
77535: LD_INT 1
77537: NEG
77538: PUSH
77539: LD_INT 0
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: PUSH
77546: LD_INT 1
77548: NEG
77549: PUSH
77550: LD_INT 1
77552: NEG
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: EMPTY
77559: LIST
77560: LIST
77561: LIST
77562: LIST
77563: LIST
77564: LIST
77565: LIST
77566: ST_TO_ADDR
// end ; 1 :
77567: GO 83464
77569: LD_INT 1
77571: DOUBLE
77572: EQUAL
77573: IFTRUE 77577
77575: GO 80200
77577: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77578: LD_ADDR_VAR 0 11
77582: PUSH
77583: LD_INT 1
77585: NEG
77586: PUSH
77587: LD_INT 3
77589: NEG
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 0
77597: PUSH
77598: LD_INT 3
77600: NEG
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PUSH
77606: LD_INT 1
77608: PUSH
77609: LD_INT 2
77611: NEG
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: LIST
77621: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77622: LD_ADDR_VAR 0 12
77626: PUSH
77627: LD_INT 2
77629: PUSH
77630: LD_INT 1
77632: NEG
77633: PUSH
77634: EMPTY
77635: LIST
77636: LIST
77637: PUSH
77638: LD_INT 3
77640: PUSH
77641: LD_INT 0
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: PUSH
77648: LD_INT 3
77650: PUSH
77651: LD_INT 1
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: LIST
77662: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77663: LD_ADDR_VAR 0 13
77667: PUSH
77668: LD_INT 3
77670: PUSH
77671: LD_INT 2
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: PUSH
77678: LD_INT 3
77680: PUSH
77681: LD_INT 3
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 2
77690: PUSH
77691: LD_INT 3
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: LIST
77702: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77703: LD_ADDR_VAR 0 14
77707: PUSH
77708: LD_INT 1
77710: PUSH
77711: LD_INT 3
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 0
77720: PUSH
77721: LD_INT 3
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PUSH
77728: LD_INT 1
77730: NEG
77731: PUSH
77732: LD_INT 2
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: LIST
77743: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77744: LD_ADDR_VAR 0 15
77748: PUSH
77749: LD_INT 2
77751: NEG
77752: PUSH
77753: LD_INT 1
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 3
77762: NEG
77763: PUSH
77764: LD_INT 0
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: PUSH
77771: LD_INT 3
77773: NEG
77774: PUSH
77775: LD_INT 1
77777: NEG
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: LIST
77787: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77788: LD_ADDR_VAR 0 16
77792: PUSH
77793: LD_INT 2
77795: NEG
77796: PUSH
77797: LD_INT 3
77799: NEG
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: PUSH
77805: LD_INT 3
77807: NEG
77808: PUSH
77809: LD_INT 2
77811: NEG
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 3
77819: NEG
77820: PUSH
77821: LD_INT 3
77823: NEG
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: LIST
77833: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77834: LD_ADDR_VAR 0 17
77838: PUSH
77839: LD_INT 1
77841: NEG
77842: PUSH
77843: LD_INT 3
77845: NEG
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: LD_INT 0
77853: PUSH
77854: LD_INT 3
77856: NEG
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 1
77864: PUSH
77865: LD_INT 2
77867: NEG
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: EMPTY
77874: LIST
77875: LIST
77876: LIST
77877: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77878: LD_ADDR_VAR 0 18
77882: PUSH
77883: LD_INT 2
77885: PUSH
77886: LD_INT 1
77888: NEG
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 3
77896: PUSH
77897: LD_INT 0
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PUSH
77904: LD_INT 3
77906: PUSH
77907: LD_INT 1
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: LIST
77918: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77919: LD_ADDR_VAR 0 19
77923: PUSH
77924: LD_INT 3
77926: PUSH
77927: LD_INT 2
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: PUSH
77934: LD_INT 3
77936: PUSH
77937: LD_INT 3
77939: PUSH
77940: EMPTY
77941: LIST
77942: LIST
77943: PUSH
77944: LD_INT 2
77946: PUSH
77947: LD_INT 3
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: LIST
77958: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77959: LD_ADDR_VAR 0 20
77963: PUSH
77964: LD_INT 1
77966: PUSH
77967: LD_INT 3
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 0
77976: PUSH
77977: LD_INT 3
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: PUSH
77984: LD_INT 1
77986: NEG
77987: PUSH
77988: LD_INT 2
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: EMPTY
77996: LIST
77997: LIST
77998: LIST
77999: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78000: LD_ADDR_VAR 0 21
78004: PUSH
78005: LD_INT 2
78007: NEG
78008: PUSH
78009: LD_INT 1
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 3
78018: NEG
78019: PUSH
78020: LD_INT 0
78022: PUSH
78023: EMPTY
78024: LIST
78025: LIST
78026: PUSH
78027: LD_INT 3
78029: NEG
78030: PUSH
78031: LD_INT 1
78033: NEG
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PUSH
78039: EMPTY
78040: LIST
78041: LIST
78042: LIST
78043: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78044: LD_ADDR_VAR 0 22
78048: PUSH
78049: LD_INT 2
78051: NEG
78052: PUSH
78053: LD_INT 3
78055: NEG
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: LD_INT 3
78063: NEG
78064: PUSH
78065: LD_INT 2
78067: NEG
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: LD_INT 3
78075: NEG
78076: PUSH
78077: LD_INT 3
78079: NEG
78080: PUSH
78081: EMPTY
78082: LIST
78083: LIST
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: LIST
78089: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78090: LD_ADDR_VAR 0 23
78094: PUSH
78095: LD_INT 0
78097: PUSH
78098: LD_INT 3
78100: NEG
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: LD_INT 1
78108: NEG
78109: PUSH
78110: LD_INT 4
78112: NEG
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 1
78120: PUSH
78121: LD_INT 3
78123: NEG
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: LIST
78133: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78134: LD_ADDR_VAR 0 24
78138: PUSH
78139: LD_INT 3
78141: PUSH
78142: LD_INT 0
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 3
78151: PUSH
78152: LD_INT 1
78154: NEG
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PUSH
78160: LD_INT 4
78162: PUSH
78163: LD_INT 1
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: LIST
78174: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78175: LD_ADDR_VAR 0 25
78179: PUSH
78180: LD_INT 3
78182: PUSH
78183: LD_INT 3
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 4
78192: PUSH
78193: LD_INT 3
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 3
78202: PUSH
78203: LD_INT 4
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: LIST
78214: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78215: LD_ADDR_VAR 0 26
78219: PUSH
78220: LD_INT 0
78222: PUSH
78223: LD_INT 3
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: LD_INT 1
78232: PUSH
78233: LD_INT 4
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: LD_INT 1
78242: NEG
78243: PUSH
78244: LD_INT 3
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: EMPTY
78252: LIST
78253: LIST
78254: LIST
78255: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78256: LD_ADDR_VAR 0 27
78260: PUSH
78261: LD_INT 3
78263: NEG
78264: PUSH
78265: LD_INT 0
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: LD_INT 3
78274: NEG
78275: PUSH
78276: LD_INT 1
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: LD_INT 4
78285: NEG
78286: PUSH
78287: LD_INT 1
78289: NEG
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: EMPTY
78296: LIST
78297: LIST
78298: LIST
78299: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78300: LD_ADDR_VAR 0 28
78304: PUSH
78305: LD_INT 3
78307: NEG
78308: PUSH
78309: LD_INT 3
78311: NEG
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: LD_INT 3
78319: NEG
78320: PUSH
78321: LD_INT 4
78323: NEG
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 4
78331: NEG
78332: PUSH
78333: LD_INT 3
78335: NEG
78336: PUSH
78337: EMPTY
78338: LIST
78339: LIST
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: LIST
78345: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78346: LD_ADDR_VAR 0 29
78350: PUSH
78351: LD_INT 1
78353: NEG
78354: PUSH
78355: LD_INT 3
78357: NEG
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 0
78365: PUSH
78366: LD_INT 3
78368: NEG
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 1
78376: PUSH
78377: LD_INT 2
78379: NEG
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 1
78387: NEG
78388: PUSH
78389: LD_INT 4
78391: NEG
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 0
78399: PUSH
78400: LD_INT 4
78402: NEG
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: LD_INT 1
78410: PUSH
78411: LD_INT 3
78413: NEG
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 1
78421: NEG
78422: PUSH
78423: LD_INT 5
78425: NEG
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 0
78433: PUSH
78434: LD_INT 5
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 1
78444: PUSH
78445: LD_INT 4
78447: NEG
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 1
78455: NEG
78456: PUSH
78457: LD_INT 6
78459: NEG
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 0
78467: PUSH
78468: LD_INT 6
78470: NEG
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 1
78478: PUSH
78479: LD_INT 5
78481: NEG
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: EMPTY
78488: LIST
78489: LIST
78490: LIST
78491: LIST
78492: LIST
78493: LIST
78494: LIST
78495: LIST
78496: LIST
78497: LIST
78498: LIST
78499: LIST
78500: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78501: LD_ADDR_VAR 0 30
78505: PUSH
78506: LD_INT 2
78508: PUSH
78509: LD_INT 1
78511: NEG
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 3
78519: PUSH
78520: LD_INT 0
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 3
78529: PUSH
78530: LD_INT 1
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 3
78539: PUSH
78540: LD_INT 1
78542: NEG
78543: PUSH
78544: EMPTY
78545: LIST
78546: LIST
78547: PUSH
78548: LD_INT 4
78550: PUSH
78551: LD_INT 0
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 4
78560: PUSH
78561: LD_INT 1
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 4
78570: PUSH
78571: LD_INT 1
78573: NEG
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: PUSH
78579: LD_INT 5
78581: PUSH
78582: LD_INT 0
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 5
78591: PUSH
78592: LD_INT 1
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: PUSH
78599: LD_INT 5
78601: PUSH
78602: LD_INT 1
78604: NEG
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: PUSH
78610: LD_INT 6
78612: PUSH
78613: LD_INT 0
78615: PUSH
78616: EMPTY
78617: LIST
78618: LIST
78619: PUSH
78620: LD_INT 6
78622: PUSH
78623: LD_INT 1
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: LIST
78634: LIST
78635: LIST
78636: LIST
78637: LIST
78638: LIST
78639: LIST
78640: LIST
78641: LIST
78642: LIST
78643: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78644: LD_ADDR_VAR 0 31
78648: PUSH
78649: LD_INT 3
78651: PUSH
78652: LD_INT 2
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 3
78661: PUSH
78662: LD_INT 3
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 2
78671: PUSH
78672: LD_INT 3
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 4
78681: PUSH
78682: LD_INT 3
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: LD_INT 4
78691: PUSH
78692: LD_INT 4
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: PUSH
78699: LD_INT 3
78701: PUSH
78702: LD_INT 4
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: PUSH
78709: LD_INT 5
78711: PUSH
78712: LD_INT 4
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 5
78721: PUSH
78722: LD_INT 5
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 4
78731: PUSH
78732: LD_INT 5
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: LD_INT 6
78741: PUSH
78742: LD_INT 5
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 6
78751: PUSH
78752: LD_INT 6
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PUSH
78759: LD_INT 5
78761: PUSH
78762: LD_INT 6
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78783: LD_ADDR_VAR 0 32
78787: PUSH
78788: LD_INT 1
78790: PUSH
78791: LD_INT 3
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 0
78800: PUSH
78801: LD_INT 3
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 1
78810: NEG
78811: PUSH
78812: LD_INT 2
78814: PUSH
78815: EMPTY
78816: LIST
78817: LIST
78818: PUSH
78819: LD_INT 1
78821: PUSH
78822: LD_INT 4
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PUSH
78829: LD_INT 0
78831: PUSH
78832: LD_INT 4
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 1
78841: NEG
78842: PUSH
78843: LD_INT 3
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PUSH
78850: LD_INT 1
78852: PUSH
78853: LD_INT 5
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PUSH
78860: LD_INT 0
78862: PUSH
78863: LD_INT 5
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 1
78872: NEG
78873: PUSH
78874: LD_INT 4
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: LD_INT 1
78883: PUSH
78884: LD_INT 6
78886: PUSH
78887: EMPTY
78888: LIST
78889: LIST
78890: PUSH
78891: LD_INT 0
78893: PUSH
78894: LD_INT 6
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 1
78903: NEG
78904: PUSH
78905: LD_INT 5
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: LIST
78916: LIST
78917: LIST
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78926: LD_ADDR_VAR 0 33
78930: PUSH
78931: LD_INT 2
78933: NEG
78934: PUSH
78935: LD_INT 1
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: PUSH
78942: LD_INT 3
78944: NEG
78945: PUSH
78946: LD_INT 0
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 3
78955: NEG
78956: PUSH
78957: LD_INT 1
78959: NEG
78960: PUSH
78961: EMPTY
78962: LIST
78963: LIST
78964: PUSH
78965: LD_INT 3
78967: NEG
78968: PUSH
78969: LD_INT 1
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PUSH
78976: LD_INT 4
78978: NEG
78979: PUSH
78980: LD_INT 0
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: PUSH
78987: LD_INT 4
78989: NEG
78990: PUSH
78991: LD_INT 1
78993: NEG
78994: PUSH
78995: EMPTY
78996: LIST
78997: LIST
78998: PUSH
78999: LD_INT 4
79001: NEG
79002: PUSH
79003: LD_INT 1
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: LD_INT 5
79012: NEG
79013: PUSH
79014: LD_INT 0
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 5
79023: NEG
79024: PUSH
79025: LD_INT 1
79027: NEG
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 5
79035: NEG
79036: PUSH
79037: LD_INT 1
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 6
79046: NEG
79047: PUSH
79048: LD_INT 0
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PUSH
79055: LD_INT 6
79057: NEG
79058: PUSH
79059: LD_INT 1
79061: NEG
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: LIST
79077: LIST
79078: LIST
79079: LIST
79080: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79081: LD_ADDR_VAR 0 34
79085: PUSH
79086: LD_INT 2
79088: NEG
79089: PUSH
79090: LD_INT 3
79092: NEG
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: LD_INT 3
79100: NEG
79101: PUSH
79102: LD_INT 2
79104: NEG
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: PUSH
79110: LD_INT 3
79112: NEG
79113: PUSH
79114: LD_INT 3
79116: NEG
79117: PUSH
79118: EMPTY
79119: LIST
79120: LIST
79121: PUSH
79122: LD_INT 3
79124: NEG
79125: PUSH
79126: LD_INT 4
79128: NEG
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 4
79136: NEG
79137: PUSH
79138: LD_INT 3
79140: NEG
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: LD_INT 4
79148: NEG
79149: PUSH
79150: LD_INT 4
79152: NEG
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: PUSH
79158: LD_INT 4
79160: NEG
79161: PUSH
79162: LD_INT 5
79164: NEG
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: PUSH
79170: LD_INT 5
79172: NEG
79173: PUSH
79174: LD_INT 4
79176: NEG
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 5
79184: NEG
79185: PUSH
79186: LD_INT 5
79188: NEG
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 5
79196: NEG
79197: PUSH
79198: LD_INT 6
79200: NEG
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 6
79208: NEG
79209: PUSH
79210: LD_INT 5
79212: NEG
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 6
79220: NEG
79221: PUSH
79222: LD_INT 6
79224: NEG
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: LIST
79234: LIST
79235: LIST
79236: LIST
79237: LIST
79238: LIST
79239: LIST
79240: LIST
79241: LIST
79242: LIST
79243: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79244: LD_ADDR_VAR 0 41
79248: PUSH
79249: LD_INT 0
79251: PUSH
79252: LD_INT 2
79254: NEG
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 1
79262: NEG
79263: PUSH
79264: LD_INT 3
79266: NEG
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: LD_INT 1
79274: PUSH
79275: LD_INT 2
79277: NEG
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: LIST
79287: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79288: LD_ADDR_VAR 0 42
79292: PUSH
79293: LD_INT 2
79295: PUSH
79296: LD_INT 0
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 2
79305: PUSH
79306: LD_INT 1
79308: NEG
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 3
79316: PUSH
79317: LD_INT 1
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: LIST
79328: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79329: LD_ADDR_VAR 0 43
79333: PUSH
79334: LD_INT 2
79336: PUSH
79337: LD_INT 2
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 3
79346: PUSH
79347: LD_INT 2
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 2
79356: PUSH
79357: LD_INT 3
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: LIST
79368: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79369: LD_ADDR_VAR 0 44
79373: PUSH
79374: LD_INT 0
79376: PUSH
79377: LD_INT 2
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: LD_INT 1
79386: PUSH
79387: LD_INT 3
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 1
79396: NEG
79397: PUSH
79398: LD_INT 2
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: LIST
79409: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79410: LD_ADDR_VAR 0 45
79414: PUSH
79415: LD_INT 2
79417: NEG
79418: PUSH
79419: LD_INT 0
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 2
79428: NEG
79429: PUSH
79430: LD_INT 1
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: LD_INT 3
79439: NEG
79440: PUSH
79441: LD_INT 1
79443: NEG
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: LIST
79453: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79454: LD_ADDR_VAR 0 46
79458: PUSH
79459: LD_INT 2
79461: NEG
79462: PUSH
79463: LD_INT 2
79465: NEG
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 2
79473: NEG
79474: PUSH
79475: LD_INT 3
79477: NEG
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: LD_INT 3
79485: NEG
79486: PUSH
79487: LD_INT 2
79489: NEG
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: LIST
79499: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79500: LD_ADDR_VAR 0 47
79504: PUSH
79505: LD_INT 2
79507: NEG
79508: PUSH
79509: LD_INT 3
79511: NEG
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 1
79519: NEG
79520: PUSH
79521: LD_INT 3
79523: NEG
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79533: LD_ADDR_VAR 0 48
79537: PUSH
79538: LD_INT 1
79540: PUSH
79541: LD_INT 2
79543: NEG
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 2
79551: PUSH
79552: LD_INT 1
79554: NEG
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79564: LD_ADDR_VAR 0 49
79568: PUSH
79569: LD_INT 3
79571: PUSH
79572: LD_INT 1
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 3
79581: PUSH
79582: LD_INT 2
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79593: LD_ADDR_VAR 0 50
79597: PUSH
79598: LD_INT 2
79600: PUSH
79601: LD_INT 3
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 1
79610: PUSH
79611: LD_INT 3
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79622: LD_ADDR_VAR 0 51
79626: PUSH
79627: LD_INT 1
79629: NEG
79630: PUSH
79631: LD_INT 2
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 2
79640: NEG
79641: PUSH
79642: LD_INT 1
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79653: LD_ADDR_VAR 0 52
79657: PUSH
79658: LD_INT 3
79660: NEG
79661: PUSH
79662: LD_INT 1
79664: NEG
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 3
79672: NEG
79673: PUSH
79674: LD_INT 2
79676: NEG
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79686: LD_ADDR_VAR 0 53
79690: PUSH
79691: LD_INT 1
79693: NEG
79694: PUSH
79695: LD_INT 3
79697: NEG
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PUSH
79703: LD_INT 0
79705: PUSH
79706: LD_INT 3
79708: NEG
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: PUSH
79714: LD_INT 1
79716: PUSH
79717: LD_INT 2
79719: NEG
79720: PUSH
79721: EMPTY
79722: LIST
79723: LIST
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: LIST
79729: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79730: LD_ADDR_VAR 0 54
79734: PUSH
79735: LD_INT 2
79737: PUSH
79738: LD_INT 1
79740: NEG
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 3
79748: PUSH
79749: LD_INT 0
79751: PUSH
79752: EMPTY
79753: LIST
79754: LIST
79755: PUSH
79756: LD_INT 3
79758: PUSH
79759: LD_INT 1
79761: PUSH
79762: EMPTY
79763: LIST
79764: LIST
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: LIST
79770: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79771: LD_ADDR_VAR 0 55
79775: PUSH
79776: LD_INT 3
79778: PUSH
79779: LD_INT 2
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 3
79788: PUSH
79789: LD_INT 3
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 2
79798: PUSH
79799: LD_INT 3
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: LIST
79810: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79811: LD_ADDR_VAR 0 56
79815: PUSH
79816: LD_INT 1
79818: PUSH
79819: LD_INT 3
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 0
79828: PUSH
79829: LD_INT 3
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 1
79838: NEG
79839: PUSH
79840: LD_INT 2
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: LIST
79851: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79852: LD_ADDR_VAR 0 57
79856: PUSH
79857: LD_INT 2
79859: NEG
79860: PUSH
79861: LD_INT 1
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PUSH
79868: LD_INT 3
79870: NEG
79871: PUSH
79872: LD_INT 0
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 3
79881: NEG
79882: PUSH
79883: LD_INT 1
79885: NEG
79886: PUSH
79887: EMPTY
79888: LIST
79889: LIST
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: LIST
79895: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79896: LD_ADDR_VAR 0 58
79900: PUSH
79901: LD_INT 2
79903: NEG
79904: PUSH
79905: LD_INT 3
79907: NEG
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 3
79915: NEG
79916: PUSH
79917: LD_INT 2
79919: NEG
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 3
79927: NEG
79928: PUSH
79929: LD_INT 3
79931: NEG
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: PUSH
79937: EMPTY
79938: LIST
79939: LIST
79940: LIST
79941: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79942: LD_ADDR_VAR 0 59
79946: PUSH
79947: LD_INT 1
79949: NEG
79950: PUSH
79951: LD_INT 2
79953: NEG
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 0
79961: PUSH
79962: LD_INT 2
79964: NEG
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 1
79972: PUSH
79973: LD_INT 1
79975: NEG
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: LIST
79985: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79986: LD_ADDR_VAR 0 60
79990: PUSH
79991: LD_INT 1
79993: PUSH
79994: LD_INT 1
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 2
80004: PUSH
80005: LD_INT 0
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 2
80014: PUSH
80015: LD_INT 1
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: LIST
80026: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80027: LD_ADDR_VAR 0 61
80031: PUSH
80032: LD_INT 2
80034: PUSH
80035: LD_INT 1
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 2
80044: PUSH
80045: LD_INT 2
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 1
80054: PUSH
80055: LD_INT 2
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: LIST
80066: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80067: LD_ADDR_VAR 0 62
80071: PUSH
80072: LD_INT 1
80074: PUSH
80075: LD_INT 2
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: PUSH
80082: LD_INT 0
80084: PUSH
80085: LD_INT 2
80087: PUSH
80088: EMPTY
80089: LIST
80090: LIST
80091: PUSH
80092: LD_INT 1
80094: NEG
80095: PUSH
80096: LD_INT 1
80098: PUSH
80099: EMPTY
80100: LIST
80101: LIST
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: LIST
80107: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80108: LD_ADDR_VAR 0 63
80112: PUSH
80113: LD_INT 1
80115: NEG
80116: PUSH
80117: LD_INT 1
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: LD_INT 2
80126: NEG
80127: PUSH
80128: LD_INT 0
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: PUSH
80135: LD_INT 2
80137: NEG
80138: PUSH
80139: LD_INT 1
80141: NEG
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: LIST
80151: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80152: LD_ADDR_VAR 0 64
80156: PUSH
80157: LD_INT 1
80159: NEG
80160: PUSH
80161: LD_INT 2
80163: NEG
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: LD_INT 2
80171: NEG
80172: PUSH
80173: LD_INT 1
80175: NEG
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 2
80183: NEG
80184: PUSH
80185: LD_INT 2
80187: NEG
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: LIST
80197: ST_TO_ADDR
// end ; 2 :
80198: GO 83464
80200: LD_INT 2
80202: DOUBLE
80203: EQUAL
80204: IFTRUE 80208
80206: GO 83463
80208: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80209: LD_ADDR_VAR 0 29
80213: PUSH
80214: LD_INT 4
80216: PUSH
80217: LD_INT 0
80219: PUSH
80220: EMPTY
80221: LIST
80222: LIST
80223: PUSH
80224: LD_INT 4
80226: PUSH
80227: LD_INT 1
80229: NEG
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 5
80237: PUSH
80238: LD_INT 0
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: PUSH
80245: LD_INT 5
80247: PUSH
80248: LD_INT 1
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 4
80257: PUSH
80258: LD_INT 1
80260: PUSH
80261: EMPTY
80262: LIST
80263: LIST
80264: PUSH
80265: LD_INT 3
80267: PUSH
80268: LD_INT 0
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 3
80277: PUSH
80278: LD_INT 1
80280: NEG
80281: PUSH
80282: EMPTY
80283: LIST
80284: LIST
80285: PUSH
80286: LD_INT 3
80288: PUSH
80289: LD_INT 2
80291: NEG
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 5
80299: PUSH
80300: LD_INT 2
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 3
80309: PUSH
80310: LD_INT 3
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 3
80319: PUSH
80320: LD_INT 2
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 4
80329: PUSH
80330: LD_INT 3
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: LD_INT 4
80339: PUSH
80340: LD_INT 4
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: PUSH
80347: LD_INT 3
80349: PUSH
80350: LD_INT 4
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 2
80359: PUSH
80360: LD_INT 3
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 2
80369: PUSH
80370: LD_INT 2
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 4
80379: PUSH
80380: LD_INT 2
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: LD_INT 2
80389: PUSH
80390: LD_INT 4
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 0
80399: PUSH
80400: LD_INT 4
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: LD_INT 0
80409: PUSH
80410: LD_INT 3
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 1
80419: PUSH
80420: LD_INT 4
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: PUSH
80427: LD_INT 1
80429: PUSH
80430: LD_INT 5
80432: PUSH
80433: EMPTY
80434: LIST
80435: LIST
80436: PUSH
80437: LD_INT 0
80439: PUSH
80440: LD_INT 5
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 1
80449: NEG
80450: PUSH
80451: LD_INT 4
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: PUSH
80458: LD_INT 1
80460: NEG
80461: PUSH
80462: LD_INT 3
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 2
80471: PUSH
80472: LD_INT 5
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: PUSH
80479: LD_INT 2
80481: NEG
80482: PUSH
80483: LD_INT 3
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 3
80492: NEG
80493: PUSH
80494: LD_INT 0
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 3
80503: NEG
80504: PUSH
80505: LD_INT 1
80507: NEG
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 2
80515: NEG
80516: PUSH
80517: LD_INT 0
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PUSH
80524: LD_INT 2
80526: NEG
80527: PUSH
80528: LD_INT 1
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 3
80537: NEG
80538: PUSH
80539: LD_INT 1
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 4
80548: NEG
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 4
80559: NEG
80560: PUSH
80561: LD_INT 1
80563: NEG
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 4
80571: NEG
80572: PUSH
80573: LD_INT 2
80575: NEG
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 2
80583: NEG
80584: PUSH
80585: LD_INT 2
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: PUSH
80592: LD_INT 4
80594: NEG
80595: PUSH
80596: LD_INT 4
80598: NEG
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 4
80606: NEG
80607: PUSH
80608: LD_INT 5
80610: NEG
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 3
80618: NEG
80619: PUSH
80620: LD_INT 4
80622: NEG
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 3
80630: NEG
80631: PUSH
80632: LD_INT 3
80634: NEG
80635: PUSH
80636: EMPTY
80637: LIST
80638: LIST
80639: PUSH
80640: LD_INT 4
80642: NEG
80643: PUSH
80644: LD_INT 3
80646: NEG
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 5
80654: NEG
80655: PUSH
80656: LD_INT 4
80658: NEG
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 5
80666: NEG
80667: PUSH
80668: LD_INT 5
80670: NEG
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 3
80678: NEG
80679: PUSH
80680: LD_INT 5
80682: NEG
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_INT 5
80690: NEG
80691: PUSH
80692: LD_INT 3
80694: NEG
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: LIST
80722: LIST
80723: LIST
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: LIST
80736: LIST
80737: LIST
80738: LIST
80739: LIST
80740: LIST
80741: LIST
80742: LIST
80743: LIST
80744: LIST
80745: LIST
80746: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80747: LD_ADDR_VAR 0 30
80751: PUSH
80752: LD_INT 4
80754: PUSH
80755: LD_INT 4
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 4
80764: PUSH
80765: LD_INT 3
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PUSH
80772: LD_INT 5
80774: PUSH
80775: LD_INT 4
80777: PUSH
80778: EMPTY
80779: LIST
80780: LIST
80781: PUSH
80782: LD_INT 5
80784: PUSH
80785: LD_INT 5
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 4
80794: PUSH
80795: LD_INT 5
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PUSH
80802: LD_INT 3
80804: PUSH
80805: LD_INT 4
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 3
80814: PUSH
80815: LD_INT 3
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: PUSH
80822: LD_INT 5
80824: PUSH
80825: LD_INT 3
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 3
80834: PUSH
80835: LD_INT 5
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: LD_INT 0
80844: PUSH
80845: LD_INT 3
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 0
80854: PUSH
80855: LD_INT 2
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: PUSH
80865: LD_INT 3
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: PUSH
80872: LD_INT 1
80874: PUSH
80875: LD_INT 4
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 0
80884: PUSH
80885: LD_INT 4
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 1
80894: NEG
80895: PUSH
80896: LD_INT 3
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 1
80905: NEG
80906: PUSH
80907: LD_INT 2
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 2
80916: PUSH
80917: LD_INT 4
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 2
80926: NEG
80927: PUSH
80928: LD_INT 2
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 4
80937: NEG
80938: PUSH
80939: LD_INT 0
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 4
80948: NEG
80949: PUSH
80950: LD_INT 1
80952: NEG
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 3
80960: NEG
80961: PUSH
80962: LD_INT 0
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 3
80971: NEG
80972: PUSH
80973: LD_INT 1
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 4
80982: NEG
80983: PUSH
80984: LD_INT 1
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 5
80993: NEG
80994: PUSH
80995: LD_INT 0
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 5
81004: NEG
81005: PUSH
81006: LD_INT 1
81008: NEG
81009: PUSH
81010: EMPTY
81011: LIST
81012: LIST
81013: PUSH
81014: LD_INT 5
81016: NEG
81017: PUSH
81018: LD_INT 2
81020: NEG
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 3
81028: NEG
81029: PUSH
81030: LD_INT 2
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: LD_INT 3
81039: NEG
81040: PUSH
81041: LD_INT 3
81043: NEG
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 3
81051: NEG
81052: PUSH
81053: LD_INT 4
81055: NEG
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 2
81063: NEG
81064: PUSH
81065: LD_INT 3
81067: NEG
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: LD_INT 2
81075: NEG
81076: PUSH
81077: LD_INT 2
81079: NEG
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: LD_INT 3
81087: NEG
81088: PUSH
81089: LD_INT 2
81091: NEG
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PUSH
81097: LD_INT 4
81099: NEG
81100: PUSH
81101: LD_INT 3
81103: NEG
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: PUSH
81109: LD_INT 4
81111: NEG
81112: PUSH
81113: LD_INT 4
81115: NEG
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 2
81123: NEG
81124: PUSH
81125: LD_INT 4
81127: NEG
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 4
81135: NEG
81136: PUSH
81137: LD_INT 2
81139: NEG
81140: PUSH
81141: EMPTY
81142: LIST
81143: LIST
81144: PUSH
81145: LD_INT 0
81147: PUSH
81148: LD_INT 4
81150: NEG
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 0
81158: PUSH
81159: LD_INT 5
81161: NEG
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 1
81169: PUSH
81170: LD_INT 4
81172: NEG
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: LD_INT 1
81180: PUSH
81181: LD_INT 3
81183: NEG
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 0
81191: PUSH
81192: LD_INT 3
81194: NEG
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: PUSH
81200: LD_INT 1
81202: NEG
81203: PUSH
81204: LD_INT 4
81206: NEG
81207: PUSH
81208: EMPTY
81209: LIST
81210: LIST
81211: PUSH
81212: LD_INT 1
81214: NEG
81215: PUSH
81216: LD_INT 5
81218: NEG
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 2
81226: PUSH
81227: LD_INT 3
81229: NEG
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 2
81237: NEG
81238: PUSH
81239: LD_INT 5
81241: NEG
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: LIST
81253: LIST
81254: LIST
81255: LIST
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: LIST
81285: LIST
81286: LIST
81287: LIST
81288: LIST
81289: LIST
81290: LIST
81291: LIST
81292: LIST
81293: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81294: LD_ADDR_VAR 0 31
81298: PUSH
81299: LD_INT 0
81301: PUSH
81302: LD_INT 4
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 0
81311: PUSH
81312: LD_INT 3
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 1
81321: PUSH
81322: LD_INT 4
81324: PUSH
81325: EMPTY
81326: LIST
81327: LIST
81328: PUSH
81329: LD_INT 1
81331: PUSH
81332: LD_INT 5
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: PUSH
81339: LD_INT 0
81341: PUSH
81342: LD_INT 5
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 1
81351: NEG
81352: PUSH
81353: LD_INT 4
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 1
81362: NEG
81363: PUSH
81364: LD_INT 3
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 2
81373: PUSH
81374: LD_INT 5
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: PUSH
81381: LD_INT 2
81383: NEG
81384: PUSH
81385: LD_INT 3
81387: PUSH
81388: EMPTY
81389: LIST
81390: LIST
81391: PUSH
81392: LD_INT 3
81394: NEG
81395: PUSH
81396: LD_INT 0
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 3
81405: NEG
81406: PUSH
81407: LD_INT 1
81409: NEG
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 2
81417: NEG
81418: PUSH
81419: LD_INT 0
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 2
81428: NEG
81429: PUSH
81430: LD_INT 1
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 3
81439: NEG
81440: PUSH
81441: LD_INT 1
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 4
81450: NEG
81451: PUSH
81452: LD_INT 0
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 4
81461: NEG
81462: PUSH
81463: LD_INT 1
81465: NEG
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: LD_INT 4
81473: NEG
81474: PUSH
81475: LD_INT 2
81477: NEG
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 2
81485: NEG
81486: PUSH
81487: LD_INT 2
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 4
81496: NEG
81497: PUSH
81498: LD_INT 4
81500: NEG
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: PUSH
81506: LD_INT 4
81508: NEG
81509: PUSH
81510: LD_INT 5
81512: NEG
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: LD_INT 3
81520: NEG
81521: PUSH
81522: LD_INT 4
81524: NEG
81525: PUSH
81526: EMPTY
81527: LIST
81528: LIST
81529: PUSH
81530: LD_INT 3
81532: NEG
81533: PUSH
81534: LD_INT 3
81536: NEG
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 4
81544: NEG
81545: PUSH
81546: LD_INT 3
81548: NEG
81549: PUSH
81550: EMPTY
81551: LIST
81552: LIST
81553: PUSH
81554: LD_INT 5
81556: NEG
81557: PUSH
81558: LD_INT 4
81560: NEG
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PUSH
81566: LD_INT 5
81568: NEG
81569: PUSH
81570: LD_INT 5
81572: NEG
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PUSH
81578: LD_INT 3
81580: NEG
81581: PUSH
81582: LD_INT 5
81584: NEG
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 5
81592: NEG
81593: PUSH
81594: LD_INT 3
81596: NEG
81597: PUSH
81598: EMPTY
81599: LIST
81600: LIST
81601: PUSH
81602: LD_INT 0
81604: PUSH
81605: LD_INT 3
81607: NEG
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 0
81615: PUSH
81616: LD_INT 4
81618: NEG
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: PUSH
81624: LD_INT 1
81626: PUSH
81627: LD_INT 3
81629: NEG
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: PUSH
81635: LD_INT 1
81637: PUSH
81638: LD_INT 2
81640: NEG
81641: PUSH
81642: EMPTY
81643: LIST
81644: LIST
81645: PUSH
81646: LD_INT 0
81648: PUSH
81649: LD_INT 2
81651: NEG
81652: PUSH
81653: EMPTY
81654: LIST
81655: LIST
81656: PUSH
81657: LD_INT 1
81659: NEG
81660: PUSH
81661: LD_INT 3
81663: NEG
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 1
81671: NEG
81672: PUSH
81673: LD_INT 4
81675: NEG
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PUSH
81681: LD_INT 2
81683: PUSH
81684: LD_INT 2
81686: NEG
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 2
81694: NEG
81695: PUSH
81696: LD_INT 4
81698: NEG
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 4
81706: PUSH
81707: LD_INT 0
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 4
81716: PUSH
81717: LD_INT 1
81719: NEG
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 5
81727: PUSH
81728: LD_INT 0
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 5
81737: PUSH
81738: LD_INT 1
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 4
81747: PUSH
81748: LD_INT 1
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 3
81757: PUSH
81758: LD_INT 0
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 3
81767: PUSH
81768: LD_INT 1
81770: NEG
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 3
81778: PUSH
81779: LD_INT 2
81781: NEG
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 5
81789: PUSH
81790: LD_INT 2
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: LIST
81819: LIST
81820: LIST
81821: LIST
81822: LIST
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: LIST
81842: LIST
81843: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81844: LD_ADDR_VAR 0 32
81848: PUSH
81849: LD_INT 4
81851: NEG
81852: PUSH
81853: LD_INT 0
81855: PUSH
81856: EMPTY
81857: LIST
81858: LIST
81859: PUSH
81860: LD_INT 4
81862: NEG
81863: PUSH
81864: LD_INT 1
81866: NEG
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 3
81874: NEG
81875: PUSH
81876: LD_INT 0
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 3
81885: NEG
81886: PUSH
81887: LD_INT 1
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 4
81896: NEG
81897: PUSH
81898: LD_INT 1
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: PUSH
81905: LD_INT 5
81907: NEG
81908: PUSH
81909: LD_INT 0
81911: PUSH
81912: EMPTY
81913: LIST
81914: LIST
81915: PUSH
81916: LD_INT 5
81918: NEG
81919: PUSH
81920: LD_INT 1
81922: NEG
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: PUSH
81928: LD_INT 5
81930: NEG
81931: PUSH
81932: LD_INT 2
81934: NEG
81935: PUSH
81936: EMPTY
81937: LIST
81938: LIST
81939: PUSH
81940: LD_INT 3
81942: NEG
81943: PUSH
81944: LD_INT 2
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: PUSH
81951: LD_INT 3
81953: NEG
81954: PUSH
81955: LD_INT 3
81957: NEG
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: PUSH
81963: LD_INT 3
81965: NEG
81966: PUSH
81967: LD_INT 4
81969: NEG
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 2
81977: NEG
81978: PUSH
81979: LD_INT 3
81981: NEG
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_INT 2
81989: NEG
81990: PUSH
81991: LD_INT 2
81993: NEG
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PUSH
81999: LD_INT 3
82001: NEG
82002: PUSH
82003: LD_INT 2
82005: NEG
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: LD_INT 4
82013: NEG
82014: PUSH
82015: LD_INT 3
82017: NEG
82018: PUSH
82019: EMPTY
82020: LIST
82021: LIST
82022: PUSH
82023: LD_INT 4
82025: NEG
82026: PUSH
82027: LD_INT 4
82029: NEG
82030: PUSH
82031: EMPTY
82032: LIST
82033: LIST
82034: PUSH
82035: LD_INT 2
82037: NEG
82038: PUSH
82039: LD_INT 4
82041: NEG
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 4
82049: NEG
82050: PUSH
82051: LD_INT 2
82053: NEG
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 0
82061: PUSH
82062: LD_INT 4
82064: NEG
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 0
82072: PUSH
82073: LD_INT 5
82075: NEG
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 1
82083: PUSH
82084: LD_INT 4
82086: NEG
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 1
82094: PUSH
82095: LD_INT 3
82097: NEG
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 0
82105: PUSH
82106: LD_INT 3
82108: NEG
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 1
82116: NEG
82117: PUSH
82118: LD_INT 4
82120: NEG
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 1
82128: NEG
82129: PUSH
82130: LD_INT 5
82132: NEG
82133: PUSH
82134: EMPTY
82135: LIST
82136: LIST
82137: PUSH
82138: LD_INT 2
82140: PUSH
82141: LD_INT 3
82143: NEG
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 2
82151: NEG
82152: PUSH
82153: LD_INT 5
82155: NEG
82156: PUSH
82157: EMPTY
82158: LIST
82159: LIST
82160: PUSH
82161: LD_INT 3
82163: PUSH
82164: LD_INT 0
82166: PUSH
82167: EMPTY
82168: LIST
82169: LIST
82170: PUSH
82171: LD_INT 3
82173: PUSH
82174: LD_INT 1
82176: NEG
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 4
82184: PUSH
82185: LD_INT 0
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 4
82194: PUSH
82195: LD_INT 1
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: LD_INT 3
82204: PUSH
82205: LD_INT 1
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PUSH
82212: LD_INT 2
82214: PUSH
82215: LD_INT 0
82217: PUSH
82218: EMPTY
82219: LIST
82220: LIST
82221: PUSH
82222: LD_INT 2
82224: PUSH
82225: LD_INT 1
82227: NEG
82228: PUSH
82229: EMPTY
82230: LIST
82231: LIST
82232: PUSH
82233: LD_INT 2
82235: PUSH
82236: LD_INT 2
82238: NEG
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 4
82246: PUSH
82247: LD_INT 2
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 4
82256: PUSH
82257: LD_INT 4
82259: PUSH
82260: EMPTY
82261: LIST
82262: LIST
82263: PUSH
82264: LD_INT 4
82266: PUSH
82267: LD_INT 3
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 5
82276: PUSH
82277: LD_INT 4
82279: PUSH
82280: EMPTY
82281: LIST
82282: LIST
82283: PUSH
82284: LD_INT 5
82286: PUSH
82287: LD_INT 5
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: PUSH
82294: LD_INT 4
82296: PUSH
82297: LD_INT 5
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: PUSH
82304: LD_INT 3
82306: PUSH
82307: LD_INT 4
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 3
82316: PUSH
82317: LD_INT 3
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: PUSH
82324: LD_INT 5
82326: PUSH
82327: LD_INT 3
82329: PUSH
82330: EMPTY
82331: LIST
82332: LIST
82333: PUSH
82334: LD_INT 3
82336: PUSH
82337: LD_INT 5
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: LIST
82348: LIST
82349: LIST
82350: LIST
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: LIST
82356: LIST
82357: LIST
82358: LIST
82359: LIST
82360: LIST
82361: LIST
82362: LIST
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: LIST
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82391: LD_ADDR_VAR 0 33
82395: PUSH
82396: LD_INT 4
82398: NEG
82399: PUSH
82400: LD_INT 4
82402: NEG
82403: PUSH
82404: EMPTY
82405: LIST
82406: LIST
82407: PUSH
82408: LD_INT 4
82410: NEG
82411: PUSH
82412: LD_INT 5
82414: NEG
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: PUSH
82420: LD_INT 3
82422: NEG
82423: PUSH
82424: LD_INT 4
82426: NEG
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 3
82434: NEG
82435: PUSH
82436: LD_INT 3
82438: NEG
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 4
82446: NEG
82447: PUSH
82448: LD_INT 3
82450: NEG
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PUSH
82456: LD_INT 5
82458: NEG
82459: PUSH
82460: LD_INT 4
82462: NEG
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: PUSH
82468: LD_INT 5
82470: NEG
82471: PUSH
82472: LD_INT 5
82474: NEG
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: PUSH
82480: LD_INT 3
82482: NEG
82483: PUSH
82484: LD_INT 5
82486: NEG
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PUSH
82492: LD_INT 5
82494: NEG
82495: PUSH
82496: LD_INT 3
82498: NEG
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 0
82506: PUSH
82507: LD_INT 3
82509: NEG
82510: PUSH
82511: EMPTY
82512: LIST
82513: LIST
82514: PUSH
82515: LD_INT 0
82517: PUSH
82518: LD_INT 4
82520: NEG
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 1
82528: PUSH
82529: LD_INT 3
82531: NEG
82532: PUSH
82533: EMPTY
82534: LIST
82535: LIST
82536: PUSH
82537: LD_INT 1
82539: PUSH
82540: LD_INT 2
82542: NEG
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 0
82550: PUSH
82551: LD_INT 2
82553: NEG
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: PUSH
82559: LD_INT 1
82561: NEG
82562: PUSH
82563: LD_INT 3
82565: NEG
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 1
82573: NEG
82574: PUSH
82575: LD_INT 4
82577: NEG
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 2
82585: PUSH
82586: LD_INT 2
82588: NEG
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: LD_INT 2
82596: NEG
82597: PUSH
82598: LD_INT 4
82600: NEG
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 4
82608: PUSH
82609: LD_INT 0
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 4
82618: PUSH
82619: LD_INT 1
82621: NEG
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 5
82629: PUSH
82630: LD_INT 0
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 5
82639: PUSH
82640: LD_INT 1
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 4
82649: PUSH
82650: LD_INT 1
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: LD_INT 3
82659: PUSH
82660: LD_INT 0
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: PUSH
82667: LD_INT 3
82669: PUSH
82670: LD_INT 1
82672: NEG
82673: PUSH
82674: EMPTY
82675: LIST
82676: LIST
82677: PUSH
82678: LD_INT 3
82680: PUSH
82681: LD_INT 2
82683: NEG
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 5
82691: PUSH
82692: LD_INT 2
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 3
82701: PUSH
82702: LD_INT 3
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 3
82711: PUSH
82712: LD_INT 2
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 4
82721: PUSH
82722: LD_INT 3
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: LD_INT 4
82731: PUSH
82732: LD_INT 4
82734: PUSH
82735: EMPTY
82736: LIST
82737: LIST
82738: PUSH
82739: LD_INT 3
82741: PUSH
82742: LD_INT 4
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 2
82751: PUSH
82752: LD_INT 3
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 2
82761: PUSH
82762: LD_INT 2
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 4
82771: PUSH
82772: LD_INT 2
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 2
82781: PUSH
82782: LD_INT 4
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 0
82791: PUSH
82792: LD_INT 4
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 0
82801: PUSH
82802: LD_INT 3
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 1
82811: PUSH
82812: LD_INT 4
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 1
82821: PUSH
82822: LD_INT 5
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 0
82831: PUSH
82832: LD_INT 5
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 1
82841: NEG
82842: PUSH
82843: LD_INT 4
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 1
82852: NEG
82853: PUSH
82854: LD_INT 3
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PUSH
82861: LD_INT 2
82863: PUSH
82864: LD_INT 5
82866: PUSH
82867: EMPTY
82868: LIST
82869: LIST
82870: PUSH
82871: LD_INT 2
82873: NEG
82874: PUSH
82875: LD_INT 3
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: EMPTY
82883: LIST
82884: LIST
82885: LIST
82886: LIST
82887: LIST
82888: LIST
82889: LIST
82890: LIST
82891: LIST
82892: LIST
82893: LIST
82894: LIST
82895: LIST
82896: LIST
82897: LIST
82898: LIST
82899: LIST
82900: LIST
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82929: LD_ADDR_VAR 0 34
82933: PUSH
82934: LD_INT 0
82936: PUSH
82937: LD_INT 4
82939: NEG
82940: PUSH
82941: EMPTY
82942: LIST
82943: LIST
82944: PUSH
82945: LD_INT 0
82947: PUSH
82948: LD_INT 5
82950: NEG
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: LD_INT 1
82958: PUSH
82959: LD_INT 4
82961: NEG
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 1
82969: PUSH
82970: LD_INT 3
82972: NEG
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 0
82980: PUSH
82981: LD_INT 3
82983: NEG
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: LD_INT 1
82991: NEG
82992: PUSH
82993: LD_INT 4
82995: NEG
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_INT 1
83003: NEG
83004: PUSH
83005: LD_INT 5
83007: NEG
83008: PUSH
83009: EMPTY
83010: LIST
83011: LIST
83012: PUSH
83013: LD_INT 2
83015: PUSH
83016: LD_INT 3
83018: NEG
83019: PUSH
83020: EMPTY
83021: LIST
83022: LIST
83023: PUSH
83024: LD_INT 2
83026: NEG
83027: PUSH
83028: LD_INT 5
83030: NEG
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: LD_INT 3
83038: PUSH
83039: LD_INT 0
83041: PUSH
83042: EMPTY
83043: LIST
83044: LIST
83045: PUSH
83046: LD_INT 3
83048: PUSH
83049: LD_INT 1
83051: NEG
83052: PUSH
83053: EMPTY
83054: LIST
83055: LIST
83056: PUSH
83057: LD_INT 4
83059: PUSH
83060: LD_INT 0
83062: PUSH
83063: EMPTY
83064: LIST
83065: LIST
83066: PUSH
83067: LD_INT 4
83069: PUSH
83070: LD_INT 1
83072: PUSH
83073: EMPTY
83074: LIST
83075: LIST
83076: PUSH
83077: LD_INT 3
83079: PUSH
83080: LD_INT 1
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 2
83089: PUSH
83090: LD_INT 0
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 2
83099: PUSH
83100: LD_INT 1
83102: NEG
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: PUSH
83108: LD_INT 2
83110: PUSH
83111: LD_INT 2
83113: NEG
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 4
83121: PUSH
83122: LD_INT 2
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 4
83131: PUSH
83132: LD_INT 4
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 4
83141: PUSH
83142: LD_INT 3
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 5
83151: PUSH
83152: LD_INT 4
83154: PUSH
83155: EMPTY
83156: LIST
83157: LIST
83158: PUSH
83159: LD_INT 5
83161: PUSH
83162: LD_INT 5
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PUSH
83169: LD_INT 4
83171: PUSH
83172: LD_INT 5
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 3
83181: PUSH
83182: LD_INT 4
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: LD_INT 3
83191: PUSH
83192: LD_INT 3
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: PUSH
83199: LD_INT 5
83201: PUSH
83202: LD_INT 3
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 3
83211: PUSH
83212: LD_INT 5
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: LD_INT 0
83221: PUSH
83222: LD_INT 3
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 0
83231: PUSH
83232: LD_INT 2
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 1
83241: PUSH
83242: LD_INT 3
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: PUSH
83249: LD_INT 1
83251: PUSH
83252: LD_INT 4
83254: PUSH
83255: EMPTY
83256: LIST
83257: LIST
83258: PUSH
83259: LD_INT 0
83261: PUSH
83262: LD_INT 4
83264: PUSH
83265: EMPTY
83266: LIST
83267: LIST
83268: PUSH
83269: LD_INT 1
83271: NEG
83272: PUSH
83273: LD_INT 3
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: LD_INT 1
83282: NEG
83283: PUSH
83284: LD_INT 2
83286: PUSH
83287: EMPTY
83288: LIST
83289: LIST
83290: PUSH
83291: LD_INT 2
83293: PUSH
83294: LD_INT 4
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 2
83303: NEG
83304: PUSH
83305: LD_INT 2
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: LD_INT 4
83314: NEG
83315: PUSH
83316: LD_INT 0
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 4
83325: NEG
83326: PUSH
83327: LD_INT 1
83329: NEG
83330: PUSH
83331: EMPTY
83332: LIST
83333: LIST
83334: PUSH
83335: LD_INT 3
83337: NEG
83338: PUSH
83339: LD_INT 0
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 3
83348: NEG
83349: PUSH
83350: LD_INT 1
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: LD_INT 4
83359: NEG
83360: PUSH
83361: LD_INT 1
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: PUSH
83368: LD_INT 5
83370: NEG
83371: PUSH
83372: LD_INT 0
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 5
83381: NEG
83382: PUSH
83383: LD_INT 1
83385: NEG
83386: PUSH
83387: EMPTY
83388: LIST
83389: LIST
83390: PUSH
83391: LD_INT 5
83393: NEG
83394: PUSH
83395: LD_INT 2
83397: NEG
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: PUSH
83403: LD_INT 3
83405: NEG
83406: PUSH
83407: LD_INT 2
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: LIST
83418: LIST
83419: LIST
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: LIST
83434: LIST
83435: LIST
83436: LIST
83437: LIST
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: LIST
83446: LIST
83447: LIST
83448: LIST
83449: LIST
83450: LIST
83451: LIST
83452: LIST
83453: LIST
83454: LIST
83455: LIST
83456: LIST
83457: LIST
83458: LIST
83459: LIST
83460: ST_TO_ADDR
// end ; end ;
83461: GO 83464
83463: POP
// case btype of b_depot , b_warehouse :
83464: LD_VAR 0 1
83468: PUSH
83469: LD_INT 0
83471: DOUBLE
83472: EQUAL
83473: IFTRUE 83483
83475: LD_INT 1
83477: DOUBLE
83478: EQUAL
83479: IFTRUE 83483
83481: GO 83684
83483: POP
// case nation of nation_american :
83484: LD_VAR 0 5
83488: PUSH
83489: LD_INT 1
83491: DOUBLE
83492: EQUAL
83493: IFTRUE 83497
83495: GO 83553
83497: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
83498: LD_ADDR_VAR 0 9
83502: PUSH
83503: LD_VAR 0 11
83507: PUSH
83508: LD_VAR 0 12
83512: PUSH
83513: LD_VAR 0 13
83517: PUSH
83518: LD_VAR 0 14
83522: PUSH
83523: LD_VAR 0 15
83527: PUSH
83528: LD_VAR 0 16
83532: PUSH
83533: EMPTY
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: PUSH
83541: LD_VAR 0 4
83545: PUSH
83546: LD_INT 1
83548: PLUS
83549: ARRAY
83550: ST_TO_ADDR
83551: GO 83682
83553: LD_INT 2
83555: DOUBLE
83556: EQUAL
83557: IFTRUE 83561
83559: GO 83617
83561: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83562: LD_ADDR_VAR 0 9
83566: PUSH
83567: LD_VAR 0 17
83571: PUSH
83572: LD_VAR 0 18
83576: PUSH
83577: LD_VAR 0 19
83581: PUSH
83582: LD_VAR 0 20
83586: PUSH
83587: LD_VAR 0 21
83591: PUSH
83592: LD_VAR 0 22
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: PUSH
83605: LD_VAR 0 4
83609: PUSH
83610: LD_INT 1
83612: PLUS
83613: ARRAY
83614: ST_TO_ADDR
83615: GO 83682
83617: LD_INT 3
83619: DOUBLE
83620: EQUAL
83621: IFTRUE 83625
83623: GO 83681
83625: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83626: LD_ADDR_VAR 0 9
83630: PUSH
83631: LD_VAR 0 23
83635: PUSH
83636: LD_VAR 0 24
83640: PUSH
83641: LD_VAR 0 25
83645: PUSH
83646: LD_VAR 0 26
83650: PUSH
83651: LD_VAR 0 27
83655: PUSH
83656: LD_VAR 0 28
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: PUSH
83669: LD_VAR 0 4
83673: PUSH
83674: LD_INT 1
83676: PLUS
83677: ARRAY
83678: ST_TO_ADDR
83679: GO 83682
83681: POP
83682: GO 84237
83684: LD_INT 2
83686: DOUBLE
83687: EQUAL
83688: IFTRUE 83698
83690: LD_INT 3
83692: DOUBLE
83693: EQUAL
83694: IFTRUE 83698
83696: GO 83754
83698: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83699: LD_ADDR_VAR 0 9
83703: PUSH
83704: LD_VAR 0 29
83708: PUSH
83709: LD_VAR 0 30
83713: PUSH
83714: LD_VAR 0 31
83718: PUSH
83719: LD_VAR 0 32
83723: PUSH
83724: LD_VAR 0 33
83728: PUSH
83729: LD_VAR 0 34
83733: PUSH
83734: EMPTY
83735: LIST
83736: LIST
83737: LIST
83738: LIST
83739: LIST
83740: LIST
83741: PUSH
83742: LD_VAR 0 4
83746: PUSH
83747: LD_INT 1
83749: PLUS
83750: ARRAY
83751: ST_TO_ADDR
83752: GO 84237
83754: LD_INT 16
83756: DOUBLE
83757: EQUAL
83758: IFTRUE 83816
83760: LD_INT 17
83762: DOUBLE
83763: EQUAL
83764: IFTRUE 83816
83766: LD_INT 18
83768: DOUBLE
83769: EQUAL
83770: IFTRUE 83816
83772: LD_INT 19
83774: DOUBLE
83775: EQUAL
83776: IFTRUE 83816
83778: LD_INT 22
83780: DOUBLE
83781: EQUAL
83782: IFTRUE 83816
83784: LD_INT 20
83786: DOUBLE
83787: EQUAL
83788: IFTRUE 83816
83790: LD_INT 21
83792: DOUBLE
83793: EQUAL
83794: IFTRUE 83816
83796: LD_INT 23
83798: DOUBLE
83799: EQUAL
83800: IFTRUE 83816
83802: LD_INT 24
83804: DOUBLE
83805: EQUAL
83806: IFTRUE 83816
83808: LD_INT 25
83810: DOUBLE
83811: EQUAL
83812: IFTRUE 83816
83814: GO 83872
83816: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83817: LD_ADDR_VAR 0 9
83821: PUSH
83822: LD_VAR 0 35
83826: PUSH
83827: LD_VAR 0 36
83831: PUSH
83832: LD_VAR 0 37
83836: PUSH
83837: LD_VAR 0 38
83841: PUSH
83842: LD_VAR 0 39
83846: PUSH
83847: LD_VAR 0 40
83851: PUSH
83852: EMPTY
83853: LIST
83854: LIST
83855: LIST
83856: LIST
83857: LIST
83858: LIST
83859: PUSH
83860: LD_VAR 0 4
83864: PUSH
83865: LD_INT 1
83867: PLUS
83868: ARRAY
83869: ST_TO_ADDR
83870: GO 84237
83872: LD_INT 6
83874: DOUBLE
83875: EQUAL
83876: IFTRUE 83928
83878: LD_INT 7
83880: DOUBLE
83881: EQUAL
83882: IFTRUE 83928
83884: LD_INT 8
83886: DOUBLE
83887: EQUAL
83888: IFTRUE 83928
83890: LD_INT 13
83892: DOUBLE
83893: EQUAL
83894: IFTRUE 83928
83896: LD_INT 12
83898: DOUBLE
83899: EQUAL
83900: IFTRUE 83928
83902: LD_INT 15
83904: DOUBLE
83905: EQUAL
83906: IFTRUE 83928
83908: LD_INT 11
83910: DOUBLE
83911: EQUAL
83912: IFTRUE 83928
83914: LD_INT 14
83916: DOUBLE
83917: EQUAL
83918: IFTRUE 83928
83920: LD_INT 10
83922: DOUBLE
83923: EQUAL
83924: IFTRUE 83928
83926: GO 83984
83928: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
83929: LD_ADDR_VAR 0 9
83933: PUSH
83934: LD_VAR 0 41
83938: PUSH
83939: LD_VAR 0 42
83943: PUSH
83944: LD_VAR 0 43
83948: PUSH
83949: LD_VAR 0 44
83953: PUSH
83954: LD_VAR 0 45
83958: PUSH
83959: LD_VAR 0 46
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: PUSH
83972: LD_VAR 0 4
83976: PUSH
83977: LD_INT 1
83979: PLUS
83980: ARRAY
83981: ST_TO_ADDR
83982: GO 84237
83984: LD_INT 36
83986: DOUBLE
83987: EQUAL
83988: IFTRUE 83992
83990: GO 84048
83992: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83993: LD_ADDR_VAR 0 9
83997: PUSH
83998: LD_VAR 0 47
84002: PUSH
84003: LD_VAR 0 48
84007: PUSH
84008: LD_VAR 0 49
84012: PUSH
84013: LD_VAR 0 50
84017: PUSH
84018: LD_VAR 0 51
84022: PUSH
84023: LD_VAR 0 52
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: PUSH
84036: LD_VAR 0 4
84040: PUSH
84041: LD_INT 1
84043: PLUS
84044: ARRAY
84045: ST_TO_ADDR
84046: GO 84237
84048: LD_INT 4
84050: DOUBLE
84051: EQUAL
84052: IFTRUE 84074
84054: LD_INT 5
84056: DOUBLE
84057: EQUAL
84058: IFTRUE 84074
84060: LD_INT 34
84062: DOUBLE
84063: EQUAL
84064: IFTRUE 84074
84066: LD_INT 37
84068: DOUBLE
84069: EQUAL
84070: IFTRUE 84074
84072: GO 84130
84074: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84075: LD_ADDR_VAR 0 9
84079: PUSH
84080: LD_VAR 0 53
84084: PUSH
84085: LD_VAR 0 54
84089: PUSH
84090: LD_VAR 0 55
84094: PUSH
84095: LD_VAR 0 56
84099: PUSH
84100: LD_VAR 0 57
84104: PUSH
84105: LD_VAR 0 58
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: LIST
84114: LIST
84115: LIST
84116: LIST
84117: PUSH
84118: LD_VAR 0 4
84122: PUSH
84123: LD_INT 1
84125: PLUS
84126: ARRAY
84127: ST_TO_ADDR
84128: GO 84237
84130: LD_INT 31
84132: DOUBLE
84133: EQUAL
84134: IFTRUE 84180
84136: LD_INT 32
84138: DOUBLE
84139: EQUAL
84140: IFTRUE 84180
84142: LD_INT 33
84144: DOUBLE
84145: EQUAL
84146: IFTRUE 84180
84148: LD_INT 27
84150: DOUBLE
84151: EQUAL
84152: IFTRUE 84180
84154: LD_INT 26
84156: DOUBLE
84157: EQUAL
84158: IFTRUE 84180
84160: LD_INT 28
84162: DOUBLE
84163: EQUAL
84164: IFTRUE 84180
84166: LD_INT 29
84168: DOUBLE
84169: EQUAL
84170: IFTRUE 84180
84172: LD_INT 30
84174: DOUBLE
84175: EQUAL
84176: IFTRUE 84180
84178: GO 84236
84180: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
84181: LD_ADDR_VAR 0 9
84185: PUSH
84186: LD_VAR 0 59
84190: PUSH
84191: LD_VAR 0 60
84195: PUSH
84196: LD_VAR 0 61
84200: PUSH
84201: LD_VAR 0 62
84205: PUSH
84206: LD_VAR 0 63
84210: PUSH
84211: LD_VAR 0 64
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: PUSH
84224: LD_VAR 0 4
84228: PUSH
84229: LD_INT 1
84231: PLUS
84232: ARRAY
84233: ST_TO_ADDR
84234: GO 84237
84236: POP
// temp_list2 = [ ] ;
84237: LD_ADDR_VAR 0 10
84241: PUSH
84242: EMPTY
84243: ST_TO_ADDR
// for i in temp_list do
84244: LD_ADDR_VAR 0 8
84248: PUSH
84249: LD_VAR 0 9
84253: PUSH
84254: FOR_IN
84255: IFFALSE 84307
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84257: LD_ADDR_VAR 0 10
84261: PUSH
84262: LD_VAR 0 10
84266: PUSH
84267: LD_VAR 0 8
84271: PUSH
84272: LD_INT 1
84274: ARRAY
84275: PUSH
84276: LD_VAR 0 2
84280: PLUS
84281: PUSH
84282: LD_VAR 0 8
84286: PUSH
84287: LD_INT 2
84289: ARRAY
84290: PUSH
84291: LD_VAR 0 3
84295: PLUS
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: EMPTY
84302: LIST
84303: ADD
84304: ST_TO_ADDR
84305: GO 84254
84307: POP
84308: POP
// result = temp_list2 ;
84309: LD_ADDR_VAR 0 7
84313: PUSH
84314: LD_VAR 0 10
84318: ST_TO_ADDR
// end ;
84319: LD_VAR 0 7
84323: RET
// export function EnemyInRange ( unit , dist ) ; begin
84324: LD_INT 0
84326: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84327: LD_ADDR_VAR 0 3
84331: PUSH
84332: LD_VAR 0 1
84336: PPUSH
84337: CALL_OW 255
84341: PPUSH
84342: LD_VAR 0 1
84346: PPUSH
84347: CALL_OW 250
84351: PPUSH
84352: LD_VAR 0 1
84356: PPUSH
84357: CALL_OW 251
84361: PPUSH
84362: LD_VAR 0 2
84366: PPUSH
84367: CALL 58428 0 4
84371: PUSH
84372: LD_INT 4
84374: ARRAY
84375: ST_TO_ADDR
// end ;
84376: LD_VAR 0 3
84380: RET
// export function PlayerSeeMe ( unit ) ; begin
84381: LD_INT 0
84383: PPUSH
// result := See ( your_side , unit ) ;
84384: LD_ADDR_VAR 0 2
84388: PUSH
84389: LD_OWVAR 2
84393: PPUSH
84394: LD_VAR 0 1
84398: PPUSH
84399: CALL_OW 292
84403: ST_TO_ADDR
// end ;
84404: LD_VAR 0 2
84408: RET
// export function ReverseDir ( unit ) ; begin
84409: LD_INT 0
84411: PPUSH
// if not unit then
84412: LD_VAR 0 1
84416: NOT
84417: IFFALSE 84421
// exit ;
84419: GO 84467
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
84421: LD_ADDR_VAR 0 2
84425: PUSH
84426: LD_INT 3
84428: PUSH
84429: LD_INT 4
84431: PUSH
84432: LD_INT 5
84434: PUSH
84435: LD_INT 0
84437: PUSH
84438: LD_INT 1
84440: PUSH
84441: LD_INT 2
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: LIST
84448: LIST
84449: LIST
84450: LIST
84451: PUSH
84452: LD_VAR 0 1
84456: PPUSH
84457: CALL_OW 254
84461: PUSH
84462: LD_INT 1
84464: PLUS
84465: ARRAY
84466: ST_TO_ADDR
// end ;
84467: LD_VAR 0 2
84471: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84472: LD_INT 0
84474: PPUSH
84475: PPUSH
84476: PPUSH
84477: PPUSH
84478: PPUSH
// if not hexes then
84479: LD_VAR 0 2
84483: NOT
84484: IFFALSE 84488
// exit ;
84486: GO 84636
// dist := 9999 ;
84488: LD_ADDR_VAR 0 5
84492: PUSH
84493: LD_INT 9999
84495: ST_TO_ADDR
// for i = 1 to hexes do
84496: LD_ADDR_VAR 0 4
84500: PUSH
84501: DOUBLE
84502: LD_INT 1
84504: DEC
84505: ST_TO_ADDR
84506: LD_VAR 0 2
84510: PUSH
84511: FOR_TO
84512: IFFALSE 84624
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84514: LD_VAR 0 1
84518: PPUSH
84519: LD_VAR 0 2
84523: PUSH
84524: LD_VAR 0 4
84528: ARRAY
84529: PUSH
84530: LD_INT 1
84532: ARRAY
84533: PPUSH
84534: LD_VAR 0 2
84538: PUSH
84539: LD_VAR 0 4
84543: ARRAY
84544: PUSH
84545: LD_INT 2
84547: ARRAY
84548: PPUSH
84549: CALL_OW 297
84553: PUSH
84554: LD_VAR 0 5
84558: LESS
84559: IFFALSE 84622
// begin hex := hexes [ i ] ;
84561: LD_ADDR_VAR 0 7
84565: PUSH
84566: LD_VAR 0 2
84570: PUSH
84571: LD_VAR 0 4
84575: ARRAY
84576: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84577: LD_ADDR_VAR 0 5
84581: PUSH
84582: LD_VAR 0 1
84586: PPUSH
84587: LD_VAR 0 2
84591: PUSH
84592: LD_VAR 0 4
84596: ARRAY
84597: PUSH
84598: LD_INT 1
84600: ARRAY
84601: PPUSH
84602: LD_VAR 0 2
84606: PUSH
84607: LD_VAR 0 4
84611: ARRAY
84612: PUSH
84613: LD_INT 2
84615: ARRAY
84616: PPUSH
84617: CALL_OW 297
84621: ST_TO_ADDR
// end ; end ;
84622: GO 84511
84624: POP
84625: POP
// result := hex ;
84626: LD_ADDR_VAR 0 3
84630: PUSH
84631: LD_VAR 0 7
84635: ST_TO_ADDR
// end ;
84636: LD_VAR 0 3
84640: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84641: LD_INT 0
84643: PPUSH
84644: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84645: LD_VAR 0 1
84649: NOT
84650: PUSH
84651: LD_VAR 0 1
84655: PUSH
84656: LD_INT 21
84658: PUSH
84659: LD_INT 2
84661: PUSH
84662: EMPTY
84663: LIST
84664: LIST
84665: PUSH
84666: LD_INT 23
84668: PUSH
84669: LD_INT 2
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: PUSH
84676: EMPTY
84677: LIST
84678: LIST
84679: PPUSH
84680: CALL_OW 69
84684: IN
84685: NOT
84686: OR
84687: IFFALSE 84691
// exit ;
84689: GO 84738
// for i = 1 to 3 do
84691: LD_ADDR_VAR 0 3
84695: PUSH
84696: DOUBLE
84697: LD_INT 1
84699: DEC
84700: ST_TO_ADDR
84701: LD_INT 3
84703: PUSH
84704: FOR_TO
84705: IFFALSE 84736
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84707: LD_VAR 0 1
84711: PPUSH
84712: CALL_OW 250
84716: PPUSH
84717: LD_VAR 0 1
84721: PPUSH
84722: CALL_OW 251
84726: PPUSH
84727: LD_INT 1
84729: PPUSH
84730: CALL_OW 453
84734: GO 84704
84736: POP
84737: POP
// end ;
84738: LD_VAR 0 2
84742: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84743: LD_INT 0
84745: PPUSH
84746: PPUSH
84747: PPUSH
84748: PPUSH
84749: PPUSH
84750: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84751: LD_VAR 0 1
84755: NOT
84756: PUSH
84757: LD_VAR 0 2
84761: NOT
84762: OR
84763: PUSH
84764: LD_VAR 0 1
84768: PPUSH
84769: CALL_OW 314
84773: OR
84774: IFFALSE 84778
// exit ;
84776: GO 85219
// x := GetX ( enemy_unit ) ;
84778: LD_ADDR_VAR 0 7
84782: PUSH
84783: LD_VAR 0 2
84787: PPUSH
84788: CALL_OW 250
84792: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84793: LD_ADDR_VAR 0 8
84797: PUSH
84798: LD_VAR 0 2
84802: PPUSH
84803: CALL_OW 251
84807: ST_TO_ADDR
// if not x or not y then
84808: LD_VAR 0 7
84812: NOT
84813: PUSH
84814: LD_VAR 0 8
84818: NOT
84819: OR
84820: IFFALSE 84824
// exit ;
84822: GO 85219
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84824: LD_ADDR_VAR 0 6
84828: PUSH
84829: LD_VAR 0 7
84833: PPUSH
84834: LD_INT 0
84836: PPUSH
84837: LD_INT 4
84839: PPUSH
84840: CALL_OW 272
84844: PUSH
84845: LD_VAR 0 8
84849: PPUSH
84850: LD_INT 0
84852: PPUSH
84853: LD_INT 4
84855: PPUSH
84856: CALL_OW 273
84860: PUSH
84861: EMPTY
84862: LIST
84863: LIST
84864: PUSH
84865: LD_VAR 0 7
84869: PPUSH
84870: LD_INT 1
84872: PPUSH
84873: LD_INT 4
84875: PPUSH
84876: CALL_OW 272
84880: PUSH
84881: LD_VAR 0 8
84885: PPUSH
84886: LD_INT 1
84888: PPUSH
84889: LD_INT 4
84891: PPUSH
84892: CALL_OW 273
84896: PUSH
84897: EMPTY
84898: LIST
84899: LIST
84900: PUSH
84901: LD_VAR 0 7
84905: PPUSH
84906: LD_INT 2
84908: PPUSH
84909: LD_INT 4
84911: PPUSH
84912: CALL_OW 272
84916: PUSH
84917: LD_VAR 0 8
84921: PPUSH
84922: LD_INT 2
84924: PPUSH
84925: LD_INT 4
84927: PPUSH
84928: CALL_OW 273
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: LD_VAR 0 7
84941: PPUSH
84942: LD_INT 3
84944: PPUSH
84945: LD_INT 4
84947: PPUSH
84948: CALL_OW 272
84952: PUSH
84953: LD_VAR 0 8
84957: PPUSH
84958: LD_INT 3
84960: PPUSH
84961: LD_INT 4
84963: PPUSH
84964: CALL_OW 273
84968: PUSH
84969: EMPTY
84970: LIST
84971: LIST
84972: PUSH
84973: LD_VAR 0 7
84977: PPUSH
84978: LD_INT 4
84980: PPUSH
84981: LD_INT 4
84983: PPUSH
84984: CALL_OW 272
84988: PUSH
84989: LD_VAR 0 8
84993: PPUSH
84994: LD_INT 4
84996: PPUSH
84997: LD_INT 4
84999: PPUSH
85000: CALL_OW 273
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_VAR 0 7
85013: PPUSH
85014: LD_INT 5
85016: PPUSH
85017: LD_INT 4
85019: PPUSH
85020: CALL_OW 272
85024: PUSH
85025: LD_VAR 0 8
85029: PPUSH
85030: LD_INT 5
85032: PPUSH
85033: LD_INT 4
85035: PPUSH
85036: CALL_OW 273
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: ST_TO_ADDR
// for i = tmp downto 1 do
85053: LD_ADDR_VAR 0 4
85057: PUSH
85058: DOUBLE
85059: LD_VAR 0 6
85063: INC
85064: ST_TO_ADDR
85065: LD_INT 1
85067: PUSH
85068: FOR_DOWNTO
85069: IFFALSE 85170
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85071: LD_VAR 0 6
85075: PUSH
85076: LD_VAR 0 4
85080: ARRAY
85081: PUSH
85082: LD_INT 1
85084: ARRAY
85085: PPUSH
85086: LD_VAR 0 6
85090: PUSH
85091: LD_VAR 0 4
85095: ARRAY
85096: PUSH
85097: LD_INT 2
85099: ARRAY
85100: PPUSH
85101: CALL_OW 488
85105: NOT
85106: PUSH
85107: LD_VAR 0 6
85111: PUSH
85112: LD_VAR 0 4
85116: ARRAY
85117: PUSH
85118: LD_INT 1
85120: ARRAY
85121: PPUSH
85122: LD_VAR 0 6
85126: PUSH
85127: LD_VAR 0 4
85131: ARRAY
85132: PUSH
85133: LD_INT 2
85135: ARRAY
85136: PPUSH
85137: CALL_OW 428
85141: PUSH
85142: LD_INT 0
85144: NONEQUAL
85145: OR
85146: IFFALSE 85168
// tmp := Delete ( tmp , i ) ;
85148: LD_ADDR_VAR 0 6
85152: PUSH
85153: LD_VAR 0 6
85157: PPUSH
85158: LD_VAR 0 4
85162: PPUSH
85163: CALL_OW 3
85167: ST_TO_ADDR
85168: GO 85068
85170: POP
85171: POP
// j := GetClosestHex ( unit , tmp ) ;
85172: LD_ADDR_VAR 0 5
85176: PUSH
85177: LD_VAR 0 1
85181: PPUSH
85182: LD_VAR 0 6
85186: PPUSH
85187: CALL 84472 0 2
85191: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85192: LD_VAR 0 1
85196: PPUSH
85197: LD_VAR 0 5
85201: PUSH
85202: LD_INT 1
85204: ARRAY
85205: PPUSH
85206: LD_VAR 0 5
85210: PUSH
85211: LD_INT 2
85213: ARRAY
85214: PPUSH
85215: CALL_OW 111
// end ;
85219: LD_VAR 0 3
85223: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85224: LD_INT 0
85226: PPUSH
85227: PPUSH
85228: PPUSH
// uc_side = 0 ;
85229: LD_ADDR_OWVAR 20
85233: PUSH
85234: LD_INT 0
85236: ST_TO_ADDR
// uc_nation = 0 ;
85237: LD_ADDR_OWVAR 21
85241: PUSH
85242: LD_INT 0
85244: ST_TO_ADDR
// InitHc ;
85245: CALL_OW 19
// InitVc ;
85249: CALL_OW 20
// if mastodonts then
85253: LD_VAR 0 6
85257: IFFALSE 85324
// for i = 1 to mastodonts do
85259: LD_ADDR_VAR 0 11
85263: PUSH
85264: DOUBLE
85265: LD_INT 1
85267: DEC
85268: ST_TO_ADDR
85269: LD_VAR 0 6
85273: PUSH
85274: FOR_TO
85275: IFFALSE 85322
// begin vc_chassis := 31 ;
85277: LD_ADDR_OWVAR 37
85281: PUSH
85282: LD_INT 31
85284: ST_TO_ADDR
// vc_control := control_rider ;
85285: LD_ADDR_OWVAR 38
85289: PUSH
85290: LD_INT 4
85292: ST_TO_ADDR
// animal := CreateVehicle ;
85293: LD_ADDR_VAR 0 12
85297: PUSH
85298: CALL_OW 45
85302: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85303: LD_VAR 0 12
85307: PPUSH
85308: LD_VAR 0 8
85312: PPUSH
85313: LD_INT 0
85315: PPUSH
85316: CALL 92095 0 3
// end ;
85320: GO 85274
85322: POP
85323: POP
// if horses then
85324: LD_VAR 0 5
85328: IFFALSE 85395
// for i = 1 to horses do
85330: LD_ADDR_VAR 0 11
85334: PUSH
85335: DOUBLE
85336: LD_INT 1
85338: DEC
85339: ST_TO_ADDR
85340: LD_VAR 0 5
85344: PUSH
85345: FOR_TO
85346: IFFALSE 85393
// begin hc_class := 21 ;
85348: LD_ADDR_OWVAR 28
85352: PUSH
85353: LD_INT 21
85355: ST_TO_ADDR
// hc_gallery :=  ;
85356: LD_ADDR_OWVAR 33
85360: PUSH
85361: LD_STRING 
85363: ST_TO_ADDR
// animal := CreateHuman ;
85364: LD_ADDR_VAR 0 12
85368: PUSH
85369: CALL_OW 44
85373: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85374: LD_VAR 0 12
85378: PPUSH
85379: LD_VAR 0 8
85383: PPUSH
85384: LD_INT 0
85386: PPUSH
85387: CALL 92095 0 3
// end ;
85391: GO 85345
85393: POP
85394: POP
// if birds then
85395: LD_VAR 0 1
85399: IFFALSE 85466
// for i = 1 to birds do
85401: LD_ADDR_VAR 0 11
85405: PUSH
85406: DOUBLE
85407: LD_INT 1
85409: DEC
85410: ST_TO_ADDR
85411: LD_VAR 0 1
85415: PUSH
85416: FOR_TO
85417: IFFALSE 85464
// begin hc_class = 18 ;
85419: LD_ADDR_OWVAR 28
85423: PUSH
85424: LD_INT 18
85426: ST_TO_ADDR
// hc_gallery =  ;
85427: LD_ADDR_OWVAR 33
85431: PUSH
85432: LD_STRING 
85434: ST_TO_ADDR
// animal := CreateHuman ;
85435: LD_ADDR_VAR 0 12
85439: PUSH
85440: CALL_OW 44
85444: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85445: LD_VAR 0 12
85449: PPUSH
85450: LD_VAR 0 8
85454: PPUSH
85455: LD_INT 0
85457: PPUSH
85458: CALL 92095 0 3
// end ;
85462: GO 85416
85464: POP
85465: POP
// if tigers then
85466: LD_VAR 0 2
85470: IFFALSE 85554
// for i = 1 to tigers do
85472: LD_ADDR_VAR 0 11
85476: PUSH
85477: DOUBLE
85478: LD_INT 1
85480: DEC
85481: ST_TO_ADDR
85482: LD_VAR 0 2
85486: PUSH
85487: FOR_TO
85488: IFFALSE 85552
// begin hc_class = class_tiger ;
85490: LD_ADDR_OWVAR 28
85494: PUSH
85495: LD_INT 14
85497: ST_TO_ADDR
// hc_gallery =  ;
85498: LD_ADDR_OWVAR 33
85502: PUSH
85503: LD_STRING 
85505: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85506: LD_ADDR_OWVAR 35
85510: PUSH
85511: LD_INT 7
85513: NEG
85514: PPUSH
85515: LD_INT 7
85517: PPUSH
85518: CALL_OW 12
85522: ST_TO_ADDR
// animal := CreateHuman ;
85523: LD_ADDR_VAR 0 12
85527: PUSH
85528: CALL_OW 44
85532: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85533: LD_VAR 0 12
85537: PPUSH
85538: LD_VAR 0 8
85542: PPUSH
85543: LD_INT 0
85545: PPUSH
85546: CALL 92095 0 3
// end ;
85550: GO 85487
85552: POP
85553: POP
// if apemans then
85554: LD_VAR 0 3
85558: IFFALSE 85681
// for i = 1 to apemans do
85560: LD_ADDR_VAR 0 11
85564: PUSH
85565: DOUBLE
85566: LD_INT 1
85568: DEC
85569: ST_TO_ADDR
85570: LD_VAR 0 3
85574: PUSH
85575: FOR_TO
85576: IFFALSE 85679
// begin hc_class = class_apeman ;
85578: LD_ADDR_OWVAR 28
85582: PUSH
85583: LD_INT 12
85585: ST_TO_ADDR
// hc_gallery =  ;
85586: LD_ADDR_OWVAR 33
85590: PUSH
85591: LD_STRING 
85593: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85594: LD_ADDR_OWVAR 35
85598: PUSH
85599: LD_INT 5
85601: NEG
85602: PPUSH
85603: LD_INT 5
85605: PPUSH
85606: CALL_OW 12
85610: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85611: LD_ADDR_OWVAR 31
85615: PUSH
85616: LD_INT 1
85618: PPUSH
85619: LD_INT 3
85621: PPUSH
85622: CALL_OW 12
85626: PUSH
85627: LD_INT 1
85629: PPUSH
85630: LD_INT 3
85632: PPUSH
85633: CALL_OW 12
85637: PUSH
85638: LD_INT 0
85640: PUSH
85641: LD_INT 0
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: LIST
85648: LIST
85649: ST_TO_ADDR
// animal := CreateHuman ;
85650: LD_ADDR_VAR 0 12
85654: PUSH
85655: CALL_OW 44
85659: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85660: LD_VAR 0 12
85664: PPUSH
85665: LD_VAR 0 8
85669: PPUSH
85670: LD_INT 0
85672: PPUSH
85673: CALL 92095 0 3
// end ;
85677: GO 85575
85679: POP
85680: POP
// if enchidnas then
85681: LD_VAR 0 4
85685: IFFALSE 85752
// for i = 1 to enchidnas do
85687: LD_ADDR_VAR 0 11
85691: PUSH
85692: DOUBLE
85693: LD_INT 1
85695: DEC
85696: ST_TO_ADDR
85697: LD_VAR 0 4
85701: PUSH
85702: FOR_TO
85703: IFFALSE 85750
// begin hc_class = 13 ;
85705: LD_ADDR_OWVAR 28
85709: PUSH
85710: LD_INT 13
85712: ST_TO_ADDR
// hc_gallery =  ;
85713: LD_ADDR_OWVAR 33
85717: PUSH
85718: LD_STRING 
85720: ST_TO_ADDR
// animal := CreateHuman ;
85721: LD_ADDR_VAR 0 12
85725: PUSH
85726: CALL_OW 44
85730: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85731: LD_VAR 0 12
85735: PPUSH
85736: LD_VAR 0 8
85740: PPUSH
85741: LD_INT 0
85743: PPUSH
85744: CALL 92095 0 3
// end ;
85748: GO 85702
85750: POP
85751: POP
// if fishes then
85752: LD_VAR 0 7
85756: IFFALSE 85823
// for i = 1 to fishes do
85758: LD_ADDR_VAR 0 11
85762: PUSH
85763: DOUBLE
85764: LD_INT 1
85766: DEC
85767: ST_TO_ADDR
85768: LD_VAR 0 7
85772: PUSH
85773: FOR_TO
85774: IFFALSE 85821
// begin hc_class = 20 ;
85776: LD_ADDR_OWVAR 28
85780: PUSH
85781: LD_INT 20
85783: ST_TO_ADDR
// hc_gallery =  ;
85784: LD_ADDR_OWVAR 33
85788: PUSH
85789: LD_STRING 
85791: ST_TO_ADDR
// animal := CreateHuman ;
85792: LD_ADDR_VAR 0 12
85796: PUSH
85797: CALL_OW 44
85801: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85802: LD_VAR 0 12
85806: PPUSH
85807: LD_VAR 0 9
85811: PPUSH
85812: LD_INT 0
85814: PPUSH
85815: CALL 92095 0 3
// end ;
85819: GO 85773
85821: POP
85822: POP
// end ;
85823: LD_VAR 0 10
85827: RET
// export function WantHeal ( sci , unit ) ; begin
85828: LD_INT 0
85830: PPUSH
// if GetTaskList ( sci ) > 0 then
85831: LD_VAR 0 1
85835: PPUSH
85836: CALL_OW 437
85840: PUSH
85841: LD_INT 0
85843: GREATER
85844: IFFALSE 85914
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85846: LD_VAR 0 1
85850: PPUSH
85851: CALL_OW 437
85855: PUSH
85856: LD_INT 1
85858: ARRAY
85859: PUSH
85860: LD_INT 1
85862: ARRAY
85863: PUSH
85864: LD_STRING l
85866: EQUAL
85867: PUSH
85868: LD_VAR 0 1
85872: PPUSH
85873: CALL_OW 437
85877: PUSH
85878: LD_INT 1
85880: ARRAY
85881: PUSH
85882: LD_INT 4
85884: ARRAY
85885: PUSH
85886: LD_VAR 0 2
85890: EQUAL
85891: AND
85892: IFFALSE 85904
// result := true else
85894: LD_ADDR_VAR 0 3
85898: PUSH
85899: LD_INT 1
85901: ST_TO_ADDR
85902: GO 85912
// result := false ;
85904: LD_ADDR_VAR 0 3
85908: PUSH
85909: LD_INT 0
85911: ST_TO_ADDR
// end else
85912: GO 85922
// result := false ;
85914: LD_ADDR_VAR 0 3
85918: PUSH
85919: LD_INT 0
85921: ST_TO_ADDR
// end ;
85922: LD_VAR 0 3
85926: RET
// export function HealTarget ( sci ) ; begin
85927: LD_INT 0
85929: PPUSH
// if not sci then
85930: LD_VAR 0 1
85934: NOT
85935: IFFALSE 85939
// exit ;
85937: GO 86004
// result := 0 ;
85939: LD_ADDR_VAR 0 2
85943: PUSH
85944: LD_INT 0
85946: ST_TO_ADDR
// if GetTaskList ( sci ) then
85947: LD_VAR 0 1
85951: PPUSH
85952: CALL_OW 437
85956: IFFALSE 86004
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85958: LD_VAR 0 1
85962: PPUSH
85963: CALL_OW 437
85967: PUSH
85968: LD_INT 1
85970: ARRAY
85971: PUSH
85972: LD_INT 1
85974: ARRAY
85975: PUSH
85976: LD_STRING l
85978: EQUAL
85979: IFFALSE 86004
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85981: LD_ADDR_VAR 0 2
85985: PUSH
85986: LD_VAR 0 1
85990: PPUSH
85991: CALL_OW 437
85995: PUSH
85996: LD_INT 1
85998: ARRAY
85999: PUSH
86000: LD_INT 4
86002: ARRAY
86003: ST_TO_ADDR
// end ;
86004: LD_VAR 0 2
86008: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
86009: LD_INT 0
86011: PPUSH
86012: PPUSH
86013: PPUSH
86014: PPUSH
86015: PPUSH
86016: PPUSH
86017: PPUSH
86018: PPUSH
86019: PPUSH
86020: PPUSH
86021: PPUSH
86022: PPUSH
86023: PPUSH
86024: PPUSH
86025: PPUSH
86026: PPUSH
86027: PPUSH
86028: PPUSH
86029: PPUSH
86030: PPUSH
86031: PPUSH
86032: PPUSH
86033: PPUSH
86034: PPUSH
86035: PPUSH
86036: PPUSH
86037: PPUSH
86038: PPUSH
86039: PPUSH
86040: PPUSH
86041: PPUSH
86042: PPUSH
86043: PPUSH
86044: PPUSH
// if not list then
86045: LD_VAR 0 1
86049: NOT
86050: IFFALSE 86054
// exit ;
86052: GO 90706
// base := list [ 1 ] ;
86054: LD_ADDR_VAR 0 3
86058: PUSH
86059: LD_VAR 0 1
86063: PUSH
86064: LD_INT 1
86066: ARRAY
86067: ST_TO_ADDR
// group := list [ 2 ] ;
86068: LD_ADDR_VAR 0 4
86072: PUSH
86073: LD_VAR 0 1
86077: PUSH
86078: LD_INT 2
86080: ARRAY
86081: ST_TO_ADDR
// path := list [ 3 ] ;
86082: LD_ADDR_VAR 0 5
86086: PUSH
86087: LD_VAR 0 1
86091: PUSH
86092: LD_INT 3
86094: ARRAY
86095: ST_TO_ADDR
// flags := list [ 4 ] ;
86096: LD_ADDR_VAR 0 6
86100: PUSH
86101: LD_VAR 0 1
86105: PUSH
86106: LD_INT 4
86108: ARRAY
86109: ST_TO_ADDR
// mined := [ ] ;
86110: LD_ADDR_VAR 0 27
86114: PUSH
86115: EMPTY
86116: ST_TO_ADDR
// bombed := [ ] ;
86117: LD_ADDR_VAR 0 28
86121: PUSH
86122: EMPTY
86123: ST_TO_ADDR
// healers := [ ] ;
86124: LD_ADDR_VAR 0 31
86128: PUSH
86129: EMPTY
86130: ST_TO_ADDR
// to_heal := [ ] ;
86131: LD_ADDR_VAR 0 30
86135: PUSH
86136: EMPTY
86137: ST_TO_ADDR
// repairs := [ ] ;
86138: LD_ADDR_VAR 0 33
86142: PUSH
86143: EMPTY
86144: ST_TO_ADDR
// to_repair := [ ] ;
86145: LD_ADDR_VAR 0 32
86149: PUSH
86150: EMPTY
86151: ST_TO_ADDR
// if not group or not path then
86152: LD_VAR 0 4
86156: NOT
86157: PUSH
86158: LD_VAR 0 5
86162: NOT
86163: OR
86164: IFFALSE 86168
// exit ;
86166: GO 90706
// side := GetSide ( group [ 1 ] ) ;
86168: LD_ADDR_VAR 0 35
86172: PUSH
86173: LD_VAR 0 4
86177: PUSH
86178: LD_INT 1
86180: ARRAY
86181: PPUSH
86182: CALL_OW 255
86186: ST_TO_ADDR
// if flags then
86187: LD_VAR 0 6
86191: IFFALSE 86335
// begin f_ignore_area := flags [ 1 ] ;
86193: LD_ADDR_VAR 0 17
86197: PUSH
86198: LD_VAR 0 6
86202: PUSH
86203: LD_INT 1
86205: ARRAY
86206: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
86207: LD_ADDR_VAR 0 18
86211: PUSH
86212: LD_VAR 0 6
86216: PUSH
86217: LD_INT 2
86219: ARRAY
86220: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
86221: LD_ADDR_VAR 0 19
86225: PUSH
86226: LD_VAR 0 6
86230: PUSH
86231: LD_INT 3
86233: ARRAY
86234: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
86235: LD_ADDR_VAR 0 20
86239: PUSH
86240: LD_VAR 0 6
86244: PUSH
86245: LD_INT 4
86247: ARRAY
86248: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86249: LD_ADDR_VAR 0 21
86253: PUSH
86254: LD_VAR 0 6
86258: PUSH
86259: LD_INT 5
86261: ARRAY
86262: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86263: LD_ADDR_VAR 0 22
86267: PUSH
86268: LD_VAR 0 6
86272: PUSH
86273: LD_INT 6
86275: ARRAY
86276: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86277: LD_ADDR_VAR 0 23
86281: PUSH
86282: LD_VAR 0 6
86286: PUSH
86287: LD_INT 7
86289: ARRAY
86290: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86291: LD_ADDR_VAR 0 24
86295: PUSH
86296: LD_VAR 0 6
86300: PUSH
86301: LD_INT 8
86303: ARRAY
86304: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86305: LD_ADDR_VAR 0 25
86309: PUSH
86310: LD_VAR 0 6
86314: PUSH
86315: LD_INT 9
86317: ARRAY
86318: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86319: LD_ADDR_VAR 0 26
86323: PUSH
86324: LD_VAR 0 6
86328: PUSH
86329: LD_INT 10
86331: ARRAY
86332: ST_TO_ADDR
// end else
86333: GO 86415
// begin f_ignore_area := false ;
86335: LD_ADDR_VAR 0 17
86339: PUSH
86340: LD_INT 0
86342: ST_TO_ADDR
// f_capture := false ;
86343: LD_ADDR_VAR 0 18
86347: PUSH
86348: LD_INT 0
86350: ST_TO_ADDR
// f_ignore_civ := false ;
86351: LD_ADDR_VAR 0 19
86355: PUSH
86356: LD_INT 0
86358: ST_TO_ADDR
// f_murder := false ;
86359: LD_ADDR_VAR 0 20
86363: PUSH
86364: LD_INT 0
86366: ST_TO_ADDR
// f_mines := false ;
86367: LD_ADDR_VAR 0 21
86371: PUSH
86372: LD_INT 0
86374: ST_TO_ADDR
// f_repair := false ;
86375: LD_ADDR_VAR 0 22
86379: PUSH
86380: LD_INT 0
86382: ST_TO_ADDR
// f_heal := false ;
86383: LD_ADDR_VAR 0 23
86387: PUSH
86388: LD_INT 0
86390: ST_TO_ADDR
// f_spacetime := false ;
86391: LD_ADDR_VAR 0 24
86395: PUSH
86396: LD_INT 0
86398: ST_TO_ADDR
// f_attack_depot := false ;
86399: LD_ADDR_VAR 0 25
86403: PUSH
86404: LD_INT 0
86406: ST_TO_ADDR
// f_crawl := false ;
86407: LD_ADDR_VAR 0 26
86411: PUSH
86412: LD_INT 0
86414: ST_TO_ADDR
// end ; if f_heal then
86415: LD_VAR 0 23
86419: IFFALSE 86446
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86421: LD_ADDR_VAR 0 31
86425: PUSH
86426: LD_VAR 0 4
86430: PPUSH
86431: LD_INT 25
86433: PUSH
86434: LD_INT 4
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PPUSH
86441: CALL_OW 72
86445: ST_TO_ADDR
// if f_repair then
86446: LD_VAR 0 22
86450: IFFALSE 86477
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86452: LD_ADDR_VAR 0 33
86456: PUSH
86457: LD_VAR 0 4
86461: PPUSH
86462: LD_INT 25
86464: PUSH
86465: LD_INT 3
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: PPUSH
86472: CALL_OW 72
86476: ST_TO_ADDR
// units_path := [ ] ;
86477: LD_ADDR_VAR 0 16
86481: PUSH
86482: EMPTY
86483: ST_TO_ADDR
// for i = 1 to group do
86484: LD_ADDR_VAR 0 7
86488: PUSH
86489: DOUBLE
86490: LD_INT 1
86492: DEC
86493: ST_TO_ADDR
86494: LD_VAR 0 4
86498: PUSH
86499: FOR_TO
86500: IFFALSE 86529
// units_path := Replace ( units_path , i , path ) ;
86502: LD_ADDR_VAR 0 16
86506: PUSH
86507: LD_VAR 0 16
86511: PPUSH
86512: LD_VAR 0 7
86516: PPUSH
86517: LD_VAR 0 5
86521: PPUSH
86522: CALL_OW 1
86526: ST_TO_ADDR
86527: GO 86499
86529: POP
86530: POP
// repeat for i = group downto 1 do
86531: LD_ADDR_VAR 0 7
86535: PUSH
86536: DOUBLE
86537: LD_VAR 0 4
86541: INC
86542: ST_TO_ADDR
86543: LD_INT 1
86545: PUSH
86546: FOR_DOWNTO
86547: IFFALSE 90669
// begin wait ( 5 ) ;
86549: LD_INT 5
86551: PPUSH
86552: CALL_OW 67
// tmp := [ ] ;
86556: LD_ADDR_VAR 0 14
86560: PUSH
86561: EMPTY
86562: ST_TO_ADDR
// attacking := false ;
86563: LD_ADDR_VAR 0 29
86567: PUSH
86568: LD_INT 0
86570: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86571: LD_VAR 0 4
86575: PUSH
86576: LD_VAR 0 7
86580: ARRAY
86581: PPUSH
86582: CALL_OW 301
86586: PUSH
86587: LD_VAR 0 4
86591: PUSH
86592: LD_VAR 0 7
86596: ARRAY
86597: NOT
86598: OR
86599: IFFALSE 86708
// begin if GetType ( group [ i ] ) = unit_human then
86601: LD_VAR 0 4
86605: PUSH
86606: LD_VAR 0 7
86610: ARRAY
86611: PPUSH
86612: CALL_OW 247
86616: PUSH
86617: LD_INT 1
86619: EQUAL
86620: IFFALSE 86666
// begin to_heal := to_heal diff group [ i ] ;
86622: LD_ADDR_VAR 0 30
86626: PUSH
86627: LD_VAR 0 30
86631: PUSH
86632: LD_VAR 0 4
86636: PUSH
86637: LD_VAR 0 7
86641: ARRAY
86642: DIFF
86643: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86644: LD_ADDR_VAR 0 31
86648: PUSH
86649: LD_VAR 0 31
86653: PUSH
86654: LD_VAR 0 4
86658: PUSH
86659: LD_VAR 0 7
86663: ARRAY
86664: DIFF
86665: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86666: LD_ADDR_VAR 0 4
86670: PUSH
86671: LD_VAR 0 4
86675: PPUSH
86676: LD_VAR 0 7
86680: PPUSH
86681: CALL_OW 3
86685: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86686: LD_ADDR_VAR 0 16
86690: PUSH
86691: LD_VAR 0 16
86695: PPUSH
86696: LD_VAR 0 7
86700: PPUSH
86701: CALL_OW 3
86705: ST_TO_ADDR
// continue ;
86706: GO 86546
// end ; if f_repair then
86708: LD_VAR 0 22
86712: IFFALSE 87201
// begin if GetType ( group [ i ] ) = unit_vehicle then
86714: LD_VAR 0 4
86718: PUSH
86719: LD_VAR 0 7
86723: ARRAY
86724: PPUSH
86725: CALL_OW 247
86729: PUSH
86730: LD_INT 2
86732: EQUAL
86733: IFFALSE 86923
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86735: LD_VAR 0 4
86739: PUSH
86740: LD_VAR 0 7
86744: ARRAY
86745: PPUSH
86746: CALL_OW 256
86750: PUSH
86751: LD_INT 700
86753: LESS
86754: PUSH
86755: LD_VAR 0 4
86759: PUSH
86760: LD_VAR 0 7
86764: ARRAY
86765: PUSH
86766: LD_VAR 0 32
86770: IN
86771: NOT
86772: AND
86773: IFFALSE 86797
// to_repair := to_repair union group [ i ] ;
86775: LD_ADDR_VAR 0 32
86779: PUSH
86780: LD_VAR 0 32
86784: PUSH
86785: LD_VAR 0 4
86789: PUSH
86790: LD_VAR 0 7
86794: ARRAY
86795: UNION
86796: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86797: LD_VAR 0 4
86801: PUSH
86802: LD_VAR 0 7
86806: ARRAY
86807: PPUSH
86808: CALL_OW 256
86812: PUSH
86813: LD_INT 1000
86815: EQUAL
86816: PUSH
86817: LD_VAR 0 4
86821: PUSH
86822: LD_VAR 0 7
86826: ARRAY
86827: PUSH
86828: LD_VAR 0 32
86832: IN
86833: AND
86834: IFFALSE 86858
// to_repair := to_repair diff group [ i ] ;
86836: LD_ADDR_VAR 0 32
86840: PUSH
86841: LD_VAR 0 32
86845: PUSH
86846: LD_VAR 0 4
86850: PUSH
86851: LD_VAR 0 7
86855: ARRAY
86856: DIFF
86857: ST_TO_ADDR
// if group [ i ] in to_repair then
86858: LD_VAR 0 4
86862: PUSH
86863: LD_VAR 0 7
86867: ARRAY
86868: PUSH
86869: LD_VAR 0 32
86873: IN
86874: IFFALSE 86921
// begin if not IsInArea ( group [ i ] , f_repair ) then
86876: LD_VAR 0 4
86880: PUSH
86881: LD_VAR 0 7
86885: ARRAY
86886: PPUSH
86887: LD_VAR 0 22
86891: PPUSH
86892: CALL_OW 308
86896: NOT
86897: IFFALSE 86919
// ComMoveToArea ( group [ i ] , f_repair ) ;
86899: LD_VAR 0 4
86903: PUSH
86904: LD_VAR 0 7
86908: ARRAY
86909: PPUSH
86910: LD_VAR 0 22
86914: PPUSH
86915: CALL_OW 113
// continue ;
86919: GO 86546
// end ; end else
86921: GO 87201
// if group [ i ] in repairs then
86923: LD_VAR 0 4
86927: PUSH
86928: LD_VAR 0 7
86932: ARRAY
86933: PUSH
86934: LD_VAR 0 33
86938: IN
86939: IFFALSE 87201
// begin if IsInUnit ( group [ i ] ) then
86941: LD_VAR 0 4
86945: PUSH
86946: LD_VAR 0 7
86950: ARRAY
86951: PPUSH
86952: CALL_OW 310
86956: IFFALSE 87024
// begin z := IsInUnit ( group [ i ] ) ;
86958: LD_ADDR_VAR 0 13
86962: PUSH
86963: LD_VAR 0 4
86967: PUSH
86968: LD_VAR 0 7
86972: ARRAY
86973: PPUSH
86974: CALL_OW 310
86978: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
86979: LD_VAR 0 13
86983: PUSH
86984: LD_VAR 0 32
86988: IN
86989: PUSH
86990: LD_VAR 0 13
86994: PPUSH
86995: LD_VAR 0 22
86999: PPUSH
87000: CALL_OW 308
87004: AND
87005: IFFALSE 87022
// ComExitVehicle ( group [ i ] ) ;
87007: LD_VAR 0 4
87011: PUSH
87012: LD_VAR 0 7
87016: ARRAY
87017: PPUSH
87018: CALL_OW 121
// end else
87022: GO 87201
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
87024: LD_ADDR_VAR 0 13
87028: PUSH
87029: LD_VAR 0 4
87033: PPUSH
87034: LD_INT 95
87036: PUSH
87037: LD_VAR 0 22
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 58
87048: PUSH
87049: EMPTY
87050: LIST
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PPUSH
87056: CALL_OW 72
87060: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
87061: LD_VAR 0 4
87065: PUSH
87066: LD_VAR 0 7
87070: ARRAY
87071: PPUSH
87072: CALL_OW 314
87076: NOT
87077: IFFALSE 87199
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
87079: LD_ADDR_VAR 0 10
87083: PUSH
87084: LD_VAR 0 13
87088: PPUSH
87089: LD_VAR 0 4
87093: PUSH
87094: LD_VAR 0 7
87098: ARRAY
87099: PPUSH
87100: CALL_OW 74
87104: ST_TO_ADDR
// if not x then
87105: LD_VAR 0 10
87109: NOT
87110: IFFALSE 87114
// continue ;
87112: GO 86546
// if GetLives ( x ) < 1000 then
87114: LD_VAR 0 10
87118: PPUSH
87119: CALL_OW 256
87123: PUSH
87124: LD_INT 1000
87126: LESS
87127: IFFALSE 87151
// ComRepairVehicle ( group [ i ] , x ) else
87129: LD_VAR 0 4
87133: PUSH
87134: LD_VAR 0 7
87138: ARRAY
87139: PPUSH
87140: LD_VAR 0 10
87144: PPUSH
87145: CALL_OW 129
87149: GO 87199
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
87151: LD_VAR 0 23
87155: PUSH
87156: LD_VAR 0 4
87160: PUSH
87161: LD_VAR 0 7
87165: ARRAY
87166: PPUSH
87167: CALL_OW 256
87171: PUSH
87172: LD_INT 1000
87174: LESS
87175: AND
87176: NOT
87177: IFFALSE 87199
// ComEnterUnit ( group [ i ] , x ) ;
87179: LD_VAR 0 4
87183: PUSH
87184: LD_VAR 0 7
87188: ARRAY
87189: PPUSH
87190: LD_VAR 0 10
87194: PPUSH
87195: CALL_OW 120
// end ; continue ;
87199: GO 86546
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
87201: LD_VAR 0 23
87205: PUSH
87206: LD_VAR 0 4
87210: PUSH
87211: LD_VAR 0 7
87215: ARRAY
87216: PPUSH
87217: CALL_OW 247
87221: PUSH
87222: LD_INT 1
87224: EQUAL
87225: AND
87226: IFFALSE 87704
// begin if group [ i ] in healers then
87228: LD_VAR 0 4
87232: PUSH
87233: LD_VAR 0 7
87237: ARRAY
87238: PUSH
87239: LD_VAR 0 31
87243: IN
87244: IFFALSE 87517
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87246: LD_VAR 0 4
87250: PUSH
87251: LD_VAR 0 7
87255: ARRAY
87256: PPUSH
87257: LD_VAR 0 23
87261: PPUSH
87262: CALL_OW 308
87266: NOT
87267: PUSH
87268: LD_VAR 0 4
87272: PUSH
87273: LD_VAR 0 7
87277: ARRAY
87278: PPUSH
87279: CALL_OW 314
87283: NOT
87284: AND
87285: IFFALSE 87309
// ComMoveToArea ( group [ i ] , f_heal ) else
87287: LD_VAR 0 4
87291: PUSH
87292: LD_VAR 0 7
87296: ARRAY
87297: PPUSH
87298: LD_VAR 0 23
87302: PPUSH
87303: CALL_OW 113
87307: GO 87515
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87309: LD_VAR 0 4
87313: PUSH
87314: LD_VAR 0 7
87318: ARRAY
87319: PPUSH
87320: CALL 85927 0 1
87324: PPUSH
87325: CALL_OW 256
87329: PUSH
87330: LD_INT 1000
87332: EQUAL
87333: IFFALSE 87352
// ComStop ( group [ i ] ) else
87335: LD_VAR 0 4
87339: PUSH
87340: LD_VAR 0 7
87344: ARRAY
87345: PPUSH
87346: CALL_OW 141
87350: GO 87515
// if not HasTask ( group [ i ] ) and to_heal then
87352: LD_VAR 0 4
87356: PUSH
87357: LD_VAR 0 7
87361: ARRAY
87362: PPUSH
87363: CALL_OW 314
87367: NOT
87368: PUSH
87369: LD_VAR 0 30
87373: AND
87374: IFFALSE 87515
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87376: LD_ADDR_VAR 0 13
87380: PUSH
87381: LD_VAR 0 30
87385: PPUSH
87386: LD_INT 3
87388: PUSH
87389: LD_INT 54
87391: PUSH
87392: EMPTY
87393: LIST
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: PPUSH
87399: CALL_OW 72
87403: PPUSH
87404: LD_VAR 0 4
87408: PUSH
87409: LD_VAR 0 7
87413: ARRAY
87414: PPUSH
87415: CALL_OW 74
87419: ST_TO_ADDR
// if z then
87420: LD_VAR 0 13
87424: IFFALSE 87515
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87426: LD_INT 91
87428: PUSH
87429: LD_VAR 0 13
87433: PUSH
87434: LD_INT 10
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: LIST
87441: PUSH
87442: LD_INT 81
87444: PUSH
87445: LD_VAR 0 13
87449: PPUSH
87450: CALL_OW 255
87454: PUSH
87455: EMPTY
87456: LIST
87457: LIST
87458: PUSH
87459: EMPTY
87460: LIST
87461: LIST
87462: PPUSH
87463: CALL_OW 69
87467: PUSH
87468: LD_INT 0
87470: EQUAL
87471: IFFALSE 87495
// ComHeal ( group [ i ] , z ) else
87473: LD_VAR 0 4
87477: PUSH
87478: LD_VAR 0 7
87482: ARRAY
87483: PPUSH
87484: LD_VAR 0 13
87488: PPUSH
87489: CALL_OW 128
87493: GO 87515
// ComMoveToArea ( group [ i ] , f_heal ) ;
87495: LD_VAR 0 4
87499: PUSH
87500: LD_VAR 0 7
87504: ARRAY
87505: PPUSH
87506: LD_VAR 0 23
87510: PPUSH
87511: CALL_OW 113
// end ; continue ;
87515: GO 86546
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87517: LD_VAR 0 4
87521: PUSH
87522: LD_VAR 0 7
87526: ARRAY
87527: PPUSH
87528: CALL_OW 256
87532: PUSH
87533: LD_INT 700
87535: LESS
87536: PUSH
87537: LD_VAR 0 4
87541: PUSH
87542: LD_VAR 0 7
87546: ARRAY
87547: PUSH
87548: LD_VAR 0 30
87552: IN
87553: NOT
87554: AND
87555: IFFALSE 87579
// to_heal := to_heal union group [ i ] ;
87557: LD_ADDR_VAR 0 30
87561: PUSH
87562: LD_VAR 0 30
87566: PUSH
87567: LD_VAR 0 4
87571: PUSH
87572: LD_VAR 0 7
87576: ARRAY
87577: UNION
87578: ST_TO_ADDR
// if group [ i ] in to_heal then
87579: LD_VAR 0 4
87583: PUSH
87584: LD_VAR 0 7
87588: ARRAY
87589: PUSH
87590: LD_VAR 0 30
87594: IN
87595: IFFALSE 87704
// begin if GetLives ( group [ i ] ) = 1000 then
87597: LD_VAR 0 4
87601: PUSH
87602: LD_VAR 0 7
87606: ARRAY
87607: PPUSH
87608: CALL_OW 256
87612: PUSH
87613: LD_INT 1000
87615: EQUAL
87616: IFFALSE 87642
// to_heal := to_heal diff group [ i ] else
87618: LD_ADDR_VAR 0 30
87622: PUSH
87623: LD_VAR 0 30
87627: PUSH
87628: LD_VAR 0 4
87632: PUSH
87633: LD_VAR 0 7
87637: ARRAY
87638: DIFF
87639: ST_TO_ADDR
87640: GO 87704
// begin if not IsInArea ( group [ i ] , to_heal ) then
87642: LD_VAR 0 4
87646: PUSH
87647: LD_VAR 0 7
87651: ARRAY
87652: PPUSH
87653: LD_VAR 0 30
87657: PPUSH
87658: CALL_OW 308
87662: NOT
87663: IFFALSE 87687
// ComMoveToArea ( group [ i ] , f_heal ) else
87665: LD_VAR 0 4
87669: PUSH
87670: LD_VAR 0 7
87674: ARRAY
87675: PPUSH
87676: LD_VAR 0 23
87680: PPUSH
87681: CALL_OW 113
87685: GO 87702
// ComHold ( group [ i ] ) ;
87687: LD_VAR 0 4
87691: PUSH
87692: LD_VAR 0 7
87696: ARRAY
87697: PPUSH
87698: CALL_OW 140
// continue ;
87702: GO 86546
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87704: LD_VAR 0 4
87708: PUSH
87709: LD_VAR 0 7
87713: ARRAY
87714: PPUSH
87715: LD_INT 10
87717: PPUSH
87718: CALL 84324 0 2
87722: NOT
87723: PUSH
87724: LD_VAR 0 16
87728: PUSH
87729: LD_VAR 0 7
87733: ARRAY
87734: PUSH
87735: EMPTY
87736: EQUAL
87737: NOT
87738: AND
87739: IFFALSE 88005
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87741: LD_VAR 0 4
87745: PUSH
87746: LD_VAR 0 7
87750: ARRAY
87751: PPUSH
87752: CALL_OW 262
87756: PUSH
87757: LD_INT 1
87759: PUSH
87760: LD_INT 2
87762: PUSH
87763: EMPTY
87764: LIST
87765: LIST
87766: IN
87767: IFFALSE 87808
// if GetFuel ( group [ i ] ) < 10 then
87769: LD_VAR 0 4
87773: PUSH
87774: LD_VAR 0 7
87778: ARRAY
87779: PPUSH
87780: CALL_OW 261
87784: PUSH
87785: LD_INT 10
87787: LESS
87788: IFFALSE 87808
// SetFuel ( group [ i ] , 12 ) ;
87790: LD_VAR 0 4
87794: PUSH
87795: LD_VAR 0 7
87799: ARRAY
87800: PPUSH
87801: LD_INT 12
87803: PPUSH
87804: CALL_OW 240
// if units_path [ i ] then
87808: LD_VAR 0 16
87812: PUSH
87813: LD_VAR 0 7
87817: ARRAY
87818: IFFALSE 88003
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
87820: LD_VAR 0 4
87824: PUSH
87825: LD_VAR 0 7
87829: ARRAY
87830: PPUSH
87831: LD_VAR 0 16
87835: PUSH
87836: LD_VAR 0 7
87840: ARRAY
87841: PUSH
87842: LD_INT 1
87844: ARRAY
87845: PUSH
87846: LD_INT 1
87848: ARRAY
87849: PPUSH
87850: LD_VAR 0 16
87854: PUSH
87855: LD_VAR 0 7
87859: ARRAY
87860: PUSH
87861: LD_INT 1
87863: ARRAY
87864: PUSH
87865: LD_INT 2
87867: ARRAY
87868: PPUSH
87869: CALL_OW 297
87873: PUSH
87874: LD_INT 6
87876: GREATER
87877: IFFALSE 87952
// begin if not HasTask ( group [ i ] ) then
87879: LD_VAR 0 4
87883: PUSH
87884: LD_VAR 0 7
87888: ARRAY
87889: PPUSH
87890: CALL_OW 314
87894: NOT
87895: IFFALSE 87950
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
87897: LD_VAR 0 4
87901: PUSH
87902: LD_VAR 0 7
87906: ARRAY
87907: PPUSH
87908: LD_VAR 0 16
87912: PUSH
87913: LD_VAR 0 7
87917: ARRAY
87918: PUSH
87919: LD_INT 1
87921: ARRAY
87922: PUSH
87923: LD_INT 1
87925: ARRAY
87926: PPUSH
87927: LD_VAR 0 16
87931: PUSH
87932: LD_VAR 0 7
87936: ARRAY
87937: PUSH
87938: LD_INT 1
87940: ARRAY
87941: PUSH
87942: LD_INT 2
87944: ARRAY
87945: PPUSH
87946: CALL_OW 114
// end else
87950: GO 88003
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
87952: LD_ADDR_VAR 0 15
87956: PUSH
87957: LD_VAR 0 16
87961: PUSH
87962: LD_VAR 0 7
87966: ARRAY
87967: PPUSH
87968: LD_INT 1
87970: PPUSH
87971: CALL_OW 3
87975: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
87976: LD_ADDR_VAR 0 16
87980: PUSH
87981: LD_VAR 0 16
87985: PPUSH
87986: LD_VAR 0 7
87990: PPUSH
87991: LD_VAR 0 15
87995: PPUSH
87996: CALL_OW 1
88000: ST_TO_ADDR
// continue ;
88001: GO 86546
// end ; end ; end else
88003: GO 90667
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
88005: LD_ADDR_VAR 0 14
88009: PUSH
88010: LD_INT 81
88012: PUSH
88013: LD_VAR 0 4
88017: PUSH
88018: LD_VAR 0 7
88022: ARRAY
88023: PPUSH
88024: CALL_OW 255
88028: PUSH
88029: EMPTY
88030: LIST
88031: LIST
88032: PPUSH
88033: CALL_OW 69
88037: ST_TO_ADDR
// if not tmp then
88038: LD_VAR 0 14
88042: NOT
88043: IFFALSE 88047
// continue ;
88045: GO 86546
// if f_ignore_area then
88047: LD_VAR 0 17
88051: IFFALSE 88139
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
88053: LD_ADDR_VAR 0 15
88057: PUSH
88058: LD_VAR 0 14
88062: PPUSH
88063: LD_INT 3
88065: PUSH
88066: LD_INT 92
88068: PUSH
88069: LD_VAR 0 17
88073: PUSH
88074: LD_INT 1
88076: ARRAY
88077: PUSH
88078: LD_VAR 0 17
88082: PUSH
88083: LD_INT 2
88085: ARRAY
88086: PUSH
88087: LD_VAR 0 17
88091: PUSH
88092: LD_INT 3
88094: ARRAY
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: PUSH
88102: EMPTY
88103: LIST
88104: LIST
88105: PPUSH
88106: CALL_OW 72
88110: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88111: LD_VAR 0 14
88115: PUSH
88116: LD_VAR 0 15
88120: DIFF
88121: IFFALSE 88139
// tmp := tmp diff tmp2 ;
88123: LD_ADDR_VAR 0 14
88127: PUSH
88128: LD_VAR 0 14
88132: PUSH
88133: LD_VAR 0 15
88137: DIFF
88138: ST_TO_ADDR
// end ; if not f_murder then
88139: LD_VAR 0 20
88143: NOT
88144: IFFALSE 88202
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
88146: LD_ADDR_VAR 0 15
88150: PUSH
88151: LD_VAR 0 14
88155: PPUSH
88156: LD_INT 3
88158: PUSH
88159: LD_INT 50
88161: PUSH
88162: EMPTY
88163: LIST
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PPUSH
88169: CALL_OW 72
88173: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88174: LD_VAR 0 14
88178: PUSH
88179: LD_VAR 0 15
88183: DIFF
88184: IFFALSE 88202
// tmp := tmp diff tmp2 ;
88186: LD_ADDR_VAR 0 14
88190: PUSH
88191: LD_VAR 0 14
88195: PUSH
88196: LD_VAR 0 15
88200: DIFF
88201: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
88202: LD_ADDR_VAR 0 14
88206: PUSH
88207: LD_VAR 0 4
88211: PUSH
88212: LD_VAR 0 7
88216: ARRAY
88217: PPUSH
88218: LD_VAR 0 14
88222: PPUSH
88223: LD_INT 1
88225: PPUSH
88226: LD_INT 1
88228: PPUSH
88229: CALL 57967 0 4
88233: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88234: LD_VAR 0 4
88238: PUSH
88239: LD_VAR 0 7
88243: ARRAY
88244: PPUSH
88245: CALL_OW 257
88249: PUSH
88250: LD_INT 1
88252: EQUAL
88253: IFFALSE 88701
// begin if WantPlant ( group [ i ] ) then
88255: LD_VAR 0 4
88259: PUSH
88260: LD_VAR 0 7
88264: ARRAY
88265: PPUSH
88266: CALL 57468 0 1
88270: IFFALSE 88274
// continue ;
88272: GO 86546
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88274: LD_VAR 0 18
88278: PUSH
88279: LD_VAR 0 4
88283: PUSH
88284: LD_VAR 0 7
88288: ARRAY
88289: PPUSH
88290: CALL_OW 310
88294: NOT
88295: AND
88296: PUSH
88297: LD_VAR 0 14
88301: PUSH
88302: LD_INT 1
88304: ARRAY
88305: PUSH
88306: LD_VAR 0 14
88310: PPUSH
88311: LD_INT 21
88313: PUSH
88314: LD_INT 2
88316: PUSH
88317: EMPTY
88318: LIST
88319: LIST
88320: PUSH
88321: LD_INT 58
88323: PUSH
88324: EMPTY
88325: LIST
88326: PUSH
88327: EMPTY
88328: LIST
88329: LIST
88330: PPUSH
88331: CALL_OW 72
88335: IN
88336: AND
88337: IFFALSE 88373
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88339: LD_VAR 0 4
88343: PUSH
88344: LD_VAR 0 7
88348: ARRAY
88349: PPUSH
88350: LD_VAR 0 14
88354: PUSH
88355: LD_INT 1
88357: ARRAY
88358: PPUSH
88359: CALL_OW 120
// attacking := true ;
88363: LD_ADDR_VAR 0 29
88367: PUSH
88368: LD_INT 1
88370: ST_TO_ADDR
// continue ;
88371: GO 86546
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88373: LD_VAR 0 26
88377: PUSH
88378: LD_VAR 0 4
88382: PUSH
88383: LD_VAR 0 7
88387: ARRAY
88388: PPUSH
88389: CALL_OW 257
88393: PUSH
88394: LD_INT 1
88396: EQUAL
88397: AND
88398: PUSH
88399: LD_VAR 0 4
88403: PUSH
88404: LD_VAR 0 7
88408: ARRAY
88409: PPUSH
88410: CALL_OW 256
88414: PUSH
88415: LD_INT 800
88417: LESS
88418: AND
88419: PUSH
88420: LD_VAR 0 4
88424: PUSH
88425: LD_VAR 0 7
88429: ARRAY
88430: PPUSH
88431: CALL_OW 318
88435: NOT
88436: AND
88437: IFFALSE 88454
// ComCrawl ( group [ i ] ) ;
88439: LD_VAR 0 4
88443: PUSH
88444: LD_VAR 0 7
88448: ARRAY
88449: PPUSH
88450: CALL_OW 137
// if f_mines then
88454: LD_VAR 0 21
88458: IFFALSE 88701
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88460: LD_VAR 0 14
88464: PUSH
88465: LD_INT 1
88467: ARRAY
88468: PPUSH
88469: CALL_OW 247
88473: PUSH
88474: LD_INT 3
88476: EQUAL
88477: PUSH
88478: LD_VAR 0 14
88482: PUSH
88483: LD_INT 1
88485: ARRAY
88486: PUSH
88487: LD_VAR 0 27
88491: IN
88492: NOT
88493: AND
88494: IFFALSE 88701
// begin x := GetX ( tmp [ 1 ] ) ;
88496: LD_ADDR_VAR 0 10
88500: PUSH
88501: LD_VAR 0 14
88505: PUSH
88506: LD_INT 1
88508: ARRAY
88509: PPUSH
88510: CALL_OW 250
88514: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88515: LD_ADDR_VAR 0 11
88519: PUSH
88520: LD_VAR 0 14
88524: PUSH
88525: LD_INT 1
88527: ARRAY
88528: PPUSH
88529: CALL_OW 251
88533: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88534: LD_ADDR_VAR 0 12
88538: PUSH
88539: LD_VAR 0 4
88543: PUSH
88544: LD_VAR 0 7
88548: ARRAY
88549: PPUSH
88550: CALL 84409 0 1
88554: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88555: LD_VAR 0 4
88559: PUSH
88560: LD_VAR 0 7
88564: ARRAY
88565: PPUSH
88566: LD_VAR 0 10
88570: PPUSH
88571: LD_VAR 0 11
88575: PPUSH
88576: LD_VAR 0 14
88580: PUSH
88581: LD_INT 1
88583: ARRAY
88584: PPUSH
88585: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88589: LD_VAR 0 4
88593: PUSH
88594: LD_VAR 0 7
88598: ARRAY
88599: PPUSH
88600: LD_VAR 0 10
88604: PPUSH
88605: LD_VAR 0 12
88609: PPUSH
88610: LD_INT 7
88612: PPUSH
88613: CALL_OW 272
88617: PPUSH
88618: LD_VAR 0 11
88622: PPUSH
88623: LD_VAR 0 12
88627: PPUSH
88628: LD_INT 7
88630: PPUSH
88631: CALL_OW 273
88635: PPUSH
88636: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88640: LD_VAR 0 4
88644: PUSH
88645: LD_VAR 0 7
88649: ARRAY
88650: PPUSH
88651: LD_INT 71
88653: PPUSH
88654: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88658: LD_ADDR_VAR 0 27
88662: PUSH
88663: LD_VAR 0 27
88667: PPUSH
88668: LD_VAR 0 27
88672: PUSH
88673: LD_INT 1
88675: PLUS
88676: PPUSH
88677: LD_VAR 0 14
88681: PUSH
88682: LD_INT 1
88684: ARRAY
88685: PPUSH
88686: CALL_OW 1
88690: ST_TO_ADDR
// attacking := true ;
88691: LD_ADDR_VAR 0 29
88695: PUSH
88696: LD_INT 1
88698: ST_TO_ADDR
// continue ;
88699: GO 86546
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88701: LD_VAR 0 4
88705: PUSH
88706: LD_VAR 0 7
88710: ARRAY
88711: PPUSH
88712: CALL_OW 257
88716: PUSH
88717: LD_INT 17
88719: EQUAL
88720: PUSH
88721: LD_VAR 0 4
88725: PUSH
88726: LD_VAR 0 7
88730: ARRAY
88731: PPUSH
88732: CALL_OW 110
88736: PUSH
88737: LD_INT 71
88739: EQUAL
88740: NOT
88741: AND
88742: IFFALSE 88888
// begin attacking := false ;
88744: LD_ADDR_VAR 0 29
88748: PUSH
88749: LD_INT 0
88751: ST_TO_ADDR
// k := 5 ;
88752: LD_ADDR_VAR 0 9
88756: PUSH
88757: LD_INT 5
88759: ST_TO_ADDR
// if tmp < k then
88760: LD_VAR 0 14
88764: PUSH
88765: LD_VAR 0 9
88769: LESS
88770: IFFALSE 88782
// k := tmp ;
88772: LD_ADDR_VAR 0 9
88776: PUSH
88777: LD_VAR 0 14
88781: ST_TO_ADDR
// for j = 1 to k do
88782: LD_ADDR_VAR 0 8
88786: PUSH
88787: DOUBLE
88788: LD_INT 1
88790: DEC
88791: ST_TO_ADDR
88792: LD_VAR 0 9
88796: PUSH
88797: FOR_TO
88798: IFFALSE 88886
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88800: LD_VAR 0 14
88804: PUSH
88805: LD_VAR 0 8
88809: ARRAY
88810: PUSH
88811: LD_VAR 0 14
88815: PPUSH
88816: LD_INT 58
88818: PUSH
88819: EMPTY
88820: LIST
88821: PPUSH
88822: CALL_OW 72
88826: IN
88827: NOT
88828: IFFALSE 88884
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88830: LD_VAR 0 4
88834: PUSH
88835: LD_VAR 0 7
88839: ARRAY
88840: PPUSH
88841: LD_VAR 0 14
88845: PUSH
88846: LD_VAR 0 8
88850: ARRAY
88851: PPUSH
88852: CALL_OW 115
// attacking := true ;
88856: LD_ADDR_VAR 0 29
88860: PUSH
88861: LD_INT 1
88863: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
88864: LD_VAR 0 4
88868: PUSH
88869: LD_VAR 0 7
88873: ARRAY
88874: PPUSH
88875: LD_INT 71
88877: PPUSH
88878: CALL_OW 109
// continue ;
88882: GO 88797
// end ; end ;
88884: GO 88797
88886: POP
88887: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
88888: LD_VAR 0 4
88892: PUSH
88893: LD_VAR 0 7
88897: ARRAY
88898: PPUSH
88899: CALL_OW 257
88903: PUSH
88904: LD_INT 8
88906: EQUAL
88907: PUSH
88908: LD_VAR 0 4
88912: PUSH
88913: LD_VAR 0 7
88917: ARRAY
88918: PPUSH
88919: CALL_OW 264
88923: PUSH
88924: LD_INT 28
88926: PUSH
88927: LD_INT 45
88929: PUSH
88930: LD_INT 7
88932: PUSH
88933: LD_INT 47
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: IN
88942: OR
88943: IFFALSE 89199
// begin attacking := false ;
88945: LD_ADDR_VAR 0 29
88949: PUSH
88950: LD_INT 0
88952: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
88953: LD_VAR 0 14
88957: PUSH
88958: LD_INT 1
88960: ARRAY
88961: PPUSH
88962: CALL_OW 266
88966: PUSH
88967: LD_INT 32
88969: PUSH
88970: LD_INT 31
88972: PUSH
88973: LD_INT 33
88975: PUSH
88976: LD_INT 4
88978: PUSH
88979: LD_INT 5
88981: PUSH
88982: EMPTY
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: IN
88989: IFFALSE 89175
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
88991: LD_ADDR_VAR 0 9
88995: PUSH
88996: LD_VAR 0 14
89000: PUSH
89001: LD_INT 1
89003: ARRAY
89004: PPUSH
89005: CALL_OW 266
89009: PPUSH
89010: LD_VAR 0 14
89014: PUSH
89015: LD_INT 1
89017: ARRAY
89018: PPUSH
89019: CALL_OW 250
89023: PPUSH
89024: LD_VAR 0 14
89028: PUSH
89029: LD_INT 1
89031: ARRAY
89032: PPUSH
89033: CALL_OW 251
89037: PPUSH
89038: LD_VAR 0 14
89042: PUSH
89043: LD_INT 1
89045: ARRAY
89046: PPUSH
89047: CALL_OW 254
89051: PPUSH
89052: LD_VAR 0 14
89056: PUSH
89057: LD_INT 1
89059: ARRAY
89060: PPUSH
89061: CALL_OW 248
89065: PPUSH
89066: LD_INT 0
89068: PPUSH
89069: CALL 65779 0 6
89073: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
89074: LD_ADDR_VAR 0 8
89078: PUSH
89079: LD_VAR 0 4
89083: PUSH
89084: LD_VAR 0 7
89088: ARRAY
89089: PPUSH
89090: LD_VAR 0 9
89094: PPUSH
89095: CALL 84472 0 2
89099: ST_TO_ADDR
// if j then
89100: LD_VAR 0 8
89104: IFFALSE 89173
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
89106: LD_VAR 0 8
89110: PUSH
89111: LD_INT 1
89113: ARRAY
89114: PPUSH
89115: LD_VAR 0 8
89119: PUSH
89120: LD_INT 2
89122: ARRAY
89123: PPUSH
89124: CALL_OW 488
89128: IFFALSE 89173
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
89130: LD_VAR 0 4
89134: PUSH
89135: LD_VAR 0 7
89139: ARRAY
89140: PPUSH
89141: LD_VAR 0 8
89145: PUSH
89146: LD_INT 1
89148: ARRAY
89149: PPUSH
89150: LD_VAR 0 8
89154: PUSH
89155: LD_INT 2
89157: ARRAY
89158: PPUSH
89159: CALL_OW 116
// attacking := true ;
89163: LD_ADDR_VAR 0 29
89167: PUSH
89168: LD_INT 1
89170: ST_TO_ADDR
// continue ;
89171: GO 86546
// end ; end else
89173: GO 89199
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89175: LD_VAR 0 4
89179: PUSH
89180: LD_VAR 0 7
89184: ARRAY
89185: PPUSH
89186: LD_VAR 0 14
89190: PUSH
89191: LD_INT 1
89193: ARRAY
89194: PPUSH
89195: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
89199: LD_VAR 0 4
89203: PUSH
89204: LD_VAR 0 7
89208: ARRAY
89209: PPUSH
89210: CALL_OW 265
89214: PUSH
89215: LD_INT 11
89217: EQUAL
89218: IFFALSE 89496
// begin k := 10 ;
89220: LD_ADDR_VAR 0 9
89224: PUSH
89225: LD_INT 10
89227: ST_TO_ADDR
// x := 0 ;
89228: LD_ADDR_VAR 0 10
89232: PUSH
89233: LD_INT 0
89235: ST_TO_ADDR
// if tmp < k then
89236: LD_VAR 0 14
89240: PUSH
89241: LD_VAR 0 9
89245: LESS
89246: IFFALSE 89258
// k := tmp ;
89248: LD_ADDR_VAR 0 9
89252: PUSH
89253: LD_VAR 0 14
89257: ST_TO_ADDR
// for j = k downto 1 do
89258: LD_ADDR_VAR 0 8
89262: PUSH
89263: DOUBLE
89264: LD_VAR 0 9
89268: INC
89269: ST_TO_ADDR
89270: LD_INT 1
89272: PUSH
89273: FOR_DOWNTO
89274: IFFALSE 89349
// begin if GetType ( tmp [ j ] ) = unit_human then
89276: LD_VAR 0 14
89280: PUSH
89281: LD_VAR 0 8
89285: ARRAY
89286: PPUSH
89287: CALL_OW 247
89291: PUSH
89292: LD_INT 1
89294: EQUAL
89295: IFFALSE 89347
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89297: LD_VAR 0 4
89301: PUSH
89302: LD_VAR 0 7
89306: ARRAY
89307: PPUSH
89308: LD_VAR 0 14
89312: PUSH
89313: LD_VAR 0 8
89317: ARRAY
89318: PPUSH
89319: CALL 84743 0 2
// x := tmp [ j ] ;
89323: LD_ADDR_VAR 0 10
89327: PUSH
89328: LD_VAR 0 14
89332: PUSH
89333: LD_VAR 0 8
89337: ARRAY
89338: ST_TO_ADDR
// attacking := true ;
89339: LD_ADDR_VAR 0 29
89343: PUSH
89344: LD_INT 1
89346: ST_TO_ADDR
// end ; end ;
89347: GO 89273
89349: POP
89350: POP
// if not x then
89351: LD_VAR 0 10
89355: NOT
89356: IFFALSE 89496
// begin attacking := true ;
89358: LD_ADDR_VAR 0 29
89362: PUSH
89363: LD_INT 1
89365: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89366: LD_VAR 0 4
89370: PUSH
89371: LD_VAR 0 7
89375: ARRAY
89376: PPUSH
89377: CALL_OW 250
89381: PPUSH
89382: LD_VAR 0 4
89386: PUSH
89387: LD_VAR 0 7
89391: ARRAY
89392: PPUSH
89393: CALL_OW 251
89397: PPUSH
89398: CALL_OW 546
89402: PUSH
89403: LD_INT 2
89405: ARRAY
89406: PUSH
89407: LD_VAR 0 14
89411: PUSH
89412: LD_INT 1
89414: ARRAY
89415: PPUSH
89416: CALL_OW 250
89420: PPUSH
89421: LD_VAR 0 14
89425: PUSH
89426: LD_INT 1
89428: ARRAY
89429: PPUSH
89430: CALL_OW 251
89434: PPUSH
89435: CALL_OW 546
89439: PUSH
89440: LD_INT 2
89442: ARRAY
89443: EQUAL
89444: IFFALSE 89472
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89446: LD_VAR 0 4
89450: PUSH
89451: LD_VAR 0 7
89455: ARRAY
89456: PPUSH
89457: LD_VAR 0 14
89461: PUSH
89462: LD_INT 1
89464: ARRAY
89465: PPUSH
89466: CALL 84743 0 2
89470: GO 89496
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89472: LD_VAR 0 4
89476: PUSH
89477: LD_VAR 0 7
89481: ARRAY
89482: PPUSH
89483: LD_VAR 0 14
89487: PUSH
89488: LD_INT 1
89490: ARRAY
89491: PPUSH
89492: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89496: LD_VAR 0 4
89500: PUSH
89501: LD_VAR 0 7
89505: ARRAY
89506: PPUSH
89507: CALL_OW 264
89511: PUSH
89512: LD_INT 29
89514: EQUAL
89515: IFFALSE 89881
// begin if WantsToAttack ( group [ i ] ) in bombed then
89517: LD_VAR 0 4
89521: PUSH
89522: LD_VAR 0 7
89526: ARRAY
89527: PPUSH
89528: CALL_OW 319
89532: PUSH
89533: LD_VAR 0 28
89537: IN
89538: IFFALSE 89542
// continue ;
89540: GO 86546
// k := 8 ;
89542: LD_ADDR_VAR 0 9
89546: PUSH
89547: LD_INT 8
89549: ST_TO_ADDR
// x := 0 ;
89550: LD_ADDR_VAR 0 10
89554: PUSH
89555: LD_INT 0
89557: ST_TO_ADDR
// if tmp < k then
89558: LD_VAR 0 14
89562: PUSH
89563: LD_VAR 0 9
89567: LESS
89568: IFFALSE 89580
// k := tmp ;
89570: LD_ADDR_VAR 0 9
89574: PUSH
89575: LD_VAR 0 14
89579: ST_TO_ADDR
// for j = 1 to k do
89580: LD_ADDR_VAR 0 8
89584: PUSH
89585: DOUBLE
89586: LD_INT 1
89588: DEC
89589: ST_TO_ADDR
89590: LD_VAR 0 9
89594: PUSH
89595: FOR_TO
89596: IFFALSE 89728
// begin if GetType ( tmp [ j ] ) = unit_building then
89598: LD_VAR 0 14
89602: PUSH
89603: LD_VAR 0 8
89607: ARRAY
89608: PPUSH
89609: CALL_OW 247
89613: PUSH
89614: LD_INT 3
89616: EQUAL
89617: IFFALSE 89726
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89619: LD_VAR 0 14
89623: PUSH
89624: LD_VAR 0 8
89628: ARRAY
89629: PUSH
89630: LD_VAR 0 28
89634: IN
89635: NOT
89636: PUSH
89637: LD_VAR 0 14
89641: PUSH
89642: LD_VAR 0 8
89646: ARRAY
89647: PPUSH
89648: CALL_OW 313
89652: AND
89653: IFFALSE 89726
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89655: LD_VAR 0 4
89659: PUSH
89660: LD_VAR 0 7
89664: ARRAY
89665: PPUSH
89666: LD_VAR 0 14
89670: PUSH
89671: LD_VAR 0 8
89675: ARRAY
89676: PPUSH
89677: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89681: LD_ADDR_VAR 0 28
89685: PUSH
89686: LD_VAR 0 28
89690: PPUSH
89691: LD_VAR 0 28
89695: PUSH
89696: LD_INT 1
89698: PLUS
89699: PPUSH
89700: LD_VAR 0 14
89704: PUSH
89705: LD_VAR 0 8
89709: ARRAY
89710: PPUSH
89711: CALL_OW 1
89715: ST_TO_ADDR
// attacking := true ;
89716: LD_ADDR_VAR 0 29
89720: PUSH
89721: LD_INT 1
89723: ST_TO_ADDR
// break ;
89724: GO 89728
// end ; end ;
89726: GO 89595
89728: POP
89729: POP
// if not attacking and f_attack_depot then
89730: LD_VAR 0 29
89734: NOT
89735: PUSH
89736: LD_VAR 0 25
89740: AND
89741: IFFALSE 89836
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89743: LD_ADDR_VAR 0 13
89747: PUSH
89748: LD_VAR 0 14
89752: PPUSH
89753: LD_INT 2
89755: PUSH
89756: LD_INT 30
89758: PUSH
89759: LD_INT 0
89761: PUSH
89762: EMPTY
89763: LIST
89764: LIST
89765: PUSH
89766: LD_INT 30
89768: PUSH
89769: LD_INT 1
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: LIST
89780: PPUSH
89781: CALL_OW 72
89785: ST_TO_ADDR
// if z then
89786: LD_VAR 0 13
89790: IFFALSE 89836
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89792: LD_VAR 0 4
89796: PUSH
89797: LD_VAR 0 7
89801: ARRAY
89802: PPUSH
89803: LD_VAR 0 13
89807: PPUSH
89808: LD_VAR 0 4
89812: PUSH
89813: LD_VAR 0 7
89817: ARRAY
89818: PPUSH
89819: CALL_OW 74
89823: PPUSH
89824: CALL_OW 115
// attacking := true ;
89828: LD_ADDR_VAR 0 29
89832: PUSH
89833: LD_INT 1
89835: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
89836: LD_VAR 0 4
89840: PUSH
89841: LD_VAR 0 7
89845: ARRAY
89846: PPUSH
89847: CALL_OW 256
89851: PUSH
89852: LD_INT 500
89854: LESS
89855: IFFALSE 89881
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89857: LD_VAR 0 4
89861: PUSH
89862: LD_VAR 0 7
89866: ARRAY
89867: PPUSH
89868: LD_VAR 0 14
89872: PUSH
89873: LD_INT 1
89875: ARRAY
89876: PPUSH
89877: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
89881: LD_VAR 0 4
89885: PUSH
89886: LD_VAR 0 7
89890: ARRAY
89891: PPUSH
89892: CALL_OW 264
89896: PUSH
89897: LD_INT 49
89899: EQUAL
89900: IFFALSE 90021
// begin if not HasTask ( group [ i ] ) then
89902: LD_VAR 0 4
89906: PUSH
89907: LD_VAR 0 7
89911: ARRAY
89912: PPUSH
89913: CALL_OW 314
89917: NOT
89918: IFFALSE 90021
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
89920: LD_ADDR_VAR 0 9
89924: PUSH
89925: LD_INT 81
89927: PUSH
89928: LD_VAR 0 4
89932: PUSH
89933: LD_VAR 0 7
89937: ARRAY
89938: PPUSH
89939: CALL_OW 255
89943: PUSH
89944: EMPTY
89945: LIST
89946: LIST
89947: PPUSH
89948: CALL_OW 69
89952: PPUSH
89953: LD_VAR 0 4
89957: PUSH
89958: LD_VAR 0 7
89962: ARRAY
89963: PPUSH
89964: CALL_OW 74
89968: ST_TO_ADDR
// if k then
89969: LD_VAR 0 9
89973: IFFALSE 90021
// if GetDistUnits ( group [ i ] , k ) > 10 then
89975: LD_VAR 0 4
89979: PUSH
89980: LD_VAR 0 7
89984: ARRAY
89985: PPUSH
89986: LD_VAR 0 9
89990: PPUSH
89991: CALL_OW 296
89995: PUSH
89996: LD_INT 10
89998: GREATER
89999: IFFALSE 90021
// ComMoveUnit ( group [ i ] , k ) ;
90001: LD_VAR 0 4
90005: PUSH
90006: LD_VAR 0 7
90010: ARRAY
90011: PPUSH
90012: LD_VAR 0 9
90016: PPUSH
90017: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
90021: LD_VAR 0 4
90025: PUSH
90026: LD_VAR 0 7
90030: ARRAY
90031: PPUSH
90032: CALL_OW 256
90036: PUSH
90037: LD_INT 250
90039: LESS
90040: PUSH
90041: LD_VAR 0 4
90045: PUSH
90046: LD_VAR 0 7
90050: ARRAY
90051: PUSH
90052: LD_INT 21
90054: PUSH
90055: LD_INT 2
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 23
90064: PUSH
90065: LD_INT 2
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: EMPTY
90073: LIST
90074: LIST
90075: PPUSH
90076: CALL_OW 69
90080: IN
90081: AND
90082: IFFALSE 90207
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
90084: LD_ADDR_VAR 0 9
90088: PUSH
90089: LD_OWVAR 3
90093: PUSH
90094: LD_VAR 0 4
90098: PUSH
90099: LD_VAR 0 7
90103: ARRAY
90104: DIFF
90105: PPUSH
90106: LD_VAR 0 4
90110: PUSH
90111: LD_VAR 0 7
90115: ARRAY
90116: PPUSH
90117: CALL_OW 74
90121: ST_TO_ADDR
// if not k then
90122: LD_VAR 0 9
90126: NOT
90127: IFFALSE 90131
// continue ;
90129: GO 86546
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
90131: LD_VAR 0 9
90135: PUSH
90136: LD_INT 81
90138: PUSH
90139: LD_VAR 0 4
90143: PUSH
90144: LD_VAR 0 7
90148: ARRAY
90149: PPUSH
90150: CALL_OW 255
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: PPUSH
90159: CALL_OW 69
90163: IN
90164: PUSH
90165: LD_VAR 0 9
90169: PPUSH
90170: LD_VAR 0 4
90174: PUSH
90175: LD_VAR 0 7
90179: ARRAY
90180: PPUSH
90181: CALL_OW 296
90185: PUSH
90186: LD_INT 5
90188: LESS
90189: AND
90190: IFFALSE 90207
// ComAutodestruct ( group [ i ] ) ;
90192: LD_VAR 0 4
90196: PUSH
90197: LD_VAR 0 7
90201: ARRAY
90202: PPUSH
90203: CALL 84641 0 1
// end ; if f_attack_depot then
90207: LD_VAR 0 25
90211: IFFALSE 90323
// begin k := 6 ;
90213: LD_ADDR_VAR 0 9
90217: PUSH
90218: LD_INT 6
90220: ST_TO_ADDR
// if tmp < k then
90221: LD_VAR 0 14
90225: PUSH
90226: LD_VAR 0 9
90230: LESS
90231: IFFALSE 90243
// k := tmp ;
90233: LD_ADDR_VAR 0 9
90237: PUSH
90238: LD_VAR 0 14
90242: ST_TO_ADDR
// for j = 1 to k do
90243: LD_ADDR_VAR 0 8
90247: PUSH
90248: DOUBLE
90249: LD_INT 1
90251: DEC
90252: ST_TO_ADDR
90253: LD_VAR 0 9
90257: PUSH
90258: FOR_TO
90259: IFFALSE 90321
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90261: LD_VAR 0 8
90265: PPUSH
90266: CALL_OW 266
90270: PUSH
90271: LD_INT 0
90273: PUSH
90274: LD_INT 1
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: IN
90281: IFFALSE 90319
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90283: LD_VAR 0 4
90287: PUSH
90288: LD_VAR 0 7
90292: ARRAY
90293: PPUSH
90294: LD_VAR 0 14
90298: PUSH
90299: LD_VAR 0 8
90303: ARRAY
90304: PPUSH
90305: CALL_OW 115
// attacking := true ;
90309: LD_ADDR_VAR 0 29
90313: PUSH
90314: LD_INT 1
90316: ST_TO_ADDR
// break ;
90317: GO 90321
// end ;
90319: GO 90258
90321: POP
90322: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90323: LD_VAR 0 4
90327: PUSH
90328: LD_VAR 0 7
90332: ARRAY
90333: PPUSH
90334: CALL_OW 302
90338: PUSH
90339: LD_VAR 0 29
90343: NOT
90344: AND
90345: IFFALSE 90667
// begin if GetTag ( group [ i ] ) = 71 then
90347: LD_VAR 0 4
90351: PUSH
90352: LD_VAR 0 7
90356: ARRAY
90357: PPUSH
90358: CALL_OW 110
90362: PUSH
90363: LD_INT 71
90365: EQUAL
90366: IFFALSE 90407
// begin if HasTask ( group [ i ] ) then
90368: LD_VAR 0 4
90372: PUSH
90373: LD_VAR 0 7
90377: ARRAY
90378: PPUSH
90379: CALL_OW 314
90383: IFFALSE 90389
// continue else
90385: GO 86546
90387: GO 90407
// SetTag ( group [ i ] , 0 ) ;
90389: LD_VAR 0 4
90393: PUSH
90394: LD_VAR 0 7
90398: ARRAY
90399: PPUSH
90400: LD_INT 0
90402: PPUSH
90403: CALL_OW 109
// end ; k := 8 ;
90407: LD_ADDR_VAR 0 9
90411: PUSH
90412: LD_INT 8
90414: ST_TO_ADDR
// x := 0 ;
90415: LD_ADDR_VAR 0 10
90419: PUSH
90420: LD_INT 0
90422: ST_TO_ADDR
// if tmp < k then
90423: LD_VAR 0 14
90427: PUSH
90428: LD_VAR 0 9
90432: LESS
90433: IFFALSE 90445
// k := tmp ;
90435: LD_ADDR_VAR 0 9
90439: PUSH
90440: LD_VAR 0 14
90444: ST_TO_ADDR
// for j = 1 to k do
90445: LD_ADDR_VAR 0 8
90449: PUSH
90450: DOUBLE
90451: LD_INT 1
90453: DEC
90454: ST_TO_ADDR
90455: LD_VAR 0 9
90459: PUSH
90460: FOR_TO
90461: IFFALSE 90559
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90463: LD_VAR 0 14
90467: PUSH
90468: LD_VAR 0 8
90472: ARRAY
90473: PPUSH
90474: CALL_OW 247
90478: PUSH
90479: LD_INT 1
90481: EQUAL
90482: PUSH
90483: LD_VAR 0 14
90487: PUSH
90488: LD_VAR 0 8
90492: ARRAY
90493: PPUSH
90494: CALL_OW 256
90498: PUSH
90499: LD_INT 250
90501: LESS
90502: PUSH
90503: LD_VAR 0 20
90507: AND
90508: PUSH
90509: LD_VAR 0 20
90513: NOT
90514: PUSH
90515: LD_VAR 0 14
90519: PUSH
90520: LD_VAR 0 8
90524: ARRAY
90525: PPUSH
90526: CALL_OW 256
90530: PUSH
90531: LD_INT 250
90533: GREATEREQUAL
90534: AND
90535: OR
90536: AND
90537: IFFALSE 90557
// begin x := tmp [ j ] ;
90539: LD_ADDR_VAR 0 10
90543: PUSH
90544: LD_VAR 0 14
90548: PUSH
90549: LD_VAR 0 8
90553: ARRAY
90554: ST_TO_ADDR
// break ;
90555: GO 90559
// end ;
90557: GO 90460
90559: POP
90560: POP
// if x then
90561: LD_VAR 0 10
90565: IFFALSE 90589
// ComAttackUnit ( group [ i ] , x ) else
90567: LD_VAR 0 4
90571: PUSH
90572: LD_VAR 0 7
90576: ARRAY
90577: PPUSH
90578: LD_VAR 0 10
90582: PPUSH
90583: CALL_OW 115
90587: GO 90613
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90589: LD_VAR 0 4
90593: PUSH
90594: LD_VAR 0 7
90598: ARRAY
90599: PPUSH
90600: LD_VAR 0 14
90604: PUSH
90605: LD_INT 1
90607: ARRAY
90608: PPUSH
90609: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90613: LD_VAR 0 4
90617: PUSH
90618: LD_VAR 0 7
90622: ARRAY
90623: PPUSH
90624: CALL_OW 314
90628: NOT
90629: IFFALSE 90667
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90631: LD_VAR 0 4
90635: PUSH
90636: LD_VAR 0 7
90640: ARRAY
90641: PPUSH
90642: LD_VAR 0 14
90646: PPUSH
90647: LD_VAR 0 4
90651: PUSH
90652: LD_VAR 0 7
90656: ARRAY
90657: PPUSH
90658: CALL_OW 74
90662: PPUSH
90663: CALL_OW 115
// end ; end ; end ;
90667: GO 86546
90669: POP
90670: POP
// wait ( 0 0$1 ) ;
90671: LD_INT 35
90673: PPUSH
90674: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90678: LD_VAR 0 4
90682: PUSH
90683: EMPTY
90684: EQUAL
90685: PUSH
90686: LD_INT 81
90688: PUSH
90689: LD_VAR 0 35
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PPUSH
90698: CALL_OW 69
90702: NOT
90703: OR
90704: IFFALSE 86531
// end ;
90706: LD_VAR 0 2
90710: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90711: LD_INT 0
90713: PPUSH
90714: PPUSH
90715: PPUSH
90716: PPUSH
// if not base_units then
90717: LD_VAR 0 1
90721: NOT
90722: IFFALSE 90726
// exit ;
90724: GO 90813
// result := false ;
90726: LD_ADDR_VAR 0 2
90730: PUSH
90731: LD_INT 0
90733: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90734: LD_ADDR_VAR 0 5
90738: PUSH
90739: LD_VAR 0 1
90743: PPUSH
90744: LD_INT 21
90746: PUSH
90747: LD_INT 3
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PPUSH
90754: CALL_OW 72
90758: ST_TO_ADDR
// if not tmp then
90759: LD_VAR 0 5
90763: NOT
90764: IFFALSE 90768
// exit ;
90766: GO 90813
// for i in tmp do
90768: LD_ADDR_VAR 0 3
90772: PUSH
90773: LD_VAR 0 5
90777: PUSH
90778: FOR_IN
90779: IFFALSE 90811
// begin result := EnemyInRange ( i , 22 ) ;
90781: LD_ADDR_VAR 0 2
90785: PUSH
90786: LD_VAR 0 3
90790: PPUSH
90791: LD_INT 22
90793: PPUSH
90794: CALL 84324 0 2
90798: ST_TO_ADDR
// if result then
90799: LD_VAR 0 2
90803: IFFALSE 90809
// exit ;
90805: POP
90806: POP
90807: GO 90813
// end ;
90809: GO 90778
90811: POP
90812: POP
// end ;
90813: LD_VAR 0 2
90817: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
90818: LD_INT 0
90820: PPUSH
90821: PPUSH
// if not units then
90822: LD_VAR 0 1
90826: NOT
90827: IFFALSE 90831
// exit ;
90829: GO 90901
// result := [ ] ;
90831: LD_ADDR_VAR 0 3
90835: PUSH
90836: EMPTY
90837: ST_TO_ADDR
// for i in units do
90838: LD_ADDR_VAR 0 4
90842: PUSH
90843: LD_VAR 0 1
90847: PUSH
90848: FOR_IN
90849: IFFALSE 90899
// if GetTag ( i ) = tag then
90851: LD_VAR 0 4
90855: PPUSH
90856: CALL_OW 110
90860: PUSH
90861: LD_VAR 0 2
90865: EQUAL
90866: IFFALSE 90897
// result := Insert ( result , result + 1 , i ) ;
90868: LD_ADDR_VAR 0 3
90872: PUSH
90873: LD_VAR 0 3
90877: PPUSH
90878: LD_VAR 0 3
90882: PUSH
90883: LD_INT 1
90885: PLUS
90886: PPUSH
90887: LD_VAR 0 4
90891: PPUSH
90892: CALL_OW 2
90896: ST_TO_ADDR
90897: GO 90848
90899: POP
90900: POP
// end ;
90901: LD_VAR 0 3
90905: RET
// export function IsDriver ( un ) ; begin
90906: LD_INT 0
90908: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
90909: LD_ADDR_VAR 0 2
90913: PUSH
90914: LD_VAR 0 1
90918: PUSH
90919: LD_INT 55
90921: PUSH
90922: EMPTY
90923: LIST
90924: PPUSH
90925: CALL_OW 69
90929: IN
90930: ST_TO_ADDR
// end ;
90931: LD_VAR 0 2
90935: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
90936: LD_INT 0
90938: PPUSH
90939: PPUSH
// list := [ ] ;
90940: LD_ADDR_VAR 0 5
90944: PUSH
90945: EMPTY
90946: ST_TO_ADDR
// case d of 0 :
90947: LD_VAR 0 3
90951: PUSH
90952: LD_INT 0
90954: DOUBLE
90955: EQUAL
90956: IFTRUE 90960
90958: GO 91093
90960: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
90961: LD_ADDR_VAR 0 5
90965: PUSH
90966: LD_VAR 0 1
90970: PUSH
90971: LD_INT 4
90973: MINUS
90974: PUSH
90975: LD_VAR 0 2
90979: PUSH
90980: LD_INT 4
90982: MINUS
90983: PUSH
90984: LD_INT 2
90986: PUSH
90987: EMPTY
90988: LIST
90989: LIST
90990: LIST
90991: PUSH
90992: LD_VAR 0 1
90996: PUSH
90997: LD_INT 3
90999: MINUS
91000: PUSH
91001: LD_VAR 0 2
91005: PUSH
91006: LD_INT 1
91008: PUSH
91009: EMPTY
91010: LIST
91011: LIST
91012: LIST
91013: PUSH
91014: LD_VAR 0 1
91018: PUSH
91019: LD_INT 4
91021: PLUS
91022: PUSH
91023: LD_VAR 0 2
91027: PUSH
91028: LD_INT 4
91030: PUSH
91031: EMPTY
91032: LIST
91033: LIST
91034: LIST
91035: PUSH
91036: LD_VAR 0 1
91040: PUSH
91041: LD_INT 3
91043: PLUS
91044: PUSH
91045: LD_VAR 0 2
91049: PUSH
91050: LD_INT 3
91052: PLUS
91053: PUSH
91054: LD_INT 5
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: LIST
91061: PUSH
91062: LD_VAR 0 1
91066: PUSH
91067: LD_VAR 0 2
91071: PUSH
91072: LD_INT 4
91074: PLUS
91075: PUSH
91076: LD_INT 0
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: LIST
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: ST_TO_ADDR
// end ; 1 :
91091: GO 91791
91093: LD_INT 1
91095: DOUBLE
91096: EQUAL
91097: IFTRUE 91101
91099: GO 91234
91101: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
91102: LD_ADDR_VAR 0 5
91106: PUSH
91107: LD_VAR 0 1
91111: PUSH
91112: LD_VAR 0 2
91116: PUSH
91117: LD_INT 4
91119: MINUS
91120: PUSH
91121: LD_INT 3
91123: PUSH
91124: EMPTY
91125: LIST
91126: LIST
91127: LIST
91128: PUSH
91129: LD_VAR 0 1
91133: PUSH
91134: LD_INT 3
91136: MINUS
91137: PUSH
91138: LD_VAR 0 2
91142: PUSH
91143: LD_INT 3
91145: MINUS
91146: PUSH
91147: LD_INT 2
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: LIST
91154: PUSH
91155: LD_VAR 0 1
91159: PUSH
91160: LD_INT 4
91162: MINUS
91163: PUSH
91164: LD_VAR 0 2
91168: PUSH
91169: LD_INT 1
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: LIST
91176: PUSH
91177: LD_VAR 0 1
91181: PUSH
91182: LD_VAR 0 2
91186: PUSH
91187: LD_INT 3
91189: PLUS
91190: PUSH
91191: LD_INT 0
91193: PUSH
91194: EMPTY
91195: LIST
91196: LIST
91197: LIST
91198: PUSH
91199: LD_VAR 0 1
91203: PUSH
91204: LD_INT 4
91206: PLUS
91207: PUSH
91208: LD_VAR 0 2
91212: PUSH
91213: LD_INT 4
91215: PLUS
91216: PUSH
91217: LD_INT 5
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: LIST
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: ST_TO_ADDR
// end ; 2 :
91232: GO 91791
91234: LD_INT 2
91236: DOUBLE
91237: EQUAL
91238: IFTRUE 91242
91240: GO 91371
91242: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91243: LD_ADDR_VAR 0 5
91247: PUSH
91248: LD_VAR 0 1
91252: PUSH
91253: LD_VAR 0 2
91257: PUSH
91258: LD_INT 3
91260: MINUS
91261: PUSH
91262: LD_INT 3
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: LIST
91269: PUSH
91270: LD_VAR 0 1
91274: PUSH
91275: LD_INT 4
91277: PLUS
91278: PUSH
91279: LD_VAR 0 2
91283: PUSH
91284: LD_INT 4
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: LIST
91291: PUSH
91292: LD_VAR 0 1
91296: PUSH
91297: LD_VAR 0 2
91301: PUSH
91302: LD_INT 4
91304: PLUS
91305: PUSH
91306: LD_INT 0
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: LIST
91313: PUSH
91314: LD_VAR 0 1
91318: PUSH
91319: LD_INT 3
91321: MINUS
91322: PUSH
91323: LD_VAR 0 2
91327: PUSH
91328: LD_INT 1
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: LIST
91335: PUSH
91336: LD_VAR 0 1
91340: PUSH
91341: LD_INT 4
91343: MINUS
91344: PUSH
91345: LD_VAR 0 2
91349: PUSH
91350: LD_INT 4
91352: MINUS
91353: PUSH
91354: LD_INT 2
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: LIST
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: LIST
91366: LIST
91367: LIST
91368: ST_TO_ADDR
// end ; 3 :
91369: GO 91791
91371: LD_INT 3
91373: DOUBLE
91374: EQUAL
91375: IFTRUE 91379
91377: GO 91512
91379: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
91380: LD_ADDR_VAR 0 5
91384: PUSH
91385: LD_VAR 0 1
91389: PUSH
91390: LD_INT 3
91392: PLUS
91393: PUSH
91394: LD_VAR 0 2
91398: PUSH
91399: LD_INT 4
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: LIST
91406: PUSH
91407: LD_VAR 0 1
91411: PUSH
91412: LD_INT 4
91414: PLUS
91415: PUSH
91416: LD_VAR 0 2
91420: PUSH
91421: LD_INT 4
91423: PLUS
91424: PUSH
91425: LD_INT 5
91427: PUSH
91428: EMPTY
91429: LIST
91430: LIST
91431: LIST
91432: PUSH
91433: LD_VAR 0 1
91437: PUSH
91438: LD_INT 4
91440: MINUS
91441: PUSH
91442: LD_VAR 0 2
91446: PUSH
91447: LD_INT 1
91449: PUSH
91450: EMPTY
91451: LIST
91452: LIST
91453: LIST
91454: PUSH
91455: LD_VAR 0 1
91459: PUSH
91460: LD_VAR 0 2
91464: PUSH
91465: LD_INT 4
91467: MINUS
91468: PUSH
91469: LD_INT 3
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: LIST
91476: PUSH
91477: LD_VAR 0 1
91481: PUSH
91482: LD_INT 3
91484: MINUS
91485: PUSH
91486: LD_VAR 0 2
91490: PUSH
91491: LD_INT 3
91493: MINUS
91494: PUSH
91495: LD_INT 2
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: LIST
91502: PUSH
91503: EMPTY
91504: LIST
91505: LIST
91506: LIST
91507: LIST
91508: LIST
91509: ST_TO_ADDR
// end ; 4 :
91510: GO 91791
91512: LD_INT 4
91514: DOUBLE
91515: EQUAL
91516: IFTRUE 91520
91518: GO 91653
91520: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
91521: LD_ADDR_VAR 0 5
91525: PUSH
91526: LD_VAR 0 1
91530: PUSH
91531: LD_VAR 0 2
91535: PUSH
91536: LD_INT 4
91538: PLUS
91539: PUSH
91540: LD_INT 0
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: LIST
91547: PUSH
91548: LD_VAR 0 1
91552: PUSH
91553: LD_INT 3
91555: PLUS
91556: PUSH
91557: LD_VAR 0 2
91561: PUSH
91562: LD_INT 3
91564: PLUS
91565: PUSH
91566: LD_INT 5
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: LIST
91573: PUSH
91574: LD_VAR 0 1
91578: PUSH
91579: LD_INT 4
91581: PLUS
91582: PUSH
91583: LD_VAR 0 2
91587: PUSH
91588: LD_INT 4
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: LIST
91595: PUSH
91596: LD_VAR 0 1
91600: PUSH
91601: LD_VAR 0 2
91605: PUSH
91606: LD_INT 3
91608: MINUS
91609: PUSH
91610: LD_INT 3
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: LIST
91617: PUSH
91618: LD_VAR 0 1
91622: PUSH
91623: LD_INT 4
91625: MINUS
91626: PUSH
91627: LD_VAR 0 2
91631: PUSH
91632: LD_INT 4
91634: MINUS
91635: PUSH
91636: LD_INT 2
91638: PUSH
91639: EMPTY
91640: LIST
91641: LIST
91642: LIST
91643: PUSH
91644: EMPTY
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: ST_TO_ADDR
// end ; 5 :
91651: GO 91791
91653: LD_INT 5
91655: DOUBLE
91656: EQUAL
91657: IFTRUE 91661
91659: GO 91790
91661: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91662: LD_ADDR_VAR 0 5
91666: PUSH
91667: LD_VAR 0 1
91671: PUSH
91672: LD_INT 4
91674: MINUS
91675: PUSH
91676: LD_VAR 0 2
91680: PUSH
91681: LD_INT 1
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: LIST
91688: PUSH
91689: LD_VAR 0 1
91693: PUSH
91694: LD_VAR 0 2
91698: PUSH
91699: LD_INT 4
91701: MINUS
91702: PUSH
91703: LD_INT 3
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: LIST
91710: PUSH
91711: LD_VAR 0 1
91715: PUSH
91716: LD_INT 4
91718: PLUS
91719: PUSH
91720: LD_VAR 0 2
91724: PUSH
91725: LD_INT 4
91727: PLUS
91728: PUSH
91729: LD_INT 5
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: LIST
91736: PUSH
91737: LD_VAR 0 1
91741: PUSH
91742: LD_INT 3
91744: PLUS
91745: PUSH
91746: LD_VAR 0 2
91750: PUSH
91751: LD_INT 4
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: LIST
91758: PUSH
91759: LD_VAR 0 1
91763: PUSH
91764: LD_VAR 0 2
91768: PUSH
91769: LD_INT 3
91771: PLUS
91772: PUSH
91773: LD_INT 0
91775: PUSH
91776: EMPTY
91777: LIST
91778: LIST
91779: LIST
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: ST_TO_ADDR
// end ; end ;
91788: GO 91791
91790: POP
// result := list ;
91791: LD_ADDR_VAR 0 4
91795: PUSH
91796: LD_VAR 0 5
91800: ST_TO_ADDR
// end ;
91801: LD_VAR 0 4
91805: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91806: LD_INT 0
91808: PPUSH
91809: PPUSH
91810: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91811: LD_VAR 0 1
91815: NOT
91816: PUSH
91817: LD_VAR 0 2
91821: PUSH
91822: LD_INT 1
91824: PUSH
91825: LD_INT 2
91827: PUSH
91828: LD_INT 3
91830: PUSH
91831: LD_INT 4
91833: PUSH
91834: EMPTY
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: IN
91840: NOT
91841: OR
91842: IFFALSE 91846
// exit ;
91844: GO 91938
// tmp := [ ] ;
91846: LD_ADDR_VAR 0 5
91850: PUSH
91851: EMPTY
91852: ST_TO_ADDR
// for i in units do
91853: LD_ADDR_VAR 0 4
91857: PUSH
91858: LD_VAR 0 1
91862: PUSH
91863: FOR_IN
91864: IFFALSE 91907
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
91866: LD_ADDR_VAR 0 5
91870: PUSH
91871: LD_VAR 0 5
91875: PPUSH
91876: LD_VAR 0 5
91880: PUSH
91881: LD_INT 1
91883: PLUS
91884: PPUSH
91885: LD_VAR 0 4
91889: PPUSH
91890: LD_VAR 0 2
91894: PPUSH
91895: CALL_OW 259
91899: PPUSH
91900: CALL_OW 2
91904: ST_TO_ADDR
91905: GO 91863
91907: POP
91908: POP
// if not tmp then
91909: LD_VAR 0 5
91913: NOT
91914: IFFALSE 91918
// exit ;
91916: GO 91938
// result := SortListByListDesc ( units , tmp ) ;
91918: LD_ADDR_VAR 0 3
91922: PUSH
91923: LD_VAR 0 1
91927: PPUSH
91928: LD_VAR 0 5
91932: PPUSH
91933: CALL_OW 77
91937: ST_TO_ADDR
// end ;
91938: LD_VAR 0 3
91942: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
91943: LD_INT 0
91945: PPUSH
91946: PPUSH
91947: PPUSH
// x := GetX ( building ) ;
91948: LD_ADDR_VAR 0 4
91952: PUSH
91953: LD_VAR 0 2
91957: PPUSH
91958: CALL_OW 250
91962: ST_TO_ADDR
// y := GetY ( building ) ;
91963: LD_ADDR_VAR 0 5
91967: PUSH
91968: LD_VAR 0 2
91972: PPUSH
91973: CALL_OW 251
91977: ST_TO_ADDR
// if GetTaskList ( unit ) then
91978: LD_VAR 0 1
91982: PPUSH
91983: CALL_OW 437
91987: IFFALSE 92082
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91989: LD_STRING e
91991: PUSH
91992: LD_VAR 0 1
91996: PPUSH
91997: CALL_OW 437
92001: PUSH
92002: LD_INT 1
92004: ARRAY
92005: PUSH
92006: LD_INT 1
92008: ARRAY
92009: EQUAL
92010: PUSH
92011: LD_VAR 0 4
92015: PUSH
92016: LD_VAR 0 1
92020: PPUSH
92021: CALL_OW 437
92025: PUSH
92026: LD_INT 1
92028: ARRAY
92029: PUSH
92030: LD_INT 2
92032: ARRAY
92033: EQUAL
92034: AND
92035: PUSH
92036: LD_VAR 0 5
92040: PUSH
92041: LD_VAR 0 1
92045: PPUSH
92046: CALL_OW 437
92050: PUSH
92051: LD_INT 1
92053: ARRAY
92054: PUSH
92055: LD_INT 3
92057: ARRAY
92058: EQUAL
92059: AND
92060: IFFALSE 92072
// result := true else
92062: LD_ADDR_VAR 0 3
92066: PUSH
92067: LD_INT 1
92069: ST_TO_ADDR
92070: GO 92080
// result := false ;
92072: LD_ADDR_VAR 0 3
92076: PUSH
92077: LD_INT 0
92079: ST_TO_ADDR
// end else
92080: GO 92090
// result := false ;
92082: LD_ADDR_VAR 0 3
92086: PUSH
92087: LD_INT 0
92089: ST_TO_ADDR
// end ;
92090: LD_VAR 0 3
92094: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
92095: LD_INT 0
92097: PPUSH
92098: PPUSH
92099: PPUSH
92100: PPUSH
// if not unit or not area then
92101: LD_VAR 0 1
92105: NOT
92106: PUSH
92107: LD_VAR 0 2
92111: NOT
92112: OR
92113: IFFALSE 92117
// exit ;
92115: GO 92281
// tmp := AreaToList ( area , i ) ;
92117: LD_ADDR_VAR 0 6
92121: PUSH
92122: LD_VAR 0 2
92126: PPUSH
92127: LD_VAR 0 5
92131: PPUSH
92132: CALL_OW 517
92136: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
92137: LD_ADDR_VAR 0 5
92141: PUSH
92142: DOUBLE
92143: LD_INT 1
92145: DEC
92146: ST_TO_ADDR
92147: LD_VAR 0 6
92151: PUSH
92152: LD_INT 1
92154: ARRAY
92155: PUSH
92156: FOR_TO
92157: IFFALSE 92279
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
92159: LD_ADDR_VAR 0 7
92163: PUSH
92164: LD_VAR 0 6
92168: PUSH
92169: LD_INT 1
92171: ARRAY
92172: PUSH
92173: LD_VAR 0 5
92177: ARRAY
92178: PUSH
92179: LD_VAR 0 6
92183: PUSH
92184: LD_INT 2
92186: ARRAY
92187: PUSH
92188: LD_VAR 0 5
92192: ARRAY
92193: PUSH
92194: EMPTY
92195: LIST
92196: LIST
92197: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92198: LD_VAR 0 7
92202: PUSH
92203: LD_INT 1
92205: ARRAY
92206: PPUSH
92207: LD_VAR 0 7
92211: PUSH
92212: LD_INT 2
92214: ARRAY
92215: PPUSH
92216: CALL_OW 428
92220: PUSH
92221: LD_INT 0
92223: EQUAL
92224: IFFALSE 92277
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92226: LD_VAR 0 1
92230: PPUSH
92231: LD_VAR 0 7
92235: PUSH
92236: LD_INT 1
92238: ARRAY
92239: PPUSH
92240: LD_VAR 0 7
92244: PUSH
92245: LD_INT 2
92247: ARRAY
92248: PPUSH
92249: LD_VAR 0 3
92253: PPUSH
92254: CALL_OW 48
// result := IsPlaced ( unit ) ;
92258: LD_ADDR_VAR 0 4
92262: PUSH
92263: LD_VAR 0 1
92267: PPUSH
92268: CALL_OW 305
92272: ST_TO_ADDR
// exit ;
92273: POP
92274: POP
92275: GO 92281
// end ; end ;
92277: GO 92156
92279: POP
92280: POP
// end ;
92281: LD_VAR 0 4
92285: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92286: LD_INT 0
92288: PPUSH
92289: PPUSH
92290: PPUSH
// if not side or side > 8 then
92291: LD_VAR 0 1
92295: NOT
92296: PUSH
92297: LD_VAR 0 1
92301: PUSH
92302: LD_INT 8
92304: GREATER
92305: OR
92306: IFFALSE 92310
// exit ;
92308: GO 92497
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92310: LD_ADDR_VAR 0 4
92314: PUSH
92315: LD_INT 22
92317: PUSH
92318: LD_VAR 0 1
92322: PUSH
92323: EMPTY
92324: LIST
92325: LIST
92326: PUSH
92327: LD_INT 21
92329: PUSH
92330: LD_INT 3
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: PUSH
92337: EMPTY
92338: LIST
92339: LIST
92340: PPUSH
92341: CALL_OW 69
92345: ST_TO_ADDR
// if not tmp then
92346: LD_VAR 0 4
92350: NOT
92351: IFFALSE 92355
// exit ;
92353: GO 92497
// enable_addtolog := true ;
92355: LD_ADDR_OWVAR 81
92359: PUSH
92360: LD_INT 1
92362: ST_TO_ADDR
// AddToLog ( [ ) ;
92363: LD_STRING [
92365: PPUSH
92366: CALL_OW 561
// for i in tmp do
92370: LD_ADDR_VAR 0 3
92374: PUSH
92375: LD_VAR 0 4
92379: PUSH
92380: FOR_IN
92381: IFFALSE 92488
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
92383: LD_STRING [
92385: PUSH
92386: LD_VAR 0 3
92390: PPUSH
92391: CALL_OW 266
92395: STR
92396: PUSH
92397: LD_STRING , 
92399: STR
92400: PUSH
92401: LD_VAR 0 3
92405: PPUSH
92406: CALL_OW 250
92410: STR
92411: PUSH
92412: LD_STRING , 
92414: STR
92415: PUSH
92416: LD_VAR 0 3
92420: PPUSH
92421: CALL_OW 251
92425: STR
92426: PUSH
92427: LD_STRING , 
92429: STR
92430: PUSH
92431: LD_VAR 0 3
92435: PPUSH
92436: CALL_OW 254
92440: STR
92441: PUSH
92442: LD_STRING , 
92444: STR
92445: PUSH
92446: LD_VAR 0 3
92450: PPUSH
92451: LD_INT 1
92453: PPUSH
92454: CALL_OW 268
92458: STR
92459: PUSH
92460: LD_STRING , 
92462: STR
92463: PUSH
92464: LD_VAR 0 3
92468: PPUSH
92469: LD_INT 2
92471: PPUSH
92472: CALL_OW 268
92476: STR
92477: PUSH
92478: LD_STRING ],
92480: STR
92481: PPUSH
92482: CALL_OW 561
// end ;
92486: GO 92380
92488: POP
92489: POP
// AddToLog ( ]; ) ;
92490: LD_STRING ];
92492: PPUSH
92493: CALL_OW 561
// end ;
92497: LD_VAR 0 2
92501: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
92502: LD_INT 0
92504: PPUSH
92505: PPUSH
92506: PPUSH
92507: PPUSH
92508: PPUSH
// if not area or not rate or not max then
92509: LD_VAR 0 1
92513: NOT
92514: PUSH
92515: LD_VAR 0 2
92519: NOT
92520: OR
92521: PUSH
92522: LD_VAR 0 4
92526: NOT
92527: OR
92528: IFFALSE 92532
// exit ;
92530: GO 92724
// while 1 do
92532: LD_INT 1
92534: IFFALSE 92724
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92536: LD_ADDR_VAR 0 9
92540: PUSH
92541: LD_VAR 0 1
92545: PPUSH
92546: LD_INT 1
92548: PPUSH
92549: CALL_OW 287
92553: PUSH
92554: LD_INT 10
92556: MUL
92557: ST_TO_ADDR
// r := rate / 10 ;
92558: LD_ADDR_VAR 0 7
92562: PUSH
92563: LD_VAR 0 2
92567: PUSH
92568: LD_INT 10
92570: DIVREAL
92571: ST_TO_ADDR
// time := 1 1$00 ;
92572: LD_ADDR_VAR 0 8
92576: PUSH
92577: LD_INT 2100
92579: ST_TO_ADDR
// if amount < min then
92580: LD_VAR 0 9
92584: PUSH
92585: LD_VAR 0 3
92589: LESS
92590: IFFALSE 92608
// r := r * 2 else
92592: LD_ADDR_VAR 0 7
92596: PUSH
92597: LD_VAR 0 7
92601: PUSH
92602: LD_INT 2
92604: MUL
92605: ST_TO_ADDR
92606: GO 92634
// if amount > max then
92608: LD_VAR 0 9
92612: PUSH
92613: LD_VAR 0 4
92617: GREATER
92618: IFFALSE 92634
// r := r / 2 ;
92620: LD_ADDR_VAR 0 7
92624: PUSH
92625: LD_VAR 0 7
92629: PUSH
92630: LD_INT 2
92632: DIVREAL
92633: ST_TO_ADDR
// time := time / r ;
92634: LD_ADDR_VAR 0 8
92638: PUSH
92639: LD_VAR 0 8
92643: PUSH
92644: LD_VAR 0 7
92648: DIVREAL
92649: ST_TO_ADDR
// if time < 0 then
92650: LD_VAR 0 8
92654: PUSH
92655: LD_INT 0
92657: LESS
92658: IFFALSE 92675
// time := time * - 1 ;
92660: LD_ADDR_VAR 0 8
92664: PUSH
92665: LD_VAR 0 8
92669: PUSH
92670: LD_INT 1
92672: NEG
92673: MUL
92674: ST_TO_ADDR
// wait ( time ) ;
92675: LD_VAR 0 8
92679: PPUSH
92680: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92684: LD_INT 35
92686: PPUSH
92687: LD_INT 875
92689: PPUSH
92690: CALL_OW 12
92694: PPUSH
92695: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92699: LD_INT 1
92701: PPUSH
92702: LD_INT 5
92704: PPUSH
92705: CALL_OW 12
92709: PPUSH
92710: LD_VAR 0 1
92714: PPUSH
92715: LD_INT 1
92717: PPUSH
92718: CALL_OW 55
// end ;
92722: GO 92532
// end ;
92724: LD_VAR 0 5
92728: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92729: LD_INT 0
92731: PPUSH
92732: PPUSH
92733: PPUSH
92734: PPUSH
92735: PPUSH
92736: PPUSH
92737: PPUSH
92738: PPUSH
// if not turrets or not factories then
92739: LD_VAR 0 1
92743: NOT
92744: PUSH
92745: LD_VAR 0 2
92749: NOT
92750: OR
92751: IFFALSE 92755
// exit ;
92753: GO 93062
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92755: LD_ADDR_VAR 0 10
92759: PUSH
92760: LD_INT 5
92762: PUSH
92763: LD_INT 6
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: PUSH
92770: LD_INT 2
92772: PUSH
92773: LD_INT 4
92775: PUSH
92776: EMPTY
92777: LIST
92778: LIST
92779: PUSH
92780: LD_INT 3
92782: PUSH
92783: LD_INT 5
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: PUSH
92790: EMPTY
92791: LIST
92792: LIST
92793: LIST
92794: PUSH
92795: LD_INT 24
92797: PUSH
92798: LD_INT 25
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 23
92807: PUSH
92808: LD_INT 27
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PUSH
92819: LD_INT 42
92821: PUSH
92822: LD_INT 43
92824: PUSH
92825: EMPTY
92826: LIST
92827: LIST
92828: PUSH
92829: LD_INT 44
92831: PUSH
92832: LD_INT 46
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: LD_INT 45
92841: PUSH
92842: LD_INT 47
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: EMPTY
92850: LIST
92851: LIST
92852: LIST
92853: PUSH
92854: EMPTY
92855: LIST
92856: LIST
92857: LIST
92858: ST_TO_ADDR
// result := [ ] ;
92859: LD_ADDR_VAR 0 3
92863: PUSH
92864: EMPTY
92865: ST_TO_ADDR
// for i in turrets do
92866: LD_ADDR_VAR 0 4
92870: PUSH
92871: LD_VAR 0 1
92875: PUSH
92876: FOR_IN
92877: IFFALSE 93060
// begin nat := GetNation ( i ) ;
92879: LD_ADDR_VAR 0 7
92883: PUSH
92884: LD_VAR 0 4
92888: PPUSH
92889: CALL_OW 248
92893: ST_TO_ADDR
// weapon := 0 ;
92894: LD_ADDR_VAR 0 8
92898: PUSH
92899: LD_INT 0
92901: ST_TO_ADDR
// if not nat then
92902: LD_VAR 0 7
92906: NOT
92907: IFFALSE 92911
// continue ;
92909: GO 92876
// for j in list [ nat ] do
92911: LD_ADDR_VAR 0 5
92915: PUSH
92916: LD_VAR 0 10
92920: PUSH
92921: LD_VAR 0 7
92925: ARRAY
92926: PUSH
92927: FOR_IN
92928: IFFALSE 92969
// if GetBWeapon ( i ) = j [ 1 ] then
92930: LD_VAR 0 4
92934: PPUSH
92935: CALL_OW 269
92939: PUSH
92940: LD_VAR 0 5
92944: PUSH
92945: LD_INT 1
92947: ARRAY
92948: EQUAL
92949: IFFALSE 92967
// begin weapon := j [ 2 ] ;
92951: LD_ADDR_VAR 0 8
92955: PUSH
92956: LD_VAR 0 5
92960: PUSH
92961: LD_INT 2
92963: ARRAY
92964: ST_TO_ADDR
// break ;
92965: GO 92969
// end ;
92967: GO 92927
92969: POP
92970: POP
// if not weapon then
92971: LD_VAR 0 8
92975: NOT
92976: IFFALSE 92980
// continue ;
92978: GO 92876
// for k in factories do
92980: LD_ADDR_VAR 0 6
92984: PUSH
92985: LD_VAR 0 2
92989: PUSH
92990: FOR_IN
92991: IFFALSE 93056
// begin weapons := AvailableWeaponList ( k ) ;
92993: LD_ADDR_VAR 0 9
92997: PUSH
92998: LD_VAR 0 6
93002: PPUSH
93003: CALL_OW 478
93007: ST_TO_ADDR
// if not weapons then
93008: LD_VAR 0 9
93012: NOT
93013: IFFALSE 93017
// continue ;
93015: GO 92990
// if weapon in weapons then
93017: LD_VAR 0 8
93021: PUSH
93022: LD_VAR 0 9
93026: IN
93027: IFFALSE 93054
// begin result := [ i , weapon ] ;
93029: LD_ADDR_VAR 0 3
93033: PUSH
93034: LD_VAR 0 4
93038: PUSH
93039: LD_VAR 0 8
93043: PUSH
93044: EMPTY
93045: LIST
93046: LIST
93047: ST_TO_ADDR
// exit ;
93048: POP
93049: POP
93050: POP
93051: POP
93052: GO 93062
// end ; end ;
93054: GO 92990
93056: POP
93057: POP
// end ;
93058: GO 92876
93060: POP
93061: POP
// end ;
93062: LD_VAR 0 3
93066: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
93067: LD_INT 0
93069: PPUSH
// if not side or side > 8 then
93070: LD_VAR 0 3
93074: NOT
93075: PUSH
93076: LD_VAR 0 3
93080: PUSH
93081: LD_INT 8
93083: GREATER
93084: OR
93085: IFFALSE 93089
// exit ;
93087: GO 93148
// if not range then
93089: LD_VAR 0 4
93093: NOT
93094: IFFALSE 93105
// range := - 12 ;
93096: LD_ADDR_VAR 0 4
93100: PUSH
93101: LD_INT 12
93103: NEG
93104: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
93105: LD_VAR 0 1
93109: PPUSH
93110: LD_VAR 0 2
93114: PPUSH
93115: LD_VAR 0 3
93119: PPUSH
93120: LD_VAR 0 4
93124: PPUSH
93125: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
93129: LD_VAR 0 1
93133: PPUSH
93134: LD_VAR 0 2
93138: PPUSH
93139: LD_VAR 0 3
93143: PPUSH
93144: CALL_OW 331
// end ;
93148: LD_VAR 0 5
93152: RET
// export function Video ( mode ) ; begin
93153: LD_INT 0
93155: PPUSH
// ingame_video = mode ;
93156: LD_ADDR_OWVAR 52
93160: PUSH
93161: LD_VAR 0 1
93165: ST_TO_ADDR
// interface_hidden = mode ;
93166: LD_ADDR_OWVAR 54
93170: PUSH
93171: LD_VAR 0 1
93175: ST_TO_ADDR
// end ;
93176: LD_VAR 0 2
93180: RET
// export function Join ( array , element ) ; begin
93181: LD_INT 0
93183: PPUSH
// result := array ^ element ;
93184: LD_ADDR_VAR 0 3
93188: PUSH
93189: LD_VAR 0 1
93193: PUSH
93194: LD_VAR 0 2
93198: ADD
93199: ST_TO_ADDR
// end ;
93200: LD_VAR 0 3
93204: RET
// export function JoinUnion ( array , element ) ; begin
93205: LD_INT 0
93207: PPUSH
// result := array union element ;
93208: LD_ADDR_VAR 0 3
93212: PUSH
93213: LD_VAR 0 1
93217: PUSH
93218: LD_VAR 0 2
93222: UNION
93223: ST_TO_ADDR
// end ;
93224: LD_VAR 0 3
93228: RET
// export function GetBehemoths ( side ) ; begin
93229: LD_INT 0
93231: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93232: LD_ADDR_VAR 0 2
93236: PUSH
93237: LD_INT 22
93239: PUSH
93240: LD_VAR 0 1
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: LD_INT 31
93251: PUSH
93252: LD_INT 25
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: EMPTY
93260: LIST
93261: LIST
93262: PPUSH
93263: CALL_OW 69
93267: ST_TO_ADDR
// end ;
93268: LD_VAR 0 2
93272: RET
// export function Shuffle ( array ) ; var i , index ; begin
93273: LD_INT 0
93275: PPUSH
93276: PPUSH
93277: PPUSH
// result := [ ] ;
93278: LD_ADDR_VAR 0 2
93282: PUSH
93283: EMPTY
93284: ST_TO_ADDR
// if not array then
93285: LD_VAR 0 1
93289: NOT
93290: IFFALSE 93294
// exit ;
93292: GO 93393
// Randomize ;
93294: CALL_OW 10
// for i = array downto 1 do
93298: LD_ADDR_VAR 0 3
93302: PUSH
93303: DOUBLE
93304: LD_VAR 0 1
93308: INC
93309: ST_TO_ADDR
93310: LD_INT 1
93312: PUSH
93313: FOR_DOWNTO
93314: IFFALSE 93391
// begin index := rand ( 1 , array ) ;
93316: LD_ADDR_VAR 0 4
93320: PUSH
93321: LD_INT 1
93323: PPUSH
93324: LD_VAR 0 1
93328: PPUSH
93329: CALL_OW 12
93333: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93334: LD_ADDR_VAR 0 2
93338: PUSH
93339: LD_VAR 0 2
93343: PPUSH
93344: LD_VAR 0 2
93348: PUSH
93349: LD_INT 1
93351: PLUS
93352: PPUSH
93353: LD_VAR 0 1
93357: PUSH
93358: LD_VAR 0 4
93362: ARRAY
93363: PPUSH
93364: CALL_OW 2
93368: ST_TO_ADDR
// array := Delete ( array , index ) ;
93369: LD_ADDR_VAR 0 1
93373: PUSH
93374: LD_VAR 0 1
93378: PPUSH
93379: LD_VAR 0 4
93383: PPUSH
93384: CALL_OW 3
93388: ST_TO_ADDR
// end ;
93389: GO 93313
93391: POP
93392: POP
// end ;
93393: LD_VAR 0 2
93397: RET
// export function GetBaseMaterials ( base ) ; begin
93398: LD_INT 0
93400: PPUSH
// result := [ 0 , 0 , 0 ] ;
93401: LD_ADDR_VAR 0 2
93405: PUSH
93406: LD_INT 0
93408: PUSH
93409: LD_INT 0
93411: PUSH
93412: LD_INT 0
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: LIST
93419: ST_TO_ADDR
// if not base then
93420: LD_VAR 0 1
93424: NOT
93425: IFFALSE 93429
// exit ;
93427: GO 93478
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
93429: LD_ADDR_VAR 0 2
93433: PUSH
93434: LD_VAR 0 1
93438: PPUSH
93439: LD_INT 1
93441: PPUSH
93442: CALL_OW 275
93446: PUSH
93447: LD_VAR 0 1
93451: PPUSH
93452: LD_INT 2
93454: PPUSH
93455: CALL_OW 275
93459: PUSH
93460: LD_VAR 0 1
93464: PPUSH
93465: LD_INT 3
93467: PPUSH
93468: CALL_OW 275
93472: PUSH
93473: EMPTY
93474: LIST
93475: LIST
93476: LIST
93477: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
93478: LD_VAR 0 2
93482: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
93483: LD_INT 0
93485: PPUSH
93486: PPUSH
93487: PPUSH
93488: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93489: LD_VAR 0 1
93493: PPUSH
93494: CALL_OW 264
93498: PUSH
93499: LD_EXP 73
93503: EQUAL
93504: IFFALSE 93576
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93506: LD_INT 68
93508: PPUSH
93509: LD_VAR 0 1
93513: PPUSH
93514: CALL_OW 255
93518: PPUSH
93519: CALL_OW 321
93523: PUSH
93524: LD_INT 2
93526: EQUAL
93527: IFFALSE 93539
// eff := 70 else
93529: LD_ADDR_VAR 0 6
93533: PUSH
93534: LD_INT 70
93536: ST_TO_ADDR
93537: GO 93547
// eff := 30 ;
93539: LD_ADDR_VAR 0 6
93543: PUSH
93544: LD_INT 30
93546: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93547: LD_VAR 0 1
93551: PPUSH
93552: CALL_OW 250
93556: PPUSH
93557: LD_VAR 0 1
93561: PPUSH
93562: CALL_OW 251
93566: PPUSH
93567: LD_VAR 0 6
93571: PPUSH
93572: CALL_OW 495
// end ; end ;
93576: LD_VAR 0 4
93580: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
93581: LD_INT 0
93583: PPUSH
93584: PPUSH
93585: PPUSH
93586: PPUSH
93587: PPUSH
93588: PPUSH
// if cmd = 124 then
93589: LD_VAR 0 1
93593: PUSH
93594: LD_INT 124
93596: EQUAL
93597: IFFALSE 93803
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
93599: LD_ADDR_VAR 0 5
93603: PUSH
93604: LD_INT 2
93606: PUSH
93607: LD_INT 34
93609: PUSH
93610: LD_INT 53
93612: PUSH
93613: EMPTY
93614: LIST
93615: LIST
93616: PUSH
93617: LD_INT 34
93619: PUSH
93620: LD_INT 14
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: LIST
93631: PPUSH
93632: CALL_OW 69
93636: ST_TO_ADDR
// if not tmp then
93637: LD_VAR 0 5
93641: NOT
93642: IFFALSE 93646
// exit ;
93644: GO 93803
// for i in tmp do
93646: LD_ADDR_VAR 0 3
93650: PUSH
93651: LD_VAR 0 5
93655: PUSH
93656: FOR_IN
93657: IFFALSE 93801
// begin taskList := GetTaskList ( i ) ;
93659: LD_ADDR_VAR 0 6
93663: PUSH
93664: LD_VAR 0 3
93668: PPUSH
93669: CALL_OW 437
93673: ST_TO_ADDR
// if not taskList then
93674: LD_VAR 0 6
93678: NOT
93679: IFFALSE 93683
// continue ;
93681: GO 93656
// for j = 1 to taskList do
93683: LD_ADDR_VAR 0 4
93687: PUSH
93688: DOUBLE
93689: LD_INT 1
93691: DEC
93692: ST_TO_ADDR
93693: LD_VAR 0 6
93697: PUSH
93698: FOR_TO
93699: IFFALSE 93797
// if taskList [ j ] [ 1 ] = | then
93701: LD_VAR 0 6
93705: PUSH
93706: LD_VAR 0 4
93710: ARRAY
93711: PUSH
93712: LD_INT 1
93714: ARRAY
93715: PUSH
93716: LD_STRING |
93718: EQUAL
93719: IFFALSE 93795
// begin _taskList := Delete ( taskList , 1 ) ;
93721: LD_ADDR_VAR 0 7
93725: PUSH
93726: LD_VAR 0 6
93730: PPUSH
93731: LD_INT 1
93733: PPUSH
93734: CALL_OW 3
93738: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
93739: LD_VAR 0 3
93743: PPUSH
93744: LD_VAR 0 7
93748: PPUSH
93749: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
93753: LD_VAR 0 3
93757: PPUSH
93758: LD_VAR 0 6
93762: PUSH
93763: LD_VAR 0 4
93767: ARRAY
93768: PUSH
93769: LD_INT 2
93771: ARRAY
93772: PPUSH
93773: LD_VAR 0 6
93777: PUSH
93778: LD_VAR 0 4
93782: ARRAY
93783: PUSH
93784: LD_INT 3
93786: ARRAY
93787: PPUSH
93788: LD_INT 8
93790: PPUSH
93791: CALL 93808 0 4
// end ;
93795: GO 93698
93797: POP
93798: POP
// end ;
93799: GO 93656
93801: POP
93802: POP
// end ; end ;
93803: LD_VAR 0 2
93807: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93808: LD_INT 0
93810: PPUSH
93811: PPUSH
93812: PPUSH
93813: PPUSH
93814: PPUSH
93815: PPUSH
93816: PPUSH
93817: PPUSH
93818: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93819: LD_VAR 0 1
93823: NOT
93824: PUSH
93825: LD_VAR 0 2
93829: PPUSH
93830: LD_VAR 0 3
93834: PPUSH
93835: CALL_OW 488
93839: NOT
93840: OR
93841: PUSH
93842: LD_VAR 0 4
93846: NOT
93847: OR
93848: IFFALSE 93852
// exit ;
93850: GO 94192
// list := [ ] ;
93852: LD_ADDR_VAR 0 13
93856: PUSH
93857: EMPTY
93858: ST_TO_ADDR
// if x - r < 0 then
93859: LD_VAR 0 2
93863: PUSH
93864: LD_VAR 0 4
93868: MINUS
93869: PUSH
93870: LD_INT 0
93872: LESS
93873: IFFALSE 93885
// min_x := 0 else
93875: LD_ADDR_VAR 0 7
93879: PUSH
93880: LD_INT 0
93882: ST_TO_ADDR
93883: GO 93901
// min_x := x - r ;
93885: LD_ADDR_VAR 0 7
93889: PUSH
93890: LD_VAR 0 2
93894: PUSH
93895: LD_VAR 0 4
93899: MINUS
93900: ST_TO_ADDR
// if y - r < 0 then
93901: LD_VAR 0 3
93905: PUSH
93906: LD_VAR 0 4
93910: MINUS
93911: PUSH
93912: LD_INT 0
93914: LESS
93915: IFFALSE 93927
// min_y := 0 else
93917: LD_ADDR_VAR 0 8
93921: PUSH
93922: LD_INT 0
93924: ST_TO_ADDR
93925: GO 93943
// min_y := y - r ;
93927: LD_ADDR_VAR 0 8
93931: PUSH
93932: LD_VAR 0 3
93936: PUSH
93937: LD_VAR 0 4
93941: MINUS
93942: ST_TO_ADDR
// max_x := x + r ;
93943: LD_ADDR_VAR 0 9
93947: PUSH
93948: LD_VAR 0 2
93952: PUSH
93953: LD_VAR 0 4
93957: PLUS
93958: ST_TO_ADDR
// max_y := y + r ;
93959: LD_ADDR_VAR 0 10
93963: PUSH
93964: LD_VAR 0 3
93968: PUSH
93969: LD_VAR 0 4
93973: PLUS
93974: ST_TO_ADDR
// for _x = min_x to max_x do
93975: LD_ADDR_VAR 0 11
93979: PUSH
93980: DOUBLE
93981: LD_VAR 0 7
93985: DEC
93986: ST_TO_ADDR
93987: LD_VAR 0 9
93991: PUSH
93992: FOR_TO
93993: IFFALSE 94110
// for _y = min_y to max_y do
93995: LD_ADDR_VAR 0 12
93999: PUSH
94000: DOUBLE
94001: LD_VAR 0 8
94005: DEC
94006: ST_TO_ADDR
94007: LD_VAR 0 10
94011: PUSH
94012: FOR_TO
94013: IFFALSE 94106
// begin if not ValidHex ( _x , _y ) then
94015: LD_VAR 0 11
94019: PPUSH
94020: LD_VAR 0 12
94024: PPUSH
94025: CALL_OW 488
94029: NOT
94030: IFFALSE 94034
// continue ;
94032: GO 94012
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
94034: LD_VAR 0 11
94038: PPUSH
94039: LD_VAR 0 12
94043: PPUSH
94044: CALL_OW 351
94048: PUSH
94049: LD_VAR 0 11
94053: PPUSH
94054: LD_VAR 0 12
94058: PPUSH
94059: CALL_OW 554
94063: AND
94064: IFFALSE 94104
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
94066: LD_ADDR_VAR 0 13
94070: PUSH
94071: LD_VAR 0 13
94075: PPUSH
94076: LD_VAR 0 13
94080: PUSH
94081: LD_INT 1
94083: PLUS
94084: PPUSH
94085: LD_VAR 0 11
94089: PUSH
94090: LD_VAR 0 12
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PPUSH
94099: CALL_OW 2
94103: ST_TO_ADDR
// end ;
94104: GO 94012
94106: POP
94107: POP
94108: GO 93992
94110: POP
94111: POP
// if not list then
94112: LD_VAR 0 13
94116: NOT
94117: IFFALSE 94121
// exit ;
94119: GO 94192
// for i in list do
94121: LD_ADDR_VAR 0 6
94125: PUSH
94126: LD_VAR 0 13
94130: PUSH
94131: FOR_IN
94132: IFFALSE 94190
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94134: LD_VAR 0 1
94138: PPUSH
94139: LD_STRING M
94141: PUSH
94142: LD_VAR 0 6
94146: PUSH
94147: LD_INT 1
94149: ARRAY
94150: PUSH
94151: LD_VAR 0 6
94155: PUSH
94156: LD_INT 2
94158: ARRAY
94159: PUSH
94160: LD_INT 0
94162: PUSH
94163: LD_INT 0
94165: PUSH
94166: LD_INT 0
94168: PUSH
94169: LD_INT 0
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: PUSH
94181: EMPTY
94182: LIST
94183: PPUSH
94184: CALL_OW 447
94188: GO 94131
94190: POP
94191: POP
// end ;
94192: LD_VAR 0 5
94196: RET
