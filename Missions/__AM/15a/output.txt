// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 19753 0 0
// InitNature ;
  19: CALL 16425 0 0
// InitArtifact ;
  23: CALL 17038 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4177 0 0
// PrepareAlliance ;
  44: CALL 1314 0 0
// PrepareArabian ;
  48: CALL 5907 0 0
// PrepareRussian ;
  52: CALL 7858 0 0
// PrepareLegion ;
  56: CALL 6301 0 0
// Action ;
  60: CALL 10361 0 0
// MC_Start ( ) ;
  64: CALL 21865 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// end ;
 168: LD_VAR 0 1
 172: RET
// export function CustomInitMacro ( ) ; begin
 173: LD_INT 0
 175: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 176: LD_ADDR_EXP 98
 180: PUSH
 181: LD_INT 26
 183: PUSH
 184: LD_INT 1
 186: PUSH
 187: LD_INT 4
 189: PUSH
 190: LD_INT 8
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 199: LD_ADDR_EXP 99
 203: PUSH
 204: LD_INT 27
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 7
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: LIST
 221: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 222: LD_INT 1
 224: PPUSH
 225: LD_INT 6
 227: PUSH
 228: LD_INT 7
 230: PUSH
 231: LD_INT 9
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: PPUSH
 245: LD_INT 28
 247: PPUSH
 248: CALL 42970 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 252: LD_INT 1
 254: PPUSH
 255: LD_INT 10
 257: PUSH
 258: LD_INT 11
 260: PUSH
 261: LD_INT 13
 263: PUSH
 264: LD_INT 15
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: PPUSH
 273: CALL 44030 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 29
 282: PUSH
 283: EMPTY
 284: LIST
 285: PPUSH
 286: CALL 44123 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 290: LD_ADDR_EXP 103
 294: PUSH
 295: LD_EXP 103
 299: PPUSH
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 22
 305: PUSH
 306: LD_INT 2
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: PUSH
 313: LD_INT 25
 315: PUSH
 316: LD_INT 15
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: PPUSH
 327: CALL_OW 69
 331: PPUSH
 332: CALL_OW 1
 336: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 337: LD_INT 1
 339: PPUSH
 340: LD_INT 13
 342: PUSH
 343: LD_INT 2
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 31
 351: PUSH
 352: EMPTY
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: PUSH
 358: LD_INT 13
 360: PUSH
 361: LD_INT 2
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: LD_INT 31
 369: PUSH
 370: EMPTY
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 13
 378: PUSH
 379: LD_INT 1
 381: PUSH
 382: LD_INT 1
 384: PUSH
 385: LD_INT 28
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: PUSH
 394: LD_INT 13
 396: PUSH
 397: LD_INT 1
 399: PUSH
 400: LD_INT 1
 402: PUSH
 403: LD_INT 28
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: PUSH
 412: LD_INT 13
 414: PUSH
 415: LD_INT 1
 417: PUSH
 418: LD_INT 1
 420: PUSH
 421: LD_INT 28
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 13
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: LD_INT 28
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PPUSH
 456: CALL 43288 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 460: LD_INT 1
 462: PPUSH
 463: LD_INT 4
 465: PPUSH
 466: CALL 43473 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 470: LD_INT 2
 472: PPUSH
 473: LD_INT 10
 475: PUSH
 476: LD_INT 11
 478: PUSH
 479: LD_INT 12
 481: PUSH
 482: LD_INT 14
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL 44030 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 495: LD_INT 2
 497: PPUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: PPUSH
 504: CALL 44123 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 508: LD_INT 2
 510: PPUSH
 511: LD_INT 21
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 51
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 22
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: LD_INT 3
 537: PUSH
 538: LD_INT 52
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 22
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: LD_INT 3
 555: PUSH
 556: LD_INT 52
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 24
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: LD_INT 3
 573: PUSH
 574: LD_INT 47
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 24
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 3
 591: PUSH
 592: LD_INT 47
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: LD_INT 24
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: LD_INT 47
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: PUSH
 619: LD_INT 24
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 3
 627: PUSH
 628: LD_INT 47
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 24
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 47
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PPUSH
 665: CALL 43288 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 669: LD_INT 2
 671: PPUSH
 672: LD_INT 5
 674: PPUSH
 675: CALL 43473 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 0
 684: PPUSH
 685: CALL 43903 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 689: LD_INT 3
 691: PPUSH
 692: LD_INT 10
 694: PUSH
 695: LD_INT 12
 697: PUSH
 698: LD_INT 15
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_OWVAR 67
 710: ARRAY
 711: PPUSH
 712: LD_INT 24
 714: PPUSH
 715: CALL 42970 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 719: LD_INT 3
 721: PPUSH
 722: LD_INT 10
 724: PUSH
 725: LD_INT 11
 727: PUSH
 728: LD_INT 13
 730: PUSH
 731: LD_INT 15
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: PPUSH
 740: CALL 44030 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 744: LD_INT 3
 746: PPUSH
 747: LD_INT 13
 749: PUSH
 750: EMPTY
 751: LIST
 752: PPUSH
 753: CALL 44123 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 757: LD_ADDR_EXP 103
 761: PUSH
 762: LD_EXP 103
 766: PPUSH
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 22
 772: PUSH
 773: LD_INT 8
 775: PUSH
 776: EMPTY
 777: LIST
 778: LIST
 779: PUSH
 780: LD_INT 25
 782: PUSH
 783: LD_INT 15
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: PPUSH
 794: CALL_OW 69
 798: PPUSH
 799: CALL_OW 1
 803: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 804: LD_INT 3
 806: PPUSH
 807: LD_INT 13
 809: PUSH
 810: LD_INT 2
 812: PUSH
 813: LD_INT 1
 815: PUSH
 816: LD_INT 31
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 13
 827: PUSH
 828: LD_INT 2
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 31
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 13
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 2
 851: PUSH
 852: LD_INT 32
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: LD_INT 14
 863: PUSH
 864: LD_INT 1
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 28
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 14
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 28
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: PUSH
 897: LD_INT 14
 899: PUSH
 900: LD_INT 1
 902: PUSH
 903: LD_INT 1
 905: PUSH
 906: LD_INT 28
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 14
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: LD_INT 1
 923: PUSH
 924: LD_INT 28
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 43288 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 4
 951: PPUSH
 952: CALL 43473 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 956: LD_INT 4
 958: PPUSH
 959: LD_INT 10
 961: PUSH
 962: LD_INT 12
 964: PUSH
 965: LD_INT 11
 967: PUSH
 968: LD_INT 15
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL 44030 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 981: LD_INT 4
 983: PPUSH
 984: LD_INT 33
 986: PUSH
 987: EMPTY
 988: LIST
 989: PPUSH
 990: CALL 44123 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 994: LD_INT 4
 996: PPUSH
 997: LD_INT 5
 999: PUSH
1000: LD_INT 6
1002: PUSH
1003: LD_INT 7
1005: PUSH
1006: LD_INT 9
1008: PUSH
1009: LD_INT 10
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PPUSH
1019: CALL 44441 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1023: LD_INT 4
1025: PPUSH
1026: LD_INT 54
1028: PPUSH
1029: LD_INT 85
1031: PPUSH
1032: LD_INT 2
1034: PPUSH
1035: LD_INT 25
1037: PUSH
1038: LD_INT 16
1040: PUSH
1041: LD_INT 17
1043: PUSH
1044: LD_INT 18
1046: PUSH
1047: LD_INT 22
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL 44235 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1061: LD_INT 4
1063: PPUSH
1064: LD_INT 5
1066: PUSH
1067: LD_INT 1
1069: PUSH
1070: LD_INT 1
1072: PUSH
1073: LD_INT 7
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 5
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: LD_INT 1
1090: PUSH
1091: LD_INT 6
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 5
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 1
1108: PUSH
1109: LD_INT 7
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_INT 5
1120: PUSH
1121: LD_INT 1
1123: PUSH
1124: LD_INT 1
1126: PUSH
1127: LD_INT 6
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 5
1138: PUSH
1139: LD_INT 1
1141: PUSH
1142: LD_INT 3
1144: PUSH
1145: LD_INT 12
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PUSH
1154: LD_INT 3
1156: PUSH
1157: LD_INT 1
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: LD_INT 13
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PPUSH
1180: CALL 43288 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1184: LD_INT 4
1186: PPUSH
1187: LD_INT 4
1189: PPUSH
1190: CALL 43473 0 2
// MC_SetTame ( 4 , powellApe ) ;
1194: LD_INT 4
1196: PPUSH
1197: LD_INT 11
1199: PPUSH
1200: CALL 43854 0 2
// end ;
1204: LD_VAR 0 1
1208: RET
// every 0 0$1 trigger debug do var i ;
1209: LD_EXP 1
1213: IFFALSE 1311
1215: GO 1217
1217: DISABLE
1218: LD_INT 0
1220: PPUSH
// begin enable ;
1221: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1222: LD_ADDR_VAR 0 1
1226: PUSH
1227: LD_INT 22
1229: PUSH
1230: LD_INT 7
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 2
1239: PUSH
1240: LD_INT 21
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: PUSH
1250: LD_INT 21
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: PUSH
1265: LD_INT 3
1267: PUSH
1268: LD_INT 24
1270: PUSH
1271: LD_INT 1000
1273: PUSH
1274: EMPTY
1275: LIST
1276: LIST
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: PPUSH
1287: CALL_OW 69
1291: PUSH
1292: FOR_IN
1293: IFFALSE 1309
// SetLives ( i , 1000 ) ;
1295: LD_VAR 0 1
1299: PPUSH
1300: LD_INT 1000
1302: PPUSH
1303: CALL_OW 234
1307: GO 1292
1309: POP
1310: POP
// end ; end_of_file
1311: PPOPN 1
1313: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1314: LD_INT 0
1316: PPUSH
1317: PPUSH
1318: PPUSH
1319: PPUSH
1320: PPUSH
// uc_side := 7 ;
1321: LD_ADDR_OWVAR 20
1325: PUSH
1326: LD_INT 7
1328: ST_TO_ADDR
// tmp := [ ] ;
1329: LD_ADDR_VAR 0 5
1333: PUSH
1334: EMPTY
1335: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1336: LD_ADDR_EXP 12
1340: PUSH
1341: LD_STRING JMM
1343: PPUSH
1344: LD_EXP 1
1348: NOT
1349: PPUSH
1350: LD_STRING 14a_
1352: PPUSH
1353: CALL 49546 0 3
1357: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1358: LD_ADDR_EXP 44
1362: PUSH
1363: LD_STRING Burlak
1365: PPUSH
1366: LD_EXP 1
1370: NOT
1371: PPUSH
1372: LD_STRING 14a_
1374: PPUSH
1375: CALL 49546 0 3
1379: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1380: LD_ADDR_EXP 27
1384: PUSH
1385: LD_STRING Joan
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: LD_STRING 13a_
1396: PPUSH
1397: CALL 49546 0 3
1401: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1402: LD_ADDR_EXP 13
1406: PUSH
1407: LD_STRING Roth
1409: PPUSH
1410: LD_EXP 1
1414: NOT
1415: PPUSH
1416: LD_STRING 13a_
1418: PPUSH
1419: CALL 49546 0 3
1423: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1424: LD_ADDR_EXP 30
1428: PUSH
1429: LD_STRING Gossudarov
1431: PPUSH
1432: LD_EXP 1
1436: NOT
1437: PPUSH
1438: LD_STRING 13a_
1440: PPUSH
1441: CALL 49546 0 3
1445: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1446: LD_ADDR_EXP 28
1450: PUSH
1451: LD_STRING DeltaDoctor
1453: PPUSH
1454: LD_EXP 1
1458: NOT
1459: PPUSH
1460: LD_STRING 13a_
1462: PPUSH
1463: CALL 49546 0 3
1467: ST_TO_ADDR
// if DeltaDoctor then
1468: LD_EXP 28
1472: IFFALSE 1490
// tmp := tmp ^ DeltaDoctor ;
1474: LD_ADDR_VAR 0 5
1478: PUSH
1479: LD_VAR 0 5
1483: PUSH
1484: LD_EXP 28
1488: ADD
1489: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1490: LD_ADDR_EXP 26
1494: PUSH
1495: LD_STRING Simms
1497: PPUSH
1498: LD_EXP 1
1502: NOT
1503: PPUSH
1504: LD_STRING 13a_
1506: PPUSH
1507: CALL 49546 0 3
1511: ST_TO_ADDR
// if Simms then
1512: LD_EXP 26
1516: IFFALSE 1534
// tmp := tmp ^ Simms ;
1518: LD_ADDR_VAR 0 5
1522: PUSH
1523: LD_VAR 0 5
1527: PUSH
1528: LD_EXP 26
1532: ADD
1533: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1534: LD_ADDR_EXP 24
1538: PUSH
1539: LD_STRING Frank
1541: PPUSH
1542: LD_EXP 1
1546: NOT
1547: PPUSH
1548: LD_STRING 13a_
1550: PPUSH
1551: CALL 49546 0 3
1555: ST_TO_ADDR
// if Frank then
1556: LD_EXP 24
1560: IFFALSE 1578
// tmp := tmp ^ Frank ;
1562: LD_ADDR_VAR 0 5
1566: PUSH
1567: LD_VAR 0 5
1571: PUSH
1572: LD_EXP 24
1576: ADD
1577: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1578: LD_ADDR_EXP 31
1582: PUSH
1583: LD_STRING Kirilenkova
1585: PPUSH
1586: LD_EXP 1
1590: NOT
1591: PPUSH
1592: LD_STRING 13a_
1594: PPUSH
1595: CALL 49546 0 3
1599: ST_TO_ADDR
// if Kirilenkova then
1600: LD_EXP 31
1604: IFFALSE 1622
// tmp := tmp ^ Kirilenkova ;
1606: LD_ADDR_VAR 0 5
1610: PUSH
1611: LD_VAR 0 5
1615: PUSH
1616: LD_EXP 31
1620: ADD
1621: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING Titov
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 13a_
1638: PPUSH
1639: CALL 49546 0 3
1643: ST_TO_ADDR
// if Titov then
1644: LD_EXP 32
1648: IFFALSE 1666
// tmp := tmp ^ Titov ;
1650: LD_ADDR_VAR 0 5
1654: PUSH
1655: LD_VAR 0 5
1659: PUSH
1660: LD_EXP 32
1664: ADD
1665: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1666: LD_ADDR_EXP 33
1670: PUSH
1671: LD_STRING Fadeev
1673: PPUSH
1674: LD_EXP 1
1678: NOT
1679: PPUSH
1680: LD_STRING 13a_
1682: PPUSH
1683: CALL 49546 0 3
1687: ST_TO_ADDR
// if Fadeev then
1688: LD_EXP 33
1692: IFFALSE 1710
// tmp := tmp ^ Fadeev ;
1694: LD_ADDR_VAR 0 5
1698: PUSH
1699: LD_VAR 0 5
1703: PUSH
1704: LD_EXP 33
1708: ADD
1709: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1710: LD_ADDR_EXP 34
1714: PUSH
1715: LD_STRING Dolgov
1717: PPUSH
1718: LD_EXP 1
1722: NOT
1723: PPUSH
1724: LD_STRING 13a_
1726: PPUSH
1727: CALL 49546 0 3
1731: ST_TO_ADDR
// if Dolgov then
1732: LD_EXP 34
1736: IFFALSE 1754
// tmp := tmp ^ Dolgov ;
1738: LD_ADDR_VAR 0 5
1742: PUSH
1743: LD_VAR 0 5
1747: PUSH
1748: LD_EXP 34
1752: ADD
1753: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1754: LD_ADDR_EXP 35
1758: PUSH
1759: LD_STRING Petrosyan
1761: PPUSH
1762: LD_EXP 1
1766: NOT
1767: PPUSH
1768: LD_STRING 13a_
1770: PPUSH
1771: CALL 49546 0 3
1775: ST_TO_ADDR
// if Petrosyan then
1776: LD_EXP 35
1780: IFFALSE 1798
// tmp := tmp ^ Petrosyan ;
1782: LD_ADDR_VAR 0 5
1786: PUSH
1787: LD_VAR 0 5
1791: PUSH
1792: LD_EXP 35
1796: ADD
1797: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1798: LD_ADDR_EXP 36
1802: PUSH
1803: LD_STRING Scholtze
1805: PPUSH
1806: LD_EXP 1
1810: NOT
1811: PPUSH
1812: LD_STRING 13a_
1814: PPUSH
1815: CALL 49546 0 3
1819: ST_TO_ADDR
// if Scholtze then
1820: LD_EXP 36
1824: IFFALSE 1842
// tmp := tmp ^ Scholtze ;
1826: LD_ADDR_VAR 0 5
1830: PUSH
1831: LD_VAR 0 5
1835: PUSH
1836: LD_EXP 36
1840: ADD
1841: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1842: LD_ADDR_EXP 37
1846: PUSH
1847: LD_STRING Oblukov
1849: PPUSH
1850: LD_EXP 1
1854: NOT
1855: PPUSH
1856: LD_STRING 13a_
1858: PPUSH
1859: CALL 49546 0 3
1863: ST_TO_ADDR
// if Oblukov then
1864: LD_EXP 37
1868: IFFALSE 1886
// tmp := tmp ^ Oblukov ;
1870: LD_ADDR_VAR 0 5
1874: PUSH
1875: LD_VAR 0 5
1879: PUSH
1880: LD_EXP 37
1884: ADD
1885: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1886: LD_ADDR_EXP 38
1890: PUSH
1891: LD_STRING Kapitsova
1893: PPUSH
1894: LD_EXP 1
1898: NOT
1899: PPUSH
1900: LD_STRING 13a_
1902: PPUSH
1903: CALL 49546 0 3
1907: ST_TO_ADDR
// if Kapitsova then
1908: LD_EXP 38
1912: IFFALSE 1930
// tmp := tmp ^ Kapitsova ;
1914: LD_ADDR_VAR 0 5
1918: PUSH
1919: LD_VAR 0 5
1923: PUSH
1924: LD_EXP 38
1928: ADD
1929: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1930: LD_ADDR_EXP 39
1934: PUSH
1935: LD_STRING Lipshchin
1937: PPUSH
1938: LD_EXP 1
1942: NOT
1943: PPUSH
1944: LD_STRING 13a_
1946: PPUSH
1947: CALL 49546 0 3
1951: ST_TO_ADDR
// if Lipshchin then
1952: LD_EXP 39
1956: IFFALSE 1974
// tmp := tmp ^ Lipshchin ;
1958: LD_ADDR_VAR 0 5
1962: PUSH
1963: LD_VAR 0 5
1967: PUSH
1968: LD_EXP 39
1972: ADD
1973: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
1974: LD_ADDR_EXP 40
1978: PUSH
1979: LD_STRING Petrovova
1981: PPUSH
1982: LD_EXP 1
1986: NOT
1987: PPUSH
1988: LD_STRING 13a_
1990: PPUSH
1991: CALL 49546 0 3
1995: ST_TO_ADDR
// if Petrovova then
1996: LD_EXP 40
2000: IFFALSE 2018
// tmp := tmp ^ Petrovova ;
2002: LD_ADDR_VAR 0 5
2006: PUSH
2007: LD_VAR 0 5
2011: PUSH
2012: LD_EXP 40
2016: ADD
2017: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2018: LD_ADDR_EXP 41
2022: PUSH
2023: LD_STRING Kovalyuk
2025: PPUSH
2026: LD_EXP 1
2030: NOT
2031: PPUSH
2032: LD_STRING 13a_
2034: PPUSH
2035: CALL 49546 0 3
2039: ST_TO_ADDR
// if Kovalyuk then
2040: LD_EXP 41
2044: IFFALSE 2062
// tmp := tmp ^ Kovalyuk ;
2046: LD_ADDR_VAR 0 5
2050: PUSH
2051: LD_VAR 0 5
2055: PUSH
2056: LD_EXP 41
2060: ADD
2061: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2062: LD_ADDR_EXP 42
2066: PUSH
2067: LD_STRING Kuzmov
2069: PPUSH
2070: LD_EXP 1
2074: NOT
2075: PPUSH
2076: LD_STRING 13a_
2078: PPUSH
2079: CALL 49546 0 3
2083: ST_TO_ADDR
// if Kuzmov then
2084: LD_EXP 42
2088: IFFALSE 2106
// tmp := tmp ^ Kuzmov ;
2090: LD_ADDR_VAR 0 5
2094: PUSH
2095: LD_VAR 0 5
2099: PUSH
2100: LD_EXP 42
2104: ADD
2105: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2106: LD_ADDR_EXP 43
2110: PUSH
2111: LD_STRING Karamazov
2113: PPUSH
2114: LD_EXP 1
2118: NOT
2119: PPUSH
2120: LD_STRING 13a_
2122: PPUSH
2123: CALL 49546 0 3
2127: ST_TO_ADDR
// if Karamazov then
2128: LD_EXP 43
2132: IFFALSE 2150
// tmp := tmp ^ Karamazov ;
2134: LD_ADDR_VAR 0 5
2138: PUSH
2139: LD_VAR 0 5
2143: PUSH
2144: LD_EXP 43
2148: ADD
2149: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2150: LD_ADDR_EXP 45
2154: PUSH
2155: LD_STRING Belkov
2157: PPUSH
2158: LD_EXP 1
2162: NOT
2163: PPUSH
2164: LD_STRING 13a_
2166: PPUSH
2167: CALL 49546 0 3
2171: ST_TO_ADDR
// if Belkov then
2172: LD_EXP 45
2176: IFFALSE 2194
// tmp := tmp ^ Belkov ;
2178: LD_ADDR_VAR 0 5
2182: PUSH
2183: LD_VAR 0 5
2187: PUSH
2188: LD_EXP 45
2192: ADD
2193: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2194: LD_ADDR_EXP 46
2198: PUSH
2199: LD_STRING Gnyevko
2201: PPUSH
2202: LD_EXP 1
2206: NOT
2207: PPUSH
2208: LD_STRING 13a_
2210: PPUSH
2211: CALL 49546 0 3
2215: ST_TO_ADDR
// if Gnyevko then
2216: LD_EXP 46
2220: IFFALSE 2238
// tmp := tmp ^ Gnyevko ;
2222: LD_ADDR_VAR 0 5
2226: PUSH
2227: LD_VAR 0 5
2231: PUSH
2232: LD_EXP 46
2236: ADD
2237: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2238: LD_ADDR_EXP 29
2242: PUSH
2243: LD_STRING Coonie
2245: PPUSH
2246: CALL_OW 25
2250: ST_TO_ADDR
// if not Lisa then
2251: LD_EXP 14
2255: NOT
2256: IFFALSE 2302
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 14
2262: PUSH
2263: LD_STRING Lisa
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 49546 0 3
2279: ST_TO_ADDR
// if Lisa then
2280: LD_EXP 14
2284: IFFALSE 2302
// tmp := tmp ^ Lisa ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 14
2300: ADD
2301: ST_TO_ADDR
// end ; if not Donaldson then
2302: LD_EXP 15
2306: NOT
2307: IFFALSE 2353
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2309: LD_ADDR_EXP 15
2313: PUSH
2314: LD_STRING Donaldson
2316: PPUSH
2317: LD_EXP 1
2321: NOT
2322: PPUSH
2323: LD_STRING 13a_
2325: PPUSH
2326: CALL 49546 0 3
2330: ST_TO_ADDR
// if Donaldson then
2331: LD_EXP 15
2335: IFFALSE 2353
// tmp := tmp ^ Donaldson ;
2337: LD_ADDR_VAR 0 5
2341: PUSH
2342: LD_VAR 0 5
2346: PUSH
2347: LD_EXP 15
2351: ADD
2352: ST_TO_ADDR
// end ; if not Bobby then
2353: LD_EXP 16
2357: NOT
2358: IFFALSE 2404
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 16
2364: PUSH
2365: LD_STRING Bobby
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 49546 0 3
2381: ST_TO_ADDR
// if Bobby then
2382: LD_EXP 16
2386: IFFALSE 2404
// tmp := tmp ^ Bobby ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 16
2402: ADD
2403: ST_TO_ADDR
// end ; if not Cyrus then
2404: LD_EXP 17
2408: NOT
2409: IFFALSE 2455
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2411: LD_ADDR_EXP 17
2415: PUSH
2416: LD_STRING Cyrus
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_STRING 13a_
2427: PPUSH
2428: CALL 49546 0 3
2432: ST_TO_ADDR
// if Cyrus then
2433: LD_EXP 17
2437: IFFALSE 2455
// tmp := tmp ^ Cyrus ;
2439: LD_ADDR_VAR 0 5
2443: PUSH
2444: LD_VAR 0 5
2448: PUSH
2449: LD_EXP 17
2453: ADD
2454: ST_TO_ADDR
// end ; if not Brown then
2455: LD_EXP 19
2459: NOT
2460: IFFALSE 2506
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2462: LD_ADDR_EXP 19
2466: PUSH
2467: LD_STRING Brown
2469: PPUSH
2470: LD_EXP 1
2474: NOT
2475: PPUSH
2476: LD_STRING 13a_
2478: PPUSH
2479: CALL 49546 0 3
2483: ST_TO_ADDR
// if Brown then
2484: LD_EXP 19
2488: IFFALSE 2506
// tmp := tmp ^ Brown ;
2490: LD_ADDR_VAR 0 5
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: LD_EXP 19
2504: ADD
2505: ST_TO_ADDR
// end ; if not Gladstone then
2506: LD_EXP 20
2510: NOT
2511: IFFALSE 2557
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2513: LD_ADDR_EXP 20
2517: PUSH
2518: LD_STRING Gladstone
2520: PPUSH
2521: LD_EXP 1
2525: NOT
2526: PPUSH
2527: LD_STRING 13a_
2529: PPUSH
2530: CALL 49546 0 3
2534: ST_TO_ADDR
// if Gladstone then
2535: LD_EXP 20
2539: IFFALSE 2557
// tmp := tmp ^ Gladstone ;
2541: LD_ADDR_VAR 0 5
2545: PUSH
2546: LD_VAR 0 5
2550: PUSH
2551: LD_EXP 20
2555: ADD
2556: ST_TO_ADDR
// end ; if not Cornel then
2557: LD_EXP 22
2561: NOT
2562: IFFALSE 2608
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2564: LD_ADDR_EXP 22
2568: PUSH
2569: LD_STRING Cornel
2571: PPUSH
2572: LD_EXP 1
2576: NOT
2577: PPUSH
2578: LD_STRING 13a_
2580: PPUSH
2581: CALL 49546 0 3
2585: ST_TO_ADDR
// if Cornel then
2586: LD_EXP 22
2590: IFFALSE 2608
// tmp := tmp ^ Cornel ;
2592: LD_ADDR_VAR 0 5
2596: PUSH
2597: LD_VAR 0 5
2601: PUSH
2602: LD_EXP 22
2606: ADD
2607: ST_TO_ADDR
// end ; if not Houten then
2608: LD_EXP 21
2612: NOT
2613: IFFALSE 2659
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2615: LD_ADDR_EXP 21
2619: PUSH
2620: LD_STRING Houten
2622: PPUSH
2623: LD_EXP 1
2627: NOT
2628: PPUSH
2629: LD_STRING 13a_
2631: PPUSH
2632: CALL 49546 0 3
2636: ST_TO_ADDR
// if Houten then
2637: LD_EXP 21
2641: IFFALSE 2659
// tmp := tmp ^ Houten ;
2643: LD_ADDR_VAR 0 5
2647: PUSH
2648: LD_VAR 0 5
2652: PUSH
2653: LD_EXP 21
2657: ADD
2658: ST_TO_ADDR
// end ; if not Gary then
2659: LD_EXP 23
2663: NOT
2664: IFFALSE 2710
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2666: LD_ADDR_EXP 23
2670: PUSH
2671: LD_STRING Gary
2673: PPUSH
2674: LD_EXP 1
2678: NOT
2679: PPUSH
2680: LD_STRING 13a_
2682: PPUSH
2683: CALL 49546 0 3
2687: ST_TO_ADDR
// if Gary then
2688: LD_EXP 23
2692: IFFALSE 2710
// tmp := tmp ^ Gary ;
2694: LD_ADDR_VAR 0 5
2698: PUSH
2699: LD_VAR 0 5
2703: PUSH
2704: LD_EXP 23
2708: ADD
2709: ST_TO_ADDR
// end ; if not Kikuchi then
2710: LD_EXP 25
2714: NOT
2715: IFFALSE 2761
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2717: LD_ADDR_EXP 25
2721: PUSH
2722: LD_STRING Kikuchi
2724: PPUSH
2725: LD_EXP 1
2729: NOT
2730: PPUSH
2731: LD_STRING 13a_
2733: PPUSH
2734: CALL 49546 0 3
2738: ST_TO_ADDR
// if Kikuchi then
2739: LD_EXP 25
2743: IFFALSE 2761
// tmp := tmp ^ Kikuchi ;
2745: LD_ADDR_VAR 0 5
2749: PUSH
2750: LD_VAR 0 5
2754: PUSH
2755: LD_EXP 25
2759: ADD
2760: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2761: LD_ADDR_VAR 0 5
2765: PUSH
2766: LD_VAR 0 5
2770: PUSH
2771: LD_STRING 13a_others
2773: PPUSH
2774: CALL_OW 31
2778: UNION
2779: ST_TO_ADDR
// tmp := tmp diff 0 ;
2780: LD_ADDR_VAR 0 5
2784: PUSH
2785: LD_VAR 0 5
2789: PUSH
2790: LD_INT 0
2792: DIFF
2793: ST_TO_ADDR
// if tmp < 15 then
2794: LD_VAR 0 5
2798: PUSH
2799: LD_INT 15
2801: LESS
2802: IFFALSE 2890
// for i = 15 downto tmp do
2804: LD_ADDR_VAR 0 2
2808: PUSH
2809: DOUBLE
2810: LD_INT 15
2812: INC
2813: ST_TO_ADDR
2814: LD_VAR 0 5
2818: PUSH
2819: FOR_DOWNTO
2820: IFFALSE 2888
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2822: LD_ADDR_OWVAR 21
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 3
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 1
2839: PPUSH
2840: LD_INT 2
2842: PPUSH
2843: CALL_OW 12
2847: ARRAY
2848: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2849: LD_INT 0
2851: PPUSH
2852: LD_INT 1
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: CALL_OW 12
2862: PPUSH
2863: LD_INT 8
2865: PPUSH
2866: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2870: LD_ADDR_VAR 0 5
2874: PUSH
2875: LD_VAR 0 5
2879: PUSH
2880: CALL_OW 44
2884: ADD
2885: ST_TO_ADDR
// end ;
2886: GO 2819
2888: POP
2889: POP
// if not debug then
2890: LD_EXP 1
2894: NOT
2895: IFFALSE 3067
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2897: LD_ADDR_VAR 0 4
2901: PUSH
2902: LD_STRING 
2904: PPUSH
2905: LD_INT 15
2907: PUSH
2908: LD_INT 14
2910: PUSH
2911: LD_INT 13
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: LIST
2918: PUSH
2919: LD_OWVAR 67
2923: ARRAY
2924: PPUSH
2925: LD_INT 15
2927: PUSH
2928: LD_INT 14
2930: PUSH
2931: LD_INT 13
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: LIST
2938: PUSH
2939: LD_OWVAR 67
2943: ARRAY
2944: PPUSH
2945: LD_INT -6
2947: PUSH
2948: LD_EXP 12
2952: PUSH
2953: LD_EXP 44
2957: PUSH
2958: LD_EXP 13
2962: PUSH
2963: LD_EXP 27
2967: PUSH
2968: LD_EXP 18
2972: PUSH
2973: LD_EXP 30
2977: PUSH
2978: LD_INT -2
2980: PUSH
2981: LD_INT -3
2983: PUSH
2984: LD_INT -5
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: LIST
2997: LIST
2998: PUSH
2999: LD_VAR 0 5
3003: ADD
3004: PPUSH
3005: LD_INT 1
3007: PUSH
3008: LD_INT 4
3010: PUSH
3011: LD_INT 2
3013: PUSH
3014: LD_INT 1
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 5
3026: PUSH
3027: LD_INT 0
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: LIST
3037: PUSH
3038: LD_INT 9
3040: PUSH
3041: LD_INT 0
3043: PUSH
3044: LD_INT 3
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PPUSH
3060: CALL_OW 42
3064: ST_TO_ADDR
3065: GO 3146
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3067: LD_ADDR_VAR 0 4
3071: PUSH
3072: LD_EXP 32
3076: PUSH
3077: LD_EXP 33
3081: PUSH
3082: LD_EXP 34
3086: PUSH
3087: LD_EXP 35
3091: PUSH
3092: LD_EXP 36
3096: PUSH
3097: LD_EXP 37
3101: PUSH
3102: LD_EXP 38
3106: PUSH
3107: LD_EXP 39
3111: PUSH
3112: LD_EXP 40
3116: PUSH
3117: LD_EXP 41
3121: PUSH
3122: LD_EXP 42
3126: PUSH
3127: LD_EXP 43
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: ST_TO_ADDR
// uc_nation := 1 ;
3146: LD_ADDR_OWVAR 21
3150: PUSH
3151: LD_INT 1
3153: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3154: LD_INT 5
3156: PPUSH
3157: LD_INT 3
3159: PPUSH
3160: LD_INT 1
3162: PPUSH
3163: LD_INT 6
3165: PPUSH
3166: LD_INT 100
3168: PPUSH
3169: CALL 56512 0 5
// veh := CreateVehicle ;
3173: LD_ADDR_VAR 0 3
3177: PUSH
3178: CALL_OW 45
3182: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3183: LD_VAR 0 3
3187: PPUSH
3188: LD_INT 7
3190: NEG
3191: PPUSH
3192: CALL_OW 242
// SetDir ( veh , 3 ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: LD_INT 3
3203: PPUSH
3204: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3208: LD_VAR 0 3
3212: PPUSH
3213: LD_INT 31
3215: PPUSH
3216: LD_INT 0
3218: PPUSH
3219: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3223: LD_EXP 12
3227: PPUSH
3228: LD_VAR 0 3
3232: PPUSH
3233: CALL_OW 52
// uc_nation := 3 ;
3237: LD_ADDR_OWVAR 21
3241: PUSH
3242: LD_INT 3
3244: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3245: LD_INT 22
3247: PPUSH
3248: LD_INT 3
3250: PPUSH
3251: LD_INT 1
3253: PPUSH
3254: LD_INT 45
3256: PPUSH
3257: LD_INT 100
3259: PPUSH
3260: CALL 56512 0 5
// veh := CreateVehicle ;
3264: LD_ADDR_VAR 0 3
3268: PUSH
3269: CALL_OW 45
3273: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3274: LD_VAR 0 3
3278: PPUSH
3279: LD_INT 7
3281: NEG
3282: PPUSH
3283: CALL_OW 242
// SetDir ( veh , 3 ) ;
3287: LD_VAR 0 3
3291: PPUSH
3292: LD_INT 3
3294: PPUSH
3295: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3299: LD_VAR 0 3
3303: PPUSH
3304: LD_INT 31
3306: PPUSH
3307: LD_INT 0
3309: PPUSH
3310: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3314: LD_EXP 44
3318: PPUSH
3319: LD_VAR 0 3
3323: PPUSH
3324: CALL_OW 52
// for i in selected do
3328: LD_ADDR_VAR 0 2
3332: PUSH
3333: LD_VAR 0 4
3337: PUSH
3338: FOR_IN
3339: IFFALSE 3897
// begin uc_nation := GetNation ( i ) ;
3341: LD_ADDR_OWVAR 21
3345: PUSH
3346: LD_VAR 0 2
3350: PPUSH
3351: CALL_OW 248
3355: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3356: LD_VAR 0 2
3360: PUSH
3361: LD_EXP 14
3365: PUSH
3366: LD_EXP 15
3370: PUSH
3371: LD_EXP 17
3375: PUSH
3376: LD_EXP 16
3380: PUSH
3381: EMPTY
3382: LIST
3383: LIST
3384: LIST
3385: LIST
3386: IN
3387: IFFALSE 3410
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3389: LD_INT 5
3391: PPUSH
3392: LD_INT 3
3394: PPUSH
3395: LD_INT 1
3397: PPUSH
3398: LD_INT 6
3400: PPUSH
3401: LD_INT 100
3403: PPUSH
3404: CALL 56512 0 5
3408: GO 3844
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3410: LD_VAR 0 2
3414: PUSH
3415: LD_EXP 37
3419: PUSH
3420: LD_EXP 42
3424: PUSH
3425: LD_EXP 40
3429: PUSH
3430: LD_EXP 32
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: LIST
3439: LIST
3440: IN
3441: IFFALSE 3472
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3443: LD_INT 24
3445: PPUSH
3446: LD_INT 1
3448: PPUSH
3449: LD_INT 1
3451: PPUSH
3452: LD_INT 46
3454: PPUSH
3455: LD_INT 65
3457: PPUSH
3458: LD_INT 75
3460: PPUSH
3461: CALL_OW 12
3465: PPUSH
3466: CALL 56512 0 5
3470: GO 3844
// if i = Karamazov then
3472: LD_VAR 0 2
3476: PUSH
3477: LD_EXP 43
3481: EQUAL
3482: IFFALSE 3505
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3484: LD_INT 22
3486: PPUSH
3487: LD_INT 3
3489: PPUSH
3490: LD_INT 1
3492: PPUSH
3493: LD_INT 52
3495: PPUSH
3496: LD_INT 100
3498: PPUSH
3499: CALL 56512 0 5
3503: GO 3844
// if i = Brown then
3505: LD_VAR 0 2
3509: PUSH
3510: LD_EXP 19
3514: EQUAL
3515: IFFALSE 3538
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3517: LD_INT 3
3519: PPUSH
3520: LD_INT 3
3522: PPUSH
3523: LD_INT 1
3525: PPUSH
3526: LD_INT 13
3528: PPUSH
3529: LD_INT 100
3531: PPUSH
3532: CALL 56512 0 5
3536: GO 3844
// if uc_nation = nation_american then
3538: LD_OWVAR 21
3542: PUSH
3543: LD_INT 1
3545: EQUAL
3546: IFFALSE 3697
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3548: LD_INT 3
3550: PUSH
3551: LD_INT 5
3553: PUSH
3554: LD_INT 5
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: PUSH
3562: LD_OWVAR 21
3566: PUSH
3567: LD_INT 3
3569: MOD
3570: PUSH
3571: LD_INT 1
3573: PLUS
3574: ARRAY
3575: PPUSH
3576: LD_INT 1
3578: PUSH
3579: LD_INT 3
3581: PUSH
3582: LD_INT 1
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: LIST
3589: PUSH
3590: LD_OWVAR 21
3594: PUSH
3595: LD_INT 3
3597: MOD
3598: PUSH
3599: LD_INT 1
3601: PLUS
3602: ARRAY
3603: PPUSH
3604: LD_INT 1
3606: PPUSH
3607: LD_INT 11
3609: PUSH
3610: LD_INT 4
3612: PUSH
3613: LD_INT 5
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: LIST
3620: PUSH
3621: LD_INT 6
3623: PUSH
3624: LD_INT 7
3626: PUSH
3627: LD_INT 9
3629: PUSH
3630: EMPTY
3631: LIST
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 6
3637: PUSH
3638: LD_INT 9
3640: PUSH
3641: LD_INT 12
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: LIST
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: LIST
3653: PUSH
3654: LD_OWVAR 21
3658: PUSH
3659: LD_INT 3
3661: MOD
3662: PUSH
3663: LD_INT 1
3665: PLUS
3666: ARRAY
3667: PUSH
3668: LD_INT 1
3670: PPUSH
3671: LD_INT 3
3673: PPUSH
3674: CALL_OW 12
3678: ARRAY
3679: PPUSH
3680: LD_INT 65
3682: PPUSH
3683: LD_INT 75
3685: PPUSH
3686: CALL_OW 12
3690: PPUSH
3691: CALL 56512 0 5
// end else
3695: GO 3844
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3697: LD_INT 22
3699: PUSH
3700: LD_INT 23
3702: PUSH
3703: LD_INT 23
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: LIST
3710: PUSH
3711: LD_OWVAR 21
3715: PUSH
3716: LD_INT 3
3718: MOD
3719: PUSH
3720: LD_INT 1
3722: PLUS
3723: ARRAY
3724: PPUSH
3725: LD_INT 1
3727: PUSH
3728: LD_INT 3
3730: PUSH
3731: LD_INT 1
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: LIST
3738: PUSH
3739: LD_OWVAR 21
3743: PUSH
3744: LD_INT 3
3746: MOD
3747: PUSH
3748: LD_INT 1
3750: PLUS
3751: ARRAY
3752: PPUSH
3753: LD_INT 1
3755: PPUSH
3756: LD_INT 45
3758: PUSH
3759: LD_INT 43
3761: PUSH
3762: LD_INT 44
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: PUSH
3770: LD_INT 46
3772: PUSH
3773: LD_INT 45
3775: PUSH
3776: LD_INT 44
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: LIST
3783: PUSH
3784: LD_INT 46
3786: PUSH
3787: LD_INT 43
3789: PUSH
3790: LD_INT 45
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: LIST
3802: PUSH
3803: LD_OWVAR 21
3807: PUSH
3808: LD_INT 3
3810: MOD
3811: PUSH
3812: LD_INT 1
3814: PLUS
3815: ARRAY
3816: PUSH
3817: LD_INT 1
3819: PPUSH
3820: LD_INT 3
3822: PPUSH
3823: CALL_OW 12
3827: ARRAY
3828: PPUSH
3829: LD_INT 65
3831: PPUSH
3832: LD_INT 75
3834: PPUSH
3835: CALL_OW 12
3839: PPUSH
3840: CALL 56512 0 5
// end ; veh := CreateVehicle ;
3844: LD_ADDR_VAR 0 3
3848: PUSH
3849: CALL_OW 45
3853: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3854: LD_VAR 0 3
3858: PPUSH
3859: LD_INT 3
3861: PPUSH
3862: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3866: LD_VAR 0 3
3870: PPUSH
3871: LD_INT 30
3873: PPUSH
3874: LD_INT 0
3876: PPUSH
3877: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
3881: LD_VAR 0 2
3885: PPUSH
3886: LD_VAR 0 3
3890: PPUSH
3891: CALL_OW 52
// end ;
3895: GO 3338
3897: POP
3898: POP
// if artifactArCaptured then
3899: LD_EXP 6
3903: IFFALSE 3989
// begin uc_nation := nation_american ;
3905: LD_ADDR_OWVAR 21
3909: PUSH
3910: LD_INT 1
3912: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
3913: LD_INT 3
3915: PPUSH
3916: LD_INT 3
3918: PPUSH
3919: LD_INT 3
3921: PPUSH
3922: LD_INT 12
3924: PPUSH
3925: LD_INT 100
3927: PPUSH
3928: CALL 56512 0 5
// veh := CreateVehicle ;
3932: LD_ADDR_VAR 0 3
3936: PUSH
3937: CALL_OW 45
3941: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3942: LD_VAR 0 3
3946: PPUSH
3947: LD_INT 3
3949: PPUSH
3950: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
3954: LD_VAR 0 3
3958: PPUSH
3959: LD_INT 198
3961: PPUSH
3962: LD_INT 22
3964: PPUSH
3965: LD_INT 0
3967: PPUSH
3968: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
3972: LD_VAR 0 3
3976: PPUSH
3977: LD_INT 4
3979: PPUSH
3980: LD_INT 50
3982: PPUSH
3983: CALL_OW 290
// end else
3987: GO 4008
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
3989: LD_INT 4
3991: PPUSH
3992: LD_INT 267
3994: PPUSH
3995: LD_INT 226
3997: PPUSH
3998: LD_INT 5
4000: PPUSH
4001: LD_INT 0
4003: PPUSH
4004: CALL_OW 58
// end ; uc_nation := nation_american ;
4008: LD_ADDR_OWVAR 21
4012: PUSH
4013: LD_INT 1
4015: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4016: LD_INT 3
4018: PPUSH
4019: LD_INT 3
4021: PPUSH
4022: LD_INT 3
4024: PPUSH
4025: LD_INT 12
4027: PPUSH
4028: LD_INT 100
4030: PPUSH
4031: CALL 56512 0 5
// veh := CreateVehicle ;
4035: LD_ADDR_VAR 0 3
4039: PUSH
4040: CALL_OW 45
4044: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4045: LD_VAR 0 3
4049: PPUSH
4050: LD_INT 3
4052: PPUSH
4053: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4057: LD_VAR 0 3
4061: PPUSH
4062: LD_INT 218
4064: PPUSH
4065: LD_INT 23
4067: PPUSH
4068: LD_INT 0
4070: PPUSH
4071: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4075: LD_VAR 0 3
4079: PPUSH
4080: LD_INT 4
4082: PPUSH
4083: LD_INT 30
4085: PPUSH
4086: CALL_OW 290
// uc_nation := nation_russian ;
4090: LD_ADDR_OWVAR 21
4094: PUSH
4095: LD_INT 3
4097: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4098: LD_INT 22
4100: PPUSH
4101: LD_INT 3
4103: PPUSH
4104: LD_INT 3
4106: PPUSH
4107: LD_INT 51
4109: PPUSH
4110: LD_INT 100
4112: PPUSH
4113: CALL 56512 0 5
// veh := CreateVehicle ;
4117: LD_ADDR_VAR 0 3
4121: PUSH
4122: CALL_OW 45
4126: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4127: LD_VAR 0 3
4131: PPUSH
4132: LD_INT 3
4134: PPUSH
4135: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4139: LD_VAR 0 3
4143: PPUSH
4144: LD_INT 214
4146: PPUSH
4147: LD_INT 20
4149: PPUSH
4150: LD_INT 0
4152: PPUSH
4153: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4157: LD_VAR 0 3
4161: PPUSH
4162: LD_INT 4
4164: PPUSH
4165: LD_INT 40
4167: PPUSH
4168: CALL_OW 290
// end ; end_of_file
4172: LD_VAR 0 1
4176: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4177: LD_INT 0
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
4188: PPUSH
// InitHc ;
4189: CALL_OW 19
// uc_side := 1 ;
4193: LD_ADDR_OWVAR 20
4197: PUSH
4198: LD_INT 1
4200: ST_TO_ADDR
// uc_nation := 1 ;
4201: LD_ADDR_OWVAR 21
4205: PUSH
4206: LD_INT 1
4208: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4209: LD_INT 387
4211: PPUSH
4212: CALL_OW 274
4216: PPUSH
4217: LD_INT 1
4219: PPUSH
4220: LD_INT 25500
4222: PPUSH
4223: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4227: LD_INT 387
4229: PPUSH
4230: CALL_OW 274
4234: PPUSH
4235: LD_INT 2
4237: PPUSH
4238: LD_INT 4000
4240: PPUSH
4241: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4245: LD_INT 387
4247: PPUSH
4248: CALL_OW 274
4252: PPUSH
4253: LD_INT 3
4255: PPUSH
4256: LD_INT 50
4258: PPUSH
4259: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4263: LD_INT 476
4265: PPUSH
4266: CALL_OW 274
4270: PPUSH
4271: LD_INT 1
4273: PPUSH
4274: LD_INT 7500
4276: PPUSH
4277: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4281: LD_INT 476
4283: PPUSH
4284: CALL_OW 274
4288: PPUSH
4289: LD_INT 2
4291: PPUSH
4292: LD_INT 4000
4294: PPUSH
4295: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4299: LD_INT 476
4301: PPUSH
4302: CALL_OW 274
4306: PPUSH
4307: LD_INT 3
4309: PPUSH
4310: LD_INT 10
4312: PPUSH
4313: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4317: LD_ADDR_EXP 47
4321: PUSH
4322: LD_STRING Powell
4324: PPUSH
4325: CALL_OW 25
4329: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
4330: LD_EXP 47
4334: PPUSH
4335: LD_INT 57
4337: PPUSH
4338: LD_INT 94
4340: PPUSH
4341: LD_INT 0
4343: PPUSH
4344: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
4348: LD_EXP 47
4352: PPUSH
4353: LD_INT 58
4355: PPUSH
4356: LD_INT 94
4358: PPUSH
4359: CALL_OW 118
// tmp := [ ] ;
4363: LD_ADDR_VAR 0 6
4367: PUSH
4368: EMPTY
4369: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4370: LD_ADDR_EXP 14
4374: PUSH
4375: LD_STRING Lisa
4377: PPUSH
4378: LD_EXP 1
4382: NOT
4383: PPUSH
4384: LD_STRING 12p_
4386: PPUSH
4387: CALL 49546 0 3
4391: ST_TO_ADDR
// if Lisa then
4392: LD_EXP 14
4396: IFFALSE 4414
// tmp := tmp ^ Lisa ;
4398: LD_ADDR_VAR 0 6
4402: PUSH
4403: LD_VAR 0 6
4407: PUSH
4408: LD_EXP 14
4412: ADD
4413: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4414: LD_ADDR_EXP 15
4418: PUSH
4419: LD_STRING Donaldson
4421: PPUSH
4422: LD_EXP 1
4426: NOT
4427: PPUSH
4428: LD_STRING 12p_
4430: PPUSH
4431: CALL 49546 0 3
4435: ST_TO_ADDR
// if Donaldson then
4436: LD_EXP 15
4440: IFFALSE 4458
// tmp := tmp ^ Donaldson ;
4442: LD_ADDR_VAR 0 6
4446: PUSH
4447: LD_VAR 0 6
4451: PUSH
4452: LD_EXP 15
4456: ADD
4457: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4458: LD_ADDR_EXP 16
4462: PUSH
4463: LD_STRING Bobby
4465: PPUSH
4466: LD_EXP 1
4470: NOT
4471: PPUSH
4472: LD_STRING 12p_
4474: PPUSH
4475: CALL 49546 0 3
4479: ST_TO_ADDR
// if Bobby then
4480: LD_EXP 16
4484: IFFALSE 4502
// tmp := tmp ^ Bobby ;
4486: LD_ADDR_VAR 0 6
4490: PUSH
4491: LD_VAR 0 6
4495: PUSH
4496: LD_EXP 16
4500: ADD
4501: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4502: LD_ADDR_EXP 17
4506: PUSH
4507: LD_STRING Cyrus
4509: PPUSH
4510: LD_EXP 1
4514: NOT
4515: PPUSH
4516: LD_STRING 12p_
4518: PPUSH
4519: CALL 49546 0 3
4523: ST_TO_ADDR
// if Cyrus then
4524: LD_EXP 17
4528: IFFALSE 4546
// tmp := tmp ^ Cyrus ;
4530: LD_ADDR_VAR 0 6
4534: PUSH
4535: LD_VAR 0 6
4539: PUSH
4540: LD_EXP 17
4544: ADD
4545: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4546: LD_ADDR_EXP 19
4550: PUSH
4551: LD_STRING Brown
4553: PPUSH
4554: LD_EXP 1
4558: NOT
4559: PPUSH
4560: LD_STRING 12p_
4562: PPUSH
4563: CALL 49546 0 3
4567: ST_TO_ADDR
// if Brown then
4568: LD_EXP 19
4572: IFFALSE 4590
// tmp := tmp ^ Brown ;
4574: LD_ADDR_VAR 0 6
4578: PUSH
4579: LD_VAR 0 6
4583: PUSH
4584: LD_EXP 19
4588: ADD
4589: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4590: LD_ADDR_EXP 20
4594: PUSH
4595: LD_STRING Gladstone
4597: PPUSH
4598: LD_EXP 1
4602: NOT
4603: PPUSH
4604: LD_STRING 12p_
4606: PPUSH
4607: CALL 49546 0 3
4611: ST_TO_ADDR
// if Gladstone then
4612: LD_EXP 20
4616: IFFALSE 4634
// tmp := tmp ^ Gladstone ;
4618: LD_ADDR_VAR 0 6
4622: PUSH
4623: LD_VAR 0 6
4627: PUSH
4628: LD_EXP 20
4632: ADD
4633: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4634: LD_ADDR_EXP 21
4638: PUSH
4639: LD_STRING Houten
4641: PPUSH
4642: LD_EXP 1
4646: NOT
4647: PPUSH
4648: LD_STRING 12p_
4650: PPUSH
4651: CALL 49546 0 3
4655: ST_TO_ADDR
// if Houten then
4656: LD_EXP 21
4660: IFFALSE 4678
// tmp := tmp ^ Houten ;
4662: LD_ADDR_VAR 0 6
4666: PUSH
4667: LD_VAR 0 6
4671: PUSH
4672: LD_EXP 21
4676: ADD
4677: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
4678: LD_ADDR_EXP 22
4682: PUSH
4683: LD_STRING Cornel
4685: PPUSH
4686: LD_EXP 1
4690: NOT
4691: PPUSH
4692: LD_STRING 12p_
4694: PPUSH
4695: CALL 49546 0 3
4699: ST_TO_ADDR
// if Cornel then
4700: LD_EXP 22
4704: IFFALSE 4722
// tmp := tmp ^ Cornel ;
4706: LD_ADDR_VAR 0 6
4710: PUSH
4711: LD_VAR 0 6
4715: PUSH
4716: LD_EXP 22
4720: ADD
4721: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
4722: LD_ADDR_EXP 23
4726: PUSH
4727: LD_STRING Gary
4729: PPUSH
4730: LD_EXP 1
4734: NOT
4735: PPUSH
4736: LD_STRING 12p_
4738: PPUSH
4739: CALL 49546 0 3
4743: ST_TO_ADDR
// if Gary then
4744: LD_EXP 23
4748: IFFALSE 4766
// tmp := tmp ^ Gary ;
4750: LD_ADDR_VAR 0 6
4754: PUSH
4755: LD_VAR 0 6
4759: PUSH
4760: LD_EXP 23
4764: ADD
4765: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
4766: LD_ADDR_EXP 25
4770: PUSH
4771: LD_STRING Kikuchi
4773: PPUSH
4774: LD_EXP 1
4778: NOT
4779: PPUSH
4780: LD_STRING 12p_
4782: PPUSH
4783: CALL 49546 0 3
4787: ST_TO_ADDR
// if Kikuchi then
4788: LD_EXP 25
4792: IFFALSE 4810
// tmp := tmp ^ Kikuchi ;
4794: LD_ADDR_VAR 0 6
4798: PUSH
4799: LD_VAR 0 6
4803: PUSH
4804: LD_EXP 25
4808: ADD
4809: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
4810: LD_ADDR_VAR 0 6
4814: PUSH
4815: LD_VAR 0 6
4819: PUSH
4820: LD_STRING 12p_others
4822: PPUSH
4823: CALL_OW 31
4827: UNION
4828: ST_TO_ADDR
// if tmp < 36 then
4829: LD_VAR 0 6
4833: PUSH
4834: LD_INT 36
4836: LESS
4837: IFFALSE 4904
// for i = 1 to 36 - tmp do
4839: LD_ADDR_VAR 0 2
4843: PUSH
4844: DOUBLE
4845: LD_INT 1
4847: DEC
4848: ST_TO_ADDR
4849: LD_INT 36
4851: PUSH
4852: LD_VAR 0 6
4856: MINUS
4857: PUSH
4858: FOR_TO
4859: IFFALSE 4902
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
4861: LD_INT 1
4863: PPUSH
4864: LD_VAR 0 2
4868: PUSH
4869: LD_INT 4
4871: MOD
4872: PUSH
4873: LD_INT 1
4875: PLUS
4876: PPUSH
4877: LD_INT 10
4879: PPUSH
4880: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
4884: LD_ADDR_VAR 0 6
4888: PUSH
4889: LD_VAR 0 6
4893: PUSH
4894: CALL_OW 44
4898: ADD
4899: ST_TO_ADDR
// end ;
4900: GO 4858
4902: POP
4903: POP
// for i in tmp do
4904: LD_ADDR_VAR 0 2
4908: PUSH
4909: LD_VAR 0 6
4913: PUSH
4914: FOR_IN
4915: IFFALSE 4940
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
4917: LD_VAR 0 2
4921: PPUSH
4922: LD_INT 62
4924: PPUSH
4925: LD_INT 93
4927: PPUSH
4928: LD_INT 9
4930: PPUSH
4931: LD_INT 0
4933: PPUSH
4934: CALL_OW 50
4938: GO 4914
4940: POP
4941: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
4942: LD_ADDR_EXP 74
4946: PUSH
4947: LD_EXP 74
4951: PPUSH
4952: LD_INT 4
4954: PPUSH
4955: LD_INT 22
4957: PUSH
4958: LD_INT 1
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PPUSH
4965: CALL_OW 69
4969: PPUSH
4970: CALL_OW 1
4974: ST_TO_ADDR
// uc_side := 0 ;
4975: LD_ADDR_OWVAR 20
4979: PUSH
4980: LD_INT 0
4982: ST_TO_ADDR
// uc_nation := 0 ;
4983: LD_ADDR_OWVAR 21
4987: PUSH
4988: LD_INT 0
4990: ST_TO_ADDR
// for i = 1 to 4 do
4991: LD_ADDR_VAR 0 2
4995: PUSH
4996: DOUBLE
4997: LD_INT 1
4999: DEC
5000: ST_TO_ADDR
5001: LD_INT 4
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5036
// begin InitHc ;
5007: CALL_OW 19
// hc_class := class_apeman ;
5011: LD_ADDR_OWVAR 28
5015: PUSH
5016: LD_INT 12
5018: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5019: CALL_OW 44
5023: PPUSH
5024: LD_INT 11
5026: PPUSH
5027: LD_INT 0
5029: PPUSH
5030: CALL_OW 49
// end ;
5034: GO 5004
5036: POP
5037: POP
// end ;
5038: LD_VAR 0 1
5042: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5043: LD_EXP 4
5047: NOT
5048: PUSH
5049: LD_INT 4
5051: PPUSH
5052: LD_INT 1
5054: PPUSH
5055: CALL 44754 0 2
5059: NOT
5060: AND
5061: IFFALSE 5833
5063: GO 5065
5065: DISABLE
5066: LD_INT 0
5068: PPUSH
5069: PPUSH
5070: PPUSH
// begin enable ;
5071: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5072: LD_INT 22
5074: PUSH
5075: LD_INT 1
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: PUSH
5082: LD_INT 23
5084: PUSH
5085: LD_INT 1
5087: PUSH
5088: EMPTY
5089: LIST
5090: LIST
5091: PUSH
5092: LD_INT 30
5094: PUSH
5095: LD_INT 3
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: LIST
5106: PPUSH
5107: CALL_OW 69
5111: NOT
5112: IFFALSE 5116
// exit ;
5114: GO 5833
// if Prob ( 40 ) then
5116: LD_INT 40
5118: PPUSH
5119: CALL_OW 13
5123: IFFALSE 5250
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5125: LD_INT 4
5127: PPUSH
5128: LD_INT 5
5130: PUSH
5131: LD_INT 1
5133: PUSH
5134: LD_INT 2
5136: PUSH
5137: LD_INT 7
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: LIST
5144: LIST
5145: PUSH
5146: LD_INT 5
5148: PUSH
5149: LD_INT 1
5151: PUSH
5152: LD_INT 2
5154: PUSH
5155: LD_INT 7
5157: PUSH
5158: EMPTY
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: PUSH
5164: LD_INT 5
5166: PUSH
5167: LD_INT 1
5169: PUSH
5170: LD_INT 2
5172: PUSH
5173: LD_INT 7
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: LIST
5180: LIST
5181: PUSH
5182: LD_INT 5
5184: PUSH
5185: LD_INT 1
5187: PUSH
5188: LD_INT 2
5190: PUSH
5191: LD_INT 6
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: PUSH
5200: LD_INT 5
5202: PUSH
5203: LD_INT 1
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: LD_INT 6
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: LIST
5216: LIST
5217: PUSH
5218: LD_INT 5
5220: PUSH
5221: LD_INT 1
5223: PUSH
5224: LD_INT 2
5226: PUSH
5227: LD_INT 6
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: PPUSH
5244: CALL 43336 0 2
// end else
5248: GO 5373
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5250: LD_INT 4
5252: PPUSH
5253: LD_INT 5
5255: PUSH
5256: LD_INT 1
5258: PUSH
5259: LD_INT 2
5261: PUSH
5262: LD_INT 7
5264: PUSH
5265: EMPTY
5266: LIST
5267: LIST
5268: LIST
5269: LIST
5270: PUSH
5271: LD_INT 5
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: LD_INT 2
5279: PUSH
5280: LD_INT 9
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: LIST
5287: LIST
5288: PUSH
5289: LD_INT 5
5291: PUSH
5292: LD_INT 1
5294: PUSH
5295: LD_INT 2
5297: PUSH
5298: LD_INT 9
5300: PUSH
5301: EMPTY
5302: LIST
5303: LIST
5304: LIST
5305: LIST
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 1
5312: PUSH
5313: LD_INT 2
5315: PUSH
5316: LD_INT 6
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: PUSH
5325: LD_INT 5
5327: PUSH
5328: LD_INT 1
5330: PUSH
5331: LD_INT 2
5333: PUSH
5334: LD_INT 6
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 5
5345: PUSH
5346: LD_INT 1
5348: PUSH
5349: LD_INT 2
5351: PUSH
5352: LD_INT 6
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: LIST
5359: LIST
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: LIST
5365: LIST
5366: LIST
5367: LIST
5368: PPUSH
5369: CALL 43336 0 2
// end ; repeat wait ( 0 0$1 ) ;
5373: LD_INT 35
5375: PPUSH
5376: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5380: LD_INT 4
5382: PPUSH
5383: LD_INT 1
5385: PPUSH
5386: CALL 44754 0 2
5390: PUSH
5391: LD_INT 6
5393: GREATEREQUAL
5394: IFFALSE 5373
// wait ( 0 0$30 ) ;
5396: LD_INT 1050
5398: PPUSH
5399: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5403: LD_ADDR_VAR 0 2
5407: PUSH
5408: LD_INT 4
5410: PPUSH
5411: LD_INT 1
5413: PPUSH
5414: CALL 44754 0 2
5418: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5419: LD_ADDR_EXP 93
5423: PUSH
5424: LD_EXP 93
5428: PPUSH
5429: LD_INT 4
5431: PPUSH
5432: LD_EXP 93
5436: PUSH
5437: LD_INT 4
5439: ARRAY
5440: PUSH
5441: LD_VAR 0 2
5445: DIFF
5446: PPUSH
5447: CALL_OW 1
5451: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5452: LD_ADDR_VAR 0 3
5456: PUSH
5457: LD_INT 0
5459: PPUSH
5460: LD_INT 2
5462: PPUSH
5463: CALL_OW 12
5467: ST_TO_ADDR
// if target then
5468: LD_VAR 0 3
5472: IFFALSE 5600
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5474: LD_ADDR_VAR 0 2
5478: PUSH
5479: LD_VAR 0 2
5483: PPUSH
5484: LD_INT 24
5486: PUSH
5487: LD_INT 250
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: PPUSH
5494: CALL_OW 72
5498: ST_TO_ADDR
// for i in tmp do
5499: LD_ADDR_VAR 0 1
5503: PUSH
5504: LD_VAR 0 2
5508: PUSH
5509: FOR_IN
5510: IFFALSE 5550
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5512: LD_VAR 0 1
5516: PPUSH
5517: LD_INT 114
5519: PPUSH
5520: LD_INT 108
5522: PPUSH
5523: CALL_OW 297
5527: PUSH
5528: LD_INT 9
5530: GREATER
5531: IFFALSE 5548
// ComMoveXY ( i , 114 , 108 ) ;
5533: LD_VAR 0 1
5537: PPUSH
5538: LD_INT 114
5540: PPUSH
5541: LD_INT 108
5543: PPUSH
5544: CALL_OW 111
5548: GO 5509
5550: POP
5551: POP
// wait ( 0 0$1 ) ;
5552: LD_INT 35
5554: PPUSH
5555: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5559: LD_VAR 0 2
5563: PPUSH
5564: LD_INT 92
5566: PUSH
5567: LD_INT 114
5569: PUSH
5570: LD_INT 108
5572: PUSH
5573: LD_INT 9
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: LIST
5580: LIST
5581: PPUSH
5582: CALL_OW 72
5586: PUSH
5587: LD_VAR 0 2
5591: PUSH
5592: LD_INT 1
5594: MINUS
5595: GREATEREQUAL
5596: IFFALSE 5474
// end else
5598: GO 5724
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5600: LD_ADDR_VAR 0 2
5604: PUSH
5605: LD_VAR 0 2
5609: PPUSH
5610: LD_INT 24
5612: PUSH
5613: LD_INT 250
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 72
5624: ST_TO_ADDR
// for i in tmp do
5625: LD_ADDR_VAR 0 1
5629: PUSH
5630: LD_VAR 0 2
5634: PUSH
5635: FOR_IN
5636: IFFALSE 5676
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5638: LD_VAR 0 1
5642: PPUSH
5643: LD_INT 129
5645: PPUSH
5646: LD_INT 139
5648: PPUSH
5649: CALL_OW 297
5653: PUSH
5654: LD_INT 9
5656: GREATER
5657: IFFALSE 5674
// ComMoveXY ( i , 129 , 139 ) ;
5659: LD_VAR 0 1
5663: PPUSH
5664: LD_INT 129
5666: PPUSH
5667: LD_INT 139
5669: PPUSH
5670: CALL_OW 111
5674: GO 5635
5676: POP
5677: POP
// wait ( 0 0$1 ) ;
5678: LD_INT 35
5680: PPUSH
5681: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
5685: LD_VAR 0 2
5689: PPUSH
5690: LD_INT 92
5692: PUSH
5693: LD_INT 129
5695: PUSH
5696: LD_INT 139
5698: PUSH
5699: LD_INT 9
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: PPUSH
5708: CALL_OW 72
5712: PUSH
5713: LD_VAR 0 2
5717: PUSH
5718: LD_INT 1
5720: MINUS
5721: GREATEREQUAL
5722: IFFALSE 5600
// end ; repeat wait ( 0 0$1 ) ;
5724: LD_INT 35
5726: PPUSH
5727: CALL_OW 67
// for i in tmp do
5731: LD_ADDR_VAR 0 1
5735: PUSH
5736: LD_VAR 0 2
5740: PUSH
5741: FOR_IN
5742: IFFALSE 5824
// begin if GetLives ( i ) > 251 then
5744: LD_VAR 0 1
5748: PPUSH
5749: CALL_OW 256
5753: PUSH
5754: LD_INT 251
5756: GREATER
5757: IFFALSE 5795
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
5759: LD_VAR 0 1
5763: PPUSH
5764: LD_INT 81
5766: PUSH
5767: LD_INT 1
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 69
5778: PPUSH
5779: LD_VAR 0 1
5783: PPUSH
5784: CALL_OW 74
5788: PPUSH
5789: CALL_OW 115
5793: GO 5822
// if IsDead ( i ) then
5795: LD_VAR 0 1
5799: PPUSH
5800: CALL_OW 301
5804: IFFALSE 5822
// tmp := tmp diff i ;
5806: LD_ADDR_VAR 0 2
5810: PUSH
5811: LD_VAR 0 2
5815: PUSH
5816: LD_VAR 0 1
5820: DIFF
5821: ST_TO_ADDR
// end ;
5822: GO 5741
5824: POP
5825: POP
// until not tmp ;
5826: LD_VAR 0 2
5830: NOT
5831: IFFALSE 5724
// end ;
5833: PPOPN 3
5835: END
// every 30 30$00 trigger not americanDestroyed do
5836: LD_EXP 4
5840: NOT
5841: IFFALSE 5906
5843: GO 5845
5845: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
5846: LD_INT 63000
5848: PUSH
5849: LD_INT 42000
5851: PUSH
5852: LD_INT 21000
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: LIST
5859: PUSH
5860: LD_OWVAR 67
5864: ARRAY
5865: PPUSH
5866: CALL_OW 67
// if americanDestroyed then
5870: LD_EXP 4
5874: IFFALSE 5878
// exit ;
5876: GO 5906
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
5878: LD_INT 4
5880: PPUSH
5881: LD_INT 5
5883: PUSH
5884: LD_INT 3
5886: PUSH
5887: LD_INT 1
5889: PUSH
5890: LD_INT 8
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: EMPTY
5900: LIST
5901: PPUSH
5902: CALL 43336 0 2
// end ; end_of_file
5906: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
5907: LD_INT 0
5909: PPUSH
5910: PPUSH
5911: PPUSH
5912: PPUSH
5913: PPUSH
// side := 2 ;
5914: LD_ADDR_VAR 0 5
5918: PUSH
5919: LD_INT 2
5921: ST_TO_ADDR
// InitHc ;
5922: CALL_OW 19
// uc_side := side ;
5926: LD_ADDR_OWVAR 20
5930: PUSH
5931: LD_VAR 0 5
5935: ST_TO_ADDR
// uc_nation := 2 ;
5936: LD_ADDR_OWVAR 21
5940: PUSH
5941: LD_INT 2
5943: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
5944: LD_ADDR_VAR 0 4
5948: PUSH
5949: LD_INT 22
5951: PUSH
5952: LD_VAR 0 5
5956: PUSH
5957: EMPTY
5958: LIST
5959: LIST
5960: PUSH
5961: LD_INT 30
5963: PUSH
5964: LD_INT 32
5966: PUSH
5967: EMPTY
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 58
5973: PUSH
5974: EMPTY
5975: LIST
5976: PUSH
5977: EMPTY
5978: LIST
5979: LIST
5980: LIST
5981: PPUSH
5982: CALL_OW 69
5986: ST_TO_ADDR
// for i = 1 to 10 do
5987: LD_ADDR_VAR 0 2
5991: PUSH
5992: DOUBLE
5993: LD_INT 1
5995: DEC
5996: ST_TO_ADDR
5997: LD_INT 10
5999: PUSH
6000: FOR_TO
6001: IFFALSE 6073
// begin uc_nation := nation_nature ;
6003: LD_ADDR_OWVAR 21
6007: PUSH
6008: LD_INT 0
6010: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6011: LD_ADDR_OWVAR 28
6015: PUSH
6016: LD_INT 15
6018: ST_TO_ADDR
// hc_gallery :=  ;
6019: LD_ADDR_OWVAR 33
6023: PUSH
6024: LD_STRING 
6026: ST_TO_ADDR
// hc_name :=  ;
6027: LD_ADDR_OWVAR 26
6031: PUSH
6032: LD_STRING 
6034: ST_TO_ADDR
// un := CreateHuman ;
6035: LD_ADDR_VAR 0 3
6039: PUSH
6040: CALL_OW 44
6044: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6045: LD_VAR 0 3
6049: PPUSH
6050: LD_VAR 0 4
6054: PUSH
6055: LD_VAR 0 4
6059: PUSH
6060: LD_VAR 0 2
6064: MINUS
6065: ARRAY
6066: PPUSH
6067: CALL_OW 52
// end ;
6071: GO 6000
6073: POP
6074: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6075: LD_INT 503
6077: PPUSH
6078: LD_INT 27
6080: PPUSH
6081: LD_STRING 
6083: PPUSH
6084: LD_INT 8
6086: PUSH
6087: LD_INT 9
6089: PUSH
6090: LD_INT 10
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: LIST
6097: PUSH
6098: LD_OWVAR 67
6102: ARRAY
6103: PPUSH
6104: LD_INT 3000
6106: PUSH
6107: LD_INT 500
6109: PUSH
6110: LD_INT 150
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: PPUSH
6118: LD_INT 16
6120: PUSH
6121: LD_INT 6
6123: PUSH
6124: LD_INT 6
6126: PUSH
6127: LD_INT 6
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: LIST
6134: LIST
6135: PPUSH
6136: CALL 59921 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6140: LD_ADDR_EXP 74
6144: PUSH
6145: LD_EXP 74
6149: PPUSH
6150: LD_INT 1
6152: PPUSH
6153: LD_INT 22
6155: PUSH
6156: LD_VAR 0 5
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 23
6167: PUSH
6168: LD_INT 2
6170: PUSH
6171: EMPTY
6172: LIST
6173: LIST
6174: PUSH
6175: LD_INT 3
6177: PUSH
6178: LD_INT 21
6180: PUSH
6181: LD_INT 2
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: LIST
6196: PPUSH
6197: CALL_OW 69
6201: PPUSH
6202: CALL_OW 1
6206: ST_TO_ADDR
// end ;
6207: LD_VAR 0 1
6211: RET
// export Omar ; export function PrepareOmarAli ; begin
6212: LD_INT 0
6214: PPUSH
// uc_side := 5 ;
6215: LD_ADDR_OWVAR 20
6219: PUSH
6220: LD_INT 5
6222: ST_TO_ADDR
// uc_nation := 2 ;
6223: LD_ADDR_OWVAR 21
6227: PUSH
6228: LD_INT 2
6230: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6231: LD_ADDR_EXP 48
6235: PUSH
6236: LD_STRING Omar
6238: PPUSH
6239: CALL_OW 25
6243: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6244: LD_EXP 48
6248: PPUSH
6249: LD_INT 330
6251: PPUSH
6252: LD_INT 244
6254: PPUSH
6255: LD_INT 0
6257: PPUSH
6258: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6262: LD_EXP 48
6266: PPUSH
6267: LD_INT 22
6269: PUSH
6270: LD_INT 7
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: PPUSH
6277: CALL_OW 69
6281: PPUSH
6282: LD_EXP 48
6286: PPUSH
6287: CALL_OW 74
6291: PPUSH
6292: CALL_OW 112
// end ; end_of_file
6296: LD_VAR 0 1
6300: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6301: LD_INT 0
6303: PPUSH
6304: PPUSH
6305: PPUSH
6306: PPUSH
6307: PPUSH
// side := 8 ;
6308: LD_ADDR_VAR 0 3
6312: PUSH
6313: LD_INT 8
6315: ST_TO_ADDR
// InitHc ;
6316: CALL_OW 19
// uc_side := side ;
6320: LD_ADDR_OWVAR 20
6324: PUSH
6325: LD_VAR 0 3
6329: ST_TO_ADDR
// uc_nation := 2 ;
6330: LD_ADDR_OWVAR 21
6334: PUSH
6335: LD_INT 2
6337: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6338: LD_ADDR_VAR 0 2
6342: PUSH
6343: LD_INT 22
6345: PUSH
6346: LD_VAR 0 3
6350: PUSH
6351: EMPTY
6352: LIST
6353: LIST
6354: PUSH
6355: LD_INT 21
6357: PUSH
6358: LD_INT 3
6360: PUSH
6361: EMPTY
6362: LIST
6363: LIST
6364: PUSH
6365: EMPTY
6366: LIST
6367: LIST
6368: PPUSH
6369: CALL_OW 69
6373: PUSH
6374: FOR_IN
6375: IFFALSE 6391
// SetBLevel ( i , 10 ) ;
6377: LD_VAR 0 2
6381: PPUSH
6382: LD_INT 10
6384: PPUSH
6385: CALL_OW 241
6389: GO 6374
6391: POP
6392: POP
// Schulz := NewCharacter ( Schulz ) ;
6393: LD_ADDR_EXP 49
6397: PUSH
6398: LD_STRING Schulz
6400: PPUSH
6401: CALL_OW 25
6405: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6406: LD_ADDR_EXP 50
6410: PUSH
6411: LD_STRING Kozlov
6413: PPUSH
6414: LD_INT 0
6416: PPUSH
6417: LD_STRING 
6419: PPUSH
6420: CALL 49546 0 3
6424: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6425: LD_EXP 50
6429: PPUSH
6430: LD_INT 22
6432: PUSH
6433: LD_INT 8
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: LD_INT 23
6442: PUSH
6443: LD_INT 3
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: PUSH
6450: LD_INT 30
6452: PUSH
6453: LD_INT 8
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: LIST
6464: PPUSH
6465: CALL_OW 69
6469: PUSH
6470: LD_INT 1
6472: ARRAY
6473: PPUSH
6474: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6478: LD_EXP 50
6482: PPUSH
6483: LD_INT 3
6485: PPUSH
6486: LD_INT 10
6488: PPUSH
6489: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6493: LD_ADDR_VAR 0 5
6497: PUSH
6498: LD_INT 22
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 30
6512: PUSH
6513: LD_INT 32
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: PUSH
6520: LD_INT 58
6522: PUSH
6523: EMPTY
6524: LIST
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: PPUSH
6531: CALL_OW 69
6535: ST_TO_ADDR
// for i = 1 to 10 do
6536: LD_ADDR_VAR 0 2
6540: PUSH
6541: DOUBLE
6542: LD_INT 1
6544: DEC
6545: ST_TO_ADDR
6546: LD_INT 10
6548: PUSH
6549: FOR_TO
6550: IFFALSE 6622
// begin uc_nation := nation_nature ;
6552: LD_ADDR_OWVAR 21
6556: PUSH
6557: LD_INT 0
6559: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6560: LD_ADDR_OWVAR 28
6564: PUSH
6565: LD_INT 15
6567: ST_TO_ADDR
// hc_gallery :=  ;
6568: LD_ADDR_OWVAR 33
6572: PUSH
6573: LD_STRING 
6575: ST_TO_ADDR
// hc_name :=  ;
6576: LD_ADDR_OWVAR 26
6580: PUSH
6581: LD_STRING 
6583: ST_TO_ADDR
// un := CreateHuman ;
6584: LD_ADDR_VAR 0 4
6588: PUSH
6589: CALL_OW 44
6593: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6594: LD_VAR 0 4
6598: PPUSH
6599: LD_VAR 0 5
6603: PUSH
6604: LD_VAR 0 5
6608: PUSH
6609: LD_VAR 0 2
6613: MINUS
6614: ARRAY
6615: PPUSH
6616: CALL_OW 52
// end ;
6620: GO 6549
6622: POP
6623: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6624: LD_INT 324
6626: PPUSH
6627: LD_INT 3
6629: PPUSH
6630: LD_STRING 
6632: PPUSH
6633: LD_INT 8
6635: PUSH
6636: LD_INT 9
6638: PUSH
6639: LD_INT 10
6641: PUSH
6642: EMPTY
6643: LIST
6644: LIST
6645: LIST
6646: PUSH
6647: LD_OWVAR 67
6651: ARRAY
6652: PPUSH
6653: LD_INT 3000
6655: PUSH
6656: LD_INT 500
6658: PUSH
6659: LD_INT 150
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: LIST
6666: PPUSH
6667: LD_INT 16
6669: PUSH
6670: LD_INT 6
6672: PUSH
6673: LD_INT 6
6675: PUSH
6676: LD_INT 8
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: PPUSH
6685: CALL 59921 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
6689: LD_ADDR_EXP 74
6693: PUSH
6694: LD_EXP 74
6698: PPUSH
6699: LD_INT 3
6701: PPUSH
6702: LD_INT 22
6704: PUSH
6705: LD_VAR 0 3
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PUSH
6714: LD_INT 23
6716: PUSH
6717: LD_INT 2
6719: PUSH
6720: EMPTY
6721: LIST
6722: LIST
6723: PUSH
6724: LD_INT 3
6726: PUSH
6727: LD_INT 21
6729: PUSH
6730: LD_INT 2
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PUSH
6737: EMPTY
6738: LIST
6739: LIST
6740: PUSH
6741: EMPTY
6742: LIST
6743: LIST
6744: LIST
6745: PPUSH
6746: CALL_OW 69
6750: PUSH
6751: LD_EXP 49
6755: DIFF
6756: PPUSH
6757: CALL_OW 1
6761: ST_TO_ADDR
// end ;
6762: LD_VAR 0 1
6766: RET
// export function BuildKozlovBomb ; begin
6767: LD_INT 0
6769: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
6770: LD_INT 332
6772: PPUSH
6773: CALL_OW 302
6777: NOT
6778: PUSH
6779: LD_INT 336
6781: PPUSH
6782: CALL_OW 302
6786: NOT
6787: OR
6788: IFFALSE 6792
// exit ;
6790: GO 6889
// ComChangeProfession ( Kozlov , 4 ) ;
6792: LD_EXP 50
6796: PPUSH
6797: LD_INT 4
6799: PPUSH
6800: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
6804: LD_INT 336
6806: PPUSH
6807: LD_INT 25
6809: PPUSH
6810: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
6814: LD_INT 35
6816: PPUSH
6817: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
6821: LD_INT 25
6823: PPUSH
6824: LD_INT 8
6826: PPUSH
6827: CALL_OW 321
6831: PUSH
6832: LD_INT 2
6834: EQUAL
6835: IFFALSE 6814
// ComExitBuilding ( Kozlov ) ;
6837: LD_EXP 50
6841: PPUSH
6842: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
6846: LD_EXP 50
6850: PPUSH
6851: LD_INT 332
6853: PPUSH
6854: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
6858: LD_EXP 50
6862: PPUSH
6863: LD_INT 3
6865: PPUSH
6866: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
6870: LD_INT 332
6872: PPUSH
6873: LD_INT 23
6875: PPUSH
6876: LD_INT 3
6878: PPUSH
6879: LD_INT 1
6881: PPUSH
6882: LD_INT 48
6884: PPUSH
6885: CALL_OW 125
// end ;
6889: LD_VAR 0 1
6893: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
6894: LD_EXP 3
6898: NOT
6899: PUSH
6900: LD_INT 3
6902: PPUSH
6903: LD_INT 1
6905: PPUSH
6906: CALL 44754 0 2
6910: NOT
6911: AND
6912: IFFALSE 7752
6914: GO 6916
6916: DISABLE
6917: LD_INT 0
6919: PPUSH
6920: PPUSH
6921: PPUSH
// begin enable ;
6922: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6923: LD_INT 22
6925: PUSH
6926: LD_INT 8
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: PUSH
6933: LD_INT 23
6935: PUSH
6936: LD_INT 2
6938: PUSH
6939: EMPTY
6940: LIST
6941: LIST
6942: PUSH
6943: LD_INT 30
6945: PUSH
6946: LD_INT 3
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: PUSH
6953: EMPTY
6954: LIST
6955: LIST
6956: LIST
6957: PPUSH
6958: CALL_OW 69
6962: NOT
6963: IFFALSE 6967
// exit ;
6965: GO 7752
// if Prob ( 40 ) then
6967: LD_INT 40
6969: PPUSH
6970: CALL_OW 13
6974: IFFALSE 7101
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6976: LD_INT 3
6978: PPUSH
6979: LD_INT 14
6981: PUSH
6982: LD_INT 1
6984: PUSH
6985: LD_INT 2
6987: PUSH
6988: LD_INT 28
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: LIST
6995: LIST
6996: PUSH
6997: LD_INT 14
6999: PUSH
7000: LD_INT 1
7002: PUSH
7003: LD_INT 2
7005: PUSH
7006: LD_INT 28
7008: PUSH
7009: EMPTY
7010: LIST
7011: LIST
7012: LIST
7013: LIST
7014: PUSH
7015: LD_INT 14
7017: PUSH
7018: LD_INT 1
7020: PUSH
7021: LD_INT 2
7023: PUSH
7024: LD_INT 28
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 14
7035: PUSH
7036: LD_INT 1
7038: PUSH
7039: LD_INT 2
7041: PUSH
7042: LD_INT 28
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: LIST
7049: LIST
7050: PUSH
7051: LD_INT 14
7053: PUSH
7054: LD_INT 1
7056: PUSH
7057: LD_INT 2
7059: PUSH
7060: LD_INT 28
7062: PUSH
7063: EMPTY
7064: LIST
7065: LIST
7066: LIST
7067: LIST
7068: PUSH
7069: LD_INT 14
7071: PUSH
7072: LD_INT 1
7074: PUSH
7075: LD_INT 2
7077: PUSH
7078: LD_INT 26
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: LIST
7094: PPUSH
7095: CALL 43336 0 2
// end else
7099: GO 7292
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7101: LD_INT 3
7103: PPUSH
7104: LD_INT 14
7106: PUSH
7107: LD_INT 1
7109: PUSH
7110: LD_INT 2
7112: PUSH
7113: LD_INT 27
7115: PUSH
7116: LD_INT 26
7118: PUSH
7119: LD_INT 26
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: LIST
7126: PUSH
7127: LD_OWVAR 67
7131: ARRAY
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: LIST
7137: LIST
7138: PUSH
7139: LD_INT 14
7141: PUSH
7142: LD_INT 1
7144: PUSH
7145: LD_INT 2
7147: PUSH
7148: LD_INT 27
7150: PUSH
7151: LD_INT 26
7153: PUSH
7154: LD_INT 26
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: LIST
7161: PUSH
7162: LD_OWVAR 67
7166: ARRAY
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: PUSH
7174: LD_INT 14
7176: PUSH
7177: LD_INT 1
7179: PUSH
7180: LD_INT 2
7182: PUSH
7183: LD_INT 26
7185: PUSH
7186: LD_INT 26
7188: PUSH
7189: LD_INT 29
7191: PUSH
7192: EMPTY
7193: LIST
7194: LIST
7195: LIST
7196: PUSH
7197: LD_OWVAR 67
7201: ARRAY
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: LIST
7207: LIST
7208: PUSH
7209: LD_INT 13
7211: PUSH
7212: LD_INT 1
7214: PUSH
7215: LD_INT 2
7217: PUSH
7218: LD_INT 26
7220: PUSH
7221: LD_INT 29
7223: PUSH
7224: LD_INT 29
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: LIST
7231: PUSH
7232: LD_OWVAR 67
7236: ARRAY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 13
7246: PUSH
7247: LD_INT 1
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: LD_INT 29
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_INT 14
7264: PUSH
7265: LD_INT 1
7267: PUSH
7268: LD_INT 2
7270: PUSH
7271: LD_INT 26
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: LIST
7278: LIST
7279: PUSH
7280: EMPTY
7281: LIST
7282: LIST
7283: LIST
7284: LIST
7285: LIST
7286: LIST
7287: PPUSH
7288: CALL 43336 0 2
// end ; repeat wait ( 0 0$1 ) ;
7292: LD_INT 35
7294: PPUSH
7295: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7299: LD_INT 3
7301: PPUSH
7302: LD_INT 1
7304: PPUSH
7305: CALL 44754 0 2
7309: PUSH
7310: LD_INT 6
7312: GREATEREQUAL
7313: IFFALSE 7292
// wait ( 0 0$30 ) ;
7315: LD_INT 1050
7317: PPUSH
7318: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7322: LD_ADDR_VAR 0 2
7326: PUSH
7327: LD_INT 3
7329: PPUSH
7330: LD_INT 1
7332: PPUSH
7333: CALL 44754 0 2
7337: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7338: LD_ADDR_EXP 93
7342: PUSH
7343: LD_EXP 93
7347: PPUSH
7348: LD_INT 3
7350: PPUSH
7351: LD_EXP 93
7355: PUSH
7356: LD_INT 3
7358: ARRAY
7359: PUSH
7360: LD_VAR 0 2
7364: DIFF
7365: PPUSH
7366: CALL_OW 1
7370: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7371: LD_ADDR_VAR 0 3
7375: PUSH
7376: LD_INT 0
7378: PPUSH
7379: LD_INT 2
7381: PPUSH
7382: CALL_OW 12
7386: ST_TO_ADDR
// if target then
7387: LD_VAR 0 3
7391: IFFALSE 7519
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7393: LD_ADDR_VAR 0 2
7397: PUSH
7398: LD_VAR 0 2
7402: PPUSH
7403: LD_INT 24
7405: PUSH
7406: LD_INT 250
7408: PUSH
7409: EMPTY
7410: LIST
7411: LIST
7412: PPUSH
7413: CALL_OW 72
7417: ST_TO_ADDR
// for i in tmp do
7418: LD_ADDR_VAR 0 1
7422: PUSH
7423: LD_VAR 0 2
7427: PUSH
7428: FOR_IN
7429: IFFALSE 7469
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7431: LD_VAR 0 1
7435: PPUSH
7436: LD_INT 89
7438: PPUSH
7439: LD_INT 71
7441: PPUSH
7442: CALL_OW 297
7446: PUSH
7447: LD_INT 9
7449: GREATER
7450: IFFALSE 7467
// ComMoveXY ( i , 89 , 71 ) ;
7452: LD_VAR 0 1
7456: PPUSH
7457: LD_INT 89
7459: PPUSH
7460: LD_INT 71
7462: PPUSH
7463: CALL_OW 111
7467: GO 7428
7469: POP
7470: POP
// wait ( 0 0$1 ) ;
7471: LD_INT 35
7473: PPUSH
7474: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7478: LD_VAR 0 2
7482: PPUSH
7483: LD_INT 92
7485: PUSH
7486: LD_INT 89
7488: PUSH
7489: LD_INT 71
7491: PUSH
7492: LD_INT 9
7494: PUSH
7495: EMPTY
7496: LIST
7497: LIST
7498: LIST
7499: LIST
7500: PPUSH
7501: CALL_OW 72
7505: PUSH
7506: LD_VAR 0 2
7510: PUSH
7511: LD_INT 1
7513: MINUS
7514: GREATEREQUAL
7515: IFFALSE 7393
// end else
7517: GO 7643
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7519: LD_ADDR_VAR 0 2
7523: PUSH
7524: LD_VAR 0 2
7528: PPUSH
7529: LD_INT 24
7531: PUSH
7532: LD_INT 250
7534: PUSH
7535: EMPTY
7536: LIST
7537: LIST
7538: PPUSH
7539: CALL_OW 72
7543: ST_TO_ADDR
// for i in tmp do
7544: LD_ADDR_VAR 0 1
7548: PUSH
7549: LD_VAR 0 2
7553: PUSH
7554: FOR_IN
7555: IFFALSE 7595
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7557: LD_VAR 0 1
7561: PPUSH
7562: LD_INT 147
7564: PPUSH
7565: LD_INT 4
7567: PPUSH
7568: CALL_OW 297
7572: PUSH
7573: LD_INT 9
7575: GREATER
7576: IFFALSE 7593
// ComMoveXY ( i , 147 , 4 ) ;
7578: LD_VAR 0 1
7582: PPUSH
7583: LD_INT 147
7585: PPUSH
7586: LD_INT 4
7588: PPUSH
7589: CALL_OW 111
7593: GO 7554
7595: POP
7596: POP
// wait ( 0 0$1 ) ;
7597: LD_INT 35
7599: PPUSH
7600: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7604: LD_VAR 0 2
7608: PPUSH
7609: LD_INT 92
7611: PUSH
7612: LD_INT 147
7614: PUSH
7615: LD_INT 4
7617: PUSH
7618: LD_INT 9
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: PPUSH
7627: CALL_OW 72
7631: PUSH
7632: LD_VAR 0 2
7636: PUSH
7637: LD_INT 1
7639: MINUS
7640: GREATEREQUAL
7641: IFFALSE 7519
// end ; repeat wait ( 0 0$1 ) ;
7643: LD_INT 35
7645: PPUSH
7646: CALL_OW 67
// for i in tmp do
7650: LD_ADDR_VAR 0 1
7654: PUSH
7655: LD_VAR 0 2
7659: PUSH
7660: FOR_IN
7661: IFFALSE 7743
// begin if GetLives ( i ) > 251 then
7663: LD_VAR 0 1
7667: PPUSH
7668: CALL_OW 256
7672: PUSH
7673: LD_INT 251
7675: GREATER
7676: IFFALSE 7714
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
7678: LD_VAR 0 1
7682: PPUSH
7683: LD_INT 81
7685: PUSH
7686: LD_INT 8
7688: PUSH
7689: EMPTY
7690: LIST
7691: LIST
7692: PPUSH
7693: CALL_OW 69
7697: PPUSH
7698: LD_VAR 0 1
7702: PPUSH
7703: CALL_OW 74
7707: PPUSH
7708: CALL_OW 115
7712: GO 7741
// if IsDead ( i ) then
7714: LD_VAR 0 1
7718: PPUSH
7719: CALL_OW 301
7723: IFFALSE 7741
// tmp := tmp diff i ;
7725: LD_ADDR_VAR 0 2
7729: PUSH
7730: LD_VAR 0 2
7734: PUSH
7735: LD_VAR 0 1
7739: DIFF
7740: ST_TO_ADDR
// end ;
7741: GO 7660
7743: POP
7744: POP
// until not tmp ;
7745: LD_VAR 0 2
7749: NOT
7750: IFFALSE 7643
// end ;
7752: PPOPN 3
7754: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
7755: LD_EXP 50
7759: PPUSH
7760: CALL_OW 302
7764: PUSH
7765: LD_EXP 3
7769: NOT
7770: AND
7771: IFFALSE 7780
7773: GO 7775
7775: DISABLE
// BuildKozlovBomb ;
7776: CALL 6767 0 0
7780: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
7781: LD_INT 22
7783: PUSH
7784: LD_INT 8
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: PUSH
7791: LD_INT 34
7793: PUSH
7794: LD_INT 48
7796: PUSH
7797: EMPTY
7798: LIST
7799: LIST
7800: PUSH
7801: EMPTY
7802: LIST
7803: LIST
7804: PPUSH
7805: CALL_OW 69
7809: IFFALSE 7857
7811: GO 7813
7813: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
7814: LD_INT 22
7816: PUSH
7817: LD_INT 8
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: LD_INT 34
7826: PUSH
7827: LD_INT 48
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PUSH
7834: EMPTY
7835: LIST
7836: LIST
7837: PPUSH
7838: CALL_OW 69
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PPUSH
7847: LD_INT 173
7849: PPUSH
7850: LD_INT 96
7852: PPUSH
7853: CALL_OW 116
// end ; end_of_file
7857: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7858: LD_INT 0
7860: PPUSH
7861: PPUSH
7862: PPUSH
7863: PPUSH
7864: PPUSH
7865: PPUSH
7866: PPUSH
7867: PPUSH
7868: PPUSH
// side := 3 ;
7869: LD_ADDR_VAR 0 6
7873: PUSH
7874: LD_INT 3
7876: ST_TO_ADDR
// InitHc ;
7877: CALL_OW 19
// uc_side := side ;
7881: LD_ADDR_OWVAR 20
7885: PUSH
7886: LD_VAR 0 6
7890: ST_TO_ADDR
// uc_nation := 3 ;
7891: LD_ADDR_OWVAR 21
7895: PUSH
7896: LD_INT 3
7898: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7899: LD_ADDR_VAR 0 2
7903: PUSH
7904: LD_INT 22
7906: PUSH
7907: LD_VAR 0 6
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PUSH
7916: LD_INT 21
7918: PUSH
7919: LD_INT 3
7921: PUSH
7922: EMPTY
7923: LIST
7924: LIST
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 69
7934: PUSH
7935: FOR_IN
7936: IFFALSE 7952
// SetBLevel ( i , 10 ) ;
7938: LD_VAR 0 2
7942: PPUSH
7943: LD_INT 10
7945: PPUSH
7946: CALL_OW 241
7950: GO 7935
7952: POP
7953: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7954: LD_ADDR_VAR 0 9
7958: PUSH
7959: LD_INT 22
7961: PUSH
7962: LD_VAR 0 6
7966: PUSH
7967: EMPTY
7968: LIST
7969: LIST
7970: PUSH
7971: LD_INT 30
7973: PUSH
7974: LD_INT 34
7976: PUSH
7977: EMPTY
7978: LIST
7979: LIST
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PPUSH
7985: CALL_OW 69
7989: ST_TO_ADDR
// if teleport then
7990: LD_VAR 0 9
7994: IFFALSE 8015
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7996: LD_VAR 0 9
8000: PUSH
8001: LD_INT 1
8003: ARRAY
8004: PPUSH
8005: LD_INT 123
8007: PPUSH
8008: LD_INT 122
8010: PPUSH
8011: CALL_OW 243
// hc_importance := 0 ;
8015: LD_ADDR_OWVAR 32
8019: PUSH
8020: LD_INT 0
8022: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8023: LD_ADDR_EXP 51
8027: PUSH
8028: LD_STRING Platonov
8030: PPUSH
8031: CALL_OW 25
8035: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8036: LD_ADDR_EXP 52
8040: PUSH
8041: LD_STRING Yakotich
8043: PPUSH
8044: CALL_OW 25
8048: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8049: LD_ADDR_EXP 53
8053: PUSH
8054: LD_STRING Gleb
8056: PPUSH
8057: CALL_OW 25
8061: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8062: LD_STRING 03_Cornel
8064: PPUSH
8065: CALL_OW 28
8069: IFFALSE 8117
// begin Bierezov := NewCharacter ( Mikhail ) ;
8071: LD_ADDR_EXP 54
8075: PUSH
8076: LD_STRING Mikhail
8078: PPUSH
8079: CALL_OW 25
8083: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8084: LD_EXP 54
8088: PPUSH
8089: LD_INT 197
8091: PPUSH
8092: LD_INT 111
8094: PPUSH
8095: LD_INT 9
8097: PPUSH
8098: LD_INT 0
8100: PPUSH
8101: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8105: LD_EXP 54
8109: PPUSH
8110: LD_INT 3
8112: PPUSH
8113: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8117: LD_EXP 51
8121: PPUSH
8122: LD_INT 126
8124: PPUSH
8125: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8129: LD_EXP 52
8133: PPUSH
8134: LD_INT 197
8136: PPUSH
8137: LD_INT 111
8139: PPUSH
8140: LD_INT 9
8142: PPUSH
8143: LD_INT 0
8145: PPUSH
8146: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8150: LD_EXP 53
8154: PPUSH
8155: LD_INT 197
8157: PPUSH
8158: LD_INT 111
8160: PPUSH
8161: LD_INT 9
8163: PPUSH
8164: LD_INT 0
8166: PPUSH
8167: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8171: LD_ADDR_VAR 0 5
8175: PUSH
8176: LD_INT 126
8178: PPUSH
8179: LD_INT 2
8181: PPUSH
8182: LD_STRING zhukov
8184: PPUSH
8185: LD_INT 9
8187: PUSH
8188: LD_INT 10
8190: PUSH
8191: LD_INT 10
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: LIST
8198: PUSH
8199: LD_OWVAR 67
8203: ARRAY
8204: PPUSH
8205: LD_INT 90000
8207: PUSH
8208: LD_INT 1000
8210: PUSH
8211: LD_INT 300
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: LIST
8218: PPUSH
8219: LD_INT 21
8221: PUSH
8222: LD_INT 8
8224: PUSH
8225: LD_INT 13
8227: PUSH
8228: LD_INT 8
8230: PUSH
8231: EMPTY
8232: LIST
8233: LIST
8234: LIST
8235: LIST
8236: PPUSH
8237: CALL 59921 0 6
8241: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8242: LD_ADDR_VAR 0 4
8246: PUSH
8247: LD_INT 267
8249: PPUSH
8250: CALL_OW 274
8254: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8255: LD_VAR 0 4
8259: PPUSH
8260: LD_INT 1
8262: PPUSH
8263: LD_INT 5000
8265: PPUSH
8266: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8270: LD_VAR 0 4
8274: PPUSH
8275: LD_INT 2
8277: PPUSH
8278: LD_INT 200
8280: PPUSH
8281: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8285: LD_VAR 0 4
8289: PPUSH
8290: LD_INT 3
8292: PPUSH
8293: LD_INT 200
8295: PPUSH
8296: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8300: LD_ADDR_EXP 74
8304: PUSH
8305: LD_EXP 74
8309: PPUSH
8310: LD_INT 2
8312: PPUSH
8313: LD_VAR 0 5
8317: PUSH
8318: LD_INT 22
8320: PUSH
8321: LD_VAR 0 6
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PUSH
8330: LD_INT 3
8332: PUSH
8333: LD_INT 21
8335: PUSH
8336: LD_INT 2
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PUSH
8343: EMPTY
8344: LIST
8345: LIST
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: PPUSH
8351: CALL_OW 69
8355: UNION
8356: PUSH
8357: LD_EXP 51
8361: DIFF
8362: PPUSH
8363: CALL_OW 1
8367: ST_TO_ADDR
// behemoths := [ ] ;
8368: LD_ADDR_EXP 55
8372: PUSH
8373: EMPTY
8374: ST_TO_ADDR
// behemothBuilders := [ ] ;
8375: LD_ADDR_EXP 56
8379: PUSH
8380: EMPTY
8381: ST_TO_ADDR
// j := 3 ;
8382: LD_ADDR_VAR 0 3
8386: PUSH
8387: LD_INT 3
8389: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8390: LD_ADDR_VAR 0 2
8394: PUSH
8395: LD_INT 22
8397: PUSH
8398: LD_INT 3
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 25
8407: PUSH
8408: LD_INT 3
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PPUSH
8419: CALL_OW 69
8423: PUSH
8424: FOR_IN
8425: IFFALSE 8475
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8427: LD_ADDR_EXP 56
8431: PUSH
8432: LD_EXP 56
8436: PPUSH
8437: LD_VAR 0 2
8441: PPUSH
8442: CALL 92257 0 2
8446: ST_TO_ADDR
// j := j - 1 ;
8447: LD_ADDR_VAR 0 3
8451: PUSH
8452: LD_VAR 0 3
8456: PUSH
8457: LD_INT 1
8459: MINUS
8460: ST_TO_ADDR
// if j = 0 then
8461: LD_VAR 0 3
8465: PUSH
8466: LD_INT 0
8468: EQUAL
8469: IFFALSE 8473
// break ;
8471: GO 8475
// end ;
8473: GO 8424
8475: POP
8476: POP
// end ;
8477: LD_VAR 0 1
8481: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8482: LD_INT 0
8484: PPUSH
8485: PPUSH
8486: PPUSH
8487: PPUSH
8488: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8489: LD_ADDR_VAR 0 4
8493: PUSH
8494: LD_INT 209
8496: PUSH
8497: LD_INT 149
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: PUSH
8504: LD_INT 219
8506: PUSH
8507: LD_INT 154
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: LD_INT 223
8516: PUSH
8517: LD_INT 149
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PUSH
8524: LD_INT 232
8526: PUSH
8527: LD_INT 155
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: LIST
8539: ST_TO_ADDR
// if not behemothBuilders then
8540: LD_EXP 56
8544: NOT
8545: IFFALSE 8549
// exit ;
8547: GO 8653
// j := 1 ;
8549: LD_ADDR_VAR 0 3
8553: PUSH
8554: LD_INT 1
8556: ST_TO_ADDR
// for i in behemothBuilders do
8557: LD_ADDR_VAR 0 2
8561: PUSH
8562: LD_EXP 56
8566: PUSH
8567: FOR_IN
8568: IFFALSE 8651
// begin if IsInUnit ( i ) then
8570: LD_VAR 0 2
8574: PPUSH
8575: CALL_OW 310
8579: IFFALSE 8590
// ComExitBuilding ( i ) ;
8581: LD_VAR 0 2
8585: PPUSH
8586: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8590: LD_VAR 0 2
8594: PPUSH
8595: LD_INT 37
8597: PPUSH
8598: LD_VAR 0 4
8602: PUSH
8603: LD_VAR 0 3
8607: ARRAY
8608: PUSH
8609: LD_INT 1
8611: ARRAY
8612: PPUSH
8613: LD_VAR 0 4
8617: PUSH
8618: LD_VAR 0 3
8622: ARRAY
8623: PUSH
8624: LD_INT 2
8626: ARRAY
8627: PPUSH
8628: LD_INT 0
8630: PPUSH
8631: CALL_OW 230
// j := j + 1 ;
8635: LD_ADDR_VAR 0 3
8639: PUSH
8640: LD_VAR 0 3
8644: PUSH
8645: LD_INT 1
8647: PLUS
8648: ST_TO_ADDR
// end ;
8649: GO 8567
8651: POP
8652: POP
// end ;
8653: LD_VAR 0 1
8657: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8658: LD_INT 3
8660: PPUSH
8661: CALL 92305 0 1
8665: PUSH
8666: LD_INT 22
8668: PUSH
8669: LD_INT 3
8671: PUSH
8672: EMPTY
8673: LIST
8674: LIST
8675: PUSH
8676: LD_INT 30
8678: PUSH
8679: LD_INT 37
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PPUSH
8690: CALL_OW 69
8694: NOT
8695: AND
8696: IFFALSE 8882
8698: GO 8700
8700: DISABLE
8701: LD_INT 0
8703: PPUSH
8704: PPUSH
// begin enable ;
8705: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8706: LD_ADDR_VAR 0 2
8710: PUSH
8711: LD_INT 3
8713: PPUSH
8714: CALL 92305 0 1
8718: ST_TO_ADDR
// for i in tmp do
8719: LD_ADDR_VAR 0 1
8723: PUSH
8724: LD_VAR 0 2
8728: PUSH
8729: FOR_IN
8730: IFFALSE 8880
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8732: LD_VAR 0 1
8736: PPUSH
8737: LD_INT 7
8739: PPUSH
8740: CALL_OW 308
8744: PUSH
8745: LD_VAR 0 1
8749: PPUSH
8750: CALL_OW 110
8754: PUSH
8755: LD_INT 2
8757: EQUAL
8758: NOT
8759: AND
8760: IFFALSE 8774
// SetTag ( i , 2 ) ;
8762: LD_VAR 0 1
8766: PPUSH
8767: LD_INT 2
8769: PPUSH
8770: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8774: LD_INT 81
8776: PUSH
8777: LD_INT 3
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: PUSH
8784: LD_INT 91
8786: PUSH
8787: LD_VAR 0 1
8791: PUSH
8792: LD_INT 12
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: LIST
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PPUSH
8804: CALL_OW 69
8808: NOT
8809: PUSH
8810: LD_VAR 0 1
8814: PPUSH
8815: CALL_OW 110
8819: PUSH
8820: LD_INT 2
8822: EQUAL
8823: NOT
8824: AND
8825: IFFALSE 8844
// ComAgressiveMove ( i , 64 , 93 ) else
8827: LD_VAR 0 1
8831: PPUSH
8832: LD_INT 64
8834: PPUSH
8835: LD_INT 93
8837: PPUSH
8838: CALL_OW 114
8842: GO 8878
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8844: LD_VAR 0 1
8848: PPUSH
8849: LD_INT 81
8851: PUSH
8852: LD_INT 3
8854: PUSH
8855: EMPTY
8856: LIST
8857: LIST
8858: PPUSH
8859: CALL_OW 69
8863: PPUSH
8864: LD_VAR 0 1
8868: PPUSH
8869: CALL_OW 74
8873: PPUSH
8874: CALL_OW 115
// end ;
8878: GO 8729
8880: POP
8881: POP
// end ;
8882: PPOPN 2
8884: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
8885: LD_EXP 2
8889: NOT
8890: PUSH
8891: LD_INT 2
8893: PPUSH
8894: LD_INT 1
8896: PPUSH
8897: CALL 44754 0 2
8901: NOT
8902: AND
8903: IFFALSE 9823
8905: GO 8907
8907: DISABLE
8908: LD_INT 0
8910: PPUSH
8911: PPUSH
8912: PPUSH
8913: PPUSH
// begin enable ;
8914: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8915: LD_INT 22
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 30
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: PPUSH
8939: CALL_OW 69
8943: NOT
8944: IFFALSE 8948
// exit ;
8946: GO 9823
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
8948: LD_ADDR_VAR 0 4
8952: PUSH
8953: LD_INT 22
8955: PUSH
8956: LD_INT 3
8958: PUSH
8959: EMPTY
8960: LIST
8961: LIST
8962: PUSH
8963: LD_INT 30
8965: PUSH
8966: LD_INT 34
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: PPUSH
8977: CALL_OW 69
8981: ST_TO_ADDR
// if Prob ( 40 ) then
8982: LD_INT 40
8984: PPUSH
8985: CALL_OW 13
8989: IFFALSE 9116
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
8991: LD_INT 2
8993: PPUSH
8994: LD_INT 22
8996: PUSH
8997: LD_INT 3
8999: PUSH
9000: LD_INT 3
9002: PUSH
9003: LD_INT 49
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: LIST
9010: LIST
9011: PUSH
9012: LD_INT 22
9014: PUSH
9015: LD_INT 3
9017: PUSH
9018: LD_INT 3
9020: PUSH
9021: LD_INT 49
9023: PUSH
9024: EMPTY
9025: LIST
9026: LIST
9027: LIST
9028: LIST
9029: PUSH
9030: LD_INT 22
9032: PUSH
9033: LD_INT 3
9035: PUSH
9036: LD_INT 3
9038: PUSH
9039: LD_INT 49
9041: PUSH
9042: EMPTY
9043: LIST
9044: LIST
9045: LIST
9046: LIST
9047: PUSH
9048: LD_INT 24
9050: PUSH
9051: LD_INT 3
9053: PUSH
9054: LD_INT 3
9056: PUSH
9057: LD_INT 46
9059: PUSH
9060: EMPTY
9061: LIST
9062: LIST
9063: LIST
9064: LIST
9065: PUSH
9066: LD_INT 24
9068: PUSH
9069: LD_INT 3
9071: PUSH
9072: LD_INT 3
9074: PUSH
9075: LD_INT 46
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: LIST
9082: LIST
9083: PUSH
9084: LD_INT 24
9086: PUSH
9087: LD_INT 3
9089: PUSH
9090: LD_INT 3
9092: PUSH
9093: LD_INT 46
9095: PUSH
9096: EMPTY
9097: LIST
9098: LIST
9099: LIST
9100: LIST
9101: PUSH
9102: EMPTY
9103: LIST
9104: LIST
9105: LIST
9106: LIST
9107: LIST
9108: LIST
9109: PPUSH
9110: CALL 43336 0 2
// end else
9114: GO 9239
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9116: LD_INT 2
9118: PPUSH
9119: LD_INT 24
9121: PUSH
9122: LD_INT 3
9124: PUSH
9125: LD_INT 3
9127: PUSH
9128: LD_INT 47
9130: PUSH
9131: EMPTY
9132: LIST
9133: LIST
9134: LIST
9135: LIST
9136: PUSH
9137: LD_INT 24
9139: PUSH
9140: LD_INT 3
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: LD_INT 47
9148: PUSH
9149: EMPTY
9150: LIST
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: LD_INT 24
9157: PUSH
9158: LD_INT 3
9160: PUSH
9161: LD_INT 3
9163: PUSH
9164: LD_INT 47
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: LIST
9171: LIST
9172: PUSH
9173: LD_INT 24
9175: PUSH
9176: LD_INT 3
9178: PUSH
9179: LD_INT 3
9181: PUSH
9182: LD_INT 46
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: LIST
9189: LIST
9190: PUSH
9191: LD_INT 24
9193: PUSH
9194: LD_INT 3
9196: PUSH
9197: LD_INT 3
9199: PUSH
9200: LD_INT 46
9202: PUSH
9203: EMPTY
9204: LIST
9205: LIST
9206: LIST
9207: LIST
9208: PUSH
9209: LD_INT 24
9211: PUSH
9212: LD_INT 3
9214: PUSH
9215: LD_INT 3
9217: PUSH
9218: LD_INT 46
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: LIST
9225: LIST
9226: PUSH
9227: EMPTY
9228: LIST
9229: LIST
9230: LIST
9231: LIST
9232: LIST
9233: LIST
9234: PPUSH
9235: CALL 43336 0 2
// end ; if Difficulty > 1 then
9239: LD_OWVAR 67
9243: PUSH
9244: LD_INT 1
9246: GREATER
9247: IFFALSE 9277
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9249: LD_INT 2
9251: PPUSH
9252: LD_INT 24
9254: PUSH
9255: LD_INT 3
9257: PUSH
9258: LD_INT 3
9260: PUSH
9261: LD_INT 47
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: LIST
9268: LIST
9269: PUSH
9270: EMPTY
9271: LIST
9272: PPUSH
9273: CALL 43336 0 2
// repeat wait ( 0 0$1 ) ;
9277: LD_INT 35
9279: PPUSH
9280: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9284: LD_INT 2
9286: PPUSH
9287: LD_INT 1
9289: PPUSH
9290: CALL 44754 0 2
9294: PUSH
9295: LD_INT 6
9297: PUSH
9298: LD_INT 7
9300: PUSH
9301: LD_INT 7
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: LIST
9308: PUSH
9309: LD_OWVAR 67
9313: ARRAY
9314: GREATEREQUAL
9315: IFFALSE 9277
// wait ( 0 0$30 ) ;
9317: LD_INT 1050
9319: PPUSH
9320: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9324: LD_ADDR_VAR 0 2
9328: PUSH
9329: LD_INT 2
9331: PPUSH
9332: LD_INT 1
9334: PPUSH
9335: CALL 44754 0 2
9339: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9340: LD_ADDR_EXP 93
9344: PUSH
9345: LD_EXP 93
9349: PPUSH
9350: LD_INT 2
9352: PPUSH
9353: LD_EXP 93
9357: PUSH
9358: LD_INT 2
9360: ARRAY
9361: PUSH
9362: LD_VAR 0 2
9366: DIFF
9367: PPUSH
9368: CALL_OW 1
9372: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9373: LD_ADDR_VAR 0 3
9377: PUSH
9378: LD_INT 0
9380: PPUSH
9381: LD_INT 1
9383: PPUSH
9384: CALL_OW 12
9388: ST_TO_ADDR
// if target then
9389: LD_VAR 0 3
9393: IFFALSE 9521
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9395: LD_ADDR_VAR 0 2
9399: PUSH
9400: LD_VAR 0 2
9404: PPUSH
9405: LD_INT 24
9407: PUSH
9408: LD_INT 250
9410: PUSH
9411: EMPTY
9412: LIST
9413: LIST
9414: PPUSH
9415: CALL_OW 72
9419: ST_TO_ADDR
// for i in tmp do
9420: LD_ADDR_VAR 0 1
9424: PUSH
9425: LD_VAR 0 2
9429: PUSH
9430: FOR_IN
9431: IFFALSE 9471
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9433: LD_VAR 0 1
9437: PPUSH
9438: LD_INT 139
9440: PPUSH
9441: LD_INT 89
9443: PPUSH
9444: CALL_OW 297
9448: PUSH
9449: LD_INT 9
9451: GREATER
9452: IFFALSE 9469
// ComMoveXY ( i , 139 , 89 ) ;
9454: LD_VAR 0 1
9458: PPUSH
9459: LD_INT 139
9461: PPUSH
9462: LD_INT 89
9464: PPUSH
9465: CALL_OW 111
9469: GO 9430
9471: POP
9472: POP
// wait ( 0 0$1 ) ;
9473: LD_INT 35
9475: PPUSH
9476: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9480: LD_VAR 0 2
9484: PPUSH
9485: LD_INT 92
9487: PUSH
9488: LD_INT 139
9490: PUSH
9491: LD_INT 89
9493: PUSH
9494: LD_INT 9
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: LIST
9501: LIST
9502: PPUSH
9503: CALL_OW 72
9507: PUSH
9508: LD_VAR 0 2
9512: PUSH
9513: LD_INT 1
9515: MINUS
9516: GREATEREQUAL
9517: IFFALSE 9395
// end else
9519: GO 9663
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9521: LD_VAR 0 2
9525: PPUSH
9526: LD_VAR 0 4
9530: PUSH
9531: LD_INT 1
9533: ARRAY
9534: PPUSH
9535: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9539: LD_ADDR_VAR 0 2
9543: PUSH
9544: LD_VAR 0 2
9548: PPUSH
9549: LD_INT 24
9551: PUSH
9552: LD_INT 250
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PPUSH
9559: CALL_OW 72
9563: ST_TO_ADDR
// for i in tmp do
9564: LD_ADDR_VAR 0 1
9568: PUSH
9569: LD_VAR 0 2
9573: PUSH
9574: FOR_IN
9575: IFFALSE 9615
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9577: LD_VAR 0 1
9581: PPUSH
9582: LD_INT 124
9584: PPUSH
9585: LD_INT 139
9587: PPUSH
9588: CALL_OW 297
9592: PUSH
9593: LD_INT 9
9595: GREATER
9596: IFFALSE 9613
// ComMoveXY ( i , 124 , 139 ) ;
9598: LD_VAR 0 1
9602: PPUSH
9603: LD_INT 124
9605: PPUSH
9606: LD_INT 139
9608: PPUSH
9609: CALL_OW 111
9613: GO 9574
9615: POP
9616: POP
// wait ( 0 0$1 ) ;
9617: LD_INT 35
9619: PPUSH
9620: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9624: LD_VAR 0 2
9628: PPUSH
9629: LD_INT 92
9631: PUSH
9632: LD_INT 124
9634: PUSH
9635: LD_INT 139
9637: PUSH
9638: LD_INT 9
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: PPUSH
9647: CALL_OW 72
9651: PUSH
9652: LD_VAR 0 2
9656: PUSH
9657: LD_INT 1
9659: MINUS
9660: GREATEREQUAL
9661: IFFALSE 9539
// end ; repeat wait ( 0 0$1 ) ;
9663: LD_INT 35
9665: PPUSH
9666: CALL_OW 67
// for i in tmp do
9670: LD_ADDR_VAR 0 1
9674: PUSH
9675: LD_VAR 0 2
9679: PUSH
9680: FOR_IN
9681: IFFALSE 9814
// begin if GetLives ( i ) > 251 then
9683: LD_VAR 0 1
9687: PPUSH
9688: CALL_OW 256
9692: PUSH
9693: LD_INT 251
9695: GREATER
9696: IFFALSE 9785
// begin if GetWeapon ( i ) = ru_time_lapser then
9698: LD_VAR 0 1
9702: PPUSH
9703: CALL_OW 264
9707: PUSH
9708: LD_INT 49
9710: EQUAL
9711: IFFALSE 9749
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
9713: LD_VAR 0 1
9717: PPUSH
9718: LD_INT 81
9720: PUSH
9721: LD_INT 3
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: PPUSH
9728: CALL_OW 69
9732: PPUSH
9733: LD_VAR 0 1
9737: PPUSH
9738: CALL_OW 74
9742: PPUSH
9743: CALL_OW 112
9747: GO 9783
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9749: LD_VAR 0 1
9753: PPUSH
9754: LD_INT 81
9756: PUSH
9757: LD_INT 3
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: PPUSH
9764: CALL_OW 69
9768: PPUSH
9769: LD_VAR 0 1
9773: PPUSH
9774: CALL_OW 74
9778: PPUSH
9779: CALL_OW 115
// end else
9783: GO 9812
// if IsDead ( i ) then
9785: LD_VAR 0 1
9789: PPUSH
9790: CALL_OW 301
9794: IFFALSE 9812
// tmp := tmp diff i ;
9796: LD_ADDR_VAR 0 2
9800: PUSH
9801: LD_VAR 0 2
9805: PUSH
9806: LD_VAR 0 1
9810: DIFF
9811: ST_TO_ADDR
// end ;
9812: GO 9680
9814: POP
9815: POP
// until not tmp ;
9816: LD_VAR 0 2
9820: NOT
9821: IFFALSE 9663
// end ;
9823: PPOPN 4
9825: END
// every 30 30$00 trigger not russianDestroyed do
9826: LD_EXP 2
9830: NOT
9831: IFFALSE 9896
9833: GO 9835
9835: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
9836: LD_INT 105000
9838: PUSH
9839: LD_INT 84000
9841: PUSH
9842: LD_INT 63000
9844: PUSH
9845: EMPTY
9846: LIST
9847: LIST
9848: LIST
9849: PUSH
9850: LD_OWVAR 67
9854: ARRAY
9855: PPUSH
9856: CALL_OW 67
// if russianDestroyed then
9860: LD_EXP 2
9864: IFFALSE 9868
// exit ;
9866: GO 9896
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
9868: LD_INT 2
9870: PPUSH
9871: LD_INT 23
9873: PUSH
9874: LD_INT 3
9876: PUSH
9877: LD_INT 1
9879: PUSH
9880: LD_INT 48
9882: PUSH
9883: EMPTY
9884: LIST
9885: LIST
9886: LIST
9887: LIST
9888: PUSH
9889: EMPTY
9890: LIST
9891: PPUSH
9892: CALL 43336 0 2
// end ; end_of_file
9896: END
// export function CustomEvent ( event ) ; begin
9897: LD_INT 0
9899: PPUSH
// end ;
9900: LD_VAR 0 2
9904: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
9905: LD_VAR 0 2
9909: PPUSH
9910: LD_VAR 0 3
9914: PPUSH
9915: LD_INT 15
9917: PPUSH
9918: CALL_OW 309
9922: IFFALSE 9931
// YouLost ( MothContaminate ) ;
9924: LD_STRING MothContaminate
9926: PPUSH
9927: CALL_OW 104
// end ;
9931: PPOPN 3
9933: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
9934: LD_VAR 0 2
9938: PPUSH
9939: LD_VAR 0 3
9943: PPUSH
9944: LD_INT 15
9946: PPUSH
9947: CALL_OW 309
9951: IFFALSE 9967
// begin wait ( 0 0$6 ) ;
9953: LD_INT 210
9955: PPUSH
9956: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
9960: LD_STRING MothContaminateBomb
9962: PPUSH
9963: CALL_OW 104
// end ; end ;
9967: PPOPN 3
9969: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9970: LD_VAR 0 1
9974: PUSH
9975: LD_EXP 12
9979: EQUAL
9980: IFFALSE 9991
// begin YouLost ( JMM ) ;
9982: LD_STRING JMM
9984: PPUSH
9985: CALL_OW 104
// exit ;
9989: GO 10040
// end ; if un = Powell then
9991: LD_VAR 0 1
9995: PUSH
9996: LD_EXP 47
10000: EQUAL
10001: IFFALSE 10011
// americanDestroyed := true ;
10003: LD_ADDR_EXP 4
10007: PUSH
10008: LD_INT 1
10010: ST_TO_ADDR
// if un = Platonov then
10011: LD_VAR 0 1
10015: PUSH
10016: LD_EXP 51
10020: EQUAL
10021: IFFALSE 10031
// russianDestroyed := true ;
10023: LD_ADDR_EXP 2
10027: PUSH
10028: LD_INT 1
10030: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10031: LD_VAR 0 1
10035: PPUSH
10036: CALL 46728 0 1
// end ;
10040: PPOPN 1
10042: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10043: LD_VAR 0 1
10047: PPUSH
10048: LD_VAR 0 2
10052: PPUSH
10053: CALL 48928 0 2
// end ;
10057: PPOPN 2
10059: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10060: LD_VAR 0 1
10064: PPUSH
10065: CALL 47996 0 1
// end ;
10069: PPOPN 1
10071: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10072: LD_VAR 0 1
10076: PUSH
10077: LD_INT 22
10079: PUSH
10080: LD_INT 8
10082: PUSH
10083: EMPTY
10084: LIST
10085: LIST
10086: PUSH
10087: LD_INT 30
10089: PUSH
10090: LD_INT 2
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: PUSH
10097: LD_INT 23
10099: PUSH
10100: LD_INT 3
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: PUSH
10107: EMPTY
10108: LIST
10109: LIST
10110: LIST
10111: PPUSH
10112: CALL_OW 69
10116: IN
10117: IFFALSE 10144
// begin ComUpgrade ( building ) ;
10119: LD_VAR 0 1
10123: PPUSH
10124: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10128: LD_EXP 50
10132: PPUSH
10133: LD_VAR 0 1
10137: PPUSH
10138: CALL 59485 0 2
// exit ;
10142: GO 10153
// end ; MCE_BuildingComplete ( building ) ;
10144: LD_VAR 0 1
10148: PPUSH
10149: CALL 48237 0 1
// end ;
10153: PPOPN 1
10155: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10156: LD_VAR 0 1
10160: PPUSH
10161: LD_VAR 0 2
10165: PPUSH
10166: CALL 46424 0 2
// end ;
10170: PPOPN 2
10172: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10173: LD_VAR 0 1
10177: PPUSH
10178: LD_VAR 0 2
10182: PPUSH
10183: LD_VAR 0 3
10187: PPUSH
10188: LD_VAR 0 4
10192: PPUSH
10193: LD_VAR 0 5
10197: PPUSH
10198: CALL 46044 0 5
// end ;
10202: PPOPN 5
10204: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10205: LD_VAR 0 1
10209: PPUSH
10210: LD_VAR 0 2
10214: PPUSH
10215: CALL 45640 0 2
// end ;
10219: PPOPN 2
10221: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10222: LD_VAR 0 1
10226: PPUSH
10227: LD_VAR 0 2
10231: PPUSH
10232: LD_VAR 0 3
10236: PPUSH
10237: LD_VAR 0 4
10241: PPUSH
10242: CALL 45478 0 4
// end ;
10246: PPOPN 4
10248: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10249: LD_VAR 0 1
10253: PPUSH
10254: LD_VAR 0 2
10258: PPUSH
10259: LD_VAR 0 3
10263: PPUSH
10264: CALL 45253 0 3
// end ;
10268: PPOPN 3
10270: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10271: LD_VAR 0 1
10275: PPUSH
10276: LD_VAR 0 2
10280: PPUSH
10281: CALL 45138 0 2
// end ;
10285: PPOPN 2
10287: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10288: LD_VAR 0 1
10292: PPUSH
10293: LD_VAR 0 2
10297: PPUSH
10298: CALL 49189 0 2
// end ;
10302: PPOPN 2
10304: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10305: LD_VAR 0 1
10309: PPUSH
10310: LD_VAR 0 2
10314: PPUSH
10315: LD_VAR 0 3
10319: PPUSH
10320: LD_VAR 0 4
10324: PPUSH
10325: CALL 49405 0 4
// end ;
10329: PPOPN 4
10331: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10332: LD_VAR 0 1
10336: PPUSH
10337: LD_VAR 0 2
10341: PPUSH
10342: CALL 44947 0 2
// end ;
10346: PPOPN 2
10348: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10349: LD_VAR 0 1
10353: PPUSH
10354: CALL 92657 0 1
// end ; end_of_file
10358: PPOPN 1
10360: END
// export function Action ; begin
10361: LD_INT 0
10363: PPUSH
// InGameOn ;
10364: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10368: LD_INT 206
10370: PPUSH
10371: LD_INT 11
10373: PPUSH
10374: CALL_OW 86
// wait ( 0 0$1 ) ;
10378: LD_INT 35
10380: PPUSH
10381: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10385: LD_EXP 12
10389: PPUSH
10390: LD_STRING DStart-JMM-JMM-1
10392: PPUSH
10393: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10397: LD_EXP 44
10401: PPUSH
10402: LD_STRING DStart-JMM-Bur-1
10404: PPUSH
10405: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10409: LD_EXP 12
10413: PPUSH
10414: LD_STRING DStart-JMM-JMM-2
10416: PPUSH
10417: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10421: LD_EXP 44
10425: PPUSH
10426: LD_STRING DStart-JMM-Bur-2
10428: PPUSH
10429: CALL_OW 88
// InGameOff ;
10433: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10437: LD_STRING MStart
10439: PPUSH
10440: CALL_OW 337
// end ;
10444: LD_VAR 0 1
10448: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10449: LD_INT 7
10451: PPUSH
10452: LD_INT 255
10454: PPUSH
10455: LD_INT 219
10457: PPUSH
10458: CALL_OW 293
10462: IFFALSE 11071
10464: GO 10466
10466: DISABLE
10467: LD_INT 0
10469: PPUSH
// begin wait ( 0 0$3 ) ;
10470: LD_INT 105
10472: PPUSH
10473: CALL_OW 67
// alienSpotted := true ;
10477: LD_ADDR_EXP 7
10481: PUSH
10482: LD_INT 1
10484: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10485: LD_ADDR_VAR 0 1
10489: PUSH
10490: LD_INT 22
10492: PUSH
10493: LD_INT 7
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PUSH
10500: LD_INT 23
10502: PUSH
10503: LD_INT 3
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: PUSH
10510: LD_INT 21
10512: PUSH
10513: LD_INT 1
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 26
10522: PUSH
10523: LD_INT 1
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: PPUSH
10536: CALL_OW 69
10540: PUSH
10541: LD_EXP 44
10545: PUSH
10546: LD_EXP 32
10550: PUSH
10551: LD_EXP 34
10555: PUSH
10556: LD_EXP 35
10560: PUSH
10561: LD_EXP 42
10565: PUSH
10566: LD_EXP 41
10570: PUSH
10571: LD_EXP 36
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: DIFF
10585: ST_TO_ADDR
// DialogueOn ;
10586: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
10590: LD_INT 255
10592: PPUSH
10593: LD_INT 219
10595: PPUSH
10596: LD_INT 7
10598: PPUSH
10599: LD_INT 20
10601: NEG
10602: PPUSH
10603: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
10607: LD_INT 255
10609: PPUSH
10610: LD_INT 219
10612: PPUSH
10613: CALL_OW 86
// if speaker then
10617: LD_VAR 0 1
10621: IFFALSE 10639
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
10623: LD_VAR 0 1
10627: PUSH
10628: LD_INT 1
10630: ARRAY
10631: PPUSH
10632: LD_STRING DAlienBase-RSol1-1
10634: PPUSH
10635: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
10639: LD_EXP 12
10643: PPUSH
10644: LD_STRING DAlienBase-JMM-1
10646: PPUSH
10647: CALL_OW 88
// if IsOk ( Burlak ) then
10651: LD_EXP 44
10655: PPUSH
10656: CALL_OW 302
10660: IFFALSE 10681
// begin dwait ( 0 0$1 ) ;
10662: LD_INT 35
10664: PPUSH
10665: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
10669: LD_EXP 44
10673: PPUSH
10674: LD_STRING DAlienBase-Bur-1
10676: PPUSH
10677: CALL_OW 88
// end ; if IsOk ( Roth ) then
10681: LD_EXP 13
10685: PPUSH
10686: CALL_OW 302
10690: IFFALSE 10704
// Say ( Roth , DAlienBase-Roth-1 ) ;
10692: LD_EXP 13
10696: PPUSH
10697: LD_STRING DAlienBase-Roth-1
10699: PPUSH
10700: CALL_OW 88
// if IsOk ( Gossudarov ) then
10704: LD_EXP 30
10708: PPUSH
10709: CALL_OW 302
10713: IFFALSE 10729
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
10715: LD_EXP 30
10719: PPUSH
10720: LD_STRING DAlienBase-Gos-1
10722: PPUSH
10723: CALL_OW 88
10727: GO 10846
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
10729: LD_ADDR_VAR 0 1
10733: PUSH
10734: LD_INT 22
10736: PUSH
10737: LD_INT 7
10739: PUSH
10740: EMPTY
10741: LIST
10742: LIST
10743: PUSH
10744: LD_INT 25
10746: PUSH
10747: LD_INT 4
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PUSH
10754: LD_INT 21
10756: PUSH
10757: LD_INT 1
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: PUSH
10764: LD_INT 26
10766: PUSH
10767: LD_INT 1
10769: PUSH
10770: EMPTY
10771: LIST
10772: LIST
10773: PUSH
10774: EMPTY
10775: LIST
10776: LIST
10777: LIST
10778: LIST
10779: PPUSH
10780: CALL_OW 69
10784: PUSH
10785: LD_EXP 13
10789: PUSH
10790: LD_EXP 12
10794: PUSH
10795: LD_EXP 44
10799: PUSH
10800: LD_EXP 32
10804: PUSH
10805: LD_EXP 42
10809: PUSH
10810: LD_EXP 41
10814: PUSH
10815: EMPTY
10816: LIST
10817: LIST
10818: LIST
10819: LIST
10820: LIST
10821: LIST
10822: DIFF
10823: ST_TO_ADDR
// if speaker then
10824: LD_VAR 0 1
10828: IFFALSE 10846
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
10830: LD_VAR 0 1
10834: PUSH
10835: LD_INT 1
10837: ARRAY
10838: PPUSH
10839: LD_STRING DAlienBase-Sci1-1
10841: PPUSH
10842: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
10846: LD_INT 255
10848: PPUSH
10849: LD_INT 219
10851: PPUSH
10852: LD_INT 7
10854: PPUSH
10855: CALL_OW 331
// DialogueOff ;
10859: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
10863: LD_INT 35
10865: PPUSH
10866: CALL_OW 67
// until IsSelected ( alien ) ;
10870: LD_INT 1
10872: PPUSH
10873: CALL_OW 306
10877: IFFALSE 10863
// if not artifactIResearched or not artifactIIResearched then
10879: LD_EXP 9
10883: NOT
10884: PUSH
10885: LD_EXP 10
10889: NOT
10890: OR
10891: IFFALSE 11071
// begin if IsOk ( Roth ) then
10893: LD_EXP 13
10897: PPUSH
10898: CALL_OW 302
10902: IFFALSE 10918
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
10904: LD_EXP 13
10908: PPUSH
10909: LD_STRING DAlieBaseNotReady-Roth-1
10911: PPUSH
10912: CALL_OW 88
10916: GO 11071
// if IsOk ( Gossudarov ) then
10918: LD_EXP 30
10922: PPUSH
10923: CALL_OW 302
10927: IFFALSE 10943
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
10929: LD_EXP 30
10933: PPUSH
10934: LD_STRING DAlieBaseNotReady-Gos-1
10936: PPUSH
10937: CALL_OW 88
10941: GO 11071
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
10943: LD_ADDR_VAR 0 1
10947: PUSH
10948: LD_INT 22
10950: PUSH
10951: LD_INT 7
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: LD_INT 23
10960: PUSH
10961: LD_INT 3
10963: PUSH
10964: EMPTY
10965: LIST
10966: LIST
10967: PUSH
10968: LD_INT 25
10970: PUSH
10971: LD_INT 4
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: PUSH
10978: LD_INT 21
10980: PUSH
10981: LD_INT 1
10983: PUSH
10984: EMPTY
10985: LIST
10986: LIST
10987: PUSH
10988: LD_INT 26
10990: PUSH
10991: LD_INT 1
10993: PUSH
10994: EMPTY
10995: LIST
10996: LIST
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: PPUSH
11005: CALL_OW 69
11009: PUSH
11010: LD_EXP 13
11014: PUSH
11015: LD_EXP 12
11019: PUSH
11020: LD_EXP 44
11024: PUSH
11025: LD_EXP 32
11029: PUSH
11030: LD_EXP 42
11034: PUSH
11035: LD_EXP 41
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: LIST
11044: LIST
11045: LIST
11046: LIST
11047: DIFF
11048: ST_TO_ADDR
// if speaker then
11049: LD_VAR 0 1
11053: IFFALSE 11071
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11055: LD_VAR 0 1
11059: PUSH
11060: LD_INT 1
11062: ARRAY
11063: PPUSH
11064: LD_STRING DAlieBaseNotReady-RSci1-1
11066: PPUSH
11067: CALL_OW 88
// end ; end ; end ;
11071: PPOPN 1
11073: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11074: LD_INT 24
11076: PPUSH
11077: LD_INT 7
11079: PPUSH
11080: CALL_OW 321
11084: PUSH
11085: LD_INT 2
11087: EQUAL
11088: IFFALSE 11779
11090: GO 11092
11092: DISABLE
11093: LD_INT 0
11095: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11096: LD_ADDR_VAR 0 1
11100: PUSH
11101: LD_INT 22
11103: PUSH
11104: LD_INT 7
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PUSH
11111: LD_INT 23
11113: PUSH
11114: LD_INT 3
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: PUSH
11121: LD_INT 25
11123: PUSH
11124: LD_INT 4
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: LD_INT 21
11133: PUSH
11134: LD_INT 1
11136: PUSH
11137: EMPTY
11138: LIST
11139: LIST
11140: PUSH
11141: LD_INT 26
11143: PUSH
11144: LD_INT 1
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: PPUSH
11158: CALL_OW 69
11162: PUSH
11163: LD_EXP 13
11167: PUSH
11168: LD_EXP 12
11172: PUSH
11173: LD_EXP 44
11177: PUSH
11178: LD_EXP 32
11182: PUSH
11183: LD_EXP 42
11187: PUSH
11188: LD_EXP 41
11192: PUSH
11193: EMPTY
11194: LIST
11195: LIST
11196: LIST
11197: LIST
11198: LIST
11199: LIST
11200: DIFF
11201: ST_TO_ADDR
// if not speaker then
11202: LD_VAR 0 1
11206: NOT
11207: IFFALSE 11211
// exit ;
11209: GO 11779
// DialogueOn ;
11211: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11215: LD_VAR 0 1
11219: PUSH
11220: LD_INT 1
11222: ARRAY
11223: PPUSH
11224: LD_STRING DArtefTechnology-RSci1-1
11226: PPUSH
11227: CALL_OW 88
// if IsOk ( Burlak ) then
11231: LD_EXP 44
11235: PPUSH
11236: CALL_OW 302
11240: IFFALSE 11254
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11242: LD_EXP 44
11246: PPUSH
11247: LD_STRING DArtefTechnology-Bur-1
11249: PPUSH
11250: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11254: LD_VAR 0 1
11258: PUSH
11259: LD_INT 1
11261: ARRAY
11262: PPUSH
11263: LD_STRING DArtefTechnology-RSci1-2
11265: PPUSH
11266: CALL_OW 88
// if Denis then
11270: LD_EXP 18
11274: IFFALSE 11291
// speaker := [ Denis ] else
11276: LD_ADDR_VAR 0 1
11280: PUSH
11281: LD_EXP 18
11285: PUSH
11286: EMPTY
11287: LIST
11288: ST_TO_ADDR
11289: GO 11397
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11291: LD_ADDR_VAR 0 1
11295: PUSH
11296: LD_INT 22
11298: PUSH
11299: LD_INT 7
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: PUSH
11306: LD_INT 23
11308: PUSH
11309: LD_INT 1
11311: PUSH
11312: EMPTY
11313: LIST
11314: LIST
11315: PUSH
11316: LD_INT 25
11318: PUSH
11319: LD_INT 4
11321: PUSH
11322: EMPTY
11323: LIST
11324: LIST
11325: PUSH
11326: LD_INT 21
11328: PUSH
11329: LD_INT 1
11331: PUSH
11332: EMPTY
11333: LIST
11334: LIST
11335: PUSH
11336: LD_INT 26
11338: PUSH
11339: LD_INT 1
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: LIST
11350: LIST
11351: LIST
11352: PPUSH
11353: CALL_OW 69
11357: PUSH
11358: LD_EXP 13
11362: PUSH
11363: LD_EXP 12
11367: PUSH
11368: LD_EXP 44
11372: PUSH
11373: LD_EXP 32
11377: PUSH
11378: LD_EXP 42
11382: PUSH
11383: LD_EXP 41
11387: PUSH
11388: EMPTY
11389: LIST
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: DIFF
11396: ST_TO_ADDR
// if speaker then
11397: LD_VAR 0 1
11401: IFFALSE 11419
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11403: LD_VAR 0 1
11407: PUSH
11408: LD_INT 1
11410: ARRAY
11411: PPUSH
11412: LD_STRING DArtefTechnology-Sci1-2
11414: PPUSH
11415: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11419: LD_ADDR_VAR 0 1
11423: PUSH
11424: LD_INT 22
11426: PUSH
11427: LD_INT 7
11429: PUSH
11430: EMPTY
11431: LIST
11432: LIST
11433: PUSH
11434: LD_INT 23
11436: PUSH
11437: LD_INT 3
11439: PUSH
11440: EMPTY
11441: LIST
11442: LIST
11443: PUSH
11444: LD_INT 25
11446: PUSH
11447: LD_INT 4
11449: PUSH
11450: EMPTY
11451: LIST
11452: LIST
11453: PUSH
11454: LD_INT 21
11456: PUSH
11457: LD_INT 1
11459: PUSH
11460: EMPTY
11461: LIST
11462: LIST
11463: PUSH
11464: LD_INT 26
11466: PUSH
11467: LD_INT 1
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: LIST
11480: PPUSH
11481: CALL_OW 69
11485: PUSH
11486: LD_EXP 13
11490: PUSH
11491: LD_EXP 12
11495: PUSH
11496: LD_EXP 44
11500: PUSH
11501: LD_EXP 32
11505: PUSH
11506: LD_EXP 42
11510: PUSH
11511: LD_EXP 41
11515: PUSH
11516: EMPTY
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: DIFF
11524: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
11525: LD_VAR 0 1
11529: PUSH
11530: LD_EXP 6
11534: PUSH
11535: LD_EXP 5
11539: OR
11540: AND
11541: IFFALSE 11775
// begin if arabianDestroyed and IsOk ( Burlak ) then
11543: LD_EXP 5
11547: PUSH
11548: LD_EXP 44
11552: PPUSH
11553: CALL_OW 302
11557: AND
11558: IFFALSE 11574
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
11560: LD_EXP 44
11564: PPUSH
11565: LD_STRING DArtefTechnology-Bur-2
11567: PPUSH
11568: CALL_OW 88
11572: GO 11586
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
11574: LD_EXP 12
11578: PPUSH
11579: LD_STRING DArtefTechnology-JMM-2
11581: PPUSH
11582: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
11586: LD_VAR 0 1
11590: PUSH
11591: LD_INT 1
11593: ARRAY
11594: PPUSH
11595: LD_STRING DArtefTechnology-RSci1-3
11597: PPUSH
11598: CALL_OW 88
// if Denis then
11602: LD_EXP 18
11606: IFFALSE 11623
// speaker := [ Denis ] else
11608: LD_ADDR_VAR 0 1
11612: PUSH
11613: LD_EXP 18
11617: PUSH
11618: EMPTY
11619: LIST
11620: ST_TO_ADDR
11621: GO 11729
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11623: LD_ADDR_VAR 0 1
11627: PUSH
11628: LD_INT 22
11630: PUSH
11631: LD_INT 7
11633: PUSH
11634: EMPTY
11635: LIST
11636: LIST
11637: PUSH
11638: LD_INT 23
11640: PUSH
11641: LD_INT 1
11643: PUSH
11644: EMPTY
11645: LIST
11646: LIST
11647: PUSH
11648: LD_INT 25
11650: PUSH
11651: LD_INT 4
11653: PUSH
11654: EMPTY
11655: LIST
11656: LIST
11657: PUSH
11658: LD_INT 21
11660: PUSH
11661: LD_INT 1
11663: PUSH
11664: EMPTY
11665: LIST
11666: LIST
11667: PUSH
11668: LD_INT 26
11670: PUSH
11671: LD_INT 1
11673: PUSH
11674: EMPTY
11675: LIST
11676: LIST
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: PPUSH
11685: CALL_OW 69
11689: PUSH
11690: LD_EXP 13
11694: PUSH
11695: LD_EXP 12
11699: PUSH
11700: LD_EXP 44
11704: PUSH
11705: LD_EXP 32
11709: PUSH
11710: LD_EXP 42
11714: PUSH
11715: LD_EXP 41
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: DIFF
11728: ST_TO_ADDR
// if speaker then
11729: LD_VAR 0 1
11733: IFFALSE 11775
// if alienSpotted then
11735: LD_EXP 7
11739: IFFALSE 11759
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
11741: LD_VAR 0 1
11745: PUSH
11746: LD_INT 1
11748: ARRAY
11749: PPUSH
11750: LD_STRING DArtefTechnology-Sci1-3
11752: PPUSH
11753: CALL_OW 88
11757: GO 11775
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
11759: LD_VAR 0 1
11763: PUSH
11764: LD_INT 1
11766: ARRAY
11767: PPUSH
11768: LD_STRING DArtefTechnology-Sci1-3a
11770: PPUSH
11771: CALL_OW 88
// end ; DialogueOff ;
11775: CALL_OW 7
// end ;
11779: PPOPN 1
11781: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
11782: LD_EXP 9
11786: IFFALSE 11981
11788: GO 11790
11790: DISABLE
11791: LD_INT 0
11793: PPUSH
// begin if Denis then
11794: LD_EXP 18
11798: IFFALSE 11815
// speaker := [ Denis ] else
11800: LD_ADDR_VAR 0 1
11804: PUSH
11805: LD_EXP 18
11809: PUSH
11810: EMPTY
11811: LIST
11812: ST_TO_ADDR
11813: GO 11921
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11815: LD_ADDR_VAR 0 1
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_INT 7
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: LD_INT 23
11832: PUSH
11833: LD_INT 1
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 25
11842: PUSH
11843: LD_INT 4
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 1
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 26
11862: PUSH
11863: LD_INT 1
11865: PUSH
11866: EMPTY
11867: LIST
11868: LIST
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: PPUSH
11877: CALL_OW 69
11881: PUSH
11882: LD_EXP 13
11886: PUSH
11887: LD_EXP 12
11891: PUSH
11892: LD_EXP 44
11896: PUSH
11897: LD_EXP 32
11901: PUSH
11902: LD_EXP 42
11906: PUSH
11907: LD_EXP 41
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: LIST
11916: LIST
11917: LIST
11918: LIST
11919: DIFF
11920: ST_TO_ADDR
// if not speaker then
11921: LD_VAR 0 1
11925: NOT
11926: IFFALSE 11930
// exit ;
11928: GO 11981
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
11930: LD_VAR 0 1
11934: PUSH
11935: LD_INT 1
11937: ARRAY
11938: PPUSH
11939: LD_STRING DArtefTechnologyAm-Sci1-1
11941: PPUSH
11942: CALL_OW 88
// if IsOk ( Burlak ) then
11946: LD_EXP 44
11950: PPUSH
11951: CALL_OW 302
11955: IFFALSE 11969
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
11957: LD_EXP 44
11961: PPUSH
11962: LD_STRING DArtefTechnologyAm-Bur-1
11964: PPUSH
11965: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
11969: LD_EXP 12
11973: PPUSH
11974: LD_STRING DArtefTechnologyAm-JMM-1
11976: PPUSH
11977: CALL_OW 88
// end ;
11981: PPOPN 1
11983: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
11984: LD_EXP 10
11988: IFFALSE 12199
11990: GO 11992
11992: DISABLE
11993: LD_INT 0
11995: PPUSH
// begin if Denis then
11996: LD_EXP 18
12000: IFFALSE 12017
// speaker := [ Denis ] else
12002: LD_ADDR_VAR 0 1
12006: PUSH
12007: LD_EXP 18
12011: PUSH
12012: EMPTY
12013: LIST
12014: ST_TO_ADDR
12015: GO 12123
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12017: LD_ADDR_VAR 0 1
12021: PUSH
12022: LD_INT 22
12024: PUSH
12025: LD_INT 7
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PUSH
12032: LD_INT 23
12034: PUSH
12035: LD_INT 3
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: LD_INT 25
12044: PUSH
12045: LD_INT 4
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PUSH
12052: LD_INT 21
12054: PUSH
12055: LD_INT 1
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: PUSH
12062: LD_INT 26
12064: PUSH
12065: LD_INT 1
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: PUSH
12072: EMPTY
12073: LIST
12074: LIST
12075: LIST
12076: LIST
12077: LIST
12078: PPUSH
12079: CALL_OW 69
12083: PUSH
12084: LD_EXP 13
12088: PUSH
12089: LD_EXP 12
12093: PUSH
12094: LD_EXP 44
12098: PUSH
12099: LD_EXP 32
12103: PUSH
12104: LD_EXP 42
12108: PUSH
12109: LD_EXP 41
12113: PUSH
12114: EMPTY
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: LIST
12121: DIFF
12122: ST_TO_ADDR
// if not speaker then
12123: LD_VAR 0 1
12127: NOT
12128: IFFALSE 12132
// exit ;
12130: GO 12199
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12132: LD_VAR 0 1
12136: PUSH
12137: LD_INT 1
12139: ARRAY
12140: PPUSH
12141: LD_STRING DArtefTechnologyRu-RSci1-1
12143: PPUSH
12144: CALL_OW 88
// if IsOk ( Burlak ) then
12148: LD_EXP 44
12152: PPUSH
12153: CALL_OW 302
12157: IFFALSE 12171
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12159: LD_EXP 44
12163: PPUSH
12164: LD_STRING DArtefTechnologyRu-Bur-1
12166: PPUSH
12167: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12171: LD_VAR 0 1
12175: PUSH
12176: LD_INT 1
12178: ARRAY
12179: PPUSH
12180: LD_STRING DArtefTechnologyRu-RSci1-2
12182: PPUSH
12183: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12187: LD_EXP 12
12191: PPUSH
12192: LD_STRING DArtefTechnologyRu-JMM-1
12194: PPUSH
12195: CALL_OW 88
// end ;
12199: PPOPN 1
12201: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12202: LD_INT 24
12204: PPUSH
12205: LD_INT 7
12207: PPUSH
12208: CALL_OW 321
12212: PUSH
12213: LD_INT 2
12215: EQUAL
12216: PUSH
12217: LD_INT 1
12219: PPUSH
12220: CALL_OW 255
12224: PUSH
12225: LD_INT 7
12227: EQUAL
12228: AND
12229: IFFALSE 12389
12231: GO 12233
12233: DISABLE
12234: LD_INT 0
12236: PPUSH
// begin if Denis then
12237: LD_EXP 18
12241: IFFALSE 12258
// speaker := [ Denis ] else
12243: LD_ADDR_VAR 0 1
12247: PUSH
12248: LD_EXP 18
12252: PUSH
12253: EMPTY
12254: LIST
12255: ST_TO_ADDR
12256: GO 12364
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12258: LD_ADDR_VAR 0 1
12262: PUSH
12263: LD_INT 22
12265: PUSH
12266: LD_INT 7
12268: PUSH
12269: EMPTY
12270: LIST
12271: LIST
12272: PUSH
12273: LD_INT 23
12275: PUSH
12276: LD_INT 1
12278: PUSH
12279: EMPTY
12280: LIST
12281: LIST
12282: PUSH
12283: LD_INT 25
12285: PUSH
12286: LD_INT 4
12288: PUSH
12289: EMPTY
12290: LIST
12291: LIST
12292: PUSH
12293: LD_INT 21
12295: PUSH
12296: LD_INT 1
12298: PUSH
12299: EMPTY
12300: LIST
12301: LIST
12302: PUSH
12303: LD_INT 26
12305: PUSH
12306: LD_INT 1
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PUSH
12313: EMPTY
12314: LIST
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: PPUSH
12320: CALL_OW 69
12324: PUSH
12325: LD_EXP 13
12329: PUSH
12330: LD_EXP 12
12334: PUSH
12335: LD_EXP 44
12339: PUSH
12340: LD_EXP 32
12344: PUSH
12345: LD_EXP 42
12349: PUSH
12350: LD_EXP 41
12354: PUSH
12355: EMPTY
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: LIST
12362: DIFF
12363: ST_TO_ADDR
// if not speaker then
12364: LD_VAR 0 1
12368: NOT
12369: IFFALSE 12373
// exit ;
12371: GO 12389
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12373: LD_VAR 0 1
12377: PUSH
12378: LD_INT 1
12380: ARRAY
12381: PPUSH
12382: LD_STRING DArtefTechnologyArStart-Sci1-1
12384: PPUSH
12385: CALL_OW 88
// end ;
12389: PPOPN 1
12391: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12392: LD_EXP 11
12396: IFFALSE 12677
12398: GO 12400
12400: DISABLE
12401: LD_INT 0
12403: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12404: LD_ADDR_VAR 0 1
12408: PUSH
12409: LD_INT 22
12411: PUSH
12412: LD_INT 7
12414: PUSH
12415: EMPTY
12416: LIST
12417: LIST
12418: PUSH
12419: LD_INT 23
12421: PUSH
12422: LD_INT 3
12424: PUSH
12425: EMPTY
12426: LIST
12427: LIST
12428: PUSH
12429: LD_INT 25
12431: PUSH
12432: LD_INT 4
12434: PUSH
12435: EMPTY
12436: LIST
12437: LIST
12438: PUSH
12439: LD_INT 21
12441: PUSH
12442: LD_INT 1
12444: PUSH
12445: EMPTY
12446: LIST
12447: LIST
12448: PUSH
12449: LD_INT 26
12451: PUSH
12452: LD_INT 1
12454: PUSH
12455: EMPTY
12456: LIST
12457: LIST
12458: PUSH
12459: EMPTY
12460: LIST
12461: LIST
12462: LIST
12463: LIST
12464: LIST
12465: PPUSH
12466: CALL_OW 69
12470: PUSH
12471: LD_EXP 13
12475: PUSH
12476: LD_EXP 12
12480: PUSH
12481: LD_EXP 44
12485: PUSH
12486: LD_EXP 32
12490: PUSH
12491: LD_EXP 42
12495: PUSH
12496: LD_EXP 41
12500: PUSH
12501: EMPTY
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: LIST
12507: LIST
12508: DIFF
12509: ST_TO_ADDR
// if not speaker then
12510: LD_VAR 0 1
12514: NOT
12515: IFFALSE 12519
// exit ;
12517: GO 12677
// DialogueOn ;
12519: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
12523: LD_VAR 0 1
12527: PUSH
12528: LD_INT 1
12530: ARRAY
12531: PPUSH
12532: LD_STRING DArtefTechnologyAr-RSci1-1
12534: PPUSH
12535: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
12539: LD_EXP 12
12543: PPUSH
12544: LD_STRING DArtefTechnologyAr-JMM-1
12546: PPUSH
12547: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
12551: LD_VAR 0 1
12555: PUSH
12556: LD_INT 1
12558: ARRAY
12559: PPUSH
12560: LD_STRING DArtefTechnologyAr-RSci1-2
12562: PPUSH
12563: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
12567: LD_EXP 12
12571: PPUSH
12572: LD_STRING DArtefTechnologyAr-JMM-2
12574: PPUSH
12575: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
12579: LD_VAR 0 1
12583: PUSH
12584: LD_INT 1
12586: ARRAY
12587: PPUSH
12588: LD_STRING DArtefTechnologyAr-RSci1-3
12590: PPUSH
12591: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
12595: LD_EXP 12
12599: PPUSH
12600: LD_STRING DArtefTechnologyAr-JMM-3
12602: PPUSH
12603: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
12607: LD_VAR 0 1
12611: PUSH
12612: LD_INT 1
12614: ARRAY
12615: PPUSH
12616: LD_STRING DArtefTechnologyAr-RSci1-4
12618: PPUSH
12619: CALL_OW 88
// if IsOk ( Burlak ) then
12623: LD_EXP 44
12627: PPUSH
12628: CALL_OW 302
12632: IFFALSE 12646
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
12634: LD_EXP 44
12638: PPUSH
12639: LD_STRING DArtefTechnologyAr-Bur-4
12641: PPUSH
12642: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
12646: LD_EXP 12
12650: PPUSH
12651: LD_STRING DArtefTechnologyAr-JMM-4
12653: PPUSH
12654: CALL_OW 88
// DialogueOff ;
12658: CALL_OW 7
// wait ( 0 0$45 ) ;
12662: LD_INT 1575
12664: PPUSH
12665: CALL_OW 67
// spawnOmar := true ;
12669: LD_ADDR_EXP 8
12673: PUSH
12674: LD_INT 1
12676: ST_TO_ADDR
// end ;
12677: PPOPN 1
12679: END
// every 0 0$1 trigger spawnOmar do
12680: LD_EXP 8
12684: IFFALSE 12982
12686: GO 12688
12688: DISABLE
// begin PrepareOmarAli ;
12689: CALL 6212 0 0
// if not Omar then
12693: LD_EXP 48
12697: NOT
12698: IFFALSE 12702
// exit ;
12700: GO 12982
// repeat wait ( 0 0$1 ) ;
12702: LD_INT 35
12704: PPUSH
12705: CALL_OW 67
// until See ( 7 , Omar ) ;
12709: LD_INT 7
12711: PPUSH
12712: LD_EXP 48
12716: PPUSH
12717: CALL_OW 292
12721: IFFALSE 12702
// CenterNowOnUnits ( Omar ) ;
12723: LD_EXP 48
12727: PPUSH
12728: CALL_OW 87
// DialogueOn ;
12732: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
12736: LD_EXP 48
12740: PPUSH
12741: LD_STRING DOmar-Omar-1
12743: PPUSH
12744: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
12748: LD_EXP 12
12752: PPUSH
12753: LD_STRING DOmar-JMM-1
12755: PPUSH
12756: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
12760: LD_EXP 48
12764: PPUSH
12765: LD_STRING DOmar-Omar-2
12767: PPUSH
12768: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
12772: LD_EXP 12
12776: PPUSH
12777: LD_STRING DOmar-JMM-2
12779: PPUSH
12780: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
12784: LD_EXP 48
12788: PPUSH
12789: LD_STRING DOmar-Omar-3
12791: PPUSH
12792: CALL_OW 88
// if IsOk ( Burlak ) then
12796: LD_EXP 44
12800: PPUSH
12801: CALL_OW 302
12805: IFFALSE 12821
// Say ( Burlak , DOmar-Bur-3 ) else
12807: LD_EXP 44
12811: PPUSH
12812: LD_STRING DOmar-Bur-3
12814: PPUSH
12815: CALL_OW 88
12819: GO 12833
// Say ( JMM , DOmar-JMM-3 ) ;
12821: LD_EXP 12
12825: PPUSH
12826: LD_STRING DOmar-JMM-3
12828: PPUSH
12829: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
12833: LD_EXP 48
12837: PPUSH
12838: LD_STRING DOmar-Omar-4
12840: PPUSH
12841: CALL_OW 88
// case Query ( QAccept ) of 1 :
12845: LD_STRING QAccept
12847: PPUSH
12848: CALL_OW 97
12852: PUSH
12853: LD_INT 1
12855: DOUBLE
12856: EQUAL
12857: IFTRUE 12861
12859: GO 12897
12861: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
12862: LD_EXP 12
12866: PPUSH
12867: LD_STRING DQrAccept#1-JMM-1
12869: PPUSH
12870: CALL_OW 88
// SetSide ( Omar , 7 ) ;
12874: LD_EXP 48
12878: PPUSH
12879: LD_INT 7
12881: PPUSH
12882: CALL_OW 235
// ComStop ( Omar ) ;
12886: LD_EXP 48
12890: PPUSH
12891: CALL_OW 141
// end ; 2 :
12895: GO 12946
12897: LD_INT 2
12899: DOUBLE
12900: EQUAL
12901: IFTRUE 12905
12903: GO 12945
12905: POP
// begin if IsOk ( Burlak ) then
12906: LD_EXP 44
12910: PPUSH
12911: CALL_OW 302
12915: IFFALSE 12931
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
12917: LD_EXP 44
12921: PPUSH
12922: LD_STRING DQrAccept#2-Bur-1
12924: PPUSH
12925: CALL_OW 88
12929: GO 12943
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
12931: LD_EXP 12
12935: PPUSH
12936: LD_STRING DQrAccept#2-JMM-1
12938: PPUSH
12939: CALL_OW 88
// end ; end ;
12943: GO 12946
12945: POP
// DialogueOff ;
12946: CALL_OW 7
// if GetSide ( Omar ) = 7 then
12950: LD_EXP 48
12954: PPUSH
12955: CALL_OW 255
12959: PUSH
12960: LD_INT 7
12962: EQUAL
12963: IFFALSE 12967
// exit ;
12965: GO 12982
// ComMoveXY ( Omar , 202 , 115 ) ;
12967: LD_EXP 48
12971: PPUSH
12972: LD_INT 202
12974: PPUSH
12975: LD_INT 115
12977: PPUSH
12978: CALL_OW 111
// end ;
12982: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
12983: LD_EXP 48
12987: PPUSH
12988: LD_INT 200
12990: PPUSH
12991: LD_INT 98
12993: PPUSH
12994: CALL_OW 297
12998: PUSH
12999: LD_INT 40
13001: LESS
13002: PUSH
13003: LD_EXP 2
13007: AND
13008: IFFALSE 13226
13010: GO 13012
13012: DISABLE
// begin SetSide ( Omar , 5 ) ;
13013: LD_EXP 48
13017: PPUSH
13018: LD_INT 5
13020: PPUSH
13021: CALL_OW 235
// if IsInUnit ( Omar ) then
13025: LD_EXP 48
13029: PPUSH
13030: CALL_OW 310
13034: IFFALSE 13045
// ComExitVehicle ( Omar ) ;
13036: LD_EXP 48
13040: PPUSH
13041: CALL_OW 121
// if IsInUnit ( Omar ) then
13045: LD_EXP 48
13049: PPUSH
13050: CALL_OW 310
13054: IFFALSE 13065
// ComExitBuilding ( Omar ) ;
13056: LD_EXP 48
13060: PPUSH
13061: CALL_OW 122
// wait ( 0 0$1 ) ;
13065: LD_INT 35
13067: PPUSH
13068: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13072: LD_EXP 48
13076: PPUSH
13077: LD_INT 203
13079: PPUSH
13080: LD_INT 120
13082: PPUSH
13083: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13087: LD_INT 35
13089: PPUSH
13090: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13094: LD_EXP 48
13098: PPUSH
13099: CALL_OW 306
13103: PUSH
13104: LD_EXP 48
13108: PPUSH
13109: LD_INT 203
13111: PPUSH
13112: LD_INT 120
13114: PPUSH
13115: CALL_OW 297
13119: PUSH
13120: LD_INT 6
13122: LESS
13123: OR
13124: IFFALSE 13087
// CenterNowOnUnits ( Omar ) ;
13126: LD_EXP 48
13130: PPUSH
13131: CALL_OW 87
// DialogueOn ;
13135: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13139: LD_EXP 12
13143: PPUSH
13144: LD_STRING DOmarContam-JMM-1
13146: PPUSH
13147: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13151: LD_EXP 48
13155: PPUSH
13156: LD_STRING DOmarContam-Omar-1
13158: PPUSH
13159: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13163: LD_EXP 12
13167: PPUSH
13168: LD_STRING DOmarContam-JMM-2
13170: PPUSH
13171: CALL_OW 88
// DialogueOff ;
13175: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13179: LD_INT 5
13181: PPUSH
13182: LD_INT 7
13184: PPUSH
13185: LD_INT 2
13187: PPUSH
13188: LD_INT 1
13190: PPUSH
13191: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13195: LD_INT 105
13197: PPUSH
13198: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13202: LD_EXP 48
13206: PPUSH
13207: LD_INT 203
13209: PPUSH
13210: LD_INT 120
13212: PPUSH
13213: CALL_OW 307
13217: IFFALSE 13195
// YouLost ( MothContaminate ) ;
13219: LD_STRING MothContaminate
13221: PPUSH
13222: CALL_OW 104
// end ;
13226: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13227: LD_EXP 4
13231: NOT
13232: PUSH
13233: LD_INT 22
13235: PUSH
13236: LD_INT 1
13238: PUSH
13239: EMPTY
13240: LIST
13241: LIST
13242: PUSH
13243: LD_INT 34
13245: PUSH
13246: LD_INT 8
13248: PUSH
13249: EMPTY
13250: LIST
13251: LIST
13252: PUSH
13253: EMPTY
13254: LIST
13255: LIST
13256: PPUSH
13257: CALL_OW 69
13261: AND
13262: IFFALSE 13343
13264: GO 13266
13266: DISABLE
// begin if not IsOk ( Powell ) then
13267: LD_EXP 47
13271: PPUSH
13272: CALL_OW 302
13276: NOT
13277: IFFALSE 13281
// exit ;
13279: GO 13343
// DialogueOn ;
13281: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13285: LD_EXP 47
13289: PPUSH
13290: LD_STRING DWinAmericans-Pow-1
13292: PPUSH
13293: CALL_OW 94
// if IsOk ( Burlak ) then
13297: LD_EXP 44
13301: PPUSH
13302: CALL_OW 302
13306: IFFALSE 13320
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13308: LD_EXP 44
13312: PPUSH
13313: LD_STRING DWinAmericans-Bur-1
13315: PPUSH
13316: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13320: LD_EXP 12
13324: PPUSH
13325: LD_STRING DWinAmericans-JMM-1
13327: PPUSH
13328: CALL_OW 88
// DialogueOff ;
13332: CALL_OW 7
// YouLost ( AmBomb ) ;
13336: LD_STRING AmBomb
13338: PPUSH
13339: CALL_OW 104
// end ;
13343: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13344: LD_EXP 2
13348: NOT
13349: PUSH
13350: LD_INT 22
13352: PUSH
13353: LD_INT 3
13355: PUSH
13356: EMPTY
13357: LIST
13358: LIST
13359: PUSH
13360: LD_INT 34
13362: PUSH
13363: LD_INT 48
13365: PUSH
13366: EMPTY
13367: LIST
13368: LIST
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: PPUSH
13374: CALL_OW 69
13378: AND
13379: IFFALSE 13460
13381: GO 13383
13383: DISABLE
// begin if not IsOk ( Platonov ) then
13384: LD_EXP 51
13388: PPUSH
13389: CALL_OW 302
13393: NOT
13394: IFFALSE 13398
// exit ;
13396: GO 13460
// DialogueOn ;
13398: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13402: LD_EXP 51
13406: PPUSH
13407: LD_STRING DWinRussians-Pla-1
13409: PPUSH
13410: CALL_OW 94
// if IsOk ( Burlak ) then
13414: LD_EXP 44
13418: PPUSH
13419: CALL_OW 302
13423: IFFALSE 13437
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13425: LD_EXP 44
13429: PPUSH
13430: LD_STRING DWinRussians-Bur-1
13432: PPUSH
13433: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13437: LD_EXP 12
13441: PPUSH
13442: LD_STRING DWinRussians-JMM-1
13444: PPUSH
13445: CALL_OW 88
// DialogueOff ;
13449: CALL_OW 7
// YouLost ( RuBomb ) ;
13453: LD_STRING RuBomb
13455: PPUSH
13456: CALL_OW 104
// end ;
13460: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13461: LD_INT 7
13463: PPUSH
13464: LD_INT 22
13466: PUSH
13467: LD_INT 7
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PPUSH
13474: CALL_OW 70
13478: PUSH
13479: LD_EXP 4
13483: NOT
13484: AND
13485: IFFALSE 13514
13487: GO 13489
13489: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13490: LD_EXP 47
13494: PPUSH
13495: LD_STRING DSurrenderAmericans-Pow-1
13497: PPUSH
13498: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
13502: LD_EXP 12
13506: PPUSH
13507: LD_STRING DSurrenderAmericans-JMM-1
13509: PPUSH
13510: CALL_OW 88
// end ;
13514: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
13515: LD_INT 2
13517: PPUSH
13518: LD_INT 22
13520: PUSH
13521: LD_INT 7
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PPUSH
13528: CALL_OW 70
13532: PUSH
13533: LD_EXP 2
13537: NOT
13538: AND
13539: PUSH
13540: LD_EXP 44
13544: AND
13545: IFFALSE 13574
13547: GO 13549
13549: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
13550: LD_EXP 51
13554: PPUSH
13555: LD_STRING DSurrenderRussians-Pla-1
13557: PPUSH
13558: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
13562: LD_EXP 44
13566: PPUSH
13567: LD_STRING DSurrenderRussians-Bur-1
13569: PPUSH
13570: CALL_OW 88
// end ;
13574: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
13575: LD_EXP 4
13579: IFFALSE 13954
13581: GO 13583
13583: DISABLE
13584: LD_INT 0
13586: PPUSH
13587: PPUSH
13588: PPUSH
// begin MC_Kill ( 4 ) ;
13589: LD_INT 4
13591: PPUSH
13592: CALL 19988 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
13596: LD_INT 1
13598: PPUSH
13599: LD_INT 7
13601: PPUSH
13602: LD_INT 1
13604: PPUSH
13605: LD_INT 1
13607: PPUSH
13608: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
13612: LD_ADDR_VAR 0 3
13616: PUSH
13617: LD_INT 22
13619: PUSH
13620: LD_INT 1
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PUSH
13627: LD_INT 26
13629: PUSH
13630: LD_INT 1
13632: PUSH
13633: EMPTY
13634: LIST
13635: LIST
13636: PUSH
13637: LD_INT 23
13639: PUSH
13640: LD_INT 1
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: LIST
13651: PPUSH
13652: CALL_OW 69
13656: PUSH
13657: LD_EXP 47
13661: PUSH
13662: LD_EXP 20
13666: PUSH
13667: LD_EXP 17
13671: PUSH
13672: LD_EXP 16
13676: PUSH
13677: LD_EXP 23
13681: PUSH
13682: LD_EXP 21
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: DIFF
13695: ST_TO_ADDR
// if speaker then
13696: LD_VAR 0 3
13700: IFFALSE 13726
// begin DialogueOn ;
13702: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
13706: LD_VAR 0 3
13710: PUSH
13711: LD_INT 1
13713: ARRAY
13714: PPUSH
13715: LD_STRING DSurrenderAmericans-Sol1-1a
13717: PPUSH
13718: CALL_OW 94
// DialogueOff ;
13722: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
13726: LD_ADDR_VAR 0 2
13730: PUSH
13731: LD_INT 22
13733: PUSH
13734: LD_INT 1
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: PUSH
13741: LD_INT 21
13743: PUSH
13744: LD_INT 1
13746: PUSH
13747: EMPTY
13748: LIST
13749: LIST
13750: PUSH
13751: EMPTY
13752: LIST
13753: LIST
13754: PPUSH
13755: CALL_OW 69
13759: PUSH
13760: LD_INT 22
13762: PUSH
13763: LD_INT 1
13765: PUSH
13766: EMPTY
13767: LIST
13768: LIST
13769: PUSH
13770: LD_INT 21
13772: PUSH
13773: LD_INT 2
13775: PUSH
13776: EMPTY
13777: LIST
13778: LIST
13779: PUSH
13780: LD_INT 1
13782: PUSH
13783: EMPTY
13784: LIST
13785: PUSH
13786: EMPTY
13787: LIST
13788: LIST
13789: LIST
13790: PPUSH
13791: CALL_OW 69
13795: ADD
13796: ST_TO_ADDR
// if tmp then
13797: LD_VAR 0 2
13801: IFFALSE 13954
// repeat wait ( 0 0$1 ) ;
13803: LD_INT 35
13805: PPUSH
13806: CALL_OW 67
// for i in tmp do
13810: LD_ADDR_VAR 0 1
13814: PUSH
13815: LD_VAR 0 2
13819: PUSH
13820: FOR_IN
13821: IFFALSE 13903
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
13823: LD_VAR 0 1
13827: PPUSH
13828: CALL_OW 310
13832: PUSH
13833: LD_VAR 0 1
13837: PPUSH
13838: CALL_OW 310
13842: PPUSH
13843: CALL_OW 247
13847: PUSH
13848: LD_INT 3
13850: EQUAL
13851: AND
13852: IFFALSE 13863
// ComExitBuilding ( i ) ;
13854: LD_VAR 0 1
13858: PPUSH
13859: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
13863: LD_VAR 0 1
13867: PPUSH
13868: LD_INT 122
13870: PPUSH
13871: LD_INT 242
13873: PPUSH
13874: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
13878: LD_VAR 0 1
13882: PPUSH
13883: LD_INT 35
13885: PPUSH
13886: CALL_OW 308
13890: IFFALSE 13901
// RemoveUnit ( i ) ;
13892: LD_VAR 0 1
13896: PPUSH
13897: CALL_OW 64
// end ;
13901: GO 13820
13903: POP
13904: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
13905: LD_INT 22
13907: PUSH
13908: LD_INT 1
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: PUSH
13915: LD_INT 2
13917: PUSH
13918: LD_INT 21
13920: PUSH
13921: LD_INT 1
13923: PUSH
13924: EMPTY
13925: LIST
13926: LIST
13927: PUSH
13928: LD_INT 33
13930: PUSH
13931: LD_INT 1
13933: PUSH
13934: EMPTY
13935: LIST
13936: LIST
13937: PUSH
13938: EMPTY
13939: LIST
13940: LIST
13941: LIST
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: PPUSH
13947: CALL_OW 69
13951: NOT
13952: IFFALSE 13803
// end ;
13954: PPOPN 3
13956: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
13957: LD_EXP 2
13961: IFFALSE 14354
13963: GO 13965
13965: DISABLE
13966: LD_INT 0
13968: PPUSH
13969: PPUSH
13970: PPUSH
// begin repeat wait ( 0 0$1 ) ;
13971: LD_INT 35
13973: PPUSH
13974: CALL_OW 67
// until IsDead ( Yakotich ) ;
13978: LD_EXP 52
13982: PPUSH
13983: CALL_OW 301
13987: IFFALSE 13971
// MC_Kill ( 2 ) ;
13989: LD_INT 2
13991: PPUSH
13992: CALL 19988 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
13996: LD_INT 3
13998: PPUSH
13999: LD_INT 7
14001: PPUSH
14002: LD_INT 1
14004: PPUSH
14005: LD_INT 1
14007: PPUSH
14008: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14012: LD_ADDR_VAR 0 3
14016: PUSH
14017: LD_INT 22
14019: PUSH
14020: LD_INT 3
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PUSH
14027: LD_INT 26
14029: PUSH
14030: LD_INT 1
14032: PUSH
14033: EMPTY
14034: LIST
14035: LIST
14036: PUSH
14037: LD_INT 23
14039: PUSH
14040: LD_INT 3
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: LIST
14051: PPUSH
14052: CALL_OW 69
14056: PUSH
14057: LD_EXP 51
14061: PUSH
14062: LD_EXP 52
14066: PUSH
14067: EMPTY
14068: LIST
14069: LIST
14070: DIFF
14071: ST_TO_ADDR
// if speaker then
14072: LD_VAR 0 3
14076: IFFALSE 14126
// begin DialogueOn ;
14078: CALL_OW 6
// if Burlak then
14082: LD_EXP 44
14086: IFFALSE 14106
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14088: LD_VAR 0 3
14092: PUSH
14093: LD_INT 1
14095: ARRAY
14096: PPUSH
14097: LD_STRING DSurrenderRussians-RSol1-1
14099: PPUSH
14100: CALL_OW 94
14104: GO 14122
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14106: LD_VAR 0 3
14110: PUSH
14111: LD_INT 1
14113: ARRAY
14114: PPUSH
14115: LD_STRING DSurrenderRussians-RSol1-1a
14117: PPUSH
14118: CALL_OW 94
// DialogueOff ;
14122: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14126: LD_ADDR_VAR 0 2
14130: PUSH
14131: LD_INT 22
14133: PUSH
14134: LD_INT 3
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: PUSH
14141: LD_INT 21
14143: PUSH
14144: LD_INT 1
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: PPUSH
14155: CALL_OW 69
14159: PUSH
14160: LD_INT 22
14162: PUSH
14163: LD_INT 3
14165: PUSH
14166: EMPTY
14167: LIST
14168: LIST
14169: PUSH
14170: LD_INT 21
14172: PUSH
14173: LD_INT 2
14175: PUSH
14176: EMPTY
14177: LIST
14178: LIST
14179: PUSH
14180: LD_INT 1
14182: PUSH
14183: EMPTY
14184: LIST
14185: PUSH
14186: EMPTY
14187: LIST
14188: LIST
14189: LIST
14190: PPUSH
14191: CALL_OW 69
14195: ADD
14196: ST_TO_ADDR
// if tmp then
14197: LD_VAR 0 2
14201: IFFALSE 14354
// repeat wait ( 0 0$1 ) ;
14203: LD_INT 35
14205: PPUSH
14206: CALL_OW 67
// for i in tmp do
14210: LD_ADDR_VAR 0 1
14214: PUSH
14215: LD_VAR 0 2
14219: PUSH
14220: FOR_IN
14221: IFFALSE 14303
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14223: LD_VAR 0 1
14227: PPUSH
14228: CALL_OW 310
14232: PUSH
14233: LD_VAR 0 1
14237: PPUSH
14238: CALL_OW 310
14242: PPUSH
14243: CALL_OW 247
14247: PUSH
14248: LD_INT 3
14250: EQUAL
14251: AND
14252: IFFALSE 14263
// ComExitBuilding ( i ) ;
14254: LD_VAR 0 1
14258: PPUSH
14259: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14263: LD_VAR 0 1
14267: PPUSH
14268: LD_INT 154
14270: PPUSH
14271: LD_INT 1
14273: PPUSH
14274: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14278: LD_VAR 0 1
14282: PPUSH
14283: LD_INT 36
14285: PPUSH
14286: CALL_OW 308
14290: IFFALSE 14301
// RemoveUnit ( i ) ;
14292: LD_VAR 0 1
14296: PPUSH
14297: CALL_OW 64
// end ;
14301: GO 14220
14303: POP
14304: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14305: LD_INT 22
14307: PUSH
14308: LD_INT 3
14310: PUSH
14311: EMPTY
14312: LIST
14313: LIST
14314: PUSH
14315: LD_INT 2
14317: PUSH
14318: LD_INT 21
14320: PUSH
14321: LD_INT 1
14323: PUSH
14324: EMPTY
14325: LIST
14326: LIST
14327: PUSH
14328: LD_INT 33
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: EMPTY
14339: LIST
14340: LIST
14341: LIST
14342: PUSH
14343: EMPTY
14344: LIST
14345: LIST
14346: PPUSH
14347: CALL_OW 69
14351: NOT
14352: IFFALSE 14203
// end ;
14354: PPOPN 3
14356: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) do
14357: LD_INT 22
14359: PUSH
14360: LD_INT 8
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: PUSH
14367: LD_INT 21
14369: PUSH
14370: LD_INT 1
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: PUSH
14377: LD_INT 23
14379: PUSH
14380: LD_INT 2
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: LIST
14391: PPUSH
14392: CALL_OW 69
14396: PUSH
14397: LD_INT 18
14399: LESS
14400: PUSH
14401: LD_EXP 50
14405: PPUSH
14406: CALL_OW 301
14410: OR
14411: IFFALSE 14424
14413: GO 14415
14415: DISABLE
// legionDestroyed := true ;
14416: LD_ADDR_EXP 3
14420: PUSH
14421: LD_INT 1
14423: ST_TO_ADDR
14424: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14425: LD_INT 22
14427: PUSH
14428: LD_INT 2
14430: PUSH
14431: EMPTY
14432: LIST
14433: LIST
14434: PUSH
14435: LD_INT 21
14437: PUSH
14438: LD_INT 1
14440: PUSH
14441: EMPTY
14442: LIST
14443: LIST
14444: PUSH
14445: LD_INT 23
14447: PUSH
14448: LD_INT 2
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: PPUSH
14460: CALL_OW 69
14464: PUSH
14465: LD_INT 9
14467: LESS
14468: IFFALSE 14481
14470: GO 14472
14472: DISABLE
// arabianDestroyed := true ;
14473: LD_ADDR_EXP 5
14477: PUSH
14478: LD_INT 1
14480: ST_TO_ADDR
14481: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14482: LD_EXP 5
14486: IFFALSE 14746
14488: GO 14490
14490: DISABLE
14491: LD_INT 0
14493: PPUSH
14494: PPUSH
// begin MC_Kill ( 1 ) ;
14495: LD_INT 1
14497: PPUSH
14498: CALL 19988 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
14502: LD_INT 2
14504: PPUSH
14505: LD_INT 7
14507: PPUSH
14508: LD_INT 1
14510: PPUSH
14511: LD_INT 1
14513: PPUSH
14514: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14518: LD_ADDR_VAR 0 2
14522: PUSH
14523: LD_INT 22
14525: PUSH
14526: LD_INT 2
14528: PUSH
14529: EMPTY
14530: LIST
14531: LIST
14532: PUSH
14533: LD_INT 21
14535: PUSH
14536: LD_INT 1
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: PPUSH
14547: CALL_OW 69
14551: PUSH
14552: LD_INT 22
14554: PUSH
14555: LD_INT 8
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: PUSH
14562: LD_INT 21
14564: PUSH
14565: LD_INT 2
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PUSH
14572: LD_INT 1
14574: PUSH
14575: EMPTY
14576: LIST
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: LIST
14582: PPUSH
14583: CALL_OW 69
14587: ADD
14588: ST_TO_ADDR
// if tmp then
14589: LD_VAR 0 2
14593: IFFALSE 14746
// repeat wait ( 0 0$1 ) ;
14595: LD_INT 35
14597: PPUSH
14598: CALL_OW 67
// for i in tmp do
14602: LD_ADDR_VAR 0 1
14606: PUSH
14607: LD_VAR 0 2
14611: PUSH
14612: FOR_IN
14613: IFFALSE 14695
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14615: LD_VAR 0 1
14619: PPUSH
14620: CALL_OW 310
14624: PUSH
14625: LD_VAR 0 1
14629: PPUSH
14630: CALL_OW 310
14634: PPUSH
14635: CALL_OW 247
14639: PUSH
14640: LD_INT 3
14642: EQUAL
14643: AND
14644: IFFALSE 14655
// ComExitBuilding ( i ) ;
14646: LD_VAR 0 1
14650: PPUSH
14651: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
14655: LD_VAR 0 1
14659: PPUSH
14660: LD_INT 254
14662: PPUSH
14663: LD_INT 268
14665: PPUSH
14666: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
14670: LD_VAR 0 1
14674: PPUSH
14675: LD_INT 34
14677: PPUSH
14678: CALL_OW 308
14682: IFFALSE 14693
// RemoveUnit ( i ) ;
14684: LD_VAR 0 1
14688: PPUSH
14689: CALL_OW 64
// end ;
14693: GO 14612
14695: POP
14696: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14697: LD_INT 22
14699: PUSH
14700: LD_INT 2
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: PUSH
14707: LD_INT 2
14709: PUSH
14710: LD_INT 21
14712: PUSH
14713: LD_INT 1
14715: PUSH
14716: EMPTY
14717: LIST
14718: LIST
14719: PUSH
14720: LD_INT 33
14722: PUSH
14723: LD_INT 1
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: LIST
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: PPUSH
14739: CALL_OW 69
14743: NOT
14744: IFFALSE 14595
// end ;
14746: PPOPN 2
14748: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
14749: LD_EXP 3
14753: IFFALSE 15094
14755: GO 14757
14757: DISABLE
14758: LD_INT 0
14760: PPUSH
14761: PPUSH
// begin MC_Kill ( 3 ) ;
14762: LD_INT 3
14764: PPUSH
14765: CALL 19988 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
14769: LD_INT 8
14771: PPUSH
14772: LD_INT 7
14774: PPUSH
14775: LD_INT 1
14777: PPUSH
14778: LD_INT 1
14780: PPUSH
14781: CALL_OW 80
// DialogueOn ;
14785: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
14789: LD_EXP 49
14793: PPUSH
14794: LD_STRING D15-Szulc-1
14796: PPUSH
14797: CALL_OW 94
// DialogueOff ;
14801: CALL_OW 7
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
14805: LD_ADDR_VAR 0 1
14809: PUSH
14810: LD_INT 22
14812: PUSH
14813: LD_INT 8
14815: PUSH
14816: EMPTY
14817: LIST
14818: LIST
14819: PUSH
14820: LD_INT 21
14822: PUSH
14823: LD_INT 3
14825: PUSH
14826: EMPTY
14827: LIST
14828: LIST
14829: PUSH
14830: LD_INT 23
14832: PUSH
14833: LD_INT 3
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: LIST
14844: PPUSH
14845: CALL_OW 69
14849: PUSH
14850: FOR_IN
14851: IFFALSE 14864
// DestroyUnit ( i ) ;
14853: LD_VAR 0 1
14857: PPUSH
14858: CALL_OW 65
14862: GO 14850
14864: POP
14865: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14866: LD_ADDR_VAR 0 2
14870: PUSH
14871: LD_INT 22
14873: PUSH
14874: LD_INT 8
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 21
14883: PUSH
14884: LD_INT 1
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: PPUSH
14895: CALL_OW 69
14899: PUSH
14900: LD_INT 22
14902: PUSH
14903: LD_INT 8
14905: PUSH
14906: EMPTY
14907: LIST
14908: LIST
14909: PUSH
14910: LD_INT 21
14912: PUSH
14913: LD_INT 2
14915: PUSH
14916: EMPTY
14917: LIST
14918: LIST
14919: PUSH
14920: LD_INT 1
14922: PUSH
14923: EMPTY
14924: LIST
14925: PUSH
14926: EMPTY
14927: LIST
14928: LIST
14929: LIST
14930: PPUSH
14931: CALL_OW 69
14935: ADD
14936: ST_TO_ADDR
// if tmp then
14937: LD_VAR 0 2
14941: IFFALSE 15094
// repeat wait ( 0 0$1 ) ;
14943: LD_INT 35
14945: PPUSH
14946: CALL_OW 67
// for i in tmp do
14950: LD_ADDR_VAR 0 1
14954: PUSH
14955: LD_VAR 0 2
14959: PUSH
14960: FOR_IN
14961: IFFALSE 15043
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14963: LD_VAR 0 1
14967: PPUSH
14968: CALL_OW 310
14972: PUSH
14973: LD_VAR 0 1
14977: PPUSH
14978: CALL_OW 310
14982: PPUSH
14983: CALL_OW 247
14987: PUSH
14988: LD_INT 3
14990: EQUAL
14991: AND
14992: IFFALSE 15003
// ComExitBuilding ( i ) ;
14994: LD_VAR 0 1
14998: PPUSH
14999: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15003: LD_VAR 0 1
15007: PPUSH
15008: LD_INT 10
15010: PPUSH
15011: LD_INT 1
15013: PPUSH
15014: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15018: LD_VAR 0 1
15022: PPUSH
15023: LD_INT 32
15025: PPUSH
15026: CALL_OW 308
15030: IFFALSE 15041
// RemoveUnit ( i ) ;
15032: LD_VAR 0 1
15036: PPUSH
15037: CALL_OW 64
// end ;
15041: GO 14960
15043: POP
15044: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15045: LD_INT 22
15047: PUSH
15048: LD_INT 8
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: PUSH
15055: LD_INT 2
15057: PUSH
15058: LD_INT 21
15060: PUSH
15061: LD_INT 1
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PUSH
15068: LD_INT 33
15070: PUSH
15071: LD_INT 1
15073: PUSH
15074: EMPTY
15075: LIST
15076: LIST
15077: PUSH
15078: EMPTY
15079: LIST
15080: LIST
15081: LIST
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: PPUSH
15087: CALL_OW 69
15091: NOT
15092: IFFALSE 14943
// end ;
15094: PPOPN 2
15096: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do var med1 , med2 ;
15097: LD_EXP 4
15101: PUSH
15102: LD_EXP 2
15106: AND
15107: PUSH
15108: LD_EXP 3
15112: AND
15113: PUSH
15114: LD_EXP 5
15118: AND
15119: IFFALSE 16422
15121: GO 15123
15123: DISABLE
15124: LD_INT 0
15126: PPUSH
15127: PPUSH
// begin music_class := 5 ;
15128: LD_ADDR_OWVAR 72
15132: PUSH
15133: LD_INT 5
15135: ST_TO_ADDR
// music_nat := 5 ;
15136: LD_ADDR_OWVAR 71
15140: PUSH
15141: LD_INT 5
15143: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
15144: LD_EXP 12
15148: PPUSH
15149: CALL_OW 87
// InGameOn ;
15153: CALL_OW 8
// DialogueOn ;
15157: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15161: LD_EXP 12
15165: PPUSH
15166: LD_STRING DEnd-JMM-JMM-1
15168: PPUSH
15169: CALL_OW 88
// if Joan then
15173: LD_EXP 27
15177: IFFALSE 15193
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15179: LD_EXP 27
15183: PPUSH
15184: LD_STRING DEnd-JMM-Joan-1
15186: PPUSH
15187: CALL_OW 88
15191: GO 15237
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15193: LD_EXP 14
15197: PUSH
15198: LD_EXP 14
15202: PPUSH
15203: CALL_OW 255
15207: PUSH
15208: LD_INT 7
15210: EQUAL
15211: AND
15212: PUSH
15213: LD_EXP 14
15217: PPUSH
15218: CALL_OW 305
15222: AND
15223: IFFALSE 15237
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15225: LD_EXP 14
15229: PPUSH
15230: LD_STRING DEnd-JMM-Lisa-1
15232: PPUSH
15233: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15237: LD_EXP 24
15241: PUSH
15242: LD_EXP 24
15246: PPUSH
15247: CALL_OW 305
15251: AND
15252: IFFALSE 15266
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15254: LD_EXP 24
15258: PPUSH
15259: LD_STRING DEnd-JMM-Frank-1
15261: PPUSH
15262: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15266: LD_EXP 17
15270: PUSH
15271: LD_EXP 17
15275: PPUSH
15276: CALL_OW 255
15280: PUSH
15281: LD_INT 7
15283: EQUAL
15284: AND
15285: PUSH
15286: LD_EXP 17
15290: PPUSH
15291: CALL_OW 305
15295: AND
15296: IFFALSE 15310
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15298: LD_EXP 17
15302: PPUSH
15303: LD_STRING DEnd-JMM-Cyrus-1
15305: PPUSH
15306: CALL_OW 88
// if Burlak then
15310: LD_EXP 44
15314: IFFALSE 15328
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15316: LD_EXP 44
15320: PPUSH
15321: LD_STRING DEnd-JMM-Bur-1
15323: PPUSH
15324: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15328: LD_EXP 27
15332: PUSH
15333: LD_EXP 14
15337: AND
15338: PUSH
15339: LD_EXP 14
15343: PPUSH
15344: CALL_OW 255
15348: PUSH
15349: LD_INT 7
15351: EQUAL
15352: AND
15353: PUSH
15354: LD_EXP 14
15358: PPUSH
15359: CALL_OW 305
15363: AND
15364: IFFALSE 15378
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15366: LD_EXP 14
15370: PPUSH
15371: LD_STRING DEnd-Burlak-Lisa-1
15373: PPUSH
15374: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15378: LD_EXP 45
15382: PUSH
15383: LD_EXP 45
15387: PPUSH
15388: CALL_OW 305
15392: AND
15393: IFFALSE 15407
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15395: LD_EXP 45
15399: PPUSH
15400: LD_STRING DEnd-JMM-Bel-1
15402: PPUSH
15403: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15407: LD_EXP 46
15411: PUSH
15412: LD_EXP 46
15416: PPUSH
15417: CALL_OW 305
15421: AND
15422: IFFALSE 15436
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15424: LD_EXP 46
15428: PPUSH
15429: LD_STRING DEnd-JMM-Gny-1
15431: PPUSH
15432: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15436: LD_EXP 22
15440: PUSH
15441: LD_EXP 22
15445: PPUSH
15446: CALL_OW 255
15450: PUSH
15451: LD_INT 7
15453: EQUAL
15454: AND
15455: PUSH
15456: LD_EXP 22
15460: PPUSH
15461: CALL_OW 305
15465: AND
15466: IFFALSE 15480
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
15468: LD_EXP 22
15472: PPUSH
15473: LD_STRING DEnd-JMM-Corn-1
15475: PPUSH
15476: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
15480: LD_EXP 15
15484: PUSH
15485: LD_EXP 15
15489: PPUSH
15490: CALL_OW 255
15494: PUSH
15495: LD_INT 7
15497: EQUAL
15498: AND
15499: PUSH
15500: LD_EXP 15
15504: PPUSH
15505: CALL_OW 305
15509: AND
15510: IFFALSE 15524
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
15512: LD_EXP 15
15516: PPUSH
15517: LD_STRING DEnd-JMM-Don-1
15519: PPUSH
15520: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
15524: LD_EXP 16
15528: PUSH
15529: LD_EXP 16
15533: PPUSH
15534: CALL_OW 255
15538: PUSH
15539: LD_INT 7
15541: EQUAL
15542: AND
15543: PUSH
15544: LD_EXP 16
15548: PPUSH
15549: CALL_OW 305
15553: AND
15554: IFFALSE 15568
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
15556: LD_EXP 16
15560: PPUSH
15561: LD_STRING DEnd-JMM-Bobby-1
15563: PPUSH
15564: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
15568: LD_EXP 18
15572: PUSH
15573: LD_EXP 18
15577: PPUSH
15578: CALL_OW 255
15582: PUSH
15583: LD_INT 7
15585: EQUAL
15586: AND
15587: PUSH
15588: LD_EXP 18
15592: PPUSH
15593: CALL_OW 305
15597: AND
15598: IFFALSE 15612
// Say ( Denis , DEnd-JMM-Den-1 ) ;
15600: LD_EXP 18
15604: PPUSH
15605: LD_STRING DEnd-JMM-Den-1
15607: PPUSH
15608: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
15612: LD_EXP 20
15616: PUSH
15617: LD_EXP 20
15621: PPUSH
15622: CALL_OW 255
15626: PUSH
15627: LD_INT 7
15629: EQUAL
15630: AND
15631: PUSH
15632: LD_EXP 20
15636: PPUSH
15637: CALL_OW 305
15641: AND
15642: IFFALSE 15656
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
15644: LD_EXP 20
15648: PPUSH
15649: LD_STRING DEnd-JMM-Glad-1
15651: PPUSH
15652: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
15656: LD_EXP 25
15660: PUSH
15661: LD_EXP 25
15665: PPUSH
15666: CALL_OW 255
15670: PUSH
15671: LD_INT 7
15673: EQUAL
15674: AND
15675: PUSH
15676: LD_EXP 25
15680: PPUSH
15681: CALL_OW 305
15685: AND
15686: IFFALSE 15700
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
15688: LD_EXP 25
15692: PPUSH
15693: LD_STRING DEnd-JMM-Yam-1
15695: PPUSH
15696: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
15700: LD_EXP 19
15704: PUSH
15705: LD_EXP 19
15709: PPUSH
15710: CALL_OW 255
15714: PUSH
15715: LD_INT 7
15717: EQUAL
15718: AND
15719: PUSH
15720: LD_EXP 19
15724: PPUSH
15725: CALL_OW 305
15729: AND
15730: IFFALSE 15744
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
15732: LD_EXP 19
15736: PPUSH
15737: LD_STRING DEnd-JMM-Brown-1
15739: PPUSH
15740: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
15744: LD_EXP 29
15748: PUSH
15749: LD_EXP 29
15753: PPUSH
15754: CALL_OW 255
15758: PUSH
15759: LD_INT 7
15761: EQUAL
15762: AND
15763: PUSH
15764: LD_EXP 29
15768: PPUSH
15769: CALL_OW 305
15773: AND
15774: IFFALSE 15788
// Say ( Connie , DEnd-JMM-Con-1 ) ;
15776: LD_EXP 29
15780: PPUSH
15781: LD_STRING DEnd-JMM-Con-1
15783: PPUSH
15784: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
15788: LD_EXP 23
15792: PUSH
15793: LD_EXP 23
15797: PPUSH
15798: CALL_OW 255
15802: PUSH
15803: LD_INT 7
15805: EQUAL
15806: AND
15807: PUSH
15808: LD_EXP 23
15812: PPUSH
15813: CALL_OW 305
15817: AND
15818: IFFALSE 15832
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
15820: LD_EXP 23
15824: PPUSH
15825: LD_STRING DEnd-JMM-Gary-1
15827: PPUSH
15828: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
15832: LD_EXP 26
15836: PUSH
15837: LD_EXP 13
15841: AND
15842: PUSH
15843: LD_EXP 26
15847: PPUSH
15848: CALL_OW 305
15852: AND
15853: IFFALSE 15867
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
15855: LD_EXP 26
15859: PPUSH
15860: LD_STRING DEnd-JMM-Sim-1
15862: PPUSH
15863: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
15867: LD_EXP 21
15871: PUSH
15872: LD_EXP 21
15876: PPUSH
15877: CALL_OW 255
15881: PUSH
15882: LD_INT 7
15884: EQUAL
15885: AND
15886: PUSH
15887: LD_EXP 21
15891: PPUSH
15892: CALL_OW 305
15896: AND
15897: IFFALSE 15911
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
15899: LD_EXP 21
15903: PPUSH
15904: LD_STRING DEnd-JMM-VanH-1
15906: PPUSH
15907: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
15911: LD_EXP 34
15915: PUSH
15916: LD_EXP 34
15920: PPUSH
15921: CALL_OW 305
15925: AND
15926: IFFALSE 15940
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
15928: LD_EXP 34
15932: PPUSH
15933: LD_STRING DEnd-JMM-Dol-1
15935: PPUSH
15936: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
15940: LD_EXP 38
15944: PUSH
15945: LD_EXP 38
15949: PPUSH
15950: CALL_OW 305
15954: AND
15955: IFFALSE 15969
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
15957: LD_EXP 38
15961: PPUSH
15962: LD_STRING DEnd-JMM-Kap-1
15964: PPUSH
15965: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
15969: LD_EXP 41
15973: PUSH
15974: LD_EXP 41
15978: PPUSH
15979: CALL_OW 305
15983: AND
15984: IFFALSE 15998
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
15986: LD_EXP 41
15990: PPUSH
15991: LD_STRING DEnd-JMM-Kov-1
15993: PPUSH
15994: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
15998: LD_EXP 36
16002: PUSH
16003: LD_EXP 36
16007: PPUSH
16008: CALL_OW 305
16012: AND
16013: IFFALSE 16027
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16015: LD_EXP 36
16019: PPUSH
16020: LD_STRING DEnd-JMM-Sch-1
16022: PPUSH
16023: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16027: LD_EXP 32
16031: PUSH
16032: LD_EXP 32
16036: PPUSH
16037: CALL_OW 305
16041: AND
16042: IFFALSE 16056
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16044: LD_EXP 32
16048: PPUSH
16049: LD_STRING DEnd-JMM-Tit-1
16051: PPUSH
16052: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16056: LD_EXP 37
16060: PUSH
16061: LD_EXP 37
16065: PPUSH
16066: CALL_OW 305
16070: AND
16071: IFFALSE 16085
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16073: LD_EXP 37
16077: PPUSH
16078: LD_STRING DEnd-JMM-Obl-1
16080: PPUSH
16081: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16085: LD_EXP 39
16089: PUSH
16090: LD_EXP 39
16094: PPUSH
16095: CALL_OW 305
16099: AND
16100: IFFALSE 16114
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16102: LD_EXP 39
16106: PPUSH
16107: LD_STRING DEnd-JMM-Lip-1
16109: PPUSH
16110: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16114: LD_EXP 33
16118: PUSH
16119: LD_EXP 33
16123: PPUSH
16124: CALL_OW 305
16128: AND
16129: PUSH
16130: LD_EXP 44
16134: AND
16135: IFFALSE 16149
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16137: LD_EXP 33
16141: PPUSH
16142: LD_STRING DEnd-Burlak-Fad-1
16144: PPUSH
16145: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16149: LD_EXP 40
16153: PUSH
16154: LD_EXP 40
16158: PPUSH
16159: CALL_OW 305
16163: AND
16164: IFFALSE 16178
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16166: LD_EXP 40
16170: PPUSH
16171: LD_STRING DEnd-Burlak-Ptr-1
16173: PPUSH
16174: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16178: LD_EXP 42
16182: PUSH
16183: LD_EXP 42
16187: PPUSH
16188: CALL_OW 305
16192: AND
16193: IFFALSE 16207
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16195: LD_EXP 42
16199: PPUSH
16200: LD_STRING DEnd-Burlak-Kuz-1
16202: PPUSH
16203: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16207: LD_EXP 31
16211: PUSH
16212: LD_EXP 31
16216: PPUSH
16217: CALL_OW 305
16221: AND
16222: PUSH
16223: LD_EXP 44
16227: AND
16228: IFFALSE 16242
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16230: LD_EXP 31
16234: PPUSH
16235: LD_STRING DEnd-Burlak-Kir-1
16237: PPUSH
16238: CALL_OW 88
// if Burlak then
16242: LD_EXP 44
16246: IFFALSE 16260
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16248: LD_EXP 12
16252: PPUSH
16253: LD_STRING DEnd-Burlak-JMM-1
16255: PPUSH
16256: CALL_OW 88
// dwait ( 0 0$2 ) ;
16260: LD_INT 70
16262: PPUSH
16263: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16267: LD_EXP 49
16271: PPUSH
16272: LD_STRING DEnd-Szulc
16274: PPUSH
16275: CALL_OW 94
// dwait ( 0 0$1 ) ;
16279: LD_INT 35
16281: PPUSH
16282: CALL_OW 68
// if IsLive ( Burlak ) then
16286: LD_EXP 44
16290: PPUSH
16291: CALL_OW 300
16295: IFFALSE 16307
// med1 := 1 else
16297: LD_ADDR_VAR 0 1
16301: PUSH
16302: LD_INT 1
16304: ST_TO_ADDR
16305: GO 16316
// med1 := - 1 ;
16307: LD_ADDR_VAR 0 1
16311: PUSH
16312: LD_INT 1
16314: NEG
16315: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16316: LD_EXP 9
16320: PUSH
16321: LD_EXP 10
16325: AND
16326: PUSH
16327: LD_EXP 11
16331: AND
16332: IFFALSE 16344
// med2 := 1 else
16334: LD_ADDR_VAR 0 2
16338: PUSH
16339: LD_INT 1
16341: ST_TO_ADDR
16342: GO 16353
// med2 := - 1 ;
16344: LD_ADDR_VAR 0 2
16348: PUSH
16349: LD_INT 1
16351: NEG
16352: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
16353: LD_STRING Hero
16355: PPUSH
16356: LD_INT 1
16358: PPUSH
16359: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
16363: LD_STRING Artefact
16365: PPUSH
16366: LD_VAR 0 2
16370: PPUSH
16371: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
16375: LD_STRING ReconcileBurlak
16377: PPUSH
16378: LD_VAR 0 1
16382: PPUSH
16383: CALL_OW 101
// GiveMedals ( MAIN ) ;
16387: LD_STRING MAIN
16389: PPUSH
16390: CALL_OW 102
// InGameOff ;
16394: CALL_OW 9
// DialogueOff ;
16398: CALL_OW 7
// music_nat := 1 ;
16402: LD_ADDR_OWVAR 71
16406: PUSH
16407: LD_INT 1
16409: ST_TO_ADDR
// music_class := 4 ;
16410: LD_ADDR_OWVAR 72
16414: PUSH
16415: LD_INT 4
16417: ST_TO_ADDR
// YouWin ;
16418: CALL_OW 103
// end ; end_of_file
16422: PPOPN 2
16424: END
// export function InitNature ; begin
16425: LD_INT 0
16427: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
16428: LD_INT 3
16430: PPUSH
16431: LD_INT 3
16433: PPUSH
16434: LD_INT 2
16436: PPUSH
16437: LD_INT 1
16439: PPUSH
16440: LD_INT 1
16442: PPUSH
16443: LD_INT 0
16445: PPUSH
16446: LD_INT 0
16448: PPUSH
16449: LD_INT 17
16451: PPUSH
16452: LD_INT 0
16454: PPUSH
16455: CALL 84326 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
16459: LD_INT 2
16461: PPUSH
16462: LD_INT 1
16464: PPUSH
16465: LD_INT 1
16467: PPUSH
16468: LD_INT 1
16470: PPUSH
16471: LD_INT 1
16473: PPUSH
16474: LD_INT 0
16476: PPUSH
16477: LD_INT 0
16479: PPUSH
16480: LD_INT 18
16482: PPUSH
16483: LD_INT 0
16485: PPUSH
16486: CALL 84326 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
16490: LD_INT 4
16492: PPUSH
16493: LD_INT 1
16495: PPUSH
16496: LD_INT 2
16498: PPUSH
16499: LD_INT 4
16501: PPUSH
16502: LD_INT 2
16504: PPUSH
16505: LD_INT 1
16507: PPUSH
16508: LD_INT 0
16510: PPUSH
16511: LD_INT 19
16513: PPUSH
16514: LD_INT 0
16516: PPUSH
16517: CALL 84326 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
16521: LD_INT 0
16523: PPUSH
16524: LD_INT 0
16526: PPUSH
16527: LD_INT 0
16529: PPUSH
16530: LD_INT 0
16532: PPUSH
16533: LD_INT 0
16535: PPUSH
16536: LD_INT 0
16538: PPUSH
16539: LD_INT 9
16541: PPUSH
16542: LD_INT 0
16544: PPUSH
16545: LD_INT 20
16547: PPUSH
16548: CALL 84326 0 9
// end ; end_of_file
16552: LD_VAR 0 1
16556: RET
// every 0 0$30 do var time ;
16557: GO 16559
16559: DISABLE
16560: LD_INT 0
16562: PPUSH
// begin time := 0 0$50 ;
16563: LD_ADDR_VAR 0 1
16567: PUSH
16568: LD_INT 1750
16570: ST_TO_ADDR
// repeat wait ( time ) ;
16571: LD_VAR 0 1
16575: PPUSH
16576: CALL_OW 67
// if Prob ( 50 ) then
16580: LD_INT 50
16582: PPUSH
16583: CALL_OW 13
16587: IFFALSE 16616
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
16589: LD_INT 1
16591: PPUSH
16592: LD_INT 5
16594: PPUSH
16595: CALL_OW 12
16599: PPUSH
16600: LD_INT 106
16602: PPUSH
16603: LD_INT 89
16605: PPUSH
16606: LD_INT 45
16608: PPUSH
16609: LD_INT 1
16611: PPUSH
16612: CALL_OW 56
// time := time + 0 0$3 ;
16616: LD_ADDR_VAR 0 1
16620: PUSH
16621: LD_VAR 0 1
16625: PUSH
16626: LD_INT 105
16628: PLUS
16629: ST_TO_ADDR
// if Prob ( 30 ) then
16630: LD_INT 30
16632: PPUSH
16633: CALL_OW 13
16637: IFFALSE 16683
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
16639: LD_INT 525
16641: PPUSH
16642: LD_INT 735
16644: PPUSH
16645: CALL_OW 12
16649: PPUSH
16650: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
16654: LD_INT 1
16656: PPUSH
16657: LD_INT 5
16659: PPUSH
16660: CALL_OW 12
16664: PPUSH
16665: LD_INT 21
16667: PPUSH
16668: LD_INT 26
16670: PPUSH
16671: LD_INT 12
16673: PPUSH
16674: LD_INT 1
16676: PPUSH
16677: CALL_OW 56
// end else
16681: GO 16719
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
16683: LD_INT 700
16685: PPUSH
16686: LD_INT 1225
16688: PPUSH
16689: CALL_OW 12
16693: PPUSH
16694: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
16698: LD_INT 1
16700: PPUSH
16701: LD_INT 5
16703: PPUSH
16704: CALL_OW 12
16708: PPUSH
16709: LD_INT 14
16711: PPUSH
16712: LD_INT 1
16714: PPUSH
16715: CALL_OW 55
// end ; if Prob ( 50 ) then
16719: LD_INT 50
16721: PPUSH
16722: CALL_OW 13
16726: IFFALSE 16772
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
16728: LD_INT 700
16730: PPUSH
16731: LD_INT 1050
16733: PPUSH
16734: CALL_OW 12
16738: PPUSH
16739: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
16743: LD_INT 1
16745: PPUSH
16746: LD_INT 5
16748: PPUSH
16749: CALL_OW 12
16753: PPUSH
16754: LD_INT 181
16756: PPUSH
16757: LD_INT 218
16759: PPUSH
16760: LD_INT 16
16762: PPUSH
16763: LD_INT 1
16765: PPUSH
16766: CALL_OW 56
// end else
16770: GO 16844
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
16772: LD_INT 350
16774: PPUSH
16775: LD_INT 525
16777: PPUSH
16778: CALL_OW 12
16782: PPUSH
16783: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
16787: LD_INT 1
16789: PPUSH
16790: LD_INT 5
16792: PPUSH
16793: CALL_OW 12
16797: PPUSH
16798: LD_INT 13
16800: PPUSH
16801: LD_INT 1
16803: PPUSH
16804: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
16808: LD_INT 350
16810: PPUSH
16811: LD_INT 700
16813: PPUSH
16814: CALL_OW 12
16818: PPUSH
16819: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
16823: LD_INT 1
16825: PPUSH
16826: LD_INT 5
16828: PPUSH
16829: CALL_OW 12
16833: PPUSH
16834: LD_INT 33
16836: PPUSH
16837: LD_INT 1
16839: PPUSH
16840: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
16844: LD_INT 65
16846: PUSH
16847: LD_INT 62
16849: PUSH
16850: LD_INT 55
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: LIST
16857: PUSH
16858: LD_OWVAR 67
16862: ARRAY
16863: PPUSH
16864: CALL_OW 13
16868: IFFALSE 16914
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
16870: LD_INT 525
16872: PPUSH
16873: LD_INT 875
16875: PPUSH
16876: CALL_OW 12
16880: PPUSH
16881: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
16885: LD_INT 1
16887: PPUSH
16888: LD_INT 5
16890: PPUSH
16891: CALL_OW 12
16895: PPUSH
16896: LD_INT 294
16898: PPUSH
16899: LD_INT 211
16901: PPUSH
16902: LD_INT 30
16904: PPUSH
16905: LD_INT 1
16907: PPUSH
16908: CALL_OW 56
// end else
16912: GO 16956
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
16914: LD_INT 420
16916: PPUSH
16917: LD_INT 770
16919: PPUSH
16920: CALL_OW 12
16924: PPUSH
16925: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
16929: LD_INT 1
16931: PPUSH
16932: LD_INT 5
16934: PPUSH
16935: CALL_OW 12
16939: PPUSH
16940: LD_INT 294
16942: PPUSH
16943: LD_INT 211
16945: PPUSH
16946: LD_INT 30
16948: PPUSH
16949: LD_INT 1
16951: PPUSH
16952: CALL_OW 56
// end ; if time > 2 2$20 then
16956: LD_VAR 0 1
16960: PUSH
16961: LD_INT 4900
16963: GREATER
16964: IFFALSE 16974
// time := 0 0$50 ;
16966: LD_ADDR_VAR 0 1
16970: PUSH
16971: LD_INT 1750
16973: ST_TO_ADDR
// until false ;
16974: LD_INT 0
16976: IFFALSE 16571
// end ;
16978: PPOPN 1
16980: END
// every 0 0$45 trigger tick < 10 10$00 do
16981: LD_OWVAR 1
16985: PUSH
16986: LD_INT 21000
16988: LESS
16989: IFFALSE 17037
16991: GO 16993
16993: DISABLE
// begin enable ;
16994: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
16995: LD_INT 350
16997: PPUSH
16998: LD_INT 700
17000: PPUSH
17001: CALL_OW 12
17005: PPUSH
17006: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17010: LD_INT 3
17012: PPUSH
17013: LD_INT 5
17015: PPUSH
17016: CALL_OW 12
17020: PPUSH
17021: LD_INT 181
17023: PPUSH
17024: LD_INT 13
17026: PPUSH
17027: LD_INT 20
17029: PPUSH
17030: LD_INT 1
17032: PPUSH
17033: CALL_OW 56
// end ; end_of_file
17037: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17038: LD_INT 0
17040: PPUSH
// SetArtifactRes ( 7 , true ) ;
17041: LD_INT 7
17043: PPUSH
17044: LD_INT 1
17046: PPUSH
17047: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17051: LD_ADDR_EXP 57
17055: PUSH
17056: EMPTY
17057: PUSH
17058: EMPTY
17059: PUSH
17060: EMPTY
17061: PUSH
17062: EMPTY
17063: LIST
17064: LIST
17065: LIST
17066: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17067: LD_ADDR_EXP 58
17071: PUSH
17072: LD_INT 1050
17074: PUSH
17075: LD_OWVAR 67
17079: MUL
17080: PUSH
17081: LD_INT 2800
17083: PUSH
17084: LD_OWVAR 67
17088: MUL
17089: PUSH
17090: LD_INT 1
17092: NEG
17093: PUSH
17094: EMPTY
17095: LIST
17096: LIST
17097: LIST
17098: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17099: LD_ADDR_EXP 59
17103: PUSH
17104: LD_INT 10
17106: PUSH
17107: LD_INT 35
17109: PUSH
17110: LD_INT 100
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: LIST
17117: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17118: LD_ADDR_EXP 60
17122: PUSH
17123: LD_INT 0
17125: PUSH
17126: LD_INT 0
17128: PUSH
17129: LD_INT 0
17131: PUSH
17132: EMPTY
17133: LIST
17134: LIST
17135: LIST
17136: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17137: LD_ADDR_EXP 62
17141: PUSH
17142: LD_INT 300
17144: PUSH
17145: LD_INT 500
17147: PUSH
17148: LD_INT 800
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: LIST
17155: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17156: LD_ADDR_EXP 63
17160: PUSH
17161: LD_INT 0
17163: PUSH
17164: LD_INT 0
17166: PUSH
17167: LD_INT 0
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: LIST
17174: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17175: LD_ADDR_EXP 64
17179: PUSH
17180: LD_INT 0
17182: PUSH
17183: LD_INT 0
17185: PUSH
17186: LD_INT 0
17188: PUSH
17189: EMPTY
17190: LIST
17191: LIST
17192: LIST
17193: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17194: LD_ADDR_EXP 61
17198: PUSH
17199: LD_INT 0
17201: PUSH
17202: LD_INT 0
17204: PUSH
17205: LD_INT 0
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: LIST
17212: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17213: LD_ADDR_EXP 65
17217: PUSH
17218: LD_INT 4
17220: PUSH
17221: LD_INT 3
17223: PUSH
17224: LD_INT 1
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: LIST
17231: PUSH
17232: LD_INT 5
17234: PUSH
17235: LD_INT 4
17237: PUSH
17238: LD_INT 2
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: LIST
17245: PUSH
17246: LD_INT 6
17248: PUSH
17249: LD_INT 3
17251: PUSH
17252: LD_INT 3
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: LIST
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: LIST
17264: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17265: LD_ADDR_EXP 66
17269: PUSH
17270: LD_INT 0
17272: PUSH
17273: LD_INT 0
17275: PUSH
17276: LD_INT 0
17278: PUSH
17279: EMPTY
17280: LIST
17281: LIST
17282: LIST
17283: ST_TO_ADDR
// end ;
17284: LD_VAR 0 1
17288: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17289: LD_INT 24
17291: PPUSH
17292: LD_INT 7
17294: PPUSH
17295: CALL_OW 321
17299: PUSH
17300: LD_INT 2
17302: EQUAL
17303: IFFALSE 18229
17305: GO 17307
17307: DISABLE
17308: LD_INT 0
17310: PPUSH
17311: PPUSH
17312: PPUSH
17313: PPUSH
17314: PPUSH
// begin enable ;
17315: ENABLE
// for i = 1 to 3 do
17316: LD_ADDR_VAR 0 1
17320: PUSH
17321: DOUBLE
17322: LD_INT 1
17324: DEC
17325: ST_TO_ADDR
17326: LD_INT 3
17328: PUSH
17329: FOR_TO
17330: IFFALSE 18227
// begin pos := FindArtifact ( i + 2 ) ;
17332: LD_ADDR_VAR 0 2
17336: PUSH
17337: LD_VAR 0 1
17341: PUSH
17342: LD_INT 2
17344: PLUS
17345: PPUSH
17346: CALL_OW 469
17350: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17351: LD_ADDR_EXP 57
17355: PUSH
17356: LD_EXP 57
17360: PPUSH
17361: LD_VAR 0 1
17365: PPUSH
17366: LD_VAR 0 2
17370: PPUSH
17371: CALL_OW 1
17375: ST_TO_ADDR
// if pos then
17376: LD_VAR 0 2
17380: IFFALSE 18088
// begin case i of 1 :
17382: LD_VAR 0 1
17386: PUSH
17387: LD_INT 1
17389: DOUBLE
17390: EQUAL
17391: IFTRUE 17395
17393: GO 17472
17395: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17396: LD_ADDR_VAR 0 4
17400: PUSH
17401: LD_INT 22
17403: PUSH
17404: LD_INT 7
17406: PUSH
17407: EMPTY
17408: LIST
17409: LIST
17410: PUSH
17411: LD_INT 23
17413: PUSH
17414: LD_INT 1
17416: PUSH
17417: EMPTY
17418: LIST
17419: LIST
17420: PUSH
17421: LD_INT 2
17423: PUSH
17424: LD_INT 30
17426: PUSH
17427: LD_INT 8
17429: PUSH
17430: EMPTY
17431: LIST
17432: LIST
17433: PUSH
17434: LD_INT 30
17436: PUSH
17437: LD_INT 7
17439: PUSH
17440: EMPTY
17441: LIST
17442: LIST
17443: PUSH
17444: LD_INT 30
17446: PUSH
17447: LD_INT 11
17449: PUSH
17450: EMPTY
17451: LIST
17452: LIST
17453: PUSH
17454: EMPTY
17455: LIST
17456: LIST
17457: LIST
17458: LIST
17459: PUSH
17460: EMPTY
17461: LIST
17462: LIST
17463: LIST
17464: PPUSH
17465: CALL_OW 69
17469: ST_TO_ADDR
17470: GO 17580
17472: LD_INT 2
17474: DOUBLE
17475: EQUAL
17476: IFTRUE 17480
17478: GO 17557
17480: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
17481: LD_ADDR_VAR 0 4
17485: PUSH
17486: LD_INT 22
17488: PUSH
17489: LD_INT 7
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: LD_INT 23
17498: PUSH
17499: LD_INT 3
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: PUSH
17506: LD_INT 2
17508: PUSH
17509: LD_INT 30
17511: PUSH
17512: LD_INT 8
17514: PUSH
17515: EMPTY
17516: LIST
17517: LIST
17518: PUSH
17519: LD_INT 30
17521: PUSH
17522: LD_INT 7
17524: PUSH
17525: EMPTY
17526: LIST
17527: LIST
17528: PUSH
17529: LD_INT 30
17531: PUSH
17532: LD_INT 11
17534: PUSH
17535: EMPTY
17536: LIST
17537: LIST
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: LIST
17543: LIST
17544: PUSH
17545: EMPTY
17546: LIST
17547: LIST
17548: LIST
17549: PPUSH
17550: CALL_OW 69
17554: ST_TO_ADDR
17555: GO 17580
17557: LD_INT 3
17559: DOUBLE
17560: EQUAL
17561: IFTRUE 17565
17563: GO 17579
17565: POP
// labs := [ alien ] ; end ;
17566: LD_ADDR_VAR 0 4
17570: PUSH
17571: LD_INT 1
17573: PUSH
17574: EMPTY
17575: LIST
17576: ST_TO_ADDR
17577: GO 17580
17579: POP
// if not labs then
17580: LD_VAR 0 4
17584: NOT
17585: IFFALSE 17589
// continue ;
17587: GO 17329
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
17589: LD_ADDR_VAR 0 5
17593: PUSH
17594: LD_VAR 0 4
17598: PPUSH
17599: LD_EXP 57
17603: PUSH
17604: LD_VAR 0 1
17608: ARRAY
17609: PUSH
17610: LD_INT 1
17612: ARRAY
17613: PPUSH
17614: LD_EXP 57
17618: PUSH
17619: LD_VAR 0 1
17623: ARRAY
17624: PUSH
17625: LD_INT 2
17627: ARRAY
17628: PPUSH
17629: CALL_OW 73
17633: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
17634: LD_VAR 0 5
17638: NOT
17639: PUSH
17640: LD_VAR 0 5
17644: PUSH
17645: LD_EXP 64
17649: PUSH
17650: LD_VAR 0 1
17654: ARRAY
17655: NONEQUAL
17656: OR
17657: IFFALSE 17762
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
17659: LD_INT 7
17661: PPUSH
17662: LD_EXP 65
17666: PUSH
17667: LD_VAR 0 1
17671: ARRAY
17672: PUSH
17673: LD_INT 3
17675: ARRAY
17676: PPUSH
17677: LD_INT 0
17679: PPUSH
17680: LD_EXP 64
17684: PUSH
17685: LD_VAR 0 1
17689: ARRAY
17690: PPUSH
17691: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
17695: LD_INT 7
17697: PPUSH
17698: LD_EXP 65
17702: PUSH
17703: LD_VAR 0 1
17707: ARRAY
17708: PUSH
17709: LD_INT 1
17711: ARRAY
17712: PPUSH
17713: LD_INT 0
17715: PPUSH
17716: LD_EXP 64
17720: PUSH
17721: LD_VAR 0 1
17725: ARRAY
17726: PPUSH
17727: CALL_OW 468
// if nearestLab then
17731: LD_VAR 0 5
17735: IFFALSE 17762
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
17737: LD_ADDR_EXP 64
17741: PUSH
17742: LD_EXP 64
17746: PPUSH
17747: LD_VAR 0 1
17751: PPUSH
17752: LD_VAR 0 5
17756: PPUSH
17757: CALL_OW 1
17761: ST_TO_ADDR
// end ; if not nearestLab then
17762: LD_VAR 0 5
17766: NOT
17767: IFFALSE 17771
// continue ;
17769: GO 17329
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
17771: LD_VAR 0 5
17775: PPUSH
17776: LD_EXP 57
17780: PUSH
17781: LD_VAR 0 1
17785: ARRAY
17786: PUSH
17787: LD_INT 1
17789: ARRAY
17790: PPUSH
17791: LD_EXP 57
17795: PUSH
17796: LD_VAR 0 1
17800: ARRAY
17801: PUSH
17802: LD_INT 2
17804: ARRAY
17805: PPUSH
17806: CALL_OW 297
17810: PUSH
17811: LD_INT 8
17813: LESS
17814: IFFALSE 18011
// begin if not artifactsResearched [ i ] then
17816: LD_EXP 60
17820: PUSH
17821: LD_VAR 0 1
17825: ARRAY
17826: NOT
17827: IFFALSE 17908
// begin if BuildingStatus ( nearestLab ) = bs_idle then
17829: LD_VAR 0 5
17833: PPUSH
17834: CALL_OW 461
17838: PUSH
17839: LD_INT 2
17841: EQUAL
17842: IFFALSE 17876
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
17844: LD_INT 7
17846: PPUSH
17847: LD_EXP 65
17851: PUSH
17852: LD_VAR 0 1
17856: ARRAY
17857: PUSH
17858: LD_INT 3
17860: ARRAY
17861: PPUSH
17862: LD_INT 2
17864: PPUSH
17865: LD_VAR 0 5
17869: PPUSH
17870: CALL_OW 468
17874: GO 17906
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
17876: LD_INT 7
17878: PPUSH
17879: LD_EXP 65
17883: PUSH
17884: LD_VAR 0 1
17888: ARRAY
17889: PUSH
17890: LD_INT 3
17892: ARRAY
17893: PPUSH
17894: LD_INT 1
17896: PPUSH
17897: LD_VAR 0 5
17901: PPUSH
17902: CALL_OW 468
// end else
17906: GO 18009
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
17908: LD_VAR 0 5
17912: PPUSH
17913: CALL_OW 461
17917: PUSH
17918: LD_INT 2
17920: EQUAL
17921: PUSH
17922: LD_EXP 66
17926: PUSH
17927: LD_VAR 0 1
17931: ARRAY
17932: AND
17933: IFFALSE 17979
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
17935: LD_INT 7
17937: PPUSH
17938: LD_EXP 65
17942: PUSH
17943: LD_VAR 0 1
17947: ARRAY
17948: PUSH
17949: LD_INT 1
17951: ARRAY
17952: PPUSH
17953: LD_EXP 65
17957: PUSH
17958: LD_VAR 0 1
17962: ARRAY
17963: PUSH
17964: LD_INT 2
17966: ARRAY
17967: PPUSH
17968: LD_VAR 0 5
17972: PPUSH
17973: CALL_OW 468
17977: GO 18009
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
17979: LD_INT 7
17981: PPUSH
17982: LD_EXP 65
17986: PUSH
17987: LD_VAR 0 1
17991: ARRAY
17992: PUSH
17993: LD_INT 1
17995: ARRAY
17996: PPUSH
17997: LD_INT 1
17999: PPUSH
18000: LD_VAR 0 5
18004: PPUSH
18005: CALL_OW 468
// end else
18009: GO 18086
// begin if not artifactsResearched [ i ] then
18011: LD_EXP 60
18015: PUSH
18016: LD_VAR 0 1
18020: ARRAY
18021: NOT
18022: IFFALSE 18056
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18024: LD_INT 7
18026: PPUSH
18027: LD_EXP 65
18031: PUSH
18032: LD_VAR 0 1
18036: ARRAY
18037: PUSH
18038: LD_INT 3
18040: ARRAY
18041: PPUSH
18042: LD_INT 0
18044: PPUSH
18045: LD_VAR 0 5
18049: PPUSH
18050: CALL_OW 468
18054: GO 18086
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18056: LD_INT 7
18058: PPUSH
18059: LD_EXP 65
18063: PUSH
18064: LD_VAR 0 1
18068: ARRAY
18069: PUSH
18070: LD_INT 1
18072: ARRAY
18073: PPUSH
18074: LD_INT 0
18076: PPUSH
18077: LD_VAR 0 5
18081: PPUSH
18082: CALL_OW 468
// end ; end else
18086: GO 18225
// begin if not artifactsLabs [ i ] then
18088: LD_EXP 64
18092: PUSH
18093: LD_VAR 0 1
18097: ARRAY
18098: NOT
18099: IFFALSE 18103
// continue ;
18101: GO 17329
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18103: LD_INT 7
18105: PPUSH
18106: LD_EXP 65
18110: PUSH
18111: LD_VAR 0 1
18115: ARRAY
18116: PUSH
18117: LD_INT 3
18119: ARRAY
18120: PPUSH
18121: LD_INT 0
18123: PPUSH
18124: LD_EXP 64
18128: PUSH
18129: LD_VAR 0 1
18133: ARRAY
18134: PPUSH
18135: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18139: LD_INT 7
18141: PPUSH
18142: LD_EXP 65
18146: PUSH
18147: LD_VAR 0 1
18151: ARRAY
18152: PUSH
18153: LD_INT 1
18155: ARRAY
18156: PPUSH
18157: LD_INT 0
18159: PPUSH
18160: LD_EXP 64
18164: PUSH
18165: LD_VAR 0 1
18169: ARRAY
18170: PPUSH
18171: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18175: LD_EXP 61
18179: PUSH
18180: LD_VAR 0 1
18184: ARRAY
18185: IFFALSE 18225
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18187: LD_ADDR_EXP 61
18191: PUSH
18192: LD_EXP 61
18196: PPUSH
18197: LD_VAR 0 1
18201: PPUSH
18202: LD_INT 0
18204: PPUSH
18205: CALL_OW 1
18209: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18210: LD_EXP 64
18214: PUSH
18215: LD_VAR 0 1
18219: ARRAY
18220: PPUSH
18221: CALL_OW 127
// end ; end ; end ;
18225: GO 17329
18227: POP
18228: POP
// end ;
18229: PPOPN 5
18231: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18232: LD_INT 0
18234: PPUSH
18235: PPUSH
18236: PPUSH
18237: PPUSH
18238: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18239: LD_VAR 0 2
18243: PUSH
18244: LD_EXP 65
18248: PUSH
18249: LD_INT 1
18251: ARRAY
18252: PUSH
18253: LD_INT 3
18255: ARRAY
18256: EQUAL
18257: IFFALSE 18380
// begin lab := artifactsLabs [ 1 ] ;
18259: LD_ADDR_VAR 0 6
18263: PUSH
18264: LD_EXP 64
18268: PUSH
18269: LD_INT 1
18271: ARRAY
18272: ST_TO_ADDR
// if not lab then
18273: LD_VAR 0 6
18277: NOT
18278: IFFALSE 18282
// exit ;
18280: GO 19314
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18282: LD_VAR 0 6
18286: PPUSH
18287: LD_EXP 62
18291: PUSH
18292: LD_INT 1
18294: ARRAY
18295: PPUSH
18296: LD_INT 1
18298: PPUSH
18299: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18303: LD_EXP 63
18307: PUSH
18308: LD_INT 1
18310: ARRAY
18311: IFFALSE 18331
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18313: LD_VAR 0 6
18317: PPUSH
18318: LD_EXP 63
18322: PUSH
18323: LD_INT 1
18325: ARRAY
18326: PPUSH
18327: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18331: LD_ADDR_EXP 61
18335: PUSH
18336: LD_EXP 61
18340: PPUSH
18341: LD_INT 1
18343: PPUSH
18344: LD_INT 1
18346: PPUSH
18347: CALL_OW 1
18351: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18352: LD_INT 7
18354: PPUSH
18355: LD_EXP 65
18359: PUSH
18360: LD_INT 1
18362: ARRAY
18363: PUSH
18364: LD_INT 3
18366: ARRAY
18367: PPUSH
18368: LD_INT 0
18370: PPUSH
18371: LD_VAR 0 6
18375: PPUSH
18376: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18380: LD_VAR 0 2
18384: PUSH
18385: LD_EXP 65
18389: PUSH
18390: LD_INT 2
18392: ARRAY
18393: PUSH
18394: LD_INT 3
18396: ARRAY
18397: EQUAL
18398: IFFALSE 18521
// begin lab := artifactsLabs [ 2 ] ;
18400: LD_ADDR_VAR 0 6
18404: PUSH
18405: LD_EXP 64
18409: PUSH
18410: LD_INT 2
18412: ARRAY
18413: ST_TO_ADDR
// if not lab then
18414: LD_VAR 0 6
18418: NOT
18419: IFFALSE 18423
// exit ;
18421: GO 19314
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
18423: LD_VAR 0 6
18427: PPUSH
18428: LD_EXP 62
18432: PUSH
18433: LD_INT 2
18435: ARRAY
18436: PPUSH
18437: LD_INT 1
18439: PPUSH
18440: CALL_OW 486
// if artifactsResProgress [ 2 ] then
18444: LD_EXP 63
18448: PUSH
18449: LD_INT 2
18451: ARRAY
18452: IFFALSE 18472
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
18454: LD_VAR 0 6
18458: PPUSH
18459: LD_EXP 63
18463: PUSH
18464: LD_INT 2
18466: ARRAY
18467: PPUSH
18468: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
18472: LD_ADDR_EXP 61
18476: PUSH
18477: LD_EXP 61
18481: PPUSH
18482: LD_INT 2
18484: PPUSH
18485: LD_INT 1
18487: PPUSH
18488: CALL_OW 1
18492: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
18493: LD_INT 7
18495: PPUSH
18496: LD_EXP 65
18500: PUSH
18501: LD_INT 2
18503: ARRAY
18504: PUSH
18505: LD_INT 3
18507: ARRAY
18508: PPUSH
18509: LD_INT 0
18511: PPUSH
18512: LD_VAR 0 6
18516: PPUSH
18517: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
18521: LD_VAR 0 2
18525: PUSH
18526: LD_EXP 65
18530: PUSH
18531: LD_INT 3
18533: ARRAY
18534: PUSH
18535: LD_INT 3
18537: ARRAY
18538: EQUAL
18539: IFFALSE 18662
// begin lab := artifactsLabs [ 3 ] ;
18541: LD_ADDR_VAR 0 6
18545: PUSH
18546: LD_EXP 64
18550: PUSH
18551: LD_INT 3
18553: ARRAY
18554: ST_TO_ADDR
// if not lab then
18555: LD_VAR 0 6
18559: NOT
18560: IFFALSE 18564
// exit ;
18562: GO 19314
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
18564: LD_VAR 0 6
18568: PPUSH
18569: LD_EXP 62
18573: PUSH
18574: LD_INT 3
18576: ARRAY
18577: PPUSH
18578: LD_INT 1
18580: PPUSH
18581: CALL_OW 486
// if artifactsResProgress [ 3 ] then
18585: LD_EXP 63
18589: PUSH
18590: LD_INT 3
18592: ARRAY
18593: IFFALSE 18613
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
18595: LD_VAR 0 6
18599: PPUSH
18600: LD_EXP 63
18604: PUSH
18605: LD_INT 3
18607: ARRAY
18608: PPUSH
18609: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
18613: LD_ADDR_EXP 61
18617: PUSH
18618: LD_EXP 61
18622: PPUSH
18623: LD_INT 3
18625: PPUSH
18626: LD_INT 1
18628: PPUSH
18629: CALL_OW 1
18633: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
18634: LD_INT 7
18636: PPUSH
18637: LD_EXP 65
18641: PUSH
18642: LD_INT 3
18644: ARRAY
18645: PUSH
18646: LD_INT 3
18648: ARRAY
18649: PPUSH
18650: LD_INT 0
18652: PPUSH
18653: LD_VAR 0 6
18657: PPUSH
18658: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
18662: LD_VAR 0 2
18666: PUSH
18667: LD_EXP 65
18671: PUSH
18672: LD_INT 1
18674: ARRAY
18675: PUSH
18676: LD_INT 1
18678: ARRAY
18679: EQUAL
18680: IFFALSE 18838
// begin lab := artifactsLabs [ 1 ] ;
18682: LD_ADDR_VAR 0 6
18686: PUSH
18687: LD_EXP 64
18691: PUSH
18692: LD_INT 1
18694: ARRAY
18695: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
18696: LD_VAR 0 6
18700: PPUSH
18701: CALL_OW 274
18705: PPUSH
18706: CALL 92474 0 1
18710: PUSH
18711: LD_INT 3
18713: ARRAY
18714: PUSH
18715: LD_EXP 59
18719: PUSH
18720: LD_INT 1
18722: ARRAY
18723: LESS
18724: IFFALSE 18738
// begin HintSpec ( ArtifactCost , 2 ) ;
18726: LD_STRING ArtifactCost
18728: PPUSH
18729: LD_INT 2
18731: PPUSH
18732: CALL_OW 338
// exit ;
18736: GO 19314
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
18738: LD_ADDR_EXP 66
18742: PUSH
18743: LD_EXP 66
18747: PPUSH
18748: LD_INT 1
18750: PPUSH
18751: LD_INT 0
18753: PPUSH
18754: CALL_OW 1
18758: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
18759: LD_VAR 0 3
18763: PPUSH
18764: LD_VAR 0 4
18768: PPUSH
18769: LD_INT 7
18771: PPUSH
18772: LD_INT 12
18774: NEG
18775: PPUSH
18776: CALL_OW 330
// wait ( 0 0$30 ) ;
18780: LD_INT 1050
18782: PPUSH
18783: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
18787: LD_VAR 0 3
18791: PPUSH
18792: LD_VAR 0 4
18796: PPUSH
18797: LD_INT 7
18799: PPUSH
18800: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
18804: LD_EXP 58
18808: PUSH
18809: LD_INT 1
18811: ARRAY
18812: PPUSH
18813: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
18817: LD_ADDR_EXP 66
18821: PUSH
18822: LD_EXP 66
18826: PPUSH
18827: LD_INT 1
18829: PPUSH
18830: LD_INT 1
18832: PPUSH
18833: CALL_OW 1
18837: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
18838: LD_VAR 0 2
18842: PUSH
18843: LD_EXP 65
18847: PUSH
18848: LD_INT 2
18850: ARRAY
18851: PUSH
18852: LD_INT 1
18854: ARRAY
18855: EQUAL
18856: IFFALSE 19068
// begin lab := artifactsLabs [ 2 ] ;
18858: LD_ADDR_VAR 0 6
18862: PUSH
18863: LD_EXP 64
18867: PUSH
18868: LD_INT 2
18870: ARRAY
18871: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
18872: LD_VAR 0 3
18876: PUSH
18877: LD_INT 81
18879: PUSH
18880: LD_INT 7
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: PUSH
18887: LD_INT 2
18889: PUSH
18890: LD_INT 32
18892: PUSH
18893: LD_INT 3
18895: PUSH
18896: EMPTY
18897: LIST
18898: LIST
18899: PUSH
18900: LD_INT 30
18902: PUSH
18903: LD_INT 28
18905: PUSH
18906: EMPTY
18907: LIST
18908: LIST
18909: PUSH
18910: LD_INT 30
18912: PUSH
18913: LD_INT 30
18915: PUSH
18916: EMPTY
18917: LIST
18918: LIST
18919: PUSH
18920: LD_INT 35
18922: PUSH
18923: LD_INT 49
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: PUSH
18930: LD_INT 34
18932: PUSH
18933: LD_INT 49
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: PUSH
18940: EMPTY
18941: LIST
18942: LIST
18943: LIST
18944: LIST
18945: LIST
18946: LIST
18947: PUSH
18948: EMPTY
18949: LIST
18950: LIST
18951: PPUSH
18952: CALL_OW 69
18956: IN
18957: NOT
18958: IFFALSE 18962
// exit ;
18960: GO 19314
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
18962: LD_VAR 0 6
18966: PPUSH
18967: CALL_OW 274
18971: PPUSH
18972: CALL 92474 0 1
18976: PUSH
18977: LD_INT 3
18979: ARRAY
18980: PUSH
18981: LD_EXP 59
18985: PUSH
18986: LD_INT 2
18988: ARRAY
18989: LESS
18990: IFFALSE 19004
// begin HintSpec ( ArtifactCost , 2 ) ;
18992: LD_STRING ArtifactCost
18994: PPUSH
18995: LD_INT 2
18997: PPUSH
18998: CALL_OW 338
// exit ;
19002: GO 19314
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19004: LD_ADDR_EXP 66
19008: PUSH
19009: LD_EXP 66
19013: PPUSH
19014: LD_INT 2
19016: PPUSH
19017: LD_INT 0
19019: PPUSH
19020: CALL_OW 1
19024: ST_TO_ADDR
// KillUnit ( x ) ;
19025: LD_VAR 0 3
19029: PPUSH
19030: CALL_OW 66
// wait ( artifactsRecharge [ 2 ] ) ;
19034: LD_EXP 58
19038: PUSH
19039: LD_INT 2
19041: ARRAY
19042: PPUSH
19043: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19047: LD_ADDR_EXP 66
19051: PUSH
19052: LD_EXP 66
19056: PPUSH
19057: LD_INT 2
19059: PPUSH
19060: LD_INT 1
19062: PPUSH
19063: CALL_OW 1
19067: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19068: LD_VAR 0 2
19072: PUSH
19073: LD_EXP 65
19077: PUSH
19078: LD_INT 3
19080: ARRAY
19081: PUSH
19082: LD_INT 1
19084: ARRAY
19085: EQUAL
19086: IFFALSE 19314
// begin lab := artifactsLabs [ 3 ] ;
19088: LD_ADDR_VAR 0 6
19092: PUSH
19093: LD_EXP 64
19097: PUSH
19098: LD_INT 3
19100: ARRAY
19101: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19102: LD_VAR 0 6
19106: PPUSH
19107: CALL_OW 274
19111: PPUSH
19112: CALL 92474 0 1
19116: PUSH
19117: LD_INT 3
19119: ARRAY
19120: PUSH
19121: LD_EXP 59
19125: PUSH
19126: LD_INT 3
19128: ARRAY
19129: LESS
19130: IFFALSE 19144
// begin HintSpec ( ArtifactCost , 2 ) ;
19132: LD_STRING ArtifactCost
19134: PPUSH
19135: LD_INT 2
19137: PPUSH
19138: CALL_OW 338
// exit ;
19142: GO 19314
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19144: LD_INT 37
19146: PPUSH
19147: LD_INT 1
19149: PPUSH
19150: CALL_OW 424
// time := 0 0$30 ;
19154: LD_ADDR_VAR 0 7
19158: PUSH
19159: LD_INT 1050
19161: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
19162: LD_ADDR_OWVAR 47
19166: PUSH
19167: LD_STRING Am15a-1
19169: PUSH
19170: LD_VAR 0 7
19174: PUSH
19175: EMPTY
19176: LIST
19177: LIST
19178: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19179: LD_INT 35
19181: PPUSH
19182: CALL_OW 67
// time := time - 0 0$1 ;
19186: LD_ADDR_VAR 0 7
19190: PUSH
19191: LD_VAR 0 7
19195: PUSH
19196: LD_INT 35
19198: MINUS
19199: ST_TO_ADDR
// until time = 0 0$00 ;
19200: LD_VAR 0 7
19204: PUSH
19205: LD_INT 0
19207: EQUAL
19208: IFFALSE 19162
// display_strings :=  ;
19210: LD_ADDR_OWVAR 47
19214: PUSH
19215: LD_STRING 
19217: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19218: LD_INT 37
19220: PPUSH
19221: LD_INT 0
19223: PPUSH
19224: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19228: LD_ADDR_VAR 0 8
19232: PUSH
19233: LD_INT 37
19235: PPUSH
19236: LD_INT 3
19238: PUSH
19239: LD_INT 21
19241: PUSH
19242: LD_INT 3
19244: PUSH
19245: EMPTY
19246: LIST
19247: LIST
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PPUSH
19253: CALL_OW 70
19257: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19258: LD_VAR 0 3
19262: PPUSH
19263: LD_VAR 0 4
19267: PPUSH
19268: CALL_OW 84
// for un in list do
19272: LD_ADDR_VAR 0 9
19276: PUSH
19277: LD_VAR 0 8
19281: PUSH
19282: FOR_IN
19283: IFFALSE 19312
// TeleportUnit ( un , x , y , 12 , true ) ;
19285: LD_VAR 0 9
19289: PPUSH
19290: LD_VAR 0 3
19294: PPUSH
19295: LD_VAR 0 4
19299: PPUSH
19300: LD_INT 12
19302: PPUSH
19303: LD_INT 1
19305: PPUSH
19306: CALL_OW 483
19310: GO 19282
19312: POP
19313: POP
// end ; end ;
19314: PPOPN 9
19316: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19317: LD_INT 0
19319: PPUSH
19320: PPUSH
// begin labNum := 0 ;
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_INT 0
19328: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19329: LD_ADDR_VAR 0 3
19333: PUSH
19334: DOUBLE
19335: LD_INT 1
19337: DEC
19338: ST_TO_ADDR
19339: LD_EXP 64
19343: PUSH
19344: FOR_TO
19345: IFFALSE 19379
// if artifactsLabs [ i ] = lab then
19347: LD_EXP 64
19351: PUSH
19352: LD_VAR 0 3
19356: ARRAY
19357: PUSH
19358: LD_VAR 0 1
19362: EQUAL
19363: IFFALSE 19377
// begin labNum := i ;
19365: LD_ADDR_VAR 0 4
19369: PUSH
19370: LD_VAR 0 3
19374: ST_TO_ADDR
// break ;
19375: GO 19379
// end ;
19377: GO 19344
19379: POP
19380: POP
// if not labNum then
19381: LD_VAR 0 4
19385: NOT
19386: IFFALSE 19390
// exit ;
19388: GO 19468
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
19390: LD_INT 7
19392: PPUSH
19393: LD_EXP 65
19397: PUSH
19398: LD_VAR 0 4
19402: ARRAY
19403: PUSH
19404: LD_INT 3
19406: ARRAY
19407: PPUSH
19408: LD_INT 2
19410: PPUSH
19411: LD_VAR 0 1
19415: PPUSH
19416: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
19420: LD_ADDR_EXP 63
19424: PUSH
19425: LD_EXP 63
19429: PPUSH
19430: LD_VAR 0 4
19434: PPUSH
19435: LD_VAR 0 2
19439: PPUSH
19440: CALL_OW 1
19444: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
19445: LD_ADDR_EXP 61
19449: PUSH
19450: LD_EXP 61
19454: PPUSH
19455: LD_VAR 0 4
19459: PPUSH
19460: LD_INT 0
19462: PPUSH
19463: CALL_OW 1
19467: ST_TO_ADDR
// end ;
19468: PPOPN 4
19470: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
19471: LD_INT 0
19473: PPUSH
19474: PPUSH
// begin labNum := 0 ;
19475: LD_ADDR_VAR 0 3
19479: PUSH
19480: LD_INT 0
19482: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19483: LD_ADDR_VAR 0 2
19487: PUSH
19488: DOUBLE
19489: LD_INT 1
19491: DEC
19492: ST_TO_ADDR
19493: LD_EXP 64
19497: PUSH
19498: FOR_TO
19499: IFFALSE 19533
// if artifactsLabs [ i ] = lab then
19501: LD_EXP 64
19505: PUSH
19506: LD_VAR 0 2
19510: ARRAY
19511: PUSH
19512: LD_VAR 0 1
19516: EQUAL
19517: IFFALSE 19531
// begin labNum := i ;
19519: LD_ADDR_VAR 0 3
19523: PUSH
19524: LD_VAR 0 2
19528: ST_TO_ADDR
// break ;
19529: GO 19533
// end ;
19531: GO 19498
19533: POP
19534: POP
// if not labNum then
19535: LD_VAR 0 3
19539: NOT
19540: IFFALSE 19544
// exit ;
19542: GO 19706
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
19544: LD_INT 7
19546: PPUSH
19547: LD_EXP 65
19551: PUSH
19552: LD_VAR 0 3
19556: ARRAY
19557: PUSH
19558: LD_INT 3
19560: ARRAY
19561: PPUSH
19562: LD_INT 0
19564: PPUSH
19565: LD_VAR 0 1
19569: PPUSH
19570: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
19574: LD_ADDR_EXP 60
19578: PUSH
19579: LD_EXP 60
19583: PPUSH
19584: LD_VAR 0 3
19588: PPUSH
19589: LD_INT 1
19591: PPUSH
19592: CALL_OW 1
19596: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
19597: LD_ADDR_EXP 66
19601: PUSH
19602: LD_EXP 66
19606: PPUSH
19607: LD_VAR 0 3
19611: PPUSH
19612: LD_INT 1
19614: PPUSH
19615: CALL_OW 1
19619: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
19620: LD_ADDR_EXP 61
19624: PUSH
19625: LD_EXP 61
19629: PPUSH
19630: LD_VAR 0 3
19634: PPUSH
19635: LD_INT 0
19637: PPUSH
19638: CALL_OW 1
19642: ST_TO_ADDR
// case labNum of 1 :
19643: LD_VAR 0 3
19647: PUSH
19648: LD_INT 1
19650: DOUBLE
19651: EQUAL
19652: IFTRUE 19656
19654: GO 19667
19656: POP
// artifactIResearched := true ; 2 :
19657: LD_ADDR_EXP 9
19661: PUSH
19662: LD_INT 1
19664: ST_TO_ADDR
19665: GO 19706
19667: LD_INT 2
19669: DOUBLE
19670: EQUAL
19671: IFTRUE 19675
19673: GO 19686
19675: POP
// artifactIIResearched := true ; 3 :
19676: LD_ADDR_EXP 10
19680: PUSH
19681: LD_INT 1
19683: ST_TO_ADDR
19684: GO 19706
19686: LD_INT 3
19688: DOUBLE
19689: EQUAL
19690: IFTRUE 19694
19692: GO 19705
19694: POP
// artifactIIIResearched := true ; end ;
19695: LD_ADDR_EXP 11
19699: PUSH
19700: LD_INT 1
19702: ST_TO_ADDR
19703: GO 19706
19705: POP
// end ; end_of_file
19706: PPOPN 3
19708: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
19709: GO 19711
19711: DISABLE
// begin ru_radar := 98 ;
19712: LD_ADDR_EXP 67
19716: PUSH
19717: LD_INT 98
19719: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
19720: LD_ADDR_EXP 68
19724: PUSH
19725: LD_INT 89
19727: ST_TO_ADDR
// us_hack := 99 ;
19728: LD_ADDR_EXP 69
19732: PUSH
19733: LD_INT 99
19735: ST_TO_ADDR
// us_artillery := 97 ;
19736: LD_ADDR_EXP 70
19740: PUSH
19741: LD_INT 97
19743: ST_TO_ADDR
// ar_bio_bomb := 91 ;
19744: LD_ADDR_EXP 71
19748: PUSH
19749: LD_INT 91
19751: ST_TO_ADDR
// end ; end_of_file
19752: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
19753: LD_INT 0
19755: PPUSH
19756: PPUSH
// skirmish := false ;
19757: LD_ADDR_EXP 72
19761: PUSH
19762: LD_INT 0
19764: ST_TO_ADDR
// debug_mc := false ;
19765: LD_ADDR_EXP 73
19769: PUSH
19770: LD_INT 0
19772: ST_TO_ADDR
// mc_bases := [ ] ;
19773: LD_ADDR_EXP 74
19777: PUSH
19778: EMPTY
19779: ST_TO_ADDR
// mc_sides := [ ] ;
19780: LD_ADDR_EXP 100
19784: PUSH
19785: EMPTY
19786: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
19787: LD_ADDR_EXP 75
19791: PUSH
19792: EMPTY
19793: ST_TO_ADDR
// mc_building_repairs := [ ] ;
19794: LD_ADDR_EXP 76
19798: PUSH
19799: EMPTY
19800: ST_TO_ADDR
// mc_need_heal := [ ] ;
19801: LD_ADDR_EXP 77
19805: PUSH
19806: EMPTY
19807: ST_TO_ADDR
// mc_healers := [ ] ;
19808: LD_ADDR_EXP 78
19812: PUSH
19813: EMPTY
19814: ST_TO_ADDR
// mc_build_list := [ ] ;
19815: LD_ADDR_EXP 79
19819: PUSH
19820: EMPTY
19821: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
19822: LD_ADDR_EXP 106
19826: PUSH
19827: EMPTY
19828: ST_TO_ADDR
// mc_builders := [ ] ;
19829: LD_ADDR_EXP 80
19833: PUSH
19834: EMPTY
19835: ST_TO_ADDR
// mc_construct_list := [ ] ;
19836: LD_ADDR_EXP 81
19840: PUSH
19841: EMPTY
19842: ST_TO_ADDR
// mc_turret_list := [ ] ;
19843: LD_ADDR_EXP 82
19847: PUSH
19848: EMPTY
19849: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
19850: LD_ADDR_EXP 83
19854: PUSH
19855: EMPTY
19856: ST_TO_ADDR
// mc_miners := [ ] ;
19857: LD_ADDR_EXP 88
19861: PUSH
19862: EMPTY
19863: ST_TO_ADDR
// mc_mines := [ ] ;
19864: LD_ADDR_EXP 87
19868: PUSH
19869: EMPTY
19870: ST_TO_ADDR
// mc_minefields := [ ] ;
19871: LD_ADDR_EXP 89
19875: PUSH
19876: EMPTY
19877: ST_TO_ADDR
// mc_crates := [ ] ;
19878: LD_ADDR_EXP 90
19882: PUSH
19883: EMPTY
19884: ST_TO_ADDR
// mc_crates_collector := [ ] ;
19885: LD_ADDR_EXP 91
19889: PUSH
19890: EMPTY
19891: ST_TO_ADDR
// mc_crates_area := [ ] ;
19892: LD_ADDR_EXP 92
19896: PUSH
19897: EMPTY
19898: ST_TO_ADDR
// mc_vehicles := [ ] ;
19899: LD_ADDR_EXP 93
19903: PUSH
19904: EMPTY
19905: ST_TO_ADDR
// mc_attack := [ ] ;
19906: LD_ADDR_EXP 94
19910: PUSH
19911: EMPTY
19912: ST_TO_ADDR
// mc_produce := [ ] ;
19913: LD_ADDR_EXP 95
19917: PUSH
19918: EMPTY
19919: ST_TO_ADDR
// mc_defender := [ ] ;
19920: LD_ADDR_EXP 96
19924: PUSH
19925: EMPTY
19926: ST_TO_ADDR
// mc_parking := [ ] ;
19927: LD_ADDR_EXP 98
19931: PUSH
19932: EMPTY
19933: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
19934: LD_ADDR_EXP 84
19938: PUSH
19939: EMPTY
19940: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
19941: LD_ADDR_EXP 86
19945: PUSH
19946: EMPTY
19947: ST_TO_ADDR
// mc_scan := [ ] ;
19948: LD_ADDR_EXP 97
19952: PUSH
19953: EMPTY
19954: ST_TO_ADDR
// mc_scan_area := [ ] ;
19955: LD_ADDR_EXP 99
19959: PUSH
19960: EMPTY
19961: ST_TO_ADDR
// mc_tech := [ ] ;
19962: LD_ADDR_EXP 101
19966: PUSH
19967: EMPTY
19968: ST_TO_ADDR
// mc_class := [ ] ;
19969: LD_ADDR_EXP 115
19973: PUSH
19974: EMPTY
19975: ST_TO_ADDR
// mc_class_case_use := [ ] ;
19976: LD_ADDR_EXP 116
19980: PUSH
19981: EMPTY
19982: ST_TO_ADDR
// end ;
19983: LD_VAR 0 1
19987: RET
// export function MC_Kill ( base ) ; begin
19988: LD_INT 0
19990: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
19991: LD_ADDR_EXP 74
19995: PUSH
19996: LD_EXP 74
20000: PPUSH
20001: LD_VAR 0 1
20005: PPUSH
20006: EMPTY
20007: PPUSH
20008: CALL_OW 1
20012: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20013: LD_ADDR_EXP 75
20017: PUSH
20018: LD_EXP 75
20022: PPUSH
20023: LD_VAR 0 1
20027: PPUSH
20028: EMPTY
20029: PPUSH
20030: CALL_OW 1
20034: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20035: LD_ADDR_EXP 76
20039: PUSH
20040: LD_EXP 76
20044: PPUSH
20045: LD_VAR 0 1
20049: PPUSH
20050: EMPTY
20051: PPUSH
20052: CALL_OW 1
20056: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20057: LD_ADDR_EXP 77
20061: PUSH
20062: LD_EXP 77
20066: PPUSH
20067: LD_VAR 0 1
20071: PPUSH
20072: EMPTY
20073: PPUSH
20074: CALL_OW 1
20078: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20079: LD_ADDR_EXP 78
20083: PUSH
20084: LD_EXP 78
20088: PPUSH
20089: LD_VAR 0 1
20093: PPUSH
20094: EMPTY
20095: PPUSH
20096: CALL_OW 1
20100: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20101: LD_ADDR_EXP 79
20105: PUSH
20106: LD_EXP 79
20110: PPUSH
20111: LD_VAR 0 1
20115: PPUSH
20116: EMPTY
20117: PPUSH
20118: CALL_OW 1
20122: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20123: LD_ADDR_EXP 80
20127: PUSH
20128: LD_EXP 80
20132: PPUSH
20133: LD_VAR 0 1
20137: PPUSH
20138: EMPTY
20139: PPUSH
20140: CALL_OW 1
20144: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20145: LD_ADDR_EXP 81
20149: PUSH
20150: LD_EXP 81
20154: PPUSH
20155: LD_VAR 0 1
20159: PPUSH
20160: EMPTY
20161: PPUSH
20162: CALL_OW 1
20166: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20167: LD_ADDR_EXP 82
20171: PUSH
20172: LD_EXP 82
20176: PPUSH
20177: LD_VAR 0 1
20181: PPUSH
20182: EMPTY
20183: PPUSH
20184: CALL_OW 1
20188: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20189: LD_ADDR_EXP 83
20193: PUSH
20194: LD_EXP 83
20198: PPUSH
20199: LD_VAR 0 1
20203: PPUSH
20204: EMPTY
20205: PPUSH
20206: CALL_OW 1
20210: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20211: LD_ADDR_EXP 84
20215: PUSH
20216: LD_EXP 84
20220: PPUSH
20221: LD_VAR 0 1
20225: PPUSH
20226: EMPTY
20227: PPUSH
20228: CALL_OW 1
20232: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20233: LD_ADDR_EXP 85
20237: PUSH
20238: LD_EXP 85
20242: PPUSH
20243: LD_VAR 0 1
20247: PPUSH
20248: LD_INT 0
20250: PPUSH
20251: CALL_OW 1
20255: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20256: LD_ADDR_EXP 86
20260: PUSH
20261: LD_EXP 86
20265: PPUSH
20266: LD_VAR 0 1
20270: PPUSH
20271: EMPTY
20272: PPUSH
20273: CALL_OW 1
20277: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20278: LD_ADDR_EXP 87
20282: PUSH
20283: LD_EXP 87
20287: PPUSH
20288: LD_VAR 0 1
20292: PPUSH
20293: EMPTY
20294: PPUSH
20295: CALL_OW 1
20299: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20300: LD_ADDR_EXP 88
20304: PUSH
20305: LD_EXP 88
20309: PPUSH
20310: LD_VAR 0 1
20314: PPUSH
20315: EMPTY
20316: PPUSH
20317: CALL_OW 1
20321: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20322: LD_ADDR_EXP 89
20326: PUSH
20327: LD_EXP 89
20331: PPUSH
20332: LD_VAR 0 1
20336: PPUSH
20337: EMPTY
20338: PPUSH
20339: CALL_OW 1
20343: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20344: LD_ADDR_EXP 90
20348: PUSH
20349: LD_EXP 90
20353: PPUSH
20354: LD_VAR 0 1
20358: PPUSH
20359: EMPTY
20360: PPUSH
20361: CALL_OW 1
20365: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20366: LD_ADDR_EXP 91
20370: PUSH
20371: LD_EXP 91
20375: PPUSH
20376: LD_VAR 0 1
20380: PPUSH
20381: EMPTY
20382: PPUSH
20383: CALL_OW 1
20387: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20388: LD_ADDR_EXP 92
20392: PUSH
20393: LD_EXP 92
20397: PPUSH
20398: LD_VAR 0 1
20402: PPUSH
20403: EMPTY
20404: PPUSH
20405: CALL_OW 1
20409: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20410: LD_ADDR_EXP 93
20414: PUSH
20415: LD_EXP 93
20419: PPUSH
20420: LD_VAR 0 1
20424: PPUSH
20425: EMPTY
20426: PPUSH
20427: CALL_OW 1
20431: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20432: LD_ADDR_EXP 94
20436: PUSH
20437: LD_EXP 94
20441: PPUSH
20442: LD_VAR 0 1
20446: PPUSH
20447: EMPTY
20448: PPUSH
20449: CALL_OW 1
20453: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20454: LD_ADDR_EXP 95
20458: PUSH
20459: LD_EXP 95
20463: PPUSH
20464: LD_VAR 0 1
20468: PPUSH
20469: EMPTY
20470: PPUSH
20471: CALL_OW 1
20475: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20476: LD_ADDR_EXP 96
20480: PUSH
20481: LD_EXP 96
20485: PPUSH
20486: LD_VAR 0 1
20490: PPUSH
20491: EMPTY
20492: PPUSH
20493: CALL_OW 1
20497: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20498: LD_ADDR_EXP 97
20502: PUSH
20503: LD_EXP 97
20507: PPUSH
20508: LD_VAR 0 1
20512: PPUSH
20513: EMPTY
20514: PPUSH
20515: CALL_OW 1
20519: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20520: LD_ADDR_EXP 98
20524: PUSH
20525: LD_EXP 98
20529: PPUSH
20530: LD_VAR 0 1
20534: PPUSH
20535: EMPTY
20536: PPUSH
20537: CALL_OW 1
20541: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20542: LD_ADDR_EXP 99
20546: PUSH
20547: LD_EXP 99
20551: PPUSH
20552: LD_VAR 0 1
20556: PPUSH
20557: EMPTY
20558: PPUSH
20559: CALL_OW 1
20563: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20564: LD_ADDR_EXP 101
20568: PUSH
20569: LD_EXP 101
20573: PPUSH
20574: LD_VAR 0 1
20578: PPUSH
20579: EMPTY
20580: PPUSH
20581: CALL_OW 1
20585: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20586: LD_ADDR_EXP 103
20590: PUSH
20591: LD_EXP 103
20595: PPUSH
20596: LD_VAR 0 1
20600: PPUSH
20601: EMPTY
20602: PPUSH
20603: CALL_OW 1
20607: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20608: LD_ADDR_EXP 104
20612: PUSH
20613: LD_EXP 104
20617: PPUSH
20618: LD_VAR 0 1
20622: PPUSH
20623: EMPTY
20624: PPUSH
20625: CALL_OW 1
20629: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20630: LD_ADDR_EXP 105
20634: PUSH
20635: LD_EXP 105
20639: PPUSH
20640: LD_VAR 0 1
20644: PPUSH
20645: EMPTY
20646: PPUSH
20647: CALL_OW 1
20651: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20652: LD_ADDR_EXP 106
20656: PUSH
20657: LD_EXP 106
20661: PPUSH
20662: LD_VAR 0 1
20666: PPUSH
20667: EMPTY
20668: PPUSH
20669: CALL_OW 1
20673: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20674: LD_ADDR_EXP 107
20678: PUSH
20679: LD_EXP 107
20683: PPUSH
20684: LD_VAR 0 1
20688: PPUSH
20689: EMPTY
20690: PPUSH
20691: CALL_OW 1
20695: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20696: LD_ADDR_EXP 108
20700: PUSH
20701: LD_EXP 108
20705: PPUSH
20706: LD_VAR 0 1
20710: PPUSH
20711: EMPTY
20712: PPUSH
20713: CALL_OW 1
20717: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20718: LD_ADDR_EXP 109
20722: PUSH
20723: LD_EXP 109
20727: PPUSH
20728: LD_VAR 0 1
20732: PPUSH
20733: EMPTY
20734: PPUSH
20735: CALL_OW 1
20739: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20740: LD_ADDR_EXP 110
20744: PUSH
20745: LD_EXP 110
20749: PPUSH
20750: LD_VAR 0 1
20754: PPUSH
20755: EMPTY
20756: PPUSH
20757: CALL_OW 1
20761: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20762: LD_ADDR_EXP 111
20766: PUSH
20767: LD_EXP 111
20771: PPUSH
20772: LD_VAR 0 1
20776: PPUSH
20777: EMPTY
20778: PPUSH
20779: CALL_OW 1
20783: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20784: LD_ADDR_EXP 112
20788: PUSH
20789: LD_EXP 112
20793: PPUSH
20794: LD_VAR 0 1
20798: PPUSH
20799: EMPTY
20800: PPUSH
20801: CALL_OW 1
20805: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20806: LD_ADDR_EXP 113
20810: PUSH
20811: LD_EXP 113
20815: PPUSH
20816: LD_VAR 0 1
20820: PPUSH
20821: EMPTY
20822: PPUSH
20823: CALL_OW 1
20827: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20828: LD_ADDR_EXP 114
20832: PUSH
20833: LD_EXP 114
20837: PPUSH
20838: LD_VAR 0 1
20842: PPUSH
20843: EMPTY
20844: PPUSH
20845: CALL_OW 1
20849: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20850: LD_ADDR_EXP 115
20854: PUSH
20855: LD_EXP 115
20859: PPUSH
20860: LD_VAR 0 1
20864: PPUSH
20865: EMPTY
20866: PPUSH
20867: CALL_OW 1
20871: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20872: LD_ADDR_EXP 116
20876: PUSH
20877: LD_EXP 116
20881: PPUSH
20882: LD_VAR 0 1
20886: PPUSH
20887: LD_INT 0
20889: PPUSH
20890: CALL_OW 1
20894: ST_TO_ADDR
// end ;
20895: LD_VAR 0 2
20899: RET
// export function MC_Add ( side , units ) ; var base ; begin
20900: LD_INT 0
20902: PPUSH
20903: PPUSH
// base := mc_bases + 1 ;
20904: LD_ADDR_VAR 0 4
20908: PUSH
20909: LD_EXP 74
20913: PUSH
20914: LD_INT 1
20916: PLUS
20917: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
20918: LD_ADDR_EXP 100
20922: PUSH
20923: LD_EXP 100
20927: PPUSH
20928: LD_VAR 0 4
20932: PPUSH
20933: LD_VAR 0 1
20937: PPUSH
20938: CALL_OW 1
20942: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
20943: LD_ADDR_EXP 74
20947: PUSH
20948: LD_EXP 74
20952: PPUSH
20953: LD_VAR 0 4
20957: PPUSH
20958: LD_VAR 0 2
20962: PPUSH
20963: CALL_OW 1
20967: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20968: LD_ADDR_EXP 75
20972: PUSH
20973: LD_EXP 75
20977: PPUSH
20978: LD_VAR 0 4
20982: PPUSH
20983: EMPTY
20984: PPUSH
20985: CALL_OW 1
20989: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20990: LD_ADDR_EXP 76
20994: PUSH
20995: LD_EXP 76
20999: PPUSH
21000: LD_VAR 0 4
21004: PPUSH
21005: EMPTY
21006: PPUSH
21007: CALL_OW 1
21011: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21012: LD_ADDR_EXP 77
21016: PUSH
21017: LD_EXP 77
21021: PPUSH
21022: LD_VAR 0 4
21026: PPUSH
21027: EMPTY
21028: PPUSH
21029: CALL_OW 1
21033: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21034: LD_ADDR_EXP 78
21038: PUSH
21039: LD_EXP 78
21043: PPUSH
21044: LD_VAR 0 4
21048: PPUSH
21049: EMPTY
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21056: LD_ADDR_EXP 79
21060: PUSH
21061: LD_EXP 79
21065: PPUSH
21066: LD_VAR 0 4
21070: PPUSH
21071: EMPTY
21072: PPUSH
21073: CALL_OW 1
21077: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21078: LD_ADDR_EXP 80
21082: PUSH
21083: LD_EXP 80
21087: PPUSH
21088: LD_VAR 0 4
21092: PPUSH
21093: EMPTY
21094: PPUSH
21095: CALL_OW 1
21099: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21100: LD_ADDR_EXP 81
21104: PUSH
21105: LD_EXP 81
21109: PPUSH
21110: LD_VAR 0 4
21114: PPUSH
21115: EMPTY
21116: PPUSH
21117: CALL_OW 1
21121: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21122: LD_ADDR_EXP 82
21126: PUSH
21127: LD_EXP 82
21131: PPUSH
21132: LD_VAR 0 4
21136: PPUSH
21137: EMPTY
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21144: LD_ADDR_EXP 83
21148: PUSH
21149: LD_EXP 83
21153: PPUSH
21154: LD_VAR 0 4
21158: PPUSH
21159: EMPTY
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21166: LD_ADDR_EXP 84
21170: PUSH
21171: LD_EXP 84
21175: PPUSH
21176: LD_VAR 0 4
21180: PPUSH
21181: EMPTY
21182: PPUSH
21183: CALL_OW 1
21187: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21188: LD_ADDR_EXP 85
21192: PUSH
21193: LD_EXP 85
21197: PPUSH
21198: LD_VAR 0 4
21202: PPUSH
21203: LD_INT 0
21205: PPUSH
21206: CALL_OW 1
21210: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21211: LD_ADDR_EXP 86
21215: PUSH
21216: LD_EXP 86
21220: PPUSH
21221: LD_VAR 0 4
21225: PPUSH
21226: EMPTY
21227: PPUSH
21228: CALL_OW 1
21232: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21233: LD_ADDR_EXP 87
21237: PUSH
21238: LD_EXP 87
21242: PPUSH
21243: LD_VAR 0 4
21247: PPUSH
21248: EMPTY
21249: PPUSH
21250: CALL_OW 1
21254: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21255: LD_ADDR_EXP 88
21259: PUSH
21260: LD_EXP 88
21264: PPUSH
21265: LD_VAR 0 4
21269: PPUSH
21270: EMPTY
21271: PPUSH
21272: CALL_OW 1
21276: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21277: LD_ADDR_EXP 89
21281: PUSH
21282: LD_EXP 89
21286: PPUSH
21287: LD_VAR 0 4
21291: PPUSH
21292: EMPTY
21293: PPUSH
21294: CALL_OW 1
21298: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21299: LD_ADDR_EXP 90
21303: PUSH
21304: LD_EXP 90
21308: PPUSH
21309: LD_VAR 0 4
21313: PPUSH
21314: EMPTY
21315: PPUSH
21316: CALL_OW 1
21320: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21321: LD_ADDR_EXP 91
21325: PUSH
21326: LD_EXP 91
21330: PPUSH
21331: LD_VAR 0 4
21335: PPUSH
21336: EMPTY
21337: PPUSH
21338: CALL_OW 1
21342: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21343: LD_ADDR_EXP 92
21347: PUSH
21348: LD_EXP 92
21352: PPUSH
21353: LD_VAR 0 4
21357: PPUSH
21358: EMPTY
21359: PPUSH
21360: CALL_OW 1
21364: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21365: LD_ADDR_EXP 93
21369: PUSH
21370: LD_EXP 93
21374: PPUSH
21375: LD_VAR 0 4
21379: PPUSH
21380: EMPTY
21381: PPUSH
21382: CALL_OW 1
21386: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21387: LD_ADDR_EXP 94
21391: PUSH
21392: LD_EXP 94
21396: PPUSH
21397: LD_VAR 0 4
21401: PPUSH
21402: EMPTY
21403: PPUSH
21404: CALL_OW 1
21408: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21409: LD_ADDR_EXP 95
21413: PUSH
21414: LD_EXP 95
21418: PPUSH
21419: LD_VAR 0 4
21423: PPUSH
21424: EMPTY
21425: PPUSH
21426: CALL_OW 1
21430: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21431: LD_ADDR_EXP 96
21435: PUSH
21436: LD_EXP 96
21440: PPUSH
21441: LD_VAR 0 4
21445: PPUSH
21446: EMPTY
21447: PPUSH
21448: CALL_OW 1
21452: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21453: LD_ADDR_EXP 97
21457: PUSH
21458: LD_EXP 97
21462: PPUSH
21463: LD_VAR 0 4
21467: PPUSH
21468: EMPTY
21469: PPUSH
21470: CALL_OW 1
21474: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21475: LD_ADDR_EXP 98
21479: PUSH
21480: LD_EXP 98
21484: PPUSH
21485: LD_VAR 0 4
21489: PPUSH
21490: EMPTY
21491: PPUSH
21492: CALL_OW 1
21496: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21497: LD_ADDR_EXP 99
21501: PUSH
21502: LD_EXP 99
21506: PPUSH
21507: LD_VAR 0 4
21511: PPUSH
21512: EMPTY
21513: PPUSH
21514: CALL_OW 1
21518: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21519: LD_ADDR_EXP 101
21523: PUSH
21524: LD_EXP 101
21528: PPUSH
21529: LD_VAR 0 4
21533: PPUSH
21534: EMPTY
21535: PPUSH
21536: CALL_OW 1
21540: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21541: LD_ADDR_EXP 103
21545: PUSH
21546: LD_EXP 103
21550: PPUSH
21551: LD_VAR 0 4
21555: PPUSH
21556: EMPTY
21557: PPUSH
21558: CALL_OW 1
21562: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21563: LD_ADDR_EXP 104
21567: PUSH
21568: LD_EXP 104
21572: PPUSH
21573: LD_VAR 0 4
21577: PPUSH
21578: EMPTY
21579: PPUSH
21580: CALL_OW 1
21584: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21585: LD_ADDR_EXP 105
21589: PUSH
21590: LD_EXP 105
21594: PPUSH
21595: LD_VAR 0 4
21599: PPUSH
21600: EMPTY
21601: PPUSH
21602: CALL_OW 1
21606: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21607: LD_ADDR_EXP 106
21611: PUSH
21612: LD_EXP 106
21616: PPUSH
21617: LD_VAR 0 4
21621: PPUSH
21622: EMPTY
21623: PPUSH
21624: CALL_OW 1
21628: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21629: LD_ADDR_EXP 107
21633: PUSH
21634: LD_EXP 107
21638: PPUSH
21639: LD_VAR 0 4
21643: PPUSH
21644: EMPTY
21645: PPUSH
21646: CALL_OW 1
21650: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21651: LD_ADDR_EXP 108
21655: PUSH
21656: LD_EXP 108
21660: PPUSH
21661: LD_VAR 0 4
21665: PPUSH
21666: EMPTY
21667: PPUSH
21668: CALL_OW 1
21672: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21673: LD_ADDR_EXP 109
21677: PUSH
21678: LD_EXP 109
21682: PPUSH
21683: LD_VAR 0 4
21687: PPUSH
21688: EMPTY
21689: PPUSH
21690: CALL_OW 1
21694: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21695: LD_ADDR_EXP 110
21699: PUSH
21700: LD_EXP 110
21704: PPUSH
21705: LD_VAR 0 4
21709: PPUSH
21710: EMPTY
21711: PPUSH
21712: CALL_OW 1
21716: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21717: LD_ADDR_EXP 111
21721: PUSH
21722: LD_EXP 111
21726: PPUSH
21727: LD_VAR 0 4
21731: PPUSH
21732: EMPTY
21733: PPUSH
21734: CALL_OW 1
21738: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21739: LD_ADDR_EXP 112
21743: PUSH
21744: LD_EXP 112
21748: PPUSH
21749: LD_VAR 0 4
21753: PPUSH
21754: EMPTY
21755: PPUSH
21756: CALL_OW 1
21760: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21761: LD_ADDR_EXP 113
21765: PUSH
21766: LD_EXP 113
21770: PPUSH
21771: LD_VAR 0 4
21775: PPUSH
21776: EMPTY
21777: PPUSH
21778: CALL_OW 1
21782: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21783: LD_ADDR_EXP 114
21787: PUSH
21788: LD_EXP 114
21792: PPUSH
21793: LD_VAR 0 4
21797: PPUSH
21798: EMPTY
21799: PPUSH
21800: CALL_OW 1
21804: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21805: LD_ADDR_EXP 115
21809: PUSH
21810: LD_EXP 115
21814: PPUSH
21815: LD_VAR 0 4
21819: PPUSH
21820: EMPTY
21821: PPUSH
21822: CALL_OW 1
21826: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21827: LD_ADDR_EXP 116
21831: PUSH
21832: LD_EXP 116
21836: PPUSH
21837: LD_VAR 0 4
21841: PPUSH
21842: LD_INT 0
21844: PPUSH
21845: CALL_OW 1
21849: ST_TO_ADDR
// result := base ;
21850: LD_ADDR_VAR 0 3
21854: PUSH
21855: LD_VAR 0 4
21859: ST_TO_ADDR
// end ;
21860: LD_VAR 0 3
21864: RET
// export function MC_Start ( ) ; var i ; begin
21865: LD_INT 0
21867: PPUSH
21868: PPUSH
// for i = 1 to mc_bases do
21869: LD_ADDR_VAR 0 2
21873: PUSH
21874: DOUBLE
21875: LD_INT 1
21877: DEC
21878: ST_TO_ADDR
21879: LD_EXP 74
21883: PUSH
21884: FOR_TO
21885: IFFALSE 22962
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
21887: LD_ADDR_EXP 74
21891: PUSH
21892: LD_EXP 74
21896: PPUSH
21897: LD_VAR 0 2
21901: PPUSH
21902: LD_EXP 74
21906: PUSH
21907: LD_VAR 0 2
21911: ARRAY
21912: PUSH
21913: LD_INT 0
21915: DIFF
21916: PPUSH
21917: CALL_OW 1
21921: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
21922: LD_ADDR_EXP 75
21926: PUSH
21927: LD_EXP 75
21931: PPUSH
21932: LD_VAR 0 2
21936: PPUSH
21937: EMPTY
21938: PPUSH
21939: CALL_OW 1
21943: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
21944: LD_ADDR_EXP 76
21948: PUSH
21949: LD_EXP 76
21953: PPUSH
21954: LD_VAR 0 2
21958: PPUSH
21959: EMPTY
21960: PPUSH
21961: CALL_OW 1
21965: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
21966: LD_ADDR_EXP 77
21970: PUSH
21971: LD_EXP 77
21975: PPUSH
21976: LD_VAR 0 2
21980: PPUSH
21981: EMPTY
21982: PPUSH
21983: CALL_OW 1
21987: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
21988: LD_ADDR_EXP 78
21992: PUSH
21993: LD_EXP 78
21997: PPUSH
21998: LD_VAR 0 2
22002: PPUSH
22003: EMPTY
22004: PUSH
22005: EMPTY
22006: PUSH
22007: EMPTY
22008: LIST
22009: LIST
22010: PPUSH
22011: CALL_OW 1
22015: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22016: LD_ADDR_EXP 79
22020: PUSH
22021: LD_EXP 79
22025: PPUSH
22026: LD_VAR 0 2
22030: PPUSH
22031: EMPTY
22032: PPUSH
22033: CALL_OW 1
22037: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22038: LD_ADDR_EXP 106
22042: PUSH
22043: LD_EXP 106
22047: PPUSH
22048: LD_VAR 0 2
22052: PPUSH
22053: EMPTY
22054: PPUSH
22055: CALL_OW 1
22059: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22060: LD_ADDR_EXP 80
22064: PUSH
22065: LD_EXP 80
22069: PPUSH
22070: LD_VAR 0 2
22074: PPUSH
22075: EMPTY
22076: PPUSH
22077: CALL_OW 1
22081: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22082: LD_ADDR_EXP 81
22086: PUSH
22087: LD_EXP 81
22091: PPUSH
22092: LD_VAR 0 2
22096: PPUSH
22097: EMPTY
22098: PPUSH
22099: CALL_OW 1
22103: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22104: LD_ADDR_EXP 82
22108: PUSH
22109: LD_EXP 82
22113: PPUSH
22114: LD_VAR 0 2
22118: PPUSH
22119: LD_EXP 74
22123: PUSH
22124: LD_VAR 0 2
22128: ARRAY
22129: PPUSH
22130: LD_INT 2
22132: PUSH
22133: LD_INT 30
22135: PUSH
22136: LD_INT 32
22138: PUSH
22139: EMPTY
22140: LIST
22141: LIST
22142: PUSH
22143: LD_INT 30
22145: PUSH
22146: LD_INT 33
22148: PUSH
22149: EMPTY
22150: LIST
22151: LIST
22152: PUSH
22153: EMPTY
22154: LIST
22155: LIST
22156: LIST
22157: PPUSH
22158: CALL_OW 72
22162: PPUSH
22163: CALL_OW 1
22167: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22168: LD_ADDR_EXP 83
22172: PUSH
22173: LD_EXP 83
22177: PPUSH
22178: LD_VAR 0 2
22182: PPUSH
22183: LD_EXP 74
22187: PUSH
22188: LD_VAR 0 2
22192: ARRAY
22193: PPUSH
22194: LD_INT 2
22196: PUSH
22197: LD_INT 30
22199: PUSH
22200: LD_INT 32
22202: PUSH
22203: EMPTY
22204: LIST
22205: LIST
22206: PUSH
22207: LD_INT 30
22209: PUSH
22210: LD_INT 31
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PUSH
22217: EMPTY
22218: LIST
22219: LIST
22220: LIST
22221: PUSH
22222: LD_INT 58
22224: PUSH
22225: EMPTY
22226: LIST
22227: PUSH
22228: EMPTY
22229: LIST
22230: LIST
22231: PPUSH
22232: CALL_OW 72
22236: PPUSH
22237: CALL_OW 1
22241: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22242: LD_ADDR_EXP 84
22246: PUSH
22247: LD_EXP 84
22251: PPUSH
22252: LD_VAR 0 2
22256: PPUSH
22257: EMPTY
22258: PPUSH
22259: CALL_OW 1
22263: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22264: LD_ADDR_EXP 88
22268: PUSH
22269: LD_EXP 88
22273: PPUSH
22274: LD_VAR 0 2
22278: PPUSH
22279: EMPTY
22280: PPUSH
22281: CALL_OW 1
22285: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22286: LD_ADDR_EXP 87
22290: PUSH
22291: LD_EXP 87
22295: PPUSH
22296: LD_VAR 0 2
22300: PPUSH
22301: EMPTY
22302: PPUSH
22303: CALL_OW 1
22307: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22308: LD_ADDR_EXP 89
22312: PUSH
22313: LD_EXP 89
22317: PPUSH
22318: LD_VAR 0 2
22322: PPUSH
22323: EMPTY
22324: PPUSH
22325: CALL_OW 1
22329: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22330: LD_ADDR_EXP 90
22334: PUSH
22335: LD_EXP 90
22339: PPUSH
22340: LD_VAR 0 2
22344: PPUSH
22345: EMPTY
22346: PPUSH
22347: CALL_OW 1
22351: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22352: LD_ADDR_EXP 91
22356: PUSH
22357: LD_EXP 91
22361: PPUSH
22362: LD_VAR 0 2
22366: PPUSH
22367: EMPTY
22368: PPUSH
22369: CALL_OW 1
22373: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22374: LD_ADDR_EXP 92
22378: PUSH
22379: LD_EXP 92
22383: PPUSH
22384: LD_VAR 0 2
22388: PPUSH
22389: EMPTY
22390: PPUSH
22391: CALL_OW 1
22395: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
22396: LD_ADDR_EXP 93
22400: PUSH
22401: LD_EXP 93
22405: PPUSH
22406: LD_VAR 0 2
22410: PPUSH
22411: EMPTY
22412: PPUSH
22413: CALL_OW 1
22417: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22418: LD_ADDR_EXP 94
22422: PUSH
22423: LD_EXP 94
22427: PPUSH
22428: LD_VAR 0 2
22432: PPUSH
22433: EMPTY
22434: PPUSH
22435: CALL_OW 1
22439: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
22440: LD_ADDR_EXP 95
22444: PUSH
22445: LD_EXP 95
22449: PPUSH
22450: LD_VAR 0 2
22454: PPUSH
22455: EMPTY
22456: PPUSH
22457: CALL_OW 1
22461: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
22462: LD_ADDR_EXP 96
22466: PUSH
22467: LD_EXP 96
22471: PPUSH
22472: LD_VAR 0 2
22476: PPUSH
22477: EMPTY
22478: PPUSH
22479: CALL_OW 1
22483: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
22484: LD_ADDR_EXP 85
22488: PUSH
22489: LD_EXP 85
22493: PPUSH
22494: LD_VAR 0 2
22498: PPUSH
22499: LD_INT 0
22501: PPUSH
22502: CALL_OW 1
22506: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
22507: LD_ADDR_EXP 98
22511: PUSH
22512: LD_EXP 98
22516: PPUSH
22517: LD_VAR 0 2
22521: PPUSH
22522: LD_INT 0
22524: PPUSH
22525: CALL_OW 1
22529: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
22530: LD_ADDR_EXP 86
22534: PUSH
22535: LD_EXP 86
22539: PPUSH
22540: LD_VAR 0 2
22544: PPUSH
22545: EMPTY
22546: PPUSH
22547: CALL_OW 1
22551: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
22552: LD_ADDR_EXP 97
22556: PUSH
22557: LD_EXP 97
22561: PPUSH
22562: LD_VAR 0 2
22566: PPUSH
22567: LD_INT 0
22569: PPUSH
22570: CALL_OW 1
22574: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
22575: LD_ADDR_EXP 99
22579: PUSH
22580: LD_EXP 99
22584: PPUSH
22585: LD_VAR 0 2
22589: PPUSH
22590: EMPTY
22591: PPUSH
22592: CALL_OW 1
22596: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
22597: LD_ADDR_EXP 102
22601: PUSH
22602: LD_EXP 102
22606: PPUSH
22607: LD_VAR 0 2
22611: PPUSH
22612: LD_INT 0
22614: PPUSH
22615: CALL_OW 1
22619: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
22620: LD_ADDR_EXP 103
22624: PUSH
22625: LD_EXP 103
22629: PPUSH
22630: LD_VAR 0 2
22634: PPUSH
22635: EMPTY
22636: PPUSH
22637: CALL_OW 1
22641: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
22642: LD_ADDR_EXP 104
22646: PUSH
22647: LD_EXP 104
22651: PPUSH
22652: LD_VAR 0 2
22656: PPUSH
22657: EMPTY
22658: PPUSH
22659: CALL_OW 1
22663: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
22664: LD_ADDR_EXP 105
22668: PUSH
22669: LD_EXP 105
22673: PPUSH
22674: LD_VAR 0 2
22678: PPUSH
22679: EMPTY
22680: PPUSH
22681: CALL_OW 1
22685: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
22686: LD_ADDR_EXP 107
22690: PUSH
22691: LD_EXP 107
22695: PPUSH
22696: LD_VAR 0 2
22700: PPUSH
22701: LD_EXP 74
22705: PUSH
22706: LD_VAR 0 2
22710: ARRAY
22711: PPUSH
22712: LD_INT 2
22714: PUSH
22715: LD_INT 30
22717: PUSH
22718: LD_INT 6
22720: PUSH
22721: EMPTY
22722: LIST
22723: LIST
22724: PUSH
22725: LD_INT 30
22727: PUSH
22728: LD_INT 7
22730: PUSH
22731: EMPTY
22732: LIST
22733: LIST
22734: PUSH
22735: LD_INT 30
22737: PUSH
22738: LD_INT 8
22740: PUSH
22741: EMPTY
22742: LIST
22743: LIST
22744: PUSH
22745: EMPTY
22746: LIST
22747: LIST
22748: LIST
22749: LIST
22750: PPUSH
22751: CALL_OW 72
22755: PPUSH
22756: CALL_OW 1
22760: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
22761: LD_ADDR_EXP 108
22765: PUSH
22766: LD_EXP 108
22770: PPUSH
22771: LD_VAR 0 2
22775: PPUSH
22776: EMPTY
22777: PPUSH
22778: CALL_OW 1
22782: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
22783: LD_ADDR_EXP 109
22787: PUSH
22788: LD_EXP 109
22792: PPUSH
22793: LD_VAR 0 2
22797: PPUSH
22798: EMPTY
22799: PPUSH
22800: CALL_OW 1
22804: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
22805: LD_ADDR_EXP 110
22809: PUSH
22810: LD_EXP 110
22814: PPUSH
22815: LD_VAR 0 2
22819: PPUSH
22820: EMPTY
22821: PPUSH
22822: CALL_OW 1
22826: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
22827: LD_ADDR_EXP 111
22831: PUSH
22832: LD_EXP 111
22836: PPUSH
22837: LD_VAR 0 2
22841: PPUSH
22842: EMPTY
22843: PPUSH
22844: CALL_OW 1
22848: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
22849: LD_ADDR_EXP 112
22853: PUSH
22854: LD_EXP 112
22858: PPUSH
22859: LD_VAR 0 2
22863: PPUSH
22864: EMPTY
22865: PPUSH
22866: CALL_OW 1
22870: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
22871: LD_ADDR_EXP 113
22875: PUSH
22876: LD_EXP 113
22880: PPUSH
22881: LD_VAR 0 2
22885: PPUSH
22886: EMPTY
22887: PPUSH
22888: CALL_OW 1
22892: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
22893: LD_ADDR_EXP 114
22897: PUSH
22898: LD_EXP 114
22902: PPUSH
22903: LD_VAR 0 2
22907: PPUSH
22908: EMPTY
22909: PPUSH
22910: CALL_OW 1
22914: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
22915: LD_ADDR_EXP 115
22919: PUSH
22920: LD_EXP 115
22924: PPUSH
22925: LD_VAR 0 2
22929: PPUSH
22930: EMPTY
22931: PPUSH
22932: CALL_OW 1
22936: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
22937: LD_ADDR_EXP 116
22941: PUSH
22942: LD_EXP 116
22946: PPUSH
22947: LD_VAR 0 2
22951: PPUSH
22952: LD_INT 0
22954: PPUSH
22955: CALL_OW 1
22959: ST_TO_ADDR
// end ;
22960: GO 21884
22962: POP
22963: POP
// MC_InitSides ( ) ;
22964: CALL 23250 0 0
// MC_InitResearch ( ) ;
22968: CALL 22989 0 0
// CustomInitMacro ( ) ;
22972: CALL 173 0 0
// skirmish := true ;
22976: LD_ADDR_EXP 72
22980: PUSH
22981: LD_INT 1
22983: ST_TO_ADDR
// end ;
22984: LD_VAR 0 1
22988: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
22989: LD_INT 0
22991: PPUSH
22992: PPUSH
22993: PPUSH
22994: PPUSH
22995: PPUSH
22996: PPUSH
// if not mc_bases then
22997: LD_EXP 74
23001: NOT
23002: IFFALSE 23006
// exit ;
23004: GO 23245
// for i = 1 to 8 do
23006: LD_ADDR_VAR 0 2
23010: PUSH
23011: DOUBLE
23012: LD_INT 1
23014: DEC
23015: ST_TO_ADDR
23016: LD_INT 8
23018: PUSH
23019: FOR_TO
23020: IFFALSE 23046
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23022: LD_ADDR_EXP 101
23026: PUSH
23027: LD_EXP 101
23031: PPUSH
23032: LD_VAR 0 2
23036: PPUSH
23037: EMPTY
23038: PPUSH
23039: CALL_OW 1
23043: ST_TO_ADDR
23044: GO 23019
23046: POP
23047: POP
// tmp := [ ] ;
23048: LD_ADDR_VAR 0 5
23052: PUSH
23053: EMPTY
23054: ST_TO_ADDR
// for i = 1 to mc_sides do
23055: LD_ADDR_VAR 0 2
23059: PUSH
23060: DOUBLE
23061: LD_INT 1
23063: DEC
23064: ST_TO_ADDR
23065: LD_EXP 100
23069: PUSH
23070: FOR_TO
23071: IFFALSE 23129
// if not mc_sides [ i ] in tmp then
23073: LD_EXP 100
23077: PUSH
23078: LD_VAR 0 2
23082: ARRAY
23083: PUSH
23084: LD_VAR 0 5
23088: IN
23089: NOT
23090: IFFALSE 23127
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23092: LD_ADDR_VAR 0 5
23096: PUSH
23097: LD_VAR 0 5
23101: PPUSH
23102: LD_VAR 0 5
23106: PUSH
23107: LD_INT 1
23109: PLUS
23110: PPUSH
23111: LD_EXP 100
23115: PUSH
23116: LD_VAR 0 2
23120: ARRAY
23121: PPUSH
23122: CALL_OW 2
23126: ST_TO_ADDR
23127: GO 23070
23129: POP
23130: POP
// if not tmp then
23131: LD_VAR 0 5
23135: NOT
23136: IFFALSE 23140
// exit ;
23138: GO 23245
// for j in tmp do
23140: LD_ADDR_VAR 0 3
23144: PUSH
23145: LD_VAR 0 5
23149: PUSH
23150: FOR_IN
23151: IFFALSE 23243
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23153: LD_ADDR_VAR 0 6
23157: PUSH
23158: LD_INT 22
23160: PUSH
23161: LD_VAR 0 3
23165: PUSH
23166: EMPTY
23167: LIST
23168: LIST
23169: PPUSH
23170: CALL_OW 69
23174: ST_TO_ADDR
// if not un then
23175: LD_VAR 0 6
23179: NOT
23180: IFFALSE 23184
// continue ;
23182: GO 23150
// nation := GetNation ( un [ 1 ] ) ;
23184: LD_ADDR_VAR 0 4
23188: PUSH
23189: LD_VAR 0 6
23193: PUSH
23194: LD_INT 1
23196: ARRAY
23197: PPUSH
23198: CALL_OW 248
23202: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23203: LD_ADDR_EXP 101
23207: PUSH
23208: LD_EXP 101
23212: PPUSH
23213: LD_VAR 0 3
23217: PPUSH
23218: LD_VAR 0 3
23222: PPUSH
23223: LD_VAR 0 4
23227: PPUSH
23228: LD_INT 1
23230: PPUSH
23231: CALL 49609 0 3
23235: PPUSH
23236: CALL_OW 1
23240: ST_TO_ADDR
// end ;
23241: GO 23150
23243: POP
23244: POP
// end ;
23245: LD_VAR 0 1
23249: RET
// export function MC_InitSides ( ) ; var i ; begin
23250: LD_INT 0
23252: PPUSH
23253: PPUSH
// if not mc_bases then
23254: LD_EXP 74
23258: NOT
23259: IFFALSE 23263
// exit ;
23261: GO 23337
// for i = 1 to mc_bases do
23263: LD_ADDR_VAR 0 2
23267: PUSH
23268: DOUBLE
23269: LD_INT 1
23271: DEC
23272: ST_TO_ADDR
23273: LD_EXP 74
23277: PUSH
23278: FOR_TO
23279: IFFALSE 23335
// if mc_bases [ i ] then
23281: LD_EXP 74
23285: PUSH
23286: LD_VAR 0 2
23290: ARRAY
23291: IFFALSE 23333
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23293: LD_ADDR_EXP 100
23297: PUSH
23298: LD_EXP 100
23302: PPUSH
23303: LD_VAR 0 2
23307: PPUSH
23308: LD_EXP 74
23312: PUSH
23313: LD_VAR 0 2
23317: ARRAY
23318: PUSH
23319: LD_INT 1
23321: ARRAY
23322: PPUSH
23323: CALL_OW 255
23327: PPUSH
23328: CALL_OW 1
23332: ST_TO_ADDR
23333: GO 23278
23335: POP
23336: POP
// end ;
23337: LD_VAR 0 1
23341: RET
// every 0 0$01 trigger skirmish do
23342: LD_EXP 72
23346: IFFALSE 23500
23348: GO 23350
23350: DISABLE
// begin enable ;
23351: ENABLE
// MC_CheckBuildings ( ) ;
23352: CALL 27998 0 0
// MC_CheckPeopleLife ( ) ;
23356: CALL 28123 0 0
// RaiseSailEvent ( 100 ) ;
23360: LD_INT 100
23362: PPUSH
23363: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23367: LD_INT 103
23369: PPUSH
23370: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23374: LD_INT 104
23376: PPUSH
23377: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23381: LD_INT 105
23383: PPUSH
23384: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
23388: LD_INT 106
23390: PPUSH
23391: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
23395: LD_INT 107
23397: PPUSH
23398: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
23402: LD_INT 108
23404: PPUSH
23405: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
23409: LD_INT 109
23411: PPUSH
23412: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
23416: LD_INT 110
23418: PPUSH
23419: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
23423: LD_INT 111
23425: PPUSH
23426: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
23430: LD_INT 112
23432: PPUSH
23433: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
23437: LD_INT 113
23439: PPUSH
23440: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
23444: LD_INT 120
23446: PPUSH
23447: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
23451: LD_INT 121
23453: PPUSH
23454: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
23458: LD_INT 122
23460: PPUSH
23461: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
23465: LD_INT 123
23467: PPUSH
23468: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
23472: LD_INT 124
23474: PPUSH
23475: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
23479: LD_INT 125
23481: PPUSH
23482: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
23486: LD_INT 126
23488: PPUSH
23489: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
23493: LD_INT 200
23495: PPUSH
23496: CALL_OW 427
// end ;
23500: END
// on SailEvent ( event ) do begin if event < 100 then
23501: LD_VAR 0 1
23505: PUSH
23506: LD_INT 100
23508: LESS
23509: IFFALSE 23520
// CustomEvent ( event ) ;
23511: LD_VAR 0 1
23515: PPUSH
23516: CALL 9897 0 1
// if event = 100 then
23520: LD_VAR 0 1
23524: PUSH
23525: LD_INT 100
23527: EQUAL
23528: IFFALSE 23534
// MC_ClassManager ( ) ;
23530: CALL 23926 0 0
// if event = 101 then
23534: LD_VAR 0 1
23538: PUSH
23539: LD_INT 101
23541: EQUAL
23542: IFFALSE 23548
// MC_RepairBuildings ( ) ;
23544: CALL 28719 0 0
// if event = 102 then
23548: LD_VAR 0 1
23552: PUSH
23553: LD_INT 102
23555: EQUAL
23556: IFFALSE 23562
// MC_Heal ( ) ;
23558: CALL 29451 0 0
// if event = 103 then
23562: LD_VAR 0 1
23566: PUSH
23567: LD_INT 103
23569: EQUAL
23570: IFFALSE 23576
// MC_Build ( ) ;
23572: CALL 29873 0 0
// if event = 104 then
23576: LD_VAR 0 1
23580: PUSH
23581: LD_INT 104
23583: EQUAL
23584: IFFALSE 23590
// MC_TurretWeapon ( ) ;
23586: CALL 31486 0 0
// if event = 105 then
23590: LD_VAR 0 1
23594: PUSH
23595: LD_INT 105
23597: EQUAL
23598: IFFALSE 23604
// MC_BuildUpgrade ( ) ;
23600: CALL 31037 0 0
// if event = 106 then
23604: LD_VAR 0 1
23608: PUSH
23609: LD_INT 106
23611: EQUAL
23612: IFFALSE 23618
// MC_PlantMines ( ) ;
23614: CALL 31916 0 0
// if event = 107 then
23618: LD_VAR 0 1
23622: PUSH
23623: LD_INT 107
23625: EQUAL
23626: IFFALSE 23632
// MC_CollectCrates ( ) ;
23628: CALL 32950 0 0
// if event = 108 then
23632: LD_VAR 0 1
23636: PUSH
23637: LD_INT 108
23639: EQUAL
23640: IFFALSE 23646
// MC_LinkRemoteControl ( ) ;
23642: CALL 34726 0 0
// if event = 109 then
23646: LD_VAR 0 1
23650: PUSH
23651: LD_INT 109
23653: EQUAL
23654: IFFALSE 23660
// MC_ProduceVehicle ( ) ;
23656: CALL 34907 0 0
// if event = 110 then
23660: LD_VAR 0 1
23664: PUSH
23665: LD_INT 110
23667: EQUAL
23668: IFFALSE 23674
// MC_SendAttack ( ) ;
23670: CALL 35373 0 0
// if event = 111 then
23674: LD_VAR 0 1
23678: PUSH
23679: LD_INT 111
23681: EQUAL
23682: IFFALSE 23688
// MC_Defend ( ) ;
23684: CALL 35481 0 0
// if event = 112 then
23688: LD_VAR 0 1
23692: PUSH
23693: LD_INT 112
23695: EQUAL
23696: IFFALSE 23702
// MC_Research ( ) ;
23698: CALL 36086 0 0
// if event = 113 then
23702: LD_VAR 0 1
23706: PUSH
23707: LD_INT 113
23709: EQUAL
23710: IFFALSE 23716
// MC_MinesTrigger ( ) ;
23712: CALL 37200 0 0
// if event = 120 then
23716: LD_VAR 0 1
23720: PUSH
23721: LD_INT 120
23723: EQUAL
23724: IFFALSE 23730
// MC_RepairVehicle ( ) ;
23726: CALL 37299 0 0
// if event = 121 then
23730: LD_VAR 0 1
23734: PUSH
23735: LD_INT 121
23737: EQUAL
23738: IFFALSE 23744
// MC_TameApe ( ) ;
23740: CALL 38029 0 0
// if event = 122 then
23744: LD_VAR 0 1
23748: PUSH
23749: LD_INT 122
23751: EQUAL
23752: IFFALSE 23758
// MC_ChangeApeClass ( ) ;
23754: CALL 38858 0 0
// if event = 123 then
23758: LD_VAR 0 1
23762: PUSH
23763: LD_INT 123
23765: EQUAL
23766: IFFALSE 23772
// MC_Bazooka ( ) ;
23768: CALL 39508 0 0
// if event = 124 then
23772: LD_VAR 0 1
23776: PUSH
23777: LD_INT 124
23779: EQUAL
23780: IFFALSE 23786
// MC_TeleportExit ( ) ;
23782: CALL 39706 0 0
// if event = 125 then
23786: LD_VAR 0 1
23790: PUSH
23791: LD_INT 125
23793: EQUAL
23794: IFFALSE 23800
// MC_Deposits ( ) ;
23796: CALL 40353 0 0
// if event = 126 then
23800: LD_VAR 0 1
23804: PUSH
23805: LD_INT 126
23807: EQUAL
23808: IFFALSE 23814
// MC_RemoteDriver ( ) ;
23810: CALL 40978 0 0
// if event = 200 then
23814: LD_VAR 0 1
23818: PUSH
23819: LD_INT 200
23821: EQUAL
23822: IFFALSE 23828
// MC_Idle ( ) ;
23824: CALL 42711 0 0
// end ;
23828: PPOPN 1
23830: END
// export function MC_Reset ( base , tag ) ; var i ; begin
23831: LD_INT 0
23833: PPUSH
23834: PPUSH
// if not mc_bases [ base ] or not tag then
23835: LD_EXP 74
23839: PUSH
23840: LD_VAR 0 1
23844: ARRAY
23845: NOT
23846: PUSH
23847: LD_VAR 0 2
23851: NOT
23852: OR
23853: IFFALSE 23857
// exit ;
23855: GO 23921
// for i in mc_bases [ base ] union mc_ape [ base ] do
23857: LD_ADDR_VAR 0 4
23861: PUSH
23862: LD_EXP 74
23866: PUSH
23867: LD_VAR 0 1
23871: ARRAY
23872: PUSH
23873: LD_EXP 103
23877: PUSH
23878: LD_VAR 0 1
23882: ARRAY
23883: UNION
23884: PUSH
23885: FOR_IN
23886: IFFALSE 23919
// if GetTag ( i ) = tag then
23888: LD_VAR 0 4
23892: PPUSH
23893: CALL_OW 110
23897: PUSH
23898: LD_VAR 0 2
23902: EQUAL
23903: IFFALSE 23917
// SetTag ( i , 0 ) ;
23905: LD_VAR 0 4
23909: PPUSH
23910: LD_INT 0
23912: PPUSH
23913: CALL_OW 109
23917: GO 23885
23919: POP
23920: POP
// end ;
23921: LD_VAR 0 3
23925: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
23926: LD_INT 0
23928: PPUSH
23929: PPUSH
23930: PPUSH
23931: PPUSH
23932: PPUSH
23933: PPUSH
23934: PPUSH
23935: PPUSH
// if not mc_bases then
23936: LD_EXP 74
23940: NOT
23941: IFFALSE 23945
// exit ;
23943: GO 24403
// for i = 1 to mc_bases do
23945: LD_ADDR_VAR 0 2
23949: PUSH
23950: DOUBLE
23951: LD_INT 1
23953: DEC
23954: ST_TO_ADDR
23955: LD_EXP 74
23959: PUSH
23960: FOR_TO
23961: IFFALSE 24401
// begin tmp := MC_ClassCheckReq ( i ) ;
23963: LD_ADDR_VAR 0 4
23967: PUSH
23968: LD_VAR 0 2
23972: PPUSH
23973: CALL 24408 0 1
23977: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
23978: LD_ADDR_EXP 115
23982: PUSH
23983: LD_EXP 115
23987: PPUSH
23988: LD_VAR 0 2
23992: PPUSH
23993: LD_VAR 0 4
23997: PPUSH
23998: CALL_OW 1
24002: ST_TO_ADDR
// if not tmp then
24003: LD_VAR 0 4
24007: NOT
24008: IFFALSE 24012
// continue ;
24010: GO 23960
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24012: LD_ADDR_VAR 0 6
24016: PUSH
24017: LD_EXP 74
24021: PUSH
24022: LD_VAR 0 2
24026: ARRAY
24027: PPUSH
24028: LD_INT 2
24030: PUSH
24031: LD_INT 30
24033: PUSH
24034: LD_INT 4
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: PUSH
24041: LD_INT 30
24043: PUSH
24044: LD_INT 5
24046: PUSH
24047: EMPTY
24048: LIST
24049: LIST
24050: PUSH
24051: EMPTY
24052: LIST
24053: LIST
24054: LIST
24055: PPUSH
24056: CALL_OW 72
24060: PUSH
24061: LD_EXP 74
24065: PUSH
24066: LD_VAR 0 2
24070: ARRAY
24071: PPUSH
24072: LD_INT 2
24074: PUSH
24075: LD_INT 30
24077: PUSH
24078: LD_INT 0
24080: PUSH
24081: EMPTY
24082: LIST
24083: LIST
24084: PUSH
24085: LD_INT 30
24087: PUSH
24088: LD_INT 1
24090: PUSH
24091: EMPTY
24092: LIST
24093: LIST
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: LIST
24099: PPUSH
24100: CALL_OW 72
24104: PUSH
24105: LD_EXP 74
24109: PUSH
24110: LD_VAR 0 2
24114: ARRAY
24115: PPUSH
24116: LD_INT 30
24118: PUSH
24119: LD_INT 3
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: PPUSH
24126: CALL_OW 72
24130: PUSH
24131: LD_EXP 74
24135: PUSH
24136: LD_VAR 0 2
24140: ARRAY
24141: PPUSH
24142: LD_INT 2
24144: PUSH
24145: LD_INT 30
24147: PUSH
24148: LD_INT 6
24150: PUSH
24151: EMPTY
24152: LIST
24153: LIST
24154: PUSH
24155: LD_INT 30
24157: PUSH
24158: LD_INT 7
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: PUSH
24165: LD_INT 30
24167: PUSH
24168: LD_INT 8
24170: PUSH
24171: EMPTY
24172: LIST
24173: LIST
24174: PUSH
24175: EMPTY
24176: LIST
24177: LIST
24178: LIST
24179: LIST
24180: PPUSH
24181: CALL_OW 72
24185: PUSH
24186: EMPTY
24187: LIST
24188: LIST
24189: LIST
24190: LIST
24191: ST_TO_ADDR
// for j = 1 to 4 do
24192: LD_ADDR_VAR 0 3
24196: PUSH
24197: DOUBLE
24198: LD_INT 1
24200: DEC
24201: ST_TO_ADDR
24202: LD_INT 4
24204: PUSH
24205: FOR_TO
24206: IFFALSE 24397
// begin if not tmp [ j ] then
24208: LD_VAR 0 4
24212: PUSH
24213: LD_VAR 0 3
24217: ARRAY
24218: NOT
24219: IFFALSE 24223
// continue ;
24221: GO 24205
// for p in tmp [ j ] do
24223: LD_ADDR_VAR 0 5
24227: PUSH
24228: LD_VAR 0 4
24232: PUSH
24233: LD_VAR 0 3
24237: ARRAY
24238: PUSH
24239: FOR_IN
24240: IFFALSE 24393
// begin if not b [ j ] then
24242: LD_VAR 0 6
24246: PUSH
24247: LD_VAR 0 3
24251: ARRAY
24252: NOT
24253: IFFALSE 24257
// break ;
24255: GO 24393
// e := 0 ;
24257: LD_ADDR_VAR 0 7
24261: PUSH
24262: LD_INT 0
24264: ST_TO_ADDR
// for k in b [ j ] do
24265: LD_ADDR_VAR 0 8
24269: PUSH
24270: LD_VAR 0 6
24274: PUSH
24275: LD_VAR 0 3
24279: ARRAY
24280: PUSH
24281: FOR_IN
24282: IFFALSE 24309
// if IsNotFull ( k ) then
24284: LD_VAR 0 8
24288: PPUSH
24289: CALL 53900 0 1
24293: IFFALSE 24307
// begin e := k ;
24295: LD_ADDR_VAR 0 7
24299: PUSH
24300: LD_VAR 0 8
24304: ST_TO_ADDR
// break ;
24305: GO 24309
// end ;
24307: GO 24281
24309: POP
24310: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24311: LD_VAR 0 7
24315: PUSH
24316: LD_VAR 0 5
24320: PPUSH
24321: LD_VAR 0 7
24325: PPUSH
24326: CALL 91019 0 2
24330: NOT
24331: AND
24332: IFFALSE 24391
// begin if IsInUnit ( p ) then
24334: LD_VAR 0 5
24338: PPUSH
24339: CALL_OW 310
24343: IFFALSE 24354
// ComExitBuilding ( p ) ;
24345: LD_VAR 0 5
24349: PPUSH
24350: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24354: LD_VAR 0 5
24358: PPUSH
24359: LD_VAR 0 7
24363: PPUSH
24364: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24368: LD_VAR 0 5
24372: PPUSH
24373: LD_VAR 0 3
24377: PPUSH
24378: CALL_OW 183
// AddComExitBuilding ( p ) ;
24382: LD_VAR 0 5
24386: PPUSH
24387: CALL_OW 182
// end ; end ;
24391: GO 24239
24393: POP
24394: POP
// end ;
24395: GO 24205
24397: POP
24398: POP
// end ;
24399: GO 23960
24401: POP
24402: POP
// end ;
24403: LD_VAR 0 1
24407: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
24408: LD_INT 0
24410: PPUSH
24411: PPUSH
24412: PPUSH
24413: PPUSH
24414: PPUSH
24415: PPUSH
24416: PPUSH
24417: PPUSH
24418: PPUSH
24419: PPUSH
24420: PPUSH
24421: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24422: LD_VAR 0 1
24426: NOT
24427: PUSH
24428: LD_EXP 74
24432: PUSH
24433: LD_VAR 0 1
24437: ARRAY
24438: NOT
24439: OR
24440: PUSH
24441: LD_EXP 74
24445: PUSH
24446: LD_VAR 0 1
24450: ARRAY
24451: PPUSH
24452: LD_INT 2
24454: PUSH
24455: LD_INT 30
24457: PUSH
24458: LD_INT 0
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: PUSH
24465: LD_INT 30
24467: PUSH
24468: LD_INT 1
24470: PUSH
24471: EMPTY
24472: LIST
24473: LIST
24474: PUSH
24475: EMPTY
24476: LIST
24477: LIST
24478: LIST
24479: PPUSH
24480: CALL_OW 72
24484: NOT
24485: OR
24486: IFFALSE 24490
// exit ;
24488: GO 27993
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24490: LD_ADDR_VAR 0 4
24494: PUSH
24495: LD_EXP 74
24499: PUSH
24500: LD_VAR 0 1
24504: ARRAY
24505: PPUSH
24506: LD_INT 2
24508: PUSH
24509: LD_INT 25
24511: PUSH
24512: LD_INT 1
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: PUSH
24519: LD_INT 25
24521: PUSH
24522: LD_INT 2
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: PUSH
24529: LD_INT 25
24531: PUSH
24532: LD_INT 3
24534: PUSH
24535: EMPTY
24536: LIST
24537: LIST
24538: PUSH
24539: LD_INT 25
24541: PUSH
24542: LD_INT 4
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: PUSH
24549: LD_INT 25
24551: PUSH
24552: LD_INT 5
24554: PUSH
24555: EMPTY
24556: LIST
24557: LIST
24558: PUSH
24559: LD_INT 25
24561: PUSH
24562: LD_INT 8
24564: PUSH
24565: EMPTY
24566: LIST
24567: LIST
24568: PUSH
24569: LD_INT 25
24571: PUSH
24572: LD_INT 9
24574: PUSH
24575: EMPTY
24576: LIST
24577: LIST
24578: PUSH
24579: EMPTY
24580: LIST
24581: LIST
24582: LIST
24583: LIST
24584: LIST
24585: LIST
24586: LIST
24587: LIST
24588: PPUSH
24589: CALL_OW 72
24593: ST_TO_ADDR
// if not tmp then
24594: LD_VAR 0 4
24598: NOT
24599: IFFALSE 24603
// exit ;
24601: GO 27993
// for i in tmp do
24603: LD_ADDR_VAR 0 3
24607: PUSH
24608: LD_VAR 0 4
24612: PUSH
24613: FOR_IN
24614: IFFALSE 24645
// if GetTag ( i ) then
24616: LD_VAR 0 3
24620: PPUSH
24621: CALL_OW 110
24625: IFFALSE 24643
// tmp := tmp diff i ;
24627: LD_ADDR_VAR 0 4
24631: PUSH
24632: LD_VAR 0 4
24636: PUSH
24637: LD_VAR 0 3
24641: DIFF
24642: ST_TO_ADDR
24643: GO 24613
24645: POP
24646: POP
// if not tmp then
24647: LD_VAR 0 4
24651: NOT
24652: IFFALSE 24656
// exit ;
24654: GO 27993
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24656: LD_ADDR_VAR 0 5
24660: PUSH
24661: LD_EXP 74
24665: PUSH
24666: LD_VAR 0 1
24670: ARRAY
24671: PPUSH
24672: LD_INT 2
24674: PUSH
24675: LD_INT 25
24677: PUSH
24678: LD_INT 1
24680: PUSH
24681: EMPTY
24682: LIST
24683: LIST
24684: PUSH
24685: LD_INT 25
24687: PUSH
24688: LD_INT 5
24690: PUSH
24691: EMPTY
24692: LIST
24693: LIST
24694: PUSH
24695: LD_INT 25
24697: PUSH
24698: LD_INT 8
24700: PUSH
24701: EMPTY
24702: LIST
24703: LIST
24704: PUSH
24705: LD_INT 25
24707: PUSH
24708: LD_INT 9
24710: PUSH
24711: EMPTY
24712: LIST
24713: LIST
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: LIST
24719: LIST
24720: LIST
24721: PPUSH
24722: CALL_OW 72
24726: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
24727: LD_ADDR_VAR 0 6
24731: PUSH
24732: LD_EXP 74
24736: PUSH
24737: LD_VAR 0 1
24741: ARRAY
24742: PPUSH
24743: LD_INT 25
24745: PUSH
24746: LD_INT 2
24748: PUSH
24749: EMPTY
24750: LIST
24751: LIST
24752: PPUSH
24753: CALL_OW 72
24757: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
24758: LD_ADDR_VAR 0 7
24762: PUSH
24763: LD_EXP 74
24767: PUSH
24768: LD_VAR 0 1
24772: ARRAY
24773: PPUSH
24774: LD_INT 25
24776: PUSH
24777: LD_INT 3
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PPUSH
24784: CALL_OW 72
24788: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
24789: LD_ADDR_VAR 0 8
24793: PUSH
24794: LD_EXP 74
24798: PUSH
24799: LD_VAR 0 1
24803: ARRAY
24804: PPUSH
24805: LD_INT 25
24807: PUSH
24808: LD_INT 4
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: LD_INT 24
24817: PUSH
24818: LD_INT 251
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PPUSH
24829: CALL_OW 72
24833: ST_TO_ADDR
// if mc_scan [ base ] then
24834: LD_EXP 97
24838: PUSH
24839: LD_VAR 0 1
24843: ARRAY
24844: IFFALSE 25305
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
24846: LD_ADDR_EXP 116
24850: PUSH
24851: LD_EXP 116
24855: PPUSH
24856: LD_VAR 0 1
24860: PPUSH
24861: LD_INT 4
24863: PPUSH
24864: CALL_OW 1
24868: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
24869: LD_ADDR_VAR 0 12
24873: PUSH
24874: LD_EXP 74
24878: PUSH
24879: LD_VAR 0 1
24883: ARRAY
24884: PPUSH
24885: LD_INT 2
24887: PUSH
24888: LD_INT 30
24890: PUSH
24891: LD_INT 4
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PUSH
24898: LD_INT 30
24900: PUSH
24901: LD_INT 5
24903: PUSH
24904: EMPTY
24905: LIST
24906: LIST
24907: PUSH
24908: EMPTY
24909: LIST
24910: LIST
24911: LIST
24912: PPUSH
24913: CALL_OW 72
24917: ST_TO_ADDR
// if not b then
24918: LD_VAR 0 12
24922: NOT
24923: IFFALSE 24927
// exit ;
24925: GO 27993
// p := [ ] ;
24927: LD_ADDR_VAR 0 11
24931: PUSH
24932: EMPTY
24933: ST_TO_ADDR
// if sci >= 2 then
24934: LD_VAR 0 8
24938: PUSH
24939: LD_INT 2
24941: GREATEREQUAL
24942: IFFALSE 24973
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
24944: LD_ADDR_VAR 0 8
24948: PUSH
24949: LD_VAR 0 8
24953: PUSH
24954: LD_INT 1
24956: ARRAY
24957: PUSH
24958: LD_VAR 0 8
24962: PUSH
24963: LD_INT 2
24965: ARRAY
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: ST_TO_ADDR
24971: GO 25034
// if sci = 1 then
24973: LD_VAR 0 8
24977: PUSH
24978: LD_INT 1
24980: EQUAL
24981: IFFALSE 25002
// sci := [ sci [ 1 ] ] else
24983: LD_ADDR_VAR 0 8
24987: PUSH
24988: LD_VAR 0 8
24992: PUSH
24993: LD_INT 1
24995: ARRAY
24996: PUSH
24997: EMPTY
24998: LIST
24999: ST_TO_ADDR
25000: GO 25034
// if sci = 0 then
25002: LD_VAR 0 8
25006: PUSH
25007: LD_INT 0
25009: EQUAL
25010: IFFALSE 25034
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25012: LD_ADDR_VAR 0 11
25016: PUSH
25017: LD_VAR 0 4
25021: PPUSH
25022: LD_INT 4
25024: PPUSH
25025: CALL 90882 0 2
25029: PUSH
25030: LD_INT 1
25032: ARRAY
25033: ST_TO_ADDR
// if eng > 4 then
25034: LD_VAR 0 6
25038: PUSH
25039: LD_INT 4
25041: GREATER
25042: IFFALSE 25088
// for i = eng downto 4 do
25044: LD_ADDR_VAR 0 3
25048: PUSH
25049: DOUBLE
25050: LD_VAR 0 6
25054: INC
25055: ST_TO_ADDR
25056: LD_INT 4
25058: PUSH
25059: FOR_DOWNTO
25060: IFFALSE 25086
// eng := eng diff eng [ i ] ;
25062: LD_ADDR_VAR 0 6
25066: PUSH
25067: LD_VAR 0 6
25071: PUSH
25072: LD_VAR 0 6
25076: PUSH
25077: LD_VAR 0 3
25081: ARRAY
25082: DIFF
25083: ST_TO_ADDR
25084: GO 25059
25086: POP
25087: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25088: LD_ADDR_VAR 0 4
25092: PUSH
25093: LD_VAR 0 4
25097: PUSH
25098: LD_VAR 0 5
25102: PUSH
25103: LD_VAR 0 6
25107: UNION
25108: PUSH
25109: LD_VAR 0 7
25113: UNION
25114: PUSH
25115: LD_VAR 0 8
25119: UNION
25120: DIFF
25121: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25122: LD_ADDR_VAR 0 13
25126: PUSH
25127: LD_EXP 74
25131: PUSH
25132: LD_VAR 0 1
25136: ARRAY
25137: PPUSH
25138: LD_INT 2
25140: PUSH
25141: LD_INT 30
25143: PUSH
25144: LD_INT 32
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: PUSH
25151: LD_INT 30
25153: PUSH
25154: LD_INT 31
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: LIST
25165: PPUSH
25166: CALL_OW 72
25170: PUSH
25171: LD_EXP 74
25175: PUSH
25176: LD_VAR 0 1
25180: ARRAY
25181: PPUSH
25182: LD_INT 2
25184: PUSH
25185: LD_INT 30
25187: PUSH
25188: LD_INT 4
25190: PUSH
25191: EMPTY
25192: LIST
25193: LIST
25194: PUSH
25195: LD_INT 30
25197: PUSH
25198: LD_INT 5
25200: PUSH
25201: EMPTY
25202: LIST
25203: LIST
25204: PUSH
25205: EMPTY
25206: LIST
25207: LIST
25208: LIST
25209: PPUSH
25210: CALL_OW 72
25214: PUSH
25215: LD_INT 6
25217: MUL
25218: PLUS
25219: ST_TO_ADDR
// if bcount < tmp then
25220: LD_VAR 0 13
25224: PUSH
25225: LD_VAR 0 4
25229: LESS
25230: IFFALSE 25276
// for i = tmp downto bcount do
25232: LD_ADDR_VAR 0 3
25236: PUSH
25237: DOUBLE
25238: LD_VAR 0 4
25242: INC
25243: ST_TO_ADDR
25244: LD_VAR 0 13
25248: PUSH
25249: FOR_DOWNTO
25250: IFFALSE 25274
// tmp := Delete ( tmp , tmp ) ;
25252: LD_ADDR_VAR 0 4
25256: PUSH
25257: LD_VAR 0 4
25261: PPUSH
25262: LD_VAR 0 4
25266: PPUSH
25267: CALL_OW 3
25271: ST_TO_ADDR
25272: GO 25249
25274: POP
25275: POP
// result := [ tmp , 0 , 0 , p ] ;
25276: LD_ADDR_VAR 0 2
25280: PUSH
25281: LD_VAR 0 4
25285: PUSH
25286: LD_INT 0
25288: PUSH
25289: LD_INT 0
25291: PUSH
25292: LD_VAR 0 11
25296: PUSH
25297: EMPTY
25298: LIST
25299: LIST
25300: LIST
25301: LIST
25302: ST_TO_ADDR
// exit ;
25303: GO 27993
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25305: LD_EXP 74
25309: PUSH
25310: LD_VAR 0 1
25314: ARRAY
25315: PPUSH
25316: LD_INT 2
25318: PUSH
25319: LD_INT 30
25321: PUSH
25322: LD_INT 6
25324: PUSH
25325: EMPTY
25326: LIST
25327: LIST
25328: PUSH
25329: LD_INT 30
25331: PUSH
25332: LD_INT 7
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 30
25341: PUSH
25342: LD_INT 8
25344: PUSH
25345: EMPTY
25346: LIST
25347: LIST
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: LIST
25353: LIST
25354: PPUSH
25355: CALL_OW 72
25359: NOT
25360: PUSH
25361: LD_EXP 74
25365: PUSH
25366: LD_VAR 0 1
25370: ARRAY
25371: PPUSH
25372: LD_INT 30
25374: PUSH
25375: LD_INT 3
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: PPUSH
25382: CALL_OW 72
25386: NOT
25387: AND
25388: IFFALSE 25460
// begin if eng = tmp then
25390: LD_VAR 0 6
25394: PUSH
25395: LD_VAR 0 4
25399: EQUAL
25400: IFFALSE 25404
// exit ;
25402: GO 27993
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
25404: LD_ADDR_EXP 116
25408: PUSH
25409: LD_EXP 116
25413: PPUSH
25414: LD_VAR 0 1
25418: PPUSH
25419: LD_INT 1
25421: PPUSH
25422: CALL_OW 1
25426: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
25427: LD_ADDR_VAR 0 2
25431: PUSH
25432: LD_INT 0
25434: PUSH
25435: LD_VAR 0 4
25439: PUSH
25440: LD_VAR 0 6
25444: DIFF
25445: PUSH
25446: LD_INT 0
25448: PUSH
25449: LD_INT 0
25451: PUSH
25452: EMPTY
25453: LIST
25454: LIST
25455: LIST
25456: LIST
25457: ST_TO_ADDR
// exit ;
25458: GO 27993
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25460: LD_EXP 101
25464: PUSH
25465: LD_EXP 100
25469: PUSH
25470: LD_VAR 0 1
25474: ARRAY
25475: ARRAY
25476: PUSH
25477: LD_EXP 74
25481: PUSH
25482: LD_VAR 0 1
25486: ARRAY
25487: PPUSH
25488: LD_INT 2
25490: PUSH
25491: LD_INT 30
25493: PUSH
25494: LD_INT 6
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: PUSH
25501: LD_INT 30
25503: PUSH
25504: LD_INT 7
25506: PUSH
25507: EMPTY
25508: LIST
25509: LIST
25510: PUSH
25511: LD_INT 30
25513: PUSH
25514: LD_INT 8
25516: PUSH
25517: EMPTY
25518: LIST
25519: LIST
25520: PUSH
25521: EMPTY
25522: LIST
25523: LIST
25524: LIST
25525: LIST
25526: PPUSH
25527: CALL_OW 72
25531: AND
25532: PUSH
25533: LD_EXP 74
25537: PUSH
25538: LD_VAR 0 1
25542: ARRAY
25543: PPUSH
25544: LD_INT 30
25546: PUSH
25547: LD_INT 3
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PPUSH
25554: CALL_OW 72
25558: NOT
25559: AND
25560: IFFALSE 25774
// begin if sci >= 6 then
25562: LD_VAR 0 8
25566: PUSH
25567: LD_INT 6
25569: GREATEREQUAL
25570: IFFALSE 25574
// exit ;
25572: GO 27993
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
25574: LD_ADDR_EXP 116
25578: PUSH
25579: LD_EXP 116
25583: PPUSH
25584: LD_VAR 0 1
25588: PPUSH
25589: LD_INT 2
25591: PPUSH
25592: CALL_OW 1
25596: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
25597: LD_ADDR_VAR 0 9
25601: PUSH
25602: LD_VAR 0 4
25606: PUSH
25607: LD_VAR 0 8
25611: DIFF
25612: PPUSH
25613: LD_INT 4
25615: PPUSH
25616: CALL 90882 0 2
25620: ST_TO_ADDR
// p := [ ] ;
25621: LD_ADDR_VAR 0 11
25625: PUSH
25626: EMPTY
25627: ST_TO_ADDR
// if sci < 6 and sort > 6 then
25628: LD_VAR 0 8
25632: PUSH
25633: LD_INT 6
25635: LESS
25636: PUSH
25637: LD_VAR 0 9
25641: PUSH
25642: LD_INT 6
25644: GREATER
25645: AND
25646: IFFALSE 25727
// begin for i = 1 to 6 - sci do
25648: LD_ADDR_VAR 0 3
25652: PUSH
25653: DOUBLE
25654: LD_INT 1
25656: DEC
25657: ST_TO_ADDR
25658: LD_INT 6
25660: PUSH
25661: LD_VAR 0 8
25665: MINUS
25666: PUSH
25667: FOR_TO
25668: IFFALSE 25723
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
25670: LD_ADDR_VAR 0 11
25674: PUSH
25675: LD_VAR 0 11
25679: PPUSH
25680: LD_VAR 0 11
25684: PUSH
25685: LD_INT 1
25687: PLUS
25688: PPUSH
25689: LD_VAR 0 9
25693: PUSH
25694: LD_INT 1
25696: ARRAY
25697: PPUSH
25698: CALL_OW 2
25702: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
25703: LD_ADDR_VAR 0 9
25707: PUSH
25708: LD_VAR 0 9
25712: PPUSH
25713: LD_INT 1
25715: PPUSH
25716: CALL_OW 3
25720: ST_TO_ADDR
// end ;
25721: GO 25667
25723: POP
25724: POP
// end else
25725: GO 25747
// if sort then
25727: LD_VAR 0 9
25731: IFFALSE 25747
// p := sort [ 1 ] ;
25733: LD_ADDR_VAR 0 11
25737: PUSH
25738: LD_VAR 0 9
25742: PUSH
25743: LD_INT 1
25745: ARRAY
25746: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
25747: LD_ADDR_VAR 0 2
25751: PUSH
25752: LD_INT 0
25754: PUSH
25755: LD_INT 0
25757: PUSH
25758: LD_INT 0
25760: PUSH
25761: LD_VAR 0 11
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: LIST
25770: LIST
25771: ST_TO_ADDR
// exit ;
25772: GO 27993
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25774: LD_EXP 101
25778: PUSH
25779: LD_EXP 100
25783: PUSH
25784: LD_VAR 0 1
25788: ARRAY
25789: ARRAY
25790: PUSH
25791: LD_EXP 74
25795: PUSH
25796: LD_VAR 0 1
25800: ARRAY
25801: PPUSH
25802: LD_INT 2
25804: PUSH
25805: LD_INT 30
25807: PUSH
25808: LD_INT 6
25810: PUSH
25811: EMPTY
25812: LIST
25813: LIST
25814: PUSH
25815: LD_INT 30
25817: PUSH
25818: LD_INT 7
25820: PUSH
25821: EMPTY
25822: LIST
25823: LIST
25824: PUSH
25825: LD_INT 30
25827: PUSH
25828: LD_INT 8
25830: PUSH
25831: EMPTY
25832: LIST
25833: LIST
25834: PUSH
25835: EMPTY
25836: LIST
25837: LIST
25838: LIST
25839: LIST
25840: PPUSH
25841: CALL_OW 72
25845: AND
25846: PUSH
25847: LD_EXP 74
25851: PUSH
25852: LD_VAR 0 1
25856: ARRAY
25857: PPUSH
25858: LD_INT 30
25860: PUSH
25861: LD_INT 3
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: PPUSH
25868: CALL_OW 72
25872: AND
25873: IFFALSE 26607
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
25875: LD_ADDR_EXP 116
25879: PUSH
25880: LD_EXP 116
25884: PPUSH
25885: LD_VAR 0 1
25889: PPUSH
25890: LD_INT 3
25892: PPUSH
25893: CALL_OW 1
25897: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25898: LD_ADDR_VAR 0 2
25902: PUSH
25903: LD_INT 0
25905: PUSH
25906: LD_INT 0
25908: PUSH
25909: LD_INT 0
25911: PUSH
25912: LD_INT 0
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: LIST
25919: LIST
25920: ST_TO_ADDR
// if not eng then
25921: LD_VAR 0 6
25925: NOT
25926: IFFALSE 25989
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
25928: LD_ADDR_VAR 0 11
25932: PUSH
25933: LD_VAR 0 4
25937: PPUSH
25938: LD_INT 2
25940: PPUSH
25941: CALL 90882 0 2
25945: PUSH
25946: LD_INT 1
25948: ARRAY
25949: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
25950: LD_ADDR_VAR 0 2
25954: PUSH
25955: LD_VAR 0 2
25959: PPUSH
25960: LD_INT 2
25962: PPUSH
25963: LD_VAR 0 11
25967: PPUSH
25968: CALL_OW 1
25972: ST_TO_ADDR
// tmp := tmp diff p ;
25973: LD_ADDR_VAR 0 4
25977: PUSH
25978: LD_VAR 0 4
25982: PUSH
25983: LD_VAR 0 11
25987: DIFF
25988: ST_TO_ADDR
// end ; if tmp and sci < 6 then
25989: LD_VAR 0 4
25993: PUSH
25994: LD_VAR 0 8
25998: PUSH
25999: LD_INT 6
26001: LESS
26002: AND
26003: IFFALSE 26191
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26005: LD_ADDR_VAR 0 9
26009: PUSH
26010: LD_VAR 0 4
26014: PUSH
26015: LD_VAR 0 8
26019: PUSH
26020: LD_VAR 0 7
26024: UNION
26025: DIFF
26026: PPUSH
26027: LD_INT 4
26029: PPUSH
26030: CALL 90882 0 2
26034: ST_TO_ADDR
// p := [ ] ;
26035: LD_ADDR_VAR 0 11
26039: PUSH
26040: EMPTY
26041: ST_TO_ADDR
// if sort then
26042: LD_VAR 0 9
26046: IFFALSE 26162
// for i = 1 to 6 - sci do
26048: LD_ADDR_VAR 0 3
26052: PUSH
26053: DOUBLE
26054: LD_INT 1
26056: DEC
26057: ST_TO_ADDR
26058: LD_INT 6
26060: PUSH
26061: LD_VAR 0 8
26065: MINUS
26066: PUSH
26067: FOR_TO
26068: IFFALSE 26160
// begin if i = sort then
26070: LD_VAR 0 3
26074: PUSH
26075: LD_VAR 0 9
26079: EQUAL
26080: IFFALSE 26084
// break ;
26082: GO 26160
// if GetClass ( i ) = 4 then
26084: LD_VAR 0 3
26088: PPUSH
26089: CALL_OW 257
26093: PUSH
26094: LD_INT 4
26096: EQUAL
26097: IFFALSE 26101
// continue ;
26099: GO 26067
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26101: LD_ADDR_VAR 0 11
26105: PUSH
26106: LD_VAR 0 11
26110: PPUSH
26111: LD_VAR 0 11
26115: PUSH
26116: LD_INT 1
26118: PLUS
26119: PPUSH
26120: LD_VAR 0 9
26124: PUSH
26125: LD_VAR 0 3
26129: ARRAY
26130: PPUSH
26131: CALL_OW 2
26135: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26136: LD_ADDR_VAR 0 4
26140: PUSH
26141: LD_VAR 0 4
26145: PUSH
26146: LD_VAR 0 9
26150: PUSH
26151: LD_VAR 0 3
26155: ARRAY
26156: DIFF
26157: ST_TO_ADDR
// end ;
26158: GO 26067
26160: POP
26161: POP
// if p then
26162: LD_VAR 0 11
26166: IFFALSE 26191
// result := Replace ( result , 4 , p ) ;
26168: LD_ADDR_VAR 0 2
26172: PUSH
26173: LD_VAR 0 2
26177: PPUSH
26178: LD_INT 4
26180: PPUSH
26181: LD_VAR 0 11
26185: PPUSH
26186: CALL_OW 1
26190: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26191: LD_VAR 0 4
26195: PUSH
26196: LD_VAR 0 7
26200: PUSH
26201: LD_INT 6
26203: LESS
26204: AND
26205: IFFALSE 26393
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26207: LD_ADDR_VAR 0 9
26211: PUSH
26212: LD_VAR 0 4
26216: PUSH
26217: LD_VAR 0 8
26221: PUSH
26222: LD_VAR 0 7
26226: UNION
26227: DIFF
26228: PPUSH
26229: LD_INT 3
26231: PPUSH
26232: CALL 90882 0 2
26236: ST_TO_ADDR
// p := [ ] ;
26237: LD_ADDR_VAR 0 11
26241: PUSH
26242: EMPTY
26243: ST_TO_ADDR
// if sort then
26244: LD_VAR 0 9
26248: IFFALSE 26364
// for i = 1 to 6 - mech do
26250: LD_ADDR_VAR 0 3
26254: PUSH
26255: DOUBLE
26256: LD_INT 1
26258: DEC
26259: ST_TO_ADDR
26260: LD_INT 6
26262: PUSH
26263: LD_VAR 0 7
26267: MINUS
26268: PUSH
26269: FOR_TO
26270: IFFALSE 26362
// begin if i = sort then
26272: LD_VAR 0 3
26276: PUSH
26277: LD_VAR 0 9
26281: EQUAL
26282: IFFALSE 26286
// break ;
26284: GO 26362
// if GetClass ( i ) = 3 then
26286: LD_VAR 0 3
26290: PPUSH
26291: CALL_OW 257
26295: PUSH
26296: LD_INT 3
26298: EQUAL
26299: IFFALSE 26303
// continue ;
26301: GO 26269
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26303: LD_ADDR_VAR 0 11
26307: PUSH
26308: LD_VAR 0 11
26312: PPUSH
26313: LD_VAR 0 11
26317: PUSH
26318: LD_INT 1
26320: PLUS
26321: PPUSH
26322: LD_VAR 0 9
26326: PUSH
26327: LD_VAR 0 3
26331: ARRAY
26332: PPUSH
26333: CALL_OW 2
26337: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26338: LD_ADDR_VAR 0 4
26342: PUSH
26343: LD_VAR 0 4
26347: PUSH
26348: LD_VAR 0 9
26352: PUSH
26353: LD_VAR 0 3
26357: ARRAY
26358: DIFF
26359: ST_TO_ADDR
// end ;
26360: GO 26269
26362: POP
26363: POP
// if p then
26364: LD_VAR 0 11
26368: IFFALSE 26393
// result := Replace ( result , 3 , p ) ;
26370: LD_ADDR_VAR 0 2
26374: PUSH
26375: LD_VAR 0 2
26379: PPUSH
26380: LD_INT 3
26382: PPUSH
26383: LD_VAR 0 11
26387: PPUSH
26388: CALL_OW 1
26392: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
26393: LD_VAR 0 4
26397: PUSH
26398: LD_INT 6
26400: GREATER
26401: PUSH
26402: LD_VAR 0 6
26406: PUSH
26407: LD_INT 6
26409: LESS
26410: AND
26411: IFFALSE 26605
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26413: LD_ADDR_VAR 0 9
26417: PUSH
26418: LD_VAR 0 4
26422: PUSH
26423: LD_VAR 0 8
26427: PUSH
26428: LD_VAR 0 7
26432: UNION
26433: PUSH
26434: LD_VAR 0 6
26438: UNION
26439: DIFF
26440: PPUSH
26441: LD_INT 2
26443: PPUSH
26444: CALL 90882 0 2
26448: ST_TO_ADDR
// p := [ ] ;
26449: LD_ADDR_VAR 0 11
26453: PUSH
26454: EMPTY
26455: ST_TO_ADDR
// if sort then
26456: LD_VAR 0 9
26460: IFFALSE 26576
// for i = 1 to 6 - eng do
26462: LD_ADDR_VAR 0 3
26466: PUSH
26467: DOUBLE
26468: LD_INT 1
26470: DEC
26471: ST_TO_ADDR
26472: LD_INT 6
26474: PUSH
26475: LD_VAR 0 6
26479: MINUS
26480: PUSH
26481: FOR_TO
26482: IFFALSE 26574
// begin if i = sort then
26484: LD_VAR 0 3
26488: PUSH
26489: LD_VAR 0 9
26493: EQUAL
26494: IFFALSE 26498
// break ;
26496: GO 26574
// if GetClass ( i ) = 2 then
26498: LD_VAR 0 3
26502: PPUSH
26503: CALL_OW 257
26507: PUSH
26508: LD_INT 2
26510: EQUAL
26511: IFFALSE 26515
// continue ;
26513: GO 26481
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26515: LD_ADDR_VAR 0 11
26519: PUSH
26520: LD_VAR 0 11
26524: PPUSH
26525: LD_VAR 0 11
26529: PUSH
26530: LD_INT 1
26532: PLUS
26533: PPUSH
26534: LD_VAR 0 9
26538: PUSH
26539: LD_VAR 0 3
26543: ARRAY
26544: PPUSH
26545: CALL_OW 2
26549: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26550: LD_ADDR_VAR 0 4
26554: PUSH
26555: LD_VAR 0 4
26559: PUSH
26560: LD_VAR 0 9
26564: PUSH
26565: LD_VAR 0 3
26569: ARRAY
26570: DIFF
26571: ST_TO_ADDR
// end ;
26572: GO 26481
26574: POP
26575: POP
// if p then
26576: LD_VAR 0 11
26580: IFFALSE 26605
// result := Replace ( result , 2 , p ) ;
26582: LD_ADDR_VAR 0 2
26586: PUSH
26587: LD_VAR 0 2
26591: PPUSH
26592: LD_INT 2
26594: PPUSH
26595: LD_VAR 0 11
26599: PPUSH
26600: CALL_OW 1
26604: ST_TO_ADDR
// end ; exit ;
26605: GO 27993
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
26607: LD_EXP 101
26611: PUSH
26612: LD_EXP 100
26616: PUSH
26617: LD_VAR 0 1
26621: ARRAY
26622: ARRAY
26623: NOT
26624: PUSH
26625: LD_EXP 74
26629: PUSH
26630: LD_VAR 0 1
26634: ARRAY
26635: PPUSH
26636: LD_INT 30
26638: PUSH
26639: LD_INT 3
26641: PUSH
26642: EMPTY
26643: LIST
26644: LIST
26645: PPUSH
26646: CALL_OW 72
26650: AND
26651: PUSH
26652: LD_EXP 79
26656: PUSH
26657: LD_VAR 0 1
26661: ARRAY
26662: AND
26663: IFFALSE 27271
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
26665: LD_ADDR_EXP 116
26669: PUSH
26670: LD_EXP 116
26674: PPUSH
26675: LD_VAR 0 1
26679: PPUSH
26680: LD_INT 5
26682: PPUSH
26683: CALL_OW 1
26687: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26688: LD_ADDR_VAR 0 2
26692: PUSH
26693: LD_INT 0
26695: PUSH
26696: LD_INT 0
26698: PUSH
26699: LD_INT 0
26701: PUSH
26702: LD_INT 0
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: LIST
26709: LIST
26710: ST_TO_ADDR
// if sci > 1 then
26711: LD_VAR 0 8
26715: PUSH
26716: LD_INT 1
26718: GREATER
26719: IFFALSE 26747
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
26721: LD_ADDR_VAR 0 4
26725: PUSH
26726: LD_VAR 0 4
26730: PUSH
26731: LD_VAR 0 8
26735: PUSH
26736: LD_VAR 0 8
26740: PUSH
26741: LD_INT 1
26743: ARRAY
26744: DIFF
26745: DIFF
26746: ST_TO_ADDR
// if tmp and not sci then
26747: LD_VAR 0 4
26751: PUSH
26752: LD_VAR 0 8
26756: NOT
26757: AND
26758: IFFALSE 26827
// begin sort := SortBySkill ( tmp , 4 ) ;
26760: LD_ADDR_VAR 0 9
26764: PUSH
26765: LD_VAR 0 4
26769: PPUSH
26770: LD_INT 4
26772: PPUSH
26773: CALL 90882 0 2
26777: ST_TO_ADDR
// if sort then
26778: LD_VAR 0 9
26782: IFFALSE 26798
// p := sort [ 1 ] ;
26784: LD_ADDR_VAR 0 11
26788: PUSH
26789: LD_VAR 0 9
26793: PUSH
26794: LD_INT 1
26796: ARRAY
26797: ST_TO_ADDR
// if p then
26798: LD_VAR 0 11
26802: IFFALSE 26827
// result := Replace ( result , 4 , p ) ;
26804: LD_ADDR_VAR 0 2
26808: PUSH
26809: LD_VAR 0 2
26813: PPUSH
26814: LD_INT 4
26816: PPUSH
26817: LD_VAR 0 11
26821: PPUSH
26822: CALL_OW 1
26826: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26827: LD_ADDR_VAR 0 4
26831: PUSH
26832: LD_VAR 0 4
26836: PUSH
26837: LD_VAR 0 7
26841: DIFF
26842: ST_TO_ADDR
// if tmp and mech < 6 then
26843: LD_VAR 0 4
26847: PUSH
26848: LD_VAR 0 7
26852: PUSH
26853: LD_INT 6
26855: LESS
26856: AND
26857: IFFALSE 27045
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26859: LD_ADDR_VAR 0 9
26863: PUSH
26864: LD_VAR 0 4
26868: PUSH
26869: LD_VAR 0 8
26873: PUSH
26874: LD_VAR 0 7
26878: UNION
26879: DIFF
26880: PPUSH
26881: LD_INT 3
26883: PPUSH
26884: CALL 90882 0 2
26888: ST_TO_ADDR
// p := [ ] ;
26889: LD_ADDR_VAR 0 11
26893: PUSH
26894: EMPTY
26895: ST_TO_ADDR
// if sort then
26896: LD_VAR 0 9
26900: IFFALSE 27016
// for i = 1 to 6 - mech do
26902: LD_ADDR_VAR 0 3
26906: PUSH
26907: DOUBLE
26908: LD_INT 1
26910: DEC
26911: ST_TO_ADDR
26912: LD_INT 6
26914: PUSH
26915: LD_VAR 0 7
26919: MINUS
26920: PUSH
26921: FOR_TO
26922: IFFALSE 27014
// begin if i = sort then
26924: LD_VAR 0 3
26928: PUSH
26929: LD_VAR 0 9
26933: EQUAL
26934: IFFALSE 26938
// break ;
26936: GO 27014
// if GetClass ( i ) = 3 then
26938: LD_VAR 0 3
26942: PPUSH
26943: CALL_OW 257
26947: PUSH
26948: LD_INT 3
26950: EQUAL
26951: IFFALSE 26955
// continue ;
26953: GO 26921
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26955: LD_ADDR_VAR 0 11
26959: PUSH
26960: LD_VAR 0 11
26964: PPUSH
26965: LD_VAR 0 11
26969: PUSH
26970: LD_INT 1
26972: PLUS
26973: PPUSH
26974: LD_VAR 0 9
26978: PUSH
26979: LD_VAR 0 3
26983: ARRAY
26984: PPUSH
26985: CALL_OW 2
26989: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26990: LD_ADDR_VAR 0 4
26994: PUSH
26995: LD_VAR 0 4
26999: PUSH
27000: LD_VAR 0 9
27004: PUSH
27005: LD_VAR 0 3
27009: ARRAY
27010: DIFF
27011: ST_TO_ADDR
// end ;
27012: GO 26921
27014: POP
27015: POP
// if p then
27016: LD_VAR 0 11
27020: IFFALSE 27045
// result := Replace ( result , 3 , p ) ;
27022: LD_ADDR_VAR 0 2
27026: PUSH
27027: LD_VAR 0 2
27031: PPUSH
27032: LD_INT 3
27034: PPUSH
27035: LD_VAR 0 11
27039: PPUSH
27040: CALL_OW 1
27044: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27045: LD_ADDR_VAR 0 4
27049: PUSH
27050: LD_VAR 0 4
27054: PUSH
27055: LD_VAR 0 6
27059: DIFF
27060: ST_TO_ADDR
// if tmp and eng < 6 then
27061: LD_VAR 0 4
27065: PUSH
27066: LD_VAR 0 6
27070: PUSH
27071: LD_INT 6
27073: LESS
27074: AND
27075: IFFALSE 27269
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27077: LD_ADDR_VAR 0 9
27081: PUSH
27082: LD_VAR 0 4
27086: PUSH
27087: LD_VAR 0 8
27091: PUSH
27092: LD_VAR 0 7
27096: UNION
27097: PUSH
27098: LD_VAR 0 6
27102: UNION
27103: DIFF
27104: PPUSH
27105: LD_INT 2
27107: PPUSH
27108: CALL 90882 0 2
27112: ST_TO_ADDR
// p := [ ] ;
27113: LD_ADDR_VAR 0 11
27117: PUSH
27118: EMPTY
27119: ST_TO_ADDR
// if sort then
27120: LD_VAR 0 9
27124: IFFALSE 27240
// for i = 1 to 6 - eng do
27126: LD_ADDR_VAR 0 3
27130: PUSH
27131: DOUBLE
27132: LD_INT 1
27134: DEC
27135: ST_TO_ADDR
27136: LD_INT 6
27138: PUSH
27139: LD_VAR 0 6
27143: MINUS
27144: PUSH
27145: FOR_TO
27146: IFFALSE 27238
// begin if i = sort then
27148: LD_VAR 0 3
27152: PUSH
27153: LD_VAR 0 9
27157: EQUAL
27158: IFFALSE 27162
// break ;
27160: GO 27238
// if GetClass ( i ) = 2 then
27162: LD_VAR 0 3
27166: PPUSH
27167: CALL_OW 257
27171: PUSH
27172: LD_INT 2
27174: EQUAL
27175: IFFALSE 27179
// continue ;
27177: GO 27145
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27179: LD_ADDR_VAR 0 11
27183: PUSH
27184: LD_VAR 0 11
27188: PPUSH
27189: LD_VAR 0 11
27193: PUSH
27194: LD_INT 1
27196: PLUS
27197: PPUSH
27198: LD_VAR 0 9
27202: PUSH
27203: LD_VAR 0 3
27207: ARRAY
27208: PPUSH
27209: CALL_OW 2
27213: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27214: LD_ADDR_VAR 0 4
27218: PUSH
27219: LD_VAR 0 4
27223: PUSH
27224: LD_VAR 0 9
27228: PUSH
27229: LD_VAR 0 3
27233: ARRAY
27234: DIFF
27235: ST_TO_ADDR
// end ;
27236: GO 27145
27238: POP
27239: POP
// if p then
27240: LD_VAR 0 11
27244: IFFALSE 27269
// result := Replace ( result , 2 , p ) ;
27246: LD_ADDR_VAR 0 2
27250: PUSH
27251: LD_VAR 0 2
27255: PPUSH
27256: LD_INT 2
27258: PPUSH
27259: LD_VAR 0 11
27263: PPUSH
27264: CALL_OW 1
27268: ST_TO_ADDR
// end ; exit ;
27269: GO 27993
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27271: LD_EXP 101
27275: PUSH
27276: LD_EXP 100
27280: PUSH
27281: LD_VAR 0 1
27285: ARRAY
27286: ARRAY
27287: NOT
27288: PUSH
27289: LD_EXP 74
27293: PUSH
27294: LD_VAR 0 1
27298: ARRAY
27299: PPUSH
27300: LD_INT 30
27302: PUSH
27303: LD_INT 3
27305: PUSH
27306: EMPTY
27307: LIST
27308: LIST
27309: PPUSH
27310: CALL_OW 72
27314: AND
27315: PUSH
27316: LD_EXP 79
27320: PUSH
27321: LD_VAR 0 1
27325: ARRAY
27326: NOT
27327: AND
27328: IFFALSE 27993
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27330: LD_ADDR_EXP 116
27334: PUSH
27335: LD_EXP 116
27339: PPUSH
27340: LD_VAR 0 1
27344: PPUSH
27345: LD_INT 6
27347: PPUSH
27348: CALL_OW 1
27352: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27353: LD_ADDR_VAR 0 2
27357: PUSH
27358: LD_INT 0
27360: PUSH
27361: LD_INT 0
27363: PUSH
27364: LD_INT 0
27366: PUSH
27367: LD_INT 0
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: LIST
27374: LIST
27375: ST_TO_ADDR
// if sci >= 1 then
27376: LD_VAR 0 8
27380: PUSH
27381: LD_INT 1
27383: GREATEREQUAL
27384: IFFALSE 27406
// tmp := tmp diff sci [ 1 ] ;
27386: LD_ADDR_VAR 0 4
27390: PUSH
27391: LD_VAR 0 4
27395: PUSH
27396: LD_VAR 0 8
27400: PUSH
27401: LD_INT 1
27403: ARRAY
27404: DIFF
27405: ST_TO_ADDR
// if tmp and not sci then
27406: LD_VAR 0 4
27410: PUSH
27411: LD_VAR 0 8
27415: NOT
27416: AND
27417: IFFALSE 27486
// begin sort := SortBySkill ( tmp , 4 ) ;
27419: LD_ADDR_VAR 0 9
27423: PUSH
27424: LD_VAR 0 4
27428: PPUSH
27429: LD_INT 4
27431: PPUSH
27432: CALL 90882 0 2
27436: ST_TO_ADDR
// if sort then
27437: LD_VAR 0 9
27441: IFFALSE 27457
// p := sort [ 1 ] ;
27443: LD_ADDR_VAR 0 11
27447: PUSH
27448: LD_VAR 0 9
27452: PUSH
27453: LD_INT 1
27455: ARRAY
27456: ST_TO_ADDR
// if p then
27457: LD_VAR 0 11
27461: IFFALSE 27486
// result := Replace ( result , 4 , p ) ;
27463: LD_ADDR_VAR 0 2
27467: PUSH
27468: LD_VAR 0 2
27472: PPUSH
27473: LD_INT 4
27475: PPUSH
27476: LD_VAR 0 11
27480: PPUSH
27481: CALL_OW 1
27485: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27486: LD_ADDR_VAR 0 4
27490: PUSH
27491: LD_VAR 0 4
27495: PUSH
27496: LD_VAR 0 7
27500: DIFF
27501: ST_TO_ADDR
// if tmp and mech < 6 then
27502: LD_VAR 0 4
27506: PUSH
27507: LD_VAR 0 7
27511: PUSH
27512: LD_INT 6
27514: LESS
27515: AND
27516: IFFALSE 27698
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
27518: LD_ADDR_VAR 0 9
27522: PUSH
27523: LD_VAR 0 4
27527: PUSH
27528: LD_VAR 0 7
27532: DIFF
27533: PPUSH
27534: LD_INT 3
27536: PPUSH
27537: CALL 90882 0 2
27541: ST_TO_ADDR
// p := [ ] ;
27542: LD_ADDR_VAR 0 11
27546: PUSH
27547: EMPTY
27548: ST_TO_ADDR
// if sort then
27549: LD_VAR 0 9
27553: IFFALSE 27669
// for i = 1 to 6 - mech do
27555: LD_ADDR_VAR 0 3
27559: PUSH
27560: DOUBLE
27561: LD_INT 1
27563: DEC
27564: ST_TO_ADDR
27565: LD_INT 6
27567: PUSH
27568: LD_VAR 0 7
27572: MINUS
27573: PUSH
27574: FOR_TO
27575: IFFALSE 27667
// begin if i = sort then
27577: LD_VAR 0 3
27581: PUSH
27582: LD_VAR 0 9
27586: EQUAL
27587: IFFALSE 27591
// break ;
27589: GO 27667
// if GetClass ( i ) = 3 then
27591: LD_VAR 0 3
27595: PPUSH
27596: CALL_OW 257
27600: PUSH
27601: LD_INT 3
27603: EQUAL
27604: IFFALSE 27608
// continue ;
27606: GO 27574
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27608: LD_ADDR_VAR 0 11
27612: PUSH
27613: LD_VAR 0 11
27617: PPUSH
27618: LD_VAR 0 11
27622: PUSH
27623: LD_INT 1
27625: PLUS
27626: PPUSH
27627: LD_VAR 0 9
27631: PUSH
27632: LD_VAR 0 3
27636: ARRAY
27637: PPUSH
27638: CALL_OW 2
27642: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27643: LD_ADDR_VAR 0 4
27647: PUSH
27648: LD_VAR 0 4
27652: PUSH
27653: LD_VAR 0 9
27657: PUSH
27658: LD_VAR 0 3
27662: ARRAY
27663: DIFF
27664: ST_TO_ADDR
// end ;
27665: GO 27574
27667: POP
27668: POP
// if p then
27669: LD_VAR 0 11
27673: IFFALSE 27698
// result := Replace ( result , 3 , p ) ;
27675: LD_ADDR_VAR 0 2
27679: PUSH
27680: LD_VAR 0 2
27684: PPUSH
27685: LD_INT 3
27687: PPUSH
27688: LD_VAR 0 11
27692: PPUSH
27693: CALL_OW 1
27697: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27698: LD_ADDR_VAR 0 4
27702: PUSH
27703: LD_VAR 0 4
27707: PUSH
27708: LD_VAR 0 6
27712: DIFF
27713: ST_TO_ADDR
// if tmp and eng < 4 then
27714: LD_VAR 0 4
27718: PUSH
27719: LD_VAR 0 6
27723: PUSH
27724: LD_INT 4
27726: LESS
27727: AND
27728: IFFALSE 27918
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
27730: LD_ADDR_VAR 0 9
27734: PUSH
27735: LD_VAR 0 4
27739: PUSH
27740: LD_VAR 0 7
27744: PUSH
27745: LD_VAR 0 6
27749: UNION
27750: DIFF
27751: PPUSH
27752: LD_INT 2
27754: PPUSH
27755: CALL 90882 0 2
27759: ST_TO_ADDR
// p := [ ] ;
27760: LD_ADDR_VAR 0 11
27764: PUSH
27765: EMPTY
27766: ST_TO_ADDR
// if sort then
27767: LD_VAR 0 9
27771: IFFALSE 27887
// for i = 1 to 4 - eng do
27773: LD_ADDR_VAR 0 3
27777: PUSH
27778: DOUBLE
27779: LD_INT 1
27781: DEC
27782: ST_TO_ADDR
27783: LD_INT 4
27785: PUSH
27786: LD_VAR 0 6
27790: MINUS
27791: PUSH
27792: FOR_TO
27793: IFFALSE 27885
// begin if i = sort then
27795: LD_VAR 0 3
27799: PUSH
27800: LD_VAR 0 9
27804: EQUAL
27805: IFFALSE 27809
// break ;
27807: GO 27885
// if GetClass ( i ) = 2 then
27809: LD_VAR 0 3
27813: PPUSH
27814: CALL_OW 257
27818: PUSH
27819: LD_INT 2
27821: EQUAL
27822: IFFALSE 27826
// continue ;
27824: GO 27792
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27826: LD_ADDR_VAR 0 11
27830: PUSH
27831: LD_VAR 0 11
27835: PPUSH
27836: LD_VAR 0 11
27840: PUSH
27841: LD_INT 1
27843: PLUS
27844: PPUSH
27845: LD_VAR 0 9
27849: PUSH
27850: LD_VAR 0 3
27854: ARRAY
27855: PPUSH
27856: CALL_OW 2
27860: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27861: LD_ADDR_VAR 0 4
27865: PUSH
27866: LD_VAR 0 4
27870: PUSH
27871: LD_VAR 0 9
27875: PUSH
27876: LD_VAR 0 3
27880: ARRAY
27881: DIFF
27882: ST_TO_ADDR
// end ;
27883: GO 27792
27885: POP
27886: POP
// if p then
27887: LD_VAR 0 11
27891: IFFALSE 27916
// result := Replace ( result , 2 , p ) ;
27893: LD_ADDR_VAR 0 2
27897: PUSH
27898: LD_VAR 0 2
27902: PPUSH
27903: LD_INT 2
27905: PPUSH
27906: LD_VAR 0 11
27910: PPUSH
27911: CALL_OW 1
27915: ST_TO_ADDR
// end else
27916: GO 27962
// for i = eng downto 5 do
27918: LD_ADDR_VAR 0 3
27922: PUSH
27923: DOUBLE
27924: LD_VAR 0 6
27928: INC
27929: ST_TO_ADDR
27930: LD_INT 5
27932: PUSH
27933: FOR_DOWNTO
27934: IFFALSE 27960
// tmp := tmp union eng [ i ] ;
27936: LD_ADDR_VAR 0 4
27940: PUSH
27941: LD_VAR 0 4
27945: PUSH
27946: LD_VAR 0 6
27950: PUSH
27951: LD_VAR 0 3
27955: ARRAY
27956: UNION
27957: ST_TO_ADDR
27958: GO 27933
27960: POP
27961: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
27962: LD_ADDR_VAR 0 2
27966: PUSH
27967: LD_VAR 0 2
27971: PPUSH
27972: LD_INT 1
27974: PPUSH
27975: LD_VAR 0 4
27979: PUSH
27980: LD_VAR 0 5
27984: DIFF
27985: PPUSH
27986: CALL_OW 1
27990: ST_TO_ADDR
// exit ;
27991: GO 27993
// end ; end ;
27993: LD_VAR 0 2
27997: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
27998: LD_INT 0
28000: PPUSH
28001: PPUSH
28002: PPUSH
// if not mc_bases then
28003: LD_EXP 74
28007: NOT
28008: IFFALSE 28012
// exit ;
28010: GO 28118
// for i = 1 to mc_bases do
28012: LD_ADDR_VAR 0 2
28016: PUSH
28017: DOUBLE
28018: LD_INT 1
28020: DEC
28021: ST_TO_ADDR
28022: LD_EXP 74
28026: PUSH
28027: FOR_TO
28028: IFFALSE 28109
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28030: LD_ADDR_VAR 0 3
28034: PUSH
28035: LD_EXP 74
28039: PUSH
28040: LD_VAR 0 2
28044: ARRAY
28045: PPUSH
28046: LD_INT 21
28048: PUSH
28049: LD_INT 3
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 3
28058: PUSH
28059: LD_INT 24
28061: PUSH
28062: LD_INT 1000
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: EMPTY
28070: LIST
28071: LIST
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PPUSH
28077: CALL_OW 72
28081: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28082: LD_ADDR_EXP 75
28086: PUSH
28087: LD_EXP 75
28091: PPUSH
28092: LD_VAR 0 2
28096: PPUSH
28097: LD_VAR 0 3
28101: PPUSH
28102: CALL_OW 1
28106: ST_TO_ADDR
// end ;
28107: GO 28027
28109: POP
28110: POP
// RaiseSailEvent ( 101 ) ;
28111: LD_INT 101
28113: PPUSH
28114: CALL_OW 427
// end ;
28118: LD_VAR 0 1
28122: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28123: LD_INT 0
28125: PPUSH
28126: PPUSH
28127: PPUSH
28128: PPUSH
28129: PPUSH
28130: PPUSH
28131: PPUSH
// if not mc_bases then
28132: LD_EXP 74
28136: NOT
28137: IFFALSE 28141
// exit ;
28139: GO 28714
// for i = 1 to mc_bases do
28141: LD_ADDR_VAR 0 2
28145: PUSH
28146: DOUBLE
28147: LD_INT 1
28149: DEC
28150: ST_TO_ADDR
28151: LD_EXP 74
28155: PUSH
28156: FOR_TO
28157: IFFALSE 28705
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28159: LD_ADDR_VAR 0 5
28163: PUSH
28164: LD_EXP 74
28168: PUSH
28169: LD_VAR 0 2
28173: ARRAY
28174: PUSH
28175: LD_EXP 103
28179: PUSH
28180: LD_VAR 0 2
28184: ARRAY
28185: UNION
28186: PPUSH
28187: LD_INT 21
28189: PUSH
28190: LD_INT 1
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: PUSH
28197: LD_INT 1
28199: PUSH
28200: LD_INT 3
28202: PUSH
28203: LD_INT 54
28205: PUSH
28206: EMPTY
28207: LIST
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PUSH
28213: LD_INT 3
28215: PUSH
28216: LD_INT 24
28218: PUSH
28219: LD_INT 800
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PUSH
28230: EMPTY
28231: LIST
28232: LIST
28233: LIST
28234: PUSH
28235: EMPTY
28236: LIST
28237: LIST
28238: PPUSH
28239: CALL_OW 72
28243: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28244: LD_ADDR_VAR 0 6
28248: PUSH
28249: LD_EXP 74
28253: PUSH
28254: LD_VAR 0 2
28258: ARRAY
28259: PPUSH
28260: LD_INT 21
28262: PUSH
28263: LD_INT 1
28265: PUSH
28266: EMPTY
28267: LIST
28268: LIST
28269: PUSH
28270: LD_INT 1
28272: PUSH
28273: LD_INT 3
28275: PUSH
28276: LD_INT 54
28278: PUSH
28279: EMPTY
28280: LIST
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: LD_INT 3
28288: PUSH
28289: LD_INT 24
28291: PUSH
28292: LD_INT 250
28294: PUSH
28295: EMPTY
28296: LIST
28297: LIST
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: EMPTY
28304: LIST
28305: LIST
28306: LIST
28307: PUSH
28308: EMPTY
28309: LIST
28310: LIST
28311: PPUSH
28312: CALL_OW 72
28316: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28317: LD_ADDR_VAR 0 7
28321: PUSH
28322: LD_VAR 0 5
28326: PUSH
28327: LD_VAR 0 6
28331: DIFF
28332: ST_TO_ADDR
// if not need_heal_1 then
28333: LD_VAR 0 6
28337: NOT
28338: IFFALSE 28371
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28340: LD_ADDR_EXP 77
28344: PUSH
28345: LD_EXP 77
28349: PPUSH
28350: LD_VAR 0 2
28354: PUSH
28355: LD_INT 1
28357: PUSH
28358: EMPTY
28359: LIST
28360: LIST
28361: PPUSH
28362: EMPTY
28363: PPUSH
28364: CALL 56634 0 3
28368: ST_TO_ADDR
28369: GO 28441
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28371: LD_ADDR_EXP 77
28375: PUSH
28376: LD_EXP 77
28380: PPUSH
28381: LD_VAR 0 2
28385: PUSH
28386: LD_INT 1
28388: PUSH
28389: EMPTY
28390: LIST
28391: LIST
28392: PPUSH
28393: LD_EXP 77
28397: PUSH
28398: LD_VAR 0 2
28402: ARRAY
28403: PUSH
28404: LD_INT 1
28406: ARRAY
28407: PPUSH
28408: LD_INT 3
28410: PUSH
28411: LD_INT 24
28413: PUSH
28414: LD_INT 1000
28416: PUSH
28417: EMPTY
28418: LIST
28419: LIST
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PPUSH
28425: CALL_OW 72
28429: PUSH
28430: LD_VAR 0 6
28434: UNION
28435: PPUSH
28436: CALL 56634 0 3
28440: ST_TO_ADDR
// if not need_heal_2 then
28441: LD_VAR 0 7
28445: NOT
28446: IFFALSE 28479
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
28448: LD_ADDR_EXP 77
28452: PUSH
28453: LD_EXP 77
28457: PPUSH
28458: LD_VAR 0 2
28462: PUSH
28463: LD_INT 2
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PPUSH
28470: EMPTY
28471: PPUSH
28472: CALL 56634 0 3
28476: ST_TO_ADDR
28477: GO 28511
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
28479: LD_ADDR_EXP 77
28483: PUSH
28484: LD_EXP 77
28488: PPUSH
28489: LD_VAR 0 2
28493: PUSH
28494: LD_INT 2
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: PPUSH
28501: LD_VAR 0 7
28505: PPUSH
28506: CALL 56634 0 3
28510: ST_TO_ADDR
// if need_heal_2 then
28511: LD_VAR 0 7
28515: IFFALSE 28687
// for j in need_heal_2 do
28517: LD_ADDR_VAR 0 3
28521: PUSH
28522: LD_VAR 0 7
28526: PUSH
28527: FOR_IN
28528: IFFALSE 28685
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
28530: LD_ADDR_VAR 0 5
28534: PUSH
28535: LD_EXP 74
28539: PUSH
28540: LD_VAR 0 2
28544: ARRAY
28545: PPUSH
28546: LD_INT 2
28548: PUSH
28549: LD_INT 30
28551: PUSH
28552: LD_INT 6
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 30
28561: PUSH
28562: LD_INT 7
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 30
28571: PUSH
28572: LD_INT 8
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 30
28581: PUSH
28582: LD_INT 0
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 30
28591: PUSH
28592: LD_INT 1
28594: PUSH
28595: EMPTY
28596: LIST
28597: LIST
28598: PUSH
28599: LD_INT 25
28601: PUSH
28602: LD_INT 4
28604: PUSH
28605: EMPTY
28606: LIST
28607: LIST
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: LIST
28613: LIST
28614: LIST
28615: LIST
28616: LIST
28617: PPUSH
28618: CALL_OW 72
28622: ST_TO_ADDR
// if tmp then
28623: LD_VAR 0 5
28627: IFFALSE 28683
// begin k := NearestUnitToUnit ( tmp , j ) ;
28629: LD_ADDR_VAR 0 4
28633: PUSH
28634: LD_VAR 0 5
28638: PPUSH
28639: LD_VAR 0 3
28643: PPUSH
28644: CALL_OW 74
28648: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
28649: LD_VAR 0 3
28653: PPUSH
28654: LD_VAR 0 4
28658: PPUSH
28659: CALL_OW 296
28663: PUSH
28664: LD_INT 7
28666: GREATER
28667: IFFALSE 28683
// ComMoveUnit ( j , k ) ;
28669: LD_VAR 0 3
28673: PPUSH
28674: LD_VAR 0 4
28678: PPUSH
28679: CALL_OW 112
// end ; end ;
28683: GO 28527
28685: POP
28686: POP
// if not need_heal_1 and not need_heal_2 then
28687: LD_VAR 0 6
28691: NOT
28692: PUSH
28693: LD_VAR 0 7
28697: NOT
28698: AND
28699: IFFALSE 28703
// continue ;
28701: GO 28156
// end ;
28703: GO 28156
28705: POP
28706: POP
// RaiseSailEvent ( 102 ) ;
28707: LD_INT 102
28709: PPUSH
28710: CALL_OW 427
// end ;
28714: LD_VAR 0 1
28718: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
28719: LD_INT 0
28721: PPUSH
28722: PPUSH
28723: PPUSH
28724: PPUSH
28725: PPUSH
28726: PPUSH
// if not mc_bases then
28727: LD_EXP 74
28731: NOT
28732: IFFALSE 28736
// exit ;
28734: GO 29446
// for i = 1 to mc_bases do
28736: LD_ADDR_VAR 0 2
28740: PUSH
28741: DOUBLE
28742: LD_INT 1
28744: DEC
28745: ST_TO_ADDR
28746: LD_EXP 74
28750: PUSH
28751: FOR_TO
28752: IFFALSE 29444
// begin if not mc_building_need_repair [ i ] then
28754: LD_EXP 75
28758: PUSH
28759: LD_VAR 0 2
28763: ARRAY
28764: NOT
28765: IFFALSE 28939
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
28767: LD_ADDR_VAR 0 6
28771: PUSH
28772: LD_EXP 93
28776: PUSH
28777: LD_VAR 0 2
28781: ARRAY
28782: PPUSH
28783: LD_INT 3
28785: PUSH
28786: LD_INT 24
28788: PUSH
28789: LD_INT 1000
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: EMPTY
28797: LIST
28798: LIST
28799: PUSH
28800: LD_INT 2
28802: PUSH
28803: LD_INT 34
28805: PUSH
28806: LD_INT 13
28808: PUSH
28809: EMPTY
28810: LIST
28811: LIST
28812: PUSH
28813: LD_INT 34
28815: PUSH
28816: LD_INT 52
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: LIST
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: PPUSH
28832: CALL_OW 72
28836: ST_TO_ADDR
// if cranes then
28837: LD_VAR 0 6
28841: IFFALSE 28903
// for j in cranes do
28843: LD_ADDR_VAR 0 3
28847: PUSH
28848: LD_VAR 0 6
28852: PUSH
28853: FOR_IN
28854: IFFALSE 28901
// if not IsInArea ( j , mc_parking [ i ] ) then
28856: LD_VAR 0 3
28860: PPUSH
28861: LD_EXP 98
28865: PUSH
28866: LD_VAR 0 2
28870: ARRAY
28871: PPUSH
28872: CALL_OW 308
28876: NOT
28877: IFFALSE 28899
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28879: LD_VAR 0 3
28883: PPUSH
28884: LD_EXP 98
28888: PUSH
28889: LD_VAR 0 2
28893: ARRAY
28894: PPUSH
28895: CALL_OW 113
28899: GO 28853
28901: POP
28902: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
28903: LD_ADDR_EXP 76
28907: PUSH
28908: LD_EXP 76
28912: PPUSH
28913: LD_VAR 0 2
28917: PPUSH
28918: EMPTY
28919: PPUSH
28920: CALL_OW 1
28924: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
28925: LD_VAR 0 2
28929: PPUSH
28930: LD_INT 101
28932: PPUSH
28933: CALL 23831 0 2
// continue ;
28937: GO 28751
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
28939: LD_ADDR_EXP 80
28943: PUSH
28944: LD_EXP 80
28948: PPUSH
28949: LD_VAR 0 2
28953: PPUSH
28954: EMPTY
28955: PPUSH
28956: CALL_OW 1
28960: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28961: LD_VAR 0 2
28965: PPUSH
28966: LD_INT 103
28968: PPUSH
28969: CALL 23831 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
28973: LD_ADDR_VAR 0 5
28977: PUSH
28978: LD_EXP 74
28982: PUSH
28983: LD_VAR 0 2
28987: ARRAY
28988: PUSH
28989: LD_EXP 103
28993: PUSH
28994: LD_VAR 0 2
28998: ARRAY
28999: UNION
29000: PPUSH
29001: LD_INT 2
29003: PUSH
29004: LD_INT 25
29006: PUSH
29007: LD_INT 2
29009: PUSH
29010: EMPTY
29011: LIST
29012: LIST
29013: PUSH
29014: LD_INT 25
29016: PUSH
29017: LD_INT 16
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: LIST
29028: PUSH
29029: EMPTY
29030: LIST
29031: PPUSH
29032: CALL_OW 72
29036: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29037: LD_ADDR_VAR 0 6
29041: PUSH
29042: LD_EXP 93
29046: PUSH
29047: LD_VAR 0 2
29051: ARRAY
29052: PPUSH
29053: LD_INT 2
29055: PUSH
29056: LD_INT 34
29058: PUSH
29059: LD_INT 13
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 34
29068: PUSH
29069: LD_INT 52
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: EMPTY
29077: LIST
29078: LIST
29079: LIST
29080: PPUSH
29081: CALL_OW 72
29085: ST_TO_ADDR
// if cranes then
29086: LD_VAR 0 6
29090: IFFALSE 29226
// begin for j in cranes do
29092: LD_ADDR_VAR 0 3
29096: PUSH
29097: LD_VAR 0 6
29101: PUSH
29102: FOR_IN
29103: IFFALSE 29224
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29105: LD_VAR 0 3
29109: PPUSH
29110: CALL_OW 256
29114: PUSH
29115: LD_INT 500
29117: GREATEREQUAL
29118: PUSH
29119: LD_VAR 0 3
29123: PPUSH
29124: CALL_OW 314
29128: NOT
29129: AND
29130: IFFALSE 29164
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29132: LD_VAR 0 3
29136: PPUSH
29137: LD_EXP 75
29141: PUSH
29142: LD_VAR 0 2
29146: ARRAY
29147: PPUSH
29148: LD_VAR 0 3
29152: PPUSH
29153: CALL_OW 74
29157: PPUSH
29158: CALL_OW 130
29162: GO 29222
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29164: LD_VAR 0 3
29168: PPUSH
29169: CALL_OW 256
29173: PUSH
29174: LD_INT 500
29176: LESS
29177: PUSH
29178: LD_VAR 0 3
29182: PPUSH
29183: LD_EXP 98
29187: PUSH
29188: LD_VAR 0 2
29192: ARRAY
29193: PPUSH
29194: CALL_OW 308
29198: NOT
29199: AND
29200: IFFALSE 29222
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29202: LD_VAR 0 3
29206: PPUSH
29207: LD_EXP 98
29211: PUSH
29212: LD_VAR 0 2
29216: ARRAY
29217: PPUSH
29218: CALL_OW 113
29222: GO 29102
29224: POP
29225: POP
// end ; if not tmp then
29226: LD_VAR 0 5
29230: NOT
29231: IFFALSE 29235
// continue ;
29233: GO 28751
// for j in tmp do
29235: LD_ADDR_VAR 0 3
29239: PUSH
29240: LD_VAR 0 5
29244: PUSH
29245: FOR_IN
29246: IFFALSE 29440
// begin if mc_need_heal [ i ] then
29248: LD_EXP 77
29252: PUSH
29253: LD_VAR 0 2
29257: ARRAY
29258: IFFALSE 29306
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29260: LD_VAR 0 3
29264: PUSH
29265: LD_EXP 77
29269: PUSH
29270: LD_VAR 0 2
29274: ARRAY
29275: PUSH
29276: LD_INT 1
29278: ARRAY
29279: IN
29280: PUSH
29281: LD_VAR 0 3
29285: PUSH
29286: LD_EXP 77
29290: PUSH
29291: LD_VAR 0 2
29295: ARRAY
29296: PUSH
29297: LD_INT 2
29299: ARRAY
29300: IN
29301: OR
29302: IFFALSE 29306
// continue ;
29304: GO 29245
// if IsInUnit ( j ) then
29306: LD_VAR 0 3
29310: PPUSH
29311: CALL_OW 310
29315: IFFALSE 29326
// ComExitBuilding ( j ) ;
29317: LD_VAR 0 3
29321: PPUSH
29322: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29326: LD_VAR 0 3
29330: PUSH
29331: LD_EXP 76
29335: PUSH
29336: LD_VAR 0 2
29340: ARRAY
29341: IN
29342: NOT
29343: IFFALSE 29401
// begin SetTag ( j , 101 ) ;
29345: LD_VAR 0 3
29349: PPUSH
29350: LD_INT 101
29352: PPUSH
29353: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29357: LD_ADDR_EXP 76
29361: PUSH
29362: LD_EXP 76
29366: PPUSH
29367: LD_VAR 0 2
29371: PUSH
29372: LD_EXP 76
29376: PUSH
29377: LD_VAR 0 2
29381: ARRAY
29382: PUSH
29383: LD_INT 1
29385: PLUS
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PPUSH
29391: LD_VAR 0 3
29395: PPUSH
29396: CALL 56634 0 3
29400: ST_TO_ADDR
// end ; wait ( 1 ) ;
29401: LD_INT 1
29403: PPUSH
29404: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
29408: LD_VAR 0 3
29412: PPUSH
29413: LD_EXP 75
29417: PUSH
29418: LD_VAR 0 2
29422: ARRAY
29423: PPUSH
29424: LD_VAR 0 3
29428: PPUSH
29429: CALL_OW 74
29433: PPUSH
29434: CALL_OW 130
// end ;
29438: GO 29245
29440: POP
29441: POP
// end ;
29442: GO 28751
29444: POP
29445: POP
// end ;
29446: LD_VAR 0 1
29450: RET
// export function MC_Heal ; var i , j , tmp ; begin
29451: LD_INT 0
29453: PPUSH
29454: PPUSH
29455: PPUSH
29456: PPUSH
// if not mc_bases then
29457: LD_EXP 74
29461: NOT
29462: IFFALSE 29466
// exit ;
29464: GO 29868
// for i = 1 to mc_bases do
29466: LD_ADDR_VAR 0 2
29470: PUSH
29471: DOUBLE
29472: LD_INT 1
29474: DEC
29475: ST_TO_ADDR
29476: LD_EXP 74
29480: PUSH
29481: FOR_TO
29482: IFFALSE 29866
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
29484: LD_EXP 77
29488: PUSH
29489: LD_VAR 0 2
29493: ARRAY
29494: PUSH
29495: LD_INT 1
29497: ARRAY
29498: NOT
29499: PUSH
29500: LD_EXP 77
29504: PUSH
29505: LD_VAR 0 2
29509: ARRAY
29510: PUSH
29511: LD_INT 2
29513: ARRAY
29514: NOT
29515: AND
29516: IFFALSE 29554
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
29518: LD_ADDR_EXP 78
29522: PUSH
29523: LD_EXP 78
29527: PPUSH
29528: LD_VAR 0 2
29532: PPUSH
29533: EMPTY
29534: PPUSH
29535: CALL_OW 1
29539: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
29540: LD_VAR 0 2
29544: PPUSH
29545: LD_INT 102
29547: PPUSH
29548: CALL 23831 0 2
// continue ;
29552: GO 29481
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
29554: LD_ADDR_VAR 0 4
29558: PUSH
29559: LD_EXP 74
29563: PUSH
29564: LD_VAR 0 2
29568: ARRAY
29569: PPUSH
29570: LD_INT 25
29572: PUSH
29573: LD_INT 4
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PPUSH
29580: CALL_OW 72
29584: ST_TO_ADDR
// if not tmp then
29585: LD_VAR 0 4
29589: NOT
29590: IFFALSE 29594
// continue ;
29592: GO 29481
// if mc_taming [ i ] then
29594: LD_EXP 105
29598: PUSH
29599: LD_VAR 0 2
29603: ARRAY
29604: IFFALSE 29628
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
29606: LD_ADDR_EXP 105
29610: PUSH
29611: LD_EXP 105
29615: PPUSH
29616: LD_VAR 0 2
29620: PPUSH
29621: EMPTY
29622: PPUSH
29623: CALL_OW 1
29627: ST_TO_ADDR
// for j in tmp do
29628: LD_ADDR_VAR 0 3
29632: PUSH
29633: LD_VAR 0 4
29637: PUSH
29638: FOR_IN
29639: IFFALSE 29862
// begin if IsInUnit ( j ) then
29641: LD_VAR 0 3
29645: PPUSH
29646: CALL_OW 310
29650: IFFALSE 29661
// ComExitBuilding ( j ) ;
29652: LD_VAR 0 3
29656: PPUSH
29657: CALL_OW 122
// if not j in mc_healers [ i ] then
29661: LD_VAR 0 3
29665: PUSH
29666: LD_EXP 78
29670: PUSH
29671: LD_VAR 0 2
29675: ARRAY
29676: IN
29677: NOT
29678: IFFALSE 29724
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
29680: LD_ADDR_EXP 78
29684: PUSH
29685: LD_EXP 78
29689: PPUSH
29690: LD_VAR 0 2
29694: PUSH
29695: LD_EXP 78
29699: PUSH
29700: LD_VAR 0 2
29704: ARRAY
29705: PUSH
29706: LD_INT 1
29708: PLUS
29709: PUSH
29710: EMPTY
29711: LIST
29712: LIST
29713: PPUSH
29714: LD_VAR 0 3
29718: PPUSH
29719: CALL 56634 0 3
29723: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
29724: LD_VAR 0 3
29728: PPUSH
29729: CALL_OW 110
29733: PUSH
29734: LD_INT 102
29736: NONEQUAL
29737: IFFALSE 29751
// SetTag ( j , 102 ) ;
29739: LD_VAR 0 3
29743: PPUSH
29744: LD_INT 102
29746: PPUSH
29747: CALL_OW 109
// Wait ( 3 ) ;
29751: LD_INT 3
29753: PPUSH
29754: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
29758: LD_EXP 77
29762: PUSH
29763: LD_VAR 0 2
29767: ARRAY
29768: PUSH
29769: LD_INT 1
29771: ARRAY
29772: IFFALSE 29804
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
29774: LD_VAR 0 3
29778: PPUSH
29779: LD_EXP 77
29783: PUSH
29784: LD_VAR 0 2
29788: ARRAY
29789: PUSH
29790: LD_INT 1
29792: ARRAY
29793: PUSH
29794: LD_INT 1
29796: ARRAY
29797: PPUSH
29798: CALL_OW 128
29802: GO 29860
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
29804: LD_VAR 0 3
29808: PPUSH
29809: CALL_OW 314
29813: NOT
29814: PUSH
29815: LD_EXP 77
29819: PUSH
29820: LD_VAR 0 2
29824: ARRAY
29825: PUSH
29826: LD_INT 2
29828: ARRAY
29829: AND
29830: IFFALSE 29860
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
29832: LD_VAR 0 3
29836: PPUSH
29837: LD_EXP 77
29841: PUSH
29842: LD_VAR 0 2
29846: ARRAY
29847: PUSH
29848: LD_INT 2
29850: ARRAY
29851: PUSH
29852: LD_INT 1
29854: ARRAY
29855: PPUSH
29856: CALL_OW 128
// end ;
29860: GO 29638
29862: POP
29863: POP
// end ;
29864: GO 29481
29866: POP
29867: POP
// end ;
29868: LD_VAR 0 1
29872: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
29873: LD_INT 0
29875: PPUSH
29876: PPUSH
29877: PPUSH
29878: PPUSH
29879: PPUSH
// if not mc_bases then
29880: LD_EXP 74
29884: NOT
29885: IFFALSE 29889
// exit ;
29887: GO 31032
// for i = 1 to mc_bases do
29889: LD_ADDR_VAR 0 2
29893: PUSH
29894: DOUBLE
29895: LD_INT 1
29897: DEC
29898: ST_TO_ADDR
29899: LD_EXP 74
29903: PUSH
29904: FOR_TO
29905: IFFALSE 31030
// begin if mc_scan [ i ] then
29907: LD_EXP 97
29911: PUSH
29912: LD_VAR 0 2
29916: ARRAY
29917: IFFALSE 29921
// continue ;
29919: GO 29904
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
29921: LD_EXP 79
29925: PUSH
29926: LD_VAR 0 2
29930: ARRAY
29931: NOT
29932: PUSH
29933: LD_EXP 81
29937: PUSH
29938: LD_VAR 0 2
29942: ARRAY
29943: NOT
29944: AND
29945: PUSH
29946: LD_EXP 80
29950: PUSH
29951: LD_VAR 0 2
29955: ARRAY
29956: AND
29957: IFFALSE 29995
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
29959: LD_ADDR_EXP 80
29963: PUSH
29964: LD_EXP 80
29968: PPUSH
29969: LD_VAR 0 2
29973: PPUSH
29974: EMPTY
29975: PPUSH
29976: CALL_OW 1
29980: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29981: LD_VAR 0 2
29985: PPUSH
29986: LD_INT 103
29988: PPUSH
29989: CALL 23831 0 2
// continue ;
29993: GO 29904
// end ; if mc_construct_list [ i ] then
29995: LD_EXP 81
29999: PUSH
30000: LD_VAR 0 2
30004: ARRAY
30005: IFFALSE 30225
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30007: LD_ADDR_VAR 0 4
30011: PUSH
30012: LD_EXP 74
30016: PUSH
30017: LD_VAR 0 2
30021: ARRAY
30022: PPUSH
30023: LD_INT 25
30025: PUSH
30026: LD_INT 2
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PPUSH
30033: CALL_OW 72
30037: PUSH
30038: LD_EXP 76
30042: PUSH
30043: LD_VAR 0 2
30047: ARRAY
30048: DIFF
30049: ST_TO_ADDR
// if not tmp then
30050: LD_VAR 0 4
30054: NOT
30055: IFFALSE 30059
// continue ;
30057: GO 29904
// for j in tmp do
30059: LD_ADDR_VAR 0 3
30063: PUSH
30064: LD_VAR 0 4
30068: PUSH
30069: FOR_IN
30070: IFFALSE 30221
// begin if not mc_builders [ i ] then
30072: LD_EXP 80
30076: PUSH
30077: LD_VAR 0 2
30081: ARRAY
30082: NOT
30083: IFFALSE 30141
// begin SetTag ( j , 103 ) ;
30085: LD_VAR 0 3
30089: PPUSH
30090: LD_INT 103
30092: PPUSH
30093: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30097: LD_ADDR_EXP 80
30101: PUSH
30102: LD_EXP 80
30106: PPUSH
30107: LD_VAR 0 2
30111: PUSH
30112: LD_EXP 80
30116: PUSH
30117: LD_VAR 0 2
30121: ARRAY
30122: PUSH
30123: LD_INT 1
30125: PLUS
30126: PUSH
30127: EMPTY
30128: LIST
30129: LIST
30130: PPUSH
30131: LD_VAR 0 3
30135: PPUSH
30136: CALL 56634 0 3
30140: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30141: LD_VAR 0 3
30145: PPUSH
30146: CALL_OW 310
30150: IFFALSE 30161
// ComExitBuilding ( j ) ;
30152: LD_VAR 0 3
30156: PPUSH
30157: CALL_OW 122
// wait ( 3 ) ;
30161: LD_INT 3
30163: PPUSH
30164: CALL_OW 67
// if not mc_construct_list [ i ] then
30168: LD_EXP 81
30172: PUSH
30173: LD_VAR 0 2
30177: ARRAY
30178: NOT
30179: IFFALSE 30183
// break ;
30181: GO 30221
// if not HasTask ( j ) then
30183: LD_VAR 0 3
30187: PPUSH
30188: CALL_OW 314
30192: NOT
30193: IFFALSE 30219
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30195: LD_VAR 0 3
30199: PPUSH
30200: LD_EXP 81
30204: PUSH
30205: LD_VAR 0 2
30209: ARRAY
30210: PUSH
30211: LD_INT 1
30213: ARRAY
30214: PPUSH
30215: CALL 59485 0 2
// end ;
30219: GO 30069
30221: POP
30222: POP
// end else
30223: GO 31028
// if mc_build_list [ i ] then
30225: LD_EXP 79
30229: PUSH
30230: LD_VAR 0 2
30234: ARRAY
30235: IFFALSE 31028
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30237: LD_ADDR_VAR 0 5
30241: PUSH
30242: LD_EXP 74
30246: PUSH
30247: LD_VAR 0 2
30251: ARRAY
30252: PPUSH
30253: LD_INT 2
30255: PUSH
30256: LD_INT 30
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 30
30268: PUSH
30269: LD_INT 1
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: LIST
30280: PPUSH
30281: CALL_OW 72
30285: ST_TO_ADDR
// if depot then
30286: LD_VAR 0 5
30290: IFFALSE 30308
// depot := depot [ 1 ] else
30292: LD_ADDR_VAR 0 5
30296: PUSH
30297: LD_VAR 0 5
30301: PUSH
30302: LD_INT 1
30304: ARRAY
30305: ST_TO_ADDR
30306: GO 30316
// depot := 0 ;
30308: LD_ADDR_VAR 0 5
30312: PUSH
30313: LD_INT 0
30315: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
30316: LD_EXP 79
30320: PUSH
30321: LD_VAR 0 2
30325: ARRAY
30326: PUSH
30327: LD_INT 1
30329: ARRAY
30330: PUSH
30331: LD_INT 1
30333: ARRAY
30334: PPUSH
30335: CALL 59315 0 1
30339: PUSH
30340: LD_EXP 74
30344: PUSH
30345: LD_VAR 0 2
30349: ARRAY
30350: PPUSH
30351: LD_INT 2
30353: PUSH
30354: LD_INT 30
30356: PUSH
30357: LD_INT 2
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 30
30366: PUSH
30367: LD_INT 3
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: LIST
30378: PPUSH
30379: CALL_OW 72
30383: NOT
30384: AND
30385: IFFALSE 30490
// begin for j = 1 to mc_build_list [ i ] do
30387: LD_ADDR_VAR 0 3
30391: PUSH
30392: DOUBLE
30393: LD_INT 1
30395: DEC
30396: ST_TO_ADDR
30397: LD_EXP 79
30401: PUSH
30402: LD_VAR 0 2
30406: ARRAY
30407: PUSH
30408: FOR_TO
30409: IFFALSE 30488
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
30411: LD_EXP 79
30415: PUSH
30416: LD_VAR 0 2
30420: ARRAY
30421: PUSH
30422: LD_VAR 0 3
30426: ARRAY
30427: PUSH
30428: LD_INT 1
30430: ARRAY
30431: PUSH
30432: LD_INT 2
30434: EQUAL
30435: IFFALSE 30486
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
30437: LD_ADDR_EXP 79
30441: PUSH
30442: LD_EXP 79
30446: PPUSH
30447: LD_VAR 0 2
30451: PPUSH
30452: LD_EXP 79
30456: PUSH
30457: LD_VAR 0 2
30461: ARRAY
30462: PPUSH
30463: LD_VAR 0 3
30467: PPUSH
30468: LD_INT 1
30470: PPUSH
30471: LD_INT 0
30473: PPUSH
30474: CALL 56052 0 4
30478: PPUSH
30479: CALL_OW 1
30483: ST_TO_ADDR
// break ;
30484: GO 30488
// end ;
30486: GO 30408
30488: POP
30489: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
30490: LD_EXP 79
30494: PUSH
30495: LD_VAR 0 2
30499: ARRAY
30500: PUSH
30501: LD_INT 1
30503: ARRAY
30504: PUSH
30505: LD_INT 1
30507: ARRAY
30508: PUSH
30509: LD_INT 0
30511: EQUAL
30512: PUSH
30513: LD_VAR 0 5
30517: PUSH
30518: LD_VAR 0 5
30522: PPUSH
30523: LD_EXP 79
30527: PUSH
30528: LD_VAR 0 2
30532: ARRAY
30533: PUSH
30534: LD_INT 1
30536: ARRAY
30537: PUSH
30538: LD_INT 1
30540: ARRAY
30541: PPUSH
30542: LD_EXP 79
30546: PUSH
30547: LD_VAR 0 2
30551: ARRAY
30552: PUSH
30553: LD_INT 1
30555: ARRAY
30556: PUSH
30557: LD_INT 2
30559: ARRAY
30560: PPUSH
30561: LD_EXP 79
30565: PUSH
30566: LD_VAR 0 2
30570: ARRAY
30571: PUSH
30572: LD_INT 1
30574: ARRAY
30575: PUSH
30576: LD_INT 3
30578: ARRAY
30579: PPUSH
30580: LD_EXP 79
30584: PUSH
30585: LD_VAR 0 2
30589: ARRAY
30590: PUSH
30591: LD_INT 1
30593: ARRAY
30594: PUSH
30595: LD_INT 4
30597: ARRAY
30598: PPUSH
30599: CALL 64049 0 5
30603: AND
30604: OR
30605: IFFALSE 30886
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30607: LD_ADDR_VAR 0 4
30611: PUSH
30612: LD_EXP 74
30616: PUSH
30617: LD_VAR 0 2
30621: ARRAY
30622: PPUSH
30623: LD_INT 25
30625: PUSH
30626: LD_INT 2
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PPUSH
30633: CALL_OW 72
30637: PUSH
30638: LD_EXP 76
30642: PUSH
30643: LD_VAR 0 2
30647: ARRAY
30648: DIFF
30649: ST_TO_ADDR
// if not tmp then
30650: LD_VAR 0 4
30654: NOT
30655: IFFALSE 30659
// continue ;
30657: GO 29904
// for j in tmp do
30659: LD_ADDR_VAR 0 3
30663: PUSH
30664: LD_VAR 0 4
30668: PUSH
30669: FOR_IN
30670: IFFALSE 30882
// begin if not mc_builders [ i ] then
30672: LD_EXP 80
30676: PUSH
30677: LD_VAR 0 2
30681: ARRAY
30682: NOT
30683: IFFALSE 30741
// begin SetTag ( j , 103 ) ;
30685: LD_VAR 0 3
30689: PPUSH
30690: LD_INT 103
30692: PPUSH
30693: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30697: LD_ADDR_EXP 80
30701: PUSH
30702: LD_EXP 80
30706: PPUSH
30707: LD_VAR 0 2
30711: PUSH
30712: LD_EXP 80
30716: PUSH
30717: LD_VAR 0 2
30721: ARRAY
30722: PUSH
30723: LD_INT 1
30725: PLUS
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PPUSH
30731: LD_VAR 0 3
30735: PPUSH
30736: CALL 56634 0 3
30740: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30741: LD_VAR 0 3
30745: PPUSH
30746: CALL_OW 310
30750: IFFALSE 30761
// ComExitBuilding ( j ) ;
30752: LD_VAR 0 3
30756: PPUSH
30757: CALL_OW 122
// wait ( 3 ) ;
30761: LD_INT 3
30763: PPUSH
30764: CALL_OW 67
// if not mc_build_list [ i ] then
30768: LD_EXP 79
30772: PUSH
30773: LD_VAR 0 2
30777: ARRAY
30778: NOT
30779: IFFALSE 30783
// break ;
30781: GO 30882
// if not HasTask ( j ) then
30783: LD_VAR 0 3
30787: PPUSH
30788: CALL_OW 314
30792: NOT
30793: IFFALSE 30880
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
30795: LD_VAR 0 3
30799: PPUSH
30800: LD_EXP 79
30804: PUSH
30805: LD_VAR 0 2
30809: ARRAY
30810: PUSH
30811: LD_INT 1
30813: ARRAY
30814: PUSH
30815: LD_INT 1
30817: ARRAY
30818: PPUSH
30819: LD_EXP 79
30823: PUSH
30824: LD_VAR 0 2
30828: ARRAY
30829: PUSH
30830: LD_INT 1
30832: ARRAY
30833: PUSH
30834: LD_INT 2
30836: ARRAY
30837: PPUSH
30838: LD_EXP 79
30842: PUSH
30843: LD_VAR 0 2
30847: ARRAY
30848: PUSH
30849: LD_INT 1
30851: ARRAY
30852: PUSH
30853: LD_INT 3
30855: ARRAY
30856: PPUSH
30857: LD_EXP 79
30861: PUSH
30862: LD_VAR 0 2
30866: ARRAY
30867: PUSH
30868: LD_INT 1
30870: ARRAY
30871: PUSH
30872: LD_INT 4
30874: ARRAY
30875: PPUSH
30876: CALL_OW 145
// end ;
30880: GO 30669
30882: POP
30883: POP
// end else
30884: GO 31028
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
30886: LD_EXP 74
30890: PUSH
30891: LD_VAR 0 2
30895: ARRAY
30896: PPUSH
30897: LD_EXP 79
30901: PUSH
30902: LD_VAR 0 2
30906: ARRAY
30907: PUSH
30908: LD_INT 1
30910: ARRAY
30911: PUSH
30912: LD_INT 1
30914: ARRAY
30915: PPUSH
30916: LD_EXP 79
30920: PUSH
30921: LD_VAR 0 2
30925: ARRAY
30926: PUSH
30927: LD_INT 1
30929: ARRAY
30930: PUSH
30931: LD_INT 2
30933: ARRAY
30934: PPUSH
30935: LD_EXP 79
30939: PUSH
30940: LD_VAR 0 2
30944: ARRAY
30945: PUSH
30946: LD_INT 1
30948: ARRAY
30949: PUSH
30950: LD_INT 3
30952: ARRAY
30953: PPUSH
30954: LD_EXP 79
30958: PUSH
30959: LD_VAR 0 2
30963: ARRAY
30964: PUSH
30965: LD_INT 1
30967: ARRAY
30968: PUSH
30969: LD_INT 4
30971: ARRAY
30972: PPUSH
30973: CALL 63385 0 5
30977: NOT
30978: IFFALSE 31028
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
30980: LD_ADDR_EXP 79
30984: PUSH
30985: LD_EXP 79
30989: PPUSH
30990: LD_VAR 0 2
30994: PPUSH
30995: LD_EXP 79
30999: PUSH
31000: LD_VAR 0 2
31004: ARRAY
31005: PPUSH
31006: LD_INT 1
31008: PPUSH
31009: LD_INT 1
31011: NEG
31012: PPUSH
31013: LD_INT 0
31015: PPUSH
31016: CALL 56052 0 4
31020: PPUSH
31021: CALL_OW 1
31025: ST_TO_ADDR
// continue ;
31026: GO 29904
// end ; end ; end ;
31028: GO 29904
31030: POP
31031: POP
// end ;
31032: LD_VAR 0 1
31036: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31037: LD_INT 0
31039: PPUSH
31040: PPUSH
31041: PPUSH
31042: PPUSH
31043: PPUSH
31044: PPUSH
// if not mc_bases then
31045: LD_EXP 74
31049: NOT
31050: IFFALSE 31054
// exit ;
31052: GO 31481
// for i = 1 to mc_bases do
31054: LD_ADDR_VAR 0 2
31058: PUSH
31059: DOUBLE
31060: LD_INT 1
31062: DEC
31063: ST_TO_ADDR
31064: LD_EXP 74
31068: PUSH
31069: FOR_TO
31070: IFFALSE 31479
// begin tmp := mc_build_upgrade [ i ] ;
31072: LD_ADDR_VAR 0 4
31076: PUSH
31077: LD_EXP 106
31081: PUSH
31082: LD_VAR 0 2
31086: ARRAY
31087: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31088: LD_ADDR_VAR 0 6
31092: PUSH
31093: LD_EXP 107
31097: PUSH
31098: LD_VAR 0 2
31102: ARRAY
31103: PPUSH
31104: LD_INT 2
31106: PUSH
31107: LD_INT 30
31109: PUSH
31110: LD_INT 6
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 30
31119: PUSH
31120: LD_INT 7
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: LIST
31131: PPUSH
31132: CALL_OW 72
31136: ST_TO_ADDR
// if not tmp and not lab then
31137: LD_VAR 0 4
31141: NOT
31142: PUSH
31143: LD_VAR 0 6
31147: NOT
31148: AND
31149: IFFALSE 31153
// continue ;
31151: GO 31069
// if tmp then
31153: LD_VAR 0 4
31157: IFFALSE 31277
// for j in tmp do
31159: LD_ADDR_VAR 0 3
31163: PUSH
31164: LD_VAR 0 4
31168: PUSH
31169: FOR_IN
31170: IFFALSE 31275
// begin if UpgradeCost ( j ) then
31172: LD_VAR 0 3
31176: PPUSH
31177: CALL 63045 0 1
31181: IFFALSE 31273
// begin ComUpgrade ( j ) ;
31183: LD_VAR 0 3
31187: PPUSH
31188: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31192: LD_ADDR_EXP 106
31196: PUSH
31197: LD_EXP 106
31201: PPUSH
31202: LD_VAR 0 2
31206: PPUSH
31207: LD_EXP 106
31211: PUSH
31212: LD_VAR 0 2
31216: ARRAY
31217: PUSH
31218: LD_VAR 0 3
31222: DIFF
31223: PPUSH
31224: CALL_OW 1
31228: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31229: LD_ADDR_EXP 81
31233: PUSH
31234: LD_EXP 81
31238: PPUSH
31239: LD_VAR 0 2
31243: PUSH
31244: LD_EXP 81
31248: PUSH
31249: LD_VAR 0 2
31253: ARRAY
31254: PUSH
31255: LD_INT 1
31257: PLUS
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PPUSH
31263: LD_VAR 0 3
31267: PPUSH
31268: CALL 56634 0 3
31272: ST_TO_ADDR
// end ; end ;
31273: GO 31169
31275: POP
31276: POP
// if not lab or not mc_lab_upgrade [ i ] then
31277: LD_VAR 0 6
31281: NOT
31282: PUSH
31283: LD_EXP 108
31287: PUSH
31288: LD_VAR 0 2
31292: ARRAY
31293: NOT
31294: OR
31295: IFFALSE 31299
// continue ;
31297: GO 31069
// for j in lab do
31299: LD_ADDR_VAR 0 3
31303: PUSH
31304: LD_VAR 0 6
31308: PUSH
31309: FOR_IN
31310: IFFALSE 31475
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
31312: LD_VAR 0 3
31316: PPUSH
31317: CALL_OW 266
31321: PUSH
31322: LD_INT 6
31324: PUSH
31325: LD_INT 7
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: IN
31332: PUSH
31333: LD_VAR 0 3
31337: PPUSH
31338: CALL_OW 461
31342: PUSH
31343: LD_INT 1
31345: NONEQUAL
31346: AND
31347: IFFALSE 31473
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
31349: LD_VAR 0 3
31353: PPUSH
31354: LD_EXP 108
31358: PUSH
31359: LD_VAR 0 2
31363: ARRAY
31364: PUSH
31365: LD_INT 1
31367: ARRAY
31368: PPUSH
31369: CALL 63250 0 2
31373: IFFALSE 31473
// begin ComCancel ( j ) ;
31375: LD_VAR 0 3
31379: PPUSH
31380: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
31384: LD_VAR 0 3
31388: PPUSH
31389: LD_EXP 108
31393: PUSH
31394: LD_VAR 0 2
31398: ARRAY
31399: PUSH
31400: LD_INT 1
31402: ARRAY
31403: PPUSH
31404: CALL_OW 207
// if not j in mc_construct_list [ i ] then
31408: LD_VAR 0 3
31412: PUSH
31413: LD_EXP 81
31417: PUSH
31418: LD_VAR 0 2
31422: ARRAY
31423: IN
31424: NOT
31425: IFFALSE 31471
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31427: LD_ADDR_EXP 81
31431: PUSH
31432: LD_EXP 81
31436: PPUSH
31437: LD_VAR 0 2
31441: PUSH
31442: LD_EXP 81
31446: PUSH
31447: LD_VAR 0 2
31451: ARRAY
31452: PUSH
31453: LD_INT 1
31455: PLUS
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PPUSH
31461: LD_VAR 0 3
31465: PPUSH
31466: CALL 56634 0 3
31470: ST_TO_ADDR
// break ;
31471: GO 31475
// end ; end ; end ;
31473: GO 31309
31475: POP
31476: POP
// end ;
31477: GO 31069
31479: POP
31480: POP
// end ;
31481: LD_VAR 0 1
31485: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
31486: LD_INT 0
31488: PPUSH
31489: PPUSH
31490: PPUSH
31491: PPUSH
31492: PPUSH
31493: PPUSH
31494: PPUSH
31495: PPUSH
31496: PPUSH
// if not mc_bases then
31497: LD_EXP 74
31501: NOT
31502: IFFALSE 31506
// exit ;
31504: GO 31911
// for i = 1 to mc_bases do
31506: LD_ADDR_VAR 0 2
31510: PUSH
31511: DOUBLE
31512: LD_INT 1
31514: DEC
31515: ST_TO_ADDR
31516: LD_EXP 74
31520: PUSH
31521: FOR_TO
31522: IFFALSE 31909
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
31524: LD_EXP 82
31528: PUSH
31529: LD_VAR 0 2
31533: ARRAY
31534: NOT
31535: PUSH
31536: LD_EXP 74
31540: PUSH
31541: LD_VAR 0 2
31545: ARRAY
31546: PPUSH
31547: LD_INT 30
31549: PUSH
31550: LD_INT 3
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: PPUSH
31557: CALL_OW 72
31561: NOT
31562: OR
31563: IFFALSE 31567
// continue ;
31565: GO 31521
// busy := false ;
31567: LD_ADDR_VAR 0 8
31571: PUSH
31572: LD_INT 0
31574: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
31575: LD_ADDR_VAR 0 4
31579: PUSH
31580: LD_EXP 74
31584: PUSH
31585: LD_VAR 0 2
31589: ARRAY
31590: PPUSH
31591: LD_INT 30
31593: PUSH
31594: LD_INT 3
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PPUSH
31601: CALL_OW 72
31605: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
31606: LD_ADDR_VAR 0 6
31610: PUSH
31611: LD_EXP 82
31615: PUSH
31616: LD_VAR 0 2
31620: ARRAY
31621: PPUSH
31622: LD_INT 2
31624: PUSH
31625: LD_INT 30
31627: PUSH
31628: LD_INT 32
31630: PUSH
31631: EMPTY
31632: LIST
31633: LIST
31634: PUSH
31635: LD_INT 30
31637: PUSH
31638: LD_INT 33
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: LIST
31649: PPUSH
31650: CALL_OW 72
31654: ST_TO_ADDR
// if not t then
31655: LD_VAR 0 6
31659: NOT
31660: IFFALSE 31664
// continue ;
31662: GO 31521
// for j in tmp do
31664: LD_ADDR_VAR 0 3
31668: PUSH
31669: LD_VAR 0 4
31673: PUSH
31674: FOR_IN
31675: IFFALSE 31705
// if not BuildingStatus ( j ) = bs_idle then
31677: LD_VAR 0 3
31681: PPUSH
31682: CALL_OW 461
31686: PUSH
31687: LD_INT 2
31689: EQUAL
31690: NOT
31691: IFFALSE 31703
// begin busy := true ;
31693: LD_ADDR_VAR 0 8
31697: PUSH
31698: LD_INT 1
31700: ST_TO_ADDR
// break ;
31701: GO 31705
// end ;
31703: GO 31674
31705: POP
31706: POP
// if busy then
31707: LD_VAR 0 8
31711: IFFALSE 31715
// continue ;
31713: GO 31521
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
31715: LD_ADDR_VAR 0 7
31719: PUSH
31720: LD_VAR 0 6
31724: PPUSH
31725: LD_INT 35
31727: PUSH
31728: LD_INT 0
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PPUSH
31735: CALL_OW 72
31739: ST_TO_ADDR
// if tw then
31740: LD_VAR 0 7
31744: IFFALSE 31821
// begin tw := tw [ 1 ] ;
31746: LD_ADDR_VAR 0 7
31750: PUSH
31751: LD_VAR 0 7
31755: PUSH
31756: LD_INT 1
31758: ARRAY
31759: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
31760: LD_ADDR_VAR 0 9
31764: PUSH
31765: LD_VAR 0 7
31769: PPUSH
31770: LD_EXP 99
31774: PUSH
31775: LD_VAR 0 2
31779: ARRAY
31780: PPUSH
31781: CALL 61604 0 2
31785: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
31786: LD_EXP 113
31790: PUSH
31791: LD_VAR 0 2
31795: ARRAY
31796: IFFALSE 31819
// if not weapon in mc_allowed_tower_weapons [ i ] then
31798: LD_VAR 0 9
31802: PUSH
31803: LD_EXP 113
31807: PUSH
31808: LD_VAR 0 2
31812: ARRAY
31813: IN
31814: NOT
31815: IFFALSE 31819
// continue ;
31817: GO 31521
// end else
31819: GO 31884
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
31821: LD_ADDR_VAR 0 5
31825: PUSH
31826: LD_EXP 82
31830: PUSH
31831: LD_VAR 0 2
31835: ARRAY
31836: PPUSH
31837: LD_VAR 0 4
31841: PPUSH
31842: CALL 91805 0 2
31846: ST_TO_ADDR
// if not tmp2 then
31847: LD_VAR 0 5
31851: NOT
31852: IFFALSE 31856
// continue ;
31854: GO 31521
// tw := tmp2 [ 1 ] ;
31856: LD_ADDR_VAR 0 7
31860: PUSH
31861: LD_VAR 0 5
31865: PUSH
31866: LD_INT 1
31868: ARRAY
31869: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
31870: LD_ADDR_VAR 0 9
31874: PUSH
31875: LD_VAR 0 5
31879: PUSH
31880: LD_INT 2
31882: ARRAY
31883: ST_TO_ADDR
// end ; if not weapon then
31884: LD_VAR 0 9
31888: NOT
31889: IFFALSE 31893
// continue ;
31891: GO 31521
// ComPlaceWeapon ( tw , weapon ) ;
31893: LD_VAR 0 7
31897: PPUSH
31898: LD_VAR 0 9
31902: PPUSH
31903: CALL_OW 148
// end ;
31907: GO 31521
31909: POP
31910: POP
// end ;
31911: LD_VAR 0 1
31915: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
31916: LD_INT 0
31918: PPUSH
31919: PPUSH
31920: PPUSH
31921: PPUSH
31922: PPUSH
31923: PPUSH
// if not mc_bases then
31924: LD_EXP 74
31928: NOT
31929: IFFALSE 31933
// exit ;
31931: GO 32945
// for i = 1 to mc_bases do
31933: LD_ADDR_VAR 0 2
31937: PUSH
31938: DOUBLE
31939: LD_INT 1
31941: DEC
31942: ST_TO_ADDR
31943: LD_EXP 74
31947: PUSH
31948: FOR_TO
31949: IFFALSE 32943
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
31951: LD_EXP 87
31955: PUSH
31956: LD_VAR 0 2
31960: ARRAY
31961: NOT
31962: PUSH
31963: LD_EXP 87
31967: PUSH
31968: LD_VAR 0 2
31972: ARRAY
31973: PUSH
31974: LD_EXP 88
31978: PUSH
31979: LD_VAR 0 2
31983: ARRAY
31984: EQUAL
31985: OR
31986: IFFALSE 31990
// continue ;
31988: GO 31948
// if mc_miners [ i ] then
31990: LD_EXP 88
31994: PUSH
31995: LD_VAR 0 2
31999: ARRAY
32000: IFFALSE 32630
// begin k := 1 ;
32002: LD_ADDR_VAR 0 4
32006: PUSH
32007: LD_INT 1
32009: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
32010: LD_ADDR_VAR 0 3
32014: PUSH
32015: DOUBLE
32016: LD_EXP 88
32020: PUSH
32021: LD_VAR 0 2
32025: ARRAY
32026: INC
32027: ST_TO_ADDR
32028: LD_INT 1
32030: PUSH
32031: FOR_DOWNTO
32032: IFFALSE 32628
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32034: LD_EXP 88
32038: PUSH
32039: LD_VAR 0 2
32043: ARRAY
32044: PUSH
32045: LD_VAR 0 3
32049: ARRAY
32050: PPUSH
32051: CALL_OW 301
32055: PUSH
32056: LD_EXP 88
32060: PUSH
32061: LD_VAR 0 2
32065: ARRAY
32066: PUSH
32067: LD_VAR 0 3
32071: ARRAY
32072: PPUSH
32073: CALL_OW 257
32077: PUSH
32078: LD_INT 1
32080: NONEQUAL
32081: OR
32082: IFFALSE 32145
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32084: LD_ADDR_VAR 0 5
32088: PUSH
32089: LD_EXP 88
32093: PUSH
32094: LD_VAR 0 2
32098: ARRAY
32099: PUSH
32100: LD_EXP 88
32104: PUSH
32105: LD_VAR 0 2
32109: ARRAY
32110: PUSH
32111: LD_VAR 0 3
32115: ARRAY
32116: DIFF
32117: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
32118: LD_ADDR_EXP 88
32122: PUSH
32123: LD_EXP 88
32127: PPUSH
32128: LD_VAR 0 2
32132: PPUSH
32133: LD_VAR 0 5
32137: PPUSH
32138: CALL_OW 1
32142: ST_TO_ADDR
// continue ;
32143: GO 32031
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
32145: LD_EXP 88
32149: PUSH
32150: LD_VAR 0 2
32154: ARRAY
32155: PUSH
32156: LD_VAR 0 3
32160: ARRAY
32161: PPUSH
32162: CALL 56570 0 1
32166: PUSH
32167: LD_EXP 88
32171: PUSH
32172: LD_VAR 0 2
32176: ARRAY
32177: PUSH
32178: LD_VAR 0 3
32182: ARRAY
32183: PPUSH
32184: CALL_OW 255
32188: PPUSH
32189: LD_EXP 87
32193: PUSH
32194: LD_VAR 0 2
32198: ARRAY
32199: PUSH
32200: LD_VAR 0 4
32204: ARRAY
32205: PUSH
32206: LD_INT 1
32208: ARRAY
32209: PPUSH
32210: LD_EXP 87
32214: PUSH
32215: LD_VAR 0 2
32219: ARRAY
32220: PUSH
32221: LD_VAR 0 4
32225: ARRAY
32226: PUSH
32227: LD_INT 2
32229: ARRAY
32230: PPUSH
32231: LD_INT 15
32233: PPUSH
32234: CALL 57530 0 4
32238: PUSH
32239: LD_INT 4
32241: ARRAY
32242: PUSH
32243: LD_EXP 88
32247: PUSH
32248: LD_VAR 0 2
32252: ARRAY
32253: PUSH
32254: LD_VAR 0 3
32258: ARRAY
32259: PPUSH
32260: LD_INT 10
32262: PPUSH
32263: CALL 59227 0 2
32267: PUSH
32268: LD_INT 4
32270: ARRAY
32271: OR
32272: AND
32273: IFFALSE 32296
// ComStop ( mc_miners [ i ] [ j ] ) ;
32275: LD_EXP 88
32279: PUSH
32280: LD_VAR 0 2
32284: ARRAY
32285: PUSH
32286: LD_VAR 0 3
32290: ARRAY
32291: PPUSH
32292: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
32296: LD_EXP 88
32300: PUSH
32301: LD_VAR 0 2
32305: ARRAY
32306: PUSH
32307: LD_VAR 0 3
32311: ARRAY
32312: PPUSH
32313: CALL_OW 257
32317: PUSH
32318: LD_INT 1
32320: EQUAL
32321: PUSH
32322: LD_EXP 88
32326: PUSH
32327: LD_VAR 0 2
32331: ARRAY
32332: PUSH
32333: LD_VAR 0 3
32337: ARRAY
32338: PPUSH
32339: CALL_OW 459
32343: NOT
32344: AND
32345: PUSH
32346: LD_EXP 88
32350: PUSH
32351: LD_VAR 0 2
32355: ARRAY
32356: PUSH
32357: LD_VAR 0 3
32361: ARRAY
32362: PPUSH
32363: CALL_OW 255
32367: PPUSH
32368: LD_EXP 87
32372: PUSH
32373: LD_VAR 0 2
32377: ARRAY
32378: PUSH
32379: LD_VAR 0 4
32383: ARRAY
32384: PUSH
32385: LD_INT 1
32387: ARRAY
32388: PPUSH
32389: LD_EXP 87
32393: PUSH
32394: LD_VAR 0 2
32398: ARRAY
32399: PUSH
32400: LD_VAR 0 4
32404: ARRAY
32405: PUSH
32406: LD_INT 2
32408: ARRAY
32409: PPUSH
32410: LD_INT 15
32412: PPUSH
32413: CALL 57530 0 4
32417: PUSH
32418: LD_INT 4
32420: ARRAY
32421: PUSH
32422: LD_INT 0
32424: EQUAL
32425: AND
32426: PUSH
32427: LD_EXP 88
32431: PUSH
32432: LD_VAR 0 2
32436: ARRAY
32437: PUSH
32438: LD_VAR 0 3
32442: ARRAY
32443: PPUSH
32444: CALL_OW 314
32448: NOT
32449: AND
32450: IFFALSE 32626
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32452: LD_EXP 88
32456: PUSH
32457: LD_VAR 0 2
32461: ARRAY
32462: PUSH
32463: LD_VAR 0 3
32467: ARRAY
32468: PPUSH
32469: CALL_OW 310
32473: IFFALSE 32496
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32475: LD_EXP 88
32479: PUSH
32480: LD_VAR 0 2
32484: ARRAY
32485: PUSH
32486: LD_VAR 0 3
32490: ARRAY
32491: PPUSH
32492: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
32496: LD_EXP 88
32500: PUSH
32501: LD_VAR 0 2
32505: ARRAY
32506: PUSH
32507: LD_VAR 0 3
32511: ARRAY
32512: PPUSH
32513: CALL_OW 314
32517: NOT
32518: IFFALSE 32586
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
32520: LD_EXP 88
32524: PUSH
32525: LD_VAR 0 2
32529: ARRAY
32530: PUSH
32531: LD_VAR 0 3
32535: ARRAY
32536: PPUSH
32537: LD_EXP 87
32541: PUSH
32542: LD_VAR 0 2
32546: ARRAY
32547: PUSH
32548: LD_VAR 0 4
32552: ARRAY
32553: PUSH
32554: LD_INT 1
32556: ARRAY
32557: PPUSH
32558: LD_EXP 87
32562: PUSH
32563: LD_VAR 0 2
32567: ARRAY
32568: PUSH
32569: LD_VAR 0 4
32573: ARRAY
32574: PUSH
32575: LD_INT 2
32577: ARRAY
32578: PPUSH
32579: LD_INT 0
32581: PPUSH
32582: CALL_OW 193
// k := k + 1 ;
32586: LD_ADDR_VAR 0 4
32590: PUSH
32591: LD_VAR 0 4
32595: PUSH
32596: LD_INT 1
32598: PLUS
32599: ST_TO_ADDR
// if k > mc_mines [ i ] then
32600: LD_VAR 0 4
32604: PUSH
32605: LD_EXP 87
32609: PUSH
32610: LD_VAR 0 2
32614: ARRAY
32615: GREATER
32616: IFFALSE 32626
// k := 1 ;
32618: LD_ADDR_VAR 0 4
32622: PUSH
32623: LD_INT 1
32625: ST_TO_ADDR
// end ; end ;
32626: GO 32031
32628: POP
32629: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
32630: LD_ADDR_VAR 0 5
32634: PUSH
32635: LD_EXP 74
32639: PUSH
32640: LD_VAR 0 2
32644: ARRAY
32645: PPUSH
32646: LD_INT 2
32648: PUSH
32649: LD_INT 30
32651: PUSH
32652: LD_INT 4
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 30
32661: PUSH
32662: LD_INT 5
32664: PUSH
32665: EMPTY
32666: LIST
32667: LIST
32668: PUSH
32669: LD_INT 30
32671: PUSH
32672: LD_INT 32
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: PPUSH
32685: CALL_OW 72
32689: ST_TO_ADDR
// if not tmp then
32690: LD_VAR 0 5
32694: NOT
32695: IFFALSE 32699
// continue ;
32697: GO 31948
// list := [ ] ;
32699: LD_ADDR_VAR 0 6
32703: PUSH
32704: EMPTY
32705: ST_TO_ADDR
// for j in tmp do
32706: LD_ADDR_VAR 0 3
32710: PUSH
32711: LD_VAR 0 5
32715: PUSH
32716: FOR_IN
32717: IFFALSE 32786
// begin for k in UnitsInside ( j ) do
32719: LD_ADDR_VAR 0 4
32723: PUSH
32724: LD_VAR 0 3
32728: PPUSH
32729: CALL_OW 313
32733: PUSH
32734: FOR_IN
32735: IFFALSE 32782
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
32737: LD_VAR 0 4
32741: PPUSH
32742: CALL_OW 257
32746: PUSH
32747: LD_INT 1
32749: EQUAL
32750: PUSH
32751: LD_VAR 0 4
32755: PPUSH
32756: CALL_OW 459
32760: NOT
32761: AND
32762: IFFALSE 32780
// list := list ^ k ;
32764: LD_ADDR_VAR 0 6
32768: PUSH
32769: LD_VAR 0 6
32773: PUSH
32774: LD_VAR 0 4
32778: ADD
32779: ST_TO_ADDR
32780: GO 32734
32782: POP
32783: POP
// end ;
32784: GO 32716
32786: POP
32787: POP
// list := list diff mc_miners [ i ] ;
32788: LD_ADDR_VAR 0 6
32792: PUSH
32793: LD_VAR 0 6
32797: PUSH
32798: LD_EXP 88
32802: PUSH
32803: LD_VAR 0 2
32807: ARRAY
32808: DIFF
32809: ST_TO_ADDR
// if not list then
32810: LD_VAR 0 6
32814: NOT
32815: IFFALSE 32819
// continue ;
32817: GO 31948
// k := mc_mines [ i ] - mc_miners [ i ] ;
32819: LD_ADDR_VAR 0 4
32823: PUSH
32824: LD_EXP 87
32828: PUSH
32829: LD_VAR 0 2
32833: ARRAY
32834: PUSH
32835: LD_EXP 88
32839: PUSH
32840: LD_VAR 0 2
32844: ARRAY
32845: MINUS
32846: ST_TO_ADDR
// if k > list then
32847: LD_VAR 0 4
32851: PUSH
32852: LD_VAR 0 6
32856: GREATER
32857: IFFALSE 32869
// k := list ;
32859: LD_ADDR_VAR 0 4
32863: PUSH
32864: LD_VAR 0 6
32868: ST_TO_ADDR
// for j = 1 to k do
32869: LD_ADDR_VAR 0 3
32873: PUSH
32874: DOUBLE
32875: LD_INT 1
32877: DEC
32878: ST_TO_ADDR
32879: LD_VAR 0 4
32883: PUSH
32884: FOR_TO
32885: IFFALSE 32939
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
32887: LD_ADDR_EXP 88
32891: PUSH
32892: LD_EXP 88
32896: PPUSH
32897: LD_VAR 0 2
32901: PUSH
32902: LD_EXP 88
32906: PUSH
32907: LD_VAR 0 2
32911: ARRAY
32912: PUSH
32913: LD_INT 1
32915: PLUS
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PPUSH
32921: LD_VAR 0 6
32925: PUSH
32926: LD_VAR 0 3
32930: ARRAY
32931: PPUSH
32932: CALL 56634 0 3
32936: ST_TO_ADDR
32937: GO 32884
32939: POP
32940: POP
// end ;
32941: GO 31948
32943: POP
32944: POP
// end ;
32945: LD_VAR 0 1
32949: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
32950: LD_INT 0
32952: PPUSH
32953: PPUSH
32954: PPUSH
32955: PPUSH
32956: PPUSH
32957: PPUSH
32958: PPUSH
32959: PPUSH
32960: PPUSH
32961: PPUSH
// if not mc_bases then
32962: LD_EXP 74
32966: NOT
32967: IFFALSE 32971
// exit ;
32969: GO 34721
// for i = 1 to mc_bases do
32971: LD_ADDR_VAR 0 2
32975: PUSH
32976: DOUBLE
32977: LD_INT 1
32979: DEC
32980: ST_TO_ADDR
32981: LD_EXP 74
32985: PUSH
32986: FOR_TO
32987: IFFALSE 34719
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
32989: LD_EXP 74
32993: PUSH
32994: LD_VAR 0 2
32998: ARRAY
32999: NOT
33000: PUSH
33001: LD_EXP 81
33005: PUSH
33006: LD_VAR 0 2
33010: ARRAY
33011: OR
33012: IFFALSE 33016
// continue ;
33014: GO 32986
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33016: LD_EXP 90
33020: PUSH
33021: LD_VAR 0 2
33025: ARRAY
33026: NOT
33027: PUSH
33028: LD_EXP 91
33032: PUSH
33033: LD_VAR 0 2
33037: ARRAY
33038: AND
33039: IFFALSE 33077
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33041: LD_ADDR_EXP 91
33045: PUSH
33046: LD_EXP 91
33050: PPUSH
33051: LD_VAR 0 2
33055: PPUSH
33056: EMPTY
33057: PPUSH
33058: CALL_OW 1
33062: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33063: LD_VAR 0 2
33067: PPUSH
33068: LD_INT 107
33070: PPUSH
33071: CALL 23831 0 2
// continue ;
33075: GO 32986
// end ; target := [ ] ;
33077: LD_ADDR_VAR 0 6
33081: PUSH
33082: EMPTY
33083: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33084: LD_ADDR_VAR 0 3
33088: PUSH
33089: DOUBLE
33090: LD_EXP 90
33094: PUSH
33095: LD_VAR 0 2
33099: ARRAY
33100: INC
33101: ST_TO_ADDR
33102: LD_INT 1
33104: PUSH
33105: FOR_DOWNTO
33106: IFFALSE 33366
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33108: LD_EXP 90
33112: PUSH
33113: LD_VAR 0 2
33117: ARRAY
33118: PUSH
33119: LD_VAR 0 3
33123: ARRAY
33124: PUSH
33125: LD_INT 2
33127: ARRAY
33128: PPUSH
33129: LD_EXP 90
33133: PUSH
33134: LD_VAR 0 2
33138: ARRAY
33139: PUSH
33140: LD_VAR 0 3
33144: ARRAY
33145: PUSH
33146: LD_INT 3
33148: ARRAY
33149: PPUSH
33150: CALL_OW 488
33154: PUSH
33155: LD_EXP 90
33159: PUSH
33160: LD_VAR 0 2
33164: ARRAY
33165: PUSH
33166: LD_VAR 0 3
33170: ARRAY
33171: PUSH
33172: LD_INT 2
33174: ARRAY
33175: PPUSH
33176: LD_EXP 90
33180: PUSH
33181: LD_VAR 0 2
33185: ARRAY
33186: PUSH
33187: LD_VAR 0 3
33191: ARRAY
33192: PUSH
33193: LD_INT 3
33195: ARRAY
33196: PPUSH
33197: CALL_OW 284
33201: PUSH
33202: LD_INT 0
33204: EQUAL
33205: AND
33206: IFFALSE 33261
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33208: LD_ADDR_VAR 0 5
33212: PUSH
33213: LD_EXP 90
33217: PUSH
33218: LD_VAR 0 2
33222: ARRAY
33223: PPUSH
33224: LD_VAR 0 3
33228: PPUSH
33229: CALL_OW 3
33233: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33234: LD_ADDR_EXP 90
33238: PUSH
33239: LD_EXP 90
33243: PPUSH
33244: LD_VAR 0 2
33248: PPUSH
33249: LD_VAR 0 5
33253: PPUSH
33254: CALL_OW 1
33258: ST_TO_ADDR
// continue ;
33259: GO 33105
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33261: LD_EXP 74
33265: PUSH
33266: LD_VAR 0 2
33270: ARRAY
33271: PUSH
33272: LD_INT 1
33274: ARRAY
33275: PPUSH
33276: CALL_OW 255
33280: PPUSH
33281: LD_EXP 90
33285: PUSH
33286: LD_VAR 0 2
33290: ARRAY
33291: PUSH
33292: LD_VAR 0 3
33296: ARRAY
33297: PUSH
33298: LD_INT 2
33300: ARRAY
33301: PPUSH
33302: LD_EXP 90
33306: PUSH
33307: LD_VAR 0 2
33311: ARRAY
33312: PUSH
33313: LD_VAR 0 3
33317: ARRAY
33318: PUSH
33319: LD_INT 3
33321: ARRAY
33322: PPUSH
33323: LD_INT 30
33325: PPUSH
33326: CALL 57530 0 4
33330: PUSH
33331: LD_INT 4
33333: ARRAY
33334: PUSH
33335: LD_INT 0
33337: EQUAL
33338: IFFALSE 33364
// begin target := mc_crates [ i ] [ j ] ;
33340: LD_ADDR_VAR 0 6
33344: PUSH
33345: LD_EXP 90
33349: PUSH
33350: LD_VAR 0 2
33354: ARRAY
33355: PUSH
33356: LD_VAR 0 3
33360: ARRAY
33361: ST_TO_ADDR
// break ;
33362: GO 33366
// end ; end ;
33364: GO 33105
33366: POP
33367: POP
// if not target then
33368: LD_VAR 0 6
33372: NOT
33373: IFFALSE 33377
// continue ;
33375: GO 32986
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33377: LD_ADDR_VAR 0 7
33381: PUSH
33382: LD_EXP 93
33386: PUSH
33387: LD_VAR 0 2
33391: ARRAY
33392: PPUSH
33393: LD_INT 2
33395: PUSH
33396: LD_INT 3
33398: PUSH
33399: LD_INT 58
33401: PUSH
33402: EMPTY
33403: LIST
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 61
33411: PUSH
33412: EMPTY
33413: LIST
33414: PUSH
33415: LD_INT 33
33417: PUSH
33418: LD_INT 5
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 33
33427: PUSH
33428: LD_INT 3
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 2
33444: PUSH
33445: LD_INT 34
33447: PUSH
33448: LD_INT 32
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 34
33457: PUSH
33458: LD_INT 51
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 34
33467: PUSH
33468: LD_INT 12
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: PUSH
33481: EMPTY
33482: LIST
33483: LIST
33484: PPUSH
33485: CALL_OW 72
33489: ST_TO_ADDR
// if not cargo then
33490: LD_VAR 0 7
33494: NOT
33495: IFFALSE 34138
// begin if mc_crates_collector [ i ] < 5 then
33497: LD_EXP 91
33501: PUSH
33502: LD_VAR 0 2
33506: ARRAY
33507: PUSH
33508: LD_INT 5
33510: LESS
33511: IFFALSE 33877
// begin if mc_ape [ i ] then
33513: LD_EXP 103
33517: PUSH
33518: LD_VAR 0 2
33522: ARRAY
33523: IFFALSE 33570
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
33525: LD_ADDR_VAR 0 5
33529: PUSH
33530: LD_EXP 103
33534: PUSH
33535: LD_VAR 0 2
33539: ARRAY
33540: PPUSH
33541: LD_INT 25
33543: PUSH
33544: LD_INT 16
33546: PUSH
33547: EMPTY
33548: LIST
33549: LIST
33550: PUSH
33551: LD_INT 24
33553: PUSH
33554: LD_INT 750
33556: PUSH
33557: EMPTY
33558: LIST
33559: LIST
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PPUSH
33565: CALL_OW 72
33569: ST_TO_ADDR
// if not tmp then
33570: LD_VAR 0 5
33574: NOT
33575: IFFALSE 33622
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
33577: LD_ADDR_VAR 0 5
33581: PUSH
33582: LD_EXP 74
33586: PUSH
33587: LD_VAR 0 2
33591: ARRAY
33592: PPUSH
33593: LD_INT 25
33595: PUSH
33596: LD_INT 2
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: LD_INT 24
33605: PUSH
33606: LD_INT 750
33608: PUSH
33609: EMPTY
33610: LIST
33611: LIST
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PPUSH
33617: CALL_OW 72
33621: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
33622: LD_EXP 103
33626: PUSH
33627: LD_VAR 0 2
33631: ARRAY
33632: PUSH
33633: LD_EXP 74
33637: PUSH
33638: LD_VAR 0 2
33642: ARRAY
33643: PPUSH
33644: LD_INT 25
33646: PUSH
33647: LD_INT 2
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 24
33656: PUSH
33657: LD_INT 750
33659: PUSH
33660: EMPTY
33661: LIST
33662: LIST
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PPUSH
33668: CALL_OW 72
33672: AND
33673: PUSH
33674: LD_VAR 0 5
33678: PUSH
33679: LD_INT 5
33681: LESS
33682: AND
33683: IFFALSE 33765
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
33685: LD_ADDR_VAR 0 3
33689: PUSH
33690: LD_EXP 74
33694: PUSH
33695: LD_VAR 0 2
33699: ARRAY
33700: PPUSH
33701: LD_INT 25
33703: PUSH
33704: LD_INT 2
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 24
33713: PUSH
33714: LD_INT 750
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PPUSH
33725: CALL_OW 72
33729: PUSH
33730: FOR_IN
33731: IFFALSE 33763
// begin tmp := tmp union j ;
33733: LD_ADDR_VAR 0 5
33737: PUSH
33738: LD_VAR 0 5
33742: PUSH
33743: LD_VAR 0 3
33747: UNION
33748: ST_TO_ADDR
// if tmp >= 5 then
33749: LD_VAR 0 5
33753: PUSH
33754: LD_INT 5
33756: GREATEREQUAL
33757: IFFALSE 33761
// break ;
33759: GO 33763
// end ;
33761: GO 33730
33763: POP
33764: POP
// end ; if not tmp then
33765: LD_VAR 0 5
33769: NOT
33770: IFFALSE 33774
// continue ;
33772: GO 32986
// for j in tmp do
33774: LD_ADDR_VAR 0 3
33778: PUSH
33779: LD_VAR 0 5
33783: PUSH
33784: FOR_IN
33785: IFFALSE 33875
// if not GetTag ( j ) then
33787: LD_VAR 0 3
33791: PPUSH
33792: CALL_OW 110
33796: NOT
33797: IFFALSE 33873
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
33799: LD_ADDR_EXP 91
33803: PUSH
33804: LD_EXP 91
33808: PPUSH
33809: LD_VAR 0 2
33813: PUSH
33814: LD_EXP 91
33818: PUSH
33819: LD_VAR 0 2
33823: ARRAY
33824: PUSH
33825: LD_INT 1
33827: PLUS
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PPUSH
33833: LD_VAR 0 3
33837: PPUSH
33838: CALL 56634 0 3
33842: ST_TO_ADDR
// SetTag ( j , 107 ) ;
33843: LD_VAR 0 3
33847: PPUSH
33848: LD_INT 107
33850: PPUSH
33851: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
33855: LD_EXP 91
33859: PUSH
33860: LD_VAR 0 2
33864: ARRAY
33865: PUSH
33866: LD_INT 5
33868: GREATEREQUAL
33869: IFFALSE 33873
// break ;
33871: GO 33875
// end ;
33873: GO 33784
33875: POP
33876: POP
// end ; if mc_crates_collector [ i ] and target then
33877: LD_EXP 91
33881: PUSH
33882: LD_VAR 0 2
33886: ARRAY
33887: PUSH
33888: LD_VAR 0 6
33892: AND
33893: IFFALSE 34136
// begin if mc_crates_collector [ i ] < target [ 1 ] then
33895: LD_EXP 91
33899: PUSH
33900: LD_VAR 0 2
33904: ARRAY
33905: PUSH
33906: LD_VAR 0 6
33910: PUSH
33911: LD_INT 1
33913: ARRAY
33914: LESS
33915: IFFALSE 33935
// tmp := mc_crates_collector [ i ] else
33917: LD_ADDR_VAR 0 5
33921: PUSH
33922: LD_EXP 91
33926: PUSH
33927: LD_VAR 0 2
33931: ARRAY
33932: ST_TO_ADDR
33933: GO 33949
// tmp := target [ 1 ] ;
33935: LD_ADDR_VAR 0 5
33939: PUSH
33940: LD_VAR 0 6
33944: PUSH
33945: LD_INT 1
33947: ARRAY
33948: ST_TO_ADDR
// k := 0 ;
33949: LD_ADDR_VAR 0 4
33953: PUSH
33954: LD_INT 0
33956: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
33957: LD_ADDR_VAR 0 3
33961: PUSH
33962: LD_EXP 91
33966: PUSH
33967: LD_VAR 0 2
33971: ARRAY
33972: PUSH
33973: FOR_IN
33974: IFFALSE 34134
// begin k := k + 1 ;
33976: LD_ADDR_VAR 0 4
33980: PUSH
33981: LD_VAR 0 4
33985: PUSH
33986: LD_INT 1
33988: PLUS
33989: ST_TO_ADDR
// if k > tmp then
33990: LD_VAR 0 4
33994: PUSH
33995: LD_VAR 0 5
33999: GREATER
34000: IFFALSE 34004
// break ;
34002: GO 34134
// if not GetClass ( j ) in [ 2 , 16 ] then
34004: LD_VAR 0 3
34008: PPUSH
34009: CALL_OW 257
34013: PUSH
34014: LD_INT 2
34016: PUSH
34017: LD_INT 16
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: IN
34024: NOT
34025: IFFALSE 34078
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34027: LD_ADDR_EXP 91
34031: PUSH
34032: LD_EXP 91
34036: PPUSH
34037: LD_VAR 0 2
34041: PPUSH
34042: LD_EXP 91
34046: PUSH
34047: LD_VAR 0 2
34051: ARRAY
34052: PUSH
34053: LD_VAR 0 3
34057: DIFF
34058: PPUSH
34059: CALL_OW 1
34063: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34064: LD_VAR 0 3
34068: PPUSH
34069: LD_INT 0
34071: PPUSH
34072: CALL_OW 109
// continue ;
34076: GO 33973
// end ; if IsInUnit ( j ) then
34078: LD_VAR 0 3
34082: PPUSH
34083: CALL_OW 310
34087: IFFALSE 34098
// ComExitBuilding ( j ) ;
34089: LD_VAR 0 3
34093: PPUSH
34094: CALL_OW 122
// wait ( 3 ) ;
34098: LD_INT 3
34100: PPUSH
34101: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34105: LD_VAR 0 3
34109: PPUSH
34110: LD_VAR 0 6
34114: PUSH
34115: LD_INT 2
34117: ARRAY
34118: PPUSH
34119: LD_VAR 0 6
34123: PUSH
34124: LD_INT 3
34126: ARRAY
34127: PPUSH
34128: CALL_OW 117
// end ;
34132: GO 33973
34134: POP
34135: POP
// end ; end else
34136: GO 34717
// begin for j in cargo do
34138: LD_ADDR_VAR 0 3
34142: PUSH
34143: LD_VAR 0 7
34147: PUSH
34148: FOR_IN
34149: IFFALSE 34715
// begin if GetTag ( j ) <> 0 then
34151: LD_VAR 0 3
34155: PPUSH
34156: CALL_OW 110
34160: PUSH
34161: LD_INT 0
34163: NONEQUAL
34164: IFFALSE 34168
// continue ;
34166: GO 34148
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34168: LD_VAR 0 3
34172: PPUSH
34173: CALL_OW 256
34177: PUSH
34178: LD_INT 1000
34180: LESS
34181: PUSH
34182: LD_VAR 0 3
34186: PPUSH
34187: LD_EXP 98
34191: PUSH
34192: LD_VAR 0 2
34196: ARRAY
34197: PPUSH
34198: CALL_OW 308
34202: NOT
34203: AND
34204: IFFALSE 34226
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34206: LD_VAR 0 3
34210: PPUSH
34211: LD_EXP 98
34215: PUSH
34216: LD_VAR 0 2
34220: ARRAY
34221: PPUSH
34222: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34226: LD_VAR 0 3
34230: PPUSH
34231: CALL_OW 256
34235: PUSH
34236: LD_INT 1000
34238: LESS
34239: PUSH
34240: LD_VAR 0 3
34244: PPUSH
34245: LD_EXP 98
34249: PUSH
34250: LD_VAR 0 2
34254: ARRAY
34255: PPUSH
34256: CALL_OW 308
34260: AND
34261: IFFALSE 34265
// continue ;
34263: GO 34148
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34265: LD_VAR 0 3
34269: PPUSH
34270: CALL_OW 262
34274: PUSH
34275: LD_INT 2
34277: EQUAL
34278: PUSH
34279: LD_VAR 0 3
34283: PPUSH
34284: CALL_OW 261
34288: PUSH
34289: LD_INT 15
34291: LESS
34292: AND
34293: IFFALSE 34297
// continue ;
34295: GO 34148
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34297: LD_VAR 0 3
34301: PPUSH
34302: CALL_OW 262
34306: PUSH
34307: LD_INT 1
34309: EQUAL
34310: PUSH
34311: LD_VAR 0 3
34315: PPUSH
34316: CALL_OW 261
34320: PUSH
34321: LD_INT 10
34323: LESS
34324: AND
34325: IFFALSE 34654
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34327: LD_ADDR_VAR 0 8
34331: PUSH
34332: LD_EXP 74
34336: PUSH
34337: LD_VAR 0 2
34341: ARRAY
34342: PPUSH
34343: LD_INT 2
34345: PUSH
34346: LD_INT 30
34348: PUSH
34349: LD_INT 0
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 30
34358: PUSH
34359: LD_INT 1
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: LIST
34370: PPUSH
34371: CALL_OW 72
34375: ST_TO_ADDR
// if not depot then
34376: LD_VAR 0 8
34380: NOT
34381: IFFALSE 34385
// continue ;
34383: GO 34148
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34385: LD_VAR 0 3
34389: PPUSH
34390: LD_VAR 0 8
34394: PPUSH
34395: LD_VAR 0 3
34399: PPUSH
34400: CALL_OW 74
34404: PPUSH
34405: CALL_OW 296
34409: PUSH
34410: LD_INT 6
34412: LESS
34413: IFFALSE 34429
// SetFuel ( j , 100 ) else
34415: LD_VAR 0 3
34419: PPUSH
34420: LD_INT 100
34422: PPUSH
34423: CALL_OW 240
34427: GO 34654
// if GetFuel ( j ) = 0 then
34429: LD_VAR 0 3
34433: PPUSH
34434: CALL_OW 261
34438: PUSH
34439: LD_INT 0
34441: EQUAL
34442: IFFALSE 34654
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34444: LD_ADDR_EXP 93
34448: PUSH
34449: LD_EXP 93
34453: PPUSH
34454: LD_VAR 0 2
34458: PPUSH
34459: LD_EXP 93
34463: PUSH
34464: LD_VAR 0 2
34468: ARRAY
34469: PUSH
34470: LD_VAR 0 3
34474: DIFF
34475: PPUSH
34476: CALL_OW 1
34480: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34481: LD_VAR 0 3
34485: PPUSH
34486: CALL_OW 263
34490: PUSH
34491: LD_INT 1
34493: EQUAL
34494: IFFALSE 34510
// ComExitVehicle ( IsInUnit ( j ) ) ;
34496: LD_VAR 0 3
34500: PPUSH
34501: CALL_OW 310
34505: PPUSH
34506: CALL_OW 121
// if GetControl ( j ) = control_remote then
34510: LD_VAR 0 3
34514: PPUSH
34515: CALL_OW 263
34519: PUSH
34520: LD_INT 2
34522: EQUAL
34523: IFFALSE 34534
// ComUnlink ( j ) ;
34525: LD_VAR 0 3
34529: PPUSH
34530: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
34534: LD_ADDR_VAR 0 9
34538: PUSH
34539: LD_VAR 0 2
34543: PPUSH
34544: LD_INT 3
34546: PPUSH
34547: CALL 43791 0 2
34551: ST_TO_ADDR
// if fac then
34552: LD_VAR 0 9
34556: IFFALSE 34652
// begin for k in fac do
34558: LD_ADDR_VAR 0 4
34562: PUSH
34563: LD_VAR 0 9
34567: PUSH
34568: FOR_IN
34569: IFFALSE 34650
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
34571: LD_ADDR_VAR 0 10
34575: PUSH
34576: LD_VAR 0 9
34580: PPUSH
34581: LD_VAR 0 3
34585: PPUSH
34586: CALL_OW 265
34590: PPUSH
34591: LD_VAR 0 3
34595: PPUSH
34596: CALL_OW 262
34600: PPUSH
34601: LD_VAR 0 3
34605: PPUSH
34606: CALL_OW 263
34610: PPUSH
34611: LD_VAR 0 3
34615: PPUSH
34616: CALL_OW 264
34620: PPUSH
34621: CALL 54166 0 5
34625: ST_TO_ADDR
// if components then
34626: LD_VAR 0 10
34630: IFFALSE 34648
// begin MC_InsertProduceList ( i , components ) ;
34632: LD_VAR 0 2
34636: PPUSH
34637: LD_VAR 0 10
34641: PPUSH
34642: CALL 43336 0 2
// break ;
34646: GO 34650
// end ; end ;
34648: GO 34568
34650: POP
34651: POP
// end ; continue ;
34652: GO 34148
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
34654: LD_VAR 0 3
34658: PPUSH
34659: LD_INT 1
34661: PPUSH
34662: CALL_OW 289
34666: PUSH
34667: LD_INT 100
34669: LESS
34670: PUSH
34671: LD_VAR 0 3
34675: PPUSH
34676: CALL_OW 314
34680: NOT
34681: AND
34682: IFFALSE 34711
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34684: LD_VAR 0 3
34688: PPUSH
34689: LD_VAR 0 6
34693: PUSH
34694: LD_INT 2
34696: ARRAY
34697: PPUSH
34698: LD_VAR 0 6
34702: PUSH
34703: LD_INT 3
34705: ARRAY
34706: PPUSH
34707: CALL_OW 117
// break ;
34711: GO 34715
// end ;
34713: GO 34148
34715: POP
34716: POP
// end ; end ;
34717: GO 32986
34719: POP
34720: POP
// end ;
34721: LD_VAR 0 1
34725: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
34726: LD_INT 0
34728: PPUSH
34729: PPUSH
34730: PPUSH
34731: PPUSH
// if not mc_bases then
34732: LD_EXP 74
34736: NOT
34737: IFFALSE 34741
// exit ;
34739: GO 34902
// for i = 1 to mc_bases do
34741: LD_ADDR_VAR 0 2
34745: PUSH
34746: DOUBLE
34747: LD_INT 1
34749: DEC
34750: ST_TO_ADDR
34751: LD_EXP 74
34755: PUSH
34756: FOR_TO
34757: IFFALSE 34900
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
34759: LD_ADDR_VAR 0 4
34763: PUSH
34764: LD_EXP 93
34768: PUSH
34769: LD_VAR 0 2
34773: ARRAY
34774: PUSH
34775: LD_EXP 96
34779: PUSH
34780: LD_VAR 0 2
34784: ARRAY
34785: UNION
34786: PPUSH
34787: LD_INT 33
34789: PUSH
34790: LD_INT 2
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PPUSH
34797: CALL_OW 72
34801: ST_TO_ADDR
// if tmp then
34802: LD_VAR 0 4
34806: IFFALSE 34898
// for j in tmp do
34808: LD_ADDR_VAR 0 3
34812: PUSH
34813: LD_VAR 0 4
34817: PUSH
34818: FOR_IN
34819: IFFALSE 34896
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
34821: LD_VAR 0 3
34825: PPUSH
34826: CALL_OW 312
34830: NOT
34831: PUSH
34832: LD_VAR 0 3
34836: PPUSH
34837: CALL_OW 256
34841: PUSH
34842: LD_INT 250
34844: GREATEREQUAL
34845: AND
34846: IFFALSE 34859
// Connect ( j ) else
34848: LD_VAR 0 3
34852: PPUSH
34853: CALL 59567 0 1
34857: GO 34894
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
34859: LD_VAR 0 3
34863: PPUSH
34864: CALL_OW 256
34868: PUSH
34869: LD_INT 250
34871: LESS
34872: PUSH
34873: LD_VAR 0 3
34877: PPUSH
34878: CALL_OW 312
34882: AND
34883: IFFALSE 34894
// ComUnlink ( j ) ;
34885: LD_VAR 0 3
34889: PPUSH
34890: CALL_OW 136
34894: GO 34818
34896: POP
34897: POP
// end ;
34898: GO 34756
34900: POP
34901: POP
// end ;
34902: LD_VAR 0 1
34906: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
34907: LD_INT 0
34909: PPUSH
34910: PPUSH
34911: PPUSH
34912: PPUSH
34913: PPUSH
// if not mc_bases then
34914: LD_EXP 74
34918: NOT
34919: IFFALSE 34923
// exit ;
34921: GO 35368
// for i = 1 to mc_bases do
34923: LD_ADDR_VAR 0 2
34927: PUSH
34928: DOUBLE
34929: LD_INT 1
34931: DEC
34932: ST_TO_ADDR
34933: LD_EXP 74
34937: PUSH
34938: FOR_TO
34939: IFFALSE 35366
// begin if not mc_produce [ i ] then
34941: LD_EXP 95
34945: PUSH
34946: LD_VAR 0 2
34950: ARRAY
34951: NOT
34952: IFFALSE 34956
// continue ;
34954: GO 34938
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34956: LD_ADDR_VAR 0 5
34960: PUSH
34961: LD_EXP 74
34965: PUSH
34966: LD_VAR 0 2
34970: ARRAY
34971: PPUSH
34972: LD_INT 30
34974: PUSH
34975: LD_INT 3
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PPUSH
34982: CALL_OW 72
34986: ST_TO_ADDR
// if not fac then
34987: LD_VAR 0 5
34991: NOT
34992: IFFALSE 34996
// continue ;
34994: GO 34938
// for j in fac do
34996: LD_ADDR_VAR 0 3
35000: PUSH
35001: LD_VAR 0 5
35005: PUSH
35006: FOR_IN
35007: IFFALSE 35362
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35009: LD_VAR 0 3
35013: PPUSH
35014: CALL_OW 461
35018: PUSH
35019: LD_INT 2
35021: NONEQUAL
35022: PUSH
35023: LD_VAR 0 3
35027: PPUSH
35028: LD_INT 15
35030: PPUSH
35031: CALL 59227 0 2
35035: PUSH
35036: LD_INT 4
35038: ARRAY
35039: OR
35040: IFFALSE 35044
// continue ;
35042: GO 35006
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35044: LD_VAR 0 3
35048: PPUSH
35049: LD_EXP 95
35053: PUSH
35054: LD_VAR 0 2
35058: ARRAY
35059: PUSH
35060: LD_INT 1
35062: ARRAY
35063: PUSH
35064: LD_INT 1
35066: ARRAY
35067: PPUSH
35068: LD_EXP 95
35072: PUSH
35073: LD_VAR 0 2
35077: ARRAY
35078: PUSH
35079: LD_INT 1
35081: ARRAY
35082: PUSH
35083: LD_INT 2
35085: ARRAY
35086: PPUSH
35087: LD_EXP 95
35091: PUSH
35092: LD_VAR 0 2
35096: ARRAY
35097: PUSH
35098: LD_INT 1
35100: ARRAY
35101: PUSH
35102: LD_INT 3
35104: ARRAY
35105: PPUSH
35106: LD_EXP 95
35110: PUSH
35111: LD_VAR 0 2
35115: ARRAY
35116: PUSH
35117: LD_INT 1
35119: ARRAY
35120: PUSH
35121: LD_INT 4
35123: ARRAY
35124: PPUSH
35125: CALL_OW 448
35129: PUSH
35130: LD_VAR 0 3
35134: PPUSH
35135: LD_EXP 95
35139: PUSH
35140: LD_VAR 0 2
35144: ARRAY
35145: PUSH
35146: LD_INT 1
35148: ARRAY
35149: PUSH
35150: LD_INT 1
35152: ARRAY
35153: PUSH
35154: LD_EXP 95
35158: PUSH
35159: LD_VAR 0 2
35163: ARRAY
35164: PUSH
35165: LD_INT 1
35167: ARRAY
35168: PUSH
35169: LD_INT 2
35171: ARRAY
35172: PUSH
35173: LD_EXP 95
35177: PUSH
35178: LD_VAR 0 2
35182: ARRAY
35183: PUSH
35184: LD_INT 1
35186: ARRAY
35187: PUSH
35188: LD_INT 3
35190: ARRAY
35191: PUSH
35192: LD_EXP 95
35196: PUSH
35197: LD_VAR 0 2
35201: ARRAY
35202: PUSH
35203: LD_INT 1
35205: ARRAY
35206: PUSH
35207: LD_INT 4
35209: ARRAY
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: LIST
35215: LIST
35216: PPUSH
35217: CALL 62898 0 2
35221: AND
35222: IFFALSE 35360
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35224: LD_VAR 0 3
35228: PPUSH
35229: LD_EXP 95
35233: PUSH
35234: LD_VAR 0 2
35238: ARRAY
35239: PUSH
35240: LD_INT 1
35242: ARRAY
35243: PUSH
35244: LD_INT 1
35246: ARRAY
35247: PPUSH
35248: LD_EXP 95
35252: PUSH
35253: LD_VAR 0 2
35257: ARRAY
35258: PUSH
35259: LD_INT 1
35261: ARRAY
35262: PUSH
35263: LD_INT 2
35265: ARRAY
35266: PPUSH
35267: LD_EXP 95
35271: PUSH
35272: LD_VAR 0 2
35276: ARRAY
35277: PUSH
35278: LD_INT 1
35280: ARRAY
35281: PUSH
35282: LD_INT 3
35284: ARRAY
35285: PPUSH
35286: LD_EXP 95
35290: PUSH
35291: LD_VAR 0 2
35295: ARRAY
35296: PUSH
35297: LD_INT 1
35299: ARRAY
35300: PUSH
35301: LD_INT 4
35303: ARRAY
35304: PPUSH
35305: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35309: LD_ADDR_VAR 0 4
35313: PUSH
35314: LD_EXP 95
35318: PUSH
35319: LD_VAR 0 2
35323: ARRAY
35324: PPUSH
35325: LD_INT 1
35327: PPUSH
35328: CALL_OW 3
35332: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35333: LD_ADDR_EXP 95
35337: PUSH
35338: LD_EXP 95
35342: PPUSH
35343: LD_VAR 0 2
35347: PPUSH
35348: LD_VAR 0 4
35352: PPUSH
35353: CALL_OW 1
35357: ST_TO_ADDR
// break ;
35358: GO 35362
// end ; end ;
35360: GO 35006
35362: POP
35363: POP
// end ;
35364: GO 34938
35366: POP
35367: POP
// end ;
35368: LD_VAR 0 1
35372: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35373: LD_INT 0
35375: PPUSH
35376: PPUSH
35377: PPUSH
// if not mc_bases then
35378: LD_EXP 74
35382: NOT
35383: IFFALSE 35387
// exit ;
35385: GO 35476
// for i = 1 to mc_bases do
35387: LD_ADDR_VAR 0 2
35391: PUSH
35392: DOUBLE
35393: LD_INT 1
35395: DEC
35396: ST_TO_ADDR
35397: LD_EXP 74
35401: PUSH
35402: FOR_TO
35403: IFFALSE 35474
// begin if mc_attack [ i ] then
35405: LD_EXP 94
35409: PUSH
35410: LD_VAR 0 2
35414: ARRAY
35415: IFFALSE 35472
// begin tmp := mc_attack [ i ] [ 1 ] ;
35417: LD_ADDR_VAR 0 3
35421: PUSH
35422: LD_EXP 94
35426: PUSH
35427: LD_VAR 0 2
35431: ARRAY
35432: PUSH
35433: LD_INT 1
35435: ARRAY
35436: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35437: LD_ADDR_EXP 94
35441: PUSH
35442: LD_EXP 94
35446: PPUSH
35447: LD_VAR 0 2
35451: PPUSH
35452: EMPTY
35453: PPUSH
35454: CALL_OW 1
35458: ST_TO_ADDR
// Attack ( tmp ) ;
35459: LD_VAR 0 3
35463: PPUSH
35464: CALL 85111 0 1
// exit ;
35468: POP
35469: POP
35470: GO 35476
// end ; end ;
35472: GO 35402
35474: POP
35475: POP
// end ;
35476: LD_VAR 0 1
35480: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35481: LD_INT 0
35483: PPUSH
35484: PPUSH
35485: PPUSH
35486: PPUSH
35487: PPUSH
35488: PPUSH
35489: PPUSH
// if not mc_bases then
35490: LD_EXP 74
35494: NOT
35495: IFFALSE 35499
// exit ;
35497: GO 36081
// for i = 1 to mc_bases do
35499: LD_ADDR_VAR 0 2
35503: PUSH
35504: DOUBLE
35505: LD_INT 1
35507: DEC
35508: ST_TO_ADDR
35509: LD_EXP 74
35513: PUSH
35514: FOR_TO
35515: IFFALSE 36079
// begin if not mc_bases [ i ] then
35517: LD_EXP 74
35521: PUSH
35522: LD_VAR 0 2
35526: ARRAY
35527: NOT
35528: IFFALSE 35532
// continue ;
35530: GO 35514
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
35532: LD_ADDR_VAR 0 7
35536: PUSH
35537: LD_EXP 74
35541: PUSH
35542: LD_VAR 0 2
35546: ARRAY
35547: PUSH
35548: LD_INT 1
35550: ARRAY
35551: PPUSH
35552: CALL 53470 0 1
35556: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
35557: LD_ADDR_EXP 97
35561: PUSH
35562: LD_EXP 97
35566: PPUSH
35567: LD_VAR 0 2
35571: PPUSH
35572: LD_EXP 74
35576: PUSH
35577: LD_VAR 0 2
35581: ARRAY
35582: PUSH
35583: LD_INT 1
35585: ARRAY
35586: PPUSH
35587: CALL_OW 255
35591: PPUSH
35592: LD_EXP 99
35596: PUSH
35597: LD_VAR 0 2
35601: ARRAY
35602: PPUSH
35603: CALL 51173 0 2
35607: PPUSH
35608: CALL_OW 1
35612: ST_TO_ADDR
// if not mc_scan [ i ] then
35613: LD_EXP 97
35617: PUSH
35618: LD_VAR 0 2
35622: ARRAY
35623: NOT
35624: IFFALSE 35779
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35626: LD_ADDR_VAR 0 4
35630: PUSH
35631: LD_EXP 74
35635: PUSH
35636: LD_VAR 0 2
35640: ARRAY
35641: PPUSH
35642: LD_INT 2
35644: PUSH
35645: LD_INT 25
35647: PUSH
35648: LD_INT 5
35650: PUSH
35651: EMPTY
35652: LIST
35653: LIST
35654: PUSH
35655: LD_INT 25
35657: PUSH
35658: LD_INT 8
35660: PUSH
35661: EMPTY
35662: LIST
35663: LIST
35664: PUSH
35665: LD_INT 25
35667: PUSH
35668: LD_INT 9
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: PPUSH
35681: CALL_OW 72
35685: ST_TO_ADDR
// if not tmp then
35686: LD_VAR 0 4
35690: NOT
35691: IFFALSE 35695
// continue ;
35693: GO 35514
// for j in tmp do
35695: LD_ADDR_VAR 0 3
35699: PUSH
35700: LD_VAR 0 4
35704: PUSH
35705: FOR_IN
35706: IFFALSE 35777
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
35708: LD_VAR 0 3
35712: PPUSH
35713: CALL_OW 310
35717: PPUSH
35718: CALL_OW 266
35722: PUSH
35723: LD_INT 5
35725: EQUAL
35726: PUSH
35727: LD_VAR 0 3
35731: PPUSH
35732: CALL_OW 257
35736: PUSH
35737: LD_INT 1
35739: EQUAL
35740: AND
35741: PUSH
35742: LD_VAR 0 3
35746: PPUSH
35747: CALL_OW 459
35751: NOT
35752: AND
35753: PUSH
35754: LD_VAR 0 7
35758: AND
35759: IFFALSE 35775
// ComChangeProfession ( j , class ) ;
35761: LD_VAR 0 3
35765: PPUSH
35766: LD_VAR 0 7
35770: PPUSH
35771: CALL_OW 123
35775: GO 35705
35777: POP
35778: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
35779: LD_EXP 97
35783: PUSH
35784: LD_VAR 0 2
35788: ARRAY
35789: PUSH
35790: LD_EXP 96
35794: PUSH
35795: LD_VAR 0 2
35799: ARRAY
35800: NOT
35801: AND
35802: PUSH
35803: LD_EXP 74
35807: PUSH
35808: LD_VAR 0 2
35812: ARRAY
35813: PPUSH
35814: LD_INT 30
35816: PUSH
35817: LD_INT 32
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PPUSH
35824: CALL_OW 72
35828: NOT
35829: AND
35830: PUSH
35831: LD_EXP 74
35835: PUSH
35836: LD_VAR 0 2
35840: ARRAY
35841: PPUSH
35842: LD_INT 2
35844: PUSH
35845: LD_INT 30
35847: PUSH
35848: LD_INT 4
35850: PUSH
35851: EMPTY
35852: LIST
35853: LIST
35854: PUSH
35855: LD_INT 30
35857: PUSH
35858: LD_INT 5
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: EMPTY
35866: LIST
35867: LIST
35868: LIST
35869: PPUSH
35870: CALL_OW 72
35874: NOT
35875: AND
35876: IFFALSE 36008
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35878: LD_ADDR_VAR 0 4
35882: PUSH
35883: LD_EXP 74
35887: PUSH
35888: LD_VAR 0 2
35892: ARRAY
35893: PPUSH
35894: LD_INT 2
35896: PUSH
35897: LD_INT 25
35899: PUSH
35900: LD_INT 1
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: LD_INT 25
35909: PUSH
35910: LD_INT 5
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 25
35919: PUSH
35920: LD_INT 8
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: LD_INT 25
35929: PUSH
35930: LD_INT 9
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: EMPTY
35938: LIST
35939: LIST
35940: LIST
35941: LIST
35942: LIST
35943: PPUSH
35944: CALL_OW 72
35948: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
35949: LD_ADDR_VAR 0 4
35953: PUSH
35954: LD_VAR 0 4
35958: PUSH
35959: LD_VAR 0 4
35963: PPUSH
35964: LD_INT 18
35966: PPUSH
35967: CALL 89894 0 2
35971: DIFF
35972: ST_TO_ADDR
// if tmp then
35973: LD_VAR 0 4
35977: IFFALSE 36008
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
35979: LD_VAR 0 2
35983: PPUSH
35984: LD_VAR 0 4
35988: PPUSH
35989: LD_EXP 99
35993: PUSH
35994: LD_VAR 0 2
35998: ARRAY
35999: PPUSH
36000: CALL 51208 0 3
// exit ;
36004: POP
36005: POP
36006: GO 36081
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36008: LD_EXP 97
36012: PUSH
36013: LD_VAR 0 2
36017: ARRAY
36018: PUSH
36019: LD_EXP 96
36023: PUSH
36024: LD_VAR 0 2
36028: ARRAY
36029: AND
36030: IFFALSE 36077
// begin tmp := mc_defender [ i ] ;
36032: LD_ADDR_VAR 0 4
36036: PUSH
36037: LD_EXP 96
36041: PUSH
36042: LD_VAR 0 2
36046: ARRAY
36047: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36048: LD_VAR 0 2
36052: PPUSH
36053: LD_VAR 0 4
36057: PPUSH
36058: LD_EXP 97
36062: PUSH
36063: LD_VAR 0 2
36067: ARRAY
36068: PPUSH
36069: CALL 51769 0 3
// exit ;
36073: POP
36074: POP
36075: GO 36081
// end ; end ;
36077: GO 35514
36079: POP
36080: POP
// end ;
36081: LD_VAR 0 1
36085: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36086: LD_INT 0
36088: PPUSH
36089: PPUSH
36090: PPUSH
36091: PPUSH
36092: PPUSH
36093: PPUSH
36094: PPUSH
36095: PPUSH
36096: PPUSH
36097: PPUSH
36098: PPUSH
// if not mc_bases then
36099: LD_EXP 74
36103: NOT
36104: IFFALSE 36108
// exit ;
36106: GO 37195
// for i = 1 to mc_bases do
36108: LD_ADDR_VAR 0 2
36112: PUSH
36113: DOUBLE
36114: LD_INT 1
36116: DEC
36117: ST_TO_ADDR
36118: LD_EXP 74
36122: PUSH
36123: FOR_TO
36124: IFFALSE 37193
// begin tmp := mc_lab [ i ] ;
36126: LD_ADDR_VAR 0 6
36130: PUSH
36131: LD_EXP 107
36135: PUSH
36136: LD_VAR 0 2
36140: ARRAY
36141: ST_TO_ADDR
// if not tmp then
36142: LD_VAR 0 6
36146: NOT
36147: IFFALSE 36151
// continue ;
36149: GO 36123
// idle_lab := 0 ;
36151: LD_ADDR_VAR 0 11
36155: PUSH
36156: LD_INT 0
36158: ST_TO_ADDR
// for j in tmp do
36159: LD_ADDR_VAR 0 3
36163: PUSH
36164: LD_VAR 0 6
36168: PUSH
36169: FOR_IN
36170: IFFALSE 37189
// begin researching := false ;
36172: LD_ADDR_VAR 0 10
36176: PUSH
36177: LD_INT 0
36179: ST_TO_ADDR
// side := GetSide ( j ) ;
36180: LD_ADDR_VAR 0 4
36184: PUSH
36185: LD_VAR 0 3
36189: PPUSH
36190: CALL_OW 255
36194: ST_TO_ADDR
// if not mc_tech [ side ] then
36195: LD_EXP 101
36199: PUSH
36200: LD_VAR 0 4
36204: ARRAY
36205: NOT
36206: IFFALSE 36210
// continue ;
36208: GO 36169
// if BuildingStatus ( j ) = bs_idle then
36210: LD_VAR 0 3
36214: PPUSH
36215: CALL_OW 461
36219: PUSH
36220: LD_INT 2
36222: EQUAL
36223: IFFALSE 36411
// begin if idle_lab and UnitsInside ( j ) < 6 then
36225: LD_VAR 0 11
36229: PUSH
36230: LD_VAR 0 3
36234: PPUSH
36235: CALL_OW 313
36239: PUSH
36240: LD_INT 6
36242: LESS
36243: AND
36244: IFFALSE 36315
// begin tmp2 := UnitsInside ( idle_lab ) ;
36246: LD_ADDR_VAR 0 9
36250: PUSH
36251: LD_VAR 0 11
36255: PPUSH
36256: CALL_OW 313
36260: ST_TO_ADDR
// if tmp2 then
36261: LD_VAR 0 9
36265: IFFALSE 36307
// for x in tmp2 do
36267: LD_ADDR_VAR 0 7
36271: PUSH
36272: LD_VAR 0 9
36276: PUSH
36277: FOR_IN
36278: IFFALSE 36305
// begin ComExitBuilding ( x ) ;
36280: LD_VAR 0 7
36284: PPUSH
36285: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36289: LD_VAR 0 7
36293: PPUSH
36294: LD_VAR 0 3
36298: PPUSH
36299: CALL_OW 180
// end ;
36303: GO 36277
36305: POP
36306: POP
// idle_lab := 0 ;
36307: LD_ADDR_VAR 0 11
36311: PUSH
36312: LD_INT 0
36314: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36315: LD_ADDR_VAR 0 5
36319: PUSH
36320: LD_EXP 101
36324: PUSH
36325: LD_VAR 0 4
36329: ARRAY
36330: PUSH
36331: FOR_IN
36332: IFFALSE 36392
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36334: LD_VAR 0 3
36338: PPUSH
36339: LD_VAR 0 5
36343: PPUSH
36344: CALL_OW 430
36348: PUSH
36349: LD_VAR 0 4
36353: PPUSH
36354: LD_VAR 0 5
36358: PPUSH
36359: CALL 50278 0 2
36363: AND
36364: IFFALSE 36390
// begin researching := true ;
36366: LD_ADDR_VAR 0 10
36370: PUSH
36371: LD_INT 1
36373: ST_TO_ADDR
// ComResearch ( j , t ) ;
36374: LD_VAR 0 3
36378: PPUSH
36379: LD_VAR 0 5
36383: PPUSH
36384: CALL_OW 124
// break ;
36388: GO 36392
// end ;
36390: GO 36331
36392: POP
36393: POP
// if not researching then
36394: LD_VAR 0 10
36398: NOT
36399: IFFALSE 36411
// idle_lab := j ;
36401: LD_ADDR_VAR 0 11
36405: PUSH
36406: LD_VAR 0 3
36410: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36411: LD_VAR 0 3
36415: PPUSH
36416: CALL_OW 461
36420: PUSH
36421: LD_INT 10
36423: EQUAL
36424: IFFALSE 37012
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36426: LD_EXP 103
36430: PUSH
36431: LD_VAR 0 2
36435: ARRAY
36436: NOT
36437: PUSH
36438: LD_EXP 104
36442: PUSH
36443: LD_VAR 0 2
36447: ARRAY
36448: NOT
36449: AND
36450: PUSH
36451: LD_EXP 101
36455: PUSH
36456: LD_VAR 0 4
36460: ARRAY
36461: PUSH
36462: LD_INT 1
36464: GREATER
36465: AND
36466: IFFALSE 36597
// begin ComCancel ( j ) ;
36468: LD_VAR 0 3
36472: PPUSH
36473: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36477: LD_ADDR_EXP 101
36481: PUSH
36482: LD_EXP 101
36486: PPUSH
36487: LD_VAR 0 4
36491: PPUSH
36492: LD_EXP 101
36496: PUSH
36497: LD_VAR 0 4
36501: ARRAY
36502: PPUSH
36503: LD_EXP 101
36507: PUSH
36508: LD_VAR 0 4
36512: ARRAY
36513: PUSH
36514: LD_INT 1
36516: MINUS
36517: PPUSH
36518: LD_EXP 101
36522: PUSH
36523: LD_VAR 0 4
36527: ARRAY
36528: PPUSH
36529: LD_INT 0
36531: PPUSH
36532: CALL 56052 0 4
36536: PPUSH
36537: CALL_OW 1
36541: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
36542: LD_ADDR_EXP 101
36546: PUSH
36547: LD_EXP 101
36551: PPUSH
36552: LD_VAR 0 4
36556: PPUSH
36557: LD_EXP 101
36561: PUSH
36562: LD_VAR 0 4
36566: ARRAY
36567: PPUSH
36568: LD_EXP 101
36572: PUSH
36573: LD_VAR 0 4
36577: ARRAY
36578: PPUSH
36579: LD_INT 1
36581: PPUSH
36582: LD_INT 0
36584: PPUSH
36585: CALL 56052 0 4
36589: PPUSH
36590: CALL_OW 1
36594: ST_TO_ADDR
// continue ;
36595: GO 36169
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
36597: LD_EXP 103
36601: PUSH
36602: LD_VAR 0 2
36606: ARRAY
36607: PUSH
36608: LD_EXP 104
36612: PUSH
36613: LD_VAR 0 2
36617: ARRAY
36618: NOT
36619: AND
36620: IFFALSE 36747
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
36622: LD_ADDR_EXP 104
36626: PUSH
36627: LD_EXP 104
36631: PPUSH
36632: LD_VAR 0 2
36636: PUSH
36637: LD_EXP 104
36641: PUSH
36642: LD_VAR 0 2
36646: ARRAY
36647: PUSH
36648: LD_INT 1
36650: PLUS
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PPUSH
36656: LD_EXP 103
36660: PUSH
36661: LD_VAR 0 2
36665: ARRAY
36666: PUSH
36667: LD_INT 1
36669: ARRAY
36670: PPUSH
36671: CALL 56634 0 3
36675: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
36676: LD_EXP 103
36680: PUSH
36681: LD_VAR 0 2
36685: ARRAY
36686: PUSH
36687: LD_INT 1
36689: ARRAY
36690: PPUSH
36691: LD_INT 112
36693: PPUSH
36694: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
36698: LD_ADDR_VAR 0 9
36702: PUSH
36703: LD_EXP 103
36707: PUSH
36708: LD_VAR 0 2
36712: ARRAY
36713: PPUSH
36714: LD_INT 1
36716: PPUSH
36717: CALL_OW 3
36721: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
36722: LD_ADDR_EXP 103
36726: PUSH
36727: LD_EXP 103
36731: PPUSH
36732: LD_VAR 0 2
36736: PPUSH
36737: LD_VAR 0 9
36741: PPUSH
36742: CALL_OW 1
36746: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
36747: LD_EXP 103
36751: PUSH
36752: LD_VAR 0 2
36756: ARRAY
36757: PUSH
36758: LD_EXP 104
36762: PUSH
36763: LD_VAR 0 2
36767: ARRAY
36768: AND
36769: PUSH
36770: LD_EXP 104
36774: PUSH
36775: LD_VAR 0 2
36779: ARRAY
36780: PUSH
36781: LD_INT 1
36783: ARRAY
36784: PPUSH
36785: CALL_OW 310
36789: NOT
36790: AND
36791: PUSH
36792: LD_VAR 0 3
36796: PPUSH
36797: CALL_OW 313
36801: PUSH
36802: LD_INT 6
36804: EQUAL
36805: AND
36806: IFFALSE 36862
// begin tmp2 := UnitsInside ( j ) ;
36808: LD_ADDR_VAR 0 9
36812: PUSH
36813: LD_VAR 0 3
36817: PPUSH
36818: CALL_OW 313
36822: ST_TO_ADDR
// if tmp2 = 6 then
36823: LD_VAR 0 9
36827: PUSH
36828: LD_INT 6
36830: EQUAL
36831: IFFALSE 36862
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
36833: LD_VAR 0 9
36837: PUSH
36838: LD_INT 1
36840: ARRAY
36841: PPUSH
36842: LD_INT 112
36844: PPUSH
36845: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
36849: LD_VAR 0 9
36853: PUSH
36854: LD_INT 1
36856: ARRAY
36857: PPUSH
36858: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
36862: LD_EXP 104
36866: PUSH
36867: LD_VAR 0 2
36871: ARRAY
36872: PUSH
36873: LD_EXP 104
36877: PUSH
36878: LD_VAR 0 2
36882: ARRAY
36883: PUSH
36884: LD_INT 1
36886: ARRAY
36887: PPUSH
36888: CALL_OW 314
36892: NOT
36893: AND
36894: PUSH
36895: LD_EXP 104
36899: PUSH
36900: LD_VAR 0 2
36904: ARRAY
36905: PUSH
36906: LD_INT 1
36908: ARRAY
36909: PPUSH
36910: CALL_OW 310
36914: NOT
36915: AND
36916: IFFALSE 36942
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36918: LD_EXP 104
36922: PUSH
36923: LD_VAR 0 2
36927: ARRAY
36928: PUSH
36929: LD_INT 1
36931: ARRAY
36932: PPUSH
36933: LD_VAR 0 3
36937: PPUSH
36938: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36942: LD_EXP 104
36946: PUSH
36947: LD_VAR 0 2
36951: ARRAY
36952: PUSH
36953: LD_INT 1
36955: ARRAY
36956: PPUSH
36957: CALL_OW 310
36961: PUSH
36962: LD_EXP 104
36966: PUSH
36967: LD_VAR 0 2
36971: ARRAY
36972: PUSH
36973: LD_INT 1
36975: ARRAY
36976: PPUSH
36977: CALL_OW 310
36981: PPUSH
36982: CALL_OW 461
36986: PUSH
36987: LD_INT 3
36989: NONEQUAL
36990: AND
36991: IFFALSE 37012
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36993: LD_EXP 104
36997: PUSH
36998: LD_VAR 0 2
37002: ARRAY
37003: PUSH
37004: LD_INT 1
37006: ARRAY
37007: PPUSH
37008: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37012: LD_VAR 0 3
37016: PPUSH
37017: CALL_OW 461
37021: PUSH
37022: LD_INT 6
37024: EQUAL
37025: PUSH
37026: LD_VAR 0 6
37030: PUSH
37031: LD_INT 1
37033: GREATER
37034: AND
37035: IFFALSE 37187
// begin sci := [ ] ;
37037: LD_ADDR_VAR 0 8
37041: PUSH
37042: EMPTY
37043: ST_TO_ADDR
// for x in ( tmp diff j ) do
37044: LD_ADDR_VAR 0 7
37048: PUSH
37049: LD_VAR 0 6
37053: PUSH
37054: LD_VAR 0 3
37058: DIFF
37059: PUSH
37060: FOR_IN
37061: IFFALSE 37113
// begin if sci = 6 then
37063: LD_VAR 0 8
37067: PUSH
37068: LD_INT 6
37070: EQUAL
37071: IFFALSE 37075
// break ;
37073: GO 37113
// if BuildingStatus ( x ) = bs_idle then
37075: LD_VAR 0 7
37079: PPUSH
37080: CALL_OW 461
37084: PUSH
37085: LD_INT 2
37087: EQUAL
37088: IFFALSE 37111
// sci := sci ^ UnitsInside ( x ) ;
37090: LD_ADDR_VAR 0 8
37094: PUSH
37095: LD_VAR 0 8
37099: PUSH
37100: LD_VAR 0 7
37104: PPUSH
37105: CALL_OW 313
37109: ADD
37110: ST_TO_ADDR
// end ;
37111: GO 37060
37113: POP
37114: POP
// if not sci then
37115: LD_VAR 0 8
37119: NOT
37120: IFFALSE 37124
// continue ;
37122: GO 36169
// for x in sci do
37124: LD_ADDR_VAR 0 7
37128: PUSH
37129: LD_VAR 0 8
37133: PUSH
37134: FOR_IN
37135: IFFALSE 37185
// if IsInUnit ( x ) and not HasTask ( x ) then
37137: LD_VAR 0 7
37141: PPUSH
37142: CALL_OW 310
37146: PUSH
37147: LD_VAR 0 7
37151: PPUSH
37152: CALL_OW 314
37156: NOT
37157: AND
37158: IFFALSE 37183
// begin ComExitBuilding ( x ) ;
37160: LD_VAR 0 7
37164: PPUSH
37165: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37169: LD_VAR 0 7
37173: PPUSH
37174: LD_VAR 0 3
37178: PPUSH
37179: CALL_OW 180
// end ;
37183: GO 37134
37185: POP
37186: POP
// end ; end ;
37187: GO 36169
37189: POP
37190: POP
// end ;
37191: GO 36123
37193: POP
37194: POP
// end ;
37195: LD_VAR 0 1
37199: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37200: LD_INT 0
37202: PPUSH
37203: PPUSH
// if not mc_bases then
37204: LD_EXP 74
37208: NOT
37209: IFFALSE 37213
// exit ;
37211: GO 37294
// for i = 1 to mc_bases do
37213: LD_ADDR_VAR 0 2
37217: PUSH
37218: DOUBLE
37219: LD_INT 1
37221: DEC
37222: ST_TO_ADDR
37223: LD_EXP 74
37227: PUSH
37228: FOR_TO
37229: IFFALSE 37292
// if mc_mines [ i ] and mc_miners [ i ] then
37231: LD_EXP 87
37235: PUSH
37236: LD_VAR 0 2
37240: ARRAY
37241: PUSH
37242: LD_EXP 88
37246: PUSH
37247: LD_VAR 0 2
37251: ARRAY
37252: AND
37253: IFFALSE 37290
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37255: LD_EXP 88
37259: PUSH
37260: LD_VAR 0 2
37264: ARRAY
37265: PUSH
37266: LD_INT 1
37268: ARRAY
37269: PPUSH
37270: CALL_OW 255
37274: PPUSH
37275: LD_EXP 87
37279: PUSH
37280: LD_VAR 0 2
37284: ARRAY
37285: PPUSH
37286: CALL 53623 0 2
37290: GO 37228
37292: POP
37293: POP
// end ;
37294: LD_VAR 0 1
37298: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37299: LD_INT 0
37301: PPUSH
37302: PPUSH
37303: PPUSH
37304: PPUSH
37305: PPUSH
37306: PPUSH
37307: PPUSH
37308: PPUSH
// if not mc_bases or not mc_parking then
37309: LD_EXP 74
37313: NOT
37314: PUSH
37315: LD_EXP 98
37319: NOT
37320: OR
37321: IFFALSE 37325
// exit ;
37323: GO 38024
// for i = 1 to mc_bases do
37325: LD_ADDR_VAR 0 2
37329: PUSH
37330: DOUBLE
37331: LD_INT 1
37333: DEC
37334: ST_TO_ADDR
37335: LD_EXP 74
37339: PUSH
37340: FOR_TO
37341: IFFALSE 38022
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37343: LD_EXP 74
37347: PUSH
37348: LD_VAR 0 2
37352: ARRAY
37353: NOT
37354: PUSH
37355: LD_EXP 98
37359: PUSH
37360: LD_VAR 0 2
37364: ARRAY
37365: NOT
37366: OR
37367: IFFALSE 37371
// continue ;
37369: GO 37340
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37371: LD_ADDR_VAR 0 5
37375: PUSH
37376: LD_EXP 74
37380: PUSH
37381: LD_VAR 0 2
37385: ARRAY
37386: PUSH
37387: LD_INT 1
37389: ARRAY
37390: PPUSH
37391: CALL_OW 255
37395: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37396: LD_ADDR_VAR 0 6
37400: PUSH
37401: LD_EXP 74
37405: PUSH
37406: LD_VAR 0 2
37410: ARRAY
37411: PPUSH
37412: LD_INT 30
37414: PUSH
37415: LD_INT 3
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PPUSH
37422: CALL_OW 72
37426: ST_TO_ADDR
// if not fac then
37427: LD_VAR 0 6
37431: NOT
37432: IFFALSE 37483
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37434: LD_ADDR_VAR 0 6
37438: PUSH
37439: LD_EXP 74
37443: PUSH
37444: LD_VAR 0 2
37448: ARRAY
37449: PPUSH
37450: LD_INT 2
37452: PUSH
37453: LD_INT 30
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 30
37465: PUSH
37466: LD_INT 1
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: LIST
37477: PPUSH
37478: CALL_OW 72
37482: ST_TO_ADDR
// if not fac then
37483: LD_VAR 0 6
37487: NOT
37488: IFFALSE 37492
// continue ;
37490: GO 37340
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37492: LD_ADDR_VAR 0 7
37496: PUSH
37497: LD_EXP 98
37501: PUSH
37502: LD_VAR 0 2
37506: ARRAY
37507: PPUSH
37508: LD_INT 22
37510: PUSH
37511: LD_VAR 0 5
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 21
37522: PUSH
37523: LD_INT 2
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 3
37532: PUSH
37533: LD_INT 24
37535: PUSH
37536: LD_INT 1000
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: LIST
37551: PPUSH
37552: CALL_OW 70
37556: ST_TO_ADDR
// for j in fac do
37557: LD_ADDR_VAR 0 3
37561: PUSH
37562: LD_VAR 0 6
37566: PUSH
37567: FOR_IN
37568: IFFALSE 37649
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37570: LD_ADDR_VAR 0 7
37574: PUSH
37575: LD_VAR 0 7
37579: PUSH
37580: LD_INT 22
37582: PUSH
37583: LD_VAR 0 5
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 91
37594: PUSH
37595: LD_VAR 0 3
37599: PUSH
37600: LD_INT 15
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 21
37610: PUSH
37611: LD_INT 2
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 3
37620: PUSH
37621: LD_INT 24
37623: PUSH
37624: LD_INT 1000
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: PPUSH
37641: CALL_OW 69
37645: UNION
37646: ST_TO_ADDR
37647: GO 37567
37649: POP
37650: POP
// if not vehs then
37651: LD_VAR 0 7
37655: NOT
37656: IFFALSE 37682
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37658: LD_ADDR_EXP 86
37662: PUSH
37663: LD_EXP 86
37667: PPUSH
37668: LD_VAR 0 2
37672: PPUSH
37673: EMPTY
37674: PPUSH
37675: CALL_OW 1
37679: ST_TO_ADDR
// continue ;
37680: GO 37340
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37682: LD_ADDR_VAR 0 8
37686: PUSH
37687: LD_EXP 74
37691: PUSH
37692: LD_VAR 0 2
37696: ARRAY
37697: PPUSH
37698: LD_INT 30
37700: PUSH
37701: LD_INT 3
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PPUSH
37708: CALL_OW 72
37712: ST_TO_ADDR
// if tmp then
37713: LD_VAR 0 8
37717: IFFALSE 37820
// begin for j in tmp do
37719: LD_ADDR_VAR 0 3
37723: PUSH
37724: LD_VAR 0 8
37728: PUSH
37729: FOR_IN
37730: IFFALSE 37818
// for k in UnitsInside ( j ) do
37732: LD_ADDR_VAR 0 4
37736: PUSH
37737: LD_VAR 0 3
37741: PPUSH
37742: CALL_OW 313
37746: PUSH
37747: FOR_IN
37748: IFFALSE 37814
// if k then
37750: LD_VAR 0 4
37754: IFFALSE 37812
// if not k in mc_repair_vehicle [ i ] then
37756: LD_VAR 0 4
37760: PUSH
37761: LD_EXP 86
37765: PUSH
37766: LD_VAR 0 2
37770: ARRAY
37771: IN
37772: NOT
37773: IFFALSE 37812
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
37775: LD_ADDR_EXP 86
37779: PUSH
37780: LD_EXP 86
37784: PPUSH
37785: LD_VAR 0 2
37789: PPUSH
37790: LD_EXP 86
37794: PUSH
37795: LD_VAR 0 2
37799: ARRAY
37800: PUSH
37801: LD_VAR 0 4
37805: UNION
37806: PPUSH
37807: CALL_OW 1
37811: ST_TO_ADDR
37812: GO 37747
37814: POP
37815: POP
37816: GO 37729
37818: POP
37819: POP
// end ; if not mc_repair_vehicle [ i ] then
37820: LD_EXP 86
37824: PUSH
37825: LD_VAR 0 2
37829: ARRAY
37830: NOT
37831: IFFALSE 37835
// continue ;
37833: GO 37340
// for j in mc_repair_vehicle [ i ] do
37835: LD_ADDR_VAR 0 3
37839: PUSH
37840: LD_EXP 86
37844: PUSH
37845: LD_VAR 0 2
37849: ARRAY
37850: PUSH
37851: FOR_IN
37852: IFFALSE 38018
// begin if GetClass ( j ) <> 3 then
37854: LD_VAR 0 3
37858: PPUSH
37859: CALL_OW 257
37863: PUSH
37864: LD_INT 3
37866: NONEQUAL
37867: IFFALSE 37908
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37869: LD_ADDR_EXP 86
37873: PUSH
37874: LD_EXP 86
37878: PPUSH
37879: LD_VAR 0 2
37883: PPUSH
37884: LD_EXP 86
37888: PUSH
37889: LD_VAR 0 2
37893: ARRAY
37894: PUSH
37895: LD_VAR 0 3
37899: DIFF
37900: PPUSH
37901: CALL_OW 1
37905: ST_TO_ADDR
// continue ;
37906: GO 37851
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37908: LD_VAR 0 3
37912: PPUSH
37913: CALL_OW 311
37917: NOT
37918: PUSH
37919: LD_VAR 0 3
37923: PUSH
37924: LD_EXP 77
37928: PUSH
37929: LD_VAR 0 2
37933: ARRAY
37934: PUSH
37935: LD_INT 1
37937: ARRAY
37938: IN
37939: NOT
37940: AND
37941: PUSH
37942: LD_VAR 0 3
37946: PUSH
37947: LD_EXP 77
37951: PUSH
37952: LD_VAR 0 2
37956: ARRAY
37957: PUSH
37958: LD_INT 2
37960: ARRAY
37961: IN
37962: NOT
37963: AND
37964: IFFALSE 38016
// begin if IsInUnit ( j ) then
37966: LD_VAR 0 3
37970: PPUSH
37971: CALL_OW 310
37975: IFFALSE 37986
// ComExitBuilding ( j ) ;
37977: LD_VAR 0 3
37981: PPUSH
37982: CALL_OW 122
// if not HasTask ( j ) then
37986: LD_VAR 0 3
37990: PPUSH
37991: CALL_OW 314
37995: NOT
37996: IFFALSE 38016
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
37998: LD_VAR 0 3
38002: PPUSH
38003: LD_VAR 0 7
38007: PUSH
38008: LD_INT 1
38010: ARRAY
38011: PPUSH
38012: CALL_OW 189
// end ; end ;
38016: GO 37851
38018: POP
38019: POP
// end ;
38020: GO 37340
38022: POP
38023: POP
// end ;
38024: LD_VAR 0 1
38028: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38029: LD_INT 0
38031: PPUSH
38032: PPUSH
38033: PPUSH
38034: PPUSH
38035: PPUSH
38036: PPUSH
38037: PPUSH
38038: PPUSH
38039: PPUSH
38040: PPUSH
38041: PPUSH
// if not mc_bases then
38042: LD_EXP 74
38046: NOT
38047: IFFALSE 38051
// exit ;
38049: GO 38853
// for i = 1 to mc_bases do
38051: LD_ADDR_VAR 0 2
38055: PUSH
38056: DOUBLE
38057: LD_INT 1
38059: DEC
38060: ST_TO_ADDR
38061: LD_EXP 74
38065: PUSH
38066: FOR_TO
38067: IFFALSE 38851
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38069: LD_EXP 102
38073: PUSH
38074: LD_VAR 0 2
38078: ARRAY
38079: NOT
38080: PUSH
38081: LD_EXP 77
38085: PUSH
38086: LD_VAR 0 2
38090: ARRAY
38091: PUSH
38092: LD_INT 1
38094: ARRAY
38095: OR
38096: PUSH
38097: LD_EXP 77
38101: PUSH
38102: LD_VAR 0 2
38106: ARRAY
38107: PUSH
38108: LD_INT 2
38110: ARRAY
38111: OR
38112: PUSH
38113: LD_EXP 100
38117: PUSH
38118: LD_VAR 0 2
38122: ARRAY
38123: PPUSH
38124: LD_INT 1
38126: PPUSH
38127: CALL_OW 325
38131: NOT
38132: OR
38133: PUSH
38134: LD_EXP 97
38138: PUSH
38139: LD_VAR 0 2
38143: ARRAY
38144: OR
38145: IFFALSE 38149
// continue ;
38147: GO 38066
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38149: LD_ADDR_VAR 0 8
38153: PUSH
38154: LD_EXP 74
38158: PUSH
38159: LD_VAR 0 2
38163: ARRAY
38164: PPUSH
38165: LD_INT 25
38167: PUSH
38168: LD_INT 4
38170: PUSH
38171: EMPTY
38172: LIST
38173: LIST
38174: PUSH
38175: LD_INT 50
38177: PUSH
38178: EMPTY
38179: LIST
38180: PUSH
38181: LD_INT 3
38183: PUSH
38184: LD_INT 60
38186: PUSH
38187: EMPTY
38188: LIST
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: LIST
38198: PPUSH
38199: CALL_OW 72
38203: PUSH
38204: LD_EXP 78
38208: PUSH
38209: LD_VAR 0 2
38213: ARRAY
38214: DIFF
38215: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38216: LD_ADDR_VAR 0 9
38220: PUSH
38221: LD_EXP 74
38225: PUSH
38226: LD_VAR 0 2
38230: ARRAY
38231: PPUSH
38232: LD_INT 2
38234: PUSH
38235: LD_INT 30
38237: PUSH
38238: LD_INT 0
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: LD_INT 30
38247: PUSH
38248: LD_INT 1
38250: PUSH
38251: EMPTY
38252: LIST
38253: LIST
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: LIST
38259: PPUSH
38260: CALL_OW 72
38264: ST_TO_ADDR
// if not tmp or not dep then
38265: LD_VAR 0 8
38269: NOT
38270: PUSH
38271: LD_VAR 0 9
38275: NOT
38276: OR
38277: IFFALSE 38281
// continue ;
38279: GO 38066
// side := GetSide ( tmp [ 1 ] ) ;
38281: LD_ADDR_VAR 0 11
38285: PUSH
38286: LD_VAR 0 8
38290: PUSH
38291: LD_INT 1
38293: ARRAY
38294: PPUSH
38295: CALL_OW 255
38299: ST_TO_ADDR
// dep := dep [ 1 ] ;
38300: LD_ADDR_VAR 0 9
38304: PUSH
38305: LD_VAR 0 9
38309: PUSH
38310: LD_INT 1
38312: ARRAY
38313: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38314: LD_ADDR_VAR 0 7
38318: PUSH
38319: LD_EXP 102
38323: PUSH
38324: LD_VAR 0 2
38328: ARRAY
38329: PPUSH
38330: LD_INT 22
38332: PUSH
38333: LD_INT 0
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 25
38342: PUSH
38343: LD_INT 12
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PPUSH
38354: CALL_OW 70
38358: PUSH
38359: LD_INT 22
38361: PUSH
38362: LD_INT 0
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 25
38371: PUSH
38372: LD_INT 12
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 91
38381: PUSH
38382: LD_VAR 0 9
38386: PUSH
38387: LD_INT 20
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: LIST
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: LIST
38399: PPUSH
38400: CALL_OW 69
38404: UNION
38405: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38406: LD_ADDR_VAR 0 10
38410: PUSH
38411: LD_EXP 102
38415: PUSH
38416: LD_VAR 0 2
38420: ARRAY
38421: PPUSH
38422: LD_INT 81
38424: PUSH
38425: LD_VAR 0 11
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PPUSH
38434: CALL_OW 70
38438: ST_TO_ADDR
// if not apes or danger_at_area then
38439: LD_VAR 0 7
38443: NOT
38444: PUSH
38445: LD_VAR 0 10
38449: OR
38450: IFFALSE 38500
// begin if mc_taming [ i ] then
38452: LD_EXP 105
38456: PUSH
38457: LD_VAR 0 2
38461: ARRAY
38462: IFFALSE 38498
// begin MC_Reset ( i , 121 ) ;
38464: LD_VAR 0 2
38468: PPUSH
38469: LD_INT 121
38471: PPUSH
38472: CALL 23831 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38476: LD_ADDR_EXP 105
38480: PUSH
38481: LD_EXP 105
38485: PPUSH
38486: LD_VAR 0 2
38490: PPUSH
38491: EMPTY
38492: PPUSH
38493: CALL_OW 1
38497: ST_TO_ADDR
// end ; continue ;
38498: GO 38066
// end ; for j in tmp do
38500: LD_ADDR_VAR 0 3
38504: PUSH
38505: LD_VAR 0 8
38509: PUSH
38510: FOR_IN
38511: IFFALSE 38847
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
38513: LD_VAR 0 3
38517: PUSH
38518: LD_EXP 105
38522: PUSH
38523: LD_VAR 0 2
38527: ARRAY
38528: IN
38529: NOT
38530: PUSH
38531: LD_EXP 105
38535: PUSH
38536: LD_VAR 0 2
38540: ARRAY
38541: PUSH
38542: LD_INT 3
38544: LESS
38545: AND
38546: IFFALSE 38604
// begin SetTag ( j , 121 ) ;
38548: LD_VAR 0 3
38552: PPUSH
38553: LD_INT 121
38555: PPUSH
38556: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
38560: LD_ADDR_EXP 105
38564: PUSH
38565: LD_EXP 105
38569: PPUSH
38570: LD_VAR 0 2
38574: PUSH
38575: LD_EXP 105
38579: PUSH
38580: LD_VAR 0 2
38584: ARRAY
38585: PUSH
38586: LD_INT 1
38588: PLUS
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PPUSH
38594: LD_VAR 0 3
38598: PPUSH
38599: CALL 56634 0 3
38603: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
38604: LD_VAR 0 3
38608: PUSH
38609: LD_EXP 105
38613: PUSH
38614: LD_VAR 0 2
38618: ARRAY
38619: IN
38620: IFFALSE 38845
// begin if GetClass ( j ) <> 4 then
38622: LD_VAR 0 3
38626: PPUSH
38627: CALL_OW 257
38631: PUSH
38632: LD_INT 4
38634: NONEQUAL
38635: IFFALSE 38688
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
38637: LD_ADDR_EXP 105
38641: PUSH
38642: LD_EXP 105
38646: PPUSH
38647: LD_VAR 0 2
38651: PPUSH
38652: LD_EXP 105
38656: PUSH
38657: LD_VAR 0 2
38661: ARRAY
38662: PUSH
38663: LD_VAR 0 3
38667: DIFF
38668: PPUSH
38669: CALL_OW 1
38673: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38674: LD_VAR 0 3
38678: PPUSH
38679: LD_INT 0
38681: PPUSH
38682: CALL_OW 109
// continue ;
38686: GO 38510
// end ; if IsInUnit ( j ) then
38688: LD_VAR 0 3
38692: PPUSH
38693: CALL_OW 310
38697: IFFALSE 38708
// ComExitBuilding ( j ) ;
38699: LD_VAR 0 3
38703: PPUSH
38704: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
38708: LD_ADDR_VAR 0 6
38712: PUSH
38713: LD_VAR 0 7
38717: PPUSH
38718: LD_VAR 0 3
38722: PPUSH
38723: CALL_OW 74
38727: ST_TO_ADDR
// if not ape then
38728: LD_VAR 0 6
38732: NOT
38733: IFFALSE 38737
// break ;
38735: GO 38847
// x := GetX ( ape ) ;
38737: LD_ADDR_VAR 0 4
38741: PUSH
38742: LD_VAR 0 6
38746: PPUSH
38747: CALL_OW 250
38751: ST_TO_ADDR
// y := GetY ( ape ) ;
38752: LD_ADDR_VAR 0 5
38756: PUSH
38757: LD_VAR 0 6
38761: PPUSH
38762: CALL_OW 251
38766: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
38767: LD_VAR 0 4
38771: PPUSH
38772: LD_VAR 0 5
38776: PPUSH
38777: CALL_OW 488
38781: NOT
38782: PUSH
38783: LD_VAR 0 11
38787: PPUSH
38788: LD_VAR 0 4
38792: PPUSH
38793: LD_VAR 0 5
38797: PPUSH
38798: LD_INT 20
38800: PPUSH
38801: CALL 57530 0 4
38805: PUSH
38806: LD_INT 4
38808: ARRAY
38809: OR
38810: IFFALSE 38814
// break ;
38812: GO 38847
// if not HasTask ( j ) then
38814: LD_VAR 0 3
38818: PPUSH
38819: CALL_OW 314
38823: NOT
38824: IFFALSE 38845
// ComTameXY ( j , x , y ) ;
38826: LD_VAR 0 3
38830: PPUSH
38831: LD_VAR 0 4
38835: PPUSH
38836: LD_VAR 0 5
38840: PPUSH
38841: CALL_OW 131
// end ; end ;
38845: GO 38510
38847: POP
38848: POP
// end ;
38849: GO 38066
38851: POP
38852: POP
// end ;
38853: LD_VAR 0 1
38857: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38858: LD_INT 0
38860: PPUSH
38861: PPUSH
38862: PPUSH
38863: PPUSH
38864: PPUSH
38865: PPUSH
38866: PPUSH
38867: PPUSH
// if not mc_bases then
38868: LD_EXP 74
38872: NOT
38873: IFFALSE 38877
// exit ;
38875: GO 39503
// for i = 1 to mc_bases do
38877: LD_ADDR_VAR 0 2
38881: PUSH
38882: DOUBLE
38883: LD_INT 1
38885: DEC
38886: ST_TO_ADDR
38887: LD_EXP 74
38891: PUSH
38892: FOR_TO
38893: IFFALSE 39501
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38895: LD_EXP 103
38899: PUSH
38900: LD_VAR 0 2
38904: ARRAY
38905: NOT
38906: PUSH
38907: LD_EXP 103
38911: PUSH
38912: LD_VAR 0 2
38916: ARRAY
38917: PPUSH
38918: LD_INT 25
38920: PUSH
38921: LD_INT 12
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PPUSH
38928: CALL_OW 72
38932: NOT
38933: OR
38934: IFFALSE 38938
// continue ;
38936: GO 38892
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38938: LD_ADDR_VAR 0 5
38942: PUSH
38943: LD_EXP 103
38947: PUSH
38948: LD_VAR 0 2
38952: ARRAY
38953: PUSH
38954: LD_INT 1
38956: ARRAY
38957: PPUSH
38958: CALL_OW 255
38962: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38963: LD_VAR 0 5
38967: PPUSH
38968: LD_INT 2
38970: PPUSH
38971: CALL_OW 325
38975: IFFALSE 39228
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38977: LD_ADDR_VAR 0 4
38981: PUSH
38982: LD_EXP 103
38986: PUSH
38987: LD_VAR 0 2
38991: ARRAY
38992: PPUSH
38993: LD_INT 25
38995: PUSH
38996: LD_INT 16
38998: PUSH
38999: EMPTY
39000: LIST
39001: LIST
39002: PPUSH
39003: CALL_OW 72
39007: ST_TO_ADDR
// if tmp < 6 then
39008: LD_VAR 0 4
39012: PUSH
39013: LD_INT 6
39015: LESS
39016: IFFALSE 39228
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39018: LD_ADDR_VAR 0 6
39022: PUSH
39023: LD_EXP 74
39027: PUSH
39028: LD_VAR 0 2
39032: ARRAY
39033: PPUSH
39034: LD_INT 2
39036: PUSH
39037: LD_INT 30
39039: PUSH
39040: LD_INT 0
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: LD_INT 30
39049: PUSH
39050: LD_INT 1
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: LIST
39061: PPUSH
39062: CALL_OW 72
39066: ST_TO_ADDR
// if depot then
39067: LD_VAR 0 6
39071: IFFALSE 39228
// begin selected := 0 ;
39073: LD_ADDR_VAR 0 7
39077: PUSH
39078: LD_INT 0
39080: ST_TO_ADDR
// for j in depot do
39081: LD_ADDR_VAR 0 3
39085: PUSH
39086: LD_VAR 0 6
39090: PUSH
39091: FOR_IN
39092: IFFALSE 39123
// begin if UnitsInside ( j ) < 6 then
39094: LD_VAR 0 3
39098: PPUSH
39099: CALL_OW 313
39103: PUSH
39104: LD_INT 6
39106: LESS
39107: IFFALSE 39121
// begin selected := j ;
39109: LD_ADDR_VAR 0 7
39113: PUSH
39114: LD_VAR 0 3
39118: ST_TO_ADDR
// break ;
39119: GO 39123
// end ; end ;
39121: GO 39091
39123: POP
39124: POP
// if selected then
39125: LD_VAR 0 7
39129: IFFALSE 39228
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39131: LD_ADDR_VAR 0 3
39135: PUSH
39136: LD_EXP 103
39140: PUSH
39141: LD_VAR 0 2
39145: ARRAY
39146: PPUSH
39147: LD_INT 25
39149: PUSH
39150: LD_INT 12
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PPUSH
39157: CALL_OW 72
39161: PUSH
39162: FOR_IN
39163: IFFALSE 39226
// if not HasTask ( j ) then
39165: LD_VAR 0 3
39169: PPUSH
39170: CALL_OW 314
39174: NOT
39175: IFFALSE 39224
// begin if not IsInUnit ( j ) then
39177: LD_VAR 0 3
39181: PPUSH
39182: CALL_OW 310
39186: NOT
39187: IFFALSE 39203
// ComEnterUnit ( j , selected ) ;
39189: LD_VAR 0 3
39193: PPUSH
39194: LD_VAR 0 7
39198: PPUSH
39199: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39203: LD_VAR 0 3
39207: PPUSH
39208: LD_INT 16
39210: PPUSH
39211: CALL_OW 183
// AddComExitBuilding ( j ) ;
39215: LD_VAR 0 3
39219: PPUSH
39220: CALL_OW 182
// end ;
39224: GO 39162
39226: POP
39227: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39228: LD_VAR 0 5
39232: PPUSH
39233: LD_INT 11
39235: PPUSH
39236: CALL_OW 325
39240: IFFALSE 39499
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39242: LD_ADDR_VAR 0 4
39246: PUSH
39247: LD_EXP 103
39251: PUSH
39252: LD_VAR 0 2
39256: ARRAY
39257: PPUSH
39258: LD_INT 25
39260: PUSH
39261: LD_INT 16
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PPUSH
39268: CALL_OW 72
39272: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39273: LD_VAR 0 4
39277: PUSH
39278: LD_INT 6
39280: GREATEREQUAL
39281: PUSH
39282: LD_VAR 0 5
39286: PPUSH
39287: LD_INT 2
39289: PPUSH
39290: CALL_OW 325
39294: NOT
39295: OR
39296: IFFALSE 39499
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39298: LD_ADDR_VAR 0 8
39302: PUSH
39303: LD_EXP 74
39307: PUSH
39308: LD_VAR 0 2
39312: ARRAY
39313: PPUSH
39314: LD_INT 2
39316: PUSH
39317: LD_INT 30
39319: PUSH
39320: LD_INT 4
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: PUSH
39327: LD_INT 30
39329: PUSH
39330: LD_INT 5
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: LIST
39341: PPUSH
39342: CALL_OW 72
39346: ST_TO_ADDR
// if barracks then
39347: LD_VAR 0 8
39351: IFFALSE 39499
// begin selected := 0 ;
39353: LD_ADDR_VAR 0 7
39357: PUSH
39358: LD_INT 0
39360: ST_TO_ADDR
// for j in barracks do
39361: LD_ADDR_VAR 0 3
39365: PUSH
39366: LD_VAR 0 8
39370: PUSH
39371: FOR_IN
39372: IFFALSE 39403
// begin if UnitsInside ( j ) < 6 then
39374: LD_VAR 0 3
39378: PPUSH
39379: CALL_OW 313
39383: PUSH
39384: LD_INT 6
39386: LESS
39387: IFFALSE 39401
// begin selected := j ;
39389: LD_ADDR_VAR 0 7
39393: PUSH
39394: LD_VAR 0 3
39398: ST_TO_ADDR
// break ;
39399: GO 39403
// end ; end ;
39401: GO 39371
39403: POP
39404: POP
// if selected then
39405: LD_VAR 0 7
39409: IFFALSE 39499
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39411: LD_ADDR_VAR 0 3
39415: PUSH
39416: LD_EXP 103
39420: PUSH
39421: LD_VAR 0 2
39425: ARRAY
39426: PPUSH
39427: LD_INT 25
39429: PUSH
39430: LD_INT 12
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PPUSH
39437: CALL_OW 72
39441: PUSH
39442: FOR_IN
39443: IFFALSE 39497
// if not IsInUnit ( j ) and not HasTask ( j ) then
39445: LD_VAR 0 3
39449: PPUSH
39450: CALL_OW 310
39454: NOT
39455: PUSH
39456: LD_VAR 0 3
39460: PPUSH
39461: CALL_OW 314
39465: NOT
39466: AND
39467: IFFALSE 39495
// begin ComEnterUnit ( j , selected ) ;
39469: LD_VAR 0 3
39473: PPUSH
39474: LD_VAR 0 7
39478: PPUSH
39479: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39483: LD_VAR 0 3
39487: PPUSH
39488: LD_INT 15
39490: PPUSH
39491: CALL_OW 183
// end ;
39495: GO 39442
39497: POP
39498: POP
// end ; end ; end ; end ; end ;
39499: GO 38892
39501: POP
39502: POP
// end ;
39503: LD_VAR 0 1
39507: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
39508: LD_INT 0
39510: PPUSH
39511: PPUSH
39512: PPUSH
39513: PPUSH
// if not mc_bases then
39514: LD_EXP 74
39518: NOT
39519: IFFALSE 39523
// exit ;
39521: GO 39701
// for i = 1 to mc_bases do
39523: LD_ADDR_VAR 0 2
39527: PUSH
39528: DOUBLE
39529: LD_INT 1
39531: DEC
39532: ST_TO_ADDR
39533: LD_EXP 74
39537: PUSH
39538: FOR_TO
39539: IFFALSE 39699
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
39541: LD_ADDR_VAR 0 4
39545: PUSH
39546: LD_EXP 74
39550: PUSH
39551: LD_VAR 0 2
39555: ARRAY
39556: PPUSH
39557: LD_INT 25
39559: PUSH
39560: LD_INT 9
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PPUSH
39567: CALL_OW 72
39571: ST_TO_ADDR
// if not tmp then
39572: LD_VAR 0 4
39576: NOT
39577: IFFALSE 39581
// continue ;
39579: GO 39538
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
39581: LD_EXP 100
39585: PUSH
39586: LD_VAR 0 2
39590: ARRAY
39591: PPUSH
39592: LD_INT 29
39594: PPUSH
39595: CALL_OW 325
39599: NOT
39600: PUSH
39601: LD_EXP 100
39605: PUSH
39606: LD_VAR 0 2
39610: ARRAY
39611: PPUSH
39612: LD_INT 28
39614: PPUSH
39615: CALL_OW 325
39619: NOT
39620: AND
39621: IFFALSE 39625
// continue ;
39623: GO 39538
// for j in tmp do
39625: LD_ADDR_VAR 0 3
39629: PUSH
39630: LD_VAR 0 4
39634: PUSH
39635: FOR_IN
39636: IFFALSE 39695
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39638: LD_VAR 0 3
39642: PUSH
39643: LD_EXP 77
39647: PUSH
39648: LD_VAR 0 2
39652: ARRAY
39653: PUSH
39654: LD_INT 1
39656: ARRAY
39657: IN
39658: NOT
39659: PUSH
39660: LD_VAR 0 3
39664: PUSH
39665: LD_EXP 77
39669: PUSH
39670: LD_VAR 0 2
39674: ARRAY
39675: PUSH
39676: LD_INT 2
39678: ARRAY
39679: IN
39680: NOT
39681: AND
39682: IFFALSE 39693
// ComSpaceTimeShoot ( j ) ;
39684: LD_VAR 0 3
39688: PPUSH
39689: CALL 50369 0 1
39693: GO 39635
39695: POP
39696: POP
// end ;
39697: GO 39538
39699: POP
39700: POP
// end ;
39701: LD_VAR 0 1
39705: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
39706: LD_INT 0
39708: PPUSH
39709: PPUSH
39710: PPUSH
39711: PPUSH
39712: PPUSH
39713: PPUSH
39714: PPUSH
39715: PPUSH
39716: PPUSH
// if not mc_bases then
39717: LD_EXP 74
39721: NOT
39722: IFFALSE 39726
// exit ;
39724: GO 40348
// for i = 1 to mc_bases do
39726: LD_ADDR_VAR 0 2
39730: PUSH
39731: DOUBLE
39732: LD_INT 1
39734: DEC
39735: ST_TO_ADDR
39736: LD_EXP 74
39740: PUSH
39741: FOR_TO
39742: IFFALSE 40346
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
39744: LD_EXP 109
39748: PUSH
39749: LD_VAR 0 2
39753: ARRAY
39754: NOT
39755: PUSH
39756: LD_INT 38
39758: PPUSH
39759: LD_EXP 100
39763: PUSH
39764: LD_VAR 0 2
39768: ARRAY
39769: PPUSH
39770: CALL_OW 321
39774: PUSH
39775: LD_INT 2
39777: NONEQUAL
39778: OR
39779: IFFALSE 39783
// continue ;
39781: GO 39741
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
39783: LD_ADDR_VAR 0 8
39787: PUSH
39788: LD_EXP 74
39792: PUSH
39793: LD_VAR 0 2
39797: ARRAY
39798: PPUSH
39799: LD_INT 30
39801: PUSH
39802: LD_INT 34
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PPUSH
39809: CALL_OW 72
39813: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
39814: LD_ADDR_VAR 0 9
39818: PUSH
39819: LD_EXP 74
39823: PUSH
39824: LD_VAR 0 2
39828: ARRAY
39829: PPUSH
39830: LD_INT 25
39832: PUSH
39833: LD_INT 4
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PPUSH
39840: CALL_OW 72
39844: PPUSH
39845: LD_INT 0
39847: PPUSH
39848: CALL 89894 0 2
39852: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39853: LD_VAR 0 9
39857: NOT
39858: PUSH
39859: LD_VAR 0 8
39863: NOT
39864: OR
39865: PUSH
39866: LD_EXP 74
39870: PUSH
39871: LD_VAR 0 2
39875: ARRAY
39876: PPUSH
39877: LD_INT 124
39879: PPUSH
39880: CALL 89894 0 2
39884: OR
39885: IFFALSE 39889
// continue ;
39887: GO 39741
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39889: LD_EXP 110
39893: PUSH
39894: LD_VAR 0 2
39898: ARRAY
39899: PUSH
39900: LD_EXP 109
39904: PUSH
39905: LD_VAR 0 2
39909: ARRAY
39910: LESS
39911: PUSH
39912: LD_EXP 110
39916: PUSH
39917: LD_VAR 0 2
39921: ARRAY
39922: PUSH
39923: LD_VAR 0 8
39927: LESS
39928: AND
39929: IFFALSE 40344
// begin tmp := sci [ 1 ] ;
39931: LD_ADDR_VAR 0 7
39935: PUSH
39936: LD_VAR 0 9
39940: PUSH
39941: LD_INT 1
39943: ARRAY
39944: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39945: LD_VAR 0 7
39949: PPUSH
39950: LD_INT 124
39952: PPUSH
39953: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39957: LD_ADDR_VAR 0 3
39961: PUSH
39962: DOUBLE
39963: LD_EXP 109
39967: PUSH
39968: LD_VAR 0 2
39972: ARRAY
39973: INC
39974: ST_TO_ADDR
39975: LD_EXP 109
39979: PUSH
39980: LD_VAR 0 2
39984: ARRAY
39985: PUSH
39986: FOR_DOWNTO
39987: IFFALSE 40330
// begin if IsInUnit ( tmp ) then
39989: LD_VAR 0 7
39993: PPUSH
39994: CALL_OW 310
39998: IFFALSE 40009
// ComExitBuilding ( tmp ) ;
40000: LD_VAR 0 7
40004: PPUSH
40005: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40009: LD_INT 35
40011: PPUSH
40012: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40016: LD_VAR 0 7
40020: PPUSH
40021: CALL_OW 310
40025: NOT
40026: PUSH
40027: LD_VAR 0 7
40031: PPUSH
40032: CALL_OW 314
40036: NOT
40037: AND
40038: IFFALSE 40009
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40040: LD_ADDR_VAR 0 6
40044: PUSH
40045: LD_VAR 0 7
40049: PPUSH
40050: CALL_OW 250
40054: PUSH
40055: LD_VAR 0 7
40059: PPUSH
40060: CALL_OW 251
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40069: LD_INT 35
40071: PPUSH
40072: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40076: LD_ADDR_VAR 0 4
40080: PUSH
40081: LD_EXP 109
40085: PUSH
40086: LD_VAR 0 2
40090: ARRAY
40091: PUSH
40092: LD_VAR 0 3
40096: ARRAY
40097: PUSH
40098: LD_INT 1
40100: ARRAY
40101: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40102: LD_ADDR_VAR 0 5
40106: PUSH
40107: LD_EXP 109
40111: PUSH
40112: LD_VAR 0 2
40116: ARRAY
40117: PUSH
40118: LD_VAR 0 3
40122: ARRAY
40123: PUSH
40124: LD_INT 2
40126: ARRAY
40127: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40128: LD_VAR 0 7
40132: PPUSH
40133: LD_INT 10
40135: PPUSH
40136: CALL 59227 0 2
40140: PUSH
40141: LD_INT 4
40143: ARRAY
40144: IFFALSE 40182
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40146: LD_VAR 0 7
40150: PPUSH
40151: LD_VAR 0 6
40155: PUSH
40156: LD_INT 1
40158: ARRAY
40159: PPUSH
40160: LD_VAR 0 6
40164: PUSH
40165: LD_INT 2
40167: ARRAY
40168: PPUSH
40169: CALL_OW 111
// wait ( 0 0$10 ) ;
40173: LD_INT 350
40175: PPUSH
40176: CALL_OW 67
// end else
40180: GO 40208
// begin ComMoveXY ( tmp , x , y ) ;
40182: LD_VAR 0 7
40186: PPUSH
40187: LD_VAR 0 4
40191: PPUSH
40192: LD_VAR 0 5
40196: PPUSH
40197: CALL_OW 111
// wait ( 0 0$3 ) ;
40201: LD_INT 105
40203: PPUSH
40204: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40208: LD_VAR 0 7
40212: PPUSH
40213: LD_VAR 0 4
40217: PPUSH
40218: LD_VAR 0 5
40222: PPUSH
40223: CALL_OW 307
40227: IFFALSE 40069
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40229: LD_VAR 0 7
40233: PPUSH
40234: LD_VAR 0 4
40238: PPUSH
40239: LD_VAR 0 5
40243: PPUSH
40244: LD_VAR 0 8
40248: PUSH
40249: LD_VAR 0 3
40253: ARRAY
40254: PPUSH
40255: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40259: LD_INT 35
40261: PPUSH
40262: CALL_OW 67
// until not HasTask ( tmp ) ;
40266: LD_VAR 0 7
40270: PPUSH
40271: CALL_OW 314
40275: NOT
40276: IFFALSE 40259
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40278: LD_ADDR_EXP 110
40282: PUSH
40283: LD_EXP 110
40287: PPUSH
40288: LD_VAR 0 2
40292: PUSH
40293: LD_EXP 110
40297: PUSH
40298: LD_VAR 0 2
40302: ARRAY
40303: PUSH
40304: LD_INT 1
40306: PLUS
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PPUSH
40312: LD_VAR 0 8
40316: PUSH
40317: LD_VAR 0 3
40321: ARRAY
40322: PPUSH
40323: CALL 56634 0 3
40327: ST_TO_ADDR
// end ;
40328: GO 39986
40330: POP
40331: POP
// MC_Reset ( i , 124 ) ;
40332: LD_VAR 0 2
40336: PPUSH
40337: LD_INT 124
40339: PPUSH
40340: CALL 23831 0 2
// end ; end ;
40344: GO 39741
40346: POP
40347: POP
// end ;
40348: LD_VAR 0 1
40352: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40353: LD_INT 0
40355: PPUSH
40356: PPUSH
40357: PPUSH
// if not mc_bases then
40358: LD_EXP 74
40362: NOT
40363: IFFALSE 40367
// exit ;
40365: GO 40973
// for i = 1 to mc_bases do
40367: LD_ADDR_VAR 0 2
40371: PUSH
40372: DOUBLE
40373: LD_INT 1
40375: DEC
40376: ST_TO_ADDR
40377: LD_EXP 74
40381: PUSH
40382: FOR_TO
40383: IFFALSE 40971
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40385: LD_ADDR_VAR 0 3
40389: PUSH
40390: LD_EXP 74
40394: PUSH
40395: LD_VAR 0 2
40399: ARRAY
40400: PPUSH
40401: LD_INT 25
40403: PUSH
40404: LD_INT 4
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PPUSH
40411: CALL_OW 72
40415: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40416: LD_VAR 0 3
40420: NOT
40421: PUSH
40422: LD_EXP 111
40426: PUSH
40427: LD_VAR 0 2
40431: ARRAY
40432: NOT
40433: OR
40434: PUSH
40435: LD_EXP 74
40439: PUSH
40440: LD_VAR 0 2
40444: ARRAY
40445: PPUSH
40446: LD_INT 2
40448: PUSH
40449: LD_INT 30
40451: PUSH
40452: LD_INT 0
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 30
40461: PUSH
40462: LD_INT 1
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: LIST
40473: PPUSH
40474: CALL_OW 72
40478: NOT
40479: OR
40480: IFFALSE 40530
// begin if mc_deposits_finder [ i ] then
40482: LD_EXP 112
40486: PUSH
40487: LD_VAR 0 2
40491: ARRAY
40492: IFFALSE 40528
// begin MC_Reset ( i , 125 ) ;
40494: LD_VAR 0 2
40498: PPUSH
40499: LD_INT 125
40501: PPUSH
40502: CALL 23831 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40506: LD_ADDR_EXP 112
40510: PUSH
40511: LD_EXP 112
40515: PPUSH
40516: LD_VAR 0 2
40520: PPUSH
40521: EMPTY
40522: PPUSH
40523: CALL_OW 1
40527: ST_TO_ADDR
// end ; continue ;
40528: GO 40382
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
40530: LD_EXP 111
40534: PUSH
40535: LD_VAR 0 2
40539: ARRAY
40540: PUSH
40541: LD_INT 1
40543: ARRAY
40544: PUSH
40545: LD_INT 3
40547: ARRAY
40548: PUSH
40549: LD_INT 1
40551: EQUAL
40552: PUSH
40553: LD_INT 20
40555: PPUSH
40556: LD_EXP 100
40560: PUSH
40561: LD_VAR 0 2
40565: ARRAY
40566: PPUSH
40567: CALL_OW 321
40571: PUSH
40572: LD_INT 2
40574: NONEQUAL
40575: AND
40576: IFFALSE 40626
// begin if mc_deposits_finder [ i ] then
40578: LD_EXP 112
40582: PUSH
40583: LD_VAR 0 2
40587: ARRAY
40588: IFFALSE 40624
// begin MC_Reset ( i , 125 ) ;
40590: LD_VAR 0 2
40594: PPUSH
40595: LD_INT 125
40597: PPUSH
40598: CALL 23831 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40602: LD_ADDR_EXP 112
40606: PUSH
40607: LD_EXP 112
40611: PPUSH
40612: LD_VAR 0 2
40616: PPUSH
40617: EMPTY
40618: PPUSH
40619: CALL_OW 1
40623: ST_TO_ADDR
// end ; continue ;
40624: GO 40382
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
40626: LD_EXP 111
40630: PUSH
40631: LD_VAR 0 2
40635: ARRAY
40636: PUSH
40637: LD_INT 1
40639: ARRAY
40640: PUSH
40641: LD_INT 1
40643: ARRAY
40644: PPUSH
40645: LD_EXP 111
40649: PUSH
40650: LD_VAR 0 2
40654: ARRAY
40655: PUSH
40656: LD_INT 1
40658: ARRAY
40659: PUSH
40660: LD_INT 2
40662: ARRAY
40663: PPUSH
40664: LD_EXP 100
40668: PUSH
40669: LD_VAR 0 2
40673: ARRAY
40674: PPUSH
40675: CALL_OW 440
40679: IFFALSE 40722
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
40681: LD_ADDR_EXP 111
40685: PUSH
40686: LD_EXP 111
40690: PPUSH
40691: LD_VAR 0 2
40695: PPUSH
40696: LD_EXP 111
40700: PUSH
40701: LD_VAR 0 2
40705: ARRAY
40706: PPUSH
40707: LD_INT 1
40709: PPUSH
40710: CALL_OW 3
40714: PPUSH
40715: CALL_OW 1
40719: ST_TO_ADDR
40720: GO 40969
// begin if not mc_deposits_finder [ i ] then
40722: LD_EXP 112
40726: PUSH
40727: LD_VAR 0 2
40731: ARRAY
40732: NOT
40733: IFFALSE 40785
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
40735: LD_ADDR_EXP 112
40739: PUSH
40740: LD_EXP 112
40744: PPUSH
40745: LD_VAR 0 2
40749: PPUSH
40750: LD_VAR 0 3
40754: PUSH
40755: LD_INT 1
40757: ARRAY
40758: PUSH
40759: EMPTY
40760: LIST
40761: PPUSH
40762: CALL_OW 1
40766: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
40767: LD_VAR 0 3
40771: PUSH
40772: LD_INT 1
40774: ARRAY
40775: PPUSH
40776: LD_INT 125
40778: PPUSH
40779: CALL_OW 109
// end else
40783: GO 40969
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
40785: LD_EXP 112
40789: PUSH
40790: LD_VAR 0 2
40794: ARRAY
40795: PUSH
40796: LD_INT 1
40798: ARRAY
40799: PPUSH
40800: CALL_OW 310
40804: IFFALSE 40827
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
40806: LD_EXP 112
40810: PUSH
40811: LD_VAR 0 2
40815: ARRAY
40816: PUSH
40817: LD_INT 1
40819: ARRAY
40820: PPUSH
40821: CALL_OW 122
40825: GO 40969
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
40827: LD_EXP 112
40831: PUSH
40832: LD_VAR 0 2
40836: ARRAY
40837: PUSH
40838: LD_INT 1
40840: ARRAY
40841: PPUSH
40842: CALL_OW 314
40846: NOT
40847: PUSH
40848: LD_EXP 112
40852: PUSH
40853: LD_VAR 0 2
40857: ARRAY
40858: PUSH
40859: LD_INT 1
40861: ARRAY
40862: PPUSH
40863: LD_EXP 111
40867: PUSH
40868: LD_VAR 0 2
40872: ARRAY
40873: PUSH
40874: LD_INT 1
40876: ARRAY
40877: PUSH
40878: LD_INT 1
40880: ARRAY
40881: PPUSH
40882: LD_EXP 111
40886: PUSH
40887: LD_VAR 0 2
40891: ARRAY
40892: PUSH
40893: LD_INT 1
40895: ARRAY
40896: PUSH
40897: LD_INT 2
40899: ARRAY
40900: PPUSH
40901: CALL_OW 297
40905: PUSH
40906: LD_INT 6
40908: GREATER
40909: AND
40910: IFFALSE 40969
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40912: LD_EXP 112
40916: PUSH
40917: LD_VAR 0 2
40921: ARRAY
40922: PUSH
40923: LD_INT 1
40925: ARRAY
40926: PPUSH
40927: LD_EXP 111
40931: PUSH
40932: LD_VAR 0 2
40936: ARRAY
40937: PUSH
40938: LD_INT 1
40940: ARRAY
40941: PUSH
40942: LD_INT 1
40944: ARRAY
40945: PPUSH
40946: LD_EXP 111
40950: PUSH
40951: LD_VAR 0 2
40955: ARRAY
40956: PUSH
40957: LD_INT 1
40959: ARRAY
40960: PUSH
40961: LD_INT 2
40963: ARRAY
40964: PPUSH
40965: CALL_OW 111
// end ; end ; end ;
40969: GO 40382
40971: POP
40972: POP
// end ;
40973: LD_VAR 0 1
40977: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40978: LD_INT 0
40980: PPUSH
40981: PPUSH
40982: PPUSH
40983: PPUSH
40984: PPUSH
40985: PPUSH
40986: PPUSH
40987: PPUSH
40988: PPUSH
40989: PPUSH
40990: PPUSH
// if not mc_bases then
40991: LD_EXP 74
40995: NOT
40996: IFFALSE 41000
// exit ;
40998: GO 41724
// for i = 1 to mc_bases do
41000: LD_ADDR_VAR 0 2
41004: PUSH
41005: DOUBLE
41006: LD_INT 1
41008: DEC
41009: ST_TO_ADDR
41010: LD_EXP 74
41014: PUSH
41015: FOR_TO
41016: IFFALSE 41722
// begin if not mc_bases [ i ] then
41018: LD_EXP 74
41022: PUSH
41023: LD_VAR 0 2
41027: ARRAY
41028: NOT
41029: IFFALSE 41033
// continue ;
41031: GO 41015
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41033: LD_ADDR_VAR 0 7
41037: PUSH
41038: LD_EXP 74
41042: PUSH
41043: LD_VAR 0 2
41047: ARRAY
41048: PUSH
41049: LD_INT 1
41051: ARRAY
41052: PPUSH
41053: CALL_OW 248
41057: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41058: LD_VAR 0 7
41062: PUSH
41063: LD_INT 3
41065: EQUAL
41066: PUSH
41067: LD_EXP 93
41071: PUSH
41072: LD_VAR 0 2
41076: ARRAY
41077: PUSH
41078: LD_EXP 96
41082: PUSH
41083: LD_VAR 0 2
41087: ARRAY
41088: UNION
41089: PPUSH
41090: LD_INT 33
41092: PUSH
41093: LD_INT 2
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PPUSH
41100: CALL_OW 72
41104: NOT
41105: OR
41106: IFFALSE 41110
// continue ;
41108: GO 41015
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41110: LD_ADDR_VAR 0 9
41114: PUSH
41115: LD_EXP 74
41119: PUSH
41120: LD_VAR 0 2
41124: ARRAY
41125: PPUSH
41126: LD_INT 30
41128: PUSH
41129: LD_INT 36
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PPUSH
41136: CALL_OW 72
41140: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41141: LD_ADDR_VAR 0 10
41145: PUSH
41146: LD_EXP 93
41150: PUSH
41151: LD_VAR 0 2
41155: ARRAY
41156: PPUSH
41157: LD_INT 34
41159: PUSH
41160: LD_INT 31
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PPUSH
41167: CALL_OW 72
41171: ST_TO_ADDR
// if not cts and not mcts then
41172: LD_VAR 0 9
41176: NOT
41177: PUSH
41178: LD_VAR 0 10
41182: NOT
41183: AND
41184: IFFALSE 41188
// continue ;
41186: GO 41015
// x := cts ;
41188: LD_ADDR_VAR 0 11
41192: PUSH
41193: LD_VAR 0 9
41197: ST_TO_ADDR
// if not x then
41198: LD_VAR 0 11
41202: NOT
41203: IFFALSE 41215
// x := mcts ;
41205: LD_ADDR_VAR 0 11
41209: PUSH
41210: LD_VAR 0 10
41214: ST_TO_ADDR
// if mc_remote_driver [ i ] then
41215: LD_EXP 114
41219: PUSH
41220: LD_VAR 0 2
41224: ARRAY
41225: IFFALSE 41494
// for j in mc_remote_driver [ i ] do
41227: LD_ADDR_VAR 0 3
41231: PUSH
41232: LD_EXP 114
41236: PUSH
41237: LD_VAR 0 2
41241: ARRAY
41242: PUSH
41243: FOR_IN
41244: IFFALSE 41492
// begin if GetClass ( j ) <> 3 then
41246: LD_VAR 0 3
41250: PPUSH
41251: CALL_OW 257
41255: PUSH
41256: LD_INT 3
41258: NONEQUAL
41259: IFFALSE 41312
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41261: LD_ADDR_EXP 114
41265: PUSH
41266: LD_EXP 114
41270: PPUSH
41271: LD_VAR 0 2
41275: PPUSH
41276: LD_EXP 114
41280: PUSH
41281: LD_VAR 0 2
41285: ARRAY
41286: PUSH
41287: LD_VAR 0 3
41291: DIFF
41292: PPUSH
41293: CALL_OW 1
41297: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41298: LD_VAR 0 3
41302: PPUSH
41303: LD_INT 0
41305: PPUSH
41306: CALL_OW 109
// continue ;
41310: GO 41243
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41312: LD_VAR 0 3
41316: PPUSH
41317: CALL_OW 310
41321: NOT
41322: PUSH
41323: LD_VAR 0 3
41327: PPUSH
41328: CALL_OW 310
41332: PPUSH
41333: CALL_OW 266
41337: PUSH
41338: LD_INT 36
41340: NONEQUAL
41341: PUSH
41342: LD_VAR 0 3
41346: PPUSH
41347: CALL 89982 0 1
41351: NOT
41352: AND
41353: OR
41354: IFFALSE 41490
// begin if IsInUnit ( j ) then
41356: LD_VAR 0 3
41360: PPUSH
41361: CALL_OW 310
41365: IFFALSE 41376
// ComExitBuilding ( j ) ;
41367: LD_VAR 0 3
41371: PPUSH
41372: CALL_OW 122
// ct := 0 ;
41376: LD_ADDR_VAR 0 8
41380: PUSH
41381: LD_INT 0
41383: ST_TO_ADDR
// for k in x do
41384: LD_ADDR_VAR 0 4
41388: PUSH
41389: LD_VAR 0 11
41393: PUSH
41394: FOR_IN
41395: IFFALSE 41468
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
41397: LD_VAR 0 4
41401: PPUSH
41402: CALL_OW 264
41406: PUSH
41407: LD_INT 31
41409: EQUAL
41410: PUSH
41411: LD_VAR 0 4
41415: PPUSH
41416: CALL_OW 311
41420: NOT
41421: AND
41422: PUSH
41423: LD_VAR 0 4
41427: PPUSH
41428: CALL_OW 266
41432: PUSH
41433: LD_INT 36
41435: EQUAL
41436: PUSH
41437: LD_VAR 0 4
41441: PPUSH
41442: CALL_OW 313
41446: PUSH
41447: LD_INT 3
41449: LESS
41450: AND
41451: OR
41452: IFFALSE 41466
// begin ct := k ;
41454: LD_ADDR_VAR 0 8
41458: PUSH
41459: LD_VAR 0 4
41463: ST_TO_ADDR
// break ;
41464: GO 41468
// end ;
41466: GO 41394
41468: POP
41469: POP
// if ct then
41470: LD_VAR 0 8
41474: IFFALSE 41490
// ComEnterUnit ( j , ct ) ;
41476: LD_VAR 0 3
41480: PPUSH
41481: LD_VAR 0 8
41485: PPUSH
41486: CALL_OW 120
// end ; end ;
41490: GO 41243
41492: POP
41493: POP
// places := 0 ;
41494: LD_ADDR_VAR 0 5
41498: PUSH
41499: LD_INT 0
41501: ST_TO_ADDR
// for j = 1 to x do
41502: LD_ADDR_VAR 0 3
41506: PUSH
41507: DOUBLE
41508: LD_INT 1
41510: DEC
41511: ST_TO_ADDR
41512: LD_VAR 0 11
41516: PUSH
41517: FOR_TO
41518: IFFALSE 41573
// if GetWeapon ( x [ j ] ) = ar_control_tower then
41520: LD_VAR 0 11
41524: PUSH
41525: LD_VAR 0 3
41529: ARRAY
41530: PPUSH
41531: CALL_OW 264
41535: PUSH
41536: LD_INT 31
41538: EQUAL
41539: IFFALSE 41557
// places := places + 1 else
41541: LD_ADDR_VAR 0 5
41545: PUSH
41546: LD_VAR 0 5
41550: PUSH
41551: LD_INT 1
41553: PLUS
41554: ST_TO_ADDR
41555: GO 41571
// places := places + 3 ;
41557: LD_ADDR_VAR 0 5
41561: PUSH
41562: LD_VAR 0 5
41566: PUSH
41567: LD_INT 3
41569: PLUS
41570: ST_TO_ADDR
41571: GO 41517
41573: POP
41574: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
41575: LD_ADDR_VAR 0 6
41579: PUSH
41580: LD_EXP 74
41584: PUSH
41585: LD_VAR 0 2
41589: ARRAY
41590: PPUSH
41591: LD_INT 25
41593: PUSH
41594: LD_INT 3
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: PPUSH
41601: CALL_OW 72
41605: PUSH
41606: LD_EXP 114
41610: PUSH
41611: LD_VAR 0 2
41615: ARRAY
41616: DIFF
41617: PPUSH
41618: LD_INT 3
41620: PPUSH
41621: CALL 90882 0 2
41625: ST_TO_ADDR
// if not tmp then
41626: LD_VAR 0 6
41630: NOT
41631: IFFALSE 41635
// continue ;
41633: GO 41015
// places := places - mc_remote_driver [ i ] ;
41635: LD_ADDR_VAR 0 5
41639: PUSH
41640: LD_VAR 0 5
41644: PUSH
41645: LD_EXP 114
41649: PUSH
41650: LD_VAR 0 2
41654: ARRAY
41655: MINUS
41656: ST_TO_ADDR
// if places then
41657: LD_VAR 0 5
41661: IFFALSE 41720
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41663: LD_ADDR_EXP 114
41667: PUSH
41668: LD_EXP 114
41672: PPUSH
41673: LD_VAR 0 2
41677: PPUSH
41678: LD_EXP 114
41682: PUSH
41683: LD_VAR 0 2
41687: ARRAY
41688: PUSH
41689: LD_VAR 0 6
41693: PUSH
41694: LD_INT 1
41696: ARRAY
41697: UNION
41698: PPUSH
41699: CALL_OW 1
41703: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41704: LD_VAR 0 6
41708: PUSH
41709: LD_INT 1
41711: ARRAY
41712: PPUSH
41713: LD_INT 126
41715: PPUSH
41716: CALL_OW 109
// end ; end ;
41720: GO 41015
41722: POP
41723: POP
// end ;
41724: LD_VAR 0 1
41728: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41729: LD_INT 0
41731: PPUSH
41732: PPUSH
41733: PPUSH
41734: PPUSH
41735: PPUSH
41736: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41737: LD_VAR 0 1
41741: NOT
41742: PUSH
41743: LD_VAR 0 2
41747: NOT
41748: OR
41749: PUSH
41750: LD_VAR 0 3
41754: NOT
41755: OR
41756: PUSH
41757: LD_VAR 0 4
41761: PUSH
41762: LD_INT 1
41764: PUSH
41765: LD_INT 2
41767: PUSH
41768: LD_INT 3
41770: PUSH
41771: LD_INT 4
41773: PUSH
41774: LD_INT 5
41776: PUSH
41777: LD_INT 8
41779: PUSH
41780: LD_INT 9
41782: PUSH
41783: LD_INT 15
41785: PUSH
41786: LD_INT 16
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: IN
41800: NOT
41801: OR
41802: IFFALSE 41806
// exit ;
41804: GO 42706
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41806: LD_ADDR_VAR 0 2
41810: PUSH
41811: LD_VAR 0 2
41815: PPUSH
41816: LD_INT 21
41818: PUSH
41819: LD_INT 3
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: LD_INT 24
41828: PUSH
41829: LD_INT 250
41831: PUSH
41832: EMPTY
41833: LIST
41834: LIST
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PPUSH
41840: CALL_OW 72
41844: ST_TO_ADDR
// case class of 1 , 15 :
41845: LD_VAR 0 4
41849: PUSH
41850: LD_INT 1
41852: DOUBLE
41853: EQUAL
41854: IFTRUE 41864
41856: LD_INT 15
41858: DOUBLE
41859: EQUAL
41860: IFTRUE 41864
41862: GO 41949
41864: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41865: LD_ADDR_VAR 0 8
41869: PUSH
41870: LD_VAR 0 2
41874: PPUSH
41875: LD_INT 2
41877: PUSH
41878: LD_INT 30
41880: PUSH
41881: LD_INT 32
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 30
41890: PUSH
41891: LD_INT 31
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: LIST
41902: PPUSH
41903: CALL_OW 72
41907: PUSH
41908: LD_VAR 0 2
41912: PPUSH
41913: LD_INT 2
41915: PUSH
41916: LD_INT 30
41918: PUSH
41919: LD_INT 4
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 30
41928: PUSH
41929: LD_INT 5
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: EMPTY
41937: LIST
41938: LIST
41939: LIST
41940: PPUSH
41941: CALL_OW 72
41945: ADD
41946: ST_TO_ADDR
41947: GO 42195
41949: LD_INT 2
41951: DOUBLE
41952: EQUAL
41953: IFTRUE 41963
41955: LD_INT 16
41957: DOUBLE
41958: EQUAL
41959: IFTRUE 41963
41961: GO 42009
41963: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41964: LD_ADDR_VAR 0 8
41968: PUSH
41969: LD_VAR 0 2
41973: PPUSH
41974: LD_INT 2
41976: PUSH
41977: LD_INT 30
41979: PUSH
41980: LD_INT 0
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 30
41989: PUSH
41990: LD_INT 1
41992: PUSH
41993: EMPTY
41994: LIST
41995: LIST
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: LIST
42001: PPUSH
42002: CALL_OW 72
42006: ST_TO_ADDR
42007: GO 42195
42009: LD_INT 3
42011: DOUBLE
42012: EQUAL
42013: IFTRUE 42017
42015: GO 42063
42017: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42018: LD_ADDR_VAR 0 8
42022: PUSH
42023: LD_VAR 0 2
42027: PPUSH
42028: LD_INT 2
42030: PUSH
42031: LD_INT 30
42033: PUSH
42034: LD_INT 2
42036: PUSH
42037: EMPTY
42038: LIST
42039: LIST
42040: PUSH
42041: LD_INT 30
42043: PUSH
42044: LD_INT 3
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: LIST
42055: PPUSH
42056: CALL_OW 72
42060: ST_TO_ADDR
42061: GO 42195
42063: LD_INT 4
42065: DOUBLE
42066: EQUAL
42067: IFTRUE 42071
42069: GO 42128
42071: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42072: LD_ADDR_VAR 0 8
42076: PUSH
42077: LD_VAR 0 2
42081: PPUSH
42082: LD_INT 2
42084: PUSH
42085: LD_INT 30
42087: PUSH
42088: LD_INT 6
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 30
42097: PUSH
42098: LD_INT 7
42100: PUSH
42101: EMPTY
42102: LIST
42103: LIST
42104: PUSH
42105: LD_INT 30
42107: PUSH
42108: LD_INT 8
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: LIST
42119: LIST
42120: PPUSH
42121: CALL_OW 72
42125: ST_TO_ADDR
42126: GO 42195
42128: LD_INT 5
42130: DOUBLE
42131: EQUAL
42132: IFTRUE 42148
42134: LD_INT 8
42136: DOUBLE
42137: EQUAL
42138: IFTRUE 42148
42140: LD_INT 9
42142: DOUBLE
42143: EQUAL
42144: IFTRUE 42148
42146: GO 42194
42148: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42149: LD_ADDR_VAR 0 8
42153: PUSH
42154: LD_VAR 0 2
42158: PPUSH
42159: LD_INT 2
42161: PUSH
42162: LD_INT 30
42164: PUSH
42165: LD_INT 4
42167: PUSH
42168: EMPTY
42169: LIST
42170: LIST
42171: PUSH
42172: LD_INT 30
42174: PUSH
42175: LD_INT 5
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: LIST
42186: PPUSH
42187: CALL_OW 72
42191: ST_TO_ADDR
42192: GO 42195
42194: POP
// if not tmp then
42195: LD_VAR 0 8
42199: NOT
42200: IFFALSE 42204
// exit ;
42202: GO 42706
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42204: LD_VAR 0 4
42208: PUSH
42209: LD_INT 1
42211: PUSH
42212: LD_INT 15
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: IN
42219: PUSH
42220: LD_EXP 83
42224: PUSH
42225: LD_VAR 0 1
42229: ARRAY
42230: AND
42231: IFFALSE 42387
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42233: LD_ADDR_VAR 0 9
42237: PUSH
42238: LD_EXP 83
42242: PUSH
42243: LD_VAR 0 1
42247: ARRAY
42248: PUSH
42249: LD_INT 1
42251: ARRAY
42252: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42253: LD_VAR 0 9
42257: PUSH
42258: LD_EXP 84
42262: PUSH
42263: LD_VAR 0 1
42267: ARRAY
42268: IN
42269: NOT
42270: IFFALSE 42385
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42272: LD_ADDR_EXP 84
42276: PUSH
42277: LD_EXP 84
42281: PPUSH
42282: LD_VAR 0 1
42286: PUSH
42287: LD_EXP 84
42291: PUSH
42292: LD_VAR 0 1
42296: ARRAY
42297: PUSH
42298: LD_INT 1
42300: PLUS
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PPUSH
42306: LD_VAR 0 9
42310: PPUSH
42311: CALL 56634 0 3
42315: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
42316: LD_ADDR_EXP 83
42320: PUSH
42321: LD_EXP 83
42325: PPUSH
42326: LD_VAR 0 1
42330: PPUSH
42331: LD_EXP 83
42335: PUSH
42336: LD_VAR 0 1
42340: ARRAY
42341: PUSH
42342: LD_VAR 0 9
42346: DIFF
42347: PPUSH
42348: CALL_OW 1
42352: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
42353: LD_VAR 0 3
42357: PPUSH
42358: LD_EXP 84
42362: PUSH
42363: LD_VAR 0 1
42367: ARRAY
42368: PUSH
42369: LD_EXP 84
42373: PUSH
42374: LD_VAR 0 1
42378: ARRAY
42379: ARRAY
42380: PPUSH
42381: CALL_OW 120
// end ; exit ;
42385: GO 42706
// end ; if tmp > 1 then
42387: LD_VAR 0 8
42391: PUSH
42392: LD_INT 1
42394: GREATER
42395: IFFALSE 42499
// for i = 2 to tmp do
42397: LD_ADDR_VAR 0 6
42401: PUSH
42402: DOUBLE
42403: LD_INT 2
42405: DEC
42406: ST_TO_ADDR
42407: LD_VAR 0 8
42411: PUSH
42412: FOR_TO
42413: IFFALSE 42497
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
42415: LD_VAR 0 8
42419: PUSH
42420: LD_VAR 0 6
42424: ARRAY
42425: PPUSH
42426: CALL_OW 461
42430: PUSH
42431: LD_INT 6
42433: EQUAL
42434: IFFALSE 42495
// begin x := tmp [ i ] ;
42436: LD_ADDR_VAR 0 9
42440: PUSH
42441: LD_VAR 0 8
42445: PUSH
42446: LD_VAR 0 6
42450: ARRAY
42451: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
42452: LD_ADDR_VAR 0 8
42456: PUSH
42457: LD_VAR 0 8
42461: PPUSH
42462: LD_VAR 0 6
42466: PPUSH
42467: CALL_OW 3
42471: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
42472: LD_ADDR_VAR 0 8
42476: PUSH
42477: LD_VAR 0 8
42481: PPUSH
42482: LD_INT 1
42484: PPUSH
42485: LD_VAR 0 9
42489: PPUSH
42490: CALL_OW 2
42494: ST_TO_ADDR
// end ;
42495: GO 42412
42497: POP
42498: POP
// for i in tmp do
42499: LD_ADDR_VAR 0 6
42503: PUSH
42504: LD_VAR 0 8
42508: PUSH
42509: FOR_IN
42510: IFFALSE 42579
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
42512: LD_VAR 0 6
42516: PPUSH
42517: CALL_OW 313
42521: PUSH
42522: LD_INT 6
42524: LESS
42525: PUSH
42526: LD_VAR 0 6
42530: PPUSH
42531: CALL_OW 266
42535: PUSH
42536: LD_INT 31
42538: PUSH
42539: LD_INT 32
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: IN
42546: NOT
42547: AND
42548: PUSH
42549: LD_VAR 0 6
42553: PPUSH
42554: CALL_OW 313
42558: PUSH
42559: LD_INT 0
42561: EQUAL
42562: OR
42563: IFFALSE 42577
// begin j := i ;
42565: LD_ADDR_VAR 0 7
42569: PUSH
42570: LD_VAR 0 6
42574: ST_TO_ADDR
// break ;
42575: GO 42579
// end ; end ;
42577: GO 42509
42579: POP
42580: POP
// if j then
42581: LD_VAR 0 7
42585: IFFALSE 42603
// ComEnterUnit ( unit , j ) else
42587: LD_VAR 0 3
42591: PPUSH
42592: LD_VAR 0 7
42596: PPUSH
42597: CALL_OW 120
42601: GO 42706
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42603: LD_ADDR_VAR 0 10
42607: PUSH
42608: LD_VAR 0 2
42612: PPUSH
42613: LD_INT 2
42615: PUSH
42616: LD_INT 30
42618: PUSH
42619: LD_INT 0
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: LD_INT 30
42628: PUSH
42629: LD_INT 1
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: LIST
42640: PPUSH
42641: CALL_OW 72
42645: ST_TO_ADDR
// if depot then
42646: LD_VAR 0 10
42650: IFFALSE 42706
// begin depot := NearestUnitToUnit ( depot , unit ) ;
42652: LD_ADDR_VAR 0 10
42656: PUSH
42657: LD_VAR 0 10
42661: PPUSH
42662: LD_VAR 0 3
42666: PPUSH
42667: CALL_OW 74
42671: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
42672: LD_VAR 0 3
42676: PPUSH
42677: LD_VAR 0 10
42681: PPUSH
42682: CALL_OW 296
42686: PUSH
42687: LD_INT 10
42689: GREATER
42690: IFFALSE 42706
// ComStandNearbyBuilding ( unit , depot ) ;
42692: LD_VAR 0 3
42696: PPUSH
42697: LD_VAR 0 10
42701: PPUSH
42702: CALL 50986 0 2
// end ; end ; end ;
42706: LD_VAR 0 5
42710: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42711: LD_INT 0
42713: PPUSH
42714: PPUSH
42715: PPUSH
42716: PPUSH
// if not mc_bases then
42717: LD_EXP 74
42721: NOT
42722: IFFALSE 42726
// exit ;
42724: GO 42965
// for i = 1 to mc_bases do
42726: LD_ADDR_VAR 0 2
42730: PUSH
42731: DOUBLE
42732: LD_INT 1
42734: DEC
42735: ST_TO_ADDR
42736: LD_EXP 74
42740: PUSH
42741: FOR_TO
42742: IFFALSE 42963
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42744: LD_ADDR_VAR 0 4
42748: PUSH
42749: LD_EXP 74
42753: PUSH
42754: LD_VAR 0 2
42758: ARRAY
42759: PPUSH
42760: LD_INT 21
42762: PUSH
42763: LD_INT 1
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: PPUSH
42770: CALL_OW 72
42774: PUSH
42775: LD_EXP 103
42779: PUSH
42780: LD_VAR 0 2
42784: ARRAY
42785: UNION
42786: ST_TO_ADDR
// if not tmp then
42787: LD_VAR 0 4
42791: NOT
42792: IFFALSE 42796
// continue ;
42794: GO 42741
// for j in tmp do
42796: LD_ADDR_VAR 0 3
42800: PUSH
42801: LD_VAR 0 4
42805: PUSH
42806: FOR_IN
42807: IFFALSE 42959
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42809: LD_VAR 0 3
42813: PPUSH
42814: CALL_OW 110
42818: NOT
42819: PUSH
42820: LD_VAR 0 3
42824: PPUSH
42825: CALL_OW 314
42829: NOT
42830: AND
42831: PUSH
42832: LD_VAR 0 3
42836: PPUSH
42837: CALL_OW 311
42841: NOT
42842: AND
42843: PUSH
42844: LD_VAR 0 3
42848: PPUSH
42849: CALL_OW 310
42853: NOT
42854: AND
42855: PUSH
42856: LD_VAR 0 3
42860: PUSH
42861: LD_EXP 77
42865: PUSH
42866: LD_VAR 0 2
42870: ARRAY
42871: PUSH
42872: LD_INT 1
42874: ARRAY
42875: IN
42876: NOT
42877: AND
42878: PUSH
42879: LD_VAR 0 3
42883: PUSH
42884: LD_EXP 77
42888: PUSH
42889: LD_VAR 0 2
42893: ARRAY
42894: PUSH
42895: LD_INT 2
42897: ARRAY
42898: IN
42899: NOT
42900: AND
42901: PUSH
42902: LD_VAR 0 3
42906: PUSH
42907: LD_EXP 86
42911: PUSH
42912: LD_VAR 0 2
42916: ARRAY
42917: IN
42918: NOT
42919: AND
42920: IFFALSE 42957
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42922: LD_VAR 0 2
42926: PPUSH
42927: LD_EXP 74
42931: PUSH
42932: LD_VAR 0 2
42936: ARRAY
42937: PPUSH
42938: LD_VAR 0 3
42942: PPUSH
42943: LD_VAR 0 3
42947: PPUSH
42948: CALL_OW 257
42952: PPUSH
42953: CALL 41729 0 4
// end ;
42957: GO 42806
42959: POP
42960: POP
// end ;
42961: GO 42741
42963: POP
42964: POP
// end ;
42965: LD_VAR 0 1
42969: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
42970: LD_INT 0
42972: PPUSH
42973: PPUSH
42974: PPUSH
42975: PPUSH
42976: PPUSH
42977: PPUSH
// if not mc_bases [ base ] then
42978: LD_EXP 74
42982: PUSH
42983: LD_VAR 0 1
42987: ARRAY
42988: NOT
42989: IFFALSE 42993
// exit ;
42991: GO 43175
// tmp := [ ] ;
42993: LD_ADDR_VAR 0 6
42997: PUSH
42998: EMPTY
42999: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43000: LD_ADDR_VAR 0 7
43004: PUSH
43005: LD_VAR 0 3
43009: PPUSH
43010: LD_INT 0
43012: PPUSH
43013: CALL_OW 517
43017: ST_TO_ADDR
// if not list then
43018: LD_VAR 0 7
43022: NOT
43023: IFFALSE 43027
// exit ;
43025: GO 43175
// for i = 1 to amount do
43027: LD_ADDR_VAR 0 5
43031: PUSH
43032: DOUBLE
43033: LD_INT 1
43035: DEC
43036: ST_TO_ADDR
43037: LD_VAR 0 2
43041: PUSH
43042: FOR_TO
43043: IFFALSE 43123
// begin x := rand ( 1 , list [ 1 ] ) ;
43045: LD_ADDR_VAR 0 8
43049: PUSH
43050: LD_INT 1
43052: PPUSH
43053: LD_VAR 0 7
43057: PUSH
43058: LD_INT 1
43060: ARRAY
43061: PPUSH
43062: CALL_OW 12
43066: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43067: LD_ADDR_VAR 0 6
43071: PUSH
43072: LD_VAR 0 6
43076: PPUSH
43077: LD_VAR 0 5
43081: PPUSH
43082: LD_VAR 0 7
43086: PUSH
43087: LD_INT 1
43089: ARRAY
43090: PUSH
43091: LD_VAR 0 8
43095: ARRAY
43096: PUSH
43097: LD_VAR 0 7
43101: PUSH
43102: LD_INT 2
43104: ARRAY
43105: PUSH
43106: LD_VAR 0 8
43110: ARRAY
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PPUSH
43116: CALL_OW 1
43120: ST_TO_ADDR
// end ;
43121: GO 43042
43123: POP
43124: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43125: LD_ADDR_EXP 87
43129: PUSH
43130: LD_EXP 87
43134: PPUSH
43135: LD_VAR 0 1
43139: PPUSH
43140: LD_VAR 0 6
43144: PPUSH
43145: CALL_OW 1
43149: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43150: LD_ADDR_EXP 89
43154: PUSH
43155: LD_EXP 89
43159: PPUSH
43160: LD_VAR 0 1
43164: PPUSH
43165: LD_VAR 0 3
43169: PPUSH
43170: CALL_OW 1
43174: ST_TO_ADDR
// end ;
43175: LD_VAR 0 4
43179: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
43180: LD_INT 0
43182: PPUSH
// if not mc_bases [ base ] then
43183: LD_EXP 74
43187: PUSH
43188: LD_VAR 0 1
43192: ARRAY
43193: NOT
43194: IFFALSE 43198
// exit ;
43196: GO 43223
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43198: LD_ADDR_EXP 79
43202: PUSH
43203: LD_EXP 79
43207: PPUSH
43208: LD_VAR 0 1
43212: PPUSH
43213: LD_VAR 0 2
43217: PPUSH
43218: CALL_OW 1
43222: ST_TO_ADDR
// end ;
43223: LD_VAR 0 3
43227: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43228: LD_INT 0
43230: PPUSH
// if not mc_bases [ base ] then
43231: LD_EXP 74
43235: PUSH
43236: LD_VAR 0 1
43240: ARRAY
43241: NOT
43242: IFFALSE 43246
// exit ;
43244: GO 43283
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43246: LD_ADDR_EXP 79
43250: PUSH
43251: LD_EXP 79
43255: PPUSH
43256: LD_VAR 0 1
43260: PPUSH
43261: LD_EXP 79
43265: PUSH
43266: LD_VAR 0 1
43270: ARRAY
43271: PUSH
43272: LD_VAR 0 2
43276: UNION
43277: PPUSH
43278: CALL_OW 1
43282: ST_TO_ADDR
// end ;
43283: LD_VAR 0 3
43287: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
43288: LD_INT 0
43290: PPUSH
// if not mc_bases [ base ] then
43291: LD_EXP 74
43295: PUSH
43296: LD_VAR 0 1
43300: ARRAY
43301: NOT
43302: IFFALSE 43306
// exit ;
43304: GO 43331
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
43306: LD_ADDR_EXP 95
43310: PUSH
43311: LD_EXP 95
43315: PPUSH
43316: LD_VAR 0 1
43320: PPUSH
43321: LD_VAR 0 2
43325: PPUSH
43326: CALL_OW 1
43330: ST_TO_ADDR
// end ;
43331: LD_VAR 0 3
43335: RET
// export function MC_InsertProduceList ( base , components ) ; begin
43336: LD_INT 0
43338: PPUSH
// if not mc_bases [ base ] then
43339: LD_EXP 74
43343: PUSH
43344: LD_VAR 0 1
43348: ARRAY
43349: NOT
43350: IFFALSE 43354
// exit ;
43352: GO 43391
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
43354: LD_ADDR_EXP 95
43358: PUSH
43359: LD_EXP 95
43363: PPUSH
43364: LD_VAR 0 1
43368: PPUSH
43369: LD_EXP 95
43373: PUSH
43374: LD_VAR 0 1
43378: ARRAY
43379: PUSH
43380: LD_VAR 0 2
43384: ADD
43385: PPUSH
43386: CALL_OW 1
43390: ST_TO_ADDR
// end ;
43391: LD_VAR 0 3
43395: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
43396: LD_INT 0
43398: PPUSH
// if not mc_bases [ base ] then
43399: LD_EXP 74
43403: PUSH
43404: LD_VAR 0 1
43408: ARRAY
43409: NOT
43410: IFFALSE 43414
// exit ;
43412: GO 43468
// mc_defender := Replace ( mc_defender , base , deflist ) ;
43414: LD_ADDR_EXP 96
43418: PUSH
43419: LD_EXP 96
43423: PPUSH
43424: LD_VAR 0 1
43428: PPUSH
43429: LD_VAR 0 2
43433: PPUSH
43434: CALL_OW 1
43438: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
43439: LD_ADDR_EXP 85
43443: PUSH
43444: LD_EXP 85
43448: PPUSH
43449: LD_VAR 0 1
43453: PPUSH
43454: LD_VAR 0 2
43458: PUSH
43459: LD_INT 0
43461: PLUS
43462: PPUSH
43463: CALL_OW 1
43467: ST_TO_ADDR
// end ;
43468: LD_VAR 0 3
43472: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
43473: LD_INT 0
43475: PPUSH
// if not mc_bases [ base ] then
43476: LD_EXP 74
43480: PUSH
43481: LD_VAR 0 1
43485: ARRAY
43486: NOT
43487: IFFALSE 43491
// exit ;
43489: GO 43516
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
43491: LD_ADDR_EXP 85
43495: PUSH
43496: LD_EXP 85
43500: PPUSH
43501: LD_VAR 0 1
43505: PPUSH
43506: LD_VAR 0 2
43510: PPUSH
43511: CALL_OW 1
43515: ST_TO_ADDR
// end ;
43516: LD_VAR 0 3
43520: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
43521: LD_INT 0
43523: PPUSH
43524: PPUSH
43525: PPUSH
43526: PPUSH
// if not mc_bases [ base ] then
43527: LD_EXP 74
43531: PUSH
43532: LD_VAR 0 1
43536: ARRAY
43537: NOT
43538: IFFALSE 43542
// exit ;
43540: GO 43607
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
43542: LD_ADDR_EXP 94
43546: PUSH
43547: LD_EXP 94
43551: PPUSH
43552: LD_VAR 0 1
43556: PUSH
43557: LD_EXP 94
43561: PUSH
43562: LD_VAR 0 1
43566: ARRAY
43567: PUSH
43568: LD_INT 1
43570: PLUS
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: PPUSH
43576: LD_VAR 0 1
43580: PUSH
43581: LD_VAR 0 2
43585: PUSH
43586: LD_VAR 0 3
43590: PUSH
43591: LD_VAR 0 4
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: PPUSH
43602: CALL 56634 0 3
43606: ST_TO_ADDR
// end ;
43607: LD_VAR 0 5
43611: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
43612: LD_INT 0
43614: PPUSH
// if not mc_bases [ base ] then
43615: LD_EXP 74
43619: PUSH
43620: LD_VAR 0 1
43624: ARRAY
43625: NOT
43626: IFFALSE 43630
// exit ;
43628: GO 43655
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
43630: LD_ADDR_EXP 111
43634: PUSH
43635: LD_EXP 111
43639: PPUSH
43640: LD_VAR 0 1
43644: PPUSH
43645: LD_VAR 0 2
43649: PPUSH
43650: CALL_OW 1
43654: ST_TO_ADDR
// end ;
43655: LD_VAR 0 3
43659: RET
// export function MC_GetMinesField ( base ) ; begin
43660: LD_INT 0
43662: PPUSH
// result := mc_mines [ base ] ;
43663: LD_ADDR_VAR 0 2
43667: PUSH
43668: LD_EXP 87
43672: PUSH
43673: LD_VAR 0 1
43677: ARRAY
43678: ST_TO_ADDR
// end ;
43679: LD_VAR 0 2
43683: RET
// export function MC_GetProduceList ( base ) ; begin
43684: LD_INT 0
43686: PPUSH
// result := mc_produce [ base ] ;
43687: LD_ADDR_VAR 0 2
43691: PUSH
43692: LD_EXP 95
43696: PUSH
43697: LD_VAR 0 1
43701: ARRAY
43702: ST_TO_ADDR
// end ;
43703: LD_VAR 0 2
43707: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43708: LD_INT 0
43710: PPUSH
43711: PPUSH
// if not mc_bases then
43712: LD_EXP 74
43716: NOT
43717: IFFALSE 43721
// exit ;
43719: GO 43786
// if mc_bases [ base ] then
43721: LD_EXP 74
43725: PUSH
43726: LD_VAR 0 1
43730: ARRAY
43731: IFFALSE 43786
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43733: LD_ADDR_VAR 0 3
43737: PUSH
43738: LD_EXP 74
43742: PUSH
43743: LD_VAR 0 1
43747: ARRAY
43748: PPUSH
43749: LD_INT 30
43751: PUSH
43752: LD_VAR 0 2
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PPUSH
43761: CALL_OW 72
43765: ST_TO_ADDR
// if result then
43766: LD_VAR 0 3
43770: IFFALSE 43786
// result := result [ 1 ] ;
43772: LD_ADDR_VAR 0 3
43776: PUSH
43777: LD_VAR 0 3
43781: PUSH
43782: LD_INT 1
43784: ARRAY
43785: ST_TO_ADDR
// end ; end ;
43786: LD_VAR 0 3
43790: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43791: LD_INT 0
43793: PPUSH
43794: PPUSH
// if not mc_bases then
43795: LD_EXP 74
43799: NOT
43800: IFFALSE 43804
// exit ;
43802: GO 43849
// if mc_bases [ base ] then
43804: LD_EXP 74
43808: PUSH
43809: LD_VAR 0 1
43813: ARRAY
43814: IFFALSE 43849
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43816: LD_ADDR_VAR 0 3
43820: PUSH
43821: LD_EXP 74
43825: PUSH
43826: LD_VAR 0 1
43830: ARRAY
43831: PPUSH
43832: LD_INT 30
43834: PUSH
43835: LD_VAR 0 2
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PPUSH
43844: CALL_OW 72
43848: ST_TO_ADDR
// end ;
43849: LD_VAR 0 3
43853: RET
// export function MC_SetTame ( base , area ) ; begin
43854: LD_INT 0
43856: PPUSH
// if not mc_bases or not base then
43857: LD_EXP 74
43861: NOT
43862: PUSH
43863: LD_VAR 0 1
43867: NOT
43868: OR
43869: IFFALSE 43873
// exit ;
43871: GO 43898
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43873: LD_ADDR_EXP 102
43877: PUSH
43878: LD_EXP 102
43882: PPUSH
43883: LD_VAR 0 1
43887: PPUSH
43888: LD_VAR 0 2
43892: PPUSH
43893: CALL_OW 1
43897: ST_TO_ADDR
// end ;
43898: LD_VAR 0 3
43902: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43903: LD_INT 0
43905: PPUSH
43906: PPUSH
// if not mc_bases or not base then
43907: LD_EXP 74
43911: NOT
43912: PUSH
43913: LD_VAR 0 1
43917: NOT
43918: OR
43919: IFFALSE 43923
// exit ;
43921: GO 44025
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43923: LD_ADDR_VAR 0 4
43927: PUSH
43928: LD_EXP 74
43932: PUSH
43933: LD_VAR 0 1
43937: ARRAY
43938: PPUSH
43939: LD_INT 30
43941: PUSH
43942: LD_VAR 0 2
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PPUSH
43951: CALL_OW 72
43955: ST_TO_ADDR
// if not tmp then
43956: LD_VAR 0 4
43960: NOT
43961: IFFALSE 43965
// exit ;
43963: GO 44025
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43965: LD_ADDR_EXP 106
43969: PUSH
43970: LD_EXP 106
43974: PPUSH
43975: LD_VAR 0 1
43979: PPUSH
43980: LD_EXP 106
43984: PUSH
43985: LD_VAR 0 1
43989: ARRAY
43990: PPUSH
43991: LD_EXP 106
43995: PUSH
43996: LD_VAR 0 1
44000: ARRAY
44001: PUSH
44002: LD_INT 1
44004: PLUS
44005: PPUSH
44006: LD_VAR 0 4
44010: PUSH
44011: LD_INT 1
44013: ARRAY
44014: PPUSH
44015: CALL_OW 2
44019: PPUSH
44020: CALL_OW 1
44024: ST_TO_ADDR
// end ;
44025: LD_VAR 0 3
44029: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44030: LD_INT 0
44032: PPUSH
44033: PPUSH
// if not mc_bases or not base or not kinds then
44034: LD_EXP 74
44038: NOT
44039: PUSH
44040: LD_VAR 0 1
44044: NOT
44045: OR
44046: PUSH
44047: LD_VAR 0 2
44051: NOT
44052: OR
44053: IFFALSE 44057
// exit ;
44055: GO 44118
// for i in kinds do
44057: LD_ADDR_VAR 0 4
44061: PUSH
44062: LD_VAR 0 2
44066: PUSH
44067: FOR_IN
44068: IFFALSE 44116
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44070: LD_ADDR_EXP 108
44074: PUSH
44075: LD_EXP 108
44079: PPUSH
44080: LD_VAR 0 1
44084: PUSH
44085: LD_EXP 108
44089: PUSH
44090: LD_VAR 0 1
44094: ARRAY
44095: PUSH
44096: LD_INT 1
44098: PLUS
44099: PUSH
44100: EMPTY
44101: LIST
44102: LIST
44103: PPUSH
44104: LD_VAR 0 4
44108: PPUSH
44109: CALL 56634 0 3
44113: ST_TO_ADDR
44114: GO 44067
44116: POP
44117: POP
// end ;
44118: LD_VAR 0 3
44122: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44123: LD_INT 0
44125: PPUSH
// if not mc_bases or not base or not areas then
44126: LD_EXP 74
44130: NOT
44131: PUSH
44132: LD_VAR 0 1
44136: NOT
44137: OR
44138: PUSH
44139: LD_VAR 0 2
44143: NOT
44144: OR
44145: IFFALSE 44149
// exit ;
44147: GO 44174
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44149: LD_ADDR_EXP 92
44153: PUSH
44154: LD_EXP 92
44158: PPUSH
44159: LD_VAR 0 1
44163: PPUSH
44164: LD_VAR 0 2
44168: PPUSH
44169: CALL_OW 1
44173: ST_TO_ADDR
// end ;
44174: LD_VAR 0 3
44178: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
44179: LD_INT 0
44181: PPUSH
// if not mc_bases or not base or not teleports_exit then
44182: LD_EXP 74
44186: NOT
44187: PUSH
44188: LD_VAR 0 1
44192: NOT
44193: OR
44194: PUSH
44195: LD_VAR 0 2
44199: NOT
44200: OR
44201: IFFALSE 44205
// exit ;
44203: GO 44230
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44205: LD_ADDR_EXP 109
44209: PUSH
44210: LD_EXP 109
44214: PPUSH
44215: LD_VAR 0 1
44219: PPUSH
44220: LD_VAR 0 2
44224: PPUSH
44225: CALL_OW 1
44229: ST_TO_ADDR
// end ;
44230: LD_VAR 0 3
44234: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44235: LD_INT 0
44237: PPUSH
44238: PPUSH
44239: PPUSH
// if not mc_bases or not base or not ext_list then
44240: LD_EXP 74
44244: NOT
44245: PUSH
44246: LD_VAR 0 1
44250: NOT
44251: OR
44252: PUSH
44253: LD_VAR 0 5
44257: NOT
44258: OR
44259: IFFALSE 44263
// exit ;
44261: GO 44436
// tmp := GetFacExtXYD ( x , y , d ) ;
44263: LD_ADDR_VAR 0 8
44267: PUSH
44268: LD_VAR 0 2
44272: PPUSH
44273: LD_VAR 0 3
44277: PPUSH
44278: LD_VAR 0 4
44282: PPUSH
44283: CALL 90012 0 3
44287: ST_TO_ADDR
// if not tmp then
44288: LD_VAR 0 8
44292: NOT
44293: IFFALSE 44297
// exit ;
44295: GO 44436
// for i in tmp do
44297: LD_ADDR_VAR 0 7
44301: PUSH
44302: LD_VAR 0 8
44306: PUSH
44307: FOR_IN
44308: IFFALSE 44434
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
44310: LD_ADDR_EXP 79
44314: PUSH
44315: LD_EXP 79
44319: PPUSH
44320: LD_VAR 0 1
44324: PPUSH
44325: LD_EXP 79
44329: PUSH
44330: LD_VAR 0 1
44334: ARRAY
44335: PPUSH
44336: LD_EXP 79
44340: PUSH
44341: LD_VAR 0 1
44345: ARRAY
44346: PUSH
44347: LD_INT 1
44349: PLUS
44350: PPUSH
44351: LD_VAR 0 5
44355: PUSH
44356: LD_INT 1
44358: ARRAY
44359: PUSH
44360: LD_VAR 0 7
44364: PUSH
44365: LD_INT 1
44367: ARRAY
44368: PUSH
44369: LD_VAR 0 7
44373: PUSH
44374: LD_INT 2
44376: ARRAY
44377: PUSH
44378: LD_VAR 0 7
44382: PUSH
44383: LD_INT 3
44385: ARRAY
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: PPUSH
44393: CALL_OW 2
44397: PPUSH
44398: CALL_OW 1
44402: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
44403: LD_ADDR_VAR 0 5
44407: PUSH
44408: LD_VAR 0 5
44412: PPUSH
44413: LD_INT 1
44415: PPUSH
44416: CALL_OW 3
44420: ST_TO_ADDR
// if not ext_list then
44421: LD_VAR 0 5
44425: NOT
44426: IFFALSE 44432
// exit ;
44428: POP
44429: POP
44430: GO 44436
// end ;
44432: GO 44307
44434: POP
44435: POP
// end ;
44436: LD_VAR 0 6
44440: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
44441: LD_INT 0
44443: PPUSH
// if not mc_bases or not base or not weapon_list then
44444: LD_EXP 74
44448: NOT
44449: PUSH
44450: LD_VAR 0 1
44454: NOT
44455: OR
44456: PUSH
44457: LD_VAR 0 2
44461: NOT
44462: OR
44463: IFFALSE 44467
// exit ;
44465: GO 44492
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
44467: LD_ADDR_EXP 113
44471: PUSH
44472: LD_EXP 113
44476: PPUSH
44477: LD_VAR 0 1
44481: PPUSH
44482: LD_VAR 0 2
44486: PPUSH
44487: CALL_OW 1
44491: ST_TO_ADDR
// end ;
44492: LD_VAR 0 3
44496: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
44497: LD_INT 0
44499: PPUSH
// if not mc_bases or not base or not tech_list then
44500: LD_EXP 74
44504: NOT
44505: PUSH
44506: LD_VAR 0 1
44510: NOT
44511: OR
44512: PUSH
44513: LD_VAR 0 2
44517: NOT
44518: OR
44519: IFFALSE 44523
// exit ;
44521: GO 44548
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
44523: LD_ADDR_EXP 101
44527: PUSH
44528: LD_EXP 101
44532: PPUSH
44533: LD_VAR 0 1
44537: PPUSH
44538: LD_VAR 0 2
44542: PPUSH
44543: CALL_OW 1
44547: ST_TO_ADDR
// end ;
44548: LD_VAR 0 3
44552: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
44553: LD_INT 0
44555: PPUSH
// if not mc_bases or not parking_area or not base then
44556: LD_EXP 74
44560: NOT
44561: PUSH
44562: LD_VAR 0 2
44566: NOT
44567: OR
44568: PUSH
44569: LD_VAR 0 1
44573: NOT
44574: OR
44575: IFFALSE 44579
// exit ;
44577: GO 44604
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
44579: LD_ADDR_EXP 98
44583: PUSH
44584: LD_EXP 98
44588: PPUSH
44589: LD_VAR 0 1
44593: PPUSH
44594: LD_VAR 0 2
44598: PPUSH
44599: CALL_OW 1
44603: ST_TO_ADDR
// end ;
44604: LD_VAR 0 3
44608: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
44609: LD_INT 0
44611: PPUSH
// if not mc_bases or not base or not scan_area then
44612: LD_EXP 74
44616: NOT
44617: PUSH
44618: LD_VAR 0 1
44622: NOT
44623: OR
44624: PUSH
44625: LD_VAR 0 2
44629: NOT
44630: OR
44631: IFFALSE 44635
// exit ;
44633: GO 44660
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
44635: LD_ADDR_EXP 99
44639: PUSH
44640: LD_EXP 99
44644: PPUSH
44645: LD_VAR 0 1
44649: PPUSH
44650: LD_VAR 0 2
44654: PPUSH
44655: CALL_OW 1
44659: ST_TO_ADDR
// end ;
44660: LD_VAR 0 3
44664: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44665: LD_INT 0
44667: PPUSH
44668: PPUSH
// if not mc_bases or not base then
44669: LD_EXP 74
44673: NOT
44674: PUSH
44675: LD_VAR 0 1
44679: NOT
44680: OR
44681: IFFALSE 44685
// exit ;
44683: GO 44749
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44685: LD_ADDR_VAR 0 3
44689: PUSH
44690: LD_INT 1
44692: PUSH
44693: LD_INT 2
44695: PUSH
44696: LD_INT 3
44698: PUSH
44699: LD_INT 4
44701: PUSH
44702: LD_INT 11
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44712: LD_ADDR_EXP 101
44716: PUSH
44717: LD_EXP 101
44721: PPUSH
44722: LD_VAR 0 1
44726: PPUSH
44727: LD_EXP 101
44731: PUSH
44732: LD_VAR 0 1
44736: ARRAY
44737: PUSH
44738: LD_VAR 0 3
44742: DIFF
44743: PPUSH
44744: CALL_OW 1
44748: ST_TO_ADDR
// end ;
44749: LD_VAR 0 2
44753: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44754: LD_INT 0
44756: PPUSH
// result := mc_vehicles [ base ] ;
44757: LD_ADDR_VAR 0 3
44761: PUSH
44762: LD_EXP 93
44766: PUSH
44767: LD_VAR 0 1
44771: ARRAY
44772: ST_TO_ADDR
// if onlyCombat then
44773: LD_VAR 0 2
44777: IFFALSE 44942
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44779: LD_ADDR_VAR 0 3
44783: PUSH
44784: LD_VAR 0 3
44788: PUSH
44789: LD_VAR 0 3
44793: PPUSH
44794: LD_INT 2
44796: PUSH
44797: LD_INT 34
44799: PUSH
44800: LD_INT 12
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 34
44809: PUSH
44810: LD_INT 51
44812: PUSH
44813: EMPTY
44814: LIST
44815: LIST
44816: PUSH
44817: LD_INT 34
44819: PUSH
44820: LD_EXP 68
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PUSH
44829: LD_INT 34
44831: PUSH
44832: LD_INT 32
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: PUSH
44839: LD_INT 34
44841: PUSH
44842: LD_INT 13
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 34
44851: PUSH
44852: LD_INT 52
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: PUSH
44859: LD_INT 34
44861: PUSH
44862: LD_INT 14
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 34
44871: PUSH
44872: LD_INT 53
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: LD_INT 34
44881: PUSH
44882: LD_EXP 67
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 34
44893: PUSH
44894: LD_INT 31
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 34
44903: PUSH
44904: LD_INT 48
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PUSH
44911: LD_INT 34
44913: PUSH
44914: LD_INT 8
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: PPUSH
44936: CALL_OW 72
44940: DIFF
44941: ST_TO_ADDR
// end ; end_of_file
44942: LD_VAR 0 3
44946: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44947: LD_INT 0
44949: PPUSH
44950: PPUSH
44951: PPUSH
// if not mc_bases or not skirmish then
44952: LD_EXP 74
44956: NOT
44957: PUSH
44958: LD_EXP 72
44962: NOT
44963: OR
44964: IFFALSE 44968
// exit ;
44966: GO 45133
// for i = 1 to mc_bases do
44968: LD_ADDR_VAR 0 4
44972: PUSH
44973: DOUBLE
44974: LD_INT 1
44976: DEC
44977: ST_TO_ADDR
44978: LD_EXP 74
44982: PUSH
44983: FOR_TO
44984: IFFALSE 45131
// begin if sci in mc_bases [ i ] then
44986: LD_VAR 0 2
44990: PUSH
44991: LD_EXP 74
44995: PUSH
44996: LD_VAR 0 4
45000: ARRAY
45001: IN
45002: IFFALSE 45129
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45004: LD_ADDR_EXP 103
45008: PUSH
45009: LD_EXP 103
45013: PPUSH
45014: LD_VAR 0 4
45018: PUSH
45019: LD_EXP 103
45023: PUSH
45024: LD_VAR 0 4
45028: ARRAY
45029: PUSH
45030: LD_INT 1
45032: PLUS
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PPUSH
45038: LD_VAR 0 1
45042: PPUSH
45043: CALL 56634 0 3
45047: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45048: LD_ADDR_VAR 0 5
45052: PUSH
45053: LD_EXP 74
45057: PUSH
45058: LD_VAR 0 4
45062: ARRAY
45063: PPUSH
45064: LD_INT 2
45066: PUSH
45067: LD_INT 30
45069: PUSH
45070: LD_INT 0
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 30
45079: PUSH
45080: LD_INT 1
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: LIST
45091: PPUSH
45092: CALL_OW 72
45096: PPUSH
45097: LD_VAR 0 1
45101: PPUSH
45102: CALL_OW 74
45106: ST_TO_ADDR
// if tmp then
45107: LD_VAR 0 5
45111: IFFALSE 45127
// ComStandNearbyBuilding ( ape , tmp ) ;
45113: LD_VAR 0 1
45117: PPUSH
45118: LD_VAR 0 5
45122: PPUSH
45123: CALL 50986 0 2
// break ;
45127: GO 45131
// end ; end ;
45129: GO 44983
45131: POP
45132: POP
// end ;
45133: LD_VAR 0 3
45137: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45138: LD_INT 0
45140: PPUSH
45141: PPUSH
45142: PPUSH
// if not mc_bases or not skirmish then
45143: LD_EXP 74
45147: NOT
45148: PUSH
45149: LD_EXP 72
45153: NOT
45154: OR
45155: IFFALSE 45159
// exit ;
45157: GO 45248
// for i = 1 to mc_bases do
45159: LD_ADDR_VAR 0 4
45163: PUSH
45164: DOUBLE
45165: LD_INT 1
45167: DEC
45168: ST_TO_ADDR
45169: LD_EXP 74
45173: PUSH
45174: FOR_TO
45175: IFFALSE 45246
// begin if building in mc_busy_turret_list [ i ] then
45177: LD_VAR 0 1
45181: PUSH
45182: LD_EXP 84
45186: PUSH
45187: LD_VAR 0 4
45191: ARRAY
45192: IN
45193: IFFALSE 45244
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45195: LD_ADDR_VAR 0 5
45199: PUSH
45200: LD_EXP 84
45204: PUSH
45205: LD_VAR 0 4
45209: ARRAY
45210: PUSH
45211: LD_VAR 0 1
45215: DIFF
45216: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45217: LD_ADDR_EXP 84
45221: PUSH
45222: LD_EXP 84
45226: PPUSH
45227: LD_VAR 0 4
45231: PPUSH
45232: LD_VAR 0 5
45236: PPUSH
45237: CALL_OW 1
45241: ST_TO_ADDR
// break ;
45242: GO 45246
// end ; end ;
45244: GO 45174
45246: POP
45247: POP
// end ;
45248: LD_VAR 0 3
45252: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45253: LD_INT 0
45255: PPUSH
45256: PPUSH
45257: PPUSH
// if not mc_bases or not skirmish then
45258: LD_EXP 74
45262: NOT
45263: PUSH
45264: LD_EXP 72
45268: NOT
45269: OR
45270: IFFALSE 45274
// exit ;
45272: GO 45473
// for i = 1 to mc_bases do
45274: LD_ADDR_VAR 0 5
45278: PUSH
45279: DOUBLE
45280: LD_INT 1
45282: DEC
45283: ST_TO_ADDR
45284: LD_EXP 74
45288: PUSH
45289: FOR_TO
45290: IFFALSE 45471
// if building in mc_bases [ i ] then
45292: LD_VAR 0 1
45296: PUSH
45297: LD_EXP 74
45301: PUSH
45302: LD_VAR 0 5
45306: ARRAY
45307: IN
45308: IFFALSE 45469
// begin tmp := mc_bases [ i ] diff building ;
45310: LD_ADDR_VAR 0 6
45314: PUSH
45315: LD_EXP 74
45319: PUSH
45320: LD_VAR 0 5
45324: ARRAY
45325: PUSH
45326: LD_VAR 0 1
45330: DIFF
45331: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
45332: LD_ADDR_EXP 74
45336: PUSH
45337: LD_EXP 74
45341: PPUSH
45342: LD_VAR 0 5
45346: PPUSH
45347: LD_VAR 0 6
45351: PPUSH
45352: CALL_OW 1
45356: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
45357: LD_VAR 0 1
45361: PUSH
45362: LD_EXP 82
45366: PUSH
45367: LD_VAR 0 5
45371: ARRAY
45372: IN
45373: IFFALSE 45412
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
45375: LD_ADDR_EXP 82
45379: PUSH
45380: LD_EXP 82
45384: PPUSH
45385: LD_VAR 0 5
45389: PPUSH
45390: LD_EXP 82
45394: PUSH
45395: LD_VAR 0 5
45399: ARRAY
45400: PUSH
45401: LD_VAR 0 1
45405: DIFF
45406: PPUSH
45407: CALL_OW 1
45411: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
45412: LD_VAR 0 1
45416: PUSH
45417: LD_EXP 83
45421: PUSH
45422: LD_VAR 0 5
45426: ARRAY
45427: IN
45428: IFFALSE 45467
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
45430: LD_ADDR_EXP 83
45434: PUSH
45435: LD_EXP 83
45439: PPUSH
45440: LD_VAR 0 5
45444: PPUSH
45445: LD_EXP 83
45449: PUSH
45450: LD_VAR 0 5
45454: ARRAY
45455: PUSH
45456: LD_VAR 0 1
45460: DIFF
45461: PPUSH
45462: CALL_OW 1
45466: ST_TO_ADDR
// break ;
45467: GO 45471
// end ;
45469: GO 45289
45471: POP
45472: POP
// end ;
45473: LD_VAR 0 4
45477: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
45478: LD_INT 0
45480: PPUSH
45481: PPUSH
45482: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
45483: LD_EXP 74
45487: NOT
45488: PUSH
45489: LD_EXP 72
45493: NOT
45494: OR
45495: PUSH
45496: LD_VAR 0 3
45500: PUSH
45501: LD_EXP 100
45505: IN
45506: NOT
45507: OR
45508: IFFALSE 45512
// exit ;
45510: GO 45635
// for i = 1 to mc_vehicles do
45512: LD_ADDR_VAR 0 6
45516: PUSH
45517: DOUBLE
45518: LD_INT 1
45520: DEC
45521: ST_TO_ADDR
45522: LD_EXP 93
45526: PUSH
45527: FOR_TO
45528: IFFALSE 45633
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
45530: LD_VAR 0 2
45534: PUSH
45535: LD_EXP 93
45539: PUSH
45540: LD_VAR 0 6
45544: ARRAY
45545: IN
45546: PUSH
45547: LD_VAR 0 1
45551: PUSH
45552: LD_EXP 93
45556: PUSH
45557: LD_VAR 0 6
45561: ARRAY
45562: IN
45563: OR
45564: IFFALSE 45631
// begin tmp := mc_vehicles [ i ] diff old ;
45566: LD_ADDR_VAR 0 7
45570: PUSH
45571: LD_EXP 93
45575: PUSH
45576: LD_VAR 0 6
45580: ARRAY
45581: PUSH
45582: LD_VAR 0 2
45586: DIFF
45587: ST_TO_ADDR
// tmp := tmp diff new ;
45588: LD_ADDR_VAR 0 7
45592: PUSH
45593: LD_VAR 0 7
45597: PUSH
45598: LD_VAR 0 1
45602: DIFF
45603: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
45604: LD_ADDR_EXP 93
45608: PUSH
45609: LD_EXP 93
45613: PPUSH
45614: LD_VAR 0 6
45618: PPUSH
45619: LD_VAR 0 7
45623: PPUSH
45624: CALL_OW 1
45628: ST_TO_ADDR
// break ;
45629: GO 45633
// end ;
45631: GO 45527
45633: POP
45634: POP
// end ;
45635: LD_VAR 0 5
45639: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
45640: LD_INT 0
45642: PPUSH
45643: PPUSH
45644: PPUSH
45645: PPUSH
// if not mc_bases or not skirmish then
45646: LD_EXP 74
45650: NOT
45651: PUSH
45652: LD_EXP 72
45656: NOT
45657: OR
45658: IFFALSE 45662
// exit ;
45660: GO 46039
// side := GetSide ( vehicle ) ;
45662: LD_ADDR_VAR 0 5
45666: PUSH
45667: LD_VAR 0 1
45671: PPUSH
45672: CALL_OW 255
45676: ST_TO_ADDR
// for i = 1 to mc_bases do
45677: LD_ADDR_VAR 0 4
45681: PUSH
45682: DOUBLE
45683: LD_INT 1
45685: DEC
45686: ST_TO_ADDR
45687: LD_EXP 74
45691: PUSH
45692: FOR_TO
45693: IFFALSE 46037
// begin if factory in mc_bases [ i ] then
45695: LD_VAR 0 2
45699: PUSH
45700: LD_EXP 74
45704: PUSH
45705: LD_VAR 0 4
45709: ARRAY
45710: IN
45711: IFFALSE 46035
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
45713: LD_EXP 96
45717: PUSH
45718: LD_VAR 0 4
45722: ARRAY
45723: PUSH
45724: LD_EXP 85
45728: PUSH
45729: LD_VAR 0 4
45733: ARRAY
45734: LESS
45735: PUSH
45736: LD_VAR 0 1
45740: PPUSH
45741: CALL_OW 264
45745: PUSH
45746: LD_INT 31
45748: PUSH
45749: LD_INT 32
45751: PUSH
45752: LD_INT 51
45754: PUSH
45755: LD_EXP 68
45759: PUSH
45760: LD_INT 12
45762: PUSH
45763: LD_INT 30
45765: PUSH
45766: LD_EXP 67
45770: PUSH
45771: LD_INT 11
45773: PUSH
45774: LD_INT 53
45776: PUSH
45777: LD_INT 14
45779: PUSH
45780: LD_EXP 71
45784: PUSH
45785: LD_INT 29
45787: PUSH
45788: LD_EXP 69
45792: PUSH
45793: LD_INT 13
45795: PUSH
45796: LD_INT 52
45798: PUSH
45799: LD_INT 48
45801: PUSH
45802: LD_INT 8
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: IN
45824: NOT
45825: AND
45826: IFFALSE 45874
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45828: LD_ADDR_EXP 96
45832: PUSH
45833: LD_EXP 96
45837: PPUSH
45838: LD_VAR 0 4
45842: PUSH
45843: LD_EXP 96
45847: PUSH
45848: LD_VAR 0 4
45852: ARRAY
45853: PUSH
45854: LD_INT 1
45856: PLUS
45857: PUSH
45858: EMPTY
45859: LIST
45860: LIST
45861: PPUSH
45862: LD_VAR 0 1
45866: PPUSH
45867: CALL 56634 0 3
45871: ST_TO_ADDR
45872: GO 45918
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45874: LD_ADDR_EXP 93
45878: PUSH
45879: LD_EXP 93
45883: PPUSH
45884: LD_VAR 0 4
45888: PUSH
45889: LD_EXP 93
45893: PUSH
45894: LD_VAR 0 4
45898: ARRAY
45899: PUSH
45900: LD_INT 1
45902: PLUS
45903: PUSH
45904: EMPTY
45905: LIST
45906: LIST
45907: PPUSH
45908: LD_VAR 0 1
45912: PPUSH
45913: CALL 56634 0 3
45917: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45918: LD_VAR 0 1
45922: PPUSH
45923: CALL_OW 263
45927: PUSH
45928: LD_INT 2
45930: EQUAL
45931: IFFALSE 45951
// begin repeat wait ( 0 0$1 ) ;
45933: LD_INT 35
45935: PPUSH
45936: CALL_OW 67
// until IsControledBy ( vehicle ) ;
45940: LD_VAR 0 1
45944: PPUSH
45945: CALL_OW 312
45949: IFFALSE 45933
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45951: LD_VAR 0 1
45955: PPUSH
45956: LD_EXP 98
45960: PUSH
45961: LD_VAR 0 4
45965: ARRAY
45966: PPUSH
45967: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45971: LD_VAR 0 1
45975: PPUSH
45976: CALL_OW 263
45980: PUSH
45981: LD_INT 1
45983: NONEQUAL
45984: IFFALSE 45988
// break ;
45986: GO 46037
// repeat wait ( 0 0$1 ) ;
45988: LD_INT 35
45990: PPUSH
45991: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45995: LD_VAR 0 1
45999: PPUSH
46000: LD_EXP 98
46004: PUSH
46005: LD_VAR 0 4
46009: ARRAY
46010: PPUSH
46011: CALL_OW 308
46015: IFFALSE 45988
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46017: LD_VAR 0 1
46021: PPUSH
46022: CALL_OW 311
46026: PPUSH
46027: CALL_OW 121
// exit ;
46031: POP
46032: POP
46033: GO 46039
// end ; end ;
46035: GO 45692
46037: POP
46038: POP
// end ;
46039: LD_VAR 0 3
46043: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46044: LD_INT 0
46046: PPUSH
46047: PPUSH
46048: PPUSH
46049: PPUSH
// if not mc_bases or not skirmish then
46050: LD_EXP 74
46054: NOT
46055: PUSH
46056: LD_EXP 72
46060: NOT
46061: OR
46062: IFFALSE 46066
// exit ;
46064: GO 46419
// repeat wait ( 0 0$1 ) ;
46066: LD_INT 35
46068: PPUSH
46069: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46073: LD_VAR 0 2
46077: PPUSH
46078: LD_VAR 0 3
46082: PPUSH
46083: CALL_OW 284
46087: IFFALSE 46066
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46089: LD_VAR 0 2
46093: PPUSH
46094: LD_VAR 0 3
46098: PPUSH
46099: CALL_OW 283
46103: PUSH
46104: LD_INT 4
46106: EQUAL
46107: IFFALSE 46111
// exit ;
46109: GO 46419
// for i = 1 to mc_bases do
46111: LD_ADDR_VAR 0 7
46115: PUSH
46116: DOUBLE
46117: LD_INT 1
46119: DEC
46120: ST_TO_ADDR
46121: LD_EXP 74
46125: PUSH
46126: FOR_TO
46127: IFFALSE 46417
// begin if mc_crates_area [ i ] then
46129: LD_EXP 92
46133: PUSH
46134: LD_VAR 0 7
46138: ARRAY
46139: IFFALSE 46250
// for j in mc_crates_area [ i ] do
46141: LD_ADDR_VAR 0 8
46145: PUSH
46146: LD_EXP 92
46150: PUSH
46151: LD_VAR 0 7
46155: ARRAY
46156: PUSH
46157: FOR_IN
46158: IFFALSE 46248
// if InArea ( x , y , j ) then
46160: LD_VAR 0 2
46164: PPUSH
46165: LD_VAR 0 3
46169: PPUSH
46170: LD_VAR 0 8
46174: PPUSH
46175: CALL_OW 309
46179: IFFALSE 46246
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46181: LD_ADDR_EXP 90
46185: PUSH
46186: LD_EXP 90
46190: PPUSH
46191: LD_VAR 0 7
46195: PUSH
46196: LD_EXP 90
46200: PUSH
46201: LD_VAR 0 7
46205: ARRAY
46206: PUSH
46207: LD_INT 1
46209: PLUS
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PPUSH
46215: LD_VAR 0 4
46219: PUSH
46220: LD_VAR 0 2
46224: PUSH
46225: LD_VAR 0 3
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: LIST
46234: PPUSH
46235: CALL 56634 0 3
46239: ST_TO_ADDR
// exit ;
46240: POP
46241: POP
46242: POP
46243: POP
46244: GO 46419
// end ;
46246: GO 46157
46248: POP
46249: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46250: LD_ADDR_VAR 0 9
46254: PUSH
46255: LD_EXP 74
46259: PUSH
46260: LD_VAR 0 7
46264: ARRAY
46265: PPUSH
46266: LD_INT 2
46268: PUSH
46269: LD_INT 30
46271: PUSH
46272: LD_INT 0
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: PUSH
46279: LD_INT 30
46281: PUSH
46282: LD_INT 1
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: LIST
46293: PPUSH
46294: CALL_OW 72
46298: ST_TO_ADDR
// if not depot then
46299: LD_VAR 0 9
46303: NOT
46304: IFFALSE 46308
// continue ;
46306: GO 46126
// for j in depot do
46308: LD_ADDR_VAR 0 8
46312: PUSH
46313: LD_VAR 0 9
46317: PUSH
46318: FOR_IN
46319: IFFALSE 46413
// if GetDistUnitXY ( j , x , y ) < 30 then
46321: LD_VAR 0 8
46325: PPUSH
46326: LD_VAR 0 2
46330: PPUSH
46331: LD_VAR 0 3
46335: PPUSH
46336: CALL_OW 297
46340: PUSH
46341: LD_INT 30
46343: LESS
46344: IFFALSE 46411
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46346: LD_ADDR_EXP 90
46350: PUSH
46351: LD_EXP 90
46355: PPUSH
46356: LD_VAR 0 7
46360: PUSH
46361: LD_EXP 90
46365: PUSH
46366: LD_VAR 0 7
46370: ARRAY
46371: PUSH
46372: LD_INT 1
46374: PLUS
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: PPUSH
46380: LD_VAR 0 4
46384: PUSH
46385: LD_VAR 0 2
46389: PUSH
46390: LD_VAR 0 3
46394: PUSH
46395: EMPTY
46396: LIST
46397: LIST
46398: LIST
46399: PPUSH
46400: CALL 56634 0 3
46404: ST_TO_ADDR
// exit ;
46405: POP
46406: POP
46407: POP
46408: POP
46409: GO 46419
// end ;
46411: GO 46318
46413: POP
46414: POP
// end ;
46415: GO 46126
46417: POP
46418: POP
// end ;
46419: LD_VAR 0 6
46423: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
46424: LD_INT 0
46426: PPUSH
46427: PPUSH
46428: PPUSH
46429: PPUSH
// if not mc_bases or not skirmish then
46430: LD_EXP 74
46434: NOT
46435: PUSH
46436: LD_EXP 72
46440: NOT
46441: OR
46442: IFFALSE 46446
// exit ;
46444: GO 46723
// side := GetSide ( lab ) ;
46446: LD_ADDR_VAR 0 4
46450: PUSH
46451: LD_VAR 0 2
46455: PPUSH
46456: CALL_OW 255
46460: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
46461: LD_VAR 0 4
46465: PUSH
46466: LD_EXP 100
46470: IN
46471: NOT
46472: PUSH
46473: LD_EXP 101
46477: NOT
46478: OR
46479: PUSH
46480: LD_EXP 74
46484: NOT
46485: OR
46486: IFFALSE 46490
// exit ;
46488: GO 46723
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
46490: LD_ADDR_EXP 101
46494: PUSH
46495: LD_EXP 101
46499: PPUSH
46500: LD_VAR 0 4
46504: PPUSH
46505: LD_EXP 101
46509: PUSH
46510: LD_VAR 0 4
46514: ARRAY
46515: PUSH
46516: LD_VAR 0 1
46520: DIFF
46521: PPUSH
46522: CALL_OW 1
46526: ST_TO_ADDR
// for i = 1 to mc_bases do
46527: LD_ADDR_VAR 0 5
46531: PUSH
46532: DOUBLE
46533: LD_INT 1
46535: DEC
46536: ST_TO_ADDR
46537: LD_EXP 74
46541: PUSH
46542: FOR_TO
46543: IFFALSE 46721
// begin if lab in mc_bases [ i ] then
46545: LD_VAR 0 2
46549: PUSH
46550: LD_EXP 74
46554: PUSH
46555: LD_VAR 0 5
46559: ARRAY
46560: IN
46561: IFFALSE 46719
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
46563: LD_VAR 0 1
46567: PUSH
46568: LD_INT 11
46570: PUSH
46571: LD_INT 4
46573: PUSH
46574: LD_INT 3
46576: PUSH
46577: LD_INT 2
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: LIST
46584: LIST
46585: IN
46586: PUSH
46587: LD_EXP 104
46591: PUSH
46592: LD_VAR 0 5
46596: ARRAY
46597: AND
46598: IFFALSE 46719
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
46600: LD_ADDR_VAR 0 6
46604: PUSH
46605: LD_EXP 104
46609: PUSH
46610: LD_VAR 0 5
46614: ARRAY
46615: PUSH
46616: LD_INT 1
46618: ARRAY
46619: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46620: LD_ADDR_EXP 104
46624: PUSH
46625: LD_EXP 104
46629: PPUSH
46630: LD_VAR 0 5
46634: PPUSH
46635: EMPTY
46636: PPUSH
46637: CALL_OW 1
46641: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46642: LD_VAR 0 6
46646: PPUSH
46647: LD_INT 0
46649: PPUSH
46650: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46654: LD_VAR 0 6
46658: PPUSH
46659: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46663: LD_ADDR_EXP 103
46667: PUSH
46668: LD_EXP 103
46672: PPUSH
46673: LD_VAR 0 5
46677: PPUSH
46678: LD_EXP 103
46682: PUSH
46683: LD_VAR 0 5
46687: ARRAY
46688: PPUSH
46689: LD_INT 1
46691: PPUSH
46692: LD_VAR 0 6
46696: PPUSH
46697: CALL_OW 2
46701: PPUSH
46702: CALL_OW 1
46706: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46707: LD_VAR 0 5
46711: PPUSH
46712: LD_INT 112
46714: PPUSH
46715: CALL 23831 0 2
// end ; end ; end ;
46719: GO 46542
46721: POP
46722: POP
// end ;
46723: LD_VAR 0 3
46727: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46728: LD_INT 0
46730: PPUSH
46731: PPUSH
46732: PPUSH
46733: PPUSH
46734: PPUSH
46735: PPUSH
46736: PPUSH
46737: PPUSH
// if not mc_bases or not skirmish then
46738: LD_EXP 74
46742: NOT
46743: PUSH
46744: LD_EXP 72
46748: NOT
46749: OR
46750: IFFALSE 46754
// exit ;
46752: GO 47991
// for i = 1 to mc_bases do
46754: LD_ADDR_VAR 0 3
46758: PUSH
46759: DOUBLE
46760: LD_INT 1
46762: DEC
46763: ST_TO_ADDR
46764: LD_EXP 74
46768: PUSH
46769: FOR_TO
46770: IFFALSE 47989
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46772: LD_VAR 0 1
46776: PUSH
46777: LD_EXP 74
46781: PUSH
46782: LD_VAR 0 3
46786: ARRAY
46787: IN
46788: PUSH
46789: LD_VAR 0 1
46793: PUSH
46794: LD_EXP 81
46798: PUSH
46799: LD_VAR 0 3
46803: ARRAY
46804: IN
46805: OR
46806: PUSH
46807: LD_VAR 0 1
46811: PUSH
46812: LD_EXP 96
46816: PUSH
46817: LD_VAR 0 3
46821: ARRAY
46822: IN
46823: OR
46824: PUSH
46825: LD_VAR 0 1
46829: PUSH
46830: LD_EXP 93
46834: PUSH
46835: LD_VAR 0 3
46839: ARRAY
46840: IN
46841: OR
46842: PUSH
46843: LD_VAR 0 1
46847: PUSH
46848: LD_EXP 103
46852: PUSH
46853: LD_VAR 0 3
46857: ARRAY
46858: IN
46859: OR
46860: PUSH
46861: LD_VAR 0 1
46865: PUSH
46866: LD_EXP 104
46870: PUSH
46871: LD_VAR 0 3
46875: ARRAY
46876: IN
46877: OR
46878: IFFALSE 47987
// begin if un in mc_ape [ i ] then
46880: LD_VAR 0 1
46884: PUSH
46885: LD_EXP 103
46889: PUSH
46890: LD_VAR 0 3
46894: ARRAY
46895: IN
46896: IFFALSE 46935
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46898: LD_ADDR_EXP 103
46902: PUSH
46903: LD_EXP 103
46907: PPUSH
46908: LD_VAR 0 3
46912: PPUSH
46913: LD_EXP 103
46917: PUSH
46918: LD_VAR 0 3
46922: ARRAY
46923: PUSH
46924: LD_VAR 0 1
46928: DIFF
46929: PPUSH
46930: CALL_OW 1
46934: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46935: LD_VAR 0 1
46939: PUSH
46940: LD_EXP 104
46944: PUSH
46945: LD_VAR 0 3
46949: ARRAY
46950: IN
46951: IFFALSE 46975
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46953: LD_ADDR_EXP 104
46957: PUSH
46958: LD_EXP 104
46962: PPUSH
46963: LD_VAR 0 3
46967: PPUSH
46968: EMPTY
46969: PPUSH
46970: CALL_OW 1
46974: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
46975: LD_VAR 0 1
46979: PPUSH
46980: CALL_OW 247
46984: PUSH
46985: LD_INT 2
46987: EQUAL
46988: PUSH
46989: LD_VAR 0 1
46993: PPUSH
46994: CALL_OW 110
46998: PUSH
46999: LD_INT 20
47001: EQUAL
47002: PUSH
47003: LD_VAR 0 1
47007: PUSH
47008: LD_EXP 96
47012: PUSH
47013: LD_VAR 0 3
47017: ARRAY
47018: IN
47019: OR
47020: PUSH
47021: LD_VAR 0 1
47025: PPUSH
47026: CALL_OW 264
47030: PUSH
47031: LD_INT 12
47033: PUSH
47034: LD_INT 51
47036: PUSH
47037: LD_EXP 68
47041: PUSH
47042: LD_INT 32
47044: PUSH
47045: LD_INT 13
47047: PUSH
47048: LD_INT 52
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: IN
47059: OR
47060: AND
47061: IFFALSE 47239
// begin if un in mc_defender [ i ] then
47063: LD_VAR 0 1
47067: PUSH
47068: LD_EXP 96
47072: PUSH
47073: LD_VAR 0 3
47077: ARRAY
47078: IN
47079: IFFALSE 47118
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47081: LD_ADDR_EXP 96
47085: PUSH
47086: LD_EXP 96
47090: PPUSH
47091: LD_VAR 0 3
47095: PPUSH
47096: LD_EXP 96
47100: PUSH
47101: LD_VAR 0 3
47105: ARRAY
47106: PUSH
47107: LD_VAR 0 1
47111: DIFF
47112: PPUSH
47113: CALL_OW 1
47117: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47118: LD_ADDR_VAR 0 8
47122: PUSH
47123: LD_VAR 0 3
47127: PPUSH
47128: LD_INT 3
47130: PPUSH
47131: CALL 43791 0 2
47135: ST_TO_ADDR
// if fac then
47136: LD_VAR 0 8
47140: IFFALSE 47239
// begin for j in fac do
47142: LD_ADDR_VAR 0 4
47146: PUSH
47147: LD_VAR 0 8
47151: PUSH
47152: FOR_IN
47153: IFFALSE 47237
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47155: LD_ADDR_VAR 0 9
47159: PUSH
47160: LD_VAR 0 8
47164: PPUSH
47165: LD_VAR 0 1
47169: PPUSH
47170: CALL_OW 265
47174: PPUSH
47175: LD_VAR 0 1
47179: PPUSH
47180: CALL_OW 262
47184: PPUSH
47185: LD_VAR 0 1
47189: PPUSH
47190: CALL_OW 263
47194: PPUSH
47195: LD_VAR 0 1
47199: PPUSH
47200: CALL_OW 264
47204: PPUSH
47205: CALL 54166 0 5
47209: ST_TO_ADDR
// if components then
47210: LD_VAR 0 9
47214: IFFALSE 47235
// begin MC_InsertProduceList ( i , [ components ] ) ;
47216: LD_VAR 0 3
47220: PPUSH
47221: LD_VAR 0 9
47225: PUSH
47226: EMPTY
47227: LIST
47228: PPUSH
47229: CALL 43336 0 2
// break ;
47233: GO 47237
// end ; end ;
47235: GO 47152
47237: POP
47238: POP
// end ; end ; if GetType ( un ) = unit_building then
47239: LD_VAR 0 1
47243: PPUSH
47244: CALL_OW 247
47248: PUSH
47249: LD_INT 3
47251: EQUAL
47252: IFFALSE 47655
// begin btype := GetBType ( un ) ;
47254: LD_ADDR_VAR 0 5
47258: PUSH
47259: LD_VAR 0 1
47263: PPUSH
47264: CALL_OW 266
47268: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
47269: LD_VAR 0 5
47273: PUSH
47274: LD_INT 29
47276: PUSH
47277: LD_INT 30
47279: PUSH
47280: EMPTY
47281: LIST
47282: LIST
47283: IN
47284: IFFALSE 47357
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
47286: LD_VAR 0 1
47290: PPUSH
47291: CALL_OW 250
47295: PPUSH
47296: LD_VAR 0 1
47300: PPUSH
47301: CALL_OW 251
47305: PPUSH
47306: LD_VAR 0 1
47310: PPUSH
47311: CALL_OW 255
47315: PPUSH
47316: CALL_OW 440
47320: NOT
47321: IFFALSE 47357
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
47323: LD_VAR 0 1
47327: PPUSH
47328: CALL_OW 250
47332: PPUSH
47333: LD_VAR 0 1
47337: PPUSH
47338: CALL_OW 251
47342: PPUSH
47343: LD_VAR 0 1
47347: PPUSH
47348: CALL_OW 255
47352: PPUSH
47353: CALL_OW 441
// end ; if btype = b_warehouse then
47357: LD_VAR 0 5
47361: PUSH
47362: LD_INT 1
47364: EQUAL
47365: IFFALSE 47383
// begin btype := b_depot ;
47367: LD_ADDR_VAR 0 5
47371: PUSH
47372: LD_INT 0
47374: ST_TO_ADDR
// pos := 1 ;
47375: LD_ADDR_VAR 0 6
47379: PUSH
47380: LD_INT 1
47382: ST_TO_ADDR
// end ; if btype = b_factory then
47383: LD_VAR 0 5
47387: PUSH
47388: LD_INT 3
47390: EQUAL
47391: IFFALSE 47409
// begin btype := b_workshop ;
47393: LD_ADDR_VAR 0 5
47397: PUSH
47398: LD_INT 2
47400: ST_TO_ADDR
// pos := 1 ;
47401: LD_ADDR_VAR 0 6
47405: PUSH
47406: LD_INT 1
47408: ST_TO_ADDR
// end ; if btype = b_barracks then
47409: LD_VAR 0 5
47413: PUSH
47414: LD_INT 5
47416: EQUAL
47417: IFFALSE 47427
// btype := b_armoury ;
47419: LD_ADDR_VAR 0 5
47423: PUSH
47424: LD_INT 4
47426: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
47427: LD_VAR 0 5
47431: PUSH
47432: LD_INT 7
47434: PUSH
47435: LD_INT 8
47437: PUSH
47438: EMPTY
47439: LIST
47440: LIST
47441: IN
47442: IFFALSE 47452
// btype := b_lab ;
47444: LD_ADDR_VAR 0 5
47448: PUSH
47449: LD_INT 6
47451: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
47452: LD_ADDR_EXP 79
47456: PUSH
47457: LD_EXP 79
47461: PPUSH
47462: LD_VAR 0 3
47466: PUSH
47467: LD_EXP 79
47471: PUSH
47472: LD_VAR 0 3
47476: ARRAY
47477: PUSH
47478: LD_INT 1
47480: PLUS
47481: PUSH
47482: EMPTY
47483: LIST
47484: LIST
47485: PPUSH
47486: LD_VAR 0 5
47490: PUSH
47491: LD_VAR 0 1
47495: PPUSH
47496: CALL_OW 250
47500: PUSH
47501: LD_VAR 0 1
47505: PPUSH
47506: CALL_OW 251
47510: PUSH
47511: LD_VAR 0 1
47515: PPUSH
47516: CALL_OW 254
47520: PUSH
47521: EMPTY
47522: LIST
47523: LIST
47524: LIST
47525: LIST
47526: PPUSH
47527: CALL 56634 0 3
47531: ST_TO_ADDR
// if pos = 1 then
47532: LD_VAR 0 6
47536: PUSH
47537: LD_INT 1
47539: EQUAL
47540: IFFALSE 47655
// begin tmp := mc_build_list [ i ] ;
47542: LD_ADDR_VAR 0 7
47546: PUSH
47547: LD_EXP 79
47551: PUSH
47552: LD_VAR 0 3
47556: ARRAY
47557: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47558: LD_VAR 0 7
47562: PPUSH
47563: LD_INT 2
47565: PUSH
47566: LD_INT 30
47568: PUSH
47569: LD_INT 0
47571: PUSH
47572: EMPTY
47573: LIST
47574: LIST
47575: PUSH
47576: LD_INT 30
47578: PUSH
47579: LD_INT 1
47581: PUSH
47582: EMPTY
47583: LIST
47584: LIST
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: LIST
47590: PPUSH
47591: CALL_OW 72
47595: IFFALSE 47605
// pos := 2 ;
47597: LD_ADDR_VAR 0 6
47601: PUSH
47602: LD_INT 2
47604: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47605: LD_ADDR_VAR 0 7
47609: PUSH
47610: LD_VAR 0 7
47614: PPUSH
47615: LD_VAR 0 6
47619: PPUSH
47620: LD_VAR 0 7
47624: PPUSH
47625: CALL 56960 0 3
47629: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47630: LD_ADDR_EXP 79
47634: PUSH
47635: LD_EXP 79
47639: PPUSH
47640: LD_VAR 0 3
47644: PPUSH
47645: LD_VAR 0 7
47649: PPUSH
47650: CALL_OW 1
47654: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47655: LD_VAR 0 1
47659: PUSH
47660: LD_EXP 74
47664: PUSH
47665: LD_VAR 0 3
47669: ARRAY
47670: IN
47671: IFFALSE 47710
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47673: LD_ADDR_EXP 74
47677: PUSH
47678: LD_EXP 74
47682: PPUSH
47683: LD_VAR 0 3
47687: PPUSH
47688: LD_EXP 74
47692: PUSH
47693: LD_VAR 0 3
47697: ARRAY
47698: PUSH
47699: LD_VAR 0 1
47703: DIFF
47704: PPUSH
47705: CALL_OW 1
47709: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47710: LD_VAR 0 1
47714: PUSH
47715: LD_EXP 81
47719: PUSH
47720: LD_VAR 0 3
47724: ARRAY
47725: IN
47726: IFFALSE 47765
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47728: LD_ADDR_EXP 81
47732: PUSH
47733: LD_EXP 81
47737: PPUSH
47738: LD_VAR 0 3
47742: PPUSH
47743: LD_EXP 81
47747: PUSH
47748: LD_VAR 0 3
47752: ARRAY
47753: PUSH
47754: LD_VAR 0 1
47758: DIFF
47759: PPUSH
47760: CALL_OW 1
47764: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47765: LD_VAR 0 1
47769: PUSH
47770: LD_EXP 93
47774: PUSH
47775: LD_VAR 0 3
47779: ARRAY
47780: IN
47781: IFFALSE 47820
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47783: LD_ADDR_EXP 93
47787: PUSH
47788: LD_EXP 93
47792: PPUSH
47793: LD_VAR 0 3
47797: PPUSH
47798: LD_EXP 93
47802: PUSH
47803: LD_VAR 0 3
47807: ARRAY
47808: PUSH
47809: LD_VAR 0 1
47813: DIFF
47814: PPUSH
47815: CALL_OW 1
47819: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47820: LD_VAR 0 1
47824: PUSH
47825: LD_EXP 96
47829: PUSH
47830: LD_VAR 0 3
47834: ARRAY
47835: IN
47836: IFFALSE 47875
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47838: LD_ADDR_EXP 96
47842: PUSH
47843: LD_EXP 96
47847: PPUSH
47848: LD_VAR 0 3
47852: PPUSH
47853: LD_EXP 96
47857: PUSH
47858: LD_VAR 0 3
47862: ARRAY
47863: PUSH
47864: LD_VAR 0 1
47868: DIFF
47869: PPUSH
47870: CALL_OW 1
47874: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47875: LD_VAR 0 1
47879: PUSH
47880: LD_EXP 83
47884: PUSH
47885: LD_VAR 0 3
47889: ARRAY
47890: IN
47891: IFFALSE 47930
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47893: LD_ADDR_EXP 83
47897: PUSH
47898: LD_EXP 83
47902: PPUSH
47903: LD_VAR 0 3
47907: PPUSH
47908: LD_EXP 83
47912: PUSH
47913: LD_VAR 0 3
47917: ARRAY
47918: PUSH
47919: LD_VAR 0 1
47923: DIFF
47924: PPUSH
47925: CALL_OW 1
47929: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47930: LD_VAR 0 1
47934: PUSH
47935: LD_EXP 82
47939: PUSH
47940: LD_VAR 0 3
47944: ARRAY
47945: IN
47946: IFFALSE 47985
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47948: LD_ADDR_EXP 82
47952: PUSH
47953: LD_EXP 82
47957: PPUSH
47958: LD_VAR 0 3
47962: PPUSH
47963: LD_EXP 82
47967: PUSH
47968: LD_VAR 0 3
47972: ARRAY
47973: PUSH
47974: LD_VAR 0 1
47978: DIFF
47979: PPUSH
47980: CALL_OW 1
47984: ST_TO_ADDR
// end ; break ;
47985: GO 47989
// end ;
47987: GO 46769
47989: POP
47990: POP
// end ;
47991: LD_VAR 0 2
47995: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47996: LD_INT 0
47998: PPUSH
47999: PPUSH
48000: PPUSH
// if not mc_bases or not skirmish then
48001: LD_EXP 74
48005: NOT
48006: PUSH
48007: LD_EXP 72
48011: NOT
48012: OR
48013: IFFALSE 48017
// exit ;
48015: GO 48232
// for i = 1 to mc_bases do
48017: LD_ADDR_VAR 0 3
48021: PUSH
48022: DOUBLE
48023: LD_INT 1
48025: DEC
48026: ST_TO_ADDR
48027: LD_EXP 74
48031: PUSH
48032: FOR_TO
48033: IFFALSE 48230
// begin if building in mc_construct_list [ i ] then
48035: LD_VAR 0 1
48039: PUSH
48040: LD_EXP 81
48044: PUSH
48045: LD_VAR 0 3
48049: ARRAY
48050: IN
48051: IFFALSE 48228
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48053: LD_ADDR_EXP 81
48057: PUSH
48058: LD_EXP 81
48062: PPUSH
48063: LD_VAR 0 3
48067: PPUSH
48068: LD_EXP 81
48072: PUSH
48073: LD_VAR 0 3
48077: ARRAY
48078: PUSH
48079: LD_VAR 0 1
48083: DIFF
48084: PPUSH
48085: CALL_OW 1
48089: ST_TO_ADDR
// if building in mc_lab [ i ] then
48090: LD_VAR 0 1
48094: PUSH
48095: LD_EXP 107
48099: PUSH
48100: LD_VAR 0 3
48104: ARRAY
48105: IN
48106: IFFALSE 48161
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
48108: LD_ADDR_EXP 108
48112: PUSH
48113: LD_EXP 108
48117: PPUSH
48118: LD_VAR 0 3
48122: PPUSH
48123: LD_EXP 108
48127: PUSH
48128: LD_VAR 0 3
48132: ARRAY
48133: PPUSH
48134: LD_INT 1
48136: PPUSH
48137: LD_EXP 108
48141: PUSH
48142: LD_VAR 0 3
48146: ARRAY
48147: PPUSH
48148: LD_INT 0
48150: PPUSH
48151: CALL 56052 0 4
48155: PPUSH
48156: CALL_OW 1
48160: ST_TO_ADDR
// if not building in mc_bases [ i ] then
48161: LD_VAR 0 1
48165: PUSH
48166: LD_EXP 74
48170: PUSH
48171: LD_VAR 0 3
48175: ARRAY
48176: IN
48177: NOT
48178: IFFALSE 48224
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48180: LD_ADDR_EXP 74
48184: PUSH
48185: LD_EXP 74
48189: PPUSH
48190: LD_VAR 0 3
48194: PUSH
48195: LD_EXP 74
48199: PUSH
48200: LD_VAR 0 3
48204: ARRAY
48205: PUSH
48206: LD_INT 1
48208: PLUS
48209: PUSH
48210: EMPTY
48211: LIST
48212: LIST
48213: PPUSH
48214: LD_VAR 0 1
48218: PPUSH
48219: CALL 56634 0 3
48223: ST_TO_ADDR
// exit ;
48224: POP
48225: POP
48226: GO 48232
// end ; end ;
48228: GO 48032
48230: POP
48231: POP
// end ;
48232: LD_VAR 0 2
48236: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
48237: LD_INT 0
48239: PPUSH
48240: PPUSH
48241: PPUSH
48242: PPUSH
48243: PPUSH
48244: PPUSH
48245: PPUSH
// if not mc_bases or not skirmish then
48246: LD_EXP 74
48250: NOT
48251: PUSH
48252: LD_EXP 72
48256: NOT
48257: OR
48258: IFFALSE 48262
// exit ;
48260: GO 48923
// for i = 1 to mc_bases do
48262: LD_ADDR_VAR 0 3
48266: PUSH
48267: DOUBLE
48268: LD_INT 1
48270: DEC
48271: ST_TO_ADDR
48272: LD_EXP 74
48276: PUSH
48277: FOR_TO
48278: IFFALSE 48921
// begin if building in mc_construct_list [ i ] then
48280: LD_VAR 0 1
48284: PUSH
48285: LD_EXP 81
48289: PUSH
48290: LD_VAR 0 3
48294: ARRAY
48295: IN
48296: IFFALSE 48919
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48298: LD_ADDR_EXP 81
48302: PUSH
48303: LD_EXP 81
48307: PPUSH
48308: LD_VAR 0 3
48312: PPUSH
48313: LD_EXP 81
48317: PUSH
48318: LD_VAR 0 3
48322: ARRAY
48323: PUSH
48324: LD_VAR 0 1
48328: DIFF
48329: PPUSH
48330: CALL_OW 1
48334: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48335: LD_ADDR_EXP 74
48339: PUSH
48340: LD_EXP 74
48344: PPUSH
48345: LD_VAR 0 3
48349: PUSH
48350: LD_EXP 74
48354: PUSH
48355: LD_VAR 0 3
48359: ARRAY
48360: PUSH
48361: LD_INT 1
48363: PLUS
48364: PUSH
48365: EMPTY
48366: LIST
48367: LIST
48368: PPUSH
48369: LD_VAR 0 1
48373: PPUSH
48374: CALL 56634 0 3
48378: ST_TO_ADDR
// btype := GetBType ( building ) ;
48379: LD_ADDR_VAR 0 5
48383: PUSH
48384: LD_VAR 0 1
48388: PPUSH
48389: CALL_OW 266
48393: ST_TO_ADDR
// side := GetSide ( building ) ;
48394: LD_ADDR_VAR 0 8
48398: PUSH
48399: LD_VAR 0 1
48403: PPUSH
48404: CALL_OW 255
48408: ST_TO_ADDR
// if btype = b_lab then
48409: LD_VAR 0 5
48413: PUSH
48414: LD_INT 6
48416: EQUAL
48417: IFFALSE 48467
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
48419: LD_ADDR_EXP 107
48423: PUSH
48424: LD_EXP 107
48428: PPUSH
48429: LD_VAR 0 3
48433: PUSH
48434: LD_EXP 107
48438: PUSH
48439: LD_VAR 0 3
48443: ARRAY
48444: PUSH
48445: LD_INT 1
48447: PLUS
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PPUSH
48453: LD_VAR 0 1
48457: PPUSH
48458: CALL 56634 0 3
48462: ST_TO_ADDR
// exit ;
48463: POP
48464: POP
48465: GO 48923
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
48467: LD_VAR 0 5
48471: PUSH
48472: LD_INT 0
48474: PUSH
48475: LD_INT 2
48477: PUSH
48478: LD_INT 4
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: LIST
48485: IN
48486: IFFALSE 48610
// begin if btype = b_armoury then
48488: LD_VAR 0 5
48492: PUSH
48493: LD_INT 4
48495: EQUAL
48496: IFFALSE 48506
// btype := b_barracks ;
48498: LD_ADDR_VAR 0 5
48502: PUSH
48503: LD_INT 5
48505: ST_TO_ADDR
// if btype = b_depot then
48506: LD_VAR 0 5
48510: PUSH
48511: LD_INT 0
48513: EQUAL
48514: IFFALSE 48524
// btype := b_warehouse ;
48516: LD_ADDR_VAR 0 5
48520: PUSH
48521: LD_INT 1
48523: ST_TO_ADDR
// if btype = b_workshop then
48524: LD_VAR 0 5
48528: PUSH
48529: LD_INT 2
48531: EQUAL
48532: IFFALSE 48542
// btype := b_factory ;
48534: LD_ADDR_VAR 0 5
48538: PUSH
48539: LD_INT 3
48541: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48542: LD_VAR 0 5
48546: PPUSH
48547: LD_VAR 0 8
48551: PPUSH
48552: CALL_OW 323
48556: PUSH
48557: LD_INT 1
48559: EQUAL
48560: IFFALSE 48606
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48562: LD_ADDR_EXP 106
48566: PUSH
48567: LD_EXP 106
48571: PPUSH
48572: LD_VAR 0 3
48576: PUSH
48577: LD_EXP 106
48581: PUSH
48582: LD_VAR 0 3
48586: ARRAY
48587: PUSH
48588: LD_INT 1
48590: PLUS
48591: PUSH
48592: EMPTY
48593: LIST
48594: LIST
48595: PPUSH
48596: LD_VAR 0 1
48600: PPUSH
48601: CALL 56634 0 3
48605: ST_TO_ADDR
// exit ;
48606: POP
48607: POP
48608: GO 48923
// end ; if btype in [ b_bunker , b_turret ] then
48610: LD_VAR 0 5
48614: PUSH
48615: LD_INT 32
48617: PUSH
48618: LD_INT 33
48620: PUSH
48621: EMPTY
48622: LIST
48623: LIST
48624: IN
48625: IFFALSE 48915
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48627: LD_ADDR_EXP 82
48631: PUSH
48632: LD_EXP 82
48636: PPUSH
48637: LD_VAR 0 3
48641: PUSH
48642: LD_EXP 82
48646: PUSH
48647: LD_VAR 0 3
48651: ARRAY
48652: PUSH
48653: LD_INT 1
48655: PLUS
48656: PUSH
48657: EMPTY
48658: LIST
48659: LIST
48660: PPUSH
48661: LD_VAR 0 1
48665: PPUSH
48666: CALL 56634 0 3
48670: ST_TO_ADDR
// if btype = b_bunker then
48671: LD_VAR 0 5
48675: PUSH
48676: LD_INT 32
48678: EQUAL
48679: IFFALSE 48915
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48681: LD_ADDR_EXP 83
48685: PUSH
48686: LD_EXP 83
48690: PPUSH
48691: LD_VAR 0 3
48695: PUSH
48696: LD_EXP 83
48700: PUSH
48701: LD_VAR 0 3
48705: ARRAY
48706: PUSH
48707: LD_INT 1
48709: PLUS
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PPUSH
48715: LD_VAR 0 1
48719: PPUSH
48720: CALL 56634 0 3
48724: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48725: LD_ADDR_VAR 0 6
48729: PUSH
48730: LD_EXP 74
48734: PUSH
48735: LD_VAR 0 3
48739: ARRAY
48740: PPUSH
48741: LD_INT 25
48743: PUSH
48744: LD_INT 1
48746: PUSH
48747: EMPTY
48748: LIST
48749: LIST
48750: PUSH
48751: LD_INT 3
48753: PUSH
48754: LD_INT 54
48756: PUSH
48757: EMPTY
48758: LIST
48759: PUSH
48760: EMPTY
48761: LIST
48762: LIST
48763: PUSH
48764: EMPTY
48765: LIST
48766: LIST
48767: PPUSH
48768: CALL_OW 72
48772: ST_TO_ADDR
// if tmp then
48773: LD_VAR 0 6
48777: IFFALSE 48783
// exit ;
48779: POP
48780: POP
48781: GO 48923
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48783: LD_ADDR_VAR 0 6
48787: PUSH
48788: LD_EXP 74
48792: PUSH
48793: LD_VAR 0 3
48797: ARRAY
48798: PPUSH
48799: LD_INT 2
48801: PUSH
48802: LD_INT 30
48804: PUSH
48805: LD_INT 4
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: PUSH
48812: LD_INT 30
48814: PUSH
48815: LD_INT 5
48817: PUSH
48818: EMPTY
48819: LIST
48820: LIST
48821: PUSH
48822: EMPTY
48823: LIST
48824: LIST
48825: LIST
48826: PPUSH
48827: CALL_OW 72
48831: ST_TO_ADDR
// if not tmp then
48832: LD_VAR 0 6
48836: NOT
48837: IFFALSE 48843
// exit ;
48839: POP
48840: POP
48841: GO 48923
// for j in tmp do
48843: LD_ADDR_VAR 0 4
48847: PUSH
48848: LD_VAR 0 6
48852: PUSH
48853: FOR_IN
48854: IFFALSE 48913
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48856: LD_ADDR_VAR 0 7
48860: PUSH
48861: LD_VAR 0 4
48865: PPUSH
48866: CALL_OW 313
48870: PPUSH
48871: LD_INT 25
48873: PUSH
48874: LD_INT 1
48876: PUSH
48877: EMPTY
48878: LIST
48879: LIST
48880: PPUSH
48881: CALL_OW 72
48885: ST_TO_ADDR
// if units then
48886: LD_VAR 0 7
48890: IFFALSE 48911
// begin ComExitBuilding ( units [ 1 ] ) ;
48892: LD_VAR 0 7
48896: PUSH
48897: LD_INT 1
48899: ARRAY
48900: PPUSH
48901: CALL_OW 122
// exit ;
48905: POP
48906: POP
48907: POP
48908: POP
48909: GO 48923
// end ; end ;
48911: GO 48853
48913: POP
48914: POP
// end ; end ; exit ;
48915: POP
48916: POP
48917: GO 48923
// end ; end ;
48919: GO 48277
48921: POP
48922: POP
// end ;
48923: LD_VAR 0 2
48927: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48928: LD_INT 0
48930: PPUSH
48931: PPUSH
48932: PPUSH
48933: PPUSH
48934: PPUSH
48935: PPUSH
48936: PPUSH
// if not mc_bases or not skirmish then
48937: LD_EXP 74
48941: NOT
48942: PUSH
48943: LD_EXP 72
48947: NOT
48948: OR
48949: IFFALSE 48953
// exit ;
48951: GO 49184
// btype := GetBType ( building ) ;
48953: LD_ADDR_VAR 0 6
48957: PUSH
48958: LD_VAR 0 1
48962: PPUSH
48963: CALL_OW 266
48967: ST_TO_ADDR
// x := GetX ( building ) ;
48968: LD_ADDR_VAR 0 7
48972: PUSH
48973: LD_VAR 0 1
48977: PPUSH
48978: CALL_OW 250
48982: ST_TO_ADDR
// y := GetY ( building ) ;
48983: LD_ADDR_VAR 0 8
48987: PUSH
48988: LD_VAR 0 1
48992: PPUSH
48993: CALL_OW 251
48997: ST_TO_ADDR
// d := GetDir ( building ) ;
48998: LD_ADDR_VAR 0 9
49002: PUSH
49003: LD_VAR 0 1
49007: PPUSH
49008: CALL_OW 254
49012: ST_TO_ADDR
// for i = 1 to mc_bases do
49013: LD_ADDR_VAR 0 4
49017: PUSH
49018: DOUBLE
49019: LD_INT 1
49021: DEC
49022: ST_TO_ADDR
49023: LD_EXP 74
49027: PUSH
49028: FOR_TO
49029: IFFALSE 49182
// begin if not mc_build_list [ i ] then
49031: LD_EXP 79
49035: PUSH
49036: LD_VAR 0 4
49040: ARRAY
49041: NOT
49042: IFFALSE 49046
// continue ;
49044: GO 49028
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
49046: LD_VAR 0 6
49050: PUSH
49051: LD_VAR 0 7
49055: PUSH
49056: LD_VAR 0 8
49060: PUSH
49061: LD_VAR 0 9
49065: PUSH
49066: EMPTY
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: PPUSH
49072: LD_EXP 79
49076: PUSH
49077: LD_VAR 0 4
49081: ARRAY
49082: PUSH
49083: LD_INT 1
49085: ARRAY
49086: PPUSH
49087: CALL 62803 0 2
49091: IFFALSE 49180
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
49093: LD_ADDR_EXP 79
49097: PUSH
49098: LD_EXP 79
49102: PPUSH
49103: LD_VAR 0 4
49107: PPUSH
49108: LD_EXP 79
49112: PUSH
49113: LD_VAR 0 4
49117: ARRAY
49118: PPUSH
49119: LD_INT 1
49121: PPUSH
49122: CALL_OW 3
49126: PPUSH
49127: CALL_OW 1
49131: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
49132: LD_ADDR_EXP 81
49136: PUSH
49137: LD_EXP 81
49141: PPUSH
49142: LD_VAR 0 4
49146: PUSH
49147: LD_EXP 81
49151: PUSH
49152: LD_VAR 0 4
49156: ARRAY
49157: PUSH
49158: LD_INT 1
49160: PLUS
49161: PUSH
49162: EMPTY
49163: LIST
49164: LIST
49165: PPUSH
49166: LD_VAR 0 1
49170: PPUSH
49171: CALL 56634 0 3
49175: ST_TO_ADDR
// exit ;
49176: POP
49177: POP
49178: GO 49184
// end ; end ;
49180: GO 49028
49182: POP
49183: POP
// end ;
49184: LD_VAR 0 3
49188: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
49189: LD_INT 0
49191: PPUSH
49192: PPUSH
49193: PPUSH
// if not mc_bases or not skirmish then
49194: LD_EXP 74
49198: NOT
49199: PUSH
49200: LD_EXP 72
49204: NOT
49205: OR
49206: IFFALSE 49210
// exit ;
49208: GO 49400
// for i = 1 to mc_bases do
49210: LD_ADDR_VAR 0 4
49214: PUSH
49215: DOUBLE
49216: LD_INT 1
49218: DEC
49219: ST_TO_ADDR
49220: LD_EXP 74
49224: PUSH
49225: FOR_TO
49226: IFFALSE 49313
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
49228: LD_VAR 0 1
49232: PUSH
49233: LD_EXP 82
49237: PUSH
49238: LD_VAR 0 4
49242: ARRAY
49243: IN
49244: PUSH
49245: LD_VAR 0 1
49249: PUSH
49250: LD_EXP 83
49254: PUSH
49255: LD_VAR 0 4
49259: ARRAY
49260: IN
49261: NOT
49262: AND
49263: IFFALSE 49311
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49265: LD_ADDR_EXP 83
49269: PUSH
49270: LD_EXP 83
49274: PPUSH
49275: LD_VAR 0 4
49279: PUSH
49280: LD_EXP 83
49284: PUSH
49285: LD_VAR 0 4
49289: ARRAY
49290: PUSH
49291: LD_INT 1
49293: PLUS
49294: PUSH
49295: EMPTY
49296: LIST
49297: LIST
49298: PPUSH
49299: LD_VAR 0 1
49303: PPUSH
49304: CALL 56634 0 3
49308: ST_TO_ADDR
// break ;
49309: GO 49313
// end ; end ;
49311: GO 49225
49313: POP
49314: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
49315: LD_VAR 0 1
49319: PPUSH
49320: CALL_OW 257
49324: PUSH
49325: LD_EXP 100
49329: IN
49330: PUSH
49331: LD_VAR 0 1
49335: PPUSH
49336: CALL_OW 266
49340: PUSH
49341: LD_INT 5
49343: EQUAL
49344: AND
49345: PUSH
49346: LD_VAR 0 2
49350: PPUSH
49351: CALL_OW 110
49355: PUSH
49356: LD_INT 18
49358: NONEQUAL
49359: AND
49360: IFFALSE 49400
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
49362: LD_VAR 0 2
49366: PPUSH
49367: CALL_OW 257
49371: PUSH
49372: LD_INT 5
49374: PUSH
49375: LD_INT 8
49377: PUSH
49378: LD_INT 9
49380: PUSH
49381: EMPTY
49382: LIST
49383: LIST
49384: LIST
49385: IN
49386: IFFALSE 49400
// SetClass ( unit , 1 ) ;
49388: LD_VAR 0 2
49392: PPUSH
49393: LD_INT 1
49395: PPUSH
49396: CALL_OW 336
// end ;
49400: LD_VAR 0 3
49404: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
49405: LD_INT 0
49407: PPUSH
49408: PPUSH
// if not mc_bases or not skirmish then
49409: LD_EXP 74
49413: NOT
49414: PUSH
49415: LD_EXP 72
49419: NOT
49420: OR
49421: IFFALSE 49425
// exit ;
49423: GO 49541
// if GetLives ( abandoned_vehicle ) > 250 then
49425: LD_VAR 0 2
49429: PPUSH
49430: CALL_OW 256
49434: PUSH
49435: LD_INT 250
49437: GREATER
49438: IFFALSE 49442
// exit ;
49440: GO 49541
// for i = 1 to mc_bases do
49442: LD_ADDR_VAR 0 6
49446: PUSH
49447: DOUBLE
49448: LD_INT 1
49450: DEC
49451: ST_TO_ADDR
49452: LD_EXP 74
49456: PUSH
49457: FOR_TO
49458: IFFALSE 49539
// begin if driver in mc_bases [ i ] then
49460: LD_VAR 0 1
49464: PUSH
49465: LD_EXP 74
49469: PUSH
49470: LD_VAR 0 6
49474: ARRAY
49475: IN
49476: IFFALSE 49537
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49478: LD_VAR 0 1
49482: PPUSH
49483: LD_EXP 74
49487: PUSH
49488: LD_VAR 0 6
49492: ARRAY
49493: PPUSH
49494: LD_INT 2
49496: PUSH
49497: LD_INT 30
49499: PUSH
49500: LD_INT 0
49502: PUSH
49503: EMPTY
49504: LIST
49505: LIST
49506: PUSH
49507: LD_INT 30
49509: PUSH
49510: LD_INT 1
49512: PUSH
49513: EMPTY
49514: LIST
49515: LIST
49516: PUSH
49517: EMPTY
49518: LIST
49519: LIST
49520: LIST
49521: PPUSH
49522: CALL_OW 72
49526: PUSH
49527: LD_INT 1
49529: ARRAY
49530: PPUSH
49531: CALL_OW 112
// break ;
49535: GO 49539
// end ; end ;
49537: GO 49457
49539: POP
49540: POP
// end ; end_of_file
49541: LD_VAR 0 5
49545: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49546: LD_INT 0
49548: PPUSH
49549: PPUSH
// if exist_mode then
49550: LD_VAR 0 2
49554: IFFALSE 49579
// unit := CreateCharacter ( prefix & ident ) else
49556: LD_ADDR_VAR 0 5
49560: PUSH
49561: LD_VAR 0 3
49565: PUSH
49566: LD_VAR 0 1
49570: STR
49571: PPUSH
49572: CALL_OW 34
49576: ST_TO_ADDR
49577: GO 49594
// unit := NewCharacter ( ident ) ;
49579: LD_ADDR_VAR 0 5
49583: PUSH
49584: LD_VAR 0 1
49588: PPUSH
49589: CALL_OW 25
49593: ST_TO_ADDR
// result := unit ;
49594: LD_ADDR_VAR 0 4
49598: PUSH
49599: LD_VAR 0 5
49603: ST_TO_ADDR
// end ;
49604: LD_VAR 0 4
49608: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49609: LD_INT 0
49611: PPUSH
49612: PPUSH
// if not side or not nation then
49613: LD_VAR 0 1
49617: NOT
49618: PUSH
49619: LD_VAR 0 2
49623: NOT
49624: OR
49625: IFFALSE 49629
// exit ;
49627: GO 50273
// case nation of nation_american :
49629: LD_VAR 0 2
49633: PUSH
49634: LD_INT 1
49636: DOUBLE
49637: EQUAL
49638: IFTRUE 49642
49640: GO 49816
49642: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
49643: LD_ADDR_VAR 0 4
49647: PUSH
49648: LD_INT 35
49650: PUSH
49651: LD_INT 45
49653: PUSH
49654: LD_INT 46
49656: PUSH
49657: LD_INT 47
49659: PUSH
49660: LD_INT 1
49662: PUSH
49663: LD_INT 2
49665: PUSH
49666: LD_INT 6
49668: PUSH
49669: LD_INT 15
49671: PUSH
49672: LD_INT 16
49674: PUSH
49675: LD_INT 7
49677: PUSH
49678: LD_INT 12
49680: PUSH
49681: LD_INT 13
49683: PUSH
49684: LD_INT 10
49686: PUSH
49687: LD_INT 14
49689: PUSH
49690: LD_INT 20
49692: PUSH
49693: LD_INT 21
49695: PUSH
49696: LD_INT 22
49698: PUSH
49699: LD_INT 25
49701: PUSH
49702: LD_INT 32
49704: PUSH
49705: LD_INT 27
49707: PUSH
49708: LD_INT 36
49710: PUSH
49711: LD_INT 69
49713: PUSH
49714: LD_INT 39
49716: PUSH
49717: LD_INT 34
49719: PUSH
49720: LD_INT 40
49722: PUSH
49723: LD_INT 48
49725: PUSH
49726: LD_INT 49
49728: PUSH
49729: LD_INT 50
49731: PUSH
49732: LD_INT 51
49734: PUSH
49735: LD_INT 52
49737: PUSH
49738: LD_INT 53
49740: PUSH
49741: LD_INT 54
49743: PUSH
49744: LD_INT 55
49746: PUSH
49747: LD_INT 56
49749: PUSH
49750: LD_INT 57
49752: PUSH
49753: LD_INT 58
49755: PUSH
49756: LD_INT 59
49758: PUSH
49759: LD_INT 60
49761: PUSH
49762: LD_INT 61
49764: PUSH
49765: LD_INT 62
49767: PUSH
49768: LD_INT 80
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: LIST
49775: LIST
49776: LIST
49777: LIST
49778: LIST
49779: LIST
49780: LIST
49781: LIST
49782: LIST
49783: LIST
49784: LIST
49785: LIST
49786: LIST
49787: LIST
49788: LIST
49789: LIST
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: LIST
49795: LIST
49796: LIST
49797: LIST
49798: LIST
49799: LIST
49800: LIST
49801: LIST
49802: LIST
49803: LIST
49804: LIST
49805: LIST
49806: LIST
49807: LIST
49808: LIST
49809: LIST
49810: LIST
49811: LIST
49812: LIST
49813: ST_TO_ADDR
49814: GO 50197
49816: LD_INT 2
49818: DOUBLE
49819: EQUAL
49820: IFTRUE 49824
49822: GO 50006
49824: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
49825: LD_ADDR_VAR 0 4
49829: PUSH
49830: LD_INT 35
49832: PUSH
49833: LD_INT 45
49835: PUSH
49836: LD_INT 46
49838: PUSH
49839: LD_INT 47
49841: PUSH
49842: LD_INT 70
49844: PUSH
49845: LD_INT 1
49847: PUSH
49848: LD_INT 11
49850: PUSH
49851: LD_INT 3
49853: PUSH
49854: LD_INT 4
49856: PUSH
49857: LD_INT 5
49859: PUSH
49860: LD_INT 6
49862: PUSH
49863: LD_INT 15
49865: PUSH
49866: LD_INT 18
49868: PUSH
49869: LD_INT 7
49871: PUSH
49872: LD_INT 17
49874: PUSH
49875: LD_INT 8
49877: PUSH
49878: LD_INT 20
49880: PUSH
49881: LD_INT 21
49883: PUSH
49884: LD_INT 22
49886: PUSH
49887: LD_INT 72
49889: PUSH
49890: LD_INT 26
49892: PUSH
49893: LD_INT 69
49895: PUSH
49896: LD_INT 39
49898: PUSH
49899: LD_INT 40
49901: PUSH
49902: LD_INT 41
49904: PUSH
49905: LD_INT 42
49907: PUSH
49908: LD_INT 43
49910: PUSH
49911: LD_INT 48
49913: PUSH
49914: LD_INT 49
49916: PUSH
49917: LD_INT 50
49919: PUSH
49920: LD_INT 51
49922: PUSH
49923: LD_INT 52
49925: PUSH
49926: LD_INT 53
49928: PUSH
49929: LD_INT 54
49931: PUSH
49932: LD_INT 55
49934: PUSH
49935: LD_INT 56
49937: PUSH
49938: LD_INT 60
49940: PUSH
49941: LD_INT 61
49943: PUSH
49944: LD_INT 62
49946: PUSH
49947: LD_INT 66
49949: PUSH
49950: LD_INT 67
49952: PUSH
49953: LD_INT 68
49955: PUSH
49956: LD_INT 81
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: LIST
49963: LIST
49964: LIST
49965: LIST
49966: LIST
49967: LIST
49968: LIST
49969: LIST
49970: LIST
49971: LIST
49972: LIST
49973: LIST
49974: LIST
49975: LIST
49976: LIST
49977: LIST
49978: LIST
49979: LIST
49980: LIST
49981: LIST
49982: LIST
49983: LIST
49984: LIST
49985: LIST
49986: LIST
49987: LIST
49988: LIST
49989: LIST
49990: LIST
49991: LIST
49992: LIST
49993: LIST
49994: LIST
49995: LIST
49996: LIST
49997: LIST
49998: LIST
49999: LIST
50000: LIST
50001: LIST
50002: LIST
50003: ST_TO_ADDR
50004: GO 50197
50006: LD_INT 3
50008: DOUBLE
50009: EQUAL
50010: IFTRUE 50014
50012: GO 50196
50014: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
50015: LD_ADDR_VAR 0 4
50019: PUSH
50020: LD_INT 46
50022: PUSH
50023: LD_INT 47
50025: PUSH
50026: LD_INT 1
50028: PUSH
50029: LD_INT 2
50031: PUSH
50032: LD_INT 11
50034: PUSH
50035: LD_INT 9
50037: PUSH
50038: LD_INT 20
50040: PUSH
50041: LD_INT 19
50043: PUSH
50044: LD_INT 21
50046: PUSH
50047: LD_INT 24
50049: PUSH
50050: LD_INT 22
50052: PUSH
50053: LD_INT 25
50055: PUSH
50056: LD_INT 28
50058: PUSH
50059: LD_INT 29
50061: PUSH
50062: LD_INT 30
50064: PUSH
50065: LD_INT 31
50067: PUSH
50068: LD_INT 37
50070: PUSH
50071: LD_INT 38
50073: PUSH
50074: LD_INT 32
50076: PUSH
50077: LD_INT 27
50079: PUSH
50080: LD_INT 33
50082: PUSH
50083: LD_INT 69
50085: PUSH
50086: LD_INT 39
50088: PUSH
50089: LD_INT 34
50091: PUSH
50092: LD_INT 40
50094: PUSH
50095: LD_INT 71
50097: PUSH
50098: LD_INT 23
50100: PUSH
50101: LD_INT 44
50103: PUSH
50104: LD_INT 48
50106: PUSH
50107: LD_INT 49
50109: PUSH
50110: LD_INT 50
50112: PUSH
50113: LD_INT 51
50115: PUSH
50116: LD_INT 52
50118: PUSH
50119: LD_INT 53
50121: PUSH
50122: LD_INT 54
50124: PUSH
50125: LD_INT 55
50127: PUSH
50128: LD_INT 56
50130: PUSH
50131: LD_INT 57
50133: PUSH
50134: LD_INT 58
50136: PUSH
50137: LD_INT 59
50139: PUSH
50140: LD_INT 63
50142: PUSH
50143: LD_INT 64
50145: PUSH
50146: LD_INT 65
50148: PUSH
50149: EMPTY
50150: LIST
50151: LIST
50152: LIST
50153: LIST
50154: LIST
50155: LIST
50156: LIST
50157: LIST
50158: LIST
50159: LIST
50160: LIST
50161: LIST
50162: LIST
50163: LIST
50164: LIST
50165: LIST
50166: LIST
50167: LIST
50168: LIST
50169: LIST
50170: LIST
50171: LIST
50172: LIST
50173: LIST
50174: LIST
50175: LIST
50176: LIST
50177: LIST
50178: LIST
50179: LIST
50180: LIST
50181: LIST
50182: LIST
50183: LIST
50184: LIST
50185: LIST
50186: LIST
50187: LIST
50188: LIST
50189: LIST
50190: LIST
50191: LIST
50192: LIST
50193: ST_TO_ADDR
50194: GO 50197
50196: POP
// if state > - 1 and state < 3 then
50197: LD_VAR 0 3
50201: PUSH
50202: LD_INT 1
50204: NEG
50205: GREATER
50206: PUSH
50207: LD_VAR 0 3
50211: PUSH
50212: LD_INT 3
50214: LESS
50215: AND
50216: IFFALSE 50273
// for i in result do
50218: LD_ADDR_VAR 0 5
50222: PUSH
50223: LD_VAR 0 4
50227: PUSH
50228: FOR_IN
50229: IFFALSE 50271
// if GetTech ( i , side ) <> state then
50231: LD_VAR 0 5
50235: PPUSH
50236: LD_VAR 0 1
50240: PPUSH
50241: CALL_OW 321
50245: PUSH
50246: LD_VAR 0 3
50250: NONEQUAL
50251: IFFALSE 50269
// result := result diff i ;
50253: LD_ADDR_VAR 0 4
50257: PUSH
50258: LD_VAR 0 4
50262: PUSH
50263: LD_VAR 0 5
50267: DIFF
50268: ST_TO_ADDR
50269: GO 50228
50271: POP
50272: POP
// end ;
50273: LD_VAR 0 4
50277: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50278: LD_INT 0
50280: PPUSH
50281: PPUSH
50282: PPUSH
// result := true ;
50283: LD_ADDR_VAR 0 3
50287: PUSH
50288: LD_INT 1
50290: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50291: LD_ADDR_VAR 0 5
50295: PUSH
50296: LD_VAR 0 2
50300: PPUSH
50301: CALL_OW 480
50305: ST_TO_ADDR
// if not tmp then
50306: LD_VAR 0 5
50310: NOT
50311: IFFALSE 50315
// exit ;
50313: GO 50364
// for i in tmp do
50315: LD_ADDR_VAR 0 4
50319: PUSH
50320: LD_VAR 0 5
50324: PUSH
50325: FOR_IN
50326: IFFALSE 50362
// if GetTech ( i , side ) <> state_researched then
50328: LD_VAR 0 4
50332: PPUSH
50333: LD_VAR 0 1
50337: PPUSH
50338: CALL_OW 321
50342: PUSH
50343: LD_INT 2
50345: NONEQUAL
50346: IFFALSE 50360
// begin result := false ;
50348: LD_ADDR_VAR 0 3
50352: PUSH
50353: LD_INT 0
50355: ST_TO_ADDR
// exit ;
50356: POP
50357: POP
50358: GO 50364
// end ;
50360: GO 50325
50362: POP
50363: POP
// end ;
50364: LD_VAR 0 3
50368: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50369: LD_INT 0
50371: PPUSH
50372: PPUSH
50373: PPUSH
50374: PPUSH
50375: PPUSH
50376: PPUSH
50377: PPUSH
50378: PPUSH
50379: PPUSH
50380: PPUSH
50381: PPUSH
50382: PPUSH
50383: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50384: LD_VAR 0 1
50388: NOT
50389: PUSH
50390: LD_VAR 0 1
50394: PPUSH
50395: CALL_OW 257
50399: PUSH
50400: LD_INT 9
50402: NONEQUAL
50403: OR
50404: IFFALSE 50408
// exit ;
50406: GO 50981
// side := GetSide ( unit ) ;
50408: LD_ADDR_VAR 0 9
50412: PUSH
50413: LD_VAR 0 1
50417: PPUSH
50418: CALL_OW 255
50422: ST_TO_ADDR
// tech_space := tech_spacanom ;
50423: LD_ADDR_VAR 0 12
50427: PUSH
50428: LD_INT 29
50430: ST_TO_ADDR
// tech_time := tech_taurad ;
50431: LD_ADDR_VAR 0 13
50435: PUSH
50436: LD_INT 28
50438: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50439: LD_ADDR_VAR 0 11
50443: PUSH
50444: LD_VAR 0 1
50448: PPUSH
50449: CALL_OW 310
50453: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50454: LD_VAR 0 11
50458: PPUSH
50459: CALL_OW 247
50463: PUSH
50464: LD_INT 2
50466: EQUAL
50467: IFFALSE 50471
// exit ;
50469: GO 50981
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50471: LD_ADDR_VAR 0 8
50475: PUSH
50476: LD_INT 81
50478: PUSH
50479: LD_VAR 0 9
50483: PUSH
50484: EMPTY
50485: LIST
50486: LIST
50487: PUSH
50488: LD_INT 3
50490: PUSH
50491: LD_INT 21
50493: PUSH
50494: LD_INT 3
50496: PUSH
50497: EMPTY
50498: LIST
50499: LIST
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: EMPTY
50506: LIST
50507: LIST
50508: PPUSH
50509: CALL_OW 69
50513: ST_TO_ADDR
// if not tmp then
50514: LD_VAR 0 8
50518: NOT
50519: IFFALSE 50523
// exit ;
50521: GO 50981
// if in_unit then
50523: LD_VAR 0 11
50527: IFFALSE 50551
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50529: LD_ADDR_VAR 0 10
50533: PUSH
50534: LD_VAR 0 8
50538: PPUSH
50539: LD_VAR 0 11
50543: PPUSH
50544: CALL_OW 74
50548: ST_TO_ADDR
50549: GO 50571
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50551: LD_ADDR_VAR 0 10
50555: PUSH
50556: LD_VAR 0 8
50560: PPUSH
50561: LD_VAR 0 1
50565: PPUSH
50566: CALL_OW 74
50570: ST_TO_ADDR
// if not enemy then
50571: LD_VAR 0 10
50575: NOT
50576: IFFALSE 50580
// exit ;
50578: GO 50981
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50580: LD_VAR 0 11
50584: PUSH
50585: LD_VAR 0 11
50589: PPUSH
50590: LD_VAR 0 10
50594: PPUSH
50595: CALL_OW 296
50599: PUSH
50600: LD_INT 13
50602: GREATER
50603: AND
50604: PUSH
50605: LD_VAR 0 1
50609: PPUSH
50610: LD_VAR 0 10
50614: PPUSH
50615: CALL_OW 296
50619: PUSH
50620: LD_INT 12
50622: GREATER
50623: OR
50624: IFFALSE 50628
// exit ;
50626: GO 50981
// missile := [ 1 ] ;
50628: LD_ADDR_VAR 0 14
50632: PUSH
50633: LD_INT 1
50635: PUSH
50636: EMPTY
50637: LIST
50638: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50639: LD_VAR 0 9
50643: PPUSH
50644: LD_VAR 0 12
50648: PPUSH
50649: CALL_OW 325
50653: IFFALSE 50682
// missile := Insert ( missile , missile + 1 , 2 ) ;
50655: LD_ADDR_VAR 0 14
50659: PUSH
50660: LD_VAR 0 14
50664: PPUSH
50665: LD_VAR 0 14
50669: PUSH
50670: LD_INT 1
50672: PLUS
50673: PPUSH
50674: LD_INT 2
50676: PPUSH
50677: CALL_OW 2
50681: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50682: LD_VAR 0 9
50686: PPUSH
50687: LD_VAR 0 13
50691: PPUSH
50692: CALL_OW 325
50696: PUSH
50697: LD_VAR 0 10
50701: PPUSH
50702: CALL_OW 255
50706: PPUSH
50707: LD_VAR 0 13
50711: PPUSH
50712: CALL_OW 325
50716: NOT
50717: AND
50718: IFFALSE 50747
// missile := Insert ( missile , missile + 1 , 3 ) ;
50720: LD_ADDR_VAR 0 14
50724: PUSH
50725: LD_VAR 0 14
50729: PPUSH
50730: LD_VAR 0 14
50734: PUSH
50735: LD_INT 1
50737: PLUS
50738: PPUSH
50739: LD_INT 3
50741: PPUSH
50742: CALL_OW 2
50746: ST_TO_ADDR
// if missile < 2 then
50747: LD_VAR 0 14
50751: PUSH
50752: LD_INT 2
50754: LESS
50755: IFFALSE 50759
// exit ;
50757: GO 50981
// x := GetX ( enemy ) ;
50759: LD_ADDR_VAR 0 4
50763: PUSH
50764: LD_VAR 0 10
50768: PPUSH
50769: CALL_OW 250
50773: ST_TO_ADDR
// y := GetY ( enemy ) ;
50774: LD_ADDR_VAR 0 5
50778: PUSH
50779: LD_VAR 0 10
50783: PPUSH
50784: CALL_OW 251
50788: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50789: LD_ADDR_VAR 0 6
50793: PUSH
50794: LD_VAR 0 4
50798: PUSH
50799: LD_INT 1
50801: NEG
50802: PPUSH
50803: LD_INT 1
50805: PPUSH
50806: CALL_OW 12
50810: PLUS
50811: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50812: LD_ADDR_VAR 0 7
50816: PUSH
50817: LD_VAR 0 5
50821: PUSH
50822: LD_INT 1
50824: NEG
50825: PPUSH
50826: LD_INT 1
50828: PPUSH
50829: CALL_OW 12
50833: PLUS
50834: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50835: LD_VAR 0 6
50839: PPUSH
50840: LD_VAR 0 7
50844: PPUSH
50845: CALL_OW 488
50849: NOT
50850: IFFALSE 50872
// begin _x := x ;
50852: LD_ADDR_VAR 0 6
50856: PUSH
50857: LD_VAR 0 4
50861: ST_TO_ADDR
// _y := y ;
50862: LD_ADDR_VAR 0 7
50866: PUSH
50867: LD_VAR 0 5
50871: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50872: LD_ADDR_VAR 0 3
50876: PUSH
50877: LD_INT 1
50879: PPUSH
50880: LD_VAR 0 14
50884: PPUSH
50885: CALL_OW 12
50889: ST_TO_ADDR
// case i of 1 :
50890: LD_VAR 0 3
50894: PUSH
50895: LD_INT 1
50897: DOUBLE
50898: EQUAL
50899: IFTRUE 50903
50901: GO 50920
50903: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50904: LD_VAR 0 1
50908: PPUSH
50909: LD_VAR 0 10
50913: PPUSH
50914: CALL_OW 115
50918: GO 50981
50920: LD_INT 2
50922: DOUBLE
50923: EQUAL
50924: IFTRUE 50928
50926: GO 50950
50928: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50929: LD_VAR 0 1
50933: PPUSH
50934: LD_VAR 0 6
50938: PPUSH
50939: LD_VAR 0 7
50943: PPUSH
50944: CALL_OW 153
50948: GO 50981
50950: LD_INT 3
50952: DOUBLE
50953: EQUAL
50954: IFTRUE 50958
50956: GO 50980
50958: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50959: LD_VAR 0 1
50963: PPUSH
50964: LD_VAR 0 6
50968: PPUSH
50969: LD_VAR 0 7
50973: PPUSH
50974: CALL_OW 154
50978: GO 50981
50980: POP
// end ;
50981: LD_VAR 0 2
50985: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50986: LD_INT 0
50988: PPUSH
50989: PPUSH
50990: PPUSH
50991: PPUSH
50992: PPUSH
50993: PPUSH
// if not unit or not building then
50994: LD_VAR 0 1
50998: NOT
50999: PUSH
51000: LD_VAR 0 2
51004: NOT
51005: OR
51006: IFFALSE 51010
// exit ;
51008: GO 51168
// x := GetX ( building ) ;
51010: LD_ADDR_VAR 0 5
51014: PUSH
51015: LD_VAR 0 2
51019: PPUSH
51020: CALL_OW 250
51024: ST_TO_ADDR
// y := GetY ( building ) ;
51025: LD_ADDR_VAR 0 6
51029: PUSH
51030: LD_VAR 0 2
51034: PPUSH
51035: CALL_OW 251
51039: ST_TO_ADDR
// for i = 0 to 5 do
51040: LD_ADDR_VAR 0 4
51044: PUSH
51045: DOUBLE
51046: LD_INT 0
51048: DEC
51049: ST_TO_ADDR
51050: LD_INT 5
51052: PUSH
51053: FOR_TO
51054: IFFALSE 51166
// begin _x := ShiftX ( x , i , 3 ) ;
51056: LD_ADDR_VAR 0 7
51060: PUSH
51061: LD_VAR 0 5
51065: PPUSH
51066: LD_VAR 0 4
51070: PPUSH
51071: LD_INT 3
51073: PPUSH
51074: CALL_OW 272
51078: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
51079: LD_ADDR_VAR 0 8
51083: PUSH
51084: LD_VAR 0 6
51088: PPUSH
51089: LD_VAR 0 4
51093: PPUSH
51094: LD_INT 3
51096: PPUSH
51097: CALL_OW 273
51101: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51102: LD_VAR 0 7
51106: PPUSH
51107: LD_VAR 0 8
51111: PPUSH
51112: CALL_OW 488
51116: NOT
51117: IFFALSE 51121
// continue ;
51119: GO 51053
// if HexInfo ( _x , _y ) = 0 then
51121: LD_VAR 0 7
51125: PPUSH
51126: LD_VAR 0 8
51130: PPUSH
51131: CALL_OW 428
51135: PUSH
51136: LD_INT 0
51138: EQUAL
51139: IFFALSE 51164
// begin ComMoveXY ( unit , _x , _y ) ;
51141: LD_VAR 0 1
51145: PPUSH
51146: LD_VAR 0 7
51150: PPUSH
51151: LD_VAR 0 8
51155: PPUSH
51156: CALL_OW 111
// exit ;
51160: POP
51161: POP
51162: GO 51168
// end ; end ;
51164: GO 51053
51166: POP
51167: POP
// end ;
51168: LD_VAR 0 3
51172: RET
// export function ScanBase ( side , base_area ) ; begin
51173: LD_INT 0
51175: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
51176: LD_ADDR_VAR 0 3
51180: PUSH
51181: LD_VAR 0 2
51185: PPUSH
51186: LD_INT 81
51188: PUSH
51189: LD_VAR 0 1
51193: PUSH
51194: EMPTY
51195: LIST
51196: LIST
51197: PPUSH
51198: CALL_OW 70
51202: ST_TO_ADDR
// end ;
51203: LD_VAR 0 3
51207: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
51208: LD_INT 0
51210: PPUSH
51211: PPUSH
51212: PPUSH
51213: PPUSH
51214: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
51215: LD_VAR 0 1
51219: NOT
51220: PUSH
51221: LD_EXP 74
51225: PUSH
51226: LD_VAR 0 1
51230: ARRAY
51231: NOT
51232: OR
51233: PUSH
51234: LD_VAR 0 2
51238: NOT
51239: OR
51240: PUSH
51241: LD_VAR 0 3
51245: NOT
51246: OR
51247: IFFALSE 51251
// exit ;
51249: GO 51764
// side := mc_sides [ base ] ;
51251: LD_ADDR_VAR 0 6
51255: PUSH
51256: LD_EXP 100
51260: PUSH
51261: LD_VAR 0 1
51265: ARRAY
51266: ST_TO_ADDR
// if not side then
51267: LD_VAR 0 6
51271: NOT
51272: IFFALSE 51276
// exit ;
51274: GO 51764
// for i in solds do
51276: LD_ADDR_VAR 0 7
51280: PUSH
51281: LD_VAR 0 2
51285: PUSH
51286: FOR_IN
51287: IFFALSE 51348
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
51289: LD_VAR 0 7
51293: PPUSH
51294: CALL_OW 310
51298: PPUSH
51299: CALL_OW 266
51303: PUSH
51304: LD_INT 32
51306: PUSH
51307: LD_INT 31
51309: PUSH
51310: EMPTY
51311: LIST
51312: LIST
51313: IN
51314: IFFALSE 51334
// solds := solds diff i else
51316: LD_ADDR_VAR 0 2
51320: PUSH
51321: LD_VAR 0 2
51325: PUSH
51326: LD_VAR 0 7
51330: DIFF
51331: ST_TO_ADDR
51332: GO 51346
// SetTag ( i , 18 ) ;
51334: LD_VAR 0 7
51338: PPUSH
51339: LD_INT 18
51341: PPUSH
51342: CALL_OW 109
51346: GO 51286
51348: POP
51349: POP
// if not solds then
51350: LD_VAR 0 2
51354: NOT
51355: IFFALSE 51359
// exit ;
51357: GO 51764
// repeat wait ( 0 0$1 ) ;
51359: LD_INT 35
51361: PPUSH
51362: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
51366: LD_ADDR_VAR 0 5
51370: PUSH
51371: LD_VAR 0 6
51375: PPUSH
51376: LD_VAR 0 3
51380: PPUSH
51381: CALL 51173 0 2
51385: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
51386: LD_EXP 74
51390: PUSH
51391: LD_VAR 0 1
51395: ARRAY
51396: NOT
51397: PUSH
51398: LD_EXP 74
51402: PUSH
51403: LD_VAR 0 1
51407: ARRAY
51408: PUSH
51409: EMPTY
51410: EQUAL
51411: OR
51412: IFFALSE 51449
// begin for i in solds do
51414: LD_ADDR_VAR 0 7
51418: PUSH
51419: LD_VAR 0 2
51423: PUSH
51424: FOR_IN
51425: IFFALSE 51438
// ComStop ( i ) ;
51427: LD_VAR 0 7
51431: PPUSH
51432: CALL_OW 141
51436: GO 51424
51438: POP
51439: POP
// solds := [ ] ;
51440: LD_ADDR_VAR 0 2
51444: PUSH
51445: EMPTY
51446: ST_TO_ADDR
// exit ;
51447: GO 51764
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
51449: LD_VAR 0 5
51453: NOT
51454: PUSH
51455: LD_VAR 0 5
51459: PUSH
51460: LD_INT 3
51462: GREATER
51463: OR
51464: PUSH
51465: LD_EXP 96
51469: PUSH
51470: LD_VAR 0 1
51474: ARRAY
51475: OR
51476: IFFALSE 51517
// begin for i in solds do
51478: LD_ADDR_VAR 0 7
51482: PUSH
51483: LD_VAR 0 2
51487: PUSH
51488: FOR_IN
51489: IFFALSE 51513
// if HasTask ( i ) then
51491: LD_VAR 0 7
51495: PPUSH
51496: CALL_OW 314
51500: IFFALSE 51511
// ComStop ( i ) ;
51502: LD_VAR 0 7
51506: PPUSH
51507: CALL_OW 141
51511: GO 51488
51513: POP
51514: POP
// break ;
51515: GO 51752
// end ; for i in solds do
51517: LD_ADDR_VAR 0 7
51521: PUSH
51522: LD_VAR 0 2
51526: PUSH
51527: FOR_IN
51528: IFFALSE 51744
// begin if IsInUnit ( i ) then
51530: LD_VAR 0 7
51534: PPUSH
51535: CALL_OW 310
51539: IFFALSE 51550
// ComExitBuilding ( i ) ;
51541: LD_VAR 0 7
51545: PPUSH
51546: CALL_OW 122
// if GetLives ( i ) > 333 then
51550: LD_VAR 0 7
51554: PPUSH
51555: CALL_OW 256
51559: PUSH
51560: LD_INT 333
51562: GREATER
51563: IFFALSE 51591
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51565: LD_VAR 0 7
51569: PPUSH
51570: LD_VAR 0 5
51574: PPUSH
51575: LD_VAR 0 7
51579: PPUSH
51580: CALL_OW 74
51584: PPUSH
51585: CALL_OW 115
51589: GO 51742
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
51591: LD_ADDR_VAR 0 8
51595: PUSH
51596: LD_EXP 74
51600: PUSH
51601: LD_VAR 0 1
51605: ARRAY
51606: PPUSH
51607: LD_INT 2
51609: PUSH
51610: LD_INT 30
51612: PUSH
51613: LD_INT 0
51615: PUSH
51616: EMPTY
51617: LIST
51618: LIST
51619: PUSH
51620: LD_INT 30
51622: PUSH
51623: LD_INT 1
51625: PUSH
51626: EMPTY
51627: LIST
51628: LIST
51629: PUSH
51630: LD_INT 30
51632: PUSH
51633: LD_INT 6
51635: PUSH
51636: EMPTY
51637: LIST
51638: LIST
51639: PUSH
51640: EMPTY
51641: LIST
51642: LIST
51643: LIST
51644: LIST
51645: PPUSH
51646: CALL_OW 72
51650: PPUSH
51651: LD_VAR 0 7
51655: PPUSH
51656: CALL_OW 74
51660: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
51661: LD_VAR 0 7
51665: PPUSH
51666: LD_VAR 0 8
51670: PPUSH
51671: CALL_OW 250
51675: PPUSH
51676: LD_INT 3
51678: PPUSH
51679: LD_INT 5
51681: PPUSH
51682: CALL_OW 272
51686: PPUSH
51687: LD_VAR 0 8
51691: PPUSH
51692: CALL_OW 251
51696: PPUSH
51697: LD_INT 3
51699: PPUSH
51700: LD_INT 5
51702: PPUSH
51703: CALL_OW 273
51707: PPUSH
51708: CALL_OW 111
// SetTag ( i , 0 ) ;
51712: LD_VAR 0 7
51716: PPUSH
51717: LD_INT 0
51719: PPUSH
51720: CALL_OW 109
// solds := solds diff i ;
51724: LD_ADDR_VAR 0 2
51728: PUSH
51729: LD_VAR 0 2
51733: PUSH
51734: LD_VAR 0 7
51738: DIFF
51739: ST_TO_ADDR
// continue ;
51740: GO 51527
// end ; end ;
51742: GO 51527
51744: POP
51745: POP
// until solds ;
51746: LD_VAR 0 2
51750: IFFALSE 51359
// MC_Reset ( base , 18 ) ;
51752: LD_VAR 0 1
51756: PPUSH
51757: LD_INT 18
51759: PPUSH
51760: CALL 23831 0 2
// end ;
51764: LD_VAR 0 4
51768: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
51769: LD_INT 0
51771: PPUSH
51772: PPUSH
51773: PPUSH
51774: PPUSH
51775: PPUSH
51776: PPUSH
51777: PPUSH
51778: PPUSH
51779: PPUSH
51780: PPUSH
51781: PPUSH
51782: PPUSH
51783: PPUSH
51784: PPUSH
51785: PPUSH
51786: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
51787: LD_ADDR_VAR 0 12
51791: PUSH
51792: LD_EXP 74
51796: PUSH
51797: LD_VAR 0 1
51801: ARRAY
51802: PPUSH
51803: LD_INT 25
51805: PUSH
51806: LD_INT 3
51808: PUSH
51809: EMPTY
51810: LIST
51811: LIST
51812: PPUSH
51813: CALL_OW 72
51817: ST_TO_ADDR
// if mc_remote_driver [ base ] then
51818: LD_EXP 114
51822: PUSH
51823: LD_VAR 0 1
51827: ARRAY
51828: IFFALSE 51852
// mechs := mechs diff mc_remote_driver [ base ] ;
51830: LD_ADDR_VAR 0 12
51834: PUSH
51835: LD_VAR 0 12
51839: PUSH
51840: LD_EXP 114
51844: PUSH
51845: LD_VAR 0 1
51849: ARRAY
51850: DIFF
51851: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51852: LD_ADDR_VAR 0 8
51856: PUSH
51857: LD_EXP 74
51861: PUSH
51862: LD_VAR 0 1
51866: ARRAY
51867: PPUSH
51868: LD_INT 2
51870: PUSH
51871: LD_INT 25
51873: PUSH
51874: LD_INT 1
51876: PUSH
51877: EMPTY
51878: LIST
51879: LIST
51880: PUSH
51881: LD_INT 25
51883: PUSH
51884: LD_INT 5
51886: PUSH
51887: EMPTY
51888: LIST
51889: LIST
51890: PUSH
51891: LD_INT 25
51893: PUSH
51894: LD_INT 8
51896: PUSH
51897: EMPTY
51898: LIST
51899: LIST
51900: PUSH
51901: LD_INT 25
51903: PUSH
51904: LD_INT 9
51906: PUSH
51907: EMPTY
51908: LIST
51909: LIST
51910: PUSH
51911: EMPTY
51912: LIST
51913: LIST
51914: LIST
51915: LIST
51916: LIST
51917: PPUSH
51918: CALL_OW 72
51922: ST_TO_ADDR
// if not defenders and not solds then
51923: LD_VAR 0 2
51927: NOT
51928: PUSH
51929: LD_VAR 0 8
51933: NOT
51934: AND
51935: IFFALSE 51939
// exit ;
51937: GO 53465
// depot_under_attack := false ;
51939: LD_ADDR_VAR 0 16
51943: PUSH
51944: LD_INT 0
51946: ST_TO_ADDR
// sold_defenders := [ ] ;
51947: LD_ADDR_VAR 0 17
51951: PUSH
51952: EMPTY
51953: ST_TO_ADDR
// if mechs then
51954: LD_VAR 0 12
51958: IFFALSE 52087
// for i in defenders do
51960: LD_ADDR_VAR 0 5
51964: PUSH
51965: LD_VAR 0 2
51969: PUSH
51970: FOR_IN
51971: IFFALSE 52085
// begin SetTag ( i , 20 ) ;
51973: LD_VAR 0 5
51977: PPUSH
51978: LD_INT 20
51980: PPUSH
51981: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
51985: LD_VAR 0 5
51989: PPUSH
51990: CALL_OW 263
51994: PUSH
51995: LD_INT 1
51997: EQUAL
51998: PUSH
51999: LD_VAR 0 5
52003: PPUSH
52004: CALL_OW 311
52008: NOT
52009: AND
52010: PUSH
52011: LD_VAR 0 12
52015: AND
52016: IFFALSE 52083
// begin un := mechs [ 1 ] ;
52018: LD_ADDR_VAR 0 10
52022: PUSH
52023: LD_VAR 0 12
52027: PUSH
52028: LD_INT 1
52030: ARRAY
52031: ST_TO_ADDR
// ComExitBuilding ( un ) ;
52032: LD_VAR 0 10
52036: PPUSH
52037: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
52041: LD_VAR 0 10
52045: PPUSH
52046: LD_VAR 0 5
52050: PPUSH
52051: CALL_OW 180
// SetTag ( un , 19 ) ;
52055: LD_VAR 0 10
52059: PPUSH
52060: LD_INT 19
52062: PPUSH
52063: CALL_OW 109
// mechs := mechs diff un ;
52067: LD_ADDR_VAR 0 12
52071: PUSH
52072: LD_VAR 0 12
52076: PUSH
52077: LD_VAR 0 10
52081: DIFF
52082: ST_TO_ADDR
// end ; end ;
52083: GO 51970
52085: POP
52086: POP
// if solds then
52087: LD_VAR 0 8
52091: IFFALSE 52150
// for i in solds do
52093: LD_ADDR_VAR 0 5
52097: PUSH
52098: LD_VAR 0 8
52102: PUSH
52103: FOR_IN
52104: IFFALSE 52148
// if not GetTag ( i ) then
52106: LD_VAR 0 5
52110: PPUSH
52111: CALL_OW 110
52115: NOT
52116: IFFALSE 52146
// begin defenders := defenders union i ;
52118: LD_ADDR_VAR 0 2
52122: PUSH
52123: LD_VAR 0 2
52127: PUSH
52128: LD_VAR 0 5
52132: UNION
52133: ST_TO_ADDR
// SetTag ( i , 18 ) ;
52134: LD_VAR 0 5
52138: PPUSH
52139: LD_INT 18
52141: PPUSH
52142: CALL_OW 109
// end ;
52146: GO 52103
52148: POP
52149: POP
// repeat wait ( 0 0$1 ) ;
52150: LD_INT 35
52152: PPUSH
52153: CALL_OW 67
// enemy := mc_scan [ base ] ;
52157: LD_ADDR_VAR 0 3
52161: PUSH
52162: LD_EXP 97
52166: PUSH
52167: LD_VAR 0 1
52171: ARRAY
52172: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52173: LD_EXP 74
52177: PUSH
52178: LD_VAR 0 1
52182: ARRAY
52183: NOT
52184: PUSH
52185: LD_EXP 74
52189: PUSH
52190: LD_VAR 0 1
52194: ARRAY
52195: PUSH
52196: EMPTY
52197: EQUAL
52198: OR
52199: IFFALSE 52236
// begin for i in defenders do
52201: LD_ADDR_VAR 0 5
52205: PUSH
52206: LD_VAR 0 2
52210: PUSH
52211: FOR_IN
52212: IFFALSE 52225
// ComStop ( i ) ;
52214: LD_VAR 0 5
52218: PPUSH
52219: CALL_OW 141
52223: GO 52211
52225: POP
52226: POP
// defenders := [ ] ;
52227: LD_ADDR_VAR 0 2
52231: PUSH
52232: EMPTY
52233: ST_TO_ADDR
// exit ;
52234: GO 53465
// end ; for i in defenders do
52236: LD_ADDR_VAR 0 5
52240: PUSH
52241: LD_VAR 0 2
52245: PUSH
52246: FOR_IN
52247: IFFALSE 52977
// begin e := NearestUnitToUnit ( enemy , i ) ;
52249: LD_ADDR_VAR 0 13
52253: PUSH
52254: LD_VAR 0 3
52258: PPUSH
52259: LD_VAR 0 5
52263: PPUSH
52264: CALL_OW 74
52268: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
52269: LD_ADDR_VAR 0 16
52273: PUSH
52274: LD_EXP 74
52278: PUSH
52279: LD_VAR 0 1
52283: ARRAY
52284: PPUSH
52285: LD_INT 2
52287: PUSH
52288: LD_INT 30
52290: PUSH
52291: LD_INT 0
52293: PUSH
52294: EMPTY
52295: LIST
52296: LIST
52297: PUSH
52298: LD_INT 30
52300: PUSH
52301: LD_INT 1
52303: PUSH
52304: EMPTY
52305: LIST
52306: LIST
52307: PUSH
52308: EMPTY
52309: LIST
52310: LIST
52311: LIST
52312: PPUSH
52313: CALL_OW 72
52317: NOT
52318: PUSH
52319: LD_EXP 74
52323: PUSH
52324: LD_VAR 0 1
52328: ARRAY
52329: PPUSH
52330: LD_INT 2
52332: PUSH
52333: LD_INT 30
52335: PUSH
52336: LD_INT 0
52338: PUSH
52339: EMPTY
52340: LIST
52341: LIST
52342: PUSH
52343: LD_INT 30
52345: PUSH
52346: LD_INT 1
52348: PUSH
52349: EMPTY
52350: LIST
52351: LIST
52352: PUSH
52353: EMPTY
52354: LIST
52355: LIST
52356: LIST
52357: PPUSH
52358: CALL_OW 72
52362: PPUSH
52363: CALL_OW 256
52367: PUSH
52368: LD_INT 600
52370: LESS
52371: OR
52372: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
52373: LD_VAR 0 5
52377: PPUSH
52378: CALL_OW 247
52382: PUSH
52383: LD_INT 2
52385: DOUBLE
52386: EQUAL
52387: IFTRUE 52391
52389: GO 52683
52391: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
52392: LD_VAR 0 5
52396: PPUSH
52397: CALL_OW 256
52401: PUSH
52402: LD_INT 650
52404: GREATER
52405: PUSH
52406: LD_VAR 0 5
52410: PPUSH
52411: LD_VAR 0 13
52415: PPUSH
52416: CALL_OW 296
52420: PUSH
52421: LD_INT 40
52423: LESS
52424: PUSH
52425: LD_VAR 0 13
52429: PPUSH
52430: LD_EXP 99
52434: PUSH
52435: LD_VAR 0 1
52439: ARRAY
52440: PPUSH
52441: CALL_OW 308
52445: OR
52446: AND
52447: IFFALSE 52465
// ComAttackUnit ( i , e ) else
52449: LD_VAR 0 5
52453: PPUSH
52454: LD_VAR 0 13
52458: PPUSH
52459: CALL_OW 115
52463: GO 52566
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
52465: LD_VAR 0 13
52469: PPUSH
52470: LD_EXP 99
52474: PUSH
52475: LD_VAR 0 1
52479: ARRAY
52480: PPUSH
52481: CALL_OW 308
52485: NOT
52486: PUSH
52487: LD_VAR 0 5
52491: PPUSH
52492: LD_VAR 0 13
52496: PPUSH
52497: CALL_OW 296
52501: PUSH
52502: LD_INT 40
52504: GREATEREQUAL
52505: AND
52506: PUSH
52507: LD_VAR 0 5
52511: PPUSH
52512: CALL_OW 256
52516: PUSH
52517: LD_INT 650
52519: LESSEQUAL
52520: OR
52521: PUSH
52522: LD_VAR 0 5
52526: PPUSH
52527: LD_EXP 98
52531: PUSH
52532: LD_VAR 0 1
52536: ARRAY
52537: PPUSH
52538: CALL_OW 308
52542: NOT
52543: AND
52544: IFFALSE 52566
// ComMoveToArea ( i , mc_parking [ base ] ) ;
52546: LD_VAR 0 5
52550: PPUSH
52551: LD_EXP 98
52555: PUSH
52556: LD_VAR 0 1
52560: ARRAY
52561: PPUSH
52562: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
52566: LD_VAR 0 5
52570: PPUSH
52571: CALL_OW 256
52575: PUSH
52576: LD_INT 998
52578: LESS
52579: PUSH
52580: LD_VAR 0 5
52584: PPUSH
52585: CALL_OW 263
52589: PUSH
52590: LD_INT 1
52592: EQUAL
52593: AND
52594: PUSH
52595: LD_VAR 0 5
52599: PPUSH
52600: CALL_OW 311
52604: AND
52605: PUSH
52606: LD_VAR 0 5
52610: PPUSH
52611: LD_EXP 98
52615: PUSH
52616: LD_VAR 0 1
52620: ARRAY
52621: PPUSH
52622: CALL_OW 308
52626: AND
52627: IFFALSE 52681
// begin mech := IsDrivenBy ( i ) ;
52629: LD_ADDR_VAR 0 9
52633: PUSH
52634: LD_VAR 0 5
52638: PPUSH
52639: CALL_OW 311
52643: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
52644: LD_VAR 0 9
52648: PPUSH
52649: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
52653: LD_VAR 0 9
52657: PPUSH
52658: LD_VAR 0 5
52662: PPUSH
52663: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
52667: LD_VAR 0 9
52671: PPUSH
52672: LD_VAR 0 5
52676: PPUSH
52677: CALL_OW 180
// end ; end ; unit_human :
52681: GO 52948
52683: LD_INT 1
52685: DOUBLE
52686: EQUAL
52687: IFTRUE 52691
52689: GO 52947
52691: POP
// begin b := IsInUnit ( i ) ;
52692: LD_ADDR_VAR 0 18
52696: PUSH
52697: LD_VAR 0 5
52701: PPUSH
52702: CALL_OW 310
52706: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
52707: LD_ADDR_VAR 0 19
52711: PUSH
52712: LD_VAR 0 18
52716: NOT
52717: PUSH
52718: LD_VAR 0 18
52722: PPUSH
52723: CALL_OW 266
52727: PUSH
52728: LD_INT 32
52730: PUSH
52731: LD_INT 31
52733: PUSH
52734: EMPTY
52735: LIST
52736: LIST
52737: IN
52738: OR
52739: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
52740: LD_VAR 0 16
52744: PUSH
52745: LD_VAR 0 2
52749: PPUSH
52750: LD_INT 21
52752: PUSH
52753: LD_INT 2
52755: PUSH
52756: EMPTY
52757: LIST
52758: LIST
52759: PPUSH
52760: CALL_OW 72
52764: PUSH
52765: LD_INT 1
52767: LESSEQUAL
52768: OR
52769: PUSH
52770: LD_VAR 0 19
52774: AND
52775: PUSH
52776: LD_VAR 0 5
52780: PUSH
52781: LD_VAR 0 17
52785: IN
52786: NOT
52787: AND
52788: IFFALSE 52881
// begin if b then
52790: LD_VAR 0 18
52794: IFFALSE 52843
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
52796: LD_VAR 0 18
52800: PPUSH
52801: LD_VAR 0 3
52805: PPUSH
52806: LD_VAR 0 18
52810: PPUSH
52811: CALL_OW 74
52815: PPUSH
52816: CALL_OW 296
52820: PUSH
52821: LD_INT 10
52823: LESS
52824: PUSH
52825: LD_VAR 0 18
52829: PPUSH
52830: CALL_OW 461
52834: PUSH
52835: LD_INT 7
52837: NONEQUAL
52838: AND
52839: IFFALSE 52843
// continue ;
52841: GO 52246
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
52843: LD_ADDR_VAR 0 17
52847: PUSH
52848: LD_VAR 0 17
52852: PPUSH
52853: LD_VAR 0 17
52857: PUSH
52858: LD_INT 1
52860: PLUS
52861: PPUSH
52862: LD_VAR 0 5
52866: PPUSH
52867: CALL_OW 1
52871: ST_TO_ADDR
// ComExitBuilding ( i ) ;
52872: LD_VAR 0 5
52876: PPUSH
52877: CALL_OW 122
// end ; if sold_defenders then
52881: LD_VAR 0 17
52885: IFFALSE 52945
// if i in sold_defenders then
52887: LD_VAR 0 5
52891: PUSH
52892: LD_VAR 0 17
52896: IN
52897: IFFALSE 52945
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
52899: LD_VAR 0 5
52903: PPUSH
52904: CALL_OW 314
52908: NOT
52909: PUSH
52910: LD_VAR 0 5
52914: PPUSH
52915: LD_VAR 0 13
52919: PPUSH
52920: CALL_OW 296
52924: PUSH
52925: LD_INT 30
52927: LESS
52928: AND
52929: IFFALSE 52945
// ComAttackUnit ( i , e ) ;
52931: LD_VAR 0 5
52935: PPUSH
52936: LD_VAR 0 13
52940: PPUSH
52941: CALL_OW 115
// end ; end ; end ;
52945: GO 52948
52947: POP
// if IsDead ( i ) then
52948: LD_VAR 0 5
52952: PPUSH
52953: CALL_OW 301
52957: IFFALSE 52975
// defenders := defenders diff i ;
52959: LD_ADDR_VAR 0 2
52963: PUSH
52964: LD_VAR 0 2
52968: PUSH
52969: LD_VAR 0 5
52973: DIFF
52974: ST_TO_ADDR
// end ;
52975: GO 52246
52977: POP
52978: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
52979: LD_VAR 0 3
52983: NOT
52984: PUSH
52985: LD_VAR 0 2
52989: NOT
52990: OR
52991: PUSH
52992: LD_EXP 74
52996: PUSH
52997: LD_VAR 0 1
53001: ARRAY
53002: NOT
53003: OR
53004: IFFALSE 52150
// MC_Reset ( base , 18 ) ;
53006: LD_VAR 0 1
53010: PPUSH
53011: LD_INT 18
53013: PPUSH
53014: CALL 23831 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53018: LD_ADDR_VAR 0 2
53022: PUSH
53023: LD_VAR 0 2
53027: PUSH
53028: LD_VAR 0 2
53032: PPUSH
53033: LD_INT 2
53035: PUSH
53036: LD_INT 25
53038: PUSH
53039: LD_INT 1
53041: PUSH
53042: EMPTY
53043: LIST
53044: LIST
53045: PUSH
53046: LD_INT 25
53048: PUSH
53049: LD_INT 5
53051: PUSH
53052: EMPTY
53053: LIST
53054: LIST
53055: PUSH
53056: LD_INT 25
53058: PUSH
53059: LD_INT 8
53061: PUSH
53062: EMPTY
53063: LIST
53064: LIST
53065: PUSH
53066: LD_INT 25
53068: PUSH
53069: LD_INT 9
53071: PUSH
53072: EMPTY
53073: LIST
53074: LIST
53075: PUSH
53076: EMPTY
53077: LIST
53078: LIST
53079: LIST
53080: LIST
53081: LIST
53082: PPUSH
53083: CALL_OW 72
53087: DIFF
53088: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
53089: LD_VAR 0 3
53093: NOT
53094: PUSH
53095: LD_VAR 0 2
53099: PPUSH
53100: LD_INT 21
53102: PUSH
53103: LD_INT 2
53105: PUSH
53106: EMPTY
53107: LIST
53108: LIST
53109: PPUSH
53110: CALL_OW 72
53114: AND
53115: IFFALSE 53453
// begin tmp := FilterByTag ( defenders , 19 ) ;
53117: LD_ADDR_VAR 0 11
53121: PUSH
53122: LD_VAR 0 2
53126: PPUSH
53127: LD_INT 19
53129: PPUSH
53130: CALL 89894 0 2
53134: ST_TO_ADDR
// if tmp then
53135: LD_VAR 0 11
53139: IFFALSE 53209
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
53141: LD_ADDR_VAR 0 11
53145: PUSH
53146: LD_VAR 0 11
53150: PPUSH
53151: LD_INT 25
53153: PUSH
53154: LD_INT 3
53156: PUSH
53157: EMPTY
53158: LIST
53159: LIST
53160: PPUSH
53161: CALL_OW 72
53165: ST_TO_ADDR
// if tmp then
53166: LD_VAR 0 11
53170: IFFALSE 53209
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
53172: LD_ADDR_EXP 86
53176: PUSH
53177: LD_EXP 86
53181: PPUSH
53182: LD_VAR 0 1
53186: PPUSH
53187: LD_EXP 86
53191: PUSH
53192: LD_VAR 0 1
53196: ARRAY
53197: PUSH
53198: LD_VAR 0 11
53202: UNION
53203: PPUSH
53204: CALL_OW 1
53208: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
53209: LD_VAR 0 1
53213: PPUSH
53214: LD_INT 19
53216: PPUSH
53217: CALL 23831 0 2
// repeat wait ( 0 0$1 ) ;
53221: LD_INT 35
53223: PPUSH
53224: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53228: LD_EXP 74
53232: PUSH
53233: LD_VAR 0 1
53237: ARRAY
53238: NOT
53239: PUSH
53240: LD_EXP 74
53244: PUSH
53245: LD_VAR 0 1
53249: ARRAY
53250: PUSH
53251: EMPTY
53252: EQUAL
53253: OR
53254: IFFALSE 53291
// begin for i in defenders do
53256: LD_ADDR_VAR 0 5
53260: PUSH
53261: LD_VAR 0 2
53265: PUSH
53266: FOR_IN
53267: IFFALSE 53280
// ComStop ( i ) ;
53269: LD_VAR 0 5
53273: PPUSH
53274: CALL_OW 141
53278: GO 53266
53280: POP
53281: POP
// defenders := [ ] ;
53282: LD_ADDR_VAR 0 2
53286: PUSH
53287: EMPTY
53288: ST_TO_ADDR
// exit ;
53289: GO 53465
// end ; for i in defenders do
53291: LD_ADDR_VAR 0 5
53295: PUSH
53296: LD_VAR 0 2
53300: PUSH
53301: FOR_IN
53302: IFFALSE 53391
// begin if not IsInArea ( i , mc_parking [ base ] ) then
53304: LD_VAR 0 5
53308: PPUSH
53309: LD_EXP 98
53313: PUSH
53314: LD_VAR 0 1
53318: ARRAY
53319: PPUSH
53320: CALL_OW 308
53324: NOT
53325: IFFALSE 53349
// ComMoveToArea ( i , mc_parking [ base ] ) else
53327: LD_VAR 0 5
53331: PPUSH
53332: LD_EXP 98
53336: PUSH
53337: LD_VAR 0 1
53341: ARRAY
53342: PPUSH
53343: CALL_OW 113
53347: GO 53389
// if GetControl ( i ) = control_manual then
53349: LD_VAR 0 5
53353: PPUSH
53354: CALL_OW 263
53358: PUSH
53359: LD_INT 1
53361: EQUAL
53362: IFFALSE 53389
// if IsDrivenBy ( i ) then
53364: LD_VAR 0 5
53368: PPUSH
53369: CALL_OW 311
53373: IFFALSE 53389
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
53375: LD_VAR 0 5
53379: PPUSH
53380: CALL_OW 311
53384: PPUSH
53385: CALL_OW 121
// end ;
53389: GO 53301
53391: POP
53392: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
53393: LD_VAR 0 2
53397: PPUSH
53398: LD_INT 95
53400: PUSH
53401: LD_EXP 98
53405: PUSH
53406: LD_VAR 0 1
53410: ARRAY
53411: PUSH
53412: EMPTY
53413: LIST
53414: LIST
53415: PPUSH
53416: CALL_OW 72
53420: PUSH
53421: LD_VAR 0 2
53425: EQUAL
53426: PUSH
53427: LD_EXP 97
53431: PUSH
53432: LD_VAR 0 1
53436: ARRAY
53437: OR
53438: PUSH
53439: LD_EXP 74
53443: PUSH
53444: LD_VAR 0 1
53448: ARRAY
53449: NOT
53450: OR
53451: IFFALSE 53221
// end ; MC_Reset ( base , 20 ) ;
53453: LD_VAR 0 1
53457: PPUSH
53458: LD_INT 20
53460: PPUSH
53461: CALL 23831 0 2
// end ;
53465: LD_VAR 0 4
53469: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53470: LD_INT 0
53472: PPUSH
53473: PPUSH
53474: PPUSH
53475: PPUSH
// result := false ;
53476: LD_ADDR_VAR 0 2
53480: PUSH
53481: LD_INT 0
53483: ST_TO_ADDR
// side := GetSide ( unit ) ;
53484: LD_ADDR_VAR 0 3
53488: PUSH
53489: LD_VAR 0 1
53493: PPUSH
53494: CALL_OW 255
53498: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53499: LD_ADDR_VAR 0 4
53503: PUSH
53504: LD_VAR 0 1
53508: PPUSH
53509: CALL_OW 248
53513: ST_TO_ADDR
// case nat of 1 :
53514: LD_VAR 0 4
53518: PUSH
53519: LD_INT 1
53521: DOUBLE
53522: EQUAL
53523: IFTRUE 53527
53525: GO 53538
53527: POP
// tech := tech_lassight ; 2 :
53528: LD_ADDR_VAR 0 5
53532: PUSH
53533: LD_INT 12
53535: ST_TO_ADDR
53536: GO 53577
53538: LD_INT 2
53540: DOUBLE
53541: EQUAL
53542: IFTRUE 53546
53544: GO 53557
53546: POP
// tech := tech_mortar ; 3 :
53547: LD_ADDR_VAR 0 5
53551: PUSH
53552: LD_INT 41
53554: ST_TO_ADDR
53555: GO 53577
53557: LD_INT 3
53559: DOUBLE
53560: EQUAL
53561: IFTRUE 53565
53563: GO 53576
53565: POP
// tech := tech_bazooka ; end ;
53566: LD_ADDR_VAR 0 5
53570: PUSH
53571: LD_INT 44
53573: ST_TO_ADDR
53574: GO 53577
53576: POP
// if Researched ( side , tech ) then
53577: LD_VAR 0 3
53581: PPUSH
53582: LD_VAR 0 5
53586: PPUSH
53587: CALL_OW 325
53591: IFFALSE 53618
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53593: LD_ADDR_VAR 0 2
53597: PUSH
53598: LD_INT 5
53600: PUSH
53601: LD_INT 8
53603: PUSH
53604: LD_INT 9
53606: PUSH
53607: EMPTY
53608: LIST
53609: LIST
53610: LIST
53611: PUSH
53612: LD_VAR 0 4
53616: ARRAY
53617: ST_TO_ADDR
// end ;
53618: LD_VAR 0 2
53622: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53623: LD_INT 0
53625: PPUSH
53626: PPUSH
53627: PPUSH
// if not mines then
53628: LD_VAR 0 2
53632: NOT
53633: IFFALSE 53637
// exit ;
53635: GO 53781
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53637: LD_ADDR_VAR 0 5
53641: PUSH
53642: LD_INT 81
53644: PUSH
53645: LD_VAR 0 1
53649: PUSH
53650: EMPTY
53651: LIST
53652: LIST
53653: PUSH
53654: LD_INT 3
53656: PUSH
53657: LD_INT 21
53659: PUSH
53660: LD_INT 3
53662: PUSH
53663: EMPTY
53664: LIST
53665: LIST
53666: PUSH
53667: EMPTY
53668: LIST
53669: LIST
53670: PUSH
53671: EMPTY
53672: LIST
53673: LIST
53674: PPUSH
53675: CALL_OW 69
53679: ST_TO_ADDR
// for i in mines do
53680: LD_ADDR_VAR 0 4
53684: PUSH
53685: LD_VAR 0 2
53689: PUSH
53690: FOR_IN
53691: IFFALSE 53779
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53693: LD_VAR 0 4
53697: PUSH
53698: LD_INT 1
53700: ARRAY
53701: PPUSH
53702: LD_VAR 0 4
53706: PUSH
53707: LD_INT 2
53709: ARRAY
53710: PPUSH
53711: CALL_OW 458
53715: NOT
53716: IFFALSE 53720
// continue ;
53718: GO 53690
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53720: LD_VAR 0 4
53724: PUSH
53725: LD_INT 1
53727: ARRAY
53728: PPUSH
53729: LD_VAR 0 4
53733: PUSH
53734: LD_INT 2
53736: ARRAY
53737: PPUSH
53738: CALL_OW 428
53742: PUSH
53743: LD_VAR 0 5
53747: IN
53748: IFFALSE 53777
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53750: LD_VAR 0 4
53754: PUSH
53755: LD_INT 1
53757: ARRAY
53758: PPUSH
53759: LD_VAR 0 4
53763: PUSH
53764: LD_INT 2
53766: ARRAY
53767: PPUSH
53768: LD_VAR 0 1
53772: PPUSH
53773: CALL_OW 456
// end ;
53777: GO 53690
53779: POP
53780: POP
// end ;
53781: LD_VAR 0 3
53785: RET
// export function Count ( array ) ; var i ; begin
53786: LD_INT 0
53788: PPUSH
53789: PPUSH
// result := 0 ;
53790: LD_ADDR_VAR 0 2
53794: PUSH
53795: LD_INT 0
53797: ST_TO_ADDR
// for i in array do
53798: LD_ADDR_VAR 0 3
53802: PUSH
53803: LD_VAR 0 1
53807: PUSH
53808: FOR_IN
53809: IFFALSE 53833
// if i then
53811: LD_VAR 0 3
53815: IFFALSE 53831
// result := result + 1 ;
53817: LD_ADDR_VAR 0 2
53821: PUSH
53822: LD_VAR 0 2
53826: PUSH
53827: LD_INT 1
53829: PLUS
53830: ST_TO_ADDR
53831: GO 53808
53833: POP
53834: POP
// end ;
53835: LD_VAR 0 2
53839: RET
// export function IsEmpty ( building ) ; begin
53840: LD_INT 0
53842: PPUSH
// if not building then
53843: LD_VAR 0 1
53847: NOT
53848: IFFALSE 53852
// exit ;
53850: GO 53895
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53852: LD_ADDR_VAR 0 2
53856: PUSH
53857: LD_VAR 0 1
53861: PUSH
53862: LD_INT 22
53864: PUSH
53865: LD_VAR 0 1
53869: PPUSH
53870: CALL_OW 255
53874: PUSH
53875: EMPTY
53876: LIST
53877: LIST
53878: PUSH
53879: LD_INT 58
53881: PUSH
53882: EMPTY
53883: LIST
53884: PUSH
53885: EMPTY
53886: LIST
53887: LIST
53888: PPUSH
53889: CALL_OW 69
53893: IN
53894: ST_TO_ADDR
// end ;
53895: LD_VAR 0 2
53899: RET
// export function IsNotFull ( building ) ; begin
53900: LD_INT 0
53902: PPUSH
// if not building then
53903: LD_VAR 0 1
53907: NOT
53908: IFFALSE 53912
// exit ;
53910: GO 53931
// result := UnitsInside ( building ) < 6 ;
53912: LD_ADDR_VAR 0 2
53916: PUSH
53917: LD_VAR 0 1
53921: PPUSH
53922: CALL_OW 313
53926: PUSH
53927: LD_INT 6
53929: LESS
53930: ST_TO_ADDR
// end ;
53931: LD_VAR 0 2
53935: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53936: LD_INT 0
53938: PPUSH
53939: PPUSH
53940: PPUSH
53941: PPUSH
// tmp := [ ] ;
53942: LD_ADDR_VAR 0 3
53946: PUSH
53947: EMPTY
53948: ST_TO_ADDR
// list := [ ] ;
53949: LD_ADDR_VAR 0 5
53953: PUSH
53954: EMPTY
53955: ST_TO_ADDR
// for i = 16 to 25 do
53956: LD_ADDR_VAR 0 4
53960: PUSH
53961: DOUBLE
53962: LD_INT 16
53964: DEC
53965: ST_TO_ADDR
53966: LD_INT 25
53968: PUSH
53969: FOR_TO
53970: IFFALSE 54043
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53972: LD_ADDR_VAR 0 3
53976: PUSH
53977: LD_VAR 0 3
53981: PUSH
53982: LD_INT 22
53984: PUSH
53985: LD_VAR 0 1
53989: PPUSH
53990: CALL_OW 255
53994: PUSH
53995: EMPTY
53996: LIST
53997: LIST
53998: PUSH
53999: LD_INT 91
54001: PUSH
54002: LD_VAR 0 1
54006: PUSH
54007: LD_INT 6
54009: PUSH
54010: EMPTY
54011: LIST
54012: LIST
54013: LIST
54014: PUSH
54015: LD_INT 30
54017: PUSH
54018: LD_VAR 0 4
54022: PUSH
54023: EMPTY
54024: LIST
54025: LIST
54026: PUSH
54027: EMPTY
54028: LIST
54029: LIST
54030: LIST
54031: PUSH
54032: EMPTY
54033: LIST
54034: PPUSH
54035: CALL_OW 69
54039: ADD
54040: ST_TO_ADDR
54041: GO 53969
54043: POP
54044: POP
// for i = 1 to tmp do
54045: LD_ADDR_VAR 0 4
54049: PUSH
54050: DOUBLE
54051: LD_INT 1
54053: DEC
54054: ST_TO_ADDR
54055: LD_VAR 0 3
54059: PUSH
54060: FOR_TO
54061: IFFALSE 54149
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54063: LD_ADDR_VAR 0 5
54067: PUSH
54068: LD_VAR 0 5
54072: PUSH
54073: LD_VAR 0 3
54077: PUSH
54078: LD_VAR 0 4
54082: ARRAY
54083: PPUSH
54084: CALL_OW 266
54088: PUSH
54089: LD_VAR 0 3
54093: PUSH
54094: LD_VAR 0 4
54098: ARRAY
54099: PPUSH
54100: CALL_OW 250
54104: PUSH
54105: LD_VAR 0 3
54109: PUSH
54110: LD_VAR 0 4
54114: ARRAY
54115: PPUSH
54116: CALL_OW 251
54120: PUSH
54121: LD_VAR 0 3
54125: PUSH
54126: LD_VAR 0 4
54130: ARRAY
54131: PPUSH
54132: CALL_OW 254
54136: PUSH
54137: EMPTY
54138: LIST
54139: LIST
54140: LIST
54141: LIST
54142: PUSH
54143: EMPTY
54144: LIST
54145: ADD
54146: ST_TO_ADDR
54147: GO 54060
54149: POP
54150: POP
// result := list ;
54151: LD_ADDR_VAR 0 2
54155: PUSH
54156: LD_VAR 0 5
54160: ST_TO_ADDR
// end ;
54161: LD_VAR 0 2
54165: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54166: LD_INT 0
54168: PPUSH
54169: PPUSH
54170: PPUSH
54171: PPUSH
54172: PPUSH
54173: PPUSH
54174: PPUSH
// if not factory then
54175: LD_VAR 0 1
54179: NOT
54180: IFFALSE 54184
// exit ;
54182: GO 54777
// if control = control_apeman then
54184: LD_VAR 0 4
54188: PUSH
54189: LD_INT 5
54191: EQUAL
54192: IFFALSE 54301
// begin tmp := UnitsInside ( factory ) ;
54194: LD_ADDR_VAR 0 8
54198: PUSH
54199: LD_VAR 0 1
54203: PPUSH
54204: CALL_OW 313
54208: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54209: LD_VAR 0 8
54213: PPUSH
54214: LD_INT 25
54216: PUSH
54217: LD_INT 12
54219: PUSH
54220: EMPTY
54221: LIST
54222: LIST
54223: PPUSH
54224: CALL_OW 72
54228: NOT
54229: IFFALSE 54239
// control := control_manual ;
54231: LD_ADDR_VAR 0 4
54235: PUSH
54236: LD_INT 1
54238: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54239: LD_ADDR_VAR 0 8
54243: PUSH
54244: LD_VAR 0 1
54248: PPUSH
54249: CALL 53936 0 1
54253: ST_TO_ADDR
// if tmp then
54254: LD_VAR 0 8
54258: IFFALSE 54301
// begin for i in tmp do
54260: LD_ADDR_VAR 0 7
54264: PUSH
54265: LD_VAR 0 8
54269: PUSH
54270: FOR_IN
54271: IFFALSE 54299
// if i [ 1 ] = b_ext_radio then
54273: LD_VAR 0 7
54277: PUSH
54278: LD_INT 1
54280: ARRAY
54281: PUSH
54282: LD_INT 22
54284: EQUAL
54285: IFFALSE 54297
// begin control := control_remote ;
54287: LD_ADDR_VAR 0 4
54291: PUSH
54292: LD_INT 2
54294: ST_TO_ADDR
// break ;
54295: GO 54299
// end ;
54297: GO 54270
54299: POP
54300: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54301: LD_VAR 0 1
54305: PPUSH
54306: LD_VAR 0 2
54310: PPUSH
54311: LD_VAR 0 3
54315: PPUSH
54316: LD_VAR 0 4
54320: PPUSH
54321: LD_VAR 0 5
54325: PPUSH
54326: CALL_OW 448
54330: IFFALSE 54365
// begin result := [ chassis , engine , control , weapon ] ;
54332: LD_ADDR_VAR 0 6
54336: PUSH
54337: LD_VAR 0 2
54341: PUSH
54342: LD_VAR 0 3
54346: PUSH
54347: LD_VAR 0 4
54351: PUSH
54352: LD_VAR 0 5
54356: PUSH
54357: EMPTY
54358: LIST
54359: LIST
54360: LIST
54361: LIST
54362: ST_TO_ADDR
// exit ;
54363: GO 54777
// end ; _chassis := AvailableChassisList ( factory ) ;
54365: LD_ADDR_VAR 0 9
54369: PUSH
54370: LD_VAR 0 1
54374: PPUSH
54375: CALL_OW 475
54379: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54380: LD_ADDR_VAR 0 11
54384: PUSH
54385: LD_VAR 0 1
54389: PPUSH
54390: CALL_OW 476
54394: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54395: LD_ADDR_VAR 0 12
54399: PUSH
54400: LD_VAR 0 1
54404: PPUSH
54405: CALL_OW 477
54409: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54410: LD_ADDR_VAR 0 10
54414: PUSH
54415: LD_VAR 0 1
54419: PPUSH
54420: CALL_OW 478
54424: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54425: LD_VAR 0 9
54429: NOT
54430: PUSH
54431: LD_VAR 0 11
54435: NOT
54436: OR
54437: PUSH
54438: LD_VAR 0 12
54442: NOT
54443: OR
54444: PUSH
54445: LD_VAR 0 10
54449: NOT
54450: OR
54451: IFFALSE 54486
// begin result := [ chassis , engine , control , weapon ] ;
54453: LD_ADDR_VAR 0 6
54457: PUSH
54458: LD_VAR 0 2
54462: PUSH
54463: LD_VAR 0 3
54467: PUSH
54468: LD_VAR 0 4
54472: PUSH
54473: LD_VAR 0 5
54477: PUSH
54478: EMPTY
54479: LIST
54480: LIST
54481: LIST
54482: LIST
54483: ST_TO_ADDR
// exit ;
54484: GO 54777
// end ; if not chassis in _chassis then
54486: LD_VAR 0 2
54490: PUSH
54491: LD_VAR 0 9
54495: IN
54496: NOT
54497: IFFALSE 54523
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54499: LD_ADDR_VAR 0 2
54503: PUSH
54504: LD_VAR 0 9
54508: PUSH
54509: LD_INT 1
54511: PPUSH
54512: LD_VAR 0 9
54516: PPUSH
54517: CALL_OW 12
54521: ARRAY
54522: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54523: LD_VAR 0 2
54527: PPUSH
54528: LD_VAR 0 3
54532: PPUSH
54533: CALL 54782 0 2
54537: NOT
54538: IFFALSE 54597
// repeat engine := _engine [ 1 ] ;
54540: LD_ADDR_VAR 0 3
54544: PUSH
54545: LD_VAR 0 11
54549: PUSH
54550: LD_INT 1
54552: ARRAY
54553: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54554: LD_ADDR_VAR 0 11
54558: PUSH
54559: LD_VAR 0 11
54563: PPUSH
54564: LD_INT 1
54566: PPUSH
54567: CALL_OW 3
54571: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54572: LD_VAR 0 2
54576: PPUSH
54577: LD_VAR 0 3
54581: PPUSH
54582: CALL 54782 0 2
54586: PUSH
54587: LD_VAR 0 11
54591: PUSH
54592: EMPTY
54593: EQUAL
54594: OR
54595: IFFALSE 54540
// if not control in _control then
54597: LD_VAR 0 4
54601: PUSH
54602: LD_VAR 0 12
54606: IN
54607: NOT
54608: IFFALSE 54634
// control := _control [ rand ( 1 , _control ) ] ;
54610: LD_ADDR_VAR 0 4
54614: PUSH
54615: LD_VAR 0 12
54619: PUSH
54620: LD_INT 1
54622: PPUSH
54623: LD_VAR 0 12
54627: PPUSH
54628: CALL_OW 12
54632: ARRAY
54633: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54634: LD_VAR 0 2
54638: PPUSH
54639: LD_VAR 0 5
54643: PPUSH
54644: CALL 55002 0 2
54648: NOT
54649: IFFALSE 54708
// repeat weapon := _weapon [ 1 ] ;
54651: LD_ADDR_VAR 0 5
54655: PUSH
54656: LD_VAR 0 10
54660: PUSH
54661: LD_INT 1
54663: ARRAY
54664: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54665: LD_ADDR_VAR 0 10
54669: PUSH
54670: LD_VAR 0 10
54674: PPUSH
54675: LD_INT 1
54677: PPUSH
54678: CALL_OW 3
54682: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54683: LD_VAR 0 2
54687: PPUSH
54688: LD_VAR 0 5
54692: PPUSH
54693: CALL 55002 0 2
54697: PUSH
54698: LD_VAR 0 10
54702: PUSH
54703: EMPTY
54704: EQUAL
54705: OR
54706: IFFALSE 54651
// result := [ ] ;
54708: LD_ADDR_VAR 0 6
54712: PUSH
54713: EMPTY
54714: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54715: LD_VAR 0 1
54719: PPUSH
54720: LD_VAR 0 2
54724: PPUSH
54725: LD_VAR 0 3
54729: PPUSH
54730: LD_VAR 0 4
54734: PPUSH
54735: LD_VAR 0 5
54739: PPUSH
54740: CALL_OW 448
54744: IFFALSE 54777
// result := [ chassis , engine , control , weapon ] ;
54746: LD_ADDR_VAR 0 6
54750: PUSH
54751: LD_VAR 0 2
54755: PUSH
54756: LD_VAR 0 3
54760: PUSH
54761: LD_VAR 0 4
54765: PUSH
54766: LD_VAR 0 5
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: LIST
54775: LIST
54776: ST_TO_ADDR
// end ;
54777: LD_VAR 0 6
54781: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
54782: LD_INT 0
54784: PPUSH
// if not chassis or not engine then
54785: LD_VAR 0 1
54789: NOT
54790: PUSH
54791: LD_VAR 0 2
54795: NOT
54796: OR
54797: IFFALSE 54801
// exit ;
54799: GO 54997
// case engine of engine_solar :
54801: LD_VAR 0 2
54805: PUSH
54806: LD_INT 2
54808: DOUBLE
54809: EQUAL
54810: IFTRUE 54814
54812: GO 54852
54814: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54815: LD_ADDR_VAR 0 3
54819: PUSH
54820: LD_INT 11
54822: PUSH
54823: LD_INT 12
54825: PUSH
54826: LD_INT 13
54828: PUSH
54829: LD_INT 14
54831: PUSH
54832: LD_INT 1
54834: PUSH
54835: LD_INT 2
54837: PUSH
54838: LD_INT 3
54840: PUSH
54841: EMPTY
54842: LIST
54843: LIST
54844: LIST
54845: LIST
54846: LIST
54847: LIST
54848: LIST
54849: ST_TO_ADDR
54850: GO 54981
54852: LD_INT 1
54854: DOUBLE
54855: EQUAL
54856: IFTRUE 54860
54858: GO 54922
54860: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54861: LD_ADDR_VAR 0 3
54865: PUSH
54866: LD_INT 11
54868: PUSH
54869: LD_INT 12
54871: PUSH
54872: LD_INT 13
54874: PUSH
54875: LD_INT 14
54877: PUSH
54878: LD_INT 1
54880: PUSH
54881: LD_INT 2
54883: PUSH
54884: LD_INT 3
54886: PUSH
54887: LD_INT 4
54889: PUSH
54890: LD_INT 5
54892: PUSH
54893: LD_INT 21
54895: PUSH
54896: LD_INT 23
54898: PUSH
54899: LD_INT 22
54901: PUSH
54902: LD_INT 24
54904: PUSH
54905: EMPTY
54906: LIST
54907: LIST
54908: LIST
54909: LIST
54910: LIST
54911: LIST
54912: LIST
54913: LIST
54914: LIST
54915: LIST
54916: LIST
54917: LIST
54918: LIST
54919: ST_TO_ADDR
54920: GO 54981
54922: LD_INT 3
54924: DOUBLE
54925: EQUAL
54926: IFTRUE 54930
54928: GO 54980
54930: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54931: LD_ADDR_VAR 0 3
54935: PUSH
54936: LD_INT 13
54938: PUSH
54939: LD_INT 14
54941: PUSH
54942: LD_INT 2
54944: PUSH
54945: LD_INT 3
54947: PUSH
54948: LD_INT 4
54950: PUSH
54951: LD_INT 5
54953: PUSH
54954: LD_INT 21
54956: PUSH
54957: LD_INT 22
54959: PUSH
54960: LD_INT 23
54962: PUSH
54963: LD_INT 24
54965: PUSH
54966: EMPTY
54967: LIST
54968: LIST
54969: LIST
54970: LIST
54971: LIST
54972: LIST
54973: LIST
54974: LIST
54975: LIST
54976: LIST
54977: ST_TO_ADDR
54978: GO 54981
54980: POP
// result := ( chassis in result ) ;
54981: LD_ADDR_VAR 0 3
54985: PUSH
54986: LD_VAR 0 1
54990: PUSH
54991: LD_VAR 0 3
54995: IN
54996: ST_TO_ADDR
// end ;
54997: LD_VAR 0 3
55001: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55002: LD_INT 0
55004: PPUSH
// if not chassis or not weapon then
55005: LD_VAR 0 1
55009: NOT
55010: PUSH
55011: LD_VAR 0 2
55015: NOT
55016: OR
55017: IFFALSE 55021
// exit ;
55019: GO 56047
// case weapon of us_machine_gun :
55021: LD_VAR 0 2
55025: PUSH
55026: LD_INT 2
55028: DOUBLE
55029: EQUAL
55030: IFTRUE 55034
55032: GO 55064
55034: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55035: LD_ADDR_VAR 0 3
55039: PUSH
55040: LD_INT 1
55042: PUSH
55043: LD_INT 2
55045: PUSH
55046: LD_INT 3
55048: PUSH
55049: LD_INT 4
55051: PUSH
55052: LD_INT 5
55054: PUSH
55055: EMPTY
55056: LIST
55057: LIST
55058: LIST
55059: LIST
55060: LIST
55061: ST_TO_ADDR
55062: GO 56031
55064: LD_INT 3
55066: DOUBLE
55067: EQUAL
55068: IFTRUE 55072
55070: GO 55102
55072: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55073: LD_ADDR_VAR 0 3
55077: PUSH
55078: LD_INT 1
55080: PUSH
55081: LD_INT 2
55083: PUSH
55084: LD_INT 3
55086: PUSH
55087: LD_INT 4
55089: PUSH
55090: LD_INT 5
55092: PUSH
55093: EMPTY
55094: LIST
55095: LIST
55096: LIST
55097: LIST
55098: LIST
55099: ST_TO_ADDR
55100: GO 56031
55102: LD_INT 11
55104: DOUBLE
55105: EQUAL
55106: IFTRUE 55110
55108: GO 55140
55110: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55111: LD_ADDR_VAR 0 3
55115: PUSH
55116: LD_INT 1
55118: PUSH
55119: LD_INT 2
55121: PUSH
55122: LD_INT 3
55124: PUSH
55125: LD_INT 4
55127: PUSH
55128: LD_INT 5
55130: PUSH
55131: EMPTY
55132: LIST
55133: LIST
55134: LIST
55135: LIST
55136: LIST
55137: ST_TO_ADDR
55138: GO 56031
55140: LD_INT 4
55142: DOUBLE
55143: EQUAL
55144: IFTRUE 55148
55146: GO 55174
55148: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55149: LD_ADDR_VAR 0 3
55153: PUSH
55154: LD_INT 2
55156: PUSH
55157: LD_INT 3
55159: PUSH
55160: LD_INT 4
55162: PUSH
55163: LD_INT 5
55165: PUSH
55166: EMPTY
55167: LIST
55168: LIST
55169: LIST
55170: LIST
55171: ST_TO_ADDR
55172: GO 56031
55174: LD_INT 5
55176: DOUBLE
55177: EQUAL
55178: IFTRUE 55182
55180: GO 55208
55182: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55183: LD_ADDR_VAR 0 3
55187: PUSH
55188: LD_INT 2
55190: PUSH
55191: LD_INT 3
55193: PUSH
55194: LD_INT 4
55196: PUSH
55197: LD_INT 5
55199: PUSH
55200: EMPTY
55201: LIST
55202: LIST
55203: LIST
55204: LIST
55205: ST_TO_ADDR
55206: GO 56031
55208: LD_INT 9
55210: DOUBLE
55211: EQUAL
55212: IFTRUE 55216
55214: GO 55242
55216: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55217: LD_ADDR_VAR 0 3
55221: PUSH
55222: LD_INT 2
55224: PUSH
55225: LD_INT 3
55227: PUSH
55228: LD_INT 4
55230: PUSH
55231: LD_INT 5
55233: PUSH
55234: EMPTY
55235: LIST
55236: LIST
55237: LIST
55238: LIST
55239: ST_TO_ADDR
55240: GO 56031
55242: LD_INT 7
55244: DOUBLE
55245: EQUAL
55246: IFTRUE 55250
55248: GO 55276
55250: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55251: LD_ADDR_VAR 0 3
55255: PUSH
55256: LD_INT 2
55258: PUSH
55259: LD_INT 3
55261: PUSH
55262: LD_INT 4
55264: PUSH
55265: LD_INT 5
55267: PUSH
55268: EMPTY
55269: LIST
55270: LIST
55271: LIST
55272: LIST
55273: ST_TO_ADDR
55274: GO 56031
55276: LD_INT 12
55278: DOUBLE
55279: EQUAL
55280: IFTRUE 55284
55282: GO 55310
55284: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55285: LD_ADDR_VAR 0 3
55289: PUSH
55290: LD_INT 2
55292: PUSH
55293: LD_INT 3
55295: PUSH
55296: LD_INT 4
55298: PUSH
55299: LD_INT 5
55301: PUSH
55302: EMPTY
55303: LIST
55304: LIST
55305: LIST
55306: LIST
55307: ST_TO_ADDR
55308: GO 56031
55310: LD_INT 13
55312: DOUBLE
55313: EQUAL
55314: IFTRUE 55318
55316: GO 55344
55318: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55319: LD_ADDR_VAR 0 3
55323: PUSH
55324: LD_INT 2
55326: PUSH
55327: LD_INT 3
55329: PUSH
55330: LD_INT 4
55332: PUSH
55333: LD_INT 5
55335: PUSH
55336: EMPTY
55337: LIST
55338: LIST
55339: LIST
55340: LIST
55341: ST_TO_ADDR
55342: GO 56031
55344: LD_INT 14
55346: DOUBLE
55347: EQUAL
55348: IFTRUE 55352
55350: GO 55370
55352: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55353: LD_ADDR_VAR 0 3
55357: PUSH
55358: LD_INT 4
55360: PUSH
55361: LD_INT 5
55363: PUSH
55364: EMPTY
55365: LIST
55366: LIST
55367: ST_TO_ADDR
55368: GO 56031
55370: LD_INT 6
55372: DOUBLE
55373: EQUAL
55374: IFTRUE 55378
55376: GO 55396
55378: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55379: LD_ADDR_VAR 0 3
55383: PUSH
55384: LD_INT 4
55386: PUSH
55387: LD_INT 5
55389: PUSH
55390: EMPTY
55391: LIST
55392: LIST
55393: ST_TO_ADDR
55394: GO 56031
55396: LD_INT 10
55398: DOUBLE
55399: EQUAL
55400: IFTRUE 55404
55402: GO 55422
55404: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55405: LD_ADDR_VAR 0 3
55409: PUSH
55410: LD_INT 4
55412: PUSH
55413: LD_INT 5
55415: PUSH
55416: EMPTY
55417: LIST
55418: LIST
55419: ST_TO_ADDR
55420: GO 56031
55422: LD_INT 22
55424: DOUBLE
55425: EQUAL
55426: IFTRUE 55430
55428: GO 55456
55430: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55431: LD_ADDR_VAR 0 3
55435: PUSH
55436: LD_INT 11
55438: PUSH
55439: LD_INT 12
55441: PUSH
55442: LD_INT 13
55444: PUSH
55445: LD_INT 14
55447: PUSH
55448: EMPTY
55449: LIST
55450: LIST
55451: LIST
55452: LIST
55453: ST_TO_ADDR
55454: GO 56031
55456: LD_INT 23
55458: DOUBLE
55459: EQUAL
55460: IFTRUE 55464
55462: GO 55490
55464: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55465: LD_ADDR_VAR 0 3
55469: PUSH
55470: LD_INT 11
55472: PUSH
55473: LD_INT 12
55475: PUSH
55476: LD_INT 13
55478: PUSH
55479: LD_INT 14
55481: PUSH
55482: EMPTY
55483: LIST
55484: LIST
55485: LIST
55486: LIST
55487: ST_TO_ADDR
55488: GO 56031
55490: LD_INT 24
55492: DOUBLE
55493: EQUAL
55494: IFTRUE 55498
55496: GO 55524
55498: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55499: LD_ADDR_VAR 0 3
55503: PUSH
55504: LD_INT 11
55506: PUSH
55507: LD_INT 12
55509: PUSH
55510: LD_INT 13
55512: PUSH
55513: LD_INT 14
55515: PUSH
55516: EMPTY
55517: LIST
55518: LIST
55519: LIST
55520: LIST
55521: ST_TO_ADDR
55522: GO 56031
55524: LD_INT 30
55526: DOUBLE
55527: EQUAL
55528: IFTRUE 55532
55530: GO 55558
55532: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55533: LD_ADDR_VAR 0 3
55537: PUSH
55538: LD_INT 11
55540: PUSH
55541: LD_INT 12
55543: PUSH
55544: LD_INT 13
55546: PUSH
55547: LD_INT 14
55549: PUSH
55550: EMPTY
55551: LIST
55552: LIST
55553: LIST
55554: LIST
55555: ST_TO_ADDR
55556: GO 56031
55558: LD_INT 25
55560: DOUBLE
55561: EQUAL
55562: IFTRUE 55566
55564: GO 55584
55566: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55567: LD_ADDR_VAR 0 3
55571: PUSH
55572: LD_INT 13
55574: PUSH
55575: LD_INT 14
55577: PUSH
55578: EMPTY
55579: LIST
55580: LIST
55581: ST_TO_ADDR
55582: GO 56031
55584: LD_INT 27
55586: DOUBLE
55587: EQUAL
55588: IFTRUE 55592
55590: GO 55610
55592: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55593: LD_ADDR_VAR 0 3
55597: PUSH
55598: LD_INT 13
55600: PUSH
55601: LD_INT 14
55603: PUSH
55604: EMPTY
55605: LIST
55606: LIST
55607: ST_TO_ADDR
55608: GO 56031
55610: LD_INT 28
55612: DOUBLE
55613: EQUAL
55614: IFTRUE 55618
55616: GO 55636
55618: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55619: LD_ADDR_VAR 0 3
55623: PUSH
55624: LD_INT 13
55626: PUSH
55627: LD_INT 14
55629: PUSH
55630: EMPTY
55631: LIST
55632: LIST
55633: ST_TO_ADDR
55634: GO 56031
55636: LD_INT 29
55638: DOUBLE
55639: EQUAL
55640: IFTRUE 55644
55642: GO 55662
55644: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55645: LD_ADDR_VAR 0 3
55649: PUSH
55650: LD_INT 13
55652: PUSH
55653: LD_INT 14
55655: PUSH
55656: EMPTY
55657: LIST
55658: LIST
55659: ST_TO_ADDR
55660: GO 56031
55662: LD_INT 31
55664: DOUBLE
55665: EQUAL
55666: IFTRUE 55670
55668: GO 55688
55670: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55671: LD_ADDR_VAR 0 3
55675: PUSH
55676: LD_INT 13
55678: PUSH
55679: LD_INT 14
55681: PUSH
55682: EMPTY
55683: LIST
55684: LIST
55685: ST_TO_ADDR
55686: GO 56031
55688: LD_INT 26
55690: DOUBLE
55691: EQUAL
55692: IFTRUE 55696
55694: GO 55714
55696: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
55697: LD_ADDR_VAR 0 3
55701: PUSH
55702: LD_INT 13
55704: PUSH
55705: LD_INT 14
55707: PUSH
55708: EMPTY
55709: LIST
55710: LIST
55711: ST_TO_ADDR
55712: GO 56031
55714: LD_INT 42
55716: DOUBLE
55717: EQUAL
55718: IFTRUE 55722
55720: GO 55748
55722: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
55723: LD_ADDR_VAR 0 3
55727: PUSH
55728: LD_INT 21
55730: PUSH
55731: LD_INT 22
55733: PUSH
55734: LD_INT 23
55736: PUSH
55737: LD_INT 24
55739: PUSH
55740: EMPTY
55741: LIST
55742: LIST
55743: LIST
55744: LIST
55745: ST_TO_ADDR
55746: GO 56031
55748: LD_INT 43
55750: DOUBLE
55751: EQUAL
55752: IFTRUE 55756
55754: GO 55782
55756: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
55757: LD_ADDR_VAR 0 3
55761: PUSH
55762: LD_INT 21
55764: PUSH
55765: LD_INT 22
55767: PUSH
55768: LD_INT 23
55770: PUSH
55771: LD_INT 24
55773: PUSH
55774: EMPTY
55775: LIST
55776: LIST
55777: LIST
55778: LIST
55779: ST_TO_ADDR
55780: GO 56031
55782: LD_INT 44
55784: DOUBLE
55785: EQUAL
55786: IFTRUE 55790
55788: GO 55816
55790: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
55791: LD_ADDR_VAR 0 3
55795: PUSH
55796: LD_INT 21
55798: PUSH
55799: LD_INT 22
55801: PUSH
55802: LD_INT 23
55804: PUSH
55805: LD_INT 24
55807: PUSH
55808: EMPTY
55809: LIST
55810: LIST
55811: LIST
55812: LIST
55813: ST_TO_ADDR
55814: GO 56031
55816: LD_INT 45
55818: DOUBLE
55819: EQUAL
55820: IFTRUE 55824
55822: GO 55850
55824: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55825: LD_ADDR_VAR 0 3
55829: PUSH
55830: LD_INT 21
55832: PUSH
55833: LD_INT 22
55835: PUSH
55836: LD_INT 23
55838: PUSH
55839: LD_INT 24
55841: PUSH
55842: EMPTY
55843: LIST
55844: LIST
55845: LIST
55846: LIST
55847: ST_TO_ADDR
55848: GO 56031
55850: LD_INT 49
55852: DOUBLE
55853: EQUAL
55854: IFTRUE 55858
55856: GO 55884
55858: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55859: LD_ADDR_VAR 0 3
55863: PUSH
55864: LD_INT 21
55866: PUSH
55867: LD_INT 22
55869: PUSH
55870: LD_INT 23
55872: PUSH
55873: LD_INT 24
55875: PUSH
55876: EMPTY
55877: LIST
55878: LIST
55879: LIST
55880: LIST
55881: ST_TO_ADDR
55882: GO 56031
55884: LD_INT 51
55886: DOUBLE
55887: EQUAL
55888: IFTRUE 55892
55890: GO 55918
55892: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55893: LD_ADDR_VAR 0 3
55897: PUSH
55898: LD_INT 21
55900: PUSH
55901: LD_INT 22
55903: PUSH
55904: LD_INT 23
55906: PUSH
55907: LD_INT 24
55909: PUSH
55910: EMPTY
55911: LIST
55912: LIST
55913: LIST
55914: LIST
55915: ST_TO_ADDR
55916: GO 56031
55918: LD_INT 52
55920: DOUBLE
55921: EQUAL
55922: IFTRUE 55926
55924: GO 55952
55926: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55927: LD_ADDR_VAR 0 3
55931: PUSH
55932: LD_INT 21
55934: PUSH
55935: LD_INT 22
55937: PUSH
55938: LD_INT 23
55940: PUSH
55941: LD_INT 24
55943: PUSH
55944: EMPTY
55945: LIST
55946: LIST
55947: LIST
55948: LIST
55949: ST_TO_ADDR
55950: GO 56031
55952: LD_INT 53
55954: DOUBLE
55955: EQUAL
55956: IFTRUE 55960
55958: GO 55978
55960: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55961: LD_ADDR_VAR 0 3
55965: PUSH
55966: LD_INT 23
55968: PUSH
55969: LD_INT 24
55971: PUSH
55972: EMPTY
55973: LIST
55974: LIST
55975: ST_TO_ADDR
55976: GO 56031
55978: LD_INT 46
55980: DOUBLE
55981: EQUAL
55982: IFTRUE 55986
55984: GO 56004
55986: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55987: LD_ADDR_VAR 0 3
55991: PUSH
55992: LD_INT 23
55994: PUSH
55995: LD_INT 24
55997: PUSH
55998: EMPTY
55999: LIST
56000: LIST
56001: ST_TO_ADDR
56002: GO 56031
56004: LD_INT 47
56006: DOUBLE
56007: EQUAL
56008: IFTRUE 56012
56010: GO 56030
56012: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56013: LD_ADDR_VAR 0 3
56017: PUSH
56018: LD_INT 23
56020: PUSH
56021: LD_INT 24
56023: PUSH
56024: EMPTY
56025: LIST
56026: LIST
56027: ST_TO_ADDR
56028: GO 56031
56030: POP
// result := ( chassis in result ) ;
56031: LD_ADDR_VAR 0 3
56035: PUSH
56036: LD_VAR 0 1
56040: PUSH
56041: LD_VAR 0 3
56045: IN
56046: ST_TO_ADDR
// end ;
56047: LD_VAR 0 3
56051: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56052: LD_INT 0
56054: PPUSH
56055: PPUSH
56056: PPUSH
56057: PPUSH
56058: PPUSH
56059: PPUSH
56060: PPUSH
// result := array ;
56061: LD_ADDR_VAR 0 5
56065: PUSH
56066: LD_VAR 0 1
56070: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56071: LD_VAR 0 1
56075: NOT
56076: PUSH
56077: LD_VAR 0 2
56081: NOT
56082: OR
56083: PUSH
56084: LD_VAR 0 3
56088: NOT
56089: OR
56090: PUSH
56091: LD_VAR 0 2
56095: PUSH
56096: LD_VAR 0 1
56100: GREATER
56101: OR
56102: PUSH
56103: LD_VAR 0 3
56107: PUSH
56108: LD_VAR 0 1
56112: GREATER
56113: OR
56114: IFFALSE 56118
// exit ;
56116: GO 56414
// if direction then
56118: LD_VAR 0 4
56122: IFFALSE 56186
// begin d := 1 ;
56124: LD_ADDR_VAR 0 9
56128: PUSH
56129: LD_INT 1
56131: ST_TO_ADDR
// if i_from > i_to then
56132: LD_VAR 0 2
56136: PUSH
56137: LD_VAR 0 3
56141: GREATER
56142: IFFALSE 56168
// length := ( array - i_from ) + i_to else
56144: LD_ADDR_VAR 0 11
56148: PUSH
56149: LD_VAR 0 1
56153: PUSH
56154: LD_VAR 0 2
56158: MINUS
56159: PUSH
56160: LD_VAR 0 3
56164: PLUS
56165: ST_TO_ADDR
56166: GO 56184
// length := i_to - i_from ;
56168: LD_ADDR_VAR 0 11
56172: PUSH
56173: LD_VAR 0 3
56177: PUSH
56178: LD_VAR 0 2
56182: MINUS
56183: ST_TO_ADDR
// end else
56184: GO 56247
// begin d := - 1 ;
56186: LD_ADDR_VAR 0 9
56190: PUSH
56191: LD_INT 1
56193: NEG
56194: ST_TO_ADDR
// if i_from > i_to then
56195: LD_VAR 0 2
56199: PUSH
56200: LD_VAR 0 3
56204: GREATER
56205: IFFALSE 56225
// length := i_from - i_to else
56207: LD_ADDR_VAR 0 11
56211: PUSH
56212: LD_VAR 0 2
56216: PUSH
56217: LD_VAR 0 3
56221: MINUS
56222: ST_TO_ADDR
56223: GO 56247
// length := ( array - i_to ) + i_from ;
56225: LD_ADDR_VAR 0 11
56229: PUSH
56230: LD_VAR 0 1
56234: PUSH
56235: LD_VAR 0 3
56239: MINUS
56240: PUSH
56241: LD_VAR 0 2
56245: PLUS
56246: ST_TO_ADDR
// end ; if not length then
56247: LD_VAR 0 11
56251: NOT
56252: IFFALSE 56256
// exit ;
56254: GO 56414
// tmp := array ;
56256: LD_ADDR_VAR 0 10
56260: PUSH
56261: LD_VAR 0 1
56265: ST_TO_ADDR
// for i = 1 to length do
56266: LD_ADDR_VAR 0 6
56270: PUSH
56271: DOUBLE
56272: LD_INT 1
56274: DEC
56275: ST_TO_ADDR
56276: LD_VAR 0 11
56280: PUSH
56281: FOR_TO
56282: IFFALSE 56402
// begin for j = 1 to array do
56284: LD_ADDR_VAR 0 7
56288: PUSH
56289: DOUBLE
56290: LD_INT 1
56292: DEC
56293: ST_TO_ADDR
56294: LD_VAR 0 1
56298: PUSH
56299: FOR_TO
56300: IFFALSE 56388
// begin k := j + d ;
56302: LD_ADDR_VAR 0 8
56306: PUSH
56307: LD_VAR 0 7
56311: PUSH
56312: LD_VAR 0 9
56316: PLUS
56317: ST_TO_ADDR
// if k > array then
56318: LD_VAR 0 8
56322: PUSH
56323: LD_VAR 0 1
56327: GREATER
56328: IFFALSE 56338
// k := 1 ;
56330: LD_ADDR_VAR 0 8
56334: PUSH
56335: LD_INT 1
56337: ST_TO_ADDR
// if not k then
56338: LD_VAR 0 8
56342: NOT
56343: IFFALSE 56355
// k := array ;
56345: LD_ADDR_VAR 0 8
56349: PUSH
56350: LD_VAR 0 1
56354: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56355: LD_ADDR_VAR 0 10
56359: PUSH
56360: LD_VAR 0 10
56364: PPUSH
56365: LD_VAR 0 8
56369: PPUSH
56370: LD_VAR 0 1
56374: PUSH
56375: LD_VAR 0 7
56379: ARRAY
56380: PPUSH
56381: CALL_OW 1
56385: ST_TO_ADDR
// end ;
56386: GO 56299
56388: POP
56389: POP
// array := tmp ;
56390: LD_ADDR_VAR 0 1
56394: PUSH
56395: LD_VAR 0 10
56399: ST_TO_ADDR
// end ;
56400: GO 56281
56402: POP
56403: POP
// result := array ;
56404: LD_ADDR_VAR 0 5
56408: PUSH
56409: LD_VAR 0 1
56413: ST_TO_ADDR
// end ;
56414: LD_VAR 0 5
56418: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56419: LD_INT 0
56421: PPUSH
56422: PPUSH
// result := 0 ;
56423: LD_ADDR_VAR 0 3
56427: PUSH
56428: LD_INT 0
56430: ST_TO_ADDR
// if not array or not value in array then
56431: LD_VAR 0 1
56435: NOT
56436: PUSH
56437: LD_VAR 0 2
56441: PUSH
56442: LD_VAR 0 1
56446: IN
56447: NOT
56448: OR
56449: IFFALSE 56453
// exit ;
56451: GO 56507
// for i = 1 to array do
56453: LD_ADDR_VAR 0 4
56457: PUSH
56458: DOUBLE
56459: LD_INT 1
56461: DEC
56462: ST_TO_ADDR
56463: LD_VAR 0 1
56467: PUSH
56468: FOR_TO
56469: IFFALSE 56505
// if value = array [ i ] then
56471: LD_VAR 0 2
56475: PUSH
56476: LD_VAR 0 1
56480: PUSH
56481: LD_VAR 0 4
56485: ARRAY
56486: EQUAL
56487: IFFALSE 56503
// begin result := i ;
56489: LD_ADDR_VAR 0 3
56493: PUSH
56494: LD_VAR 0 4
56498: ST_TO_ADDR
// exit ;
56499: POP
56500: POP
56501: GO 56507
// end ;
56503: GO 56468
56505: POP
56506: POP
// end ;
56507: LD_VAR 0 3
56511: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56512: LD_INT 0
56514: PPUSH
// vc_chassis := chassis ;
56515: LD_ADDR_OWVAR 37
56519: PUSH
56520: LD_VAR 0 1
56524: ST_TO_ADDR
// vc_engine := engine ;
56525: LD_ADDR_OWVAR 39
56529: PUSH
56530: LD_VAR 0 2
56534: ST_TO_ADDR
// vc_control := control ;
56535: LD_ADDR_OWVAR 38
56539: PUSH
56540: LD_VAR 0 3
56544: ST_TO_ADDR
// vc_weapon := weapon ;
56545: LD_ADDR_OWVAR 40
56549: PUSH
56550: LD_VAR 0 4
56554: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56555: LD_ADDR_OWVAR 41
56559: PUSH
56560: LD_VAR 0 5
56564: ST_TO_ADDR
// end ;
56565: LD_VAR 0 6
56569: RET
// export function WantPlant ( unit ) ; var task ; begin
56570: LD_INT 0
56572: PPUSH
56573: PPUSH
// result := false ;
56574: LD_ADDR_VAR 0 2
56578: PUSH
56579: LD_INT 0
56581: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56582: LD_ADDR_VAR 0 3
56586: PUSH
56587: LD_VAR 0 1
56591: PPUSH
56592: CALL_OW 437
56596: ST_TO_ADDR
// if task then
56597: LD_VAR 0 3
56601: IFFALSE 56629
// if task [ 1 ] [ 1 ] = p then
56603: LD_VAR 0 3
56607: PUSH
56608: LD_INT 1
56610: ARRAY
56611: PUSH
56612: LD_INT 1
56614: ARRAY
56615: PUSH
56616: LD_STRING p
56618: EQUAL
56619: IFFALSE 56629
// result := true ;
56621: LD_ADDR_VAR 0 2
56625: PUSH
56626: LD_INT 1
56628: ST_TO_ADDR
// end ;
56629: LD_VAR 0 2
56633: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56634: LD_INT 0
56636: PPUSH
56637: PPUSH
56638: PPUSH
56639: PPUSH
// if pos < 1 then
56640: LD_VAR 0 2
56644: PUSH
56645: LD_INT 1
56647: LESS
56648: IFFALSE 56652
// exit ;
56650: GO 56955
// if pos = 1 then
56652: LD_VAR 0 2
56656: PUSH
56657: LD_INT 1
56659: EQUAL
56660: IFFALSE 56693
// result := Replace ( arr , pos [ 1 ] , value ) else
56662: LD_ADDR_VAR 0 4
56666: PUSH
56667: LD_VAR 0 1
56671: PPUSH
56672: LD_VAR 0 2
56676: PUSH
56677: LD_INT 1
56679: ARRAY
56680: PPUSH
56681: LD_VAR 0 3
56685: PPUSH
56686: CALL_OW 1
56690: ST_TO_ADDR
56691: GO 56955
// begin tmp := arr ;
56693: LD_ADDR_VAR 0 6
56697: PUSH
56698: LD_VAR 0 1
56702: ST_TO_ADDR
// s_arr := [ tmp ] ;
56703: LD_ADDR_VAR 0 7
56707: PUSH
56708: LD_VAR 0 6
56712: PUSH
56713: EMPTY
56714: LIST
56715: ST_TO_ADDR
// for i = 1 to pos - 1 do
56716: LD_ADDR_VAR 0 5
56720: PUSH
56721: DOUBLE
56722: LD_INT 1
56724: DEC
56725: ST_TO_ADDR
56726: LD_VAR 0 2
56730: PUSH
56731: LD_INT 1
56733: MINUS
56734: PUSH
56735: FOR_TO
56736: IFFALSE 56781
// begin tmp := tmp [ pos [ i ] ] ;
56738: LD_ADDR_VAR 0 6
56742: PUSH
56743: LD_VAR 0 6
56747: PUSH
56748: LD_VAR 0 2
56752: PUSH
56753: LD_VAR 0 5
56757: ARRAY
56758: ARRAY
56759: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
56760: LD_ADDR_VAR 0 7
56764: PUSH
56765: LD_VAR 0 7
56769: PUSH
56770: LD_VAR 0 6
56774: PUSH
56775: EMPTY
56776: LIST
56777: ADD
56778: ST_TO_ADDR
// end ;
56779: GO 56735
56781: POP
56782: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
56783: LD_ADDR_VAR 0 6
56787: PUSH
56788: LD_VAR 0 6
56792: PPUSH
56793: LD_VAR 0 2
56797: PUSH
56798: LD_VAR 0 2
56802: ARRAY
56803: PPUSH
56804: LD_VAR 0 3
56808: PPUSH
56809: CALL_OW 1
56813: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56814: LD_ADDR_VAR 0 7
56818: PUSH
56819: LD_VAR 0 7
56823: PPUSH
56824: LD_VAR 0 7
56828: PPUSH
56829: LD_VAR 0 6
56833: PPUSH
56834: CALL_OW 1
56838: ST_TO_ADDR
// for i = s_arr downto 2 do
56839: LD_ADDR_VAR 0 5
56843: PUSH
56844: DOUBLE
56845: LD_VAR 0 7
56849: INC
56850: ST_TO_ADDR
56851: LD_INT 2
56853: PUSH
56854: FOR_DOWNTO
56855: IFFALSE 56939
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56857: LD_ADDR_VAR 0 6
56861: PUSH
56862: LD_VAR 0 7
56866: PUSH
56867: LD_VAR 0 5
56871: PUSH
56872: LD_INT 1
56874: MINUS
56875: ARRAY
56876: PPUSH
56877: LD_VAR 0 2
56881: PUSH
56882: LD_VAR 0 5
56886: PUSH
56887: LD_INT 1
56889: MINUS
56890: ARRAY
56891: PPUSH
56892: LD_VAR 0 7
56896: PUSH
56897: LD_VAR 0 5
56901: ARRAY
56902: PPUSH
56903: CALL_OW 1
56907: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56908: LD_ADDR_VAR 0 7
56912: PUSH
56913: LD_VAR 0 7
56917: PPUSH
56918: LD_VAR 0 5
56922: PUSH
56923: LD_INT 1
56925: MINUS
56926: PPUSH
56927: LD_VAR 0 6
56931: PPUSH
56932: CALL_OW 1
56936: ST_TO_ADDR
// end ;
56937: GO 56854
56939: POP
56940: POP
// result := s_arr [ 1 ] ;
56941: LD_ADDR_VAR 0 4
56945: PUSH
56946: LD_VAR 0 7
56950: PUSH
56951: LD_INT 1
56953: ARRAY
56954: ST_TO_ADDR
// end ; end ;
56955: LD_VAR 0 4
56959: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56960: LD_INT 0
56962: PPUSH
56963: PPUSH
// if not list then
56964: LD_VAR 0 1
56968: NOT
56969: IFFALSE 56973
// exit ;
56971: GO 57064
// i := list [ pos1 ] ;
56973: LD_ADDR_VAR 0 5
56977: PUSH
56978: LD_VAR 0 1
56982: PUSH
56983: LD_VAR 0 2
56987: ARRAY
56988: ST_TO_ADDR
// if not i then
56989: LD_VAR 0 5
56993: NOT
56994: IFFALSE 56998
// exit ;
56996: GO 57064
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56998: LD_ADDR_VAR 0 1
57002: PUSH
57003: LD_VAR 0 1
57007: PPUSH
57008: LD_VAR 0 2
57012: PPUSH
57013: LD_VAR 0 1
57017: PUSH
57018: LD_VAR 0 3
57022: ARRAY
57023: PPUSH
57024: CALL_OW 1
57028: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57029: LD_ADDR_VAR 0 1
57033: PUSH
57034: LD_VAR 0 1
57038: PPUSH
57039: LD_VAR 0 3
57043: PPUSH
57044: LD_VAR 0 5
57048: PPUSH
57049: CALL_OW 1
57053: ST_TO_ADDR
// result := list ;
57054: LD_ADDR_VAR 0 4
57058: PUSH
57059: LD_VAR 0 1
57063: ST_TO_ADDR
// end ;
57064: LD_VAR 0 4
57068: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57069: LD_INT 0
57071: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57072: LD_ADDR_VAR 0 5
57076: PUSH
57077: LD_VAR 0 1
57081: PPUSH
57082: CALL_OW 250
57086: PPUSH
57087: LD_VAR 0 1
57091: PPUSH
57092: CALL_OW 251
57096: PPUSH
57097: LD_VAR 0 2
57101: PPUSH
57102: LD_VAR 0 3
57106: PPUSH
57107: LD_VAR 0 4
57111: PPUSH
57112: CALL 57122 0 5
57116: ST_TO_ADDR
// end ;
57117: LD_VAR 0 5
57121: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57122: LD_INT 0
57124: PPUSH
57125: PPUSH
57126: PPUSH
57127: PPUSH
// if not list then
57128: LD_VAR 0 3
57132: NOT
57133: IFFALSE 57137
// exit ;
57135: GO 57525
// result := [ ] ;
57137: LD_ADDR_VAR 0 6
57141: PUSH
57142: EMPTY
57143: ST_TO_ADDR
// for i in list do
57144: LD_ADDR_VAR 0 7
57148: PUSH
57149: LD_VAR 0 3
57153: PUSH
57154: FOR_IN
57155: IFFALSE 57357
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57157: LD_ADDR_VAR 0 9
57161: PUSH
57162: LD_VAR 0 7
57166: PPUSH
57167: LD_VAR 0 1
57171: PPUSH
57172: LD_VAR 0 2
57176: PPUSH
57177: CALL_OW 297
57181: ST_TO_ADDR
// if not result then
57182: LD_VAR 0 6
57186: NOT
57187: IFFALSE 57213
// result := [ [ i , tmp ] ] else
57189: LD_ADDR_VAR 0 6
57193: PUSH
57194: LD_VAR 0 7
57198: PUSH
57199: LD_VAR 0 9
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: PUSH
57208: EMPTY
57209: LIST
57210: ST_TO_ADDR
57211: GO 57355
// begin if result [ result ] [ 2 ] < tmp then
57213: LD_VAR 0 6
57217: PUSH
57218: LD_VAR 0 6
57222: ARRAY
57223: PUSH
57224: LD_INT 2
57226: ARRAY
57227: PUSH
57228: LD_VAR 0 9
57232: LESS
57233: IFFALSE 57275
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57235: LD_ADDR_VAR 0 6
57239: PUSH
57240: LD_VAR 0 6
57244: PPUSH
57245: LD_VAR 0 6
57249: PUSH
57250: LD_INT 1
57252: PLUS
57253: PPUSH
57254: LD_VAR 0 7
57258: PUSH
57259: LD_VAR 0 9
57263: PUSH
57264: EMPTY
57265: LIST
57266: LIST
57267: PPUSH
57268: CALL_OW 2
57272: ST_TO_ADDR
57273: GO 57355
// for j = 1 to result do
57275: LD_ADDR_VAR 0 8
57279: PUSH
57280: DOUBLE
57281: LD_INT 1
57283: DEC
57284: ST_TO_ADDR
57285: LD_VAR 0 6
57289: PUSH
57290: FOR_TO
57291: IFFALSE 57353
// begin if tmp < result [ j ] [ 2 ] then
57293: LD_VAR 0 9
57297: PUSH
57298: LD_VAR 0 6
57302: PUSH
57303: LD_VAR 0 8
57307: ARRAY
57308: PUSH
57309: LD_INT 2
57311: ARRAY
57312: LESS
57313: IFFALSE 57351
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57315: LD_ADDR_VAR 0 6
57319: PUSH
57320: LD_VAR 0 6
57324: PPUSH
57325: LD_VAR 0 8
57329: PPUSH
57330: LD_VAR 0 7
57334: PUSH
57335: LD_VAR 0 9
57339: PUSH
57340: EMPTY
57341: LIST
57342: LIST
57343: PPUSH
57344: CALL_OW 2
57348: ST_TO_ADDR
// break ;
57349: GO 57353
// end ; end ;
57351: GO 57290
57353: POP
57354: POP
// end ; end ;
57355: GO 57154
57357: POP
57358: POP
// if result and not asc then
57359: LD_VAR 0 6
57363: PUSH
57364: LD_VAR 0 4
57368: NOT
57369: AND
57370: IFFALSE 57445
// begin tmp := result ;
57372: LD_ADDR_VAR 0 9
57376: PUSH
57377: LD_VAR 0 6
57381: ST_TO_ADDR
// for i = tmp downto 1 do
57382: LD_ADDR_VAR 0 7
57386: PUSH
57387: DOUBLE
57388: LD_VAR 0 9
57392: INC
57393: ST_TO_ADDR
57394: LD_INT 1
57396: PUSH
57397: FOR_DOWNTO
57398: IFFALSE 57443
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57400: LD_ADDR_VAR 0 6
57404: PUSH
57405: LD_VAR 0 6
57409: PPUSH
57410: LD_VAR 0 9
57414: PUSH
57415: LD_VAR 0 7
57419: MINUS
57420: PUSH
57421: LD_INT 1
57423: PLUS
57424: PPUSH
57425: LD_VAR 0 9
57429: PUSH
57430: LD_VAR 0 7
57434: ARRAY
57435: PPUSH
57436: CALL_OW 1
57440: ST_TO_ADDR
57441: GO 57397
57443: POP
57444: POP
// end ; tmp := [ ] ;
57445: LD_ADDR_VAR 0 9
57449: PUSH
57450: EMPTY
57451: ST_TO_ADDR
// if mode then
57452: LD_VAR 0 5
57456: IFFALSE 57525
// begin for i = 1 to result do
57458: LD_ADDR_VAR 0 7
57462: PUSH
57463: DOUBLE
57464: LD_INT 1
57466: DEC
57467: ST_TO_ADDR
57468: LD_VAR 0 6
57472: PUSH
57473: FOR_TO
57474: IFFALSE 57513
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57476: LD_ADDR_VAR 0 9
57480: PUSH
57481: LD_VAR 0 9
57485: PPUSH
57486: LD_VAR 0 7
57490: PPUSH
57491: LD_VAR 0 6
57495: PUSH
57496: LD_VAR 0 7
57500: ARRAY
57501: PUSH
57502: LD_INT 1
57504: ARRAY
57505: PPUSH
57506: CALL_OW 1
57510: ST_TO_ADDR
57511: GO 57473
57513: POP
57514: POP
// result := tmp ;
57515: LD_ADDR_VAR 0 6
57519: PUSH
57520: LD_VAR 0 9
57524: ST_TO_ADDR
// end ; end ;
57525: LD_VAR 0 6
57529: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57530: LD_INT 0
57532: PPUSH
57533: PPUSH
57534: PPUSH
57535: PPUSH
57536: PPUSH
57537: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57538: LD_ADDR_VAR 0 5
57542: PUSH
57543: LD_INT 0
57545: PUSH
57546: LD_INT 0
57548: PUSH
57549: LD_INT 0
57551: PUSH
57552: EMPTY
57553: PUSH
57554: EMPTY
57555: LIST
57556: LIST
57557: LIST
57558: LIST
57559: ST_TO_ADDR
// if not x or not y then
57560: LD_VAR 0 2
57564: NOT
57565: PUSH
57566: LD_VAR 0 3
57570: NOT
57571: OR
57572: IFFALSE 57576
// exit ;
57574: GO 59222
// if not range then
57576: LD_VAR 0 4
57580: NOT
57581: IFFALSE 57591
// range := 10 ;
57583: LD_ADDR_VAR 0 4
57587: PUSH
57588: LD_INT 10
57590: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57591: LD_ADDR_VAR 0 8
57595: PUSH
57596: LD_INT 81
57598: PUSH
57599: LD_VAR 0 1
57603: PUSH
57604: EMPTY
57605: LIST
57606: LIST
57607: PUSH
57608: LD_INT 92
57610: PUSH
57611: LD_VAR 0 2
57615: PUSH
57616: LD_VAR 0 3
57620: PUSH
57621: LD_VAR 0 4
57625: PUSH
57626: EMPTY
57627: LIST
57628: LIST
57629: LIST
57630: LIST
57631: PUSH
57632: LD_INT 3
57634: PUSH
57635: LD_INT 21
57637: PUSH
57638: LD_INT 3
57640: PUSH
57641: EMPTY
57642: LIST
57643: LIST
57644: PUSH
57645: EMPTY
57646: LIST
57647: LIST
57648: PUSH
57649: EMPTY
57650: LIST
57651: LIST
57652: LIST
57653: PPUSH
57654: CALL_OW 69
57658: ST_TO_ADDR
// if not tmp then
57659: LD_VAR 0 8
57663: NOT
57664: IFFALSE 57668
// exit ;
57666: GO 59222
// for i in tmp do
57668: LD_ADDR_VAR 0 6
57672: PUSH
57673: LD_VAR 0 8
57677: PUSH
57678: FOR_IN
57679: IFFALSE 59197
// begin points := [ 0 , 0 , 0 ] ;
57681: LD_ADDR_VAR 0 9
57685: PUSH
57686: LD_INT 0
57688: PUSH
57689: LD_INT 0
57691: PUSH
57692: LD_INT 0
57694: PUSH
57695: EMPTY
57696: LIST
57697: LIST
57698: LIST
57699: ST_TO_ADDR
// bpoints := 1 ;
57700: LD_ADDR_VAR 0 10
57704: PUSH
57705: LD_INT 1
57707: ST_TO_ADDR
// case GetType ( i ) of unit_human :
57708: LD_VAR 0 6
57712: PPUSH
57713: CALL_OW 247
57717: PUSH
57718: LD_INT 1
57720: DOUBLE
57721: EQUAL
57722: IFTRUE 57726
57724: GO 58304
57726: POP
// begin if GetClass ( i ) = 1 then
57727: LD_VAR 0 6
57731: PPUSH
57732: CALL_OW 257
57736: PUSH
57737: LD_INT 1
57739: EQUAL
57740: IFFALSE 57761
// points := [ 10 , 5 , 3 ] ;
57742: LD_ADDR_VAR 0 9
57746: PUSH
57747: LD_INT 10
57749: PUSH
57750: LD_INT 5
57752: PUSH
57753: LD_INT 3
57755: PUSH
57756: EMPTY
57757: LIST
57758: LIST
57759: LIST
57760: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
57761: LD_VAR 0 6
57765: PPUSH
57766: CALL_OW 257
57770: PUSH
57771: LD_INT 2
57773: PUSH
57774: LD_INT 3
57776: PUSH
57777: LD_INT 4
57779: PUSH
57780: EMPTY
57781: LIST
57782: LIST
57783: LIST
57784: IN
57785: IFFALSE 57806
// points := [ 3 , 2 , 1 ] ;
57787: LD_ADDR_VAR 0 9
57791: PUSH
57792: LD_INT 3
57794: PUSH
57795: LD_INT 2
57797: PUSH
57798: LD_INT 1
57800: PUSH
57801: EMPTY
57802: LIST
57803: LIST
57804: LIST
57805: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57806: LD_VAR 0 6
57810: PPUSH
57811: CALL_OW 257
57815: PUSH
57816: LD_INT 5
57818: EQUAL
57819: IFFALSE 57840
// points := [ 130 , 5 , 2 ] ;
57821: LD_ADDR_VAR 0 9
57825: PUSH
57826: LD_INT 130
57828: PUSH
57829: LD_INT 5
57831: PUSH
57832: LD_INT 2
57834: PUSH
57835: EMPTY
57836: LIST
57837: LIST
57838: LIST
57839: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57840: LD_VAR 0 6
57844: PPUSH
57845: CALL_OW 257
57849: PUSH
57850: LD_INT 8
57852: EQUAL
57853: IFFALSE 57874
// points := [ 35 , 35 , 30 ] ;
57855: LD_ADDR_VAR 0 9
57859: PUSH
57860: LD_INT 35
57862: PUSH
57863: LD_INT 35
57865: PUSH
57866: LD_INT 30
57868: PUSH
57869: EMPTY
57870: LIST
57871: LIST
57872: LIST
57873: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57874: LD_VAR 0 6
57878: PPUSH
57879: CALL_OW 257
57883: PUSH
57884: LD_INT 9
57886: EQUAL
57887: IFFALSE 57908
// points := [ 20 , 55 , 40 ] ;
57889: LD_ADDR_VAR 0 9
57893: PUSH
57894: LD_INT 20
57896: PUSH
57897: LD_INT 55
57899: PUSH
57900: LD_INT 40
57902: PUSH
57903: EMPTY
57904: LIST
57905: LIST
57906: LIST
57907: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57908: LD_VAR 0 6
57912: PPUSH
57913: CALL_OW 257
57917: PUSH
57918: LD_INT 12
57920: PUSH
57921: LD_INT 16
57923: PUSH
57924: EMPTY
57925: LIST
57926: LIST
57927: IN
57928: IFFALSE 57949
// points := [ 5 , 3 , 2 ] ;
57930: LD_ADDR_VAR 0 9
57934: PUSH
57935: LD_INT 5
57937: PUSH
57938: LD_INT 3
57940: PUSH
57941: LD_INT 2
57943: PUSH
57944: EMPTY
57945: LIST
57946: LIST
57947: LIST
57948: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57949: LD_VAR 0 6
57953: PPUSH
57954: CALL_OW 257
57958: PUSH
57959: LD_INT 17
57961: EQUAL
57962: IFFALSE 57983
// points := [ 100 , 50 , 75 ] ;
57964: LD_ADDR_VAR 0 9
57968: PUSH
57969: LD_INT 100
57971: PUSH
57972: LD_INT 50
57974: PUSH
57975: LD_INT 75
57977: PUSH
57978: EMPTY
57979: LIST
57980: LIST
57981: LIST
57982: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57983: LD_VAR 0 6
57987: PPUSH
57988: CALL_OW 257
57992: PUSH
57993: LD_INT 15
57995: EQUAL
57996: IFFALSE 58017
// points := [ 10 , 5 , 3 ] ;
57998: LD_ADDR_VAR 0 9
58002: PUSH
58003: LD_INT 10
58005: PUSH
58006: LD_INT 5
58008: PUSH
58009: LD_INT 3
58011: PUSH
58012: EMPTY
58013: LIST
58014: LIST
58015: LIST
58016: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58017: LD_VAR 0 6
58021: PPUSH
58022: CALL_OW 257
58026: PUSH
58027: LD_INT 14
58029: EQUAL
58030: IFFALSE 58051
// points := [ 10 , 0 , 0 ] ;
58032: LD_ADDR_VAR 0 9
58036: PUSH
58037: LD_INT 10
58039: PUSH
58040: LD_INT 0
58042: PUSH
58043: LD_INT 0
58045: PUSH
58046: EMPTY
58047: LIST
58048: LIST
58049: LIST
58050: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58051: LD_VAR 0 6
58055: PPUSH
58056: CALL_OW 257
58060: PUSH
58061: LD_INT 11
58063: EQUAL
58064: IFFALSE 58085
// points := [ 30 , 10 , 5 ] ;
58066: LD_ADDR_VAR 0 9
58070: PUSH
58071: LD_INT 30
58073: PUSH
58074: LD_INT 10
58076: PUSH
58077: LD_INT 5
58079: PUSH
58080: EMPTY
58081: LIST
58082: LIST
58083: LIST
58084: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58085: LD_VAR 0 1
58089: PPUSH
58090: LD_INT 5
58092: PPUSH
58093: CALL_OW 321
58097: PUSH
58098: LD_INT 2
58100: EQUAL
58101: IFFALSE 58118
// bpoints := bpoints * 1.8 ;
58103: LD_ADDR_VAR 0 10
58107: PUSH
58108: LD_VAR 0 10
58112: PUSH
58113: LD_REAL  1.80000000000000E+0000
58116: MUL
58117: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58118: LD_VAR 0 6
58122: PPUSH
58123: CALL_OW 257
58127: PUSH
58128: LD_INT 1
58130: PUSH
58131: LD_INT 2
58133: PUSH
58134: LD_INT 3
58136: PUSH
58137: LD_INT 4
58139: PUSH
58140: EMPTY
58141: LIST
58142: LIST
58143: LIST
58144: LIST
58145: IN
58146: PUSH
58147: LD_VAR 0 1
58151: PPUSH
58152: LD_INT 51
58154: PPUSH
58155: CALL_OW 321
58159: PUSH
58160: LD_INT 2
58162: EQUAL
58163: AND
58164: IFFALSE 58181
// bpoints := bpoints * 1.2 ;
58166: LD_ADDR_VAR 0 10
58170: PUSH
58171: LD_VAR 0 10
58175: PUSH
58176: LD_REAL  1.20000000000000E+0000
58179: MUL
58180: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58181: LD_VAR 0 6
58185: PPUSH
58186: CALL_OW 257
58190: PUSH
58191: LD_INT 5
58193: PUSH
58194: LD_INT 7
58196: PUSH
58197: LD_INT 9
58199: PUSH
58200: EMPTY
58201: LIST
58202: LIST
58203: LIST
58204: IN
58205: PUSH
58206: LD_VAR 0 1
58210: PPUSH
58211: LD_INT 52
58213: PPUSH
58214: CALL_OW 321
58218: PUSH
58219: LD_INT 2
58221: EQUAL
58222: AND
58223: IFFALSE 58240
// bpoints := bpoints * 1.5 ;
58225: LD_ADDR_VAR 0 10
58229: PUSH
58230: LD_VAR 0 10
58234: PUSH
58235: LD_REAL  1.50000000000000E+0000
58238: MUL
58239: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58240: LD_VAR 0 1
58244: PPUSH
58245: LD_INT 66
58247: PPUSH
58248: CALL_OW 321
58252: PUSH
58253: LD_INT 2
58255: EQUAL
58256: IFFALSE 58273
// bpoints := bpoints * 1.1 ;
58258: LD_ADDR_VAR 0 10
58262: PUSH
58263: LD_VAR 0 10
58267: PUSH
58268: LD_REAL  1.10000000000000E+0000
58271: MUL
58272: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58273: LD_ADDR_VAR 0 10
58277: PUSH
58278: LD_VAR 0 10
58282: PUSH
58283: LD_VAR 0 6
58287: PPUSH
58288: LD_INT 1
58290: PPUSH
58291: CALL_OW 259
58295: PUSH
58296: LD_REAL  1.15000000000000E+0000
58299: MUL
58300: MUL
58301: ST_TO_ADDR
// end ; unit_vehicle :
58302: GO 59126
58304: LD_INT 2
58306: DOUBLE
58307: EQUAL
58308: IFTRUE 58312
58310: GO 59114
58312: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58313: LD_VAR 0 6
58317: PPUSH
58318: CALL_OW 264
58322: PUSH
58323: LD_INT 2
58325: PUSH
58326: LD_INT 42
58328: PUSH
58329: LD_INT 24
58331: PUSH
58332: EMPTY
58333: LIST
58334: LIST
58335: LIST
58336: IN
58337: IFFALSE 58358
// points := [ 25 , 5 , 3 ] ;
58339: LD_ADDR_VAR 0 9
58343: PUSH
58344: LD_INT 25
58346: PUSH
58347: LD_INT 5
58349: PUSH
58350: LD_INT 3
58352: PUSH
58353: EMPTY
58354: LIST
58355: LIST
58356: LIST
58357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58358: LD_VAR 0 6
58362: PPUSH
58363: CALL_OW 264
58367: PUSH
58368: LD_INT 4
58370: PUSH
58371: LD_INT 43
58373: PUSH
58374: LD_INT 25
58376: PUSH
58377: EMPTY
58378: LIST
58379: LIST
58380: LIST
58381: IN
58382: IFFALSE 58403
// points := [ 40 , 15 , 5 ] ;
58384: LD_ADDR_VAR 0 9
58388: PUSH
58389: LD_INT 40
58391: PUSH
58392: LD_INT 15
58394: PUSH
58395: LD_INT 5
58397: PUSH
58398: EMPTY
58399: LIST
58400: LIST
58401: LIST
58402: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58403: LD_VAR 0 6
58407: PPUSH
58408: CALL_OW 264
58412: PUSH
58413: LD_INT 3
58415: PUSH
58416: LD_INT 23
58418: PUSH
58419: EMPTY
58420: LIST
58421: LIST
58422: IN
58423: IFFALSE 58444
// points := [ 7 , 25 , 8 ] ;
58425: LD_ADDR_VAR 0 9
58429: PUSH
58430: LD_INT 7
58432: PUSH
58433: LD_INT 25
58435: PUSH
58436: LD_INT 8
58438: PUSH
58439: EMPTY
58440: LIST
58441: LIST
58442: LIST
58443: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58444: LD_VAR 0 6
58448: PPUSH
58449: CALL_OW 264
58453: PUSH
58454: LD_INT 5
58456: PUSH
58457: LD_INT 27
58459: PUSH
58460: LD_INT 44
58462: PUSH
58463: EMPTY
58464: LIST
58465: LIST
58466: LIST
58467: IN
58468: IFFALSE 58489
// points := [ 14 , 50 , 16 ] ;
58470: LD_ADDR_VAR 0 9
58474: PUSH
58475: LD_INT 14
58477: PUSH
58478: LD_INT 50
58480: PUSH
58481: LD_INT 16
58483: PUSH
58484: EMPTY
58485: LIST
58486: LIST
58487: LIST
58488: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58489: LD_VAR 0 6
58493: PPUSH
58494: CALL_OW 264
58498: PUSH
58499: LD_INT 6
58501: PUSH
58502: LD_INT 46
58504: PUSH
58505: EMPTY
58506: LIST
58507: LIST
58508: IN
58509: IFFALSE 58530
// points := [ 32 , 120 , 70 ] ;
58511: LD_ADDR_VAR 0 9
58515: PUSH
58516: LD_INT 32
58518: PUSH
58519: LD_INT 120
58521: PUSH
58522: LD_INT 70
58524: PUSH
58525: EMPTY
58526: LIST
58527: LIST
58528: LIST
58529: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
58530: LD_VAR 0 6
58534: PPUSH
58535: CALL_OW 264
58539: PUSH
58540: LD_INT 7
58542: PUSH
58543: LD_INT 28
58545: PUSH
58546: LD_INT 45
58548: PUSH
58549: EMPTY
58550: LIST
58551: LIST
58552: LIST
58553: IN
58554: IFFALSE 58575
// points := [ 35 , 20 , 45 ] ;
58556: LD_ADDR_VAR 0 9
58560: PUSH
58561: LD_INT 35
58563: PUSH
58564: LD_INT 20
58566: PUSH
58567: LD_INT 45
58569: PUSH
58570: EMPTY
58571: LIST
58572: LIST
58573: LIST
58574: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58575: LD_VAR 0 6
58579: PPUSH
58580: CALL_OW 264
58584: PUSH
58585: LD_INT 47
58587: PUSH
58588: EMPTY
58589: LIST
58590: IN
58591: IFFALSE 58612
// points := [ 67 , 45 , 75 ] ;
58593: LD_ADDR_VAR 0 9
58597: PUSH
58598: LD_INT 67
58600: PUSH
58601: LD_INT 45
58603: PUSH
58604: LD_INT 75
58606: PUSH
58607: EMPTY
58608: LIST
58609: LIST
58610: LIST
58611: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58612: LD_VAR 0 6
58616: PPUSH
58617: CALL_OW 264
58621: PUSH
58622: LD_INT 26
58624: PUSH
58625: EMPTY
58626: LIST
58627: IN
58628: IFFALSE 58649
// points := [ 120 , 30 , 80 ] ;
58630: LD_ADDR_VAR 0 9
58634: PUSH
58635: LD_INT 120
58637: PUSH
58638: LD_INT 30
58640: PUSH
58641: LD_INT 80
58643: PUSH
58644: EMPTY
58645: LIST
58646: LIST
58647: LIST
58648: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58649: LD_VAR 0 6
58653: PPUSH
58654: CALL_OW 264
58658: PUSH
58659: LD_INT 22
58661: PUSH
58662: EMPTY
58663: LIST
58664: IN
58665: IFFALSE 58686
// points := [ 40 , 1 , 1 ] ;
58667: LD_ADDR_VAR 0 9
58671: PUSH
58672: LD_INT 40
58674: PUSH
58675: LD_INT 1
58677: PUSH
58678: LD_INT 1
58680: PUSH
58681: EMPTY
58682: LIST
58683: LIST
58684: LIST
58685: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
58686: LD_VAR 0 6
58690: PPUSH
58691: CALL_OW 264
58695: PUSH
58696: LD_INT 29
58698: PUSH
58699: EMPTY
58700: LIST
58701: IN
58702: IFFALSE 58723
// points := [ 70 , 200 , 400 ] ;
58704: LD_ADDR_VAR 0 9
58708: PUSH
58709: LD_INT 70
58711: PUSH
58712: LD_INT 200
58714: PUSH
58715: LD_INT 400
58717: PUSH
58718: EMPTY
58719: LIST
58720: LIST
58721: LIST
58722: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
58723: LD_VAR 0 6
58727: PPUSH
58728: CALL_OW 264
58732: PUSH
58733: LD_INT 14
58735: PUSH
58736: LD_INT 53
58738: PUSH
58739: EMPTY
58740: LIST
58741: LIST
58742: IN
58743: IFFALSE 58764
// points := [ 40 , 10 , 20 ] ;
58745: LD_ADDR_VAR 0 9
58749: PUSH
58750: LD_INT 40
58752: PUSH
58753: LD_INT 10
58755: PUSH
58756: LD_INT 20
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: LIST
58763: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
58764: LD_VAR 0 6
58768: PPUSH
58769: CALL_OW 264
58773: PUSH
58774: LD_INT 9
58776: PUSH
58777: EMPTY
58778: LIST
58779: IN
58780: IFFALSE 58801
// points := [ 5 , 70 , 20 ] ;
58782: LD_ADDR_VAR 0 9
58786: PUSH
58787: LD_INT 5
58789: PUSH
58790: LD_INT 70
58792: PUSH
58793: LD_INT 20
58795: PUSH
58796: EMPTY
58797: LIST
58798: LIST
58799: LIST
58800: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58801: LD_VAR 0 6
58805: PPUSH
58806: CALL_OW 264
58810: PUSH
58811: LD_INT 10
58813: PUSH
58814: EMPTY
58815: LIST
58816: IN
58817: IFFALSE 58838
// points := [ 35 , 110 , 70 ] ;
58819: LD_ADDR_VAR 0 9
58823: PUSH
58824: LD_INT 35
58826: PUSH
58827: LD_INT 110
58829: PUSH
58830: LD_INT 70
58832: PUSH
58833: EMPTY
58834: LIST
58835: LIST
58836: LIST
58837: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58838: LD_VAR 0 6
58842: PPUSH
58843: CALL_OW 265
58847: PUSH
58848: LD_INT 25
58850: EQUAL
58851: IFFALSE 58872
// points := [ 80 , 65 , 100 ] ;
58853: LD_ADDR_VAR 0 9
58857: PUSH
58858: LD_INT 80
58860: PUSH
58861: LD_INT 65
58863: PUSH
58864: LD_INT 100
58866: PUSH
58867: EMPTY
58868: LIST
58869: LIST
58870: LIST
58871: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58872: LD_VAR 0 6
58876: PPUSH
58877: CALL_OW 263
58881: PUSH
58882: LD_INT 1
58884: EQUAL
58885: IFFALSE 58920
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58887: LD_ADDR_VAR 0 10
58891: PUSH
58892: LD_VAR 0 10
58896: PUSH
58897: LD_VAR 0 6
58901: PPUSH
58902: CALL_OW 311
58906: PPUSH
58907: LD_INT 3
58909: PPUSH
58910: CALL_OW 259
58914: PUSH
58915: LD_INT 4
58917: MUL
58918: MUL
58919: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58920: LD_VAR 0 6
58924: PPUSH
58925: CALL_OW 263
58929: PUSH
58930: LD_INT 2
58932: EQUAL
58933: IFFALSE 58984
// begin j := IsControledBy ( i ) ;
58935: LD_ADDR_VAR 0 7
58939: PUSH
58940: LD_VAR 0 6
58944: PPUSH
58945: CALL_OW 312
58949: ST_TO_ADDR
// if j then
58950: LD_VAR 0 7
58954: IFFALSE 58984
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58956: LD_ADDR_VAR 0 10
58960: PUSH
58961: LD_VAR 0 10
58965: PUSH
58966: LD_VAR 0 7
58970: PPUSH
58971: LD_INT 3
58973: PPUSH
58974: CALL_OW 259
58978: PUSH
58979: LD_INT 3
58981: MUL
58982: MUL
58983: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58984: LD_VAR 0 6
58988: PPUSH
58989: CALL_OW 264
58993: PUSH
58994: LD_INT 5
58996: PUSH
58997: LD_INT 6
58999: PUSH
59000: LD_INT 46
59002: PUSH
59003: LD_INT 44
59005: PUSH
59006: LD_INT 47
59008: PUSH
59009: LD_INT 45
59011: PUSH
59012: LD_INT 28
59014: PUSH
59015: LD_INT 7
59017: PUSH
59018: LD_INT 27
59020: PUSH
59021: LD_INT 29
59023: PUSH
59024: EMPTY
59025: LIST
59026: LIST
59027: LIST
59028: LIST
59029: LIST
59030: LIST
59031: LIST
59032: LIST
59033: LIST
59034: LIST
59035: IN
59036: PUSH
59037: LD_VAR 0 1
59041: PPUSH
59042: LD_INT 52
59044: PPUSH
59045: CALL_OW 321
59049: PUSH
59050: LD_INT 2
59052: EQUAL
59053: AND
59054: IFFALSE 59071
// bpoints := bpoints * 1.2 ;
59056: LD_ADDR_VAR 0 10
59060: PUSH
59061: LD_VAR 0 10
59065: PUSH
59066: LD_REAL  1.20000000000000E+0000
59069: MUL
59070: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59071: LD_VAR 0 6
59075: PPUSH
59076: CALL_OW 264
59080: PUSH
59081: LD_INT 6
59083: PUSH
59084: LD_INT 46
59086: PUSH
59087: LD_INT 47
59089: PUSH
59090: EMPTY
59091: LIST
59092: LIST
59093: LIST
59094: IN
59095: IFFALSE 59112
// bpoints := bpoints * 1.2 ;
59097: LD_ADDR_VAR 0 10
59101: PUSH
59102: LD_VAR 0 10
59106: PUSH
59107: LD_REAL  1.20000000000000E+0000
59110: MUL
59111: ST_TO_ADDR
// end ; unit_building :
59112: GO 59126
59114: LD_INT 3
59116: DOUBLE
59117: EQUAL
59118: IFTRUE 59122
59120: GO 59125
59122: POP
// ; end ;
59123: GO 59126
59125: POP
// for j = 1 to 3 do
59126: LD_ADDR_VAR 0 7
59130: PUSH
59131: DOUBLE
59132: LD_INT 1
59134: DEC
59135: ST_TO_ADDR
59136: LD_INT 3
59138: PUSH
59139: FOR_TO
59140: IFFALSE 59193
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59142: LD_ADDR_VAR 0 5
59146: PUSH
59147: LD_VAR 0 5
59151: PPUSH
59152: LD_VAR 0 7
59156: PPUSH
59157: LD_VAR 0 5
59161: PUSH
59162: LD_VAR 0 7
59166: ARRAY
59167: PUSH
59168: LD_VAR 0 9
59172: PUSH
59173: LD_VAR 0 7
59177: ARRAY
59178: PUSH
59179: LD_VAR 0 10
59183: MUL
59184: PLUS
59185: PPUSH
59186: CALL_OW 1
59190: ST_TO_ADDR
59191: GO 59139
59193: POP
59194: POP
// end ;
59195: GO 57678
59197: POP
59198: POP
// result := Replace ( result , 4 , tmp ) ;
59199: LD_ADDR_VAR 0 5
59203: PUSH
59204: LD_VAR 0 5
59208: PPUSH
59209: LD_INT 4
59211: PPUSH
59212: LD_VAR 0 8
59216: PPUSH
59217: CALL_OW 1
59221: ST_TO_ADDR
// end ;
59222: LD_VAR 0 5
59226: RET
// export function DangerAtRange ( unit , range ) ; begin
59227: LD_INT 0
59229: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59230: LD_ADDR_VAR 0 3
59234: PUSH
59235: LD_VAR 0 1
59239: PPUSH
59240: CALL_OW 255
59244: PPUSH
59245: LD_VAR 0 1
59249: PPUSH
59250: CALL_OW 250
59254: PPUSH
59255: LD_VAR 0 1
59259: PPUSH
59260: CALL_OW 251
59264: PPUSH
59265: LD_VAR 0 2
59269: PPUSH
59270: CALL 57530 0 4
59274: ST_TO_ADDR
// end ;
59275: LD_VAR 0 3
59279: RET
// export function DangerInArea ( side , area ) ; begin
59280: LD_INT 0
59282: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59283: LD_ADDR_VAR 0 3
59287: PUSH
59288: LD_VAR 0 2
59292: PPUSH
59293: LD_INT 81
59295: PUSH
59296: LD_VAR 0 1
59300: PUSH
59301: EMPTY
59302: LIST
59303: LIST
59304: PPUSH
59305: CALL_OW 70
59309: ST_TO_ADDR
// end ;
59310: LD_VAR 0 3
59314: RET
// export function IsExtension ( b ) ; begin
59315: LD_INT 0
59317: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59318: LD_ADDR_VAR 0 2
59322: PUSH
59323: LD_VAR 0 1
59327: PUSH
59328: LD_INT 23
59330: PUSH
59331: LD_INT 20
59333: PUSH
59334: LD_INT 22
59336: PUSH
59337: LD_INT 17
59339: PUSH
59340: LD_INT 24
59342: PUSH
59343: LD_INT 21
59345: PUSH
59346: LD_INT 19
59348: PUSH
59349: LD_INT 16
59351: PUSH
59352: LD_INT 25
59354: PUSH
59355: LD_INT 18
59357: PUSH
59358: EMPTY
59359: LIST
59360: LIST
59361: LIST
59362: LIST
59363: LIST
59364: LIST
59365: LIST
59366: LIST
59367: LIST
59368: LIST
59369: IN
59370: ST_TO_ADDR
// end ;
59371: LD_VAR 0 2
59375: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
59376: LD_INT 0
59378: PPUSH
59379: PPUSH
59380: PPUSH
// result := [ ] ;
59381: LD_ADDR_VAR 0 3
59385: PUSH
59386: EMPTY
59387: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59388: LD_ADDR_VAR 0 4
59392: PUSH
59393: LD_VAR 0 2
59397: PPUSH
59398: LD_INT 21
59400: PUSH
59401: LD_INT 3
59403: PUSH
59404: EMPTY
59405: LIST
59406: LIST
59407: PPUSH
59408: CALL_OW 70
59412: ST_TO_ADDR
// if not tmp then
59413: LD_VAR 0 4
59417: NOT
59418: IFFALSE 59422
// exit ;
59420: GO 59480
// for i in tmp do
59422: LD_ADDR_VAR 0 5
59426: PUSH
59427: LD_VAR 0 4
59431: PUSH
59432: FOR_IN
59433: IFFALSE 59468
// if GetBase ( i ) <> base then
59435: LD_VAR 0 5
59439: PPUSH
59440: CALL_OW 274
59444: PUSH
59445: LD_VAR 0 1
59449: NONEQUAL
59450: IFFALSE 59466
// ComLinkToBase ( base , i ) ;
59452: LD_VAR 0 1
59456: PPUSH
59457: LD_VAR 0 5
59461: PPUSH
59462: CALL_OW 169
59466: GO 59432
59468: POP
59469: POP
// result := tmp ;
59470: LD_ADDR_VAR 0 3
59474: PUSH
59475: LD_VAR 0 4
59479: ST_TO_ADDR
// end ;
59480: LD_VAR 0 3
59484: RET
// export function ComComplete ( unit , b ) ; var i ; begin
59485: LD_INT 0
59487: PPUSH
59488: PPUSH
// if BuildingStatus ( b ) = bs_build then
59489: LD_VAR 0 2
59493: PPUSH
59494: CALL_OW 461
59498: PUSH
59499: LD_INT 1
59501: EQUAL
59502: IFFALSE 59562
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59504: LD_VAR 0 1
59508: PPUSH
59509: LD_STRING h
59511: PUSH
59512: LD_VAR 0 2
59516: PPUSH
59517: CALL_OW 250
59521: PUSH
59522: LD_VAR 0 2
59526: PPUSH
59527: CALL_OW 251
59531: PUSH
59532: LD_VAR 0 2
59536: PUSH
59537: LD_INT 0
59539: PUSH
59540: LD_INT 0
59542: PUSH
59543: LD_INT 0
59545: PUSH
59546: EMPTY
59547: LIST
59548: LIST
59549: LIST
59550: LIST
59551: LIST
59552: LIST
59553: LIST
59554: PUSH
59555: EMPTY
59556: LIST
59557: PPUSH
59558: CALL_OW 446
// end ;
59562: LD_VAR 0 3
59566: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59567: LD_INT 0
59569: PPUSH
59570: PPUSH
59571: PPUSH
59572: PPUSH
59573: PPUSH
59574: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
59575: LD_VAR 0 1
59579: NOT
59580: PUSH
59581: LD_VAR 0 1
59585: PPUSH
59586: CALL_OW 263
59590: PUSH
59591: LD_INT 2
59593: EQUAL
59594: NOT
59595: OR
59596: IFFALSE 59600
// exit ;
59598: GO 59916
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59600: LD_ADDR_VAR 0 6
59604: PUSH
59605: LD_INT 22
59607: PUSH
59608: LD_VAR 0 1
59612: PPUSH
59613: CALL_OW 255
59617: PUSH
59618: EMPTY
59619: LIST
59620: LIST
59621: PUSH
59622: LD_INT 2
59624: PUSH
59625: LD_INT 30
59627: PUSH
59628: LD_INT 36
59630: PUSH
59631: EMPTY
59632: LIST
59633: LIST
59634: PUSH
59635: LD_INT 34
59637: PUSH
59638: LD_INT 31
59640: PUSH
59641: EMPTY
59642: LIST
59643: LIST
59644: PUSH
59645: EMPTY
59646: LIST
59647: LIST
59648: LIST
59649: PUSH
59650: EMPTY
59651: LIST
59652: LIST
59653: PPUSH
59654: CALL_OW 69
59658: ST_TO_ADDR
// if not tmp then
59659: LD_VAR 0 6
59663: NOT
59664: IFFALSE 59668
// exit ;
59666: GO 59916
// result := [ ] ;
59668: LD_ADDR_VAR 0 2
59672: PUSH
59673: EMPTY
59674: ST_TO_ADDR
// for i in tmp do
59675: LD_ADDR_VAR 0 3
59679: PUSH
59680: LD_VAR 0 6
59684: PUSH
59685: FOR_IN
59686: IFFALSE 59757
// begin t := UnitsInside ( i ) ;
59688: LD_ADDR_VAR 0 4
59692: PUSH
59693: LD_VAR 0 3
59697: PPUSH
59698: CALL_OW 313
59702: ST_TO_ADDR
// if t then
59703: LD_VAR 0 4
59707: IFFALSE 59755
// for j in t do
59709: LD_ADDR_VAR 0 7
59713: PUSH
59714: LD_VAR 0 4
59718: PUSH
59719: FOR_IN
59720: IFFALSE 59753
// result := Insert ( result , result + 1 , j ) ;
59722: LD_ADDR_VAR 0 2
59726: PUSH
59727: LD_VAR 0 2
59731: PPUSH
59732: LD_VAR 0 2
59736: PUSH
59737: LD_INT 1
59739: PLUS
59740: PPUSH
59741: LD_VAR 0 7
59745: PPUSH
59746: CALL_OW 2
59750: ST_TO_ADDR
59751: GO 59719
59753: POP
59754: POP
// end ;
59755: GO 59685
59757: POP
59758: POP
// if not result then
59759: LD_VAR 0 2
59763: NOT
59764: IFFALSE 59768
// exit ;
59766: GO 59916
// mech := result [ 1 ] ;
59768: LD_ADDR_VAR 0 5
59772: PUSH
59773: LD_VAR 0 2
59777: PUSH
59778: LD_INT 1
59780: ARRAY
59781: ST_TO_ADDR
// if result > 1 then
59782: LD_VAR 0 2
59786: PUSH
59787: LD_INT 1
59789: GREATER
59790: IFFALSE 59902
// for i = 2 to result do
59792: LD_ADDR_VAR 0 3
59796: PUSH
59797: DOUBLE
59798: LD_INT 2
59800: DEC
59801: ST_TO_ADDR
59802: LD_VAR 0 2
59806: PUSH
59807: FOR_TO
59808: IFFALSE 59900
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59810: LD_ADDR_VAR 0 4
59814: PUSH
59815: LD_VAR 0 2
59819: PUSH
59820: LD_VAR 0 3
59824: ARRAY
59825: PPUSH
59826: LD_INT 3
59828: PPUSH
59829: CALL_OW 259
59833: PUSH
59834: LD_VAR 0 2
59838: PUSH
59839: LD_VAR 0 3
59843: ARRAY
59844: PPUSH
59845: CALL_OW 432
59849: MINUS
59850: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59851: LD_VAR 0 4
59855: PUSH
59856: LD_VAR 0 5
59860: PPUSH
59861: LD_INT 3
59863: PPUSH
59864: CALL_OW 259
59868: PUSH
59869: LD_VAR 0 5
59873: PPUSH
59874: CALL_OW 432
59878: MINUS
59879: GREATEREQUAL
59880: IFFALSE 59898
// mech := result [ i ] ;
59882: LD_ADDR_VAR 0 5
59886: PUSH
59887: LD_VAR 0 2
59891: PUSH
59892: LD_VAR 0 3
59896: ARRAY
59897: ST_TO_ADDR
// end ;
59898: GO 59807
59900: POP
59901: POP
// ComLinkTo ( vehicle , mech ) ;
59902: LD_VAR 0 1
59906: PPUSH
59907: LD_VAR 0 5
59911: PPUSH
59912: CALL_OW 135
// end ;
59916: LD_VAR 0 2
59920: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59921: LD_INT 0
59923: PPUSH
59924: PPUSH
59925: PPUSH
59926: PPUSH
59927: PPUSH
59928: PPUSH
59929: PPUSH
59930: PPUSH
59931: PPUSH
59932: PPUSH
59933: PPUSH
59934: PPUSH
59935: PPUSH
// result := [ ] ;
59936: LD_ADDR_VAR 0 7
59940: PUSH
59941: EMPTY
59942: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59943: LD_VAR 0 1
59947: PPUSH
59948: CALL_OW 266
59952: PUSH
59953: LD_INT 0
59955: PUSH
59956: LD_INT 1
59958: PUSH
59959: EMPTY
59960: LIST
59961: LIST
59962: IN
59963: NOT
59964: IFFALSE 59968
// exit ;
59966: GO 61599
// if name then
59968: LD_VAR 0 3
59972: IFFALSE 59988
// SetBName ( base_dep , name ) ;
59974: LD_VAR 0 1
59978: PPUSH
59979: LD_VAR 0 3
59983: PPUSH
59984: CALL_OW 500
// base := GetBase ( base_dep ) ;
59988: LD_ADDR_VAR 0 15
59992: PUSH
59993: LD_VAR 0 1
59997: PPUSH
59998: CALL_OW 274
60002: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60003: LD_ADDR_VAR 0 16
60007: PUSH
60008: LD_VAR 0 1
60012: PPUSH
60013: CALL_OW 255
60017: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60018: LD_ADDR_VAR 0 17
60022: PUSH
60023: LD_VAR 0 1
60027: PPUSH
60028: CALL_OW 248
60032: ST_TO_ADDR
// if sources then
60033: LD_VAR 0 5
60037: IFFALSE 60084
// for i = 1 to 3 do
60039: LD_ADDR_VAR 0 8
60043: PUSH
60044: DOUBLE
60045: LD_INT 1
60047: DEC
60048: ST_TO_ADDR
60049: LD_INT 3
60051: PUSH
60052: FOR_TO
60053: IFFALSE 60082
// AddResourceType ( base , i , sources [ i ] ) ;
60055: LD_VAR 0 15
60059: PPUSH
60060: LD_VAR 0 8
60064: PPUSH
60065: LD_VAR 0 5
60069: PUSH
60070: LD_VAR 0 8
60074: ARRAY
60075: PPUSH
60076: CALL_OW 276
60080: GO 60052
60082: POP
60083: POP
// buildings := GetBaseBuildings ( base , area ) ;
60084: LD_ADDR_VAR 0 18
60088: PUSH
60089: LD_VAR 0 15
60093: PPUSH
60094: LD_VAR 0 2
60098: PPUSH
60099: CALL 59376 0 2
60103: ST_TO_ADDR
// InitHc ;
60104: CALL_OW 19
// InitUc ;
60108: CALL_OW 18
// uc_side := side ;
60112: LD_ADDR_OWVAR 20
60116: PUSH
60117: LD_VAR 0 16
60121: ST_TO_ADDR
// uc_nation := nation ;
60122: LD_ADDR_OWVAR 21
60126: PUSH
60127: LD_VAR 0 17
60131: ST_TO_ADDR
// if buildings then
60132: LD_VAR 0 18
60136: IFFALSE 61458
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60138: LD_ADDR_VAR 0 19
60142: PUSH
60143: LD_VAR 0 18
60147: PPUSH
60148: LD_INT 2
60150: PUSH
60151: LD_INT 30
60153: PUSH
60154: LD_INT 29
60156: PUSH
60157: EMPTY
60158: LIST
60159: LIST
60160: PUSH
60161: LD_INT 30
60163: PUSH
60164: LD_INT 30
60166: PUSH
60167: EMPTY
60168: LIST
60169: LIST
60170: PUSH
60171: EMPTY
60172: LIST
60173: LIST
60174: LIST
60175: PPUSH
60176: CALL_OW 72
60180: ST_TO_ADDR
// if tmp then
60181: LD_VAR 0 19
60185: IFFALSE 60233
// for i in tmp do
60187: LD_ADDR_VAR 0 8
60191: PUSH
60192: LD_VAR 0 19
60196: PUSH
60197: FOR_IN
60198: IFFALSE 60231
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60200: LD_VAR 0 8
60204: PPUSH
60205: CALL_OW 250
60209: PPUSH
60210: LD_VAR 0 8
60214: PPUSH
60215: CALL_OW 251
60219: PPUSH
60220: LD_VAR 0 16
60224: PPUSH
60225: CALL_OW 441
60229: GO 60197
60231: POP
60232: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60233: LD_VAR 0 18
60237: PPUSH
60238: LD_INT 2
60240: PUSH
60241: LD_INT 30
60243: PUSH
60244: LD_INT 32
60246: PUSH
60247: EMPTY
60248: LIST
60249: LIST
60250: PUSH
60251: LD_INT 30
60253: PUSH
60254: LD_INT 33
60256: PUSH
60257: EMPTY
60258: LIST
60259: LIST
60260: PUSH
60261: EMPTY
60262: LIST
60263: LIST
60264: LIST
60265: PPUSH
60266: CALL_OW 72
60270: IFFALSE 60358
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60272: LD_ADDR_VAR 0 8
60276: PUSH
60277: LD_VAR 0 18
60281: PPUSH
60282: LD_INT 2
60284: PUSH
60285: LD_INT 30
60287: PUSH
60288: LD_INT 32
60290: PUSH
60291: EMPTY
60292: LIST
60293: LIST
60294: PUSH
60295: LD_INT 30
60297: PUSH
60298: LD_INT 33
60300: PUSH
60301: EMPTY
60302: LIST
60303: LIST
60304: PUSH
60305: EMPTY
60306: LIST
60307: LIST
60308: LIST
60309: PPUSH
60310: CALL_OW 72
60314: PUSH
60315: FOR_IN
60316: IFFALSE 60356
// begin if not GetBWeapon ( i ) then
60318: LD_VAR 0 8
60322: PPUSH
60323: CALL_OW 269
60327: NOT
60328: IFFALSE 60354
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60330: LD_VAR 0 8
60334: PPUSH
60335: LD_VAR 0 8
60339: PPUSH
60340: LD_VAR 0 2
60344: PPUSH
60345: CALL 61604 0 2
60349: PPUSH
60350: CALL_OW 431
// end ;
60354: GO 60315
60356: POP
60357: POP
// end ; for i = 1 to personel do
60358: LD_ADDR_VAR 0 8
60362: PUSH
60363: DOUBLE
60364: LD_INT 1
60366: DEC
60367: ST_TO_ADDR
60368: LD_VAR 0 6
60372: PUSH
60373: FOR_TO
60374: IFFALSE 61438
// begin if i > 4 then
60376: LD_VAR 0 8
60380: PUSH
60381: LD_INT 4
60383: GREATER
60384: IFFALSE 60388
// break ;
60386: GO 61438
// case i of 1 :
60388: LD_VAR 0 8
60392: PUSH
60393: LD_INT 1
60395: DOUBLE
60396: EQUAL
60397: IFTRUE 60401
60399: GO 60481
60401: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60402: LD_ADDR_VAR 0 12
60406: PUSH
60407: LD_VAR 0 18
60411: PPUSH
60412: LD_INT 22
60414: PUSH
60415: LD_VAR 0 16
60419: PUSH
60420: EMPTY
60421: LIST
60422: LIST
60423: PUSH
60424: LD_INT 58
60426: PUSH
60427: EMPTY
60428: LIST
60429: PUSH
60430: LD_INT 2
60432: PUSH
60433: LD_INT 30
60435: PUSH
60436: LD_INT 32
60438: PUSH
60439: EMPTY
60440: LIST
60441: LIST
60442: PUSH
60443: LD_INT 30
60445: PUSH
60446: LD_INT 4
60448: PUSH
60449: EMPTY
60450: LIST
60451: LIST
60452: PUSH
60453: LD_INT 30
60455: PUSH
60456: LD_INT 5
60458: PUSH
60459: EMPTY
60460: LIST
60461: LIST
60462: PUSH
60463: EMPTY
60464: LIST
60465: LIST
60466: LIST
60467: LIST
60468: PUSH
60469: EMPTY
60470: LIST
60471: LIST
60472: LIST
60473: PPUSH
60474: CALL_OW 72
60478: ST_TO_ADDR
60479: GO 60703
60481: LD_INT 2
60483: DOUBLE
60484: EQUAL
60485: IFTRUE 60489
60487: GO 60551
60489: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60490: LD_ADDR_VAR 0 12
60494: PUSH
60495: LD_VAR 0 18
60499: PPUSH
60500: LD_INT 22
60502: PUSH
60503: LD_VAR 0 16
60507: PUSH
60508: EMPTY
60509: LIST
60510: LIST
60511: PUSH
60512: LD_INT 2
60514: PUSH
60515: LD_INT 30
60517: PUSH
60518: LD_INT 0
60520: PUSH
60521: EMPTY
60522: LIST
60523: LIST
60524: PUSH
60525: LD_INT 30
60527: PUSH
60528: LD_INT 1
60530: PUSH
60531: EMPTY
60532: LIST
60533: LIST
60534: PUSH
60535: EMPTY
60536: LIST
60537: LIST
60538: LIST
60539: PUSH
60540: EMPTY
60541: LIST
60542: LIST
60543: PPUSH
60544: CALL_OW 72
60548: ST_TO_ADDR
60549: GO 60703
60551: LD_INT 3
60553: DOUBLE
60554: EQUAL
60555: IFTRUE 60559
60557: GO 60621
60559: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60560: LD_ADDR_VAR 0 12
60564: PUSH
60565: LD_VAR 0 18
60569: PPUSH
60570: LD_INT 22
60572: PUSH
60573: LD_VAR 0 16
60577: PUSH
60578: EMPTY
60579: LIST
60580: LIST
60581: PUSH
60582: LD_INT 2
60584: PUSH
60585: LD_INT 30
60587: PUSH
60588: LD_INT 2
60590: PUSH
60591: EMPTY
60592: LIST
60593: LIST
60594: PUSH
60595: LD_INT 30
60597: PUSH
60598: LD_INT 3
60600: PUSH
60601: EMPTY
60602: LIST
60603: LIST
60604: PUSH
60605: EMPTY
60606: LIST
60607: LIST
60608: LIST
60609: PUSH
60610: EMPTY
60611: LIST
60612: LIST
60613: PPUSH
60614: CALL_OW 72
60618: ST_TO_ADDR
60619: GO 60703
60621: LD_INT 4
60623: DOUBLE
60624: EQUAL
60625: IFTRUE 60629
60627: GO 60702
60629: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60630: LD_ADDR_VAR 0 12
60634: PUSH
60635: LD_VAR 0 18
60639: PPUSH
60640: LD_INT 22
60642: PUSH
60643: LD_VAR 0 16
60647: PUSH
60648: EMPTY
60649: LIST
60650: LIST
60651: PUSH
60652: LD_INT 2
60654: PUSH
60655: LD_INT 30
60657: PUSH
60658: LD_INT 6
60660: PUSH
60661: EMPTY
60662: LIST
60663: LIST
60664: PUSH
60665: LD_INT 30
60667: PUSH
60668: LD_INT 7
60670: PUSH
60671: EMPTY
60672: LIST
60673: LIST
60674: PUSH
60675: LD_INT 30
60677: PUSH
60678: LD_INT 8
60680: PUSH
60681: EMPTY
60682: LIST
60683: LIST
60684: PUSH
60685: EMPTY
60686: LIST
60687: LIST
60688: LIST
60689: LIST
60690: PUSH
60691: EMPTY
60692: LIST
60693: LIST
60694: PPUSH
60695: CALL_OW 72
60699: ST_TO_ADDR
60700: GO 60703
60702: POP
// if i = 1 then
60703: LD_VAR 0 8
60707: PUSH
60708: LD_INT 1
60710: EQUAL
60711: IFFALSE 60822
// begin tmp := [ ] ;
60713: LD_ADDR_VAR 0 19
60717: PUSH
60718: EMPTY
60719: ST_TO_ADDR
// for j in f do
60720: LD_ADDR_VAR 0 9
60724: PUSH
60725: LD_VAR 0 12
60729: PUSH
60730: FOR_IN
60731: IFFALSE 60804
// if GetBType ( j ) = b_bunker then
60733: LD_VAR 0 9
60737: PPUSH
60738: CALL_OW 266
60742: PUSH
60743: LD_INT 32
60745: EQUAL
60746: IFFALSE 60773
// tmp := Insert ( tmp , 1 , j ) else
60748: LD_ADDR_VAR 0 19
60752: PUSH
60753: LD_VAR 0 19
60757: PPUSH
60758: LD_INT 1
60760: PPUSH
60761: LD_VAR 0 9
60765: PPUSH
60766: CALL_OW 2
60770: ST_TO_ADDR
60771: GO 60802
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60773: LD_ADDR_VAR 0 19
60777: PUSH
60778: LD_VAR 0 19
60782: PPUSH
60783: LD_VAR 0 19
60787: PUSH
60788: LD_INT 1
60790: PLUS
60791: PPUSH
60792: LD_VAR 0 9
60796: PPUSH
60797: CALL_OW 2
60801: ST_TO_ADDR
60802: GO 60730
60804: POP
60805: POP
// if tmp then
60806: LD_VAR 0 19
60810: IFFALSE 60822
// f := tmp ;
60812: LD_ADDR_VAR 0 12
60816: PUSH
60817: LD_VAR 0 19
60821: ST_TO_ADDR
// end ; x := personel [ i ] ;
60822: LD_ADDR_VAR 0 13
60826: PUSH
60827: LD_VAR 0 6
60831: PUSH
60832: LD_VAR 0 8
60836: ARRAY
60837: ST_TO_ADDR
// if x = - 1 then
60838: LD_VAR 0 13
60842: PUSH
60843: LD_INT 1
60845: NEG
60846: EQUAL
60847: IFFALSE 61056
// begin for j in f do
60849: LD_ADDR_VAR 0 9
60853: PUSH
60854: LD_VAR 0 12
60858: PUSH
60859: FOR_IN
60860: IFFALSE 61052
// repeat InitHc ;
60862: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60866: LD_VAR 0 9
60870: PPUSH
60871: CALL_OW 266
60875: PUSH
60876: LD_INT 5
60878: EQUAL
60879: IFFALSE 60949
// begin if UnitsInside ( j ) < 3 then
60881: LD_VAR 0 9
60885: PPUSH
60886: CALL_OW 313
60890: PUSH
60891: LD_INT 3
60893: LESS
60894: IFFALSE 60930
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60896: LD_INT 0
60898: PPUSH
60899: LD_INT 5
60901: PUSH
60902: LD_INT 8
60904: PUSH
60905: LD_INT 9
60907: PUSH
60908: EMPTY
60909: LIST
60910: LIST
60911: LIST
60912: PUSH
60913: LD_VAR 0 17
60917: ARRAY
60918: PPUSH
60919: LD_VAR 0 4
60923: PPUSH
60924: CALL_OW 380
60928: GO 60947
// PrepareHuman ( false , i , skill ) ;
60930: LD_INT 0
60932: PPUSH
60933: LD_VAR 0 8
60937: PPUSH
60938: LD_VAR 0 4
60942: PPUSH
60943: CALL_OW 380
// end else
60947: GO 60966
// PrepareHuman ( false , i , skill ) ;
60949: LD_INT 0
60951: PPUSH
60952: LD_VAR 0 8
60956: PPUSH
60957: LD_VAR 0 4
60961: PPUSH
60962: CALL_OW 380
// un := CreateHuman ;
60966: LD_ADDR_VAR 0 14
60970: PUSH
60971: CALL_OW 44
60975: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60976: LD_ADDR_VAR 0 7
60980: PUSH
60981: LD_VAR 0 7
60985: PPUSH
60986: LD_INT 1
60988: PPUSH
60989: LD_VAR 0 14
60993: PPUSH
60994: CALL_OW 2
60998: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60999: LD_VAR 0 14
61003: PPUSH
61004: LD_VAR 0 9
61008: PPUSH
61009: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61013: LD_VAR 0 9
61017: PPUSH
61018: CALL_OW 313
61022: PUSH
61023: LD_INT 6
61025: EQUAL
61026: PUSH
61027: LD_VAR 0 9
61031: PPUSH
61032: CALL_OW 266
61036: PUSH
61037: LD_INT 32
61039: PUSH
61040: LD_INT 31
61042: PUSH
61043: EMPTY
61044: LIST
61045: LIST
61046: IN
61047: OR
61048: IFFALSE 60862
61050: GO 60859
61052: POP
61053: POP
// end else
61054: GO 61436
// for j = 1 to x do
61056: LD_ADDR_VAR 0 9
61060: PUSH
61061: DOUBLE
61062: LD_INT 1
61064: DEC
61065: ST_TO_ADDR
61066: LD_VAR 0 13
61070: PUSH
61071: FOR_TO
61072: IFFALSE 61434
// begin InitHc ;
61074: CALL_OW 19
// if not f then
61078: LD_VAR 0 12
61082: NOT
61083: IFFALSE 61172
// begin PrepareHuman ( false , i , skill ) ;
61085: LD_INT 0
61087: PPUSH
61088: LD_VAR 0 8
61092: PPUSH
61093: LD_VAR 0 4
61097: PPUSH
61098: CALL_OW 380
// un := CreateHuman ;
61102: LD_ADDR_VAR 0 14
61106: PUSH
61107: CALL_OW 44
61111: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61112: LD_ADDR_VAR 0 7
61116: PUSH
61117: LD_VAR 0 7
61121: PPUSH
61122: LD_INT 1
61124: PPUSH
61125: LD_VAR 0 14
61129: PPUSH
61130: CALL_OW 2
61134: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61135: LD_VAR 0 14
61139: PPUSH
61140: LD_VAR 0 1
61144: PPUSH
61145: CALL_OW 250
61149: PPUSH
61150: LD_VAR 0 1
61154: PPUSH
61155: CALL_OW 251
61159: PPUSH
61160: LD_INT 10
61162: PPUSH
61163: LD_INT 0
61165: PPUSH
61166: CALL_OW 50
// continue ;
61170: GO 61071
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61172: LD_VAR 0 12
61176: PUSH
61177: LD_INT 1
61179: ARRAY
61180: PPUSH
61181: CALL_OW 313
61185: PUSH
61186: LD_VAR 0 12
61190: PUSH
61191: LD_INT 1
61193: ARRAY
61194: PPUSH
61195: CALL_OW 266
61199: PUSH
61200: LD_INT 32
61202: PUSH
61203: LD_INT 31
61205: PUSH
61206: EMPTY
61207: LIST
61208: LIST
61209: IN
61210: AND
61211: PUSH
61212: LD_VAR 0 12
61216: PUSH
61217: LD_INT 1
61219: ARRAY
61220: PPUSH
61221: CALL_OW 313
61225: PUSH
61226: LD_INT 6
61228: EQUAL
61229: OR
61230: IFFALSE 61250
// f := Delete ( f , 1 ) ;
61232: LD_ADDR_VAR 0 12
61236: PUSH
61237: LD_VAR 0 12
61241: PPUSH
61242: LD_INT 1
61244: PPUSH
61245: CALL_OW 3
61249: ST_TO_ADDR
// if not f then
61250: LD_VAR 0 12
61254: NOT
61255: IFFALSE 61273
// begin x := x + 2 ;
61257: LD_ADDR_VAR 0 13
61261: PUSH
61262: LD_VAR 0 13
61266: PUSH
61267: LD_INT 2
61269: PLUS
61270: ST_TO_ADDR
// continue ;
61271: GO 61071
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61273: LD_VAR 0 12
61277: PUSH
61278: LD_INT 1
61280: ARRAY
61281: PPUSH
61282: CALL_OW 266
61286: PUSH
61287: LD_INT 5
61289: EQUAL
61290: IFFALSE 61364
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61292: LD_VAR 0 12
61296: PUSH
61297: LD_INT 1
61299: ARRAY
61300: PPUSH
61301: CALL_OW 313
61305: PUSH
61306: LD_INT 3
61308: LESS
61309: IFFALSE 61345
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61311: LD_INT 0
61313: PPUSH
61314: LD_INT 5
61316: PUSH
61317: LD_INT 8
61319: PUSH
61320: LD_INT 9
61322: PUSH
61323: EMPTY
61324: LIST
61325: LIST
61326: LIST
61327: PUSH
61328: LD_VAR 0 17
61332: ARRAY
61333: PPUSH
61334: LD_VAR 0 4
61338: PPUSH
61339: CALL_OW 380
61343: GO 61362
// PrepareHuman ( false , i , skill ) ;
61345: LD_INT 0
61347: PPUSH
61348: LD_VAR 0 8
61352: PPUSH
61353: LD_VAR 0 4
61357: PPUSH
61358: CALL_OW 380
// end else
61362: GO 61381
// PrepareHuman ( false , i , skill ) ;
61364: LD_INT 0
61366: PPUSH
61367: LD_VAR 0 8
61371: PPUSH
61372: LD_VAR 0 4
61376: PPUSH
61377: CALL_OW 380
// un := CreateHuman ;
61381: LD_ADDR_VAR 0 14
61385: PUSH
61386: CALL_OW 44
61390: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61391: LD_ADDR_VAR 0 7
61395: PUSH
61396: LD_VAR 0 7
61400: PPUSH
61401: LD_INT 1
61403: PPUSH
61404: LD_VAR 0 14
61408: PPUSH
61409: CALL_OW 2
61413: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61414: LD_VAR 0 14
61418: PPUSH
61419: LD_VAR 0 12
61423: PUSH
61424: LD_INT 1
61426: ARRAY
61427: PPUSH
61428: CALL_OW 52
// end ;
61432: GO 61071
61434: POP
61435: POP
// end ;
61436: GO 60373
61438: POP
61439: POP
// result := result ^ buildings ;
61440: LD_ADDR_VAR 0 7
61444: PUSH
61445: LD_VAR 0 7
61449: PUSH
61450: LD_VAR 0 18
61454: ADD
61455: ST_TO_ADDR
// end else
61456: GO 61599
// begin for i = 1 to personel do
61458: LD_ADDR_VAR 0 8
61462: PUSH
61463: DOUBLE
61464: LD_INT 1
61466: DEC
61467: ST_TO_ADDR
61468: LD_VAR 0 6
61472: PUSH
61473: FOR_TO
61474: IFFALSE 61597
// begin if i > 4 then
61476: LD_VAR 0 8
61480: PUSH
61481: LD_INT 4
61483: GREATER
61484: IFFALSE 61488
// break ;
61486: GO 61597
// x := personel [ i ] ;
61488: LD_ADDR_VAR 0 13
61492: PUSH
61493: LD_VAR 0 6
61497: PUSH
61498: LD_VAR 0 8
61502: ARRAY
61503: ST_TO_ADDR
// if x = - 1 then
61504: LD_VAR 0 13
61508: PUSH
61509: LD_INT 1
61511: NEG
61512: EQUAL
61513: IFFALSE 61517
// continue ;
61515: GO 61473
// PrepareHuman ( false , i , skill ) ;
61517: LD_INT 0
61519: PPUSH
61520: LD_VAR 0 8
61524: PPUSH
61525: LD_VAR 0 4
61529: PPUSH
61530: CALL_OW 380
// un := CreateHuman ;
61534: LD_ADDR_VAR 0 14
61538: PUSH
61539: CALL_OW 44
61543: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61544: LD_VAR 0 14
61548: PPUSH
61549: LD_VAR 0 1
61553: PPUSH
61554: CALL_OW 250
61558: PPUSH
61559: LD_VAR 0 1
61563: PPUSH
61564: CALL_OW 251
61568: PPUSH
61569: LD_INT 10
61571: PPUSH
61572: LD_INT 0
61574: PPUSH
61575: CALL_OW 50
// result := result ^ un ;
61579: LD_ADDR_VAR 0 7
61583: PUSH
61584: LD_VAR 0 7
61588: PUSH
61589: LD_VAR 0 14
61593: ADD
61594: ST_TO_ADDR
// end ;
61595: GO 61473
61597: POP
61598: POP
// end ; end ;
61599: LD_VAR 0 7
61603: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61604: LD_INT 0
61606: PPUSH
61607: PPUSH
61608: PPUSH
61609: PPUSH
61610: PPUSH
61611: PPUSH
61612: PPUSH
61613: PPUSH
61614: PPUSH
61615: PPUSH
61616: PPUSH
61617: PPUSH
61618: PPUSH
61619: PPUSH
61620: PPUSH
61621: PPUSH
// result := false ;
61622: LD_ADDR_VAR 0 3
61626: PUSH
61627: LD_INT 0
61629: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61630: LD_VAR 0 1
61634: NOT
61635: PUSH
61636: LD_VAR 0 1
61640: PPUSH
61641: CALL_OW 266
61645: PUSH
61646: LD_INT 32
61648: PUSH
61649: LD_INT 33
61651: PUSH
61652: EMPTY
61653: LIST
61654: LIST
61655: IN
61656: NOT
61657: OR
61658: IFFALSE 61662
// exit ;
61660: GO 62798
// nat := GetNation ( tower ) ;
61662: LD_ADDR_VAR 0 12
61666: PUSH
61667: LD_VAR 0 1
61671: PPUSH
61672: CALL_OW 248
61676: ST_TO_ADDR
// side := GetSide ( tower ) ;
61677: LD_ADDR_VAR 0 16
61681: PUSH
61682: LD_VAR 0 1
61686: PPUSH
61687: CALL_OW 255
61691: ST_TO_ADDR
// x := GetX ( tower ) ;
61692: LD_ADDR_VAR 0 10
61696: PUSH
61697: LD_VAR 0 1
61701: PPUSH
61702: CALL_OW 250
61706: ST_TO_ADDR
// y := GetY ( tower ) ;
61707: LD_ADDR_VAR 0 11
61711: PUSH
61712: LD_VAR 0 1
61716: PPUSH
61717: CALL_OW 251
61721: ST_TO_ADDR
// if not x or not y then
61722: LD_VAR 0 10
61726: NOT
61727: PUSH
61728: LD_VAR 0 11
61732: NOT
61733: OR
61734: IFFALSE 61738
// exit ;
61736: GO 62798
// weapon := 0 ;
61738: LD_ADDR_VAR 0 18
61742: PUSH
61743: LD_INT 0
61745: ST_TO_ADDR
// fac_list := [ ] ;
61746: LD_ADDR_VAR 0 17
61750: PUSH
61751: EMPTY
61752: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
61753: LD_ADDR_VAR 0 6
61757: PUSH
61758: LD_VAR 0 1
61762: PPUSH
61763: CALL_OW 274
61767: PPUSH
61768: LD_VAR 0 2
61772: PPUSH
61773: CALL 59376 0 2
61777: PPUSH
61778: LD_INT 30
61780: PUSH
61781: LD_INT 3
61783: PUSH
61784: EMPTY
61785: LIST
61786: LIST
61787: PPUSH
61788: CALL_OW 72
61792: ST_TO_ADDR
// if not factories then
61793: LD_VAR 0 6
61797: NOT
61798: IFFALSE 61802
// exit ;
61800: GO 62798
// for i in factories do
61802: LD_ADDR_VAR 0 8
61806: PUSH
61807: LD_VAR 0 6
61811: PUSH
61812: FOR_IN
61813: IFFALSE 61838
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61815: LD_ADDR_VAR 0 17
61819: PUSH
61820: LD_VAR 0 17
61824: PUSH
61825: LD_VAR 0 8
61829: PPUSH
61830: CALL_OW 478
61834: UNION
61835: ST_TO_ADDR
61836: GO 61812
61838: POP
61839: POP
// if not fac_list then
61840: LD_VAR 0 17
61844: NOT
61845: IFFALSE 61849
// exit ;
61847: GO 62798
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61849: LD_ADDR_VAR 0 5
61853: PUSH
61854: LD_INT 4
61856: PUSH
61857: LD_INT 5
61859: PUSH
61860: LD_INT 9
61862: PUSH
61863: LD_INT 10
61865: PUSH
61866: LD_INT 6
61868: PUSH
61869: LD_INT 7
61871: PUSH
61872: LD_INT 11
61874: PUSH
61875: EMPTY
61876: LIST
61877: LIST
61878: LIST
61879: LIST
61880: LIST
61881: LIST
61882: LIST
61883: PUSH
61884: LD_INT 27
61886: PUSH
61887: LD_INT 28
61889: PUSH
61890: LD_INT 26
61892: PUSH
61893: LD_INT 30
61895: PUSH
61896: EMPTY
61897: LIST
61898: LIST
61899: LIST
61900: LIST
61901: PUSH
61902: LD_INT 43
61904: PUSH
61905: LD_INT 44
61907: PUSH
61908: LD_INT 46
61910: PUSH
61911: LD_INT 45
61913: PUSH
61914: LD_INT 47
61916: PUSH
61917: LD_INT 49
61919: PUSH
61920: EMPTY
61921: LIST
61922: LIST
61923: LIST
61924: LIST
61925: LIST
61926: LIST
61927: PUSH
61928: EMPTY
61929: LIST
61930: LIST
61931: LIST
61932: PUSH
61933: LD_VAR 0 12
61937: ARRAY
61938: ST_TO_ADDR
// for i in list do
61939: LD_ADDR_VAR 0 8
61943: PUSH
61944: LD_VAR 0 5
61948: PUSH
61949: FOR_IN
61950: IFFALSE 61983
// if not i in fac_list then
61952: LD_VAR 0 8
61956: PUSH
61957: LD_VAR 0 17
61961: IN
61962: NOT
61963: IFFALSE 61981
// list := list diff i ;
61965: LD_ADDR_VAR 0 5
61969: PUSH
61970: LD_VAR 0 5
61974: PUSH
61975: LD_VAR 0 8
61979: DIFF
61980: ST_TO_ADDR
61981: GO 61949
61983: POP
61984: POP
// if not list then
61985: LD_VAR 0 5
61989: NOT
61990: IFFALSE 61994
// exit ;
61992: GO 62798
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61994: LD_VAR 0 12
61998: PUSH
61999: LD_INT 3
62001: EQUAL
62002: PUSH
62003: LD_INT 49
62005: PUSH
62006: LD_VAR 0 5
62010: IN
62011: AND
62012: PUSH
62013: LD_INT 31
62015: PPUSH
62016: LD_VAR 0 16
62020: PPUSH
62021: CALL_OW 321
62025: PUSH
62026: LD_INT 2
62028: EQUAL
62029: AND
62030: IFFALSE 62090
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62032: LD_INT 22
62034: PUSH
62035: LD_VAR 0 16
62039: PUSH
62040: EMPTY
62041: LIST
62042: LIST
62043: PUSH
62044: LD_INT 35
62046: PUSH
62047: LD_INT 49
62049: PUSH
62050: EMPTY
62051: LIST
62052: LIST
62053: PUSH
62054: LD_INT 91
62056: PUSH
62057: LD_VAR 0 1
62061: PUSH
62062: LD_INT 10
62064: PUSH
62065: EMPTY
62066: LIST
62067: LIST
62068: LIST
62069: PUSH
62070: EMPTY
62071: LIST
62072: LIST
62073: LIST
62074: PPUSH
62075: CALL_OW 69
62079: NOT
62080: IFFALSE 62090
// weapon := ru_time_lapser ;
62082: LD_ADDR_VAR 0 18
62086: PUSH
62087: LD_INT 49
62089: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62090: LD_VAR 0 12
62094: PUSH
62095: LD_INT 1
62097: PUSH
62098: LD_INT 2
62100: PUSH
62101: EMPTY
62102: LIST
62103: LIST
62104: IN
62105: PUSH
62106: LD_INT 11
62108: PUSH
62109: LD_VAR 0 5
62113: IN
62114: PUSH
62115: LD_INT 30
62117: PUSH
62118: LD_VAR 0 5
62122: IN
62123: OR
62124: AND
62125: PUSH
62126: LD_INT 6
62128: PPUSH
62129: LD_VAR 0 16
62133: PPUSH
62134: CALL_OW 321
62138: PUSH
62139: LD_INT 2
62141: EQUAL
62142: AND
62143: IFFALSE 62308
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62145: LD_INT 22
62147: PUSH
62148: LD_VAR 0 16
62152: PUSH
62153: EMPTY
62154: LIST
62155: LIST
62156: PUSH
62157: LD_INT 2
62159: PUSH
62160: LD_INT 35
62162: PUSH
62163: LD_INT 11
62165: PUSH
62166: EMPTY
62167: LIST
62168: LIST
62169: PUSH
62170: LD_INT 35
62172: PUSH
62173: LD_INT 30
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: PUSH
62180: EMPTY
62181: LIST
62182: LIST
62183: LIST
62184: PUSH
62185: LD_INT 91
62187: PUSH
62188: LD_VAR 0 1
62192: PUSH
62193: LD_INT 18
62195: PUSH
62196: EMPTY
62197: LIST
62198: LIST
62199: LIST
62200: PUSH
62201: EMPTY
62202: LIST
62203: LIST
62204: LIST
62205: PPUSH
62206: CALL_OW 69
62210: NOT
62211: PUSH
62212: LD_INT 22
62214: PUSH
62215: LD_VAR 0 16
62219: PUSH
62220: EMPTY
62221: LIST
62222: LIST
62223: PUSH
62224: LD_INT 2
62226: PUSH
62227: LD_INT 30
62229: PUSH
62230: LD_INT 32
62232: PUSH
62233: EMPTY
62234: LIST
62235: LIST
62236: PUSH
62237: LD_INT 30
62239: PUSH
62240: LD_INT 33
62242: PUSH
62243: EMPTY
62244: LIST
62245: LIST
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: LIST
62251: PUSH
62252: LD_INT 91
62254: PUSH
62255: LD_VAR 0 1
62259: PUSH
62260: LD_INT 12
62262: PUSH
62263: EMPTY
62264: LIST
62265: LIST
62266: LIST
62267: PUSH
62268: EMPTY
62269: LIST
62270: LIST
62271: LIST
62272: PUSH
62273: EMPTY
62274: LIST
62275: PPUSH
62276: CALL_OW 69
62280: PUSH
62281: LD_INT 2
62283: GREATER
62284: AND
62285: IFFALSE 62308
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62287: LD_ADDR_VAR 0 18
62291: PUSH
62292: LD_INT 11
62294: PUSH
62295: LD_INT 30
62297: PUSH
62298: EMPTY
62299: LIST
62300: LIST
62301: PUSH
62302: LD_VAR 0 12
62306: ARRAY
62307: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62308: LD_VAR 0 18
62312: NOT
62313: PUSH
62314: LD_INT 40
62316: PPUSH
62317: LD_VAR 0 16
62321: PPUSH
62322: CALL_OW 321
62326: PUSH
62327: LD_INT 2
62329: EQUAL
62330: AND
62331: PUSH
62332: LD_INT 7
62334: PUSH
62335: LD_VAR 0 5
62339: IN
62340: PUSH
62341: LD_INT 28
62343: PUSH
62344: LD_VAR 0 5
62348: IN
62349: OR
62350: PUSH
62351: LD_INT 45
62353: PUSH
62354: LD_VAR 0 5
62358: IN
62359: OR
62360: AND
62361: IFFALSE 62615
// begin hex := GetHexInfo ( x , y ) ;
62363: LD_ADDR_VAR 0 4
62367: PUSH
62368: LD_VAR 0 10
62372: PPUSH
62373: LD_VAR 0 11
62377: PPUSH
62378: CALL_OW 546
62382: ST_TO_ADDR
// if hex [ 1 ] then
62383: LD_VAR 0 4
62387: PUSH
62388: LD_INT 1
62390: ARRAY
62391: IFFALSE 62395
// exit ;
62393: GO 62798
// height := hex [ 2 ] ;
62395: LD_ADDR_VAR 0 15
62399: PUSH
62400: LD_VAR 0 4
62404: PUSH
62405: LD_INT 2
62407: ARRAY
62408: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62409: LD_ADDR_VAR 0 14
62413: PUSH
62414: LD_INT 0
62416: PUSH
62417: LD_INT 2
62419: PUSH
62420: LD_INT 3
62422: PUSH
62423: LD_INT 5
62425: PUSH
62426: EMPTY
62427: LIST
62428: LIST
62429: LIST
62430: LIST
62431: ST_TO_ADDR
// for i in tmp do
62432: LD_ADDR_VAR 0 8
62436: PUSH
62437: LD_VAR 0 14
62441: PUSH
62442: FOR_IN
62443: IFFALSE 62613
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62445: LD_ADDR_VAR 0 9
62449: PUSH
62450: LD_VAR 0 10
62454: PPUSH
62455: LD_VAR 0 8
62459: PPUSH
62460: LD_INT 5
62462: PPUSH
62463: CALL_OW 272
62467: PUSH
62468: LD_VAR 0 11
62472: PPUSH
62473: LD_VAR 0 8
62477: PPUSH
62478: LD_INT 5
62480: PPUSH
62481: CALL_OW 273
62485: PUSH
62486: EMPTY
62487: LIST
62488: LIST
62489: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62490: LD_VAR 0 9
62494: PUSH
62495: LD_INT 1
62497: ARRAY
62498: PPUSH
62499: LD_VAR 0 9
62503: PUSH
62504: LD_INT 2
62506: ARRAY
62507: PPUSH
62508: CALL_OW 488
62512: IFFALSE 62611
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62514: LD_ADDR_VAR 0 4
62518: PUSH
62519: LD_VAR 0 9
62523: PUSH
62524: LD_INT 1
62526: ARRAY
62527: PPUSH
62528: LD_VAR 0 9
62532: PUSH
62533: LD_INT 2
62535: ARRAY
62536: PPUSH
62537: CALL_OW 546
62541: ST_TO_ADDR
// if hex [ 1 ] then
62542: LD_VAR 0 4
62546: PUSH
62547: LD_INT 1
62549: ARRAY
62550: IFFALSE 62554
// continue ;
62552: GO 62442
// h := hex [ 2 ] ;
62554: LD_ADDR_VAR 0 13
62558: PUSH
62559: LD_VAR 0 4
62563: PUSH
62564: LD_INT 2
62566: ARRAY
62567: ST_TO_ADDR
// if h + 7 < height then
62568: LD_VAR 0 13
62572: PUSH
62573: LD_INT 7
62575: PLUS
62576: PUSH
62577: LD_VAR 0 15
62581: LESS
62582: IFFALSE 62611
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62584: LD_ADDR_VAR 0 18
62588: PUSH
62589: LD_INT 7
62591: PUSH
62592: LD_INT 28
62594: PUSH
62595: LD_INT 45
62597: PUSH
62598: EMPTY
62599: LIST
62600: LIST
62601: LIST
62602: PUSH
62603: LD_VAR 0 12
62607: ARRAY
62608: ST_TO_ADDR
// break ;
62609: GO 62613
// end ; end ; end ;
62611: GO 62442
62613: POP
62614: POP
// end ; if not weapon then
62615: LD_VAR 0 18
62619: NOT
62620: IFFALSE 62680
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62622: LD_ADDR_VAR 0 5
62626: PUSH
62627: LD_VAR 0 5
62631: PUSH
62632: LD_INT 11
62634: PUSH
62635: LD_INT 30
62637: PUSH
62638: LD_INT 49
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: LIST
62645: DIFF
62646: ST_TO_ADDR
// if not list then
62647: LD_VAR 0 5
62651: NOT
62652: IFFALSE 62656
// exit ;
62654: GO 62798
// weapon := list [ rand ( 1 , list ) ] ;
62656: LD_ADDR_VAR 0 18
62660: PUSH
62661: LD_VAR 0 5
62665: PUSH
62666: LD_INT 1
62668: PPUSH
62669: LD_VAR 0 5
62673: PPUSH
62674: CALL_OW 12
62678: ARRAY
62679: ST_TO_ADDR
// end ; if weapon then
62680: LD_VAR 0 18
62684: IFFALSE 62798
// begin tmp := CostOfWeapon ( weapon ) ;
62686: LD_ADDR_VAR 0 14
62690: PUSH
62691: LD_VAR 0 18
62695: PPUSH
62696: CALL_OW 451
62700: ST_TO_ADDR
// j := GetBase ( tower ) ;
62701: LD_ADDR_VAR 0 9
62705: PUSH
62706: LD_VAR 0 1
62710: PPUSH
62711: CALL_OW 274
62715: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
62716: LD_VAR 0 9
62720: PPUSH
62721: LD_INT 1
62723: PPUSH
62724: CALL_OW 275
62728: PUSH
62729: LD_VAR 0 14
62733: PUSH
62734: LD_INT 1
62736: ARRAY
62737: GREATEREQUAL
62738: PUSH
62739: LD_VAR 0 9
62743: PPUSH
62744: LD_INT 2
62746: PPUSH
62747: CALL_OW 275
62751: PUSH
62752: LD_VAR 0 14
62756: PUSH
62757: LD_INT 2
62759: ARRAY
62760: GREATEREQUAL
62761: AND
62762: PUSH
62763: LD_VAR 0 9
62767: PPUSH
62768: LD_INT 3
62770: PPUSH
62771: CALL_OW 275
62775: PUSH
62776: LD_VAR 0 14
62780: PUSH
62781: LD_INT 3
62783: ARRAY
62784: GREATEREQUAL
62785: AND
62786: IFFALSE 62798
// result := weapon ;
62788: LD_ADDR_VAR 0 3
62792: PUSH
62793: LD_VAR 0 18
62797: ST_TO_ADDR
// end ; end ;
62798: LD_VAR 0 3
62802: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62803: LD_INT 0
62805: PPUSH
62806: PPUSH
// result := true ;
62807: LD_ADDR_VAR 0 3
62811: PUSH
62812: LD_INT 1
62814: ST_TO_ADDR
// if array1 = array2 then
62815: LD_VAR 0 1
62819: PUSH
62820: LD_VAR 0 2
62824: EQUAL
62825: IFFALSE 62885
// begin for i = 1 to array1 do
62827: LD_ADDR_VAR 0 4
62831: PUSH
62832: DOUBLE
62833: LD_INT 1
62835: DEC
62836: ST_TO_ADDR
62837: LD_VAR 0 1
62841: PUSH
62842: FOR_TO
62843: IFFALSE 62881
// if array1 [ i ] <> array2 [ i ] then
62845: LD_VAR 0 1
62849: PUSH
62850: LD_VAR 0 4
62854: ARRAY
62855: PUSH
62856: LD_VAR 0 2
62860: PUSH
62861: LD_VAR 0 4
62865: ARRAY
62866: NONEQUAL
62867: IFFALSE 62879
// begin result := false ;
62869: LD_ADDR_VAR 0 3
62873: PUSH
62874: LD_INT 0
62876: ST_TO_ADDR
// break ;
62877: GO 62881
// end ;
62879: GO 62842
62881: POP
62882: POP
// end else
62883: GO 62893
// result := false ;
62885: LD_ADDR_VAR 0 3
62889: PUSH
62890: LD_INT 0
62892: ST_TO_ADDR
// end ;
62893: LD_VAR 0 3
62897: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62898: LD_INT 0
62900: PPUSH
62901: PPUSH
62902: PPUSH
// pom := GetBase ( fac ) ;
62903: LD_ADDR_VAR 0 5
62907: PUSH
62908: LD_VAR 0 1
62912: PPUSH
62913: CALL_OW 274
62917: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62918: LD_ADDR_VAR 0 4
62922: PUSH
62923: LD_VAR 0 2
62927: PUSH
62928: LD_INT 1
62930: ARRAY
62931: PPUSH
62932: LD_VAR 0 2
62936: PUSH
62937: LD_INT 2
62939: ARRAY
62940: PPUSH
62941: LD_VAR 0 2
62945: PUSH
62946: LD_INT 3
62948: ARRAY
62949: PPUSH
62950: LD_VAR 0 2
62954: PUSH
62955: LD_INT 4
62957: ARRAY
62958: PPUSH
62959: CALL_OW 449
62963: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62964: LD_ADDR_VAR 0 3
62968: PUSH
62969: LD_VAR 0 5
62973: PPUSH
62974: LD_INT 1
62976: PPUSH
62977: CALL_OW 275
62981: PUSH
62982: LD_VAR 0 4
62986: PUSH
62987: LD_INT 1
62989: ARRAY
62990: GREATEREQUAL
62991: PUSH
62992: LD_VAR 0 5
62996: PPUSH
62997: LD_INT 2
62999: PPUSH
63000: CALL_OW 275
63004: PUSH
63005: LD_VAR 0 4
63009: PUSH
63010: LD_INT 2
63012: ARRAY
63013: GREATEREQUAL
63014: AND
63015: PUSH
63016: LD_VAR 0 5
63020: PPUSH
63021: LD_INT 3
63023: PPUSH
63024: CALL_OW 275
63028: PUSH
63029: LD_VAR 0 4
63033: PUSH
63034: LD_INT 3
63036: ARRAY
63037: GREATEREQUAL
63038: AND
63039: ST_TO_ADDR
// end ;
63040: LD_VAR 0 3
63044: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63045: LD_INT 0
63047: PPUSH
63048: PPUSH
63049: PPUSH
63050: PPUSH
// pom := GetBase ( building ) ;
63051: LD_ADDR_VAR 0 3
63055: PUSH
63056: LD_VAR 0 1
63060: PPUSH
63061: CALL_OW 274
63065: ST_TO_ADDR
// if not pom then
63066: LD_VAR 0 3
63070: NOT
63071: IFFALSE 63075
// exit ;
63073: GO 63245
// btype := GetBType ( building ) ;
63075: LD_ADDR_VAR 0 5
63079: PUSH
63080: LD_VAR 0 1
63084: PPUSH
63085: CALL_OW 266
63089: ST_TO_ADDR
// if btype = b_armoury then
63090: LD_VAR 0 5
63094: PUSH
63095: LD_INT 4
63097: EQUAL
63098: IFFALSE 63108
// btype := b_barracks ;
63100: LD_ADDR_VAR 0 5
63104: PUSH
63105: LD_INT 5
63107: ST_TO_ADDR
// if btype = b_depot then
63108: LD_VAR 0 5
63112: PUSH
63113: LD_INT 0
63115: EQUAL
63116: IFFALSE 63126
// btype := b_warehouse ;
63118: LD_ADDR_VAR 0 5
63122: PUSH
63123: LD_INT 1
63125: ST_TO_ADDR
// if btype = b_workshop then
63126: LD_VAR 0 5
63130: PUSH
63131: LD_INT 2
63133: EQUAL
63134: IFFALSE 63144
// btype := b_factory ;
63136: LD_ADDR_VAR 0 5
63140: PUSH
63141: LD_INT 3
63143: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63144: LD_ADDR_VAR 0 4
63148: PUSH
63149: LD_VAR 0 5
63153: PPUSH
63154: LD_VAR 0 1
63158: PPUSH
63159: CALL_OW 248
63163: PPUSH
63164: CALL_OW 450
63168: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63169: LD_ADDR_VAR 0 2
63173: PUSH
63174: LD_VAR 0 3
63178: PPUSH
63179: LD_INT 1
63181: PPUSH
63182: CALL_OW 275
63186: PUSH
63187: LD_VAR 0 4
63191: PUSH
63192: LD_INT 1
63194: ARRAY
63195: GREATEREQUAL
63196: PUSH
63197: LD_VAR 0 3
63201: PPUSH
63202: LD_INT 2
63204: PPUSH
63205: CALL_OW 275
63209: PUSH
63210: LD_VAR 0 4
63214: PUSH
63215: LD_INT 2
63217: ARRAY
63218: GREATEREQUAL
63219: AND
63220: PUSH
63221: LD_VAR 0 3
63225: PPUSH
63226: LD_INT 3
63228: PPUSH
63229: CALL_OW 275
63233: PUSH
63234: LD_VAR 0 4
63238: PUSH
63239: LD_INT 3
63241: ARRAY
63242: GREATEREQUAL
63243: AND
63244: ST_TO_ADDR
// end ;
63245: LD_VAR 0 2
63249: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63250: LD_INT 0
63252: PPUSH
63253: PPUSH
63254: PPUSH
// pom := GetBase ( building ) ;
63255: LD_ADDR_VAR 0 4
63259: PUSH
63260: LD_VAR 0 1
63264: PPUSH
63265: CALL_OW 274
63269: ST_TO_ADDR
// if not pom then
63270: LD_VAR 0 4
63274: NOT
63275: IFFALSE 63279
// exit ;
63277: GO 63380
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63279: LD_ADDR_VAR 0 5
63283: PUSH
63284: LD_VAR 0 2
63288: PPUSH
63289: LD_VAR 0 1
63293: PPUSH
63294: CALL_OW 248
63298: PPUSH
63299: CALL_OW 450
63303: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63304: LD_ADDR_VAR 0 3
63308: PUSH
63309: LD_VAR 0 4
63313: PPUSH
63314: LD_INT 1
63316: PPUSH
63317: CALL_OW 275
63321: PUSH
63322: LD_VAR 0 5
63326: PUSH
63327: LD_INT 1
63329: ARRAY
63330: GREATEREQUAL
63331: PUSH
63332: LD_VAR 0 4
63336: PPUSH
63337: LD_INT 2
63339: PPUSH
63340: CALL_OW 275
63344: PUSH
63345: LD_VAR 0 5
63349: PUSH
63350: LD_INT 2
63352: ARRAY
63353: GREATEREQUAL
63354: AND
63355: PUSH
63356: LD_VAR 0 4
63360: PPUSH
63361: LD_INT 3
63363: PPUSH
63364: CALL_OW 275
63368: PUSH
63369: LD_VAR 0 5
63373: PUSH
63374: LD_INT 3
63376: ARRAY
63377: GREATEREQUAL
63378: AND
63379: ST_TO_ADDR
// end ;
63380: LD_VAR 0 3
63384: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
63385: LD_INT 0
63387: PPUSH
63388: PPUSH
63389: PPUSH
63390: PPUSH
63391: PPUSH
63392: PPUSH
63393: PPUSH
63394: PPUSH
63395: PPUSH
63396: PPUSH
// result := false ;
63397: LD_ADDR_VAR 0 6
63401: PUSH
63402: LD_INT 0
63404: ST_TO_ADDR
// if not base or not btype or not x or not y then
63405: LD_VAR 0 1
63409: NOT
63410: PUSH
63411: LD_VAR 0 2
63415: NOT
63416: OR
63417: PUSH
63418: LD_VAR 0 3
63422: NOT
63423: OR
63424: PUSH
63425: LD_VAR 0 4
63429: NOT
63430: OR
63431: IFFALSE 63435
// exit ;
63433: GO 64044
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
63435: LD_ADDR_VAR 0 12
63439: PUSH
63440: LD_VAR 0 2
63444: PPUSH
63445: LD_VAR 0 3
63449: PPUSH
63450: LD_VAR 0 4
63454: PPUSH
63455: LD_VAR 0 5
63459: PPUSH
63460: LD_VAR 0 1
63464: PUSH
63465: LD_INT 1
63467: ARRAY
63468: PPUSH
63469: CALL_OW 248
63473: PPUSH
63474: LD_INT 0
63476: PPUSH
63477: CALL 64881 0 6
63481: ST_TO_ADDR
// if not hexes then
63482: LD_VAR 0 12
63486: NOT
63487: IFFALSE 63491
// exit ;
63489: GO 64044
// for i = 1 to hexes do
63491: LD_ADDR_VAR 0 7
63495: PUSH
63496: DOUBLE
63497: LD_INT 1
63499: DEC
63500: ST_TO_ADDR
63501: LD_VAR 0 12
63505: PUSH
63506: FOR_TO
63507: IFFALSE 64042
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63509: LD_ADDR_VAR 0 11
63513: PUSH
63514: LD_VAR 0 12
63518: PUSH
63519: LD_VAR 0 7
63523: ARRAY
63524: PUSH
63525: LD_INT 1
63527: ARRAY
63528: PPUSH
63529: LD_VAR 0 12
63533: PUSH
63534: LD_VAR 0 7
63538: ARRAY
63539: PUSH
63540: LD_INT 2
63542: ARRAY
63543: PPUSH
63544: CALL_OW 428
63548: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63549: LD_VAR 0 12
63553: PUSH
63554: LD_VAR 0 7
63558: ARRAY
63559: PUSH
63560: LD_INT 1
63562: ARRAY
63563: PPUSH
63564: LD_VAR 0 12
63568: PUSH
63569: LD_VAR 0 7
63573: ARRAY
63574: PUSH
63575: LD_INT 2
63577: ARRAY
63578: PPUSH
63579: CALL_OW 351
63583: PUSH
63584: LD_VAR 0 12
63588: PUSH
63589: LD_VAR 0 7
63593: ARRAY
63594: PUSH
63595: LD_INT 1
63597: ARRAY
63598: PPUSH
63599: LD_VAR 0 12
63603: PUSH
63604: LD_VAR 0 7
63608: ARRAY
63609: PUSH
63610: LD_INT 2
63612: ARRAY
63613: PPUSH
63614: CALL_OW 488
63618: NOT
63619: OR
63620: PUSH
63621: LD_VAR 0 11
63625: PPUSH
63626: CALL_OW 247
63630: PUSH
63631: LD_INT 3
63633: EQUAL
63634: OR
63635: IFFALSE 63641
// exit ;
63637: POP
63638: POP
63639: GO 64044
// if not tmp or not tmp in base then
63641: LD_VAR 0 11
63645: NOT
63646: PUSH
63647: LD_VAR 0 11
63651: PUSH
63652: LD_VAR 0 1
63656: IN
63657: NOT
63658: OR
63659: IFFALSE 63663
// continue ;
63661: GO 63506
// result := true ;
63663: LD_ADDR_VAR 0 6
63667: PUSH
63668: LD_INT 1
63670: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63671: LD_ADDR_VAR 0 15
63675: PUSH
63676: LD_VAR 0 1
63680: PPUSH
63681: LD_INT 22
63683: PUSH
63684: LD_VAR 0 11
63688: PPUSH
63689: CALL_OW 255
63693: PUSH
63694: EMPTY
63695: LIST
63696: LIST
63697: PUSH
63698: LD_INT 2
63700: PUSH
63701: LD_INT 30
63703: PUSH
63704: LD_INT 0
63706: PUSH
63707: EMPTY
63708: LIST
63709: LIST
63710: PUSH
63711: LD_INT 30
63713: PUSH
63714: LD_INT 1
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: PUSH
63721: EMPTY
63722: LIST
63723: LIST
63724: LIST
63725: PUSH
63726: EMPTY
63727: LIST
63728: LIST
63729: PPUSH
63730: CALL_OW 72
63734: ST_TO_ADDR
// if dep then
63735: LD_VAR 0 15
63739: IFFALSE 63875
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63741: LD_ADDR_VAR 0 14
63745: PUSH
63746: LD_VAR 0 15
63750: PUSH
63751: LD_INT 1
63753: ARRAY
63754: PPUSH
63755: CALL_OW 250
63759: PPUSH
63760: LD_VAR 0 15
63764: PUSH
63765: LD_INT 1
63767: ARRAY
63768: PPUSH
63769: CALL_OW 254
63773: PPUSH
63774: LD_INT 5
63776: PPUSH
63777: CALL_OW 272
63781: PUSH
63782: LD_VAR 0 15
63786: PUSH
63787: LD_INT 1
63789: ARRAY
63790: PPUSH
63791: CALL_OW 251
63795: PPUSH
63796: LD_VAR 0 15
63800: PUSH
63801: LD_INT 1
63803: ARRAY
63804: PPUSH
63805: CALL_OW 254
63809: PPUSH
63810: LD_INT 5
63812: PPUSH
63813: CALL_OW 273
63817: PUSH
63818: EMPTY
63819: LIST
63820: LIST
63821: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63822: LD_VAR 0 14
63826: PUSH
63827: LD_INT 1
63829: ARRAY
63830: PPUSH
63831: LD_VAR 0 14
63835: PUSH
63836: LD_INT 2
63838: ARRAY
63839: PPUSH
63840: CALL_OW 488
63844: IFFALSE 63875
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63846: LD_VAR 0 11
63850: PPUSH
63851: LD_VAR 0 14
63855: PUSH
63856: LD_INT 1
63858: ARRAY
63859: PPUSH
63860: LD_VAR 0 14
63864: PUSH
63865: LD_INT 2
63867: ARRAY
63868: PPUSH
63869: CALL_OW 111
// continue ;
63873: GO 63506
// end ; end ; r := GetDir ( tmp ) ;
63875: LD_ADDR_VAR 0 13
63879: PUSH
63880: LD_VAR 0 11
63884: PPUSH
63885: CALL_OW 254
63889: ST_TO_ADDR
// if r = 5 then
63890: LD_VAR 0 13
63894: PUSH
63895: LD_INT 5
63897: EQUAL
63898: IFFALSE 63908
// r := 0 ;
63900: LD_ADDR_VAR 0 13
63904: PUSH
63905: LD_INT 0
63907: ST_TO_ADDR
// for j = r to 5 do
63908: LD_ADDR_VAR 0 8
63912: PUSH
63913: DOUBLE
63914: LD_VAR 0 13
63918: DEC
63919: ST_TO_ADDR
63920: LD_INT 5
63922: PUSH
63923: FOR_TO
63924: IFFALSE 64038
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63926: LD_ADDR_VAR 0 9
63930: PUSH
63931: LD_VAR 0 11
63935: PPUSH
63936: CALL_OW 250
63940: PPUSH
63941: LD_VAR 0 8
63945: PPUSH
63946: LD_INT 2
63948: PPUSH
63949: CALL_OW 272
63953: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63954: LD_ADDR_VAR 0 10
63958: PUSH
63959: LD_VAR 0 11
63963: PPUSH
63964: CALL_OW 251
63968: PPUSH
63969: LD_VAR 0 8
63973: PPUSH
63974: LD_INT 2
63976: PPUSH
63977: CALL_OW 273
63981: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63982: LD_VAR 0 9
63986: PPUSH
63987: LD_VAR 0 10
63991: PPUSH
63992: CALL_OW 488
63996: PUSH
63997: LD_VAR 0 9
64001: PPUSH
64002: LD_VAR 0 10
64006: PPUSH
64007: CALL_OW 428
64011: NOT
64012: AND
64013: IFFALSE 64036
// begin ComMoveXY ( tmp , _x , _y ) ;
64015: LD_VAR 0 11
64019: PPUSH
64020: LD_VAR 0 9
64024: PPUSH
64025: LD_VAR 0 10
64029: PPUSH
64030: CALL_OW 111
// break ;
64034: GO 64038
// end ; end ;
64036: GO 63923
64038: POP
64039: POP
// end ;
64040: GO 63506
64042: POP
64043: POP
// end ;
64044: LD_VAR 0 6
64048: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
64049: LD_INT 0
64051: PPUSH
64052: PPUSH
64053: PPUSH
64054: PPUSH
64055: PPUSH
64056: PPUSH
64057: PPUSH
64058: PPUSH
64059: PPUSH
64060: PPUSH
// result := false ;
64061: LD_ADDR_VAR 0 6
64065: PUSH
64066: LD_INT 0
64068: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64069: LD_VAR 0 1
64073: NOT
64074: PUSH
64075: LD_VAR 0 1
64079: PPUSH
64080: CALL_OW 266
64084: PUSH
64085: LD_INT 0
64087: PUSH
64088: LD_INT 1
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: IN
64095: NOT
64096: OR
64097: PUSH
64098: LD_VAR 0 2
64102: NOT
64103: OR
64104: PUSH
64105: LD_VAR 0 5
64109: PUSH
64110: LD_INT 0
64112: PUSH
64113: LD_INT 1
64115: PUSH
64116: LD_INT 2
64118: PUSH
64119: LD_INT 3
64121: PUSH
64122: LD_INT 4
64124: PUSH
64125: LD_INT 5
64127: PUSH
64128: EMPTY
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: IN
64136: NOT
64137: OR
64138: PUSH
64139: LD_VAR 0 3
64143: PPUSH
64144: LD_VAR 0 4
64148: PPUSH
64149: CALL_OW 488
64153: NOT
64154: OR
64155: IFFALSE 64159
// exit ;
64157: GO 64876
// pom := GetBase ( depot ) ;
64159: LD_ADDR_VAR 0 10
64163: PUSH
64164: LD_VAR 0 1
64168: PPUSH
64169: CALL_OW 274
64173: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64174: LD_ADDR_VAR 0 11
64178: PUSH
64179: LD_VAR 0 2
64183: PPUSH
64184: LD_VAR 0 1
64188: PPUSH
64189: CALL_OW 248
64193: PPUSH
64194: CALL_OW 450
64198: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64199: LD_VAR 0 10
64203: PPUSH
64204: LD_INT 1
64206: PPUSH
64207: CALL_OW 275
64211: PUSH
64212: LD_VAR 0 11
64216: PUSH
64217: LD_INT 1
64219: ARRAY
64220: GREATEREQUAL
64221: PUSH
64222: LD_VAR 0 10
64226: PPUSH
64227: LD_INT 2
64229: PPUSH
64230: CALL_OW 275
64234: PUSH
64235: LD_VAR 0 11
64239: PUSH
64240: LD_INT 2
64242: ARRAY
64243: GREATEREQUAL
64244: AND
64245: PUSH
64246: LD_VAR 0 10
64250: PPUSH
64251: LD_INT 3
64253: PPUSH
64254: CALL_OW 275
64258: PUSH
64259: LD_VAR 0 11
64263: PUSH
64264: LD_INT 3
64266: ARRAY
64267: GREATEREQUAL
64268: AND
64269: NOT
64270: IFFALSE 64274
// exit ;
64272: GO 64876
// if GetBType ( depot ) = b_depot then
64274: LD_VAR 0 1
64278: PPUSH
64279: CALL_OW 266
64283: PUSH
64284: LD_INT 0
64286: EQUAL
64287: IFFALSE 64299
// dist := 28 else
64289: LD_ADDR_VAR 0 14
64293: PUSH
64294: LD_INT 28
64296: ST_TO_ADDR
64297: GO 64307
// dist := 36 ;
64299: LD_ADDR_VAR 0 14
64303: PUSH
64304: LD_INT 36
64306: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
64307: LD_VAR 0 1
64311: PPUSH
64312: LD_VAR 0 3
64316: PPUSH
64317: LD_VAR 0 4
64321: PPUSH
64322: CALL_OW 297
64326: PUSH
64327: LD_VAR 0 14
64331: GREATER
64332: IFFALSE 64336
// exit ;
64334: GO 64876
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
64336: LD_ADDR_VAR 0 12
64340: PUSH
64341: LD_VAR 0 2
64345: PPUSH
64346: LD_VAR 0 3
64350: PPUSH
64351: LD_VAR 0 4
64355: PPUSH
64356: LD_VAR 0 5
64360: PPUSH
64361: LD_VAR 0 1
64365: PPUSH
64366: CALL_OW 248
64370: PPUSH
64371: LD_INT 0
64373: PPUSH
64374: CALL 64881 0 6
64378: ST_TO_ADDR
// if not hexes then
64379: LD_VAR 0 12
64383: NOT
64384: IFFALSE 64388
// exit ;
64386: GO 64876
// hex := GetHexInfo ( x , y ) ;
64388: LD_ADDR_VAR 0 15
64392: PUSH
64393: LD_VAR 0 3
64397: PPUSH
64398: LD_VAR 0 4
64402: PPUSH
64403: CALL_OW 546
64407: ST_TO_ADDR
// if hex [ 1 ] then
64408: LD_VAR 0 15
64412: PUSH
64413: LD_INT 1
64415: ARRAY
64416: IFFALSE 64420
// exit ;
64418: GO 64876
// height := hex [ 2 ] ;
64420: LD_ADDR_VAR 0 13
64424: PUSH
64425: LD_VAR 0 15
64429: PUSH
64430: LD_INT 2
64432: ARRAY
64433: ST_TO_ADDR
// for i = 1 to hexes do
64434: LD_ADDR_VAR 0 7
64438: PUSH
64439: DOUBLE
64440: LD_INT 1
64442: DEC
64443: ST_TO_ADDR
64444: LD_VAR 0 12
64448: PUSH
64449: FOR_TO
64450: IFFALSE 64780
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
64452: LD_VAR 0 12
64456: PUSH
64457: LD_VAR 0 7
64461: ARRAY
64462: PUSH
64463: LD_INT 1
64465: ARRAY
64466: PPUSH
64467: LD_VAR 0 12
64471: PUSH
64472: LD_VAR 0 7
64476: ARRAY
64477: PUSH
64478: LD_INT 2
64480: ARRAY
64481: PPUSH
64482: CALL_OW 488
64486: NOT
64487: PUSH
64488: LD_VAR 0 12
64492: PUSH
64493: LD_VAR 0 7
64497: ARRAY
64498: PUSH
64499: LD_INT 1
64501: ARRAY
64502: PPUSH
64503: LD_VAR 0 12
64507: PUSH
64508: LD_VAR 0 7
64512: ARRAY
64513: PUSH
64514: LD_INT 2
64516: ARRAY
64517: PPUSH
64518: CALL_OW 428
64522: PUSH
64523: LD_INT 0
64525: GREATER
64526: OR
64527: PUSH
64528: LD_VAR 0 12
64532: PUSH
64533: LD_VAR 0 7
64537: ARRAY
64538: PUSH
64539: LD_INT 1
64541: ARRAY
64542: PPUSH
64543: LD_VAR 0 12
64547: PUSH
64548: LD_VAR 0 7
64552: ARRAY
64553: PUSH
64554: LD_INT 2
64556: ARRAY
64557: PPUSH
64558: CALL_OW 351
64562: OR
64563: IFFALSE 64569
// exit ;
64565: POP
64566: POP
64567: GO 64876
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64569: LD_ADDR_VAR 0 8
64573: PUSH
64574: LD_VAR 0 12
64578: PUSH
64579: LD_VAR 0 7
64583: ARRAY
64584: PUSH
64585: LD_INT 1
64587: ARRAY
64588: PPUSH
64589: LD_VAR 0 12
64593: PUSH
64594: LD_VAR 0 7
64598: ARRAY
64599: PUSH
64600: LD_INT 2
64602: ARRAY
64603: PPUSH
64604: CALL_OW 546
64608: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64609: LD_VAR 0 8
64613: PUSH
64614: LD_INT 1
64616: ARRAY
64617: PUSH
64618: LD_VAR 0 8
64622: PUSH
64623: LD_INT 2
64625: ARRAY
64626: PUSH
64627: LD_VAR 0 13
64631: PUSH
64632: LD_INT 2
64634: PLUS
64635: GREATER
64636: OR
64637: PUSH
64638: LD_VAR 0 8
64642: PUSH
64643: LD_INT 2
64645: ARRAY
64646: PUSH
64647: LD_VAR 0 13
64651: PUSH
64652: LD_INT 2
64654: MINUS
64655: LESS
64656: OR
64657: PUSH
64658: LD_VAR 0 8
64662: PUSH
64663: LD_INT 3
64665: ARRAY
64666: PUSH
64667: LD_INT 0
64669: PUSH
64670: LD_INT 8
64672: PUSH
64673: LD_INT 9
64675: PUSH
64676: LD_INT 10
64678: PUSH
64679: LD_INT 11
64681: PUSH
64682: LD_INT 12
64684: PUSH
64685: LD_INT 13
64687: PUSH
64688: LD_INT 16
64690: PUSH
64691: LD_INT 17
64693: PUSH
64694: LD_INT 18
64696: PUSH
64697: LD_INT 19
64699: PUSH
64700: LD_INT 20
64702: PUSH
64703: LD_INT 21
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: LIST
64719: LIST
64720: IN
64721: NOT
64722: OR
64723: PUSH
64724: LD_VAR 0 8
64728: PUSH
64729: LD_INT 5
64731: ARRAY
64732: NOT
64733: OR
64734: PUSH
64735: LD_VAR 0 8
64739: PUSH
64740: LD_INT 6
64742: ARRAY
64743: PUSH
64744: LD_INT 1
64746: PUSH
64747: LD_INT 2
64749: PUSH
64750: LD_INT 7
64752: PUSH
64753: LD_INT 9
64755: PUSH
64756: LD_INT 10
64758: PUSH
64759: LD_INT 11
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: LIST
64768: LIST
64769: IN
64770: NOT
64771: OR
64772: IFFALSE 64778
// exit ;
64774: POP
64775: POP
64776: GO 64876
// end ;
64778: GO 64449
64780: POP
64781: POP
// side := GetSide ( depot ) ;
64782: LD_ADDR_VAR 0 9
64786: PUSH
64787: LD_VAR 0 1
64791: PPUSH
64792: CALL_OW 255
64796: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
64797: LD_VAR 0 9
64801: PPUSH
64802: LD_VAR 0 3
64806: PPUSH
64807: LD_VAR 0 4
64811: PPUSH
64812: LD_INT 20
64814: PPUSH
64815: CALL 57530 0 4
64819: PUSH
64820: LD_INT 4
64822: ARRAY
64823: IFFALSE 64827
// exit ;
64825: GO 64876
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
64827: LD_VAR 0 2
64831: PUSH
64832: LD_INT 29
64834: PUSH
64835: LD_INT 30
64837: PUSH
64838: EMPTY
64839: LIST
64840: LIST
64841: IN
64842: PUSH
64843: LD_VAR 0 3
64847: PPUSH
64848: LD_VAR 0 4
64852: PPUSH
64853: LD_VAR 0 9
64857: PPUSH
64858: CALL_OW 440
64862: NOT
64863: AND
64864: IFFALSE 64868
// exit ;
64866: GO 64876
// result := true ;
64868: LD_ADDR_VAR 0 6
64872: PUSH
64873: LD_INT 1
64875: ST_TO_ADDR
// end ;
64876: LD_VAR 0 6
64880: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
64881: LD_INT 0
64883: PPUSH
64884: PPUSH
64885: PPUSH
64886: PPUSH
64887: PPUSH
64888: PPUSH
64889: PPUSH
64890: PPUSH
64891: PPUSH
64892: PPUSH
64893: PPUSH
64894: PPUSH
64895: PPUSH
64896: PPUSH
64897: PPUSH
64898: PPUSH
64899: PPUSH
64900: PPUSH
64901: PPUSH
64902: PPUSH
64903: PPUSH
64904: PPUSH
64905: PPUSH
64906: PPUSH
64907: PPUSH
64908: PPUSH
64909: PPUSH
64910: PPUSH
64911: PPUSH
64912: PPUSH
64913: PPUSH
64914: PPUSH
64915: PPUSH
64916: PPUSH
64917: PPUSH
64918: PPUSH
64919: PPUSH
64920: PPUSH
64921: PPUSH
64922: PPUSH
64923: PPUSH
64924: PPUSH
64925: PPUSH
64926: PPUSH
64927: PPUSH
64928: PPUSH
64929: PPUSH
64930: PPUSH
64931: PPUSH
64932: PPUSH
64933: PPUSH
64934: PPUSH
64935: PPUSH
64936: PPUSH
64937: PPUSH
64938: PPUSH
64939: PPUSH
64940: PPUSH
// result = [ ] ;
64941: LD_ADDR_VAR 0 7
64945: PUSH
64946: EMPTY
64947: ST_TO_ADDR
// temp_list = [ ] ;
64948: LD_ADDR_VAR 0 9
64952: PUSH
64953: EMPTY
64954: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
64955: LD_VAR 0 4
64959: PUSH
64960: LD_INT 0
64962: PUSH
64963: LD_INT 1
64965: PUSH
64966: LD_INT 2
64968: PUSH
64969: LD_INT 3
64971: PUSH
64972: LD_INT 4
64974: PUSH
64975: LD_INT 5
64977: PUSH
64978: EMPTY
64979: LIST
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: LIST
64985: IN
64986: NOT
64987: PUSH
64988: LD_VAR 0 1
64992: PUSH
64993: LD_INT 0
64995: PUSH
64996: LD_INT 1
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: IN
65003: PUSH
65004: LD_VAR 0 5
65008: PUSH
65009: LD_INT 1
65011: PUSH
65012: LD_INT 2
65014: PUSH
65015: LD_INT 3
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: LIST
65022: IN
65023: NOT
65024: AND
65025: OR
65026: IFFALSE 65030
// exit ;
65028: GO 83421
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65030: LD_VAR 0 1
65034: PUSH
65035: LD_INT 6
65037: PUSH
65038: LD_INT 7
65040: PUSH
65041: LD_INT 8
65043: PUSH
65044: LD_INT 13
65046: PUSH
65047: LD_INT 12
65049: PUSH
65050: LD_INT 15
65052: PUSH
65053: LD_INT 11
65055: PUSH
65056: LD_INT 14
65058: PUSH
65059: LD_INT 10
65061: PUSH
65062: EMPTY
65063: LIST
65064: LIST
65065: LIST
65066: LIST
65067: LIST
65068: LIST
65069: LIST
65070: LIST
65071: LIST
65072: IN
65073: IFFALSE 65083
// btype = b_lab ;
65075: LD_ADDR_VAR 0 1
65079: PUSH
65080: LD_INT 6
65082: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65083: LD_VAR 0 6
65087: PUSH
65088: LD_INT 0
65090: PUSH
65091: LD_INT 1
65093: PUSH
65094: LD_INT 2
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: LIST
65101: IN
65102: NOT
65103: PUSH
65104: LD_VAR 0 1
65108: PUSH
65109: LD_INT 0
65111: PUSH
65112: LD_INT 1
65114: PUSH
65115: LD_INT 2
65117: PUSH
65118: LD_INT 3
65120: PUSH
65121: LD_INT 6
65123: PUSH
65124: LD_INT 36
65126: PUSH
65127: LD_INT 4
65129: PUSH
65130: LD_INT 5
65132: PUSH
65133: LD_INT 31
65135: PUSH
65136: LD_INT 32
65138: PUSH
65139: LD_INT 33
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: IN
65155: NOT
65156: PUSH
65157: LD_VAR 0 6
65161: PUSH
65162: LD_INT 1
65164: EQUAL
65165: AND
65166: OR
65167: PUSH
65168: LD_VAR 0 1
65172: PUSH
65173: LD_INT 2
65175: PUSH
65176: LD_INT 3
65178: PUSH
65179: EMPTY
65180: LIST
65181: LIST
65182: IN
65183: NOT
65184: PUSH
65185: LD_VAR 0 6
65189: PUSH
65190: LD_INT 2
65192: EQUAL
65193: AND
65194: OR
65195: IFFALSE 65205
// mode = 0 ;
65197: LD_ADDR_VAR 0 6
65201: PUSH
65202: LD_INT 0
65204: ST_TO_ADDR
// case mode of 0 :
65205: LD_VAR 0 6
65209: PUSH
65210: LD_INT 0
65212: DOUBLE
65213: EQUAL
65214: IFTRUE 65218
65216: GO 76671
65218: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65219: LD_ADDR_VAR 0 11
65223: PUSH
65224: LD_INT 0
65226: PUSH
65227: LD_INT 0
65229: PUSH
65230: EMPTY
65231: LIST
65232: LIST
65233: PUSH
65234: LD_INT 0
65236: PUSH
65237: LD_INT 1
65239: NEG
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 1
65247: PUSH
65248: LD_INT 0
65250: PUSH
65251: EMPTY
65252: LIST
65253: LIST
65254: PUSH
65255: LD_INT 1
65257: PUSH
65258: LD_INT 1
65260: PUSH
65261: EMPTY
65262: LIST
65263: LIST
65264: PUSH
65265: LD_INT 0
65267: PUSH
65268: LD_INT 1
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 1
65277: NEG
65278: PUSH
65279: LD_INT 0
65281: PUSH
65282: EMPTY
65283: LIST
65284: LIST
65285: PUSH
65286: LD_INT 1
65288: NEG
65289: PUSH
65290: LD_INT 1
65292: NEG
65293: PUSH
65294: EMPTY
65295: LIST
65296: LIST
65297: PUSH
65298: LD_INT 1
65300: NEG
65301: PUSH
65302: LD_INT 2
65304: NEG
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: LD_INT 0
65312: PUSH
65313: LD_INT 2
65315: NEG
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 1
65323: PUSH
65324: LD_INT 1
65326: NEG
65327: PUSH
65328: EMPTY
65329: LIST
65330: LIST
65331: PUSH
65332: LD_INT 1
65334: PUSH
65335: LD_INT 2
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: LD_INT 0
65344: PUSH
65345: LD_INT 2
65347: PUSH
65348: EMPTY
65349: LIST
65350: LIST
65351: PUSH
65352: LD_INT 1
65354: NEG
65355: PUSH
65356: LD_INT 1
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: PUSH
65363: LD_INT 1
65365: PUSH
65366: LD_INT 3
65368: PUSH
65369: EMPTY
65370: LIST
65371: LIST
65372: PUSH
65373: LD_INT 0
65375: PUSH
65376: LD_INT 3
65378: PUSH
65379: EMPTY
65380: LIST
65381: LIST
65382: PUSH
65383: LD_INT 1
65385: NEG
65386: PUSH
65387: LD_INT 2
65389: PUSH
65390: EMPTY
65391: LIST
65392: LIST
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: LIST
65409: LIST
65410: LIST
65411: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65412: LD_ADDR_VAR 0 12
65416: PUSH
65417: LD_INT 0
65419: PUSH
65420: LD_INT 0
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 0
65429: PUSH
65430: LD_INT 1
65432: NEG
65433: PUSH
65434: EMPTY
65435: LIST
65436: LIST
65437: PUSH
65438: LD_INT 1
65440: PUSH
65441: LD_INT 0
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 1
65450: PUSH
65451: LD_INT 1
65453: PUSH
65454: EMPTY
65455: LIST
65456: LIST
65457: PUSH
65458: LD_INT 0
65460: PUSH
65461: LD_INT 1
65463: PUSH
65464: EMPTY
65465: LIST
65466: LIST
65467: PUSH
65468: LD_INT 1
65470: NEG
65471: PUSH
65472: LD_INT 0
65474: PUSH
65475: EMPTY
65476: LIST
65477: LIST
65478: PUSH
65479: LD_INT 1
65481: NEG
65482: PUSH
65483: LD_INT 1
65485: NEG
65486: PUSH
65487: EMPTY
65488: LIST
65489: LIST
65490: PUSH
65491: LD_INT 1
65493: PUSH
65494: LD_INT 1
65496: NEG
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: PUSH
65502: LD_INT 2
65504: PUSH
65505: LD_INT 0
65507: PUSH
65508: EMPTY
65509: LIST
65510: LIST
65511: PUSH
65512: LD_INT 2
65514: PUSH
65515: LD_INT 1
65517: PUSH
65518: EMPTY
65519: LIST
65520: LIST
65521: PUSH
65522: LD_INT 1
65524: NEG
65525: PUSH
65526: LD_INT 1
65528: PUSH
65529: EMPTY
65530: LIST
65531: LIST
65532: PUSH
65533: LD_INT 2
65535: NEG
65536: PUSH
65537: LD_INT 0
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: PUSH
65544: LD_INT 2
65546: NEG
65547: PUSH
65548: LD_INT 1
65550: NEG
65551: PUSH
65552: EMPTY
65553: LIST
65554: LIST
65555: PUSH
65556: LD_INT 2
65558: NEG
65559: PUSH
65560: LD_INT 1
65562: PUSH
65563: EMPTY
65564: LIST
65565: LIST
65566: PUSH
65567: LD_INT 3
65569: NEG
65570: PUSH
65571: LD_INT 0
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PUSH
65578: LD_INT 3
65580: NEG
65581: PUSH
65582: LD_INT 1
65584: NEG
65585: PUSH
65586: EMPTY
65587: LIST
65588: LIST
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: LIST
65606: LIST
65607: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65608: LD_ADDR_VAR 0 13
65612: PUSH
65613: LD_INT 0
65615: PUSH
65616: LD_INT 0
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: PUSH
65623: LD_INT 0
65625: PUSH
65626: LD_INT 1
65628: NEG
65629: PUSH
65630: EMPTY
65631: LIST
65632: LIST
65633: PUSH
65634: LD_INT 1
65636: PUSH
65637: LD_INT 0
65639: PUSH
65640: EMPTY
65641: LIST
65642: LIST
65643: PUSH
65644: LD_INT 1
65646: PUSH
65647: LD_INT 1
65649: PUSH
65650: EMPTY
65651: LIST
65652: LIST
65653: PUSH
65654: LD_INT 0
65656: PUSH
65657: LD_INT 1
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: PUSH
65664: LD_INT 1
65666: NEG
65667: PUSH
65668: LD_INT 0
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: PUSH
65675: LD_INT 1
65677: NEG
65678: PUSH
65679: LD_INT 1
65681: NEG
65682: PUSH
65683: EMPTY
65684: LIST
65685: LIST
65686: PUSH
65687: LD_INT 1
65689: NEG
65690: PUSH
65691: LD_INT 2
65693: NEG
65694: PUSH
65695: EMPTY
65696: LIST
65697: LIST
65698: PUSH
65699: LD_INT 2
65701: PUSH
65702: LD_INT 1
65704: PUSH
65705: EMPTY
65706: LIST
65707: LIST
65708: PUSH
65709: LD_INT 2
65711: PUSH
65712: LD_INT 2
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: LD_INT 1
65721: PUSH
65722: LD_INT 2
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PUSH
65729: LD_INT 2
65731: NEG
65732: PUSH
65733: LD_INT 1
65735: NEG
65736: PUSH
65737: EMPTY
65738: LIST
65739: LIST
65740: PUSH
65741: LD_INT 2
65743: NEG
65744: PUSH
65745: LD_INT 2
65747: NEG
65748: PUSH
65749: EMPTY
65750: LIST
65751: LIST
65752: PUSH
65753: LD_INT 2
65755: NEG
65756: PUSH
65757: LD_INT 3
65759: NEG
65760: PUSH
65761: EMPTY
65762: LIST
65763: LIST
65764: PUSH
65765: LD_INT 3
65767: NEG
65768: PUSH
65769: LD_INT 2
65771: NEG
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: LD_INT 3
65779: NEG
65780: PUSH
65781: LD_INT 3
65783: NEG
65784: PUSH
65785: EMPTY
65786: LIST
65787: LIST
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: LIST
65793: LIST
65794: LIST
65795: LIST
65796: LIST
65797: LIST
65798: LIST
65799: LIST
65800: LIST
65801: LIST
65802: LIST
65803: LIST
65804: LIST
65805: LIST
65806: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
65807: LD_ADDR_VAR 0 14
65811: PUSH
65812: LD_INT 0
65814: PUSH
65815: LD_INT 0
65817: PUSH
65818: EMPTY
65819: LIST
65820: LIST
65821: PUSH
65822: LD_INT 0
65824: PUSH
65825: LD_INT 1
65827: NEG
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 1
65835: PUSH
65836: LD_INT 0
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: LD_INT 1
65845: PUSH
65846: LD_INT 1
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: LD_INT 0
65855: PUSH
65856: LD_INT 1
65858: PUSH
65859: EMPTY
65860: LIST
65861: LIST
65862: PUSH
65863: LD_INT 1
65865: NEG
65866: PUSH
65867: LD_INT 0
65869: PUSH
65870: EMPTY
65871: LIST
65872: LIST
65873: PUSH
65874: LD_INT 1
65876: NEG
65877: PUSH
65878: LD_INT 1
65880: NEG
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: PUSH
65886: LD_INT 1
65888: NEG
65889: PUSH
65890: LD_INT 2
65892: NEG
65893: PUSH
65894: EMPTY
65895: LIST
65896: LIST
65897: PUSH
65898: LD_INT 0
65900: PUSH
65901: LD_INT 2
65903: NEG
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: PUSH
65909: LD_INT 1
65911: PUSH
65912: LD_INT 1
65914: NEG
65915: PUSH
65916: EMPTY
65917: LIST
65918: LIST
65919: PUSH
65920: LD_INT 1
65922: PUSH
65923: LD_INT 2
65925: PUSH
65926: EMPTY
65927: LIST
65928: LIST
65929: PUSH
65930: LD_INT 0
65932: PUSH
65933: LD_INT 2
65935: PUSH
65936: EMPTY
65937: LIST
65938: LIST
65939: PUSH
65940: LD_INT 1
65942: NEG
65943: PUSH
65944: LD_INT 1
65946: PUSH
65947: EMPTY
65948: LIST
65949: LIST
65950: PUSH
65951: LD_INT 1
65953: NEG
65954: PUSH
65955: LD_INT 3
65957: NEG
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: PUSH
65963: LD_INT 0
65965: PUSH
65966: LD_INT 3
65968: NEG
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 1
65976: PUSH
65977: LD_INT 2
65979: NEG
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: EMPTY
65986: LIST
65987: LIST
65988: LIST
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66003: LD_ADDR_VAR 0 15
66007: PUSH
66008: LD_INT 0
66010: PUSH
66011: LD_INT 0
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 0
66020: PUSH
66021: LD_INT 1
66023: NEG
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: PUSH
66029: LD_INT 1
66031: PUSH
66032: LD_INT 0
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 1
66041: PUSH
66042: LD_INT 1
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: LD_INT 0
66051: PUSH
66052: LD_INT 1
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PUSH
66059: LD_INT 1
66061: NEG
66062: PUSH
66063: LD_INT 0
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: PUSH
66070: LD_INT 1
66072: NEG
66073: PUSH
66074: LD_INT 1
66076: NEG
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 1
66084: PUSH
66085: LD_INT 1
66087: NEG
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: LD_INT 2
66095: PUSH
66096: LD_INT 0
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 2
66105: PUSH
66106: LD_INT 1
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: PUSH
66113: LD_INT 1
66115: NEG
66116: PUSH
66117: LD_INT 1
66119: PUSH
66120: EMPTY
66121: LIST
66122: LIST
66123: PUSH
66124: LD_INT 2
66126: NEG
66127: PUSH
66128: LD_INT 0
66130: PUSH
66131: EMPTY
66132: LIST
66133: LIST
66134: PUSH
66135: LD_INT 2
66137: NEG
66138: PUSH
66139: LD_INT 1
66141: NEG
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PUSH
66147: LD_INT 2
66149: PUSH
66150: LD_INT 1
66152: NEG
66153: PUSH
66154: EMPTY
66155: LIST
66156: LIST
66157: PUSH
66158: LD_INT 3
66160: PUSH
66161: LD_INT 0
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PUSH
66168: LD_INT 3
66170: PUSH
66171: LD_INT 1
66173: PUSH
66174: EMPTY
66175: LIST
66176: LIST
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66196: LD_ADDR_VAR 0 16
66200: PUSH
66201: LD_INT 0
66203: PUSH
66204: LD_INT 0
66206: PUSH
66207: EMPTY
66208: LIST
66209: LIST
66210: PUSH
66211: LD_INT 0
66213: PUSH
66214: LD_INT 1
66216: NEG
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: PUSH
66222: LD_INT 1
66224: PUSH
66225: LD_INT 0
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: PUSH
66232: LD_INT 1
66234: PUSH
66235: LD_INT 1
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: PUSH
66242: LD_INT 0
66244: PUSH
66245: LD_INT 1
66247: PUSH
66248: EMPTY
66249: LIST
66250: LIST
66251: PUSH
66252: LD_INT 1
66254: NEG
66255: PUSH
66256: LD_INT 0
66258: PUSH
66259: EMPTY
66260: LIST
66261: LIST
66262: PUSH
66263: LD_INT 1
66265: NEG
66266: PUSH
66267: LD_INT 1
66269: NEG
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PUSH
66275: LD_INT 1
66277: NEG
66278: PUSH
66279: LD_INT 2
66281: NEG
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PUSH
66287: LD_INT 2
66289: PUSH
66290: LD_INT 1
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: PUSH
66297: LD_INT 2
66299: PUSH
66300: LD_INT 2
66302: PUSH
66303: EMPTY
66304: LIST
66305: LIST
66306: PUSH
66307: LD_INT 1
66309: PUSH
66310: LD_INT 2
66312: PUSH
66313: EMPTY
66314: LIST
66315: LIST
66316: PUSH
66317: LD_INT 2
66319: NEG
66320: PUSH
66321: LD_INT 1
66323: NEG
66324: PUSH
66325: EMPTY
66326: LIST
66327: LIST
66328: PUSH
66329: LD_INT 2
66331: NEG
66332: PUSH
66333: LD_INT 2
66335: NEG
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PUSH
66341: LD_INT 3
66343: PUSH
66344: LD_INT 2
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: LD_INT 3
66353: PUSH
66354: LD_INT 3
66356: PUSH
66357: EMPTY
66358: LIST
66359: LIST
66360: PUSH
66361: LD_INT 2
66363: PUSH
66364: LD_INT 3
66366: PUSH
66367: EMPTY
66368: LIST
66369: LIST
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66389: LD_ADDR_VAR 0 17
66393: PUSH
66394: LD_INT 0
66396: PUSH
66397: LD_INT 0
66399: PUSH
66400: EMPTY
66401: LIST
66402: LIST
66403: PUSH
66404: LD_INT 0
66406: PUSH
66407: LD_INT 1
66409: NEG
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: PUSH
66415: LD_INT 1
66417: PUSH
66418: LD_INT 0
66420: PUSH
66421: EMPTY
66422: LIST
66423: LIST
66424: PUSH
66425: LD_INT 1
66427: PUSH
66428: LD_INT 1
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: PUSH
66435: LD_INT 0
66437: PUSH
66438: LD_INT 1
66440: PUSH
66441: EMPTY
66442: LIST
66443: LIST
66444: PUSH
66445: LD_INT 1
66447: NEG
66448: PUSH
66449: LD_INT 0
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 1
66458: NEG
66459: PUSH
66460: LD_INT 1
66462: NEG
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: LD_INT 1
66470: NEG
66471: PUSH
66472: LD_INT 2
66474: NEG
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: PUSH
66480: LD_INT 0
66482: PUSH
66483: LD_INT 2
66485: NEG
66486: PUSH
66487: EMPTY
66488: LIST
66489: LIST
66490: PUSH
66491: LD_INT 1
66493: PUSH
66494: LD_INT 1
66496: NEG
66497: PUSH
66498: EMPTY
66499: LIST
66500: LIST
66501: PUSH
66502: LD_INT 2
66504: PUSH
66505: LD_INT 0
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: LD_INT 2
66514: PUSH
66515: LD_INT 1
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 2
66524: PUSH
66525: LD_INT 2
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 1
66534: PUSH
66535: LD_INT 2
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: LD_INT 0
66544: PUSH
66545: LD_INT 2
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 1
66554: NEG
66555: PUSH
66556: LD_INT 1
66558: PUSH
66559: EMPTY
66560: LIST
66561: LIST
66562: PUSH
66563: LD_INT 2
66565: NEG
66566: PUSH
66567: LD_INT 0
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PUSH
66574: LD_INT 2
66576: NEG
66577: PUSH
66578: LD_INT 1
66580: NEG
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: PUSH
66586: LD_INT 2
66588: NEG
66589: PUSH
66590: LD_INT 2
66592: NEG
66593: PUSH
66594: EMPTY
66595: LIST
66596: LIST
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66619: LD_ADDR_VAR 0 18
66623: PUSH
66624: LD_INT 0
66626: PUSH
66627: LD_INT 0
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: PUSH
66634: LD_INT 0
66636: PUSH
66637: LD_INT 1
66639: NEG
66640: PUSH
66641: EMPTY
66642: LIST
66643: LIST
66644: PUSH
66645: LD_INT 1
66647: PUSH
66648: LD_INT 0
66650: PUSH
66651: EMPTY
66652: LIST
66653: LIST
66654: PUSH
66655: LD_INT 1
66657: PUSH
66658: LD_INT 1
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 0
66667: PUSH
66668: LD_INT 1
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 1
66677: NEG
66678: PUSH
66679: LD_INT 0
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: PUSH
66686: LD_INT 1
66688: NEG
66689: PUSH
66690: LD_INT 1
66692: NEG
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: PUSH
66698: LD_INT 1
66700: NEG
66701: PUSH
66702: LD_INT 2
66704: NEG
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: LD_INT 0
66712: PUSH
66713: LD_INT 2
66715: NEG
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: LD_INT 1
66723: PUSH
66724: LD_INT 1
66726: NEG
66727: PUSH
66728: EMPTY
66729: LIST
66730: LIST
66731: PUSH
66732: LD_INT 2
66734: PUSH
66735: LD_INT 0
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: PUSH
66742: LD_INT 2
66744: PUSH
66745: LD_INT 1
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: PUSH
66752: LD_INT 2
66754: PUSH
66755: LD_INT 2
66757: PUSH
66758: EMPTY
66759: LIST
66760: LIST
66761: PUSH
66762: LD_INT 1
66764: PUSH
66765: LD_INT 2
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: LD_INT 0
66774: PUSH
66775: LD_INT 2
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: LD_INT 1
66784: NEG
66785: PUSH
66786: LD_INT 1
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: LD_INT 2
66795: NEG
66796: PUSH
66797: LD_INT 0
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PUSH
66804: LD_INT 2
66806: NEG
66807: PUSH
66808: LD_INT 1
66810: NEG
66811: PUSH
66812: EMPTY
66813: LIST
66814: LIST
66815: PUSH
66816: LD_INT 2
66818: NEG
66819: PUSH
66820: LD_INT 2
66822: NEG
66823: PUSH
66824: EMPTY
66825: LIST
66826: LIST
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: LIST
66832: LIST
66833: LIST
66834: LIST
66835: LIST
66836: LIST
66837: LIST
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66849: LD_ADDR_VAR 0 19
66853: PUSH
66854: LD_INT 0
66856: PUSH
66857: LD_INT 0
66859: PUSH
66860: EMPTY
66861: LIST
66862: LIST
66863: PUSH
66864: LD_INT 0
66866: PUSH
66867: LD_INT 1
66869: NEG
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 1
66877: PUSH
66878: LD_INT 0
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 1
66887: PUSH
66888: LD_INT 1
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 0
66897: PUSH
66898: LD_INT 1
66900: PUSH
66901: EMPTY
66902: LIST
66903: LIST
66904: PUSH
66905: LD_INT 1
66907: NEG
66908: PUSH
66909: LD_INT 0
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 1
66918: NEG
66919: PUSH
66920: LD_INT 1
66922: NEG
66923: PUSH
66924: EMPTY
66925: LIST
66926: LIST
66927: PUSH
66928: LD_INT 1
66930: NEG
66931: PUSH
66932: LD_INT 2
66934: NEG
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: PUSH
66940: LD_INT 0
66942: PUSH
66943: LD_INT 2
66945: NEG
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: PUSH
66951: LD_INT 1
66953: PUSH
66954: LD_INT 1
66956: NEG
66957: PUSH
66958: EMPTY
66959: LIST
66960: LIST
66961: PUSH
66962: LD_INT 2
66964: PUSH
66965: LD_INT 0
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 2
66974: PUSH
66975: LD_INT 1
66977: PUSH
66978: EMPTY
66979: LIST
66980: LIST
66981: PUSH
66982: LD_INT 2
66984: PUSH
66985: LD_INT 2
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 1
66994: PUSH
66995: LD_INT 2
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 0
67004: PUSH
67005: LD_INT 2
67007: PUSH
67008: EMPTY
67009: LIST
67010: LIST
67011: PUSH
67012: LD_INT 1
67014: NEG
67015: PUSH
67016: LD_INT 1
67018: PUSH
67019: EMPTY
67020: LIST
67021: LIST
67022: PUSH
67023: LD_INT 2
67025: NEG
67026: PUSH
67027: LD_INT 0
67029: PUSH
67030: EMPTY
67031: LIST
67032: LIST
67033: PUSH
67034: LD_INT 2
67036: NEG
67037: PUSH
67038: LD_INT 1
67040: NEG
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: PUSH
67046: LD_INT 2
67048: NEG
67049: PUSH
67050: LD_INT 2
67052: NEG
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: EMPTY
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: LIST
67074: LIST
67075: LIST
67076: LIST
67077: LIST
67078: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67079: LD_ADDR_VAR 0 20
67083: PUSH
67084: LD_INT 0
67086: PUSH
67087: LD_INT 0
67089: PUSH
67090: EMPTY
67091: LIST
67092: LIST
67093: PUSH
67094: LD_INT 0
67096: PUSH
67097: LD_INT 1
67099: NEG
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: PUSH
67105: LD_INT 1
67107: PUSH
67108: LD_INT 0
67110: PUSH
67111: EMPTY
67112: LIST
67113: LIST
67114: PUSH
67115: LD_INT 1
67117: PUSH
67118: LD_INT 1
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 0
67127: PUSH
67128: LD_INT 1
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 1
67137: NEG
67138: PUSH
67139: LD_INT 0
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: LD_INT 1
67148: NEG
67149: PUSH
67150: LD_INT 1
67152: NEG
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: LD_INT 1
67160: NEG
67161: PUSH
67162: LD_INT 2
67164: NEG
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: LD_INT 0
67172: PUSH
67173: LD_INT 2
67175: NEG
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: PUSH
67181: LD_INT 1
67183: PUSH
67184: LD_INT 1
67186: NEG
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: PUSH
67192: LD_INT 2
67194: PUSH
67195: LD_INT 0
67197: PUSH
67198: EMPTY
67199: LIST
67200: LIST
67201: PUSH
67202: LD_INT 2
67204: PUSH
67205: LD_INT 1
67207: PUSH
67208: EMPTY
67209: LIST
67210: LIST
67211: PUSH
67212: LD_INT 2
67214: PUSH
67215: LD_INT 2
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: PUSH
67222: LD_INT 1
67224: PUSH
67225: LD_INT 2
67227: PUSH
67228: EMPTY
67229: LIST
67230: LIST
67231: PUSH
67232: LD_INT 0
67234: PUSH
67235: LD_INT 2
67237: PUSH
67238: EMPTY
67239: LIST
67240: LIST
67241: PUSH
67242: LD_INT 1
67244: NEG
67245: PUSH
67246: LD_INT 1
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: PUSH
67253: LD_INT 2
67255: NEG
67256: PUSH
67257: LD_INT 0
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: LD_INT 2
67266: NEG
67267: PUSH
67268: LD_INT 1
67270: NEG
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: PUSH
67276: LD_INT 2
67278: NEG
67279: PUSH
67280: LD_INT 2
67282: NEG
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: LIST
67306: LIST
67307: LIST
67308: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67309: LD_ADDR_VAR 0 21
67313: PUSH
67314: LD_INT 0
67316: PUSH
67317: LD_INT 0
67319: PUSH
67320: EMPTY
67321: LIST
67322: LIST
67323: PUSH
67324: LD_INT 0
67326: PUSH
67327: LD_INT 1
67329: NEG
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: PUSH
67335: LD_INT 1
67337: PUSH
67338: LD_INT 0
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 1
67347: PUSH
67348: LD_INT 1
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 0
67357: PUSH
67358: LD_INT 1
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: LD_INT 1
67367: NEG
67368: PUSH
67369: LD_INT 0
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: LD_INT 1
67378: NEG
67379: PUSH
67380: LD_INT 1
67382: NEG
67383: PUSH
67384: EMPTY
67385: LIST
67386: LIST
67387: PUSH
67388: LD_INT 1
67390: NEG
67391: PUSH
67392: LD_INT 2
67394: NEG
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 0
67402: PUSH
67403: LD_INT 2
67405: NEG
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 1
67413: PUSH
67414: LD_INT 1
67416: NEG
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 2
67424: PUSH
67425: LD_INT 0
67427: PUSH
67428: EMPTY
67429: LIST
67430: LIST
67431: PUSH
67432: LD_INT 2
67434: PUSH
67435: LD_INT 1
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 2
67444: PUSH
67445: LD_INT 2
67447: PUSH
67448: EMPTY
67449: LIST
67450: LIST
67451: PUSH
67452: LD_INT 1
67454: PUSH
67455: LD_INT 2
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PUSH
67462: LD_INT 0
67464: PUSH
67465: LD_INT 2
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: PUSH
67472: LD_INT 1
67474: NEG
67475: PUSH
67476: LD_INT 1
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: LD_INT 2
67485: NEG
67486: PUSH
67487: LD_INT 0
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 2
67496: NEG
67497: PUSH
67498: LD_INT 1
67500: NEG
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: PUSH
67506: LD_INT 2
67508: NEG
67509: PUSH
67510: LD_INT 2
67512: NEG
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: LIST
67528: LIST
67529: LIST
67530: LIST
67531: LIST
67532: LIST
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: LIST
67538: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67539: LD_ADDR_VAR 0 22
67543: PUSH
67544: LD_INT 0
67546: PUSH
67547: LD_INT 0
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 0
67556: PUSH
67557: LD_INT 1
67559: NEG
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 1
67567: PUSH
67568: LD_INT 0
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 1
67577: PUSH
67578: LD_INT 1
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 0
67587: PUSH
67588: LD_INT 1
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 1
67597: NEG
67598: PUSH
67599: LD_INT 0
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: LD_INT 1
67608: NEG
67609: PUSH
67610: LD_INT 1
67612: NEG
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 1
67620: NEG
67621: PUSH
67622: LD_INT 2
67624: NEG
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 0
67632: PUSH
67633: LD_INT 2
67635: NEG
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 1
67643: PUSH
67644: LD_INT 1
67646: NEG
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 2
67654: PUSH
67655: LD_INT 0
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 2
67664: PUSH
67665: LD_INT 1
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 2
67674: PUSH
67675: LD_INT 2
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 1
67684: PUSH
67685: LD_INT 2
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 0
67694: PUSH
67695: LD_INT 2
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 1
67704: NEG
67705: PUSH
67706: LD_INT 1
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: PUSH
67713: LD_INT 2
67715: NEG
67716: PUSH
67717: LD_INT 0
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: LD_INT 2
67726: NEG
67727: PUSH
67728: LD_INT 1
67730: NEG
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: PUSH
67736: LD_INT 2
67738: NEG
67739: PUSH
67740: LD_INT 2
67742: NEG
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: EMPTY
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
67769: LD_ADDR_VAR 0 23
67773: PUSH
67774: LD_INT 0
67776: PUSH
67777: LD_INT 0
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 0
67786: PUSH
67787: LD_INT 1
67789: NEG
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: PUSH
67795: LD_INT 1
67797: PUSH
67798: LD_INT 0
67800: PUSH
67801: EMPTY
67802: LIST
67803: LIST
67804: PUSH
67805: LD_INT 1
67807: PUSH
67808: LD_INT 1
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PUSH
67815: LD_INT 0
67817: PUSH
67818: LD_INT 1
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 1
67827: NEG
67828: PUSH
67829: LD_INT 0
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: LD_INT 1
67838: NEG
67839: PUSH
67840: LD_INT 1
67842: NEG
67843: PUSH
67844: EMPTY
67845: LIST
67846: LIST
67847: PUSH
67848: LD_INT 1
67850: NEG
67851: PUSH
67852: LD_INT 2
67854: NEG
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: LD_INT 0
67862: PUSH
67863: LD_INT 2
67865: NEG
67866: PUSH
67867: EMPTY
67868: LIST
67869: LIST
67870: PUSH
67871: LD_INT 1
67873: PUSH
67874: LD_INT 1
67876: NEG
67877: PUSH
67878: EMPTY
67879: LIST
67880: LIST
67881: PUSH
67882: LD_INT 2
67884: PUSH
67885: LD_INT 0
67887: PUSH
67888: EMPTY
67889: LIST
67890: LIST
67891: PUSH
67892: LD_INT 2
67894: PUSH
67895: LD_INT 1
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PUSH
67902: LD_INT 2
67904: PUSH
67905: LD_INT 2
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: PUSH
67912: LD_INT 1
67914: PUSH
67915: LD_INT 2
67917: PUSH
67918: EMPTY
67919: LIST
67920: LIST
67921: PUSH
67922: LD_INT 0
67924: PUSH
67925: LD_INT 2
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: PUSH
67932: LD_INT 1
67934: NEG
67935: PUSH
67936: LD_INT 1
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PUSH
67943: LD_INT 2
67945: NEG
67946: PUSH
67947: LD_INT 0
67949: PUSH
67950: EMPTY
67951: LIST
67952: LIST
67953: PUSH
67954: LD_INT 2
67956: NEG
67957: PUSH
67958: LD_INT 1
67960: NEG
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 2
67968: NEG
67969: PUSH
67970: LD_INT 2
67972: NEG
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: LD_INT 2
67980: NEG
67981: PUSH
67982: LD_INT 3
67984: NEG
67985: PUSH
67986: EMPTY
67987: LIST
67988: LIST
67989: PUSH
67990: LD_INT 1
67992: NEG
67993: PUSH
67994: LD_INT 3
67996: NEG
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: PUSH
68002: LD_INT 1
68004: PUSH
68005: LD_INT 2
68007: NEG
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 2
68015: PUSH
68016: LD_INT 1
68018: NEG
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: LIST
68028: LIST
68029: LIST
68030: LIST
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68049: LD_ADDR_VAR 0 24
68053: PUSH
68054: LD_INT 0
68056: PUSH
68057: LD_INT 0
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 0
68066: PUSH
68067: LD_INT 1
68069: NEG
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: LD_INT 1
68077: PUSH
68078: LD_INT 0
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 1
68087: PUSH
68088: LD_INT 1
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: LD_INT 0
68097: PUSH
68098: LD_INT 1
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: LD_INT 1
68107: NEG
68108: PUSH
68109: LD_INT 0
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: PUSH
68116: LD_INT 1
68118: NEG
68119: PUSH
68120: LD_INT 1
68122: NEG
68123: PUSH
68124: EMPTY
68125: LIST
68126: LIST
68127: PUSH
68128: LD_INT 1
68130: NEG
68131: PUSH
68132: LD_INT 2
68134: NEG
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: LD_INT 0
68142: PUSH
68143: LD_INT 2
68145: NEG
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: LD_INT 1
68153: PUSH
68154: LD_INT 1
68156: NEG
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: LD_INT 2
68164: PUSH
68165: LD_INT 0
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: LD_INT 2
68174: PUSH
68175: LD_INT 1
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: PUSH
68182: LD_INT 2
68184: PUSH
68185: LD_INT 2
68187: PUSH
68188: EMPTY
68189: LIST
68190: LIST
68191: PUSH
68192: LD_INT 1
68194: PUSH
68195: LD_INT 2
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: PUSH
68202: LD_INT 0
68204: PUSH
68205: LD_INT 2
68207: PUSH
68208: EMPTY
68209: LIST
68210: LIST
68211: PUSH
68212: LD_INT 1
68214: NEG
68215: PUSH
68216: LD_INT 1
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: LD_INT 2
68225: NEG
68226: PUSH
68227: LD_INT 0
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 2
68236: NEG
68237: PUSH
68238: LD_INT 1
68240: NEG
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: PUSH
68246: LD_INT 2
68248: NEG
68249: PUSH
68250: LD_INT 2
68252: NEG
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: LD_INT 1
68260: PUSH
68261: LD_INT 2
68263: NEG
68264: PUSH
68265: EMPTY
68266: LIST
68267: LIST
68268: PUSH
68269: LD_INT 2
68271: PUSH
68272: LD_INT 1
68274: NEG
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 3
68282: PUSH
68283: LD_INT 1
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 3
68292: PUSH
68293: LD_INT 2
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
68325: LD_ADDR_VAR 0 25
68329: PUSH
68330: LD_INT 0
68332: PUSH
68333: LD_INT 0
68335: PUSH
68336: EMPTY
68337: LIST
68338: LIST
68339: PUSH
68340: LD_INT 0
68342: PUSH
68343: LD_INT 1
68345: NEG
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: PUSH
68351: LD_INT 1
68353: PUSH
68354: LD_INT 0
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 1
68363: PUSH
68364: LD_INT 1
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 0
68373: PUSH
68374: LD_INT 1
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 1
68383: NEG
68384: PUSH
68385: LD_INT 0
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PUSH
68392: LD_INT 1
68394: NEG
68395: PUSH
68396: LD_INT 1
68398: NEG
68399: PUSH
68400: EMPTY
68401: LIST
68402: LIST
68403: PUSH
68404: LD_INT 1
68406: NEG
68407: PUSH
68408: LD_INT 2
68410: NEG
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PUSH
68416: LD_INT 0
68418: PUSH
68419: LD_INT 2
68421: NEG
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: PUSH
68427: LD_INT 1
68429: PUSH
68430: LD_INT 1
68432: NEG
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 2
68440: PUSH
68441: LD_INT 0
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 2
68450: PUSH
68451: LD_INT 1
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PUSH
68458: LD_INT 2
68460: PUSH
68461: LD_INT 2
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: PUSH
68468: LD_INT 1
68470: PUSH
68471: LD_INT 2
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: PUSH
68478: LD_INT 0
68480: PUSH
68481: LD_INT 2
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: PUSH
68488: LD_INT 1
68490: NEG
68491: PUSH
68492: LD_INT 1
68494: PUSH
68495: EMPTY
68496: LIST
68497: LIST
68498: PUSH
68499: LD_INT 2
68501: NEG
68502: PUSH
68503: LD_INT 0
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: LD_INT 2
68512: NEG
68513: PUSH
68514: LD_INT 1
68516: NEG
68517: PUSH
68518: EMPTY
68519: LIST
68520: LIST
68521: PUSH
68522: LD_INT 2
68524: NEG
68525: PUSH
68526: LD_INT 2
68528: NEG
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: PUSH
68534: LD_INT 3
68536: PUSH
68537: LD_INT 1
68539: PUSH
68540: EMPTY
68541: LIST
68542: LIST
68543: PUSH
68544: LD_INT 3
68546: PUSH
68547: LD_INT 2
68549: PUSH
68550: EMPTY
68551: LIST
68552: LIST
68553: PUSH
68554: LD_INT 2
68556: PUSH
68557: LD_INT 3
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 1
68566: PUSH
68567: LD_INT 3
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: EMPTY
68575: LIST
68576: LIST
68577: LIST
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: LIST
68589: LIST
68590: LIST
68591: LIST
68592: LIST
68593: LIST
68594: LIST
68595: LIST
68596: LIST
68597: LIST
68598: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68599: LD_ADDR_VAR 0 26
68603: PUSH
68604: LD_INT 0
68606: PUSH
68607: LD_INT 0
68609: PUSH
68610: EMPTY
68611: LIST
68612: LIST
68613: PUSH
68614: LD_INT 0
68616: PUSH
68617: LD_INT 1
68619: NEG
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: PUSH
68625: LD_INT 1
68627: PUSH
68628: LD_INT 0
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 1
68637: PUSH
68638: LD_INT 1
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 0
68647: PUSH
68648: LD_INT 1
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 1
68657: NEG
68658: PUSH
68659: LD_INT 0
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 1
68668: NEG
68669: PUSH
68670: LD_INT 1
68672: NEG
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 1
68680: NEG
68681: PUSH
68682: LD_INT 2
68684: NEG
68685: PUSH
68686: EMPTY
68687: LIST
68688: LIST
68689: PUSH
68690: LD_INT 0
68692: PUSH
68693: LD_INT 2
68695: NEG
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 1
68703: PUSH
68704: LD_INT 1
68706: NEG
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 2
68714: PUSH
68715: LD_INT 0
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 2
68724: PUSH
68725: LD_INT 1
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: PUSH
68732: LD_INT 2
68734: PUSH
68735: LD_INT 2
68737: PUSH
68738: EMPTY
68739: LIST
68740: LIST
68741: PUSH
68742: LD_INT 1
68744: PUSH
68745: LD_INT 2
68747: PUSH
68748: EMPTY
68749: LIST
68750: LIST
68751: PUSH
68752: LD_INT 0
68754: PUSH
68755: LD_INT 2
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 1
68764: NEG
68765: PUSH
68766: LD_INT 1
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 2
68775: NEG
68776: PUSH
68777: LD_INT 0
68779: PUSH
68780: EMPTY
68781: LIST
68782: LIST
68783: PUSH
68784: LD_INT 2
68786: NEG
68787: PUSH
68788: LD_INT 1
68790: NEG
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: LD_INT 2
68798: NEG
68799: PUSH
68800: LD_INT 2
68802: NEG
68803: PUSH
68804: EMPTY
68805: LIST
68806: LIST
68807: PUSH
68808: LD_INT 2
68810: PUSH
68811: LD_INT 3
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: PUSH
68818: LD_INT 1
68820: PUSH
68821: LD_INT 3
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 1
68830: NEG
68831: PUSH
68832: LD_INT 2
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: LD_INT 2
68841: NEG
68842: PUSH
68843: LD_INT 1
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68875: LD_ADDR_VAR 0 27
68879: PUSH
68880: LD_INT 0
68882: PUSH
68883: LD_INT 0
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PUSH
68890: LD_INT 0
68892: PUSH
68893: LD_INT 1
68895: NEG
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 1
68903: PUSH
68904: LD_INT 0
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 1
68913: PUSH
68914: LD_INT 1
68916: PUSH
68917: EMPTY
68918: LIST
68919: LIST
68920: PUSH
68921: LD_INT 0
68923: PUSH
68924: LD_INT 1
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: PUSH
68931: LD_INT 1
68933: NEG
68934: PUSH
68935: LD_INT 0
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: PUSH
68942: LD_INT 1
68944: NEG
68945: PUSH
68946: LD_INT 1
68948: NEG
68949: PUSH
68950: EMPTY
68951: LIST
68952: LIST
68953: PUSH
68954: LD_INT 1
68956: NEG
68957: PUSH
68958: LD_INT 2
68960: NEG
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: PUSH
68966: LD_INT 0
68968: PUSH
68969: LD_INT 2
68971: NEG
68972: PUSH
68973: EMPTY
68974: LIST
68975: LIST
68976: PUSH
68977: LD_INT 1
68979: PUSH
68980: LD_INT 1
68982: NEG
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: PUSH
68988: LD_INT 2
68990: PUSH
68991: LD_INT 0
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 2
69000: PUSH
69001: LD_INT 1
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: LD_INT 2
69010: PUSH
69011: LD_INT 2
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: LD_INT 1
69020: PUSH
69021: LD_INT 2
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: LD_INT 0
69030: PUSH
69031: LD_INT 2
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 1
69040: NEG
69041: PUSH
69042: LD_INT 1
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 2
69051: NEG
69052: PUSH
69053: LD_INT 0
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: LD_INT 2
69062: NEG
69063: PUSH
69064: LD_INT 1
69066: NEG
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 2
69074: NEG
69075: PUSH
69076: LD_INT 2
69078: NEG
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 1
69086: NEG
69087: PUSH
69088: LD_INT 2
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PUSH
69095: LD_INT 2
69097: NEG
69098: PUSH
69099: LD_INT 1
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PUSH
69106: LD_INT 3
69108: NEG
69109: PUSH
69110: LD_INT 1
69112: NEG
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 3
69120: NEG
69121: PUSH
69122: LD_INT 2
69124: NEG
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: EMPTY
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: LIST
69147: LIST
69148: LIST
69149: LIST
69150: LIST
69151: LIST
69152: LIST
69153: LIST
69154: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69155: LD_ADDR_VAR 0 28
69159: PUSH
69160: LD_INT 0
69162: PUSH
69163: LD_INT 0
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: PUSH
69170: LD_INT 0
69172: PUSH
69173: LD_INT 1
69175: NEG
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 1
69183: PUSH
69184: LD_INT 0
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: LD_INT 1
69193: PUSH
69194: LD_INT 1
69196: PUSH
69197: EMPTY
69198: LIST
69199: LIST
69200: PUSH
69201: LD_INT 0
69203: PUSH
69204: LD_INT 1
69206: PUSH
69207: EMPTY
69208: LIST
69209: LIST
69210: PUSH
69211: LD_INT 1
69213: NEG
69214: PUSH
69215: LD_INT 0
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: PUSH
69222: LD_INT 1
69224: NEG
69225: PUSH
69226: LD_INT 1
69228: NEG
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: PUSH
69234: LD_INT 1
69236: NEG
69237: PUSH
69238: LD_INT 2
69240: NEG
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PUSH
69246: LD_INT 0
69248: PUSH
69249: LD_INT 2
69251: NEG
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 1
69259: PUSH
69260: LD_INT 1
69262: NEG
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: PUSH
69268: LD_INT 2
69270: PUSH
69271: LD_INT 0
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: PUSH
69278: LD_INT 2
69280: PUSH
69281: LD_INT 1
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 2
69290: PUSH
69291: LD_INT 2
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PUSH
69298: LD_INT 1
69300: PUSH
69301: LD_INT 2
69303: PUSH
69304: EMPTY
69305: LIST
69306: LIST
69307: PUSH
69308: LD_INT 0
69310: PUSH
69311: LD_INT 2
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: LD_INT 1
69320: NEG
69321: PUSH
69322: LD_INT 1
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: PUSH
69329: LD_INT 2
69331: NEG
69332: PUSH
69333: LD_INT 0
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 2
69342: NEG
69343: PUSH
69344: LD_INT 1
69346: NEG
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: PUSH
69352: LD_INT 2
69354: NEG
69355: PUSH
69356: LD_INT 2
69358: NEG
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: PUSH
69364: LD_INT 2
69366: NEG
69367: PUSH
69368: LD_INT 3
69370: NEG
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 1
69378: NEG
69379: PUSH
69380: LD_INT 3
69382: NEG
69383: PUSH
69384: EMPTY
69385: LIST
69386: LIST
69387: PUSH
69388: LD_INT 3
69390: NEG
69391: PUSH
69392: LD_INT 1
69394: NEG
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: PUSH
69400: LD_INT 3
69402: NEG
69403: PUSH
69404: LD_INT 2
69406: NEG
69407: PUSH
69408: EMPTY
69409: LIST
69410: LIST
69411: PUSH
69412: EMPTY
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: LIST
69434: LIST
69435: LIST
69436: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69437: LD_ADDR_VAR 0 29
69441: PUSH
69442: LD_INT 0
69444: PUSH
69445: LD_INT 0
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 0
69454: PUSH
69455: LD_INT 1
69457: NEG
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 1
69465: PUSH
69466: LD_INT 0
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PUSH
69473: LD_INT 1
69475: PUSH
69476: LD_INT 1
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: PUSH
69483: LD_INT 0
69485: PUSH
69486: LD_INT 1
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 1
69495: NEG
69496: PUSH
69497: LD_INT 0
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 1
69506: NEG
69507: PUSH
69508: LD_INT 1
69510: NEG
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: LD_INT 1
69518: NEG
69519: PUSH
69520: LD_INT 2
69522: NEG
69523: PUSH
69524: EMPTY
69525: LIST
69526: LIST
69527: PUSH
69528: LD_INT 0
69530: PUSH
69531: LD_INT 2
69533: NEG
69534: PUSH
69535: EMPTY
69536: LIST
69537: LIST
69538: PUSH
69539: LD_INT 1
69541: PUSH
69542: LD_INT 1
69544: NEG
69545: PUSH
69546: EMPTY
69547: LIST
69548: LIST
69549: PUSH
69550: LD_INT 2
69552: PUSH
69553: LD_INT 0
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 2
69562: PUSH
69563: LD_INT 1
69565: PUSH
69566: EMPTY
69567: LIST
69568: LIST
69569: PUSH
69570: LD_INT 1
69572: PUSH
69573: LD_INT 2
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 0
69582: PUSH
69583: LD_INT 2
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 1
69592: NEG
69593: PUSH
69594: LD_INT 1
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 2
69603: NEG
69604: PUSH
69605: LD_INT 1
69607: NEG
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 2
69615: NEG
69616: PUSH
69617: LD_INT 2
69619: NEG
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 2
69627: NEG
69628: PUSH
69629: LD_INT 3
69631: NEG
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 2
69639: PUSH
69640: LD_INT 1
69642: NEG
69643: PUSH
69644: EMPTY
69645: LIST
69646: LIST
69647: PUSH
69648: LD_INT 3
69650: PUSH
69651: LD_INT 1
69653: PUSH
69654: EMPTY
69655: LIST
69656: LIST
69657: PUSH
69658: LD_INT 1
69660: PUSH
69661: LD_INT 3
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: PUSH
69668: LD_INT 1
69670: NEG
69671: PUSH
69672: LD_INT 2
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: PUSH
69679: LD_INT 3
69681: NEG
69682: PUSH
69683: LD_INT 2
69685: NEG
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69716: LD_ADDR_VAR 0 30
69720: PUSH
69721: LD_INT 0
69723: PUSH
69724: LD_INT 0
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 0
69733: PUSH
69734: LD_INT 1
69736: NEG
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: PUSH
69742: LD_INT 1
69744: PUSH
69745: LD_INT 0
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 1
69754: PUSH
69755: LD_INT 1
69757: PUSH
69758: EMPTY
69759: LIST
69760: LIST
69761: PUSH
69762: LD_INT 0
69764: PUSH
69765: LD_INT 1
69767: PUSH
69768: EMPTY
69769: LIST
69770: LIST
69771: PUSH
69772: LD_INT 1
69774: NEG
69775: PUSH
69776: LD_INT 0
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: PUSH
69783: LD_INT 1
69785: NEG
69786: PUSH
69787: LD_INT 1
69789: NEG
69790: PUSH
69791: EMPTY
69792: LIST
69793: LIST
69794: PUSH
69795: LD_INT 1
69797: NEG
69798: PUSH
69799: LD_INT 2
69801: NEG
69802: PUSH
69803: EMPTY
69804: LIST
69805: LIST
69806: PUSH
69807: LD_INT 0
69809: PUSH
69810: LD_INT 2
69812: NEG
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: PUSH
69818: LD_INT 1
69820: PUSH
69821: LD_INT 1
69823: NEG
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: PUSH
69829: LD_INT 2
69831: PUSH
69832: LD_INT 0
69834: PUSH
69835: EMPTY
69836: LIST
69837: LIST
69838: PUSH
69839: LD_INT 2
69841: PUSH
69842: LD_INT 1
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: LD_INT 2
69851: PUSH
69852: LD_INT 2
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 1
69861: PUSH
69862: LD_INT 2
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 1
69871: NEG
69872: PUSH
69873: LD_INT 1
69875: PUSH
69876: EMPTY
69877: LIST
69878: LIST
69879: PUSH
69880: LD_INT 2
69882: NEG
69883: PUSH
69884: LD_INT 0
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 2
69893: NEG
69894: PUSH
69895: LD_INT 1
69897: NEG
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: PUSH
69903: LD_INT 1
69905: NEG
69906: PUSH
69907: LD_INT 3
69909: NEG
69910: PUSH
69911: EMPTY
69912: LIST
69913: LIST
69914: PUSH
69915: LD_INT 1
69917: PUSH
69918: LD_INT 2
69920: NEG
69921: PUSH
69922: EMPTY
69923: LIST
69924: LIST
69925: PUSH
69926: LD_INT 3
69928: PUSH
69929: LD_INT 2
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: PUSH
69936: LD_INT 2
69938: PUSH
69939: LD_INT 3
69941: PUSH
69942: EMPTY
69943: LIST
69944: LIST
69945: PUSH
69946: LD_INT 2
69948: NEG
69949: PUSH
69950: LD_INT 1
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: LD_INT 3
69959: NEG
69960: PUSH
69961: LD_INT 1
69963: NEG
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: LIST
69993: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69994: LD_ADDR_VAR 0 31
69998: PUSH
69999: LD_INT 0
70001: PUSH
70002: LD_INT 0
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: LD_INT 0
70011: PUSH
70012: LD_INT 1
70014: NEG
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 1
70022: PUSH
70023: LD_INT 0
70025: PUSH
70026: EMPTY
70027: LIST
70028: LIST
70029: PUSH
70030: LD_INT 1
70032: PUSH
70033: LD_INT 1
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 0
70042: PUSH
70043: LD_INT 1
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: LD_INT 1
70052: NEG
70053: PUSH
70054: LD_INT 0
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: LD_INT 1
70063: NEG
70064: PUSH
70065: LD_INT 1
70067: NEG
70068: PUSH
70069: EMPTY
70070: LIST
70071: LIST
70072: PUSH
70073: LD_INT 1
70075: NEG
70076: PUSH
70077: LD_INT 2
70079: NEG
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PUSH
70085: LD_INT 1
70087: PUSH
70088: LD_INT 1
70090: NEG
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: PUSH
70096: LD_INT 2
70098: PUSH
70099: LD_INT 0
70101: PUSH
70102: EMPTY
70103: LIST
70104: LIST
70105: PUSH
70106: LD_INT 2
70108: PUSH
70109: LD_INT 1
70111: PUSH
70112: EMPTY
70113: LIST
70114: LIST
70115: PUSH
70116: LD_INT 2
70118: PUSH
70119: LD_INT 2
70121: PUSH
70122: EMPTY
70123: LIST
70124: LIST
70125: PUSH
70126: LD_INT 1
70128: PUSH
70129: LD_INT 2
70131: PUSH
70132: EMPTY
70133: LIST
70134: LIST
70135: PUSH
70136: LD_INT 0
70138: PUSH
70139: LD_INT 2
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: PUSH
70146: LD_INT 1
70148: NEG
70149: PUSH
70150: LD_INT 1
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 2
70159: NEG
70160: PUSH
70161: LD_INT 1
70163: NEG
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: LD_INT 2
70171: NEG
70172: PUSH
70173: LD_INT 2
70175: NEG
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 2
70183: NEG
70184: PUSH
70185: LD_INT 3
70187: NEG
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 2
70195: PUSH
70196: LD_INT 1
70198: NEG
70199: PUSH
70200: EMPTY
70201: LIST
70202: LIST
70203: PUSH
70204: LD_INT 3
70206: PUSH
70207: LD_INT 1
70209: PUSH
70210: EMPTY
70211: LIST
70212: LIST
70213: PUSH
70214: LD_INT 1
70216: PUSH
70217: LD_INT 3
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: PUSH
70224: LD_INT 1
70226: NEG
70227: PUSH
70228: LD_INT 2
70230: PUSH
70231: EMPTY
70232: LIST
70233: LIST
70234: PUSH
70235: LD_INT 3
70237: NEG
70238: PUSH
70239: LD_INT 2
70241: NEG
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: LIST
70264: LIST
70265: LIST
70266: LIST
70267: LIST
70268: LIST
70269: LIST
70270: LIST
70271: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70272: LD_ADDR_VAR 0 32
70276: PUSH
70277: LD_INT 0
70279: PUSH
70280: LD_INT 0
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 0
70289: PUSH
70290: LD_INT 1
70292: NEG
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: PUSH
70298: LD_INT 1
70300: PUSH
70301: LD_INT 0
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PUSH
70308: LD_INT 1
70310: PUSH
70311: LD_INT 1
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: LD_INT 1
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 1
70330: NEG
70331: PUSH
70332: LD_INT 0
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 1
70341: NEG
70342: PUSH
70343: LD_INT 1
70345: NEG
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: PUSH
70351: LD_INT 1
70353: NEG
70354: PUSH
70355: LD_INT 2
70357: NEG
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PUSH
70363: LD_INT 0
70365: PUSH
70366: LD_INT 2
70368: NEG
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 1
70376: PUSH
70377: LD_INT 1
70379: NEG
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: PUSH
70385: LD_INT 2
70387: PUSH
70388: LD_INT 1
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: PUSH
70395: LD_INT 2
70397: PUSH
70398: LD_INT 2
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 1
70407: PUSH
70408: LD_INT 2
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 0
70417: PUSH
70418: LD_INT 2
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 1
70427: NEG
70428: PUSH
70429: LD_INT 1
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 2
70438: NEG
70439: PUSH
70440: LD_INT 0
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 2
70449: NEG
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 1
70461: NEG
70462: PUSH
70463: LD_INT 3
70465: NEG
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: PUSH
70471: LD_INT 1
70473: PUSH
70474: LD_INT 2
70476: NEG
70477: PUSH
70478: EMPTY
70479: LIST
70480: LIST
70481: PUSH
70482: LD_INT 3
70484: PUSH
70485: LD_INT 2
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PUSH
70492: LD_INT 2
70494: PUSH
70495: LD_INT 3
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: PUSH
70502: LD_INT 2
70504: NEG
70505: PUSH
70506: LD_INT 1
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 3
70515: NEG
70516: PUSH
70517: LD_INT 1
70519: NEG
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: LIST
70529: LIST
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: LIST
70543: LIST
70544: LIST
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70550: LD_ADDR_VAR 0 33
70554: PUSH
70555: LD_INT 0
70557: PUSH
70558: LD_INT 0
70560: PUSH
70561: EMPTY
70562: LIST
70563: LIST
70564: PUSH
70565: LD_INT 0
70567: PUSH
70568: LD_INT 1
70570: NEG
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 1
70578: PUSH
70579: LD_INT 0
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PUSH
70586: LD_INT 1
70588: PUSH
70589: LD_INT 1
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 0
70598: PUSH
70599: LD_INT 1
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 1
70608: NEG
70609: PUSH
70610: LD_INT 0
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: PUSH
70617: LD_INT 1
70619: NEG
70620: PUSH
70621: LD_INT 1
70623: NEG
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 1
70631: NEG
70632: PUSH
70633: LD_INT 2
70635: NEG
70636: PUSH
70637: EMPTY
70638: LIST
70639: LIST
70640: PUSH
70641: LD_INT 1
70643: PUSH
70644: LD_INT 1
70646: NEG
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: PUSH
70652: LD_INT 2
70654: PUSH
70655: LD_INT 0
70657: PUSH
70658: EMPTY
70659: LIST
70660: LIST
70661: PUSH
70662: LD_INT 2
70664: PUSH
70665: LD_INT 1
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: PUSH
70672: LD_INT 1
70674: PUSH
70675: LD_INT 2
70677: PUSH
70678: EMPTY
70679: LIST
70680: LIST
70681: PUSH
70682: LD_INT 0
70684: PUSH
70685: LD_INT 2
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 1
70694: NEG
70695: PUSH
70696: LD_INT 1
70698: PUSH
70699: EMPTY
70700: LIST
70701: LIST
70702: PUSH
70703: LD_INT 2
70705: NEG
70706: PUSH
70707: LD_INT 0
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 2
70716: NEG
70717: PUSH
70718: LD_INT 1
70720: NEG
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: LD_INT 2
70728: NEG
70729: PUSH
70730: LD_INT 2
70732: NEG
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: PUSH
70738: LD_INT 2
70740: NEG
70741: PUSH
70742: LD_INT 3
70744: NEG
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 2
70752: PUSH
70753: LD_INT 1
70755: NEG
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: PUSH
70761: LD_INT 3
70763: PUSH
70764: LD_INT 1
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: PUSH
70771: LD_INT 1
70773: PUSH
70774: LD_INT 3
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: PUSH
70781: LD_INT 1
70783: NEG
70784: PUSH
70785: LD_INT 2
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: PUSH
70792: LD_INT 3
70794: NEG
70795: PUSH
70796: LD_INT 2
70798: NEG
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: LIST
70820: LIST
70821: LIST
70822: LIST
70823: LIST
70824: LIST
70825: LIST
70826: LIST
70827: LIST
70828: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70829: LD_ADDR_VAR 0 34
70833: PUSH
70834: LD_INT 0
70836: PUSH
70837: LD_INT 0
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PUSH
70844: LD_INT 0
70846: PUSH
70847: LD_INT 1
70849: NEG
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 1
70857: PUSH
70858: LD_INT 0
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: PUSH
70865: LD_INT 1
70867: PUSH
70868: LD_INT 1
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PUSH
70875: LD_INT 0
70877: PUSH
70878: LD_INT 1
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 1
70887: NEG
70888: PUSH
70889: LD_INT 0
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: NEG
70899: PUSH
70900: LD_INT 1
70902: NEG
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: LD_INT 1
70910: NEG
70911: PUSH
70912: LD_INT 2
70914: NEG
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: PUSH
70920: LD_INT 0
70922: PUSH
70923: LD_INT 2
70925: NEG
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 1
70933: PUSH
70934: LD_INT 1
70936: NEG
70937: PUSH
70938: EMPTY
70939: LIST
70940: LIST
70941: PUSH
70942: LD_INT 2
70944: PUSH
70945: LD_INT 1
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: PUSH
70952: LD_INT 2
70954: PUSH
70955: LD_INT 2
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: PUSH
70962: LD_INT 1
70964: PUSH
70965: LD_INT 2
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: PUSH
70972: LD_INT 1
70974: NEG
70975: PUSH
70976: LD_INT 1
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: PUSH
70983: LD_INT 2
70985: NEG
70986: PUSH
70987: LD_INT 0
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 2
70996: NEG
70997: PUSH
70998: LD_INT 1
71000: NEG
71001: PUSH
71002: EMPTY
71003: LIST
71004: LIST
71005: PUSH
71006: LD_INT 2
71008: NEG
71009: PUSH
71010: LD_INT 2
71012: NEG
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 1
71020: NEG
71021: PUSH
71022: LD_INT 3
71024: NEG
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 1
71032: PUSH
71033: LD_INT 2
71035: NEG
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: LD_INT 3
71043: PUSH
71044: LD_INT 2
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 2
71053: PUSH
71054: LD_INT 3
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 2
71063: NEG
71064: PUSH
71065: LD_INT 1
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 3
71074: NEG
71075: PUSH
71076: LD_INT 1
71078: NEG
71079: PUSH
71080: EMPTY
71081: LIST
71082: LIST
71083: PUSH
71084: EMPTY
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: LIST
71098: LIST
71099: LIST
71100: LIST
71101: LIST
71102: LIST
71103: LIST
71104: LIST
71105: LIST
71106: LIST
71107: LIST
71108: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71109: LD_ADDR_VAR 0 35
71113: PUSH
71114: LD_INT 0
71116: PUSH
71117: LD_INT 0
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 0
71126: PUSH
71127: LD_INT 1
71129: NEG
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 1
71137: PUSH
71138: LD_INT 0
71140: PUSH
71141: EMPTY
71142: LIST
71143: LIST
71144: PUSH
71145: LD_INT 1
71147: PUSH
71148: LD_INT 1
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: LD_INT 0
71157: PUSH
71158: LD_INT 1
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PUSH
71165: LD_INT 1
71167: NEG
71168: PUSH
71169: LD_INT 0
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: LD_INT 1
71178: NEG
71179: PUSH
71180: LD_INT 1
71182: NEG
71183: PUSH
71184: EMPTY
71185: LIST
71186: LIST
71187: PUSH
71188: LD_INT 2
71190: PUSH
71191: LD_INT 1
71193: PUSH
71194: EMPTY
71195: LIST
71196: LIST
71197: PUSH
71198: LD_INT 2
71200: NEG
71201: PUSH
71202: LD_INT 1
71204: NEG
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: LIST
71214: LIST
71215: LIST
71216: LIST
71217: LIST
71218: LIST
71219: LIST
71220: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71221: LD_ADDR_VAR 0 36
71225: PUSH
71226: LD_INT 0
71228: PUSH
71229: LD_INT 0
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: LD_INT 0
71238: PUSH
71239: LD_INT 1
71241: NEG
71242: PUSH
71243: EMPTY
71244: LIST
71245: LIST
71246: PUSH
71247: LD_INT 1
71249: PUSH
71250: LD_INT 0
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 1
71259: PUSH
71260: LD_INT 1
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 0
71269: PUSH
71270: LD_INT 1
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: PUSH
71277: LD_INT 1
71279: NEG
71280: PUSH
71281: LD_INT 0
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 1
71290: NEG
71291: PUSH
71292: LD_INT 1
71294: NEG
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: NEG
71303: PUSH
71304: LD_INT 2
71306: NEG
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: LD_INT 1
71314: PUSH
71315: LD_INT 2
71317: PUSH
71318: EMPTY
71319: LIST
71320: LIST
71321: PUSH
71322: EMPTY
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71333: LD_ADDR_VAR 0 37
71337: PUSH
71338: LD_INT 0
71340: PUSH
71341: LD_INT 0
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: PUSH
71348: LD_INT 0
71350: PUSH
71351: LD_INT 1
71353: NEG
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PUSH
71359: LD_INT 1
71361: PUSH
71362: LD_INT 0
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PUSH
71369: LD_INT 1
71371: PUSH
71372: LD_INT 1
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: LD_INT 0
71381: PUSH
71382: LD_INT 1
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: PUSH
71389: LD_INT 1
71391: NEG
71392: PUSH
71393: LD_INT 0
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: LD_INT 1
71402: NEG
71403: PUSH
71404: LD_INT 1
71406: NEG
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 1
71414: PUSH
71415: LD_INT 1
71417: NEG
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PUSH
71423: LD_INT 1
71425: NEG
71426: PUSH
71427: LD_INT 1
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71445: LD_ADDR_VAR 0 38
71449: PUSH
71450: LD_INT 0
71452: PUSH
71453: LD_INT 0
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: LD_INT 0
71462: PUSH
71463: LD_INT 1
71465: NEG
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: PUSH
71471: LD_INT 1
71473: PUSH
71474: LD_INT 0
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 1
71483: PUSH
71484: LD_INT 1
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 0
71493: PUSH
71494: LD_INT 1
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: PUSH
71501: LD_INT 1
71503: NEG
71504: PUSH
71505: LD_INT 0
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PUSH
71512: LD_INT 1
71514: NEG
71515: PUSH
71516: LD_INT 1
71518: NEG
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PUSH
71524: LD_INT 2
71526: PUSH
71527: LD_INT 1
71529: PUSH
71530: EMPTY
71531: LIST
71532: LIST
71533: PUSH
71534: LD_INT 2
71536: NEG
71537: PUSH
71538: LD_INT 1
71540: NEG
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: LIST
71550: LIST
71551: LIST
71552: LIST
71553: LIST
71554: LIST
71555: LIST
71556: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71557: LD_ADDR_VAR 0 39
71561: PUSH
71562: LD_INT 0
71564: PUSH
71565: LD_INT 0
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PUSH
71572: LD_INT 0
71574: PUSH
71575: LD_INT 1
71577: NEG
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 1
71585: PUSH
71586: LD_INT 0
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 1
71595: PUSH
71596: LD_INT 1
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PUSH
71603: LD_INT 0
71605: PUSH
71606: LD_INT 1
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: PUSH
71613: LD_INT 1
71615: NEG
71616: PUSH
71617: LD_INT 0
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: PUSH
71624: LD_INT 1
71626: NEG
71627: PUSH
71628: LD_INT 1
71630: NEG
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 1
71638: NEG
71639: PUSH
71640: LD_INT 2
71642: NEG
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 1
71650: PUSH
71651: LD_INT 2
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: LIST
71662: LIST
71663: LIST
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71669: LD_ADDR_VAR 0 40
71673: PUSH
71674: LD_INT 0
71676: PUSH
71677: LD_INT 0
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: PUSH
71684: LD_INT 0
71686: PUSH
71687: LD_INT 1
71689: NEG
71690: PUSH
71691: EMPTY
71692: LIST
71693: LIST
71694: PUSH
71695: LD_INT 1
71697: PUSH
71698: LD_INT 0
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: LD_INT 1
71707: PUSH
71708: LD_INT 1
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 0
71717: PUSH
71718: LD_INT 1
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: PUSH
71725: LD_INT 1
71727: NEG
71728: PUSH
71729: LD_INT 0
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 1
71738: NEG
71739: PUSH
71740: LD_INT 1
71742: NEG
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 1
71750: PUSH
71751: LD_INT 1
71753: NEG
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: LD_INT 1
71761: NEG
71762: PUSH
71763: LD_INT 1
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PUSH
71770: EMPTY
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71781: LD_ADDR_VAR 0 41
71785: PUSH
71786: LD_INT 0
71788: PUSH
71789: LD_INT 0
71791: PUSH
71792: EMPTY
71793: LIST
71794: LIST
71795: PUSH
71796: LD_INT 0
71798: PUSH
71799: LD_INT 1
71801: NEG
71802: PUSH
71803: EMPTY
71804: LIST
71805: LIST
71806: PUSH
71807: LD_INT 1
71809: PUSH
71810: LD_INT 0
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: PUSH
71817: LD_INT 1
71819: PUSH
71820: LD_INT 1
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 0
71829: PUSH
71830: LD_INT 1
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: LD_INT 1
71839: NEG
71840: PUSH
71841: LD_INT 0
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 1
71850: NEG
71851: PUSH
71852: LD_INT 1
71854: NEG
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 1
71862: NEG
71863: PUSH
71864: LD_INT 2
71866: NEG
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 1
71874: PUSH
71875: LD_INT 1
71877: NEG
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: PUSH
71883: LD_INT 2
71885: PUSH
71886: LD_INT 0
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: PUSH
71893: LD_INT 2
71895: PUSH
71896: LD_INT 1
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 2
71905: PUSH
71906: LD_INT 2
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_INT 1
71915: PUSH
71916: LD_INT 2
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 1
71925: NEG
71926: PUSH
71927: LD_INT 1
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 2
71936: NEG
71937: PUSH
71938: LD_INT 0
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PUSH
71945: LD_INT 2
71947: NEG
71948: PUSH
71949: LD_INT 1
71951: NEG
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: LD_INT 2
71959: NEG
71960: PUSH
71961: LD_INT 2
71963: NEG
71964: PUSH
71965: EMPTY
71966: LIST
71967: LIST
71968: PUSH
71969: LD_INT 2
71971: NEG
71972: PUSH
71973: LD_INT 3
71975: NEG
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: PUSH
71981: LD_INT 2
71983: PUSH
71984: LD_INT 1
71986: NEG
71987: PUSH
71988: EMPTY
71989: LIST
71990: LIST
71991: PUSH
71992: LD_INT 3
71994: PUSH
71995: LD_INT 0
71997: PUSH
71998: EMPTY
71999: LIST
72000: LIST
72001: PUSH
72002: LD_INT 3
72004: PUSH
72005: LD_INT 1
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: PUSH
72012: LD_INT 3
72014: PUSH
72015: LD_INT 2
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: PUSH
72022: LD_INT 3
72024: PUSH
72025: LD_INT 3
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 2
72034: PUSH
72035: LD_INT 3
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: PUSH
72042: LD_INT 2
72044: NEG
72045: PUSH
72046: LD_INT 1
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 3
72055: NEG
72056: PUSH
72057: LD_INT 0
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: LD_INT 3
72066: NEG
72067: PUSH
72068: LD_INT 1
72070: NEG
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 3
72078: NEG
72079: PUSH
72080: LD_INT 2
72082: NEG
72083: PUSH
72084: EMPTY
72085: LIST
72086: LIST
72087: PUSH
72088: LD_INT 3
72090: NEG
72091: PUSH
72092: LD_INT 3
72094: NEG
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: LIST
72107: LIST
72108: LIST
72109: LIST
72110: LIST
72111: LIST
72112: LIST
72113: LIST
72114: LIST
72115: LIST
72116: LIST
72117: LIST
72118: LIST
72119: LIST
72120: LIST
72121: LIST
72122: LIST
72123: LIST
72124: LIST
72125: LIST
72126: LIST
72127: LIST
72128: LIST
72129: LIST
72130: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72131: LD_ADDR_VAR 0 42
72135: PUSH
72136: LD_INT 0
72138: PUSH
72139: LD_INT 0
72141: PUSH
72142: EMPTY
72143: LIST
72144: LIST
72145: PUSH
72146: LD_INT 0
72148: PUSH
72149: LD_INT 1
72151: NEG
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PUSH
72157: LD_INT 1
72159: PUSH
72160: LD_INT 0
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 1
72169: PUSH
72170: LD_INT 1
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 0
72179: PUSH
72180: LD_INT 1
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: LD_INT 1
72189: NEG
72190: PUSH
72191: LD_INT 0
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 1
72200: NEG
72201: PUSH
72202: LD_INT 1
72204: NEG
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 1
72212: NEG
72213: PUSH
72214: LD_INT 2
72216: NEG
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: LD_INT 2
72227: NEG
72228: PUSH
72229: EMPTY
72230: LIST
72231: LIST
72232: PUSH
72233: LD_INT 1
72235: PUSH
72236: LD_INT 1
72238: NEG
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: PUSH
72244: LD_INT 2
72246: PUSH
72247: LD_INT 1
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: PUSH
72254: LD_INT 2
72256: PUSH
72257: LD_INT 2
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 1
72266: PUSH
72267: LD_INT 2
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PUSH
72274: LD_INT 0
72276: PUSH
72277: LD_INT 2
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 1
72286: NEG
72287: PUSH
72288: LD_INT 1
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 2
72297: NEG
72298: PUSH
72299: LD_INT 1
72301: NEG
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 2
72309: NEG
72310: PUSH
72311: LD_INT 2
72313: NEG
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PUSH
72319: LD_INT 2
72321: NEG
72322: PUSH
72323: LD_INT 3
72325: NEG
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: PUSH
72331: LD_INT 1
72333: NEG
72334: PUSH
72335: LD_INT 3
72337: NEG
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 0
72345: PUSH
72346: LD_INT 3
72348: NEG
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 1
72356: PUSH
72357: LD_INT 2
72359: NEG
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 3
72367: PUSH
72368: LD_INT 2
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 3
72377: PUSH
72378: LD_INT 3
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 2
72387: PUSH
72388: LD_INT 3
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 1
72397: PUSH
72398: LD_INT 3
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 0
72407: PUSH
72408: LD_INT 3
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PUSH
72415: LD_INT 1
72417: NEG
72418: PUSH
72419: LD_INT 2
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 3
72428: NEG
72429: PUSH
72430: LD_INT 2
72432: NEG
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 3
72440: NEG
72441: PUSH
72442: LD_INT 3
72444: NEG
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: LIST
72469: LIST
72470: LIST
72471: LIST
72472: LIST
72473: LIST
72474: LIST
72475: LIST
72476: LIST
72477: LIST
72478: LIST
72479: LIST
72480: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72481: LD_ADDR_VAR 0 43
72485: PUSH
72486: LD_INT 0
72488: PUSH
72489: LD_INT 0
72491: PUSH
72492: EMPTY
72493: LIST
72494: LIST
72495: PUSH
72496: LD_INT 0
72498: PUSH
72499: LD_INT 1
72501: NEG
72502: PUSH
72503: EMPTY
72504: LIST
72505: LIST
72506: PUSH
72507: LD_INT 1
72509: PUSH
72510: LD_INT 0
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 1
72519: PUSH
72520: LD_INT 1
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PUSH
72527: LD_INT 0
72529: PUSH
72530: LD_INT 1
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: PUSH
72537: LD_INT 1
72539: NEG
72540: PUSH
72541: LD_INT 0
72543: PUSH
72544: EMPTY
72545: LIST
72546: LIST
72547: PUSH
72548: LD_INT 1
72550: NEG
72551: PUSH
72552: LD_INT 1
72554: NEG
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 1
72562: NEG
72563: PUSH
72564: LD_INT 2
72566: NEG
72567: PUSH
72568: EMPTY
72569: LIST
72570: LIST
72571: PUSH
72572: LD_INT 0
72574: PUSH
72575: LD_INT 2
72577: NEG
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: LD_INT 1
72585: PUSH
72586: LD_INT 1
72588: NEG
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: PUSH
72594: LD_INT 2
72596: PUSH
72597: LD_INT 0
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: PUSH
72604: LD_INT 2
72606: PUSH
72607: LD_INT 1
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: LD_INT 1
72616: PUSH
72617: LD_INT 2
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 0
72626: PUSH
72627: LD_INT 2
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 1
72636: NEG
72637: PUSH
72638: LD_INT 1
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 2
72647: NEG
72648: PUSH
72649: LD_INT 0
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 2
72658: NEG
72659: PUSH
72660: LD_INT 1
72662: NEG
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: LD_INT 1
72670: NEG
72671: PUSH
72672: LD_INT 3
72674: NEG
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: PUSH
72680: LD_INT 0
72682: PUSH
72683: LD_INT 3
72685: NEG
72686: PUSH
72687: EMPTY
72688: LIST
72689: LIST
72690: PUSH
72691: LD_INT 1
72693: PUSH
72694: LD_INT 2
72696: NEG
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 2
72704: PUSH
72705: LD_INT 1
72707: NEG
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: LD_INT 3
72715: PUSH
72716: LD_INT 0
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: LD_INT 3
72725: PUSH
72726: LD_INT 1
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 1
72735: PUSH
72736: LD_INT 3
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 0
72745: PUSH
72746: LD_INT 3
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 1
72755: NEG
72756: PUSH
72757: LD_INT 2
72759: PUSH
72760: EMPTY
72761: LIST
72762: LIST
72763: PUSH
72764: LD_INT 2
72766: NEG
72767: PUSH
72768: LD_INT 1
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: PUSH
72775: LD_INT 3
72777: NEG
72778: PUSH
72779: LD_INT 0
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 3
72788: NEG
72789: PUSH
72790: LD_INT 1
72792: NEG
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: EMPTY
72799: LIST
72800: LIST
72801: LIST
72802: LIST
72803: LIST
72804: LIST
72805: LIST
72806: LIST
72807: LIST
72808: LIST
72809: LIST
72810: LIST
72811: LIST
72812: LIST
72813: LIST
72814: LIST
72815: LIST
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: LIST
72824: LIST
72825: LIST
72826: LIST
72827: LIST
72828: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72829: LD_ADDR_VAR 0 44
72833: PUSH
72834: LD_INT 0
72836: PUSH
72837: LD_INT 0
72839: PUSH
72840: EMPTY
72841: LIST
72842: LIST
72843: PUSH
72844: LD_INT 0
72846: PUSH
72847: LD_INT 1
72849: NEG
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 1
72857: PUSH
72858: LD_INT 0
72860: PUSH
72861: EMPTY
72862: LIST
72863: LIST
72864: PUSH
72865: LD_INT 1
72867: PUSH
72868: LD_INT 1
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 0
72877: PUSH
72878: LD_INT 1
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 1
72887: NEG
72888: PUSH
72889: LD_INT 0
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 1
72898: NEG
72899: PUSH
72900: LD_INT 1
72902: NEG
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 1
72910: NEG
72911: PUSH
72912: LD_INT 2
72914: NEG
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: PUSH
72920: LD_INT 1
72922: PUSH
72923: LD_INT 1
72925: NEG
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PUSH
72931: LD_INT 2
72933: PUSH
72934: LD_INT 0
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 2
72943: PUSH
72944: LD_INT 1
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 2
72953: PUSH
72954: LD_INT 2
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: LD_INT 2
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 1
72973: NEG
72974: PUSH
72975: LD_INT 1
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 2
72984: NEG
72985: PUSH
72986: LD_INT 0
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 2
72995: NEG
72996: PUSH
72997: LD_INT 1
72999: NEG
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PUSH
73005: LD_INT 2
73007: NEG
73008: PUSH
73009: LD_INT 2
73011: NEG
73012: PUSH
73013: EMPTY
73014: LIST
73015: LIST
73016: PUSH
73017: LD_INT 2
73019: NEG
73020: PUSH
73021: LD_INT 3
73023: NEG
73024: PUSH
73025: EMPTY
73026: LIST
73027: LIST
73028: PUSH
73029: LD_INT 2
73031: PUSH
73032: LD_INT 1
73034: NEG
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PUSH
73040: LD_INT 3
73042: PUSH
73043: LD_INT 0
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: LD_INT 3
73052: PUSH
73053: LD_INT 1
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: LD_INT 3
73062: PUSH
73063: LD_INT 2
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: LD_INT 3
73072: PUSH
73073: LD_INT 3
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: PUSH
73080: LD_INT 2
73082: PUSH
73083: LD_INT 3
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 2
73092: NEG
73093: PUSH
73094: LD_INT 1
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: LD_INT 3
73103: NEG
73104: PUSH
73105: LD_INT 0
73107: PUSH
73108: EMPTY
73109: LIST
73110: LIST
73111: PUSH
73112: LD_INT 3
73114: NEG
73115: PUSH
73116: LD_INT 1
73118: NEG
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: LD_INT 3
73126: NEG
73127: PUSH
73128: LD_INT 2
73130: NEG
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 3
73138: NEG
73139: PUSH
73140: LD_INT 3
73142: NEG
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: LIST
73155: LIST
73156: LIST
73157: LIST
73158: LIST
73159: LIST
73160: LIST
73161: LIST
73162: LIST
73163: LIST
73164: LIST
73165: LIST
73166: LIST
73167: LIST
73168: LIST
73169: LIST
73170: LIST
73171: LIST
73172: LIST
73173: LIST
73174: LIST
73175: LIST
73176: LIST
73177: LIST
73178: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73179: LD_ADDR_VAR 0 45
73183: PUSH
73184: LD_INT 0
73186: PUSH
73187: LD_INT 0
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: LD_INT 0
73196: PUSH
73197: LD_INT 1
73199: NEG
73200: PUSH
73201: EMPTY
73202: LIST
73203: LIST
73204: PUSH
73205: LD_INT 1
73207: PUSH
73208: LD_INT 0
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: PUSH
73215: LD_INT 1
73217: PUSH
73218: LD_INT 1
73220: PUSH
73221: EMPTY
73222: LIST
73223: LIST
73224: PUSH
73225: LD_INT 0
73227: PUSH
73228: LD_INT 1
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 1
73237: NEG
73238: PUSH
73239: LD_INT 0
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 1
73248: NEG
73249: PUSH
73250: LD_INT 1
73252: NEG
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 1
73260: NEG
73261: PUSH
73262: LD_INT 2
73264: NEG
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: PUSH
73270: LD_INT 0
73272: PUSH
73273: LD_INT 2
73275: NEG
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: LD_INT 1
73286: NEG
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: PUSH
73292: LD_INT 2
73294: PUSH
73295: LD_INT 1
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 2
73304: PUSH
73305: LD_INT 2
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 1
73314: PUSH
73315: LD_INT 2
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 0
73324: PUSH
73325: LD_INT 2
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: LD_INT 1
73334: NEG
73335: PUSH
73336: LD_INT 1
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 2
73345: NEG
73346: PUSH
73347: LD_INT 1
73349: NEG
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 2
73357: NEG
73358: PUSH
73359: LD_INT 2
73361: NEG
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 2
73369: NEG
73370: PUSH
73371: LD_INT 3
73373: NEG
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: PUSH
73379: LD_INT 1
73381: NEG
73382: PUSH
73383: LD_INT 3
73385: NEG
73386: PUSH
73387: EMPTY
73388: LIST
73389: LIST
73390: PUSH
73391: LD_INT 0
73393: PUSH
73394: LD_INT 3
73396: NEG
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: LD_INT 1
73404: PUSH
73405: LD_INT 2
73407: NEG
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 3
73415: PUSH
73416: LD_INT 2
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: PUSH
73423: LD_INT 3
73425: PUSH
73426: LD_INT 3
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 2
73435: PUSH
73436: LD_INT 3
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 1
73445: PUSH
73446: LD_INT 3
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 0
73455: PUSH
73456: LD_INT 3
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 1
73465: NEG
73466: PUSH
73467: LD_INT 2
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 3
73476: NEG
73477: PUSH
73478: LD_INT 2
73480: NEG
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 3
73488: NEG
73489: PUSH
73490: LD_INT 3
73492: NEG
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: LIST
73502: LIST
73503: LIST
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73529: LD_ADDR_VAR 0 46
73533: PUSH
73534: LD_INT 0
73536: PUSH
73537: LD_INT 0
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: LD_INT 0
73546: PUSH
73547: LD_INT 1
73549: NEG
73550: PUSH
73551: EMPTY
73552: LIST
73553: LIST
73554: PUSH
73555: LD_INT 1
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 1
73567: PUSH
73568: LD_INT 1
73570: PUSH
73571: EMPTY
73572: LIST
73573: LIST
73574: PUSH
73575: LD_INT 0
73577: PUSH
73578: LD_INT 1
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 1
73587: NEG
73588: PUSH
73589: LD_INT 0
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 1
73598: NEG
73599: PUSH
73600: LD_INT 1
73602: NEG
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 1
73610: NEG
73611: PUSH
73612: LD_INT 2
73614: NEG
73615: PUSH
73616: EMPTY
73617: LIST
73618: LIST
73619: PUSH
73620: LD_INT 0
73622: PUSH
73623: LD_INT 2
73625: NEG
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PUSH
73631: LD_INT 1
73633: PUSH
73634: LD_INT 1
73636: NEG
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: PUSH
73642: LD_INT 2
73644: PUSH
73645: LD_INT 0
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 2
73654: PUSH
73655: LD_INT 1
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: PUSH
73662: LD_INT 1
73664: PUSH
73665: LD_INT 2
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 0
73674: PUSH
73675: LD_INT 2
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: NEG
73685: PUSH
73686: LD_INT 1
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 2
73695: NEG
73696: PUSH
73697: LD_INT 0
73699: PUSH
73700: EMPTY
73701: LIST
73702: LIST
73703: PUSH
73704: LD_INT 2
73706: NEG
73707: PUSH
73708: LD_INT 1
73710: NEG
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PUSH
73716: LD_INT 1
73718: NEG
73719: PUSH
73720: LD_INT 3
73722: NEG
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: LD_INT 0
73730: PUSH
73731: LD_INT 3
73733: NEG
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: PUSH
73739: LD_INT 1
73741: PUSH
73742: LD_INT 2
73744: NEG
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: LD_INT 2
73752: PUSH
73753: LD_INT 1
73755: NEG
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: LD_INT 3
73763: PUSH
73764: LD_INT 0
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: PUSH
73771: LD_INT 3
73773: PUSH
73774: LD_INT 1
73776: PUSH
73777: EMPTY
73778: LIST
73779: LIST
73780: PUSH
73781: LD_INT 1
73783: PUSH
73784: LD_INT 3
73786: PUSH
73787: EMPTY
73788: LIST
73789: LIST
73790: PUSH
73791: LD_INT 0
73793: PUSH
73794: LD_INT 3
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: PUSH
73801: LD_INT 1
73803: NEG
73804: PUSH
73805: LD_INT 2
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 2
73814: NEG
73815: PUSH
73816: LD_INT 1
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 3
73825: NEG
73826: PUSH
73827: LD_INT 0
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 3
73836: NEG
73837: PUSH
73838: LD_INT 1
73840: NEG
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: LIST
73850: LIST
73851: LIST
73852: LIST
73853: LIST
73854: LIST
73855: LIST
73856: LIST
73857: LIST
73858: LIST
73859: LIST
73860: LIST
73861: LIST
73862: LIST
73863: LIST
73864: LIST
73865: LIST
73866: LIST
73867: LIST
73868: LIST
73869: LIST
73870: LIST
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73877: LD_ADDR_VAR 0 47
73881: PUSH
73882: LD_INT 0
73884: PUSH
73885: LD_INT 0
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: LD_INT 1
73897: NEG
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 1
73905: PUSH
73906: LD_INT 0
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 1
73915: PUSH
73916: LD_INT 1
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 0
73925: PUSH
73926: LD_INT 1
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 1
73935: NEG
73936: PUSH
73937: LD_INT 0
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: PUSH
73944: LD_INT 1
73946: NEG
73947: PUSH
73948: LD_INT 1
73950: NEG
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 1
73958: NEG
73959: PUSH
73960: LD_INT 2
73962: NEG
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 0
73970: PUSH
73971: LD_INT 2
73973: NEG
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: LD_INT 1
73981: PUSH
73982: LD_INT 1
73984: NEG
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: LD_INT 2
73992: NEG
73993: PUSH
73994: LD_INT 1
73996: NEG
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: LD_INT 2
74004: NEG
74005: PUSH
74006: LD_INT 2
74008: NEG
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PUSH
74014: EMPTY
74015: LIST
74016: LIST
74017: LIST
74018: LIST
74019: LIST
74020: LIST
74021: LIST
74022: LIST
74023: LIST
74024: LIST
74025: LIST
74026: LIST
74027: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74028: LD_ADDR_VAR 0 48
74032: PUSH
74033: LD_INT 0
74035: PUSH
74036: LD_INT 0
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: LD_INT 0
74045: PUSH
74046: LD_INT 1
74048: NEG
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: LD_INT 1
74056: PUSH
74057: LD_INT 0
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 1
74066: PUSH
74067: LD_INT 1
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 0
74076: PUSH
74077: LD_INT 1
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 1
74086: NEG
74087: PUSH
74088: LD_INT 0
74090: PUSH
74091: EMPTY
74092: LIST
74093: LIST
74094: PUSH
74095: LD_INT 1
74097: NEG
74098: PUSH
74099: LD_INT 1
74101: NEG
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 1
74109: NEG
74110: PUSH
74111: LD_INT 2
74113: NEG
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: LD_INT 0
74121: PUSH
74122: LD_INT 2
74124: NEG
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 1
74132: PUSH
74133: LD_INT 1
74135: NEG
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: PUSH
74141: LD_INT 2
74143: PUSH
74144: LD_INT 0
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: PUSH
74151: LD_INT 2
74153: PUSH
74154: LD_INT 1
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: LIST
74165: LIST
74166: LIST
74167: LIST
74168: LIST
74169: LIST
74170: LIST
74171: LIST
74172: LIST
74173: LIST
74174: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74175: LD_ADDR_VAR 0 49
74179: PUSH
74180: LD_INT 0
74182: PUSH
74183: LD_INT 0
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: LD_INT 0
74192: PUSH
74193: LD_INT 1
74195: NEG
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: LD_INT 1
74203: PUSH
74204: LD_INT 0
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: LD_INT 1
74213: PUSH
74214: LD_INT 1
74216: PUSH
74217: EMPTY
74218: LIST
74219: LIST
74220: PUSH
74221: LD_INT 0
74223: PUSH
74224: LD_INT 1
74226: PUSH
74227: EMPTY
74228: LIST
74229: LIST
74230: PUSH
74231: LD_INT 1
74233: NEG
74234: PUSH
74235: LD_INT 0
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 1
74244: NEG
74245: PUSH
74246: LD_INT 1
74248: NEG
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: PUSH
74254: LD_INT 1
74256: PUSH
74257: LD_INT 1
74259: NEG
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: PUSH
74265: LD_INT 2
74267: PUSH
74268: LD_INT 0
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 2
74277: PUSH
74278: LD_INT 1
74280: PUSH
74281: EMPTY
74282: LIST
74283: LIST
74284: PUSH
74285: LD_INT 2
74287: PUSH
74288: LD_INT 2
74290: PUSH
74291: EMPTY
74292: LIST
74293: LIST
74294: PUSH
74295: LD_INT 1
74297: PUSH
74298: LD_INT 2
74300: PUSH
74301: EMPTY
74302: LIST
74303: LIST
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: LIST
74309: LIST
74310: LIST
74311: LIST
74312: LIST
74313: LIST
74314: LIST
74315: LIST
74316: LIST
74317: LIST
74318: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74319: LD_ADDR_VAR 0 50
74323: PUSH
74324: LD_INT 0
74326: PUSH
74327: LD_INT 0
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 0
74336: PUSH
74337: LD_INT 1
74339: NEG
74340: PUSH
74341: EMPTY
74342: LIST
74343: LIST
74344: PUSH
74345: LD_INT 1
74347: PUSH
74348: LD_INT 0
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: PUSH
74355: LD_INT 1
74357: PUSH
74358: LD_INT 1
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 0
74367: PUSH
74368: LD_INT 1
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: LD_INT 1
74377: NEG
74378: PUSH
74379: LD_INT 0
74381: PUSH
74382: EMPTY
74383: LIST
74384: LIST
74385: PUSH
74386: LD_INT 1
74388: NEG
74389: PUSH
74390: LD_INT 1
74392: NEG
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: LD_INT 2
74400: PUSH
74401: LD_INT 1
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 2
74410: PUSH
74411: LD_INT 2
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: LD_INT 1
74420: PUSH
74421: LD_INT 2
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: PUSH
74428: LD_INT 0
74430: PUSH
74431: LD_INT 2
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 1
74440: NEG
74441: PUSH
74442: LD_INT 1
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: LIST
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: LIST
74458: LIST
74459: LIST
74460: LIST
74461: LIST
74462: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74463: LD_ADDR_VAR 0 51
74467: PUSH
74468: LD_INT 0
74470: PUSH
74471: LD_INT 0
74473: PUSH
74474: EMPTY
74475: LIST
74476: LIST
74477: PUSH
74478: LD_INT 0
74480: PUSH
74481: LD_INT 1
74483: NEG
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 1
74491: PUSH
74492: LD_INT 0
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 1
74501: PUSH
74502: LD_INT 1
74504: PUSH
74505: EMPTY
74506: LIST
74507: LIST
74508: PUSH
74509: LD_INT 0
74511: PUSH
74512: LD_INT 1
74514: PUSH
74515: EMPTY
74516: LIST
74517: LIST
74518: PUSH
74519: LD_INT 1
74521: NEG
74522: PUSH
74523: LD_INT 0
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: LD_INT 1
74532: NEG
74533: PUSH
74534: LD_INT 1
74536: NEG
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 1
74544: PUSH
74545: LD_INT 2
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: PUSH
74552: LD_INT 0
74554: PUSH
74555: LD_INT 2
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: LD_INT 1
74564: NEG
74565: PUSH
74566: LD_INT 1
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: LD_INT 2
74575: NEG
74576: PUSH
74577: LD_INT 0
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 2
74586: NEG
74587: PUSH
74588: LD_INT 1
74590: NEG
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: LIST
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: LIST
74605: LIST
74606: LIST
74607: LIST
74608: LIST
74609: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74610: LD_ADDR_VAR 0 52
74614: PUSH
74615: LD_INT 0
74617: PUSH
74618: LD_INT 0
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 0
74627: PUSH
74628: LD_INT 1
74630: NEG
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 1
74638: PUSH
74639: LD_INT 0
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: LD_INT 1
74648: PUSH
74649: LD_INT 1
74651: PUSH
74652: EMPTY
74653: LIST
74654: LIST
74655: PUSH
74656: LD_INT 0
74658: PUSH
74659: LD_INT 1
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: PUSH
74666: LD_INT 1
74668: NEG
74669: PUSH
74670: LD_INT 0
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 1
74679: NEG
74680: PUSH
74681: LD_INT 1
74683: NEG
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 1
74691: NEG
74692: PUSH
74693: LD_INT 2
74695: NEG
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 1
74703: NEG
74704: PUSH
74705: LD_INT 1
74707: PUSH
74708: EMPTY
74709: LIST
74710: LIST
74711: PUSH
74712: LD_INT 2
74714: NEG
74715: PUSH
74716: LD_INT 0
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: PUSH
74723: LD_INT 2
74725: NEG
74726: PUSH
74727: LD_INT 1
74729: NEG
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: LD_INT 2
74737: NEG
74738: PUSH
74739: LD_INT 2
74741: NEG
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: LIST
74751: LIST
74752: LIST
74753: LIST
74754: LIST
74755: LIST
74756: LIST
74757: LIST
74758: LIST
74759: LIST
74760: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74761: LD_ADDR_VAR 0 53
74765: PUSH
74766: LD_INT 0
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 0
74778: PUSH
74779: LD_INT 1
74781: NEG
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: PUSH
74787: LD_INT 1
74789: PUSH
74790: LD_INT 0
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 1
74799: PUSH
74800: LD_INT 1
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 0
74809: PUSH
74810: LD_INT 1
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 1
74819: NEG
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 1
74830: NEG
74831: PUSH
74832: LD_INT 1
74834: NEG
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: LD_INT 1
74842: NEG
74843: PUSH
74844: LD_INT 2
74846: NEG
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 0
74854: PUSH
74855: LD_INT 2
74857: NEG
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 1
74865: PUSH
74866: LD_INT 1
74868: NEG
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: LD_INT 2
74876: PUSH
74877: LD_INT 0
74879: PUSH
74880: EMPTY
74881: LIST
74882: LIST
74883: PUSH
74884: LD_INT 2
74886: PUSH
74887: LD_INT 1
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: PUSH
74894: LD_INT 2
74896: PUSH
74897: LD_INT 2
74899: PUSH
74900: EMPTY
74901: LIST
74902: LIST
74903: PUSH
74904: LD_INT 1
74906: PUSH
74907: LD_INT 2
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 0
74916: PUSH
74917: LD_INT 2
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: PUSH
74924: LD_INT 1
74926: NEG
74927: PUSH
74928: LD_INT 1
74930: PUSH
74931: EMPTY
74932: LIST
74933: LIST
74934: PUSH
74935: LD_INT 2
74937: NEG
74938: PUSH
74939: LD_INT 0
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: PUSH
74946: LD_INT 2
74948: NEG
74949: PUSH
74950: LD_INT 1
74952: NEG
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: PUSH
74958: LD_INT 2
74960: NEG
74961: PUSH
74962: LD_INT 2
74964: NEG
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: LIST
74974: LIST
74975: LIST
74976: LIST
74977: LIST
74978: LIST
74979: LIST
74980: LIST
74981: LIST
74982: LIST
74983: LIST
74984: LIST
74985: LIST
74986: LIST
74987: LIST
74988: LIST
74989: LIST
74990: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74991: LD_ADDR_VAR 0 54
74995: PUSH
74996: LD_INT 0
74998: PUSH
74999: LD_INT 0
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: LD_INT 0
75008: PUSH
75009: LD_INT 1
75011: NEG
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 1
75019: PUSH
75020: LD_INT 0
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: PUSH
75027: LD_INT 1
75029: PUSH
75030: LD_INT 1
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 0
75039: PUSH
75040: LD_INT 1
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 1
75049: NEG
75050: PUSH
75051: LD_INT 0
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: LD_INT 1
75060: NEG
75061: PUSH
75062: LD_INT 1
75064: NEG
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 1
75072: NEG
75073: PUSH
75074: LD_INT 2
75076: NEG
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 0
75084: PUSH
75085: LD_INT 2
75087: NEG
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 1
75095: PUSH
75096: LD_INT 1
75098: NEG
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: LD_INT 2
75106: PUSH
75107: LD_INT 0
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PUSH
75114: LD_INT 2
75116: PUSH
75117: LD_INT 1
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: LD_INT 2
75126: PUSH
75127: LD_INT 2
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 1
75136: PUSH
75137: LD_INT 2
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 0
75146: PUSH
75147: LD_INT 2
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: PUSH
75154: LD_INT 1
75156: NEG
75157: PUSH
75158: LD_INT 1
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PUSH
75165: LD_INT 2
75167: NEG
75168: PUSH
75169: LD_INT 0
75171: PUSH
75172: EMPTY
75173: LIST
75174: LIST
75175: PUSH
75176: LD_INT 2
75178: NEG
75179: PUSH
75180: LD_INT 1
75182: NEG
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: PUSH
75188: LD_INT 2
75190: NEG
75191: PUSH
75192: LD_INT 2
75194: NEG
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: LIST
75204: LIST
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: LIST
75212: LIST
75213: LIST
75214: LIST
75215: LIST
75216: LIST
75217: LIST
75218: LIST
75219: LIST
75220: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75221: LD_ADDR_VAR 0 55
75225: PUSH
75226: LD_INT 0
75228: PUSH
75229: LD_INT 0
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: LD_INT 0
75238: PUSH
75239: LD_INT 1
75241: NEG
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: LD_INT 1
75249: PUSH
75250: LD_INT 0
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: LD_INT 1
75259: PUSH
75260: LD_INT 1
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: PUSH
75267: LD_INT 0
75269: PUSH
75270: LD_INT 1
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PUSH
75277: LD_INT 1
75279: NEG
75280: PUSH
75281: LD_INT 0
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 1
75290: NEG
75291: PUSH
75292: LD_INT 1
75294: NEG
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 1
75302: NEG
75303: PUSH
75304: LD_INT 2
75306: NEG
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 0
75314: PUSH
75315: LD_INT 2
75317: NEG
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 1
75325: PUSH
75326: LD_INT 1
75328: NEG
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: PUSH
75334: LD_INT 2
75336: PUSH
75337: LD_INT 0
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PUSH
75344: LD_INT 2
75346: PUSH
75347: LD_INT 1
75349: PUSH
75350: EMPTY
75351: LIST
75352: LIST
75353: PUSH
75354: LD_INT 2
75356: PUSH
75357: LD_INT 2
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: LD_INT 1
75366: PUSH
75367: LD_INT 2
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: LD_INT 0
75376: PUSH
75377: LD_INT 2
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: PUSH
75384: LD_INT 1
75386: NEG
75387: PUSH
75388: LD_INT 1
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: LD_INT 2
75397: NEG
75398: PUSH
75399: LD_INT 0
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: PUSH
75406: LD_INT 2
75408: NEG
75409: PUSH
75410: LD_INT 1
75412: NEG
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 2
75420: NEG
75421: PUSH
75422: LD_INT 2
75424: NEG
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: LIST
75434: LIST
75435: LIST
75436: LIST
75437: LIST
75438: LIST
75439: LIST
75440: LIST
75441: LIST
75442: LIST
75443: LIST
75444: LIST
75445: LIST
75446: LIST
75447: LIST
75448: LIST
75449: LIST
75450: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75451: LD_ADDR_VAR 0 56
75455: PUSH
75456: LD_INT 0
75458: PUSH
75459: LD_INT 0
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 0
75468: PUSH
75469: LD_INT 1
75471: NEG
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: PUSH
75477: LD_INT 1
75479: PUSH
75480: LD_INT 0
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: PUSH
75487: LD_INT 1
75489: PUSH
75490: LD_INT 1
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: PUSH
75497: LD_INT 0
75499: PUSH
75500: LD_INT 1
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: LD_INT 1
75509: NEG
75510: PUSH
75511: LD_INT 0
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: LD_INT 1
75520: NEG
75521: PUSH
75522: LD_INT 1
75524: NEG
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: LD_INT 1
75532: NEG
75533: PUSH
75534: LD_INT 2
75536: NEG
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 0
75544: PUSH
75545: LD_INT 2
75547: NEG
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: PUSH
75553: LD_INT 1
75555: PUSH
75556: LD_INT 1
75558: NEG
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 2
75566: PUSH
75567: LD_INT 0
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: PUSH
75574: LD_INT 2
75576: PUSH
75577: LD_INT 1
75579: PUSH
75580: EMPTY
75581: LIST
75582: LIST
75583: PUSH
75584: LD_INT 2
75586: PUSH
75587: LD_INT 2
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 1
75596: PUSH
75597: LD_INT 2
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: PUSH
75604: LD_INT 0
75606: PUSH
75607: LD_INT 2
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: PUSH
75614: LD_INT 1
75616: NEG
75617: PUSH
75618: LD_INT 1
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PUSH
75625: LD_INT 2
75627: NEG
75628: PUSH
75629: LD_INT 0
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: PUSH
75636: LD_INT 2
75638: NEG
75639: PUSH
75640: LD_INT 1
75642: NEG
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 2
75650: NEG
75651: PUSH
75652: LD_INT 2
75654: NEG
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: LIST
75664: LIST
75665: LIST
75666: LIST
75667: LIST
75668: LIST
75669: LIST
75670: LIST
75671: LIST
75672: LIST
75673: LIST
75674: LIST
75675: LIST
75676: LIST
75677: LIST
75678: LIST
75679: LIST
75680: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75681: LD_ADDR_VAR 0 57
75685: PUSH
75686: LD_INT 0
75688: PUSH
75689: LD_INT 0
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: LD_INT 0
75698: PUSH
75699: LD_INT 1
75701: NEG
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: LD_INT 1
75709: PUSH
75710: LD_INT 0
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: PUSH
75717: LD_INT 1
75719: PUSH
75720: LD_INT 1
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 0
75729: PUSH
75730: LD_INT 1
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PUSH
75737: LD_INT 1
75739: NEG
75740: PUSH
75741: LD_INT 0
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: LD_INT 1
75750: NEG
75751: PUSH
75752: LD_INT 1
75754: NEG
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 1
75762: NEG
75763: PUSH
75764: LD_INT 2
75766: NEG
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 0
75774: PUSH
75775: LD_INT 2
75777: NEG
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 1
75785: PUSH
75786: LD_INT 1
75788: NEG
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: LD_INT 2
75796: PUSH
75797: LD_INT 0
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: LD_INT 2
75806: PUSH
75807: LD_INT 1
75809: PUSH
75810: EMPTY
75811: LIST
75812: LIST
75813: PUSH
75814: LD_INT 2
75816: PUSH
75817: LD_INT 2
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 1
75826: PUSH
75827: LD_INT 2
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 0
75836: PUSH
75837: LD_INT 2
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: LD_INT 1
75846: NEG
75847: PUSH
75848: LD_INT 1
75850: PUSH
75851: EMPTY
75852: LIST
75853: LIST
75854: PUSH
75855: LD_INT 2
75857: NEG
75858: PUSH
75859: LD_INT 0
75861: PUSH
75862: EMPTY
75863: LIST
75864: LIST
75865: PUSH
75866: LD_INT 2
75868: NEG
75869: PUSH
75870: LD_INT 1
75872: NEG
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: PUSH
75878: LD_INT 2
75880: NEG
75881: PUSH
75882: LD_INT 2
75884: NEG
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: EMPTY
75891: LIST
75892: LIST
75893: LIST
75894: LIST
75895: LIST
75896: LIST
75897: LIST
75898: LIST
75899: LIST
75900: LIST
75901: LIST
75902: LIST
75903: LIST
75904: LIST
75905: LIST
75906: LIST
75907: LIST
75908: LIST
75909: LIST
75910: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75911: LD_ADDR_VAR 0 58
75915: PUSH
75916: LD_INT 0
75918: PUSH
75919: LD_INT 0
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: PUSH
75926: LD_INT 0
75928: PUSH
75929: LD_INT 1
75931: NEG
75932: PUSH
75933: EMPTY
75934: LIST
75935: LIST
75936: PUSH
75937: LD_INT 1
75939: PUSH
75940: LD_INT 0
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 1
75949: PUSH
75950: LD_INT 1
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 0
75959: PUSH
75960: LD_INT 1
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PUSH
75967: LD_INT 1
75969: NEG
75970: PUSH
75971: LD_INT 0
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: PUSH
75978: LD_INT 1
75980: NEG
75981: PUSH
75982: LD_INT 1
75984: NEG
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: PUSH
75990: LD_INT 1
75992: NEG
75993: PUSH
75994: LD_INT 2
75996: NEG
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: LD_INT 0
76004: PUSH
76005: LD_INT 2
76007: NEG
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 1
76015: PUSH
76016: LD_INT 1
76018: NEG
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: PUSH
76024: LD_INT 2
76026: PUSH
76027: LD_INT 0
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: LD_INT 2
76036: PUSH
76037: LD_INT 1
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PUSH
76044: LD_INT 2
76046: PUSH
76047: LD_INT 2
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 1
76056: PUSH
76057: LD_INT 2
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 0
76066: PUSH
76067: LD_INT 2
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 1
76076: NEG
76077: PUSH
76078: LD_INT 1
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 2
76087: NEG
76088: PUSH
76089: LD_INT 0
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: PUSH
76096: LD_INT 2
76098: NEG
76099: PUSH
76100: LD_INT 1
76102: NEG
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: PUSH
76108: LD_INT 2
76110: NEG
76111: PUSH
76112: LD_INT 2
76114: NEG
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: LIST
76124: LIST
76125: LIST
76126: LIST
76127: LIST
76128: LIST
76129: LIST
76130: LIST
76131: LIST
76132: LIST
76133: LIST
76134: LIST
76135: LIST
76136: LIST
76137: LIST
76138: LIST
76139: LIST
76140: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76141: LD_ADDR_VAR 0 59
76145: PUSH
76146: LD_INT 0
76148: PUSH
76149: LD_INT 0
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 0
76158: PUSH
76159: LD_INT 1
76161: NEG
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: LD_INT 1
76169: PUSH
76170: LD_INT 0
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 1
76179: PUSH
76180: LD_INT 1
76182: PUSH
76183: EMPTY
76184: LIST
76185: LIST
76186: PUSH
76187: LD_INT 0
76189: PUSH
76190: LD_INT 1
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: LD_INT 1
76199: NEG
76200: PUSH
76201: LD_INT 0
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: LD_INT 1
76210: NEG
76211: PUSH
76212: LD_INT 1
76214: NEG
76215: PUSH
76216: EMPTY
76217: LIST
76218: LIST
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: LIST
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76229: LD_ADDR_VAR 0 60
76233: PUSH
76234: LD_INT 0
76236: PUSH
76237: LD_INT 0
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 0
76246: PUSH
76247: LD_INT 1
76249: NEG
76250: PUSH
76251: EMPTY
76252: LIST
76253: LIST
76254: PUSH
76255: LD_INT 1
76257: PUSH
76258: LD_INT 0
76260: PUSH
76261: EMPTY
76262: LIST
76263: LIST
76264: PUSH
76265: LD_INT 1
76267: PUSH
76268: LD_INT 1
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: PUSH
76275: LD_INT 0
76277: PUSH
76278: LD_INT 1
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 1
76287: NEG
76288: PUSH
76289: LD_INT 0
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 1
76298: NEG
76299: PUSH
76300: LD_INT 1
76302: NEG
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: EMPTY
76309: LIST
76310: LIST
76311: LIST
76312: LIST
76313: LIST
76314: LIST
76315: LIST
76316: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76317: LD_ADDR_VAR 0 61
76321: PUSH
76322: LD_INT 0
76324: PUSH
76325: LD_INT 0
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: PUSH
76332: LD_INT 0
76334: PUSH
76335: LD_INT 1
76337: NEG
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 1
76345: PUSH
76346: LD_INT 0
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 1
76355: PUSH
76356: LD_INT 1
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: LD_INT 0
76365: PUSH
76366: LD_INT 1
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 1
76375: NEG
76376: PUSH
76377: LD_INT 0
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: LD_INT 1
76386: NEG
76387: PUSH
76388: LD_INT 1
76390: NEG
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: LIST
76400: LIST
76401: LIST
76402: LIST
76403: LIST
76404: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76405: LD_ADDR_VAR 0 62
76409: PUSH
76410: LD_INT 0
76412: PUSH
76413: LD_INT 0
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 0
76422: PUSH
76423: LD_INT 1
76425: NEG
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PUSH
76431: LD_INT 1
76433: PUSH
76434: LD_INT 0
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PUSH
76441: LD_INT 1
76443: PUSH
76444: LD_INT 1
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: PUSH
76451: LD_INT 0
76453: PUSH
76454: LD_INT 1
76456: PUSH
76457: EMPTY
76458: LIST
76459: LIST
76460: PUSH
76461: LD_INT 1
76463: NEG
76464: PUSH
76465: LD_INT 0
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: PUSH
76472: LD_INT 1
76474: NEG
76475: PUSH
76476: LD_INT 1
76478: NEG
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PUSH
76484: EMPTY
76485: LIST
76486: LIST
76487: LIST
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76493: LD_ADDR_VAR 0 63
76497: PUSH
76498: LD_INT 0
76500: PUSH
76501: LD_INT 0
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 0
76510: PUSH
76511: LD_INT 1
76513: NEG
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: LD_INT 1
76521: PUSH
76522: LD_INT 0
76524: PUSH
76525: EMPTY
76526: LIST
76527: LIST
76528: PUSH
76529: LD_INT 1
76531: PUSH
76532: LD_INT 1
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: LD_INT 0
76541: PUSH
76542: LD_INT 1
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: LD_INT 1
76551: NEG
76552: PUSH
76553: LD_INT 0
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: LD_INT 1
76562: NEG
76563: PUSH
76564: LD_INT 1
76566: NEG
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: LIST
76576: LIST
76577: LIST
76578: LIST
76579: LIST
76580: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76581: LD_ADDR_VAR 0 64
76585: PUSH
76586: LD_INT 0
76588: PUSH
76589: LD_INT 0
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: LD_INT 0
76598: PUSH
76599: LD_INT 1
76601: NEG
76602: PUSH
76603: EMPTY
76604: LIST
76605: LIST
76606: PUSH
76607: LD_INT 1
76609: PUSH
76610: LD_INT 0
76612: PUSH
76613: EMPTY
76614: LIST
76615: LIST
76616: PUSH
76617: LD_INT 1
76619: PUSH
76620: LD_INT 1
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: PUSH
76627: LD_INT 0
76629: PUSH
76630: LD_INT 1
76632: PUSH
76633: EMPTY
76634: LIST
76635: LIST
76636: PUSH
76637: LD_INT 1
76639: NEG
76640: PUSH
76641: LD_INT 0
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: PUSH
76648: LD_INT 1
76650: NEG
76651: PUSH
76652: LD_INT 1
76654: NEG
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: ST_TO_ADDR
// end ; 1 :
76669: GO 82566
76671: LD_INT 1
76673: DOUBLE
76674: EQUAL
76675: IFTRUE 76679
76677: GO 79302
76679: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76680: LD_ADDR_VAR 0 11
76684: PUSH
76685: LD_INT 1
76687: NEG
76688: PUSH
76689: LD_INT 3
76691: NEG
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 0
76699: PUSH
76700: LD_INT 3
76702: NEG
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 1
76710: PUSH
76711: LD_INT 2
76713: NEG
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: EMPTY
76720: LIST
76721: LIST
76722: LIST
76723: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76724: LD_ADDR_VAR 0 12
76728: PUSH
76729: LD_INT 2
76731: PUSH
76732: LD_INT 1
76734: NEG
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: PUSH
76740: LD_INT 3
76742: PUSH
76743: LD_INT 0
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: PUSH
76750: LD_INT 3
76752: PUSH
76753: LD_INT 1
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: LIST
76764: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76765: LD_ADDR_VAR 0 13
76769: PUSH
76770: LD_INT 3
76772: PUSH
76773: LD_INT 2
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 3
76782: PUSH
76783: LD_INT 3
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: PUSH
76790: LD_INT 2
76792: PUSH
76793: LD_INT 3
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: LIST
76804: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76805: LD_ADDR_VAR 0 14
76809: PUSH
76810: LD_INT 1
76812: PUSH
76813: LD_INT 3
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: LD_INT 0
76822: PUSH
76823: LD_INT 3
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: PUSH
76830: LD_INT 1
76832: NEG
76833: PUSH
76834: LD_INT 2
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: LIST
76845: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76846: LD_ADDR_VAR 0 15
76850: PUSH
76851: LD_INT 2
76853: NEG
76854: PUSH
76855: LD_INT 1
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: PUSH
76862: LD_INT 3
76864: NEG
76865: PUSH
76866: LD_INT 0
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 3
76875: NEG
76876: PUSH
76877: LD_INT 1
76879: NEG
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: LIST
76889: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76890: LD_ADDR_VAR 0 16
76894: PUSH
76895: LD_INT 2
76897: NEG
76898: PUSH
76899: LD_INT 3
76901: NEG
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 3
76909: NEG
76910: PUSH
76911: LD_INT 2
76913: NEG
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: LD_INT 3
76921: NEG
76922: PUSH
76923: LD_INT 3
76925: NEG
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: LIST
76935: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76936: LD_ADDR_VAR 0 17
76940: PUSH
76941: LD_INT 1
76943: NEG
76944: PUSH
76945: LD_INT 3
76947: NEG
76948: PUSH
76949: EMPTY
76950: LIST
76951: LIST
76952: PUSH
76953: LD_INT 0
76955: PUSH
76956: LD_INT 3
76958: NEG
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: PUSH
76964: LD_INT 1
76966: PUSH
76967: LD_INT 2
76969: NEG
76970: PUSH
76971: EMPTY
76972: LIST
76973: LIST
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: LIST
76979: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76980: LD_ADDR_VAR 0 18
76984: PUSH
76985: LD_INT 2
76987: PUSH
76988: LD_INT 1
76990: NEG
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PUSH
76996: LD_INT 3
76998: PUSH
76999: LD_INT 0
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: PUSH
77006: LD_INT 3
77008: PUSH
77009: LD_INT 1
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PUSH
77016: EMPTY
77017: LIST
77018: LIST
77019: LIST
77020: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77021: LD_ADDR_VAR 0 19
77025: PUSH
77026: LD_INT 3
77028: PUSH
77029: LD_INT 2
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 3
77038: PUSH
77039: LD_INT 3
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: LD_INT 3
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: LIST
77060: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77061: LD_ADDR_VAR 0 20
77065: PUSH
77066: LD_INT 1
77068: PUSH
77069: LD_INT 3
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PUSH
77076: LD_INT 0
77078: PUSH
77079: LD_INT 3
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PUSH
77086: LD_INT 1
77088: NEG
77089: PUSH
77090: LD_INT 2
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: LIST
77101: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77102: LD_ADDR_VAR 0 21
77106: PUSH
77107: LD_INT 2
77109: NEG
77110: PUSH
77111: LD_INT 1
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: LD_INT 3
77120: NEG
77121: PUSH
77122: LD_INT 0
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: LD_INT 3
77131: NEG
77132: PUSH
77133: LD_INT 1
77135: NEG
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: LIST
77145: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77146: LD_ADDR_VAR 0 22
77150: PUSH
77151: LD_INT 2
77153: NEG
77154: PUSH
77155: LD_INT 3
77157: NEG
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: LD_INT 3
77165: NEG
77166: PUSH
77167: LD_INT 2
77169: NEG
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: PUSH
77175: LD_INT 3
77177: NEG
77178: PUSH
77179: LD_INT 3
77181: NEG
77182: PUSH
77183: EMPTY
77184: LIST
77185: LIST
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: LIST
77191: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77192: LD_ADDR_VAR 0 23
77196: PUSH
77197: LD_INT 0
77199: PUSH
77200: LD_INT 3
77202: NEG
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: PUSH
77208: LD_INT 1
77210: NEG
77211: PUSH
77212: LD_INT 4
77214: NEG
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: PUSH
77220: LD_INT 1
77222: PUSH
77223: LD_INT 3
77225: NEG
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: LIST
77235: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
77236: LD_ADDR_VAR 0 24
77240: PUSH
77241: LD_INT 3
77243: PUSH
77244: LD_INT 0
77246: PUSH
77247: EMPTY
77248: LIST
77249: LIST
77250: PUSH
77251: LD_INT 3
77253: PUSH
77254: LD_INT 1
77256: NEG
77257: PUSH
77258: EMPTY
77259: LIST
77260: LIST
77261: PUSH
77262: LD_INT 4
77264: PUSH
77265: LD_INT 1
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: LIST
77276: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
77277: LD_ADDR_VAR 0 25
77281: PUSH
77282: LD_INT 3
77284: PUSH
77285: LD_INT 3
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: PUSH
77292: LD_INT 4
77294: PUSH
77295: LD_INT 3
77297: PUSH
77298: EMPTY
77299: LIST
77300: LIST
77301: PUSH
77302: LD_INT 3
77304: PUSH
77305: LD_INT 4
77307: PUSH
77308: EMPTY
77309: LIST
77310: LIST
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: LIST
77316: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
77317: LD_ADDR_VAR 0 26
77321: PUSH
77322: LD_INT 0
77324: PUSH
77325: LD_INT 3
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: LD_INT 1
77334: PUSH
77335: LD_INT 4
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: LD_INT 1
77344: NEG
77345: PUSH
77346: LD_INT 3
77348: PUSH
77349: EMPTY
77350: LIST
77351: LIST
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: LIST
77357: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
77358: LD_ADDR_VAR 0 27
77362: PUSH
77363: LD_INT 3
77365: NEG
77366: PUSH
77367: LD_INT 0
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 3
77376: NEG
77377: PUSH
77378: LD_INT 1
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PUSH
77385: LD_INT 4
77387: NEG
77388: PUSH
77389: LD_INT 1
77391: NEG
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: LIST
77401: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77402: LD_ADDR_VAR 0 28
77406: PUSH
77407: LD_INT 3
77409: NEG
77410: PUSH
77411: LD_INT 3
77413: NEG
77414: PUSH
77415: EMPTY
77416: LIST
77417: LIST
77418: PUSH
77419: LD_INT 3
77421: NEG
77422: PUSH
77423: LD_INT 4
77425: NEG
77426: PUSH
77427: EMPTY
77428: LIST
77429: LIST
77430: PUSH
77431: LD_INT 4
77433: NEG
77434: PUSH
77435: LD_INT 3
77437: NEG
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: LIST
77447: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77448: LD_ADDR_VAR 0 29
77452: PUSH
77453: LD_INT 1
77455: NEG
77456: PUSH
77457: LD_INT 3
77459: NEG
77460: PUSH
77461: EMPTY
77462: LIST
77463: LIST
77464: PUSH
77465: LD_INT 0
77467: PUSH
77468: LD_INT 3
77470: NEG
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PUSH
77476: LD_INT 1
77478: PUSH
77479: LD_INT 2
77481: NEG
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: PUSH
77487: LD_INT 1
77489: NEG
77490: PUSH
77491: LD_INT 4
77493: NEG
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 0
77501: PUSH
77502: LD_INT 4
77504: NEG
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: PUSH
77510: LD_INT 1
77512: PUSH
77513: LD_INT 3
77515: NEG
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: PUSH
77521: LD_INT 1
77523: NEG
77524: PUSH
77525: LD_INT 5
77527: NEG
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: PUSH
77533: LD_INT 0
77535: PUSH
77536: LD_INT 5
77538: NEG
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: LD_INT 1
77546: PUSH
77547: LD_INT 4
77549: NEG
77550: PUSH
77551: EMPTY
77552: LIST
77553: LIST
77554: PUSH
77555: LD_INT 1
77557: NEG
77558: PUSH
77559: LD_INT 6
77561: NEG
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PUSH
77567: LD_INT 0
77569: PUSH
77570: LD_INT 6
77572: NEG
77573: PUSH
77574: EMPTY
77575: LIST
77576: LIST
77577: PUSH
77578: LD_INT 1
77580: PUSH
77581: LD_INT 5
77583: NEG
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: LIST
77593: LIST
77594: LIST
77595: LIST
77596: LIST
77597: LIST
77598: LIST
77599: LIST
77600: LIST
77601: LIST
77602: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77603: LD_ADDR_VAR 0 30
77607: PUSH
77608: LD_INT 2
77610: PUSH
77611: LD_INT 1
77613: NEG
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: PUSH
77619: LD_INT 3
77621: PUSH
77622: LD_INT 0
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: PUSH
77629: LD_INT 3
77631: PUSH
77632: LD_INT 1
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: PUSH
77639: LD_INT 3
77641: PUSH
77642: LD_INT 1
77644: NEG
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 4
77652: PUSH
77653: LD_INT 0
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 4
77662: PUSH
77663: LD_INT 1
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: LD_INT 4
77672: PUSH
77673: LD_INT 1
77675: NEG
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: PUSH
77681: LD_INT 5
77683: PUSH
77684: LD_INT 0
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: PUSH
77691: LD_INT 5
77693: PUSH
77694: LD_INT 1
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: PUSH
77701: LD_INT 5
77703: PUSH
77704: LD_INT 1
77706: NEG
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: LD_INT 6
77714: PUSH
77715: LD_INT 0
77717: PUSH
77718: EMPTY
77719: LIST
77720: LIST
77721: PUSH
77722: LD_INT 6
77724: PUSH
77725: LD_INT 1
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: LIST
77744: LIST
77745: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
77746: LD_ADDR_VAR 0 31
77750: PUSH
77751: LD_INT 3
77753: PUSH
77754: LD_INT 2
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PUSH
77761: LD_INT 3
77763: PUSH
77764: LD_INT 3
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: PUSH
77771: LD_INT 2
77773: PUSH
77774: LD_INT 3
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: PUSH
77781: LD_INT 4
77783: PUSH
77784: LD_INT 3
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: PUSH
77791: LD_INT 4
77793: PUSH
77794: LD_INT 4
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 3
77803: PUSH
77804: LD_INT 4
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: LD_INT 5
77813: PUSH
77814: LD_INT 4
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: PUSH
77821: LD_INT 5
77823: PUSH
77824: LD_INT 5
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 4
77833: PUSH
77834: LD_INT 5
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 6
77843: PUSH
77844: LD_INT 5
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: LD_INT 6
77853: PUSH
77854: LD_INT 6
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: LD_INT 5
77863: PUSH
77864: LD_INT 6
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: LIST
77875: LIST
77876: LIST
77877: LIST
77878: LIST
77879: LIST
77880: LIST
77881: LIST
77882: LIST
77883: LIST
77884: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
77885: LD_ADDR_VAR 0 32
77889: PUSH
77890: LD_INT 1
77892: PUSH
77893: LD_INT 3
77895: PUSH
77896: EMPTY
77897: LIST
77898: LIST
77899: PUSH
77900: LD_INT 0
77902: PUSH
77903: LD_INT 3
77905: PUSH
77906: EMPTY
77907: LIST
77908: LIST
77909: PUSH
77910: LD_INT 1
77912: NEG
77913: PUSH
77914: LD_INT 2
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 1
77923: PUSH
77924: LD_INT 4
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: LD_INT 0
77933: PUSH
77934: LD_INT 4
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 1
77943: NEG
77944: PUSH
77945: LD_INT 3
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 1
77954: PUSH
77955: LD_INT 5
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 0
77964: PUSH
77965: LD_INT 5
77967: PUSH
77968: EMPTY
77969: LIST
77970: LIST
77971: PUSH
77972: LD_INT 1
77974: NEG
77975: PUSH
77976: LD_INT 4
77978: PUSH
77979: EMPTY
77980: LIST
77981: LIST
77982: PUSH
77983: LD_INT 1
77985: PUSH
77986: LD_INT 6
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: PUSH
77993: LD_INT 0
77995: PUSH
77996: LD_INT 6
77998: PUSH
77999: EMPTY
78000: LIST
78001: LIST
78002: PUSH
78003: LD_INT 1
78005: NEG
78006: PUSH
78007: LD_INT 5
78009: PUSH
78010: EMPTY
78011: LIST
78012: LIST
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: LIST
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: LIST
78027: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78028: LD_ADDR_VAR 0 33
78032: PUSH
78033: LD_INT 2
78035: NEG
78036: PUSH
78037: LD_INT 1
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 3
78046: NEG
78047: PUSH
78048: LD_INT 0
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: PUSH
78055: LD_INT 3
78057: NEG
78058: PUSH
78059: LD_INT 1
78061: NEG
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 3
78069: NEG
78070: PUSH
78071: LD_INT 1
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 4
78080: NEG
78081: PUSH
78082: LD_INT 0
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PUSH
78089: LD_INT 4
78091: NEG
78092: PUSH
78093: LD_INT 1
78095: NEG
78096: PUSH
78097: EMPTY
78098: LIST
78099: LIST
78100: PUSH
78101: LD_INT 4
78103: NEG
78104: PUSH
78105: LD_INT 1
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PUSH
78112: LD_INT 5
78114: NEG
78115: PUSH
78116: LD_INT 0
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 5
78125: NEG
78126: PUSH
78127: LD_INT 1
78129: NEG
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: PUSH
78135: LD_INT 5
78137: NEG
78138: PUSH
78139: LD_INT 1
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: PUSH
78146: LD_INT 6
78148: NEG
78149: PUSH
78150: LD_INT 0
78152: PUSH
78153: EMPTY
78154: LIST
78155: LIST
78156: PUSH
78157: LD_INT 6
78159: NEG
78160: PUSH
78161: LD_INT 1
78163: NEG
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: LIST
78173: LIST
78174: LIST
78175: LIST
78176: LIST
78177: LIST
78178: LIST
78179: LIST
78180: LIST
78181: LIST
78182: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78183: LD_ADDR_VAR 0 34
78187: PUSH
78188: LD_INT 2
78190: NEG
78191: PUSH
78192: LD_INT 3
78194: NEG
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 3
78202: NEG
78203: PUSH
78204: LD_INT 2
78206: NEG
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: LD_INT 3
78214: NEG
78215: PUSH
78216: LD_INT 3
78218: NEG
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: LD_INT 3
78226: NEG
78227: PUSH
78228: LD_INT 4
78230: NEG
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 4
78238: NEG
78239: PUSH
78240: LD_INT 3
78242: NEG
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: PUSH
78248: LD_INT 4
78250: NEG
78251: PUSH
78252: LD_INT 4
78254: NEG
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 4
78262: NEG
78263: PUSH
78264: LD_INT 5
78266: NEG
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: LD_INT 5
78274: NEG
78275: PUSH
78276: LD_INT 4
78278: NEG
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: LD_INT 5
78286: NEG
78287: PUSH
78288: LD_INT 5
78290: NEG
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: LD_INT 5
78298: NEG
78299: PUSH
78300: LD_INT 6
78302: NEG
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: LD_INT 6
78310: NEG
78311: PUSH
78312: LD_INT 5
78314: NEG
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: PUSH
78320: LD_INT 6
78322: NEG
78323: PUSH
78324: LD_INT 6
78326: NEG
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: LIST
78336: LIST
78337: LIST
78338: LIST
78339: LIST
78340: LIST
78341: LIST
78342: LIST
78343: LIST
78344: LIST
78345: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
78346: LD_ADDR_VAR 0 41
78350: PUSH
78351: LD_INT 0
78353: PUSH
78354: LD_INT 2
78356: NEG
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: LD_INT 1
78364: NEG
78365: PUSH
78366: LD_INT 3
78368: NEG
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 1
78376: PUSH
78377: LD_INT 2
78379: NEG
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: LIST
78389: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
78390: LD_ADDR_VAR 0 42
78394: PUSH
78395: LD_INT 2
78397: PUSH
78398: LD_INT 0
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: PUSH
78405: LD_INT 2
78407: PUSH
78408: LD_INT 1
78410: NEG
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PUSH
78416: LD_INT 3
78418: PUSH
78419: LD_INT 1
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: LIST
78430: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78431: LD_ADDR_VAR 0 43
78435: PUSH
78436: LD_INT 2
78438: PUSH
78439: LD_INT 2
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 3
78448: PUSH
78449: LD_INT 2
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 2
78458: PUSH
78459: LD_INT 3
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: LIST
78470: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78471: LD_ADDR_VAR 0 44
78475: PUSH
78476: LD_INT 0
78478: PUSH
78479: LD_INT 2
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 1
78488: PUSH
78489: LD_INT 3
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 1
78498: NEG
78499: PUSH
78500: LD_INT 2
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: EMPTY
78508: LIST
78509: LIST
78510: LIST
78511: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78512: LD_ADDR_VAR 0 45
78516: PUSH
78517: LD_INT 2
78519: NEG
78520: PUSH
78521: LD_INT 0
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: PUSH
78528: LD_INT 2
78530: NEG
78531: PUSH
78532: LD_INT 1
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: LD_INT 3
78541: NEG
78542: PUSH
78543: LD_INT 1
78545: NEG
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: EMPTY
78552: LIST
78553: LIST
78554: LIST
78555: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78556: LD_ADDR_VAR 0 46
78560: PUSH
78561: LD_INT 2
78563: NEG
78564: PUSH
78565: LD_INT 2
78567: NEG
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: LD_INT 2
78575: NEG
78576: PUSH
78577: LD_INT 3
78579: NEG
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 3
78587: NEG
78588: PUSH
78589: LD_INT 2
78591: NEG
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: LIST
78601: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78602: LD_ADDR_VAR 0 47
78606: PUSH
78607: LD_INT 2
78609: NEG
78610: PUSH
78611: LD_INT 3
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 1
78621: NEG
78622: PUSH
78623: LD_INT 3
78625: NEG
78626: PUSH
78627: EMPTY
78628: LIST
78629: LIST
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78635: LD_ADDR_VAR 0 48
78639: PUSH
78640: LD_INT 1
78642: PUSH
78643: LD_INT 2
78645: NEG
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: LD_INT 2
78653: PUSH
78654: LD_INT 1
78656: NEG
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: PUSH
78662: EMPTY
78663: LIST
78664: LIST
78665: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
78666: LD_ADDR_VAR 0 49
78670: PUSH
78671: LD_INT 3
78673: PUSH
78674: LD_INT 1
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 3
78683: PUSH
78684: LD_INT 2
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
78695: LD_ADDR_VAR 0 50
78699: PUSH
78700: LD_INT 2
78702: PUSH
78703: LD_INT 3
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 1
78712: PUSH
78713: LD_INT 3
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78724: LD_ADDR_VAR 0 51
78728: PUSH
78729: LD_INT 1
78731: NEG
78732: PUSH
78733: LD_INT 2
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 2
78742: NEG
78743: PUSH
78744: LD_INT 1
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78755: LD_ADDR_VAR 0 52
78759: PUSH
78760: LD_INT 3
78762: NEG
78763: PUSH
78764: LD_INT 1
78766: NEG
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 3
78774: NEG
78775: PUSH
78776: LD_INT 2
78778: NEG
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78788: LD_ADDR_VAR 0 53
78792: PUSH
78793: LD_INT 1
78795: NEG
78796: PUSH
78797: LD_INT 3
78799: NEG
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: PUSH
78805: LD_INT 0
78807: PUSH
78808: LD_INT 3
78810: NEG
78811: PUSH
78812: EMPTY
78813: LIST
78814: LIST
78815: PUSH
78816: LD_INT 1
78818: PUSH
78819: LD_INT 2
78821: NEG
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: LIST
78831: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78832: LD_ADDR_VAR 0 54
78836: PUSH
78837: LD_INT 2
78839: PUSH
78840: LD_INT 1
78842: NEG
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 3
78850: PUSH
78851: LD_INT 0
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 3
78860: PUSH
78861: LD_INT 1
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: LIST
78872: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78873: LD_ADDR_VAR 0 55
78877: PUSH
78878: LD_INT 3
78880: PUSH
78881: LD_INT 2
78883: PUSH
78884: EMPTY
78885: LIST
78886: LIST
78887: PUSH
78888: LD_INT 3
78890: PUSH
78891: LD_INT 3
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: PUSH
78898: LD_INT 2
78900: PUSH
78901: LD_INT 3
78903: PUSH
78904: EMPTY
78905: LIST
78906: LIST
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: LIST
78912: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78913: LD_ADDR_VAR 0 56
78917: PUSH
78918: LD_INT 1
78920: PUSH
78921: LD_INT 3
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: PUSH
78928: LD_INT 0
78930: PUSH
78931: LD_INT 3
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: LD_INT 1
78940: NEG
78941: PUSH
78942: LD_INT 2
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: LIST
78953: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78954: LD_ADDR_VAR 0 57
78958: PUSH
78959: LD_INT 2
78961: NEG
78962: PUSH
78963: LD_INT 1
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 3
78972: NEG
78973: PUSH
78974: LD_INT 0
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 3
78983: NEG
78984: PUSH
78985: LD_INT 1
78987: NEG
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: LIST
78997: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78998: LD_ADDR_VAR 0 58
79002: PUSH
79003: LD_INT 2
79005: NEG
79006: PUSH
79007: LD_INT 3
79009: NEG
79010: PUSH
79011: EMPTY
79012: LIST
79013: LIST
79014: PUSH
79015: LD_INT 3
79017: NEG
79018: PUSH
79019: LD_INT 2
79021: NEG
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 3
79029: NEG
79030: PUSH
79031: LD_INT 3
79033: NEG
79034: PUSH
79035: EMPTY
79036: LIST
79037: LIST
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: LIST
79043: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79044: LD_ADDR_VAR 0 59
79048: PUSH
79049: LD_INT 1
79051: NEG
79052: PUSH
79053: LD_INT 2
79055: NEG
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: LD_INT 0
79063: PUSH
79064: LD_INT 2
79066: NEG
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 1
79074: PUSH
79075: LD_INT 1
79077: NEG
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: LIST
79087: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79088: LD_ADDR_VAR 0 60
79092: PUSH
79093: LD_INT 1
79095: PUSH
79096: LD_INT 1
79098: NEG
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 2
79106: PUSH
79107: LD_INT 0
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 2
79116: PUSH
79117: LD_INT 1
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: LIST
79128: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79129: LD_ADDR_VAR 0 61
79133: PUSH
79134: LD_INT 2
79136: PUSH
79137: LD_INT 1
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 2
79146: PUSH
79147: LD_INT 2
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: LD_INT 1
79156: PUSH
79157: LD_INT 2
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: EMPTY
79165: LIST
79166: LIST
79167: LIST
79168: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79169: LD_ADDR_VAR 0 62
79173: PUSH
79174: LD_INT 1
79176: PUSH
79177: LD_INT 2
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 0
79186: PUSH
79187: LD_INT 2
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 1
79196: NEG
79197: PUSH
79198: LD_INT 1
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: LIST
79209: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79210: LD_ADDR_VAR 0 63
79214: PUSH
79215: LD_INT 1
79217: NEG
79218: PUSH
79219: LD_INT 1
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 2
79228: NEG
79229: PUSH
79230: LD_INT 0
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 2
79239: NEG
79240: PUSH
79241: LD_INT 1
79243: NEG
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: LIST
79253: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79254: LD_ADDR_VAR 0 64
79258: PUSH
79259: LD_INT 1
79261: NEG
79262: PUSH
79263: LD_INT 2
79265: NEG
79266: PUSH
79267: EMPTY
79268: LIST
79269: LIST
79270: PUSH
79271: LD_INT 2
79273: NEG
79274: PUSH
79275: LD_INT 1
79277: NEG
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 2
79285: NEG
79286: PUSH
79287: LD_INT 2
79289: NEG
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: LIST
79299: ST_TO_ADDR
// end ; 2 :
79300: GO 82566
79302: LD_INT 2
79304: DOUBLE
79305: EQUAL
79306: IFTRUE 79310
79308: GO 82565
79310: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
79311: LD_ADDR_VAR 0 29
79315: PUSH
79316: LD_INT 4
79318: PUSH
79319: LD_INT 0
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: LD_INT 4
79328: PUSH
79329: LD_INT 1
79331: NEG
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 5
79339: PUSH
79340: LD_INT 0
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 5
79349: PUSH
79350: LD_INT 1
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 4
79359: PUSH
79360: LD_INT 1
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 3
79369: PUSH
79370: LD_INT 0
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: PUSH
79377: LD_INT 3
79379: PUSH
79380: LD_INT 1
79382: NEG
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 3
79390: PUSH
79391: LD_INT 2
79393: NEG
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 5
79401: PUSH
79402: LD_INT 2
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 3
79411: PUSH
79412: LD_INT 3
79414: PUSH
79415: EMPTY
79416: LIST
79417: LIST
79418: PUSH
79419: LD_INT 3
79421: PUSH
79422: LD_INT 2
79424: PUSH
79425: EMPTY
79426: LIST
79427: LIST
79428: PUSH
79429: LD_INT 4
79431: PUSH
79432: LD_INT 3
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 4
79441: PUSH
79442: LD_INT 4
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 3
79451: PUSH
79452: LD_INT 4
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 2
79461: PUSH
79462: LD_INT 3
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 2
79471: PUSH
79472: LD_INT 2
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 4
79481: PUSH
79482: LD_INT 2
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 2
79491: PUSH
79492: LD_INT 4
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 0
79501: PUSH
79502: LD_INT 4
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: LD_INT 0
79511: PUSH
79512: LD_INT 3
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: PUSH
79519: LD_INT 1
79521: PUSH
79522: LD_INT 4
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 1
79531: PUSH
79532: LD_INT 5
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 0
79541: PUSH
79542: LD_INT 5
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 1
79551: NEG
79552: PUSH
79553: LD_INT 4
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 1
79562: NEG
79563: PUSH
79564: LD_INT 3
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 2
79573: PUSH
79574: LD_INT 5
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: LD_INT 2
79583: NEG
79584: PUSH
79585: LD_INT 3
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: LD_INT 3
79594: NEG
79595: PUSH
79596: LD_INT 0
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: PUSH
79603: LD_INT 3
79605: NEG
79606: PUSH
79607: LD_INT 1
79609: NEG
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: PUSH
79615: LD_INT 2
79617: NEG
79618: PUSH
79619: LD_INT 0
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 2
79628: NEG
79629: PUSH
79630: LD_INT 1
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 3
79639: NEG
79640: PUSH
79641: LD_INT 1
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 4
79650: NEG
79651: PUSH
79652: LD_INT 0
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 4
79661: NEG
79662: PUSH
79663: LD_INT 1
79665: NEG
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 4
79673: NEG
79674: PUSH
79675: LD_INT 2
79677: NEG
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 2
79685: NEG
79686: PUSH
79687: LD_INT 2
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: LD_INT 4
79696: NEG
79697: PUSH
79698: LD_INT 4
79700: NEG
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 4
79708: NEG
79709: PUSH
79710: LD_INT 5
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 3
79720: NEG
79721: PUSH
79722: LD_INT 4
79724: NEG
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 3
79732: NEG
79733: PUSH
79734: LD_INT 3
79736: NEG
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 4
79744: NEG
79745: PUSH
79746: LD_INT 3
79748: NEG
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 5
79756: NEG
79757: PUSH
79758: LD_INT 4
79760: NEG
79761: PUSH
79762: EMPTY
79763: LIST
79764: LIST
79765: PUSH
79766: LD_INT 5
79768: NEG
79769: PUSH
79770: LD_INT 5
79772: NEG
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 3
79780: NEG
79781: PUSH
79782: LD_INT 5
79784: NEG
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: LD_INT 5
79792: NEG
79793: PUSH
79794: LD_INT 3
79796: NEG
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: LIST
79806: LIST
79807: LIST
79808: LIST
79809: LIST
79810: LIST
79811: LIST
79812: LIST
79813: LIST
79814: LIST
79815: LIST
79816: LIST
79817: LIST
79818: LIST
79819: LIST
79820: LIST
79821: LIST
79822: LIST
79823: LIST
79824: LIST
79825: LIST
79826: LIST
79827: LIST
79828: LIST
79829: LIST
79830: LIST
79831: LIST
79832: LIST
79833: LIST
79834: LIST
79835: LIST
79836: LIST
79837: LIST
79838: LIST
79839: LIST
79840: LIST
79841: LIST
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
79849: LD_ADDR_VAR 0 30
79853: PUSH
79854: LD_INT 4
79856: PUSH
79857: LD_INT 4
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: LD_INT 4
79866: PUSH
79867: LD_INT 3
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 5
79876: PUSH
79877: LD_INT 4
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 5
79886: PUSH
79887: LD_INT 5
79889: PUSH
79890: EMPTY
79891: LIST
79892: LIST
79893: PUSH
79894: LD_INT 4
79896: PUSH
79897: LD_INT 5
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: LD_INT 3
79906: PUSH
79907: LD_INT 4
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: PUSH
79914: LD_INT 3
79916: PUSH
79917: LD_INT 3
79919: PUSH
79920: EMPTY
79921: LIST
79922: LIST
79923: PUSH
79924: LD_INT 5
79926: PUSH
79927: LD_INT 3
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PUSH
79934: LD_INT 3
79936: PUSH
79937: LD_INT 5
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 0
79946: PUSH
79947: LD_INT 3
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: LD_INT 0
79956: PUSH
79957: LD_INT 2
79959: PUSH
79960: EMPTY
79961: LIST
79962: LIST
79963: PUSH
79964: LD_INT 1
79966: PUSH
79967: LD_INT 3
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 1
79976: PUSH
79977: LD_INT 4
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 0
79986: PUSH
79987: LD_INT 4
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: PUSH
79994: LD_INT 1
79996: NEG
79997: PUSH
79998: LD_INT 3
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 1
80007: NEG
80008: PUSH
80009: LD_INT 2
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 2
80018: PUSH
80019: LD_INT 4
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 2
80028: NEG
80029: PUSH
80030: LD_INT 2
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 4
80039: NEG
80040: PUSH
80041: LD_INT 0
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 4
80050: NEG
80051: PUSH
80052: LD_INT 1
80054: NEG
80055: PUSH
80056: EMPTY
80057: LIST
80058: LIST
80059: PUSH
80060: LD_INT 3
80062: NEG
80063: PUSH
80064: LD_INT 0
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 3
80073: NEG
80074: PUSH
80075: LD_INT 1
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: PUSH
80082: LD_INT 4
80084: NEG
80085: PUSH
80086: LD_INT 1
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PUSH
80093: LD_INT 5
80095: NEG
80096: PUSH
80097: LD_INT 0
80099: PUSH
80100: EMPTY
80101: LIST
80102: LIST
80103: PUSH
80104: LD_INT 5
80106: NEG
80107: PUSH
80108: LD_INT 1
80110: NEG
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 5
80118: NEG
80119: PUSH
80120: LD_INT 2
80122: NEG
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 3
80130: NEG
80131: PUSH
80132: LD_INT 2
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 3
80141: NEG
80142: PUSH
80143: LD_INT 3
80145: NEG
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: PUSH
80151: LD_INT 3
80153: NEG
80154: PUSH
80155: LD_INT 4
80157: NEG
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: PUSH
80163: LD_INT 2
80165: NEG
80166: PUSH
80167: LD_INT 3
80169: NEG
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: LD_INT 2
80177: NEG
80178: PUSH
80179: LD_INT 2
80181: NEG
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 3
80189: NEG
80190: PUSH
80191: LD_INT 2
80193: NEG
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PUSH
80199: LD_INT 4
80201: NEG
80202: PUSH
80203: LD_INT 3
80205: NEG
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: PUSH
80211: LD_INT 4
80213: NEG
80214: PUSH
80215: LD_INT 4
80217: NEG
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 2
80225: NEG
80226: PUSH
80227: LD_INT 4
80229: NEG
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 4
80237: NEG
80238: PUSH
80239: LD_INT 2
80241: NEG
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 0
80249: PUSH
80250: LD_INT 4
80252: NEG
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 0
80260: PUSH
80261: LD_INT 5
80263: NEG
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 1
80271: PUSH
80272: LD_INT 4
80274: NEG
80275: PUSH
80276: EMPTY
80277: LIST
80278: LIST
80279: PUSH
80280: LD_INT 1
80282: PUSH
80283: LD_INT 3
80285: NEG
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 0
80293: PUSH
80294: LD_INT 3
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 1
80304: NEG
80305: PUSH
80306: LD_INT 4
80308: NEG
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 1
80316: NEG
80317: PUSH
80318: LD_INT 5
80320: NEG
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: LD_INT 2
80328: PUSH
80329: LD_INT 3
80331: NEG
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: LD_INT 2
80339: NEG
80340: PUSH
80341: LD_INT 5
80343: NEG
80344: PUSH
80345: EMPTY
80346: LIST
80347: LIST
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80396: LD_ADDR_VAR 0 31
80400: PUSH
80401: LD_INT 0
80403: PUSH
80404: LD_INT 4
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 0
80413: PUSH
80414: LD_INT 3
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PUSH
80421: LD_INT 1
80423: PUSH
80424: LD_INT 4
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 1
80433: PUSH
80434: LD_INT 5
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: PUSH
80441: LD_INT 0
80443: PUSH
80444: LD_INT 5
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 1
80453: NEG
80454: PUSH
80455: LD_INT 4
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 1
80464: NEG
80465: PUSH
80466: LD_INT 3
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 2
80475: PUSH
80476: LD_INT 5
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: LD_INT 2
80485: NEG
80486: PUSH
80487: LD_INT 3
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: LD_INT 3
80496: NEG
80497: PUSH
80498: LD_INT 0
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 3
80507: NEG
80508: PUSH
80509: LD_INT 1
80511: NEG
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: LD_INT 2
80519: NEG
80520: PUSH
80521: LD_INT 0
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: LD_INT 2
80530: NEG
80531: PUSH
80532: LD_INT 1
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 3
80541: NEG
80542: PUSH
80543: LD_INT 1
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 4
80552: NEG
80553: PUSH
80554: LD_INT 0
80556: PUSH
80557: EMPTY
80558: LIST
80559: LIST
80560: PUSH
80561: LD_INT 4
80563: NEG
80564: PUSH
80565: LD_INT 1
80567: NEG
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: PUSH
80573: LD_INT 4
80575: NEG
80576: PUSH
80577: LD_INT 2
80579: NEG
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 2
80587: NEG
80588: PUSH
80589: LD_INT 2
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 4
80598: NEG
80599: PUSH
80600: LD_INT 4
80602: NEG
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 4
80610: NEG
80611: PUSH
80612: LD_INT 5
80614: NEG
80615: PUSH
80616: EMPTY
80617: LIST
80618: LIST
80619: PUSH
80620: LD_INT 3
80622: NEG
80623: PUSH
80624: LD_INT 4
80626: NEG
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 3
80634: NEG
80635: PUSH
80636: LD_INT 3
80638: NEG
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 4
80646: NEG
80647: PUSH
80648: LD_INT 3
80650: NEG
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 5
80658: NEG
80659: PUSH
80660: LD_INT 4
80662: NEG
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 5
80670: NEG
80671: PUSH
80672: LD_INT 5
80674: NEG
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 3
80682: NEG
80683: PUSH
80684: LD_INT 5
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 5
80694: NEG
80695: PUSH
80696: LD_INT 3
80698: NEG
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 0
80706: PUSH
80707: LD_INT 3
80709: NEG
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: LD_INT 0
80717: PUSH
80718: LD_INT 4
80720: NEG
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 1
80728: PUSH
80729: LD_INT 3
80731: NEG
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PUSH
80737: LD_INT 1
80739: PUSH
80740: LD_INT 2
80742: NEG
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 0
80750: PUSH
80751: LD_INT 2
80753: NEG
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 1
80761: NEG
80762: PUSH
80763: LD_INT 3
80765: NEG
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 1
80773: NEG
80774: PUSH
80775: LD_INT 4
80777: NEG
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: PUSH
80783: LD_INT 2
80785: PUSH
80786: LD_INT 2
80788: NEG
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: PUSH
80794: LD_INT 2
80796: NEG
80797: PUSH
80798: LD_INT 4
80800: NEG
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 4
80808: PUSH
80809: LD_INT 0
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 4
80818: PUSH
80819: LD_INT 1
80821: NEG
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 5
80829: PUSH
80830: LD_INT 0
80832: PUSH
80833: EMPTY
80834: LIST
80835: LIST
80836: PUSH
80837: LD_INT 5
80839: PUSH
80840: LD_INT 1
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 4
80849: PUSH
80850: LD_INT 1
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 3
80859: PUSH
80860: LD_INT 0
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 3
80869: PUSH
80870: LD_INT 1
80872: NEG
80873: PUSH
80874: EMPTY
80875: LIST
80876: LIST
80877: PUSH
80878: LD_INT 3
80880: PUSH
80881: LD_INT 2
80883: NEG
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 5
80891: PUSH
80892: LD_INT 2
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
80946: LD_ADDR_VAR 0 32
80950: PUSH
80951: LD_INT 4
80953: NEG
80954: PUSH
80955: LD_INT 0
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PUSH
80962: LD_INT 4
80964: NEG
80965: PUSH
80966: LD_INT 1
80968: NEG
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 3
80976: NEG
80977: PUSH
80978: LD_INT 0
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 3
80987: NEG
80988: PUSH
80989: LD_INT 1
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 4
80998: NEG
80999: PUSH
81000: LD_INT 1
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 5
81009: NEG
81010: PUSH
81011: LD_INT 0
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: PUSH
81018: LD_INT 5
81020: NEG
81021: PUSH
81022: LD_INT 1
81024: NEG
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 5
81032: NEG
81033: PUSH
81034: LD_INT 2
81036: NEG
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 3
81044: NEG
81045: PUSH
81046: LD_INT 2
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 3
81055: NEG
81056: PUSH
81057: LD_INT 3
81059: NEG
81060: PUSH
81061: EMPTY
81062: LIST
81063: LIST
81064: PUSH
81065: LD_INT 3
81067: NEG
81068: PUSH
81069: LD_INT 4
81071: NEG
81072: PUSH
81073: EMPTY
81074: LIST
81075: LIST
81076: PUSH
81077: LD_INT 2
81079: NEG
81080: PUSH
81081: LD_INT 3
81083: NEG
81084: PUSH
81085: EMPTY
81086: LIST
81087: LIST
81088: PUSH
81089: LD_INT 2
81091: NEG
81092: PUSH
81093: LD_INT 2
81095: NEG
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 3
81103: NEG
81104: PUSH
81105: LD_INT 2
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 4
81115: NEG
81116: PUSH
81117: LD_INT 3
81119: NEG
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: LD_INT 4
81127: NEG
81128: PUSH
81129: LD_INT 4
81131: NEG
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PUSH
81137: LD_INT 2
81139: NEG
81140: PUSH
81141: LD_INT 4
81143: NEG
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 4
81151: NEG
81152: PUSH
81153: LD_INT 2
81155: NEG
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 0
81163: PUSH
81164: LD_INT 4
81166: NEG
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: LD_INT 0
81174: PUSH
81175: LD_INT 5
81177: NEG
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PUSH
81183: LD_INT 1
81185: PUSH
81186: LD_INT 4
81188: NEG
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PUSH
81194: LD_INT 1
81196: PUSH
81197: LD_INT 3
81199: NEG
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 0
81207: PUSH
81208: LD_INT 3
81210: NEG
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 1
81218: NEG
81219: PUSH
81220: LD_INT 4
81222: NEG
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 1
81230: NEG
81231: PUSH
81232: LD_INT 5
81234: NEG
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 2
81242: PUSH
81243: LD_INT 3
81245: NEG
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: PUSH
81251: LD_INT 2
81253: NEG
81254: PUSH
81255: LD_INT 5
81257: NEG
81258: PUSH
81259: EMPTY
81260: LIST
81261: LIST
81262: PUSH
81263: LD_INT 3
81265: PUSH
81266: LD_INT 0
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 3
81275: PUSH
81276: LD_INT 1
81278: NEG
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 4
81286: PUSH
81287: LD_INT 0
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 4
81296: PUSH
81297: LD_INT 1
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 3
81306: PUSH
81307: LD_INT 1
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_INT 2
81316: PUSH
81317: LD_INT 0
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 2
81326: PUSH
81327: LD_INT 1
81329: NEG
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 2
81337: PUSH
81338: LD_INT 2
81340: NEG
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: LD_INT 4
81348: PUSH
81349: LD_INT 2
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 4
81358: PUSH
81359: LD_INT 4
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 4
81368: PUSH
81369: LD_INT 3
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: LD_INT 5
81378: PUSH
81379: LD_INT 4
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 5
81388: PUSH
81389: LD_INT 5
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 4
81398: PUSH
81399: LD_INT 5
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 3
81408: PUSH
81409: LD_INT 4
81411: PUSH
81412: EMPTY
81413: LIST
81414: LIST
81415: PUSH
81416: LD_INT 3
81418: PUSH
81419: LD_INT 3
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 5
81428: PUSH
81429: LD_INT 3
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: LD_INT 3
81438: PUSH
81439: LD_INT 5
81441: PUSH
81442: EMPTY
81443: LIST
81444: LIST
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81493: LD_ADDR_VAR 0 33
81497: PUSH
81498: LD_INT 4
81500: NEG
81501: PUSH
81502: LD_INT 4
81504: NEG
81505: PUSH
81506: EMPTY
81507: LIST
81508: LIST
81509: PUSH
81510: LD_INT 4
81512: NEG
81513: PUSH
81514: LD_INT 5
81516: NEG
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PUSH
81522: LD_INT 3
81524: NEG
81525: PUSH
81526: LD_INT 4
81528: NEG
81529: PUSH
81530: EMPTY
81531: LIST
81532: LIST
81533: PUSH
81534: LD_INT 3
81536: NEG
81537: PUSH
81538: LD_INT 3
81540: NEG
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: PUSH
81546: LD_INT 4
81548: NEG
81549: PUSH
81550: LD_INT 3
81552: NEG
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 5
81560: NEG
81561: PUSH
81562: LD_INT 4
81564: NEG
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: LD_INT 5
81572: NEG
81573: PUSH
81574: LD_INT 5
81576: NEG
81577: PUSH
81578: EMPTY
81579: LIST
81580: LIST
81581: PUSH
81582: LD_INT 3
81584: NEG
81585: PUSH
81586: LD_INT 5
81588: NEG
81589: PUSH
81590: EMPTY
81591: LIST
81592: LIST
81593: PUSH
81594: LD_INT 5
81596: NEG
81597: PUSH
81598: LD_INT 3
81600: NEG
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 0
81608: PUSH
81609: LD_INT 3
81611: NEG
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 0
81619: PUSH
81620: LD_INT 4
81622: NEG
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 1
81630: PUSH
81631: LD_INT 3
81633: NEG
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 1
81641: PUSH
81642: LD_INT 2
81644: NEG
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 0
81652: PUSH
81653: LD_INT 2
81655: NEG
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 1
81663: NEG
81664: PUSH
81665: LD_INT 3
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 1
81675: NEG
81676: PUSH
81677: LD_INT 4
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 2
81687: PUSH
81688: LD_INT 2
81690: NEG
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: LD_INT 2
81698: NEG
81699: PUSH
81700: LD_INT 4
81702: NEG
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 4
81710: PUSH
81711: LD_INT 0
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 4
81720: PUSH
81721: LD_INT 1
81723: NEG
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 5
81731: PUSH
81732: LD_INT 0
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 5
81741: PUSH
81742: LD_INT 1
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 4
81751: PUSH
81752: LD_INT 1
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 3
81761: PUSH
81762: LD_INT 0
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 3
81771: PUSH
81772: LD_INT 1
81774: NEG
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: PUSH
81780: LD_INT 3
81782: PUSH
81783: LD_INT 2
81785: NEG
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 5
81793: PUSH
81794: LD_INT 2
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: PUSH
81801: LD_INT 3
81803: PUSH
81804: LD_INT 3
81806: PUSH
81807: EMPTY
81808: LIST
81809: LIST
81810: PUSH
81811: LD_INT 3
81813: PUSH
81814: LD_INT 2
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: PUSH
81821: LD_INT 4
81823: PUSH
81824: LD_INT 3
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: LD_INT 4
81833: PUSH
81834: LD_INT 4
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 3
81843: PUSH
81844: LD_INT 4
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 2
81853: PUSH
81854: LD_INT 3
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 2
81863: PUSH
81864: LD_INT 2
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: PUSH
81871: LD_INT 4
81873: PUSH
81874: LD_INT 2
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PUSH
81881: LD_INT 2
81883: PUSH
81884: LD_INT 4
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: PUSH
81891: LD_INT 0
81893: PUSH
81894: LD_INT 4
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_INT 0
81903: PUSH
81904: LD_INT 3
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 1
81913: PUSH
81914: LD_INT 4
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 1
81923: PUSH
81924: LD_INT 5
81926: PUSH
81927: EMPTY
81928: LIST
81929: LIST
81930: PUSH
81931: LD_INT 0
81933: PUSH
81934: LD_INT 5
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PUSH
81941: LD_INT 1
81943: NEG
81944: PUSH
81945: LD_INT 4
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: PUSH
81952: LD_INT 1
81954: NEG
81955: PUSH
81956: LD_INT 3
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: PUSH
81963: LD_INT 2
81965: PUSH
81966: LD_INT 5
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: PUSH
81973: LD_INT 2
81975: NEG
81976: PUSH
81977: LD_INT 3
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82031: LD_ADDR_VAR 0 34
82035: PUSH
82036: LD_INT 0
82038: PUSH
82039: LD_INT 4
82041: NEG
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 0
82049: PUSH
82050: LD_INT 5
82052: NEG
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 1
82060: PUSH
82061: LD_INT 4
82063: NEG
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_INT 1
82071: PUSH
82072: LD_INT 3
82074: NEG
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 0
82082: PUSH
82083: LD_INT 3
82085: NEG
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 1
82093: NEG
82094: PUSH
82095: LD_INT 4
82097: NEG
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 1
82105: NEG
82106: PUSH
82107: LD_INT 5
82109: NEG
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: PUSH
82115: LD_INT 2
82117: PUSH
82118: LD_INT 3
82120: NEG
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 2
82128: NEG
82129: PUSH
82130: LD_INT 5
82132: NEG
82133: PUSH
82134: EMPTY
82135: LIST
82136: LIST
82137: PUSH
82138: LD_INT 3
82140: PUSH
82141: LD_INT 0
82143: PUSH
82144: EMPTY
82145: LIST
82146: LIST
82147: PUSH
82148: LD_INT 3
82150: PUSH
82151: LD_INT 1
82153: NEG
82154: PUSH
82155: EMPTY
82156: LIST
82157: LIST
82158: PUSH
82159: LD_INT 4
82161: PUSH
82162: LD_INT 0
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 4
82171: PUSH
82172: LD_INT 1
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 3
82181: PUSH
82182: LD_INT 1
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 2
82191: PUSH
82192: LD_INT 0
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 2
82201: PUSH
82202: LD_INT 1
82204: NEG
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: PUSH
82210: LD_INT 2
82212: PUSH
82213: LD_INT 2
82215: NEG
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 4
82223: PUSH
82224: LD_INT 2
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: PUSH
82231: LD_INT 4
82233: PUSH
82234: LD_INT 4
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 4
82243: PUSH
82244: LD_INT 3
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: PUSH
82251: LD_INT 5
82253: PUSH
82254: LD_INT 4
82256: PUSH
82257: EMPTY
82258: LIST
82259: LIST
82260: PUSH
82261: LD_INT 5
82263: PUSH
82264: LD_INT 5
82266: PUSH
82267: EMPTY
82268: LIST
82269: LIST
82270: PUSH
82271: LD_INT 4
82273: PUSH
82274: LD_INT 5
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 3
82283: PUSH
82284: LD_INT 4
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PUSH
82291: LD_INT 3
82293: PUSH
82294: LD_INT 3
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: PUSH
82301: LD_INT 5
82303: PUSH
82304: LD_INT 3
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 3
82313: PUSH
82314: LD_INT 5
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 0
82323: PUSH
82324: LD_INT 3
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 0
82333: PUSH
82334: LD_INT 2
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 1
82343: PUSH
82344: LD_INT 3
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 1
82353: PUSH
82354: LD_INT 4
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PUSH
82361: LD_INT 0
82363: PUSH
82364: LD_INT 4
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: PUSH
82371: LD_INT 1
82373: NEG
82374: PUSH
82375: LD_INT 3
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 1
82384: NEG
82385: PUSH
82386: LD_INT 2
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 2
82395: PUSH
82396: LD_INT 4
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 2
82405: NEG
82406: PUSH
82407: LD_INT 2
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 4
82416: NEG
82417: PUSH
82418: LD_INT 0
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: PUSH
82425: LD_INT 4
82427: NEG
82428: PUSH
82429: LD_INT 1
82431: NEG
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 3
82439: NEG
82440: PUSH
82441: LD_INT 0
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 3
82450: NEG
82451: PUSH
82452: LD_INT 1
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 4
82461: NEG
82462: PUSH
82463: LD_INT 1
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 5
82472: NEG
82473: PUSH
82474: LD_INT 0
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PUSH
82481: LD_INT 5
82483: NEG
82484: PUSH
82485: LD_INT 1
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 5
82495: NEG
82496: PUSH
82497: LD_INT 2
82499: NEG
82500: PUSH
82501: EMPTY
82502: LIST
82503: LIST
82504: PUSH
82505: LD_INT 3
82507: NEG
82508: PUSH
82509: LD_INT 2
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: LIST
82520: LIST
82521: LIST
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: ST_TO_ADDR
// end ; end ;
82563: GO 82566
82565: POP
// case btype of b_depot , b_warehouse :
82566: LD_VAR 0 1
82570: PUSH
82571: LD_INT 0
82573: DOUBLE
82574: EQUAL
82575: IFTRUE 82585
82577: LD_INT 1
82579: DOUBLE
82580: EQUAL
82581: IFTRUE 82585
82583: GO 82786
82585: POP
// case nation of nation_american :
82586: LD_VAR 0 5
82590: PUSH
82591: LD_INT 1
82593: DOUBLE
82594: EQUAL
82595: IFTRUE 82599
82597: GO 82655
82599: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
82600: LD_ADDR_VAR 0 9
82604: PUSH
82605: LD_VAR 0 11
82609: PUSH
82610: LD_VAR 0 12
82614: PUSH
82615: LD_VAR 0 13
82619: PUSH
82620: LD_VAR 0 14
82624: PUSH
82625: LD_VAR 0 15
82629: PUSH
82630: LD_VAR 0 16
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: PUSH
82643: LD_VAR 0 4
82647: PUSH
82648: LD_INT 1
82650: PLUS
82651: ARRAY
82652: ST_TO_ADDR
82653: GO 82784
82655: LD_INT 2
82657: DOUBLE
82658: EQUAL
82659: IFTRUE 82663
82661: GO 82719
82663: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
82664: LD_ADDR_VAR 0 9
82668: PUSH
82669: LD_VAR 0 17
82673: PUSH
82674: LD_VAR 0 18
82678: PUSH
82679: LD_VAR 0 19
82683: PUSH
82684: LD_VAR 0 20
82688: PUSH
82689: LD_VAR 0 21
82693: PUSH
82694: LD_VAR 0 22
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: PUSH
82707: LD_VAR 0 4
82711: PUSH
82712: LD_INT 1
82714: PLUS
82715: ARRAY
82716: ST_TO_ADDR
82717: GO 82784
82719: LD_INT 3
82721: DOUBLE
82722: EQUAL
82723: IFTRUE 82727
82725: GO 82783
82727: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
82728: LD_ADDR_VAR 0 9
82732: PUSH
82733: LD_VAR 0 23
82737: PUSH
82738: LD_VAR 0 24
82742: PUSH
82743: LD_VAR 0 25
82747: PUSH
82748: LD_VAR 0 26
82752: PUSH
82753: LD_VAR 0 27
82757: PUSH
82758: LD_VAR 0 28
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: PUSH
82771: LD_VAR 0 4
82775: PUSH
82776: LD_INT 1
82778: PLUS
82779: ARRAY
82780: ST_TO_ADDR
82781: GO 82784
82783: POP
82784: GO 83339
82786: LD_INT 2
82788: DOUBLE
82789: EQUAL
82790: IFTRUE 82800
82792: LD_INT 3
82794: DOUBLE
82795: EQUAL
82796: IFTRUE 82800
82798: GO 82856
82800: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
82801: LD_ADDR_VAR 0 9
82805: PUSH
82806: LD_VAR 0 29
82810: PUSH
82811: LD_VAR 0 30
82815: PUSH
82816: LD_VAR 0 31
82820: PUSH
82821: LD_VAR 0 32
82825: PUSH
82826: LD_VAR 0 33
82830: PUSH
82831: LD_VAR 0 34
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: PUSH
82844: LD_VAR 0 4
82848: PUSH
82849: LD_INT 1
82851: PLUS
82852: ARRAY
82853: ST_TO_ADDR
82854: GO 83339
82856: LD_INT 16
82858: DOUBLE
82859: EQUAL
82860: IFTRUE 82918
82862: LD_INT 17
82864: DOUBLE
82865: EQUAL
82866: IFTRUE 82918
82868: LD_INT 18
82870: DOUBLE
82871: EQUAL
82872: IFTRUE 82918
82874: LD_INT 19
82876: DOUBLE
82877: EQUAL
82878: IFTRUE 82918
82880: LD_INT 22
82882: DOUBLE
82883: EQUAL
82884: IFTRUE 82918
82886: LD_INT 20
82888: DOUBLE
82889: EQUAL
82890: IFTRUE 82918
82892: LD_INT 21
82894: DOUBLE
82895: EQUAL
82896: IFTRUE 82918
82898: LD_INT 23
82900: DOUBLE
82901: EQUAL
82902: IFTRUE 82918
82904: LD_INT 24
82906: DOUBLE
82907: EQUAL
82908: IFTRUE 82918
82910: LD_INT 25
82912: DOUBLE
82913: EQUAL
82914: IFTRUE 82918
82916: GO 82974
82918: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
82919: LD_ADDR_VAR 0 9
82923: PUSH
82924: LD_VAR 0 35
82928: PUSH
82929: LD_VAR 0 36
82933: PUSH
82934: LD_VAR 0 37
82938: PUSH
82939: LD_VAR 0 38
82943: PUSH
82944: LD_VAR 0 39
82948: PUSH
82949: LD_VAR 0 40
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: LIST
82958: LIST
82959: LIST
82960: LIST
82961: PUSH
82962: LD_VAR 0 4
82966: PUSH
82967: LD_INT 1
82969: PLUS
82970: ARRAY
82971: ST_TO_ADDR
82972: GO 83339
82974: LD_INT 6
82976: DOUBLE
82977: EQUAL
82978: IFTRUE 83030
82980: LD_INT 7
82982: DOUBLE
82983: EQUAL
82984: IFTRUE 83030
82986: LD_INT 8
82988: DOUBLE
82989: EQUAL
82990: IFTRUE 83030
82992: LD_INT 13
82994: DOUBLE
82995: EQUAL
82996: IFTRUE 83030
82998: LD_INT 12
83000: DOUBLE
83001: EQUAL
83002: IFTRUE 83030
83004: LD_INT 15
83006: DOUBLE
83007: EQUAL
83008: IFTRUE 83030
83010: LD_INT 11
83012: DOUBLE
83013: EQUAL
83014: IFTRUE 83030
83016: LD_INT 14
83018: DOUBLE
83019: EQUAL
83020: IFTRUE 83030
83022: LD_INT 10
83024: DOUBLE
83025: EQUAL
83026: IFTRUE 83030
83028: GO 83086
83030: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
83031: LD_ADDR_VAR 0 9
83035: PUSH
83036: LD_VAR 0 41
83040: PUSH
83041: LD_VAR 0 42
83045: PUSH
83046: LD_VAR 0 43
83050: PUSH
83051: LD_VAR 0 44
83055: PUSH
83056: LD_VAR 0 45
83060: PUSH
83061: LD_VAR 0 46
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: PUSH
83074: LD_VAR 0 4
83078: PUSH
83079: LD_INT 1
83081: PLUS
83082: ARRAY
83083: ST_TO_ADDR
83084: GO 83339
83086: LD_INT 36
83088: DOUBLE
83089: EQUAL
83090: IFTRUE 83094
83092: GO 83150
83094: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83095: LD_ADDR_VAR 0 9
83099: PUSH
83100: LD_VAR 0 47
83104: PUSH
83105: LD_VAR 0 48
83109: PUSH
83110: LD_VAR 0 49
83114: PUSH
83115: LD_VAR 0 50
83119: PUSH
83120: LD_VAR 0 51
83124: PUSH
83125: LD_VAR 0 52
83129: PUSH
83130: EMPTY
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: LIST
83137: PUSH
83138: LD_VAR 0 4
83142: PUSH
83143: LD_INT 1
83145: PLUS
83146: ARRAY
83147: ST_TO_ADDR
83148: GO 83339
83150: LD_INT 4
83152: DOUBLE
83153: EQUAL
83154: IFTRUE 83176
83156: LD_INT 5
83158: DOUBLE
83159: EQUAL
83160: IFTRUE 83176
83162: LD_INT 34
83164: DOUBLE
83165: EQUAL
83166: IFTRUE 83176
83168: LD_INT 37
83170: DOUBLE
83171: EQUAL
83172: IFTRUE 83176
83174: GO 83232
83176: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83177: LD_ADDR_VAR 0 9
83181: PUSH
83182: LD_VAR 0 53
83186: PUSH
83187: LD_VAR 0 54
83191: PUSH
83192: LD_VAR 0 55
83196: PUSH
83197: LD_VAR 0 56
83201: PUSH
83202: LD_VAR 0 57
83206: PUSH
83207: LD_VAR 0 58
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: LIST
83216: LIST
83217: LIST
83218: LIST
83219: PUSH
83220: LD_VAR 0 4
83224: PUSH
83225: LD_INT 1
83227: PLUS
83228: ARRAY
83229: ST_TO_ADDR
83230: GO 83339
83232: LD_INT 31
83234: DOUBLE
83235: EQUAL
83236: IFTRUE 83282
83238: LD_INT 32
83240: DOUBLE
83241: EQUAL
83242: IFTRUE 83282
83244: LD_INT 33
83246: DOUBLE
83247: EQUAL
83248: IFTRUE 83282
83250: LD_INT 27
83252: DOUBLE
83253: EQUAL
83254: IFTRUE 83282
83256: LD_INT 26
83258: DOUBLE
83259: EQUAL
83260: IFTRUE 83282
83262: LD_INT 28
83264: DOUBLE
83265: EQUAL
83266: IFTRUE 83282
83268: LD_INT 29
83270: DOUBLE
83271: EQUAL
83272: IFTRUE 83282
83274: LD_INT 30
83276: DOUBLE
83277: EQUAL
83278: IFTRUE 83282
83280: GO 83338
83282: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
83283: LD_ADDR_VAR 0 9
83287: PUSH
83288: LD_VAR 0 59
83292: PUSH
83293: LD_VAR 0 60
83297: PUSH
83298: LD_VAR 0 61
83302: PUSH
83303: LD_VAR 0 62
83307: PUSH
83308: LD_VAR 0 63
83312: PUSH
83313: LD_VAR 0 64
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: PUSH
83326: LD_VAR 0 4
83330: PUSH
83331: LD_INT 1
83333: PLUS
83334: ARRAY
83335: ST_TO_ADDR
83336: GO 83339
83338: POP
// temp_list2 = [ ] ;
83339: LD_ADDR_VAR 0 10
83343: PUSH
83344: EMPTY
83345: ST_TO_ADDR
// for i in temp_list do
83346: LD_ADDR_VAR 0 8
83350: PUSH
83351: LD_VAR 0 9
83355: PUSH
83356: FOR_IN
83357: IFFALSE 83409
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
83359: LD_ADDR_VAR 0 10
83363: PUSH
83364: LD_VAR 0 10
83368: PUSH
83369: LD_VAR 0 8
83373: PUSH
83374: LD_INT 1
83376: ARRAY
83377: PUSH
83378: LD_VAR 0 2
83382: PLUS
83383: PUSH
83384: LD_VAR 0 8
83388: PUSH
83389: LD_INT 2
83391: ARRAY
83392: PUSH
83393: LD_VAR 0 3
83397: PLUS
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: PUSH
83403: EMPTY
83404: LIST
83405: ADD
83406: ST_TO_ADDR
83407: GO 83356
83409: POP
83410: POP
// result = temp_list2 ;
83411: LD_ADDR_VAR 0 7
83415: PUSH
83416: LD_VAR 0 10
83420: ST_TO_ADDR
// end ;
83421: LD_VAR 0 7
83425: RET
// export function EnemyInRange ( unit , dist ) ; begin
83426: LD_INT 0
83428: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83429: LD_ADDR_VAR 0 3
83433: PUSH
83434: LD_VAR 0 1
83438: PPUSH
83439: CALL_OW 255
83443: PPUSH
83444: LD_VAR 0 1
83448: PPUSH
83449: CALL_OW 250
83453: PPUSH
83454: LD_VAR 0 1
83458: PPUSH
83459: CALL_OW 251
83463: PPUSH
83464: LD_VAR 0 2
83468: PPUSH
83469: CALL 57530 0 4
83473: PUSH
83474: LD_INT 4
83476: ARRAY
83477: ST_TO_ADDR
// end ;
83478: LD_VAR 0 3
83482: RET
// export function PlayerSeeMe ( unit ) ; begin
83483: LD_INT 0
83485: PPUSH
// result := See ( your_side , unit ) ;
83486: LD_ADDR_VAR 0 2
83490: PUSH
83491: LD_OWVAR 2
83495: PPUSH
83496: LD_VAR 0 1
83500: PPUSH
83501: CALL_OW 292
83505: ST_TO_ADDR
// end ;
83506: LD_VAR 0 2
83510: RET
// export function ReverseDir ( unit ) ; begin
83511: LD_INT 0
83513: PPUSH
// if not unit then
83514: LD_VAR 0 1
83518: NOT
83519: IFFALSE 83523
// exit ;
83521: GO 83569
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
83523: LD_ADDR_VAR 0 2
83527: PUSH
83528: LD_INT 3
83530: PUSH
83531: LD_INT 4
83533: PUSH
83534: LD_INT 5
83536: PUSH
83537: LD_INT 0
83539: PUSH
83540: LD_INT 1
83542: PUSH
83543: LD_INT 2
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: PUSH
83554: LD_VAR 0 1
83558: PPUSH
83559: CALL_OW 254
83563: PUSH
83564: LD_INT 1
83566: PLUS
83567: ARRAY
83568: ST_TO_ADDR
// end ;
83569: LD_VAR 0 2
83573: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83574: LD_INT 0
83576: PPUSH
83577: PPUSH
83578: PPUSH
83579: PPUSH
83580: PPUSH
// if not hexes then
83581: LD_VAR 0 2
83585: NOT
83586: IFFALSE 83590
// exit ;
83588: GO 83738
// dist := 9999 ;
83590: LD_ADDR_VAR 0 5
83594: PUSH
83595: LD_INT 9999
83597: ST_TO_ADDR
// for i = 1 to hexes do
83598: LD_ADDR_VAR 0 4
83602: PUSH
83603: DOUBLE
83604: LD_INT 1
83606: DEC
83607: ST_TO_ADDR
83608: LD_VAR 0 2
83612: PUSH
83613: FOR_TO
83614: IFFALSE 83726
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83616: LD_VAR 0 1
83620: PPUSH
83621: LD_VAR 0 2
83625: PUSH
83626: LD_VAR 0 4
83630: ARRAY
83631: PUSH
83632: LD_INT 1
83634: ARRAY
83635: PPUSH
83636: LD_VAR 0 2
83640: PUSH
83641: LD_VAR 0 4
83645: ARRAY
83646: PUSH
83647: LD_INT 2
83649: ARRAY
83650: PPUSH
83651: CALL_OW 297
83655: PUSH
83656: LD_VAR 0 5
83660: LESS
83661: IFFALSE 83724
// begin hex := hexes [ i ] ;
83663: LD_ADDR_VAR 0 7
83667: PUSH
83668: LD_VAR 0 2
83672: PUSH
83673: LD_VAR 0 4
83677: ARRAY
83678: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83679: LD_ADDR_VAR 0 5
83683: PUSH
83684: LD_VAR 0 1
83688: PPUSH
83689: LD_VAR 0 2
83693: PUSH
83694: LD_VAR 0 4
83698: ARRAY
83699: PUSH
83700: LD_INT 1
83702: ARRAY
83703: PPUSH
83704: LD_VAR 0 2
83708: PUSH
83709: LD_VAR 0 4
83713: ARRAY
83714: PUSH
83715: LD_INT 2
83717: ARRAY
83718: PPUSH
83719: CALL_OW 297
83723: ST_TO_ADDR
// end ; end ;
83724: GO 83613
83726: POP
83727: POP
// result := hex ;
83728: LD_ADDR_VAR 0 3
83732: PUSH
83733: LD_VAR 0 7
83737: ST_TO_ADDR
// end ;
83738: LD_VAR 0 3
83742: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
83743: LD_INT 0
83745: PPUSH
83746: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83747: LD_VAR 0 1
83751: NOT
83752: PUSH
83753: LD_VAR 0 1
83757: PUSH
83758: LD_INT 21
83760: PUSH
83761: LD_INT 2
83763: PUSH
83764: EMPTY
83765: LIST
83766: LIST
83767: PUSH
83768: LD_INT 23
83770: PUSH
83771: LD_INT 2
83773: PUSH
83774: EMPTY
83775: LIST
83776: LIST
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PPUSH
83782: CALL_OW 69
83786: IN
83787: NOT
83788: OR
83789: IFFALSE 83793
// exit ;
83791: GO 83840
// for i = 1 to 3 do
83793: LD_ADDR_VAR 0 3
83797: PUSH
83798: DOUBLE
83799: LD_INT 1
83801: DEC
83802: ST_TO_ADDR
83803: LD_INT 3
83805: PUSH
83806: FOR_TO
83807: IFFALSE 83838
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
83809: LD_VAR 0 1
83813: PPUSH
83814: CALL_OW 250
83818: PPUSH
83819: LD_VAR 0 1
83823: PPUSH
83824: CALL_OW 251
83828: PPUSH
83829: LD_INT 1
83831: PPUSH
83832: CALL_OW 453
83836: GO 83806
83838: POP
83839: POP
// end ;
83840: LD_VAR 0 2
83844: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
83845: LD_INT 0
83847: PPUSH
83848: PPUSH
83849: PPUSH
83850: PPUSH
83851: PPUSH
83852: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
83853: LD_VAR 0 1
83857: NOT
83858: PUSH
83859: LD_VAR 0 2
83863: NOT
83864: OR
83865: PUSH
83866: LD_VAR 0 1
83870: PPUSH
83871: CALL_OW 314
83875: OR
83876: IFFALSE 83880
// exit ;
83878: GO 84321
// x := GetX ( enemy_unit ) ;
83880: LD_ADDR_VAR 0 7
83884: PUSH
83885: LD_VAR 0 2
83889: PPUSH
83890: CALL_OW 250
83894: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
83895: LD_ADDR_VAR 0 8
83899: PUSH
83900: LD_VAR 0 2
83904: PPUSH
83905: CALL_OW 251
83909: ST_TO_ADDR
// if not x or not y then
83910: LD_VAR 0 7
83914: NOT
83915: PUSH
83916: LD_VAR 0 8
83920: NOT
83921: OR
83922: IFFALSE 83926
// exit ;
83924: GO 84321
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
83926: LD_ADDR_VAR 0 6
83930: PUSH
83931: LD_VAR 0 7
83935: PPUSH
83936: LD_INT 0
83938: PPUSH
83939: LD_INT 4
83941: PPUSH
83942: CALL_OW 272
83946: PUSH
83947: LD_VAR 0 8
83951: PPUSH
83952: LD_INT 0
83954: PPUSH
83955: LD_INT 4
83957: PPUSH
83958: CALL_OW 273
83962: PUSH
83963: EMPTY
83964: LIST
83965: LIST
83966: PUSH
83967: LD_VAR 0 7
83971: PPUSH
83972: LD_INT 1
83974: PPUSH
83975: LD_INT 4
83977: PPUSH
83978: CALL_OW 272
83982: PUSH
83983: LD_VAR 0 8
83987: PPUSH
83988: LD_INT 1
83990: PPUSH
83991: LD_INT 4
83993: PPUSH
83994: CALL_OW 273
83998: PUSH
83999: EMPTY
84000: LIST
84001: LIST
84002: PUSH
84003: LD_VAR 0 7
84007: PPUSH
84008: LD_INT 2
84010: PPUSH
84011: LD_INT 4
84013: PPUSH
84014: CALL_OW 272
84018: PUSH
84019: LD_VAR 0 8
84023: PPUSH
84024: LD_INT 2
84026: PPUSH
84027: LD_INT 4
84029: PPUSH
84030: CALL_OW 273
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PUSH
84039: LD_VAR 0 7
84043: PPUSH
84044: LD_INT 3
84046: PPUSH
84047: LD_INT 4
84049: PPUSH
84050: CALL_OW 272
84054: PUSH
84055: LD_VAR 0 8
84059: PPUSH
84060: LD_INT 3
84062: PPUSH
84063: LD_INT 4
84065: PPUSH
84066: CALL_OW 273
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_VAR 0 7
84079: PPUSH
84080: LD_INT 4
84082: PPUSH
84083: LD_INT 4
84085: PPUSH
84086: CALL_OW 272
84090: PUSH
84091: LD_VAR 0 8
84095: PPUSH
84096: LD_INT 4
84098: PPUSH
84099: LD_INT 4
84101: PPUSH
84102: CALL_OW 273
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: LD_VAR 0 7
84115: PPUSH
84116: LD_INT 5
84118: PPUSH
84119: LD_INT 4
84121: PPUSH
84122: CALL_OW 272
84126: PUSH
84127: LD_VAR 0 8
84131: PPUSH
84132: LD_INT 5
84134: PPUSH
84135: LD_INT 4
84137: PPUSH
84138: CALL_OW 273
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: PUSH
84147: EMPTY
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: ST_TO_ADDR
// for i = tmp downto 1 do
84155: LD_ADDR_VAR 0 4
84159: PUSH
84160: DOUBLE
84161: LD_VAR 0 6
84165: INC
84166: ST_TO_ADDR
84167: LD_INT 1
84169: PUSH
84170: FOR_DOWNTO
84171: IFFALSE 84272
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84173: LD_VAR 0 6
84177: PUSH
84178: LD_VAR 0 4
84182: ARRAY
84183: PUSH
84184: LD_INT 1
84186: ARRAY
84187: PPUSH
84188: LD_VAR 0 6
84192: PUSH
84193: LD_VAR 0 4
84197: ARRAY
84198: PUSH
84199: LD_INT 2
84201: ARRAY
84202: PPUSH
84203: CALL_OW 488
84207: NOT
84208: PUSH
84209: LD_VAR 0 6
84213: PUSH
84214: LD_VAR 0 4
84218: ARRAY
84219: PUSH
84220: LD_INT 1
84222: ARRAY
84223: PPUSH
84224: LD_VAR 0 6
84228: PUSH
84229: LD_VAR 0 4
84233: ARRAY
84234: PUSH
84235: LD_INT 2
84237: ARRAY
84238: PPUSH
84239: CALL_OW 428
84243: PUSH
84244: LD_INT 0
84246: NONEQUAL
84247: OR
84248: IFFALSE 84270
// tmp := Delete ( tmp , i ) ;
84250: LD_ADDR_VAR 0 6
84254: PUSH
84255: LD_VAR 0 6
84259: PPUSH
84260: LD_VAR 0 4
84264: PPUSH
84265: CALL_OW 3
84269: ST_TO_ADDR
84270: GO 84170
84272: POP
84273: POP
// j := GetClosestHex ( unit , tmp ) ;
84274: LD_ADDR_VAR 0 5
84278: PUSH
84279: LD_VAR 0 1
84283: PPUSH
84284: LD_VAR 0 6
84288: PPUSH
84289: CALL 83574 0 2
84293: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
84294: LD_VAR 0 1
84298: PPUSH
84299: LD_VAR 0 5
84303: PUSH
84304: LD_INT 1
84306: ARRAY
84307: PPUSH
84308: LD_VAR 0 5
84312: PUSH
84313: LD_INT 2
84315: ARRAY
84316: PPUSH
84317: CALL_OW 111
// end ;
84321: LD_VAR 0 3
84325: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84326: LD_INT 0
84328: PPUSH
84329: PPUSH
84330: PPUSH
// uc_side = 0 ;
84331: LD_ADDR_OWVAR 20
84335: PUSH
84336: LD_INT 0
84338: ST_TO_ADDR
// uc_nation = 0 ;
84339: LD_ADDR_OWVAR 21
84343: PUSH
84344: LD_INT 0
84346: ST_TO_ADDR
// InitHc ;
84347: CALL_OW 19
// InitVc ;
84351: CALL_OW 20
// if mastodonts then
84355: LD_VAR 0 6
84359: IFFALSE 84426
// for i = 1 to mastodonts do
84361: LD_ADDR_VAR 0 11
84365: PUSH
84366: DOUBLE
84367: LD_INT 1
84369: DEC
84370: ST_TO_ADDR
84371: LD_VAR 0 6
84375: PUSH
84376: FOR_TO
84377: IFFALSE 84424
// begin vc_chassis := 31 ;
84379: LD_ADDR_OWVAR 37
84383: PUSH
84384: LD_INT 31
84386: ST_TO_ADDR
// vc_control := control_rider ;
84387: LD_ADDR_OWVAR 38
84391: PUSH
84392: LD_INT 4
84394: ST_TO_ADDR
// animal := CreateVehicle ;
84395: LD_ADDR_VAR 0 12
84399: PUSH
84400: CALL_OW 45
84404: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84405: LD_VAR 0 12
84409: PPUSH
84410: LD_VAR 0 8
84414: PPUSH
84415: LD_INT 0
84417: PPUSH
84418: CALL 91171 0 3
// end ;
84422: GO 84376
84424: POP
84425: POP
// if horses then
84426: LD_VAR 0 5
84430: IFFALSE 84497
// for i = 1 to horses do
84432: LD_ADDR_VAR 0 11
84436: PUSH
84437: DOUBLE
84438: LD_INT 1
84440: DEC
84441: ST_TO_ADDR
84442: LD_VAR 0 5
84446: PUSH
84447: FOR_TO
84448: IFFALSE 84495
// begin hc_class := 21 ;
84450: LD_ADDR_OWVAR 28
84454: PUSH
84455: LD_INT 21
84457: ST_TO_ADDR
// hc_gallery :=  ;
84458: LD_ADDR_OWVAR 33
84462: PUSH
84463: LD_STRING 
84465: ST_TO_ADDR
// animal := CreateHuman ;
84466: LD_ADDR_VAR 0 12
84470: PUSH
84471: CALL_OW 44
84475: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84476: LD_VAR 0 12
84480: PPUSH
84481: LD_VAR 0 8
84485: PPUSH
84486: LD_INT 0
84488: PPUSH
84489: CALL 91171 0 3
// end ;
84493: GO 84447
84495: POP
84496: POP
// if birds then
84497: LD_VAR 0 1
84501: IFFALSE 84568
// for i = 1 to birds do
84503: LD_ADDR_VAR 0 11
84507: PUSH
84508: DOUBLE
84509: LD_INT 1
84511: DEC
84512: ST_TO_ADDR
84513: LD_VAR 0 1
84517: PUSH
84518: FOR_TO
84519: IFFALSE 84566
// begin hc_class = 18 ;
84521: LD_ADDR_OWVAR 28
84525: PUSH
84526: LD_INT 18
84528: ST_TO_ADDR
// hc_gallery =  ;
84529: LD_ADDR_OWVAR 33
84533: PUSH
84534: LD_STRING 
84536: ST_TO_ADDR
// animal := CreateHuman ;
84537: LD_ADDR_VAR 0 12
84541: PUSH
84542: CALL_OW 44
84546: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84547: LD_VAR 0 12
84551: PPUSH
84552: LD_VAR 0 8
84556: PPUSH
84557: LD_INT 0
84559: PPUSH
84560: CALL 91171 0 3
// end ;
84564: GO 84518
84566: POP
84567: POP
// if tigers then
84568: LD_VAR 0 2
84572: IFFALSE 84656
// for i = 1 to tigers do
84574: LD_ADDR_VAR 0 11
84578: PUSH
84579: DOUBLE
84580: LD_INT 1
84582: DEC
84583: ST_TO_ADDR
84584: LD_VAR 0 2
84588: PUSH
84589: FOR_TO
84590: IFFALSE 84654
// begin hc_class = class_tiger ;
84592: LD_ADDR_OWVAR 28
84596: PUSH
84597: LD_INT 14
84599: ST_TO_ADDR
// hc_gallery =  ;
84600: LD_ADDR_OWVAR 33
84604: PUSH
84605: LD_STRING 
84607: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84608: LD_ADDR_OWVAR 35
84612: PUSH
84613: LD_INT 7
84615: NEG
84616: PPUSH
84617: LD_INT 7
84619: PPUSH
84620: CALL_OW 12
84624: ST_TO_ADDR
// animal := CreateHuman ;
84625: LD_ADDR_VAR 0 12
84629: PUSH
84630: CALL_OW 44
84634: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84635: LD_VAR 0 12
84639: PPUSH
84640: LD_VAR 0 8
84644: PPUSH
84645: LD_INT 0
84647: PPUSH
84648: CALL 91171 0 3
// end ;
84652: GO 84589
84654: POP
84655: POP
// if apemans then
84656: LD_VAR 0 3
84660: IFFALSE 84783
// for i = 1 to apemans do
84662: LD_ADDR_VAR 0 11
84666: PUSH
84667: DOUBLE
84668: LD_INT 1
84670: DEC
84671: ST_TO_ADDR
84672: LD_VAR 0 3
84676: PUSH
84677: FOR_TO
84678: IFFALSE 84781
// begin hc_class = class_apeman ;
84680: LD_ADDR_OWVAR 28
84684: PUSH
84685: LD_INT 12
84687: ST_TO_ADDR
// hc_gallery =  ;
84688: LD_ADDR_OWVAR 33
84692: PUSH
84693: LD_STRING 
84695: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
84696: LD_ADDR_OWVAR 35
84700: PUSH
84701: LD_INT 5
84703: NEG
84704: PPUSH
84705: LD_INT 5
84707: PPUSH
84708: CALL_OW 12
84712: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
84713: LD_ADDR_OWVAR 31
84717: PUSH
84718: LD_INT 1
84720: PPUSH
84721: LD_INT 3
84723: PPUSH
84724: CALL_OW 12
84728: PUSH
84729: LD_INT 1
84731: PPUSH
84732: LD_INT 3
84734: PPUSH
84735: CALL_OW 12
84739: PUSH
84740: LD_INT 0
84742: PUSH
84743: LD_INT 0
84745: PUSH
84746: EMPTY
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: ST_TO_ADDR
// animal := CreateHuman ;
84752: LD_ADDR_VAR 0 12
84756: PUSH
84757: CALL_OW 44
84761: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84762: LD_VAR 0 12
84766: PPUSH
84767: LD_VAR 0 8
84771: PPUSH
84772: LD_INT 0
84774: PPUSH
84775: CALL 91171 0 3
// end ;
84779: GO 84677
84781: POP
84782: POP
// if enchidnas then
84783: LD_VAR 0 4
84787: IFFALSE 84854
// for i = 1 to enchidnas do
84789: LD_ADDR_VAR 0 11
84793: PUSH
84794: DOUBLE
84795: LD_INT 1
84797: DEC
84798: ST_TO_ADDR
84799: LD_VAR 0 4
84803: PUSH
84804: FOR_TO
84805: IFFALSE 84852
// begin hc_class = 13 ;
84807: LD_ADDR_OWVAR 28
84811: PUSH
84812: LD_INT 13
84814: ST_TO_ADDR
// hc_gallery =  ;
84815: LD_ADDR_OWVAR 33
84819: PUSH
84820: LD_STRING 
84822: ST_TO_ADDR
// animal := CreateHuman ;
84823: LD_ADDR_VAR 0 12
84827: PUSH
84828: CALL_OW 44
84832: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84833: LD_VAR 0 12
84837: PPUSH
84838: LD_VAR 0 8
84842: PPUSH
84843: LD_INT 0
84845: PPUSH
84846: CALL 91171 0 3
// end ;
84850: GO 84804
84852: POP
84853: POP
// if fishes then
84854: LD_VAR 0 7
84858: IFFALSE 84925
// for i = 1 to fishes do
84860: LD_ADDR_VAR 0 11
84864: PUSH
84865: DOUBLE
84866: LD_INT 1
84868: DEC
84869: ST_TO_ADDR
84870: LD_VAR 0 7
84874: PUSH
84875: FOR_TO
84876: IFFALSE 84923
// begin hc_class = 20 ;
84878: LD_ADDR_OWVAR 28
84882: PUSH
84883: LD_INT 20
84885: ST_TO_ADDR
// hc_gallery =  ;
84886: LD_ADDR_OWVAR 33
84890: PUSH
84891: LD_STRING 
84893: ST_TO_ADDR
// animal := CreateHuman ;
84894: LD_ADDR_VAR 0 12
84898: PUSH
84899: CALL_OW 44
84903: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84904: LD_VAR 0 12
84908: PPUSH
84909: LD_VAR 0 9
84913: PPUSH
84914: LD_INT 0
84916: PPUSH
84917: CALL 91171 0 3
// end ;
84921: GO 84875
84923: POP
84924: POP
// end ;
84925: LD_VAR 0 10
84929: RET
// export function WantHeal ( sci , unit ) ; begin
84930: LD_INT 0
84932: PPUSH
// if GetTaskList ( sci ) > 0 then
84933: LD_VAR 0 1
84937: PPUSH
84938: CALL_OW 437
84942: PUSH
84943: LD_INT 0
84945: GREATER
84946: IFFALSE 85016
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84948: LD_VAR 0 1
84952: PPUSH
84953: CALL_OW 437
84957: PUSH
84958: LD_INT 1
84960: ARRAY
84961: PUSH
84962: LD_INT 1
84964: ARRAY
84965: PUSH
84966: LD_STRING l
84968: EQUAL
84969: PUSH
84970: LD_VAR 0 1
84974: PPUSH
84975: CALL_OW 437
84979: PUSH
84980: LD_INT 1
84982: ARRAY
84983: PUSH
84984: LD_INT 4
84986: ARRAY
84987: PUSH
84988: LD_VAR 0 2
84992: EQUAL
84993: AND
84994: IFFALSE 85006
// result := true else
84996: LD_ADDR_VAR 0 3
85000: PUSH
85001: LD_INT 1
85003: ST_TO_ADDR
85004: GO 85014
// result := false ;
85006: LD_ADDR_VAR 0 3
85010: PUSH
85011: LD_INT 0
85013: ST_TO_ADDR
// end else
85014: GO 85024
// result := false ;
85016: LD_ADDR_VAR 0 3
85020: PUSH
85021: LD_INT 0
85023: ST_TO_ADDR
// end ;
85024: LD_VAR 0 3
85028: RET
// export function HealTarget ( sci ) ; begin
85029: LD_INT 0
85031: PPUSH
// if not sci then
85032: LD_VAR 0 1
85036: NOT
85037: IFFALSE 85041
// exit ;
85039: GO 85106
// result := 0 ;
85041: LD_ADDR_VAR 0 2
85045: PUSH
85046: LD_INT 0
85048: ST_TO_ADDR
// if GetTaskList ( sci ) then
85049: LD_VAR 0 1
85053: PPUSH
85054: CALL_OW 437
85058: IFFALSE 85106
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85060: LD_VAR 0 1
85064: PPUSH
85065: CALL_OW 437
85069: PUSH
85070: LD_INT 1
85072: ARRAY
85073: PUSH
85074: LD_INT 1
85076: ARRAY
85077: PUSH
85078: LD_STRING l
85080: EQUAL
85081: IFFALSE 85106
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85083: LD_ADDR_VAR 0 2
85087: PUSH
85088: LD_VAR 0 1
85092: PPUSH
85093: CALL_OW 437
85097: PUSH
85098: LD_INT 1
85100: ARRAY
85101: PUSH
85102: LD_INT 4
85104: ARRAY
85105: ST_TO_ADDR
// end ;
85106: LD_VAR 0 2
85110: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
85111: LD_INT 0
85113: PPUSH
85114: PPUSH
85115: PPUSH
85116: PPUSH
85117: PPUSH
85118: PPUSH
85119: PPUSH
85120: PPUSH
85121: PPUSH
85122: PPUSH
85123: PPUSH
85124: PPUSH
85125: PPUSH
85126: PPUSH
85127: PPUSH
85128: PPUSH
85129: PPUSH
85130: PPUSH
85131: PPUSH
85132: PPUSH
85133: PPUSH
85134: PPUSH
85135: PPUSH
85136: PPUSH
85137: PPUSH
85138: PPUSH
85139: PPUSH
85140: PPUSH
85141: PPUSH
85142: PPUSH
85143: PPUSH
85144: PPUSH
85145: PPUSH
85146: PPUSH
// if not list then
85147: LD_VAR 0 1
85151: NOT
85152: IFFALSE 85156
// exit ;
85154: GO 89782
// base := list [ 1 ] ;
85156: LD_ADDR_VAR 0 3
85160: PUSH
85161: LD_VAR 0 1
85165: PUSH
85166: LD_INT 1
85168: ARRAY
85169: ST_TO_ADDR
// group := list [ 2 ] ;
85170: LD_ADDR_VAR 0 4
85174: PUSH
85175: LD_VAR 0 1
85179: PUSH
85180: LD_INT 2
85182: ARRAY
85183: ST_TO_ADDR
// path := list [ 3 ] ;
85184: LD_ADDR_VAR 0 5
85188: PUSH
85189: LD_VAR 0 1
85193: PUSH
85194: LD_INT 3
85196: ARRAY
85197: ST_TO_ADDR
// flags := list [ 4 ] ;
85198: LD_ADDR_VAR 0 6
85202: PUSH
85203: LD_VAR 0 1
85207: PUSH
85208: LD_INT 4
85210: ARRAY
85211: ST_TO_ADDR
// mined := [ ] ;
85212: LD_ADDR_VAR 0 27
85216: PUSH
85217: EMPTY
85218: ST_TO_ADDR
// bombed := [ ] ;
85219: LD_ADDR_VAR 0 28
85223: PUSH
85224: EMPTY
85225: ST_TO_ADDR
// healers := [ ] ;
85226: LD_ADDR_VAR 0 31
85230: PUSH
85231: EMPTY
85232: ST_TO_ADDR
// to_heal := [ ] ;
85233: LD_ADDR_VAR 0 30
85237: PUSH
85238: EMPTY
85239: ST_TO_ADDR
// repairs := [ ] ;
85240: LD_ADDR_VAR 0 33
85244: PUSH
85245: EMPTY
85246: ST_TO_ADDR
// to_repair := [ ] ;
85247: LD_ADDR_VAR 0 32
85251: PUSH
85252: EMPTY
85253: ST_TO_ADDR
// if not group or not path then
85254: LD_VAR 0 4
85258: NOT
85259: PUSH
85260: LD_VAR 0 5
85264: NOT
85265: OR
85266: IFFALSE 85270
// exit ;
85268: GO 89782
// side := GetSide ( group [ 1 ] ) ;
85270: LD_ADDR_VAR 0 35
85274: PUSH
85275: LD_VAR 0 4
85279: PUSH
85280: LD_INT 1
85282: ARRAY
85283: PPUSH
85284: CALL_OW 255
85288: ST_TO_ADDR
// if flags then
85289: LD_VAR 0 6
85293: IFFALSE 85437
// begin f_ignore_area := flags [ 1 ] ;
85295: LD_ADDR_VAR 0 17
85299: PUSH
85300: LD_VAR 0 6
85304: PUSH
85305: LD_INT 1
85307: ARRAY
85308: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
85309: LD_ADDR_VAR 0 18
85313: PUSH
85314: LD_VAR 0 6
85318: PUSH
85319: LD_INT 2
85321: ARRAY
85322: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
85323: LD_ADDR_VAR 0 19
85327: PUSH
85328: LD_VAR 0 6
85332: PUSH
85333: LD_INT 3
85335: ARRAY
85336: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
85337: LD_ADDR_VAR 0 20
85341: PUSH
85342: LD_VAR 0 6
85346: PUSH
85347: LD_INT 4
85349: ARRAY
85350: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
85351: LD_ADDR_VAR 0 21
85355: PUSH
85356: LD_VAR 0 6
85360: PUSH
85361: LD_INT 5
85363: ARRAY
85364: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
85365: LD_ADDR_VAR 0 22
85369: PUSH
85370: LD_VAR 0 6
85374: PUSH
85375: LD_INT 6
85377: ARRAY
85378: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
85379: LD_ADDR_VAR 0 23
85383: PUSH
85384: LD_VAR 0 6
85388: PUSH
85389: LD_INT 7
85391: ARRAY
85392: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
85393: LD_ADDR_VAR 0 24
85397: PUSH
85398: LD_VAR 0 6
85402: PUSH
85403: LD_INT 8
85405: ARRAY
85406: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
85407: LD_ADDR_VAR 0 25
85411: PUSH
85412: LD_VAR 0 6
85416: PUSH
85417: LD_INT 9
85419: ARRAY
85420: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
85421: LD_ADDR_VAR 0 26
85425: PUSH
85426: LD_VAR 0 6
85430: PUSH
85431: LD_INT 10
85433: ARRAY
85434: ST_TO_ADDR
// end else
85435: GO 85517
// begin f_ignore_area := false ;
85437: LD_ADDR_VAR 0 17
85441: PUSH
85442: LD_INT 0
85444: ST_TO_ADDR
// f_capture := false ;
85445: LD_ADDR_VAR 0 18
85449: PUSH
85450: LD_INT 0
85452: ST_TO_ADDR
// f_ignore_civ := false ;
85453: LD_ADDR_VAR 0 19
85457: PUSH
85458: LD_INT 0
85460: ST_TO_ADDR
// f_murder := false ;
85461: LD_ADDR_VAR 0 20
85465: PUSH
85466: LD_INT 0
85468: ST_TO_ADDR
// f_mines := false ;
85469: LD_ADDR_VAR 0 21
85473: PUSH
85474: LD_INT 0
85476: ST_TO_ADDR
// f_repair := false ;
85477: LD_ADDR_VAR 0 22
85481: PUSH
85482: LD_INT 0
85484: ST_TO_ADDR
// f_heal := false ;
85485: LD_ADDR_VAR 0 23
85489: PUSH
85490: LD_INT 0
85492: ST_TO_ADDR
// f_spacetime := false ;
85493: LD_ADDR_VAR 0 24
85497: PUSH
85498: LD_INT 0
85500: ST_TO_ADDR
// f_attack_depot := false ;
85501: LD_ADDR_VAR 0 25
85505: PUSH
85506: LD_INT 0
85508: ST_TO_ADDR
// f_crawl := false ;
85509: LD_ADDR_VAR 0 26
85513: PUSH
85514: LD_INT 0
85516: ST_TO_ADDR
// end ; if f_heal then
85517: LD_VAR 0 23
85521: IFFALSE 85548
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
85523: LD_ADDR_VAR 0 31
85527: PUSH
85528: LD_VAR 0 4
85532: PPUSH
85533: LD_INT 25
85535: PUSH
85536: LD_INT 4
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: PPUSH
85543: CALL_OW 72
85547: ST_TO_ADDR
// if f_repair then
85548: LD_VAR 0 22
85552: IFFALSE 85579
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
85554: LD_ADDR_VAR 0 33
85558: PUSH
85559: LD_VAR 0 4
85563: PPUSH
85564: LD_INT 25
85566: PUSH
85567: LD_INT 3
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PPUSH
85574: CALL_OW 72
85578: ST_TO_ADDR
// units_path := [ ] ;
85579: LD_ADDR_VAR 0 16
85583: PUSH
85584: EMPTY
85585: ST_TO_ADDR
// for i = 1 to group do
85586: LD_ADDR_VAR 0 7
85590: PUSH
85591: DOUBLE
85592: LD_INT 1
85594: DEC
85595: ST_TO_ADDR
85596: LD_VAR 0 4
85600: PUSH
85601: FOR_TO
85602: IFFALSE 85631
// units_path := Replace ( units_path , i , path ) ;
85604: LD_ADDR_VAR 0 16
85608: PUSH
85609: LD_VAR 0 16
85613: PPUSH
85614: LD_VAR 0 7
85618: PPUSH
85619: LD_VAR 0 5
85623: PPUSH
85624: CALL_OW 1
85628: ST_TO_ADDR
85629: GO 85601
85631: POP
85632: POP
// repeat for i = group downto 1 do
85633: LD_ADDR_VAR 0 7
85637: PUSH
85638: DOUBLE
85639: LD_VAR 0 4
85643: INC
85644: ST_TO_ADDR
85645: LD_INT 1
85647: PUSH
85648: FOR_DOWNTO
85649: IFFALSE 89745
// begin wait ( 5 ) ;
85651: LD_INT 5
85653: PPUSH
85654: CALL_OW 67
// tmp := [ ] ;
85658: LD_ADDR_VAR 0 14
85662: PUSH
85663: EMPTY
85664: ST_TO_ADDR
// attacking := false ;
85665: LD_ADDR_VAR 0 29
85669: PUSH
85670: LD_INT 0
85672: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
85673: LD_VAR 0 4
85677: PUSH
85678: LD_VAR 0 7
85682: ARRAY
85683: PPUSH
85684: CALL_OW 301
85688: PUSH
85689: LD_VAR 0 4
85693: PUSH
85694: LD_VAR 0 7
85698: ARRAY
85699: NOT
85700: OR
85701: IFFALSE 85810
// begin if GetType ( group [ i ] ) = unit_human then
85703: LD_VAR 0 4
85707: PUSH
85708: LD_VAR 0 7
85712: ARRAY
85713: PPUSH
85714: CALL_OW 247
85718: PUSH
85719: LD_INT 1
85721: EQUAL
85722: IFFALSE 85768
// begin to_heal := to_heal diff group [ i ] ;
85724: LD_ADDR_VAR 0 30
85728: PUSH
85729: LD_VAR 0 30
85733: PUSH
85734: LD_VAR 0 4
85738: PUSH
85739: LD_VAR 0 7
85743: ARRAY
85744: DIFF
85745: ST_TO_ADDR
// healers := healers diff group [ i ] ;
85746: LD_ADDR_VAR 0 31
85750: PUSH
85751: LD_VAR 0 31
85755: PUSH
85756: LD_VAR 0 4
85760: PUSH
85761: LD_VAR 0 7
85765: ARRAY
85766: DIFF
85767: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
85768: LD_ADDR_VAR 0 4
85772: PUSH
85773: LD_VAR 0 4
85777: PPUSH
85778: LD_VAR 0 7
85782: PPUSH
85783: CALL_OW 3
85787: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
85788: LD_ADDR_VAR 0 16
85792: PUSH
85793: LD_VAR 0 16
85797: PPUSH
85798: LD_VAR 0 7
85802: PPUSH
85803: CALL_OW 3
85807: ST_TO_ADDR
// continue ;
85808: GO 85648
// end ; if f_repair then
85810: LD_VAR 0 22
85814: IFFALSE 86303
// begin if GetType ( group [ i ] ) = unit_vehicle then
85816: LD_VAR 0 4
85820: PUSH
85821: LD_VAR 0 7
85825: ARRAY
85826: PPUSH
85827: CALL_OW 247
85831: PUSH
85832: LD_INT 2
85834: EQUAL
85835: IFFALSE 86025
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
85837: LD_VAR 0 4
85841: PUSH
85842: LD_VAR 0 7
85846: ARRAY
85847: PPUSH
85848: CALL_OW 256
85852: PUSH
85853: LD_INT 700
85855: LESS
85856: PUSH
85857: LD_VAR 0 4
85861: PUSH
85862: LD_VAR 0 7
85866: ARRAY
85867: PUSH
85868: LD_VAR 0 32
85872: IN
85873: NOT
85874: AND
85875: IFFALSE 85899
// to_repair := to_repair union group [ i ] ;
85877: LD_ADDR_VAR 0 32
85881: PUSH
85882: LD_VAR 0 32
85886: PUSH
85887: LD_VAR 0 4
85891: PUSH
85892: LD_VAR 0 7
85896: ARRAY
85897: UNION
85898: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
85899: LD_VAR 0 4
85903: PUSH
85904: LD_VAR 0 7
85908: ARRAY
85909: PPUSH
85910: CALL_OW 256
85914: PUSH
85915: LD_INT 1000
85917: EQUAL
85918: PUSH
85919: LD_VAR 0 4
85923: PUSH
85924: LD_VAR 0 7
85928: ARRAY
85929: PUSH
85930: LD_VAR 0 32
85934: IN
85935: AND
85936: IFFALSE 85960
// to_repair := to_repair diff group [ i ] ;
85938: LD_ADDR_VAR 0 32
85942: PUSH
85943: LD_VAR 0 32
85947: PUSH
85948: LD_VAR 0 4
85952: PUSH
85953: LD_VAR 0 7
85957: ARRAY
85958: DIFF
85959: ST_TO_ADDR
// if group [ i ] in to_repair then
85960: LD_VAR 0 4
85964: PUSH
85965: LD_VAR 0 7
85969: ARRAY
85970: PUSH
85971: LD_VAR 0 32
85975: IN
85976: IFFALSE 86023
// begin if not IsInArea ( group [ i ] , f_repair ) then
85978: LD_VAR 0 4
85982: PUSH
85983: LD_VAR 0 7
85987: ARRAY
85988: PPUSH
85989: LD_VAR 0 22
85993: PPUSH
85994: CALL_OW 308
85998: NOT
85999: IFFALSE 86021
// ComMoveToArea ( group [ i ] , f_repair ) ;
86001: LD_VAR 0 4
86005: PUSH
86006: LD_VAR 0 7
86010: ARRAY
86011: PPUSH
86012: LD_VAR 0 22
86016: PPUSH
86017: CALL_OW 113
// continue ;
86021: GO 85648
// end ; end else
86023: GO 86303
// if group [ i ] in repairs then
86025: LD_VAR 0 4
86029: PUSH
86030: LD_VAR 0 7
86034: ARRAY
86035: PUSH
86036: LD_VAR 0 33
86040: IN
86041: IFFALSE 86303
// begin if IsInUnit ( group [ i ] ) then
86043: LD_VAR 0 4
86047: PUSH
86048: LD_VAR 0 7
86052: ARRAY
86053: PPUSH
86054: CALL_OW 310
86058: IFFALSE 86126
// begin z := IsInUnit ( group [ i ] ) ;
86060: LD_ADDR_VAR 0 13
86064: PUSH
86065: LD_VAR 0 4
86069: PUSH
86070: LD_VAR 0 7
86074: ARRAY
86075: PPUSH
86076: CALL_OW 310
86080: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
86081: LD_VAR 0 13
86085: PUSH
86086: LD_VAR 0 32
86090: IN
86091: PUSH
86092: LD_VAR 0 13
86096: PPUSH
86097: LD_VAR 0 22
86101: PPUSH
86102: CALL_OW 308
86106: AND
86107: IFFALSE 86124
// ComExitVehicle ( group [ i ] ) ;
86109: LD_VAR 0 4
86113: PUSH
86114: LD_VAR 0 7
86118: ARRAY
86119: PPUSH
86120: CALL_OW 121
// end else
86124: GO 86303
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
86126: LD_ADDR_VAR 0 13
86130: PUSH
86131: LD_VAR 0 4
86135: PPUSH
86136: LD_INT 95
86138: PUSH
86139: LD_VAR 0 22
86143: PUSH
86144: EMPTY
86145: LIST
86146: LIST
86147: PUSH
86148: LD_INT 58
86150: PUSH
86151: EMPTY
86152: LIST
86153: PUSH
86154: EMPTY
86155: LIST
86156: LIST
86157: PPUSH
86158: CALL_OW 72
86162: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
86163: LD_VAR 0 4
86167: PUSH
86168: LD_VAR 0 7
86172: ARRAY
86173: PPUSH
86174: CALL_OW 314
86178: NOT
86179: IFFALSE 86301
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
86181: LD_ADDR_VAR 0 10
86185: PUSH
86186: LD_VAR 0 13
86190: PPUSH
86191: LD_VAR 0 4
86195: PUSH
86196: LD_VAR 0 7
86200: ARRAY
86201: PPUSH
86202: CALL_OW 74
86206: ST_TO_ADDR
// if not x then
86207: LD_VAR 0 10
86211: NOT
86212: IFFALSE 86216
// continue ;
86214: GO 85648
// if GetLives ( x ) < 1000 then
86216: LD_VAR 0 10
86220: PPUSH
86221: CALL_OW 256
86225: PUSH
86226: LD_INT 1000
86228: LESS
86229: IFFALSE 86253
// ComRepairVehicle ( group [ i ] , x ) else
86231: LD_VAR 0 4
86235: PUSH
86236: LD_VAR 0 7
86240: ARRAY
86241: PPUSH
86242: LD_VAR 0 10
86246: PPUSH
86247: CALL_OW 129
86251: GO 86301
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
86253: LD_VAR 0 23
86257: PUSH
86258: LD_VAR 0 4
86262: PUSH
86263: LD_VAR 0 7
86267: ARRAY
86268: PPUSH
86269: CALL_OW 256
86273: PUSH
86274: LD_INT 1000
86276: LESS
86277: AND
86278: NOT
86279: IFFALSE 86301
// ComEnterUnit ( group [ i ] , x ) ;
86281: LD_VAR 0 4
86285: PUSH
86286: LD_VAR 0 7
86290: ARRAY
86291: PPUSH
86292: LD_VAR 0 10
86296: PPUSH
86297: CALL_OW 120
// end ; continue ;
86301: GO 85648
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
86303: LD_VAR 0 23
86307: PUSH
86308: LD_VAR 0 4
86312: PUSH
86313: LD_VAR 0 7
86317: ARRAY
86318: PPUSH
86319: CALL_OW 247
86323: PUSH
86324: LD_INT 1
86326: EQUAL
86327: AND
86328: IFFALSE 86806
// begin if group [ i ] in healers then
86330: LD_VAR 0 4
86334: PUSH
86335: LD_VAR 0 7
86339: ARRAY
86340: PUSH
86341: LD_VAR 0 31
86345: IN
86346: IFFALSE 86619
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
86348: LD_VAR 0 4
86352: PUSH
86353: LD_VAR 0 7
86357: ARRAY
86358: PPUSH
86359: LD_VAR 0 23
86363: PPUSH
86364: CALL_OW 308
86368: NOT
86369: PUSH
86370: LD_VAR 0 4
86374: PUSH
86375: LD_VAR 0 7
86379: ARRAY
86380: PPUSH
86381: CALL_OW 314
86385: NOT
86386: AND
86387: IFFALSE 86411
// ComMoveToArea ( group [ i ] , f_heal ) else
86389: LD_VAR 0 4
86393: PUSH
86394: LD_VAR 0 7
86398: ARRAY
86399: PPUSH
86400: LD_VAR 0 23
86404: PPUSH
86405: CALL_OW 113
86409: GO 86617
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
86411: LD_VAR 0 4
86415: PUSH
86416: LD_VAR 0 7
86420: ARRAY
86421: PPUSH
86422: CALL 85029 0 1
86426: PPUSH
86427: CALL_OW 256
86431: PUSH
86432: LD_INT 1000
86434: EQUAL
86435: IFFALSE 86454
// ComStop ( group [ i ] ) else
86437: LD_VAR 0 4
86441: PUSH
86442: LD_VAR 0 7
86446: ARRAY
86447: PPUSH
86448: CALL_OW 141
86452: GO 86617
// if not HasTask ( group [ i ] ) and to_heal then
86454: LD_VAR 0 4
86458: PUSH
86459: LD_VAR 0 7
86463: ARRAY
86464: PPUSH
86465: CALL_OW 314
86469: NOT
86470: PUSH
86471: LD_VAR 0 30
86475: AND
86476: IFFALSE 86617
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
86478: LD_ADDR_VAR 0 13
86482: PUSH
86483: LD_VAR 0 30
86487: PPUSH
86488: LD_INT 3
86490: PUSH
86491: LD_INT 54
86493: PUSH
86494: EMPTY
86495: LIST
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PPUSH
86501: CALL_OW 72
86505: PPUSH
86506: LD_VAR 0 4
86510: PUSH
86511: LD_VAR 0 7
86515: ARRAY
86516: PPUSH
86517: CALL_OW 74
86521: ST_TO_ADDR
// if z then
86522: LD_VAR 0 13
86526: IFFALSE 86617
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
86528: LD_INT 91
86530: PUSH
86531: LD_VAR 0 13
86535: PUSH
86536: LD_INT 10
86538: PUSH
86539: EMPTY
86540: LIST
86541: LIST
86542: LIST
86543: PUSH
86544: LD_INT 81
86546: PUSH
86547: LD_VAR 0 13
86551: PPUSH
86552: CALL_OW 255
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PPUSH
86565: CALL_OW 69
86569: PUSH
86570: LD_INT 0
86572: EQUAL
86573: IFFALSE 86597
// ComHeal ( group [ i ] , z ) else
86575: LD_VAR 0 4
86579: PUSH
86580: LD_VAR 0 7
86584: ARRAY
86585: PPUSH
86586: LD_VAR 0 13
86590: PPUSH
86591: CALL_OW 128
86595: GO 86617
// ComMoveToArea ( group [ i ] , f_heal ) ;
86597: LD_VAR 0 4
86601: PUSH
86602: LD_VAR 0 7
86606: ARRAY
86607: PPUSH
86608: LD_VAR 0 23
86612: PPUSH
86613: CALL_OW 113
// end ; continue ;
86617: GO 85648
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
86619: LD_VAR 0 4
86623: PUSH
86624: LD_VAR 0 7
86628: ARRAY
86629: PPUSH
86630: CALL_OW 256
86634: PUSH
86635: LD_INT 700
86637: LESS
86638: PUSH
86639: LD_VAR 0 4
86643: PUSH
86644: LD_VAR 0 7
86648: ARRAY
86649: PUSH
86650: LD_VAR 0 30
86654: IN
86655: NOT
86656: AND
86657: IFFALSE 86681
// to_heal := to_heal union group [ i ] ;
86659: LD_ADDR_VAR 0 30
86663: PUSH
86664: LD_VAR 0 30
86668: PUSH
86669: LD_VAR 0 4
86673: PUSH
86674: LD_VAR 0 7
86678: ARRAY
86679: UNION
86680: ST_TO_ADDR
// if group [ i ] in to_heal then
86681: LD_VAR 0 4
86685: PUSH
86686: LD_VAR 0 7
86690: ARRAY
86691: PUSH
86692: LD_VAR 0 30
86696: IN
86697: IFFALSE 86806
// begin if GetLives ( group [ i ] ) = 1000 then
86699: LD_VAR 0 4
86703: PUSH
86704: LD_VAR 0 7
86708: ARRAY
86709: PPUSH
86710: CALL_OW 256
86714: PUSH
86715: LD_INT 1000
86717: EQUAL
86718: IFFALSE 86744
// to_heal := to_heal diff group [ i ] else
86720: LD_ADDR_VAR 0 30
86724: PUSH
86725: LD_VAR 0 30
86729: PUSH
86730: LD_VAR 0 4
86734: PUSH
86735: LD_VAR 0 7
86739: ARRAY
86740: DIFF
86741: ST_TO_ADDR
86742: GO 86806
// begin if not IsInArea ( group [ i ] , to_heal ) then
86744: LD_VAR 0 4
86748: PUSH
86749: LD_VAR 0 7
86753: ARRAY
86754: PPUSH
86755: LD_VAR 0 30
86759: PPUSH
86760: CALL_OW 308
86764: NOT
86765: IFFALSE 86789
// ComMoveToArea ( group [ i ] , f_heal ) else
86767: LD_VAR 0 4
86771: PUSH
86772: LD_VAR 0 7
86776: ARRAY
86777: PPUSH
86778: LD_VAR 0 23
86782: PPUSH
86783: CALL_OW 113
86787: GO 86804
// ComHold ( group [ i ] ) ;
86789: LD_VAR 0 4
86793: PUSH
86794: LD_VAR 0 7
86798: ARRAY
86799: PPUSH
86800: CALL_OW 140
// continue ;
86804: GO 85648
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
86806: LD_VAR 0 4
86810: PUSH
86811: LD_VAR 0 7
86815: ARRAY
86816: PPUSH
86817: LD_INT 10
86819: PPUSH
86820: CALL 83426 0 2
86824: NOT
86825: PUSH
86826: LD_VAR 0 16
86830: PUSH
86831: LD_VAR 0 7
86835: ARRAY
86836: PUSH
86837: EMPTY
86838: EQUAL
86839: NOT
86840: AND
86841: IFFALSE 87107
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
86843: LD_VAR 0 4
86847: PUSH
86848: LD_VAR 0 7
86852: ARRAY
86853: PPUSH
86854: CALL_OW 262
86858: PUSH
86859: LD_INT 1
86861: PUSH
86862: LD_INT 2
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: IN
86869: IFFALSE 86910
// if GetFuel ( group [ i ] ) < 10 then
86871: LD_VAR 0 4
86875: PUSH
86876: LD_VAR 0 7
86880: ARRAY
86881: PPUSH
86882: CALL_OW 261
86886: PUSH
86887: LD_INT 10
86889: LESS
86890: IFFALSE 86910
// SetFuel ( group [ i ] , 12 ) ;
86892: LD_VAR 0 4
86896: PUSH
86897: LD_VAR 0 7
86901: ARRAY
86902: PPUSH
86903: LD_INT 12
86905: PPUSH
86906: CALL_OW 240
// if units_path [ i ] then
86910: LD_VAR 0 16
86914: PUSH
86915: LD_VAR 0 7
86919: ARRAY
86920: IFFALSE 87105
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
86922: LD_VAR 0 4
86926: PUSH
86927: LD_VAR 0 7
86931: ARRAY
86932: PPUSH
86933: LD_VAR 0 16
86937: PUSH
86938: LD_VAR 0 7
86942: ARRAY
86943: PUSH
86944: LD_INT 1
86946: ARRAY
86947: PUSH
86948: LD_INT 1
86950: ARRAY
86951: PPUSH
86952: LD_VAR 0 16
86956: PUSH
86957: LD_VAR 0 7
86961: ARRAY
86962: PUSH
86963: LD_INT 1
86965: ARRAY
86966: PUSH
86967: LD_INT 2
86969: ARRAY
86970: PPUSH
86971: CALL_OW 297
86975: PUSH
86976: LD_INT 6
86978: GREATER
86979: IFFALSE 87054
// begin if not HasTask ( group [ i ] ) then
86981: LD_VAR 0 4
86985: PUSH
86986: LD_VAR 0 7
86990: ARRAY
86991: PPUSH
86992: CALL_OW 314
86996: NOT
86997: IFFALSE 87052
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
86999: LD_VAR 0 4
87003: PUSH
87004: LD_VAR 0 7
87008: ARRAY
87009: PPUSH
87010: LD_VAR 0 16
87014: PUSH
87015: LD_VAR 0 7
87019: ARRAY
87020: PUSH
87021: LD_INT 1
87023: ARRAY
87024: PUSH
87025: LD_INT 1
87027: ARRAY
87028: PPUSH
87029: LD_VAR 0 16
87033: PUSH
87034: LD_VAR 0 7
87038: ARRAY
87039: PUSH
87040: LD_INT 1
87042: ARRAY
87043: PUSH
87044: LD_INT 2
87046: ARRAY
87047: PPUSH
87048: CALL_OW 114
// end else
87052: GO 87105
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
87054: LD_ADDR_VAR 0 15
87058: PUSH
87059: LD_VAR 0 16
87063: PUSH
87064: LD_VAR 0 7
87068: ARRAY
87069: PPUSH
87070: LD_INT 1
87072: PPUSH
87073: CALL_OW 3
87077: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
87078: LD_ADDR_VAR 0 16
87082: PUSH
87083: LD_VAR 0 16
87087: PPUSH
87088: LD_VAR 0 7
87092: PPUSH
87093: LD_VAR 0 15
87097: PPUSH
87098: CALL_OW 1
87102: ST_TO_ADDR
// continue ;
87103: GO 85648
// end ; end ; end else
87105: GO 89743
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
87107: LD_ADDR_VAR 0 14
87111: PUSH
87112: LD_INT 81
87114: PUSH
87115: LD_VAR 0 4
87119: PUSH
87120: LD_VAR 0 7
87124: ARRAY
87125: PPUSH
87126: CALL_OW 255
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PPUSH
87135: CALL_OW 69
87139: ST_TO_ADDR
// if not tmp then
87140: LD_VAR 0 14
87144: NOT
87145: IFFALSE 87149
// continue ;
87147: GO 85648
// if f_ignore_area then
87149: LD_VAR 0 17
87153: IFFALSE 87241
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
87155: LD_ADDR_VAR 0 15
87159: PUSH
87160: LD_VAR 0 14
87164: PPUSH
87165: LD_INT 3
87167: PUSH
87168: LD_INT 92
87170: PUSH
87171: LD_VAR 0 17
87175: PUSH
87176: LD_INT 1
87178: ARRAY
87179: PUSH
87180: LD_VAR 0 17
87184: PUSH
87185: LD_INT 2
87187: ARRAY
87188: PUSH
87189: LD_VAR 0 17
87193: PUSH
87194: LD_INT 3
87196: ARRAY
87197: PUSH
87198: EMPTY
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PPUSH
87208: CALL_OW 72
87212: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87213: LD_VAR 0 14
87217: PUSH
87218: LD_VAR 0 15
87222: DIFF
87223: IFFALSE 87241
// tmp := tmp diff tmp2 ;
87225: LD_ADDR_VAR 0 14
87229: PUSH
87230: LD_VAR 0 14
87234: PUSH
87235: LD_VAR 0 15
87239: DIFF
87240: ST_TO_ADDR
// end ; if not f_murder then
87241: LD_VAR 0 20
87245: NOT
87246: IFFALSE 87304
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
87248: LD_ADDR_VAR 0 15
87252: PUSH
87253: LD_VAR 0 14
87257: PPUSH
87258: LD_INT 3
87260: PUSH
87261: LD_INT 50
87263: PUSH
87264: EMPTY
87265: LIST
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: PPUSH
87271: CALL_OW 72
87275: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87276: LD_VAR 0 14
87280: PUSH
87281: LD_VAR 0 15
87285: DIFF
87286: IFFALSE 87304
// tmp := tmp diff tmp2 ;
87288: LD_ADDR_VAR 0 14
87292: PUSH
87293: LD_VAR 0 14
87297: PUSH
87298: LD_VAR 0 15
87302: DIFF
87303: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
87304: LD_ADDR_VAR 0 14
87308: PUSH
87309: LD_VAR 0 4
87313: PUSH
87314: LD_VAR 0 7
87318: ARRAY
87319: PPUSH
87320: LD_VAR 0 14
87324: PPUSH
87325: LD_INT 1
87327: PPUSH
87328: LD_INT 1
87330: PPUSH
87331: CALL 57069 0 4
87335: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
87336: LD_VAR 0 4
87340: PUSH
87341: LD_VAR 0 7
87345: ARRAY
87346: PPUSH
87347: CALL_OW 257
87351: PUSH
87352: LD_INT 1
87354: EQUAL
87355: IFFALSE 87803
// begin if WantPlant ( group [ i ] ) then
87357: LD_VAR 0 4
87361: PUSH
87362: LD_VAR 0 7
87366: ARRAY
87367: PPUSH
87368: CALL 56570 0 1
87372: IFFALSE 87376
// continue ;
87374: GO 85648
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
87376: LD_VAR 0 18
87380: PUSH
87381: LD_VAR 0 4
87385: PUSH
87386: LD_VAR 0 7
87390: ARRAY
87391: PPUSH
87392: CALL_OW 310
87396: NOT
87397: AND
87398: PUSH
87399: LD_VAR 0 14
87403: PUSH
87404: LD_INT 1
87406: ARRAY
87407: PUSH
87408: LD_VAR 0 14
87412: PPUSH
87413: LD_INT 21
87415: PUSH
87416: LD_INT 2
87418: PUSH
87419: EMPTY
87420: LIST
87421: LIST
87422: PUSH
87423: LD_INT 58
87425: PUSH
87426: EMPTY
87427: LIST
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PPUSH
87433: CALL_OW 72
87437: IN
87438: AND
87439: IFFALSE 87475
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
87441: LD_VAR 0 4
87445: PUSH
87446: LD_VAR 0 7
87450: ARRAY
87451: PPUSH
87452: LD_VAR 0 14
87456: PUSH
87457: LD_INT 1
87459: ARRAY
87460: PPUSH
87461: CALL_OW 120
// attacking := true ;
87465: LD_ADDR_VAR 0 29
87469: PUSH
87470: LD_INT 1
87472: ST_TO_ADDR
// continue ;
87473: GO 85648
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
87475: LD_VAR 0 26
87479: PUSH
87480: LD_VAR 0 4
87484: PUSH
87485: LD_VAR 0 7
87489: ARRAY
87490: PPUSH
87491: CALL_OW 257
87495: PUSH
87496: LD_INT 1
87498: EQUAL
87499: AND
87500: PUSH
87501: LD_VAR 0 4
87505: PUSH
87506: LD_VAR 0 7
87510: ARRAY
87511: PPUSH
87512: CALL_OW 256
87516: PUSH
87517: LD_INT 800
87519: LESS
87520: AND
87521: PUSH
87522: LD_VAR 0 4
87526: PUSH
87527: LD_VAR 0 7
87531: ARRAY
87532: PPUSH
87533: CALL_OW 318
87537: NOT
87538: AND
87539: IFFALSE 87556
// ComCrawl ( group [ i ] ) ;
87541: LD_VAR 0 4
87545: PUSH
87546: LD_VAR 0 7
87550: ARRAY
87551: PPUSH
87552: CALL_OW 137
// if f_mines then
87556: LD_VAR 0 21
87560: IFFALSE 87803
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
87562: LD_VAR 0 14
87566: PUSH
87567: LD_INT 1
87569: ARRAY
87570: PPUSH
87571: CALL_OW 247
87575: PUSH
87576: LD_INT 3
87578: EQUAL
87579: PUSH
87580: LD_VAR 0 14
87584: PUSH
87585: LD_INT 1
87587: ARRAY
87588: PUSH
87589: LD_VAR 0 27
87593: IN
87594: NOT
87595: AND
87596: IFFALSE 87803
// begin x := GetX ( tmp [ 1 ] ) ;
87598: LD_ADDR_VAR 0 10
87602: PUSH
87603: LD_VAR 0 14
87607: PUSH
87608: LD_INT 1
87610: ARRAY
87611: PPUSH
87612: CALL_OW 250
87616: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
87617: LD_ADDR_VAR 0 11
87621: PUSH
87622: LD_VAR 0 14
87626: PUSH
87627: LD_INT 1
87629: ARRAY
87630: PPUSH
87631: CALL_OW 251
87635: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
87636: LD_ADDR_VAR 0 12
87640: PUSH
87641: LD_VAR 0 4
87645: PUSH
87646: LD_VAR 0 7
87650: ARRAY
87651: PPUSH
87652: CALL 83511 0 1
87656: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
87657: LD_VAR 0 4
87661: PUSH
87662: LD_VAR 0 7
87666: ARRAY
87667: PPUSH
87668: LD_VAR 0 10
87672: PPUSH
87673: LD_VAR 0 11
87677: PPUSH
87678: LD_VAR 0 14
87682: PUSH
87683: LD_INT 1
87685: ARRAY
87686: PPUSH
87687: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
87691: LD_VAR 0 4
87695: PUSH
87696: LD_VAR 0 7
87700: ARRAY
87701: PPUSH
87702: LD_VAR 0 10
87706: PPUSH
87707: LD_VAR 0 12
87711: PPUSH
87712: LD_INT 7
87714: PPUSH
87715: CALL_OW 272
87719: PPUSH
87720: LD_VAR 0 11
87724: PPUSH
87725: LD_VAR 0 12
87729: PPUSH
87730: LD_INT 7
87732: PPUSH
87733: CALL_OW 273
87737: PPUSH
87738: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
87742: LD_VAR 0 4
87746: PUSH
87747: LD_VAR 0 7
87751: ARRAY
87752: PPUSH
87753: LD_INT 71
87755: PPUSH
87756: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
87760: LD_ADDR_VAR 0 27
87764: PUSH
87765: LD_VAR 0 27
87769: PPUSH
87770: LD_VAR 0 27
87774: PUSH
87775: LD_INT 1
87777: PLUS
87778: PPUSH
87779: LD_VAR 0 14
87783: PUSH
87784: LD_INT 1
87786: ARRAY
87787: PPUSH
87788: CALL_OW 1
87792: ST_TO_ADDR
// attacking := true ;
87793: LD_ADDR_VAR 0 29
87797: PUSH
87798: LD_INT 1
87800: ST_TO_ADDR
// continue ;
87801: GO 85648
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
87803: LD_VAR 0 4
87807: PUSH
87808: LD_VAR 0 7
87812: ARRAY
87813: PPUSH
87814: CALL_OW 257
87818: PUSH
87819: LD_INT 17
87821: EQUAL
87822: PUSH
87823: LD_VAR 0 4
87827: PUSH
87828: LD_VAR 0 7
87832: ARRAY
87833: PPUSH
87834: CALL_OW 110
87838: PUSH
87839: LD_INT 71
87841: EQUAL
87842: NOT
87843: AND
87844: IFFALSE 87990
// begin attacking := false ;
87846: LD_ADDR_VAR 0 29
87850: PUSH
87851: LD_INT 0
87853: ST_TO_ADDR
// k := 5 ;
87854: LD_ADDR_VAR 0 9
87858: PUSH
87859: LD_INT 5
87861: ST_TO_ADDR
// if tmp < k then
87862: LD_VAR 0 14
87866: PUSH
87867: LD_VAR 0 9
87871: LESS
87872: IFFALSE 87884
// k := tmp ;
87874: LD_ADDR_VAR 0 9
87878: PUSH
87879: LD_VAR 0 14
87883: ST_TO_ADDR
// for j = 1 to k do
87884: LD_ADDR_VAR 0 8
87888: PUSH
87889: DOUBLE
87890: LD_INT 1
87892: DEC
87893: ST_TO_ADDR
87894: LD_VAR 0 9
87898: PUSH
87899: FOR_TO
87900: IFFALSE 87988
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
87902: LD_VAR 0 14
87906: PUSH
87907: LD_VAR 0 8
87911: ARRAY
87912: PUSH
87913: LD_VAR 0 14
87917: PPUSH
87918: LD_INT 58
87920: PUSH
87921: EMPTY
87922: LIST
87923: PPUSH
87924: CALL_OW 72
87928: IN
87929: NOT
87930: IFFALSE 87986
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87932: LD_VAR 0 4
87936: PUSH
87937: LD_VAR 0 7
87941: ARRAY
87942: PPUSH
87943: LD_VAR 0 14
87947: PUSH
87948: LD_VAR 0 8
87952: ARRAY
87953: PPUSH
87954: CALL_OW 115
// attacking := true ;
87958: LD_ADDR_VAR 0 29
87962: PUSH
87963: LD_INT 1
87965: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
87966: LD_VAR 0 4
87970: PUSH
87971: LD_VAR 0 7
87975: ARRAY
87976: PPUSH
87977: LD_INT 71
87979: PPUSH
87980: CALL_OW 109
// continue ;
87984: GO 87899
// end ; end ;
87986: GO 87899
87988: POP
87989: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
87990: LD_VAR 0 4
87994: PUSH
87995: LD_VAR 0 7
87999: ARRAY
88000: PPUSH
88001: CALL_OW 257
88005: PUSH
88006: LD_INT 8
88008: EQUAL
88009: PUSH
88010: LD_VAR 0 4
88014: PUSH
88015: LD_VAR 0 7
88019: ARRAY
88020: PPUSH
88021: CALL_OW 264
88025: PUSH
88026: LD_INT 28
88028: PUSH
88029: LD_INT 45
88031: PUSH
88032: LD_INT 7
88034: PUSH
88035: LD_INT 47
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: IN
88044: OR
88045: IFFALSE 88275
// begin attacking := false ;
88047: LD_ADDR_VAR 0 29
88051: PUSH
88052: LD_INT 0
88054: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
88055: LD_VAR 0 14
88059: PUSH
88060: LD_INT 1
88062: ARRAY
88063: PPUSH
88064: CALL_OW 266
88068: PUSH
88069: LD_INT 32
88071: PUSH
88072: LD_INT 31
88074: PUSH
88075: LD_INT 33
88077: PUSH
88078: LD_INT 4
88080: PUSH
88081: LD_INT 5
88083: PUSH
88084: EMPTY
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: IN
88091: IFFALSE 88275
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
88093: LD_ADDR_VAR 0 9
88097: PUSH
88098: LD_VAR 0 14
88102: PUSH
88103: LD_INT 1
88105: ARRAY
88106: PPUSH
88107: CALL_OW 266
88111: PPUSH
88112: LD_VAR 0 14
88116: PUSH
88117: LD_INT 1
88119: ARRAY
88120: PPUSH
88121: CALL_OW 250
88125: PPUSH
88126: LD_VAR 0 14
88130: PUSH
88131: LD_INT 1
88133: ARRAY
88134: PPUSH
88135: CALL_OW 251
88139: PPUSH
88140: LD_VAR 0 14
88144: PUSH
88145: LD_INT 1
88147: ARRAY
88148: PPUSH
88149: CALL_OW 254
88153: PPUSH
88154: LD_VAR 0 14
88158: PUSH
88159: LD_INT 1
88161: ARRAY
88162: PPUSH
88163: CALL_OW 248
88167: PPUSH
88168: LD_INT 0
88170: PPUSH
88171: CALL 64881 0 6
88175: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
88176: LD_ADDR_VAR 0 8
88180: PUSH
88181: LD_VAR 0 4
88185: PUSH
88186: LD_VAR 0 7
88190: ARRAY
88191: PPUSH
88192: LD_VAR 0 9
88196: PPUSH
88197: CALL 83574 0 2
88201: ST_TO_ADDR
// if j then
88202: LD_VAR 0 8
88206: IFFALSE 88275
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
88208: LD_VAR 0 8
88212: PUSH
88213: LD_INT 1
88215: ARRAY
88216: PPUSH
88217: LD_VAR 0 8
88221: PUSH
88222: LD_INT 2
88224: ARRAY
88225: PPUSH
88226: CALL_OW 488
88230: IFFALSE 88275
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
88232: LD_VAR 0 4
88236: PUSH
88237: LD_VAR 0 7
88241: ARRAY
88242: PPUSH
88243: LD_VAR 0 8
88247: PUSH
88248: LD_INT 1
88250: ARRAY
88251: PPUSH
88252: LD_VAR 0 8
88256: PUSH
88257: LD_INT 2
88259: ARRAY
88260: PPUSH
88261: CALL_OW 116
// attacking := true ;
88265: LD_ADDR_VAR 0 29
88269: PUSH
88270: LD_INT 1
88272: ST_TO_ADDR
// continue ;
88273: GO 85648
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
88275: LD_VAR 0 4
88279: PUSH
88280: LD_VAR 0 7
88284: ARRAY
88285: PPUSH
88286: CALL_OW 265
88290: PUSH
88291: LD_INT 11
88293: EQUAL
88294: IFFALSE 88572
// begin k := 10 ;
88296: LD_ADDR_VAR 0 9
88300: PUSH
88301: LD_INT 10
88303: ST_TO_ADDR
// x := 0 ;
88304: LD_ADDR_VAR 0 10
88308: PUSH
88309: LD_INT 0
88311: ST_TO_ADDR
// if tmp < k then
88312: LD_VAR 0 14
88316: PUSH
88317: LD_VAR 0 9
88321: LESS
88322: IFFALSE 88334
// k := tmp ;
88324: LD_ADDR_VAR 0 9
88328: PUSH
88329: LD_VAR 0 14
88333: ST_TO_ADDR
// for j = k downto 1 do
88334: LD_ADDR_VAR 0 8
88338: PUSH
88339: DOUBLE
88340: LD_VAR 0 9
88344: INC
88345: ST_TO_ADDR
88346: LD_INT 1
88348: PUSH
88349: FOR_DOWNTO
88350: IFFALSE 88425
// begin if GetType ( tmp [ j ] ) = unit_human then
88352: LD_VAR 0 14
88356: PUSH
88357: LD_VAR 0 8
88361: ARRAY
88362: PPUSH
88363: CALL_OW 247
88367: PUSH
88368: LD_INT 1
88370: EQUAL
88371: IFFALSE 88423
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
88373: LD_VAR 0 4
88377: PUSH
88378: LD_VAR 0 7
88382: ARRAY
88383: PPUSH
88384: LD_VAR 0 14
88388: PUSH
88389: LD_VAR 0 8
88393: ARRAY
88394: PPUSH
88395: CALL 83845 0 2
// x := tmp [ j ] ;
88399: LD_ADDR_VAR 0 10
88403: PUSH
88404: LD_VAR 0 14
88408: PUSH
88409: LD_VAR 0 8
88413: ARRAY
88414: ST_TO_ADDR
// attacking := true ;
88415: LD_ADDR_VAR 0 29
88419: PUSH
88420: LD_INT 1
88422: ST_TO_ADDR
// end ; end ;
88423: GO 88349
88425: POP
88426: POP
// if not x then
88427: LD_VAR 0 10
88431: NOT
88432: IFFALSE 88572
// begin attacking := true ;
88434: LD_ADDR_VAR 0 29
88438: PUSH
88439: LD_INT 1
88441: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
88442: LD_VAR 0 4
88446: PUSH
88447: LD_VAR 0 7
88451: ARRAY
88452: PPUSH
88453: CALL_OW 250
88457: PPUSH
88458: LD_VAR 0 4
88462: PUSH
88463: LD_VAR 0 7
88467: ARRAY
88468: PPUSH
88469: CALL_OW 251
88473: PPUSH
88474: CALL_OW 546
88478: PUSH
88479: LD_INT 2
88481: ARRAY
88482: PUSH
88483: LD_VAR 0 14
88487: PUSH
88488: LD_INT 1
88490: ARRAY
88491: PPUSH
88492: CALL_OW 250
88496: PPUSH
88497: LD_VAR 0 14
88501: PUSH
88502: LD_INT 1
88504: ARRAY
88505: PPUSH
88506: CALL_OW 251
88510: PPUSH
88511: CALL_OW 546
88515: PUSH
88516: LD_INT 2
88518: ARRAY
88519: EQUAL
88520: IFFALSE 88548
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
88522: LD_VAR 0 4
88526: PUSH
88527: LD_VAR 0 7
88531: ARRAY
88532: PPUSH
88533: LD_VAR 0 14
88537: PUSH
88538: LD_INT 1
88540: ARRAY
88541: PPUSH
88542: CALL 83845 0 2
88546: GO 88572
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88548: LD_VAR 0 4
88552: PUSH
88553: LD_VAR 0 7
88557: ARRAY
88558: PPUSH
88559: LD_VAR 0 14
88563: PUSH
88564: LD_INT 1
88566: ARRAY
88567: PPUSH
88568: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
88572: LD_VAR 0 4
88576: PUSH
88577: LD_VAR 0 7
88581: ARRAY
88582: PPUSH
88583: CALL_OW 264
88587: PUSH
88588: LD_INT 29
88590: EQUAL
88591: IFFALSE 88957
// begin if WantsToAttack ( group [ i ] ) in bombed then
88593: LD_VAR 0 4
88597: PUSH
88598: LD_VAR 0 7
88602: ARRAY
88603: PPUSH
88604: CALL_OW 319
88608: PUSH
88609: LD_VAR 0 28
88613: IN
88614: IFFALSE 88618
// continue ;
88616: GO 85648
// k := 8 ;
88618: LD_ADDR_VAR 0 9
88622: PUSH
88623: LD_INT 8
88625: ST_TO_ADDR
// x := 0 ;
88626: LD_ADDR_VAR 0 10
88630: PUSH
88631: LD_INT 0
88633: ST_TO_ADDR
// if tmp < k then
88634: LD_VAR 0 14
88638: PUSH
88639: LD_VAR 0 9
88643: LESS
88644: IFFALSE 88656
// k := tmp ;
88646: LD_ADDR_VAR 0 9
88650: PUSH
88651: LD_VAR 0 14
88655: ST_TO_ADDR
// for j = 1 to k do
88656: LD_ADDR_VAR 0 8
88660: PUSH
88661: DOUBLE
88662: LD_INT 1
88664: DEC
88665: ST_TO_ADDR
88666: LD_VAR 0 9
88670: PUSH
88671: FOR_TO
88672: IFFALSE 88804
// begin if GetType ( tmp [ j ] ) = unit_building then
88674: LD_VAR 0 14
88678: PUSH
88679: LD_VAR 0 8
88683: ARRAY
88684: PPUSH
88685: CALL_OW 247
88689: PUSH
88690: LD_INT 3
88692: EQUAL
88693: IFFALSE 88802
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
88695: LD_VAR 0 14
88699: PUSH
88700: LD_VAR 0 8
88704: ARRAY
88705: PUSH
88706: LD_VAR 0 28
88710: IN
88711: NOT
88712: PUSH
88713: LD_VAR 0 14
88717: PUSH
88718: LD_VAR 0 8
88722: ARRAY
88723: PPUSH
88724: CALL_OW 313
88728: AND
88729: IFFALSE 88802
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88731: LD_VAR 0 4
88735: PUSH
88736: LD_VAR 0 7
88740: ARRAY
88741: PPUSH
88742: LD_VAR 0 14
88746: PUSH
88747: LD_VAR 0 8
88751: ARRAY
88752: PPUSH
88753: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
88757: LD_ADDR_VAR 0 28
88761: PUSH
88762: LD_VAR 0 28
88766: PPUSH
88767: LD_VAR 0 28
88771: PUSH
88772: LD_INT 1
88774: PLUS
88775: PPUSH
88776: LD_VAR 0 14
88780: PUSH
88781: LD_VAR 0 8
88785: ARRAY
88786: PPUSH
88787: CALL_OW 1
88791: ST_TO_ADDR
// attacking := true ;
88792: LD_ADDR_VAR 0 29
88796: PUSH
88797: LD_INT 1
88799: ST_TO_ADDR
// break ;
88800: GO 88804
// end ; end ;
88802: GO 88671
88804: POP
88805: POP
// if not attacking and f_attack_depot then
88806: LD_VAR 0 29
88810: NOT
88811: PUSH
88812: LD_VAR 0 25
88816: AND
88817: IFFALSE 88912
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88819: LD_ADDR_VAR 0 13
88823: PUSH
88824: LD_VAR 0 14
88828: PPUSH
88829: LD_INT 2
88831: PUSH
88832: LD_INT 30
88834: PUSH
88835: LD_INT 0
88837: PUSH
88838: EMPTY
88839: LIST
88840: LIST
88841: PUSH
88842: LD_INT 30
88844: PUSH
88845: LD_INT 1
88847: PUSH
88848: EMPTY
88849: LIST
88850: LIST
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: LIST
88856: PPUSH
88857: CALL_OW 72
88861: ST_TO_ADDR
// if z then
88862: LD_VAR 0 13
88866: IFFALSE 88912
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
88868: LD_VAR 0 4
88872: PUSH
88873: LD_VAR 0 7
88877: ARRAY
88878: PPUSH
88879: LD_VAR 0 13
88883: PPUSH
88884: LD_VAR 0 4
88888: PUSH
88889: LD_VAR 0 7
88893: ARRAY
88894: PPUSH
88895: CALL_OW 74
88899: PPUSH
88900: CALL_OW 115
// attacking := true ;
88904: LD_ADDR_VAR 0 29
88908: PUSH
88909: LD_INT 1
88911: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
88912: LD_VAR 0 4
88916: PUSH
88917: LD_VAR 0 7
88921: ARRAY
88922: PPUSH
88923: CALL_OW 256
88927: PUSH
88928: LD_INT 500
88930: LESS
88931: IFFALSE 88957
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88933: LD_VAR 0 4
88937: PUSH
88938: LD_VAR 0 7
88942: ARRAY
88943: PPUSH
88944: LD_VAR 0 14
88948: PUSH
88949: LD_INT 1
88951: ARRAY
88952: PPUSH
88953: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
88957: LD_VAR 0 4
88961: PUSH
88962: LD_VAR 0 7
88966: ARRAY
88967: PPUSH
88968: CALL_OW 264
88972: PUSH
88973: LD_INT 49
88975: EQUAL
88976: IFFALSE 89097
// begin if not HasTask ( group [ i ] ) then
88978: LD_VAR 0 4
88982: PUSH
88983: LD_VAR 0 7
88987: ARRAY
88988: PPUSH
88989: CALL_OW 314
88993: NOT
88994: IFFALSE 89097
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
88996: LD_ADDR_VAR 0 9
89000: PUSH
89001: LD_INT 81
89003: PUSH
89004: LD_VAR 0 4
89008: PUSH
89009: LD_VAR 0 7
89013: ARRAY
89014: PPUSH
89015: CALL_OW 255
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PPUSH
89024: CALL_OW 69
89028: PPUSH
89029: LD_VAR 0 4
89033: PUSH
89034: LD_VAR 0 7
89038: ARRAY
89039: PPUSH
89040: CALL_OW 74
89044: ST_TO_ADDR
// if k then
89045: LD_VAR 0 9
89049: IFFALSE 89097
// if GetDistUnits ( group [ i ] , k ) > 10 then
89051: LD_VAR 0 4
89055: PUSH
89056: LD_VAR 0 7
89060: ARRAY
89061: PPUSH
89062: LD_VAR 0 9
89066: PPUSH
89067: CALL_OW 296
89071: PUSH
89072: LD_INT 10
89074: GREATER
89075: IFFALSE 89097
// ComMoveUnit ( group [ i ] , k ) ;
89077: LD_VAR 0 4
89081: PUSH
89082: LD_VAR 0 7
89086: ARRAY
89087: PPUSH
89088: LD_VAR 0 9
89092: PPUSH
89093: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
89097: LD_VAR 0 4
89101: PUSH
89102: LD_VAR 0 7
89106: ARRAY
89107: PPUSH
89108: CALL_OW 256
89112: PUSH
89113: LD_INT 250
89115: LESS
89116: PUSH
89117: LD_VAR 0 4
89121: PUSH
89122: LD_VAR 0 7
89126: ARRAY
89127: PUSH
89128: LD_INT 21
89130: PUSH
89131: LD_INT 2
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: LD_INT 23
89140: PUSH
89141: LD_INT 2
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PPUSH
89152: CALL_OW 69
89156: IN
89157: AND
89158: IFFALSE 89283
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
89160: LD_ADDR_VAR 0 9
89164: PUSH
89165: LD_OWVAR 3
89169: PUSH
89170: LD_VAR 0 4
89174: PUSH
89175: LD_VAR 0 7
89179: ARRAY
89180: DIFF
89181: PPUSH
89182: LD_VAR 0 4
89186: PUSH
89187: LD_VAR 0 7
89191: ARRAY
89192: PPUSH
89193: CALL_OW 74
89197: ST_TO_ADDR
// if not k then
89198: LD_VAR 0 9
89202: NOT
89203: IFFALSE 89207
// continue ;
89205: GO 85648
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
89207: LD_VAR 0 9
89211: PUSH
89212: LD_INT 81
89214: PUSH
89215: LD_VAR 0 4
89219: PUSH
89220: LD_VAR 0 7
89224: ARRAY
89225: PPUSH
89226: CALL_OW 255
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: PPUSH
89235: CALL_OW 69
89239: IN
89240: PUSH
89241: LD_VAR 0 9
89245: PPUSH
89246: LD_VAR 0 4
89250: PUSH
89251: LD_VAR 0 7
89255: ARRAY
89256: PPUSH
89257: CALL_OW 296
89261: PUSH
89262: LD_INT 5
89264: LESS
89265: AND
89266: IFFALSE 89283
// ComAutodestruct ( group [ i ] ) ;
89268: LD_VAR 0 4
89272: PUSH
89273: LD_VAR 0 7
89277: ARRAY
89278: PPUSH
89279: CALL 83743 0 1
// end ; if f_attack_depot then
89283: LD_VAR 0 25
89287: IFFALSE 89399
// begin k := 6 ;
89289: LD_ADDR_VAR 0 9
89293: PUSH
89294: LD_INT 6
89296: ST_TO_ADDR
// if tmp < k then
89297: LD_VAR 0 14
89301: PUSH
89302: LD_VAR 0 9
89306: LESS
89307: IFFALSE 89319
// k := tmp ;
89309: LD_ADDR_VAR 0 9
89313: PUSH
89314: LD_VAR 0 14
89318: ST_TO_ADDR
// for j = 1 to k do
89319: LD_ADDR_VAR 0 8
89323: PUSH
89324: DOUBLE
89325: LD_INT 1
89327: DEC
89328: ST_TO_ADDR
89329: LD_VAR 0 9
89333: PUSH
89334: FOR_TO
89335: IFFALSE 89397
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
89337: LD_VAR 0 8
89341: PPUSH
89342: CALL_OW 266
89346: PUSH
89347: LD_INT 0
89349: PUSH
89350: LD_INT 1
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: IN
89357: IFFALSE 89395
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89359: LD_VAR 0 4
89363: PUSH
89364: LD_VAR 0 7
89368: ARRAY
89369: PPUSH
89370: LD_VAR 0 14
89374: PUSH
89375: LD_VAR 0 8
89379: ARRAY
89380: PPUSH
89381: CALL_OW 115
// attacking := true ;
89385: LD_ADDR_VAR 0 29
89389: PUSH
89390: LD_INT 1
89392: ST_TO_ADDR
// break ;
89393: GO 89397
// end ;
89395: GO 89334
89397: POP
89398: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
89399: LD_VAR 0 4
89403: PUSH
89404: LD_VAR 0 7
89408: ARRAY
89409: PPUSH
89410: CALL_OW 302
89414: PUSH
89415: LD_VAR 0 29
89419: NOT
89420: AND
89421: IFFALSE 89743
// begin if GetTag ( group [ i ] ) = 71 then
89423: LD_VAR 0 4
89427: PUSH
89428: LD_VAR 0 7
89432: ARRAY
89433: PPUSH
89434: CALL_OW 110
89438: PUSH
89439: LD_INT 71
89441: EQUAL
89442: IFFALSE 89483
// begin if HasTask ( group [ i ] ) then
89444: LD_VAR 0 4
89448: PUSH
89449: LD_VAR 0 7
89453: ARRAY
89454: PPUSH
89455: CALL_OW 314
89459: IFFALSE 89465
// continue else
89461: GO 85648
89463: GO 89483
// SetTag ( group [ i ] , 0 ) ;
89465: LD_VAR 0 4
89469: PUSH
89470: LD_VAR 0 7
89474: ARRAY
89475: PPUSH
89476: LD_INT 0
89478: PPUSH
89479: CALL_OW 109
// end ; k := 8 ;
89483: LD_ADDR_VAR 0 9
89487: PUSH
89488: LD_INT 8
89490: ST_TO_ADDR
// x := 0 ;
89491: LD_ADDR_VAR 0 10
89495: PUSH
89496: LD_INT 0
89498: ST_TO_ADDR
// if tmp < k then
89499: LD_VAR 0 14
89503: PUSH
89504: LD_VAR 0 9
89508: LESS
89509: IFFALSE 89521
// k := tmp ;
89511: LD_ADDR_VAR 0 9
89515: PUSH
89516: LD_VAR 0 14
89520: ST_TO_ADDR
// for j = 1 to k do
89521: LD_ADDR_VAR 0 8
89525: PUSH
89526: DOUBLE
89527: LD_INT 1
89529: DEC
89530: ST_TO_ADDR
89531: LD_VAR 0 9
89535: PUSH
89536: FOR_TO
89537: IFFALSE 89635
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
89539: LD_VAR 0 14
89543: PUSH
89544: LD_VAR 0 8
89548: ARRAY
89549: PPUSH
89550: CALL_OW 247
89554: PUSH
89555: LD_INT 1
89557: EQUAL
89558: PUSH
89559: LD_VAR 0 14
89563: PUSH
89564: LD_VAR 0 8
89568: ARRAY
89569: PPUSH
89570: CALL_OW 256
89574: PUSH
89575: LD_INT 250
89577: LESS
89578: PUSH
89579: LD_VAR 0 20
89583: AND
89584: PUSH
89585: LD_VAR 0 20
89589: NOT
89590: PUSH
89591: LD_VAR 0 14
89595: PUSH
89596: LD_VAR 0 8
89600: ARRAY
89601: PPUSH
89602: CALL_OW 256
89606: PUSH
89607: LD_INT 250
89609: GREATEREQUAL
89610: AND
89611: OR
89612: AND
89613: IFFALSE 89633
// begin x := tmp [ j ] ;
89615: LD_ADDR_VAR 0 10
89619: PUSH
89620: LD_VAR 0 14
89624: PUSH
89625: LD_VAR 0 8
89629: ARRAY
89630: ST_TO_ADDR
// break ;
89631: GO 89635
// end ;
89633: GO 89536
89635: POP
89636: POP
// if x then
89637: LD_VAR 0 10
89641: IFFALSE 89665
// ComAttackUnit ( group [ i ] , x ) else
89643: LD_VAR 0 4
89647: PUSH
89648: LD_VAR 0 7
89652: ARRAY
89653: PPUSH
89654: LD_VAR 0 10
89658: PPUSH
89659: CALL_OW 115
89663: GO 89689
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89665: LD_VAR 0 4
89669: PUSH
89670: LD_VAR 0 7
89674: ARRAY
89675: PPUSH
89676: LD_VAR 0 14
89680: PUSH
89681: LD_INT 1
89683: ARRAY
89684: PPUSH
89685: CALL_OW 115
// if not HasTask ( group [ i ] ) then
89689: LD_VAR 0 4
89693: PUSH
89694: LD_VAR 0 7
89698: ARRAY
89699: PPUSH
89700: CALL_OW 314
89704: NOT
89705: IFFALSE 89743
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
89707: LD_VAR 0 4
89711: PUSH
89712: LD_VAR 0 7
89716: ARRAY
89717: PPUSH
89718: LD_VAR 0 14
89722: PPUSH
89723: LD_VAR 0 4
89727: PUSH
89728: LD_VAR 0 7
89732: ARRAY
89733: PPUSH
89734: CALL_OW 74
89738: PPUSH
89739: CALL_OW 115
// end ; end ; end ;
89743: GO 85648
89745: POP
89746: POP
// wait ( 0 0$1 ) ;
89747: LD_INT 35
89749: PPUSH
89750: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
89754: LD_VAR 0 4
89758: PUSH
89759: EMPTY
89760: EQUAL
89761: PUSH
89762: LD_INT 81
89764: PUSH
89765: LD_VAR 0 35
89769: PUSH
89770: EMPTY
89771: LIST
89772: LIST
89773: PPUSH
89774: CALL_OW 69
89778: NOT
89779: OR
89780: IFFALSE 85633
// end ;
89782: LD_VAR 0 2
89786: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
89787: LD_INT 0
89789: PPUSH
89790: PPUSH
89791: PPUSH
89792: PPUSH
// if not base_units then
89793: LD_VAR 0 1
89797: NOT
89798: IFFALSE 89802
// exit ;
89800: GO 89889
// result := false ;
89802: LD_ADDR_VAR 0 2
89806: PUSH
89807: LD_INT 0
89809: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
89810: LD_ADDR_VAR 0 5
89814: PUSH
89815: LD_VAR 0 1
89819: PPUSH
89820: LD_INT 21
89822: PUSH
89823: LD_INT 3
89825: PUSH
89826: EMPTY
89827: LIST
89828: LIST
89829: PPUSH
89830: CALL_OW 72
89834: ST_TO_ADDR
// if not tmp then
89835: LD_VAR 0 5
89839: NOT
89840: IFFALSE 89844
// exit ;
89842: GO 89889
// for i in tmp do
89844: LD_ADDR_VAR 0 3
89848: PUSH
89849: LD_VAR 0 5
89853: PUSH
89854: FOR_IN
89855: IFFALSE 89887
// begin result := EnemyInRange ( i , 22 ) ;
89857: LD_ADDR_VAR 0 2
89861: PUSH
89862: LD_VAR 0 3
89866: PPUSH
89867: LD_INT 22
89869: PPUSH
89870: CALL 83426 0 2
89874: ST_TO_ADDR
// if result then
89875: LD_VAR 0 2
89879: IFFALSE 89885
// exit ;
89881: POP
89882: POP
89883: GO 89889
// end ;
89885: GO 89854
89887: POP
89888: POP
// end ;
89889: LD_VAR 0 2
89893: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
89894: LD_INT 0
89896: PPUSH
89897: PPUSH
// if not units then
89898: LD_VAR 0 1
89902: NOT
89903: IFFALSE 89907
// exit ;
89905: GO 89977
// result := [ ] ;
89907: LD_ADDR_VAR 0 3
89911: PUSH
89912: EMPTY
89913: ST_TO_ADDR
// for i in units do
89914: LD_ADDR_VAR 0 4
89918: PUSH
89919: LD_VAR 0 1
89923: PUSH
89924: FOR_IN
89925: IFFALSE 89975
// if GetTag ( i ) = tag then
89927: LD_VAR 0 4
89931: PPUSH
89932: CALL_OW 110
89936: PUSH
89937: LD_VAR 0 2
89941: EQUAL
89942: IFFALSE 89973
// result := Insert ( result , result + 1 , i ) ;
89944: LD_ADDR_VAR 0 3
89948: PUSH
89949: LD_VAR 0 3
89953: PPUSH
89954: LD_VAR 0 3
89958: PUSH
89959: LD_INT 1
89961: PLUS
89962: PPUSH
89963: LD_VAR 0 4
89967: PPUSH
89968: CALL_OW 2
89972: ST_TO_ADDR
89973: GO 89924
89975: POP
89976: POP
// end ;
89977: LD_VAR 0 3
89981: RET
// export function IsDriver ( un ) ; begin
89982: LD_INT 0
89984: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
89985: LD_ADDR_VAR 0 2
89989: PUSH
89990: LD_VAR 0 1
89994: PUSH
89995: LD_INT 55
89997: PUSH
89998: EMPTY
89999: LIST
90000: PPUSH
90001: CALL_OW 69
90005: IN
90006: ST_TO_ADDR
// end ;
90007: LD_VAR 0 2
90011: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
90012: LD_INT 0
90014: PPUSH
90015: PPUSH
// list := [ ] ;
90016: LD_ADDR_VAR 0 5
90020: PUSH
90021: EMPTY
90022: ST_TO_ADDR
// case d of 0 :
90023: LD_VAR 0 3
90027: PUSH
90028: LD_INT 0
90030: DOUBLE
90031: EQUAL
90032: IFTRUE 90036
90034: GO 90169
90036: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
90037: LD_ADDR_VAR 0 5
90041: PUSH
90042: LD_VAR 0 1
90046: PUSH
90047: LD_INT 4
90049: MINUS
90050: PUSH
90051: LD_VAR 0 2
90055: PUSH
90056: LD_INT 4
90058: MINUS
90059: PUSH
90060: LD_INT 2
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: LIST
90067: PUSH
90068: LD_VAR 0 1
90072: PUSH
90073: LD_INT 3
90075: MINUS
90076: PUSH
90077: LD_VAR 0 2
90081: PUSH
90082: LD_INT 1
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: LIST
90089: PUSH
90090: LD_VAR 0 1
90094: PUSH
90095: LD_INT 4
90097: PLUS
90098: PUSH
90099: LD_VAR 0 2
90103: PUSH
90104: LD_INT 4
90106: PUSH
90107: EMPTY
90108: LIST
90109: LIST
90110: LIST
90111: PUSH
90112: LD_VAR 0 1
90116: PUSH
90117: LD_INT 3
90119: PLUS
90120: PUSH
90121: LD_VAR 0 2
90125: PUSH
90126: LD_INT 3
90128: PLUS
90129: PUSH
90130: LD_INT 5
90132: PUSH
90133: EMPTY
90134: LIST
90135: LIST
90136: LIST
90137: PUSH
90138: LD_VAR 0 1
90142: PUSH
90143: LD_VAR 0 2
90147: PUSH
90148: LD_INT 4
90150: PLUS
90151: PUSH
90152: LD_INT 0
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: LIST
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: ST_TO_ADDR
// end ; 1 :
90167: GO 90867
90169: LD_INT 1
90171: DOUBLE
90172: EQUAL
90173: IFTRUE 90177
90175: GO 90310
90177: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
90178: LD_ADDR_VAR 0 5
90182: PUSH
90183: LD_VAR 0 1
90187: PUSH
90188: LD_VAR 0 2
90192: PUSH
90193: LD_INT 4
90195: MINUS
90196: PUSH
90197: LD_INT 3
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: LIST
90204: PUSH
90205: LD_VAR 0 1
90209: PUSH
90210: LD_INT 3
90212: MINUS
90213: PUSH
90214: LD_VAR 0 2
90218: PUSH
90219: LD_INT 3
90221: MINUS
90222: PUSH
90223: LD_INT 2
90225: PUSH
90226: EMPTY
90227: LIST
90228: LIST
90229: LIST
90230: PUSH
90231: LD_VAR 0 1
90235: PUSH
90236: LD_INT 4
90238: MINUS
90239: PUSH
90240: LD_VAR 0 2
90244: PUSH
90245: LD_INT 1
90247: PUSH
90248: EMPTY
90249: LIST
90250: LIST
90251: LIST
90252: PUSH
90253: LD_VAR 0 1
90257: PUSH
90258: LD_VAR 0 2
90262: PUSH
90263: LD_INT 3
90265: PLUS
90266: PUSH
90267: LD_INT 0
90269: PUSH
90270: EMPTY
90271: LIST
90272: LIST
90273: LIST
90274: PUSH
90275: LD_VAR 0 1
90279: PUSH
90280: LD_INT 4
90282: PLUS
90283: PUSH
90284: LD_VAR 0 2
90288: PUSH
90289: LD_INT 4
90291: PLUS
90292: PUSH
90293: LD_INT 5
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: LIST
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: ST_TO_ADDR
// end ; 2 :
90308: GO 90867
90310: LD_INT 2
90312: DOUBLE
90313: EQUAL
90314: IFTRUE 90318
90316: GO 90447
90318: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
90319: LD_ADDR_VAR 0 5
90323: PUSH
90324: LD_VAR 0 1
90328: PUSH
90329: LD_VAR 0 2
90333: PUSH
90334: LD_INT 3
90336: MINUS
90337: PUSH
90338: LD_INT 3
90340: PUSH
90341: EMPTY
90342: LIST
90343: LIST
90344: LIST
90345: PUSH
90346: LD_VAR 0 1
90350: PUSH
90351: LD_INT 4
90353: PLUS
90354: PUSH
90355: LD_VAR 0 2
90359: PUSH
90360: LD_INT 4
90362: PUSH
90363: EMPTY
90364: LIST
90365: LIST
90366: LIST
90367: PUSH
90368: LD_VAR 0 1
90372: PUSH
90373: LD_VAR 0 2
90377: PUSH
90378: LD_INT 4
90380: PLUS
90381: PUSH
90382: LD_INT 0
90384: PUSH
90385: EMPTY
90386: LIST
90387: LIST
90388: LIST
90389: PUSH
90390: LD_VAR 0 1
90394: PUSH
90395: LD_INT 3
90397: MINUS
90398: PUSH
90399: LD_VAR 0 2
90403: PUSH
90404: LD_INT 1
90406: PUSH
90407: EMPTY
90408: LIST
90409: LIST
90410: LIST
90411: PUSH
90412: LD_VAR 0 1
90416: PUSH
90417: LD_INT 4
90419: MINUS
90420: PUSH
90421: LD_VAR 0 2
90425: PUSH
90426: LD_INT 4
90428: MINUS
90429: PUSH
90430: LD_INT 2
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: LIST
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: ST_TO_ADDR
// end ; 3 :
90445: GO 90867
90447: LD_INT 3
90449: DOUBLE
90450: EQUAL
90451: IFTRUE 90455
90453: GO 90588
90455: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
90456: LD_ADDR_VAR 0 5
90460: PUSH
90461: LD_VAR 0 1
90465: PUSH
90466: LD_INT 3
90468: PLUS
90469: PUSH
90470: LD_VAR 0 2
90474: PUSH
90475: LD_INT 4
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: LIST
90482: PUSH
90483: LD_VAR 0 1
90487: PUSH
90488: LD_INT 4
90490: PLUS
90491: PUSH
90492: LD_VAR 0 2
90496: PUSH
90497: LD_INT 4
90499: PLUS
90500: PUSH
90501: LD_INT 5
90503: PUSH
90504: EMPTY
90505: LIST
90506: LIST
90507: LIST
90508: PUSH
90509: LD_VAR 0 1
90513: PUSH
90514: LD_INT 4
90516: MINUS
90517: PUSH
90518: LD_VAR 0 2
90522: PUSH
90523: LD_INT 1
90525: PUSH
90526: EMPTY
90527: LIST
90528: LIST
90529: LIST
90530: PUSH
90531: LD_VAR 0 1
90535: PUSH
90536: LD_VAR 0 2
90540: PUSH
90541: LD_INT 4
90543: MINUS
90544: PUSH
90545: LD_INT 3
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: LIST
90552: PUSH
90553: LD_VAR 0 1
90557: PUSH
90558: LD_INT 3
90560: MINUS
90561: PUSH
90562: LD_VAR 0 2
90566: PUSH
90567: LD_INT 3
90569: MINUS
90570: PUSH
90571: LD_INT 2
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: LIST
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: ST_TO_ADDR
// end ; 4 :
90586: GO 90867
90588: LD_INT 4
90590: DOUBLE
90591: EQUAL
90592: IFTRUE 90596
90594: GO 90729
90596: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
90597: LD_ADDR_VAR 0 5
90601: PUSH
90602: LD_VAR 0 1
90606: PUSH
90607: LD_VAR 0 2
90611: PUSH
90612: LD_INT 4
90614: PLUS
90615: PUSH
90616: LD_INT 0
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: LIST
90623: PUSH
90624: LD_VAR 0 1
90628: PUSH
90629: LD_INT 3
90631: PLUS
90632: PUSH
90633: LD_VAR 0 2
90637: PUSH
90638: LD_INT 3
90640: PLUS
90641: PUSH
90642: LD_INT 5
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: LIST
90649: PUSH
90650: LD_VAR 0 1
90654: PUSH
90655: LD_INT 4
90657: PLUS
90658: PUSH
90659: LD_VAR 0 2
90663: PUSH
90664: LD_INT 4
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: LIST
90671: PUSH
90672: LD_VAR 0 1
90676: PUSH
90677: LD_VAR 0 2
90681: PUSH
90682: LD_INT 3
90684: MINUS
90685: PUSH
90686: LD_INT 3
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: LIST
90693: PUSH
90694: LD_VAR 0 1
90698: PUSH
90699: LD_INT 4
90701: MINUS
90702: PUSH
90703: LD_VAR 0 2
90707: PUSH
90708: LD_INT 4
90710: MINUS
90711: PUSH
90712: LD_INT 2
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: LIST
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: LIST
90724: LIST
90725: LIST
90726: ST_TO_ADDR
// end ; 5 :
90727: GO 90867
90729: LD_INT 5
90731: DOUBLE
90732: EQUAL
90733: IFTRUE 90737
90735: GO 90866
90737: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
90738: LD_ADDR_VAR 0 5
90742: PUSH
90743: LD_VAR 0 1
90747: PUSH
90748: LD_INT 4
90750: MINUS
90751: PUSH
90752: LD_VAR 0 2
90756: PUSH
90757: LD_INT 1
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: LIST
90764: PUSH
90765: LD_VAR 0 1
90769: PUSH
90770: LD_VAR 0 2
90774: PUSH
90775: LD_INT 4
90777: MINUS
90778: PUSH
90779: LD_INT 3
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: LIST
90786: PUSH
90787: LD_VAR 0 1
90791: PUSH
90792: LD_INT 4
90794: PLUS
90795: PUSH
90796: LD_VAR 0 2
90800: PUSH
90801: LD_INT 4
90803: PLUS
90804: PUSH
90805: LD_INT 5
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: LIST
90812: PUSH
90813: LD_VAR 0 1
90817: PUSH
90818: LD_INT 3
90820: PLUS
90821: PUSH
90822: LD_VAR 0 2
90826: PUSH
90827: LD_INT 4
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: LIST
90834: PUSH
90835: LD_VAR 0 1
90839: PUSH
90840: LD_VAR 0 2
90844: PUSH
90845: LD_INT 3
90847: PLUS
90848: PUSH
90849: LD_INT 0
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: LIST
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: ST_TO_ADDR
// end ; end ;
90864: GO 90867
90866: POP
// result := list ;
90867: LD_ADDR_VAR 0 4
90871: PUSH
90872: LD_VAR 0 5
90876: ST_TO_ADDR
// end ;
90877: LD_VAR 0 4
90881: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
90882: LD_INT 0
90884: PPUSH
90885: PPUSH
90886: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
90887: LD_VAR 0 1
90891: NOT
90892: PUSH
90893: LD_VAR 0 2
90897: PUSH
90898: LD_INT 1
90900: PUSH
90901: LD_INT 2
90903: PUSH
90904: LD_INT 3
90906: PUSH
90907: LD_INT 4
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: LIST
90914: LIST
90915: IN
90916: NOT
90917: OR
90918: IFFALSE 90922
// exit ;
90920: GO 91014
// tmp := [ ] ;
90922: LD_ADDR_VAR 0 5
90926: PUSH
90927: EMPTY
90928: ST_TO_ADDR
// for i in units do
90929: LD_ADDR_VAR 0 4
90933: PUSH
90934: LD_VAR 0 1
90938: PUSH
90939: FOR_IN
90940: IFFALSE 90983
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
90942: LD_ADDR_VAR 0 5
90946: PUSH
90947: LD_VAR 0 5
90951: PPUSH
90952: LD_VAR 0 5
90956: PUSH
90957: LD_INT 1
90959: PLUS
90960: PPUSH
90961: LD_VAR 0 4
90965: PPUSH
90966: LD_VAR 0 2
90970: PPUSH
90971: CALL_OW 259
90975: PPUSH
90976: CALL_OW 2
90980: ST_TO_ADDR
90981: GO 90939
90983: POP
90984: POP
// if not tmp then
90985: LD_VAR 0 5
90989: NOT
90990: IFFALSE 90994
// exit ;
90992: GO 91014
// result := SortListByListDesc ( units , tmp ) ;
90994: LD_ADDR_VAR 0 3
90998: PUSH
90999: LD_VAR 0 1
91003: PPUSH
91004: LD_VAR 0 5
91008: PPUSH
91009: CALL_OW 77
91013: ST_TO_ADDR
// end ;
91014: LD_VAR 0 3
91018: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
91019: LD_INT 0
91021: PPUSH
91022: PPUSH
91023: PPUSH
// x := GetX ( building ) ;
91024: LD_ADDR_VAR 0 4
91028: PUSH
91029: LD_VAR 0 2
91033: PPUSH
91034: CALL_OW 250
91038: ST_TO_ADDR
// y := GetY ( building ) ;
91039: LD_ADDR_VAR 0 5
91043: PUSH
91044: LD_VAR 0 2
91048: PPUSH
91049: CALL_OW 251
91053: ST_TO_ADDR
// if GetTaskList ( unit ) then
91054: LD_VAR 0 1
91058: PPUSH
91059: CALL_OW 437
91063: IFFALSE 91158
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91065: LD_STRING e
91067: PUSH
91068: LD_VAR 0 1
91072: PPUSH
91073: CALL_OW 437
91077: PUSH
91078: LD_INT 1
91080: ARRAY
91081: PUSH
91082: LD_INT 1
91084: ARRAY
91085: EQUAL
91086: PUSH
91087: LD_VAR 0 4
91091: PUSH
91092: LD_VAR 0 1
91096: PPUSH
91097: CALL_OW 437
91101: PUSH
91102: LD_INT 1
91104: ARRAY
91105: PUSH
91106: LD_INT 2
91108: ARRAY
91109: EQUAL
91110: AND
91111: PUSH
91112: LD_VAR 0 5
91116: PUSH
91117: LD_VAR 0 1
91121: PPUSH
91122: CALL_OW 437
91126: PUSH
91127: LD_INT 1
91129: ARRAY
91130: PUSH
91131: LD_INT 3
91133: ARRAY
91134: EQUAL
91135: AND
91136: IFFALSE 91148
// result := true else
91138: LD_ADDR_VAR 0 3
91142: PUSH
91143: LD_INT 1
91145: ST_TO_ADDR
91146: GO 91156
// result := false ;
91148: LD_ADDR_VAR 0 3
91152: PUSH
91153: LD_INT 0
91155: ST_TO_ADDR
// end else
91156: GO 91166
// result := false ;
91158: LD_ADDR_VAR 0 3
91162: PUSH
91163: LD_INT 0
91165: ST_TO_ADDR
// end ;
91166: LD_VAR 0 3
91170: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
91171: LD_INT 0
91173: PPUSH
91174: PPUSH
91175: PPUSH
91176: PPUSH
// if not unit or not area then
91177: LD_VAR 0 1
91181: NOT
91182: PUSH
91183: LD_VAR 0 2
91187: NOT
91188: OR
91189: IFFALSE 91193
// exit ;
91191: GO 91357
// tmp := AreaToList ( area , i ) ;
91193: LD_ADDR_VAR 0 6
91197: PUSH
91198: LD_VAR 0 2
91202: PPUSH
91203: LD_VAR 0 5
91207: PPUSH
91208: CALL_OW 517
91212: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
91213: LD_ADDR_VAR 0 5
91217: PUSH
91218: DOUBLE
91219: LD_INT 1
91221: DEC
91222: ST_TO_ADDR
91223: LD_VAR 0 6
91227: PUSH
91228: LD_INT 1
91230: ARRAY
91231: PUSH
91232: FOR_TO
91233: IFFALSE 91355
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
91235: LD_ADDR_VAR 0 7
91239: PUSH
91240: LD_VAR 0 6
91244: PUSH
91245: LD_INT 1
91247: ARRAY
91248: PUSH
91249: LD_VAR 0 5
91253: ARRAY
91254: PUSH
91255: LD_VAR 0 6
91259: PUSH
91260: LD_INT 2
91262: ARRAY
91263: PUSH
91264: LD_VAR 0 5
91268: ARRAY
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
91274: LD_VAR 0 7
91278: PUSH
91279: LD_INT 1
91281: ARRAY
91282: PPUSH
91283: LD_VAR 0 7
91287: PUSH
91288: LD_INT 2
91290: ARRAY
91291: PPUSH
91292: CALL_OW 428
91296: PUSH
91297: LD_INT 0
91299: EQUAL
91300: IFFALSE 91353
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
91302: LD_VAR 0 1
91306: PPUSH
91307: LD_VAR 0 7
91311: PUSH
91312: LD_INT 1
91314: ARRAY
91315: PPUSH
91316: LD_VAR 0 7
91320: PUSH
91321: LD_INT 2
91323: ARRAY
91324: PPUSH
91325: LD_VAR 0 3
91329: PPUSH
91330: CALL_OW 48
// result := IsPlaced ( unit ) ;
91334: LD_ADDR_VAR 0 4
91338: PUSH
91339: LD_VAR 0 1
91343: PPUSH
91344: CALL_OW 305
91348: ST_TO_ADDR
// exit ;
91349: POP
91350: POP
91351: GO 91357
// end ; end ;
91353: GO 91232
91355: POP
91356: POP
// end ;
91357: LD_VAR 0 4
91361: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
91362: LD_INT 0
91364: PPUSH
91365: PPUSH
91366: PPUSH
// if not side or side > 8 then
91367: LD_VAR 0 1
91371: NOT
91372: PUSH
91373: LD_VAR 0 1
91377: PUSH
91378: LD_INT 8
91380: GREATER
91381: OR
91382: IFFALSE 91386
// exit ;
91384: GO 91573
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
91386: LD_ADDR_VAR 0 4
91390: PUSH
91391: LD_INT 22
91393: PUSH
91394: LD_VAR 0 1
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: PUSH
91403: LD_INT 21
91405: PUSH
91406: LD_INT 3
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PPUSH
91417: CALL_OW 69
91421: ST_TO_ADDR
// if not tmp then
91422: LD_VAR 0 4
91426: NOT
91427: IFFALSE 91431
// exit ;
91429: GO 91573
// enable_addtolog := true ;
91431: LD_ADDR_OWVAR 81
91435: PUSH
91436: LD_INT 1
91438: ST_TO_ADDR
// AddToLog ( [ ) ;
91439: LD_STRING [
91441: PPUSH
91442: CALL_OW 561
// for i in tmp do
91446: LD_ADDR_VAR 0 3
91450: PUSH
91451: LD_VAR 0 4
91455: PUSH
91456: FOR_IN
91457: IFFALSE 91564
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
91459: LD_STRING [
91461: PUSH
91462: LD_VAR 0 3
91466: PPUSH
91467: CALL_OW 266
91471: STR
91472: PUSH
91473: LD_STRING , 
91475: STR
91476: PUSH
91477: LD_VAR 0 3
91481: PPUSH
91482: CALL_OW 250
91486: STR
91487: PUSH
91488: LD_STRING , 
91490: STR
91491: PUSH
91492: LD_VAR 0 3
91496: PPUSH
91497: CALL_OW 251
91501: STR
91502: PUSH
91503: LD_STRING , 
91505: STR
91506: PUSH
91507: LD_VAR 0 3
91511: PPUSH
91512: CALL_OW 254
91516: STR
91517: PUSH
91518: LD_STRING , 
91520: STR
91521: PUSH
91522: LD_VAR 0 3
91526: PPUSH
91527: LD_INT 1
91529: PPUSH
91530: CALL_OW 268
91534: STR
91535: PUSH
91536: LD_STRING , 
91538: STR
91539: PUSH
91540: LD_VAR 0 3
91544: PPUSH
91545: LD_INT 2
91547: PPUSH
91548: CALL_OW 268
91552: STR
91553: PUSH
91554: LD_STRING ],
91556: STR
91557: PPUSH
91558: CALL_OW 561
// end ;
91562: GO 91456
91564: POP
91565: POP
// AddToLog ( ]; ) ;
91566: LD_STRING ];
91568: PPUSH
91569: CALL_OW 561
// end ;
91573: LD_VAR 0 2
91577: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
91578: LD_INT 0
91580: PPUSH
91581: PPUSH
91582: PPUSH
91583: PPUSH
91584: PPUSH
// if not area or not rate or not max then
91585: LD_VAR 0 1
91589: NOT
91590: PUSH
91591: LD_VAR 0 2
91595: NOT
91596: OR
91597: PUSH
91598: LD_VAR 0 4
91602: NOT
91603: OR
91604: IFFALSE 91608
// exit ;
91606: GO 91800
// while 1 do
91608: LD_INT 1
91610: IFFALSE 91800
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
91612: LD_ADDR_VAR 0 9
91616: PUSH
91617: LD_VAR 0 1
91621: PPUSH
91622: LD_INT 1
91624: PPUSH
91625: CALL_OW 287
91629: PUSH
91630: LD_INT 10
91632: MUL
91633: ST_TO_ADDR
// r := rate / 10 ;
91634: LD_ADDR_VAR 0 7
91638: PUSH
91639: LD_VAR 0 2
91643: PUSH
91644: LD_INT 10
91646: DIVREAL
91647: ST_TO_ADDR
// time := 1 1$00 ;
91648: LD_ADDR_VAR 0 8
91652: PUSH
91653: LD_INT 2100
91655: ST_TO_ADDR
// if amount < min then
91656: LD_VAR 0 9
91660: PUSH
91661: LD_VAR 0 3
91665: LESS
91666: IFFALSE 91684
// r := r * 2 else
91668: LD_ADDR_VAR 0 7
91672: PUSH
91673: LD_VAR 0 7
91677: PUSH
91678: LD_INT 2
91680: MUL
91681: ST_TO_ADDR
91682: GO 91710
// if amount > max then
91684: LD_VAR 0 9
91688: PUSH
91689: LD_VAR 0 4
91693: GREATER
91694: IFFALSE 91710
// r := r / 2 ;
91696: LD_ADDR_VAR 0 7
91700: PUSH
91701: LD_VAR 0 7
91705: PUSH
91706: LD_INT 2
91708: DIVREAL
91709: ST_TO_ADDR
// time := time / r ;
91710: LD_ADDR_VAR 0 8
91714: PUSH
91715: LD_VAR 0 8
91719: PUSH
91720: LD_VAR 0 7
91724: DIVREAL
91725: ST_TO_ADDR
// if time < 0 then
91726: LD_VAR 0 8
91730: PUSH
91731: LD_INT 0
91733: LESS
91734: IFFALSE 91751
// time := time * - 1 ;
91736: LD_ADDR_VAR 0 8
91740: PUSH
91741: LD_VAR 0 8
91745: PUSH
91746: LD_INT 1
91748: NEG
91749: MUL
91750: ST_TO_ADDR
// wait ( time ) ;
91751: LD_VAR 0 8
91755: PPUSH
91756: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
91760: LD_INT 35
91762: PPUSH
91763: LD_INT 875
91765: PPUSH
91766: CALL_OW 12
91770: PPUSH
91771: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
91775: LD_INT 1
91777: PPUSH
91778: LD_INT 5
91780: PPUSH
91781: CALL_OW 12
91785: PPUSH
91786: LD_VAR 0 1
91790: PPUSH
91791: LD_INT 1
91793: PPUSH
91794: CALL_OW 55
// end ;
91798: GO 91608
// end ;
91800: LD_VAR 0 5
91804: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
91805: LD_INT 0
91807: PPUSH
91808: PPUSH
91809: PPUSH
91810: PPUSH
91811: PPUSH
91812: PPUSH
91813: PPUSH
91814: PPUSH
// if not turrets or not factories then
91815: LD_VAR 0 1
91819: NOT
91820: PUSH
91821: LD_VAR 0 2
91825: NOT
91826: OR
91827: IFFALSE 91831
// exit ;
91829: GO 92138
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
91831: LD_ADDR_VAR 0 10
91835: PUSH
91836: LD_INT 5
91838: PUSH
91839: LD_INT 6
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: PUSH
91846: LD_INT 2
91848: PUSH
91849: LD_INT 4
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 3
91858: PUSH
91859: LD_INT 5
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: EMPTY
91867: LIST
91868: LIST
91869: LIST
91870: PUSH
91871: LD_INT 24
91873: PUSH
91874: LD_INT 25
91876: PUSH
91877: EMPTY
91878: LIST
91879: LIST
91880: PUSH
91881: LD_INT 23
91883: PUSH
91884: LD_INT 27
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: PUSH
91895: LD_INT 42
91897: PUSH
91898: LD_INT 43
91900: PUSH
91901: EMPTY
91902: LIST
91903: LIST
91904: PUSH
91905: LD_INT 44
91907: PUSH
91908: LD_INT 46
91910: PUSH
91911: EMPTY
91912: LIST
91913: LIST
91914: PUSH
91915: LD_INT 45
91917: PUSH
91918: LD_INT 47
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: LIST
91929: PUSH
91930: EMPTY
91931: LIST
91932: LIST
91933: LIST
91934: ST_TO_ADDR
// result := [ ] ;
91935: LD_ADDR_VAR 0 3
91939: PUSH
91940: EMPTY
91941: ST_TO_ADDR
// for i in turrets do
91942: LD_ADDR_VAR 0 4
91946: PUSH
91947: LD_VAR 0 1
91951: PUSH
91952: FOR_IN
91953: IFFALSE 92136
// begin nat := GetNation ( i ) ;
91955: LD_ADDR_VAR 0 7
91959: PUSH
91960: LD_VAR 0 4
91964: PPUSH
91965: CALL_OW 248
91969: ST_TO_ADDR
// weapon := 0 ;
91970: LD_ADDR_VAR 0 8
91974: PUSH
91975: LD_INT 0
91977: ST_TO_ADDR
// if not nat then
91978: LD_VAR 0 7
91982: NOT
91983: IFFALSE 91987
// continue ;
91985: GO 91952
// for j in list [ nat ] do
91987: LD_ADDR_VAR 0 5
91991: PUSH
91992: LD_VAR 0 10
91996: PUSH
91997: LD_VAR 0 7
92001: ARRAY
92002: PUSH
92003: FOR_IN
92004: IFFALSE 92045
// if GetBWeapon ( i ) = j [ 1 ] then
92006: LD_VAR 0 4
92010: PPUSH
92011: CALL_OW 269
92015: PUSH
92016: LD_VAR 0 5
92020: PUSH
92021: LD_INT 1
92023: ARRAY
92024: EQUAL
92025: IFFALSE 92043
// begin weapon := j [ 2 ] ;
92027: LD_ADDR_VAR 0 8
92031: PUSH
92032: LD_VAR 0 5
92036: PUSH
92037: LD_INT 2
92039: ARRAY
92040: ST_TO_ADDR
// break ;
92041: GO 92045
// end ;
92043: GO 92003
92045: POP
92046: POP
// if not weapon then
92047: LD_VAR 0 8
92051: NOT
92052: IFFALSE 92056
// continue ;
92054: GO 91952
// for k in factories do
92056: LD_ADDR_VAR 0 6
92060: PUSH
92061: LD_VAR 0 2
92065: PUSH
92066: FOR_IN
92067: IFFALSE 92132
// begin weapons := AvailableWeaponList ( k ) ;
92069: LD_ADDR_VAR 0 9
92073: PUSH
92074: LD_VAR 0 6
92078: PPUSH
92079: CALL_OW 478
92083: ST_TO_ADDR
// if not weapons then
92084: LD_VAR 0 9
92088: NOT
92089: IFFALSE 92093
// continue ;
92091: GO 92066
// if weapon in weapons then
92093: LD_VAR 0 8
92097: PUSH
92098: LD_VAR 0 9
92102: IN
92103: IFFALSE 92130
// begin result := [ i , weapon ] ;
92105: LD_ADDR_VAR 0 3
92109: PUSH
92110: LD_VAR 0 4
92114: PUSH
92115: LD_VAR 0 8
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: ST_TO_ADDR
// exit ;
92124: POP
92125: POP
92126: POP
92127: POP
92128: GO 92138
// end ; end ;
92130: GO 92066
92132: POP
92133: POP
// end ;
92134: GO 91952
92136: POP
92137: POP
// end ;
92138: LD_VAR 0 3
92142: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
92143: LD_INT 0
92145: PPUSH
// if not side or side > 8 then
92146: LD_VAR 0 3
92150: NOT
92151: PUSH
92152: LD_VAR 0 3
92156: PUSH
92157: LD_INT 8
92159: GREATER
92160: OR
92161: IFFALSE 92165
// exit ;
92163: GO 92224
// if not range then
92165: LD_VAR 0 4
92169: NOT
92170: IFFALSE 92181
// range := - 12 ;
92172: LD_ADDR_VAR 0 4
92176: PUSH
92177: LD_INT 12
92179: NEG
92180: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
92181: LD_VAR 0 1
92185: PPUSH
92186: LD_VAR 0 2
92190: PPUSH
92191: LD_VAR 0 3
92195: PPUSH
92196: LD_VAR 0 4
92200: PPUSH
92201: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
92205: LD_VAR 0 1
92209: PPUSH
92210: LD_VAR 0 2
92214: PPUSH
92215: LD_VAR 0 3
92219: PPUSH
92220: CALL_OW 331
// end ;
92224: LD_VAR 0 5
92228: RET
// export function Video ( mode ) ; begin
92229: LD_INT 0
92231: PPUSH
// ingame_video = mode ;
92232: LD_ADDR_OWVAR 52
92236: PUSH
92237: LD_VAR 0 1
92241: ST_TO_ADDR
// interface_hidden = mode ;
92242: LD_ADDR_OWVAR 54
92246: PUSH
92247: LD_VAR 0 1
92251: ST_TO_ADDR
// end ;
92252: LD_VAR 0 2
92256: RET
// export function Join ( array , element ) ; begin
92257: LD_INT 0
92259: PPUSH
// result := array ^ element ;
92260: LD_ADDR_VAR 0 3
92264: PUSH
92265: LD_VAR 0 1
92269: PUSH
92270: LD_VAR 0 2
92274: ADD
92275: ST_TO_ADDR
// end ;
92276: LD_VAR 0 3
92280: RET
// export function JoinUnion ( array , element ) ; begin
92281: LD_INT 0
92283: PPUSH
// result := array union element ;
92284: LD_ADDR_VAR 0 3
92288: PUSH
92289: LD_VAR 0 1
92293: PUSH
92294: LD_VAR 0 2
92298: UNION
92299: ST_TO_ADDR
// end ;
92300: LD_VAR 0 3
92304: RET
// export function GetBehemoths ( side ) ; begin
92305: LD_INT 0
92307: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
92308: LD_ADDR_VAR 0 2
92312: PUSH
92313: LD_INT 22
92315: PUSH
92316: LD_VAR 0 1
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: PUSH
92325: LD_INT 31
92327: PUSH
92328: LD_INT 25
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: PPUSH
92339: CALL_OW 69
92343: ST_TO_ADDR
// end ;
92344: LD_VAR 0 2
92348: RET
// export function Shuffle ( array ) ; var i , index ; begin
92349: LD_INT 0
92351: PPUSH
92352: PPUSH
92353: PPUSH
// result := [ ] ;
92354: LD_ADDR_VAR 0 2
92358: PUSH
92359: EMPTY
92360: ST_TO_ADDR
// if not array then
92361: LD_VAR 0 1
92365: NOT
92366: IFFALSE 92370
// exit ;
92368: GO 92469
// Randomize ;
92370: CALL_OW 10
// for i = array downto 1 do
92374: LD_ADDR_VAR 0 3
92378: PUSH
92379: DOUBLE
92380: LD_VAR 0 1
92384: INC
92385: ST_TO_ADDR
92386: LD_INT 1
92388: PUSH
92389: FOR_DOWNTO
92390: IFFALSE 92467
// begin index := rand ( 1 , array ) ;
92392: LD_ADDR_VAR 0 4
92396: PUSH
92397: LD_INT 1
92399: PPUSH
92400: LD_VAR 0 1
92404: PPUSH
92405: CALL_OW 12
92409: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
92410: LD_ADDR_VAR 0 2
92414: PUSH
92415: LD_VAR 0 2
92419: PPUSH
92420: LD_VAR 0 2
92424: PUSH
92425: LD_INT 1
92427: PLUS
92428: PPUSH
92429: LD_VAR 0 1
92433: PUSH
92434: LD_VAR 0 4
92438: ARRAY
92439: PPUSH
92440: CALL_OW 2
92444: ST_TO_ADDR
// array := Delete ( array , index ) ;
92445: LD_ADDR_VAR 0 1
92449: PUSH
92450: LD_VAR 0 1
92454: PPUSH
92455: LD_VAR 0 4
92459: PPUSH
92460: CALL_OW 3
92464: ST_TO_ADDR
// end ;
92465: GO 92389
92467: POP
92468: POP
// end ;
92469: LD_VAR 0 2
92473: RET
// export function GetBaseMaterials ( base ) ; begin
92474: LD_INT 0
92476: PPUSH
// result := [ 0 , 0 , 0 ] ;
92477: LD_ADDR_VAR 0 2
92481: PUSH
92482: LD_INT 0
92484: PUSH
92485: LD_INT 0
92487: PUSH
92488: LD_INT 0
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: LIST
92495: ST_TO_ADDR
// if not base then
92496: LD_VAR 0 1
92500: NOT
92501: IFFALSE 92505
// exit ;
92503: GO 92554
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
92505: LD_ADDR_VAR 0 2
92509: PUSH
92510: LD_VAR 0 1
92514: PPUSH
92515: LD_INT 1
92517: PPUSH
92518: CALL_OW 275
92522: PUSH
92523: LD_VAR 0 1
92527: PPUSH
92528: LD_INT 2
92530: PPUSH
92531: CALL_OW 275
92535: PUSH
92536: LD_VAR 0 1
92540: PPUSH
92541: LD_INT 3
92543: PPUSH
92544: CALL_OW 275
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: LIST
92553: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
92554: LD_VAR 0 2
92558: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
92559: LD_INT 0
92561: PPUSH
92562: PPUSH
92563: PPUSH
92564: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
92565: LD_VAR 0 1
92569: PPUSH
92570: CALL_OW 264
92574: PUSH
92575: LD_EXP 71
92579: EQUAL
92580: IFFALSE 92652
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
92582: LD_INT 68
92584: PPUSH
92585: LD_VAR 0 1
92589: PPUSH
92590: CALL_OW 255
92594: PPUSH
92595: CALL_OW 321
92599: PUSH
92600: LD_INT 2
92602: EQUAL
92603: IFFALSE 92615
// eff := 70 else
92605: LD_ADDR_VAR 0 6
92609: PUSH
92610: LD_INT 70
92612: ST_TO_ADDR
92613: GO 92623
// eff := 30 ;
92615: LD_ADDR_VAR 0 6
92619: PUSH
92620: LD_INT 30
92622: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
92623: LD_VAR 0 1
92627: PPUSH
92628: CALL_OW 250
92632: PPUSH
92633: LD_VAR 0 1
92637: PPUSH
92638: CALL_OW 251
92642: PPUSH
92643: LD_VAR 0 6
92647: PPUSH
92648: CALL_OW 495
// end ; end ;
92652: LD_VAR 0 4
92656: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
92657: LD_INT 0
92659: PPUSH
92660: PPUSH
92661: PPUSH
92662: PPUSH
92663: PPUSH
92664: PPUSH
// if cmd = 124 then
92665: LD_VAR 0 1
92669: PUSH
92670: LD_INT 124
92672: EQUAL
92673: IFFALSE 92879
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
92675: LD_ADDR_VAR 0 5
92679: PUSH
92680: LD_INT 2
92682: PUSH
92683: LD_INT 34
92685: PUSH
92686: LD_INT 53
92688: PUSH
92689: EMPTY
92690: LIST
92691: LIST
92692: PUSH
92693: LD_INT 34
92695: PUSH
92696: LD_INT 14
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: PUSH
92703: EMPTY
92704: LIST
92705: LIST
92706: LIST
92707: PPUSH
92708: CALL_OW 69
92712: ST_TO_ADDR
// if not tmp then
92713: LD_VAR 0 5
92717: NOT
92718: IFFALSE 92722
// exit ;
92720: GO 92879
// for i in tmp do
92722: LD_ADDR_VAR 0 3
92726: PUSH
92727: LD_VAR 0 5
92731: PUSH
92732: FOR_IN
92733: IFFALSE 92877
// begin taskList := GetTaskList ( i ) ;
92735: LD_ADDR_VAR 0 6
92739: PUSH
92740: LD_VAR 0 3
92744: PPUSH
92745: CALL_OW 437
92749: ST_TO_ADDR
// if not taskList then
92750: LD_VAR 0 6
92754: NOT
92755: IFFALSE 92759
// continue ;
92757: GO 92732
// for j = 1 to taskList do
92759: LD_ADDR_VAR 0 4
92763: PUSH
92764: DOUBLE
92765: LD_INT 1
92767: DEC
92768: ST_TO_ADDR
92769: LD_VAR 0 6
92773: PUSH
92774: FOR_TO
92775: IFFALSE 92873
// if taskList [ j ] [ 1 ] = | then
92777: LD_VAR 0 6
92781: PUSH
92782: LD_VAR 0 4
92786: ARRAY
92787: PUSH
92788: LD_INT 1
92790: ARRAY
92791: PUSH
92792: LD_STRING |
92794: EQUAL
92795: IFFALSE 92871
// begin _taskList := Delete ( taskList , 1 ) ;
92797: LD_ADDR_VAR 0 7
92801: PUSH
92802: LD_VAR 0 6
92806: PPUSH
92807: LD_INT 1
92809: PPUSH
92810: CALL_OW 3
92814: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
92815: LD_VAR 0 3
92819: PPUSH
92820: LD_VAR 0 7
92824: PPUSH
92825: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
92829: LD_VAR 0 3
92833: PPUSH
92834: LD_VAR 0 6
92838: PUSH
92839: LD_VAR 0 4
92843: ARRAY
92844: PUSH
92845: LD_INT 2
92847: ARRAY
92848: PPUSH
92849: LD_VAR 0 6
92853: PUSH
92854: LD_VAR 0 4
92858: ARRAY
92859: PUSH
92860: LD_INT 3
92862: ARRAY
92863: PPUSH
92864: LD_INT 8
92866: PPUSH
92867: CALL 92884 0 4
// end ;
92871: GO 92774
92873: POP
92874: POP
// end ;
92875: GO 92732
92877: POP
92878: POP
// end ; end ;
92879: LD_VAR 0 2
92883: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
92884: LD_INT 0
92886: PPUSH
92887: PPUSH
92888: PPUSH
92889: PPUSH
92890: PPUSH
92891: PPUSH
92892: PPUSH
92893: PPUSH
92894: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
92895: LD_VAR 0 1
92899: NOT
92900: PUSH
92901: LD_VAR 0 2
92905: PPUSH
92906: LD_VAR 0 3
92910: PPUSH
92911: CALL_OW 488
92915: NOT
92916: OR
92917: PUSH
92918: LD_VAR 0 4
92922: NOT
92923: OR
92924: IFFALSE 92928
// exit ;
92926: GO 93268
// list := [ ] ;
92928: LD_ADDR_VAR 0 13
92932: PUSH
92933: EMPTY
92934: ST_TO_ADDR
// if x - r < 0 then
92935: LD_VAR 0 2
92939: PUSH
92940: LD_VAR 0 4
92944: MINUS
92945: PUSH
92946: LD_INT 0
92948: LESS
92949: IFFALSE 92961
// min_x := 0 else
92951: LD_ADDR_VAR 0 7
92955: PUSH
92956: LD_INT 0
92958: ST_TO_ADDR
92959: GO 92977
// min_x := x - r ;
92961: LD_ADDR_VAR 0 7
92965: PUSH
92966: LD_VAR 0 2
92970: PUSH
92971: LD_VAR 0 4
92975: MINUS
92976: ST_TO_ADDR
// if y - r < 0 then
92977: LD_VAR 0 3
92981: PUSH
92982: LD_VAR 0 4
92986: MINUS
92987: PUSH
92988: LD_INT 0
92990: LESS
92991: IFFALSE 93003
// min_y := 0 else
92993: LD_ADDR_VAR 0 8
92997: PUSH
92998: LD_INT 0
93000: ST_TO_ADDR
93001: GO 93019
// min_y := y - r ;
93003: LD_ADDR_VAR 0 8
93007: PUSH
93008: LD_VAR 0 3
93012: PUSH
93013: LD_VAR 0 4
93017: MINUS
93018: ST_TO_ADDR
// max_x := x + r ;
93019: LD_ADDR_VAR 0 9
93023: PUSH
93024: LD_VAR 0 2
93028: PUSH
93029: LD_VAR 0 4
93033: PLUS
93034: ST_TO_ADDR
// max_y := y + r ;
93035: LD_ADDR_VAR 0 10
93039: PUSH
93040: LD_VAR 0 3
93044: PUSH
93045: LD_VAR 0 4
93049: PLUS
93050: ST_TO_ADDR
// for _x = min_x to max_x do
93051: LD_ADDR_VAR 0 11
93055: PUSH
93056: DOUBLE
93057: LD_VAR 0 7
93061: DEC
93062: ST_TO_ADDR
93063: LD_VAR 0 9
93067: PUSH
93068: FOR_TO
93069: IFFALSE 93186
// for _y = min_y to max_y do
93071: LD_ADDR_VAR 0 12
93075: PUSH
93076: DOUBLE
93077: LD_VAR 0 8
93081: DEC
93082: ST_TO_ADDR
93083: LD_VAR 0 10
93087: PUSH
93088: FOR_TO
93089: IFFALSE 93182
// begin if not ValidHex ( _x , _y ) then
93091: LD_VAR 0 11
93095: PPUSH
93096: LD_VAR 0 12
93100: PPUSH
93101: CALL_OW 488
93105: NOT
93106: IFFALSE 93110
// continue ;
93108: GO 93088
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
93110: LD_VAR 0 11
93114: PPUSH
93115: LD_VAR 0 12
93119: PPUSH
93120: CALL_OW 351
93124: PUSH
93125: LD_VAR 0 11
93129: PPUSH
93130: LD_VAR 0 12
93134: PPUSH
93135: CALL_OW 554
93139: AND
93140: IFFALSE 93180
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
93142: LD_ADDR_VAR 0 13
93146: PUSH
93147: LD_VAR 0 13
93151: PPUSH
93152: LD_VAR 0 13
93156: PUSH
93157: LD_INT 1
93159: PLUS
93160: PPUSH
93161: LD_VAR 0 11
93165: PUSH
93166: LD_VAR 0 12
93170: PUSH
93171: EMPTY
93172: LIST
93173: LIST
93174: PPUSH
93175: CALL_OW 2
93179: ST_TO_ADDR
// end ;
93180: GO 93088
93182: POP
93183: POP
93184: GO 93068
93186: POP
93187: POP
// if not list then
93188: LD_VAR 0 13
93192: NOT
93193: IFFALSE 93197
// exit ;
93195: GO 93268
// for i in list do
93197: LD_ADDR_VAR 0 6
93201: PUSH
93202: LD_VAR 0 13
93206: PUSH
93207: FOR_IN
93208: IFFALSE 93266
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
93210: LD_VAR 0 1
93214: PPUSH
93215: LD_STRING M
93217: PUSH
93218: LD_VAR 0 6
93222: PUSH
93223: LD_INT 1
93225: ARRAY
93226: PUSH
93227: LD_VAR 0 6
93231: PUSH
93232: LD_INT 2
93234: ARRAY
93235: PUSH
93236: LD_INT 0
93238: PUSH
93239: LD_INT 0
93241: PUSH
93242: LD_INT 0
93244: PUSH
93245: LD_INT 0
93247: PUSH
93248: EMPTY
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: PUSH
93257: EMPTY
93258: LIST
93259: PPUSH
93260: CALL_OW 447
93264: GO 93207
93266: POP
93267: POP
// end ;
93268: LD_VAR 0 5
93272: RET
