// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 22550 0 0
// InitNature ;
  19: CALL 19216 0 0
// InitArtifact ;
  23: CALL 19833 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5112 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 7095 0 0
// PrepareRussian ;
  52: CALL 9318 0 0
// PrepareLegion ;
  56: CALL 7592 0 0
// Action ;
  60: CALL 12245 0 0
// MC_Start ( ) ;
  64: CALL 24730 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 102
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 103
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 46447 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 47526 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 47619 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 107
 353: PUSH
 354: LD_EXP 107
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 46784 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 46969 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 47526 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 47619 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 46784 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 46969 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 47399 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 46447 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 47526 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 47619 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 107
 843: PUSH
 844: LD_EXP 107
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 46784 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 46969 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 47526 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 47619 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 47937 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 47731 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 46784 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 46969 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 47350 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// SetInvulnrability ( alien , true ) ;
1443: LD_INT 1
1445: PPUSH
1446: LD_INT 1
1448: PPUSH
1449: CALL_OW 607
// uc_side := 7 ;
1453: LD_ADDR_OWVAR 20
1457: PUSH
1458: LD_INT 7
1460: ST_TO_ADDR
// tmp := [ ] ;
1461: LD_ADDR_VAR 0 5
1465: PUSH
1466: EMPTY
1467: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1468: LD_ADDR_EXP 19
1472: PUSH
1473: LD_STRING JMM
1475: PPUSH
1476: LD_EXP 1
1480: NOT
1481: PPUSH
1482: LD_STRING 14a_
1484: PPUSH
1485: CALL 53258 0 3
1489: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1490: LD_ADDR_EXP 52
1494: PUSH
1495: LD_STRING Burlak
1497: PPUSH
1498: LD_EXP 1
1502: NOT
1503: PPUSH
1504: LD_STRING 14a_
1506: PPUSH
1507: CALL 53258 0 3
1511: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1512: LD_ADDR_EXP 34
1516: PUSH
1517: LD_STRING Joan
1519: PPUSH
1520: LD_EXP 1
1524: NOT
1525: PPUSH
1526: LD_STRING 13a_
1528: PPUSH
1529: CALL 53258 0 3
1533: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1534: LD_ADDR_EXP 20
1538: PUSH
1539: LD_STRING Roth
1541: PPUSH
1542: LD_EXP 1
1546: NOT
1547: PPUSH
1548: LD_STRING 13a_
1550: PPUSH
1551: CALL 53258 0 3
1555: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1556: LD_ADDR_EXP 38
1560: PUSH
1561: LD_STRING Gossudarov
1563: PPUSH
1564: LD_EXP 1
1568: NOT
1569: PPUSH
1570: LD_STRING 13a_
1572: PPUSH
1573: CALL 53258 0 3
1577: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1578: LD_ADDR_EXP 25
1582: PUSH
1583: LD_STRING Denis
1585: PPUSH
1586: LD_EXP 1
1590: NOT
1591: PPUSH
1592: LD_STRING 13a_
1594: PPUSH
1595: CALL 53258 0 3
1599: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1600: LD_ADDR_EXP 35
1604: PUSH
1605: LD_STRING DeltaDoctor
1607: PPUSH
1608: LD_EXP 1
1612: NOT
1613: PPUSH
1614: LD_STRING 13a_
1616: PPUSH
1617: CALL 53258 0 3
1621: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1622: LD_ADDR_EXP 37
1626: PUSH
1627: LD_STRING Mike
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 13a_
1638: PPUSH
1639: CALL 53258 0 3
1643: ST_TO_ADDR
// if DeltaDoctor then
1644: LD_EXP 35
1648: IFFALSE 1666
// tmp := tmp ^ DeltaDoctor ;
1650: LD_ADDR_VAR 0 5
1654: PUSH
1655: LD_VAR 0 5
1659: PUSH
1660: LD_EXP 35
1664: ADD
1665: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1666: LD_ADDR_EXP 33
1670: PUSH
1671: LD_STRING Simms
1673: PPUSH
1674: LD_EXP 1
1678: NOT
1679: PPUSH
1680: LD_STRING 13a_
1682: PPUSH
1683: CALL 53258 0 3
1687: ST_TO_ADDR
// if Simms then
1688: LD_EXP 33
1692: IFFALSE 1710
// tmp := tmp ^ Simms ;
1694: LD_ADDR_VAR 0 5
1698: PUSH
1699: LD_VAR 0 5
1703: PUSH
1704: LD_EXP 33
1708: ADD
1709: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1710: LD_ADDR_EXP 31
1714: PUSH
1715: LD_STRING Frank
1717: PPUSH
1718: LD_EXP 1
1722: NOT
1723: PPUSH
1724: LD_STRING 13a_
1726: PPUSH
1727: CALL 53258 0 3
1731: ST_TO_ADDR
// if Frank then
1732: LD_EXP 31
1736: IFFALSE 1754
// tmp := tmp ^ Frank ;
1738: LD_ADDR_VAR 0 5
1742: PUSH
1743: LD_VAR 0 5
1747: PUSH
1748: LD_EXP 31
1752: ADD
1753: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1754: LD_ADDR_EXP 39
1758: PUSH
1759: LD_STRING Kirilenkova
1761: PPUSH
1762: LD_EXP 1
1766: NOT
1767: PPUSH
1768: LD_STRING 13a_
1770: PPUSH
1771: CALL 53258 0 3
1775: ST_TO_ADDR
// if Kirilenkova then
1776: LD_EXP 39
1780: IFFALSE 1798
// tmp := tmp ^ Kirilenkova ;
1782: LD_ADDR_VAR 0 5
1786: PUSH
1787: LD_VAR 0 5
1791: PUSH
1792: LD_EXP 39
1796: ADD
1797: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1798: LD_ADDR_EXP 40
1802: PUSH
1803: LD_STRING Titov
1805: PPUSH
1806: LD_EXP 1
1810: NOT
1811: PPUSH
1812: LD_STRING 13a_
1814: PPUSH
1815: CALL 53258 0 3
1819: ST_TO_ADDR
// if Titov then
1820: LD_EXP 40
1824: IFFALSE 1842
// tmp := tmp ^ Titov ;
1826: LD_ADDR_VAR 0 5
1830: PUSH
1831: LD_VAR 0 5
1835: PUSH
1836: LD_EXP 40
1840: ADD
1841: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1842: LD_ADDR_EXP 41
1846: PUSH
1847: LD_STRING Fadeev
1849: PPUSH
1850: LD_EXP 1
1854: NOT
1855: PPUSH
1856: LD_STRING 13a_
1858: PPUSH
1859: CALL 53258 0 3
1863: ST_TO_ADDR
// if Fadeev then
1864: LD_EXP 41
1868: IFFALSE 1886
// tmp := tmp ^ Fadeev ;
1870: LD_ADDR_VAR 0 5
1874: PUSH
1875: LD_VAR 0 5
1879: PUSH
1880: LD_EXP 41
1884: ADD
1885: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1886: LD_ADDR_EXP 42
1890: PUSH
1891: LD_STRING Dolgov
1893: PPUSH
1894: LD_EXP 1
1898: NOT
1899: PPUSH
1900: LD_STRING 13a_
1902: PPUSH
1903: CALL 53258 0 3
1907: ST_TO_ADDR
// if Dolgov then
1908: LD_EXP 42
1912: IFFALSE 1930
// tmp := tmp ^ Dolgov ;
1914: LD_ADDR_VAR 0 5
1918: PUSH
1919: LD_VAR 0 5
1923: PUSH
1924: LD_EXP 42
1928: ADD
1929: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1930: LD_ADDR_EXP 43
1934: PUSH
1935: LD_STRING Petrosyan
1937: PPUSH
1938: LD_EXP 1
1942: NOT
1943: PPUSH
1944: LD_STRING 13a_
1946: PPUSH
1947: CALL 53258 0 3
1951: ST_TO_ADDR
// if Petrosyan then
1952: LD_EXP 43
1956: IFFALSE 1974
// tmp := tmp ^ Petrosyan ;
1958: LD_ADDR_VAR 0 5
1962: PUSH
1963: LD_VAR 0 5
1967: PUSH
1968: LD_EXP 43
1972: ADD
1973: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1974: LD_ADDR_EXP 44
1978: PUSH
1979: LD_STRING Scholtze
1981: PPUSH
1982: LD_EXP 1
1986: NOT
1987: PPUSH
1988: LD_STRING 13a_
1990: PPUSH
1991: CALL 53258 0 3
1995: ST_TO_ADDR
// if Scholtze then
1996: LD_EXP 44
2000: IFFALSE 2018
// tmp := tmp ^ Scholtze ;
2002: LD_ADDR_VAR 0 5
2006: PUSH
2007: LD_VAR 0 5
2011: PUSH
2012: LD_EXP 44
2016: ADD
2017: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2018: LD_ADDR_EXP 45
2022: PUSH
2023: LD_STRING Oblukov
2025: PPUSH
2026: LD_EXP 1
2030: NOT
2031: PPUSH
2032: LD_STRING 13a_
2034: PPUSH
2035: CALL 53258 0 3
2039: ST_TO_ADDR
// if Oblukov then
2040: LD_EXP 45
2044: IFFALSE 2062
// tmp := tmp ^ Oblukov ;
2046: LD_ADDR_VAR 0 5
2050: PUSH
2051: LD_VAR 0 5
2055: PUSH
2056: LD_EXP 45
2060: ADD
2061: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2062: LD_ADDR_EXP 46
2066: PUSH
2067: LD_STRING Kapitsova
2069: PPUSH
2070: LD_EXP 1
2074: NOT
2075: PPUSH
2076: LD_STRING 13a_
2078: PPUSH
2079: CALL 53258 0 3
2083: ST_TO_ADDR
// if Kapitsova then
2084: LD_EXP 46
2088: IFFALSE 2106
// tmp := tmp ^ Kapitsova ;
2090: LD_ADDR_VAR 0 5
2094: PUSH
2095: LD_VAR 0 5
2099: PUSH
2100: LD_EXP 46
2104: ADD
2105: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2106: LD_ADDR_EXP 47
2110: PUSH
2111: LD_STRING Lipshchin
2113: PPUSH
2114: LD_EXP 1
2118: NOT
2119: PPUSH
2120: LD_STRING 13a_
2122: PPUSH
2123: CALL 53258 0 3
2127: ST_TO_ADDR
// if Lipshchin then
2128: LD_EXP 47
2132: IFFALSE 2150
// tmp := tmp ^ Lipshchin ;
2134: LD_ADDR_VAR 0 5
2138: PUSH
2139: LD_VAR 0 5
2143: PUSH
2144: LD_EXP 47
2148: ADD
2149: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2150: LD_ADDR_EXP 48
2154: PUSH
2155: LD_STRING Petrovova
2157: PPUSH
2158: LD_EXP 1
2162: NOT
2163: PPUSH
2164: LD_STRING 13a_
2166: PPUSH
2167: CALL 53258 0 3
2171: ST_TO_ADDR
// if Petrovova then
2172: LD_EXP 48
2176: IFFALSE 2194
// tmp := tmp ^ Petrovova ;
2178: LD_ADDR_VAR 0 5
2182: PUSH
2183: LD_VAR 0 5
2187: PUSH
2188: LD_EXP 48
2192: ADD
2193: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2194: LD_ADDR_EXP 49
2198: PUSH
2199: LD_STRING Kovalyuk
2201: PPUSH
2202: LD_EXP 1
2206: NOT
2207: PPUSH
2208: LD_STRING 13a_
2210: PPUSH
2211: CALL 53258 0 3
2215: ST_TO_ADDR
// if Kovalyuk then
2216: LD_EXP 49
2220: IFFALSE 2238
// tmp := tmp ^ Kovalyuk ;
2222: LD_ADDR_VAR 0 5
2226: PUSH
2227: LD_VAR 0 5
2231: PUSH
2232: LD_EXP 49
2236: ADD
2237: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2238: LD_ADDR_EXP 50
2242: PUSH
2243: LD_STRING Kuzmov
2245: PPUSH
2246: LD_EXP 1
2250: NOT
2251: PPUSH
2252: LD_STRING 13a_
2254: PPUSH
2255: CALL 53258 0 3
2259: ST_TO_ADDR
// if Kuzmov then
2260: LD_EXP 50
2264: IFFALSE 2282
// tmp := tmp ^ Kuzmov ;
2266: LD_ADDR_VAR 0 5
2270: PUSH
2271: LD_VAR 0 5
2275: PUSH
2276: LD_EXP 50
2280: ADD
2281: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2282: LD_ADDR_EXP 51
2286: PUSH
2287: LD_STRING Karamazov
2289: PPUSH
2290: LD_EXP 1
2294: NOT
2295: PPUSH
2296: LD_STRING 13a_
2298: PPUSH
2299: CALL 53258 0 3
2303: ST_TO_ADDR
// if Karamazov then
2304: LD_EXP 51
2308: IFFALSE 2326
// tmp := tmp ^ Karamazov ;
2310: LD_ADDR_VAR 0 5
2314: PUSH
2315: LD_VAR 0 5
2319: PUSH
2320: LD_EXP 51
2324: ADD
2325: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2326: LD_ADDR_EXP 53
2330: PUSH
2331: LD_STRING Belkov
2333: PPUSH
2334: LD_EXP 1
2338: NOT
2339: PPUSH
2340: LD_STRING 13a_
2342: PPUSH
2343: CALL 53258 0 3
2347: ST_TO_ADDR
// if Belkov then
2348: LD_EXP 53
2352: IFFALSE 2370
// tmp := tmp ^ Belkov ;
2354: LD_ADDR_VAR 0 5
2358: PUSH
2359: LD_VAR 0 5
2363: PUSH
2364: LD_EXP 53
2368: ADD
2369: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2370: LD_ADDR_EXP 54
2374: PUSH
2375: LD_STRING Gnyevko
2377: PPUSH
2378: LD_EXP 1
2382: NOT
2383: PPUSH
2384: LD_STRING 13a_
2386: PPUSH
2387: CALL 53258 0 3
2391: ST_TO_ADDR
// if Gnyevko then
2392: LD_EXP 54
2396: IFFALSE 2414
// tmp := tmp ^ Gnyevko ;
2398: LD_ADDR_VAR 0 5
2402: PUSH
2403: LD_VAR 0 5
2407: PUSH
2408: LD_EXP 54
2412: ADD
2413: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2414: LD_ADDR_EXP 36
2418: PUSH
2419: LD_STRING Coonie
2421: PPUSH
2422: CALL_OW 25
2426: ST_TO_ADDR
// if not Lisa then
2427: LD_EXP 21
2431: NOT
2432: IFFALSE 2478
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2434: LD_ADDR_EXP 21
2438: PUSH
2439: LD_STRING Lisa
2441: PPUSH
2442: LD_EXP 1
2446: NOT
2447: PPUSH
2448: LD_STRING 13a_
2450: PPUSH
2451: CALL 53258 0 3
2455: ST_TO_ADDR
// if Lisa then
2456: LD_EXP 21
2460: IFFALSE 2478
// tmp := tmp ^ Lisa ;
2462: LD_ADDR_VAR 0 5
2466: PUSH
2467: LD_VAR 0 5
2471: PUSH
2472: LD_EXP 21
2476: ADD
2477: ST_TO_ADDR
// end ; if not Donaldson then
2478: LD_EXP 22
2482: NOT
2483: IFFALSE 2529
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2485: LD_ADDR_EXP 22
2489: PUSH
2490: LD_STRING Donaldson
2492: PPUSH
2493: LD_EXP 1
2497: NOT
2498: PPUSH
2499: LD_STRING 13a_
2501: PPUSH
2502: CALL 53258 0 3
2506: ST_TO_ADDR
// if Donaldson then
2507: LD_EXP 22
2511: IFFALSE 2529
// tmp := tmp ^ Donaldson ;
2513: LD_ADDR_VAR 0 5
2517: PUSH
2518: LD_VAR 0 5
2522: PUSH
2523: LD_EXP 22
2527: ADD
2528: ST_TO_ADDR
// end ; if not Bobby then
2529: LD_EXP 23
2533: NOT
2534: IFFALSE 2580
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2536: LD_ADDR_EXP 23
2540: PUSH
2541: LD_STRING Bobby
2543: PPUSH
2544: LD_EXP 1
2548: NOT
2549: PPUSH
2550: LD_STRING 13a_
2552: PPUSH
2553: CALL 53258 0 3
2557: ST_TO_ADDR
// if Bobby then
2558: LD_EXP 23
2562: IFFALSE 2580
// tmp := tmp ^ Bobby ;
2564: LD_ADDR_VAR 0 5
2568: PUSH
2569: LD_VAR 0 5
2573: PUSH
2574: LD_EXP 23
2578: ADD
2579: ST_TO_ADDR
// end ; if not Cyrus then
2580: LD_EXP 24
2584: NOT
2585: IFFALSE 2631
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2587: LD_ADDR_EXP 24
2591: PUSH
2592: LD_STRING Cyrus
2594: PPUSH
2595: LD_EXP 1
2599: NOT
2600: PPUSH
2601: LD_STRING 13a_
2603: PPUSH
2604: CALL 53258 0 3
2608: ST_TO_ADDR
// if Cyrus then
2609: LD_EXP 24
2613: IFFALSE 2631
// tmp := tmp ^ Cyrus ;
2615: LD_ADDR_VAR 0 5
2619: PUSH
2620: LD_VAR 0 5
2624: PUSH
2625: LD_EXP 24
2629: ADD
2630: ST_TO_ADDR
// end ; if not Brown then
2631: LD_EXP 26
2635: NOT
2636: IFFALSE 2682
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2638: LD_ADDR_EXP 26
2642: PUSH
2643: LD_STRING Brown
2645: PPUSH
2646: LD_EXP 1
2650: NOT
2651: PPUSH
2652: LD_STRING 13a_
2654: PPUSH
2655: CALL 53258 0 3
2659: ST_TO_ADDR
// if Brown then
2660: LD_EXP 26
2664: IFFALSE 2682
// tmp := tmp ^ Brown ;
2666: LD_ADDR_VAR 0 5
2670: PUSH
2671: LD_VAR 0 5
2675: PUSH
2676: LD_EXP 26
2680: ADD
2681: ST_TO_ADDR
// end ; if not Gladstone then
2682: LD_EXP 27
2686: NOT
2687: IFFALSE 2733
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2689: LD_ADDR_EXP 27
2693: PUSH
2694: LD_STRING Gladstone
2696: PPUSH
2697: LD_EXP 1
2701: NOT
2702: PPUSH
2703: LD_STRING 13a_
2705: PPUSH
2706: CALL 53258 0 3
2710: ST_TO_ADDR
// if Gladstone then
2711: LD_EXP 27
2715: IFFALSE 2733
// tmp := tmp ^ Gladstone ;
2717: LD_ADDR_VAR 0 5
2721: PUSH
2722: LD_VAR 0 5
2726: PUSH
2727: LD_EXP 27
2731: ADD
2732: ST_TO_ADDR
// end ; if not Cornel then
2733: LD_EXP 29
2737: NOT
2738: IFFALSE 2784
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2740: LD_ADDR_EXP 29
2744: PUSH
2745: LD_STRING Cornel
2747: PPUSH
2748: LD_EXP 1
2752: NOT
2753: PPUSH
2754: LD_STRING 13a_
2756: PPUSH
2757: CALL 53258 0 3
2761: ST_TO_ADDR
// if Cornel then
2762: LD_EXP 29
2766: IFFALSE 2784
// tmp := tmp ^ Cornel ;
2768: LD_ADDR_VAR 0 5
2772: PUSH
2773: LD_VAR 0 5
2777: PUSH
2778: LD_EXP 29
2782: ADD
2783: ST_TO_ADDR
// end ; if not Houten then
2784: LD_EXP 28
2788: NOT
2789: IFFALSE 2835
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2791: LD_ADDR_EXP 28
2795: PUSH
2796: LD_STRING Houten
2798: PPUSH
2799: LD_EXP 1
2803: NOT
2804: PPUSH
2805: LD_STRING 13a_
2807: PPUSH
2808: CALL 53258 0 3
2812: ST_TO_ADDR
// if Houten then
2813: LD_EXP 28
2817: IFFALSE 2835
// tmp := tmp ^ Houten ;
2819: LD_ADDR_VAR 0 5
2823: PUSH
2824: LD_VAR 0 5
2828: PUSH
2829: LD_EXP 28
2833: ADD
2834: ST_TO_ADDR
// end ; if not Gary then
2835: LD_EXP 30
2839: NOT
2840: IFFALSE 2886
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2842: LD_ADDR_EXP 30
2846: PUSH
2847: LD_STRING Gary
2849: PPUSH
2850: LD_EXP 1
2854: NOT
2855: PPUSH
2856: LD_STRING 13a_
2858: PPUSH
2859: CALL 53258 0 3
2863: ST_TO_ADDR
// if Gary then
2864: LD_EXP 30
2868: IFFALSE 2886
// tmp := tmp ^ Gary ;
2870: LD_ADDR_VAR 0 5
2874: PUSH
2875: LD_VAR 0 5
2879: PUSH
2880: LD_EXP 30
2884: ADD
2885: ST_TO_ADDR
// end ; if not Kikuchi then
2886: LD_EXP 32
2890: NOT
2891: IFFALSE 2937
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2893: LD_ADDR_EXP 32
2897: PUSH
2898: LD_STRING Kikuchi
2900: PPUSH
2901: LD_EXP 1
2905: NOT
2906: PPUSH
2907: LD_STRING 13a_
2909: PPUSH
2910: CALL 53258 0 3
2914: ST_TO_ADDR
// if Kikuchi then
2915: LD_EXP 32
2919: IFFALSE 2937
// tmp := tmp ^ Kikuchi ;
2921: LD_ADDR_VAR 0 5
2925: PUSH
2926: LD_VAR 0 5
2930: PUSH
2931: LD_EXP 32
2935: ADD
2936: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2937: LD_ADDR_VAR 0 5
2941: PUSH
2942: LD_VAR 0 5
2946: PUSH
2947: LD_STRING 13a_others
2949: PPUSH
2950: CALL_OW 31
2954: UNION
2955: ST_TO_ADDR
// tmp := tmp diff 0 ;
2956: LD_ADDR_VAR 0 5
2960: PUSH
2961: LD_VAR 0 5
2965: PUSH
2966: LD_INT 0
2968: DIFF
2969: ST_TO_ADDR
// if tmp < 15 then
2970: LD_VAR 0 5
2974: PUSH
2975: LD_INT 15
2977: LESS
2978: IFFALSE 3066
// for i = 15 downto tmp do
2980: LD_ADDR_VAR 0 2
2984: PUSH
2985: DOUBLE
2986: LD_INT 15
2988: INC
2989: ST_TO_ADDR
2990: LD_VAR 0 5
2994: PUSH
2995: FOR_DOWNTO
2996: IFFALSE 3064
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2998: LD_ADDR_OWVAR 21
3002: PUSH
3003: LD_INT 1
3005: PUSH
3006: LD_INT 3
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: PUSH
3013: LD_INT 1
3015: PPUSH
3016: LD_INT 2
3018: PPUSH
3019: CALL_OW 12
3023: ARRAY
3024: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3025: LD_INT 0
3027: PPUSH
3028: LD_INT 1
3030: PPUSH
3031: LD_INT 4
3033: PPUSH
3034: CALL_OW 12
3038: PPUSH
3039: LD_INT 8
3041: PPUSH
3042: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3046: LD_ADDR_VAR 0 5
3050: PUSH
3051: LD_VAR 0 5
3055: PUSH
3056: CALL_OW 44
3060: ADD
3061: ST_TO_ADDR
// end ;
3062: GO 2995
3064: POP
3065: POP
// if not debug then
3066: LD_EXP 1
3070: NOT
3071: IFFALSE 3251
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3073: LD_ADDR_VAR 0 4
3077: PUSH
3078: LD_STRING 
3080: PPUSH
3081: LD_INT 14
3083: PUSH
3084: LD_INT 13
3086: PUSH
3087: LD_INT 12
3089: PUSH
3090: LD_INT 11
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_OWVAR 67
3103: ARRAY
3104: PPUSH
3105: LD_INT 14
3107: PUSH
3108: LD_INT 13
3110: PUSH
3111: LD_INT 12
3113: PUSH
3114: LD_INT 11
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_OWVAR 67
3127: ARRAY
3128: PPUSH
3129: LD_INT -5
3131: PUSH
3132: LD_EXP 19
3136: PUSH
3137: LD_EXP 52
3141: PUSH
3142: LD_EXP 20
3146: PUSH
3147: LD_EXP 34
3151: PUSH
3152: LD_EXP 25
3156: PUSH
3157: LD_EXP 38
3161: PUSH
3162: LD_INT -2
3164: PUSH
3165: LD_INT -3
3167: PUSH
3168: LD_INT -5
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: PUSH
3183: LD_VAR 0 5
3187: ADD
3188: PPUSH
3189: LD_INT 1
3191: PUSH
3192: LD_INT 4
3194: PUSH
3195: LD_INT 2
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: EMPTY
3202: LIST
3203: LIST
3204: PUSH
3205: LD_INT 3
3207: PUSH
3208: LD_INT 5
3210: PUSH
3211: LD_INT 0
3213: PUSH
3214: LD_INT 3
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: PUSH
3222: LD_INT 9
3224: PUSH
3225: LD_INT 0
3227: PUSH
3228: LD_INT 3
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: LIST
3242: LIST
3243: PPUSH
3244: CALL_OW 42
3248: ST_TO_ADDR
3249: GO 3300
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3251: LD_ADDR_VAR 0 4
3255: PUSH
3256: LD_EXP 40
3260: PUSH
3261: LD_EXP 41
3265: PUSH
3266: LD_EXP 42
3270: PUSH
3271: LD_EXP 43
3275: PUSH
3276: LD_EXP 44
3280: PUSH
3281: LD_EXP 45
3285: PUSH
3286: LD_EXP 46
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: LIST
3298: LIST
3299: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3300: LD_ADDR_EXP 17
3304: PUSH
3305: LD_VAR 0 5
3309: PUSH
3310: LD_VAR 0 4
3314: DIFF
3315: ST_TO_ADDR
// uc_nation := 1 ;
3316: LD_ADDR_OWVAR 21
3320: PUSH
3321: LD_INT 1
3323: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3324: LD_INT 5
3326: PPUSH
3327: LD_INT 3
3329: PPUSH
3330: LD_INT 1
3332: PPUSH
3333: LD_INT 6
3335: PPUSH
3336: LD_INT 100
3338: PPUSH
3339: CALL 58098 0 5
// veh := CreateVehicle ;
3343: LD_ADDR_VAR 0 3
3347: PUSH
3348: CALL_OW 45
3352: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3353: LD_VAR 0 3
3357: PPUSH
3358: LD_INT 7
3360: NEG
3361: PPUSH
3362: CALL_OW 242
// SetDir ( veh , 3 ) ;
3366: LD_VAR 0 3
3370: PPUSH
3371: LD_INT 3
3373: PPUSH
3374: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3378: LD_VAR 0 3
3382: PPUSH
3383: LD_INT 31
3385: PPUSH
3386: LD_INT 0
3388: PPUSH
3389: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3393: LD_EXP 19
3397: PPUSH
3398: LD_VAR 0 3
3402: PPUSH
3403: CALL_OW 52
// if Joan then
3407: LD_EXP 34
3411: IFFALSE 3483
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 3
3418: PPUSH
3419: LD_INT 1
3421: PPUSH
3422: LD_INT 11
3424: PPUSH
3425: LD_INT 100
3427: PPUSH
3428: CALL 58098 0 5
// veh := CreateVehicle ;
3432: LD_ADDR_VAR 0 3
3436: PUSH
3437: CALL_OW 45
3441: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3442: LD_VAR 0 3
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3454: LD_VAR 0 3
3458: PPUSH
3459: LD_INT 30
3461: PPUSH
3462: LD_INT 0
3464: PPUSH
3465: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3469: LD_EXP 34
3473: PPUSH
3474: LD_VAR 0 3
3478: PPUSH
3479: CALL_OW 52
// end ; if Roth then
3483: LD_EXP 20
3487: IFFALSE 3559
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3489: LD_INT 3
3491: PPUSH
3492: LD_INT 3
3494: PPUSH
3495: LD_INT 1
3497: PPUSH
3498: LD_INT 11
3500: PPUSH
3501: LD_INT 100
3503: PPUSH
3504: CALL 58098 0 5
// veh := CreateVehicle ;
3508: LD_ADDR_VAR 0 3
3512: PUSH
3513: CALL_OW 45
3517: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3518: LD_VAR 0 3
3522: PPUSH
3523: LD_INT 3
3525: PPUSH
3526: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3530: LD_VAR 0 3
3534: PPUSH
3535: LD_INT 30
3537: PPUSH
3538: LD_INT 0
3540: PPUSH
3541: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3545: LD_EXP 20
3549: PPUSH
3550: LD_VAR 0 3
3554: PPUSH
3555: CALL_OW 52
// end ; if Denis then
3559: LD_EXP 25
3563: IFFALSE 3635
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3565: LD_INT 5
3567: PPUSH
3568: LD_INT 3
3570: PPUSH
3571: LD_INT 1
3573: PPUSH
3574: LD_INT 9
3576: PPUSH
3577: LD_INT 100
3579: PPUSH
3580: CALL 58098 0 5
// veh := CreateVehicle ;
3584: LD_ADDR_VAR 0 3
3588: PUSH
3589: CALL_OW 45
3593: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3594: LD_VAR 0 3
3598: PPUSH
3599: LD_INT 3
3601: PPUSH
3602: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3606: LD_VAR 0 3
3610: PPUSH
3611: LD_INT 30
3613: PPUSH
3614: LD_INT 0
3616: PPUSH
3617: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3621: LD_EXP 25
3625: PPUSH
3626: LD_VAR 0 3
3630: PPUSH
3631: CALL_OW 52
// end ; uc_nation := 3 ;
3635: LD_ADDR_OWVAR 21
3639: PUSH
3640: LD_INT 3
3642: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3643: LD_INT 22
3645: PPUSH
3646: LD_INT 3
3648: PPUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 45
3654: PPUSH
3655: LD_INT 100
3657: PPUSH
3658: CALL 58098 0 5
// veh := CreateVehicle ;
3662: LD_ADDR_VAR 0 3
3666: PUSH
3667: CALL_OW 45
3671: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3672: LD_VAR 0 3
3676: PPUSH
3677: LD_INT 7
3679: NEG
3680: PPUSH
3681: CALL_OW 242
// SetDir ( veh , 3 ) ;
3685: LD_VAR 0 3
3689: PPUSH
3690: LD_INT 3
3692: PPUSH
3693: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3697: LD_VAR 0 3
3701: PPUSH
3702: LD_INT 31
3704: PPUSH
3705: LD_INT 0
3707: PPUSH
3708: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3712: LD_EXP 52
3716: PPUSH
3717: LD_VAR 0 3
3721: PPUSH
3722: CALL_OW 52
// if Gossudarov then
3726: LD_EXP 38
3730: IFFALSE 3817
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3732: LD_INT 22
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 1
3740: PPUSH
3741: LD_INT 51
3743: PPUSH
3744: LD_INT 100
3746: PPUSH
3747: CALL 58098 0 5
// veh := CreateVehicle ;
3751: LD_ADDR_VAR 0 3
3755: PUSH
3756: CALL_OW 45
3760: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 3
3768: PPUSH
3769: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3773: LD_VAR 0 3
3777: PPUSH
3778: LD_INT 30
3780: PPUSH
3781: LD_INT 0
3783: PPUSH
3784: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3788: LD_EXP 38
3792: PPUSH
3793: LD_VAR 0 3
3797: PPUSH
3798: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3802: LD_VAR 0 3
3806: PPUSH
3807: LD_INT 1
3809: PPUSH
3810: LD_INT 100
3812: PPUSH
3813: CALL_OW 290
// end ; if Mike then
3817: LD_EXP 37
3821: IFFALSE 3838
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3823: LD_EXP 37
3827: PPUSH
3828: LD_INT 30
3830: PPUSH
3831: LD_INT 0
3833: PPUSH
3834: CALL_OW 49
// for i in selected do
3838: LD_ADDR_VAR 0 2
3842: PUSH
3843: LD_VAR 0 4
3847: PUSH
3848: FOR_IN
3849: IFFALSE 4407
// begin uc_nation := GetNation ( i ) ;
3851: LD_ADDR_OWVAR 21
3855: PUSH
3856: LD_VAR 0 2
3860: PPUSH
3861: CALL_OW 248
3865: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3866: LD_VAR 0 2
3870: PUSH
3871: LD_EXP 21
3875: PUSH
3876: LD_EXP 22
3880: PUSH
3881: LD_EXP 24
3885: PUSH
3886: LD_EXP 23
3890: PUSH
3891: EMPTY
3892: LIST
3893: LIST
3894: LIST
3895: LIST
3896: IN
3897: IFFALSE 3920
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 3
3904: PPUSH
3905: LD_INT 1
3907: PPUSH
3908: LD_INT 6
3910: PPUSH
3911: LD_INT 100
3913: PPUSH
3914: CALL 58098 0 5
3918: GO 4354
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3920: LD_VAR 0 2
3924: PUSH
3925: LD_EXP 45
3929: PUSH
3930: LD_EXP 50
3934: PUSH
3935: LD_EXP 48
3939: PUSH
3940: LD_EXP 40
3944: PUSH
3945: EMPTY
3946: LIST
3947: LIST
3948: LIST
3949: LIST
3950: IN
3951: IFFALSE 3982
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3953: LD_INT 24
3955: PPUSH
3956: LD_INT 1
3958: PPUSH
3959: LD_INT 1
3961: PPUSH
3962: LD_INT 46
3964: PPUSH
3965: LD_INT 65
3967: PPUSH
3968: LD_INT 75
3970: PPUSH
3971: CALL_OW 12
3975: PPUSH
3976: CALL 58098 0 5
3980: GO 4354
// if i = Karamazov then
3982: LD_VAR 0 2
3986: PUSH
3987: LD_EXP 51
3991: EQUAL
3992: IFFALSE 4015
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3994: LD_INT 22
3996: PPUSH
3997: LD_INT 3
3999: PPUSH
4000: LD_INT 1
4002: PPUSH
4003: LD_INT 52
4005: PPUSH
4006: LD_INT 100
4008: PPUSH
4009: CALL 58098 0 5
4013: GO 4354
// if i = Brown then
4015: LD_VAR 0 2
4019: PUSH
4020: LD_EXP 26
4024: EQUAL
4025: IFFALSE 4048
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4027: LD_INT 3
4029: PPUSH
4030: LD_INT 3
4032: PPUSH
4033: LD_INT 1
4035: PPUSH
4036: LD_INT 13
4038: PPUSH
4039: LD_INT 100
4041: PPUSH
4042: CALL 58098 0 5
4046: GO 4354
// if uc_nation = nation_american then
4048: LD_OWVAR 21
4052: PUSH
4053: LD_INT 1
4055: EQUAL
4056: IFFALSE 4207
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4058: LD_INT 3
4060: PUSH
4061: LD_INT 5
4063: PUSH
4064: LD_INT 5
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: LIST
4071: PUSH
4072: LD_OWVAR 21
4076: PUSH
4077: LD_INT 3
4079: MOD
4080: PUSH
4081: LD_INT 1
4083: PLUS
4084: ARRAY
4085: PPUSH
4086: LD_INT 1
4088: PUSH
4089: LD_INT 3
4091: PUSH
4092: LD_INT 1
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: PUSH
4100: LD_OWVAR 21
4104: PUSH
4105: LD_INT 3
4107: MOD
4108: PUSH
4109: LD_INT 1
4111: PLUS
4112: ARRAY
4113: PPUSH
4114: LD_INT 1
4116: PPUSH
4117: LD_INT 11
4119: PUSH
4120: LD_INT 4
4122: PUSH
4123: LD_INT 5
4125: PUSH
4126: EMPTY
4127: LIST
4128: LIST
4129: LIST
4130: PUSH
4131: LD_INT 6
4133: PUSH
4134: LD_INT 7
4136: PUSH
4137: LD_INT 9
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: LIST
4144: PUSH
4145: LD_INT 6
4147: PUSH
4148: LD_INT 9
4150: PUSH
4151: LD_INT 12
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: EMPTY
4160: LIST
4161: LIST
4162: LIST
4163: PUSH
4164: LD_OWVAR 21
4168: PUSH
4169: LD_INT 3
4171: MOD
4172: PUSH
4173: LD_INT 1
4175: PLUS
4176: ARRAY
4177: PUSH
4178: LD_INT 1
4180: PPUSH
4181: LD_INT 3
4183: PPUSH
4184: CALL_OW 12
4188: ARRAY
4189: PPUSH
4190: LD_INT 65
4192: PPUSH
4193: LD_INT 75
4195: PPUSH
4196: CALL_OW 12
4200: PPUSH
4201: CALL 58098 0 5
// end else
4205: GO 4354
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4207: LD_INT 22
4209: PUSH
4210: LD_INT 23
4212: PUSH
4213: LD_INT 23
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: LIST
4220: PUSH
4221: LD_OWVAR 21
4225: PUSH
4226: LD_INT 3
4228: MOD
4229: PUSH
4230: LD_INT 1
4232: PLUS
4233: ARRAY
4234: PPUSH
4235: LD_INT 1
4237: PUSH
4238: LD_INT 3
4240: PUSH
4241: LD_INT 1
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: PUSH
4249: LD_OWVAR 21
4253: PUSH
4254: LD_INT 3
4256: MOD
4257: PUSH
4258: LD_INT 1
4260: PLUS
4261: ARRAY
4262: PPUSH
4263: LD_INT 1
4265: PPUSH
4266: LD_INT 45
4268: PUSH
4269: LD_INT 43
4271: PUSH
4272: LD_INT 44
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: LIST
4279: PUSH
4280: LD_INT 46
4282: PUSH
4283: LD_INT 45
4285: PUSH
4286: LD_INT 44
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: LIST
4293: PUSH
4294: LD_INT 46
4296: PUSH
4297: LD_INT 43
4299: PUSH
4300: LD_INT 45
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: LIST
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: LIST
4312: PUSH
4313: LD_OWVAR 21
4317: PUSH
4318: LD_INT 3
4320: MOD
4321: PUSH
4322: LD_INT 1
4324: PLUS
4325: ARRAY
4326: PUSH
4327: LD_INT 1
4329: PPUSH
4330: LD_INT 3
4332: PPUSH
4333: CALL_OW 12
4337: ARRAY
4338: PPUSH
4339: LD_INT 65
4341: PPUSH
4342: LD_INT 75
4344: PPUSH
4345: CALL_OW 12
4349: PPUSH
4350: CALL 58098 0 5
// end ; veh := CreateVehicle ;
4354: LD_ADDR_VAR 0 3
4358: PUSH
4359: CALL_OW 45
4363: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4364: LD_VAR 0 3
4368: PPUSH
4369: LD_INT 3
4371: PPUSH
4372: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4376: LD_VAR 0 3
4380: PPUSH
4381: LD_INT 30
4383: PPUSH
4384: LD_INT 0
4386: PPUSH
4387: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4391: LD_VAR 0 2
4395: PPUSH
4396: LD_VAR 0 3
4400: PPUSH
4401: CALL_OW 52
// end ;
4405: GO 3848
4407: POP
4408: POP
// if artifactArCaptured then
4409: LD_EXP 9
4413: IFFALSE 4499
// begin uc_nation := nation_american ;
4415: LD_ADDR_OWVAR 21
4419: PUSH
4420: LD_INT 1
4422: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4423: LD_INT 3
4425: PPUSH
4426: LD_INT 3
4428: PPUSH
4429: LD_INT 3
4431: PPUSH
4432: LD_INT 12
4434: PPUSH
4435: LD_INT 100
4437: PPUSH
4438: CALL 58098 0 5
// veh := CreateVehicle ;
4442: LD_ADDR_VAR 0 3
4446: PUSH
4447: CALL_OW 45
4451: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4452: LD_VAR 0 3
4456: PPUSH
4457: LD_INT 3
4459: PPUSH
4460: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4464: LD_VAR 0 3
4468: PPUSH
4469: LD_INT 198
4471: PPUSH
4472: LD_INT 22
4474: PPUSH
4475: LD_INT 0
4477: PPUSH
4478: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4482: LD_VAR 0 3
4486: PPUSH
4487: LD_INT 4
4489: PPUSH
4490: LD_INT 50
4492: PPUSH
4493: CALL_OW 290
// end else
4497: GO 4518
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4499: LD_INT 4
4501: PPUSH
4502: LD_INT 5
4504: PPUSH
4505: LD_INT 267
4507: PPUSH
4508: LD_INT 226
4510: PPUSH
4511: LD_INT 0
4513: PPUSH
4514: CALL_OW 58
// end ; uc_nation := nation_american ;
4518: LD_ADDR_OWVAR 21
4522: PUSH
4523: LD_INT 1
4525: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4526: LD_INT 3
4528: PPUSH
4529: LD_INT 3
4531: PPUSH
4532: LD_INT 3
4534: PPUSH
4535: LD_INT 12
4537: PPUSH
4538: LD_INT 100
4540: PPUSH
4541: CALL 58098 0 5
// veh := CreateVehicle ;
4545: LD_ADDR_VAR 0 3
4549: PUSH
4550: CALL_OW 45
4554: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4555: LD_VAR 0 3
4559: PPUSH
4560: LD_INT 3
4562: PPUSH
4563: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4567: LD_VAR 0 3
4571: PPUSH
4572: LD_INT 218
4574: PPUSH
4575: LD_INT 23
4577: PPUSH
4578: LD_INT 0
4580: PPUSH
4581: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4585: LD_VAR 0 3
4589: PPUSH
4590: LD_INT 4
4592: PPUSH
4593: LD_INT 30
4595: PPUSH
4596: CALL_OW 290
// uc_nation := nation_russian ;
4600: LD_ADDR_OWVAR 21
4604: PUSH
4605: LD_INT 3
4607: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4608: LD_INT 22
4610: PPUSH
4611: LD_INT 3
4613: PPUSH
4614: LD_INT 3
4616: PPUSH
4617: LD_INT 51
4619: PPUSH
4620: LD_INT 100
4622: PPUSH
4623: CALL 58098 0 5
// veh := CreateVehicle ;
4627: LD_ADDR_VAR 0 3
4631: PUSH
4632: CALL_OW 45
4636: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4637: LD_VAR 0 3
4641: PPUSH
4642: LD_INT 3
4644: PPUSH
4645: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4649: LD_VAR 0 3
4653: PPUSH
4654: LD_INT 214
4656: PPUSH
4657: LD_INT 20
4659: PPUSH
4660: LD_INT 0
4662: PPUSH
4663: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4667: LD_VAR 0 3
4671: PPUSH
4672: LD_INT 4
4674: PPUSH
4675: LD_INT 40
4677: PPUSH
4678: CALL_OW 290
// end ;
4682: LD_VAR 0 1
4686: RET
// export function AllianceSupport ; var i , veh ; begin
4687: LD_INT 0
4689: PPUSH
4690: PPUSH
4691: PPUSH
// if not allianceTeam then
4692: LD_EXP 17
4696: NOT
4697: IFFALSE 4701
// exit ;
4699: GO 5107
// for i := 1 to 6 do
4701: LD_ADDR_VAR 0 2
4705: PUSH
4706: DOUBLE
4707: LD_INT 1
4709: DEC
4710: ST_TO_ADDR
4711: LD_INT 6
4713: PUSH
4714: FOR_TO
4715: IFFALSE 5011
// begin uc_side := 7 ;
4717: LD_ADDR_OWVAR 20
4721: PUSH
4722: LD_INT 7
4724: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4725: LD_ADDR_OWVAR 21
4729: PUSH
4730: LD_INT 1
4732: PUSH
4733: LD_INT 3
4735: PUSH
4736: EMPTY
4737: LIST
4738: LIST
4739: PUSH
4740: LD_VAR 0 2
4744: PUSH
4745: LD_INT 2
4747: MOD
4748: PUSH
4749: LD_INT 1
4751: PLUS
4752: ARRAY
4753: ST_TO_ADDR
// if uc_nation = 1 then
4754: LD_OWVAR 21
4758: PUSH
4759: LD_INT 1
4761: EQUAL
4762: IFFALSE 4804
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4764: LD_INT 5
4766: PPUSH
4767: LD_INT 3
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 6
4775: PUSH
4776: LD_INT 7
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 2
4788: PPUSH
4789: CALL_OW 12
4793: ARRAY
4794: PPUSH
4795: LD_INT 100
4797: PPUSH
4798: CALL 58098 0 5
4802: GO 4842
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4804: LD_INT 23
4806: PPUSH
4807: LD_INT 3
4809: PPUSH
4810: LD_INT 1
4812: PPUSH
4813: LD_INT 46
4815: PUSH
4816: LD_INT 47
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 1
4825: PPUSH
4826: LD_INT 2
4828: PPUSH
4829: CALL_OW 12
4833: ARRAY
4834: PPUSH
4835: LD_INT 100
4837: PPUSH
4838: CALL 58098 0 5
// if not allianceTeam then
4842: LD_EXP 17
4846: NOT
4847: IFFALSE 4851
// break ;
4849: GO 5011
// veh := CreateVehicle ;
4851: LD_ADDR_VAR 0 3
4855: PUSH
4856: CALL_OW 45
4860: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4861: LD_VAR 0 3
4865: PPUSH
4866: LD_INT 4
4868: PPUSH
4869: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4873: LD_VAR 0 3
4877: PPUSH
4878: LD_INT 38
4880: PPUSH
4881: LD_INT 0
4883: PPUSH
4884: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4888: LD_EXP 17
4892: PUSH
4893: LD_INT 1
4895: ARRAY
4896: PPUSH
4897: LD_INT 3
4899: PPUSH
4900: CALL_OW 259
4904: PUSH
4905: LD_INT 4
4907: GREATER
4908: IFFALSE 4926
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4910: LD_EXP 17
4914: PUSH
4915: LD_INT 1
4917: ARRAY
4918: PPUSH
4919: LD_INT 3
4921: PPUSH
4922: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4926: LD_EXP 17
4930: PUSH
4931: LD_INT 1
4933: ARRAY
4934: PPUSH
4935: LD_INT 4
4937: PPUSH
4938: CALL_OW 259
4942: PUSH
4943: LD_INT 8
4945: GREATER
4946: IFFALSE 4964
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4948: LD_EXP 17
4952: PUSH
4953: LD_INT 1
4955: ARRAY
4956: PPUSH
4957: LD_INT 4
4959: PPUSH
4960: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4964: LD_EXP 17
4968: PUSH
4969: LD_INT 1
4971: ARRAY
4972: PPUSH
4973: LD_VAR 0 3
4977: PPUSH
4978: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4982: LD_ADDR_EXP 17
4986: PUSH
4987: LD_EXP 17
4991: PPUSH
4992: LD_INT 1
4994: PPUSH
4995: CALL_OW 3
4999: ST_TO_ADDR
// ComHold ( veh ) ;
5000: LD_VAR 0 3
5004: PPUSH
5005: CALL_OW 140
// end ;
5009: GO 4714
5011: POP
5012: POP
// uc_side := 7 ;
5013: LD_ADDR_OWVAR 20
5017: PUSH
5018: LD_INT 7
5020: ST_TO_ADDR
// uc_nation := 1 ;
5021: LD_ADDR_OWVAR 21
5025: PUSH
5026: LD_INT 1
5028: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5029: LD_INT 5
5031: PPUSH
5032: LD_INT 3
5034: PPUSH
5035: LD_INT 3
5037: PPUSH
5038: LD_INT 11
5040: PPUSH
5041: LD_INT 100
5043: PPUSH
5044: CALL 58098 0 5
// veh := CreateVehicle ;
5048: LD_ADDR_VAR 0 3
5052: PUSH
5053: CALL_OW 45
5057: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5058: LD_VAR 0 3
5062: PPUSH
5063: LD_INT 4
5065: PPUSH
5066: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5070: LD_VAR 0 3
5074: PPUSH
5075: LD_INT 305
5077: PPUSH
5078: LD_INT 218
5080: PPUSH
5081: LD_INT 0
5083: PPUSH
5084: CALL_OW 48
// ComHold ( veh ) ;
5088: LD_VAR 0 3
5092: PPUSH
5093: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5097: LD_INT 313
5099: PPUSH
5100: LD_INT 220
5102: PPUSH
5103: CALL_OW 86
// end ; end_of_file
5107: LD_VAR 0 1
5111: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5112: LD_INT 0
5114: PPUSH
5115: PPUSH
5116: PPUSH
5117: PPUSH
5118: PPUSH
5119: PPUSH
5120: PPUSH
5121: PPUSH
5122: PPUSH
5123: PPUSH
5124: PPUSH
// InitHc ;
5125: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5129: LD_INT 387
5131: PPUSH
5132: LD_STRING sigma
5134: PPUSH
5135: CALL_OW 500
// uc_side := 1 ;
5139: LD_ADDR_OWVAR 20
5143: PUSH
5144: LD_INT 1
5146: ST_TO_ADDR
// uc_nation := 1 ;
5147: LD_ADDR_OWVAR 21
5151: PUSH
5152: LD_INT 1
5154: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5155: LD_ADDR_VAR 0 2
5159: PUSH
5160: LD_INT 22
5162: PUSH
5163: LD_INT 1
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: LD_INT 21
5172: PUSH
5173: LD_INT 3
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PUSH
5180: EMPTY
5181: LIST
5182: LIST
5183: PPUSH
5184: CALL_OW 69
5188: PUSH
5189: FOR_IN
5190: IFFALSE 5206
// SetBLevel ( i , 10 ) ;
5192: LD_VAR 0 2
5196: PPUSH
5197: LD_INT 10
5199: PPUSH
5200: CALL_OW 241
5204: GO 5189
5206: POP
5207: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5208: LD_INT 387
5210: PPUSH
5211: CALL_OW 274
5215: PPUSH
5216: LD_INT 1
5218: PPUSH
5219: LD_INT 7500
5221: PPUSH
5222: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5226: LD_INT 387
5228: PPUSH
5229: CALL_OW 274
5233: PPUSH
5234: LD_INT 2
5236: PPUSH
5237: LD_INT 4000
5239: PPUSH
5240: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5244: LD_INT 387
5246: PPUSH
5247: CALL_OW 274
5251: PPUSH
5252: LD_INT 3
5254: PPUSH
5255: LD_INT 50
5257: PPUSH
5258: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5262: LD_INT 476
5264: PPUSH
5265: CALL_OW 274
5269: PPUSH
5270: LD_INT 1
5272: PPUSH
5273: LD_INT 5500
5275: PPUSH
5276: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5280: LD_INT 476
5282: PPUSH
5283: CALL_OW 274
5287: PPUSH
5288: LD_INT 2
5290: PPUSH
5291: LD_INT 4000
5293: PPUSH
5294: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5298: LD_INT 476
5300: PPUSH
5301: CALL_OW 274
5305: PPUSH
5306: LD_INT 3
5308: PPUSH
5309: LD_INT 10
5311: PPUSH
5312: CALL_OW 277
// if LoadVariable ( 12a_PowellKilled , false ) then
5316: LD_STRING 12a_PowellKilled
5318: PPUSH
5319: LD_INT 0
5321: PPUSH
5322: CALL_OW 30
5326: IFFALSE 5353
// begin PrepareHuman ( sex_male , class_soldier , 10 ) ;
5328: LD_INT 1
5330: PPUSH
5331: LD_INT 1
5333: PPUSH
5334: LD_INT 10
5336: PPUSH
5337: CALL_OW 380
// Powell := CreateHuman ;
5341: LD_ADDR_EXP 55
5345: PUSH
5346: CALL_OW 44
5350: ST_TO_ADDR
// end else
5351: GO 5366
// Powell := NewCharacter ( Powell ) ;
5353: LD_ADDR_EXP 55
5357: PUSH
5358: LD_STRING Powell
5360: PPUSH
5361: CALL_OW 25
5365: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5366: LD_EXP 55
5370: PPUSH
5371: LD_INT 387
5373: PPUSH
5374: CALL_OW 52
// tmp := [ ] ;
5378: LD_ADDR_VAR 0 7
5382: PUSH
5383: EMPTY
5384: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5385: LD_ADDR_EXP 21
5389: PUSH
5390: LD_STRING Lisa
5392: PPUSH
5393: LD_EXP 1
5397: NOT
5398: PPUSH
5399: LD_STRING 12p_
5401: PPUSH
5402: CALL 53258 0 3
5406: ST_TO_ADDR
// if Lisa then
5407: LD_EXP 21
5411: IFFALSE 5429
// tmp := tmp ^ Lisa ;
5413: LD_ADDR_VAR 0 7
5417: PUSH
5418: LD_VAR 0 7
5422: PUSH
5423: LD_EXP 21
5427: ADD
5428: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5429: LD_ADDR_EXP 22
5433: PUSH
5434: LD_STRING Donaldson
5436: PPUSH
5437: LD_EXP 1
5441: NOT
5442: PPUSH
5443: LD_STRING 12p_
5445: PPUSH
5446: CALL 53258 0 3
5450: ST_TO_ADDR
// if Donaldson then
5451: LD_EXP 22
5455: IFFALSE 5473
// tmp := tmp ^ Donaldson ;
5457: LD_ADDR_VAR 0 7
5461: PUSH
5462: LD_VAR 0 7
5466: PUSH
5467: LD_EXP 22
5471: ADD
5472: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5473: LD_ADDR_EXP 23
5477: PUSH
5478: LD_STRING Bobby
5480: PPUSH
5481: LD_EXP 1
5485: NOT
5486: PPUSH
5487: LD_STRING 12p_
5489: PPUSH
5490: CALL 53258 0 3
5494: ST_TO_ADDR
// if Bobby then
5495: LD_EXP 23
5499: IFFALSE 5517
// tmp := tmp ^ Bobby ;
5501: LD_ADDR_VAR 0 7
5505: PUSH
5506: LD_VAR 0 7
5510: PUSH
5511: LD_EXP 23
5515: ADD
5516: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5517: LD_ADDR_EXP 24
5521: PUSH
5522: LD_STRING Cyrus
5524: PPUSH
5525: LD_EXP 1
5529: NOT
5530: PPUSH
5531: LD_STRING 12p_
5533: PPUSH
5534: CALL 53258 0 3
5538: ST_TO_ADDR
// if Cyrus then
5539: LD_EXP 24
5543: IFFALSE 5561
// tmp := tmp ^ Cyrus ;
5545: LD_ADDR_VAR 0 7
5549: PUSH
5550: LD_VAR 0 7
5554: PUSH
5555: LD_EXP 24
5559: ADD
5560: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5561: LD_ADDR_EXP 26
5565: PUSH
5566: LD_STRING Brown
5568: PPUSH
5569: LD_EXP 1
5573: NOT
5574: PPUSH
5575: LD_STRING 12p_
5577: PPUSH
5578: CALL 53258 0 3
5582: ST_TO_ADDR
// if Brown then
5583: LD_EXP 26
5587: IFFALSE 5605
// tmp := tmp ^ Brown ;
5589: LD_ADDR_VAR 0 7
5593: PUSH
5594: LD_VAR 0 7
5598: PUSH
5599: LD_EXP 26
5603: ADD
5604: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5605: LD_ADDR_EXP 27
5609: PUSH
5610: LD_STRING Gladstone
5612: PPUSH
5613: LD_EXP 1
5617: NOT
5618: PPUSH
5619: LD_STRING 12p_
5621: PPUSH
5622: CALL 53258 0 3
5626: ST_TO_ADDR
// if Gladstone then
5627: LD_EXP 27
5631: IFFALSE 5649
// tmp := tmp ^ Gladstone ;
5633: LD_ADDR_VAR 0 7
5637: PUSH
5638: LD_VAR 0 7
5642: PUSH
5643: LD_EXP 27
5647: ADD
5648: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5649: LD_ADDR_EXP 28
5653: PUSH
5654: LD_STRING Houten
5656: PPUSH
5657: LD_EXP 1
5661: NOT
5662: PPUSH
5663: LD_STRING 12p_
5665: PPUSH
5666: CALL 53258 0 3
5670: ST_TO_ADDR
// if Houten then
5671: LD_EXP 28
5675: IFFALSE 5693
// tmp := tmp ^ Houten ;
5677: LD_ADDR_VAR 0 7
5681: PUSH
5682: LD_VAR 0 7
5686: PUSH
5687: LD_EXP 28
5691: ADD
5692: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5693: LD_ADDR_EXP 29
5697: PUSH
5698: LD_STRING Cornel
5700: PPUSH
5701: LD_EXP 1
5705: NOT
5706: PPUSH
5707: LD_STRING 12p_
5709: PPUSH
5710: CALL 53258 0 3
5714: ST_TO_ADDR
// if Cornel then
5715: LD_EXP 29
5719: IFFALSE 5737
// tmp := tmp ^ Cornel ;
5721: LD_ADDR_VAR 0 7
5725: PUSH
5726: LD_VAR 0 7
5730: PUSH
5731: LD_EXP 29
5735: ADD
5736: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5737: LD_ADDR_EXP 30
5741: PUSH
5742: LD_STRING Gary
5744: PPUSH
5745: LD_EXP 1
5749: NOT
5750: PPUSH
5751: LD_STRING 12p_
5753: PPUSH
5754: CALL 53258 0 3
5758: ST_TO_ADDR
// if Gary then
5759: LD_EXP 30
5763: IFFALSE 5781
// tmp := tmp ^ Gary ;
5765: LD_ADDR_VAR 0 7
5769: PUSH
5770: LD_VAR 0 7
5774: PUSH
5775: LD_EXP 30
5779: ADD
5780: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5781: LD_ADDR_EXP 32
5785: PUSH
5786: LD_STRING Kikuchi
5788: PPUSH
5789: LD_EXP 1
5793: NOT
5794: PPUSH
5795: LD_STRING 12p_
5797: PPUSH
5798: CALL 53258 0 3
5802: ST_TO_ADDR
// if Kikuchi then
5803: LD_EXP 32
5807: IFFALSE 5825
// tmp := tmp ^ Kikuchi ;
5809: LD_ADDR_VAR 0 7
5813: PUSH
5814: LD_VAR 0 7
5818: PUSH
5819: LD_EXP 32
5823: ADD
5824: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5825: LD_ADDR_VAR 0 7
5829: PUSH
5830: LD_VAR 0 7
5834: PUSH
5835: LD_STRING 12p_others
5837: PPUSH
5838: CALL_OW 31
5842: UNION
5843: ST_TO_ADDR
// InitHc_All ( ) ;
5844: CALL_OW 584
// if tmp < 36 then
5848: LD_VAR 0 7
5852: PUSH
5853: LD_INT 36
5855: LESS
5856: IFFALSE 5923
// for i = 1 to 36 - tmp do
5858: LD_ADDR_VAR 0 2
5862: PUSH
5863: DOUBLE
5864: LD_INT 1
5866: DEC
5867: ST_TO_ADDR
5868: LD_INT 36
5870: PUSH
5871: LD_VAR 0 7
5875: MINUS
5876: PUSH
5877: FOR_TO
5878: IFFALSE 5921
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5880: LD_INT 1
5882: PPUSH
5883: LD_VAR 0 2
5887: PUSH
5888: LD_INT 4
5890: MOD
5891: PUSH
5892: LD_INT 1
5894: PLUS
5895: PPUSH
5896: LD_INT 10
5898: PPUSH
5899: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5903: LD_ADDR_VAR 0 7
5907: PUSH
5908: LD_VAR 0 7
5912: PUSH
5913: CALL_OW 44
5917: ADD
5918: ST_TO_ADDR
// end ;
5919: GO 5877
5921: POP
5922: POP
// p := 0 ;
5923: LD_ADDR_VAR 0 6
5927: PUSH
5928: LD_INT 0
5930: ST_TO_ADDR
// for i in tmp do
5931: LD_ADDR_VAR 0 2
5935: PUSH
5936: LD_VAR 0 7
5940: PUSH
5941: FOR_IN
5942: IFFALSE 5994
// begin p := Inc ( p ) ;
5944: LD_ADDR_VAR 0 6
5948: PUSH
5949: LD_VAR 0 6
5953: PPUSH
5954: CALL 92321 0 1
5958: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5959: LD_VAR 0 2
5963: PPUSH
5964: LD_INT 62
5966: PPUSH
5967: LD_INT 93
5969: PPUSH
5970: LD_INT 9
5972: PPUSH
5973: LD_INT 0
5975: PPUSH
5976: CALL_OW 50
// if p > 36 then
5980: LD_VAR 0 6
5984: PUSH
5985: LD_INT 36
5987: GREATER
5988: IFFALSE 5992
// break ;
5990: GO 5994
// end ;
5992: GO 5941
5994: POP
5995: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5996: LD_ADDR_EXP 78
6000: PUSH
6001: LD_EXP 78
6005: PPUSH
6006: LD_INT 4
6008: PPUSH
6009: LD_INT 22
6011: PUSH
6012: LD_INT 1
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PPUSH
6019: CALL_OW 69
6023: PUSH
6024: LD_EXP 55
6028: DIFF
6029: PPUSH
6030: CALL_OW 1
6034: ST_TO_ADDR
// uc_side := 0 ;
6035: LD_ADDR_OWVAR 20
6039: PUSH
6040: LD_INT 0
6042: ST_TO_ADDR
// uc_nation := 0 ;
6043: LD_ADDR_OWVAR 21
6047: PUSH
6048: LD_INT 0
6050: ST_TO_ADDR
// for i = 1 to 4 do
6051: LD_ADDR_VAR 0 2
6055: PUSH
6056: DOUBLE
6057: LD_INT 1
6059: DEC
6060: ST_TO_ADDR
6061: LD_INT 4
6063: PUSH
6064: FOR_TO
6065: IFFALSE 6096
// begin InitHc ;
6067: CALL_OW 19
// hc_class := class_apeman ;
6071: LD_ADDR_OWVAR 28
6075: PUSH
6076: LD_INT 12
6078: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6079: CALL_OW 44
6083: PPUSH
6084: LD_INT 11
6086: PPUSH
6087: LD_INT 0
6089: PPUSH
6090: CALL_OW 49
// end ;
6094: GO 6064
6096: POP
6097: POP
// end ;
6098: LD_VAR 0 1
6102: RET
// every 9 9$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6103: LD_EXP 4
6107: NOT
6108: IFFALSE 7017
6110: GO 6112
6112: DISABLE
6113: LD_INT 0
6115: PPUSH
6116: PPUSH
6117: PPUSH
6118: PPUSH
// begin enable ;
6119: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6120: LD_INT 22
6122: PUSH
6123: LD_INT 1
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: PUSH
6130: LD_INT 23
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: PUSH
6140: LD_INT 30
6142: PUSH
6143: LD_INT 3
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: PPUSH
6155: CALL_OW 69
6159: NOT
6160: IFFALSE 6164
// exit ;
6162: GO 7017
// if Prob ( 40 ) then
6164: LD_INT 40
6166: PPUSH
6167: CALL_OW 13
6171: IFFALSE 6298
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6173: LD_INT 4
6175: PPUSH
6176: LD_INT 5
6178: PUSH
6179: LD_INT 1
6181: PUSH
6182: LD_INT 2
6184: PUSH
6185: LD_INT 7
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PUSH
6194: LD_INT 5
6196: PUSH
6197: LD_INT 1
6199: PUSH
6200: LD_INT 2
6202: PUSH
6203: LD_INT 7
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 5
6214: PUSH
6215: LD_INT 1
6217: PUSH
6218: LD_INT 2
6220: PUSH
6221: LD_INT 7
6223: PUSH
6224: EMPTY
6225: LIST
6226: LIST
6227: LIST
6228: LIST
6229: PUSH
6230: LD_INT 5
6232: PUSH
6233: LD_INT 1
6235: PUSH
6236: LD_INT 2
6238: PUSH
6239: LD_INT 6
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: LIST
6246: LIST
6247: PUSH
6248: LD_INT 5
6250: PUSH
6251: LD_INT 1
6253: PUSH
6254: LD_INT 2
6256: PUSH
6257: LD_INT 6
6259: PUSH
6260: EMPTY
6261: LIST
6262: LIST
6263: LIST
6264: LIST
6265: PUSH
6266: LD_INT 5
6268: PUSH
6269: LD_INT 1
6271: PUSH
6272: LD_INT 2
6274: PUSH
6275: LD_INT 6
6277: PUSH
6278: EMPTY
6279: LIST
6280: LIST
6281: LIST
6282: LIST
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: LIST
6290: LIST
6291: PPUSH
6292: CALL 46832 0 2
// end else
6296: GO 6421
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6298: LD_INT 4
6300: PPUSH
6301: LD_INT 5
6303: PUSH
6304: LD_INT 1
6306: PUSH
6307: LD_INT 2
6309: PUSH
6310: LD_INT 7
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: LIST
6317: LIST
6318: PUSH
6319: LD_INT 5
6321: PUSH
6322: LD_INT 1
6324: PUSH
6325: LD_INT 2
6327: PUSH
6328: LD_INT 9
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PUSH
6337: LD_INT 5
6339: PUSH
6340: LD_INT 1
6342: PUSH
6343: LD_INT 2
6345: PUSH
6346: LD_INT 9
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: LIST
6353: LIST
6354: PUSH
6355: LD_INT 5
6357: PUSH
6358: LD_INT 1
6360: PUSH
6361: LD_INT 2
6363: PUSH
6364: LD_INT 6
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 5
6375: PUSH
6376: LD_INT 1
6378: PUSH
6379: LD_INT 2
6381: PUSH
6382: LD_INT 6
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: PUSH
6391: LD_INT 5
6393: PUSH
6394: LD_INT 1
6396: PUSH
6397: LD_INT 2
6399: PUSH
6400: LD_INT 6
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: PPUSH
6417: CALL 46832 0 2
// end ; p := 0 ;
6421: LD_ADDR_VAR 0 4
6425: PUSH
6426: LD_INT 0
6428: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6429: LD_INT 35
6431: PPUSH
6432: CALL_OW 67
// p := Inc ( p ) ;
6436: LD_ADDR_VAR 0 4
6440: PUSH
6441: LD_VAR 0 4
6445: PPUSH
6446: CALL 92321 0 1
6450: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6451: LD_INT 4
6453: PPUSH
6454: LD_INT 1
6456: PPUSH
6457: CALL 48250 0 2
6461: PUSH
6462: LD_INT 6
6464: GREATEREQUAL
6465: PUSH
6466: LD_VAR 0 4
6470: PUSH
6471: LD_INT 100
6473: GREATER
6474: OR
6475: IFFALSE 6429
// wait ( 0 0$30 ) ;
6477: LD_INT 1050
6479: PPUSH
6480: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_siberium_rocket ] , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] ] ] ) diff mc_defender [ 4 ] ;
6484: LD_ADDR_VAR 0 2
6488: PUSH
6489: LD_INT 22
6491: PUSH
6492: LD_INT 1
6494: PUSH
6495: EMPTY
6496: LIST
6497: LIST
6498: PUSH
6499: LD_INT 21
6501: PUSH
6502: LD_INT 2
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: PUSH
6509: LD_INT 3
6511: PUSH
6512: LD_INT 34
6514: PUSH
6515: LD_INT 8
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 34
6524: PUSH
6525: LD_INT 12
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: PUSH
6532: LD_INT 34
6534: PUSH
6535: LD_INT 13
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: LIST
6552: PPUSH
6553: CALL_OW 69
6557: PUSH
6558: LD_EXP 100
6562: PUSH
6563: LD_INT 4
6565: ARRAY
6566: DIFF
6567: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6568: LD_ADDR_EXP 97
6572: PUSH
6573: LD_EXP 97
6577: PPUSH
6578: LD_INT 4
6580: PPUSH
6581: LD_EXP 97
6585: PUSH
6586: LD_INT 4
6588: ARRAY
6589: PUSH
6590: LD_VAR 0 2
6594: DIFF
6595: PPUSH
6596: CALL_OW 1
6600: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6601: LD_ADDR_VAR 0 3
6605: PUSH
6606: LD_INT 0
6608: PPUSH
6609: LD_INT 2
6611: PPUSH
6612: CALL_OW 12
6616: ST_TO_ADDR
// p := 0 ;
6617: LD_ADDR_VAR 0 4
6621: PUSH
6622: LD_INT 0
6624: ST_TO_ADDR
// if target then
6625: LD_VAR 0 3
6629: IFFALSE 6782
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6631: LD_ADDR_VAR 0 2
6635: PUSH
6636: LD_VAR 0 2
6640: PPUSH
6641: LD_INT 24
6643: PUSH
6644: LD_INT 250
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: PPUSH
6651: CALL_OW 72
6655: ST_TO_ADDR
// for i in tmp do
6656: LD_ADDR_VAR 0 1
6660: PUSH
6661: LD_VAR 0 2
6665: PUSH
6666: FOR_IN
6667: IFFALSE 6707
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6669: LD_VAR 0 1
6673: PPUSH
6674: LD_INT 114
6676: PPUSH
6677: LD_INT 108
6679: PPUSH
6680: CALL_OW 297
6684: PUSH
6685: LD_INT 9
6687: GREATER
6688: IFFALSE 6705
// ComMoveXY ( i , 114 , 108 ) ;
6690: LD_VAR 0 1
6694: PPUSH
6695: LD_INT 114
6697: PPUSH
6698: LD_INT 108
6700: PPUSH
6701: CALL_OW 111
6705: GO 6666
6707: POP
6708: POP
// wait ( 0 0$1 ) ;
6709: LD_INT 35
6711: PPUSH
6712: CALL_OW 67
// p := Inc ( p ) ;
6716: LD_ADDR_VAR 0 4
6720: PUSH
6721: LD_VAR 0 4
6725: PPUSH
6726: CALL 92321 0 1
6730: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6731: LD_VAR 0 2
6735: PPUSH
6736: LD_INT 92
6738: PUSH
6739: LD_INT 114
6741: PUSH
6742: LD_INT 108
6744: PUSH
6745: LD_INT 9
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: LIST
6752: LIST
6753: PPUSH
6754: CALL_OW 72
6758: PUSH
6759: LD_VAR 0 2
6763: PUSH
6764: LD_INT 1
6766: MINUS
6767: GREATEREQUAL
6768: PUSH
6769: LD_VAR 0 4
6773: PUSH
6774: LD_INT 30
6776: GREATER
6777: OR
6778: IFFALSE 6631
// end else
6780: GO 6931
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6782: LD_ADDR_VAR 0 2
6786: PUSH
6787: LD_VAR 0 2
6791: PPUSH
6792: LD_INT 24
6794: PUSH
6795: LD_INT 250
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PPUSH
6802: CALL_OW 72
6806: ST_TO_ADDR
// for i in tmp do
6807: LD_ADDR_VAR 0 1
6811: PUSH
6812: LD_VAR 0 2
6816: PUSH
6817: FOR_IN
6818: IFFALSE 6858
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6820: LD_VAR 0 1
6824: PPUSH
6825: LD_INT 129
6827: PPUSH
6828: LD_INT 139
6830: PPUSH
6831: CALL_OW 297
6835: PUSH
6836: LD_INT 9
6838: GREATER
6839: IFFALSE 6856
// ComMoveXY ( i , 129 , 139 ) ;
6841: LD_VAR 0 1
6845: PPUSH
6846: LD_INT 129
6848: PPUSH
6849: LD_INT 139
6851: PPUSH
6852: CALL_OW 111
6856: GO 6817
6858: POP
6859: POP
// wait ( 0 0$1 ) ;
6860: LD_INT 35
6862: PPUSH
6863: CALL_OW 67
// p := Inc ( p ) ;
6867: LD_ADDR_VAR 0 4
6871: PUSH
6872: LD_VAR 0 4
6876: PPUSH
6877: CALL 92321 0 1
6881: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6882: LD_VAR 0 2
6886: PPUSH
6887: LD_INT 92
6889: PUSH
6890: LD_INT 129
6892: PUSH
6893: LD_INT 139
6895: PUSH
6896: LD_INT 9
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: LIST
6903: LIST
6904: PPUSH
6905: CALL_OW 72
6909: PUSH
6910: LD_VAR 0 2
6914: PUSH
6915: LD_INT 1
6917: MINUS
6918: GREATEREQUAL
6919: PUSH
6920: LD_VAR 0 4
6924: PUSH
6925: LD_INT 30
6927: GREATER
6928: OR
6929: IFFALSE 6782
// end ; repeat wait ( 0 0$1 ) ;
6931: LD_INT 35
6933: PPUSH
6934: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6938: LD_ADDR_VAR 0 2
6942: PUSH
6943: LD_VAR 0 2
6947: PPUSH
6948: LD_INT 50
6950: PUSH
6951: EMPTY
6952: LIST
6953: PPUSH
6954: CALL_OW 72
6958: ST_TO_ADDR
// for i in tmp do
6959: LD_ADDR_VAR 0 1
6963: PUSH
6964: LD_VAR 0 2
6968: PUSH
6969: FOR_IN
6970: IFFALSE 7008
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
6972: LD_VAR 0 1
6976: PPUSH
6977: LD_INT 81
6979: PUSH
6980: LD_INT 1
6982: PUSH
6983: EMPTY
6984: LIST
6985: LIST
6986: PPUSH
6987: CALL_OW 69
6991: PPUSH
6992: LD_VAR 0 1
6996: PPUSH
6997: CALL_OW 74
7001: PPUSH
7002: CALL_OW 115
7006: GO 6969
7008: POP
7009: POP
// until not tmp ;
7010: LD_VAR 0 2
7014: NOT
7015: IFFALSE 6931
// end ;
7017: PPOPN 4
7019: END
// every 30 30$00 trigger not americanDestroyed do
7020: LD_EXP 4
7024: NOT
7025: IFFALSE 7094
7027: GO 7029
7029: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
7030: LD_INT 63000
7032: PUSH
7033: LD_INT 42000
7035: PUSH
7036: LD_INT 31500
7038: PUSH
7039: LD_INT 21000
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: LIST
7046: LIST
7047: PUSH
7048: LD_OWVAR 67
7052: ARRAY
7053: PPUSH
7054: CALL_OW 67
// if americanDestroyed then
7058: LD_EXP 4
7062: IFFALSE 7066
// exit ;
7064: GO 7094
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
7066: LD_INT 4
7068: PPUSH
7069: LD_INT 5
7071: PUSH
7072: LD_INT 3
7074: PUSH
7075: LD_INT 1
7077: PUSH
7078: LD_INT 8
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: EMPTY
7088: LIST
7089: PPUSH
7090: CALL 46832 0 2
// end ; end_of_file
7094: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
7095: LD_INT 0
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
// side := 2 ;
7102: LD_ADDR_VAR 0 5
7106: PUSH
7107: LD_INT 2
7109: ST_TO_ADDR
// InitHc ;
7110: CALL_OW 19
// uc_side := side ;
7114: LD_ADDR_OWVAR 20
7118: PUSH
7119: LD_VAR 0 5
7123: ST_TO_ADDR
// uc_nation := 2 ;
7124: LD_ADDR_OWVAR 21
7128: PUSH
7129: LD_INT 2
7131: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
7132: LD_ADDR_VAR 0 2
7136: PUSH
7137: LD_INT 22
7139: PUSH
7140: LD_INT 2
7142: PUSH
7143: EMPTY
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 21
7149: PUSH
7150: LD_INT 3
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PPUSH
7161: CALL_OW 69
7165: PUSH
7166: FOR_IN
7167: IFFALSE 7183
// SetBLevel ( i , 10 ) ;
7169: LD_VAR 0 2
7173: PPUSH
7174: LD_INT 10
7176: PPUSH
7177: CALL_OW 241
7181: GO 7166
7183: POP
7184: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7185: LD_ADDR_VAR 0 4
7189: PUSH
7190: LD_INT 22
7192: PUSH
7193: LD_VAR 0 5
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: PUSH
7202: LD_INT 30
7204: PUSH
7205: LD_INT 32
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: PUSH
7212: LD_INT 58
7214: PUSH
7215: EMPTY
7216: LIST
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: PPUSH
7223: CALL_OW 69
7227: ST_TO_ADDR
// for i = 1 to 10 do
7228: LD_ADDR_VAR 0 2
7232: PUSH
7233: DOUBLE
7234: LD_INT 1
7236: DEC
7237: ST_TO_ADDR
7238: LD_INT 10
7240: PUSH
7241: FOR_TO
7242: IFFALSE 7314
// begin uc_nation := nation_nature ;
7244: LD_ADDR_OWVAR 21
7248: PUSH
7249: LD_INT 0
7251: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7252: LD_ADDR_OWVAR 28
7256: PUSH
7257: LD_INT 15
7259: ST_TO_ADDR
// hc_gallery :=  ;
7260: LD_ADDR_OWVAR 33
7264: PUSH
7265: LD_STRING 
7267: ST_TO_ADDR
// hc_name :=  ;
7268: LD_ADDR_OWVAR 26
7272: PUSH
7273: LD_STRING 
7275: ST_TO_ADDR
// un := CreateHuman ;
7276: LD_ADDR_VAR 0 3
7280: PUSH
7281: CALL_OW 44
7285: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7286: LD_VAR 0 3
7290: PPUSH
7291: LD_VAR 0 4
7295: PUSH
7296: LD_VAR 0 4
7300: PUSH
7301: LD_VAR 0 2
7305: MINUS
7306: ARRAY
7307: PPUSH
7308: CALL_OW 52
// end ;
7312: GO 7241
7314: POP
7315: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7316: LD_INT 503
7318: PPUSH
7319: LD_INT 27
7321: PPUSH
7322: LD_STRING 
7324: PPUSH
7325: LD_INT 8
7327: PUSH
7328: LD_INT 9
7330: PUSH
7331: LD_INT 10
7333: PUSH
7334: LD_INT 10
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: LIST
7341: LIST
7342: PUSH
7343: LD_OWVAR 67
7347: ARRAY
7348: PPUSH
7349: LD_INT 3000
7351: PUSH
7352: LD_INT 500
7354: PUSH
7355: LD_INT 150
7357: PUSH
7358: EMPTY
7359: LIST
7360: LIST
7361: LIST
7362: PPUSH
7363: LD_INT 16
7365: PUSH
7366: LD_INT 6
7368: PUSH
7369: LD_INT 6
7371: PUSH
7372: LD_INT 6
7374: PUSH
7375: EMPTY
7376: LIST
7377: LIST
7378: LIST
7379: LIST
7380: PPUSH
7381: CALL 61919 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7385: LD_ADDR_EXP 78
7389: PUSH
7390: LD_EXP 78
7394: PPUSH
7395: LD_INT 1
7397: PPUSH
7398: LD_INT 22
7400: PUSH
7401: LD_VAR 0 5
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: LD_INT 23
7412: PUSH
7413: LD_INT 2
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: LD_INT 21
7425: PUSH
7426: LD_INT 2
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: LIST
7441: PPUSH
7442: CALL_OW 69
7446: PPUSH
7447: CALL_OW 1
7451: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7452: LD_INT 216
7454: PPUSH
7455: LD_INT 228
7457: PPUSH
7458: LD_INT 2
7460: PPUSH
7461: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7465: LD_INT 223
7467: PPUSH
7468: LD_INT 241
7470: PPUSH
7471: LD_INT 2
7473: PPUSH
7474: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7478: LD_INT 216
7480: PPUSH
7481: LD_INT 217
7483: PPUSH
7484: LD_INT 2
7486: PPUSH
7487: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7491: LD_INT 233
7493: PPUSH
7494: LD_INT 257
7496: PPUSH
7497: LD_INT 2
7499: PPUSH
7500: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7504: LD_INT 230
7506: PPUSH
7507: LD_INT 199
7509: PPUSH
7510: LD_INT 2
7512: PPUSH
7513: CALL_OW 244
// end ;
7517: LD_VAR 0 1
7521: RET
// export Omar ; export function PrepareOmarAli ; begin
7522: LD_INT 0
7524: PPUSH
// uc_side := 5 ;
7525: LD_ADDR_OWVAR 20
7529: PUSH
7530: LD_INT 5
7532: ST_TO_ADDR
// uc_nation := 2 ;
7533: LD_ADDR_OWVAR 21
7537: PUSH
7538: LD_INT 2
7540: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7541: LD_ADDR_EXP 56
7545: PUSH
7546: LD_STRING Omar
7548: PPUSH
7549: CALL_OW 25
7553: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7554: LD_EXP 56
7558: PPUSH
7559: LD_INT 330
7561: PPUSH
7562: LD_INT 244
7564: PPUSH
7565: LD_INT 0
7567: PPUSH
7568: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7572: LD_EXP 56
7576: PPUSH
7577: LD_INT 252
7579: PPUSH
7580: LD_INT 220
7582: PPUSH
7583: CALL_OW 111
// end ; end_of_file
7587: LD_VAR 0 1
7591: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7592: LD_INT 0
7594: PPUSH
7595: PPUSH
7596: PPUSH
7597: PPUSH
7598: PPUSH
// side := 8 ;
7599: LD_ADDR_VAR 0 3
7603: PUSH
7604: LD_INT 8
7606: ST_TO_ADDR
// InitHc ;
7607: CALL_OW 19
// uc_side := side ;
7611: LD_ADDR_OWVAR 20
7615: PUSH
7616: LD_VAR 0 3
7620: ST_TO_ADDR
// uc_nation := 2 ;
7621: LD_ADDR_OWVAR 21
7625: PUSH
7626: LD_INT 2
7628: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7629: LD_ADDR_VAR 0 2
7633: PUSH
7634: LD_INT 22
7636: PUSH
7637: LD_VAR 0 3
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PUSH
7646: LD_INT 21
7648: PUSH
7649: LD_INT 3
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: PPUSH
7660: CALL_OW 69
7664: PUSH
7665: FOR_IN
7666: IFFALSE 7682
// SetBLevel ( i , 10 ) ;
7668: LD_VAR 0 2
7672: PPUSH
7673: LD_INT 10
7675: PPUSH
7676: CALL_OW 241
7680: GO 7665
7682: POP
7683: POP
// Schulz := NewCharacter ( Schulz ) ;
7684: LD_ADDR_EXP 57
7688: PUSH
7689: LD_STRING Schulz
7691: PPUSH
7692: CALL_OW 25
7696: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7697: LD_ADDR_EXP 59
7701: PUSH
7702: LD_STRING Kaia
7704: PPUSH
7705: CALL_OW 25
7709: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7710: LD_EXP 59
7714: PPUSH
7715: LD_INT 324
7717: PPUSH
7718: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7722: LD_ADDR_EXP 58
7726: PUSH
7727: LD_STRING Kozlov
7729: PPUSH
7730: LD_INT 0
7732: PPUSH
7733: LD_STRING 
7735: PPUSH
7736: CALL 53258 0 3
7740: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7741: LD_EXP 58
7745: PPUSH
7746: LD_INT 22
7748: PUSH
7749: LD_INT 8
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: PUSH
7756: LD_INT 23
7758: PUSH
7759: LD_INT 3
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PUSH
7766: LD_INT 30
7768: PUSH
7769: LD_INT 8
7771: PUSH
7772: EMPTY
7773: LIST
7774: LIST
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: LIST
7780: PPUSH
7781: CALL_OW 69
7785: PUSH
7786: LD_INT 1
7788: ARRAY
7789: PPUSH
7790: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7794: LD_EXP 58
7798: PPUSH
7799: LD_INT 3
7801: PPUSH
7802: LD_INT 10
7804: PPUSH
7805: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7809: LD_ADDR_VAR 0 5
7813: PUSH
7814: LD_INT 22
7816: PUSH
7817: LD_VAR 0 3
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 30
7828: PUSH
7829: LD_INT 32
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: LD_INT 58
7838: PUSH
7839: EMPTY
7840: LIST
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: LIST
7846: PPUSH
7847: CALL_OW 69
7851: ST_TO_ADDR
// for i = 1 to 10 do
7852: LD_ADDR_VAR 0 2
7856: PUSH
7857: DOUBLE
7858: LD_INT 1
7860: DEC
7861: ST_TO_ADDR
7862: LD_INT 10
7864: PUSH
7865: FOR_TO
7866: IFFALSE 7938
// begin uc_nation := nation_nature ;
7868: LD_ADDR_OWVAR 21
7872: PUSH
7873: LD_INT 0
7875: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7876: LD_ADDR_OWVAR 28
7880: PUSH
7881: LD_INT 15
7883: ST_TO_ADDR
// hc_gallery :=  ;
7884: LD_ADDR_OWVAR 33
7888: PUSH
7889: LD_STRING 
7891: ST_TO_ADDR
// hc_name :=  ;
7892: LD_ADDR_OWVAR 26
7896: PUSH
7897: LD_STRING 
7899: ST_TO_ADDR
// un := CreateHuman ;
7900: LD_ADDR_VAR 0 4
7904: PUSH
7905: CALL_OW 44
7909: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7910: LD_VAR 0 4
7914: PPUSH
7915: LD_VAR 0 5
7919: PUSH
7920: LD_VAR 0 5
7924: PUSH
7925: LD_VAR 0 2
7929: MINUS
7930: ARRAY
7931: PPUSH
7932: CALL_OW 52
// end ;
7936: GO 7865
7938: POP
7939: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7940: LD_INT 324
7942: PPUSH
7943: LD_INT 3
7945: PPUSH
7946: LD_STRING 
7948: PPUSH
7949: LD_INT 8
7951: PUSH
7952: LD_INT 9
7954: PUSH
7955: LD_INT 10
7957: PUSH
7958: LD_INT 10
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: LIST
7965: LIST
7966: PUSH
7967: LD_OWVAR 67
7971: ARRAY
7972: PPUSH
7973: LD_INT 3000
7975: PUSH
7976: LD_INT 500
7978: PUSH
7979: LD_INT 150
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: LIST
7986: PPUSH
7987: LD_INT 16
7989: PUSH
7990: LD_INT 6
7992: PUSH
7993: LD_INT 6
7995: PUSH
7996: LD_INT 8
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: LIST
8003: LIST
8004: PPUSH
8005: CALL 61919 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
8009: LD_ADDR_EXP 78
8013: PUSH
8014: LD_EXP 78
8018: PPUSH
8019: LD_INT 3
8021: PPUSH
8022: LD_INT 22
8024: PUSH
8025: LD_VAR 0 3
8029: PUSH
8030: EMPTY
8031: LIST
8032: LIST
8033: PUSH
8034: LD_INT 23
8036: PUSH
8037: LD_INT 2
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: PUSH
8044: LD_INT 3
8046: PUSH
8047: LD_INT 21
8049: PUSH
8050: LD_INT 2
8052: PUSH
8053: EMPTY
8054: LIST
8055: LIST
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: PPUSH
8066: CALL_OW 69
8070: PUSH
8071: LD_EXP 57
8075: DIFF
8076: PPUSH
8077: CALL_OW 1
8081: ST_TO_ADDR
// end ;
8082: LD_VAR 0 1
8086: RET
// export function BuildKozlovBomb ; begin
8087: LD_INT 0
8089: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
8090: LD_INT 332
8092: PPUSH
8093: CALL_OW 302
8097: NOT
8098: PUSH
8099: LD_INT 336
8101: PPUSH
8102: CALL_OW 302
8106: NOT
8107: OR
8108: IFFALSE 8112
// exit ;
8110: GO 8209
// ComChangeProfession ( Kozlov , 4 ) ;
8112: LD_EXP 58
8116: PPUSH
8117: LD_INT 4
8119: PPUSH
8120: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
8124: LD_INT 336
8126: PPUSH
8127: LD_INT 25
8129: PPUSH
8130: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
8134: LD_INT 35
8136: PPUSH
8137: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
8141: LD_INT 25
8143: PPUSH
8144: LD_INT 8
8146: PPUSH
8147: CALL_OW 321
8151: PUSH
8152: LD_INT 2
8154: EQUAL
8155: IFFALSE 8134
// ComExitBuilding ( Kozlov ) ;
8157: LD_EXP 58
8161: PPUSH
8162: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8166: LD_EXP 58
8170: PPUSH
8171: LD_INT 332
8173: PPUSH
8174: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8178: LD_EXP 58
8182: PPUSH
8183: LD_INT 3
8185: PPUSH
8186: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8190: LD_INT 332
8192: PPUSH
8193: LD_INT 23
8195: PPUSH
8196: LD_INT 3
8198: PPUSH
8199: LD_INT 1
8201: PPUSH
8202: LD_INT 48
8204: PPUSH
8205: CALL_OW 125
// end ;
8209: LD_VAR 0 1
8213: RET
// every 9 9$30 + 7 7$00 trigger not legionDestroyed do var i , tmp , target , p ;
8214: LD_EXP 3
8218: NOT
8219: IFFALSE 9212
8221: GO 8223
8223: DISABLE
8224: LD_INT 0
8226: PPUSH
8227: PPUSH
8228: PPUSH
8229: PPUSH
// begin enable ;
8230: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8231: LD_INT 22
8233: PUSH
8234: LD_INT 8
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: PUSH
8241: LD_INT 23
8243: PUSH
8244: LD_INT 2
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: LD_INT 30
8253: PUSH
8254: LD_INT 3
8256: PUSH
8257: EMPTY
8258: LIST
8259: LIST
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: LIST
8265: PPUSH
8266: CALL_OW 69
8270: NOT
8271: IFFALSE 8275
// exit ;
8273: GO 9212
// if Prob ( 40 ) then
8275: LD_INT 40
8277: PPUSH
8278: CALL_OW 13
8282: IFFALSE 8409
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8284: LD_INT 3
8286: PPUSH
8287: LD_INT 14
8289: PUSH
8290: LD_INT 1
8292: PUSH
8293: LD_INT 2
8295: PUSH
8296: LD_INT 28
8298: PUSH
8299: EMPTY
8300: LIST
8301: LIST
8302: LIST
8303: LIST
8304: PUSH
8305: LD_INT 14
8307: PUSH
8308: LD_INT 1
8310: PUSH
8311: LD_INT 2
8313: PUSH
8314: LD_INT 28
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: LIST
8321: LIST
8322: PUSH
8323: LD_INT 14
8325: PUSH
8326: LD_INT 1
8328: PUSH
8329: LD_INT 2
8331: PUSH
8332: LD_INT 28
8334: PUSH
8335: EMPTY
8336: LIST
8337: LIST
8338: LIST
8339: LIST
8340: PUSH
8341: LD_INT 14
8343: PUSH
8344: LD_INT 1
8346: PUSH
8347: LD_INT 2
8349: PUSH
8350: LD_INT 28
8352: PUSH
8353: EMPTY
8354: LIST
8355: LIST
8356: LIST
8357: LIST
8358: PUSH
8359: LD_INT 14
8361: PUSH
8362: LD_INT 1
8364: PUSH
8365: LD_INT 2
8367: PUSH
8368: LD_INT 28
8370: PUSH
8371: EMPTY
8372: LIST
8373: LIST
8374: LIST
8375: LIST
8376: PUSH
8377: LD_INT 14
8379: PUSH
8380: LD_INT 1
8382: PUSH
8383: LD_INT 2
8385: PUSH
8386: LD_INT 26
8388: PUSH
8389: EMPTY
8390: LIST
8391: LIST
8392: LIST
8393: LIST
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: LIST
8402: PPUSH
8403: CALL 46832 0 2
// end else
8407: GO 8616
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8409: LD_INT 3
8411: PPUSH
8412: LD_INT 14
8414: PUSH
8415: LD_INT 1
8417: PUSH
8418: LD_INT 2
8420: PUSH
8421: LD_INT 27
8423: PUSH
8424: LD_INT 26
8426: PUSH
8427: LD_INT 26
8429: PUSH
8430: LD_INT 28
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: LIST
8437: LIST
8438: PUSH
8439: LD_OWVAR 67
8443: ARRAY
8444: PUSH
8445: EMPTY
8446: LIST
8447: LIST
8448: LIST
8449: LIST
8450: PUSH
8451: LD_INT 14
8453: PUSH
8454: LD_INT 1
8456: PUSH
8457: LD_INT 2
8459: PUSH
8460: LD_INT 27
8462: PUSH
8463: LD_INT 26
8465: PUSH
8466: LD_INT 26
8468: PUSH
8469: LD_INT 26
8471: PUSH
8472: EMPTY
8473: LIST
8474: LIST
8475: LIST
8476: LIST
8477: PUSH
8478: LD_OWVAR 67
8482: ARRAY
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: LIST
8488: LIST
8489: PUSH
8490: LD_INT 14
8492: PUSH
8493: LD_INT 1
8495: PUSH
8496: LD_INT 2
8498: PUSH
8499: LD_INT 26
8501: PUSH
8502: LD_INT 26
8504: PUSH
8505: LD_INT 29
8507: PUSH
8508: LD_INT 29
8510: PUSH
8511: EMPTY
8512: LIST
8513: LIST
8514: LIST
8515: LIST
8516: PUSH
8517: LD_OWVAR 67
8521: ARRAY
8522: PUSH
8523: EMPTY
8524: LIST
8525: LIST
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 13
8531: PUSH
8532: LD_INT 1
8534: PUSH
8535: LD_INT 2
8537: PUSH
8538: LD_INT 26
8540: PUSH
8541: LD_INT 29
8543: PUSH
8544: LD_INT 29
8546: PUSH
8547: LD_INT 29
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: PUSH
8556: LD_OWVAR 67
8560: ARRAY
8561: PUSH
8562: EMPTY
8563: LIST
8564: LIST
8565: LIST
8566: LIST
8567: PUSH
8568: LD_INT 13
8570: PUSH
8571: LD_INT 1
8573: PUSH
8574: LD_INT 2
8576: PUSH
8577: LD_INT 29
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: LIST
8584: LIST
8585: PUSH
8586: LD_INT 14
8588: PUSH
8589: LD_INT 1
8591: PUSH
8592: LD_INT 2
8594: PUSH
8595: LD_INT 26
8597: PUSH
8598: EMPTY
8599: LIST
8600: LIST
8601: LIST
8602: LIST
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: LIST
8608: LIST
8609: LIST
8610: LIST
8611: PPUSH
8612: CALL 46832 0 2
// end ; p := 0 ;
8616: LD_ADDR_VAR 0 4
8620: PUSH
8621: LD_INT 0
8623: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8624: LD_INT 35
8626: PPUSH
8627: CALL_OW 67
// p := Inc ( p ) ;
8631: LD_ADDR_VAR 0 4
8635: PUSH
8636: LD_VAR 0 4
8640: PPUSH
8641: CALL 92321 0 1
8645: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8646: LD_INT 3
8648: PPUSH
8649: LD_INT 1
8651: PPUSH
8652: CALL 48250 0 2
8656: PUSH
8657: LD_INT 6
8659: GREATEREQUAL
8660: PUSH
8661: LD_VAR 0 4
8665: PUSH
8666: LD_INT 100
8668: GREATER
8669: OR
8670: IFFALSE 8624
// wait ( 0 0$30 ) ;
8672: LD_INT 1050
8674: PPUSH
8675: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
8679: LD_ADDR_VAR 0 2
8683: PUSH
8684: LD_INT 22
8686: PUSH
8687: LD_INT 8
8689: PUSH
8690: EMPTY
8691: LIST
8692: LIST
8693: PUSH
8694: LD_INT 21
8696: PUSH
8697: LD_INT 2
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: PUSH
8704: LD_INT 3
8706: PUSH
8707: LD_INT 34
8709: PUSH
8710: LD_INT 31
8712: PUSH
8713: EMPTY
8714: LIST
8715: LIST
8716: PUSH
8717: LD_INT 34
8719: PUSH
8720: LD_INT 32
8722: PUSH
8723: EMPTY
8724: LIST
8725: LIST
8726: PUSH
8727: LD_INT 34
8729: PUSH
8730: LD_INT 88
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: PUSH
8743: EMPTY
8744: LIST
8745: LIST
8746: LIST
8747: PPUSH
8748: CALL_OW 69
8752: PUSH
8753: LD_EXP 100
8757: PUSH
8758: LD_INT 3
8760: ARRAY
8761: DIFF
8762: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8763: LD_ADDR_EXP 97
8767: PUSH
8768: LD_EXP 97
8772: PPUSH
8773: LD_INT 3
8775: PPUSH
8776: LD_EXP 97
8780: PUSH
8781: LD_INT 3
8783: ARRAY
8784: PUSH
8785: LD_VAR 0 2
8789: DIFF
8790: PPUSH
8791: CALL_OW 1
8795: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8796: LD_ADDR_VAR 0 3
8800: PUSH
8801: LD_INT 0
8803: PPUSH
8804: LD_INT 2
8806: PPUSH
8807: CALL_OW 12
8811: ST_TO_ADDR
// p := 0 ;
8812: LD_ADDR_VAR 0 4
8816: PUSH
8817: LD_INT 0
8819: ST_TO_ADDR
// if target then
8820: LD_VAR 0 3
8824: IFFALSE 8977
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8826: LD_ADDR_VAR 0 2
8830: PUSH
8831: LD_VAR 0 2
8835: PPUSH
8836: LD_INT 24
8838: PUSH
8839: LD_INT 250
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PPUSH
8846: CALL_OW 72
8850: ST_TO_ADDR
// for i in tmp do
8851: LD_ADDR_VAR 0 1
8855: PUSH
8856: LD_VAR 0 2
8860: PUSH
8861: FOR_IN
8862: IFFALSE 8902
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8864: LD_VAR 0 1
8868: PPUSH
8869: LD_INT 89
8871: PPUSH
8872: LD_INT 71
8874: PPUSH
8875: CALL_OW 297
8879: PUSH
8880: LD_INT 9
8882: GREATER
8883: IFFALSE 8900
// ComMoveXY ( i , 89 , 71 ) ;
8885: LD_VAR 0 1
8889: PPUSH
8890: LD_INT 89
8892: PPUSH
8893: LD_INT 71
8895: PPUSH
8896: CALL_OW 111
8900: GO 8861
8902: POP
8903: POP
// wait ( 0 0$1 ) ;
8904: LD_INT 35
8906: PPUSH
8907: CALL_OW 67
// p := Inc ( p ) ;
8911: LD_ADDR_VAR 0 4
8915: PUSH
8916: LD_VAR 0 4
8920: PPUSH
8921: CALL 92321 0 1
8925: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
8926: LD_VAR 0 2
8930: PPUSH
8931: LD_INT 92
8933: PUSH
8934: LD_INT 89
8936: PUSH
8937: LD_INT 71
8939: PUSH
8940: LD_INT 9
8942: PUSH
8943: EMPTY
8944: LIST
8945: LIST
8946: LIST
8947: LIST
8948: PPUSH
8949: CALL_OW 72
8953: PUSH
8954: LD_VAR 0 2
8958: PUSH
8959: LD_INT 1
8961: MINUS
8962: GREATEREQUAL
8963: PUSH
8964: LD_VAR 0 4
8968: PUSH
8969: LD_INT 30
8971: GREATER
8972: OR
8973: IFFALSE 8826
// end else
8975: GO 9126
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8977: LD_ADDR_VAR 0 2
8981: PUSH
8982: LD_VAR 0 2
8986: PPUSH
8987: LD_INT 24
8989: PUSH
8990: LD_INT 250
8992: PUSH
8993: EMPTY
8994: LIST
8995: LIST
8996: PPUSH
8997: CALL_OW 72
9001: ST_TO_ADDR
// for i in tmp do
9002: LD_ADDR_VAR 0 1
9006: PUSH
9007: LD_VAR 0 2
9011: PUSH
9012: FOR_IN
9013: IFFALSE 9053
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
9015: LD_VAR 0 1
9019: PPUSH
9020: LD_INT 147
9022: PPUSH
9023: LD_INT 4
9025: PPUSH
9026: CALL_OW 297
9030: PUSH
9031: LD_INT 9
9033: GREATER
9034: IFFALSE 9051
// ComMoveXY ( i , 147 , 4 ) ;
9036: LD_VAR 0 1
9040: PPUSH
9041: LD_INT 147
9043: PPUSH
9044: LD_INT 4
9046: PPUSH
9047: CALL_OW 111
9051: GO 9012
9053: POP
9054: POP
// wait ( 0 0$1 ) ;
9055: LD_INT 35
9057: PPUSH
9058: CALL_OW 67
// p := Inc ( p ) ;
9062: LD_ADDR_VAR 0 4
9066: PUSH
9067: LD_VAR 0 4
9071: PPUSH
9072: CALL 92321 0 1
9076: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9077: LD_VAR 0 2
9081: PPUSH
9082: LD_INT 92
9084: PUSH
9085: LD_INT 147
9087: PUSH
9088: LD_INT 4
9090: PUSH
9091: LD_INT 9
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: LIST
9098: LIST
9099: PPUSH
9100: CALL_OW 72
9104: PUSH
9105: LD_VAR 0 2
9109: PUSH
9110: LD_INT 1
9112: MINUS
9113: GREATEREQUAL
9114: PUSH
9115: LD_VAR 0 4
9119: PUSH
9120: LD_INT 30
9122: GREATER
9123: OR
9124: IFFALSE 8977
// end ; repeat wait ( 0 0$1 ) ;
9126: LD_INT 35
9128: PPUSH
9129: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
9133: LD_ADDR_VAR 0 2
9137: PUSH
9138: LD_VAR 0 2
9142: PPUSH
9143: LD_INT 50
9145: PUSH
9146: EMPTY
9147: LIST
9148: PPUSH
9149: CALL_OW 72
9153: ST_TO_ADDR
// for i in tmp do
9154: LD_ADDR_VAR 0 1
9158: PUSH
9159: LD_VAR 0 2
9163: PUSH
9164: FOR_IN
9165: IFFALSE 9203
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
9167: LD_VAR 0 1
9171: PPUSH
9172: LD_INT 81
9174: PUSH
9175: LD_INT 8
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PPUSH
9182: CALL_OW 69
9186: PPUSH
9187: LD_VAR 0 1
9191: PPUSH
9192: CALL_OW 74
9196: PPUSH
9197: CALL_OW 115
9201: GO 9164
9203: POP
9204: POP
// until not tmp ;
9205: LD_VAR 0 2
9209: NOT
9210: IFFALSE 9126
// end ;
9212: PPOPN 4
9214: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
9215: LD_EXP 58
9219: PPUSH
9220: CALL_OW 302
9224: PUSH
9225: LD_EXP 3
9229: NOT
9230: AND
9231: IFFALSE 9240
9233: GO 9235
9235: DISABLE
// BuildKozlovBomb ;
9236: CALL 8087 0 0
9240: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
9241: LD_INT 22
9243: PUSH
9244: LD_INT 8
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: PUSH
9251: LD_INT 34
9253: PUSH
9254: LD_INT 48
9256: PUSH
9257: EMPTY
9258: LIST
9259: LIST
9260: PUSH
9261: EMPTY
9262: LIST
9263: LIST
9264: PPUSH
9265: CALL_OW 69
9269: IFFALSE 9317
9271: GO 9273
9273: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9274: LD_INT 22
9276: PUSH
9277: LD_INT 8
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: PUSH
9284: LD_INT 34
9286: PUSH
9287: LD_INT 48
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: PUSH
9294: EMPTY
9295: LIST
9296: LIST
9297: PPUSH
9298: CALL_OW 69
9302: PUSH
9303: LD_INT 1
9305: ARRAY
9306: PPUSH
9307: LD_INT 173
9309: PPUSH
9310: LD_INT 96
9312: PPUSH
9313: CALL_OW 116
// end ; end_of_file
9317: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9318: LD_INT 0
9320: PPUSH
9321: PPUSH
9322: PPUSH
9323: PPUSH
9324: PPUSH
9325: PPUSH
9326: PPUSH
9327: PPUSH
9328: PPUSH
9329: PPUSH
// side := 3 ;
9330: LD_ADDR_VAR 0 6
9334: PUSH
9335: LD_INT 3
9337: ST_TO_ADDR
// InitHc ;
9338: CALL_OW 19
// uc_side := side ;
9342: LD_ADDR_OWVAR 20
9346: PUSH
9347: LD_VAR 0 6
9351: ST_TO_ADDR
// uc_nation := 3 ;
9352: LD_ADDR_OWVAR 21
9356: PUSH
9357: LD_INT 3
9359: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9360: LD_ADDR_VAR 0 2
9364: PUSH
9365: LD_INT 22
9367: PUSH
9368: LD_VAR 0 6
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: PUSH
9377: LD_INT 21
9379: PUSH
9380: LD_INT 3
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: PUSH
9387: EMPTY
9388: LIST
9389: LIST
9390: PPUSH
9391: CALL_OW 69
9395: PUSH
9396: FOR_IN
9397: IFFALSE 9413
// SetBLevel ( i , 10 ) ;
9399: LD_VAR 0 2
9403: PPUSH
9404: LD_INT 10
9406: PPUSH
9407: CALL_OW 241
9411: GO 9396
9413: POP
9414: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9415: LD_ADDR_VAR 0 10
9419: PUSH
9420: LD_INT 22
9422: PUSH
9423: LD_VAR 0 6
9427: PUSH
9428: EMPTY
9429: LIST
9430: LIST
9431: PUSH
9432: LD_INT 30
9434: PUSH
9435: LD_INT 34
9437: PUSH
9438: EMPTY
9439: LIST
9440: LIST
9441: PUSH
9442: EMPTY
9443: LIST
9444: LIST
9445: PPUSH
9446: CALL_OW 69
9450: ST_TO_ADDR
// if teleport then
9451: LD_VAR 0 10
9455: IFFALSE 9476
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9457: LD_VAR 0 10
9461: PUSH
9462: LD_INT 1
9464: ARRAY
9465: PPUSH
9466: LD_INT 123
9468: PPUSH
9469: LD_INT 122
9471: PPUSH
9472: CALL_OW 243
// hc_importance := 0 ;
9476: LD_ADDR_OWVAR 32
9480: PUSH
9481: LD_INT 0
9483: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9484: LD_ADDR_EXP 60
9488: PUSH
9489: LD_STRING Platonov
9491: PPUSH
9492: CALL_OW 25
9496: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9497: LD_ADDR_EXP 61
9501: PUSH
9502: LD_STRING Yakotich
9504: PPUSH
9505: LD_EXP 1
9509: NOT
9510: PPUSH
9511: LD_STRING 09_
9513: PPUSH
9514: CALL 53258 0 3
9518: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9519: LD_ADDR_EXP 62
9523: PUSH
9524: LD_STRING Gleb
9526: PPUSH
9527: CALL_OW 25
9531: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9532: LD_STRING 03_Cornel
9534: PPUSH
9535: CALL_OW 28
9539: IFFALSE 9587
// begin Bierezov := NewCharacter ( Mikhail ) ;
9541: LD_ADDR_EXP 63
9545: PUSH
9546: LD_STRING Mikhail
9548: PPUSH
9549: CALL_OW 25
9553: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9554: LD_EXP 63
9558: PPUSH
9559: LD_INT 197
9561: PPUSH
9562: LD_INT 111
9564: PPUSH
9565: LD_INT 9
9567: PPUSH
9568: LD_INT 0
9570: PPUSH
9571: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9575: LD_EXP 63
9579: PPUSH
9580: LD_INT 3
9582: PPUSH
9583: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9587: LD_EXP 60
9591: PPUSH
9592: LD_INT 126
9594: PPUSH
9595: CALL_OW 52
// if Yakotich then
9599: LD_EXP 61
9603: IFFALSE 9626
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9605: LD_EXP 61
9609: PPUSH
9610: LD_INT 197
9612: PPUSH
9613: LD_INT 111
9615: PPUSH
9616: LD_INT 9
9618: PPUSH
9619: LD_INT 0
9621: PPUSH
9622: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9626: LD_EXP 62
9630: PPUSH
9631: LD_INT 197
9633: PPUSH
9634: LD_INT 111
9636: PPUSH
9637: LD_INT 9
9639: PPUSH
9640: LD_INT 0
9642: PPUSH
9643: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9647: LD_ADDR_VAR 0 5
9651: PUSH
9652: LD_INT 126
9654: PPUSH
9655: LD_INT 2
9657: PPUSH
9658: LD_STRING zhukov
9660: PPUSH
9661: LD_INT 9
9663: PUSH
9664: LD_INT 10
9666: PUSH
9667: LD_INT 10
9669: PUSH
9670: LD_INT 10
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: LIST
9677: LIST
9678: PUSH
9679: LD_OWVAR 67
9683: ARRAY
9684: PPUSH
9685: LD_INT 9000
9687: PUSH
9688: LD_INT 1000
9690: PUSH
9691: LD_INT 300
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: LIST
9698: PPUSH
9699: LD_INT 21
9701: PUSH
9702: LD_INT 8
9704: PUSH
9705: LD_INT 13
9707: PUSH
9708: LD_INT 8
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: PPUSH
9717: CALL 61919 0 6
9721: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9722: LD_ADDR_EXP 78
9726: PUSH
9727: LD_EXP 78
9731: PPUSH
9732: LD_INT 2
9734: PPUSH
9735: LD_VAR 0 5
9739: PUSH
9740: LD_EXP 61
9744: PUSH
9745: LD_EXP 62
9749: PUSH
9750: LD_EXP 63
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: LIST
9759: UNION
9760: PPUSH
9761: CALL_OW 1
9765: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9766: LD_ADDR_VAR 0 4
9770: PUSH
9771: LD_INT 267
9773: PPUSH
9774: CALL_OW 274
9778: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9779: LD_VAR 0 4
9783: PPUSH
9784: LD_INT 1
9786: PPUSH
9787: LD_INT 5000
9789: PPUSH
9790: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9794: LD_VAR 0 4
9798: PPUSH
9799: LD_INT 2
9801: PPUSH
9802: LD_INT 200
9804: PPUSH
9805: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9809: LD_VAR 0 4
9813: PPUSH
9814: LD_INT 3
9816: PPUSH
9817: LD_INT 200
9819: PPUSH
9820: CALL_OW 277
// for i := 1 to 6 do
9824: LD_ADDR_VAR 0 2
9828: PUSH
9829: DOUBLE
9830: LD_INT 1
9832: DEC
9833: ST_TO_ADDR
9834: LD_INT 6
9836: PUSH
9837: FOR_TO
9838: IFFALSE 9921
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
9840: LD_INT 0
9842: PPUSH
9843: LD_INT 8
9845: PUSH
9846: LD_INT 9
9848: PUSH
9849: LD_INT 10
9851: PUSH
9852: LD_INT 10
9854: PUSH
9855: EMPTY
9856: LIST
9857: LIST
9858: LIST
9859: LIST
9860: PUSH
9861: LD_OWVAR 67
9865: ARRAY
9866: PPUSH
9867: CALL_OW 381
// un := CreateHuman ;
9871: LD_ADDR_VAR 0 8
9875: PUSH
9876: CALL_OW 44
9880: ST_TO_ADDR
// if i mod 2 = 0 then
9881: LD_VAR 0 2
9885: PUSH
9886: LD_INT 2
9888: MOD
9889: PUSH
9890: LD_INT 0
9892: EQUAL
9893: IFFALSE 9907
// SetClass ( un , class_bazooker ) ;
9895: LD_VAR 0 8
9899: PPUSH
9900: LD_INT 9
9902: PPUSH
9903: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
9907: LD_VAR 0 8
9911: PPUSH
9912: LD_INT 674
9914: PPUSH
9915: CALL_OW 52
// end ;
9919: GO 9837
9921: POP
9922: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
9923: LD_INT 21
9925: PPUSH
9926: LD_INT 3
9928: PPUSH
9929: LD_INT 3
9931: PPUSH
9932: LD_INT 52
9934: PPUSH
9935: LD_INT 100
9937: PPUSH
9938: CALL 58098 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
9942: CALL_OW 45
9946: PPUSH
9947: LD_INT 259
9949: PPUSH
9950: LD_INT 145
9952: PPUSH
9953: LD_INT 3
9955: PPUSH
9956: LD_INT 0
9958: PPUSH
9959: CALL 93100 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
9963: CALL_OW 45
9967: PPUSH
9968: LD_INT 245
9970: PPUSH
9971: LD_INT 139
9973: PPUSH
9974: LD_INT 3
9976: PPUSH
9977: LD_INT 0
9979: PPUSH
9980: CALL 93100 0 5
// behemoths := [ ] ;
9984: LD_ADDR_EXP 64
9988: PUSH
9989: EMPTY
9990: ST_TO_ADDR
// behemothBuilders := [ ] ;
9991: LD_ADDR_EXP 65
9995: PUSH
9996: EMPTY
9997: ST_TO_ADDR
// j := 3 ;
9998: LD_ADDR_VAR 0 3
10002: PUSH
10003: LD_INT 3
10005: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
10006: LD_ADDR_VAR 0 2
10010: PUSH
10011: LD_INT 22
10013: PUSH
10014: LD_INT 3
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PUSH
10021: LD_INT 25
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PPUSH
10035: CALL_OW 69
10039: PUSH
10040: FOR_IN
10041: IFFALSE 10091
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
10043: LD_ADDR_EXP 65
10047: PUSH
10048: LD_EXP 65
10052: PPUSH
10053: LD_VAR 0 2
10057: PPUSH
10058: CALL 90960 0 2
10062: ST_TO_ADDR
// j := j - 1 ;
10063: LD_ADDR_VAR 0 3
10067: PUSH
10068: LD_VAR 0 3
10072: PUSH
10073: LD_INT 1
10075: MINUS
10076: ST_TO_ADDR
// if j = 0 then
10077: LD_VAR 0 3
10081: PUSH
10082: LD_INT 0
10084: EQUAL
10085: IFFALSE 10089
// break ;
10087: GO 10091
// end ;
10089: GO 10040
10091: POP
10092: POP
// end ;
10093: LD_VAR 0 1
10097: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
10098: LD_INT 0
10100: PPUSH
10101: PPUSH
10102: PPUSH
10103: PPUSH
10104: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
10105: LD_ADDR_VAR 0 4
10109: PUSH
10110: LD_INT 209
10112: PUSH
10113: LD_INT 149
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 219
10122: PUSH
10123: LD_INT 154
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PUSH
10130: LD_INT 223
10132: PUSH
10133: LD_INT 149
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: PUSH
10140: LD_INT 232
10142: PUSH
10143: LD_INT 155
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: ST_TO_ADDR
// if not behemothBuilders then
10156: LD_EXP 65
10160: NOT
10161: IFFALSE 10165
// exit ;
10163: GO 10269
// j := 1 ;
10165: LD_ADDR_VAR 0 3
10169: PUSH
10170: LD_INT 1
10172: ST_TO_ADDR
// for i in behemothBuilders do
10173: LD_ADDR_VAR 0 2
10177: PUSH
10178: LD_EXP 65
10182: PUSH
10183: FOR_IN
10184: IFFALSE 10267
// begin if IsInUnit ( i ) then
10186: LD_VAR 0 2
10190: PPUSH
10191: CALL_OW 310
10195: IFFALSE 10206
// ComExitBuilding ( i ) ;
10197: LD_VAR 0 2
10201: PPUSH
10202: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
10206: LD_VAR 0 2
10210: PPUSH
10211: LD_INT 37
10213: PPUSH
10214: LD_VAR 0 4
10218: PUSH
10219: LD_VAR 0 3
10223: ARRAY
10224: PUSH
10225: LD_INT 1
10227: ARRAY
10228: PPUSH
10229: LD_VAR 0 4
10233: PUSH
10234: LD_VAR 0 3
10238: ARRAY
10239: PUSH
10240: LD_INT 2
10242: ARRAY
10243: PPUSH
10244: LD_INT 0
10246: PPUSH
10247: CALL_OW 230
// j := j + 1 ;
10251: LD_ADDR_VAR 0 3
10255: PUSH
10256: LD_VAR 0 3
10260: PUSH
10261: LD_INT 1
10263: PLUS
10264: ST_TO_ADDR
// end ;
10265: GO 10183
10267: POP
10268: POP
// end ;
10269: LD_VAR 0 1
10273: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10274: LD_INT 3
10276: PPUSH
10277: CALL 91021 0 1
10281: PUSH
10282: LD_INT 22
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: PUSH
10292: LD_INT 30
10294: PUSH
10295: LD_INT 37
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: PPUSH
10306: CALL_OW 69
10310: NOT
10311: AND
10312: IFFALSE 10498
10314: GO 10316
10316: DISABLE
10317: LD_INT 0
10319: PPUSH
10320: PPUSH
// begin enable ;
10321: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10322: LD_ADDR_VAR 0 2
10326: PUSH
10327: LD_INT 3
10329: PPUSH
10330: CALL 91021 0 1
10334: ST_TO_ADDR
// for i in tmp do
10335: LD_ADDR_VAR 0 1
10339: PUSH
10340: LD_VAR 0 2
10344: PUSH
10345: FOR_IN
10346: IFFALSE 10496
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10348: LD_VAR 0 1
10352: PPUSH
10353: LD_INT 7
10355: PPUSH
10356: CALL_OW 308
10360: PUSH
10361: LD_VAR 0 1
10365: PPUSH
10366: CALL_OW 110
10370: PUSH
10371: LD_INT 2
10373: EQUAL
10374: NOT
10375: AND
10376: IFFALSE 10390
// SetTag ( i , 2 ) ;
10378: LD_VAR 0 1
10382: PPUSH
10383: LD_INT 2
10385: PPUSH
10386: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10390: LD_INT 81
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: PUSH
10400: LD_INT 91
10402: PUSH
10403: LD_VAR 0 1
10407: PUSH
10408: LD_INT 12
10410: PUSH
10411: EMPTY
10412: LIST
10413: LIST
10414: LIST
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: PPUSH
10420: CALL_OW 69
10424: NOT
10425: PUSH
10426: LD_VAR 0 1
10430: PPUSH
10431: CALL_OW 110
10435: PUSH
10436: LD_INT 2
10438: EQUAL
10439: NOT
10440: AND
10441: IFFALSE 10460
// ComAgressiveMove ( i , 64 , 93 ) else
10443: LD_VAR 0 1
10447: PPUSH
10448: LD_INT 64
10450: PPUSH
10451: LD_INT 93
10453: PPUSH
10454: CALL_OW 114
10458: GO 10494
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10460: LD_VAR 0 1
10464: PPUSH
10465: LD_INT 81
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: EMPTY
10472: LIST
10473: LIST
10474: PPUSH
10475: CALL_OW 69
10479: PPUSH
10480: LD_VAR 0 1
10484: PPUSH
10485: CALL_OW 74
10489: PPUSH
10490: CALL_OW 115
// end ;
10494: GO 10345
10496: POP
10497: POP
// end ;
10498: PPOPN 2
10500: END
// every 9 9$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10501: LD_EXP 2
10505: NOT
10506: IFFALSE 11567
10508: GO 10510
10510: DISABLE
10511: LD_INT 0
10513: PPUSH
10514: PPUSH
10515: PPUSH
10516: PPUSH
10517: PPUSH
// begin enable ;
10518: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10519: LD_INT 22
10521: PUSH
10522: LD_INT 3
10524: PUSH
10525: EMPTY
10526: LIST
10527: LIST
10528: PUSH
10529: LD_INT 30
10531: PUSH
10532: LD_INT 3
10534: PUSH
10535: EMPTY
10536: LIST
10537: LIST
10538: PUSH
10539: EMPTY
10540: LIST
10541: LIST
10542: PPUSH
10543: CALL_OW 69
10547: NOT
10548: IFFALSE 10552
// exit ;
10550: GO 11567
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10552: LD_ADDR_VAR 0 4
10556: PUSH
10557: LD_INT 22
10559: PUSH
10560: LD_INT 3
10562: PUSH
10563: EMPTY
10564: LIST
10565: LIST
10566: PUSH
10567: LD_INT 30
10569: PUSH
10570: LD_INT 34
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PUSH
10577: EMPTY
10578: LIST
10579: LIST
10580: PPUSH
10581: CALL_OW 69
10585: ST_TO_ADDR
// if Prob ( 40 ) then
10586: LD_INT 40
10588: PPUSH
10589: CALL_OW 13
10593: IFFALSE 10720
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10595: LD_INT 2
10597: PPUSH
10598: LD_INT 22
10600: PUSH
10601: LD_INT 3
10603: PUSH
10604: LD_INT 3
10606: PUSH
10607: LD_INT 49
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: PUSH
10616: LD_INT 22
10618: PUSH
10619: LD_INT 3
10621: PUSH
10622: LD_INT 3
10624: PUSH
10625: LD_INT 49
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: LIST
10632: LIST
10633: PUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 3
10639: PUSH
10640: LD_INT 3
10642: PUSH
10643: LD_INT 49
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: LIST
10650: LIST
10651: PUSH
10652: LD_INT 24
10654: PUSH
10655: LD_INT 3
10657: PUSH
10658: LD_INT 3
10660: PUSH
10661: LD_INT 46
10663: PUSH
10664: EMPTY
10665: LIST
10666: LIST
10667: LIST
10668: LIST
10669: PUSH
10670: LD_INT 24
10672: PUSH
10673: LD_INT 3
10675: PUSH
10676: LD_INT 3
10678: PUSH
10679: LD_INT 46
10681: PUSH
10682: EMPTY
10683: LIST
10684: LIST
10685: LIST
10686: LIST
10687: PUSH
10688: LD_INT 24
10690: PUSH
10691: LD_INT 3
10693: PUSH
10694: LD_INT 3
10696: PUSH
10697: LD_INT 46
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: LIST
10704: LIST
10705: PUSH
10706: EMPTY
10707: LIST
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: LIST
10713: PPUSH
10714: CALL 46832 0 2
// end else
10718: GO 10843
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10720: LD_INT 2
10722: PPUSH
10723: LD_INT 24
10725: PUSH
10726: LD_INT 3
10728: PUSH
10729: LD_INT 3
10731: PUSH
10732: LD_INT 47
10734: PUSH
10735: EMPTY
10736: LIST
10737: LIST
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 24
10743: PUSH
10744: LD_INT 3
10746: PUSH
10747: LD_INT 3
10749: PUSH
10750: LD_INT 47
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: PUSH
10759: LD_INT 24
10761: PUSH
10762: LD_INT 3
10764: PUSH
10765: LD_INT 3
10767: PUSH
10768: LD_INT 47
10770: PUSH
10771: EMPTY
10772: LIST
10773: LIST
10774: LIST
10775: LIST
10776: PUSH
10777: LD_INT 24
10779: PUSH
10780: LD_INT 3
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 46
10788: PUSH
10789: EMPTY
10790: LIST
10791: LIST
10792: LIST
10793: LIST
10794: PUSH
10795: LD_INT 24
10797: PUSH
10798: LD_INT 3
10800: PUSH
10801: LD_INT 3
10803: PUSH
10804: LD_INT 46
10806: PUSH
10807: EMPTY
10808: LIST
10809: LIST
10810: LIST
10811: LIST
10812: PUSH
10813: LD_INT 24
10815: PUSH
10816: LD_INT 3
10818: PUSH
10819: LD_INT 3
10821: PUSH
10822: LD_INT 46
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: LIST
10829: LIST
10830: PUSH
10831: EMPTY
10832: LIST
10833: LIST
10834: LIST
10835: LIST
10836: LIST
10837: LIST
10838: PPUSH
10839: CALL 46832 0 2
// end ; if Difficulty > 1 then
10843: LD_OWVAR 67
10847: PUSH
10848: LD_INT 1
10850: GREATER
10851: IFFALSE 10881
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10853: LD_INT 2
10855: PPUSH
10856: LD_INT 24
10858: PUSH
10859: LD_INT 3
10861: PUSH
10862: LD_INT 3
10864: PUSH
10865: LD_INT 47
10867: PUSH
10868: EMPTY
10869: LIST
10870: LIST
10871: LIST
10872: LIST
10873: PUSH
10874: EMPTY
10875: LIST
10876: PPUSH
10877: CALL 46832 0 2
// p := 0 ;
10881: LD_ADDR_VAR 0 5
10885: PUSH
10886: LD_INT 0
10888: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10889: LD_INT 35
10891: PPUSH
10892: CALL_OW 67
// p := Inc ( p ) ;
10896: LD_ADDR_VAR 0 5
10900: PUSH
10901: LD_VAR 0 5
10905: PPUSH
10906: CALL 92321 0 1
10910: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 120 ;
10911: LD_INT 2
10913: PPUSH
10914: LD_INT 1
10916: PPUSH
10917: CALL 48250 0 2
10921: PUSH
10922: LD_INT 6
10924: PUSH
10925: LD_INT 7
10927: PUSH
10928: LD_INT 7
10930: PUSH
10931: LD_INT 7
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: LIST
10938: LIST
10939: PUSH
10940: LD_OWVAR 67
10944: ARRAY
10945: GREATEREQUAL
10946: PUSH
10947: LD_VAR 0 5
10951: PUSH
10952: LD_INT 120
10954: GREATER
10955: OR
10956: IFFALSE 10889
// wait ( 0 0$30 ) ;
10958: LD_INT 1050
10960: PPUSH
10961: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
10965: LD_ADDR_VAR 0 2
10969: PUSH
10970: LD_INT 22
10972: PUSH
10973: LD_INT 3
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: PUSH
10980: LD_INT 21
10982: PUSH
10983: LD_INT 2
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: PUSH
10990: LD_INT 3
10992: PUSH
10993: LD_INT 34
10995: PUSH
10996: LD_INT 48
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: PUSH
11003: LD_INT 34
11005: PUSH
11006: LD_INT 51
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: PUSH
11013: LD_INT 34
11015: PUSH
11016: LD_INT 52
11018: PUSH
11019: EMPTY
11020: LIST
11021: LIST
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: PUSH
11029: EMPTY
11030: LIST
11031: LIST
11032: LIST
11033: PPUSH
11034: CALL_OW 69
11038: PUSH
11039: LD_EXP 100
11043: PUSH
11044: LD_INT 2
11046: ARRAY
11047: DIFF
11048: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11049: LD_ADDR_EXP 97
11053: PUSH
11054: LD_EXP 97
11058: PPUSH
11059: LD_INT 2
11061: PPUSH
11062: LD_EXP 97
11066: PUSH
11067: LD_INT 2
11069: ARRAY
11070: PUSH
11071: LD_VAR 0 2
11075: DIFF
11076: PPUSH
11077: CALL_OW 1
11081: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11082: LD_ADDR_VAR 0 3
11086: PUSH
11087: LD_INT 0
11089: PPUSH
11090: LD_INT 1
11092: PPUSH
11093: CALL_OW 12
11097: ST_TO_ADDR
// p := 0 ;
11098: LD_ADDR_VAR 0 5
11102: PUSH
11103: LD_INT 0
11105: ST_TO_ADDR
// if target then
11106: LD_VAR 0 3
11110: IFFALSE 11263
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11112: LD_ADDR_VAR 0 2
11116: PUSH
11117: LD_VAR 0 2
11121: PPUSH
11122: LD_INT 24
11124: PUSH
11125: LD_INT 250
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: PPUSH
11132: CALL_OW 72
11136: ST_TO_ADDR
// for i in tmp do
11137: LD_ADDR_VAR 0 1
11141: PUSH
11142: LD_VAR 0 2
11146: PUSH
11147: FOR_IN
11148: IFFALSE 11188
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11150: LD_VAR 0 1
11154: PPUSH
11155: LD_INT 139
11157: PPUSH
11158: LD_INT 89
11160: PPUSH
11161: CALL_OW 297
11165: PUSH
11166: LD_INT 9
11168: GREATER
11169: IFFALSE 11186
// ComMoveXY ( i , 139 , 89 ) ;
11171: LD_VAR 0 1
11175: PPUSH
11176: LD_INT 139
11178: PPUSH
11179: LD_INT 89
11181: PPUSH
11182: CALL_OW 111
11186: GO 11147
11188: POP
11189: POP
// wait ( 0 0$1 ) ;
11190: LD_INT 35
11192: PPUSH
11193: CALL_OW 67
// p := Inc ( p ) ;
11197: LD_ADDR_VAR 0 5
11201: PUSH
11202: LD_VAR 0 5
11206: PPUSH
11207: CALL 92321 0 1
11211: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11212: LD_VAR 0 2
11216: PPUSH
11217: LD_INT 92
11219: PUSH
11220: LD_INT 139
11222: PUSH
11223: LD_INT 89
11225: PUSH
11226: LD_INT 9
11228: PUSH
11229: EMPTY
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: PPUSH
11235: CALL_OW 72
11239: PUSH
11240: LD_VAR 0 2
11244: PUSH
11245: LD_INT 1
11247: MINUS
11248: GREATEREQUAL
11249: PUSH
11250: LD_VAR 0 5
11254: PUSH
11255: LD_INT 30
11257: GREATER
11258: OR
11259: IFFALSE 11112
// end else
11261: GO 11430
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11263: LD_VAR 0 2
11267: PPUSH
11268: LD_VAR 0 4
11272: PUSH
11273: LD_INT 1
11275: ARRAY
11276: PPUSH
11277: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11281: LD_ADDR_VAR 0 2
11285: PUSH
11286: LD_VAR 0 2
11290: PPUSH
11291: LD_INT 24
11293: PUSH
11294: LD_INT 250
11296: PUSH
11297: EMPTY
11298: LIST
11299: LIST
11300: PPUSH
11301: CALL_OW 72
11305: ST_TO_ADDR
// for i in tmp do
11306: LD_ADDR_VAR 0 1
11310: PUSH
11311: LD_VAR 0 2
11315: PUSH
11316: FOR_IN
11317: IFFALSE 11357
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11319: LD_VAR 0 1
11323: PPUSH
11324: LD_INT 124
11326: PPUSH
11327: LD_INT 139
11329: PPUSH
11330: CALL_OW 297
11334: PUSH
11335: LD_INT 9
11337: GREATER
11338: IFFALSE 11355
// ComMoveXY ( i , 124 , 139 ) ;
11340: LD_VAR 0 1
11344: PPUSH
11345: LD_INT 124
11347: PPUSH
11348: LD_INT 139
11350: PPUSH
11351: CALL_OW 111
11355: GO 11316
11357: POP
11358: POP
// wait ( 0 0$1 ) ;
11359: LD_INT 35
11361: PPUSH
11362: CALL_OW 67
// p := Inc ( p ) ;
11366: LD_ADDR_VAR 0 5
11370: PUSH
11371: LD_VAR 0 5
11375: PPUSH
11376: CALL 92321 0 1
11380: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11381: LD_VAR 0 2
11385: PPUSH
11386: LD_INT 92
11388: PUSH
11389: LD_INT 124
11391: PUSH
11392: LD_INT 139
11394: PUSH
11395: LD_INT 9
11397: PUSH
11398: EMPTY
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: PPUSH
11404: CALL_OW 72
11408: PUSH
11409: LD_VAR 0 2
11413: PUSH
11414: LD_INT 1
11416: MINUS
11417: GREATEREQUAL
11418: PUSH
11419: LD_VAR 0 5
11423: PUSH
11424: LD_INT 30
11426: GREATER
11427: OR
11428: IFFALSE 11281
// end ; repeat wait ( 0 0$1 ) ;
11430: LD_INT 35
11432: PPUSH
11433: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11437: LD_ADDR_VAR 0 2
11441: PUSH
11442: LD_VAR 0 2
11446: PPUSH
11447: LD_INT 50
11449: PUSH
11450: EMPTY
11451: LIST
11452: PPUSH
11453: CALL_OW 72
11457: ST_TO_ADDR
// for i in tmp do
11458: LD_ADDR_VAR 0 1
11462: PUSH
11463: LD_VAR 0 2
11467: PUSH
11468: FOR_IN
11469: IFFALSE 11558
// begin if GetWeapon ( i ) = ru_time_lapser then
11471: LD_VAR 0 1
11475: PPUSH
11476: CALL_OW 264
11480: PUSH
11481: LD_INT 49
11483: EQUAL
11484: IFFALSE 11522
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11486: LD_VAR 0 1
11490: PPUSH
11491: LD_INT 81
11493: PUSH
11494: LD_INT 3
11496: PUSH
11497: EMPTY
11498: LIST
11499: LIST
11500: PPUSH
11501: CALL_OW 69
11505: PPUSH
11506: LD_VAR 0 1
11510: PPUSH
11511: CALL_OW 74
11515: PPUSH
11516: CALL_OW 112
11520: GO 11556
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11522: LD_VAR 0 1
11526: PPUSH
11527: LD_INT 81
11529: PUSH
11530: LD_INT 3
11532: PUSH
11533: EMPTY
11534: LIST
11535: LIST
11536: PPUSH
11537: CALL_OW 69
11541: PPUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 74
11551: PPUSH
11552: CALL_OW 115
// end ;
11556: GO 11468
11558: POP
11559: POP
// until not tmp ;
11560: LD_VAR 0 2
11564: NOT
11565: IFFALSE 11430
// end ;
11567: PPOPN 5
11569: END
// every 30 30$00 trigger not russianDestroyed do
11570: LD_EXP 2
11574: NOT
11575: IFFALSE 11644
11577: GO 11579
11579: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11580: LD_INT 105000
11582: PUSH
11583: LD_INT 84000
11585: PUSH
11586: LD_INT 63000
11588: PUSH
11589: LD_INT 52500
11591: PUSH
11592: EMPTY
11593: LIST
11594: LIST
11595: LIST
11596: LIST
11597: PUSH
11598: LD_OWVAR 67
11602: ARRAY
11603: PPUSH
11604: CALL_OW 67
// if russianDestroyed then
11608: LD_EXP 2
11612: IFFALSE 11616
// exit ;
11614: GO 11644
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11616: LD_INT 2
11618: PPUSH
11619: LD_INT 23
11621: PUSH
11622: LD_INT 3
11624: PUSH
11625: LD_INT 1
11627: PUSH
11628: LD_INT 48
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: PUSH
11637: EMPTY
11638: LIST
11639: PPUSH
11640: CALL 46832 0 2
// end ; end_of_file
11644: END
// export function CustomEvent ( event ) ; begin
11645: LD_INT 0
11647: PPUSH
// end ;
11648: LD_VAR 0 2
11652: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11653: LD_VAR 0 2
11657: PPUSH
11658: LD_VAR 0 3
11662: PPUSH
11663: LD_INT 15
11665: PPUSH
11666: CALL_OW 309
11670: IFFALSE 11679
// YouLost ( MothContaminate ) ;
11672: LD_STRING MothContaminate
11674: PPUSH
11675: CALL_OW 104
// end ;
11679: PPOPN 3
11681: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11682: LD_VAR 0 2
11686: PPUSH
11687: LD_VAR 0 3
11691: PPUSH
11692: LD_INT 15
11694: PPUSH
11695: CALL_OW 309
11699: IFFALSE 11715
// begin wait ( 0 0$6 ) ;
11701: LD_INT 210
11703: PPUSH
11704: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11708: LD_STRING MothContaminateBomb
11710: PPUSH
11711: CALL_OW 104
// end ; end ;
11715: PPOPN 3
11717: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11718: LD_VAR 0 1
11722: PPUSH
11723: CALL 111292 0 1
// if un = JMM then
11727: LD_VAR 0 1
11731: PUSH
11732: LD_EXP 19
11736: EQUAL
11737: IFFALSE 11748
// begin YouLost ( JMM ) ;
11739: LD_STRING JMM
11741: PPUSH
11742: CALL_OW 104
// exit ;
11746: GO 11877
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11748: LD_VAR 0 1
11752: PPUSH
11753: CALL_OW 255
11757: PUSH
11758: LD_INT 2
11760: EQUAL
11761: PUSH
11762: LD_EXP 18
11766: NOT
11767: AND
11768: IFFALSE 11778
// arabianAttacked := true ;
11770: LD_ADDR_EXP 18
11774: PUSH
11775: LD_INT 1
11777: ST_TO_ADDR
// if un = Powell then
11778: LD_VAR 0 1
11782: PUSH
11783: LD_EXP 55
11787: EQUAL
11788: IFFALSE 11798
// americanDestroyed := true ;
11790: LD_ADDR_EXP 4
11794: PUSH
11795: LD_INT 1
11797: ST_TO_ADDR
// if un = Platonov then
11798: LD_VAR 0 1
11802: PUSH
11803: LD_EXP 60
11807: EQUAL
11808: IFFALSE 11818
// russianDestroyed := true ;
11810: LD_ADDR_EXP 2
11814: PUSH
11815: LD_INT 1
11817: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11818: LD_VAR 0 1
11822: PUSH
11823: LD_INT 22
11825: PUSH
11826: LD_INT 7
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: PUSH
11833: LD_INT 21
11835: PUSH
11836: LD_INT 2
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: PUSH
11843: EMPTY
11844: LIST
11845: LIST
11846: PPUSH
11847: CALL_OW 69
11851: IN
11852: IFFALSE 11868
// vehicleLostCounter := vehicleLostCounter + 1 ;
11854: LD_ADDR_EXP 15
11858: PUSH
11859: LD_EXP 15
11863: PUSH
11864: LD_INT 1
11866: PLUS
11867: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11868: LD_VAR 0 1
11872: PPUSH
11873: CALL 50274 0 1
// end ;
11877: PPOPN 1
11879: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11880: LD_VAR 0 1
11884: PPUSH
11885: LD_VAR 0 2
11889: PPUSH
11890: CALL 52606 0 2
// end ;
11894: PPOPN 2
11896: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11897: LD_VAR 0 1
11901: PPUSH
11902: CALL 51674 0 1
// end ;
11906: PPOPN 1
11908: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11909: LD_VAR 0 1
11913: PUSH
11914: LD_INT 22
11916: PUSH
11917: LD_INT 8
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: PUSH
11924: LD_INT 30
11926: PUSH
11927: LD_INT 2
11929: PUSH
11930: EMPTY
11931: LIST
11932: LIST
11933: PUSH
11934: LD_INT 23
11936: PUSH
11937: LD_INT 3
11939: PUSH
11940: EMPTY
11941: LIST
11942: LIST
11943: PUSH
11944: EMPTY
11945: LIST
11946: LIST
11947: LIST
11948: PPUSH
11949: CALL_OW 69
11953: IN
11954: IFFALSE 11981
// begin ComUpgrade ( building ) ;
11956: LD_VAR 0 1
11960: PPUSH
11961: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11965: LD_EXP 58
11969: PPUSH
11970: LD_VAR 0 1
11974: PPUSH
11975: CALL 61458 0 2
// exit ;
11979: GO 11990
// end ; MCE_BuildingComplete ( building ) ;
11981: LD_VAR 0 1
11985: PPUSH
11986: CALL 51915 0 1
// end ;
11990: PPOPN 1
11992: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11993: LD_VAR 0 1
11997: PPUSH
11998: LD_VAR 0 2
12002: PPUSH
12003: CALL 49970 0 2
// end ;
12007: PPOPN 2
12009: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12010: LD_VAR 0 1
12014: PPUSH
12015: LD_VAR 0 2
12019: PPUSH
12020: LD_VAR 0 3
12024: PPUSH
12025: LD_VAR 0 4
12029: PPUSH
12030: LD_VAR 0 5
12034: PPUSH
12035: CALL 49590 0 5
// end ;
12039: PPOPN 5
12041: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
12042: LD_VAR 0 1
12046: PPUSH
12047: LD_VAR 0 2
12051: PPUSH
12052: CALL 111412 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
12056: LD_VAR 0 1
12060: PPUSH
12061: LD_VAR 0 2
12065: PPUSH
12066: CALL 49143 0 2
// end ;
12070: PPOPN 2
12072: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12073: LD_VAR 0 1
12077: PPUSH
12078: LD_VAR 0 2
12082: PPUSH
12083: LD_VAR 0 3
12087: PPUSH
12088: LD_VAR 0 4
12092: PPUSH
12093: CALL 48981 0 4
// end ;
12097: PPOPN 4
12099: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12100: LD_VAR 0 1
12104: PPUSH
12105: LD_VAR 0 2
12109: PPUSH
12110: LD_VAR 0 3
12114: PPUSH
12115: CALL 48756 0 3
// end ;
12119: PPOPN 3
12121: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12122: LD_VAR 0 1
12126: PPUSH
12127: LD_VAR 0 2
12131: PPUSH
12132: CALL 48641 0 2
// end ;
12136: PPOPN 2
12138: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12139: LD_VAR 0 1
12143: PPUSH
12144: LD_VAR 0 2
12148: PPUSH
12149: CALL 52901 0 2
// end ;
12153: PPOPN 2
12155: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
12156: LD_VAR 0 1
12160: PUSH
12161: LD_INT 674
12163: EQUAL
12164: IFFALSE 12186
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
12166: LD_VAR 0 2
12170: PPUSH
12171: LD_INT 227
12173: PPUSH
12174: LD_INT 136
12176: PPUSH
12177: CALL_OW 428
12181: PPUSH
12182: CALL_OW 120
// end ;
12186: PPOPN 2
12188: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12189: LD_VAR 0 1
12193: PPUSH
12194: LD_VAR 0 2
12198: PPUSH
12199: LD_VAR 0 3
12203: PPUSH
12204: LD_VAR 0 4
12208: PPUSH
12209: CALL 53117 0 4
// end ;
12213: PPOPN 4
12215: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12216: LD_VAR 0 1
12220: PPUSH
12221: LD_VAR 0 2
12225: PPUSH
12226: CALL 48450 0 2
// end ;
12230: PPOPN 2
12232: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12233: LD_VAR 0 1
12237: PPUSH
12238: CALL 111396 0 1
// end ; end_of_file
12242: PPOPN 1
12244: END
// export function Action ; begin
12245: LD_INT 0
12247: PPUSH
// InGameOn ;
12248: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
12252: LD_INT 206
12254: PPUSH
12255: LD_INT 11
12257: PPUSH
12258: CALL_OW 86
// wait ( 0 0$1 ) ;
12262: LD_INT 35
12264: PPUSH
12265: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
12269: LD_EXP 19
12273: PPUSH
12274: LD_STRING DStart-JMM-JMM-1
12276: PPUSH
12277: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
12281: LD_EXP 52
12285: PPUSH
12286: LD_STRING DStart-JMM-Bur-1
12288: PPUSH
12289: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
12293: LD_EXP 19
12297: PPUSH
12298: LD_STRING DStart-JMM-JMM-2
12300: PPUSH
12301: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
12305: LD_EXP 52
12309: PPUSH
12310: LD_STRING DStart-JMM-Bur-2
12312: PPUSH
12313: CALL_OW 88
// InGameOff ;
12317: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
12321: LD_STRING MStart
12323: PPUSH
12324: CALL_OW 337
// SaveForQuickRestart ;
12328: CALL_OW 22
// end ;
12332: LD_VAR 0 1
12336: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
12337: LD_INT 7
12339: PPUSH
12340: LD_INT 255
12342: PPUSH
12343: LD_INT 219
12345: PPUSH
12346: CALL_OW 293
12350: IFFALSE 12959
12352: GO 12354
12354: DISABLE
12355: LD_INT 0
12357: PPUSH
// begin wait ( 0 0$3 ) ;
12358: LD_INT 105
12360: PPUSH
12361: CALL_OW 67
// alienSpotted := true ;
12365: LD_ADDR_EXP 10
12369: PUSH
12370: LD_INT 1
12372: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12373: LD_ADDR_VAR 0 1
12377: PUSH
12378: LD_INT 22
12380: PUSH
12381: LD_INT 7
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: PUSH
12388: LD_INT 23
12390: PUSH
12391: LD_INT 3
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: LD_INT 21
12400: PUSH
12401: LD_INT 1
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 26
12410: PUSH
12411: LD_INT 1
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: LIST
12422: LIST
12423: PPUSH
12424: CALL_OW 69
12428: PUSH
12429: LD_EXP 52
12433: PUSH
12434: LD_EXP 40
12438: PUSH
12439: LD_EXP 42
12443: PUSH
12444: LD_EXP 43
12448: PUSH
12449: LD_EXP 50
12453: PUSH
12454: LD_EXP 49
12458: PUSH
12459: LD_EXP 44
12463: PUSH
12464: EMPTY
12465: LIST
12466: LIST
12467: LIST
12468: LIST
12469: LIST
12470: LIST
12471: LIST
12472: DIFF
12473: ST_TO_ADDR
// DialogueOn ;
12474: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12478: LD_INT 255
12480: PPUSH
12481: LD_INT 219
12483: PPUSH
12484: LD_INT 7
12486: PPUSH
12487: LD_INT 20
12489: NEG
12490: PPUSH
12491: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12495: LD_INT 255
12497: PPUSH
12498: LD_INT 219
12500: PPUSH
12501: CALL_OW 86
// if speaker then
12505: LD_VAR 0 1
12509: IFFALSE 12527
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12511: LD_VAR 0 1
12515: PUSH
12516: LD_INT 1
12518: ARRAY
12519: PPUSH
12520: LD_STRING DAlienBase-RSol1-1
12522: PPUSH
12523: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12527: LD_EXP 19
12531: PPUSH
12532: LD_STRING DAlienBase-JMM-1
12534: PPUSH
12535: CALL_OW 88
// if IsOk ( Burlak ) then
12539: LD_EXP 52
12543: PPUSH
12544: CALL_OW 302
12548: IFFALSE 12569
// begin dwait ( 0 0$1 ) ;
12550: LD_INT 35
12552: PPUSH
12553: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12557: LD_EXP 52
12561: PPUSH
12562: LD_STRING DAlienBase-Bur-1
12564: PPUSH
12565: CALL_OW 88
// end ; if IsOk ( Roth ) then
12569: LD_EXP 20
12573: PPUSH
12574: CALL_OW 302
12578: IFFALSE 12592
// Say ( Roth , DAlienBase-Roth-1 ) ;
12580: LD_EXP 20
12584: PPUSH
12585: LD_STRING DAlienBase-Roth-1
12587: PPUSH
12588: CALL_OW 88
// if IsOk ( Gossudarov ) then
12592: LD_EXP 38
12596: PPUSH
12597: CALL_OW 302
12601: IFFALSE 12617
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12603: LD_EXP 38
12607: PPUSH
12608: LD_STRING DAlienBase-Gos-1
12610: PPUSH
12611: CALL_OW 88
12615: GO 12734
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12617: LD_ADDR_VAR 0 1
12621: PUSH
12622: LD_INT 22
12624: PUSH
12625: LD_INT 7
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 25
12634: PUSH
12635: LD_INT 4
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: LD_INT 21
12644: PUSH
12645: LD_INT 1
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PUSH
12652: LD_INT 26
12654: PUSH
12655: LD_INT 1
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: LIST
12666: LIST
12667: PPUSH
12668: CALL_OW 69
12672: PUSH
12673: LD_EXP 20
12677: PUSH
12678: LD_EXP 19
12682: PUSH
12683: LD_EXP 52
12687: PUSH
12688: LD_EXP 40
12692: PUSH
12693: LD_EXP 50
12697: PUSH
12698: LD_EXP 49
12702: PUSH
12703: EMPTY
12704: LIST
12705: LIST
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: DIFF
12711: ST_TO_ADDR
// if speaker then
12712: LD_VAR 0 1
12716: IFFALSE 12734
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12718: LD_VAR 0 1
12722: PUSH
12723: LD_INT 1
12725: ARRAY
12726: PPUSH
12727: LD_STRING DAlienBase-Sci1-1
12729: PPUSH
12730: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12734: LD_INT 255
12736: PPUSH
12737: LD_INT 219
12739: PPUSH
12740: LD_INT 7
12742: PPUSH
12743: CALL_OW 331
// DialogueOff ;
12747: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12751: LD_INT 35
12753: PPUSH
12754: CALL_OW 67
// until IsSelected ( alien ) ;
12758: LD_INT 1
12760: PPUSH
12761: CALL_OW 306
12765: IFFALSE 12751
// if not artifactIResearched or not artifactIIResearched then
12767: LD_EXP 12
12771: NOT
12772: PUSH
12773: LD_EXP 13
12777: NOT
12778: OR
12779: IFFALSE 12959
// begin if IsOk ( Roth ) then
12781: LD_EXP 20
12785: PPUSH
12786: CALL_OW 302
12790: IFFALSE 12806
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12792: LD_EXP 20
12796: PPUSH
12797: LD_STRING DAlieBaseNotReady-Roth-1
12799: PPUSH
12800: CALL_OW 88
12804: GO 12959
// if IsOk ( Gossudarov ) then
12806: LD_EXP 38
12810: PPUSH
12811: CALL_OW 302
12815: IFFALSE 12831
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12817: LD_EXP 38
12821: PPUSH
12822: LD_STRING DAlieBaseNotReady-Gos-1
12824: PPUSH
12825: CALL_OW 88
12829: GO 12959
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12831: LD_ADDR_VAR 0 1
12835: PUSH
12836: LD_INT 22
12838: PUSH
12839: LD_INT 7
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 23
12848: PUSH
12849: LD_INT 3
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: LD_INT 25
12858: PUSH
12859: LD_INT 4
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: LD_INT 21
12868: PUSH
12869: LD_INT 1
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: PUSH
12876: LD_INT 26
12878: PUSH
12879: LD_INT 1
12881: PUSH
12882: EMPTY
12883: LIST
12884: LIST
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: PPUSH
12893: CALL_OW 69
12897: PUSH
12898: LD_EXP 20
12902: PUSH
12903: LD_EXP 19
12907: PUSH
12908: LD_EXP 52
12912: PUSH
12913: LD_EXP 40
12917: PUSH
12918: LD_EXP 50
12922: PUSH
12923: LD_EXP 49
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: DIFF
12936: ST_TO_ADDR
// if speaker then
12937: LD_VAR 0 1
12941: IFFALSE 12959
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12943: LD_VAR 0 1
12947: PUSH
12948: LD_INT 1
12950: ARRAY
12951: PPUSH
12952: LD_STRING DAlieBaseNotReady-RSci1-1
12954: PPUSH
12955: CALL_OW 88
// end ; end ; end ;
12959: PPOPN 1
12961: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12962: LD_INT 24
12964: PPUSH
12965: LD_INT 7
12967: PPUSH
12968: CALL_OW 321
12972: PUSH
12973: LD_INT 2
12975: EQUAL
12976: IFFALSE 13667
12978: GO 12980
12980: DISABLE
12981: LD_INT 0
12983: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12984: LD_ADDR_VAR 0 1
12988: PUSH
12989: LD_INT 22
12991: PUSH
12992: LD_INT 7
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PUSH
12999: LD_INT 23
13001: PUSH
13002: LD_INT 3
13004: PUSH
13005: EMPTY
13006: LIST
13007: LIST
13008: PUSH
13009: LD_INT 25
13011: PUSH
13012: LD_INT 4
13014: PUSH
13015: EMPTY
13016: LIST
13017: LIST
13018: PUSH
13019: LD_INT 21
13021: PUSH
13022: LD_INT 1
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: PUSH
13029: LD_INT 26
13031: PUSH
13032: LD_INT 1
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: PPUSH
13046: CALL_OW 69
13050: PUSH
13051: LD_EXP 20
13055: PUSH
13056: LD_EXP 19
13060: PUSH
13061: LD_EXP 52
13065: PUSH
13066: LD_EXP 40
13070: PUSH
13071: LD_EXP 50
13075: PUSH
13076: LD_EXP 49
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: DIFF
13089: ST_TO_ADDR
// if not speaker then
13090: LD_VAR 0 1
13094: NOT
13095: IFFALSE 13099
// exit ;
13097: GO 13667
// DialogueOn ;
13099: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
13103: LD_VAR 0 1
13107: PUSH
13108: LD_INT 1
13110: ARRAY
13111: PPUSH
13112: LD_STRING DArtefTechnology-RSci1-1
13114: PPUSH
13115: CALL_OW 88
// if IsOk ( Burlak ) then
13119: LD_EXP 52
13123: PPUSH
13124: CALL_OW 302
13128: IFFALSE 13142
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
13130: LD_EXP 52
13134: PPUSH
13135: LD_STRING DArtefTechnology-Bur-1
13137: PPUSH
13138: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
13142: LD_VAR 0 1
13146: PUSH
13147: LD_INT 1
13149: ARRAY
13150: PPUSH
13151: LD_STRING DArtefTechnology-RSci1-2
13153: PPUSH
13154: CALL_OW 88
// if Denis then
13158: LD_EXP 25
13162: IFFALSE 13179
// speaker := [ Denis ] else
13164: LD_ADDR_VAR 0 1
13168: PUSH
13169: LD_EXP 25
13173: PUSH
13174: EMPTY
13175: LIST
13176: ST_TO_ADDR
13177: GO 13285
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13179: LD_ADDR_VAR 0 1
13183: PUSH
13184: LD_INT 22
13186: PUSH
13187: LD_INT 7
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PUSH
13194: LD_INT 23
13196: PUSH
13197: LD_INT 1
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: PUSH
13204: LD_INT 25
13206: PUSH
13207: LD_INT 4
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 21
13216: PUSH
13217: LD_INT 1
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PUSH
13224: LD_INT 26
13226: PUSH
13227: LD_INT 1
13229: PUSH
13230: EMPTY
13231: LIST
13232: LIST
13233: PUSH
13234: EMPTY
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: LIST
13240: PPUSH
13241: CALL_OW 69
13245: PUSH
13246: LD_EXP 20
13250: PUSH
13251: LD_EXP 19
13255: PUSH
13256: LD_EXP 52
13260: PUSH
13261: LD_EXP 40
13265: PUSH
13266: LD_EXP 50
13270: PUSH
13271: LD_EXP 49
13275: PUSH
13276: EMPTY
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: LIST
13282: LIST
13283: DIFF
13284: ST_TO_ADDR
// if speaker then
13285: LD_VAR 0 1
13289: IFFALSE 13307
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
13291: LD_VAR 0 1
13295: PUSH
13296: LD_INT 1
13298: ARRAY
13299: PPUSH
13300: LD_STRING DArtefTechnology-Sci1-2
13302: PPUSH
13303: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13307: LD_ADDR_VAR 0 1
13311: PUSH
13312: LD_INT 22
13314: PUSH
13315: LD_INT 7
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PUSH
13322: LD_INT 23
13324: PUSH
13325: LD_INT 3
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PUSH
13332: LD_INT 25
13334: PUSH
13335: LD_INT 4
13337: PUSH
13338: EMPTY
13339: LIST
13340: LIST
13341: PUSH
13342: LD_INT 21
13344: PUSH
13345: LD_INT 1
13347: PUSH
13348: EMPTY
13349: LIST
13350: LIST
13351: PUSH
13352: LD_INT 26
13354: PUSH
13355: LD_INT 1
13357: PUSH
13358: EMPTY
13359: LIST
13360: LIST
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: PPUSH
13369: CALL_OW 69
13373: PUSH
13374: LD_EXP 20
13378: PUSH
13379: LD_EXP 19
13383: PUSH
13384: LD_EXP 52
13388: PUSH
13389: LD_EXP 40
13393: PUSH
13394: LD_EXP 50
13398: PUSH
13399: LD_EXP 49
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: LIST
13408: LIST
13409: LIST
13410: LIST
13411: DIFF
13412: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13413: LD_VAR 0 1
13417: PUSH
13418: LD_EXP 9
13422: PUSH
13423: LD_EXP 5
13427: OR
13428: AND
13429: IFFALSE 13663
// begin if arabianDestroyed and IsOk ( Burlak ) then
13431: LD_EXP 5
13435: PUSH
13436: LD_EXP 52
13440: PPUSH
13441: CALL_OW 302
13445: AND
13446: IFFALSE 13462
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13448: LD_EXP 52
13452: PPUSH
13453: LD_STRING DArtefTechnology-Bur-2
13455: PPUSH
13456: CALL_OW 88
13460: GO 13474
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13462: LD_EXP 19
13466: PPUSH
13467: LD_STRING DArtefTechnology-JMM-2
13469: PPUSH
13470: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13474: LD_VAR 0 1
13478: PUSH
13479: LD_INT 1
13481: ARRAY
13482: PPUSH
13483: LD_STRING DArtefTechnology-RSci1-3
13485: PPUSH
13486: CALL_OW 88
// if Denis then
13490: LD_EXP 25
13494: IFFALSE 13511
// speaker := [ Denis ] else
13496: LD_ADDR_VAR 0 1
13500: PUSH
13501: LD_EXP 25
13505: PUSH
13506: EMPTY
13507: LIST
13508: ST_TO_ADDR
13509: GO 13617
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13511: LD_ADDR_VAR 0 1
13515: PUSH
13516: LD_INT 22
13518: PUSH
13519: LD_INT 7
13521: PUSH
13522: EMPTY
13523: LIST
13524: LIST
13525: PUSH
13526: LD_INT 23
13528: PUSH
13529: LD_INT 1
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: LD_INT 25
13538: PUSH
13539: LD_INT 4
13541: PUSH
13542: EMPTY
13543: LIST
13544: LIST
13545: PUSH
13546: LD_INT 21
13548: PUSH
13549: LD_INT 1
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: LD_INT 26
13558: PUSH
13559: LD_INT 1
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PUSH
13566: EMPTY
13567: LIST
13568: LIST
13569: LIST
13570: LIST
13571: LIST
13572: PPUSH
13573: CALL_OW 69
13577: PUSH
13578: LD_EXP 20
13582: PUSH
13583: LD_EXP 19
13587: PUSH
13588: LD_EXP 52
13592: PUSH
13593: LD_EXP 40
13597: PUSH
13598: LD_EXP 50
13602: PUSH
13603: LD_EXP 49
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: LIST
13614: LIST
13615: DIFF
13616: ST_TO_ADDR
// if speaker then
13617: LD_VAR 0 1
13621: IFFALSE 13663
// if alienSpotted then
13623: LD_EXP 10
13627: IFFALSE 13647
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13629: LD_VAR 0 1
13633: PUSH
13634: LD_INT 1
13636: ARRAY
13637: PPUSH
13638: LD_STRING DArtefTechnology-Sci1-3
13640: PPUSH
13641: CALL_OW 88
13645: GO 13663
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13647: LD_VAR 0 1
13651: PUSH
13652: LD_INT 1
13654: ARRAY
13655: PPUSH
13656: LD_STRING DArtefTechnology-Sci1-3a
13658: PPUSH
13659: CALL_OW 88
// end ; DialogueOff ;
13663: CALL_OW 7
// end ;
13667: PPOPN 1
13669: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13670: LD_EXP 12
13674: IFFALSE 13877
13676: GO 13678
13678: DISABLE
13679: LD_INT 0
13681: PPUSH
// begin if Denis then
13682: LD_EXP 25
13686: IFFALSE 13703
// speaker := [ Denis ] else
13688: LD_ADDR_VAR 0 1
13692: PUSH
13693: LD_EXP 25
13697: PUSH
13698: EMPTY
13699: LIST
13700: ST_TO_ADDR
13701: GO 13809
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13703: LD_ADDR_VAR 0 1
13707: PUSH
13708: LD_INT 22
13710: PUSH
13711: LD_INT 7
13713: PUSH
13714: EMPTY
13715: LIST
13716: LIST
13717: PUSH
13718: LD_INT 23
13720: PUSH
13721: LD_INT 1
13723: PUSH
13724: EMPTY
13725: LIST
13726: LIST
13727: PUSH
13728: LD_INT 25
13730: PUSH
13731: LD_INT 4
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: PUSH
13738: LD_INT 21
13740: PUSH
13741: LD_INT 1
13743: PUSH
13744: EMPTY
13745: LIST
13746: LIST
13747: PUSH
13748: LD_INT 26
13750: PUSH
13751: LD_INT 1
13753: PUSH
13754: EMPTY
13755: LIST
13756: LIST
13757: PUSH
13758: EMPTY
13759: LIST
13760: LIST
13761: LIST
13762: LIST
13763: LIST
13764: PPUSH
13765: CALL_OW 69
13769: PUSH
13770: LD_EXP 20
13774: PUSH
13775: LD_EXP 19
13779: PUSH
13780: LD_EXP 52
13784: PUSH
13785: LD_EXP 40
13789: PUSH
13790: LD_EXP 50
13794: PUSH
13795: LD_EXP 49
13799: PUSH
13800: EMPTY
13801: LIST
13802: LIST
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: DIFF
13808: ST_TO_ADDR
// if not speaker then
13809: LD_VAR 0 1
13813: NOT
13814: IFFALSE 13818
// exit ;
13816: GO 13877
// DialogueOn ;
13818: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13822: LD_VAR 0 1
13826: PUSH
13827: LD_INT 1
13829: ARRAY
13830: PPUSH
13831: LD_STRING DArtefTechnologyAm-Sci1-1
13833: PPUSH
13834: CALL_OW 88
// if IsOk ( Burlak ) then
13838: LD_EXP 52
13842: PPUSH
13843: CALL_OW 302
13847: IFFALSE 13861
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13849: LD_EXP 52
13853: PPUSH
13854: LD_STRING DArtefTechnologyAm-Bur-1
13856: PPUSH
13857: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13861: LD_EXP 19
13865: PPUSH
13866: LD_STRING DArtefTechnologyAm-JMM-1
13868: PPUSH
13869: CALL_OW 88
// DialogueOff ;
13873: CALL_OW 7
// end ;
13877: PPOPN 1
13879: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13880: LD_EXP 13
13884: IFFALSE 14086
13886: GO 13888
13888: DISABLE
13889: LD_INT 0
13891: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13892: LD_ADDR_VAR 0 1
13896: PUSH
13897: LD_INT 22
13899: PUSH
13900: LD_INT 7
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: PUSH
13907: LD_INT 23
13909: PUSH
13910: LD_INT 3
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: PUSH
13917: LD_INT 25
13919: PUSH
13920: LD_INT 4
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: PUSH
13927: LD_INT 21
13929: PUSH
13930: LD_INT 1
13932: PUSH
13933: EMPTY
13934: LIST
13935: LIST
13936: PUSH
13937: LD_INT 26
13939: PUSH
13940: LD_INT 1
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: PUSH
13947: EMPTY
13948: LIST
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: PPUSH
13954: CALL_OW 69
13958: PUSH
13959: LD_EXP 20
13963: PUSH
13964: LD_EXP 19
13968: PUSH
13969: LD_EXP 52
13973: PUSH
13974: LD_EXP 40
13978: PUSH
13979: LD_EXP 50
13983: PUSH
13984: LD_EXP 49
13988: PUSH
13989: EMPTY
13990: LIST
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: LIST
13996: DIFF
13997: ST_TO_ADDR
// if not speaker then
13998: LD_VAR 0 1
14002: NOT
14003: IFFALSE 14007
// exit ;
14005: GO 14086
// DialogueOn ;
14007: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
14011: LD_VAR 0 1
14015: PUSH
14016: LD_VAR 0 1
14020: ARRAY
14021: PPUSH
14022: LD_STRING DArtefTechnologyRu-RSci1-1
14024: PPUSH
14025: CALL_OW 88
// if IsOk ( Burlak ) then
14029: LD_EXP 52
14033: PPUSH
14034: CALL_OW 302
14038: IFFALSE 14052
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
14040: LD_EXP 52
14044: PPUSH
14045: LD_STRING DArtefTechnologyRu-Bur-1
14047: PPUSH
14048: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
14052: LD_VAR 0 1
14056: PUSH
14057: LD_VAR 0 1
14061: ARRAY
14062: PPUSH
14063: LD_STRING DArtefTechnologyRu-RSci1-2
14065: PPUSH
14066: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
14070: LD_EXP 19
14074: PPUSH
14075: LD_STRING DArtefTechnologyRu-JMM-1
14077: PPUSH
14078: CALL_OW 88
// DialogueOff ;
14082: CALL_OW 7
// end ;
14086: PPOPN 1
14088: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
14089: LD_INT 24
14091: PPUSH
14092: LD_INT 7
14094: PPUSH
14095: CALL_OW 321
14099: PUSH
14100: LD_INT 2
14102: EQUAL
14103: PUSH
14104: LD_INT 1
14106: PPUSH
14107: CALL_OW 255
14111: PUSH
14112: LD_INT 7
14114: EQUAL
14115: AND
14116: IFFALSE 14284
14118: GO 14120
14120: DISABLE
14121: LD_INT 0
14123: PPUSH
// begin if Denis then
14124: LD_EXP 25
14128: IFFALSE 14145
// speaker := [ Denis ] else
14130: LD_ADDR_VAR 0 1
14134: PUSH
14135: LD_EXP 25
14139: PUSH
14140: EMPTY
14141: LIST
14142: ST_TO_ADDR
14143: GO 14251
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14145: LD_ADDR_VAR 0 1
14149: PUSH
14150: LD_INT 22
14152: PUSH
14153: LD_INT 7
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: PUSH
14160: LD_INT 23
14162: PUSH
14163: LD_INT 1
14165: PUSH
14166: EMPTY
14167: LIST
14168: LIST
14169: PUSH
14170: LD_INT 25
14172: PUSH
14173: LD_INT 4
14175: PUSH
14176: EMPTY
14177: LIST
14178: LIST
14179: PUSH
14180: LD_INT 21
14182: PUSH
14183: LD_INT 1
14185: PUSH
14186: EMPTY
14187: LIST
14188: LIST
14189: PUSH
14190: LD_INT 26
14192: PUSH
14193: LD_INT 1
14195: PUSH
14196: EMPTY
14197: LIST
14198: LIST
14199: PUSH
14200: EMPTY
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: LIST
14206: PPUSH
14207: CALL_OW 69
14211: PUSH
14212: LD_EXP 20
14216: PUSH
14217: LD_EXP 19
14221: PUSH
14222: LD_EXP 52
14226: PUSH
14227: LD_EXP 40
14231: PUSH
14232: LD_EXP 50
14236: PUSH
14237: LD_EXP 49
14241: PUSH
14242: EMPTY
14243: LIST
14244: LIST
14245: LIST
14246: LIST
14247: LIST
14248: LIST
14249: DIFF
14250: ST_TO_ADDR
// if not speaker then
14251: LD_VAR 0 1
14255: NOT
14256: IFFALSE 14260
// exit ;
14258: GO 14284
// DialogueOn ;
14260: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
14264: LD_VAR 0 1
14268: PUSH
14269: LD_INT 1
14271: ARRAY
14272: PPUSH
14273: LD_STRING DArtefTechnologyArStart-Sci1-1
14275: PPUSH
14276: CALL_OW 88
// DialogueOff ;
14280: CALL_OW 7
// end ;
14284: PPOPN 1
14286: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
14287: LD_EXP 14
14291: IFFALSE 14572
14293: GO 14295
14295: DISABLE
14296: LD_INT 0
14298: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14299: LD_ADDR_VAR 0 1
14303: PUSH
14304: LD_INT 22
14306: PUSH
14307: LD_INT 7
14309: PUSH
14310: EMPTY
14311: LIST
14312: LIST
14313: PUSH
14314: LD_INT 23
14316: PUSH
14317: LD_INT 3
14319: PUSH
14320: EMPTY
14321: LIST
14322: LIST
14323: PUSH
14324: LD_INT 25
14326: PUSH
14327: LD_INT 4
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: LD_INT 21
14336: PUSH
14337: LD_INT 1
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: LD_INT 26
14346: PUSH
14347: LD_INT 1
14349: PUSH
14350: EMPTY
14351: LIST
14352: LIST
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: PPUSH
14361: CALL_OW 69
14365: PUSH
14366: LD_EXP 20
14370: PUSH
14371: LD_EXP 19
14375: PUSH
14376: LD_EXP 52
14380: PUSH
14381: LD_EXP 40
14385: PUSH
14386: LD_EXP 50
14390: PUSH
14391: LD_EXP 49
14395: PUSH
14396: EMPTY
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: DIFF
14404: ST_TO_ADDR
// if not speaker then
14405: LD_VAR 0 1
14409: NOT
14410: IFFALSE 14414
// exit ;
14412: GO 14572
// DialogueOn ;
14414: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14418: LD_VAR 0 1
14422: PUSH
14423: LD_INT 1
14425: ARRAY
14426: PPUSH
14427: LD_STRING DArtefTechnologyAr-RSci1-1
14429: PPUSH
14430: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14434: LD_EXP 19
14438: PPUSH
14439: LD_STRING DArtefTechnologyAr-JMM-1
14441: PPUSH
14442: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14446: LD_VAR 0 1
14450: PUSH
14451: LD_INT 1
14453: ARRAY
14454: PPUSH
14455: LD_STRING DArtefTechnologyAr-RSci1-2
14457: PPUSH
14458: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14462: LD_EXP 19
14466: PPUSH
14467: LD_STRING DArtefTechnologyAr-JMM-2
14469: PPUSH
14470: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14474: LD_VAR 0 1
14478: PUSH
14479: LD_INT 1
14481: ARRAY
14482: PPUSH
14483: LD_STRING DArtefTechnologyAr-RSci1-3
14485: PPUSH
14486: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14490: LD_EXP 19
14494: PPUSH
14495: LD_STRING DArtefTechnologyAr-JMM-3
14497: PPUSH
14498: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14502: LD_VAR 0 1
14506: PUSH
14507: LD_INT 1
14509: ARRAY
14510: PPUSH
14511: LD_STRING DArtefTechnologyAr-RSci1-4
14513: PPUSH
14514: CALL_OW 88
// if IsOk ( Burlak ) then
14518: LD_EXP 52
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14529: LD_EXP 52
14533: PPUSH
14534: LD_STRING DArtefTechnologyAr-Bur-4
14536: PPUSH
14537: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14541: LD_EXP 19
14545: PPUSH
14546: LD_STRING DArtefTechnologyAr-JMM-4
14548: PPUSH
14549: CALL_OW 88
// DialogueOff ;
14553: CALL_OW 7
// wait ( 0 0$45 ) ;
14557: LD_INT 1575
14559: PPUSH
14560: CALL_OW 67
// spawnOmar := true ;
14564: LD_ADDR_EXP 11
14568: PUSH
14569: LD_INT 1
14571: ST_TO_ADDR
// end ;
14572: PPOPN 1
14574: END
// every 0 0$1 trigger spawnOmar do
14575: LD_EXP 11
14579: IFFALSE 14959
14581: GO 14583
14583: DISABLE
// begin PrepareOmarAli ;
14584: CALL 7522 0 0
// if not HasTask ( Omar ) then
14588: LD_EXP 56
14592: PPUSH
14593: CALL_OW 314
14597: NOT
14598: IFFALSE 14615
// ComMoveXY ( Omar , 252 , 220 ) ;
14600: LD_EXP 56
14604: PPUSH
14605: LD_INT 252
14607: PPUSH
14608: LD_INT 220
14610: PPUSH
14611: CALL_OW 111
// if not Omar then
14615: LD_EXP 56
14619: NOT
14620: IFFALSE 14624
// exit ;
14622: GO 14959
// repeat wait ( 0 0$1 ) ;
14624: LD_INT 35
14626: PPUSH
14627: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14631: LD_EXP 56
14635: PPUSH
14636: CALL_OW 314
14640: NOT
14641: PUSH
14642: LD_EXP 56
14646: PPUSH
14647: LD_INT 252
14649: PPUSH
14650: LD_INT 220
14652: PPUSH
14653: CALL_OW 297
14657: PUSH
14658: LD_INT 6
14660: GREATER
14661: AND
14662: IFFALSE 14679
// ComMoveXY ( Omar , 252 , 220 ) ;
14664: LD_EXP 56
14668: PPUSH
14669: LD_INT 252
14671: PPUSH
14672: LD_INT 220
14674: PPUSH
14675: CALL_OW 111
// until See ( 7 , Omar ) ;
14679: LD_INT 7
14681: PPUSH
14682: LD_EXP 56
14686: PPUSH
14687: CALL_OW 292
14691: IFFALSE 14624
// CenterNowOnUnits ( Omar ) ;
14693: LD_EXP 56
14697: PPUSH
14698: CALL_OW 87
// DialogueOn ;
14702: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14706: LD_EXP 56
14710: PPUSH
14711: LD_STRING DOmar-Omar-1
14713: PPUSH
14714: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14718: LD_EXP 19
14722: PPUSH
14723: LD_STRING DOmar-JMM-1
14725: PPUSH
14726: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14730: LD_EXP 56
14734: PPUSH
14735: LD_STRING DOmar-Omar-2
14737: PPUSH
14738: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14742: LD_EXP 19
14746: PPUSH
14747: LD_STRING DOmar-JMM-2
14749: PPUSH
14750: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14754: LD_EXP 56
14758: PPUSH
14759: LD_STRING DOmar-Omar-3
14761: PPUSH
14762: CALL_OW 88
// if IsOk ( Burlak ) then
14766: LD_EXP 52
14770: PPUSH
14771: CALL_OW 302
14775: IFFALSE 14791
// Say ( Burlak , DOmar-Bur-3 ) else
14777: LD_EXP 52
14781: PPUSH
14782: LD_STRING DOmar-Bur-3
14784: PPUSH
14785: CALL_OW 88
14789: GO 14803
// Say ( JMM , DOmar-JMM-3 ) ;
14791: LD_EXP 19
14795: PPUSH
14796: LD_STRING DOmar-JMM-3
14798: PPUSH
14799: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14803: LD_EXP 56
14807: PPUSH
14808: LD_STRING DOmar-Omar-4
14810: PPUSH
14811: CALL_OW 88
// case Query ( QAccept ) of 1 :
14815: LD_STRING QAccept
14817: PPUSH
14818: CALL_OW 97
14822: PUSH
14823: LD_INT 1
14825: DOUBLE
14826: EQUAL
14827: IFTRUE 14831
14829: GO 14867
14831: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14832: LD_EXP 19
14836: PPUSH
14837: LD_STRING DQrAccept#1-JMM-1
14839: PPUSH
14840: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14844: LD_EXP 56
14848: PPUSH
14849: LD_INT 7
14851: PPUSH
14852: CALL_OW 235
// ComStop ( Omar ) ;
14856: LD_EXP 56
14860: PPUSH
14861: CALL_OW 141
// end ; 2 :
14865: GO 14916
14867: LD_INT 2
14869: DOUBLE
14870: EQUAL
14871: IFTRUE 14875
14873: GO 14915
14875: POP
// begin if IsOk ( Burlak ) then
14876: LD_EXP 52
14880: PPUSH
14881: CALL_OW 302
14885: IFFALSE 14901
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14887: LD_EXP 52
14891: PPUSH
14892: LD_STRING DQrAccept#2-Bur-1
14894: PPUSH
14895: CALL_OW 88
14899: GO 14913
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14901: LD_EXP 19
14905: PPUSH
14906: LD_STRING DQrAccept#2-JMM-1
14908: PPUSH
14909: CALL_OW 88
// end ; end ;
14913: GO 14916
14915: POP
// DialogueOff ;
14916: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14920: LD_EXP 56
14924: PPUSH
14925: CALL_OW 255
14929: PUSH
14930: LD_INT 7
14932: EQUAL
14933: IFFALSE 14944
// begin SetAchievement ( ACH_OMAR ) ;
14935: LD_STRING ACH_OMAR
14937: PPUSH
14938: CALL_OW 543
// exit ;
14942: GO 14959
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14944: LD_EXP 56
14948: PPUSH
14949: LD_INT 202
14951: PPUSH
14952: LD_INT 115
14954: PPUSH
14955: CALL_OW 111
// end ;
14959: END
// every 0 0$1 trigger IsOk ( Omar ) and russianDestroyed and GetSide ( Omar ) = 7 do var i ;
14960: LD_EXP 56
14964: PPUSH
14965: CALL_OW 302
14969: PUSH
14970: LD_EXP 2
14974: AND
14975: PUSH
14976: LD_EXP 56
14980: PPUSH
14981: CALL_OW 255
14985: PUSH
14986: LD_INT 7
14988: EQUAL
14989: AND
14990: IFFALSE 15482
14992: GO 14994
14994: DISABLE
14995: LD_INT 0
14997: PPUSH
// begin wait ( 0 0$2 ) ;
14998: LD_INT 70
15000: PPUSH
15001: CALL_OW 67
// SetSide ( Omar , 5 ) ;
15005: LD_EXP 56
15009: PPUSH
15010: LD_INT 5
15012: PPUSH
15013: CALL_OW 235
// if IsInUnit ( Omar ) then
15017: LD_EXP 56
15021: PPUSH
15022: CALL_OW 310
15026: IFFALSE 15037
// ComExitVehicle ( Omar ) ;
15028: LD_EXP 56
15032: PPUSH
15033: CALL_OW 121
// if IsInUnit ( Omar ) then
15037: LD_EXP 56
15041: PPUSH
15042: CALL_OW 310
15046: IFFALSE 15057
// ComExitBuilding ( Omar ) ;
15048: LD_EXP 56
15052: PPUSH
15053: CALL_OW 122
// wait ( 0 0$1 ) ;
15057: LD_INT 35
15059: PPUSH
15060: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15064: LD_EXP 56
15068: PPUSH
15069: LD_INT 203
15071: PPUSH
15072: LD_INT 120
15074: PPUSH
15075: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
15079: LD_INT 35
15081: PPUSH
15082: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
15086: LD_EXP 56
15090: PPUSH
15091: CALL_OW 306
15095: PUSH
15096: LD_EXP 56
15100: PPUSH
15101: LD_INT 203
15103: PPUSH
15104: LD_INT 120
15106: PPUSH
15107: CALL_OW 297
15111: PUSH
15112: LD_INT 20
15114: LESS
15115: OR
15116: IFFALSE 15079
// DialogueOn ;
15118: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
15122: LD_EXP 56
15126: PPUSH
15127: CALL_OW 250
15131: PPUSH
15132: LD_EXP 56
15136: PPUSH
15137: CALL_OW 251
15141: PPUSH
15142: LD_INT 7
15144: PPUSH
15145: LD_INT 6
15147: NEG
15148: PPUSH
15149: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
15153: LD_EXP 56
15157: PPUSH
15158: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
15162: LD_EXP 19
15166: PPUSH
15167: LD_STRING DOmarContam-JMM-1
15169: PPUSH
15170: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
15174: LD_EXP 56
15178: PPUSH
15179: LD_STRING DOmarContam-Omar-1
15181: PPUSH
15182: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
15186: LD_EXP 19
15190: PPUSH
15191: LD_STRING DOmarContam-JMM-2
15193: PPUSH
15194: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
15198: LD_EXP 56
15202: PPUSH
15203: CALL_OW 250
15207: PPUSH
15208: LD_EXP 56
15212: PPUSH
15213: CALL_OW 251
15217: PPUSH
15218: LD_INT 7
15220: PPUSH
15221: CALL_OW 331
// DialogueOff ;
15225: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
15229: LD_INT 5
15231: PPUSH
15232: LD_INT 7
15234: PPUSH
15235: LD_INT 2
15237: PPUSH
15238: LD_INT 1
15240: PPUSH
15241: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
15245: LD_INT 105
15247: PPUSH
15248: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15252: LD_EXP 56
15256: PPUSH
15257: LD_INT 203
15259: PPUSH
15260: LD_INT 120
15262: PPUSH
15263: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
15267: LD_EXP 56
15271: PPUSH
15272: LD_INT 203
15274: PPUSH
15275: LD_INT 120
15277: PPUSH
15278: CALL_OW 307
15282: IFFALSE 15245
// ComHold ( Omar ) ;
15284: LD_EXP 56
15288: PPUSH
15289: CALL_OW 140
// InGameOn ;
15293: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
15297: LD_INT 203
15299: PPUSH
15300: LD_INT 120
15302: PPUSH
15303: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
15307: LD_INT 203
15309: PPUSH
15310: LD_INT 120
15312: PPUSH
15313: LD_INT 7
15315: PPUSH
15316: LD_INT 30
15318: NEG
15319: PPUSH
15320: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
15324: LD_ADDR_VAR 0 1
15328: PUSH
15329: LD_INT 203
15331: PUSH
15332: LD_INT 120
15334: PUSH
15335: EMPTY
15336: LIST
15337: LIST
15338: PUSH
15339: LD_INT 202
15341: PUSH
15342: LD_INT 125
15344: PUSH
15345: EMPTY
15346: LIST
15347: LIST
15348: PUSH
15349: LD_INT 195
15351: PUSH
15352: LD_INT 117
15354: PUSH
15355: EMPTY
15356: LIST
15357: LIST
15358: PUSH
15359: LD_INT 216
15361: PUSH
15362: LD_INT 123
15364: PUSH
15365: EMPTY
15366: LIST
15367: LIST
15368: PUSH
15369: LD_INT 224
15371: PUSH
15372: LD_INT 131
15374: PUSH
15375: EMPTY
15376: LIST
15377: LIST
15378: PUSH
15379: LD_INT 212
15381: PUSH
15382: LD_INT 133
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: LIST
15393: LIST
15394: LIST
15395: LIST
15396: PUSH
15397: FOR_IN
15398: IFFALSE 15434
// begin wait ( 0 0$0.5 ) ;
15400: LD_INT 18
15402: PPUSH
15403: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15407: LD_VAR 0 1
15411: PUSH
15412: LD_INT 1
15414: ARRAY
15415: PPUSH
15416: LD_VAR 0 1
15420: PUSH
15421: LD_INT 2
15423: ARRAY
15424: PPUSH
15425: LD_INT 5
15427: PPUSH
15428: CALL_OW 495
// end ;
15432: GO 15397
15434: POP
15435: POP
// KillUnit ( Omar ) ;
15436: LD_EXP 56
15440: PPUSH
15441: CALL_OW 66
// wait ( 0 0$3 ) ;
15445: LD_INT 105
15447: PPUSH
15448: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15452: LD_EXP 19
15456: PPUSH
15457: LD_STRING D16b-JMM-1
15459: PPUSH
15460: CALL_OW 91
// wait ( 0 0$2 ) ;
15464: LD_INT 70
15466: PPUSH
15467: CALL_OW 67
// InGameOff ;
15471: CALL_OW 9
// YouLost ( MothContaminate ) ;
15475: LD_STRING MothContaminate
15477: PPUSH
15478: CALL_OW 104
// end ;
15482: PPOPN 1
15484: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15485: LD_EXP 4
15489: NOT
15490: PUSH
15491: LD_INT 22
15493: PUSH
15494: LD_INT 1
15496: PUSH
15497: EMPTY
15498: LIST
15499: LIST
15500: PUSH
15501: LD_INT 34
15503: PUSH
15504: LD_INT 8
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: PUSH
15511: EMPTY
15512: LIST
15513: LIST
15514: PPUSH
15515: CALL_OW 69
15519: AND
15520: IFFALSE 15639
15522: GO 15524
15524: DISABLE
// begin wait ( 0 0$10 ) ;
15525: LD_INT 350
15527: PPUSH
15528: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15532: LD_EXP 55
15536: PPUSH
15537: CALL_OW 302
15541: NOT
15542: PUSH
15543: LD_INT 22
15545: PUSH
15546: LD_INT 1
15548: PUSH
15549: EMPTY
15550: LIST
15551: LIST
15552: PUSH
15553: LD_INT 34
15555: PUSH
15556: LD_INT 8
15558: PUSH
15559: EMPTY
15560: LIST
15561: LIST
15562: PUSH
15563: EMPTY
15564: LIST
15565: LIST
15566: PPUSH
15567: CALL_OW 69
15571: NOT
15572: OR
15573: IFFALSE 15577
// exit ;
15575: GO 15639
// DialogueOn ;
15577: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15581: LD_EXP 55
15585: PPUSH
15586: LD_STRING DWinAmericans-Pow-1
15588: PPUSH
15589: CALL_OW 94
// if IsOk ( Burlak ) then
15593: LD_EXP 52
15597: PPUSH
15598: CALL_OW 302
15602: IFFALSE 15616
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15604: LD_EXP 52
15608: PPUSH
15609: LD_STRING DWinAmericans-Bur-1
15611: PPUSH
15612: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15616: LD_EXP 19
15620: PPUSH
15621: LD_STRING DWinAmericans-JMM-1
15623: PPUSH
15624: CALL_OW 88
// DialogueOff ;
15628: CALL_OW 7
// YouLost ( AmBomb ) ;
15632: LD_STRING AmBomb
15634: PPUSH
15635: CALL_OW 104
// end ;
15639: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15640: LD_EXP 2
15644: NOT
15645: PUSH
15646: LD_INT 22
15648: PUSH
15649: LD_INT 3
15651: PUSH
15652: EMPTY
15653: LIST
15654: LIST
15655: PUSH
15656: LD_INT 34
15658: PUSH
15659: LD_INT 48
15661: PUSH
15662: EMPTY
15663: LIST
15664: LIST
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: PPUSH
15670: CALL_OW 69
15674: AND
15675: IFFALSE 15794
15677: GO 15679
15679: DISABLE
// begin wait ( 0 0$10 ) ;
15680: LD_INT 350
15682: PPUSH
15683: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15687: LD_EXP 60
15691: PPUSH
15692: CALL_OW 302
15696: NOT
15697: PUSH
15698: LD_INT 22
15700: PUSH
15701: LD_INT 3
15703: PUSH
15704: EMPTY
15705: LIST
15706: LIST
15707: PUSH
15708: LD_INT 34
15710: PUSH
15711: LD_INT 48
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: PUSH
15718: EMPTY
15719: LIST
15720: LIST
15721: PPUSH
15722: CALL_OW 69
15726: NOT
15727: OR
15728: IFFALSE 15732
// exit ;
15730: GO 15794
// DialogueOn ;
15732: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15736: LD_EXP 60
15740: PPUSH
15741: LD_STRING DWinRussians-Pla-1
15743: PPUSH
15744: CALL_OW 94
// if IsOk ( Burlak ) then
15748: LD_EXP 52
15752: PPUSH
15753: CALL_OW 302
15757: IFFALSE 15771
// Say ( Burlak , DWinRussians-Bur-1 ) ;
15759: LD_EXP 52
15763: PPUSH
15764: LD_STRING DWinRussians-Bur-1
15766: PPUSH
15767: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
15771: LD_EXP 19
15775: PPUSH
15776: LD_STRING DWinRussians-JMM-1
15778: PPUSH
15779: CALL_OW 88
// DialogueOff ;
15783: CALL_OW 7
// YouLost ( RuBomb ) ;
15787: LD_STRING RuBomb
15789: PPUSH
15790: CALL_OW 104
// end ;
15794: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
15795: LD_INT 7
15797: PPUSH
15798: LD_INT 22
15800: PUSH
15801: LD_INT 7
15803: PUSH
15804: EMPTY
15805: LIST
15806: LIST
15807: PPUSH
15808: CALL_OW 70
15812: PUSH
15813: LD_EXP 4
15817: NOT
15818: AND
15819: IFFALSE 15848
15821: GO 15823
15823: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
15824: LD_EXP 55
15828: PPUSH
15829: LD_STRING DSurrenderAmericans-Pow-1
15831: PPUSH
15832: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
15836: LD_EXP 19
15840: PPUSH
15841: LD_STRING DSurrenderAmericans-JMM-1
15843: PPUSH
15844: CALL_OW 88
// end ;
15848: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
15849: LD_INT 2
15851: PPUSH
15852: LD_INT 22
15854: PUSH
15855: LD_INT 7
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PPUSH
15862: CALL_OW 70
15866: PUSH
15867: LD_EXP 2
15871: NOT
15872: AND
15873: PUSH
15874: LD_EXP 52
15878: AND
15879: IFFALSE 15908
15881: GO 15883
15883: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
15884: LD_EXP 60
15888: PPUSH
15889: LD_STRING DSurrenderRussians-Pla-1
15891: PPUSH
15892: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15896: LD_EXP 52
15900: PPUSH
15901: LD_STRING DSurrenderRussians-Bur-1
15903: PPUSH
15904: CALL_OW 88
// end ;
15908: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
15909: LD_EXP 4
15913: IFFALSE 16352
15915: GO 15917
15917: DISABLE
15918: LD_INT 0
15920: PPUSH
15921: PPUSH
15922: PPUSH
// begin MC_Kill ( 4 ) ;
15923: LD_INT 4
15925: PPUSH
15926: CALL 22807 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
15930: LD_INT 1
15932: PPUSH
15933: LD_INT 7
15935: PPUSH
15936: LD_INT 1
15938: PPUSH
15939: LD_INT 1
15941: PPUSH
15942: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
15946: LD_ADDR_VAR 0 3
15950: PUSH
15951: LD_INT 22
15953: PUSH
15954: LD_INT 1
15956: PUSH
15957: EMPTY
15958: LIST
15959: LIST
15960: PUSH
15961: LD_INT 50
15963: PUSH
15964: EMPTY
15965: LIST
15966: PUSH
15967: LD_INT 26
15969: PUSH
15970: LD_INT 1
15972: PUSH
15973: EMPTY
15974: LIST
15975: LIST
15976: PUSH
15977: LD_INT 23
15979: PUSH
15980: LD_INT 1
15982: PUSH
15983: EMPTY
15984: LIST
15985: LIST
15986: PUSH
15987: EMPTY
15988: LIST
15989: LIST
15990: LIST
15991: LIST
15992: PPUSH
15993: CALL_OW 69
15997: PUSH
15998: LD_EXP 55
16002: PUSH
16003: LD_EXP 27
16007: PUSH
16008: LD_EXP 24
16012: PUSH
16013: LD_EXP 23
16017: PUSH
16018: LD_EXP 30
16022: PUSH
16023: LD_EXP 28
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: LIST
16032: LIST
16033: LIST
16034: LIST
16035: DIFF
16036: ST_TO_ADDR
// if not speaker then
16037: LD_VAR 0 3
16041: NOT
16042: IFFALSE 16082
// begin uc_side := 1 ;
16044: LD_ADDR_OWVAR 20
16048: PUSH
16049: LD_INT 1
16051: ST_TO_ADDR
// uc_nation := 1 ;
16052: LD_ADDR_OWVAR 21
16056: PUSH
16057: LD_INT 1
16059: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16060: LD_INT 1
16062: PPUSH
16063: LD_INT 0
16065: PPUSH
16066: CALL_OW 381
// speaker := CreateHuman ;
16070: LD_ADDR_VAR 0 3
16074: PUSH
16075: CALL_OW 44
16079: ST_TO_ADDR
// end else
16080: GO 16096
// speaker := speaker [ 1 ] ;
16082: LD_ADDR_VAR 0 3
16086: PUSH
16087: LD_VAR 0 3
16091: PUSH
16092: LD_INT 1
16094: ARRAY
16095: ST_TO_ADDR
// DialogueOn ;
16096: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
16100: LD_VAR 0 3
16104: PPUSH
16105: LD_STRING DSurrenderAmericans-Sol1-1a
16107: PPUSH
16108: CALL_OW 94
// DialogueOff ;
16112: CALL_OW 7
// americanCapitulated := true ;
16116: LD_ADDR_EXP 6
16120: PUSH
16121: LD_INT 1
16123: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16124: LD_ADDR_VAR 0 2
16128: PUSH
16129: LD_INT 22
16131: PUSH
16132: LD_INT 1
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 21
16141: PUSH
16142: LD_INT 1
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: PPUSH
16153: CALL_OW 69
16157: PUSH
16158: LD_INT 22
16160: PUSH
16161: LD_INT 1
16163: PUSH
16164: EMPTY
16165: LIST
16166: LIST
16167: PUSH
16168: LD_INT 21
16170: PUSH
16171: LD_INT 2
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: PUSH
16178: LD_INT 1
16180: PUSH
16181: EMPTY
16182: LIST
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: LIST
16188: PPUSH
16189: CALL_OW 69
16193: ADD
16194: ST_TO_ADDR
// if tmp then
16195: LD_VAR 0 2
16199: IFFALSE 16352
// repeat wait ( 0 0$1 ) ;
16201: LD_INT 35
16203: PPUSH
16204: CALL_OW 67
// for i in tmp do
16208: LD_ADDR_VAR 0 1
16212: PUSH
16213: LD_VAR 0 2
16217: PUSH
16218: FOR_IN
16219: IFFALSE 16301
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16221: LD_VAR 0 1
16225: PPUSH
16226: CALL_OW 310
16230: PUSH
16231: LD_VAR 0 1
16235: PPUSH
16236: CALL_OW 310
16240: PPUSH
16241: CALL_OW 247
16245: PUSH
16246: LD_INT 3
16248: EQUAL
16249: AND
16250: IFFALSE 16261
// ComExitBuilding ( i ) ;
16252: LD_VAR 0 1
16256: PPUSH
16257: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
16261: LD_VAR 0 1
16265: PPUSH
16266: LD_INT 122
16268: PPUSH
16269: LD_INT 242
16271: PPUSH
16272: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
16276: LD_VAR 0 1
16280: PPUSH
16281: LD_INT 35
16283: PPUSH
16284: CALL_OW 308
16288: IFFALSE 16299
// RemoveUnit ( i ) ;
16290: LD_VAR 0 1
16294: PPUSH
16295: CALL_OW 64
// end ;
16299: GO 16218
16301: POP
16302: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16303: LD_INT 22
16305: PUSH
16306: LD_INT 1
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: PUSH
16313: LD_INT 2
16315: PUSH
16316: LD_INT 21
16318: PUSH
16319: LD_INT 1
16321: PUSH
16322: EMPTY
16323: LIST
16324: LIST
16325: PUSH
16326: LD_INT 33
16328: PUSH
16329: LD_INT 1
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: PUSH
16336: EMPTY
16337: LIST
16338: LIST
16339: LIST
16340: PUSH
16341: EMPTY
16342: LIST
16343: LIST
16344: PPUSH
16345: CALL_OW 69
16349: NOT
16350: IFFALSE 16201
// end ;
16352: PPOPN 3
16354: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
16355: LD_EXP 2
16359: IFFALSE 16808
16361: GO 16363
16363: DISABLE
16364: LD_INT 0
16366: PPUSH
16367: PPUSH
16368: PPUSH
// begin repeat wait ( 0 0$1 ) ;
16369: LD_INT 35
16371: PPUSH
16372: CALL_OW 67
// until IsDead ( Yakotich ) ;
16376: LD_EXP 61
16380: PPUSH
16381: CALL_OW 301
16385: IFFALSE 16369
// MC_Kill ( 2 ) ;
16387: LD_INT 2
16389: PPUSH
16390: CALL 22807 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16394: LD_INT 3
16396: PPUSH
16397: LD_INT 7
16399: PPUSH
16400: LD_INT 1
16402: PPUSH
16403: LD_INT 1
16405: PPUSH
16406: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16410: LD_ADDR_VAR 0 3
16414: PUSH
16415: LD_INT 22
16417: PUSH
16418: LD_INT 3
16420: PUSH
16421: EMPTY
16422: LIST
16423: LIST
16424: PUSH
16425: LD_INT 50
16427: PUSH
16428: EMPTY
16429: LIST
16430: PUSH
16431: LD_INT 26
16433: PUSH
16434: LD_INT 1
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: PUSH
16441: LD_INT 23
16443: PUSH
16444: LD_INT 3
16446: PUSH
16447: EMPTY
16448: LIST
16449: LIST
16450: PUSH
16451: EMPTY
16452: LIST
16453: LIST
16454: LIST
16455: LIST
16456: PPUSH
16457: CALL_OW 69
16461: PUSH
16462: LD_EXP 60
16466: DIFF
16467: ST_TO_ADDR
// if not speaker then
16468: LD_VAR 0 3
16472: NOT
16473: IFFALSE 16513
// begin uc_side := 3 ;
16475: LD_ADDR_OWVAR 20
16479: PUSH
16480: LD_INT 3
16482: ST_TO_ADDR
// uc_nation := 3 ;
16483: LD_ADDR_OWVAR 21
16487: PUSH
16488: LD_INT 3
16490: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16491: LD_INT 1
16493: PPUSH
16494: LD_INT 0
16496: PPUSH
16497: CALL_OW 381
// speaker := CreateHuman ;
16501: LD_ADDR_VAR 0 3
16505: PUSH
16506: CALL_OW 44
16510: ST_TO_ADDR
// end else
16511: GO 16527
// speaker := speaker [ 1 ] ;
16513: LD_ADDR_VAR 0 3
16517: PUSH
16518: LD_VAR 0 3
16522: PUSH
16523: LD_INT 1
16525: ARRAY
16526: ST_TO_ADDR
// DialogueOn ;
16527: CALL_OW 6
// if IsOK ( Burlak ) then
16531: LD_EXP 52
16535: PPUSH
16536: CALL_OW 302
16540: IFFALSE 16556
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16542: LD_VAR 0 3
16546: PPUSH
16547: LD_STRING DSurrenderRussians-RSol1-1
16549: PPUSH
16550: CALL_OW 94
16554: GO 16568
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16556: LD_VAR 0 3
16560: PPUSH
16561: LD_STRING DSurrenderRussians-RSol1-1a
16563: PPUSH
16564: CALL_OW 94
// DialogueOff ;
16568: CALL_OW 7
// russianCapitulated := true ;
16572: LD_ADDR_EXP 7
16576: PUSH
16577: LD_INT 1
16579: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16580: LD_ADDR_VAR 0 2
16584: PUSH
16585: LD_INT 22
16587: PUSH
16588: LD_INT 3
16590: PUSH
16591: EMPTY
16592: LIST
16593: LIST
16594: PUSH
16595: LD_INT 21
16597: PUSH
16598: LD_INT 1
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: PUSH
16605: EMPTY
16606: LIST
16607: LIST
16608: PPUSH
16609: CALL_OW 69
16613: PUSH
16614: LD_INT 22
16616: PUSH
16617: LD_INT 3
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: LD_INT 21
16626: PUSH
16627: LD_INT 2
16629: PUSH
16630: EMPTY
16631: LIST
16632: LIST
16633: PUSH
16634: LD_INT 1
16636: PUSH
16637: EMPTY
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL_OW 69
16649: ADD
16650: ST_TO_ADDR
// if tmp then
16651: LD_VAR 0 2
16655: IFFALSE 16808
// repeat wait ( 0 0$1 ) ;
16657: LD_INT 35
16659: PPUSH
16660: CALL_OW 67
// for i in tmp do
16664: LD_ADDR_VAR 0 1
16668: PUSH
16669: LD_VAR 0 2
16673: PUSH
16674: FOR_IN
16675: IFFALSE 16757
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16677: LD_VAR 0 1
16681: PPUSH
16682: CALL_OW 310
16686: PUSH
16687: LD_VAR 0 1
16691: PPUSH
16692: CALL_OW 310
16696: PPUSH
16697: CALL_OW 247
16701: PUSH
16702: LD_INT 3
16704: EQUAL
16705: AND
16706: IFFALSE 16717
// ComExitBuilding ( i ) ;
16708: LD_VAR 0 1
16712: PPUSH
16713: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16717: LD_VAR 0 1
16721: PPUSH
16722: LD_INT 154
16724: PPUSH
16725: LD_INT 1
16727: PPUSH
16728: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16732: LD_VAR 0 1
16736: PPUSH
16737: LD_INT 36
16739: PPUSH
16740: CALL_OW 308
16744: IFFALSE 16755
// RemoveUnit ( i ) ;
16746: LD_VAR 0 1
16750: PPUSH
16751: CALL_OW 64
// end ;
16755: GO 16674
16757: POP
16758: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16759: LD_INT 22
16761: PUSH
16762: LD_INT 3
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: PUSH
16769: LD_INT 2
16771: PUSH
16772: LD_INT 21
16774: PUSH
16775: LD_INT 1
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: PUSH
16782: LD_INT 33
16784: PUSH
16785: LD_INT 1
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: PUSH
16792: EMPTY
16793: LIST
16794: LIST
16795: LIST
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PPUSH
16801: CALL_OW 69
16805: NOT
16806: IFFALSE 16657
// end ;
16808: PPOPN 3
16810: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
16811: LD_INT 22
16813: PUSH
16814: LD_INT 8
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PUSH
16821: LD_INT 21
16823: PUSH
16824: LD_INT 1
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: PUSH
16831: LD_INT 23
16833: PUSH
16834: LD_INT 2
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: PUSH
16841: EMPTY
16842: LIST
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 69
16850: PUSH
16851: LD_INT 18
16853: LESS
16854: PUSH
16855: LD_EXP 58
16859: PPUSH
16860: CALL_OW 301
16864: OR
16865: PUSH
16866: LD_INT 324
16868: PPUSH
16869: CALL_OW 255
16873: PUSH
16874: LD_INT 7
16876: EQUAL
16877: OR
16878: IFFALSE 16891
16880: GO 16882
16882: DISABLE
// legionDestroyed := true ;
16883: LD_ADDR_EXP 3
16887: PUSH
16888: LD_INT 1
16890: ST_TO_ADDR
16891: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
16892: LD_INT 22
16894: PUSH
16895: LD_INT 2
16897: PUSH
16898: EMPTY
16899: LIST
16900: LIST
16901: PUSH
16902: LD_INT 21
16904: PUSH
16905: LD_INT 1
16907: PUSH
16908: EMPTY
16909: LIST
16910: LIST
16911: PUSH
16912: LD_INT 23
16914: PUSH
16915: LD_INT 2
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: LIST
16926: PPUSH
16927: CALL_OW 69
16931: PUSH
16932: LD_INT 9
16934: LESS
16935: PUSH
16936: LD_INT 503
16938: PPUSH
16939: CALL_OW 301
16943: OR
16944: PUSH
16945: LD_INT 503
16947: PPUSH
16948: CALL_OW 255
16952: PUSH
16953: LD_INT 7
16955: EQUAL
16956: OR
16957: IFFALSE 16970
16959: GO 16961
16961: DISABLE
// arabianDestroyed := true ;
16962: LD_ADDR_EXP 5
16966: PUSH
16967: LD_INT 1
16969: ST_TO_ADDR
16970: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
16971: LD_EXP 5
16975: IFFALSE 17219
16977: GO 16979
16979: DISABLE
16980: LD_INT 0
16982: PPUSH
16983: PPUSH
// begin MC_Kill ( 1 ) ;
16984: LD_INT 1
16986: PPUSH
16987: CALL 22807 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16991: LD_ADDR_VAR 0 2
16995: PUSH
16996: LD_INT 22
16998: PUSH
16999: LD_INT 2
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: PUSH
17006: LD_INT 21
17008: PUSH
17009: LD_INT 1
17011: PUSH
17012: EMPTY
17013: LIST
17014: LIST
17015: PUSH
17016: EMPTY
17017: LIST
17018: LIST
17019: PPUSH
17020: CALL_OW 69
17024: PUSH
17025: LD_INT 22
17027: PUSH
17028: LD_INT 2
17030: PUSH
17031: EMPTY
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 21
17037: PUSH
17038: LD_INT 2
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: PUSH
17045: LD_INT 1
17047: PUSH
17048: EMPTY
17049: LIST
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: LIST
17055: PPUSH
17056: CALL_OW 69
17060: ADD
17061: ST_TO_ADDR
// if tmp then
17062: LD_VAR 0 2
17066: IFFALSE 17219
// repeat wait ( 0 0$1 ) ;
17068: LD_INT 35
17070: PPUSH
17071: CALL_OW 67
// for i in tmp do
17075: LD_ADDR_VAR 0 1
17079: PUSH
17080: LD_VAR 0 2
17084: PUSH
17085: FOR_IN
17086: IFFALSE 17168
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17088: LD_VAR 0 1
17092: PPUSH
17093: CALL_OW 310
17097: PUSH
17098: LD_VAR 0 1
17102: PPUSH
17103: CALL_OW 310
17107: PPUSH
17108: CALL_OW 247
17112: PUSH
17113: LD_INT 3
17115: EQUAL
17116: AND
17117: IFFALSE 17128
// ComExitBuilding ( i ) ;
17119: LD_VAR 0 1
17123: PPUSH
17124: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
17128: LD_VAR 0 1
17132: PPUSH
17133: LD_INT 254
17135: PPUSH
17136: LD_INT 268
17138: PPUSH
17139: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
17143: LD_VAR 0 1
17147: PPUSH
17148: LD_INT 34
17150: PPUSH
17151: CALL_OW 308
17155: IFFALSE 17166
// RemoveUnit ( i ) ;
17157: LD_VAR 0 1
17161: PPUSH
17162: CALL_OW 64
// end ;
17166: GO 17085
17168: POP
17169: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17170: LD_INT 22
17172: PUSH
17173: LD_INT 2
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: PUSH
17180: LD_INT 2
17182: PUSH
17183: LD_INT 21
17185: PUSH
17186: LD_INT 1
17188: PUSH
17189: EMPTY
17190: LIST
17191: LIST
17192: PUSH
17193: LD_INT 33
17195: PUSH
17196: LD_INT 1
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: EMPTY
17204: LIST
17205: LIST
17206: LIST
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: PPUSH
17212: CALL_OW 69
17216: NOT
17217: IFFALSE 17068
// end ;
17219: PPOPN 2
17221: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
17222: LD_EXP 3
17226: IFFALSE 17578
17228: GO 17230
17230: DISABLE
17231: LD_INT 0
17233: PPUSH
17234: PPUSH
// begin MC_Kill ( 3 ) ;
17235: LD_INT 3
17237: PPUSH
17238: CALL 22807 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
17242: LD_INT 8
17244: PPUSH
17245: LD_INT 7
17247: PPUSH
17248: LD_INT 1
17250: PPUSH
17251: LD_INT 1
17253: PPUSH
17254: CALL_OW 80
// DialogueOn ;
17258: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
17262: LD_EXP 57
17266: PPUSH
17267: LD_STRING D15-Szulc-1
17269: PPUSH
17270: CALL_OW 94
// DialogueOff ;
17274: CALL_OW 7
// legionCapitulated := true ;
17278: LD_ADDR_EXP 8
17282: PUSH
17283: LD_INT 1
17285: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
17286: LD_ADDR_VAR 0 1
17290: PUSH
17291: LD_INT 22
17293: PUSH
17294: LD_INT 8
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 21
17303: PUSH
17304: LD_INT 3
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PUSH
17311: LD_INT 23
17313: PUSH
17314: LD_INT 3
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: PUSH
17321: EMPTY
17322: LIST
17323: LIST
17324: LIST
17325: PPUSH
17326: CALL_OW 69
17330: PUSH
17331: FOR_IN
17332: IFFALSE 17348
// SetLives ( i , 3 ) ;
17334: LD_VAR 0 1
17338: PPUSH
17339: LD_INT 3
17341: PPUSH
17342: CALL_OW 234
17346: GO 17331
17348: POP
17349: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17350: LD_ADDR_VAR 0 2
17354: PUSH
17355: LD_INT 22
17357: PUSH
17358: LD_INT 8
17360: PUSH
17361: EMPTY
17362: LIST
17363: LIST
17364: PUSH
17365: LD_INT 21
17367: PUSH
17368: LD_INT 1
17370: PUSH
17371: EMPTY
17372: LIST
17373: LIST
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: PPUSH
17379: CALL_OW 69
17383: PUSH
17384: LD_INT 22
17386: PUSH
17387: LD_INT 8
17389: PUSH
17390: EMPTY
17391: LIST
17392: LIST
17393: PUSH
17394: LD_INT 21
17396: PUSH
17397: LD_INT 2
17399: PUSH
17400: EMPTY
17401: LIST
17402: LIST
17403: PUSH
17404: LD_INT 1
17406: PUSH
17407: EMPTY
17408: LIST
17409: PUSH
17410: EMPTY
17411: LIST
17412: LIST
17413: LIST
17414: PPUSH
17415: CALL_OW 69
17419: ADD
17420: ST_TO_ADDR
// if tmp then
17421: LD_VAR 0 2
17425: IFFALSE 17578
// repeat wait ( 0 0$1 ) ;
17427: LD_INT 35
17429: PPUSH
17430: CALL_OW 67
// for i in tmp do
17434: LD_ADDR_VAR 0 1
17438: PUSH
17439: LD_VAR 0 2
17443: PUSH
17444: FOR_IN
17445: IFFALSE 17527
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17447: LD_VAR 0 1
17451: PPUSH
17452: CALL_OW 310
17456: PUSH
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 310
17466: PPUSH
17467: CALL_OW 247
17471: PUSH
17472: LD_INT 3
17474: EQUAL
17475: AND
17476: IFFALSE 17487
// ComExitBuilding ( i ) ;
17478: LD_VAR 0 1
17482: PPUSH
17483: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17487: LD_VAR 0 1
17491: PPUSH
17492: LD_INT 10
17494: PPUSH
17495: LD_INT 1
17497: PPUSH
17498: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17502: LD_VAR 0 1
17506: PPUSH
17507: LD_INT 32
17509: PPUSH
17510: CALL_OW 308
17514: IFFALSE 17525
// RemoveUnit ( i ) ;
17516: LD_VAR 0 1
17520: PPUSH
17521: CALL_OW 64
// end ;
17525: GO 17444
17527: POP
17528: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17529: LD_INT 22
17531: PUSH
17532: LD_INT 8
17534: PUSH
17535: EMPTY
17536: LIST
17537: LIST
17538: PUSH
17539: LD_INT 2
17541: PUSH
17542: LD_INT 21
17544: PUSH
17545: LD_INT 1
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: PUSH
17552: LD_INT 33
17554: PUSH
17555: LD_INT 1
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: LIST
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: PPUSH
17571: CALL_OW 69
17575: NOT
17576: IFFALSE 17427
// end ;
17578: PPOPN 2
17580: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17581: LD_EXP 5
17585: NOT
17586: PUSH
17587: LD_OWVAR 1
17591: PUSH
17592: LD_INT 63000
17594: GREATEREQUAL
17595: AND
17596: PUSH
17597: LD_OWVAR 67
17601: PUSH
17602: LD_INT 3
17604: LESS
17605: AND
17606: IFFALSE 17615
17608: GO 17610
17610: DISABLE
// AllianceSupport ;
17611: CALL 4687 0 0
17615: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17616: LD_EXP 4
17620: PUSH
17621: LD_EXP 2
17625: AND
17626: PUSH
17627: LD_EXP 3
17631: AND
17632: PUSH
17633: LD_EXP 5
17637: AND
17638: PUSH
17639: LD_EXP 6
17643: AND
17644: PUSH
17645: LD_EXP 7
17649: AND
17650: PUSH
17651: LD_EXP 8
17655: AND
17656: PUSH
17657: LD_EXP 56
17661: PPUSH
17662: CALL_OW 255
17666: PUSH
17667: LD_INT 5
17669: NONEQUAL
17670: PUSH
17671: LD_EXP 56
17675: PPUSH
17676: CALL_OW 301
17680: OR
17681: PUSH
17682: LD_EXP 56
17686: PPUSH
17687: CALL_OW 305
17691: NOT
17692: OR
17693: AND
17694: IFFALSE 19213
17696: GO 17698
17698: DISABLE
17699: LD_INT 0
17701: PPUSH
17702: PPUSH
// begin wait ( 0 0$5 ) ;
17703: LD_INT 175
17705: PPUSH
17706: CALL_OW 67
// music_class := 5 ;
17710: LD_ADDR_OWVAR 72
17714: PUSH
17715: LD_INT 5
17717: ST_TO_ADDR
// music_nat := 5 ;
17718: LD_ADDR_OWVAR 71
17722: PUSH
17723: LD_INT 5
17725: ST_TO_ADDR
// if vehicleLostCounter < 3 then
17726: LD_EXP 15
17730: PUSH
17731: LD_INT 3
17733: LESS
17734: IFFALSE 17743
// SetAchievement ( ACH_ECONOMY ) ;
17736: LD_STRING ACH_ECONOMY
17738: PPUSH
17739: CALL_OW 543
// if tick < 60 60$00 then
17743: LD_OWVAR 1
17747: PUSH
17748: LD_INT 126000
17750: LESS
17751: IFFALSE 17767
// begin wait ( 3 ) ;
17753: LD_INT 3
17755: PPUSH
17756: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
17760: LD_STRING ACH_ASPEED_19
17762: PPUSH
17763: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
17767: LD_EXP 19
17771: PPUSH
17772: CALL_OW 87
// InGameOn ;
17776: CALL_OW 8
// DialogueOn ;
17780: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
17784: LD_EXP 19
17788: PPUSH
17789: LD_STRING DEnd-JMM-JMM-1
17791: PPUSH
17792: CALL_OW 88
// if Joan then
17796: LD_EXP 34
17800: IFFALSE 17816
// Say ( Joan , DEnd-JMM-Joan-1 ) else
17802: LD_EXP 34
17806: PPUSH
17807: LD_STRING DEnd-JMM-Joan-1
17809: PPUSH
17810: CALL_OW 88
17814: GO 17860
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
17816: LD_EXP 21
17820: PUSH
17821: LD_EXP 21
17825: PPUSH
17826: CALL_OW 255
17830: PUSH
17831: LD_INT 7
17833: EQUAL
17834: AND
17835: PUSH
17836: LD_EXP 21
17840: PPUSH
17841: CALL_OW 305
17845: AND
17846: IFFALSE 17860
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17848: LD_EXP 21
17852: PPUSH
17853: LD_STRING DEnd-JMM-Lisa-1
17855: PPUSH
17856: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
17860: LD_EXP 31
17864: PUSH
17865: LD_EXP 31
17869: PPUSH
17870: CALL_OW 305
17874: AND
17875: IFFALSE 17889
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17877: LD_EXP 31
17881: PPUSH
17882: LD_STRING DEnd-JMM-Frank-1
17884: PPUSH
17885: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
17889: LD_EXP 24
17893: PUSH
17894: LD_EXP 24
17898: PPUSH
17899: CALL_OW 255
17903: PUSH
17904: LD_INT 7
17906: EQUAL
17907: AND
17908: PUSH
17909: LD_EXP 24
17913: PPUSH
17914: CALL_OW 305
17918: AND
17919: IFFALSE 17933
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17921: LD_EXP 24
17925: PPUSH
17926: LD_STRING DEnd-JMM-Cyrus-1
17928: PPUSH
17929: CALL_OW 88
// if Burlak then
17933: LD_EXP 52
17937: IFFALSE 17951
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17939: LD_EXP 52
17943: PPUSH
17944: LD_STRING DEnd-JMM-Bur-1
17946: PPUSH
17947: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
17951: LD_EXP 34
17955: PUSH
17956: LD_EXP 21
17960: AND
17961: PUSH
17962: LD_EXP 21
17966: PPUSH
17967: CALL_OW 255
17971: PUSH
17972: LD_INT 7
17974: EQUAL
17975: AND
17976: PUSH
17977: LD_EXP 21
17981: PPUSH
17982: CALL_OW 305
17986: AND
17987: PUSH
17988: LD_EXP 52
17992: PPUSH
17993: CALL_OW 302
17997: AND
17998: IFFALSE 18012
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
18000: LD_EXP 21
18004: PPUSH
18005: LD_STRING DEnd-Burlak-Lisa-1
18007: PPUSH
18008: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
18012: LD_EXP 53
18016: PUSH
18017: LD_EXP 53
18021: PPUSH
18022: CALL_OW 305
18026: AND
18027: IFFALSE 18041
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
18029: LD_EXP 53
18033: PPUSH
18034: LD_STRING DEnd-JMM-Bel-1
18036: PPUSH
18037: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
18041: LD_EXP 54
18045: PUSH
18046: LD_EXP 54
18050: PPUSH
18051: CALL_OW 305
18055: AND
18056: IFFALSE 18070
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
18058: LD_EXP 54
18062: PPUSH
18063: LD_STRING DEnd-JMM-Gny-1
18065: PPUSH
18066: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
18070: LD_EXP 29
18074: PUSH
18075: LD_EXP 29
18079: PPUSH
18080: CALL_OW 255
18084: PUSH
18085: LD_INT 7
18087: EQUAL
18088: AND
18089: PUSH
18090: LD_EXP 29
18094: PPUSH
18095: CALL_OW 305
18099: AND
18100: IFFALSE 18114
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
18102: LD_EXP 29
18106: PPUSH
18107: LD_STRING DEnd-JMM-Corn-1
18109: PPUSH
18110: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
18114: LD_EXP 22
18118: PUSH
18119: LD_EXP 22
18123: PPUSH
18124: CALL_OW 255
18128: PUSH
18129: LD_INT 7
18131: EQUAL
18132: AND
18133: PUSH
18134: LD_EXP 22
18138: PPUSH
18139: CALL_OW 305
18143: AND
18144: IFFALSE 18158
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
18146: LD_EXP 22
18150: PPUSH
18151: LD_STRING DEnd-JMM-Don-1
18153: PPUSH
18154: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
18158: LD_EXP 23
18162: PUSH
18163: LD_EXP 23
18167: PPUSH
18168: CALL_OW 255
18172: PUSH
18173: LD_INT 7
18175: EQUAL
18176: AND
18177: PUSH
18178: LD_EXP 23
18182: PPUSH
18183: CALL_OW 305
18187: AND
18188: IFFALSE 18202
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
18190: LD_EXP 23
18194: PPUSH
18195: LD_STRING DEnd-JMM-Bobby-1
18197: PPUSH
18198: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
18202: LD_EXP 25
18206: PUSH
18207: LD_EXP 25
18211: PPUSH
18212: CALL_OW 255
18216: PUSH
18217: LD_INT 7
18219: EQUAL
18220: AND
18221: PUSH
18222: LD_EXP 25
18226: PPUSH
18227: CALL_OW 305
18231: AND
18232: IFFALSE 18246
// Say ( Denis , DEnd-JMM-Den-1 ) ;
18234: LD_EXP 25
18238: PPUSH
18239: LD_STRING DEnd-JMM-Den-1
18241: PPUSH
18242: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
18246: LD_EXP 27
18250: PUSH
18251: LD_EXP 27
18255: PPUSH
18256: CALL_OW 255
18260: PUSH
18261: LD_INT 7
18263: EQUAL
18264: AND
18265: PUSH
18266: LD_EXP 27
18270: PPUSH
18271: CALL_OW 305
18275: AND
18276: IFFALSE 18290
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
18278: LD_EXP 27
18282: PPUSH
18283: LD_STRING DEnd-JMM-Glad-1
18285: PPUSH
18286: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18290: LD_EXP 32
18294: PUSH
18295: LD_EXP 32
18299: PPUSH
18300: CALL_OW 255
18304: PUSH
18305: LD_INT 7
18307: EQUAL
18308: AND
18309: PUSH
18310: LD_EXP 32
18314: PPUSH
18315: CALL_OW 305
18319: AND
18320: IFFALSE 18334
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18322: LD_EXP 32
18326: PPUSH
18327: LD_STRING DEnd-JMM-Yam-1
18329: PPUSH
18330: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
18334: LD_EXP 26
18338: PUSH
18339: LD_EXP 26
18343: PPUSH
18344: CALL_OW 255
18348: PUSH
18349: LD_INT 7
18351: EQUAL
18352: AND
18353: PUSH
18354: LD_EXP 26
18358: PPUSH
18359: CALL_OW 305
18363: AND
18364: IFFALSE 18378
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
18366: LD_EXP 26
18370: PPUSH
18371: LD_STRING DEnd-JMM-Brown-1
18373: PPUSH
18374: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
18378: LD_EXP 36
18382: PUSH
18383: LD_EXP 36
18387: PPUSH
18388: CALL_OW 255
18392: PUSH
18393: LD_INT 7
18395: EQUAL
18396: AND
18397: PUSH
18398: LD_EXP 36
18402: PPUSH
18403: CALL_OW 305
18407: AND
18408: IFFALSE 18422
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18410: LD_EXP 36
18414: PPUSH
18415: LD_STRING DEnd-JMM-Con-1
18417: PPUSH
18418: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
18422: LD_EXP 30
18426: PUSH
18427: LD_EXP 30
18431: PPUSH
18432: CALL_OW 255
18436: PUSH
18437: LD_INT 7
18439: EQUAL
18440: AND
18441: PUSH
18442: LD_EXP 30
18446: PPUSH
18447: CALL_OW 305
18451: AND
18452: IFFALSE 18466
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18454: LD_EXP 30
18458: PPUSH
18459: LD_STRING DEnd-JMM-Gary-1
18461: PPUSH
18462: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18466: LD_EXP 20
18470: PUSH
18471: LD_EXP 20
18475: PPUSH
18476: CALL_OW 305
18480: AND
18481: IFFALSE 18495
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18483: LD_EXP 20
18487: PPUSH
18488: LD_STRING DEnd-JMM-Roth-1
18490: PPUSH
18491: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18495: LD_EXP 33
18499: PUSH
18500: LD_EXP 20
18504: AND
18505: PUSH
18506: LD_EXP 33
18510: PPUSH
18511: CALL_OW 305
18515: AND
18516: IFFALSE 18530
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18518: LD_EXP 33
18522: PPUSH
18523: LD_STRING DEnd-JMM-Sim-1
18525: PPUSH
18526: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18530: LD_EXP 28
18534: PUSH
18535: LD_EXP 28
18539: PPUSH
18540: CALL_OW 255
18544: PUSH
18545: LD_INT 7
18547: EQUAL
18548: AND
18549: PUSH
18550: LD_EXP 28
18554: PPUSH
18555: CALL_OW 305
18559: AND
18560: IFFALSE 18574
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18562: LD_EXP 28
18566: PPUSH
18567: LD_STRING DEnd-JMM-VanH-1
18569: PPUSH
18570: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18574: LD_EXP 42
18578: PUSH
18579: LD_EXP 42
18583: PPUSH
18584: CALL_OW 305
18588: AND
18589: IFFALSE 18603
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18591: LD_EXP 42
18595: PPUSH
18596: LD_STRING DEnd-JMM-Dol-1
18598: PPUSH
18599: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18603: LD_EXP 32
18607: PUSH
18608: LD_EXP 32
18612: PPUSH
18613: CALL_OW 255
18617: PUSH
18618: LD_INT 7
18620: EQUAL
18621: AND
18622: PUSH
18623: LD_EXP 32
18627: PPUSH
18628: CALL_OW 305
18632: AND
18633: IFFALSE 18647
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18635: LD_EXP 32
18639: PPUSH
18640: LD_STRING DEnd-JMM-Yam-1
18642: PPUSH
18643: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18647: LD_EXP 46
18651: PUSH
18652: LD_EXP 46
18656: PPUSH
18657: CALL_OW 305
18661: AND
18662: IFFALSE 18676
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18664: LD_EXP 46
18668: PPUSH
18669: LD_STRING DEnd-JMM-Kap-1
18671: PPUSH
18672: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18676: LD_EXP 49
18680: PUSH
18681: LD_EXP 49
18685: PPUSH
18686: CALL_OW 305
18690: AND
18691: IFFALSE 18705
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18693: LD_EXP 49
18697: PPUSH
18698: LD_STRING DEnd-JMM-Kov-1
18700: PPUSH
18701: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
18705: LD_EXP 44
18709: PUSH
18710: LD_EXP 44
18714: PPUSH
18715: CALL_OW 305
18719: AND
18720: IFFALSE 18734
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18722: LD_EXP 44
18726: PPUSH
18727: LD_STRING DEnd-JMM-Sch-1
18729: PPUSH
18730: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
18734: LD_EXP 40
18738: PUSH
18739: LD_EXP 40
18743: PPUSH
18744: CALL_OW 305
18748: AND
18749: PUSH
18750: LD_EXP 52
18754: PPUSH
18755: CALL_OW 302
18759: AND
18760: IFFALSE 18774
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18762: LD_EXP 40
18766: PPUSH
18767: LD_STRING DEnd-JMM-Tit-1
18769: PPUSH
18770: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
18774: LD_EXP 45
18778: PUSH
18779: LD_EXP 45
18783: PPUSH
18784: CALL_OW 305
18788: AND
18789: IFFALSE 18803
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18791: LD_EXP 45
18795: PPUSH
18796: LD_STRING DEnd-JMM-Obl-1
18798: PPUSH
18799: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
18803: LD_EXP 47
18807: PUSH
18808: LD_EXP 47
18812: PPUSH
18813: CALL_OW 305
18817: AND
18818: IFFALSE 18832
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18820: LD_EXP 47
18824: PPUSH
18825: LD_STRING DEnd-JMM-Lip-1
18827: PPUSH
18828: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
18832: LD_EXP 41
18836: PUSH
18837: LD_EXP 41
18841: PPUSH
18842: CALL_OW 305
18846: AND
18847: PUSH
18848: LD_EXP 52
18852: PPUSH
18853: CALL_OW 302
18857: AND
18858: IFFALSE 18872
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
18860: LD_EXP 41
18864: PPUSH
18865: LD_STRING DEnd-Burlak-Fad-1
18867: PPUSH
18868: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
18872: LD_EXP 48
18876: PUSH
18877: LD_EXP 48
18881: PPUSH
18882: CALL_OW 305
18886: AND
18887: IFFALSE 18901
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
18889: LD_EXP 48
18893: PPUSH
18894: LD_STRING DEnd-Burlak-Ptr-1
18896: PPUSH
18897: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
18901: LD_EXP 50
18905: PUSH
18906: LD_EXP 50
18910: PPUSH
18911: CALL_OW 305
18915: AND
18916: IFFALSE 18930
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
18918: LD_EXP 50
18922: PPUSH
18923: LD_STRING DEnd-Burlak-Kuz-1
18925: PPUSH
18926: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
18930: LD_EXP 39
18934: PUSH
18935: LD_EXP 39
18939: PPUSH
18940: CALL_OW 305
18944: AND
18945: PUSH
18946: LD_EXP 52
18950: PPUSH
18951: CALL_OW 302
18955: AND
18956: IFFALSE 18970
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
18958: LD_EXP 39
18962: PPUSH
18963: LD_STRING DEnd-Burlak-Kir-1
18965: PPUSH
18966: CALL_OW 88
// if Joan then
18970: LD_EXP 34
18974: IFFALSE 18988
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
18976: LD_EXP 34
18980: PPUSH
18981: LD_STRING DEnd-Burlak-Joan-1
18983: PPUSH
18984: CALL_OW 88
// if IsOk ( Burlak ) then
18988: LD_EXP 52
18992: PPUSH
18993: CALL_OW 302
18997: IFFALSE 19011
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
18999: LD_EXP 19
19003: PPUSH
19004: LD_STRING DEnd-Burlak-JMM-1
19006: PPUSH
19007: CALL_OW 88
// dwait ( 0 0$2 ) ;
19011: LD_INT 70
19013: PPUSH
19014: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
19018: LD_EXP 57
19022: PPUSH
19023: LD_STRING DEnd-Szulc
19025: PPUSH
19026: CALL_OW 94
// dwait ( 0 0$1 ) ;
19030: LD_INT 35
19032: PPUSH
19033: CALL_OW 68
// if IsLive ( Burlak ) then
19037: LD_EXP 52
19041: PPUSH
19042: CALL_OW 300
19046: IFFALSE 19058
// med1 := 1 else
19048: LD_ADDR_VAR 0 1
19052: PUSH
19053: LD_INT 1
19055: ST_TO_ADDR
19056: GO 19067
// med1 := - 1 ;
19058: LD_ADDR_VAR 0 1
19062: PUSH
19063: LD_INT 1
19065: NEG
19066: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
19067: LD_EXP 12
19071: PUSH
19072: LD_EXP 13
19076: AND
19077: PUSH
19078: LD_EXP 14
19082: AND
19083: IFFALSE 19095
// med2 := 1 else
19085: LD_ADDR_VAR 0 2
19089: PUSH
19090: LD_INT 1
19092: ST_TO_ADDR
19093: GO 19104
// med2 := - 1 ;
19095: LD_ADDR_VAR 0 2
19099: PUSH
19100: LD_INT 1
19102: NEG
19103: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
19104: LD_STRING Hero
19106: PPUSH
19107: LD_INT 1
19109: PPUSH
19110: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
19114: LD_STRING Artefact
19116: PPUSH
19117: LD_VAR 0 2
19121: PPUSH
19122: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
19126: LD_STRING ReconcileBurlak
19128: PPUSH
19129: LD_VAR 0 1
19133: PPUSH
19134: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
19138: LD_OWVAR 67
19142: PUSH
19143: LD_INT 3
19145: GREATEREQUAL
19146: PUSH
19147: LD_VAR 0 1
19151: PUSH
19152: LD_INT 1
19154: EQUAL
19155: AND
19156: PUSH
19157: LD_VAR 0 2
19161: PUSH
19162: LD_INT 1
19164: EQUAL
19165: AND
19166: IFFALSE 19178
// SetAchievementEX ( ACH_AMER , 19 ) ;
19168: LD_STRING ACH_AMER
19170: PPUSH
19171: LD_INT 19
19173: PPUSH
19174: CALL_OW 564
// GiveMedals ( MAIN ) ;
19178: LD_STRING MAIN
19180: PPUSH
19181: CALL_OW 102
// InGameOff ;
19185: CALL_OW 9
// DialogueOff ;
19189: CALL_OW 7
// music_nat := 1 ;
19193: LD_ADDR_OWVAR 71
19197: PUSH
19198: LD_INT 1
19200: ST_TO_ADDR
// music_class := 4 ;
19201: LD_ADDR_OWVAR 72
19205: PUSH
19206: LD_INT 4
19208: ST_TO_ADDR
// YouWin ;
19209: CALL_OW 103
// end ; end_of_file
19213: PPOPN 2
19215: END
// export function InitNature ; begin
19216: LD_INT 0
19218: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
19219: LD_INT 3
19221: PPUSH
19222: LD_INT 3
19224: PPUSH
19225: LD_INT 2
19227: PPUSH
19228: LD_INT 1
19230: PPUSH
19231: LD_INT 1
19233: PPUSH
19234: LD_INT 0
19236: PPUSH
19237: LD_INT 0
19239: PPUSH
19240: LD_INT 17
19242: PPUSH
19243: LD_INT 0
19245: PPUSH
19246: CALL 87637 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
19250: LD_INT 2
19252: PPUSH
19253: LD_INT 1
19255: PPUSH
19256: LD_INT 1
19258: PPUSH
19259: LD_INT 1
19261: PPUSH
19262: LD_INT 1
19264: PPUSH
19265: LD_INT 0
19267: PPUSH
19268: LD_INT 0
19270: PPUSH
19271: LD_INT 18
19273: PPUSH
19274: LD_INT 0
19276: PPUSH
19277: CALL 87637 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
19281: LD_INT 4
19283: PPUSH
19284: LD_INT 1
19286: PPUSH
19287: LD_INT 2
19289: PPUSH
19290: LD_INT 4
19292: PPUSH
19293: LD_INT 2
19295: PPUSH
19296: LD_INT 1
19298: PPUSH
19299: LD_INT 0
19301: PPUSH
19302: LD_INT 19
19304: PPUSH
19305: LD_INT 0
19307: PPUSH
19308: CALL 87637 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
19312: LD_INT 0
19314: PPUSH
19315: LD_INT 0
19317: PPUSH
19318: LD_INT 0
19320: PPUSH
19321: LD_INT 0
19323: PPUSH
19324: LD_INT 0
19326: PPUSH
19327: LD_INT 0
19329: PPUSH
19330: LD_INT 9
19332: PPUSH
19333: LD_INT 0
19335: PPUSH
19336: LD_INT 20
19338: PPUSH
19339: CALL 87637 0 9
// end ; end_of_file
19343: LD_VAR 0 1
19347: RET
// every 0 0$30 do var time ;
19348: GO 19350
19350: DISABLE
19351: LD_INT 0
19353: PPUSH
// begin time := 0 0$30 ;
19354: LD_ADDR_VAR 0 1
19358: PUSH
19359: LD_INT 1050
19361: ST_TO_ADDR
// repeat wait ( time ) ;
19362: LD_VAR 0 1
19366: PPUSH
19367: CALL_OW 67
// if Prob ( 50 ) then
19371: LD_INT 50
19373: PPUSH
19374: CALL_OW 13
19378: IFFALSE 19407
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
19380: LD_INT 1
19382: PPUSH
19383: LD_INT 5
19385: PPUSH
19386: CALL_OW 12
19390: PPUSH
19391: LD_INT 106
19393: PPUSH
19394: LD_INT 89
19396: PPUSH
19397: LD_INT 45
19399: PPUSH
19400: LD_INT 1
19402: PPUSH
19403: CALL_OW 56
// time := time + 0 0$3 ;
19407: LD_ADDR_VAR 0 1
19411: PUSH
19412: LD_VAR 0 1
19416: PUSH
19417: LD_INT 105
19419: PLUS
19420: ST_TO_ADDR
// if Prob ( 30 ) then
19421: LD_INT 30
19423: PPUSH
19424: CALL_OW 13
19428: IFFALSE 19474
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
19430: LD_INT 525
19432: PPUSH
19433: LD_INT 735
19435: PPUSH
19436: CALL_OW 12
19440: PPUSH
19441: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19445: LD_INT 1
19447: PPUSH
19448: LD_INT 5
19450: PPUSH
19451: CALL_OW 12
19455: PPUSH
19456: LD_INT 21
19458: PPUSH
19459: LD_INT 26
19461: PPUSH
19462: LD_INT 12
19464: PPUSH
19465: LD_INT 1
19467: PPUSH
19468: CALL_OW 56
// end else
19472: GO 19510
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19474: LD_INT 700
19476: PPUSH
19477: LD_INT 1225
19479: PPUSH
19480: CALL_OW 12
19484: PPUSH
19485: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19489: LD_INT 1
19491: PPUSH
19492: LD_INT 5
19494: PPUSH
19495: CALL_OW 12
19499: PPUSH
19500: LD_INT 14
19502: PPUSH
19503: LD_INT 1
19505: PPUSH
19506: CALL_OW 55
// end ; if Prob ( 50 ) then
19510: LD_INT 50
19512: PPUSH
19513: CALL_OW 13
19517: IFFALSE 19563
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19519: LD_INT 700
19521: PPUSH
19522: LD_INT 1050
19524: PPUSH
19525: CALL_OW 12
19529: PPUSH
19530: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19534: LD_INT 1
19536: PPUSH
19537: LD_INT 5
19539: PPUSH
19540: CALL_OW 12
19544: PPUSH
19545: LD_INT 181
19547: PPUSH
19548: LD_INT 218
19550: PPUSH
19551: LD_INT 16
19553: PPUSH
19554: LD_INT 1
19556: PPUSH
19557: CALL_OW 56
// end else
19561: GO 19635
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19563: LD_INT 350
19565: PPUSH
19566: LD_INT 525
19568: PPUSH
19569: CALL_OW 12
19573: PPUSH
19574: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19578: LD_INT 1
19580: PPUSH
19581: LD_INT 5
19583: PPUSH
19584: CALL_OW 12
19588: PPUSH
19589: LD_INT 13
19591: PPUSH
19592: LD_INT 1
19594: PPUSH
19595: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19599: LD_INT 350
19601: PPUSH
19602: LD_INT 700
19604: PPUSH
19605: CALL_OW 12
19609: PPUSH
19610: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19614: LD_INT 1
19616: PPUSH
19617: LD_INT 5
19619: PPUSH
19620: CALL_OW 12
19624: PPUSH
19625: LD_INT 33
19627: PPUSH
19628: LD_INT 1
19630: PPUSH
19631: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19635: LD_INT 65
19637: PUSH
19638: LD_INT 62
19640: PUSH
19641: LD_INT 55
19643: PUSH
19644: LD_INT 50
19646: PUSH
19647: EMPTY
19648: LIST
19649: LIST
19650: LIST
19651: LIST
19652: PUSH
19653: LD_OWVAR 67
19657: ARRAY
19658: PPUSH
19659: CALL_OW 13
19663: IFFALSE 19709
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19665: LD_INT 525
19667: PPUSH
19668: LD_INT 875
19670: PPUSH
19671: CALL_OW 12
19675: PPUSH
19676: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19680: LD_INT 1
19682: PPUSH
19683: LD_INT 5
19685: PPUSH
19686: CALL_OW 12
19690: PPUSH
19691: LD_INT 294
19693: PPUSH
19694: LD_INT 211
19696: PPUSH
19697: LD_INT 30
19699: PPUSH
19700: LD_INT 1
19702: PPUSH
19703: CALL_OW 56
// end else
19707: GO 19751
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
19709: LD_INT 420
19711: PPUSH
19712: LD_INT 770
19714: PPUSH
19715: CALL_OW 12
19719: PPUSH
19720: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19724: LD_INT 1
19726: PPUSH
19727: LD_INT 5
19729: PPUSH
19730: CALL_OW 12
19734: PPUSH
19735: LD_INT 294
19737: PPUSH
19738: LD_INT 211
19740: PPUSH
19741: LD_INT 30
19743: PPUSH
19744: LD_INT 1
19746: PPUSH
19747: CALL_OW 56
// end ; if time > 2 2$20 then
19751: LD_VAR 0 1
19755: PUSH
19756: LD_INT 4900
19758: GREATER
19759: IFFALSE 19769
// time := 0 0$50 ;
19761: LD_ADDR_VAR 0 1
19765: PUSH
19766: LD_INT 1750
19768: ST_TO_ADDR
// until false ;
19769: LD_INT 0
19771: IFFALSE 19362
// end ;
19773: PPOPN 1
19775: END
// every 0 0$45 trigger tick < 10 10$00 do
19776: LD_OWVAR 1
19780: PUSH
19781: LD_INT 21000
19783: LESS
19784: IFFALSE 19832
19786: GO 19788
19788: DISABLE
// begin enable ;
19789: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19790: LD_INT 350
19792: PPUSH
19793: LD_INT 700
19795: PPUSH
19796: CALL_OW 12
19800: PPUSH
19801: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
19805: LD_INT 3
19807: PPUSH
19808: LD_INT 5
19810: PPUSH
19811: CALL_OW 12
19815: PPUSH
19816: LD_INT 181
19818: PPUSH
19819: LD_INT 13
19821: PPUSH
19822: LD_INT 20
19824: PPUSH
19825: LD_INT 1
19827: PPUSH
19828: CALL_OW 56
// end ; end_of_file
19832: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
19833: LD_INT 0
19835: PPUSH
// SetArtifactRes ( 7 , true ) ;
19836: LD_INT 7
19838: PPUSH
19839: LD_INT 1
19841: PPUSH
19842: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
19846: LD_ADDR_EXP 66
19850: PUSH
19851: EMPTY
19852: PUSH
19853: EMPTY
19854: PUSH
19855: EMPTY
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: LIST
19861: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
19862: LD_ADDR_EXP 67
19866: PUSH
19867: LD_INT 1050
19869: PUSH
19870: LD_OWVAR 67
19874: MUL
19875: PUSH
19876: LD_INT 2800
19878: PUSH
19879: LD_OWVAR 67
19883: MUL
19884: PUSH
19885: LD_INT 1
19887: NEG
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: LIST
19893: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
19894: LD_ADDR_EXP 68
19898: PUSH
19899: LD_INT 10
19901: PUSH
19902: LD_INT 35
19904: PUSH
19905: LD_INT 100
19907: PUSH
19908: EMPTY
19909: LIST
19910: LIST
19911: LIST
19912: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
19913: LD_ADDR_EXP 69
19917: PUSH
19918: LD_INT 0
19920: PUSH
19921: LD_INT 0
19923: PUSH
19924: LD_INT 0
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: LIST
19931: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
19932: LD_ADDR_EXP 71
19936: PUSH
19937: LD_INT 300
19939: PUSH
19940: LD_INT 500
19942: PUSH
19943: LD_INT 800
19945: PUSH
19946: EMPTY
19947: LIST
19948: LIST
19949: LIST
19950: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
19951: LD_ADDR_EXP 72
19955: PUSH
19956: LD_INT 0
19958: PUSH
19959: LD_INT 0
19961: PUSH
19962: LD_INT 0
19964: PUSH
19965: EMPTY
19966: LIST
19967: LIST
19968: LIST
19969: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
19970: LD_ADDR_EXP 73
19974: PUSH
19975: LD_INT 0
19977: PUSH
19978: LD_INT 0
19980: PUSH
19981: LD_INT 0
19983: PUSH
19984: EMPTY
19985: LIST
19986: LIST
19987: LIST
19988: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
19989: LD_ADDR_EXP 70
19993: PUSH
19994: LD_INT 0
19996: PUSH
19997: LD_INT 0
19999: PUSH
20000: LD_INT 0
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: LIST
20007: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
20008: LD_ADDR_EXP 74
20012: PUSH
20013: LD_INT 4
20015: PUSH
20016: LD_INT 3
20018: PUSH
20019: LD_INT 1
20021: PUSH
20022: EMPTY
20023: LIST
20024: LIST
20025: LIST
20026: PUSH
20027: LD_INT 5
20029: PUSH
20030: LD_INT 4
20032: PUSH
20033: LD_INT 2
20035: PUSH
20036: EMPTY
20037: LIST
20038: LIST
20039: LIST
20040: PUSH
20041: LD_INT 6
20043: PUSH
20044: LD_INT 3
20046: PUSH
20047: LD_INT 3
20049: PUSH
20050: EMPTY
20051: LIST
20052: LIST
20053: LIST
20054: PUSH
20055: EMPTY
20056: LIST
20057: LIST
20058: LIST
20059: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
20060: LD_ADDR_EXP 75
20064: PUSH
20065: LD_INT 0
20067: PUSH
20068: LD_INT 0
20070: PUSH
20071: LD_INT 0
20073: PUSH
20074: EMPTY
20075: LIST
20076: LIST
20077: LIST
20078: ST_TO_ADDR
// end ;
20079: LD_VAR 0 1
20083: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
20084: LD_INT 24
20086: PPUSH
20087: LD_INT 7
20089: PPUSH
20090: CALL_OW 321
20094: PUSH
20095: LD_INT 2
20097: EQUAL
20098: IFFALSE 21024
20100: GO 20102
20102: DISABLE
20103: LD_INT 0
20105: PPUSH
20106: PPUSH
20107: PPUSH
20108: PPUSH
20109: PPUSH
// begin enable ;
20110: ENABLE
// for i = 1 to 3 do
20111: LD_ADDR_VAR 0 1
20115: PUSH
20116: DOUBLE
20117: LD_INT 1
20119: DEC
20120: ST_TO_ADDR
20121: LD_INT 3
20123: PUSH
20124: FOR_TO
20125: IFFALSE 21022
// begin pos := FindArtifact ( i + 2 ) ;
20127: LD_ADDR_VAR 0 2
20131: PUSH
20132: LD_VAR 0 1
20136: PUSH
20137: LD_INT 2
20139: PLUS
20140: PPUSH
20141: CALL_OW 469
20145: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
20146: LD_ADDR_EXP 66
20150: PUSH
20151: LD_EXP 66
20155: PPUSH
20156: LD_VAR 0 1
20160: PPUSH
20161: LD_VAR 0 2
20165: PPUSH
20166: CALL_OW 1
20170: ST_TO_ADDR
// if pos then
20171: LD_VAR 0 2
20175: IFFALSE 20883
// begin case i of 1 :
20177: LD_VAR 0 1
20181: PUSH
20182: LD_INT 1
20184: DOUBLE
20185: EQUAL
20186: IFTRUE 20190
20188: GO 20267
20190: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
20191: LD_ADDR_VAR 0 4
20195: PUSH
20196: LD_INT 22
20198: PUSH
20199: LD_INT 7
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: PUSH
20206: LD_INT 23
20208: PUSH
20209: LD_INT 1
20211: PUSH
20212: EMPTY
20213: LIST
20214: LIST
20215: PUSH
20216: LD_INT 2
20218: PUSH
20219: LD_INT 30
20221: PUSH
20222: LD_INT 8
20224: PUSH
20225: EMPTY
20226: LIST
20227: LIST
20228: PUSH
20229: LD_INT 30
20231: PUSH
20232: LD_INT 7
20234: PUSH
20235: EMPTY
20236: LIST
20237: LIST
20238: PUSH
20239: LD_INT 30
20241: PUSH
20242: LD_INT 11
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: LIST
20253: LIST
20254: PUSH
20255: EMPTY
20256: LIST
20257: LIST
20258: LIST
20259: PPUSH
20260: CALL_OW 69
20264: ST_TO_ADDR
20265: GO 20375
20267: LD_INT 2
20269: DOUBLE
20270: EQUAL
20271: IFTRUE 20275
20273: GO 20352
20275: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
20276: LD_ADDR_VAR 0 4
20280: PUSH
20281: LD_INT 22
20283: PUSH
20284: LD_INT 7
20286: PUSH
20287: EMPTY
20288: LIST
20289: LIST
20290: PUSH
20291: LD_INT 23
20293: PUSH
20294: LD_INT 3
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: PUSH
20301: LD_INT 2
20303: PUSH
20304: LD_INT 30
20306: PUSH
20307: LD_INT 8
20309: PUSH
20310: EMPTY
20311: LIST
20312: LIST
20313: PUSH
20314: LD_INT 30
20316: PUSH
20317: LD_INT 7
20319: PUSH
20320: EMPTY
20321: LIST
20322: LIST
20323: PUSH
20324: LD_INT 30
20326: PUSH
20327: LD_INT 11
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: PUSH
20334: EMPTY
20335: LIST
20336: LIST
20337: LIST
20338: LIST
20339: PUSH
20340: EMPTY
20341: LIST
20342: LIST
20343: LIST
20344: PPUSH
20345: CALL_OW 69
20349: ST_TO_ADDR
20350: GO 20375
20352: LD_INT 3
20354: DOUBLE
20355: EQUAL
20356: IFTRUE 20360
20358: GO 20374
20360: POP
// labs := [ alien ] ; end ;
20361: LD_ADDR_VAR 0 4
20365: PUSH
20366: LD_INT 1
20368: PUSH
20369: EMPTY
20370: LIST
20371: ST_TO_ADDR
20372: GO 20375
20374: POP
// if not labs then
20375: LD_VAR 0 4
20379: NOT
20380: IFFALSE 20384
// continue ;
20382: GO 20124
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
20384: LD_ADDR_VAR 0 5
20388: PUSH
20389: LD_VAR 0 4
20393: PPUSH
20394: LD_EXP 66
20398: PUSH
20399: LD_VAR 0 1
20403: ARRAY
20404: PUSH
20405: LD_INT 1
20407: ARRAY
20408: PPUSH
20409: LD_EXP 66
20413: PUSH
20414: LD_VAR 0 1
20418: ARRAY
20419: PUSH
20420: LD_INT 2
20422: ARRAY
20423: PPUSH
20424: CALL_OW 73
20428: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
20429: LD_VAR 0 5
20433: NOT
20434: PUSH
20435: LD_VAR 0 5
20439: PUSH
20440: LD_EXP 73
20444: PUSH
20445: LD_VAR 0 1
20449: ARRAY
20450: NONEQUAL
20451: OR
20452: IFFALSE 20557
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20454: LD_INT 7
20456: PPUSH
20457: LD_EXP 74
20461: PUSH
20462: LD_VAR 0 1
20466: ARRAY
20467: PUSH
20468: LD_INT 3
20470: ARRAY
20471: PPUSH
20472: LD_INT 0
20474: PPUSH
20475: LD_EXP 73
20479: PUSH
20480: LD_VAR 0 1
20484: ARRAY
20485: PPUSH
20486: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20490: LD_INT 7
20492: PPUSH
20493: LD_EXP 74
20497: PUSH
20498: LD_VAR 0 1
20502: ARRAY
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: PPUSH
20508: LD_INT 0
20510: PPUSH
20511: LD_EXP 73
20515: PUSH
20516: LD_VAR 0 1
20520: ARRAY
20521: PPUSH
20522: CALL_OW 468
// if nearestLab then
20526: LD_VAR 0 5
20530: IFFALSE 20557
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20532: LD_ADDR_EXP 73
20536: PUSH
20537: LD_EXP 73
20541: PPUSH
20542: LD_VAR 0 1
20546: PPUSH
20547: LD_VAR 0 5
20551: PPUSH
20552: CALL_OW 1
20556: ST_TO_ADDR
// end ; if not nearestLab then
20557: LD_VAR 0 5
20561: NOT
20562: IFFALSE 20566
// continue ;
20564: GO 20124
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20566: LD_VAR 0 5
20570: PPUSH
20571: LD_EXP 66
20575: PUSH
20576: LD_VAR 0 1
20580: ARRAY
20581: PUSH
20582: LD_INT 1
20584: ARRAY
20585: PPUSH
20586: LD_EXP 66
20590: PUSH
20591: LD_VAR 0 1
20595: ARRAY
20596: PUSH
20597: LD_INT 2
20599: ARRAY
20600: PPUSH
20601: CALL_OW 297
20605: PUSH
20606: LD_INT 8
20608: LESS
20609: IFFALSE 20806
// begin if not artifactsResearched [ i ] then
20611: LD_EXP 69
20615: PUSH
20616: LD_VAR 0 1
20620: ARRAY
20621: NOT
20622: IFFALSE 20703
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20624: LD_VAR 0 5
20628: PPUSH
20629: CALL_OW 461
20633: PUSH
20634: LD_INT 2
20636: EQUAL
20637: IFFALSE 20671
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20639: LD_INT 7
20641: PPUSH
20642: LD_EXP 74
20646: PUSH
20647: LD_VAR 0 1
20651: ARRAY
20652: PUSH
20653: LD_INT 3
20655: ARRAY
20656: PPUSH
20657: LD_INT 2
20659: PPUSH
20660: LD_VAR 0 5
20664: PPUSH
20665: CALL_OW 468
20669: GO 20701
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20671: LD_INT 7
20673: PPUSH
20674: LD_EXP 74
20678: PUSH
20679: LD_VAR 0 1
20683: ARRAY
20684: PUSH
20685: LD_INT 3
20687: ARRAY
20688: PPUSH
20689: LD_INT 1
20691: PPUSH
20692: LD_VAR 0 5
20696: PPUSH
20697: CALL_OW 468
// end else
20701: GO 20804
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
20703: LD_VAR 0 5
20707: PPUSH
20708: CALL_OW 461
20712: PUSH
20713: LD_INT 2
20715: EQUAL
20716: PUSH
20717: LD_EXP 75
20721: PUSH
20722: LD_VAR 0 1
20726: ARRAY
20727: AND
20728: IFFALSE 20774
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
20730: LD_INT 7
20732: PPUSH
20733: LD_EXP 74
20737: PUSH
20738: LD_VAR 0 1
20742: ARRAY
20743: PUSH
20744: LD_INT 1
20746: ARRAY
20747: PPUSH
20748: LD_EXP 74
20752: PUSH
20753: LD_VAR 0 1
20757: ARRAY
20758: PUSH
20759: LD_INT 2
20761: ARRAY
20762: PPUSH
20763: LD_VAR 0 5
20767: PPUSH
20768: CALL_OW 468
20772: GO 20804
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
20774: LD_INT 7
20776: PPUSH
20777: LD_EXP 74
20781: PUSH
20782: LD_VAR 0 1
20786: ARRAY
20787: PUSH
20788: LD_INT 1
20790: ARRAY
20791: PPUSH
20792: LD_INT 1
20794: PPUSH
20795: LD_VAR 0 5
20799: PPUSH
20800: CALL_OW 468
// end else
20804: GO 20881
// begin if not artifactsResearched [ i ] then
20806: LD_EXP 69
20810: PUSH
20811: LD_VAR 0 1
20815: ARRAY
20816: NOT
20817: IFFALSE 20851
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
20819: LD_INT 7
20821: PPUSH
20822: LD_EXP 74
20826: PUSH
20827: LD_VAR 0 1
20831: ARRAY
20832: PUSH
20833: LD_INT 3
20835: ARRAY
20836: PPUSH
20837: LD_INT 0
20839: PPUSH
20840: LD_VAR 0 5
20844: PPUSH
20845: CALL_OW 468
20849: GO 20881
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
20851: LD_INT 7
20853: PPUSH
20854: LD_EXP 74
20858: PUSH
20859: LD_VAR 0 1
20863: ARRAY
20864: PUSH
20865: LD_INT 1
20867: ARRAY
20868: PPUSH
20869: LD_INT 0
20871: PPUSH
20872: LD_VAR 0 5
20876: PPUSH
20877: CALL_OW 468
// end ; end else
20881: GO 21020
// begin if not artifactsLabs [ i ] then
20883: LD_EXP 73
20887: PUSH
20888: LD_VAR 0 1
20892: ARRAY
20893: NOT
20894: IFFALSE 20898
// continue ;
20896: GO 20124
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20898: LD_INT 7
20900: PPUSH
20901: LD_EXP 74
20905: PUSH
20906: LD_VAR 0 1
20910: ARRAY
20911: PUSH
20912: LD_INT 3
20914: ARRAY
20915: PPUSH
20916: LD_INT 0
20918: PPUSH
20919: LD_EXP 73
20923: PUSH
20924: LD_VAR 0 1
20928: ARRAY
20929: PPUSH
20930: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20934: LD_INT 7
20936: PPUSH
20937: LD_EXP 74
20941: PUSH
20942: LD_VAR 0 1
20946: ARRAY
20947: PUSH
20948: LD_INT 1
20950: ARRAY
20951: PPUSH
20952: LD_INT 0
20954: PPUSH
20955: LD_EXP 73
20959: PUSH
20960: LD_VAR 0 1
20964: ARRAY
20965: PPUSH
20966: CALL_OW 468
// if artifactsLabsWorking [ i ] then
20970: LD_EXP 70
20974: PUSH
20975: LD_VAR 0 1
20979: ARRAY
20980: IFFALSE 21020
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
20982: LD_ADDR_EXP 70
20986: PUSH
20987: LD_EXP 70
20991: PPUSH
20992: LD_VAR 0 1
20996: PPUSH
20997: LD_INT 0
20999: PPUSH
21000: CALL_OW 1
21004: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
21005: LD_EXP 73
21009: PUSH
21010: LD_VAR 0 1
21014: ARRAY
21015: PPUSH
21016: CALL_OW 127
// end ; end ; end ;
21020: GO 20124
21022: POP
21023: POP
// end ;
21024: PPOPN 5
21026: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
21027: LD_INT 0
21029: PPUSH
21030: PPUSH
21031: PPUSH
21032: PPUSH
21033: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
21034: LD_VAR 0 2
21038: PUSH
21039: LD_EXP 74
21043: PUSH
21044: LD_INT 1
21046: ARRAY
21047: PUSH
21048: LD_INT 3
21050: ARRAY
21051: EQUAL
21052: IFFALSE 21175
// begin lab := artifactsLabs [ 1 ] ;
21054: LD_ADDR_VAR 0 6
21058: PUSH
21059: LD_EXP 73
21063: PUSH
21064: LD_INT 1
21066: ARRAY
21067: ST_TO_ADDR
// if not lab then
21068: LD_VAR 0 6
21072: NOT
21073: IFFALSE 21077
// exit ;
21075: GO 22155
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
21077: LD_VAR 0 6
21081: PPUSH
21082: LD_EXP 71
21086: PUSH
21087: LD_INT 1
21089: ARRAY
21090: PPUSH
21091: LD_INT 1
21093: PPUSH
21094: CALL_OW 486
// if artifactsResProgress [ 1 ] then
21098: LD_EXP 72
21102: PUSH
21103: LD_INT 1
21105: ARRAY
21106: IFFALSE 21126
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
21108: LD_VAR 0 6
21112: PPUSH
21113: LD_EXP 72
21117: PUSH
21118: LD_INT 1
21120: ARRAY
21121: PPUSH
21122: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
21126: LD_ADDR_EXP 70
21130: PUSH
21131: LD_EXP 70
21135: PPUSH
21136: LD_INT 1
21138: PPUSH
21139: LD_INT 1
21141: PPUSH
21142: CALL_OW 1
21146: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
21147: LD_INT 7
21149: PPUSH
21150: LD_EXP 74
21154: PUSH
21155: LD_INT 1
21157: ARRAY
21158: PUSH
21159: LD_INT 3
21161: ARRAY
21162: PPUSH
21163: LD_INT 0
21165: PPUSH
21166: LD_VAR 0 6
21170: PPUSH
21171: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
21175: LD_VAR 0 2
21179: PUSH
21180: LD_EXP 74
21184: PUSH
21185: LD_INT 2
21187: ARRAY
21188: PUSH
21189: LD_INT 3
21191: ARRAY
21192: EQUAL
21193: IFFALSE 21316
// begin lab := artifactsLabs [ 2 ] ;
21195: LD_ADDR_VAR 0 6
21199: PUSH
21200: LD_EXP 73
21204: PUSH
21205: LD_INT 2
21207: ARRAY
21208: ST_TO_ADDR
// if not lab then
21209: LD_VAR 0 6
21213: NOT
21214: IFFALSE 21218
// exit ;
21216: GO 22155
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
21218: LD_VAR 0 6
21222: PPUSH
21223: LD_EXP 71
21227: PUSH
21228: LD_INT 2
21230: ARRAY
21231: PPUSH
21232: LD_INT 1
21234: PPUSH
21235: CALL_OW 486
// if artifactsResProgress [ 2 ] then
21239: LD_EXP 72
21243: PUSH
21244: LD_INT 2
21246: ARRAY
21247: IFFALSE 21267
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
21249: LD_VAR 0 6
21253: PPUSH
21254: LD_EXP 72
21258: PUSH
21259: LD_INT 2
21261: ARRAY
21262: PPUSH
21263: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
21267: LD_ADDR_EXP 70
21271: PUSH
21272: LD_EXP 70
21276: PPUSH
21277: LD_INT 2
21279: PPUSH
21280: LD_INT 1
21282: PPUSH
21283: CALL_OW 1
21287: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
21288: LD_INT 7
21290: PPUSH
21291: LD_EXP 74
21295: PUSH
21296: LD_INT 2
21298: ARRAY
21299: PUSH
21300: LD_INT 3
21302: ARRAY
21303: PPUSH
21304: LD_INT 0
21306: PPUSH
21307: LD_VAR 0 6
21311: PPUSH
21312: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
21316: LD_VAR 0 2
21320: PUSH
21321: LD_EXP 74
21325: PUSH
21326: LD_INT 3
21328: ARRAY
21329: PUSH
21330: LD_INT 3
21332: ARRAY
21333: EQUAL
21334: IFFALSE 21457
// begin lab := artifactsLabs [ 3 ] ;
21336: LD_ADDR_VAR 0 6
21340: PUSH
21341: LD_EXP 73
21345: PUSH
21346: LD_INT 3
21348: ARRAY
21349: ST_TO_ADDR
// if not lab then
21350: LD_VAR 0 6
21354: NOT
21355: IFFALSE 21359
// exit ;
21357: GO 22155
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
21359: LD_VAR 0 6
21363: PPUSH
21364: LD_EXP 71
21368: PUSH
21369: LD_INT 3
21371: ARRAY
21372: PPUSH
21373: LD_INT 1
21375: PPUSH
21376: CALL_OW 486
// if artifactsResProgress [ 3 ] then
21380: LD_EXP 72
21384: PUSH
21385: LD_INT 3
21387: ARRAY
21388: IFFALSE 21408
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
21390: LD_VAR 0 6
21394: PPUSH
21395: LD_EXP 72
21399: PUSH
21400: LD_INT 3
21402: ARRAY
21403: PPUSH
21404: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
21408: LD_ADDR_EXP 70
21412: PUSH
21413: LD_EXP 70
21417: PPUSH
21418: LD_INT 3
21420: PPUSH
21421: LD_INT 1
21423: PPUSH
21424: CALL_OW 1
21428: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
21429: LD_INT 7
21431: PPUSH
21432: LD_EXP 74
21436: PUSH
21437: LD_INT 3
21439: ARRAY
21440: PUSH
21441: LD_INT 3
21443: ARRAY
21444: PPUSH
21445: LD_INT 0
21447: PPUSH
21448: LD_VAR 0 6
21452: PPUSH
21453: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21457: LD_VAR 0 2
21461: PUSH
21462: LD_EXP 74
21466: PUSH
21467: LD_INT 1
21469: ARRAY
21470: PUSH
21471: LD_INT 1
21473: ARRAY
21474: EQUAL
21475: IFFALSE 21633
// begin lab := artifactsLabs [ 1 ] ;
21477: LD_ADDR_VAR 0 6
21481: PUSH
21482: LD_EXP 73
21486: PUSH
21487: LD_INT 1
21489: ARRAY
21490: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21491: LD_VAR 0 6
21495: PPUSH
21496: CALL_OW 274
21500: PPUSH
21501: CALL 91190 0 1
21505: PUSH
21506: LD_INT 3
21508: ARRAY
21509: PUSH
21510: LD_EXP 68
21514: PUSH
21515: LD_INT 1
21517: ARRAY
21518: LESS
21519: IFFALSE 21533
// begin HintSpec ( ArtifactCost , 2 ) ;
21521: LD_STRING ArtifactCost
21523: PPUSH
21524: LD_INT 2
21526: PPUSH
21527: CALL_OW 338
// exit ;
21531: GO 22155
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21533: LD_ADDR_EXP 75
21537: PUSH
21538: LD_EXP 75
21542: PPUSH
21543: LD_INT 1
21545: PPUSH
21546: LD_INT 0
21548: PPUSH
21549: CALL_OW 1
21553: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21554: LD_VAR 0 3
21558: PPUSH
21559: LD_VAR 0 4
21563: PPUSH
21564: LD_INT 7
21566: PPUSH
21567: LD_INT 12
21569: NEG
21570: PPUSH
21571: CALL_OW 330
// wait ( 0 0$30 ) ;
21575: LD_INT 1050
21577: PPUSH
21578: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21582: LD_VAR 0 3
21586: PPUSH
21587: LD_VAR 0 4
21591: PPUSH
21592: LD_INT 7
21594: PPUSH
21595: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21599: LD_EXP 67
21603: PUSH
21604: LD_INT 1
21606: ARRAY
21607: PPUSH
21608: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21612: LD_ADDR_EXP 75
21616: PUSH
21617: LD_EXP 75
21621: PPUSH
21622: LD_INT 1
21624: PPUSH
21625: LD_INT 1
21627: PPUSH
21628: CALL_OW 1
21632: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
21633: LD_VAR 0 2
21637: PUSH
21638: LD_EXP 74
21642: PUSH
21643: LD_INT 2
21645: ARRAY
21646: PUSH
21647: LD_INT 1
21649: ARRAY
21650: EQUAL
21651: IFFALSE 21888
// begin lab := artifactsLabs [ 2 ] ;
21653: LD_ADDR_VAR 0 6
21657: PUSH
21658: LD_EXP 73
21662: PUSH
21663: LD_INT 2
21665: ARRAY
21666: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
21667: LD_VAR 0 3
21671: PUSH
21672: LD_INT 81
21674: PUSH
21675: LD_INT 7
21677: PUSH
21678: EMPTY
21679: LIST
21680: LIST
21681: PUSH
21682: LD_INT 2
21684: PUSH
21685: LD_INT 32
21687: PUSH
21688: LD_INT 3
21690: PUSH
21691: EMPTY
21692: LIST
21693: LIST
21694: PUSH
21695: LD_INT 30
21697: PUSH
21698: LD_INT 28
21700: PUSH
21701: EMPTY
21702: LIST
21703: LIST
21704: PUSH
21705: LD_INT 30
21707: PUSH
21708: LD_INT 30
21710: PUSH
21711: EMPTY
21712: LIST
21713: LIST
21714: PUSH
21715: LD_INT 35
21717: PUSH
21718: LD_INT 49
21720: PUSH
21721: EMPTY
21722: LIST
21723: LIST
21724: PUSH
21725: LD_INT 34
21727: PUSH
21728: LD_INT 49
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PUSH
21735: LD_INT 30
21737: PUSH
21738: LD_INT 21
21740: PUSH
21741: EMPTY
21742: LIST
21743: LIST
21744: PUSH
21745: EMPTY
21746: LIST
21747: LIST
21748: LIST
21749: LIST
21750: LIST
21751: LIST
21752: LIST
21753: PUSH
21754: EMPTY
21755: LIST
21756: LIST
21757: PPUSH
21758: CALL_OW 69
21762: IN
21763: NOT
21764: IFFALSE 21768
// exit ;
21766: GO 22155
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
21768: LD_VAR 0 6
21772: PPUSH
21773: CALL_OW 274
21777: PPUSH
21778: CALL 91190 0 1
21782: PUSH
21783: LD_INT 3
21785: ARRAY
21786: PUSH
21787: LD_EXP 68
21791: PUSH
21792: LD_INT 2
21794: ARRAY
21795: LESS
21796: IFFALSE 21810
// begin HintSpec ( ArtifactCost , 2 ) ;
21798: LD_STRING ArtifactCost
21800: PPUSH
21801: LD_INT 2
21803: PPUSH
21804: CALL_OW 338
// exit ;
21808: GO 22155
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
21810: LD_ADDR_EXP 75
21814: PUSH
21815: LD_EXP 75
21819: PPUSH
21820: LD_INT 2
21822: PPUSH
21823: LD_INT 0
21825: PPUSH
21826: CALL_OW 1
21830: ST_TO_ADDR
// KillUnit ( x ) ;
21831: LD_VAR 0 3
21835: PPUSH
21836: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
21840: LD_ADDR_EXP 16
21844: PUSH
21845: LD_EXP 16
21849: PUSH
21850: LD_INT 1
21852: PLUS
21853: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
21854: LD_EXP 67
21858: PUSH
21859: LD_INT 2
21861: ARRAY
21862: PPUSH
21863: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
21867: LD_ADDR_EXP 75
21871: PUSH
21872: LD_EXP 75
21876: PPUSH
21877: LD_INT 2
21879: PPUSH
21880: LD_INT 1
21882: PPUSH
21883: CALL_OW 1
21887: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
21888: LD_VAR 0 2
21892: PUSH
21893: LD_EXP 74
21897: PUSH
21898: LD_INT 3
21900: ARRAY
21901: PUSH
21902: LD_INT 1
21904: ARRAY
21905: EQUAL
21906: IFFALSE 22155
// begin lab := artifactsLabs [ 3 ] ;
21908: LD_ADDR_VAR 0 6
21912: PUSH
21913: LD_EXP 73
21917: PUSH
21918: LD_INT 3
21920: ARRAY
21921: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
21922: LD_VAR 0 6
21926: PPUSH
21927: CALL_OW 274
21931: PPUSH
21932: CALL 91190 0 1
21936: PUSH
21937: LD_INT 3
21939: ARRAY
21940: PUSH
21941: LD_EXP 68
21945: PUSH
21946: LD_INT 3
21948: ARRAY
21949: LESS
21950: IFFALSE 21964
// begin HintSpec ( ArtifactCost , 2 ) ;
21952: LD_STRING ArtifactCost
21954: PPUSH
21955: LD_INT 2
21957: PPUSH
21958: CALL_OW 338
// exit ;
21962: GO 22155
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
21964: LD_INT 37
21966: PPUSH
21967: LD_INT 1
21969: PPUSH
21970: CALL_OW 424
// time := 0 0$30 ;
21974: LD_ADDR_VAR 0 7
21978: PUSH
21979: LD_INT 1050
21981: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
21982: LD_ADDR_EXP 75
21986: PUSH
21987: LD_EXP 75
21991: PPUSH
21992: LD_INT 3
21994: PPUSH
21995: LD_INT 0
21997: PPUSH
21998: CALL_OW 1
22002: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
22003: LD_ADDR_OWVAR 47
22007: PUSH
22008: LD_STRING #Am15a-1
22010: PUSH
22011: LD_VAR 0 7
22015: PUSH
22016: EMPTY
22017: LIST
22018: LIST
22019: ST_TO_ADDR
// wait ( 0 0$1 ) ;
22020: LD_INT 35
22022: PPUSH
22023: CALL_OW 67
// time := time - 0 0$1 ;
22027: LD_ADDR_VAR 0 7
22031: PUSH
22032: LD_VAR 0 7
22036: PUSH
22037: LD_INT 35
22039: MINUS
22040: ST_TO_ADDR
// until time = 0 0$00 ;
22041: LD_VAR 0 7
22045: PUSH
22046: LD_INT 0
22048: EQUAL
22049: IFFALSE 22003
// display_strings :=  ;
22051: LD_ADDR_OWVAR 47
22055: PUSH
22056: LD_STRING 
22058: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
22059: LD_INT 37
22061: PPUSH
22062: LD_INT 0
22064: PPUSH
22065: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
22069: LD_ADDR_VAR 0 8
22073: PUSH
22074: LD_INT 37
22076: PPUSH
22077: LD_INT 3
22079: PUSH
22080: LD_INT 21
22082: PUSH
22083: LD_INT 3
22085: PUSH
22086: EMPTY
22087: LIST
22088: LIST
22089: PUSH
22090: EMPTY
22091: LIST
22092: LIST
22093: PPUSH
22094: CALL_OW 70
22098: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
22099: LD_VAR 0 3
22103: PPUSH
22104: LD_VAR 0 4
22108: PPUSH
22109: CALL_OW 84
// for un in list do
22113: LD_ADDR_VAR 0 9
22117: PUSH
22118: LD_VAR 0 8
22122: PUSH
22123: FOR_IN
22124: IFFALSE 22153
// TeleportUnit ( un , x , y , 12 , true ) ;
22126: LD_VAR 0 9
22130: PPUSH
22131: LD_VAR 0 3
22135: PPUSH
22136: LD_VAR 0 4
22140: PPUSH
22141: LD_INT 12
22143: PPUSH
22144: LD_INT 1
22146: PPUSH
22147: CALL_OW 483
22151: GO 22123
22153: POP
22154: POP
// end ; end ;
22155: PPOPN 9
22157: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
22158: LD_INT 0
22160: PPUSH
22161: PPUSH
// begin labNum := 0 ;
22162: LD_ADDR_VAR 0 4
22166: PUSH
22167: LD_INT 0
22169: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22170: LD_ADDR_VAR 0 3
22174: PUSH
22175: DOUBLE
22176: LD_INT 1
22178: DEC
22179: ST_TO_ADDR
22180: LD_EXP 73
22184: PUSH
22185: FOR_TO
22186: IFFALSE 22220
// if artifactsLabs [ i ] = lab then
22188: LD_EXP 73
22192: PUSH
22193: LD_VAR 0 3
22197: ARRAY
22198: PUSH
22199: LD_VAR 0 1
22203: EQUAL
22204: IFFALSE 22218
// begin labNum := i ;
22206: LD_ADDR_VAR 0 4
22210: PUSH
22211: LD_VAR 0 3
22215: ST_TO_ADDR
// break ;
22216: GO 22220
// end ;
22218: GO 22185
22220: POP
22221: POP
// if not labNum then
22222: LD_VAR 0 4
22226: NOT
22227: IFFALSE 22231
// exit ;
22229: GO 22309
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
22231: LD_INT 7
22233: PPUSH
22234: LD_EXP 74
22238: PUSH
22239: LD_VAR 0 4
22243: ARRAY
22244: PUSH
22245: LD_INT 3
22247: ARRAY
22248: PPUSH
22249: LD_INT 2
22251: PPUSH
22252: LD_VAR 0 1
22256: PPUSH
22257: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
22261: LD_ADDR_EXP 72
22265: PUSH
22266: LD_EXP 72
22270: PPUSH
22271: LD_VAR 0 4
22275: PPUSH
22276: LD_VAR 0 2
22280: PPUSH
22281: CALL_OW 1
22285: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
22286: LD_ADDR_EXP 70
22290: PUSH
22291: LD_EXP 70
22295: PPUSH
22296: LD_VAR 0 4
22300: PPUSH
22301: LD_INT 0
22303: PPUSH
22304: CALL_OW 1
22308: ST_TO_ADDR
// end ;
22309: PPOPN 4
22311: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
22312: LD_INT 0
22314: PPUSH
22315: PPUSH
// begin labNum := 0 ;
22316: LD_ADDR_VAR 0 3
22320: PUSH
22321: LD_INT 0
22323: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22324: LD_ADDR_VAR 0 2
22328: PUSH
22329: DOUBLE
22330: LD_INT 1
22332: DEC
22333: ST_TO_ADDR
22334: LD_EXP 73
22338: PUSH
22339: FOR_TO
22340: IFFALSE 22374
// if artifactsLabs [ i ] = lab then
22342: LD_EXP 73
22346: PUSH
22347: LD_VAR 0 2
22351: ARRAY
22352: PUSH
22353: LD_VAR 0 1
22357: EQUAL
22358: IFFALSE 22372
// begin labNum := i ;
22360: LD_ADDR_VAR 0 3
22364: PUSH
22365: LD_VAR 0 2
22369: ST_TO_ADDR
// break ;
22370: GO 22374
// end ;
22372: GO 22339
22374: POP
22375: POP
// if not labNum then
22376: LD_VAR 0 3
22380: NOT
22381: IFFALSE 22385
// exit ;
22383: GO 22547
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
22385: LD_INT 7
22387: PPUSH
22388: LD_EXP 74
22392: PUSH
22393: LD_VAR 0 3
22397: ARRAY
22398: PUSH
22399: LD_INT 3
22401: ARRAY
22402: PPUSH
22403: LD_INT 0
22405: PPUSH
22406: LD_VAR 0 1
22410: PPUSH
22411: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
22415: LD_ADDR_EXP 69
22419: PUSH
22420: LD_EXP 69
22424: PPUSH
22425: LD_VAR 0 3
22429: PPUSH
22430: LD_INT 1
22432: PPUSH
22433: CALL_OW 1
22437: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22438: LD_ADDR_EXP 75
22442: PUSH
22443: LD_EXP 75
22447: PPUSH
22448: LD_VAR 0 3
22452: PPUSH
22453: LD_INT 1
22455: PPUSH
22456: CALL_OW 1
22460: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22461: LD_ADDR_EXP 70
22465: PUSH
22466: LD_EXP 70
22470: PPUSH
22471: LD_VAR 0 3
22475: PPUSH
22476: LD_INT 0
22478: PPUSH
22479: CALL_OW 1
22483: ST_TO_ADDR
// case labNum of 1 :
22484: LD_VAR 0 3
22488: PUSH
22489: LD_INT 1
22491: DOUBLE
22492: EQUAL
22493: IFTRUE 22497
22495: GO 22508
22497: POP
// artifactIResearched := true ; 2 :
22498: LD_ADDR_EXP 12
22502: PUSH
22503: LD_INT 1
22505: ST_TO_ADDR
22506: GO 22547
22508: LD_INT 2
22510: DOUBLE
22511: EQUAL
22512: IFTRUE 22516
22514: GO 22527
22516: POP
// artifactIIResearched := true ; 3 :
22517: LD_ADDR_EXP 13
22521: PUSH
22522: LD_INT 1
22524: ST_TO_ADDR
22525: GO 22547
22527: LD_INT 3
22529: DOUBLE
22530: EQUAL
22531: IFTRUE 22535
22533: GO 22546
22535: POP
// artifactIIIResearched := true ; end ;
22536: LD_ADDR_EXP 14
22540: PUSH
22541: LD_INT 1
22543: ST_TO_ADDR
22544: GO 22547
22546: POP
// end ; end_of_file
22547: PPOPN 3
22549: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
22550: LD_INT 0
22552: PPUSH
22553: PPUSH
// skirmish := false ;
22554: LD_ADDR_EXP 76
22558: PUSH
22559: LD_INT 0
22561: ST_TO_ADDR
// debug_mc := false ;
22562: LD_ADDR_EXP 77
22566: PUSH
22567: LD_INT 0
22569: ST_TO_ADDR
// mc_bases := [ ] ;
22570: LD_ADDR_EXP 78
22574: PUSH
22575: EMPTY
22576: ST_TO_ADDR
// mc_sides := [ ] ;
22577: LD_ADDR_EXP 104
22581: PUSH
22582: EMPTY
22583: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
22584: LD_ADDR_EXP 79
22588: PUSH
22589: EMPTY
22590: ST_TO_ADDR
// mc_building_repairs := [ ] ;
22591: LD_ADDR_EXP 80
22595: PUSH
22596: EMPTY
22597: ST_TO_ADDR
// mc_need_heal := [ ] ;
22598: LD_ADDR_EXP 81
22602: PUSH
22603: EMPTY
22604: ST_TO_ADDR
// mc_healers := [ ] ;
22605: LD_ADDR_EXP 82
22609: PUSH
22610: EMPTY
22611: ST_TO_ADDR
// mc_build_list := [ ] ;
22612: LD_ADDR_EXP 83
22616: PUSH
22617: EMPTY
22618: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
22619: LD_ADDR_EXP 110
22623: PUSH
22624: EMPTY
22625: ST_TO_ADDR
// mc_builders := [ ] ;
22626: LD_ADDR_EXP 84
22630: PUSH
22631: EMPTY
22632: ST_TO_ADDR
// mc_construct_list := [ ] ;
22633: LD_ADDR_EXP 85
22637: PUSH
22638: EMPTY
22639: ST_TO_ADDR
// mc_turret_list := [ ] ;
22640: LD_ADDR_EXP 86
22644: PUSH
22645: EMPTY
22646: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
22647: LD_ADDR_EXP 87
22651: PUSH
22652: EMPTY
22653: ST_TO_ADDR
// mc_miners := [ ] ;
22654: LD_ADDR_EXP 92
22658: PUSH
22659: EMPTY
22660: ST_TO_ADDR
// mc_mines := [ ] ;
22661: LD_ADDR_EXP 91
22665: PUSH
22666: EMPTY
22667: ST_TO_ADDR
// mc_minefields := [ ] ;
22668: LD_ADDR_EXP 93
22672: PUSH
22673: EMPTY
22674: ST_TO_ADDR
// mc_crates := [ ] ;
22675: LD_ADDR_EXP 94
22679: PUSH
22680: EMPTY
22681: ST_TO_ADDR
// mc_crates_collector := [ ] ;
22682: LD_ADDR_EXP 95
22686: PUSH
22687: EMPTY
22688: ST_TO_ADDR
// mc_crates_area := [ ] ;
22689: LD_ADDR_EXP 96
22693: PUSH
22694: EMPTY
22695: ST_TO_ADDR
// mc_vehicles := [ ] ;
22696: LD_ADDR_EXP 97
22700: PUSH
22701: EMPTY
22702: ST_TO_ADDR
// mc_attack := [ ] ;
22703: LD_ADDR_EXP 98
22707: PUSH
22708: EMPTY
22709: ST_TO_ADDR
// mc_produce := [ ] ;
22710: LD_ADDR_EXP 99
22714: PUSH
22715: EMPTY
22716: ST_TO_ADDR
// mc_defender := [ ] ;
22717: LD_ADDR_EXP 100
22721: PUSH
22722: EMPTY
22723: ST_TO_ADDR
// mc_parking := [ ] ;
22724: LD_ADDR_EXP 102
22728: PUSH
22729: EMPTY
22730: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
22731: LD_ADDR_EXP 88
22735: PUSH
22736: EMPTY
22737: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
22738: LD_ADDR_EXP 90
22742: PUSH
22743: EMPTY
22744: ST_TO_ADDR
// mc_scan := [ ] ;
22745: LD_ADDR_EXP 101
22749: PUSH
22750: EMPTY
22751: ST_TO_ADDR
// mc_scan_area := [ ] ;
22752: LD_ADDR_EXP 103
22756: PUSH
22757: EMPTY
22758: ST_TO_ADDR
// mc_tech := [ ] ;
22759: LD_ADDR_EXP 105
22763: PUSH
22764: EMPTY
22765: ST_TO_ADDR
// mc_class := [ ] ;
22766: LD_ADDR_EXP 119
22770: PUSH
22771: EMPTY
22772: ST_TO_ADDR
// mc_class_case_use := [ ] ;
22773: LD_ADDR_EXP 120
22777: PUSH
22778: EMPTY
22779: ST_TO_ADDR
// mc_is_defending := [ ] ;
22780: LD_ADDR_EXP 121
22784: PUSH
22785: EMPTY
22786: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
22787: LD_ADDR_EXP 112
22791: PUSH
22792: EMPTY
22793: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
22794: LD_ADDR_EXP 122
22798: PUSH
22799: LD_INT 0
22801: ST_TO_ADDR
// end ;
22802: LD_VAR 0 1
22806: RET
// export function MC_Kill ( base ) ; begin
22807: LD_INT 0
22809: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
22810: LD_ADDR_EXP 78
22814: PUSH
22815: LD_EXP 78
22819: PPUSH
22820: LD_VAR 0 1
22824: PPUSH
22825: EMPTY
22826: PPUSH
22827: CALL_OW 1
22831: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22832: LD_ADDR_EXP 79
22836: PUSH
22837: LD_EXP 79
22841: PPUSH
22842: LD_VAR 0 1
22846: PPUSH
22847: EMPTY
22848: PPUSH
22849: CALL_OW 1
22853: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22854: LD_ADDR_EXP 80
22858: PUSH
22859: LD_EXP 80
22863: PPUSH
22864: LD_VAR 0 1
22868: PPUSH
22869: EMPTY
22870: PPUSH
22871: CALL_OW 1
22875: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22876: LD_ADDR_EXP 81
22880: PUSH
22881: LD_EXP 81
22885: PPUSH
22886: LD_VAR 0 1
22890: PPUSH
22891: EMPTY
22892: PPUSH
22893: CALL_OW 1
22897: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22898: LD_ADDR_EXP 82
22902: PUSH
22903: LD_EXP 82
22907: PPUSH
22908: LD_VAR 0 1
22912: PPUSH
22913: EMPTY
22914: PPUSH
22915: CALL_OW 1
22919: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22920: LD_ADDR_EXP 83
22924: PUSH
22925: LD_EXP 83
22929: PPUSH
22930: LD_VAR 0 1
22934: PPUSH
22935: EMPTY
22936: PPUSH
22937: CALL_OW 1
22941: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22942: LD_ADDR_EXP 84
22946: PUSH
22947: LD_EXP 84
22951: PPUSH
22952: LD_VAR 0 1
22956: PPUSH
22957: EMPTY
22958: PPUSH
22959: CALL_OW 1
22963: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22964: LD_ADDR_EXP 85
22968: PUSH
22969: LD_EXP 85
22973: PPUSH
22974: LD_VAR 0 1
22978: PPUSH
22979: EMPTY
22980: PPUSH
22981: CALL_OW 1
22985: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22986: LD_ADDR_EXP 86
22990: PUSH
22991: LD_EXP 86
22995: PPUSH
22996: LD_VAR 0 1
23000: PPUSH
23001: EMPTY
23002: PPUSH
23003: CALL_OW 1
23007: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23008: LD_ADDR_EXP 87
23012: PUSH
23013: LD_EXP 87
23017: PPUSH
23018: LD_VAR 0 1
23022: PPUSH
23023: EMPTY
23024: PPUSH
23025: CALL_OW 1
23029: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23030: LD_ADDR_EXP 88
23034: PUSH
23035: LD_EXP 88
23039: PPUSH
23040: LD_VAR 0 1
23044: PPUSH
23045: EMPTY
23046: PPUSH
23047: CALL_OW 1
23051: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23052: LD_ADDR_EXP 89
23056: PUSH
23057: LD_EXP 89
23061: PPUSH
23062: LD_VAR 0 1
23066: PPUSH
23067: LD_INT 0
23069: PPUSH
23070: CALL_OW 1
23074: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23075: LD_ADDR_EXP 90
23079: PUSH
23080: LD_EXP 90
23084: PPUSH
23085: LD_VAR 0 1
23089: PPUSH
23090: EMPTY
23091: PPUSH
23092: CALL_OW 1
23096: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23097: LD_ADDR_EXP 91
23101: PUSH
23102: LD_EXP 91
23106: PPUSH
23107: LD_VAR 0 1
23111: PPUSH
23112: EMPTY
23113: PPUSH
23114: CALL_OW 1
23118: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23119: LD_ADDR_EXP 92
23123: PUSH
23124: LD_EXP 92
23128: PPUSH
23129: LD_VAR 0 1
23133: PPUSH
23134: EMPTY
23135: PPUSH
23136: CALL_OW 1
23140: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23141: LD_ADDR_EXP 93
23145: PUSH
23146: LD_EXP 93
23150: PPUSH
23151: LD_VAR 0 1
23155: PPUSH
23156: EMPTY
23157: PPUSH
23158: CALL_OW 1
23162: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23163: LD_ADDR_EXP 94
23167: PUSH
23168: LD_EXP 94
23172: PPUSH
23173: LD_VAR 0 1
23177: PPUSH
23178: EMPTY
23179: PPUSH
23180: CALL_OW 1
23184: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23185: LD_ADDR_EXP 95
23189: PUSH
23190: LD_EXP 95
23194: PPUSH
23195: LD_VAR 0 1
23199: PPUSH
23200: EMPTY
23201: PPUSH
23202: CALL_OW 1
23206: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23207: LD_ADDR_EXP 96
23211: PUSH
23212: LD_EXP 96
23216: PPUSH
23217: LD_VAR 0 1
23221: PPUSH
23222: EMPTY
23223: PPUSH
23224: CALL_OW 1
23228: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23229: LD_ADDR_EXP 97
23233: PUSH
23234: LD_EXP 97
23238: PPUSH
23239: LD_VAR 0 1
23243: PPUSH
23244: EMPTY
23245: PPUSH
23246: CALL_OW 1
23250: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23251: LD_ADDR_EXP 98
23255: PUSH
23256: LD_EXP 98
23260: PPUSH
23261: LD_VAR 0 1
23265: PPUSH
23266: EMPTY
23267: PPUSH
23268: CALL_OW 1
23272: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23273: LD_ADDR_EXP 99
23277: PUSH
23278: LD_EXP 99
23282: PPUSH
23283: LD_VAR 0 1
23287: PPUSH
23288: EMPTY
23289: PPUSH
23290: CALL_OW 1
23294: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23295: LD_ADDR_EXP 100
23299: PUSH
23300: LD_EXP 100
23304: PPUSH
23305: LD_VAR 0 1
23309: PPUSH
23310: EMPTY
23311: PPUSH
23312: CALL_OW 1
23316: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23317: LD_ADDR_EXP 101
23321: PUSH
23322: LD_EXP 101
23326: PPUSH
23327: LD_VAR 0 1
23331: PPUSH
23332: EMPTY
23333: PPUSH
23334: CALL_OW 1
23338: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23339: LD_ADDR_EXP 102
23343: PUSH
23344: LD_EXP 102
23348: PPUSH
23349: LD_VAR 0 1
23353: PPUSH
23354: EMPTY
23355: PPUSH
23356: CALL_OW 1
23360: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23361: LD_ADDR_EXP 103
23365: PUSH
23366: LD_EXP 103
23370: PPUSH
23371: LD_VAR 0 1
23375: PPUSH
23376: EMPTY
23377: PPUSH
23378: CALL_OW 1
23382: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23383: LD_ADDR_EXP 105
23387: PUSH
23388: LD_EXP 105
23392: PPUSH
23393: LD_VAR 0 1
23397: PPUSH
23398: EMPTY
23399: PPUSH
23400: CALL_OW 1
23404: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23405: LD_ADDR_EXP 107
23409: PUSH
23410: LD_EXP 107
23414: PPUSH
23415: LD_VAR 0 1
23419: PPUSH
23420: EMPTY
23421: PPUSH
23422: CALL_OW 1
23426: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23427: LD_ADDR_EXP 108
23431: PUSH
23432: LD_EXP 108
23436: PPUSH
23437: LD_VAR 0 1
23441: PPUSH
23442: EMPTY
23443: PPUSH
23444: CALL_OW 1
23448: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23449: LD_ADDR_EXP 109
23453: PUSH
23454: LD_EXP 109
23458: PPUSH
23459: LD_VAR 0 1
23463: PPUSH
23464: EMPTY
23465: PPUSH
23466: CALL_OW 1
23470: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23471: LD_ADDR_EXP 110
23475: PUSH
23476: LD_EXP 110
23480: PPUSH
23481: LD_VAR 0 1
23485: PPUSH
23486: EMPTY
23487: PPUSH
23488: CALL_OW 1
23492: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23493: LD_ADDR_EXP 111
23497: PUSH
23498: LD_EXP 111
23502: PPUSH
23503: LD_VAR 0 1
23507: PPUSH
23508: EMPTY
23509: PPUSH
23510: CALL_OW 1
23514: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23515: LD_ADDR_EXP 112
23519: PUSH
23520: LD_EXP 112
23524: PPUSH
23525: LD_VAR 0 1
23529: PPUSH
23530: EMPTY
23531: PPUSH
23532: CALL_OW 1
23536: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23537: LD_ADDR_EXP 113
23541: PUSH
23542: LD_EXP 113
23546: PPUSH
23547: LD_VAR 0 1
23551: PPUSH
23552: EMPTY
23553: PPUSH
23554: CALL_OW 1
23558: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23559: LD_ADDR_EXP 114
23563: PUSH
23564: LD_EXP 114
23568: PPUSH
23569: LD_VAR 0 1
23573: PPUSH
23574: EMPTY
23575: PPUSH
23576: CALL_OW 1
23580: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23581: LD_ADDR_EXP 115
23585: PUSH
23586: LD_EXP 115
23590: PPUSH
23591: LD_VAR 0 1
23595: PPUSH
23596: EMPTY
23597: PPUSH
23598: CALL_OW 1
23602: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23603: LD_ADDR_EXP 116
23607: PUSH
23608: LD_EXP 116
23612: PPUSH
23613: LD_VAR 0 1
23617: PPUSH
23618: EMPTY
23619: PPUSH
23620: CALL_OW 1
23624: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23625: LD_ADDR_EXP 117
23629: PUSH
23630: LD_EXP 117
23634: PPUSH
23635: LD_VAR 0 1
23639: PPUSH
23640: EMPTY
23641: PPUSH
23642: CALL_OW 1
23646: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23647: LD_ADDR_EXP 118
23651: PUSH
23652: LD_EXP 118
23656: PPUSH
23657: LD_VAR 0 1
23661: PPUSH
23662: EMPTY
23663: PPUSH
23664: CALL_OW 1
23668: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23669: LD_ADDR_EXP 119
23673: PUSH
23674: LD_EXP 119
23678: PPUSH
23679: LD_VAR 0 1
23683: PPUSH
23684: EMPTY
23685: PPUSH
23686: CALL_OW 1
23690: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23691: LD_ADDR_EXP 120
23695: PUSH
23696: LD_EXP 120
23700: PPUSH
23701: LD_VAR 0 1
23705: PPUSH
23706: LD_INT 0
23708: PPUSH
23709: CALL_OW 1
23713: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23714: LD_ADDR_EXP 121
23718: PUSH
23719: LD_EXP 121
23723: PPUSH
23724: LD_VAR 0 1
23728: PPUSH
23729: LD_INT 0
23731: PPUSH
23732: CALL_OW 1
23736: ST_TO_ADDR
// end ;
23737: LD_VAR 0 2
23741: RET
// export function MC_Add ( side , units ) ; var base ; begin
23742: LD_INT 0
23744: PPUSH
23745: PPUSH
// base := mc_bases + 1 ;
23746: LD_ADDR_VAR 0 4
23750: PUSH
23751: LD_EXP 78
23755: PUSH
23756: LD_INT 1
23758: PLUS
23759: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
23760: LD_ADDR_EXP 104
23764: PUSH
23765: LD_EXP 104
23769: PPUSH
23770: LD_VAR 0 4
23774: PPUSH
23775: LD_VAR 0 1
23779: PPUSH
23780: CALL_OW 1
23784: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
23785: LD_ADDR_EXP 78
23789: PUSH
23790: LD_EXP 78
23794: PPUSH
23795: LD_VAR 0 4
23799: PPUSH
23800: LD_VAR 0 2
23804: PPUSH
23805: CALL_OW 1
23809: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23810: LD_ADDR_EXP 79
23814: PUSH
23815: LD_EXP 79
23819: PPUSH
23820: LD_VAR 0 4
23824: PPUSH
23825: EMPTY
23826: PPUSH
23827: CALL_OW 1
23831: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23832: LD_ADDR_EXP 80
23836: PUSH
23837: LD_EXP 80
23841: PPUSH
23842: LD_VAR 0 4
23846: PPUSH
23847: EMPTY
23848: PPUSH
23849: CALL_OW 1
23853: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23854: LD_ADDR_EXP 81
23858: PUSH
23859: LD_EXP 81
23863: PPUSH
23864: LD_VAR 0 4
23868: PPUSH
23869: EMPTY
23870: PPUSH
23871: CALL_OW 1
23875: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23876: LD_ADDR_EXP 82
23880: PUSH
23881: LD_EXP 82
23885: PPUSH
23886: LD_VAR 0 4
23890: PPUSH
23891: EMPTY
23892: PPUSH
23893: CALL_OW 1
23897: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23898: LD_ADDR_EXP 83
23902: PUSH
23903: LD_EXP 83
23907: PPUSH
23908: LD_VAR 0 4
23912: PPUSH
23913: EMPTY
23914: PPUSH
23915: CALL_OW 1
23919: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23920: LD_ADDR_EXP 84
23924: PUSH
23925: LD_EXP 84
23929: PPUSH
23930: LD_VAR 0 4
23934: PPUSH
23935: EMPTY
23936: PPUSH
23937: CALL_OW 1
23941: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23942: LD_ADDR_EXP 85
23946: PUSH
23947: LD_EXP 85
23951: PPUSH
23952: LD_VAR 0 4
23956: PPUSH
23957: EMPTY
23958: PPUSH
23959: CALL_OW 1
23963: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23964: LD_ADDR_EXP 86
23968: PUSH
23969: LD_EXP 86
23973: PPUSH
23974: LD_VAR 0 4
23978: PPUSH
23979: EMPTY
23980: PPUSH
23981: CALL_OW 1
23985: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23986: LD_ADDR_EXP 87
23990: PUSH
23991: LD_EXP 87
23995: PPUSH
23996: LD_VAR 0 4
24000: PPUSH
24001: EMPTY
24002: PPUSH
24003: CALL_OW 1
24007: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
24008: LD_ADDR_EXP 88
24012: PUSH
24013: LD_EXP 88
24017: PPUSH
24018: LD_VAR 0 4
24022: PPUSH
24023: EMPTY
24024: PPUSH
24025: CALL_OW 1
24029: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
24030: LD_ADDR_EXP 89
24034: PUSH
24035: LD_EXP 89
24039: PPUSH
24040: LD_VAR 0 4
24044: PPUSH
24045: LD_INT 0
24047: PPUSH
24048: CALL_OW 1
24052: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
24053: LD_ADDR_EXP 90
24057: PUSH
24058: LD_EXP 90
24062: PPUSH
24063: LD_VAR 0 4
24067: PPUSH
24068: EMPTY
24069: PPUSH
24070: CALL_OW 1
24074: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
24075: LD_ADDR_EXP 91
24079: PUSH
24080: LD_EXP 91
24084: PPUSH
24085: LD_VAR 0 4
24089: PPUSH
24090: EMPTY
24091: PPUSH
24092: CALL_OW 1
24096: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
24097: LD_ADDR_EXP 92
24101: PUSH
24102: LD_EXP 92
24106: PPUSH
24107: LD_VAR 0 4
24111: PPUSH
24112: EMPTY
24113: PPUSH
24114: CALL_OW 1
24118: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
24119: LD_ADDR_EXP 93
24123: PUSH
24124: LD_EXP 93
24128: PPUSH
24129: LD_VAR 0 4
24133: PPUSH
24134: EMPTY
24135: PPUSH
24136: CALL_OW 1
24140: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
24141: LD_ADDR_EXP 94
24145: PUSH
24146: LD_EXP 94
24150: PPUSH
24151: LD_VAR 0 4
24155: PPUSH
24156: EMPTY
24157: PPUSH
24158: CALL_OW 1
24162: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
24163: LD_ADDR_EXP 95
24167: PUSH
24168: LD_EXP 95
24172: PPUSH
24173: LD_VAR 0 4
24177: PPUSH
24178: EMPTY
24179: PPUSH
24180: CALL_OW 1
24184: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
24185: LD_ADDR_EXP 96
24189: PUSH
24190: LD_EXP 96
24194: PPUSH
24195: LD_VAR 0 4
24199: PPUSH
24200: EMPTY
24201: PPUSH
24202: CALL_OW 1
24206: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
24207: LD_ADDR_EXP 97
24211: PUSH
24212: LD_EXP 97
24216: PPUSH
24217: LD_VAR 0 4
24221: PPUSH
24222: EMPTY
24223: PPUSH
24224: CALL_OW 1
24228: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
24229: LD_ADDR_EXP 98
24233: PUSH
24234: LD_EXP 98
24238: PPUSH
24239: LD_VAR 0 4
24243: PPUSH
24244: EMPTY
24245: PPUSH
24246: CALL_OW 1
24250: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
24251: LD_ADDR_EXP 99
24255: PUSH
24256: LD_EXP 99
24260: PPUSH
24261: LD_VAR 0 4
24265: PPUSH
24266: EMPTY
24267: PPUSH
24268: CALL_OW 1
24272: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
24273: LD_ADDR_EXP 100
24277: PUSH
24278: LD_EXP 100
24282: PPUSH
24283: LD_VAR 0 4
24287: PPUSH
24288: EMPTY
24289: PPUSH
24290: CALL_OW 1
24294: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
24295: LD_ADDR_EXP 101
24299: PUSH
24300: LD_EXP 101
24304: PPUSH
24305: LD_VAR 0 4
24309: PPUSH
24310: EMPTY
24311: PPUSH
24312: CALL_OW 1
24316: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
24317: LD_ADDR_EXP 102
24321: PUSH
24322: LD_EXP 102
24326: PPUSH
24327: LD_VAR 0 4
24331: PPUSH
24332: EMPTY
24333: PPUSH
24334: CALL_OW 1
24338: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
24339: LD_ADDR_EXP 103
24343: PUSH
24344: LD_EXP 103
24348: PPUSH
24349: LD_VAR 0 4
24353: PPUSH
24354: EMPTY
24355: PPUSH
24356: CALL_OW 1
24360: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
24361: LD_ADDR_EXP 105
24365: PUSH
24366: LD_EXP 105
24370: PPUSH
24371: LD_VAR 0 4
24375: PPUSH
24376: EMPTY
24377: PPUSH
24378: CALL_OW 1
24382: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
24383: LD_ADDR_EXP 107
24387: PUSH
24388: LD_EXP 107
24392: PPUSH
24393: LD_VAR 0 4
24397: PPUSH
24398: EMPTY
24399: PPUSH
24400: CALL_OW 1
24404: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24405: LD_ADDR_EXP 108
24409: PUSH
24410: LD_EXP 108
24414: PPUSH
24415: LD_VAR 0 4
24419: PPUSH
24420: EMPTY
24421: PPUSH
24422: CALL_OW 1
24426: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24427: LD_ADDR_EXP 109
24431: PUSH
24432: LD_EXP 109
24436: PPUSH
24437: LD_VAR 0 4
24441: PPUSH
24442: EMPTY
24443: PPUSH
24444: CALL_OW 1
24448: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24449: LD_ADDR_EXP 110
24453: PUSH
24454: LD_EXP 110
24458: PPUSH
24459: LD_VAR 0 4
24463: PPUSH
24464: EMPTY
24465: PPUSH
24466: CALL_OW 1
24470: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24471: LD_ADDR_EXP 111
24475: PUSH
24476: LD_EXP 111
24480: PPUSH
24481: LD_VAR 0 4
24485: PPUSH
24486: EMPTY
24487: PPUSH
24488: CALL_OW 1
24492: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24493: LD_ADDR_EXP 112
24497: PUSH
24498: LD_EXP 112
24502: PPUSH
24503: LD_VAR 0 4
24507: PPUSH
24508: EMPTY
24509: PPUSH
24510: CALL_OW 1
24514: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24515: LD_ADDR_EXP 113
24519: PUSH
24520: LD_EXP 113
24524: PPUSH
24525: LD_VAR 0 4
24529: PPUSH
24530: EMPTY
24531: PPUSH
24532: CALL_OW 1
24536: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24537: LD_ADDR_EXP 114
24541: PUSH
24542: LD_EXP 114
24546: PPUSH
24547: LD_VAR 0 4
24551: PPUSH
24552: EMPTY
24553: PPUSH
24554: CALL_OW 1
24558: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24559: LD_ADDR_EXP 115
24563: PUSH
24564: LD_EXP 115
24568: PPUSH
24569: LD_VAR 0 4
24573: PPUSH
24574: EMPTY
24575: PPUSH
24576: CALL_OW 1
24580: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24581: LD_ADDR_EXP 116
24585: PUSH
24586: LD_EXP 116
24590: PPUSH
24591: LD_VAR 0 4
24595: PPUSH
24596: EMPTY
24597: PPUSH
24598: CALL_OW 1
24602: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24603: LD_ADDR_EXP 117
24607: PUSH
24608: LD_EXP 117
24612: PPUSH
24613: LD_VAR 0 4
24617: PPUSH
24618: EMPTY
24619: PPUSH
24620: CALL_OW 1
24624: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24625: LD_ADDR_EXP 118
24629: PUSH
24630: LD_EXP 118
24634: PPUSH
24635: LD_VAR 0 4
24639: PPUSH
24640: EMPTY
24641: PPUSH
24642: CALL_OW 1
24646: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24647: LD_ADDR_EXP 119
24651: PUSH
24652: LD_EXP 119
24656: PPUSH
24657: LD_VAR 0 4
24661: PPUSH
24662: EMPTY
24663: PPUSH
24664: CALL_OW 1
24668: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24669: LD_ADDR_EXP 120
24673: PUSH
24674: LD_EXP 120
24678: PPUSH
24679: LD_VAR 0 4
24683: PPUSH
24684: LD_INT 0
24686: PPUSH
24687: CALL_OW 1
24691: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24692: LD_ADDR_EXP 121
24696: PUSH
24697: LD_EXP 121
24701: PPUSH
24702: LD_VAR 0 4
24706: PPUSH
24707: LD_INT 0
24709: PPUSH
24710: CALL_OW 1
24714: ST_TO_ADDR
// result := base ;
24715: LD_ADDR_VAR 0 3
24719: PUSH
24720: LD_VAR 0 4
24724: ST_TO_ADDR
// end ;
24725: LD_VAR 0 3
24729: RET
// export function MC_Start ( ) ; var i ; begin
24730: LD_INT 0
24732: PPUSH
24733: PPUSH
// for i = 1 to mc_bases do
24734: LD_ADDR_VAR 0 2
24738: PUSH
24739: DOUBLE
24740: LD_INT 1
24742: DEC
24743: ST_TO_ADDR
24744: LD_EXP 78
24748: PUSH
24749: FOR_TO
24750: IFFALSE 25850
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
24752: LD_ADDR_EXP 78
24756: PUSH
24757: LD_EXP 78
24761: PPUSH
24762: LD_VAR 0 2
24766: PPUSH
24767: LD_EXP 78
24771: PUSH
24772: LD_VAR 0 2
24776: ARRAY
24777: PUSH
24778: LD_INT 0
24780: DIFF
24781: PPUSH
24782: CALL_OW 1
24786: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
24787: LD_ADDR_EXP 79
24791: PUSH
24792: LD_EXP 79
24796: PPUSH
24797: LD_VAR 0 2
24801: PPUSH
24802: EMPTY
24803: PPUSH
24804: CALL_OW 1
24808: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
24809: LD_ADDR_EXP 80
24813: PUSH
24814: LD_EXP 80
24818: PPUSH
24819: LD_VAR 0 2
24823: PPUSH
24824: EMPTY
24825: PPUSH
24826: CALL_OW 1
24830: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
24831: LD_ADDR_EXP 81
24835: PUSH
24836: LD_EXP 81
24840: PPUSH
24841: LD_VAR 0 2
24845: PPUSH
24846: EMPTY
24847: PPUSH
24848: CALL_OW 1
24852: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
24853: LD_ADDR_EXP 82
24857: PUSH
24858: LD_EXP 82
24862: PPUSH
24863: LD_VAR 0 2
24867: PPUSH
24868: EMPTY
24869: PUSH
24870: EMPTY
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: PPUSH
24876: CALL_OW 1
24880: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
24881: LD_ADDR_EXP 83
24885: PUSH
24886: LD_EXP 83
24890: PPUSH
24891: LD_VAR 0 2
24895: PPUSH
24896: EMPTY
24897: PPUSH
24898: CALL_OW 1
24902: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
24903: LD_ADDR_EXP 110
24907: PUSH
24908: LD_EXP 110
24912: PPUSH
24913: LD_VAR 0 2
24917: PPUSH
24918: EMPTY
24919: PPUSH
24920: CALL_OW 1
24924: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
24925: LD_ADDR_EXP 84
24929: PUSH
24930: LD_EXP 84
24934: PPUSH
24935: LD_VAR 0 2
24939: PPUSH
24940: EMPTY
24941: PPUSH
24942: CALL_OW 1
24946: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
24947: LD_ADDR_EXP 85
24951: PUSH
24952: LD_EXP 85
24956: PPUSH
24957: LD_VAR 0 2
24961: PPUSH
24962: EMPTY
24963: PPUSH
24964: CALL_OW 1
24968: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
24969: LD_ADDR_EXP 86
24973: PUSH
24974: LD_EXP 86
24978: PPUSH
24979: LD_VAR 0 2
24983: PPUSH
24984: LD_EXP 78
24988: PUSH
24989: LD_VAR 0 2
24993: ARRAY
24994: PPUSH
24995: LD_INT 2
24997: PUSH
24998: LD_INT 30
25000: PUSH
25001: LD_INT 32
25003: PUSH
25004: EMPTY
25005: LIST
25006: LIST
25007: PUSH
25008: LD_INT 30
25010: PUSH
25011: LD_INT 33
25013: PUSH
25014: EMPTY
25015: LIST
25016: LIST
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: LIST
25022: PPUSH
25023: CALL_OW 72
25027: PPUSH
25028: CALL_OW 1
25032: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
25033: LD_ADDR_EXP 87
25037: PUSH
25038: LD_EXP 87
25042: PPUSH
25043: LD_VAR 0 2
25047: PPUSH
25048: LD_EXP 78
25052: PUSH
25053: LD_VAR 0 2
25057: ARRAY
25058: PPUSH
25059: LD_INT 2
25061: PUSH
25062: LD_INT 30
25064: PUSH
25065: LD_INT 32
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PUSH
25072: LD_INT 30
25074: PUSH
25075: LD_INT 31
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: LIST
25086: PUSH
25087: LD_INT 58
25089: PUSH
25090: EMPTY
25091: LIST
25092: PUSH
25093: EMPTY
25094: LIST
25095: LIST
25096: PPUSH
25097: CALL_OW 72
25101: PPUSH
25102: CALL_OW 1
25106: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
25107: LD_ADDR_EXP 88
25111: PUSH
25112: LD_EXP 88
25116: PPUSH
25117: LD_VAR 0 2
25121: PPUSH
25122: EMPTY
25123: PPUSH
25124: CALL_OW 1
25128: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
25129: LD_ADDR_EXP 92
25133: PUSH
25134: LD_EXP 92
25138: PPUSH
25139: LD_VAR 0 2
25143: PPUSH
25144: EMPTY
25145: PPUSH
25146: CALL_OW 1
25150: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
25151: LD_ADDR_EXP 91
25155: PUSH
25156: LD_EXP 91
25160: PPUSH
25161: LD_VAR 0 2
25165: PPUSH
25166: EMPTY
25167: PPUSH
25168: CALL_OW 1
25172: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
25173: LD_ADDR_EXP 93
25177: PUSH
25178: LD_EXP 93
25182: PPUSH
25183: LD_VAR 0 2
25187: PPUSH
25188: EMPTY
25189: PPUSH
25190: CALL_OW 1
25194: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
25195: LD_ADDR_EXP 94
25199: PUSH
25200: LD_EXP 94
25204: PPUSH
25205: LD_VAR 0 2
25209: PPUSH
25210: EMPTY
25211: PPUSH
25212: CALL_OW 1
25216: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
25217: LD_ADDR_EXP 95
25221: PUSH
25222: LD_EXP 95
25226: PPUSH
25227: LD_VAR 0 2
25231: PPUSH
25232: EMPTY
25233: PPUSH
25234: CALL_OW 1
25238: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
25239: LD_ADDR_EXP 96
25243: PUSH
25244: LD_EXP 96
25248: PPUSH
25249: LD_VAR 0 2
25253: PPUSH
25254: EMPTY
25255: PPUSH
25256: CALL_OW 1
25260: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
25261: LD_ADDR_EXP 97
25265: PUSH
25266: LD_EXP 97
25270: PPUSH
25271: LD_VAR 0 2
25275: PPUSH
25276: EMPTY
25277: PPUSH
25278: CALL_OW 1
25282: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
25283: LD_ADDR_EXP 98
25287: PUSH
25288: LD_EXP 98
25292: PPUSH
25293: LD_VAR 0 2
25297: PPUSH
25298: EMPTY
25299: PPUSH
25300: CALL_OW 1
25304: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
25305: LD_ADDR_EXP 99
25309: PUSH
25310: LD_EXP 99
25314: PPUSH
25315: LD_VAR 0 2
25319: PPUSH
25320: EMPTY
25321: PPUSH
25322: CALL_OW 1
25326: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
25327: LD_ADDR_EXP 100
25331: PUSH
25332: LD_EXP 100
25336: PPUSH
25337: LD_VAR 0 2
25341: PPUSH
25342: EMPTY
25343: PPUSH
25344: CALL_OW 1
25348: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
25349: LD_ADDR_EXP 89
25353: PUSH
25354: LD_EXP 89
25358: PPUSH
25359: LD_VAR 0 2
25363: PPUSH
25364: LD_INT 0
25366: PPUSH
25367: CALL_OW 1
25371: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
25372: LD_ADDR_EXP 102
25376: PUSH
25377: LD_EXP 102
25381: PPUSH
25382: LD_VAR 0 2
25386: PPUSH
25387: LD_INT 0
25389: PPUSH
25390: CALL_OW 1
25394: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
25395: LD_ADDR_EXP 90
25399: PUSH
25400: LD_EXP 90
25404: PPUSH
25405: LD_VAR 0 2
25409: PPUSH
25410: EMPTY
25411: PPUSH
25412: CALL_OW 1
25416: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
25417: LD_ADDR_EXP 101
25421: PUSH
25422: LD_EXP 101
25426: PPUSH
25427: LD_VAR 0 2
25431: PPUSH
25432: LD_INT 0
25434: PPUSH
25435: CALL_OW 1
25439: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25440: LD_ADDR_EXP 103
25444: PUSH
25445: LD_EXP 103
25449: PPUSH
25450: LD_VAR 0 2
25454: PPUSH
25455: EMPTY
25456: PPUSH
25457: CALL_OW 1
25461: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25462: LD_ADDR_EXP 106
25466: PUSH
25467: LD_EXP 106
25471: PPUSH
25472: LD_VAR 0 2
25476: PPUSH
25477: LD_INT 0
25479: PPUSH
25480: CALL_OW 1
25484: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25485: LD_ADDR_EXP 107
25489: PUSH
25490: LD_EXP 107
25494: PPUSH
25495: LD_VAR 0 2
25499: PPUSH
25500: EMPTY
25501: PPUSH
25502: CALL_OW 1
25506: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25507: LD_ADDR_EXP 108
25511: PUSH
25512: LD_EXP 108
25516: PPUSH
25517: LD_VAR 0 2
25521: PPUSH
25522: EMPTY
25523: PPUSH
25524: CALL_OW 1
25528: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25529: LD_ADDR_EXP 109
25533: PUSH
25534: LD_EXP 109
25538: PPUSH
25539: LD_VAR 0 2
25543: PPUSH
25544: EMPTY
25545: PPUSH
25546: CALL_OW 1
25550: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
25551: LD_ADDR_EXP 111
25555: PUSH
25556: LD_EXP 111
25560: PPUSH
25561: LD_VAR 0 2
25565: PPUSH
25566: LD_EXP 78
25570: PUSH
25571: LD_VAR 0 2
25575: ARRAY
25576: PPUSH
25577: LD_INT 2
25579: PUSH
25580: LD_INT 30
25582: PUSH
25583: LD_INT 6
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 30
25592: PUSH
25593: LD_INT 7
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: PUSH
25600: LD_INT 30
25602: PUSH
25603: LD_INT 8
25605: PUSH
25606: EMPTY
25607: LIST
25608: LIST
25609: PUSH
25610: EMPTY
25611: LIST
25612: LIST
25613: LIST
25614: LIST
25615: PPUSH
25616: CALL_OW 72
25620: PPUSH
25621: CALL_OW 1
25625: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
25626: LD_ADDR_EXP 112
25630: PUSH
25631: LD_EXP 112
25635: PPUSH
25636: LD_VAR 0 2
25640: PPUSH
25641: EMPTY
25642: PPUSH
25643: CALL_OW 1
25647: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
25648: LD_ADDR_EXP 113
25652: PUSH
25653: LD_EXP 113
25657: PPUSH
25658: LD_VAR 0 2
25662: PPUSH
25663: EMPTY
25664: PPUSH
25665: CALL_OW 1
25669: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
25670: LD_ADDR_EXP 114
25674: PUSH
25675: LD_EXP 114
25679: PPUSH
25680: LD_VAR 0 2
25684: PPUSH
25685: EMPTY
25686: PPUSH
25687: CALL_OW 1
25691: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
25692: LD_ADDR_EXP 115
25696: PUSH
25697: LD_EXP 115
25701: PPUSH
25702: LD_VAR 0 2
25706: PPUSH
25707: EMPTY
25708: PPUSH
25709: CALL_OW 1
25713: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
25714: LD_ADDR_EXP 116
25718: PUSH
25719: LD_EXP 116
25723: PPUSH
25724: LD_VAR 0 2
25728: PPUSH
25729: EMPTY
25730: PPUSH
25731: CALL_OW 1
25735: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
25736: LD_ADDR_EXP 117
25740: PUSH
25741: LD_EXP 117
25745: PPUSH
25746: LD_VAR 0 2
25750: PPUSH
25751: EMPTY
25752: PPUSH
25753: CALL_OW 1
25757: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
25758: LD_ADDR_EXP 118
25762: PUSH
25763: LD_EXP 118
25767: PPUSH
25768: LD_VAR 0 2
25772: PPUSH
25773: EMPTY
25774: PPUSH
25775: CALL_OW 1
25779: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
25780: LD_ADDR_EXP 119
25784: PUSH
25785: LD_EXP 119
25789: PPUSH
25790: LD_VAR 0 2
25794: PPUSH
25795: EMPTY
25796: PPUSH
25797: CALL_OW 1
25801: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
25802: LD_ADDR_EXP 120
25806: PUSH
25807: LD_EXP 120
25811: PPUSH
25812: LD_VAR 0 2
25816: PPUSH
25817: LD_INT 0
25819: PPUSH
25820: CALL_OW 1
25824: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
25825: LD_ADDR_EXP 121
25829: PUSH
25830: LD_EXP 121
25834: PPUSH
25835: LD_VAR 0 2
25839: PPUSH
25840: LD_INT 0
25842: PPUSH
25843: CALL_OW 1
25847: ST_TO_ADDR
// end ;
25848: GO 24749
25850: POP
25851: POP
// MC_InitSides ( ) ;
25852: CALL 26138 0 0
// MC_InitResearch ( ) ;
25856: CALL 25877 0 0
// CustomInitMacro ( ) ;
25860: CALL 228 0 0
// skirmish := true ;
25864: LD_ADDR_EXP 76
25868: PUSH
25869: LD_INT 1
25871: ST_TO_ADDR
// end ;
25872: LD_VAR 0 1
25876: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
25877: LD_INT 0
25879: PPUSH
25880: PPUSH
25881: PPUSH
25882: PPUSH
25883: PPUSH
25884: PPUSH
// if not mc_bases then
25885: LD_EXP 78
25889: NOT
25890: IFFALSE 25894
// exit ;
25892: GO 26133
// for i = 1 to 8 do
25894: LD_ADDR_VAR 0 2
25898: PUSH
25899: DOUBLE
25900: LD_INT 1
25902: DEC
25903: ST_TO_ADDR
25904: LD_INT 8
25906: PUSH
25907: FOR_TO
25908: IFFALSE 25934
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
25910: LD_ADDR_EXP 105
25914: PUSH
25915: LD_EXP 105
25919: PPUSH
25920: LD_VAR 0 2
25924: PPUSH
25925: EMPTY
25926: PPUSH
25927: CALL_OW 1
25931: ST_TO_ADDR
25932: GO 25907
25934: POP
25935: POP
// tmp := [ ] ;
25936: LD_ADDR_VAR 0 5
25940: PUSH
25941: EMPTY
25942: ST_TO_ADDR
// for i = 1 to mc_sides do
25943: LD_ADDR_VAR 0 2
25947: PUSH
25948: DOUBLE
25949: LD_INT 1
25951: DEC
25952: ST_TO_ADDR
25953: LD_EXP 104
25957: PUSH
25958: FOR_TO
25959: IFFALSE 26017
// if not mc_sides [ i ] in tmp then
25961: LD_EXP 104
25965: PUSH
25966: LD_VAR 0 2
25970: ARRAY
25971: PUSH
25972: LD_VAR 0 5
25976: IN
25977: NOT
25978: IFFALSE 26015
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
25980: LD_ADDR_VAR 0 5
25984: PUSH
25985: LD_VAR 0 5
25989: PPUSH
25990: LD_VAR 0 5
25994: PUSH
25995: LD_INT 1
25997: PLUS
25998: PPUSH
25999: LD_EXP 104
26003: PUSH
26004: LD_VAR 0 2
26008: ARRAY
26009: PPUSH
26010: CALL_OW 2
26014: ST_TO_ADDR
26015: GO 25958
26017: POP
26018: POP
// if not tmp then
26019: LD_VAR 0 5
26023: NOT
26024: IFFALSE 26028
// exit ;
26026: GO 26133
// for j in tmp do
26028: LD_ADDR_VAR 0 3
26032: PUSH
26033: LD_VAR 0 5
26037: PUSH
26038: FOR_IN
26039: IFFALSE 26131
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
26041: LD_ADDR_VAR 0 6
26045: PUSH
26046: LD_INT 22
26048: PUSH
26049: LD_VAR 0 3
26053: PUSH
26054: EMPTY
26055: LIST
26056: LIST
26057: PPUSH
26058: CALL_OW 69
26062: ST_TO_ADDR
// if not un then
26063: LD_VAR 0 6
26067: NOT
26068: IFFALSE 26072
// continue ;
26070: GO 26038
// nation := GetNation ( un [ 1 ] ) ;
26072: LD_ADDR_VAR 0 4
26076: PUSH
26077: LD_VAR 0 6
26081: PUSH
26082: LD_INT 1
26084: ARRAY
26085: PPUSH
26086: CALL_OW 248
26090: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
26091: LD_ADDR_EXP 105
26095: PUSH
26096: LD_EXP 105
26100: PPUSH
26101: LD_VAR 0 3
26105: PPUSH
26106: LD_VAR 0 3
26110: PPUSH
26111: LD_VAR 0 4
26115: PPUSH
26116: LD_INT 1
26118: PPUSH
26119: CALL 53321 0 3
26123: PPUSH
26124: CALL_OW 1
26128: ST_TO_ADDR
// end ;
26129: GO 26038
26131: POP
26132: POP
// end ;
26133: LD_VAR 0 1
26137: RET
// export function MC_InitSides ( ) ; var i ; begin
26138: LD_INT 0
26140: PPUSH
26141: PPUSH
// if not mc_bases then
26142: LD_EXP 78
26146: NOT
26147: IFFALSE 26151
// exit ;
26149: GO 26225
// for i = 1 to mc_bases do
26151: LD_ADDR_VAR 0 2
26155: PUSH
26156: DOUBLE
26157: LD_INT 1
26159: DEC
26160: ST_TO_ADDR
26161: LD_EXP 78
26165: PUSH
26166: FOR_TO
26167: IFFALSE 26223
// if mc_bases [ i ] then
26169: LD_EXP 78
26173: PUSH
26174: LD_VAR 0 2
26178: ARRAY
26179: IFFALSE 26221
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
26181: LD_ADDR_EXP 104
26185: PUSH
26186: LD_EXP 104
26190: PPUSH
26191: LD_VAR 0 2
26195: PPUSH
26196: LD_EXP 78
26200: PUSH
26201: LD_VAR 0 2
26205: ARRAY
26206: PUSH
26207: LD_INT 1
26209: ARRAY
26210: PPUSH
26211: CALL_OW 255
26215: PPUSH
26216: CALL_OW 1
26220: ST_TO_ADDR
26221: GO 26166
26223: POP
26224: POP
// end ;
26225: LD_VAR 0 1
26229: RET
// every 0 0$03 trigger skirmish do
26230: LD_EXP 76
26234: IFFALSE 26388
26236: GO 26238
26238: DISABLE
// begin enable ;
26239: ENABLE
// MC_CheckBuildings ( ) ;
26240: CALL 30900 0 0
// MC_CheckPeopleLife ( ) ;
26244: CALL 31061 0 0
// RaiseSailEvent ( 100 ) ;
26248: LD_INT 100
26250: PPUSH
26251: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
26255: LD_INT 103
26257: PPUSH
26258: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
26262: LD_INT 104
26264: PPUSH
26265: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
26269: LD_INT 105
26271: PPUSH
26272: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
26276: LD_INT 106
26278: PPUSH
26279: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
26283: LD_INT 107
26285: PPUSH
26286: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
26290: LD_INT 108
26292: PPUSH
26293: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
26297: LD_INT 109
26299: PPUSH
26300: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
26304: LD_INT 110
26306: PPUSH
26307: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
26311: LD_INT 111
26313: PPUSH
26314: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
26318: LD_INT 112
26320: PPUSH
26321: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
26325: LD_INT 113
26327: PPUSH
26328: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
26332: LD_INT 120
26334: PPUSH
26335: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
26339: LD_INT 121
26341: PPUSH
26342: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
26346: LD_INT 122
26348: PPUSH
26349: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
26353: LD_INT 123
26355: PPUSH
26356: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
26360: LD_INT 124
26362: PPUSH
26363: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
26367: LD_INT 125
26369: PPUSH
26370: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
26374: LD_INT 126
26376: PPUSH
26377: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
26381: LD_INT 200
26383: PPUSH
26384: CALL_OW 427
// end ;
26388: END
// on SailEvent ( event ) do begin if event < 100 then
26389: LD_VAR 0 1
26393: PUSH
26394: LD_INT 100
26396: LESS
26397: IFFALSE 26408
// CustomEvent ( event ) ;
26399: LD_VAR 0 1
26403: PPUSH
26404: CALL 11645 0 1
// if event = 100 then
26408: LD_VAR 0 1
26412: PUSH
26413: LD_INT 100
26415: EQUAL
26416: IFFALSE 26422
// MC_ClassManager ( ) ;
26418: CALL 26814 0 0
// if event = 101 then
26422: LD_VAR 0 1
26426: PUSH
26427: LD_INT 101
26429: EQUAL
26430: IFFALSE 26436
// MC_RepairBuildings ( ) ;
26432: CALL 31646 0 0
// if event = 102 then
26436: LD_VAR 0 1
26440: PUSH
26441: LD_INT 102
26443: EQUAL
26444: IFFALSE 26450
// MC_Heal ( ) ;
26446: CALL 32581 0 0
// if event = 103 then
26450: LD_VAR 0 1
26454: PUSH
26455: LD_INT 103
26457: EQUAL
26458: IFFALSE 26464
// MC_Build ( ) ;
26460: CALL 33003 0 0
// if event = 104 then
26464: LD_VAR 0 1
26468: PUSH
26469: LD_INT 104
26471: EQUAL
26472: IFFALSE 26478
// MC_TurretWeapon ( ) ;
26474: CALL 34637 0 0
// if event = 105 then
26478: LD_VAR 0 1
26482: PUSH
26483: LD_INT 105
26485: EQUAL
26486: IFFALSE 26492
// MC_BuildUpgrade ( ) ;
26488: CALL 34188 0 0
// if event = 106 then
26492: LD_VAR 0 1
26496: PUSH
26497: LD_INT 106
26499: EQUAL
26500: IFFALSE 26506
// MC_PlantMines ( ) ;
26502: CALL 35067 0 0
// if event = 107 then
26506: LD_VAR 0 1
26510: PUSH
26511: LD_INT 107
26513: EQUAL
26514: IFFALSE 26520
// MC_CollectCrates ( ) ;
26516: CALL 35865 0 0
// if event = 108 then
26520: LD_VAR 0 1
26524: PUSH
26525: LD_INT 108
26527: EQUAL
26528: IFFALSE 26534
// MC_LinkRemoteControl ( ) ;
26530: CALL 37715 0 0
// if event = 109 then
26534: LD_VAR 0 1
26538: PUSH
26539: LD_INT 109
26541: EQUAL
26542: IFFALSE 26548
// MC_ProduceVehicle ( ) ;
26544: CALL 37896 0 0
// if event = 110 then
26548: LD_VAR 0 1
26552: PUSH
26553: LD_INT 110
26555: EQUAL
26556: IFFALSE 26562
// MC_SendAttack ( ) ;
26558: CALL 38362 0 0
// if event = 111 then
26562: LD_VAR 0 1
26566: PUSH
26567: LD_INT 111
26569: EQUAL
26570: IFFALSE 26576
// MC_Defend ( ) ;
26572: CALL 38470 0 0
// if event = 112 then
26576: LD_VAR 0 1
26580: PUSH
26581: LD_INT 112
26583: EQUAL
26584: IFFALSE 26590
// MC_Research ( ) ;
26586: CALL 39350 0 0
// if event = 113 then
26590: LD_VAR 0 1
26594: PUSH
26595: LD_INT 113
26597: EQUAL
26598: IFFALSE 26604
// MC_MinesTrigger ( ) ;
26600: CALL 40464 0 0
// if event = 120 then
26604: LD_VAR 0 1
26608: PUSH
26609: LD_INT 120
26611: EQUAL
26612: IFFALSE 26618
// MC_RepairVehicle ( ) ;
26614: CALL 40563 0 0
// if event = 121 then
26618: LD_VAR 0 1
26622: PUSH
26623: LD_INT 121
26625: EQUAL
26626: IFFALSE 26632
// MC_TameApe ( ) ;
26628: CALL 41332 0 0
// if event = 122 then
26632: LD_VAR 0 1
26636: PUSH
26637: LD_INT 122
26639: EQUAL
26640: IFFALSE 26646
// MC_ChangeApeClass ( ) ;
26642: CALL 42161 0 0
// if event = 123 then
26646: LD_VAR 0 1
26650: PUSH
26651: LD_INT 123
26653: EQUAL
26654: IFFALSE 26660
// MC_Bazooka ( ) ;
26656: CALL 42811 0 0
// if event = 124 then
26660: LD_VAR 0 1
26664: PUSH
26665: LD_INT 124
26667: EQUAL
26668: IFFALSE 26674
// MC_TeleportExit ( ) ;
26670: CALL 43009 0 0
// if event = 125 then
26674: LD_VAR 0 1
26678: PUSH
26679: LD_INT 125
26681: EQUAL
26682: IFFALSE 26688
// MC_Deposits ( ) ;
26684: CALL 43656 0 0
// if event = 126 then
26688: LD_VAR 0 1
26692: PUSH
26693: LD_INT 126
26695: EQUAL
26696: IFFALSE 26702
// MC_RemoteDriver ( ) ;
26698: CALL 44281 0 0
// if event = 200 then
26702: LD_VAR 0 1
26706: PUSH
26707: LD_INT 200
26709: EQUAL
26710: IFFALSE 26716
// MC_Idle ( ) ;
26712: CALL 46188 0 0
// end ;
26716: PPOPN 1
26718: END
// export function MC_Reset ( base , tag ) ; var i ; begin
26719: LD_INT 0
26721: PPUSH
26722: PPUSH
// if not mc_bases [ base ] or not tag then
26723: LD_EXP 78
26727: PUSH
26728: LD_VAR 0 1
26732: ARRAY
26733: NOT
26734: PUSH
26735: LD_VAR 0 2
26739: NOT
26740: OR
26741: IFFALSE 26745
// exit ;
26743: GO 26809
// for i in mc_bases [ base ] union mc_ape [ base ] do
26745: LD_ADDR_VAR 0 4
26749: PUSH
26750: LD_EXP 78
26754: PUSH
26755: LD_VAR 0 1
26759: ARRAY
26760: PUSH
26761: LD_EXP 107
26765: PUSH
26766: LD_VAR 0 1
26770: ARRAY
26771: UNION
26772: PUSH
26773: FOR_IN
26774: IFFALSE 26807
// if GetTag ( i ) = tag then
26776: LD_VAR 0 4
26780: PPUSH
26781: CALL_OW 110
26785: PUSH
26786: LD_VAR 0 2
26790: EQUAL
26791: IFFALSE 26805
// SetTag ( i , 0 ) ;
26793: LD_VAR 0 4
26797: PPUSH
26798: LD_INT 0
26800: PPUSH
26801: CALL_OW 109
26805: GO 26773
26807: POP
26808: POP
// end ;
26809: LD_VAR 0 3
26813: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
26814: LD_INT 0
26816: PPUSH
26817: PPUSH
26818: PPUSH
26819: PPUSH
26820: PPUSH
26821: PPUSH
26822: PPUSH
26823: PPUSH
// if not mc_bases then
26824: LD_EXP 78
26828: NOT
26829: IFFALSE 26833
// exit ;
26831: GO 27282
// for i = 1 to mc_bases do
26833: LD_ADDR_VAR 0 2
26837: PUSH
26838: DOUBLE
26839: LD_INT 1
26841: DEC
26842: ST_TO_ADDR
26843: LD_EXP 78
26847: PUSH
26848: FOR_TO
26849: IFFALSE 27280
// begin tmp := MC_ClassCheckReq ( i ) ;
26851: LD_ADDR_VAR 0 4
26855: PUSH
26856: LD_VAR 0 2
26860: PPUSH
26861: CALL 27287 0 1
26865: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
26866: LD_ADDR_EXP 119
26870: PUSH
26871: LD_EXP 119
26875: PPUSH
26876: LD_VAR 0 2
26880: PPUSH
26881: LD_VAR 0 4
26885: PPUSH
26886: CALL_OW 1
26890: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
26891: LD_ADDR_VAR 0 6
26895: PUSH
26896: LD_EXP 78
26900: PUSH
26901: LD_VAR 0 2
26905: ARRAY
26906: PPUSH
26907: LD_INT 2
26909: PUSH
26910: LD_INT 30
26912: PUSH
26913: LD_INT 4
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: PUSH
26920: LD_INT 30
26922: PUSH
26923: LD_INT 5
26925: PUSH
26926: EMPTY
26927: LIST
26928: LIST
26929: PUSH
26930: EMPTY
26931: LIST
26932: LIST
26933: LIST
26934: PPUSH
26935: CALL_OW 72
26939: PUSH
26940: LD_EXP 78
26944: PUSH
26945: LD_VAR 0 2
26949: ARRAY
26950: PPUSH
26951: LD_INT 2
26953: PUSH
26954: LD_INT 30
26956: PUSH
26957: LD_INT 0
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: PUSH
26964: LD_INT 30
26966: PUSH
26967: LD_INT 1
26969: PUSH
26970: EMPTY
26971: LIST
26972: LIST
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: LIST
26978: PPUSH
26979: CALL_OW 72
26983: PUSH
26984: LD_EXP 78
26988: PUSH
26989: LD_VAR 0 2
26993: ARRAY
26994: PPUSH
26995: LD_INT 30
26997: PUSH
26998: LD_INT 3
27000: PUSH
27001: EMPTY
27002: LIST
27003: LIST
27004: PPUSH
27005: CALL_OW 72
27009: PUSH
27010: LD_EXP 78
27014: PUSH
27015: LD_VAR 0 2
27019: ARRAY
27020: PPUSH
27021: LD_INT 2
27023: PUSH
27024: LD_INT 30
27026: PUSH
27027: LD_INT 6
27029: PUSH
27030: EMPTY
27031: LIST
27032: LIST
27033: PUSH
27034: LD_INT 30
27036: PUSH
27037: LD_INT 7
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: PUSH
27044: LD_INT 30
27046: PUSH
27047: LD_INT 8
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: EMPTY
27055: LIST
27056: LIST
27057: LIST
27058: LIST
27059: PPUSH
27060: CALL_OW 72
27064: PUSH
27065: EMPTY
27066: LIST
27067: LIST
27068: LIST
27069: LIST
27070: ST_TO_ADDR
// for j := 1 to 4 do
27071: LD_ADDR_VAR 0 3
27075: PUSH
27076: DOUBLE
27077: LD_INT 1
27079: DEC
27080: ST_TO_ADDR
27081: LD_INT 4
27083: PUSH
27084: FOR_TO
27085: IFFALSE 27276
// begin if not tmp [ j ] then
27087: LD_VAR 0 4
27091: PUSH
27092: LD_VAR 0 3
27096: ARRAY
27097: NOT
27098: IFFALSE 27102
// continue ;
27100: GO 27084
// for p in tmp [ j ] do
27102: LD_ADDR_VAR 0 5
27106: PUSH
27107: LD_VAR 0 4
27111: PUSH
27112: LD_VAR 0 3
27116: ARRAY
27117: PUSH
27118: FOR_IN
27119: IFFALSE 27272
// begin if not b [ j ] then
27121: LD_VAR 0 6
27125: PUSH
27126: LD_VAR 0 3
27130: ARRAY
27131: NOT
27132: IFFALSE 27136
// break ;
27134: GO 27272
// e := 0 ;
27136: LD_ADDR_VAR 0 7
27140: PUSH
27141: LD_INT 0
27143: ST_TO_ADDR
// for k in b [ j ] do
27144: LD_ADDR_VAR 0 8
27148: PUSH
27149: LD_VAR 0 6
27153: PUSH
27154: LD_VAR 0 3
27158: ARRAY
27159: PUSH
27160: FOR_IN
27161: IFFALSE 27188
// if IsNotFull ( k ) then
27163: LD_VAR 0 8
27167: PPUSH
27168: CALL 55442 0 1
27172: IFFALSE 27186
// begin e := k ;
27174: LD_ADDR_VAR 0 7
27178: PUSH
27179: LD_VAR 0 8
27183: ST_TO_ADDR
// break ;
27184: GO 27188
// end ;
27186: GO 27160
27188: POP
27189: POP
// if e and not UnitGoingToBuilding ( p , e ) then
27190: LD_VAR 0 7
27194: PUSH
27195: LD_VAR 0 5
27199: PPUSH
27200: LD_VAR 0 7
27204: PPUSH
27205: CALL 89592 0 2
27209: NOT
27210: AND
27211: IFFALSE 27270
// begin if IsInUnit ( p ) then
27213: LD_VAR 0 5
27217: PPUSH
27218: CALL_OW 310
27222: IFFALSE 27233
// ComExitBuilding ( p ) ;
27224: LD_VAR 0 5
27228: PPUSH
27229: CALL_OW 122
// ComEnterUnit ( p , e ) ;
27233: LD_VAR 0 5
27237: PPUSH
27238: LD_VAR 0 7
27242: PPUSH
27243: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
27247: LD_VAR 0 5
27251: PPUSH
27252: LD_VAR 0 3
27256: PPUSH
27257: CALL_OW 183
// AddComExitBuilding ( p ) ;
27261: LD_VAR 0 5
27265: PPUSH
27266: CALL_OW 182
// end ; end ;
27270: GO 27118
27272: POP
27273: POP
// end ;
27274: GO 27084
27276: POP
27277: POP
// end ;
27278: GO 26848
27280: POP
27281: POP
// end ;
27282: LD_VAR 0 1
27286: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
27287: LD_INT 0
27289: PPUSH
27290: PPUSH
27291: PPUSH
27292: PPUSH
27293: PPUSH
27294: PPUSH
27295: PPUSH
27296: PPUSH
27297: PPUSH
27298: PPUSH
27299: PPUSH
27300: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
27301: LD_ADDR_VAR 0 2
27305: PUSH
27306: LD_INT 0
27308: PUSH
27309: LD_INT 0
27311: PUSH
27312: LD_INT 0
27314: PUSH
27315: LD_INT 0
27317: PUSH
27318: EMPTY
27319: LIST
27320: LIST
27321: LIST
27322: LIST
27323: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
27324: LD_VAR 0 1
27328: NOT
27329: PUSH
27330: LD_EXP 78
27334: PUSH
27335: LD_VAR 0 1
27339: ARRAY
27340: NOT
27341: OR
27342: PUSH
27343: LD_EXP 78
27347: PUSH
27348: LD_VAR 0 1
27352: ARRAY
27353: PPUSH
27354: LD_INT 2
27356: PUSH
27357: LD_INT 30
27359: PUSH
27360: LD_INT 0
27362: PUSH
27363: EMPTY
27364: LIST
27365: LIST
27366: PUSH
27367: LD_INT 30
27369: PUSH
27370: LD_INT 1
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: LIST
27381: PPUSH
27382: CALL_OW 72
27386: NOT
27387: OR
27388: IFFALSE 27392
// exit ;
27390: GO 30895
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27392: LD_ADDR_VAR 0 4
27396: PUSH
27397: LD_EXP 78
27401: PUSH
27402: LD_VAR 0 1
27406: ARRAY
27407: PPUSH
27408: LD_INT 2
27410: PUSH
27411: LD_INT 25
27413: PUSH
27414: LD_INT 1
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 25
27423: PUSH
27424: LD_INT 2
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: PUSH
27431: LD_INT 25
27433: PUSH
27434: LD_INT 3
27436: PUSH
27437: EMPTY
27438: LIST
27439: LIST
27440: PUSH
27441: LD_INT 25
27443: PUSH
27444: LD_INT 4
27446: PUSH
27447: EMPTY
27448: LIST
27449: LIST
27450: PUSH
27451: LD_INT 25
27453: PUSH
27454: LD_INT 5
27456: PUSH
27457: EMPTY
27458: LIST
27459: LIST
27460: PUSH
27461: LD_INT 25
27463: PUSH
27464: LD_INT 8
27466: PUSH
27467: EMPTY
27468: LIST
27469: LIST
27470: PUSH
27471: LD_INT 25
27473: PUSH
27474: LD_INT 9
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: LIST
27485: LIST
27486: LIST
27487: LIST
27488: LIST
27489: LIST
27490: PPUSH
27491: CALL_OW 72
27495: ST_TO_ADDR
// if not tmp then
27496: LD_VAR 0 4
27500: NOT
27501: IFFALSE 27505
// exit ;
27503: GO 30895
// for i in tmp do
27505: LD_ADDR_VAR 0 3
27509: PUSH
27510: LD_VAR 0 4
27514: PUSH
27515: FOR_IN
27516: IFFALSE 27547
// if GetTag ( i ) then
27518: LD_VAR 0 3
27522: PPUSH
27523: CALL_OW 110
27527: IFFALSE 27545
// tmp := tmp diff i ;
27529: LD_ADDR_VAR 0 4
27533: PUSH
27534: LD_VAR 0 4
27538: PUSH
27539: LD_VAR 0 3
27543: DIFF
27544: ST_TO_ADDR
27545: GO 27515
27547: POP
27548: POP
// if not tmp then
27549: LD_VAR 0 4
27553: NOT
27554: IFFALSE 27558
// exit ;
27556: GO 30895
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27558: LD_ADDR_VAR 0 5
27562: PUSH
27563: LD_EXP 78
27567: PUSH
27568: LD_VAR 0 1
27572: ARRAY
27573: PPUSH
27574: LD_INT 2
27576: PUSH
27577: LD_INT 25
27579: PUSH
27580: LD_INT 1
27582: PUSH
27583: EMPTY
27584: LIST
27585: LIST
27586: PUSH
27587: LD_INT 25
27589: PUSH
27590: LD_INT 5
27592: PUSH
27593: EMPTY
27594: LIST
27595: LIST
27596: PUSH
27597: LD_INT 25
27599: PUSH
27600: LD_INT 8
27602: PUSH
27603: EMPTY
27604: LIST
27605: LIST
27606: PUSH
27607: LD_INT 25
27609: PUSH
27610: LD_INT 9
27612: PUSH
27613: EMPTY
27614: LIST
27615: LIST
27616: PUSH
27617: EMPTY
27618: LIST
27619: LIST
27620: LIST
27621: LIST
27622: LIST
27623: PPUSH
27624: CALL_OW 72
27628: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
27629: LD_ADDR_VAR 0 6
27633: PUSH
27634: LD_EXP 78
27638: PUSH
27639: LD_VAR 0 1
27643: ARRAY
27644: PPUSH
27645: LD_INT 25
27647: PUSH
27648: LD_INT 2
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PPUSH
27655: CALL_OW 72
27659: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
27660: LD_ADDR_VAR 0 7
27664: PUSH
27665: LD_EXP 78
27669: PUSH
27670: LD_VAR 0 1
27674: ARRAY
27675: PPUSH
27676: LD_INT 25
27678: PUSH
27679: LD_INT 3
27681: PUSH
27682: EMPTY
27683: LIST
27684: LIST
27685: PPUSH
27686: CALL_OW 72
27690: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
27691: LD_ADDR_VAR 0 8
27695: PUSH
27696: LD_EXP 78
27700: PUSH
27701: LD_VAR 0 1
27705: ARRAY
27706: PPUSH
27707: LD_INT 25
27709: PUSH
27710: LD_INT 4
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PUSH
27717: LD_INT 24
27719: PUSH
27720: LD_INT 251
27722: PUSH
27723: EMPTY
27724: LIST
27725: LIST
27726: PUSH
27727: EMPTY
27728: LIST
27729: LIST
27730: PPUSH
27731: CALL_OW 72
27735: ST_TO_ADDR
// if mc_is_defending [ base ] then
27736: LD_EXP 121
27740: PUSH
27741: LD_VAR 0 1
27745: ARRAY
27746: IFFALSE 28207
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
27748: LD_ADDR_EXP 120
27752: PUSH
27753: LD_EXP 120
27757: PPUSH
27758: LD_VAR 0 1
27762: PPUSH
27763: LD_INT 4
27765: PPUSH
27766: CALL_OW 1
27770: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
27771: LD_ADDR_VAR 0 12
27775: PUSH
27776: LD_EXP 78
27780: PUSH
27781: LD_VAR 0 1
27785: ARRAY
27786: PPUSH
27787: LD_INT 2
27789: PUSH
27790: LD_INT 30
27792: PUSH
27793: LD_INT 4
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 30
27802: PUSH
27803: LD_INT 5
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: LIST
27814: PPUSH
27815: CALL_OW 72
27819: ST_TO_ADDR
// if not b then
27820: LD_VAR 0 12
27824: NOT
27825: IFFALSE 27829
// exit ;
27827: GO 30895
// p := [ ] ;
27829: LD_ADDR_VAR 0 11
27833: PUSH
27834: EMPTY
27835: ST_TO_ADDR
// if sci >= 2 then
27836: LD_VAR 0 8
27840: PUSH
27841: LD_INT 2
27843: GREATEREQUAL
27844: IFFALSE 27875
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
27846: LD_ADDR_VAR 0 8
27850: PUSH
27851: LD_VAR 0 8
27855: PUSH
27856: LD_INT 1
27858: ARRAY
27859: PUSH
27860: LD_VAR 0 8
27864: PUSH
27865: LD_INT 2
27867: ARRAY
27868: PUSH
27869: EMPTY
27870: LIST
27871: LIST
27872: ST_TO_ADDR
27873: GO 27936
// if sci = 1 then
27875: LD_VAR 0 8
27879: PUSH
27880: LD_INT 1
27882: EQUAL
27883: IFFALSE 27904
// sci := [ sci [ 1 ] ] else
27885: LD_ADDR_VAR 0 8
27889: PUSH
27890: LD_VAR 0 8
27894: PUSH
27895: LD_INT 1
27897: ARRAY
27898: PUSH
27899: EMPTY
27900: LIST
27901: ST_TO_ADDR
27902: GO 27936
// if sci = 0 then
27904: LD_VAR 0 8
27908: PUSH
27909: LD_INT 0
27911: EQUAL
27912: IFFALSE 27936
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
27914: LD_ADDR_VAR 0 11
27918: PUSH
27919: LD_VAR 0 4
27923: PPUSH
27924: LD_INT 4
27926: PPUSH
27927: CALL 89464 0 2
27931: PUSH
27932: LD_INT 1
27934: ARRAY
27935: ST_TO_ADDR
// if eng > 4 then
27936: LD_VAR 0 6
27940: PUSH
27941: LD_INT 4
27943: GREATER
27944: IFFALSE 27990
// for i = eng downto 4 do
27946: LD_ADDR_VAR 0 3
27950: PUSH
27951: DOUBLE
27952: LD_VAR 0 6
27956: INC
27957: ST_TO_ADDR
27958: LD_INT 4
27960: PUSH
27961: FOR_DOWNTO
27962: IFFALSE 27988
// eng := eng diff eng [ i ] ;
27964: LD_ADDR_VAR 0 6
27968: PUSH
27969: LD_VAR 0 6
27973: PUSH
27974: LD_VAR 0 6
27978: PUSH
27979: LD_VAR 0 3
27983: ARRAY
27984: DIFF
27985: ST_TO_ADDR
27986: GO 27961
27988: POP
27989: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
27990: LD_ADDR_VAR 0 4
27994: PUSH
27995: LD_VAR 0 4
27999: PUSH
28000: LD_VAR 0 5
28004: PUSH
28005: LD_VAR 0 6
28009: UNION
28010: PUSH
28011: LD_VAR 0 7
28015: UNION
28016: PUSH
28017: LD_VAR 0 8
28021: UNION
28022: DIFF
28023: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
28024: LD_ADDR_VAR 0 13
28028: PUSH
28029: LD_EXP 78
28033: PUSH
28034: LD_VAR 0 1
28038: ARRAY
28039: PPUSH
28040: LD_INT 2
28042: PUSH
28043: LD_INT 30
28045: PUSH
28046: LD_INT 32
28048: PUSH
28049: EMPTY
28050: LIST
28051: LIST
28052: PUSH
28053: LD_INT 30
28055: PUSH
28056: LD_INT 31
28058: PUSH
28059: EMPTY
28060: LIST
28061: LIST
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: LIST
28067: PPUSH
28068: CALL_OW 72
28072: PUSH
28073: LD_EXP 78
28077: PUSH
28078: LD_VAR 0 1
28082: ARRAY
28083: PPUSH
28084: LD_INT 2
28086: PUSH
28087: LD_INT 30
28089: PUSH
28090: LD_INT 4
28092: PUSH
28093: EMPTY
28094: LIST
28095: LIST
28096: PUSH
28097: LD_INT 30
28099: PUSH
28100: LD_INT 5
28102: PUSH
28103: EMPTY
28104: LIST
28105: LIST
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: LIST
28111: PPUSH
28112: CALL_OW 72
28116: PUSH
28117: LD_INT 6
28119: MUL
28120: PLUS
28121: ST_TO_ADDR
// if bcount < tmp then
28122: LD_VAR 0 13
28126: PUSH
28127: LD_VAR 0 4
28131: LESS
28132: IFFALSE 28178
// for i = tmp downto bcount do
28134: LD_ADDR_VAR 0 3
28138: PUSH
28139: DOUBLE
28140: LD_VAR 0 4
28144: INC
28145: ST_TO_ADDR
28146: LD_VAR 0 13
28150: PUSH
28151: FOR_DOWNTO
28152: IFFALSE 28176
// tmp := Delete ( tmp , tmp ) ;
28154: LD_ADDR_VAR 0 4
28158: PUSH
28159: LD_VAR 0 4
28163: PPUSH
28164: LD_VAR 0 4
28168: PPUSH
28169: CALL_OW 3
28173: ST_TO_ADDR
28174: GO 28151
28176: POP
28177: POP
// result := [ tmp , 0 , 0 , p ] ;
28178: LD_ADDR_VAR 0 2
28182: PUSH
28183: LD_VAR 0 4
28187: PUSH
28188: LD_INT 0
28190: PUSH
28191: LD_INT 0
28193: PUSH
28194: LD_VAR 0 11
28198: PUSH
28199: EMPTY
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: ST_TO_ADDR
// exit ;
28205: GO 30895
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28207: LD_EXP 78
28211: PUSH
28212: LD_VAR 0 1
28216: ARRAY
28217: PPUSH
28218: LD_INT 2
28220: PUSH
28221: LD_INT 30
28223: PUSH
28224: LD_INT 6
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: LD_INT 30
28233: PUSH
28234: LD_INT 7
28236: PUSH
28237: EMPTY
28238: LIST
28239: LIST
28240: PUSH
28241: LD_INT 30
28243: PUSH
28244: LD_INT 8
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: EMPTY
28252: LIST
28253: LIST
28254: LIST
28255: LIST
28256: PPUSH
28257: CALL_OW 72
28261: NOT
28262: PUSH
28263: LD_EXP 78
28267: PUSH
28268: LD_VAR 0 1
28272: ARRAY
28273: PPUSH
28274: LD_INT 30
28276: PUSH
28277: LD_INT 3
28279: PUSH
28280: EMPTY
28281: LIST
28282: LIST
28283: PPUSH
28284: CALL_OW 72
28288: NOT
28289: AND
28290: IFFALSE 28362
// begin if eng = tmp then
28292: LD_VAR 0 6
28296: PUSH
28297: LD_VAR 0 4
28301: EQUAL
28302: IFFALSE 28306
// exit ;
28304: GO 30895
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
28306: LD_ADDR_EXP 120
28310: PUSH
28311: LD_EXP 120
28315: PPUSH
28316: LD_VAR 0 1
28320: PPUSH
28321: LD_INT 1
28323: PPUSH
28324: CALL_OW 1
28328: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
28329: LD_ADDR_VAR 0 2
28333: PUSH
28334: LD_INT 0
28336: PUSH
28337: LD_VAR 0 4
28341: PUSH
28342: LD_VAR 0 6
28346: DIFF
28347: PUSH
28348: LD_INT 0
28350: PUSH
28351: LD_INT 0
28353: PUSH
28354: EMPTY
28355: LIST
28356: LIST
28357: LIST
28358: LIST
28359: ST_TO_ADDR
// exit ;
28360: GO 30895
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28362: LD_EXP 105
28366: PUSH
28367: LD_EXP 104
28371: PUSH
28372: LD_VAR 0 1
28376: ARRAY
28377: ARRAY
28378: PUSH
28379: LD_EXP 78
28383: PUSH
28384: LD_VAR 0 1
28388: ARRAY
28389: PPUSH
28390: LD_INT 2
28392: PUSH
28393: LD_INT 30
28395: PUSH
28396: LD_INT 6
28398: PUSH
28399: EMPTY
28400: LIST
28401: LIST
28402: PUSH
28403: LD_INT 30
28405: PUSH
28406: LD_INT 7
28408: PUSH
28409: EMPTY
28410: LIST
28411: LIST
28412: PUSH
28413: LD_INT 30
28415: PUSH
28416: LD_INT 8
28418: PUSH
28419: EMPTY
28420: LIST
28421: LIST
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: LIST
28427: LIST
28428: PPUSH
28429: CALL_OW 72
28433: AND
28434: PUSH
28435: LD_EXP 78
28439: PUSH
28440: LD_VAR 0 1
28444: ARRAY
28445: PPUSH
28446: LD_INT 30
28448: PUSH
28449: LD_INT 3
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PPUSH
28456: CALL_OW 72
28460: NOT
28461: AND
28462: IFFALSE 28676
// begin if sci >= 6 then
28464: LD_VAR 0 8
28468: PUSH
28469: LD_INT 6
28471: GREATEREQUAL
28472: IFFALSE 28476
// exit ;
28474: GO 30895
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28476: LD_ADDR_EXP 120
28480: PUSH
28481: LD_EXP 120
28485: PPUSH
28486: LD_VAR 0 1
28490: PPUSH
28491: LD_INT 2
28493: PPUSH
28494: CALL_OW 1
28498: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28499: LD_ADDR_VAR 0 9
28503: PUSH
28504: LD_VAR 0 4
28508: PUSH
28509: LD_VAR 0 8
28513: DIFF
28514: PPUSH
28515: LD_INT 4
28517: PPUSH
28518: CALL 89464 0 2
28522: ST_TO_ADDR
// p := [ ] ;
28523: LD_ADDR_VAR 0 11
28527: PUSH
28528: EMPTY
28529: ST_TO_ADDR
// if sci < 6 and sort > 6 then
28530: LD_VAR 0 8
28534: PUSH
28535: LD_INT 6
28537: LESS
28538: PUSH
28539: LD_VAR 0 9
28543: PUSH
28544: LD_INT 6
28546: GREATER
28547: AND
28548: IFFALSE 28629
// begin for i = 1 to 6 - sci do
28550: LD_ADDR_VAR 0 3
28554: PUSH
28555: DOUBLE
28556: LD_INT 1
28558: DEC
28559: ST_TO_ADDR
28560: LD_INT 6
28562: PUSH
28563: LD_VAR 0 8
28567: MINUS
28568: PUSH
28569: FOR_TO
28570: IFFALSE 28625
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
28572: LD_ADDR_VAR 0 11
28576: PUSH
28577: LD_VAR 0 11
28581: PPUSH
28582: LD_VAR 0 11
28586: PUSH
28587: LD_INT 1
28589: PLUS
28590: PPUSH
28591: LD_VAR 0 9
28595: PUSH
28596: LD_INT 1
28598: ARRAY
28599: PPUSH
28600: CALL_OW 2
28604: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
28605: LD_ADDR_VAR 0 9
28609: PUSH
28610: LD_VAR 0 9
28614: PPUSH
28615: LD_INT 1
28617: PPUSH
28618: CALL_OW 3
28622: ST_TO_ADDR
// end ;
28623: GO 28569
28625: POP
28626: POP
// end else
28627: GO 28649
// if sort then
28629: LD_VAR 0 9
28633: IFFALSE 28649
// p := sort [ 1 ] ;
28635: LD_ADDR_VAR 0 11
28639: PUSH
28640: LD_VAR 0 9
28644: PUSH
28645: LD_INT 1
28647: ARRAY
28648: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
28649: LD_ADDR_VAR 0 2
28653: PUSH
28654: LD_INT 0
28656: PUSH
28657: LD_INT 0
28659: PUSH
28660: LD_INT 0
28662: PUSH
28663: LD_VAR 0 11
28667: PUSH
28668: EMPTY
28669: LIST
28670: LIST
28671: LIST
28672: LIST
28673: ST_TO_ADDR
// exit ;
28674: GO 30895
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28676: LD_EXP 105
28680: PUSH
28681: LD_EXP 104
28685: PUSH
28686: LD_VAR 0 1
28690: ARRAY
28691: ARRAY
28692: PUSH
28693: LD_EXP 78
28697: PUSH
28698: LD_VAR 0 1
28702: ARRAY
28703: PPUSH
28704: LD_INT 2
28706: PUSH
28707: LD_INT 30
28709: PUSH
28710: LD_INT 6
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: PUSH
28717: LD_INT 30
28719: PUSH
28720: LD_INT 7
28722: PUSH
28723: EMPTY
28724: LIST
28725: LIST
28726: PUSH
28727: LD_INT 30
28729: PUSH
28730: LD_INT 8
28732: PUSH
28733: EMPTY
28734: LIST
28735: LIST
28736: PUSH
28737: EMPTY
28738: LIST
28739: LIST
28740: LIST
28741: LIST
28742: PPUSH
28743: CALL_OW 72
28747: AND
28748: PUSH
28749: LD_EXP 78
28753: PUSH
28754: LD_VAR 0 1
28758: ARRAY
28759: PPUSH
28760: LD_INT 30
28762: PUSH
28763: LD_INT 3
28765: PUSH
28766: EMPTY
28767: LIST
28768: LIST
28769: PPUSH
28770: CALL_OW 72
28774: AND
28775: IFFALSE 29509
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
28777: LD_ADDR_EXP 120
28781: PUSH
28782: LD_EXP 120
28786: PPUSH
28787: LD_VAR 0 1
28791: PPUSH
28792: LD_INT 3
28794: PPUSH
28795: CALL_OW 1
28799: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28800: LD_ADDR_VAR 0 2
28804: PUSH
28805: LD_INT 0
28807: PUSH
28808: LD_INT 0
28810: PUSH
28811: LD_INT 0
28813: PUSH
28814: LD_INT 0
28816: PUSH
28817: EMPTY
28818: LIST
28819: LIST
28820: LIST
28821: LIST
28822: ST_TO_ADDR
// if not eng then
28823: LD_VAR 0 6
28827: NOT
28828: IFFALSE 28891
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
28830: LD_ADDR_VAR 0 11
28834: PUSH
28835: LD_VAR 0 4
28839: PPUSH
28840: LD_INT 2
28842: PPUSH
28843: CALL 89464 0 2
28847: PUSH
28848: LD_INT 1
28850: ARRAY
28851: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
28852: LD_ADDR_VAR 0 2
28856: PUSH
28857: LD_VAR 0 2
28861: PPUSH
28862: LD_INT 2
28864: PPUSH
28865: LD_VAR 0 11
28869: PPUSH
28870: CALL_OW 1
28874: ST_TO_ADDR
// tmp := tmp diff p ;
28875: LD_ADDR_VAR 0 4
28879: PUSH
28880: LD_VAR 0 4
28884: PUSH
28885: LD_VAR 0 11
28889: DIFF
28890: ST_TO_ADDR
// end ; if tmp and sci < 6 then
28891: LD_VAR 0 4
28895: PUSH
28896: LD_VAR 0 8
28900: PUSH
28901: LD_INT 6
28903: LESS
28904: AND
28905: IFFALSE 29093
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
28907: LD_ADDR_VAR 0 9
28911: PUSH
28912: LD_VAR 0 4
28916: PUSH
28917: LD_VAR 0 8
28921: PUSH
28922: LD_VAR 0 7
28926: UNION
28927: DIFF
28928: PPUSH
28929: LD_INT 4
28931: PPUSH
28932: CALL 89464 0 2
28936: ST_TO_ADDR
// p := [ ] ;
28937: LD_ADDR_VAR 0 11
28941: PUSH
28942: EMPTY
28943: ST_TO_ADDR
// if sort then
28944: LD_VAR 0 9
28948: IFFALSE 29064
// for i = 1 to 6 - sci do
28950: LD_ADDR_VAR 0 3
28954: PUSH
28955: DOUBLE
28956: LD_INT 1
28958: DEC
28959: ST_TO_ADDR
28960: LD_INT 6
28962: PUSH
28963: LD_VAR 0 8
28967: MINUS
28968: PUSH
28969: FOR_TO
28970: IFFALSE 29062
// begin if i = sort then
28972: LD_VAR 0 3
28976: PUSH
28977: LD_VAR 0 9
28981: EQUAL
28982: IFFALSE 28986
// break ;
28984: GO 29062
// if GetClass ( i ) = 4 then
28986: LD_VAR 0 3
28990: PPUSH
28991: CALL_OW 257
28995: PUSH
28996: LD_INT 4
28998: EQUAL
28999: IFFALSE 29003
// continue ;
29001: GO 28969
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29003: LD_ADDR_VAR 0 11
29007: PUSH
29008: LD_VAR 0 11
29012: PPUSH
29013: LD_VAR 0 11
29017: PUSH
29018: LD_INT 1
29020: PLUS
29021: PPUSH
29022: LD_VAR 0 9
29026: PUSH
29027: LD_VAR 0 3
29031: ARRAY
29032: PPUSH
29033: CALL_OW 2
29037: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29038: LD_ADDR_VAR 0 4
29042: PUSH
29043: LD_VAR 0 4
29047: PUSH
29048: LD_VAR 0 9
29052: PUSH
29053: LD_VAR 0 3
29057: ARRAY
29058: DIFF
29059: ST_TO_ADDR
// end ;
29060: GO 28969
29062: POP
29063: POP
// if p then
29064: LD_VAR 0 11
29068: IFFALSE 29093
// result := Replace ( result , 4 , p ) ;
29070: LD_ADDR_VAR 0 2
29074: PUSH
29075: LD_VAR 0 2
29079: PPUSH
29080: LD_INT 4
29082: PPUSH
29083: LD_VAR 0 11
29087: PPUSH
29088: CALL_OW 1
29092: ST_TO_ADDR
// end ; if tmp and mech < 6 then
29093: LD_VAR 0 4
29097: PUSH
29098: LD_VAR 0 7
29102: PUSH
29103: LD_INT 6
29105: LESS
29106: AND
29107: IFFALSE 29295
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29109: LD_ADDR_VAR 0 9
29113: PUSH
29114: LD_VAR 0 4
29118: PUSH
29119: LD_VAR 0 8
29123: PUSH
29124: LD_VAR 0 7
29128: UNION
29129: DIFF
29130: PPUSH
29131: LD_INT 3
29133: PPUSH
29134: CALL 89464 0 2
29138: ST_TO_ADDR
// p := [ ] ;
29139: LD_ADDR_VAR 0 11
29143: PUSH
29144: EMPTY
29145: ST_TO_ADDR
// if sort then
29146: LD_VAR 0 9
29150: IFFALSE 29266
// for i = 1 to 6 - mech do
29152: LD_ADDR_VAR 0 3
29156: PUSH
29157: DOUBLE
29158: LD_INT 1
29160: DEC
29161: ST_TO_ADDR
29162: LD_INT 6
29164: PUSH
29165: LD_VAR 0 7
29169: MINUS
29170: PUSH
29171: FOR_TO
29172: IFFALSE 29264
// begin if i = sort then
29174: LD_VAR 0 3
29178: PUSH
29179: LD_VAR 0 9
29183: EQUAL
29184: IFFALSE 29188
// break ;
29186: GO 29264
// if GetClass ( i ) = 3 then
29188: LD_VAR 0 3
29192: PPUSH
29193: CALL_OW 257
29197: PUSH
29198: LD_INT 3
29200: EQUAL
29201: IFFALSE 29205
// continue ;
29203: GO 29171
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29205: LD_ADDR_VAR 0 11
29209: PUSH
29210: LD_VAR 0 11
29214: PPUSH
29215: LD_VAR 0 11
29219: PUSH
29220: LD_INT 1
29222: PLUS
29223: PPUSH
29224: LD_VAR 0 9
29228: PUSH
29229: LD_VAR 0 3
29233: ARRAY
29234: PPUSH
29235: CALL_OW 2
29239: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29240: LD_ADDR_VAR 0 4
29244: PUSH
29245: LD_VAR 0 4
29249: PUSH
29250: LD_VAR 0 9
29254: PUSH
29255: LD_VAR 0 3
29259: ARRAY
29260: DIFF
29261: ST_TO_ADDR
// end ;
29262: GO 29171
29264: POP
29265: POP
// if p then
29266: LD_VAR 0 11
29270: IFFALSE 29295
// result := Replace ( result , 3 , p ) ;
29272: LD_ADDR_VAR 0 2
29276: PUSH
29277: LD_VAR 0 2
29281: PPUSH
29282: LD_INT 3
29284: PPUSH
29285: LD_VAR 0 11
29289: PPUSH
29290: CALL_OW 1
29294: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
29295: LD_VAR 0 4
29299: PUSH
29300: LD_INT 6
29302: GREATER
29303: PUSH
29304: LD_VAR 0 6
29308: PUSH
29309: LD_INT 6
29311: LESS
29312: AND
29313: IFFALSE 29507
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29315: LD_ADDR_VAR 0 9
29319: PUSH
29320: LD_VAR 0 4
29324: PUSH
29325: LD_VAR 0 8
29329: PUSH
29330: LD_VAR 0 7
29334: UNION
29335: PUSH
29336: LD_VAR 0 6
29340: UNION
29341: DIFF
29342: PPUSH
29343: LD_INT 2
29345: PPUSH
29346: CALL 89464 0 2
29350: ST_TO_ADDR
// p := [ ] ;
29351: LD_ADDR_VAR 0 11
29355: PUSH
29356: EMPTY
29357: ST_TO_ADDR
// if sort then
29358: LD_VAR 0 9
29362: IFFALSE 29478
// for i = 1 to 6 - eng do
29364: LD_ADDR_VAR 0 3
29368: PUSH
29369: DOUBLE
29370: LD_INT 1
29372: DEC
29373: ST_TO_ADDR
29374: LD_INT 6
29376: PUSH
29377: LD_VAR 0 6
29381: MINUS
29382: PUSH
29383: FOR_TO
29384: IFFALSE 29476
// begin if i = sort then
29386: LD_VAR 0 3
29390: PUSH
29391: LD_VAR 0 9
29395: EQUAL
29396: IFFALSE 29400
// break ;
29398: GO 29476
// if GetClass ( i ) = 2 then
29400: LD_VAR 0 3
29404: PPUSH
29405: CALL_OW 257
29409: PUSH
29410: LD_INT 2
29412: EQUAL
29413: IFFALSE 29417
// continue ;
29415: GO 29383
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29417: LD_ADDR_VAR 0 11
29421: PUSH
29422: LD_VAR 0 11
29426: PPUSH
29427: LD_VAR 0 11
29431: PUSH
29432: LD_INT 1
29434: PLUS
29435: PPUSH
29436: LD_VAR 0 9
29440: PUSH
29441: LD_VAR 0 3
29445: ARRAY
29446: PPUSH
29447: CALL_OW 2
29451: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29452: LD_ADDR_VAR 0 4
29456: PUSH
29457: LD_VAR 0 4
29461: PUSH
29462: LD_VAR 0 9
29466: PUSH
29467: LD_VAR 0 3
29471: ARRAY
29472: DIFF
29473: ST_TO_ADDR
// end ;
29474: GO 29383
29476: POP
29477: POP
// if p then
29478: LD_VAR 0 11
29482: IFFALSE 29507
// result := Replace ( result , 2 , p ) ;
29484: LD_ADDR_VAR 0 2
29488: PUSH
29489: LD_VAR 0 2
29493: PPUSH
29494: LD_INT 2
29496: PPUSH
29497: LD_VAR 0 11
29501: PPUSH
29502: CALL_OW 1
29506: ST_TO_ADDR
// end ; exit ;
29507: GO 30895
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29509: LD_EXP 105
29513: PUSH
29514: LD_EXP 104
29518: PUSH
29519: LD_VAR 0 1
29523: ARRAY
29524: ARRAY
29525: NOT
29526: PUSH
29527: LD_EXP 78
29531: PUSH
29532: LD_VAR 0 1
29536: ARRAY
29537: PPUSH
29538: LD_INT 30
29540: PUSH
29541: LD_INT 3
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PPUSH
29548: CALL_OW 72
29552: AND
29553: PUSH
29554: LD_EXP 83
29558: PUSH
29559: LD_VAR 0 1
29563: ARRAY
29564: AND
29565: IFFALSE 30173
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
29567: LD_ADDR_EXP 120
29571: PUSH
29572: LD_EXP 120
29576: PPUSH
29577: LD_VAR 0 1
29581: PPUSH
29582: LD_INT 5
29584: PPUSH
29585: CALL_OW 1
29589: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29590: LD_ADDR_VAR 0 2
29594: PUSH
29595: LD_INT 0
29597: PUSH
29598: LD_INT 0
29600: PUSH
29601: LD_INT 0
29603: PUSH
29604: LD_INT 0
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: ST_TO_ADDR
// if sci > 1 then
29613: LD_VAR 0 8
29617: PUSH
29618: LD_INT 1
29620: GREATER
29621: IFFALSE 29649
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
29623: LD_ADDR_VAR 0 4
29627: PUSH
29628: LD_VAR 0 4
29632: PUSH
29633: LD_VAR 0 8
29637: PUSH
29638: LD_VAR 0 8
29642: PUSH
29643: LD_INT 1
29645: ARRAY
29646: DIFF
29647: DIFF
29648: ST_TO_ADDR
// if tmp and not sci then
29649: LD_VAR 0 4
29653: PUSH
29654: LD_VAR 0 8
29658: NOT
29659: AND
29660: IFFALSE 29729
// begin sort := SortBySkill ( tmp , 4 ) ;
29662: LD_ADDR_VAR 0 9
29666: PUSH
29667: LD_VAR 0 4
29671: PPUSH
29672: LD_INT 4
29674: PPUSH
29675: CALL 89464 0 2
29679: ST_TO_ADDR
// if sort then
29680: LD_VAR 0 9
29684: IFFALSE 29700
// p := sort [ 1 ] ;
29686: LD_ADDR_VAR 0 11
29690: PUSH
29691: LD_VAR 0 9
29695: PUSH
29696: LD_INT 1
29698: ARRAY
29699: ST_TO_ADDR
// if p then
29700: LD_VAR 0 11
29704: IFFALSE 29729
// result := Replace ( result , 4 , p ) ;
29706: LD_ADDR_VAR 0 2
29710: PUSH
29711: LD_VAR 0 2
29715: PPUSH
29716: LD_INT 4
29718: PPUSH
29719: LD_VAR 0 11
29723: PPUSH
29724: CALL_OW 1
29728: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29729: LD_ADDR_VAR 0 4
29733: PUSH
29734: LD_VAR 0 4
29738: PUSH
29739: LD_VAR 0 7
29743: DIFF
29744: ST_TO_ADDR
// if tmp and mech < 6 then
29745: LD_VAR 0 4
29749: PUSH
29750: LD_VAR 0 7
29754: PUSH
29755: LD_INT 6
29757: LESS
29758: AND
29759: IFFALSE 29947
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29761: LD_ADDR_VAR 0 9
29765: PUSH
29766: LD_VAR 0 4
29770: PUSH
29771: LD_VAR 0 8
29775: PUSH
29776: LD_VAR 0 7
29780: UNION
29781: DIFF
29782: PPUSH
29783: LD_INT 3
29785: PPUSH
29786: CALL 89464 0 2
29790: ST_TO_ADDR
// p := [ ] ;
29791: LD_ADDR_VAR 0 11
29795: PUSH
29796: EMPTY
29797: ST_TO_ADDR
// if sort then
29798: LD_VAR 0 9
29802: IFFALSE 29918
// for i = 1 to 6 - mech do
29804: LD_ADDR_VAR 0 3
29808: PUSH
29809: DOUBLE
29810: LD_INT 1
29812: DEC
29813: ST_TO_ADDR
29814: LD_INT 6
29816: PUSH
29817: LD_VAR 0 7
29821: MINUS
29822: PUSH
29823: FOR_TO
29824: IFFALSE 29916
// begin if i = sort then
29826: LD_VAR 0 3
29830: PUSH
29831: LD_VAR 0 9
29835: EQUAL
29836: IFFALSE 29840
// break ;
29838: GO 29916
// if GetClass ( i ) = 3 then
29840: LD_VAR 0 3
29844: PPUSH
29845: CALL_OW 257
29849: PUSH
29850: LD_INT 3
29852: EQUAL
29853: IFFALSE 29857
// continue ;
29855: GO 29823
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29857: LD_ADDR_VAR 0 11
29861: PUSH
29862: LD_VAR 0 11
29866: PPUSH
29867: LD_VAR 0 11
29871: PUSH
29872: LD_INT 1
29874: PLUS
29875: PPUSH
29876: LD_VAR 0 9
29880: PUSH
29881: LD_VAR 0 3
29885: ARRAY
29886: PPUSH
29887: CALL_OW 2
29891: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29892: LD_ADDR_VAR 0 4
29896: PUSH
29897: LD_VAR 0 4
29901: PUSH
29902: LD_VAR 0 9
29906: PUSH
29907: LD_VAR 0 3
29911: ARRAY
29912: DIFF
29913: ST_TO_ADDR
// end ;
29914: GO 29823
29916: POP
29917: POP
// if p then
29918: LD_VAR 0 11
29922: IFFALSE 29947
// result := Replace ( result , 3 , p ) ;
29924: LD_ADDR_VAR 0 2
29928: PUSH
29929: LD_VAR 0 2
29933: PPUSH
29934: LD_INT 3
29936: PPUSH
29937: LD_VAR 0 11
29941: PPUSH
29942: CALL_OW 1
29946: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29947: LD_ADDR_VAR 0 4
29951: PUSH
29952: LD_VAR 0 4
29956: PUSH
29957: LD_VAR 0 6
29961: DIFF
29962: ST_TO_ADDR
// if tmp and eng < 6 then
29963: LD_VAR 0 4
29967: PUSH
29968: LD_VAR 0 6
29972: PUSH
29973: LD_INT 6
29975: LESS
29976: AND
29977: IFFALSE 30171
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29979: LD_ADDR_VAR 0 9
29983: PUSH
29984: LD_VAR 0 4
29988: PUSH
29989: LD_VAR 0 8
29993: PUSH
29994: LD_VAR 0 7
29998: UNION
29999: PUSH
30000: LD_VAR 0 6
30004: UNION
30005: DIFF
30006: PPUSH
30007: LD_INT 2
30009: PPUSH
30010: CALL 89464 0 2
30014: ST_TO_ADDR
// p := [ ] ;
30015: LD_ADDR_VAR 0 11
30019: PUSH
30020: EMPTY
30021: ST_TO_ADDR
// if sort then
30022: LD_VAR 0 9
30026: IFFALSE 30142
// for i = 1 to 6 - eng do
30028: LD_ADDR_VAR 0 3
30032: PUSH
30033: DOUBLE
30034: LD_INT 1
30036: DEC
30037: ST_TO_ADDR
30038: LD_INT 6
30040: PUSH
30041: LD_VAR 0 6
30045: MINUS
30046: PUSH
30047: FOR_TO
30048: IFFALSE 30140
// begin if i = sort then
30050: LD_VAR 0 3
30054: PUSH
30055: LD_VAR 0 9
30059: EQUAL
30060: IFFALSE 30064
// break ;
30062: GO 30140
// if GetClass ( i ) = 2 then
30064: LD_VAR 0 3
30068: PPUSH
30069: CALL_OW 257
30073: PUSH
30074: LD_INT 2
30076: EQUAL
30077: IFFALSE 30081
// continue ;
30079: GO 30047
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30081: LD_ADDR_VAR 0 11
30085: PUSH
30086: LD_VAR 0 11
30090: PPUSH
30091: LD_VAR 0 11
30095: PUSH
30096: LD_INT 1
30098: PLUS
30099: PPUSH
30100: LD_VAR 0 9
30104: PUSH
30105: LD_VAR 0 3
30109: ARRAY
30110: PPUSH
30111: CALL_OW 2
30115: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30116: LD_ADDR_VAR 0 4
30120: PUSH
30121: LD_VAR 0 4
30125: PUSH
30126: LD_VAR 0 9
30130: PUSH
30131: LD_VAR 0 3
30135: ARRAY
30136: DIFF
30137: ST_TO_ADDR
// end ;
30138: GO 30047
30140: POP
30141: POP
// if p then
30142: LD_VAR 0 11
30146: IFFALSE 30171
// result := Replace ( result , 2 , p ) ;
30148: LD_ADDR_VAR 0 2
30152: PUSH
30153: LD_VAR 0 2
30157: PPUSH
30158: LD_INT 2
30160: PPUSH
30161: LD_VAR 0 11
30165: PPUSH
30166: CALL_OW 1
30170: ST_TO_ADDR
// end ; exit ;
30171: GO 30895
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
30173: LD_EXP 105
30177: PUSH
30178: LD_EXP 104
30182: PUSH
30183: LD_VAR 0 1
30187: ARRAY
30188: ARRAY
30189: NOT
30190: PUSH
30191: LD_EXP 78
30195: PUSH
30196: LD_VAR 0 1
30200: ARRAY
30201: PPUSH
30202: LD_INT 30
30204: PUSH
30205: LD_INT 3
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PPUSH
30212: CALL_OW 72
30216: AND
30217: PUSH
30218: LD_EXP 83
30222: PUSH
30223: LD_VAR 0 1
30227: ARRAY
30228: NOT
30229: AND
30230: IFFALSE 30895
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
30232: LD_ADDR_EXP 120
30236: PUSH
30237: LD_EXP 120
30241: PPUSH
30242: LD_VAR 0 1
30246: PPUSH
30247: LD_INT 6
30249: PPUSH
30250: CALL_OW 1
30254: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
30255: LD_ADDR_VAR 0 2
30259: PUSH
30260: LD_INT 0
30262: PUSH
30263: LD_INT 0
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: LD_INT 0
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: LIST
30276: LIST
30277: ST_TO_ADDR
// if sci >= 1 then
30278: LD_VAR 0 8
30282: PUSH
30283: LD_INT 1
30285: GREATEREQUAL
30286: IFFALSE 30308
// tmp := tmp diff sci [ 1 ] ;
30288: LD_ADDR_VAR 0 4
30292: PUSH
30293: LD_VAR 0 4
30297: PUSH
30298: LD_VAR 0 8
30302: PUSH
30303: LD_INT 1
30305: ARRAY
30306: DIFF
30307: ST_TO_ADDR
// if tmp and not sci then
30308: LD_VAR 0 4
30312: PUSH
30313: LD_VAR 0 8
30317: NOT
30318: AND
30319: IFFALSE 30388
// begin sort := SortBySkill ( tmp , 4 ) ;
30321: LD_ADDR_VAR 0 9
30325: PUSH
30326: LD_VAR 0 4
30330: PPUSH
30331: LD_INT 4
30333: PPUSH
30334: CALL 89464 0 2
30338: ST_TO_ADDR
// if sort then
30339: LD_VAR 0 9
30343: IFFALSE 30359
// p := sort [ 1 ] ;
30345: LD_ADDR_VAR 0 11
30349: PUSH
30350: LD_VAR 0 9
30354: PUSH
30355: LD_INT 1
30357: ARRAY
30358: ST_TO_ADDR
// if p then
30359: LD_VAR 0 11
30363: IFFALSE 30388
// result := Replace ( result , 4 , p ) ;
30365: LD_ADDR_VAR 0 2
30369: PUSH
30370: LD_VAR 0 2
30374: PPUSH
30375: LD_INT 4
30377: PPUSH
30378: LD_VAR 0 11
30382: PPUSH
30383: CALL_OW 1
30387: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30388: LD_ADDR_VAR 0 4
30392: PUSH
30393: LD_VAR 0 4
30397: PUSH
30398: LD_VAR 0 7
30402: DIFF
30403: ST_TO_ADDR
// if tmp and mech < 6 then
30404: LD_VAR 0 4
30408: PUSH
30409: LD_VAR 0 7
30413: PUSH
30414: LD_INT 6
30416: LESS
30417: AND
30418: IFFALSE 30600
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
30420: LD_ADDR_VAR 0 9
30424: PUSH
30425: LD_VAR 0 4
30429: PUSH
30430: LD_VAR 0 7
30434: DIFF
30435: PPUSH
30436: LD_INT 3
30438: PPUSH
30439: CALL 89464 0 2
30443: ST_TO_ADDR
// p := [ ] ;
30444: LD_ADDR_VAR 0 11
30448: PUSH
30449: EMPTY
30450: ST_TO_ADDR
// if sort then
30451: LD_VAR 0 9
30455: IFFALSE 30571
// for i = 1 to 6 - mech do
30457: LD_ADDR_VAR 0 3
30461: PUSH
30462: DOUBLE
30463: LD_INT 1
30465: DEC
30466: ST_TO_ADDR
30467: LD_INT 6
30469: PUSH
30470: LD_VAR 0 7
30474: MINUS
30475: PUSH
30476: FOR_TO
30477: IFFALSE 30569
// begin if i = sort then
30479: LD_VAR 0 3
30483: PUSH
30484: LD_VAR 0 9
30488: EQUAL
30489: IFFALSE 30493
// break ;
30491: GO 30569
// if GetClass ( i ) = 3 then
30493: LD_VAR 0 3
30497: PPUSH
30498: CALL_OW 257
30502: PUSH
30503: LD_INT 3
30505: EQUAL
30506: IFFALSE 30510
// continue ;
30508: GO 30476
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30510: LD_ADDR_VAR 0 11
30514: PUSH
30515: LD_VAR 0 11
30519: PPUSH
30520: LD_VAR 0 11
30524: PUSH
30525: LD_INT 1
30527: PLUS
30528: PPUSH
30529: LD_VAR 0 9
30533: PUSH
30534: LD_VAR 0 3
30538: ARRAY
30539: PPUSH
30540: CALL_OW 2
30544: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30545: LD_ADDR_VAR 0 4
30549: PUSH
30550: LD_VAR 0 4
30554: PUSH
30555: LD_VAR 0 9
30559: PUSH
30560: LD_VAR 0 3
30564: ARRAY
30565: DIFF
30566: ST_TO_ADDR
// end ;
30567: GO 30476
30569: POP
30570: POP
// if p then
30571: LD_VAR 0 11
30575: IFFALSE 30600
// result := Replace ( result , 3 , p ) ;
30577: LD_ADDR_VAR 0 2
30581: PUSH
30582: LD_VAR 0 2
30586: PPUSH
30587: LD_INT 3
30589: PPUSH
30590: LD_VAR 0 11
30594: PPUSH
30595: CALL_OW 1
30599: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30600: LD_ADDR_VAR 0 4
30604: PUSH
30605: LD_VAR 0 4
30609: PUSH
30610: LD_VAR 0 6
30614: DIFF
30615: ST_TO_ADDR
// if tmp and eng < 4 then
30616: LD_VAR 0 4
30620: PUSH
30621: LD_VAR 0 6
30625: PUSH
30626: LD_INT 4
30628: LESS
30629: AND
30630: IFFALSE 30820
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
30632: LD_ADDR_VAR 0 9
30636: PUSH
30637: LD_VAR 0 4
30641: PUSH
30642: LD_VAR 0 7
30646: PUSH
30647: LD_VAR 0 6
30651: UNION
30652: DIFF
30653: PPUSH
30654: LD_INT 2
30656: PPUSH
30657: CALL 89464 0 2
30661: ST_TO_ADDR
// p := [ ] ;
30662: LD_ADDR_VAR 0 11
30666: PUSH
30667: EMPTY
30668: ST_TO_ADDR
// if sort then
30669: LD_VAR 0 9
30673: IFFALSE 30789
// for i = 1 to 4 - eng do
30675: LD_ADDR_VAR 0 3
30679: PUSH
30680: DOUBLE
30681: LD_INT 1
30683: DEC
30684: ST_TO_ADDR
30685: LD_INT 4
30687: PUSH
30688: LD_VAR 0 6
30692: MINUS
30693: PUSH
30694: FOR_TO
30695: IFFALSE 30787
// begin if i = sort then
30697: LD_VAR 0 3
30701: PUSH
30702: LD_VAR 0 9
30706: EQUAL
30707: IFFALSE 30711
// break ;
30709: GO 30787
// if GetClass ( i ) = 2 then
30711: LD_VAR 0 3
30715: PPUSH
30716: CALL_OW 257
30720: PUSH
30721: LD_INT 2
30723: EQUAL
30724: IFFALSE 30728
// continue ;
30726: GO 30694
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30728: LD_ADDR_VAR 0 11
30732: PUSH
30733: LD_VAR 0 11
30737: PPUSH
30738: LD_VAR 0 11
30742: PUSH
30743: LD_INT 1
30745: PLUS
30746: PPUSH
30747: LD_VAR 0 9
30751: PUSH
30752: LD_VAR 0 3
30756: ARRAY
30757: PPUSH
30758: CALL_OW 2
30762: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30763: LD_ADDR_VAR 0 4
30767: PUSH
30768: LD_VAR 0 4
30772: PUSH
30773: LD_VAR 0 9
30777: PUSH
30778: LD_VAR 0 3
30782: ARRAY
30783: DIFF
30784: ST_TO_ADDR
// end ;
30785: GO 30694
30787: POP
30788: POP
// if p then
30789: LD_VAR 0 11
30793: IFFALSE 30818
// result := Replace ( result , 2 , p ) ;
30795: LD_ADDR_VAR 0 2
30799: PUSH
30800: LD_VAR 0 2
30804: PPUSH
30805: LD_INT 2
30807: PPUSH
30808: LD_VAR 0 11
30812: PPUSH
30813: CALL_OW 1
30817: ST_TO_ADDR
// end else
30818: GO 30864
// for i = eng downto 5 do
30820: LD_ADDR_VAR 0 3
30824: PUSH
30825: DOUBLE
30826: LD_VAR 0 6
30830: INC
30831: ST_TO_ADDR
30832: LD_INT 5
30834: PUSH
30835: FOR_DOWNTO
30836: IFFALSE 30862
// tmp := tmp union eng [ i ] ;
30838: LD_ADDR_VAR 0 4
30842: PUSH
30843: LD_VAR 0 4
30847: PUSH
30848: LD_VAR 0 6
30852: PUSH
30853: LD_VAR 0 3
30857: ARRAY
30858: UNION
30859: ST_TO_ADDR
30860: GO 30835
30862: POP
30863: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
30864: LD_ADDR_VAR 0 2
30868: PUSH
30869: LD_VAR 0 2
30873: PPUSH
30874: LD_INT 1
30876: PPUSH
30877: LD_VAR 0 4
30881: PUSH
30882: LD_VAR 0 5
30886: DIFF
30887: PPUSH
30888: CALL_OW 1
30892: ST_TO_ADDR
// exit ;
30893: GO 30895
// end ; end ;
30895: LD_VAR 0 2
30899: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
30900: LD_INT 0
30902: PPUSH
30903: PPUSH
30904: PPUSH
// if not mc_bases then
30905: LD_EXP 78
30909: NOT
30910: IFFALSE 30914
// exit ;
30912: GO 31056
// for i = 1 to mc_bases do
30914: LD_ADDR_VAR 0 2
30918: PUSH
30919: DOUBLE
30920: LD_INT 1
30922: DEC
30923: ST_TO_ADDR
30924: LD_EXP 78
30928: PUSH
30929: FOR_TO
30930: IFFALSE 31047
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
30932: LD_ADDR_VAR 0 3
30936: PUSH
30937: LD_EXP 78
30941: PUSH
30942: LD_VAR 0 2
30946: ARRAY
30947: PPUSH
30948: LD_INT 21
30950: PUSH
30951: LD_INT 3
30953: PUSH
30954: EMPTY
30955: LIST
30956: LIST
30957: PUSH
30958: LD_INT 3
30960: PUSH
30961: LD_INT 2
30963: PUSH
30964: LD_INT 30
30966: PUSH
30967: LD_INT 29
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PUSH
30974: LD_INT 30
30976: PUSH
30977: LD_INT 30
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: EMPTY
30985: LIST
30986: LIST
30987: LIST
30988: PUSH
30989: EMPTY
30990: LIST
30991: LIST
30992: PUSH
30993: LD_INT 3
30995: PUSH
30996: LD_INT 24
30998: PUSH
30999: LD_INT 1000
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: EMPTY
31011: LIST
31012: LIST
31013: LIST
31014: PPUSH
31015: CALL_OW 72
31019: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
31020: LD_ADDR_EXP 79
31024: PUSH
31025: LD_EXP 79
31029: PPUSH
31030: LD_VAR 0 2
31034: PPUSH
31035: LD_VAR 0 3
31039: PPUSH
31040: CALL_OW 1
31044: ST_TO_ADDR
// end ;
31045: GO 30929
31047: POP
31048: POP
// RaiseSailEvent ( 101 ) ;
31049: LD_INT 101
31051: PPUSH
31052: CALL_OW 427
// end ;
31056: LD_VAR 0 1
31060: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
31061: LD_INT 0
31063: PPUSH
31064: PPUSH
31065: PPUSH
31066: PPUSH
31067: PPUSH
31068: PPUSH
31069: PPUSH
// if not mc_bases then
31070: LD_EXP 78
31074: NOT
31075: IFFALSE 31079
// exit ;
31077: GO 31641
// for i = 1 to mc_bases do
31079: LD_ADDR_VAR 0 2
31083: PUSH
31084: DOUBLE
31085: LD_INT 1
31087: DEC
31088: ST_TO_ADDR
31089: LD_EXP 78
31093: PUSH
31094: FOR_TO
31095: IFFALSE 31632
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
31097: LD_ADDR_VAR 0 5
31101: PUSH
31102: LD_EXP 78
31106: PUSH
31107: LD_VAR 0 2
31111: ARRAY
31112: PUSH
31113: LD_EXP 107
31117: PUSH
31118: LD_VAR 0 2
31122: ARRAY
31123: UNION
31124: PPUSH
31125: LD_INT 21
31127: PUSH
31128: LD_INT 1
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: PUSH
31135: LD_INT 1
31137: PUSH
31138: LD_INT 3
31140: PUSH
31141: LD_INT 54
31143: PUSH
31144: EMPTY
31145: LIST
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 3
31153: PUSH
31154: LD_INT 24
31156: PUSH
31157: LD_INT 1000
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: LIST
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: PPUSH
31177: CALL_OW 72
31181: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
31182: LD_ADDR_VAR 0 6
31186: PUSH
31187: LD_EXP 78
31191: PUSH
31192: LD_VAR 0 2
31196: ARRAY
31197: PPUSH
31198: LD_INT 21
31200: PUSH
31201: LD_INT 1
31203: PUSH
31204: EMPTY
31205: LIST
31206: LIST
31207: PUSH
31208: LD_INT 1
31210: PUSH
31211: LD_INT 3
31213: PUSH
31214: LD_INT 54
31216: PUSH
31217: EMPTY
31218: LIST
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 3
31226: PUSH
31227: LD_INT 24
31229: PUSH
31230: LD_INT 250
31232: PUSH
31233: EMPTY
31234: LIST
31235: LIST
31236: PUSH
31237: EMPTY
31238: LIST
31239: LIST
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: LIST
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PPUSH
31250: CALL_OW 72
31254: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
31255: LD_ADDR_VAR 0 7
31259: PUSH
31260: LD_VAR 0 5
31264: PUSH
31265: LD_VAR 0 6
31269: DIFF
31270: ST_TO_ADDR
// if not need_heal_1 then
31271: LD_VAR 0 6
31275: NOT
31276: IFFALSE 31309
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
31278: LD_ADDR_EXP 81
31282: PUSH
31283: LD_EXP 81
31287: PPUSH
31288: LD_VAR 0 2
31292: PUSH
31293: LD_INT 1
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PPUSH
31300: EMPTY
31301: PPUSH
31302: CALL 58220 0 3
31306: ST_TO_ADDR
31307: GO 31379
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
31309: LD_ADDR_EXP 81
31313: PUSH
31314: LD_EXP 81
31318: PPUSH
31319: LD_VAR 0 2
31323: PUSH
31324: LD_INT 1
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PPUSH
31331: LD_EXP 81
31335: PUSH
31336: LD_VAR 0 2
31340: ARRAY
31341: PUSH
31342: LD_INT 1
31344: ARRAY
31345: PPUSH
31346: LD_INT 3
31348: PUSH
31349: LD_INT 24
31351: PUSH
31352: LD_INT 1000
31354: PUSH
31355: EMPTY
31356: LIST
31357: LIST
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PPUSH
31363: CALL_OW 72
31367: PUSH
31368: LD_VAR 0 6
31372: UNION
31373: PPUSH
31374: CALL 58220 0 3
31378: ST_TO_ADDR
// if not need_heal_2 then
31379: LD_VAR 0 7
31383: NOT
31384: IFFALSE 31417
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
31386: LD_ADDR_EXP 81
31390: PUSH
31391: LD_EXP 81
31395: PPUSH
31396: LD_VAR 0 2
31400: PUSH
31401: LD_INT 2
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PPUSH
31408: EMPTY
31409: PPUSH
31410: CALL 58220 0 3
31414: ST_TO_ADDR
31415: GO 31449
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
31417: LD_ADDR_EXP 81
31421: PUSH
31422: LD_EXP 81
31426: PPUSH
31427: LD_VAR 0 2
31431: PUSH
31432: LD_INT 2
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: PPUSH
31439: LD_VAR 0 7
31443: PPUSH
31444: CALL 58220 0 3
31448: ST_TO_ADDR
// if need_heal_2 then
31449: LD_VAR 0 7
31453: IFFALSE 31614
// for j in need_heal_2 do
31455: LD_ADDR_VAR 0 3
31459: PUSH
31460: LD_VAR 0 7
31464: PUSH
31465: FOR_IN
31466: IFFALSE 31612
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31468: LD_ADDR_VAR 0 5
31472: PUSH
31473: LD_EXP 78
31477: PUSH
31478: LD_VAR 0 2
31482: ARRAY
31483: PPUSH
31484: LD_INT 2
31486: PUSH
31487: LD_INT 30
31489: PUSH
31490: LD_INT 6
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 30
31499: PUSH
31500: LD_INT 7
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 30
31509: PUSH
31510: LD_INT 8
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: LD_INT 30
31519: PUSH
31520: LD_INT 0
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 30
31529: PUSH
31530: LD_INT 1
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: EMPTY
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: PPUSH
31545: CALL_OW 72
31549: ST_TO_ADDR
// if tmp then
31550: LD_VAR 0 5
31554: IFFALSE 31610
// begin k := NearestUnitToUnit ( tmp , j ) ;
31556: LD_ADDR_VAR 0 4
31560: PUSH
31561: LD_VAR 0 5
31565: PPUSH
31566: LD_VAR 0 3
31570: PPUSH
31571: CALL_OW 74
31575: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
31576: LD_VAR 0 3
31580: PPUSH
31581: LD_VAR 0 4
31585: PPUSH
31586: CALL_OW 296
31590: PUSH
31591: LD_INT 5
31593: GREATER
31594: IFFALSE 31610
// ComMoveToNearbyEntrance ( j , k ) ;
31596: LD_VAR 0 3
31600: PPUSH
31601: LD_VAR 0 4
31605: PPUSH
31606: CALL 91837 0 2
// end ; end ;
31610: GO 31465
31612: POP
31613: POP
// if not need_heal_1 and not need_heal_2 then
31614: LD_VAR 0 6
31618: NOT
31619: PUSH
31620: LD_VAR 0 7
31624: NOT
31625: AND
31626: IFFALSE 31630
// continue ;
31628: GO 31094
// end ;
31630: GO 31094
31632: POP
31633: POP
// RaiseSailEvent ( 102 ) ;
31634: LD_INT 102
31636: PPUSH
31637: CALL_OW 427
// end ;
31641: LD_VAR 0 1
31645: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
31646: LD_INT 0
31648: PPUSH
31649: PPUSH
31650: PPUSH
31651: PPUSH
31652: PPUSH
31653: PPUSH
31654: PPUSH
31655: PPUSH
// if not mc_bases then
31656: LD_EXP 78
31660: NOT
31661: IFFALSE 31665
// exit ;
31663: GO 32576
// for i = 1 to mc_bases do
31665: LD_ADDR_VAR 0 2
31669: PUSH
31670: DOUBLE
31671: LD_INT 1
31673: DEC
31674: ST_TO_ADDR
31675: LD_EXP 78
31679: PUSH
31680: FOR_TO
31681: IFFALSE 32574
// begin if not mc_building_need_repair [ i ] then
31683: LD_EXP 79
31687: PUSH
31688: LD_VAR 0 2
31692: ARRAY
31693: NOT
31694: IFFALSE 31879
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
31696: LD_ADDR_VAR 0 6
31700: PUSH
31701: LD_EXP 97
31705: PUSH
31706: LD_VAR 0 2
31710: ARRAY
31711: PPUSH
31712: LD_INT 3
31714: PUSH
31715: LD_INT 24
31717: PUSH
31718: LD_INT 1000
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: EMPTY
31726: LIST
31727: LIST
31728: PUSH
31729: LD_INT 2
31731: PUSH
31732: LD_INT 34
31734: PUSH
31735: LD_INT 13
31737: PUSH
31738: EMPTY
31739: LIST
31740: LIST
31741: PUSH
31742: LD_INT 34
31744: PUSH
31745: LD_INT 52
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 34
31754: PUSH
31755: LD_INT 88
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: LIST
31766: LIST
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PPUSH
31772: CALL_OW 72
31776: ST_TO_ADDR
// if cranes then
31777: LD_VAR 0 6
31781: IFFALSE 31843
// for j in cranes do
31783: LD_ADDR_VAR 0 3
31787: PUSH
31788: LD_VAR 0 6
31792: PUSH
31793: FOR_IN
31794: IFFALSE 31841
// if not IsInArea ( j , mc_parking [ i ] ) then
31796: LD_VAR 0 3
31800: PPUSH
31801: LD_EXP 102
31805: PUSH
31806: LD_VAR 0 2
31810: ARRAY
31811: PPUSH
31812: CALL_OW 308
31816: NOT
31817: IFFALSE 31839
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31819: LD_VAR 0 3
31823: PPUSH
31824: LD_EXP 102
31828: PUSH
31829: LD_VAR 0 2
31833: ARRAY
31834: PPUSH
31835: CALL_OW 113
31839: GO 31793
31841: POP
31842: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
31843: LD_ADDR_EXP 80
31847: PUSH
31848: LD_EXP 80
31852: PPUSH
31853: LD_VAR 0 2
31857: PPUSH
31858: EMPTY
31859: PPUSH
31860: CALL_OW 1
31864: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
31865: LD_VAR 0 2
31869: PPUSH
31870: LD_INT 101
31872: PPUSH
31873: CALL 26719 0 2
// continue ;
31877: GO 31680
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
31879: LD_ADDR_EXP 84
31883: PUSH
31884: LD_EXP 84
31888: PPUSH
31889: LD_VAR 0 2
31893: PPUSH
31894: EMPTY
31895: PPUSH
31896: CALL_OW 1
31900: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31901: LD_VAR 0 2
31905: PPUSH
31906: LD_INT 103
31908: PPUSH
31909: CALL 26719 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
31913: LD_ADDR_VAR 0 5
31917: PUSH
31918: LD_EXP 78
31922: PUSH
31923: LD_VAR 0 2
31927: ARRAY
31928: PUSH
31929: LD_EXP 107
31933: PUSH
31934: LD_VAR 0 2
31938: ARRAY
31939: UNION
31940: PPUSH
31941: LD_INT 2
31943: PUSH
31944: LD_INT 25
31946: PUSH
31947: LD_INT 2
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 25
31956: PUSH
31957: LD_INT 16
31959: PUSH
31960: EMPTY
31961: LIST
31962: LIST
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: LIST
31968: PUSH
31969: EMPTY
31970: LIST
31971: PPUSH
31972: CALL_OW 72
31976: ST_TO_ADDR
// if mc_need_heal [ i ] then
31977: LD_EXP 81
31981: PUSH
31982: LD_VAR 0 2
31986: ARRAY
31987: IFFALSE 32031
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
31989: LD_ADDR_VAR 0 5
31993: PUSH
31994: LD_VAR 0 5
31998: PUSH
31999: LD_EXP 81
32003: PUSH
32004: LD_VAR 0 2
32008: ARRAY
32009: PUSH
32010: LD_INT 1
32012: ARRAY
32013: PUSH
32014: LD_EXP 81
32018: PUSH
32019: LD_VAR 0 2
32023: ARRAY
32024: PUSH
32025: LD_INT 2
32027: ARRAY
32028: UNION
32029: DIFF
32030: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
32031: LD_ADDR_VAR 0 6
32035: PUSH
32036: LD_EXP 97
32040: PUSH
32041: LD_VAR 0 2
32045: ARRAY
32046: PPUSH
32047: LD_INT 2
32049: PUSH
32050: LD_INT 34
32052: PUSH
32053: LD_INT 13
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 34
32062: PUSH
32063: LD_INT 52
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 34
32072: PUSH
32073: LD_INT 88
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: PPUSH
32086: CALL_OW 72
32090: ST_TO_ADDR
// if cranes then
32091: LD_VAR 0 6
32095: IFFALSE 32263
// begin for j in cranes do
32097: LD_ADDR_VAR 0 3
32101: PUSH
32102: LD_VAR 0 6
32106: PUSH
32107: FOR_IN
32108: IFFALSE 32261
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
32110: LD_VAR 0 3
32114: PPUSH
32115: CALL_OW 256
32119: PUSH
32120: LD_INT 1000
32122: EQUAL
32123: PUSH
32124: LD_VAR 0 3
32128: PPUSH
32129: CALL_OW 314
32133: NOT
32134: AND
32135: IFFALSE 32201
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
32137: LD_ADDR_VAR 0 8
32141: PUSH
32142: LD_EXP 79
32146: PUSH
32147: LD_VAR 0 2
32151: ARRAY
32152: PPUSH
32153: LD_VAR 0 3
32157: PPUSH
32158: CALL_OW 74
32162: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
32163: LD_VAR 0 8
32167: PPUSH
32168: LD_INT 16
32170: PPUSH
32171: CALL 61185 0 2
32175: PUSH
32176: LD_INT 4
32178: ARRAY
32179: PUSH
32180: LD_INT 10
32182: LESS
32183: IFFALSE 32199
// ComRepairBuilding ( j , to_repair ) ;
32185: LD_VAR 0 3
32189: PPUSH
32190: LD_VAR 0 8
32194: PPUSH
32195: CALL_OW 130
// end else
32199: GO 32259
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
32201: LD_VAR 0 3
32205: PPUSH
32206: CALL_OW 256
32210: PUSH
32211: LD_INT 500
32213: LESS
32214: PUSH
32215: LD_VAR 0 3
32219: PPUSH
32220: LD_EXP 102
32224: PUSH
32225: LD_VAR 0 2
32229: ARRAY
32230: PPUSH
32231: CALL_OW 308
32235: NOT
32236: AND
32237: IFFALSE 32259
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32239: LD_VAR 0 3
32243: PPUSH
32244: LD_EXP 102
32248: PUSH
32249: LD_VAR 0 2
32253: ARRAY
32254: PPUSH
32255: CALL_OW 113
// end ;
32259: GO 32107
32261: POP
32262: POP
// end ; if tmp > 3 then
32263: LD_VAR 0 5
32267: PUSH
32268: LD_INT 3
32270: GREATER
32271: IFFALSE 32291
// tmp := ShrinkArray ( tmp , 4 ) ;
32273: LD_ADDR_VAR 0 5
32277: PUSH
32278: LD_VAR 0 5
32282: PPUSH
32283: LD_INT 4
32285: PPUSH
32286: CALL 91275 0 2
32290: ST_TO_ADDR
// if not tmp then
32291: LD_VAR 0 5
32295: NOT
32296: IFFALSE 32300
// continue ;
32298: GO 31680
// for j in tmp do
32300: LD_ADDR_VAR 0 3
32304: PUSH
32305: LD_VAR 0 5
32309: PUSH
32310: FOR_IN
32311: IFFALSE 32570
// begin if IsInUnit ( j ) then
32313: LD_VAR 0 3
32317: PPUSH
32318: CALL_OW 310
32322: IFFALSE 32333
// ComExitBuilding ( j ) ;
32324: LD_VAR 0 3
32328: PPUSH
32329: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
32333: LD_VAR 0 3
32337: PUSH
32338: LD_EXP 80
32342: PUSH
32343: LD_VAR 0 2
32347: ARRAY
32348: IN
32349: NOT
32350: IFFALSE 32408
// begin SetTag ( j , 101 ) ;
32352: LD_VAR 0 3
32356: PPUSH
32357: LD_INT 101
32359: PPUSH
32360: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
32364: LD_ADDR_EXP 80
32368: PUSH
32369: LD_EXP 80
32373: PPUSH
32374: LD_VAR 0 2
32378: PUSH
32379: LD_EXP 80
32383: PUSH
32384: LD_VAR 0 2
32388: ARRAY
32389: PUSH
32390: LD_INT 1
32392: PLUS
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: PPUSH
32398: LD_VAR 0 3
32402: PPUSH
32403: CALL 58220 0 3
32407: ST_TO_ADDR
// end ; wait ( 1 ) ;
32408: LD_INT 1
32410: PPUSH
32411: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
32415: LD_ADDR_VAR 0 7
32419: PUSH
32420: LD_EXP 79
32424: PUSH
32425: LD_VAR 0 2
32429: ARRAY
32430: ST_TO_ADDR
// if mc_scan [ i ] then
32431: LD_EXP 101
32435: PUSH
32436: LD_VAR 0 2
32440: ARRAY
32441: IFFALSE 32503
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
32443: LD_ADDR_VAR 0 7
32447: PUSH
32448: LD_EXP 79
32452: PUSH
32453: LD_VAR 0 2
32457: ARRAY
32458: PPUSH
32459: LD_INT 3
32461: PUSH
32462: LD_INT 30
32464: PUSH
32465: LD_INT 32
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: PUSH
32472: LD_INT 30
32474: PUSH
32475: LD_INT 33
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 30
32484: PUSH
32485: LD_INT 31
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: LIST
32496: LIST
32497: PPUSH
32498: CALL_OW 72
32502: ST_TO_ADDR
// if not to_repair_tmp then
32503: LD_VAR 0 7
32507: NOT
32508: IFFALSE 32512
// continue ;
32510: GO 32310
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32512: LD_ADDR_VAR 0 8
32516: PUSH
32517: LD_VAR 0 7
32521: PPUSH
32522: LD_VAR 0 3
32526: PPUSH
32527: CALL_OW 74
32531: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
32532: LD_VAR 0 8
32536: PPUSH
32537: LD_INT 16
32539: PPUSH
32540: CALL 61185 0 2
32544: PUSH
32545: LD_INT 4
32547: ARRAY
32548: PUSH
32549: LD_INT 14
32551: LESS
32552: IFFALSE 32568
// ComRepairBuilding ( j , to_repair ) ;
32554: LD_VAR 0 3
32558: PPUSH
32559: LD_VAR 0 8
32563: PPUSH
32564: CALL_OW 130
// end ;
32568: GO 32310
32570: POP
32571: POP
// end ;
32572: GO 31680
32574: POP
32575: POP
// end ;
32576: LD_VAR 0 1
32580: RET
// export function MC_Heal ; var i , j , tmp ; begin
32581: LD_INT 0
32583: PPUSH
32584: PPUSH
32585: PPUSH
32586: PPUSH
// if not mc_bases then
32587: LD_EXP 78
32591: NOT
32592: IFFALSE 32596
// exit ;
32594: GO 32998
// for i = 1 to mc_bases do
32596: LD_ADDR_VAR 0 2
32600: PUSH
32601: DOUBLE
32602: LD_INT 1
32604: DEC
32605: ST_TO_ADDR
32606: LD_EXP 78
32610: PUSH
32611: FOR_TO
32612: IFFALSE 32996
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
32614: LD_EXP 81
32618: PUSH
32619: LD_VAR 0 2
32623: ARRAY
32624: PUSH
32625: LD_INT 1
32627: ARRAY
32628: NOT
32629: PUSH
32630: LD_EXP 81
32634: PUSH
32635: LD_VAR 0 2
32639: ARRAY
32640: PUSH
32641: LD_INT 2
32643: ARRAY
32644: NOT
32645: AND
32646: IFFALSE 32684
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
32648: LD_ADDR_EXP 82
32652: PUSH
32653: LD_EXP 82
32657: PPUSH
32658: LD_VAR 0 2
32662: PPUSH
32663: EMPTY
32664: PPUSH
32665: CALL_OW 1
32669: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
32670: LD_VAR 0 2
32674: PPUSH
32675: LD_INT 102
32677: PPUSH
32678: CALL 26719 0 2
// continue ;
32682: GO 32611
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
32684: LD_ADDR_VAR 0 4
32688: PUSH
32689: LD_EXP 78
32693: PUSH
32694: LD_VAR 0 2
32698: ARRAY
32699: PPUSH
32700: LD_INT 25
32702: PUSH
32703: LD_INT 4
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PPUSH
32710: CALL_OW 72
32714: ST_TO_ADDR
// if not tmp then
32715: LD_VAR 0 4
32719: NOT
32720: IFFALSE 32724
// continue ;
32722: GO 32611
// if mc_taming [ i ] then
32724: LD_EXP 109
32728: PUSH
32729: LD_VAR 0 2
32733: ARRAY
32734: IFFALSE 32758
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
32736: LD_ADDR_EXP 109
32740: PUSH
32741: LD_EXP 109
32745: PPUSH
32746: LD_VAR 0 2
32750: PPUSH
32751: EMPTY
32752: PPUSH
32753: CALL_OW 1
32757: ST_TO_ADDR
// for j in tmp do
32758: LD_ADDR_VAR 0 3
32762: PUSH
32763: LD_VAR 0 4
32767: PUSH
32768: FOR_IN
32769: IFFALSE 32992
// begin if IsInUnit ( j ) then
32771: LD_VAR 0 3
32775: PPUSH
32776: CALL_OW 310
32780: IFFALSE 32791
// ComExitBuilding ( j ) ;
32782: LD_VAR 0 3
32786: PPUSH
32787: CALL_OW 122
// if not j in mc_healers [ i ] then
32791: LD_VAR 0 3
32795: PUSH
32796: LD_EXP 82
32800: PUSH
32801: LD_VAR 0 2
32805: ARRAY
32806: IN
32807: NOT
32808: IFFALSE 32854
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
32810: LD_ADDR_EXP 82
32814: PUSH
32815: LD_EXP 82
32819: PPUSH
32820: LD_VAR 0 2
32824: PUSH
32825: LD_EXP 82
32829: PUSH
32830: LD_VAR 0 2
32834: ARRAY
32835: PUSH
32836: LD_INT 1
32838: PLUS
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PPUSH
32844: LD_VAR 0 3
32848: PPUSH
32849: CALL 58220 0 3
32853: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
32854: LD_VAR 0 3
32858: PPUSH
32859: CALL_OW 110
32863: PUSH
32864: LD_INT 102
32866: NONEQUAL
32867: IFFALSE 32881
// SetTag ( j , 102 ) ;
32869: LD_VAR 0 3
32873: PPUSH
32874: LD_INT 102
32876: PPUSH
32877: CALL_OW 109
// Wait ( 3 ) ;
32881: LD_INT 3
32883: PPUSH
32884: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
32888: LD_EXP 81
32892: PUSH
32893: LD_VAR 0 2
32897: ARRAY
32898: PUSH
32899: LD_INT 1
32901: ARRAY
32902: IFFALSE 32934
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
32904: LD_VAR 0 3
32908: PPUSH
32909: LD_EXP 81
32913: PUSH
32914: LD_VAR 0 2
32918: ARRAY
32919: PUSH
32920: LD_INT 1
32922: ARRAY
32923: PUSH
32924: LD_INT 1
32926: ARRAY
32927: PPUSH
32928: CALL_OW 128
32932: GO 32990
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
32934: LD_VAR 0 3
32938: PPUSH
32939: CALL_OW 314
32943: NOT
32944: PUSH
32945: LD_EXP 81
32949: PUSH
32950: LD_VAR 0 2
32954: ARRAY
32955: PUSH
32956: LD_INT 2
32958: ARRAY
32959: AND
32960: IFFALSE 32990
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
32962: LD_VAR 0 3
32966: PPUSH
32967: LD_EXP 81
32971: PUSH
32972: LD_VAR 0 2
32976: ARRAY
32977: PUSH
32978: LD_INT 2
32980: ARRAY
32981: PUSH
32982: LD_INT 1
32984: ARRAY
32985: PPUSH
32986: CALL_OW 128
// end ;
32990: GO 32768
32992: POP
32993: POP
// end ;
32994: GO 32611
32996: POP
32997: POP
// end ;
32998: LD_VAR 0 1
33002: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
33003: LD_INT 0
33005: PPUSH
33006: PPUSH
33007: PPUSH
33008: PPUSH
33009: PPUSH
33010: PPUSH
// if not mc_bases then
33011: LD_EXP 78
33015: NOT
33016: IFFALSE 33020
// exit ;
33018: GO 34183
// for i = 1 to mc_bases do
33020: LD_ADDR_VAR 0 2
33024: PUSH
33025: DOUBLE
33026: LD_INT 1
33028: DEC
33029: ST_TO_ADDR
33030: LD_EXP 78
33034: PUSH
33035: FOR_TO
33036: IFFALSE 34181
// begin if mc_scan [ i ] then
33038: LD_EXP 101
33042: PUSH
33043: LD_VAR 0 2
33047: ARRAY
33048: IFFALSE 33052
// continue ;
33050: GO 33035
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
33052: LD_EXP 83
33056: PUSH
33057: LD_VAR 0 2
33061: ARRAY
33062: NOT
33063: PUSH
33064: LD_EXP 85
33068: PUSH
33069: LD_VAR 0 2
33073: ARRAY
33074: NOT
33075: AND
33076: PUSH
33077: LD_EXP 84
33081: PUSH
33082: LD_VAR 0 2
33086: ARRAY
33087: AND
33088: IFFALSE 33126
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
33090: LD_ADDR_EXP 84
33094: PUSH
33095: LD_EXP 84
33099: PPUSH
33100: LD_VAR 0 2
33104: PPUSH
33105: EMPTY
33106: PPUSH
33107: CALL_OW 1
33111: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
33112: LD_VAR 0 2
33116: PPUSH
33117: LD_INT 103
33119: PPUSH
33120: CALL 26719 0 2
// continue ;
33124: GO 33035
// end ; if mc_construct_list [ i ] then
33126: LD_EXP 85
33130: PUSH
33131: LD_VAR 0 2
33135: ARRAY
33136: IFFALSE 33356
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33138: LD_ADDR_VAR 0 5
33142: PUSH
33143: LD_EXP 78
33147: PUSH
33148: LD_VAR 0 2
33152: ARRAY
33153: PPUSH
33154: LD_INT 25
33156: PUSH
33157: LD_INT 2
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PPUSH
33164: CALL_OW 72
33168: PUSH
33169: LD_EXP 80
33173: PUSH
33174: LD_VAR 0 2
33178: ARRAY
33179: DIFF
33180: ST_TO_ADDR
// if not tmp then
33181: LD_VAR 0 5
33185: NOT
33186: IFFALSE 33190
// continue ;
33188: GO 33035
// for j in tmp do
33190: LD_ADDR_VAR 0 3
33194: PUSH
33195: LD_VAR 0 5
33199: PUSH
33200: FOR_IN
33201: IFFALSE 33352
// begin if not mc_builders [ i ] then
33203: LD_EXP 84
33207: PUSH
33208: LD_VAR 0 2
33212: ARRAY
33213: NOT
33214: IFFALSE 33272
// begin SetTag ( j , 103 ) ;
33216: LD_VAR 0 3
33220: PPUSH
33221: LD_INT 103
33223: PPUSH
33224: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33228: LD_ADDR_EXP 84
33232: PUSH
33233: LD_EXP 84
33237: PPUSH
33238: LD_VAR 0 2
33242: PUSH
33243: LD_EXP 84
33247: PUSH
33248: LD_VAR 0 2
33252: ARRAY
33253: PUSH
33254: LD_INT 1
33256: PLUS
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PPUSH
33262: LD_VAR 0 3
33266: PPUSH
33267: CALL 58220 0 3
33271: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33272: LD_VAR 0 3
33276: PPUSH
33277: CALL_OW 310
33281: IFFALSE 33292
// ComExitBuilding ( j ) ;
33283: LD_VAR 0 3
33287: PPUSH
33288: CALL_OW 122
// wait ( 3 ) ;
33292: LD_INT 3
33294: PPUSH
33295: CALL_OW 67
// if not mc_construct_list [ i ] then
33299: LD_EXP 85
33303: PUSH
33304: LD_VAR 0 2
33308: ARRAY
33309: NOT
33310: IFFALSE 33314
// break ;
33312: GO 33352
// if not HasTask ( j ) then
33314: LD_VAR 0 3
33318: PPUSH
33319: CALL_OW 314
33323: NOT
33324: IFFALSE 33350
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
33326: LD_VAR 0 3
33330: PPUSH
33331: LD_EXP 85
33335: PUSH
33336: LD_VAR 0 2
33340: ARRAY
33341: PUSH
33342: LD_INT 1
33344: ARRAY
33345: PPUSH
33346: CALL 61458 0 2
// end ;
33350: GO 33200
33352: POP
33353: POP
// end else
33354: GO 34179
// if mc_build_list [ i ] then
33356: LD_EXP 83
33360: PUSH
33361: LD_VAR 0 2
33365: ARRAY
33366: IFFALSE 34179
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
33368: LD_EXP 83
33372: PUSH
33373: LD_VAR 0 2
33377: ARRAY
33378: PUSH
33379: LD_INT 1
33381: ARRAY
33382: PUSH
33383: LD_INT 1
33385: ARRAY
33386: PPUSH
33387: CALL 61282 0 1
33391: PUSH
33392: LD_EXP 78
33396: PUSH
33397: LD_VAR 0 2
33401: ARRAY
33402: PPUSH
33403: LD_INT 2
33405: PUSH
33406: LD_INT 30
33408: PUSH
33409: LD_INT 2
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 30
33418: PUSH
33419: LD_INT 3
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: LIST
33430: PPUSH
33431: CALL_OW 72
33435: NOT
33436: AND
33437: IFFALSE 33542
// begin for j = 1 to mc_build_list [ i ] do
33439: LD_ADDR_VAR 0 3
33443: PUSH
33444: DOUBLE
33445: LD_INT 1
33447: DEC
33448: ST_TO_ADDR
33449: LD_EXP 83
33453: PUSH
33454: LD_VAR 0 2
33458: ARRAY
33459: PUSH
33460: FOR_TO
33461: IFFALSE 33540
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33463: LD_EXP 83
33467: PUSH
33468: LD_VAR 0 2
33472: ARRAY
33473: PUSH
33474: LD_VAR 0 3
33478: ARRAY
33479: PUSH
33480: LD_INT 1
33482: ARRAY
33483: PUSH
33484: LD_INT 2
33486: EQUAL
33487: IFFALSE 33538
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33489: LD_ADDR_EXP 83
33493: PUSH
33494: LD_EXP 83
33498: PPUSH
33499: LD_VAR 0 2
33503: PPUSH
33504: LD_EXP 83
33508: PUSH
33509: LD_VAR 0 2
33513: ARRAY
33514: PPUSH
33515: LD_VAR 0 3
33519: PPUSH
33520: LD_INT 1
33522: PPUSH
33523: LD_INT 0
33525: PPUSH
33526: CALL 57638 0 4
33530: PPUSH
33531: CALL_OW 1
33535: ST_TO_ADDR
// break ;
33536: GO 33540
// end ;
33538: GO 33460
33540: POP
33541: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33542: LD_ADDR_VAR 0 6
33546: PUSH
33547: LD_EXP 78
33551: PUSH
33552: LD_VAR 0 2
33556: ARRAY
33557: PPUSH
33558: LD_INT 2
33560: PUSH
33561: LD_INT 30
33563: PUSH
33564: LD_INT 0
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: PUSH
33571: LD_INT 30
33573: PUSH
33574: LD_INT 1
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: LIST
33585: PPUSH
33586: CALL_OW 72
33590: ST_TO_ADDR
// for k := 1 to depot do
33591: LD_ADDR_VAR 0 4
33595: PUSH
33596: DOUBLE
33597: LD_INT 1
33599: DEC
33600: ST_TO_ADDR
33601: LD_VAR 0 6
33605: PUSH
33606: FOR_TO
33607: IFFALSE 34177
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
33609: LD_EXP 83
33613: PUSH
33614: LD_VAR 0 2
33618: ARRAY
33619: PUSH
33620: LD_INT 1
33622: ARRAY
33623: PUSH
33624: LD_INT 1
33626: ARRAY
33627: PUSH
33628: LD_INT 0
33630: EQUAL
33631: PUSH
33632: LD_VAR 0 6
33636: PUSH
33637: LD_VAR 0 4
33641: ARRAY
33642: PPUSH
33643: LD_EXP 83
33647: PUSH
33648: LD_VAR 0 2
33652: ARRAY
33653: PUSH
33654: LD_INT 1
33656: ARRAY
33657: PUSH
33658: LD_INT 1
33660: ARRAY
33661: PPUSH
33662: LD_EXP 83
33666: PUSH
33667: LD_VAR 0 2
33671: ARRAY
33672: PUSH
33673: LD_INT 1
33675: ARRAY
33676: PUSH
33677: LD_INT 2
33679: ARRAY
33680: PPUSH
33681: LD_EXP 83
33685: PUSH
33686: LD_VAR 0 2
33690: ARRAY
33691: PUSH
33692: LD_INT 1
33694: ARRAY
33695: PUSH
33696: LD_INT 3
33698: ARRAY
33699: PPUSH
33700: LD_EXP 83
33704: PUSH
33705: LD_VAR 0 2
33709: ARRAY
33710: PUSH
33711: LD_INT 1
33713: ARRAY
33714: PUSH
33715: LD_INT 4
33717: ARRAY
33718: PPUSH
33719: CALL 66694 0 5
33723: OR
33724: IFFALSE 34005
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33726: LD_ADDR_VAR 0 5
33730: PUSH
33731: LD_EXP 78
33735: PUSH
33736: LD_VAR 0 2
33740: ARRAY
33741: PPUSH
33742: LD_INT 25
33744: PUSH
33745: LD_INT 2
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PPUSH
33752: CALL_OW 72
33756: PUSH
33757: LD_EXP 80
33761: PUSH
33762: LD_VAR 0 2
33766: ARRAY
33767: DIFF
33768: ST_TO_ADDR
// if not tmp then
33769: LD_VAR 0 5
33773: NOT
33774: IFFALSE 33778
// continue ;
33776: GO 33606
// for j in tmp do
33778: LD_ADDR_VAR 0 3
33782: PUSH
33783: LD_VAR 0 5
33787: PUSH
33788: FOR_IN
33789: IFFALSE 34001
// begin if not mc_builders [ i ] then
33791: LD_EXP 84
33795: PUSH
33796: LD_VAR 0 2
33800: ARRAY
33801: NOT
33802: IFFALSE 33860
// begin SetTag ( j , 103 ) ;
33804: LD_VAR 0 3
33808: PPUSH
33809: LD_INT 103
33811: PPUSH
33812: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33816: LD_ADDR_EXP 84
33820: PUSH
33821: LD_EXP 84
33825: PPUSH
33826: LD_VAR 0 2
33830: PUSH
33831: LD_EXP 84
33835: PUSH
33836: LD_VAR 0 2
33840: ARRAY
33841: PUSH
33842: LD_INT 1
33844: PLUS
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PPUSH
33850: LD_VAR 0 3
33854: PPUSH
33855: CALL 58220 0 3
33859: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33860: LD_VAR 0 3
33864: PPUSH
33865: CALL_OW 310
33869: IFFALSE 33880
// ComExitBuilding ( j ) ;
33871: LD_VAR 0 3
33875: PPUSH
33876: CALL_OW 122
// wait ( 3 ) ;
33880: LD_INT 3
33882: PPUSH
33883: CALL_OW 67
// if not mc_build_list [ i ] then
33887: LD_EXP 83
33891: PUSH
33892: LD_VAR 0 2
33896: ARRAY
33897: NOT
33898: IFFALSE 33902
// break ;
33900: GO 34001
// if not HasTask ( j ) then
33902: LD_VAR 0 3
33906: PPUSH
33907: CALL_OW 314
33911: NOT
33912: IFFALSE 33999
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
33914: LD_VAR 0 3
33918: PPUSH
33919: LD_EXP 83
33923: PUSH
33924: LD_VAR 0 2
33928: ARRAY
33929: PUSH
33930: LD_INT 1
33932: ARRAY
33933: PUSH
33934: LD_INT 1
33936: ARRAY
33937: PPUSH
33938: LD_EXP 83
33942: PUSH
33943: LD_VAR 0 2
33947: ARRAY
33948: PUSH
33949: LD_INT 1
33951: ARRAY
33952: PUSH
33953: LD_INT 2
33955: ARRAY
33956: PPUSH
33957: LD_EXP 83
33961: PUSH
33962: LD_VAR 0 2
33966: ARRAY
33967: PUSH
33968: LD_INT 1
33970: ARRAY
33971: PUSH
33972: LD_INT 3
33974: ARRAY
33975: PPUSH
33976: LD_EXP 83
33980: PUSH
33981: LD_VAR 0 2
33985: ARRAY
33986: PUSH
33987: LD_INT 1
33989: ARRAY
33990: PUSH
33991: LD_INT 4
33993: ARRAY
33994: PPUSH
33995: CALL_OW 145
// end ;
33999: GO 33788
34001: POP
34002: POP
// end else
34003: GO 34175
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
34005: LD_EXP 78
34009: PUSH
34010: LD_VAR 0 2
34014: ARRAY
34015: PPUSH
34016: LD_EXP 83
34020: PUSH
34021: LD_VAR 0 2
34025: ARRAY
34026: PUSH
34027: LD_INT 1
34029: ARRAY
34030: PUSH
34031: LD_INT 1
34033: ARRAY
34034: PPUSH
34035: LD_EXP 83
34039: PUSH
34040: LD_VAR 0 2
34044: ARRAY
34045: PUSH
34046: LD_INT 1
34048: ARRAY
34049: PUSH
34050: LD_INT 2
34052: ARRAY
34053: PPUSH
34054: LD_EXP 83
34058: PUSH
34059: LD_VAR 0 2
34063: ARRAY
34064: PUSH
34065: LD_INT 1
34067: ARRAY
34068: PUSH
34069: LD_INT 3
34071: ARRAY
34072: PPUSH
34073: LD_EXP 83
34077: PUSH
34078: LD_VAR 0 2
34082: ARRAY
34083: PUSH
34084: LD_INT 1
34086: ARRAY
34087: PUSH
34088: LD_INT 4
34090: ARRAY
34091: PPUSH
34092: LD_EXP 78
34096: PUSH
34097: LD_VAR 0 2
34101: ARRAY
34102: PPUSH
34103: LD_INT 21
34105: PUSH
34106: LD_INT 3
34108: PUSH
34109: EMPTY
34110: LIST
34111: LIST
34112: PPUSH
34113: CALL_OW 72
34117: PPUSH
34118: EMPTY
34119: PPUSH
34120: CALL 65448 0 7
34124: NOT
34125: IFFALSE 34175
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
34127: LD_ADDR_EXP 83
34131: PUSH
34132: LD_EXP 83
34136: PPUSH
34137: LD_VAR 0 2
34141: PPUSH
34142: LD_EXP 83
34146: PUSH
34147: LD_VAR 0 2
34151: ARRAY
34152: PPUSH
34153: LD_INT 1
34155: PPUSH
34156: LD_INT 1
34158: NEG
34159: PPUSH
34160: LD_INT 0
34162: PPUSH
34163: CALL 57638 0 4
34167: PPUSH
34168: CALL_OW 1
34172: ST_TO_ADDR
// continue ;
34173: GO 33606
// end ; end ;
34175: GO 33606
34177: POP
34178: POP
// end ; end ;
34179: GO 33035
34181: POP
34182: POP
// end ;
34183: LD_VAR 0 1
34187: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
34188: LD_INT 0
34190: PPUSH
34191: PPUSH
34192: PPUSH
34193: PPUSH
34194: PPUSH
34195: PPUSH
// if not mc_bases then
34196: LD_EXP 78
34200: NOT
34201: IFFALSE 34205
// exit ;
34203: GO 34632
// for i = 1 to mc_bases do
34205: LD_ADDR_VAR 0 2
34209: PUSH
34210: DOUBLE
34211: LD_INT 1
34213: DEC
34214: ST_TO_ADDR
34215: LD_EXP 78
34219: PUSH
34220: FOR_TO
34221: IFFALSE 34630
// begin tmp := mc_build_upgrade [ i ] ;
34223: LD_ADDR_VAR 0 4
34227: PUSH
34228: LD_EXP 110
34232: PUSH
34233: LD_VAR 0 2
34237: ARRAY
34238: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
34239: LD_ADDR_VAR 0 6
34243: PUSH
34244: LD_EXP 111
34248: PUSH
34249: LD_VAR 0 2
34253: ARRAY
34254: PPUSH
34255: LD_INT 2
34257: PUSH
34258: LD_INT 30
34260: PUSH
34261: LD_INT 6
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: LD_INT 30
34270: PUSH
34271: LD_INT 7
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: LIST
34282: PPUSH
34283: CALL_OW 72
34287: ST_TO_ADDR
// if not tmp and not lab then
34288: LD_VAR 0 4
34292: NOT
34293: PUSH
34294: LD_VAR 0 6
34298: NOT
34299: AND
34300: IFFALSE 34304
// continue ;
34302: GO 34220
// if tmp then
34304: LD_VAR 0 4
34308: IFFALSE 34428
// for j in tmp do
34310: LD_ADDR_VAR 0 3
34314: PUSH
34315: LD_VAR 0 4
34319: PUSH
34320: FOR_IN
34321: IFFALSE 34426
// begin if UpgradeCost ( j ) then
34323: LD_VAR 0 3
34327: PPUSH
34328: CALL 65108 0 1
34332: IFFALSE 34424
// begin ComUpgrade ( j ) ;
34334: LD_VAR 0 3
34338: PPUSH
34339: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
34343: LD_ADDR_EXP 110
34347: PUSH
34348: LD_EXP 110
34352: PPUSH
34353: LD_VAR 0 2
34357: PPUSH
34358: LD_EXP 110
34362: PUSH
34363: LD_VAR 0 2
34367: ARRAY
34368: PUSH
34369: LD_VAR 0 3
34373: DIFF
34374: PPUSH
34375: CALL_OW 1
34379: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34380: LD_ADDR_EXP 85
34384: PUSH
34385: LD_EXP 85
34389: PPUSH
34390: LD_VAR 0 2
34394: PUSH
34395: LD_EXP 85
34399: PUSH
34400: LD_VAR 0 2
34404: ARRAY
34405: PUSH
34406: LD_INT 1
34408: PLUS
34409: PUSH
34410: EMPTY
34411: LIST
34412: LIST
34413: PPUSH
34414: LD_VAR 0 3
34418: PPUSH
34419: CALL 58220 0 3
34423: ST_TO_ADDR
// end ; end ;
34424: GO 34320
34426: POP
34427: POP
// if not lab or not mc_lab_upgrade [ i ] then
34428: LD_VAR 0 6
34432: NOT
34433: PUSH
34434: LD_EXP 112
34438: PUSH
34439: LD_VAR 0 2
34443: ARRAY
34444: NOT
34445: OR
34446: IFFALSE 34450
// continue ;
34448: GO 34220
// for j in lab do
34450: LD_ADDR_VAR 0 3
34454: PUSH
34455: LD_VAR 0 6
34459: PUSH
34460: FOR_IN
34461: IFFALSE 34626
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34463: LD_VAR 0 3
34467: PPUSH
34468: CALL_OW 266
34472: PUSH
34473: LD_INT 6
34475: PUSH
34476: LD_INT 7
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: IN
34483: PUSH
34484: LD_VAR 0 3
34488: PPUSH
34489: CALL_OW 461
34493: PUSH
34494: LD_INT 1
34496: NONEQUAL
34497: AND
34498: IFFALSE 34624
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34500: LD_VAR 0 3
34504: PPUSH
34505: LD_EXP 112
34509: PUSH
34510: LD_VAR 0 2
34514: ARRAY
34515: PUSH
34516: LD_INT 1
34518: ARRAY
34519: PPUSH
34520: CALL 65313 0 2
34524: IFFALSE 34624
// begin ComCancel ( j ) ;
34526: LD_VAR 0 3
34530: PPUSH
34531: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
34535: LD_VAR 0 3
34539: PPUSH
34540: LD_EXP 112
34544: PUSH
34545: LD_VAR 0 2
34549: ARRAY
34550: PUSH
34551: LD_INT 1
34553: ARRAY
34554: PPUSH
34555: CALL_OW 207
// if not j in mc_construct_list [ i ] then
34559: LD_VAR 0 3
34563: PUSH
34564: LD_EXP 85
34568: PUSH
34569: LD_VAR 0 2
34573: ARRAY
34574: IN
34575: NOT
34576: IFFALSE 34622
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34578: LD_ADDR_EXP 85
34582: PUSH
34583: LD_EXP 85
34587: PPUSH
34588: LD_VAR 0 2
34592: PUSH
34593: LD_EXP 85
34597: PUSH
34598: LD_VAR 0 2
34602: ARRAY
34603: PUSH
34604: LD_INT 1
34606: PLUS
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PPUSH
34612: LD_VAR 0 3
34616: PPUSH
34617: CALL 58220 0 3
34621: ST_TO_ADDR
// break ;
34622: GO 34626
// end ; end ; end ;
34624: GO 34460
34626: POP
34627: POP
// end ;
34628: GO 34220
34630: POP
34631: POP
// end ;
34632: LD_VAR 0 1
34636: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
34637: LD_INT 0
34639: PPUSH
34640: PPUSH
34641: PPUSH
34642: PPUSH
34643: PPUSH
34644: PPUSH
34645: PPUSH
34646: PPUSH
34647: PPUSH
// if not mc_bases then
34648: LD_EXP 78
34652: NOT
34653: IFFALSE 34657
// exit ;
34655: GO 35062
// for i = 1 to mc_bases do
34657: LD_ADDR_VAR 0 2
34661: PUSH
34662: DOUBLE
34663: LD_INT 1
34665: DEC
34666: ST_TO_ADDR
34667: LD_EXP 78
34671: PUSH
34672: FOR_TO
34673: IFFALSE 35060
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
34675: LD_EXP 86
34679: PUSH
34680: LD_VAR 0 2
34684: ARRAY
34685: NOT
34686: PUSH
34687: LD_EXP 78
34691: PUSH
34692: LD_VAR 0 2
34696: ARRAY
34697: PPUSH
34698: LD_INT 30
34700: PUSH
34701: LD_INT 3
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: PPUSH
34708: CALL_OW 72
34712: NOT
34713: OR
34714: IFFALSE 34718
// continue ;
34716: GO 34672
// busy := false ;
34718: LD_ADDR_VAR 0 8
34722: PUSH
34723: LD_INT 0
34725: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34726: LD_ADDR_VAR 0 4
34730: PUSH
34731: LD_EXP 78
34735: PUSH
34736: LD_VAR 0 2
34740: ARRAY
34741: PPUSH
34742: LD_INT 30
34744: PUSH
34745: LD_INT 3
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PPUSH
34752: CALL_OW 72
34756: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
34757: LD_ADDR_VAR 0 6
34761: PUSH
34762: LD_EXP 86
34766: PUSH
34767: LD_VAR 0 2
34771: ARRAY
34772: PPUSH
34773: LD_INT 2
34775: PUSH
34776: LD_INT 30
34778: PUSH
34779: LD_INT 32
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 30
34788: PUSH
34789: LD_INT 33
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: LIST
34800: PPUSH
34801: CALL_OW 72
34805: ST_TO_ADDR
// if not t then
34806: LD_VAR 0 6
34810: NOT
34811: IFFALSE 34815
// continue ;
34813: GO 34672
// for j in tmp do
34815: LD_ADDR_VAR 0 3
34819: PUSH
34820: LD_VAR 0 4
34824: PUSH
34825: FOR_IN
34826: IFFALSE 34856
// if not BuildingStatus ( j ) = bs_idle then
34828: LD_VAR 0 3
34832: PPUSH
34833: CALL_OW 461
34837: PUSH
34838: LD_INT 2
34840: EQUAL
34841: NOT
34842: IFFALSE 34854
// begin busy := true ;
34844: LD_ADDR_VAR 0 8
34848: PUSH
34849: LD_INT 1
34851: ST_TO_ADDR
// break ;
34852: GO 34856
// end ;
34854: GO 34825
34856: POP
34857: POP
// if busy then
34858: LD_VAR 0 8
34862: IFFALSE 34866
// continue ;
34864: GO 34672
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
34866: LD_ADDR_VAR 0 7
34870: PUSH
34871: LD_VAR 0 6
34875: PPUSH
34876: LD_INT 35
34878: PUSH
34879: LD_INT 0
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PPUSH
34886: CALL_OW 72
34890: ST_TO_ADDR
// if tw then
34891: LD_VAR 0 7
34895: IFFALSE 34972
// begin tw := tw [ 1 ] ;
34897: LD_ADDR_VAR 0 7
34901: PUSH
34902: LD_VAR 0 7
34906: PUSH
34907: LD_INT 1
34909: ARRAY
34910: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
34911: LD_ADDR_VAR 0 9
34915: PUSH
34916: LD_VAR 0 7
34920: PPUSH
34921: LD_EXP 103
34925: PUSH
34926: LD_VAR 0 2
34930: ARRAY
34931: PPUSH
34932: CALL 63605 0 2
34936: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
34937: LD_EXP 117
34941: PUSH
34942: LD_VAR 0 2
34946: ARRAY
34947: IFFALSE 34970
// if not weapon in mc_allowed_tower_weapons [ i ] then
34949: LD_VAR 0 9
34953: PUSH
34954: LD_EXP 117
34958: PUSH
34959: LD_VAR 0 2
34963: ARRAY
34964: IN
34965: NOT
34966: IFFALSE 34970
// continue ;
34968: GO 34672
// end else
34970: GO 35035
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
34972: LD_ADDR_VAR 0 5
34976: PUSH
34977: LD_EXP 86
34981: PUSH
34982: LD_VAR 0 2
34986: ARRAY
34987: PPUSH
34988: LD_VAR 0 4
34992: PPUSH
34993: CALL 90508 0 2
34997: ST_TO_ADDR
// if not tmp2 then
34998: LD_VAR 0 5
35002: NOT
35003: IFFALSE 35007
// continue ;
35005: GO 34672
// tw := tmp2 [ 1 ] ;
35007: LD_ADDR_VAR 0 7
35011: PUSH
35012: LD_VAR 0 5
35016: PUSH
35017: LD_INT 1
35019: ARRAY
35020: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
35021: LD_ADDR_VAR 0 9
35025: PUSH
35026: LD_VAR 0 5
35030: PUSH
35031: LD_INT 2
35033: ARRAY
35034: ST_TO_ADDR
// end ; if not weapon then
35035: LD_VAR 0 9
35039: NOT
35040: IFFALSE 35044
// continue ;
35042: GO 34672
// ComPlaceWeapon ( tw , weapon ) ;
35044: LD_VAR 0 7
35048: PPUSH
35049: LD_VAR 0 9
35053: PPUSH
35054: CALL_OW 148
// end ;
35058: GO 34672
35060: POP
35061: POP
// end ;
35062: LD_VAR 0 1
35066: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
35067: LD_INT 0
35069: PPUSH
35070: PPUSH
35071: PPUSH
35072: PPUSH
35073: PPUSH
35074: PPUSH
35075: PPUSH
// if not mc_bases then
35076: LD_EXP 78
35080: NOT
35081: IFFALSE 35085
// exit ;
35083: GO 35860
// for i = 1 to mc_bases do
35085: LD_ADDR_VAR 0 2
35089: PUSH
35090: DOUBLE
35091: LD_INT 1
35093: DEC
35094: ST_TO_ADDR
35095: LD_EXP 78
35099: PUSH
35100: FOR_TO
35101: IFFALSE 35858
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
35103: LD_EXP 91
35107: PUSH
35108: LD_VAR 0 2
35112: ARRAY
35113: NOT
35114: PUSH
35115: LD_EXP 91
35119: PUSH
35120: LD_VAR 0 2
35124: ARRAY
35125: PUSH
35126: LD_EXP 92
35130: PUSH
35131: LD_VAR 0 2
35135: ARRAY
35136: EQUAL
35137: OR
35138: PUSH
35139: LD_EXP 101
35143: PUSH
35144: LD_VAR 0 2
35148: ARRAY
35149: OR
35150: IFFALSE 35154
// continue ;
35152: GO 35100
// if mc_miners [ i ] then
35154: LD_EXP 92
35158: PUSH
35159: LD_VAR 0 2
35163: ARRAY
35164: IFFALSE 35545
// begin for j = mc_miners [ i ] downto 1 do
35166: LD_ADDR_VAR 0 3
35170: PUSH
35171: DOUBLE
35172: LD_EXP 92
35176: PUSH
35177: LD_VAR 0 2
35181: ARRAY
35182: INC
35183: ST_TO_ADDR
35184: LD_INT 1
35186: PUSH
35187: FOR_DOWNTO
35188: IFFALSE 35543
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
35190: LD_EXP 92
35194: PUSH
35195: LD_VAR 0 2
35199: ARRAY
35200: PUSH
35201: LD_VAR 0 3
35205: ARRAY
35206: PPUSH
35207: CALL_OW 301
35211: PUSH
35212: LD_EXP 92
35216: PUSH
35217: LD_VAR 0 2
35221: ARRAY
35222: PUSH
35223: LD_VAR 0 3
35227: ARRAY
35228: PPUSH
35229: CALL_OW 257
35233: PUSH
35234: LD_INT 1
35236: NONEQUAL
35237: OR
35238: IFFALSE 35301
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
35240: LD_ADDR_VAR 0 5
35244: PUSH
35245: LD_EXP 92
35249: PUSH
35250: LD_VAR 0 2
35254: ARRAY
35255: PUSH
35256: LD_EXP 92
35260: PUSH
35261: LD_VAR 0 2
35265: ARRAY
35266: PUSH
35267: LD_VAR 0 3
35271: ARRAY
35272: DIFF
35273: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
35274: LD_ADDR_EXP 92
35278: PUSH
35279: LD_EXP 92
35283: PPUSH
35284: LD_VAR 0 2
35288: PPUSH
35289: LD_VAR 0 5
35293: PPUSH
35294: CALL_OW 1
35298: ST_TO_ADDR
// continue ;
35299: GO 35187
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
35301: LD_EXP 92
35305: PUSH
35306: LD_VAR 0 2
35310: ARRAY
35311: PUSH
35312: LD_VAR 0 3
35316: ARRAY
35317: PPUSH
35318: CALL_OW 257
35322: PUSH
35323: LD_INT 1
35325: EQUAL
35326: PUSH
35327: LD_EXP 92
35331: PUSH
35332: LD_VAR 0 2
35336: ARRAY
35337: PUSH
35338: LD_VAR 0 3
35342: ARRAY
35343: PPUSH
35344: CALL_OW 459
35348: NOT
35349: AND
35350: PUSH
35351: LD_EXP 92
35355: PUSH
35356: LD_VAR 0 2
35360: ARRAY
35361: PUSH
35362: LD_VAR 0 3
35366: ARRAY
35367: PPUSH
35368: CALL_OW 314
35372: NOT
35373: AND
35374: IFFALSE 35541
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
35376: LD_EXP 92
35380: PUSH
35381: LD_VAR 0 2
35385: ARRAY
35386: PUSH
35387: LD_VAR 0 3
35391: ARRAY
35392: PPUSH
35393: CALL_OW 310
35397: IFFALSE 35420
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
35399: LD_EXP 92
35403: PUSH
35404: LD_VAR 0 2
35408: ARRAY
35409: PUSH
35410: LD_VAR 0 3
35414: ARRAY
35415: PPUSH
35416: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
35420: LD_EXP 92
35424: PUSH
35425: LD_VAR 0 2
35429: ARRAY
35430: PUSH
35431: LD_VAR 0 3
35435: ARRAY
35436: PPUSH
35437: CALL_OW 314
35441: NOT
35442: IFFALSE 35541
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
35444: LD_ADDR_VAR 0 7
35448: PUSH
35449: LD_VAR 0 3
35453: PUSH
35454: LD_EXP 91
35458: PUSH
35459: LD_VAR 0 2
35463: ARRAY
35464: PPUSH
35465: CALL 55360 0 1
35469: MOD
35470: PUSH
35471: LD_INT 1
35473: PLUS
35474: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35475: LD_EXP 92
35479: PUSH
35480: LD_VAR 0 2
35484: ARRAY
35485: PUSH
35486: LD_VAR 0 3
35490: ARRAY
35491: PPUSH
35492: LD_EXP 91
35496: PUSH
35497: LD_VAR 0 2
35501: ARRAY
35502: PUSH
35503: LD_VAR 0 7
35507: ARRAY
35508: PUSH
35509: LD_INT 1
35511: ARRAY
35512: PPUSH
35513: LD_EXP 91
35517: PUSH
35518: LD_VAR 0 2
35522: ARRAY
35523: PUSH
35524: LD_VAR 0 7
35528: ARRAY
35529: PUSH
35530: LD_INT 2
35532: ARRAY
35533: PPUSH
35534: LD_INT 0
35536: PPUSH
35537: CALL_OW 193
// end ; end ; end ;
35541: GO 35187
35543: POP
35544: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
35545: LD_ADDR_VAR 0 5
35549: PUSH
35550: LD_EXP 78
35554: PUSH
35555: LD_VAR 0 2
35559: ARRAY
35560: PPUSH
35561: LD_INT 2
35563: PUSH
35564: LD_INT 30
35566: PUSH
35567: LD_INT 4
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 30
35576: PUSH
35577: LD_INT 5
35579: PUSH
35580: EMPTY
35581: LIST
35582: LIST
35583: PUSH
35584: LD_INT 30
35586: PUSH
35587: LD_INT 32
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: LIST
35598: LIST
35599: PPUSH
35600: CALL_OW 72
35604: ST_TO_ADDR
// if not tmp then
35605: LD_VAR 0 5
35609: NOT
35610: IFFALSE 35614
// continue ;
35612: GO 35100
// list := [ ] ;
35614: LD_ADDR_VAR 0 6
35618: PUSH
35619: EMPTY
35620: ST_TO_ADDR
// for j in tmp do
35621: LD_ADDR_VAR 0 3
35625: PUSH
35626: LD_VAR 0 5
35630: PUSH
35631: FOR_IN
35632: IFFALSE 35701
// begin for k in UnitsInside ( j ) do
35634: LD_ADDR_VAR 0 4
35638: PUSH
35639: LD_VAR 0 3
35643: PPUSH
35644: CALL_OW 313
35648: PUSH
35649: FOR_IN
35650: IFFALSE 35697
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
35652: LD_VAR 0 4
35656: PPUSH
35657: CALL_OW 257
35661: PUSH
35662: LD_INT 1
35664: EQUAL
35665: PUSH
35666: LD_VAR 0 4
35670: PPUSH
35671: CALL_OW 459
35675: NOT
35676: AND
35677: IFFALSE 35695
// list := list ^ k ;
35679: LD_ADDR_VAR 0 6
35683: PUSH
35684: LD_VAR 0 6
35688: PUSH
35689: LD_VAR 0 4
35693: ADD
35694: ST_TO_ADDR
35695: GO 35649
35697: POP
35698: POP
// end ;
35699: GO 35631
35701: POP
35702: POP
// list := list diff mc_miners [ i ] ;
35703: LD_ADDR_VAR 0 6
35707: PUSH
35708: LD_VAR 0 6
35712: PUSH
35713: LD_EXP 92
35717: PUSH
35718: LD_VAR 0 2
35722: ARRAY
35723: DIFF
35724: ST_TO_ADDR
// if not list then
35725: LD_VAR 0 6
35729: NOT
35730: IFFALSE 35734
// continue ;
35732: GO 35100
// k := mc_mines [ i ] - mc_miners [ i ] ;
35734: LD_ADDR_VAR 0 4
35738: PUSH
35739: LD_EXP 91
35743: PUSH
35744: LD_VAR 0 2
35748: ARRAY
35749: PUSH
35750: LD_EXP 92
35754: PUSH
35755: LD_VAR 0 2
35759: ARRAY
35760: MINUS
35761: ST_TO_ADDR
// if k > list then
35762: LD_VAR 0 4
35766: PUSH
35767: LD_VAR 0 6
35771: GREATER
35772: IFFALSE 35784
// k := list ;
35774: LD_ADDR_VAR 0 4
35778: PUSH
35779: LD_VAR 0 6
35783: ST_TO_ADDR
// for j = 1 to k do
35784: LD_ADDR_VAR 0 3
35788: PUSH
35789: DOUBLE
35790: LD_INT 1
35792: DEC
35793: ST_TO_ADDR
35794: LD_VAR 0 4
35798: PUSH
35799: FOR_TO
35800: IFFALSE 35854
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
35802: LD_ADDR_EXP 92
35806: PUSH
35807: LD_EXP 92
35811: PPUSH
35812: LD_VAR 0 2
35816: PUSH
35817: LD_EXP 92
35821: PUSH
35822: LD_VAR 0 2
35826: ARRAY
35827: PUSH
35828: LD_INT 1
35830: PLUS
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PPUSH
35836: LD_VAR 0 6
35840: PUSH
35841: LD_VAR 0 3
35845: ARRAY
35846: PPUSH
35847: CALL 58220 0 3
35851: ST_TO_ADDR
35852: GO 35799
35854: POP
35855: POP
// end ;
35856: GO 35100
35858: POP
35859: POP
// end ;
35860: LD_VAR 0 1
35864: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
35865: LD_INT 0
35867: PPUSH
35868: PPUSH
35869: PPUSH
35870: PPUSH
35871: PPUSH
35872: PPUSH
35873: PPUSH
35874: PPUSH
35875: PPUSH
35876: PPUSH
35877: PPUSH
// if not mc_bases then
35878: LD_EXP 78
35882: NOT
35883: IFFALSE 35887
// exit ;
35885: GO 37710
// for i = 1 to mc_bases do
35887: LD_ADDR_VAR 0 2
35891: PUSH
35892: DOUBLE
35893: LD_INT 1
35895: DEC
35896: ST_TO_ADDR
35897: LD_EXP 78
35901: PUSH
35902: FOR_TO
35903: IFFALSE 37708
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
35905: LD_EXP 78
35909: PUSH
35910: LD_VAR 0 2
35914: ARRAY
35915: NOT
35916: PUSH
35917: LD_EXP 85
35921: PUSH
35922: LD_VAR 0 2
35926: ARRAY
35927: OR
35928: IFFALSE 35932
// continue ;
35930: GO 35902
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
35932: LD_EXP 94
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: NOT
35943: PUSH
35944: LD_EXP 95
35948: PUSH
35949: LD_VAR 0 2
35953: ARRAY
35954: AND
35955: IFFALSE 35993
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
35957: LD_ADDR_EXP 95
35961: PUSH
35962: LD_EXP 95
35966: PPUSH
35967: LD_VAR 0 2
35971: PPUSH
35972: EMPTY
35973: PPUSH
35974: CALL_OW 1
35978: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
35979: LD_VAR 0 2
35983: PPUSH
35984: LD_INT 107
35986: PPUSH
35987: CALL 26719 0 2
// continue ;
35991: GO 35902
// end ; target := [ ] ;
35993: LD_ADDR_VAR 0 7
35997: PUSH
35998: EMPTY
35999: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36000: LD_ADDR_VAR 0 6
36004: PUSH
36005: LD_EXP 78
36009: PUSH
36010: LD_VAR 0 2
36014: ARRAY
36015: PUSH
36016: LD_INT 1
36018: ARRAY
36019: PPUSH
36020: CALL_OW 255
36024: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36025: LD_ADDR_VAR 0 9
36029: PUSH
36030: LD_EXP 78
36034: PUSH
36035: LD_VAR 0 2
36039: ARRAY
36040: PPUSH
36041: LD_INT 2
36043: PUSH
36044: LD_INT 30
36046: PUSH
36047: LD_INT 0
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 30
36056: PUSH
36057: LD_INT 1
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: LIST
36068: PPUSH
36069: CALL_OW 72
36073: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
36074: LD_ADDR_VAR 0 3
36078: PUSH
36079: DOUBLE
36080: LD_EXP 94
36084: PUSH
36085: LD_VAR 0 2
36089: ARRAY
36090: INC
36091: ST_TO_ADDR
36092: LD_INT 1
36094: PUSH
36095: FOR_DOWNTO
36096: IFFALSE 36341
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
36098: LD_EXP 94
36102: PUSH
36103: LD_VAR 0 2
36107: ARRAY
36108: PUSH
36109: LD_VAR 0 3
36113: ARRAY
36114: PUSH
36115: LD_INT 2
36117: ARRAY
36118: PPUSH
36119: LD_EXP 94
36123: PUSH
36124: LD_VAR 0 2
36128: ARRAY
36129: PUSH
36130: LD_VAR 0 3
36134: ARRAY
36135: PUSH
36136: LD_INT 3
36138: ARRAY
36139: PPUSH
36140: CALL_OW 488
36144: PUSH
36145: LD_EXP 94
36149: PUSH
36150: LD_VAR 0 2
36154: ARRAY
36155: PUSH
36156: LD_VAR 0 3
36160: ARRAY
36161: PUSH
36162: LD_INT 2
36164: ARRAY
36165: PPUSH
36166: LD_EXP 94
36170: PUSH
36171: LD_VAR 0 2
36175: ARRAY
36176: PUSH
36177: LD_VAR 0 3
36181: ARRAY
36182: PUSH
36183: LD_INT 3
36185: ARRAY
36186: PPUSH
36187: CALL_OW 284
36191: PUSH
36192: LD_INT 0
36194: EQUAL
36195: AND
36196: IFFALSE 36251
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
36198: LD_ADDR_VAR 0 5
36202: PUSH
36203: LD_EXP 94
36207: PUSH
36208: LD_VAR 0 2
36212: ARRAY
36213: PPUSH
36214: LD_VAR 0 3
36218: PPUSH
36219: CALL_OW 3
36223: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
36224: LD_ADDR_EXP 94
36228: PUSH
36229: LD_EXP 94
36233: PPUSH
36234: LD_VAR 0 2
36238: PPUSH
36239: LD_VAR 0 5
36243: PPUSH
36244: CALL_OW 1
36248: ST_TO_ADDR
// continue ;
36249: GO 36095
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
36251: LD_VAR 0 6
36255: PPUSH
36256: LD_EXP 94
36260: PUSH
36261: LD_VAR 0 2
36265: ARRAY
36266: PUSH
36267: LD_VAR 0 3
36271: ARRAY
36272: PUSH
36273: LD_INT 2
36275: ARRAY
36276: PPUSH
36277: LD_EXP 94
36281: PUSH
36282: LD_VAR 0 2
36286: ARRAY
36287: PUSH
36288: LD_VAR 0 3
36292: ARRAY
36293: PUSH
36294: LD_INT 3
36296: ARRAY
36297: PPUSH
36298: LD_INT 30
36300: PPUSH
36301: CALL 59484 0 4
36305: PUSH
36306: LD_INT 4
36308: ARRAY
36309: PUSH
36310: LD_INT 0
36312: EQUAL
36313: IFFALSE 36339
// begin target := mc_crates [ i ] [ j ] ;
36315: LD_ADDR_VAR 0 7
36319: PUSH
36320: LD_EXP 94
36324: PUSH
36325: LD_VAR 0 2
36329: ARRAY
36330: PUSH
36331: LD_VAR 0 3
36335: ARRAY
36336: ST_TO_ADDR
// break ;
36337: GO 36341
// end ; end ;
36339: GO 36095
36341: POP
36342: POP
// if not target then
36343: LD_VAR 0 7
36347: NOT
36348: IFFALSE 36352
// continue ;
36350: GO 35902
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
36352: LD_ADDR_VAR 0 8
36356: PUSH
36357: LD_EXP 97
36361: PUSH
36362: LD_VAR 0 2
36366: ARRAY
36367: PPUSH
36368: LD_INT 2
36370: PUSH
36371: LD_INT 3
36373: PUSH
36374: LD_INT 58
36376: PUSH
36377: EMPTY
36378: LIST
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 61
36386: PUSH
36387: EMPTY
36388: LIST
36389: PUSH
36390: LD_INT 33
36392: PUSH
36393: LD_INT 5
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 33
36402: PUSH
36403: LD_INT 3
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: EMPTY
36411: LIST
36412: LIST
36413: LIST
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 2
36419: PUSH
36420: LD_INT 34
36422: PUSH
36423: LD_INT 32
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 34
36432: PUSH
36433: LD_INT 51
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: LD_INT 34
36442: PUSH
36443: LD_INT 12
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PPUSH
36460: CALL_OW 72
36464: ST_TO_ADDR
// if not cargo then
36465: LD_VAR 0 8
36469: NOT
36470: IFFALSE 37176
// begin if mc_crates_collector [ i ] < 5 then
36472: LD_EXP 95
36476: PUSH
36477: LD_VAR 0 2
36481: ARRAY
36482: PUSH
36483: LD_INT 5
36485: LESS
36486: IFFALSE 36852
// begin if mc_ape [ i ] then
36488: LD_EXP 107
36492: PUSH
36493: LD_VAR 0 2
36497: ARRAY
36498: IFFALSE 36545
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36500: LD_ADDR_VAR 0 5
36504: PUSH
36505: LD_EXP 107
36509: PUSH
36510: LD_VAR 0 2
36514: ARRAY
36515: PPUSH
36516: LD_INT 25
36518: PUSH
36519: LD_INT 16
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: LD_INT 24
36528: PUSH
36529: LD_INT 750
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PPUSH
36540: CALL_OW 72
36544: ST_TO_ADDR
// if not tmp then
36545: LD_VAR 0 5
36549: NOT
36550: IFFALSE 36597
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
36552: LD_ADDR_VAR 0 5
36556: PUSH
36557: LD_EXP 78
36561: PUSH
36562: LD_VAR 0 2
36566: ARRAY
36567: PPUSH
36568: LD_INT 25
36570: PUSH
36571: LD_INT 2
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: PUSH
36578: LD_INT 24
36580: PUSH
36581: LD_INT 750
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PPUSH
36592: CALL_OW 72
36596: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
36597: LD_EXP 107
36601: PUSH
36602: LD_VAR 0 2
36606: ARRAY
36607: PUSH
36608: LD_EXP 78
36612: PUSH
36613: LD_VAR 0 2
36617: ARRAY
36618: PPUSH
36619: LD_INT 25
36621: PUSH
36622: LD_INT 2
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: LD_INT 24
36631: PUSH
36632: LD_INT 750
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PPUSH
36643: CALL_OW 72
36647: AND
36648: PUSH
36649: LD_VAR 0 5
36653: PUSH
36654: LD_INT 5
36656: LESS
36657: AND
36658: IFFALSE 36740
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
36660: LD_ADDR_VAR 0 3
36664: PUSH
36665: LD_EXP 78
36669: PUSH
36670: LD_VAR 0 2
36674: ARRAY
36675: PPUSH
36676: LD_INT 25
36678: PUSH
36679: LD_INT 2
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 24
36688: PUSH
36689: LD_INT 750
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: PPUSH
36700: CALL_OW 72
36704: PUSH
36705: FOR_IN
36706: IFFALSE 36738
// begin tmp := tmp union j ;
36708: LD_ADDR_VAR 0 5
36712: PUSH
36713: LD_VAR 0 5
36717: PUSH
36718: LD_VAR 0 3
36722: UNION
36723: ST_TO_ADDR
// if tmp >= 5 then
36724: LD_VAR 0 5
36728: PUSH
36729: LD_INT 5
36731: GREATEREQUAL
36732: IFFALSE 36736
// break ;
36734: GO 36738
// end ;
36736: GO 36705
36738: POP
36739: POP
// end ; if not tmp then
36740: LD_VAR 0 5
36744: NOT
36745: IFFALSE 36749
// continue ;
36747: GO 35902
// for j in tmp do
36749: LD_ADDR_VAR 0 3
36753: PUSH
36754: LD_VAR 0 5
36758: PUSH
36759: FOR_IN
36760: IFFALSE 36850
// if not GetTag ( j ) then
36762: LD_VAR 0 3
36766: PPUSH
36767: CALL_OW 110
36771: NOT
36772: IFFALSE 36848
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
36774: LD_ADDR_EXP 95
36778: PUSH
36779: LD_EXP 95
36783: PPUSH
36784: LD_VAR 0 2
36788: PUSH
36789: LD_EXP 95
36793: PUSH
36794: LD_VAR 0 2
36798: ARRAY
36799: PUSH
36800: LD_INT 1
36802: PLUS
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PPUSH
36808: LD_VAR 0 3
36812: PPUSH
36813: CALL 58220 0 3
36817: ST_TO_ADDR
// SetTag ( j , 107 ) ;
36818: LD_VAR 0 3
36822: PPUSH
36823: LD_INT 107
36825: PPUSH
36826: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
36830: LD_EXP 95
36834: PUSH
36835: LD_VAR 0 2
36839: ARRAY
36840: PUSH
36841: LD_INT 5
36843: GREATEREQUAL
36844: IFFALSE 36848
// break ;
36846: GO 36850
// end ;
36848: GO 36759
36850: POP
36851: POP
// end ; if mc_crates_collector [ i ] and target then
36852: LD_EXP 95
36856: PUSH
36857: LD_VAR 0 2
36861: ARRAY
36862: PUSH
36863: LD_VAR 0 7
36867: AND
36868: IFFALSE 37174
// begin if mc_crates_collector [ i ] < target [ 1 ] then
36870: LD_EXP 95
36874: PUSH
36875: LD_VAR 0 2
36879: ARRAY
36880: PUSH
36881: LD_VAR 0 7
36885: PUSH
36886: LD_INT 1
36888: ARRAY
36889: LESS
36890: IFFALSE 36910
// tmp := mc_crates_collector [ i ] else
36892: LD_ADDR_VAR 0 5
36896: PUSH
36897: LD_EXP 95
36901: PUSH
36902: LD_VAR 0 2
36906: ARRAY
36907: ST_TO_ADDR
36908: GO 36924
// tmp := target [ 1 ] ;
36910: LD_ADDR_VAR 0 5
36914: PUSH
36915: LD_VAR 0 7
36919: PUSH
36920: LD_INT 1
36922: ARRAY
36923: ST_TO_ADDR
// k := 0 ;
36924: LD_ADDR_VAR 0 4
36928: PUSH
36929: LD_INT 0
36931: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
36932: LD_ADDR_VAR 0 3
36936: PUSH
36937: LD_EXP 95
36941: PUSH
36942: LD_VAR 0 2
36946: ARRAY
36947: PUSH
36948: FOR_IN
36949: IFFALSE 37172
// begin k := k + 1 ;
36951: LD_ADDR_VAR 0 4
36955: PUSH
36956: LD_VAR 0 4
36960: PUSH
36961: LD_INT 1
36963: PLUS
36964: ST_TO_ADDR
// if k > tmp then
36965: LD_VAR 0 4
36969: PUSH
36970: LD_VAR 0 5
36974: GREATER
36975: IFFALSE 36979
// break ;
36977: GO 37172
// if not GetClass ( j ) in [ 2 , 16 ] then
36979: LD_VAR 0 3
36983: PPUSH
36984: CALL_OW 257
36988: PUSH
36989: LD_INT 2
36991: PUSH
36992: LD_INT 16
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: IN
36999: NOT
37000: IFFALSE 37053
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
37002: LD_ADDR_EXP 95
37006: PUSH
37007: LD_EXP 95
37011: PPUSH
37012: LD_VAR 0 2
37016: PPUSH
37017: LD_EXP 95
37021: PUSH
37022: LD_VAR 0 2
37026: ARRAY
37027: PUSH
37028: LD_VAR 0 3
37032: DIFF
37033: PPUSH
37034: CALL_OW 1
37038: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37039: LD_VAR 0 3
37043: PPUSH
37044: LD_INT 0
37046: PPUSH
37047: CALL_OW 109
// continue ;
37051: GO 36948
// end ; if IsInUnit ( j ) then
37053: LD_VAR 0 3
37057: PPUSH
37058: CALL_OW 310
37062: IFFALSE 37073
// ComExitBuilding ( j ) ;
37064: LD_VAR 0 3
37068: PPUSH
37069: CALL_OW 122
// wait ( 3 ) ;
37073: LD_INT 3
37075: PPUSH
37076: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
37080: LD_VAR 0 3
37084: PPUSH
37085: CALL_OW 314
37089: PUSH
37090: LD_VAR 0 6
37094: PPUSH
37095: LD_VAR 0 7
37099: PUSH
37100: LD_INT 2
37102: ARRAY
37103: PPUSH
37104: LD_VAR 0 7
37108: PUSH
37109: LD_INT 3
37111: ARRAY
37112: PPUSH
37113: LD_INT 30
37115: PPUSH
37116: CALL 59484 0 4
37120: PUSH
37121: LD_INT 4
37123: ARRAY
37124: AND
37125: IFFALSE 37143
// ComStandNearbyBuilding ( j , depot ) else
37127: LD_VAR 0 3
37131: PPUSH
37132: LD_VAR 0 9
37136: PPUSH
37137: CALL 54822 0 2
37141: GO 37170
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37143: LD_VAR 0 3
37147: PPUSH
37148: LD_VAR 0 7
37152: PUSH
37153: LD_INT 2
37155: ARRAY
37156: PPUSH
37157: LD_VAR 0 7
37161: PUSH
37162: LD_INT 3
37164: ARRAY
37165: PPUSH
37166: CALL_OW 117
// end ;
37170: GO 36948
37172: POP
37173: POP
// end ; end else
37174: GO 37706
// begin for j in cargo do
37176: LD_ADDR_VAR 0 3
37180: PUSH
37181: LD_VAR 0 8
37185: PUSH
37186: FOR_IN
37187: IFFALSE 37704
// begin if GetTag ( j ) <> 0 then
37189: LD_VAR 0 3
37193: PPUSH
37194: CALL_OW 110
37198: PUSH
37199: LD_INT 0
37201: NONEQUAL
37202: IFFALSE 37206
// continue ;
37204: GO 37186
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
37206: LD_VAR 0 3
37210: PPUSH
37211: CALL_OW 256
37215: PUSH
37216: LD_INT 1000
37218: LESS
37219: PUSH
37220: LD_VAR 0 3
37224: PPUSH
37225: LD_EXP 102
37229: PUSH
37230: LD_VAR 0 2
37234: ARRAY
37235: PPUSH
37236: CALL_OW 308
37240: NOT
37241: AND
37242: IFFALSE 37264
// ComMoveToArea ( j , mc_parking [ i ] ) ;
37244: LD_VAR 0 3
37248: PPUSH
37249: LD_EXP 102
37253: PUSH
37254: LD_VAR 0 2
37258: ARRAY
37259: PPUSH
37260: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
37264: LD_VAR 0 3
37268: PPUSH
37269: CALL_OW 256
37273: PUSH
37274: LD_INT 1000
37276: LESS
37277: PUSH
37278: LD_VAR 0 3
37282: PPUSH
37283: LD_EXP 102
37287: PUSH
37288: LD_VAR 0 2
37292: ARRAY
37293: PPUSH
37294: CALL_OW 308
37298: AND
37299: IFFALSE 37303
// continue ;
37301: GO 37186
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
37303: LD_VAR 0 3
37307: PPUSH
37308: CALL_OW 262
37312: PUSH
37313: LD_INT 2
37315: EQUAL
37316: PUSH
37317: LD_VAR 0 3
37321: PPUSH
37322: CALL_OW 261
37326: PUSH
37327: LD_INT 15
37329: LESS
37330: AND
37331: IFFALSE 37335
// continue ;
37333: GO 37186
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
37335: LD_VAR 0 3
37339: PPUSH
37340: CALL_OW 262
37344: PUSH
37345: LD_INT 1
37347: EQUAL
37348: PUSH
37349: LD_VAR 0 3
37353: PPUSH
37354: CALL_OW 261
37358: PUSH
37359: LD_INT 10
37361: LESS
37362: AND
37363: IFFALSE 37643
// begin if not depot then
37365: LD_VAR 0 9
37369: NOT
37370: IFFALSE 37374
// continue ;
37372: GO 37186
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
37374: LD_VAR 0 3
37378: PPUSH
37379: LD_VAR 0 9
37383: PPUSH
37384: LD_VAR 0 3
37388: PPUSH
37389: CALL_OW 74
37393: PPUSH
37394: CALL_OW 296
37398: PUSH
37399: LD_INT 6
37401: LESS
37402: IFFALSE 37418
// SetFuel ( j , 100 ) else
37404: LD_VAR 0 3
37408: PPUSH
37409: LD_INT 100
37411: PPUSH
37412: CALL_OW 240
37416: GO 37643
// if GetFuel ( j ) = 0 then
37418: LD_VAR 0 3
37422: PPUSH
37423: CALL_OW 261
37427: PUSH
37428: LD_INT 0
37430: EQUAL
37431: IFFALSE 37643
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
37433: LD_ADDR_EXP 97
37437: PUSH
37438: LD_EXP 97
37442: PPUSH
37443: LD_VAR 0 2
37447: PPUSH
37448: LD_EXP 97
37452: PUSH
37453: LD_VAR 0 2
37457: ARRAY
37458: PUSH
37459: LD_VAR 0 3
37463: DIFF
37464: PPUSH
37465: CALL_OW 1
37469: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37470: LD_VAR 0 3
37474: PPUSH
37475: CALL_OW 263
37479: PUSH
37480: LD_INT 1
37482: EQUAL
37483: IFFALSE 37499
// ComExitVehicle ( IsInUnit ( j ) ) ;
37485: LD_VAR 0 3
37489: PPUSH
37490: CALL_OW 310
37494: PPUSH
37495: CALL_OW 121
// if GetControl ( j ) = control_remote then
37499: LD_VAR 0 3
37503: PPUSH
37504: CALL_OW 263
37508: PUSH
37509: LD_INT 2
37511: EQUAL
37512: IFFALSE 37523
// ComUnlink ( j ) ;
37514: LD_VAR 0 3
37518: PPUSH
37519: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37523: LD_ADDR_VAR 0 10
37527: PUSH
37528: LD_VAR 0 2
37532: PPUSH
37533: LD_INT 3
37535: PPUSH
37536: CALL 47287 0 2
37540: ST_TO_ADDR
// if fac then
37541: LD_VAR 0 10
37545: IFFALSE 37641
// begin for k in fac do
37547: LD_ADDR_VAR 0 4
37551: PUSH
37552: LD_VAR 0 10
37556: PUSH
37557: FOR_IN
37558: IFFALSE 37639
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
37560: LD_ADDR_VAR 0 11
37564: PUSH
37565: LD_VAR 0 10
37569: PPUSH
37570: LD_VAR 0 3
37574: PPUSH
37575: CALL_OW 265
37579: PPUSH
37580: LD_VAR 0 3
37584: PPUSH
37585: CALL_OW 262
37589: PPUSH
37590: LD_VAR 0 3
37594: PPUSH
37595: CALL_OW 263
37599: PPUSH
37600: LD_VAR 0 3
37604: PPUSH
37605: CALL_OW 264
37609: PPUSH
37610: CALL 55718 0 5
37614: ST_TO_ADDR
// if components then
37615: LD_VAR 0 11
37619: IFFALSE 37637
// begin MC_InsertProduceList ( i , components ) ;
37621: LD_VAR 0 2
37625: PPUSH
37626: LD_VAR 0 11
37630: PPUSH
37631: CALL 46832 0 2
// break ;
37635: GO 37639
// end ; end ;
37637: GO 37557
37639: POP
37640: POP
// end ; continue ;
37641: GO 37186
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
37643: LD_VAR 0 3
37647: PPUSH
37648: LD_INT 1
37650: PPUSH
37651: CALL_OW 289
37655: PUSH
37656: LD_INT 100
37658: LESS
37659: PUSH
37660: LD_VAR 0 3
37664: PPUSH
37665: CALL_OW 314
37669: NOT
37670: AND
37671: IFFALSE 37700
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37673: LD_VAR 0 3
37677: PPUSH
37678: LD_VAR 0 7
37682: PUSH
37683: LD_INT 2
37685: ARRAY
37686: PPUSH
37687: LD_VAR 0 7
37691: PUSH
37692: LD_INT 3
37694: ARRAY
37695: PPUSH
37696: CALL_OW 117
// break ;
37700: GO 37704
// end ;
37702: GO 37186
37704: POP
37705: POP
// end ; end ;
37706: GO 35902
37708: POP
37709: POP
// end ;
37710: LD_VAR 0 1
37714: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
37715: LD_INT 0
37717: PPUSH
37718: PPUSH
37719: PPUSH
37720: PPUSH
// if not mc_bases then
37721: LD_EXP 78
37725: NOT
37726: IFFALSE 37730
// exit ;
37728: GO 37891
// for i = 1 to mc_bases do
37730: LD_ADDR_VAR 0 2
37734: PUSH
37735: DOUBLE
37736: LD_INT 1
37738: DEC
37739: ST_TO_ADDR
37740: LD_EXP 78
37744: PUSH
37745: FOR_TO
37746: IFFALSE 37889
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
37748: LD_ADDR_VAR 0 4
37752: PUSH
37753: LD_EXP 97
37757: PUSH
37758: LD_VAR 0 2
37762: ARRAY
37763: PUSH
37764: LD_EXP 100
37768: PUSH
37769: LD_VAR 0 2
37773: ARRAY
37774: UNION
37775: PPUSH
37776: LD_INT 33
37778: PUSH
37779: LD_INT 2
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PPUSH
37786: CALL_OW 72
37790: ST_TO_ADDR
// if tmp then
37791: LD_VAR 0 4
37795: IFFALSE 37887
// for j in tmp do
37797: LD_ADDR_VAR 0 3
37801: PUSH
37802: LD_VAR 0 4
37806: PUSH
37807: FOR_IN
37808: IFFALSE 37885
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
37810: LD_VAR 0 3
37814: PPUSH
37815: CALL_OW 312
37819: NOT
37820: PUSH
37821: LD_VAR 0 3
37825: PPUSH
37826: CALL_OW 256
37830: PUSH
37831: LD_INT 250
37833: GREATEREQUAL
37834: AND
37835: IFFALSE 37848
// Connect ( j ) else
37837: LD_VAR 0 3
37841: PPUSH
37842: CALL 61566 0 1
37846: GO 37883
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
37848: LD_VAR 0 3
37852: PPUSH
37853: CALL_OW 256
37857: PUSH
37858: LD_INT 250
37860: LESS
37861: PUSH
37862: LD_VAR 0 3
37866: PPUSH
37867: CALL_OW 312
37871: AND
37872: IFFALSE 37883
// ComUnlink ( j ) ;
37874: LD_VAR 0 3
37878: PPUSH
37879: CALL_OW 136
37883: GO 37807
37885: POP
37886: POP
// end ;
37887: GO 37745
37889: POP
37890: POP
// end ;
37891: LD_VAR 0 1
37895: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
37896: LD_INT 0
37898: PPUSH
37899: PPUSH
37900: PPUSH
37901: PPUSH
37902: PPUSH
// if not mc_bases then
37903: LD_EXP 78
37907: NOT
37908: IFFALSE 37912
// exit ;
37910: GO 38357
// for i = 1 to mc_bases do
37912: LD_ADDR_VAR 0 2
37916: PUSH
37917: DOUBLE
37918: LD_INT 1
37920: DEC
37921: ST_TO_ADDR
37922: LD_EXP 78
37926: PUSH
37927: FOR_TO
37928: IFFALSE 38355
// begin if not mc_produce [ i ] then
37930: LD_EXP 99
37934: PUSH
37935: LD_VAR 0 2
37939: ARRAY
37940: NOT
37941: IFFALSE 37945
// continue ;
37943: GO 37927
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37945: LD_ADDR_VAR 0 5
37949: PUSH
37950: LD_EXP 78
37954: PUSH
37955: LD_VAR 0 2
37959: ARRAY
37960: PPUSH
37961: LD_INT 30
37963: PUSH
37964: LD_INT 3
37966: PUSH
37967: EMPTY
37968: LIST
37969: LIST
37970: PPUSH
37971: CALL_OW 72
37975: ST_TO_ADDR
// if not fac then
37976: LD_VAR 0 5
37980: NOT
37981: IFFALSE 37985
// continue ;
37983: GO 37927
// for j in fac do
37985: LD_ADDR_VAR 0 3
37989: PUSH
37990: LD_VAR 0 5
37994: PUSH
37995: FOR_IN
37996: IFFALSE 38351
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
37998: LD_VAR 0 3
38002: PPUSH
38003: CALL_OW 461
38007: PUSH
38008: LD_INT 2
38010: NONEQUAL
38011: PUSH
38012: LD_VAR 0 3
38016: PPUSH
38017: LD_INT 15
38019: PPUSH
38020: CALL 61185 0 2
38024: PUSH
38025: LD_INT 4
38027: ARRAY
38028: OR
38029: IFFALSE 38033
// continue ;
38031: GO 37995
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
38033: LD_VAR 0 3
38037: PPUSH
38038: LD_EXP 99
38042: PUSH
38043: LD_VAR 0 2
38047: ARRAY
38048: PUSH
38049: LD_INT 1
38051: ARRAY
38052: PUSH
38053: LD_INT 1
38055: ARRAY
38056: PPUSH
38057: LD_EXP 99
38061: PUSH
38062: LD_VAR 0 2
38066: ARRAY
38067: PUSH
38068: LD_INT 1
38070: ARRAY
38071: PUSH
38072: LD_INT 2
38074: ARRAY
38075: PPUSH
38076: LD_EXP 99
38080: PUSH
38081: LD_VAR 0 2
38085: ARRAY
38086: PUSH
38087: LD_INT 1
38089: ARRAY
38090: PUSH
38091: LD_INT 3
38093: ARRAY
38094: PPUSH
38095: LD_EXP 99
38099: PUSH
38100: LD_VAR 0 2
38104: ARRAY
38105: PUSH
38106: LD_INT 1
38108: ARRAY
38109: PUSH
38110: LD_INT 4
38112: ARRAY
38113: PPUSH
38114: CALL_OW 448
38118: PUSH
38119: LD_VAR 0 3
38123: PPUSH
38124: LD_EXP 99
38128: PUSH
38129: LD_VAR 0 2
38133: ARRAY
38134: PUSH
38135: LD_INT 1
38137: ARRAY
38138: PUSH
38139: LD_INT 1
38141: ARRAY
38142: PUSH
38143: LD_EXP 99
38147: PUSH
38148: LD_VAR 0 2
38152: ARRAY
38153: PUSH
38154: LD_INT 1
38156: ARRAY
38157: PUSH
38158: LD_INT 2
38160: ARRAY
38161: PUSH
38162: LD_EXP 99
38166: PUSH
38167: LD_VAR 0 2
38171: ARRAY
38172: PUSH
38173: LD_INT 1
38175: ARRAY
38176: PUSH
38177: LD_INT 3
38179: ARRAY
38180: PUSH
38181: LD_EXP 99
38185: PUSH
38186: LD_VAR 0 2
38190: ARRAY
38191: PUSH
38192: LD_INT 1
38194: ARRAY
38195: PUSH
38196: LD_INT 4
38198: ARRAY
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: LIST
38204: LIST
38205: PPUSH
38206: CALL 64961 0 2
38210: AND
38211: IFFALSE 38349
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
38213: LD_VAR 0 3
38217: PPUSH
38218: LD_EXP 99
38222: PUSH
38223: LD_VAR 0 2
38227: ARRAY
38228: PUSH
38229: LD_INT 1
38231: ARRAY
38232: PUSH
38233: LD_INT 1
38235: ARRAY
38236: PPUSH
38237: LD_EXP 99
38241: PUSH
38242: LD_VAR 0 2
38246: ARRAY
38247: PUSH
38248: LD_INT 1
38250: ARRAY
38251: PUSH
38252: LD_INT 2
38254: ARRAY
38255: PPUSH
38256: LD_EXP 99
38260: PUSH
38261: LD_VAR 0 2
38265: ARRAY
38266: PUSH
38267: LD_INT 1
38269: ARRAY
38270: PUSH
38271: LD_INT 3
38273: ARRAY
38274: PPUSH
38275: LD_EXP 99
38279: PUSH
38280: LD_VAR 0 2
38284: ARRAY
38285: PUSH
38286: LD_INT 1
38288: ARRAY
38289: PUSH
38290: LD_INT 4
38292: ARRAY
38293: PPUSH
38294: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
38298: LD_ADDR_VAR 0 4
38302: PUSH
38303: LD_EXP 99
38307: PUSH
38308: LD_VAR 0 2
38312: ARRAY
38313: PPUSH
38314: LD_INT 1
38316: PPUSH
38317: CALL_OW 3
38321: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
38322: LD_ADDR_EXP 99
38326: PUSH
38327: LD_EXP 99
38331: PPUSH
38332: LD_VAR 0 2
38336: PPUSH
38337: LD_VAR 0 4
38341: PPUSH
38342: CALL_OW 1
38346: ST_TO_ADDR
// break ;
38347: GO 38351
// end ; end ;
38349: GO 37995
38351: POP
38352: POP
// end ;
38353: GO 37927
38355: POP
38356: POP
// end ;
38357: LD_VAR 0 1
38361: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
38362: LD_INT 0
38364: PPUSH
38365: PPUSH
38366: PPUSH
// if not mc_bases then
38367: LD_EXP 78
38371: NOT
38372: IFFALSE 38376
// exit ;
38374: GO 38465
// for i = 1 to mc_bases do
38376: LD_ADDR_VAR 0 2
38380: PUSH
38381: DOUBLE
38382: LD_INT 1
38384: DEC
38385: ST_TO_ADDR
38386: LD_EXP 78
38390: PUSH
38391: FOR_TO
38392: IFFALSE 38463
// begin if mc_attack [ i ] then
38394: LD_EXP 98
38398: PUSH
38399: LD_VAR 0 2
38403: ARRAY
38404: IFFALSE 38461
// begin tmp := mc_attack [ i ] [ 1 ] ;
38406: LD_ADDR_VAR 0 3
38410: PUSH
38411: LD_EXP 98
38415: PUSH
38416: LD_VAR 0 2
38420: ARRAY
38421: PUSH
38422: LD_INT 1
38424: ARRAY
38425: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38426: LD_ADDR_EXP 98
38430: PUSH
38431: LD_EXP 98
38435: PPUSH
38436: LD_VAR 0 2
38440: PPUSH
38441: EMPTY
38442: PPUSH
38443: CALL_OW 1
38447: ST_TO_ADDR
// Attack ( tmp ) ;
38448: LD_VAR 0 3
38452: PPUSH
38453: CALL 116186 0 1
// exit ;
38457: POP
38458: POP
38459: GO 38465
// end ; end ;
38461: GO 38391
38463: POP
38464: POP
// end ;
38465: LD_VAR 0 1
38469: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38470: LD_INT 0
38472: PPUSH
38473: PPUSH
38474: PPUSH
38475: PPUSH
38476: PPUSH
38477: PPUSH
38478: PPUSH
// if not mc_bases then
38479: LD_EXP 78
38483: NOT
38484: IFFALSE 38488
// exit ;
38486: GO 39345
// for i = 1 to mc_bases do
38488: LD_ADDR_VAR 0 2
38492: PUSH
38493: DOUBLE
38494: LD_INT 1
38496: DEC
38497: ST_TO_ADDR
38498: LD_EXP 78
38502: PUSH
38503: FOR_TO
38504: IFFALSE 39343
// begin if not mc_bases [ i ] then
38506: LD_EXP 78
38510: PUSH
38511: LD_VAR 0 2
38515: ARRAY
38516: NOT
38517: IFFALSE 38521
// continue ;
38519: GO 38503
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38521: LD_ADDR_VAR 0 7
38525: PUSH
38526: LD_EXP 78
38530: PUSH
38531: LD_VAR 0 2
38535: ARRAY
38536: PUSH
38537: LD_INT 1
38539: ARRAY
38540: PPUSH
38541: CALL 55044 0 1
38545: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
38546: LD_ADDR_EXP 101
38550: PUSH
38551: LD_EXP 101
38555: PPUSH
38556: LD_VAR 0 2
38560: PPUSH
38561: LD_EXP 78
38565: PUSH
38566: LD_VAR 0 2
38570: ARRAY
38571: PUSH
38572: LD_INT 1
38574: ARRAY
38575: PPUSH
38576: CALL_OW 255
38580: PPUSH
38581: LD_EXP 103
38585: PUSH
38586: LD_VAR 0 2
38590: ARRAY
38591: PPUSH
38592: CALL 55009 0 2
38596: PPUSH
38597: CALL_OW 1
38601: ST_TO_ADDR
// if not mc_scan [ i ] then
38602: LD_EXP 101
38606: PUSH
38607: LD_VAR 0 2
38611: ARRAY
38612: NOT
38613: IFFALSE 38791
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38615: LD_ADDR_EXP 121
38619: PUSH
38620: LD_EXP 121
38624: PPUSH
38625: LD_VAR 0 2
38629: PPUSH
38630: LD_INT 0
38632: PPUSH
38633: CALL_OW 1
38637: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38638: LD_ADDR_VAR 0 4
38642: PUSH
38643: LD_EXP 78
38647: PUSH
38648: LD_VAR 0 2
38652: ARRAY
38653: PPUSH
38654: LD_INT 2
38656: PUSH
38657: LD_INT 25
38659: PUSH
38660: LD_INT 5
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 25
38669: PUSH
38670: LD_INT 8
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 25
38679: PUSH
38680: LD_INT 9
38682: PUSH
38683: EMPTY
38684: LIST
38685: LIST
38686: PUSH
38687: EMPTY
38688: LIST
38689: LIST
38690: LIST
38691: LIST
38692: PPUSH
38693: CALL_OW 72
38697: ST_TO_ADDR
// if not tmp then
38698: LD_VAR 0 4
38702: NOT
38703: IFFALSE 38707
// continue ;
38705: GO 38503
// for j in tmp do
38707: LD_ADDR_VAR 0 3
38711: PUSH
38712: LD_VAR 0 4
38716: PUSH
38717: FOR_IN
38718: IFFALSE 38789
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
38720: LD_VAR 0 3
38724: PPUSH
38725: CALL_OW 310
38729: PPUSH
38730: CALL_OW 266
38734: PUSH
38735: LD_INT 5
38737: EQUAL
38738: PUSH
38739: LD_VAR 0 3
38743: PPUSH
38744: CALL_OW 257
38748: PUSH
38749: LD_INT 1
38751: EQUAL
38752: AND
38753: PUSH
38754: LD_VAR 0 3
38758: PPUSH
38759: CALL_OW 459
38763: NOT
38764: AND
38765: PUSH
38766: LD_VAR 0 7
38770: AND
38771: IFFALSE 38787
// ComChangeProfession ( j , class ) ;
38773: LD_VAR 0 3
38777: PPUSH
38778: LD_VAR 0 7
38782: PPUSH
38783: CALL_OW 123
38787: GO 38717
38789: POP
38790: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
38791: LD_EXP 101
38795: PUSH
38796: LD_VAR 0 2
38800: ARRAY
38801: PUSH
38802: LD_EXP 121
38806: PUSH
38807: LD_VAR 0 2
38811: ARRAY
38812: NOT
38813: AND
38814: PUSH
38815: LD_EXP 100
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: NOT
38826: AND
38827: PUSH
38828: LD_EXP 78
38832: PUSH
38833: LD_VAR 0 2
38837: ARRAY
38838: PPUSH
38839: LD_INT 50
38841: PUSH
38842: EMPTY
38843: LIST
38844: PUSH
38845: LD_INT 2
38847: PUSH
38848: LD_INT 30
38850: PUSH
38851: LD_INT 32
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: LD_INT 30
38860: PUSH
38861: LD_INT 33
38863: PUSH
38864: EMPTY
38865: LIST
38866: LIST
38867: PUSH
38868: LD_INT 30
38870: PUSH
38871: LD_INT 4
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 30
38880: PUSH
38881: LD_INT 5
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: PUSH
38895: EMPTY
38896: LIST
38897: LIST
38898: PPUSH
38899: CALL_OW 72
38903: PUSH
38904: LD_INT 4
38906: LESS
38907: PUSH
38908: LD_EXP 78
38912: PUSH
38913: LD_VAR 0 2
38917: ARRAY
38918: PPUSH
38919: LD_INT 3
38921: PUSH
38922: LD_INT 24
38924: PUSH
38925: LD_INT 1000
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 2
38938: PUSH
38939: LD_INT 30
38941: PUSH
38942: LD_INT 0
38944: PUSH
38945: EMPTY
38946: LIST
38947: LIST
38948: PUSH
38949: LD_INT 30
38951: PUSH
38952: LD_INT 1
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: LIST
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PPUSH
38968: CALL_OW 72
38972: OR
38973: AND
38974: IFFALSE 39225
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38976: LD_ADDR_EXP 121
38980: PUSH
38981: LD_EXP 121
38985: PPUSH
38986: LD_VAR 0 2
38990: PPUSH
38991: LD_INT 1
38993: PPUSH
38994: CALL_OW 1
38998: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38999: LD_ADDR_VAR 0 4
39003: PUSH
39004: LD_EXP 78
39008: PUSH
39009: LD_VAR 0 2
39013: ARRAY
39014: PPUSH
39015: LD_INT 2
39017: PUSH
39018: LD_INT 25
39020: PUSH
39021: LD_INT 1
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 25
39030: PUSH
39031: LD_INT 5
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 25
39040: PUSH
39041: LD_INT 8
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: LD_INT 25
39050: PUSH
39051: LD_INT 9
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: PPUSH
39065: CALL_OW 72
39069: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
39070: LD_ADDR_VAR 0 4
39074: PUSH
39075: LD_VAR 0 4
39079: PUSH
39080: LD_VAR 0 4
39084: PPUSH
39085: LD_INT 18
39087: PPUSH
39088: CALL 88529 0 2
39092: DIFF
39093: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
39094: LD_VAR 0 4
39098: NOT
39099: PUSH
39100: LD_EXP 78
39104: PUSH
39105: LD_VAR 0 2
39109: ARRAY
39110: PPUSH
39111: LD_INT 2
39113: PUSH
39114: LD_INT 30
39116: PUSH
39117: LD_INT 4
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 30
39126: PUSH
39127: LD_INT 5
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: EMPTY
39135: LIST
39136: LIST
39137: LIST
39138: PPUSH
39139: CALL_OW 72
39143: NOT
39144: AND
39145: IFFALSE 39207
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
39147: LD_ADDR_VAR 0 4
39151: PUSH
39152: LD_EXP 78
39156: PUSH
39157: LD_VAR 0 2
39161: ARRAY
39162: PPUSH
39163: LD_INT 2
39165: PUSH
39166: LD_INT 25
39168: PUSH
39169: LD_INT 2
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 25
39178: PUSH
39179: LD_INT 3
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: LD_INT 25
39188: PUSH
39189: LD_INT 4
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: LIST
39200: LIST
39201: PPUSH
39202: CALL_OW 72
39206: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
39207: LD_VAR 0 2
39211: PPUSH
39212: LD_VAR 0 4
39216: PPUSH
39217: CALL 120895 0 2
// exit ;
39221: POP
39222: POP
39223: GO 39345
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
39225: LD_EXP 101
39229: PUSH
39230: LD_VAR 0 2
39234: ARRAY
39235: PUSH
39236: LD_EXP 121
39240: PUSH
39241: LD_VAR 0 2
39245: ARRAY
39246: NOT
39247: AND
39248: PUSH
39249: LD_EXP 100
39253: PUSH
39254: LD_VAR 0 2
39258: ARRAY
39259: AND
39260: IFFALSE 39341
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39262: LD_ADDR_EXP 121
39266: PUSH
39267: LD_EXP 121
39271: PPUSH
39272: LD_VAR 0 2
39276: PPUSH
39277: LD_INT 1
39279: PPUSH
39280: CALL_OW 1
39284: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
39285: LD_ADDR_VAR 0 4
39289: PUSH
39290: LD_EXP 100
39294: PUSH
39295: LD_VAR 0 2
39299: ARRAY
39300: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39301: LD_ADDR_EXP 100
39305: PUSH
39306: LD_EXP 100
39310: PPUSH
39311: LD_VAR 0 2
39315: PPUSH
39316: EMPTY
39317: PPUSH
39318: CALL_OW 1
39322: ST_TO_ADDR
// Defend ( i , tmp ) ;
39323: LD_VAR 0 2
39327: PPUSH
39328: LD_VAR 0 4
39332: PPUSH
39333: CALL 121491 0 2
// exit ;
39337: POP
39338: POP
39339: GO 39345
// end ; end ;
39341: GO 38503
39343: POP
39344: POP
// end ;
39345: LD_VAR 0 1
39349: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
39350: LD_INT 0
39352: PPUSH
39353: PPUSH
39354: PPUSH
39355: PPUSH
39356: PPUSH
39357: PPUSH
39358: PPUSH
39359: PPUSH
39360: PPUSH
39361: PPUSH
39362: PPUSH
// if not mc_bases then
39363: LD_EXP 78
39367: NOT
39368: IFFALSE 39372
// exit ;
39370: GO 40459
// for i = 1 to mc_bases do
39372: LD_ADDR_VAR 0 2
39376: PUSH
39377: DOUBLE
39378: LD_INT 1
39380: DEC
39381: ST_TO_ADDR
39382: LD_EXP 78
39386: PUSH
39387: FOR_TO
39388: IFFALSE 40457
// begin tmp := mc_lab [ i ] ;
39390: LD_ADDR_VAR 0 6
39394: PUSH
39395: LD_EXP 111
39399: PUSH
39400: LD_VAR 0 2
39404: ARRAY
39405: ST_TO_ADDR
// if not tmp then
39406: LD_VAR 0 6
39410: NOT
39411: IFFALSE 39415
// continue ;
39413: GO 39387
// idle_lab := 0 ;
39415: LD_ADDR_VAR 0 11
39419: PUSH
39420: LD_INT 0
39422: ST_TO_ADDR
// for j in tmp do
39423: LD_ADDR_VAR 0 3
39427: PUSH
39428: LD_VAR 0 6
39432: PUSH
39433: FOR_IN
39434: IFFALSE 40453
// begin researching := false ;
39436: LD_ADDR_VAR 0 10
39440: PUSH
39441: LD_INT 0
39443: ST_TO_ADDR
// side := GetSide ( j ) ;
39444: LD_ADDR_VAR 0 4
39448: PUSH
39449: LD_VAR 0 3
39453: PPUSH
39454: CALL_OW 255
39458: ST_TO_ADDR
// if not mc_tech [ side ] then
39459: LD_EXP 105
39463: PUSH
39464: LD_VAR 0 4
39468: ARRAY
39469: NOT
39470: IFFALSE 39474
// continue ;
39472: GO 39433
// if BuildingStatus ( j ) = bs_idle then
39474: LD_VAR 0 3
39478: PPUSH
39479: CALL_OW 461
39483: PUSH
39484: LD_INT 2
39486: EQUAL
39487: IFFALSE 39675
// begin if idle_lab and UnitsInside ( j ) < 6 then
39489: LD_VAR 0 11
39493: PUSH
39494: LD_VAR 0 3
39498: PPUSH
39499: CALL_OW 313
39503: PUSH
39504: LD_INT 6
39506: LESS
39507: AND
39508: IFFALSE 39579
// begin tmp2 := UnitsInside ( idle_lab ) ;
39510: LD_ADDR_VAR 0 9
39514: PUSH
39515: LD_VAR 0 11
39519: PPUSH
39520: CALL_OW 313
39524: ST_TO_ADDR
// if tmp2 then
39525: LD_VAR 0 9
39529: IFFALSE 39571
// for x in tmp2 do
39531: LD_ADDR_VAR 0 7
39535: PUSH
39536: LD_VAR 0 9
39540: PUSH
39541: FOR_IN
39542: IFFALSE 39569
// begin ComExitBuilding ( x ) ;
39544: LD_VAR 0 7
39548: PPUSH
39549: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39553: LD_VAR 0 7
39557: PPUSH
39558: LD_VAR 0 3
39562: PPUSH
39563: CALL_OW 180
// end ;
39567: GO 39541
39569: POP
39570: POP
// idle_lab := 0 ;
39571: LD_ADDR_VAR 0 11
39575: PUSH
39576: LD_INT 0
39578: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
39579: LD_ADDR_VAR 0 5
39583: PUSH
39584: LD_EXP 105
39588: PUSH
39589: LD_VAR 0 4
39593: ARRAY
39594: PUSH
39595: FOR_IN
39596: IFFALSE 39656
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
39598: LD_VAR 0 3
39602: PPUSH
39603: LD_VAR 0 5
39607: PPUSH
39608: CALL_OW 430
39612: PUSH
39613: LD_VAR 0 4
39617: PPUSH
39618: LD_VAR 0 5
39622: PPUSH
39623: CALL 54114 0 2
39627: AND
39628: IFFALSE 39654
// begin researching := true ;
39630: LD_ADDR_VAR 0 10
39634: PUSH
39635: LD_INT 1
39637: ST_TO_ADDR
// ComResearch ( j , t ) ;
39638: LD_VAR 0 3
39642: PPUSH
39643: LD_VAR 0 5
39647: PPUSH
39648: CALL_OW 124
// break ;
39652: GO 39656
// end ;
39654: GO 39595
39656: POP
39657: POP
// if not researching then
39658: LD_VAR 0 10
39662: NOT
39663: IFFALSE 39675
// idle_lab := j ;
39665: LD_ADDR_VAR 0 11
39669: PUSH
39670: LD_VAR 0 3
39674: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
39675: LD_VAR 0 3
39679: PPUSH
39680: CALL_OW 461
39684: PUSH
39685: LD_INT 10
39687: EQUAL
39688: IFFALSE 40276
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
39690: LD_EXP 107
39694: PUSH
39695: LD_VAR 0 2
39699: ARRAY
39700: NOT
39701: PUSH
39702: LD_EXP 108
39706: PUSH
39707: LD_VAR 0 2
39711: ARRAY
39712: NOT
39713: AND
39714: PUSH
39715: LD_EXP 105
39719: PUSH
39720: LD_VAR 0 4
39724: ARRAY
39725: PUSH
39726: LD_INT 1
39728: GREATER
39729: AND
39730: IFFALSE 39861
// begin ComCancel ( j ) ;
39732: LD_VAR 0 3
39736: PPUSH
39737: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
39741: LD_ADDR_EXP 105
39745: PUSH
39746: LD_EXP 105
39750: PPUSH
39751: LD_VAR 0 4
39755: PPUSH
39756: LD_EXP 105
39760: PUSH
39761: LD_VAR 0 4
39765: ARRAY
39766: PPUSH
39767: LD_EXP 105
39771: PUSH
39772: LD_VAR 0 4
39776: ARRAY
39777: PUSH
39778: LD_INT 1
39780: MINUS
39781: PPUSH
39782: LD_EXP 105
39786: PUSH
39787: LD_VAR 0 4
39791: ARRAY
39792: PPUSH
39793: LD_INT 0
39795: PPUSH
39796: CALL 57638 0 4
39800: PPUSH
39801: CALL_OW 1
39805: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
39806: LD_ADDR_EXP 105
39810: PUSH
39811: LD_EXP 105
39815: PPUSH
39816: LD_VAR 0 4
39820: PPUSH
39821: LD_EXP 105
39825: PUSH
39826: LD_VAR 0 4
39830: ARRAY
39831: PPUSH
39832: LD_EXP 105
39836: PUSH
39837: LD_VAR 0 4
39841: ARRAY
39842: PPUSH
39843: LD_INT 1
39845: PPUSH
39846: LD_INT 0
39848: PPUSH
39849: CALL 57638 0 4
39853: PPUSH
39854: CALL_OW 1
39858: ST_TO_ADDR
// continue ;
39859: GO 39433
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
39861: LD_EXP 107
39865: PUSH
39866: LD_VAR 0 2
39870: ARRAY
39871: PUSH
39872: LD_EXP 108
39876: PUSH
39877: LD_VAR 0 2
39881: ARRAY
39882: NOT
39883: AND
39884: IFFALSE 40011
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
39886: LD_ADDR_EXP 108
39890: PUSH
39891: LD_EXP 108
39895: PPUSH
39896: LD_VAR 0 2
39900: PUSH
39901: LD_EXP 108
39905: PUSH
39906: LD_VAR 0 2
39910: ARRAY
39911: PUSH
39912: LD_INT 1
39914: PLUS
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PPUSH
39920: LD_EXP 107
39924: PUSH
39925: LD_VAR 0 2
39929: ARRAY
39930: PUSH
39931: LD_INT 1
39933: ARRAY
39934: PPUSH
39935: CALL 58220 0 3
39939: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
39940: LD_EXP 107
39944: PUSH
39945: LD_VAR 0 2
39949: ARRAY
39950: PUSH
39951: LD_INT 1
39953: ARRAY
39954: PPUSH
39955: LD_INT 112
39957: PPUSH
39958: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
39962: LD_ADDR_VAR 0 9
39966: PUSH
39967: LD_EXP 107
39971: PUSH
39972: LD_VAR 0 2
39976: ARRAY
39977: PPUSH
39978: LD_INT 1
39980: PPUSH
39981: CALL_OW 3
39985: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
39986: LD_ADDR_EXP 107
39990: PUSH
39991: LD_EXP 107
39995: PPUSH
39996: LD_VAR 0 2
40000: PPUSH
40001: LD_VAR 0 9
40005: PPUSH
40006: CALL_OW 1
40010: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
40011: LD_EXP 107
40015: PUSH
40016: LD_VAR 0 2
40020: ARRAY
40021: PUSH
40022: LD_EXP 108
40026: PUSH
40027: LD_VAR 0 2
40031: ARRAY
40032: AND
40033: PUSH
40034: LD_EXP 108
40038: PUSH
40039: LD_VAR 0 2
40043: ARRAY
40044: PUSH
40045: LD_INT 1
40047: ARRAY
40048: PPUSH
40049: CALL_OW 310
40053: NOT
40054: AND
40055: PUSH
40056: LD_VAR 0 3
40060: PPUSH
40061: CALL_OW 313
40065: PUSH
40066: LD_INT 6
40068: EQUAL
40069: AND
40070: IFFALSE 40126
// begin tmp2 := UnitsInside ( j ) ;
40072: LD_ADDR_VAR 0 9
40076: PUSH
40077: LD_VAR 0 3
40081: PPUSH
40082: CALL_OW 313
40086: ST_TO_ADDR
// if tmp2 = 6 then
40087: LD_VAR 0 9
40091: PUSH
40092: LD_INT 6
40094: EQUAL
40095: IFFALSE 40126
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
40097: LD_VAR 0 9
40101: PUSH
40102: LD_INT 1
40104: ARRAY
40105: PPUSH
40106: LD_INT 112
40108: PPUSH
40109: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
40113: LD_VAR 0 9
40117: PUSH
40118: LD_INT 1
40120: ARRAY
40121: PPUSH
40122: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
40126: LD_EXP 108
40130: PUSH
40131: LD_VAR 0 2
40135: ARRAY
40136: PUSH
40137: LD_EXP 108
40141: PUSH
40142: LD_VAR 0 2
40146: ARRAY
40147: PUSH
40148: LD_INT 1
40150: ARRAY
40151: PPUSH
40152: CALL_OW 314
40156: NOT
40157: AND
40158: PUSH
40159: LD_EXP 108
40163: PUSH
40164: LD_VAR 0 2
40168: ARRAY
40169: PUSH
40170: LD_INT 1
40172: ARRAY
40173: PPUSH
40174: CALL_OW 310
40178: NOT
40179: AND
40180: IFFALSE 40206
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
40182: LD_EXP 108
40186: PUSH
40187: LD_VAR 0 2
40191: ARRAY
40192: PUSH
40193: LD_INT 1
40195: ARRAY
40196: PPUSH
40197: LD_VAR 0 3
40201: PPUSH
40202: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
40206: LD_EXP 108
40210: PUSH
40211: LD_VAR 0 2
40215: ARRAY
40216: PUSH
40217: LD_INT 1
40219: ARRAY
40220: PPUSH
40221: CALL_OW 310
40225: PUSH
40226: LD_EXP 108
40230: PUSH
40231: LD_VAR 0 2
40235: ARRAY
40236: PUSH
40237: LD_INT 1
40239: ARRAY
40240: PPUSH
40241: CALL_OW 310
40245: PPUSH
40246: CALL_OW 461
40250: PUSH
40251: LD_INT 3
40253: NONEQUAL
40254: AND
40255: IFFALSE 40276
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
40257: LD_EXP 108
40261: PUSH
40262: LD_VAR 0 2
40266: ARRAY
40267: PUSH
40268: LD_INT 1
40270: ARRAY
40271: PPUSH
40272: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
40276: LD_VAR 0 3
40280: PPUSH
40281: CALL_OW 461
40285: PUSH
40286: LD_INT 6
40288: EQUAL
40289: PUSH
40290: LD_VAR 0 6
40294: PUSH
40295: LD_INT 1
40297: GREATER
40298: AND
40299: IFFALSE 40451
// begin sci := [ ] ;
40301: LD_ADDR_VAR 0 8
40305: PUSH
40306: EMPTY
40307: ST_TO_ADDR
// for x in ( tmp diff j ) do
40308: LD_ADDR_VAR 0 7
40312: PUSH
40313: LD_VAR 0 6
40317: PUSH
40318: LD_VAR 0 3
40322: DIFF
40323: PUSH
40324: FOR_IN
40325: IFFALSE 40377
// begin if sci = 6 then
40327: LD_VAR 0 8
40331: PUSH
40332: LD_INT 6
40334: EQUAL
40335: IFFALSE 40339
// break ;
40337: GO 40377
// if BuildingStatus ( x ) = bs_idle then
40339: LD_VAR 0 7
40343: PPUSH
40344: CALL_OW 461
40348: PUSH
40349: LD_INT 2
40351: EQUAL
40352: IFFALSE 40375
// sci := sci ^ UnitsInside ( x ) ;
40354: LD_ADDR_VAR 0 8
40358: PUSH
40359: LD_VAR 0 8
40363: PUSH
40364: LD_VAR 0 7
40368: PPUSH
40369: CALL_OW 313
40373: ADD
40374: ST_TO_ADDR
// end ;
40375: GO 40324
40377: POP
40378: POP
// if not sci then
40379: LD_VAR 0 8
40383: NOT
40384: IFFALSE 40388
// continue ;
40386: GO 39433
// for x in sci do
40388: LD_ADDR_VAR 0 7
40392: PUSH
40393: LD_VAR 0 8
40397: PUSH
40398: FOR_IN
40399: IFFALSE 40449
// if IsInUnit ( x ) and not HasTask ( x ) then
40401: LD_VAR 0 7
40405: PPUSH
40406: CALL_OW 310
40410: PUSH
40411: LD_VAR 0 7
40415: PPUSH
40416: CALL_OW 314
40420: NOT
40421: AND
40422: IFFALSE 40447
// begin ComExitBuilding ( x ) ;
40424: LD_VAR 0 7
40428: PPUSH
40429: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40433: LD_VAR 0 7
40437: PPUSH
40438: LD_VAR 0 3
40442: PPUSH
40443: CALL_OW 180
// end ;
40447: GO 40398
40449: POP
40450: POP
// end ; end ;
40451: GO 39433
40453: POP
40454: POP
// end ;
40455: GO 39387
40457: POP
40458: POP
// end ;
40459: LD_VAR 0 1
40463: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40464: LD_INT 0
40466: PPUSH
40467: PPUSH
// if not mc_bases then
40468: LD_EXP 78
40472: NOT
40473: IFFALSE 40477
// exit ;
40475: GO 40558
// for i = 1 to mc_bases do
40477: LD_ADDR_VAR 0 2
40481: PUSH
40482: DOUBLE
40483: LD_INT 1
40485: DEC
40486: ST_TO_ADDR
40487: LD_EXP 78
40491: PUSH
40492: FOR_TO
40493: IFFALSE 40556
// if mc_mines [ i ] and mc_miners [ i ] then
40495: LD_EXP 91
40499: PUSH
40500: LD_VAR 0 2
40504: ARRAY
40505: PUSH
40506: LD_EXP 92
40510: PUSH
40511: LD_VAR 0 2
40515: ARRAY
40516: AND
40517: IFFALSE 40554
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40519: LD_EXP 92
40523: PUSH
40524: LD_VAR 0 2
40528: ARRAY
40529: PUSH
40530: LD_INT 1
40532: ARRAY
40533: PPUSH
40534: CALL_OW 255
40538: PPUSH
40539: LD_EXP 91
40543: PUSH
40544: LD_VAR 0 2
40548: ARRAY
40549: PPUSH
40550: CALL 55197 0 2
40554: GO 40492
40556: POP
40557: POP
// end ;
40558: LD_VAR 0 1
40562: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
40563: LD_INT 0
40565: PPUSH
40566: PPUSH
40567: PPUSH
40568: PPUSH
40569: PPUSH
40570: PPUSH
40571: PPUSH
40572: PPUSH
// if not mc_bases or not mc_parking then
40573: LD_EXP 78
40577: NOT
40578: PUSH
40579: LD_EXP 102
40583: NOT
40584: OR
40585: IFFALSE 40589
// exit ;
40587: GO 41327
// for i = 1 to mc_bases do
40589: LD_ADDR_VAR 0 2
40593: PUSH
40594: DOUBLE
40595: LD_INT 1
40597: DEC
40598: ST_TO_ADDR
40599: LD_EXP 78
40603: PUSH
40604: FOR_TO
40605: IFFALSE 41325
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
40607: LD_EXP 78
40611: PUSH
40612: LD_VAR 0 2
40616: ARRAY
40617: NOT
40618: PUSH
40619: LD_EXP 102
40623: PUSH
40624: LD_VAR 0 2
40628: ARRAY
40629: NOT
40630: OR
40631: IFFALSE 40635
// continue ;
40633: GO 40604
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
40635: LD_ADDR_VAR 0 5
40639: PUSH
40640: LD_EXP 78
40644: PUSH
40645: LD_VAR 0 2
40649: ARRAY
40650: PUSH
40651: LD_INT 1
40653: ARRAY
40654: PPUSH
40655: CALL_OW 255
40659: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40660: LD_ADDR_VAR 0 6
40664: PUSH
40665: LD_EXP 78
40669: PUSH
40670: LD_VAR 0 2
40674: ARRAY
40675: PPUSH
40676: LD_INT 30
40678: PUSH
40679: LD_INT 3
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PPUSH
40686: CALL_OW 72
40690: ST_TO_ADDR
// if not fac then
40691: LD_VAR 0 6
40695: NOT
40696: IFFALSE 40747
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40698: LD_ADDR_VAR 0 6
40702: PUSH
40703: LD_EXP 78
40707: PUSH
40708: LD_VAR 0 2
40712: ARRAY
40713: PPUSH
40714: LD_INT 2
40716: PUSH
40717: LD_INT 30
40719: PUSH
40720: LD_INT 0
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 30
40729: PUSH
40730: LD_INT 1
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: LIST
40741: PPUSH
40742: CALL_OW 72
40746: ST_TO_ADDR
// if not fac then
40747: LD_VAR 0 6
40751: NOT
40752: IFFALSE 40756
// continue ;
40754: GO 40604
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40756: LD_ADDR_VAR 0 7
40760: PUSH
40761: LD_EXP 102
40765: PUSH
40766: LD_VAR 0 2
40770: ARRAY
40771: PPUSH
40772: LD_INT 22
40774: PUSH
40775: LD_VAR 0 5
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: PUSH
40784: LD_INT 21
40786: PUSH
40787: LD_INT 2
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 3
40796: PUSH
40797: LD_INT 60
40799: PUSH
40800: EMPTY
40801: LIST
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: PUSH
40807: LD_INT 3
40809: PUSH
40810: LD_INT 24
40812: PUSH
40813: LD_INT 1000
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: LIST
40828: LIST
40829: PPUSH
40830: CALL_OW 70
40834: ST_TO_ADDR
// for j in fac do
40835: LD_ADDR_VAR 0 3
40839: PUSH
40840: LD_VAR 0 6
40844: PUSH
40845: FOR_IN
40846: IFFALSE 40941
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40848: LD_ADDR_VAR 0 7
40852: PUSH
40853: LD_VAR 0 7
40857: PUSH
40858: LD_INT 22
40860: PUSH
40861: LD_VAR 0 5
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 91
40872: PUSH
40873: LD_VAR 0 3
40877: PUSH
40878: LD_INT 15
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: LIST
40885: PUSH
40886: LD_INT 21
40888: PUSH
40889: LD_INT 2
40891: PUSH
40892: EMPTY
40893: LIST
40894: LIST
40895: PUSH
40896: LD_INT 3
40898: PUSH
40899: LD_INT 60
40901: PUSH
40902: EMPTY
40903: LIST
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: LD_INT 3
40911: PUSH
40912: LD_INT 24
40914: PUSH
40915: LD_INT 1000
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: LIST
40930: LIST
40931: LIST
40932: PPUSH
40933: CALL_OW 69
40937: UNION
40938: ST_TO_ADDR
40939: GO 40845
40941: POP
40942: POP
// if not vehs then
40943: LD_VAR 0 7
40947: NOT
40948: IFFALSE 40974
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
40950: LD_ADDR_EXP 90
40954: PUSH
40955: LD_EXP 90
40959: PPUSH
40960: LD_VAR 0 2
40964: PPUSH
40965: EMPTY
40966: PPUSH
40967: CALL_OW 1
40971: ST_TO_ADDR
// continue ;
40972: GO 40604
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40974: LD_ADDR_VAR 0 8
40978: PUSH
40979: LD_EXP 78
40983: PUSH
40984: LD_VAR 0 2
40988: ARRAY
40989: PPUSH
40990: LD_INT 30
40992: PUSH
40993: LD_INT 3
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: PPUSH
41000: CALL_OW 72
41004: ST_TO_ADDR
// if tmp then
41005: LD_VAR 0 8
41009: IFFALSE 41112
// begin for j in tmp do
41011: LD_ADDR_VAR 0 3
41015: PUSH
41016: LD_VAR 0 8
41020: PUSH
41021: FOR_IN
41022: IFFALSE 41110
// for k in UnitsInside ( j ) do
41024: LD_ADDR_VAR 0 4
41028: PUSH
41029: LD_VAR 0 3
41033: PPUSH
41034: CALL_OW 313
41038: PUSH
41039: FOR_IN
41040: IFFALSE 41106
// if k then
41042: LD_VAR 0 4
41046: IFFALSE 41104
// if not k in mc_repair_vehicle [ i ] then
41048: LD_VAR 0 4
41052: PUSH
41053: LD_EXP 90
41057: PUSH
41058: LD_VAR 0 2
41062: ARRAY
41063: IN
41064: NOT
41065: IFFALSE 41104
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
41067: LD_ADDR_EXP 90
41071: PUSH
41072: LD_EXP 90
41076: PPUSH
41077: LD_VAR 0 2
41081: PPUSH
41082: LD_EXP 90
41086: PUSH
41087: LD_VAR 0 2
41091: ARRAY
41092: PUSH
41093: LD_VAR 0 4
41097: UNION
41098: PPUSH
41099: CALL_OW 1
41103: ST_TO_ADDR
41104: GO 41039
41106: POP
41107: POP
41108: GO 41021
41110: POP
41111: POP
// end ; if not mc_repair_vehicle [ i ] then
41112: LD_EXP 90
41116: PUSH
41117: LD_VAR 0 2
41121: ARRAY
41122: NOT
41123: IFFALSE 41127
// continue ;
41125: GO 40604
// for j in mc_repair_vehicle [ i ] do
41127: LD_ADDR_VAR 0 3
41131: PUSH
41132: LD_EXP 90
41136: PUSH
41137: LD_VAR 0 2
41141: ARRAY
41142: PUSH
41143: FOR_IN
41144: IFFALSE 41321
// begin if GetClass ( j ) <> 3 then
41146: LD_VAR 0 3
41150: PPUSH
41151: CALL_OW 257
41155: PUSH
41156: LD_INT 3
41158: NONEQUAL
41159: IFFALSE 41200
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
41161: LD_ADDR_EXP 90
41165: PUSH
41166: LD_EXP 90
41170: PPUSH
41171: LD_VAR 0 2
41175: PPUSH
41176: LD_EXP 90
41180: PUSH
41181: LD_VAR 0 2
41185: ARRAY
41186: PUSH
41187: LD_VAR 0 3
41191: DIFF
41192: PPUSH
41193: CALL_OW 1
41197: ST_TO_ADDR
// continue ;
41198: GO 41143
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41200: LD_VAR 0 3
41204: PPUSH
41205: CALL_OW 311
41209: NOT
41210: PUSH
41211: LD_VAR 0 3
41215: PUSH
41216: LD_EXP 81
41220: PUSH
41221: LD_VAR 0 2
41225: ARRAY
41226: PUSH
41227: LD_INT 1
41229: ARRAY
41230: IN
41231: NOT
41232: AND
41233: PUSH
41234: LD_VAR 0 3
41238: PUSH
41239: LD_EXP 81
41243: PUSH
41244: LD_VAR 0 2
41248: ARRAY
41249: PUSH
41250: LD_INT 2
41252: ARRAY
41253: IN
41254: NOT
41255: AND
41256: IFFALSE 41319
// begin if IsInUnit ( j ) then
41258: LD_VAR 0 3
41262: PPUSH
41263: CALL_OW 310
41267: IFFALSE 41280
// ComExitBuilding ( j ) else
41269: LD_VAR 0 3
41273: PPUSH
41274: CALL_OW 122
41278: GO 41319
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
41280: LD_VAR 0 3
41284: PPUSH
41285: LD_VAR 0 7
41289: PUSH
41290: LD_INT 1
41292: ARRAY
41293: PPUSH
41294: CALL 93025 0 2
41298: NOT
41299: IFFALSE 41319
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
41301: LD_VAR 0 3
41305: PPUSH
41306: LD_VAR 0 7
41310: PUSH
41311: LD_INT 1
41313: ARRAY
41314: PPUSH
41315: CALL_OW 129
// end ; end ;
41319: GO 41143
41321: POP
41322: POP
// end ;
41323: GO 40604
41325: POP
41326: POP
// end ;
41327: LD_VAR 0 1
41331: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
41332: LD_INT 0
41334: PPUSH
41335: PPUSH
41336: PPUSH
41337: PPUSH
41338: PPUSH
41339: PPUSH
41340: PPUSH
41341: PPUSH
41342: PPUSH
41343: PPUSH
41344: PPUSH
// if not mc_bases then
41345: LD_EXP 78
41349: NOT
41350: IFFALSE 41354
// exit ;
41352: GO 42156
// for i = 1 to mc_bases do
41354: LD_ADDR_VAR 0 2
41358: PUSH
41359: DOUBLE
41360: LD_INT 1
41362: DEC
41363: ST_TO_ADDR
41364: LD_EXP 78
41368: PUSH
41369: FOR_TO
41370: IFFALSE 42154
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
41372: LD_EXP 106
41376: PUSH
41377: LD_VAR 0 2
41381: ARRAY
41382: NOT
41383: PUSH
41384: LD_EXP 81
41388: PUSH
41389: LD_VAR 0 2
41393: ARRAY
41394: PUSH
41395: LD_INT 1
41397: ARRAY
41398: OR
41399: PUSH
41400: LD_EXP 81
41404: PUSH
41405: LD_VAR 0 2
41409: ARRAY
41410: PUSH
41411: LD_INT 2
41413: ARRAY
41414: OR
41415: PUSH
41416: LD_EXP 104
41420: PUSH
41421: LD_VAR 0 2
41425: ARRAY
41426: PPUSH
41427: LD_INT 1
41429: PPUSH
41430: CALL_OW 325
41434: NOT
41435: OR
41436: PUSH
41437: LD_EXP 101
41441: PUSH
41442: LD_VAR 0 2
41446: ARRAY
41447: OR
41448: IFFALSE 41452
// continue ;
41450: GO 41369
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41452: LD_ADDR_VAR 0 8
41456: PUSH
41457: LD_EXP 78
41461: PUSH
41462: LD_VAR 0 2
41466: ARRAY
41467: PPUSH
41468: LD_INT 25
41470: PUSH
41471: LD_INT 4
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 50
41480: PUSH
41481: EMPTY
41482: LIST
41483: PUSH
41484: LD_INT 3
41486: PUSH
41487: LD_INT 60
41489: PUSH
41490: EMPTY
41491: LIST
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: LIST
41501: PPUSH
41502: CALL_OW 72
41506: PUSH
41507: LD_EXP 82
41511: PUSH
41512: LD_VAR 0 2
41516: ARRAY
41517: DIFF
41518: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41519: LD_ADDR_VAR 0 9
41523: PUSH
41524: LD_EXP 78
41528: PUSH
41529: LD_VAR 0 2
41533: ARRAY
41534: PPUSH
41535: LD_INT 2
41537: PUSH
41538: LD_INT 30
41540: PUSH
41541: LD_INT 0
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PUSH
41548: LD_INT 30
41550: PUSH
41551: LD_INT 1
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: LIST
41562: PPUSH
41563: CALL_OW 72
41567: ST_TO_ADDR
// if not tmp or not dep then
41568: LD_VAR 0 8
41572: NOT
41573: PUSH
41574: LD_VAR 0 9
41578: NOT
41579: OR
41580: IFFALSE 41584
// continue ;
41582: GO 41369
// side := GetSide ( tmp [ 1 ] ) ;
41584: LD_ADDR_VAR 0 11
41588: PUSH
41589: LD_VAR 0 8
41593: PUSH
41594: LD_INT 1
41596: ARRAY
41597: PPUSH
41598: CALL_OW 255
41602: ST_TO_ADDR
// dep := dep [ 1 ] ;
41603: LD_ADDR_VAR 0 9
41607: PUSH
41608: LD_VAR 0 9
41612: PUSH
41613: LD_INT 1
41615: ARRAY
41616: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
41617: LD_ADDR_VAR 0 7
41621: PUSH
41622: LD_EXP 106
41626: PUSH
41627: LD_VAR 0 2
41631: ARRAY
41632: PPUSH
41633: LD_INT 22
41635: PUSH
41636: LD_INT 0
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: LD_INT 25
41645: PUSH
41646: LD_INT 12
41648: PUSH
41649: EMPTY
41650: LIST
41651: LIST
41652: PUSH
41653: EMPTY
41654: LIST
41655: LIST
41656: PPUSH
41657: CALL_OW 70
41661: PUSH
41662: LD_INT 22
41664: PUSH
41665: LD_INT 0
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 25
41674: PUSH
41675: LD_INT 12
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 91
41684: PUSH
41685: LD_VAR 0 9
41689: PUSH
41690: LD_INT 20
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: LIST
41697: PUSH
41698: EMPTY
41699: LIST
41700: LIST
41701: LIST
41702: PPUSH
41703: CALL_OW 69
41707: UNION
41708: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
41709: LD_ADDR_VAR 0 10
41713: PUSH
41714: LD_EXP 106
41718: PUSH
41719: LD_VAR 0 2
41723: ARRAY
41724: PPUSH
41725: LD_INT 81
41727: PUSH
41728: LD_VAR 0 11
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PPUSH
41737: CALL_OW 70
41741: ST_TO_ADDR
// if not apes or danger_at_area then
41742: LD_VAR 0 7
41746: NOT
41747: PUSH
41748: LD_VAR 0 10
41752: OR
41753: IFFALSE 41803
// begin if mc_taming [ i ] then
41755: LD_EXP 109
41759: PUSH
41760: LD_VAR 0 2
41764: ARRAY
41765: IFFALSE 41801
// begin MC_Reset ( i , 121 ) ;
41767: LD_VAR 0 2
41771: PPUSH
41772: LD_INT 121
41774: PPUSH
41775: CALL 26719 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41779: LD_ADDR_EXP 109
41783: PUSH
41784: LD_EXP 109
41788: PPUSH
41789: LD_VAR 0 2
41793: PPUSH
41794: EMPTY
41795: PPUSH
41796: CALL_OW 1
41800: ST_TO_ADDR
// end ; continue ;
41801: GO 41369
// end ; for j in tmp do
41803: LD_ADDR_VAR 0 3
41807: PUSH
41808: LD_VAR 0 8
41812: PUSH
41813: FOR_IN
41814: IFFALSE 42150
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
41816: LD_VAR 0 3
41820: PUSH
41821: LD_EXP 109
41825: PUSH
41826: LD_VAR 0 2
41830: ARRAY
41831: IN
41832: NOT
41833: PUSH
41834: LD_EXP 109
41838: PUSH
41839: LD_VAR 0 2
41843: ARRAY
41844: PUSH
41845: LD_INT 3
41847: LESS
41848: AND
41849: IFFALSE 41907
// begin SetTag ( j , 121 ) ;
41851: LD_VAR 0 3
41855: PPUSH
41856: LD_INT 121
41858: PPUSH
41859: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
41863: LD_ADDR_EXP 109
41867: PUSH
41868: LD_EXP 109
41872: PPUSH
41873: LD_VAR 0 2
41877: PUSH
41878: LD_EXP 109
41882: PUSH
41883: LD_VAR 0 2
41887: ARRAY
41888: PUSH
41889: LD_INT 1
41891: PLUS
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PPUSH
41897: LD_VAR 0 3
41901: PPUSH
41902: CALL 58220 0 3
41906: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
41907: LD_VAR 0 3
41911: PUSH
41912: LD_EXP 109
41916: PUSH
41917: LD_VAR 0 2
41921: ARRAY
41922: IN
41923: IFFALSE 42148
// begin if GetClass ( j ) <> 4 then
41925: LD_VAR 0 3
41929: PPUSH
41930: CALL_OW 257
41934: PUSH
41935: LD_INT 4
41937: NONEQUAL
41938: IFFALSE 41991
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
41940: LD_ADDR_EXP 109
41944: PUSH
41945: LD_EXP 109
41949: PPUSH
41950: LD_VAR 0 2
41954: PPUSH
41955: LD_EXP 109
41959: PUSH
41960: LD_VAR 0 2
41964: ARRAY
41965: PUSH
41966: LD_VAR 0 3
41970: DIFF
41971: PPUSH
41972: CALL_OW 1
41976: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41977: LD_VAR 0 3
41981: PPUSH
41982: LD_INT 0
41984: PPUSH
41985: CALL_OW 109
// continue ;
41989: GO 41813
// end ; if IsInUnit ( j ) then
41991: LD_VAR 0 3
41995: PPUSH
41996: CALL_OW 310
42000: IFFALSE 42011
// ComExitBuilding ( j ) ;
42002: LD_VAR 0 3
42006: PPUSH
42007: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
42011: LD_ADDR_VAR 0 6
42015: PUSH
42016: LD_VAR 0 7
42020: PPUSH
42021: LD_VAR 0 3
42025: PPUSH
42026: CALL_OW 74
42030: ST_TO_ADDR
// if not ape then
42031: LD_VAR 0 6
42035: NOT
42036: IFFALSE 42040
// break ;
42038: GO 42150
// x := GetX ( ape ) ;
42040: LD_ADDR_VAR 0 4
42044: PUSH
42045: LD_VAR 0 6
42049: PPUSH
42050: CALL_OW 250
42054: ST_TO_ADDR
// y := GetY ( ape ) ;
42055: LD_ADDR_VAR 0 5
42059: PUSH
42060: LD_VAR 0 6
42064: PPUSH
42065: CALL_OW 251
42069: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
42070: LD_VAR 0 4
42074: PPUSH
42075: LD_VAR 0 5
42079: PPUSH
42080: CALL_OW 488
42084: NOT
42085: PUSH
42086: LD_VAR 0 11
42090: PPUSH
42091: LD_VAR 0 4
42095: PPUSH
42096: LD_VAR 0 5
42100: PPUSH
42101: LD_INT 20
42103: PPUSH
42104: CALL 59484 0 4
42108: PUSH
42109: LD_INT 4
42111: ARRAY
42112: OR
42113: IFFALSE 42117
// break ;
42115: GO 42150
// if not HasTask ( j ) then
42117: LD_VAR 0 3
42121: PPUSH
42122: CALL_OW 314
42126: NOT
42127: IFFALSE 42148
// ComTameXY ( j , x , y ) ;
42129: LD_VAR 0 3
42133: PPUSH
42134: LD_VAR 0 4
42138: PPUSH
42139: LD_VAR 0 5
42143: PPUSH
42144: CALL_OW 131
// end ; end ;
42148: GO 41813
42150: POP
42151: POP
// end ;
42152: GO 41369
42154: POP
42155: POP
// end ;
42156: LD_VAR 0 1
42160: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
42161: LD_INT 0
42163: PPUSH
42164: PPUSH
42165: PPUSH
42166: PPUSH
42167: PPUSH
42168: PPUSH
42169: PPUSH
42170: PPUSH
// if not mc_bases then
42171: LD_EXP 78
42175: NOT
42176: IFFALSE 42180
// exit ;
42178: GO 42806
// for i = 1 to mc_bases do
42180: LD_ADDR_VAR 0 2
42184: PUSH
42185: DOUBLE
42186: LD_INT 1
42188: DEC
42189: ST_TO_ADDR
42190: LD_EXP 78
42194: PUSH
42195: FOR_TO
42196: IFFALSE 42804
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
42198: LD_EXP 107
42202: PUSH
42203: LD_VAR 0 2
42207: ARRAY
42208: NOT
42209: PUSH
42210: LD_EXP 107
42214: PUSH
42215: LD_VAR 0 2
42219: ARRAY
42220: PPUSH
42221: LD_INT 25
42223: PUSH
42224: LD_INT 12
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PPUSH
42231: CALL_OW 72
42235: NOT
42236: OR
42237: IFFALSE 42241
// continue ;
42239: GO 42195
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
42241: LD_ADDR_VAR 0 5
42245: PUSH
42246: LD_EXP 107
42250: PUSH
42251: LD_VAR 0 2
42255: ARRAY
42256: PUSH
42257: LD_INT 1
42259: ARRAY
42260: PPUSH
42261: CALL_OW 255
42265: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
42266: LD_VAR 0 5
42270: PPUSH
42271: LD_INT 2
42273: PPUSH
42274: CALL_OW 325
42278: IFFALSE 42531
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42280: LD_ADDR_VAR 0 4
42284: PUSH
42285: LD_EXP 107
42289: PUSH
42290: LD_VAR 0 2
42294: ARRAY
42295: PPUSH
42296: LD_INT 25
42298: PUSH
42299: LD_INT 16
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PPUSH
42306: CALL_OW 72
42310: ST_TO_ADDR
// if tmp < 6 then
42311: LD_VAR 0 4
42315: PUSH
42316: LD_INT 6
42318: LESS
42319: IFFALSE 42531
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42321: LD_ADDR_VAR 0 6
42325: PUSH
42326: LD_EXP 78
42330: PUSH
42331: LD_VAR 0 2
42335: ARRAY
42336: PPUSH
42337: LD_INT 2
42339: PUSH
42340: LD_INT 30
42342: PUSH
42343: LD_INT 0
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: LD_INT 30
42352: PUSH
42353: LD_INT 1
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: EMPTY
42361: LIST
42362: LIST
42363: LIST
42364: PPUSH
42365: CALL_OW 72
42369: ST_TO_ADDR
// if depot then
42370: LD_VAR 0 6
42374: IFFALSE 42531
// begin selected := 0 ;
42376: LD_ADDR_VAR 0 7
42380: PUSH
42381: LD_INT 0
42383: ST_TO_ADDR
// for j in depot do
42384: LD_ADDR_VAR 0 3
42388: PUSH
42389: LD_VAR 0 6
42393: PUSH
42394: FOR_IN
42395: IFFALSE 42426
// begin if UnitsInside ( j ) < 6 then
42397: LD_VAR 0 3
42401: PPUSH
42402: CALL_OW 313
42406: PUSH
42407: LD_INT 6
42409: LESS
42410: IFFALSE 42424
// begin selected := j ;
42412: LD_ADDR_VAR 0 7
42416: PUSH
42417: LD_VAR 0 3
42421: ST_TO_ADDR
// break ;
42422: GO 42426
// end ; end ;
42424: GO 42394
42426: POP
42427: POP
// if selected then
42428: LD_VAR 0 7
42432: IFFALSE 42531
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42434: LD_ADDR_VAR 0 3
42438: PUSH
42439: LD_EXP 107
42443: PUSH
42444: LD_VAR 0 2
42448: ARRAY
42449: PPUSH
42450: LD_INT 25
42452: PUSH
42453: LD_INT 12
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PPUSH
42460: CALL_OW 72
42464: PUSH
42465: FOR_IN
42466: IFFALSE 42529
// if not HasTask ( j ) then
42468: LD_VAR 0 3
42472: PPUSH
42473: CALL_OW 314
42477: NOT
42478: IFFALSE 42527
// begin if not IsInUnit ( j ) then
42480: LD_VAR 0 3
42484: PPUSH
42485: CALL_OW 310
42489: NOT
42490: IFFALSE 42506
// ComEnterUnit ( j , selected ) ;
42492: LD_VAR 0 3
42496: PPUSH
42497: LD_VAR 0 7
42501: PPUSH
42502: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42506: LD_VAR 0 3
42510: PPUSH
42511: LD_INT 16
42513: PPUSH
42514: CALL_OW 183
// AddComExitBuilding ( j ) ;
42518: LD_VAR 0 3
42522: PPUSH
42523: CALL_OW 182
// end ;
42527: GO 42465
42529: POP
42530: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
42531: LD_VAR 0 5
42535: PPUSH
42536: LD_INT 11
42538: PPUSH
42539: CALL_OW 325
42543: IFFALSE 42802
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42545: LD_ADDR_VAR 0 4
42549: PUSH
42550: LD_EXP 107
42554: PUSH
42555: LD_VAR 0 2
42559: ARRAY
42560: PPUSH
42561: LD_INT 25
42563: PUSH
42564: LD_INT 16
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PPUSH
42571: CALL_OW 72
42575: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
42576: LD_VAR 0 4
42580: PUSH
42581: LD_INT 6
42583: GREATEREQUAL
42584: PUSH
42585: LD_VAR 0 5
42589: PPUSH
42590: LD_INT 2
42592: PPUSH
42593: CALL_OW 325
42597: NOT
42598: OR
42599: IFFALSE 42802
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42601: LD_ADDR_VAR 0 8
42605: PUSH
42606: LD_EXP 78
42610: PUSH
42611: LD_VAR 0 2
42615: ARRAY
42616: PPUSH
42617: LD_INT 2
42619: PUSH
42620: LD_INT 30
42622: PUSH
42623: LD_INT 4
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: PUSH
42630: LD_INT 30
42632: PUSH
42633: LD_INT 5
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: LIST
42644: PPUSH
42645: CALL_OW 72
42649: ST_TO_ADDR
// if barracks then
42650: LD_VAR 0 8
42654: IFFALSE 42802
// begin selected := 0 ;
42656: LD_ADDR_VAR 0 7
42660: PUSH
42661: LD_INT 0
42663: ST_TO_ADDR
// for j in barracks do
42664: LD_ADDR_VAR 0 3
42668: PUSH
42669: LD_VAR 0 8
42673: PUSH
42674: FOR_IN
42675: IFFALSE 42706
// begin if UnitsInside ( j ) < 6 then
42677: LD_VAR 0 3
42681: PPUSH
42682: CALL_OW 313
42686: PUSH
42687: LD_INT 6
42689: LESS
42690: IFFALSE 42704
// begin selected := j ;
42692: LD_ADDR_VAR 0 7
42696: PUSH
42697: LD_VAR 0 3
42701: ST_TO_ADDR
// break ;
42702: GO 42706
// end ; end ;
42704: GO 42674
42706: POP
42707: POP
// if selected then
42708: LD_VAR 0 7
42712: IFFALSE 42802
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42714: LD_ADDR_VAR 0 3
42718: PUSH
42719: LD_EXP 107
42723: PUSH
42724: LD_VAR 0 2
42728: ARRAY
42729: PPUSH
42730: LD_INT 25
42732: PUSH
42733: LD_INT 12
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PPUSH
42740: CALL_OW 72
42744: PUSH
42745: FOR_IN
42746: IFFALSE 42800
// if not IsInUnit ( j ) and not HasTask ( j ) then
42748: LD_VAR 0 3
42752: PPUSH
42753: CALL_OW 310
42757: NOT
42758: PUSH
42759: LD_VAR 0 3
42763: PPUSH
42764: CALL_OW 314
42768: NOT
42769: AND
42770: IFFALSE 42798
// begin ComEnterUnit ( j , selected ) ;
42772: LD_VAR 0 3
42776: PPUSH
42777: LD_VAR 0 7
42781: PPUSH
42782: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
42786: LD_VAR 0 3
42790: PPUSH
42791: LD_INT 15
42793: PPUSH
42794: CALL_OW 183
// end ;
42798: GO 42745
42800: POP
42801: POP
// end ; end ; end ; end ; end ;
42802: GO 42195
42804: POP
42805: POP
// end ;
42806: LD_VAR 0 1
42810: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
42811: LD_INT 0
42813: PPUSH
42814: PPUSH
42815: PPUSH
42816: PPUSH
// if not mc_bases then
42817: LD_EXP 78
42821: NOT
42822: IFFALSE 42826
// exit ;
42824: GO 43004
// for i = 1 to mc_bases do
42826: LD_ADDR_VAR 0 2
42830: PUSH
42831: DOUBLE
42832: LD_INT 1
42834: DEC
42835: ST_TO_ADDR
42836: LD_EXP 78
42840: PUSH
42841: FOR_TO
42842: IFFALSE 43002
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
42844: LD_ADDR_VAR 0 4
42848: PUSH
42849: LD_EXP 78
42853: PUSH
42854: LD_VAR 0 2
42858: ARRAY
42859: PPUSH
42860: LD_INT 25
42862: PUSH
42863: LD_INT 9
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PPUSH
42870: CALL_OW 72
42874: ST_TO_ADDR
// if not tmp then
42875: LD_VAR 0 4
42879: NOT
42880: IFFALSE 42884
// continue ;
42882: GO 42841
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
42884: LD_EXP 104
42888: PUSH
42889: LD_VAR 0 2
42893: ARRAY
42894: PPUSH
42895: LD_INT 29
42897: PPUSH
42898: CALL_OW 325
42902: NOT
42903: PUSH
42904: LD_EXP 104
42908: PUSH
42909: LD_VAR 0 2
42913: ARRAY
42914: PPUSH
42915: LD_INT 28
42917: PPUSH
42918: CALL_OW 325
42922: NOT
42923: AND
42924: IFFALSE 42928
// continue ;
42926: GO 42841
// for j in tmp do
42928: LD_ADDR_VAR 0 3
42932: PUSH
42933: LD_VAR 0 4
42937: PUSH
42938: FOR_IN
42939: IFFALSE 42998
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
42941: LD_VAR 0 3
42945: PUSH
42946: LD_EXP 81
42950: PUSH
42951: LD_VAR 0 2
42955: ARRAY
42956: PUSH
42957: LD_INT 1
42959: ARRAY
42960: IN
42961: NOT
42962: PUSH
42963: LD_VAR 0 3
42967: PUSH
42968: LD_EXP 81
42972: PUSH
42973: LD_VAR 0 2
42977: ARRAY
42978: PUSH
42979: LD_INT 2
42981: ARRAY
42982: IN
42983: NOT
42984: AND
42985: IFFALSE 42996
// ComSpaceTimeShoot ( j ) ;
42987: LD_VAR 0 3
42991: PPUSH
42992: CALL 54205 0 1
42996: GO 42938
42998: POP
42999: POP
// end ;
43000: GO 42841
43002: POP
43003: POP
// end ;
43004: LD_VAR 0 1
43008: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
43009: LD_INT 0
43011: PPUSH
43012: PPUSH
43013: PPUSH
43014: PPUSH
43015: PPUSH
43016: PPUSH
43017: PPUSH
43018: PPUSH
43019: PPUSH
// if not mc_bases then
43020: LD_EXP 78
43024: NOT
43025: IFFALSE 43029
// exit ;
43027: GO 43651
// for i = 1 to mc_bases do
43029: LD_ADDR_VAR 0 2
43033: PUSH
43034: DOUBLE
43035: LD_INT 1
43037: DEC
43038: ST_TO_ADDR
43039: LD_EXP 78
43043: PUSH
43044: FOR_TO
43045: IFFALSE 43649
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
43047: LD_EXP 113
43051: PUSH
43052: LD_VAR 0 2
43056: ARRAY
43057: NOT
43058: PUSH
43059: LD_INT 38
43061: PPUSH
43062: LD_EXP 104
43066: PUSH
43067: LD_VAR 0 2
43071: ARRAY
43072: PPUSH
43073: CALL_OW 321
43077: PUSH
43078: LD_INT 2
43080: NONEQUAL
43081: OR
43082: IFFALSE 43086
// continue ;
43084: GO 43044
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
43086: LD_ADDR_VAR 0 8
43090: PUSH
43091: LD_EXP 78
43095: PUSH
43096: LD_VAR 0 2
43100: ARRAY
43101: PPUSH
43102: LD_INT 30
43104: PUSH
43105: LD_INT 34
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PPUSH
43112: CALL_OW 72
43116: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
43117: LD_ADDR_VAR 0 9
43121: PUSH
43122: LD_EXP 78
43126: PUSH
43127: LD_VAR 0 2
43131: ARRAY
43132: PPUSH
43133: LD_INT 25
43135: PUSH
43136: LD_INT 4
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PPUSH
43143: CALL_OW 72
43147: PPUSH
43148: LD_INT 0
43150: PPUSH
43151: CALL 88529 0 2
43155: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
43156: LD_VAR 0 9
43160: NOT
43161: PUSH
43162: LD_VAR 0 8
43166: NOT
43167: OR
43168: PUSH
43169: LD_EXP 78
43173: PUSH
43174: LD_VAR 0 2
43178: ARRAY
43179: PPUSH
43180: LD_INT 124
43182: PPUSH
43183: CALL 88529 0 2
43187: OR
43188: IFFALSE 43192
// continue ;
43190: GO 43044
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
43192: LD_EXP 114
43196: PUSH
43197: LD_VAR 0 2
43201: ARRAY
43202: PUSH
43203: LD_EXP 113
43207: PUSH
43208: LD_VAR 0 2
43212: ARRAY
43213: LESS
43214: PUSH
43215: LD_EXP 114
43219: PUSH
43220: LD_VAR 0 2
43224: ARRAY
43225: PUSH
43226: LD_VAR 0 8
43230: LESS
43231: AND
43232: IFFALSE 43647
// begin tmp := sci [ 1 ] ;
43234: LD_ADDR_VAR 0 7
43238: PUSH
43239: LD_VAR 0 9
43243: PUSH
43244: LD_INT 1
43246: ARRAY
43247: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
43248: LD_VAR 0 7
43252: PPUSH
43253: LD_INT 124
43255: PPUSH
43256: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
43260: LD_ADDR_VAR 0 3
43264: PUSH
43265: DOUBLE
43266: LD_EXP 113
43270: PUSH
43271: LD_VAR 0 2
43275: ARRAY
43276: INC
43277: ST_TO_ADDR
43278: LD_EXP 113
43282: PUSH
43283: LD_VAR 0 2
43287: ARRAY
43288: PUSH
43289: FOR_DOWNTO
43290: IFFALSE 43633
// begin if IsInUnit ( tmp ) then
43292: LD_VAR 0 7
43296: PPUSH
43297: CALL_OW 310
43301: IFFALSE 43312
// ComExitBuilding ( tmp ) ;
43303: LD_VAR 0 7
43307: PPUSH
43308: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
43312: LD_INT 35
43314: PPUSH
43315: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
43319: LD_VAR 0 7
43323: PPUSH
43324: CALL_OW 310
43328: NOT
43329: PUSH
43330: LD_VAR 0 7
43334: PPUSH
43335: CALL_OW 314
43339: NOT
43340: AND
43341: IFFALSE 43312
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
43343: LD_ADDR_VAR 0 6
43347: PUSH
43348: LD_VAR 0 7
43352: PPUSH
43353: CALL_OW 250
43357: PUSH
43358: LD_VAR 0 7
43362: PPUSH
43363: CALL_OW 251
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
43372: LD_INT 35
43374: PPUSH
43375: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
43379: LD_ADDR_VAR 0 4
43383: PUSH
43384: LD_EXP 113
43388: PUSH
43389: LD_VAR 0 2
43393: ARRAY
43394: PUSH
43395: LD_VAR 0 3
43399: ARRAY
43400: PUSH
43401: LD_INT 1
43403: ARRAY
43404: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
43405: LD_ADDR_VAR 0 5
43409: PUSH
43410: LD_EXP 113
43414: PUSH
43415: LD_VAR 0 2
43419: ARRAY
43420: PUSH
43421: LD_VAR 0 3
43425: ARRAY
43426: PUSH
43427: LD_INT 2
43429: ARRAY
43430: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
43431: LD_VAR 0 7
43435: PPUSH
43436: LD_INT 10
43438: PPUSH
43439: CALL 61185 0 2
43443: PUSH
43444: LD_INT 4
43446: ARRAY
43447: IFFALSE 43485
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43449: LD_VAR 0 7
43453: PPUSH
43454: LD_VAR 0 6
43458: PUSH
43459: LD_INT 1
43461: ARRAY
43462: PPUSH
43463: LD_VAR 0 6
43467: PUSH
43468: LD_INT 2
43470: ARRAY
43471: PPUSH
43472: CALL_OW 111
// wait ( 0 0$10 ) ;
43476: LD_INT 350
43478: PPUSH
43479: CALL_OW 67
// end else
43483: GO 43511
// begin ComMoveXY ( tmp , x , y ) ;
43485: LD_VAR 0 7
43489: PPUSH
43490: LD_VAR 0 4
43494: PPUSH
43495: LD_VAR 0 5
43499: PPUSH
43500: CALL_OW 111
// wait ( 0 0$3 ) ;
43504: LD_INT 105
43506: PPUSH
43507: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43511: LD_VAR 0 7
43515: PPUSH
43516: LD_VAR 0 4
43520: PPUSH
43521: LD_VAR 0 5
43525: PPUSH
43526: CALL_OW 307
43530: IFFALSE 43372
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
43532: LD_VAR 0 7
43536: PPUSH
43537: LD_VAR 0 4
43541: PPUSH
43542: LD_VAR 0 5
43546: PPUSH
43547: LD_VAR 0 8
43551: PUSH
43552: LD_VAR 0 3
43556: ARRAY
43557: PPUSH
43558: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
43562: LD_INT 35
43564: PPUSH
43565: CALL_OW 67
// until not HasTask ( tmp ) ;
43569: LD_VAR 0 7
43573: PPUSH
43574: CALL_OW 314
43578: NOT
43579: IFFALSE 43562
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
43581: LD_ADDR_EXP 114
43585: PUSH
43586: LD_EXP 114
43590: PPUSH
43591: LD_VAR 0 2
43595: PUSH
43596: LD_EXP 114
43600: PUSH
43601: LD_VAR 0 2
43605: ARRAY
43606: PUSH
43607: LD_INT 1
43609: PLUS
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: PPUSH
43615: LD_VAR 0 8
43619: PUSH
43620: LD_VAR 0 3
43624: ARRAY
43625: PPUSH
43626: CALL 58220 0 3
43630: ST_TO_ADDR
// end ;
43631: GO 43289
43633: POP
43634: POP
// MC_Reset ( i , 124 ) ;
43635: LD_VAR 0 2
43639: PPUSH
43640: LD_INT 124
43642: PPUSH
43643: CALL 26719 0 2
// end ; end ;
43647: GO 43044
43649: POP
43650: POP
// end ;
43651: LD_VAR 0 1
43655: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
43656: LD_INT 0
43658: PPUSH
43659: PPUSH
43660: PPUSH
// if not mc_bases then
43661: LD_EXP 78
43665: NOT
43666: IFFALSE 43670
// exit ;
43668: GO 44276
// for i = 1 to mc_bases do
43670: LD_ADDR_VAR 0 2
43674: PUSH
43675: DOUBLE
43676: LD_INT 1
43678: DEC
43679: ST_TO_ADDR
43680: LD_EXP 78
43684: PUSH
43685: FOR_TO
43686: IFFALSE 44274
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43688: LD_ADDR_VAR 0 3
43692: PUSH
43693: LD_EXP 78
43697: PUSH
43698: LD_VAR 0 2
43702: ARRAY
43703: PPUSH
43704: LD_INT 25
43706: PUSH
43707: LD_INT 4
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PPUSH
43714: CALL_OW 72
43718: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43719: LD_VAR 0 3
43723: NOT
43724: PUSH
43725: LD_EXP 115
43729: PUSH
43730: LD_VAR 0 2
43734: ARRAY
43735: NOT
43736: OR
43737: PUSH
43738: LD_EXP 78
43742: PUSH
43743: LD_VAR 0 2
43747: ARRAY
43748: PPUSH
43749: LD_INT 2
43751: PUSH
43752: LD_INT 30
43754: PUSH
43755: LD_INT 0
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 30
43764: PUSH
43765: LD_INT 1
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: LIST
43776: PPUSH
43777: CALL_OW 72
43781: NOT
43782: OR
43783: IFFALSE 43833
// begin if mc_deposits_finder [ i ] then
43785: LD_EXP 116
43789: PUSH
43790: LD_VAR 0 2
43794: ARRAY
43795: IFFALSE 43831
// begin MC_Reset ( i , 125 ) ;
43797: LD_VAR 0 2
43801: PPUSH
43802: LD_INT 125
43804: PPUSH
43805: CALL 26719 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43809: LD_ADDR_EXP 116
43813: PUSH
43814: LD_EXP 116
43818: PPUSH
43819: LD_VAR 0 2
43823: PPUSH
43824: EMPTY
43825: PPUSH
43826: CALL_OW 1
43830: ST_TO_ADDR
// end ; continue ;
43831: GO 43685
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
43833: LD_EXP 115
43837: PUSH
43838: LD_VAR 0 2
43842: ARRAY
43843: PUSH
43844: LD_INT 1
43846: ARRAY
43847: PUSH
43848: LD_INT 3
43850: ARRAY
43851: PUSH
43852: LD_INT 1
43854: EQUAL
43855: PUSH
43856: LD_INT 20
43858: PPUSH
43859: LD_EXP 104
43863: PUSH
43864: LD_VAR 0 2
43868: ARRAY
43869: PPUSH
43870: CALL_OW 321
43874: PUSH
43875: LD_INT 2
43877: NONEQUAL
43878: AND
43879: IFFALSE 43929
// begin if mc_deposits_finder [ i ] then
43881: LD_EXP 116
43885: PUSH
43886: LD_VAR 0 2
43890: ARRAY
43891: IFFALSE 43927
// begin MC_Reset ( i , 125 ) ;
43893: LD_VAR 0 2
43897: PPUSH
43898: LD_INT 125
43900: PPUSH
43901: CALL 26719 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43905: LD_ADDR_EXP 116
43909: PUSH
43910: LD_EXP 116
43914: PPUSH
43915: LD_VAR 0 2
43919: PPUSH
43920: EMPTY
43921: PPUSH
43922: CALL_OW 1
43926: ST_TO_ADDR
// end ; continue ;
43927: GO 43685
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
43929: LD_EXP 115
43933: PUSH
43934: LD_VAR 0 2
43938: ARRAY
43939: PUSH
43940: LD_INT 1
43942: ARRAY
43943: PUSH
43944: LD_INT 1
43946: ARRAY
43947: PPUSH
43948: LD_EXP 115
43952: PUSH
43953: LD_VAR 0 2
43957: ARRAY
43958: PUSH
43959: LD_INT 1
43961: ARRAY
43962: PUSH
43963: LD_INT 2
43965: ARRAY
43966: PPUSH
43967: LD_EXP 104
43971: PUSH
43972: LD_VAR 0 2
43976: ARRAY
43977: PPUSH
43978: CALL_OW 440
43982: IFFALSE 44025
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
43984: LD_ADDR_EXP 115
43988: PUSH
43989: LD_EXP 115
43993: PPUSH
43994: LD_VAR 0 2
43998: PPUSH
43999: LD_EXP 115
44003: PUSH
44004: LD_VAR 0 2
44008: ARRAY
44009: PPUSH
44010: LD_INT 1
44012: PPUSH
44013: CALL_OW 3
44017: PPUSH
44018: CALL_OW 1
44022: ST_TO_ADDR
44023: GO 44272
// begin if not mc_deposits_finder [ i ] then
44025: LD_EXP 116
44029: PUSH
44030: LD_VAR 0 2
44034: ARRAY
44035: NOT
44036: IFFALSE 44088
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
44038: LD_ADDR_EXP 116
44042: PUSH
44043: LD_EXP 116
44047: PPUSH
44048: LD_VAR 0 2
44052: PPUSH
44053: LD_VAR 0 3
44057: PUSH
44058: LD_INT 1
44060: ARRAY
44061: PUSH
44062: EMPTY
44063: LIST
44064: PPUSH
44065: CALL_OW 1
44069: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
44070: LD_VAR 0 3
44074: PUSH
44075: LD_INT 1
44077: ARRAY
44078: PPUSH
44079: LD_INT 125
44081: PPUSH
44082: CALL_OW 109
// end else
44086: GO 44272
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
44088: LD_EXP 116
44092: PUSH
44093: LD_VAR 0 2
44097: ARRAY
44098: PUSH
44099: LD_INT 1
44101: ARRAY
44102: PPUSH
44103: CALL_OW 310
44107: IFFALSE 44130
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
44109: LD_EXP 116
44113: PUSH
44114: LD_VAR 0 2
44118: ARRAY
44119: PUSH
44120: LD_INT 1
44122: ARRAY
44123: PPUSH
44124: CALL_OW 122
44128: GO 44272
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
44130: LD_EXP 116
44134: PUSH
44135: LD_VAR 0 2
44139: ARRAY
44140: PUSH
44141: LD_INT 1
44143: ARRAY
44144: PPUSH
44145: CALL_OW 314
44149: NOT
44150: PUSH
44151: LD_EXP 116
44155: PUSH
44156: LD_VAR 0 2
44160: ARRAY
44161: PUSH
44162: LD_INT 1
44164: ARRAY
44165: PPUSH
44166: LD_EXP 115
44170: PUSH
44171: LD_VAR 0 2
44175: ARRAY
44176: PUSH
44177: LD_INT 1
44179: ARRAY
44180: PUSH
44181: LD_INT 1
44183: ARRAY
44184: PPUSH
44185: LD_EXP 115
44189: PUSH
44190: LD_VAR 0 2
44194: ARRAY
44195: PUSH
44196: LD_INT 1
44198: ARRAY
44199: PUSH
44200: LD_INT 2
44202: ARRAY
44203: PPUSH
44204: CALL_OW 297
44208: PUSH
44209: LD_INT 6
44211: GREATER
44212: AND
44213: IFFALSE 44272
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
44215: LD_EXP 116
44219: PUSH
44220: LD_VAR 0 2
44224: ARRAY
44225: PUSH
44226: LD_INT 1
44228: ARRAY
44229: PPUSH
44230: LD_EXP 115
44234: PUSH
44235: LD_VAR 0 2
44239: ARRAY
44240: PUSH
44241: LD_INT 1
44243: ARRAY
44244: PUSH
44245: LD_INT 1
44247: ARRAY
44248: PPUSH
44249: LD_EXP 115
44253: PUSH
44254: LD_VAR 0 2
44258: ARRAY
44259: PUSH
44260: LD_INT 1
44262: ARRAY
44263: PUSH
44264: LD_INT 2
44266: ARRAY
44267: PPUSH
44268: CALL_OW 111
// end ; end ; end ;
44272: GO 43685
44274: POP
44275: POP
// end ;
44276: LD_VAR 0 1
44280: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
44281: LD_INT 0
44283: PPUSH
44284: PPUSH
44285: PPUSH
44286: PPUSH
44287: PPUSH
44288: PPUSH
44289: PPUSH
44290: PPUSH
44291: PPUSH
44292: PPUSH
44293: PPUSH
// if not mc_bases then
44294: LD_EXP 78
44298: NOT
44299: IFFALSE 44303
// exit ;
44301: GO 45243
// for i = 1 to mc_bases do
44303: LD_ADDR_VAR 0 2
44307: PUSH
44308: DOUBLE
44309: LD_INT 1
44311: DEC
44312: ST_TO_ADDR
44313: LD_EXP 78
44317: PUSH
44318: FOR_TO
44319: IFFALSE 45241
// begin if not mc_bases [ i ] or mc_scan [ i ] then
44321: LD_EXP 78
44325: PUSH
44326: LD_VAR 0 2
44330: ARRAY
44331: NOT
44332: PUSH
44333: LD_EXP 101
44337: PUSH
44338: LD_VAR 0 2
44342: ARRAY
44343: OR
44344: IFFALSE 44348
// continue ;
44346: GO 44318
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
44348: LD_ADDR_VAR 0 7
44352: PUSH
44353: LD_EXP 78
44357: PUSH
44358: LD_VAR 0 2
44362: ARRAY
44363: PUSH
44364: LD_INT 1
44366: ARRAY
44367: PPUSH
44368: CALL_OW 248
44372: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
44373: LD_VAR 0 7
44377: PUSH
44378: LD_INT 3
44380: EQUAL
44381: PUSH
44382: LD_EXP 97
44386: PUSH
44387: LD_VAR 0 2
44391: ARRAY
44392: PUSH
44393: LD_EXP 100
44397: PUSH
44398: LD_VAR 0 2
44402: ARRAY
44403: UNION
44404: PPUSH
44405: LD_INT 33
44407: PUSH
44408: LD_INT 2
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PPUSH
44415: CALL_OW 72
44419: NOT
44420: OR
44421: IFFALSE 44425
// continue ;
44423: GO 44318
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
44425: LD_ADDR_VAR 0 9
44429: PUSH
44430: LD_EXP 78
44434: PUSH
44435: LD_VAR 0 2
44439: ARRAY
44440: PPUSH
44441: LD_INT 30
44443: PUSH
44444: LD_INT 36
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PPUSH
44451: CALL_OW 72
44455: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44456: LD_ADDR_VAR 0 10
44460: PUSH
44461: LD_EXP 97
44465: PUSH
44466: LD_VAR 0 2
44470: ARRAY
44471: PPUSH
44472: LD_INT 34
44474: PUSH
44475: LD_INT 31
44477: PUSH
44478: EMPTY
44479: LIST
44480: LIST
44481: PPUSH
44482: CALL_OW 72
44486: ST_TO_ADDR
// if not cts and not mcts then
44487: LD_VAR 0 9
44491: NOT
44492: PUSH
44493: LD_VAR 0 10
44497: NOT
44498: AND
44499: IFFALSE 44503
// continue ;
44501: GO 44318
// x := cts ;
44503: LD_ADDR_VAR 0 11
44507: PUSH
44508: LD_VAR 0 9
44512: ST_TO_ADDR
// if not x then
44513: LD_VAR 0 11
44517: NOT
44518: IFFALSE 44530
// x := mcts ;
44520: LD_ADDR_VAR 0 11
44524: PUSH
44525: LD_VAR 0 10
44529: ST_TO_ADDR
// if not x then
44530: LD_VAR 0 11
44534: NOT
44535: IFFALSE 44539
// continue ;
44537: GO 44318
// if mc_remote_driver [ i ] then
44539: LD_EXP 118
44543: PUSH
44544: LD_VAR 0 2
44548: ARRAY
44549: IFFALSE 44936
// for j in mc_remote_driver [ i ] do
44551: LD_ADDR_VAR 0 3
44555: PUSH
44556: LD_EXP 118
44560: PUSH
44561: LD_VAR 0 2
44565: ARRAY
44566: PUSH
44567: FOR_IN
44568: IFFALSE 44934
// begin if GetClass ( j ) <> 3 then
44570: LD_VAR 0 3
44574: PPUSH
44575: CALL_OW 257
44579: PUSH
44580: LD_INT 3
44582: NONEQUAL
44583: IFFALSE 44636
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
44585: LD_ADDR_EXP 118
44589: PUSH
44590: LD_EXP 118
44594: PPUSH
44595: LD_VAR 0 2
44599: PPUSH
44600: LD_EXP 118
44604: PUSH
44605: LD_VAR 0 2
44609: ARRAY
44610: PUSH
44611: LD_VAR 0 3
44615: DIFF
44616: PPUSH
44617: CALL_OW 1
44621: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44622: LD_VAR 0 3
44626: PPUSH
44627: LD_INT 0
44629: PPUSH
44630: CALL_OW 109
// continue ;
44634: GO 44567
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
44636: LD_EXP 97
44640: PUSH
44641: LD_VAR 0 2
44645: ARRAY
44646: PPUSH
44647: LD_INT 34
44649: PUSH
44650: LD_INT 31
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 58
44659: PUSH
44660: EMPTY
44661: LIST
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PPUSH
44667: CALL_OW 72
44671: PUSH
44672: LD_VAR 0 3
44676: PPUSH
44677: CALL 88564 0 1
44681: NOT
44682: AND
44683: IFFALSE 44754
// begin if IsInUnit ( j ) then
44685: LD_VAR 0 3
44689: PPUSH
44690: CALL_OW 310
44694: IFFALSE 44705
// ComExitBuilding ( j ) ;
44696: LD_VAR 0 3
44700: PPUSH
44701: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
44705: LD_VAR 0 3
44709: PPUSH
44710: LD_EXP 97
44714: PUSH
44715: LD_VAR 0 2
44719: ARRAY
44720: PPUSH
44721: LD_INT 34
44723: PUSH
44724: LD_INT 31
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 58
44733: PUSH
44734: EMPTY
44735: LIST
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: PPUSH
44741: CALL_OW 72
44745: PUSH
44746: LD_INT 1
44748: ARRAY
44749: PPUSH
44750: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
44754: LD_VAR 0 3
44758: PPUSH
44759: CALL_OW 310
44763: NOT
44764: PUSH
44765: LD_VAR 0 3
44769: PPUSH
44770: CALL_OW 310
44774: PPUSH
44775: CALL_OW 266
44779: PUSH
44780: LD_INT 36
44782: NONEQUAL
44783: PUSH
44784: LD_VAR 0 3
44788: PPUSH
44789: CALL 88564 0 1
44793: NOT
44794: AND
44795: OR
44796: IFFALSE 44932
// begin if IsInUnit ( j ) then
44798: LD_VAR 0 3
44802: PPUSH
44803: CALL_OW 310
44807: IFFALSE 44818
// ComExitBuilding ( j ) ;
44809: LD_VAR 0 3
44813: PPUSH
44814: CALL_OW 122
// ct := 0 ;
44818: LD_ADDR_VAR 0 8
44822: PUSH
44823: LD_INT 0
44825: ST_TO_ADDR
// for k in x do
44826: LD_ADDR_VAR 0 4
44830: PUSH
44831: LD_VAR 0 11
44835: PUSH
44836: FOR_IN
44837: IFFALSE 44910
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
44839: LD_VAR 0 4
44843: PPUSH
44844: CALL_OW 264
44848: PUSH
44849: LD_INT 31
44851: EQUAL
44852: PUSH
44853: LD_VAR 0 4
44857: PPUSH
44858: CALL_OW 311
44862: NOT
44863: AND
44864: PUSH
44865: LD_VAR 0 4
44869: PPUSH
44870: CALL_OW 266
44874: PUSH
44875: LD_INT 36
44877: EQUAL
44878: PUSH
44879: LD_VAR 0 4
44883: PPUSH
44884: CALL_OW 313
44888: PUSH
44889: LD_INT 3
44891: LESS
44892: AND
44893: OR
44894: IFFALSE 44908
// begin ct := k ;
44896: LD_ADDR_VAR 0 8
44900: PUSH
44901: LD_VAR 0 4
44905: ST_TO_ADDR
// break ;
44906: GO 44910
// end ;
44908: GO 44836
44910: POP
44911: POP
// if ct then
44912: LD_VAR 0 8
44916: IFFALSE 44932
// ComEnterUnit ( j , ct ) ;
44918: LD_VAR 0 3
44922: PPUSH
44923: LD_VAR 0 8
44927: PPUSH
44928: CALL_OW 120
// end ; end ;
44932: GO 44567
44934: POP
44935: POP
// places := 0 ;
44936: LD_ADDR_VAR 0 5
44940: PUSH
44941: LD_INT 0
44943: ST_TO_ADDR
// for j = 1 to x do
44944: LD_ADDR_VAR 0 3
44948: PUSH
44949: DOUBLE
44950: LD_INT 1
44952: DEC
44953: ST_TO_ADDR
44954: LD_VAR 0 11
44958: PUSH
44959: FOR_TO
44960: IFFALSE 45036
// if GetWeapon ( x [ j ] ) = ar_control_tower then
44962: LD_VAR 0 11
44966: PUSH
44967: LD_VAR 0 3
44971: ARRAY
44972: PPUSH
44973: CALL_OW 264
44977: PUSH
44978: LD_INT 31
44980: EQUAL
44981: IFFALSE 44999
// places := places + 1 else
44983: LD_ADDR_VAR 0 5
44987: PUSH
44988: LD_VAR 0 5
44992: PUSH
44993: LD_INT 1
44995: PLUS
44996: ST_TO_ADDR
44997: GO 45034
// if GetBType ( x [ j ] ) = b_control_tower then
44999: LD_VAR 0 11
45003: PUSH
45004: LD_VAR 0 3
45008: ARRAY
45009: PPUSH
45010: CALL_OW 266
45014: PUSH
45015: LD_INT 36
45017: EQUAL
45018: IFFALSE 45034
// places := places + 3 ;
45020: LD_ADDR_VAR 0 5
45024: PUSH
45025: LD_VAR 0 5
45029: PUSH
45030: LD_INT 3
45032: PLUS
45033: ST_TO_ADDR
45034: GO 44959
45036: POP
45037: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
45038: LD_VAR 0 5
45042: PUSH
45043: LD_INT 0
45045: EQUAL
45046: PUSH
45047: LD_VAR 0 5
45051: PUSH
45052: LD_EXP 118
45056: PUSH
45057: LD_VAR 0 2
45061: ARRAY
45062: LESSEQUAL
45063: OR
45064: IFFALSE 45068
// continue ;
45066: GO 44318
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
45068: LD_ADDR_VAR 0 6
45072: PUSH
45073: LD_EXP 78
45077: PUSH
45078: LD_VAR 0 2
45082: ARRAY
45083: PPUSH
45084: LD_INT 25
45086: PUSH
45087: LD_INT 3
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PPUSH
45094: CALL_OW 72
45098: PUSH
45099: LD_EXP 118
45103: PUSH
45104: LD_VAR 0 2
45108: ARRAY
45109: DIFF
45110: PPUSH
45111: LD_INT 3
45113: PPUSH
45114: CALL 89464 0 2
45118: ST_TO_ADDR
// for j in tmp do
45119: LD_ADDR_VAR 0 3
45123: PUSH
45124: LD_VAR 0 6
45128: PUSH
45129: FOR_IN
45130: IFFALSE 45165
// if GetTag ( j ) > 0 then
45132: LD_VAR 0 3
45136: PPUSH
45137: CALL_OW 110
45141: PUSH
45142: LD_INT 0
45144: GREATER
45145: IFFALSE 45163
// tmp := tmp diff j ;
45147: LD_ADDR_VAR 0 6
45151: PUSH
45152: LD_VAR 0 6
45156: PUSH
45157: LD_VAR 0 3
45161: DIFF
45162: ST_TO_ADDR
45163: GO 45129
45165: POP
45166: POP
// if not tmp then
45167: LD_VAR 0 6
45171: NOT
45172: IFFALSE 45176
// continue ;
45174: GO 44318
// if places then
45176: LD_VAR 0 5
45180: IFFALSE 45239
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
45182: LD_ADDR_EXP 118
45186: PUSH
45187: LD_EXP 118
45191: PPUSH
45192: LD_VAR 0 2
45196: PPUSH
45197: LD_EXP 118
45201: PUSH
45202: LD_VAR 0 2
45206: ARRAY
45207: PUSH
45208: LD_VAR 0 6
45212: PUSH
45213: LD_INT 1
45215: ARRAY
45216: UNION
45217: PPUSH
45218: CALL_OW 1
45222: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
45223: LD_VAR 0 6
45227: PUSH
45228: LD_INT 1
45230: ARRAY
45231: PPUSH
45232: LD_INT 126
45234: PPUSH
45235: CALL_OW 109
// end ; end ;
45239: GO 44318
45241: POP
45242: POP
// end ;
45243: LD_VAR 0 1
45247: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
45248: LD_INT 0
45250: PPUSH
45251: PPUSH
45252: PPUSH
45253: PPUSH
45254: PPUSH
45255: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
45256: LD_VAR 0 1
45260: NOT
45261: PUSH
45262: LD_VAR 0 2
45266: NOT
45267: OR
45268: PUSH
45269: LD_VAR 0 3
45273: NOT
45274: OR
45275: PUSH
45276: LD_VAR 0 4
45280: PUSH
45281: LD_INT 1
45283: PUSH
45284: LD_INT 2
45286: PUSH
45287: LD_INT 3
45289: PUSH
45290: LD_INT 4
45292: PUSH
45293: LD_INT 5
45295: PUSH
45296: LD_INT 8
45298: PUSH
45299: LD_INT 9
45301: PUSH
45302: LD_INT 15
45304: PUSH
45305: LD_INT 16
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: IN
45319: NOT
45320: OR
45321: IFFALSE 45325
// exit ;
45323: GO 46183
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
45325: LD_ADDR_VAR 0 2
45329: PUSH
45330: LD_VAR 0 2
45334: PPUSH
45335: LD_INT 21
45337: PUSH
45338: LD_INT 3
45340: PUSH
45341: EMPTY
45342: LIST
45343: LIST
45344: PUSH
45345: LD_INT 24
45347: PUSH
45348: LD_INT 250
45350: PUSH
45351: EMPTY
45352: LIST
45353: LIST
45354: PUSH
45355: EMPTY
45356: LIST
45357: LIST
45358: PPUSH
45359: CALL_OW 72
45363: ST_TO_ADDR
// case class of 1 , 15 :
45364: LD_VAR 0 4
45368: PUSH
45369: LD_INT 1
45371: DOUBLE
45372: EQUAL
45373: IFTRUE 45383
45375: LD_INT 15
45377: DOUBLE
45378: EQUAL
45379: IFTRUE 45383
45381: GO 45468
45383: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
45384: LD_ADDR_VAR 0 8
45388: PUSH
45389: LD_VAR 0 2
45393: PPUSH
45394: LD_INT 2
45396: PUSH
45397: LD_INT 30
45399: PUSH
45400: LD_INT 32
45402: PUSH
45403: EMPTY
45404: LIST
45405: LIST
45406: PUSH
45407: LD_INT 30
45409: PUSH
45410: LD_INT 31
45412: PUSH
45413: EMPTY
45414: LIST
45415: LIST
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: LIST
45421: PPUSH
45422: CALL_OW 72
45426: PUSH
45427: LD_VAR 0 2
45431: PPUSH
45432: LD_INT 2
45434: PUSH
45435: LD_INT 30
45437: PUSH
45438: LD_INT 4
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 30
45447: PUSH
45448: LD_INT 5
45450: PUSH
45451: EMPTY
45452: LIST
45453: LIST
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: LIST
45459: PPUSH
45460: CALL_OW 72
45464: ADD
45465: ST_TO_ADDR
45466: GO 45714
45468: LD_INT 2
45470: DOUBLE
45471: EQUAL
45472: IFTRUE 45482
45474: LD_INT 16
45476: DOUBLE
45477: EQUAL
45478: IFTRUE 45482
45480: GO 45528
45482: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45483: LD_ADDR_VAR 0 8
45487: PUSH
45488: LD_VAR 0 2
45492: PPUSH
45493: LD_INT 2
45495: PUSH
45496: LD_INT 30
45498: PUSH
45499: LD_INT 0
45501: PUSH
45502: EMPTY
45503: LIST
45504: LIST
45505: PUSH
45506: LD_INT 30
45508: PUSH
45509: LD_INT 1
45511: PUSH
45512: EMPTY
45513: LIST
45514: LIST
45515: PUSH
45516: EMPTY
45517: LIST
45518: LIST
45519: LIST
45520: PPUSH
45521: CALL_OW 72
45525: ST_TO_ADDR
45526: GO 45714
45528: LD_INT 3
45530: DOUBLE
45531: EQUAL
45532: IFTRUE 45536
45534: GO 45582
45536: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
45537: LD_ADDR_VAR 0 8
45541: PUSH
45542: LD_VAR 0 2
45546: PPUSH
45547: LD_INT 2
45549: PUSH
45550: LD_INT 30
45552: PUSH
45553: LD_INT 2
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: PUSH
45560: LD_INT 30
45562: PUSH
45563: LD_INT 3
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: LIST
45574: PPUSH
45575: CALL_OW 72
45579: ST_TO_ADDR
45580: GO 45714
45582: LD_INT 4
45584: DOUBLE
45585: EQUAL
45586: IFTRUE 45590
45588: GO 45647
45590: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
45591: LD_ADDR_VAR 0 8
45595: PUSH
45596: LD_VAR 0 2
45600: PPUSH
45601: LD_INT 2
45603: PUSH
45604: LD_INT 30
45606: PUSH
45607: LD_INT 6
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: PUSH
45614: LD_INT 30
45616: PUSH
45617: LD_INT 7
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: PUSH
45624: LD_INT 30
45626: PUSH
45627: LD_INT 8
45629: PUSH
45630: EMPTY
45631: LIST
45632: LIST
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: PPUSH
45640: CALL_OW 72
45644: ST_TO_ADDR
45645: GO 45714
45647: LD_INT 5
45649: DOUBLE
45650: EQUAL
45651: IFTRUE 45667
45653: LD_INT 8
45655: DOUBLE
45656: EQUAL
45657: IFTRUE 45667
45659: LD_INT 9
45661: DOUBLE
45662: EQUAL
45663: IFTRUE 45667
45665: GO 45713
45667: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
45668: LD_ADDR_VAR 0 8
45672: PUSH
45673: LD_VAR 0 2
45677: PPUSH
45678: LD_INT 2
45680: PUSH
45681: LD_INT 30
45683: PUSH
45684: LD_INT 4
45686: PUSH
45687: EMPTY
45688: LIST
45689: LIST
45690: PUSH
45691: LD_INT 30
45693: PUSH
45694: LD_INT 5
45696: PUSH
45697: EMPTY
45698: LIST
45699: LIST
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: LIST
45705: PPUSH
45706: CALL_OW 72
45710: ST_TO_ADDR
45711: GO 45714
45713: POP
// if not tmp then
45714: LD_VAR 0 8
45718: NOT
45719: IFFALSE 45723
// exit ;
45721: GO 46183
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
45723: LD_VAR 0 4
45727: PUSH
45728: LD_INT 1
45730: PUSH
45731: LD_INT 15
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: IN
45738: PUSH
45739: LD_EXP 87
45743: PUSH
45744: LD_VAR 0 1
45748: ARRAY
45749: AND
45750: IFFALSE 45906
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
45752: LD_ADDR_VAR 0 9
45756: PUSH
45757: LD_EXP 87
45761: PUSH
45762: LD_VAR 0 1
45766: ARRAY
45767: PUSH
45768: LD_INT 1
45770: ARRAY
45771: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
45772: LD_VAR 0 9
45776: PUSH
45777: LD_EXP 88
45781: PUSH
45782: LD_VAR 0 1
45786: ARRAY
45787: IN
45788: NOT
45789: IFFALSE 45904
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
45791: LD_ADDR_EXP 88
45795: PUSH
45796: LD_EXP 88
45800: PPUSH
45801: LD_VAR 0 1
45805: PUSH
45806: LD_EXP 88
45810: PUSH
45811: LD_VAR 0 1
45815: ARRAY
45816: PUSH
45817: LD_INT 1
45819: PLUS
45820: PUSH
45821: EMPTY
45822: LIST
45823: LIST
45824: PPUSH
45825: LD_VAR 0 9
45829: PPUSH
45830: CALL 58220 0 3
45834: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
45835: LD_ADDR_EXP 87
45839: PUSH
45840: LD_EXP 87
45844: PPUSH
45845: LD_VAR 0 1
45849: PPUSH
45850: LD_EXP 87
45854: PUSH
45855: LD_VAR 0 1
45859: ARRAY
45860: PUSH
45861: LD_VAR 0 9
45865: DIFF
45866: PPUSH
45867: CALL_OW 1
45871: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
45872: LD_VAR 0 3
45876: PPUSH
45877: LD_EXP 88
45881: PUSH
45882: LD_VAR 0 1
45886: ARRAY
45887: PUSH
45888: LD_EXP 88
45892: PUSH
45893: LD_VAR 0 1
45897: ARRAY
45898: ARRAY
45899: PPUSH
45900: CALL_OW 120
// end ; exit ;
45904: GO 46183
// end ; if tmp > 1 then
45906: LD_VAR 0 8
45910: PUSH
45911: LD_INT 1
45913: GREATER
45914: IFFALSE 46018
// for i = 2 to tmp do
45916: LD_ADDR_VAR 0 6
45920: PUSH
45921: DOUBLE
45922: LD_INT 2
45924: DEC
45925: ST_TO_ADDR
45926: LD_VAR 0 8
45930: PUSH
45931: FOR_TO
45932: IFFALSE 46016
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
45934: LD_VAR 0 8
45938: PUSH
45939: LD_VAR 0 6
45943: ARRAY
45944: PPUSH
45945: CALL_OW 461
45949: PUSH
45950: LD_INT 6
45952: EQUAL
45953: IFFALSE 46014
// begin x := tmp [ i ] ;
45955: LD_ADDR_VAR 0 9
45959: PUSH
45960: LD_VAR 0 8
45964: PUSH
45965: LD_VAR 0 6
45969: ARRAY
45970: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
45971: LD_ADDR_VAR 0 8
45975: PUSH
45976: LD_VAR 0 8
45980: PPUSH
45981: LD_VAR 0 6
45985: PPUSH
45986: CALL_OW 3
45990: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
45991: LD_ADDR_VAR 0 8
45995: PUSH
45996: LD_VAR 0 8
46000: PPUSH
46001: LD_INT 1
46003: PPUSH
46004: LD_VAR 0 9
46008: PPUSH
46009: CALL_OW 2
46013: ST_TO_ADDR
// end ;
46014: GO 45931
46016: POP
46017: POP
// for i in tmp do
46018: LD_ADDR_VAR 0 6
46022: PUSH
46023: LD_VAR 0 8
46027: PUSH
46028: FOR_IN
46029: IFFALSE 46056
// begin if IsNotFull ( i ) then
46031: LD_VAR 0 6
46035: PPUSH
46036: CALL 55442 0 1
46040: IFFALSE 46054
// begin j := i ;
46042: LD_ADDR_VAR 0 7
46046: PUSH
46047: LD_VAR 0 6
46051: ST_TO_ADDR
// break ;
46052: GO 46056
// end ; end ;
46054: GO 46028
46056: POP
46057: POP
// if j then
46058: LD_VAR 0 7
46062: IFFALSE 46080
// ComEnterUnit ( unit , j ) else
46064: LD_VAR 0 3
46068: PPUSH
46069: LD_VAR 0 7
46073: PPUSH
46074: CALL_OW 120
46078: GO 46183
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46080: LD_ADDR_VAR 0 10
46084: PUSH
46085: LD_VAR 0 2
46089: PPUSH
46090: LD_INT 2
46092: PUSH
46093: LD_INT 30
46095: PUSH
46096: LD_INT 0
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: PUSH
46103: LD_INT 30
46105: PUSH
46106: LD_INT 1
46108: PUSH
46109: EMPTY
46110: LIST
46111: LIST
46112: PUSH
46113: EMPTY
46114: LIST
46115: LIST
46116: LIST
46117: PPUSH
46118: CALL_OW 72
46122: ST_TO_ADDR
// if depot then
46123: LD_VAR 0 10
46127: IFFALSE 46183
// begin depot := NearestUnitToUnit ( depot , unit ) ;
46129: LD_ADDR_VAR 0 10
46133: PUSH
46134: LD_VAR 0 10
46138: PPUSH
46139: LD_VAR 0 3
46143: PPUSH
46144: CALL_OW 74
46148: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
46149: LD_VAR 0 3
46153: PPUSH
46154: LD_VAR 0 10
46158: PPUSH
46159: CALL_OW 296
46163: PUSH
46164: LD_INT 10
46166: GREATER
46167: IFFALSE 46183
// ComStandNearbyBuilding ( unit , depot ) ;
46169: LD_VAR 0 3
46173: PPUSH
46174: LD_VAR 0 10
46178: PPUSH
46179: CALL 54822 0 2
// end ; end ; end ;
46183: LD_VAR 0 5
46187: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
46188: LD_INT 0
46190: PPUSH
46191: PPUSH
46192: PPUSH
46193: PPUSH
// if not mc_bases then
46194: LD_EXP 78
46198: NOT
46199: IFFALSE 46203
// exit ;
46201: GO 46442
// for i = 1 to mc_bases do
46203: LD_ADDR_VAR 0 2
46207: PUSH
46208: DOUBLE
46209: LD_INT 1
46211: DEC
46212: ST_TO_ADDR
46213: LD_EXP 78
46217: PUSH
46218: FOR_TO
46219: IFFALSE 46440
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
46221: LD_ADDR_VAR 0 4
46225: PUSH
46226: LD_EXP 78
46230: PUSH
46231: LD_VAR 0 2
46235: ARRAY
46236: PPUSH
46237: LD_INT 21
46239: PUSH
46240: LD_INT 1
46242: PUSH
46243: EMPTY
46244: LIST
46245: LIST
46246: PPUSH
46247: CALL_OW 72
46251: PUSH
46252: LD_EXP 107
46256: PUSH
46257: LD_VAR 0 2
46261: ARRAY
46262: UNION
46263: ST_TO_ADDR
// if not tmp then
46264: LD_VAR 0 4
46268: NOT
46269: IFFALSE 46273
// continue ;
46271: GO 46218
// for j in tmp do
46273: LD_ADDR_VAR 0 3
46277: PUSH
46278: LD_VAR 0 4
46282: PUSH
46283: FOR_IN
46284: IFFALSE 46436
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
46286: LD_VAR 0 3
46290: PPUSH
46291: CALL_OW 110
46295: NOT
46296: PUSH
46297: LD_VAR 0 3
46301: PPUSH
46302: CALL_OW 314
46306: NOT
46307: AND
46308: PUSH
46309: LD_VAR 0 3
46313: PPUSH
46314: CALL_OW 311
46318: NOT
46319: AND
46320: PUSH
46321: LD_VAR 0 3
46325: PPUSH
46326: CALL_OW 310
46330: NOT
46331: AND
46332: PUSH
46333: LD_VAR 0 3
46337: PUSH
46338: LD_EXP 81
46342: PUSH
46343: LD_VAR 0 2
46347: ARRAY
46348: PUSH
46349: LD_INT 1
46351: ARRAY
46352: IN
46353: NOT
46354: AND
46355: PUSH
46356: LD_VAR 0 3
46360: PUSH
46361: LD_EXP 81
46365: PUSH
46366: LD_VAR 0 2
46370: ARRAY
46371: PUSH
46372: LD_INT 2
46374: ARRAY
46375: IN
46376: NOT
46377: AND
46378: PUSH
46379: LD_VAR 0 3
46383: PUSH
46384: LD_EXP 90
46388: PUSH
46389: LD_VAR 0 2
46393: ARRAY
46394: IN
46395: NOT
46396: AND
46397: IFFALSE 46434
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
46399: LD_VAR 0 2
46403: PPUSH
46404: LD_EXP 78
46408: PUSH
46409: LD_VAR 0 2
46413: ARRAY
46414: PPUSH
46415: LD_VAR 0 3
46419: PPUSH
46420: LD_VAR 0 3
46424: PPUSH
46425: CALL_OW 257
46429: PPUSH
46430: CALL 45248 0 4
// end ;
46434: GO 46283
46436: POP
46437: POP
// end ;
46438: GO 46218
46440: POP
46441: POP
// end ;
46442: LD_VAR 0 1
46446: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46447: LD_INT 0
46449: PPUSH
46450: PPUSH
46451: PPUSH
46452: PPUSH
46453: PPUSH
46454: PPUSH
// if not mc_bases [ base ] then
46455: LD_EXP 78
46459: PUSH
46460: LD_VAR 0 1
46464: ARRAY
46465: NOT
46466: IFFALSE 46470
// exit ;
46468: GO 46671
// tmp := [ ] ;
46470: LD_ADDR_VAR 0 6
46474: PUSH
46475: EMPTY
46476: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46477: LD_ADDR_VAR 0 7
46481: PUSH
46482: LD_VAR 0 3
46486: PPUSH
46487: LD_INT 0
46489: PPUSH
46490: CALL_OW 517
46494: ST_TO_ADDR
// if not list then
46495: LD_VAR 0 7
46499: NOT
46500: IFFALSE 46504
// exit ;
46502: GO 46671
// c := Count ( list [ 1 ] ) ;
46504: LD_ADDR_VAR 0 9
46508: PUSH
46509: LD_VAR 0 7
46513: PUSH
46514: LD_INT 1
46516: ARRAY
46517: PPUSH
46518: CALL 55360 0 1
46522: ST_TO_ADDR
// if amount > c then
46523: LD_VAR 0 2
46527: PUSH
46528: LD_VAR 0 9
46532: GREATER
46533: IFFALSE 46545
// amount := c ;
46535: LD_ADDR_VAR 0 2
46539: PUSH
46540: LD_VAR 0 9
46544: ST_TO_ADDR
// for i := 1 to amount do
46545: LD_ADDR_VAR 0 5
46549: PUSH
46550: DOUBLE
46551: LD_INT 1
46553: DEC
46554: ST_TO_ADDR
46555: LD_VAR 0 2
46559: PUSH
46560: FOR_TO
46561: IFFALSE 46619
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
46563: LD_ADDR_VAR 0 6
46567: PUSH
46568: LD_VAR 0 6
46572: PPUSH
46573: LD_VAR 0 5
46577: PPUSH
46578: LD_VAR 0 7
46582: PUSH
46583: LD_INT 1
46585: ARRAY
46586: PUSH
46587: LD_VAR 0 5
46591: ARRAY
46592: PUSH
46593: LD_VAR 0 7
46597: PUSH
46598: LD_INT 2
46600: ARRAY
46601: PUSH
46602: LD_VAR 0 5
46606: ARRAY
46607: PUSH
46608: EMPTY
46609: LIST
46610: LIST
46611: PPUSH
46612: CALL_OW 1
46616: ST_TO_ADDR
46617: GO 46560
46619: POP
46620: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
46621: LD_ADDR_EXP 91
46625: PUSH
46626: LD_EXP 91
46630: PPUSH
46631: LD_VAR 0 1
46635: PPUSH
46636: LD_VAR 0 6
46640: PPUSH
46641: CALL_OW 1
46645: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
46646: LD_ADDR_EXP 93
46650: PUSH
46651: LD_EXP 93
46655: PPUSH
46656: LD_VAR 0 1
46660: PPUSH
46661: LD_VAR 0 3
46665: PPUSH
46666: CALL_OW 1
46670: ST_TO_ADDR
// end ;
46671: LD_VAR 0 4
46675: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
46676: LD_INT 0
46678: PPUSH
// if not mc_bases [ base ] then
46679: LD_EXP 78
46683: PUSH
46684: LD_VAR 0 1
46688: ARRAY
46689: NOT
46690: IFFALSE 46694
// exit ;
46692: GO 46719
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
46694: LD_ADDR_EXP 83
46698: PUSH
46699: LD_EXP 83
46703: PPUSH
46704: LD_VAR 0 1
46708: PPUSH
46709: LD_VAR 0 2
46713: PPUSH
46714: CALL_OW 1
46718: ST_TO_ADDR
// end ;
46719: LD_VAR 0 3
46723: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
46724: LD_INT 0
46726: PPUSH
// if not mc_bases [ base ] then
46727: LD_EXP 78
46731: PUSH
46732: LD_VAR 0 1
46736: ARRAY
46737: NOT
46738: IFFALSE 46742
// exit ;
46740: GO 46779
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
46742: LD_ADDR_EXP 83
46746: PUSH
46747: LD_EXP 83
46751: PPUSH
46752: LD_VAR 0 1
46756: PPUSH
46757: LD_EXP 83
46761: PUSH
46762: LD_VAR 0 1
46766: ARRAY
46767: PUSH
46768: LD_VAR 0 2
46772: UNION
46773: PPUSH
46774: CALL_OW 1
46778: ST_TO_ADDR
// end ;
46779: LD_VAR 0 3
46783: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
46784: LD_INT 0
46786: PPUSH
// if not mc_bases [ base ] then
46787: LD_EXP 78
46791: PUSH
46792: LD_VAR 0 1
46796: ARRAY
46797: NOT
46798: IFFALSE 46802
// exit ;
46800: GO 46827
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
46802: LD_ADDR_EXP 99
46806: PUSH
46807: LD_EXP 99
46811: PPUSH
46812: LD_VAR 0 1
46816: PPUSH
46817: LD_VAR 0 2
46821: PPUSH
46822: CALL_OW 1
46826: ST_TO_ADDR
// end ;
46827: LD_VAR 0 3
46831: RET
// export function MC_InsertProduceList ( base , components ) ; begin
46832: LD_INT 0
46834: PPUSH
// if not mc_bases [ base ] then
46835: LD_EXP 78
46839: PUSH
46840: LD_VAR 0 1
46844: ARRAY
46845: NOT
46846: IFFALSE 46850
// exit ;
46848: GO 46887
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
46850: LD_ADDR_EXP 99
46854: PUSH
46855: LD_EXP 99
46859: PPUSH
46860: LD_VAR 0 1
46864: PPUSH
46865: LD_EXP 99
46869: PUSH
46870: LD_VAR 0 1
46874: ARRAY
46875: PUSH
46876: LD_VAR 0 2
46880: ADD
46881: PPUSH
46882: CALL_OW 1
46886: ST_TO_ADDR
// end ;
46887: LD_VAR 0 3
46891: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
46892: LD_INT 0
46894: PPUSH
// if not mc_bases [ base ] then
46895: LD_EXP 78
46899: PUSH
46900: LD_VAR 0 1
46904: ARRAY
46905: NOT
46906: IFFALSE 46910
// exit ;
46908: GO 46964
// mc_defender := Replace ( mc_defender , base , deflist ) ;
46910: LD_ADDR_EXP 100
46914: PUSH
46915: LD_EXP 100
46919: PPUSH
46920: LD_VAR 0 1
46924: PPUSH
46925: LD_VAR 0 2
46929: PPUSH
46930: CALL_OW 1
46934: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
46935: LD_ADDR_EXP 89
46939: PUSH
46940: LD_EXP 89
46944: PPUSH
46945: LD_VAR 0 1
46949: PPUSH
46950: LD_VAR 0 2
46954: PUSH
46955: LD_INT 0
46957: PLUS
46958: PPUSH
46959: CALL_OW 1
46963: ST_TO_ADDR
// end ;
46964: LD_VAR 0 3
46968: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
46969: LD_INT 0
46971: PPUSH
// if not mc_bases [ base ] then
46972: LD_EXP 78
46976: PUSH
46977: LD_VAR 0 1
46981: ARRAY
46982: NOT
46983: IFFALSE 46987
// exit ;
46985: GO 47012
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
46987: LD_ADDR_EXP 89
46991: PUSH
46992: LD_EXP 89
46996: PPUSH
46997: LD_VAR 0 1
47001: PPUSH
47002: LD_VAR 0 2
47006: PPUSH
47007: CALL_OW 1
47011: ST_TO_ADDR
// end ;
47012: LD_VAR 0 3
47016: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
47017: LD_INT 0
47019: PPUSH
47020: PPUSH
47021: PPUSH
47022: PPUSH
// if not mc_bases [ base ] then
47023: LD_EXP 78
47027: PUSH
47028: LD_VAR 0 1
47032: ARRAY
47033: NOT
47034: IFFALSE 47038
// exit ;
47036: GO 47103
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
47038: LD_ADDR_EXP 98
47042: PUSH
47043: LD_EXP 98
47047: PPUSH
47048: LD_VAR 0 1
47052: PUSH
47053: LD_EXP 98
47057: PUSH
47058: LD_VAR 0 1
47062: ARRAY
47063: PUSH
47064: LD_INT 1
47066: PLUS
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: PPUSH
47072: LD_VAR 0 1
47076: PUSH
47077: LD_VAR 0 2
47081: PUSH
47082: LD_VAR 0 3
47086: PUSH
47087: LD_VAR 0 4
47091: PUSH
47092: EMPTY
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: PPUSH
47098: CALL 58220 0 3
47102: ST_TO_ADDR
// end ;
47103: LD_VAR 0 5
47107: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
47108: LD_INT 0
47110: PPUSH
// if not mc_bases [ base ] then
47111: LD_EXP 78
47115: PUSH
47116: LD_VAR 0 1
47120: ARRAY
47121: NOT
47122: IFFALSE 47126
// exit ;
47124: GO 47151
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
47126: LD_ADDR_EXP 115
47130: PUSH
47131: LD_EXP 115
47135: PPUSH
47136: LD_VAR 0 1
47140: PPUSH
47141: LD_VAR 0 2
47145: PPUSH
47146: CALL_OW 1
47150: ST_TO_ADDR
// end ;
47151: LD_VAR 0 3
47155: RET
// export function MC_GetMinesField ( base ) ; begin
47156: LD_INT 0
47158: PPUSH
// result := mc_mines [ base ] ;
47159: LD_ADDR_VAR 0 2
47163: PUSH
47164: LD_EXP 91
47168: PUSH
47169: LD_VAR 0 1
47173: ARRAY
47174: ST_TO_ADDR
// end ;
47175: LD_VAR 0 2
47179: RET
// export function MC_GetProduceList ( base ) ; begin
47180: LD_INT 0
47182: PPUSH
// result := mc_produce [ base ] ;
47183: LD_ADDR_VAR 0 2
47187: PUSH
47188: LD_EXP 99
47192: PUSH
47193: LD_VAR 0 1
47197: ARRAY
47198: ST_TO_ADDR
// end ;
47199: LD_VAR 0 2
47203: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
47204: LD_INT 0
47206: PPUSH
47207: PPUSH
// if not mc_bases then
47208: LD_EXP 78
47212: NOT
47213: IFFALSE 47217
// exit ;
47215: GO 47282
// if mc_bases [ base ] then
47217: LD_EXP 78
47221: PUSH
47222: LD_VAR 0 1
47226: ARRAY
47227: IFFALSE 47282
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47229: LD_ADDR_VAR 0 3
47233: PUSH
47234: LD_EXP 78
47238: PUSH
47239: LD_VAR 0 1
47243: ARRAY
47244: PPUSH
47245: LD_INT 30
47247: PUSH
47248: LD_VAR 0 2
47252: PUSH
47253: EMPTY
47254: LIST
47255: LIST
47256: PPUSH
47257: CALL_OW 72
47261: ST_TO_ADDR
// if result then
47262: LD_VAR 0 3
47266: IFFALSE 47282
// result := result [ 1 ] ;
47268: LD_ADDR_VAR 0 3
47272: PUSH
47273: LD_VAR 0 3
47277: PUSH
47278: LD_INT 1
47280: ARRAY
47281: ST_TO_ADDR
// end ; end ;
47282: LD_VAR 0 3
47286: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
47287: LD_INT 0
47289: PPUSH
47290: PPUSH
// if not mc_bases then
47291: LD_EXP 78
47295: NOT
47296: IFFALSE 47300
// exit ;
47298: GO 47345
// if mc_bases [ base ] then
47300: LD_EXP 78
47304: PUSH
47305: LD_VAR 0 1
47309: ARRAY
47310: IFFALSE 47345
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47312: LD_ADDR_VAR 0 3
47316: PUSH
47317: LD_EXP 78
47321: PUSH
47322: LD_VAR 0 1
47326: ARRAY
47327: PPUSH
47328: LD_INT 30
47330: PUSH
47331: LD_VAR 0 2
47335: PUSH
47336: EMPTY
47337: LIST
47338: LIST
47339: PPUSH
47340: CALL_OW 72
47344: ST_TO_ADDR
// end ;
47345: LD_VAR 0 3
47349: RET
// export function MC_SetTame ( base , area ) ; begin
47350: LD_INT 0
47352: PPUSH
// if not mc_bases or not base then
47353: LD_EXP 78
47357: NOT
47358: PUSH
47359: LD_VAR 0 1
47363: NOT
47364: OR
47365: IFFALSE 47369
// exit ;
47367: GO 47394
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
47369: LD_ADDR_EXP 106
47373: PUSH
47374: LD_EXP 106
47378: PPUSH
47379: LD_VAR 0 1
47383: PPUSH
47384: LD_VAR 0 2
47388: PPUSH
47389: CALL_OW 1
47393: ST_TO_ADDR
// end ;
47394: LD_VAR 0 3
47398: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
47399: LD_INT 0
47401: PPUSH
47402: PPUSH
// if not mc_bases or not base then
47403: LD_EXP 78
47407: NOT
47408: PUSH
47409: LD_VAR 0 1
47413: NOT
47414: OR
47415: IFFALSE 47419
// exit ;
47417: GO 47521
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47419: LD_ADDR_VAR 0 4
47423: PUSH
47424: LD_EXP 78
47428: PUSH
47429: LD_VAR 0 1
47433: ARRAY
47434: PPUSH
47435: LD_INT 30
47437: PUSH
47438: LD_VAR 0 2
47442: PUSH
47443: EMPTY
47444: LIST
47445: LIST
47446: PPUSH
47447: CALL_OW 72
47451: ST_TO_ADDR
// if not tmp then
47452: LD_VAR 0 4
47456: NOT
47457: IFFALSE 47461
// exit ;
47459: GO 47521
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47461: LD_ADDR_EXP 110
47465: PUSH
47466: LD_EXP 110
47470: PPUSH
47471: LD_VAR 0 1
47475: PPUSH
47476: LD_EXP 110
47480: PUSH
47481: LD_VAR 0 1
47485: ARRAY
47486: PPUSH
47487: LD_EXP 110
47491: PUSH
47492: LD_VAR 0 1
47496: ARRAY
47497: PUSH
47498: LD_INT 1
47500: PLUS
47501: PPUSH
47502: LD_VAR 0 4
47506: PUSH
47507: LD_INT 1
47509: ARRAY
47510: PPUSH
47511: CALL_OW 2
47515: PPUSH
47516: CALL_OW 1
47520: ST_TO_ADDR
// end ;
47521: LD_VAR 0 3
47525: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47526: LD_INT 0
47528: PPUSH
47529: PPUSH
// if not mc_bases or not base or not kinds then
47530: LD_EXP 78
47534: NOT
47535: PUSH
47536: LD_VAR 0 1
47540: NOT
47541: OR
47542: PUSH
47543: LD_VAR 0 2
47547: NOT
47548: OR
47549: IFFALSE 47553
// exit ;
47551: GO 47614
// for i in kinds do
47553: LD_ADDR_VAR 0 4
47557: PUSH
47558: LD_VAR 0 2
47562: PUSH
47563: FOR_IN
47564: IFFALSE 47612
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
47566: LD_ADDR_EXP 112
47570: PUSH
47571: LD_EXP 112
47575: PPUSH
47576: LD_VAR 0 1
47580: PUSH
47581: LD_EXP 112
47585: PUSH
47586: LD_VAR 0 1
47590: ARRAY
47591: PUSH
47592: LD_INT 1
47594: PLUS
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: PPUSH
47600: LD_VAR 0 4
47604: PPUSH
47605: CALL 58220 0 3
47609: ST_TO_ADDR
47610: GO 47563
47612: POP
47613: POP
// end ;
47614: LD_VAR 0 3
47618: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
47619: LD_INT 0
47621: PPUSH
// if not mc_bases or not base or not areas then
47622: LD_EXP 78
47626: NOT
47627: PUSH
47628: LD_VAR 0 1
47632: NOT
47633: OR
47634: PUSH
47635: LD_VAR 0 2
47639: NOT
47640: OR
47641: IFFALSE 47645
// exit ;
47643: GO 47670
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
47645: LD_ADDR_EXP 96
47649: PUSH
47650: LD_EXP 96
47654: PPUSH
47655: LD_VAR 0 1
47659: PPUSH
47660: LD_VAR 0 2
47664: PPUSH
47665: CALL_OW 1
47669: ST_TO_ADDR
// end ;
47670: LD_VAR 0 3
47674: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
47675: LD_INT 0
47677: PPUSH
// if not mc_bases or not base or not teleports_exit then
47678: LD_EXP 78
47682: NOT
47683: PUSH
47684: LD_VAR 0 1
47688: NOT
47689: OR
47690: PUSH
47691: LD_VAR 0 2
47695: NOT
47696: OR
47697: IFFALSE 47701
// exit ;
47699: GO 47726
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
47701: LD_ADDR_EXP 113
47705: PUSH
47706: LD_EXP 113
47710: PPUSH
47711: LD_VAR 0 1
47715: PPUSH
47716: LD_VAR 0 2
47720: PPUSH
47721: CALL_OW 1
47725: ST_TO_ADDR
// end ;
47726: LD_VAR 0 3
47730: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
47731: LD_INT 0
47733: PPUSH
47734: PPUSH
47735: PPUSH
// if not mc_bases or not base or not ext_list then
47736: LD_EXP 78
47740: NOT
47741: PUSH
47742: LD_VAR 0 1
47746: NOT
47747: OR
47748: PUSH
47749: LD_VAR 0 5
47753: NOT
47754: OR
47755: IFFALSE 47759
// exit ;
47757: GO 47932
// tmp := GetFacExtXYD ( x , y , d ) ;
47759: LD_ADDR_VAR 0 8
47763: PUSH
47764: LD_VAR 0 2
47768: PPUSH
47769: LD_VAR 0 3
47773: PPUSH
47774: LD_VAR 0 4
47778: PPUSH
47779: CALL 88594 0 3
47783: ST_TO_ADDR
// if not tmp then
47784: LD_VAR 0 8
47788: NOT
47789: IFFALSE 47793
// exit ;
47791: GO 47932
// for i in tmp do
47793: LD_ADDR_VAR 0 7
47797: PUSH
47798: LD_VAR 0 8
47802: PUSH
47803: FOR_IN
47804: IFFALSE 47930
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
47806: LD_ADDR_EXP 83
47810: PUSH
47811: LD_EXP 83
47815: PPUSH
47816: LD_VAR 0 1
47820: PPUSH
47821: LD_EXP 83
47825: PUSH
47826: LD_VAR 0 1
47830: ARRAY
47831: PPUSH
47832: LD_EXP 83
47836: PUSH
47837: LD_VAR 0 1
47841: ARRAY
47842: PUSH
47843: LD_INT 1
47845: PLUS
47846: PPUSH
47847: LD_VAR 0 5
47851: PUSH
47852: LD_INT 1
47854: ARRAY
47855: PUSH
47856: LD_VAR 0 7
47860: PUSH
47861: LD_INT 1
47863: ARRAY
47864: PUSH
47865: LD_VAR 0 7
47869: PUSH
47870: LD_INT 2
47872: ARRAY
47873: PUSH
47874: LD_VAR 0 7
47878: PUSH
47879: LD_INT 3
47881: ARRAY
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: PPUSH
47889: CALL_OW 2
47893: PPUSH
47894: CALL_OW 1
47898: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
47899: LD_ADDR_VAR 0 5
47903: PUSH
47904: LD_VAR 0 5
47908: PPUSH
47909: LD_INT 1
47911: PPUSH
47912: CALL_OW 3
47916: ST_TO_ADDR
// if not ext_list then
47917: LD_VAR 0 5
47921: NOT
47922: IFFALSE 47928
// exit ;
47924: POP
47925: POP
47926: GO 47932
// end ;
47928: GO 47803
47930: POP
47931: POP
// end ;
47932: LD_VAR 0 6
47936: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
47937: LD_INT 0
47939: PPUSH
// if not mc_bases or not base or not weapon_list then
47940: LD_EXP 78
47944: NOT
47945: PUSH
47946: LD_VAR 0 1
47950: NOT
47951: OR
47952: PUSH
47953: LD_VAR 0 2
47957: NOT
47958: OR
47959: IFFALSE 47963
// exit ;
47961: GO 47988
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
47963: LD_ADDR_EXP 117
47967: PUSH
47968: LD_EXP 117
47972: PPUSH
47973: LD_VAR 0 1
47977: PPUSH
47978: LD_VAR 0 2
47982: PPUSH
47983: CALL_OW 1
47987: ST_TO_ADDR
// end ;
47988: LD_VAR 0 3
47992: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
47993: LD_INT 0
47995: PPUSH
// if not mc_bases or not base or not tech_list then
47996: LD_EXP 78
48000: NOT
48001: PUSH
48002: LD_VAR 0 1
48006: NOT
48007: OR
48008: PUSH
48009: LD_VAR 0 2
48013: NOT
48014: OR
48015: IFFALSE 48019
// exit ;
48017: GO 48044
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
48019: LD_ADDR_EXP 105
48023: PUSH
48024: LD_EXP 105
48028: PPUSH
48029: LD_VAR 0 1
48033: PPUSH
48034: LD_VAR 0 2
48038: PPUSH
48039: CALL_OW 1
48043: ST_TO_ADDR
// end ;
48044: LD_VAR 0 3
48048: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
48049: LD_INT 0
48051: PPUSH
// if not mc_bases or not parking_area or not base then
48052: LD_EXP 78
48056: NOT
48057: PUSH
48058: LD_VAR 0 2
48062: NOT
48063: OR
48064: PUSH
48065: LD_VAR 0 1
48069: NOT
48070: OR
48071: IFFALSE 48075
// exit ;
48073: GO 48100
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
48075: LD_ADDR_EXP 102
48079: PUSH
48080: LD_EXP 102
48084: PPUSH
48085: LD_VAR 0 1
48089: PPUSH
48090: LD_VAR 0 2
48094: PPUSH
48095: CALL_OW 1
48099: ST_TO_ADDR
// end ;
48100: LD_VAR 0 3
48104: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
48105: LD_INT 0
48107: PPUSH
// if not mc_bases or not base or not scan_area then
48108: LD_EXP 78
48112: NOT
48113: PUSH
48114: LD_VAR 0 1
48118: NOT
48119: OR
48120: PUSH
48121: LD_VAR 0 2
48125: NOT
48126: OR
48127: IFFALSE 48131
// exit ;
48129: GO 48156
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
48131: LD_ADDR_EXP 103
48135: PUSH
48136: LD_EXP 103
48140: PPUSH
48141: LD_VAR 0 1
48145: PPUSH
48146: LD_VAR 0 2
48150: PPUSH
48151: CALL_OW 1
48155: ST_TO_ADDR
// end ;
48156: LD_VAR 0 3
48160: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
48161: LD_INT 0
48163: PPUSH
48164: PPUSH
// if not mc_bases or not base then
48165: LD_EXP 78
48169: NOT
48170: PUSH
48171: LD_VAR 0 1
48175: NOT
48176: OR
48177: IFFALSE 48181
// exit ;
48179: GO 48245
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
48181: LD_ADDR_VAR 0 3
48185: PUSH
48186: LD_INT 1
48188: PUSH
48189: LD_INT 2
48191: PUSH
48192: LD_INT 3
48194: PUSH
48195: LD_INT 4
48197: PUSH
48198: LD_INT 11
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
48208: LD_ADDR_EXP 105
48212: PUSH
48213: LD_EXP 105
48217: PPUSH
48218: LD_VAR 0 1
48222: PPUSH
48223: LD_EXP 105
48227: PUSH
48228: LD_VAR 0 1
48232: ARRAY
48233: PUSH
48234: LD_VAR 0 3
48238: DIFF
48239: PPUSH
48240: CALL_OW 1
48244: ST_TO_ADDR
// end ;
48245: LD_VAR 0 2
48249: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
48250: LD_INT 0
48252: PPUSH
// result := mc_vehicles [ base ] ;
48253: LD_ADDR_VAR 0 3
48257: PUSH
48258: LD_EXP 97
48262: PUSH
48263: LD_VAR 0 1
48267: ARRAY
48268: ST_TO_ADDR
// if onlyCombat then
48269: LD_VAR 0 2
48273: IFFALSE 48445
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
48275: LD_ADDR_VAR 0 3
48279: PUSH
48280: LD_VAR 0 3
48284: PUSH
48285: LD_VAR 0 3
48289: PPUSH
48290: LD_INT 2
48292: PUSH
48293: LD_INT 34
48295: PUSH
48296: LD_INT 12
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: PUSH
48303: LD_INT 34
48305: PUSH
48306: LD_INT 51
48308: PUSH
48309: EMPTY
48310: LIST
48311: LIST
48312: PUSH
48313: LD_INT 34
48315: PUSH
48316: LD_INT 89
48318: PUSH
48319: EMPTY
48320: LIST
48321: LIST
48322: PUSH
48323: LD_INT 34
48325: PUSH
48326: LD_INT 32
48328: PUSH
48329: EMPTY
48330: LIST
48331: LIST
48332: PUSH
48333: LD_INT 34
48335: PUSH
48336: LD_INT 13
48338: PUSH
48339: EMPTY
48340: LIST
48341: LIST
48342: PUSH
48343: LD_INT 34
48345: PUSH
48346: LD_INT 52
48348: PUSH
48349: EMPTY
48350: LIST
48351: LIST
48352: PUSH
48353: LD_INT 34
48355: PUSH
48356: LD_INT 88
48358: PUSH
48359: EMPTY
48360: LIST
48361: LIST
48362: PUSH
48363: LD_INT 34
48365: PUSH
48366: LD_INT 14
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PUSH
48373: LD_INT 34
48375: PUSH
48376: LD_INT 53
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PUSH
48383: LD_INT 34
48385: PUSH
48386: LD_INT 98
48388: PUSH
48389: EMPTY
48390: LIST
48391: LIST
48392: PUSH
48393: LD_INT 34
48395: PUSH
48396: LD_INT 31
48398: PUSH
48399: EMPTY
48400: LIST
48401: LIST
48402: PUSH
48403: LD_INT 34
48405: PUSH
48406: LD_INT 48
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: PUSH
48413: LD_INT 34
48415: PUSH
48416: LD_INT 8
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: EMPTY
48424: LIST
48425: LIST
48426: LIST
48427: LIST
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: LIST
48433: LIST
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: PPUSH
48439: CALL_OW 72
48443: DIFF
48444: ST_TO_ADDR
// end ; end_of_file
48445: LD_VAR 0 3
48449: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48450: LD_INT 0
48452: PPUSH
48453: PPUSH
48454: PPUSH
// if not mc_bases or not skirmish then
48455: LD_EXP 78
48459: NOT
48460: PUSH
48461: LD_EXP 76
48465: NOT
48466: OR
48467: IFFALSE 48471
// exit ;
48469: GO 48636
// for i = 1 to mc_bases do
48471: LD_ADDR_VAR 0 4
48475: PUSH
48476: DOUBLE
48477: LD_INT 1
48479: DEC
48480: ST_TO_ADDR
48481: LD_EXP 78
48485: PUSH
48486: FOR_TO
48487: IFFALSE 48634
// begin if sci in mc_bases [ i ] then
48489: LD_VAR 0 2
48493: PUSH
48494: LD_EXP 78
48498: PUSH
48499: LD_VAR 0 4
48503: ARRAY
48504: IN
48505: IFFALSE 48632
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48507: LD_ADDR_EXP 107
48511: PUSH
48512: LD_EXP 107
48516: PPUSH
48517: LD_VAR 0 4
48521: PUSH
48522: LD_EXP 107
48526: PUSH
48527: LD_VAR 0 4
48531: ARRAY
48532: PUSH
48533: LD_INT 1
48535: PLUS
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PPUSH
48541: LD_VAR 0 1
48545: PPUSH
48546: CALL 58220 0 3
48550: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
48551: LD_ADDR_VAR 0 5
48555: PUSH
48556: LD_EXP 78
48560: PUSH
48561: LD_VAR 0 4
48565: ARRAY
48566: PPUSH
48567: LD_INT 2
48569: PUSH
48570: LD_INT 30
48572: PUSH
48573: LD_INT 0
48575: PUSH
48576: EMPTY
48577: LIST
48578: LIST
48579: PUSH
48580: LD_INT 30
48582: PUSH
48583: LD_INT 1
48585: PUSH
48586: EMPTY
48587: LIST
48588: LIST
48589: PUSH
48590: EMPTY
48591: LIST
48592: LIST
48593: LIST
48594: PPUSH
48595: CALL_OW 72
48599: PPUSH
48600: LD_VAR 0 1
48604: PPUSH
48605: CALL_OW 74
48609: ST_TO_ADDR
// if tmp then
48610: LD_VAR 0 5
48614: IFFALSE 48630
// ComStandNearbyBuilding ( ape , tmp ) ;
48616: LD_VAR 0 1
48620: PPUSH
48621: LD_VAR 0 5
48625: PPUSH
48626: CALL 54822 0 2
// break ;
48630: GO 48634
// end ; end ;
48632: GO 48486
48634: POP
48635: POP
// end ;
48636: LD_VAR 0 3
48640: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
48641: LD_INT 0
48643: PPUSH
48644: PPUSH
48645: PPUSH
// if not mc_bases or not skirmish then
48646: LD_EXP 78
48650: NOT
48651: PUSH
48652: LD_EXP 76
48656: NOT
48657: OR
48658: IFFALSE 48662
// exit ;
48660: GO 48751
// for i = 1 to mc_bases do
48662: LD_ADDR_VAR 0 4
48666: PUSH
48667: DOUBLE
48668: LD_INT 1
48670: DEC
48671: ST_TO_ADDR
48672: LD_EXP 78
48676: PUSH
48677: FOR_TO
48678: IFFALSE 48749
// begin if building in mc_busy_turret_list [ i ] then
48680: LD_VAR 0 1
48684: PUSH
48685: LD_EXP 88
48689: PUSH
48690: LD_VAR 0 4
48694: ARRAY
48695: IN
48696: IFFALSE 48747
// begin tmp := mc_busy_turret_list [ i ] diff building ;
48698: LD_ADDR_VAR 0 5
48702: PUSH
48703: LD_EXP 88
48707: PUSH
48708: LD_VAR 0 4
48712: ARRAY
48713: PUSH
48714: LD_VAR 0 1
48718: DIFF
48719: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
48720: LD_ADDR_EXP 88
48724: PUSH
48725: LD_EXP 88
48729: PPUSH
48730: LD_VAR 0 4
48734: PPUSH
48735: LD_VAR 0 5
48739: PPUSH
48740: CALL_OW 1
48744: ST_TO_ADDR
// break ;
48745: GO 48749
// end ; end ;
48747: GO 48677
48749: POP
48750: POP
// end ;
48751: LD_VAR 0 3
48755: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
48756: LD_INT 0
48758: PPUSH
48759: PPUSH
48760: PPUSH
// if not mc_bases or not skirmish then
48761: LD_EXP 78
48765: NOT
48766: PUSH
48767: LD_EXP 76
48771: NOT
48772: OR
48773: IFFALSE 48777
// exit ;
48775: GO 48976
// for i = 1 to mc_bases do
48777: LD_ADDR_VAR 0 5
48781: PUSH
48782: DOUBLE
48783: LD_INT 1
48785: DEC
48786: ST_TO_ADDR
48787: LD_EXP 78
48791: PUSH
48792: FOR_TO
48793: IFFALSE 48974
// if building in mc_bases [ i ] then
48795: LD_VAR 0 1
48799: PUSH
48800: LD_EXP 78
48804: PUSH
48805: LD_VAR 0 5
48809: ARRAY
48810: IN
48811: IFFALSE 48972
// begin tmp := mc_bases [ i ] diff building ;
48813: LD_ADDR_VAR 0 6
48817: PUSH
48818: LD_EXP 78
48822: PUSH
48823: LD_VAR 0 5
48827: ARRAY
48828: PUSH
48829: LD_VAR 0 1
48833: DIFF
48834: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
48835: LD_ADDR_EXP 78
48839: PUSH
48840: LD_EXP 78
48844: PPUSH
48845: LD_VAR 0 5
48849: PPUSH
48850: LD_VAR 0 6
48854: PPUSH
48855: CALL_OW 1
48859: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
48860: LD_VAR 0 1
48864: PUSH
48865: LD_EXP 86
48869: PUSH
48870: LD_VAR 0 5
48874: ARRAY
48875: IN
48876: IFFALSE 48915
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
48878: LD_ADDR_EXP 86
48882: PUSH
48883: LD_EXP 86
48887: PPUSH
48888: LD_VAR 0 5
48892: PPUSH
48893: LD_EXP 86
48897: PUSH
48898: LD_VAR 0 5
48902: ARRAY
48903: PUSH
48904: LD_VAR 0 1
48908: DIFF
48909: PPUSH
48910: CALL_OW 1
48914: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
48915: LD_VAR 0 1
48919: PUSH
48920: LD_EXP 87
48924: PUSH
48925: LD_VAR 0 5
48929: ARRAY
48930: IN
48931: IFFALSE 48970
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
48933: LD_ADDR_EXP 87
48937: PUSH
48938: LD_EXP 87
48942: PPUSH
48943: LD_VAR 0 5
48947: PPUSH
48948: LD_EXP 87
48952: PUSH
48953: LD_VAR 0 5
48957: ARRAY
48958: PUSH
48959: LD_VAR 0 1
48963: DIFF
48964: PPUSH
48965: CALL_OW 1
48969: ST_TO_ADDR
// break ;
48970: GO 48974
// end ;
48972: GO 48792
48974: POP
48975: POP
// end ;
48976: LD_VAR 0 4
48980: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
48981: LD_INT 0
48983: PPUSH
48984: PPUSH
48985: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
48986: LD_EXP 78
48990: NOT
48991: PUSH
48992: LD_EXP 76
48996: NOT
48997: OR
48998: PUSH
48999: LD_VAR 0 3
49003: PUSH
49004: LD_EXP 104
49008: IN
49009: NOT
49010: OR
49011: IFFALSE 49015
// exit ;
49013: GO 49138
// for i = 1 to mc_vehicles do
49015: LD_ADDR_VAR 0 6
49019: PUSH
49020: DOUBLE
49021: LD_INT 1
49023: DEC
49024: ST_TO_ADDR
49025: LD_EXP 97
49029: PUSH
49030: FOR_TO
49031: IFFALSE 49136
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
49033: LD_VAR 0 2
49037: PUSH
49038: LD_EXP 97
49042: PUSH
49043: LD_VAR 0 6
49047: ARRAY
49048: IN
49049: PUSH
49050: LD_VAR 0 1
49054: PUSH
49055: LD_EXP 97
49059: PUSH
49060: LD_VAR 0 6
49064: ARRAY
49065: IN
49066: OR
49067: IFFALSE 49134
// begin tmp := mc_vehicles [ i ] diff old ;
49069: LD_ADDR_VAR 0 7
49073: PUSH
49074: LD_EXP 97
49078: PUSH
49079: LD_VAR 0 6
49083: ARRAY
49084: PUSH
49085: LD_VAR 0 2
49089: DIFF
49090: ST_TO_ADDR
// tmp := tmp diff new ;
49091: LD_ADDR_VAR 0 7
49095: PUSH
49096: LD_VAR 0 7
49100: PUSH
49101: LD_VAR 0 1
49105: DIFF
49106: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
49107: LD_ADDR_EXP 97
49111: PUSH
49112: LD_EXP 97
49116: PPUSH
49117: LD_VAR 0 6
49121: PPUSH
49122: LD_VAR 0 7
49126: PPUSH
49127: CALL_OW 1
49131: ST_TO_ADDR
// break ;
49132: GO 49136
// end ;
49134: GO 49030
49136: POP
49137: POP
// end ;
49138: LD_VAR 0 5
49142: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
49143: LD_INT 0
49145: PPUSH
49146: PPUSH
49147: PPUSH
49148: PPUSH
// if not mc_bases or not skirmish then
49149: LD_EXP 78
49153: NOT
49154: PUSH
49155: LD_EXP 76
49159: NOT
49160: OR
49161: IFFALSE 49165
// exit ;
49163: GO 49585
// repeat wait ( 0 0$1 ) ;
49165: LD_INT 35
49167: PPUSH
49168: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
49172: LD_EXP 122
49176: NOT
49177: IFFALSE 49165
// mc_block_vehicle_constructed_thread := true ;
49179: LD_ADDR_EXP 122
49183: PUSH
49184: LD_INT 1
49186: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
49187: LD_ADDR_VAR 0 5
49191: PUSH
49192: LD_VAR 0 1
49196: PPUSH
49197: CALL_OW 255
49201: ST_TO_ADDR
// for i = 1 to mc_bases do
49202: LD_ADDR_VAR 0 4
49206: PUSH
49207: DOUBLE
49208: LD_INT 1
49210: DEC
49211: ST_TO_ADDR
49212: LD_EXP 78
49216: PUSH
49217: FOR_TO
49218: IFFALSE 49575
// begin if factory in mc_bases [ i ] then
49220: LD_VAR 0 2
49224: PUSH
49225: LD_EXP 78
49229: PUSH
49230: LD_VAR 0 4
49234: ARRAY
49235: IN
49236: IFFALSE 49573
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
49238: LD_EXP 100
49242: PUSH
49243: LD_VAR 0 4
49247: ARRAY
49248: PUSH
49249: LD_EXP 89
49253: PUSH
49254: LD_VAR 0 4
49258: ARRAY
49259: LESS
49260: PUSH
49261: LD_VAR 0 1
49265: PPUSH
49266: CALL_OW 264
49270: PUSH
49271: LD_INT 31
49273: PUSH
49274: LD_INT 32
49276: PUSH
49277: LD_INT 51
49279: PUSH
49280: LD_INT 89
49282: PUSH
49283: LD_INT 12
49285: PUSH
49286: LD_INT 30
49288: PUSH
49289: LD_INT 98
49291: PUSH
49292: LD_INT 11
49294: PUSH
49295: LD_INT 53
49297: PUSH
49298: LD_INT 14
49300: PUSH
49301: LD_INT 91
49303: PUSH
49304: LD_INT 29
49306: PUSH
49307: LD_INT 99
49309: PUSH
49310: LD_INT 13
49312: PUSH
49313: LD_INT 52
49315: PUSH
49316: LD_INT 88
49318: PUSH
49319: LD_INT 48
49321: PUSH
49322: LD_INT 8
49324: PUSH
49325: EMPTY
49326: LIST
49327: LIST
49328: LIST
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: IN
49345: NOT
49346: AND
49347: IFFALSE 49395
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
49349: LD_ADDR_EXP 100
49353: PUSH
49354: LD_EXP 100
49358: PPUSH
49359: LD_VAR 0 4
49363: PUSH
49364: LD_EXP 100
49368: PUSH
49369: LD_VAR 0 4
49373: ARRAY
49374: PUSH
49375: LD_INT 1
49377: PLUS
49378: PUSH
49379: EMPTY
49380: LIST
49381: LIST
49382: PPUSH
49383: LD_VAR 0 1
49387: PPUSH
49388: CALL 58220 0 3
49392: ST_TO_ADDR
49393: GO 49439
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
49395: LD_ADDR_EXP 97
49399: PUSH
49400: LD_EXP 97
49404: PPUSH
49405: LD_VAR 0 4
49409: PUSH
49410: LD_EXP 97
49414: PUSH
49415: LD_VAR 0 4
49419: ARRAY
49420: PUSH
49421: LD_INT 1
49423: PLUS
49424: PUSH
49425: EMPTY
49426: LIST
49427: LIST
49428: PPUSH
49429: LD_VAR 0 1
49433: PPUSH
49434: CALL 58220 0 3
49438: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
49439: LD_ADDR_EXP 122
49443: PUSH
49444: LD_INT 0
49446: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49447: LD_VAR 0 1
49451: PPUSH
49452: CALL_OW 263
49456: PUSH
49457: LD_INT 2
49459: EQUAL
49460: IFFALSE 49489
// begin repeat wait ( 0 0$3 ) ;
49462: LD_INT 105
49464: PPUSH
49465: CALL_OW 67
// Connect ( vehicle ) ;
49469: LD_VAR 0 1
49473: PPUSH
49474: CALL 61566 0 1
// until IsControledBy ( vehicle ) ;
49478: LD_VAR 0 1
49482: PPUSH
49483: CALL_OW 312
49487: IFFALSE 49462
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49489: LD_VAR 0 1
49493: PPUSH
49494: LD_EXP 102
49498: PUSH
49499: LD_VAR 0 4
49503: ARRAY
49504: PPUSH
49505: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49509: LD_VAR 0 1
49513: PPUSH
49514: CALL_OW 263
49518: PUSH
49519: LD_INT 1
49521: NONEQUAL
49522: IFFALSE 49526
// break ;
49524: GO 49575
// repeat wait ( 0 0$1 ) ;
49526: LD_INT 35
49528: PPUSH
49529: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
49533: LD_VAR 0 1
49537: PPUSH
49538: LD_EXP 102
49542: PUSH
49543: LD_VAR 0 4
49547: ARRAY
49548: PPUSH
49549: CALL_OW 308
49553: IFFALSE 49526
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
49555: LD_VAR 0 1
49559: PPUSH
49560: CALL_OW 311
49564: PPUSH
49565: CALL_OW 121
// exit ;
49569: POP
49570: POP
49571: GO 49585
// end ; end ;
49573: GO 49217
49575: POP
49576: POP
// mc_block_vehicle_constructed_thread := false ;
49577: LD_ADDR_EXP 122
49581: PUSH
49582: LD_INT 0
49584: ST_TO_ADDR
// end ;
49585: LD_VAR 0 3
49589: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
49590: LD_INT 0
49592: PPUSH
49593: PPUSH
49594: PPUSH
49595: PPUSH
// if not mc_bases or not skirmish then
49596: LD_EXP 78
49600: NOT
49601: PUSH
49602: LD_EXP 76
49606: NOT
49607: OR
49608: IFFALSE 49612
// exit ;
49610: GO 49965
// repeat wait ( 0 0$1 ) ;
49612: LD_INT 35
49614: PPUSH
49615: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
49619: LD_VAR 0 2
49623: PPUSH
49624: LD_VAR 0 3
49628: PPUSH
49629: CALL_OW 284
49633: IFFALSE 49612
// if GetResourceTypeXY ( x , y ) = mat_artefact then
49635: LD_VAR 0 2
49639: PPUSH
49640: LD_VAR 0 3
49644: PPUSH
49645: CALL_OW 283
49649: PUSH
49650: LD_INT 4
49652: EQUAL
49653: IFFALSE 49657
// exit ;
49655: GO 49965
// for i = 1 to mc_bases do
49657: LD_ADDR_VAR 0 7
49661: PUSH
49662: DOUBLE
49663: LD_INT 1
49665: DEC
49666: ST_TO_ADDR
49667: LD_EXP 78
49671: PUSH
49672: FOR_TO
49673: IFFALSE 49963
// begin if mc_crates_area [ i ] then
49675: LD_EXP 96
49679: PUSH
49680: LD_VAR 0 7
49684: ARRAY
49685: IFFALSE 49796
// for j in mc_crates_area [ i ] do
49687: LD_ADDR_VAR 0 8
49691: PUSH
49692: LD_EXP 96
49696: PUSH
49697: LD_VAR 0 7
49701: ARRAY
49702: PUSH
49703: FOR_IN
49704: IFFALSE 49794
// if InArea ( x , y , j ) then
49706: LD_VAR 0 2
49710: PPUSH
49711: LD_VAR 0 3
49715: PPUSH
49716: LD_VAR 0 8
49720: PPUSH
49721: CALL_OW 309
49725: IFFALSE 49792
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49727: LD_ADDR_EXP 94
49731: PUSH
49732: LD_EXP 94
49736: PPUSH
49737: LD_VAR 0 7
49741: PUSH
49742: LD_EXP 94
49746: PUSH
49747: LD_VAR 0 7
49751: ARRAY
49752: PUSH
49753: LD_INT 1
49755: PLUS
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PPUSH
49761: LD_VAR 0 4
49765: PUSH
49766: LD_VAR 0 2
49770: PUSH
49771: LD_VAR 0 3
49775: PUSH
49776: EMPTY
49777: LIST
49778: LIST
49779: LIST
49780: PPUSH
49781: CALL 58220 0 3
49785: ST_TO_ADDR
// exit ;
49786: POP
49787: POP
49788: POP
49789: POP
49790: GO 49965
// end ;
49792: GO 49703
49794: POP
49795: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49796: LD_ADDR_VAR 0 9
49800: PUSH
49801: LD_EXP 78
49805: PUSH
49806: LD_VAR 0 7
49810: ARRAY
49811: PPUSH
49812: LD_INT 2
49814: PUSH
49815: LD_INT 30
49817: PUSH
49818: LD_INT 0
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: PUSH
49825: LD_INT 30
49827: PUSH
49828: LD_INT 1
49830: PUSH
49831: EMPTY
49832: LIST
49833: LIST
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: LIST
49839: PPUSH
49840: CALL_OW 72
49844: ST_TO_ADDR
// if not depot then
49845: LD_VAR 0 9
49849: NOT
49850: IFFALSE 49854
// continue ;
49852: GO 49672
// for j in depot do
49854: LD_ADDR_VAR 0 8
49858: PUSH
49859: LD_VAR 0 9
49863: PUSH
49864: FOR_IN
49865: IFFALSE 49959
// if GetDistUnitXY ( j , x , y ) < 30 then
49867: LD_VAR 0 8
49871: PPUSH
49872: LD_VAR 0 2
49876: PPUSH
49877: LD_VAR 0 3
49881: PPUSH
49882: CALL_OW 297
49886: PUSH
49887: LD_INT 30
49889: LESS
49890: IFFALSE 49957
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49892: LD_ADDR_EXP 94
49896: PUSH
49897: LD_EXP 94
49901: PPUSH
49902: LD_VAR 0 7
49906: PUSH
49907: LD_EXP 94
49911: PUSH
49912: LD_VAR 0 7
49916: ARRAY
49917: PUSH
49918: LD_INT 1
49920: PLUS
49921: PUSH
49922: EMPTY
49923: LIST
49924: LIST
49925: PPUSH
49926: LD_VAR 0 4
49930: PUSH
49931: LD_VAR 0 2
49935: PUSH
49936: LD_VAR 0 3
49940: PUSH
49941: EMPTY
49942: LIST
49943: LIST
49944: LIST
49945: PPUSH
49946: CALL 58220 0 3
49950: ST_TO_ADDR
// exit ;
49951: POP
49952: POP
49953: POP
49954: POP
49955: GO 49965
// end ;
49957: GO 49864
49959: POP
49960: POP
// end ;
49961: GO 49672
49963: POP
49964: POP
// end ;
49965: LD_VAR 0 6
49969: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
49970: LD_INT 0
49972: PPUSH
49973: PPUSH
49974: PPUSH
49975: PPUSH
// if not mc_bases or not skirmish then
49976: LD_EXP 78
49980: NOT
49981: PUSH
49982: LD_EXP 76
49986: NOT
49987: OR
49988: IFFALSE 49992
// exit ;
49990: GO 50269
// side := GetSide ( lab ) ;
49992: LD_ADDR_VAR 0 4
49996: PUSH
49997: LD_VAR 0 2
50001: PPUSH
50002: CALL_OW 255
50006: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
50007: LD_VAR 0 4
50011: PUSH
50012: LD_EXP 104
50016: IN
50017: NOT
50018: PUSH
50019: LD_EXP 105
50023: NOT
50024: OR
50025: PUSH
50026: LD_EXP 78
50030: NOT
50031: OR
50032: IFFALSE 50036
// exit ;
50034: GO 50269
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
50036: LD_ADDR_EXP 105
50040: PUSH
50041: LD_EXP 105
50045: PPUSH
50046: LD_VAR 0 4
50050: PPUSH
50051: LD_EXP 105
50055: PUSH
50056: LD_VAR 0 4
50060: ARRAY
50061: PUSH
50062: LD_VAR 0 1
50066: DIFF
50067: PPUSH
50068: CALL_OW 1
50072: ST_TO_ADDR
// for i = 1 to mc_bases do
50073: LD_ADDR_VAR 0 5
50077: PUSH
50078: DOUBLE
50079: LD_INT 1
50081: DEC
50082: ST_TO_ADDR
50083: LD_EXP 78
50087: PUSH
50088: FOR_TO
50089: IFFALSE 50267
// begin if lab in mc_bases [ i ] then
50091: LD_VAR 0 2
50095: PUSH
50096: LD_EXP 78
50100: PUSH
50101: LD_VAR 0 5
50105: ARRAY
50106: IN
50107: IFFALSE 50265
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
50109: LD_VAR 0 1
50113: PUSH
50114: LD_INT 11
50116: PUSH
50117: LD_INT 4
50119: PUSH
50120: LD_INT 3
50122: PUSH
50123: LD_INT 2
50125: PUSH
50126: EMPTY
50127: LIST
50128: LIST
50129: LIST
50130: LIST
50131: IN
50132: PUSH
50133: LD_EXP 108
50137: PUSH
50138: LD_VAR 0 5
50142: ARRAY
50143: AND
50144: IFFALSE 50265
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
50146: LD_ADDR_VAR 0 6
50150: PUSH
50151: LD_EXP 108
50155: PUSH
50156: LD_VAR 0 5
50160: ARRAY
50161: PUSH
50162: LD_INT 1
50164: ARRAY
50165: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50166: LD_ADDR_EXP 108
50170: PUSH
50171: LD_EXP 108
50175: PPUSH
50176: LD_VAR 0 5
50180: PPUSH
50181: EMPTY
50182: PPUSH
50183: CALL_OW 1
50187: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
50188: LD_VAR 0 6
50192: PPUSH
50193: LD_INT 0
50195: PPUSH
50196: CALL_OW 109
// ComExitBuilding ( tmp ) ;
50200: LD_VAR 0 6
50204: PPUSH
50205: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
50209: LD_ADDR_EXP 107
50213: PUSH
50214: LD_EXP 107
50218: PPUSH
50219: LD_VAR 0 5
50223: PPUSH
50224: LD_EXP 107
50228: PUSH
50229: LD_VAR 0 5
50233: ARRAY
50234: PPUSH
50235: LD_INT 1
50237: PPUSH
50238: LD_VAR 0 6
50242: PPUSH
50243: CALL_OW 2
50247: PPUSH
50248: CALL_OW 1
50252: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
50253: LD_VAR 0 5
50257: PPUSH
50258: LD_INT 112
50260: PPUSH
50261: CALL 26719 0 2
// end ; end ; end ;
50265: GO 50088
50267: POP
50268: POP
// end ;
50269: LD_VAR 0 3
50273: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
50274: LD_INT 0
50276: PPUSH
50277: PPUSH
50278: PPUSH
50279: PPUSH
50280: PPUSH
50281: PPUSH
50282: PPUSH
50283: PPUSH
// if not mc_bases or not skirmish then
50284: LD_EXP 78
50288: NOT
50289: PUSH
50290: LD_EXP 76
50294: NOT
50295: OR
50296: IFFALSE 50300
// exit ;
50298: GO 51669
// for i = 1 to mc_bases do
50300: LD_ADDR_VAR 0 3
50304: PUSH
50305: DOUBLE
50306: LD_INT 1
50308: DEC
50309: ST_TO_ADDR
50310: LD_EXP 78
50314: PUSH
50315: FOR_TO
50316: IFFALSE 51667
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
50318: LD_VAR 0 1
50322: PUSH
50323: LD_EXP 78
50327: PUSH
50328: LD_VAR 0 3
50332: ARRAY
50333: IN
50334: PUSH
50335: LD_VAR 0 1
50339: PUSH
50340: LD_EXP 85
50344: PUSH
50345: LD_VAR 0 3
50349: ARRAY
50350: IN
50351: OR
50352: PUSH
50353: LD_VAR 0 1
50357: PUSH
50358: LD_EXP 100
50362: PUSH
50363: LD_VAR 0 3
50367: ARRAY
50368: IN
50369: OR
50370: PUSH
50371: LD_VAR 0 1
50375: PUSH
50376: LD_EXP 97
50380: PUSH
50381: LD_VAR 0 3
50385: ARRAY
50386: IN
50387: OR
50388: PUSH
50389: LD_VAR 0 1
50393: PUSH
50394: LD_EXP 107
50398: PUSH
50399: LD_VAR 0 3
50403: ARRAY
50404: IN
50405: OR
50406: PUSH
50407: LD_VAR 0 1
50411: PUSH
50412: LD_EXP 108
50416: PUSH
50417: LD_VAR 0 3
50421: ARRAY
50422: IN
50423: OR
50424: IFFALSE 51665
// begin if un in mc_ape [ i ] then
50426: LD_VAR 0 1
50430: PUSH
50431: LD_EXP 107
50435: PUSH
50436: LD_VAR 0 3
50440: ARRAY
50441: IN
50442: IFFALSE 50481
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
50444: LD_ADDR_EXP 107
50448: PUSH
50449: LD_EXP 107
50453: PPUSH
50454: LD_VAR 0 3
50458: PPUSH
50459: LD_EXP 107
50463: PUSH
50464: LD_VAR 0 3
50468: ARRAY
50469: PUSH
50470: LD_VAR 0 1
50474: DIFF
50475: PPUSH
50476: CALL_OW 1
50480: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50481: LD_VAR 0 1
50485: PUSH
50486: LD_EXP 108
50490: PUSH
50491: LD_VAR 0 3
50495: ARRAY
50496: IN
50497: IFFALSE 50521
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50499: LD_ADDR_EXP 108
50503: PUSH
50504: LD_EXP 108
50508: PPUSH
50509: LD_VAR 0 3
50513: PPUSH
50514: EMPTY
50515: PPUSH
50516: CALL_OW 1
50520: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50521: LD_VAR 0 1
50525: PPUSH
50526: CALL_OW 247
50530: PUSH
50531: LD_INT 2
50533: EQUAL
50534: PUSH
50535: LD_VAR 0 1
50539: PPUSH
50540: CALL_OW 110
50544: PUSH
50545: LD_INT 20
50547: EQUAL
50548: PUSH
50549: LD_VAR 0 1
50553: PUSH
50554: LD_EXP 100
50558: PUSH
50559: LD_VAR 0 3
50563: ARRAY
50564: IN
50565: OR
50566: PUSH
50567: LD_VAR 0 1
50571: PPUSH
50572: CALL_OW 264
50576: PUSH
50577: LD_INT 12
50579: PUSH
50580: LD_INT 51
50582: PUSH
50583: LD_INT 89
50585: PUSH
50586: LD_INT 32
50588: PUSH
50589: LD_INT 13
50591: PUSH
50592: LD_INT 52
50594: PUSH
50595: LD_INT 31
50597: PUSH
50598: EMPTY
50599: LIST
50600: LIST
50601: LIST
50602: LIST
50603: LIST
50604: LIST
50605: LIST
50606: IN
50607: OR
50608: AND
50609: IFFALSE 50917
// begin if un in mc_defender [ i ] then
50611: LD_VAR 0 1
50615: PUSH
50616: LD_EXP 100
50620: PUSH
50621: LD_VAR 0 3
50625: ARRAY
50626: IN
50627: IFFALSE 50666
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50629: LD_ADDR_EXP 100
50633: PUSH
50634: LD_EXP 100
50638: PPUSH
50639: LD_VAR 0 3
50643: PPUSH
50644: LD_EXP 100
50648: PUSH
50649: LD_VAR 0 3
50653: ARRAY
50654: PUSH
50655: LD_VAR 0 1
50659: DIFF
50660: PPUSH
50661: CALL_OW 1
50665: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
50666: LD_ADDR_VAR 0 8
50670: PUSH
50671: LD_VAR 0 3
50675: PPUSH
50676: LD_INT 3
50678: PPUSH
50679: CALL 47287 0 2
50683: ST_TO_ADDR
// if fac then
50684: LD_VAR 0 8
50688: IFFALSE 50917
// begin for j in fac do
50690: LD_ADDR_VAR 0 4
50694: PUSH
50695: LD_VAR 0 8
50699: PUSH
50700: FOR_IN
50701: IFFALSE 50915
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
50703: LD_ADDR_VAR 0 9
50707: PUSH
50708: LD_VAR 0 8
50712: PPUSH
50713: LD_VAR 0 1
50717: PPUSH
50718: CALL_OW 265
50722: PPUSH
50723: LD_VAR 0 1
50727: PPUSH
50728: CALL_OW 262
50732: PPUSH
50733: LD_VAR 0 1
50737: PPUSH
50738: CALL_OW 263
50742: PPUSH
50743: LD_VAR 0 1
50747: PPUSH
50748: CALL_OW 264
50752: PPUSH
50753: CALL 55718 0 5
50757: ST_TO_ADDR
// if components then
50758: LD_VAR 0 9
50762: IFFALSE 50913
// begin if GetWeapon ( un ) = ar_control_tower then
50764: LD_VAR 0 1
50768: PPUSH
50769: CALL_OW 264
50773: PUSH
50774: LD_INT 31
50776: EQUAL
50777: IFFALSE 50894
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
50779: LD_VAR 0 1
50783: PPUSH
50784: CALL_OW 311
50788: PPUSH
50789: LD_INT 0
50791: PPUSH
50792: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
50796: LD_ADDR_EXP 118
50800: PUSH
50801: LD_EXP 118
50805: PPUSH
50806: LD_VAR 0 3
50810: PPUSH
50811: LD_EXP 118
50815: PUSH
50816: LD_VAR 0 3
50820: ARRAY
50821: PUSH
50822: LD_VAR 0 1
50826: PPUSH
50827: CALL_OW 311
50831: DIFF
50832: PPUSH
50833: CALL_OW 1
50837: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
50838: LD_ADDR_VAR 0 7
50842: PUSH
50843: LD_EXP 99
50847: PUSH
50848: LD_VAR 0 3
50852: ARRAY
50853: PPUSH
50854: LD_INT 1
50856: PPUSH
50857: LD_VAR 0 9
50861: PPUSH
50862: CALL_OW 2
50866: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50867: LD_ADDR_EXP 99
50871: PUSH
50872: LD_EXP 99
50876: PPUSH
50877: LD_VAR 0 3
50881: PPUSH
50882: LD_VAR 0 7
50886: PPUSH
50887: CALL_OW 1
50891: ST_TO_ADDR
// end else
50892: GO 50911
// MC_InsertProduceList ( i , [ components ] ) ;
50894: LD_VAR 0 3
50898: PPUSH
50899: LD_VAR 0 9
50903: PUSH
50904: EMPTY
50905: LIST
50906: PPUSH
50907: CALL 46832 0 2
// break ;
50911: GO 50915
// end ; end ;
50913: GO 50700
50915: POP
50916: POP
// end ; end ; if GetType ( un ) = unit_building then
50917: LD_VAR 0 1
50921: PPUSH
50922: CALL_OW 247
50926: PUSH
50927: LD_INT 3
50929: EQUAL
50930: IFFALSE 51333
// begin btype := GetBType ( un ) ;
50932: LD_ADDR_VAR 0 5
50936: PUSH
50937: LD_VAR 0 1
50941: PPUSH
50942: CALL_OW 266
50946: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
50947: LD_VAR 0 5
50951: PUSH
50952: LD_INT 29
50954: PUSH
50955: LD_INT 30
50957: PUSH
50958: EMPTY
50959: LIST
50960: LIST
50961: IN
50962: IFFALSE 51035
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
50964: LD_VAR 0 1
50968: PPUSH
50969: CALL_OW 250
50973: PPUSH
50974: LD_VAR 0 1
50978: PPUSH
50979: CALL_OW 251
50983: PPUSH
50984: LD_VAR 0 1
50988: PPUSH
50989: CALL_OW 255
50993: PPUSH
50994: CALL_OW 440
50998: NOT
50999: IFFALSE 51035
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
51001: LD_VAR 0 1
51005: PPUSH
51006: CALL_OW 250
51010: PPUSH
51011: LD_VAR 0 1
51015: PPUSH
51016: CALL_OW 251
51020: PPUSH
51021: LD_VAR 0 1
51025: PPUSH
51026: CALL_OW 255
51030: PPUSH
51031: CALL_OW 441
// end ; if btype = b_warehouse then
51035: LD_VAR 0 5
51039: PUSH
51040: LD_INT 1
51042: EQUAL
51043: IFFALSE 51061
// begin btype := b_depot ;
51045: LD_ADDR_VAR 0 5
51049: PUSH
51050: LD_INT 0
51052: ST_TO_ADDR
// pos := 1 ;
51053: LD_ADDR_VAR 0 6
51057: PUSH
51058: LD_INT 1
51060: ST_TO_ADDR
// end ; if btype = b_factory then
51061: LD_VAR 0 5
51065: PUSH
51066: LD_INT 3
51068: EQUAL
51069: IFFALSE 51087
// begin btype := b_workshop ;
51071: LD_ADDR_VAR 0 5
51075: PUSH
51076: LD_INT 2
51078: ST_TO_ADDR
// pos := 1 ;
51079: LD_ADDR_VAR 0 6
51083: PUSH
51084: LD_INT 1
51086: ST_TO_ADDR
// end ; if btype = b_barracks then
51087: LD_VAR 0 5
51091: PUSH
51092: LD_INT 5
51094: EQUAL
51095: IFFALSE 51105
// btype := b_armoury ;
51097: LD_ADDR_VAR 0 5
51101: PUSH
51102: LD_INT 4
51104: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
51105: LD_VAR 0 5
51109: PUSH
51110: LD_INT 7
51112: PUSH
51113: LD_INT 8
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: IN
51120: IFFALSE 51130
// btype := b_lab ;
51122: LD_ADDR_VAR 0 5
51126: PUSH
51127: LD_INT 6
51129: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
51130: LD_ADDR_EXP 83
51134: PUSH
51135: LD_EXP 83
51139: PPUSH
51140: LD_VAR 0 3
51144: PUSH
51145: LD_EXP 83
51149: PUSH
51150: LD_VAR 0 3
51154: ARRAY
51155: PUSH
51156: LD_INT 1
51158: PLUS
51159: PUSH
51160: EMPTY
51161: LIST
51162: LIST
51163: PPUSH
51164: LD_VAR 0 5
51168: PUSH
51169: LD_VAR 0 1
51173: PPUSH
51174: CALL_OW 250
51178: PUSH
51179: LD_VAR 0 1
51183: PPUSH
51184: CALL_OW 251
51188: PUSH
51189: LD_VAR 0 1
51193: PPUSH
51194: CALL_OW 254
51198: PUSH
51199: EMPTY
51200: LIST
51201: LIST
51202: LIST
51203: LIST
51204: PPUSH
51205: CALL 58220 0 3
51209: ST_TO_ADDR
// if pos = 1 then
51210: LD_VAR 0 6
51214: PUSH
51215: LD_INT 1
51217: EQUAL
51218: IFFALSE 51333
// begin tmp := mc_build_list [ i ] ;
51220: LD_ADDR_VAR 0 7
51224: PUSH
51225: LD_EXP 83
51229: PUSH
51230: LD_VAR 0 3
51234: ARRAY
51235: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51236: LD_VAR 0 7
51240: PPUSH
51241: LD_INT 2
51243: PUSH
51244: LD_INT 30
51246: PUSH
51247: LD_INT 0
51249: PUSH
51250: EMPTY
51251: LIST
51252: LIST
51253: PUSH
51254: LD_INT 30
51256: PUSH
51257: LD_INT 1
51259: PUSH
51260: EMPTY
51261: LIST
51262: LIST
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: LIST
51268: PPUSH
51269: CALL_OW 72
51273: IFFALSE 51283
// pos := 2 ;
51275: LD_ADDR_VAR 0 6
51279: PUSH
51280: LD_INT 2
51282: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
51283: LD_ADDR_VAR 0 7
51287: PUSH
51288: LD_VAR 0 7
51292: PPUSH
51293: LD_VAR 0 6
51297: PPUSH
51298: LD_VAR 0 7
51302: PPUSH
51303: CALL 58546 0 3
51307: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
51308: LD_ADDR_EXP 83
51312: PUSH
51313: LD_EXP 83
51317: PPUSH
51318: LD_VAR 0 3
51322: PPUSH
51323: LD_VAR 0 7
51327: PPUSH
51328: CALL_OW 1
51332: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
51333: LD_VAR 0 1
51337: PUSH
51338: LD_EXP 78
51342: PUSH
51343: LD_VAR 0 3
51347: ARRAY
51348: IN
51349: IFFALSE 51388
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
51351: LD_ADDR_EXP 78
51355: PUSH
51356: LD_EXP 78
51360: PPUSH
51361: LD_VAR 0 3
51365: PPUSH
51366: LD_EXP 78
51370: PUSH
51371: LD_VAR 0 3
51375: ARRAY
51376: PUSH
51377: LD_VAR 0 1
51381: DIFF
51382: PPUSH
51383: CALL_OW 1
51387: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
51388: LD_VAR 0 1
51392: PUSH
51393: LD_EXP 85
51397: PUSH
51398: LD_VAR 0 3
51402: ARRAY
51403: IN
51404: IFFALSE 51443
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
51406: LD_ADDR_EXP 85
51410: PUSH
51411: LD_EXP 85
51415: PPUSH
51416: LD_VAR 0 3
51420: PPUSH
51421: LD_EXP 85
51425: PUSH
51426: LD_VAR 0 3
51430: ARRAY
51431: PUSH
51432: LD_VAR 0 1
51436: DIFF
51437: PPUSH
51438: CALL_OW 1
51442: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
51443: LD_VAR 0 1
51447: PUSH
51448: LD_EXP 97
51452: PUSH
51453: LD_VAR 0 3
51457: ARRAY
51458: IN
51459: IFFALSE 51498
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51461: LD_ADDR_EXP 97
51465: PUSH
51466: LD_EXP 97
51470: PPUSH
51471: LD_VAR 0 3
51475: PPUSH
51476: LD_EXP 97
51480: PUSH
51481: LD_VAR 0 3
51485: ARRAY
51486: PUSH
51487: LD_VAR 0 1
51491: DIFF
51492: PPUSH
51493: CALL_OW 1
51497: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51498: LD_VAR 0 1
51502: PUSH
51503: LD_EXP 100
51507: PUSH
51508: LD_VAR 0 3
51512: ARRAY
51513: IN
51514: IFFALSE 51553
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51516: LD_ADDR_EXP 100
51520: PUSH
51521: LD_EXP 100
51525: PPUSH
51526: LD_VAR 0 3
51530: PPUSH
51531: LD_EXP 100
51535: PUSH
51536: LD_VAR 0 3
51540: ARRAY
51541: PUSH
51542: LD_VAR 0 1
51546: DIFF
51547: PPUSH
51548: CALL_OW 1
51552: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
51553: LD_VAR 0 1
51557: PUSH
51558: LD_EXP 87
51562: PUSH
51563: LD_VAR 0 3
51567: ARRAY
51568: IN
51569: IFFALSE 51608
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
51571: LD_ADDR_EXP 87
51575: PUSH
51576: LD_EXP 87
51580: PPUSH
51581: LD_VAR 0 3
51585: PPUSH
51586: LD_EXP 87
51590: PUSH
51591: LD_VAR 0 3
51595: ARRAY
51596: PUSH
51597: LD_VAR 0 1
51601: DIFF
51602: PPUSH
51603: CALL_OW 1
51607: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
51608: LD_VAR 0 1
51612: PUSH
51613: LD_EXP 86
51617: PUSH
51618: LD_VAR 0 3
51622: ARRAY
51623: IN
51624: IFFALSE 51663
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
51626: LD_ADDR_EXP 86
51630: PUSH
51631: LD_EXP 86
51635: PPUSH
51636: LD_VAR 0 3
51640: PPUSH
51641: LD_EXP 86
51645: PUSH
51646: LD_VAR 0 3
51650: ARRAY
51651: PUSH
51652: LD_VAR 0 1
51656: DIFF
51657: PPUSH
51658: CALL_OW 1
51662: ST_TO_ADDR
// end ; break ;
51663: GO 51667
// end ;
51665: GO 50315
51667: POP
51668: POP
// end ;
51669: LD_VAR 0 2
51673: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
51674: LD_INT 0
51676: PPUSH
51677: PPUSH
51678: PPUSH
// if not mc_bases or not skirmish then
51679: LD_EXP 78
51683: NOT
51684: PUSH
51685: LD_EXP 76
51689: NOT
51690: OR
51691: IFFALSE 51695
// exit ;
51693: GO 51910
// for i = 1 to mc_bases do
51695: LD_ADDR_VAR 0 3
51699: PUSH
51700: DOUBLE
51701: LD_INT 1
51703: DEC
51704: ST_TO_ADDR
51705: LD_EXP 78
51709: PUSH
51710: FOR_TO
51711: IFFALSE 51908
// begin if building in mc_construct_list [ i ] then
51713: LD_VAR 0 1
51717: PUSH
51718: LD_EXP 85
51722: PUSH
51723: LD_VAR 0 3
51727: ARRAY
51728: IN
51729: IFFALSE 51906
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51731: LD_ADDR_EXP 85
51735: PUSH
51736: LD_EXP 85
51740: PPUSH
51741: LD_VAR 0 3
51745: PPUSH
51746: LD_EXP 85
51750: PUSH
51751: LD_VAR 0 3
51755: ARRAY
51756: PUSH
51757: LD_VAR 0 1
51761: DIFF
51762: PPUSH
51763: CALL_OW 1
51767: ST_TO_ADDR
// if building in mc_lab [ i ] then
51768: LD_VAR 0 1
51772: PUSH
51773: LD_EXP 111
51777: PUSH
51778: LD_VAR 0 3
51782: ARRAY
51783: IN
51784: IFFALSE 51839
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
51786: LD_ADDR_EXP 112
51790: PUSH
51791: LD_EXP 112
51795: PPUSH
51796: LD_VAR 0 3
51800: PPUSH
51801: LD_EXP 112
51805: PUSH
51806: LD_VAR 0 3
51810: ARRAY
51811: PPUSH
51812: LD_INT 1
51814: PPUSH
51815: LD_EXP 112
51819: PUSH
51820: LD_VAR 0 3
51824: ARRAY
51825: PPUSH
51826: LD_INT 0
51828: PPUSH
51829: CALL 57638 0 4
51833: PPUSH
51834: CALL_OW 1
51838: ST_TO_ADDR
// if not building in mc_bases [ i ] then
51839: LD_VAR 0 1
51843: PUSH
51844: LD_EXP 78
51848: PUSH
51849: LD_VAR 0 3
51853: ARRAY
51854: IN
51855: NOT
51856: IFFALSE 51902
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51858: LD_ADDR_EXP 78
51862: PUSH
51863: LD_EXP 78
51867: PPUSH
51868: LD_VAR 0 3
51872: PUSH
51873: LD_EXP 78
51877: PUSH
51878: LD_VAR 0 3
51882: ARRAY
51883: PUSH
51884: LD_INT 1
51886: PLUS
51887: PUSH
51888: EMPTY
51889: LIST
51890: LIST
51891: PPUSH
51892: LD_VAR 0 1
51896: PPUSH
51897: CALL 58220 0 3
51901: ST_TO_ADDR
// exit ;
51902: POP
51903: POP
51904: GO 51910
// end ; end ;
51906: GO 51710
51908: POP
51909: POP
// end ;
51910: LD_VAR 0 2
51914: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
51915: LD_INT 0
51917: PPUSH
51918: PPUSH
51919: PPUSH
51920: PPUSH
51921: PPUSH
51922: PPUSH
51923: PPUSH
// if not mc_bases or not skirmish then
51924: LD_EXP 78
51928: NOT
51929: PUSH
51930: LD_EXP 76
51934: NOT
51935: OR
51936: IFFALSE 51940
// exit ;
51938: GO 52601
// for i = 1 to mc_bases do
51940: LD_ADDR_VAR 0 3
51944: PUSH
51945: DOUBLE
51946: LD_INT 1
51948: DEC
51949: ST_TO_ADDR
51950: LD_EXP 78
51954: PUSH
51955: FOR_TO
51956: IFFALSE 52599
// begin if building in mc_construct_list [ i ] then
51958: LD_VAR 0 1
51962: PUSH
51963: LD_EXP 85
51967: PUSH
51968: LD_VAR 0 3
51972: ARRAY
51973: IN
51974: IFFALSE 52597
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51976: LD_ADDR_EXP 85
51980: PUSH
51981: LD_EXP 85
51985: PPUSH
51986: LD_VAR 0 3
51990: PPUSH
51991: LD_EXP 85
51995: PUSH
51996: LD_VAR 0 3
52000: ARRAY
52001: PUSH
52002: LD_VAR 0 1
52006: DIFF
52007: PPUSH
52008: CALL_OW 1
52012: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52013: LD_ADDR_EXP 78
52017: PUSH
52018: LD_EXP 78
52022: PPUSH
52023: LD_VAR 0 3
52027: PUSH
52028: LD_EXP 78
52032: PUSH
52033: LD_VAR 0 3
52037: ARRAY
52038: PUSH
52039: LD_INT 1
52041: PLUS
52042: PUSH
52043: EMPTY
52044: LIST
52045: LIST
52046: PPUSH
52047: LD_VAR 0 1
52051: PPUSH
52052: CALL 58220 0 3
52056: ST_TO_ADDR
// btype := GetBType ( building ) ;
52057: LD_ADDR_VAR 0 5
52061: PUSH
52062: LD_VAR 0 1
52066: PPUSH
52067: CALL_OW 266
52071: ST_TO_ADDR
// side := GetSide ( building ) ;
52072: LD_ADDR_VAR 0 8
52076: PUSH
52077: LD_VAR 0 1
52081: PPUSH
52082: CALL_OW 255
52086: ST_TO_ADDR
// if btype = b_lab then
52087: LD_VAR 0 5
52091: PUSH
52092: LD_INT 6
52094: EQUAL
52095: IFFALSE 52145
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
52097: LD_ADDR_EXP 111
52101: PUSH
52102: LD_EXP 111
52106: PPUSH
52107: LD_VAR 0 3
52111: PUSH
52112: LD_EXP 111
52116: PUSH
52117: LD_VAR 0 3
52121: ARRAY
52122: PUSH
52123: LD_INT 1
52125: PLUS
52126: PUSH
52127: EMPTY
52128: LIST
52129: LIST
52130: PPUSH
52131: LD_VAR 0 1
52135: PPUSH
52136: CALL 58220 0 3
52140: ST_TO_ADDR
// exit ;
52141: POP
52142: POP
52143: GO 52601
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
52145: LD_VAR 0 5
52149: PUSH
52150: LD_INT 0
52152: PUSH
52153: LD_INT 2
52155: PUSH
52156: LD_INT 4
52158: PUSH
52159: EMPTY
52160: LIST
52161: LIST
52162: LIST
52163: IN
52164: IFFALSE 52288
// begin if btype = b_armoury then
52166: LD_VAR 0 5
52170: PUSH
52171: LD_INT 4
52173: EQUAL
52174: IFFALSE 52184
// btype := b_barracks ;
52176: LD_ADDR_VAR 0 5
52180: PUSH
52181: LD_INT 5
52183: ST_TO_ADDR
// if btype = b_depot then
52184: LD_VAR 0 5
52188: PUSH
52189: LD_INT 0
52191: EQUAL
52192: IFFALSE 52202
// btype := b_warehouse ;
52194: LD_ADDR_VAR 0 5
52198: PUSH
52199: LD_INT 1
52201: ST_TO_ADDR
// if btype = b_workshop then
52202: LD_VAR 0 5
52206: PUSH
52207: LD_INT 2
52209: EQUAL
52210: IFFALSE 52220
// btype := b_factory ;
52212: LD_ADDR_VAR 0 5
52216: PUSH
52217: LD_INT 3
52219: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
52220: LD_VAR 0 5
52224: PPUSH
52225: LD_VAR 0 8
52229: PPUSH
52230: CALL_OW 323
52234: PUSH
52235: LD_INT 1
52237: EQUAL
52238: IFFALSE 52284
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
52240: LD_ADDR_EXP 110
52244: PUSH
52245: LD_EXP 110
52249: PPUSH
52250: LD_VAR 0 3
52254: PUSH
52255: LD_EXP 110
52259: PUSH
52260: LD_VAR 0 3
52264: ARRAY
52265: PUSH
52266: LD_INT 1
52268: PLUS
52269: PUSH
52270: EMPTY
52271: LIST
52272: LIST
52273: PPUSH
52274: LD_VAR 0 1
52278: PPUSH
52279: CALL 58220 0 3
52283: ST_TO_ADDR
// exit ;
52284: POP
52285: POP
52286: GO 52601
// end ; if btype in [ b_bunker , b_turret ] then
52288: LD_VAR 0 5
52292: PUSH
52293: LD_INT 32
52295: PUSH
52296: LD_INT 33
52298: PUSH
52299: EMPTY
52300: LIST
52301: LIST
52302: IN
52303: IFFALSE 52593
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
52305: LD_ADDR_EXP 86
52309: PUSH
52310: LD_EXP 86
52314: PPUSH
52315: LD_VAR 0 3
52319: PUSH
52320: LD_EXP 86
52324: PUSH
52325: LD_VAR 0 3
52329: ARRAY
52330: PUSH
52331: LD_INT 1
52333: PLUS
52334: PUSH
52335: EMPTY
52336: LIST
52337: LIST
52338: PPUSH
52339: LD_VAR 0 1
52343: PPUSH
52344: CALL 58220 0 3
52348: ST_TO_ADDR
// if btype = b_bunker then
52349: LD_VAR 0 5
52353: PUSH
52354: LD_INT 32
52356: EQUAL
52357: IFFALSE 52593
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52359: LD_ADDR_EXP 87
52363: PUSH
52364: LD_EXP 87
52368: PPUSH
52369: LD_VAR 0 3
52373: PUSH
52374: LD_EXP 87
52378: PUSH
52379: LD_VAR 0 3
52383: ARRAY
52384: PUSH
52385: LD_INT 1
52387: PLUS
52388: PUSH
52389: EMPTY
52390: LIST
52391: LIST
52392: PPUSH
52393: LD_VAR 0 1
52397: PPUSH
52398: CALL 58220 0 3
52402: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
52403: LD_ADDR_VAR 0 6
52407: PUSH
52408: LD_EXP 78
52412: PUSH
52413: LD_VAR 0 3
52417: ARRAY
52418: PPUSH
52419: LD_INT 25
52421: PUSH
52422: LD_INT 1
52424: PUSH
52425: EMPTY
52426: LIST
52427: LIST
52428: PUSH
52429: LD_INT 3
52431: PUSH
52432: LD_INT 54
52434: PUSH
52435: EMPTY
52436: LIST
52437: PUSH
52438: EMPTY
52439: LIST
52440: LIST
52441: PUSH
52442: EMPTY
52443: LIST
52444: LIST
52445: PPUSH
52446: CALL_OW 72
52450: ST_TO_ADDR
// if tmp then
52451: LD_VAR 0 6
52455: IFFALSE 52461
// exit ;
52457: POP
52458: POP
52459: GO 52601
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52461: LD_ADDR_VAR 0 6
52465: PUSH
52466: LD_EXP 78
52470: PUSH
52471: LD_VAR 0 3
52475: ARRAY
52476: PPUSH
52477: LD_INT 2
52479: PUSH
52480: LD_INT 30
52482: PUSH
52483: LD_INT 4
52485: PUSH
52486: EMPTY
52487: LIST
52488: LIST
52489: PUSH
52490: LD_INT 30
52492: PUSH
52493: LD_INT 5
52495: PUSH
52496: EMPTY
52497: LIST
52498: LIST
52499: PUSH
52500: EMPTY
52501: LIST
52502: LIST
52503: LIST
52504: PPUSH
52505: CALL_OW 72
52509: ST_TO_ADDR
// if not tmp then
52510: LD_VAR 0 6
52514: NOT
52515: IFFALSE 52521
// exit ;
52517: POP
52518: POP
52519: GO 52601
// for j in tmp do
52521: LD_ADDR_VAR 0 4
52525: PUSH
52526: LD_VAR 0 6
52530: PUSH
52531: FOR_IN
52532: IFFALSE 52591
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
52534: LD_ADDR_VAR 0 7
52538: PUSH
52539: LD_VAR 0 4
52543: PPUSH
52544: CALL_OW 313
52548: PPUSH
52549: LD_INT 25
52551: PUSH
52552: LD_INT 1
52554: PUSH
52555: EMPTY
52556: LIST
52557: LIST
52558: PPUSH
52559: CALL_OW 72
52563: ST_TO_ADDR
// if units then
52564: LD_VAR 0 7
52568: IFFALSE 52589
// begin ComExitBuilding ( units [ 1 ] ) ;
52570: LD_VAR 0 7
52574: PUSH
52575: LD_INT 1
52577: ARRAY
52578: PPUSH
52579: CALL_OW 122
// exit ;
52583: POP
52584: POP
52585: POP
52586: POP
52587: GO 52601
// end ; end ;
52589: GO 52531
52591: POP
52592: POP
// end ; end ; exit ;
52593: POP
52594: POP
52595: GO 52601
// end ; end ;
52597: GO 51955
52599: POP
52600: POP
// end ;
52601: LD_VAR 0 2
52605: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
52606: LD_INT 0
52608: PPUSH
52609: PPUSH
52610: PPUSH
52611: PPUSH
52612: PPUSH
52613: PPUSH
52614: PPUSH
// if not mc_bases or not skirmish then
52615: LD_EXP 78
52619: NOT
52620: PUSH
52621: LD_EXP 76
52625: NOT
52626: OR
52627: IFFALSE 52631
// exit ;
52629: GO 52896
// btype := GetBType ( building ) ;
52631: LD_ADDR_VAR 0 6
52635: PUSH
52636: LD_VAR 0 1
52640: PPUSH
52641: CALL_OW 266
52645: ST_TO_ADDR
// x := GetX ( building ) ;
52646: LD_ADDR_VAR 0 7
52650: PUSH
52651: LD_VAR 0 1
52655: PPUSH
52656: CALL_OW 250
52660: ST_TO_ADDR
// y := GetY ( building ) ;
52661: LD_ADDR_VAR 0 8
52665: PUSH
52666: LD_VAR 0 1
52670: PPUSH
52671: CALL_OW 251
52675: ST_TO_ADDR
// d := GetDir ( building ) ;
52676: LD_ADDR_VAR 0 9
52680: PUSH
52681: LD_VAR 0 1
52685: PPUSH
52686: CALL_OW 254
52690: ST_TO_ADDR
// for i = 1 to mc_bases do
52691: LD_ADDR_VAR 0 4
52695: PUSH
52696: DOUBLE
52697: LD_INT 1
52699: DEC
52700: ST_TO_ADDR
52701: LD_EXP 78
52705: PUSH
52706: FOR_TO
52707: IFFALSE 52894
// begin if not mc_build_list [ i ] then
52709: LD_EXP 83
52713: PUSH
52714: LD_VAR 0 4
52718: ARRAY
52719: NOT
52720: IFFALSE 52724
// continue ;
52722: GO 52706
// for j := 1 to mc_build_list [ i ] do
52724: LD_ADDR_VAR 0 5
52728: PUSH
52729: DOUBLE
52730: LD_INT 1
52732: DEC
52733: ST_TO_ADDR
52734: LD_EXP 83
52738: PUSH
52739: LD_VAR 0 4
52743: ARRAY
52744: PUSH
52745: FOR_TO
52746: IFFALSE 52890
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
52748: LD_VAR 0 6
52752: PUSH
52753: LD_VAR 0 7
52757: PUSH
52758: LD_VAR 0 8
52762: PUSH
52763: LD_VAR 0 9
52767: PUSH
52768: EMPTY
52769: LIST
52770: LIST
52771: LIST
52772: LIST
52773: PPUSH
52774: LD_EXP 83
52778: PUSH
52779: LD_VAR 0 4
52783: ARRAY
52784: PUSH
52785: LD_VAR 0 5
52789: ARRAY
52790: PPUSH
52791: CALL 64777 0 2
52795: IFFALSE 52888
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
52797: LD_ADDR_EXP 83
52801: PUSH
52802: LD_EXP 83
52806: PPUSH
52807: LD_VAR 0 4
52811: PPUSH
52812: LD_EXP 83
52816: PUSH
52817: LD_VAR 0 4
52821: ARRAY
52822: PPUSH
52823: LD_VAR 0 5
52827: PPUSH
52828: CALL_OW 3
52832: PPUSH
52833: CALL_OW 1
52837: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
52838: LD_ADDR_EXP 85
52842: PUSH
52843: LD_EXP 85
52847: PPUSH
52848: LD_VAR 0 4
52852: PUSH
52853: LD_EXP 85
52857: PUSH
52858: LD_VAR 0 4
52862: ARRAY
52863: PUSH
52864: LD_INT 1
52866: PLUS
52867: PUSH
52868: EMPTY
52869: LIST
52870: LIST
52871: PPUSH
52872: LD_VAR 0 1
52876: PPUSH
52877: CALL 58220 0 3
52881: ST_TO_ADDR
// exit ;
52882: POP
52883: POP
52884: POP
52885: POP
52886: GO 52896
// end ;
52888: GO 52745
52890: POP
52891: POP
// end ;
52892: GO 52706
52894: POP
52895: POP
// end ;
52896: LD_VAR 0 3
52900: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
52901: LD_INT 0
52903: PPUSH
52904: PPUSH
52905: PPUSH
// if not mc_bases or not skirmish then
52906: LD_EXP 78
52910: NOT
52911: PUSH
52912: LD_EXP 76
52916: NOT
52917: OR
52918: IFFALSE 52922
// exit ;
52920: GO 53112
// for i = 1 to mc_bases do
52922: LD_ADDR_VAR 0 4
52926: PUSH
52927: DOUBLE
52928: LD_INT 1
52930: DEC
52931: ST_TO_ADDR
52932: LD_EXP 78
52936: PUSH
52937: FOR_TO
52938: IFFALSE 53025
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
52940: LD_VAR 0 1
52944: PUSH
52945: LD_EXP 86
52949: PUSH
52950: LD_VAR 0 4
52954: ARRAY
52955: IN
52956: PUSH
52957: LD_VAR 0 1
52961: PUSH
52962: LD_EXP 87
52966: PUSH
52967: LD_VAR 0 4
52971: ARRAY
52972: IN
52973: NOT
52974: AND
52975: IFFALSE 53023
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52977: LD_ADDR_EXP 87
52981: PUSH
52982: LD_EXP 87
52986: PPUSH
52987: LD_VAR 0 4
52991: PUSH
52992: LD_EXP 87
52996: PUSH
52997: LD_VAR 0 4
53001: ARRAY
53002: PUSH
53003: LD_INT 1
53005: PLUS
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: PPUSH
53011: LD_VAR 0 1
53015: PPUSH
53016: CALL 58220 0 3
53020: ST_TO_ADDR
// break ;
53021: GO 53025
// end ; end ;
53023: GO 52937
53025: POP
53026: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
53027: LD_VAR 0 1
53031: PPUSH
53032: CALL_OW 257
53036: PUSH
53037: LD_EXP 104
53041: IN
53042: PUSH
53043: LD_VAR 0 1
53047: PPUSH
53048: CALL_OW 266
53052: PUSH
53053: LD_INT 5
53055: EQUAL
53056: AND
53057: PUSH
53058: LD_VAR 0 2
53062: PPUSH
53063: CALL_OW 110
53067: PUSH
53068: LD_INT 18
53070: NONEQUAL
53071: AND
53072: IFFALSE 53112
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
53074: LD_VAR 0 2
53078: PPUSH
53079: CALL_OW 257
53083: PUSH
53084: LD_INT 5
53086: PUSH
53087: LD_INT 8
53089: PUSH
53090: LD_INT 9
53092: PUSH
53093: EMPTY
53094: LIST
53095: LIST
53096: LIST
53097: IN
53098: IFFALSE 53112
// SetClass ( unit , 1 ) ;
53100: LD_VAR 0 2
53104: PPUSH
53105: LD_INT 1
53107: PPUSH
53108: CALL_OW 336
// end ;
53112: LD_VAR 0 3
53116: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
53117: LD_INT 0
53119: PPUSH
53120: PPUSH
// if not mc_bases or not skirmish then
53121: LD_EXP 78
53125: NOT
53126: PUSH
53127: LD_EXP 76
53131: NOT
53132: OR
53133: IFFALSE 53137
// exit ;
53135: GO 53253
// if GetLives ( abandoned_vehicle ) > 250 then
53137: LD_VAR 0 2
53141: PPUSH
53142: CALL_OW 256
53146: PUSH
53147: LD_INT 250
53149: GREATER
53150: IFFALSE 53154
// exit ;
53152: GO 53253
// for i = 1 to mc_bases do
53154: LD_ADDR_VAR 0 6
53158: PUSH
53159: DOUBLE
53160: LD_INT 1
53162: DEC
53163: ST_TO_ADDR
53164: LD_EXP 78
53168: PUSH
53169: FOR_TO
53170: IFFALSE 53251
// begin if driver in mc_bases [ i ] then
53172: LD_VAR 0 1
53176: PUSH
53177: LD_EXP 78
53181: PUSH
53182: LD_VAR 0 6
53186: ARRAY
53187: IN
53188: IFFALSE 53249
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
53190: LD_VAR 0 1
53194: PPUSH
53195: LD_EXP 78
53199: PUSH
53200: LD_VAR 0 6
53204: ARRAY
53205: PPUSH
53206: LD_INT 2
53208: PUSH
53209: LD_INT 30
53211: PUSH
53212: LD_INT 0
53214: PUSH
53215: EMPTY
53216: LIST
53217: LIST
53218: PUSH
53219: LD_INT 30
53221: PUSH
53222: LD_INT 1
53224: PUSH
53225: EMPTY
53226: LIST
53227: LIST
53228: PUSH
53229: EMPTY
53230: LIST
53231: LIST
53232: LIST
53233: PPUSH
53234: CALL_OW 72
53238: PUSH
53239: LD_INT 1
53241: ARRAY
53242: PPUSH
53243: CALL 91837 0 2
// break ;
53247: GO 53251
// end ; end ;
53249: GO 53169
53251: POP
53252: POP
// end ; end_of_file
53253: LD_VAR 0 5
53257: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
53258: LD_INT 0
53260: PPUSH
53261: PPUSH
// if exist_mode then
53262: LD_VAR 0 2
53266: IFFALSE 53291
// unit := CreateCharacter ( prefix & ident ) else
53268: LD_ADDR_VAR 0 5
53272: PUSH
53273: LD_VAR 0 3
53277: PUSH
53278: LD_VAR 0 1
53282: STR
53283: PPUSH
53284: CALL_OW 34
53288: ST_TO_ADDR
53289: GO 53306
// unit := NewCharacter ( ident ) ;
53291: LD_ADDR_VAR 0 5
53295: PUSH
53296: LD_VAR 0 1
53300: PPUSH
53301: CALL_OW 25
53305: ST_TO_ADDR
// result := unit ;
53306: LD_ADDR_VAR 0 4
53310: PUSH
53311: LD_VAR 0 5
53315: ST_TO_ADDR
// end ;
53316: LD_VAR 0 4
53320: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
53321: LD_INT 0
53323: PPUSH
53324: PPUSH
// if not side or not nation then
53325: LD_VAR 0 1
53329: NOT
53330: PUSH
53331: LD_VAR 0 2
53335: NOT
53336: OR
53337: IFFALSE 53341
// exit ;
53339: GO 54109
// case nation of nation_american :
53341: LD_VAR 0 2
53345: PUSH
53346: LD_INT 1
53348: DOUBLE
53349: EQUAL
53350: IFTRUE 53354
53352: GO 53568
53354: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
53355: LD_ADDR_VAR 0 4
53359: PUSH
53360: LD_INT 35
53362: PUSH
53363: LD_INT 45
53365: PUSH
53366: LD_INT 46
53368: PUSH
53369: LD_INT 47
53371: PUSH
53372: LD_INT 82
53374: PUSH
53375: LD_INT 83
53377: PUSH
53378: LD_INT 84
53380: PUSH
53381: LD_INT 85
53383: PUSH
53384: LD_INT 86
53386: PUSH
53387: LD_INT 1
53389: PUSH
53390: LD_INT 2
53392: PUSH
53393: LD_INT 6
53395: PUSH
53396: LD_INT 15
53398: PUSH
53399: LD_INT 16
53401: PUSH
53402: LD_INT 7
53404: PUSH
53405: LD_INT 12
53407: PUSH
53408: LD_INT 13
53410: PUSH
53411: LD_INT 10
53413: PUSH
53414: LD_INT 14
53416: PUSH
53417: LD_INT 20
53419: PUSH
53420: LD_INT 21
53422: PUSH
53423: LD_INT 22
53425: PUSH
53426: LD_INT 25
53428: PUSH
53429: LD_INT 32
53431: PUSH
53432: LD_INT 27
53434: PUSH
53435: LD_INT 36
53437: PUSH
53438: LD_INT 69
53440: PUSH
53441: LD_INT 39
53443: PUSH
53444: LD_INT 34
53446: PUSH
53447: LD_INT 40
53449: PUSH
53450: LD_INT 48
53452: PUSH
53453: LD_INT 49
53455: PUSH
53456: LD_INT 50
53458: PUSH
53459: LD_INT 51
53461: PUSH
53462: LD_INT 52
53464: PUSH
53465: LD_INT 53
53467: PUSH
53468: LD_INT 54
53470: PUSH
53471: LD_INT 55
53473: PUSH
53474: LD_INT 56
53476: PUSH
53477: LD_INT 57
53479: PUSH
53480: LD_INT 58
53482: PUSH
53483: LD_INT 59
53485: PUSH
53486: LD_INT 60
53488: PUSH
53489: LD_INT 61
53491: PUSH
53492: LD_INT 62
53494: PUSH
53495: LD_INT 80
53497: PUSH
53498: LD_INT 82
53500: PUSH
53501: LD_INT 83
53503: PUSH
53504: LD_INT 84
53506: PUSH
53507: LD_INT 85
53509: PUSH
53510: LD_INT 86
53512: PUSH
53513: EMPTY
53514: LIST
53515: LIST
53516: LIST
53517: LIST
53518: LIST
53519: LIST
53520: LIST
53521: LIST
53522: LIST
53523: LIST
53524: LIST
53525: LIST
53526: LIST
53527: LIST
53528: LIST
53529: LIST
53530: LIST
53531: LIST
53532: LIST
53533: LIST
53534: LIST
53535: LIST
53536: LIST
53537: LIST
53538: LIST
53539: LIST
53540: LIST
53541: LIST
53542: LIST
53543: LIST
53544: LIST
53545: LIST
53546: LIST
53547: LIST
53548: LIST
53549: LIST
53550: LIST
53551: LIST
53552: LIST
53553: LIST
53554: LIST
53555: LIST
53556: LIST
53557: LIST
53558: LIST
53559: LIST
53560: LIST
53561: LIST
53562: LIST
53563: LIST
53564: LIST
53565: ST_TO_ADDR
53566: GO 54033
53568: LD_INT 2
53570: DOUBLE
53571: EQUAL
53572: IFTRUE 53576
53574: GO 53802
53576: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
53577: LD_ADDR_VAR 0 4
53581: PUSH
53582: LD_INT 35
53584: PUSH
53585: LD_INT 45
53587: PUSH
53588: LD_INT 46
53590: PUSH
53591: LD_INT 47
53593: PUSH
53594: LD_INT 82
53596: PUSH
53597: LD_INT 83
53599: PUSH
53600: LD_INT 84
53602: PUSH
53603: LD_INT 85
53605: PUSH
53606: LD_INT 87
53608: PUSH
53609: LD_INT 70
53611: PUSH
53612: LD_INT 1
53614: PUSH
53615: LD_INT 11
53617: PUSH
53618: LD_INT 3
53620: PUSH
53621: LD_INT 4
53623: PUSH
53624: LD_INT 5
53626: PUSH
53627: LD_INT 6
53629: PUSH
53630: LD_INT 15
53632: PUSH
53633: LD_INT 18
53635: PUSH
53636: LD_INT 7
53638: PUSH
53639: LD_INT 17
53641: PUSH
53642: LD_INT 8
53644: PUSH
53645: LD_INT 20
53647: PUSH
53648: LD_INT 21
53650: PUSH
53651: LD_INT 22
53653: PUSH
53654: LD_INT 72
53656: PUSH
53657: LD_INT 26
53659: PUSH
53660: LD_INT 69
53662: PUSH
53663: LD_INT 39
53665: PUSH
53666: LD_INT 40
53668: PUSH
53669: LD_INT 41
53671: PUSH
53672: LD_INT 42
53674: PUSH
53675: LD_INT 43
53677: PUSH
53678: LD_INT 48
53680: PUSH
53681: LD_INT 49
53683: PUSH
53684: LD_INT 50
53686: PUSH
53687: LD_INT 51
53689: PUSH
53690: LD_INT 52
53692: PUSH
53693: LD_INT 53
53695: PUSH
53696: LD_INT 54
53698: PUSH
53699: LD_INT 55
53701: PUSH
53702: LD_INT 56
53704: PUSH
53705: LD_INT 60
53707: PUSH
53708: LD_INT 61
53710: PUSH
53711: LD_INT 62
53713: PUSH
53714: LD_INT 66
53716: PUSH
53717: LD_INT 67
53719: PUSH
53720: LD_INT 68
53722: PUSH
53723: LD_INT 81
53725: PUSH
53726: LD_INT 82
53728: PUSH
53729: LD_INT 83
53731: PUSH
53732: LD_INT 84
53734: PUSH
53735: LD_INT 85
53737: PUSH
53738: LD_INT 87
53740: PUSH
53741: LD_INT 88
53743: PUSH
53744: EMPTY
53745: LIST
53746: LIST
53747: LIST
53748: LIST
53749: LIST
53750: LIST
53751: LIST
53752: LIST
53753: LIST
53754: LIST
53755: LIST
53756: LIST
53757: LIST
53758: LIST
53759: LIST
53760: LIST
53761: LIST
53762: LIST
53763: LIST
53764: LIST
53765: LIST
53766: LIST
53767: LIST
53768: LIST
53769: LIST
53770: LIST
53771: LIST
53772: LIST
53773: LIST
53774: LIST
53775: LIST
53776: LIST
53777: LIST
53778: LIST
53779: LIST
53780: LIST
53781: LIST
53782: LIST
53783: LIST
53784: LIST
53785: LIST
53786: LIST
53787: LIST
53788: LIST
53789: LIST
53790: LIST
53791: LIST
53792: LIST
53793: LIST
53794: LIST
53795: LIST
53796: LIST
53797: LIST
53798: LIST
53799: ST_TO_ADDR
53800: GO 54033
53802: LD_INT 3
53804: DOUBLE
53805: EQUAL
53806: IFTRUE 53810
53808: GO 54032
53810: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
53811: LD_ADDR_VAR 0 4
53815: PUSH
53816: LD_INT 46
53818: PUSH
53819: LD_INT 47
53821: PUSH
53822: LD_INT 1
53824: PUSH
53825: LD_INT 2
53827: PUSH
53828: LD_INT 82
53830: PUSH
53831: LD_INT 83
53833: PUSH
53834: LD_INT 84
53836: PUSH
53837: LD_INT 85
53839: PUSH
53840: LD_INT 86
53842: PUSH
53843: LD_INT 11
53845: PUSH
53846: LD_INT 9
53848: PUSH
53849: LD_INT 20
53851: PUSH
53852: LD_INT 19
53854: PUSH
53855: LD_INT 21
53857: PUSH
53858: LD_INT 24
53860: PUSH
53861: LD_INT 22
53863: PUSH
53864: LD_INT 25
53866: PUSH
53867: LD_INT 28
53869: PUSH
53870: LD_INT 29
53872: PUSH
53873: LD_INT 30
53875: PUSH
53876: LD_INT 31
53878: PUSH
53879: LD_INT 37
53881: PUSH
53882: LD_INT 38
53884: PUSH
53885: LD_INT 32
53887: PUSH
53888: LD_INT 27
53890: PUSH
53891: LD_INT 33
53893: PUSH
53894: LD_INT 69
53896: PUSH
53897: LD_INT 39
53899: PUSH
53900: LD_INT 34
53902: PUSH
53903: LD_INT 40
53905: PUSH
53906: LD_INT 71
53908: PUSH
53909: LD_INT 23
53911: PUSH
53912: LD_INT 44
53914: PUSH
53915: LD_INT 48
53917: PUSH
53918: LD_INT 49
53920: PUSH
53921: LD_INT 50
53923: PUSH
53924: LD_INT 51
53926: PUSH
53927: LD_INT 52
53929: PUSH
53930: LD_INT 53
53932: PUSH
53933: LD_INT 54
53935: PUSH
53936: LD_INT 55
53938: PUSH
53939: LD_INT 56
53941: PUSH
53942: LD_INT 57
53944: PUSH
53945: LD_INT 58
53947: PUSH
53948: LD_INT 59
53950: PUSH
53951: LD_INT 63
53953: PUSH
53954: LD_INT 64
53956: PUSH
53957: LD_INT 65
53959: PUSH
53960: LD_INT 82
53962: PUSH
53963: LD_INT 83
53965: PUSH
53966: LD_INT 84
53968: PUSH
53969: LD_INT 85
53971: PUSH
53972: LD_INT 86
53974: PUSH
53975: EMPTY
53976: LIST
53977: LIST
53978: LIST
53979: LIST
53980: LIST
53981: LIST
53982: LIST
53983: LIST
53984: LIST
53985: LIST
53986: LIST
53987: LIST
53988: LIST
53989: LIST
53990: LIST
53991: LIST
53992: LIST
53993: LIST
53994: LIST
53995: LIST
53996: LIST
53997: LIST
53998: LIST
53999: LIST
54000: LIST
54001: LIST
54002: LIST
54003: LIST
54004: LIST
54005: LIST
54006: LIST
54007: LIST
54008: LIST
54009: LIST
54010: LIST
54011: LIST
54012: LIST
54013: LIST
54014: LIST
54015: LIST
54016: LIST
54017: LIST
54018: LIST
54019: LIST
54020: LIST
54021: LIST
54022: LIST
54023: LIST
54024: LIST
54025: LIST
54026: LIST
54027: LIST
54028: LIST
54029: ST_TO_ADDR
54030: GO 54033
54032: POP
// if state > - 1 and state < 3 then
54033: LD_VAR 0 3
54037: PUSH
54038: LD_INT 1
54040: NEG
54041: GREATER
54042: PUSH
54043: LD_VAR 0 3
54047: PUSH
54048: LD_INT 3
54050: LESS
54051: AND
54052: IFFALSE 54109
// for i in result do
54054: LD_ADDR_VAR 0 5
54058: PUSH
54059: LD_VAR 0 4
54063: PUSH
54064: FOR_IN
54065: IFFALSE 54107
// if GetTech ( i , side ) <> state then
54067: LD_VAR 0 5
54071: PPUSH
54072: LD_VAR 0 1
54076: PPUSH
54077: CALL_OW 321
54081: PUSH
54082: LD_VAR 0 3
54086: NONEQUAL
54087: IFFALSE 54105
// result := result diff i ;
54089: LD_ADDR_VAR 0 4
54093: PUSH
54094: LD_VAR 0 4
54098: PUSH
54099: LD_VAR 0 5
54103: DIFF
54104: ST_TO_ADDR
54105: GO 54064
54107: POP
54108: POP
// end ;
54109: LD_VAR 0 4
54113: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
54114: LD_INT 0
54116: PPUSH
54117: PPUSH
54118: PPUSH
// result := true ;
54119: LD_ADDR_VAR 0 3
54123: PUSH
54124: LD_INT 1
54126: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
54127: LD_ADDR_VAR 0 5
54131: PUSH
54132: LD_VAR 0 2
54136: PPUSH
54137: CALL_OW 480
54141: ST_TO_ADDR
// if not tmp then
54142: LD_VAR 0 5
54146: NOT
54147: IFFALSE 54151
// exit ;
54149: GO 54200
// for i in tmp do
54151: LD_ADDR_VAR 0 4
54155: PUSH
54156: LD_VAR 0 5
54160: PUSH
54161: FOR_IN
54162: IFFALSE 54198
// if GetTech ( i , side ) <> state_researched then
54164: LD_VAR 0 4
54168: PPUSH
54169: LD_VAR 0 1
54173: PPUSH
54174: CALL_OW 321
54178: PUSH
54179: LD_INT 2
54181: NONEQUAL
54182: IFFALSE 54196
// begin result := false ;
54184: LD_ADDR_VAR 0 3
54188: PUSH
54189: LD_INT 0
54191: ST_TO_ADDR
// exit ;
54192: POP
54193: POP
54194: GO 54200
// end ;
54196: GO 54161
54198: POP
54199: POP
// end ;
54200: LD_VAR 0 3
54204: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
54205: LD_INT 0
54207: PPUSH
54208: PPUSH
54209: PPUSH
54210: PPUSH
54211: PPUSH
54212: PPUSH
54213: PPUSH
54214: PPUSH
54215: PPUSH
54216: PPUSH
54217: PPUSH
54218: PPUSH
54219: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
54220: LD_VAR 0 1
54224: NOT
54225: PUSH
54226: LD_VAR 0 1
54230: PPUSH
54231: CALL_OW 257
54235: PUSH
54236: LD_INT 9
54238: NONEQUAL
54239: OR
54240: IFFALSE 54244
// exit ;
54242: GO 54817
// side := GetSide ( unit ) ;
54244: LD_ADDR_VAR 0 9
54248: PUSH
54249: LD_VAR 0 1
54253: PPUSH
54254: CALL_OW 255
54258: ST_TO_ADDR
// tech_space := tech_spacanom ;
54259: LD_ADDR_VAR 0 12
54263: PUSH
54264: LD_INT 29
54266: ST_TO_ADDR
// tech_time := tech_taurad ;
54267: LD_ADDR_VAR 0 13
54271: PUSH
54272: LD_INT 28
54274: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
54275: LD_ADDR_VAR 0 11
54279: PUSH
54280: LD_VAR 0 1
54284: PPUSH
54285: CALL_OW 310
54289: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
54290: LD_VAR 0 11
54294: PPUSH
54295: CALL_OW 247
54299: PUSH
54300: LD_INT 2
54302: EQUAL
54303: IFFALSE 54307
// exit ;
54305: GO 54817
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54307: LD_ADDR_VAR 0 8
54311: PUSH
54312: LD_INT 81
54314: PUSH
54315: LD_VAR 0 9
54319: PUSH
54320: EMPTY
54321: LIST
54322: LIST
54323: PUSH
54324: LD_INT 3
54326: PUSH
54327: LD_INT 21
54329: PUSH
54330: LD_INT 3
54332: PUSH
54333: EMPTY
54334: LIST
54335: LIST
54336: PUSH
54337: EMPTY
54338: LIST
54339: LIST
54340: PUSH
54341: EMPTY
54342: LIST
54343: LIST
54344: PPUSH
54345: CALL_OW 69
54349: ST_TO_ADDR
// if not tmp then
54350: LD_VAR 0 8
54354: NOT
54355: IFFALSE 54359
// exit ;
54357: GO 54817
// if in_unit then
54359: LD_VAR 0 11
54363: IFFALSE 54387
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
54365: LD_ADDR_VAR 0 10
54369: PUSH
54370: LD_VAR 0 8
54374: PPUSH
54375: LD_VAR 0 11
54379: PPUSH
54380: CALL_OW 74
54384: ST_TO_ADDR
54385: GO 54407
// enemy := NearestUnitToUnit ( tmp , unit ) ;
54387: LD_ADDR_VAR 0 10
54391: PUSH
54392: LD_VAR 0 8
54396: PPUSH
54397: LD_VAR 0 1
54401: PPUSH
54402: CALL_OW 74
54406: ST_TO_ADDR
// if not enemy then
54407: LD_VAR 0 10
54411: NOT
54412: IFFALSE 54416
// exit ;
54414: GO 54817
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54416: LD_VAR 0 11
54420: PUSH
54421: LD_VAR 0 11
54425: PPUSH
54426: LD_VAR 0 10
54430: PPUSH
54431: CALL_OW 296
54435: PUSH
54436: LD_INT 13
54438: GREATER
54439: AND
54440: PUSH
54441: LD_VAR 0 1
54445: PPUSH
54446: LD_VAR 0 10
54450: PPUSH
54451: CALL_OW 296
54455: PUSH
54456: LD_INT 12
54458: GREATER
54459: OR
54460: IFFALSE 54464
// exit ;
54462: GO 54817
// missile := [ 1 ] ;
54464: LD_ADDR_VAR 0 14
54468: PUSH
54469: LD_INT 1
54471: PUSH
54472: EMPTY
54473: LIST
54474: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54475: LD_VAR 0 9
54479: PPUSH
54480: LD_VAR 0 12
54484: PPUSH
54485: CALL_OW 325
54489: IFFALSE 54518
// missile := Replace ( missile , missile + 1 , 2 ) ;
54491: LD_ADDR_VAR 0 14
54495: PUSH
54496: LD_VAR 0 14
54500: PPUSH
54501: LD_VAR 0 14
54505: PUSH
54506: LD_INT 1
54508: PLUS
54509: PPUSH
54510: LD_INT 2
54512: PPUSH
54513: CALL_OW 1
54517: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54518: LD_VAR 0 9
54522: PPUSH
54523: LD_VAR 0 13
54527: PPUSH
54528: CALL_OW 325
54532: PUSH
54533: LD_VAR 0 10
54537: PPUSH
54538: CALL_OW 255
54542: PPUSH
54543: LD_VAR 0 13
54547: PPUSH
54548: CALL_OW 325
54552: NOT
54553: AND
54554: IFFALSE 54583
// missile := Replace ( missile , missile + 1 , 3 ) ;
54556: LD_ADDR_VAR 0 14
54560: PUSH
54561: LD_VAR 0 14
54565: PPUSH
54566: LD_VAR 0 14
54570: PUSH
54571: LD_INT 1
54573: PLUS
54574: PPUSH
54575: LD_INT 3
54577: PPUSH
54578: CALL_OW 1
54582: ST_TO_ADDR
// if missile < 2 then
54583: LD_VAR 0 14
54587: PUSH
54588: LD_INT 2
54590: LESS
54591: IFFALSE 54595
// exit ;
54593: GO 54817
// x := GetX ( enemy ) ;
54595: LD_ADDR_VAR 0 4
54599: PUSH
54600: LD_VAR 0 10
54604: PPUSH
54605: CALL_OW 250
54609: ST_TO_ADDR
// y := GetY ( enemy ) ;
54610: LD_ADDR_VAR 0 5
54614: PUSH
54615: LD_VAR 0 10
54619: PPUSH
54620: CALL_OW 251
54624: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
54625: LD_ADDR_VAR 0 6
54629: PUSH
54630: LD_VAR 0 4
54634: PUSH
54635: LD_INT 1
54637: NEG
54638: PPUSH
54639: LD_INT 1
54641: PPUSH
54642: CALL_OW 12
54646: PLUS
54647: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
54648: LD_ADDR_VAR 0 7
54652: PUSH
54653: LD_VAR 0 5
54657: PUSH
54658: LD_INT 1
54660: NEG
54661: PPUSH
54662: LD_INT 1
54664: PPUSH
54665: CALL_OW 12
54669: PLUS
54670: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54671: LD_VAR 0 6
54675: PPUSH
54676: LD_VAR 0 7
54680: PPUSH
54681: CALL_OW 488
54685: NOT
54686: IFFALSE 54708
// begin _x := x ;
54688: LD_ADDR_VAR 0 6
54692: PUSH
54693: LD_VAR 0 4
54697: ST_TO_ADDR
// _y := y ;
54698: LD_ADDR_VAR 0 7
54702: PUSH
54703: LD_VAR 0 5
54707: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
54708: LD_ADDR_VAR 0 3
54712: PUSH
54713: LD_INT 1
54715: PPUSH
54716: LD_VAR 0 14
54720: PPUSH
54721: CALL_OW 12
54725: ST_TO_ADDR
// case i of 1 :
54726: LD_VAR 0 3
54730: PUSH
54731: LD_INT 1
54733: DOUBLE
54734: EQUAL
54735: IFTRUE 54739
54737: GO 54756
54739: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
54740: LD_VAR 0 1
54744: PPUSH
54745: LD_VAR 0 10
54749: PPUSH
54750: CALL_OW 115
54754: GO 54817
54756: LD_INT 2
54758: DOUBLE
54759: EQUAL
54760: IFTRUE 54764
54762: GO 54786
54764: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
54765: LD_VAR 0 1
54769: PPUSH
54770: LD_VAR 0 6
54774: PPUSH
54775: LD_VAR 0 7
54779: PPUSH
54780: CALL_OW 153
54784: GO 54817
54786: LD_INT 3
54788: DOUBLE
54789: EQUAL
54790: IFTRUE 54794
54792: GO 54816
54794: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
54795: LD_VAR 0 1
54799: PPUSH
54800: LD_VAR 0 6
54804: PPUSH
54805: LD_VAR 0 7
54809: PPUSH
54810: CALL_OW 154
54814: GO 54817
54816: POP
// end ;
54817: LD_VAR 0 2
54821: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
54822: LD_INT 0
54824: PPUSH
54825: PPUSH
54826: PPUSH
54827: PPUSH
54828: PPUSH
54829: PPUSH
// if not unit or not building then
54830: LD_VAR 0 1
54834: NOT
54835: PUSH
54836: LD_VAR 0 2
54840: NOT
54841: OR
54842: IFFALSE 54846
// exit ;
54844: GO 55004
// x := GetX ( building ) ;
54846: LD_ADDR_VAR 0 5
54850: PUSH
54851: LD_VAR 0 2
54855: PPUSH
54856: CALL_OW 250
54860: ST_TO_ADDR
// y := GetY ( building ) ;
54861: LD_ADDR_VAR 0 6
54865: PUSH
54866: LD_VAR 0 2
54870: PPUSH
54871: CALL_OW 251
54875: ST_TO_ADDR
// for i = 0 to 5 do
54876: LD_ADDR_VAR 0 4
54880: PUSH
54881: DOUBLE
54882: LD_INT 0
54884: DEC
54885: ST_TO_ADDR
54886: LD_INT 5
54888: PUSH
54889: FOR_TO
54890: IFFALSE 55002
// begin _x := ShiftX ( x , i , 3 ) ;
54892: LD_ADDR_VAR 0 7
54896: PUSH
54897: LD_VAR 0 5
54901: PPUSH
54902: LD_VAR 0 4
54906: PPUSH
54907: LD_INT 3
54909: PPUSH
54910: CALL_OW 272
54914: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
54915: LD_ADDR_VAR 0 8
54919: PUSH
54920: LD_VAR 0 6
54924: PPUSH
54925: LD_VAR 0 4
54929: PPUSH
54930: LD_INT 3
54932: PPUSH
54933: CALL_OW 273
54937: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54938: LD_VAR 0 7
54942: PPUSH
54943: LD_VAR 0 8
54947: PPUSH
54948: CALL_OW 488
54952: NOT
54953: IFFALSE 54957
// continue ;
54955: GO 54889
// if HexInfo ( _x , _y ) = 0 then
54957: LD_VAR 0 7
54961: PPUSH
54962: LD_VAR 0 8
54966: PPUSH
54967: CALL_OW 428
54971: PUSH
54972: LD_INT 0
54974: EQUAL
54975: IFFALSE 55000
// begin ComMoveXY ( unit , _x , _y ) ;
54977: LD_VAR 0 1
54981: PPUSH
54982: LD_VAR 0 7
54986: PPUSH
54987: LD_VAR 0 8
54991: PPUSH
54992: CALL_OW 111
// exit ;
54996: POP
54997: POP
54998: GO 55004
// end ; end ;
55000: GO 54889
55002: POP
55003: POP
// end ;
55004: LD_VAR 0 3
55008: RET
// export function ScanBase ( side , base_area ) ; begin
55009: LD_INT 0
55011: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
55012: LD_ADDR_VAR 0 3
55016: PUSH
55017: LD_VAR 0 2
55021: PPUSH
55022: LD_INT 81
55024: PUSH
55025: LD_VAR 0 1
55029: PUSH
55030: EMPTY
55031: LIST
55032: LIST
55033: PPUSH
55034: CALL_OW 70
55038: ST_TO_ADDR
// end ;
55039: LD_VAR 0 3
55043: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
55044: LD_INT 0
55046: PPUSH
55047: PPUSH
55048: PPUSH
55049: PPUSH
// result := false ;
55050: LD_ADDR_VAR 0 2
55054: PUSH
55055: LD_INT 0
55057: ST_TO_ADDR
// side := GetSide ( unit ) ;
55058: LD_ADDR_VAR 0 3
55062: PUSH
55063: LD_VAR 0 1
55067: PPUSH
55068: CALL_OW 255
55072: ST_TO_ADDR
// nat := GetNation ( unit ) ;
55073: LD_ADDR_VAR 0 4
55077: PUSH
55078: LD_VAR 0 1
55082: PPUSH
55083: CALL_OW 248
55087: ST_TO_ADDR
// case nat of 1 :
55088: LD_VAR 0 4
55092: PUSH
55093: LD_INT 1
55095: DOUBLE
55096: EQUAL
55097: IFTRUE 55101
55099: GO 55112
55101: POP
// tech := tech_lassight ; 2 :
55102: LD_ADDR_VAR 0 5
55106: PUSH
55107: LD_INT 12
55109: ST_TO_ADDR
55110: GO 55151
55112: LD_INT 2
55114: DOUBLE
55115: EQUAL
55116: IFTRUE 55120
55118: GO 55131
55120: POP
// tech := tech_mortar ; 3 :
55121: LD_ADDR_VAR 0 5
55125: PUSH
55126: LD_INT 41
55128: ST_TO_ADDR
55129: GO 55151
55131: LD_INT 3
55133: DOUBLE
55134: EQUAL
55135: IFTRUE 55139
55137: GO 55150
55139: POP
// tech := tech_bazooka ; end ;
55140: LD_ADDR_VAR 0 5
55144: PUSH
55145: LD_INT 44
55147: ST_TO_ADDR
55148: GO 55151
55150: POP
// if Researched ( side , tech ) then
55151: LD_VAR 0 3
55155: PPUSH
55156: LD_VAR 0 5
55160: PPUSH
55161: CALL_OW 325
55165: IFFALSE 55192
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
55167: LD_ADDR_VAR 0 2
55171: PUSH
55172: LD_INT 5
55174: PUSH
55175: LD_INT 8
55177: PUSH
55178: LD_INT 9
55180: PUSH
55181: EMPTY
55182: LIST
55183: LIST
55184: LIST
55185: PUSH
55186: LD_VAR 0 4
55190: ARRAY
55191: ST_TO_ADDR
// end ;
55192: LD_VAR 0 2
55196: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
55197: LD_INT 0
55199: PPUSH
55200: PPUSH
55201: PPUSH
// if not mines then
55202: LD_VAR 0 2
55206: NOT
55207: IFFALSE 55211
// exit ;
55209: GO 55355
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55211: LD_ADDR_VAR 0 5
55215: PUSH
55216: LD_INT 81
55218: PUSH
55219: LD_VAR 0 1
55223: PUSH
55224: EMPTY
55225: LIST
55226: LIST
55227: PUSH
55228: LD_INT 3
55230: PUSH
55231: LD_INT 21
55233: PUSH
55234: LD_INT 3
55236: PUSH
55237: EMPTY
55238: LIST
55239: LIST
55240: PUSH
55241: EMPTY
55242: LIST
55243: LIST
55244: PUSH
55245: EMPTY
55246: LIST
55247: LIST
55248: PPUSH
55249: CALL_OW 69
55253: ST_TO_ADDR
// for i in mines do
55254: LD_ADDR_VAR 0 4
55258: PUSH
55259: LD_VAR 0 2
55263: PUSH
55264: FOR_IN
55265: IFFALSE 55353
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
55267: LD_VAR 0 4
55271: PUSH
55272: LD_INT 1
55274: ARRAY
55275: PPUSH
55276: LD_VAR 0 4
55280: PUSH
55281: LD_INT 2
55283: ARRAY
55284: PPUSH
55285: CALL_OW 458
55289: NOT
55290: IFFALSE 55294
// continue ;
55292: GO 55264
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
55294: LD_VAR 0 4
55298: PUSH
55299: LD_INT 1
55301: ARRAY
55302: PPUSH
55303: LD_VAR 0 4
55307: PUSH
55308: LD_INT 2
55310: ARRAY
55311: PPUSH
55312: CALL_OW 428
55316: PUSH
55317: LD_VAR 0 5
55321: IN
55322: IFFALSE 55351
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
55324: LD_VAR 0 4
55328: PUSH
55329: LD_INT 1
55331: ARRAY
55332: PPUSH
55333: LD_VAR 0 4
55337: PUSH
55338: LD_INT 2
55340: ARRAY
55341: PPUSH
55342: LD_VAR 0 1
55346: PPUSH
55347: CALL_OW 456
// end ;
55351: GO 55264
55353: POP
55354: POP
// end ;
55355: LD_VAR 0 3
55359: RET
// export function Count ( array ) ; begin
55360: LD_INT 0
55362: PPUSH
// result := array + 0 ;
55363: LD_ADDR_VAR 0 2
55367: PUSH
55368: LD_VAR 0 1
55372: PUSH
55373: LD_INT 0
55375: PLUS
55376: ST_TO_ADDR
// end ;
55377: LD_VAR 0 2
55381: RET
// export function IsEmpty ( building ) ; begin
55382: LD_INT 0
55384: PPUSH
// if not building then
55385: LD_VAR 0 1
55389: NOT
55390: IFFALSE 55394
// exit ;
55392: GO 55437
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
55394: LD_ADDR_VAR 0 2
55398: PUSH
55399: LD_VAR 0 1
55403: PUSH
55404: LD_INT 22
55406: PUSH
55407: LD_VAR 0 1
55411: PPUSH
55412: CALL_OW 255
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: PUSH
55421: LD_INT 58
55423: PUSH
55424: EMPTY
55425: LIST
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: PPUSH
55431: CALL_OW 69
55435: IN
55436: ST_TO_ADDR
// end ;
55437: LD_VAR 0 2
55441: RET
// export function IsNotFull ( building ) ; var places ; begin
55442: LD_INT 0
55444: PPUSH
55445: PPUSH
// if not building then
55446: LD_VAR 0 1
55450: NOT
55451: IFFALSE 55455
// exit ;
55453: GO 55483
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
55455: LD_ADDR_VAR 0 2
55459: PUSH
55460: LD_VAR 0 1
55464: PPUSH
55465: LD_INT 3
55467: PUSH
55468: LD_INT 62
55470: PUSH
55471: EMPTY
55472: LIST
55473: PUSH
55474: EMPTY
55475: LIST
55476: LIST
55477: PPUSH
55478: CALL_OW 72
55482: ST_TO_ADDR
// end ;
55483: LD_VAR 0 2
55487: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55488: LD_INT 0
55490: PPUSH
55491: PPUSH
55492: PPUSH
55493: PPUSH
// tmp := [ ] ;
55494: LD_ADDR_VAR 0 3
55498: PUSH
55499: EMPTY
55500: ST_TO_ADDR
// list := [ ] ;
55501: LD_ADDR_VAR 0 5
55505: PUSH
55506: EMPTY
55507: ST_TO_ADDR
// for i = 16 to 25 do
55508: LD_ADDR_VAR 0 4
55512: PUSH
55513: DOUBLE
55514: LD_INT 16
55516: DEC
55517: ST_TO_ADDR
55518: LD_INT 25
55520: PUSH
55521: FOR_TO
55522: IFFALSE 55595
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55524: LD_ADDR_VAR 0 3
55528: PUSH
55529: LD_VAR 0 3
55533: PUSH
55534: LD_INT 22
55536: PUSH
55537: LD_VAR 0 1
55541: PPUSH
55542: CALL_OW 255
55546: PUSH
55547: EMPTY
55548: LIST
55549: LIST
55550: PUSH
55551: LD_INT 91
55553: PUSH
55554: LD_VAR 0 1
55558: PUSH
55559: LD_INT 6
55561: PUSH
55562: EMPTY
55563: LIST
55564: LIST
55565: LIST
55566: PUSH
55567: LD_INT 30
55569: PUSH
55570: LD_VAR 0 4
55574: PUSH
55575: EMPTY
55576: LIST
55577: LIST
55578: PUSH
55579: EMPTY
55580: LIST
55581: LIST
55582: LIST
55583: PUSH
55584: EMPTY
55585: LIST
55586: PPUSH
55587: CALL_OW 69
55591: ADD
55592: ST_TO_ADDR
55593: GO 55521
55595: POP
55596: POP
// for i = 1 to tmp do
55597: LD_ADDR_VAR 0 4
55601: PUSH
55602: DOUBLE
55603: LD_INT 1
55605: DEC
55606: ST_TO_ADDR
55607: LD_VAR 0 3
55611: PUSH
55612: FOR_TO
55613: IFFALSE 55701
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55615: LD_ADDR_VAR 0 5
55619: PUSH
55620: LD_VAR 0 5
55624: PUSH
55625: LD_VAR 0 3
55629: PUSH
55630: LD_VAR 0 4
55634: ARRAY
55635: PPUSH
55636: CALL_OW 266
55640: PUSH
55641: LD_VAR 0 3
55645: PUSH
55646: LD_VAR 0 4
55650: ARRAY
55651: PPUSH
55652: CALL_OW 250
55656: PUSH
55657: LD_VAR 0 3
55661: PUSH
55662: LD_VAR 0 4
55666: ARRAY
55667: PPUSH
55668: CALL_OW 251
55672: PUSH
55673: LD_VAR 0 3
55677: PUSH
55678: LD_VAR 0 4
55682: ARRAY
55683: PPUSH
55684: CALL_OW 254
55688: PUSH
55689: EMPTY
55690: LIST
55691: LIST
55692: LIST
55693: LIST
55694: PUSH
55695: EMPTY
55696: LIST
55697: ADD
55698: ST_TO_ADDR
55699: GO 55612
55701: POP
55702: POP
// result := list ;
55703: LD_ADDR_VAR 0 2
55707: PUSH
55708: LD_VAR 0 5
55712: ST_TO_ADDR
// end ;
55713: LD_VAR 0 2
55717: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55718: LD_INT 0
55720: PPUSH
55721: PPUSH
55722: PPUSH
55723: PPUSH
55724: PPUSH
55725: PPUSH
55726: PPUSH
// if not factory then
55727: LD_VAR 0 1
55731: NOT
55732: IFFALSE 55736
// exit ;
55734: GO 56329
// if control = control_apeman then
55736: LD_VAR 0 4
55740: PUSH
55741: LD_INT 5
55743: EQUAL
55744: IFFALSE 55853
// begin tmp := UnitsInside ( factory ) ;
55746: LD_ADDR_VAR 0 8
55750: PUSH
55751: LD_VAR 0 1
55755: PPUSH
55756: CALL_OW 313
55760: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55761: LD_VAR 0 8
55765: PPUSH
55766: LD_INT 25
55768: PUSH
55769: LD_INT 12
55771: PUSH
55772: EMPTY
55773: LIST
55774: LIST
55775: PPUSH
55776: CALL_OW 72
55780: NOT
55781: IFFALSE 55791
// control := control_manual ;
55783: LD_ADDR_VAR 0 4
55787: PUSH
55788: LD_INT 1
55790: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55791: LD_ADDR_VAR 0 8
55795: PUSH
55796: LD_VAR 0 1
55800: PPUSH
55801: CALL 55488 0 1
55805: ST_TO_ADDR
// if tmp then
55806: LD_VAR 0 8
55810: IFFALSE 55853
// begin for i in tmp do
55812: LD_ADDR_VAR 0 7
55816: PUSH
55817: LD_VAR 0 8
55821: PUSH
55822: FOR_IN
55823: IFFALSE 55851
// if i [ 1 ] = b_ext_radio then
55825: LD_VAR 0 7
55829: PUSH
55830: LD_INT 1
55832: ARRAY
55833: PUSH
55834: LD_INT 22
55836: EQUAL
55837: IFFALSE 55849
// begin control := control_remote ;
55839: LD_ADDR_VAR 0 4
55843: PUSH
55844: LD_INT 2
55846: ST_TO_ADDR
// break ;
55847: GO 55851
// end ;
55849: GO 55822
55851: POP
55852: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55853: LD_VAR 0 1
55857: PPUSH
55858: LD_VAR 0 2
55862: PPUSH
55863: LD_VAR 0 3
55867: PPUSH
55868: LD_VAR 0 4
55872: PPUSH
55873: LD_VAR 0 5
55877: PPUSH
55878: CALL_OW 448
55882: IFFALSE 55917
// begin result := [ chassis , engine , control , weapon ] ;
55884: LD_ADDR_VAR 0 6
55888: PUSH
55889: LD_VAR 0 2
55893: PUSH
55894: LD_VAR 0 3
55898: PUSH
55899: LD_VAR 0 4
55903: PUSH
55904: LD_VAR 0 5
55908: PUSH
55909: EMPTY
55910: LIST
55911: LIST
55912: LIST
55913: LIST
55914: ST_TO_ADDR
// exit ;
55915: GO 56329
// end ; _chassis := AvailableChassisList ( factory ) ;
55917: LD_ADDR_VAR 0 9
55921: PUSH
55922: LD_VAR 0 1
55926: PPUSH
55927: CALL_OW 475
55931: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55932: LD_ADDR_VAR 0 11
55936: PUSH
55937: LD_VAR 0 1
55941: PPUSH
55942: CALL_OW 476
55946: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55947: LD_ADDR_VAR 0 12
55951: PUSH
55952: LD_VAR 0 1
55956: PPUSH
55957: CALL_OW 477
55961: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55962: LD_ADDR_VAR 0 10
55966: PUSH
55967: LD_VAR 0 1
55971: PPUSH
55972: CALL_OW 478
55976: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55977: LD_VAR 0 9
55981: NOT
55982: PUSH
55983: LD_VAR 0 11
55987: NOT
55988: OR
55989: PUSH
55990: LD_VAR 0 12
55994: NOT
55995: OR
55996: PUSH
55997: LD_VAR 0 10
56001: NOT
56002: OR
56003: IFFALSE 56038
// begin result := [ chassis , engine , control , weapon ] ;
56005: LD_ADDR_VAR 0 6
56009: PUSH
56010: LD_VAR 0 2
56014: PUSH
56015: LD_VAR 0 3
56019: PUSH
56020: LD_VAR 0 4
56024: PUSH
56025: LD_VAR 0 5
56029: PUSH
56030: EMPTY
56031: LIST
56032: LIST
56033: LIST
56034: LIST
56035: ST_TO_ADDR
// exit ;
56036: GO 56329
// end ; if not chassis in _chassis then
56038: LD_VAR 0 2
56042: PUSH
56043: LD_VAR 0 9
56047: IN
56048: NOT
56049: IFFALSE 56075
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
56051: LD_ADDR_VAR 0 2
56055: PUSH
56056: LD_VAR 0 9
56060: PUSH
56061: LD_INT 1
56063: PPUSH
56064: LD_VAR 0 9
56068: PPUSH
56069: CALL_OW 12
56073: ARRAY
56074: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
56075: LD_VAR 0 2
56079: PPUSH
56080: LD_VAR 0 3
56084: PPUSH
56085: CALL 56334 0 2
56089: NOT
56090: IFFALSE 56149
// repeat engine := _engine [ 1 ] ;
56092: LD_ADDR_VAR 0 3
56096: PUSH
56097: LD_VAR 0 11
56101: PUSH
56102: LD_INT 1
56104: ARRAY
56105: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
56106: LD_ADDR_VAR 0 11
56110: PUSH
56111: LD_VAR 0 11
56115: PPUSH
56116: LD_INT 1
56118: PPUSH
56119: CALL_OW 3
56123: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
56124: LD_VAR 0 2
56128: PPUSH
56129: LD_VAR 0 3
56133: PPUSH
56134: CALL 56334 0 2
56138: PUSH
56139: LD_VAR 0 11
56143: PUSH
56144: EMPTY
56145: EQUAL
56146: OR
56147: IFFALSE 56092
// if not control in _control then
56149: LD_VAR 0 4
56153: PUSH
56154: LD_VAR 0 12
56158: IN
56159: NOT
56160: IFFALSE 56186
// control := _control [ rand ( 1 , _control ) ] ;
56162: LD_ADDR_VAR 0 4
56166: PUSH
56167: LD_VAR 0 12
56171: PUSH
56172: LD_INT 1
56174: PPUSH
56175: LD_VAR 0 12
56179: PPUSH
56180: CALL_OW 12
56184: ARRAY
56185: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
56186: LD_VAR 0 2
56190: PPUSH
56191: LD_VAR 0 5
56195: PPUSH
56196: CALL 56554 0 2
56200: NOT
56201: IFFALSE 56260
// repeat weapon := _weapon [ 1 ] ;
56203: LD_ADDR_VAR 0 5
56207: PUSH
56208: LD_VAR 0 10
56212: PUSH
56213: LD_INT 1
56215: ARRAY
56216: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
56217: LD_ADDR_VAR 0 10
56221: PUSH
56222: LD_VAR 0 10
56226: PPUSH
56227: LD_INT 1
56229: PPUSH
56230: CALL_OW 3
56234: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
56235: LD_VAR 0 2
56239: PPUSH
56240: LD_VAR 0 5
56244: PPUSH
56245: CALL 56554 0 2
56249: PUSH
56250: LD_VAR 0 10
56254: PUSH
56255: EMPTY
56256: EQUAL
56257: OR
56258: IFFALSE 56203
// result := [ ] ;
56260: LD_ADDR_VAR 0 6
56264: PUSH
56265: EMPTY
56266: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56267: LD_VAR 0 1
56271: PPUSH
56272: LD_VAR 0 2
56276: PPUSH
56277: LD_VAR 0 3
56281: PPUSH
56282: LD_VAR 0 4
56286: PPUSH
56287: LD_VAR 0 5
56291: PPUSH
56292: CALL_OW 448
56296: IFFALSE 56329
// result := [ chassis , engine , control , weapon ] ;
56298: LD_ADDR_VAR 0 6
56302: PUSH
56303: LD_VAR 0 2
56307: PUSH
56308: LD_VAR 0 3
56312: PUSH
56313: LD_VAR 0 4
56317: PUSH
56318: LD_VAR 0 5
56322: PUSH
56323: EMPTY
56324: LIST
56325: LIST
56326: LIST
56327: LIST
56328: ST_TO_ADDR
// end ;
56329: LD_VAR 0 6
56333: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
56334: LD_INT 0
56336: PPUSH
// if not chassis or not engine then
56337: LD_VAR 0 1
56341: NOT
56342: PUSH
56343: LD_VAR 0 2
56347: NOT
56348: OR
56349: IFFALSE 56353
// exit ;
56351: GO 56549
// case engine of engine_solar :
56353: LD_VAR 0 2
56357: PUSH
56358: LD_INT 2
56360: DOUBLE
56361: EQUAL
56362: IFTRUE 56366
56364: GO 56404
56366: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
56367: LD_ADDR_VAR 0 3
56371: PUSH
56372: LD_INT 11
56374: PUSH
56375: LD_INT 12
56377: PUSH
56378: LD_INT 13
56380: PUSH
56381: LD_INT 14
56383: PUSH
56384: LD_INT 1
56386: PUSH
56387: LD_INT 2
56389: PUSH
56390: LD_INT 3
56392: PUSH
56393: EMPTY
56394: LIST
56395: LIST
56396: LIST
56397: LIST
56398: LIST
56399: LIST
56400: LIST
56401: ST_TO_ADDR
56402: GO 56533
56404: LD_INT 1
56406: DOUBLE
56407: EQUAL
56408: IFTRUE 56412
56410: GO 56474
56412: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56413: LD_ADDR_VAR 0 3
56417: PUSH
56418: LD_INT 11
56420: PUSH
56421: LD_INT 12
56423: PUSH
56424: LD_INT 13
56426: PUSH
56427: LD_INT 14
56429: PUSH
56430: LD_INT 1
56432: PUSH
56433: LD_INT 2
56435: PUSH
56436: LD_INT 3
56438: PUSH
56439: LD_INT 4
56441: PUSH
56442: LD_INT 5
56444: PUSH
56445: LD_INT 21
56447: PUSH
56448: LD_INT 23
56450: PUSH
56451: LD_INT 22
56453: PUSH
56454: LD_INT 24
56456: PUSH
56457: EMPTY
56458: LIST
56459: LIST
56460: LIST
56461: LIST
56462: LIST
56463: LIST
56464: LIST
56465: LIST
56466: LIST
56467: LIST
56468: LIST
56469: LIST
56470: LIST
56471: ST_TO_ADDR
56472: GO 56533
56474: LD_INT 3
56476: DOUBLE
56477: EQUAL
56478: IFTRUE 56482
56480: GO 56532
56482: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56483: LD_ADDR_VAR 0 3
56487: PUSH
56488: LD_INT 13
56490: PUSH
56491: LD_INT 14
56493: PUSH
56494: LD_INT 2
56496: PUSH
56497: LD_INT 3
56499: PUSH
56500: LD_INT 4
56502: PUSH
56503: LD_INT 5
56505: PUSH
56506: LD_INT 21
56508: PUSH
56509: LD_INT 22
56511: PUSH
56512: LD_INT 23
56514: PUSH
56515: LD_INT 24
56517: PUSH
56518: EMPTY
56519: LIST
56520: LIST
56521: LIST
56522: LIST
56523: LIST
56524: LIST
56525: LIST
56526: LIST
56527: LIST
56528: LIST
56529: ST_TO_ADDR
56530: GO 56533
56532: POP
// result := ( chassis in result ) ;
56533: LD_ADDR_VAR 0 3
56537: PUSH
56538: LD_VAR 0 1
56542: PUSH
56543: LD_VAR 0 3
56547: IN
56548: ST_TO_ADDR
// end ;
56549: LD_VAR 0 3
56553: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56554: LD_INT 0
56556: PPUSH
// if not chassis or not weapon then
56557: LD_VAR 0 1
56561: NOT
56562: PUSH
56563: LD_VAR 0 2
56567: NOT
56568: OR
56569: IFFALSE 56573
// exit ;
56571: GO 57633
// case weapon of us_machine_gun :
56573: LD_VAR 0 2
56577: PUSH
56578: LD_INT 2
56580: DOUBLE
56581: EQUAL
56582: IFTRUE 56586
56584: GO 56616
56586: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56587: LD_ADDR_VAR 0 3
56591: PUSH
56592: LD_INT 1
56594: PUSH
56595: LD_INT 2
56597: PUSH
56598: LD_INT 3
56600: PUSH
56601: LD_INT 4
56603: PUSH
56604: LD_INT 5
56606: PUSH
56607: EMPTY
56608: LIST
56609: LIST
56610: LIST
56611: LIST
56612: LIST
56613: ST_TO_ADDR
56614: GO 57617
56616: LD_INT 3
56618: DOUBLE
56619: EQUAL
56620: IFTRUE 56624
56622: GO 56654
56624: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56625: LD_ADDR_VAR 0 3
56629: PUSH
56630: LD_INT 1
56632: PUSH
56633: LD_INT 2
56635: PUSH
56636: LD_INT 3
56638: PUSH
56639: LD_INT 4
56641: PUSH
56642: LD_INT 5
56644: PUSH
56645: EMPTY
56646: LIST
56647: LIST
56648: LIST
56649: LIST
56650: LIST
56651: ST_TO_ADDR
56652: GO 57617
56654: LD_INT 11
56656: DOUBLE
56657: EQUAL
56658: IFTRUE 56662
56660: GO 56692
56662: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56663: LD_ADDR_VAR 0 3
56667: PUSH
56668: LD_INT 1
56670: PUSH
56671: LD_INT 2
56673: PUSH
56674: LD_INT 3
56676: PUSH
56677: LD_INT 4
56679: PUSH
56680: LD_INT 5
56682: PUSH
56683: EMPTY
56684: LIST
56685: LIST
56686: LIST
56687: LIST
56688: LIST
56689: ST_TO_ADDR
56690: GO 57617
56692: LD_INT 4
56694: DOUBLE
56695: EQUAL
56696: IFTRUE 56700
56698: GO 56726
56700: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56701: LD_ADDR_VAR 0 3
56705: PUSH
56706: LD_INT 2
56708: PUSH
56709: LD_INT 3
56711: PUSH
56712: LD_INT 4
56714: PUSH
56715: LD_INT 5
56717: PUSH
56718: EMPTY
56719: LIST
56720: LIST
56721: LIST
56722: LIST
56723: ST_TO_ADDR
56724: GO 57617
56726: LD_INT 5
56728: DOUBLE
56729: EQUAL
56730: IFTRUE 56734
56732: GO 56760
56734: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56735: LD_ADDR_VAR 0 3
56739: PUSH
56740: LD_INT 2
56742: PUSH
56743: LD_INT 3
56745: PUSH
56746: LD_INT 4
56748: PUSH
56749: LD_INT 5
56751: PUSH
56752: EMPTY
56753: LIST
56754: LIST
56755: LIST
56756: LIST
56757: ST_TO_ADDR
56758: GO 57617
56760: LD_INT 9
56762: DOUBLE
56763: EQUAL
56764: IFTRUE 56768
56766: GO 56794
56768: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56769: LD_ADDR_VAR 0 3
56773: PUSH
56774: LD_INT 2
56776: PUSH
56777: LD_INT 3
56779: PUSH
56780: LD_INT 4
56782: PUSH
56783: LD_INT 5
56785: PUSH
56786: EMPTY
56787: LIST
56788: LIST
56789: LIST
56790: LIST
56791: ST_TO_ADDR
56792: GO 57617
56794: LD_INT 7
56796: DOUBLE
56797: EQUAL
56798: IFTRUE 56802
56800: GO 56828
56802: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56803: LD_ADDR_VAR 0 3
56807: PUSH
56808: LD_INT 2
56810: PUSH
56811: LD_INT 3
56813: PUSH
56814: LD_INT 4
56816: PUSH
56817: LD_INT 5
56819: PUSH
56820: EMPTY
56821: LIST
56822: LIST
56823: LIST
56824: LIST
56825: ST_TO_ADDR
56826: GO 57617
56828: LD_INT 12
56830: DOUBLE
56831: EQUAL
56832: IFTRUE 56836
56834: GO 56862
56836: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56837: LD_ADDR_VAR 0 3
56841: PUSH
56842: LD_INT 2
56844: PUSH
56845: LD_INT 3
56847: PUSH
56848: LD_INT 4
56850: PUSH
56851: LD_INT 5
56853: PUSH
56854: EMPTY
56855: LIST
56856: LIST
56857: LIST
56858: LIST
56859: ST_TO_ADDR
56860: GO 57617
56862: LD_INT 13
56864: DOUBLE
56865: EQUAL
56866: IFTRUE 56870
56868: GO 56896
56870: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56871: LD_ADDR_VAR 0 3
56875: PUSH
56876: LD_INT 2
56878: PUSH
56879: LD_INT 3
56881: PUSH
56882: LD_INT 4
56884: PUSH
56885: LD_INT 5
56887: PUSH
56888: EMPTY
56889: LIST
56890: LIST
56891: LIST
56892: LIST
56893: ST_TO_ADDR
56894: GO 57617
56896: LD_INT 14
56898: DOUBLE
56899: EQUAL
56900: IFTRUE 56904
56902: GO 56922
56904: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56905: LD_ADDR_VAR 0 3
56909: PUSH
56910: LD_INT 4
56912: PUSH
56913: LD_INT 5
56915: PUSH
56916: EMPTY
56917: LIST
56918: LIST
56919: ST_TO_ADDR
56920: GO 57617
56922: LD_INT 6
56924: DOUBLE
56925: EQUAL
56926: IFTRUE 56930
56928: GO 56948
56930: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56931: LD_ADDR_VAR 0 3
56935: PUSH
56936: LD_INT 4
56938: PUSH
56939: LD_INT 5
56941: PUSH
56942: EMPTY
56943: LIST
56944: LIST
56945: ST_TO_ADDR
56946: GO 57617
56948: LD_INT 10
56950: DOUBLE
56951: EQUAL
56952: IFTRUE 56956
56954: GO 56974
56956: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56957: LD_ADDR_VAR 0 3
56961: PUSH
56962: LD_INT 4
56964: PUSH
56965: LD_INT 5
56967: PUSH
56968: EMPTY
56969: LIST
56970: LIST
56971: ST_TO_ADDR
56972: GO 57617
56974: LD_INT 22
56976: DOUBLE
56977: EQUAL
56978: IFTRUE 56982
56980: GO 57008
56982: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56983: LD_ADDR_VAR 0 3
56987: PUSH
56988: LD_INT 11
56990: PUSH
56991: LD_INT 12
56993: PUSH
56994: LD_INT 13
56996: PUSH
56997: LD_INT 14
56999: PUSH
57000: EMPTY
57001: LIST
57002: LIST
57003: LIST
57004: LIST
57005: ST_TO_ADDR
57006: GO 57617
57008: LD_INT 23
57010: DOUBLE
57011: EQUAL
57012: IFTRUE 57016
57014: GO 57042
57016: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
57017: LD_ADDR_VAR 0 3
57021: PUSH
57022: LD_INT 11
57024: PUSH
57025: LD_INT 12
57027: PUSH
57028: LD_INT 13
57030: PUSH
57031: LD_INT 14
57033: PUSH
57034: EMPTY
57035: LIST
57036: LIST
57037: LIST
57038: LIST
57039: ST_TO_ADDR
57040: GO 57617
57042: LD_INT 24
57044: DOUBLE
57045: EQUAL
57046: IFTRUE 57050
57048: GO 57076
57050: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
57051: LD_ADDR_VAR 0 3
57055: PUSH
57056: LD_INT 11
57058: PUSH
57059: LD_INT 12
57061: PUSH
57062: LD_INT 13
57064: PUSH
57065: LD_INT 14
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: LIST
57072: LIST
57073: ST_TO_ADDR
57074: GO 57617
57076: LD_INT 30
57078: DOUBLE
57079: EQUAL
57080: IFTRUE 57084
57082: GO 57110
57084: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
57085: LD_ADDR_VAR 0 3
57089: PUSH
57090: LD_INT 11
57092: PUSH
57093: LD_INT 12
57095: PUSH
57096: LD_INT 13
57098: PUSH
57099: LD_INT 14
57101: PUSH
57102: EMPTY
57103: LIST
57104: LIST
57105: LIST
57106: LIST
57107: ST_TO_ADDR
57108: GO 57617
57110: LD_INT 25
57112: DOUBLE
57113: EQUAL
57114: IFTRUE 57118
57116: GO 57136
57118: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
57119: LD_ADDR_VAR 0 3
57123: PUSH
57124: LD_INT 13
57126: PUSH
57127: LD_INT 14
57129: PUSH
57130: EMPTY
57131: LIST
57132: LIST
57133: ST_TO_ADDR
57134: GO 57617
57136: LD_INT 27
57138: DOUBLE
57139: EQUAL
57140: IFTRUE 57144
57142: GO 57162
57144: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
57145: LD_ADDR_VAR 0 3
57149: PUSH
57150: LD_INT 13
57152: PUSH
57153: LD_INT 14
57155: PUSH
57156: EMPTY
57157: LIST
57158: LIST
57159: ST_TO_ADDR
57160: GO 57617
57162: LD_INT 92
57164: DOUBLE
57165: EQUAL
57166: IFTRUE 57170
57168: GO 57196
57170: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
57171: LD_ADDR_VAR 0 3
57175: PUSH
57176: LD_INT 11
57178: PUSH
57179: LD_INT 12
57181: PUSH
57182: LD_INT 13
57184: PUSH
57185: LD_INT 14
57187: PUSH
57188: EMPTY
57189: LIST
57190: LIST
57191: LIST
57192: LIST
57193: ST_TO_ADDR
57194: GO 57617
57196: LD_INT 28
57198: DOUBLE
57199: EQUAL
57200: IFTRUE 57204
57202: GO 57222
57204: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
57205: LD_ADDR_VAR 0 3
57209: PUSH
57210: LD_INT 13
57212: PUSH
57213: LD_INT 14
57215: PUSH
57216: EMPTY
57217: LIST
57218: LIST
57219: ST_TO_ADDR
57220: GO 57617
57222: LD_INT 29
57224: DOUBLE
57225: EQUAL
57226: IFTRUE 57230
57228: GO 57248
57230: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
57231: LD_ADDR_VAR 0 3
57235: PUSH
57236: LD_INT 13
57238: PUSH
57239: LD_INT 14
57241: PUSH
57242: EMPTY
57243: LIST
57244: LIST
57245: ST_TO_ADDR
57246: GO 57617
57248: LD_INT 31
57250: DOUBLE
57251: EQUAL
57252: IFTRUE 57256
57254: GO 57274
57256: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
57257: LD_ADDR_VAR 0 3
57261: PUSH
57262: LD_INT 13
57264: PUSH
57265: LD_INT 14
57267: PUSH
57268: EMPTY
57269: LIST
57270: LIST
57271: ST_TO_ADDR
57272: GO 57617
57274: LD_INT 26
57276: DOUBLE
57277: EQUAL
57278: IFTRUE 57282
57280: GO 57300
57282: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
57283: LD_ADDR_VAR 0 3
57287: PUSH
57288: LD_INT 13
57290: PUSH
57291: LD_INT 14
57293: PUSH
57294: EMPTY
57295: LIST
57296: LIST
57297: ST_TO_ADDR
57298: GO 57617
57300: LD_INT 42
57302: DOUBLE
57303: EQUAL
57304: IFTRUE 57308
57306: GO 57334
57308: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
57309: LD_ADDR_VAR 0 3
57313: PUSH
57314: LD_INT 21
57316: PUSH
57317: LD_INT 22
57319: PUSH
57320: LD_INT 23
57322: PUSH
57323: LD_INT 24
57325: PUSH
57326: EMPTY
57327: LIST
57328: LIST
57329: LIST
57330: LIST
57331: ST_TO_ADDR
57332: GO 57617
57334: LD_INT 43
57336: DOUBLE
57337: EQUAL
57338: IFTRUE 57342
57340: GO 57368
57342: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
57343: LD_ADDR_VAR 0 3
57347: PUSH
57348: LD_INT 21
57350: PUSH
57351: LD_INT 22
57353: PUSH
57354: LD_INT 23
57356: PUSH
57357: LD_INT 24
57359: PUSH
57360: EMPTY
57361: LIST
57362: LIST
57363: LIST
57364: LIST
57365: ST_TO_ADDR
57366: GO 57617
57368: LD_INT 44
57370: DOUBLE
57371: EQUAL
57372: IFTRUE 57376
57374: GO 57402
57376: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
57377: LD_ADDR_VAR 0 3
57381: PUSH
57382: LD_INT 21
57384: PUSH
57385: LD_INT 22
57387: PUSH
57388: LD_INT 23
57390: PUSH
57391: LD_INT 24
57393: PUSH
57394: EMPTY
57395: LIST
57396: LIST
57397: LIST
57398: LIST
57399: ST_TO_ADDR
57400: GO 57617
57402: LD_INT 45
57404: DOUBLE
57405: EQUAL
57406: IFTRUE 57410
57408: GO 57436
57410: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57411: LD_ADDR_VAR 0 3
57415: PUSH
57416: LD_INT 21
57418: PUSH
57419: LD_INT 22
57421: PUSH
57422: LD_INT 23
57424: PUSH
57425: LD_INT 24
57427: PUSH
57428: EMPTY
57429: LIST
57430: LIST
57431: LIST
57432: LIST
57433: ST_TO_ADDR
57434: GO 57617
57436: LD_INT 49
57438: DOUBLE
57439: EQUAL
57440: IFTRUE 57444
57442: GO 57470
57444: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57445: LD_ADDR_VAR 0 3
57449: PUSH
57450: LD_INT 21
57452: PUSH
57453: LD_INT 22
57455: PUSH
57456: LD_INT 23
57458: PUSH
57459: LD_INT 24
57461: PUSH
57462: EMPTY
57463: LIST
57464: LIST
57465: LIST
57466: LIST
57467: ST_TO_ADDR
57468: GO 57617
57470: LD_INT 51
57472: DOUBLE
57473: EQUAL
57474: IFTRUE 57478
57476: GO 57504
57478: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57479: LD_ADDR_VAR 0 3
57483: PUSH
57484: LD_INT 21
57486: PUSH
57487: LD_INT 22
57489: PUSH
57490: LD_INT 23
57492: PUSH
57493: LD_INT 24
57495: PUSH
57496: EMPTY
57497: LIST
57498: LIST
57499: LIST
57500: LIST
57501: ST_TO_ADDR
57502: GO 57617
57504: LD_INT 52
57506: DOUBLE
57507: EQUAL
57508: IFTRUE 57512
57510: GO 57538
57512: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57513: LD_ADDR_VAR 0 3
57517: PUSH
57518: LD_INT 21
57520: PUSH
57521: LD_INT 22
57523: PUSH
57524: LD_INT 23
57526: PUSH
57527: LD_INT 24
57529: PUSH
57530: EMPTY
57531: LIST
57532: LIST
57533: LIST
57534: LIST
57535: ST_TO_ADDR
57536: GO 57617
57538: LD_INT 53
57540: DOUBLE
57541: EQUAL
57542: IFTRUE 57546
57544: GO 57564
57546: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57547: LD_ADDR_VAR 0 3
57551: PUSH
57552: LD_INT 23
57554: PUSH
57555: LD_INT 24
57557: PUSH
57558: EMPTY
57559: LIST
57560: LIST
57561: ST_TO_ADDR
57562: GO 57617
57564: LD_INT 46
57566: DOUBLE
57567: EQUAL
57568: IFTRUE 57572
57570: GO 57590
57572: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57573: LD_ADDR_VAR 0 3
57577: PUSH
57578: LD_INT 23
57580: PUSH
57581: LD_INT 24
57583: PUSH
57584: EMPTY
57585: LIST
57586: LIST
57587: ST_TO_ADDR
57588: GO 57617
57590: LD_INT 47
57592: DOUBLE
57593: EQUAL
57594: IFTRUE 57598
57596: GO 57616
57598: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57599: LD_ADDR_VAR 0 3
57603: PUSH
57604: LD_INT 23
57606: PUSH
57607: LD_INT 24
57609: PUSH
57610: EMPTY
57611: LIST
57612: LIST
57613: ST_TO_ADDR
57614: GO 57617
57616: POP
// result := ( chassis in result ) ;
57617: LD_ADDR_VAR 0 3
57621: PUSH
57622: LD_VAR 0 1
57626: PUSH
57627: LD_VAR 0 3
57631: IN
57632: ST_TO_ADDR
// end ;
57633: LD_VAR 0 3
57637: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57638: LD_INT 0
57640: PPUSH
57641: PPUSH
57642: PPUSH
57643: PPUSH
57644: PPUSH
57645: PPUSH
57646: PPUSH
// result := array ;
57647: LD_ADDR_VAR 0 5
57651: PUSH
57652: LD_VAR 0 1
57656: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57657: LD_VAR 0 1
57661: NOT
57662: PUSH
57663: LD_VAR 0 2
57667: NOT
57668: OR
57669: PUSH
57670: LD_VAR 0 3
57674: NOT
57675: OR
57676: PUSH
57677: LD_VAR 0 2
57681: PUSH
57682: LD_VAR 0 1
57686: GREATER
57687: OR
57688: PUSH
57689: LD_VAR 0 3
57693: PUSH
57694: LD_VAR 0 1
57698: GREATER
57699: OR
57700: IFFALSE 57704
// exit ;
57702: GO 58000
// if direction then
57704: LD_VAR 0 4
57708: IFFALSE 57772
// begin d := 1 ;
57710: LD_ADDR_VAR 0 9
57714: PUSH
57715: LD_INT 1
57717: ST_TO_ADDR
// if i_from > i_to then
57718: LD_VAR 0 2
57722: PUSH
57723: LD_VAR 0 3
57727: GREATER
57728: IFFALSE 57754
// length := ( array - i_from ) + i_to else
57730: LD_ADDR_VAR 0 11
57734: PUSH
57735: LD_VAR 0 1
57739: PUSH
57740: LD_VAR 0 2
57744: MINUS
57745: PUSH
57746: LD_VAR 0 3
57750: PLUS
57751: ST_TO_ADDR
57752: GO 57770
// length := i_to - i_from ;
57754: LD_ADDR_VAR 0 11
57758: PUSH
57759: LD_VAR 0 3
57763: PUSH
57764: LD_VAR 0 2
57768: MINUS
57769: ST_TO_ADDR
// end else
57770: GO 57833
// begin d := - 1 ;
57772: LD_ADDR_VAR 0 9
57776: PUSH
57777: LD_INT 1
57779: NEG
57780: ST_TO_ADDR
// if i_from > i_to then
57781: LD_VAR 0 2
57785: PUSH
57786: LD_VAR 0 3
57790: GREATER
57791: IFFALSE 57811
// length := i_from - i_to else
57793: LD_ADDR_VAR 0 11
57797: PUSH
57798: LD_VAR 0 2
57802: PUSH
57803: LD_VAR 0 3
57807: MINUS
57808: ST_TO_ADDR
57809: GO 57833
// length := ( array - i_to ) + i_from ;
57811: LD_ADDR_VAR 0 11
57815: PUSH
57816: LD_VAR 0 1
57820: PUSH
57821: LD_VAR 0 3
57825: MINUS
57826: PUSH
57827: LD_VAR 0 2
57831: PLUS
57832: ST_TO_ADDR
// end ; if not length then
57833: LD_VAR 0 11
57837: NOT
57838: IFFALSE 57842
// exit ;
57840: GO 58000
// tmp := array ;
57842: LD_ADDR_VAR 0 10
57846: PUSH
57847: LD_VAR 0 1
57851: ST_TO_ADDR
// for i = 1 to length do
57852: LD_ADDR_VAR 0 6
57856: PUSH
57857: DOUBLE
57858: LD_INT 1
57860: DEC
57861: ST_TO_ADDR
57862: LD_VAR 0 11
57866: PUSH
57867: FOR_TO
57868: IFFALSE 57988
// begin for j = 1 to array do
57870: LD_ADDR_VAR 0 7
57874: PUSH
57875: DOUBLE
57876: LD_INT 1
57878: DEC
57879: ST_TO_ADDR
57880: LD_VAR 0 1
57884: PUSH
57885: FOR_TO
57886: IFFALSE 57974
// begin k := j + d ;
57888: LD_ADDR_VAR 0 8
57892: PUSH
57893: LD_VAR 0 7
57897: PUSH
57898: LD_VAR 0 9
57902: PLUS
57903: ST_TO_ADDR
// if k > array then
57904: LD_VAR 0 8
57908: PUSH
57909: LD_VAR 0 1
57913: GREATER
57914: IFFALSE 57924
// k := 1 ;
57916: LD_ADDR_VAR 0 8
57920: PUSH
57921: LD_INT 1
57923: ST_TO_ADDR
// if not k then
57924: LD_VAR 0 8
57928: NOT
57929: IFFALSE 57941
// k := array ;
57931: LD_ADDR_VAR 0 8
57935: PUSH
57936: LD_VAR 0 1
57940: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57941: LD_ADDR_VAR 0 10
57945: PUSH
57946: LD_VAR 0 10
57950: PPUSH
57951: LD_VAR 0 8
57955: PPUSH
57956: LD_VAR 0 1
57960: PUSH
57961: LD_VAR 0 7
57965: ARRAY
57966: PPUSH
57967: CALL_OW 1
57971: ST_TO_ADDR
// end ;
57972: GO 57885
57974: POP
57975: POP
// array := tmp ;
57976: LD_ADDR_VAR 0 1
57980: PUSH
57981: LD_VAR 0 10
57985: ST_TO_ADDR
// end ;
57986: GO 57867
57988: POP
57989: POP
// result := array ;
57990: LD_ADDR_VAR 0 5
57994: PUSH
57995: LD_VAR 0 1
57999: ST_TO_ADDR
// end ;
58000: LD_VAR 0 5
58004: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
58005: LD_INT 0
58007: PPUSH
58008: PPUSH
// result := 0 ;
58009: LD_ADDR_VAR 0 3
58013: PUSH
58014: LD_INT 0
58016: ST_TO_ADDR
// if not array or not value in array then
58017: LD_VAR 0 1
58021: NOT
58022: PUSH
58023: LD_VAR 0 2
58027: PUSH
58028: LD_VAR 0 1
58032: IN
58033: NOT
58034: OR
58035: IFFALSE 58039
// exit ;
58037: GO 58093
// for i = 1 to array do
58039: LD_ADDR_VAR 0 4
58043: PUSH
58044: DOUBLE
58045: LD_INT 1
58047: DEC
58048: ST_TO_ADDR
58049: LD_VAR 0 1
58053: PUSH
58054: FOR_TO
58055: IFFALSE 58091
// if value = array [ i ] then
58057: LD_VAR 0 2
58061: PUSH
58062: LD_VAR 0 1
58066: PUSH
58067: LD_VAR 0 4
58071: ARRAY
58072: EQUAL
58073: IFFALSE 58089
// begin result := i ;
58075: LD_ADDR_VAR 0 3
58079: PUSH
58080: LD_VAR 0 4
58084: ST_TO_ADDR
// exit ;
58085: POP
58086: POP
58087: GO 58093
// end ;
58089: GO 58054
58091: POP
58092: POP
// end ;
58093: LD_VAR 0 3
58097: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
58098: LD_INT 0
58100: PPUSH
// vc_chassis := chassis ;
58101: LD_ADDR_OWVAR 37
58105: PUSH
58106: LD_VAR 0 1
58110: ST_TO_ADDR
// vc_engine := engine ;
58111: LD_ADDR_OWVAR 39
58115: PUSH
58116: LD_VAR 0 2
58120: ST_TO_ADDR
// vc_control := control ;
58121: LD_ADDR_OWVAR 38
58125: PUSH
58126: LD_VAR 0 3
58130: ST_TO_ADDR
// vc_weapon := weapon ;
58131: LD_ADDR_OWVAR 40
58135: PUSH
58136: LD_VAR 0 4
58140: ST_TO_ADDR
// vc_fuel_battery := fuel ;
58141: LD_ADDR_OWVAR 41
58145: PUSH
58146: LD_VAR 0 5
58150: ST_TO_ADDR
// end ;
58151: LD_VAR 0 6
58155: RET
// export function WantPlant ( unit ) ; var task ; begin
58156: LD_INT 0
58158: PPUSH
58159: PPUSH
// result := false ;
58160: LD_ADDR_VAR 0 2
58164: PUSH
58165: LD_INT 0
58167: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
58168: LD_ADDR_VAR 0 3
58172: PUSH
58173: LD_VAR 0 1
58177: PPUSH
58178: CALL_OW 437
58182: ST_TO_ADDR
// if task then
58183: LD_VAR 0 3
58187: IFFALSE 58215
// if task [ 1 ] [ 1 ] = p then
58189: LD_VAR 0 3
58193: PUSH
58194: LD_INT 1
58196: ARRAY
58197: PUSH
58198: LD_INT 1
58200: ARRAY
58201: PUSH
58202: LD_STRING p
58204: EQUAL
58205: IFFALSE 58215
// result := true ;
58207: LD_ADDR_VAR 0 2
58211: PUSH
58212: LD_INT 1
58214: ST_TO_ADDR
// end ;
58215: LD_VAR 0 2
58219: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
58220: LD_INT 0
58222: PPUSH
58223: PPUSH
58224: PPUSH
58225: PPUSH
// if pos < 1 then
58226: LD_VAR 0 2
58230: PUSH
58231: LD_INT 1
58233: LESS
58234: IFFALSE 58238
// exit ;
58236: GO 58541
// if pos = 1 then
58238: LD_VAR 0 2
58242: PUSH
58243: LD_INT 1
58245: EQUAL
58246: IFFALSE 58279
// result := Replace ( arr , pos [ 1 ] , value ) else
58248: LD_ADDR_VAR 0 4
58252: PUSH
58253: LD_VAR 0 1
58257: PPUSH
58258: LD_VAR 0 2
58262: PUSH
58263: LD_INT 1
58265: ARRAY
58266: PPUSH
58267: LD_VAR 0 3
58271: PPUSH
58272: CALL_OW 1
58276: ST_TO_ADDR
58277: GO 58541
// begin tmp := arr ;
58279: LD_ADDR_VAR 0 6
58283: PUSH
58284: LD_VAR 0 1
58288: ST_TO_ADDR
// s_arr := [ tmp ] ;
58289: LD_ADDR_VAR 0 7
58293: PUSH
58294: LD_VAR 0 6
58298: PUSH
58299: EMPTY
58300: LIST
58301: ST_TO_ADDR
// for i = 1 to pos - 1 do
58302: LD_ADDR_VAR 0 5
58306: PUSH
58307: DOUBLE
58308: LD_INT 1
58310: DEC
58311: ST_TO_ADDR
58312: LD_VAR 0 2
58316: PUSH
58317: LD_INT 1
58319: MINUS
58320: PUSH
58321: FOR_TO
58322: IFFALSE 58367
// begin tmp := tmp [ pos [ i ] ] ;
58324: LD_ADDR_VAR 0 6
58328: PUSH
58329: LD_VAR 0 6
58333: PUSH
58334: LD_VAR 0 2
58338: PUSH
58339: LD_VAR 0 5
58343: ARRAY
58344: ARRAY
58345: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
58346: LD_ADDR_VAR 0 7
58350: PUSH
58351: LD_VAR 0 7
58355: PUSH
58356: LD_VAR 0 6
58360: PUSH
58361: EMPTY
58362: LIST
58363: ADD
58364: ST_TO_ADDR
// end ;
58365: GO 58321
58367: POP
58368: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
58369: LD_ADDR_VAR 0 6
58373: PUSH
58374: LD_VAR 0 6
58378: PPUSH
58379: LD_VAR 0 2
58383: PUSH
58384: LD_VAR 0 2
58388: ARRAY
58389: PPUSH
58390: LD_VAR 0 3
58394: PPUSH
58395: CALL_OW 1
58399: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
58400: LD_ADDR_VAR 0 7
58404: PUSH
58405: LD_VAR 0 7
58409: PPUSH
58410: LD_VAR 0 7
58414: PPUSH
58415: LD_VAR 0 6
58419: PPUSH
58420: CALL_OW 1
58424: ST_TO_ADDR
// for i = s_arr downto 2 do
58425: LD_ADDR_VAR 0 5
58429: PUSH
58430: DOUBLE
58431: LD_VAR 0 7
58435: INC
58436: ST_TO_ADDR
58437: LD_INT 2
58439: PUSH
58440: FOR_DOWNTO
58441: IFFALSE 58525
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58443: LD_ADDR_VAR 0 6
58447: PUSH
58448: LD_VAR 0 7
58452: PUSH
58453: LD_VAR 0 5
58457: PUSH
58458: LD_INT 1
58460: MINUS
58461: ARRAY
58462: PPUSH
58463: LD_VAR 0 2
58467: PUSH
58468: LD_VAR 0 5
58472: PUSH
58473: LD_INT 1
58475: MINUS
58476: ARRAY
58477: PPUSH
58478: LD_VAR 0 7
58482: PUSH
58483: LD_VAR 0 5
58487: ARRAY
58488: PPUSH
58489: CALL_OW 1
58493: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58494: LD_ADDR_VAR 0 7
58498: PUSH
58499: LD_VAR 0 7
58503: PPUSH
58504: LD_VAR 0 5
58508: PUSH
58509: LD_INT 1
58511: MINUS
58512: PPUSH
58513: LD_VAR 0 6
58517: PPUSH
58518: CALL_OW 1
58522: ST_TO_ADDR
// end ;
58523: GO 58440
58525: POP
58526: POP
// result := s_arr [ 1 ] ;
58527: LD_ADDR_VAR 0 4
58531: PUSH
58532: LD_VAR 0 7
58536: PUSH
58537: LD_INT 1
58539: ARRAY
58540: ST_TO_ADDR
// end ; end ;
58541: LD_VAR 0 4
58545: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58546: LD_INT 0
58548: PPUSH
58549: PPUSH
// if not list then
58550: LD_VAR 0 1
58554: NOT
58555: IFFALSE 58559
// exit ;
58557: GO 58650
// i := list [ pos1 ] ;
58559: LD_ADDR_VAR 0 5
58563: PUSH
58564: LD_VAR 0 1
58568: PUSH
58569: LD_VAR 0 2
58573: ARRAY
58574: ST_TO_ADDR
// if not i then
58575: LD_VAR 0 5
58579: NOT
58580: IFFALSE 58584
// exit ;
58582: GO 58650
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58584: LD_ADDR_VAR 0 1
58588: PUSH
58589: LD_VAR 0 1
58593: PPUSH
58594: LD_VAR 0 2
58598: PPUSH
58599: LD_VAR 0 1
58603: PUSH
58604: LD_VAR 0 3
58608: ARRAY
58609: PPUSH
58610: CALL_OW 1
58614: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58615: LD_ADDR_VAR 0 1
58619: PUSH
58620: LD_VAR 0 1
58624: PPUSH
58625: LD_VAR 0 3
58629: PPUSH
58630: LD_VAR 0 5
58634: PPUSH
58635: CALL_OW 1
58639: ST_TO_ADDR
// result := list ;
58640: LD_ADDR_VAR 0 4
58644: PUSH
58645: LD_VAR 0 1
58649: ST_TO_ADDR
// end ;
58650: LD_VAR 0 4
58654: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58655: LD_INT 0
58657: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58658: LD_ADDR_VAR 0 5
58662: PUSH
58663: LD_VAR 0 1
58667: PPUSH
58668: CALL_OW 250
58672: PPUSH
58673: LD_VAR 0 1
58677: PPUSH
58678: CALL_OW 251
58682: PPUSH
58683: LD_VAR 0 2
58687: PPUSH
58688: LD_VAR 0 3
58692: PPUSH
58693: LD_VAR 0 4
58697: PPUSH
58698: CALL 59076 0 5
58702: ST_TO_ADDR
// end ;
58703: LD_VAR 0 5
58707: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
58708: LD_INT 0
58710: PPUSH
58711: PPUSH
58712: PPUSH
58713: PPUSH
// if not list or not unit then
58714: LD_VAR 0 2
58718: NOT
58719: PUSH
58720: LD_VAR 0 1
58724: NOT
58725: OR
58726: IFFALSE 58730
// exit ;
58728: GO 59071
// result := [ ] ;
58730: LD_ADDR_VAR 0 5
58734: PUSH
58735: EMPTY
58736: ST_TO_ADDR
// for i in list do
58737: LD_ADDR_VAR 0 6
58741: PUSH
58742: LD_VAR 0 2
58746: PUSH
58747: FOR_IN
58748: IFFALSE 58966
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
58750: LD_ADDR_VAR 0 8
58754: PUSH
58755: LD_VAR 0 1
58759: PPUSH
58760: LD_VAR 0 6
58764: PUSH
58765: LD_INT 1
58767: ARRAY
58768: PPUSH
58769: LD_VAR 0 6
58773: PUSH
58774: LD_INT 2
58776: ARRAY
58777: PPUSH
58778: CALL_OW 297
58782: ST_TO_ADDR
// if not Count ( result ) then
58783: LD_VAR 0 5
58787: PPUSH
58788: CALL 55360 0 1
58792: NOT
58793: IFFALSE 58826
// begin result := Join ( result , [ i , tmp ] ) ;
58795: LD_ADDR_VAR 0 5
58799: PUSH
58800: LD_VAR 0 5
58804: PPUSH
58805: LD_VAR 0 6
58809: PUSH
58810: LD_VAR 0 8
58814: PUSH
58815: EMPTY
58816: LIST
58817: LIST
58818: PPUSH
58819: CALL 90960 0 2
58823: ST_TO_ADDR
// continue ;
58824: GO 58747
// end ; if result [ result ] [ 2 ] <= tmp then
58826: LD_VAR 0 5
58830: PUSH
58831: LD_VAR 0 5
58835: ARRAY
58836: PUSH
58837: LD_INT 2
58839: ARRAY
58840: PUSH
58841: LD_VAR 0 8
58845: LESSEQUAL
58846: IFFALSE 58879
// result := Join ( result , [ i , tmp ] ) else
58848: LD_ADDR_VAR 0 5
58852: PUSH
58853: LD_VAR 0 5
58857: PPUSH
58858: LD_VAR 0 6
58862: PUSH
58863: LD_VAR 0 8
58867: PUSH
58868: EMPTY
58869: LIST
58870: LIST
58871: PPUSH
58872: CALL 90960 0 2
58876: ST_TO_ADDR
58877: GO 58964
// begin for j := 1 to Count ( result ) do
58879: LD_ADDR_VAR 0 7
58883: PUSH
58884: DOUBLE
58885: LD_INT 1
58887: DEC
58888: ST_TO_ADDR
58889: LD_VAR 0 5
58893: PPUSH
58894: CALL 55360 0 1
58898: PUSH
58899: FOR_TO
58900: IFFALSE 58962
// begin if tmp < result [ j ] [ 2 ] then
58902: LD_VAR 0 8
58906: PUSH
58907: LD_VAR 0 5
58911: PUSH
58912: LD_VAR 0 7
58916: ARRAY
58917: PUSH
58918: LD_INT 2
58920: ARRAY
58921: LESS
58922: IFFALSE 58960
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58924: LD_ADDR_VAR 0 5
58928: PUSH
58929: LD_VAR 0 5
58933: PPUSH
58934: LD_VAR 0 7
58938: PPUSH
58939: LD_VAR 0 6
58943: PUSH
58944: LD_VAR 0 8
58948: PUSH
58949: EMPTY
58950: LIST
58951: LIST
58952: PPUSH
58953: CALL_OW 2
58957: ST_TO_ADDR
// break ;
58958: GO 58962
// end ; end ;
58960: GO 58899
58962: POP
58963: POP
// end ; end ;
58964: GO 58747
58966: POP
58967: POP
// if result and not asc then
58968: LD_VAR 0 5
58972: PUSH
58973: LD_VAR 0 3
58977: NOT
58978: AND
58979: IFFALSE 58996
// result := ReverseArray ( result ) ;
58981: LD_ADDR_VAR 0 5
58985: PUSH
58986: LD_VAR 0 5
58990: PPUSH
58991: CALL 86236 0 1
58995: ST_TO_ADDR
// tmp := [ ] ;
58996: LD_ADDR_VAR 0 8
59000: PUSH
59001: EMPTY
59002: ST_TO_ADDR
// if mode then
59003: LD_VAR 0 4
59007: IFFALSE 59071
// begin for i := 1 to result do
59009: LD_ADDR_VAR 0 6
59013: PUSH
59014: DOUBLE
59015: LD_INT 1
59017: DEC
59018: ST_TO_ADDR
59019: LD_VAR 0 5
59023: PUSH
59024: FOR_TO
59025: IFFALSE 59059
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
59027: LD_ADDR_VAR 0 8
59031: PUSH
59032: LD_VAR 0 8
59036: PPUSH
59037: LD_VAR 0 5
59041: PUSH
59042: LD_VAR 0 6
59046: ARRAY
59047: PUSH
59048: LD_INT 1
59050: ARRAY
59051: PPUSH
59052: CALL 90960 0 2
59056: ST_TO_ADDR
59057: GO 59024
59059: POP
59060: POP
// result := tmp ;
59061: LD_ADDR_VAR 0 5
59065: PUSH
59066: LD_VAR 0 8
59070: ST_TO_ADDR
// end ; end ;
59071: LD_VAR 0 5
59075: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
59076: LD_INT 0
59078: PPUSH
59079: PPUSH
59080: PPUSH
59081: PPUSH
// if not list then
59082: LD_VAR 0 3
59086: NOT
59087: IFFALSE 59091
// exit ;
59089: GO 59479
// result := [ ] ;
59091: LD_ADDR_VAR 0 6
59095: PUSH
59096: EMPTY
59097: ST_TO_ADDR
// for i in list do
59098: LD_ADDR_VAR 0 7
59102: PUSH
59103: LD_VAR 0 3
59107: PUSH
59108: FOR_IN
59109: IFFALSE 59311
// begin tmp := GetDistUnitXY ( i , x , y ) ;
59111: LD_ADDR_VAR 0 9
59115: PUSH
59116: LD_VAR 0 7
59120: PPUSH
59121: LD_VAR 0 1
59125: PPUSH
59126: LD_VAR 0 2
59130: PPUSH
59131: CALL_OW 297
59135: ST_TO_ADDR
// if not result then
59136: LD_VAR 0 6
59140: NOT
59141: IFFALSE 59167
// result := [ [ i , tmp ] ] else
59143: LD_ADDR_VAR 0 6
59147: PUSH
59148: LD_VAR 0 7
59152: PUSH
59153: LD_VAR 0 9
59157: PUSH
59158: EMPTY
59159: LIST
59160: LIST
59161: PUSH
59162: EMPTY
59163: LIST
59164: ST_TO_ADDR
59165: GO 59309
// begin if result [ result ] [ 2 ] < tmp then
59167: LD_VAR 0 6
59171: PUSH
59172: LD_VAR 0 6
59176: ARRAY
59177: PUSH
59178: LD_INT 2
59180: ARRAY
59181: PUSH
59182: LD_VAR 0 9
59186: LESS
59187: IFFALSE 59229
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
59189: LD_ADDR_VAR 0 6
59193: PUSH
59194: LD_VAR 0 6
59198: PPUSH
59199: LD_VAR 0 6
59203: PUSH
59204: LD_INT 1
59206: PLUS
59207: PPUSH
59208: LD_VAR 0 7
59212: PUSH
59213: LD_VAR 0 9
59217: PUSH
59218: EMPTY
59219: LIST
59220: LIST
59221: PPUSH
59222: CALL_OW 2
59226: ST_TO_ADDR
59227: GO 59309
// for j = 1 to result do
59229: LD_ADDR_VAR 0 8
59233: PUSH
59234: DOUBLE
59235: LD_INT 1
59237: DEC
59238: ST_TO_ADDR
59239: LD_VAR 0 6
59243: PUSH
59244: FOR_TO
59245: IFFALSE 59307
// begin if tmp < result [ j ] [ 2 ] then
59247: LD_VAR 0 9
59251: PUSH
59252: LD_VAR 0 6
59256: PUSH
59257: LD_VAR 0 8
59261: ARRAY
59262: PUSH
59263: LD_INT 2
59265: ARRAY
59266: LESS
59267: IFFALSE 59305
// begin result := Insert ( result , j , [ i , tmp ] ) ;
59269: LD_ADDR_VAR 0 6
59273: PUSH
59274: LD_VAR 0 6
59278: PPUSH
59279: LD_VAR 0 8
59283: PPUSH
59284: LD_VAR 0 7
59288: PUSH
59289: LD_VAR 0 9
59293: PUSH
59294: EMPTY
59295: LIST
59296: LIST
59297: PPUSH
59298: CALL_OW 2
59302: ST_TO_ADDR
// break ;
59303: GO 59307
// end ; end ;
59305: GO 59244
59307: POP
59308: POP
// end ; end ;
59309: GO 59108
59311: POP
59312: POP
// if result and not asc then
59313: LD_VAR 0 6
59317: PUSH
59318: LD_VAR 0 4
59322: NOT
59323: AND
59324: IFFALSE 59399
// begin tmp := result ;
59326: LD_ADDR_VAR 0 9
59330: PUSH
59331: LD_VAR 0 6
59335: ST_TO_ADDR
// for i = tmp downto 1 do
59336: LD_ADDR_VAR 0 7
59340: PUSH
59341: DOUBLE
59342: LD_VAR 0 9
59346: INC
59347: ST_TO_ADDR
59348: LD_INT 1
59350: PUSH
59351: FOR_DOWNTO
59352: IFFALSE 59397
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
59354: LD_ADDR_VAR 0 6
59358: PUSH
59359: LD_VAR 0 6
59363: PPUSH
59364: LD_VAR 0 9
59368: PUSH
59369: LD_VAR 0 7
59373: MINUS
59374: PUSH
59375: LD_INT 1
59377: PLUS
59378: PPUSH
59379: LD_VAR 0 9
59383: PUSH
59384: LD_VAR 0 7
59388: ARRAY
59389: PPUSH
59390: CALL_OW 1
59394: ST_TO_ADDR
59395: GO 59351
59397: POP
59398: POP
// end ; tmp := [ ] ;
59399: LD_ADDR_VAR 0 9
59403: PUSH
59404: EMPTY
59405: ST_TO_ADDR
// if mode then
59406: LD_VAR 0 5
59410: IFFALSE 59479
// begin for i = 1 to result do
59412: LD_ADDR_VAR 0 7
59416: PUSH
59417: DOUBLE
59418: LD_INT 1
59420: DEC
59421: ST_TO_ADDR
59422: LD_VAR 0 6
59426: PUSH
59427: FOR_TO
59428: IFFALSE 59467
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
59430: LD_ADDR_VAR 0 9
59434: PUSH
59435: LD_VAR 0 9
59439: PPUSH
59440: LD_VAR 0 7
59444: PPUSH
59445: LD_VAR 0 6
59449: PUSH
59450: LD_VAR 0 7
59454: ARRAY
59455: PUSH
59456: LD_INT 1
59458: ARRAY
59459: PPUSH
59460: CALL_OW 1
59464: ST_TO_ADDR
59465: GO 59427
59467: POP
59468: POP
// result := tmp ;
59469: LD_ADDR_VAR 0 6
59473: PUSH
59474: LD_VAR 0 9
59478: ST_TO_ADDR
// end ; end ;
59479: LD_VAR 0 6
59483: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
59484: LD_INT 0
59486: PPUSH
59487: PPUSH
59488: PPUSH
59489: PPUSH
59490: PPUSH
59491: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
59492: LD_ADDR_VAR 0 5
59496: PUSH
59497: LD_INT 0
59499: PUSH
59500: LD_INT 0
59502: PUSH
59503: LD_INT 0
59505: PUSH
59506: EMPTY
59507: PUSH
59508: EMPTY
59509: LIST
59510: LIST
59511: LIST
59512: LIST
59513: ST_TO_ADDR
// if not x or not y then
59514: LD_VAR 0 2
59518: NOT
59519: PUSH
59520: LD_VAR 0 3
59524: NOT
59525: OR
59526: IFFALSE 59530
// exit ;
59528: GO 61180
// if not range then
59530: LD_VAR 0 4
59534: NOT
59535: IFFALSE 59545
// range := 10 ;
59537: LD_ADDR_VAR 0 4
59541: PUSH
59542: LD_INT 10
59544: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
59545: LD_ADDR_VAR 0 8
59549: PUSH
59550: LD_INT 81
59552: PUSH
59553: LD_VAR 0 1
59557: PUSH
59558: EMPTY
59559: LIST
59560: LIST
59561: PUSH
59562: LD_INT 92
59564: PUSH
59565: LD_VAR 0 2
59569: PUSH
59570: LD_VAR 0 3
59574: PUSH
59575: LD_VAR 0 4
59579: PUSH
59580: EMPTY
59581: LIST
59582: LIST
59583: LIST
59584: LIST
59585: PUSH
59586: LD_INT 3
59588: PUSH
59589: LD_INT 21
59591: PUSH
59592: LD_INT 3
59594: PUSH
59595: EMPTY
59596: LIST
59597: LIST
59598: PUSH
59599: EMPTY
59600: LIST
59601: LIST
59602: PUSH
59603: EMPTY
59604: LIST
59605: LIST
59606: LIST
59607: PPUSH
59608: CALL_OW 69
59612: ST_TO_ADDR
// if not tmp then
59613: LD_VAR 0 8
59617: NOT
59618: IFFALSE 59622
// exit ;
59620: GO 61180
// for i in tmp do
59622: LD_ADDR_VAR 0 6
59626: PUSH
59627: LD_VAR 0 8
59631: PUSH
59632: FOR_IN
59633: IFFALSE 61155
// begin points := [ 0 , 0 , 0 ] ;
59635: LD_ADDR_VAR 0 9
59639: PUSH
59640: LD_INT 0
59642: PUSH
59643: LD_INT 0
59645: PUSH
59646: LD_INT 0
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: LIST
59653: ST_TO_ADDR
// bpoints := 1 ;
59654: LD_ADDR_VAR 0 10
59658: PUSH
59659: LD_INT 1
59661: ST_TO_ADDR
// case GetType ( i ) of unit_human :
59662: LD_VAR 0 6
59666: PPUSH
59667: CALL_OW 247
59671: PUSH
59672: LD_INT 1
59674: DOUBLE
59675: EQUAL
59676: IFTRUE 59680
59678: GO 60258
59680: POP
// begin if GetClass ( i ) = 1 then
59681: LD_VAR 0 6
59685: PPUSH
59686: CALL_OW 257
59690: PUSH
59691: LD_INT 1
59693: EQUAL
59694: IFFALSE 59715
// points := [ 10 , 5 , 3 ] ;
59696: LD_ADDR_VAR 0 9
59700: PUSH
59701: LD_INT 10
59703: PUSH
59704: LD_INT 5
59706: PUSH
59707: LD_INT 3
59709: PUSH
59710: EMPTY
59711: LIST
59712: LIST
59713: LIST
59714: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
59715: LD_VAR 0 6
59719: PPUSH
59720: CALL_OW 257
59724: PUSH
59725: LD_INT 2
59727: PUSH
59728: LD_INT 3
59730: PUSH
59731: LD_INT 4
59733: PUSH
59734: EMPTY
59735: LIST
59736: LIST
59737: LIST
59738: IN
59739: IFFALSE 59760
// points := [ 3 , 2 , 1 ] ;
59741: LD_ADDR_VAR 0 9
59745: PUSH
59746: LD_INT 3
59748: PUSH
59749: LD_INT 2
59751: PUSH
59752: LD_INT 1
59754: PUSH
59755: EMPTY
59756: LIST
59757: LIST
59758: LIST
59759: ST_TO_ADDR
// if GetClass ( i ) = 5 then
59760: LD_VAR 0 6
59764: PPUSH
59765: CALL_OW 257
59769: PUSH
59770: LD_INT 5
59772: EQUAL
59773: IFFALSE 59794
// points := [ 130 , 5 , 2 ] ;
59775: LD_ADDR_VAR 0 9
59779: PUSH
59780: LD_INT 130
59782: PUSH
59783: LD_INT 5
59785: PUSH
59786: LD_INT 2
59788: PUSH
59789: EMPTY
59790: LIST
59791: LIST
59792: LIST
59793: ST_TO_ADDR
// if GetClass ( i ) = 8 then
59794: LD_VAR 0 6
59798: PPUSH
59799: CALL_OW 257
59803: PUSH
59804: LD_INT 8
59806: EQUAL
59807: IFFALSE 59828
// points := [ 35 , 35 , 30 ] ;
59809: LD_ADDR_VAR 0 9
59813: PUSH
59814: LD_INT 35
59816: PUSH
59817: LD_INT 35
59819: PUSH
59820: LD_INT 30
59822: PUSH
59823: EMPTY
59824: LIST
59825: LIST
59826: LIST
59827: ST_TO_ADDR
// if GetClass ( i ) = 9 then
59828: LD_VAR 0 6
59832: PPUSH
59833: CALL_OW 257
59837: PUSH
59838: LD_INT 9
59840: EQUAL
59841: IFFALSE 59862
// points := [ 20 , 55 , 40 ] ;
59843: LD_ADDR_VAR 0 9
59847: PUSH
59848: LD_INT 20
59850: PUSH
59851: LD_INT 55
59853: PUSH
59854: LD_INT 40
59856: PUSH
59857: EMPTY
59858: LIST
59859: LIST
59860: LIST
59861: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59862: LD_VAR 0 6
59866: PPUSH
59867: CALL_OW 257
59871: PUSH
59872: LD_INT 12
59874: PUSH
59875: LD_INT 16
59877: PUSH
59878: EMPTY
59879: LIST
59880: LIST
59881: IN
59882: IFFALSE 59903
// points := [ 5 , 3 , 2 ] ;
59884: LD_ADDR_VAR 0 9
59888: PUSH
59889: LD_INT 5
59891: PUSH
59892: LD_INT 3
59894: PUSH
59895: LD_INT 2
59897: PUSH
59898: EMPTY
59899: LIST
59900: LIST
59901: LIST
59902: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59903: LD_VAR 0 6
59907: PPUSH
59908: CALL_OW 257
59912: PUSH
59913: LD_INT 17
59915: EQUAL
59916: IFFALSE 59937
// points := [ 100 , 50 , 75 ] ;
59918: LD_ADDR_VAR 0 9
59922: PUSH
59923: LD_INT 100
59925: PUSH
59926: LD_INT 50
59928: PUSH
59929: LD_INT 75
59931: PUSH
59932: EMPTY
59933: LIST
59934: LIST
59935: LIST
59936: ST_TO_ADDR
// if GetClass ( i ) = 15 then
59937: LD_VAR 0 6
59941: PPUSH
59942: CALL_OW 257
59946: PUSH
59947: LD_INT 15
59949: EQUAL
59950: IFFALSE 59971
// points := [ 10 , 5 , 3 ] ;
59952: LD_ADDR_VAR 0 9
59956: PUSH
59957: LD_INT 10
59959: PUSH
59960: LD_INT 5
59962: PUSH
59963: LD_INT 3
59965: PUSH
59966: EMPTY
59967: LIST
59968: LIST
59969: LIST
59970: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59971: LD_VAR 0 6
59975: PPUSH
59976: CALL_OW 257
59980: PUSH
59981: LD_INT 14
59983: EQUAL
59984: IFFALSE 60005
// points := [ 10 , 0 , 0 ] ;
59986: LD_ADDR_VAR 0 9
59990: PUSH
59991: LD_INT 10
59993: PUSH
59994: LD_INT 0
59996: PUSH
59997: LD_INT 0
59999: PUSH
60000: EMPTY
60001: LIST
60002: LIST
60003: LIST
60004: ST_TO_ADDR
// if GetClass ( i ) = 11 then
60005: LD_VAR 0 6
60009: PPUSH
60010: CALL_OW 257
60014: PUSH
60015: LD_INT 11
60017: EQUAL
60018: IFFALSE 60039
// points := [ 30 , 10 , 5 ] ;
60020: LD_ADDR_VAR 0 9
60024: PUSH
60025: LD_INT 30
60027: PUSH
60028: LD_INT 10
60030: PUSH
60031: LD_INT 5
60033: PUSH
60034: EMPTY
60035: LIST
60036: LIST
60037: LIST
60038: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
60039: LD_VAR 0 1
60043: PPUSH
60044: LD_INT 5
60046: PPUSH
60047: CALL_OW 321
60051: PUSH
60052: LD_INT 2
60054: EQUAL
60055: IFFALSE 60072
// bpoints := bpoints * 1.8 ;
60057: LD_ADDR_VAR 0 10
60061: PUSH
60062: LD_VAR 0 10
60066: PUSH
60067: LD_REAL  1.80000000000000E+0000
60070: MUL
60071: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
60072: LD_VAR 0 6
60076: PPUSH
60077: CALL_OW 257
60081: PUSH
60082: LD_INT 1
60084: PUSH
60085: LD_INT 2
60087: PUSH
60088: LD_INT 3
60090: PUSH
60091: LD_INT 4
60093: PUSH
60094: EMPTY
60095: LIST
60096: LIST
60097: LIST
60098: LIST
60099: IN
60100: PUSH
60101: LD_VAR 0 1
60105: PPUSH
60106: LD_INT 51
60108: PPUSH
60109: CALL_OW 321
60113: PUSH
60114: LD_INT 2
60116: EQUAL
60117: AND
60118: IFFALSE 60135
// bpoints := bpoints * 1.2 ;
60120: LD_ADDR_VAR 0 10
60124: PUSH
60125: LD_VAR 0 10
60129: PUSH
60130: LD_REAL  1.20000000000000E+0000
60133: MUL
60134: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
60135: LD_VAR 0 6
60139: PPUSH
60140: CALL_OW 257
60144: PUSH
60145: LD_INT 5
60147: PUSH
60148: LD_INT 7
60150: PUSH
60151: LD_INT 9
60153: PUSH
60154: EMPTY
60155: LIST
60156: LIST
60157: LIST
60158: IN
60159: PUSH
60160: LD_VAR 0 1
60164: PPUSH
60165: LD_INT 52
60167: PPUSH
60168: CALL_OW 321
60172: PUSH
60173: LD_INT 2
60175: EQUAL
60176: AND
60177: IFFALSE 60194
// bpoints := bpoints * 1.5 ;
60179: LD_ADDR_VAR 0 10
60183: PUSH
60184: LD_VAR 0 10
60188: PUSH
60189: LD_REAL  1.50000000000000E+0000
60192: MUL
60193: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
60194: LD_VAR 0 1
60198: PPUSH
60199: LD_INT 66
60201: PPUSH
60202: CALL_OW 321
60206: PUSH
60207: LD_INT 2
60209: EQUAL
60210: IFFALSE 60227
// bpoints := bpoints * 1.1 ;
60212: LD_ADDR_VAR 0 10
60216: PUSH
60217: LD_VAR 0 10
60221: PUSH
60222: LD_REAL  1.10000000000000E+0000
60225: MUL
60226: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
60227: LD_ADDR_VAR 0 10
60231: PUSH
60232: LD_VAR 0 10
60236: PUSH
60237: LD_VAR 0 6
60241: PPUSH
60242: LD_INT 1
60244: PPUSH
60245: CALL_OW 259
60249: PUSH
60250: LD_REAL  1.15000000000000E+0000
60253: MUL
60254: MUL
60255: ST_TO_ADDR
// end ; unit_vehicle :
60256: GO 61084
60258: LD_INT 2
60260: DOUBLE
60261: EQUAL
60262: IFTRUE 60266
60264: GO 61072
60266: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
60267: LD_VAR 0 6
60271: PPUSH
60272: CALL_OW 264
60276: PUSH
60277: LD_INT 2
60279: PUSH
60280: LD_INT 42
60282: PUSH
60283: LD_INT 24
60285: PUSH
60286: EMPTY
60287: LIST
60288: LIST
60289: LIST
60290: IN
60291: IFFALSE 60312
// points := [ 25 , 5 , 3 ] ;
60293: LD_ADDR_VAR 0 9
60297: PUSH
60298: LD_INT 25
60300: PUSH
60301: LD_INT 5
60303: PUSH
60304: LD_INT 3
60306: PUSH
60307: EMPTY
60308: LIST
60309: LIST
60310: LIST
60311: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
60312: LD_VAR 0 6
60316: PPUSH
60317: CALL_OW 264
60321: PUSH
60322: LD_INT 4
60324: PUSH
60325: LD_INT 43
60327: PUSH
60328: LD_INT 25
60330: PUSH
60331: EMPTY
60332: LIST
60333: LIST
60334: LIST
60335: IN
60336: IFFALSE 60357
// points := [ 40 , 15 , 5 ] ;
60338: LD_ADDR_VAR 0 9
60342: PUSH
60343: LD_INT 40
60345: PUSH
60346: LD_INT 15
60348: PUSH
60349: LD_INT 5
60351: PUSH
60352: EMPTY
60353: LIST
60354: LIST
60355: LIST
60356: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
60357: LD_VAR 0 6
60361: PPUSH
60362: CALL_OW 264
60366: PUSH
60367: LD_INT 3
60369: PUSH
60370: LD_INT 23
60372: PUSH
60373: EMPTY
60374: LIST
60375: LIST
60376: IN
60377: IFFALSE 60398
// points := [ 7 , 25 , 8 ] ;
60379: LD_ADDR_VAR 0 9
60383: PUSH
60384: LD_INT 7
60386: PUSH
60387: LD_INT 25
60389: PUSH
60390: LD_INT 8
60392: PUSH
60393: EMPTY
60394: LIST
60395: LIST
60396: LIST
60397: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
60398: LD_VAR 0 6
60402: PPUSH
60403: CALL_OW 264
60407: PUSH
60408: LD_INT 5
60410: PUSH
60411: LD_INT 27
60413: PUSH
60414: LD_INT 44
60416: PUSH
60417: EMPTY
60418: LIST
60419: LIST
60420: LIST
60421: IN
60422: IFFALSE 60443
// points := [ 14 , 50 , 16 ] ;
60424: LD_ADDR_VAR 0 9
60428: PUSH
60429: LD_INT 14
60431: PUSH
60432: LD_INT 50
60434: PUSH
60435: LD_INT 16
60437: PUSH
60438: EMPTY
60439: LIST
60440: LIST
60441: LIST
60442: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
60443: LD_VAR 0 6
60447: PPUSH
60448: CALL_OW 264
60452: PUSH
60453: LD_INT 6
60455: PUSH
60456: LD_INT 46
60458: PUSH
60459: EMPTY
60460: LIST
60461: LIST
60462: IN
60463: IFFALSE 60484
// points := [ 32 , 120 , 70 ] ;
60465: LD_ADDR_VAR 0 9
60469: PUSH
60470: LD_INT 32
60472: PUSH
60473: LD_INT 120
60475: PUSH
60476: LD_INT 70
60478: PUSH
60479: EMPTY
60480: LIST
60481: LIST
60482: LIST
60483: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
60484: LD_VAR 0 6
60488: PPUSH
60489: CALL_OW 264
60493: PUSH
60494: LD_INT 7
60496: PUSH
60497: LD_INT 28
60499: PUSH
60500: LD_INT 45
60502: PUSH
60503: LD_INT 92
60505: PUSH
60506: EMPTY
60507: LIST
60508: LIST
60509: LIST
60510: LIST
60511: IN
60512: IFFALSE 60533
// points := [ 35 , 20 , 45 ] ;
60514: LD_ADDR_VAR 0 9
60518: PUSH
60519: LD_INT 35
60521: PUSH
60522: LD_INT 20
60524: PUSH
60525: LD_INT 45
60527: PUSH
60528: EMPTY
60529: LIST
60530: LIST
60531: LIST
60532: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
60533: LD_VAR 0 6
60537: PPUSH
60538: CALL_OW 264
60542: PUSH
60543: LD_INT 47
60545: PUSH
60546: EMPTY
60547: LIST
60548: IN
60549: IFFALSE 60570
// points := [ 67 , 45 , 75 ] ;
60551: LD_ADDR_VAR 0 9
60555: PUSH
60556: LD_INT 67
60558: PUSH
60559: LD_INT 45
60561: PUSH
60562: LD_INT 75
60564: PUSH
60565: EMPTY
60566: LIST
60567: LIST
60568: LIST
60569: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
60570: LD_VAR 0 6
60574: PPUSH
60575: CALL_OW 264
60579: PUSH
60580: LD_INT 26
60582: PUSH
60583: EMPTY
60584: LIST
60585: IN
60586: IFFALSE 60607
// points := [ 120 , 30 , 80 ] ;
60588: LD_ADDR_VAR 0 9
60592: PUSH
60593: LD_INT 120
60595: PUSH
60596: LD_INT 30
60598: PUSH
60599: LD_INT 80
60601: PUSH
60602: EMPTY
60603: LIST
60604: LIST
60605: LIST
60606: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
60607: LD_VAR 0 6
60611: PPUSH
60612: CALL_OW 264
60616: PUSH
60617: LD_INT 22
60619: PUSH
60620: EMPTY
60621: LIST
60622: IN
60623: IFFALSE 60644
// points := [ 40 , 1 , 1 ] ;
60625: LD_ADDR_VAR 0 9
60629: PUSH
60630: LD_INT 40
60632: PUSH
60633: LD_INT 1
60635: PUSH
60636: LD_INT 1
60638: PUSH
60639: EMPTY
60640: LIST
60641: LIST
60642: LIST
60643: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
60644: LD_VAR 0 6
60648: PPUSH
60649: CALL_OW 264
60653: PUSH
60654: LD_INT 29
60656: PUSH
60657: EMPTY
60658: LIST
60659: IN
60660: IFFALSE 60681
// points := [ 70 , 200 , 400 ] ;
60662: LD_ADDR_VAR 0 9
60666: PUSH
60667: LD_INT 70
60669: PUSH
60670: LD_INT 200
60672: PUSH
60673: LD_INT 400
60675: PUSH
60676: EMPTY
60677: LIST
60678: LIST
60679: LIST
60680: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
60681: LD_VAR 0 6
60685: PPUSH
60686: CALL_OW 264
60690: PUSH
60691: LD_INT 14
60693: PUSH
60694: LD_INT 53
60696: PUSH
60697: EMPTY
60698: LIST
60699: LIST
60700: IN
60701: IFFALSE 60722
// points := [ 40 , 10 , 20 ] ;
60703: LD_ADDR_VAR 0 9
60707: PUSH
60708: LD_INT 40
60710: PUSH
60711: LD_INT 10
60713: PUSH
60714: LD_INT 20
60716: PUSH
60717: EMPTY
60718: LIST
60719: LIST
60720: LIST
60721: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
60722: LD_VAR 0 6
60726: PPUSH
60727: CALL_OW 264
60731: PUSH
60732: LD_INT 9
60734: PUSH
60735: EMPTY
60736: LIST
60737: IN
60738: IFFALSE 60759
// points := [ 5 , 70 , 20 ] ;
60740: LD_ADDR_VAR 0 9
60744: PUSH
60745: LD_INT 5
60747: PUSH
60748: LD_INT 70
60750: PUSH
60751: LD_INT 20
60753: PUSH
60754: EMPTY
60755: LIST
60756: LIST
60757: LIST
60758: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
60759: LD_VAR 0 6
60763: PPUSH
60764: CALL_OW 264
60768: PUSH
60769: LD_INT 10
60771: PUSH
60772: EMPTY
60773: LIST
60774: IN
60775: IFFALSE 60796
// points := [ 35 , 110 , 70 ] ;
60777: LD_ADDR_VAR 0 9
60781: PUSH
60782: LD_INT 35
60784: PUSH
60785: LD_INT 110
60787: PUSH
60788: LD_INT 70
60790: PUSH
60791: EMPTY
60792: LIST
60793: LIST
60794: LIST
60795: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
60796: LD_VAR 0 6
60800: PPUSH
60801: CALL_OW 265
60805: PUSH
60806: LD_INT 25
60808: EQUAL
60809: IFFALSE 60830
// points := [ 80 , 65 , 100 ] ;
60811: LD_ADDR_VAR 0 9
60815: PUSH
60816: LD_INT 80
60818: PUSH
60819: LD_INT 65
60821: PUSH
60822: LD_INT 100
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: LIST
60829: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
60830: LD_VAR 0 6
60834: PPUSH
60835: CALL_OW 263
60839: PUSH
60840: LD_INT 1
60842: EQUAL
60843: IFFALSE 60878
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
60845: LD_ADDR_VAR 0 10
60849: PUSH
60850: LD_VAR 0 10
60854: PUSH
60855: LD_VAR 0 6
60859: PPUSH
60860: CALL_OW 311
60864: PPUSH
60865: LD_INT 3
60867: PPUSH
60868: CALL_OW 259
60872: PUSH
60873: LD_INT 4
60875: MUL
60876: MUL
60877: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60878: LD_VAR 0 6
60882: PPUSH
60883: CALL_OW 263
60887: PUSH
60888: LD_INT 2
60890: EQUAL
60891: IFFALSE 60942
// begin j := IsControledBy ( i ) ;
60893: LD_ADDR_VAR 0 7
60897: PUSH
60898: LD_VAR 0 6
60902: PPUSH
60903: CALL_OW 312
60907: ST_TO_ADDR
// if j then
60908: LD_VAR 0 7
60912: IFFALSE 60942
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60914: LD_ADDR_VAR 0 10
60918: PUSH
60919: LD_VAR 0 10
60923: PUSH
60924: LD_VAR 0 7
60928: PPUSH
60929: LD_INT 3
60931: PPUSH
60932: CALL_OW 259
60936: PUSH
60937: LD_INT 3
60939: MUL
60940: MUL
60941: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
60942: LD_VAR 0 6
60946: PPUSH
60947: CALL_OW 264
60951: PUSH
60952: LD_INT 5
60954: PUSH
60955: LD_INT 6
60957: PUSH
60958: LD_INT 46
60960: PUSH
60961: LD_INT 44
60963: PUSH
60964: LD_INT 47
60966: PUSH
60967: LD_INT 45
60969: PUSH
60970: LD_INT 28
60972: PUSH
60973: LD_INT 7
60975: PUSH
60976: LD_INT 27
60978: PUSH
60979: LD_INT 29
60981: PUSH
60982: EMPTY
60983: LIST
60984: LIST
60985: LIST
60986: LIST
60987: LIST
60988: LIST
60989: LIST
60990: LIST
60991: LIST
60992: LIST
60993: IN
60994: PUSH
60995: LD_VAR 0 1
60999: PPUSH
61000: LD_INT 52
61002: PPUSH
61003: CALL_OW 321
61007: PUSH
61008: LD_INT 2
61010: EQUAL
61011: AND
61012: IFFALSE 61029
// bpoints := bpoints * 1.2 ;
61014: LD_ADDR_VAR 0 10
61018: PUSH
61019: LD_VAR 0 10
61023: PUSH
61024: LD_REAL  1.20000000000000E+0000
61027: MUL
61028: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
61029: LD_VAR 0 6
61033: PPUSH
61034: CALL_OW 264
61038: PUSH
61039: LD_INT 6
61041: PUSH
61042: LD_INT 46
61044: PUSH
61045: LD_INT 47
61047: PUSH
61048: EMPTY
61049: LIST
61050: LIST
61051: LIST
61052: IN
61053: IFFALSE 61070
// bpoints := bpoints * 1.2 ;
61055: LD_ADDR_VAR 0 10
61059: PUSH
61060: LD_VAR 0 10
61064: PUSH
61065: LD_REAL  1.20000000000000E+0000
61068: MUL
61069: ST_TO_ADDR
// end ; unit_building :
61070: GO 61084
61072: LD_INT 3
61074: DOUBLE
61075: EQUAL
61076: IFTRUE 61080
61078: GO 61083
61080: POP
// ; end ;
61081: GO 61084
61083: POP
// for j = 1 to 3 do
61084: LD_ADDR_VAR 0 7
61088: PUSH
61089: DOUBLE
61090: LD_INT 1
61092: DEC
61093: ST_TO_ADDR
61094: LD_INT 3
61096: PUSH
61097: FOR_TO
61098: IFFALSE 61151
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
61100: LD_ADDR_VAR 0 5
61104: PUSH
61105: LD_VAR 0 5
61109: PPUSH
61110: LD_VAR 0 7
61114: PPUSH
61115: LD_VAR 0 5
61119: PUSH
61120: LD_VAR 0 7
61124: ARRAY
61125: PUSH
61126: LD_VAR 0 9
61130: PUSH
61131: LD_VAR 0 7
61135: ARRAY
61136: PUSH
61137: LD_VAR 0 10
61141: MUL
61142: PLUS
61143: PPUSH
61144: CALL_OW 1
61148: ST_TO_ADDR
61149: GO 61097
61151: POP
61152: POP
// end ;
61153: GO 59632
61155: POP
61156: POP
// result := Replace ( result , 4 , tmp ) ;
61157: LD_ADDR_VAR 0 5
61161: PUSH
61162: LD_VAR 0 5
61166: PPUSH
61167: LD_INT 4
61169: PPUSH
61170: LD_VAR 0 8
61174: PPUSH
61175: CALL_OW 1
61179: ST_TO_ADDR
// end ;
61180: LD_VAR 0 5
61184: RET
// export function DangerAtRange ( unit , range ) ; begin
61185: LD_INT 0
61187: PPUSH
// if not unit then
61188: LD_VAR 0 1
61192: NOT
61193: IFFALSE 61197
// exit ;
61195: GO 61242
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
61197: LD_ADDR_VAR 0 3
61201: PUSH
61202: LD_VAR 0 1
61206: PPUSH
61207: CALL_OW 255
61211: PPUSH
61212: LD_VAR 0 1
61216: PPUSH
61217: CALL_OW 250
61221: PPUSH
61222: LD_VAR 0 1
61226: PPUSH
61227: CALL_OW 251
61231: PPUSH
61232: LD_VAR 0 2
61236: PPUSH
61237: CALL 59484 0 4
61241: ST_TO_ADDR
// end ;
61242: LD_VAR 0 3
61246: RET
// export function DangerInArea ( side , area ) ; begin
61247: LD_INT 0
61249: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
61250: LD_ADDR_VAR 0 3
61254: PUSH
61255: LD_VAR 0 2
61259: PPUSH
61260: LD_INT 81
61262: PUSH
61263: LD_VAR 0 1
61267: PUSH
61268: EMPTY
61269: LIST
61270: LIST
61271: PPUSH
61272: CALL_OW 70
61276: ST_TO_ADDR
// end ;
61277: LD_VAR 0 3
61281: RET
// export function IsExtension ( b ) ; begin
61282: LD_INT 0
61284: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
61285: LD_ADDR_VAR 0 2
61289: PUSH
61290: LD_VAR 0 1
61294: PUSH
61295: LD_INT 23
61297: PUSH
61298: LD_INT 20
61300: PUSH
61301: LD_INT 22
61303: PUSH
61304: LD_INT 17
61306: PUSH
61307: LD_INT 24
61309: PUSH
61310: LD_INT 21
61312: PUSH
61313: LD_INT 19
61315: PUSH
61316: LD_INT 16
61318: PUSH
61319: LD_INT 25
61321: PUSH
61322: LD_INT 18
61324: PUSH
61325: EMPTY
61326: LIST
61327: LIST
61328: LIST
61329: LIST
61330: LIST
61331: LIST
61332: LIST
61333: LIST
61334: LIST
61335: LIST
61336: IN
61337: ST_TO_ADDR
// end ;
61338: LD_VAR 0 2
61342: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
61343: LD_INT 0
61345: PPUSH
61346: PPUSH
61347: PPUSH
// result := [ ] ;
61348: LD_ADDR_VAR 0 4
61352: PUSH
61353: EMPTY
61354: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
61355: LD_ADDR_VAR 0 5
61359: PUSH
61360: LD_VAR 0 2
61364: PPUSH
61365: LD_INT 21
61367: PUSH
61368: LD_INT 3
61370: PUSH
61371: EMPTY
61372: LIST
61373: LIST
61374: PPUSH
61375: CALL_OW 70
61379: ST_TO_ADDR
// if not tmp then
61380: LD_VAR 0 5
61384: NOT
61385: IFFALSE 61389
// exit ;
61387: GO 61453
// if checkLink then
61389: LD_VAR 0 3
61393: IFFALSE 61443
// begin for i in tmp do
61395: LD_ADDR_VAR 0 6
61399: PUSH
61400: LD_VAR 0 5
61404: PUSH
61405: FOR_IN
61406: IFFALSE 61441
// if GetBase ( i ) <> base then
61408: LD_VAR 0 6
61412: PPUSH
61413: CALL_OW 274
61417: PUSH
61418: LD_VAR 0 1
61422: NONEQUAL
61423: IFFALSE 61439
// ComLinkToBase ( base , i ) ;
61425: LD_VAR 0 1
61429: PPUSH
61430: LD_VAR 0 6
61434: PPUSH
61435: CALL_OW 169
61439: GO 61405
61441: POP
61442: POP
// end ; result := tmp ;
61443: LD_ADDR_VAR 0 4
61447: PUSH
61448: LD_VAR 0 5
61452: ST_TO_ADDR
// end ;
61453: LD_VAR 0 4
61457: RET
// export function ComComplete ( units , b ) ; var i ; begin
61458: LD_INT 0
61460: PPUSH
61461: PPUSH
// if not units then
61462: LD_VAR 0 1
61466: NOT
61467: IFFALSE 61471
// exit ;
61469: GO 61561
// for i in units do
61471: LD_ADDR_VAR 0 4
61475: PUSH
61476: LD_VAR 0 1
61480: PUSH
61481: FOR_IN
61482: IFFALSE 61559
// if BuildingStatus ( b ) = bs_build then
61484: LD_VAR 0 2
61488: PPUSH
61489: CALL_OW 461
61493: PUSH
61494: LD_INT 1
61496: EQUAL
61497: IFFALSE 61557
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
61499: LD_VAR 0 4
61503: PPUSH
61504: LD_STRING h
61506: PUSH
61507: LD_VAR 0 2
61511: PPUSH
61512: CALL_OW 250
61516: PUSH
61517: LD_VAR 0 2
61521: PPUSH
61522: CALL_OW 251
61526: PUSH
61527: LD_VAR 0 2
61531: PUSH
61532: LD_INT 0
61534: PUSH
61535: LD_INT 0
61537: PUSH
61538: LD_INT 0
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: LIST
61545: LIST
61546: LIST
61547: LIST
61548: LIST
61549: PUSH
61550: EMPTY
61551: LIST
61552: PPUSH
61553: CALL_OW 446
61557: GO 61481
61559: POP
61560: POP
// end ;
61561: LD_VAR 0 3
61565: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
61566: LD_INT 0
61568: PPUSH
61569: PPUSH
61570: PPUSH
61571: PPUSH
61572: PPUSH
61573: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
61574: LD_VAR 0 1
61578: NOT
61579: PUSH
61580: LD_VAR 0 1
61584: PPUSH
61585: CALL_OW 263
61589: PUSH
61590: LD_INT 2
61592: NONEQUAL
61593: OR
61594: IFFALSE 61598
// exit ;
61596: GO 61914
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
61598: LD_ADDR_VAR 0 6
61602: PUSH
61603: LD_INT 22
61605: PUSH
61606: LD_VAR 0 1
61610: PPUSH
61611: CALL_OW 255
61615: PUSH
61616: EMPTY
61617: LIST
61618: LIST
61619: PUSH
61620: LD_INT 2
61622: PUSH
61623: LD_INT 30
61625: PUSH
61626: LD_INT 36
61628: PUSH
61629: EMPTY
61630: LIST
61631: LIST
61632: PUSH
61633: LD_INT 34
61635: PUSH
61636: LD_INT 31
61638: PUSH
61639: EMPTY
61640: LIST
61641: LIST
61642: PUSH
61643: EMPTY
61644: LIST
61645: LIST
61646: LIST
61647: PUSH
61648: EMPTY
61649: LIST
61650: LIST
61651: PPUSH
61652: CALL_OW 69
61656: ST_TO_ADDR
// if not tmp then
61657: LD_VAR 0 6
61661: NOT
61662: IFFALSE 61666
// exit ;
61664: GO 61914
// result := [ ] ;
61666: LD_ADDR_VAR 0 2
61670: PUSH
61671: EMPTY
61672: ST_TO_ADDR
// for i in tmp do
61673: LD_ADDR_VAR 0 3
61677: PUSH
61678: LD_VAR 0 6
61682: PUSH
61683: FOR_IN
61684: IFFALSE 61755
// begin t := UnitsInside ( i ) ;
61686: LD_ADDR_VAR 0 4
61690: PUSH
61691: LD_VAR 0 3
61695: PPUSH
61696: CALL_OW 313
61700: ST_TO_ADDR
// if t then
61701: LD_VAR 0 4
61705: IFFALSE 61753
// for j in t do
61707: LD_ADDR_VAR 0 7
61711: PUSH
61712: LD_VAR 0 4
61716: PUSH
61717: FOR_IN
61718: IFFALSE 61751
// result := Replace ( result , result + 1 , j ) ;
61720: LD_ADDR_VAR 0 2
61724: PUSH
61725: LD_VAR 0 2
61729: PPUSH
61730: LD_VAR 0 2
61734: PUSH
61735: LD_INT 1
61737: PLUS
61738: PPUSH
61739: LD_VAR 0 7
61743: PPUSH
61744: CALL_OW 1
61748: ST_TO_ADDR
61749: GO 61717
61751: POP
61752: POP
// end ;
61753: GO 61683
61755: POP
61756: POP
// if not result then
61757: LD_VAR 0 2
61761: NOT
61762: IFFALSE 61766
// exit ;
61764: GO 61914
// mech := result [ 1 ] ;
61766: LD_ADDR_VAR 0 5
61770: PUSH
61771: LD_VAR 0 2
61775: PUSH
61776: LD_INT 1
61778: ARRAY
61779: ST_TO_ADDR
// if result > 1 then
61780: LD_VAR 0 2
61784: PUSH
61785: LD_INT 1
61787: GREATER
61788: IFFALSE 61900
// begin for i = 2 to result do
61790: LD_ADDR_VAR 0 3
61794: PUSH
61795: DOUBLE
61796: LD_INT 2
61798: DEC
61799: ST_TO_ADDR
61800: LD_VAR 0 2
61804: PUSH
61805: FOR_TO
61806: IFFALSE 61898
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
61808: LD_ADDR_VAR 0 4
61812: PUSH
61813: LD_VAR 0 2
61817: PUSH
61818: LD_VAR 0 3
61822: ARRAY
61823: PPUSH
61824: LD_INT 3
61826: PPUSH
61827: CALL_OW 259
61831: PUSH
61832: LD_VAR 0 2
61836: PUSH
61837: LD_VAR 0 3
61841: ARRAY
61842: PPUSH
61843: CALL_OW 432
61847: MINUS
61848: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
61849: LD_VAR 0 4
61853: PUSH
61854: LD_VAR 0 5
61858: PPUSH
61859: LD_INT 3
61861: PPUSH
61862: CALL_OW 259
61866: PUSH
61867: LD_VAR 0 5
61871: PPUSH
61872: CALL_OW 432
61876: MINUS
61877: GREATEREQUAL
61878: IFFALSE 61896
// mech := result [ i ] ;
61880: LD_ADDR_VAR 0 5
61884: PUSH
61885: LD_VAR 0 2
61889: PUSH
61890: LD_VAR 0 3
61894: ARRAY
61895: ST_TO_ADDR
// end ;
61896: GO 61805
61898: POP
61899: POP
// end ; ComLinkTo ( vehicle , mech ) ;
61900: LD_VAR 0 1
61904: PPUSH
61905: LD_VAR 0 5
61909: PPUSH
61910: CALL_OW 135
// end ;
61914: LD_VAR 0 2
61918: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61919: LD_INT 0
61921: PPUSH
61922: PPUSH
61923: PPUSH
61924: PPUSH
61925: PPUSH
61926: PPUSH
61927: PPUSH
61928: PPUSH
61929: PPUSH
61930: PPUSH
61931: PPUSH
61932: PPUSH
61933: PPUSH
// result := [ ] ;
61934: LD_ADDR_VAR 0 7
61938: PUSH
61939: EMPTY
61940: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
61941: LD_VAR 0 1
61945: PPUSH
61946: CALL_OW 266
61950: PUSH
61951: LD_INT 0
61953: PUSH
61954: LD_INT 1
61956: PUSH
61957: EMPTY
61958: LIST
61959: LIST
61960: IN
61961: NOT
61962: IFFALSE 61966
// exit ;
61964: GO 63600
// if name then
61966: LD_VAR 0 3
61970: IFFALSE 61986
// SetBName ( base_dep , name ) ;
61972: LD_VAR 0 1
61976: PPUSH
61977: LD_VAR 0 3
61981: PPUSH
61982: CALL_OW 500
// base := GetBase ( base_dep ) ;
61986: LD_ADDR_VAR 0 15
61990: PUSH
61991: LD_VAR 0 1
61995: PPUSH
61996: CALL_OW 274
62000: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
62001: LD_ADDR_VAR 0 16
62005: PUSH
62006: LD_VAR 0 1
62010: PPUSH
62011: CALL_OW 255
62015: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
62016: LD_ADDR_VAR 0 17
62020: PUSH
62021: LD_VAR 0 1
62025: PPUSH
62026: CALL_OW 248
62030: ST_TO_ADDR
// if sources then
62031: LD_VAR 0 5
62035: IFFALSE 62082
// for i = 1 to 3 do
62037: LD_ADDR_VAR 0 8
62041: PUSH
62042: DOUBLE
62043: LD_INT 1
62045: DEC
62046: ST_TO_ADDR
62047: LD_INT 3
62049: PUSH
62050: FOR_TO
62051: IFFALSE 62080
// AddResourceType ( base , i , sources [ i ] ) ;
62053: LD_VAR 0 15
62057: PPUSH
62058: LD_VAR 0 8
62062: PPUSH
62063: LD_VAR 0 5
62067: PUSH
62068: LD_VAR 0 8
62072: ARRAY
62073: PPUSH
62074: CALL_OW 276
62078: GO 62050
62080: POP
62081: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
62082: LD_ADDR_VAR 0 18
62086: PUSH
62087: LD_VAR 0 15
62091: PPUSH
62092: LD_VAR 0 2
62096: PPUSH
62097: LD_INT 1
62099: PPUSH
62100: CALL 61343 0 3
62104: ST_TO_ADDR
// InitHc ;
62105: CALL_OW 19
// InitUc ;
62109: CALL_OW 18
// uc_side := side ;
62113: LD_ADDR_OWVAR 20
62117: PUSH
62118: LD_VAR 0 16
62122: ST_TO_ADDR
// uc_nation := nation ;
62123: LD_ADDR_OWVAR 21
62127: PUSH
62128: LD_VAR 0 17
62132: ST_TO_ADDR
// if buildings then
62133: LD_VAR 0 18
62137: IFFALSE 63459
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
62139: LD_ADDR_VAR 0 19
62143: PUSH
62144: LD_VAR 0 18
62148: PPUSH
62149: LD_INT 2
62151: PUSH
62152: LD_INT 30
62154: PUSH
62155: LD_INT 29
62157: PUSH
62158: EMPTY
62159: LIST
62160: LIST
62161: PUSH
62162: LD_INT 30
62164: PUSH
62165: LD_INT 30
62167: PUSH
62168: EMPTY
62169: LIST
62170: LIST
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: LIST
62176: PPUSH
62177: CALL_OW 72
62181: ST_TO_ADDR
// if tmp then
62182: LD_VAR 0 19
62186: IFFALSE 62234
// for i in tmp do
62188: LD_ADDR_VAR 0 8
62192: PUSH
62193: LD_VAR 0 19
62197: PUSH
62198: FOR_IN
62199: IFFALSE 62232
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
62201: LD_VAR 0 8
62205: PPUSH
62206: CALL_OW 250
62210: PPUSH
62211: LD_VAR 0 8
62215: PPUSH
62216: CALL_OW 251
62220: PPUSH
62221: LD_VAR 0 16
62225: PPUSH
62226: CALL_OW 441
62230: GO 62198
62232: POP
62233: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
62234: LD_VAR 0 18
62238: PPUSH
62239: LD_INT 2
62241: PUSH
62242: LD_INT 30
62244: PUSH
62245: LD_INT 32
62247: PUSH
62248: EMPTY
62249: LIST
62250: LIST
62251: PUSH
62252: LD_INT 30
62254: PUSH
62255: LD_INT 33
62257: PUSH
62258: EMPTY
62259: LIST
62260: LIST
62261: PUSH
62262: EMPTY
62263: LIST
62264: LIST
62265: LIST
62266: PPUSH
62267: CALL_OW 72
62271: IFFALSE 62359
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
62273: LD_ADDR_VAR 0 8
62277: PUSH
62278: LD_VAR 0 18
62282: PPUSH
62283: LD_INT 2
62285: PUSH
62286: LD_INT 30
62288: PUSH
62289: LD_INT 32
62291: PUSH
62292: EMPTY
62293: LIST
62294: LIST
62295: PUSH
62296: LD_INT 30
62298: PUSH
62299: LD_INT 33
62301: PUSH
62302: EMPTY
62303: LIST
62304: LIST
62305: PUSH
62306: EMPTY
62307: LIST
62308: LIST
62309: LIST
62310: PPUSH
62311: CALL_OW 72
62315: PUSH
62316: FOR_IN
62317: IFFALSE 62357
// begin if not GetBWeapon ( i ) then
62319: LD_VAR 0 8
62323: PPUSH
62324: CALL_OW 269
62328: NOT
62329: IFFALSE 62355
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
62331: LD_VAR 0 8
62335: PPUSH
62336: LD_VAR 0 8
62340: PPUSH
62341: LD_VAR 0 2
62345: PPUSH
62346: CALL 63605 0 2
62350: PPUSH
62351: CALL_OW 431
// end ;
62355: GO 62316
62357: POP
62358: POP
// end ; for i = 1 to personel do
62359: LD_ADDR_VAR 0 8
62363: PUSH
62364: DOUBLE
62365: LD_INT 1
62367: DEC
62368: ST_TO_ADDR
62369: LD_VAR 0 6
62373: PUSH
62374: FOR_TO
62375: IFFALSE 63439
// begin if i > 4 then
62377: LD_VAR 0 8
62381: PUSH
62382: LD_INT 4
62384: GREATER
62385: IFFALSE 62389
// break ;
62387: GO 63439
// case i of 1 :
62389: LD_VAR 0 8
62393: PUSH
62394: LD_INT 1
62396: DOUBLE
62397: EQUAL
62398: IFTRUE 62402
62400: GO 62482
62402: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
62403: LD_ADDR_VAR 0 12
62407: PUSH
62408: LD_VAR 0 18
62412: PPUSH
62413: LD_INT 22
62415: PUSH
62416: LD_VAR 0 16
62420: PUSH
62421: EMPTY
62422: LIST
62423: LIST
62424: PUSH
62425: LD_INT 58
62427: PUSH
62428: EMPTY
62429: LIST
62430: PUSH
62431: LD_INT 2
62433: PUSH
62434: LD_INT 30
62436: PUSH
62437: LD_INT 32
62439: PUSH
62440: EMPTY
62441: LIST
62442: LIST
62443: PUSH
62444: LD_INT 30
62446: PUSH
62447: LD_INT 4
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: PUSH
62454: LD_INT 30
62456: PUSH
62457: LD_INT 5
62459: PUSH
62460: EMPTY
62461: LIST
62462: LIST
62463: PUSH
62464: EMPTY
62465: LIST
62466: LIST
62467: LIST
62468: LIST
62469: PUSH
62470: EMPTY
62471: LIST
62472: LIST
62473: LIST
62474: PPUSH
62475: CALL_OW 72
62479: ST_TO_ADDR
62480: GO 62704
62482: LD_INT 2
62484: DOUBLE
62485: EQUAL
62486: IFTRUE 62490
62488: GO 62552
62490: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
62491: LD_ADDR_VAR 0 12
62495: PUSH
62496: LD_VAR 0 18
62500: PPUSH
62501: LD_INT 22
62503: PUSH
62504: LD_VAR 0 16
62508: PUSH
62509: EMPTY
62510: LIST
62511: LIST
62512: PUSH
62513: LD_INT 2
62515: PUSH
62516: LD_INT 30
62518: PUSH
62519: LD_INT 0
62521: PUSH
62522: EMPTY
62523: LIST
62524: LIST
62525: PUSH
62526: LD_INT 30
62528: PUSH
62529: LD_INT 1
62531: PUSH
62532: EMPTY
62533: LIST
62534: LIST
62535: PUSH
62536: EMPTY
62537: LIST
62538: LIST
62539: LIST
62540: PUSH
62541: EMPTY
62542: LIST
62543: LIST
62544: PPUSH
62545: CALL_OW 72
62549: ST_TO_ADDR
62550: GO 62704
62552: LD_INT 3
62554: DOUBLE
62555: EQUAL
62556: IFTRUE 62560
62558: GO 62622
62560: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
62561: LD_ADDR_VAR 0 12
62565: PUSH
62566: LD_VAR 0 18
62570: PPUSH
62571: LD_INT 22
62573: PUSH
62574: LD_VAR 0 16
62578: PUSH
62579: EMPTY
62580: LIST
62581: LIST
62582: PUSH
62583: LD_INT 2
62585: PUSH
62586: LD_INT 30
62588: PUSH
62589: LD_INT 2
62591: PUSH
62592: EMPTY
62593: LIST
62594: LIST
62595: PUSH
62596: LD_INT 30
62598: PUSH
62599: LD_INT 3
62601: PUSH
62602: EMPTY
62603: LIST
62604: LIST
62605: PUSH
62606: EMPTY
62607: LIST
62608: LIST
62609: LIST
62610: PUSH
62611: EMPTY
62612: LIST
62613: LIST
62614: PPUSH
62615: CALL_OW 72
62619: ST_TO_ADDR
62620: GO 62704
62622: LD_INT 4
62624: DOUBLE
62625: EQUAL
62626: IFTRUE 62630
62628: GO 62703
62630: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
62631: LD_ADDR_VAR 0 12
62635: PUSH
62636: LD_VAR 0 18
62640: PPUSH
62641: LD_INT 22
62643: PUSH
62644: LD_VAR 0 16
62648: PUSH
62649: EMPTY
62650: LIST
62651: LIST
62652: PUSH
62653: LD_INT 2
62655: PUSH
62656: LD_INT 30
62658: PUSH
62659: LD_INT 6
62661: PUSH
62662: EMPTY
62663: LIST
62664: LIST
62665: PUSH
62666: LD_INT 30
62668: PUSH
62669: LD_INT 7
62671: PUSH
62672: EMPTY
62673: LIST
62674: LIST
62675: PUSH
62676: LD_INT 30
62678: PUSH
62679: LD_INT 8
62681: PUSH
62682: EMPTY
62683: LIST
62684: LIST
62685: PUSH
62686: EMPTY
62687: LIST
62688: LIST
62689: LIST
62690: LIST
62691: PUSH
62692: EMPTY
62693: LIST
62694: LIST
62695: PPUSH
62696: CALL_OW 72
62700: ST_TO_ADDR
62701: GO 62704
62703: POP
// if i = 1 then
62704: LD_VAR 0 8
62708: PUSH
62709: LD_INT 1
62711: EQUAL
62712: IFFALSE 62823
// begin tmp := [ ] ;
62714: LD_ADDR_VAR 0 19
62718: PUSH
62719: EMPTY
62720: ST_TO_ADDR
// for j in f do
62721: LD_ADDR_VAR 0 9
62725: PUSH
62726: LD_VAR 0 12
62730: PUSH
62731: FOR_IN
62732: IFFALSE 62805
// if GetBType ( j ) = b_bunker then
62734: LD_VAR 0 9
62738: PPUSH
62739: CALL_OW 266
62743: PUSH
62744: LD_INT 32
62746: EQUAL
62747: IFFALSE 62774
// tmp := Insert ( tmp , 1 , j ) else
62749: LD_ADDR_VAR 0 19
62753: PUSH
62754: LD_VAR 0 19
62758: PPUSH
62759: LD_INT 1
62761: PPUSH
62762: LD_VAR 0 9
62766: PPUSH
62767: CALL_OW 2
62771: ST_TO_ADDR
62772: GO 62803
// tmp := Insert ( tmp , tmp + 1 , j ) ;
62774: LD_ADDR_VAR 0 19
62778: PUSH
62779: LD_VAR 0 19
62783: PPUSH
62784: LD_VAR 0 19
62788: PUSH
62789: LD_INT 1
62791: PLUS
62792: PPUSH
62793: LD_VAR 0 9
62797: PPUSH
62798: CALL_OW 2
62802: ST_TO_ADDR
62803: GO 62731
62805: POP
62806: POP
// if tmp then
62807: LD_VAR 0 19
62811: IFFALSE 62823
// f := tmp ;
62813: LD_ADDR_VAR 0 12
62817: PUSH
62818: LD_VAR 0 19
62822: ST_TO_ADDR
// end ; x := personel [ i ] ;
62823: LD_ADDR_VAR 0 13
62827: PUSH
62828: LD_VAR 0 6
62832: PUSH
62833: LD_VAR 0 8
62837: ARRAY
62838: ST_TO_ADDR
// if x = - 1 then
62839: LD_VAR 0 13
62843: PUSH
62844: LD_INT 1
62846: NEG
62847: EQUAL
62848: IFFALSE 63057
// begin for j in f do
62850: LD_ADDR_VAR 0 9
62854: PUSH
62855: LD_VAR 0 12
62859: PUSH
62860: FOR_IN
62861: IFFALSE 63053
// repeat InitHc ;
62863: CALL_OW 19
// if GetBType ( j ) = b_barracks then
62867: LD_VAR 0 9
62871: PPUSH
62872: CALL_OW 266
62876: PUSH
62877: LD_INT 5
62879: EQUAL
62880: IFFALSE 62950
// begin if UnitsInside ( j ) < 3 then
62882: LD_VAR 0 9
62886: PPUSH
62887: CALL_OW 313
62891: PUSH
62892: LD_INT 3
62894: LESS
62895: IFFALSE 62931
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62897: LD_INT 0
62899: PPUSH
62900: LD_INT 5
62902: PUSH
62903: LD_INT 8
62905: PUSH
62906: LD_INT 9
62908: PUSH
62909: EMPTY
62910: LIST
62911: LIST
62912: LIST
62913: PUSH
62914: LD_VAR 0 17
62918: ARRAY
62919: PPUSH
62920: LD_VAR 0 4
62924: PPUSH
62925: CALL_OW 380
62929: GO 62948
// PrepareHuman ( false , i , skill ) ;
62931: LD_INT 0
62933: PPUSH
62934: LD_VAR 0 8
62938: PPUSH
62939: LD_VAR 0 4
62943: PPUSH
62944: CALL_OW 380
// end else
62948: GO 62967
// PrepareHuman ( false , i , skill ) ;
62950: LD_INT 0
62952: PPUSH
62953: LD_VAR 0 8
62957: PPUSH
62958: LD_VAR 0 4
62962: PPUSH
62963: CALL_OW 380
// un := CreateHuman ;
62967: LD_ADDR_VAR 0 14
62971: PUSH
62972: CALL_OW 44
62976: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62977: LD_ADDR_VAR 0 7
62981: PUSH
62982: LD_VAR 0 7
62986: PPUSH
62987: LD_INT 1
62989: PPUSH
62990: LD_VAR 0 14
62994: PPUSH
62995: CALL_OW 2
62999: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
63000: LD_VAR 0 14
63004: PPUSH
63005: LD_VAR 0 9
63009: PPUSH
63010: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
63014: LD_VAR 0 9
63018: PPUSH
63019: CALL_OW 313
63023: PUSH
63024: LD_INT 6
63026: EQUAL
63027: PUSH
63028: LD_VAR 0 9
63032: PPUSH
63033: CALL_OW 266
63037: PUSH
63038: LD_INT 32
63040: PUSH
63041: LD_INT 31
63043: PUSH
63044: EMPTY
63045: LIST
63046: LIST
63047: IN
63048: OR
63049: IFFALSE 62863
63051: GO 62860
63053: POP
63054: POP
// end else
63055: GO 63437
// for j = 1 to x do
63057: LD_ADDR_VAR 0 9
63061: PUSH
63062: DOUBLE
63063: LD_INT 1
63065: DEC
63066: ST_TO_ADDR
63067: LD_VAR 0 13
63071: PUSH
63072: FOR_TO
63073: IFFALSE 63435
// begin InitHc ;
63075: CALL_OW 19
// if not f then
63079: LD_VAR 0 12
63083: NOT
63084: IFFALSE 63173
// begin PrepareHuman ( false , i , skill ) ;
63086: LD_INT 0
63088: PPUSH
63089: LD_VAR 0 8
63093: PPUSH
63094: LD_VAR 0 4
63098: PPUSH
63099: CALL_OW 380
// un := CreateHuman ;
63103: LD_ADDR_VAR 0 14
63107: PUSH
63108: CALL_OW 44
63112: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63113: LD_ADDR_VAR 0 7
63117: PUSH
63118: LD_VAR 0 7
63122: PPUSH
63123: LD_INT 1
63125: PPUSH
63126: LD_VAR 0 14
63130: PPUSH
63131: CALL_OW 2
63135: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63136: LD_VAR 0 14
63140: PPUSH
63141: LD_VAR 0 1
63145: PPUSH
63146: CALL_OW 250
63150: PPUSH
63151: LD_VAR 0 1
63155: PPUSH
63156: CALL_OW 251
63160: PPUSH
63161: LD_INT 10
63163: PPUSH
63164: LD_INT 0
63166: PPUSH
63167: CALL_OW 50
// continue ;
63171: GO 63072
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
63173: LD_VAR 0 12
63177: PUSH
63178: LD_INT 1
63180: ARRAY
63181: PPUSH
63182: CALL_OW 313
63186: PUSH
63187: LD_VAR 0 12
63191: PUSH
63192: LD_INT 1
63194: ARRAY
63195: PPUSH
63196: CALL_OW 266
63200: PUSH
63201: LD_INT 32
63203: PUSH
63204: LD_INT 31
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: IN
63211: AND
63212: PUSH
63213: LD_VAR 0 12
63217: PUSH
63218: LD_INT 1
63220: ARRAY
63221: PPUSH
63222: CALL_OW 313
63226: PUSH
63227: LD_INT 6
63229: EQUAL
63230: OR
63231: IFFALSE 63251
// f := Delete ( f , 1 ) ;
63233: LD_ADDR_VAR 0 12
63237: PUSH
63238: LD_VAR 0 12
63242: PPUSH
63243: LD_INT 1
63245: PPUSH
63246: CALL_OW 3
63250: ST_TO_ADDR
// if not f then
63251: LD_VAR 0 12
63255: NOT
63256: IFFALSE 63274
// begin x := x + 2 ;
63258: LD_ADDR_VAR 0 13
63262: PUSH
63263: LD_VAR 0 13
63267: PUSH
63268: LD_INT 2
63270: PLUS
63271: ST_TO_ADDR
// continue ;
63272: GO 63072
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
63274: LD_VAR 0 12
63278: PUSH
63279: LD_INT 1
63281: ARRAY
63282: PPUSH
63283: CALL_OW 266
63287: PUSH
63288: LD_INT 5
63290: EQUAL
63291: IFFALSE 63365
// begin if UnitsInside ( f [ 1 ] ) < 3 then
63293: LD_VAR 0 12
63297: PUSH
63298: LD_INT 1
63300: ARRAY
63301: PPUSH
63302: CALL_OW 313
63306: PUSH
63307: LD_INT 3
63309: LESS
63310: IFFALSE 63346
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
63312: LD_INT 0
63314: PPUSH
63315: LD_INT 5
63317: PUSH
63318: LD_INT 8
63320: PUSH
63321: LD_INT 9
63323: PUSH
63324: EMPTY
63325: LIST
63326: LIST
63327: LIST
63328: PUSH
63329: LD_VAR 0 17
63333: ARRAY
63334: PPUSH
63335: LD_VAR 0 4
63339: PPUSH
63340: CALL_OW 380
63344: GO 63363
// PrepareHuman ( false , i , skill ) ;
63346: LD_INT 0
63348: PPUSH
63349: LD_VAR 0 8
63353: PPUSH
63354: LD_VAR 0 4
63358: PPUSH
63359: CALL_OW 380
// end else
63363: GO 63382
// PrepareHuman ( false , i , skill ) ;
63365: LD_INT 0
63367: PPUSH
63368: LD_VAR 0 8
63372: PPUSH
63373: LD_VAR 0 4
63377: PPUSH
63378: CALL_OW 380
// un := CreateHuman ;
63382: LD_ADDR_VAR 0 14
63386: PUSH
63387: CALL_OW 44
63391: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63392: LD_ADDR_VAR 0 7
63396: PUSH
63397: LD_VAR 0 7
63401: PPUSH
63402: LD_INT 1
63404: PPUSH
63405: LD_VAR 0 14
63409: PPUSH
63410: CALL_OW 2
63414: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
63415: LD_VAR 0 14
63419: PPUSH
63420: LD_VAR 0 12
63424: PUSH
63425: LD_INT 1
63427: ARRAY
63428: PPUSH
63429: CALL_OW 52
// end ;
63433: GO 63072
63435: POP
63436: POP
// end ;
63437: GO 62374
63439: POP
63440: POP
// result := result ^ buildings ;
63441: LD_ADDR_VAR 0 7
63445: PUSH
63446: LD_VAR 0 7
63450: PUSH
63451: LD_VAR 0 18
63455: ADD
63456: ST_TO_ADDR
// end else
63457: GO 63600
// begin for i = 1 to personel do
63459: LD_ADDR_VAR 0 8
63463: PUSH
63464: DOUBLE
63465: LD_INT 1
63467: DEC
63468: ST_TO_ADDR
63469: LD_VAR 0 6
63473: PUSH
63474: FOR_TO
63475: IFFALSE 63598
// begin if i > 4 then
63477: LD_VAR 0 8
63481: PUSH
63482: LD_INT 4
63484: GREATER
63485: IFFALSE 63489
// break ;
63487: GO 63598
// x := personel [ i ] ;
63489: LD_ADDR_VAR 0 13
63493: PUSH
63494: LD_VAR 0 6
63498: PUSH
63499: LD_VAR 0 8
63503: ARRAY
63504: ST_TO_ADDR
// if x = - 1 then
63505: LD_VAR 0 13
63509: PUSH
63510: LD_INT 1
63512: NEG
63513: EQUAL
63514: IFFALSE 63518
// continue ;
63516: GO 63474
// PrepareHuman ( false , i , skill ) ;
63518: LD_INT 0
63520: PPUSH
63521: LD_VAR 0 8
63525: PPUSH
63526: LD_VAR 0 4
63530: PPUSH
63531: CALL_OW 380
// un := CreateHuman ;
63535: LD_ADDR_VAR 0 14
63539: PUSH
63540: CALL_OW 44
63544: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63545: LD_VAR 0 14
63549: PPUSH
63550: LD_VAR 0 1
63554: PPUSH
63555: CALL_OW 250
63559: PPUSH
63560: LD_VAR 0 1
63564: PPUSH
63565: CALL_OW 251
63569: PPUSH
63570: LD_INT 10
63572: PPUSH
63573: LD_INT 0
63575: PPUSH
63576: CALL_OW 50
// result := result ^ un ;
63580: LD_ADDR_VAR 0 7
63584: PUSH
63585: LD_VAR 0 7
63589: PUSH
63590: LD_VAR 0 14
63594: ADD
63595: ST_TO_ADDR
// end ;
63596: GO 63474
63598: POP
63599: POP
// end ; end ;
63600: LD_VAR 0 7
63604: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
63605: LD_INT 0
63607: PPUSH
63608: PPUSH
63609: PPUSH
63610: PPUSH
63611: PPUSH
63612: PPUSH
63613: PPUSH
63614: PPUSH
63615: PPUSH
63616: PPUSH
63617: PPUSH
63618: PPUSH
63619: PPUSH
63620: PPUSH
63621: PPUSH
63622: PPUSH
// result := false ;
63623: LD_ADDR_VAR 0 3
63627: PUSH
63628: LD_INT 0
63630: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
63631: LD_VAR 0 1
63635: NOT
63636: PUSH
63637: LD_VAR 0 1
63641: PPUSH
63642: CALL_OW 266
63646: PUSH
63647: LD_INT 32
63649: PUSH
63650: LD_INT 33
63652: PUSH
63653: EMPTY
63654: LIST
63655: LIST
63656: IN
63657: NOT
63658: OR
63659: IFFALSE 63663
// exit ;
63661: GO 64772
// nat := GetNation ( tower ) ;
63663: LD_ADDR_VAR 0 12
63667: PUSH
63668: LD_VAR 0 1
63672: PPUSH
63673: CALL_OW 248
63677: ST_TO_ADDR
// side := GetSide ( tower ) ;
63678: LD_ADDR_VAR 0 16
63682: PUSH
63683: LD_VAR 0 1
63687: PPUSH
63688: CALL_OW 255
63692: ST_TO_ADDR
// x := GetX ( tower ) ;
63693: LD_ADDR_VAR 0 10
63697: PUSH
63698: LD_VAR 0 1
63702: PPUSH
63703: CALL_OW 250
63707: ST_TO_ADDR
// y := GetY ( tower ) ;
63708: LD_ADDR_VAR 0 11
63712: PUSH
63713: LD_VAR 0 1
63717: PPUSH
63718: CALL_OW 251
63722: ST_TO_ADDR
// if not x or not y then
63723: LD_VAR 0 10
63727: NOT
63728: PUSH
63729: LD_VAR 0 11
63733: NOT
63734: OR
63735: IFFALSE 63739
// exit ;
63737: GO 64772
// weapon := 0 ;
63739: LD_ADDR_VAR 0 18
63743: PUSH
63744: LD_INT 0
63746: ST_TO_ADDR
// fac_list := [ ] ;
63747: LD_ADDR_VAR 0 17
63751: PUSH
63752: EMPTY
63753: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
63754: LD_ADDR_VAR 0 6
63758: PUSH
63759: LD_VAR 0 1
63763: PPUSH
63764: CALL_OW 274
63768: PPUSH
63769: LD_VAR 0 2
63773: PPUSH
63774: LD_INT 0
63776: PPUSH
63777: CALL 61343 0 3
63781: PPUSH
63782: LD_INT 30
63784: PUSH
63785: LD_INT 3
63787: PUSH
63788: EMPTY
63789: LIST
63790: LIST
63791: PPUSH
63792: CALL_OW 72
63796: ST_TO_ADDR
// if not factories then
63797: LD_VAR 0 6
63801: NOT
63802: IFFALSE 63806
// exit ;
63804: GO 64772
// for i in factories do
63806: LD_ADDR_VAR 0 8
63810: PUSH
63811: LD_VAR 0 6
63815: PUSH
63816: FOR_IN
63817: IFFALSE 63842
// fac_list := fac_list union AvailableWeaponList ( i ) ;
63819: LD_ADDR_VAR 0 17
63823: PUSH
63824: LD_VAR 0 17
63828: PUSH
63829: LD_VAR 0 8
63833: PPUSH
63834: CALL_OW 478
63838: UNION
63839: ST_TO_ADDR
63840: GO 63816
63842: POP
63843: POP
// if not fac_list then
63844: LD_VAR 0 17
63848: NOT
63849: IFFALSE 63853
// exit ;
63851: GO 64772
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
63853: LD_ADDR_VAR 0 5
63857: PUSH
63858: LD_INT 4
63860: PUSH
63861: LD_INT 5
63863: PUSH
63864: LD_INT 9
63866: PUSH
63867: LD_INT 10
63869: PUSH
63870: LD_INT 6
63872: PUSH
63873: LD_INT 7
63875: PUSH
63876: LD_INT 11
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: LIST
63883: LIST
63884: LIST
63885: LIST
63886: LIST
63887: PUSH
63888: LD_INT 27
63890: PUSH
63891: LD_INT 28
63893: PUSH
63894: LD_INT 26
63896: PUSH
63897: LD_INT 30
63899: PUSH
63900: EMPTY
63901: LIST
63902: LIST
63903: LIST
63904: LIST
63905: PUSH
63906: LD_INT 43
63908: PUSH
63909: LD_INT 44
63911: PUSH
63912: LD_INT 46
63914: PUSH
63915: LD_INT 45
63917: PUSH
63918: LD_INT 47
63920: PUSH
63921: LD_INT 49
63923: PUSH
63924: EMPTY
63925: LIST
63926: LIST
63927: LIST
63928: LIST
63929: LIST
63930: LIST
63931: PUSH
63932: EMPTY
63933: LIST
63934: LIST
63935: LIST
63936: PUSH
63937: LD_VAR 0 12
63941: ARRAY
63942: ST_TO_ADDR
// list := list isect fac_list ;
63943: LD_ADDR_VAR 0 5
63947: PUSH
63948: LD_VAR 0 5
63952: PUSH
63953: LD_VAR 0 17
63957: ISECT
63958: ST_TO_ADDR
// if not list then
63959: LD_VAR 0 5
63963: NOT
63964: IFFALSE 63968
// exit ;
63966: GO 64772
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63968: LD_VAR 0 12
63972: PUSH
63973: LD_INT 3
63975: EQUAL
63976: PUSH
63977: LD_INT 49
63979: PUSH
63980: LD_VAR 0 5
63984: IN
63985: AND
63986: PUSH
63987: LD_INT 31
63989: PPUSH
63990: LD_VAR 0 16
63994: PPUSH
63995: CALL_OW 321
63999: PUSH
64000: LD_INT 2
64002: EQUAL
64003: AND
64004: IFFALSE 64064
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
64006: LD_INT 22
64008: PUSH
64009: LD_VAR 0 16
64013: PUSH
64014: EMPTY
64015: LIST
64016: LIST
64017: PUSH
64018: LD_INT 35
64020: PUSH
64021: LD_INT 49
64023: PUSH
64024: EMPTY
64025: LIST
64026: LIST
64027: PUSH
64028: LD_INT 91
64030: PUSH
64031: LD_VAR 0 1
64035: PUSH
64036: LD_INT 10
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: LIST
64043: PUSH
64044: EMPTY
64045: LIST
64046: LIST
64047: LIST
64048: PPUSH
64049: CALL_OW 69
64053: NOT
64054: IFFALSE 64064
// weapon := ru_time_lapser ;
64056: LD_ADDR_VAR 0 18
64060: PUSH
64061: LD_INT 49
64063: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
64064: LD_VAR 0 12
64068: PUSH
64069: LD_INT 1
64071: PUSH
64072: LD_INT 2
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: IN
64079: PUSH
64080: LD_INT 11
64082: PUSH
64083: LD_VAR 0 5
64087: IN
64088: PUSH
64089: LD_INT 30
64091: PUSH
64092: LD_VAR 0 5
64096: IN
64097: OR
64098: AND
64099: PUSH
64100: LD_INT 6
64102: PPUSH
64103: LD_VAR 0 16
64107: PPUSH
64108: CALL_OW 321
64112: PUSH
64113: LD_INT 2
64115: EQUAL
64116: AND
64117: IFFALSE 64282
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
64119: LD_INT 22
64121: PUSH
64122: LD_VAR 0 16
64126: PUSH
64127: EMPTY
64128: LIST
64129: LIST
64130: PUSH
64131: LD_INT 2
64133: PUSH
64134: LD_INT 35
64136: PUSH
64137: LD_INT 11
64139: PUSH
64140: EMPTY
64141: LIST
64142: LIST
64143: PUSH
64144: LD_INT 35
64146: PUSH
64147: LD_INT 30
64149: PUSH
64150: EMPTY
64151: LIST
64152: LIST
64153: PUSH
64154: EMPTY
64155: LIST
64156: LIST
64157: LIST
64158: PUSH
64159: LD_INT 91
64161: PUSH
64162: LD_VAR 0 1
64166: PUSH
64167: LD_INT 18
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: LIST
64174: PUSH
64175: EMPTY
64176: LIST
64177: LIST
64178: LIST
64179: PPUSH
64180: CALL_OW 69
64184: NOT
64185: PUSH
64186: LD_INT 22
64188: PUSH
64189: LD_VAR 0 16
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: LD_INT 2
64200: PUSH
64201: LD_INT 30
64203: PUSH
64204: LD_INT 32
64206: PUSH
64207: EMPTY
64208: LIST
64209: LIST
64210: PUSH
64211: LD_INT 30
64213: PUSH
64214: LD_INT 33
64216: PUSH
64217: EMPTY
64218: LIST
64219: LIST
64220: PUSH
64221: EMPTY
64222: LIST
64223: LIST
64224: LIST
64225: PUSH
64226: LD_INT 91
64228: PUSH
64229: LD_VAR 0 1
64233: PUSH
64234: LD_INT 12
64236: PUSH
64237: EMPTY
64238: LIST
64239: LIST
64240: LIST
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: LIST
64246: PUSH
64247: EMPTY
64248: LIST
64249: PPUSH
64250: CALL_OW 69
64254: PUSH
64255: LD_INT 2
64257: GREATER
64258: AND
64259: IFFALSE 64282
// weapon := [ us_radar , ar_radar ] [ nat ] ;
64261: LD_ADDR_VAR 0 18
64265: PUSH
64266: LD_INT 11
64268: PUSH
64269: LD_INT 30
64271: PUSH
64272: EMPTY
64273: LIST
64274: LIST
64275: PUSH
64276: LD_VAR 0 12
64280: ARRAY
64281: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
64282: LD_VAR 0 18
64286: NOT
64287: PUSH
64288: LD_INT 40
64290: PPUSH
64291: LD_VAR 0 16
64295: PPUSH
64296: CALL_OW 321
64300: PUSH
64301: LD_INT 2
64303: EQUAL
64304: AND
64305: PUSH
64306: LD_INT 7
64308: PUSH
64309: LD_VAR 0 5
64313: IN
64314: PUSH
64315: LD_INT 28
64317: PUSH
64318: LD_VAR 0 5
64322: IN
64323: OR
64324: PUSH
64325: LD_INT 45
64327: PUSH
64328: LD_VAR 0 5
64332: IN
64333: OR
64334: AND
64335: IFFALSE 64589
// begin hex := GetHexInfo ( x , y ) ;
64337: LD_ADDR_VAR 0 4
64341: PUSH
64342: LD_VAR 0 10
64346: PPUSH
64347: LD_VAR 0 11
64351: PPUSH
64352: CALL_OW 546
64356: ST_TO_ADDR
// if hex [ 1 ] then
64357: LD_VAR 0 4
64361: PUSH
64362: LD_INT 1
64364: ARRAY
64365: IFFALSE 64369
// exit ;
64367: GO 64772
// height := hex [ 2 ] ;
64369: LD_ADDR_VAR 0 15
64373: PUSH
64374: LD_VAR 0 4
64378: PUSH
64379: LD_INT 2
64381: ARRAY
64382: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
64383: LD_ADDR_VAR 0 14
64387: PUSH
64388: LD_INT 0
64390: PUSH
64391: LD_INT 2
64393: PUSH
64394: LD_INT 3
64396: PUSH
64397: LD_INT 5
64399: PUSH
64400: EMPTY
64401: LIST
64402: LIST
64403: LIST
64404: LIST
64405: ST_TO_ADDR
// for i in tmp do
64406: LD_ADDR_VAR 0 8
64410: PUSH
64411: LD_VAR 0 14
64415: PUSH
64416: FOR_IN
64417: IFFALSE 64587
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
64419: LD_ADDR_VAR 0 9
64423: PUSH
64424: LD_VAR 0 10
64428: PPUSH
64429: LD_VAR 0 8
64433: PPUSH
64434: LD_INT 5
64436: PPUSH
64437: CALL_OW 272
64441: PUSH
64442: LD_VAR 0 11
64446: PPUSH
64447: LD_VAR 0 8
64451: PPUSH
64452: LD_INT 5
64454: PPUSH
64455: CALL_OW 273
64459: PUSH
64460: EMPTY
64461: LIST
64462: LIST
64463: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
64464: LD_VAR 0 9
64468: PUSH
64469: LD_INT 1
64471: ARRAY
64472: PPUSH
64473: LD_VAR 0 9
64477: PUSH
64478: LD_INT 2
64480: ARRAY
64481: PPUSH
64482: CALL_OW 488
64486: IFFALSE 64585
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
64488: LD_ADDR_VAR 0 4
64492: PUSH
64493: LD_VAR 0 9
64497: PUSH
64498: LD_INT 1
64500: ARRAY
64501: PPUSH
64502: LD_VAR 0 9
64506: PUSH
64507: LD_INT 2
64509: ARRAY
64510: PPUSH
64511: CALL_OW 546
64515: ST_TO_ADDR
// if hex [ 1 ] then
64516: LD_VAR 0 4
64520: PUSH
64521: LD_INT 1
64523: ARRAY
64524: IFFALSE 64528
// continue ;
64526: GO 64416
// h := hex [ 2 ] ;
64528: LD_ADDR_VAR 0 13
64532: PUSH
64533: LD_VAR 0 4
64537: PUSH
64538: LD_INT 2
64540: ARRAY
64541: ST_TO_ADDR
// if h + 7 < height then
64542: LD_VAR 0 13
64546: PUSH
64547: LD_INT 7
64549: PLUS
64550: PUSH
64551: LD_VAR 0 15
64555: LESS
64556: IFFALSE 64585
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
64558: LD_ADDR_VAR 0 18
64562: PUSH
64563: LD_INT 7
64565: PUSH
64566: LD_INT 28
64568: PUSH
64569: LD_INT 45
64571: PUSH
64572: EMPTY
64573: LIST
64574: LIST
64575: LIST
64576: PUSH
64577: LD_VAR 0 12
64581: ARRAY
64582: ST_TO_ADDR
// break ;
64583: GO 64587
// end ; end ; end ;
64585: GO 64416
64587: POP
64588: POP
// end ; if not weapon then
64589: LD_VAR 0 18
64593: NOT
64594: IFFALSE 64654
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
64596: LD_ADDR_VAR 0 5
64600: PUSH
64601: LD_VAR 0 5
64605: PUSH
64606: LD_INT 11
64608: PUSH
64609: LD_INT 30
64611: PUSH
64612: LD_INT 49
64614: PUSH
64615: EMPTY
64616: LIST
64617: LIST
64618: LIST
64619: DIFF
64620: ST_TO_ADDR
// if not list then
64621: LD_VAR 0 5
64625: NOT
64626: IFFALSE 64630
// exit ;
64628: GO 64772
// weapon := list [ rand ( 1 , list ) ] ;
64630: LD_ADDR_VAR 0 18
64634: PUSH
64635: LD_VAR 0 5
64639: PUSH
64640: LD_INT 1
64642: PPUSH
64643: LD_VAR 0 5
64647: PPUSH
64648: CALL_OW 12
64652: ARRAY
64653: ST_TO_ADDR
// end ; if weapon then
64654: LD_VAR 0 18
64658: IFFALSE 64772
// begin tmp := CostOfWeapon ( weapon ) ;
64660: LD_ADDR_VAR 0 14
64664: PUSH
64665: LD_VAR 0 18
64669: PPUSH
64670: CALL_OW 451
64674: ST_TO_ADDR
// j := GetBase ( tower ) ;
64675: LD_ADDR_VAR 0 9
64679: PUSH
64680: LD_VAR 0 1
64684: PPUSH
64685: CALL_OW 274
64689: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
64690: LD_VAR 0 9
64694: PPUSH
64695: LD_INT 1
64697: PPUSH
64698: CALL_OW 275
64702: PUSH
64703: LD_VAR 0 14
64707: PUSH
64708: LD_INT 1
64710: ARRAY
64711: GREATEREQUAL
64712: PUSH
64713: LD_VAR 0 9
64717: PPUSH
64718: LD_INT 2
64720: PPUSH
64721: CALL_OW 275
64725: PUSH
64726: LD_VAR 0 14
64730: PUSH
64731: LD_INT 2
64733: ARRAY
64734: GREATEREQUAL
64735: AND
64736: PUSH
64737: LD_VAR 0 9
64741: PPUSH
64742: LD_INT 3
64744: PPUSH
64745: CALL_OW 275
64749: PUSH
64750: LD_VAR 0 14
64754: PUSH
64755: LD_INT 3
64757: ARRAY
64758: GREATEREQUAL
64759: AND
64760: IFFALSE 64772
// result := weapon ;
64762: LD_ADDR_VAR 0 3
64766: PUSH
64767: LD_VAR 0 18
64771: ST_TO_ADDR
// end ; end ;
64772: LD_VAR 0 3
64776: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
64777: LD_INT 0
64779: PPUSH
64780: PPUSH
// result := true ;
64781: LD_ADDR_VAR 0 3
64785: PUSH
64786: LD_INT 1
64788: ST_TO_ADDR
// if array1 = array2 then
64789: LD_VAR 0 1
64793: PUSH
64794: LD_VAR 0 2
64798: EQUAL
64799: IFFALSE 64859
// begin for i = 1 to array1 do
64801: LD_ADDR_VAR 0 4
64805: PUSH
64806: DOUBLE
64807: LD_INT 1
64809: DEC
64810: ST_TO_ADDR
64811: LD_VAR 0 1
64815: PUSH
64816: FOR_TO
64817: IFFALSE 64855
// if array1 [ i ] <> array2 [ i ] then
64819: LD_VAR 0 1
64823: PUSH
64824: LD_VAR 0 4
64828: ARRAY
64829: PUSH
64830: LD_VAR 0 2
64834: PUSH
64835: LD_VAR 0 4
64839: ARRAY
64840: NONEQUAL
64841: IFFALSE 64853
// begin result := false ;
64843: LD_ADDR_VAR 0 3
64847: PUSH
64848: LD_INT 0
64850: ST_TO_ADDR
// break ;
64851: GO 64855
// end ;
64853: GO 64816
64855: POP
64856: POP
// end else
64857: GO 64867
// result := false ;
64859: LD_ADDR_VAR 0 3
64863: PUSH
64864: LD_INT 0
64866: ST_TO_ADDR
// end ;
64867: LD_VAR 0 3
64871: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
64872: LD_INT 0
64874: PPUSH
64875: PPUSH
// if not array1 or not array2 then
64876: LD_VAR 0 1
64880: NOT
64881: PUSH
64882: LD_VAR 0 2
64886: NOT
64887: OR
64888: IFFALSE 64892
// exit ;
64890: GO 64956
// result := true ;
64892: LD_ADDR_VAR 0 3
64896: PUSH
64897: LD_INT 1
64899: ST_TO_ADDR
// for i = 1 to array1 do
64900: LD_ADDR_VAR 0 4
64904: PUSH
64905: DOUBLE
64906: LD_INT 1
64908: DEC
64909: ST_TO_ADDR
64910: LD_VAR 0 1
64914: PUSH
64915: FOR_TO
64916: IFFALSE 64954
// if array1 [ i ] <> array2 [ i ] then
64918: LD_VAR 0 1
64922: PUSH
64923: LD_VAR 0 4
64927: ARRAY
64928: PUSH
64929: LD_VAR 0 2
64933: PUSH
64934: LD_VAR 0 4
64938: ARRAY
64939: NONEQUAL
64940: IFFALSE 64952
// begin result := false ;
64942: LD_ADDR_VAR 0 3
64946: PUSH
64947: LD_INT 0
64949: ST_TO_ADDR
// break ;
64950: GO 64954
// end ;
64952: GO 64915
64954: POP
64955: POP
// end ;
64956: LD_VAR 0 3
64960: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
64961: LD_INT 0
64963: PPUSH
64964: PPUSH
64965: PPUSH
// pom := GetBase ( fac ) ;
64966: LD_ADDR_VAR 0 5
64970: PUSH
64971: LD_VAR 0 1
64975: PPUSH
64976: CALL_OW 274
64980: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
64981: LD_ADDR_VAR 0 4
64985: PUSH
64986: LD_VAR 0 2
64990: PUSH
64991: LD_INT 1
64993: ARRAY
64994: PPUSH
64995: LD_VAR 0 2
64999: PUSH
65000: LD_INT 2
65002: ARRAY
65003: PPUSH
65004: LD_VAR 0 2
65008: PUSH
65009: LD_INT 3
65011: ARRAY
65012: PPUSH
65013: LD_VAR 0 2
65017: PUSH
65018: LD_INT 4
65020: ARRAY
65021: PPUSH
65022: CALL_OW 449
65026: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65027: LD_ADDR_VAR 0 3
65031: PUSH
65032: LD_VAR 0 5
65036: PPUSH
65037: LD_INT 1
65039: PPUSH
65040: CALL_OW 275
65044: PUSH
65045: LD_VAR 0 4
65049: PUSH
65050: LD_INT 1
65052: ARRAY
65053: GREATEREQUAL
65054: PUSH
65055: LD_VAR 0 5
65059: PPUSH
65060: LD_INT 2
65062: PPUSH
65063: CALL_OW 275
65067: PUSH
65068: LD_VAR 0 4
65072: PUSH
65073: LD_INT 2
65075: ARRAY
65076: GREATEREQUAL
65077: AND
65078: PUSH
65079: LD_VAR 0 5
65083: PPUSH
65084: LD_INT 3
65086: PPUSH
65087: CALL_OW 275
65091: PUSH
65092: LD_VAR 0 4
65096: PUSH
65097: LD_INT 3
65099: ARRAY
65100: GREATEREQUAL
65101: AND
65102: ST_TO_ADDR
// end ;
65103: LD_VAR 0 3
65107: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
65108: LD_INT 0
65110: PPUSH
65111: PPUSH
65112: PPUSH
65113: PPUSH
// pom := GetBase ( building ) ;
65114: LD_ADDR_VAR 0 3
65118: PUSH
65119: LD_VAR 0 1
65123: PPUSH
65124: CALL_OW 274
65128: ST_TO_ADDR
// if not pom then
65129: LD_VAR 0 3
65133: NOT
65134: IFFALSE 65138
// exit ;
65136: GO 65308
// btype := GetBType ( building ) ;
65138: LD_ADDR_VAR 0 5
65142: PUSH
65143: LD_VAR 0 1
65147: PPUSH
65148: CALL_OW 266
65152: ST_TO_ADDR
// if btype = b_armoury then
65153: LD_VAR 0 5
65157: PUSH
65158: LD_INT 4
65160: EQUAL
65161: IFFALSE 65171
// btype := b_barracks ;
65163: LD_ADDR_VAR 0 5
65167: PUSH
65168: LD_INT 5
65170: ST_TO_ADDR
// if btype = b_depot then
65171: LD_VAR 0 5
65175: PUSH
65176: LD_INT 0
65178: EQUAL
65179: IFFALSE 65189
// btype := b_warehouse ;
65181: LD_ADDR_VAR 0 5
65185: PUSH
65186: LD_INT 1
65188: ST_TO_ADDR
// if btype = b_workshop then
65189: LD_VAR 0 5
65193: PUSH
65194: LD_INT 2
65196: EQUAL
65197: IFFALSE 65207
// btype := b_factory ;
65199: LD_ADDR_VAR 0 5
65203: PUSH
65204: LD_INT 3
65206: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65207: LD_ADDR_VAR 0 4
65211: PUSH
65212: LD_VAR 0 5
65216: PPUSH
65217: LD_VAR 0 1
65221: PPUSH
65222: CALL_OW 248
65226: PPUSH
65227: CALL_OW 450
65231: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65232: LD_ADDR_VAR 0 2
65236: PUSH
65237: LD_VAR 0 3
65241: PPUSH
65242: LD_INT 1
65244: PPUSH
65245: CALL_OW 275
65249: PUSH
65250: LD_VAR 0 4
65254: PUSH
65255: LD_INT 1
65257: ARRAY
65258: GREATEREQUAL
65259: PUSH
65260: LD_VAR 0 3
65264: PPUSH
65265: LD_INT 2
65267: PPUSH
65268: CALL_OW 275
65272: PUSH
65273: LD_VAR 0 4
65277: PUSH
65278: LD_INT 2
65280: ARRAY
65281: GREATEREQUAL
65282: AND
65283: PUSH
65284: LD_VAR 0 3
65288: PPUSH
65289: LD_INT 3
65291: PPUSH
65292: CALL_OW 275
65296: PUSH
65297: LD_VAR 0 4
65301: PUSH
65302: LD_INT 3
65304: ARRAY
65305: GREATEREQUAL
65306: AND
65307: ST_TO_ADDR
// end ;
65308: LD_VAR 0 2
65312: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
65313: LD_INT 0
65315: PPUSH
65316: PPUSH
65317: PPUSH
// pom := GetBase ( building ) ;
65318: LD_ADDR_VAR 0 4
65322: PUSH
65323: LD_VAR 0 1
65327: PPUSH
65328: CALL_OW 274
65332: ST_TO_ADDR
// if not pom then
65333: LD_VAR 0 4
65337: NOT
65338: IFFALSE 65342
// exit ;
65340: GO 65443
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65342: LD_ADDR_VAR 0 5
65346: PUSH
65347: LD_VAR 0 2
65351: PPUSH
65352: LD_VAR 0 1
65356: PPUSH
65357: CALL_OW 248
65361: PPUSH
65362: CALL_OW 450
65366: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65367: LD_ADDR_VAR 0 3
65371: PUSH
65372: LD_VAR 0 4
65376: PPUSH
65377: LD_INT 1
65379: PPUSH
65380: CALL_OW 275
65384: PUSH
65385: LD_VAR 0 5
65389: PUSH
65390: LD_INT 1
65392: ARRAY
65393: GREATEREQUAL
65394: PUSH
65395: LD_VAR 0 4
65399: PPUSH
65400: LD_INT 2
65402: PPUSH
65403: CALL_OW 275
65407: PUSH
65408: LD_VAR 0 5
65412: PUSH
65413: LD_INT 2
65415: ARRAY
65416: GREATEREQUAL
65417: AND
65418: PUSH
65419: LD_VAR 0 4
65423: PPUSH
65424: LD_INT 3
65426: PPUSH
65427: CALL_OW 275
65431: PUSH
65432: LD_VAR 0 5
65436: PUSH
65437: LD_INT 3
65439: ARRAY
65440: GREATEREQUAL
65441: AND
65442: ST_TO_ADDR
// end ;
65443: LD_VAR 0 3
65447: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
65448: LD_INT 0
65450: PPUSH
65451: PPUSH
65452: PPUSH
65453: PPUSH
65454: PPUSH
65455: PPUSH
65456: PPUSH
65457: PPUSH
65458: PPUSH
65459: PPUSH
65460: PPUSH
// result := false ;
65461: LD_ADDR_VAR 0 8
65465: PUSH
65466: LD_INT 0
65468: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
65469: LD_VAR 0 5
65473: NOT
65474: PUSH
65475: LD_VAR 0 1
65479: NOT
65480: OR
65481: PUSH
65482: LD_VAR 0 2
65486: NOT
65487: OR
65488: PUSH
65489: LD_VAR 0 3
65493: NOT
65494: OR
65495: IFFALSE 65499
// exit ;
65497: GO 66313
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
65499: LD_ADDR_VAR 0 14
65503: PUSH
65504: LD_VAR 0 1
65508: PPUSH
65509: LD_VAR 0 2
65513: PPUSH
65514: LD_VAR 0 3
65518: PPUSH
65519: LD_VAR 0 4
65523: PPUSH
65524: LD_VAR 0 5
65528: PUSH
65529: LD_INT 1
65531: ARRAY
65532: PPUSH
65533: CALL_OW 248
65537: PPUSH
65538: LD_INT 0
65540: PPUSH
65541: CALL 67566 0 6
65545: ST_TO_ADDR
// if not hexes then
65546: LD_VAR 0 14
65550: NOT
65551: IFFALSE 65555
// exit ;
65553: GO 66313
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
65555: LD_ADDR_VAR 0 17
65559: PUSH
65560: LD_VAR 0 5
65564: PPUSH
65565: LD_INT 22
65567: PUSH
65568: LD_VAR 0 13
65572: PPUSH
65573: CALL_OW 255
65577: PUSH
65578: EMPTY
65579: LIST
65580: LIST
65581: PUSH
65582: LD_INT 2
65584: PUSH
65585: LD_INT 30
65587: PUSH
65588: LD_INT 0
65590: PUSH
65591: EMPTY
65592: LIST
65593: LIST
65594: PUSH
65595: LD_INT 30
65597: PUSH
65598: LD_INT 1
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: LIST
65609: PUSH
65610: EMPTY
65611: LIST
65612: LIST
65613: PPUSH
65614: CALL_OW 72
65618: ST_TO_ADDR
// for i = 1 to hexes do
65619: LD_ADDR_VAR 0 9
65623: PUSH
65624: DOUBLE
65625: LD_INT 1
65627: DEC
65628: ST_TO_ADDR
65629: LD_VAR 0 14
65633: PUSH
65634: FOR_TO
65635: IFFALSE 66311
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65637: LD_ADDR_VAR 0 13
65641: PUSH
65642: LD_VAR 0 14
65646: PUSH
65647: LD_VAR 0 9
65651: ARRAY
65652: PUSH
65653: LD_INT 1
65655: ARRAY
65656: PPUSH
65657: LD_VAR 0 14
65661: PUSH
65662: LD_VAR 0 9
65666: ARRAY
65667: PUSH
65668: LD_INT 2
65670: ARRAY
65671: PPUSH
65672: CALL_OW 428
65676: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
65677: LD_VAR 0 14
65681: PUSH
65682: LD_VAR 0 9
65686: ARRAY
65687: PUSH
65688: LD_INT 1
65690: ARRAY
65691: PPUSH
65692: LD_VAR 0 14
65696: PUSH
65697: LD_VAR 0 9
65701: ARRAY
65702: PUSH
65703: LD_INT 2
65705: ARRAY
65706: PPUSH
65707: CALL_OW 351
65711: PUSH
65712: LD_VAR 0 14
65716: PUSH
65717: LD_VAR 0 9
65721: ARRAY
65722: PUSH
65723: LD_INT 1
65725: ARRAY
65726: PPUSH
65727: LD_VAR 0 14
65731: PUSH
65732: LD_VAR 0 9
65736: ARRAY
65737: PUSH
65738: LD_INT 2
65740: ARRAY
65741: PPUSH
65742: CALL_OW 488
65746: NOT
65747: OR
65748: PUSH
65749: LD_VAR 0 13
65753: PPUSH
65754: CALL_OW 247
65758: PUSH
65759: LD_INT 3
65761: EQUAL
65762: OR
65763: IFFALSE 65769
// exit ;
65765: POP
65766: POP
65767: GO 66313
// if not tmp then
65769: LD_VAR 0 13
65773: NOT
65774: IFFALSE 65778
// continue ;
65776: GO 65634
// result := true ;
65778: LD_ADDR_VAR 0 8
65782: PUSH
65783: LD_INT 1
65785: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
65786: LD_VAR 0 6
65790: PUSH
65791: LD_VAR 0 13
65795: PPUSH
65796: CALL_OW 247
65800: PUSH
65801: LD_INT 2
65803: EQUAL
65804: AND
65805: PUSH
65806: LD_VAR 0 13
65810: PPUSH
65811: CALL_OW 263
65815: PUSH
65816: LD_INT 1
65818: EQUAL
65819: AND
65820: IFFALSE 65984
// begin if IsDrivenBy ( tmp ) then
65822: LD_VAR 0 13
65826: PPUSH
65827: CALL_OW 311
65831: IFFALSE 65835
// continue ;
65833: GO 65634
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
65835: LD_VAR 0 6
65839: PPUSH
65840: LD_INT 3
65842: PUSH
65843: LD_INT 60
65845: PUSH
65846: EMPTY
65847: LIST
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: LD_INT 3
65855: PUSH
65856: LD_INT 55
65858: PUSH
65859: EMPTY
65860: LIST
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: PPUSH
65870: CALL_OW 72
65874: IFFALSE 65982
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
65876: LD_ADDR_VAR 0 18
65880: PUSH
65881: LD_VAR 0 6
65885: PPUSH
65886: LD_INT 3
65888: PUSH
65889: LD_INT 60
65891: PUSH
65892: EMPTY
65893: LIST
65894: PUSH
65895: EMPTY
65896: LIST
65897: LIST
65898: PUSH
65899: LD_INT 3
65901: PUSH
65902: LD_INT 55
65904: PUSH
65905: EMPTY
65906: LIST
65907: PUSH
65908: EMPTY
65909: LIST
65910: LIST
65911: PUSH
65912: EMPTY
65913: LIST
65914: LIST
65915: PPUSH
65916: CALL_OW 72
65920: PUSH
65921: LD_INT 1
65923: ARRAY
65924: ST_TO_ADDR
// if IsInUnit ( driver ) then
65925: LD_VAR 0 18
65929: PPUSH
65930: CALL_OW 310
65934: IFFALSE 65945
// ComExit ( driver ) ;
65936: LD_VAR 0 18
65940: PPUSH
65941: CALL 91358 0 1
// AddComEnterUnit ( driver , tmp ) ;
65945: LD_VAR 0 18
65949: PPUSH
65950: LD_VAR 0 13
65954: PPUSH
65955: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
65959: LD_VAR 0 18
65963: PPUSH
65964: LD_VAR 0 7
65968: PPUSH
65969: CALL_OW 173
// AddComExitVehicle ( driver ) ;
65973: LD_VAR 0 18
65977: PPUSH
65978: CALL_OW 181
// end ; continue ;
65982: GO 65634
// end ; if not cleaners or not tmp in cleaners then
65984: LD_VAR 0 6
65988: NOT
65989: PUSH
65990: LD_VAR 0 13
65994: PUSH
65995: LD_VAR 0 6
65999: IN
66000: NOT
66001: OR
66002: IFFALSE 66309
// begin if dep then
66004: LD_VAR 0 17
66008: IFFALSE 66144
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
66010: LD_ADDR_VAR 0 16
66014: PUSH
66015: LD_VAR 0 17
66019: PUSH
66020: LD_INT 1
66022: ARRAY
66023: PPUSH
66024: CALL_OW 250
66028: PPUSH
66029: LD_VAR 0 17
66033: PUSH
66034: LD_INT 1
66036: ARRAY
66037: PPUSH
66038: CALL_OW 254
66042: PPUSH
66043: LD_INT 5
66045: PPUSH
66046: CALL_OW 272
66050: PUSH
66051: LD_VAR 0 17
66055: PUSH
66056: LD_INT 1
66058: ARRAY
66059: PPUSH
66060: CALL_OW 251
66064: PPUSH
66065: LD_VAR 0 17
66069: PUSH
66070: LD_INT 1
66072: ARRAY
66073: PPUSH
66074: CALL_OW 254
66078: PPUSH
66079: LD_INT 5
66081: PPUSH
66082: CALL_OW 273
66086: PUSH
66087: EMPTY
66088: LIST
66089: LIST
66090: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
66091: LD_VAR 0 16
66095: PUSH
66096: LD_INT 1
66098: ARRAY
66099: PPUSH
66100: LD_VAR 0 16
66104: PUSH
66105: LD_INT 2
66107: ARRAY
66108: PPUSH
66109: CALL_OW 488
66113: IFFALSE 66144
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
66115: LD_VAR 0 13
66119: PPUSH
66120: LD_VAR 0 16
66124: PUSH
66125: LD_INT 1
66127: ARRAY
66128: PPUSH
66129: LD_VAR 0 16
66133: PUSH
66134: LD_INT 2
66136: ARRAY
66137: PPUSH
66138: CALL_OW 111
// continue ;
66142: GO 65634
// end ; end ; r := GetDir ( tmp ) ;
66144: LD_ADDR_VAR 0 15
66148: PUSH
66149: LD_VAR 0 13
66153: PPUSH
66154: CALL_OW 254
66158: ST_TO_ADDR
// if r = 5 then
66159: LD_VAR 0 15
66163: PUSH
66164: LD_INT 5
66166: EQUAL
66167: IFFALSE 66177
// r := 0 ;
66169: LD_ADDR_VAR 0 15
66173: PUSH
66174: LD_INT 0
66176: ST_TO_ADDR
// for j = r to 5 do
66177: LD_ADDR_VAR 0 10
66181: PUSH
66182: DOUBLE
66183: LD_VAR 0 15
66187: DEC
66188: ST_TO_ADDR
66189: LD_INT 5
66191: PUSH
66192: FOR_TO
66193: IFFALSE 66307
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
66195: LD_ADDR_VAR 0 11
66199: PUSH
66200: LD_VAR 0 13
66204: PPUSH
66205: CALL_OW 250
66209: PPUSH
66210: LD_VAR 0 10
66214: PPUSH
66215: LD_INT 2
66217: PPUSH
66218: CALL_OW 272
66222: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
66223: LD_ADDR_VAR 0 12
66227: PUSH
66228: LD_VAR 0 13
66232: PPUSH
66233: CALL_OW 251
66237: PPUSH
66238: LD_VAR 0 10
66242: PPUSH
66243: LD_INT 2
66245: PPUSH
66246: CALL_OW 273
66250: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
66251: LD_VAR 0 11
66255: PPUSH
66256: LD_VAR 0 12
66260: PPUSH
66261: CALL_OW 488
66265: PUSH
66266: LD_VAR 0 11
66270: PPUSH
66271: LD_VAR 0 12
66275: PPUSH
66276: CALL_OW 428
66280: NOT
66281: AND
66282: IFFALSE 66305
// begin ComMoveXY ( tmp , _x , _y ) ;
66284: LD_VAR 0 13
66288: PPUSH
66289: LD_VAR 0 11
66293: PPUSH
66294: LD_VAR 0 12
66298: PPUSH
66299: CALL_OW 111
// break ;
66303: GO 66307
// end ; end ;
66305: GO 66192
66307: POP
66308: POP
// end ; end ;
66309: GO 65634
66311: POP
66312: POP
// end ;
66313: LD_VAR 0 8
66317: RET
// export function BuildingTechInvented ( side , btype ) ; begin
66318: LD_INT 0
66320: PPUSH
// result := true ;
66321: LD_ADDR_VAR 0 3
66325: PUSH
66326: LD_INT 1
66328: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
66329: LD_VAR 0 2
66333: PUSH
66334: LD_INT 24
66336: DOUBLE
66337: EQUAL
66338: IFTRUE 66348
66340: LD_INT 33
66342: DOUBLE
66343: EQUAL
66344: IFTRUE 66348
66346: GO 66373
66348: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
66349: LD_ADDR_VAR 0 3
66353: PUSH
66354: LD_INT 32
66356: PPUSH
66357: LD_VAR 0 1
66361: PPUSH
66362: CALL_OW 321
66366: PUSH
66367: LD_INT 2
66369: EQUAL
66370: ST_TO_ADDR
66371: GO 66689
66373: LD_INT 20
66375: DOUBLE
66376: EQUAL
66377: IFTRUE 66381
66379: GO 66406
66381: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
66382: LD_ADDR_VAR 0 3
66386: PUSH
66387: LD_INT 6
66389: PPUSH
66390: LD_VAR 0 1
66394: PPUSH
66395: CALL_OW 321
66399: PUSH
66400: LD_INT 2
66402: EQUAL
66403: ST_TO_ADDR
66404: GO 66689
66406: LD_INT 22
66408: DOUBLE
66409: EQUAL
66410: IFTRUE 66420
66412: LD_INT 36
66414: DOUBLE
66415: EQUAL
66416: IFTRUE 66420
66418: GO 66445
66420: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
66421: LD_ADDR_VAR 0 3
66425: PUSH
66426: LD_INT 15
66428: PPUSH
66429: LD_VAR 0 1
66433: PPUSH
66434: CALL_OW 321
66438: PUSH
66439: LD_INT 2
66441: EQUAL
66442: ST_TO_ADDR
66443: GO 66689
66445: LD_INT 30
66447: DOUBLE
66448: EQUAL
66449: IFTRUE 66453
66451: GO 66478
66453: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
66454: LD_ADDR_VAR 0 3
66458: PUSH
66459: LD_INT 20
66461: PPUSH
66462: LD_VAR 0 1
66466: PPUSH
66467: CALL_OW 321
66471: PUSH
66472: LD_INT 2
66474: EQUAL
66475: ST_TO_ADDR
66476: GO 66689
66478: LD_INT 28
66480: DOUBLE
66481: EQUAL
66482: IFTRUE 66492
66484: LD_INT 21
66486: DOUBLE
66487: EQUAL
66488: IFTRUE 66492
66490: GO 66517
66492: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
66493: LD_ADDR_VAR 0 3
66497: PUSH
66498: LD_INT 21
66500: PPUSH
66501: LD_VAR 0 1
66505: PPUSH
66506: CALL_OW 321
66510: PUSH
66511: LD_INT 2
66513: EQUAL
66514: ST_TO_ADDR
66515: GO 66689
66517: LD_INT 16
66519: DOUBLE
66520: EQUAL
66521: IFTRUE 66525
66523: GO 66550
66525: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
66526: LD_ADDR_VAR 0 3
66530: PUSH
66531: LD_INT 84
66533: PPUSH
66534: LD_VAR 0 1
66538: PPUSH
66539: CALL_OW 321
66543: PUSH
66544: LD_INT 2
66546: EQUAL
66547: ST_TO_ADDR
66548: GO 66689
66550: LD_INT 19
66552: DOUBLE
66553: EQUAL
66554: IFTRUE 66564
66556: LD_INT 23
66558: DOUBLE
66559: EQUAL
66560: IFTRUE 66564
66562: GO 66589
66564: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
66565: LD_ADDR_VAR 0 3
66569: PUSH
66570: LD_INT 83
66572: PPUSH
66573: LD_VAR 0 1
66577: PPUSH
66578: CALL_OW 321
66582: PUSH
66583: LD_INT 2
66585: EQUAL
66586: ST_TO_ADDR
66587: GO 66689
66589: LD_INT 17
66591: DOUBLE
66592: EQUAL
66593: IFTRUE 66597
66595: GO 66622
66597: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
66598: LD_ADDR_VAR 0 3
66602: PUSH
66603: LD_INT 39
66605: PPUSH
66606: LD_VAR 0 1
66610: PPUSH
66611: CALL_OW 321
66615: PUSH
66616: LD_INT 2
66618: EQUAL
66619: ST_TO_ADDR
66620: GO 66689
66622: LD_INT 18
66624: DOUBLE
66625: EQUAL
66626: IFTRUE 66630
66628: GO 66655
66630: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
66631: LD_ADDR_VAR 0 3
66635: PUSH
66636: LD_INT 40
66638: PPUSH
66639: LD_VAR 0 1
66643: PPUSH
66644: CALL_OW 321
66648: PUSH
66649: LD_INT 2
66651: EQUAL
66652: ST_TO_ADDR
66653: GO 66689
66655: LD_INT 27
66657: DOUBLE
66658: EQUAL
66659: IFTRUE 66663
66661: GO 66688
66663: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
66664: LD_ADDR_VAR 0 3
66668: PUSH
66669: LD_INT 35
66671: PPUSH
66672: LD_VAR 0 1
66676: PPUSH
66677: CALL_OW 321
66681: PUSH
66682: LD_INT 2
66684: EQUAL
66685: ST_TO_ADDR
66686: GO 66689
66688: POP
// end ;
66689: LD_VAR 0 3
66693: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
66694: LD_INT 0
66696: PPUSH
66697: PPUSH
66698: PPUSH
66699: PPUSH
66700: PPUSH
66701: PPUSH
66702: PPUSH
66703: PPUSH
66704: PPUSH
66705: PPUSH
66706: PPUSH
// result := false ;
66707: LD_ADDR_VAR 0 6
66711: PUSH
66712: LD_INT 0
66714: ST_TO_ADDR
// if btype = b_depot then
66715: LD_VAR 0 2
66719: PUSH
66720: LD_INT 0
66722: EQUAL
66723: IFFALSE 66735
// begin result := true ;
66725: LD_ADDR_VAR 0 6
66729: PUSH
66730: LD_INT 1
66732: ST_TO_ADDR
// exit ;
66733: GO 67561
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
66735: LD_VAR 0 1
66739: NOT
66740: PUSH
66741: LD_VAR 0 1
66745: PPUSH
66746: CALL_OW 266
66750: PUSH
66751: LD_INT 0
66753: PUSH
66754: LD_INT 1
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: IN
66761: NOT
66762: OR
66763: PUSH
66764: LD_VAR 0 2
66768: NOT
66769: OR
66770: PUSH
66771: LD_VAR 0 5
66775: PUSH
66776: LD_INT 0
66778: PUSH
66779: LD_INT 1
66781: PUSH
66782: LD_INT 2
66784: PUSH
66785: LD_INT 3
66787: PUSH
66788: LD_INT 4
66790: PUSH
66791: LD_INT 5
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: LIST
66798: LIST
66799: LIST
66800: LIST
66801: IN
66802: NOT
66803: OR
66804: PUSH
66805: LD_VAR 0 3
66809: PPUSH
66810: LD_VAR 0 4
66814: PPUSH
66815: CALL_OW 488
66819: NOT
66820: OR
66821: IFFALSE 66825
// exit ;
66823: GO 67561
// side := GetSide ( depot ) ;
66825: LD_ADDR_VAR 0 9
66829: PUSH
66830: LD_VAR 0 1
66834: PPUSH
66835: CALL_OW 255
66839: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
66840: LD_VAR 0 9
66844: PPUSH
66845: LD_VAR 0 2
66849: PPUSH
66850: CALL 66318 0 2
66854: NOT
66855: IFFALSE 66859
// exit ;
66857: GO 67561
// pom := GetBase ( depot ) ;
66859: LD_ADDR_VAR 0 10
66863: PUSH
66864: LD_VAR 0 1
66868: PPUSH
66869: CALL_OW 274
66873: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
66874: LD_ADDR_VAR 0 11
66878: PUSH
66879: LD_VAR 0 2
66883: PPUSH
66884: LD_VAR 0 1
66888: PPUSH
66889: CALL_OW 248
66893: PPUSH
66894: CALL_OW 450
66898: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
66899: LD_VAR 0 10
66903: PPUSH
66904: LD_INT 1
66906: PPUSH
66907: CALL_OW 275
66911: PUSH
66912: LD_VAR 0 11
66916: PUSH
66917: LD_INT 1
66919: ARRAY
66920: GREATEREQUAL
66921: PUSH
66922: LD_VAR 0 10
66926: PPUSH
66927: LD_INT 2
66929: PPUSH
66930: CALL_OW 275
66934: PUSH
66935: LD_VAR 0 11
66939: PUSH
66940: LD_INT 2
66942: ARRAY
66943: GREATEREQUAL
66944: AND
66945: PUSH
66946: LD_VAR 0 10
66950: PPUSH
66951: LD_INT 3
66953: PPUSH
66954: CALL_OW 275
66958: PUSH
66959: LD_VAR 0 11
66963: PUSH
66964: LD_INT 3
66966: ARRAY
66967: GREATEREQUAL
66968: AND
66969: NOT
66970: IFFALSE 66974
// exit ;
66972: GO 67561
// if GetBType ( depot ) = b_depot then
66974: LD_VAR 0 1
66978: PPUSH
66979: CALL_OW 266
66983: PUSH
66984: LD_INT 0
66986: EQUAL
66987: IFFALSE 66999
// dist := 28 else
66989: LD_ADDR_VAR 0 14
66993: PUSH
66994: LD_INT 28
66996: ST_TO_ADDR
66997: GO 67007
// dist := 36 ;
66999: LD_ADDR_VAR 0 14
67003: PUSH
67004: LD_INT 36
67006: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
67007: LD_VAR 0 1
67011: PPUSH
67012: LD_VAR 0 3
67016: PPUSH
67017: LD_VAR 0 4
67021: PPUSH
67022: CALL_OW 297
67026: PUSH
67027: LD_VAR 0 14
67031: GREATER
67032: IFFALSE 67036
// exit ;
67034: GO 67561
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
67036: LD_ADDR_VAR 0 12
67040: PUSH
67041: LD_VAR 0 2
67045: PPUSH
67046: LD_VAR 0 3
67050: PPUSH
67051: LD_VAR 0 4
67055: PPUSH
67056: LD_VAR 0 5
67060: PPUSH
67061: LD_VAR 0 1
67065: PPUSH
67066: CALL_OW 248
67070: PPUSH
67071: LD_INT 0
67073: PPUSH
67074: CALL 67566 0 6
67078: ST_TO_ADDR
// if not hexes then
67079: LD_VAR 0 12
67083: NOT
67084: IFFALSE 67088
// exit ;
67086: GO 67561
// hex := GetHexInfo ( x , y ) ;
67088: LD_ADDR_VAR 0 15
67092: PUSH
67093: LD_VAR 0 3
67097: PPUSH
67098: LD_VAR 0 4
67102: PPUSH
67103: CALL_OW 546
67107: ST_TO_ADDR
// if hex [ 1 ] then
67108: LD_VAR 0 15
67112: PUSH
67113: LD_INT 1
67115: ARRAY
67116: IFFALSE 67120
// exit ;
67118: GO 67561
// height := hex [ 2 ] ;
67120: LD_ADDR_VAR 0 13
67124: PUSH
67125: LD_VAR 0 15
67129: PUSH
67130: LD_INT 2
67132: ARRAY
67133: ST_TO_ADDR
// for i = 1 to hexes do
67134: LD_ADDR_VAR 0 7
67138: PUSH
67139: DOUBLE
67140: LD_INT 1
67142: DEC
67143: ST_TO_ADDR
67144: LD_VAR 0 12
67148: PUSH
67149: FOR_TO
67150: IFFALSE 67480
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
67152: LD_VAR 0 12
67156: PUSH
67157: LD_VAR 0 7
67161: ARRAY
67162: PUSH
67163: LD_INT 1
67165: ARRAY
67166: PPUSH
67167: LD_VAR 0 12
67171: PUSH
67172: LD_VAR 0 7
67176: ARRAY
67177: PUSH
67178: LD_INT 2
67180: ARRAY
67181: PPUSH
67182: CALL_OW 488
67186: NOT
67187: PUSH
67188: LD_VAR 0 12
67192: PUSH
67193: LD_VAR 0 7
67197: ARRAY
67198: PUSH
67199: LD_INT 1
67201: ARRAY
67202: PPUSH
67203: LD_VAR 0 12
67207: PUSH
67208: LD_VAR 0 7
67212: ARRAY
67213: PUSH
67214: LD_INT 2
67216: ARRAY
67217: PPUSH
67218: CALL_OW 428
67222: PUSH
67223: LD_INT 0
67225: GREATER
67226: OR
67227: PUSH
67228: LD_VAR 0 12
67232: PUSH
67233: LD_VAR 0 7
67237: ARRAY
67238: PUSH
67239: LD_INT 1
67241: ARRAY
67242: PPUSH
67243: LD_VAR 0 12
67247: PUSH
67248: LD_VAR 0 7
67252: ARRAY
67253: PUSH
67254: LD_INT 2
67256: ARRAY
67257: PPUSH
67258: CALL_OW 351
67262: OR
67263: IFFALSE 67269
// exit ;
67265: POP
67266: POP
67267: GO 67561
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
67269: LD_ADDR_VAR 0 8
67273: PUSH
67274: LD_VAR 0 12
67278: PUSH
67279: LD_VAR 0 7
67283: ARRAY
67284: PUSH
67285: LD_INT 1
67287: ARRAY
67288: PPUSH
67289: LD_VAR 0 12
67293: PUSH
67294: LD_VAR 0 7
67298: ARRAY
67299: PUSH
67300: LD_INT 2
67302: ARRAY
67303: PPUSH
67304: CALL_OW 546
67308: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
67309: LD_VAR 0 8
67313: PUSH
67314: LD_INT 1
67316: ARRAY
67317: PUSH
67318: LD_VAR 0 8
67322: PUSH
67323: LD_INT 2
67325: ARRAY
67326: PUSH
67327: LD_VAR 0 13
67331: PUSH
67332: LD_INT 2
67334: PLUS
67335: GREATER
67336: OR
67337: PUSH
67338: LD_VAR 0 8
67342: PUSH
67343: LD_INT 2
67345: ARRAY
67346: PUSH
67347: LD_VAR 0 13
67351: PUSH
67352: LD_INT 2
67354: MINUS
67355: LESS
67356: OR
67357: PUSH
67358: LD_VAR 0 8
67362: PUSH
67363: LD_INT 3
67365: ARRAY
67366: PUSH
67367: LD_INT 0
67369: PUSH
67370: LD_INT 8
67372: PUSH
67373: LD_INT 9
67375: PUSH
67376: LD_INT 10
67378: PUSH
67379: LD_INT 11
67381: PUSH
67382: LD_INT 12
67384: PUSH
67385: LD_INT 13
67387: PUSH
67388: LD_INT 16
67390: PUSH
67391: LD_INT 17
67393: PUSH
67394: LD_INT 18
67396: PUSH
67397: LD_INT 19
67399: PUSH
67400: LD_INT 20
67402: PUSH
67403: LD_INT 21
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: LIST
67410: LIST
67411: LIST
67412: LIST
67413: LIST
67414: LIST
67415: LIST
67416: LIST
67417: LIST
67418: LIST
67419: LIST
67420: IN
67421: NOT
67422: OR
67423: PUSH
67424: LD_VAR 0 8
67428: PUSH
67429: LD_INT 5
67431: ARRAY
67432: NOT
67433: OR
67434: PUSH
67435: LD_VAR 0 8
67439: PUSH
67440: LD_INT 6
67442: ARRAY
67443: PUSH
67444: LD_INT 1
67446: PUSH
67447: LD_INT 2
67449: PUSH
67450: LD_INT 7
67452: PUSH
67453: LD_INT 9
67455: PUSH
67456: LD_INT 10
67458: PUSH
67459: LD_INT 11
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: IN
67470: NOT
67471: OR
67472: IFFALSE 67478
// exit ;
67474: POP
67475: POP
67476: GO 67561
// end ;
67478: GO 67149
67480: POP
67481: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
67482: LD_VAR 0 9
67486: PPUSH
67487: LD_VAR 0 3
67491: PPUSH
67492: LD_VAR 0 4
67496: PPUSH
67497: LD_INT 20
67499: PPUSH
67500: CALL 59484 0 4
67504: PUSH
67505: LD_INT 4
67507: ARRAY
67508: IFFALSE 67512
// exit ;
67510: GO 67561
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
67512: LD_VAR 0 2
67516: PUSH
67517: LD_INT 29
67519: PUSH
67520: LD_INT 30
67522: PUSH
67523: EMPTY
67524: LIST
67525: LIST
67526: IN
67527: PUSH
67528: LD_VAR 0 3
67532: PPUSH
67533: LD_VAR 0 4
67537: PPUSH
67538: LD_VAR 0 9
67542: PPUSH
67543: CALL_OW 440
67547: NOT
67548: AND
67549: IFFALSE 67553
// exit ;
67551: GO 67561
// result := true ;
67553: LD_ADDR_VAR 0 6
67557: PUSH
67558: LD_INT 1
67560: ST_TO_ADDR
// end ;
67561: LD_VAR 0 6
67565: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
67566: LD_INT 0
67568: PPUSH
67569: PPUSH
67570: PPUSH
67571: PPUSH
67572: PPUSH
67573: PPUSH
67574: PPUSH
67575: PPUSH
67576: PPUSH
67577: PPUSH
67578: PPUSH
67579: PPUSH
67580: PPUSH
67581: PPUSH
67582: PPUSH
67583: PPUSH
67584: PPUSH
67585: PPUSH
67586: PPUSH
67587: PPUSH
67588: PPUSH
67589: PPUSH
67590: PPUSH
67591: PPUSH
67592: PPUSH
67593: PPUSH
67594: PPUSH
67595: PPUSH
67596: PPUSH
67597: PPUSH
67598: PPUSH
67599: PPUSH
67600: PPUSH
67601: PPUSH
67602: PPUSH
67603: PPUSH
67604: PPUSH
67605: PPUSH
67606: PPUSH
67607: PPUSH
67608: PPUSH
67609: PPUSH
67610: PPUSH
67611: PPUSH
67612: PPUSH
67613: PPUSH
67614: PPUSH
67615: PPUSH
67616: PPUSH
67617: PPUSH
67618: PPUSH
67619: PPUSH
67620: PPUSH
67621: PPUSH
67622: PPUSH
67623: PPUSH
67624: PPUSH
67625: PPUSH
// result = [ ] ;
67626: LD_ADDR_VAR 0 7
67630: PUSH
67631: EMPTY
67632: ST_TO_ADDR
// temp_list = [ ] ;
67633: LD_ADDR_VAR 0 9
67637: PUSH
67638: EMPTY
67639: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
67640: LD_VAR 0 4
67644: PUSH
67645: LD_INT 0
67647: PUSH
67648: LD_INT 1
67650: PUSH
67651: LD_INT 2
67653: PUSH
67654: LD_INT 3
67656: PUSH
67657: LD_INT 4
67659: PUSH
67660: LD_INT 5
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: LIST
67667: LIST
67668: LIST
67669: LIST
67670: IN
67671: NOT
67672: PUSH
67673: LD_VAR 0 1
67677: PUSH
67678: LD_INT 0
67680: PUSH
67681: LD_INT 1
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: IN
67688: PUSH
67689: LD_VAR 0 5
67693: PUSH
67694: LD_INT 1
67696: PUSH
67697: LD_INT 2
67699: PUSH
67700: LD_INT 3
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: LIST
67707: IN
67708: NOT
67709: AND
67710: OR
67711: IFFALSE 67715
// exit ;
67713: GO 86106
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
67715: LD_VAR 0 1
67719: PUSH
67720: LD_INT 6
67722: PUSH
67723: LD_INT 7
67725: PUSH
67726: LD_INT 8
67728: PUSH
67729: LD_INT 13
67731: PUSH
67732: LD_INT 12
67734: PUSH
67735: LD_INT 15
67737: PUSH
67738: LD_INT 11
67740: PUSH
67741: LD_INT 14
67743: PUSH
67744: LD_INT 10
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: IN
67758: IFFALSE 67768
// btype = b_lab ;
67760: LD_ADDR_VAR 0 1
67764: PUSH
67765: LD_INT 6
67767: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
67768: LD_VAR 0 6
67772: PUSH
67773: LD_INT 0
67775: PUSH
67776: LD_INT 1
67778: PUSH
67779: LD_INT 2
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: LIST
67786: IN
67787: NOT
67788: PUSH
67789: LD_VAR 0 1
67793: PUSH
67794: LD_INT 0
67796: PUSH
67797: LD_INT 1
67799: PUSH
67800: LD_INT 2
67802: PUSH
67803: LD_INT 3
67805: PUSH
67806: LD_INT 6
67808: PUSH
67809: LD_INT 36
67811: PUSH
67812: LD_INT 4
67814: PUSH
67815: LD_INT 5
67817: PUSH
67818: LD_INT 31
67820: PUSH
67821: LD_INT 32
67823: PUSH
67824: LD_INT 33
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: IN
67840: NOT
67841: PUSH
67842: LD_VAR 0 6
67846: PUSH
67847: LD_INT 1
67849: EQUAL
67850: AND
67851: OR
67852: PUSH
67853: LD_VAR 0 1
67857: PUSH
67858: LD_INT 2
67860: PUSH
67861: LD_INT 3
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: IN
67868: NOT
67869: PUSH
67870: LD_VAR 0 6
67874: PUSH
67875: LD_INT 2
67877: EQUAL
67878: AND
67879: OR
67880: IFFALSE 67890
// mode = 0 ;
67882: LD_ADDR_VAR 0 6
67886: PUSH
67887: LD_INT 0
67889: ST_TO_ADDR
// case mode of 0 :
67890: LD_VAR 0 6
67894: PUSH
67895: LD_INT 0
67897: DOUBLE
67898: EQUAL
67899: IFTRUE 67903
67901: GO 79356
67903: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67904: LD_ADDR_VAR 0 11
67908: PUSH
67909: LD_INT 0
67911: PUSH
67912: LD_INT 0
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PUSH
67919: LD_INT 0
67921: PUSH
67922: LD_INT 1
67924: NEG
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PUSH
67930: LD_INT 1
67932: PUSH
67933: LD_INT 0
67935: PUSH
67936: EMPTY
67937: LIST
67938: LIST
67939: PUSH
67940: LD_INT 1
67942: PUSH
67943: LD_INT 1
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 0
67952: PUSH
67953: LD_INT 1
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 1
67962: NEG
67963: PUSH
67964: LD_INT 0
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 1
67973: NEG
67974: PUSH
67975: LD_INT 1
67977: NEG
67978: PUSH
67979: EMPTY
67980: LIST
67981: LIST
67982: PUSH
67983: LD_INT 1
67985: NEG
67986: PUSH
67987: LD_INT 2
67989: NEG
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: PUSH
67995: LD_INT 0
67997: PUSH
67998: LD_INT 2
68000: NEG
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 1
68008: PUSH
68009: LD_INT 1
68011: NEG
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 1
68019: PUSH
68020: LD_INT 2
68022: PUSH
68023: EMPTY
68024: LIST
68025: LIST
68026: PUSH
68027: LD_INT 0
68029: PUSH
68030: LD_INT 2
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: LD_INT 1
68039: NEG
68040: PUSH
68041: LD_INT 1
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 1
68050: PUSH
68051: LD_INT 3
68053: PUSH
68054: EMPTY
68055: LIST
68056: LIST
68057: PUSH
68058: LD_INT 0
68060: PUSH
68061: LD_INT 3
68063: PUSH
68064: EMPTY
68065: LIST
68066: LIST
68067: PUSH
68068: LD_INT 1
68070: NEG
68071: PUSH
68072: LD_INT 2
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: LIST
68096: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68097: LD_ADDR_VAR 0 12
68101: PUSH
68102: LD_INT 0
68104: PUSH
68105: LD_INT 0
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: PUSH
68112: LD_INT 0
68114: PUSH
68115: LD_INT 1
68117: NEG
68118: PUSH
68119: EMPTY
68120: LIST
68121: LIST
68122: PUSH
68123: LD_INT 1
68125: PUSH
68126: LD_INT 0
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: LD_INT 1
68135: PUSH
68136: LD_INT 1
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PUSH
68143: LD_INT 0
68145: PUSH
68146: LD_INT 1
68148: PUSH
68149: EMPTY
68150: LIST
68151: LIST
68152: PUSH
68153: LD_INT 1
68155: NEG
68156: PUSH
68157: LD_INT 0
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: PUSH
68164: LD_INT 1
68166: NEG
68167: PUSH
68168: LD_INT 1
68170: NEG
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: PUSH
68176: LD_INT 1
68178: PUSH
68179: LD_INT 1
68181: NEG
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PUSH
68187: LD_INT 2
68189: PUSH
68190: LD_INT 0
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: LD_INT 2
68199: PUSH
68200: LD_INT 1
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 1
68209: NEG
68210: PUSH
68211: LD_INT 1
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 2
68220: NEG
68221: PUSH
68222: LD_INT 0
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 2
68231: NEG
68232: PUSH
68233: LD_INT 1
68235: NEG
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: PUSH
68241: LD_INT 2
68243: NEG
68244: PUSH
68245: LD_INT 1
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 3
68254: NEG
68255: PUSH
68256: LD_INT 0
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 3
68265: NEG
68266: PUSH
68267: LD_INT 1
68269: NEG
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: PUSH
68275: EMPTY
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68293: LD_ADDR_VAR 0 13
68297: PUSH
68298: LD_INT 0
68300: PUSH
68301: LD_INT 0
68303: PUSH
68304: EMPTY
68305: LIST
68306: LIST
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: LD_INT 1
68313: NEG
68314: PUSH
68315: EMPTY
68316: LIST
68317: LIST
68318: PUSH
68319: LD_INT 1
68321: PUSH
68322: LD_INT 0
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: LD_INT 1
68331: PUSH
68332: LD_INT 1
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 0
68341: PUSH
68342: LD_INT 1
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: PUSH
68349: LD_INT 1
68351: NEG
68352: PUSH
68353: LD_INT 0
68355: PUSH
68356: EMPTY
68357: LIST
68358: LIST
68359: PUSH
68360: LD_INT 1
68362: NEG
68363: PUSH
68364: LD_INT 1
68366: NEG
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PUSH
68372: LD_INT 1
68374: NEG
68375: PUSH
68376: LD_INT 2
68378: NEG
68379: PUSH
68380: EMPTY
68381: LIST
68382: LIST
68383: PUSH
68384: LD_INT 2
68386: PUSH
68387: LD_INT 1
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: PUSH
68394: LD_INT 2
68396: PUSH
68397: LD_INT 2
68399: PUSH
68400: EMPTY
68401: LIST
68402: LIST
68403: PUSH
68404: LD_INT 1
68406: PUSH
68407: LD_INT 2
68409: PUSH
68410: EMPTY
68411: LIST
68412: LIST
68413: PUSH
68414: LD_INT 2
68416: NEG
68417: PUSH
68418: LD_INT 1
68420: NEG
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 2
68428: NEG
68429: PUSH
68430: LD_INT 2
68432: NEG
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 2
68440: NEG
68441: PUSH
68442: LD_INT 3
68444: NEG
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: LD_INT 3
68452: NEG
68453: PUSH
68454: LD_INT 2
68456: NEG
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 3
68464: NEG
68465: PUSH
68466: LD_INT 3
68468: NEG
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: LIST
68478: LIST
68479: LIST
68480: LIST
68481: LIST
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
68492: LD_ADDR_VAR 0 14
68496: PUSH
68497: LD_INT 0
68499: PUSH
68500: LD_INT 0
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 0
68509: PUSH
68510: LD_INT 1
68512: NEG
68513: PUSH
68514: EMPTY
68515: LIST
68516: LIST
68517: PUSH
68518: LD_INT 1
68520: PUSH
68521: LD_INT 0
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 1
68530: PUSH
68531: LD_INT 1
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 0
68540: PUSH
68541: LD_INT 1
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: LD_INT 1
68550: NEG
68551: PUSH
68552: LD_INT 0
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: LD_INT 1
68561: NEG
68562: PUSH
68563: LD_INT 1
68565: NEG
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 1
68573: NEG
68574: PUSH
68575: LD_INT 2
68577: NEG
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 0
68585: PUSH
68586: LD_INT 2
68588: NEG
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: PUSH
68594: LD_INT 1
68596: PUSH
68597: LD_INT 1
68599: NEG
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: LD_INT 1
68607: PUSH
68608: LD_INT 2
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: LD_INT 0
68617: PUSH
68618: LD_INT 2
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: PUSH
68625: LD_INT 1
68627: NEG
68628: PUSH
68629: LD_INT 1
68631: PUSH
68632: EMPTY
68633: LIST
68634: LIST
68635: PUSH
68636: LD_INT 1
68638: NEG
68639: PUSH
68640: LD_INT 3
68642: NEG
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 0
68650: PUSH
68651: LD_INT 3
68653: NEG
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: PUSH
68659: LD_INT 1
68661: PUSH
68662: LD_INT 2
68664: NEG
68665: PUSH
68666: EMPTY
68667: LIST
68668: LIST
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
68688: LD_ADDR_VAR 0 15
68692: PUSH
68693: LD_INT 0
68695: PUSH
68696: LD_INT 0
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: LD_INT 0
68705: PUSH
68706: LD_INT 1
68708: NEG
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: PUSH
68714: LD_INT 1
68716: PUSH
68717: LD_INT 0
68719: PUSH
68720: EMPTY
68721: LIST
68722: LIST
68723: PUSH
68724: LD_INT 1
68726: PUSH
68727: LD_INT 1
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 0
68736: PUSH
68737: LD_INT 1
68739: PUSH
68740: EMPTY
68741: LIST
68742: LIST
68743: PUSH
68744: LD_INT 1
68746: NEG
68747: PUSH
68748: LD_INT 0
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PUSH
68755: LD_INT 1
68757: NEG
68758: PUSH
68759: LD_INT 1
68761: NEG
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 1
68769: PUSH
68770: LD_INT 1
68772: NEG
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: PUSH
68778: LD_INT 2
68780: PUSH
68781: LD_INT 0
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PUSH
68788: LD_INT 2
68790: PUSH
68791: LD_INT 1
68793: PUSH
68794: EMPTY
68795: LIST
68796: LIST
68797: PUSH
68798: LD_INT 1
68800: NEG
68801: PUSH
68802: LD_INT 1
68804: PUSH
68805: EMPTY
68806: LIST
68807: LIST
68808: PUSH
68809: LD_INT 2
68811: NEG
68812: PUSH
68813: LD_INT 0
68815: PUSH
68816: EMPTY
68817: LIST
68818: LIST
68819: PUSH
68820: LD_INT 2
68822: NEG
68823: PUSH
68824: LD_INT 1
68826: NEG
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PUSH
68832: LD_INT 2
68834: PUSH
68835: LD_INT 1
68837: NEG
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PUSH
68843: LD_INT 3
68845: PUSH
68846: LD_INT 0
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PUSH
68853: LD_INT 3
68855: PUSH
68856: LD_INT 1
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: EMPTY
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: LIST
68878: LIST
68879: LIST
68880: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
68881: LD_ADDR_VAR 0 16
68885: PUSH
68886: LD_INT 0
68888: PUSH
68889: LD_INT 0
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PUSH
68896: LD_INT 0
68898: PUSH
68899: LD_INT 1
68901: NEG
68902: PUSH
68903: EMPTY
68904: LIST
68905: LIST
68906: PUSH
68907: LD_INT 1
68909: PUSH
68910: LD_INT 0
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: PUSH
68917: LD_INT 1
68919: PUSH
68920: LD_INT 1
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 0
68929: PUSH
68930: LD_INT 1
68932: PUSH
68933: EMPTY
68934: LIST
68935: LIST
68936: PUSH
68937: LD_INT 1
68939: NEG
68940: PUSH
68941: LD_INT 0
68943: PUSH
68944: EMPTY
68945: LIST
68946: LIST
68947: PUSH
68948: LD_INT 1
68950: NEG
68951: PUSH
68952: LD_INT 1
68954: NEG
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: PUSH
68960: LD_INT 1
68962: NEG
68963: PUSH
68964: LD_INT 2
68966: NEG
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: PUSH
68972: LD_INT 2
68974: PUSH
68975: LD_INT 1
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: PUSH
68982: LD_INT 2
68984: PUSH
68985: LD_INT 2
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 1
68994: PUSH
68995: LD_INT 2
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: LD_INT 2
69004: NEG
69005: PUSH
69006: LD_INT 1
69008: NEG
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 2
69016: NEG
69017: PUSH
69018: LD_INT 2
69020: NEG
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PUSH
69026: LD_INT 3
69028: PUSH
69029: LD_INT 2
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: LD_INT 3
69038: PUSH
69039: LD_INT 3
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: LD_INT 2
69048: PUSH
69049: LD_INT 3
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: LIST
69060: LIST
69061: LIST
69062: LIST
69063: LIST
69064: LIST
69065: LIST
69066: LIST
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69074: LD_ADDR_VAR 0 17
69078: PUSH
69079: LD_INT 0
69081: PUSH
69082: LD_INT 0
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: PUSH
69089: LD_INT 0
69091: PUSH
69092: LD_INT 1
69094: NEG
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: PUSH
69100: LD_INT 1
69102: PUSH
69103: LD_INT 0
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 1
69112: PUSH
69113: LD_INT 1
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 0
69122: PUSH
69123: LD_INT 1
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 1
69132: NEG
69133: PUSH
69134: LD_INT 0
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: PUSH
69141: LD_INT 1
69143: NEG
69144: PUSH
69145: LD_INT 1
69147: NEG
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: LD_INT 2
69159: NEG
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: PUSH
69165: LD_INT 0
69167: PUSH
69168: LD_INT 2
69170: NEG
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: PUSH
69176: LD_INT 1
69178: PUSH
69179: LD_INT 1
69181: NEG
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 2
69189: PUSH
69190: LD_INT 0
69192: PUSH
69193: EMPTY
69194: LIST
69195: LIST
69196: PUSH
69197: LD_INT 2
69199: PUSH
69200: LD_INT 1
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PUSH
69207: LD_INT 2
69209: PUSH
69210: LD_INT 2
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: LD_INT 1
69219: PUSH
69220: LD_INT 2
69222: PUSH
69223: EMPTY
69224: LIST
69225: LIST
69226: PUSH
69227: LD_INT 0
69229: PUSH
69230: LD_INT 2
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: LD_INT 1
69239: NEG
69240: PUSH
69241: LD_INT 1
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 2
69250: NEG
69251: PUSH
69252: LD_INT 0
69254: PUSH
69255: EMPTY
69256: LIST
69257: LIST
69258: PUSH
69259: LD_INT 2
69261: NEG
69262: PUSH
69263: LD_INT 1
69265: NEG
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 2
69273: NEG
69274: PUSH
69275: LD_INT 2
69277: NEG
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: LIST
69287: LIST
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69304: LD_ADDR_VAR 0 18
69308: PUSH
69309: LD_INT 0
69311: PUSH
69312: LD_INT 0
69314: PUSH
69315: EMPTY
69316: LIST
69317: LIST
69318: PUSH
69319: LD_INT 0
69321: PUSH
69322: LD_INT 1
69324: NEG
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: PUSH
69330: LD_INT 1
69332: PUSH
69333: LD_INT 0
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 1
69342: PUSH
69343: LD_INT 1
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: LD_INT 0
69352: PUSH
69353: LD_INT 1
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: PUSH
69360: LD_INT 1
69362: NEG
69363: PUSH
69364: LD_INT 0
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 1
69373: NEG
69374: PUSH
69375: LD_INT 1
69377: NEG
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 1
69385: NEG
69386: PUSH
69387: LD_INT 2
69389: NEG
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 0
69397: PUSH
69398: LD_INT 2
69400: NEG
69401: PUSH
69402: EMPTY
69403: LIST
69404: LIST
69405: PUSH
69406: LD_INT 1
69408: PUSH
69409: LD_INT 1
69411: NEG
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: PUSH
69417: LD_INT 2
69419: PUSH
69420: LD_INT 0
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: PUSH
69427: LD_INT 2
69429: PUSH
69430: LD_INT 1
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 2
69439: PUSH
69440: LD_INT 2
69442: PUSH
69443: EMPTY
69444: LIST
69445: LIST
69446: PUSH
69447: LD_INT 1
69449: PUSH
69450: LD_INT 2
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 0
69459: PUSH
69460: LD_INT 2
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 1
69469: NEG
69470: PUSH
69471: LD_INT 1
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 2
69480: NEG
69481: PUSH
69482: LD_INT 0
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: PUSH
69489: LD_INT 2
69491: NEG
69492: PUSH
69493: LD_INT 1
69495: NEG
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 2
69503: NEG
69504: PUSH
69505: LD_INT 2
69507: NEG
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: EMPTY
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: LIST
69526: LIST
69527: LIST
69528: LIST
69529: LIST
69530: LIST
69531: LIST
69532: LIST
69533: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69534: LD_ADDR_VAR 0 19
69538: PUSH
69539: LD_INT 0
69541: PUSH
69542: LD_INT 0
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PUSH
69549: LD_INT 0
69551: PUSH
69552: LD_INT 1
69554: NEG
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 1
69562: PUSH
69563: LD_INT 0
69565: PUSH
69566: EMPTY
69567: LIST
69568: LIST
69569: PUSH
69570: LD_INT 1
69572: PUSH
69573: LD_INT 1
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 0
69582: PUSH
69583: LD_INT 1
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 1
69592: NEG
69593: PUSH
69594: LD_INT 0
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 1
69603: NEG
69604: PUSH
69605: LD_INT 1
69607: NEG
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 1
69615: NEG
69616: PUSH
69617: LD_INT 2
69619: NEG
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 0
69627: PUSH
69628: LD_INT 2
69630: NEG
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PUSH
69636: LD_INT 1
69638: PUSH
69639: LD_INT 1
69641: NEG
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 2
69649: PUSH
69650: LD_INT 0
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 2
69659: PUSH
69660: LD_INT 1
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 2
69669: PUSH
69670: LD_INT 2
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: LD_INT 2
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: PUSH
69687: LD_INT 0
69689: PUSH
69690: LD_INT 2
69692: PUSH
69693: EMPTY
69694: LIST
69695: LIST
69696: PUSH
69697: LD_INT 1
69699: NEG
69700: PUSH
69701: LD_INT 1
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PUSH
69708: LD_INT 2
69710: NEG
69711: PUSH
69712: LD_INT 0
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 2
69721: NEG
69722: PUSH
69723: LD_INT 1
69725: NEG
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 2
69733: NEG
69734: PUSH
69735: LD_INT 2
69737: NEG
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: LIST
69761: LIST
69762: LIST
69763: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69764: LD_ADDR_VAR 0 20
69768: PUSH
69769: LD_INT 0
69771: PUSH
69772: LD_INT 0
69774: PUSH
69775: EMPTY
69776: LIST
69777: LIST
69778: PUSH
69779: LD_INT 0
69781: PUSH
69782: LD_INT 1
69784: NEG
69785: PUSH
69786: EMPTY
69787: LIST
69788: LIST
69789: PUSH
69790: LD_INT 1
69792: PUSH
69793: LD_INT 0
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PUSH
69800: LD_INT 1
69802: PUSH
69803: LD_INT 1
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 0
69812: PUSH
69813: LD_INT 1
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 1
69822: NEG
69823: PUSH
69824: LD_INT 0
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: PUSH
69831: LD_INT 1
69833: NEG
69834: PUSH
69835: LD_INT 1
69837: NEG
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 1
69845: NEG
69846: PUSH
69847: LD_INT 2
69849: NEG
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 0
69857: PUSH
69858: LD_INT 2
69860: NEG
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: LD_INT 1
69868: PUSH
69869: LD_INT 1
69871: NEG
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 2
69879: PUSH
69880: LD_INT 0
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 2
69889: PUSH
69890: LD_INT 1
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 2
69899: PUSH
69900: LD_INT 2
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 1
69909: PUSH
69910: LD_INT 2
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 0
69919: PUSH
69920: LD_INT 2
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: PUSH
69927: LD_INT 1
69929: NEG
69930: PUSH
69931: LD_INT 1
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: PUSH
69938: LD_INT 2
69940: NEG
69941: PUSH
69942: LD_INT 0
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: PUSH
69949: LD_INT 2
69951: NEG
69952: PUSH
69953: LD_INT 1
69955: NEG
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: PUSH
69961: LD_INT 2
69963: NEG
69964: PUSH
69965: LD_INT 2
69967: NEG
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: LIST
69993: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69994: LD_ADDR_VAR 0 21
69998: PUSH
69999: LD_INT 0
70001: PUSH
70002: LD_INT 0
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: LD_INT 0
70011: PUSH
70012: LD_INT 1
70014: NEG
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 1
70022: PUSH
70023: LD_INT 0
70025: PUSH
70026: EMPTY
70027: LIST
70028: LIST
70029: PUSH
70030: LD_INT 1
70032: PUSH
70033: LD_INT 1
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 0
70042: PUSH
70043: LD_INT 1
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: LD_INT 1
70052: NEG
70053: PUSH
70054: LD_INT 0
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: LD_INT 1
70063: NEG
70064: PUSH
70065: LD_INT 1
70067: NEG
70068: PUSH
70069: EMPTY
70070: LIST
70071: LIST
70072: PUSH
70073: LD_INT 1
70075: NEG
70076: PUSH
70077: LD_INT 2
70079: NEG
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PUSH
70085: LD_INT 0
70087: PUSH
70088: LD_INT 2
70090: NEG
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: PUSH
70096: LD_INT 1
70098: PUSH
70099: LD_INT 1
70101: NEG
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: PUSH
70107: LD_INT 2
70109: PUSH
70110: LD_INT 0
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: LD_INT 2
70119: PUSH
70120: LD_INT 1
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: PUSH
70127: LD_INT 2
70129: PUSH
70130: LD_INT 2
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 1
70139: PUSH
70140: LD_INT 2
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PUSH
70147: LD_INT 0
70149: PUSH
70150: LD_INT 2
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 1
70159: NEG
70160: PUSH
70161: LD_INT 1
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PUSH
70168: LD_INT 2
70170: NEG
70171: PUSH
70172: LD_INT 0
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: PUSH
70179: LD_INT 2
70181: NEG
70182: PUSH
70183: LD_INT 1
70185: NEG
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 2
70193: NEG
70194: PUSH
70195: LD_INT 2
70197: NEG
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70224: LD_ADDR_VAR 0 22
70228: PUSH
70229: LD_INT 0
70231: PUSH
70232: LD_INT 0
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: LD_INT 0
70241: PUSH
70242: LD_INT 1
70244: NEG
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: LD_INT 1
70252: PUSH
70253: LD_INT 0
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 1
70262: PUSH
70263: LD_INT 1
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 0
70272: PUSH
70273: LD_INT 1
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 1
70282: NEG
70283: PUSH
70284: LD_INT 0
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: LD_INT 1
70293: NEG
70294: PUSH
70295: LD_INT 1
70297: NEG
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PUSH
70303: LD_INT 1
70305: NEG
70306: PUSH
70307: LD_INT 2
70309: NEG
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: LD_INT 0
70317: PUSH
70318: LD_INT 2
70320: NEG
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 1
70328: PUSH
70329: LD_INT 1
70331: NEG
70332: PUSH
70333: EMPTY
70334: LIST
70335: LIST
70336: PUSH
70337: LD_INT 2
70339: PUSH
70340: LD_INT 0
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: LD_INT 2
70349: PUSH
70350: LD_INT 1
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: PUSH
70357: LD_INT 2
70359: PUSH
70360: LD_INT 2
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: PUSH
70367: LD_INT 1
70369: PUSH
70370: LD_INT 2
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 0
70379: PUSH
70380: LD_INT 2
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 1
70389: NEG
70390: PUSH
70391: LD_INT 1
70393: PUSH
70394: EMPTY
70395: LIST
70396: LIST
70397: PUSH
70398: LD_INT 2
70400: NEG
70401: PUSH
70402: LD_INT 0
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 2
70411: NEG
70412: PUSH
70413: LD_INT 1
70415: NEG
70416: PUSH
70417: EMPTY
70418: LIST
70419: LIST
70420: PUSH
70421: LD_INT 2
70423: NEG
70424: PUSH
70425: LD_INT 2
70427: NEG
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: LIST
70445: LIST
70446: LIST
70447: LIST
70448: LIST
70449: LIST
70450: LIST
70451: LIST
70452: LIST
70453: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
70454: LD_ADDR_VAR 0 23
70458: PUSH
70459: LD_INT 0
70461: PUSH
70462: LD_INT 0
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: LD_INT 0
70471: PUSH
70472: LD_INT 1
70474: NEG
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: LD_INT 1
70482: PUSH
70483: LD_INT 0
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: PUSH
70490: LD_INT 1
70492: PUSH
70493: LD_INT 1
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PUSH
70500: LD_INT 0
70502: PUSH
70503: LD_INT 1
70505: PUSH
70506: EMPTY
70507: LIST
70508: LIST
70509: PUSH
70510: LD_INT 1
70512: NEG
70513: PUSH
70514: LD_INT 0
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: LD_INT 1
70523: NEG
70524: PUSH
70525: LD_INT 1
70527: NEG
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: PUSH
70533: LD_INT 1
70535: NEG
70536: PUSH
70537: LD_INT 2
70539: NEG
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 0
70547: PUSH
70548: LD_INT 2
70550: NEG
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 1
70558: PUSH
70559: LD_INT 1
70561: NEG
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: PUSH
70567: LD_INT 2
70569: PUSH
70570: LD_INT 0
70572: PUSH
70573: EMPTY
70574: LIST
70575: LIST
70576: PUSH
70577: LD_INT 2
70579: PUSH
70580: LD_INT 1
70582: PUSH
70583: EMPTY
70584: LIST
70585: LIST
70586: PUSH
70587: LD_INT 2
70589: PUSH
70590: LD_INT 2
70592: PUSH
70593: EMPTY
70594: LIST
70595: LIST
70596: PUSH
70597: LD_INT 1
70599: PUSH
70600: LD_INT 2
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 0
70609: PUSH
70610: LD_INT 2
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: PUSH
70617: LD_INT 1
70619: NEG
70620: PUSH
70621: LD_INT 1
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PUSH
70628: LD_INT 2
70630: NEG
70631: PUSH
70632: LD_INT 0
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 2
70641: NEG
70642: PUSH
70643: LD_INT 1
70645: NEG
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: LD_INT 2
70653: NEG
70654: PUSH
70655: LD_INT 2
70657: NEG
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 2
70665: NEG
70666: PUSH
70667: LD_INT 3
70669: NEG
70670: PUSH
70671: EMPTY
70672: LIST
70673: LIST
70674: PUSH
70675: LD_INT 1
70677: NEG
70678: PUSH
70679: LD_INT 3
70681: NEG
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: LD_INT 1
70689: PUSH
70690: LD_INT 2
70692: NEG
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 2
70700: PUSH
70701: LD_INT 1
70703: NEG
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: EMPTY
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: LIST
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
70734: LD_ADDR_VAR 0 24
70738: PUSH
70739: LD_INT 0
70741: PUSH
70742: LD_INT 0
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 0
70751: PUSH
70752: LD_INT 1
70754: NEG
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: LD_INT 1
70762: PUSH
70763: LD_INT 0
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 1
70772: PUSH
70773: LD_INT 1
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: PUSH
70780: LD_INT 0
70782: PUSH
70783: LD_INT 1
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 1
70792: NEG
70793: PUSH
70794: LD_INT 0
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 1
70803: NEG
70804: PUSH
70805: LD_INT 1
70807: NEG
70808: PUSH
70809: EMPTY
70810: LIST
70811: LIST
70812: PUSH
70813: LD_INT 1
70815: NEG
70816: PUSH
70817: LD_INT 2
70819: NEG
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: PUSH
70825: LD_INT 0
70827: PUSH
70828: LD_INT 2
70830: NEG
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: PUSH
70836: LD_INT 1
70838: PUSH
70839: LD_INT 1
70841: NEG
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 2
70849: PUSH
70850: LD_INT 0
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 2
70859: PUSH
70860: LD_INT 1
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PUSH
70867: LD_INT 2
70869: PUSH
70870: LD_INT 2
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 1
70879: PUSH
70880: LD_INT 2
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 0
70889: PUSH
70890: LD_INT 2
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 1
70899: NEG
70900: PUSH
70901: LD_INT 1
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: LD_INT 2
70910: NEG
70911: PUSH
70912: LD_INT 0
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PUSH
70919: LD_INT 2
70921: NEG
70922: PUSH
70923: LD_INT 1
70925: NEG
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 2
70933: NEG
70934: PUSH
70935: LD_INT 2
70937: NEG
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 1
70945: PUSH
70946: LD_INT 2
70948: NEG
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: LD_INT 2
70956: PUSH
70957: LD_INT 1
70959: NEG
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: LD_INT 3
70967: PUSH
70968: LD_INT 1
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PUSH
70975: LD_INT 3
70977: PUSH
70978: LD_INT 2
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: LIST
70997: LIST
70998: LIST
70999: LIST
71000: LIST
71001: LIST
71002: LIST
71003: LIST
71004: LIST
71005: LIST
71006: LIST
71007: LIST
71008: LIST
71009: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
71010: LD_ADDR_VAR 0 25
71014: PUSH
71015: LD_INT 0
71017: PUSH
71018: LD_INT 0
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: PUSH
71025: LD_INT 0
71027: PUSH
71028: LD_INT 1
71030: NEG
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: PUSH
71036: LD_INT 1
71038: PUSH
71039: LD_INT 0
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: PUSH
71046: LD_INT 1
71048: PUSH
71049: LD_INT 1
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: PUSH
71056: LD_INT 0
71058: PUSH
71059: LD_INT 1
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: PUSH
71066: LD_INT 1
71068: NEG
71069: PUSH
71070: LD_INT 0
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: LD_INT 1
71079: NEG
71080: PUSH
71081: LD_INT 1
71083: NEG
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 1
71091: NEG
71092: PUSH
71093: LD_INT 2
71095: NEG
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: PUSH
71101: LD_INT 0
71103: PUSH
71104: LD_INT 2
71106: NEG
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 1
71114: PUSH
71115: LD_INT 1
71117: NEG
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: LD_INT 2
71125: PUSH
71126: LD_INT 0
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PUSH
71133: LD_INT 2
71135: PUSH
71136: LD_INT 1
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: LD_INT 2
71145: PUSH
71146: LD_INT 2
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: PUSH
71153: LD_INT 1
71155: PUSH
71156: LD_INT 2
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: PUSH
71163: LD_INT 0
71165: PUSH
71166: LD_INT 2
71168: PUSH
71169: EMPTY
71170: LIST
71171: LIST
71172: PUSH
71173: LD_INT 1
71175: NEG
71176: PUSH
71177: LD_INT 1
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: PUSH
71184: LD_INT 2
71186: NEG
71187: PUSH
71188: LD_INT 0
71190: PUSH
71191: EMPTY
71192: LIST
71193: LIST
71194: PUSH
71195: LD_INT 2
71197: NEG
71198: PUSH
71199: LD_INT 1
71201: NEG
71202: PUSH
71203: EMPTY
71204: LIST
71205: LIST
71206: PUSH
71207: LD_INT 2
71209: NEG
71210: PUSH
71211: LD_INT 2
71213: NEG
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PUSH
71219: LD_INT 3
71221: PUSH
71222: LD_INT 1
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 3
71231: PUSH
71232: LD_INT 2
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 2
71241: PUSH
71242: LD_INT 3
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: LD_INT 1
71251: PUSH
71252: LD_INT 3
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: LIST
71279: LIST
71280: LIST
71281: LIST
71282: LIST
71283: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
71284: LD_ADDR_VAR 0 26
71288: PUSH
71289: LD_INT 0
71291: PUSH
71292: LD_INT 0
71294: PUSH
71295: EMPTY
71296: LIST
71297: LIST
71298: PUSH
71299: LD_INT 0
71301: PUSH
71302: LD_INT 1
71304: NEG
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 1
71312: PUSH
71313: LD_INT 0
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 1
71322: PUSH
71323: LD_INT 1
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PUSH
71330: LD_INT 0
71332: PUSH
71333: LD_INT 1
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 1
71342: NEG
71343: PUSH
71344: LD_INT 0
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 1
71353: NEG
71354: PUSH
71355: LD_INT 1
71357: NEG
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 1
71365: NEG
71366: PUSH
71367: LD_INT 2
71369: NEG
71370: PUSH
71371: EMPTY
71372: LIST
71373: LIST
71374: PUSH
71375: LD_INT 0
71377: PUSH
71378: LD_INT 2
71380: NEG
71381: PUSH
71382: EMPTY
71383: LIST
71384: LIST
71385: PUSH
71386: LD_INT 1
71388: PUSH
71389: LD_INT 1
71391: NEG
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 2
71399: PUSH
71400: LD_INT 0
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 2
71409: PUSH
71410: LD_INT 1
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 2
71419: PUSH
71420: LD_INT 2
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 1
71429: PUSH
71430: LD_INT 2
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: PUSH
71437: LD_INT 0
71439: PUSH
71440: LD_INT 2
71442: PUSH
71443: EMPTY
71444: LIST
71445: LIST
71446: PUSH
71447: LD_INT 1
71449: NEG
71450: PUSH
71451: LD_INT 1
71453: PUSH
71454: EMPTY
71455: LIST
71456: LIST
71457: PUSH
71458: LD_INT 2
71460: NEG
71461: PUSH
71462: LD_INT 0
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 2
71471: NEG
71472: PUSH
71473: LD_INT 1
71475: NEG
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 2
71483: NEG
71484: PUSH
71485: LD_INT 2
71487: NEG
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: PUSH
71493: LD_INT 2
71495: PUSH
71496: LD_INT 3
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 1
71505: PUSH
71506: LD_INT 3
71508: PUSH
71509: EMPTY
71510: LIST
71511: LIST
71512: PUSH
71513: LD_INT 1
71515: NEG
71516: PUSH
71517: LD_INT 2
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PUSH
71524: LD_INT 2
71526: NEG
71527: PUSH
71528: LD_INT 1
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: LIST
71546: LIST
71547: LIST
71548: LIST
71549: LIST
71550: LIST
71551: LIST
71552: LIST
71553: LIST
71554: LIST
71555: LIST
71556: LIST
71557: LIST
71558: LIST
71559: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71560: LD_ADDR_VAR 0 27
71564: PUSH
71565: LD_INT 0
71567: PUSH
71568: LD_INT 0
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 0
71577: PUSH
71578: LD_INT 1
71580: NEG
71581: PUSH
71582: EMPTY
71583: LIST
71584: LIST
71585: PUSH
71586: LD_INT 1
71588: PUSH
71589: LD_INT 0
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: PUSH
71596: LD_INT 1
71598: PUSH
71599: LD_INT 1
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 0
71608: PUSH
71609: LD_INT 1
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: PUSH
71616: LD_INT 1
71618: NEG
71619: PUSH
71620: LD_INT 0
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 1
71629: NEG
71630: PUSH
71631: LD_INT 1
71633: NEG
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 1
71641: NEG
71642: PUSH
71643: LD_INT 2
71645: NEG
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: LD_INT 2
71656: NEG
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 1
71664: PUSH
71665: LD_INT 1
71667: NEG
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: PUSH
71673: LD_INT 2
71675: PUSH
71676: LD_INT 0
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 2
71685: PUSH
71686: LD_INT 1
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: LD_INT 2
71695: PUSH
71696: LD_INT 2
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 1
71705: PUSH
71706: LD_INT 2
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 0
71715: PUSH
71716: LD_INT 2
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: LD_INT 1
71725: NEG
71726: PUSH
71727: LD_INT 1
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: PUSH
71734: LD_INT 2
71736: NEG
71737: PUSH
71738: LD_INT 0
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 2
71747: NEG
71748: PUSH
71749: LD_INT 1
71751: NEG
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 2
71759: NEG
71760: PUSH
71761: LD_INT 2
71763: NEG
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 1
71771: NEG
71772: PUSH
71773: LD_INT 2
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 2
71782: NEG
71783: PUSH
71784: LD_INT 1
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: PUSH
71791: LD_INT 3
71793: NEG
71794: PUSH
71795: LD_INT 1
71797: NEG
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: PUSH
71803: LD_INT 3
71805: NEG
71806: PUSH
71807: LD_INT 2
71809: NEG
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: EMPTY
71816: LIST
71817: LIST
71818: LIST
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: LIST
71828: LIST
71829: LIST
71830: LIST
71831: LIST
71832: LIST
71833: LIST
71834: LIST
71835: LIST
71836: LIST
71837: LIST
71838: LIST
71839: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71840: LD_ADDR_VAR 0 28
71844: PUSH
71845: LD_INT 0
71847: PUSH
71848: LD_INT 0
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: PUSH
71855: LD_INT 0
71857: PUSH
71858: LD_INT 1
71860: NEG
71861: PUSH
71862: EMPTY
71863: LIST
71864: LIST
71865: PUSH
71866: LD_INT 1
71868: PUSH
71869: LD_INT 0
71871: PUSH
71872: EMPTY
71873: LIST
71874: LIST
71875: PUSH
71876: LD_INT 1
71878: PUSH
71879: LD_INT 1
71881: PUSH
71882: EMPTY
71883: LIST
71884: LIST
71885: PUSH
71886: LD_INT 0
71888: PUSH
71889: LD_INT 1
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 1
71898: NEG
71899: PUSH
71900: LD_INT 0
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: PUSH
71907: LD_INT 1
71909: NEG
71910: PUSH
71911: LD_INT 1
71913: NEG
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 1
71921: NEG
71922: PUSH
71923: LD_INT 2
71925: NEG
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: PUSH
71931: LD_INT 0
71933: PUSH
71934: LD_INT 2
71936: NEG
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: PUSH
71942: LD_INT 1
71944: PUSH
71945: LD_INT 1
71947: NEG
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: LD_INT 2
71955: PUSH
71956: LD_INT 0
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 2
71965: PUSH
71966: LD_INT 1
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: LD_INT 2
71975: PUSH
71976: LD_INT 2
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: PUSH
71983: LD_INT 1
71985: PUSH
71986: LD_INT 2
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 0
71995: PUSH
71996: LD_INT 2
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PUSH
72003: LD_INT 1
72005: NEG
72006: PUSH
72007: LD_INT 1
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 2
72016: NEG
72017: PUSH
72018: LD_INT 0
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 2
72027: NEG
72028: PUSH
72029: LD_INT 1
72031: NEG
72032: PUSH
72033: EMPTY
72034: LIST
72035: LIST
72036: PUSH
72037: LD_INT 2
72039: NEG
72040: PUSH
72041: LD_INT 2
72043: NEG
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: LD_INT 2
72051: NEG
72052: PUSH
72053: LD_INT 3
72055: NEG
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 1
72063: NEG
72064: PUSH
72065: LD_INT 3
72067: NEG
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: PUSH
72073: LD_INT 3
72075: NEG
72076: PUSH
72077: LD_INT 1
72079: NEG
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: PUSH
72085: LD_INT 3
72087: NEG
72088: PUSH
72089: LD_INT 2
72091: NEG
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: LIST
72107: LIST
72108: LIST
72109: LIST
72110: LIST
72111: LIST
72112: LIST
72113: LIST
72114: LIST
72115: LIST
72116: LIST
72117: LIST
72118: LIST
72119: LIST
72120: LIST
72121: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72122: LD_ADDR_VAR 0 29
72126: PUSH
72127: LD_INT 0
72129: PUSH
72130: LD_INT 0
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 0
72139: PUSH
72140: LD_INT 1
72142: NEG
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 1
72150: PUSH
72151: LD_INT 0
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: PUSH
72161: LD_INT 1
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: LD_INT 0
72170: PUSH
72171: LD_INT 1
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: LD_INT 1
72180: NEG
72181: PUSH
72182: LD_INT 0
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 1
72191: NEG
72192: PUSH
72193: LD_INT 1
72195: NEG
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: PUSH
72201: LD_INT 1
72203: NEG
72204: PUSH
72205: LD_INT 2
72207: NEG
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: LD_INT 0
72215: PUSH
72216: LD_INT 2
72218: NEG
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 1
72226: PUSH
72227: LD_INT 1
72229: NEG
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 2
72237: PUSH
72238: LD_INT 0
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 2
72247: PUSH
72248: LD_INT 1
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 1
72257: PUSH
72258: LD_INT 2
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: LD_INT 0
72267: PUSH
72268: LD_INT 2
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 1
72277: NEG
72278: PUSH
72279: LD_INT 1
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: PUSH
72286: LD_INT 2
72288: NEG
72289: PUSH
72290: LD_INT 1
72292: NEG
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 2
72300: NEG
72301: PUSH
72302: LD_INT 2
72304: NEG
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: LD_INT 2
72312: NEG
72313: PUSH
72314: LD_INT 3
72316: NEG
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 2
72324: PUSH
72325: LD_INT 1
72327: NEG
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 3
72335: PUSH
72336: LD_INT 1
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 1
72345: PUSH
72346: LD_INT 3
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: PUSH
72353: LD_INT 1
72355: NEG
72356: PUSH
72357: LD_INT 2
72359: PUSH
72360: EMPTY
72361: LIST
72362: LIST
72363: PUSH
72364: LD_INT 3
72366: NEG
72367: PUSH
72368: LD_INT 2
72370: NEG
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: LIST
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72401: LD_ADDR_VAR 0 30
72405: PUSH
72406: LD_INT 0
72408: PUSH
72409: LD_INT 0
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: LD_INT 0
72418: PUSH
72419: LD_INT 1
72421: NEG
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: LD_INT 1
72429: PUSH
72430: LD_INT 0
72432: PUSH
72433: EMPTY
72434: LIST
72435: LIST
72436: PUSH
72437: LD_INT 1
72439: PUSH
72440: LD_INT 1
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: PUSH
72447: LD_INT 0
72449: PUSH
72450: LD_INT 1
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: PUSH
72457: LD_INT 1
72459: NEG
72460: PUSH
72461: LD_INT 0
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: PUSH
72468: LD_INT 1
72470: NEG
72471: PUSH
72472: LD_INT 1
72474: NEG
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 1
72482: NEG
72483: PUSH
72484: LD_INT 2
72486: NEG
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PUSH
72492: LD_INT 0
72494: PUSH
72495: LD_INT 2
72497: NEG
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 1
72505: PUSH
72506: LD_INT 1
72508: NEG
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 2
72516: PUSH
72517: LD_INT 0
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PUSH
72524: LD_INT 2
72526: PUSH
72527: LD_INT 1
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 2
72536: PUSH
72537: LD_INT 2
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 1
72546: PUSH
72547: LD_INT 2
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 1
72556: NEG
72557: PUSH
72558: LD_INT 1
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: LD_INT 2
72567: NEG
72568: PUSH
72569: LD_INT 0
72571: PUSH
72572: EMPTY
72573: LIST
72574: LIST
72575: PUSH
72576: LD_INT 2
72578: NEG
72579: PUSH
72580: LD_INT 1
72582: NEG
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: LD_INT 1
72590: NEG
72591: PUSH
72592: LD_INT 3
72594: NEG
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 1
72602: PUSH
72603: LD_INT 2
72605: NEG
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: PUSH
72611: LD_INT 3
72613: PUSH
72614: LD_INT 2
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: PUSH
72621: LD_INT 2
72623: PUSH
72624: LD_INT 3
72626: PUSH
72627: EMPTY
72628: LIST
72629: LIST
72630: PUSH
72631: LD_INT 2
72633: NEG
72634: PUSH
72635: LD_INT 1
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PUSH
72642: LD_INT 3
72644: NEG
72645: PUSH
72646: LD_INT 1
72648: NEG
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72679: LD_ADDR_VAR 0 31
72683: PUSH
72684: LD_INT 0
72686: PUSH
72687: LD_INT 0
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 0
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 1
72707: PUSH
72708: LD_INT 0
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 1
72717: PUSH
72718: LD_INT 1
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 0
72727: PUSH
72728: LD_INT 1
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PUSH
72735: LD_INT 1
72737: NEG
72738: PUSH
72739: LD_INT 0
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 1
72748: NEG
72749: PUSH
72750: LD_INT 1
72752: NEG
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 1
72760: NEG
72761: PUSH
72762: LD_INT 2
72764: NEG
72765: PUSH
72766: EMPTY
72767: LIST
72768: LIST
72769: PUSH
72770: LD_INT 1
72772: PUSH
72773: LD_INT 1
72775: NEG
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 2
72783: PUSH
72784: LD_INT 0
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 2
72793: PUSH
72794: LD_INT 1
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 2
72803: PUSH
72804: LD_INT 2
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 1
72813: PUSH
72814: LD_INT 2
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PUSH
72821: LD_INT 0
72823: PUSH
72824: LD_INT 2
72826: PUSH
72827: EMPTY
72828: LIST
72829: LIST
72830: PUSH
72831: LD_INT 1
72833: NEG
72834: PUSH
72835: LD_INT 1
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: PUSH
72842: LD_INT 2
72844: NEG
72845: PUSH
72846: LD_INT 1
72848: NEG
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 2
72856: NEG
72857: PUSH
72858: LD_INT 2
72860: NEG
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 2
72868: NEG
72869: PUSH
72870: LD_INT 3
72872: NEG
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: PUSH
72878: LD_INT 2
72880: PUSH
72881: LD_INT 1
72883: NEG
72884: PUSH
72885: EMPTY
72886: LIST
72887: LIST
72888: PUSH
72889: LD_INT 3
72891: PUSH
72892: LD_INT 1
72894: PUSH
72895: EMPTY
72896: LIST
72897: LIST
72898: PUSH
72899: LD_INT 1
72901: PUSH
72902: LD_INT 3
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: PUSH
72909: LD_INT 1
72911: NEG
72912: PUSH
72913: LD_INT 2
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: PUSH
72920: LD_INT 3
72922: NEG
72923: PUSH
72924: LD_INT 2
72926: NEG
72927: PUSH
72928: EMPTY
72929: LIST
72930: LIST
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: LIST
72944: LIST
72945: LIST
72946: LIST
72947: LIST
72948: LIST
72949: LIST
72950: LIST
72951: LIST
72952: LIST
72953: LIST
72954: LIST
72955: LIST
72956: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72957: LD_ADDR_VAR 0 32
72961: PUSH
72962: LD_INT 0
72964: PUSH
72965: LD_INT 0
72967: PUSH
72968: EMPTY
72969: LIST
72970: LIST
72971: PUSH
72972: LD_INT 0
72974: PUSH
72975: LD_INT 1
72977: NEG
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: PUSH
72983: LD_INT 1
72985: PUSH
72986: LD_INT 0
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 1
72995: PUSH
72996: LD_INT 1
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 0
73005: PUSH
73006: LD_INT 1
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 1
73015: NEG
73016: PUSH
73017: LD_INT 0
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: PUSH
73024: LD_INT 1
73026: NEG
73027: PUSH
73028: LD_INT 1
73030: NEG
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: PUSH
73036: LD_INT 1
73038: NEG
73039: PUSH
73040: LD_INT 2
73042: NEG
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 0
73050: PUSH
73051: LD_INT 2
73053: NEG
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 1
73061: PUSH
73062: LD_INT 1
73064: NEG
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: LD_INT 2
73072: PUSH
73073: LD_INT 1
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: PUSH
73080: LD_INT 2
73082: PUSH
73083: LD_INT 2
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 1
73092: PUSH
73093: LD_INT 2
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: PUSH
73100: LD_INT 0
73102: PUSH
73103: LD_INT 2
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 1
73112: NEG
73113: PUSH
73114: LD_INT 1
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: PUSH
73121: LD_INT 2
73123: NEG
73124: PUSH
73125: LD_INT 0
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: PUSH
73132: LD_INT 2
73134: NEG
73135: PUSH
73136: LD_INT 1
73138: NEG
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 1
73146: NEG
73147: PUSH
73148: LD_INT 3
73150: NEG
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: PUSH
73156: LD_INT 1
73158: PUSH
73159: LD_INT 2
73161: NEG
73162: PUSH
73163: EMPTY
73164: LIST
73165: LIST
73166: PUSH
73167: LD_INT 3
73169: PUSH
73170: LD_INT 2
73172: PUSH
73173: EMPTY
73174: LIST
73175: LIST
73176: PUSH
73177: LD_INT 2
73179: PUSH
73180: LD_INT 3
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: LD_INT 2
73189: NEG
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 3
73200: NEG
73201: PUSH
73202: LD_INT 1
73204: NEG
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: PUSH
73210: EMPTY
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: LIST
73220: LIST
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73235: LD_ADDR_VAR 0 33
73239: PUSH
73240: LD_INT 0
73242: PUSH
73243: LD_INT 0
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 0
73252: PUSH
73253: LD_INT 1
73255: NEG
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 1
73263: PUSH
73264: LD_INT 0
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: PUSH
73271: LD_INT 1
73273: PUSH
73274: LD_INT 1
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PUSH
73281: LD_INT 0
73283: PUSH
73284: LD_INT 1
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: PUSH
73291: LD_INT 1
73293: NEG
73294: PUSH
73295: LD_INT 0
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 1
73304: NEG
73305: PUSH
73306: LD_INT 1
73308: NEG
73309: PUSH
73310: EMPTY
73311: LIST
73312: LIST
73313: PUSH
73314: LD_INT 1
73316: NEG
73317: PUSH
73318: LD_INT 2
73320: NEG
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: PUSH
73326: LD_INT 1
73328: PUSH
73329: LD_INT 1
73331: NEG
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: PUSH
73337: LD_INT 2
73339: PUSH
73340: LD_INT 0
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: LD_INT 2
73349: PUSH
73350: LD_INT 1
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PUSH
73357: LD_INT 1
73359: PUSH
73360: LD_INT 2
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 0
73369: PUSH
73370: LD_INT 2
73372: PUSH
73373: EMPTY
73374: LIST
73375: LIST
73376: PUSH
73377: LD_INT 1
73379: NEG
73380: PUSH
73381: LD_INT 1
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 2
73390: NEG
73391: PUSH
73392: LD_INT 0
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 2
73401: NEG
73402: PUSH
73403: LD_INT 1
73405: NEG
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 2
73413: NEG
73414: PUSH
73415: LD_INT 2
73417: NEG
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: PUSH
73423: LD_INT 2
73425: NEG
73426: PUSH
73427: LD_INT 3
73429: NEG
73430: PUSH
73431: EMPTY
73432: LIST
73433: LIST
73434: PUSH
73435: LD_INT 2
73437: PUSH
73438: LD_INT 1
73440: NEG
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: LD_INT 3
73448: PUSH
73449: LD_INT 1
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 1
73458: PUSH
73459: LD_INT 3
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: LD_INT 1
73468: NEG
73469: PUSH
73470: LD_INT 2
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: LD_INT 3
73479: NEG
73480: PUSH
73481: LD_INT 2
73483: NEG
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: LIST
73493: LIST
73494: LIST
73495: LIST
73496: LIST
73497: LIST
73498: LIST
73499: LIST
73500: LIST
73501: LIST
73502: LIST
73503: LIST
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73514: LD_ADDR_VAR 0 34
73518: PUSH
73519: LD_INT 0
73521: PUSH
73522: LD_INT 0
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: LD_INT 0
73531: PUSH
73532: LD_INT 1
73534: NEG
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: PUSH
73540: LD_INT 1
73542: PUSH
73543: LD_INT 0
73545: PUSH
73546: EMPTY
73547: LIST
73548: LIST
73549: PUSH
73550: LD_INT 1
73552: PUSH
73553: LD_INT 1
73555: PUSH
73556: EMPTY
73557: LIST
73558: LIST
73559: PUSH
73560: LD_INT 0
73562: PUSH
73563: LD_INT 1
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 1
73572: NEG
73573: PUSH
73574: LD_INT 0
73576: PUSH
73577: EMPTY
73578: LIST
73579: LIST
73580: PUSH
73581: LD_INT 1
73583: NEG
73584: PUSH
73585: LD_INT 1
73587: NEG
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 1
73595: NEG
73596: PUSH
73597: LD_INT 2
73599: NEG
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 0
73607: PUSH
73608: LD_INT 2
73610: NEG
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: LD_INT 1
73621: NEG
73622: PUSH
73623: EMPTY
73624: LIST
73625: LIST
73626: PUSH
73627: LD_INT 2
73629: PUSH
73630: LD_INT 1
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: PUSH
73637: LD_INT 2
73639: PUSH
73640: LD_INT 2
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 1
73649: PUSH
73650: LD_INT 2
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: LD_INT 1
73659: NEG
73660: PUSH
73661: LD_INT 1
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: PUSH
73668: LD_INT 2
73670: NEG
73671: PUSH
73672: LD_INT 0
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 2
73681: NEG
73682: PUSH
73683: LD_INT 1
73685: NEG
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: PUSH
73691: LD_INT 2
73693: NEG
73694: PUSH
73695: LD_INT 2
73697: NEG
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 1
73705: NEG
73706: PUSH
73707: LD_INT 3
73709: NEG
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 1
73717: PUSH
73718: LD_INT 2
73720: NEG
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 3
73728: PUSH
73729: LD_INT 2
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PUSH
73736: LD_INT 2
73738: PUSH
73739: LD_INT 3
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PUSH
73746: LD_INT 2
73748: NEG
73749: PUSH
73750: LD_INT 1
73752: PUSH
73753: EMPTY
73754: LIST
73755: LIST
73756: PUSH
73757: LD_INT 3
73759: NEG
73760: PUSH
73761: LD_INT 1
73763: NEG
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: LIST
73778: LIST
73779: LIST
73780: LIST
73781: LIST
73782: LIST
73783: LIST
73784: LIST
73785: LIST
73786: LIST
73787: LIST
73788: LIST
73789: LIST
73790: LIST
73791: LIST
73792: LIST
73793: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
73794: LD_ADDR_VAR 0 35
73798: PUSH
73799: LD_INT 0
73801: PUSH
73802: LD_INT 0
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 0
73811: PUSH
73812: LD_INT 1
73814: NEG
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: PUSH
73820: LD_INT 1
73822: PUSH
73823: LD_INT 0
73825: PUSH
73826: EMPTY
73827: LIST
73828: LIST
73829: PUSH
73830: LD_INT 1
73832: PUSH
73833: LD_INT 1
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: LD_INT 0
73842: PUSH
73843: LD_INT 1
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 1
73852: NEG
73853: PUSH
73854: LD_INT 0
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 1
73863: NEG
73864: PUSH
73865: LD_INT 1
73867: NEG
73868: PUSH
73869: EMPTY
73870: LIST
73871: LIST
73872: PUSH
73873: LD_INT 2
73875: PUSH
73876: LD_INT 1
73878: PUSH
73879: EMPTY
73880: LIST
73881: LIST
73882: PUSH
73883: LD_INT 2
73885: NEG
73886: PUSH
73887: LD_INT 1
73889: NEG
73890: PUSH
73891: EMPTY
73892: LIST
73893: LIST
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73906: LD_ADDR_VAR 0 36
73910: PUSH
73911: LD_INT 0
73913: PUSH
73914: LD_INT 0
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 0
73923: PUSH
73924: LD_INT 1
73926: NEG
73927: PUSH
73928: EMPTY
73929: LIST
73930: LIST
73931: PUSH
73932: LD_INT 1
73934: PUSH
73935: LD_INT 0
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 1
73944: PUSH
73945: LD_INT 1
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: PUSH
73952: LD_INT 0
73954: PUSH
73955: LD_INT 1
73957: PUSH
73958: EMPTY
73959: LIST
73960: LIST
73961: PUSH
73962: LD_INT 1
73964: NEG
73965: PUSH
73966: LD_INT 0
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 1
73975: NEG
73976: PUSH
73977: LD_INT 1
73979: NEG
73980: PUSH
73981: EMPTY
73982: LIST
73983: LIST
73984: PUSH
73985: LD_INT 1
73987: NEG
73988: PUSH
73989: LD_INT 2
73991: NEG
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: LD_INT 1
73999: PUSH
74000: LD_INT 2
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: LIST
74011: LIST
74012: LIST
74013: LIST
74014: LIST
74015: LIST
74016: LIST
74017: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74018: LD_ADDR_VAR 0 37
74022: PUSH
74023: LD_INT 0
74025: PUSH
74026: LD_INT 0
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: PUSH
74033: LD_INT 0
74035: PUSH
74036: LD_INT 1
74038: NEG
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: LD_INT 1
74046: PUSH
74047: LD_INT 0
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: LD_INT 1
74056: PUSH
74057: LD_INT 1
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 0
74066: PUSH
74067: LD_INT 1
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 1
74076: NEG
74077: PUSH
74078: LD_INT 0
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 1
74087: NEG
74088: PUSH
74089: LD_INT 1
74091: NEG
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: PUSH
74097: LD_INT 1
74099: PUSH
74100: LD_INT 1
74102: NEG
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 1
74110: NEG
74111: PUSH
74112: LD_INT 1
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
74130: LD_ADDR_VAR 0 38
74134: PUSH
74135: LD_INT 0
74137: PUSH
74138: LD_INT 0
74140: PUSH
74141: EMPTY
74142: LIST
74143: LIST
74144: PUSH
74145: LD_INT 0
74147: PUSH
74148: LD_INT 1
74150: NEG
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: LD_INT 1
74158: PUSH
74159: LD_INT 0
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: PUSH
74166: LD_INT 1
74168: PUSH
74169: LD_INT 1
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 0
74178: PUSH
74179: LD_INT 1
74181: PUSH
74182: EMPTY
74183: LIST
74184: LIST
74185: PUSH
74186: LD_INT 1
74188: NEG
74189: PUSH
74190: LD_INT 0
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 1
74199: NEG
74200: PUSH
74201: LD_INT 1
74203: NEG
74204: PUSH
74205: EMPTY
74206: LIST
74207: LIST
74208: PUSH
74209: LD_INT 2
74211: PUSH
74212: LD_INT 1
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: PUSH
74219: LD_INT 2
74221: NEG
74222: PUSH
74223: LD_INT 1
74225: NEG
74226: PUSH
74227: EMPTY
74228: LIST
74229: LIST
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: LIST
74235: LIST
74236: LIST
74237: LIST
74238: LIST
74239: LIST
74240: LIST
74241: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
74242: LD_ADDR_VAR 0 39
74246: PUSH
74247: LD_INT 0
74249: PUSH
74250: LD_INT 0
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PUSH
74257: LD_INT 0
74259: PUSH
74260: LD_INT 1
74262: NEG
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PUSH
74268: LD_INT 1
74270: PUSH
74271: LD_INT 0
74273: PUSH
74274: EMPTY
74275: LIST
74276: LIST
74277: PUSH
74278: LD_INT 1
74280: PUSH
74281: LD_INT 1
74283: PUSH
74284: EMPTY
74285: LIST
74286: LIST
74287: PUSH
74288: LD_INT 0
74290: PUSH
74291: LD_INT 1
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: LD_INT 1
74300: NEG
74301: PUSH
74302: LD_INT 0
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 1
74311: NEG
74312: PUSH
74313: LD_INT 1
74315: NEG
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 1
74323: NEG
74324: PUSH
74325: LD_INT 2
74327: NEG
74328: PUSH
74329: EMPTY
74330: LIST
74331: LIST
74332: PUSH
74333: LD_INT 1
74335: PUSH
74336: LD_INT 2
74338: PUSH
74339: EMPTY
74340: LIST
74341: LIST
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: LIST
74350: LIST
74351: LIST
74352: LIST
74353: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74354: LD_ADDR_VAR 0 40
74358: PUSH
74359: LD_INT 0
74361: PUSH
74362: LD_INT 0
74364: PUSH
74365: EMPTY
74366: LIST
74367: LIST
74368: PUSH
74369: LD_INT 0
74371: PUSH
74372: LD_INT 1
74374: NEG
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PUSH
74380: LD_INT 1
74382: PUSH
74383: LD_INT 0
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: LD_INT 1
74392: PUSH
74393: LD_INT 1
74395: PUSH
74396: EMPTY
74397: LIST
74398: LIST
74399: PUSH
74400: LD_INT 0
74402: PUSH
74403: LD_INT 1
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: PUSH
74410: LD_INT 1
74412: NEG
74413: PUSH
74414: LD_INT 0
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: PUSH
74421: LD_INT 1
74423: NEG
74424: PUSH
74425: LD_INT 1
74427: NEG
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PUSH
74433: LD_INT 1
74435: PUSH
74436: LD_INT 1
74438: NEG
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: PUSH
74444: LD_INT 1
74446: NEG
74447: PUSH
74448: LD_INT 1
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: EMPTY
74456: LIST
74457: LIST
74458: LIST
74459: LIST
74460: LIST
74461: LIST
74462: LIST
74463: LIST
74464: LIST
74465: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74466: LD_ADDR_VAR 0 41
74470: PUSH
74471: LD_INT 0
74473: PUSH
74474: LD_INT 0
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: LD_INT 0
74483: PUSH
74484: LD_INT 1
74486: NEG
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 1
74494: PUSH
74495: LD_INT 0
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 1
74504: PUSH
74505: LD_INT 1
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: PUSH
74512: LD_INT 0
74514: PUSH
74515: LD_INT 1
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 1
74524: NEG
74525: PUSH
74526: LD_INT 0
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: PUSH
74533: LD_INT 1
74535: NEG
74536: PUSH
74537: LD_INT 1
74539: NEG
74540: PUSH
74541: EMPTY
74542: LIST
74543: LIST
74544: PUSH
74545: LD_INT 1
74547: NEG
74548: PUSH
74549: LD_INT 2
74551: NEG
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: PUSH
74557: LD_INT 1
74559: PUSH
74560: LD_INT 1
74562: NEG
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PUSH
74568: LD_INT 2
74570: PUSH
74571: LD_INT 0
74573: PUSH
74574: EMPTY
74575: LIST
74576: LIST
74577: PUSH
74578: LD_INT 2
74580: PUSH
74581: LD_INT 1
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: PUSH
74588: LD_INT 2
74590: PUSH
74591: LD_INT 2
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 1
74600: PUSH
74601: LD_INT 2
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 1
74610: NEG
74611: PUSH
74612: LD_INT 1
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: PUSH
74619: LD_INT 2
74621: NEG
74622: PUSH
74623: LD_INT 0
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: PUSH
74630: LD_INT 2
74632: NEG
74633: PUSH
74634: LD_INT 1
74636: NEG
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: PUSH
74642: LD_INT 2
74644: NEG
74645: PUSH
74646: LD_INT 2
74648: NEG
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 2
74656: NEG
74657: PUSH
74658: LD_INT 3
74660: NEG
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: PUSH
74666: LD_INT 2
74668: PUSH
74669: LD_INT 1
74671: NEG
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 3
74679: PUSH
74680: LD_INT 0
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 3
74689: PUSH
74690: LD_INT 1
74692: PUSH
74693: EMPTY
74694: LIST
74695: LIST
74696: PUSH
74697: LD_INT 3
74699: PUSH
74700: LD_INT 2
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: PUSH
74707: LD_INT 3
74709: PUSH
74710: LD_INT 3
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: LD_INT 2
74719: PUSH
74720: LD_INT 3
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 2
74729: NEG
74730: PUSH
74731: LD_INT 1
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 3
74740: NEG
74741: PUSH
74742: LD_INT 0
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 3
74751: NEG
74752: PUSH
74753: LD_INT 1
74755: NEG
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: PUSH
74761: LD_INT 3
74763: NEG
74764: PUSH
74765: LD_INT 2
74767: NEG
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: PUSH
74773: LD_INT 3
74775: NEG
74776: PUSH
74777: LD_INT 3
74779: NEG
74780: PUSH
74781: EMPTY
74782: LIST
74783: LIST
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: LIST
74792: LIST
74793: LIST
74794: LIST
74795: LIST
74796: LIST
74797: LIST
74798: LIST
74799: LIST
74800: LIST
74801: LIST
74802: LIST
74803: LIST
74804: LIST
74805: LIST
74806: LIST
74807: LIST
74808: LIST
74809: LIST
74810: LIST
74811: LIST
74812: LIST
74813: LIST
74814: LIST
74815: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74816: LD_ADDR_VAR 0 42
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: LD_INT 0
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 0
74833: PUSH
74834: LD_INT 1
74836: NEG
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 1
74844: PUSH
74845: LD_INT 0
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 1
74854: PUSH
74855: LD_INT 1
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PUSH
74862: LD_INT 0
74864: PUSH
74865: LD_INT 1
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 1
74874: NEG
74875: PUSH
74876: LD_INT 0
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: LD_INT 1
74885: NEG
74886: PUSH
74887: LD_INT 1
74889: NEG
74890: PUSH
74891: EMPTY
74892: LIST
74893: LIST
74894: PUSH
74895: LD_INT 1
74897: NEG
74898: PUSH
74899: LD_INT 2
74901: NEG
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 0
74909: PUSH
74910: LD_INT 2
74912: NEG
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 1
74920: PUSH
74921: LD_INT 1
74923: NEG
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 2
74931: PUSH
74932: LD_INT 1
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: PUSH
74939: LD_INT 2
74941: PUSH
74942: LD_INT 2
74944: PUSH
74945: EMPTY
74946: LIST
74947: LIST
74948: PUSH
74949: LD_INT 1
74951: PUSH
74952: LD_INT 2
74954: PUSH
74955: EMPTY
74956: LIST
74957: LIST
74958: PUSH
74959: LD_INT 0
74961: PUSH
74962: LD_INT 2
74964: PUSH
74965: EMPTY
74966: LIST
74967: LIST
74968: PUSH
74969: LD_INT 1
74971: NEG
74972: PUSH
74973: LD_INT 1
74975: PUSH
74976: EMPTY
74977: LIST
74978: LIST
74979: PUSH
74980: LD_INT 2
74982: NEG
74983: PUSH
74984: LD_INT 1
74986: NEG
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: LD_INT 2
74994: NEG
74995: PUSH
74996: LD_INT 2
74998: NEG
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 2
75006: NEG
75007: PUSH
75008: LD_INT 3
75010: NEG
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: LD_INT 1
75018: NEG
75019: PUSH
75020: LD_INT 3
75022: NEG
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: PUSH
75028: LD_INT 0
75030: PUSH
75031: LD_INT 3
75033: NEG
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PUSH
75039: LD_INT 1
75041: PUSH
75042: LD_INT 2
75044: NEG
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PUSH
75050: LD_INT 3
75052: PUSH
75053: LD_INT 2
75055: PUSH
75056: EMPTY
75057: LIST
75058: LIST
75059: PUSH
75060: LD_INT 3
75062: PUSH
75063: LD_INT 3
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 2
75072: PUSH
75073: LD_INT 3
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: LD_INT 1
75082: PUSH
75083: LD_INT 3
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 0
75092: PUSH
75093: LD_INT 3
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: LD_INT 1
75102: NEG
75103: PUSH
75104: LD_INT 2
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PUSH
75111: LD_INT 3
75113: NEG
75114: PUSH
75115: LD_INT 2
75117: NEG
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: PUSH
75123: LD_INT 3
75125: NEG
75126: PUSH
75127: LD_INT 3
75129: NEG
75130: PUSH
75131: EMPTY
75132: LIST
75133: LIST
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: LIST
75142: LIST
75143: LIST
75144: LIST
75145: LIST
75146: LIST
75147: LIST
75148: LIST
75149: LIST
75150: LIST
75151: LIST
75152: LIST
75153: LIST
75154: LIST
75155: LIST
75156: LIST
75157: LIST
75158: LIST
75159: LIST
75160: LIST
75161: LIST
75162: LIST
75163: LIST
75164: LIST
75165: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75166: LD_ADDR_VAR 0 43
75170: PUSH
75171: LD_INT 0
75173: PUSH
75174: LD_INT 0
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: LD_INT 0
75183: PUSH
75184: LD_INT 1
75186: NEG
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 1
75194: PUSH
75195: LD_INT 0
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: LD_INT 1
75204: PUSH
75205: LD_INT 1
75207: PUSH
75208: EMPTY
75209: LIST
75210: LIST
75211: PUSH
75212: LD_INT 0
75214: PUSH
75215: LD_INT 1
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: PUSH
75222: LD_INT 1
75224: NEG
75225: PUSH
75226: LD_INT 0
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 1
75235: NEG
75236: PUSH
75237: LD_INT 1
75239: NEG
75240: PUSH
75241: EMPTY
75242: LIST
75243: LIST
75244: PUSH
75245: LD_INT 1
75247: NEG
75248: PUSH
75249: LD_INT 2
75251: NEG
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: LD_INT 0
75259: PUSH
75260: LD_INT 2
75262: NEG
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: LD_INT 1
75270: PUSH
75271: LD_INT 1
75273: NEG
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 2
75281: PUSH
75282: LD_INT 0
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 2
75291: PUSH
75292: LD_INT 1
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 1
75301: PUSH
75302: LD_INT 2
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: PUSH
75309: LD_INT 0
75311: PUSH
75312: LD_INT 2
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: PUSH
75319: LD_INT 1
75321: NEG
75322: PUSH
75323: LD_INT 1
75325: PUSH
75326: EMPTY
75327: LIST
75328: LIST
75329: PUSH
75330: LD_INT 2
75332: NEG
75333: PUSH
75334: LD_INT 0
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: PUSH
75341: LD_INT 2
75343: NEG
75344: PUSH
75345: LD_INT 1
75347: NEG
75348: PUSH
75349: EMPTY
75350: LIST
75351: LIST
75352: PUSH
75353: LD_INT 1
75355: NEG
75356: PUSH
75357: LD_INT 3
75359: NEG
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: LD_INT 0
75367: PUSH
75368: LD_INT 3
75370: NEG
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 1
75378: PUSH
75379: LD_INT 2
75381: NEG
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PUSH
75387: LD_INT 2
75389: PUSH
75390: LD_INT 1
75392: NEG
75393: PUSH
75394: EMPTY
75395: LIST
75396: LIST
75397: PUSH
75398: LD_INT 3
75400: PUSH
75401: LD_INT 0
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 3
75410: PUSH
75411: LD_INT 1
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 1
75420: PUSH
75421: LD_INT 3
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 0
75430: PUSH
75431: LD_INT 3
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 1
75440: NEG
75441: PUSH
75442: LD_INT 2
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: LD_INT 2
75451: NEG
75452: PUSH
75453: LD_INT 1
75455: PUSH
75456: EMPTY
75457: LIST
75458: LIST
75459: PUSH
75460: LD_INT 3
75462: NEG
75463: PUSH
75464: LD_INT 0
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 3
75473: NEG
75474: PUSH
75475: LD_INT 1
75477: NEG
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: LIST
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: LIST
75500: LIST
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: LIST
75506: LIST
75507: LIST
75508: LIST
75509: LIST
75510: LIST
75511: LIST
75512: LIST
75513: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75514: LD_ADDR_VAR 0 44
75518: PUSH
75519: LD_INT 0
75521: PUSH
75522: LD_INT 0
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 0
75531: PUSH
75532: LD_INT 1
75534: NEG
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 1
75542: PUSH
75543: LD_INT 0
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 1
75552: PUSH
75553: LD_INT 1
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 0
75562: PUSH
75563: LD_INT 1
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 1
75572: NEG
75573: PUSH
75574: LD_INT 0
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 1
75583: NEG
75584: PUSH
75585: LD_INT 1
75587: NEG
75588: PUSH
75589: EMPTY
75590: LIST
75591: LIST
75592: PUSH
75593: LD_INT 1
75595: NEG
75596: PUSH
75597: LD_INT 2
75599: NEG
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: LD_INT 1
75607: PUSH
75608: LD_INT 1
75610: NEG
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 2
75618: PUSH
75619: LD_INT 0
75621: PUSH
75622: EMPTY
75623: LIST
75624: LIST
75625: PUSH
75626: LD_INT 2
75628: PUSH
75629: LD_INT 1
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: PUSH
75636: LD_INT 2
75638: PUSH
75639: LD_INT 2
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: PUSH
75646: LD_INT 1
75648: PUSH
75649: LD_INT 2
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: PUSH
75656: LD_INT 1
75658: NEG
75659: PUSH
75660: LD_INT 1
75662: PUSH
75663: EMPTY
75664: LIST
75665: LIST
75666: PUSH
75667: LD_INT 2
75669: NEG
75670: PUSH
75671: LD_INT 0
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 2
75680: NEG
75681: PUSH
75682: LD_INT 1
75684: NEG
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: LD_INT 2
75692: NEG
75693: PUSH
75694: LD_INT 2
75696: NEG
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 2
75704: NEG
75705: PUSH
75706: LD_INT 3
75708: NEG
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: LD_INT 2
75716: PUSH
75717: LD_INT 1
75719: NEG
75720: PUSH
75721: EMPTY
75722: LIST
75723: LIST
75724: PUSH
75725: LD_INT 3
75727: PUSH
75728: LD_INT 0
75730: PUSH
75731: EMPTY
75732: LIST
75733: LIST
75734: PUSH
75735: LD_INT 3
75737: PUSH
75738: LD_INT 1
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 3
75747: PUSH
75748: LD_INT 2
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: LD_INT 3
75757: PUSH
75758: LD_INT 3
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 2
75767: PUSH
75768: LD_INT 3
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 2
75777: NEG
75778: PUSH
75779: LD_INT 1
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 3
75788: NEG
75789: PUSH
75790: LD_INT 0
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 3
75799: NEG
75800: PUSH
75801: LD_INT 1
75803: NEG
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 3
75811: NEG
75812: PUSH
75813: LD_INT 2
75815: NEG
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 3
75823: NEG
75824: PUSH
75825: LD_INT 3
75827: NEG
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: LIST
75837: LIST
75838: LIST
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: LIST
75848: LIST
75849: LIST
75850: LIST
75851: LIST
75852: LIST
75853: LIST
75854: LIST
75855: LIST
75856: LIST
75857: LIST
75858: LIST
75859: LIST
75860: LIST
75861: LIST
75862: LIST
75863: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75864: LD_ADDR_VAR 0 45
75868: PUSH
75869: LD_INT 0
75871: PUSH
75872: LD_INT 0
75874: PUSH
75875: EMPTY
75876: LIST
75877: LIST
75878: PUSH
75879: LD_INT 0
75881: PUSH
75882: LD_INT 1
75884: NEG
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: LD_INT 1
75892: PUSH
75893: LD_INT 0
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 1
75902: PUSH
75903: LD_INT 1
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: LD_INT 0
75912: PUSH
75913: LD_INT 1
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 1
75922: NEG
75923: PUSH
75924: LD_INT 0
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 1
75933: NEG
75934: PUSH
75935: LD_INT 1
75937: NEG
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 1
75945: NEG
75946: PUSH
75947: LD_INT 2
75949: NEG
75950: PUSH
75951: EMPTY
75952: LIST
75953: LIST
75954: PUSH
75955: LD_INT 0
75957: PUSH
75958: LD_INT 2
75960: NEG
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 1
75968: PUSH
75969: LD_INT 1
75971: NEG
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 2
75979: PUSH
75980: LD_INT 1
75982: PUSH
75983: EMPTY
75984: LIST
75985: LIST
75986: PUSH
75987: LD_INT 2
75989: PUSH
75990: LD_INT 2
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 1
75999: PUSH
76000: LD_INT 2
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 0
76009: PUSH
76010: LD_INT 2
76012: PUSH
76013: EMPTY
76014: LIST
76015: LIST
76016: PUSH
76017: LD_INT 1
76019: NEG
76020: PUSH
76021: LD_INT 1
76023: PUSH
76024: EMPTY
76025: LIST
76026: LIST
76027: PUSH
76028: LD_INT 2
76030: NEG
76031: PUSH
76032: LD_INT 1
76034: NEG
76035: PUSH
76036: EMPTY
76037: LIST
76038: LIST
76039: PUSH
76040: LD_INT 2
76042: NEG
76043: PUSH
76044: LD_INT 2
76046: NEG
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: LD_INT 2
76054: NEG
76055: PUSH
76056: LD_INT 3
76058: NEG
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 1
76066: NEG
76067: PUSH
76068: LD_INT 3
76070: NEG
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: LD_INT 0
76078: PUSH
76079: LD_INT 3
76081: NEG
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: PUSH
76087: LD_INT 1
76089: PUSH
76090: LD_INT 2
76092: NEG
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: PUSH
76098: LD_INT 3
76100: PUSH
76101: LD_INT 2
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: PUSH
76108: LD_INT 3
76110: PUSH
76111: LD_INT 3
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: PUSH
76118: LD_INT 2
76120: PUSH
76121: LD_INT 3
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 1
76130: PUSH
76131: LD_INT 3
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: PUSH
76138: LD_INT 0
76140: PUSH
76141: LD_INT 3
76143: PUSH
76144: EMPTY
76145: LIST
76146: LIST
76147: PUSH
76148: LD_INT 1
76150: NEG
76151: PUSH
76152: LD_INT 2
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: LD_INT 3
76161: NEG
76162: PUSH
76163: LD_INT 2
76165: NEG
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 3
76173: NEG
76174: PUSH
76175: LD_INT 3
76177: NEG
76178: PUSH
76179: EMPTY
76180: LIST
76181: LIST
76182: PUSH
76183: EMPTY
76184: LIST
76185: LIST
76186: LIST
76187: LIST
76188: LIST
76189: LIST
76190: LIST
76191: LIST
76192: LIST
76193: LIST
76194: LIST
76195: LIST
76196: LIST
76197: LIST
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76214: LD_ADDR_VAR 0 46
76218: PUSH
76219: LD_INT 0
76221: PUSH
76222: LD_INT 0
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: PUSH
76229: LD_INT 0
76231: PUSH
76232: LD_INT 1
76234: NEG
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PUSH
76240: LD_INT 1
76242: PUSH
76243: LD_INT 0
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: PUSH
76250: LD_INT 1
76252: PUSH
76253: LD_INT 1
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PUSH
76260: LD_INT 0
76262: PUSH
76263: LD_INT 1
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: PUSH
76270: LD_INT 1
76272: NEG
76273: PUSH
76274: LD_INT 0
76276: PUSH
76277: EMPTY
76278: LIST
76279: LIST
76280: PUSH
76281: LD_INT 1
76283: NEG
76284: PUSH
76285: LD_INT 1
76287: NEG
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 1
76295: NEG
76296: PUSH
76297: LD_INT 2
76299: NEG
76300: PUSH
76301: EMPTY
76302: LIST
76303: LIST
76304: PUSH
76305: LD_INT 0
76307: PUSH
76308: LD_INT 2
76310: NEG
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 1
76318: PUSH
76319: LD_INT 1
76321: NEG
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 2
76329: PUSH
76330: LD_INT 0
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 2
76339: PUSH
76340: LD_INT 1
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 1
76349: PUSH
76350: LD_INT 2
76352: PUSH
76353: EMPTY
76354: LIST
76355: LIST
76356: PUSH
76357: LD_INT 0
76359: PUSH
76360: LD_INT 2
76362: PUSH
76363: EMPTY
76364: LIST
76365: LIST
76366: PUSH
76367: LD_INT 1
76369: NEG
76370: PUSH
76371: LD_INT 1
76373: PUSH
76374: EMPTY
76375: LIST
76376: LIST
76377: PUSH
76378: LD_INT 2
76380: NEG
76381: PUSH
76382: LD_INT 0
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 2
76391: NEG
76392: PUSH
76393: LD_INT 1
76395: NEG
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 1
76403: NEG
76404: PUSH
76405: LD_INT 3
76407: NEG
76408: PUSH
76409: EMPTY
76410: LIST
76411: LIST
76412: PUSH
76413: LD_INT 0
76415: PUSH
76416: LD_INT 3
76418: NEG
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: PUSH
76424: LD_INT 1
76426: PUSH
76427: LD_INT 2
76429: NEG
76430: PUSH
76431: EMPTY
76432: LIST
76433: LIST
76434: PUSH
76435: LD_INT 2
76437: PUSH
76438: LD_INT 1
76440: NEG
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: PUSH
76446: LD_INT 3
76448: PUSH
76449: LD_INT 0
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: LD_INT 3
76458: PUSH
76459: LD_INT 1
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 1
76468: PUSH
76469: LD_INT 3
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: LD_INT 0
76478: PUSH
76479: LD_INT 3
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 1
76488: NEG
76489: PUSH
76490: LD_INT 2
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 2
76499: NEG
76500: PUSH
76501: LD_INT 1
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 3
76510: NEG
76511: PUSH
76512: LD_INT 0
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: LD_INT 3
76521: NEG
76522: PUSH
76523: LD_INT 1
76525: NEG
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: LIST
76535: LIST
76536: LIST
76537: LIST
76538: LIST
76539: LIST
76540: LIST
76541: LIST
76542: LIST
76543: LIST
76544: LIST
76545: LIST
76546: LIST
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: LIST
76554: LIST
76555: LIST
76556: LIST
76557: LIST
76558: LIST
76559: LIST
76560: LIST
76561: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76562: LD_ADDR_VAR 0 47
76566: PUSH
76567: LD_INT 0
76569: PUSH
76570: LD_INT 0
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 0
76579: PUSH
76580: LD_INT 1
76582: NEG
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PUSH
76588: LD_INT 1
76590: PUSH
76591: LD_INT 0
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: PUSH
76598: LD_INT 1
76600: PUSH
76601: LD_INT 1
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: PUSH
76608: LD_INT 0
76610: PUSH
76611: LD_INT 1
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: PUSH
76618: LD_INT 1
76620: NEG
76621: PUSH
76622: LD_INT 0
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: LD_INT 1
76631: NEG
76632: PUSH
76633: LD_INT 1
76635: NEG
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 1
76643: NEG
76644: PUSH
76645: LD_INT 2
76647: NEG
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PUSH
76653: LD_INT 0
76655: PUSH
76656: LD_INT 2
76658: NEG
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PUSH
76664: LD_INT 1
76666: PUSH
76667: LD_INT 1
76669: NEG
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: PUSH
76675: LD_INT 2
76677: NEG
76678: PUSH
76679: LD_INT 1
76681: NEG
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 2
76689: NEG
76690: PUSH
76691: LD_INT 2
76693: NEG
76694: PUSH
76695: EMPTY
76696: LIST
76697: LIST
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: LIST
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: LIST
76708: LIST
76709: LIST
76710: LIST
76711: LIST
76712: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76713: LD_ADDR_VAR 0 48
76717: PUSH
76718: LD_INT 0
76720: PUSH
76721: LD_INT 0
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 0
76730: PUSH
76731: LD_INT 1
76733: NEG
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 1
76741: PUSH
76742: LD_INT 0
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: PUSH
76749: LD_INT 1
76751: PUSH
76752: LD_INT 1
76754: PUSH
76755: EMPTY
76756: LIST
76757: LIST
76758: PUSH
76759: LD_INT 0
76761: PUSH
76762: LD_INT 1
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: LD_INT 1
76771: NEG
76772: PUSH
76773: LD_INT 0
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 1
76782: NEG
76783: PUSH
76784: LD_INT 1
76786: NEG
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 1
76794: NEG
76795: PUSH
76796: LD_INT 2
76798: NEG
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: PUSH
76804: LD_INT 0
76806: PUSH
76807: LD_INT 2
76809: NEG
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 1
76817: PUSH
76818: LD_INT 1
76820: NEG
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 2
76828: PUSH
76829: LD_INT 0
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 2
76838: PUSH
76839: LD_INT 1
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: LIST
76850: LIST
76851: LIST
76852: LIST
76853: LIST
76854: LIST
76855: LIST
76856: LIST
76857: LIST
76858: LIST
76859: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76860: LD_ADDR_VAR 0 49
76864: PUSH
76865: LD_INT 0
76867: PUSH
76868: LD_INT 0
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: LD_INT 0
76877: PUSH
76878: LD_INT 1
76880: NEG
76881: PUSH
76882: EMPTY
76883: LIST
76884: LIST
76885: PUSH
76886: LD_INT 1
76888: PUSH
76889: LD_INT 0
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 1
76898: PUSH
76899: LD_INT 1
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 0
76908: PUSH
76909: LD_INT 1
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: PUSH
76916: LD_INT 1
76918: NEG
76919: PUSH
76920: LD_INT 0
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 1
76929: NEG
76930: PUSH
76931: LD_INT 1
76933: NEG
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: LD_INT 1
76941: PUSH
76942: LD_INT 1
76944: NEG
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: PUSH
76950: LD_INT 2
76952: PUSH
76953: LD_INT 0
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 2
76962: PUSH
76963: LD_INT 1
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: LD_INT 2
76972: PUSH
76973: LD_INT 2
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 1
76982: PUSH
76983: LD_INT 2
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: LIST
76994: LIST
76995: LIST
76996: LIST
76997: LIST
76998: LIST
76999: LIST
77000: LIST
77001: LIST
77002: LIST
77003: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77004: LD_ADDR_VAR 0 50
77008: PUSH
77009: LD_INT 0
77011: PUSH
77012: LD_INT 0
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 0
77021: PUSH
77022: LD_INT 1
77024: NEG
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 1
77032: PUSH
77033: LD_INT 0
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: PUSH
77040: LD_INT 1
77042: PUSH
77043: LD_INT 1
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: PUSH
77050: LD_INT 0
77052: PUSH
77053: LD_INT 1
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 1
77062: NEG
77063: PUSH
77064: LD_INT 0
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: PUSH
77071: LD_INT 1
77073: NEG
77074: PUSH
77075: LD_INT 1
77077: NEG
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 2
77085: PUSH
77086: LD_INT 1
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: LD_INT 2
77095: PUSH
77096: LD_INT 2
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 1
77105: PUSH
77106: LD_INT 2
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 0
77115: PUSH
77116: LD_INT 2
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: LD_INT 1
77125: NEG
77126: PUSH
77127: LD_INT 1
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: LIST
77138: LIST
77139: LIST
77140: LIST
77141: LIST
77142: LIST
77143: LIST
77144: LIST
77145: LIST
77146: LIST
77147: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77148: LD_ADDR_VAR 0 51
77152: PUSH
77153: LD_INT 0
77155: PUSH
77156: LD_INT 0
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: LD_INT 0
77165: PUSH
77166: LD_INT 1
77168: NEG
77169: PUSH
77170: EMPTY
77171: LIST
77172: LIST
77173: PUSH
77174: LD_INT 1
77176: PUSH
77177: LD_INT 0
77179: PUSH
77180: EMPTY
77181: LIST
77182: LIST
77183: PUSH
77184: LD_INT 1
77186: PUSH
77187: LD_INT 1
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 0
77196: PUSH
77197: LD_INT 1
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 1
77206: NEG
77207: PUSH
77208: LD_INT 0
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 1
77217: NEG
77218: PUSH
77219: LD_INT 1
77221: NEG
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: PUSH
77227: LD_INT 1
77229: PUSH
77230: LD_INT 2
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: PUSH
77237: LD_INT 0
77239: PUSH
77240: LD_INT 2
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 1
77249: NEG
77250: PUSH
77251: LD_INT 1
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PUSH
77258: LD_INT 2
77260: NEG
77261: PUSH
77262: LD_INT 0
77264: PUSH
77265: EMPTY
77266: LIST
77267: LIST
77268: PUSH
77269: LD_INT 2
77271: NEG
77272: PUSH
77273: LD_INT 1
77275: NEG
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: LIST
77289: LIST
77290: LIST
77291: LIST
77292: LIST
77293: LIST
77294: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77295: LD_ADDR_VAR 0 52
77299: PUSH
77300: LD_INT 0
77302: PUSH
77303: LD_INT 0
77305: PUSH
77306: EMPTY
77307: LIST
77308: LIST
77309: PUSH
77310: LD_INT 0
77312: PUSH
77313: LD_INT 1
77315: NEG
77316: PUSH
77317: EMPTY
77318: LIST
77319: LIST
77320: PUSH
77321: LD_INT 1
77323: PUSH
77324: LD_INT 0
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: PUSH
77331: LD_INT 1
77333: PUSH
77334: LD_INT 1
77336: PUSH
77337: EMPTY
77338: LIST
77339: LIST
77340: PUSH
77341: LD_INT 0
77343: PUSH
77344: LD_INT 1
77346: PUSH
77347: EMPTY
77348: LIST
77349: LIST
77350: PUSH
77351: LD_INT 1
77353: NEG
77354: PUSH
77355: LD_INT 0
77357: PUSH
77358: EMPTY
77359: LIST
77360: LIST
77361: PUSH
77362: LD_INT 1
77364: NEG
77365: PUSH
77366: LD_INT 1
77368: NEG
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 1
77376: NEG
77377: PUSH
77378: LD_INT 2
77380: NEG
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: LD_INT 1
77388: NEG
77389: PUSH
77390: LD_INT 1
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 2
77399: NEG
77400: PUSH
77401: LD_INT 0
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: PUSH
77408: LD_INT 2
77410: NEG
77411: PUSH
77412: LD_INT 1
77414: NEG
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 2
77422: NEG
77423: PUSH
77424: LD_INT 2
77426: NEG
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: LIST
77436: LIST
77437: LIST
77438: LIST
77439: LIST
77440: LIST
77441: LIST
77442: LIST
77443: LIST
77444: LIST
77445: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77446: LD_ADDR_VAR 0 53
77450: PUSH
77451: LD_INT 0
77453: PUSH
77454: LD_INT 0
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: PUSH
77461: LD_INT 0
77463: PUSH
77464: LD_INT 1
77466: NEG
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 1
77474: PUSH
77475: LD_INT 0
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: LD_INT 1
77484: PUSH
77485: LD_INT 1
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 0
77494: PUSH
77495: LD_INT 1
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 1
77504: NEG
77505: PUSH
77506: LD_INT 0
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 1
77515: NEG
77516: PUSH
77517: LD_INT 1
77519: NEG
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 1
77527: NEG
77528: PUSH
77529: LD_INT 2
77531: NEG
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: LD_INT 0
77539: PUSH
77540: LD_INT 2
77542: NEG
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 1
77550: PUSH
77551: LD_INT 1
77553: NEG
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 2
77561: PUSH
77562: LD_INT 0
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 2
77571: PUSH
77572: LD_INT 1
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PUSH
77579: LD_INT 2
77581: PUSH
77582: LD_INT 2
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: PUSH
77589: LD_INT 1
77591: PUSH
77592: LD_INT 2
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 0
77601: PUSH
77602: LD_INT 2
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: LD_INT 1
77611: NEG
77612: PUSH
77613: LD_INT 1
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 2
77622: NEG
77623: PUSH
77624: LD_INT 0
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 2
77633: NEG
77634: PUSH
77635: LD_INT 1
77637: NEG
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: LD_INT 2
77645: NEG
77646: PUSH
77647: LD_INT 2
77649: NEG
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: EMPTY
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77676: LD_ADDR_VAR 0 54
77680: PUSH
77681: LD_INT 0
77683: PUSH
77684: LD_INT 0
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: PUSH
77691: LD_INT 0
77693: PUSH
77694: LD_INT 1
77696: NEG
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: PUSH
77702: LD_INT 1
77704: PUSH
77705: LD_INT 0
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: LD_INT 1
77714: PUSH
77715: LD_INT 1
77717: PUSH
77718: EMPTY
77719: LIST
77720: LIST
77721: PUSH
77722: LD_INT 0
77724: PUSH
77725: LD_INT 1
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PUSH
77732: LD_INT 1
77734: NEG
77735: PUSH
77736: LD_INT 0
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 1
77745: NEG
77746: PUSH
77747: LD_INT 1
77749: NEG
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: LD_INT 1
77757: NEG
77758: PUSH
77759: LD_INT 2
77761: NEG
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: LD_INT 0
77769: PUSH
77770: LD_INT 2
77772: NEG
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: PUSH
77778: LD_INT 1
77780: PUSH
77781: LD_INT 1
77783: NEG
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: LD_INT 2
77791: PUSH
77792: LD_INT 0
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 2
77801: PUSH
77802: LD_INT 1
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: PUSH
77809: LD_INT 2
77811: PUSH
77812: LD_INT 2
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: LD_INT 1
77821: PUSH
77822: LD_INT 2
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: LD_INT 0
77831: PUSH
77832: LD_INT 2
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: LD_INT 1
77841: NEG
77842: PUSH
77843: LD_INT 1
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 2
77852: NEG
77853: PUSH
77854: LD_INT 0
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: LD_INT 2
77863: NEG
77864: PUSH
77865: LD_INT 1
77867: NEG
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 2
77875: NEG
77876: PUSH
77877: LD_INT 2
77879: NEG
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: LIST
77889: LIST
77890: LIST
77891: LIST
77892: LIST
77893: LIST
77894: LIST
77895: LIST
77896: LIST
77897: LIST
77898: LIST
77899: LIST
77900: LIST
77901: LIST
77902: LIST
77903: LIST
77904: LIST
77905: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77906: LD_ADDR_VAR 0 55
77910: PUSH
77911: LD_INT 0
77913: PUSH
77914: LD_INT 0
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 0
77923: PUSH
77924: LD_INT 1
77926: NEG
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: PUSH
77932: LD_INT 1
77934: PUSH
77935: LD_INT 0
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: LD_INT 1
77944: PUSH
77945: LD_INT 1
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 0
77954: PUSH
77955: LD_INT 1
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 1
77964: NEG
77965: PUSH
77966: LD_INT 0
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 1
77975: NEG
77976: PUSH
77977: LD_INT 1
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 1
77987: NEG
77988: PUSH
77989: LD_INT 2
77991: NEG
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: PUSH
77997: LD_INT 0
77999: PUSH
78000: LD_INT 2
78002: NEG
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 1
78010: PUSH
78011: LD_INT 1
78013: NEG
78014: PUSH
78015: EMPTY
78016: LIST
78017: LIST
78018: PUSH
78019: LD_INT 2
78021: PUSH
78022: LD_INT 0
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: LD_INT 2
78031: PUSH
78032: LD_INT 1
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PUSH
78039: LD_INT 2
78041: PUSH
78042: LD_INT 2
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 1
78051: PUSH
78052: LD_INT 2
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 0
78061: PUSH
78062: LD_INT 2
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: LD_INT 1
78071: NEG
78072: PUSH
78073: LD_INT 1
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 2
78082: NEG
78083: PUSH
78084: LD_INT 0
78086: PUSH
78087: EMPTY
78088: LIST
78089: LIST
78090: PUSH
78091: LD_INT 2
78093: NEG
78094: PUSH
78095: LD_INT 1
78097: NEG
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: PUSH
78103: LD_INT 2
78105: NEG
78106: PUSH
78107: LD_INT 2
78109: NEG
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: LIST
78119: LIST
78120: LIST
78121: LIST
78122: LIST
78123: LIST
78124: LIST
78125: LIST
78126: LIST
78127: LIST
78128: LIST
78129: LIST
78130: LIST
78131: LIST
78132: LIST
78133: LIST
78134: LIST
78135: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78136: LD_ADDR_VAR 0 56
78140: PUSH
78141: LD_INT 0
78143: PUSH
78144: LD_INT 0
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: PUSH
78151: LD_INT 0
78153: PUSH
78154: LD_INT 1
78156: NEG
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 1
78164: PUSH
78165: LD_INT 0
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 1
78174: PUSH
78175: LD_INT 1
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 0
78184: PUSH
78185: LD_INT 1
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: LD_INT 1
78194: NEG
78195: PUSH
78196: LD_INT 0
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: LD_INT 1
78205: NEG
78206: PUSH
78207: LD_INT 1
78209: NEG
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 1
78217: NEG
78218: PUSH
78219: LD_INT 2
78221: NEG
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 0
78229: PUSH
78230: LD_INT 2
78232: NEG
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 1
78240: PUSH
78241: LD_INT 1
78243: NEG
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 2
78251: PUSH
78252: LD_INT 0
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PUSH
78259: LD_INT 2
78261: PUSH
78262: LD_INT 1
78264: PUSH
78265: EMPTY
78266: LIST
78267: LIST
78268: PUSH
78269: LD_INT 2
78271: PUSH
78272: LD_INT 2
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: PUSH
78279: LD_INT 1
78281: PUSH
78282: LD_INT 2
78284: PUSH
78285: EMPTY
78286: LIST
78287: LIST
78288: PUSH
78289: LD_INT 0
78291: PUSH
78292: LD_INT 2
78294: PUSH
78295: EMPTY
78296: LIST
78297: LIST
78298: PUSH
78299: LD_INT 1
78301: NEG
78302: PUSH
78303: LD_INT 1
78305: PUSH
78306: EMPTY
78307: LIST
78308: LIST
78309: PUSH
78310: LD_INT 2
78312: NEG
78313: PUSH
78314: LD_INT 0
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PUSH
78321: LD_INT 2
78323: NEG
78324: PUSH
78325: LD_INT 1
78327: NEG
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: PUSH
78333: LD_INT 2
78335: NEG
78336: PUSH
78337: LD_INT 2
78339: NEG
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: LIST
78349: LIST
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: LIST
78363: LIST
78364: LIST
78365: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78366: LD_ADDR_VAR 0 57
78370: PUSH
78371: LD_INT 0
78373: PUSH
78374: LD_INT 0
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: LD_INT 0
78383: PUSH
78384: LD_INT 1
78386: NEG
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: LD_INT 1
78394: PUSH
78395: LD_INT 0
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: PUSH
78402: LD_INT 1
78404: PUSH
78405: LD_INT 1
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: LD_INT 0
78414: PUSH
78415: LD_INT 1
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 1
78424: NEG
78425: PUSH
78426: LD_INT 0
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 1
78435: NEG
78436: PUSH
78437: LD_INT 1
78439: NEG
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 1
78447: NEG
78448: PUSH
78449: LD_INT 2
78451: NEG
78452: PUSH
78453: EMPTY
78454: LIST
78455: LIST
78456: PUSH
78457: LD_INT 0
78459: PUSH
78460: LD_INT 2
78462: NEG
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: LD_INT 1
78470: PUSH
78471: LD_INT 1
78473: NEG
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: PUSH
78479: LD_INT 2
78481: PUSH
78482: LD_INT 0
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 2
78491: PUSH
78492: LD_INT 1
78494: PUSH
78495: EMPTY
78496: LIST
78497: LIST
78498: PUSH
78499: LD_INT 2
78501: PUSH
78502: LD_INT 2
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PUSH
78509: LD_INT 1
78511: PUSH
78512: LD_INT 2
78514: PUSH
78515: EMPTY
78516: LIST
78517: LIST
78518: PUSH
78519: LD_INT 0
78521: PUSH
78522: LD_INT 2
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 1
78531: NEG
78532: PUSH
78533: LD_INT 1
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 2
78542: NEG
78543: PUSH
78544: LD_INT 0
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 2
78553: NEG
78554: PUSH
78555: LD_INT 1
78557: NEG
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PUSH
78563: LD_INT 2
78565: NEG
78566: PUSH
78567: LD_INT 2
78569: NEG
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: LIST
78579: LIST
78580: LIST
78581: LIST
78582: LIST
78583: LIST
78584: LIST
78585: LIST
78586: LIST
78587: LIST
78588: LIST
78589: LIST
78590: LIST
78591: LIST
78592: LIST
78593: LIST
78594: LIST
78595: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78596: LD_ADDR_VAR 0 58
78600: PUSH
78601: LD_INT 0
78603: PUSH
78604: LD_INT 0
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PUSH
78611: LD_INT 0
78613: PUSH
78614: LD_INT 1
78616: NEG
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 1
78624: PUSH
78625: LD_INT 0
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PUSH
78632: LD_INT 1
78634: PUSH
78635: LD_INT 1
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PUSH
78642: LD_INT 0
78644: PUSH
78645: LD_INT 1
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 1
78654: NEG
78655: PUSH
78656: LD_INT 0
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 1
78665: NEG
78666: PUSH
78667: LD_INT 1
78669: NEG
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 1
78677: NEG
78678: PUSH
78679: LD_INT 2
78681: NEG
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: LD_INT 0
78689: PUSH
78690: LD_INT 2
78692: NEG
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 1
78700: PUSH
78701: LD_INT 1
78703: NEG
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: PUSH
78709: LD_INT 2
78711: PUSH
78712: LD_INT 0
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 2
78721: PUSH
78722: LD_INT 1
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 2
78731: PUSH
78732: LD_INT 2
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: LD_INT 1
78741: PUSH
78742: LD_INT 2
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 0
78751: PUSH
78752: LD_INT 2
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PUSH
78759: LD_INT 1
78761: NEG
78762: PUSH
78763: LD_INT 1
78765: PUSH
78766: EMPTY
78767: LIST
78768: LIST
78769: PUSH
78770: LD_INT 2
78772: NEG
78773: PUSH
78774: LD_INT 0
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: PUSH
78781: LD_INT 2
78783: NEG
78784: PUSH
78785: LD_INT 1
78787: NEG
78788: PUSH
78789: EMPTY
78790: LIST
78791: LIST
78792: PUSH
78793: LD_INT 2
78795: NEG
78796: PUSH
78797: LD_INT 2
78799: NEG
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: LIST
78812: LIST
78813: LIST
78814: LIST
78815: LIST
78816: LIST
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78826: LD_ADDR_VAR 0 59
78830: PUSH
78831: LD_INT 0
78833: PUSH
78834: LD_INT 0
78836: PUSH
78837: EMPTY
78838: LIST
78839: LIST
78840: PUSH
78841: LD_INT 0
78843: PUSH
78844: LD_INT 1
78846: NEG
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 1
78854: PUSH
78855: LD_INT 0
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: LD_INT 1
78864: PUSH
78865: LD_INT 1
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: PUSH
78872: LD_INT 0
78874: PUSH
78875: LD_INT 1
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PUSH
78882: LD_INT 1
78884: NEG
78885: PUSH
78886: LD_INT 0
78888: PUSH
78889: EMPTY
78890: LIST
78891: LIST
78892: PUSH
78893: LD_INT 1
78895: NEG
78896: PUSH
78897: LD_INT 1
78899: NEG
78900: PUSH
78901: EMPTY
78902: LIST
78903: LIST
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: LIST
78909: LIST
78910: LIST
78911: LIST
78912: LIST
78913: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78914: LD_ADDR_VAR 0 60
78918: PUSH
78919: LD_INT 0
78921: PUSH
78922: LD_INT 0
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 0
78931: PUSH
78932: LD_INT 1
78934: NEG
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 1
78942: PUSH
78943: LD_INT 0
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 1
78952: PUSH
78953: LD_INT 1
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 0
78962: PUSH
78963: LD_INT 1
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 1
78972: NEG
78973: PUSH
78974: LD_INT 0
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 1
78983: NEG
78984: PUSH
78985: LD_INT 1
78987: NEG
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79002: LD_ADDR_VAR 0 61
79006: PUSH
79007: LD_INT 0
79009: PUSH
79010: LD_INT 0
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 0
79019: PUSH
79020: LD_INT 1
79022: NEG
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 1
79030: PUSH
79031: LD_INT 0
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 1
79040: PUSH
79041: LD_INT 1
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 0
79050: PUSH
79051: LD_INT 1
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 1
79060: NEG
79061: PUSH
79062: LD_INT 0
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 1
79071: NEG
79072: PUSH
79073: LD_INT 1
79075: NEG
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: LIST
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79090: LD_ADDR_VAR 0 62
79094: PUSH
79095: LD_INT 0
79097: PUSH
79098: LD_INT 0
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: LD_INT 0
79107: PUSH
79108: LD_INT 1
79110: NEG
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 1
79118: PUSH
79119: LD_INT 0
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 1
79128: PUSH
79129: LD_INT 1
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: PUSH
79136: LD_INT 0
79138: PUSH
79139: LD_INT 1
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: LD_INT 1
79148: NEG
79149: PUSH
79150: LD_INT 0
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 1
79159: NEG
79160: PUSH
79161: LD_INT 1
79163: NEG
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: LIST
79173: LIST
79174: LIST
79175: LIST
79176: LIST
79177: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79178: LD_ADDR_VAR 0 63
79182: PUSH
79183: LD_INT 0
79185: PUSH
79186: LD_INT 0
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 0
79195: PUSH
79196: LD_INT 1
79198: NEG
79199: PUSH
79200: EMPTY
79201: LIST
79202: LIST
79203: PUSH
79204: LD_INT 1
79206: PUSH
79207: LD_INT 0
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 1
79216: PUSH
79217: LD_INT 1
79219: PUSH
79220: EMPTY
79221: LIST
79222: LIST
79223: PUSH
79224: LD_INT 0
79226: PUSH
79227: LD_INT 1
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: LD_INT 1
79236: NEG
79237: PUSH
79238: LD_INT 0
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 1
79247: NEG
79248: PUSH
79249: LD_INT 1
79251: NEG
79252: PUSH
79253: EMPTY
79254: LIST
79255: LIST
79256: PUSH
79257: EMPTY
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: LIST
79263: LIST
79264: LIST
79265: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79266: LD_ADDR_VAR 0 64
79270: PUSH
79271: LD_INT 0
79273: PUSH
79274: LD_INT 0
79276: PUSH
79277: EMPTY
79278: LIST
79279: LIST
79280: PUSH
79281: LD_INT 0
79283: PUSH
79284: LD_INT 1
79286: NEG
79287: PUSH
79288: EMPTY
79289: LIST
79290: LIST
79291: PUSH
79292: LD_INT 1
79294: PUSH
79295: LD_INT 0
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 1
79304: PUSH
79305: LD_INT 1
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: LD_INT 0
79314: PUSH
79315: LD_INT 1
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 1
79324: NEG
79325: PUSH
79326: LD_INT 0
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 1
79335: NEG
79336: PUSH
79337: LD_INT 1
79339: NEG
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: LIST
79353: ST_TO_ADDR
// end ; 1 :
79354: GO 85251
79356: LD_INT 1
79358: DOUBLE
79359: EQUAL
79360: IFTRUE 79364
79362: GO 81987
79364: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79365: LD_ADDR_VAR 0 11
79369: PUSH
79370: LD_INT 1
79372: NEG
79373: PUSH
79374: LD_INT 3
79376: NEG
79377: PUSH
79378: EMPTY
79379: LIST
79380: LIST
79381: PUSH
79382: LD_INT 0
79384: PUSH
79385: LD_INT 3
79387: NEG
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: PUSH
79393: LD_INT 1
79395: PUSH
79396: LD_INT 2
79398: NEG
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: LIST
79408: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79409: LD_ADDR_VAR 0 12
79413: PUSH
79414: LD_INT 2
79416: PUSH
79417: LD_INT 1
79419: NEG
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 3
79427: PUSH
79428: LD_INT 0
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 3
79437: PUSH
79438: LD_INT 1
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: LIST
79449: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79450: LD_ADDR_VAR 0 13
79454: PUSH
79455: LD_INT 3
79457: PUSH
79458: LD_INT 2
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 3
79467: PUSH
79468: LD_INT 3
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: PUSH
79475: LD_INT 2
79477: PUSH
79478: LD_INT 3
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: LIST
79489: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79490: LD_ADDR_VAR 0 14
79494: PUSH
79495: LD_INT 1
79497: PUSH
79498: LD_INT 3
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: LD_INT 0
79507: PUSH
79508: LD_INT 3
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 1
79517: NEG
79518: PUSH
79519: LD_INT 2
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: LIST
79530: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79531: LD_ADDR_VAR 0 15
79535: PUSH
79536: LD_INT 2
79538: NEG
79539: PUSH
79540: LD_INT 1
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 3
79549: NEG
79550: PUSH
79551: LD_INT 0
79553: PUSH
79554: EMPTY
79555: LIST
79556: LIST
79557: PUSH
79558: LD_INT 3
79560: NEG
79561: PUSH
79562: LD_INT 1
79564: NEG
79565: PUSH
79566: EMPTY
79567: LIST
79568: LIST
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: LIST
79574: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79575: LD_ADDR_VAR 0 16
79579: PUSH
79580: LD_INT 2
79582: NEG
79583: PUSH
79584: LD_INT 3
79586: NEG
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: LD_INT 3
79594: NEG
79595: PUSH
79596: LD_INT 2
79598: NEG
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 3
79606: NEG
79607: PUSH
79608: LD_INT 3
79610: NEG
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: LIST
79620: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79621: LD_ADDR_VAR 0 17
79625: PUSH
79626: LD_INT 1
79628: NEG
79629: PUSH
79630: LD_INT 3
79632: NEG
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 0
79640: PUSH
79641: LD_INT 3
79643: NEG
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 1
79651: PUSH
79652: LD_INT 2
79654: NEG
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: LIST
79664: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79665: LD_ADDR_VAR 0 18
79669: PUSH
79670: LD_INT 2
79672: PUSH
79673: LD_INT 1
79675: NEG
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: LD_INT 3
79683: PUSH
79684: LD_INT 0
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: LD_INT 3
79693: PUSH
79694: LD_INT 1
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: LIST
79705: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79706: LD_ADDR_VAR 0 19
79710: PUSH
79711: LD_INT 3
79713: PUSH
79714: LD_INT 2
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PUSH
79721: LD_INT 3
79723: PUSH
79724: LD_INT 3
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PUSH
79731: LD_INT 2
79733: PUSH
79734: LD_INT 3
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: LIST
79745: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79746: LD_ADDR_VAR 0 20
79750: PUSH
79751: LD_INT 1
79753: PUSH
79754: LD_INT 3
79756: PUSH
79757: EMPTY
79758: LIST
79759: LIST
79760: PUSH
79761: LD_INT 0
79763: PUSH
79764: LD_INT 3
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: LD_INT 1
79773: NEG
79774: PUSH
79775: LD_INT 2
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: LIST
79786: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79787: LD_ADDR_VAR 0 21
79791: PUSH
79792: LD_INT 2
79794: NEG
79795: PUSH
79796: LD_INT 1
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 3
79805: NEG
79806: PUSH
79807: LD_INT 0
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 3
79816: NEG
79817: PUSH
79818: LD_INT 1
79820: NEG
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: LIST
79830: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79831: LD_ADDR_VAR 0 22
79835: PUSH
79836: LD_INT 2
79838: NEG
79839: PUSH
79840: LD_INT 3
79842: NEG
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: LD_INT 3
79850: NEG
79851: PUSH
79852: LD_INT 2
79854: NEG
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 3
79862: NEG
79863: PUSH
79864: LD_INT 3
79866: NEG
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: LIST
79876: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
79877: LD_ADDR_VAR 0 23
79881: PUSH
79882: LD_INT 0
79884: PUSH
79885: LD_INT 3
79887: NEG
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 1
79895: NEG
79896: PUSH
79897: LD_INT 4
79899: NEG
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PUSH
79905: LD_INT 1
79907: PUSH
79908: LD_INT 3
79910: NEG
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: LIST
79920: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
79921: LD_ADDR_VAR 0 24
79925: PUSH
79926: LD_INT 3
79928: PUSH
79929: LD_INT 0
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 3
79938: PUSH
79939: LD_INT 1
79941: NEG
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: PUSH
79947: LD_INT 4
79949: PUSH
79950: LD_INT 1
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: LIST
79961: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
79962: LD_ADDR_VAR 0 25
79966: PUSH
79967: LD_INT 3
79969: PUSH
79970: LD_INT 3
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 4
79979: PUSH
79980: LD_INT 3
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: PUSH
79987: LD_INT 3
79989: PUSH
79990: LD_INT 4
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: LIST
80001: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
80002: LD_ADDR_VAR 0 26
80006: PUSH
80007: LD_INT 0
80009: PUSH
80010: LD_INT 3
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 1
80019: PUSH
80020: LD_INT 4
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 1
80029: NEG
80030: PUSH
80031: LD_INT 3
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: LIST
80042: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
80043: LD_ADDR_VAR 0 27
80047: PUSH
80048: LD_INT 3
80050: NEG
80051: PUSH
80052: LD_INT 0
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 3
80061: NEG
80062: PUSH
80063: LD_INT 1
80065: PUSH
80066: EMPTY
80067: LIST
80068: LIST
80069: PUSH
80070: LD_INT 4
80072: NEG
80073: PUSH
80074: LD_INT 1
80076: NEG
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: LIST
80086: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
80087: LD_ADDR_VAR 0 28
80091: PUSH
80092: LD_INT 3
80094: NEG
80095: PUSH
80096: LD_INT 3
80098: NEG
80099: PUSH
80100: EMPTY
80101: LIST
80102: LIST
80103: PUSH
80104: LD_INT 3
80106: NEG
80107: PUSH
80108: LD_INT 4
80110: NEG
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 4
80118: NEG
80119: PUSH
80120: LD_INT 3
80122: NEG
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: LIST
80132: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
80133: LD_ADDR_VAR 0 29
80137: PUSH
80138: LD_INT 1
80140: NEG
80141: PUSH
80142: LD_INT 3
80144: NEG
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 0
80152: PUSH
80153: LD_INT 3
80155: NEG
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 1
80163: PUSH
80164: LD_INT 2
80166: NEG
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 1
80174: NEG
80175: PUSH
80176: LD_INT 4
80178: NEG
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 0
80186: PUSH
80187: LD_INT 4
80189: NEG
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 1
80197: PUSH
80198: LD_INT 3
80200: NEG
80201: PUSH
80202: EMPTY
80203: LIST
80204: LIST
80205: PUSH
80206: LD_INT 1
80208: NEG
80209: PUSH
80210: LD_INT 5
80212: NEG
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: PUSH
80218: LD_INT 0
80220: PUSH
80221: LD_INT 5
80223: NEG
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 1
80231: PUSH
80232: LD_INT 4
80234: NEG
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: LD_INT 6
80246: NEG
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 0
80254: PUSH
80255: LD_INT 6
80257: NEG
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 1
80265: PUSH
80266: LD_INT 5
80268: NEG
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: LIST
80287: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
80288: LD_ADDR_VAR 0 30
80292: PUSH
80293: LD_INT 2
80295: PUSH
80296: LD_INT 1
80298: NEG
80299: PUSH
80300: EMPTY
80301: LIST
80302: LIST
80303: PUSH
80304: LD_INT 3
80306: PUSH
80307: LD_INT 0
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 3
80316: PUSH
80317: LD_INT 1
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 3
80326: PUSH
80327: LD_INT 1
80329: NEG
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: LD_INT 4
80337: PUSH
80338: LD_INT 0
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 4
80347: PUSH
80348: LD_INT 1
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 4
80357: PUSH
80358: LD_INT 1
80360: NEG
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 5
80368: PUSH
80369: LD_INT 0
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: PUSH
80376: LD_INT 5
80378: PUSH
80379: LD_INT 1
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: PUSH
80386: LD_INT 5
80388: PUSH
80389: LD_INT 1
80391: NEG
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 6
80399: PUSH
80400: LD_INT 0
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: LD_INT 6
80409: PUSH
80410: LD_INT 1
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: LIST
80421: LIST
80422: LIST
80423: LIST
80424: LIST
80425: LIST
80426: LIST
80427: LIST
80428: LIST
80429: LIST
80430: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
80431: LD_ADDR_VAR 0 31
80435: PUSH
80436: LD_INT 3
80438: PUSH
80439: LD_INT 2
80441: PUSH
80442: EMPTY
80443: LIST
80444: LIST
80445: PUSH
80446: LD_INT 3
80448: PUSH
80449: LD_INT 3
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: LD_INT 2
80458: PUSH
80459: LD_INT 3
80461: PUSH
80462: EMPTY
80463: LIST
80464: LIST
80465: PUSH
80466: LD_INT 4
80468: PUSH
80469: LD_INT 3
80471: PUSH
80472: EMPTY
80473: LIST
80474: LIST
80475: PUSH
80476: LD_INT 4
80478: PUSH
80479: LD_INT 4
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PUSH
80486: LD_INT 3
80488: PUSH
80489: LD_INT 4
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 5
80498: PUSH
80499: LD_INT 4
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 5
80508: PUSH
80509: LD_INT 5
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 4
80518: PUSH
80519: LD_INT 5
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 6
80528: PUSH
80529: LD_INT 5
80531: PUSH
80532: EMPTY
80533: LIST
80534: LIST
80535: PUSH
80536: LD_INT 6
80538: PUSH
80539: LD_INT 6
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 5
80548: PUSH
80549: LD_INT 6
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
80570: LD_ADDR_VAR 0 32
80574: PUSH
80575: LD_INT 1
80577: PUSH
80578: LD_INT 3
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 0
80587: PUSH
80588: LD_INT 3
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: PUSH
80595: LD_INT 1
80597: NEG
80598: PUSH
80599: LD_INT 2
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: PUSH
80606: LD_INT 1
80608: PUSH
80609: LD_INT 4
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 0
80618: PUSH
80619: LD_INT 4
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: LD_INT 1
80628: NEG
80629: PUSH
80630: LD_INT 3
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: LD_INT 1
80639: PUSH
80640: LD_INT 5
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 0
80649: PUSH
80650: LD_INT 5
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 1
80659: NEG
80660: PUSH
80661: LD_INT 4
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 1
80670: PUSH
80671: LD_INT 6
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 0
80680: PUSH
80681: LD_INT 6
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_INT 1
80690: NEG
80691: PUSH
80692: LD_INT 5
80694: PUSH
80695: EMPTY
80696: LIST
80697: LIST
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
80713: LD_ADDR_VAR 0 33
80717: PUSH
80718: LD_INT 2
80720: NEG
80721: PUSH
80722: LD_INT 1
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 3
80731: NEG
80732: PUSH
80733: LD_INT 0
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 3
80742: NEG
80743: PUSH
80744: LD_INT 1
80746: NEG
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 3
80754: NEG
80755: PUSH
80756: LD_INT 1
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 4
80765: NEG
80766: PUSH
80767: LD_INT 0
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 4
80776: NEG
80777: PUSH
80778: LD_INT 1
80780: NEG
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 4
80788: NEG
80789: PUSH
80790: LD_INT 1
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 5
80799: NEG
80800: PUSH
80801: LD_INT 0
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 5
80810: NEG
80811: PUSH
80812: LD_INT 1
80814: NEG
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: PUSH
80820: LD_INT 5
80822: NEG
80823: PUSH
80824: LD_INT 1
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: PUSH
80831: LD_INT 6
80833: NEG
80834: PUSH
80835: LD_INT 0
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: LD_INT 6
80844: NEG
80845: PUSH
80846: LD_INT 1
80848: NEG
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: LIST
80858: LIST
80859: LIST
80860: LIST
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: LIST
80866: LIST
80867: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
80868: LD_ADDR_VAR 0 34
80872: PUSH
80873: LD_INT 2
80875: NEG
80876: PUSH
80877: LD_INT 3
80879: NEG
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 3
80887: NEG
80888: PUSH
80889: LD_INT 2
80891: NEG
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: LD_INT 3
80899: NEG
80900: PUSH
80901: LD_INT 3
80903: NEG
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PUSH
80909: LD_INT 3
80911: NEG
80912: PUSH
80913: LD_INT 4
80915: NEG
80916: PUSH
80917: EMPTY
80918: LIST
80919: LIST
80920: PUSH
80921: LD_INT 4
80923: NEG
80924: PUSH
80925: LD_INT 3
80927: NEG
80928: PUSH
80929: EMPTY
80930: LIST
80931: LIST
80932: PUSH
80933: LD_INT 4
80935: NEG
80936: PUSH
80937: LD_INT 4
80939: NEG
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 4
80947: NEG
80948: PUSH
80949: LD_INT 5
80951: NEG
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 5
80959: NEG
80960: PUSH
80961: LD_INT 4
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 5
80971: NEG
80972: PUSH
80973: LD_INT 5
80975: NEG
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 5
80983: NEG
80984: PUSH
80985: LD_INT 6
80987: NEG
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 6
80995: NEG
80996: PUSH
80997: LD_INT 5
80999: NEG
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 6
81007: NEG
81008: PUSH
81009: LD_INT 6
81011: NEG
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: LIST
81021: LIST
81022: LIST
81023: LIST
81024: LIST
81025: LIST
81026: LIST
81027: LIST
81028: LIST
81029: LIST
81030: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
81031: LD_ADDR_VAR 0 41
81035: PUSH
81036: LD_INT 0
81038: PUSH
81039: LD_INT 2
81041: NEG
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 1
81049: NEG
81050: PUSH
81051: LD_INT 3
81053: NEG
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 1
81061: PUSH
81062: LD_INT 2
81064: NEG
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: EMPTY
81071: LIST
81072: LIST
81073: LIST
81074: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
81075: LD_ADDR_VAR 0 42
81079: PUSH
81080: LD_INT 2
81082: PUSH
81083: LD_INT 0
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 2
81092: PUSH
81093: LD_INT 1
81095: NEG
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 3
81103: PUSH
81104: LD_INT 1
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: LIST
81115: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
81116: LD_ADDR_VAR 0 43
81120: PUSH
81121: LD_INT 2
81123: PUSH
81124: LD_INT 2
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 3
81133: PUSH
81134: LD_INT 2
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 2
81143: PUSH
81144: LD_INT 3
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: LIST
81155: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
81156: LD_ADDR_VAR 0 44
81160: PUSH
81161: LD_INT 0
81163: PUSH
81164: LD_INT 2
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 1
81173: PUSH
81174: LD_INT 3
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: PUSH
81181: LD_INT 1
81183: NEG
81184: PUSH
81185: LD_INT 2
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: EMPTY
81193: LIST
81194: LIST
81195: LIST
81196: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81197: LD_ADDR_VAR 0 45
81201: PUSH
81202: LD_INT 2
81204: NEG
81205: PUSH
81206: LD_INT 0
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 2
81215: NEG
81216: PUSH
81217: LD_INT 1
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 3
81226: NEG
81227: PUSH
81228: LD_INT 1
81230: NEG
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: LIST
81240: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
81241: LD_ADDR_VAR 0 46
81245: PUSH
81246: LD_INT 2
81248: NEG
81249: PUSH
81250: LD_INT 2
81252: NEG
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 2
81260: NEG
81261: PUSH
81262: LD_INT 3
81264: NEG
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: PUSH
81270: LD_INT 3
81272: NEG
81273: PUSH
81274: LD_INT 2
81276: NEG
81277: PUSH
81278: EMPTY
81279: LIST
81280: LIST
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: LIST
81286: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
81287: LD_ADDR_VAR 0 47
81291: PUSH
81292: LD_INT 2
81294: NEG
81295: PUSH
81296: LD_INT 3
81298: NEG
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 1
81306: NEG
81307: PUSH
81308: LD_INT 3
81310: NEG
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81320: LD_ADDR_VAR 0 48
81324: PUSH
81325: LD_INT 1
81327: PUSH
81328: LD_INT 2
81330: NEG
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 2
81338: PUSH
81339: LD_INT 1
81341: NEG
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: EMPTY
81348: LIST
81349: LIST
81350: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
81351: LD_ADDR_VAR 0 49
81355: PUSH
81356: LD_INT 3
81358: PUSH
81359: LD_INT 1
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 3
81368: PUSH
81369: LD_INT 2
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
81380: LD_ADDR_VAR 0 50
81384: PUSH
81385: LD_INT 2
81387: PUSH
81388: LD_INT 3
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 1
81397: PUSH
81398: LD_INT 3
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: EMPTY
81406: LIST
81407: LIST
81408: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81409: LD_ADDR_VAR 0 51
81413: PUSH
81414: LD_INT 1
81416: NEG
81417: PUSH
81418: LD_INT 2
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 2
81427: NEG
81428: PUSH
81429: LD_INT 1
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81440: LD_ADDR_VAR 0 52
81444: PUSH
81445: LD_INT 3
81447: NEG
81448: PUSH
81449: LD_INT 1
81451: NEG
81452: PUSH
81453: EMPTY
81454: LIST
81455: LIST
81456: PUSH
81457: LD_INT 3
81459: NEG
81460: PUSH
81461: LD_INT 2
81463: NEG
81464: PUSH
81465: EMPTY
81466: LIST
81467: LIST
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81473: LD_ADDR_VAR 0 53
81477: PUSH
81478: LD_INT 1
81480: NEG
81481: PUSH
81482: LD_INT 3
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 0
81492: PUSH
81493: LD_INT 3
81495: NEG
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 1
81503: PUSH
81504: LD_INT 2
81506: NEG
81507: PUSH
81508: EMPTY
81509: LIST
81510: LIST
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: LIST
81516: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81517: LD_ADDR_VAR 0 54
81521: PUSH
81522: LD_INT 2
81524: PUSH
81525: LD_INT 1
81527: NEG
81528: PUSH
81529: EMPTY
81530: LIST
81531: LIST
81532: PUSH
81533: LD_INT 3
81535: PUSH
81536: LD_INT 0
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: PUSH
81543: LD_INT 3
81545: PUSH
81546: LD_INT 1
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: LIST
81557: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81558: LD_ADDR_VAR 0 55
81562: PUSH
81563: LD_INT 3
81565: PUSH
81566: LD_INT 2
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PUSH
81573: LD_INT 3
81575: PUSH
81576: LD_INT 3
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: LD_INT 2
81585: PUSH
81586: LD_INT 3
81588: PUSH
81589: EMPTY
81590: LIST
81591: LIST
81592: PUSH
81593: EMPTY
81594: LIST
81595: LIST
81596: LIST
81597: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81598: LD_ADDR_VAR 0 56
81602: PUSH
81603: LD_INT 1
81605: PUSH
81606: LD_INT 3
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 0
81615: PUSH
81616: LD_INT 3
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 1
81625: NEG
81626: PUSH
81627: LD_INT 2
81629: PUSH
81630: EMPTY
81631: LIST
81632: LIST
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: LIST
81638: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81639: LD_ADDR_VAR 0 57
81643: PUSH
81644: LD_INT 2
81646: NEG
81647: PUSH
81648: LD_INT 1
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: PUSH
81655: LD_INT 3
81657: NEG
81658: PUSH
81659: LD_INT 0
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 3
81668: NEG
81669: PUSH
81670: LD_INT 1
81672: NEG
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: LIST
81682: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81683: LD_ADDR_VAR 0 58
81687: PUSH
81688: LD_INT 2
81690: NEG
81691: PUSH
81692: LD_INT 3
81694: NEG
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: PUSH
81700: LD_INT 3
81702: NEG
81703: PUSH
81704: LD_INT 2
81706: NEG
81707: PUSH
81708: EMPTY
81709: LIST
81710: LIST
81711: PUSH
81712: LD_INT 3
81714: NEG
81715: PUSH
81716: LD_INT 3
81718: NEG
81719: PUSH
81720: EMPTY
81721: LIST
81722: LIST
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: LIST
81728: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
81729: LD_ADDR_VAR 0 59
81733: PUSH
81734: LD_INT 1
81736: NEG
81737: PUSH
81738: LD_INT 2
81740: NEG
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 0
81748: PUSH
81749: LD_INT 2
81751: NEG
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 1
81759: PUSH
81760: LD_INT 1
81762: NEG
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: EMPTY
81769: LIST
81770: LIST
81771: LIST
81772: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
81773: LD_ADDR_VAR 0 60
81777: PUSH
81778: LD_INT 1
81780: PUSH
81781: LD_INT 1
81783: NEG
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 2
81791: PUSH
81792: LD_INT 0
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 2
81801: PUSH
81802: LD_INT 1
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: LIST
81813: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
81814: LD_ADDR_VAR 0 61
81818: PUSH
81819: LD_INT 2
81821: PUSH
81822: LD_INT 1
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 2
81831: PUSH
81832: LD_INT 2
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PUSH
81839: LD_INT 1
81841: PUSH
81842: LD_INT 2
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: LIST
81853: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
81854: LD_ADDR_VAR 0 62
81858: PUSH
81859: LD_INT 1
81861: PUSH
81862: LD_INT 2
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PUSH
81869: LD_INT 0
81871: PUSH
81872: LD_INT 2
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: PUSH
81879: LD_INT 1
81881: NEG
81882: PUSH
81883: LD_INT 1
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: LIST
81894: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
81895: LD_ADDR_VAR 0 63
81899: PUSH
81900: LD_INT 1
81902: NEG
81903: PUSH
81904: LD_INT 1
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 2
81913: NEG
81914: PUSH
81915: LD_INT 0
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 2
81924: NEG
81925: PUSH
81926: LD_INT 1
81928: NEG
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: LIST
81938: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81939: LD_ADDR_VAR 0 64
81943: PUSH
81944: LD_INT 1
81946: NEG
81947: PUSH
81948: LD_INT 2
81950: NEG
81951: PUSH
81952: EMPTY
81953: LIST
81954: LIST
81955: PUSH
81956: LD_INT 2
81958: NEG
81959: PUSH
81960: LD_INT 1
81962: NEG
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 2
81970: NEG
81971: PUSH
81972: LD_INT 2
81974: NEG
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: LIST
81984: ST_TO_ADDR
// end ; 2 :
81985: GO 85251
81987: LD_INT 2
81989: DOUBLE
81990: EQUAL
81991: IFTRUE 81995
81993: GO 85250
81995: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
81996: LD_ADDR_VAR 0 29
82000: PUSH
82001: LD_INT 4
82003: PUSH
82004: LD_INT 0
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: LD_INT 4
82013: PUSH
82014: LD_INT 1
82016: NEG
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 5
82024: PUSH
82025: LD_INT 0
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 5
82034: PUSH
82035: LD_INT 1
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 4
82044: PUSH
82045: LD_INT 1
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 3
82054: PUSH
82055: LD_INT 0
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 3
82064: PUSH
82065: LD_INT 1
82067: NEG
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 3
82075: PUSH
82076: LD_INT 2
82078: NEG
82079: PUSH
82080: EMPTY
82081: LIST
82082: LIST
82083: PUSH
82084: LD_INT 5
82086: PUSH
82087: LD_INT 2
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PUSH
82094: LD_INT 3
82096: PUSH
82097: LD_INT 3
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 3
82106: PUSH
82107: LD_INT 2
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 4
82116: PUSH
82117: LD_INT 3
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: PUSH
82124: LD_INT 4
82126: PUSH
82127: LD_INT 4
82129: PUSH
82130: EMPTY
82131: LIST
82132: LIST
82133: PUSH
82134: LD_INT 3
82136: PUSH
82137: LD_INT 4
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 2
82146: PUSH
82147: LD_INT 3
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 2
82156: PUSH
82157: LD_INT 2
82159: PUSH
82160: EMPTY
82161: LIST
82162: LIST
82163: PUSH
82164: LD_INT 4
82166: PUSH
82167: LD_INT 2
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 2
82176: PUSH
82177: LD_INT 4
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: PUSH
82184: LD_INT 0
82186: PUSH
82187: LD_INT 4
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 0
82196: PUSH
82197: LD_INT 3
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 1
82206: PUSH
82207: LD_INT 4
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 1
82216: PUSH
82217: LD_INT 5
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 0
82226: PUSH
82227: LD_INT 5
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 1
82236: NEG
82237: PUSH
82238: LD_INT 4
82240: PUSH
82241: EMPTY
82242: LIST
82243: LIST
82244: PUSH
82245: LD_INT 1
82247: NEG
82248: PUSH
82249: LD_INT 3
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PUSH
82256: LD_INT 2
82258: PUSH
82259: LD_INT 5
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 2
82268: NEG
82269: PUSH
82270: LD_INT 3
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 3
82279: NEG
82280: PUSH
82281: LD_INT 0
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PUSH
82288: LD_INT 3
82290: NEG
82291: PUSH
82292: LD_INT 1
82294: NEG
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 2
82302: NEG
82303: PUSH
82304: LD_INT 0
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 2
82313: NEG
82314: PUSH
82315: LD_INT 1
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PUSH
82322: LD_INT 3
82324: NEG
82325: PUSH
82326: LD_INT 1
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 4
82335: NEG
82336: PUSH
82337: LD_INT 0
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: LD_INT 4
82346: NEG
82347: PUSH
82348: LD_INT 1
82350: NEG
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 4
82358: NEG
82359: PUSH
82360: LD_INT 2
82362: NEG
82363: PUSH
82364: EMPTY
82365: LIST
82366: LIST
82367: PUSH
82368: LD_INT 2
82370: NEG
82371: PUSH
82372: LD_INT 2
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 4
82381: NEG
82382: PUSH
82383: LD_INT 4
82385: NEG
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: PUSH
82391: LD_INT 4
82393: NEG
82394: PUSH
82395: LD_INT 5
82397: NEG
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 3
82405: NEG
82406: PUSH
82407: LD_INT 4
82409: NEG
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 3
82417: NEG
82418: PUSH
82419: LD_INT 3
82421: NEG
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 4
82429: NEG
82430: PUSH
82431: LD_INT 3
82433: NEG
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 5
82441: NEG
82442: PUSH
82443: LD_INT 4
82445: NEG
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: PUSH
82451: LD_INT 5
82453: NEG
82454: PUSH
82455: LD_INT 5
82457: NEG
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: PUSH
82463: LD_INT 3
82465: NEG
82466: PUSH
82467: LD_INT 5
82469: NEG
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: PUSH
82475: LD_INT 5
82477: NEG
82478: PUSH
82479: LD_INT 3
82481: NEG
82482: PUSH
82483: EMPTY
82484: LIST
82485: LIST
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: LIST
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: LIST
82505: LIST
82506: LIST
82507: LIST
82508: LIST
82509: LIST
82510: LIST
82511: LIST
82512: LIST
82513: LIST
82514: LIST
82515: LIST
82516: LIST
82517: LIST
82518: LIST
82519: LIST
82520: LIST
82521: LIST
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
82534: LD_ADDR_VAR 0 30
82538: PUSH
82539: LD_INT 4
82541: PUSH
82542: LD_INT 4
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PUSH
82549: LD_INT 4
82551: PUSH
82552: LD_INT 3
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: PUSH
82559: LD_INT 5
82561: PUSH
82562: LD_INT 4
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 5
82571: PUSH
82572: LD_INT 5
82574: PUSH
82575: EMPTY
82576: LIST
82577: LIST
82578: PUSH
82579: LD_INT 4
82581: PUSH
82582: LD_INT 5
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 3
82591: PUSH
82592: LD_INT 4
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 3
82601: PUSH
82602: LD_INT 3
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: PUSH
82609: LD_INT 5
82611: PUSH
82612: LD_INT 3
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: PUSH
82619: LD_INT 3
82621: PUSH
82622: LD_INT 5
82624: PUSH
82625: EMPTY
82626: LIST
82627: LIST
82628: PUSH
82629: LD_INT 0
82631: PUSH
82632: LD_INT 3
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 0
82641: PUSH
82642: LD_INT 2
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 1
82651: PUSH
82652: LD_INT 3
82654: PUSH
82655: EMPTY
82656: LIST
82657: LIST
82658: PUSH
82659: LD_INT 1
82661: PUSH
82662: LD_INT 4
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 0
82671: PUSH
82672: LD_INT 4
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 1
82681: NEG
82682: PUSH
82683: LD_INT 3
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 1
82692: NEG
82693: PUSH
82694: LD_INT 2
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: PUSH
82701: LD_INT 2
82703: PUSH
82704: LD_INT 4
82706: PUSH
82707: EMPTY
82708: LIST
82709: LIST
82710: PUSH
82711: LD_INT 2
82713: NEG
82714: PUSH
82715: LD_INT 2
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 4
82724: NEG
82725: PUSH
82726: LD_INT 0
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: PUSH
82733: LD_INT 4
82735: NEG
82736: PUSH
82737: LD_INT 1
82739: NEG
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 3
82747: NEG
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 3
82758: NEG
82759: PUSH
82760: LD_INT 1
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: PUSH
82767: LD_INT 4
82769: NEG
82770: PUSH
82771: LD_INT 1
82773: PUSH
82774: EMPTY
82775: LIST
82776: LIST
82777: PUSH
82778: LD_INT 5
82780: NEG
82781: PUSH
82782: LD_INT 0
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 5
82791: NEG
82792: PUSH
82793: LD_INT 1
82795: NEG
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 5
82803: NEG
82804: PUSH
82805: LD_INT 2
82807: NEG
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: PUSH
82813: LD_INT 3
82815: NEG
82816: PUSH
82817: LD_INT 2
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: PUSH
82824: LD_INT 3
82826: NEG
82827: PUSH
82828: LD_INT 3
82830: NEG
82831: PUSH
82832: EMPTY
82833: LIST
82834: LIST
82835: PUSH
82836: LD_INT 3
82838: NEG
82839: PUSH
82840: LD_INT 4
82842: NEG
82843: PUSH
82844: EMPTY
82845: LIST
82846: LIST
82847: PUSH
82848: LD_INT 2
82850: NEG
82851: PUSH
82852: LD_INT 3
82854: NEG
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 2
82862: NEG
82863: PUSH
82864: LD_INT 2
82866: NEG
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: PUSH
82872: LD_INT 3
82874: NEG
82875: PUSH
82876: LD_INT 2
82878: NEG
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 4
82886: NEG
82887: PUSH
82888: LD_INT 3
82890: NEG
82891: PUSH
82892: EMPTY
82893: LIST
82894: LIST
82895: PUSH
82896: LD_INT 4
82898: NEG
82899: PUSH
82900: LD_INT 4
82902: NEG
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 2
82910: NEG
82911: PUSH
82912: LD_INT 4
82914: NEG
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: PUSH
82920: LD_INT 4
82922: NEG
82923: PUSH
82924: LD_INT 2
82926: NEG
82927: PUSH
82928: EMPTY
82929: LIST
82930: LIST
82931: PUSH
82932: LD_INT 0
82934: PUSH
82935: LD_INT 4
82937: NEG
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: PUSH
82943: LD_INT 0
82945: PUSH
82946: LD_INT 5
82948: NEG
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: PUSH
82954: LD_INT 1
82956: PUSH
82957: LD_INT 4
82959: NEG
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: PUSH
82965: LD_INT 1
82967: PUSH
82968: LD_INT 3
82970: NEG
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: PUSH
82976: LD_INT 0
82978: PUSH
82979: LD_INT 3
82981: NEG
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 1
82989: NEG
82990: PUSH
82991: LD_INT 4
82993: NEG
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: LD_INT 1
83001: NEG
83002: PUSH
83003: LD_INT 5
83005: NEG
83006: PUSH
83007: EMPTY
83008: LIST
83009: LIST
83010: PUSH
83011: LD_INT 2
83013: PUSH
83014: LD_INT 3
83016: NEG
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 2
83024: NEG
83025: PUSH
83026: LD_INT 5
83028: NEG
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: PUSH
83034: EMPTY
83035: LIST
83036: LIST
83037: LIST
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: LIST
83061: LIST
83062: LIST
83063: LIST
83064: LIST
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
83081: LD_ADDR_VAR 0 31
83085: PUSH
83086: LD_INT 0
83088: PUSH
83089: LD_INT 4
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 0
83098: PUSH
83099: LD_INT 3
83101: PUSH
83102: EMPTY
83103: LIST
83104: LIST
83105: PUSH
83106: LD_INT 1
83108: PUSH
83109: LD_INT 4
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: PUSH
83116: LD_INT 1
83118: PUSH
83119: LD_INT 5
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: PUSH
83126: LD_INT 0
83128: PUSH
83129: LD_INT 5
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 1
83138: NEG
83139: PUSH
83140: LD_INT 4
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 1
83149: NEG
83150: PUSH
83151: LD_INT 3
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 2
83160: PUSH
83161: LD_INT 5
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 2
83170: NEG
83171: PUSH
83172: LD_INT 3
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 3
83181: NEG
83182: PUSH
83183: LD_INT 0
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: PUSH
83190: LD_INT 3
83192: NEG
83193: PUSH
83194: LD_INT 1
83196: NEG
83197: PUSH
83198: EMPTY
83199: LIST
83200: LIST
83201: PUSH
83202: LD_INT 2
83204: NEG
83205: PUSH
83206: LD_INT 0
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PUSH
83213: LD_INT 2
83215: NEG
83216: PUSH
83217: LD_INT 1
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 3
83226: NEG
83227: PUSH
83228: LD_INT 1
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: LD_INT 4
83237: NEG
83238: PUSH
83239: LD_INT 0
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: PUSH
83246: LD_INT 4
83248: NEG
83249: PUSH
83250: LD_INT 1
83252: NEG
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: PUSH
83258: LD_INT 4
83260: NEG
83261: PUSH
83262: LD_INT 2
83264: NEG
83265: PUSH
83266: EMPTY
83267: LIST
83268: LIST
83269: PUSH
83270: LD_INT 2
83272: NEG
83273: PUSH
83274: LD_INT 2
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: PUSH
83281: LD_INT 4
83283: NEG
83284: PUSH
83285: LD_INT 4
83287: NEG
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 4
83295: NEG
83296: PUSH
83297: LD_INT 5
83299: NEG
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: PUSH
83305: LD_INT 3
83307: NEG
83308: PUSH
83309: LD_INT 4
83311: NEG
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 3
83319: NEG
83320: PUSH
83321: LD_INT 3
83323: NEG
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: LD_INT 4
83331: NEG
83332: PUSH
83333: LD_INT 3
83335: NEG
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 5
83343: NEG
83344: PUSH
83345: LD_INT 4
83347: NEG
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: PUSH
83353: LD_INT 5
83355: NEG
83356: PUSH
83357: LD_INT 5
83359: NEG
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 3
83367: NEG
83368: PUSH
83369: LD_INT 5
83371: NEG
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 5
83379: NEG
83380: PUSH
83381: LD_INT 3
83383: NEG
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: PUSH
83389: LD_INT 0
83391: PUSH
83392: LD_INT 3
83394: NEG
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PUSH
83400: LD_INT 0
83402: PUSH
83403: LD_INT 4
83405: NEG
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: PUSH
83411: LD_INT 1
83413: PUSH
83414: LD_INT 3
83416: NEG
83417: PUSH
83418: EMPTY
83419: LIST
83420: LIST
83421: PUSH
83422: LD_INT 1
83424: PUSH
83425: LD_INT 2
83427: NEG
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: PUSH
83433: LD_INT 0
83435: PUSH
83436: LD_INT 2
83438: NEG
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 1
83446: NEG
83447: PUSH
83448: LD_INT 3
83450: NEG
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 1
83458: NEG
83459: PUSH
83460: LD_INT 4
83462: NEG
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: PUSH
83468: LD_INT 2
83470: PUSH
83471: LD_INT 2
83473: NEG
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 2
83481: NEG
83482: PUSH
83483: LD_INT 4
83485: NEG
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 4
83493: PUSH
83494: LD_INT 0
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 4
83503: PUSH
83504: LD_INT 1
83506: NEG
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 5
83514: PUSH
83515: LD_INT 0
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 5
83524: PUSH
83525: LD_INT 1
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 4
83534: PUSH
83535: LD_INT 1
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 3
83544: PUSH
83545: LD_INT 0
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 3
83554: PUSH
83555: LD_INT 1
83557: NEG
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 3
83565: PUSH
83566: LD_INT 2
83568: NEG
83569: PUSH
83570: EMPTY
83571: LIST
83572: LIST
83573: PUSH
83574: LD_INT 5
83576: PUSH
83577: LD_INT 2
83579: PUSH
83580: EMPTY
83581: LIST
83582: LIST
83583: PUSH
83584: EMPTY
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: LIST
83590: LIST
83591: LIST
83592: LIST
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
83631: LD_ADDR_VAR 0 32
83635: PUSH
83636: LD_INT 4
83638: NEG
83639: PUSH
83640: LD_INT 0
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: PUSH
83647: LD_INT 4
83649: NEG
83650: PUSH
83651: LD_INT 1
83653: NEG
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 3
83661: NEG
83662: PUSH
83663: LD_INT 0
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_INT 3
83672: NEG
83673: PUSH
83674: LD_INT 1
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 4
83683: NEG
83684: PUSH
83685: LD_INT 1
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 5
83694: NEG
83695: PUSH
83696: LD_INT 0
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 5
83705: NEG
83706: PUSH
83707: LD_INT 1
83709: NEG
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 5
83717: NEG
83718: PUSH
83719: LD_INT 2
83721: NEG
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: LD_INT 3
83729: NEG
83730: PUSH
83731: LD_INT 2
83733: PUSH
83734: EMPTY
83735: LIST
83736: LIST
83737: PUSH
83738: LD_INT 3
83740: NEG
83741: PUSH
83742: LD_INT 3
83744: NEG
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: PUSH
83750: LD_INT 3
83752: NEG
83753: PUSH
83754: LD_INT 4
83756: NEG
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 2
83764: NEG
83765: PUSH
83766: LD_INT 3
83768: NEG
83769: PUSH
83770: EMPTY
83771: LIST
83772: LIST
83773: PUSH
83774: LD_INT 2
83776: NEG
83777: PUSH
83778: LD_INT 2
83780: NEG
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: PUSH
83786: LD_INT 3
83788: NEG
83789: PUSH
83790: LD_INT 2
83792: NEG
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: PUSH
83798: LD_INT 4
83800: NEG
83801: PUSH
83802: LD_INT 3
83804: NEG
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: LD_INT 4
83812: NEG
83813: PUSH
83814: LD_INT 4
83816: NEG
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: PUSH
83822: LD_INT 2
83824: NEG
83825: PUSH
83826: LD_INT 4
83828: NEG
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 4
83836: NEG
83837: PUSH
83838: LD_INT 2
83840: NEG
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: LD_INT 0
83848: PUSH
83849: LD_INT 4
83851: NEG
83852: PUSH
83853: EMPTY
83854: LIST
83855: LIST
83856: PUSH
83857: LD_INT 0
83859: PUSH
83860: LD_INT 5
83862: NEG
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: PUSH
83871: LD_INT 4
83873: NEG
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 1
83881: PUSH
83882: LD_INT 3
83884: NEG
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 0
83892: PUSH
83893: LD_INT 3
83895: NEG
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 1
83903: NEG
83904: PUSH
83905: LD_INT 4
83907: NEG
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: LD_INT 1
83915: NEG
83916: PUSH
83917: LD_INT 5
83919: NEG
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: PUSH
83925: LD_INT 2
83927: PUSH
83928: LD_INT 3
83930: NEG
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 2
83938: NEG
83939: PUSH
83940: LD_INT 5
83942: NEG
83943: PUSH
83944: EMPTY
83945: LIST
83946: LIST
83947: PUSH
83948: LD_INT 3
83950: PUSH
83951: LD_INT 0
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: PUSH
83958: LD_INT 3
83960: PUSH
83961: LD_INT 1
83963: NEG
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PUSH
83969: LD_INT 4
83971: PUSH
83972: LD_INT 0
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PUSH
83979: LD_INT 4
83981: PUSH
83982: LD_INT 1
83984: PUSH
83985: EMPTY
83986: LIST
83987: LIST
83988: PUSH
83989: LD_INT 3
83991: PUSH
83992: LD_INT 1
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: LD_INT 2
84001: PUSH
84002: LD_INT 0
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 2
84011: PUSH
84012: LD_INT 1
84014: NEG
84015: PUSH
84016: EMPTY
84017: LIST
84018: LIST
84019: PUSH
84020: LD_INT 2
84022: PUSH
84023: LD_INT 2
84025: NEG
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: PUSH
84031: LD_INT 4
84033: PUSH
84034: LD_INT 2
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: LD_INT 4
84043: PUSH
84044: LD_INT 4
84046: PUSH
84047: EMPTY
84048: LIST
84049: LIST
84050: PUSH
84051: LD_INT 4
84053: PUSH
84054: LD_INT 3
84056: PUSH
84057: EMPTY
84058: LIST
84059: LIST
84060: PUSH
84061: LD_INT 5
84063: PUSH
84064: LD_INT 4
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: PUSH
84071: LD_INT 5
84073: PUSH
84074: LD_INT 5
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 4
84083: PUSH
84084: LD_INT 5
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 3
84093: PUSH
84094: LD_INT 4
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PUSH
84101: LD_INT 3
84103: PUSH
84104: LD_INT 3
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: LD_INT 5
84113: PUSH
84114: LD_INT 3
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: PUSH
84121: LD_INT 3
84123: PUSH
84124: LD_INT 5
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: LIST
84176: LIST
84177: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
84178: LD_ADDR_VAR 0 33
84182: PUSH
84183: LD_INT 4
84185: NEG
84186: PUSH
84187: LD_INT 4
84189: NEG
84190: PUSH
84191: EMPTY
84192: LIST
84193: LIST
84194: PUSH
84195: LD_INT 4
84197: NEG
84198: PUSH
84199: LD_INT 5
84201: NEG
84202: PUSH
84203: EMPTY
84204: LIST
84205: LIST
84206: PUSH
84207: LD_INT 3
84209: NEG
84210: PUSH
84211: LD_INT 4
84213: NEG
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 3
84221: NEG
84222: PUSH
84223: LD_INT 3
84225: NEG
84226: PUSH
84227: EMPTY
84228: LIST
84229: LIST
84230: PUSH
84231: LD_INT 4
84233: NEG
84234: PUSH
84235: LD_INT 3
84237: NEG
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: PUSH
84243: LD_INT 5
84245: NEG
84246: PUSH
84247: LD_INT 4
84249: NEG
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 5
84257: NEG
84258: PUSH
84259: LD_INT 5
84261: NEG
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: PUSH
84267: LD_INT 3
84269: NEG
84270: PUSH
84271: LD_INT 5
84273: NEG
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: PUSH
84279: LD_INT 5
84281: NEG
84282: PUSH
84283: LD_INT 3
84285: NEG
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 0
84293: PUSH
84294: LD_INT 3
84296: NEG
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: PUSH
84302: LD_INT 0
84304: PUSH
84305: LD_INT 4
84307: NEG
84308: PUSH
84309: EMPTY
84310: LIST
84311: LIST
84312: PUSH
84313: LD_INT 1
84315: PUSH
84316: LD_INT 3
84318: NEG
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: PUSH
84324: LD_INT 1
84326: PUSH
84327: LD_INT 2
84329: NEG
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: PUSH
84335: LD_INT 0
84337: PUSH
84338: LD_INT 2
84340: NEG
84341: PUSH
84342: EMPTY
84343: LIST
84344: LIST
84345: PUSH
84346: LD_INT 1
84348: NEG
84349: PUSH
84350: LD_INT 3
84352: NEG
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 1
84360: NEG
84361: PUSH
84362: LD_INT 4
84364: NEG
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: PUSH
84370: LD_INT 2
84372: PUSH
84373: LD_INT 2
84375: NEG
84376: PUSH
84377: EMPTY
84378: LIST
84379: LIST
84380: PUSH
84381: LD_INT 2
84383: NEG
84384: PUSH
84385: LD_INT 4
84387: NEG
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 4
84395: PUSH
84396: LD_INT 0
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 4
84405: PUSH
84406: LD_INT 1
84408: NEG
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 5
84416: PUSH
84417: LD_INT 0
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 5
84426: PUSH
84427: LD_INT 1
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 4
84436: PUSH
84437: LD_INT 1
84439: PUSH
84440: EMPTY
84441: LIST
84442: LIST
84443: PUSH
84444: LD_INT 3
84446: PUSH
84447: LD_INT 0
84449: PUSH
84450: EMPTY
84451: LIST
84452: LIST
84453: PUSH
84454: LD_INT 3
84456: PUSH
84457: LD_INT 1
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 3
84467: PUSH
84468: LD_INT 2
84470: NEG
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: PUSH
84476: LD_INT 5
84478: PUSH
84479: LD_INT 2
84481: PUSH
84482: EMPTY
84483: LIST
84484: LIST
84485: PUSH
84486: LD_INT 3
84488: PUSH
84489: LD_INT 3
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: PUSH
84496: LD_INT 3
84498: PUSH
84499: LD_INT 2
84501: PUSH
84502: EMPTY
84503: LIST
84504: LIST
84505: PUSH
84506: LD_INT 4
84508: PUSH
84509: LD_INT 3
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: PUSH
84516: LD_INT 4
84518: PUSH
84519: LD_INT 4
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: PUSH
84526: LD_INT 3
84528: PUSH
84529: LD_INT 4
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: PUSH
84536: LD_INT 2
84538: PUSH
84539: LD_INT 3
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 2
84548: PUSH
84549: LD_INT 2
84551: PUSH
84552: EMPTY
84553: LIST
84554: LIST
84555: PUSH
84556: LD_INT 4
84558: PUSH
84559: LD_INT 2
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 2
84568: PUSH
84569: LD_INT 4
84571: PUSH
84572: EMPTY
84573: LIST
84574: LIST
84575: PUSH
84576: LD_INT 0
84578: PUSH
84579: LD_INT 4
84581: PUSH
84582: EMPTY
84583: LIST
84584: LIST
84585: PUSH
84586: LD_INT 0
84588: PUSH
84589: LD_INT 3
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 1
84598: PUSH
84599: LD_INT 4
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 1
84608: PUSH
84609: LD_INT 5
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 0
84618: PUSH
84619: LD_INT 5
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: PUSH
84626: LD_INT 1
84628: NEG
84629: PUSH
84630: LD_INT 4
84632: PUSH
84633: EMPTY
84634: LIST
84635: LIST
84636: PUSH
84637: LD_INT 1
84639: NEG
84640: PUSH
84641: LD_INT 3
84643: PUSH
84644: EMPTY
84645: LIST
84646: LIST
84647: PUSH
84648: LD_INT 2
84650: PUSH
84651: LD_INT 5
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: LD_INT 2
84660: NEG
84661: PUSH
84662: LD_INT 3
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: LIST
84684: LIST
84685: LIST
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: LIST
84691: LIST
84692: LIST
84693: LIST
84694: LIST
84695: LIST
84696: LIST
84697: LIST
84698: LIST
84699: LIST
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: LIST
84705: LIST
84706: LIST
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: LIST
84715: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
84716: LD_ADDR_VAR 0 34
84720: PUSH
84721: LD_INT 0
84723: PUSH
84724: LD_INT 4
84726: NEG
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 0
84734: PUSH
84735: LD_INT 5
84737: NEG
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: PUSH
84743: LD_INT 1
84745: PUSH
84746: LD_INT 4
84748: NEG
84749: PUSH
84750: EMPTY
84751: LIST
84752: LIST
84753: PUSH
84754: LD_INT 1
84756: PUSH
84757: LD_INT 3
84759: NEG
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: PUSH
84765: LD_INT 0
84767: PUSH
84768: LD_INT 3
84770: NEG
84771: PUSH
84772: EMPTY
84773: LIST
84774: LIST
84775: PUSH
84776: LD_INT 1
84778: NEG
84779: PUSH
84780: LD_INT 4
84782: NEG
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PUSH
84788: LD_INT 1
84790: NEG
84791: PUSH
84792: LD_INT 5
84794: NEG
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 2
84802: PUSH
84803: LD_INT 3
84805: NEG
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: LD_INT 2
84813: NEG
84814: PUSH
84815: LD_INT 5
84817: NEG
84818: PUSH
84819: EMPTY
84820: LIST
84821: LIST
84822: PUSH
84823: LD_INT 3
84825: PUSH
84826: LD_INT 0
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PUSH
84833: LD_INT 3
84835: PUSH
84836: LD_INT 1
84838: NEG
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: PUSH
84844: LD_INT 4
84846: PUSH
84847: LD_INT 0
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: PUSH
84854: LD_INT 4
84856: PUSH
84857: LD_INT 1
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 3
84866: PUSH
84867: LD_INT 1
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 2
84876: PUSH
84877: LD_INT 0
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 2
84886: PUSH
84887: LD_INT 1
84889: NEG
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 2
84897: PUSH
84898: LD_INT 2
84900: NEG
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 4
84908: PUSH
84909: LD_INT 2
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 4
84918: PUSH
84919: LD_INT 4
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 4
84928: PUSH
84929: LD_INT 3
84931: PUSH
84932: EMPTY
84933: LIST
84934: LIST
84935: PUSH
84936: LD_INT 5
84938: PUSH
84939: LD_INT 4
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 5
84948: PUSH
84949: LD_INT 5
84951: PUSH
84952: EMPTY
84953: LIST
84954: LIST
84955: PUSH
84956: LD_INT 4
84958: PUSH
84959: LD_INT 5
84961: PUSH
84962: EMPTY
84963: LIST
84964: LIST
84965: PUSH
84966: LD_INT 3
84968: PUSH
84969: LD_INT 4
84971: PUSH
84972: EMPTY
84973: LIST
84974: LIST
84975: PUSH
84976: LD_INT 3
84978: PUSH
84979: LD_INT 3
84981: PUSH
84982: EMPTY
84983: LIST
84984: LIST
84985: PUSH
84986: LD_INT 5
84988: PUSH
84989: LD_INT 3
84991: PUSH
84992: EMPTY
84993: LIST
84994: LIST
84995: PUSH
84996: LD_INT 3
84998: PUSH
84999: LD_INT 5
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 0
85008: PUSH
85009: LD_INT 3
85011: PUSH
85012: EMPTY
85013: LIST
85014: LIST
85015: PUSH
85016: LD_INT 0
85018: PUSH
85019: LD_INT 2
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: PUSH
85026: LD_INT 1
85028: PUSH
85029: LD_INT 3
85031: PUSH
85032: EMPTY
85033: LIST
85034: LIST
85035: PUSH
85036: LD_INT 1
85038: PUSH
85039: LD_INT 4
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: LD_INT 0
85048: PUSH
85049: LD_INT 4
85051: PUSH
85052: EMPTY
85053: LIST
85054: LIST
85055: PUSH
85056: LD_INT 1
85058: NEG
85059: PUSH
85060: LD_INT 3
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 1
85069: NEG
85070: PUSH
85071: LD_INT 2
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: LD_INT 2
85080: PUSH
85081: LD_INT 4
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 2
85090: NEG
85091: PUSH
85092: LD_INT 2
85094: PUSH
85095: EMPTY
85096: LIST
85097: LIST
85098: PUSH
85099: LD_INT 4
85101: NEG
85102: PUSH
85103: LD_INT 0
85105: PUSH
85106: EMPTY
85107: LIST
85108: LIST
85109: PUSH
85110: LD_INT 4
85112: NEG
85113: PUSH
85114: LD_INT 1
85116: NEG
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: PUSH
85122: LD_INT 3
85124: NEG
85125: PUSH
85126: LD_INT 0
85128: PUSH
85129: EMPTY
85130: LIST
85131: LIST
85132: PUSH
85133: LD_INT 3
85135: NEG
85136: PUSH
85137: LD_INT 1
85139: PUSH
85140: EMPTY
85141: LIST
85142: LIST
85143: PUSH
85144: LD_INT 4
85146: NEG
85147: PUSH
85148: LD_INT 1
85150: PUSH
85151: EMPTY
85152: LIST
85153: LIST
85154: PUSH
85155: LD_INT 5
85157: NEG
85158: PUSH
85159: LD_INT 0
85161: PUSH
85162: EMPTY
85163: LIST
85164: LIST
85165: PUSH
85166: LD_INT 5
85168: NEG
85169: PUSH
85170: LD_INT 1
85172: NEG
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: PUSH
85178: LD_INT 5
85180: NEG
85181: PUSH
85182: LD_INT 2
85184: NEG
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 3
85192: NEG
85193: PUSH
85194: LD_INT 2
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: LIST
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: LIST
85246: LIST
85247: ST_TO_ADDR
// end ; end ;
85248: GO 85251
85250: POP
// case btype of b_depot , b_warehouse :
85251: LD_VAR 0 1
85255: PUSH
85256: LD_INT 0
85258: DOUBLE
85259: EQUAL
85260: IFTRUE 85270
85262: LD_INT 1
85264: DOUBLE
85265: EQUAL
85266: IFTRUE 85270
85268: GO 85471
85270: POP
// case nation of nation_american :
85271: LD_VAR 0 5
85275: PUSH
85276: LD_INT 1
85278: DOUBLE
85279: EQUAL
85280: IFTRUE 85284
85282: GO 85340
85284: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
85285: LD_ADDR_VAR 0 9
85289: PUSH
85290: LD_VAR 0 11
85294: PUSH
85295: LD_VAR 0 12
85299: PUSH
85300: LD_VAR 0 13
85304: PUSH
85305: LD_VAR 0 14
85309: PUSH
85310: LD_VAR 0 15
85314: PUSH
85315: LD_VAR 0 16
85319: PUSH
85320: EMPTY
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: PUSH
85328: LD_VAR 0 4
85332: PUSH
85333: LD_INT 1
85335: PLUS
85336: ARRAY
85337: ST_TO_ADDR
85338: GO 85469
85340: LD_INT 2
85342: DOUBLE
85343: EQUAL
85344: IFTRUE 85348
85346: GO 85404
85348: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
85349: LD_ADDR_VAR 0 9
85353: PUSH
85354: LD_VAR 0 17
85358: PUSH
85359: LD_VAR 0 18
85363: PUSH
85364: LD_VAR 0 19
85368: PUSH
85369: LD_VAR 0 20
85373: PUSH
85374: LD_VAR 0 21
85378: PUSH
85379: LD_VAR 0 22
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: PUSH
85392: LD_VAR 0 4
85396: PUSH
85397: LD_INT 1
85399: PLUS
85400: ARRAY
85401: ST_TO_ADDR
85402: GO 85469
85404: LD_INT 3
85406: DOUBLE
85407: EQUAL
85408: IFTRUE 85412
85410: GO 85468
85412: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
85413: LD_ADDR_VAR 0 9
85417: PUSH
85418: LD_VAR 0 23
85422: PUSH
85423: LD_VAR 0 24
85427: PUSH
85428: LD_VAR 0 25
85432: PUSH
85433: LD_VAR 0 26
85437: PUSH
85438: LD_VAR 0 27
85442: PUSH
85443: LD_VAR 0 28
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: LIST
85452: LIST
85453: LIST
85454: LIST
85455: PUSH
85456: LD_VAR 0 4
85460: PUSH
85461: LD_INT 1
85463: PLUS
85464: ARRAY
85465: ST_TO_ADDR
85466: GO 85469
85468: POP
85469: GO 86024
85471: LD_INT 2
85473: DOUBLE
85474: EQUAL
85475: IFTRUE 85485
85477: LD_INT 3
85479: DOUBLE
85480: EQUAL
85481: IFTRUE 85485
85483: GO 85541
85485: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
85486: LD_ADDR_VAR 0 9
85490: PUSH
85491: LD_VAR 0 29
85495: PUSH
85496: LD_VAR 0 30
85500: PUSH
85501: LD_VAR 0 31
85505: PUSH
85506: LD_VAR 0 32
85510: PUSH
85511: LD_VAR 0 33
85515: PUSH
85516: LD_VAR 0 34
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: PUSH
85529: LD_VAR 0 4
85533: PUSH
85534: LD_INT 1
85536: PLUS
85537: ARRAY
85538: ST_TO_ADDR
85539: GO 86024
85541: LD_INT 16
85543: DOUBLE
85544: EQUAL
85545: IFTRUE 85603
85547: LD_INT 17
85549: DOUBLE
85550: EQUAL
85551: IFTRUE 85603
85553: LD_INT 18
85555: DOUBLE
85556: EQUAL
85557: IFTRUE 85603
85559: LD_INT 19
85561: DOUBLE
85562: EQUAL
85563: IFTRUE 85603
85565: LD_INT 22
85567: DOUBLE
85568: EQUAL
85569: IFTRUE 85603
85571: LD_INT 20
85573: DOUBLE
85574: EQUAL
85575: IFTRUE 85603
85577: LD_INT 21
85579: DOUBLE
85580: EQUAL
85581: IFTRUE 85603
85583: LD_INT 23
85585: DOUBLE
85586: EQUAL
85587: IFTRUE 85603
85589: LD_INT 24
85591: DOUBLE
85592: EQUAL
85593: IFTRUE 85603
85595: LD_INT 25
85597: DOUBLE
85598: EQUAL
85599: IFTRUE 85603
85601: GO 85659
85603: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
85604: LD_ADDR_VAR 0 9
85608: PUSH
85609: LD_VAR 0 35
85613: PUSH
85614: LD_VAR 0 36
85618: PUSH
85619: LD_VAR 0 37
85623: PUSH
85624: LD_VAR 0 38
85628: PUSH
85629: LD_VAR 0 39
85633: PUSH
85634: LD_VAR 0 40
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: PUSH
85647: LD_VAR 0 4
85651: PUSH
85652: LD_INT 1
85654: PLUS
85655: ARRAY
85656: ST_TO_ADDR
85657: GO 86024
85659: LD_INT 6
85661: DOUBLE
85662: EQUAL
85663: IFTRUE 85715
85665: LD_INT 7
85667: DOUBLE
85668: EQUAL
85669: IFTRUE 85715
85671: LD_INT 8
85673: DOUBLE
85674: EQUAL
85675: IFTRUE 85715
85677: LD_INT 13
85679: DOUBLE
85680: EQUAL
85681: IFTRUE 85715
85683: LD_INT 12
85685: DOUBLE
85686: EQUAL
85687: IFTRUE 85715
85689: LD_INT 15
85691: DOUBLE
85692: EQUAL
85693: IFTRUE 85715
85695: LD_INT 11
85697: DOUBLE
85698: EQUAL
85699: IFTRUE 85715
85701: LD_INT 14
85703: DOUBLE
85704: EQUAL
85705: IFTRUE 85715
85707: LD_INT 10
85709: DOUBLE
85710: EQUAL
85711: IFTRUE 85715
85713: GO 85771
85715: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
85716: LD_ADDR_VAR 0 9
85720: PUSH
85721: LD_VAR 0 41
85725: PUSH
85726: LD_VAR 0 42
85730: PUSH
85731: LD_VAR 0 43
85735: PUSH
85736: LD_VAR 0 44
85740: PUSH
85741: LD_VAR 0 45
85745: PUSH
85746: LD_VAR 0 46
85750: PUSH
85751: EMPTY
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: PUSH
85759: LD_VAR 0 4
85763: PUSH
85764: LD_INT 1
85766: PLUS
85767: ARRAY
85768: ST_TO_ADDR
85769: GO 86024
85771: LD_INT 36
85773: DOUBLE
85774: EQUAL
85775: IFTRUE 85779
85777: GO 85835
85779: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
85780: LD_ADDR_VAR 0 9
85784: PUSH
85785: LD_VAR 0 47
85789: PUSH
85790: LD_VAR 0 48
85794: PUSH
85795: LD_VAR 0 49
85799: PUSH
85800: LD_VAR 0 50
85804: PUSH
85805: LD_VAR 0 51
85809: PUSH
85810: LD_VAR 0 52
85814: PUSH
85815: EMPTY
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: PUSH
85823: LD_VAR 0 4
85827: PUSH
85828: LD_INT 1
85830: PLUS
85831: ARRAY
85832: ST_TO_ADDR
85833: GO 86024
85835: LD_INT 4
85837: DOUBLE
85838: EQUAL
85839: IFTRUE 85861
85841: LD_INT 5
85843: DOUBLE
85844: EQUAL
85845: IFTRUE 85861
85847: LD_INT 34
85849: DOUBLE
85850: EQUAL
85851: IFTRUE 85861
85853: LD_INT 37
85855: DOUBLE
85856: EQUAL
85857: IFTRUE 85861
85859: GO 85917
85861: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
85862: LD_ADDR_VAR 0 9
85866: PUSH
85867: LD_VAR 0 53
85871: PUSH
85872: LD_VAR 0 54
85876: PUSH
85877: LD_VAR 0 55
85881: PUSH
85882: LD_VAR 0 56
85886: PUSH
85887: LD_VAR 0 57
85891: PUSH
85892: LD_VAR 0 58
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: PUSH
85905: LD_VAR 0 4
85909: PUSH
85910: LD_INT 1
85912: PLUS
85913: ARRAY
85914: ST_TO_ADDR
85915: GO 86024
85917: LD_INT 31
85919: DOUBLE
85920: EQUAL
85921: IFTRUE 85967
85923: LD_INT 32
85925: DOUBLE
85926: EQUAL
85927: IFTRUE 85967
85929: LD_INT 33
85931: DOUBLE
85932: EQUAL
85933: IFTRUE 85967
85935: LD_INT 27
85937: DOUBLE
85938: EQUAL
85939: IFTRUE 85967
85941: LD_INT 26
85943: DOUBLE
85944: EQUAL
85945: IFTRUE 85967
85947: LD_INT 28
85949: DOUBLE
85950: EQUAL
85951: IFTRUE 85967
85953: LD_INT 29
85955: DOUBLE
85956: EQUAL
85957: IFTRUE 85967
85959: LD_INT 30
85961: DOUBLE
85962: EQUAL
85963: IFTRUE 85967
85965: GO 86023
85967: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
85968: LD_ADDR_VAR 0 9
85972: PUSH
85973: LD_VAR 0 59
85977: PUSH
85978: LD_VAR 0 60
85982: PUSH
85983: LD_VAR 0 61
85987: PUSH
85988: LD_VAR 0 62
85992: PUSH
85993: LD_VAR 0 63
85997: PUSH
85998: LD_VAR 0 64
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: LIST
86010: PUSH
86011: LD_VAR 0 4
86015: PUSH
86016: LD_INT 1
86018: PLUS
86019: ARRAY
86020: ST_TO_ADDR
86021: GO 86024
86023: POP
// temp_list2 = [ ] ;
86024: LD_ADDR_VAR 0 10
86028: PUSH
86029: EMPTY
86030: ST_TO_ADDR
// for i in temp_list do
86031: LD_ADDR_VAR 0 8
86035: PUSH
86036: LD_VAR 0 9
86040: PUSH
86041: FOR_IN
86042: IFFALSE 86094
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
86044: LD_ADDR_VAR 0 10
86048: PUSH
86049: LD_VAR 0 10
86053: PUSH
86054: LD_VAR 0 8
86058: PUSH
86059: LD_INT 1
86061: ARRAY
86062: PUSH
86063: LD_VAR 0 2
86067: PLUS
86068: PUSH
86069: LD_VAR 0 8
86073: PUSH
86074: LD_INT 2
86076: ARRAY
86077: PUSH
86078: LD_VAR 0 3
86082: PLUS
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: EMPTY
86089: LIST
86090: ADD
86091: ST_TO_ADDR
86092: GO 86041
86094: POP
86095: POP
// result = temp_list2 ;
86096: LD_ADDR_VAR 0 7
86100: PUSH
86101: LD_VAR 0 10
86105: ST_TO_ADDR
// end ;
86106: LD_VAR 0 7
86110: RET
// export function EnemyInRange ( unit , dist ) ; begin
86111: LD_INT 0
86113: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
86114: LD_ADDR_VAR 0 3
86118: PUSH
86119: LD_VAR 0 1
86123: PPUSH
86124: CALL_OW 255
86128: PPUSH
86129: LD_VAR 0 1
86133: PPUSH
86134: CALL_OW 250
86138: PPUSH
86139: LD_VAR 0 1
86143: PPUSH
86144: CALL_OW 251
86148: PPUSH
86149: LD_VAR 0 2
86153: PPUSH
86154: CALL 59484 0 4
86158: PUSH
86159: LD_INT 4
86161: ARRAY
86162: ST_TO_ADDR
// end ;
86163: LD_VAR 0 3
86167: RET
// export function PlayerSeeMe ( unit ) ; begin
86168: LD_INT 0
86170: PPUSH
// result := See ( your_side , unit ) ;
86171: LD_ADDR_VAR 0 2
86175: PUSH
86176: LD_OWVAR 2
86180: PPUSH
86181: LD_VAR 0 1
86185: PPUSH
86186: CALL_OW 292
86190: ST_TO_ADDR
// end ;
86191: LD_VAR 0 2
86195: RET
// export function ReverseDir ( unit ) ; begin
86196: LD_INT 0
86198: PPUSH
// if not unit then
86199: LD_VAR 0 1
86203: NOT
86204: IFFALSE 86208
// exit ;
86206: GO 86231
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
86208: LD_ADDR_VAR 0 2
86212: PUSH
86213: LD_VAR 0 1
86217: PPUSH
86218: CALL_OW 254
86222: PUSH
86223: LD_INT 3
86225: PLUS
86226: PUSH
86227: LD_INT 6
86229: MOD
86230: ST_TO_ADDR
// end ;
86231: LD_VAR 0 2
86235: RET
// export function ReverseArray ( array ) ; var i ; begin
86236: LD_INT 0
86238: PPUSH
86239: PPUSH
// if not array then
86240: LD_VAR 0 1
86244: NOT
86245: IFFALSE 86249
// exit ;
86247: GO 86304
// result := [ ] ;
86249: LD_ADDR_VAR 0 2
86253: PUSH
86254: EMPTY
86255: ST_TO_ADDR
// for i := array downto 1 do
86256: LD_ADDR_VAR 0 3
86260: PUSH
86261: DOUBLE
86262: LD_VAR 0 1
86266: INC
86267: ST_TO_ADDR
86268: LD_INT 1
86270: PUSH
86271: FOR_DOWNTO
86272: IFFALSE 86302
// result := Join ( result , array [ i ] ) ;
86274: LD_ADDR_VAR 0 2
86278: PUSH
86279: LD_VAR 0 2
86283: PPUSH
86284: LD_VAR 0 1
86288: PUSH
86289: LD_VAR 0 3
86293: ARRAY
86294: PPUSH
86295: CALL 90960 0 2
86299: ST_TO_ADDR
86300: GO 86271
86302: POP
86303: POP
// end ;
86304: LD_VAR 0 2
86308: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
86309: LD_INT 0
86311: PPUSH
86312: PPUSH
86313: PPUSH
86314: PPUSH
86315: PPUSH
86316: PPUSH
// if not unit or not hexes then
86317: LD_VAR 0 1
86321: NOT
86322: PUSH
86323: LD_VAR 0 2
86327: NOT
86328: OR
86329: IFFALSE 86333
// exit ;
86331: GO 86456
// dist := 9999 ;
86333: LD_ADDR_VAR 0 5
86337: PUSH
86338: LD_INT 9999
86340: ST_TO_ADDR
// for i = 1 to hexes do
86341: LD_ADDR_VAR 0 4
86345: PUSH
86346: DOUBLE
86347: LD_INT 1
86349: DEC
86350: ST_TO_ADDR
86351: LD_VAR 0 2
86355: PUSH
86356: FOR_TO
86357: IFFALSE 86444
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
86359: LD_ADDR_VAR 0 6
86363: PUSH
86364: LD_VAR 0 1
86368: PPUSH
86369: LD_VAR 0 2
86373: PUSH
86374: LD_VAR 0 4
86378: ARRAY
86379: PUSH
86380: LD_INT 1
86382: ARRAY
86383: PPUSH
86384: LD_VAR 0 2
86388: PUSH
86389: LD_VAR 0 4
86393: ARRAY
86394: PUSH
86395: LD_INT 2
86397: ARRAY
86398: PPUSH
86399: CALL_OW 297
86403: ST_TO_ADDR
// if tdist < dist then
86404: LD_VAR 0 6
86408: PUSH
86409: LD_VAR 0 5
86413: LESS
86414: IFFALSE 86442
// begin hex := hexes [ i ] ;
86416: LD_ADDR_VAR 0 8
86420: PUSH
86421: LD_VAR 0 2
86425: PUSH
86426: LD_VAR 0 4
86430: ARRAY
86431: ST_TO_ADDR
// dist := tdist ;
86432: LD_ADDR_VAR 0 5
86436: PUSH
86437: LD_VAR 0 6
86441: ST_TO_ADDR
// end ; end ;
86442: GO 86356
86444: POP
86445: POP
// result := hex ;
86446: LD_ADDR_VAR 0 3
86450: PUSH
86451: LD_VAR 0 8
86455: ST_TO_ADDR
// end ;
86456: LD_VAR 0 3
86460: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
86461: LD_INT 0
86463: PPUSH
86464: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86465: LD_VAR 0 1
86469: NOT
86470: PUSH
86471: LD_VAR 0 1
86475: PUSH
86476: LD_INT 21
86478: PUSH
86479: LD_INT 2
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: PUSH
86486: LD_INT 23
86488: PUSH
86489: LD_INT 2
86491: PUSH
86492: EMPTY
86493: LIST
86494: LIST
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PPUSH
86500: CALL_OW 69
86504: IN
86505: NOT
86506: OR
86507: IFFALSE 86511
// exit ;
86509: GO 86558
// for i = 1 to 3 do
86511: LD_ADDR_VAR 0 3
86515: PUSH
86516: DOUBLE
86517: LD_INT 1
86519: DEC
86520: ST_TO_ADDR
86521: LD_INT 3
86523: PUSH
86524: FOR_TO
86525: IFFALSE 86556
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
86527: LD_VAR 0 1
86531: PPUSH
86532: CALL_OW 250
86536: PPUSH
86537: LD_VAR 0 1
86541: PPUSH
86542: CALL_OW 251
86546: PPUSH
86547: LD_INT 1
86549: PPUSH
86550: CALL_OW 453
86554: GO 86524
86556: POP
86557: POP
// end ;
86558: LD_VAR 0 2
86562: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
86563: LD_INT 0
86565: PPUSH
86566: PPUSH
86567: PPUSH
86568: PPUSH
86569: PPUSH
86570: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
86571: LD_VAR 0 1
86575: NOT
86576: PUSH
86577: LD_VAR 0 2
86581: NOT
86582: OR
86583: PUSH
86584: LD_VAR 0 1
86588: PPUSH
86589: CALL_OW 314
86593: OR
86594: IFFALSE 86598
// exit ;
86596: GO 87065
// if GetLives ( i ) < 250 then
86598: LD_VAR 0 4
86602: PPUSH
86603: CALL_OW 256
86607: PUSH
86608: LD_INT 250
86610: LESS
86611: IFFALSE 86624
// begin ComAutodestruct ( i ) ;
86613: LD_VAR 0 4
86617: PPUSH
86618: CALL 86461 0 1
// exit ;
86622: GO 87065
// end ; x := GetX ( enemy_unit ) ;
86624: LD_ADDR_VAR 0 7
86628: PUSH
86629: LD_VAR 0 2
86633: PPUSH
86634: CALL_OW 250
86638: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
86639: LD_ADDR_VAR 0 8
86643: PUSH
86644: LD_VAR 0 2
86648: PPUSH
86649: CALL_OW 251
86653: ST_TO_ADDR
// if not x or not y then
86654: LD_VAR 0 7
86658: NOT
86659: PUSH
86660: LD_VAR 0 8
86664: NOT
86665: OR
86666: IFFALSE 86670
// exit ;
86668: GO 87065
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
86670: LD_ADDR_VAR 0 6
86674: PUSH
86675: LD_VAR 0 7
86679: PPUSH
86680: LD_INT 0
86682: PPUSH
86683: LD_INT 4
86685: PPUSH
86686: CALL_OW 272
86690: PUSH
86691: LD_VAR 0 8
86695: PPUSH
86696: LD_INT 0
86698: PPUSH
86699: LD_INT 4
86701: PPUSH
86702: CALL_OW 273
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: PUSH
86711: LD_VAR 0 7
86715: PPUSH
86716: LD_INT 1
86718: PPUSH
86719: LD_INT 4
86721: PPUSH
86722: CALL_OW 272
86726: PUSH
86727: LD_VAR 0 8
86731: PPUSH
86732: LD_INT 1
86734: PPUSH
86735: LD_INT 4
86737: PPUSH
86738: CALL_OW 273
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PUSH
86747: LD_VAR 0 7
86751: PPUSH
86752: LD_INT 2
86754: PPUSH
86755: LD_INT 4
86757: PPUSH
86758: CALL_OW 272
86762: PUSH
86763: LD_VAR 0 8
86767: PPUSH
86768: LD_INT 2
86770: PPUSH
86771: LD_INT 4
86773: PPUSH
86774: CALL_OW 273
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: PUSH
86783: LD_VAR 0 7
86787: PPUSH
86788: LD_INT 3
86790: PPUSH
86791: LD_INT 4
86793: PPUSH
86794: CALL_OW 272
86798: PUSH
86799: LD_VAR 0 8
86803: PPUSH
86804: LD_INT 3
86806: PPUSH
86807: LD_INT 4
86809: PPUSH
86810: CALL_OW 273
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: PUSH
86819: LD_VAR 0 7
86823: PPUSH
86824: LD_INT 4
86826: PPUSH
86827: LD_INT 4
86829: PPUSH
86830: CALL_OW 272
86834: PUSH
86835: LD_VAR 0 8
86839: PPUSH
86840: LD_INT 4
86842: PPUSH
86843: LD_INT 4
86845: PPUSH
86846: CALL_OW 273
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PUSH
86855: LD_VAR 0 7
86859: PPUSH
86860: LD_INT 5
86862: PPUSH
86863: LD_INT 4
86865: PPUSH
86866: CALL_OW 272
86870: PUSH
86871: LD_VAR 0 8
86875: PPUSH
86876: LD_INT 5
86878: PPUSH
86879: LD_INT 4
86881: PPUSH
86882: CALL_OW 273
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: ST_TO_ADDR
// for i = tmp downto 1 do
86899: LD_ADDR_VAR 0 4
86903: PUSH
86904: DOUBLE
86905: LD_VAR 0 6
86909: INC
86910: ST_TO_ADDR
86911: LD_INT 1
86913: PUSH
86914: FOR_DOWNTO
86915: IFFALSE 87016
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
86917: LD_VAR 0 6
86921: PUSH
86922: LD_VAR 0 4
86926: ARRAY
86927: PUSH
86928: LD_INT 1
86930: ARRAY
86931: PPUSH
86932: LD_VAR 0 6
86936: PUSH
86937: LD_VAR 0 4
86941: ARRAY
86942: PUSH
86943: LD_INT 2
86945: ARRAY
86946: PPUSH
86947: CALL_OW 488
86951: NOT
86952: PUSH
86953: LD_VAR 0 6
86957: PUSH
86958: LD_VAR 0 4
86962: ARRAY
86963: PUSH
86964: LD_INT 1
86966: ARRAY
86967: PPUSH
86968: LD_VAR 0 6
86972: PUSH
86973: LD_VAR 0 4
86977: ARRAY
86978: PUSH
86979: LD_INT 2
86981: ARRAY
86982: PPUSH
86983: CALL_OW 428
86987: PUSH
86988: LD_INT 0
86990: NONEQUAL
86991: OR
86992: IFFALSE 87014
// tmp := Delete ( tmp , i ) ;
86994: LD_ADDR_VAR 0 6
86998: PUSH
86999: LD_VAR 0 6
87003: PPUSH
87004: LD_VAR 0 4
87008: PPUSH
87009: CALL_OW 3
87013: ST_TO_ADDR
87014: GO 86914
87016: POP
87017: POP
// j := GetClosestHex ( unit , tmp ) ;
87018: LD_ADDR_VAR 0 5
87022: PUSH
87023: LD_VAR 0 1
87027: PPUSH
87028: LD_VAR 0 6
87032: PPUSH
87033: CALL 86309 0 2
87037: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
87038: LD_VAR 0 1
87042: PPUSH
87043: LD_VAR 0 5
87047: PUSH
87048: LD_INT 1
87050: ARRAY
87051: PPUSH
87052: LD_VAR 0 5
87056: PUSH
87057: LD_INT 2
87059: ARRAY
87060: PPUSH
87061: CALL_OW 111
// end ;
87065: LD_VAR 0 3
87069: RET
// export function PrepareApemanSoldier ( ) ; begin
87070: LD_INT 0
87072: PPUSH
// uc_nation := 0 ;
87073: LD_ADDR_OWVAR 21
87077: PUSH
87078: LD_INT 0
87080: ST_TO_ADDR
// hc_sex := sex_male ;
87081: LD_ADDR_OWVAR 27
87085: PUSH
87086: LD_INT 1
87088: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
87089: LD_ADDR_OWVAR 28
87093: PUSH
87094: LD_INT 15
87096: ST_TO_ADDR
// hc_gallery :=  ;
87097: LD_ADDR_OWVAR 33
87101: PUSH
87102: LD_STRING 
87104: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87105: LD_ADDR_OWVAR 31
87109: PUSH
87110: LD_INT 0
87112: PPUSH
87113: LD_INT 3
87115: PPUSH
87116: CALL_OW 12
87120: PUSH
87121: LD_INT 0
87123: PPUSH
87124: LD_INT 3
87126: PPUSH
87127: CALL_OW 12
87131: PUSH
87132: LD_INT 0
87134: PUSH
87135: LD_INT 0
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: ST_TO_ADDR
// end ;
87144: LD_VAR 0 1
87148: RET
// export function PrepareApemanEngineer ( ) ; begin
87149: LD_INT 0
87151: PPUSH
// uc_nation := 0 ;
87152: LD_ADDR_OWVAR 21
87156: PUSH
87157: LD_INT 0
87159: ST_TO_ADDR
// hc_sex := sex_male ;
87160: LD_ADDR_OWVAR 27
87164: PUSH
87165: LD_INT 1
87167: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
87168: LD_ADDR_OWVAR 28
87172: PUSH
87173: LD_INT 16
87175: ST_TO_ADDR
// hc_gallery :=  ;
87176: LD_ADDR_OWVAR 33
87180: PUSH
87181: LD_STRING 
87183: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87184: LD_ADDR_OWVAR 31
87188: PUSH
87189: LD_INT 0
87191: PPUSH
87192: LD_INT 3
87194: PPUSH
87195: CALL_OW 12
87199: PUSH
87200: LD_INT 0
87202: PPUSH
87203: LD_INT 3
87205: PPUSH
87206: CALL_OW 12
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: LD_INT 0
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: LIST
87221: LIST
87222: ST_TO_ADDR
// end ;
87223: LD_VAR 0 1
87227: RET
// export function PrepareApeman ( agressivity ) ; begin
87228: LD_INT 0
87230: PPUSH
// uc_side := 0 ;
87231: LD_ADDR_OWVAR 20
87235: PUSH
87236: LD_INT 0
87238: ST_TO_ADDR
// uc_nation := 0 ;
87239: LD_ADDR_OWVAR 21
87243: PUSH
87244: LD_INT 0
87246: ST_TO_ADDR
// hc_sex := sex_male ;
87247: LD_ADDR_OWVAR 27
87251: PUSH
87252: LD_INT 1
87254: ST_TO_ADDR
// hc_class := class_apeman ;
87255: LD_ADDR_OWVAR 28
87259: PUSH
87260: LD_INT 12
87262: ST_TO_ADDR
// hc_gallery :=  ;
87263: LD_ADDR_OWVAR 33
87267: PUSH
87268: LD_STRING 
87270: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87271: LD_ADDR_OWVAR 35
87275: PUSH
87276: LD_VAR 0 1
87280: NEG
87281: PPUSH
87282: LD_VAR 0 1
87286: PPUSH
87287: CALL_OW 12
87291: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87292: LD_ADDR_OWVAR 31
87296: PUSH
87297: LD_INT 0
87299: PPUSH
87300: LD_INT 3
87302: PPUSH
87303: CALL_OW 12
87307: PUSH
87308: LD_INT 0
87310: PPUSH
87311: LD_INT 3
87313: PPUSH
87314: CALL_OW 12
87318: PUSH
87319: LD_INT 0
87321: PUSH
87322: LD_INT 0
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: ST_TO_ADDR
// end ;
87331: LD_VAR 0 2
87335: RET
// export function PrepareTiger ( agressivity ) ; begin
87336: LD_INT 0
87338: PPUSH
// uc_side := 0 ;
87339: LD_ADDR_OWVAR 20
87343: PUSH
87344: LD_INT 0
87346: ST_TO_ADDR
// uc_nation := 0 ;
87347: LD_ADDR_OWVAR 21
87351: PUSH
87352: LD_INT 0
87354: ST_TO_ADDR
// hc_class := class_tiger ;
87355: LD_ADDR_OWVAR 28
87359: PUSH
87360: LD_INT 14
87362: ST_TO_ADDR
// hc_gallery :=  ;
87363: LD_ADDR_OWVAR 33
87367: PUSH
87368: LD_STRING 
87370: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87371: LD_ADDR_OWVAR 35
87375: PUSH
87376: LD_VAR 0 1
87380: NEG
87381: PPUSH
87382: LD_VAR 0 1
87386: PPUSH
87387: CALL_OW 12
87391: ST_TO_ADDR
// end ;
87392: LD_VAR 0 2
87396: RET
// export function PrepareEnchidna ( ) ; begin
87397: LD_INT 0
87399: PPUSH
// uc_side := 0 ;
87400: LD_ADDR_OWVAR 20
87404: PUSH
87405: LD_INT 0
87407: ST_TO_ADDR
// uc_nation := 0 ;
87408: LD_ADDR_OWVAR 21
87412: PUSH
87413: LD_INT 0
87415: ST_TO_ADDR
// hc_class := class_baggie ;
87416: LD_ADDR_OWVAR 28
87420: PUSH
87421: LD_INT 13
87423: ST_TO_ADDR
// hc_gallery :=  ;
87424: LD_ADDR_OWVAR 33
87428: PUSH
87429: LD_STRING 
87431: ST_TO_ADDR
// end ;
87432: LD_VAR 0 1
87436: RET
// export function PrepareFrog ( ) ; begin
87437: LD_INT 0
87439: PPUSH
// uc_side := 0 ;
87440: LD_ADDR_OWVAR 20
87444: PUSH
87445: LD_INT 0
87447: ST_TO_ADDR
// uc_nation := 0 ;
87448: LD_ADDR_OWVAR 21
87452: PUSH
87453: LD_INT 0
87455: ST_TO_ADDR
// hc_class := class_frog ;
87456: LD_ADDR_OWVAR 28
87460: PUSH
87461: LD_INT 19
87463: ST_TO_ADDR
// hc_gallery :=  ;
87464: LD_ADDR_OWVAR 33
87468: PUSH
87469: LD_STRING 
87471: ST_TO_ADDR
// end ;
87472: LD_VAR 0 1
87476: RET
// export function PrepareFish ( ) ; begin
87477: LD_INT 0
87479: PPUSH
// uc_side := 0 ;
87480: LD_ADDR_OWVAR 20
87484: PUSH
87485: LD_INT 0
87487: ST_TO_ADDR
// uc_nation := 0 ;
87488: LD_ADDR_OWVAR 21
87492: PUSH
87493: LD_INT 0
87495: ST_TO_ADDR
// hc_class := class_fish ;
87496: LD_ADDR_OWVAR 28
87500: PUSH
87501: LD_INT 20
87503: ST_TO_ADDR
// hc_gallery :=  ;
87504: LD_ADDR_OWVAR 33
87508: PUSH
87509: LD_STRING 
87511: ST_TO_ADDR
// end ;
87512: LD_VAR 0 1
87516: RET
// export function PrepareBird ( ) ; begin
87517: LD_INT 0
87519: PPUSH
// uc_side := 0 ;
87520: LD_ADDR_OWVAR 20
87524: PUSH
87525: LD_INT 0
87527: ST_TO_ADDR
// uc_nation := 0 ;
87528: LD_ADDR_OWVAR 21
87532: PUSH
87533: LD_INT 0
87535: ST_TO_ADDR
// hc_class := class_phororhacos ;
87536: LD_ADDR_OWVAR 28
87540: PUSH
87541: LD_INT 18
87543: ST_TO_ADDR
// hc_gallery :=  ;
87544: LD_ADDR_OWVAR 33
87548: PUSH
87549: LD_STRING 
87551: ST_TO_ADDR
// end ;
87552: LD_VAR 0 1
87556: RET
// export function PrepareHorse ( ) ; begin
87557: LD_INT 0
87559: PPUSH
// uc_side := 0 ;
87560: LD_ADDR_OWVAR 20
87564: PUSH
87565: LD_INT 0
87567: ST_TO_ADDR
// uc_nation := 0 ;
87568: LD_ADDR_OWVAR 21
87572: PUSH
87573: LD_INT 0
87575: ST_TO_ADDR
// hc_class := class_horse ;
87576: LD_ADDR_OWVAR 28
87580: PUSH
87581: LD_INT 21
87583: ST_TO_ADDR
// hc_gallery :=  ;
87584: LD_ADDR_OWVAR 33
87588: PUSH
87589: LD_STRING 
87591: ST_TO_ADDR
// end ;
87592: LD_VAR 0 1
87596: RET
// export function PrepareMastodont ( ) ; begin
87597: LD_INT 0
87599: PPUSH
// uc_side := 0 ;
87600: LD_ADDR_OWVAR 20
87604: PUSH
87605: LD_INT 0
87607: ST_TO_ADDR
// uc_nation := 0 ;
87608: LD_ADDR_OWVAR 21
87612: PUSH
87613: LD_INT 0
87615: ST_TO_ADDR
// vc_chassis := class_mastodont ;
87616: LD_ADDR_OWVAR 37
87620: PUSH
87621: LD_INT 31
87623: ST_TO_ADDR
// vc_control := control_rider ;
87624: LD_ADDR_OWVAR 38
87628: PUSH
87629: LD_INT 4
87631: ST_TO_ADDR
// end ;
87632: LD_VAR 0 1
87636: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
87637: LD_INT 0
87639: PPUSH
87640: PPUSH
87641: PPUSH
// uc_side = 0 ;
87642: LD_ADDR_OWVAR 20
87646: PUSH
87647: LD_INT 0
87649: ST_TO_ADDR
// uc_nation = 0 ;
87650: LD_ADDR_OWVAR 21
87654: PUSH
87655: LD_INT 0
87657: ST_TO_ADDR
// InitHc_All ( ) ;
87658: CALL_OW 584
// InitVc ;
87662: CALL_OW 20
// if mastodonts then
87666: LD_VAR 0 6
87670: IFFALSE 87737
// for i = 1 to mastodonts do
87672: LD_ADDR_VAR 0 11
87676: PUSH
87677: DOUBLE
87678: LD_INT 1
87680: DEC
87681: ST_TO_ADDR
87682: LD_VAR 0 6
87686: PUSH
87687: FOR_TO
87688: IFFALSE 87735
// begin vc_chassis := 31 ;
87690: LD_ADDR_OWVAR 37
87694: PUSH
87695: LD_INT 31
87697: ST_TO_ADDR
// vc_control := control_rider ;
87698: LD_ADDR_OWVAR 38
87702: PUSH
87703: LD_INT 4
87705: ST_TO_ADDR
// animal := CreateVehicle ;
87706: LD_ADDR_VAR 0 12
87710: PUSH
87711: CALL_OW 45
87715: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87716: LD_VAR 0 12
87720: PPUSH
87721: LD_VAR 0 8
87725: PPUSH
87726: LD_INT 0
87728: PPUSH
87729: CALL 89865 0 3
// end ;
87733: GO 87687
87735: POP
87736: POP
// if horses then
87737: LD_VAR 0 5
87741: IFFALSE 87808
// for i = 1 to horses do
87743: LD_ADDR_VAR 0 11
87747: PUSH
87748: DOUBLE
87749: LD_INT 1
87751: DEC
87752: ST_TO_ADDR
87753: LD_VAR 0 5
87757: PUSH
87758: FOR_TO
87759: IFFALSE 87806
// begin hc_class := 21 ;
87761: LD_ADDR_OWVAR 28
87765: PUSH
87766: LD_INT 21
87768: ST_TO_ADDR
// hc_gallery :=  ;
87769: LD_ADDR_OWVAR 33
87773: PUSH
87774: LD_STRING 
87776: ST_TO_ADDR
// animal := CreateHuman ;
87777: LD_ADDR_VAR 0 12
87781: PUSH
87782: CALL_OW 44
87786: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87787: LD_VAR 0 12
87791: PPUSH
87792: LD_VAR 0 8
87796: PPUSH
87797: LD_INT 0
87799: PPUSH
87800: CALL 89865 0 3
// end ;
87804: GO 87758
87806: POP
87807: POP
// if birds then
87808: LD_VAR 0 1
87812: IFFALSE 87879
// for i = 1 to birds do
87814: LD_ADDR_VAR 0 11
87818: PUSH
87819: DOUBLE
87820: LD_INT 1
87822: DEC
87823: ST_TO_ADDR
87824: LD_VAR 0 1
87828: PUSH
87829: FOR_TO
87830: IFFALSE 87877
// begin hc_class := 18 ;
87832: LD_ADDR_OWVAR 28
87836: PUSH
87837: LD_INT 18
87839: ST_TO_ADDR
// hc_gallery =  ;
87840: LD_ADDR_OWVAR 33
87844: PUSH
87845: LD_STRING 
87847: ST_TO_ADDR
// animal := CreateHuman ;
87848: LD_ADDR_VAR 0 12
87852: PUSH
87853: CALL_OW 44
87857: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87858: LD_VAR 0 12
87862: PPUSH
87863: LD_VAR 0 8
87867: PPUSH
87868: LD_INT 0
87870: PPUSH
87871: CALL 89865 0 3
// end ;
87875: GO 87829
87877: POP
87878: POP
// if tigers then
87879: LD_VAR 0 2
87883: IFFALSE 87967
// for i = 1 to tigers do
87885: LD_ADDR_VAR 0 11
87889: PUSH
87890: DOUBLE
87891: LD_INT 1
87893: DEC
87894: ST_TO_ADDR
87895: LD_VAR 0 2
87899: PUSH
87900: FOR_TO
87901: IFFALSE 87965
// begin hc_class = class_tiger ;
87903: LD_ADDR_OWVAR 28
87907: PUSH
87908: LD_INT 14
87910: ST_TO_ADDR
// hc_gallery =  ;
87911: LD_ADDR_OWVAR 33
87915: PUSH
87916: LD_STRING 
87918: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
87919: LD_ADDR_OWVAR 35
87923: PUSH
87924: LD_INT 7
87926: NEG
87927: PPUSH
87928: LD_INT 7
87930: PPUSH
87931: CALL_OW 12
87935: ST_TO_ADDR
// animal := CreateHuman ;
87936: LD_ADDR_VAR 0 12
87940: PUSH
87941: CALL_OW 44
87945: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87946: LD_VAR 0 12
87950: PPUSH
87951: LD_VAR 0 8
87955: PPUSH
87956: LD_INT 0
87958: PPUSH
87959: CALL 89865 0 3
// end ;
87963: GO 87900
87965: POP
87966: POP
// if apemans then
87967: LD_VAR 0 3
87971: IFFALSE 88094
// for i = 1 to apemans do
87973: LD_ADDR_VAR 0 11
87977: PUSH
87978: DOUBLE
87979: LD_INT 1
87981: DEC
87982: ST_TO_ADDR
87983: LD_VAR 0 3
87987: PUSH
87988: FOR_TO
87989: IFFALSE 88092
// begin hc_class = class_apeman ;
87991: LD_ADDR_OWVAR 28
87995: PUSH
87996: LD_INT 12
87998: ST_TO_ADDR
// hc_gallery =  ;
87999: LD_ADDR_OWVAR 33
88003: PUSH
88004: LD_STRING 
88006: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
88007: LD_ADDR_OWVAR 35
88011: PUSH
88012: LD_INT 2
88014: NEG
88015: PPUSH
88016: LD_INT 2
88018: PPUSH
88019: CALL_OW 12
88023: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
88024: LD_ADDR_OWVAR 31
88028: PUSH
88029: LD_INT 1
88031: PPUSH
88032: LD_INT 3
88034: PPUSH
88035: CALL_OW 12
88039: PUSH
88040: LD_INT 1
88042: PPUSH
88043: LD_INT 3
88045: PPUSH
88046: CALL_OW 12
88050: PUSH
88051: LD_INT 0
88053: PUSH
88054: LD_INT 0
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: ST_TO_ADDR
// animal := CreateHuman ;
88063: LD_ADDR_VAR 0 12
88067: PUSH
88068: CALL_OW 44
88072: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88073: LD_VAR 0 12
88077: PPUSH
88078: LD_VAR 0 8
88082: PPUSH
88083: LD_INT 0
88085: PPUSH
88086: CALL 89865 0 3
// end ;
88090: GO 87988
88092: POP
88093: POP
// if enchidnas then
88094: LD_VAR 0 4
88098: IFFALSE 88165
// for i = 1 to enchidnas do
88100: LD_ADDR_VAR 0 11
88104: PUSH
88105: DOUBLE
88106: LD_INT 1
88108: DEC
88109: ST_TO_ADDR
88110: LD_VAR 0 4
88114: PUSH
88115: FOR_TO
88116: IFFALSE 88163
// begin hc_class = 13 ;
88118: LD_ADDR_OWVAR 28
88122: PUSH
88123: LD_INT 13
88125: ST_TO_ADDR
// hc_gallery =  ;
88126: LD_ADDR_OWVAR 33
88130: PUSH
88131: LD_STRING 
88133: ST_TO_ADDR
// animal := CreateHuman ;
88134: LD_ADDR_VAR 0 12
88138: PUSH
88139: CALL_OW 44
88143: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88144: LD_VAR 0 12
88148: PPUSH
88149: LD_VAR 0 8
88153: PPUSH
88154: LD_INT 0
88156: PPUSH
88157: CALL 89865 0 3
// end ;
88161: GO 88115
88163: POP
88164: POP
// if fishes then
88165: LD_VAR 0 7
88169: IFFALSE 88236
// for i = 1 to fishes do
88171: LD_ADDR_VAR 0 11
88175: PUSH
88176: DOUBLE
88177: LD_INT 1
88179: DEC
88180: ST_TO_ADDR
88181: LD_VAR 0 7
88185: PUSH
88186: FOR_TO
88187: IFFALSE 88234
// begin hc_class = 20 ;
88189: LD_ADDR_OWVAR 28
88193: PUSH
88194: LD_INT 20
88196: ST_TO_ADDR
// hc_gallery =  ;
88197: LD_ADDR_OWVAR 33
88201: PUSH
88202: LD_STRING 
88204: ST_TO_ADDR
// animal := CreateHuman ;
88205: LD_ADDR_VAR 0 12
88209: PUSH
88210: CALL_OW 44
88214: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
88215: LD_VAR 0 12
88219: PPUSH
88220: LD_VAR 0 9
88224: PPUSH
88225: LD_INT 0
88227: PPUSH
88228: CALL 89865 0 3
// end ;
88232: GO 88186
88234: POP
88235: POP
// end ;
88236: LD_VAR 0 10
88240: RET
// export function WantHeal ( sci , unit ) ; begin
88241: LD_INT 0
88243: PPUSH
// if GetTaskList ( sci ) > 0 then
88244: LD_VAR 0 1
88248: PPUSH
88249: CALL_OW 437
88253: PUSH
88254: LD_INT 0
88256: GREATER
88257: IFFALSE 88327
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
88259: LD_VAR 0 1
88263: PPUSH
88264: CALL_OW 437
88268: PUSH
88269: LD_INT 1
88271: ARRAY
88272: PUSH
88273: LD_INT 1
88275: ARRAY
88276: PUSH
88277: LD_STRING l
88279: EQUAL
88280: PUSH
88281: LD_VAR 0 1
88285: PPUSH
88286: CALL_OW 437
88290: PUSH
88291: LD_INT 1
88293: ARRAY
88294: PUSH
88295: LD_INT 4
88297: ARRAY
88298: PUSH
88299: LD_VAR 0 2
88303: EQUAL
88304: AND
88305: IFFALSE 88317
// result := true else
88307: LD_ADDR_VAR 0 3
88311: PUSH
88312: LD_INT 1
88314: ST_TO_ADDR
88315: GO 88325
// result := false ;
88317: LD_ADDR_VAR 0 3
88321: PUSH
88322: LD_INT 0
88324: ST_TO_ADDR
// end else
88325: GO 88335
// result := false ;
88327: LD_ADDR_VAR 0 3
88331: PUSH
88332: LD_INT 0
88334: ST_TO_ADDR
// end ;
88335: LD_VAR 0 3
88339: RET
// export function HealTarget ( sci ) ; begin
88340: LD_INT 0
88342: PPUSH
// if not sci then
88343: LD_VAR 0 1
88347: NOT
88348: IFFALSE 88352
// exit ;
88350: GO 88417
// result := 0 ;
88352: LD_ADDR_VAR 0 2
88356: PUSH
88357: LD_INT 0
88359: ST_TO_ADDR
// if GetTaskList ( sci ) then
88360: LD_VAR 0 1
88364: PPUSH
88365: CALL_OW 437
88369: IFFALSE 88417
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
88371: LD_VAR 0 1
88375: PPUSH
88376: CALL_OW 437
88380: PUSH
88381: LD_INT 1
88383: ARRAY
88384: PUSH
88385: LD_INT 1
88387: ARRAY
88388: PUSH
88389: LD_STRING l
88391: EQUAL
88392: IFFALSE 88417
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
88394: LD_ADDR_VAR 0 2
88398: PUSH
88399: LD_VAR 0 1
88403: PPUSH
88404: CALL_OW 437
88408: PUSH
88409: LD_INT 1
88411: ARRAY
88412: PUSH
88413: LD_INT 4
88415: ARRAY
88416: ST_TO_ADDR
// end ;
88417: LD_VAR 0 2
88421: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
88422: LD_INT 0
88424: PPUSH
88425: PPUSH
88426: PPUSH
88427: PPUSH
// if not base_units then
88428: LD_VAR 0 1
88432: NOT
88433: IFFALSE 88437
// exit ;
88435: GO 88524
// result := false ;
88437: LD_ADDR_VAR 0 2
88441: PUSH
88442: LD_INT 0
88444: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
88445: LD_ADDR_VAR 0 5
88449: PUSH
88450: LD_VAR 0 1
88454: PPUSH
88455: LD_INT 21
88457: PUSH
88458: LD_INT 3
88460: PUSH
88461: EMPTY
88462: LIST
88463: LIST
88464: PPUSH
88465: CALL_OW 72
88469: ST_TO_ADDR
// if not tmp then
88470: LD_VAR 0 5
88474: NOT
88475: IFFALSE 88479
// exit ;
88477: GO 88524
// for i in tmp do
88479: LD_ADDR_VAR 0 3
88483: PUSH
88484: LD_VAR 0 5
88488: PUSH
88489: FOR_IN
88490: IFFALSE 88522
// begin result := EnemyInRange ( i , 22 ) ;
88492: LD_ADDR_VAR 0 2
88496: PUSH
88497: LD_VAR 0 3
88501: PPUSH
88502: LD_INT 22
88504: PPUSH
88505: CALL 86111 0 2
88509: ST_TO_ADDR
// if result then
88510: LD_VAR 0 2
88514: IFFALSE 88520
// exit ;
88516: POP
88517: POP
88518: GO 88524
// end ;
88520: GO 88489
88522: POP
88523: POP
// end ;
88524: LD_VAR 0 2
88528: RET
// export function FilterByTag ( units , tag ) ; begin
88529: LD_INT 0
88531: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
88532: LD_ADDR_VAR 0 3
88536: PUSH
88537: LD_VAR 0 1
88541: PPUSH
88542: LD_INT 120
88544: PUSH
88545: LD_VAR 0 2
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PPUSH
88554: CALL_OW 72
88558: ST_TO_ADDR
// end ;
88559: LD_VAR 0 3
88563: RET
// export function IsDriver ( un ) ; begin
88564: LD_INT 0
88566: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
88567: LD_ADDR_VAR 0 2
88571: PUSH
88572: LD_VAR 0 1
88576: PUSH
88577: LD_INT 55
88579: PUSH
88580: EMPTY
88581: LIST
88582: PPUSH
88583: CALL_OW 69
88587: IN
88588: ST_TO_ADDR
// end ;
88589: LD_VAR 0 2
88593: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
88594: LD_INT 0
88596: PPUSH
88597: PPUSH
// list := [ ] ;
88598: LD_ADDR_VAR 0 5
88602: PUSH
88603: EMPTY
88604: ST_TO_ADDR
// case d of 0 :
88605: LD_VAR 0 3
88609: PUSH
88610: LD_INT 0
88612: DOUBLE
88613: EQUAL
88614: IFTRUE 88618
88616: GO 88751
88618: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
88619: LD_ADDR_VAR 0 5
88623: PUSH
88624: LD_VAR 0 1
88628: PUSH
88629: LD_INT 4
88631: MINUS
88632: PUSH
88633: LD_VAR 0 2
88637: PUSH
88638: LD_INT 4
88640: MINUS
88641: PUSH
88642: LD_INT 2
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: LIST
88649: PUSH
88650: LD_VAR 0 1
88654: PUSH
88655: LD_INT 3
88657: MINUS
88658: PUSH
88659: LD_VAR 0 2
88663: PUSH
88664: LD_INT 1
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: LIST
88671: PUSH
88672: LD_VAR 0 1
88676: PUSH
88677: LD_INT 4
88679: PLUS
88680: PUSH
88681: LD_VAR 0 2
88685: PUSH
88686: LD_INT 4
88688: PUSH
88689: EMPTY
88690: LIST
88691: LIST
88692: LIST
88693: PUSH
88694: LD_VAR 0 1
88698: PUSH
88699: LD_INT 3
88701: PLUS
88702: PUSH
88703: LD_VAR 0 2
88707: PUSH
88708: LD_INT 3
88710: PLUS
88711: PUSH
88712: LD_INT 5
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: LIST
88719: PUSH
88720: LD_VAR 0 1
88724: PUSH
88725: LD_VAR 0 2
88729: PUSH
88730: LD_INT 4
88732: PLUS
88733: PUSH
88734: LD_INT 0
88736: PUSH
88737: EMPTY
88738: LIST
88739: LIST
88740: LIST
88741: PUSH
88742: EMPTY
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: ST_TO_ADDR
// end ; 1 :
88749: GO 89449
88751: LD_INT 1
88753: DOUBLE
88754: EQUAL
88755: IFTRUE 88759
88757: GO 88892
88759: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
88760: LD_ADDR_VAR 0 5
88764: PUSH
88765: LD_VAR 0 1
88769: PUSH
88770: LD_VAR 0 2
88774: PUSH
88775: LD_INT 4
88777: MINUS
88778: PUSH
88779: LD_INT 3
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: LIST
88786: PUSH
88787: LD_VAR 0 1
88791: PUSH
88792: LD_INT 3
88794: MINUS
88795: PUSH
88796: LD_VAR 0 2
88800: PUSH
88801: LD_INT 3
88803: MINUS
88804: PUSH
88805: LD_INT 2
88807: PUSH
88808: EMPTY
88809: LIST
88810: LIST
88811: LIST
88812: PUSH
88813: LD_VAR 0 1
88817: PUSH
88818: LD_INT 4
88820: MINUS
88821: PUSH
88822: LD_VAR 0 2
88826: PUSH
88827: LD_INT 1
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: LIST
88834: PUSH
88835: LD_VAR 0 1
88839: PUSH
88840: LD_VAR 0 2
88844: PUSH
88845: LD_INT 3
88847: PLUS
88848: PUSH
88849: LD_INT 0
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: LIST
88856: PUSH
88857: LD_VAR 0 1
88861: PUSH
88862: LD_INT 4
88864: PLUS
88865: PUSH
88866: LD_VAR 0 2
88870: PUSH
88871: LD_INT 4
88873: PLUS
88874: PUSH
88875: LD_INT 5
88877: PUSH
88878: EMPTY
88879: LIST
88880: LIST
88881: LIST
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: LIST
88889: ST_TO_ADDR
// end ; 2 :
88890: GO 89449
88892: LD_INT 2
88894: DOUBLE
88895: EQUAL
88896: IFTRUE 88900
88898: GO 89029
88900: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88901: LD_ADDR_VAR 0 5
88905: PUSH
88906: LD_VAR 0 1
88910: PUSH
88911: LD_VAR 0 2
88915: PUSH
88916: LD_INT 3
88918: MINUS
88919: PUSH
88920: LD_INT 3
88922: PUSH
88923: EMPTY
88924: LIST
88925: LIST
88926: LIST
88927: PUSH
88928: LD_VAR 0 1
88932: PUSH
88933: LD_INT 4
88935: PLUS
88936: PUSH
88937: LD_VAR 0 2
88941: PUSH
88942: LD_INT 4
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: LIST
88949: PUSH
88950: LD_VAR 0 1
88954: PUSH
88955: LD_VAR 0 2
88959: PUSH
88960: LD_INT 4
88962: PLUS
88963: PUSH
88964: LD_INT 0
88966: PUSH
88967: EMPTY
88968: LIST
88969: LIST
88970: LIST
88971: PUSH
88972: LD_VAR 0 1
88976: PUSH
88977: LD_INT 3
88979: MINUS
88980: PUSH
88981: LD_VAR 0 2
88985: PUSH
88986: LD_INT 1
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: LIST
88993: PUSH
88994: LD_VAR 0 1
88998: PUSH
88999: LD_INT 4
89001: MINUS
89002: PUSH
89003: LD_VAR 0 2
89007: PUSH
89008: LD_INT 4
89010: MINUS
89011: PUSH
89012: LD_INT 2
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: LIST
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: ST_TO_ADDR
// end ; 3 :
89027: GO 89449
89029: LD_INT 3
89031: DOUBLE
89032: EQUAL
89033: IFTRUE 89037
89035: GO 89170
89037: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
89038: LD_ADDR_VAR 0 5
89042: PUSH
89043: LD_VAR 0 1
89047: PUSH
89048: LD_INT 3
89050: PLUS
89051: PUSH
89052: LD_VAR 0 2
89056: PUSH
89057: LD_INT 4
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: LIST
89064: PUSH
89065: LD_VAR 0 1
89069: PUSH
89070: LD_INT 4
89072: PLUS
89073: PUSH
89074: LD_VAR 0 2
89078: PUSH
89079: LD_INT 4
89081: PLUS
89082: PUSH
89083: LD_INT 5
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: LIST
89090: PUSH
89091: LD_VAR 0 1
89095: PUSH
89096: LD_INT 4
89098: MINUS
89099: PUSH
89100: LD_VAR 0 2
89104: PUSH
89105: LD_INT 1
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: LIST
89112: PUSH
89113: LD_VAR 0 1
89117: PUSH
89118: LD_VAR 0 2
89122: PUSH
89123: LD_INT 4
89125: MINUS
89126: PUSH
89127: LD_INT 3
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: LIST
89134: PUSH
89135: LD_VAR 0 1
89139: PUSH
89140: LD_INT 3
89142: MINUS
89143: PUSH
89144: LD_VAR 0 2
89148: PUSH
89149: LD_INT 3
89151: MINUS
89152: PUSH
89153: LD_INT 2
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: LIST
89160: PUSH
89161: EMPTY
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: ST_TO_ADDR
// end ; 4 :
89168: GO 89449
89170: LD_INT 4
89172: DOUBLE
89173: EQUAL
89174: IFTRUE 89178
89176: GO 89311
89178: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
89179: LD_ADDR_VAR 0 5
89183: PUSH
89184: LD_VAR 0 1
89188: PUSH
89189: LD_VAR 0 2
89193: PUSH
89194: LD_INT 4
89196: PLUS
89197: PUSH
89198: LD_INT 0
89200: PUSH
89201: EMPTY
89202: LIST
89203: LIST
89204: LIST
89205: PUSH
89206: LD_VAR 0 1
89210: PUSH
89211: LD_INT 3
89213: PLUS
89214: PUSH
89215: LD_VAR 0 2
89219: PUSH
89220: LD_INT 3
89222: PLUS
89223: PUSH
89224: LD_INT 5
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: LIST
89231: PUSH
89232: LD_VAR 0 1
89236: PUSH
89237: LD_INT 4
89239: PLUS
89240: PUSH
89241: LD_VAR 0 2
89245: PUSH
89246: LD_INT 4
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: LIST
89253: PUSH
89254: LD_VAR 0 1
89258: PUSH
89259: LD_VAR 0 2
89263: PUSH
89264: LD_INT 3
89266: MINUS
89267: PUSH
89268: LD_INT 3
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: LIST
89275: PUSH
89276: LD_VAR 0 1
89280: PUSH
89281: LD_INT 4
89283: MINUS
89284: PUSH
89285: LD_VAR 0 2
89289: PUSH
89290: LD_INT 4
89292: MINUS
89293: PUSH
89294: LD_INT 2
89296: PUSH
89297: EMPTY
89298: LIST
89299: LIST
89300: LIST
89301: PUSH
89302: EMPTY
89303: LIST
89304: LIST
89305: LIST
89306: LIST
89307: LIST
89308: ST_TO_ADDR
// end ; 5 :
89309: GO 89449
89311: LD_INT 5
89313: DOUBLE
89314: EQUAL
89315: IFTRUE 89319
89317: GO 89448
89319: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
89320: LD_ADDR_VAR 0 5
89324: PUSH
89325: LD_VAR 0 1
89329: PUSH
89330: LD_INT 4
89332: MINUS
89333: PUSH
89334: LD_VAR 0 2
89338: PUSH
89339: LD_INT 1
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: LIST
89346: PUSH
89347: LD_VAR 0 1
89351: PUSH
89352: LD_VAR 0 2
89356: PUSH
89357: LD_INT 4
89359: MINUS
89360: PUSH
89361: LD_INT 3
89363: PUSH
89364: EMPTY
89365: LIST
89366: LIST
89367: LIST
89368: PUSH
89369: LD_VAR 0 1
89373: PUSH
89374: LD_INT 4
89376: PLUS
89377: PUSH
89378: LD_VAR 0 2
89382: PUSH
89383: LD_INT 4
89385: PLUS
89386: PUSH
89387: LD_INT 5
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: LIST
89394: PUSH
89395: LD_VAR 0 1
89399: PUSH
89400: LD_INT 3
89402: PLUS
89403: PUSH
89404: LD_VAR 0 2
89408: PUSH
89409: LD_INT 4
89411: PUSH
89412: EMPTY
89413: LIST
89414: LIST
89415: LIST
89416: PUSH
89417: LD_VAR 0 1
89421: PUSH
89422: LD_VAR 0 2
89426: PUSH
89427: LD_INT 3
89429: PLUS
89430: PUSH
89431: LD_INT 0
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: LIST
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: LIST
89443: LIST
89444: LIST
89445: ST_TO_ADDR
// end ; end ;
89446: GO 89449
89448: POP
// result := list ;
89449: LD_ADDR_VAR 0 4
89453: PUSH
89454: LD_VAR 0 5
89458: ST_TO_ADDR
// end ;
89459: LD_VAR 0 4
89463: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
89464: LD_INT 0
89466: PPUSH
89467: PPUSH
89468: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
89469: LD_VAR 0 1
89473: NOT
89474: PUSH
89475: LD_VAR 0 2
89479: PUSH
89480: LD_INT 1
89482: PUSH
89483: LD_INT 2
89485: PUSH
89486: LD_INT 3
89488: PUSH
89489: LD_INT 4
89491: PUSH
89492: EMPTY
89493: LIST
89494: LIST
89495: LIST
89496: LIST
89497: IN
89498: NOT
89499: OR
89500: IFFALSE 89504
// exit ;
89502: GO 89587
// tmp := [ ] ;
89504: LD_ADDR_VAR 0 5
89508: PUSH
89509: EMPTY
89510: ST_TO_ADDR
// for i in units do
89511: LD_ADDR_VAR 0 4
89515: PUSH
89516: LD_VAR 0 1
89520: PUSH
89521: FOR_IN
89522: IFFALSE 89556
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
89524: LD_ADDR_VAR 0 5
89528: PUSH
89529: LD_VAR 0 5
89533: PPUSH
89534: LD_VAR 0 4
89538: PPUSH
89539: LD_VAR 0 2
89543: PPUSH
89544: CALL_OW 259
89548: PPUSH
89549: CALL 90960 0 2
89553: ST_TO_ADDR
89554: GO 89521
89556: POP
89557: POP
// if not tmp then
89558: LD_VAR 0 5
89562: NOT
89563: IFFALSE 89567
// exit ;
89565: GO 89587
// result := SortListByListDesc ( units , tmp ) ;
89567: LD_ADDR_VAR 0 3
89571: PUSH
89572: LD_VAR 0 1
89576: PPUSH
89577: LD_VAR 0 5
89581: PPUSH
89582: CALL_OW 77
89586: ST_TO_ADDR
// end ;
89587: LD_VAR 0 3
89591: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
89592: LD_INT 0
89594: PPUSH
89595: PPUSH
89596: PPUSH
// result := false ;
89597: LD_ADDR_VAR 0 3
89601: PUSH
89602: LD_INT 0
89604: ST_TO_ADDR
// if not building then
89605: LD_VAR 0 2
89609: NOT
89610: IFFALSE 89614
// exit ;
89612: GO 89752
// x := GetX ( building ) ;
89614: LD_ADDR_VAR 0 4
89618: PUSH
89619: LD_VAR 0 2
89623: PPUSH
89624: CALL_OW 250
89628: ST_TO_ADDR
// y := GetY ( building ) ;
89629: LD_ADDR_VAR 0 5
89633: PUSH
89634: LD_VAR 0 2
89638: PPUSH
89639: CALL_OW 251
89643: ST_TO_ADDR
// if not x or not y then
89644: LD_VAR 0 4
89648: NOT
89649: PUSH
89650: LD_VAR 0 5
89654: NOT
89655: OR
89656: IFFALSE 89660
// exit ;
89658: GO 89752
// if GetTaskList ( unit ) then
89660: LD_VAR 0 1
89664: PPUSH
89665: CALL_OW 437
89669: IFFALSE 89752
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89671: LD_STRING e
89673: PUSH
89674: LD_VAR 0 1
89678: PPUSH
89679: CALL_OW 437
89683: PUSH
89684: LD_INT 1
89686: ARRAY
89687: PUSH
89688: LD_INT 1
89690: ARRAY
89691: EQUAL
89692: PUSH
89693: LD_VAR 0 4
89697: PUSH
89698: LD_VAR 0 1
89702: PPUSH
89703: CALL_OW 437
89707: PUSH
89708: LD_INT 1
89710: ARRAY
89711: PUSH
89712: LD_INT 2
89714: ARRAY
89715: EQUAL
89716: AND
89717: PUSH
89718: LD_VAR 0 5
89722: PUSH
89723: LD_VAR 0 1
89727: PPUSH
89728: CALL_OW 437
89732: PUSH
89733: LD_INT 1
89735: ARRAY
89736: PUSH
89737: LD_INT 3
89739: ARRAY
89740: EQUAL
89741: AND
89742: IFFALSE 89752
// result := true end ;
89744: LD_ADDR_VAR 0 3
89748: PUSH
89749: LD_INT 1
89751: ST_TO_ADDR
// end ;
89752: LD_VAR 0 3
89756: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
89757: LD_INT 0
89759: PPUSH
// result := false ;
89760: LD_ADDR_VAR 0 4
89764: PUSH
89765: LD_INT 0
89767: ST_TO_ADDR
// if GetTaskList ( unit ) then
89768: LD_VAR 0 1
89772: PPUSH
89773: CALL_OW 437
89777: IFFALSE 89860
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89779: LD_STRING M
89781: PUSH
89782: LD_VAR 0 1
89786: PPUSH
89787: CALL_OW 437
89791: PUSH
89792: LD_INT 1
89794: ARRAY
89795: PUSH
89796: LD_INT 1
89798: ARRAY
89799: EQUAL
89800: PUSH
89801: LD_VAR 0 2
89805: PUSH
89806: LD_VAR 0 1
89810: PPUSH
89811: CALL_OW 437
89815: PUSH
89816: LD_INT 1
89818: ARRAY
89819: PUSH
89820: LD_INT 2
89822: ARRAY
89823: EQUAL
89824: AND
89825: PUSH
89826: LD_VAR 0 3
89830: PUSH
89831: LD_VAR 0 1
89835: PPUSH
89836: CALL_OW 437
89840: PUSH
89841: LD_INT 1
89843: ARRAY
89844: PUSH
89845: LD_INT 3
89847: ARRAY
89848: EQUAL
89849: AND
89850: IFFALSE 89860
// result := true ;
89852: LD_ADDR_VAR 0 4
89856: PUSH
89857: LD_INT 1
89859: ST_TO_ADDR
// end ; end ;
89860: LD_VAR 0 4
89864: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89865: LD_INT 0
89867: PPUSH
89868: PPUSH
89869: PPUSH
89870: PPUSH
// if not unit or not area then
89871: LD_VAR 0 1
89875: NOT
89876: PUSH
89877: LD_VAR 0 2
89881: NOT
89882: OR
89883: IFFALSE 89887
// exit ;
89885: GO 90063
// tmp := AreaToList ( area , i ) ;
89887: LD_ADDR_VAR 0 6
89891: PUSH
89892: LD_VAR 0 2
89896: PPUSH
89897: LD_VAR 0 5
89901: PPUSH
89902: CALL_OW 517
89906: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89907: LD_ADDR_VAR 0 5
89911: PUSH
89912: DOUBLE
89913: LD_INT 1
89915: DEC
89916: ST_TO_ADDR
89917: LD_VAR 0 6
89921: PUSH
89922: LD_INT 1
89924: ARRAY
89925: PUSH
89926: FOR_TO
89927: IFFALSE 90061
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89929: LD_ADDR_VAR 0 7
89933: PUSH
89934: LD_VAR 0 6
89938: PUSH
89939: LD_INT 1
89941: ARRAY
89942: PUSH
89943: LD_VAR 0 5
89947: ARRAY
89948: PUSH
89949: LD_VAR 0 6
89953: PUSH
89954: LD_INT 2
89956: ARRAY
89957: PUSH
89958: LD_VAR 0 5
89962: ARRAY
89963: PUSH
89964: EMPTY
89965: LIST
89966: LIST
89967: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
89968: LD_INT 92
89970: PUSH
89971: LD_VAR 0 7
89975: PUSH
89976: LD_INT 1
89978: ARRAY
89979: PUSH
89980: LD_VAR 0 7
89984: PUSH
89985: LD_INT 2
89987: ARRAY
89988: PUSH
89989: LD_INT 2
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: LIST
89996: LIST
89997: PPUSH
89998: CALL_OW 69
90002: PUSH
90003: LD_INT 0
90005: EQUAL
90006: IFFALSE 90059
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
90008: LD_VAR 0 1
90012: PPUSH
90013: LD_VAR 0 7
90017: PUSH
90018: LD_INT 1
90020: ARRAY
90021: PPUSH
90022: LD_VAR 0 7
90026: PUSH
90027: LD_INT 2
90029: ARRAY
90030: PPUSH
90031: LD_VAR 0 3
90035: PPUSH
90036: CALL_OW 48
// result := IsPlaced ( unit ) ;
90040: LD_ADDR_VAR 0 4
90044: PUSH
90045: LD_VAR 0 1
90049: PPUSH
90050: CALL_OW 305
90054: ST_TO_ADDR
// exit ;
90055: POP
90056: POP
90057: GO 90063
// end ; end ;
90059: GO 89926
90061: POP
90062: POP
// end ;
90063: LD_VAR 0 4
90067: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
90068: LD_INT 0
90070: PPUSH
90071: PPUSH
90072: PPUSH
// if not side or side > 8 then
90073: LD_VAR 0 1
90077: NOT
90078: PUSH
90079: LD_VAR 0 1
90083: PUSH
90084: LD_INT 8
90086: GREATER
90087: OR
90088: IFFALSE 90092
// exit ;
90090: GO 90279
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
90092: LD_ADDR_VAR 0 4
90096: PUSH
90097: LD_INT 22
90099: PUSH
90100: LD_VAR 0 1
90104: PUSH
90105: EMPTY
90106: LIST
90107: LIST
90108: PUSH
90109: LD_INT 21
90111: PUSH
90112: LD_INT 3
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: PPUSH
90123: CALL_OW 69
90127: ST_TO_ADDR
// if not tmp then
90128: LD_VAR 0 4
90132: NOT
90133: IFFALSE 90137
// exit ;
90135: GO 90279
// enable_addtolog := true ;
90137: LD_ADDR_OWVAR 81
90141: PUSH
90142: LD_INT 1
90144: ST_TO_ADDR
// AddToLog ( [ ) ;
90145: LD_STRING [
90147: PPUSH
90148: CALL_OW 561
// for i in tmp do
90152: LD_ADDR_VAR 0 3
90156: PUSH
90157: LD_VAR 0 4
90161: PUSH
90162: FOR_IN
90163: IFFALSE 90270
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
90165: LD_STRING [
90167: PUSH
90168: LD_VAR 0 3
90172: PPUSH
90173: CALL_OW 266
90177: STR
90178: PUSH
90179: LD_STRING , 
90181: STR
90182: PUSH
90183: LD_VAR 0 3
90187: PPUSH
90188: CALL_OW 250
90192: STR
90193: PUSH
90194: LD_STRING , 
90196: STR
90197: PUSH
90198: LD_VAR 0 3
90202: PPUSH
90203: CALL_OW 251
90207: STR
90208: PUSH
90209: LD_STRING , 
90211: STR
90212: PUSH
90213: LD_VAR 0 3
90217: PPUSH
90218: CALL_OW 254
90222: STR
90223: PUSH
90224: LD_STRING , 
90226: STR
90227: PUSH
90228: LD_VAR 0 3
90232: PPUSH
90233: LD_INT 1
90235: PPUSH
90236: CALL_OW 268
90240: STR
90241: PUSH
90242: LD_STRING , 
90244: STR
90245: PUSH
90246: LD_VAR 0 3
90250: PPUSH
90251: LD_INT 2
90253: PPUSH
90254: CALL_OW 268
90258: STR
90259: PUSH
90260: LD_STRING ],
90262: STR
90263: PPUSH
90264: CALL_OW 561
// end ;
90268: GO 90162
90270: POP
90271: POP
// AddToLog ( ]; ) ;
90272: LD_STRING ];
90274: PPUSH
90275: CALL_OW 561
// end ;
90279: LD_VAR 0 2
90283: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
90284: LD_INT 0
90286: PPUSH
90287: PPUSH
90288: PPUSH
90289: PPUSH
90290: PPUSH
// if not area or not rate or not max then
90291: LD_VAR 0 1
90295: NOT
90296: PUSH
90297: LD_VAR 0 2
90301: NOT
90302: OR
90303: PUSH
90304: LD_VAR 0 4
90308: NOT
90309: OR
90310: IFFALSE 90314
// exit ;
90312: GO 90503
// while 1 do
90314: LD_INT 1
90316: IFFALSE 90503
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
90318: LD_ADDR_VAR 0 9
90322: PUSH
90323: LD_VAR 0 1
90327: PPUSH
90328: LD_INT 1
90330: PPUSH
90331: CALL_OW 287
90335: PUSH
90336: LD_INT 10
90338: MUL
90339: ST_TO_ADDR
// r := rate / 10 ;
90340: LD_ADDR_VAR 0 7
90344: PUSH
90345: LD_VAR 0 2
90349: PUSH
90350: LD_INT 10
90352: DIVREAL
90353: ST_TO_ADDR
// time := 1 1$00 ;
90354: LD_ADDR_VAR 0 8
90358: PUSH
90359: LD_INT 2100
90361: ST_TO_ADDR
// if amount < min then
90362: LD_VAR 0 9
90366: PUSH
90367: LD_VAR 0 3
90371: LESS
90372: IFFALSE 90390
// r := r * 2 else
90374: LD_ADDR_VAR 0 7
90378: PUSH
90379: LD_VAR 0 7
90383: PUSH
90384: LD_INT 2
90386: MUL
90387: ST_TO_ADDR
90388: GO 90416
// if amount > max then
90390: LD_VAR 0 9
90394: PUSH
90395: LD_VAR 0 4
90399: GREATER
90400: IFFALSE 90416
// r := r / 2 ;
90402: LD_ADDR_VAR 0 7
90406: PUSH
90407: LD_VAR 0 7
90411: PUSH
90412: LD_INT 2
90414: DIVREAL
90415: ST_TO_ADDR
// time := time / r ;
90416: LD_ADDR_VAR 0 8
90420: PUSH
90421: LD_VAR 0 8
90425: PUSH
90426: LD_VAR 0 7
90430: DIVREAL
90431: ST_TO_ADDR
// if time < 0 then
90432: LD_VAR 0 8
90436: PUSH
90437: LD_INT 0
90439: LESS
90440: IFFALSE 90457
// time := time * - 1 ;
90442: LD_ADDR_VAR 0 8
90446: PUSH
90447: LD_VAR 0 8
90451: PUSH
90452: LD_INT 1
90454: NEG
90455: MUL
90456: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
90457: LD_VAR 0 8
90461: PUSH
90462: LD_INT 35
90464: PPUSH
90465: LD_INT 875
90467: PPUSH
90468: CALL_OW 12
90472: PLUS
90473: PPUSH
90474: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
90478: LD_INT 1
90480: PPUSH
90481: LD_INT 5
90483: PPUSH
90484: CALL_OW 12
90488: PPUSH
90489: LD_VAR 0 1
90493: PPUSH
90494: LD_INT 1
90496: PPUSH
90497: CALL_OW 55
// end ;
90501: GO 90314
// end ;
90503: LD_VAR 0 5
90507: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
90508: LD_INT 0
90510: PPUSH
90511: PPUSH
90512: PPUSH
90513: PPUSH
90514: PPUSH
90515: PPUSH
90516: PPUSH
90517: PPUSH
// if not turrets or not factories then
90518: LD_VAR 0 1
90522: NOT
90523: PUSH
90524: LD_VAR 0 2
90528: NOT
90529: OR
90530: IFFALSE 90534
// exit ;
90532: GO 90841
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
90534: LD_ADDR_VAR 0 10
90538: PUSH
90539: LD_INT 5
90541: PUSH
90542: LD_INT 6
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: LD_INT 2
90551: PUSH
90552: LD_INT 4
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: PUSH
90559: LD_INT 3
90561: PUSH
90562: LD_INT 5
90564: PUSH
90565: EMPTY
90566: LIST
90567: LIST
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: LIST
90573: PUSH
90574: LD_INT 24
90576: PUSH
90577: LD_INT 25
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 23
90586: PUSH
90587: LD_INT 27
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PUSH
90594: EMPTY
90595: LIST
90596: LIST
90597: PUSH
90598: LD_INT 42
90600: PUSH
90601: LD_INT 43
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PUSH
90608: LD_INT 44
90610: PUSH
90611: LD_INT 46
90613: PUSH
90614: EMPTY
90615: LIST
90616: LIST
90617: PUSH
90618: LD_INT 45
90620: PUSH
90621: LD_INT 47
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: LIST
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: LIST
90637: ST_TO_ADDR
// result := [ ] ;
90638: LD_ADDR_VAR 0 3
90642: PUSH
90643: EMPTY
90644: ST_TO_ADDR
// for i in turrets do
90645: LD_ADDR_VAR 0 4
90649: PUSH
90650: LD_VAR 0 1
90654: PUSH
90655: FOR_IN
90656: IFFALSE 90839
// begin nat := GetNation ( i ) ;
90658: LD_ADDR_VAR 0 7
90662: PUSH
90663: LD_VAR 0 4
90667: PPUSH
90668: CALL_OW 248
90672: ST_TO_ADDR
// weapon := 0 ;
90673: LD_ADDR_VAR 0 8
90677: PUSH
90678: LD_INT 0
90680: ST_TO_ADDR
// if not nat then
90681: LD_VAR 0 7
90685: NOT
90686: IFFALSE 90690
// continue ;
90688: GO 90655
// for j in list [ nat ] do
90690: LD_ADDR_VAR 0 5
90694: PUSH
90695: LD_VAR 0 10
90699: PUSH
90700: LD_VAR 0 7
90704: ARRAY
90705: PUSH
90706: FOR_IN
90707: IFFALSE 90748
// if GetBWeapon ( i ) = j [ 1 ] then
90709: LD_VAR 0 4
90713: PPUSH
90714: CALL_OW 269
90718: PUSH
90719: LD_VAR 0 5
90723: PUSH
90724: LD_INT 1
90726: ARRAY
90727: EQUAL
90728: IFFALSE 90746
// begin weapon := j [ 2 ] ;
90730: LD_ADDR_VAR 0 8
90734: PUSH
90735: LD_VAR 0 5
90739: PUSH
90740: LD_INT 2
90742: ARRAY
90743: ST_TO_ADDR
// break ;
90744: GO 90748
// end ;
90746: GO 90706
90748: POP
90749: POP
// if not weapon then
90750: LD_VAR 0 8
90754: NOT
90755: IFFALSE 90759
// continue ;
90757: GO 90655
// for k in factories do
90759: LD_ADDR_VAR 0 6
90763: PUSH
90764: LD_VAR 0 2
90768: PUSH
90769: FOR_IN
90770: IFFALSE 90835
// begin weapons := AvailableWeaponList ( k ) ;
90772: LD_ADDR_VAR 0 9
90776: PUSH
90777: LD_VAR 0 6
90781: PPUSH
90782: CALL_OW 478
90786: ST_TO_ADDR
// if not weapons then
90787: LD_VAR 0 9
90791: NOT
90792: IFFALSE 90796
// continue ;
90794: GO 90769
// if weapon in weapons then
90796: LD_VAR 0 8
90800: PUSH
90801: LD_VAR 0 9
90805: IN
90806: IFFALSE 90833
// begin result := [ i , weapon ] ;
90808: LD_ADDR_VAR 0 3
90812: PUSH
90813: LD_VAR 0 4
90817: PUSH
90818: LD_VAR 0 8
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: ST_TO_ADDR
// exit ;
90827: POP
90828: POP
90829: POP
90830: POP
90831: GO 90841
// end ; end ;
90833: GO 90769
90835: POP
90836: POP
// end ;
90837: GO 90655
90839: POP
90840: POP
// end ;
90841: LD_VAR 0 3
90845: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
90846: LD_INT 0
90848: PPUSH
// if not side or side > 8 then
90849: LD_VAR 0 3
90853: NOT
90854: PUSH
90855: LD_VAR 0 3
90859: PUSH
90860: LD_INT 8
90862: GREATER
90863: OR
90864: IFFALSE 90868
// exit ;
90866: GO 90927
// if not range then
90868: LD_VAR 0 4
90872: NOT
90873: IFFALSE 90884
// range := - 12 ;
90875: LD_ADDR_VAR 0 4
90879: PUSH
90880: LD_INT 12
90882: NEG
90883: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90884: LD_VAR 0 1
90888: PPUSH
90889: LD_VAR 0 2
90893: PPUSH
90894: LD_VAR 0 3
90898: PPUSH
90899: LD_VAR 0 4
90903: PPUSH
90904: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90908: LD_VAR 0 1
90912: PPUSH
90913: LD_VAR 0 2
90917: PPUSH
90918: LD_VAR 0 3
90922: PPUSH
90923: CALL_OW 331
// end ;
90927: LD_VAR 0 5
90931: RET
// export function Video ( mode ) ; begin
90932: LD_INT 0
90934: PPUSH
// ingame_video = mode ;
90935: LD_ADDR_OWVAR 52
90939: PUSH
90940: LD_VAR 0 1
90944: ST_TO_ADDR
// interface_hidden = mode ;
90945: LD_ADDR_OWVAR 54
90949: PUSH
90950: LD_VAR 0 1
90954: ST_TO_ADDR
// end ;
90955: LD_VAR 0 2
90959: RET
// export function Join ( array , element ) ; begin
90960: LD_INT 0
90962: PPUSH
// result := Replace ( array , array + 1 , element ) ;
90963: LD_ADDR_VAR 0 3
90967: PUSH
90968: LD_VAR 0 1
90972: PPUSH
90973: LD_VAR 0 1
90977: PUSH
90978: LD_INT 1
90980: PLUS
90981: PPUSH
90982: LD_VAR 0 2
90986: PPUSH
90987: CALL_OW 1
90991: ST_TO_ADDR
// end ;
90992: LD_VAR 0 3
90996: RET
// export function JoinUnion ( array , element ) ; begin
90997: LD_INT 0
90999: PPUSH
// result := array union element ;
91000: LD_ADDR_VAR 0 3
91004: PUSH
91005: LD_VAR 0 1
91009: PUSH
91010: LD_VAR 0 2
91014: UNION
91015: ST_TO_ADDR
// end ;
91016: LD_VAR 0 3
91020: RET
// export function GetBehemoths ( side ) ; begin
91021: LD_INT 0
91023: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
91024: LD_ADDR_VAR 0 2
91028: PUSH
91029: LD_INT 22
91031: PUSH
91032: LD_VAR 0 1
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PUSH
91041: LD_INT 31
91043: PUSH
91044: LD_INT 25
91046: PUSH
91047: EMPTY
91048: LIST
91049: LIST
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PPUSH
91055: CALL_OW 69
91059: ST_TO_ADDR
// end ;
91060: LD_VAR 0 2
91064: RET
// export function Shuffle ( array ) ; var i , index ; begin
91065: LD_INT 0
91067: PPUSH
91068: PPUSH
91069: PPUSH
// result := [ ] ;
91070: LD_ADDR_VAR 0 2
91074: PUSH
91075: EMPTY
91076: ST_TO_ADDR
// if not array then
91077: LD_VAR 0 1
91081: NOT
91082: IFFALSE 91086
// exit ;
91084: GO 91185
// Randomize ;
91086: CALL_OW 10
// for i = array downto 1 do
91090: LD_ADDR_VAR 0 3
91094: PUSH
91095: DOUBLE
91096: LD_VAR 0 1
91100: INC
91101: ST_TO_ADDR
91102: LD_INT 1
91104: PUSH
91105: FOR_DOWNTO
91106: IFFALSE 91183
// begin index := rand ( 1 , array ) ;
91108: LD_ADDR_VAR 0 4
91112: PUSH
91113: LD_INT 1
91115: PPUSH
91116: LD_VAR 0 1
91120: PPUSH
91121: CALL_OW 12
91125: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
91126: LD_ADDR_VAR 0 2
91130: PUSH
91131: LD_VAR 0 2
91135: PPUSH
91136: LD_VAR 0 2
91140: PUSH
91141: LD_INT 1
91143: PLUS
91144: PPUSH
91145: LD_VAR 0 1
91149: PUSH
91150: LD_VAR 0 4
91154: ARRAY
91155: PPUSH
91156: CALL_OW 2
91160: ST_TO_ADDR
// array := Delete ( array , index ) ;
91161: LD_ADDR_VAR 0 1
91165: PUSH
91166: LD_VAR 0 1
91170: PPUSH
91171: LD_VAR 0 4
91175: PPUSH
91176: CALL_OW 3
91180: ST_TO_ADDR
// end ;
91181: GO 91105
91183: POP
91184: POP
// end ;
91185: LD_VAR 0 2
91189: RET
// export function GetBaseMaterials ( base ) ; begin
91190: LD_INT 0
91192: PPUSH
// result := [ 0 , 0 , 0 ] ;
91193: LD_ADDR_VAR 0 2
91197: PUSH
91198: LD_INT 0
91200: PUSH
91201: LD_INT 0
91203: PUSH
91204: LD_INT 0
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: LIST
91211: ST_TO_ADDR
// if not base then
91212: LD_VAR 0 1
91216: NOT
91217: IFFALSE 91221
// exit ;
91219: GO 91270
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
91221: LD_ADDR_VAR 0 2
91225: PUSH
91226: LD_VAR 0 1
91230: PPUSH
91231: LD_INT 1
91233: PPUSH
91234: CALL_OW 275
91238: PUSH
91239: LD_VAR 0 1
91243: PPUSH
91244: LD_INT 2
91246: PPUSH
91247: CALL_OW 275
91251: PUSH
91252: LD_VAR 0 1
91256: PPUSH
91257: LD_INT 3
91259: PPUSH
91260: CALL_OW 275
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: LIST
91269: ST_TO_ADDR
// end ;
91270: LD_VAR 0 2
91274: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
91275: LD_INT 0
91277: PPUSH
91278: PPUSH
// result := array ;
91279: LD_ADDR_VAR 0 3
91283: PUSH
91284: LD_VAR 0 1
91288: ST_TO_ADDR
// if size >= result then
91289: LD_VAR 0 2
91293: PUSH
91294: LD_VAR 0 3
91298: GREATEREQUAL
91299: IFFALSE 91303
// exit ;
91301: GO 91353
// if size then
91303: LD_VAR 0 2
91307: IFFALSE 91353
// for i := array downto size do
91309: LD_ADDR_VAR 0 4
91313: PUSH
91314: DOUBLE
91315: LD_VAR 0 1
91319: INC
91320: ST_TO_ADDR
91321: LD_VAR 0 2
91325: PUSH
91326: FOR_DOWNTO
91327: IFFALSE 91351
// result := Delete ( result , result ) ;
91329: LD_ADDR_VAR 0 3
91333: PUSH
91334: LD_VAR 0 3
91338: PPUSH
91339: LD_VAR 0 3
91343: PPUSH
91344: CALL_OW 3
91348: ST_TO_ADDR
91349: GO 91326
91351: POP
91352: POP
// end ;
91353: LD_VAR 0 3
91357: RET
// export function ComExit ( unit ) ; var tmp ; begin
91358: LD_INT 0
91360: PPUSH
91361: PPUSH
// if not IsInUnit ( unit ) then
91362: LD_VAR 0 1
91366: PPUSH
91367: CALL_OW 310
91371: NOT
91372: IFFALSE 91376
// exit ;
91374: GO 91436
// tmp := IsInUnit ( unit ) ;
91376: LD_ADDR_VAR 0 3
91380: PUSH
91381: LD_VAR 0 1
91385: PPUSH
91386: CALL_OW 310
91390: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
91391: LD_VAR 0 3
91395: PPUSH
91396: CALL_OW 247
91400: PUSH
91401: LD_INT 2
91403: EQUAL
91404: IFFALSE 91417
// ComExitVehicle ( unit ) else
91406: LD_VAR 0 1
91410: PPUSH
91411: CALL_OW 121
91415: GO 91426
// ComExitBuilding ( unit ) ;
91417: LD_VAR 0 1
91421: PPUSH
91422: CALL_OW 122
// result := tmp ;
91426: LD_ADDR_VAR 0 2
91430: PUSH
91431: LD_VAR 0 3
91435: ST_TO_ADDR
// end ;
91436: LD_VAR 0 2
91440: RET
// export function ComExitAll ( units ) ; var i ; begin
91441: LD_INT 0
91443: PPUSH
91444: PPUSH
// if not units then
91445: LD_VAR 0 1
91449: NOT
91450: IFFALSE 91454
// exit ;
91452: GO 91480
// for i in units do
91454: LD_ADDR_VAR 0 3
91458: PUSH
91459: LD_VAR 0 1
91463: PUSH
91464: FOR_IN
91465: IFFALSE 91478
// ComExit ( i ) ;
91467: LD_VAR 0 3
91471: PPUSH
91472: CALL 91358 0 1
91476: GO 91464
91478: POP
91479: POP
// end ;
91480: LD_VAR 0 2
91484: RET
// export function ResetHc ; begin
91485: LD_INT 0
91487: PPUSH
// InitHc ;
91488: CALL_OW 19
// hc_importance := 0 ;
91492: LD_ADDR_OWVAR 32
91496: PUSH
91497: LD_INT 0
91499: ST_TO_ADDR
// end ;
91500: LD_VAR 0 1
91504: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
91505: LD_INT 0
91507: PPUSH
91508: PPUSH
91509: PPUSH
// _x := ( x1 + x2 ) div 2 ;
91510: LD_ADDR_VAR 0 6
91514: PUSH
91515: LD_VAR 0 1
91519: PUSH
91520: LD_VAR 0 3
91524: PLUS
91525: PUSH
91526: LD_INT 2
91528: DIV
91529: ST_TO_ADDR
// if _x < 0 then
91530: LD_VAR 0 6
91534: PUSH
91535: LD_INT 0
91537: LESS
91538: IFFALSE 91555
// _x := _x * - 1 ;
91540: LD_ADDR_VAR 0 6
91544: PUSH
91545: LD_VAR 0 6
91549: PUSH
91550: LD_INT 1
91552: NEG
91553: MUL
91554: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
91555: LD_ADDR_VAR 0 7
91559: PUSH
91560: LD_VAR 0 2
91564: PUSH
91565: LD_VAR 0 4
91569: PLUS
91570: PUSH
91571: LD_INT 2
91573: DIV
91574: ST_TO_ADDR
// if _y < 0 then
91575: LD_VAR 0 7
91579: PUSH
91580: LD_INT 0
91582: LESS
91583: IFFALSE 91600
// _y := _y * - 1 ;
91585: LD_ADDR_VAR 0 7
91589: PUSH
91590: LD_VAR 0 7
91594: PUSH
91595: LD_INT 1
91597: NEG
91598: MUL
91599: ST_TO_ADDR
// result := [ _x , _y ] ;
91600: LD_ADDR_VAR 0 5
91604: PUSH
91605: LD_VAR 0 6
91609: PUSH
91610: LD_VAR 0 7
91614: PUSH
91615: EMPTY
91616: LIST
91617: LIST
91618: ST_TO_ADDR
// end ;
91619: LD_VAR 0 5
91623: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
91624: LD_INT 0
91626: PPUSH
91627: PPUSH
91628: PPUSH
91629: PPUSH
// task := GetTaskList ( unit ) ;
91630: LD_ADDR_VAR 0 7
91634: PUSH
91635: LD_VAR 0 1
91639: PPUSH
91640: CALL_OW 437
91644: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
91645: LD_VAR 0 7
91649: NOT
91650: PUSH
91651: LD_VAR 0 1
91655: PPUSH
91656: LD_VAR 0 2
91660: PPUSH
91661: CALL_OW 308
91665: NOT
91666: AND
91667: IFFALSE 91671
// exit ;
91669: GO 91789
// if IsInArea ( unit , area ) then
91671: LD_VAR 0 1
91675: PPUSH
91676: LD_VAR 0 2
91680: PPUSH
91681: CALL_OW 308
91685: IFFALSE 91703
// begin ComMoveToArea ( unit , goAway ) ;
91687: LD_VAR 0 1
91691: PPUSH
91692: LD_VAR 0 3
91696: PPUSH
91697: CALL_OW 113
// exit ;
91701: GO 91789
// end ; if task [ 1 ] [ 1 ] <> M then
91703: LD_VAR 0 7
91707: PUSH
91708: LD_INT 1
91710: ARRAY
91711: PUSH
91712: LD_INT 1
91714: ARRAY
91715: PUSH
91716: LD_STRING M
91718: NONEQUAL
91719: IFFALSE 91723
// exit ;
91721: GO 91789
// x := task [ 1 ] [ 2 ] ;
91723: LD_ADDR_VAR 0 5
91727: PUSH
91728: LD_VAR 0 7
91732: PUSH
91733: LD_INT 1
91735: ARRAY
91736: PUSH
91737: LD_INT 2
91739: ARRAY
91740: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
91741: LD_ADDR_VAR 0 6
91745: PUSH
91746: LD_VAR 0 7
91750: PUSH
91751: LD_INT 1
91753: ARRAY
91754: PUSH
91755: LD_INT 3
91757: ARRAY
91758: ST_TO_ADDR
// if InArea ( x , y , area ) then
91759: LD_VAR 0 5
91763: PPUSH
91764: LD_VAR 0 6
91768: PPUSH
91769: LD_VAR 0 2
91773: PPUSH
91774: CALL_OW 309
91778: IFFALSE 91789
// ComStop ( unit ) ;
91780: LD_VAR 0 1
91784: PPUSH
91785: CALL_OW 141
// end ;
91789: LD_VAR 0 4
91793: RET
// export function Abs ( value ) ; begin
91794: LD_INT 0
91796: PPUSH
// result := value ;
91797: LD_ADDR_VAR 0 2
91801: PUSH
91802: LD_VAR 0 1
91806: ST_TO_ADDR
// if value < 0 then
91807: LD_VAR 0 1
91811: PUSH
91812: LD_INT 0
91814: LESS
91815: IFFALSE 91832
// result := value * - 1 ;
91817: LD_ADDR_VAR 0 2
91821: PUSH
91822: LD_VAR 0 1
91826: PUSH
91827: LD_INT 1
91829: NEG
91830: MUL
91831: ST_TO_ADDR
// end ;
91832: LD_VAR 0 2
91836: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
91837: LD_INT 0
91839: PPUSH
91840: PPUSH
91841: PPUSH
91842: PPUSH
91843: PPUSH
91844: PPUSH
91845: PPUSH
91846: PPUSH
// if not unit or not building then
91847: LD_VAR 0 1
91851: NOT
91852: PUSH
91853: LD_VAR 0 2
91857: NOT
91858: OR
91859: IFFALSE 91863
// exit ;
91861: GO 92089
// x := GetX ( building ) ;
91863: LD_ADDR_VAR 0 4
91867: PUSH
91868: LD_VAR 0 2
91872: PPUSH
91873: CALL_OW 250
91877: ST_TO_ADDR
// y := GetY ( building ) ;
91878: LD_ADDR_VAR 0 6
91882: PUSH
91883: LD_VAR 0 2
91887: PPUSH
91888: CALL_OW 251
91892: ST_TO_ADDR
// d := GetDir ( building ) ;
91893: LD_ADDR_VAR 0 8
91897: PUSH
91898: LD_VAR 0 2
91902: PPUSH
91903: CALL_OW 254
91907: ST_TO_ADDR
// r := 4 ;
91908: LD_ADDR_VAR 0 9
91912: PUSH
91913: LD_INT 4
91915: ST_TO_ADDR
// for i := 1 to 5 do
91916: LD_ADDR_VAR 0 10
91920: PUSH
91921: DOUBLE
91922: LD_INT 1
91924: DEC
91925: ST_TO_ADDR
91926: LD_INT 5
91928: PUSH
91929: FOR_TO
91930: IFFALSE 92087
// begin _x := ShiftX ( x , d , r + i ) ;
91932: LD_ADDR_VAR 0 5
91936: PUSH
91937: LD_VAR 0 4
91941: PPUSH
91942: LD_VAR 0 8
91946: PPUSH
91947: LD_VAR 0 9
91951: PUSH
91952: LD_VAR 0 10
91956: PLUS
91957: PPUSH
91958: CALL_OW 272
91962: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
91963: LD_ADDR_VAR 0 7
91967: PUSH
91968: LD_VAR 0 6
91972: PPUSH
91973: LD_VAR 0 8
91977: PPUSH
91978: LD_VAR 0 9
91982: PUSH
91983: LD_VAR 0 10
91987: PLUS
91988: PPUSH
91989: CALL_OW 273
91993: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
91994: LD_VAR 0 5
91998: PPUSH
91999: LD_VAR 0 7
92003: PPUSH
92004: CALL_OW 488
92008: PUSH
92009: LD_VAR 0 5
92013: PPUSH
92014: LD_VAR 0 7
92018: PPUSH
92019: CALL_OW 428
92023: PPUSH
92024: CALL_OW 247
92028: PUSH
92029: LD_INT 3
92031: PUSH
92032: LD_INT 2
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: IN
92039: NOT
92040: AND
92041: IFFALSE 92085
// begin ComMoveXY ( unit , _x , _y ) ;
92043: LD_VAR 0 1
92047: PPUSH
92048: LD_VAR 0 5
92052: PPUSH
92053: LD_VAR 0 7
92057: PPUSH
92058: CALL_OW 111
// result := [ _x , _y ] ;
92062: LD_ADDR_VAR 0 3
92066: PUSH
92067: LD_VAR 0 5
92071: PUSH
92072: LD_VAR 0 7
92076: PUSH
92077: EMPTY
92078: LIST
92079: LIST
92080: ST_TO_ADDR
// exit ;
92081: POP
92082: POP
92083: GO 92089
// end ; end ;
92085: GO 91929
92087: POP
92088: POP
// end ;
92089: LD_VAR 0 3
92093: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
92094: LD_INT 0
92096: PPUSH
92097: PPUSH
92098: PPUSH
// result := 0 ;
92099: LD_ADDR_VAR 0 3
92103: PUSH
92104: LD_INT 0
92106: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
92107: LD_VAR 0 1
92111: PUSH
92112: LD_INT 0
92114: LESS
92115: PUSH
92116: LD_VAR 0 1
92120: PUSH
92121: LD_INT 8
92123: GREATER
92124: OR
92125: PUSH
92126: LD_VAR 0 2
92130: PUSH
92131: LD_INT 0
92133: LESS
92134: OR
92135: PUSH
92136: LD_VAR 0 2
92140: PUSH
92141: LD_INT 8
92143: GREATER
92144: OR
92145: IFFALSE 92149
// exit ;
92147: GO 92224
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
92149: LD_ADDR_VAR 0 4
92153: PUSH
92154: LD_INT 22
92156: PUSH
92157: LD_VAR 0 2
92161: PUSH
92162: EMPTY
92163: LIST
92164: LIST
92165: PPUSH
92166: CALL_OW 69
92170: PUSH
92171: FOR_IN
92172: IFFALSE 92222
// begin un := UnitShoot ( i ) ;
92174: LD_ADDR_VAR 0 5
92178: PUSH
92179: LD_VAR 0 4
92183: PPUSH
92184: CALL_OW 504
92188: ST_TO_ADDR
// if GetSide ( un ) = side1 then
92189: LD_VAR 0 5
92193: PPUSH
92194: CALL_OW 255
92198: PUSH
92199: LD_VAR 0 1
92203: EQUAL
92204: IFFALSE 92220
// begin result := un ;
92206: LD_ADDR_VAR 0 3
92210: PUSH
92211: LD_VAR 0 5
92215: ST_TO_ADDR
// exit ;
92216: POP
92217: POP
92218: GO 92224
// end ; end ;
92220: GO 92171
92222: POP
92223: POP
// end ;
92224: LD_VAR 0 3
92228: RET
// export function GetCargoBay ( units ) ; begin
92229: LD_INT 0
92231: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
92232: LD_ADDR_VAR 0 2
92236: PUSH
92237: LD_VAR 0 1
92241: PPUSH
92242: LD_INT 2
92244: PUSH
92245: LD_INT 34
92247: PUSH
92248: LD_INT 12
92250: PUSH
92251: EMPTY
92252: LIST
92253: LIST
92254: PUSH
92255: LD_INT 34
92257: PUSH
92258: LD_INT 51
92260: PUSH
92261: EMPTY
92262: LIST
92263: LIST
92264: PUSH
92265: LD_INT 34
92267: PUSH
92268: LD_INT 32
92270: PUSH
92271: EMPTY
92272: LIST
92273: LIST
92274: PUSH
92275: LD_INT 34
92277: PUSH
92278: LD_INT 89
92280: PUSH
92281: EMPTY
92282: LIST
92283: LIST
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: PPUSH
92292: CALL_OW 72
92296: ST_TO_ADDR
// end ;
92297: LD_VAR 0 2
92301: RET
// export function Negate ( value ) ; begin
92302: LD_INT 0
92304: PPUSH
// result := not value ;
92305: LD_ADDR_VAR 0 2
92309: PUSH
92310: LD_VAR 0 1
92314: NOT
92315: ST_TO_ADDR
// end ;
92316: LD_VAR 0 2
92320: RET
// export function Inc ( value ) ; begin
92321: LD_INT 0
92323: PPUSH
// result := value + 1 ;
92324: LD_ADDR_VAR 0 2
92328: PUSH
92329: LD_VAR 0 1
92333: PUSH
92334: LD_INT 1
92336: PLUS
92337: ST_TO_ADDR
// end ;
92338: LD_VAR 0 2
92342: RET
// export function Dec ( value ) ; begin
92343: LD_INT 0
92345: PPUSH
// result := value - 1 ;
92346: LD_ADDR_VAR 0 2
92350: PUSH
92351: LD_VAR 0 1
92355: PUSH
92356: LD_INT 1
92358: MINUS
92359: ST_TO_ADDR
// end ;
92360: LD_VAR 0 2
92364: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
92365: LD_INT 0
92367: PPUSH
92368: PPUSH
92369: PPUSH
92370: PPUSH
92371: PPUSH
92372: PPUSH
92373: PPUSH
92374: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
92375: LD_VAR 0 1
92379: PPUSH
92380: LD_VAR 0 2
92384: PPUSH
92385: CALL_OW 488
92389: NOT
92390: PUSH
92391: LD_VAR 0 3
92395: PPUSH
92396: LD_VAR 0 4
92400: PPUSH
92401: CALL_OW 488
92405: NOT
92406: OR
92407: IFFALSE 92420
// begin result := - 1 ;
92409: LD_ADDR_VAR 0 5
92413: PUSH
92414: LD_INT 1
92416: NEG
92417: ST_TO_ADDR
// exit ;
92418: GO 92655
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
92420: LD_ADDR_VAR 0 12
92424: PUSH
92425: LD_VAR 0 1
92429: PPUSH
92430: LD_VAR 0 2
92434: PPUSH
92435: LD_VAR 0 3
92439: PPUSH
92440: LD_VAR 0 4
92444: PPUSH
92445: CALL 91505 0 4
92449: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
92450: LD_ADDR_VAR 0 11
92454: PUSH
92455: LD_VAR 0 1
92459: PPUSH
92460: LD_VAR 0 2
92464: PPUSH
92465: LD_VAR 0 12
92469: PUSH
92470: LD_INT 1
92472: ARRAY
92473: PPUSH
92474: LD_VAR 0 12
92478: PUSH
92479: LD_INT 2
92481: ARRAY
92482: PPUSH
92483: CALL_OW 298
92487: ST_TO_ADDR
// distance := 9999 ;
92488: LD_ADDR_VAR 0 10
92492: PUSH
92493: LD_INT 9999
92495: ST_TO_ADDR
// for i := 0 to 5 do
92496: LD_ADDR_VAR 0 6
92500: PUSH
92501: DOUBLE
92502: LD_INT 0
92504: DEC
92505: ST_TO_ADDR
92506: LD_INT 5
92508: PUSH
92509: FOR_TO
92510: IFFALSE 92653
// begin _x := ShiftX ( x1 , i , centerDist ) ;
92512: LD_ADDR_VAR 0 7
92516: PUSH
92517: LD_VAR 0 1
92521: PPUSH
92522: LD_VAR 0 6
92526: PPUSH
92527: LD_VAR 0 11
92531: PPUSH
92532: CALL_OW 272
92536: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
92537: LD_ADDR_VAR 0 8
92541: PUSH
92542: LD_VAR 0 2
92546: PPUSH
92547: LD_VAR 0 6
92551: PPUSH
92552: LD_VAR 0 11
92556: PPUSH
92557: CALL_OW 273
92561: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
92562: LD_VAR 0 7
92566: PPUSH
92567: LD_VAR 0 8
92571: PPUSH
92572: CALL_OW 488
92576: NOT
92577: IFFALSE 92581
// continue ;
92579: GO 92509
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
92581: LD_ADDR_VAR 0 9
92585: PUSH
92586: LD_VAR 0 12
92590: PUSH
92591: LD_INT 1
92593: ARRAY
92594: PPUSH
92595: LD_VAR 0 12
92599: PUSH
92600: LD_INT 2
92602: ARRAY
92603: PPUSH
92604: LD_VAR 0 7
92608: PPUSH
92609: LD_VAR 0 8
92613: PPUSH
92614: CALL_OW 298
92618: ST_TO_ADDR
// if tmp < distance then
92619: LD_VAR 0 9
92623: PUSH
92624: LD_VAR 0 10
92628: LESS
92629: IFFALSE 92651
// begin result := i ;
92631: LD_ADDR_VAR 0 5
92635: PUSH
92636: LD_VAR 0 6
92640: ST_TO_ADDR
// distance := tmp ;
92641: LD_ADDR_VAR 0 10
92645: PUSH
92646: LD_VAR 0 9
92650: ST_TO_ADDR
// end ; end ;
92651: GO 92509
92653: POP
92654: POP
// end ;
92655: LD_VAR 0 5
92659: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92660: LD_INT 0
92662: PPUSH
92663: PPUSH
// if not driver or not IsInUnit ( driver ) then
92664: LD_VAR 0 1
92668: NOT
92669: PUSH
92670: LD_VAR 0 1
92674: PPUSH
92675: CALL_OW 310
92679: NOT
92680: OR
92681: IFFALSE 92685
// exit ;
92683: GO 92775
// vehicle := IsInUnit ( driver ) ;
92685: LD_ADDR_VAR 0 3
92689: PUSH
92690: LD_VAR 0 1
92694: PPUSH
92695: CALL_OW 310
92699: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92700: LD_VAR 0 1
92704: PPUSH
92705: LD_STRING \
92707: PUSH
92708: LD_INT 0
92710: PUSH
92711: LD_INT 0
92713: PUSH
92714: LD_INT 0
92716: PUSH
92717: LD_INT 0
92719: PUSH
92720: LD_INT 0
92722: PUSH
92723: LD_INT 0
92725: PUSH
92726: EMPTY
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: PUSH
92735: LD_STRING E
92737: PUSH
92738: LD_INT 0
92740: PUSH
92741: LD_INT 0
92743: PUSH
92744: LD_VAR 0 3
92748: PUSH
92749: LD_INT 0
92751: PUSH
92752: LD_INT 0
92754: PUSH
92755: LD_INT 0
92757: PUSH
92758: EMPTY
92759: LIST
92760: LIST
92761: LIST
92762: LIST
92763: LIST
92764: LIST
92765: LIST
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PPUSH
92771: CALL_OW 446
// end ;
92775: LD_VAR 0 2
92779: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92780: LD_INT 0
92782: PPUSH
92783: PPUSH
// if not driver or not IsInUnit ( driver ) then
92784: LD_VAR 0 1
92788: NOT
92789: PUSH
92790: LD_VAR 0 1
92794: PPUSH
92795: CALL_OW 310
92799: NOT
92800: OR
92801: IFFALSE 92805
// exit ;
92803: GO 92895
// vehicle := IsInUnit ( driver ) ;
92805: LD_ADDR_VAR 0 3
92809: PUSH
92810: LD_VAR 0 1
92814: PPUSH
92815: CALL_OW 310
92819: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92820: LD_VAR 0 1
92824: PPUSH
92825: LD_STRING \
92827: PUSH
92828: LD_INT 0
92830: PUSH
92831: LD_INT 0
92833: PUSH
92834: LD_INT 0
92836: PUSH
92837: LD_INT 0
92839: PUSH
92840: LD_INT 0
92842: PUSH
92843: LD_INT 0
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: PUSH
92855: LD_STRING E
92857: PUSH
92858: LD_INT 0
92860: PUSH
92861: LD_INT 0
92863: PUSH
92864: LD_VAR 0 3
92868: PUSH
92869: LD_INT 0
92871: PUSH
92872: LD_INT 0
92874: PUSH
92875: LD_INT 0
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: PUSH
92887: EMPTY
92888: LIST
92889: LIST
92890: PPUSH
92891: CALL_OW 447
// end ;
92895: LD_VAR 0 2
92899: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
92900: LD_INT 0
92902: PPUSH
92903: PPUSH
92904: PPUSH
// tmp := [ ] ;
92905: LD_ADDR_VAR 0 5
92909: PUSH
92910: EMPTY
92911: ST_TO_ADDR
// for i in units do
92912: LD_ADDR_VAR 0 4
92916: PUSH
92917: LD_VAR 0 1
92921: PUSH
92922: FOR_IN
92923: IFFALSE 92961
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
92925: LD_ADDR_VAR 0 5
92929: PUSH
92930: LD_VAR 0 5
92934: PPUSH
92935: LD_VAR 0 5
92939: PUSH
92940: LD_INT 1
92942: PLUS
92943: PPUSH
92944: LD_VAR 0 4
92948: PPUSH
92949: CALL_OW 256
92953: PPUSH
92954: CALL_OW 2
92958: ST_TO_ADDR
92959: GO 92922
92961: POP
92962: POP
// if not tmp then
92963: LD_VAR 0 5
92967: NOT
92968: IFFALSE 92972
// exit ;
92970: GO 93020
// if asc then
92972: LD_VAR 0 2
92976: IFFALSE 93000
// result := SortListByListAsc ( units , tmp ) else
92978: LD_ADDR_VAR 0 3
92982: PUSH
92983: LD_VAR 0 1
92987: PPUSH
92988: LD_VAR 0 5
92992: PPUSH
92993: CALL_OW 76
92997: ST_TO_ADDR
92998: GO 93020
// result := SortListByListDesc ( units , tmp ) ;
93000: LD_ADDR_VAR 0 3
93004: PUSH
93005: LD_VAR 0 1
93009: PPUSH
93010: LD_VAR 0 5
93014: PPUSH
93015: CALL_OW 77
93019: ST_TO_ADDR
// end ;
93020: LD_VAR 0 3
93024: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
93025: LD_INT 0
93027: PPUSH
93028: PPUSH
// task := GetTaskList ( mech ) ;
93029: LD_ADDR_VAR 0 4
93033: PUSH
93034: LD_VAR 0 1
93038: PPUSH
93039: CALL_OW 437
93043: ST_TO_ADDR
// if not task then
93044: LD_VAR 0 4
93048: NOT
93049: IFFALSE 93053
// exit ;
93051: GO 93095
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
93053: LD_ADDR_VAR 0 3
93057: PUSH
93058: LD_VAR 0 4
93062: PUSH
93063: LD_INT 1
93065: ARRAY
93066: PUSH
93067: LD_INT 1
93069: ARRAY
93070: PUSH
93071: LD_STRING r
93073: EQUAL
93074: PUSH
93075: LD_VAR 0 4
93079: PUSH
93080: LD_INT 1
93082: ARRAY
93083: PUSH
93084: LD_INT 4
93086: ARRAY
93087: PUSH
93088: LD_VAR 0 2
93092: EQUAL
93093: AND
93094: ST_TO_ADDR
// end ;
93095: LD_VAR 0 3
93099: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
93100: LD_INT 0
93102: PPUSH
// SetDir ( unit , d ) ;
93103: LD_VAR 0 1
93107: PPUSH
93108: LD_VAR 0 4
93112: PPUSH
93113: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
93117: LD_VAR 0 1
93121: PPUSH
93122: LD_VAR 0 2
93126: PPUSH
93127: LD_VAR 0 3
93131: PPUSH
93132: LD_VAR 0 5
93136: PPUSH
93137: CALL_OW 48
// end ;
93141: LD_VAR 0 6
93145: RET
// export function ToNaturalNumber ( number ) ; begin
93146: LD_INT 0
93148: PPUSH
// result := number div 1 ;
93149: LD_ADDR_VAR 0 2
93153: PUSH
93154: LD_VAR 0 1
93158: PUSH
93159: LD_INT 1
93161: DIV
93162: ST_TO_ADDR
// if number < 0 then
93163: LD_VAR 0 1
93167: PUSH
93168: LD_INT 0
93170: LESS
93171: IFFALSE 93181
// result := 0 ;
93173: LD_ADDR_VAR 0 2
93177: PUSH
93178: LD_INT 0
93180: ST_TO_ADDR
// end ;
93181: LD_VAR 0 2
93185: RET
// export function SortByClass ( units , class ) ; var un ; begin
93186: LD_INT 0
93188: PPUSH
93189: PPUSH
// if not units or not class then
93190: LD_VAR 0 1
93194: NOT
93195: PUSH
93196: LD_VAR 0 2
93200: NOT
93201: OR
93202: IFFALSE 93206
// exit ;
93204: GO 93301
// result := [ ] ;
93206: LD_ADDR_VAR 0 3
93210: PUSH
93211: EMPTY
93212: ST_TO_ADDR
// for un in units do
93213: LD_ADDR_VAR 0 4
93217: PUSH
93218: LD_VAR 0 1
93222: PUSH
93223: FOR_IN
93224: IFFALSE 93299
// if GetClass ( un ) = class then
93226: LD_VAR 0 4
93230: PPUSH
93231: CALL_OW 257
93235: PUSH
93236: LD_VAR 0 2
93240: EQUAL
93241: IFFALSE 93268
// result := Insert ( result , 1 , un ) else
93243: LD_ADDR_VAR 0 3
93247: PUSH
93248: LD_VAR 0 3
93252: PPUSH
93253: LD_INT 1
93255: PPUSH
93256: LD_VAR 0 4
93260: PPUSH
93261: CALL_OW 2
93265: ST_TO_ADDR
93266: GO 93297
// result := Replace ( result , result + 1 , un ) ;
93268: LD_ADDR_VAR 0 3
93272: PUSH
93273: LD_VAR 0 3
93277: PPUSH
93278: LD_VAR 0 3
93282: PUSH
93283: LD_INT 1
93285: PLUS
93286: PPUSH
93287: LD_VAR 0 4
93291: PPUSH
93292: CALL_OW 1
93296: ST_TO_ADDR
93297: GO 93223
93299: POP
93300: POP
// end ;
93301: LD_VAR 0 3
93305: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
93306: LD_INT 0
93308: PPUSH
93309: PPUSH
93310: PPUSH
93311: PPUSH
93312: PPUSH
93313: PPUSH
93314: PPUSH
// result := [ ] ;
93315: LD_ADDR_VAR 0 4
93319: PUSH
93320: EMPTY
93321: ST_TO_ADDR
// if x - r < 0 then
93322: LD_VAR 0 1
93326: PUSH
93327: LD_VAR 0 3
93331: MINUS
93332: PUSH
93333: LD_INT 0
93335: LESS
93336: IFFALSE 93348
// min_x := 0 else
93338: LD_ADDR_VAR 0 8
93342: PUSH
93343: LD_INT 0
93345: ST_TO_ADDR
93346: GO 93364
// min_x := x - r ;
93348: LD_ADDR_VAR 0 8
93352: PUSH
93353: LD_VAR 0 1
93357: PUSH
93358: LD_VAR 0 3
93362: MINUS
93363: ST_TO_ADDR
// if y - r < 0 then
93364: LD_VAR 0 2
93368: PUSH
93369: LD_VAR 0 3
93373: MINUS
93374: PUSH
93375: LD_INT 0
93377: LESS
93378: IFFALSE 93390
// min_y := 0 else
93380: LD_ADDR_VAR 0 7
93384: PUSH
93385: LD_INT 0
93387: ST_TO_ADDR
93388: GO 93406
// min_y := y - r ;
93390: LD_ADDR_VAR 0 7
93394: PUSH
93395: LD_VAR 0 2
93399: PUSH
93400: LD_VAR 0 3
93404: MINUS
93405: ST_TO_ADDR
// max_x := x + r ;
93406: LD_ADDR_VAR 0 9
93410: PUSH
93411: LD_VAR 0 1
93415: PUSH
93416: LD_VAR 0 3
93420: PLUS
93421: ST_TO_ADDR
// max_y := y + r ;
93422: LD_ADDR_VAR 0 10
93426: PUSH
93427: LD_VAR 0 2
93431: PUSH
93432: LD_VAR 0 3
93436: PLUS
93437: ST_TO_ADDR
// for _x = min_x to max_x do
93438: LD_ADDR_VAR 0 5
93442: PUSH
93443: DOUBLE
93444: LD_VAR 0 8
93448: DEC
93449: ST_TO_ADDR
93450: LD_VAR 0 9
93454: PUSH
93455: FOR_TO
93456: IFFALSE 93557
// for _y = min_y to max_y do
93458: LD_ADDR_VAR 0 6
93462: PUSH
93463: DOUBLE
93464: LD_VAR 0 7
93468: DEC
93469: ST_TO_ADDR
93470: LD_VAR 0 10
93474: PUSH
93475: FOR_TO
93476: IFFALSE 93553
// begin if not ValidHex ( _x , _y ) then
93478: LD_VAR 0 5
93482: PPUSH
93483: LD_VAR 0 6
93487: PPUSH
93488: CALL_OW 488
93492: NOT
93493: IFFALSE 93497
// continue ;
93495: GO 93475
// if GetResourceTypeXY ( _x , _y ) then
93497: LD_VAR 0 5
93501: PPUSH
93502: LD_VAR 0 6
93506: PPUSH
93507: CALL_OW 283
93511: IFFALSE 93551
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
93513: LD_ADDR_VAR 0 4
93517: PUSH
93518: LD_VAR 0 4
93522: PPUSH
93523: LD_VAR 0 4
93527: PUSH
93528: LD_INT 1
93530: PLUS
93531: PPUSH
93532: LD_VAR 0 5
93536: PUSH
93537: LD_VAR 0 6
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: PPUSH
93546: CALL_OW 1
93550: ST_TO_ADDR
// end ;
93551: GO 93475
93553: POP
93554: POP
93555: GO 93455
93557: POP
93558: POP
// end ;
93559: LD_VAR 0 4
93563: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
93564: LD_INT 0
93566: PPUSH
93567: PPUSH
93568: PPUSH
93569: PPUSH
93570: PPUSH
93571: PPUSH
93572: PPUSH
93573: PPUSH
// if not units then
93574: LD_VAR 0 1
93578: NOT
93579: IFFALSE 93583
// exit ;
93581: GO 94107
// result := UnitFilter ( units , [ f_ok ] ) ;
93583: LD_ADDR_VAR 0 3
93587: PUSH
93588: LD_VAR 0 1
93592: PPUSH
93593: LD_INT 50
93595: PUSH
93596: EMPTY
93597: LIST
93598: PPUSH
93599: CALL_OW 72
93603: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
93604: LD_ADDR_VAR 0 8
93608: PUSH
93609: LD_VAR 0 1
93613: PUSH
93614: LD_INT 1
93616: ARRAY
93617: PPUSH
93618: CALL_OW 255
93622: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
93623: LD_ADDR_VAR 0 10
93627: PUSH
93628: LD_INT 29
93630: PUSH
93631: LD_INT 91
93633: PUSH
93634: LD_INT 49
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: LIST
93641: ST_TO_ADDR
// if not result then
93642: LD_VAR 0 3
93646: NOT
93647: IFFALSE 93651
// exit ;
93649: GO 94107
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
93651: LD_ADDR_VAR 0 5
93655: PUSH
93656: LD_INT 81
93658: PUSH
93659: LD_VAR 0 8
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: PPUSH
93668: CALL_OW 69
93672: ST_TO_ADDR
// for i in result do
93673: LD_ADDR_VAR 0 4
93677: PUSH
93678: LD_VAR 0 3
93682: PUSH
93683: FOR_IN
93684: IFFALSE 94105
// begin tag := GetTag ( i ) + 1 ;
93686: LD_ADDR_VAR 0 9
93690: PUSH
93691: LD_VAR 0 4
93695: PPUSH
93696: CALL_OW 110
93700: PUSH
93701: LD_INT 1
93703: PLUS
93704: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
93705: LD_ADDR_VAR 0 7
93709: PUSH
93710: LD_VAR 0 4
93714: PPUSH
93715: CALL_OW 250
93719: PPUSH
93720: LD_VAR 0 4
93724: PPUSH
93725: CALL_OW 251
93729: PPUSH
93730: LD_INT 6
93732: PPUSH
93733: CALL 93306 0 3
93737: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
93738: LD_VAR 0 4
93742: PPUSH
93743: CALL_OW 247
93747: PUSH
93748: LD_INT 2
93750: EQUAL
93751: PUSH
93752: LD_VAR 0 7
93756: AND
93757: PUSH
93758: LD_VAR 0 4
93762: PPUSH
93763: CALL_OW 264
93767: PUSH
93768: LD_VAR 0 10
93772: IN
93773: NOT
93774: AND
93775: IFFALSE 93814
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
93777: LD_VAR 0 4
93781: PPUSH
93782: LD_VAR 0 7
93786: PUSH
93787: LD_INT 1
93789: ARRAY
93790: PUSH
93791: LD_INT 1
93793: ARRAY
93794: PPUSH
93795: LD_VAR 0 7
93799: PUSH
93800: LD_INT 1
93802: ARRAY
93803: PUSH
93804: LD_INT 2
93806: ARRAY
93807: PPUSH
93808: CALL_OW 116
93812: GO 94103
// if path > tag then
93814: LD_VAR 0 2
93818: PUSH
93819: LD_VAR 0 9
93823: GREATER
93824: IFFALSE 94032
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
93826: LD_ADDR_VAR 0 6
93830: PUSH
93831: LD_VAR 0 5
93835: PPUSH
93836: LD_INT 91
93838: PUSH
93839: LD_VAR 0 4
93843: PUSH
93844: LD_INT 8
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: LIST
93851: PPUSH
93852: CALL_OW 72
93856: ST_TO_ADDR
// if nearEnemy then
93857: LD_VAR 0 6
93861: IFFALSE 93930
// begin if GetWeapon ( i ) = ru_time_lapser then
93863: LD_VAR 0 4
93867: PPUSH
93868: CALL_OW 264
93872: PUSH
93873: LD_INT 49
93875: EQUAL
93876: IFFALSE 93904
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
93878: LD_VAR 0 4
93882: PPUSH
93883: LD_VAR 0 6
93887: PPUSH
93888: LD_VAR 0 4
93892: PPUSH
93893: CALL_OW 74
93897: PPUSH
93898: CALL_OW 112
93902: GO 93928
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
93904: LD_VAR 0 4
93908: PPUSH
93909: LD_VAR 0 6
93913: PPUSH
93914: LD_VAR 0 4
93918: PPUSH
93919: CALL_OW 74
93923: PPUSH
93924: CALL 95032 0 2
// end else
93928: GO 94030
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
93930: LD_VAR 0 4
93934: PPUSH
93935: LD_VAR 0 2
93939: PUSH
93940: LD_VAR 0 9
93944: ARRAY
93945: PUSH
93946: LD_INT 1
93948: ARRAY
93949: PPUSH
93950: LD_VAR 0 2
93954: PUSH
93955: LD_VAR 0 9
93959: ARRAY
93960: PUSH
93961: LD_INT 2
93963: ARRAY
93964: PPUSH
93965: CALL_OW 297
93969: PUSH
93970: LD_INT 6
93972: GREATER
93973: IFFALSE 94016
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
93975: LD_VAR 0 4
93979: PPUSH
93980: LD_VAR 0 2
93984: PUSH
93985: LD_VAR 0 9
93989: ARRAY
93990: PUSH
93991: LD_INT 1
93993: ARRAY
93994: PPUSH
93995: LD_VAR 0 2
93999: PUSH
94000: LD_VAR 0 9
94004: ARRAY
94005: PUSH
94006: LD_INT 2
94008: ARRAY
94009: PPUSH
94010: CALL_OW 114
94014: GO 94030
// SetTag ( i , tag ) ;
94016: LD_VAR 0 4
94020: PPUSH
94021: LD_VAR 0 9
94025: PPUSH
94026: CALL_OW 109
// end else
94030: GO 94103
// if enemy then
94032: LD_VAR 0 5
94036: IFFALSE 94103
// begin if GetWeapon ( i ) = ru_time_lapser then
94038: LD_VAR 0 4
94042: PPUSH
94043: CALL_OW 264
94047: PUSH
94048: LD_INT 49
94050: EQUAL
94051: IFFALSE 94079
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
94053: LD_VAR 0 4
94057: PPUSH
94058: LD_VAR 0 5
94062: PPUSH
94063: LD_VAR 0 4
94067: PPUSH
94068: CALL_OW 74
94072: PPUSH
94073: CALL_OW 112
94077: GO 94103
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
94079: LD_VAR 0 4
94083: PPUSH
94084: LD_VAR 0 5
94088: PPUSH
94089: LD_VAR 0 4
94093: PPUSH
94094: CALL_OW 74
94098: PPUSH
94099: CALL 95032 0 2
// end ; end ;
94103: GO 93683
94105: POP
94106: POP
// end ;
94107: LD_VAR 0 3
94111: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
94112: LD_INT 0
94114: PPUSH
94115: PPUSH
94116: PPUSH
// if not unit or IsInUnit ( unit ) then
94117: LD_VAR 0 1
94121: NOT
94122: PUSH
94123: LD_VAR 0 1
94127: PPUSH
94128: CALL_OW 310
94132: OR
94133: IFFALSE 94137
// exit ;
94135: GO 94228
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
94137: LD_ADDR_VAR 0 4
94141: PUSH
94142: LD_VAR 0 1
94146: PPUSH
94147: CALL_OW 250
94151: PPUSH
94152: LD_VAR 0 2
94156: PPUSH
94157: LD_INT 1
94159: PPUSH
94160: CALL_OW 272
94164: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
94165: LD_ADDR_VAR 0 5
94169: PUSH
94170: LD_VAR 0 1
94174: PPUSH
94175: CALL_OW 251
94179: PPUSH
94180: LD_VAR 0 2
94184: PPUSH
94185: LD_INT 1
94187: PPUSH
94188: CALL_OW 273
94192: ST_TO_ADDR
// if ValidHex ( x , y ) then
94193: LD_VAR 0 4
94197: PPUSH
94198: LD_VAR 0 5
94202: PPUSH
94203: CALL_OW 488
94207: IFFALSE 94228
// ComTurnXY ( unit , x , y ) ;
94209: LD_VAR 0 1
94213: PPUSH
94214: LD_VAR 0 4
94218: PPUSH
94219: LD_VAR 0 5
94223: PPUSH
94224: CALL_OW 118
// end ;
94228: LD_VAR 0 3
94232: RET
// export function SeeUnits ( side , units ) ; var i ; begin
94233: LD_INT 0
94235: PPUSH
94236: PPUSH
// result := false ;
94237: LD_ADDR_VAR 0 3
94241: PUSH
94242: LD_INT 0
94244: ST_TO_ADDR
// if not units then
94245: LD_VAR 0 2
94249: NOT
94250: IFFALSE 94254
// exit ;
94252: GO 94299
// for i in units do
94254: LD_ADDR_VAR 0 4
94258: PUSH
94259: LD_VAR 0 2
94263: PUSH
94264: FOR_IN
94265: IFFALSE 94297
// if See ( side , i ) then
94267: LD_VAR 0 1
94271: PPUSH
94272: LD_VAR 0 4
94276: PPUSH
94277: CALL_OW 292
94281: IFFALSE 94295
// begin result := true ;
94283: LD_ADDR_VAR 0 3
94287: PUSH
94288: LD_INT 1
94290: ST_TO_ADDR
// exit ;
94291: POP
94292: POP
94293: GO 94299
// end ;
94295: GO 94264
94297: POP
94298: POP
// end ;
94299: LD_VAR 0 3
94303: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
94304: LD_INT 0
94306: PPUSH
94307: PPUSH
94308: PPUSH
94309: PPUSH
// if not unit or not points then
94310: LD_VAR 0 1
94314: NOT
94315: PUSH
94316: LD_VAR 0 2
94320: NOT
94321: OR
94322: IFFALSE 94326
// exit ;
94324: GO 94416
// dist := 99999 ;
94326: LD_ADDR_VAR 0 5
94330: PUSH
94331: LD_INT 99999
94333: ST_TO_ADDR
// for i in points do
94334: LD_ADDR_VAR 0 4
94338: PUSH
94339: LD_VAR 0 2
94343: PUSH
94344: FOR_IN
94345: IFFALSE 94414
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
94347: LD_ADDR_VAR 0 6
94351: PUSH
94352: LD_VAR 0 1
94356: PPUSH
94357: LD_VAR 0 4
94361: PUSH
94362: LD_INT 1
94364: ARRAY
94365: PPUSH
94366: LD_VAR 0 4
94370: PUSH
94371: LD_INT 2
94373: ARRAY
94374: PPUSH
94375: CALL_OW 297
94379: ST_TO_ADDR
// if tmpDist < dist then
94380: LD_VAR 0 6
94384: PUSH
94385: LD_VAR 0 5
94389: LESS
94390: IFFALSE 94412
// begin result := i ;
94392: LD_ADDR_VAR 0 3
94396: PUSH
94397: LD_VAR 0 4
94401: ST_TO_ADDR
// dist := tmpDist ;
94402: LD_ADDR_VAR 0 5
94406: PUSH
94407: LD_VAR 0 6
94411: ST_TO_ADDR
// end ; end ;
94412: GO 94344
94414: POP
94415: POP
// end ;
94416: LD_VAR 0 3
94420: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
94421: LD_INT 0
94423: PPUSH
// uc_side := side ;
94424: LD_ADDR_OWVAR 20
94428: PUSH
94429: LD_VAR 0 1
94433: ST_TO_ADDR
// uc_nation := 3 ;
94434: LD_ADDR_OWVAR 21
94438: PUSH
94439: LD_INT 3
94441: ST_TO_ADDR
// vc_chassis := 25 ;
94442: LD_ADDR_OWVAR 37
94446: PUSH
94447: LD_INT 25
94449: ST_TO_ADDR
// vc_engine := engine_siberite ;
94450: LD_ADDR_OWVAR 39
94454: PUSH
94455: LD_INT 3
94457: ST_TO_ADDR
// vc_control := control_computer ;
94458: LD_ADDR_OWVAR 38
94462: PUSH
94463: LD_INT 3
94465: ST_TO_ADDR
// vc_weapon := 59 ;
94466: LD_ADDR_OWVAR 40
94470: PUSH
94471: LD_INT 59
94473: ST_TO_ADDR
// result := CreateVehicle ;
94474: LD_ADDR_VAR 0 5
94478: PUSH
94479: CALL_OW 45
94483: ST_TO_ADDR
// SetDir ( result , d ) ;
94484: LD_VAR 0 5
94488: PPUSH
94489: LD_VAR 0 4
94493: PPUSH
94494: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
94498: LD_VAR 0 5
94502: PPUSH
94503: LD_VAR 0 2
94507: PPUSH
94508: LD_VAR 0 3
94512: PPUSH
94513: LD_INT 0
94515: PPUSH
94516: CALL_OW 48
// end ;
94520: LD_VAR 0 5
94524: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
94525: LD_INT 0
94527: PPUSH
94528: PPUSH
94529: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
94530: LD_ADDR_VAR 0 2
94534: PUSH
94535: LD_INT 0
94537: PUSH
94538: LD_INT 0
94540: PUSH
94541: LD_INT 0
94543: PUSH
94544: LD_INT 0
94546: PUSH
94547: EMPTY
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
94553: LD_VAR 0 1
94557: NOT
94558: PUSH
94559: LD_VAR 0 1
94563: PPUSH
94564: CALL_OW 264
94568: PUSH
94569: LD_INT 12
94571: PUSH
94572: LD_INT 51
94574: PUSH
94575: LD_INT 32
94577: PUSH
94578: LD_INT 89
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: IN
94587: NOT
94588: OR
94589: IFFALSE 94593
// exit ;
94591: GO 94691
// for i := 1 to 3 do
94593: LD_ADDR_VAR 0 3
94597: PUSH
94598: DOUBLE
94599: LD_INT 1
94601: DEC
94602: ST_TO_ADDR
94603: LD_INT 3
94605: PUSH
94606: FOR_TO
94607: IFFALSE 94689
// begin tmp := GetCargo ( cargo , i ) ;
94609: LD_ADDR_VAR 0 4
94613: PUSH
94614: LD_VAR 0 1
94618: PPUSH
94619: LD_VAR 0 3
94623: PPUSH
94624: CALL_OW 289
94628: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
94629: LD_ADDR_VAR 0 2
94633: PUSH
94634: LD_VAR 0 2
94638: PPUSH
94639: LD_VAR 0 3
94643: PPUSH
94644: LD_VAR 0 4
94648: PPUSH
94649: CALL_OW 1
94653: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
94654: LD_ADDR_VAR 0 2
94658: PUSH
94659: LD_VAR 0 2
94663: PPUSH
94664: LD_INT 4
94666: PPUSH
94667: LD_VAR 0 2
94671: PUSH
94672: LD_INT 4
94674: ARRAY
94675: PUSH
94676: LD_VAR 0 4
94680: PLUS
94681: PPUSH
94682: CALL_OW 1
94686: ST_TO_ADDR
// end ;
94687: GO 94606
94689: POP
94690: POP
// end ;
94691: LD_VAR 0 2
94695: RET
// export function Length ( array ) ; begin
94696: LD_INT 0
94698: PPUSH
// result := array + 0 ;
94699: LD_ADDR_VAR 0 2
94703: PUSH
94704: LD_VAR 0 1
94708: PUSH
94709: LD_INT 0
94711: PLUS
94712: ST_TO_ADDR
// end ;
94713: LD_VAR 0 2
94717: RET
// export function PrepareArray ( array ) ; begin
94718: LD_INT 0
94720: PPUSH
// result := array diff 0 ;
94721: LD_ADDR_VAR 0 2
94725: PUSH
94726: LD_VAR 0 1
94730: PUSH
94731: LD_INT 0
94733: DIFF
94734: ST_TO_ADDR
// if not result [ 1 ] then
94735: LD_VAR 0 2
94739: PUSH
94740: LD_INT 1
94742: ARRAY
94743: NOT
94744: IFFALSE 94764
// result := Delete ( result , 1 ) ;
94746: LD_ADDR_VAR 0 2
94750: PUSH
94751: LD_VAR 0 2
94755: PPUSH
94756: LD_INT 1
94758: PPUSH
94759: CALL_OW 3
94763: ST_TO_ADDR
// end ;
94764: LD_VAR 0 2
94768: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
94769: LD_INT 0
94771: PPUSH
94772: PPUSH
94773: PPUSH
94774: PPUSH
// sibRocketRange := 25 ;
94775: LD_ADDR_VAR 0 6
94779: PUSH
94780: LD_INT 25
94782: ST_TO_ADDR
// result := false ;
94783: LD_ADDR_VAR 0 4
94787: PUSH
94788: LD_INT 0
94790: ST_TO_ADDR
// for i := 0 to 5 do
94791: LD_ADDR_VAR 0 5
94795: PUSH
94796: DOUBLE
94797: LD_INT 0
94799: DEC
94800: ST_TO_ADDR
94801: LD_INT 5
94803: PUSH
94804: FOR_TO
94805: IFFALSE 94872
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
94807: LD_VAR 0 1
94811: PPUSH
94812: LD_VAR 0 5
94816: PPUSH
94817: LD_VAR 0 6
94821: PPUSH
94822: CALL_OW 272
94826: PPUSH
94827: LD_VAR 0 2
94831: PPUSH
94832: LD_VAR 0 5
94836: PPUSH
94837: LD_VAR 0 6
94841: PPUSH
94842: CALL_OW 273
94846: PPUSH
94847: LD_VAR 0 3
94851: PPUSH
94852: CALL_OW 309
94856: IFFALSE 94870
// begin result := true ;
94858: LD_ADDR_VAR 0 4
94862: PUSH
94863: LD_INT 1
94865: ST_TO_ADDR
// exit ;
94866: POP
94867: POP
94868: GO 94874
// end ;
94870: GO 94804
94872: POP
94873: POP
// end ;
94874: LD_VAR 0 4
94878: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
94879: LD_INT 0
94881: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
94882: LD_VAR 0 1
94886: PPUSH
94887: LD_VAR 0 2
94891: PPUSH
94892: LD_INT 0
94894: PPUSH
94895: LD_INT 0
94897: PPUSH
94898: LD_INT 1
94900: PPUSH
94901: LD_INT 0
94903: PPUSH
94904: CALL_OW 587
// end ;
94908: LD_VAR 0 3
94912: RET
// export function CenterOnNow ( unit ) ; begin
94913: LD_INT 0
94915: PPUSH
// result := IsInUnit ( unit ) ;
94916: LD_ADDR_VAR 0 2
94920: PUSH
94921: LD_VAR 0 1
94925: PPUSH
94926: CALL_OW 310
94930: ST_TO_ADDR
// if not result then
94931: LD_VAR 0 2
94935: NOT
94936: IFFALSE 94948
// result := unit ;
94938: LD_ADDR_VAR 0 2
94942: PUSH
94943: LD_VAR 0 1
94947: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
94948: LD_VAR 0 1
94952: PPUSH
94953: CALL_OW 87
// end ;
94957: LD_VAR 0 2
94961: RET
// export function ComMoveHex ( unit , hex ) ; begin
94962: LD_INT 0
94964: PPUSH
// if not hex then
94965: LD_VAR 0 2
94969: NOT
94970: IFFALSE 94974
// exit ;
94972: GO 95027
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
94974: LD_VAR 0 2
94978: PUSH
94979: LD_INT 1
94981: ARRAY
94982: PPUSH
94983: LD_VAR 0 2
94987: PUSH
94988: LD_INT 2
94990: ARRAY
94991: PPUSH
94992: CALL_OW 428
94996: IFFALSE 95000
// exit ;
94998: GO 95027
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
95000: LD_VAR 0 1
95004: PPUSH
95005: LD_VAR 0 2
95009: PUSH
95010: LD_INT 1
95012: ARRAY
95013: PPUSH
95014: LD_VAR 0 2
95018: PUSH
95019: LD_INT 2
95021: ARRAY
95022: PPUSH
95023: CALL_OW 111
// end ;
95027: LD_VAR 0 3
95031: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
95032: LD_INT 0
95034: PPUSH
95035: PPUSH
95036: PPUSH
// if not unit or not enemy then
95037: LD_VAR 0 1
95041: NOT
95042: PUSH
95043: LD_VAR 0 2
95047: NOT
95048: OR
95049: IFFALSE 95053
// exit ;
95051: GO 95177
// x := GetX ( enemy ) ;
95053: LD_ADDR_VAR 0 4
95057: PUSH
95058: LD_VAR 0 2
95062: PPUSH
95063: CALL_OW 250
95067: ST_TO_ADDR
// y := GetY ( enemy ) ;
95068: LD_ADDR_VAR 0 5
95072: PUSH
95073: LD_VAR 0 2
95077: PPUSH
95078: CALL_OW 251
95082: ST_TO_ADDR
// if ValidHex ( x , y ) then
95083: LD_VAR 0 4
95087: PPUSH
95088: LD_VAR 0 5
95092: PPUSH
95093: CALL_OW 488
95097: IFFALSE 95177
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
95099: LD_VAR 0 2
95103: PPUSH
95104: CALL_OW 247
95108: PUSH
95109: LD_INT 3
95111: PUSH
95112: LD_INT 2
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: IN
95119: PUSH
95120: LD_VAR 0 1
95124: PPUSH
95125: CALL_OW 255
95129: PPUSH
95130: LD_VAR 0 2
95134: PPUSH
95135: CALL_OW 292
95139: AND
95140: IFFALSE 95158
// ComAttackUnit ( unit , enemy ) else
95142: LD_VAR 0 1
95146: PPUSH
95147: LD_VAR 0 2
95151: PPUSH
95152: CALL_OW 115
95156: GO 95177
// ComAgressiveMove ( unit , x , y ) ;
95158: LD_VAR 0 1
95162: PPUSH
95163: LD_VAR 0 4
95167: PPUSH
95168: LD_VAR 0 5
95172: PPUSH
95173: CALL_OW 114
// end ;
95177: LD_VAR 0 3
95181: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
95182: LD_INT 0
95184: PPUSH
95185: PPUSH
95186: PPUSH
// list := AreaToList ( area , 0 ) ;
95187: LD_ADDR_VAR 0 5
95191: PUSH
95192: LD_VAR 0 1
95196: PPUSH
95197: LD_INT 0
95199: PPUSH
95200: CALL_OW 517
95204: ST_TO_ADDR
// if not list then
95205: LD_VAR 0 5
95209: NOT
95210: IFFALSE 95214
// exit ;
95212: GO 95344
// if all then
95214: LD_VAR 0 2
95218: IFFALSE 95306
// begin for i := 1 to list [ 1 ] do
95220: LD_ADDR_VAR 0 4
95224: PUSH
95225: DOUBLE
95226: LD_INT 1
95228: DEC
95229: ST_TO_ADDR
95230: LD_VAR 0 5
95234: PUSH
95235: LD_INT 1
95237: ARRAY
95238: PUSH
95239: FOR_TO
95240: IFFALSE 95302
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
95242: LD_ADDR_VAR 0 3
95246: PUSH
95247: LD_VAR 0 3
95251: PPUSH
95252: LD_VAR 0 3
95256: PUSH
95257: LD_INT 1
95259: PLUS
95260: PPUSH
95261: LD_VAR 0 5
95265: PUSH
95266: LD_INT 1
95268: ARRAY
95269: PUSH
95270: LD_VAR 0 4
95274: ARRAY
95275: PUSH
95276: LD_VAR 0 5
95280: PUSH
95281: LD_INT 2
95283: ARRAY
95284: PUSH
95285: LD_VAR 0 4
95289: ARRAY
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: PPUSH
95295: CALL_OW 1
95299: ST_TO_ADDR
95300: GO 95239
95302: POP
95303: POP
// exit ;
95304: GO 95344
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
95306: LD_ADDR_VAR 0 3
95310: PUSH
95311: LD_VAR 0 5
95315: PUSH
95316: LD_INT 1
95318: ARRAY
95319: PUSH
95320: LD_INT 1
95322: ARRAY
95323: PUSH
95324: LD_VAR 0 5
95328: PUSH
95329: LD_INT 2
95331: ARRAY
95332: PUSH
95333: LD_INT 1
95335: ARRAY
95336: PUSH
95337: EMPTY
95338: LIST
95339: LIST
95340: PUSH
95341: EMPTY
95342: LIST
95343: ST_TO_ADDR
// end ;
95344: LD_VAR 0 3
95348: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
95349: LD_INT 0
95351: PPUSH
95352: PPUSH
// list := AreaToList ( area , 0 ) ;
95353: LD_ADDR_VAR 0 4
95357: PUSH
95358: LD_VAR 0 1
95362: PPUSH
95363: LD_INT 0
95365: PPUSH
95366: CALL_OW 517
95370: ST_TO_ADDR
// if not list then
95371: LD_VAR 0 4
95375: NOT
95376: IFFALSE 95380
// exit ;
95378: GO 95421
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
95380: LD_ADDR_VAR 0 3
95384: PUSH
95385: LD_VAR 0 4
95389: PUSH
95390: LD_INT 1
95392: ARRAY
95393: PUSH
95394: LD_INT 1
95396: ARRAY
95397: PUSH
95398: LD_VAR 0 4
95402: PUSH
95403: LD_INT 2
95405: ARRAY
95406: PUSH
95407: LD_INT 1
95409: ARRAY
95410: PUSH
95411: LD_VAR 0 2
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: LIST
95420: ST_TO_ADDR
// end ;
95421: LD_VAR 0 3
95425: RET
// export function First ( array ) ; begin
95426: LD_INT 0
95428: PPUSH
// if not array then
95429: LD_VAR 0 1
95433: NOT
95434: IFFALSE 95438
// exit ;
95436: GO 95452
// result := array [ 1 ] ;
95438: LD_ADDR_VAR 0 2
95442: PUSH
95443: LD_VAR 0 1
95447: PUSH
95448: LD_INT 1
95450: ARRAY
95451: ST_TO_ADDR
// end ;
95452: LD_VAR 0 2
95456: RET
// export function Last ( array ) ; begin
95457: LD_INT 0
95459: PPUSH
// if not array then
95460: LD_VAR 0 1
95464: NOT
95465: IFFALSE 95469
// exit ;
95467: GO 95485
// result := array [ array ] ;
95469: LD_ADDR_VAR 0 2
95473: PUSH
95474: LD_VAR 0 1
95478: PUSH
95479: LD_VAR 0 1
95483: ARRAY
95484: ST_TO_ADDR
// end ; end_of_file end_of_file
95485: LD_VAR 0 2
95489: RET
// export globalGameSaveCounter ; every 0 0$1 do
95490: GO 95492
95492: DISABLE
// begin enable ;
95493: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
95494: LD_STRING updateTimer(
95496: PUSH
95497: LD_OWVAR 1
95501: STR
95502: PUSH
95503: LD_STRING );
95505: STR
95506: PPUSH
95507: CALL_OW 559
// end ;
95511: END
// every 0 0$1 do
95512: GO 95514
95514: DISABLE
// begin globalGameSaveCounter := 0 ;
95515: LD_ADDR_EXP 123
95519: PUSH
95520: LD_INT 0
95522: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
95523: LD_STRING setGameSaveCounter(0)
95525: PPUSH
95526: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
95530: LD_STRING initStreamRollete();
95532: PPUSH
95533: CALL_OW 559
// InitStreamMode ;
95537: CALL 96863 0 0
// DefineStreamItems ( false ) ;
95541: LD_INT 0
95543: PPUSH
95544: CALL 97327 0 1
// end ;
95548: END
// export function SOS_MapStart ( ) ; begin
95549: LD_INT 0
95551: PPUSH
// if streamModeActive then
95552: LD_EXP 124
95556: IFFALSE 95565
// DefineStreamItems ( true ) ;
95558: LD_INT 1
95560: PPUSH
95561: CALL 97327 0 1
// UpdateLuaVariables ( ) ;
95565: CALL 95582 0 0
// UpdateFactoryWaypoints ( ) ;
95569: CALL 110196 0 0
// UpdateWarehouseGatheringPoints ( ) ;
95573: CALL 110453 0 0
// end ;
95577: LD_VAR 0 1
95581: RET
// function UpdateLuaVariables ( ) ; begin
95582: LD_INT 0
95584: PPUSH
// if globalGameSaveCounter then
95585: LD_EXP 123
95589: IFFALSE 95623
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
95591: LD_ADDR_EXP 123
95595: PUSH
95596: LD_EXP 123
95600: PPUSH
95601: CALL 92321 0 1
95605: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95606: LD_STRING setGameSaveCounter(
95608: PUSH
95609: LD_EXP 123
95613: STR
95614: PUSH
95615: LD_STRING )
95617: STR
95618: PPUSH
95619: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
95623: LD_STRING setGameDifficulty(
95625: PUSH
95626: LD_OWVAR 67
95630: STR
95631: PUSH
95632: LD_STRING )
95634: STR
95635: PPUSH
95636: CALL_OW 559
// end ;
95640: LD_VAR 0 1
95644: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
95645: LD_INT 0
95647: PPUSH
// if p2 = stream_mode then
95648: LD_VAR 0 2
95652: PUSH
95653: LD_INT 100
95655: EQUAL
95656: IFFALSE 96659
// begin if not StreamModeActive then
95658: LD_EXP 124
95662: NOT
95663: IFFALSE 95673
// StreamModeActive := true ;
95665: LD_ADDR_EXP 124
95669: PUSH
95670: LD_INT 1
95672: ST_TO_ADDR
// if p3 = 0 then
95673: LD_VAR 0 3
95677: PUSH
95678: LD_INT 0
95680: EQUAL
95681: IFFALSE 95687
// InitStreamMode ;
95683: CALL 96863 0 0
// if p3 = 1 then
95687: LD_VAR 0 3
95691: PUSH
95692: LD_INT 1
95694: EQUAL
95695: IFFALSE 95705
// sRocket := true ;
95697: LD_ADDR_EXP 129
95701: PUSH
95702: LD_INT 1
95704: ST_TO_ADDR
// if p3 = 2 then
95705: LD_VAR 0 3
95709: PUSH
95710: LD_INT 2
95712: EQUAL
95713: IFFALSE 95723
// sSpeed := true ;
95715: LD_ADDR_EXP 128
95719: PUSH
95720: LD_INT 1
95722: ST_TO_ADDR
// if p3 = 3 then
95723: LD_VAR 0 3
95727: PUSH
95728: LD_INT 3
95730: EQUAL
95731: IFFALSE 95741
// sEngine := true ;
95733: LD_ADDR_EXP 130
95737: PUSH
95738: LD_INT 1
95740: ST_TO_ADDR
// if p3 = 4 then
95741: LD_VAR 0 3
95745: PUSH
95746: LD_INT 4
95748: EQUAL
95749: IFFALSE 95759
// sSpec := true ;
95751: LD_ADDR_EXP 127
95755: PUSH
95756: LD_INT 1
95758: ST_TO_ADDR
// if p3 = 5 then
95759: LD_VAR 0 3
95763: PUSH
95764: LD_INT 5
95766: EQUAL
95767: IFFALSE 95777
// sLevel := true ;
95769: LD_ADDR_EXP 131
95773: PUSH
95774: LD_INT 1
95776: ST_TO_ADDR
// if p3 = 6 then
95777: LD_VAR 0 3
95781: PUSH
95782: LD_INT 6
95784: EQUAL
95785: IFFALSE 95795
// sArmoury := true ;
95787: LD_ADDR_EXP 132
95791: PUSH
95792: LD_INT 1
95794: ST_TO_ADDR
// if p3 = 7 then
95795: LD_VAR 0 3
95799: PUSH
95800: LD_INT 7
95802: EQUAL
95803: IFFALSE 95813
// sRadar := true ;
95805: LD_ADDR_EXP 133
95809: PUSH
95810: LD_INT 1
95812: ST_TO_ADDR
// if p3 = 8 then
95813: LD_VAR 0 3
95817: PUSH
95818: LD_INT 8
95820: EQUAL
95821: IFFALSE 95831
// sBunker := true ;
95823: LD_ADDR_EXP 134
95827: PUSH
95828: LD_INT 1
95830: ST_TO_ADDR
// if p3 = 9 then
95831: LD_VAR 0 3
95835: PUSH
95836: LD_INT 9
95838: EQUAL
95839: IFFALSE 95849
// sHack := true ;
95841: LD_ADDR_EXP 135
95845: PUSH
95846: LD_INT 1
95848: ST_TO_ADDR
// if p3 = 10 then
95849: LD_VAR 0 3
95853: PUSH
95854: LD_INT 10
95856: EQUAL
95857: IFFALSE 95867
// sFire := true ;
95859: LD_ADDR_EXP 136
95863: PUSH
95864: LD_INT 1
95866: ST_TO_ADDR
// if p3 = 11 then
95867: LD_VAR 0 3
95871: PUSH
95872: LD_INT 11
95874: EQUAL
95875: IFFALSE 95885
// sRefresh := true ;
95877: LD_ADDR_EXP 137
95881: PUSH
95882: LD_INT 1
95884: ST_TO_ADDR
// if p3 = 12 then
95885: LD_VAR 0 3
95889: PUSH
95890: LD_INT 12
95892: EQUAL
95893: IFFALSE 95903
// sExp := true ;
95895: LD_ADDR_EXP 138
95899: PUSH
95900: LD_INT 1
95902: ST_TO_ADDR
// if p3 = 13 then
95903: LD_VAR 0 3
95907: PUSH
95908: LD_INT 13
95910: EQUAL
95911: IFFALSE 95921
// sDepot := true ;
95913: LD_ADDR_EXP 139
95917: PUSH
95918: LD_INT 1
95920: ST_TO_ADDR
// if p3 = 14 then
95921: LD_VAR 0 3
95925: PUSH
95926: LD_INT 14
95928: EQUAL
95929: IFFALSE 95939
// sFlag := true ;
95931: LD_ADDR_EXP 140
95935: PUSH
95936: LD_INT 1
95938: ST_TO_ADDR
// if p3 = 15 then
95939: LD_VAR 0 3
95943: PUSH
95944: LD_INT 15
95946: EQUAL
95947: IFFALSE 95957
// sKamikadze := true ;
95949: LD_ADDR_EXP 148
95953: PUSH
95954: LD_INT 1
95956: ST_TO_ADDR
// if p3 = 16 then
95957: LD_VAR 0 3
95961: PUSH
95962: LD_INT 16
95964: EQUAL
95965: IFFALSE 95975
// sTroll := true ;
95967: LD_ADDR_EXP 149
95971: PUSH
95972: LD_INT 1
95974: ST_TO_ADDR
// if p3 = 17 then
95975: LD_VAR 0 3
95979: PUSH
95980: LD_INT 17
95982: EQUAL
95983: IFFALSE 95993
// sSlow := true ;
95985: LD_ADDR_EXP 150
95989: PUSH
95990: LD_INT 1
95992: ST_TO_ADDR
// if p3 = 18 then
95993: LD_VAR 0 3
95997: PUSH
95998: LD_INT 18
96000: EQUAL
96001: IFFALSE 96011
// sLack := true ;
96003: LD_ADDR_EXP 151
96007: PUSH
96008: LD_INT 1
96010: ST_TO_ADDR
// if p3 = 19 then
96011: LD_VAR 0 3
96015: PUSH
96016: LD_INT 19
96018: EQUAL
96019: IFFALSE 96029
// sTank := true ;
96021: LD_ADDR_EXP 153
96025: PUSH
96026: LD_INT 1
96028: ST_TO_ADDR
// if p3 = 20 then
96029: LD_VAR 0 3
96033: PUSH
96034: LD_INT 20
96036: EQUAL
96037: IFFALSE 96047
// sRemote := true ;
96039: LD_ADDR_EXP 154
96043: PUSH
96044: LD_INT 1
96046: ST_TO_ADDR
// if p3 = 21 then
96047: LD_VAR 0 3
96051: PUSH
96052: LD_INT 21
96054: EQUAL
96055: IFFALSE 96065
// sPowell := true ;
96057: LD_ADDR_EXP 155
96061: PUSH
96062: LD_INT 1
96064: ST_TO_ADDR
// if p3 = 22 then
96065: LD_VAR 0 3
96069: PUSH
96070: LD_INT 22
96072: EQUAL
96073: IFFALSE 96083
// sTeleport := true ;
96075: LD_ADDR_EXP 158
96079: PUSH
96080: LD_INT 1
96082: ST_TO_ADDR
// if p3 = 23 then
96083: LD_VAR 0 3
96087: PUSH
96088: LD_INT 23
96090: EQUAL
96091: IFFALSE 96101
// sOilTower := true ;
96093: LD_ADDR_EXP 160
96097: PUSH
96098: LD_INT 1
96100: ST_TO_ADDR
// if p3 = 24 then
96101: LD_VAR 0 3
96105: PUSH
96106: LD_INT 24
96108: EQUAL
96109: IFFALSE 96119
// sShovel := true ;
96111: LD_ADDR_EXP 161
96115: PUSH
96116: LD_INT 1
96118: ST_TO_ADDR
// if p3 = 25 then
96119: LD_VAR 0 3
96123: PUSH
96124: LD_INT 25
96126: EQUAL
96127: IFFALSE 96137
// sSheik := true ;
96129: LD_ADDR_EXP 162
96133: PUSH
96134: LD_INT 1
96136: ST_TO_ADDR
// if p3 = 26 then
96137: LD_VAR 0 3
96141: PUSH
96142: LD_INT 26
96144: EQUAL
96145: IFFALSE 96155
// sEarthquake := true ;
96147: LD_ADDR_EXP 164
96151: PUSH
96152: LD_INT 1
96154: ST_TO_ADDR
// if p3 = 27 then
96155: LD_VAR 0 3
96159: PUSH
96160: LD_INT 27
96162: EQUAL
96163: IFFALSE 96173
// sAI := true ;
96165: LD_ADDR_EXP 165
96169: PUSH
96170: LD_INT 1
96172: ST_TO_ADDR
// if p3 = 28 then
96173: LD_VAR 0 3
96177: PUSH
96178: LD_INT 28
96180: EQUAL
96181: IFFALSE 96191
// sCargo := true ;
96183: LD_ADDR_EXP 168
96187: PUSH
96188: LD_INT 1
96190: ST_TO_ADDR
// if p3 = 29 then
96191: LD_VAR 0 3
96195: PUSH
96196: LD_INT 29
96198: EQUAL
96199: IFFALSE 96209
// sDLaser := true ;
96201: LD_ADDR_EXP 169
96205: PUSH
96206: LD_INT 1
96208: ST_TO_ADDR
// if p3 = 30 then
96209: LD_VAR 0 3
96213: PUSH
96214: LD_INT 30
96216: EQUAL
96217: IFFALSE 96227
// sExchange := true ;
96219: LD_ADDR_EXP 170
96223: PUSH
96224: LD_INT 1
96226: ST_TO_ADDR
// if p3 = 31 then
96227: LD_VAR 0 3
96231: PUSH
96232: LD_INT 31
96234: EQUAL
96235: IFFALSE 96245
// sFac := true ;
96237: LD_ADDR_EXP 171
96241: PUSH
96242: LD_INT 1
96244: ST_TO_ADDR
// if p3 = 32 then
96245: LD_VAR 0 3
96249: PUSH
96250: LD_INT 32
96252: EQUAL
96253: IFFALSE 96263
// sPower := true ;
96255: LD_ADDR_EXP 172
96259: PUSH
96260: LD_INT 1
96262: ST_TO_ADDR
// if p3 = 33 then
96263: LD_VAR 0 3
96267: PUSH
96268: LD_INT 33
96270: EQUAL
96271: IFFALSE 96281
// sRandom := true ;
96273: LD_ADDR_EXP 173
96277: PUSH
96278: LD_INT 1
96280: ST_TO_ADDR
// if p3 = 34 then
96281: LD_VAR 0 3
96285: PUSH
96286: LD_INT 34
96288: EQUAL
96289: IFFALSE 96299
// sShield := true ;
96291: LD_ADDR_EXP 174
96295: PUSH
96296: LD_INT 1
96298: ST_TO_ADDR
// if p3 = 35 then
96299: LD_VAR 0 3
96303: PUSH
96304: LD_INT 35
96306: EQUAL
96307: IFFALSE 96317
// sTime := true ;
96309: LD_ADDR_EXP 175
96313: PUSH
96314: LD_INT 1
96316: ST_TO_ADDR
// if p3 = 36 then
96317: LD_VAR 0 3
96321: PUSH
96322: LD_INT 36
96324: EQUAL
96325: IFFALSE 96335
// sTools := true ;
96327: LD_ADDR_EXP 176
96331: PUSH
96332: LD_INT 1
96334: ST_TO_ADDR
// if p3 = 101 then
96335: LD_VAR 0 3
96339: PUSH
96340: LD_INT 101
96342: EQUAL
96343: IFFALSE 96353
// sSold := true ;
96345: LD_ADDR_EXP 141
96349: PUSH
96350: LD_INT 1
96352: ST_TO_ADDR
// if p3 = 102 then
96353: LD_VAR 0 3
96357: PUSH
96358: LD_INT 102
96360: EQUAL
96361: IFFALSE 96371
// sDiff := true ;
96363: LD_ADDR_EXP 142
96367: PUSH
96368: LD_INT 1
96370: ST_TO_ADDR
// if p3 = 103 then
96371: LD_VAR 0 3
96375: PUSH
96376: LD_INT 103
96378: EQUAL
96379: IFFALSE 96389
// sFog := true ;
96381: LD_ADDR_EXP 145
96385: PUSH
96386: LD_INT 1
96388: ST_TO_ADDR
// if p3 = 104 then
96389: LD_VAR 0 3
96393: PUSH
96394: LD_INT 104
96396: EQUAL
96397: IFFALSE 96407
// sReset := true ;
96399: LD_ADDR_EXP 146
96403: PUSH
96404: LD_INT 1
96406: ST_TO_ADDR
// if p3 = 105 then
96407: LD_VAR 0 3
96411: PUSH
96412: LD_INT 105
96414: EQUAL
96415: IFFALSE 96425
// sSun := true ;
96417: LD_ADDR_EXP 147
96421: PUSH
96422: LD_INT 1
96424: ST_TO_ADDR
// if p3 = 106 then
96425: LD_VAR 0 3
96429: PUSH
96430: LD_INT 106
96432: EQUAL
96433: IFFALSE 96443
// sTiger := true ;
96435: LD_ADDR_EXP 143
96439: PUSH
96440: LD_INT 1
96442: ST_TO_ADDR
// if p3 = 107 then
96443: LD_VAR 0 3
96447: PUSH
96448: LD_INT 107
96450: EQUAL
96451: IFFALSE 96461
// sBomb := true ;
96453: LD_ADDR_EXP 144
96457: PUSH
96458: LD_INT 1
96460: ST_TO_ADDR
// if p3 = 108 then
96461: LD_VAR 0 3
96465: PUSH
96466: LD_INT 108
96468: EQUAL
96469: IFFALSE 96479
// sWound := true ;
96471: LD_ADDR_EXP 152
96475: PUSH
96476: LD_INT 1
96478: ST_TO_ADDR
// if p3 = 109 then
96479: LD_VAR 0 3
96483: PUSH
96484: LD_INT 109
96486: EQUAL
96487: IFFALSE 96497
// sBetray := true ;
96489: LD_ADDR_EXP 156
96493: PUSH
96494: LD_INT 1
96496: ST_TO_ADDR
// if p3 = 110 then
96497: LD_VAR 0 3
96501: PUSH
96502: LD_INT 110
96504: EQUAL
96505: IFFALSE 96515
// sContamin := true ;
96507: LD_ADDR_EXP 157
96511: PUSH
96512: LD_INT 1
96514: ST_TO_ADDR
// if p3 = 111 then
96515: LD_VAR 0 3
96519: PUSH
96520: LD_INT 111
96522: EQUAL
96523: IFFALSE 96533
// sOil := true ;
96525: LD_ADDR_EXP 159
96529: PUSH
96530: LD_INT 1
96532: ST_TO_ADDR
// if p3 = 112 then
96533: LD_VAR 0 3
96537: PUSH
96538: LD_INT 112
96540: EQUAL
96541: IFFALSE 96551
// sStu := true ;
96543: LD_ADDR_EXP 163
96547: PUSH
96548: LD_INT 1
96550: ST_TO_ADDR
// if p3 = 113 then
96551: LD_VAR 0 3
96555: PUSH
96556: LD_INT 113
96558: EQUAL
96559: IFFALSE 96569
// sBazooka := true ;
96561: LD_ADDR_EXP 166
96565: PUSH
96566: LD_INT 1
96568: ST_TO_ADDR
// if p3 = 114 then
96569: LD_VAR 0 3
96573: PUSH
96574: LD_INT 114
96576: EQUAL
96577: IFFALSE 96587
// sMortar := true ;
96579: LD_ADDR_EXP 167
96583: PUSH
96584: LD_INT 1
96586: ST_TO_ADDR
// if p3 = 115 then
96587: LD_VAR 0 3
96591: PUSH
96592: LD_INT 115
96594: EQUAL
96595: IFFALSE 96605
// sRanger := true ;
96597: LD_ADDR_EXP 177
96601: PUSH
96602: LD_INT 1
96604: ST_TO_ADDR
// if p3 = 116 then
96605: LD_VAR 0 3
96609: PUSH
96610: LD_INT 116
96612: EQUAL
96613: IFFALSE 96623
// sComputer := true ;
96615: LD_ADDR_EXP 178
96619: PUSH
96620: LD_INT 1
96622: ST_TO_ADDR
// if p3 = 117 then
96623: LD_VAR 0 3
96627: PUSH
96628: LD_INT 117
96630: EQUAL
96631: IFFALSE 96641
// s30 := true ;
96633: LD_ADDR_EXP 179
96637: PUSH
96638: LD_INT 1
96640: ST_TO_ADDR
// if p3 = 118 then
96641: LD_VAR 0 3
96645: PUSH
96646: LD_INT 118
96648: EQUAL
96649: IFFALSE 96659
// s60 := true ;
96651: LD_ADDR_EXP 180
96655: PUSH
96656: LD_INT 1
96658: ST_TO_ADDR
// end ; if p2 = hack_mode then
96659: LD_VAR 0 2
96663: PUSH
96664: LD_INT 101
96666: EQUAL
96667: IFFALSE 96795
// begin case p3 of 1 :
96669: LD_VAR 0 3
96673: PUSH
96674: LD_INT 1
96676: DOUBLE
96677: EQUAL
96678: IFTRUE 96682
96680: GO 96689
96682: POP
// hHackUnlimitedResources ; 2 :
96683: CALL 108942 0 0
96687: GO 96795
96689: LD_INT 2
96691: DOUBLE
96692: EQUAL
96693: IFTRUE 96697
96695: GO 96704
96697: POP
// hHackSetLevel10 ; 3 :
96698: CALL 109075 0 0
96702: GO 96795
96704: LD_INT 3
96706: DOUBLE
96707: EQUAL
96708: IFTRUE 96712
96710: GO 96719
96712: POP
// hHackSetLevel10YourUnits ; 4 :
96713: CALL 109160 0 0
96717: GO 96795
96719: LD_INT 4
96721: DOUBLE
96722: EQUAL
96723: IFTRUE 96727
96725: GO 96734
96727: POP
// hHackInvincible ; 5 :
96728: CALL 109608 0 0
96732: GO 96795
96734: LD_INT 5
96736: DOUBLE
96737: EQUAL
96738: IFTRUE 96742
96740: GO 96749
96742: POP
// hHackInvisible ; 6 :
96743: CALL 109719 0 0
96747: GO 96795
96749: LD_INT 6
96751: DOUBLE
96752: EQUAL
96753: IFTRUE 96757
96755: GO 96764
96757: POP
// hHackChangeYourSide ; 7 :
96758: CALL 109776 0 0
96762: GO 96795
96764: LD_INT 7
96766: DOUBLE
96767: EQUAL
96768: IFTRUE 96772
96770: GO 96779
96772: POP
// hHackChangeUnitSide ; 8 :
96773: CALL 109818 0 0
96777: GO 96795
96779: LD_INT 8
96781: DOUBLE
96782: EQUAL
96783: IFTRUE 96787
96785: GO 96794
96787: POP
// hHackFog ; end ;
96788: CALL 109919 0 0
96792: GO 96795
96794: POP
// end ; if p2 = game_save_mode then
96795: LD_VAR 0 2
96799: PUSH
96800: LD_INT 102
96802: EQUAL
96803: IFFALSE 96858
// begin if p3 = 1 then
96805: LD_VAR 0 3
96809: PUSH
96810: LD_INT 1
96812: EQUAL
96813: IFFALSE 96825
// globalGameSaveCounter := p4 ;
96815: LD_ADDR_EXP 123
96819: PUSH
96820: LD_VAR 0 4
96824: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
96825: LD_VAR 0 3
96829: PUSH
96830: LD_INT 2
96832: EQUAL
96833: PUSH
96834: LD_EXP 123
96838: AND
96839: IFFALSE 96858
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96841: LD_STRING setGameSaveCounter(
96843: PUSH
96844: LD_EXP 123
96848: STR
96849: PUSH
96850: LD_STRING )
96852: STR
96853: PPUSH
96854: CALL_OW 559
// end ; end ;
96858: LD_VAR 0 7
96862: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
96863: LD_INT 0
96865: PPUSH
// streamModeActive := false ;
96866: LD_ADDR_EXP 124
96870: PUSH
96871: LD_INT 0
96873: ST_TO_ADDR
// normalCounter := 36 ;
96874: LD_ADDR_EXP 125
96878: PUSH
96879: LD_INT 36
96881: ST_TO_ADDR
// hardcoreCounter := 18 ;
96882: LD_ADDR_EXP 126
96886: PUSH
96887: LD_INT 18
96889: ST_TO_ADDR
// sRocket := false ;
96890: LD_ADDR_EXP 129
96894: PUSH
96895: LD_INT 0
96897: ST_TO_ADDR
// sSpeed := false ;
96898: LD_ADDR_EXP 128
96902: PUSH
96903: LD_INT 0
96905: ST_TO_ADDR
// sEngine := false ;
96906: LD_ADDR_EXP 130
96910: PUSH
96911: LD_INT 0
96913: ST_TO_ADDR
// sSpec := false ;
96914: LD_ADDR_EXP 127
96918: PUSH
96919: LD_INT 0
96921: ST_TO_ADDR
// sLevel := false ;
96922: LD_ADDR_EXP 131
96926: PUSH
96927: LD_INT 0
96929: ST_TO_ADDR
// sArmoury := false ;
96930: LD_ADDR_EXP 132
96934: PUSH
96935: LD_INT 0
96937: ST_TO_ADDR
// sRadar := false ;
96938: LD_ADDR_EXP 133
96942: PUSH
96943: LD_INT 0
96945: ST_TO_ADDR
// sBunker := false ;
96946: LD_ADDR_EXP 134
96950: PUSH
96951: LD_INT 0
96953: ST_TO_ADDR
// sHack := false ;
96954: LD_ADDR_EXP 135
96958: PUSH
96959: LD_INT 0
96961: ST_TO_ADDR
// sFire := false ;
96962: LD_ADDR_EXP 136
96966: PUSH
96967: LD_INT 0
96969: ST_TO_ADDR
// sRefresh := false ;
96970: LD_ADDR_EXP 137
96974: PUSH
96975: LD_INT 0
96977: ST_TO_ADDR
// sExp := false ;
96978: LD_ADDR_EXP 138
96982: PUSH
96983: LD_INT 0
96985: ST_TO_ADDR
// sDepot := false ;
96986: LD_ADDR_EXP 139
96990: PUSH
96991: LD_INT 0
96993: ST_TO_ADDR
// sFlag := false ;
96994: LD_ADDR_EXP 140
96998: PUSH
96999: LD_INT 0
97001: ST_TO_ADDR
// sKamikadze := false ;
97002: LD_ADDR_EXP 148
97006: PUSH
97007: LD_INT 0
97009: ST_TO_ADDR
// sTroll := false ;
97010: LD_ADDR_EXP 149
97014: PUSH
97015: LD_INT 0
97017: ST_TO_ADDR
// sSlow := false ;
97018: LD_ADDR_EXP 150
97022: PUSH
97023: LD_INT 0
97025: ST_TO_ADDR
// sLack := false ;
97026: LD_ADDR_EXP 151
97030: PUSH
97031: LD_INT 0
97033: ST_TO_ADDR
// sTank := false ;
97034: LD_ADDR_EXP 153
97038: PUSH
97039: LD_INT 0
97041: ST_TO_ADDR
// sRemote := false ;
97042: LD_ADDR_EXP 154
97046: PUSH
97047: LD_INT 0
97049: ST_TO_ADDR
// sPowell := false ;
97050: LD_ADDR_EXP 155
97054: PUSH
97055: LD_INT 0
97057: ST_TO_ADDR
// sTeleport := false ;
97058: LD_ADDR_EXP 158
97062: PUSH
97063: LD_INT 0
97065: ST_TO_ADDR
// sOilTower := false ;
97066: LD_ADDR_EXP 160
97070: PUSH
97071: LD_INT 0
97073: ST_TO_ADDR
// sShovel := false ;
97074: LD_ADDR_EXP 161
97078: PUSH
97079: LD_INT 0
97081: ST_TO_ADDR
// sSheik := false ;
97082: LD_ADDR_EXP 162
97086: PUSH
97087: LD_INT 0
97089: ST_TO_ADDR
// sEarthquake := false ;
97090: LD_ADDR_EXP 164
97094: PUSH
97095: LD_INT 0
97097: ST_TO_ADDR
// sAI := false ;
97098: LD_ADDR_EXP 165
97102: PUSH
97103: LD_INT 0
97105: ST_TO_ADDR
// sCargo := false ;
97106: LD_ADDR_EXP 168
97110: PUSH
97111: LD_INT 0
97113: ST_TO_ADDR
// sDLaser := false ;
97114: LD_ADDR_EXP 169
97118: PUSH
97119: LD_INT 0
97121: ST_TO_ADDR
// sExchange := false ;
97122: LD_ADDR_EXP 170
97126: PUSH
97127: LD_INT 0
97129: ST_TO_ADDR
// sFac := false ;
97130: LD_ADDR_EXP 171
97134: PUSH
97135: LD_INT 0
97137: ST_TO_ADDR
// sPower := false ;
97138: LD_ADDR_EXP 172
97142: PUSH
97143: LD_INT 0
97145: ST_TO_ADDR
// sRandom := false ;
97146: LD_ADDR_EXP 173
97150: PUSH
97151: LD_INT 0
97153: ST_TO_ADDR
// sShield := false ;
97154: LD_ADDR_EXP 174
97158: PUSH
97159: LD_INT 0
97161: ST_TO_ADDR
// sTime := false ;
97162: LD_ADDR_EXP 175
97166: PUSH
97167: LD_INT 0
97169: ST_TO_ADDR
// sTools := false ;
97170: LD_ADDR_EXP 176
97174: PUSH
97175: LD_INT 0
97177: ST_TO_ADDR
// sSold := false ;
97178: LD_ADDR_EXP 141
97182: PUSH
97183: LD_INT 0
97185: ST_TO_ADDR
// sDiff := false ;
97186: LD_ADDR_EXP 142
97190: PUSH
97191: LD_INT 0
97193: ST_TO_ADDR
// sFog := false ;
97194: LD_ADDR_EXP 145
97198: PUSH
97199: LD_INT 0
97201: ST_TO_ADDR
// sReset := false ;
97202: LD_ADDR_EXP 146
97206: PUSH
97207: LD_INT 0
97209: ST_TO_ADDR
// sSun := false ;
97210: LD_ADDR_EXP 147
97214: PUSH
97215: LD_INT 0
97217: ST_TO_ADDR
// sTiger := false ;
97218: LD_ADDR_EXP 143
97222: PUSH
97223: LD_INT 0
97225: ST_TO_ADDR
// sBomb := false ;
97226: LD_ADDR_EXP 144
97230: PUSH
97231: LD_INT 0
97233: ST_TO_ADDR
// sWound := false ;
97234: LD_ADDR_EXP 152
97238: PUSH
97239: LD_INT 0
97241: ST_TO_ADDR
// sBetray := false ;
97242: LD_ADDR_EXP 156
97246: PUSH
97247: LD_INT 0
97249: ST_TO_ADDR
// sContamin := false ;
97250: LD_ADDR_EXP 157
97254: PUSH
97255: LD_INT 0
97257: ST_TO_ADDR
// sOil := false ;
97258: LD_ADDR_EXP 159
97262: PUSH
97263: LD_INT 0
97265: ST_TO_ADDR
// sStu := false ;
97266: LD_ADDR_EXP 163
97270: PUSH
97271: LD_INT 0
97273: ST_TO_ADDR
// sBazooka := false ;
97274: LD_ADDR_EXP 166
97278: PUSH
97279: LD_INT 0
97281: ST_TO_ADDR
// sMortar := false ;
97282: LD_ADDR_EXP 167
97286: PUSH
97287: LD_INT 0
97289: ST_TO_ADDR
// sRanger := false ;
97290: LD_ADDR_EXP 177
97294: PUSH
97295: LD_INT 0
97297: ST_TO_ADDR
// sComputer := false ;
97298: LD_ADDR_EXP 178
97302: PUSH
97303: LD_INT 0
97305: ST_TO_ADDR
// s30 := false ;
97306: LD_ADDR_EXP 179
97310: PUSH
97311: LD_INT 0
97313: ST_TO_ADDR
// s60 := false ;
97314: LD_ADDR_EXP 180
97318: PUSH
97319: LD_INT 0
97321: ST_TO_ADDR
// end ;
97322: LD_VAR 0 1
97326: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
97327: LD_INT 0
97329: PPUSH
97330: PPUSH
97331: PPUSH
97332: PPUSH
97333: PPUSH
97334: PPUSH
97335: PPUSH
// result := [ ] ;
97336: LD_ADDR_VAR 0 2
97340: PUSH
97341: EMPTY
97342: ST_TO_ADDR
// if campaign_id = 1 then
97343: LD_OWVAR 69
97347: PUSH
97348: LD_INT 1
97350: EQUAL
97351: IFFALSE 100517
// begin case mission_number of 1 :
97353: LD_OWVAR 70
97357: PUSH
97358: LD_INT 1
97360: DOUBLE
97361: EQUAL
97362: IFTRUE 97366
97364: GO 97442
97366: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
97367: LD_ADDR_VAR 0 2
97371: PUSH
97372: LD_INT 2
97374: PUSH
97375: LD_INT 4
97377: PUSH
97378: LD_INT 11
97380: PUSH
97381: LD_INT 12
97383: PUSH
97384: LD_INT 15
97386: PUSH
97387: LD_INT 16
97389: PUSH
97390: LD_INT 22
97392: PUSH
97393: LD_INT 23
97395: PUSH
97396: LD_INT 26
97398: PUSH
97399: EMPTY
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: PUSH
97410: LD_INT 101
97412: PUSH
97413: LD_INT 102
97415: PUSH
97416: LD_INT 106
97418: PUSH
97419: LD_INT 116
97421: PUSH
97422: LD_INT 117
97424: PUSH
97425: LD_INT 118
97427: PUSH
97428: EMPTY
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: ST_TO_ADDR
97440: GO 100515
97442: LD_INT 2
97444: DOUBLE
97445: EQUAL
97446: IFTRUE 97450
97448: GO 97534
97450: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
97451: LD_ADDR_VAR 0 2
97455: PUSH
97456: LD_INT 2
97458: PUSH
97459: LD_INT 4
97461: PUSH
97462: LD_INT 11
97464: PUSH
97465: LD_INT 12
97467: PUSH
97468: LD_INT 15
97470: PUSH
97471: LD_INT 16
97473: PUSH
97474: LD_INT 22
97476: PUSH
97477: LD_INT 23
97479: PUSH
97480: LD_INT 26
97482: PUSH
97483: EMPTY
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: PUSH
97494: LD_INT 101
97496: PUSH
97497: LD_INT 102
97499: PUSH
97500: LD_INT 105
97502: PUSH
97503: LD_INT 106
97505: PUSH
97506: LD_INT 108
97508: PUSH
97509: LD_INT 116
97511: PUSH
97512: LD_INT 117
97514: PUSH
97515: LD_INT 118
97517: PUSH
97518: EMPTY
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: PUSH
97528: EMPTY
97529: LIST
97530: LIST
97531: ST_TO_ADDR
97532: GO 100515
97534: LD_INT 3
97536: DOUBLE
97537: EQUAL
97538: IFTRUE 97542
97540: GO 97630
97542: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
97543: LD_ADDR_VAR 0 2
97547: PUSH
97548: LD_INT 2
97550: PUSH
97551: LD_INT 4
97553: PUSH
97554: LD_INT 5
97556: PUSH
97557: LD_INT 11
97559: PUSH
97560: LD_INT 12
97562: PUSH
97563: LD_INT 15
97565: PUSH
97566: LD_INT 16
97568: PUSH
97569: LD_INT 22
97571: PUSH
97572: LD_INT 26
97574: PUSH
97575: LD_INT 36
97577: PUSH
97578: EMPTY
97579: LIST
97580: LIST
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: PUSH
97590: LD_INT 101
97592: PUSH
97593: LD_INT 102
97595: PUSH
97596: LD_INT 105
97598: PUSH
97599: LD_INT 106
97601: PUSH
97602: LD_INT 108
97604: PUSH
97605: LD_INT 116
97607: PUSH
97608: LD_INT 117
97610: PUSH
97611: LD_INT 118
97613: PUSH
97614: EMPTY
97615: LIST
97616: LIST
97617: LIST
97618: LIST
97619: LIST
97620: LIST
97621: LIST
97622: LIST
97623: PUSH
97624: EMPTY
97625: LIST
97626: LIST
97627: ST_TO_ADDR
97628: GO 100515
97630: LD_INT 4
97632: DOUBLE
97633: EQUAL
97634: IFTRUE 97638
97636: GO 97734
97638: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
97639: LD_ADDR_VAR 0 2
97643: PUSH
97644: LD_INT 2
97646: PUSH
97647: LD_INT 4
97649: PUSH
97650: LD_INT 5
97652: PUSH
97653: LD_INT 8
97655: PUSH
97656: LD_INT 11
97658: PUSH
97659: LD_INT 12
97661: PUSH
97662: LD_INT 15
97664: PUSH
97665: LD_INT 16
97667: PUSH
97668: LD_INT 22
97670: PUSH
97671: LD_INT 23
97673: PUSH
97674: LD_INT 26
97676: PUSH
97677: LD_INT 36
97679: PUSH
97680: EMPTY
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: PUSH
97694: LD_INT 101
97696: PUSH
97697: LD_INT 102
97699: PUSH
97700: LD_INT 105
97702: PUSH
97703: LD_INT 106
97705: PUSH
97706: LD_INT 108
97708: PUSH
97709: LD_INT 116
97711: PUSH
97712: LD_INT 117
97714: PUSH
97715: LD_INT 118
97717: PUSH
97718: EMPTY
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: LIST
97726: LIST
97727: PUSH
97728: EMPTY
97729: LIST
97730: LIST
97731: ST_TO_ADDR
97732: GO 100515
97734: LD_INT 5
97736: DOUBLE
97737: EQUAL
97738: IFTRUE 97742
97740: GO 97854
97742: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
97743: LD_ADDR_VAR 0 2
97747: PUSH
97748: LD_INT 2
97750: PUSH
97751: LD_INT 4
97753: PUSH
97754: LD_INT 5
97756: PUSH
97757: LD_INT 6
97759: PUSH
97760: LD_INT 8
97762: PUSH
97763: LD_INT 11
97765: PUSH
97766: LD_INT 12
97768: PUSH
97769: LD_INT 15
97771: PUSH
97772: LD_INT 16
97774: PUSH
97775: LD_INT 22
97777: PUSH
97778: LD_INT 23
97780: PUSH
97781: LD_INT 25
97783: PUSH
97784: LD_INT 26
97786: PUSH
97787: LD_INT 36
97789: PUSH
97790: EMPTY
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: PUSH
97806: LD_INT 101
97808: PUSH
97809: LD_INT 102
97811: PUSH
97812: LD_INT 105
97814: PUSH
97815: LD_INT 106
97817: PUSH
97818: LD_INT 108
97820: PUSH
97821: LD_INT 109
97823: PUSH
97824: LD_INT 112
97826: PUSH
97827: LD_INT 116
97829: PUSH
97830: LD_INT 117
97832: PUSH
97833: LD_INT 118
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: LIST
97840: LIST
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: LIST
97846: LIST
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: ST_TO_ADDR
97852: GO 100515
97854: LD_INT 6
97856: DOUBLE
97857: EQUAL
97858: IFTRUE 97862
97860: GO 97994
97862: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
97863: LD_ADDR_VAR 0 2
97867: PUSH
97868: LD_INT 2
97870: PUSH
97871: LD_INT 4
97873: PUSH
97874: LD_INT 5
97876: PUSH
97877: LD_INT 6
97879: PUSH
97880: LD_INT 8
97882: PUSH
97883: LD_INT 11
97885: PUSH
97886: LD_INT 12
97888: PUSH
97889: LD_INT 15
97891: PUSH
97892: LD_INT 16
97894: PUSH
97895: LD_INT 20
97897: PUSH
97898: LD_INT 21
97900: PUSH
97901: LD_INT 22
97903: PUSH
97904: LD_INT 23
97906: PUSH
97907: LD_INT 25
97909: PUSH
97910: LD_INT 26
97912: PUSH
97913: LD_INT 30
97915: PUSH
97916: LD_INT 31
97918: PUSH
97919: LD_INT 32
97921: PUSH
97922: LD_INT 36
97924: PUSH
97925: EMPTY
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: LIST
97943: LIST
97944: LIST
97945: PUSH
97946: LD_INT 101
97948: PUSH
97949: LD_INT 102
97951: PUSH
97952: LD_INT 105
97954: PUSH
97955: LD_INT 106
97957: PUSH
97958: LD_INT 108
97960: PUSH
97961: LD_INT 109
97963: PUSH
97964: LD_INT 112
97966: PUSH
97967: LD_INT 116
97969: PUSH
97970: LD_INT 117
97972: PUSH
97973: LD_INT 118
97975: PUSH
97976: EMPTY
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: PUSH
97988: EMPTY
97989: LIST
97990: LIST
97991: ST_TO_ADDR
97992: GO 100515
97994: LD_INT 7
97996: DOUBLE
97997: EQUAL
97998: IFTRUE 98002
98000: GO 98114
98002: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
98003: LD_ADDR_VAR 0 2
98007: PUSH
98008: LD_INT 2
98010: PUSH
98011: LD_INT 4
98013: PUSH
98014: LD_INT 5
98016: PUSH
98017: LD_INT 7
98019: PUSH
98020: LD_INT 11
98022: PUSH
98023: LD_INT 12
98025: PUSH
98026: LD_INT 15
98028: PUSH
98029: LD_INT 16
98031: PUSH
98032: LD_INT 20
98034: PUSH
98035: LD_INT 21
98037: PUSH
98038: LD_INT 22
98040: PUSH
98041: LD_INT 23
98043: PUSH
98044: LD_INT 25
98046: PUSH
98047: LD_INT 26
98049: PUSH
98050: EMPTY
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: LIST
98056: LIST
98057: LIST
98058: LIST
98059: LIST
98060: LIST
98061: LIST
98062: LIST
98063: LIST
98064: LIST
98065: PUSH
98066: LD_INT 101
98068: PUSH
98069: LD_INT 102
98071: PUSH
98072: LD_INT 103
98074: PUSH
98075: LD_INT 105
98077: PUSH
98078: LD_INT 106
98080: PUSH
98081: LD_INT 108
98083: PUSH
98084: LD_INT 112
98086: PUSH
98087: LD_INT 116
98089: PUSH
98090: LD_INT 117
98092: PUSH
98093: LD_INT 118
98095: PUSH
98096: EMPTY
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: ST_TO_ADDR
98112: GO 100515
98114: LD_INT 8
98116: DOUBLE
98117: EQUAL
98118: IFTRUE 98122
98120: GO 98262
98122: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
98123: LD_ADDR_VAR 0 2
98127: PUSH
98128: LD_INT 2
98130: PUSH
98131: LD_INT 4
98133: PUSH
98134: LD_INT 5
98136: PUSH
98137: LD_INT 6
98139: PUSH
98140: LD_INT 7
98142: PUSH
98143: LD_INT 8
98145: PUSH
98146: LD_INT 11
98148: PUSH
98149: LD_INT 12
98151: PUSH
98152: LD_INT 15
98154: PUSH
98155: LD_INT 16
98157: PUSH
98158: LD_INT 20
98160: PUSH
98161: LD_INT 21
98163: PUSH
98164: LD_INT 22
98166: PUSH
98167: LD_INT 23
98169: PUSH
98170: LD_INT 25
98172: PUSH
98173: LD_INT 26
98175: PUSH
98176: LD_INT 30
98178: PUSH
98179: LD_INT 31
98181: PUSH
98182: LD_INT 32
98184: PUSH
98185: LD_INT 36
98187: PUSH
98188: EMPTY
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: LIST
98202: LIST
98203: LIST
98204: LIST
98205: LIST
98206: LIST
98207: LIST
98208: LIST
98209: PUSH
98210: LD_INT 101
98212: PUSH
98213: LD_INT 102
98215: PUSH
98216: LD_INT 103
98218: PUSH
98219: LD_INT 105
98221: PUSH
98222: LD_INT 106
98224: PUSH
98225: LD_INT 108
98227: PUSH
98228: LD_INT 109
98230: PUSH
98231: LD_INT 112
98233: PUSH
98234: LD_INT 116
98236: PUSH
98237: LD_INT 117
98239: PUSH
98240: LD_INT 118
98242: PUSH
98243: EMPTY
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: PUSH
98256: EMPTY
98257: LIST
98258: LIST
98259: ST_TO_ADDR
98260: GO 100515
98262: LD_INT 9
98264: DOUBLE
98265: EQUAL
98266: IFTRUE 98270
98268: GO 98418
98270: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
98271: LD_ADDR_VAR 0 2
98275: PUSH
98276: LD_INT 2
98278: PUSH
98279: LD_INT 4
98281: PUSH
98282: LD_INT 5
98284: PUSH
98285: LD_INT 6
98287: PUSH
98288: LD_INT 7
98290: PUSH
98291: LD_INT 8
98293: PUSH
98294: LD_INT 11
98296: PUSH
98297: LD_INT 12
98299: PUSH
98300: LD_INT 15
98302: PUSH
98303: LD_INT 16
98305: PUSH
98306: LD_INT 20
98308: PUSH
98309: LD_INT 21
98311: PUSH
98312: LD_INT 22
98314: PUSH
98315: LD_INT 23
98317: PUSH
98318: LD_INT 25
98320: PUSH
98321: LD_INT 26
98323: PUSH
98324: LD_INT 28
98326: PUSH
98327: LD_INT 30
98329: PUSH
98330: LD_INT 31
98332: PUSH
98333: LD_INT 32
98335: PUSH
98336: LD_INT 36
98338: PUSH
98339: EMPTY
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: LIST
98360: LIST
98361: PUSH
98362: LD_INT 101
98364: PUSH
98365: LD_INT 102
98367: PUSH
98368: LD_INT 103
98370: PUSH
98371: LD_INT 105
98373: PUSH
98374: LD_INT 106
98376: PUSH
98377: LD_INT 108
98379: PUSH
98380: LD_INT 109
98382: PUSH
98383: LD_INT 112
98385: PUSH
98386: LD_INT 114
98388: PUSH
98389: LD_INT 116
98391: PUSH
98392: LD_INT 117
98394: PUSH
98395: LD_INT 118
98397: PUSH
98398: EMPTY
98399: LIST
98400: LIST
98401: LIST
98402: LIST
98403: LIST
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: LIST
98410: LIST
98411: PUSH
98412: EMPTY
98413: LIST
98414: LIST
98415: ST_TO_ADDR
98416: GO 100515
98418: LD_INT 10
98420: DOUBLE
98421: EQUAL
98422: IFTRUE 98426
98424: GO 98622
98426: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
98427: LD_ADDR_VAR 0 2
98431: PUSH
98432: LD_INT 2
98434: PUSH
98435: LD_INT 4
98437: PUSH
98438: LD_INT 5
98440: PUSH
98441: LD_INT 6
98443: PUSH
98444: LD_INT 7
98446: PUSH
98447: LD_INT 8
98449: PUSH
98450: LD_INT 9
98452: PUSH
98453: LD_INT 10
98455: PUSH
98456: LD_INT 11
98458: PUSH
98459: LD_INT 12
98461: PUSH
98462: LD_INT 13
98464: PUSH
98465: LD_INT 14
98467: PUSH
98468: LD_INT 15
98470: PUSH
98471: LD_INT 16
98473: PUSH
98474: LD_INT 17
98476: PUSH
98477: LD_INT 18
98479: PUSH
98480: LD_INT 19
98482: PUSH
98483: LD_INT 20
98485: PUSH
98486: LD_INT 21
98488: PUSH
98489: LD_INT 22
98491: PUSH
98492: LD_INT 23
98494: PUSH
98495: LD_INT 24
98497: PUSH
98498: LD_INT 25
98500: PUSH
98501: LD_INT 26
98503: PUSH
98504: LD_INT 28
98506: PUSH
98507: LD_INT 30
98509: PUSH
98510: LD_INT 31
98512: PUSH
98513: LD_INT 32
98515: PUSH
98516: LD_INT 36
98518: PUSH
98519: EMPTY
98520: LIST
98521: LIST
98522: LIST
98523: LIST
98524: LIST
98525: LIST
98526: LIST
98527: LIST
98528: LIST
98529: LIST
98530: LIST
98531: LIST
98532: LIST
98533: LIST
98534: LIST
98535: LIST
98536: LIST
98537: LIST
98538: LIST
98539: LIST
98540: LIST
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: PUSH
98550: LD_INT 101
98552: PUSH
98553: LD_INT 102
98555: PUSH
98556: LD_INT 103
98558: PUSH
98559: LD_INT 104
98561: PUSH
98562: LD_INT 105
98564: PUSH
98565: LD_INT 106
98567: PUSH
98568: LD_INT 107
98570: PUSH
98571: LD_INT 108
98573: PUSH
98574: LD_INT 109
98576: PUSH
98577: LD_INT 110
98579: PUSH
98580: LD_INT 111
98582: PUSH
98583: LD_INT 112
98585: PUSH
98586: LD_INT 114
98588: PUSH
98589: LD_INT 116
98591: PUSH
98592: LD_INT 117
98594: PUSH
98595: LD_INT 118
98597: PUSH
98598: EMPTY
98599: LIST
98600: LIST
98601: LIST
98602: LIST
98603: LIST
98604: LIST
98605: LIST
98606: LIST
98607: LIST
98608: LIST
98609: LIST
98610: LIST
98611: LIST
98612: LIST
98613: LIST
98614: LIST
98615: PUSH
98616: EMPTY
98617: LIST
98618: LIST
98619: ST_TO_ADDR
98620: GO 100515
98622: LD_INT 11
98624: DOUBLE
98625: EQUAL
98626: IFTRUE 98630
98628: GO 98834
98630: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
98631: LD_ADDR_VAR 0 2
98635: PUSH
98636: LD_INT 2
98638: PUSH
98639: LD_INT 3
98641: PUSH
98642: LD_INT 4
98644: PUSH
98645: LD_INT 5
98647: PUSH
98648: LD_INT 6
98650: PUSH
98651: LD_INT 7
98653: PUSH
98654: LD_INT 8
98656: PUSH
98657: LD_INT 9
98659: PUSH
98660: LD_INT 10
98662: PUSH
98663: LD_INT 11
98665: PUSH
98666: LD_INT 12
98668: PUSH
98669: LD_INT 13
98671: PUSH
98672: LD_INT 14
98674: PUSH
98675: LD_INT 15
98677: PUSH
98678: LD_INT 16
98680: PUSH
98681: LD_INT 17
98683: PUSH
98684: LD_INT 18
98686: PUSH
98687: LD_INT 19
98689: PUSH
98690: LD_INT 20
98692: PUSH
98693: LD_INT 21
98695: PUSH
98696: LD_INT 22
98698: PUSH
98699: LD_INT 23
98701: PUSH
98702: LD_INT 24
98704: PUSH
98705: LD_INT 25
98707: PUSH
98708: LD_INT 26
98710: PUSH
98711: LD_INT 28
98713: PUSH
98714: LD_INT 30
98716: PUSH
98717: LD_INT 31
98719: PUSH
98720: LD_INT 32
98722: PUSH
98723: LD_INT 34
98725: PUSH
98726: LD_INT 36
98728: PUSH
98729: EMPTY
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: PUSH
98762: LD_INT 101
98764: PUSH
98765: LD_INT 102
98767: PUSH
98768: LD_INT 103
98770: PUSH
98771: LD_INT 104
98773: PUSH
98774: LD_INT 105
98776: PUSH
98777: LD_INT 106
98779: PUSH
98780: LD_INT 107
98782: PUSH
98783: LD_INT 108
98785: PUSH
98786: LD_INT 109
98788: PUSH
98789: LD_INT 110
98791: PUSH
98792: LD_INT 111
98794: PUSH
98795: LD_INT 112
98797: PUSH
98798: LD_INT 114
98800: PUSH
98801: LD_INT 116
98803: PUSH
98804: LD_INT 117
98806: PUSH
98807: LD_INT 118
98809: PUSH
98810: EMPTY
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: PUSH
98828: EMPTY
98829: LIST
98830: LIST
98831: ST_TO_ADDR
98832: GO 100515
98834: LD_INT 12
98836: DOUBLE
98837: EQUAL
98838: IFTRUE 98842
98840: GO 99062
98842: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
98843: LD_ADDR_VAR 0 2
98847: PUSH
98848: LD_INT 1
98850: PUSH
98851: LD_INT 2
98853: PUSH
98854: LD_INT 3
98856: PUSH
98857: LD_INT 4
98859: PUSH
98860: LD_INT 5
98862: PUSH
98863: LD_INT 6
98865: PUSH
98866: LD_INT 7
98868: PUSH
98869: LD_INT 8
98871: PUSH
98872: LD_INT 9
98874: PUSH
98875: LD_INT 10
98877: PUSH
98878: LD_INT 11
98880: PUSH
98881: LD_INT 12
98883: PUSH
98884: LD_INT 13
98886: PUSH
98887: LD_INT 14
98889: PUSH
98890: LD_INT 15
98892: PUSH
98893: LD_INT 16
98895: PUSH
98896: LD_INT 17
98898: PUSH
98899: LD_INT 18
98901: PUSH
98902: LD_INT 19
98904: PUSH
98905: LD_INT 20
98907: PUSH
98908: LD_INT 21
98910: PUSH
98911: LD_INT 22
98913: PUSH
98914: LD_INT 23
98916: PUSH
98917: LD_INT 24
98919: PUSH
98920: LD_INT 25
98922: PUSH
98923: LD_INT 26
98925: PUSH
98926: LD_INT 27
98928: PUSH
98929: LD_INT 28
98931: PUSH
98932: LD_INT 30
98934: PUSH
98935: LD_INT 31
98937: PUSH
98938: LD_INT 32
98940: PUSH
98941: LD_INT 33
98943: PUSH
98944: LD_INT 34
98946: PUSH
98947: LD_INT 36
98949: PUSH
98950: EMPTY
98951: LIST
98952: LIST
98953: LIST
98954: LIST
98955: LIST
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: PUSH
98986: LD_INT 101
98988: PUSH
98989: LD_INT 102
98991: PUSH
98992: LD_INT 103
98994: PUSH
98995: LD_INT 104
98997: PUSH
98998: LD_INT 105
99000: PUSH
99001: LD_INT 106
99003: PUSH
99004: LD_INT 107
99006: PUSH
99007: LD_INT 108
99009: PUSH
99010: LD_INT 109
99012: PUSH
99013: LD_INT 110
99015: PUSH
99016: LD_INT 111
99018: PUSH
99019: LD_INT 112
99021: PUSH
99022: LD_INT 113
99024: PUSH
99025: LD_INT 114
99027: PUSH
99028: LD_INT 116
99030: PUSH
99031: LD_INT 117
99033: PUSH
99034: LD_INT 118
99036: PUSH
99037: EMPTY
99038: LIST
99039: LIST
99040: LIST
99041: LIST
99042: LIST
99043: LIST
99044: LIST
99045: LIST
99046: LIST
99047: LIST
99048: LIST
99049: LIST
99050: LIST
99051: LIST
99052: LIST
99053: LIST
99054: LIST
99055: PUSH
99056: EMPTY
99057: LIST
99058: LIST
99059: ST_TO_ADDR
99060: GO 100515
99062: LD_INT 13
99064: DOUBLE
99065: EQUAL
99066: IFTRUE 99070
99068: GO 99278
99070: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
99071: LD_ADDR_VAR 0 2
99075: PUSH
99076: LD_INT 1
99078: PUSH
99079: LD_INT 2
99081: PUSH
99082: LD_INT 3
99084: PUSH
99085: LD_INT 4
99087: PUSH
99088: LD_INT 5
99090: PUSH
99091: LD_INT 8
99093: PUSH
99094: LD_INT 9
99096: PUSH
99097: LD_INT 10
99099: PUSH
99100: LD_INT 11
99102: PUSH
99103: LD_INT 12
99105: PUSH
99106: LD_INT 14
99108: PUSH
99109: LD_INT 15
99111: PUSH
99112: LD_INT 16
99114: PUSH
99115: LD_INT 17
99117: PUSH
99118: LD_INT 18
99120: PUSH
99121: LD_INT 19
99123: PUSH
99124: LD_INT 20
99126: PUSH
99127: LD_INT 21
99129: PUSH
99130: LD_INT 22
99132: PUSH
99133: LD_INT 23
99135: PUSH
99136: LD_INT 24
99138: PUSH
99139: LD_INT 25
99141: PUSH
99142: LD_INT 26
99144: PUSH
99145: LD_INT 27
99147: PUSH
99148: LD_INT 28
99150: PUSH
99151: LD_INT 30
99153: PUSH
99154: LD_INT 31
99156: PUSH
99157: LD_INT 32
99159: PUSH
99160: LD_INT 33
99162: PUSH
99163: LD_INT 34
99165: PUSH
99166: LD_INT 36
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: LIST
99188: LIST
99189: LIST
99190: LIST
99191: LIST
99192: LIST
99193: LIST
99194: LIST
99195: LIST
99196: LIST
99197: LIST
99198: LIST
99199: LIST
99200: LIST
99201: PUSH
99202: LD_INT 101
99204: PUSH
99205: LD_INT 102
99207: PUSH
99208: LD_INT 103
99210: PUSH
99211: LD_INT 104
99213: PUSH
99214: LD_INT 105
99216: PUSH
99217: LD_INT 106
99219: PUSH
99220: LD_INT 107
99222: PUSH
99223: LD_INT 108
99225: PUSH
99226: LD_INT 109
99228: PUSH
99229: LD_INT 110
99231: PUSH
99232: LD_INT 111
99234: PUSH
99235: LD_INT 112
99237: PUSH
99238: LD_INT 113
99240: PUSH
99241: LD_INT 114
99243: PUSH
99244: LD_INT 116
99246: PUSH
99247: LD_INT 117
99249: PUSH
99250: LD_INT 118
99252: PUSH
99253: EMPTY
99254: LIST
99255: LIST
99256: LIST
99257: LIST
99258: LIST
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: PUSH
99272: EMPTY
99273: LIST
99274: LIST
99275: ST_TO_ADDR
99276: GO 100515
99278: LD_INT 14
99280: DOUBLE
99281: EQUAL
99282: IFTRUE 99286
99284: GO 99510
99286: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
99287: LD_ADDR_VAR 0 2
99291: PUSH
99292: LD_INT 1
99294: PUSH
99295: LD_INT 2
99297: PUSH
99298: LD_INT 3
99300: PUSH
99301: LD_INT 4
99303: PUSH
99304: LD_INT 5
99306: PUSH
99307: LD_INT 6
99309: PUSH
99310: LD_INT 7
99312: PUSH
99313: LD_INT 8
99315: PUSH
99316: LD_INT 9
99318: PUSH
99319: LD_INT 10
99321: PUSH
99322: LD_INT 11
99324: PUSH
99325: LD_INT 12
99327: PUSH
99328: LD_INT 13
99330: PUSH
99331: LD_INT 14
99333: PUSH
99334: LD_INT 15
99336: PUSH
99337: LD_INT 16
99339: PUSH
99340: LD_INT 17
99342: PUSH
99343: LD_INT 18
99345: PUSH
99346: LD_INT 19
99348: PUSH
99349: LD_INT 20
99351: PUSH
99352: LD_INT 21
99354: PUSH
99355: LD_INT 22
99357: PUSH
99358: LD_INT 23
99360: PUSH
99361: LD_INT 24
99363: PUSH
99364: LD_INT 25
99366: PUSH
99367: LD_INT 26
99369: PUSH
99370: LD_INT 27
99372: PUSH
99373: LD_INT 28
99375: PUSH
99376: LD_INT 29
99378: PUSH
99379: LD_INT 30
99381: PUSH
99382: LD_INT 31
99384: PUSH
99385: LD_INT 32
99387: PUSH
99388: LD_INT 33
99390: PUSH
99391: LD_INT 34
99393: PUSH
99394: LD_INT 36
99396: PUSH
99397: EMPTY
99398: LIST
99399: LIST
99400: LIST
99401: LIST
99402: LIST
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: LIST
99430: LIST
99431: LIST
99432: LIST
99433: PUSH
99434: LD_INT 101
99436: PUSH
99437: LD_INT 102
99439: PUSH
99440: LD_INT 103
99442: PUSH
99443: LD_INT 104
99445: PUSH
99446: LD_INT 105
99448: PUSH
99449: LD_INT 106
99451: PUSH
99452: LD_INT 107
99454: PUSH
99455: LD_INT 108
99457: PUSH
99458: LD_INT 109
99460: PUSH
99461: LD_INT 110
99463: PUSH
99464: LD_INT 111
99466: PUSH
99467: LD_INT 112
99469: PUSH
99470: LD_INT 113
99472: PUSH
99473: LD_INT 114
99475: PUSH
99476: LD_INT 116
99478: PUSH
99479: LD_INT 117
99481: PUSH
99482: LD_INT 118
99484: PUSH
99485: EMPTY
99486: LIST
99487: LIST
99488: LIST
99489: LIST
99490: LIST
99491: LIST
99492: LIST
99493: LIST
99494: LIST
99495: LIST
99496: LIST
99497: LIST
99498: LIST
99499: LIST
99500: LIST
99501: LIST
99502: LIST
99503: PUSH
99504: EMPTY
99505: LIST
99506: LIST
99507: ST_TO_ADDR
99508: GO 100515
99510: LD_INT 15
99512: DOUBLE
99513: EQUAL
99514: IFTRUE 99518
99516: GO 99742
99518: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
99519: LD_ADDR_VAR 0 2
99523: PUSH
99524: LD_INT 1
99526: PUSH
99527: LD_INT 2
99529: PUSH
99530: LD_INT 3
99532: PUSH
99533: LD_INT 4
99535: PUSH
99536: LD_INT 5
99538: PUSH
99539: LD_INT 6
99541: PUSH
99542: LD_INT 7
99544: PUSH
99545: LD_INT 8
99547: PUSH
99548: LD_INT 9
99550: PUSH
99551: LD_INT 10
99553: PUSH
99554: LD_INT 11
99556: PUSH
99557: LD_INT 12
99559: PUSH
99560: LD_INT 13
99562: PUSH
99563: LD_INT 14
99565: PUSH
99566: LD_INT 15
99568: PUSH
99569: LD_INT 16
99571: PUSH
99572: LD_INT 17
99574: PUSH
99575: LD_INT 18
99577: PUSH
99578: LD_INT 19
99580: PUSH
99581: LD_INT 20
99583: PUSH
99584: LD_INT 21
99586: PUSH
99587: LD_INT 22
99589: PUSH
99590: LD_INT 23
99592: PUSH
99593: LD_INT 24
99595: PUSH
99596: LD_INT 25
99598: PUSH
99599: LD_INT 26
99601: PUSH
99602: LD_INT 27
99604: PUSH
99605: LD_INT 28
99607: PUSH
99608: LD_INT 29
99610: PUSH
99611: LD_INT 30
99613: PUSH
99614: LD_INT 31
99616: PUSH
99617: LD_INT 32
99619: PUSH
99620: LD_INT 33
99622: PUSH
99623: LD_INT 34
99625: PUSH
99626: LD_INT 36
99628: PUSH
99629: EMPTY
99630: LIST
99631: LIST
99632: LIST
99633: LIST
99634: LIST
99635: LIST
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: LIST
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: LIST
99658: LIST
99659: LIST
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: PUSH
99666: LD_INT 101
99668: PUSH
99669: LD_INT 102
99671: PUSH
99672: LD_INT 103
99674: PUSH
99675: LD_INT 104
99677: PUSH
99678: LD_INT 105
99680: PUSH
99681: LD_INT 106
99683: PUSH
99684: LD_INT 107
99686: PUSH
99687: LD_INT 108
99689: PUSH
99690: LD_INT 109
99692: PUSH
99693: LD_INT 110
99695: PUSH
99696: LD_INT 111
99698: PUSH
99699: LD_INT 112
99701: PUSH
99702: LD_INT 113
99704: PUSH
99705: LD_INT 114
99707: PUSH
99708: LD_INT 116
99710: PUSH
99711: LD_INT 117
99713: PUSH
99714: LD_INT 118
99716: PUSH
99717: EMPTY
99718: LIST
99719: LIST
99720: LIST
99721: LIST
99722: LIST
99723: LIST
99724: LIST
99725: LIST
99726: LIST
99727: LIST
99728: LIST
99729: LIST
99730: LIST
99731: LIST
99732: LIST
99733: LIST
99734: LIST
99735: PUSH
99736: EMPTY
99737: LIST
99738: LIST
99739: ST_TO_ADDR
99740: GO 100515
99742: LD_INT 16
99744: DOUBLE
99745: EQUAL
99746: IFTRUE 99750
99748: GO 99886
99750: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
99751: LD_ADDR_VAR 0 2
99755: PUSH
99756: LD_INT 2
99758: PUSH
99759: LD_INT 4
99761: PUSH
99762: LD_INT 5
99764: PUSH
99765: LD_INT 7
99767: PUSH
99768: LD_INT 11
99770: PUSH
99771: LD_INT 12
99773: PUSH
99774: LD_INT 15
99776: PUSH
99777: LD_INT 16
99779: PUSH
99780: LD_INT 20
99782: PUSH
99783: LD_INT 21
99785: PUSH
99786: LD_INT 22
99788: PUSH
99789: LD_INT 23
99791: PUSH
99792: LD_INT 25
99794: PUSH
99795: LD_INT 26
99797: PUSH
99798: LD_INT 30
99800: PUSH
99801: LD_INT 31
99803: PUSH
99804: LD_INT 32
99806: PUSH
99807: LD_INT 33
99809: PUSH
99810: LD_INT 34
99812: PUSH
99813: EMPTY
99814: LIST
99815: LIST
99816: LIST
99817: LIST
99818: LIST
99819: LIST
99820: LIST
99821: LIST
99822: LIST
99823: LIST
99824: LIST
99825: LIST
99826: LIST
99827: LIST
99828: LIST
99829: LIST
99830: LIST
99831: LIST
99832: LIST
99833: PUSH
99834: LD_INT 101
99836: PUSH
99837: LD_INT 102
99839: PUSH
99840: LD_INT 103
99842: PUSH
99843: LD_INT 106
99845: PUSH
99846: LD_INT 108
99848: PUSH
99849: LD_INT 112
99851: PUSH
99852: LD_INT 113
99854: PUSH
99855: LD_INT 114
99857: PUSH
99858: LD_INT 116
99860: PUSH
99861: LD_INT 117
99863: PUSH
99864: LD_INT 118
99866: PUSH
99867: EMPTY
99868: LIST
99869: LIST
99870: LIST
99871: LIST
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: PUSH
99880: EMPTY
99881: LIST
99882: LIST
99883: ST_TO_ADDR
99884: GO 100515
99886: LD_INT 17
99888: DOUBLE
99889: EQUAL
99890: IFTRUE 99894
99892: GO 100118
99894: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99895: LD_ADDR_VAR 0 2
99899: PUSH
99900: LD_INT 1
99902: PUSH
99903: LD_INT 2
99905: PUSH
99906: LD_INT 3
99908: PUSH
99909: LD_INT 4
99911: PUSH
99912: LD_INT 5
99914: PUSH
99915: LD_INT 6
99917: PUSH
99918: LD_INT 7
99920: PUSH
99921: LD_INT 8
99923: PUSH
99924: LD_INT 9
99926: PUSH
99927: LD_INT 10
99929: PUSH
99930: LD_INT 11
99932: PUSH
99933: LD_INT 12
99935: PUSH
99936: LD_INT 13
99938: PUSH
99939: LD_INT 14
99941: PUSH
99942: LD_INT 15
99944: PUSH
99945: LD_INT 16
99947: PUSH
99948: LD_INT 17
99950: PUSH
99951: LD_INT 18
99953: PUSH
99954: LD_INT 19
99956: PUSH
99957: LD_INT 20
99959: PUSH
99960: LD_INT 21
99962: PUSH
99963: LD_INT 22
99965: PUSH
99966: LD_INT 23
99968: PUSH
99969: LD_INT 24
99971: PUSH
99972: LD_INT 25
99974: PUSH
99975: LD_INT 26
99977: PUSH
99978: LD_INT 27
99980: PUSH
99981: LD_INT 28
99983: PUSH
99984: LD_INT 29
99986: PUSH
99987: LD_INT 30
99989: PUSH
99990: LD_INT 31
99992: PUSH
99993: LD_INT 32
99995: PUSH
99996: LD_INT 33
99998: PUSH
99999: LD_INT 34
100001: PUSH
100002: LD_INT 36
100004: PUSH
100005: EMPTY
100006: LIST
100007: LIST
100008: LIST
100009: LIST
100010: LIST
100011: LIST
100012: LIST
100013: LIST
100014: LIST
100015: LIST
100016: LIST
100017: LIST
100018: LIST
100019: LIST
100020: LIST
100021: LIST
100022: LIST
100023: LIST
100024: LIST
100025: LIST
100026: LIST
100027: LIST
100028: LIST
100029: LIST
100030: LIST
100031: LIST
100032: LIST
100033: LIST
100034: LIST
100035: LIST
100036: LIST
100037: LIST
100038: LIST
100039: LIST
100040: LIST
100041: PUSH
100042: LD_INT 101
100044: PUSH
100045: LD_INT 102
100047: PUSH
100048: LD_INT 103
100050: PUSH
100051: LD_INT 104
100053: PUSH
100054: LD_INT 105
100056: PUSH
100057: LD_INT 106
100059: PUSH
100060: LD_INT 107
100062: PUSH
100063: LD_INT 108
100065: PUSH
100066: LD_INT 109
100068: PUSH
100069: LD_INT 110
100071: PUSH
100072: LD_INT 111
100074: PUSH
100075: LD_INT 112
100077: PUSH
100078: LD_INT 113
100080: PUSH
100081: LD_INT 114
100083: PUSH
100084: LD_INT 116
100086: PUSH
100087: LD_INT 117
100089: PUSH
100090: LD_INT 118
100092: PUSH
100093: EMPTY
100094: LIST
100095: LIST
100096: LIST
100097: LIST
100098: LIST
100099: LIST
100100: LIST
100101: LIST
100102: LIST
100103: LIST
100104: LIST
100105: LIST
100106: LIST
100107: LIST
100108: LIST
100109: LIST
100110: LIST
100111: PUSH
100112: EMPTY
100113: LIST
100114: LIST
100115: ST_TO_ADDR
100116: GO 100515
100118: LD_INT 18
100120: DOUBLE
100121: EQUAL
100122: IFTRUE 100126
100124: GO 100274
100126: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
100127: LD_ADDR_VAR 0 2
100131: PUSH
100132: LD_INT 2
100134: PUSH
100135: LD_INT 4
100137: PUSH
100138: LD_INT 5
100140: PUSH
100141: LD_INT 7
100143: PUSH
100144: LD_INT 11
100146: PUSH
100147: LD_INT 12
100149: PUSH
100150: LD_INT 15
100152: PUSH
100153: LD_INT 16
100155: PUSH
100156: LD_INT 20
100158: PUSH
100159: LD_INT 21
100161: PUSH
100162: LD_INT 22
100164: PUSH
100165: LD_INT 23
100167: PUSH
100168: LD_INT 25
100170: PUSH
100171: LD_INT 26
100173: PUSH
100174: LD_INT 30
100176: PUSH
100177: LD_INT 31
100179: PUSH
100180: LD_INT 32
100182: PUSH
100183: LD_INT 33
100185: PUSH
100186: LD_INT 34
100188: PUSH
100189: LD_INT 35
100191: PUSH
100192: LD_INT 36
100194: PUSH
100195: EMPTY
100196: LIST
100197: LIST
100198: LIST
100199: LIST
100200: LIST
100201: LIST
100202: LIST
100203: LIST
100204: LIST
100205: LIST
100206: LIST
100207: LIST
100208: LIST
100209: LIST
100210: LIST
100211: LIST
100212: LIST
100213: LIST
100214: LIST
100215: LIST
100216: LIST
100217: PUSH
100218: LD_INT 101
100220: PUSH
100221: LD_INT 102
100223: PUSH
100224: LD_INT 103
100226: PUSH
100227: LD_INT 106
100229: PUSH
100230: LD_INT 108
100232: PUSH
100233: LD_INT 112
100235: PUSH
100236: LD_INT 113
100238: PUSH
100239: LD_INT 114
100241: PUSH
100242: LD_INT 115
100244: PUSH
100245: LD_INT 116
100247: PUSH
100248: LD_INT 117
100250: PUSH
100251: LD_INT 118
100253: PUSH
100254: EMPTY
100255: LIST
100256: LIST
100257: LIST
100258: LIST
100259: LIST
100260: LIST
100261: LIST
100262: LIST
100263: LIST
100264: LIST
100265: LIST
100266: LIST
100267: PUSH
100268: EMPTY
100269: LIST
100270: LIST
100271: ST_TO_ADDR
100272: GO 100515
100274: LD_INT 19
100276: DOUBLE
100277: EQUAL
100278: IFTRUE 100282
100280: GO 100514
100282: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
100283: LD_ADDR_VAR 0 2
100287: PUSH
100288: LD_INT 1
100290: PUSH
100291: LD_INT 2
100293: PUSH
100294: LD_INT 3
100296: PUSH
100297: LD_INT 4
100299: PUSH
100300: LD_INT 5
100302: PUSH
100303: LD_INT 6
100305: PUSH
100306: LD_INT 7
100308: PUSH
100309: LD_INT 8
100311: PUSH
100312: LD_INT 9
100314: PUSH
100315: LD_INT 10
100317: PUSH
100318: LD_INT 11
100320: PUSH
100321: LD_INT 12
100323: PUSH
100324: LD_INT 13
100326: PUSH
100327: LD_INT 14
100329: PUSH
100330: LD_INT 15
100332: PUSH
100333: LD_INT 16
100335: PUSH
100336: LD_INT 17
100338: PUSH
100339: LD_INT 18
100341: PUSH
100342: LD_INT 19
100344: PUSH
100345: LD_INT 20
100347: PUSH
100348: LD_INT 21
100350: PUSH
100351: LD_INT 22
100353: PUSH
100354: LD_INT 23
100356: PUSH
100357: LD_INT 24
100359: PUSH
100360: LD_INT 25
100362: PUSH
100363: LD_INT 26
100365: PUSH
100366: LD_INT 27
100368: PUSH
100369: LD_INT 28
100371: PUSH
100372: LD_INT 29
100374: PUSH
100375: LD_INT 30
100377: PUSH
100378: LD_INT 31
100380: PUSH
100381: LD_INT 32
100383: PUSH
100384: LD_INT 33
100386: PUSH
100387: LD_INT 34
100389: PUSH
100390: LD_INT 35
100392: PUSH
100393: LD_INT 36
100395: PUSH
100396: EMPTY
100397: LIST
100398: LIST
100399: LIST
100400: LIST
100401: LIST
100402: LIST
100403: LIST
100404: LIST
100405: LIST
100406: LIST
100407: LIST
100408: LIST
100409: LIST
100410: LIST
100411: LIST
100412: LIST
100413: LIST
100414: LIST
100415: LIST
100416: LIST
100417: LIST
100418: LIST
100419: LIST
100420: LIST
100421: LIST
100422: LIST
100423: LIST
100424: LIST
100425: LIST
100426: LIST
100427: LIST
100428: LIST
100429: LIST
100430: LIST
100431: LIST
100432: LIST
100433: PUSH
100434: LD_INT 101
100436: PUSH
100437: LD_INT 102
100439: PUSH
100440: LD_INT 103
100442: PUSH
100443: LD_INT 104
100445: PUSH
100446: LD_INT 105
100448: PUSH
100449: LD_INT 106
100451: PUSH
100452: LD_INT 107
100454: PUSH
100455: LD_INT 108
100457: PUSH
100458: LD_INT 109
100460: PUSH
100461: LD_INT 110
100463: PUSH
100464: LD_INT 111
100466: PUSH
100467: LD_INT 112
100469: PUSH
100470: LD_INT 113
100472: PUSH
100473: LD_INT 114
100475: PUSH
100476: LD_INT 115
100478: PUSH
100479: LD_INT 116
100481: PUSH
100482: LD_INT 117
100484: PUSH
100485: LD_INT 118
100487: PUSH
100488: EMPTY
100489: LIST
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: LIST
100505: LIST
100506: LIST
100507: PUSH
100508: EMPTY
100509: LIST
100510: LIST
100511: ST_TO_ADDR
100512: GO 100515
100514: POP
// end else
100515: GO 100746
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
100517: LD_ADDR_VAR 0 2
100521: PUSH
100522: LD_INT 1
100524: PUSH
100525: LD_INT 2
100527: PUSH
100528: LD_INT 3
100530: PUSH
100531: LD_INT 4
100533: PUSH
100534: LD_INT 5
100536: PUSH
100537: LD_INT 6
100539: PUSH
100540: LD_INT 7
100542: PUSH
100543: LD_INT 8
100545: PUSH
100546: LD_INT 9
100548: PUSH
100549: LD_INT 10
100551: PUSH
100552: LD_INT 11
100554: PUSH
100555: LD_INT 12
100557: PUSH
100558: LD_INT 13
100560: PUSH
100561: LD_INT 14
100563: PUSH
100564: LD_INT 15
100566: PUSH
100567: LD_INT 16
100569: PUSH
100570: LD_INT 17
100572: PUSH
100573: LD_INT 18
100575: PUSH
100576: LD_INT 19
100578: PUSH
100579: LD_INT 20
100581: PUSH
100582: LD_INT 21
100584: PUSH
100585: LD_INT 22
100587: PUSH
100588: LD_INT 23
100590: PUSH
100591: LD_INT 24
100593: PUSH
100594: LD_INT 25
100596: PUSH
100597: LD_INT 26
100599: PUSH
100600: LD_INT 27
100602: PUSH
100603: LD_INT 28
100605: PUSH
100606: LD_INT 29
100608: PUSH
100609: LD_INT 30
100611: PUSH
100612: LD_INT 31
100614: PUSH
100615: LD_INT 32
100617: PUSH
100618: LD_INT 33
100620: PUSH
100621: LD_INT 34
100623: PUSH
100624: LD_INT 35
100626: PUSH
100627: LD_INT 36
100629: PUSH
100630: EMPTY
100631: LIST
100632: LIST
100633: LIST
100634: LIST
100635: LIST
100636: LIST
100637: LIST
100638: LIST
100639: LIST
100640: LIST
100641: LIST
100642: LIST
100643: LIST
100644: LIST
100645: LIST
100646: LIST
100647: LIST
100648: LIST
100649: LIST
100650: LIST
100651: LIST
100652: LIST
100653: LIST
100654: LIST
100655: LIST
100656: LIST
100657: LIST
100658: LIST
100659: LIST
100660: LIST
100661: LIST
100662: LIST
100663: LIST
100664: LIST
100665: LIST
100666: LIST
100667: PUSH
100668: LD_INT 101
100670: PUSH
100671: LD_INT 102
100673: PUSH
100674: LD_INT 103
100676: PUSH
100677: LD_INT 104
100679: PUSH
100680: LD_INT 105
100682: PUSH
100683: LD_INT 106
100685: PUSH
100686: LD_INT 107
100688: PUSH
100689: LD_INT 108
100691: PUSH
100692: LD_INT 109
100694: PUSH
100695: LD_INT 110
100697: PUSH
100698: LD_INT 111
100700: PUSH
100701: LD_INT 112
100703: PUSH
100704: LD_INT 113
100706: PUSH
100707: LD_INT 114
100709: PUSH
100710: LD_INT 115
100712: PUSH
100713: LD_INT 116
100715: PUSH
100716: LD_INT 117
100718: PUSH
100719: LD_INT 118
100721: PUSH
100722: EMPTY
100723: LIST
100724: LIST
100725: LIST
100726: LIST
100727: LIST
100728: LIST
100729: LIST
100730: LIST
100731: LIST
100732: LIST
100733: LIST
100734: LIST
100735: LIST
100736: LIST
100737: LIST
100738: LIST
100739: LIST
100740: LIST
100741: PUSH
100742: EMPTY
100743: LIST
100744: LIST
100745: ST_TO_ADDR
// if result then
100746: LD_VAR 0 2
100750: IFFALSE 101536
// begin normal :=  ;
100752: LD_ADDR_VAR 0 5
100756: PUSH
100757: LD_STRING 
100759: ST_TO_ADDR
// hardcore :=  ;
100760: LD_ADDR_VAR 0 6
100764: PUSH
100765: LD_STRING 
100767: ST_TO_ADDR
// active :=  ;
100768: LD_ADDR_VAR 0 7
100772: PUSH
100773: LD_STRING 
100775: ST_TO_ADDR
// for i = 1 to normalCounter do
100776: LD_ADDR_VAR 0 8
100780: PUSH
100781: DOUBLE
100782: LD_INT 1
100784: DEC
100785: ST_TO_ADDR
100786: LD_EXP 125
100790: PUSH
100791: FOR_TO
100792: IFFALSE 100893
// begin tmp := 0 ;
100794: LD_ADDR_VAR 0 3
100798: PUSH
100799: LD_STRING 0
100801: ST_TO_ADDR
// if result [ 1 ] then
100802: LD_VAR 0 2
100806: PUSH
100807: LD_INT 1
100809: ARRAY
100810: IFFALSE 100875
// if result [ 1 ] [ 1 ] = i then
100812: LD_VAR 0 2
100816: PUSH
100817: LD_INT 1
100819: ARRAY
100820: PUSH
100821: LD_INT 1
100823: ARRAY
100824: PUSH
100825: LD_VAR 0 8
100829: EQUAL
100830: IFFALSE 100875
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
100832: LD_ADDR_VAR 0 2
100836: PUSH
100837: LD_VAR 0 2
100841: PPUSH
100842: LD_INT 1
100844: PPUSH
100845: LD_VAR 0 2
100849: PUSH
100850: LD_INT 1
100852: ARRAY
100853: PPUSH
100854: LD_INT 1
100856: PPUSH
100857: CALL_OW 3
100861: PPUSH
100862: CALL_OW 1
100866: ST_TO_ADDR
// tmp := 1 ;
100867: LD_ADDR_VAR 0 3
100871: PUSH
100872: LD_STRING 1
100874: ST_TO_ADDR
// end ; normal := normal & tmp ;
100875: LD_ADDR_VAR 0 5
100879: PUSH
100880: LD_VAR 0 5
100884: PUSH
100885: LD_VAR 0 3
100889: STR
100890: ST_TO_ADDR
// end ;
100891: GO 100791
100893: POP
100894: POP
// for i = 1 to hardcoreCounter do
100895: LD_ADDR_VAR 0 8
100899: PUSH
100900: DOUBLE
100901: LD_INT 1
100903: DEC
100904: ST_TO_ADDR
100905: LD_EXP 126
100909: PUSH
100910: FOR_TO
100911: IFFALSE 101016
// begin tmp := 0 ;
100913: LD_ADDR_VAR 0 3
100917: PUSH
100918: LD_STRING 0
100920: ST_TO_ADDR
// if result [ 2 ] then
100921: LD_VAR 0 2
100925: PUSH
100926: LD_INT 2
100928: ARRAY
100929: IFFALSE 100998
// if result [ 2 ] [ 1 ] = 100 + i then
100931: LD_VAR 0 2
100935: PUSH
100936: LD_INT 2
100938: ARRAY
100939: PUSH
100940: LD_INT 1
100942: ARRAY
100943: PUSH
100944: LD_INT 100
100946: PUSH
100947: LD_VAR 0 8
100951: PLUS
100952: EQUAL
100953: IFFALSE 100998
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100955: LD_ADDR_VAR 0 2
100959: PUSH
100960: LD_VAR 0 2
100964: PPUSH
100965: LD_INT 2
100967: PPUSH
100968: LD_VAR 0 2
100972: PUSH
100973: LD_INT 2
100975: ARRAY
100976: PPUSH
100977: LD_INT 1
100979: PPUSH
100980: CALL_OW 3
100984: PPUSH
100985: CALL_OW 1
100989: ST_TO_ADDR
// tmp := 1 ;
100990: LD_ADDR_VAR 0 3
100994: PUSH
100995: LD_STRING 1
100997: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100998: LD_ADDR_VAR 0 6
101002: PUSH
101003: LD_VAR 0 6
101007: PUSH
101008: LD_VAR 0 3
101012: STR
101013: ST_TO_ADDR
// end ;
101014: GO 100910
101016: POP
101017: POP
// if isGameLoad then
101018: LD_VAR 0 1
101022: IFFALSE 101497
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
101024: LD_ADDR_VAR 0 4
101028: PUSH
101029: LD_EXP 129
101033: PUSH
101034: LD_EXP 128
101038: PUSH
101039: LD_EXP 130
101043: PUSH
101044: LD_EXP 127
101048: PUSH
101049: LD_EXP 131
101053: PUSH
101054: LD_EXP 132
101058: PUSH
101059: LD_EXP 133
101063: PUSH
101064: LD_EXP 134
101068: PUSH
101069: LD_EXP 135
101073: PUSH
101074: LD_EXP 136
101078: PUSH
101079: LD_EXP 137
101083: PUSH
101084: LD_EXP 138
101088: PUSH
101089: LD_EXP 139
101093: PUSH
101094: LD_EXP 140
101098: PUSH
101099: LD_EXP 148
101103: PUSH
101104: LD_EXP 149
101108: PUSH
101109: LD_EXP 150
101113: PUSH
101114: LD_EXP 151
101118: PUSH
101119: LD_EXP 153
101123: PUSH
101124: LD_EXP 154
101128: PUSH
101129: LD_EXP 155
101133: PUSH
101134: LD_EXP 158
101138: PUSH
101139: LD_EXP 160
101143: PUSH
101144: LD_EXP 161
101148: PUSH
101149: LD_EXP 162
101153: PUSH
101154: LD_EXP 164
101158: PUSH
101159: LD_EXP 165
101163: PUSH
101164: LD_EXP 168
101168: PUSH
101169: LD_EXP 169
101173: PUSH
101174: LD_EXP 170
101178: PUSH
101179: LD_EXP 171
101183: PUSH
101184: LD_EXP 172
101188: PUSH
101189: LD_EXP 173
101193: PUSH
101194: LD_EXP 174
101198: PUSH
101199: LD_EXP 175
101203: PUSH
101204: LD_EXP 176
101208: PUSH
101209: LD_EXP 141
101213: PUSH
101214: LD_EXP 142
101218: PUSH
101219: LD_EXP 145
101223: PUSH
101224: LD_EXP 146
101228: PUSH
101229: LD_EXP 147
101233: PUSH
101234: LD_EXP 143
101238: PUSH
101239: LD_EXP 144
101243: PUSH
101244: LD_EXP 152
101248: PUSH
101249: LD_EXP 156
101253: PUSH
101254: LD_EXP 157
101258: PUSH
101259: LD_EXP 159
101263: PUSH
101264: LD_EXP 163
101268: PUSH
101269: LD_EXP 166
101273: PUSH
101274: LD_EXP 167
101278: PUSH
101279: LD_EXP 177
101283: PUSH
101284: LD_EXP 178
101288: PUSH
101289: LD_EXP 179
101293: PUSH
101294: LD_EXP 180
101298: PUSH
101299: EMPTY
101300: LIST
101301: LIST
101302: LIST
101303: LIST
101304: LIST
101305: LIST
101306: LIST
101307: LIST
101308: LIST
101309: LIST
101310: LIST
101311: LIST
101312: LIST
101313: LIST
101314: LIST
101315: LIST
101316: LIST
101317: LIST
101318: LIST
101319: LIST
101320: LIST
101321: LIST
101322: LIST
101323: LIST
101324: LIST
101325: LIST
101326: LIST
101327: LIST
101328: LIST
101329: LIST
101330: LIST
101331: LIST
101332: LIST
101333: LIST
101334: LIST
101335: LIST
101336: LIST
101337: LIST
101338: LIST
101339: LIST
101340: LIST
101341: LIST
101342: LIST
101343: LIST
101344: LIST
101345: LIST
101346: LIST
101347: LIST
101348: LIST
101349: LIST
101350: LIST
101351: LIST
101352: LIST
101353: LIST
101354: ST_TO_ADDR
// tmp :=  ;
101355: LD_ADDR_VAR 0 3
101359: PUSH
101360: LD_STRING 
101362: ST_TO_ADDR
// for i = 1 to normalCounter do
101363: LD_ADDR_VAR 0 8
101367: PUSH
101368: DOUBLE
101369: LD_INT 1
101371: DEC
101372: ST_TO_ADDR
101373: LD_EXP 125
101377: PUSH
101378: FOR_TO
101379: IFFALSE 101415
// begin if flags [ i ] then
101381: LD_VAR 0 4
101385: PUSH
101386: LD_VAR 0 8
101390: ARRAY
101391: IFFALSE 101413
// tmp := tmp & i & ; ;
101393: LD_ADDR_VAR 0 3
101397: PUSH
101398: LD_VAR 0 3
101402: PUSH
101403: LD_VAR 0 8
101407: STR
101408: PUSH
101409: LD_STRING ;
101411: STR
101412: ST_TO_ADDR
// end ;
101413: GO 101378
101415: POP
101416: POP
// for i = 1 to hardcoreCounter do
101417: LD_ADDR_VAR 0 8
101421: PUSH
101422: DOUBLE
101423: LD_INT 1
101425: DEC
101426: ST_TO_ADDR
101427: LD_EXP 126
101431: PUSH
101432: FOR_TO
101433: IFFALSE 101479
// begin if flags [ normalCounter + i ] then
101435: LD_VAR 0 4
101439: PUSH
101440: LD_EXP 125
101444: PUSH
101445: LD_VAR 0 8
101449: PLUS
101450: ARRAY
101451: IFFALSE 101477
// tmp := tmp & ( 100 + i ) & ; ;
101453: LD_ADDR_VAR 0 3
101457: PUSH
101458: LD_VAR 0 3
101462: PUSH
101463: LD_INT 100
101465: PUSH
101466: LD_VAR 0 8
101470: PLUS
101471: STR
101472: PUSH
101473: LD_STRING ;
101475: STR
101476: ST_TO_ADDR
// end ;
101477: GO 101432
101479: POP
101480: POP
// if tmp then
101481: LD_VAR 0 3
101485: IFFALSE 101497
// active := tmp ;
101487: LD_ADDR_VAR 0 7
101491: PUSH
101492: LD_VAR 0 3
101496: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
101497: LD_STRING getStreamItemsFromMission("
101499: PUSH
101500: LD_VAR 0 5
101504: STR
101505: PUSH
101506: LD_STRING ","
101508: STR
101509: PUSH
101510: LD_VAR 0 6
101514: STR
101515: PUSH
101516: LD_STRING ","
101518: STR
101519: PUSH
101520: LD_VAR 0 7
101524: STR
101525: PUSH
101526: LD_STRING ")
101528: STR
101529: PPUSH
101530: CALL_OW 559
// end else
101534: GO 101543
// ToLua ( getStreamItemsFromMission("","","") ) ;
101536: LD_STRING getStreamItemsFromMission("","","")
101538: PPUSH
101539: CALL_OW 559
// end ;
101543: LD_VAR 0 2
101547: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
101548: LD_EXP 124
101552: PUSH
101553: LD_EXP 129
101557: AND
101558: IFFALSE 101682
101560: GO 101562
101562: DISABLE
101563: LD_INT 0
101565: PPUSH
101566: PPUSH
// begin enable ;
101567: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
101568: LD_ADDR_VAR 0 2
101572: PUSH
101573: LD_INT 22
101575: PUSH
101576: LD_OWVAR 2
101580: PUSH
101581: EMPTY
101582: LIST
101583: LIST
101584: PUSH
101585: LD_INT 2
101587: PUSH
101588: LD_INT 34
101590: PUSH
101591: LD_INT 7
101593: PUSH
101594: EMPTY
101595: LIST
101596: LIST
101597: PUSH
101598: LD_INT 34
101600: PUSH
101601: LD_INT 45
101603: PUSH
101604: EMPTY
101605: LIST
101606: LIST
101607: PUSH
101608: LD_INT 34
101610: PUSH
101611: LD_INT 28
101613: PUSH
101614: EMPTY
101615: LIST
101616: LIST
101617: PUSH
101618: LD_INT 34
101620: PUSH
101621: LD_INT 47
101623: PUSH
101624: EMPTY
101625: LIST
101626: LIST
101627: PUSH
101628: EMPTY
101629: LIST
101630: LIST
101631: LIST
101632: LIST
101633: LIST
101634: PUSH
101635: EMPTY
101636: LIST
101637: LIST
101638: PPUSH
101639: CALL_OW 69
101643: ST_TO_ADDR
// if not tmp then
101644: LD_VAR 0 2
101648: NOT
101649: IFFALSE 101653
// exit ;
101651: GO 101682
// for i in tmp do
101653: LD_ADDR_VAR 0 1
101657: PUSH
101658: LD_VAR 0 2
101662: PUSH
101663: FOR_IN
101664: IFFALSE 101680
// begin SetLives ( i , 0 ) ;
101666: LD_VAR 0 1
101670: PPUSH
101671: LD_INT 0
101673: PPUSH
101674: CALL_OW 234
// end ;
101678: GO 101663
101680: POP
101681: POP
// end ;
101682: PPOPN 2
101684: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
101685: LD_EXP 124
101689: PUSH
101690: LD_EXP 130
101694: AND
101695: IFFALSE 101779
101697: GO 101699
101699: DISABLE
101700: LD_INT 0
101702: PPUSH
101703: PPUSH
// begin enable ;
101704: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
101705: LD_ADDR_VAR 0 2
101709: PUSH
101710: LD_INT 22
101712: PUSH
101713: LD_OWVAR 2
101717: PUSH
101718: EMPTY
101719: LIST
101720: LIST
101721: PUSH
101722: LD_INT 32
101724: PUSH
101725: LD_INT 3
101727: PUSH
101728: EMPTY
101729: LIST
101730: LIST
101731: PUSH
101732: EMPTY
101733: LIST
101734: LIST
101735: PPUSH
101736: CALL_OW 69
101740: ST_TO_ADDR
// if not tmp then
101741: LD_VAR 0 2
101745: NOT
101746: IFFALSE 101750
// exit ;
101748: GO 101779
// for i in tmp do
101750: LD_ADDR_VAR 0 1
101754: PUSH
101755: LD_VAR 0 2
101759: PUSH
101760: FOR_IN
101761: IFFALSE 101777
// begin SetLives ( i , 0 ) ;
101763: LD_VAR 0 1
101767: PPUSH
101768: LD_INT 0
101770: PPUSH
101771: CALL_OW 234
// end ;
101775: GO 101760
101777: POP
101778: POP
// end ;
101779: PPOPN 2
101781: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
101782: LD_EXP 124
101786: PUSH
101787: LD_EXP 127
101791: AND
101792: IFFALSE 101885
101794: GO 101796
101796: DISABLE
101797: LD_INT 0
101799: PPUSH
// begin enable ;
101800: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
101801: LD_ADDR_VAR 0 1
101805: PUSH
101806: LD_INT 22
101808: PUSH
101809: LD_OWVAR 2
101813: PUSH
101814: EMPTY
101815: LIST
101816: LIST
101817: PUSH
101818: LD_INT 2
101820: PUSH
101821: LD_INT 25
101823: PUSH
101824: LD_INT 5
101826: PUSH
101827: EMPTY
101828: LIST
101829: LIST
101830: PUSH
101831: LD_INT 25
101833: PUSH
101834: LD_INT 9
101836: PUSH
101837: EMPTY
101838: LIST
101839: LIST
101840: PUSH
101841: LD_INT 25
101843: PUSH
101844: LD_INT 8
101846: PUSH
101847: EMPTY
101848: LIST
101849: LIST
101850: PUSH
101851: EMPTY
101852: LIST
101853: LIST
101854: LIST
101855: LIST
101856: PUSH
101857: EMPTY
101858: LIST
101859: LIST
101860: PPUSH
101861: CALL_OW 69
101865: PUSH
101866: FOR_IN
101867: IFFALSE 101883
// begin SetClass ( i , 1 ) ;
101869: LD_VAR 0 1
101873: PPUSH
101874: LD_INT 1
101876: PPUSH
101877: CALL_OW 336
// end ;
101881: GO 101866
101883: POP
101884: POP
// end ;
101885: PPOPN 1
101887: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101888: LD_EXP 124
101892: PUSH
101893: LD_EXP 128
101897: AND
101898: PUSH
101899: LD_OWVAR 65
101903: PUSH
101904: LD_INT 7
101906: LESS
101907: AND
101908: IFFALSE 101922
101910: GO 101912
101912: DISABLE
// begin enable ;
101913: ENABLE
// game_speed := 7 ;
101914: LD_ADDR_OWVAR 65
101918: PUSH
101919: LD_INT 7
101921: ST_TO_ADDR
// end ;
101922: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101923: LD_EXP 124
101927: PUSH
101928: LD_EXP 131
101932: AND
101933: IFFALSE 102135
101935: GO 101937
101937: DISABLE
101938: LD_INT 0
101940: PPUSH
101941: PPUSH
101942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101943: LD_ADDR_VAR 0 3
101947: PUSH
101948: LD_INT 81
101950: PUSH
101951: LD_OWVAR 2
101955: PUSH
101956: EMPTY
101957: LIST
101958: LIST
101959: PUSH
101960: LD_INT 21
101962: PUSH
101963: LD_INT 1
101965: PUSH
101966: EMPTY
101967: LIST
101968: LIST
101969: PUSH
101970: EMPTY
101971: LIST
101972: LIST
101973: PPUSH
101974: CALL_OW 69
101978: ST_TO_ADDR
// if not tmp then
101979: LD_VAR 0 3
101983: NOT
101984: IFFALSE 101988
// exit ;
101986: GO 102135
// if tmp > 5 then
101988: LD_VAR 0 3
101992: PUSH
101993: LD_INT 5
101995: GREATER
101996: IFFALSE 102008
// k := 5 else
101998: LD_ADDR_VAR 0 2
102002: PUSH
102003: LD_INT 5
102005: ST_TO_ADDR
102006: GO 102018
// k := tmp ;
102008: LD_ADDR_VAR 0 2
102012: PUSH
102013: LD_VAR 0 3
102017: ST_TO_ADDR
// for i := 1 to k do
102018: LD_ADDR_VAR 0 1
102022: PUSH
102023: DOUBLE
102024: LD_INT 1
102026: DEC
102027: ST_TO_ADDR
102028: LD_VAR 0 2
102032: PUSH
102033: FOR_TO
102034: IFFALSE 102133
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
102036: LD_VAR 0 3
102040: PUSH
102041: LD_VAR 0 1
102045: ARRAY
102046: PPUSH
102047: LD_VAR 0 1
102051: PUSH
102052: LD_INT 4
102054: MOD
102055: PUSH
102056: LD_INT 1
102058: PLUS
102059: PPUSH
102060: CALL_OW 259
102064: PUSH
102065: LD_INT 10
102067: LESS
102068: IFFALSE 102131
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
102070: LD_VAR 0 3
102074: PUSH
102075: LD_VAR 0 1
102079: ARRAY
102080: PPUSH
102081: LD_VAR 0 1
102085: PUSH
102086: LD_INT 4
102088: MOD
102089: PUSH
102090: LD_INT 1
102092: PLUS
102093: PPUSH
102094: LD_VAR 0 3
102098: PUSH
102099: LD_VAR 0 1
102103: ARRAY
102104: PPUSH
102105: LD_VAR 0 1
102109: PUSH
102110: LD_INT 4
102112: MOD
102113: PUSH
102114: LD_INT 1
102116: PLUS
102117: PPUSH
102118: CALL_OW 259
102122: PUSH
102123: LD_INT 1
102125: PLUS
102126: PPUSH
102127: CALL_OW 237
102131: GO 102033
102133: POP
102134: POP
// end ;
102135: PPOPN 3
102137: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
102138: LD_EXP 124
102142: PUSH
102143: LD_EXP 132
102147: AND
102148: IFFALSE 102168
102150: GO 102152
102152: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
102153: LD_INT 4
102155: PPUSH
102156: LD_OWVAR 2
102160: PPUSH
102161: LD_INT 0
102163: PPUSH
102164: CALL_OW 324
102168: END
// every 0 0$1 trigger StreamModeActive and sShovel do
102169: LD_EXP 124
102173: PUSH
102174: LD_EXP 161
102178: AND
102179: IFFALSE 102199
102181: GO 102183
102183: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
102184: LD_INT 19
102186: PPUSH
102187: LD_OWVAR 2
102191: PPUSH
102192: LD_INT 0
102194: PPUSH
102195: CALL_OW 324
102199: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
102200: LD_EXP 124
102204: PUSH
102205: LD_EXP 133
102209: AND
102210: IFFALSE 102312
102212: GO 102214
102214: DISABLE
102215: LD_INT 0
102217: PPUSH
102218: PPUSH
// begin enable ;
102219: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
102220: LD_ADDR_VAR 0 2
102224: PUSH
102225: LD_INT 22
102227: PUSH
102228: LD_OWVAR 2
102232: PUSH
102233: EMPTY
102234: LIST
102235: LIST
102236: PUSH
102237: LD_INT 2
102239: PUSH
102240: LD_INT 34
102242: PUSH
102243: LD_INT 11
102245: PUSH
102246: EMPTY
102247: LIST
102248: LIST
102249: PUSH
102250: LD_INT 34
102252: PUSH
102253: LD_INT 30
102255: PUSH
102256: EMPTY
102257: LIST
102258: LIST
102259: PUSH
102260: EMPTY
102261: LIST
102262: LIST
102263: LIST
102264: PUSH
102265: EMPTY
102266: LIST
102267: LIST
102268: PPUSH
102269: CALL_OW 69
102273: ST_TO_ADDR
// if not tmp then
102274: LD_VAR 0 2
102278: NOT
102279: IFFALSE 102283
// exit ;
102281: GO 102312
// for i in tmp do
102283: LD_ADDR_VAR 0 1
102287: PUSH
102288: LD_VAR 0 2
102292: PUSH
102293: FOR_IN
102294: IFFALSE 102310
// begin SetLives ( i , 0 ) ;
102296: LD_VAR 0 1
102300: PPUSH
102301: LD_INT 0
102303: PPUSH
102304: CALL_OW 234
// end ;
102308: GO 102293
102310: POP
102311: POP
// end ;
102312: PPOPN 2
102314: END
// every 0 0$1 trigger StreamModeActive and sBunker do
102315: LD_EXP 124
102319: PUSH
102320: LD_EXP 134
102324: AND
102325: IFFALSE 102345
102327: GO 102329
102329: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
102330: LD_INT 32
102332: PPUSH
102333: LD_OWVAR 2
102337: PPUSH
102338: LD_INT 0
102340: PPUSH
102341: CALL_OW 324
102345: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
102346: LD_EXP 124
102350: PUSH
102351: LD_EXP 135
102355: AND
102356: IFFALSE 102537
102358: GO 102360
102360: DISABLE
102361: LD_INT 0
102363: PPUSH
102364: PPUSH
102365: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
102366: LD_ADDR_VAR 0 2
102370: PUSH
102371: LD_INT 22
102373: PUSH
102374: LD_OWVAR 2
102378: PUSH
102379: EMPTY
102380: LIST
102381: LIST
102382: PUSH
102383: LD_INT 33
102385: PUSH
102386: LD_INT 3
102388: PUSH
102389: EMPTY
102390: LIST
102391: LIST
102392: PUSH
102393: EMPTY
102394: LIST
102395: LIST
102396: PPUSH
102397: CALL_OW 69
102401: ST_TO_ADDR
// if not tmp then
102402: LD_VAR 0 2
102406: NOT
102407: IFFALSE 102411
// exit ;
102409: GO 102537
// side := 0 ;
102411: LD_ADDR_VAR 0 3
102415: PUSH
102416: LD_INT 0
102418: ST_TO_ADDR
// for i := 1 to 8 do
102419: LD_ADDR_VAR 0 1
102423: PUSH
102424: DOUBLE
102425: LD_INT 1
102427: DEC
102428: ST_TO_ADDR
102429: LD_INT 8
102431: PUSH
102432: FOR_TO
102433: IFFALSE 102481
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
102435: LD_OWVAR 2
102439: PUSH
102440: LD_VAR 0 1
102444: NONEQUAL
102445: PUSH
102446: LD_OWVAR 2
102450: PPUSH
102451: LD_VAR 0 1
102455: PPUSH
102456: CALL_OW 81
102460: PUSH
102461: LD_INT 2
102463: EQUAL
102464: AND
102465: IFFALSE 102479
// begin side := i ;
102467: LD_ADDR_VAR 0 3
102471: PUSH
102472: LD_VAR 0 1
102476: ST_TO_ADDR
// break ;
102477: GO 102481
// end ;
102479: GO 102432
102481: POP
102482: POP
// if not side then
102483: LD_VAR 0 3
102487: NOT
102488: IFFALSE 102492
// exit ;
102490: GO 102537
// for i := 1 to tmp do
102492: LD_ADDR_VAR 0 1
102496: PUSH
102497: DOUBLE
102498: LD_INT 1
102500: DEC
102501: ST_TO_ADDR
102502: LD_VAR 0 2
102506: PUSH
102507: FOR_TO
102508: IFFALSE 102535
// if Prob ( 60 ) then
102510: LD_INT 60
102512: PPUSH
102513: CALL_OW 13
102517: IFFALSE 102533
// SetSide ( i , side ) ;
102519: LD_VAR 0 1
102523: PPUSH
102524: LD_VAR 0 3
102528: PPUSH
102529: CALL_OW 235
102533: GO 102507
102535: POP
102536: POP
// end ;
102537: PPOPN 3
102539: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
102540: LD_EXP 124
102544: PUSH
102545: LD_EXP 137
102549: AND
102550: IFFALSE 102669
102552: GO 102554
102554: DISABLE
102555: LD_INT 0
102557: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
102558: LD_ADDR_VAR 0 1
102562: PUSH
102563: LD_INT 22
102565: PUSH
102566: LD_OWVAR 2
102570: PUSH
102571: EMPTY
102572: LIST
102573: LIST
102574: PUSH
102575: LD_INT 21
102577: PUSH
102578: LD_INT 1
102580: PUSH
102581: EMPTY
102582: LIST
102583: LIST
102584: PUSH
102585: LD_INT 3
102587: PUSH
102588: LD_INT 23
102590: PUSH
102591: LD_INT 0
102593: PUSH
102594: EMPTY
102595: LIST
102596: LIST
102597: PUSH
102598: EMPTY
102599: LIST
102600: LIST
102601: PUSH
102602: EMPTY
102603: LIST
102604: LIST
102605: LIST
102606: PPUSH
102607: CALL_OW 69
102611: PUSH
102612: FOR_IN
102613: IFFALSE 102667
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
102615: LD_VAR 0 1
102619: PPUSH
102620: CALL_OW 257
102624: PUSH
102625: LD_INT 1
102627: PUSH
102628: LD_INT 2
102630: PUSH
102631: LD_INT 3
102633: PUSH
102634: LD_INT 4
102636: PUSH
102637: EMPTY
102638: LIST
102639: LIST
102640: LIST
102641: LIST
102642: IN
102643: IFFALSE 102665
// SetClass ( un , rand ( 1 , 4 ) ) ;
102645: LD_VAR 0 1
102649: PPUSH
102650: LD_INT 1
102652: PPUSH
102653: LD_INT 4
102655: PPUSH
102656: CALL_OW 12
102660: PPUSH
102661: CALL_OW 336
102665: GO 102612
102667: POP
102668: POP
// end ;
102669: PPOPN 1
102671: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
102672: LD_EXP 124
102676: PUSH
102677: LD_EXP 136
102681: AND
102682: IFFALSE 102761
102684: GO 102686
102686: DISABLE
102687: LD_INT 0
102689: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102690: LD_ADDR_VAR 0 1
102694: PUSH
102695: LD_INT 22
102697: PUSH
102698: LD_OWVAR 2
102702: PUSH
102703: EMPTY
102704: LIST
102705: LIST
102706: PUSH
102707: LD_INT 21
102709: PUSH
102710: LD_INT 3
102712: PUSH
102713: EMPTY
102714: LIST
102715: LIST
102716: PUSH
102717: EMPTY
102718: LIST
102719: LIST
102720: PPUSH
102721: CALL_OW 69
102725: ST_TO_ADDR
// if not tmp then
102726: LD_VAR 0 1
102730: NOT
102731: IFFALSE 102735
// exit ;
102733: GO 102761
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
102735: LD_VAR 0 1
102739: PUSH
102740: LD_INT 1
102742: PPUSH
102743: LD_VAR 0 1
102747: PPUSH
102748: CALL_OW 12
102752: ARRAY
102753: PPUSH
102754: LD_INT 100
102756: PPUSH
102757: CALL_OW 234
// end ;
102761: PPOPN 1
102763: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
102764: LD_EXP 124
102768: PUSH
102769: LD_EXP 138
102773: AND
102774: IFFALSE 102872
102776: GO 102778
102778: DISABLE
102779: LD_INT 0
102781: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102782: LD_ADDR_VAR 0 1
102786: PUSH
102787: LD_INT 22
102789: PUSH
102790: LD_OWVAR 2
102794: PUSH
102795: EMPTY
102796: LIST
102797: LIST
102798: PUSH
102799: LD_INT 21
102801: PUSH
102802: LD_INT 1
102804: PUSH
102805: EMPTY
102806: LIST
102807: LIST
102808: PUSH
102809: EMPTY
102810: LIST
102811: LIST
102812: PPUSH
102813: CALL_OW 69
102817: ST_TO_ADDR
// if not tmp then
102818: LD_VAR 0 1
102822: NOT
102823: IFFALSE 102827
// exit ;
102825: GO 102872
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
102827: LD_VAR 0 1
102831: PUSH
102832: LD_INT 1
102834: PPUSH
102835: LD_VAR 0 1
102839: PPUSH
102840: CALL_OW 12
102844: ARRAY
102845: PPUSH
102846: LD_INT 1
102848: PPUSH
102849: LD_INT 4
102851: PPUSH
102852: CALL_OW 12
102856: PPUSH
102857: LD_INT 3000
102859: PPUSH
102860: LD_INT 9000
102862: PPUSH
102863: CALL_OW 12
102867: PPUSH
102868: CALL_OW 492
// end ;
102872: PPOPN 1
102874: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102875: LD_EXP 124
102879: PUSH
102880: LD_EXP 139
102884: AND
102885: IFFALSE 102905
102887: GO 102889
102889: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102890: LD_INT 1
102892: PPUSH
102893: LD_OWVAR 2
102897: PPUSH
102898: LD_INT 0
102900: PPUSH
102901: CALL_OW 324
102905: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102906: LD_EXP 124
102910: PUSH
102911: LD_EXP 140
102915: AND
102916: IFFALSE 102999
102918: GO 102920
102920: DISABLE
102921: LD_INT 0
102923: PPUSH
102924: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102925: LD_ADDR_VAR 0 2
102929: PUSH
102930: LD_INT 22
102932: PUSH
102933: LD_OWVAR 2
102937: PUSH
102938: EMPTY
102939: LIST
102940: LIST
102941: PUSH
102942: LD_INT 21
102944: PUSH
102945: LD_INT 3
102947: PUSH
102948: EMPTY
102949: LIST
102950: LIST
102951: PUSH
102952: EMPTY
102953: LIST
102954: LIST
102955: PPUSH
102956: CALL_OW 69
102960: ST_TO_ADDR
// if not tmp then
102961: LD_VAR 0 2
102965: NOT
102966: IFFALSE 102970
// exit ;
102968: GO 102999
// for i in tmp do
102970: LD_ADDR_VAR 0 1
102974: PUSH
102975: LD_VAR 0 2
102979: PUSH
102980: FOR_IN
102981: IFFALSE 102997
// SetBLevel ( i , 10 ) ;
102983: LD_VAR 0 1
102987: PPUSH
102988: LD_INT 10
102990: PPUSH
102991: CALL_OW 241
102995: GO 102980
102997: POP
102998: POP
// end ;
102999: PPOPN 2
103001: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
103002: LD_EXP 124
103006: PUSH
103007: LD_EXP 141
103011: AND
103012: IFFALSE 103123
103014: GO 103016
103016: DISABLE
103017: LD_INT 0
103019: PPUSH
103020: PPUSH
103021: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103022: LD_ADDR_VAR 0 3
103026: PUSH
103027: LD_INT 22
103029: PUSH
103030: LD_OWVAR 2
103034: PUSH
103035: EMPTY
103036: LIST
103037: LIST
103038: PUSH
103039: LD_INT 25
103041: PUSH
103042: LD_INT 1
103044: PUSH
103045: EMPTY
103046: LIST
103047: LIST
103048: PUSH
103049: EMPTY
103050: LIST
103051: LIST
103052: PPUSH
103053: CALL_OW 69
103057: ST_TO_ADDR
// if not tmp then
103058: LD_VAR 0 3
103062: NOT
103063: IFFALSE 103067
// exit ;
103065: GO 103123
// un := tmp [ rand ( 1 , tmp ) ] ;
103067: LD_ADDR_VAR 0 2
103071: PUSH
103072: LD_VAR 0 3
103076: PUSH
103077: LD_INT 1
103079: PPUSH
103080: LD_VAR 0 3
103084: PPUSH
103085: CALL_OW 12
103089: ARRAY
103090: ST_TO_ADDR
// if Crawls ( un ) then
103091: LD_VAR 0 2
103095: PPUSH
103096: CALL_OW 318
103100: IFFALSE 103111
// ComWalk ( un ) ;
103102: LD_VAR 0 2
103106: PPUSH
103107: CALL_OW 138
// SetClass ( un , class_sniper ) ;
103111: LD_VAR 0 2
103115: PPUSH
103116: LD_INT 5
103118: PPUSH
103119: CALL_OW 336
// end ;
103123: PPOPN 3
103125: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
103126: LD_EXP 124
103130: PUSH
103131: LD_EXP 142
103135: AND
103136: PUSH
103137: LD_OWVAR 67
103141: PUSH
103142: LD_INT 4
103144: LESS
103145: AND
103146: IFFALSE 103165
103148: GO 103150
103150: DISABLE
// begin Difficulty := Difficulty + 1 ;
103151: LD_ADDR_OWVAR 67
103155: PUSH
103156: LD_OWVAR 67
103160: PUSH
103161: LD_INT 1
103163: PLUS
103164: ST_TO_ADDR
// end ;
103165: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
103166: LD_EXP 124
103170: PUSH
103171: LD_EXP 143
103175: AND
103176: IFFALSE 103279
103178: GO 103180
103180: DISABLE
103181: LD_INT 0
103183: PPUSH
// begin for i := 1 to 5 do
103184: LD_ADDR_VAR 0 1
103188: PUSH
103189: DOUBLE
103190: LD_INT 1
103192: DEC
103193: ST_TO_ADDR
103194: LD_INT 5
103196: PUSH
103197: FOR_TO
103198: IFFALSE 103277
// begin uc_nation := nation_nature ;
103200: LD_ADDR_OWVAR 21
103204: PUSH
103205: LD_INT 0
103207: ST_TO_ADDR
// uc_side := 0 ;
103208: LD_ADDR_OWVAR 20
103212: PUSH
103213: LD_INT 0
103215: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
103216: LD_ADDR_OWVAR 29
103220: PUSH
103221: LD_INT 12
103223: PUSH
103224: LD_INT 12
103226: PUSH
103227: EMPTY
103228: LIST
103229: LIST
103230: ST_TO_ADDR
// hc_agressivity := 20 ;
103231: LD_ADDR_OWVAR 35
103235: PUSH
103236: LD_INT 20
103238: ST_TO_ADDR
// hc_class := class_tiger ;
103239: LD_ADDR_OWVAR 28
103243: PUSH
103244: LD_INT 14
103246: ST_TO_ADDR
// hc_gallery :=  ;
103247: LD_ADDR_OWVAR 33
103251: PUSH
103252: LD_STRING 
103254: ST_TO_ADDR
// hc_name :=  ;
103255: LD_ADDR_OWVAR 26
103259: PUSH
103260: LD_STRING 
103262: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
103263: CALL_OW 44
103267: PPUSH
103268: LD_INT 0
103270: PPUSH
103271: CALL_OW 51
// end ;
103275: GO 103197
103277: POP
103278: POP
// end ;
103279: PPOPN 1
103281: END
// every 0 0$1 trigger StreamModeActive and sBomb do
103282: LD_EXP 124
103286: PUSH
103287: LD_EXP 144
103291: AND
103292: IFFALSE 103301
103294: GO 103296
103296: DISABLE
// StreamSibBomb ;
103297: CALL 103302 0 0
103301: END
// export function StreamSibBomb ; var i , x , y ; begin
103302: LD_INT 0
103304: PPUSH
103305: PPUSH
103306: PPUSH
103307: PPUSH
// result := false ;
103308: LD_ADDR_VAR 0 1
103312: PUSH
103313: LD_INT 0
103315: ST_TO_ADDR
// for i := 1 to 16 do
103316: LD_ADDR_VAR 0 2
103320: PUSH
103321: DOUBLE
103322: LD_INT 1
103324: DEC
103325: ST_TO_ADDR
103326: LD_INT 16
103328: PUSH
103329: FOR_TO
103330: IFFALSE 103529
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
103332: LD_ADDR_VAR 0 3
103336: PUSH
103337: LD_INT 10
103339: PUSH
103340: LD_INT 20
103342: PUSH
103343: LD_INT 30
103345: PUSH
103346: LD_INT 40
103348: PUSH
103349: LD_INT 50
103351: PUSH
103352: LD_INT 60
103354: PUSH
103355: LD_INT 70
103357: PUSH
103358: LD_INT 80
103360: PUSH
103361: LD_INT 90
103363: PUSH
103364: LD_INT 100
103366: PUSH
103367: LD_INT 110
103369: PUSH
103370: LD_INT 120
103372: PUSH
103373: LD_INT 130
103375: PUSH
103376: LD_INT 140
103378: PUSH
103379: LD_INT 150
103381: PUSH
103382: EMPTY
103383: LIST
103384: LIST
103385: LIST
103386: LIST
103387: LIST
103388: LIST
103389: LIST
103390: LIST
103391: LIST
103392: LIST
103393: LIST
103394: LIST
103395: LIST
103396: LIST
103397: LIST
103398: PUSH
103399: LD_INT 1
103401: PPUSH
103402: LD_INT 15
103404: PPUSH
103405: CALL_OW 12
103409: ARRAY
103410: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
103411: LD_ADDR_VAR 0 4
103415: PUSH
103416: LD_INT 10
103418: PUSH
103419: LD_INT 20
103421: PUSH
103422: LD_INT 30
103424: PUSH
103425: LD_INT 40
103427: PUSH
103428: LD_INT 50
103430: PUSH
103431: LD_INT 60
103433: PUSH
103434: LD_INT 70
103436: PUSH
103437: LD_INT 80
103439: PUSH
103440: LD_INT 90
103442: PUSH
103443: LD_INT 100
103445: PUSH
103446: LD_INT 110
103448: PUSH
103449: LD_INT 120
103451: PUSH
103452: LD_INT 130
103454: PUSH
103455: LD_INT 140
103457: PUSH
103458: LD_INT 150
103460: PUSH
103461: EMPTY
103462: LIST
103463: LIST
103464: LIST
103465: LIST
103466: LIST
103467: LIST
103468: LIST
103469: LIST
103470: LIST
103471: LIST
103472: LIST
103473: LIST
103474: LIST
103475: LIST
103476: LIST
103477: PUSH
103478: LD_INT 1
103480: PPUSH
103481: LD_INT 15
103483: PPUSH
103484: CALL_OW 12
103488: ARRAY
103489: ST_TO_ADDR
// if ValidHex ( x , y ) then
103490: LD_VAR 0 3
103494: PPUSH
103495: LD_VAR 0 4
103499: PPUSH
103500: CALL_OW 488
103504: IFFALSE 103527
// begin result := [ x , y ] ;
103506: LD_ADDR_VAR 0 1
103510: PUSH
103511: LD_VAR 0 3
103515: PUSH
103516: LD_VAR 0 4
103520: PUSH
103521: EMPTY
103522: LIST
103523: LIST
103524: ST_TO_ADDR
// break ;
103525: GO 103529
// end ; end ;
103527: GO 103329
103529: POP
103530: POP
// if result then
103531: LD_VAR 0 1
103535: IFFALSE 103595
// begin ToLua ( playSibBomb() ) ;
103537: LD_STRING playSibBomb()
103539: PPUSH
103540: CALL_OW 559
// wait ( 0 0$14 ) ;
103544: LD_INT 490
103546: PPUSH
103547: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
103551: LD_VAR 0 1
103555: PUSH
103556: LD_INT 1
103558: ARRAY
103559: PPUSH
103560: LD_VAR 0 1
103564: PUSH
103565: LD_INT 2
103567: ARRAY
103568: PPUSH
103569: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
103573: LD_VAR 0 1
103577: PUSH
103578: LD_INT 1
103580: ARRAY
103581: PPUSH
103582: LD_VAR 0 1
103586: PUSH
103587: LD_INT 2
103589: ARRAY
103590: PPUSH
103591: CALL_OW 429
// end ; end ;
103595: LD_VAR 0 1
103599: RET
// every 0 0$1 trigger StreamModeActive and sReset do
103600: LD_EXP 124
103604: PUSH
103605: LD_EXP 146
103609: AND
103610: IFFALSE 103622
103612: GO 103614
103614: DISABLE
// YouLost (  ) ;
103615: LD_STRING 
103617: PPUSH
103618: CALL_OW 104
103622: END
// every 0 0$1 trigger StreamModeActive and sFog do
103623: LD_EXP 124
103627: PUSH
103628: LD_EXP 145
103632: AND
103633: IFFALSE 103647
103635: GO 103637
103637: DISABLE
// FogOff ( your_side ) ;
103638: LD_OWVAR 2
103642: PPUSH
103643: CALL_OW 344
103647: END
// every 0 0$1 trigger StreamModeActive and sSun do
103648: LD_EXP 124
103652: PUSH
103653: LD_EXP 147
103657: AND
103658: IFFALSE 103686
103660: GO 103662
103662: DISABLE
// begin solar_recharge_percent := 0 ;
103663: LD_ADDR_OWVAR 79
103667: PUSH
103668: LD_INT 0
103670: ST_TO_ADDR
// wait ( 5 5$00 ) ;
103671: LD_INT 10500
103673: PPUSH
103674: CALL_OW 67
// solar_recharge_percent := 100 ;
103678: LD_ADDR_OWVAR 79
103682: PUSH
103683: LD_INT 100
103685: ST_TO_ADDR
// end ;
103686: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
103687: LD_EXP 124
103691: PUSH
103692: LD_EXP 148
103696: AND
103697: IFFALSE 103936
103699: GO 103701
103701: DISABLE
103702: LD_INT 0
103704: PPUSH
103705: PPUSH
103706: PPUSH
// begin tmp := [ ] ;
103707: LD_ADDR_VAR 0 3
103711: PUSH
103712: EMPTY
103713: ST_TO_ADDR
// for i := 1 to 6 do
103714: LD_ADDR_VAR 0 1
103718: PUSH
103719: DOUBLE
103720: LD_INT 1
103722: DEC
103723: ST_TO_ADDR
103724: LD_INT 6
103726: PUSH
103727: FOR_TO
103728: IFFALSE 103833
// begin uc_nation := nation_nature ;
103730: LD_ADDR_OWVAR 21
103734: PUSH
103735: LD_INT 0
103737: ST_TO_ADDR
// uc_side := 0 ;
103738: LD_ADDR_OWVAR 20
103742: PUSH
103743: LD_INT 0
103745: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
103746: LD_ADDR_OWVAR 29
103750: PUSH
103751: LD_INT 12
103753: PUSH
103754: LD_INT 12
103756: PUSH
103757: EMPTY
103758: LIST
103759: LIST
103760: ST_TO_ADDR
// hc_agressivity := 20 ;
103761: LD_ADDR_OWVAR 35
103765: PUSH
103766: LD_INT 20
103768: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
103769: LD_ADDR_OWVAR 28
103773: PUSH
103774: LD_INT 17
103776: ST_TO_ADDR
// hc_gallery :=  ;
103777: LD_ADDR_OWVAR 33
103781: PUSH
103782: LD_STRING 
103784: ST_TO_ADDR
// hc_name :=  ;
103785: LD_ADDR_OWVAR 26
103789: PUSH
103790: LD_STRING 
103792: ST_TO_ADDR
// un := CreateHuman ;
103793: LD_ADDR_VAR 0 2
103797: PUSH
103798: CALL_OW 44
103802: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
103803: LD_VAR 0 2
103807: PPUSH
103808: LD_INT 1
103810: PPUSH
103811: CALL_OW 51
// tmp := tmp ^ un ;
103815: LD_ADDR_VAR 0 3
103819: PUSH
103820: LD_VAR 0 3
103824: PUSH
103825: LD_VAR 0 2
103829: ADD
103830: ST_TO_ADDR
// end ;
103831: GO 103727
103833: POP
103834: POP
// repeat wait ( 0 0$1 ) ;
103835: LD_INT 35
103837: PPUSH
103838: CALL_OW 67
// for un in tmp do
103842: LD_ADDR_VAR 0 2
103846: PUSH
103847: LD_VAR 0 3
103851: PUSH
103852: FOR_IN
103853: IFFALSE 103927
// begin if IsDead ( un ) then
103855: LD_VAR 0 2
103859: PPUSH
103860: CALL_OW 301
103864: IFFALSE 103884
// begin tmp := tmp diff un ;
103866: LD_ADDR_VAR 0 3
103870: PUSH
103871: LD_VAR 0 3
103875: PUSH
103876: LD_VAR 0 2
103880: DIFF
103881: ST_TO_ADDR
// continue ;
103882: GO 103852
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103884: LD_VAR 0 2
103888: PPUSH
103889: LD_INT 3
103891: PUSH
103892: LD_INT 22
103894: PUSH
103895: LD_INT 0
103897: PUSH
103898: EMPTY
103899: LIST
103900: LIST
103901: PUSH
103902: EMPTY
103903: LIST
103904: LIST
103905: PPUSH
103906: CALL_OW 69
103910: PPUSH
103911: LD_VAR 0 2
103915: PPUSH
103916: CALL_OW 74
103920: PPUSH
103921: CALL_OW 115
// end ;
103925: GO 103852
103927: POP
103928: POP
// until not tmp ;
103929: LD_VAR 0 3
103933: NOT
103934: IFFALSE 103835
// end ;
103936: PPOPN 3
103938: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103939: LD_EXP 124
103943: PUSH
103944: LD_EXP 149
103948: AND
103949: IFFALSE 104003
103951: GO 103953
103953: DISABLE
// begin ToLua ( displayTroll(); ) ;
103954: LD_STRING displayTroll();
103956: PPUSH
103957: CALL_OW 559
// wait ( 3 3$00 ) ;
103961: LD_INT 6300
103963: PPUSH
103964: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103968: LD_STRING hideTroll();
103970: PPUSH
103971: CALL_OW 559
// wait ( 1 1$00 ) ;
103975: LD_INT 2100
103977: PPUSH
103978: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103982: LD_STRING displayTroll();
103984: PPUSH
103985: CALL_OW 559
// wait ( 1 1$00 ) ;
103989: LD_INT 2100
103991: PPUSH
103992: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103996: LD_STRING hideTroll();
103998: PPUSH
103999: CALL_OW 559
// end ;
104003: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
104004: LD_EXP 124
104008: PUSH
104009: LD_EXP 150
104013: AND
104014: IFFALSE 104077
104016: GO 104018
104018: DISABLE
104019: LD_INT 0
104021: PPUSH
// begin p := 0 ;
104022: LD_ADDR_VAR 0 1
104026: PUSH
104027: LD_INT 0
104029: ST_TO_ADDR
// repeat game_speed := 1 ;
104030: LD_ADDR_OWVAR 65
104034: PUSH
104035: LD_INT 1
104037: ST_TO_ADDR
// wait ( 0 0$1 ) ;
104038: LD_INT 35
104040: PPUSH
104041: CALL_OW 67
// p := p + 1 ;
104045: LD_ADDR_VAR 0 1
104049: PUSH
104050: LD_VAR 0 1
104054: PUSH
104055: LD_INT 1
104057: PLUS
104058: ST_TO_ADDR
// until p >= 60 ;
104059: LD_VAR 0 1
104063: PUSH
104064: LD_INT 60
104066: GREATEREQUAL
104067: IFFALSE 104030
// game_speed := 4 ;
104069: LD_ADDR_OWVAR 65
104073: PUSH
104074: LD_INT 4
104076: ST_TO_ADDR
// end ;
104077: PPOPN 1
104079: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
104080: LD_EXP 124
104084: PUSH
104085: LD_EXP 151
104089: AND
104090: IFFALSE 104236
104092: GO 104094
104094: DISABLE
104095: LD_INT 0
104097: PPUSH
104098: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104099: LD_ADDR_VAR 0 1
104103: PUSH
104104: LD_INT 22
104106: PUSH
104107: LD_OWVAR 2
104111: PUSH
104112: EMPTY
104113: LIST
104114: LIST
104115: PUSH
104116: LD_INT 2
104118: PUSH
104119: LD_INT 30
104121: PUSH
104122: LD_INT 0
104124: PUSH
104125: EMPTY
104126: LIST
104127: LIST
104128: PUSH
104129: LD_INT 30
104131: PUSH
104132: LD_INT 1
104134: PUSH
104135: EMPTY
104136: LIST
104137: LIST
104138: PUSH
104139: EMPTY
104140: LIST
104141: LIST
104142: LIST
104143: PUSH
104144: EMPTY
104145: LIST
104146: LIST
104147: PPUSH
104148: CALL_OW 69
104152: ST_TO_ADDR
// if not depot then
104153: LD_VAR 0 1
104157: NOT
104158: IFFALSE 104162
// exit ;
104160: GO 104236
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
104162: LD_ADDR_VAR 0 2
104166: PUSH
104167: LD_VAR 0 1
104171: PUSH
104172: LD_INT 1
104174: PPUSH
104175: LD_VAR 0 1
104179: PPUSH
104180: CALL_OW 12
104184: ARRAY
104185: PPUSH
104186: CALL_OW 274
104190: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
104191: LD_VAR 0 2
104195: PPUSH
104196: LD_INT 1
104198: PPUSH
104199: LD_INT 0
104201: PPUSH
104202: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
104206: LD_VAR 0 2
104210: PPUSH
104211: LD_INT 2
104213: PPUSH
104214: LD_INT 0
104216: PPUSH
104217: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
104221: LD_VAR 0 2
104225: PPUSH
104226: LD_INT 3
104228: PPUSH
104229: LD_INT 0
104231: PPUSH
104232: CALL_OW 277
// end ;
104236: PPOPN 2
104238: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
104239: LD_EXP 124
104243: PUSH
104244: LD_EXP 152
104248: AND
104249: IFFALSE 104346
104251: GO 104253
104253: DISABLE
104254: LD_INT 0
104256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104257: LD_ADDR_VAR 0 1
104261: PUSH
104262: LD_INT 22
104264: PUSH
104265: LD_OWVAR 2
104269: PUSH
104270: EMPTY
104271: LIST
104272: LIST
104273: PUSH
104274: LD_INT 21
104276: PUSH
104277: LD_INT 1
104279: PUSH
104280: EMPTY
104281: LIST
104282: LIST
104283: PUSH
104284: LD_INT 3
104286: PUSH
104287: LD_INT 23
104289: PUSH
104290: LD_INT 0
104292: PUSH
104293: EMPTY
104294: LIST
104295: LIST
104296: PUSH
104297: EMPTY
104298: LIST
104299: LIST
104300: PUSH
104301: EMPTY
104302: LIST
104303: LIST
104304: LIST
104305: PPUSH
104306: CALL_OW 69
104310: ST_TO_ADDR
// if not tmp then
104311: LD_VAR 0 1
104315: NOT
104316: IFFALSE 104320
// exit ;
104318: GO 104346
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
104320: LD_VAR 0 1
104324: PUSH
104325: LD_INT 1
104327: PPUSH
104328: LD_VAR 0 1
104332: PPUSH
104333: CALL_OW 12
104337: ARRAY
104338: PPUSH
104339: LD_INT 200
104341: PPUSH
104342: CALL_OW 234
// end ;
104346: PPOPN 1
104348: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
104349: LD_EXP 124
104353: PUSH
104354: LD_EXP 153
104358: AND
104359: IFFALSE 104438
104361: GO 104363
104363: DISABLE
104364: LD_INT 0
104366: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
104367: LD_ADDR_VAR 0 1
104371: PUSH
104372: LD_INT 22
104374: PUSH
104375: LD_OWVAR 2
104379: PUSH
104380: EMPTY
104381: LIST
104382: LIST
104383: PUSH
104384: LD_INT 21
104386: PUSH
104387: LD_INT 2
104389: PUSH
104390: EMPTY
104391: LIST
104392: LIST
104393: PUSH
104394: EMPTY
104395: LIST
104396: LIST
104397: PPUSH
104398: CALL_OW 69
104402: ST_TO_ADDR
// if not tmp then
104403: LD_VAR 0 1
104407: NOT
104408: IFFALSE 104412
// exit ;
104410: GO 104438
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
104412: LD_VAR 0 1
104416: PUSH
104417: LD_INT 1
104419: PPUSH
104420: LD_VAR 0 1
104424: PPUSH
104425: CALL_OW 12
104429: ARRAY
104430: PPUSH
104431: LD_INT 60
104433: PPUSH
104434: CALL_OW 234
// end ;
104438: PPOPN 1
104440: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
104441: LD_EXP 124
104445: PUSH
104446: LD_EXP 154
104450: AND
104451: IFFALSE 104550
104453: GO 104455
104455: DISABLE
104456: LD_INT 0
104458: PPUSH
104459: PPUSH
// begin enable ;
104460: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
104461: LD_ADDR_VAR 0 1
104465: PUSH
104466: LD_INT 22
104468: PUSH
104469: LD_OWVAR 2
104473: PUSH
104474: EMPTY
104475: LIST
104476: LIST
104477: PUSH
104478: LD_INT 61
104480: PUSH
104481: EMPTY
104482: LIST
104483: PUSH
104484: LD_INT 33
104486: PUSH
104487: LD_INT 2
104489: PUSH
104490: EMPTY
104491: LIST
104492: LIST
104493: PUSH
104494: EMPTY
104495: LIST
104496: LIST
104497: LIST
104498: PPUSH
104499: CALL_OW 69
104503: ST_TO_ADDR
// if not tmp then
104504: LD_VAR 0 1
104508: NOT
104509: IFFALSE 104513
// exit ;
104511: GO 104550
// for i in tmp do
104513: LD_ADDR_VAR 0 2
104517: PUSH
104518: LD_VAR 0 1
104522: PUSH
104523: FOR_IN
104524: IFFALSE 104548
// if IsControledBy ( i ) then
104526: LD_VAR 0 2
104530: PPUSH
104531: CALL_OW 312
104535: IFFALSE 104546
// ComUnlink ( i ) ;
104537: LD_VAR 0 2
104541: PPUSH
104542: CALL_OW 136
104546: GO 104523
104548: POP
104549: POP
// end ;
104550: PPOPN 2
104552: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
104553: LD_EXP 124
104557: PUSH
104558: LD_EXP 155
104562: AND
104563: IFFALSE 104703
104565: GO 104567
104567: DISABLE
104568: LD_INT 0
104570: PPUSH
104571: PPUSH
// begin ToLua ( displayPowell(); ) ;
104572: LD_STRING displayPowell();
104574: PPUSH
104575: CALL_OW 559
// uc_side := 0 ;
104579: LD_ADDR_OWVAR 20
104583: PUSH
104584: LD_INT 0
104586: ST_TO_ADDR
// uc_nation := 2 ;
104587: LD_ADDR_OWVAR 21
104591: PUSH
104592: LD_INT 2
104594: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
104595: LD_ADDR_OWVAR 37
104599: PUSH
104600: LD_INT 14
104602: ST_TO_ADDR
// vc_engine := engine_siberite ;
104603: LD_ADDR_OWVAR 39
104607: PUSH
104608: LD_INT 3
104610: ST_TO_ADDR
// vc_control := control_apeman ;
104611: LD_ADDR_OWVAR 38
104615: PUSH
104616: LD_INT 5
104618: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
104619: LD_ADDR_OWVAR 40
104623: PUSH
104624: LD_INT 29
104626: ST_TO_ADDR
// un := CreateVehicle ;
104627: LD_ADDR_VAR 0 2
104631: PUSH
104632: CALL_OW 45
104636: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104637: LD_VAR 0 2
104641: PPUSH
104642: LD_INT 1
104644: PPUSH
104645: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104649: LD_INT 35
104651: PPUSH
104652: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104656: LD_VAR 0 2
104660: PPUSH
104661: LD_INT 22
104663: PUSH
104664: LD_OWVAR 2
104668: PUSH
104669: EMPTY
104670: LIST
104671: LIST
104672: PPUSH
104673: CALL_OW 69
104677: PPUSH
104678: LD_VAR 0 2
104682: PPUSH
104683: CALL_OW 74
104687: PPUSH
104688: CALL_OW 115
// until IsDead ( un ) ;
104692: LD_VAR 0 2
104696: PPUSH
104697: CALL_OW 301
104701: IFFALSE 104649
// end ;
104703: PPOPN 2
104705: END
// every 0 0$1 trigger StreamModeActive and sStu do
104706: LD_EXP 124
104710: PUSH
104711: LD_EXP 163
104715: AND
104716: IFFALSE 104732
104718: GO 104720
104720: DISABLE
// begin ToLua ( displayStucuk(); ) ;
104721: LD_STRING displayStucuk();
104723: PPUSH
104724: CALL_OW 559
// ResetFog ;
104728: CALL_OW 335
// end ;
104732: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
104733: LD_EXP 124
104737: PUSH
104738: LD_EXP 156
104742: AND
104743: IFFALSE 104884
104745: GO 104747
104747: DISABLE
104748: LD_INT 0
104750: PPUSH
104751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104752: LD_ADDR_VAR 0 2
104756: PUSH
104757: LD_INT 22
104759: PUSH
104760: LD_OWVAR 2
104764: PUSH
104765: EMPTY
104766: LIST
104767: LIST
104768: PUSH
104769: LD_INT 21
104771: PUSH
104772: LD_INT 1
104774: PUSH
104775: EMPTY
104776: LIST
104777: LIST
104778: PUSH
104779: EMPTY
104780: LIST
104781: LIST
104782: PPUSH
104783: CALL_OW 69
104787: ST_TO_ADDR
// if not tmp then
104788: LD_VAR 0 2
104792: NOT
104793: IFFALSE 104797
// exit ;
104795: GO 104884
// un := tmp [ rand ( 1 , tmp ) ] ;
104797: LD_ADDR_VAR 0 1
104801: PUSH
104802: LD_VAR 0 2
104806: PUSH
104807: LD_INT 1
104809: PPUSH
104810: LD_VAR 0 2
104814: PPUSH
104815: CALL_OW 12
104819: ARRAY
104820: ST_TO_ADDR
// SetSide ( un , 0 ) ;
104821: LD_VAR 0 1
104825: PPUSH
104826: LD_INT 0
104828: PPUSH
104829: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
104833: LD_VAR 0 1
104837: PPUSH
104838: LD_OWVAR 3
104842: PUSH
104843: LD_VAR 0 1
104847: DIFF
104848: PPUSH
104849: LD_VAR 0 1
104853: PPUSH
104854: CALL_OW 74
104858: PPUSH
104859: CALL_OW 115
// wait ( 0 0$20 ) ;
104863: LD_INT 700
104865: PPUSH
104866: CALL_OW 67
// SetSide ( un , your_side ) ;
104870: LD_VAR 0 1
104874: PPUSH
104875: LD_OWVAR 2
104879: PPUSH
104880: CALL_OW 235
// end ;
104884: PPOPN 2
104886: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104887: LD_EXP 124
104891: PUSH
104892: LD_EXP 157
104896: AND
104897: IFFALSE 105003
104899: GO 104901
104901: DISABLE
104902: LD_INT 0
104904: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104905: LD_ADDR_VAR 0 1
104909: PUSH
104910: LD_INT 22
104912: PUSH
104913: LD_OWVAR 2
104917: PUSH
104918: EMPTY
104919: LIST
104920: LIST
104921: PUSH
104922: LD_INT 2
104924: PUSH
104925: LD_INT 30
104927: PUSH
104928: LD_INT 0
104930: PUSH
104931: EMPTY
104932: LIST
104933: LIST
104934: PUSH
104935: LD_INT 30
104937: PUSH
104938: LD_INT 1
104940: PUSH
104941: EMPTY
104942: LIST
104943: LIST
104944: PUSH
104945: EMPTY
104946: LIST
104947: LIST
104948: LIST
104949: PUSH
104950: EMPTY
104951: LIST
104952: LIST
104953: PPUSH
104954: CALL_OW 69
104958: ST_TO_ADDR
// if not depot then
104959: LD_VAR 0 1
104963: NOT
104964: IFFALSE 104968
// exit ;
104966: GO 105003
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104968: LD_VAR 0 1
104972: PUSH
104973: LD_INT 1
104975: ARRAY
104976: PPUSH
104977: CALL_OW 250
104981: PPUSH
104982: LD_VAR 0 1
104986: PUSH
104987: LD_INT 1
104989: ARRAY
104990: PPUSH
104991: CALL_OW 251
104995: PPUSH
104996: LD_INT 70
104998: PPUSH
104999: CALL_OW 495
// end ;
105003: PPOPN 1
105005: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
105006: LD_EXP 124
105010: PUSH
105011: LD_EXP 158
105015: AND
105016: IFFALSE 105227
105018: GO 105020
105020: DISABLE
105021: LD_INT 0
105023: PPUSH
105024: PPUSH
105025: PPUSH
105026: PPUSH
105027: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105028: LD_ADDR_VAR 0 5
105032: PUSH
105033: LD_INT 22
105035: PUSH
105036: LD_OWVAR 2
105040: PUSH
105041: EMPTY
105042: LIST
105043: LIST
105044: PUSH
105045: LD_INT 21
105047: PUSH
105048: LD_INT 1
105050: PUSH
105051: EMPTY
105052: LIST
105053: LIST
105054: PUSH
105055: EMPTY
105056: LIST
105057: LIST
105058: PPUSH
105059: CALL_OW 69
105063: ST_TO_ADDR
// if not tmp then
105064: LD_VAR 0 5
105068: NOT
105069: IFFALSE 105073
// exit ;
105071: GO 105227
// for i in tmp do
105073: LD_ADDR_VAR 0 1
105077: PUSH
105078: LD_VAR 0 5
105082: PUSH
105083: FOR_IN
105084: IFFALSE 105225
// begin d := rand ( 0 , 5 ) ;
105086: LD_ADDR_VAR 0 4
105090: PUSH
105091: LD_INT 0
105093: PPUSH
105094: LD_INT 5
105096: PPUSH
105097: CALL_OW 12
105101: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
105102: LD_ADDR_VAR 0 2
105106: PUSH
105107: LD_VAR 0 1
105111: PPUSH
105112: CALL_OW 250
105116: PPUSH
105117: LD_VAR 0 4
105121: PPUSH
105122: LD_INT 3
105124: PPUSH
105125: LD_INT 12
105127: PPUSH
105128: CALL_OW 12
105132: PPUSH
105133: CALL_OW 272
105137: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
105138: LD_ADDR_VAR 0 3
105142: PUSH
105143: LD_VAR 0 1
105147: PPUSH
105148: CALL_OW 251
105152: PPUSH
105153: LD_VAR 0 4
105157: PPUSH
105158: LD_INT 3
105160: PPUSH
105161: LD_INT 12
105163: PPUSH
105164: CALL_OW 12
105168: PPUSH
105169: CALL_OW 273
105173: ST_TO_ADDR
// if ValidHex ( x , y ) then
105174: LD_VAR 0 2
105178: PPUSH
105179: LD_VAR 0 3
105183: PPUSH
105184: CALL_OW 488
105188: IFFALSE 105223
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
105190: LD_VAR 0 1
105194: PPUSH
105195: LD_VAR 0 2
105199: PPUSH
105200: LD_VAR 0 3
105204: PPUSH
105205: LD_INT 3
105207: PPUSH
105208: LD_INT 6
105210: PPUSH
105211: CALL_OW 12
105215: PPUSH
105216: LD_INT 1
105218: PPUSH
105219: CALL_OW 483
// end ;
105223: GO 105083
105225: POP
105226: POP
// end ;
105227: PPOPN 5
105229: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
105230: LD_EXP 124
105234: PUSH
105235: LD_EXP 159
105239: AND
105240: IFFALSE 105334
105242: GO 105244
105244: DISABLE
105245: LD_INT 0
105247: PPUSH
105248: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
105249: LD_ADDR_VAR 0 2
105253: PUSH
105254: LD_INT 22
105256: PUSH
105257: LD_OWVAR 2
105261: PUSH
105262: EMPTY
105263: LIST
105264: LIST
105265: PUSH
105266: LD_INT 32
105268: PUSH
105269: LD_INT 1
105271: PUSH
105272: EMPTY
105273: LIST
105274: LIST
105275: PUSH
105276: LD_INT 21
105278: PUSH
105279: LD_INT 2
105281: PUSH
105282: EMPTY
105283: LIST
105284: LIST
105285: PUSH
105286: EMPTY
105287: LIST
105288: LIST
105289: LIST
105290: PPUSH
105291: CALL_OW 69
105295: ST_TO_ADDR
// if not tmp then
105296: LD_VAR 0 2
105300: NOT
105301: IFFALSE 105305
// exit ;
105303: GO 105334
// for i in tmp do
105305: LD_ADDR_VAR 0 1
105309: PUSH
105310: LD_VAR 0 2
105314: PUSH
105315: FOR_IN
105316: IFFALSE 105332
// SetFuel ( i , 0 ) ;
105318: LD_VAR 0 1
105322: PPUSH
105323: LD_INT 0
105325: PPUSH
105326: CALL_OW 240
105330: GO 105315
105332: POP
105333: POP
// end ;
105334: PPOPN 2
105336: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
105337: LD_EXP 124
105341: PUSH
105342: LD_EXP 160
105346: AND
105347: IFFALSE 105413
105349: GO 105351
105351: DISABLE
105352: LD_INT 0
105354: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105355: LD_ADDR_VAR 0 1
105359: PUSH
105360: LD_INT 22
105362: PUSH
105363: LD_OWVAR 2
105367: PUSH
105368: EMPTY
105369: LIST
105370: LIST
105371: PUSH
105372: LD_INT 30
105374: PUSH
105375: LD_INT 29
105377: PUSH
105378: EMPTY
105379: LIST
105380: LIST
105381: PUSH
105382: EMPTY
105383: LIST
105384: LIST
105385: PPUSH
105386: CALL_OW 69
105390: ST_TO_ADDR
// if not tmp then
105391: LD_VAR 0 1
105395: NOT
105396: IFFALSE 105400
// exit ;
105398: GO 105413
// DestroyUnit ( tmp [ 1 ] ) ;
105400: LD_VAR 0 1
105404: PUSH
105405: LD_INT 1
105407: ARRAY
105408: PPUSH
105409: CALL_OW 65
// end ;
105413: PPOPN 1
105415: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
105416: LD_EXP 124
105420: PUSH
105421: LD_EXP 162
105425: AND
105426: IFFALSE 105555
105428: GO 105430
105430: DISABLE
105431: LD_INT 0
105433: PPUSH
// begin uc_side := 0 ;
105434: LD_ADDR_OWVAR 20
105438: PUSH
105439: LD_INT 0
105441: ST_TO_ADDR
// uc_nation := nation_arabian ;
105442: LD_ADDR_OWVAR 21
105446: PUSH
105447: LD_INT 2
105449: ST_TO_ADDR
// hc_gallery :=  ;
105450: LD_ADDR_OWVAR 33
105454: PUSH
105455: LD_STRING 
105457: ST_TO_ADDR
// hc_name :=  ;
105458: LD_ADDR_OWVAR 26
105462: PUSH
105463: LD_STRING 
105465: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
105466: LD_INT 1
105468: PPUSH
105469: LD_INT 11
105471: PPUSH
105472: LD_INT 10
105474: PPUSH
105475: CALL_OW 380
// un := CreateHuman ;
105479: LD_ADDR_VAR 0 1
105483: PUSH
105484: CALL_OW 44
105488: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105489: LD_VAR 0 1
105493: PPUSH
105494: LD_INT 1
105496: PPUSH
105497: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105501: LD_INT 35
105503: PPUSH
105504: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105508: LD_VAR 0 1
105512: PPUSH
105513: LD_INT 22
105515: PUSH
105516: LD_OWVAR 2
105520: PUSH
105521: EMPTY
105522: LIST
105523: LIST
105524: PPUSH
105525: CALL_OW 69
105529: PPUSH
105530: LD_VAR 0 1
105534: PPUSH
105535: CALL_OW 74
105539: PPUSH
105540: CALL_OW 115
// until IsDead ( un ) ;
105544: LD_VAR 0 1
105548: PPUSH
105549: CALL_OW 301
105553: IFFALSE 105501
// end ;
105555: PPOPN 1
105557: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
105558: LD_EXP 124
105562: PUSH
105563: LD_EXP 164
105567: AND
105568: IFFALSE 105580
105570: GO 105572
105572: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
105573: LD_STRING earthquake(getX(game), 0, 32)
105575: PPUSH
105576: CALL_OW 559
105580: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
105581: LD_EXP 124
105585: PUSH
105586: LD_EXP 165
105590: AND
105591: IFFALSE 105682
105593: GO 105595
105595: DISABLE
105596: LD_INT 0
105598: PPUSH
// begin enable ;
105599: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
105600: LD_ADDR_VAR 0 1
105604: PUSH
105605: LD_INT 22
105607: PUSH
105608: LD_OWVAR 2
105612: PUSH
105613: EMPTY
105614: LIST
105615: LIST
105616: PUSH
105617: LD_INT 21
105619: PUSH
105620: LD_INT 2
105622: PUSH
105623: EMPTY
105624: LIST
105625: LIST
105626: PUSH
105627: LD_INT 33
105629: PUSH
105630: LD_INT 3
105632: PUSH
105633: EMPTY
105634: LIST
105635: LIST
105636: PUSH
105637: EMPTY
105638: LIST
105639: LIST
105640: LIST
105641: PPUSH
105642: CALL_OW 69
105646: ST_TO_ADDR
// if not tmp then
105647: LD_VAR 0 1
105651: NOT
105652: IFFALSE 105656
// exit ;
105654: GO 105682
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105656: LD_VAR 0 1
105660: PUSH
105661: LD_INT 1
105663: PPUSH
105664: LD_VAR 0 1
105668: PPUSH
105669: CALL_OW 12
105673: ARRAY
105674: PPUSH
105675: LD_INT 1
105677: PPUSH
105678: CALL_OW 234
// end ;
105682: PPOPN 1
105684: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
105685: LD_EXP 124
105689: PUSH
105690: LD_EXP 166
105694: AND
105695: IFFALSE 105836
105697: GO 105699
105699: DISABLE
105700: LD_INT 0
105702: PPUSH
105703: PPUSH
105704: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105705: LD_ADDR_VAR 0 3
105709: PUSH
105710: LD_INT 22
105712: PUSH
105713: LD_OWVAR 2
105717: PUSH
105718: EMPTY
105719: LIST
105720: LIST
105721: PUSH
105722: LD_INT 25
105724: PUSH
105725: LD_INT 1
105727: PUSH
105728: EMPTY
105729: LIST
105730: LIST
105731: PUSH
105732: EMPTY
105733: LIST
105734: LIST
105735: PPUSH
105736: CALL_OW 69
105740: ST_TO_ADDR
// if not tmp then
105741: LD_VAR 0 3
105745: NOT
105746: IFFALSE 105750
// exit ;
105748: GO 105836
// un := tmp [ rand ( 1 , tmp ) ] ;
105750: LD_ADDR_VAR 0 2
105754: PUSH
105755: LD_VAR 0 3
105759: PUSH
105760: LD_INT 1
105762: PPUSH
105763: LD_VAR 0 3
105767: PPUSH
105768: CALL_OW 12
105772: ARRAY
105773: ST_TO_ADDR
// if Crawls ( un ) then
105774: LD_VAR 0 2
105778: PPUSH
105779: CALL_OW 318
105783: IFFALSE 105794
// ComWalk ( un ) ;
105785: LD_VAR 0 2
105789: PPUSH
105790: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
105794: LD_VAR 0 2
105798: PPUSH
105799: LD_INT 9
105801: PPUSH
105802: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
105806: LD_INT 28
105808: PPUSH
105809: LD_OWVAR 2
105813: PPUSH
105814: LD_INT 2
105816: PPUSH
105817: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
105821: LD_INT 29
105823: PPUSH
105824: LD_OWVAR 2
105828: PPUSH
105829: LD_INT 2
105831: PPUSH
105832: CALL_OW 322
// end ;
105836: PPOPN 3
105838: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
105839: LD_EXP 124
105843: PUSH
105844: LD_EXP 167
105848: AND
105849: IFFALSE 105960
105851: GO 105853
105853: DISABLE
105854: LD_INT 0
105856: PPUSH
105857: PPUSH
105858: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105859: LD_ADDR_VAR 0 3
105863: PUSH
105864: LD_INT 22
105866: PUSH
105867: LD_OWVAR 2
105871: PUSH
105872: EMPTY
105873: LIST
105874: LIST
105875: PUSH
105876: LD_INT 25
105878: PUSH
105879: LD_INT 1
105881: PUSH
105882: EMPTY
105883: LIST
105884: LIST
105885: PUSH
105886: EMPTY
105887: LIST
105888: LIST
105889: PPUSH
105890: CALL_OW 69
105894: ST_TO_ADDR
// if not tmp then
105895: LD_VAR 0 3
105899: NOT
105900: IFFALSE 105904
// exit ;
105902: GO 105960
// un := tmp [ rand ( 1 , tmp ) ] ;
105904: LD_ADDR_VAR 0 2
105908: PUSH
105909: LD_VAR 0 3
105913: PUSH
105914: LD_INT 1
105916: PPUSH
105917: LD_VAR 0 3
105921: PPUSH
105922: CALL_OW 12
105926: ARRAY
105927: ST_TO_ADDR
// if Crawls ( un ) then
105928: LD_VAR 0 2
105932: PPUSH
105933: CALL_OW 318
105937: IFFALSE 105948
// ComWalk ( un ) ;
105939: LD_VAR 0 2
105943: PPUSH
105944: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105948: LD_VAR 0 2
105952: PPUSH
105953: LD_INT 8
105955: PPUSH
105956: CALL_OW 336
// end ;
105960: PPOPN 3
105962: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105963: LD_EXP 124
105967: PUSH
105968: LD_EXP 168
105972: AND
105973: IFFALSE 106117
105975: GO 105977
105977: DISABLE
105978: LD_INT 0
105980: PPUSH
105981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105982: LD_ADDR_VAR 0 2
105986: PUSH
105987: LD_INT 22
105989: PUSH
105990: LD_OWVAR 2
105994: PUSH
105995: EMPTY
105996: LIST
105997: LIST
105998: PUSH
105999: LD_INT 21
106001: PUSH
106002: LD_INT 2
106004: PUSH
106005: EMPTY
106006: LIST
106007: LIST
106008: PUSH
106009: LD_INT 2
106011: PUSH
106012: LD_INT 34
106014: PUSH
106015: LD_INT 12
106017: PUSH
106018: EMPTY
106019: LIST
106020: LIST
106021: PUSH
106022: LD_INT 34
106024: PUSH
106025: LD_INT 51
106027: PUSH
106028: EMPTY
106029: LIST
106030: LIST
106031: PUSH
106032: LD_INT 34
106034: PUSH
106035: LD_INT 32
106037: PUSH
106038: EMPTY
106039: LIST
106040: LIST
106041: PUSH
106042: EMPTY
106043: LIST
106044: LIST
106045: LIST
106046: LIST
106047: PUSH
106048: EMPTY
106049: LIST
106050: LIST
106051: LIST
106052: PPUSH
106053: CALL_OW 69
106057: ST_TO_ADDR
// if not tmp then
106058: LD_VAR 0 2
106062: NOT
106063: IFFALSE 106067
// exit ;
106065: GO 106117
// for i in tmp do
106067: LD_ADDR_VAR 0 1
106071: PUSH
106072: LD_VAR 0 2
106076: PUSH
106077: FOR_IN
106078: IFFALSE 106115
// if GetCargo ( i , mat_artifact ) = 0 then
106080: LD_VAR 0 1
106084: PPUSH
106085: LD_INT 4
106087: PPUSH
106088: CALL_OW 289
106092: PUSH
106093: LD_INT 0
106095: EQUAL
106096: IFFALSE 106113
// SetCargo ( i , mat_siberit , 100 ) ;
106098: LD_VAR 0 1
106102: PPUSH
106103: LD_INT 3
106105: PPUSH
106106: LD_INT 100
106108: PPUSH
106109: CALL_OW 290
106113: GO 106077
106115: POP
106116: POP
// end ;
106117: PPOPN 2
106119: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
106120: LD_EXP 124
106124: PUSH
106125: LD_EXP 169
106129: AND
106130: IFFALSE 106313
106132: GO 106134
106134: DISABLE
106135: LD_INT 0
106137: PPUSH
106138: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106139: LD_ADDR_VAR 0 2
106143: PUSH
106144: LD_INT 22
106146: PUSH
106147: LD_OWVAR 2
106151: PUSH
106152: EMPTY
106153: LIST
106154: LIST
106155: PPUSH
106156: CALL_OW 69
106160: ST_TO_ADDR
// if not tmp then
106161: LD_VAR 0 2
106165: NOT
106166: IFFALSE 106170
// exit ;
106168: GO 106313
// for i := 1 to 2 do
106170: LD_ADDR_VAR 0 1
106174: PUSH
106175: DOUBLE
106176: LD_INT 1
106178: DEC
106179: ST_TO_ADDR
106180: LD_INT 2
106182: PUSH
106183: FOR_TO
106184: IFFALSE 106311
// begin uc_side := your_side ;
106186: LD_ADDR_OWVAR 20
106190: PUSH
106191: LD_OWVAR 2
106195: ST_TO_ADDR
// uc_nation := nation_american ;
106196: LD_ADDR_OWVAR 21
106200: PUSH
106201: LD_INT 1
106203: ST_TO_ADDR
// vc_chassis := us_morphling ;
106204: LD_ADDR_OWVAR 37
106208: PUSH
106209: LD_INT 5
106211: ST_TO_ADDR
// vc_engine := engine_siberite ;
106212: LD_ADDR_OWVAR 39
106216: PUSH
106217: LD_INT 3
106219: ST_TO_ADDR
// vc_control := control_computer ;
106220: LD_ADDR_OWVAR 38
106224: PUSH
106225: LD_INT 3
106227: ST_TO_ADDR
// vc_weapon := us_double_laser ;
106228: LD_ADDR_OWVAR 40
106232: PUSH
106233: LD_INT 10
106235: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
106236: LD_VAR 0 2
106240: PUSH
106241: LD_INT 1
106243: ARRAY
106244: PPUSH
106245: CALL_OW 310
106249: NOT
106250: IFFALSE 106297
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
106252: CALL_OW 45
106256: PPUSH
106257: LD_VAR 0 2
106261: PUSH
106262: LD_INT 1
106264: ARRAY
106265: PPUSH
106266: CALL_OW 250
106270: PPUSH
106271: LD_VAR 0 2
106275: PUSH
106276: LD_INT 1
106278: ARRAY
106279: PPUSH
106280: CALL_OW 251
106284: PPUSH
106285: LD_INT 12
106287: PPUSH
106288: LD_INT 1
106290: PPUSH
106291: CALL_OW 50
106295: GO 106309
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
106297: CALL_OW 45
106301: PPUSH
106302: LD_INT 1
106304: PPUSH
106305: CALL_OW 51
// end ;
106309: GO 106183
106311: POP
106312: POP
// end ;
106313: PPOPN 2
106315: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
106316: LD_EXP 124
106320: PUSH
106321: LD_EXP 170
106325: AND
106326: IFFALSE 106548
106328: GO 106330
106330: DISABLE
106331: LD_INT 0
106333: PPUSH
106334: PPUSH
106335: PPUSH
106336: PPUSH
106337: PPUSH
106338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106339: LD_ADDR_VAR 0 6
106343: PUSH
106344: LD_INT 22
106346: PUSH
106347: LD_OWVAR 2
106351: PUSH
106352: EMPTY
106353: LIST
106354: LIST
106355: PUSH
106356: LD_INT 21
106358: PUSH
106359: LD_INT 1
106361: PUSH
106362: EMPTY
106363: LIST
106364: LIST
106365: PUSH
106366: LD_INT 3
106368: PUSH
106369: LD_INT 23
106371: PUSH
106372: LD_INT 0
106374: PUSH
106375: EMPTY
106376: LIST
106377: LIST
106378: PUSH
106379: EMPTY
106380: LIST
106381: LIST
106382: PUSH
106383: EMPTY
106384: LIST
106385: LIST
106386: LIST
106387: PPUSH
106388: CALL_OW 69
106392: ST_TO_ADDR
// if not tmp then
106393: LD_VAR 0 6
106397: NOT
106398: IFFALSE 106402
// exit ;
106400: GO 106548
// s1 := rand ( 1 , 4 ) ;
106402: LD_ADDR_VAR 0 2
106406: PUSH
106407: LD_INT 1
106409: PPUSH
106410: LD_INT 4
106412: PPUSH
106413: CALL_OW 12
106417: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
106418: LD_ADDR_VAR 0 4
106422: PUSH
106423: LD_VAR 0 6
106427: PUSH
106428: LD_INT 1
106430: ARRAY
106431: PPUSH
106432: LD_VAR 0 2
106436: PPUSH
106437: CALL_OW 259
106441: ST_TO_ADDR
// if s1 = 1 then
106442: LD_VAR 0 2
106446: PUSH
106447: LD_INT 1
106449: EQUAL
106450: IFFALSE 106470
// s2 := rand ( 2 , 4 ) else
106452: LD_ADDR_VAR 0 3
106456: PUSH
106457: LD_INT 2
106459: PPUSH
106460: LD_INT 4
106462: PPUSH
106463: CALL_OW 12
106467: ST_TO_ADDR
106468: GO 106478
// s2 := 1 ;
106470: LD_ADDR_VAR 0 3
106474: PUSH
106475: LD_INT 1
106477: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
106478: LD_ADDR_VAR 0 5
106482: PUSH
106483: LD_VAR 0 6
106487: PUSH
106488: LD_INT 1
106490: ARRAY
106491: PPUSH
106492: LD_VAR 0 3
106496: PPUSH
106497: CALL_OW 259
106501: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
106502: LD_VAR 0 6
106506: PUSH
106507: LD_INT 1
106509: ARRAY
106510: PPUSH
106511: LD_VAR 0 2
106515: PPUSH
106516: LD_VAR 0 5
106520: PPUSH
106521: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
106525: LD_VAR 0 6
106529: PUSH
106530: LD_INT 1
106532: ARRAY
106533: PPUSH
106534: LD_VAR 0 3
106538: PPUSH
106539: LD_VAR 0 4
106543: PPUSH
106544: CALL_OW 237
// end ;
106548: PPOPN 6
106550: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
106551: LD_EXP 124
106555: PUSH
106556: LD_EXP 171
106560: AND
106561: IFFALSE 106640
106563: GO 106565
106565: DISABLE
106566: LD_INT 0
106568: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
106569: LD_ADDR_VAR 0 1
106573: PUSH
106574: LD_INT 22
106576: PUSH
106577: LD_OWVAR 2
106581: PUSH
106582: EMPTY
106583: LIST
106584: LIST
106585: PUSH
106586: LD_INT 30
106588: PUSH
106589: LD_INT 3
106591: PUSH
106592: EMPTY
106593: LIST
106594: LIST
106595: PUSH
106596: EMPTY
106597: LIST
106598: LIST
106599: PPUSH
106600: CALL_OW 69
106604: ST_TO_ADDR
// if not tmp then
106605: LD_VAR 0 1
106609: NOT
106610: IFFALSE 106614
// exit ;
106612: GO 106640
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
106614: LD_VAR 0 1
106618: PUSH
106619: LD_INT 1
106621: PPUSH
106622: LD_VAR 0 1
106626: PPUSH
106627: CALL_OW 12
106631: ARRAY
106632: PPUSH
106633: LD_INT 1
106635: PPUSH
106636: CALL_OW 234
// end ;
106640: PPOPN 1
106642: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
106643: LD_EXP 124
106647: PUSH
106648: LD_EXP 172
106652: AND
106653: IFFALSE 106765
106655: GO 106657
106657: DISABLE
106658: LD_INT 0
106660: PPUSH
106661: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
106662: LD_ADDR_VAR 0 2
106666: PUSH
106667: LD_INT 22
106669: PUSH
106670: LD_OWVAR 2
106674: PUSH
106675: EMPTY
106676: LIST
106677: LIST
106678: PUSH
106679: LD_INT 2
106681: PUSH
106682: LD_INT 30
106684: PUSH
106685: LD_INT 27
106687: PUSH
106688: EMPTY
106689: LIST
106690: LIST
106691: PUSH
106692: LD_INT 30
106694: PUSH
106695: LD_INT 26
106697: PUSH
106698: EMPTY
106699: LIST
106700: LIST
106701: PUSH
106702: LD_INT 30
106704: PUSH
106705: LD_INT 28
106707: PUSH
106708: EMPTY
106709: LIST
106710: LIST
106711: PUSH
106712: EMPTY
106713: LIST
106714: LIST
106715: LIST
106716: LIST
106717: PUSH
106718: EMPTY
106719: LIST
106720: LIST
106721: PPUSH
106722: CALL_OW 69
106726: ST_TO_ADDR
// if not tmp then
106727: LD_VAR 0 2
106731: NOT
106732: IFFALSE 106736
// exit ;
106734: GO 106765
// for i in tmp do
106736: LD_ADDR_VAR 0 1
106740: PUSH
106741: LD_VAR 0 2
106745: PUSH
106746: FOR_IN
106747: IFFALSE 106763
// SetLives ( i , 1 ) ;
106749: LD_VAR 0 1
106753: PPUSH
106754: LD_INT 1
106756: PPUSH
106757: CALL_OW 234
106761: GO 106746
106763: POP
106764: POP
// end ;
106765: PPOPN 2
106767: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
106768: LD_EXP 124
106772: PUSH
106773: LD_EXP 173
106777: AND
106778: IFFALSE 107065
106780: GO 106782
106782: DISABLE
106783: LD_INT 0
106785: PPUSH
106786: PPUSH
106787: PPUSH
// begin i := rand ( 1 , 7 ) ;
106788: LD_ADDR_VAR 0 1
106792: PUSH
106793: LD_INT 1
106795: PPUSH
106796: LD_INT 7
106798: PPUSH
106799: CALL_OW 12
106803: ST_TO_ADDR
// case i of 1 :
106804: LD_VAR 0 1
106808: PUSH
106809: LD_INT 1
106811: DOUBLE
106812: EQUAL
106813: IFTRUE 106817
106815: GO 106827
106817: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
106818: LD_STRING earthquake(getX(game), 0, 32)
106820: PPUSH
106821: CALL_OW 559
106825: GO 107065
106827: LD_INT 2
106829: DOUBLE
106830: EQUAL
106831: IFTRUE 106835
106833: GO 106849
106835: POP
// begin ToLua ( displayStucuk(); ) ;
106836: LD_STRING displayStucuk();
106838: PPUSH
106839: CALL_OW 559
// ResetFog ;
106843: CALL_OW 335
// end ; 3 :
106847: GO 107065
106849: LD_INT 3
106851: DOUBLE
106852: EQUAL
106853: IFTRUE 106857
106855: GO 106961
106857: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106858: LD_ADDR_VAR 0 2
106862: PUSH
106863: LD_INT 22
106865: PUSH
106866: LD_OWVAR 2
106870: PUSH
106871: EMPTY
106872: LIST
106873: LIST
106874: PUSH
106875: LD_INT 25
106877: PUSH
106878: LD_INT 1
106880: PUSH
106881: EMPTY
106882: LIST
106883: LIST
106884: PUSH
106885: EMPTY
106886: LIST
106887: LIST
106888: PPUSH
106889: CALL_OW 69
106893: ST_TO_ADDR
// if not tmp then
106894: LD_VAR 0 2
106898: NOT
106899: IFFALSE 106903
// exit ;
106901: GO 107065
// un := tmp [ rand ( 1 , tmp ) ] ;
106903: LD_ADDR_VAR 0 3
106907: PUSH
106908: LD_VAR 0 2
106912: PUSH
106913: LD_INT 1
106915: PPUSH
106916: LD_VAR 0 2
106920: PPUSH
106921: CALL_OW 12
106925: ARRAY
106926: ST_TO_ADDR
// if Crawls ( un ) then
106927: LD_VAR 0 3
106931: PPUSH
106932: CALL_OW 318
106936: IFFALSE 106947
// ComWalk ( un ) ;
106938: LD_VAR 0 3
106942: PPUSH
106943: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106947: LD_VAR 0 3
106951: PPUSH
106952: LD_INT 8
106954: PPUSH
106955: CALL_OW 336
// end ; 4 :
106959: GO 107065
106961: LD_INT 4
106963: DOUBLE
106964: EQUAL
106965: IFTRUE 106969
106967: GO 107043
106969: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106970: LD_ADDR_VAR 0 2
106974: PUSH
106975: LD_INT 22
106977: PUSH
106978: LD_OWVAR 2
106982: PUSH
106983: EMPTY
106984: LIST
106985: LIST
106986: PUSH
106987: LD_INT 30
106989: PUSH
106990: LD_INT 29
106992: PUSH
106993: EMPTY
106994: LIST
106995: LIST
106996: PUSH
106997: EMPTY
106998: LIST
106999: LIST
107000: PPUSH
107001: CALL_OW 69
107005: ST_TO_ADDR
// if not tmp then
107006: LD_VAR 0 2
107010: NOT
107011: IFFALSE 107015
// exit ;
107013: GO 107065
// CenterNowOnUnits ( tmp [ 1 ] ) ;
107015: LD_VAR 0 2
107019: PUSH
107020: LD_INT 1
107022: ARRAY
107023: PPUSH
107024: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
107028: LD_VAR 0 2
107032: PUSH
107033: LD_INT 1
107035: ARRAY
107036: PPUSH
107037: CALL_OW 65
// end ; 5 .. 7 :
107041: GO 107065
107043: LD_INT 5
107045: DOUBLE
107046: GREATEREQUAL
107047: IFFALSE 107055
107049: LD_INT 7
107051: DOUBLE
107052: LESSEQUAL
107053: IFTRUE 107057
107055: GO 107064
107057: POP
// StreamSibBomb ; end ;
107058: CALL 103302 0 0
107062: GO 107065
107064: POP
// end ;
107065: PPOPN 3
107067: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
107068: LD_EXP 124
107072: PUSH
107073: LD_EXP 174
107077: AND
107078: IFFALSE 107234
107080: GO 107082
107082: DISABLE
107083: LD_INT 0
107085: PPUSH
107086: PPUSH
107087: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
107088: LD_ADDR_VAR 0 2
107092: PUSH
107093: LD_INT 81
107095: PUSH
107096: LD_OWVAR 2
107100: PUSH
107101: EMPTY
107102: LIST
107103: LIST
107104: PUSH
107105: LD_INT 2
107107: PUSH
107108: LD_INT 21
107110: PUSH
107111: LD_INT 1
107113: PUSH
107114: EMPTY
107115: LIST
107116: LIST
107117: PUSH
107118: LD_INT 21
107120: PUSH
107121: LD_INT 2
107123: PUSH
107124: EMPTY
107125: LIST
107126: LIST
107127: PUSH
107128: EMPTY
107129: LIST
107130: LIST
107131: LIST
107132: PUSH
107133: EMPTY
107134: LIST
107135: LIST
107136: PPUSH
107137: CALL_OW 69
107141: ST_TO_ADDR
// if not tmp then
107142: LD_VAR 0 2
107146: NOT
107147: IFFALSE 107151
// exit ;
107149: GO 107234
// p := 0 ;
107151: LD_ADDR_VAR 0 3
107155: PUSH
107156: LD_INT 0
107158: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
107159: LD_INT 35
107161: PPUSH
107162: CALL_OW 67
// p := p + 1 ;
107166: LD_ADDR_VAR 0 3
107170: PUSH
107171: LD_VAR 0 3
107175: PUSH
107176: LD_INT 1
107178: PLUS
107179: ST_TO_ADDR
// for i in tmp do
107180: LD_ADDR_VAR 0 1
107184: PUSH
107185: LD_VAR 0 2
107189: PUSH
107190: FOR_IN
107191: IFFALSE 107222
// if GetLives ( i ) < 1000 then
107193: LD_VAR 0 1
107197: PPUSH
107198: CALL_OW 256
107202: PUSH
107203: LD_INT 1000
107205: LESS
107206: IFFALSE 107220
// SetLives ( i , 1000 ) ;
107208: LD_VAR 0 1
107212: PPUSH
107213: LD_INT 1000
107215: PPUSH
107216: CALL_OW 234
107220: GO 107190
107222: POP
107223: POP
// until p > 20 ;
107224: LD_VAR 0 3
107228: PUSH
107229: LD_INT 20
107231: GREATER
107232: IFFALSE 107159
// end ;
107234: PPOPN 3
107236: END
// every 0 0$1 trigger StreamModeActive and sTime do
107237: LD_EXP 124
107241: PUSH
107242: LD_EXP 175
107246: AND
107247: IFFALSE 107282
107249: GO 107251
107251: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
107252: LD_INT 28
107254: PPUSH
107255: LD_OWVAR 2
107259: PPUSH
107260: LD_INT 2
107262: PPUSH
107263: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
107267: LD_INT 30
107269: PPUSH
107270: LD_OWVAR 2
107274: PPUSH
107275: LD_INT 2
107277: PPUSH
107278: CALL_OW 322
// end ;
107282: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
107283: LD_EXP 124
107287: PUSH
107288: LD_EXP 176
107292: AND
107293: IFFALSE 107414
107295: GO 107297
107297: DISABLE
107298: LD_INT 0
107300: PPUSH
107301: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
107302: LD_ADDR_VAR 0 2
107306: PUSH
107307: LD_INT 22
107309: PUSH
107310: LD_OWVAR 2
107314: PUSH
107315: EMPTY
107316: LIST
107317: LIST
107318: PUSH
107319: LD_INT 21
107321: PUSH
107322: LD_INT 1
107324: PUSH
107325: EMPTY
107326: LIST
107327: LIST
107328: PUSH
107329: LD_INT 3
107331: PUSH
107332: LD_INT 23
107334: PUSH
107335: LD_INT 0
107337: PUSH
107338: EMPTY
107339: LIST
107340: LIST
107341: PUSH
107342: EMPTY
107343: LIST
107344: LIST
107345: PUSH
107346: EMPTY
107347: LIST
107348: LIST
107349: LIST
107350: PPUSH
107351: CALL_OW 69
107355: ST_TO_ADDR
// if not tmp then
107356: LD_VAR 0 2
107360: NOT
107361: IFFALSE 107365
// exit ;
107363: GO 107414
// for i in tmp do
107365: LD_ADDR_VAR 0 1
107369: PUSH
107370: LD_VAR 0 2
107374: PUSH
107375: FOR_IN
107376: IFFALSE 107412
// begin if Crawls ( i ) then
107378: LD_VAR 0 1
107382: PPUSH
107383: CALL_OW 318
107387: IFFALSE 107398
// ComWalk ( i ) ;
107389: LD_VAR 0 1
107393: PPUSH
107394: CALL_OW 138
// SetClass ( i , 2 ) ;
107398: LD_VAR 0 1
107402: PPUSH
107403: LD_INT 2
107405: PPUSH
107406: CALL_OW 336
// end ;
107410: GO 107375
107412: POP
107413: POP
// end ;
107414: PPOPN 2
107416: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
107417: LD_EXP 124
107421: PUSH
107422: LD_EXP 177
107426: AND
107427: IFFALSE 107715
107429: GO 107431
107431: DISABLE
107432: LD_INT 0
107434: PPUSH
107435: PPUSH
107436: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
107437: LD_OWVAR 2
107441: PPUSH
107442: LD_INT 9
107444: PPUSH
107445: LD_INT 1
107447: PPUSH
107448: LD_INT 1
107450: PPUSH
107451: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
107455: LD_INT 9
107457: PPUSH
107458: LD_OWVAR 2
107462: PPUSH
107463: CALL_OW 343
// uc_side := 9 ;
107467: LD_ADDR_OWVAR 20
107471: PUSH
107472: LD_INT 9
107474: ST_TO_ADDR
// uc_nation := 2 ;
107475: LD_ADDR_OWVAR 21
107479: PUSH
107480: LD_INT 2
107482: ST_TO_ADDR
// hc_name := Dark Warrior ;
107483: LD_ADDR_OWVAR 26
107487: PUSH
107488: LD_STRING Dark Warrior
107490: ST_TO_ADDR
// hc_gallery :=  ;
107491: LD_ADDR_OWVAR 33
107495: PUSH
107496: LD_STRING 
107498: ST_TO_ADDR
// hc_noskilllimit := true ;
107499: LD_ADDR_OWVAR 76
107503: PUSH
107504: LD_INT 1
107506: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
107507: LD_ADDR_OWVAR 31
107511: PUSH
107512: LD_INT 30
107514: PUSH
107515: LD_INT 30
107517: PUSH
107518: LD_INT 30
107520: PUSH
107521: LD_INT 30
107523: PUSH
107524: EMPTY
107525: LIST
107526: LIST
107527: LIST
107528: LIST
107529: ST_TO_ADDR
// un := CreateHuman ;
107530: LD_ADDR_VAR 0 3
107534: PUSH
107535: CALL_OW 44
107539: ST_TO_ADDR
// hc_noskilllimit := false ;
107540: LD_ADDR_OWVAR 76
107544: PUSH
107545: LD_INT 0
107547: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
107548: LD_VAR 0 3
107552: PPUSH
107553: LD_INT 1
107555: PPUSH
107556: CALL_OW 51
// ToLua ( playRanger() ) ;
107560: LD_STRING playRanger()
107562: PPUSH
107563: CALL_OW 559
// p := 0 ;
107567: LD_ADDR_VAR 0 2
107571: PUSH
107572: LD_INT 0
107574: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
107575: LD_INT 35
107577: PPUSH
107578: CALL_OW 67
// p := p + 1 ;
107582: LD_ADDR_VAR 0 2
107586: PUSH
107587: LD_VAR 0 2
107591: PUSH
107592: LD_INT 1
107594: PLUS
107595: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
107596: LD_VAR 0 3
107600: PPUSH
107601: CALL_OW 256
107605: PUSH
107606: LD_INT 1000
107608: LESS
107609: IFFALSE 107623
// SetLives ( un , 1000 ) ;
107611: LD_VAR 0 3
107615: PPUSH
107616: LD_INT 1000
107618: PPUSH
107619: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
107623: LD_VAR 0 3
107627: PPUSH
107628: LD_INT 81
107630: PUSH
107631: LD_OWVAR 2
107635: PUSH
107636: EMPTY
107637: LIST
107638: LIST
107639: PUSH
107640: LD_INT 91
107642: PUSH
107643: LD_VAR 0 3
107647: PUSH
107648: LD_INT 30
107650: PUSH
107651: EMPTY
107652: LIST
107653: LIST
107654: LIST
107655: PUSH
107656: EMPTY
107657: LIST
107658: LIST
107659: PPUSH
107660: CALL_OW 69
107664: PPUSH
107665: LD_VAR 0 3
107669: PPUSH
107670: CALL_OW 74
107674: PPUSH
107675: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
107679: LD_VAR 0 2
107683: PUSH
107684: LD_INT 80
107686: GREATER
107687: PUSH
107688: LD_VAR 0 3
107692: PPUSH
107693: CALL_OW 301
107697: OR
107698: IFFALSE 107575
// if un then
107700: LD_VAR 0 3
107704: IFFALSE 107715
// RemoveUnit ( un ) ;
107706: LD_VAR 0 3
107710: PPUSH
107711: CALL_OW 64
// end ;
107715: PPOPN 3
107717: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
107718: LD_EXP 178
107722: IFFALSE 107838
107724: GO 107726
107726: DISABLE
107727: LD_INT 0
107729: PPUSH
107730: PPUSH
107731: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107732: LD_ADDR_VAR 0 2
107736: PUSH
107737: LD_INT 81
107739: PUSH
107740: LD_OWVAR 2
107744: PUSH
107745: EMPTY
107746: LIST
107747: LIST
107748: PUSH
107749: LD_INT 21
107751: PUSH
107752: LD_INT 1
107754: PUSH
107755: EMPTY
107756: LIST
107757: LIST
107758: PUSH
107759: EMPTY
107760: LIST
107761: LIST
107762: PPUSH
107763: CALL_OW 69
107767: ST_TO_ADDR
// ToLua ( playComputer() ) ;
107768: LD_STRING playComputer()
107770: PPUSH
107771: CALL_OW 559
// if not tmp then
107775: LD_VAR 0 2
107779: NOT
107780: IFFALSE 107784
// exit ;
107782: GO 107838
// for i in tmp do
107784: LD_ADDR_VAR 0 1
107788: PUSH
107789: LD_VAR 0 2
107793: PUSH
107794: FOR_IN
107795: IFFALSE 107836
// for j := 1 to 4 do
107797: LD_ADDR_VAR 0 3
107801: PUSH
107802: DOUBLE
107803: LD_INT 1
107805: DEC
107806: ST_TO_ADDR
107807: LD_INT 4
107809: PUSH
107810: FOR_TO
107811: IFFALSE 107832
// SetSkill ( i , j , 10 ) ;
107813: LD_VAR 0 1
107817: PPUSH
107818: LD_VAR 0 3
107822: PPUSH
107823: LD_INT 10
107825: PPUSH
107826: CALL_OW 237
107830: GO 107810
107832: POP
107833: POP
107834: GO 107794
107836: POP
107837: POP
// end ;
107838: PPOPN 3
107840: END
// every 0 0$1 trigger s30 do var i , tmp ;
107841: LD_EXP 179
107845: IFFALSE 107914
107847: GO 107849
107849: DISABLE
107850: LD_INT 0
107852: PPUSH
107853: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107854: LD_ADDR_VAR 0 2
107858: PUSH
107859: LD_INT 22
107861: PUSH
107862: LD_OWVAR 2
107866: PUSH
107867: EMPTY
107868: LIST
107869: LIST
107870: PPUSH
107871: CALL_OW 69
107875: ST_TO_ADDR
// if not tmp then
107876: LD_VAR 0 2
107880: NOT
107881: IFFALSE 107885
// exit ;
107883: GO 107914
// for i in tmp do
107885: LD_ADDR_VAR 0 1
107889: PUSH
107890: LD_VAR 0 2
107894: PUSH
107895: FOR_IN
107896: IFFALSE 107912
// SetLives ( i , 300 ) ;
107898: LD_VAR 0 1
107902: PPUSH
107903: LD_INT 300
107905: PPUSH
107906: CALL_OW 234
107910: GO 107895
107912: POP
107913: POP
// end ;
107914: PPOPN 2
107916: END
// every 0 0$1 trigger s60 do var i , tmp ;
107917: LD_EXP 180
107921: IFFALSE 107990
107923: GO 107925
107925: DISABLE
107926: LD_INT 0
107928: PPUSH
107929: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107930: LD_ADDR_VAR 0 2
107934: PUSH
107935: LD_INT 22
107937: PUSH
107938: LD_OWVAR 2
107942: PUSH
107943: EMPTY
107944: LIST
107945: LIST
107946: PPUSH
107947: CALL_OW 69
107951: ST_TO_ADDR
// if not tmp then
107952: LD_VAR 0 2
107956: NOT
107957: IFFALSE 107961
// exit ;
107959: GO 107990
// for i in tmp do
107961: LD_ADDR_VAR 0 1
107965: PUSH
107966: LD_VAR 0 2
107970: PUSH
107971: FOR_IN
107972: IFFALSE 107988
// SetLives ( i , 600 ) ;
107974: LD_VAR 0 1
107978: PPUSH
107979: LD_INT 600
107981: PPUSH
107982: CALL_OW 234
107986: GO 107971
107988: POP
107989: POP
// end ;
107990: PPOPN 2
107992: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107993: LD_INT 0
107995: PPUSH
// case cmd of 301 :
107996: LD_VAR 0 1
108000: PUSH
108001: LD_INT 301
108003: DOUBLE
108004: EQUAL
108005: IFTRUE 108009
108007: GO 108041
108009: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
108010: LD_VAR 0 6
108014: PPUSH
108015: LD_VAR 0 7
108019: PPUSH
108020: LD_VAR 0 8
108024: PPUSH
108025: LD_VAR 0 4
108029: PPUSH
108030: LD_VAR 0 5
108034: PPUSH
108035: CALL 109250 0 5
108039: GO 108162
108041: LD_INT 302
108043: DOUBLE
108044: EQUAL
108045: IFTRUE 108049
108047: GO 108086
108049: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
108050: LD_VAR 0 6
108054: PPUSH
108055: LD_VAR 0 7
108059: PPUSH
108060: LD_VAR 0 8
108064: PPUSH
108065: LD_VAR 0 9
108069: PPUSH
108070: LD_VAR 0 4
108074: PPUSH
108075: LD_VAR 0 5
108079: PPUSH
108080: CALL 109341 0 6
108084: GO 108162
108086: LD_INT 303
108088: DOUBLE
108089: EQUAL
108090: IFTRUE 108094
108092: GO 108131
108094: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
108095: LD_VAR 0 6
108099: PPUSH
108100: LD_VAR 0 7
108104: PPUSH
108105: LD_VAR 0 8
108109: PPUSH
108110: LD_VAR 0 9
108114: PPUSH
108115: LD_VAR 0 4
108119: PPUSH
108120: LD_VAR 0 5
108124: PPUSH
108125: CALL 108167 0 6
108129: GO 108162
108131: LD_INT 304
108133: DOUBLE
108134: EQUAL
108135: IFTRUE 108139
108137: GO 108161
108139: POP
// hHackTeleport ( unit , x , y ) ; end ;
108140: LD_VAR 0 2
108144: PPUSH
108145: LD_VAR 0 4
108149: PPUSH
108150: LD_VAR 0 5
108154: PPUSH
108155: CALL 109934 0 3
108159: GO 108162
108161: POP
// end ;
108162: LD_VAR 0 12
108166: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
108167: LD_INT 0
108169: PPUSH
108170: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
108171: LD_VAR 0 1
108175: PUSH
108176: LD_INT 1
108178: LESS
108179: PUSH
108180: LD_VAR 0 1
108184: PUSH
108185: LD_INT 3
108187: GREATER
108188: OR
108189: PUSH
108190: LD_VAR 0 5
108194: PPUSH
108195: LD_VAR 0 6
108199: PPUSH
108200: CALL_OW 428
108204: OR
108205: IFFALSE 108209
// exit ;
108207: GO 108937
// uc_side := your_side ;
108209: LD_ADDR_OWVAR 20
108213: PUSH
108214: LD_OWVAR 2
108218: ST_TO_ADDR
// uc_nation := nation ;
108219: LD_ADDR_OWVAR 21
108223: PUSH
108224: LD_VAR 0 1
108228: ST_TO_ADDR
// bc_level = 1 ;
108229: LD_ADDR_OWVAR 43
108233: PUSH
108234: LD_INT 1
108236: ST_TO_ADDR
// case btype of 1 :
108237: LD_VAR 0 2
108241: PUSH
108242: LD_INT 1
108244: DOUBLE
108245: EQUAL
108246: IFTRUE 108250
108248: GO 108261
108250: POP
// bc_type := b_depot ; 2 :
108251: LD_ADDR_OWVAR 42
108255: PUSH
108256: LD_INT 0
108258: ST_TO_ADDR
108259: GO 108881
108261: LD_INT 2
108263: DOUBLE
108264: EQUAL
108265: IFTRUE 108269
108267: GO 108280
108269: POP
// bc_type := b_warehouse ; 3 :
108270: LD_ADDR_OWVAR 42
108274: PUSH
108275: LD_INT 1
108277: ST_TO_ADDR
108278: GO 108881
108280: LD_INT 3
108282: DOUBLE
108283: EQUAL
108284: IFTRUE 108288
108286: GO 108299
108288: POP
// bc_type := b_lab ; 4 .. 9 :
108289: LD_ADDR_OWVAR 42
108293: PUSH
108294: LD_INT 6
108296: ST_TO_ADDR
108297: GO 108881
108299: LD_INT 4
108301: DOUBLE
108302: GREATEREQUAL
108303: IFFALSE 108311
108305: LD_INT 9
108307: DOUBLE
108308: LESSEQUAL
108309: IFTRUE 108313
108311: GO 108373
108313: POP
// begin bc_type := b_lab_half ;
108314: LD_ADDR_OWVAR 42
108318: PUSH
108319: LD_INT 7
108321: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
108322: LD_ADDR_OWVAR 44
108326: PUSH
108327: LD_INT 10
108329: PUSH
108330: LD_INT 11
108332: PUSH
108333: LD_INT 12
108335: PUSH
108336: LD_INT 15
108338: PUSH
108339: LD_INT 14
108341: PUSH
108342: LD_INT 13
108344: PUSH
108345: EMPTY
108346: LIST
108347: LIST
108348: LIST
108349: LIST
108350: LIST
108351: LIST
108352: PUSH
108353: LD_VAR 0 2
108357: PUSH
108358: LD_INT 3
108360: MINUS
108361: ARRAY
108362: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
108363: LD_ADDR_OWVAR 45
108367: PUSH
108368: LD_INT 9
108370: ST_TO_ADDR
// end ; 10 .. 13 :
108371: GO 108881
108373: LD_INT 10
108375: DOUBLE
108376: GREATEREQUAL
108377: IFFALSE 108385
108379: LD_INT 13
108381: DOUBLE
108382: LESSEQUAL
108383: IFTRUE 108387
108385: GO 108464
108387: POP
// begin bc_type := b_lab_full ;
108388: LD_ADDR_OWVAR 42
108392: PUSH
108393: LD_INT 8
108395: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
108396: LD_ADDR_OWVAR 44
108400: PUSH
108401: LD_INT 10
108403: PUSH
108404: LD_INT 12
108406: PUSH
108407: LD_INT 14
108409: PUSH
108410: LD_INT 13
108412: PUSH
108413: EMPTY
108414: LIST
108415: LIST
108416: LIST
108417: LIST
108418: PUSH
108419: LD_VAR 0 2
108423: PUSH
108424: LD_INT 9
108426: MINUS
108427: ARRAY
108428: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
108429: LD_ADDR_OWVAR 45
108433: PUSH
108434: LD_INT 11
108436: PUSH
108437: LD_INT 15
108439: PUSH
108440: LD_INT 12
108442: PUSH
108443: LD_INT 15
108445: PUSH
108446: EMPTY
108447: LIST
108448: LIST
108449: LIST
108450: LIST
108451: PUSH
108452: LD_VAR 0 2
108456: PUSH
108457: LD_INT 9
108459: MINUS
108460: ARRAY
108461: ST_TO_ADDR
// end ; 14 :
108462: GO 108881
108464: LD_INT 14
108466: DOUBLE
108467: EQUAL
108468: IFTRUE 108472
108470: GO 108483
108472: POP
// bc_type := b_workshop ; 15 :
108473: LD_ADDR_OWVAR 42
108477: PUSH
108478: LD_INT 2
108480: ST_TO_ADDR
108481: GO 108881
108483: LD_INT 15
108485: DOUBLE
108486: EQUAL
108487: IFTRUE 108491
108489: GO 108502
108491: POP
// bc_type := b_factory ; 16 :
108492: LD_ADDR_OWVAR 42
108496: PUSH
108497: LD_INT 3
108499: ST_TO_ADDR
108500: GO 108881
108502: LD_INT 16
108504: DOUBLE
108505: EQUAL
108506: IFTRUE 108510
108508: GO 108521
108510: POP
// bc_type := b_ext_gun ; 17 :
108511: LD_ADDR_OWVAR 42
108515: PUSH
108516: LD_INT 17
108518: ST_TO_ADDR
108519: GO 108881
108521: LD_INT 17
108523: DOUBLE
108524: EQUAL
108525: IFTRUE 108529
108527: GO 108557
108529: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
108530: LD_ADDR_OWVAR 42
108534: PUSH
108535: LD_INT 19
108537: PUSH
108538: LD_INT 23
108540: PUSH
108541: LD_INT 19
108543: PUSH
108544: EMPTY
108545: LIST
108546: LIST
108547: LIST
108548: PUSH
108549: LD_VAR 0 1
108553: ARRAY
108554: ST_TO_ADDR
108555: GO 108881
108557: LD_INT 18
108559: DOUBLE
108560: EQUAL
108561: IFTRUE 108565
108563: GO 108576
108565: POP
// bc_type := b_ext_radar ; 19 :
108566: LD_ADDR_OWVAR 42
108570: PUSH
108571: LD_INT 20
108573: ST_TO_ADDR
108574: GO 108881
108576: LD_INT 19
108578: DOUBLE
108579: EQUAL
108580: IFTRUE 108584
108582: GO 108595
108584: POP
// bc_type := b_ext_radio ; 20 :
108585: LD_ADDR_OWVAR 42
108589: PUSH
108590: LD_INT 22
108592: ST_TO_ADDR
108593: GO 108881
108595: LD_INT 20
108597: DOUBLE
108598: EQUAL
108599: IFTRUE 108603
108601: GO 108614
108603: POP
// bc_type := b_ext_siberium ; 21 :
108604: LD_ADDR_OWVAR 42
108608: PUSH
108609: LD_INT 21
108611: ST_TO_ADDR
108612: GO 108881
108614: LD_INT 21
108616: DOUBLE
108617: EQUAL
108618: IFTRUE 108622
108620: GO 108633
108622: POP
// bc_type := b_ext_computer ; 22 :
108623: LD_ADDR_OWVAR 42
108627: PUSH
108628: LD_INT 24
108630: ST_TO_ADDR
108631: GO 108881
108633: LD_INT 22
108635: DOUBLE
108636: EQUAL
108637: IFTRUE 108641
108639: GO 108652
108641: POP
// bc_type := b_ext_track ; 23 :
108642: LD_ADDR_OWVAR 42
108646: PUSH
108647: LD_INT 16
108649: ST_TO_ADDR
108650: GO 108881
108652: LD_INT 23
108654: DOUBLE
108655: EQUAL
108656: IFTRUE 108660
108658: GO 108671
108660: POP
// bc_type := b_ext_laser ; 24 :
108661: LD_ADDR_OWVAR 42
108665: PUSH
108666: LD_INT 25
108668: ST_TO_ADDR
108669: GO 108881
108671: LD_INT 24
108673: DOUBLE
108674: EQUAL
108675: IFTRUE 108679
108677: GO 108690
108679: POP
// bc_type := b_control_tower ; 25 :
108680: LD_ADDR_OWVAR 42
108684: PUSH
108685: LD_INT 36
108687: ST_TO_ADDR
108688: GO 108881
108690: LD_INT 25
108692: DOUBLE
108693: EQUAL
108694: IFTRUE 108698
108696: GO 108709
108698: POP
// bc_type := b_breastwork ; 26 :
108699: LD_ADDR_OWVAR 42
108703: PUSH
108704: LD_INT 31
108706: ST_TO_ADDR
108707: GO 108881
108709: LD_INT 26
108711: DOUBLE
108712: EQUAL
108713: IFTRUE 108717
108715: GO 108728
108717: POP
// bc_type := b_bunker ; 27 :
108718: LD_ADDR_OWVAR 42
108722: PUSH
108723: LD_INT 32
108725: ST_TO_ADDR
108726: GO 108881
108728: LD_INT 27
108730: DOUBLE
108731: EQUAL
108732: IFTRUE 108736
108734: GO 108747
108736: POP
// bc_type := b_turret ; 28 :
108737: LD_ADDR_OWVAR 42
108741: PUSH
108742: LD_INT 33
108744: ST_TO_ADDR
108745: GO 108881
108747: LD_INT 28
108749: DOUBLE
108750: EQUAL
108751: IFTRUE 108755
108753: GO 108766
108755: POP
// bc_type := b_armoury ; 29 :
108756: LD_ADDR_OWVAR 42
108760: PUSH
108761: LD_INT 4
108763: ST_TO_ADDR
108764: GO 108881
108766: LD_INT 29
108768: DOUBLE
108769: EQUAL
108770: IFTRUE 108774
108772: GO 108785
108774: POP
// bc_type := b_barracks ; 30 :
108775: LD_ADDR_OWVAR 42
108779: PUSH
108780: LD_INT 5
108782: ST_TO_ADDR
108783: GO 108881
108785: LD_INT 30
108787: DOUBLE
108788: EQUAL
108789: IFTRUE 108793
108791: GO 108804
108793: POP
// bc_type := b_solar_power ; 31 :
108794: LD_ADDR_OWVAR 42
108798: PUSH
108799: LD_INT 27
108801: ST_TO_ADDR
108802: GO 108881
108804: LD_INT 31
108806: DOUBLE
108807: EQUAL
108808: IFTRUE 108812
108810: GO 108823
108812: POP
// bc_type := b_oil_power ; 32 :
108813: LD_ADDR_OWVAR 42
108817: PUSH
108818: LD_INT 26
108820: ST_TO_ADDR
108821: GO 108881
108823: LD_INT 32
108825: DOUBLE
108826: EQUAL
108827: IFTRUE 108831
108829: GO 108842
108831: POP
// bc_type := b_siberite_power ; 33 :
108832: LD_ADDR_OWVAR 42
108836: PUSH
108837: LD_INT 28
108839: ST_TO_ADDR
108840: GO 108881
108842: LD_INT 33
108844: DOUBLE
108845: EQUAL
108846: IFTRUE 108850
108848: GO 108861
108850: POP
// bc_type := b_oil_mine ; 34 :
108851: LD_ADDR_OWVAR 42
108855: PUSH
108856: LD_INT 29
108858: ST_TO_ADDR
108859: GO 108881
108861: LD_INT 34
108863: DOUBLE
108864: EQUAL
108865: IFTRUE 108869
108867: GO 108880
108869: POP
// bc_type := b_siberite_mine ; end ;
108870: LD_ADDR_OWVAR 42
108874: PUSH
108875: LD_INT 30
108877: ST_TO_ADDR
108878: GO 108881
108880: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108881: LD_ADDR_VAR 0 8
108885: PUSH
108886: LD_VAR 0 5
108890: PPUSH
108891: LD_VAR 0 6
108895: PPUSH
108896: LD_VAR 0 3
108900: PPUSH
108901: CALL_OW 47
108905: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108906: LD_OWVAR 42
108910: PUSH
108911: LD_INT 32
108913: PUSH
108914: LD_INT 33
108916: PUSH
108917: EMPTY
108918: LIST
108919: LIST
108920: IN
108921: IFFALSE 108937
// PlaceWeaponTurret ( b , weapon ) ;
108923: LD_VAR 0 8
108927: PPUSH
108928: LD_VAR 0 4
108932: PPUSH
108933: CALL_OW 431
// end ;
108937: LD_VAR 0 7
108941: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108942: LD_INT 0
108944: PPUSH
108945: PPUSH
108946: PPUSH
108947: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108948: LD_ADDR_VAR 0 4
108952: PUSH
108953: LD_INT 22
108955: PUSH
108956: LD_OWVAR 2
108960: PUSH
108961: EMPTY
108962: LIST
108963: LIST
108964: PUSH
108965: LD_INT 2
108967: PUSH
108968: LD_INT 30
108970: PUSH
108971: LD_INT 0
108973: PUSH
108974: EMPTY
108975: LIST
108976: LIST
108977: PUSH
108978: LD_INT 30
108980: PUSH
108981: LD_INT 1
108983: PUSH
108984: EMPTY
108985: LIST
108986: LIST
108987: PUSH
108988: EMPTY
108989: LIST
108990: LIST
108991: LIST
108992: PUSH
108993: EMPTY
108994: LIST
108995: LIST
108996: PPUSH
108997: CALL_OW 69
109001: ST_TO_ADDR
// if not tmp then
109002: LD_VAR 0 4
109006: NOT
109007: IFFALSE 109011
// exit ;
109009: GO 109070
// for i in tmp do
109011: LD_ADDR_VAR 0 2
109015: PUSH
109016: LD_VAR 0 4
109020: PUSH
109021: FOR_IN
109022: IFFALSE 109068
// for j = 1 to 3 do
109024: LD_ADDR_VAR 0 3
109028: PUSH
109029: DOUBLE
109030: LD_INT 1
109032: DEC
109033: ST_TO_ADDR
109034: LD_INT 3
109036: PUSH
109037: FOR_TO
109038: IFFALSE 109064
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
109040: LD_VAR 0 2
109044: PPUSH
109045: CALL_OW 274
109049: PPUSH
109050: LD_VAR 0 3
109054: PPUSH
109055: LD_INT 99999
109057: PPUSH
109058: CALL_OW 277
109062: GO 109037
109064: POP
109065: POP
109066: GO 109021
109068: POP
109069: POP
// end ;
109070: LD_VAR 0 1
109074: RET
// export function hHackSetLevel10 ; var i , j ; begin
109075: LD_INT 0
109077: PPUSH
109078: PPUSH
109079: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109080: LD_ADDR_VAR 0 2
109084: PUSH
109085: LD_INT 21
109087: PUSH
109088: LD_INT 1
109090: PUSH
109091: EMPTY
109092: LIST
109093: LIST
109094: PPUSH
109095: CALL_OW 69
109099: PUSH
109100: FOR_IN
109101: IFFALSE 109153
// if IsSelected ( i ) then
109103: LD_VAR 0 2
109107: PPUSH
109108: CALL_OW 306
109112: IFFALSE 109151
// begin for j := 1 to 4 do
109114: LD_ADDR_VAR 0 3
109118: PUSH
109119: DOUBLE
109120: LD_INT 1
109122: DEC
109123: ST_TO_ADDR
109124: LD_INT 4
109126: PUSH
109127: FOR_TO
109128: IFFALSE 109149
// SetSkill ( i , j , 10 ) ;
109130: LD_VAR 0 2
109134: PPUSH
109135: LD_VAR 0 3
109139: PPUSH
109140: LD_INT 10
109142: PPUSH
109143: CALL_OW 237
109147: GO 109127
109149: POP
109150: POP
// end ;
109151: GO 109100
109153: POP
109154: POP
// end ;
109155: LD_VAR 0 1
109159: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
109160: LD_INT 0
109162: PPUSH
109163: PPUSH
109164: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
109165: LD_ADDR_VAR 0 2
109169: PUSH
109170: LD_INT 22
109172: PUSH
109173: LD_OWVAR 2
109177: PUSH
109178: EMPTY
109179: LIST
109180: LIST
109181: PUSH
109182: LD_INT 21
109184: PUSH
109185: LD_INT 1
109187: PUSH
109188: EMPTY
109189: LIST
109190: LIST
109191: PUSH
109192: EMPTY
109193: LIST
109194: LIST
109195: PPUSH
109196: CALL_OW 69
109200: PUSH
109201: FOR_IN
109202: IFFALSE 109243
// begin for j := 1 to 4 do
109204: LD_ADDR_VAR 0 3
109208: PUSH
109209: DOUBLE
109210: LD_INT 1
109212: DEC
109213: ST_TO_ADDR
109214: LD_INT 4
109216: PUSH
109217: FOR_TO
109218: IFFALSE 109239
// SetSkill ( i , j , 10 ) ;
109220: LD_VAR 0 2
109224: PPUSH
109225: LD_VAR 0 3
109229: PPUSH
109230: LD_INT 10
109232: PPUSH
109233: CALL_OW 237
109237: GO 109217
109239: POP
109240: POP
// end ;
109241: GO 109201
109243: POP
109244: POP
// end ;
109245: LD_VAR 0 1
109249: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
109250: LD_INT 0
109252: PPUSH
// uc_side := your_side ;
109253: LD_ADDR_OWVAR 20
109257: PUSH
109258: LD_OWVAR 2
109262: ST_TO_ADDR
// uc_nation := nation ;
109263: LD_ADDR_OWVAR 21
109267: PUSH
109268: LD_VAR 0 1
109272: ST_TO_ADDR
// InitHc ;
109273: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
109277: LD_INT 0
109279: PPUSH
109280: LD_VAR 0 2
109284: PPUSH
109285: LD_VAR 0 3
109289: PPUSH
109290: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
109294: LD_VAR 0 4
109298: PPUSH
109299: LD_VAR 0 5
109303: PPUSH
109304: CALL_OW 428
109308: PUSH
109309: LD_INT 0
109311: EQUAL
109312: IFFALSE 109336
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
109314: CALL_OW 44
109318: PPUSH
109319: LD_VAR 0 4
109323: PPUSH
109324: LD_VAR 0 5
109328: PPUSH
109329: LD_INT 1
109331: PPUSH
109332: CALL_OW 48
// end ;
109336: LD_VAR 0 6
109340: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
109341: LD_INT 0
109343: PPUSH
109344: PPUSH
// uc_side := your_side ;
109345: LD_ADDR_OWVAR 20
109349: PUSH
109350: LD_OWVAR 2
109354: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
109355: LD_VAR 0 1
109359: PUSH
109360: LD_INT 1
109362: PUSH
109363: LD_INT 2
109365: PUSH
109366: LD_INT 3
109368: PUSH
109369: LD_INT 4
109371: PUSH
109372: LD_INT 5
109374: PUSH
109375: EMPTY
109376: LIST
109377: LIST
109378: LIST
109379: LIST
109380: LIST
109381: IN
109382: IFFALSE 109394
// uc_nation := nation_american else
109384: LD_ADDR_OWVAR 21
109388: PUSH
109389: LD_INT 1
109391: ST_TO_ADDR
109392: GO 109437
// if chassis in [ 11 , 12 , 13 , 14 ] then
109394: LD_VAR 0 1
109398: PUSH
109399: LD_INT 11
109401: PUSH
109402: LD_INT 12
109404: PUSH
109405: LD_INT 13
109407: PUSH
109408: LD_INT 14
109410: PUSH
109411: EMPTY
109412: LIST
109413: LIST
109414: LIST
109415: LIST
109416: IN
109417: IFFALSE 109429
// uc_nation := nation_arabian else
109419: LD_ADDR_OWVAR 21
109423: PUSH
109424: LD_INT 2
109426: ST_TO_ADDR
109427: GO 109437
// uc_nation := nation_russian ;
109429: LD_ADDR_OWVAR 21
109433: PUSH
109434: LD_INT 3
109436: ST_TO_ADDR
// vc_chassis := chassis ;
109437: LD_ADDR_OWVAR 37
109441: PUSH
109442: LD_VAR 0 1
109446: ST_TO_ADDR
// vc_engine := engine ;
109447: LD_ADDR_OWVAR 39
109451: PUSH
109452: LD_VAR 0 2
109456: ST_TO_ADDR
// vc_control := control ;
109457: LD_ADDR_OWVAR 38
109461: PUSH
109462: LD_VAR 0 3
109466: ST_TO_ADDR
// vc_weapon := weapon ;
109467: LD_ADDR_OWVAR 40
109471: PUSH
109472: LD_VAR 0 4
109476: ST_TO_ADDR
// un := CreateVehicle ;
109477: LD_ADDR_VAR 0 8
109481: PUSH
109482: CALL_OW 45
109486: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
109487: LD_VAR 0 8
109491: PPUSH
109492: LD_INT 0
109494: PPUSH
109495: LD_INT 5
109497: PPUSH
109498: CALL_OW 12
109502: PPUSH
109503: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
109507: LD_VAR 0 8
109511: PPUSH
109512: LD_VAR 0 5
109516: PPUSH
109517: LD_VAR 0 6
109521: PPUSH
109522: LD_INT 1
109524: PPUSH
109525: CALL_OW 48
// end ;
109529: LD_VAR 0 7
109533: RET
// export hInvincible ; every 1 do
109534: GO 109536
109536: DISABLE
// hInvincible := [ ] ;
109537: LD_ADDR_EXP 181
109541: PUSH
109542: EMPTY
109543: ST_TO_ADDR
109544: END
// every 10 do var i ;
109545: GO 109547
109547: DISABLE
109548: LD_INT 0
109550: PPUSH
// begin enable ;
109551: ENABLE
// if not hInvincible then
109552: LD_EXP 181
109556: NOT
109557: IFFALSE 109561
// exit ;
109559: GO 109605
// for i in hInvincible do
109561: LD_ADDR_VAR 0 1
109565: PUSH
109566: LD_EXP 181
109570: PUSH
109571: FOR_IN
109572: IFFALSE 109603
// if GetLives ( i ) < 1000 then
109574: LD_VAR 0 1
109578: PPUSH
109579: CALL_OW 256
109583: PUSH
109584: LD_INT 1000
109586: LESS
109587: IFFALSE 109601
// SetLives ( i , 1000 ) ;
109589: LD_VAR 0 1
109593: PPUSH
109594: LD_INT 1000
109596: PPUSH
109597: CALL_OW 234
109601: GO 109571
109603: POP
109604: POP
// end ;
109605: PPOPN 1
109607: END
// export function hHackInvincible ; var i ; begin
109608: LD_INT 0
109610: PPUSH
109611: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
109612: LD_ADDR_VAR 0 2
109616: PUSH
109617: LD_INT 2
109619: PUSH
109620: LD_INT 21
109622: PUSH
109623: LD_INT 1
109625: PUSH
109626: EMPTY
109627: LIST
109628: LIST
109629: PUSH
109630: LD_INT 21
109632: PUSH
109633: LD_INT 2
109635: PUSH
109636: EMPTY
109637: LIST
109638: LIST
109639: PUSH
109640: EMPTY
109641: LIST
109642: LIST
109643: LIST
109644: PPUSH
109645: CALL_OW 69
109649: PUSH
109650: FOR_IN
109651: IFFALSE 109712
// if IsSelected ( i ) then
109653: LD_VAR 0 2
109657: PPUSH
109658: CALL_OW 306
109662: IFFALSE 109710
// begin if i in hInvincible then
109664: LD_VAR 0 2
109668: PUSH
109669: LD_EXP 181
109673: IN
109674: IFFALSE 109694
// hInvincible := hInvincible diff i else
109676: LD_ADDR_EXP 181
109680: PUSH
109681: LD_EXP 181
109685: PUSH
109686: LD_VAR 0 2
109690: DIFF
109691: ST_TO_ADDR
109692: GO 109710
// hInvincible := hInvincible union i ;
109694: LD_ADDR_EXP 181
109698: PUSH
109699: LD_EXP 181
109703: PUSH
109704: LD_VAR 0 2
109708: UNION
109709: ST_TO_ADDR
// end ;
109710: GO 109650
109712: POP
109713: POP
// end ;
109714: LD_VAR 0 1
109718: RET
// export function hHackInvisible ; var i , j ; begin
109719: LD_INT 0
109721: PPUSH
109722: PPUSH
109723: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109724: LD_ADDR_VAR 0 2
109728: PUSH
109729: LD_INT 21
109731: PUSH
109732: LD_INT 1
109734: PUSH
109735: EMPTY
109736: LIST
109737: LIST
109738: PPUSH
109739: CALL_OW 69
109743: PUSH
109744: FOR_IN
109745: IFFALSE 109769
// if IsSelected ( i ) then
109747: LD_VAR 0 2
109751: PPUSH
109752: CALL_OW 306
109756: IFFALSE 109767
// ComForceInvisible ( i ) ;
109758: LD_VAR 0 2
109762: PPUSH
109763: CALL_OW 496
109767: GO 109744
109769: POP
109770: POP
// end ;
109771: LD_VAR 0 1
109775: RET
// export function hHackChangeYourSide ; begin
109776: LD_INT 0
109778: PPUSH
// if your_side = 8 then
109779: LD_OWVAR 2
109783: PUSH
109784: LD_INT 8
109786: EQUAL
109787: IFFALSE 109799
// your_side := 0 else
109789: LD_ADDR_OWVAR 2
109793: PUSH
109794: LD_INT 0
109796: ST_TO_ADDR
109797: GO 109813
// your_side := your_side + 1 ;
109799: LD_ADDR_OWVAR 2
109803: PUSH
109804: LD_OWVAR 2
109808: PUSH
109809: LD_INT 1
109811: PLUS
109812: ST_TO_ADDR
// end ;
109813: LD_VAR 0 1
109817: RET
// export function hHackChangeUnitSide ; var i , j ; begin
109818: LD_INT 0
109820: PPUSH
109821: PPUSH
109822: PPUSH
// for i in all_units do
109823: LD_ADDR_VAR 0 2
109827: PUSH
109828: LD_OWVAR 3
109832: PUSH
109833: FOR_IN
109834: IFFALSE 109912
// if IsSelected ( i ) then
109836: LD_VAR 0 2
109840: PPUSH
109841: CALL_OW 306
109845: IFFALSE 109910
// begin j := GetSide ( i ) ;
109847: LD_ADDR_VAR 0 3
109851: PUSH
109852: LD_VAR 0 2
109856: PPUSH
109857: CALL_OW 255
109861: ST_TO_ADDR
// if j = 8 then
109862: LD_VAR 0 3
109866: PUSH
109867: LD_INT 8
109869: EQUAL
109870: IFFALSE 109882
// j := 0 else
109872: LD_ADDR_VAR 0 3
109876: PUSH
109877: LD_INT 0
109879: ST_TO_ADDR
109880: GO 109896
// j := j + 1 ;
109882: LD_ADDR_VAR 0 3
109886: PUSH
109887: LD_VAR 0 3
109891: PUSH
109892: LD_INT 1
109894: PLUS
109895: ST_TO_ADDR
// SetSide ( i , j ) ;
109896: LD_VAR 0 2
109900: PPUSH
109901: LD_VAR 0 3
109905: PPUSH
109906: CALL_OW 235
// end ;
109910: GO 109833
109912: POP
109913: POP
// end ;
109914: LD_VAR 0 1
109918: RET
// export function hHackFog ; begin
109919: LD_INT 0
109921: PPUSH
// FogOff ( true ) ;
109922: LD_INT 1
109924: PPUSH
109925: CALL_OW 344
// end ;
109929: LD_VAR 0 1
109933: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109934: LD_INT 0
109936: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109937: LD_VAR 0 1
109941: PPUSH
109942: LD_VAR 0 2
109946: PPUSH
109947: LD_VAR 0 3
109951: PPUSH
109952: LD_INT 1
109954: PPUSH
109955: LD_INT 1
109957: PPUSH
109958: CALL_OW 483
// CenterOnXY ( x , y ) ;
109962: LD_VAR 0 2
109966: PPUSH
109967: LD_VAR 0 3
109971: PPUSH
109972: CALL_OW 84
// end ;
109976: LD_VAR 0 4
109980: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109981: LD_INT 0
109983: PPUSH
109984: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109985: LD_VAR 0 1
109989: NOT
109990: PUSH
109991: LD_VAR 0 2
109995: PPUSH
109996: LD_VAR 0 3
110000: PPUSH
110001: CALL_OW 488
110005: NOT
110006: OR
110007: PUSH
110008: LD_VAR 0 1
110012: PPUSH
110013: CALL_OW 266
110017: PUSH
110018: LD_INT 3
110020: NONEQUAL
110021: PUSH
110022: LD_VAR 0 1
110026: PPUSH
110027: CALL_OW 247
110031: PUSH
110032: LD_INT 1
110034: EQUAL
110035: NOT
110036: AND
110037: OR
110038: IFFALSE 110042
// exit ;
110040: GO 110191
// if GetType ( factory ) = unit_human then
110042: LD_VAR 0 1
110046: PPUSH
110047: CALL_OW 247
110051: PUSH
110052: LD_INT 1
110054: EQUAL
110055: IFFALSE 110072
// factory := IsInUnit ( factory ) ;
110057: LD_ADDR_VAR 0 1
110061: PUSH
110062: LD_VAR 0 1
110066: PPUSH
110067: CALL_OW 310
110071: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
110072: LD_VAR 0 1
110076: PPUSH
110077: CALL_OW 266
110081: PUSH
110082: LD_INT 3
110084: NONEQUAL
110085: IFFALSE 110089
// exit ;
110087: GO 110191
// if HexInfo ( x , y ) = factory then
110089: LD_VAR 0 2
110093: PPUSH
110094: LD_VAR 0 3
110098: PPUSH
110099: CALL_OW 428
110103: PUSH
110104: LD_VAR 0 1
110108: EQUAL
110109: IFFALSE 110136
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
110111: LD_ADDR_EXP 182
110115: PUSH
110116: LD_EXP 182
110120: PPUSH
110121: LD_VAR 0 1
110125: PPUSH
110126: LD_INT 0
110128: PPUSH
110129: CALL_OW 1
110133: ST_TO_ADDR
110134: GO 110187
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
110136: LD_ADDR_EXP 182
110140: PUSH
110141: LD_EXP 182
110145: PPUSH
110146: LD_VAR 0 1
110150: PPUSH
110151: LD_VAR 0 1
110155: PPUSH
110156: CALL_OW 255
110160: PUSH
110161: LD_VAR 0 1
110165: PUSH
110166: LD_VAR 0 2
110170: PUSH
110171: LD_VAR 0 3
110175: PUSH
110176: EMPTY
110177: LIST
110178: LIST
110179: LIST
110180: LIST
110181: PPUSH
110182: CALL_OW 1
110186: ST_TO_ADDR
// UpdateFactoryWaypoints ;
110187: CALL 110196 0 0
// end ;
110191: LD_VAR 0 4
110195: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
110196: LD_INT 0
110198: PPUSH
110199: PPUSH
110200: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
110201: LD_STRING resetFactoryWaypoint();
110203: PPUSH
110204: CALL_OW 559
// if factoryWaypoints then
110208: LD_EXP 182
110212: IFFALSE 110338
// begin list := PrepareArray ( factoryWaypoints ) ;
110214: LD_ADDR_VAR 0 3
110218: PUSH
110219: LD_EXP 182
110223: PPUSH
110224: CALL 94718 0 1
110228: ST_TO_ADDR
// for i := 1 to list do
110229: LD_ADDR_VAR 0 2
110233: PUSH
110234: DOUBLE
110235: LD_INT 1
110237: DEC
110238: ST_TO_ADDR
110239: LD_VAR 0 3
110243: PUSH
110244: FOR_TO
110245: IFFALSE 110336
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
110247: LD_STRING setFactoryWaypointXY(
110249: PUSH
110250: LD_VAR 0 3
110254: PUSH
110255: LD_VAR 0 2
110259: ARRAY
110260: PUSH
110261: LD_INT 1
110263: ARRAY
110264: STR
110265: PUSH
110266: LD_STRING ,
110268: STR
110269: PUSH
110270: LD_VAR 0 3
110274: PUSH
110275: LD_VAR 0 2
110279: ARRAY
110280: PUSH
110281: LD_INT 2
110283: ARRAY
110284: STR
110285: PUSH
110286: LD_STRING ,
110288: STR
110289: PUSH
110290: LD_VAR 0 3
110294: PUSH
110295: LD_VAR 0 2
110299: ARRAY
110300: PUSH
110301: LD_INT 3
110303: ARRAY
110304: STR
110305: PUSH
110306: LD_STRING ,
110308: STR
110309: PUSH
110310: LD_VAR 0 3
110314: PUSH
110315: LD_VAR 0 2
110319: ARRAY
110320: PUSH
110321: LD_INT 4
110323: ARRAY
110324: STR
110325: PUSH
110326: LD_STRING )
110328: STR
110329: PPUSH
110330: CALL_OW 559
110334: GO 110244
110336: POP
110337: POP
// end ; end ;
110338: LD_VAR 0 1
110342: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
110343: LD_INT 0
110345: PPUSH
// if HexInfo ( x , y ) = warehouse then
110346: LD_VAR 0 2
110350: PPUSH
110351: LD_VAR 0 3
110355: PPUSH
110356: CALL_OW 428
110360: PUSH
110361: LD_VAR 0 1
110365: EQUAL
110366: IFFALSE 110393
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
110368: LD_ADDR_EXP 183
110372: PUSH
110373: LD_EXP 183
110377: PPUSH
110378: LD_VAR 0 1
110382: PPUSH
110383: LD_INT 0
110385: PPUSH
110386: CALL_OW 1
110390: ST_TO_ADDR
110391: GO 110444
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
110393: LD_ADDR_EXP 183
110397: PUSH
110398: LD_EXP 183
110402: PPUSH
110403: LD_VAR 0 1
110407: PPUSH
110408: LD_VAR 0 1
110412: PPUSH
110413: CALL_OW 255
110417: PUSH
110418: LD_VAR 0 1
110422: PUSH
110423: LD_VAR 0 2
110427: PUSH
110428: LD_VAR 0 3
110432: PUSH
110433: EMPTY
110434: LIST
110435: LIST
110436: LIST
110437: LIST
110438: PPUSH
110439: CALL_OW 1
110443: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
110444: CALL 110453 0 0
// end ;
110448: LD_VAR 0 4
110452: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
110453: LD_INT 0
110455: PPUSH
110456: PPUSH
110457: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
110458: LD_STRING resetWarehouseGatheringPoints();
110460: PPUSH
110461: CALL_OW 559
// if warehouseGatheringPoints then
110465: LD_EXP 183
110469: IFFALSE 110595
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
110471: LD_ADDR_VAR 0 3
110475: PUSH
110476: LD_EXP 183
110480: PPUSH
110481: CALL 94718 0 1
110485: ST_TO_ADDR
// for i := 1 to list do
110486: LD_ADDR_VAR 0 2
110490: PUSH
110491: DOUBLE
110492: LD_INT 1
110494: DEC
110495: ST_TO_ADDR
110496: LD_VAR 0 3
110500: PUSH
110501: FOR_TO
110502: IFFALSE 110593
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
110504: LD_STRING setWarehouseGatheringPointXY(
110506: PUSH
110507: LD_VAR 0 3
110511: PUSH
110512: LD_VAR 0 2
110516: ARRAY
110517: PUSH
110518: LD_INT 1
110520: ARRAY
110521: STR
110522: PUSH
110523: LD_STRING ,
110525: STR
110526: PUSH
110527: LD_VAR 0 3
110531: PUSH
110532: LD_VAR 0 2
110536: ARRAY
110537: PUSH
110538: LD_INT 2
110540: ARRAY
110541: STR
110542: PUSH
110543: LD_STRING ,
110545: STR
110546: PUSH
110547: LD_VAR 0 3
110551: PUSH
110552: LD_VAR 0 2
110556: ARRAY
110557: PUSH
110558: LD_INT 3
110560: ARRAY
110561: STR
110562: PUSH
110563: LD_STRING ,
110565: STR
110566: PUSH
110567: LD_VAR 0 3
110571: PUSH
110572: LD_VAR 0 2
110576: ARRAY
110577: PUSH
110578: LD_INT 4
110580: ARRAY
110581: STR
110582: PUSH
110583: LD_STRING )
110585: STR
110586: PPUSH
110587: CALL_OW 559
110591: GO 110501
110593: POP
110594: POP
// end ; end ;
110595: LD_VAR 0 1
110599: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
110600: LD_EXP 183
110604: IFFALSE 111289
110606: GO 110608
110608: DISABLE
110609: LD_INT 0
110611: PPUSH
110612: PPUSH
110613: PPUSH
110614: PPUSH
110615: PPUSH
110616: PPUSH
110617: PPUSH
110618: PPUSH
110619: PPUSH
// begin enable ;
110620: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
110621: LD_ADDR_VAR 0 3
110625: PUSH
110626: LD_EXP 183
110630: PPUSH
110631: CALL 94718 0 1
110635: ST_TO_ADDR
// if not list then
110636: LD_VAR 0 3
110640: NOT
110641: IFFALSE 110645
// exit ;
110643: GO 111289
// for i := 1 to list do
110645: LD_ADDR_VAR 0 1
110649: PUSH
110650: DOUBLE
110651: LD_INT 1
110653: DEC
110654: ST_TO_ADDR
110655: LD_VAR 0 3
110659: PUSH
110660: FOR_TO
110661: IFFALSE 111287
// begin depot := list [ i ] [ 2 ] ;
110663: LD_ADDR_VAR 0 8
110667: PUSH
110668: LD_VAR 0 3
110672: PUSH
110673: LD_VAR 0 1
110677: ARRAY
110678: PUSH
110679: LD_INT 2
110681: ARRAY
110682: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
110683: LD_ADDR_VAR 0 5
110687: PUSH
110688: LD_VAR 0 3
110692: PUSH
110693: LD_VAR 0 1
110697: ARRAY
110698: PUSH
110699: LD_INT 1
110701: ARRAY
110702: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
110703: LD_VAR 0 8
110707: PPUSH
110708: CALL_OW 301
110712: PUSH
110713: LD_VAR 0 5
110717: PUSH
110718: LD_VAR 0 8
110722: PPUSH
110723: CALL_OW 255
110727: NONEQUAL
110728: OR
110729: IFFALSE 110758
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
110731: LD_ADDR_EXP 183
110735: PUSH
110736: LD_EXP 183
110740: PPUSH
110741: LD_VAR 0 8
110745: PPUSH
110746: LD_INT 0
110748: PPUSH
110749: CALL_OW 1
110753: ST_TO_ADDR
// exit ;
110754: POP
110755: POP
110756: GO 111289
// end ; x := list [ i ] [ 3 ] ;
110758: LD_ADDR_VAR 0 6
110762: PUSH
110763: LD_VAR 0 3
110767: PUSH
110768: LD_VAR 0 1
110772: ARRAY
110773: PUSH
110774: LD_INT 3
110776: ARRAY
110777: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
110778: LD_ADDR_VAR 0 7
110782: PUSH
110783: LD_VAR 0 3
110787: PUSH
110788: LD_VAR 0 1
110792: ARRAY
110793: PUSH
110794: LD_INT 4
110796: ARRAY
110797: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
110798: LD_ADDR_VAR 0 9
110802: PUSH
110803: LD_VAR 0 6
110807: PPUSH
110808: LD_VAR 0 7
110812: PPUSH
110813: LD_INT 16
110815: PPUSH
110816: CALL 93306 0 3
110820: ST_TO_ADDR
// if not cratesNearbyPoint then
110821: LD_VAR 0 9
110825: NOT
110826: IFFALSE 110832
// exit ;
110828: POP
110829: POP
110830: GO 111289
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
110832: LD_ADDR_VAR 0 4
110836: PUSH
110837: LD_INT 22
110839: PUSH
110840: LD_VAR 0 5
110844: PUSH
110845: EMPTY
110846: LIST
110847: LIST
110848: PUSH
110849: LD_INT 3
110851: PUSH
110852: LD_INT 60
110854: PUSH
110855: EMPTY
110856: LIST
110857: PUSH
110858: EMPTY
110859: LIST
110860: LIST
110861: PUSH
110862: LD_INT 91
110864: PUSH
110865: LD_VAR 0 8
110869: PUSH
110870: LD_INT 6
110872: PUSH
110873: EMPTY
110874: LIST
110875: LIST
110876: LIST
110877: PUSH
110878: LD_INT 2
110880: PUSH
110881: LD_INT 25
110883: PUSH
110884: LD_INT 2
110886: PUSH
110887: EMPTY
110888: LIST
110889: LIST
110890: PUSH
110891: LD_INT 25
110893: PUSH
110894: LD_INT 16
110896: PUSH
110897: EMPTY
110898: LIST
110899: LIST
110900: PUSH
110901: EMPTY
110902: LIST
110903: LIST
110904: LIST
110905: PUSH
110906: EMPTY
110907: LIST
110908: LIST
110909: LIST
110910: LIST
110911: PPUSH
110912: CALL_OW 69
110916: PUSH
110917: LD_VAR 0 8
110921: PPUSH
110922: CALL_OW 313
110926: PPUSH
110927: LD_INT 3
110929: PUSH
110930: LD_INT 60
110932: PUSH
110933: EMPTY
110934: LIST
110935: PUSH
110936: EMPTY
110937: LIST
110938: LIST
110939: PUSH
110940: LD_INT 2
110942: PUSH
110943: LD_INT 25
110945: PUSH
110946: LD_INT 2
110948: PUSH
110949: EMPTY
110950: LIST
110951: LIST
110952: PUSH
110953: LD_INT 25
110955: PUSH
110956: LD_INT 16
110958: PUSH
110959: EMPTY
110960: LIST
110961: LIST
110962: PUSH
110963: EMPTY
110964: LIST
110965: LIST
110966: LIST
110967: PUSH
110968: EMPTY
110969: LIST
110970: LIST
110971: PPUSH
110972: CALL_OW 72
110976: UNION
110977: ST_TO_ADDR
// if tmp then
110978: LD_VAR 0 4
110982: IFFALSE 111062
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110984: LD_ADDR_VAR 0 4
110988: PUSH
110989: LD_VAR 0 4
110993: PPUSH
110994: LD_INT 3
110996: PPUSH
110997: CALL 91275 0 2
111001: ST_TO_ADDR
// for j in tmp do
111002: LD_ADDR_VAR 0 2
111006: PUSH
111007: LD_VAR 0 4
111011: PUSH
111012: FOR_IN
111013: IFFALSE 111056
// begin if IsInUnit ( j ) then
111015: LD_VAR 0 2
111019: PPUSH
111020: CALL_OW 310
111024: IFFALSE 111035
// ComExit ( j ) ;
111026: LD_VAR 0 2
111030: PPUSH
111031: CALL 91358 0 1
// AddComCollect ( j , x , y ) ;
111035: LD_VAR 0 2
111039: PPUSH
111040: LD_VAR 0 6
111044: PPUSH
111045: LD_VAR 0 7
111049: PPUSH
111050: CALL_OW 177
// end ;
111054: GO 111012
111056: POP
111057: POP
// exit ;
111058: POP
111059: POP
111060: GO 111289
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
111062: LD_ADDR_VAR 0 4
111066: PUSH
111067: LD_INT 22
111069: PUSH
111070: LD_VAR 0 5
111074: PUSH
111075: EMPTY
111076: LIST
111077: LIST
111078: PUSH
111079: LD_INT 91
111081: PUSH
111082: LD_VAR 0 8
111086: PUSH
111087: LD_INT 8
111089: PUSH
111090: EMPTY
111091: LIST
111092: LIST
111093: LIST
111094: PUSH
111095: LD_INT 2
111097: PUSH
111098: LD_INT 34
111100: PUSH
111101: LD_INT 12
111103: PUSH
111104: EMPTY
111105: LIST
111106: LIST
111107: PUSH
111108: LD_INT 34
111110: PUSH
111111: LD_INT 51
111113: PUSH
111114: EMPTY
111115: LIST
111116: LIST
111117: PUSH
111118: LD_INT 34
111120: PUSH
111121: LD_INT 32
111123: PUSH
111124: EMPTY
111125: LIST
111126: LIST
111127: PUSH
111128: LD_INT 34
111130: PUSH
111131: LD_INT 89
111133: PUSH
111134: EMPTY
111135: LIST
111136: LIST
111137: PUSH
111138: EMPTY
111139: LIST
111140: LIST
111141: LIST
111142: LIST
111143: LIST
111144: PUSH
111145: EMPTY
111146: LIST
111147: LIST
111148: LIST
111149: PPUSH
111150: CALL_OW 69
111154: ST_TO_ADDR
// if tmp then
111155: LD_VAR 0 4
111159: IFFALSE 111285
// begin for j in tmp do
111161: LD_ADDR_VAR 0 2
111165: PUSH
111166: LD_VAR 0 4
111170: PUSH
111171: FOR_IN
111172: IFFALSE 111283
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
111174: LD_VAR 0 2
111178: PPUSH
111179: CALL_OW 262
111183: PUSH
111184: LD_INT 3
111186: EQUAL
111187: PUSH
111188: LD_VAR 0 2
111192: PPUSH
111193: CALL_OW 261
111197: PUSH
111198: LD_INT 20
111200: GREATER
111201: OR
111202: PUSH
111203: LD_VAR 0 2
111207: PPUSH
111208: CALL_OW 314
111212: NOT
111213: AND
111214: PUSH
111215: LD_VAR 0 2
111219: PPUSH
111220: CALL_OW 263
111224: PUSH
111225: LD_INT 1
111227: NONEQUAL
111228: PUSH
111229: LD_VAR 0 2
111233: PPUSH
111234: CALL_OW 311
111238: OR
111239: AND
111240: IFFALSE 111281
// begin ComCollect ( j , x , y ) ;
111242: LD_VAR 0 2
111246: PPUSH
111247: LD_VAR 0 6
111251: PPUSH
111252: LD_VAR 0 7
111256: PPUSH
111257: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
111261: LD_VAR 0 2
111265: PPUSH
111266: LD_VAR 0 8
111270: PPUSH
111271: CALL_OW 172
// exit ;
111275: POP
111276: POP
111277: POP
111278: POP
111279: GO 111289
// end ;
111281: GO 111171
111283: POP
111284: POP
// end ; end ;
111285: GO 110660
111287: POP
111288: POP
// end ; end_of_file
111289: PPOPN 9
111291: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
111292: LD_INT 0
111294: PPUSH
111295: PPUSH
111296: PPUSH
111297: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
111298: LD_VAR 0 1
111302: PPUSH
111303: CALL_OW 264
111307: PUSH
111308: LD_INT 91
111310: EQUAL
111311: IFFALSE 111383
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
111313: LD_INT 68
111315: PPUSH
111316: LD_VAR 0 1
111320: PPUSH
111321: CALL_OW 255
111325: PPUSH
111326: CALL_OW 321
111330: PUSH
111331: LD_INT 2
111333: EQUAL
111334: IFFALSE 111346
// eff := 70 else
111336: LD_ADDR_VAR 0 4
111340: PUSH
111341: LD_INT 70
111343: ST_TO_ADDR
111344: GO 111354
// eff := 30 ;
111346: LD_ADDR_VAR 0 4
111350: PUSH
111351: LD_INT 30
111353: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
111354: LD_VAR 0 1
111358: PPUSH
111359: CALL_OW 250
111363: PPUSH
111364: LD_VAR 0 1
111368: PPUSH
111369: CALL_OW 251
111373: PPUSH
111374: LD_VAR 0 4
111378: PPUSH
111379: CALL_OW 495
// end ; end ;
111383: LD_VAR 0 2
111387: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
111388: LD_INT 0
111390: PPUSH
// end ;
111391: LD_VAR 0 4
111395: RET
// export function SOS_Command ( cmd ) ; begin
111396: LD_INT 0
111398: PPUSH
// end ;
111399: LD_VAR 0 2
111403: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
111404: LD_INT 0
111406: PPUSH
// end ;
111407: LD_VAR 0 6
111411: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
111412: LD_INT 0
111414: PPUSH
111415: PPUSH
// if not vehicle or not factory then
111416: LD_VAR 0 1
111420: NOT
111421: PUSH
111422: LD_VAR 0 2
111426: NOT
111427: OR
111428: IFFALSE 111432
// exit ;
111430: GO 111663
// if factoryWaypoints >= factory then
111432: LD_EXP 182
111436: PUSH
111437: LD_VAR 0 2
111441: GREATEREQUAL
111442: IFFALSE 111663
// if factoryWaypoints [ factory ] then
111444: LD_EXP 182
111448: PUSH
111449: LD_VAR 0 2
111453: ARRAY
111454: IFFALSE 111663
// begin if GetControl ( vehicle ) = control_manual then
111456: LD_VAR 0 1
111460: PPUSH
111461: CALL_OW 263
111465: PUSH
111466: LD_INT 1
111468: EQUAL
111469: IFFALSE 111550
// begin driver := IsDrivenBy ( vehicle ) ;
111471: LD_ADDR_VAR 0 4
111475: PUSH
111476: LD_VAR 0 1
111480: PPUSH
111481: CALL_OW 311
111485: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
111486: LD_VAR 0 4
111490: PPUSH
111491: LD_EXP 182
111495: PUSH
111496: LD_VAR 0 2
111500: ARRAY
111501: PUSH
111502: LD_INT 3
111504: ARRAY
111505: PPUSH
111506: LD_EXP 182
111510: PUSH
111511: LD_VAR 0 2
111515: ARRAY
111516: PUSH
111517: LD_INT 4
111519: ARRAY
111520: PPUSH
111521: CALL_OW 171
// AddComExitVehicle ( driver ) ;
111525: LD_VAR 0 4
111529: PPUSH
111530: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
111534: LD_VAR 0 4
111538: PPUSH
111539: LD_VAR 0 2
111543: PPUSH
111544: CALL_OW 180
// end else
111548: GO 111663
// if GetControl ( vehicle ) = control_remote then
111550: LD_VAR 0 1
111554: PPUSH
111555: CALL_OW 263
111559: PUSH
111560: LD_INT 2
111562: EQUAL
111563: IFFALSE 111624
// begin wait ( 0 0$2 ) ;
111565: LD_INT 70
111567: PPUSH
111568: CALL_OW 67
// if Connect ( vehicle ) then
111572: LD_VAR 0 1
111576: PPUSH
111577: CALL 61566 0 1
111581: IFFALSE 111622
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
111583: LD_VAR 0 1
111587: PPUSH
111588: LD_EXP 182
111592: PUSH
111593: LD_VAR 0 2
111597: ARRAY
111598: PUSH
111599: LD_INT 3
111601: ARRAY
111602: PPUSH
111603: LD_EXP 182
111607: PUSH
111608: LD_VAR 0 2
111612: ARRAY
111613: PUSH
111614: LD_INT 4
111616: ARRAY
111617: PPUSH
111618: CALL_OW 171
// end else
111622: GO 111663
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
111624: LD_VAR 0 1
111628: PPUSH
111629: LD_EXP 182
111633: PUSH
111634: LD_VAR 0 2
111638: ARRAY
111639: PUSH
111640: LD_INT 3
111642: ARRAY
111643: PPUSH
111644: LD_EXP 182
111648: PUSH
111649: LD_VAR 0 2
111653: ARRAY
111654: PUSH
111655: LD_INT 4
111657: ARRAY
111658: PPUSH
111659: CALL_OW 171
// end ; end ;
111663: LD_VAR 0 3
111667: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
111668: LD_INT 0
111670: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
111671: LD_VAR 0 1
111675: PUSH
111676: LD_INT 250
111678: EQUAL
111679: PUSH
111680: LD_VAR 0 2
111684: PPUSH
111685: CALL_OW 264
111689: PUSH
111690: LD_INT 81
111692: EQUAL
111693: AND
111694: IFFALSE 111715
// MinerPlaceMine ( unit , x , y ) ;
111696: LD_VAR 0 2
111700: PPUSH
111701: LD_VAR 0 4
111705: PPUSH
111706: LD_VAR 0 5
111710: PPUSH
111711: CALL 114705 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
111715: LD_VAR 0 1
111719: PUSH
111720: LD_INT 251
111722: EQUAL
111723: PUSH
111724: LD_VAR 0 2
111728: PPUSH
111729: CALL_OW 264
111733: PUSH
111734: LD_INT 81
111736: EQUAL
111737: AND
111738: IFFALSE 111759
// MinerDetonateMine ( unit , x , y ) ;
111740: LD_VAR 0 2
111744: PPUSH
111745: LD_VAR 0 4
111749: PPUSH
111750: LD_VAR 0 5
111754: PPUSH
111755: CALL 114980 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
111759: LD_VAR 0 1
111763: PUSH
111764: LD_INT 252
111766: EQUAL
111767: PUSH
111768: LD_VAR 0 2
111772: PPUSH
111773: CALL_OW 264
111777: PUSH
111778: LD_INT 81
111780: EQUAL
111781: AND
111782: IFFALSE 111803
// MinerCreateMinefield ( unit , x , y ) ;
111784: LD_VAR 0 2
111788: PPUSH
111789: LD_VAR 0 4
111793: PPUSH
111794: LD_VAR 0 5
111798: PPUSH
111799: CALL 115397 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
111803: LD_VAR 0 1
111807: PUSH
111808: LD_INT 253
111810: EQUAL
111811: PUSH
111812: LD_VAR 0 2
111816: PPUSH
111817: CALL_OW 257
111821: PUSH
111822: LD_INT 5
111824: EQUAL
111825: AND
111826: IFFALSE 111847
// ComBinocular ( unit , x , y ) ;
111828: LD_VAR 0 2
111832: PPUSH
111833: LD_VAR 0 4
111837: PPUSH
111838: LD_VAR 0 5
111842: PPUSH
111843: CALL 115766 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
111847: LD_VAR 0 1
111851: PUSH
111852: LD_INT 254
111854: EQUAL
111855: PUSH
111856: LD_VAR 0 2
111860: PPUSH
111861: CALL_OW 264
111865: PUSH
111866: LD_INT 99
111868: EQUAL
111869: AND
111870: PUSH
111871: LD_VAR 0 3
111875: PPUSH
111876: CALL_OW 263
111880: PUSH
111881: LD_INT 3
111883: EQUAL
111884: AND
111885: IFFALSE 111901
// HackDestroyVehicle ( unit , selectedUnit ) ;
111887: LD_VAR 0 2
111891: PPUSH
111892: LD_VAR 0 3
111896: PPUSH
111897: CALL 114069 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
111901: LD_VAR 0 1
111905: PUSH
111906: LD_INT 255
111908: EQUAL
111909: PUSH
111910: LD_VAR 0 2
111914: PPUSH
111915: CALL_OW 264
111919: PUSH
111920: LD_INT 14
111922: PUSH
111923: LD_INT 53
111925: PUSH
111926: EMPTY
111927: LIST
111928: LIST
111929: IN
111930: AND
111931: PUSH
111932: LD_VAR 0 4
111936: PPUSH
111937: LD_VAR 0 5
111941: PPUSH
111942: CALL_OW 488
111946: AND
111947: IFFALSE 111971
// CutTreeXYR ( unit , x , y , 12 ) ;
111949: LD_VAR 0 2
111953: PPUSH
111954: LD_VAR 0 4
111958: PPUSH
111959: LD_VAR 0 5
111963: PPUSH
111964: LD_INT 12
111966: PPUSH
111967: CALL 112066 0 4
// if cmd = 256 then
111971: LD_VAR 0 1
111975: PUSH
111976: LD_INT 256
111978: EQUAL
111979: IFFALSE 112000
// SetFactoryWaypoint ( unit , x , y ) ;
111981: LD_VAR 0 2
111985: PPUSH
111986: LD_VAR 0 4
111990: PPUSH
111991: LD_VAR 0 5
111995: PPUSH
111996: CALL 109981 0 3
// if cmd = 257 then
112000: LD_VAR 0 1
112004: PUSH
112005: LD_INT 257
112007: EQUAL
112008: IFFALSE 112029
// SetWarehouseGatheringPoint ( unit , x , y ) ;
112010: LD_VAR 0 2
112014: PPUSH
112015: LD_VAR 0 4
112019: PPUSH
112020: LD_VAR 0 5
112024: PPUSH
112025: CALL 110343 0 3
// if cmd = 258 then
112029: LD_VAR 0 1
112033: PUSH
112034: LD_INT 258
112036: EQUAL
112037: IFFALSE 112061
// BurnTreeXYR ( unit , x , y , 8 ) ;
112039: LD_VAR 0 2
112043: PPUSH
112044: LD_VAR 0 4
112048: PPUSH
112049: LD_VAR 0 5
112053: PPUSH
112054: LD_INT 8
112056: PPUSH
112057: CALL 112460 0 4
// end ;
112061: LD_VAR 0 6
112065: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
112066: LD_INT 0
112068: PPUSH
112069: PPUSH
112070: PPUSH
112071: PPUSH
112072: PPUSH
112073: PPUSH
112074: PPUSH
112075: PPUSH
112076: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
112077: LD_VAR 0 1
112081: PPUSH
112082: CALL_OW 302
112086: NOT
112087: PUSH
112088: LD_VAR 0 2
112092: PPUSH
112093: LD_VAR 0 3
112097: PPUSH
112098: CALL_OW 488
112102: NOT
112103: OR
112104: PUSH
112105: LD_VAR 0 4
112109: NOT
112110: OR
112111: IFFALSE 112115
// exit ;
112113: GO 112455
// list := [ ] ;
112115: LD_ADDR_VAR 0 13
112119: PUSH
112120: EMPTY
112121: ST_TO_ADDR
// if x - r < 0 then
112122: LD_VAR 0 2
112126: PUSH
112127: LD_VAR 0 4
112131: MINUS
112132: PUSH
112133: LD_INT 0
112135: LESS
112136: IFFALSE 112148
// min_x := 0 else
112138: LD_ADDR_VAR 0 7
112142: PUSH
112143: LD_INT 0
112145: ST_TO_ADDR
112146: GO 112164
// min_x := x - r ;
112148: LD_ADDR_VAR 0 7
112152: PUSH
112153: LD_VAR 0 2
112157: PUSH
112158: LD_VAR 0 4
112162: MINUS
112163: ST_TO_ADDR
// if y - r < 0 then
112164: LD_VAR 0 3
112168: PUSH
112169: LD_VAR 0 4
112173: MINUS
112174: PUSH
112175: LD_INT 0
112177: LESS
112178: IFFALSE 112190
// min_y := 0 else
112180: LD_ADDR_VAR 0 8
112184: PUSH
112185: LD_INT 0
112187: ST_TO_ADDR
112188: GO 112206
// min_y := y - r ;
112190: LD_ADDR_VAR 0 8
112194: PUSH
112195: LD_VAR 0 3
112199: PUSH
112200: LD_VAR 0 4
112204: MINUS
112205: ST_TO_ADDR
// max_x := x + r ;
112206: LD_ADDR_VAR 0 9
112210: PUSH
112211: LD_VAR 0 2
112215: PUSH
112216: LD_VAR 0 4
112220: PLUS
112221: ST_TO_ADDR
// max_y := y + r ;
112222: LD_ADDR_VAR 0 10
112226: PUSH
112227: LD_VAR 0 3
112231: PUSH
112232: LD_VAR 0 4
112236: PLUS
112237: ST_TO_ADDR
// for _x = min_x to max_x do
112238: LD_ADDR_VAR 0 11
112242: PUSH
112243: DOUBLE
112244: LD_VAR 0 7
112248: DEC
112249: ST_TO_ADDR
112250: LD_VAR 0 9
112254: PUSH
112255: FOR_TO
112256: IFFALSE 112373
// for _y = min_y to max_y do
112258: LD_ADDR_VAR 0 12
112262: PUSH
112263: DOUBLE
112264: LD_VAR 0 8
112268: DEC
112269: ST_TO_ADDR
112270: LD_VAR 0 10
112274: PUSH
112275: FOR_TO
112276: IFFALSE 112369
// begin if not ValidHex ( _x , _y ) then
112278: LD_VAR 0 11
112282: PPUSH
112283: LD_VAR 0 12
112287: PPUSH
112288: CALL_OW 488
112292: NOT
112293: IFFALSE 112297
// continue ;
112295: GO 112275
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112297: LD_VAR 0 11
112301: PPUSH
112302: LD_VAR 0 12
112306: PPUSH
112307: CALL_OW 351
112311: PUSH
112312: LD_VAR 0 11
112316: PPUSH
112317: LD_VAR 0 12
112321: PPUSH
112322: CALL_OW 554
112326: AND
112327: IFFALSE 112367
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112329: LD_ADDR_VAR 0 13
112333: PUSH
112334: LD_VAR 0 13
112338: PPUSH
112339: LD_VAR 0 13
112343: PUSH
112344: LD_INT 1
112346: PLUS
112347: PPUSH
112348: LD_VAR 0 11
112352: PUSH
112353: LD_VAR 0 12
112357: PUSH
112358: EMPTY
112359: LIST
112360: LIST
112361: PPUSH
112362: CALL_OW 2
112366: ST_TO_ADDR
// end ;
112367: GO 112275
112369: POP
112370: POP
112371: GO 112255
112373: POP
112374: POP
// if not list then
112375: LD_VAR 0 13
112379: NOT
112380: IFFALSE 112384
// exit ;
112382: GO 112455
// for i in list do
112384: LD_ADDR_VAR 0 6
112388: PUSH
112389: LD_VAR 0 13
112393: PUSH
112394: FOR_IN
112395: IFFALSE 112453
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
112397: LD_VAR 0 1
112401: PPUSH
112402: LD_STRING M
112404: PUSH
112405: LD_VAR 0 6
112409: PUSH
112410: LD_INT 1
112412: ARRAY
112413: PUSH
112414: LD_VAR 0 6
112418: PUSH
112419: LD_INT 2
112421: ARRAY
112422: PUSH
112423: LD_INT 0
112425: PUSH
112426: LD_INT 0
112428: PUSH
112429: LD_INT 0
112431: PUSH
112432: LD_INT 0
112434: PUSH
112435: EMPTY
112436: LIST
112437: LIST
112438: LIST
112439: LIST
112440: LIST
112441: LIST
112442: LIST
112443: PUSH
112444: EMPTY
112445: LIST
112446: PPUSH
112447: CALL_OW 447
112451: GO 112394
112453: POP
112454: POP
// end ;
112455: LD_VAR 0 5
112459: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
112460: LD_INT 0
112462: PPUSH
112463: PPUSH
112464: PPUSH
112465: PPUSH
112466: PPUSH
112467: PPUSH
112468: PPUSH
112469: PPUSH
112470: PPUSH
112471: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
112472: LD_VAR 0 1
112476: PPUSH
112477: CALL_OW 302
112481: NOT
112482: PUSH
112483: LD_VAR 0 2
112487: PPUSH
112488: LD_VAR 0 3
112492: PPUSH
112493: CALL_OW 488
112497: NOT
112498: OR
112499: PUSH
112500: LD_VAR 0 4
112504: NOT
112505: OR
112506: IFFALSE 112510
// exit ;
112508: GO 113023
// list := [ ] ;
112510: LD_ADDR_VAR 0 13
112514: PUSH
112515: EMPTY
112516: ST_TO_ADDR
// if x - r < 0 then
112517: LD_VAR 0 2
112521: PUSH
112522: LD_VAR 0 4
112526: MINUS
112527: PUSH
112528: LD_INT 0
112530: LESS
112531: IFFALSE 112543
// min_x := 0 else
112533: LD_ADDR_VAR 0 7
112537: PUSH
112538: LD_INT 0
112540: ST_TO_ADDR
112541: GO 112559
// min_x := x - r ;
112543: LD_ADDR_VAR 0 7
112547: PUSH
112548: LD_VAR 0 2
112552: PUSH
112553: LD_VAR 0 4
112557: MINUS
112558: ST_TO_ADDR
// if y - r < 0 then
112559: LD_VAR 0 3
112563: PUSH
112564: LD_VAR 0 4
112568: MINUS
112569: PUSH
112570: LD_INT 0
112572: LESS
112573: IFFALSE 112585
// min_y := 0 else
112575: LD_ADDR_VAR 0 8
112579: PUSH
112580: LD_INT 0
112582: ST_TO_ADDR
112583: GO 112601
// min_y := y - r ;
112585: LD_ADDR_VAR 0 8
112589: PUSH
112590: LD_VAR 0 3
112594: PUSH
112595: LD_VAR 0 4
112599: MINUS
112600: ST_TO_ADDR
// max_x := x + r ;
112601: LD_ADDR_VAR 0 9
112605: PUSH
112606: LD_VAR 0 2
112610: PUSH
112611: LD_VAR 0 4
112615: PLUS
112616: ST_TO_ADDR
// max_y := y + r ;
112617: LD_ADDR_VAR 0 10
112621: PUSH
112622: LD_VAR 0 3
112626: PUSH
112627: LD_VAR 0 4
112631: PLUS
112632: ST_TO_ADDR
// for _x = min_x to max_x do
112633: LD_ADDR_VAR 0 11
112637: PUSH
112638: DOUBLE
112639: LD_VAR 0 7
112643: DEC
112644: ST_TO_ADDR
112645: LD_VAR 0 9
112649: PUSH
112650: FOR_TO
112651: IFFALSE 112768
// for _y = min_y to max_y do
112653: LD_ADDR_VAR 0 12
112657: PUSH
112658: DOUBLE
112659: LD_VAR 0 8
112663: DEC
112664: ST_TO_ADDR
112665: LD_VAR 0 10
112669: PUSH
112670: FOR_TO
112671: IFFALSE 112764
// begin if not ValidHex ( _x , _y ) then
112673: LD_VAR 0 11
112677: PPUSH
112678: LD_VAR 0 12
112682: PPUSH
112683: CALL_OW 488
112687: NOT
112688: IFFALSE 112692
// continue ;
112690: GO 112670
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112692: LD_VAR 0 11
112696: PPUSH
112697: LD_VAR 0 12
112701: PPUSH
112702: CALL_OW 351
112706: PUSH
112707: LD_VAR 0 11
112711: PPUSH
112712: LD_VAR 0 12
112716: PPUSH
112717: CALL_OW 554
112721: AND
112722: IFFALSE 112762
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112724: LD_ADDR_VAR 0 13
112728: PUSH
112729: LD_VAR 0 13
112733: PPUSH
112734: LD_VAR 0 13
112738: PUSH
112739: LD_INT 1
112741: PLUS
112742: PPUSH
112743: LD_VAR 0 11
112747: PUSH
112748: LD_VAR 0 12
112752: PUSH
112753: EMPTY
112754: LIST
112755: LIST
112756: PPUSH
112757: CALL_OW 2
112761: ST_TO_ADDR
// end ;
112762: GO 112670
112764: POP
112765: POP
112766: GO 112650
112768: POP
112769: POP
// if not list then
112770: LD_VAR 0 13
112774: NOT
112775: IFFALSE 112779
// exit ;
112777: GO 113023
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
112779: LD_ADDR_VAR 0 13
112783: PUSH
112784: LD_VAR 0 1
112788: PPUSH
112789: LD_VAR 0 13
112793: PPUSH
112794: LD_INT 1
112796: PPUSH
112797: LD_INT 1
112799: PPUSH
112800: CALL 58708 0 4
112804: ST_TO_ADDR
// ComStop ( flame ) ;
112805: LD_VAR 0 1
112809: PPUSH
112810: CALL_OW 141
// for i in list do
112814: LD_ADDR_VAR 0 6
112818: PUSH
112819: LD_VAR 0 13
112823: PUSH
112824: FOR_IN
112825: IFFALSE 112856
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
112827: LD_VAR 0 1
112831: PPUSH
112832: LD_VAR 0 6
112836: PUSH
112837: LD_INT 1
112839: ARRAY
112840: PPUSH
112841: LD_VAR 0 6
112845: PUSH
112846: LD_INT 2
112848: ARRAY
112849: PPUSH
112850: CALL_OW 176
112854: GO 112824
112856: POP
112857: POP
// repeat wait ( 0 0$1 ) ;
112858: LD_INT 35
112860: PPUSH
112861: CALL_OW 67
// task := GetTaskList ( flame ) ;
112865: LD_ADDR_VAR 0 14
112869: PUSH
112870: LD_VAR 0 1
112874: PPUSH
112875: CALL_OW 437
112879: ST_TO_ADDR
// if not task then
112880: LD_VAR 0 14
112884: NOT
112885: IFFALSE 112889
// exit ;
112887: GO 113023
// if task [ 1 ] [ 1 ] <> | then
112889: LD_VAR 0 14
112893: PUSH
112894: LD_INT 1
112896: ARRAY
112897: PUSH
112898: LD_INT 1
112900: ARRAY
112901: PUSH
112902: LD_STRING |
112904: NONEQUAL
112905: IFFALSE 112909
// exit ;
112907: GO 113023
// _x := task [ 1 ] [ 2 ] ;
112909: LD_ADDR_VAR 0 11
112913: PUSH
112914: LD_VAR 0 14
112918: PUSH
112919: LD_INT 1
112921: ARRAY
112922: PUSH
112923: LD_INT 2
112925: ARRAY
112926: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
112927: LD_ADDR_VAR 0 12
112931: PUSH
112932: LD_VAR 0 14
112936: PUSH
112937: LD_INT 1
112939: ARRAY
112940: PUSH
112941: LD_INT 3
112943: ARRAY
112944: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
112945: LD_VAR 0 11
112949: PPUSH
112950: LD_VAR 0 12
112954: PPUSH
112955: CALL_OW 351
112959: NOT
112960: PUSH
112961: LD_VAR 0 11
112965: PPUSH
112966: LD_VAR 0 12
112970: PPUSH
112971: CALL_OW 554
112975: NOT
112976: OR
112977: IFFALSE 113011
// begin task := Delete ( task , 1 ) ;
112979: LD_ADDR_VAR 0 14
112983: PUSH
112984: LD_VAR 0 14
112988: PPUSH
112989: LD_INT 1
112991: PPUSH
112992: CALL_OW 3
112996: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
112997: LD_VAR 0 1
113001: PPUSH
113002: LD_VAR 0 14
113006: PPUSH
113007: CALL_OW 446
// end ; until not HasTask ( flame ) ;
113011: LD_VAR 0 1
113015: PPUSH
113016: CALL_OW 314
113020: NOT
113021: IFFALSE 112858
// end ;
113023: LD_VAR 0 5
113027: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
113028: LD_EXP 185
113032: NOT
113033: IFFALSE 113083
113035: GO 113037
113037: DISABLE
// begin initHack := true ;
113038: LD_ADDR_EXP 185
113042: PUSH
113043: LD_INT 1
113045: ST_TO_ADDR
// hackTanks := [ ] ;
113046: LD_ADDR_EXP 186
113050: PUSH
113051: EMPTY
113052: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
113053: LD_ADDR_EXP 187
113057: PUSH
113058: EMPTY
113059: ST_TO_ADDR
// hackLimit := 3 ;
113060: LD_ADDR_EXP 188
113064: PUSH
113065: LD_INT 3
113067: ST_TO_ADDR
// hackDist := 12 ;
113068: LD_ADDR_EXP 189
113072: PUSH
113073: LD_INT 12
113075: ST_TO_ADDR
// hackCounter := [ ] ;
113076: LD_ADDR_EXP 190
113080: PUSH
113081: EMPTY
113082: ST_TO_ADDR
// end ;
113083: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
113084: LD_EXP 185
113088: PUSH
113089: LD_INT 34
113091: PUSH
113092: LD_INT 99
113094: PUSH
113095: EMPTY
113096: LIST
113097: LIST
113098: PPUSH
113099: CALL_OW 69
113103: AND
113104: IFFALSE 113357
113106: GO 113108
113108: DISABLE
113109: LD_INT 0
113111: PPUSH
113112: PPUSH
// begin enable ;
113113: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
113114: LD_ADDR_VAR 0 1
113118: PUSH
113119: LD_INT 34
113121: PUSH
113122: LD_INT 99
113124: PUSH
113125: EMPTY
113126: LIST
113127: LIST
113128: PPUSH
113129: CALL_OW 69
113133: PUSH
113134: FOR_IN
113135: IFFALSE 113355
// begin if not i in hackTanks then
113137: LD_VAR 0 1
113141: PUSH
113142: LD_EXP 186
113146: IN
113147: NOT
113148: IFFALSE 113231
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
113150: LD_ADDR_EXP 186
113154: PUSH
113155: LD_EXP 186
113159: PPUSH
113160: LD_EXP 186
113164: PUSH
113165: LD_INT 1
113167: PLUS
113168: PPUSH
113169: LD_VAR 0 1
113173: PPUSH
113174: CALL_OW 1
113178: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
113179: LD_ADDR_EXP 187
113183: PUSH
113184: LD_EXP 187
113188: PPUSH
113189: LD_EXP 187
113193: PUSH
113194: LD_INT 1
113196: PLUS
113197: PPUSH
113198: EMPTY
113199: PPUSH
113200: CALL_OW 1
113204: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
113205: LD_ADDR_EXP 190
113209: PUSH
113210: LD_EXP 190
113214: PPUSH
113215: LD_EXP 190
113219: PUSH
113220: LD_INT 1
113222: PLUS
113223: PPUSH
113224: EMPTY
113225: PPUSH
113226: CALL_OW 1
113230: ST_TO_ADDR
// end ; if not IsOk ( i ) then
113231: LD_VAR 0 1
113235: PPUSH
113236: CALL_OW 302
113240: NOT
113241: IFFALSE 113254
// begin HackUnlinkAll ( i ) ;
113243: LD_VAR 0 1
113247: PPUSH
113248: CALL 113360 0 1
// continue ;
113252: GO 113134
// end ; HackCheckCapturedStatus ( i ) ;
113254: LD_VAR 0 1
113258: PPUSH
113259: CALL 113803 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
113263: LD_ADDR_VAR 0 2
113267: PUSH
113268: LD_INT 81
113270: PUSH
113271: LD_VAR 0 1
113275: PPUSH
113276: CALL_OW 255
113280: PUSH
113281: EMPTY
113282: LIST
113283: LIST
113284: PUSH
113285: LD_INT 33
113287: PUSH
113288: LD_INT 3
113290: PUSH
113291: EMPTY
113292: LIST
113293: LIST
113294: PUSH
113295: LD_INT 91
113297: PUSH
113298: LD_VAR 0 1
113302: PUSH
113303: LD_EXP 189
113307: PUSH
113308: EMPTY
113309: LIST
113310: LIST
113311: LIST
113312: PUSH
113313: LD_INT 50
113315: PUSH
113316: EMPTY
113317: LIST
113318: PUSH
113319: EMPTY
113320: LIST
113321: LIST
113322: LIST
113323: LIST
113324: PPUSH
113325: CALL_OW 69
113329: ST_TO_ADDR
// if not tmp then
113330: LD_VAR 0 2
113334: NOT
113335: IFFALSE 113339
// continue ;
113337: GO 113134
// HackLink ( i , tmp ) ;
113339: LD_VAR 0 1
113343: PPUSH
113344: LD_VAR 0 2
113348: PPUSH
113349: CALL 113496 0 2
// end ;
113353: GO 113134
113355: POP
113356: POP
// end ;
113357: PPOPN 2
113359: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
113360: LD_INT 0
113362: PPUSH
113363: PPUSH
113364: PPUSH
// if not hack in hackTanks then
113365: LD_VAR 0 1
113369: PUSH
113370: LD_EXP 186
113374: IN
113375: NOT
113376: IFFALSE 113380
// exit ;
113378: GO 113491
// index := GetElementIndex ( hackTanks , hack ) ;
113380: LD_ADDR_VAR 0 4
113384: PUSH
113385: LD_EXP 186
113389: PPUSH
113390: LD_VAR 0 1
113394: PPUSH
113395: CALL 58005 0 2
113399: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
113400: LD_EXP 187
113404: PUSH
113405: LD_VAR 0 4
113409: ARRAY
113410: IFFALSE 113491
// begin for i in hackTanksCaptured [ index ] do
113412: LD_ADDR_VAR 0 3
113416: PUSH
113417: LD_EXP 187
113421: PUSH
113422: LD_VAR 0 4
113426: ARRAY
113427: PUSH
113428: FOR_IN
113429: IFFALSE 113455
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
113431: LD_VAR 0 3
113435: PUSH
113436: LD_INT 1
113438: ARRAY
113439: PPUSH
113440: LD_VAR 0 3
113444: PUSH
113445: LD_INT 2
113447: ARRAY
113448: PPUSH
113449: CALL_OW 235
113453: GO 113428
113455: POP
113456: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
113457: LD_ADDR_EXP 187
113461: PUSH
113462: LD_EXP 187
113466: PPUSH
113467: LD_VAR 0 4
113471: PPUSH
113472: EMPTY
113473: PPUSH
113474: CALL_OW 1
113478: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
113479: LD_VAR 0 1
113483: PPUSH
113484: LD_INT 0
113486: PPUSH
113487: CALL_OW 505
// end ; end ;
113491: LD_VAR 0 2
113495: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
113496: LD_INT 0
113498: PPUSH
113499: PPUSH
113500: PPUSH
// if not hack in hackTanks or not vehicles then
113501: LD_VAR 0 1
113505: PUSH
113506: LD_EXP 186
113510: IN
113511: NOT
113512: PUSH
113513: LD_VAR 0 2
113517: NOT
113518: OR
113519: IFFALSE 113523
// exit ;
113521: GO 113798
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
113523: LD_ADDR_VAR 0 2
113527: PUSH
113528: LD_VAR 0 1
113532: PPUSH
113533: LD_VAR 0 2
113537: PPUSH
113538: LD_INT 1
113540: PPUSH
113541: LD_INT 1
113543: PPUSH
113544: CALL 58655 0 4
113548: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
113549: LD_ADDR_VAR 0 5
113553: PUSH
113554: LD_EXP 186
113558: PPUSH
113559: LD_VAR 0 1
113563: PPUSH
113564: CALL 58005 0 2
113568: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
113569: LD_EXP 187
113573: PUSH
113574: LD_VAR 0 5
113578: ARRAY
113579: PUSH
113580: LD_EXP 188
113584: LESS
113585: IFFALSE 113774
// begin for i := 1 to vehicles do
113587: LD_ADDR_VAR 0 4
113591: PUSH
113592: DOUBLE
113593: LD_INT 1
113595: DEC
113596: ST_TO_ADDR
113597: LD_VAR 0 2
113601: PUSH
113602: FOR_TO
113603: IFFALSE 113772
// begin if hackTanksCaptured [ index ] = hackLimit then
113605: LD_EXP 187
113609: PUSH
113610: LD_VAR 0 5
113614: ARRAY
113615: PUSH
113616: LD_EXP 188
113620: EQUAL
113621: IFFALSE 113625
// break ;
113623: GO 113772
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
113625: LD_ADDR_EXP 190
113629: PUSH
113630: LD_EXP 190
113634: PPUSH
113635: LD_VAR 0 5
113639: PPUSH
113640: LD_EXP 190
113644: PUSH
113645: LD_VAR 0 5
113649: ARRAY
113650: PUSH
113651: LD_INT 1
113653: PLUS
113654: PPUSH
113655: CALL_OW 1
113659: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
113660: LD_ADDR_EXP 187
113664: PUSH
113665: LD_EXP 187
113669: PPUSH
113670: LD_VAR 0 5
113674: PUSH
113675: LD_EXP 187
113679: PUSH
113680: LD_VAR 0 5
113684: ARRAY
113685: PUSH
113686: LD_INT 1
113688: PLUS
113689: PUSH
113690: EMPTY
113691: LIST
113692: LIST
113693: PPUSH
113694: LD_VAR 0 2
113698: PUSH
113699: LD_VAR 0 4
113703: ARRAY
113704: PUSH
113705: LD_VAR 0 2
113709: PUSH
113710: LD_VAR 0 4
113714: ARRAY
113715: PPUSH
113716: CALL_OW 255
113720: PUSH
113721: EMPTY
113722: LIST
113723: LIST
113724: PPUSH
113725: CALL 58220 0 3
113729: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
113730: LD_VAR 0 2
113734: PUSH
113735: LD_VAR 0 4
113739: ARRAY
113740: PPUSH
113741: LD_VAR 0 1
113745: PPUSH
113746: CALL_OW 255
113750: PPUSH
113751: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
113755: LD_VAR 0 2
113759: PUSH
113760: LD_VAR 0 4
113764: ARRAY
113765: PPUSH
113766: CALL_OW 141
// end ;
113770: GO 113602
113772: POP
113773: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
113774: LD_VAR 0 1
113778: PPUSH
113779: LD_EXP 187
113783: PUSH
113784: LD_VAR 0 5
113788: ARRAY
113789: PUSH
113790: LD_INT 0
113792: PLUS
113793: PPUSH
113794: CALL_OW 505
// end ;
113798: LD_VAR 0 3
113802: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
113803: LD_INT 0
113805: PPUSH
113806: PPUSH
113807: PPUSH
113808: PPUSH
// if not hack in hackTanks then
113809: LD_VAR 0 1
113813: PUSH
113814: LD_EXP 186
113818: IN
113819: NOT
113820: IFFALSE 113824
// exit ;
113822: GO 114064
// index := GetElementIndex ( hackTanks , hack ) ;
113824: LD_ADDR_VAR 0 4
113828: PUSH
113829: LD_EXP 186
113833: PPUSH
113834: LD_VAR 0 1
113838: PPUSH
113839: CALL 58005 0 2
113843: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
113844: LD_ADDR_VAR 0 3
113848: PUSH
113849: DOUBLE
113850: LD_EXP 187
113854: PUSH
113855: LD_VAR 0 4
113859: ARRAY
113860: INC
113861: ST_TO_ADDR
113862: LD_INT 1
113864: PUSH
113865: FOR_DOWNTO
113866: IFFALSE 114038
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
113868: LD_ADDR_VAR 0 5
113872: PUSH
113873: LD_EXP 187
113877: PUSH
113878: LD_VAR 0 4
113882: ARRAY
113883: PUSH
113884: LD_VAR 0 3
113888: ARRAY
113889: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
113890: LD_VAR 0 5
113894: PUSH
113895: LD_INT 1
113897: ARRAY
113898: PPUSH
113899: CALL_OW 302
113903: NOT
113904: PUSH
113905: LD_VAR 0 5
113909: PUSH
113910: LD_INT 1
113912: ARRAY
113913: PPUSH
113914: CALL_OW 255
113918: PUSH
113919: LD_VAR 0 1
113923: PPUSH
113924: CALL_OW 255
113928: NONEQUAL
113929: OR
113930: IFFALSE 114036
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
113932: LD_VAR 0 5
113936: PUSH
113937: LD_INT 1
113939: ARRAY
113940: PPUSH
113941: CALL_OW 305
113945: PUSH
113946: LD_VAR 0 5
113950: PUSH
113951: LD_INT 1
113953: ARRAY
113954: PPUSH
113955: CALL_OW 255
113959: PUSH
113960: LD_VAR 0 1
113964: PPUSH
113965: CALL_OW 255
113969: EQUAL
113970: AND
113971: IFFALSE 113995
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
113973: LD_VAR 0 5
113977: PUSH
113978: LD_INT 1
113980: ARRAY
113981: PPUSH
113982: LD_VAR 0 5
113986: PUSH
113987: LD_INT 2
113989: ARRAY
113990: PPUSH
113991: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
113995: LD_ADDR_EXP 187
113999: PUSH
114000: LD_EXP 187
114004: PPUSH
114005: LD_VAR 0 4
114009: PPUSH
114010: LD_EXP 187
114014: PUSH
114015: LD_VAR 0 4
114019: ARRAY
114020: PPUSH
114021: LD_VAR 0 3
114025: PPUSH
114026: CALL_OW 3
114030: PPUSH
114031: CALL_OW 1
114035: ST_TO_ADDR
// end ; end ;
114036: GO 113865
114038: POP
114039: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
114040: LD_VAR 0 1
114044: PPUSH
114045: LD_EXP 187
114049: PUSH
114050: LD_VAR 0 4
114054: ARRAY
114055: PUSH
114056: LD_INT 0
114058: PLUS
114059: PPUSH
114060: CALL_OW 505
// end ;
114064: LD_VAR 0 2
114068: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
114069: LD_INT 0
114071: PPUSH
114072: PPUSH
114073: PPUSH
114074: PPUSH
// if not hack in hackTanks then
114075: LD_VAR 0 1
114079: PUSH
114080: LD_EXP 186
114084: IN
114085: NOT
114086: IFFALSE 114090
// exit ;
114088: GO 114175
// index := GetElementIndex ( hackTanks , hack ) ;
114090: LD_ADDR_VAR 0 5
114094: PUSH
114095: LD_EXP 186
114099: PPUSH
114100: LD_VAR 0 1
114104: PPUSH
114105: CALL 58005 0 2
114109: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
114110: LD_ADDR_VAR 0 4
114114: PUSH
114115: DOUBLE
114116: LD_INT 1
114118: DEC
114119: ST_TO_ADDR
114120: LD_EXP 187
114124: PUSH
114125: LD_VAR 0 5
114129: ARRAY
114130: PUSH
114131: FOR_TO
114132: IFFALSE 114173
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
114134: LD_EXP 187
114138: PUSH
114139: LD_VAR 0 5
114143: ARRAY
114144: PUSH
114145: LD_VAR 0 4
114149: ARRAY
114150: PUSH
114151: LD_INT 1
114153: ARRAY
114154: PUSH
114155: LD_VAR 0 2
114159: EQUAL
114160: IFFALSE 114171
// KillUnit ( vehicle ) ;
114162: LD_VAR 0 2
114166: PPUSH
114167: CALL_OW 66
114171: GO 114131
114173: POP
114174: POP
// end ;
114175: LD_VAR 0 3
114179: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
114180: LD_EXP 191
114184: NOT
114185: IFFALSE 114220
114187: GO 114189
114189: DISABLE
// begin initMiner := true ;
114190: LD_ADDR_EXP 191
114194: PUSH
114195: LD_INT 1
114197: ST_TO_ADDR
// minersList := [ ] ;
114198: LD_ADDR_EXP 192
114202: PUSH
114203: EMPTY
114204: ST_TO_ADDR
// minerMinesList := [ ] ;
114205: LD_ADDR_EXP 193
114209: PUSH
114210: EMPTY
114211: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
114212: LD_ADDR_EXP 194
114216: PUSH
114217: LD_INT 5
114219: ST_TO_ADDR
// end ;
114220: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
114221: LD_EXP 191
114225: PUSH
114226: LD_INT 34
114228: PUSH
114229: LD_INT 81
114231: PUSH
114232: EMPTY
114233: LIST
114234: LIST
114235: PPUSH
114236: CALL_OW 69
114240: AND
114241: IFFALSE 114702
114243: GO 114245
114245: DISABLE
114246: LD_INT 0
114248: PPUSH
114249: PPUSH
114250: PPUSH
114251: PPUSH
// begin enable ;
114252: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
114253: LD_ADDR_VAR 0 1
114257: PUSH
114258: LD_INT 34
114260: PUSH
114261: LD_INT 81
114263: PUSH
114264: EMPTY
114265: LIST
114266: LIST
114267: PPUSH
114268: CALL_OW 69
114272: PUSH
114273: FOR_IN
114274: IFFALSE 114346
// begin if not i in minersList then
114276: LD_VAR 0 1
114280: PUSH
114281: LD_EXP 192
114285: IN
114286: NOT
114287: IFFALSE 114344
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
114289: LD_ADDR_EXP 192
114293: PUSH
114294: LD_EXP 192
114298: PPUSH
114299: LD_EXP 192
114303: PUSH
114304: LD_INT 1
114306: PLUS
114307: PPUSH
114308: LD_VAR 0 1
114312: PPUSH
114313: CALL_OW 1
114317: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
114318: LD_ADDR_EXP 193
114322: PUSH
114323: LD_EXP 193
114327: PPUSH
114328: LD_EXP 193
114332: PUSH
114333: LD_INT 1
114335: PLUS
114336: PPUSH
114337: EMPTY
114338: PPUSH
114339: CALL_OW 1
114343: ST_TO_ADDR
// end end ;
114344: GO 114273
114346: POP
114347: POP
// for i := minerMinesList downto 1 do
114348: LD_ADDR_VAR 0 1
114352: PUSH
114353: DOUBLE
114354: LD_EXP 193
114358: INC
114359: ST_TO_ADDR
114360: LD_INT 1
114362: PUSH
114363: FOR_DOWNTO
114364: IFFALSE 114700
// begin if IsLive ( minersList [ i ] ) then
114366: LD_EXP 192
114370: PUSH
114371: LD_VAR 0 1
114375: ARRAY
114376: PPUSH
114377: CALL_OW 300
114381: IFFALSE 114409
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
114383: LD_EXP 192
114387: PUSH
114388: LD_VAR 0 1
114392: ARRAY
114393: PPUSH
114394: LD_EXP 193
114398: PUSH
114399: LD_VAR 0 1
114403: ARRAY
114404: PPUSH
114405: CALL_OW 505
// if not minerMinesList [ i ] then
114409: LD_EXP 193
114413: PUSH
114414: LD_VAR 0 1
114418: ARRAY
114419: NOT
114420: IFFALSE 114424
// continue ;
114422: GO 114363
// for j := minerMinesList [ i ] downto 1 do
114424: LD_ADDR_VAR 0 2
114428: PUSH
114429: DOUBLE
114430: LD_EXP 193
114434: PUSH
114435: LD_VAR 0 1
114439: ARRAY
114440: INC
114441: ST_TO_ADDR
114442: LD_INT 1
114444: PUSH
114445: FOR_DOWNTO
114446: IFFALSE 114696
// begin side := GetSide ( minersList [ i ] ) ;
114448: LD_ADDR_VAR 0 3
114452: PUSH
114453: LD_EXP 192
114457: PUSH
114458: LD_VAR 0 1
114462: ARRAY
114463: PPUSH
114464: CALL_OW 255
114468: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
114469: LD_ADDR_VAR 0 4
114473: PUSH
114474: LD_EXP 193
114478: PUSH
114479: LD_VAR 0 1
114483: ARRAY
114484: PUSH
114485: LD_VAR 0 2
114489: ARRAY
114490: PUSH
114491: LD_INT 1
114493: ARRAY
114494: PPUSH
114495: LD_EXP 193
114499: PUSH
114500: LD_VAR 0 1
114504: ARRAY
114505: PUSH
114506: LD_VAR 0 2
114510: ARRAY
114511: PUSH
114512: LD_INT 2
114514: ARRAY
114515: PPUSH
114516: CALL_OW 428
114520: ST_TO_ADDR
// if not tmp then
114521: LD_VAR 0 4
114525: NOT
114526: IFFALSE 114530
// continue ;
114528: GO 114445
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
114530: LD_VAR 0 4
114534: PUSH
114535: LD_INT 81
114537: PUSH
114538: LD_VAR 0 3
114542: PUSH
114543: EMPTY
114544: LIST
114545: LIST
114546: PPUSH
114547: CALL_OW 69
114551: IN
114552: PUSH
114553: LD_EXP 193
114557: PUSH
114558: LD_VAR 0 1
114562: ARRAY
114563: PUSH
114564: LD_VAR 0 2
114568: ARRAY
114569: PUSH
114570: LD_INT 1
114572: ARRAY
114573: PPUSH
114574: LD_EXP 193
114578: PUSH
114579: LD_VAR 0 1
114583: ARRAY
114584: PUSH
114585: LD_VAR 0 2
114589: ARRAY
114590: PUSH
114591: LD_INT 2
114593: ARRAY
114594: PPUSH
114595: CALL_OW 458
114599: AND
114600: IFFALSE 114694
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
114602: LD_EXP 193
114606: PUSH
114607: LD_VAR 0 1
114611: ARRAY
114612: PUSH
114613: LD_VAR 0 2
114617: ARRAY
114618: PUSH
114619: LD_INT 1
114621: ARRAY
114622: PPUSH
114623: LD_EXP 193
114627: PUSH
114628: LD_VAR 0 1
114632: ARRAY
114633: PUSH
114634: LD_VAR 0 2
114638: ARRAY
114639: PUSH
114640: LD_INT 2
114642: ARRAY
114643: PPUSH
114644: LD_VAR 0 3
114648: PPUSH
114649: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
114653: LD_ADDR_EXP 193
114657: PUSH
114658: LD_EXP 193
114662: PPUSH
114663: LD_VAR 0 1
114667: PPUSH
114668: LD_EXP 193
114672: PUSH
114673: LD_VAR 0 1
114677: ARRAY
114678: PPUSH
114679: LD_VAR 0 2
114683: PPUSH
114684: CALL_OW 3
114688: PPUSH
114689: CALL_OW 1
114693: ST_TO_ADDR
// end ; end ;
114694: GO 114445
114696: POP
114697: POP
// end ;
114698: GO 114363
114700: POP
114701: POP
// end ;
114702: PPOPN 4
114704: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
114705: LD_INT 0
114707: PPUSH
114708: PPUSH
// result := false ;
114709: LD_ADDR_VAR 0 4
114713: PUSH
114714: LD_INT 0
114716: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
114717: LD_VAR 0 1
114721: PPUSH
114722: CALL_OW 264
114726: PUSH
114727: LD_INT 81
114729: EQUAL
114730: NOT
114731: IFFALSE 114735
// exit ;
114733: GO 114975
// index := GetElementIndex ( minersList , unit ) ;
114735: LD_ADDR_VAR 0 5
114739: PUSH
114740: LD_EXP 192
114744: PPUSH
114745: LD_VAR 0 1
114749: PPUSH
114750: CALL 58005 0 2
114754: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
114755: LD_EXP 193
114759: PUSH
114760: LD_VAR 0 5
114764: ARRAY
114765: PUSH
114766: LD_EXP 194
114770: GREATEREQUAL
114771: IFFALSE 114775
// exit ;
114773: GO 114975
// ComMoveXY ( unit , x , y ) ;
114775: LD_VAR 0 1
114779: PPUSH
114780: LD_VAR 0 2
114784: PPUSH
114785: LD_VAR 0 3
114789: PPUSH
114790: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
114794: LD_INT 35
114796: PPUSH
114797: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
114801: LD_VAR 0 1
114805: PPUSH
114806: LD_VAR 0 2
114810: PPUSH
114811: LD_VAR 0 3
114815: PPUSH
114816: CALL 89757 0 3
114820: NOT
114821: PUSH
114822: LD_VAR 0 1
114826: PPUSH
114827: CALL_OW 314
114831: AND
114832: IFFALSE 114836
// exit ;
114834: GO 114975
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
114836: LD_VAR 0 2
114840: PPUSH
114841: LD_VAR 0 3
114845: PPUSH
114846: CALL_OW 428
114850: PUSH
114851: LD_VAR 0 1
114855: EQUAL
114856: PUSH
114857: LD_VAR 0 1
114861: PPUSH
114862: CALL_OW 314
114866: NOT
114867: AND
114868: IFFALSE 114794
// PlaySoundXY ( x , y , PlantMine ) ;
114870: LD_VAR 0 2
114874: PPUSH
114875: LD_VAR 0 3
114879: PPUSH
114880: LD_STRING PlantMine
114882: PPUSH
114883: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
114887: LD_VAR 0 2
114891: PPUSH
114892: LD_VAR 0 3
114896: PPUSH
114897: LD_VAR 0 1
114901: PPUSH
114902: CALL_OW 255
114906: PPUSH
114907: LD_INT 0
114909: PPUSH
114910: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
114914: LD_ADDR_EXP 193
114918: PUSH
114919: LD_EXP 193
114923: PPUSH
114924: LD_VAR 0 5
114928: PUSH
114929: LD_EXP 193
114933: PUSH
114934: LD_VAR 0 5
114938: ARRAY
114939: PUSH
114940: LD_INT 1
114942: PLUS
114943: PUSH
114944: EMPTY
114945: LIST
114946: LIST
114947: PPUSH
114948: LD_VAR 0 2
114952: PUSH
114953: LD_VAR 0 3
114957: PUSH
114958: EMPTY
114959: LIST
114960: LIST
114961: PPUSH
114962: CALL 58220 0 3
114966: ST_TO_ADDR
// result := true ;
114967: LD_ADDR_VAR 0 4
114971: PUSH
114972: LD_INT 1
114974: ST_TO_ADDR
// end ;
114975: LD_VAR 0 4
114979: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
114980: LD_INT 0
114982: PPUSH
114983: PPUSH
114984: PPUSH
// if not unit in minersList then
114985: LD_VAR 0 1
114989: PUSH
114990: LD_EXP 192
114994: IN
114995: NOT
114996: IFFALSE 115000
// exit ;
114998: GO 115392
// index := GetElementIndex ( minersList , unit ) ;
115000: LD_ADDR_VAR 0 6
115004: PUSH
115005: LD_EXP 192
115009: PPUSH
115010: LD_VAR 0 1
115014: PPUSH
115015: CALL 58005 0 2
115019: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
115020: LD_ADDR_VAR 0 5
115024: PUSH
115025: DOUBLE
115026: LD_EXP 193
115030: PUSH
115031: LD_VAR 0 6
115035: ARRAY
115036: INC
115037: ST_TO_ADDR
115038: LD_INT 1
115040: PUSH
115041: FOR_DOWNTO
115042: IFFALSE 115203
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
115044: LD_EXP 193
115048: PUSH
115049: LD_VAR 0 6
115053: ARRAY
115054: PUSH
115055: LD_VAR 0 5
115059: ARRAY
115060: PUSH
115061: LD_INT 1
115063: ARRAY
115064: PUSH
115065: LD_VAR 0 2
115069: EQUAL
115070: PUSH
115071: LD_EXP 193
115075: PUSH
115076: LD_VAR 0 6
115080: ARRAY
115081: PUSH
115082: LD_VAR 0 5
115086: ARRAY
115087: PUSH
115088: LD_INT 2
115090: ARRAY
115091: PUSH
115092: LD_VAR 0 3
115096: EQUAL
115097: AND
115098: IFFALSE 115201
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
115100: LD_EXP 193
115104: PUSH
115105: LD_VAR 0 6
115109: ARRAY
115110: PUSH
115111: LD_VAR 0 5
115115: ARRAY
115116: PUSH
115117: LD_INT 1
115119: ARRAY
115120: PPUSH
115121: LD_EXP 193
115125: PUSH
115126: LD_VAR 0 6
115130: ARRAY
115131: PUSH
115132: LD_VAR 0 5
115136: ARRAY
115137: PUSH
115138: LD_INT 2
115140: ARRAY
115141: PPUSH
115142: LD_VAR 0 1
115146: PPUSH
115147: CALL_OW 255
115151: PPUSH
115152: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
115156: LD_ADDR_EXP 193
115160: PUSH
115161: LD_EXP 193
115165: PPUSH
115166: LD_VAR 0 6
115170: PPUSH
115171: LD_EXP 193
115175: PUSH
115176: LD_VAR 0 6
115180: ARRAY
115181: PPUSH
115182: LD_VAR 0 5
115186: PPUSH
115187: CALL_OW 3
115191: PPUSH
115192: CALL_OW 1
115196: ST_TO_ADDR
// exit ;
115197: POP
115198: POP
115199: GO 115392
// end ; end ;
115201: GO 115041
115203: POP
115204: POP
// for i := minerMinesList [ index ] downto 1 do
115205: LD_ADDR_VAR 0 5
115209: PUSH
115210: DOUBLE
115211: LD_EXP 193
115215: PUSH
115216: LD_VAR 0 6
115220: ARRAY
115221: INC
115222: ST_TO_ADDR
115223: LD_INT 1
115225: PUSH
115226: FOR_DOWNTO
115227: IFFALSE 115390
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
115229: LD_EXP 193
115233: PUSH
115234: LD_VAR 0 6
115238: ARRAY
115239: PUSH
115240: LD_VAR 0 5
115244: ARRAY
115245: PUSH
115246: LD_INT 1
115248: ARRAY
115249: PPUSH
115250: LD_EXP 193
115254: PUSH
115255: LD_VAR 0 6
115259: ARRAY
115260: PUSH
115261: LD_VAR 0 5
115265: ARRAY
115266: PUSH
115267: LD_INT 2
115269: ARRAY
115270: PPUSH
115271: LD_VAR 0 2
115275: PPUSH
115276: LD_VAR 0 3
115280: PPUSH
115281: CALL_OW 298
115285: PUSH
115286: LD_INT 6
115288: LESS
115289: IFFALSE 115388
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
115291: LD_EXP 193
115295: PUSH
115296: LD_VAR 0 6
115300: ARRAY
115301: PUSH
115302: LD_VAR 0 5
115306: ARRAY
115307: PUSH
115308: LD_INT 1
115310: ARRAY
115311: PPUSH
115312: LD_EXP 193
115316: PUSH
115317: LD_VAR 0 6
115321: ARRAY
115322: PUSH
115323: LD_VAR 0 5
115327: ARRAY
115328: PUSH
115329: LD_INT 2
115331: ARRAY
115332: PPUSH
115333: LD_VAR 0 1
115337: PPUSH
115338: CALL_OW 255
115342: PPUSH
115343: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
115347: LD_ADDR_EXP 193
115351: PUSH
115352: LD_EXP 193
115356: PPUSH
115357: LD_VAR 0 6
115361: PPUSH
115362: LD_EXP 193
115366: PUSH
115367: LD_VAR 0 6
115371: ARRAY
115372: PPUSH
115373: LD_VAR 0 5
115377: PPUSH
115378: CALL_OW 3
115382: PPUSH
115383: CALL_OW 1
115387: ST_TO_ADDR
// end ; end ;
115388: GO 115226
115390: POP
115391: POP
// end ;
115392: LD_VAR 0 4
115396: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
115397: LD_INT 0
115399: PPUSH
115400: PPUSH
115401: PPUSH
115402: PPUSH
115403: PPUSH
115404: PPUSH
115405: PPUSH
115406: PPUSH
115407: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
115408: LD_VAR 0 1
115412: PPUSH
115413: CALL_OW 264
115417: PUSH
115418: LD_INT 81
115420: EQUAL
115421: NOT
115422: PUSH
115423: LD_VAR 0 1
115427: PUSH
115428: LD_EXP 192
115432: IN
115433: NOT
115434: OR
115435: IFFALSE 115439
// exit ;
115437: GO 115761
// index := GetElementIndex ( minersList , unit ) ;
115439: LD_ADDR_VAR 0 6
115443: PUSH
115444: LD_EXP 192
115448: PPUSH
115449: LD_VAR 0 1
115453: PPUSH
115454: CALL 58005 0 2
115458: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
115459: LD_ADDR_VAR 0 8
115463: PUSH
115464: LD_EXP 194
115468: PUSH
115469: LD_EXP 193
115473: PUSH
115474: LD_VAR 0 6
115478: ARRAY
115479: MINUS
115480: ST_TO_ADDR
// if not minesFreeAmount then
115481: LD_VAR 0 8
115485: NOT
115486: IFFALSE 115490
// exit ;
115488: GO 115761
// tmp := [ ] ;
115490: LD_ADDR_VAR 0 7
115494: PUSH
115495: EMPTY
115496: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
115497: LD_ADDR_VAR 0 5
115501: PUSH
115502: DOUBLE
115503: LD_INT 1
115505: DEC
115506: ST_TO_ADDR
115507: LD_VAR 0 8
115511: PUSH
115512: FOR_TO
115513: IFFALSE 115708
// begin _d := rand ( 0 , 5 ) ;
115515: LD_ADDR_VAR 0 11
115519: PUSH
115520: LD_INT 0
115522: PPUSH
115523: LD_INT 5
115525: PPUSH
115526: CALL_OW 12
115530: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
115531: LD_ADDR_VAR 0 12
115535: PUSH
115536: LD_INT 2
115538: PPUSH
115539: LD_INT 6
115541: PPUSH
115542: CALL_OW 12
115546: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
115547: LD_ADDR_VAR 0 9
115551: PUSH
115552: LD_VAR 0 2
115556: PPUSH
115557: LD_VAR 0 11
115561: PPUSH
115562: LD_VAR 0 12
115566: PPUSH
115567: CALL_OW 272
115571: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
115572: LD_ADDR_VAR 0 10
115576: PUSH
115577: LD_VAR 0 3
115581: PPUSH
115582: LD_VAR 0 11
115586: PPUSH
115587: LD_VAR 0 12
115591: PPUSH
115592: CALL_OW 273
115596: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
115597: LD_VAR 0 9
115601: PPUSH
115602: LD_VAR 0 10
115606: PPUSH
115607: CALL_OW 488
115611: PUSH
115612: LD_VAR 0 9
115616: PUSH
115617: LD_VAR 0 10
115621: PUSH
115622: EMPTY
115623: LIST
115624: LIST
115625: PUSH
115626: LD_VAR 0 7
115630: IN
115631: NOT
115632: AND
115633: PUSH
115634: LD_VAR 0 9
115638: PPUSH
115639: LD_VAR 0 10
115643: PPUSH
115644: CALL_OW 458
115648: NOT
115649: AND
115650: IFFALSE 115692
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
115652: LD_ADDR_VAR 0 7
115656: PUSH
115657: LD_VAR 0 7
115661: PPUSH
115662: LD_VAR 0 7
115666: PUSH
115667: LD_INT 1
115669: PLUS
115670: PPUSH
115671: LD_VAR 0 9
115675: PUSH
115676: LD_VAR 0 10
115680: PUSH
115681: EMPTY
115682: LIST
115683: LIST
115684: PPUSH
115685: CALL_OW 1
115689: ST_TO_ADDR
115690: GO 115706
// i := i - 1 ;
115692: LD_ADDR_VAR 0 5
115696: PUSH
115697: LD_VAR 0 5
115701: PUSH
115702: LD_INT 1
115704: MINUS
115705: ST_TO_ADDR
// end ;
115706: GO 115512
115708: POP
115709: POP
// for i in tmp do
115710: LD_ADDR_VAR 0 5
115714: PUSH
115715: LD_VAR 0 7
115719: PUSH
115720: FOR_IN
115721: IFFALSE 115759
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
115723: LD_VAR 0 1
115727: PPUSH
115728: LD_VAR 0 5
115732: PUSH
115733: LD_INT 1
115735: ARRAY
115736: PPUSH
115737: LD_VAR 0 5
115741: PUSH
115742: LD_INT 2
115744: ARRAY
115745: PPUSH
115746: CALL 114705 0 3
115750: NOT
115751: IFFALSE 115757
// exit ;
115753: POP
115754: POP
115755: GO 115761
115757: GO 115720
115759: POP
115760: POP
// end ;
115761: LD_VAR 0 4
115765: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
115766: LD_INT 0
115768: PPUSH
115769: PPUSH
115770: PPUSH
115771: PPUSH
115772: PPUSH
115773: PPUSH
115774: PPUSH
// if not GetClass ( unit ) = class_sniper then
115775: LD_VAR 0 1
115779: PPUSH
115780: CALL_OW 257
115784: PUSH
115785: LD_INT 5
115787: EQUAL
115788: NOT
115789: IFFALSE 115793
// exit ;
115791: GO 116181
// dist := 8 ;
115793: LD_ADDR_VAR 0 5
115797: PUSH
115798: LD_INT 8
115800: ST_TO_ADDR
// viewRange := 12 ;
115801: LD_ADDR_VAR 0 7
115805: PUSH
115806: LD_INT 12
115808: ST_TO_ADDR
// side := GetSide ( unit ) ;
115809: LD_ADDR_VAR 0 6
115813: PUSH
115814: LD_VAR 0 1
115818: PPUSH
115819: CALL_OW 255
115823: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
115824: LD_INT 61
115826: PPUSH
115827: LD_VAR 0 6
115831: PPUSH
115832: CALL_OW 321
115836: PUSH
115837: LD_INT 2
115839: EQUAL
115840: IFFALSE 115850
// viewRange := 16 ;
115842: LD_ADDR_VAR 0 7
115846: PUSH
115847: LD_INT 16
115849: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
115850: LD_VAR 0 1
115854: PPUSH
115855: LD_VAR 0 2
115859: PPUSH
115860: LD_VAR 0 3
115864: PPUSH
115865: CALL_OW 297
115869: PUSH
115870: LD_VAR 0 5
115874: GREATER
115875: IFFALSE 115954
// begin ComMoveXY ( unit , x , y ) ;
115877: LD_VAR 0 1
115881: PPUSH
115882: LD_VAR 0 2
115886: PPUSH
115887: LD_VAR 0 3
115891: PPUSH
115892: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
115896: LD_INT 35
115898: PPUSH
115899: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
115903: LD_VAR 0 1
115907: PPUSH
115908: LD_VAR 0 2
115912: PPUSH
115913: LD_VAR 0 3
115917: PPUSH
115918: CALL 89757 0 3
115922: NOT
115923: IFFALSE 115927
// exit ;
115925: GO 116181
// until GetDistUnitXY ( unit , x , y ) < dist ;
115927: LD_VAR 0 1
115931: PPUSH
115932: LD_VAR 0 2
115936: PPUSH
115937: LD_VAR 0 3
115941: PPUSH
115942: CALL_OW 297
115946: PUSH
115947: LD_VAR 0 5
115951: LESS
115952: IFFALSE 115896
// end ; ComTurnXY ( unit , x , y ) ;
115954: LD_VAR 0 1
115958: PPUSH
115959: LD_VAR 0 2
115963: PPUSH
115964: LD_VAR 0 3
115968: PPUSH
115969: CALL_OW 118
// wait ( 5 ) ;
115973: LD_INT 5
115975: PPUSH
115976: CALL_OW 67
// _d := GetDir ( unit ) ;
115980: LD_ADDR_VAR 0 10
115984: PUSH
115985: LD_VAR 0 1
115989: PPUSH
115990: CALL_OW 254
115994: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
115995: LD_ADDR_VAR 0 8
115999: PUSH
116000: LD_VAR 0 1
116004: PPUSH
116005: CALL_OW 250
116009: PPUSH
116010: LD_VAR 0 10
116014: PPUSH
116015: LD_VAR 0 5
116019: PPUSH
116020: CALL_OW 272
116024: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
116025: LD_ADDR_VAR 0 9
116029: PUSH
116030: LD_VAR 0 1
116034: PPUSH
116035: CALL_OW 251
116039: PPUSH
116040: LD_VAR 0 10
116044: PPUSH
116045: LD_VAR 0 5
116049: PPUSH
116050: CALL_OW 273
116054: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
116055: LD_VAR 0 8
116059: PPUSH
116060: LD_VAR 0 9
116064: PPUSH
116065: CALL_OW 488
116069: NOT
116070: IFFALSE 116074
// exit ;
116072: GO 116181
// ComAnimCustom ( unit , 1 ) ;
116074: LD_VAR 0 1
116078: PPUSH
116079: LD_INT 1
116081: PPUSH
116082: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
116086: LD_VAR 0 8
116090: PPUSH
116091: LD_VAR 0 9
116095: PPUSH
116096: LD_VAR 0 6
116100: PPUSH
116101: LD_VAR 0 7
116105: PPUSH
116106: CALL_OW 330
// repeat wait ( 1 ) ;
116110: LD_INT 1
116112: PPUSH
116113: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
116117: LD_VAR 0 1
116121: PPUSH
116122: CALL_OW 316
116126: PUSH
116127: LD_VAR 0 1
116131: PPUSH
116132: CALL_OW 314
116136: OR
116137: PUSH
116138: LD_VAR 0 1
116142: PPUSH
116143: CALL_OW 302
116147: NOT
116148: OR
116149: PUSH
116150: LD_VAR 0 1
116154: PPUSH
116155: CALL_OW 301
116159: OR
116160: IFFALSE 116110
// RemoveSeeing ( _x , _y , side ) ;
116162: LD_VAR 0 8
116166: PPUSH
116167: LD_VAR 0 9
116171: PPUSH
116172: LD_VAR 0 6
116176: PPUSH
116177: CALL_OW 331
// end ; end_of_file
116181: LD_VAR 0 4
116185: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
116186: LD_INT 0
116188: PPUSH
116189: PPUSH
116190: PPUSH
116191: PPUSH
116192: PPUSH
116193: PPUSH
116194: PPUSH
116195: PPUSH
116196: PPUSH
116197: PPUSH
116198: PPUSH
116199: PPUSH
116200: PPUSH
116201: PPUSH
116202: PPUSH
116203: PPUSH
116204: PPUSH
116205: PPUSH
116206: PPUSH
116207: PPUSH
116208: PPUSH
116209: PPUSH
116210: PPUSH
116211: PPUSH
116212: PPUSH
116213: PPUSH
116214: PPUSH
116215: PPUSH
116216: PPUSH
116217: PPUSH
116218: PPUSH
116219: PPUSH
116220: PPUSH
116221: PPUSH
// if not list then
116222: LD_VAR 0 1
116226: NOT
116227: IFFALSE 116231
// exit ;
116229: GO 120890
// base := list [ 1 ] ;
116231: LD_ADDR_VAR 0 3
116235: PUSH
116236: LD_VAR 0 1
116240: PUSH
116241: LD_INT 1
116243: ARRAY
116244: ST_TO_ADDR
// group := list [ 2 ] ;
116245: LD_ADDR_VAR 0 4
116249: PUSH
116250: LD_VAR 0 1
116254: PUSH
116255: LD_INT 2
116257: ARRAY
116258: ST_TO_ADDR
// path := list [ 3 ] ;
116259: LD_ADDR_VAR 0 5
116263: PUSH
116264: LD_VAR 0 1
116268: PUSH
116269: LD_INT 3
116271: ARRAY
116272: ST_TO_ADDR
// flags := list [ 4 ] ;
116273: LD_ADDR_VAR 0 6
116277: PUSH
116278: LD_VAR 0 1
116282: PUSH
116283: LD_INT 4
116285: ARRAY
116286: ST_TO_ADDR
// mined := [ ] ;
116287: LD_ADDR_VAR 0 27
116291: PUSH
116292: EMPTY
116293: ST_TO_ADDR
// bombed := [ ] ;
116294: LD_ADDR_VAR 0 28
116298: PUSH
116299: EMPTY
116300: ST_TO_ADDR
// healers := [ ] ;
116301: LD_ADDR_VAR 0 31
116305: PUSH
116306: EMPTY
116307: ST_TO_ADDR
// to_heal := [ ] ;
116308: LD_ADDR_VAR 0 30
116312: PUSH
116313: EMPTY
116314: ST_TO_ADDR
// repairs := [ ] ;
116315: LD_ADDR_VAR 0 33
116319: PUSH
116320: EMPTY
116321: ST_TO_ADDR
// to_repair := [ ] ;
116322: LD_ADDR_VAR 0 32
116326: PUSH
116327: EMPTY
116328: ST_TO_ADDR
// if not group or not path then
116329: LD_VAR 0 4
116333: NOT
116334: PUSH
116335: LD_VAR 0 5
116339: NOT
116340: OR
116341: IFFALSE 116345
// exit ;
116343: GO 120890
// side := GetSide ( group [ 1 ] ) ;
116345: LD_ADDR_VAR 0 35
116349: PUSH
116350: LD_VAR 0 4
116354: PUSH
116355: LD_INT 1
116357: ARRAY
116358: PPUSH
116359: CALL_OW 255
116363: ST_TO_ADDR
// if flags then
116364: LD_VAR 0 6
116368: IFFALSE 116512
// begin f_ignore_area := flags [ 1 ] ;
116370: LD_ADDR_VAR 0 17
116374: PUSH
116375: LD_VAR 0 6
116379: PUSH
116380: LD_INT 1
116382: ARRAY
116383: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
116384: LD_ADDR_VAR 0 18
116388: PUSH
116389: LD_VAR 0 6
116393: PUSH
116394: LD_INT 2
116396: ARRAY
116397: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
116398: LD_ADDR_VAR 0 19
116402: PUSH
116403: LD_VAR 0 6
116407: PUSH
116408: LD_INT 3
116410: ARRAY
116411: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
116412: LD_ADDR_VAR 0 20
116416: PUSH
116417: LD_VAR 0 6
116421: PUSH
116422: LD_INT 4
116424: ARRAY
116425: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
116426: LD_ADDR_VAR 0 21
116430: PUSH
116431: LD_VAR 0 6
116435: PUSH
116436: LD_INT 5
116438: ARRAY
116439: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
116440: LD_ADDR_VAR 0 22
116444: PUSH
116445: LD_VAR 0 6
116449: PUSH
116450: LD_INT 6
116452: ARRAY
116453: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
116454: LD_ADDR_VAR 0 23
116458: PUSH
116459: LD_VAR 0 6
116463: PUSH
116464: LD_INT 7
116466: ARRAY
116467: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
116468: LD_ADDR_VAR 0 24
116472: PUSH
116473: LD_VAR 0 6
116477: PUSH
116478: LD_INT 8
116480: ARRAY
116481: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
116482: LD_ADDR_VAR 0 25
116486: PUSH
116487: LD_VAR 0 6
116491: PUSH
116492: LD_INT 9
116494: ARRAY
116495: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
116496: LD_ADDR_VAR 0 26
116500: PUSH
116501: LD_VAR 0 6
116505: PUSH
116506: LD_INT 10
116508: ARRAY
116509: ST_TO_ADDR
// end else
116510: GO 116592
// begin f_ignore_area := false ;
116512: LD_ADDR_VAR 0 17
116516: PUSH
116517: LD_INT 0
116519: ST_TO_ADDR
// f_capture := false ;
116520: LD_ADDR_VAR 0 18
116524: PUSH
116525: LD_INT 0
116527: ST_TO_ADDR
// f_ignore_civ := false ;
116528: LD_ADDR_VAR 0 19
116532: PUSH
116533: LD_INT 0
116535: ST_TO_ADDR
// f_murder := false ;
116536: LD_ADDR_VAR 0 20
116540: PUSH
116541: LD_INT 0
116543: ST_TO_ADDR
// f_mines := false ;
116544: LD_ADDR_VAR 0 21
116548: PUSH
116549: LD_INT 0
116551: ST_TO_ADDR
// f_repair := false ;
116552: LD_ADDR_VAR 0 22
116556: PUSH
116557: LD_INT 0
116559: ST_TO_ADDR
// f_heal := false ;
116560: LD_ADDR_VAR 0 23
116564: PUSH
116565: LD_INT 0
116567: ST_TO_ADDR
// f_spacetime := false ;
116568: LD_ADDR_VAR 0 24
116572: PUSH
116573: LD_INT 0
116575: ST_TO_ADDR
// f_attack_depot := false ;
116576: LD_ADDR_VAR 0 25
116580: PUSH
116581: LD_INT 0
116583: ST_TO_ADDR
// f_crawl := false ;
116584: LD_ADDR_VAR 0 26
116588: PUSH
116589: LD_INT 0
116591: ST_TO_ADDR
// end ; if f_heal then
116592: LD_VAR 0 23
116596: IFFALSE 116623
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
116598: LD_ADDR_VAR 0 31
116602: PUSH
116603: LD_VAR 0 4
116607: PPUSH
116608: LD_INT 25
116610: PUSH
116611: LD_INT 4
116613: PUSH
116614: EMPTY
116615: LIST
116616: LIST
116617: PPUSH
116618: CALL_OW 72
116622: ST_TO_ADDR
// if f_repair then
116623: LD_VAR 0 22
116627: IFFALSE 116654
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
116629: LD_ADDR_VAR 0 33
116633: PUSH
116634: LD_VAR 0 4
116638: PPUSH
116639: LD_INT 25
116641: PUSH
116642: LD_INT 3
116644: PUSH
116645: EMPTY
116646: LIST
116647: LIST
116648: PPUSH
116649: CALL_OW 72
116653: ST_TO_ADDR
// units_path := [ ] ;
116654: LD_ADDR_VAR 0 16
116658: PUSH
116659: EMPTY
116660: ST_TO_ADDR
// for i = 1 to group do
116661: LD_ADDR_VAR 0 7
116665: PUSH
116666: DOUBLE
116667: LD_INT 1
116669: DEC
116670: ST_TO_ADDR
116671: LD_VAR 0 4
116675: PUSH
116676: FOR_TO
116677: IFFALSE 116706
// units_path := Replace ( units_path , i , path ) ;
116679: LD_ADDR_VAR 0 16
116683: PUSH
116684: LD_VAR 0 16
116688: PPUSH
116689: LD_VAR 0 7
116693: PPUSH
116694: LD_VAR 0 5
116698: PPUSH
116699: CALL_OW 1
116703: ST_TO_ADDR
116704: GO 116676
116706: POP
116707: POP
// repeat for i = group downto 1 do
116708: LD_ADDR_VAR 0 7
116712: PUSH
116713: DOUBLE
116714: LD_VAR 0 4
116718: INC
116719: ST_TO_ADDR
116720: LD_INT 1
116722: PUSH
116723: FOR_DOWNTO
116724: IFFALSE 120846
// begin wait ( 5 ) ;
116726: LD_INT 5
116728: PPUSH
116729: CALL_OW 67
// tmp := [ ] ;
116733: LD_ADDR_VAR 0 14
116737: PUSH
116738: EMPTY
116739: ST_TO_ADDR
// attacking := false ;
116740: LD_ADDR_VAR 0 29
116744: PUSH
116745: LD_INT 0
116747: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
116748: LD_VAR 0 4
116752: PUSH
116753: LD_VAR 0 7
116757: ARRAY
116758: PPUSH
116759: CALL_OW 301
116763: PUSH
116764: LD_VAR 0 4
116768: PUSH
116769: LD_VAR 0 7
116773: ARRAY
116774: NOT
116775: OR
116776: IFFALSE 116885
// begin if GetType ( group [ i ] ) = unit_human then
116778: LD_VAR 0 4
116782: PUSH
116783: LD_VAR 0 7
116787: ARRAY
116788: PPUSH
116789: CALL_OW 247
116793: PUSH
116794: LD_INT 1
116796: EQUAL
116797: IFFALSE 116843
// begin to_heal := to_heal diff group [ i ] ;
116799: LD_ADDR_VAR 0 30
116803: PUSH
116804: LD_VAR 0 30
116808: PUSH
116809: LD_VAR 0 4
116813: PUSH
116814: LD_VAR 0 7
116818: ARRAY
116819: DIFF
116820: ST_TO_ADDR
// healers := healers diff group [ i ] ;
116821: LD_ADDR_VAR 0 31
116825: PUSH
116826: LD_VAR 0 31
116830: PUSH
116831: LD_VAR 0 4
116835: PUSH
116836: LD_VAR 0 7
116840: ARRAY
116841: DIFF
116842: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
116843: LD_ADDR_VAR 0 4
116847: PUSH
116848: LD_VAR 0 4
116852: PPUSH
116853: LD_VAR 0 7
116857: PPUSH
116858: CALL_OW 3
116862: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
116863: LD_ADDR_VAR 0 16
116867: PUSH
116868: LD_VAR 0 16
116872: PPUSH
116873: LD_VAR 0 7
116877: PPUSH
116878: CALL_OW 3
116882: ST_TO_ADDR
// continue ;
116883: GO 116723
// end ; if f_repair then
116885: LD_VAR 0 22
116889: IFFALSE 117378
// begin if GetType ( group [ i ] ) = unit_vehicle then
116891: LD_VAR 0 4
116895: PUSH
116896: LD_VAR 0 7
116900: ARRAY
116901: PPUSH
116902: CALL_OW 247
116906: PUSH
116907: LD_INT 2
116909: EQUAL
116910: IFFALSE 117100
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
116912: LD_VAR 0 4
116916: PUSH
116917: LD_VAR 0 7
116921: ARRAY
116922: PPUSH
116923: CALL_OW 256
116927: PUSH
116928: LD_INT 700
116930: LESS
116931: PUSH
116932: LD_VAR 0 4
116936: PUSH
116937: LD_VAR 0 7
116941: ARRAY
116942: PUSH
116943: LD_VAR 0 32
116947: IN
116948: NOT
116949: AND
116950: IFFALSE 116974
// to_repair := to_repair union group [ i ] ;
116952: LD_ADDR_VAR 0 32
116956: PUSH
116957: LD_VAR 0 32
116961: PUSH
116962: LD_VAR 0 4
116966: PUSH
116967: LD_VAR 0 7
116971: ARRAY
116972: UNION
116973: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
116974: LD_VAR 0 4
116978: PUSH
116979: LD_VAR 0 7
116983: ARRAY
116984: PPUSH
116985: CALL_OW 256
116989: PUSH
116990: LD_INT 1000
116992: EQUAL
116993: PUSH
116994: LD_VAR 0 4
116998: PUSH
116999: LD_VAR 0 7
117003: ARRAY
117004: PUSH
117005: LD_VAR 0 32
117009: IN
117010: AND
117011: IFFALSE 117035
// to_repair := to_repair diff group [ i ] ;
117013: LD_ADDR_VAR 0 32
117017: PUSH
117018: LD_VAR 0 32
117022: PUSH
117023: LD_VAR 0 4
117027: PUSH
117028: LD_VAR 0 7
117032: ARRAY
117033: DIFF
117034: ST_TO_ADDR
// if group [ i ] in to_repair then
117035: LD_VAR 0 4
117039: PUSH
117040: LD_VAR 0 7
117044: ARRAY
117045: PUSH
117046: LD_VAR 0 32
117050: IN
117051: IFFALSE 117098
// begin if not IsInArea ( group [ i ] , f_repair ) then
117053: LD_VAR 0 4
117057: PUSH
117058: LD_VAR 0 7
117062: ARRAY
117063: PPUSH
117064: LD_VAR 0 22
117068: PPUSH
117069: CALL_OW 308
117073: NOT
117074: IFFALSE 117096
// ComMoveToArea ( group [ i ] , f_repair ) ;
117076: LD_VAR 0 4
117080: PUSH
117081: LD_VAR 0 7
117085: ARRAY
117086: PPUSH
117087: LD_VAR 0 22
117091: PPUSH
117092: CALL_OW 113
// continue ;
117096: GO 116723
// end ; end else
117098: GO 117378
// if group [ i ] in repairs then
117100: LD_VAR 0 4
117104: PUSH
117105: LD_VAR 0 7
117109: ARRAY
117110: PUSH
117111: LD_VAR 0 33
117115: IN
117116: IFFALSE 117378
// begin if IsInUnit ( group [ i ] ) then
117118: LD_VAR 0 4
117122: PUSH
117123: LD_VAR 0 7
117127: ARRAY
117128: PPUSH
117129: CALL_OW 310
117133: IFFALSE 117201
// begin z := IsInUnit ( group [ i ] ) ;
117135: LD_ADDR_VAR 0 13
117139: PUSH
117140: LD_VAR 0 4
117144: PUSH
117145: LD_VAR 0 7
117149: ARRAY
117150: PPUSH
117151: CALL_OW 310
117155: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
117156: LD_VAR 0 13
117160: PUSH
117161: LD_VAR 0 32
117165: IN
117166: PUSH
117167: LD_VAR 0 13
117171: PPUSH
117172: LD_VAR 0 22
117176: PPUSH
117177: CALL_OW 308
117181: AND
117182: IFFALSE 117199
// ComExitVehicle ( group [ i ] ) ;
117184: LD_VAR 0 4
117188: PUSH
117189: LD_VAR 0 7
117193: ARRAY
117194: PPUSH
117195: CALL_OW 121
// end else
117199: GO 117378
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
117201: LD_ADDR_VAR 0 13
117205: PUSH
117206: LD_VAR 0 4
117210: PPUSH
117211: LD_INT 95
117213: PUSH
117214: LD_VAR 0 22
117218: PUSH
117219: EMPTY
117220: LIST
117221: LIST
117222: PUSH
117223: LD_INT 58
117225: PUSH
117226: EMPTY
117227: LIST
117228: PUSH
117229: EMPTY
117230: LIST
117231: LIST
117232: PPUSH
117233: CALL_OW 72
117237: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
117238: LD_VAR 0 4
117242: PUSH
117243: LD_VAR 0 7
117247: ARRAY
117248: PPUSH
117249: CALL_OW 314
117253: NOT
117254: IFFALSE 117376
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
117256: LD_ADDR_VAR 0 10
117260: PUSH
117261: LD_VAR 0 13
117265: PPUSH
117266: LD_VAR 0 4
117270: PUSH
117271: LD_VAR 0 7
117275: ARRAY
117276: PPUSH
117277: CALL_OW 74
117281: ST_TO_ADDR
// if not x then
117282: LD_VAR 0 10
117286: NOT
117287: IFFALSE 117291
// continue ;
117289: GO 116723
// if GetLives ( x ) < 1000 then
117291: LD_VAR 0 10
117295: PPUSH
117296: CALL_OW 256
117300: PUSH
117301: LD_INT 1000
117303: LESS
117304: IFFALSE 117328
// ComRepairVehicle ( group [ i ] , x ) else
117306: LD_VAR 0 4
117310: PUSH
117311: LD_VAR 0 7
117315: ARRAY
117316: PPUSH
117317: LD_VAR 0 10
117321: PPUSH
117322: CALL_OW 129
117326: GO 117376
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
117328: LD_VAR 0 23
117332: PUSH
117333: LD_VAR 0 4
117337: PUSH
117338: LD_VAR 0 7
117342: ARRAY
117343: PPUSH
117344: CALL_OW 256
117348: PUSH
117349: LD_INT 1000
117351: LESS
117352: AND
117353: NOT
117354: IFFALSE 117376
// ComEnterUnit ( group [ i ] , x ) ;
117356: LD_VAR 0 4
117360: PUSH
117361: LD_VAR 0 7
117365: ARRAY
117366: PPUSH
117367: LD_VAR 0 10
117371: PPUSH
117372: CALL_OW 120
// end ; continue ;
117376: GO 116723
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
117378: LD_VAR 0 23
117382: PUSH
117383: LD_VAR 0 4
117387: PUSH
117388: LD_VAR 0 7
117392: ARRAY
117393: PPUSH
117394: CALL_OW 247
117398: PUSH
117399: LD_INT 1
117401: EQUAL
117402: AND
117403: IFFALSE 117881
// begin if group [ i ] in healers then
117405: LD_VAR 0 4
117409: PUSH
117410: LD_VAR 0 7
117414: ARRAY
117415: PUSH
117416: LD_VAR 0 31
117420: IN
117421: IFFALSE 117694
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
117423: LD_VAR 0 4
117427: PUSH
117428: LD_VAR 0 7
117432: ARRAY
117433: PPUSH
117434: LD_VAR 0 23
117438: PPUSH
117439: CALL_OW 308
117443: NOT
117444: PUSH
117445: LD_VAR 0 4
117449: PUSH
117450: LD_VAR 0 7
117454: ARRAY
117455: PPUSH
117456: CALL_OW 314
117460: NOT
117461: AND
117462: IFFALSE 117486
// ComMoveToArea ( group [ i ] , f_heal ) else
117464: LD_VAR 0 4
117468: PUSH
117469: LD_VAR 0 7
117473: ARRAY
117474: PPUSH
117475: LD_VAR 0 23
117479: PPUSH
117480: CALL_OW 113
117484: GO 117692
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
117486: LD_VAR 0 4
117490: PUSH
117491: LD_VAR 0 7
117495: ARRAY
117496: PPUSH
117497: CALL 88340 0 1
117501: PPUSH
117502: CALL_OW 256
117506: PUSH
117507: LD_INT 1000
117509: EQUAL
117510: IFFALSE 117529
// ComStop ( group [ i ] ) else
117512: LD_VAR 0 4
117516: PUSH
117517: LD_VAR 0 7
117521: ARRAY
117522: PPUSH
117523: CALL_OW 141
117527: GO 117692
// if not HasTask ( group [ i ] ) and to_heal then
117529: LD_VAR 0 4
117533: PUSH
117534: LD_VAR 0 7
117538: ARRAY
117539: PPUSH
117540: CALL_OW 314
117544: NOT
117545: PUSH
117546: LD_VAR 0 30
117550: AND
117551: IFFALSE 117692
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
117553: LD_ADDR_VAR 0 13
117557: PUSH
117558: LD_VAR 0 30
117562: PPUSH
117563: LD_INT 3
117565: PUSH
117566: LD_INT 54
117568: PUSH
117569: EMPTY
117570: LIST
117571: PUSH
117572: EMPTY
117573: LIST
117574: LIST
117575: PPUSH
117576: CALL_OW 72
117580: PPUSH
117581: LD_VAR 0 4
117585: PUSH
117586: LD_VAR 0 7
117590: ARRAY
117591: PPUSH
117592: CALL_OW 74
117596: ST_TO_ADDR
// if z then
117597: LD_VAR 0 13
117601: IFFALSE 117692
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
117603: LD_INT 91
117605: PUSH
117606: LD_VAR 0 13
117610: PUSH
117611: LD_INT 10
117613: PUSH
117614: EMPTY
117615: LIST
117616: LIST
117617: LIST
117618: PUSH
117619: LD_INT 81
117621: PUSH
117622: LD_VAR 0 13
117626: PPUSH
117627: CALL_OW 255
117631: PUSH
117632: EMPTY
117633: LIST
117634: LIST
117635: PUSH
117636: EMPTY
117637: LIST
117638: LIST
117639: PPUSH
117640: CALL_OW 69
117644: PUSH
117645: LD_INT 0
117647: EQUAL
117648: IFFALSE 117672
// ComHeal ( group [ i ] , z ) else
117650: LD_VAR 0 4
117654: PUSH
117655: LD_VAR 0 7
117659: ARRAY
117660: PPUSH
117661: LD_VAR 0 13
117665: PPUSH
117666: CALL_OW 128
117670: GO 117692
// ComMoveToArea ( group [ i ] , f_heal ) ;
117672: LD_VAR 0 4
117676: PUSH
117677: LD_VAR 0 7
117681: ARRAY
117682: PPUSH
117683: LD_VAR 0 23
117687: PPUSH
117688: CALL_OW 113
// end ; continue ;
117692: GO 116723
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
117694: LD_VAR 0 4
117698: PUSH
117699: LD_VAR 0 7
117703: ARRAY
117704: PPUSH
117705: CALL_OW 256
117709: PUSH
117710: LD_INT 700
117712: LESS
117713: PUSH
117714: LD_VAR 0 4
117718: PUSH
117719: LD_VAR 0 7
117723: ARRAY
117724: PUSH
117725: LD_VAR 0 30
117729: IN
117730: NOT
117731: AND
117732: IFFALSE 117756
// to_heal := to_heal union group [ i ] ;
117734: LD_ADDR_VAR 0 30
117738: PUSH
117739: LD_VAR 0 30
117743: PUSH
117744: LD_VAR 0 4
117748: PUSH
117749: LD_VAR 0 7
117753: ARRAY
117754: UNION
117755: ST_TO_ADDR
// if group [ i ] in to_heal then
117756: LD_VAR 0 4
117760: PUSH
117761: LD_VAR 0 7
117765: ARRAY
117766: PUSH
117767: LD_VAR 0 30
117771: IN
117772: IFFALSE 117881
// begin if GetLives ( group [ i ] ) = 1000 then
117774: LD_VAR 0 4
117778: PUSH
117779: LD_VAR 0 7
117783: ARRAY
117784: PPUSH
117785: CALL_OW 256
117789: PUSH
117790: LD_INT 1000
117792: EQUAL
117793: IFFALSE 117819
// to_heal := to_heal diff group [ i ] else
117795: LD_ADDR_VAR 0 30
117799: PUSH
117800: LD_VAR 0 30
117804: PUSH
117805: LD_VAR 0 4
117809: PUSH
117810: LD_VAR 0 7
117814: ARRAY
117815: DIFF
117816: ST_TO_ADDR
117817: GO 117881
// begin if not IsInArea ( group [ i ] , to_heal ) then
117819: LD_VAR 0 4
117823: PUSH
117824: LD_VAR 0 7
117828: ARRAY
117829: PPUSH
117830: LD_VAR 0 30
117834: PPUSH
117835: CALL_OW 308
117839: NOT
117840: IFFALSE 117864
// ComMoveToArea ( group [ i ] , f_heal ) else
117842: LD_VAR 0 4
117846: PUSH
117847: LD_VAR 0 7
117851: ARRAY
117852: PPUSH
117853: LD_VAR 0 23
117857: PPUSH
117858: CALL_OW 113
117862: GO 117879
// ComHold ( group [ i ] ) ;
117864: LD_VAR 0 4
117868: PUSH
117869: LD_VAR 0 7
117873: ARRAY
117874: PPUSH
117875: CALL_OW 140
// continue ;
117879: GO 116723
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
117881: LD_VAR 0 4
117885: PUSH
117886: LD_VAR 0 7
117890: ARRAY
117891: PPUSH
117892: LD_INT 10
117894: PPUSH
117895: CALL 86111 0 2
117899: NOT
117900: PUSH
117901: LD_VAR 0 16
117905: PUSH
117906: LD_VAR 0 7
117910: ARRAY
117911: PUSH
117912: EMPTY
117913: EQUAL
117914: NOT
117915: AND
117916: IFFALSE 118182
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
117918: LD_VAR 0 4
117922: PUSH
117923: LD_VAR 0 7
117927: ARRAY
117928: PPUSH
117929: CALL_OW 262
117933: PUSH
117934: LD_INT 1
117936: PUSH
117937: LD_INT 2
117939: PUSH
117940: EMPTY
117941: LIST
117942: LIST
117943: IN
117944: IFFALSE 117985
// if GetFuel ( group [ i ] ) < 10 then
117946: LD_VAR 0 4
117950: PUSH
117951: LD_VAR 0 7
117955: ARRAY
117956: PPUSH
117957: CALL_OW 261
117961: PUSH
117962: LD_INT 10
117964: LESS
117965: IFFALSE 117985
// SetFuel ( group [ i ] , 12 ) ;
117967: LD_VAR 0 4
117971: PUSH
117972: LD_VAR 0 7
117976: ARRAY
117977: PPUSH
117978: LD_INT 12
117980: PPUSH
117981: CALL_OW 240
// if units_path [ i ] then
117985: LD_VAR 0 16
117989: PUSH
117990: LD_VAR 0 7
117994: ARRAY
117995: IFFALSE 118180
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
117997: LD_VAR 0 4
118001: PUSH
118002: LD_VAR 0 7
118006: ARRAY
118007: PPUSH
118008: LD_VAR 0 16
118012: PUSH
118013: LD_VAR 0 7
118017: ARRAY
118018: PUSH
118019: LD_INT 1
118021: ARRAY
118022: PUSH
118023: LD_INT 1
118025: ARRAY
118026: PPUSH
118027: LD_VAR 0 16
118031: PUSH
118032: LD_VAR 0 7
118036: ARRAY
118037: PUSH
118038: LD_INT 1
118040: ARRAY
118041: PUSH
118042: LD_INT 2
118044: ARRAY
118045: PPUSH
118046: CALL_OW 297
118050: PUSH
118051: LD_INT 6
118053: GREATER
118054: IFFALSE 118129
// begin if not HasTask ( group [ i ] ) then
118056: LD_VAR 0 4
118060: PUSH
118061: LD_VAR 0 7
118065: ARRAY
118066: PPUSH
118067: CALL_OW 314
118071: NOT
118072: IFFALSE 118127
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
118074: LD_VAR 0 4
118078: PUSH
118079: LD_VAR 0 7
118083: ARRAY
118084: PPUSH
118085: LD_VAR 0 16
118089: PUSH
118090: LD_VAR 0 7
118094: ARRAY
118095: PUSH
118096: LD_INT 1
118098: ARRAY
118099: PUSH
118100: LD_INT 1
118102: ARRAY
118103: PPUSH
118104: LD_VAR 0 16
118108: PUSH
118109: LD_VAR 0 7
118113: ARRAY
118114: PUSH
118115: LD_INT 1
118117: ARRAY
118118: PUSH
118119: LD_INT 2
118121: ARRAY
118122: PPUSH
118123: CALL_OW 114
// end else
118127: GO 118180
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
118129: LD_ADDR_VAR 0 15
118133: PUSH
118134: LD_VAR 0 16
118138: PUSH
118139: LD_VAR 0 7
118143: ARRAY
118144: PPUSH
118145: LD_INT 1
118147: PPUSH
118148: CALL_OW 3
118152: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
118153: LD_ADDR_VAR 0 16
118157: PUSH
118158: LD_VAR 0 16
118162: PPUSH
118163: LD_VAR 0 7
118167: PPUSH
118168: LD_VAR 0 15
118172: PPUSH
118173: CALL_OW 1
118177: ST_TO_ADDR
// continue ;
118178: GO 116723
// end ; end ; end else
118180: GO 120844
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
118182: LD_ADDR_VAR 0 14
118186: PUSH
118187: LD_INT 81
118189: PUSH
118190: LD_VAR 0 4
118194: PUSH
118195: LD_VAR 0 7
118199: ARRAY
118200: PPUSH
118201: CALL_OW 255
118205: PUSH
118206: EMPTY
118207: LIST
118208: LIST
118209: PPUSH
118210: CALL_OW 69
118214: ST_TO_ADDR
// if not tmp then
118215: LD_VAR 0 14
118219: NOT
118220: IFFALSE 118224
// continue ;
118222: GO 116723
// if f_ignore_area then
118224: LD_VAR 0 17
118228: IFFALSE 118316
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
118230: LD_ADDR_VAR 0 15
118234: PUSH
118235: LD_VAR 0 14
118239: PPUSH
118240: LD_INT 3
118242: PUSH
118243: LD_INT 92
118245: PUSH
118246: LD_VAR 0 17
118250: PUSH
118251: LD_INT 1
118253: ARRAY
118254: PUSH
118255: LD_VAR 0 17
118259: PUSH
118260: LD_INT 2
118262: ARRAY
118263: PUSH
118264: LD_VAR 0 17
118268: PUSH
118269: LD_INT 3
118271: ARRAY
118272: PUSH
118273: EMPTY
118274: LIST
118275: LIST
118276: LIST
118277: LIST
118278: PUSH
118279: EMPTY
118280: LIST
118281: LIST
118282: PPUSH
118283: CALL_OW 72
118287: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
118288: LD_VAR 0 14
118292: PUSH
118293: LD_VAR 0 15
118297: DIFF
118298: IFFALSE 118316
// tmp := tmp diff tmp2 ;
118300: LD_ADDR_VAR 0 14
118304: PUSH
118305: LD_VAR 0 14
118309: PUSH
118310: LD_VAR 0 15
118314: DIFF
118315: ST_TO_ADDR
// end ; if not f_murder then
118316: LD_VAR 0 20
118320: NOT
118321: IFFALSE 118379
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
118323: LD_ADDR_VAR 0 15
118327: PUSH
118328: LD_VAR 0 14
118332: PPUSH
118333: LD_INT 3
118335: PUSH
118336: LD_INT 50
118338: PUSH
118339: EMPTY
118340: LIST
118341: PUSH
118342: EMPTY
118343: LIST
118344: LIST
118345: PPUSH
118346: CALL_OW 72
118350: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
118351: LD_VAR 0 14
118355: PUSH
118356: LD_VAR 0 15
118360: DIFF
118361: IFFALSE 118379
// tmp := tmp diff tmp2 ;
118363: LD_ADDR_VAR 0 14
118367: PUSH
118368: LD_VAR 0 14
118372: PUSH
118373: LD_VAR 0 15
118377: DIFF
118378: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
118379: LD_ADDR_VAR 0 14
118383: PUSH
118384: LD_VAR 0 4
118388: PUSH
118389: LD_VAR 0 7
118393: ARRAY
118394: PPUSH
118395: LD_VAR 0 14
118399: PPUSH
118400: LD_INT 1
118402: PPUSH
118403: LD_INT 1
118405: PPUSH
118406: CALL 58655 0 4
118410: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
118411: LD_VAR 0 4
118415: PUSH
118416: LD_VAR 0 7
118420: ARRAY
118421: PPUSH
118422: CALL_OW 257
118426: PUSH
118427: LD_INT 1
118429: EQUAL
118430: IFFALSE 118878
// begin if WantPlant ( group [ i ] ) then
118432: LD_VAR 0 4
118436: PUSH
118437: LD_VAR 0 7
118441: ARRAY
118442: PPUSH
118443: CALL 58156 0 1
118447: IFFALSE 118451
// continue ;
118449: GO 116723
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
118451: LD_VAR 0 18
118455: PUSH
118456: LD_VAR 0 4
118460: PUSH
118461: LD_VAR 0 7
118465: ARRAY
118466: PPUSH
118467: CALL_OW 310
118471: NOT
118472: AND
118473: PUSH
118474: LD_VAR 0 14
118478: PUSH
118479: LD_INT 1
118481: ARRAY
118482: PUSH
118483: LD_VAR 0 14
118487: PPUSH
118488: LD_INT 21
118490: PUSH
118491: LD_INT 2
118493: PUSH
118494: EMPTY
118495: LIST
118496: LIST
118497: PUSH
118498: LD_INT 58
118500: PUSH
118501: EMPTY
118502: LIST
118503: PUSH
118504: EMPTY
118505: LIST
118506: LIST
118507: PPUSH
118508: CALL_OW 72
118512: IN
118513: AND
118514: IFFALSE 118550
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
118516: LD_VAR 0 4
118520: PUSH
118521: LD_VAR 0 7
118525: ARRAY
118526: PPUSH
118527: LD_VAR 0 14
118531: PUSH
118532: LD_INT 1
118534: ARRAY
118535: PPUSH
118536: CALL_OW 120
// attacking := true ;
118540: LD_ADDR_VAR 0 29
118544: PUSH
118545: LD_INT 1
118547: ST_TO_ADDR
// continue ;
118548: GO 116723
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
118550: LD_VAR 0 26
118554: PUSH
118555: LD_VAR 0 4
118559: PUSH
118560: LD_VAR 0 7
118564: ARRAY
118565: PPUSH
118566: CALL_OW 257
118570: PUSH
118571: LD_INT 1
118573: EQUAL
118574: AND
118575: PUSH
118576: LD_VAR 0 4
118580: PUSH
118581: LD_VAR 0 7
118585: ARRAY
118586: PPUSH
118587: CALL_OW 256
118591: PUSH
118592: LD_INT 800
118594: LESS
118595: AND
118596: PUSH
118597: LD_VAR 0 4
118601: PUSH
118602: LD_VAR 0 7
118606: ARRAY
118607: PPUSH
118608: CALL_OW 318
118612: NOT
118613: AND
118614: IFFALSE 118631
// ComCrawl ( group [ i ] ) ;
118616: LD_VAR 0 4
118620: PUSH
118621: LD_VAR 0 7
118625: ARRAY
118626: PPUSH
118627: CALL_OW 137
// if f_mines then
118631: LD_VAR 0 21
118635: IFFALSE 118878
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
118637: LD_VAR 0 14
118641: PUSH
118642: LD_INT 1
118644: ARRAY
118645: PPUSH
118646: CALL_OW 247
118650: PUSH
118651: LD_INT 3
118653: EQUAL
118654: PUSH
118655: LD_VAR 0 14
118659: PUSH
118660: LD_INT 1
118662: ARRAY
118663: PUSH
118664: LD_VAR 0 27
118668: IN
118669: NOT
118670: AND
118671: IFFALSE 118878
// begin x := GetX ( tmp [ 1 ] ) ;
118673: LD_ADDR_VAR 0 10
118677: PUSH
118678: LD_VAR 0 14
118682: PUSH
118683: LD_INT 1
118685: ARRAY
118686: PPUSH
118687: CALL_OW 250
118691: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
118692: LD_ADDR_VAR 0 11
118696: PUSH
118697: LD_VAR 0 14
118701: PUSH
118702: LD_INT 1
118704: ARRAY
118705: PPUSH
118706: CALL_OW 251
118710: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
118711: LD_ADDR_VAR 0 12
118715: PUSH
118716: LD_VAR 0 4
118720: PUSH
118721: LD_VAR 0 7
118725: ARRAY
118726: PPUSH
118727: CALL 86196 0 1
118731: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
118732: LD_VAR 0 4
118736: PUSH
118737: LD_VAR 0 7
118741: ARRAY
118742: PPUSH
118743: LD_VAR 0 10
118747: PPUSH
118748: LD_VAR 0 11
118752: PPUSH
118753: LD_VAR 0 14
118757: PUSH
118758: LD_INT 1
118760: ARRAY
118761: PPUSH
118762: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
118766: LD_VAR 0 4
118770: PUSH
118771: LD_VAR 0 7
118775: ARRAY
118776: PPUSH
118777: LD_VAR 0 10
118781: PPUSH
118782: LD_VAR 0 12
118786: PPUSH
118787: LD_INT 7
118789: PPUSH
118790: CALL_OW 272
118794: PPUSH
118795: LD_VAR 0 11
118799: PPUSH
118800: LD_VAR 0 12
118804: PPUSH
118805: LD_INT 7
118807: PPUSH
118808: CALL_OW 273
118812: PPUSH
118813: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
118817: LD_VAR 0 4
118821: PUSH
118822: LD_VAR 0 7
118826: ARRAY
118827: PPUSH
118828: LD_INT 71
118830: PPUSH
118831: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
118835: LD_ADDR_VAR 0 27
118839: PUSH
118840: LD_VAR 0 27
118844: PPUSH
118845: LD_VAR 0 27
118849: PUSH
118850: LD_INT 1
118852: PLUS
118853: PPUSH
118854: LD_VAR 0 14
118858: PUSH
118859: LD_INT 1
118861: ARRAY
118862: PPUSH
118863: CALL_OW 1
118867: ST_TO_ADDR
// attacking := true ;
118868: LD_ADDR_VAR 0 29
118872: PUSH
118873: LD_INT 1
118875: ST_TO_ADDR
// continue ;
118876: GO 116723
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
118878: LD_VAR 0 4
118882: PUSH
118883: LD_VAR 0 7
118887: ARRAY
118888: PPUSH
118889: CALL_OW 257
118893: PUSH
118894: LD_INT 17
118896: EQUAL
118897: PUSH
118898: LD_VAR 0 4
118902: PUSH
118903: LD_VAR 0 7
118907: ARRAY
118908: PPUSH
118909: CALL_OW 110
118913: PUSH
118914: LD_INT 71
118916: EQUAL
118917: NOT
118918: AND
118919: IFFALSE 119065
// begin attacking := false ;
118921: LD_ADDR_VAR 0 29
118925: PUSH
118926: LD_INT 0
118928: ST_TO_ADDR
// k := 5 ;
118929: LD_ADDR_VAR 0 9
118933: PUSH
118934: LD_INT 5
118936: ST_TO_ADDR
// if tmp < k then
118937: LD_VAR 0 14
118941: PUSH
118942: LD_VAR 0 9
118946: LESS
118947: IFFALSE 118959
// k := tmp ;
118949: LD_ADDR_VAR 0 9
118953: PUSH
118954: LD_VAR 0 14
118958: ST_TO_ADDR
// for j = 1 to k do
118959: LD_ADDR_VAR 0 8
118963: PUSH
118964: DOUBLE
118965: LD_INT 1
118967: DEC
118968: ST_TO_ADDR
118969: LD_VAR 0 9
118973: PUSH
118974: FOR_TO
118975: IFFALSE 119063
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
118977: LD_VAR 0 14
118981: PUSH
118982: LD_VAR 0 8
118986: ARRAY
118987: PUSH
118988: LD_VAR 0 14
118992: PPUSH
118993: LD_INT 58
118995: PUSH
118996: EMPTY
118997: LIST
118998: PPUSH
118999: CALL_OW 72
119003: IN
119004: NOT
119005: IFFALSE 119061
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119007: LD_VAR 0 4
119011: PUSH
119012: LD_VAR 0 7
119016: ARRAY
119017: PPUSH
119018: LD_VAR 0 14
119022: PUSH
119023: LD_VAR 0 8
119027: ARRAY
119028: PPUSH
119029: CALL_OW 115
// attacking := true ;
119033: LD_ADDR_VAR 0 29
119037: PUSH
119038: LD_INT 1
119040: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
119041: LD_VAR 0 4
119045: PUSH
119046: LD_VAR 0 7
119050: ARRAY
119051: PPUSH
119052: LD_INT 71
119054: PPUSH
119055: CALL_OW 109
// continue ;
119059: GO 118974
// end ; end ;
119061: GO 118974
119063: POP
119064: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
119065: LD_VAR 0 4
119069: PUSH
119070: LD_VAR 0 7
119074: ARRAY
119075: PPUSH
119076: CALL_OW 257
119080: PUSH
119081: LD_INT 8
119083: EQUAL
119084: PUSH
119085: LD_VAR 0 4
119089: PUSH
119090: LD_VAR 0 7
119094: ARRAY
119095: PPUSH
119096: CALL_OW 264
119100: PUSH
119101: LD_INT 28
119103: PUSH
119104: LD_INT 45
119106: PUSH
119107: LD_INT 7
119109: PUSH
119110: LD_INT 47
119112: PUSH
119113: EMPTY
119114: LIST
119115: LIST
119116: LIST
119117: LIST
119118: IN
119119: OR
119120: IFFALSE 119376
// begin attacking := false ;
119122: LD_ADDR_VAR 0 29
119126: PUSH
119127: LD_INT 0
119129: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
119130: LD_VAR 0 14
119134: PUSH
119135: LD_INT 1
119137: ARRAY
119138: PPUSH
119139: CALL_OW 266
119143: PUSH
119144: LD_INT 32
119146: PUSH
119147: LD_INT 31
119149: PUSH
119150: LD_INT 33
119152: PUSH
119153: LD_INT 4
119155: PUSH
119156: LD_INT 5
119158: PUSH
119159: EMPTY
119160: LIST
119161: LIST
119162: LIST
119163: LIST
119164: LIST
119165: IN
119166: IFFALSE 119352
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
119168: LD_ADDR_VAR 0 9
119172: PUSH
119173: LD_VAR 0 14
119177: PUSH
119178: LD_INT 1
119180: ARRAY
119181: PPUSH
119182: CALL_OW 266
119186: PPUSH
119187: LD_VAR 0 14
119191: PUSH
119192: LD_INT 1
119194: ARRAY
119195: PPUSH
119196: CALL_OW 250
119200: PPUSH
119201: LD_VAR 0 14
119205: PUSH
119206: LD_INT 1
119208: ARRAY
119209: PPUSH
119210: CALL_OW 251
119214: PPUSH
119215: LD_VAR 0 14
119219: PUSH
119220: LD_INT 1
119222: ARRAY
119223: PPUSH
119224: CALL_OW 254
119228: PPUSH
119229: LD_VAR 0 14
119233: PUSH
119234: LD_INT 1
119236: ARRAY
119237: PPUSH
119238: CALL_OW 248
119242: PPUSH
119243: LD_INT 0
119245: PPUSH
119246: CALL 67566 0 6
119250: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
119251: LD_ADDR_VAR 0 8
119255: PUSH
119256: LD_VAR 0 4
119260: PUSH
119261: LD_VAR 0 7
119265: ARRAY
119266: PPUSH
119267: LD_VAR 0 9
119271: PPUSH
119272: CALL 86309 0 2
119276: ST_TO_ADDR
// if j then
119277: LD_VAR 0 8
119281: IFFALSE 119350
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
119283: LD_VAR 0 8
119287: PUSH
119288: LD_INT 1
119290: ARRAY
119291: PPUSH
119292: LD_VAR 0 8
119296: PUSH
119297: LD_INT 2
119299: ARRAY
119300: PPUSH
119301: CALL_OW 488
119305: IFFALSE 119350
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
119307: LD_VAR 0 4
119311: PUSH
119312: LD_VAR 0 7
119316: ARRAY
119317: PPUSH
119318: LD_VAR 0 8
119322: PUSH
119323: LD_INT 1
119325: ARRAY
119326: PPUSH
119327: LD_VAR 0 8
119331: PUSH
119332: LD_INT 2
119334: ARRAY
119335: PPUSH
119336: CALL_OW 116
// attacking := true ;
119340: LD_ADDR_VAR 0 29
119344: PUSH
119345: LD_INT 1
119347: ST_TO_ADDR
// continue ;
119348: GO 116723
// end ; end else
119350: GO 119376
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119352: LD_VAR 0 4
119356: PUSH
119357: LD_VAR 0 7
119361: ARRAY
119362: PPUSH
119363: LD_VAR 0 14
119367: PUSH
119368: LD_INT 1
119370: ARRAY
119371: PPUSH
119372: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
119376: LD_VAR 0 4
119380: PUSH
119381: LD_VAR 0 7
119385: ARRAY
119386: PPUSH
119387: CALL_OW 265
119391: PUSH
119392: LD_INT 11
119394: EQUAL
119395: IFFALSE 119673
// begin k := 10 ;
119397: LD_ADDR_VAR 0 9
119401: PUSH
119402: LD_INT 10
119404: ST_TO_ADDR
// x := 0 ;
119405: LD_ADDR_VAR 0 10
119409: PUSH
119410: LD_INT 0
119412: ST_TO_ADDR
// if tmp < k then
119413: LD_VAR 0 14
119417: PUSH
119418: LD_VAR 0 9
119422: LESS
119423: IFFALSE 119435
// k := tmp ;
119425: LD_ADDR_VAR 0 9
119429: PUSH
119430: LD_VAR 0 14
119434: ST_TO_ADDR
// for j = k downto 1 do
119435: LD_ADDR_VAR 0 8
119439: PUSH
119440: DOUBLE
119441: LD_VAR 0 9
119445: INC
119446: ST_TO_ADDR
119447: LD_INT 1
119449: PUSH
119450: FOR_DOWNTO
119451: IFFALSE 119526
// begin if GetType ( tmp [ j ] ) = unit_human then
119453: LD_VAR 0 14
119457: PUSH
119458: LD_VAR 0 8
119462: ARRAY
119463: PPUSH
119464: CALL_OW 247
119468: PUSH
119469: LD_INT 1
119471: EQUAL
119472: IFFALSE 119524
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
119474: LD_VAR 0 4
119478: PUSH
119479: LD_VAR 0 7
119483: ARRAY
119484: PPUSH
119485: LD_VAR 0 14
119489: PUSH
119490: LD_VAR 0 8
119494: ARRAY
119495: PPUSH
119496: CALL 86563 0 2
// x := tmp [ j ] ;
119500: LD_ADDR_VAR 0 10
119504: PUSH
119505: LD_VAR 0 14
119509: PUSH
119510: LD_VAR 0 8
119514: ARRAY
119515: ST_TO_ADDR
// attacking := true ;
119516: LD_ADDR_VAR 0 29
119520: PUSH
119521: LD_INT 1
119523: ST_TO_ADDR
// end ; end ;
119524: GO 119450
119526: POP
119527: POP
// if not x then
119528: LD_VAR 0 10
119532: NOT
119533: IFFALSE 119673
// begin attacking := true ;
119535: LD_ADDR_VAR 0 29
119539: PUSH
119540: LD_INT 1
119542: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
119543: LD_VAR 0 4
119547: PUSH
119548: LD_VAR 0 7
119552: ARRAY
119553: PPUSH
119554: CALL_OW 250
119558: PPUSH
119559: LD_VAR 0 4
119563: PUSH
119564: LD_VAR 0 7
119568: ARRAY
119569: PPUSH
119570: CALL_OW 251
119574: PPUSH
119575: CALL_OW 546
119579: PUSH
119580: LD_INT 2
119582: ARRAY
119583: PUSH
119584: LD_VAR 0 14
119588: PUSH
119589: LD_INT 1
119591: ARRAY
119592: PPUSH
119593: CALL_OW 250
119597: PPUSH
119598: LD_VAR 0 14
119602: PUSH
119603: LD_INT 1
119605: ARRAY
119606: PPUSH
119607: CALL_OW 251
119611: PPUSH
119612: CALL_OW 546
119616: PUSH
119617: LD_INT 2
119619: ARRAY
119620: EQUAL
119621: IFFALSE 119649
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
119623: LD_VAR 0 4
119627: PUSH
119628: LD_VAR 0 7
119632: ARRAY
119633: PPUSH
119634: LD_VAR 0 14
119638: PUSH
119639: LD_INT 1
119641: ARRAY
119642: PPUSH
119643: CALL 86563 0 2
119647: GO 119673
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119649: LD_VAR 0 4
119653: PUSH
119654: LD_VAR 0 7
119658: ARRAY
119659: PPUSH
119660: LD_VAR 0 14
119664: PUSH
119665: LD_INT 1
119667: ARRAY
119668: PPUSH
119669: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
119673: LD_VAR 0 4
119677: PUSH
119678: LD_VAR 0 7
119682: ARRAY
119683: PPUSH
119684: CALL_OW 264
119688: PUSH
119689: LD_INT 29
119691: EQUAL
119692: IFFALSE 120058
// begin if WantsToAttack ( group [ i ] ) in bombed then
119694: LD_VAR 0 4
119698: PUSH
119699: LD_VAR 0 7
119703: ARRAY
119704: PPUSH
119705: CALL_OW 319
119709: PUSH
119710: LD_VAR 0 28
119714: IN
119715: IFFALSE 119719
// continue ;
119717: GO 116723
// k := 8 ;
119719: LD_ADDR_VAR 0 9
119723: PUSH
119724: LD_INT 8
119726: ST_TO_ADDR
// x := 0 ;
119727: LD_ADDR_VAR 0 10
119731: PUSH
119732: LD_INT 0
119734: ST_TO_ADDR
// if tmp < k then
119735: LD_VAR 0 14
119739: PUSH
119740: LD_VAR 0 9
119744: LESS
119745: IFFALSE 119757
// k := tmp ;
119747: LD_ADDR_VAR 0 9
119751: PUSH
119752: LD_VAR 0 14
119756: ST_TO_ADDR
// for j = 1 to k do
119757: LD_ADDR_VAR 0 8
119761: PUSH
119762: DOUBLE
119763: LD_INT 1
119765: DEC
119766: ST_TO_ADDR
119767: LD_VAR 0 9
119771: PUSH
119772: FOR_TO
119773: IFFALSE 119905
// begin if GetType ( tmp [ j ] ) = unit_building then
119775: LD_VAR 0 14
119779: PUSH
119780: LD_VAR 0 8
119784: ARRAY
119785: PPUSH
119786: CALL_OW 247
119790: PUSH
119791: LD_INT 3
119793: EQUAL
119794: IFFALSE 119903
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
119796: LD_VAR 0 14
119800: PUSH
119801: LD_VAR 0 8
119805: ARRAY
119806: PUSH
119807: LD_VAR 0 28
119811: IN
119812: NOT
119813: PUSH
119814: LD_VAR 0 14
119818: PUSH
119819: LD_VAR 0 8
119823: ARRAY
119824: PPUSH
119825: CALL_OW 313
119829: AND
119830: IFFALSE 119903
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119832: LD_VAR 0 4
119836: PUSH
119837: LD_VAR 0 7
119841: ARRAY
119842: PPUSH
119843: LD_VAR 0 14
119847: PUSH
119848: LD_VAR 0 8
119852: ARRAY
119853: PPUSH
119854: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
119858: LD_ADDR_VAR 0 28
119862: PUSH
119863: LD_VAR 0 28
119867: PPUSH
119868: LD_VAR 0 28
119872: PUSH
119873: LD_INT 1
119875: PLUS
119876: PPUSH
119877: LD_VAR 0 14
119881: PUSH
119882: LD_VAR 0 8
119886: ARRAY
119887: PPUSH
119888: CALL_OW 1
119892: ST_TO_ADDR
// attacking := true ;
119893: LD_ADDR_VAR 0 29
119897: PUSH
119898: LD_INT 1
119900: ST_TO_ADDR
// break ;
119901: GO 119905
// end ; end ;
119903: GO 119772
119905: POP
119906: POP
// if not attacking and f_attack_depot then
119907: LD_VAR 0 29
119911: NOT
119912: PUSH
119913: LD_VAR 0 25
119917: AND
119918: IFFALSE 120013
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119920: LD_ADDR_VAR 0 13
119924: PUSH
119925: LD_VAR 0 14
119929: PPUSH
119930: LD_INT 2
119932: PUSH
119933: LD_INT 30
119935: PUSH
119936: LD_INT 0
119938: PUSH
119939: EMPTY
119940: LIST
119941: LIST
119942: PUSH
119943: LD_INT 30
119945: PUSH
119946: LD_INT 1
119948: PUSH
119949: EMPTY
119950: LIST
119951: LIST
119952: PUSH
119953: EMPTY
119954: LIST
119955: LIST
119956: LIST
119957: PPUSH
119958: CALL_OW 72
119962: ST_TO_ADDR
// if z then
119963: LD_VAR 0 13
119967: IFFALSE 120013
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
119969: LD_VAR 0 4
119973: PUSH
119974: LD_VAR 0 7
119978: ARRAY
119979: PPUSH
119980: LD_VAR 0 13
119984: PPUSH
119985: LD_VAR 0 4
119989: PUSH
119990: LD_VAR 0 7
119994: ARRAY
119995: PPUSH
119996: CALL_OW 74
120000: PPUSH
120001: CALL_OW 115
// attacking := true ;
120005: LD_ADDR_VAR 0 29
120009: PUSH
120010: LD_INT 1
120012: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
120013: LD_VAR 0 4
120017: PUSH
120018: LD_VAR 0 7
120022: ARRAY
120023: PPUSH
120024: CALL_OW 256
120028: PUSH
120029: LD_INT 500
120031: LESS
120032: IFFALSE 120058
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120034: LD_VAR 0 4
120038: PUSH
120039: LD_VAR 0 7
120043: ARRAY
120044: PPUSH
120045: LD_VAR 0 14
120049: PUSH
120050: LD_INT 1
120052: ARRAY
120053: PPUSH
120054: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
120058: LD_VAR 0 4
120062: PUSH
120063: LD_VAR 0 7
120067: ARRAY
120068: PPUSH
120069: CALL_OW 264
120073: PUSH
120074: LD_INT 49
120076: EQUAL
120077: IFFALSE 120198
// begin if not HasTask ( group [ i ] ) then
120079: LD_VAR 0 4
120083: PUSH
120084: LD_VAR 0 7
120088: ARRAY
120089: PPUSH
120090: CALL_OW 314
120094: NOT
120095: IFFALSE 120198
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
120097: LD_ADDR_VAR 0 9
120101: PUSH
120102: LD_INT 81
120104: PUSH
120105: LD_VAR 0 4
120109: PUSH
120110: LD_VAR 0 7
120114: ARRAY
120115: PPUSH
120116: CALL_OW 255
120120: PUSH
120121: EMPTY
120122: LIST
120123: LIST
120124: PPUSH
120125: CALL_OW 69
120129: PPUSH
120130: LD_VAR 0 4
120134: PUSH
120135: LD_VAR 0 7
120139: ARRAY
120140: PPUSH
120141: CALL_OW 74
120145: ST_TO_ADDR
// if k then
120146: LD_VAR 0 9
120150: IFFALSE 120198
// if GetDistUnits ( group [ i ] , k ) > 10 then
120152: LD_VAR 0 4
120156: PUSH
120157: LD_VAR 0 7
120161: ARRAY
120162: PPUSH
120163: LD_VAR 0 9
120167: PPUSH
120168: CALL_OW 296
120172: PUSH
120173: LD_INT 10
120175: GREATER
120176: IFFALSE 120198
// ComMoveUnit ( group [ i ] , k ) ;
120178: LD_VAR 0 4
120182: PUSH
120183: LD_VAR 0 7
120187: ARRAY
120188: PPUSH
120189: LD_VAR 0 9
120193: PPUSH
120194: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
120198: LD_VAR 0 4
120202: PUSH
120203: LD_VAR 0 7
120207: ARRAY
120208: PPUSH
120209: CALL_OW 256
120213: PUSH
120214: LD_INT 250
120216: LESS
120217: PUSH
120218: LD_VAR 0 4
120222: PUSH
120223: LD_VAR 0 7
120227: ARRAY
120228: PUSH
120229: LD_INT 21
120231: PUSH
120232: LD_INT 2
120234: PUSH
120235: EMPTY
120236: LIST
120237: LIST
120238: PUSH
120239: LD_INT 23
120241: PUSH
120242: LD_INT 2
120244: PUSH
120245: EMPTY
120246: LIST
120247: LIST
120248: PUSH
120249: EMPTY
120250: LIST
120251: LIST
120252: PPUSH
120253: CALL_OW 69
120257: IN
120258: AND
120259: IFFALSE 120384
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
120261: LD_ADDR_VAR 0 9
120265: PUSH
120266: LD_OWVAR 3
120270: PUSH
120271: LD_VAR 0 4
120275: PUSH
120276: LD_VAR 0 7
120280: ARRAY
120281: DIFF
120282: PPUSH
120283: LD_VAR 0 4
120287: PUSH
120288: LD_VAR 0 7
120292: ARRAY
120293: PPUSH
120294: CALL_OW 74
120298: ST_TO_ADDR
// if not k then
120299: LD_VAR 0 9
120303: NOT
120304: IFFALSE 120308
// continue ;
120306: GO 116723
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
120308: LD_VAR 0 9
120312: PUSH
120313: LD_INT 81
120315: PUSH
120316: LD_VAR 0 4
120320: PUSH
120321: LD_VAR 0 7
120325: ARRAY
120326: PPUSH
120327: CALL_OW 255
120331: PUSH
120332: EMPTY
120333: LIST
120334: LIST
120335: PPUSH
120336: CALL_OW 69
120340: IN
120341: PUSH
120342: LD_VAR 0 9
120346: PPUSH
120347: LD_VAR 0 4
120351: PUSH
120352: LD_VAR 0 7
120356: ARRAY
120357: PPUSH
120358: CALL_OW 296
120362: PUSH
120363: LD_INT 5
120365: LESS
120366: AND
120367: IFFALSE 120384
// ComAutodestruct ( group [ i ] ) ;
120369: LD_VAR 0 4
120373: PUSH
120374: LD_VAR 0 7
120378: ARRAY
120379: PPUSH
120380: CALL 86461 0 1
// end ; if f_attack_depot then
120384: LD_VAR 0 25
120388: IFFALSE 120500
// begin k := 6 ;
120390: LD_ADDR_VAR 0 9
120394: PUSH
120395: LD_INT 6
120397: ST_TO_ADDR
// if tmp < k then
120398: LD_VAR 0 14
120402: PUSH
120403: LD_VAR 0 9
120407: LESS
120408: IFFALSE 120420
// k := tmp ;
120410: LD_ADDR_VAR 0 9
120414: PUSH
120415: LD_VAR 0 14
120419: ST_TO_ADDR
// for j = 1 to k do
120420: LD_ADDR_VAR 0 8
120424: PUSH
120425: DOUBLE
120426: LD_INT 1
120428: DEC
120429: ST_TO_ADDR
120430: LD_VAR 0 9
120434: PUSH
120435: FOR_TO
120436: IFFALSE 120498
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
120438: LD_VAR 0 8
120442: PPUSH
120443: CALL_OW 266
120447: PUSH
120448: LD_INT 0
120450: PUSH
120451: LD_INT 1
120453: PUSH
120454: EMPTY
120455: LIST
120456: LIST
120457: IN
120458: IFFALSE 120496
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120460: LD_VAR 0 4
120464: PUSH
120465: LD_VAR 0 7
120469: ARRAY
120470: PPUSH
120471: LD_VAR 0 14
120475: PUSH
120476: LD_VAR 0 8
120480: ARRAY
120481: PPUSH
120482: CALL_OW 115
// attacking := true ;
120486: LD_ADDR_VAR 0 29
120490: PUSH
120491: LD_INT 1
120493: ST_TO_ADDR
// break ;
120494: GO 120498
// end ;
120496: GO 120435
120498: POP
120499: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
120500: LD_VAR 0 4
120504: PUSH
120505: LD_VAR 0 7
120509: ARRAY
120510: PPUSH
120511: CALL_OW 302
120515: PUSH
120516: LD_VAR 0 29
120520: NOT
120521: AND
120522: IFFALSE 120844
// begin if GetTag ( group [ i ] ) = 71 then
120524: LD_VAR 0 4
120528: PUSH
120529: LD_VAR 0 7
120533: ARRAY
120534: PPUSH
120535: CALL_OW 110
120539: PUSH
120540: LD_INT 71
120542: EQUAL
120543: IFFALSE 120584
// begin if HasTask ( group [ i ] ) then
120545: LD_VAR 0 4
120549: PUSH
120550: LD_VAR 0 7
120554: ARRAY
120555: PPUSH
120556: CALL_OW 314
120560: IFFALSE 120566
// continue else
120562: GO 116723
120564: GO 120584
// SetTag ( group [ i ] , 0 ) ;
120566: LD_VAR 0 4
120570: PUSH
120571: LD_VAR 0 7
120575: ARRAY
120576: PPUSH
120577: LD_INT 0
120579: PPUSH
120580: CALL_OW 109
// end ; k := 8 ;
120584: LD_ADDR_VAR 0 9
120588: PUSH
120589: LD_INT 8
120591: ST_TO_ADDR
// x := 0 ;
120592: LD_ADDR_VAR 0 10
120596: PUSH
120597: LD_INT 0
120599: ST_TO_ADDR
// if tmp < k then
120600: LD_VAR 0 14
120604: PUSH
120605: LD_VAR 0 9
120609: LESS
120610: IFFALSE 120622
// k := tmp ;
120612: LD_ADDR_VAR 0 9
120616: PUSH
120617: LD_VAR 0 14
120621: ST_TO_ADDR
// for j = 1 to k do
120622: LD_ADDR_VAR 0 8
120626: PUSH
120627: DOUBLE
120628: LD_INT 1
120630: DEC
120631: ST_TO_ADDR
120632: LD_VAR 0 9
120636: PUSH
120637: FOR_TO
120638: IFFALSE 120736
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
120640: LD_VAR 0 14
120644: PUSH
120645: LD_VAR 0 8
120649: ARRAY
120650: PPUSH
120651: CALL_OW 247
120655: PUSH
120656: LD_INT 1
120658: EQUAL
120659: PUSH
120660: LD_VAR 0 14
120664: PUSH
120665: LD_VAR 0 8
120669: ARRAY
120670: PPUSH
120671: CALL_OW 256
120675: PUSH
120676: LD_INT 250
120678: LESS
120679: PUSH
120680: LD_VAR 0 20
120684: AND
120685: PUSH
120686: LD_VAR 0 20
120690: NOT
120691: PUSH
120692: LD_VAR 0 14
120696: PUSH
120697: LD_VAR 0 8
120701: ARRAY
120702: PPUSH
120703: CALL_OW 256
120707: PUSH
120708: LD_INT 250
120710: GREATEREQUAL
120711: AND
120712: OR
120713: AND
120714: IFFALSE 120734
// begin x := tmp [ j ] ;
120716: LD_ADDR_VAR 0 10
120720: PUSH
120721: LD_VAR 0 14
120725: PUSH
120726: LD_VAR 0 8
120730: ARRAY
120731: ST_TO_ADDR
// break ;
120732: GO 120736
// end ;
120734: GO 120637
120736: POP
120737: POP
// if x then
120738: LD_VAR 0 10
120742: IFFALSE 120766
// ComAttackUnit ( group [ i ] , x ) else
120744: LD_VAR 0 4
120748: PUSH
120749: LD_VAR 0 7
120753: ARRAY
120754: PPUSH
120755: LD_VAR 0 10
120759: PPUSH
120760: CALL_OW 115
120764: GO 120790
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120766: LD_VAR 0 4
120770: PUSH
120771: LD_VAR 0 7
120775: ARRAY
120776: PPUSH
120777: LD_VAR 0 14
120781: PUSH
120782: LD_INT 1
120784: ARRAY
120785: PPUSH
120786: CALL_OW 115
// if not HasTask ( group [ i ] ) then
120790: LD_VAR 0 4
120794: PUSH
120795: LD_VAR 0 7
120799: ARRAY
120800: PPUSH
120801: CALL_OW 314
120805: NOT
120806: IFFALSE 120844
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
120808: LD_VAR 0 4
120812: PUSH
120813: LD_VAR 0 7
120817: ARRAY
120818: PPUSH
120819: LD_VAR 0 14
120823: PPUSH
120824: LD_VAR 0 4
120828: PUSH
120829: LD_VAR 0 7
120833: ARRAY
120834: PPUSH
120835: CALL_OW 74
120839: PPUSH
120840: CALL_OW 115
// end ; end ; end ;
120844: GO 116723
120846: POP
120847: POP
// wait ( 0 0$2 ) ;
120848: LD_INT 70
120850: PPUSH
120851: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
120855: LD_VAR 0 4
120859: NOT
120860: PUSH
120861: LD_VAR 0 4
120865: PUSH
120866: EMPTY
120867: EQUAL
120868: OR
120869: PUSH
120870: LD_INT 81
120872: PUSH
120873: LD_VAR 0 35
120877: PUSH
120878: EMPTY
120879: LIST
120880: LIST
120881: PPUSH
120882: CALL_OW 69
120886: NOT
120887: OR
120888: IFFALSE 116708
// end ;
120890: LD_VAR 0 2
120894: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
120895: LD_INT 0
120897: PPUSH
120898: PPUSH
120899: PPUSH
120900: PPUSH
120901: PPUSH
120902: PPUSH
// if not base or not mc_bases [ base ] or not solds then
120903: LD_VAR 0 1
120907: NOT
120908: PUSH
120909: LD_EXP 78
120913: PUSH
120914: LD_VAR 0 1
120918: ARRAY
120919: NOT
120920: OR
120921: PUSH
120922: LD_VAR 0 2
120926: NOT
120927: OR
120928: IFFALSE 120932
// exit ;
120930: GO 121486
// side := mc_sides [ base ] ;
120932: LD_ADDR_VAR 0 6
120936: PUSH
120937: LD_EXP 104
120941: PUSH
120942: LD_VAR 0 1
120946: ARRAY
120947: ST_TO_ADDR
// if not side then
120948: LD_VAR 0 6
120952: NOT
120953: IFFALSE 120957
// exit ;
120955: GO 121486
// for i in solds do
120957: LD_ADDR_VAR 0 7
120961: PUSH
120962: LD_VAR 0 2
120966: PUSH
120967: FOR_IN
120968: IFFALSE 121029
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
120970: LD_VAR 0 7
120974: PPUSH
120975: CALL_OW 310
120979: PPUSH
120980: CALL_OW 266
120984: PUSH
120985: LD_INT 32
120987: PUSH
120988: LD_INT 31
120990: PUSH
120991: EMPTY
120992: LIST
120993: LIST
120994: IN
120995: IFFALSE 121015
// solds := solds diff i else
120997: LD_ADDR_VAR 0 2
121001: PUSH
121002: LD_VAR 0 2
121006: PUSH
121007: LD_VAR 0 7
121011: DIFF
121012: ST_TO_ADDR
121013: GO 121027
// SetTag ( i , 18 ) ;
121015: LD_VAR 0 7
121019: PPUSH
121020: LD_INT 18
121022: PPUSH
121023: CALL_OW 109
121027: GO 120967
121029: POP
121030: POP
// if not solds then
121031: LD_VAR 0 2
121035: NOT
121036: IFFALSE 121040
// exit ;
121038: GO 121486
// repeat wait ( 0 0$2 ) ;
121040: LD_INT 70
121042: PPUSH
121043: CALL_OW 67
// enemy := mc_scan [ base ] ;
121047: LD_ADDR_VAR 0 4
121051: PUSH
121052: LD_EXP 101
121056: PUSH
121057: LD_VAR 0 1
121061: ARRAY
121062: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121063: LD_EXP 78
121067: PUSH
121068: LD_VAR 0 1
121072: ARRAY
121073: NOT
121074: PUSH
121075: LD_EXP 78
121079: PUSH
121080: LD_VAR 0 1
121084: ARRAY
121085: PUSH
121086: EMPTY
121087: EQUAL
121088: OR
121089: IFFALSE 121126
// begin for i in solds do
121091: LD_ADDR_VAR 0 7
121095: PUSH
121096: LD_VAR 0 2
121100: PUSH
121101: FOR_IN
121102: IFFALSE 121115
// ComStop ( i ) ;
121104: LD_VAR 0 7
121108: PPUSH
121109: CALL_OW 141
121113: GO 121101
121115: POP
121116: POP
// solds := [ ] ;
121117: LD_ADDR_VAR 0 2
121121: PUSH
121122: EMPTY
121123: ST_TO_ADDR
// exit ;
121124: GO 121486
// end ; for i in solds do
121126: LD_ADDR_VAR 0 7
121130: PUSH
121131: LD_VAR 0 2
121135: PUSH
121136: FOR_IN
121137: IFFALSE 121458
// begin if IsInUnit ( i ) then
121139: LD_VAR 0 7
121143: PPUSH
121144: CALL_OW 310
121148: IFFALSE 121159
// ComExitBuilding ( i ) ;
121150: LD_VAR 0 7
121154: PPUSH
121155: CALL_OW 122
// if GetLives ( i ) > 500 then
121159: LD_VAR 0 7
121163: PPUSH
121164: CALL_OW 256
121168: PUSH
121169: LD_INT 500
121171: GREATER
121172: IFFALSE 121225
// begin e := NearestUnitToUnit ( enemy , i ) ;
121174: LD_ADDR_VAR 0 5
121178: PUSH
121179: LD_VAR 0 4
121183: PPUSH
121184: LD_VAR 0 7
121188: PPUSH
121189: CALL_OW 74
121193: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
121194: LD_VAR 0 7
121198: PPUSH
121199: LD_VAR 0 5
121203: PPUSH
121204: CALL_OW 250
121208: PPUSH
121209: LD_VAR 0 5
121213: PPUSH
121214: CALL_OW 251
121218: PPUSH
121219: CALL_OW 114
// end else
121223: GO 121456
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
121225: LD_VAR 0 7
121229: PPUSH
121230: LD_EXP 78
121234: PUSH
121235: LD_VAR 0 1
121239: ARRAY
121240: PPUSH
121241: LD_INT 2
121243: PUSH
121244: LD_INT 30
121246: PUSH
121247: LD_INT 0
121249: PUSH
121250: EMPTY
121251: LIST
121252: LIST
121253: PUSH
121254: LD_INT 30
121256: PUSH
121257: LD_INT 1
121259: PUSH
121260: EMPTY
121261: LIST
121262: LIST
121263: PUSH
121264: LD_INT 30
121266: PUSH
121267: LD_INT 6
121269: PUSH
121270: EMPTY
121271: LIST
121272: LIST
121273: PUSH
121274: EMPTY
121275: LIST
121276: LIST
121277: LIST
121278: LIST
121279: PPUSH
121280: CALL_OW 72
121284: PPUSH
121285: LD_VAR 0 7
121289: PPUSH
121290: CALL_OW 74
121294: PPUSH
121295: CALL_OW 296
121299: PUSH
121300: LD_INT 10
121302: GREATER
121303: IFFALSE 121456
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
121305: LD_ADDR_VAR 0 8
121309: PUSH
121310: LD_EXP 78
121314: PUSH
121315: LD_VAR 0 1
121319: ARRAY
121320: PPUSH
121321: LD_INT 2
121323: PUSH
121324: LD_INT 30
121326: PUSH
121327: LD_INT 0
121329: PUSH
121330: EMPTY
121331: LIST
121332: LIST
121333: PUSH
121334: LD_INT 30
121336: PUSH
121337: LD_INT 1
121339: PUSH
121340: EMPTY
121341: LIST
121342: LIST
121343: PUSH
121344: LD_INT 30
121346: PUSH
121347: LD_INT 6
121349: PUSH
121350: EMPTY
121351: LIST
121352: LIST
121353: PUSH
121354: EMPTY
121355: LIST
121356: LIST
121357: LIST
121358: LIST
121359: PPUSH
121360: CALL_OW 72
121364: PPUSH
121365: LD_VAR 0 7
121369: PPUSH
121370: CALL_OW 74
121374: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
121375: LD_VAR 0 7
121379: PPUSH
121380: LD_VAR 0 8
121384: PPUSH
121385: CALL_OW 250
121389: PPUSH
121390: LD_INT 3
121392: PPUSH
121393: LD_INT 5
121395: PPUSH
121396: CALL_OW 272
121400: PPUSH
121401: LD_VAR 0 8
121405: PPUSH
121406: CALL_OW 251
121410: PPUSH
121411: LD_INT 3
121413: PPUSH
121414: LD_INT 5
121416: PPUSH
121417: CALL_OW 273
121421: PPUSH
121422: CALL_OW 111
// SetTag ( i , 0 ) ;
121426: LD_VAR 0 7
121430: PPUSH
121431: LD_INT 0
121433: PPUSH
121434: CALL_OW 109
// solds := solds diff i ;
121438: LD_ADDR_VAR 0 2
121442: PUSH
121443: LD_VAR 0 2
121447: PUSH
121448: LD_VAR 0 7
121452: DIFF
121453: ST_TO_ADDR
// continue ;
121454: GO 121136
// end ; end ;
121456: GO 121136
121458: POP
121459: POP
// until not solds or not enemy ;
121460: LD_VAR 0 2
121464: NOT
121465: PUSH
121466: LD_VAR 0 4
121470: NOT
121471: OR
121472: IFFALSE 121040
// MC_Reset ( base , 18 ) ;
121474: LD_VAR 0 1
121478: PPUSH
121479: LD_INT 18
121481: PPUSH
121482: CALL 26719 0 2
// end ;
121486: LD_VAR 0 3
121490: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
121491: LD_INT 0
121493: PPUSH
121494: PPUSH
121495: PPUSH
121496: PPUSH
121497: PPUSH
121498: PPUSH
121499: PPUSH
121500: PPUSH
121501: PPUSH
121502: PPUSH
121503: PPUSH
121504: PPUSH
121505: PPUSH
121506: PPUSH
121507: PPUSH
121508: PPUSH
121509: PPUSH
121510: PPUSH
121511: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
121512: LD_ADDR_VAR 0 12
121516: PUSH
121517: LD_EXP 78
121521: PUSH
121522: LD_VAR 0 1
121526: ARRAY
121527: PPUSH
121528: LD_INT 25
121530: PUSH
121531: LD_INT 3
121533: PUSH
121534: EMPTY
121535: LIST
121536: LIST
121537: PPUSH
121538: CALL_OW 72
121542: ST_TO_ADDR
// if mc_remote_driver [ base ] then
121543: LD_EXP 118
121547: PUSH
121548: LD_VAR 0 1
121552: ARRAY
121553: IFFALSE 121577
// mechs := mechs diff mc_remote_driver [ base ] ;
121555: LD_ADDR_VAR 0 12
121559: PUSH
121560: LD_VAR 0 12
121564: PUSH
121565: LD_EXP 118
121569: PUSH
121570: LD_VAR 0 1
121574: ARRAY
121575: DIFF
121576: ST_TO_ADDR
// for i in mechs do
121577: LD_ADDR_VAR 0 4
121581: PUSH
121582: LD_VAR 0 12
121586: PUSH
121587: FOR_IN
121588: IFFALSE 121623
// if GetTag ( i ) > 0 then
121590: LD_VAR 0 4
121594: PPUSH
121595: CALL_OW 110
121599: PUSH
121600: LD_INT 0
121602: GREATER
121603: IFFALSE 121621
// mechs := mechs diff i ;
121605: LD_ADDR_VAR 0 12
121609: PUSH
121610: LD_VAR 0 12
121614: PUSH
121615: LD_VAR 0 4
121619: DIFF
121620: ST_TO_ADDR
121621: GO 121587
121623: POP
121624: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
121625: LD_ADDR_VAR 0 8
121629: PUSH
121630: LD_EXP 78
121634: PUSH
121635: LD_VAR 0 1
121639: ARRAY
121640: PPUSH
121641: LD_INT 2
121643: PUSH
121644: LD_INT 25
121646: PUSH
121647: LD_INT 1
121649: PUSH
121650: EMPTY
121651: LIST
121652: LIST
121653: PUSH
121654: LD_INT 25
121656: PUSH
121657: LD_INT 5
121659: PUSH
121660: EMPTY
121661: LIST
121662: LIST
121663: PUSH
121664: LD_INT 25
121666: PUSH
121667: LD_INT 8
121669: PUSH
121670: EMPTY
121671: LIST
121672: LIST
121673: PUSH
121674: LD_INT 25
121676: PUSH
121677: LD_INT 9
121679: PUSH
121680: EMPTY
121681: LIST
121682: LIST
121683: PUSH
121684: EMPTY
121685: LIST
121686: LIST
121687: LIST
121688: LIST
121689: LIST
121690: PPUSH
121691: CALL_OW 72
121695: ST_TO_ADDR
// if not defenders and not solds then
121696: LD_VAR 0 2
121700: NOT
121701: PUSH
121702: LD_VAR 0 8
121706: NOT
121707: AND
121708: IFFALSE 121712
// exit ;
121710: GO 123482
// depot_under_attack := false ;
121712: LD_ADDR_VAR 0 16
121716: PUSH
121717: LD_INT 0
121719: ST_TO_ADDR
// sold_defenders := [ ] ;
121720: LD_ADDR_VAR 0 17
121724: PUSH
121725: EMPTY
121726: ST_TO_ADDR
// if mechs then
121727: LD_VAR 0 12
121731: IFFALSE 121884
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
121733: LD_ADDR_VAR 0 4
121737: PUSH
121738: LD_VAR 0 2
121742: PPUSH
121743: LD_INT 21
121745: PUSH
121746: LD_INT 2
121748: PUSH
121749: EMPTY
121750: LIST
121751: LIST
121752: PPUSH
121753: CALL_OW 72
121757: PUSH
121758: FOR_IN
121759: IFFALSE 121882
// begin if GetTag ( i ) <> 20 then
121761: LD_VAR 0 4
121765: PPUSH
121766: CALL_OW 110
121770: PUSH
121771: LD_INT 20
121773: NONEQUAL
121774: IFFALSE 121788
// SetTag ( i , 20 ) ;
121776: LD_VAR 0 4
121780: PPUSH
121781: LD_INT 20
121783: PPUSH
121784: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
121788: LD_VAR 0 4
121792: PPUSH
121793: CALL_OW 263
121797: PUSH
121798: LD_INT 1
121800: EQUAL
121801: PUSH
121802: LD_VAR 0 4
121806: PPUSH
121807: CALL_OW 311
121811: NOT
121812: AND
121813: IFFALSE 121880
// begin un := mechs [ 1 ] ;
121815: LD_ADDR_VAR 0 10
121819: PUSH
121820: LD_VAR 0 12
121824: PUSH
121825: LD_INT 1
121827: ARRAY
121828: ST_TO_ADDR
// ComExit ( un ) ;
121829: LD_VAR 0 10
121833: PPUSH
121834: CALL 91358 0 1
// AddComEnterUnit ( un , i ) ;
121838: LD_VAR 0 10
121842: PPUSH
121843: LD_VAR 0 4
121847: PPUSH
121848: CALL_OW 180
// SetTag ( un , 19 ) ;
121852: LD_VAR 0 10
121856: PPUSH
121857: LD_INT 19
121859: PPUSH
121860: CALL_OW 109
// mechs := mechs diff un ;
121864: LD_ADDR_VAR 0 12
121868: PUSH
121869: LD_VAR 0 12
121873: PUSH
121874: LD_VAR 0 10
121878: DIFF
121879: ST_TO_ADDR
// end ; end ;
121880: GO 121758
121882: POP
121883: POP
// if solds then
121884: LD_VAR 0 8
121888: IFFALSE 121947
// for i in solds do
121890: LD_ADDR_VAR 0 4
121894: PUSH
121895: LD_VAR 0 8
121899: PUSH
121900: FOR_IN
121901: IFFALSE 121945
// if not GetTag ( i ) then
121903: LD_VAR 0 4
121907: PPUSH
121908: CALL_OW 110
121912: NOT
121913: IFFALSE 121943
// begin defenders := defenders union i ;
121915: LD_ADDR_VAR 0 2
121919: PUSH
121920: LD_VAR 0 2
121924: PUSH
121925: LD_VAR 0 4
121929: UNION
121930: ST_TO_ADDR
// SetTag ( i , 18 ) ;
121931: LD_VAR 0 4
121935: PPUSH
121936: LD_INT 18
121938: PPUSH
121939: CALL_OW 109
// end ;
121943: GO 121900
121945: POP
121946: POP
// repeat wait ( 0 0$2 ) ;
121947: LD_INT 70
121949: PPUSH
121950: CALL_OW 67
// enemy := mc_scan [ base ] ;
121954: LD_ADDR_VAR 0 21
121958: PUSH
121959: LD_EXP 101
121963: PUSH
121964: LD_VAR 0 1
121968: ARRAY
121969: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121970: LD_EXP 78
121974: PUSH
121975: LD_VAR 0 1
121979: ARRAY
121980: NOT
121981: PUSH
121982: LD_EXP 78
121986: PUSH
121987: LD_VAR 0 1
121991: ARRAY
121992: PUSH
121993: EMPTY
121994: EQUAL
121995: OR
121996: IFFALSE 122033
// begin for i in defenders do
121998: LD_ADDR_VAR 0 4
122002: PUSH
122003: LD_VAR 0 2
122007: PUSH
122008: FOR_IN
122009: IFFALSE 122022
// ComStop ( i ) ;
122011: LD_VAR 0 4
122015: PPUSH
122016: CALL_OW 141
122020: GO 122008
122022: POP
122023: POP
// defenders := [ ] ;
122024: LD_ADDR_VAR 0 2
122028: PUSH
122029: EMPTY
122030: ST_TO_ADDR
// exit ;
122031: GO 123482
// end ; for i in defenders do
122033: LD_ADDR_VAR 0 4
122037: PUSH
122038: LD_VAR 0 2
122042: PUSH
122043: FOR_IN
122044: IFFALSE 122942
// begin e := NearestUnitToUnit ( enemy , i ) ;
122046: LD_ADDR_VAR 0 13
122050: PUSH
122051: LD_VAR 0 21
122055: PPUSH
122056: LD_VAR 0 4
122060: PPUSH
122061: CALL_OW 74
122065: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
122066: LD_ADDR_VAR 0 7
122070: PUSH
122071: LD_EXP 78
122075: PUSH
122076: LD_VAR 0 1
122080: ARRAY
122081: PPUSH
122082: LD_INT 2
122084: PUSH
122085: LD_INT 30
122087: PUSH
122088: LD_INT 0
122090: PUSH
122091: EMPTY
122092: LIST
122093: LIST
122094: PUSH
122095: LD_INT 30
122097: PUSH
122098: LD_INT 1
122100: PUSH
122101: EMPTY
122102: LIST
122103: LIST
122104: PUSH
122105: EMPTY
122106: LIST
122107: LIST
122108: LIST
122109: PPUSH
122110: CALL_OW 72
122114: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
122115: LD_ADDR_VAR 0 16
122119: PUSH
122120: LD_VAR 0 7
122124: NOT
122125: PUSH
122126: LD_VAR 0 7
122130: PPUSH
122131: LD_INT 3
122133: PUSH
122134: LD_INT 24
122136: PUSH
122137: LD_INT 600
122139: PUSH
122140: EMPTY
122141: LIST
122142: LIST
122143: PUSH
122144: EMPTY
122145: LIST
122146: LIST
122147: PPUSH
122148: CALL_OW 72
122152: OR
122153: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
122154: LD_VAR 0 4
122158: PPUSH
122159: CALL_OW 247
122163: PUSH
122164: LD_INT 2
122166: DOUBLE
122167: EQUAL
122168: IFTRUE 122172
122170: GO 122568
122172: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
122173: LD_VAR 0 4
122177: PPUSH
122178: CALL_OW 256
122182: PUSH
122183: LD_INT 1000
122185: EQUAL
122186: PUSH
122187: LD_VAR 0 4
122191: PPUSH
122192: LD_VAR 0 13
122196: PPUSH
122197: CALL_OW 296
122201: PUSH
122202: LD_INT 40
122204: LESS
122205: PUSH
122206: LD_VAR 0 13
122210: PPUSH
122211: LD_EXP 103
122215: PUSH
122216: LD_VAR 0 1
122220: ARRAY
122221: PPUSH
122222: CALL_OW 308
122226: OR
122227: AND
122228: IFFALSE 122350
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
122230: LD_VAR 0 4
122234: PPUSH
122235: CALL_OW 262
122239: PUSH
122240: LD_INT 1
122242: EQUAL
122243: PUSH
122244: LD_VAR 0 4
122248: PPUSH
122249: CALL_OW 261
122253: PUSH
122254: LD_INT 30
122256: LESS
122257: AND
122258: PUSH
122259: LD_VAR 0 7
122263: AND
122264: IFFALSE 122334
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
122266: LD_VAR 0 4
122270: PPUSH
122271: LD_VAR 0 7
122275: PPUSH
122276: LD_VAR 0 4
122280: PPUSH
122281: CALL_OW 74
122285: PPUSH
122286: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
122290: LD_VAR 0 4
122294: PPUSH
122295: LD_VAR 0 7
122299: PPUSH
122300: LD_VAR 0 4
122304: PPUSH
122305: CALL_OW 74
122309: PPUSH
122310: CALL_OW 296
122314: PUSH
122315: LD_INT 6
122317: LESS
122318: IFFALSE 122332
// SetFuel ( i , 100 ) ;
122320: LD_VAR 0 4
122324: PPUSH
122325: LD_INT 100
122327: PPUSH
122328: CALL_OW 240
// end else
122332: GO 122348
// ComAttackUnit ( i , e ) ;
122334: LD_VAR 0 4
122338: PPUSH
122339: LD_VAR 0 13
122343: PPUSH
122344: CALL_OW 115
// end else
122348: GO 122451
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
122350: LD_VAR 0 13
122354: PPUSH
122355: LD_EXP 103
122359: PUSH
122360: LD_VAR 0 1
122364: ARRAY
122365: PPUSH
122366: CALL_OW 308
122370: NOT
122371: PUSH
122372: LD_VAR 0 4
122376: PPUSH
122377: LD_VAR 0 13
122381: PPUSH
122382: CALL_OW 296
122386: PUSH
122387: LD_INT 40
122389: GREATEREQUAL
122390: AND
122391: PUSH
122392: LD_VAR 0 4
122396: PPUSH
122397: CALL_OW 256
122401: PUSH
122402: LD_INT 650
122404: LESSEQUAL
122405: OR
122406: PUSH
122407: LD_VAR 0 4
122411: PPUSH
122412: LD_EXP 102
122416: PUSH
122417: LD_VAR 0 1
122421: ARRAY
122422: PPUSH
122423: CALL_OW 308
122427: NOT
122428: AND
122429: IFFALSE 122451
// ComMoveToArea ( i , mc_parking [ base ] ) ;
122431: LD_VAR 0 4
122435: PPUSH
122436: LD_EXP 102
122440: PUSH
122441: LD_VAR 0 1
122445: ARRAY
122446: PPUSH
122447: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
122451: LD_VAR 0 4
122455: PPUSH
122456: CALL_OW 256
122460: PUSH
122461: LD_INT 1000
122463: LESS
122464: PUSH
122465: LD_VAR 0 4
122469: PPUSH
122470: CALL_OW 263
122474: PUSH
122475: LD_INT 1
122477: EQUAL
122478: AND
122479: PUSH
122480: LD_VAR 0 4
122484: PPUSH
122485: CALL_OW 311
122489: AND
122490: PUSH
122491: LD_VAR 0 4
122495: PPUSH
122496: LD_EXP 102
122500: PUSH
122501: LD_VAR 0 1
122505: ARRAY
122506: PPUSH
122507: CALL_OW 308
122511: AND
122512: IFFALSE 122566
// begin mech := IsDrivenBy ( i ) ;
122514: LD_ADDR_VAR 0 9
122518: PUSH
122519: LD_VAR 0 4
122523: PPUSH
122524: CALL_OW 311
122528: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
122529: LD_VAR 0 9
122533: PPUSH
122534: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
122538: LD_VAR 0 9
122542: PPUSH
122543: LD_VAR 0 4
122547: PPUSH
122548: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
122552: LD_VAR 0 9
122556: PPUSH
122557: LD_VAR 0 4
122561: PPUSH
122562: CALL_OW 180
// end ; end ; unit_human :
122566: GO 122913
122568: LD_INT 1
122570: DOUBLE
122571: EQUAL
122572: IFTRUE 122576
122574: GO 122912
122576: POP
// begin b := IsInUnit ( i ) ;
122577: LD_ADDR_VAR 0 18
122581: PUSH
122582: LD_VAR 0 4
122586: PPUSH
122587: CALL_OW 310
122591: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
122592: LD_ADDR_VAR 0 19
122596: PUSH
122597: LD_VAR 0 18
122601: NOT
122602: PUSH
122603: LD_VAR 0 18
122607: PPUSH
122608: CALL_OW 266
122612: PUSH
122613: LD_INT 32
122615: PUSH
122616: LD_INT 31
122618: PUSH
122619: EMPTY
122620: LIST
122621: LIST
122622: IN
122623: OR
122624: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
122625: LD_VAR 0 18
122629: PPUSH
122630: CALL_OW 266
122634: PUSH
122635: LD_INT 5
122637: EQUAL
122638: PUSH
122639: LD_VAR 0 4
122643: PPUSH
122644: CALL_OW 257
122648: PUSH
122649: LD_INT 1
122651: PUSH
122652: LD_INT 2
122654: PUSH
122655: LD_INT 3
122657: PUSH
122658: LD_INT 4
122660: PUSH
122661: EMPTY
122662: LIST
122663: LIST
122664: LIST
122665: LIST
122666: IN
122667: AND
122668: IFFALSE 122705
// begin class := AllowSpecClass ( i ) ;
122670: LD_ADDR_VAR 0 20
122674: PUSH
122675: LD_VAR 0 4
122679: PPUSH
122680: CALL 55044 0 1
122684: ST_TO_ADDR
// if class then
122685: LD_VAR 0 20
122689: IFFALSE 122705
// ComChangeProfession ( i , class ) ;
122691: LD_VAR 0 4
122695: PPUSH
122696: LD_VAR 0 20
122700: PPUSH
122701: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
122705: LD_VAR 0 16
122709: PUSH
122710: LD_VAR 0 2
122714: PPUSH
122715: LD_INT 21
122717: PUSH
122718: LD_INT 2
122720: PUSH
122721: EMPTY
122722: LIST
122723: LIST
122724: PPUSH
122725: CALL_OW 72
122729: PUSH
122730: LD_INT 1
122732: LESSEQUAL
122733: OR
122734: PUSH
122735: LD_VAR 0 19
122739: AND
122740: PUSH
122741: LD_VAR 0 4
122745: PUSH
122746: LD_VAR 0 17
122750: IN
122751: NOT
122752: AND
122753: IFFALSE 122846
// begin if b then
122755: LD_VAR 0 18
122759: IFFALSE 122808
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
122761: LD_VAR 0 18
122765: PPUSH
122766: LD_VAR 0 21
122770: PPUSH
122771: LD_VAR 0 18
122775: PPUSH
122776: CALL_OW 74
122780: PPUSH
122781: CALL_OW 296
122785: PUSH
122786: LD_INT 10
122788: LESS
122789: PUSH
122790: LD_VAR 0 18
122794: PPUSH
122795: CALL_OW 461
122799: PUSH
122800: LD_INT 7
122802: NONEQUAL
122803: AND
122804: IFFALSE 122808
// continue ;
122806: GO 122043
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
122808: LD_ADDR_VAR 0 17
122812: PUSH
122813: LD_VAR 0 17
122817: PPUSH
122818: LD_VAR 0 17
122822: PUSH
122823: LD_INT 1
122825: PLUS
122826: PPUSH
122827: LD_VAR 0 4
122831: PPUSH
122832: CALL_OW 1
122836: ST_TO_ADDR
// ComExitBuilding ( i ) ;
122837: LD_VAR 0 4
122841: PPUSH
122842: CALL_OW 122
// end ; if sold_defenders then
122846: LD_VAR 0 17
122850: IFFALSE 122910
// if i in sold_defenders then
122852: LD_VAR 0 4
122856: PUSH
122857: LD_VAR 0 17
122861: IN
122862: IFFALSE 122910
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
122864: LD_VAR 0 4
122868: PPUSH
122869: CALL_OW 314
122873: NOT
122874: PUSH
122875: LD_VAR 0 4
122879: PPUSH
122880: LD_VAR 0 13
122884: PPUSH
122885: CALL_OW 296
122889: PUSH
122890: LD_INT 30
122892: LESS
122893: AND
122894: IFFALSE 122910
// ComAttackUnit ( i , e ) ;
122896: LD_VAR 0 4
122900: PPUSH
122901: LD_VAR 0 13
122905: PPUSH
122906: CALL_OW 115
// end ; end ; end ;
122910: GO 122913
122912: POP
// if IsDead ( i ) then
122913: LD_VAR 0 4
122917: PPUSH
122918: CALL_OW 301
122922: IFFALSE 122940
// defenders := defenders diff i ;
122924: LD_ADDR_VAR 0 2
122928: PUSH
122929: LD_VAR 0 2
122933: PUSH
122934: LD_VAR 0 4
122938: DIFF
122939: ST_TO_ADDR
// end ;
122940: GO 122043
122942: POP
122943: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
122944: LD_VAR 0 21
122948: NOT
122949: PUSH
122950: LD_VAR 0 2
122954: NOT
122955: OR
122956: PUSH
122957: LD_EXP 78
122961: PUSH
122962: LD_VAR 0 1
122966: ARRAY
122967: NOT
122968: OR
122969: IFFALSE 121947
// MC_Reset ( base , 18 ) ;
122971: LD_VAR 0 1
122975: PPUSH
122976: LD_INT 18
122978: PPUSH
122979: CALL 26719 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
122983: LD_ADDR_VAR 0 2
122987: PUSH
122988: LD_VAR 0 2
122992: PUSH
122993: LD_VAR 0 2
122997: PPUSH
122998: LD_INT 2
123000: PUSH
123001: LD_INT 25
123003: PUSH
123004: LD_INT 1
123006: PUSH
123007: EMPTY
123008: LIST
123009: LIST
123010: PUSH
123011: LD_INT 25
123013: PUSH
123014: LD_INT 5
123016: PUSH
123017: EMPTY
123018: LIST
123019: LIST
123020: PUSH
123021: LD_INT 25
123023: PUSH
123024: LD_INT 8
123026: PUSH
123027: EMPTY
123028: LIST
123029: LIST
123030: PUSH
123031: LD_INT 25
123033: PUSH
123034: LD_INT 9
123036: PUSH
123037: EMPTY
123038: LIST
123039: LIST
123040: PUSH
123041: EMPTY
123042: LIST
123043: LIST
123044: LIST
123045: LIST
123046: LIST
123047: PPUSH
123048: CALL_OW 72
123052: DIFF
123053: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
123054: LD_VAR 0 21
123058: NOT
123059: PUSH
123060: LD_VAR 0 2
123064: PPUSH
123065: LD_INT 21
123067: PUSH
123068: LD_INT 2
123070: PUSH
123071: EMPTY
123072: LIST
123073: LIST
123074: PPUSH
123075: CALL_OW 72
123079: AND
123080: IFFALSE 123418
// begin tmp := FilterByTag ( defenders , 19 ) ;
123082: LD_ADDR_VAR 0 11
123086: PUSH
123087: LD_VAR 0 2
123091: PPUSH
123092: LD_INT 19
123094: PPUSH
123095: CALL 88529 0 2
123099: ST_TO_ADDR
// if tmp then
123100: LD_VAR 0 11
123104: IFFALSE 123174
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
123106: LD_ADDR_VAR 0 11
123110: PUSH
123111: LD_VAR 0 11
123115: PPUSH
123116: LD_INT 25
123118: PUSH
123119: LD_INT 3
123121: PUSH
123122: EMPTY
123123: LIST
123124: LIST
123125: PPUSH
123126: CALL_OW 72
123130: ST_TO_ADDR
// if tmp then
123131: LD_VAR 0 11
123135: IFFALSE 123174
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
123137: LD_ADDR_EXP 90
123141: PUSH
123142: LD_EXP 90
123146: PPUSH
123147: LD_VAR 0 1
123151: PPUSH
123152: LD_EXP 90
123156: PUSH
123157: LD_VAR 0 1
123161: ARRAY
123162: PUSH
123163: LD_VAR 0 11
123167: UNION
123168: PPUSH
123169: CALL_OW 1
123173: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
123174: LD_VAR 0 1
123178: PPUSH
123179: LD_INT 19
123181: PPUSH
123182: CALL 26719 0 2
// repeat wait ( 0 0$1 ) ;
123186: LD_INT 35
123188: PPUSH
123189: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
123193: LD_EXP 78
123197: PUSH
123198: LD_VAR 0 1
123202: ARRAY
123203: NOT
123204: PUSH
123205: LD_EXP 78
123209: PUSH
123210: LD_VAR 0 1
123214: ARRAY
123215: PUSH
123216: EMPTY
123217: EQUAL
123218: OR
123219: IFFALSE 123256
// begin for i in defenders do
123221: LD_ADDR_VAR 0 4
123225: PUSH
123226: LD_VAR 0 2
123230: PUSH
123231: FOR_IN
123232: IFFALSE 123245
// ComStop ( i ) ;
123234: LD_VAR 0 4
123238: PPUSH
123239: CALL_OW 141
123243: GO 123231
123245: POP
123246: POP
// defenders := [ ] ;
123247: LD_ADDR_VAR 0 2
123251: PUSH
123252: EMPTY
123253: ST_TO_ADDR
// exit ;
123254: GO 123482
// end ; for i in defenders do
123256: LD_ADDR_VAR 0 4
123260: PUSH
123261: LD_VAR 0 2
123265: PUSH
123266: FOR_IN
123267: IFFALSE 123356
// begin if not IsInArea ( i , mc_parking [ base ] ) then
123269: LD_VAR 0 4
123273: PPUSH
123274: LD_EXP 102
123278: PUSH
123279: LD_VAR 0 1
123283: ARRAY
123284: PPUSH
123285: CALL_OW 308
123289: NOT
123290: IFFALSE 123314
// ComMoveToArea ( i , mc_parking [ base ] ) else
123292: LD_VAR 0 4
123296: PPUSH
123297: LD_EXP 102
123301: PUSH
123302: LD_VAR 0 1
123306: ARRAY
123307: PPUSH
123308: CALL_OW 113
123312: GO 123354
// if GetControl ( i ) = control_manual then
123314: LD_VAR 0 4
123318: PPUSH
123319: CALL_OW 263
123323: PUSH
123324: LD_INT 1
123326: EQUAL
123327: IFFALSE 123354
// if IsDrivenBy ( i ) then
123329: LD_VAR 0 4
123333: PPUSH
123334: CALL_OW 311
123338: IFFALSE 123354
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
123340: LD_VAR 0 4
123344: PPUSH
123345: CALL_OW 311
123349: PPUSH
123350: CALL_OW 121
// end ;
123354: GO 123266
123356: POP
123357: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
123358: LD_VAR 0 2
123362: PPUSH
123363: LD_INT 95
123365: PUSH
123366: LD_EXP 102
123370: PUSH
123371: LD_VAR 0 1
123375: ARRAY
123376: PUSH
123377: EMPTY
123378: LIST
123379: LIST
123380: PPUSH
123381: CALL_OW 72
123385: PUSH
123386: LD_VAR 0 2
123390: EQUAL
123391: PUSH
123392: LD_EXP 101
123396: PUSH
123397: LD_VAR 0 1
123401: ARRAY
123402: OR
123403: PUSH
123404: LD_EXP 78
123408: PUSH
123409: LD_VAR 0 1
123413: ARRAY
123414: NOT
123415: OR
123416: IFFALSE 123186
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
123418: LD_ADDR_EXP 100
123422: PUSH
123423: LD_EXP 100
123427: PPUSH
123428: LD_VAR 0 1
123432: PPUSH
123433: LD_VAR 0 2
123437: PPUSH
123438: LD_INT 21
123440: PUSH
123441: LD_INT 2
123443: PUSH
123444: EMPTY
123445: LIST
123446: LIST
123447: PPUSH
123448: CALL_OW 72
123452: PPUSH
123453: CALL_OW 1
123457: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
123458: LD_VAR 0 1
123462: PPUSH
123463: LD_INT 19
123465: PPUSH
123466: CALL 26719 0 2
// MC_Reset ( base , 20 ) ;
123470: LD_VAR 0 1
123474: PPUSH
123475: LD_INT 20
123477: PPUSH
123478: CALL 26719 0 2
// end ; end_of_file
123482: LD_VAR 0 3
123486: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
123487: LD_VAR 0 1
123491: PUSH
123492: LD_INT 200
123494: DOUBLE
123495: GREATEREQUAL
123496: IFFALSE 123504
123498: LD_INT 299
123500: DOUBLE
123501: LESSEQUAL
123502: IFTRUE 123506
123504: GO 123538
123506: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
123507: LD_VAR 0 1
123511: PPUSH
123512: LD_VAR 0 2
123516: PPUSH
123517: LD_VAR 0 3
123521: PPUSH
123522: LD_VAR 0 4
123526: PPUSH
123527: LD_VAR 0 5
123531: PPUSH
123532: CALL 111668 0 5
123536: GO 123615
123538: LD_INT 300
123540: DOUBLE
123541: GREATEREQUAL
123542: IFFALSE 123550
123544: LD_INT 399
123546: DOUBLE
123547: LESSEQUAL
123548: IFTRUE 123552
123550: GO 123614
123552: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
123553: LD_VAR 0 1
123557: PPUSH
123558: LD_VAR 0 2
123562: PPUSH
123563: LD_VAR 0 3
123567: PPUSH
123568: LD_VAR 0 4
123572: PPUSH
123573: LD_VAR 0 5
123577: PPUSH
123578: LD_VAR 0 6
123582: PPUSH
123583: LD_VAR 0 7
123587: PPUSH
123588: LD_VAR 0 8
123592: PPUSH
123593: LD_VAR 0 9
123597: PPUSH
123598: LD_VAR 0 10
123602: PPUSH
123603: LD_VAR 0 11
123607: PPUSH
123608: CALL 107993 0 11
123612: GO 123615
123614: POP
// end ;
123615: PPOPN 11
123617: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
123618: LD_VAR 0 1
123622: PPUSH
123623: LD_VAR 0 2
123627: PPUSH
123628: LD_VAR 0 3
123632: PPUSH
123633: LD_VAR 0 4
123637: PPUSH
123638: LD_VAR 0 5
123642: PPUSH
123643: CALL 111404 0 5
// end ; end_of_file
123647: PPOPN 5
123649: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
123650: LD_VAR 0 1
123654: PPUSH
123655: LD_VAR 0 2
123659: PPUSH
123660: LD_VAR 0 3
123664: PPUSH
123665: LD_VAR 0 4
123669: PPUSH
123670: LD_VAR 0 5
123674: PPUSH
123675: LD_VAR 0 6
123679: PPUSH
123680: CALL 95645 0 6
// end ;
123684: PPOPN 6
123686: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
123687: LD_INT 0
123689: PPUSH
// begin if not units then
123690: LD_VAR 0 1
123694: NOT
123695: IFFALSE 123699
// exit ;
123697: GO 123699
// end ;
123699: PPOPN 7
123701: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
123702: CALL 95549 0 0
// end ;
123706: PPOPN 1
123708: END
