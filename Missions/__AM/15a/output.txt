// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 20694 0 0
// InitMacro ;
  19: CALL 20862 0 0
// InitNature ;
  23: CALL 17360 0 0
// InitArtifact ;
  27: CALL 17977 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 4641 0 0
// PrepareAlliance ;
  48: CALL 1429 0 0
// PrepareArabian ;
  52: CALL 6413 0 0
// PrepareRussian ;
  56: CALL 8422 0 0
// PrepareLegion ;
  60: CALL 6845 0 0
// Action ;
  64: CALL 10987 0 0
// MC_Start ( ) ;
  68: CALL 23027 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// export function CustomInitMacro ( ) ; begin
 217: LD_INT 0
 219: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 220: LD_ADDR_EXP 117
 224: PUSH
 225: LD_INT 26
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 4
 233: PUSH
 234: LD_INT 8
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: LIST
 242: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 243: LD_ADDR_EXP 118
 247: PUSH
 248: LD_INT 27
 250: PUSH
 251: LD_INT 2
 253: PUSH
 254: LD_INT 3
 256: PUSH
 257: LD_INT 7
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_INT 6
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: LD_INT 9
 277: PUSH
 278: LD_INT 10
 280: PUSH
 281: EMPTY
 282: LIST
 283: LIST
 284: LIST
 285: LIST
 286: PUSH
 287: LD_OWVAR 67
 291: ARRAY
 292: PPUSH
 293: LD_INT 28
 295: PPUSH
 296: CALL 44716 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 10
 305: PUSH
 306: LD_INT 11
 308: PUSH
 309: LD_INT 13
 311: PUSH
 312: LD_INT 15
 314: PUSH
 315: EMPTY
 316: LIST
 317: LIST
 318: LIST
 319: LIST
 320: PPUSH
 321: CALL 45776 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 325: LD_INT 1
 327: PPUSH
 328: LD_INT 29
 330: PUSH
 331: EMPTY
 332: LIST
 333: PPUSH
 334: CALL 45869 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 338: LD_ADDR_EXP 122
 342: PUSH
 343: LD_EXP 122
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 22
 353: PUSH
 354: LD_INT 2
 356: PUSH
 357: EMPTY
 358: LIST
 359: LIST
 360: PUSH
 361: LD_INT 25
 363: PUSH
 364: LD_INT 15
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PUSH
 371: EMPTY
 372: LIST
 373: LIST
 374: PPUSH
 375: CALL_OW 69
 379: PPUSH
 380: CALL_OW 1
 384: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 385: LD_INT 1
 387: PPUSH
 388: LD_INT 13
 390: PUSH
 391: LD_INT 2
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: LD_INT 31
 399: PUSH
 400: EMPTY
 401: LIST
 402: LIST
 403: LIST
 404: LIST
 405: PUSH
 406: LD_INT 13
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 1
 414: PUSH
 415: LD_INT 31
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: LIST
 423: PUSH
 424: LD_INT 13
 426: PUSH
 427: LD_INT 1
 429: PUSH
 430: LD_INT 1
 432: PUSH
 433: LD_INT 28
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: PUSH
 442: LD_INT 13
 444: PUSH
 445: LD_INT 1
 447: PUSH
 448: LD_INT 1
 450: PUSH
 451: LD_INT 28
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: PUSH
 460: LD_INT 13
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: LD_INT 28
 471: PUSH
 472: EMPTY
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: PUSH
 478: LD_INT 13
 480: PUSH
 481: LD_INT 1
 483: PUSH
 484: LD_INT 1
 486: PUSH
 487: LD_INT 28
 489: PUSH
 490: EMPTY
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PUSH
 496: LD_INT 13
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: LD_INT 2
 504: PUSH
 505: LD_EXP 78
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PPUSH
 525: CALL 45034 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 529: LD_INT 1
 531: PPUSH
 532: LD_INT 4
 534: PPUSH
 535: CALL 45219 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 539: LD_INT 2
 541: PPUSH
 542: LD_INT 10
 544: PUSH
 545: LD_INT 11
 547: PUSH
 548: LD_INT 12
 550: PUSH
 551: LD_INT 14
 553: PUSH
 554: EMPTY
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 45776 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 564: LD_INT 2
 566: PPUSH
 567: LD_INT 14
 569: PUSH
 570: EMPTY
 571: LIST
 572: PPUSH
 573: CALL 45869 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 577: LD_INT 2
 579: PPUSH
 580: LD_INT 21
 582: PUSH
 583: LD_INT 3
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 51
 591: PUSH
 592: EMPTY
 593: LIST
 594: LIST
 595: LIST
 596: LIST
 597: PUSH
 598: LD_INT 22
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 52
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: LIST
 615: PUSH
 616: LD_INT 22
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 52
 627: PUSH
 628: EMPTY
 629: LIST
 630: LIST
 631: LIST
 632: LIST
 633: PUSH
 634: LD_INT 24
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 47
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: LIST
 650: LIST
 651: PUSH
 652: LD_INT 24
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 47
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 24
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 47
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: LD_INT 24
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 3
 696: PUSH
 697: LD_INT 47
 699: PUSH
 700: EMPTY
 701: LIST
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_INT 24
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 47
 717: PUSH
 718: EMPTY
 719: LIST
 720: LIST
 721: LIST
 722: LIST
 723: PUSH
 724: EMPTY
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PPUSH
 734: CALL 45034 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 738: LD_INT 2
 740: PPUSH
 741: LD_INT 5
 743: PPUSH
 744: CALL 45219 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 748: LD_INT 2
 750: PPUSH
 751: LD_INT 0
 753: PPUSH
 754: CALL 45649 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 758: LD_INT 3
 760: PPUSH
 761: LD_INT 10
 763: PUSH
 764: LD_INT 12
 766: PUSH
 767: LD_INT 14
 769: PUSH
 770: LD_INT 15
 772: PUSH
 773: EMPTY
 774: LIST
 775: LIST
 776: LIST
 777: LIST
 778: PUSH
 779: LD_OWVAR 67
 783: ARRAY
 784: PPUSH
 785: LD_INT 24
 787: PPUSH
 788: CALL 44716 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 792: LD_INT 3
 794: PPUSH
 795: LD_INT 10
 797: PUSH
 798: LD_INT 11
 800: PUSH
 801: LD_INT 13
 803: PUSH
 804: LD_INT 15
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PPUSH
 813: CALL 45776 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 817: LD_INT 3
 819: PPUSH
 820: LD_INT 13
 822: PUSH
 823: EMPTY
 824: LIST
 825: PPUSH
 826: CALL 45869 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 830: LD_ADDR_EXP 122
 834: PUSH
 835: LD_EXP 122
 839: PPUSH
 840: LD_INT 3
 842: PPUSH
 843: LD_INT 22
 845: PUSH
 846: LD_INT 8
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 25
 855: PUSH
 856: LD_INT 15
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: EMPTY
 864: LIST
 865: LIST
 866: PPUSH
 867: CALL_OW 69
 871: PPUSH
 872: CALL_OW 1
 876: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 877: LD_INT 3
 879: PPUSH
 880: LD_INT 13
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 1
 888: PUSH
 889: LD_INT 31
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_INT 13
 900: PUSH
 901: LD_INT 2
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 31
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 13
 918: PUSH
 919: LD_INT 3
 921: PUSH
 922: LD_INT 2
 924: PUSH
 925: LD_INT 32
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 14
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 28
 945: PUSH
 946: EMPTY
 947: LIST
 948: LIST
 949: LIST
 950: LIST
 951: PUSH
 952: LD_INT 14
 954: PUSH
 955: LD_INT 1
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 28
 963: PUSH
 964: EMPTY
 965: LIST
 966: LIST
 967: LIST
 968: LIST
 969: PUSH
 970: LD_INT 14
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 1
 978: PUSH
 979: LD_INT 28
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_INT 14
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 1
 996: PUSH
 997: LD_INT 28
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: LIST
1004: LIST
1005: PUSH
1006: LD_INT 14
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 2
1014: PUSH
1015: LD_EXP 78
1019: PUSH
1020: EMPTY
1021: LIST
1022: LIST
1023: LIST
1024: LIST
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL 45034 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1040: LD_INT 3
1042: PPUSH
1043: LD_INT 4
1045: PPUSH
1046: CALL 45219 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1050: LD_INT 4
1052: PPUSH
1053: LD_INT 10
1055: PUSH
1056: LD_INT 12
1058: PUSH
1059: LD_INT 11
1061: PUSH
1062: LD_INT 15
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PPUSH
1071: CALL 45776 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1075: LD_INT 4
1077: PPUSH
1078: LD_INT 33
1080: PUSH
1081: EMPTY
1082: LIST
1083: PPUSH
1084: CALL 45869 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1088: LD_INT 4
1090: PPUSH
1091: LD_INT 5
1093: PUSH
1094: LD_INT 6
1096: PUSH
1097: LD_INT 7
1099: PUSH
1100: LD_INT 9
1102: PUSH
1103: LD_INT 10
1105: PUSH
1106: EMPTY
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: PPUSH
1113: CALL 46187 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1117: LD_INT 4
1119: PPUSH
1120: LD_INT 54
1122: PPUSH
1123: LD_INT 85
1125: PPUSH
1126: LD_INT 2
1128: PPUSH
1129: LD_INT 25
1131: PUSH
1132: LD_INT 16
1134: PUSH
1135: LD_INT 17
1137: PUSH
1138: LD_INT 18
1140: PUSH
1141: LD_INT 22
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PPUSH
1151: CALL 45981 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 7
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 1
1184: PUSH
1185: LD_INT 6
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 5
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 1
1202: PUSH
1203: LD_INT 7
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 5
1214: PUSH
1215: LD_INT 1
1217: PUSH
1218: LD_INT 1
1220: PUSH
1221: LD_INT 6
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 5
1232: PUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 3
1238: PUSH
1239: LD_INT 12
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 3
1250: PUSH
1251: LD_INT 1
1253: PUSH
1254: LD_INT 3
1256: PUSH
1257: LD_INT 13
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: PPUSH
1274: CALL 45034 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1278: LD_INT 4
1280: PPUSH
1281: LD_INT 4
1283: PPUSH
1284: CALL 45219 0 2
// MC_SetTame ( 4 , powellApe ) ;
1288: LD_INT 4
1290: PPUSH
1291: LD_INT 11
1293: PPUSH
1294: CALL 45600 0 2
// end ;
1298: LD_VAR 0 1
1302: RET
// every 0 0$1 trigger debug do var i ;
1303: LD_EXP 1
1307: IFFALSE 1405
1309: GO 1311
1311: DISABLE
1312: LD_INT 0
1314: PPUSH
// begin enable ;
1315: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1316: LD_ADDR_VAR 0 1
1320: PUSH
1321: LD_INT 22
1323: PUSH
1324: LD_INT 7
1326: PUSH
1327: EMPTY
1328: LIST
1329: LIST
1330: PUSH
1331: LD_INT 2
1333: PUSH
1334: LD_INT 21
1336: PUSH
1337: LD_INT 1
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: PUSH
1344: LD_INT 21
1346: PUSH
1347: LD_INT 2
1349: PUSH
1350: EMPTY
1351: LIST
1352: LIST
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 3
1361: PUSH
1362: LD_INT 24
1364: PUSH
1365: LD_INT 1000
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: PUSH
1372: EMPTY
1373: LIST
1374: LIST
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: LIST
1380: PPUSH
1381: CALL_OW 69
1385: PUSH
1386: FOR_IN
1387: IFFALSE 1403
// SetLives ( i , 1000 ) ;
1389: LD_VAR 0 1
1393: PPUSH
1394: LD_INT 1000
1396: PPUSH
1397: CALL_OW 234
1401: GO 1386
1403: POP
1404: POP
// end ;
1405: PPOPN 1
1407: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1408: LD_EXP 16
1412: PUSH
1413: LD_INT 5
1415: GREATEREQUAL
1416: IFFALSE 1428
1418: GO 1420
1420: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1421: LD_STRING ACH_ARTIFACT
1423: PPUSH
1424: CALL_OW 543
1428: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1429: LD_INT 0
1431: PPUSH
1432: PPUSH
1433: PPUSH
1434: PPUSH
1435: PPUSH
// uc_side := 7 ;
1436: LD_ADDR_OWVAR 20
1440: PUSH
1441: LD_INT 7
1443: ST_TO_ADDR
// tmp := [ ] ;
1444: LD_ADDR_VAR 0 5
1448: PUSH
1449: EMPTY
1450: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1451: LD_ADDR_EXP 17
1455: PUSH
1456: LD_STRING JMM
1458: PPUSH
1459: LD_EXP 1
1463: NOT
1464: PPUSH
1465: LD_STRING 14a_
1467: PPUSH
1468: CALL 51488 0 3
1472: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1473: LD_ADDR_EXP 49
1477: PUSH
1478: LD_STRING Burlak
1480: PPUSH
1481: LD_EXP 1
1485: NOT
1486: PPUSH
1487: LD_STRING 14a_
1489: PPUSH
1490: CALL 51488 0 3
1494: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1495: LD_ADDR_EXP 32
1499: PUSH
1500: LD_STRING Joan
1502: PPUSH
1503: LD_EXP 1
1507: NOT
1508: PPUSH
1509: LD_STRING 13a_
1511: PPUSH
1512: CALL 51488 0 3
1516: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1517: LD_ADDR_EXP 18
1521: PUSH
1522: LD_STRING Roth
1524: PPUSH
1525: LD_EXP 1
1529: NOT
1530: PPUSH
1531: LD_STRING 13a_
1533: PPUSH
1534: CALL 51488 0 3
1538: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1539: LD_ADDR_EXP 35
1543: PUSH
1544: LD_STRING Gossudarov
1546: PPUSH
1547: LD_EXP 1
1551: NOT
1552: PPUSH
1553: LD_STRING 13a_
1555: PPUSH
1556: CALL 51488 0 3
1560: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1561: LD_ADDR_EXP 23
1565: PUSH
1566: LD_STRING Denis
1568: PPUSH
1569: LD_EXP 1
1573: NOT
1574: PPUSH
1575: LD_STRING 13a_
1577: PPUSH
1578: CALL 51488 0 3
1582: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1583: LD_ADDR_EXP 33
1587: PUSH
1588: LD_STRING DeltaDoctor
1590: PPUSH
1591: LD_EXP 1
1595: NOT
1596: PPUSH
1597: LD_STRING 13a_
1599: PPUSH
1600: CALL 51488 0 3
1604: ST_TO_ADDR
// if DeltaDoctor then
1605: LD_EXP 33
1609: IFFALSE 1627
// tmp := tmp ^ DeltaDoctor ;
1611: LD_ADDR_VAR 0 5
1615: PUSH
1616: LD_VAR 0 5
1620: PUSH
1621: LD_EXP 33
1625: ADD
1626: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1627: LD_ADDR_EXP 31
1631: PUSH
1632: LD_STRING Simms
1634: PPUSH
1635: LD_EXP 1
1639: NOT
1640: PPUSH
1641: LD_STRING 13a_
1643: PPUSH
1644: CALL 51488 0 3
1648: ST_TO_ADDR
// if Simms then
1649: LD_EXP 31
1653: IFFALSE 1671
// tmp := tmp ^ Simms ;
1655: LD_ADDR_VAR 0 5
1659: PUSH
1660: LD_VAR 0 5
1664: PUSH
1665: LD_EXP 31
1669: ADD
1670: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1671: LD_ADDR_EXP 29
1675: PUSH
1676: LD_STRING Frank
1678: PPUSH
1679: LD_EXP 1
1683: NOT
1684: PPUSH
1685: LD_STRING 13a_
1687: PPUSH
1688: CALL 51488 0 3
1692: ST_TO_ADDR
// if Frank then
1693: LD_EXP 29
1697: IFFALSE 1715
// tmp := tmp ^ Frank ;
1699: LD_ADDR_VAR 0 5
1703: PUSH
1704: LD_VAR 0 5
1708: PUSH
1709: LD_EXP 29
1713: ADD
1714: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1715: LD_ADDR_EXP 36
1719: PUSH
1720: LD_STRING Kirilenkova
1722: PPUSH
1723: LD_EXP 1
1727: NOT
1728: PPUSH
1729: LD_STRING 13a_
1731: PPUSH
1732: CALL 51488 0 3
1736: ST_TO_ADDR
// if Kirilenkova then
1737: LD_EXP 36
1741: IFFALSE 1759
// tmp := tmp ^ Kirilenkova ;
1743: LD_ADDR_VAR 0 5
1747: PUSH
1748: LD_VAR 0 5
1752: PUSH
1753: LD_EXP 36
1757: ADD
1758: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1759: LD_ADDR_EXP 37
1763: PUSH
1764: LD_STRING Titov
1766: PPUSH
1767: LD_EXP 1
1771: NOT
1772: PPUSH
1773: LD_STRING 13a_
1775: PPUSH
1776: CALL 51488 0 3
1780: ST_TO_ADDR
// if Titov then
1781: LD_EXP 37
1785: IFFALSE 1803
// tmp := tmp ^ Titov ;
1787: LD_ADDR_VAR 0 5
1791: PUSH
1792: LD_VAR 0 5
1796: PUSH
1797: LD_EXP 37
1801: ADD
1802: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1803: LD_ADDR_EXP 38
1807: PUSH
1808: LD_STRING Fadeev
1810: PPUSH
1811: LD_EXP 1
1815: NOT
1816: PPUSH
1817: LD_STRING 13a_
1819: PPUSH
1820: CALL 51488 0 3
1824: ST_TO_ADDR
// if Fadeev then
1825: LD_EXP 38
1829: IFFALSE 1847
// tmp := tmp ^ Fadeev ;
1831: LD_ADDR_VAR 0 5
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 38
1845: ADD
1846: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1847: LD_ADDR_EXP 39
1851: PUSH
1852: LD_STRING Dolgov
1854: PPUSH
1855: LD_EXP 1
1859: NOT
1860: PPUSH
1861: LD_STRING 13a_
1863: PPUSH
1864: CALL 51488 0 3
1868: ST_TO_ADDR
// if Dolgov then
1869: LD_EXP 39
1873: IFFALSE 1891
// tmp := tmp ^ Dolgov ;
1875: LD_ADDR_VAR 0 5
1879: PUSH
1880: LD_VAR 0 5
1884: PUSH
1885: LD_EXP 39
1889: ADD
1890: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1891: LD_ADDR_EXP 40
1895: PUSH
1896: LD_STRING Petrosyan
1898: PPUSH
1899: LD_EXP 1
1903: NOT
1904: PPUSH
1905: LD_STRING 13a_
1907: PPUSH
1908: CALL 51488 0 3
1912: ST_TO_ADDR
// if Petrosyan then
1913: LD_EXP 40
1917: IFFALSE 1935
// tmp := tmp ^ Petrosyan ;
1919: LD_ADDR_VAR 0 5
1923: PUSH
1924: LD_VAR 0 5
1928: PUSH
1929: LD_EXP 40
1933: ADD
1934: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1935: LD_ADDR_EXP 41
1939: PUSH
1940: LD_STRING Scholtze
1942: PPUSH
1943: LD_EXP 1
1947: NOT
1948: PPUSH
1949: LD_STRING 13a_
1951: PPUSH
1952: CALL 51488 0 3
1956: ST_TO_ADDR
// if Scholtze then
1957: LD_EXP 41
1961: IFFALSE 1979
// tmp := tmp ^ Scholtze ;
1963: LD_ADDR_VAR 0 5
1967: PUSH
1968: LD_VAR 0 5
1972: PUSH
1973: LD_EXP 41
1977: ADD
1978: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1979: LD_ADDR_EXP 42
1983: PUSH
1984: LD_STRING Oblukov
1986: PPUSH
1987: LD_EXP 1
1991: NOT
1992: PPUSH
1993: LD_STRING 13a_
1995: PPUSH
1996: CALL 51488 0 3
2000: ST_TO_ADDR
// if Oblukov then
2001: LD_EXP 42
2005: IFFALSE 2023
// tmp := tmp ^ Oblukov ;
2007: LD_ADDR_VAR 0 5
2011: PUSH
2012: LD_VAR 0 5
2016: PUSH
2017: LD_EXP 42
2021: ADD
2022: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2023: LD_ADDR_EXP 43
2027: PUSH
2028: LD_STRING Kapitsova
2030: PPUSH
2031: LD_EXP 1
2035: NOT
2036: PPUSH
2037: LD_STRING 13a_
2039: PPUSH
2040: CALL 51488 0 3
2044: ST_TO_ADDR
// if Kapitsova then
2045: LD_EXP 43
2049: IFFALSE 2067
// tmp := tmp ^ Kapitsova ;
2051: LD_ADDR_VAR 0 5
2055: PUSH
2056: LD_VAR 0 5
2060: PUSH
2061: LD_EXP 43
2065: ADD
2066: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2067: LD_ADDR_EXP 44
2071: PUSH
2072: LD_STRING Lipshchin
2074: PPUSH
2075: LD_EXP 1
2079: NOT
2080: PPUSH
2081: LD_STRING 13a_
2083: PPUSH
2084: CALL 51488 0 3
2088: ST_TO_ADDR
// if Lipshchin then
2089: LD_EXP 44
2093: IFFALSE 2111
// tmp := tmp ^ Lipshchin ;
2095: LD_ADDR_VAR 0 5
2099: PUSH
2100: LD_VAR 0 5
2104: PUSH
2105: LD_EXP 44
2109: ADD
2110: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2111: LD_ADDR_EXP 45
2115: PUSH
2116: LD_STRING Petrovova
2118: PPUSH
2119: LD_EXP 1
2123: NOT
2124: PPUSH
2125: LD_STRING 13a_
2127: PPUSH
2128: CALL 51488 0 3
2132: ST_TO_ADDR
// if Petrovova then
2133: LD_EXP 45
2137: IFFALSE 2155
// tmp := tmp ^ Petrovova ;
2139: LD_ADDR_VAR 0 5
2143: PUSH
2144: LD_VAR 0 5
2148: PUSH
2149: LD_EXP 45
2153: ADD
2154: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2155: LD_ADDR_EXP 46
2159: PUSH
2160: LD_STRING Kovalyuk
2162: PPUSH
2163: LD_EXP 1
2167: NOT
2168: PPUSH
2169: LD_STRING 13a_
2171: PPUSH
2172: CALL 51488 0 3
2176: ST_TO_ADDR
// if Kovalyuk then
2177: LD_EXP 46
2181: IFFALSE 2199
// tmp := tmp ^ Kovalyuk ;
2183: LD_ADDR_VAR 0 5
2187: PUSH
2188: LD_VAR 0 5
2192: PUSH
2193: LD_EXP 46
2197: ADD
2198: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2199: LD_ADDR_EXP 47
2203: PUSH
2204: LD_STRING Kuzmov
2206: PPUSH
2207: LD_EXP 1
2211: NOT
2212: PPUSH
2213: LD_STRING 13a_
2215: PPUSH
2216: CALL 51488 0 3
2220: ST_TO_ADDR
// if Kuzmov then
2221: LD_EXP 47
2225: IFFALSE 2243
// tmp := tmp ^ Kuzmov ;
2227: LD_ADDR_VAR 0 5
2231: PUSH
2232: LD_VAR 0 5
2236: PUSH
2237: LD_EXP 47
2241: ADD
2242: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2243: LD_ADDR_EXP 48
2247: PUSH
2248: LD_STRING Karamazov
2250: PPUSH
2251: LD_EXP 1
2255: NOT
2256: PPUSH
2257: LD_STRING 13a_
2259: PPUSH
2260: CALL 51488 0 3
2264: ST_TO_ADDR
// if Karamazov then
2265: LD_EXP 48
2269: IFFALSE 2287
// tmp := tmp ^ Karamazov ;
2271: LD_ADDR_VAR 0 5
2275: PUSH
2276: LD_VAR 0 5
2280: PUSH
2281: LD_EXP 48
2285: ADD
2286: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2287: LD_ADDR_EXP 50
2291: PUSH
2292: LD_STRING Belkov
2294: PPUSH
2295: LD_EXP 1
2299: NOT
2300: PPUSH
2301: LD_STRING 13a_
2303: PPUSH
2304: CALL 51488 0 3
2308: ST_TO_ADDR
// if Belkov then
2309: LD_EXP 50
2313: IFFALSE 2331
// tmp := tmp ^ Belkov ;
2315: LD_ADDR_VAR 0 5
2319: PUSH
2320: LD_VAR 0 5
2324: PUSH
2325: LD_EXP 50
2329: ADD
2330: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2331: LD_ADDR_EXP 51
2335: PUSH
2336: LD_STRING Gnyevko
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_STRING 13a_
2347: PPUSH
2348: CALL 51488 0 3
2352: ST_TO_ADDR
// if Gnyevko then
2353: LD_EXP 51
2357: IFFALSE 2375
// tmp := tmp ^ Gnyevko ;
2359: LD_ADDR_VAR 0 5
2363: PUSH
2364: LD_VAR 0 5
2368: PUSH
2369: LD_EXP 51
2373: ADD
2374: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2375: LD_ADDR_EXP 34
2379: PUSH
2380: LD_STRING Coonie
2382: PPUSH
2383: CALL_OW 25
2387: ST_TO_ADDR
// if not Lisa then
2388: LD_EXP 19
2392: NOT
2393: IFFALSE 2439
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2395: LD_ADDR_EXP 19
2399: PUSH
2400: LD_STRING Lisa
2402: PPUSH
2403: LD_EXP 1
2407: NOT
2408: PPUSH
2409: LD_STRING 13a_
2411: PPUSH
2412: CALL 51488 0 3
2416: ST_TO_ADDR
// if Lisa then
2417: LD_EXP 19
2421: IFFALSE 2439
// tmp := tmp ^ Lisa ;
2423: LD_ADDR_VAR 0 5
2427: PUSH
2428: LD_VAR 0 5
2432: PUSH
2433: LD_EXP 19
2437: ADD
2438: ST_TO_ADDR
// end ; if not Donaldson then
2439: LD_EXP 20
2443: NOT
2444: IFFALSE 2490
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2446: LD_ADDR_EXP 20
2450: PUSH
2451: LD_STRING Donaldson
2453: PPUSH
2454: LD_EXP 1
2458: NOT
2459: PPUSH
2460: LD_STRING 13a_
2462: PPUSH
2463: CALL 51488 0 3
2467: ST_TO_ADDR
// if Donaldson then
2468: LD_EXP 20
2472: IFFALSE 2490
// tmp := tmp ^ Donaldson ;
2474: LD_ADDR_VAR 0 5
2478: PUSH
2479: LD_VAR 0 5
2483: PUSH
2484: LD_EXP 20
2488: ADD
2489: ST_TO_ADDR
// end ; if not Bobby then
2490: LD_EXP 21
2494: NOT
2495: IFFALSE 2541
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2497: LD_ADDR_EXP 21
2501: PUSH
2502: LD_STRING Bobby
2504: PPUSH
2505: LD_EXP 1
2509: NOT
2510: PPUSH
2511: LD_STRING 13a_
2513: PPUSH
2514: CALL 51488 0 3
2518: ST_TO_ADDR
// if Bobby then
2519: LD_EXP 21
2523: IFFALSE 2541
// tmp := tmp ^ Bobby ;
2525: LD_ADDR_VAR 0 5
2529: PUSH
2530: LD_VAR 0 5
2534: PUSH
2535: LD_EXP 21
2539: ADD
2540: ST_TO_ADDR
// end ; if not Cyrus then
2541: LD_EXP 22
2545: NOT
2546: IFFALSE 2592
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2548: LD_ADDR_EXP 22
2552: PUSH
2553: LD_STRING Cyrus
2555: PPUSH
2556: LD_EXP 1
2560: NOT
2561: PPUSH
2562: LD_STRING 13a_
2564: PPUSH
2565: CALL 51488 0 3
2569: ST_TO_ADDR
// if Cyrus then
2570: LD_EXP 22
2574: IFFALSE 2592
// tmp := tmp ^ Cyrus ;
2576: LD_ADDR_VAR 0 5
2580: PUSH
2581: LD_VAR 0 5
2585: PUSH
2586: LD_EXP 22
2590: ADD
2591: ST_TO_ADDR
// end ; if not Brown then
2592: LD_EXP 24
2596: NOT
2597: IFFALSE 2643
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2599: LD_ADDR_EXP 24
2603: PUSH
2604: LD_STRING Brown
2606: PPUSH
2607: LD_EXP 1
2611: NOT
2612: PPUSH
2613: LD_STRING 13a_
2615: PPUSH
2616: CALL 51488 0 3
2620: ST_TO_ADDR
// if Brown then
2621: LD_EXP 24
2625: IFFALSE 2643
// tmp := tmp ^ Brown ;
2627: LD_ADDR_VAR 0 5
2631: PUSH
2632: LD_VAR 0 5
2636: PUSH
2637: LD_EXP 24
2641: ADD
2642: ST_TO_ADDR
// end ; if not Gladstone then
2643: LD_EXP 25
2647: NOT
2648: IFFALSE 2694
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2650: LD_ADDR_EXP 25
2654: PUSH
2655: LD_STRING Gladstone
2657: PPUSH
2658: LD_EXP 1
2662: NOT
2663: PPUSH
2664: LD_STRING 13a_
2666: PPUSH
2667: CALL 51488 0 3
2671: ST_TO_ADDR
// if Gladstone then
2672: LD_EXP 25
2676: IFFALSE 2694
// tmp := tmp ^ Gladstone ;
2678: LD_ADDR_VAR 0 5
2682: PUSH
2683: LD_VAR 0 5
2687: PUSH
2688: LD_EXP 25
2692: ADD
2693: ST_TO_ADDR
// end ; if not Cornel then
2694: LD_EXP 27
2698: NOT
2699: IFFALSE 2745
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2701: LD_ADDR_EXP 27
2705: PUSH
2706: LD_STRING Cornel
2708: PPUSH
2709: LD_EXP 1
2713: NOT
2714: PPUSH
2715: LD_STRING 13a_
2717: PPUSH
2718: CALL 51488 0 3
2722: ST_TO_ADDR
// if Cornel then
2723: LD_EXP 27
2727: IFFALSE 2745
// tmp := tmp ^ Cornel ;
2729: LD_ADDR_VAR 0 5
2733: PUSH
2734: LD_VAR 0 5
2738: PUSH
2739: LD_EXP 27
2743: ADD
2744: ST_TO_ADDR
// end ; if not Houten then
2745: LD_EXP 26
2749: NOT
2750: IFFALSE 2796
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2752: LD_ADDR_EXP 26
2756: PUSH
2757: LD_STRING Houten
2759: PPUSH
2760: LD_EXP 1
2764: NOT
2765: PPUSH
2766: LD_STRING 13a_
2768: PPUSH
2769: CALL 51488 0 3
2773: ST_TO_ADDR
// if Houten then
2774: LD_EXP 26
2778: IFFALSE 2796
// tmp := tmp ^ Houten ;
2780: LD_ADDR_VAR 0 5
2784: PUSH
2785: LD_VAR 0 5
2789: PUSH
2790: LD_EXP 26
2794: ADD
2795: ST_TO_ADDR
// end ; if not Gary then
2796: LD_EXP 28
2800: NOT
2801: IFFALSE 2847
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2803: LD_ADDR_EXP 28
2807: PUSH
2808: LD_STRING Gary
2810: PPUSH
2811: LD_EXP 1
2815: NOT
2816: PPUSH
2817: LD_STRING 13a_
2819: PPUSH
2820: CALL 51488 0 3
2824: ST_TO_ADDR
// if Gary then
2825: LD_EXP 28
2829: IFFALSE 2847
// tmp := tmp ^ Gary ;
2831: LD_ADDR_VAR 0 5
2835: PUSH
2836: LD_VAR 0 5
2840: PUSH
2841: LD_EXP 28
2845: ADD
2846: ST_TO_ADDR
// end ; if not Kikuchi then
2847: LD_EXP 30
2851: NOT
2852: IFFALSE 2898
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2854: LD_ADDR_EXP 30
2858: PUSH
2859: LD_STRING Kikuchi
2861: PPUSH
2862: LD_EXP 1
2866: NOT
2867: PPUSH
2868: LD_STRING 13a_
2870: PPUSH
2871: CALL 51488 0 3
2875: ST_TO_ADDR
// if Kikuchi then
2876: LD_EXP 30
2880: IFFALSE 2898
// tmp := tmp ^ Kikuchi ;
2882: LD_ADDR_VAR 0 5
2886: PUSH
2887: LD_VAR 0 5
2891: PUSH
2892: LD_EXP 30
2896: ADD
2897: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2898: LD_ADDR_VAR 0 5
2902: PUSH
2903: LD_VAR 0 5
2907: PUSH
2908: LD_STRING 13a_others
2910: PPUSH
2911: CALL_OW 31
2915: UNION
2916: ST_TO_ADDR
// tmp := tmp diff 0 ;
2917: LD_ADDR_VAR 0 5
2921: PUSH
2922: LD_VAR 0 5
2926: PUSH
2927: LD_INT 0
2929: DIFF
2930: ST_TO_ADDR
// if tmp < 15 then
2931: LD_VAR 0 5
2935: PUSH
2936: LD_INT 15
2938: LESS
2939: IFFALSE 3027
// for i = 15 downto tmp do
2941: LD_ADDR_VAR 0 2
2945: PUSH
2946: DOUBLE
2947: LD_INT 15
2949: INC
2950: ST_TO_ADDR
2951: LD_VAR 0 5
2955: PUSH
2956: FOR_DOWNTO
2957: IFFALSE 3025
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2959: LD_ADDR_OWVAR 21
2963: PUSH
2964: LD_INT 1
2966: PUSH
2967: LD_INT 3
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: PUSH
2974: LD_INT 1
2976: PPUSH
2977: LD_INT 2
2979: PPUSH
2980: CALL_OW 12
2984: ARRAY
2985: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2986: LD_INT 0
2988: PPUSH
2989: LD_INT 1
2991: PPUSH
2992: LD_INT 4
2994: PPUSH
2995: CALL_OW 12
2999: PPUSH
3000: LD_INT 8
3002: PPUSH
3003: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3007: LD_ADDR_VAR 0 5
3011: PUSH
3012: LD_VAR 0 5
3016: PUSH
3017: CALL_OW 44
3021: ADD
3022: ST_TO_ADDR
// end ;
3023: GO 2956
3025: POP
3026: POP
// if not debug then
3027: LD_EXP 1
3031: NOT
3032: IFFALSE 3212
// selected = CharacterSelection (  , [ 15 , 14 , 13 , 12 ] [ Difficulty ] , [ 15 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3034: LD_ADDR_VAR 0 4
3038: PUSH
3039: LD_STRING 
3041: PPUSH
3042: LD_INT 15
3044: PUSH
3045: LD_INT 14
3047: PUSH
3048: LD_INT 13
3050: PUSH
3051: LD_INT 12
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PUSH
3060: LD_OWVAR 67
3064: ARRAY
3065: PPUSH
3066: LD_INT 15
3068: PUSH
3069: LD_INT 14
3071: PUSH
3072: LD_INT 13
3074: PUSH
3075: LD_INT 12
3077: PUSH
3078: EMPTY
3079: LIST
3080: LIST
3081: LIST
3082: LIST
3083: PUSH
3084: LD_OWVAR 67
3088: ARRAY
3089: PPUSH
3090: LD_INT -5
3092: PUSH
3093: LD_EXP 17
3097: PUSH
3098: LD_EXP 49
3102: PUSH
3103: LD_EXP 18
3107: PUSH
3108: LD_EXP 32
3112: PUSH
3113: LD_EXP 23
3117: PUSH
3118: LD_EXP 35
3122: PUSH
3123: LD_INT -2
3125: PUSH
3126: LD_INT -3
3128: PUSH
3129: LD_INT -5
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: PUSH
3144: LD_VAR 0 5
3148: ADD
3149: PPUSH
3150: LD_INT 1
3152: PUSH
3153: LD_INT 4
3155: PUSH
3156: LD_INT 2
3158: PUSH
3159: LD_INT 1
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: PUSH
3166: LD_INT 3
3168: PUSH
3169: LD_INT 5
3171: PUSH
3172: LD_INT 0
3174: PUSH
3175: LD_INT 3
3177: PUSH
3178: EMPTY
3179: LIST
3180: LIST
3181: LIST
3182: PUSH
3183: LD_INT 9
3185: PUSH
3186: LD_INT 0
3188: PUSH
3189: LD_INT 3
3191: PUSH
3192: EMPTY
3193: LIST
3194: LIST
3195: LIST
3196: PUSH
3197: EMPTY
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: CALL_OW 42
3209: ST_TO_ADDR
3210: GO 3291
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3212: LD_ADDR_VAR 0 4
3216: PUSH
3217: LD_EXP 37
3221: PUSH
3222: LD_EXP 38
3226: PUSH
3227: LD_EXP 39
3231: PUSH
3232: LD_EXP 40
3236: PUSH
3237: LD_EXP 41
3241: PUSH
3242: LD_EXP 42
3246: PUSH
3247: LD_EXP 43
3251: PUSH
3252: LD_EXP 44
3256: PUSH
3257: LD_EXP 45
3261: PUSH
3262: LD_EXP 46
3266: PUSH
3267: LD_EXP 47
3271: PUSH
3272: LD_EXP 48
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: LIST
3281: LIST
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: ST_TO_ADDR
// uc_nation := 1 ;
3291: LD_ADDR_OWVAR 21
3295: PUSH
3296: LD_INT 1
3298: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3299: LD_INT 5
3301: PPUSH
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 6
3310: PPUSH
3311: LD_INT 100
3313: PPUSH
3314: CALL 56352 0 5
// veh := CreateVehicle ;
3318: LD_ADDR_VAR 0 3
3322: PUSH
3323: CALL_OW 45
3327: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3328: LD_VAR 0 3
3332: PPUSH
3333: LD_INT 7
3335: NEG
3336: PPUSH
3337: CALL_OW 242
// SetDir ( veh , 3 ) ;
3341: LD_VAR 0 3
3345: PPUSH
3346: LD_INT 3
3348: PPUSH
3349: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3353: LD_VAR 0 3
3357: PPUSH
3358: LD_INT 31
3360: PPUSH
3361: LD_INT 0
3363: PPUSH
3364: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3368: LD_EXP 17
3372: PPUSH
3373: LD_VAR 0 3
3377: PPUSH
3378: CALL_OW 52
// if Joan then
3382: LD_EXP 32
3386: IFFALSE 3458
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3388: LD_INT 3
3390: PPUSH
3391: LD_INT 3
3393: PPUSH
3394: LD_INT 1
3396: PPUSH
3397: LD_INT 11
3399: PPUSH
3400: LD_INT 100
3402: PPUSH
3403: CALL 56352 0 5
// veh := CreateVehicle ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: CALL_OW 45
3416: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3417: LD_VAR 0 3
3421: PPUSH
3422: LD_INT 3
3424: PPUSH
3425: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3429: LD_VAR 0 3
3433: PPUSH
3434: LD_INT 30
3436: PPUSH
3437: LD_INT 0
3439: PPUSH
3440: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3444: LD_EXP 32
3448: PPUSH
3449: LD_VAR 0 3
3453: PPUSH
3454: CALL_OW 52
// end ; if Roth then
3458: LD_EXP 18
3462: IFFALSE 3534
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3464: LD_INT 3
3466: PPUSH
3467: LD_INT 3
3469: PPUSH
3470: LD_INT 1
3472: PPUSH
3473: LD_INT 11
3475: PPUSH
3476: LD_INT 100
3478: PPUSH
3479: CALL 56352 0 5
// veh := CreateVehicle ;
3483: LD_ADDR_VAR 0 3
3487: PUSH
3488: CALL_OW 45
3492: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3493: LD_VAR 0 3
3497: PPUSH
3498: LD_INT 3
3500: PPUSH
3501: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3505: LD_VAR 0 3
3509: PPUSH
3510: LD_INT 30
3512: PPUSH
3513: LD_INT 0
3515: PPUSH
3516: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3520: LD_EXP 18
3524: PPUSH
3525: LD_VAR 0 3
3529: PPUSH
3530: CALL_OW 52
// end ; if Denis then
3534: LD_EXP 23
3538: IFFALSE 3610
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3540: LD_INT 5
3542: PPUSH
3543: LD_INT 3
3545: PPUSH
3546: LD_INT 1
3548: PPUSH
3549: LD_INT 9
3551: PPUSH
3552: LD_INT 100
3554: PPUSH
3555: CALL 56352 0 5
// veh := CreateVehicle ;
3559: LD_ADDR_VAR 0 3
3563: PUSH
3564: CALL_OW 45
3568: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3569: LD_VAR 0 3
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3581: LD_VAR 0 3
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 0
3591: PPUSH
3592: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3596: LD_EXP 23
3600: PPUSH
3601: LD_VAR 0 3
3605: PPUSH
3606: CALL_OW 52
// end ; uc_nation := 3 ;
3610: LD_ADDR_OWVAR 21
3614: PUSH
3615: LD_INT 3
3617: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3618: LD_INT 22
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: LD_INT 45
3629: PPUSH
3630: LD_INT 100
3632: PPUSH
3633: CALL 56352 0 5
// veh := CreateVehicle ;
3637: LD_ADDR_VAR 0 3
3641: PUSH
3642: CALL_OW 45
3646: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3647: LD_VAR 0 3
3651: PPUSH
3652: LD_INT 7
3654: NEG
3655: PPUSH
3656: CALL_OW 242
// SetDir ( veh , 3 ) ;
3660: LD_VAR 0 3
3664: PPUSH
3665: LD_INT 3
3667: PPUSH
3668: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3672: LD_VAR 0 3
3676: PPUSH
3677: LD_INT 31
3679: PPUSH
3680: LD_INT 0
3682: PPUSH
3683: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3687: LD_EXP 49
3691: PPUSH
3692: LD_VAR 0 3
3696: PPUSH
3697: CALL_OW 52
// if Gossudarov then
3701: LD_EXP 35
3705: IFFALSE 3792
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3707: LD_INT 22
3709: PPUSH
3710: LD_INT 3
3712: PPUSH
3713: LD_INT 1
3715: PPUSH
3716: LD_INT 51
3718: PPUSH
3719: LD_INT 100
3721: PPUSH
3722: CALL 56352 0 5
// veh := CreateVehicle ;
3726: LD_ADDR_VAR 0 3
3730: PUSH
3731: CALL_OW 45
3735: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3736: LD_VAR 0 3
3740: PPUSH
3741: LD_INT 3
3743: PPUSH
3744: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3748: LD_VAR 0 3
3752: PPUSH
3753: LD_INT 30
3755: PPUSH
3756: LD_INT 0
3758: PPUSH
3759: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3763: LD_EXP 35
3767: PPUSH
3768: LD_VAR 0 3
3772: PPUSH
3773: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3777: LD_VAR 0 3
3781: PPUSH
3782: LD_INT 1
3784: PPUSH
3785: LD_INT 100
3787: PPUSH
3788: CALL_OW 290
// end ; for i in selected do
3792: LD_ADDR_VAR 0 2
3796: PUSH
3797: LD_VAR 0 4
3801: PUSH
3802: FOR_IN
3803: IFFALSE 4361
// begin uc_nation := GetNation ( i ) ;
3805: LD_ADDR_OWVAR 21
3809: PUSH
3810: LD_VAR 0 2
3814: PPUSH
3815: CALL_OW 248
3819: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3820: LD_VAR 0 2
3824: PUSH
3825: LD_EXP 19
3829: PUSH
3830: LD_EXP 20
3834: PUSH
3835: LD_EXP 22
3839: PUSH
3840: LD_EXP 21
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: IN
3851: IFFALSE 3874
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3853: LD_INT 5
3855: PPUSH
3856: LD_INT 3
3858: PPUSH
3859: LD_INT 1
3861: PPUSH
3862: LD_INT 6
3864: PPUSH
3865: LD_INT 100
3867: PPUSH
3868: CALL 56352 0 5
3872: GO 4308
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 42
3883: PUSH
3884: LD_EXP 47
3888: PUSH
3889: LD_EXP 45
3893: PUSH
3894: LD_EXP 37
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: LIST
3903: LIST
3904: IN
3905: IFFALSE 3936
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3907: LD_INT 24
3909: PPUSH
3910: LD_INT 1
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: LD_INT 46
3918: PPUSH
3919: LD_INT 65
3921: PPUSH
3922: LD_INT 75
3924: PPUSH
3925: CALL_OW 12
3929: PPUSH
3930: CALL 56352 0 5
3934: GO 4308
// if i = Karamazov then
3936: LD_VAR 0 2
3940: PUSH
3941: LD_EXP 48
3945: EQUAL
3946: IFFALSE 3969
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3948: LD_INT 22
3950: PPUSH
3951: LD_INT 3
3953: PPUSH
3954: LD_INT 1
3956: PPUSH
3957: LD_INT 52
3959: PPUSH
3960: LD_INT 100
3962: PPUSH
3963: CALL 56352 0 5
3967: GO 4308
// if i = Brown then
3969: LD_VAR 0 2
3973: PUSH
3974: LD_EXP 24
3978: EQUAL
3979: IFFALSE 4002
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3981: LD_INT 3
3983: PPUSH
3984: LD_INT 3
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 13
3992: PPUSH
3993: LD_INT 100
3995: PPUSH
3996: CALL 56352 0 5
4000: GO 4308
// if uc_nation = nation_american then
4002: LD_OWVAR 21
4006: PUSH
4007: LD_INT 1
4009: EQUAL
4010: IFFALSE 4161
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4012: LD_INT 3
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: LD_INT 5
4020: PUSH
4021: EMPTY
4022: LIST
4023: LIST
4024: LIST
4025: PUSH
4026: LD_OWVAR 21
4030: PUSH
4031: LD_INT 3
4033: MOD
4034: PUSH
4035: LD_INT 1
4037: PLUS
4038: ARRAY
4039: PPUSH
4040: LD_INT 1
4042: PUSH
4043: LD_INT 3
4045: PUSH
4046: LD_INT 1
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: LIST
4053: PUSH
4054: LD_OWVAR 21
4058: PUSH
4059: LD_INT 3
4061: MOD
4062: PUSH
4063: LD_INT 1
4065: PLUS
4066: ARRAY
4067: PPUSH
4068: LD_INT 1
4070: PPUSH
4071: LD_INT 11
4073: PUSH
4074: LD_INT 4
4076: PUSH
4077: LD_INT 5
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: LIST
4084: PUSH
4085: LD_INT 6
4087: PUSH
4088: LD_INT 7
4090: PUSH
4091: LD_INT 9
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: LIST
4098: PUSH
4099: LD_INT 6
4101: PUSH
4102: LD_INT 9
4104: PUSH
4105: LD_INT 12
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: LIST
4117: PUSH
4118: LD_OWVAR 21
4122: PUSH
4123: LD_INT 3
4125: MOD
4126: PUSH
4127: LD_INT 1
4129: PLUS
4130: ARRAY
4131: PUSH
4132: LD_INT 1
4134: PPUSH
4135: LD_INT 3
4137: PPUSH
4138: CALL_OW 12
4142: ARRAY
4143: PPUSH
4144: LD_INT 65
4146: PPUSH
4147: LD_INT 75
4149: PPUSH
4150: CALL_OW 12
4154: PPUSH
4155: CALL 56352 0 5
// end else
4159: GO 4308
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4161: LD_INT 22
4163: PUSH
4164: LD_INT 23
4166: PUSH
4167: LD_INT 23
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: LIST
4174: PUSH
4175: LD_OWVAR 21
4179: PUSH
4180: LD_INT 3
4182: MOD
4183: PUSH
4184: LD_INT 1
4186: PLUS
4187: ARRAY
4188: PPUSH
4189: LD_INT 1
4191: PUSH
4192: LD_INT 3
4194: PUSH
4195: LD_INT 1
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: LIST
4202: PUSH
4203: LD_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: MOD
4211: PUSH
4212: LD_INT 1
4214: PLUS
4215: ARRAY
4216: PPUSH
4217: LD_INT 1
4219: PPUSH
4220: LD_INT 45
4222: PUSH
4223: LD_INT 43
4225: PUSH
4226: LD_INT 44
4228: PUSH
4229: EMPTY
4230: LIST
4231: LIST
4232: LIST
4233: PUSH
4234: LD_INT 46
4236: PUSH
4237: LD_INT 45
4239: PUSH
4240: LD_INT 44
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: LIST
4247: PUSH
4248: LD_INT 46
4250: PUSH
4251: LD_INT 43
4253: PUSH
4254: LD_INT 45
4256: PUSH
4257: EMPTY
4258: LIST
4259: LIST
4260: LIST
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_OWVAR 21
4271: PUSH
4272: LD_INT 3
4274: MOD
4275: PUSH
4276: LD_INT 1
4278: PLUS
4279: ARRAY
4280: PUSH
4281: LD_INT 1
4283: PPUSH
4284: LD_INT 3
4286: PPUSH
4287: CALL_OW 12
4291: ARRAY
4292: PPUSH
4293: LD_INT 65
4295: PPUSH
4296: LD_INT 75
4298: PPUSH
4299: CALL_OW 12
4303: PPUSH
4304: CALL 56352 0 5
// end ; veh := CreateVehicle ;
4308: LD_ADDR_VAR 0 3
4312: PUSH
4313: CALL_OW 45
4317: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4318: LD_VAR 0 3
4322: PPUSH
4323: LD_INT 3
4325: PPUSH
4326: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4330: LD_VAR 0 3
4334: PPUSH
4335: LD_INT 30
4337: PPUSH
4338: LD_INT 0
4340: PPUSH
4341: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4345: LD_VAR 0 2
4349: PPUSH
4350: LD_VAR 0 3
4354: PPUSH
4355: CALL_OW 52
// end ;
4359: GO 3802
4361: POP
4362: POP
// if artifactArCaptured then
4363: LD_EXP 9
4367: IFFALSE 4453
// begin uc_nation := nation_american ;
4369: LD_ADDR_OWVAR 21
4373: PUSH
4374: LD_INT 1
4376: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4377: LD_INT 3
4379: PPUSH
4380: LD_INT 3
4382: PPUSH
4383: LD_INT 3
4385: PPUSH
4386: LD_INT 12
4388: PPUSH
4389: LD_INT 100
4391: PPUSH
4392: CALL 56352 0 5
// veh := CreateVehicle ;
4396: LD_ADDR_VAR 0 3
4400: PUSH
4401: CALL_OW 45
4405: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4406: LD_VAR 0 3
4410: PPUSH
4411: LD_INT 3
4413: PPUSH
4414: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4418: LD_VAR 0 3
4422: PPUSH
4423: LD_INT 198
4425: PPUSH
4426: LD_INT 22
4428: PPUSH
4429: LD_INT 0
4431: PPUSH
4432: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4436: LD_VAR 0 3
4440: PPUSH
4441: LD_INT 4
4443: PPUSH
4444: LD_INT 50
4446: PPUSH
4447: CALL_OW 290
// end else
4451: GO 4472
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4453: LD_INT 4
4455: PPUSH
4456: LD_INT 5
4458: PPUSH
4459: LD_INT 267
4461: PPUSH
4462: LD_INT 226
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 58
// end ; uc_nation := nation_american ;
4472: LD_ADDR_OWVAR 21
4476: PUSH
4477: LD_INT 1
4479: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4480: LD_INT 3
4482: PPUSH
4483: LD_INT 3
4485: PPUSH
4486: LD_INT 3
4488: PPUSH
4489: LD_INT 12
4491: PPUSH
4492: LD_INT 100
4494: PPUSH
4495: CALL 56352 0 5
// veh := CreateVehicle ;
4499: LD_ADDR_VAR 0 3
4503: PUSH
4504: CALL_OW 45
4508: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4509: LD_VAR 0 3
4513: PPUSH
4514: LD_INT 3
4516: PPUSH
4517: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4521: LD_VAR 0 3
4525: PPUSH
4526: LD_INT 218
4528: PPUSH
4529: LD_INT 23
4531: PPUSH
4532: LD_INT 0
4534: PPUSH
4535: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4539: LD_VAR 0 3
4543: PPUSH
4544: LD_INT 4
4546: PPUSH
4547: LD_INT 30
4549: PPUSH
4550: CALL_OW 290
// uc_nation := nation_russian ;
4554: LD_ADDR_OWVAR 21
4558: PUSH
4559: LD_INT 3
4561: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4562: LD_INT 22
4564: PPUSH
4565: LD_INT 3
4567: PPUSH
4568: LD_INT 3
4570: PPUSH
4571: LD_INT 51
4573: PPUSH
4574: LD_INT 100
4576: PPUSH
4577: CALL 56352 0 5
// veh := CreateVehicle ;
4581: LD_ADDR_VAR 0 3
4585: PUSH
4586: CALL_OW 45
4590: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4591: LD_VAR 0 3
4595: PPUSH
4596: LD_INT 3
4598: PPUSH
4599: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4603: LD_VAR 0 3
4607: PPUSH
4608: LD_INT 214
4610: PPUSH
4611: LD_INT 20
4613: PPUSH
4614: LD_INT 0
4616: PPUSH
4617: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4621: LD_VAR 0 3
4625: PPUSH
4626: LD_INT 4
4628: PPUSH
4629: LD_INT 40
4631: PPUSH
4632: CALL_OW 290
// end ; end_of_file
4636: LD_VAR 0 1
4640: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
4647: PPUSH
4648: PPUSH
4649: PPUSH
4650: PPUSH
4651: PPUSH
4652: PPUSH
// InitHc ;
4653: CALL_OW 19
// uc_side := 1 ;
4657: LD_ADDR_OWVAR 20
4661: PUSH
4662: LD_INT 1
4664: ST_TO_ADDR
// uc_nation := 1 ;
4665: LD_ADDR_OWVAR 21
4669: PUSH
4670: LD_INT 1
4672: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4673: LD_ADDR_VAR 0 2
4677: PUSH
4678: LD_INT 22
4680: PUSH
4681: LD_INT 1
4683: PUSH
4684: EMPTY
4685: LIST
4686: LIST
4687: PUSH
4688: LD_INT 21
4690: PUSH
4691: LD_INT 3
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PPUSH
4702: CALL_OW 69
4706: PUSH
4707: FOR_IN
4708: IFFALSE 4724
// SetBLevel ( i , 10 ) ;
4710: LD_VAR 0 2
4714: PPUSH
4715: LD_INT 10
4717: PPUSH
4718: CALL_OW 241
4722: GO 4707
4724: POP
4725: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4726: LD_INT 387
4728: PPUSH
4729: CALL_OW 274
4733: PPUSH
4734: LD_INT 1
4736: PPUSH
4737: LD_INT 7500
4739: PPUSH
4740: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4744: LD_INT 387
4746: PPUSH
4747: CALL_OW 274
4751: PPUSH
4752: LD_INT 2
4754: PPUSH
4755: LD_INT 4000
4757: PPUSH
4758: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4762: LD_INT 387
4764: PPUSH
4765: CALL_OW 274
4769: PPUSH
4770: LD_INT 3
4772: PPUSH
4773: LD_INT 50
4775: PPUSH
4776: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4780: LD_INT 476
4782: PPUSH
4783: CALL_OW 274
4787: PPUSH
4788: LD_INT 1
4790: PPUSH
4791: LD_INT 5500
4793: PPUSH
4794: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4798: LD_INT 476
4800: PPUSH
4801: CALL_OW 274
4805: PPUSH
4806: LD_INT 2
4808: PPUSH
4809: LD_INT 4000
4811: PPUSH
4812: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4816: LD_INT 476
4818: PPUSH
4819: CALL_OW 274
4823: PPUSH
4824: LD_INT 3
4826: PPUSH
4827: LD_INT 10
4829: PPUSH
4830: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4834: LD_ADDR_EXP 52
4838: PUSH
4839: LD_STRING Powell
4841: PPUSH
4842: CALL_OW 25
4846: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4847: LD_EXP 52
4851: PPUSH
4852: LD_INT 387
4854: PPUSH
4855: CALL_OW 52
// tmp := [ ] ;
4859: LD_ADDR_VAR 0 6
4863: PUSH
4864: EMPTY
4865: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4866: LD_ADDR_EXP 19
4870: PUSH
4871: LD_STRING Lisa
4873: PPUSH
4874: LD_EXP 1
4878: NOT
4879: PPUSH
4880: LD_STRING 12p_
4882: PPUSH
4883: CALL 51488 0 3
4887: ST_TO_ADDR
// if Lisa then
4888: LD_EXP 19
4892: IFFALSE 4910
// tmp := tmp ^ Lisa ;
4894: LD_ADDR_VAR 0 6
4898: PUSH
4899: LD_VAR 0 6
4903: PUSH
4904: LD_EXP 19
4908: ADD
4909: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4910: LD_ADDR_EXP 20
4914: PUSH
4915: LD_STRING Donaldson
4917: PPUSH
4918: LD_EXP 1
4922: NOT
4923: PPUSH
4924: LD_STRING 12p_
4926: PPUSH
4927: CALL 51488 0 3
4931: ST_TO_ADDR
// if Donaldson then
4932: LD_EXP 20
4936: IFFALSE 4954
// tmp := tmp ^ Donaldson ;
4938: LD_ADDR_VAR 0 6
4942: PUSH
4943: LD_VAR 0 6
4947: PUSH
4948: LD_EXP 20
4952: ADD
4953: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4954: LD_ADDR_EXP 21
4958: PUSH
4959: LD_STRING Bobby
4961: PPUSH
4962: LD_EXP 1
4966: NOT
4967: PPUSH
4968: LD_STRING 12p_
4970: PPUSH
4971: CALL 51488 0 3
4975: ST_TO_ADDR
// if Bobby then
4976: LD_EXP 21
4980: IFFALSE 4998
// tmp := tmp ^ Bobby ;
4982: LD_ADDR_VAR 0 6
4986: PUSH
4987: LD_VAR 0 6
4991: PUSH
4992: LD_EXP 21
4996: ADD
4997: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4998: LD_ADDR_EXP 22
5002: PUSH
5003: LD_STRING Cyrus
5005: PPUSH
5006: LD_EXP 1
5010: NOT
5011: PPUSH
5012: LD_STRING 12p_
5014: PPUSH
5015: CALL 51488 0 3
5019: ST_TO_ADDR
// if Cyrus then
5020: LD_EXP 22
5024: IFFALSE 5042
// tmp := tmp ^ Cyrus ;
5026: LD_ADDR_VAR 0 6
5030: PUSH
5031: LD_VAR 0 6
5035: PUSH
5036: LD_EXP 22
5040: ADD
5041: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5042: LD_ADDR_EXP 24
5046: PUSH
5047: LD_STRING Brown
5049: PPUSH
5050: LD_EXP 1
5054: NOT
5055: PPUSH
5056: LD_STRING 12p_
5058: PPUSH
5059: CALL 51488 0 3
5063: ST_TO_ADDR
// if Brown then
5064: LD_EXP 24
5068: IFFALSE 5086
// tmp := tmp ^ Brown ;
5070: LD_ADDR_VAR 0 6
5074: PUSH
5075: LD_VAR 0 6
5079: PUSH
5080: LD_EXP 24
5084: ADD
5085: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5086: LD_ADDR_EXP 25
5090: PUSH
5091: LD_STRING Gladstone
5093: PPUSH
5094: LD_EXP 1
5098: NOT
5099: PPUSH
5100: LD_STRING 12p_
5102: PPUSH
5103: CALL 51488 0 3
5107: ST_TO_ADDR
// if Gladstone then
5108: LD_EXP 25
5112: IFFALSE 5130
// tmp := tmp ^ Gladstone ;
5114: LD_ADDR_VAR 0 6
5118: PUSH
5119: LD_VAR 0 6
5123: PUSH
5124: LD_EXP 25
5128: ADD
5129: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5130: LD_ADDR_EXP 26
5134: PUSH
5135: LD_STRING Houten
5137: PPUSH
5138: LD_EXP 1
5142: NOT
5143: PPUSH
5144: LD_STRING 12p_
5146: PPUSH
5147: CALL 51488 0 3
5151: ST_TO_ADDR
// if Houten then
5152: LD_EXP 26
5156: IFFALSE 5174
// tmp := tmp ^ Houten ;
5158: LD_ADDR_VAR 0 6
5162: PUSH
5163: LD_VAR 0 6
5167: PUSH
5168: LD_EXP 26
5172: ADD
5173: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5174: LD_ADDR_EXP 27
5178: PUSH
5179: LD_STRING Cornel
5181: PPUSH
5182: LD_EXP 1
5186: NOT
5187: PPUSH
5188: LD_STRING 12p_
5190: PPUSH
5191: CALL 51488 0 3
5195: ST_TO_ADDR
// if Cornel then
5196: LD_EXP 27
5200: IFFALSE 5218
// tmp := tmp ^ Cornel ;
5202: LD_ADDR_VAR 0 6
5206: PUSH
5207: LD_VAR 0 6
5211: PUSH
5212: LD_EXP 27
5216: ADD
5217: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5218: LD_ADDR_EXP 28
5222: PUSH
5223: LD_STRING Gary
5225: PPUSH
5226: LD_EXP 1
5230: NOT
5231: PPUSH
5232: LD_STRING 12p_
5234: PPUSH
5235: CALL 51488 0 3
5239: ST_TO_ADDR
// if Gary then
5240: LD_EXP 28
5244: IFFALSE 5262
// tmp := tmp ^ Gary ;
5246: LD_ADDR_VAR 0 6
5250: PUSH
5251: LD_VAR 0 6
5255: PUSH
5256: LD_EXP 28
5260: ADD
5261: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5262: LD_ADDR_EXP 30
5266: PUSH
5267: LD_STRING Kikuchi
5269: PPUSH
5270: LD_EXP 1
5274: NOT
5275: PPUSH
5276: LD_STRING 12p_
5278: PPUSH
5279: CALL 51488 0 3
5283: ST_TO_ADDR
// if Kikuchi then
5284: LD_EXP 30
5288: IFFALSE 5306
// tmp := tmp ^ Kikuchi ;
5290: LD_ADDR_VAR 0 6
5294: PUSH
5295: LD_VAR 0 6
5299: PUSH
5300: LD_EXP 30
5304: ADD
5305: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5306: LD_ADDR_VAR 0 6
5310: PUSH
5311: LD_VAR 0 6
5315: PUSH
5316: LD_STRING 12p_others
5318: PPUSH
5319: CALL_OW 31
5323: UNION
5324: ST_TO_ADDR
// if tmp < 36 then
5325: LD_VAR 0 6
5329: PUSH
5330: LD_INT 36
5332: LESS
5333: IFFALSE 5400
// for i = 1 to 36 - tmp do
5335: LD_ADDR_VAR 0 2
5339: PUSH
5340: DOUBLE
5341: LD_INT 1
5343: DEC
5344: ST_TO_ADDR
5345: LD_INT 36
5347: PUSH
5348: LD_VAR 0 6
5352: MINUS
5353: PUSH
5354: FOR_TO
5355: IFFALSE 5398
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5357: LD_INT 1
5359: PPUSH
5360: LD_VAR 0 2
5364: PUSH
5365: LD_INT 4
5367: MOD
5368: PUSH
5369: LD_INT 1
5371: PLUS
5372: PPUSH
5373: LD_INT 10
5375: PPUSH
5376: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5380: LD_ADDR_VAR 0 6
5384: PUSH
5385: LD_VAR 0 6
5389: PUSH
5390: CALL_OW 44
5394: ADD
5395: ST_TO_ADDR
// end ;
5396: GO 5354
5398: POP
5399: POP
// for i in tmp do
5400: LD_ADDR_VAR 0 2
5404: PUSH
5405: LD_VAR 0 6
5409: PUSH
5410: FOR_IN
5411: IFFALSE 5436
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5413: LD_VAR 0 2
5417: PPUSH
5418: LD_INT 62
5420: PPUSH
5421: LD_INT 93
5423: PPUSH
5424: LD_INT 9
5426: PPUSH
5427: LD_INT 0
5429: PPUSH
5430: CALL_OW 50
5434: GO 5410
5436: POP
5437: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5438: LD_ADDR_EXP 93
5442: PUSH
5443: LD_EXP 93
5447: PPUSH
5448: LD_INT 4
5450: PPUSH
5451: LD_INT 22
5453: PUSH
5454: LD_INT 1
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: PPUSH
5461: CALL_OW 69
5465: PUSH
5466: LD_EXP 52
5470: DIFF
5471: PPUSH
5472: CALL_OW 1
5476: ST_TO_ADDR
// uc_side := 0 ;
5477: LD_ADDR_OWVAR 20
5481: PUSH
5482: LD_INT 0
5484: ST_TO_ADDR
// uc_nation := 0 ;
5485: LD_ADDR_OWVAR 21
5489: PUSH
5490: LD_INT 0
5492: ST_TO_ADDR
// for i = 1 to 4 do
5493: LD_ADDR_VAR 0 2
5497: PUSH
5498: DOUBLE
5499: LD_INT 1
5501: DEC
5502: ST_TO_ADDR
5503: LD_INT 4
5505: PUSH
5506: FOR_TO
5507: IFFALSE 5538
// begin InitHc ;
5509: CALL_OW 19
// hc_class := class_apeman ;
5513: LD_ADDR_OWVAR 28
5517: PUSH
5518: LD_INT 12
5520: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5521: CALL_OW 44
5525: PPUSH
5526: LD_INT 11
5528: PPUSH
5529: LD_INT 0
5531: PPUSH
5532: CALL_OW 49
// end ;
5536: GO 5506
5538: POP
5539: POP
// end ;
5540: LD_VAR 0 1
5544: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5545: LD_EXP 4
5549: NOT
5550: PUSH
5551: LD_INT 4
5553: PPUSH
5554: LD_INT 1
5556: PPUSH
5557: CALL 46500 0 2
5561: NOT
5562: AND
5563: IFFALSE 6335
5565: GO 5567
5567: DISABLE
5568: LD_INT 0
5570: PPUSH
5571: PPUSH
5572: PPUSH
// begin enable ;
5573: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5574: LD_INT 22
5576: PUSH
5577: LD_INT 1
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 23
5586: PUSH
5587: LD_INT 1
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: LD_INT 30
5596: PUSH
5597: LD_INT 3
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: PPUSH
5609: CALL_OW 69
5613: NOT
5614: IFFALSE 5618
// exit ;
5616: GO 6335
// if Prob ( 40 ) then
5618: LD_INT 40
5620: PPUSH
5621: CALL_OW 13
5625: IFFALSE 5752
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5627: LD_INT 4
5629: PPUSH
5630: LD_INT 5
5632: PUSH
5633: LD_INT 1
5635: PUSH
5636: LD_INT 2
5638: PUSH
5639: LD_INT 7
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: LIST
5646: LIST
5647: PUSH
5648: LD_INT 5
5650: PUSH
5651: LD_INT 1
5653: PUSH
5654: LD_INT 2
5656: PUSH
5657: LD_INT 7
5659: PUSH
5660: EMPTY
5661: LIST
5662: LIST
5663: LIST
5664: LIST
5665: PUSH
5666: LD_INT 5
5668: PUSH
5669: LD_INT 1
5671: PUSH
5672: LD_INT 2
5674: PUSH
5675: LD_INT 7
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PUSH
5684: LD_INT 5
5686: PUSH
5687: LD_INT 1
5689: PUSH
5690: LD_INT 2
5692: PUSH
5693: LD_INT 6
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: LIST
5701: PUSH
5702: LD_INT 5
5704: PUSH
5705: LD_INT 1
5707: PUSH
5708: LD_INT 2
5710: PUSH
5711: LD_INT 6
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: LIST
5718: LIST
5719: PUSH
5720: LD_INT 5
5722: PUSH
5723: LD_INT 1
5725: PUSH
5726: LD_INT 2
5728: PUSH
5729: LD_INT 6
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: LIST
5736: LIST
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: PPUSH
5746: CALL 45082 0 2
// end else
5750: GO 5875
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5752: LD_INT 4
5754: PPUSH
5755: LD_INT 5
5757: PUSH
5758: LD_INT 1
5760: PUSH
5761: LD_INT 2
5763: PUSH
5764: LD_INT 7
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 5
5775: PUSH
5776: LD_INT 1
5778: PUSH
5779: LD_INT 2
5781: PUSH
5782: LD_INT 9
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 5
5793: PUSH
5794: LD_INT 1
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: LD_INT 9
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PUSH
5809: LD_INT 5
5811: PUSH
5812: LD_INT 1
5814: PUSH
5815: LD_INT 2
5817: PUSH
5818: LD_INT 6
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: LIST
5825: LIST
5826: PUSH
5827: LD_INT 5
5829: PUSH
5830: LD_INT 1
5832: PUSH
5833: LD_INT 2
5835: PUSH
5836: LD_INT 6
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: LIST
5843: LIST
5844: PUSH
5845: LD_INT 5
5847: PUSH
5848: LD_INT 1
5850: PUSH
5851: LD_INT 2
5853: PUSH
5854: LD_INT 6
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: PPUSH
5871: CALL 45082 0 2
// end ; repeat wait ( 0 0$1 ) ;
5875: LD_INT 35
5877: PPUSH
5878: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5882: LD_INT 4
5884: PPUSH
5885: LD_INT 1
5887: PPUSH
5888: CALL 46500 0 2
5892: PUSH
5893: LD_INT 6
5895: GREATEREQUAL
5896: IFFALSE 5875
// wait ( 0 0$30 ) ;
5898: LD_INT 1050
5900: PPUSH
5901: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5905: LD_ADDR_VAR 0 2
5909: PUSH
5910: LD_INT 4
5912: PPUSH
5913: LD_INT 1
5915: PPUSH
5916: CALL 46500 0 2
5920: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5921: LD_ADDR_EXP 112
5925: PUSH
5926: LD_EXP 112
5930: PPUSH
5931: LD_INT 4
5933: PPUSH
5934: LD_EXP 112
5938: PUSH
5939: LD_INT 4
5941: ARRAY
5942: PUSH
5943: LD_VAR 0 2
5947: DIFF
5948: PPUSH
5949: CALL_OW 1
5953: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5954: LD_ADDR_VAR 0 3
5958: PUSH
5959: LD_INT 0
5961: PPUSH
5962: LD_INT 2
5964: PPUSH
5965: CALL_OW 12
5969: ST_TO_ADDR
// if target then
5970: LD_VAR 0 3
5974: IFFALSE 6102
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5976: LD_ADDR_VAR 0 2
5980: PUSH
5981: LD_VAR 0 2
5985: PPUSH
5986: LD_INT 24
5988: PUSH
5989: LD_INT 250
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: PPUSH
5996: CALL_OW 72
6000: ST_TO_ADDR
// for i in tmp do
6001: LD_ADDR_VAR 0 1
6005: PUSH
6006: LD_VAR 0 2
6010: PUSH
6011: FOR_IN
6012: IFFALSE 6052
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6014: LD_VAR 0 1
6018: PPUSH
6019: LD_INT 114
6021: PPUSH
6022: LD_INT 108
6024: PPUSH
6025: CALL_OW 297
6029: PUSH
6030: LD_INT 9
6032: GREATER
6033: IFFALSE 6050
// ComMoveXY ( i , 114 , 108 ) ;
6035: LD_VAR 0 1
6039: PPUSH
6040: LD_INT 114
6042: PPUSH
6043: LD_INT 108
6045: PPUSH
6046: CALL_OW 111
6050: GO 6011
6052: POP
6053: POP
// wait ( 0 0$1 ) ;
6054: LD_INT 35
6056: PPUSH
6057: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6061: LD_VAR 0 2
6065: PPUSH
6066: LD_INT 92
6068: PUSH
6069: LD_INT 114
6071: PUSH
6072: LD_INT 108
6074: PUSH
6075: LD_INT 9
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PPUSH
6084: CALL_OW 72
6088: PUSH
6089: LD_VAR 0 2
6093: PUSH
6094: LD_INT 1
6096: MINUS
6097: GREATEREQUAL
6098: IFFALSE 5976
// end else
6100: GO 6226
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6102: LD_ADDR_VAR 0 2
6106: PUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: LD_INT 24
6114: PUSH
6115: LD_INT 250
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PPUSH
6122: CALL_OW 72
6126: ST_TO_ADDR
// for i in tmp do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: LD_VAR 0 2
6136: PUSH
6137: FOR_IN
6138: IFFALSE 6178
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6140: LD_VAR 0 1
6144: PPUSH
6145: LD_INT 129
6147: PPUSH
6148: LD_INT 139
6150: PPUSH
6151: CALL_OW 297
6155: PUSH
6156: LD_INT 9
6158: GREATER
6159: IFFALSE 6176
// ComMoveXY ( i , 129 , 139 ) ;
6161: LD_VAR 0 1
6165: PPUSH
6166: LD_INT 129
6168: PPUSH
6169: LD_INT 139
6171: PPUSH
6172: CALL_OW 111
6176: GO 6137
6178: POP
6179: POP
// wait ( 0 0$1 ) ;
6180: LD_INT 35
6182: PPUSH
6183: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6187: LD_VAR 0 2
6191: PPUSH
6192: LD_INT 92
6194: PUSH
6195: LD_INT 129
6197: PUSH
6198: LD_INT 139
6200: PUSH
6201: LD_INT 9
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL_OW 72
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_INT 1
6222: MINUS
6223: GREATEREQUAL
6224: IFFALSE 6102
// end ; repeat wait ( 0 0$1 ) ;
6226: LD_INT 35
6228: PPUSH
6229: CALL_OW 67
// for i in tmp do
6233: LD_ADDR_VAR 0 1
6237: PUSH
6238: LD_VAR 0 2
6242: PUSH
6243: FOR_IN
6244: IFFALSE 6326
// begin if GetLives ( i ) > 251 then
6246: LD_VAR 0 1
6250: PPUSH
6251: CALL_OW 256
6255: PUSH
6256: LD_INT 251
6258: GREATER
6259: IFFALSE 6297
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6261: LD_VAR 0 1
6265: PPUSH
6266: LD_INT 81
6268: PUSH
6269: LD_INT 1
6271: PUSH
6272: EMPTY
6273: LIST
6274: LIST
6275: PPUSH
6276: CALL_OW 69
6280: PPUSH
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 74
6290: PPUSH
6291: CALL_OW 115
6295: GO 6324
// if IsDead ( i ) then
6297: LD_VAR 0 1
6301: PPUSH
6302: CALL_OW 301
6306: IFFALSE 6324
// tmp := tmp diff i ;
6308: LD_ADDR_VAR 0 2
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_VAR 0 1
6322: DIFF
6323: ST_TO_ADDR
// end ;
6324: GO 6243
6326: POP
6327: POP
// until not tmp ;
6328: LD_VAR 0 2
6332: NOT
6333: IFFALSE 6226
// end ;
6335: PPOPN 3
6337: END
// every 30 30$00 trigger not americanDestroyed do
6338: LD_EXP 4
6342: NOT
6343: IFFALSE 6412
6345: GO 6347
6347: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6348: LD_INT 63000
6350: PUSH
6351: LD_INT 42000
6353: PUSH
6354: LD_INT 31500
6356: PUSH
6357: LD_INT 21000
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: PUSH
6366: LD_OWVAR 67
6370: ARRAY
6371: PPUSH
6372: CALL_OW 67
// if americanDestroyed then
6376: LD_EXP 4
6380: IFFALSE 6384
// exit ;
6382: GO 6412
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6384: LD_INT 4
6386: PPUSH
6387: LD_INT 5
6389: PUSH
6390: LD_INT 3
6392: PUSH
6393: LD_INT 1
6395: PUSH
6396: LD_INT 8
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: EMPTY
6406: LIST
6407: PPUSH
6408: CALL 45082 0 2
// end ; end_of_file
6412: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6413: LD_INT 0
6415: PPUSH
6416: PPUSH
6417: PPUSH
6418: PPUSH
6419: PPUSH
// side := 2 ;
6420: LD_ADDR_VAR 0 5
6424: PUSH
6425: LD_INT 2
6427: ST_TO_ADDR
// InitHc ;
6428: CALL_OW 19
// uc_side := side ;
6432: LD_ADDR_OWVAR 20
6436: PUSH
6437: LD_VAR 0 5
6441: ST_TO_ADDR
// uc_nation := 2 ;
6442: LD_ADDR_OWVAR 21
6446: PUSH
6447: LD_INT 2
6449: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6450: LD_ADDR_VAR 0 2
6454: PUSH
6455: LD_INT 22
6457: PUSH
6458: LD_INT 2
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: PUSH
6465: LD_INT 21
6467: PUSH
6468: LD_INT 3
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: PUSH
6475: EMPTY
6476: LIST
6477: LIST
6478: PPUSH
6479: CALL_OW 69
6483: PUSH
6484: FOR_IN
6485: IFFALSE 6501
// SetBLevel ( i , 10 ) ;
6487: LD_VAR 0 2
6491: PPUSH
6492: LD_INT 10
6494: PPUSH
6495: CALL_OW 241
6499: GO 6484
6501: POP
6502: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6503: LD_ADDR_VAR 0 4
6507: PUSH
6508: LD_INT 22
6510: PUSH
6511: LD_VAR 0 5
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: PUSH
6520: LD_INT 30
6522: PUSH
6523: LD_INT 32
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PUSH
6530: LD_INT 58
6532: PUSH
6533: EMPTY
6534: LIST
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: LIST
6540: PPUSH
6541: CALL_OW 69
6545: ST_TO_ADDR
// for i = 1 to 10 do
6546: LD_ADDR_VAR 0 2
6550: PUSH
6551: DOUBLE
6552: LD_INT 1
6554: DEC
6555: ST_TO_ADDR
6556: LD_INT 10
6558: PUSH
6559: FOR_TO
6560: IFFALSE 6632
// begin uc_nation := nation_nature ;
6562: LD_ADDR_OWVAR 21
6566: PUSH
6567: LD_INT 0
6569: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6570: LD_ADDR_OWVAR 28
6574: PUSH
6575: LD_INT 15
6577: ST_TO_ADDR
// hc_gallery :=  ;
6578: LD_ADDR_OWVAR 33
6582: PUSH
6583: LD_STRING 
6585: ST_TO_ADDR
// hc_name :=  ;
6586: LD_ADDR_OWVAR 26
6590: PUSH
6591: LD_STRING 
6593: ST_TO_ADDR
// un := CreateHuman ;
6594: LD_ADDR_VAR 0 3
6598: PUSH
6599: CALL_OW 44
6603: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6604: LD_VAR 0 3
6608: PPUSH
6609: LD_VAR 0 4
6613: PUSH
6614: LD_VAR 0 4
6618: PUSH
6619: LD_VAR 0 2
6623: MINUS
6624: ARRAY
6625: PPUSH
6626: CALL_OW 52
// end ;
6630: GO 6559
6632: POP
6633: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6634: LD_INT 503
6636: PPUSH
6637: LD_INT 27
6639: PPUSH
6640: LD_STRING 
6642: PPUSH
6643: LD_INT 8
6645: PUSH
6646: LD_INT 9
6648: PUSH
6649: LD_INT 10
6651: PUSH
6652: LD_INT 10
6654: PUSH
6655: EMPTY
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: PUSH
6661: LD_OWVAR 67
6665: ARRAY
6666: PPUSH
6667: LD_INT 3000
6669: PUSH
6670: LD_INT 500
6672: PUSH
6673: LD_INT 150
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: LIST
6680: PPUSH
6681: LD_INT 16
6683: PUSH
6684: LD_INT 6
6686: PUSH
6687: LD_INT 6
6689: PUSH
6690: LD_INT 6
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: PPUSH
6699: CALL 59798 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6703: LD_ADDR_EXP 93
6707: PUSH
6708: LD_EXP 93
6712: PPUSH
6713: LD_INT 1
6715: PPUSH
6716: LD_INT 22
6718: PUSH
6719: LD_VAR 0 5
6723: PUSH
6724: EMPTY
6725: LIST
6726: LIST
6727: PUSH
6728: LD_INT 23
6730: PUSH
6731: LD_INT 2
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PUSH
6738: LD_INT 3
6740: PUSH
6741: LD_INT 21
6743: PUSH
6744: LD_INT 2
6746: PUSH
6747: EMPTY
6748: LIST
6749: LIST
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: LIST
6759: PPUSH
6760: CALL_OW 69
6764: PPUSH
6765: CALL_OW 1
6769: ST_TO_ADDR
// end ;
6770: LD_VAR 0 1
6774: RET
// export Omar ; export function PrepareOmarAli ; begin
6775: LD_INT 0
6777: PPUSH
// uc_side := 5 ;
6778: LD_ADDR_OWVAR 20
6782: PUSH
6783: LD_INT 5
6785: ST_TO_ADDR
// uc_nation := 2 ;
6786: LD_ADDR_OWVAR 21
6790: PUSH
6791: LD_INT 2
6793: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6794: LD_ADDR_EXP 53
6798: PUSH
6799: LD_STRING Omar
6801: PPUSH
6802: CALL_OW 25
6806: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6807: LD_EXP 53
6811: PPUSH
6812: LD_INT 330
6814: PPUSH
6815: LD_INT 244
6817: PPUSH
6818: LD_INT 0
6820: PPUSH
6821: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6825: LD_EXP 53
6829: PPUSH
6830: LD_INT 252
6832: PPUSH
6833: LD_INT 220
6835: PPUSH
6836: CALL_OW 111
// end ; end_of_file
6840: LD_VAR 0 1
6844: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6845: LD_INT 0
6847: PPUSH
6848: PPUSH
6849: PPUSH
6850: PPUSH
6851: PPUSH
// side := 8 ;
6852: LD_ADDR_VAR 0 3
6856: PUSH
6857: LD_INT 8
6859: ST_TO_ADDR
// InitHc ;
6860: CALL_OW 19
// uc_side := side ;
6864: LD_ADDR_OWVAR 20
6868: PUSH
6869: LD_VAR 0 3
6873: ST_TO_ADDR
// uc_nation := 2 ;
6874: LD_ADDR_OWVAR 21
6878: PUSH
6879: LD_INT 2
6881: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6882: LD_ADDR_VAR 0 2
6886: PUSH
6887: LD_INT 22
6889: PUSH
6890: LD_VAR 0 3
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: PUSH
6899: LD_INT 21
6901: PUSH
6902: LD_INT 3
6904: PUSH
6905: EMPTY
6906: LIST
6907: LIST
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PPUSH
6913: CALL_OW 69
6917: PUSH
6918: FOR_IN
6919: IFFALSE 6935
// SetBLevel ( i , 10 ) ;
6921: LD_VAR 0 2
6925: PPUSH
6926: LD_INT 10
6928: PPUSH
6929: CALL_OW 241
6933: GO 6918
6935: POP
6936: POP
// Schulz := NewCharacter ( Schulz ) ;
6937: LD_ADDR_EXP 54
6941: PUSH
6942: LD_STRING Schulz
6944: PPUSH
6945: CALL_OW 25
6949: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6950: LD_ADDR_EXP 55
6954: PUSH
6955: LD_STRING Kozlov
6957: PPUSH
6958: LD_INT 0
6960: PPUSH
6961: LD_STRING 
6963: PPUSH
6964: CALL 51488 0 3
6968: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6969: LD_EXP 55
6973: PPUSH
6974: LD_INT 22
6976: PUSH
6977: LD_INT 8
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 23
6986: PUSH
6987: LD_INT 3
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 30
6996: PUSH
6997: LD_INT 8
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PUSH
7014: LD_INT 1
7016: ARRAY
7017: PPUSH
7018: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7022: LD_EXP 55
7026: PPUSH
7027: LD_INT 3
7029: PPUSH
7030: LD_INT 10
7032: PPUSH
7033: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7037: LD_ADDR_VAR 0 5
7041: PUSH
7042: LD_INT 22
7044: PUSH
7045: LD_VAR 0 3
7049: PUSH
7050: EMPTY
7051: LIST
7052: LIST
7053: PUSH
7054: LD_INT 30
7056: PUSH
7057: LD_INT 32
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PUSH
7064: LD_INT 58
7066: PUSH
7067: EMPTY
7068: LIST
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: PPUSH
7075: CALL_OW 69
7079: ST_TO_ADDR
// for i = 1 to 10 do
7080: LD_ADDR_VAR 0 2
7084: PUSH
7085: DOUBLE
7086: LD_INT 1
7088: DEC
7089: ST_TO_ADDR
7090: LD_INT 10
7092: PUSH
7093: FOR_TO
7094: IFFALSE 7166
// begin uc_nation := nation_nature ;
7096: LD_ADDR_OWVAR 21
7100: PUSH
7101: LD_INT 0
7103: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7104: LD_ADDR_OWVAR 28
7108: PUSH
7109: LD_INT 15
7111: ST_TO_ADDR
// hc_gallery :=  ;
7112: LD_ADDR_OWVAR 33
7116: PUSH
7117: LD_STRING 
7119: ST_TO_ADDR
// hc_name :=  ;
7120: LD_ADDR_OWVAR 26
7124: PUSH
7125: LD_STRING 
7127: ST_TO_ADDR
// un := CreateHuman ;
7128: LD_ADDR_VAR 0 4
7132: PUSH
7133: CALL_OW 44
7137: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7138: LD_VAR 0 4
7142: PPUSH
7143: LD_VAR 0 5
7147: PUSH
7148: LD_VAR 0 5
7152: PUSH
7153: LD_VAR 0 2
7157: MINUS
7158: ARRAY
7159: PPUSH
7160: CALL_OW 52
// end ;
7164: GO 7093
7166: POP
7167: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7168: LD_INT 324
7170: PPUSH
7171: LD_INT 3
7173: PPUSH
7174: LD_STRING 
7176: PPUSH
7177: LD_INT 8
7179: PUSH
7180: LD_INT 9
7182: PUSH
7183: LD_INT 10
7185: PUSH
7186: LD_INT 10
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: LIST
7194: PUSH
7195: LD_OWVAR 67
7199: ARRAY
7200: PPUSH
7201: LD_INT 3000
7203: PUSH
7204: LD_INT 500
7206: PUSH
7207: LD_INT 150
7209: PUSH
7210: EMPTY
7211: LIST
7212: LIST
7213: LIST
7214: PPUSH
7215: LD_INT 16
7217: PUSH
7218: LD_INT 6
7220: PUSH
7221: LD_INT 6
7223: PUSH
7224: LD_INT 8
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: LIST
7231: LIST
7232: PPUSH
7233: CALL 59798 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7237: LD_ADDR_EXP 93
7241: PUSH
7242: LD_EXP 93
7246: PPUSH
7247: LD_INT 3
7249: PPUSH
7250: LD_INT 22
7252: PUSH
7253: LD_VAR 0 3
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: PUSH
7262: LD_INT 23
7264: PUSH
7265: LD_INT 2
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PUSH
7272: LD_INT 3
7274: PUSH
7275: LD_INT 21
7277: PUSH
7278: LD_INT 2
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PUSH
7285: EMPTY
7286: LIST
7287: LIST
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: LIST
7293: PPUSH
7294: CALL_OW 69
7298: PUSH
7299: LD_EXP 54
7303: DIFF
7304: PPUSH
7305: CALL_OW 1
7309: ST_TO_ADDR
// end ;
7310: LD_VAR 0 1
7314: RET
// export function BuildKozlovBomb ; begin
7315: LD_INT 0
7317: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7318: LD_INT 332
7320: PPUSH
7321: CALL_OW 302
7325: NOT
7326: PUSH
7327: LD_INT 336
7329: PPUSH
7330: CALL_OW 302
7334: NOT
7335: OR
7336: IFFALSE 7340
// exit ;
7338: GO 7437
// ComChangeProfession ( Kozlov , 4 ) ;
7340: LD_EXP 55
7344: PPUSH
7345: LD_INT 4
7347: PPUSH
7348: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7352: LD_INT 336
7354: PPUSH
7355: LD_INT 25
7357: PPUSH
7358: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7362: LD_INT 35
7364: PPUSH
7365: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7369: LD_INT 25
7371: PPUSH
7372: LD_INT 8
7374: PPUSH
7375: CALL_OW 321
7379: PUSH
7380: LD_INT 2
7382: EQUAL
7383: IFFALSE 7362
// ComExitBuilding ( Kozlov ) ;
7385: LD_EXP 55
7389: PPUSH
7390: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7394: LD_EXP 55
7398: PPUSH
7399: LD_INT 332
7401: PPUSH
7402: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7406: LD_EXP 55
7410: PPUSH
7411: LD_INT 3
7413: PPUSH
7414: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7418: LD_INT 332
7420: PPUSH
7421: LD_INT 23
7423: PPUSH
7424: LD_INT 3
7426: PPUSH
7427: LD_INT 1
7429: PPUSH
7430: LD_INT 48
7432: PPUSH
7433: CALL_OW 125
// end ;
7437: LD_VAR 0 1
7441: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7442: LD_EXP 3
7446: NOT
7447: PUSH
7448: LD_INT 3
7450: PPUSH
7451: LD_INT 1
7453: PPUSH
7454: CALL 46500 0 2
7458: NOT
7459: AND
7460: IFFALSE 8316
7462: GO 7464
7464: DISABLE
7465: LD_INT 0
7467: PPUSH
7468: PPUSH
7469: PPUSH
// begin enable ;
7470: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7471: LD_INT 22
7473: PUSH
7474: LD_INT 8
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: PUSH
7481: LD_INT 23
7483: PUSH
7484: LD_INT 2
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 30
7493: PUSH
7494: LD_INT 3
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: PPUSH
7506: CALL_OW 69
7510: NOT
7511: IFFALSE 7515
// exit ;
7513: GO 8316
// if Prob ( 40 ) then
7515: LD_INT 40
7517: PPUSH
7518: CALL_OW 13
7522: IFFALSE 7649
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7524: LD_INT 3
7526: PPUSH
7527: LD_INT 14
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: LD_INT 2
7535: PUSH
7536: LD_INT 28
7538: PUSH
7539: EMPTY
7540: LIST
7541: LIST
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 14
7547: PUSH
7548: LD_INT 1
7550: PUSH
7551: LD_INT 2
7553: PUSH
7554: LD_INT 28
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: LIST
7561: LIST
7562: PUSH
7563: LD_INT 14
7565: PUSH
7566: LD_INT 1
7568: PUSH
7569: LD_INT 2
7571: PUSH
7572: LD_INT 28
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: LIST
7579: LIST
7580: PUSH
7581: LD_INT 14
7583: PUSH
7584: LD_INT 1
7586: PUSH
7587: LD_INT 2
7589: PUSH
7590: LD_INT 28
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: PUSH
7599: LD_INT 14
7601: PUSH
7602: LD_INT 1
7604: PUSH
7605: LD_INT 2
7607: PUSH
7608: LD_INT 28
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: LIST
7615: LIST
7616: PUSH
7617: LD_INT 14
7619: PUSH
7620: LD_INT 1
7622: PUSH
7623: LD_INT 2
7625: PUSH
7626: LD_INT 26
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: LIST
7642: PPUSH
7643: CALL 45082 0 2
// end else
7647: GO 7856
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7649: LD_INT 3
7651: PPUSH
7652: LD_INT 14
7654: PUSH
7655: LD_INT 1
7657: PUSH
7658: LD_INT 2
7660: PUSH
7661: LD_INT 27
7663: PUSH
7664: LD_INT 26
7666: PUSH
7667: LD_INT 26
7669: PUSH
7670: LD_INT 28
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: LIST
7677: LIST
7678: PUSH
7679: LD_OWVAR 67
7683: ARRAY
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: LIST
7690: PUSH
7691: LD_INT 14
7693: PUSH
7694: LD_INT 1
7696: PUSH
7697: LD_INT 2
7699: PUSH
7700: LD_INT 27
7702: PUSH
7703: LD_INT 26
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 26
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_OWVAR 67
7722: ARRAY
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: PUSH
7730: LD_INT 14
7732: PUSH
7733: LD_INT 1
7735: PUSH
7736: LD_INT 2
7738: PUSH
7739: LD_INT 26
7741: PUSH
7742: LD_INT 26
7744: PUSH
7745: LD_INT 29
7747: PUSH
7748: LD_INT 29
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: PUSH
7757: LD_OWVAR 67
7761: ARRAY
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: LIST
7767: LIST
7768: PUSH
7769: LD_INT 13
7771: PUSH
7772: LD_INT 1
7774: PUSH
7775: LD_INT 2
7777: PUSH
7778: LD_INT 26
7780: PUSH
7781: LD_INT 29
7783: PUSH
7784: LD_INT 29
7786: PUSH
7787: LD_INT 29
7789: PUSH
7790: EMPTY
7791: LIST
7792: LIST
7793: LIST
7794: LIST
7795: PUSH
7796: LD_OWVAR 67
7800: ARRAY
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PUSH
7808: LD_INT 13
7810: PUSH
7811: LD_INT 1
7813: PUSH
7814: LD_INT 2
7816: PUSH
7817: LD_INT 29
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 14
7828: PUSH
7829: LD_INT 1
7831: PUSH
7832: LD_INT 2
7834: PUSH
7835: LD_INT 26
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: LIST
7842: LIST
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: LIST
7851: PPUSH
7852: CALL 45082 0 2
// end ; repeat wait ( 0 0$1 ) ;
7856: LD_INT 35
7858: PPUSH
7859: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7863: LD_INT 3
7865: PPUSH
7866: LD_INT 1
7868: PPUSH
7869: CALL 46500 0 2
7873: PUSH
7874: LD_INT 6
7876: GREATEREQUAL
7877: IFFALSE 7856
// wait ( 0 0$30 ) ;
7879: LD_INT 1050
7881: PPUSH
7882: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7886: LD_ADDR_VAR 0 2
7890: PUSH
7891: LD_INT 3
7893: PPUSH
7894: LD_INT 1
7896: PPUSH
7897: CALL 46500 0 2
7901: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7902: LD_ADDR_EXP 112
7906: PUSH
7907: LD_EXP 112
7911: PPUSH
7912: LD_INT 3
7914: PPUSH
7915: LD_EXP 112
7919: PUSH
7920: LD_INT 3
7922: ARRAY
7923: PUSH
7924: LD_VAR 0 2
7928: DIFF
7929: PPUSH
7930: CALL_OW 1
7934: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7935: LD_ADDR_VAR 0 3
7939: PUSH
7940: LD_INT 0
7942: PPUSH
7943: LD_INT 2
7945: PPUSH
7946: CALL_OW 12
7950: ST_TO_ADDR
// if target then
7951: LD_VAR 0 3
7955: IFFALSE 8083
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7957: LD_ADDR_VAR 0 2
7961: PUSH
7962: LD_VAR 0 2
7966: PPUSH
7967: LD_INT 24
7969: PUSH
7970: LD_INT 250
7972: PUSH
7973: EMPTY
7974: LIST
7975: LIST
7976: PPUSH
7977: CALL_OW 72
7981: ST_TO_ADDR
// for i in tmp do
7982: LD_ADDR_VAR 0 1
7986: PUSH
7987: LD_VAR 0 2
7991: PUSH
7992: FOR_IN
7993: IFFALSE 8033
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7995: LD_VAR 0 1
7999: PPUSH
8000: LD_INT 89
8002: PPUSH
8003: LD_INT 71
8005: PPUSH
8006: CALL_OW 297
8010: PUSH
8011: LD_INT 9
8013: GREATER
8014: IFFALSE 8031
// ComMoveXY ( i , 89 , 71 ) ;
8016: LD_VAR 0 1
8020: PPUSH
8021: LD_INT 89
8023: PPUSH
8024: LD_INT 71
8026: PPUSH
8027: CALL_OW 111
8031: GO 7992
8033: POP
8034: POP
// wait ( 0 0$1 ) ;
8035: LD_INT 35
8037: PPUSH
8038: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8042: LD_VAR 0 2
8046: PPUSH
8047: LD_INT 92
8049: PUSH
8050: LD_INT 89
8052: PUSH
8053: LD_INT 71
8055: PUSH
8056: LD_INT 9
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: LIST
8063: LIST
8064: PPUSH
8065: CALL_OW 72
8069: PUSH
8070: LD_VAR 0 2
8074: PUSH
8075: LD_INT 1
8077: MINUS
8078: GREATEREQUAL
8079: IFFALSE 7957
// end else
8081: GO 8207
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8083: LD_ADDR_VAR 0 2
8087: PUSH
8088: LD_VAR 0 2
8092: PPUSH
8093: LD_INT 24
8095: PUSH
8096: LD_INT 250
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: PPUSH
8103: CALL_OW 72
8107: ST_TO_ADDR
// for i in tmp do
8108: LD_ADDR_VAR 0 1
8112: PUSH
8113: LD_VAR 0 2
8117: PUSH
8118: FOR_IN
8119: IFFALSE 8159
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8121: LD_VAR 0 1
8125: PPUSH
8126: LD_INT 147
8128: PPUSH
8129: LD_INT 4
8131: PPUSH
8132: CALL_OW 297
8136: PUSH
8137: LD_INT 9
8139: GREATER
8140: IFFALSE 8157
// ComMoveXY ( i , 147 , 4 ) ;
8142: LD_VAR 0 1
8146: PPUSH
8147: LD_INT 147
8149: PPUSH
8150: LD_INT 4
8152: PPUSH
8153: CALL_OW 111
8157: GO 8118
8159: POP
8160: POP
// wait ( 0 0$1 ) ;
8161: LD_INT 35
8163: PPUSH
8164: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8168: LD_VAR 0 2
8172: PPUSH
8173: LD_INT 92
8175: PUSH
8176: LD_INT 147
8178: PUSH
8179: LD_INT 4
8181: PUSH
8182: LD_INT 9
8184: PUSH
8185: EMPTY
8186: LIST
8187: LIST
8188: LIST
8189: LIST
8190: PPUSH
8191: CALL_OW 72
8195: PUSH
8196: LD_VAR 0 2
8200: PUSH
8201: LD_INT 1
8203: MINUS
8204: GREATEREQUAL
8205: IFFALSE 8083
// end ; repeat wait ( 0 0$1 ) ;
8207: LD_INT 35
8209: PPUSH
8210: CALL_OW 67
// for i in tmp do
8214: LD_ADDR_VAR 0 1
8218: PUSH
8219: LD_VAR 0 2
8223: PUSH
8224: FOR_IN
8225: IFFALSE 8307
// begin if GetLives ( i ) > 251 then
8227: LD_VAR 0 1
8231: PPUSH
8232: CALL_OW 256
8236: PUSH
8237: LD_INT 251
8239: GREATER
8240: IFFALSE 8278
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8242: LD_VAR 0 1
8246: PPUSH
8247: LD_INT 81
8249: PUSH
8250: LD_INT 8
8252: PUSH
8253: EMPTY
8254: LIST
8255: LIST
8256: PPUSH
8257: CALL_OW 69
8261: PPUSH
8262: LD_VAR 0 1
8266: PPUSH
8267: CALL_OW 74
8271: PPUSH
8272: CALL_OW 115
8276: GO 8305
// if IsDead ( i ) then
8278: LD_VAR 0 1
8282: PPUSH
8283: CALL_OW 301
8287: IFFALSE 8305
// tmp := tmp diff i ;
8289: LD_ADDR_VAR 0 2
8293: PUSH
8294: LD_VAR 0 2
8298: PUSH
8299: LD_VAR 0 1
8303: DIFF
8304: ST_TO_ADDR
// end ;
8305: GO 8224
8307: POP
8308: POP
// until not tmp ;
8309: LD_VAR 0 2
8313: NOT
8314: IFFALSE 8207
// end ;
8316: PPOPN 3
8318: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8319: LD_EXP 55
8323: PPUSH
8324: CALL_OW 302
8328: PUSH
8329: LD_EXP 3
8333: NOT
8334: AND
8335: IFFALSE 8344
8337: GO 8339
8339: DISABLE
// BuildKozlovBomb ;
8340: CALL 7315 0 0
8344: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8345: LD_INT 22
8347: PUSH
8348: LD_INT 8
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PUSH
8355: LD_INT 34
8357: PUSH
8358: LD_INT 48
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: PUSH
8365: EMPTY
8366: LIST
8367: LIST
8368: PPUSH
8369: CALL_OW 69
8373: IFFALSE 8421
8375: GO 8377
8377: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8378: LD_INT 22
8380: PUSH
8381: LD_INT 8
8383: PUSH
8384: EMPTY
8385: LIST
8386: LIST
8387: PUSH
8388: LD_INT 34
8390: PUSH
8391: LD_INT 48
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: PUSH
8398: EMPTY
8399: LIST
8400: LIST
8401: PPUSH
8402: CALL_OW 69
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PPUSH
8411: LD_INT 173
8413: PPUSH
8414: LD_INT 96
8416: PPUSH
8417: CALL_OW 116
// end ; end_of_file
8421: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8422: LD_INT 0
8424: PPUSH
8425: PPUSH
8426: PPUSH
8427: PPUSH
8428: PPUSH
8429: PPUSH
8430: PPUSH
8431: PPUSH
8432: PPUSH
// side := 3 ;
8433: LD_ADDR_VAR 0 6
8437: PUSH
8438: LD_INT 3
8440: ST_TO_ADDR
// InitHc ;
8441: CALL_OW 19
// uc_side := side ;
8445: LD_ADDR_OWVAR 20
8449: PUSH
8450: LD_VAR 0 6
8454: ST_TO_ADDR
// uc_nation := 3 ;
8455: LD_ADDR_OWVAR 21
8459: PUSH
8460: LD_INT 3
8462: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8463: LD_ADDR_VAR 0 2
8467: PUSH
8468: LD_INT 22
8470: PUSH
8471: LD_VAR 0 6
8475: PUSH
8476: EMPTY
8477: LIST
8478: LIST
8479: PUSH
8480: LD_INT 21
8482: PUSH
8483: LD_INT 3
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: PUSH
8490: EMPTY
8491: LIST
8492: LIST
8493: PPUSH
8494: CALL_OW 69
8498: PUSH
8499: FOR_IN
8500: IFFALSE 8516
// SetBLevel ( i , 10 ) ;
8502: LD_VAR 0 2
8506: PPUSH
8507: LD_INT 10
8509: PPUSH
8510: CALL_OW 241
8514: GO 8499
8516: POP
8517: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8518: LD_ADDR_VAR 0 9
8522: PUSH
8523: LD_INT 22
8525: PUSH
8526: LD_VAR 0 6
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PUSH
8535: LD_INT 30
8537: PUSH
8538: LD_INT 34
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: PPUSH
8549: CALL_OW 69
8553: ST_TO_ADDR
// if teleport then
8554: LD_VAR 0 9
8558: IFFALSE 8579
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8560: LD_VAR 0 9
8564: PUSH
8565: LD_INT 1
8567: ARRAY
8568: PPUSH
8569: LD_INT 123
8571: PPUSH
8572: LD_INT 122
8574: PPUSH
8575: CALL_OW 243
// hc_importance := 0 ;
8579: LD_ADDR_OWVAR 32
8583: PUSH
8584: LD_INT 0
8586: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8587: LD_ADDR_EXP 56
8591: PUSH
8592: LD_STRING Platonov
8594: PPUSH
8595: CALL_OW 25
8599: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8600: LD_ADDR_EXP 57
8604: PUSH
8605: LD_STRING Yakotich
8607: PPUSH
8608: CALL_OW 25
8612: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8613: LD_ADDR_EXP 58
8617: PUSH
8618: LD_STRING Gleb
8620: PPUSH
8621: CALL_OW 25
8625: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8626: LD_STRING 03_Cornel
8628: PPUSH
8629: CALL_OW 28
8633: IFFALSE 8681
// begin Bierezov := NewCharacter ( Mikhail ) ;
8635: LD_ADDR_EXP 59
8639: PUSH
8640: LD_STRING Mikhail
8642: PPUSH
8643: CALL_OW 25
8647: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8648: LD_EXP 59
8652: PPUSH
8653: LD_INT 197
8655: PPUSH
8656: LD_INT 111
8658: PPUSH
8659: LD_INT 9
8661: PPUSH
8662: LD_INT 0
8664: PPUSH
8665: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8669: LD_EXP 59
8673: PPUSH
8674: LD_INT 3
8676: PPUSH
8677: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8681: LD_EXP 56
8685: PPUSH
8686: LD_INT 126
8688: PPUSH
8689: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8693: LD_EXP 57
8697: PPUSH
8698: LD_INT 197
8700: PPUSH
8701: LD_INT 111
8703: PPUSH
8704: LD_INT 9
8706: PPUSH
8707: LD_INT 0
8709: PPUSH
8710: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8714: LD_EXP 58
8718: PPUSH
8719: LD_INT 197
8721: PPUSH
8722: LD_INT 111
8724: PPUSH
8725: LD_INT 9
8727: PPUSH
8728: LD_INT 0
8730: PPUSH
8731: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8735: LD_ADDR_VAR 0 5
8739: PUSH
8740: LD_INT 126
8742: PPUSH
8743: LD_INT 2
8745: PPUSH
8746: LD_STRING zhukov
8748: PPUSH
8749: LD_INT 9
8751: PUSH
8752: LD_INT 10
8754: PUSH
8755: LD_INT 10
8757: PUSH
8758: LD_INT 10
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: LIST
8765: LIST
8766: PUSH
8767: LD_OWVAR 67
8771: ARRAY
8772: PPUSH
8773: LD_INT 9000
8775: PUSH
8776: LD_INT 1000
8778: PUSH
8779: LD_INT 300
8781: PUSH
8782: EMPTY
8783: LIST
8784: LIST
8785: LIST
8786: PPUSH
8787: LD_INT 21
8789: PUSH
8790: LD_INT 8
8792: PUSH
8793: LD_INT 13
8795: PUSH
8796: LD_INT 8
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: LIST
8803: LIST
8804: PPUSH
8805: CALL 59798 0 6
8809: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8810: LD_ADDR_VAR 0 4
8814: PUSH
8815: LD_INT 267
8817: PPUSH
8818: CALL_OW 274
8822: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8823: LD_VAR 0 4
8827: PPUSH
8828: LD_INT 1
8830: PPUSH
8831: LD_INT 5000
8833: PPUSH
8834: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8838: LD_VAR 0 4
8842: PPUSH
8843: LD_INT 2
8845: PPUSH
8846: LD_INT 200
8848: PPUSH
8849: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_INT 3
8860: PPUSH
8861: LD_INT 200
8863: PPUSH
8864: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8868: LD_ADDR_EXP 93
8872: PUSH
8873: LD_EXP 93
8877: PPUSH
8878: LD_INT 2
8880: PPUSH
8881: LD_VAR 0 5
8885: PUSH
8886: LD_INT 22
8888: PUSH
8889: LD_VAR 0 6
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: PUSH
8898: LD_INT 3
8900: PUSH
8901: LD_INT 21
8903: PUSH
8904: LD_INT 2
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PPUSH
8919: CALL_OW 69
8923: UNION
8924: PUSH
8925: LD_EXP 56
8929: DIFF
8930: PPUSH
8931: CALL_OW 1
8935: ST_TO_ADDR
// behemoths := [ ] ;
8936: LD_ADDR_EXP 60
8940: PUSH
8941: EMPTY
8942: ST_TO_ADDR
// behemothBuilders := [ ] ;
8943: LD_ADDR_EXP 61
8947: PUSH
8948: EMPTY
8949: ST_TO_ADDR
// j := 3 ;
8950: LD_ADDR_VAR 0 3
8954: PUSH
8955: LD_INT 3
8957: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8958: LD_ADDR_VAR 0 2
8962: PUSH
8963: LD_INT 22
8965: PUSH
8966: LD_INT 3
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 25
8975: PUSH
8976: LD_INT 3
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: PPUSH
8987: CALL_OW 69
8991: PUSH
8992: FOR_IN
8993: IFFALSE 9043
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8995: LD_ADDR_EXP 61
8999: PUSH
9000: LD_EXP 61
9004: PPUSH
9005: LD_VAR 0 2
9009: PPUSH
9010: CALL 88225 0 2
9014: ST_TO_ADDR
// j := j - 1 ;
9015: LD_ADDR_VAR 0 3
9019: PUSH
9020: LD_VAR 0 3
9024: PUSH
9025: LD_INT 1
9027: MINUS
9028: ST_TO_ADDR
// if j = 0 then
9029: LD_VAR 0 3
9033: PUSH
9034: LD_INT 0
9036: EQUAL
9037: IFFALSE 9041
// break ;
9039: GO 9043
// end ;
9041: GO 8992
9043: POP
9044: POP
// end ;
9045: LD_VAR 0 1
9049: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9050: LD_INT 0
9052: PPUSH
9053: PPUSH
9054: PPUSH
9055: PPUSH
9056: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9057: LD_ADDR_VAR 0 4
9061: PUSH
9062: LD_INT 209
9064: PUSH
9065: LD_INT 149
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: LD_INT 219
9074: PUSH
9075: LD_INT 154
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PUSH
9082: LD_INT 223
9084: PUSH
9085: LD_INT 149
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 232
9094: PUSH
9095: LD_INT 155
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: EMPTY
9103: LIST
9104: LIST
9105: LIST
9106: LIST
9107: ST_TO_ADDR
// if not behemothBuilders then
9108: LD_EXP 61
9112: NOT
9113: IFFALSE 9117
// exit ;
9115: GO 9221
// j := 1 ;
9117: LD_ADDR_VAR 0 3
9121: PUSH
9122: LD_INT 1
9124: ST_TO_ADDR
// for i in behemothBuilders do
9125: LD_ADDR_VAR 0 2
9129: PUSH
9130: LD_EXP 61
9134: PUSH
9135: FOR_IN
9136: IFFALSE 9219
// begin if IsInUnit ( i ) then
9138: LD_VAR 0 2
9142: PPUSH
9143: CALL_OW 310
9147: IFFALSE 9158
// ComExitBuilding ( i ) ;
9149: LD_VAR 0 2
9153: PPUSH
9154: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9158: LD_VAR 0 2
9162: PPUSH
9163: LD_INT 37
9165: PPUSH
9166: LD_VAR 0 4
9170: PUSH
9171: LD_VAR 0 3
9175: ARRAY
9176: PUSH
9177: LD_INT 1
9179: ARRAY
9180: PPUSH
9181: LD_VAR 0 4
9185: PUSH
9186: LD_VAR 0 3
9190: ARRAY
9191: PUSH
9192: LD_INT 2
9194: ARRAY
9195: PPUSH
9196: LD_INT 0
9198: PPUSH
9199: CALL_OW 230
// j := j + 1 ;
9203: LD_ADDR_VAR 0 3
9207: PUSH
9208: LD_VAR 0 3
9212: PUSH
9213: LD_INT 1
9215: PLUS
9216: ST_TO_ADDR
// end ;
9217: GO 9135
9219: POP
9220: POP
// end ;
9221: LD_VAR 0 1
9225: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9226: LD_INT 3
9228: PPUSH
9229: CALL 88286 0 1
9233: PUSH
9234: LD_INT 22
9236: PUSH
9237: LD_INT 3
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: PUSH
9244: LD_INT 30
9246: PUSH
9247: LD_INT 37
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PPUSH
9258: CALL_OW 69
9262: NOT
9263: AND
9264: IFFALSE 9450
9266: GO 9268
9268: DISABLE
9269: LD_INT 0
9271: PPUSH
9272: PPUSH
// begin enable ;
9273: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9274: LD_ADDR_VAR 0 2
9278: PUSH
9279: LD_INT 3
9281: PPUSH
9282: CALL 88286 0 1
9286: ST_TO_ADDR
// for i in tmp do
9287: LD_ADDR_VAR 0 1
9291: PUSH
9292: LD_VAR 0 2
9296: PUSH
9297: FOR_IN
9298: IFFALSE 9448
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9300: LD_VAR 0 1
9304: PPUSH
9305: LD_INT 7
9307: PPUSH
9308: CALL_OW 308
9312: PUSH
9313: LD_VAR 0 1
9317: PPUSH
9318: CALL_OW 110
9322: PUSH
9323: LD_INT 2
9325: EQUAL
9326: NOT
9327: AND
9328: IFFALSE 9342
// SetTag ( i , 2 ) ;
9330: LD_VAR 0 1
9334: PPUSH
9335: LD_INT 2
9337: PPUSH
9338: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9342: LD_INT 81
9344: PUSH
9345: LD_INT 3
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PUSH
9352: LD_INT 91
9354: PUSH
9355: LD_VAR 0 1
9359: PUSH
9360: LD_INT 12
9362: PUSH
9363: EMPTY
9364: LIST
9365: LIST
9366: LIST
9367: PUSH
9368: EMPTY
9369: LIST
9370: LIST
9371: PPUSH
9372: CALL_OW 69
9376: NOT
9377: PUSH
9378: LD_VAR 0 1
9382: PPUSH
9383: CALL_OW 110
9387: PUSH
9388: LD_INT 2
9390: EQUAL
9391: NOT
9392: AND
9393: IFFALSE 9412
// ComAgressiveMove ( i , 64 , 93 ) else
9395: LD_VAR 0 1
9399: PPUSH
9400: LD_INT 64
9402: PPUSH
9403: LD_INT 93
9405: PPUSH
9406: CALL_OW 114
9410: GO 9446
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9412: LD_VAR 0 1
9416: PPUSH
9417: LD_INT 81
9419: PUSH
9420: LD_INT 3
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: PPUSH
9427: CALL_OW 69
9431: PPUSH
9432: LD_VAR 0 1
9436: PPUSH
9437: CALL_OW 74
9441: PPUSH
9442: CALL_OW 115
// end ;
9446: GO 9297
9448: POP
9449: POP
// end ;
9450: PPOPN 2
9452: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9453: LD_EXP 2
9457: NOT
9458: PUSH
9459: LD_INT 2
9461: PPUSH
9462: LD_INT 1
9464: PPUSH
9465: CALL 46500 0 2
9469: NOT
9470: AND
9471: IFFALSE 10395
9473: GO 9475
9475: DISABLE
9476: LD_INT 0
9478: PPUSH
9479: PPUSH
9480: PPUSH
9481: PPUSH
// begin enable ;
9482: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9483: LD_INT 22
9485: PUSH
9486: LD_INT 3
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: LD_INT 30
9495: PUSH
9496: LD_INT 3
9498: PUSH
9499: EMPTY
9500: LIST
9501: LIST
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: PPUSH
9507: CALL_OW 69
9511: NOT
9512: IFFALSE 9516
// exit ;
9514: GO 10395
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9516: LD_ADDR_VAR 0 4
9520: PUSH
9521: LD_INT 22
9523: PUSH
9524: LD_INT 3
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: PUSH
9531: LD_INT 30
9533: PUSH
9534: LD_INT 34
9536: PUSH
9537: EMPTY
9538: LIST
9539: LIST
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: PPUSH
9545: CALL_OW 69
9549: ST_TO_ADDR
// if Prob ( 40 ) then
9550: LD_INT 40
9552: PPUSH
9553: CALL_OW 13
9557: IFFALSE 9684
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9559: LD_INT 2
9561: PPUSH
9562: LD_INT 22
9564: PUSH
9565: LD_INT 3
9567: PUSH
9568: LD_INT 3
9570: PUSH
9571: LD_INT 49
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: LIST
9578: LIST
9579: PUSH
9580: LD_INT 22
9582: PUSH
9583: LD_INT 3
9585: PUSH
9586: LD_INT 3
9588: PUSH
9589: LD_INT 49
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: LIST
9596: LIST
9597: PUSH
9598: LD_INT 22
9600: PUSH
9601: LD_INT 3
9603: PUSH
9604: LD_INT 3
9606: PUSH
9607: LD_INT 49
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: PUSH
9616: LD_INT 24
9618: PUSH
9619: LD_INT 3
9621: PUSH
9622: LD_INT 3
9624: PUSH
9625: LD_INT 46
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: LIST
9632: LIST
9633: PUSH
9634: LD_INT 24
9636: PUSH
9637: LD_INT 3
9639: PUSH
9640: LD_INT 3
9642: PUSH
9643: LD_INT 46
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: PUSH
9652: LD_INT 24
9654: PUSH
9655: LD_INT 3
9657: PUSH
9658: LD_INT 3
9660: PUSH
9661: LD_INT 46
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: LIST
9668: LIST
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL 45082 0 2
// end else
9682: GO 9807
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9684: LD_INT 2
9686: PPUSH
9687: LD_INT 24
9689: PUSH
9690: LD_INT 3
9692: PUSH
9693: LD_INT 3
9695: PUSH
9696: LD_INT 47
9698: PUSH
9699: EMPTY
9700: LIST
9701: LIST
9702: LIST
9703: LIST
9704: PUSH
9705: LD_INT 24
9707: PUSH
9708: LD_INT 3
9710: PUSH
9711: LD_INT 3
9713: PUSH
9714: LD_INT 47
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: LIST
9721: LIST
9722: PUSH
9723: LD_INT 24
9725: PUSH
9726: LD_INT 3
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 47
9734: PUSH
9735: EMPTY
9736: LIST
9737: LIST
9738: LIST
9739: LIST
9740: PUSH
9741: LD_INT 24
9743: PUSH
9744: LD_INT 3
9746: PUSH
9747: LD_INT 3
9749: PUSH
9750: LD_INT 46
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: LIST
9757: LIST
9758: PUSH
9759: LD_INT 24
9761: PUSH
9762: LD_INT 3
9764: PUSH
9765: LD_INT 3
9767: PUSH
9768: LD_INT 46
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: LIST
9776: PUSH
9777: LD_INT 24
9779: PUSH
9780: LD_INT 3
9782: PUSH
9783: LD_INT 3
9785: PUSH
9786: LD_INT 46
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: LIST
9793: LIST
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: PPUSH
9803: CALL 45082 0 2
// end ; if Difficulty > 1 then
9807: LD_OWVAR 67
9811: PUSH
9812: LD_INT 1
9814: GREATER
9815: IFFALSE 9845
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9817: LD_INT 2
9819: PPUSH
9820: LD_INT 24
9822: PUSH
9823: LD_INT 3
9825: PUSH
9826: LD_INT 3
9828: PUSH
9829: LD_INT 47
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: PUSH
9838: EMPTY
9839: LIST
9840: PPUSH
9841: CALL 45082 0 2
// repeat wait ( 0 0$1 ) ;
9845: LD_INT 35
9847: PPUSH
9848: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
9852: LD_INT 2
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL 46500 0 2
9862: PUSH
9863: LD_INT 6
9865: PUSH
9866: LD_INT 7
9868: PUSH
9869: LD_INT 7
9871: PUSH
9872: LD_INT 7
9874: PUSH
9875: EMPTY
9876: LIST
9877: LIST
9878: LIST
9879: LIST
9880: PUSH
9881: LD_OWVAR 67
9885: ARRAY
9886: GREATEREQUAL
9887: IFFALSE 9845
// wait ( 0 0$30 ) ;
9889: LD_INT 1050
9891: PPUSH
9892: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9896: LD_ADDR_VAR 0 2
9900: PUSH
9901: LD_INT 2
9903: PPUSH
9904: LD_INT 1
9906: PPUSH
9907: CALL 46500 0 2
9911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9912: LD_ADDR_EXP 112
9916: PUSH
9917: LD_EXP 112
9921: PPUSH
9922: LD_INT 2
9924: PPUSH
9925: LD_EXP 112
9929: PUSH
9930: LD_INT 2
9932: ARRAY
9933: PUSH
9934: LD_VAR 0 2
9938: DIFF
9939: PPUSH
9940: CALL_OW 1
9944: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9945: LD_ADDR_VAR 0 3
9949: PUSH
9950: LD_INT 0
9952: PPUSH
9953: LD_INT 1
9955: PPUSH
9956: CALL_OW 12
9960: ST_TO_ADDR
// if target then
9961: LD_VAR 0 3
9965: IFFALSE 10093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9967: LD_ADDR_VAR 0 2
9971: PUSH
9972: LD_VAR 0 2
9976: PPUSH
9977: LD_INT 24
9979: PUSH
9980: LD_INT 250
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: PPUSH
9987: CALL_OW 72
9991: ST_TO_ADDR
// for i in tmp do
9992: LD_ADDR_VAR 0 1
9996: PUSH
9997: LD_VAR 0 2
10001: PUSH
10002: FOR_IN
10003: IFFALSE 10043
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10005: LD_VAR 0 1
10009: PPUSH
10010: LD_INT 139
10012: PPUSH
10013: LD_INT 89
10015: PPUSH
10016: CALL_OW 297
10020: PUSH
10021: LD_INT 9
10023: GREATER
10024: IFFALSE 10041
// ComMoveXY ( i , 139 , 89 ) ;
10026: LD_VAR 0 1
10030: PPUSH
10031: LD_INT 139
10033: PPUSH
10034: LD_INT 89
10036: PPUSH
10037: CALL_OW 111
10041: GO 10002
10043: POP
10044: POP
// wait ( 0 0$1 ) ;
10045: LD_INT 35
10047: PPUSH
10048: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10052: LD_VAR 0 2
10056: PPUSH
10057: LD_INT 92
10059: PUSH
10060: LD_INT 139
10062: PUSH
10063: LD_INT 89
10065: PUSH
10066: LD_INT 9
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: PPUSH
10075: CALL_OW 72
10079: PUSH
10080: LD_VAR 0 2
10084: PUSH
10085: LD_INT 1
10087: MINUS
10088: GREATEREQUAL
10089: IFFALSE 9967
// end else
10091: GO 10235
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10093: LD_VAR 0 2
10097: PPUSH
10098: LD_VAR 0 4
10102: PUSH
10103: LD_INT 1
10105: ARRAY
10106: PPUSH
10107: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10111: LD_ADDR_VAR 0 2
10115: PUSH
10116: LD_VAR 0 2
10120: PPUSH
10121: LD_INT 24
10123: PUSH
10124: LD_INT 250
10126: PUSH
10127: EMPTY
10128: LIST
10129: LIST
10130: PPUSH
10131: CALL_OW 72
10135: ST_TO_ADDR
// for i in tmp do
10136: LD_ADDR_VAR 0 1
10140: PUSH
10141: LD_VAR 0 2
10145: PUSH
10146: FOR_IN
10147: IFFALSE 10187
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10149: LD_VAR 0 1
10153: PPUSH
10154: LD_INT 124
10156: PPUSH
10157: LD_INT 139
10159: PPUSH
10160: CALL_OW 297
10164: PUSH
10165: LD_INT 9
10167: GREATER
10168: IFFALSE 10185
// ComMoveXY ( i , 124 , 139 ) ;
10170: LD_VAR 0 1
10174: PPUSH
10175: LD_INT 124
10177: PPUSH
10178: LD_INT 139
10180: PPUSH
10181: CALL_OW 111
10185: GO 10146
10187: POP
10188: POP
// wait ( 0 0$1 ) ;
10189: LD_INT 35
10191: PPUSH
10192: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10196: LD_VAR 0 2
10200: PPUSH
10201: LD_INT 92
10203: PUSH
10204: LD_INT 124
10206: PUSH
10207: LD_INT 139
10209: PUSH
10210: LD_INT 9
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL_OW 72
10223: PUSH
10224: LD_VAR 0 2
10228: PUSH
10229: LD_INT 1
10231: MINUS
10232: GREATEREQUAL
10233: IFFALSE 10111
// end ; repeat wait ( 0 0$1 ) ;
10235: LD_INT 35
10237: PPUSH
10238: CALL_OW 67
// for i in tmp do
10242: LD_ADDR_VAR 0 1
10246: PUSH
10247: LD_VAR 0 2
10251: PUSH
10252: FOR_IN
10253: IFFALSE 10386
// begin if GetLives ( i ) > 251 then
10255: LD_VAR 0 1
10259: PPUSH
10260: CALL_OW 256
10264: PUSH
10265: LD_INT 251
10267: GREATER
10268: IFFALSE 10357
// begin if GetWeapon ( i ) = ru_time_lapser then
10270: LD_VAR 0 1
10274: PPUSH
10275: CALL_OW 264
10279: PUSH
10280: LD_INT 49
10282: EQUAL
10283: IFFALSE 10321
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10285: LD_VAR 0 1
10289: PPUSH
10290: LD_INT 81
10292: PUSH
10293: LD_INT 3
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PPUSH
10300: CALL_OW 69
10304: PPUSH
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 74
10314: PPUSH
10315: CALL_OW 112
10319: GO 10355
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10321: LD_VAR 0 1
10325: PPUSH
10326: LD_INT 81
10328: PUSH
10329: LD_INT 3
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: PPUSH
10336: CALL_OW 69
10340: PPUSH
10341: LD_VAR 0 1
10345: PPUSH
10346: CALL_OW 74
10350: PPUSH
10351: CALL_OW 115
// end else
10355: GO 10384
// if IsDead ( i ) then
10357: LD_VAR 0 1
10361: PPUSH
10362: CALL_OW 301
10366: IFFALSE 10384
// tmp := tmp diff i ;
10368: LD_ADDR_VAR 0 2
10372: PUSH
10373: LD_VAR 0 2
10377: PUSH
10378: LD_VAR 0 1
10382: DIFF
10383: ST_TO_ADDR
// end ;
10384: GO 10252
10386: POP
10387: POP
// until not tmp ;
10388: LD_VAR 0 2
10392: NOT
10393: IFFALSE 10235
// end ;
10395: PPOPN 4
10397: END
// every 30 30$00 trigger not russianDestroyed do
10398: LD_EXP 2
10402: NOT
10403: IFFALSE 10472
10405: GO 10407
10407: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10408: LD_INT 105000
10410: PUSH
10411: LD_INT 84000
10413: PUSH
10414: LD_INT 63000
10416: PUSH
10417: LD_INT 52500
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_OWVAR 67
10430: ARRAY
10431: PPUSH
10432: CALL_OW 67
// if russianDestroyed then
10436: LD_EXP 2
10440: IFFALSE 10444
// exit ;
10442: GO 10472
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10444: LD_INT 2
10446: PPUSH
10447: LD_INT 23
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 1
10455: PUSH
10456: LD_INT 48
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: PUSH
10465: EMPTY
10466: LIST
10467: PPUSH
10468: CALL 45082 0 2
// end ; end_of_file
10472: END
// export function CustomEvent ( event ) ; begin
10473: LD_INT 0
10475: PPUSH
// end ;
10476: LD_VAR 0 2
10480: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10481: LD_VAR 0 2
10485: PPUSH
10486: LD_VAR 0 3
10490: PPUSH
10491: LD_INT 15
10493: PPUSH
10494: CALL_OW 309
10498: IFFALSE 10507
// YouLost ( MothContaminate ) ;
10500: LD_STRING MothContaminate
10502: PPUSH
10503: CALL_OW 104
// end ;
10507: PPOPN 3
10509: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10510: LD_VAR 0 2
10514: PPUSH
10515: LD_VAR 0 3
10519: PPUSH
10520: LD_INT 15
10522: PPUSH
10523: CALL_OW 309
10527: IFFALSE 10543
// begin wait ( 0 0$6 ) ;
10529: LD_INT 210
10531: PPUSH
10532: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10536: LD_STRING MothContaminateBomb
10538: PPUSH
10539: CALL_OW 104
// end ; end ;
10543: PPOPN 3
10545: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10546: LD_VAR 0 1
10550: PUSH
10551: LD_EXP 17
10555: EQUAL
10556: IFFALSE 10567
// begin YouLost ( JMM ) ;
10558: LD_STRING JMM
10560: PPUSH
10561: CALL_OW 104
// exit ;
10565: GO 10666
// end ; if un = Powell then
10567: LD_VAR 0 1
10571: PUSH
10572: LD_EXP 52
10576: EQUAL
10577: IFFALSE 10587
// americanDestroyed := true ;
10579: LD_ADDR_EXP 4
10583: PUSH
10584: LD_INT 1
10586: ST_TO_ADDR
// if un = Platonov then
10587: LD_VAR 0 1
10591: PUSH
10592: LD_EXP 56
10596: EQUAL
10597: IFFALSE 10607
// russianDestroyed := true ;
10599: LD_ADDR_EXP 2
10603: PUSH
10604: LD_INT 1
10606: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10607: LD_VAR 0 1
10611: PUSH
10612: LD_INT 22
10614: PUSH
10615: LD_INT 7
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: PUSH
10622: LD_INT 21
10624: PUSH
10625: LD_INT 2
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PUSH
10632: EMPTY
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10657
// vehicleLostCounter := vehicleLostCounter + 1 ;
10643: LD_ADDR_EXP 15
10647: PUSH
10648: LD_EXP 15
10652: PUSH
10653: LD_INT 1
10655: PLUS
10656: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 48502 0 1
// end ;
10666: PPOPN 1
10668: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10669: LD_VAR 0 1
10673: PPUSH
10674: LD_VAR 0 2
10678: PPUSH
10679: CALL 50836 0 2
// end ;
10683: PPOPN 2
10685: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10686: LD_VAR 0 1
10690: PPUSH
10691: CALL 49904 0 1
// end ;
10695: PPOPN 1
10697: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10698: LD_VAR 0 1
10702: PUSH
10703: LD_INT 22
10705: PUSH
10706: LD_INT 8
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 30
10715: PUSH
10716: LD_INT 2
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 23
10725: PUSH
10726: LD_INT 3
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 69
10742: IN
10743: IFFALSE 10770
// begin ComUpgrade ( building ) ;
10745: LD_VAR 0 1
10749: PPUSH
10750: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10754: LD_EXP 55
10758: PPUSH
10759: LD_VAR 0 1
10763: PPUSH
10764: CALL 59337 0 2
// exit ;
10768: GO 10779
// end ; MCE_BuildingComplete ( building ) ;
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL 50145 0 1
// end ;
10779: PPOPN 1
10781: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10782: LD_VAR 0 1
10786: PPUSH
10787: LD_VAR 0 2
10791: PPUSH
10792: CALL 48198 0 2
// end ;
10796: PPOPN 2
10798: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10799: LD_VAR 0 1
10803: PPUSH
10804: LD_VAR 0 2
10808: PPUSH
10809: LD_VAR 0 3
10813: PPUSH
10814: LD_VAR 0 4
10818: PPUSH
10819: LD_VAR 0 5
10823: PPUSH
10824: CALL 47818 0 5
// end ;
10828: PPOPN 5
10830: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10831: LD_VAR 0 1
10835: PPUSH
10836: LD_VAR 0 2
10840: PPUSH
10841: CALL 47399 0 2
// end ;
10845: PPOPN 2
10847: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10848: LD_VAR 0 1
10852: PPUSH
10853: LD_VAR 0 2
10857: PPUSH
10858: LD_VAR 0 3
10862: PPUSH
10863: LD_VAR 0 4
10867: PPUSH
10868: CALL 47237 0 4
// end ;
10872: PPOPN 4
10874: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_VAR 0 2
10884: PPUSH
10885: LD_VAR 0 3
10889: PPUSH
10890: CALL 47012 0 3
// end ;
10894: PPOPN 3
10896: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10897: LD_VAR 0 1
10901: PPUSH
10902: LD_VAR 0 2
10906: PPUSH
10907: CALL 46897 0 2
// end ;
10911: PPOPN 2
10913: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10914: LD_VAR 0 1
10918: PPUSH
10919: LD_VAR 0 2
10923: PPUSH
10924: CALL 51131 0 2
// end ;
10928: PPOPN 2
10930: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10931: LD_VAR 0 1
10935: PPUSH
10936: LD_VAR 0 2
10940: PPUSH
10941: LD_VAR 0 3
10945: PPUSH
10946: LD_VAR 0 4
10950: PPUSH
10951: CALL 51347 0 4
// end ;
10955: PPOPN 4
10957: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10958: LD_VAR 0 1
10962: PPUSH
10963: LD_VAR 0 2
10967: PPUSH
10968: CALL 46706 0 2
// end ;
10972: PPOPN 2
10974: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10975: LD_VAR 0 1
10979: PPUSH
10980: CALL 104321 0 1
// end ; end_of_file
10984: PPOPN 1
10986: END
// export function Action ; begin
10987: LD_INT 0
10989: PPUSH
// InGameOn ;
10990: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10994: LD_INT 206
10996: PPUSH
10997: LD_INT 11
10999: PPUSH
11000: CALL_OW 86
// wait ( 0 0$1 ) ;
11004: LD_INT 35
11006: PPUSH
11007: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11011: LD_EXP 17
11015: PPUSH
11016: LD_STRING DStart-JMM-JMM-1
11018: PPUSH
11019: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11023: LD_EXP 49
11027: PPUSH
11028: LD_STRING DStart-JMM-Bur-1
11030: PPUSH
11031: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11035: LD_EXP 17
11039: PPUSH
11040: LD_STRING DStart-JMM-JMM-2
11042: PPUSH
11043: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11047: LD_EXP 49
11051: PPUSH
11052: LD_STRING DStart-JMM-Bur-2
11054: PPUSH
11055: CALL_OW 88
// InGameOff ;
11059: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11063: LD_STRING MStart
11065: PPUSH
11066: CALL_OW 337
// SaveForQuickRestart ;
11070: CALL_OW 22
// end ;
11074: LD_VAR 0 1
11078: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11079: LD_INT 7
11081: PPUSH
11082: LD_INT 255
11084: PPUSH
11085: LD_INT 219
11087: PPUSH
11088: CALL_OW 293
11092: IFFALSE 11701
11094: GO 11096
11096: DISABLE
11097: LD_INT 0
11099: PPUSH
// begin wait ( 0 0$3 ) ;
11100: LD_INT 105
11102: PPUSH
11103: CALL_OW 67
// alienSpotted := true ;
11107: LD_ADDR_EXP 10
11111: PUSH
11112: LD_INT 1
11114: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11115: LD_ADDR_VAR 0 1
11119: PUSH
11120: LD_INT 22
11122: PUSH
11123: LD_INT 7
11125: PUSH
11126: EMPTY
11127: LIST
11128: LIST
11129: PUSH
11130: LD_INT 23
11132: PUSH
11133: LD_INT 3
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PUSH
11140: LD_INT 21
11142: PUSH
11143: LD_INT 1
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: PUSH
11150: LD_INT 26
11152: PUSH
11153: LD_INT 1
11155: PUSH
11156: EMPTY
11157: LIST
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: PPUSH
11166: CALL_OW 69
11170: PUSH
11171: LD_EXP 49
11175: PUSH
11176: LD_EXP 37
11180: PUSH
11181: LD_EXP 39
11185: PUSH
11186: LD_EXP 40
11190: PUSH
11191: LD_EXP 47
11195: PUSH
11196: LD_EXP 46
11200: PUSH
11201: LD_EXP 41
11205: PUSH
11206: EMPTY
11207: LIST
11208: LIST
11209: LIST
11210: LIST
11211: LIST
11212: LIST
11213: LIST
11214: DIFF
11215: ST_TO_ADDR
// DialogueOn ;
11216: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11220: LD_INT 255
11222: PPUSH
11223: LD_INT 219
11225: PPUSH
11226: LD_INT 7
11228: PPUSH
11229: LD_INT 20
11231: NEG
11232: PPUSH
11233: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11237: LD_INT 255
11239: PPUSH
11240: LD_INT 219
11242: PPUSH
11243: CALL_OW 86
// if speaker then
11247: LD_VAR 0 1
11251: IFFALSE 11269
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11253: LD_VAR 0 1
11257: PUSH
11258: LD_INT 1
11260: ARRAY
11261: PPUSH
11262: LD_STRING DAlienBase-RSol1-1
11264: PPUSH
11265: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11269: LD_EXP 17
11273: PPUSH
11274: LD_STRING DAlienBase-JMM-1
11276: PPUSH
11277: CALL_OW 88
// if IsOk ( Burlak ) then
11281: LD_EXP 49
11285: PPUSH
11286: CALL_OW 302
11290: IFFALSE 11311
// begin dwait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11299: LD_EXP 49
11303: PPUSH
11304: LD_STRING DAlienBase-Bur-1
11306: PPUSH
11307: CALL_OW 88
// end ; if IsOk ( Roth ) then
11311: LD_EXP 18
11315: PPUSH
11316: CALL_OW 302
11320: IFFALSE 11334
// Say ( Roth , DAlienBase-Roth-1 ) ;
11322: LD_EXP 18
11326: PPUSH
11327: LD_STRING DAlienBase-Roth-1
11329: PPUSH
11330: CALL_OW 88
// if IsOk ( Gossudarov ) then
11334: LD_EXP 35
11338: PPUSH
11339: CALL_OW 302
11343: IFFALSE 11359
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11345: LD_EXP 35
11349: PPUSH
11350: LD_STRING DAlienBase-Gos-1
11352: PPUSH
11353: CALL_OW 88
11357: GO 11476
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11359: LD_ADDR_VAR 0 1
11363: PUSH
11364: LD_INT 22
11366: PUSH
11367: LD_INT 7
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: PUSH
11374: LD_INT 25
11376: PUSH
11377: LD_INT 4
11379: PUSH
11380: EMPTY
11381: LIST
11382: LIST
11383: PUSH
11384: LD_INT 21
11386: PUSH
11387: LD_INT 1
11389: PUSH
11390: EMPTY
11391: LIST
11392: LIST
11393: PUSH
11394: LD_INT 26
11396: PUSH
11397: LD_INT 1
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: PUSH
11404: EMPTY
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: PPUSH
11410: CALL_OW 69
11414: PUSH
11415: LD_EXP 18
11419: PUSH
11420: LD_EXP 17
11424: PUSH
11425: LD_EXP 49
11429: PUSH
11430: LD_EXP 37
11434: PUSH
11435: LD_EXP 47
11439: PUSH
11440: LD_EXP 46
11444: PUSH
11445: EMPTY
11446: LIST
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: DIFF
11453: ST_TO_ADDR
// if speaker then
11454: LD_VAR 0 1
11458: IFFALSE 11476
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11460: LD_VAR 0 1
11464: PUSH
11465: LD_INT 1
11467: ARRAY
11468: PPUSH
11469: LD_STRING DAlienBase-Sci1-1
11471: PPUSH
11472: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11476: LD_INT 255
11478: PPUSH
11479: LD_INT 219
11481: PPUSH
11482: LD_INT 7
11484: PPUSH
11485: CALL_OW 331
// DialogueOff ;
11489: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11493: LD_INT 35
11495: PPUSH
11496: CALL_OW 67
// until IsSelected ( alien ) ;
11500: LD_INT 1
11502: PPUSH
11503: CALL_OW 306
11507: IFFALSE 11493
// if not artifactIResearched or not artifactIIResearched then
11509: LD_EXP 12
11513: NOT
11514: PUSH
11515: LD_EXP 13
11519: NOT
11520: OR
11521: IFFALSE 11701
// begin if IsOk ( Roth ) then
11523: LD_EXP 18
11527: PPUSH
11528: CALL_OW 302
11532: IFFALSE 11548
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11534: LD_EXP 18
11538: PPUSH
11539: LD_STRING DAlieBaseNotReady-Roth-1
11541: PPUSH
11542: CALL_OW 88
11546: GO 11701
// if IsOk ( Gossudarov ) then
11548: LD_EXP 35
11552: PPUSH
11553: CALL_OW 302
11557: IFFALSE 11573
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11559: LD_EXP 35
11563: PPUSH
11564: LD_STRING DAlieBaseNotReady-Gos-1
11566: PPUSH
11567: CALL_OW 88
11571: GO 11701
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11573: LD_ADDR_VAR 0 1
11577: PUSH
11578: LD_INT 22
11580: PUSH
11581: LD_INT 7
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PUSH
11588: LD_INT 23
11590: PUSH
11591: LD_INT 3
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: PUSH
11598: LD_INT 25
11600: PUSH
11601: LD_INT 4
11603: PUSH
11604: EMPTY
11605: LIST
11606: LIST
11607: PUSH
11608: LD_INT 21
11610: PUSH
11611: LD_INT 1
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: PUSH
11618: LD_INT 26
11620: PUSH
11621: LD_INT 1
11623: PUSH
11624: EMPTY
11625: LIST
11626: LIST
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: PPUSH
11635: CALL_OW 69
11639: PUSH
11640: LD_EXP 18
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 49
11654: PUSH
11655: LD_EXP 37
11659: PUSH
11660: LD_EXP 47
11664: PUSH
11665: LD_EXP 46
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: LIST
11674: LIST
11675: LIST
11676: LIST
11677: DIFF
11678: ST_TO_ADDR
// if speaker then
11679: LD_VAR 0 1
11683: IFFALSE 11701
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11685: LD_VAR 0 1
11689: PUSH
11690: LD_INT 1
11692: ARRAY
11693: PPUSH
11694: LD_STRING DAlieBaseNotReady-RSci1-1
11696: PPUSH
11697: CALL_OW 88
// end ; end ; end ;
11701: PPOPN 1
11703: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11704: LD_INT 24
11706: PPUSH
11707: LD_INT 7
11709: PPUSH
11710: CALL_OW 321
11714: PUSH
11715: LD_INT 2
11717: EQUAL
11718: IFFALSE 12409
11720: GO 11722
11722: DISABLE
11723: LD_INT 0
11725: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11726: LD_ADDR_VAR 0 1
11730: PUSH
11731: LD_INT 22
11733: PUSH
11734: LD_INT 7
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: PUSH
11741: LD_INT 23
11743: PUSH
11744: LD_INT 3
11746: PUSH
11747: EMPTY
11748: LIST
11749: LIST
11750: PUSH
11751: LD_INT 25
11753: PUSH
11754: LD_INT 4
11756: PUSH
11757: EMPTY
11758: LIST
11759: LIST
11760: PUSH
11761: LD_INT 21
11763: PUSH
11764: LD_INT 1
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: PUSH
11771: LD_INT 26
11773: PUSH
11774: LD_INT 1
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: PPUSH
11788: CALL_OW 69
11792: PUSH
11793: LD_EXP 18
11797: PUSH
11798: LD_EXP 17
11802: PUSH
11803: LD_EXP 49
11807: PUSH
11808: LD_EXP 37
11812: PUSH
11813: LD_EXP 47
11817: PUSH
11818: LD_EXP 46
11822: PUSH
11823: EMPTY
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: DIFF
11831: ST_TO_ADDR
// if not speaker then
11832: LD_VAR 0 1
11836: NOT
11837: IFFALSE 11841
// exit ;
11839: GO 12409
// DialogueOn ;
11841: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11845: LD_VAR 0 1
11849: PUSH
11850: LD_INT 1
11852: ARRAY
11853: PPUSH
11854: LD_STRING DArtefTechnology-RSci1-1
11856: PPUSH
11857: CALL_OW 88
// if IsOk ( Burlak ) then
11861: LD_EXP 49
11865: PPUSH
11866: CALL_OW 302
11870: IFFALSE 11884
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11872: LD_EXP 49
11876: PPUSH
11877: LD_STRING DArtefTechnology-Bur-1
11879: PPUSH
11880: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11884: LD_VAR 0 1
11888: PUSH
11889: LD_INT 1
11891: ARRAY
11892: PPUSH
11893: LD_STRING DArtefTechnology-RSci1-2
11895: PPUSH
11896: CALL_OW 88
// if Denis then
11900: LD_EXP 23
11904: IFFALSE 11921
// speaker := [ Denis ] else
11906: LD_ADDR_VAR 0 1
11910: PUSH
11911: LD_EXP 23
11915: PUSH
11916: EMPTY
11917: LIST
11918: ST_TO_ADDR
11919: GO 12027
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11921: LD_ADDR_VAR 0 1
11925: PUSH
11926: LD_INT 22
11928: PUSH
11929: LD_INT 7
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: PUSH
11936: LD_INT 23
11938: PUSH
11939: LD_INT 1
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: PUSH
11946: LD_INT 25
11948: PUSH
11949: LD_INT 4
11951: PUSH
11952: EMPTY
11953: LIST
11954: LIST
11955: PUSH
11956: LD_INT 21
11958: PUSH
11959: LD_INT 1
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PUSH
11966: LD_INT 26
11968: PUSH
11969: LD_INT 1
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: PPUSH
11983: CALL_OW 69
11987: PUSH
11988: LD_EXP 18
11992: PUSH
11993: LD_EXP 17
11997: PUSH
11998: LD_EXP 49
12002: PUSH
12003: LD_EXP 37
12007: PUSH
12008: LD_EXP 47
12012: PUSH
12013: LD_EXP 46
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: LIST
12024: LIST
12025: DIFF
12026: ST_TO_ADDR
// if speaker then
12027: LD_VAR 0 1
12031: IFFALSE 12049
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12033: LD_VAR 0 1
12037: PUSH
12038: LD_INT 1
12040: ARRAY
12041: PPUSH
12042: LD_STRING DArtefTechnology-Sci1-2
12044: PPUSH
12045: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12049: LD_ADDR_VAR 0 1
12053: PUSH
12054: LD_INT 22
12056: PUSH
12057: LD_INT 7
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: LD_INT 23
12066: PUSH
12067: LD_INT 3
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PUSH
12074: LD_INT 25
12076: PUSH
12077: LD_INT 4
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 21
12086: PUSH
12087: LD_INT 1
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: LD_INT 26
12096: PUSH
12097: LD_INT 1
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PUSH
12104: EMPTY
12105: LIST
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: PPUSH
12111: CALL_OW 69
12115: PUSH
12116: LD_EXP 18
12120: PUSH
12121: LD_EXP 17
12125: PUSH
12126: LD_EXP 49
12130: PUSH
12131: LD_EXP 37
12135: PUSH
12136: LD_EXP 47
12140: PUSH
12141: LD_EXP 46
12145: PUSH
12146: EMPTY
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: LIST
12153: DIFF
12154: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12155: LD_VAR 0 1
12159: PUSH
12160: LD_EXP 9
12164: PUSH
12165: LD_EXP 5
12169: OR
12170: AND
12171: IFFALSE 12405
// begin if arabianDestroyed and IsOk ( Burlak ) then
12173: LD_EXP 5
12177: PUSH
12178: LD_EXP 49
12182: PPUSH
12183: CALL_OW 302
12187: AND
12188: IFFALSE 12204
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12190: LD_EXP 49
12194: PPUSH
12195: LD_STRING DArtefTechnology-Bur-2
12197: PPUSH
12198: CALL_OW 88
12202: GO 12216
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12204: LD_EXP 17
12208: PPUSH
12209: LD_STRING DArtefTechnology-JMM-2
12211: PPUSH
12212: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12216: LD_VAR 0 1
12220: PUSH
12221: LD_INT 1
12223: ARRAY
12224: PPUSH
12225: LD_STRING DArtefTechnology-RSci1-3
12227: PPUSH
12228: CALL_OW 88
// if Denis then
12232: LD_EXP 23
12236: IFFALSE 12253
// speaker := [ Denis ] else
12238: LD_ADDR_VAR 0 1
12242: PUSH
12243: LD_EXP 23
12247: PUSH
12248: EMPTY
12249: LIST
12250: ST_TO_ADDR
12251: GO 12359
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12253: LD_ADDR_VAR 0 1
12257: PUSH
12258: LD_INT 22
12260: PUSH
12261: LD_INT 7
12263: PUSH
12264: EMPTY
12265: LIST
12266: LIST
12267: PUSH
12268: LD_INT 23
12270: PUSH
12271: LD_INT 1
12273: PUSH
12274: EMPTY
12275: LIST
12276: LIST
12277: PUSH
12278: LD_INT 25
12280: PUSH
12281: LD_INT 4
12283: PUSH
12284: EMPTY
12285: LIST
12286: LIST
12287: PUSH
12288: LD_INT 21
12290: PUSH
12291: LD_INT 1
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: PUSH
12298: LD_INT 26
12300: PUSH
12301: LD_INT 1
12303: PUSH
12304: EMPTY
12305: LIST
12306: LIST
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: PPUSH
12315: CALL_OW 69
12319: PUSH
12320: LD_EXP 18
12324: PUSH
12325: LD_EXP 17
12329: PUSH
12330: LD_EXP 49
12334: PUSH
12335: LD_EXP 37
12339: PUSH
12340: LD_EXP 47
12344: PUSH
12345: LD_EXP 46
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: DIFF
12358: ST_TO_ADDR
// if speaker then
12359: LD_VAR 0 1
12363: IFFALSE 12405
// if alienSpotted then
12365: LD_EXP 10
12369: IFFALSE 12389
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12371: LD_VAR 0 1
12375: PUSH
12376: LD_INT 1
12378: ARRAY
12379: PPUSH
12380: LD_STRING DArtefTechnology-Sci1-3
12382: PPUSH
12383: CALL_OW 88
12387: GO 12405
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12389: LD_VAR 0 1
12393: PUSH
12394: LD_INT 1
12396: ARRAY
12397: PPUSH
12398: LD_STRING DArtefTechnology-Sci1-3a
12400: PPUSH
12401: CALL_OW 88
// end ; DialogueOff ;
12405: CALL_OW 7
// end ;
12409: PPOPN 1
12411: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12412: LD_EXP 12
12416: IFFALSE 12611
12418: GO 12420
12420: DISABLE
12421: LD_INT 0
12423: PPUSH
// begin if Denis then
12424: LD_EXP 23
12428: IFFALSE 12445
// speaker := [ Denis ] else
12430: LD_ADDR_VAR 0 1
12434: PUSH
12435: LD_EXP 23
12439: PUSH
12440: EMPTY
12441: LIST
12442: ST_TO_ADDR
12443: GO 12551
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12445: LD_ADDR_VAR 0 1
12449: PUSH
12450: LD_INT 22
12452: PUSH
12453: LD_INT 7
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 23
12462: PUSH
12463: LD_INT 1
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: LD_INT 25
12472: PUSH
12473: LD_INT 4
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: LD_INT 21
12482: PUSH
12483: LD_INT 1
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PUSH
12490: LD_INT 26
12492: PUSH
12493: LD_INT 1
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PUSH
12500: EMPTY
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: PPUSH
12507: CALL_OW 69
12511: PUSH
12512: LD_EXP 18
12516: PUSH
12517: LD_EXP 17
12521: PUSH
12522: LD_EXP 49
12526: PUSH
12527: LD_EXP 37
12531: PUSH
12532: LD_EXP 47
12536: PUSH
12537: LD_EXP 46
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: LIST
12548: LIST
12549: DIFF
12550: ST_TO_ADDR
// if not speaker then
12551: LD_VAR 0 1
12555: NOT
12556: IFFALSE 12560
// exit ;
12558: GO 12611
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12560: LD_VAR 0 1
12564: PUSH
12565: LD_INT 1
12567: ARRAY
12568: PPUSH
12569: LD_STRING DArtefTechnologyAm-Sci1-1
12571: PPUSH
12572: CALL_OW 88
// if IsOk ( Burlak ) then
12576: LD_EXP 49
12580: PPUSH
12581: CALL_OW 302
12585: IFFALSE 12599
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12587: LD_EXP 49
12591: PPUSH
12592: LD_STRING DArtefTechnologyAm-Bur-1
12594: PPUSH
12595: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12599: LD_EXP 17
12603: PPUSH
12604: LD_STRING DArtefTechnologyAm-JMM-1
12606: PPUSH
12607: CALL_OW 88
// end ;
12611: PPOPN 1
12613: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12614: LD_EXP 13
12618: IFFALSE 12808
12620: GO 12622
12622: DISABLE
12623: LD_INT 0
12625: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12626: LD_ADDR_VAR 0 1
12630: PUSH
12631: LD_INT 22
12633: PUSH
12634: LD_INT 7
12636: PUSH
12637: EMPTY
12638: LIST
12639: LIST
12640: PUSH
12641: LD_INT 23
12643: PUSH
12644: LD_INT 3
12646: PUSH
12647: EMPTY
12648: LIST
12649: LIST
12650: PUSH
12651: LD_INT 25
12653: PUSH
12654: LD_INT 4
12656: PUSH
12657: EMPTY
12658: LIST
12659: LIST
12660: PUSH
12661: LD_INT 21
12663: PUSH
12664: LD_INT 1
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PUSH
12671: LD_INT 26
12673: PUSH
12674: LD_INT 1
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: LIST
12685: LIST
12686: LIST
12687: PPUSH
12688: CALL_OW 69
12692: PUSH
12693: LD_EXP 18
12697: PUSH
12698: LD_EXP 17
12702: PUSH
12703: LD_EXP 49
12707: PUSH
12708: LD_EXP 37
12712: PUSH
12713: LD_EXP 47
12717: PUSH
12718: LD_EXP 46
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: LIST
12729: LIST
12730: DIFF
12731: ST_TO_ADDR
// if not speaker then
12732: LD_VAR 0 1
12736: NOT
12737: IFFALSE 12741
// exit ;
12739: GO 12808
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12741: LD_VAR 0 1
12745: PUSH
12746: LD_INT 1
12748: ARRAY
12749: PPUSH
12750: LD_STRING DArtefTechnologyRu-RSci1-1
12752: PPUSH
12753: CALL_OW 88
// if IsOk ( Burlak ) then
12757: LD_EXP 49
12761: PPUSH
12762: CALL_OW 302
12766: IFFALSE 12780
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12768: LD_EXP 49
12772: PPUSH
12773: LD_STRING DArtefTechnologyRu-Bur-1
12775: PPUSH
12776: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12780: LD_VAR 0 1
12784: PUSH
12785: LD_INT 1
12787: ARRAY
12788: PPUSH
12789: LD_STRING DArtefTechnologyRu-RSci1-2
12791: PPUSH
12792: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12796: LD_EXP 17
12800: PPUSH
12801: LD_STRING DArtefTechnologyRu-JMM-1
12803: PPUSH
12804: CALL_OW 88
// end ;
12808: PPOPN 1
12810: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12811: LD_INT 24
12813: PPUSH
12814: LD_INT 7
12816: PPUSH
12817: CALL_OW 321
12821: PUSH
12822: LD_INT 2
12824: EQUAL
12825: PUSH
12826: LD_INT 1
12828: PPUSH
12829: CALL_OW 255
12833: PUSH
12834: LD_INT 7
12836: EQUAL
12837: AND
12838: IFFALSE 12998
12840: GO 12842
12842: DISABLE
12843: LD_INT 0
12845: PPUSH
// begin if Denis then
12846: LD_EXP 23
12850: IFFALSE 12867
// speaker := [ Denis ] else
12852: LD_ADDR_VAR 0 1
12856: PUSH
12857: LD_EXP 23
12861: PUSH
12862: EMPTY
12863: LIST
12864: ST_TO_ADDR
12865: GO 12973
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12867: LD_ADDR_VAR 0 1
12871: PUSH
12872: LD_INT 22
12874: PUSH
12875: LD_INT 7
12877: PUSH
12878: EMPTY
12879: LIST
12880: LIST
12881: PUSH
12882: LD_INT 23
12884: PUSH
12885: LD_INT 1
12887: PUSH
12888: EMPTY
12889: LIST
12890: LIST
12891: PUSH
12892: LD_INT 25
12894: PUSH
12895: LD_INT 4
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PUSH
12902: LD_INT 21
12904: PUSH
12905: LD_INT 1
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: PUSH
12912: LD_INT 26
12914: PUSH
12915: LD_INT 1
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PPUSH
12929: CALL_OW 69
12933: PUSH
12934: LD_EXP 18
12938: PUSH
12939: LD_EXP 17
12943: PUSH
12944: LD_EXP 49
12948: PUSH
12949: LD_EXP 37
12953: PUSH
12954: LD_EXP 47
12958: PUSH
12959: LD_EXP 46
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: DIFF
12972: ST_TO_ADDR
// if not speaker then
12973: LD_VAR 0 1
12977: NOT
12978: IFFALSE 12982
// exit ;
12980: GO 12998
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12982: LD_VAR 0 1
12986: PUSH
12987: LD_INT 1
12989: ARRAY
12990: PPUSH
12991: LD_STRING DArtefTechnologyArStart-Sci1-1
12993: PPUSH
12994: CALL_OW 88
// end ;
12998: PPOPN 1
13000: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13001: LD_EXP 14
13005: IFFALSE 13286
13007: GO 13009
13009: DISABLE
13010: LD_INT 0
13012: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13013: LD_ADDR_VAR 0 1
13017: PUSH
13018: LD_INT 22
13020: PUSH
13021: LD_INT 7
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 23
13030: PUSH
13031: LD_INT 3
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 25
13040: PUSH
13041: LD_INT 4
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: PUSH
13048: LD_INT 21
13050: PUSH
13051: LD_INT 1
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: PUSH
13058: LD_INT 26
13060: PUSH
13061: LD_INT 1
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: LIST
13074: PPUSH
13075: CALL_OW 69
13079: PUSH
13080: LD_EXP 18
13084: PUSH
13085: LD_EXP 17
13089: PUSH
13090: LD_EXP 49
13094: PUSH
13095: LD_EXP 37
13099: PUSH
13100: LD_EXP 47
13104: PUSH
13105: LD_EXP 46
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: DIFF
13118: ST_TO_ADDR
// if not speaker then
13119: LD_VAR 0 1
13123: NOT
13124: IFFALSE 13128
// exit ;
13126: GO 13286
// DialogueOn ;
13128: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13132: LD_VAR 0 1
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING DArtefTechnologyAr-RSci1-1
13143: PPUSH
13144: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13148: LD_EXP 17
13152: PPUSH
13153: LD_STRING DArtefTechnologyAr-JMM-1
13155: PPUSH
13156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13160: LD_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: ARRAY
13168: PPUSH
13169: LD_STRING DArtefTechnologyAr-RSci1-2
13171: PPUSH
13172: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13176: LD_EXP 17
13180: PPUSH
13181: LD_STRING DArtefTechnologyAr-JMM-2
13183: PPUSH
13184: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13188: LD_VAR 0 1
13192: PUSH
13193: LD_INT 1
13195: ARRAY
13196: PPUSH
13197: LD_STRING DArtefTechnologyAr-RSci1-3
13199: PPUSH
13200: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13204: LD_EXP 17
13208: PPUSH
13209: LD_STRING DArtefTechnologyAr-JMM-3
13211: PPUSH
13212: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13216: LD_VAR 0 1
13220: PUSH
13221: LD_INT 1
13223: ARRAY
13224: PPUSH
13225: LD_STRING DArtefTechnologyAr-RSci1-4
13227: PPUSH
13228: CALL_OW 88
// if IsOk ( Burlak ) then
13232: LD_EXP 49
13236: PPUSH
13237: CALL_OW 302
13241: IFFALSE 13255
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13243: LD_EXP 49
13247: PPUSH
13248: LD_STRING DArtefTechnologyAr-Bur-4
13250: PPUSH
13251: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13255: LD_EXP 17
13259: PPUSH
13260: LD_STRING DArtefTechnologyAr-JMM-4
13262: PPUSH
13263: CALL_OW 88
// DialogueOff ;
13267: CALL_OW 7
// wait ( 0 0$45 ) ;
13271: LD_INT 1575
13273: PPUSH
13274: CALL_OW 67
// spawnOmar := true ;
13278: LD_ADDR_EXP 11
13282: PUSH
13283: LD_INT 1
13285: ST_TO_ADDR
// end ;
13286: PPOPN 1
13288: END
// every 0 0$1 trigger spawnOmar do
13289: LD_EXP 11
13293: IFFALSE 13673
13295: GO 13297
13297: DISABLE
// begin PrepareOmarAli ;
13298: CALL 6775 0 0
// if not HasTask ( Omar ) then
13302: LD_EXP 53
13306: PPUSH
13307: CALL_OW 314
13311: NOT
13312: IFFALSE 13329
// ComMoveXY ( Omar , 252 , 220 ) ;
13314: LD_EXP 53
13318: PPUSH
13319: LD_INT 252
13321: PPUSH
13322: LD_INT 220
13324: PPUSH
13325: CALL_OW 111
// if not Omar then
13329: LD_EXP 53
13333: NOT
13334: IFFALSE 13338
// exit ;
13336: GO 13673
// repeat wait ( 0 0$1 ) ;
13338: LD_INT 35
13340: PPUSH
13341: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13345: LD_EXP 53
13349: PPUSH
13350: CALL_OW 314
13354: NOT
13355: PUSH
13356: LD_EXP 53
13360: PPUSH
13361: LD_INT 252
13363: PPUSH
13364: LD_INT 220
13366: PPUSH
13367: CALL_OW 297
13371: PUSH
13372: LD_INT 6
13374: GREATER
13375: AND
13376: IFFALSE 13393
// ComMoveXY ( Omar , 252 , 220 ) ;
13378: LD_EXP 53
13382: PPUSH
13383: LD_INT 252
13385: PPUSH
13386: LD_INT 220
13388: PPUSH
13389: CALL_OW 111
// until See ( 7 , Omar ) ;
13393: LD_INT 7
13395: PPUSH
13396: LD_EXP 53
13400: PPUSH
13401: CALL_OW 292
13405: IFFALSE 13338
// CenterNowOnUnits ( Omar ) ;
13407: LD_EXP 53
13411: PPUSH
13412: CALL_OW 87
// DialogueOn ;
13416: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13420: LD_EXP 53
13424: PPUSH
13425: LD_STRING DOmar-Omar-1
13427: PPUSH
13428: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13432: LD_EXP 17
13436: PPUSH
13437: LD_STRING DOmar-JMM-1
13439: PPUSH
13440: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13444: LD_EXP 53
13448: PPUSH
13449: LD_STRING DOmar-Omar-2
13451: PPUSH
13452: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13456: LD_EXP 17
13460: PPUSH
13461: LD_STRING DOmar-JMM-2
13463: PPUSH
13464: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13468: LD_EXP 53
13472: PPUSH
13473: LD_STRING DOmar-Omar-3
13475: PPUSH
13476: CALL_OW 88
// if IsOk ( Burlak ) then
13480: LD_EXP 49
13484: PPUSH
13485: CALL_OW 302
13489: IFFALSE 13505
// Say ( Burlak , DOmar-Bur-3 ) else
13491: LD_EXP 49
13495: PPUSH
13496: LD_STRING DOmar-Bur-3
13498: PPUSH
13499: CALL_OW 88
13503: GO 13517
// Say ( JMM , DOmar-JMM-3 ) ;
13505: LD_EXP 17
13509: PPUSH
13510: LD_STRING DOmar-JMM-3
13512: PPUSH
13513: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13517: LD_EXP 53
13521: PPUSH
13522: LD_STRING DOmar-Omar-4
13524: PPUSH
13525: CALL_OW 88
// case Query ( QAccept ) of 1 :
13529: LD_STRING QAccept
13531: PPUSH
13532: CALL_OW 97
13536: PUSH
13537: LD_INT 1
13539: DOUBLE
13540: EQUAL
13541: IFTRUE 13545
13543: GO 13581
13545: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13546: LD_EXP 17
13550: PPUSH
13551: LD_STRING DQrAccept#1-JMM-1
13553: PPUSH
13554: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13558: LD_EXP 53
13562: PPUSH
13563: LD_INT 7
13565: PPUSH
13566: CALL_OW 235
// ComStop ( Omar ) ;
13570: LD_EXP 53
13574: PPUSH
13575: CALL_OW 141
// end ; 2 :
13579: GO 13630
13581: LD_INT 2
13583: DOUBLE
13584: EQUAL
13585: IFTRUE 13589
13587: GO 13629
13589: POP
// begin if IsOk ( Burlak ) then
13590: LD_EXP 49
13594: PPUSH
13595: CALL_OW 302
13599: IFFALSE 13615
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13601: LD_EXP 49
13605: PPUSH
13606: LD_STRING DQrAccept#2-Bur-1
13608: PPUSH
13609: CALL_OW 88
13613: GO 13627
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13615: LD_EXP 17
13619: PPUSH
13620: LD_STRING DQrAccept#2-JMM-1
13622: PPUSH
13623: CALL_OW 88
// end ; end ;
13627: GO 13630
13629: POP
// DialogueOff ;
13630: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13634: LD_EXP 53
13638: PPUSH
13639: CALL_OW 255
13643: PUSH
13644: LD_INT 7
13646: EQUAL
13647: IFFALSE 13658
// begin SetAchievement ( ACH_OMAR ) ;
13649: LD_STRING ACH_OMAR
13651: PPUSH
13652: CALL_OW 543
// exit ;
13656: GO 13673
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13658: LD_EXP 53
13662: PPUSH
13663: LD_INT 202
13665: PPUSH
13666: LD_INT 115
13668: PPUSH
13669: CALL_OW 111
// end ;
13673: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13674: LD_EXP 53
13678: PPUSH
13679: LD_INT 200
13681: PPUSH
13682: LD_INT 98
13684: PPUSH
13685: CALL_OW 297
13689: PUSH
13690: LD_INT 40
13692: LESS
13693: PUSH
13694: LD_EXP 2
13698: AND
13699: IFFALSE 13917
13701: GO 13703
13703: DISABLE
// begin SetSide ( Omar , 5 ) ;
13704: LD_EXP 53
13708: PPUSH
13709: LD_INT 5
13711: PPUSH
13712: CALL_OW 235
// if IsInUnit ( Omar ) then
13716: LD_EXP 53
13720: PPUSH
13721: CALL_OW 310
13725: IFFALSE 13736
// ComExitVehicle ( Omar ) ;
13727: LD_EXP 53
13731: PPUSH
13732: CALL_OW 121
// if IsInUnit ( Omar ) then
13736: LD_EXP 53
13740: PPUSH
13741: CALL_OW 310
13745: IFFALSE 13756
// ComExitBuilding ( Omar ) ;
13747: LD_EXP 53
13751: PPUSH
13752: CALL_OW 122
// wait ( 0 0$1 ) ;
13756: LD_INT 35
13758: PPUSH
13759: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13763: LD_EXP 53
13767: PPUSH
13768: LD_INT 203
13770: PPUSH
13771: LD_INT 120
13773: PPUSH
13774: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13778: LD_INT 35
13780: PPUSH
13781: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13785: LD_EXP 53
13789: PPUSH
13790: CALL_OW 306
13794: PUSH
13795: LD_EXP 53
13799: PPUSH
13800: LD_INT 203
13802: PPUSH
13803: LD_INT 120
13805: PPUSH
13806: CALL_OW 297
13810: PUSH
13811: LD_INT 6
13813: LESS
13814: OR
13815: IFFALSE 13778
// CenterNowOnUnits ( Omar ) ;
13817: LD_EXP 53
13821: PPUSH
13822: CALL_OW 87
// DialogueOn ;
13826: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13830: LD_EXP 17
13834: PPUSH
13835: LD_STRING DOmarContam-JMM-1
13837: PPUSH
13838: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13842: LD_EXP 53
13846: PPUSH
13847: LD_STRING DOmarContam-Omar-1
13849: PPUSH
13850: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13854: LD_EXP 17
13858: PPUSH
13859: LD_STRING DOmarContam-JMM-2
13861: PPUSH
13862: CALL_OW 88
// DialogueOff ;
13866: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13870: LD_INT 5
13872: PPUSH
13873: LD_INT 7
13875: PPUSH
13876: LD_INT 2
13878: PPUSH
13879: LD_INT 1
13881: PPUSH
13882: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13886: LD_INT 105
13888: PPUSH
13889: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13893: LD_EXP 53
13897: PPUSH
13898: LD_INT 203
13900: PPUSH
13901: LD_INT 120
13903: PPUSH
13904: CALL_OW 307
13908: IFFALSE 13886
// YouLost ( MothContaminate ) ;
13910: LD_STRING MothContaminate
13912: PPUSH
13913: CALL_OW 104
// end ;
13917: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13918: LD_EXP 4
13922: NOT
13923: PUSH
13924: LD_INT 22
13926: PUSH
13927: LD_INT 1
13929: PUSH
13930: EMPTY
13931: LIST
13932: LIST
13933: PUSH
13934: LD_INT 34
13936: PUSH
13937: LD_INT 8
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PUSH
13944: EMPTY
13945: LIST
13946: LIST
13947: PPUSH
13948: CALL_OW 69
13952: AND
13953: IFFALSE 14072
13955: GO 13957
13957: DISABLE
// begin wait ( 0 0$5 ) ;
13958: LD_INT 175
13960: PPUSH
13961: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13965: LD_EXP 52
13969: PPUSH
13970: CALL_OW 302
13974: NOT
13975: PUSH
13976: LD_INT 22
13978: PUSH
13979: LD_INT 1
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: PUSH
13986: LD_INT 34
13988: PUSH
13989: LD_INT 8
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PUSH
13996: EMPTY
13997: LIST
13998: LIST
13999: PPUSH
14000: CALL_OW 69
14004: NOT
14005: OR
14006: IFFALSE 14010
// exit ;
14008: GO 14072
// DialogueOn ;
14010: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14014: LD_EXP 52
14018: PPUSH
14019: LD_STRING DWinAmericans-Pow-1
14021: PPUSH
14022: CALL_OW 94
// if IsOk ( Burlak ) then
14026: LD_EXP 49
14030: PPUSH
14031: CALL_OW 302
14035: IFFALSE 14049
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14037: LD_EXP 49
14041: PPUSH
14042: LD_STRING DWinAmericans-Bur-1
14044: PPUSH
14045: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14049: LD_EXP 17
14053: PPUSH
14054: LD_STRING DWinAmericans-JMM-1
14056: PPUSH
14057: CALL_OW 88
// DialogueOff ;
14061: CALL_OW 7
// YouLost ( AmBomb ) ;
14065: LD_STRING AmBomb
14067: PPUSH
14068: CALL_OW 104
// end ;
14072: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14073: LD_EXP 2
14077: NOT
14078: PUSH
14079: LD_INT 22
14081: PUSH
14082: LD_INT 3
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: LD_INT 34
14091: PUSH
14092: LD_INT 48
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: PPUSH
14103: CALL_OW 69
14107: AND
14108: IFFALSE 14227
14110: GO 14112
14112: DISABLE
// begin wait ( 0 0$5 ) ;
14113: LD_INT 175
14115: PPUSH
14116: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14120: LD_EXP 56
14124: PPUSH
14125: CALL_OW 302
14129: NOT
14130: PUSH
14131: LD_INT 22
14133: PUSH
14134: LD_INT 3
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: PUSH
14141: LD_INT 34
14143: PUSH
14144: LD_INT 48
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: PPUSH
14155: CALL_OW 69
14159: NOT
14160: OR
14161: IFFALSE 14165
// exit ;
14163: GO 14227
// DialogueOn ;
14165: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14169: LD_EXP 56
14173: PPUSH
14174: LD_STRING DWinRussians-Pla-1
14176: PPUSH
14177: CALL_OW 94
// if IsOk ( Burlak ) then
14181: LD_EXP 49
14185: PPUSH
14186: CALL_OW 302
14190: IFFALSE 14204
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14192: LD_EXP 49
14196: PPUSH
14197: LD_STRING DWinRussians-Bur-1
14199: PPUSH
14200: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14204: LD_EXP 17
14208: PPUSH
14209: LD_STRING DWinRussians-JMM-1
14211: PPUSH
14212: CALL_OW 88
// DialogueOff ;
14216: CALL_OW 7
// YouLost ( RuBomb ) ;
14220: LD_STRING RuBomb
14222: PPUSH
14223: CALL_OW 104
// end ;
14227: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14228: LD_INT 7
14230: PPUSH
14231: LD_INT 22
14233: PUSH
14234: LD_INT 7
14236: PUSH
14237: EMPTY
14238: LIST
14239: LIST
14240: PPUSH
14241: CALL_OW 70
14245: PUSH
14246: LD_EXP 4
14250: NOT
14251: AND
14252: IFFALSE 14281
14254: GO 14256
14256: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14257: LD_EXP 52
14261: PPUSH
14262: LD_STRING DSurrenderAmericans-Pow-1
14264: PPUSH
14265: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14269: LD_EXP 17
14273: PPUSH
14274: LD_STRING DSurrenderAmericans-JMM-1
14276: PPUSH
14277: CALL_OW 88
// end ;
14281: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14282: LD_INT 2
14284: PPUSH
14285: LD_INT 22
14287: PUSH
14288: LD_INT 7
14290: PUSH
14291: EMPTY
14292: LIST
14293: LIST
14294: PPUSH
14295: CALL_OW 70
14299: PUSH
14300: LD_EXP 2
14304: NOT
14305: AND
14306: PUSH
14307: LD_EXP 49
14311: AND
14312: IFFALSE 14341
14314: GO 14316
14316: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14317: LD_EXP 56
14321: PPUSH
14322: LD_STRING DSurrenderRussians-Pla-1
14324: PPUSH
14325: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14329: LD_EXP 49
14333: PPUSH
14334: LD_STRING DSurrenderRussians-Bur-1
14336: PPUSH
14337: CALL_OW 88
// end ;
14341: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14342: LD_EXP 4
14346: IFFALSE 14729
14348: GO 14350
14350: DISABLE
14351: LD_INT 0
14353: PPUSH
14354: PPUSH
14355: PPUSH
// begin MC_Kill ( 4 ) ;
14356: LD_INT 4
14358: PPUSH
14359: CALL 21104 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14363: LD_INT 1
14365: PPUSH
14366: LD_INT 7
14368: PPUSH
14369: LD_INT 1
14371: PPUSH
14372: LD_INT 1
14374: PPUSH
14375: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14379: LD_ADDR_VAR 0 3
14383: PUSH
14384: LD_INT 22
14386: PUSH
14387: LD_INT 1
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: LD_INT 26
14396: PUSH
14397: LD_INT 1
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: PUSH
14404: LD_INT 23
14406: PUSH
14407: LD_INT 1
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PUSH
14414: EMPTY
14415: LIST
14416: LIST
14417: LIST
14418: PPUSH
14419: CALL_OW 69
14423: PUSH
14424: LD_EXP 52
14428: PUSH
14429: LD_EXP 25
14433: PUSH
14434: LD_EXP 22
14438: PUSH
14439: LD_EXP 21
14443: PUSH
14444: LD_EXP 28
14448: PUSH
14449: LD_EXP 26
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: DIFF
14462: ST_TO_ADDR
// if speaker then
14463: LD_VAR 0 3
14467: IFFALSE 14493
// begin DialogueOn ;
14469: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14473: LD_VAR 0 3
14477: PUSH
14478: LD_INT 1
14480: ARRAY
14481: PPUSH
14482: LD_STRING DSurrenderAmericans-Sol1-1a
14484: PPUSH
14485: CALL_OW 94
// DialogueOff ;
14489: CALL_OW 7
// end ; americanCapitulated := true ;
14493: LD_ADDR_EXP 6
14497: PUSH
14498: LD_INT 1
14500: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14501: LD_ADDR_VAR 0 2
14505: PUSH
14506: LD_INT 22
14508: PUSH
14509: LD_INT 1
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PUSH
14516: LD_INT 21
14518: PUSH
14519: LD_INT 1
14521: PUSH
14522: EMPTY
14523: LIST
14524: LIST
14525: PUSH
14526: EMPTY
14527: LIST
14528: LIST
14529: PPUSH
14530: CALL_OW 69
14534: PUSH
14535: LD_INT 22
14537: PUSH
14538: LD_INT 1
14540: PUSH
14541: EMPTY
14542: LIST
14543: LIST
14544: PUSH
14545: LD_INT 21
14547: PUSH
14548: LD_INT 2
14550: PUSH
14551: EMPTY
14552: LIST
14553: LIST
14554: PUSH
14555: LD_INT 1
14557: PUSH
14558: EMPTY
14559: LIST
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: LIST
14565: PPUSH
14566: CALL_OW 69
14570: ADD
14571: ST_TO_ADDR
// if tmp then
14572: LD_VAR 0 2
14576: IFFALSE 14729
// repeat wait ( 0 0$1 ) ;
14578: LD_INT 35
14580: PPUSH
14581: CALL_OW 67
// for i in tmp do
14585: LD_ADDR_VAR 0 1
14589: PUSH
14590: LD_VAR 0 2
14594: PUSH
14595: FOR_IN
14596: IFFALSE 14678
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14598: LD_VAR 0 1
14602: PPUSH
14603: CALL_OW 310
14607: PUSH
14608: LD_VAR 0 1
14612: PPUSH
14613: CALL_OW 310
14617: PPUSH
14618: CALL_OW 247
14622: PUSH
14623: LD_INT 3
14625: EQUAL
14626: AND
14627: IFFALSE 14638
// ComExitBuilding ( i ) ;
14629: LD_VAR 0 1
14633: PPUSH
14634: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14638: LD_VAR 0 1
14642: PPUSH
14643: LD_INT 122
14645: PPUSH
14646: LD_INT 242
14648: PPUSH
14649: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14653: LD_VAR 0 1
14657: PPUSH
14658: LD_INT 35
14660: PPUSH
14661: CALL_OW 308
14665: IFFALSE 14676
// RemoveUnit ( i ) ;
14667: LD_VAR 0 1
14671: PPUSH
14672: CALL_OW 64
// end ;
14676: GO 14595
14678: POP
14679: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14680: LD_INT 22
14682: PUSH
14683: LD_INT 1
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PUSH
14690: LD_INT 2
14692: PUSH
14693: LD_INT 21
14695: PUSH
14696: LD_INT 1
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: LD_INT 33
14705: PUSH
14706: LD_INT 1
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: LIST
14717: PUSH
14718: EMPTY
14719: LIST
14720: LIST
14721: PPUSH
14722: CALL_OW 69
14726: NOT
14727: IFFALSE 14578
// end ;
14729: PPOPN 3
14731: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14732: LD_EXP 2
14736: IFFALSE 15137
14738: GO 14740
14740: DISABLE
14741: LD_INT 0
14743: PPUSH
14744: PPUSH
14745: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14746: LD_INT 35
14748: PPUSH
14749: CALL_OW 67
// until IsDead ( Yakotich ) ;
14753: LD_EXP 57
14757: PPUSH
14758: CALL_OW 301
14762: IFFALSE 14746
// MC_Kill ( 2 ) ;
14764: LD_INT 2
14766: PPUSH
14767: CALL 21104 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14771: LD_INT 3
14773: PPUSH
14774: LD_INT 7
14776: PPUSH
14777: LD_INT 1
14779: PPUSH
14780: LD_INT 1
14782: PPUSH
14783: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14787: LD_ADDR_VAR 0 3
14791: PUSH
14792: LD_INT 22
14794: PUSH
14795: LD_INT 3
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PUSH
14802: LD_INT 26
14804: PUSH
14805: LD_INT 1
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PUSH
14812: LD_INT 23
14814: PUSH
14815: LD_INT 3
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PUSH
14822: EMPTY
14823: LIST
14824: LIST
14825: LIST
14826: PPUSH
14827: CALL_OW 69
14831: PUSH
14832: LD_EXP 56
14836: PUSH
14837: LD_EXP 57
14841: PUSH
14842: EMPTY
14843: LIST
14844: LIST
14845: DIFF
14846: ST_TO_ADDR
// if speaker then
14847: LD_VAR 0 3
14851: IFFALSE 14901
// begin DialogueOn ;
14853: CALL_OW 6
// if Burlak then
14857: LD_EXP 49
14861: IFFALSE 14881
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14863: LD_VAR 0 3
14867: PUSH
14868: LD_INT 1
14870: ARRAY
14871: PPUSH
14872: LD_STRING DSurrenderRussians-RSol1-1
14874: PPUSH
14875: CALL_OW 94
14879: GO 14897
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14881: LD_VAR 0 3
14885: PUSH
14886: LD_INT 1
14888: ARRAY
14889: PPUSH
14890: LD_STRING DSurrenderRussians-RSol1-1a
14892: PPUSH
14893: CALL_OW 94
// DialogueOff ;
14897: CALL_OW 7
// end ; russianCapitulated := true ;
14901: LD_ADDR_EXP 7
14905: PUSH
14906: LD_INT 1
14908: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14909: LD_ADDR_VAR 0 2
14913: PUSH
14914: LD_INT 22
14916: PUSH
14917: LD_INT 3
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: PUSH
14924: LD_INT 21
14926: PUSH
14927: LD_INT 1
14929: PUSH
14930: EMPTY
14931: LIST
14932: LIST
14933: PUSH
14934: EMPTY
14935: LIST
14936: LIST
14937: PPUSH
14938: CALL_OW 69
14942: PUSH
14943: LD_INT 22
14945: PUSH
14946: LD_INT 3
14948: PUSH
14949: EMPTY
14950: LIST
14951: LIST
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 1
14965: PUSH
14966: EMPTY
14967: LIST
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: LIST
14973: PPUSH
14974: CALL_OW 69
14978: ADD
14979: ST_TO_ADDR
// if tmp then
14980: LD_VAR 0 2
14984: IFFALSE 15137
// repeat wait ( 0 0$1 ) ;
14986: LD_INT 35
14988: PPUSH
14989: CALL_OW 67
// for i in tmp do
14993: LD_ADDR_VAR 0 1
14997: PUSH
14998: LD_VAR 0 2
15002: PUSH
15003: FOR_IN
15004: IFFALSE 15086
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15006: LD_VAR 0 1
15010: PPUSH
15011: CALL_OW 310
15015: PUSH
15016: LD_VAR 0 1
15020: PPUSH
15021: CALL_OW 310
15025: PPUSH
15026: CALL_OW 247
15030: PUSH
15031: LD_INT 3
15033: EQUAL
15034: AND
15035: IFFALSE 15046
// ComExitBuilding ( i ) ;
15037: LD_VAR 0 1
15041: PPUSH
15042: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15046: LD_VAR 0 1
15050: PPUSH
15051: LD_INT 154
15053: PPUSH
15054: LD_INT 1
15056: PPUSH
15057: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_INT 36
15068: PPUSH
15069: CALL_OW 308
15073: IFFALSE 15084
// RemoveUnit ( i ) ;
15075: LD_VAR 0 1
15079: PPUSH
15080: CALL_OW 64
// end ;
15084: GO 15003
15086: POP
15087: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15088: LD_INT 22
15090: PUSH
15091: LD_INT 3
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: PUSH
15098: LD_INT 2
15100: PUSH
15101: LD_INT 21
15103: PUSH
15104: LD_INT 1
15106: PUSH
15107: EMPTY
15108: LIST
15109: LIST
15110: PUSH
15111: LD_INT 33
15113: PUSH
15114: LD_INT 1
15116: PUSH
15117: EMPTY
15118: LIST
15119: LIST
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: LIST
15125: PUSH
15126: EMPTY
15127: LIST
15128: LIST
15129: PPUSH
15130: CALL_OW 69
15134: NOT
15135: IFFALSE 14986
// end ;
15137: PPOPN 3
15139: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15140: LD_INT 22
15142: PUSH
15143: LD_INT 8
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: PUSH
15150: LD_INT 21
15152: PUSH
15153: LD_INT 1
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: PUSH
15160: LD_INT 23
15162: PUSH
15163: LD_INT 2
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: LIST
15174: PPUSH
15175: CALL_OW 69
15179: PUSH
15180: LD_INT 18
15182: LESS
15183: PUSH
15184: LD_EXP 55
15188: PPUSH
15189: CALL_OW 301
15193: OR
15194: PUSH
15195: LD_INT 324
15197: PPUSH
15198: CALL_OW 255
15202: PUSH
15203: LD_INT 7
15205: EQUAL
15206: OR
15207: IFFALSE 15220
15209: GO 15211
15211: DISABLE
// legionDestroyed := true ;
15212: LD_ADDR_EXP 3
15216: PUSH
15217: LD_INT 1
15219: ST_TO_ADDR
15220: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15221: LD_INT 22
15223: PUSH
15224: LD_INT 2
15226: PUSH
15227: EMPTY
15228: LIST
15229: LIST
15230: PUSH
15231: LD_INT 21
15233: PUSH
15234: LD_INT 1
15236: PUSH
15237: EMPTY
15238: LIST
15239: LIST
15240: PUSH
15241: LD_INT 23
15243: PUSH
15244: LD_INT 2
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: LIST
15255: PPUSH
15256: CALL_OW 69
15260: PUSH
15261: LD_INT 9
15263: LESS
15264: IFFALSE 15277
15266: GO 15268
15268: DISABLE
// arabianDestroyed := true ;
15269: LD_ADDR_EXP 5
15273: PUSH
15274: LD_INT 1
15276: ST_TO_ADDR
15277: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15278: LD_EXP 5
15282: IFFALSE 15526
15284: GO 15286
15286: DISABLE
15287: LD_INT 0
15289: PPUSH
15290: PPUSH
// begin MC_Kill ( 1 ) ;
15291: LD_INT 1
15293: PPUSH
15294: CALL 21104 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15298: LD_ADDR_VAR 0 2
15302: PUSH
15303: LD_INT 22
15305: PUSH
15306: LD_INT 2
15308: PUSH
15309: EMPTY
15310: LIST
15311: LIST
15312: PUSH
15313: LD_INT 21
15315: PUSH
15316: LD_INT 1
15318: PUSH
15319: EMPTY
15320: LIST
15321: LIST
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: PPUSH
15327: CALL_OW 69
15331: PUSH
15332: LD_INT 22
15334: PUSH
15335: LD_INT 8
15337: PUSH
15338: EMPTY
15339: LIST
15340: LIST
15341: PUSH
15342: LD_INT 21
15344: PUSH
15345: LD_INT 2
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: PUSH
15352: LD_INT 1
15354: PUSH
15355: EMPTY
15356: LIST
15357: PUSH
15358: EMPTY
15359: LIST
15360: LIST
15361: LIST
15362: PPUSH
15363: CALL_OW 69
15367: ADD
15368: ST_TO_ADDR
// if tmp then
15369: LD_VAR 0 2
15373: IFFALSE 15526
// repeat wait ( 0 0$1 ) ;
15375: LD_INT 35
15377: PPUSH
15378: CALL_OW 67
// for i in tmp do
15382: LD_ADDR_VAR 0 1
15386: PUSH
15387: LD_VAR 0 2
15391: PUSH
15392: FOR_IN
15393: IFFALSE 15475
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15395: LD_VAR 0 1
15399: PPUSH
15400: CALL_OW 310
15404: PUSH
15405: LD_VAR 0 1
15409: PPUSH
15410: CALL_OW 310
15414: PPUSH
15415: CALL_OW 247
15419: PUSH
15420: LD_INT 3
15422: EQUAL
15423: AND
15424: IFFALSE 15435
// ComExitBuilding ( i ) ;
15426: LD_VAR 0 1
15430: PPUSH
15431: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_INT 254
15442: PPUSH
15443: LD_INT 268
15445: PPUSH
15446: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15450: LD_VAR 0 1
15454: PPUSH
15455: LD_INT 34
15457: PPUSH
15458: CALL_OW 308
15462: IFFALSE 15473
// RemoveUnit ( i ) ;
15464: LD_VAR 0 1
15468: PPUSH
15469: CALL_OW 64
// end ;
15473: GO 15392
15475: POP
15476: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15477: LD_INT 22
15479: PUSH
15480: LD_INT 2
15482: PUSH
15483: EMPTY
15484: LIST
15485: LIST
15486: PUSH
15487: LD_INT 2
15489: PUSH
15490: LD_INT 21
15492: PUSH
15493: LD_INT 1
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 33
15502: PUSH
15503: LD_INT 1
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: LIST
15514: PUSH
15515: EMPTY
15516: LIST
15517: LIST
15518: PPUSH
15519: CALL_OW 69
15523: NOT
15524: IFFALSE 15375
// end ;
15526: PPOPN 2
15528: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15529: LD_EXP 3
15533: IFFALSE 15885
15535: GO 15537
15537: DISABLE
15538: LD_INT 0
15540: PPUSH
15541: PPUSH
// begin MC_Kill ( 3 ) ;
15542: LD_INT 3
15544: PPUSH
15545: CALL 21104 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15549: LD_INT 8
15551: PPUSH
15552: LD_INT 7
15554: PPUSH
15555: LD_INT 1
15557: PPUSH
15558: LD_INT 1
15560: PPUSH
15561: CALL_OW 80
// DialogueOn ;
15565: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15569: LD_EXP 54
15573: PPUSH
15574: LD_STRING D15-Szulc-1
15576: PPUSH
15577: CALL_OW 94
// DialogueOff ;
15581: CALL_OW 7
// legionCapitulated := true ;
15585: LD_ADDR_EXP 8
15589: PUSH
15590: LD_INT 1
15592: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15593: LD_ADDR_VAR 0 1
15597: PUSH
15598: LD_INT 22
15600: PUSH
15601: LD_INT 8
15603: PUSH
15604: EMPTY
15605: LIST
15606: LIST
15607: PUSH
15608: LD_INT 21
15610: PUSH
15611: LD_INT 3
15613: PUSH
15614: EMPTY
15615: LIST
15616: LIST
15617: PUSH
15618: LD_INT 23
15620: PUSH
15621: LD_INT 3
15623: PUSH
15624: EMPTY
15625: LIST
15626: LIST
15627: PUSH
15628: EMPTY
15629: LIST
15630: LIST
15631: LIST
15632: PPUSH
15633: CALL_OW 69
15637: PUSH
15638: FOR_IN
15639: IFFALSE 15655
// SetLives ( i , 3 ) ;
15641: LD_VAR 0 1
15645: PPUSH
15646: LD_INT 3
15648: PPUSH
15649: CALL_OW 234
15653: GO 15638
15655: POP
15656: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15657: LD_ADDR_VAR 0 2
15661: PUSH
15662: LD_INT 22
15664: PUSH
15665: LD_INT 8
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: PUSH
15672: LD_INT 21
15674: PUSH
15675: LD_INT 1
15677: PUSH
15678: EMPTY
15679: LIST
15680: LIST
15681: PUSH
15682: EMPTY
15683: LIST
15684: LIST
15685: PPUSH
15686: CALL_OW 69
15690: PUSH
15691: LD_INT 22
15693: PUSH
15694: LD_INT 8
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: PUSH
15701: LD_INT 21
15703: PUSH
15704: LD_INT 2
15706: PUSH
15707: EMPTY
15708: LIST
15709: LIST
15710: PUSH
15711: LD_INT 1
15713: PUSH
15714: EMPTY
15715: LIST
15716: PUSH
15717: EMPTY
15718: LIST
15719: LIST
15720: LIST
15721: PPUSH
15722: CALL_OW 69
15726: ADD
15727: ST_TO_ADDR
// if tmp then
15728: LD_VAR 0 2
15732: IFFALSE 15885
// repeat wait ( 0 0$1 ) ;
15734: LD_INT 35
15736: PPUSH
15737: CALL_OW 67
// for i in tmp do
15741: LD_ADDR_VAR 0 1
15745: PUSH
15746: LD_VAR 0 2
15750: PUSH
15751: FOR_IN
15752: IFFALSE 15834
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15754: LD_VAR 0 1
15758: PPUSH
15759: CALL_OW 310
15763: PUSH
15764: LD_VAR 0 1
15768: PPUSH
15769: CALL_OW 310
15773: PPUSH
15774: CALL_OW 247
15778: PUSH
15779: LD_INT 3
15781: EQUAL
15782: AND
15783: IFFALSE 15794
// ComExitBuilding ( i ) ;
15785: LD_VAR 0 1
15789: PPUSH
15790: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15794: LD_VAR 0 1
15798: PPUSH
15799: LD_INT 10
15801: PPUSH
15802: LD_INT 1
15804: PPUSH
15805: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15809: LD_VAR 0 1
15813: PPUSH
15814: LD_INT 32
15816: PPUSH
15817: CALL_OW 308
15821: IFFALSE 15832
// RemoveUnit ( i ) ;
15823: LD_VAR 0 1
15827: PPUSH
15828: CALL_OW 64
// end ;
15832: GO 15751
15834: POP
15835: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15836: LD_INT 22
15838: PUSH
15839: LD_INT 8
15841: PUSH
15842: EMPTY
15843: LIST
15844: LIST
15845: PUSH
15846: LD_INT 2
15848: PUSH
15849: LD_INT 21
15851: PUSH
15852: LD_INT 1
15854: PUSH
15855: EMPTY
15856: LIST
15857: LIST
15858: PUSH
15859: LD_INT 33
15861: PUSH
15862: LD_INT 1
15864: PUSH
15865: EMPTY
15866: LIST
15867: LIST
15868: PUSH
15869: EMPTY
15870: LIST
15871: LIST
15872: LIST
15873: PUSH
15874: EMPTY
15875: LIST
15876: LIST
15877: PPUSH
15878: CALL_OW 69
15882: NOT
15883: IFFALSE 15734
// end ;
15885: PPOPN 2
15887: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15888: LD_EXP 4
15892: PUSH
15893: LD_EXP 2
15897: AND
15898: PUSH
15899: LD_EXP 3
15903: AND
15904: PUSH
15905: LD_EXP 5
15909: AND
15910: PUSH
15911: LD_EXP 6
15915: AND
15916: PUSH
15917: LD_EXP 7
15921: AND
15922: PUSH
15923: LD_EXP 8
15927: AND
15928: PUSH
15929: LD_EXP 53
15933: PPUSH
15934: CALL_OW 255
15938: PUSH
15939: LD_INT 5
15941: NONEQUAL
15942: PUSH
15943: LD_EXP 53
15947: PPUSH
15948: CALL_OW 301
15952: OR
15953: PUSH
15954: LD_EXP 53
15958: PPUSH
15959: CALL_OW 305
15963: NOT
15964: OR
15965: AND
15966: IFFALSE 17357
15968: GO 15970
15970: DISABLE
15971: LD_INT 0
15973: PPUSH
15974: PPUSH
// begin wait ( 0 0$5 ) ;
15975: LD_INT 175
15977: PPUSH
15978: CALL_OW 67
// music_class := 5 ;
15982: LD_ADDR_OWVAR 72
15986: PUSH
15987: LD_INT 5
15989: ST_TO_ADDR
// music_nat := 5 ;
15990: LD_ADDR_OWVAR 71
15994: PUSH
15995: LD_INT 5
15997: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15998: LD_EXP 15
16002: PUSH
16003: LD_INT 3
16005: LESS
16006: IFFALSE 16015
// SetAchievement ( ACH_ECONOMY ) ;
16008: LD_STRING ACH_ECONOMY
16010: PPUSH
16011: CALL_OW 543
// if tick < 60 60$00 then
16015: LD_OWVAR 1
16019: PUSH
16020: LD_INT 126000
16022: LESS
16023: IFFALSE 16039
// begin wait ( 3 ) ;
16025: LD_INT 3
16027: PPUSH
16028: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16032: LD_STRING ACH_ASPEED_19
16034: PPUSH
16035: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16039: LD_EXP 17
16043: PPUSH
16044: CALL_OW 87
// InGameOn ;
16048: CALL_OW 8
// DialogueOn ;
16052: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16056: LD_EXP 17
16060: PPUSH
16061: LD_STRING DEnd-JMM-JMM-1
16063: PPUSH
16064: CALL_OW 88
// if Joan then
16068: LD_EXP 32
16072: IFFALSE 16088
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16074: LD_EXP 32
16078: PPUSH
16079: LD_STRING DEnd-JMM-Joan-1
16081: PPUSH
16082: CALL_OW 88
16086: GO 16132
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16088: LD_EXP 19
16092: PUSH
16093: LD_EXP 19
16097: PPUSH
16098: CALL_OW 255
16102: PUSH
16103: LD_INT 7
16105: EQUAL
16106: AND
16107: PUSH
16108: LD_EXP 19
16112: PPUSH
16113: CALL_OW 305
16117: AND
16118: IFFALSE 16132
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16120: LD_EXP 19
16124: PPUSH
16125: LD_STRING DEnd-JMM-Lisa-1
16127: PPUSH
16128: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16132: LD_EXP 29
16136: PUSH
16137: LD_EXP 29
16141: PPUSH
16142: CALL_OW 305
16146: AND
16147: IFFALSE 16161
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16149: LD_EXP 29
16153: PPUSH
16154: LD_STRING DEnd-JMM-Frank-1
16156: PPUSH
16157: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16161: LD_EXP 22
16165: PUSH
16166: LD_EXP 22
16170: PPUSH
16171: CALL_OW 255
16175: PUSH
16176: LD_INT 7
16178: EQUAL
16179: AND
16180: PUSH
16181: LD_EXP 22
16185: PPUSH
16186: CALL_OW 305
16190: AND
16191: IFFALSE 16205
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16193: LD_EXP 22
16197: PPUSH
16198: LD_STRING DEnd-JMM-Cyrus-1
16200: PPUSH
16201: CALL_OW 88
// if Burlak then
16205: LD_EXP 49
16209: IFFALSE 16223
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16211: LD_EXP 49
16215: PPUSH
16216: LD_STRING DEnd-JMM-Bur-1
16218: PPUSH
16219: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16223: LD_EXP 32
16227: PUSH
16228: LD_EXP 19
16232: AND
16233: PUSH
16234: LD_EXP 19
16238: PPUSH
16239: CALL_OW 255
16243: PUSH
16244: LD_INT 7
16246: EQUAL
16247: AND
16248: PUSH
16249: LD_EXP 19
16253: PPUSH
16254: CALL_OW 305
16258: AND
16259: IFFALSE 16273
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16261: LD_EXP 19
16265: PPUSH
16266: LD_STRING DEnd-Burlak-Lisa-1
16268: PPUSH
16269: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16273: LD_EXP 50
16277: PUSH
16278: LD_EXP 50
16282: PPUSH
16283: CALL_OW 305
16287: AND
16288: IFFALSE 16302
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16290: LD_EXP 50
16294: PPUSH
16295: LD_STRING DEnd-JMM-Bel-1
16297: PPUSH
16298: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16302: LD_EXP 51
16306: PUSH
16307: LD_EXP 51
16311: PPUSH
16312: CALL_OW 305
16316: AND
16317: IFFALSE 16331
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16319: LD_EXP 51
16323: PPUSH
16324: LD_STRING DEnd-JMM-Gny-1
16326: PPUSH
16327: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16331: LD_EXP 27
16335: PUSH
16336: LD_EXP 27
16340: PPUSH
16341: CALL_OW 255
16345: PUSH
16346: LD_INT 7
16348: EQUAL
16349: AND
16350: PUSH
16351: LD_EXP 27
16355: PPUSH
16356: CALL_OW 305
16360: AND
16361: IFFALSE 16375
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16363: LD_EXP 27
16367: PPUSH
16368: LD_STRING DEnd-JMM-Corn-1
16370: PPUSH
16371: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16375: LD_EXP 20
16379: PUSH
16380: LD_EXP 20
16384: PPUSH
16385: CALL_OW 255
16389: PUSH
16390: LD_INT 7
16392: EQUAL
16393: AND
16394: PUSH
16395: LD_EXP 20
16399: PPUSH
16400: CALL_OW 305
16404: AND
16405: IFFALSE 16419
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16407: LD_EXP 20
16411: PPUSH
16412: LD_STRING DEnd-JMM-Don-1
16414: PPUSH
16415: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16419: LD_EXP 21
16423: PUSH
16424: LD_EXP 21
16428: PPUSH
16429: CALL_OW 255
16433: PUSH
16434: LD_INT 7
16436: EQUAL
16437: AND
16438: PUSH
16439: LD_EXP 21
16443: PPUSH
16444: CALL_OW 305
16448: AND
16449: IFFALSE 16463
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16451: LD_EXP 21
16455: PPUSH
16456: LD_STRING DEnd-JMM-Bobby-1
16458: PPUSH
16459: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16463: LD_EXP 23
16467: PUSH
16468: LD_EXP 23
16472: PPUSH
16473: CALL_OW 255
16477: PUSH
16478: LD_INT 7
16480: EQUAL
16481: AND
16482: PUSH
16483: LD_EXP 23
16487: PPUSH
16488: CALL_OW 305
16492: AND
16493: IFFALSE 16507
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16495: LD_EXP 23
16499: PPUSH
16500: LD_STRING DEnd-JMM-Den-1
16502: PPUSH
16503: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16507: LD_EXP 25
16511: PUSH
16512: LD_EXP 25
16516: PPUSH
16517: CALL_OW 255
16521: PUSH
16522: LD_INT 7
16524: EQUAL
16525: AND
16526: PUSH
16527: LD_EXP 25
16531: PPUSH
16532: CALL_OW 305
16536: AND
16537: IFFALSE 16551
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16539: LD_EXP 25
16543: PPUSH
16544: LD_STRING DEnd-JMM-Glad-1
16546: PPUSH
16547: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16551: LD_EXP 30
16555: PUSH
16556: LD_EXP 30
16560: PPUSH
16561: CALL_OW 255
16565: PUSH
16566: LD_INT 7
16568: EQUAL
16569: AND
16570: PUSH
16571: LD_EXP 30
16575: PPUSH
16576: CALL_OW 305
16580: AND
16581: IFFALSE 16595
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16583: LD_EXP 30
16587: PPUSH
16588: LD_STRING DEnd-JMM-Yam-1
16590: PPUSH
16591: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16595: LD_EXP 24
16599: PUSH
16600: LD_EXP 24
16604: PPUSH
16605: CALL_OW 255
16609: PUSH
16610: LD_INT 7
16612: EQUAL
16613: AND
16614: PUSH
16615: LD_EXP 24
16619: PPUSH
16620: CALL_OW 305
16624: AND
16625: IFFALSE 16639
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16627: LD_EXP 24
16631: PPUSH
16632: LD_STRING DEnd-JMM-Brown-1
16634: PPUSH
16635: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16639: LD_EXP 34
16643: PUSH
16644: LD_EXP 34
16648: PPUSH
16649: CALL_OW 255
16653: PUSH
16654: LD_INT 7
16656: EQUAL
16657: AND
16658: PUSH
16659: LD_EXP 34
16663: PPUSH
16664: CALL_OW 305
16668: AND
16669: IFFALSE 16683
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16671: LD_EXP 34
16675: PPUSH
16676: LD_STRING DEnd-JMM-Con-1
16678: PPUSH
16679: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16683: LD_EXP 28
16687: PUSH
16688: LD_EXP 28
16692: PPUSH
16693: CALL_OW 255
16697: PUSH
16698: LD_INT 7
16700: EQUAL
16701: AND
16702: PUSH
16703: LD_EXP 28
16707: PPUSH
16708: CALL_OW 305
16712: AND
16713: IFFALSE 16727
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16715: LD_EXP 28
16719: PPUSH
16720: LD_STRING DEnd-JMM-Gary-1
16722: PPUSH
16723: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16727: LD_EXP 31
16731: PUSH
16732: LD_EXP 18
16736: AND
16737: PUSH
16738: LD_EXP 31
16742: PPUSH
16743: CALL_OW 305
16747: AND
16748: IFFALSE 16762
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16750: LD_EXP 31
16754: PPUSH
16755: LD_STRING DEnd-JMM-Sim-1
16757: PPUSH
16758: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16762: LD_EXP 26
16766: PUSH
16767: LD_EXP 26
16771: PPUSH
16772: CALL_OW 255
16776: PUSH
16777: LD_INT 7
16779: EQUAL
16780: AND
16781: PUSH
16782: LD_EXP 26
16786: PPUSH
16787: CALL_OW 305
16791: AND
16792: IFFALSE 16806
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16794: LD_EXP 26
16798: PPUSH
16799: LD_STRING DEnd-JMM-VanH-1
16801: PPUSH
16802: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16806: LD_EXP 39
16810: PUSH
16811: LD_EXP 39
16815: PPUSH
16816: CALL_OW 305
16820: AND
16821: IFFALSE 16835
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16823: LD_EXP 39
16827: PPUSH
16828: LD_STRING DEnd-JMM-Dol-1
16830: PPUSH
16831: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16835: LD_EXP 43
16839: PUSH
16840: LD_EXP 43
16844: PPUSH
16845: CALL_OW 305
16849: AND
16850: IFFALSE 16864
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16852: LD_EXP 43
16856: PPUSH
16857: LD_STRING DEnd-JMM-Kap-1
16859: PPUSH
16860: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16864: LD_EXP 46
16868: PUSH
16869: LD_EXP 46
16873: PPUSH
16874: CALL_OW 305
16878: AND
16879: IFFALSE 16893
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16881: LD_EXP 46
16885: PPUSH
16886: LD_STRING DEnd-JMM-Kov-1
16888: PPUSH
16889: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16893: LD_EXP 41
16897: PUSH
16898: LD_EXP 41
16902: PPUSH
16903: CALL_OW 305
16907: AND
16908: IFFALSE 16922
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16910: LD_EXP 41
16914: PPUSH
16915: LD_STRING DEnd-JMM-Sch-1
16917: PPUSH
16918: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16922: LD_EXP 37
16926: PUSH
16927: LD_EXP 37
16931: PPUSH
16932: CALL_OW 305
16936: AND
16937: IFFALSE 16951
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16939: LD_EXP 37
16943: PPUSH
16944: LD_STRING DEnd-JMM-Tit-1
16946: PPUSH
16947: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16951: LD_EXP 42
16955: PUSH
16956: LD_EXP 42
16960: PPUSH
16961: CALL_OW 305
16965: AND
16966: IFFALSE 16980
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16968: LD_EXP 42
16972: PPUSH
16973: LD_STRING DEnd-JMM-Obl-1
16975: PPUSH
16976: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16980: LD_EXP 44
16984: PUSH
16985: LD_EXP 44
16989: PPUSH
16990: CALL_OW 305
16994: AND
16995: IFFALSE 17009
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16997: LD_EXP 44
17001: PPUSH
17002: LD_STRING DEnd-JMM-Lip-1
17004: PPUSH
17005: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17009: LD_EXP 38
17013: PUSH
17014: LD_EXP 38
17018: PPUSH
17019: CALL_OW 305
17023: AND
17024: PUSH
17025: LD_EXP 49
17029: AND
17030: IFFALSE 17044
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17032: LD_EXP 38
17036: PPUSH
17037: LD_STRING DEnd-Burlak-Fad-1
17039: PPUSH
17040: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17044: LD_EXP 45
17048: PUSH
17049: LD_EXP 45
17053: PPUSH
17054: CALL_OW 305
17058: AND
17059: IFFALSE 17073
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17061: LD_EXP 45
17065: PPUSH
17066: LD_STRING DEnd-Burlak-Ptr-1
17068: PPUSH
17069: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17073: LD_EXP 47
17077: PUSH
17078: LD_EXP 47
17082: PPUSH
17083: CALL_OW 305
17087: AND
17088: IFFALSE 17102
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17090: LD_EXP 47
17094: PPUSH
17095: LD_STRING DEnd-Burlak-Kuz-1
17097: PPUSH
17098: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17102: LD_EXP 36
17106: PUSH
17107: LD_EXP 36
17111: PPUSH
17112: CALL_OW 305
17116: AND
17117: PUSH
17118: LD_EXP 49
17122: AND
17123: IFFALSE 17137
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17125: LD_EXP 36
17129: PPUSH
17130: LD_STRING DEnd-Burlak-Kir-1
17132: PPUSH
17133: CALL_OW 88
// if Burlak then
17137: LD_EXP 49
17141: IFFALSE 17155
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17143: LD_EXP 17
17147: PPUSH
17148: LD_STRING DEnd-Burlak-JMM-1
17150: PPUSH
17151: CALL_OW 88
// dwait ( 0 0$2 ) ;
17155: LD_INT 70
17157: PPUSH
17158: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17162: LD_EXP 54
17166: PPUSH
17167: LD_STRING DEnd-Szulc
17169: PPUSH
17170: CALL_OW 94
// dwait ( 0 0$1 ) ;
17174: LD_INT 35
17176: PPUSH
17177: CALL_OW 68
// if IsLive ( Burlak ) then
17181: LD_EXP 49
17185: PPUSH
17186: CALL_OW 300
17190: IFFALSE 17202
// med1 := 1 else
17192: LD_ADDR_VAR 0 1
17196: PUSH
17197: LD_INT 1
17199: ST_TO_ADDR
17200: GO 17211
// med1 := - 1 ;
17202: LD_ADDR_VAR 0 1
17206: PUSH
17207: LD_INT 1
17209: NEG
17210: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17211: LD_EXP 12
17215: PUSH
17216: LD_EXP 13
17220: AND
17221: PUSH
17222: LD_EXP 14
17226: AND
17227: IFFALSE 17239
// med2 := 1 else
17229: LD_ADDR_VAR 0 2
17233: PUSH
17234: LD_INT 1
17236: ST_TO_ADDR
17237: GO 17248
// med2 := - 1 ;
17239: LD_ADDR_VAR 0 2
17243: PUSH
17244: LD_INT 1
17246: NEG
17247: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17248: LD_STRING Hero
17250: PPUSH
17251: LD_INT 1
17253: PPUSH
17254: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17258: LD_STRING Artefact
17260: PPUSH
17261: LD_VAR 0 2
17265: PPUSH
17266: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17270: LD_STRING ReconcileBurlak
17272: PPUSH
17273: LD_VAR 0 1
17277: PPUSH
17278: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17282: LD_OWVAR 67
17286: PUSH
17287: LD_INT 3
17289: GREATEREQUAL
17290: PUSH
17291: LD_VAR 0 1
17295: PUSH
17296: LD_INT 1
17298: EQUAL
17299: AND
17300: PUSH
17301: LD_VAR 0 2
17305: PUSH
17306: LD_INT 1
17308: EQUAL
17309: AND
17310: IFFALSE 17322
// SetAchievementEX ( ACH_AMER , 19 ) ;
17312: LD_STRING ACH_AMER
17314: PPUSH
17315: LD_INT 19
17317: PPUSH
17318: CALL_OW 564
// GiveMedals ( MAIN ) ;
17322: LD_STRING MAIN
17324: PPUSH
17325: CALL_OW 102
// InGameOff ;
17329: CALL_OW 9
// DialogueOff ;
17333: CALL_OW 7
// music_nat := 1 ;
17337: LD_ADDR_OWVAR 71
17341: PUSH
17342: LD_INT 1
17344: ST_TO_ADDR
// music_class := 4 ;
17345: LD_ADDR_OWVAR 72
17349: PUSH
17350: LD_INT 4
17352: ST_TO_ADDR
// YouWin ;
17353: CALL_OW 103
// end ; end_of_file
17357: PPOPN 2
17359: END
// export function InitNature ; begin
17360: LD_INT 0
17362: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17363: LD_INT 3
17365: PPUSH
17366: LD_INT 3
17368: PPUSH
17369: LD_INT 2
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: LD_INT 1
17377: PPUSH
17378: LD_INT 0
17380: PPUSH
17381: LD_INT 0
17383: PPUSH
17384: LD_INT 17
17386: PPUSH
17387: LD_INT 0
17389: PPUSH
17390: CALL 84851 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17394: LD_INT 2
17396: PPUSH
17397: LD_INT 1
17399: PPUSH
17400: LD_INT 1
17402: PPUSH
17403: LD_INT 1
17405: PPUSH
17406: LD_INT 1
17408: PPUSH
17409: LD_INT 0
17411: PPUSH
17412: LD_INT 0
17414: PPUSH
17415: LD_INT 18
17417: PPUSH
17418: LD_INT 0
17420: PPUSH
17421: CALL 84851 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17425: LD_INT 4
17427: PPUSH
17428: LD_INT 1
17430: PPUSH
17431: LD_INT 2
17433: PPUSH
17434: LD_INT 4
17436: PPUSH
17437: LD_INT 2
17439: PPUSH
17440: LD_INT 1
17442: PPUSH
17443: LD_INT 0
17445: PPUSH
17446: LD_INT 19
17448: PPUSH
17449: LD_INT 0
17451: PPUSH
17452: CALL 84851 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17456: LD_INT 0
17458: PPUSH
17459: LD_INT 0
17461: PPUSH
17462: LD_INT 0
17464: PPUSH
17465: LD_INT 0
17467: PPUSH
17468: LD_INT 0
17470: PPUSH
17471: LD_INT 0
17473: PPUSH
17474: LD_INT 9
17476: PPUSH
17477: LD_INT 0
17479: PPUSH
17480: LD_INT 20
17482: PPUSH
17483: CALL 84851 0 9
// end ; end_of_file
17487: LD_VAR 0 1
17491: RET
// every 0 0$30 do var time ;
17492: GO 17494
17494: DISABLE
17495: LD_INT 0
17497: PPUSH
// begin time := 0 0$30 ;
17498: LD_ADDR_VAR 0 1
17502: PUSH
17503: LD_INT 1050
17505: ST_TO_ADDR
// repeat wait ( time ) ;
17506: LD_VAR 0 1
17510: PPUSH
17511: CALL_OW 67
// if Prob ( 50 ) then
17515: LD_INT 50
17517: PPUSH
17518: CALL_OW 13
17522: IFFALSE 17551
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17524: LD_INT 1
17526: PPUSH
17527: LD_INT 5
17529: PPUSH
17530: CALL_OW 12
17534: PPUSH
17535: LD_INT 106
17537: PPUSH
17538: LD_INT 89
17540: PPUSH
17541: LD_INT 45
17543: PPUSH
17544: LD_INT 1
17546: PPUSH
17547: CALL_OW 56
// time := time + 0 0$3 ;
17551: LD_ADDR_VAR 0 1
17555: PUSH
17556: LD_VAR 0 1
17560: PUSH
17561: LD_INT 105
17563: PLUS
17564: ST_TO_ADDR
// if Prob ( 30 ) then
17565: LD_INT 30
17567: PPUSH
17568: CALL_OW 13
17572: IFFALSE 17618
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17574: LD_INT 525
17576: PPUSH
17577: LD_INT 735
17579: PPUSH
17580: CALL_OW 12
17584: PPUSH
17585: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17589: LD_INT 1
17591: PPUSH
17592: LD_INT 5
17594: PPUSH
17595: CALL_OW 12
17599: PPUSH
17600: LD_INT 21
17602: PPUSH
17603: LD_INT 26
17605: PPUSH
17606: LD_INT 12
17608: PPUSH
17609: LD_INT 1
17611: PPUSH
17612: CALL_OW 56
// end else
17616: GO 17654
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17618: LD_INT 700
17620: PPUSH
17621: LD_INT 1225
17623: PPUSH
17624: CALL_OW 12
17628: PPUSH
17629: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17633: LD_INT 1
17635: PPUSH
17636: LD_INT 5
17638: PPUSH
17639: CALL_OW 12
17643: PPUSH
17644: LD_INT 14
17646: PPUSH
17647: LD_INT 1
17649: PPUSH
17650: CALL_OW 55
// end ; if Prob ( 50 ) then
17654: LD_INT 50
17656: PPUSH
17657: CALL_OW 13
17661: IFFALSE 17707
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17663: LD_INT 700
17665: PPUSH
17666: LD_INT 1050
17668: PPUSH
17669: CALL_OW 12
17673: PPUSH
17674: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17678: LD_INT 1
17680: PPUSH
17681: LD_INT 5
17683: PPUSH
17684: CALL_OW 12
17688: PPUSH
17689: LD_INT 181
17691: PPUSH
17692: LD_INT 218
17694: PPUSH
17695: LD_INT 16
17697: PPUSH
17698: LD_INT 1
17700: PPUSH
17701: CALL_OW 56
// end else
17705: GO 17779
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17707: LD_INT 350
17709: PPUSH
17710: LD_INT 525
17712: PPUSH
17713: CALL_OW 12
17717: PPUSH
17718: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17722: LD_INT 1
17724: PPUSH
17725: LD_INT 5
17727: PPUSH
17728: CALL_OW 12
17732: PPUSH
17733: LD_INT 13
17735: PPUSH
17736: LD_INT 1
17738: PPUSH
17739: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17743: LD_INT 350
17745: PPUSH
17746: LD_INT 700
17748: PPUSH
17749: CALL_OW 12
17753: PPUSH
17754: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17758: LD_INT 1
17760: PPUSH
17761: LD_INT 5
17763: PPUSH
17764: CALL_OW 12
17768: PPUSH
17769: LD_INT 33
17771: PPUSH
17772: LD_INT 1
17774: PPUSH
17775: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
17779: LD_INT 65
17781: PUSH
17782: LD_INT 62
17784: PUSH
17785: LD_INT 55
17787: PUSH
17788: LD_INT 50
17790: PUSH
17791: EMPTY
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: PUSH
17797: LD_OWVAR 67
17801: ARRAY
17802: PPUSH
17803: CALL_OW 13
17807: IFFALSE 17853
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17809: LD_INT 525
17811: PPUSH
17812: LD_INT 875
17814: PPUSH
17815: CALL_OW 12
17819: PPUSH
17820: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17824: LD_INT 1
17826: PPUSH
17827: LD_INT 5
17829: PPUSH
17830: CALL_OW 12
17834: PPUSH
17835: LD_INT 294
17837: PPUSH
17838: LD_INT 211
17840: PPUSH
17841: LD_INT 30
17843: PPUSH
17844: LD_INT 1
17846: PPUSH
17847: CALL_OW 56
// end else
17851: GO 17895
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17853: LD_INT 420
17855: PPUSH
17856: LD_INT 770
17858: PPUSH
17859: CALL_OW 12
17863: PPUSH
17864: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17868: LD_INT 1
17870: PPUSH
17871: LD_INT 5
17873: PPUSH
17874: CALL_OW 12
17878: PPUSH
17879: LD_INT 294
17881: PPUSH
17882: LD_INT 211
17884: PPUSH
17885: LD_INT 30
17887: PPUSH
17888: LD_INT 1
17890: PPUSH
17891: CALL_OW 56
// end ; if time > 2 2$20 then
17895: LD_VAR 0 1
17899: PUSH
17900: LD_INT 4900
17902: GREATER
17903: IFFALSE 17913
// time := 0 0$50 ;
17905: LD_ADDR_VAR 0 1
17909: PUSH
17910: LD_INT 1750
17912: ST_TO_ADDR
// until false ;
17913: LD_INT 0
17915: IFFALSE 17506
// end ;
17917: PPOPN 1
17919: END
// every 0 0$45 trigger tick < 10 10$00 do
17920: LD_OWVAR 1
17924: PUSH
17925: LD_INT 21000
17927: LESS
17928: IFFALSE 17976
17930: GO 17932
17932: DISABLE
// begin enable ;
17933: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17934: LD_INT 350
17936: PPUSH
17937: LD_INT 700
17939: PPUSH
17940: CALL_OW 12
17944: PPUSH
17945: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17949: LD_INT 3
17951: PPUSH
17952: LD_INT 5
17954: PPUSH
17955: CALL_OW 12
17959: PPUSH
17960: LD_INT 181
17962: PPUSH
17963: LD_INT 13
17965: PPUSH
17966: LD_INT 20
17968: PPUSH
17969: LD_INT 1
17971: PPUSH
17972: CALL_OW 56
// end ; end_of_file
17976: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17977: LD_INT 0
17979: PPUSH
// SetArtifactRes ( 7 , true ) ;
17980: LD_INT 7
17982: PPUSH
17983: LD_INT 1
17985: PPUSH
17986: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17990: LD_ADDR_EXP 62
17994: PUSH
17995: EMPTY
17996: PUSH
17997: EMPTY
17998: PUSH
17999: EMPTY
18000: PUSH
18001: EMPTY
18002: LIST
18003: LIST
18004: LIST
18005: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18006: LD_ADDR_EXP 63
18010: PUSH
18011: LD_INT 1050
18013: PUSH
18014: LD_OWVAR 67
18018: MUL
18019: PUSH
18020: LD_INT 2800
18022: PUSH
18023: LD_OWVAR 67
18027: MUL
18028: PUSH
18029: LD_INT 1
18031: NEG
18032: PUSH
18033: EMPTY
18034: LIST
18035: LIST
18036: LIST
18037: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18038: LD_ADDR_EXP 64
18042: PUSH
18043: LD_INT 10
18045: PUSH
18046: LD_INT 35
18048: PUSH
18049: LD_INT 100
18051: PUSH
18052: EMPTY
18053: LIST
18054: LIST
18055: LIST
18056: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18057: LD_ADDR_EXP 65
18061: PUSH
18062: LD_INT 0
18064: PUSH
18065: LD_INT 0
18067: PUSH
18068: LD_INT 0
18070: PUSH
18071: EMPTY
18072: LIST
18073: LIST
18074: LIST
18075: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18076: LD_ADDR_EXP 67
18080: PUSH
18081: LD_INT 300
18083: PUSH
18084: LD_INT 500
18086: PUSH
18087: LD_INT 800
18089: PUSH
18090: EMPTY
18091: LIST
18092: LIST
18093: LIST
18094: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18095: LD_ADDR_EXP 68
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: LD_INT 0
18105: PUSH
18106: LD_INT 0
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18114: LD_ADDR_EXP 69
18118: PUSH
18119: LD_INT 0
18121: PUSH
18122: LD_INT 0
18124: PUSH
18125: LD_INT 0
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: LIST
18132: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18133: LD_ADDR_EXP 66
18137: PUSH
18138: LD_INT 0
18140: PUSH
18141: LD_INT 0
18143: PUSH
18144: LD_INT 0
18146: PUSH
18147: EMPTY
18148: LIST
18149: LIST
18150: LIST
18151: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18152: LD_ADDR_EXP 70
18156: PUSH
18157: LD_INT 4
18159: PUSH
18160: LD_INT 3
18162: PUSH
18163: LD_INT 1
18165: PUSH
18166: EMPTY
18167: LIST
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 5
18173: PUSH
18174: LD_INT 4
18176: PUSH
18177: LD_INT 2
18179: PUSH
18180: EMPTY
18181: LIST
18182: LIST
18183: LIST
18184: PUSH
18185: LD_INT 6
18187: PUSH
18188: LD_INT 3
18190: PUSH
18191: LD_INT 3
18193: PUSH
18194: EMPTY
18195: LIST
18196: LIST
18197: LIST
18198: PUSH
18199: EMPTY
18200: LIST
18201: LIST
18202: LIST
18203: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18204: LD_ADDR_EXP 71
18208: PUSH
18209: LD_INT 0
18211: PUSH
18212: LD_INT 0
18214: PUSH
18215: LD_INT 0
18217: PUSH
18218: EMPTY
18219: LIST
18220: LIST
18221: LIST
18222: ST_TO_ADDR
// end ;
18223: LD_VAR 0 1
18227: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18228: LD_INT 24
18230: PPUSH
18231: LD_INT 7
18233: PPUSH
18234: CALL_OW 321
18238: PUSH
18239: LD_INT 2
18241: EQUAL
18242: IFFALSE 19168
18244: GO 18246
18246: DISABLE
18247: LD_INT 0
18249: PPUSH
18250: PPUSH
18251: PPUSH
18252: PPUSH
18253: PPUSH
// begin enable ;
18254: ENABLE
// for i = 1 to 3 do
18255: LD_ADDR_VAR 0 1
18259: PUSH
18260: DOUBLE
18261: LD_INT 1
18263: DEC
18264: ST_TO_ADDR
18265: LD_INT 3
18267: PUSH
18268: FOR_TO
18269: IFFALSE 19166
// begin pos := FindArtifact ( i + 2 ) ;
18271: LD_ADDR_VAR 0 2
18275: PUSH
18276: LD_VAR 0 1
18280: PUSH
18281: LD_INT 2
18283: PLUS
18284: PPUSH
18285: CALL_OW 469
18289: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18290: LD_ADDR_EXP 62
18294: PUSH
18295: LD_EXP 62
18299: PPUSH
18300: LD_VAR 0 1
18304: PPUSH
18305: LD_VAR 0 2
18309: PPUSH
18310: CALL_OW 1
18314: ST_TO_ADDR
// if pos then
18315: LD_VAR 0 2
18319: IFFALSE 19027
// begin case i of 1 :
18321: LD_VAR 0 1
18325: PUSH
18326: LD_INT 1
18328: DOUBLE
18329: EQUAL
18330: IFTRUE 18334
18332: GO 18411
18334: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18335: LD_ADDR_VAR 0 4
18339: PUSH
18340: LD_INT 22
18342: PUSH
18343: LD_INT 7
18345: PUSH
18346: EMPTY
18347: LIST
18348: LIST
18349: PUSH
18350: LD_INT 23
18352: PUSH
18353: LD_INT 1
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: PUSH
18360: LD_INT 2
18362: PUSH
18363: LD_INT 30
18365: PUSH
18366: LD_INT 8
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: PUSH
18373: LD_INT 30
18375: PUSH
18376: LD_INT 7
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 30
18385: PUSH
18386: LD_INT 11
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: LIST
18397: LIST
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: LIST
18403: PPUSH
18404: CALL_OW 69
18408: ST_TO_ADDR
18409: GO 18519
18411: LD_INT 2
18413: DOUBLE
18414: EQUAL
18415: IFTRUE 18419
18417: GO 18496
18419: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18420: LD_ADDR_VAR 0 4
18424: PUSH
18425: LD_INT 22
18427: PUSH
18428: LD_INT 7
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: PUSH
18435: LD_INT 23
18437: PUSH
18438: LD_INT 3
18440: PUSH
18441: EMPTY
18442: LIST
18443: LIST
18444: PUSH
18445: LD_INT 2
18447: PUSH
18448: LD_INT 30
18450: PUSH
18451: LD_INT 8
18453: PUSH
18454: EMPTY
18455: LIST
18456: LIST
18457: PUSH
18458: LD_INT 30
18460: PUSH
18461: LD_INT 7
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: PUSH
18468: LD_INT 30
18470: PUSH
18471: LD_INT 11
18473: PUSH
18474: EMPTY
18475: LIST
18476: LIST
18477: PUSH
18478: EMPTY
18479: LIST
18480: LIST
18481: LIST
18482: LIST
18483: PUSH
18484: EMPTY
18485: LIST
18486: LIST
18487: LIST
18488: PPUSH
18489: CALL_OW 69
18493: ST_TO_ADDR
18494: GO 18519
18496: LD_INT 3
18498: DOUBLE
18499: EQUAL
18500: IFTRUE 18504
18502: GO 18518
18504: POP
// labs := [ alien ] ; end ;
18505: LD_ADDR_VAR 0 4
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: EMPTY
18514: LIST
18515: ST_TO_ADDR
18516: GO 18519
18518: POP
// if not labs then
18519: LD_VAR 0 4
18523: NOT
18524: IFFALSE 18528
// continue ;
18526: GO 18268
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18528: LD_ADDR_VAR 0 5
18532: PUSH
18533: LD_VAR 0 4
18537: PPUSH
18538: LD_EXP 62
18542: PUSH
18543: LD_VAR 0 1
18547: ARRAY
18548: PUSH
18549: LD_INT 1
18551: ARRAY
18552: PPUSH
18553: LD_EXP 62
18557: PUSH
18558: LD_VAR 0 1
18562: ARRAY
18563: PUSH
18564: LD_INT 2
18566: ARRAY
18567: PPUSH
18568: CALL_OW 73
18572: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18573: LD_VAR 0 5
18577: NOT
18578: PUSH
18579: LD_VAR 0 5
18583: PUSH
18584: LD_EXP 69
18588: PUSH
18589: LD_VAR 0 1
18593: ARRAY
18594: NONEQUAL
18595: OR
18596: IFFALSE 18701
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18598: LD_INT 7
18600: PPUSH
18601: LD_EXP 70
18605: PUSH
18606: LD_VAR 0 1
18610: ARRAY
18611: PUSH
18612: LD_INT 3
18614: ARRAY
18615: PPUSH
18616: LD_INT 0
18618: PPUSH
18619: LD_EXP 69
18623: PUSH
18624: LD_VAR 0 1
18628: ARRAY
18629: PPUSH
18630: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18634: LD_INT 7
18636: PPUSH
18637: LD_EXP 70
18641: PUSH
18642: LD_VAR 0 1
18646: ARRAY
18647: PUSH
18648: LD_INT 1
18650: ARRAY
18651: PPUSH
18652: LD_INT 0
18654: PPUSH
18655: LD_EXP 69
18659: PUSH
18660: LD_VAR 0 1
18664: ARRAY
18665: PPUSH
18666: CALL_OW 468
// if nearestLab then
18670: LD_VAR 0 5
18674: IFFALSE 18701
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18676: LD_ADDR_EXP 69
18680: PUSH
18681: LD_EXP 69
18685: PPUSH
18686: LD_VAR 0 1
18690: PPUSH
18691: LD_VAR 0 5
18695: PPUSH
18696: CALL_OW 1
18700: ST_TO_ADDR
// end ; if not nearestLab then
18701: LD_VAR 0 5
18705: NOT
18706: IFFALSE 18710
// continue ;
18708: GO 18268
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18710: LD_VAR 0 5
18714: PPUSH
18715: LD_EXP 62
18719: PUSH
18720: LD_VAR 0 1
18724: ARRAY
18725: PUSH
18726: LD_INT 1
18728: ARRAY
18729: PPUSH
18730: LD_EXP 62
18734: PUSH
18735: LD_VAR 0 1
18739: ARRAY
18740: PUSH
18741: LD_INT 2
18743: ARRAY
18744: PPUSH
18745: CALL_OW 297
18749: PUSH
18750: LD_INT 8
18752: LESS
18753: IFFALSE 18950
// begin if not artifactsResearched [ i ] then
18755: LD_EXP 65
18759: PUSH
18760: LD_VAR 0 1
18764: ARRAY
18765: NOT
18766: IFFALSE 18847
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18768: LD_VAR 0 5
18772: PPUSH
18773: CALL_OW 461
18777: PUSH
18778: LD_INT 2
18780: EQUAL
18781: IFFALSE 18815
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18783: LD_INT 7
18785: PPUSH
18786: LD_EXP 70
18790: PUSH
18791: LD_VAR 0 1
18795: ARRAY
18796: PUSH
18797: LD_INT 3
18799: ARRAY
18800: PPUSH
18801: LD_INT 2
18803: PPUSH
18804: LD_VAR 0 5
18808: PPUSH
18809: CALL_OW 468
18813: GO 18845
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18815: LD_INT 7
18817: PPUSH
18818: LD_EXP 70
18822: PUSH
18823: LD_VAR 0 1
18827: ARRAY
18828: PUSH
18829: LD_INT 3
18831: ARRAY
18832: PPUSH
18833: LD_INT 1
18835: PPUSH
18836: LD_VAR 0 5
18840: PPUSH
18841: CALL_OW 468
// end else
18845: GO 18948
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18847: LD_VAR 0 5
18851: PPUSH
18852: CALL_OW 461
18856: PUSH
18857: LD_INT 2
18859: EQUAL
18860: PUSH
18861: LD_EXP 71
18865: PUSH
18866: LD_VAR 0 1
18870: ARRAY
18871: AND
18872: IFFALSE 18918
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18874: LD_INT 7
18876: PPUSH
18877: LD_EXP 70
18881: PUSH
18882: LD_VAR 0 1
18886: ARRAY
18887: PUSH
18888: LD_INT 1
18890: ARRAY
18891: PPUSH
18892: LD_EXP 70
18896: PUSH
18897: LD_VAR 0 1
18901: ARRAY
18902: PUSH
18903: LD_INT 2
18905: ARRAY
18906: PPUSH
18907: LD_VAR 0 5
18911: PPUSH
18912: CALL_OW 468
18916: GO 18948
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18918: LD_INT 7
18920: PPUSH
18921: LD_EXP 70
18925: PUSH
18926: LD_VAR 0 1
18930: ARRAY
18931: PUSH
18932: LD_INT 1
18934: ARRAY
18935: PPUSH
18936: LD_INT 1
18938: PPUSH
18939: LD_VAR 0 5
18943: PPUSH
18944: CALL_OW 468
// end else
18948: GO 19025
// begin if not artifactsResearched [ i ] then
18950: LD_EXP 65
18954: PUSH
18955: LD_VAR 0 1
18959: ARRAY
18960: NOT
18961: IFFALSE 18995
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18963: LD_INT 7
18965: PPUSH
18966: LD_EXP 70
18970: PUSH
18971: LD_VAR 0 1
18975: ARRAY
18976: PUSH
18977: LD_INT 3
18979: ARRAY
18980: PPUSH
18981: LD_INT 0
18983: PPUSH
18984: LD_VAR 0 5
18988: PPUSH
18989: CALL_OW 468
18993: GO 19025
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18995: LD_INT 7
18997: PPUSH
18998: LD_EXP 70
19002: PUSH
19003: LD_VAR 0 1
19007: ARRAY
19008: PUSH
19009: LD_INT 1
19011: ARRAY
19012: PPUSH
19013: LD_INT 0
19015: PPUSH
19016: LD_VAR 0 5
19020: PPUSH
19021: CALL_OW 468
// end ; end else
19025: GO 19164
// begin if not artifactsLabs [ i ] then
19027: LD_EXP 69
19031: PUSH
19032: LD_VAR 0 1
19036: ARRAY
19037: NOT
19038: IFFALSE 19042
// continue ;
19040: GO 18268
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19042: LD_INT 7
19044: PPUSH
19045: LD_EXP 70
19049: PUSH
19050: LD_VAR 0 1
19054: ARRAY
19055: PUSH
19056: LD_INT 3
19058: ARRAY
19059: PPUSH
19060: LD_INT 0
19062: PPUSH
19063: LD_EXP 69
19067: PUSH
19068: LD_VAR 0 1
19072: ARRAY
19073: PPUSH
19074: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19078: LD_INT 7
19080: PPUSH
19081: LD_EXP 70
19085: PUSH
19086: LD_VAR 0 1
19090: ARRAY
19091: PUSH
19092: LD_INT 1
19094: ARRAY
19095: PPUSH
19096: LD_INT 0
19098: PPUSH
19099: LD_EXP 69
19103: PUSH
19104: LD_VAR 0 1
19108: ARRAY
19109: PPUSH
19110: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19114: LD_EXP 66
19118: PUSH
19119: LD_VAR 0 1
19123: ARRAY
19124: IFFALSE 19164
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19126: LD_ADDR_EXP 66
19130: PUSH
19131: LD_EXP 66
19135: PPUSH
19136: LD_VAR 0 1
19140: PPUSH
19141: LD_INT 0
19143: PPUSH
19144: CALL_OW 1
19148: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19149: LD_EXP 69
19153: PUSH
19154: LD_VAR 0 1
19158: ARRAY
19159: PPUSH
19160: CALL_OW 127
// end ; end ; end ;
19164: GO 18268
19166: POP
19167: POP
// end ;
19168: PPOPN 5
19170: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19171: LD_INT 0
19173: PPUSH
19174: PPUSH
19175: PPUSH
19176: PPUSH
19177: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19178: LD_VAR 0 2
19182: PUSH
19183: LD_EXP 70
19187: PUSH
19188: LD_INT 1
19190: ARRAY
19191: PUSH
19192: LD_INT 3
19194: ARRAY
19195: EQUAL
19196: IFFALSE 19319
// begin lab := artifactsLabs [ 1 ] ;
19198: LD_ADDR_VAR 0 6
19202: PUSH
19203: LD_EXP 69
19207: PUSH
19208: LD_INT 1
19210: ARRAY
19211: ST_TO_ADDR
// if not lab then
19212: LD_VAR 0 6
19216: NOT
19217: IFFALSE 19221
// exit ;
19219: GO 20299
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19221: LD_VAR 0 6
19225: PPUSH
19226: LD_EXP 67
19230: PUSH
19231: LD_INT 1
19233: ARRAY
19234: PPUSH
19235: LD_INT 1
19237: PPUSH
19238: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19242: LD_EXP 68
19246: PUSH
19247: LD_INT 1
19249: ARRAY
19250: IFFALSE 19270
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19252: LD_VAR 0 6
19256: PPUSH
19257: LD_EXP 68
19261: PUSH
19262: LD_INT 1
19264: ARRAY
19265: PPUSH
19266: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19270: LD_ADDR_EXP 66
19274: PUSH
19275: LD_EXP 66
19279: PPUSH
19280: LD_INT 1
19282: PPUSH
19283: LD_INT 1
19285: PPUSH
19286: CALL_OW 1
19290: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19291: LD_INT 7
19293: PPUSH
19294: LD_EXP 70
19298: PUSH
19299: LD_INT 1
19301: ARRAY
19302: PUSH
19303: LD_INT 3
19305: ARRAY
19306: PPUSH
19307: LD_INT 0
19309: PPUSH
19310: LD_VAR 0 6
19314: PPUSH
19315: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19319: LD_VAR 0 2
19323: PUSH
19324: LD_EXP 70
19328: PUSH
19329: LD_INT 2
19331: ARRAY
19332: PUSH
19333: LD_INT 3
19335: ARRAY
19336: EQUAL
19337: IFFALSE 19460
// begin lab := artifactsLabs [ 2 ] ;
19339: LD_ADDR_VAR 0 6
19343: PUSH
19344: LD_EXP 69
19348: PUSH
19349: LD_INT 2
19351: ARRAY
19352: ST_TO_ADDR
// if not lab then
19353: LD_VAR 0 6
19357: NOT
19358: IFFALSE 19362
// exit ;
19360: GO 20299
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19362: LD_VAR 0 6
19366: PPUSH
19367: LD_EXP 67
19371: PUSH
19372: LD_INT 2
19374: ARRAY
19375: PPUSH
19376: LD_INT 1
19378: PPUSH
19379: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19383: LD_EXP 68
19387: PUSH
19388: LD_INT 2
19390: ARRAY
19391: IFFALSE 19411
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19393: LD_VAR 0 6
19397: PPUSH
19398: LD_EXP 68
19402: PUSH
19403: LD_INT 2
19405: ARRAY
19406: PPUSH
19407: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19411: LD_ADDR_EXP 66
19415: PUSH
19416: LD_EXP 66
19420: PPUSH
19421: LD_INT 2
19423: PPUSH
19424: LD_INT 1
19426: PPUSH
19427: CALL_OW 1
19431: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19432: LD_INT 7
19434: PPUSH
19435: LD_EXP 70
19439: PUSH
19440: LD_INT 2
19442: ARRAY
19443: PUSH
19444: LD_INT 3
19446: ARRAY
19447: PPUSH
19448: LD_INT 0
19450: PPUSH
19451: LD_VAR 0 6
19455: PPUSH
19456: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19460: LD_VAR 0 2
19464: PUSH
19465: LD_EXP 70
19469: PUSH
19470: LD_INT 3
19472: ARRAY
19473: PUSH
19474: LD_INT 3
19476: ARRAY
19477: EQUAL
19478: IFFALSE 19601
// begin lab := artifactsLabs [ 3 ] ;
19480: LD_ADDR_VAR 0 6
19484: PUSH
19485: LD_EXP 69
19489: PUSH
19490: LD_INT 3
19492: ARRAY
19493: ST_TO_ADDR
// if not lab then
19494: LD_VAR 0 6
19498: NOT
19499: IFFALSE 19503
// exit ;
19501: GO 20299
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19503: LD_VAR 0 6
19507: PPUSH
19508: LD_EXP 67
19512: PUSH
19513: LD_INT 3
19515: ARRAY
19516: PPUSH
19517: LD_INT 1
19519: PPUSH
19520: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19524: LD_EXP 68
19528: PUSH
19529: LD_INT 3
19531: ARRAY
19532: IFFALSE 19552
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19534: LD_VAR 0 6
19538: PPUSH
19539: LD_EXP 68
19543: PUSH
19544: LD_INT 3
19546: ARRAY
19547: PPUSH
19548: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19552: LD_ADDR_EXP 66
19556: PUSH
19557: LD_EXP 66
19561: PPUSH
19562: LD_INT 3
19564: PPUSH
19565: LD_INT 1
19567: PPUSH
19568: CALL_OW 1
19572: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19573: LD_INT 7
19575: PPUSH
19576: LD_EXP 70
19580: PUSH
19581: LD_INT 3
19583: ARRAY
19584: PUSH
19585: LD_INT 3
19587: ARRAY
19588: PPUSH
19589: LD_INT 0
19591: PPUSH
19592: LD_VAR 0 6
19596: PPUSH
19597: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19601: LD_VAR 0 2
19605: PUSH
19606: LD_EXP 70
19610: PUSH
19611: LD_INT 1
19613: ARRAY
19614: PUSH
19615: LD_INT 1
19617: ARRAY
19618: EQUAL
19619: IFFALSE 19777
// begin lab := artifactsLabs [ 1 ] ;
19621: LD_ADDR_VAR 0 6
19625: PUSH
19626: LD_EXP 69
19630: PUSH
19631: LD_INT 1
19633: ARRAY
19634: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19635: LD_VAR 0 6
19639: PPUSH
19640: CALL_OW 274
19644: PPUSH
19645: CALL 88455 0 1
19649: PUSH
19650: LD_INT 3
19652: ARRAY
19653: PUSH
19654: LD_EXP 64
19658: PUSH
19659: LD_INT 1
19661: ARRAY
19662: LESS
19663: IFFALSE 19677
// begin HintSpec ( ArtifactCost , 2 ) ;
19665: LD_STRING ArtifactCost
19667: PPUSH
19668: LD_INT 2
19670: PPUSH
19671: CALL_OW 338
// exit ;
19675: GO 20299
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19677: LD_ADDR_EXP 71
19681: PUSH
19682: LD_EXP 71
19686: PPUSH
19687: LD_INT 1
19689: PPUSH
19690: LD_INT 0
19692: PPUSH
19693: CALL_OW 1
19697: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19698: LD_VAR 0 3
19702: PPUSH
19703: LD_VAR 0 4
19707: PPUSH
19708: LD_INT 7
19710: PPUSH
19711: LD_INT 12
19713: NEG
19714: PPUSH
19715: CALL_OW 330
// wait ( 0 0$30 ) ;
19719: LD_INT 1050
19721: PPUSH
19722: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19726: LD_VAR 0 3
19730: PPUSH
19731: LD_VAR 0 4
19735: PPUSH
19736: LD_INT 7
19738: PPUSH
19739: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19743: LD_EXP 63
19747: PUSH
19748: LD_INT 1
19750: ARRAY
19751: PPUSH
19752: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19756: LD_ADDR_EXP 71
19760: PUSH
19761: LD_EXP 71
19765: PPUSH
19766: LD_INT 1
19768: PPUSH
19769: LD_INT 1
19771: PPUSH
19772: CALL_OW 1
19776: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19777: LD_VAR 0 2
19781: PUSH
19782: LD_EXP 70
19786: PUSH
19787: LD_INT 2
19789: ARRAY
19790: PUSH
19791: LD_INT 1
19793: ARRAY
19794: EQUAL
19795: IFFALSE 20032
// begin lab := artifactsLabs [ 2 ] ;
19797: LD_ADDR_VAR 0 6
19801: PUSH
19802: LD_EXP 69
19806: PUSH
19807: LD_INT 2
19809: ARRAY
19810: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19811: LD_VAR 0 3
19815: PUSH
19816: LD_INT 81
19818: PUSH
19819: LD_INT 7
19821: PUSH
19822: EMPTY
19823: LIST
19824: LIST
19825: PUSH
19826: LD_INT 2
19828: PUSH
19829: LD_INT 32
19831: PUSH
19832: LD_INT 3
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 28
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: PUSH
19849: LD_INT 30
19851: PUSH
19852: LD_INT 30
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: PUSH
19859: LD_INT 35
19861: PUSH
19862: LD_INT 49
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: PUSH
19869: LD_INT 34
19871: PUSH
19872: LD_INT 49
19874: PUSH
19875: EMPTY
19876: LIST
19877: LIST
19878: PUSH
19879: LD_INT 30
19881: PUSH
19882: LD_INT 21
19884: PUSH
19885: EMPTY
19886: LIST
19887: LIST
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: LIST
19893: LIST
19894: LIST
19895: LIST
19896: LIST
19897: PUSH
19898: EMPTY
19899: LIST
19900: LIST
19901: PPUSH
19902: CALL_OW 69
19906: IN
19907: NOT
19908: IFFALSE 19912
// exit ;
19910: GO 20299
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19912: LD_VAR 0 6
19916: PPUSH
19917: CALL_OW 274
19921: PPUSH
19922: CALL 88455 0 1
19926: PUSH
19927: LD_INT 3
19929: ARRAY
19930: PUSH
19931: LD_EXP 64
19935: PUSH
19936: LD_INT 2
19938: ARRAY
19939: LESS
19940: IFFALSE 19954
// begin HintSpec ( ArtifactCost , 2 ) ;
19942: LD_STRING ArtifactCost
19944: PPUSH
19945: LD_INT 2
19947: PPUSH
19948: CALL_OW 338
// exit ;
19952: GO 20299
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19954: LD_ADDR_EXP 71
19958: PUSH
19959: LD_EXP 71
19963: PPUSH
19964: LD_INT 2
19966: PPUSH
19967: LD_INT 0
19969: PPUSH
19970: CALL_OW 1
19974: ST_TO_ADDR
// KillUnit ( x ) ;
19975: LD_VAR 0 3
19979: PPUSH
19980: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19984: LD_ADDR_EXP 16
19988: PUSH
19989: LD_EXP 16
19993: PUSH
19994: LD_INT 1
19996: PLUS
19997: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19998: LD_EXP 63
20002: PUSH
20003: LD_INT 2
20005: ARRAY
20006: PPUSH
20007: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20011: LD_ADDR_EXP 71
20015: PUSH
20016: LD_EXP 71
20020: PPUSH
20021: LD_INT 2
20023: PPUSH
20024: LD_INT 1
20026: PPUSH
20027: CALL_OW 1
20031: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20032: LD_VAR 0 2
20036: PUSH
20037: LD_EXP 70
20041: PUSH
20042: LD_INT 3
20044: ARRAY
20045: PUSH
20046: LD_INT 1
20048: ARRAY
20049: EQUAL
20050: IFFALSE 20299
// begin lab := artifactsLabs [ 3 ] ;
20052: LD_ADDR_VAR 0 6
20056: PUSH
20057: LD_EXP 69
20061: PUSH
20062: LD_INT 3
20064: ARRAY
20065: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20066: LD_VAR 0 6
20070: PPUSH
20071: CALL_OW 274
20075: PPUSH
20076: CALL 88455 0 1
20080: PUSH
20081: LD_INT 3
20083: ARRAY
20084: PUSH
20085: LD_EXP 64
20089: PUSH
20090: LD_INT 3
20092: ARRAY
20093: LESS
20094: IFFALSE 20108
// begin HintSpec ( ArtifactCost , 2 ) ;
20096: LD_STRING ArtifactCost
20098: PPUSH
20099: LD_INT 2
20101: PPUSH
20102: CALL_OW 338
// exit ;
20106: GO 20299
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20108: LD_INT 37
20110: PPUSH
20111: LD_INT 1
20113: PPUSH
20114: CALL_OW 424
// time := 0 0$30 ;
20118: LD_ADDR_VAR 0 7
20122: PUSH
20123: LD_INT 1050
20125: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20126: LD_ADDR_EXP 71
20130: PUSH
20131: LD_EXP 71
20135: PPUSH
20136: LD_INT 3
20138: PPUSH
20139: LD_INT 0
20141: PPUSH
20142: CALL_OW 1
20146: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20147: LD_ADDR_OWVAR 47
20151: PUSH
20152: LD_STRING #Am15a-1
20154: PUSH
20155: LD_VAR 0 7
20159: PUSH
20160: EMPTY
20161: LIST
20162: LIST
20163: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20164: LD_INT 35
20166: PPUSH
20167: CALL_OW 67
// time := time - 0 0$1 ;
20171: LD_ADDR_VAR 0 7
20175: PUSH
20176: LD_VAR 0 7
20180: PUSH
20181: LD_INT 35
20183: MINUS
20184: ST_TO_ADDR
// until time = 0 0$00 ;
20185: LD_VAR 0 7
20189: PUSH
20190: LD_INT 0
20192: EQUAL
20193: IFFALSE 20147
// display_strings :=  ;
20195: LD_ADDR_OWVAR 47
20199: PUSH
20200: LD_STRING 
20202: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20203: LD_INT 37
20205: PPUSH
20206: LD_INT 0
20208: PPUSH
20209: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20213: LD_ADDR_VAR 0 8
20217: PUSH
20218: LD_INT 37
20220: PPUSH
20221: LD_INT 3
20223: PUSH
20224: LD_INT 21
20226: PUSH
20227: LD_INT 3
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: PUSH
20234: EMPTY
20235: LIST
20236: LIST
20237: PPUSH
20238: CALL_OW 70
20242: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20243: LD_VAR 0 3
20247: PPUSH
20248: LD_VAR 0 4
20252: PPUSH
20253: CALL_OW 84
// for un in list do
20257: LD_ADDR_VAR 0 9
20261: PUSH
20262: LD_VAR 0 8
20266: PUSH
20267: FOR_IN
20268: IFFALSE 20297
// TeleportUnit ( un , x , y , 12 , true ) ;
20270: LD_VAR 0 9
20274: PPUSH
20275: LD_VAR 0 3
20279: PPUSH
20280: LD_VAR 0 4
20284: PPUSH
20285: LD_INT 12
20287: PPUSH
20288: LD_INT 1
20290: PPUSH
20291: CALL_OW 483
20295: GO 20267
20297: POP
20298: POP
// end ; end ;
20299: PPOPN 9
20301: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20302: LD_INT 0
20304: PPUSH
20305: PPUSH
// begin labNum := 0 ;
20306: LD_ADDR_VAR 0 4
20310: PUSH
20311: LD_INT 0
20313: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20314: LD_ADDR_VAR 0 3
20318: PUSH
20319: DOUBLE
20320: LD_INT 1
20322: DEC
20323: ST_TO_ADDR
20324: LD_EXP 69
20328: PUSH
20329: FOR_TO
20330: IFFALSE 20364
// if artifactsLabs [ i ] = lab then
20332: LD_EXP 69
20336: PUSH
20337: LD_VAR 0 3
20341: ARRAY
20342: PUSH
20343: LD_VAR 0 1
20347: EQUAL
20348: IFFALSE 20362
// begin labNum := i ;
20350: LD_ADDR_VAR 0 4
20354: PUSH
20355: LD_VAR 0 3
20359: ST_TO_ADDR
// break ;
20360: GO 20364
// end ;
20362: GO 20329
20364: POP
20365: POP
// if not labNum then
20366: LD_VAR 0 4
20370: NOT
20371: IFFALSE 20375
// exit ;
20373: GO 20453
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20375: LD_INT 7
20377: PPUSH
20378: LD_EXP 70
20382: PUSH
20383: LD_VAR 0 4
20387: ARRAY
20388: PUSH
20389: LD_INT 3
20391: ARRAY
20392: PPUSH
20393: LD_INT 2
20395: PPUSH
20396: LD_VAR 0 1
20400: PPUSH
20401: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20405: LD_ADDR_EXP 68
20409: PUSH
20410: LD_EXP 68
20414: PPUSH
20415: LD_VAR 0 4
20419: PPUSH
20420: LD_VAR 0 2
20424: PPUSH
20425: CALL_OW 1
20429: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20430: LD_ADDR_EXP 66
20434: PUSH
20435: LD_EXP 66
20439: PPUSH
20440: LD_VAR 0 4
20444: PPUSH
20445: LD_INT 0
20447: PPUSH
20448: CALL_OW 1
20452: ST_TO_ADDR
// end ;
20453: PPOPN 4
20455: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20456: LD_INT 0
20458: PPUSH
20459: PPUSH
// begin labNum := 0 ;
20460: LD_ADDR_VAR 0 3
20464: PUSH
20465: LD_INT 0
20467: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20468: LD_ADDR_VAR 0 2
20472: PUSH
20473: DOUBLE
20474: LD_INT 1
20476: DEC
20477: ST_TO_ADDR
20478: LD_EXP 69
20482: PUSH
20483: FOR_TO
20484: IFFALSE 20518
// if artifactsLabs [ i ] = lab then
20486: LD_EXP 69
20490: PUSH
20491: LD_VAR 0 2
20495: ARRAY
20496: PUSH
20497: LD_VAR 0 1
20501: EQUAL
20502: IFFALSE 20516
// begin labNum := i ;
20504: LD_ADDR_VAR 0 3
20508: PUSH
20509: LD_VAR 0 2
20513: ST_TO_ADDR
// break ;
20514: GO 20518
// end ;
20516: GO 20483
20518: POP
20519: POP
// if not labNum then
20520: LD_VAR 0 3
20524: NOT
20525: IFFALSE 20529
// exit ;
20527: GO 20691
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20529: LD_INT 7
20531: PPUSH
20532: LD_EXP 70
20536: PUSH
20537: LD_VAR 0 3
20541: ARRAY
20542: PUSH
20543: LD_INT 3
20545: ARRAY
20546: PPUSH
20547: LD_INT 0
20549: PPUSH
20550: LD_VAR 0 1
20554: PPUSH
20555: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20559: LD_ADDR_EXP 65
20563: PUSH
20564: LD_EXP 65
20568: PPUSH
20569: LD_VAR 0 3
20573: PPUSH
20574: LD_INT 1
20576: PPUSH
20577: CALL_OW 1
20581: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20582: LD_ADDR_EXP 71
20586: PUSH
20587: LD_EXP 71
20591: PPUSH
20592: LD_VAR 0 3
20596: PPUSH
20597: LD_INT 1
20599: PPUSH
20600: CALL_OW 1
20604: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20605: LD_ADDR_EXP 66
20609: PUSH
20610: LD_EXP 66
20614: PPUSH
20615: LD_VAR 0 3
20619: PPUSH
20620: LD_INT 0
20622: PPUSH
20623: CALL_OW 1
20627: ST_TO_ADDR
// case labNum of 1 :
20628: LD_VAR 0 3
20632: PUSH
20633: LD_INT 1
20635: DOUBLE
20636: EQUAL
20637: IFTRUE 20641
20639: GO 20652
20641: POP
// artifactIResearched := true ; 2 :
20642: LD_ADDR_EXP 12
20646: PUSH
20647: LD_INT 1
20649: ST_TO_ADDR
20650: GO 20691
20652: LD_INT 2
20654: DOUBLE
20655: EQUAL
20656: IFTRUE 20660
20658: GO 20671
20660: POP
// artifactIIResearched := true ; 3 :
20661: LD_ADDR_EXP 13
20665: PUSH
20666: LD_INT 1
20668: ST_TO_ADDR
20669: GO 20691
20671: LD_INT 3
20673: DOUBLE
20674: EQUAL
20675: IFTRUE 20679
20677: GO 20690
20679: POP
// artifactIIIResearched := true ; end ;
20680: LD_ADDR_EXP 14
20684: PUSH
20685: LD_INT 1
20687: ST_TO_ADDR
20688: GO 20691
20690: POP
// end ; end_of_file
20691: PPOPN 3
20693: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
20694: LD_INT 0
20696: PPUSH
// ar_miner := 81 ;
20697: LD_ADDR_EXP 79
20701: PUSH
20702: LD_INT 81
20704: ST_TO_ADDR
// ar_crane := 88 ;
20705: LD_ADDR_EXP 78
20709: PUSH
20710: LD_INT 88
20712: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20713: LD_ADDR_EXP 73
20717: PUSH
20718: LD_INT 89
20720: ST_TO_ADDR
// us_hack := 99 ;
20721: LD_ADDR_EXP 74
20725: PUSH
20726: LD_INT 99
20728: ST_TO_ADDR
// us_artillery := 97 ;
20729: LD_ADDR_EXP 75
20733: PUSH
20734: LD_INT 97
20736: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20737: LD_ADDR_EXP 76
20741: PUSH
20742: LD_INT 91
20744: ST_TO_ADDR
// ar_mortar := 92 ;
20745: LD_ADDR_EXP 77
20749: PUSH
20750: LD_INT 92
20752: ST_TO_ADDR
// ru_radar := 98 ;
20753: LD_ADDR_EXP 72
20757: PUSH
20758: LD_INT 98
20760: ST_TO_ADDR
// tech_Artillery := 80 ;
20761: LD_ADDR_EXP 80
20765: PUSH
20766: LD_INT 80
20768: ST_TO_ADDR
// tech_RadMat := 81 ;
20769: LD_ADDR_EXP 81
20773: PUSH
20774: LD_INT 81
20776: ST_TO_ADDR
// tech_BasicTools := 82 ;
20777: LD_ADDR_EXP 82
20781: PUSH
20782: LD_INT 82
20784: ST_TO_ADDR
// tech_Cargo := 83 ;
20785: LD_ADDR_EXP 83
20789: PUSH
20790: LD_INT 83
20792: ST_TO_ADDR
// tech_Track := 84 ;
20793: LD_ADDR_EXP 84
20797: PUSH
20798: LD_INT 84
20800: ST_TO_ADDR
// tech_Crane := 85 ;
20801: LD_ADDR_EXP 85
20805: PUSH
20806: LD_INT 85
20808: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20809: LD_ADDR_EXP 86
20813: PUSH
20814: LD_INT 86
20816: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20817: LD_ADDR_EXP 87
20821: PUSH
20822: LD_INT 87
20824: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
20825: LD_ADDR_EXP 88
20829: PUSH
20830: LD_INT 88
20832: ST_TO_ADDR
// class_mastodont := 31 ;
20833: LD_ADDR_EXP 89
20837: PUSH
20838: LD_INT 31
20840: ST_TO_ADDR
// class_horse := 21 ;
20841: LD_ADDR_EXP 90
20845: PUSH
20846: LD_INT 21
20848: ST_TO_ADDR
// end ;
20849: LD_VAR 0 1
20853: RET
// every 1 do
20854: GO 20856
20856: DISABLE
// InitGlobalVariables ; end_of_file
20857: CALL 20694 0 0
20861: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
20862: LD_INT 0
20864: PPUSH
20865: PPUSH
// skirmish := false ;
20866: LD_ADDR_EXP 91
20870: PUSH
20871: LD_INT 0
20873: ST_TO_ADDR
// debug_mc := false ;
20874: LD_ADDR_EXP 92
20878: PUSH
20879: LD_INT 0
20881: ST_TO_ADDR
// mc_bases := [ ] ;
20882: LD_ADDR_EXP 93
20886: PUSH
20887: EMPTY
20888: ST_TO_ADDR
// mc_sides := [ ] ;
20889: LD_ADDR_EXP 119
20893: PUSH
20894: EMPTY
20895: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20896: LD_ADDR_EXP 94
20900: PUSH
20901: EMPTY
20902: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20903: LD_ADDR_EXP 95
20907: PUSH
20908: EMPTY
20909: ST_TO_ADDR
// mc_need_heal := [ ] ;
20910: LD_ADDR_EXP 96
20914: PUSH
20915: EMPTY
20916: ST_TO_ADDR
// mc_healers := [ ] ;
20917: LD_ADDR_EXP 97
20921: PUSH
20922: EMPTY
20923: ST_TO_ADDR
// mc_build_list := [ ] ;
20924: LD_ADDR_EXP 98
20928: PUSH
20929: EMPTY
20930: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20931: LD_ADDR_EXP 125
20935: PUSH
20936: EMPTY
20937: ST_TO_ADDR
// mc_builders := [ ] ;
20938: LD_ADDR_EXP 99
20942: PUSH
20943: EMPTY
20944: ST_TO_ADDR
// mc_construct_list := [ ] ;
20945: LD_ADDR_EXP 100
20949: PUSH
20950: EMPTY
20951: ST_TO_ADDR
// mc_turret_list := [ ] ;
20952: LD_ADDR_EXP 101
20956: PUSH
20957: EMPTY
20958: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20959: LD_ADDR_EXP 102
20963: PUSH
20964: EMPTY
20965: ST_TO_ADDR
// mc_miners := [ ] ;
20966: LD_ADDR_EXP 107
20970: PUSH
20971: EMPTY
20972: ST_TO_ADDR
// mc_mines := [ ] ;
20973: LD_ADDR_EXP 106
20977: PUSH
20978: EMPTY
20979: ST_TO_ADDR
// mc_minefields := [ ] ;
20980: LD_ADDR_EXP 108
20984: PUSH
20985: EMPTY
20986: ST_TO_ADDR
// mc_crates := [ ] ;
20987: LD_ADDR_EXP 109
20991: PUSH
20992: EMPTY
20993: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20994: LD_ADDR_EXP 110
20998: PUSH
20999: EMPTY
21000: ST_TO_ADDR
// mc_crates_area := [ ] ;
21001: LD_ADDR_EXP 111
21005: PUSH
21006: EMPTY
21007: ST_TO_ADDR
// mc_vehicles := [ ] ;
21008: LD_ADDR_EXP 112
21012: PUSH
21013: EMPTY
21014: ST_TO_ADDR
// mc_attack := [ ] ;
21015: LD_ADDR_EXP 113
21019: PUSH
21020: EMPTY
21021: ST_TO_ADDR
// mc_produce := [ ] ;
21022: LD_ADDR_EXP 114
21026: PUSH
21027: EMPTY
21028: ST_TO_ADDR
// mc_defender := [ ] ;
21029: LD_ADDR_EXP 115
21033: PUSH
21034: EMPTY
21035: ST_TO_ADDR
// mc_parking := [ ] ;
21036: LD_ADDR_EXP 117
21040: PUSH
21041: EMPTY
21042: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21043: LD_ADDR_EXP 103
21047: PUSH
21048: EMPTY
21049: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21050: LD_ADDR_EXP 105
21054: PUSH
21055: EMPTY
21056: ST_TO_ADDR
// mc_scan := [ ] ;
21057: LD_ADDR_EXP 116
21061: PUSH
21062: EMPTY
21063: ST_TO_ADDR
// mc_scan_area := [ ] ;
21064: LD_ADDR_EXP 118
21068: PUSH
21069: EMPTY
21070: ST_TO_ADDR
// mc_tech := [ ] ;
21071: LD_ADDR_EXP 120
21075: PUSH
21076: EMPTY
21077: ST_TO_ADDR
// mc_class := [ ] ;
21078: LD_ADDR_EXP 134
21082: PUSH
21083: EMPTY
21084: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21085: LD_ADDR_EXP 135
21089: PUSH
21090: EMPTY
21091: ST_TO_ADDR
// mc_is_defending := [ ] ;
21092: LD_ADDR_EXP 136
21096: PUSH
21097: EMPTY
21098: ST_TO_ADDR
// end ;
21099: LD_VAR 0 1
21103: RET
// export function MC_Kill ( base ) ; begin
21104: LD_INT 0
21106: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21107: LD_ADDR_EXP 93
21111: PUSH
21112: LD_EXP 93
21116: PPUSH
21117: LD_VAR 0 1
21121: PPUSH
21122: EMPTY
21123: PPUSH
21124: CALL_OW 1
21128: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21129: LD_ADDR_EXP 94
21133: PUSH
21134: LD_EXP 94
21138: PPUSH
21139: LD_VAR 0 1
21143: PPUSH
21144: EMPTY
21145: PPUSH
21146: CALL_OW 1
21150: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21151: LD_ADDR_EXP 95
21155: PUSH
21156: LD_EXP 95
21160: PPUSH
21161: LD_VAR 0 1
21165: PPUSH
21166: EMPTY
21167: PPUSH
21168: CALL_OW 1
21172: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21173: LD_ADDR_EXP 96
21177: PUSH
21178: LD_EXP 96
21182: PPUSH
21183: LD_VAR 0 1
21187: PPUSH
21188: EMPTY
21189: PPUSH
21190: CALL_OW 1
21194: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21195: LD_ADDR_EXP 97
21199: PUSH
21200: LD_EXP 97
21204: PPUSH
21205: LD_VAR 0 1
21209: PPUSH
21210: EMPTY
21211: PPUSH
21212: CALL_OW 1
21216: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21217: LD_ADDR_EXP 98
21221: PUSH
21222: LD_EXP 98
21226: PPUSH
21227: LD_VAR 0 1
21231: PPUSH
21232: EMPTY
21233: PPUSH
21234: CALL_OW 1
21238: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21239: LD_ADDR_EXP 99
21243: PUSH
21244: LD_EXP 99
21248: PPUSH
21249: LD_VAR 0 1
21253: PPUSH
21254: EMPTY
21255: PPUSH
21256: CALL_OW 1
21260: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21261: LD_ADDR_EXP 100
21265: PUSH
21266: LD_EXP 100
21270: PPUSH
21271: LD_VAR 0 1
21275: PPUSH
21276: EMPTY
21277: PPUSH
21278: CALL_OW 1
21282: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21283: LD_ADDR_EXP 101
21287: PUSH
21288: LD_EXP 101
21292: PPUSH
21293: LD_VAR 0 1
21297: PPUSH
21298: EMPTY
21299: PPUSH
21300: CALL_OW 1
21304: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21305: LD_ADDR_EXP 102
21309: PUSH
21310: LD_EXP 102
21314: PPUSH
21315: LD_VAR 0 1
21319: PPUSH
21320: EMPTY
21321: PPUSH
21322: CALL_OW 1
21326: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21327: LD_ADDR_EXP 103
21331: PUSH
21332: LD_EXP 103
21336: PPUSH
21337: LD_VAR 0 1
21341: PPUSH
21342: EMPTY
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21349: LD_ADDR_EXP 104
21353: PUSH
21354: LD_EXP 104
21358: PPUSH
21359: LD_VAR 0 1
21363: PPUSH
21364: LD_INT 0
21366: PPUSH
21367: CALL_OW 1
21371: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21372: LD_ADDR_EXP 105
21376: PUSH
21377: LD_EXP 105
21381: PPUSH
21382: LD_VAR 0 1
21386: PPUSH
21387: EMPTY
21388: PPUSH
21389: CALL_OW 1
21393: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21394: LD_ADDR_EXP 106
21398: PUSH
21399: LD_EXP 106
21403: PPUSH
21404: LD_VAR 0 1
21408: PPUSH
21409: EMPTY
21410: PPUSH
21411: CALL_OW 1
21415: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21416: LD_ADDR_EXP 107
21420: PUSH
21421: LD_EXP 107
21425: PPUSH
21426: LD_VAR 0 1
21430: PPUSH
21431: EMPTY
21432: PPUSH
21433: CALL_OW 1
21437: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21438: LD_ADDR_EXP 108
21442: PUSH
21443: LD_EXP 108
21447: PPUSH
21448: LD_VAR 0 1
21452: PPUSH
21453: EMPTY
21454: PPUSH
21455: CALL_OW 1
21459: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21460: LD_ADDR_EXP 109
21464: PUSH
21465: LD_EXP 109
21469: PPUSH
21470: LD_VAR 0 1
21474: PPUSH
21475: EMPTY
21476: PPUSH
21477: CALL_OW 1
21481: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21482: LD_ADDR_EXP 110
21486: PUSH
21487: LD_EXP 110
21491: PPUSH
21492: LD_VAR 0 1
21496: PPUSH
21497: EMPTY
21498: PPUSH
21499: CALL_OW 1
21503: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21504: LD_ADDR_EXP 111
21508: PUSH
21509: LD_EXP 111
21513: PPUSH
21514: LD_VAR 0 1
21518: PPUSH
21519: EMPTY
21520: PPUSH
21521: CALL_OW 1
21525: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21526: LD_ADDR_EXP 112
21530: PUSH
21531: LD_EXP 112
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: EMPTY
21542: PPUSH
21543: CALL_OW 1
21547: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21548: LD_ADDR_EXP 113
21552: PUSH
21553: LD_EXP 113
21557: PPUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: EMPTY
21564: PPUSH
21565: CALL_OW 1
21569: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21570: LD_ADDR_EXP 114
21574: PUSH
21575: LD_EXP 114
21579: PPUSH
21580: LD_VAR 0 1
21584: PPUSH
21585: EMPTY
21586: PPUSH
21587: CALL_OW 1
21591: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21592: LD_ADDR_EXP 115
21596: PUSH
21597: LD_EXP 115
21601: PPUSH
21602: LD_VAR 0 1
21606: PPUSH
21607: EMPTY
21608: PPUSH
21609: CALL_OW 1
21613: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21614: LD_ADDR_EXP 116
21618: PUSH
21619: LD_EXP 116
21623: PPUSH
21624: LD_VAR 0 1
21628: PPUSH
21629: EMPTY
21630: PPUSH
21631: CALL_OW 1
21635: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21636: LD_ADDR_EXP 117
21640: PUSH
21641: LD_EXP 117
21645: PPUSH
21646: LD_VAR 0 1
21650: PPUSH
21651: EMPTY
21652: PPUSH
21653: CALL_OW 1
21657: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21658: LD_ADDR_EXP 118
21662: PUSH
21663: LD_EXP 118
21667: PPUSH
21668: LD_VAR 0 1
21672: PPUSH
21673: EMPTY
21674: PPUSH
21675: CALL_OW 1
21679: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21680: LD_ADDR_EXP 120
21684: PUSH
21685: LD_EXP 120
21689: PPUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: EMPTY
21696: PPUSH
21697: CALL_OW 1
21701: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21702: LD_ADDR_EXP 122
21706: PUSH
21707: LD_EXP 122
21711: PPUSH
21712: LD_VAR 0 1
21716: PPUSH
21717: EMPTY
21718: PPUSH
21719: CALL_OW 1
21723: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21724: LD_ADDR_EXP 123
21728: PUSH
21729: LD_EXP 123
21733: PPUSH
21734: LD_VAR 0 1
21738: PPUSH
21739: EMPTY
21740: PPUSH
21741: CALL_OW 1
21745: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21746: LD_ADDR_EXP 124
21750: PUSH
21751: LD_EXP 124
21755: PPUSH
21756: LD_VAR 0 1
21760: PPUSH
21761: EMPTY
21762: PPUSH
21763: CALL_OW 1
21767: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21768: LD_ADDR_EXP 125
21772: PUSH
21773: LD_EXP 125
21777: PPUSH
21778: LD_VAR 0 1
21782: PPUSH
21783: EMPTY
21784: PPUSH
21785: CALL_OW 1
21789: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21790: LD_ADDR_EXP 126
21794: PUSH
21795: LD_EXP 126
21799: PPUSH
21800: LD_VAR 0 1
21804: PPUSH
21805: EMPTY
21806: PPUSH
21807: CALL_OW 1
21811: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21812: LD_ADDR_EXP 127
21816: PUSH
21817: LD_EXP 127
21821: PPUSH
21822: LD_VAR 0 1
21826: PPUSH
21827: EMPTY
21828: PPUSH
21829: CALL_OW 1
21833: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21834: LD_ADDR_EXP 128
21838: PUSH
21839: LD_EXP 128
21843: PPUSH
21844: LD_VAR 0 1
21848: PPUSH
21849: EMPTY
21850: PPUSH
21851: CALL_OW 1
21855: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21856: LD_ADDR_EXP 129
21860: PUSH
21861: LD_EXP 129
21865: PPUSH
21866: LD_VAR 0 1
21870: PPUSH
21871: EMPTY
21872: PPUSH
21873: CALL_OW 1
21877: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21878: LD_ADDR_EXP 130
21882: PUSH
21883: LD_EXP 130
21887: PPUSH
21888: LD_VAR 0 1
21892: PPUSH
21893: EMPTY
21894: PPUSH
21895: CALL_OW 1
21899: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21900: LD_ADDR_EXP 131
21904: PUSH
21905: LD_EXP 131
21909: PPUSH
21910: LD_VAR 0 1
21914: PPUSH
21915: EMPTY
21916: PPUSH
21917: CALL_OW 1
21921: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21922: LD_ADDR_EXP 132
21926: PUSH
21927: LD_EXP 132
21931: PPUSH
21932: LD_VAR 0 1
21936: PPUSH
21937: EMPTY
21938: PPUSH
21939: CALL_OW 1
21943: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21944: LD_ADDR_EXP 133
21948: PUSH
21949: LD_EXP 133
21953: PPUSH
21954: LD_VAR 0 1
21958: PPUSH
21959: EMPTY
21960: PPUSH
21961: CALL_OW 1
21965: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21966: LD_ADDR_EXP 134
21970: PUSH
21971: LD_EXP 134
21975: PPUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: EMPTY
21982: PPUSH
21983: CALL_OW 1
21987: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21988: LD_ADDR_EXP 135
21992: PUSH
21993: LD_EXP 135
21997: PPUSH
21998: LD_VAR 0 1
22002: PPUSH
22003: LD_INT 0
22005: PPUSH
22006: CALL_OW 1
22010: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22011: LD_ADDR_EXP 136
22015: PUSH
22016: LD_EXP 136
22020: PPUSH
22021: LD_VAR 0 1
22025: PPUSH
22026: LD_INT 0
22028: PPUSH
22029: CALL_OW 1
22033: ST_TO_ADDR
// end ;
22034: LD_VAR 0 2
22038: RET
// export function MC_Add ( side , units ) ; var base ; begin
22039: LD_INT 0
22041: PPUSH
22042: PPUSH
// base := mc_bases + 1 ;
22043: LD_ADDR_VAR 0 4
22047: PUSH
22048: LD_EXP 93
22052: PUSH
22053: LD_INT 1
22055: PLUS
22056: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22057: LD_ADDR_EXP 119
22061: PUSH
22062: LD_EXP 119
22066: PPUSH
22067: LD_VAR 0 4
22071: PPUSH
22072: LD_VAR 0 1
22076: PPUSH
22077: CALL_OW 1
22081: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22082: LD_ADDR_EXP 93
22086: PUSH
22087: LD_EXP 93
22091: PPUSH
22092: LD_VAR 0 4
22096: PPUSH
22097: LD_VAR 0 2
22101: PPUSH
22102: CALL_OW 1
22106: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22107: LD_ADDR_EXP 94
22111: PUSH
22112: LD_EXP 94
22116: PPUSH
22117: LD_VAR 0 4
22121: PPUSH
22122: EMPTY
22123: PPUSH
22124: CALL_OW 1
22128: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22129: LD_ADDR_EXP 95
22133: PUSH
22134: LD_EXP 95
22138: PPUSH
22139: LD_VAR 0 4
22143: PPUSH
22144: EMPTY
22145: PPUSH
22146: CALL_OW 1
22150: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22151: LD_ADDR_EXP 96
22155: PUSH
22156: LD_EXP 96
22160: PPUSH
22161: LD_VAR 0 4
22165: PPUSH
22166: EMPTY
22167: PPUSH
22168: CALL_OW 1
22172: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22173: LD_ADDR_EXP 97
22177: PUSH
22178: LD_EXP 97
22182: PPUSH
22183: LD_VAR 0 4
22187: PPUSH
22188: EMPTY
22189: PPUSH
22190: CALL_OW 1
22194: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22195: LD_ADDR_EXP 98
22199: PUSH
22200: LD_EXP 98
22204: PPUSH
22205: LD_VAR 0 4
22209: PPUSH
22210: EMPTY
22211: PPUSH
22212: CALL_OW 1
22216: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22217: LD_ADDR_EXP 99
22221: PUSH
22222: LD_EXP 99
22226: PPUSH
22227: LD_VAR 0 4
22231: PPUSH
22232: EMPTY
22233: PPUSH
22234: CALL_OW 1
22238: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22239: LD_ADDR_EXP 100
22243: PUSH
22244: LD_EXP 100
22248: PPUSH
22249: LD_VAR 0 4
22253: PPUSH
22254: EMPTY
22255: PPUSH
22256: CALL_OW 1
22260: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22261: LD_ADDR_EXP 101
22265: PUSH
22266: LD_EXP 101
22270: PPUSH
22271: LD_VAR 0 4
22275: PPUSH
22276: EMPTY
22277: PPUSH
22278: CALL_OW 1
22282: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22283: LD_ADDR_EXP 102
22287: PUSH
22288: LD_EXP 102
22292: PPUSH
22293: LD_VAR 0 4
22297: PPUSH
22298: EMPTY
22299: PPUSH
22300: CALL_OW 1
22304: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22305: LD_ADDR_EXP 103
22309: PUSH
22310: LD_EXP 103
22314: PPUSH
22315: LD_VAR 0 4
22319: PPUSH
22320: EMPTY
22321: PPUSH
22322: CALL_OW 1
22326: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22327: LD_ADDR_EXP 104
22331: PUSH
22332: LD_EXP 104
22336: PPUSH
22337: LD_VAR 0 4
22341: PPUSH
22342: LD_INT 0
22344: PPUSH
22345: CALL_OW 1
22349: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22350: LD_ADDR_EXP 105
22354: PUSH
22355: LD_EXP 105
22359: PPUSH
22360: LD_VAR 0 4
22364: PPUSH
22365: EMPTY
22366: PPUSH
22367: CALL_OW 1
22371: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22372: LD_ADDR_EXP 106
22376: PUSH
22377: LD_EXP 106
22381: PPUSH
22382: LD_VAR 0 4
22386: PPUSH
22387: EMPTY
22388: PPUSH
22389: CALL_OW 1
22393: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22394: LD_ADDR_EXP 107
22398: PUSH
22399: LD_EXP 107
22403: PPUSH
22404: LD_VAR 0 4
22408: PPUSH
22409: EMPTY
22410: PPUSH
22411: CALL_OW 1
22415: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22416: LD_ADDR_EXP 108
22420: PUSH
22421: LD_EXP 108
22425: PPUSH
22426: LD_VAR 0 4
22430: PPUSH
22431: EMPTY
22432: PPUSH
22433: CALL_OW 1
22437: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22438: LD_ADDR_EXP 109
22442: PUSH
22443: LD_EXP 109
22447: PPUSH
22448: LD_VAR 0 4
22452: PPUSH
22453: EMPTY
22454: PPUSH
22455: CALL_OW 1
22459: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22460: LD_ADDR_EXP 110
22464: PUSH
22465: LD_EXP 110
22469: PPUSH
22470: LD_VAR 0 4
22474: PPUSH
22475: EMPTY
22476: PPUSH
22477: CALL_OW 1
22481: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22482: LD_ADDR_EXP 111
22486: PUSH
22487: LD_EXP 111
22491: PPUSH
22492: LD_VAR 0 4
22496: PPUSH
22497: EMPTY
22498: PPUSH
22499: CALL_OW 1
22503: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22504: LD_ADDR_EXP 112
22508: PUSH
22509: LD_EXP 112
22513: PPUSH
22514: LD_VAR 0 4
22518: PPUSH
22519: EMPTY
22520: PPUSH
22521: CALL_OW 1
22525: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22526: LD_ADDR_EXP 113
22530: PUSH
22531: LD_EXP 113
22535: PPUSH
22536: LD_VAR 0 4
22540: PPUSH
22541: EMPTY
22542: PPUSH
22543: CALL_OW 1
22547: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22548: LD_ADDR_EXP 114
22552: PUSH
22553: LD_EXP 114
22557: PPUSH
22558: LD_VAR 0 4
22562: PPUSH
22563: EMPTY
22564: PPUSH
22565: CALL_OW 1
22569: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22570: LD_ADDR_EXP 115
22574: PUSH
22575: LD_EXP 115
22579: PPUSH
22580: LD_VAR 0 4
22584: PPUSH
22585: EMPTY
22586: PPUSH
22587: CALL_OW 1
22591: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22592: LD_ADDR_EXP 116
22596: PUSH
22597: LD_EXP 116
22601: PPUSH
22602: LD_VAR 0 4
22606: PPUSH
22607: EMPTY
22608: PPUSH
22609: CALL_OW 1
22613: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22614: LD_ADDR_EXP 117
22618: PUSH
22619: LD_EXP 117
22623: PPUSH
22624: LD_VAR 0 4
22628: PPUSH
22629: EMPTY
22630: PPUSH
22631: CALL_OW 1
22635: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22636: LD_ADDR_EXP 118
22640: PUSH
22641: LD_EXP 118
22645: PPUSH
22646: LD_VAR 0 4
22650: PPUSH
22651: EMPTY
22652: PPUSH
22653: CALL_OW 1
22657: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22658: LD_ADDR_EXP 120
22662: PUSH
22663: LD_EXP 120
22667: PPUSH
22668: LD_VAR 0 4
22672: PPUSH
22673: EMPTY
22674: PPUSH
22675: CALL_OW 1
22679: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22680: LD_ADDR_EXP 122
22684: PUSH
22685: LD_EXP 122
22689: PPUSH
22690: LD_VAR 0 4
22694: PPUSH
22695: EMPTY
22696: PPUSH
22697: CALL_OW 1
22701: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22702: LD_ADDR_EXP 123
22706: PUSH
22707: LD_EXP 123
22711: PPUSH
22712: LD_VAR 0 4
22716: PPUSH
22717: EMPTY
22718: PPUSH
22719: CALL_OW 1
22723: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22724: LD_ADDR_EXP 124
22728: PUSH
22729: LD_EXP 124
22733: PPUSH
22734: LD_VAR 0 4
22738: PPUSH
22739: EMPTY
22740: PPUSH
22741: CALL_OW 1
22745: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22746: LD_ADDR_EXP 125
22750: PUSH
22751: LD_EXP 125
22755: PPUSH
22756: LD_VAR 0 4
22760: PPUSH
22761: EMPTY
22762: PPUSH
22763: CALL_OW 1
22767: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22768: LD_ADDR_EXP 126
22772: PUSH
22773: LD_EXP 126
22777: PPUSH
22778: LD_VAR 0 4
22782: PPUSH
22783: EMPTY
22784: PPUSH
22785: CALL_OW 1
22789: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22790: LD_ADDR_EXP 127
22794: PUSH
22795: LD_EXP 127
22799: PPUSH
22800: LD_VAR 0 4
22804: PPUSH
22805: EMPTY
22806: PPUSH
22807: CALL_OW 1
22811: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22812: LD_ADDR_EXP 128
22816: PUSH
22817: LD_EXP 128
22821: PPUSH
22822: LD_VAR 0 4
22826: PPUSH
22827: EMPTY
22828: PPUSH
22829: CALL_OW 1
22833: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22834: LD_ADDR_EXP 129
22838: PUSH
22839: LD_EXP 129
22843: PPUSH
22844: LD_VAR 0 4
22848: PPUSH
22849: EMPTY
22850: PPUSH
22851: CALL_OW 1
22855: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22856: LD_ADDR_EXP 130
22860: PUSH
22861: LD_EXP 130
22865: PPUSH
22866: LD_VAR 0 4
22870: PPUSH
22871: EMPTY
22872: PPUSH
22873: CALL_OW 1
22877: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22878: LD_ADDR_EXP 131
22882: PUSH
22883: LD_EXP 131
22887: PPUSH
22888: LD_VAR 0 4
22892: PPUSH
22893: EMPTY
22894: PPUSH
22895: CALL_OW 1
22899: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22900: LD_ADDR_EXP 132
22904: PUSH
22905: LD_EXP 132
22909: PPUSH
22910: LD_VAR 0 4
22914: PPUSH
22915: EMPTY
22916: PPUSH
22917: CALL_OW 1
22921: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22922: LD_ADDR_EXP 133
22926: PUSH
22927: LD_EXP 133
22931: PPUSH
22932: LD_VAR 0 4
22936: PPUSH
22937: EMPTY
22938: PPUSH
22939: CALL_OW 1
22943: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22944: LD_ADDR_EXP 134
22948: PUSH
22949: LD_EXP 134
22953: PPUSH
22954: LD_VAR 0 4
22958: PPUSH
22959: EMPTY
22960: PPUSH
22961: CALL_OW 1
22965: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22966: LD_ADDR_EXP 135
22970: PUSH
22971: LD_EXP 135
22975: PPUSH
22976: LD_VAR 0 4
22980: PPUSH
22981: LD_INT 0
22983: PPUSH
22984: CALL_OW 1
22988: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22989: LD_ADDR_EXP 136
22993: PUSH
22994: LD_EXP 136
22998: PPUSH
22999: LD_VAR 0 4
23003: PPUSH
23004: LD_INT 0
23006: PPUSH
23007: CALL_OW 1
23011: ST_TO_ADDR
// result := base ;
23012: LD_ADDR_VAR 0 3
23016: PUSH
23017: LD_VAR 0 4
23021: ST_TO_ADDR
// end ;
23022: LD_VAR 0 3
23026: RET
// export function MC_Start ( ) ; var i ; begin
23027: LD_INT 0
23029: PPUSH
23030: PPUSH
// for i = 1 to mc_bases do
23031: LD_ADDR_VAR 0 2
23035: PUSH
23036: DOUBLE
23037: LD_INT 1
23039: DEC
23040: ST_TO_ADDR
23041: LD_EXP 93
23045: PUSH
23046: FOR_TO
23047: IFFALSE 24147
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23049: LD_ADDR_EXP 93
23053: PUSH
23054: LD_EXP 93
23058: PPUSH
23059: LD_VAR 0 2
23063: PPUSH
23064: LD_EXP 93
23068: PUSH
23069: LD_VAR 0 2
23073: ARRAY
23074: PUSH
23075: LD_INT 0
23077: DIFF
23078: PPUSH
23079: CALL_OW 1
23083: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23084: LD_ADDR_EXP 94
23088: PUSH
23089: LD_EXP 94
23093: PPUSH
23094: LD_VAR 0 2
23098: PPUSH
23099: EMPTY
23100: PPUSH
23101: CALL_OW 1
23105: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23106: LD_ADDR_EXP 95
23110: PUSH
23111: LD_EXP 95
23115: PPUSH
23116: LD_VAR 0 2
23120: PPUSH
23121: EMPTY
23122: PPUSH
23123: CALL_OW 1
23127: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23128: LD_ADDR_EXP 96
23132: PUSH
23133: LD_EXP 96
23137: PPUSH
23138: LD_VAR 0 2
23142: PPUSH
23143: EMPTY
23144: PPUSH
23145: CALL_OW 1
23149: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23150: LD_ADDR_EXP 97
23154: PUSH
23155: LD_EXP 97
23159: PPUSH
23160: LD_VAR 0 2
23164: PPUSH
23165: EMPTY
23166: PUSH
23167: EMPTY
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: PPUSH
23173: CALL_OW 1
23177: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23178: LD_ADDR_EXP 98
23182: PUSH
23183: LD_EXP 98
23187: PPUSH
23188: LD_VAR 0 2
23192: PPUSH
23193: EMPTY
23194: PPUSH
23195: CALL_OW 1
23199: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23200: LD_ADDR_EXP 125
23204: PUSH
23205: LD_EXP 125
23209: PPUSH
23210: LD_VAR 0 2
23214: PPUSH
23215: EMPTY
23216: PPUSH
23217: CALL_OW 1
23221: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23222: LD_ADDR_EXP 99
23226: PUSH
23227: LD_EXP 99
23231: PPUSH
23232: LD_VAR 0 2
23236: PPUSH
23237: EMPTY
23238: PPUSH
23239: CALL_OW 1
23243: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23244: LD_ADDR_EXP 100
23248: PUSH
23249: LD_EXP 100
23253: PPUSH
23254: LD_VAR 0 2
23258: PPUSH
23259: EMPTY
23260: PPUSH
23261: CALL_OW 1
23265: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23266: LD_ADDR_EXP 101
23270: PUSH
23271: LD_EXP 101
23275: PPUSH
23276: LD_VAR 0 2
23280: PPUSH
23281: LD_EXP 93
23285: PUSH
23286: LD_VAR 0 2
23290: ARRAY
23291: PPUSH
23292: LD_INT 2
23294: PUSH
23295: LD_INT 30
23297: PUSH
23298: LD_INT 32
23300: PUSH
23301: EMPTY
23302: LIST
23303: LIST
23304: PUSH
23305: LD_INT 30
23307: PUSH
23308: LD_INT 33
23310: PUSH
23311: EMPTY
23312: LIST
23313: LIST
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: LIST
23319: PPUSH
23320: CALL_OW 72
23324: PPUSH
23325: CALL_OW 1
23329: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23330: LD_ADDR_EXP 102
23334: PUSH
23335: LD_EXP 102
23339: PPUSH
23340: LD_VAR 0 2
23344: PPUSH
23345: LD_EXP 93
23349: PUSH
23350: LD_VAR 0 2
23354: ARRAY
23355: PPUSH
23356: LD_INT 2
23358: PUSH
23359: LD_INT 30
23361: PUSH
23362: LD_INT 32
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: PUSH
23369: LD_INT 30
23371: PUSH
23372: LD_INT 31
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: LIST
23383: PUSH
23384: LD_INT 58
23386: PUSH
23387: EMPTY
23388: LIST
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: PPUSH
23394: CALL_OW 72
23398: PPUSH
23399: CALL_OW 1
23403: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23404: LD_ADDR_EXP 103
23408: PUSH
23409: LD_EXP 103
23413: PPUSH
23414: LD_VAR 0 2
23418: PPUSH
23419: EMPTY
23420: PPUSH
23421: CALL_OW 1
23425: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23426: LD_ADDR_EXP 107
23430: PUSH
23431: LD_EXP 107
23435: PPUSH
23436: LD_VAR 0 2
23440: PPUSH
23441: EMPTY
23442: PPUSH
23443: CALL_OW 1
23447: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23448: LD_ADDR_EXP 106
23452: PUSH
23453: LD_EXP 106
23457: PPUSH
23458: LD_VAR 0 2
23462: PPUSH
23463: EMPTY
23464: PPUSH
23465: CALL_OW 1
23469: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23470: LD_ADDR_EXP 108
23474: PUSH
23475: LD_EXP 108
23479: PPUSH
23480: LD_VAR 0 2
23484: PPUSH
23485: EMPTY
23486: PPUSH
23487: CALL_OW 1
23491: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23492: LD_ADDR_EXP 109
23496: PUSH
23497: LD_EXP 109
23501: PPUSH
23502: LD_VAR 0 2
23506: PPUSH
23507: EMPTY
23508: PPUSH
23509: CALL_OW 1
23513: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23514: LD_ADDR_EXP 110
23518: PUSH
23519: LD_EXP 110
23523: PPUSH
23524: LD_VAR 0 2
23528: PPUSH
23529: EMPTY
23530: PPUSH
23531: CALL_OW 1
23535: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23536: LD_ADDR_EXP 111
23540: PUSH
23541: LD_EXP 111
23545: PPUSH
23546: LD_VAR 0 2
23550: PPUSH
23551: EMPTY
23552: PPUSH
23553: CALL_OW 1
23557: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23558: LD_ADDR_EXP 112
23562: PUSH
23563: LD_EXP 112
23567: PPUSH
23568: LD_VAR 0 2
23572: PPUSH
23573: EMPTY
23574: PPUSH
23575: CALL_OW 1
23579: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23580: LD_ADDR_EXP 113
23584: PUSH
23585: LD_EXP 113
23589: PPUSH
23590: LD_VAR 0 2
23594: PPUSH
23595: EMPTY
23596: PPUSH
23597: CALL_OW 1
23601: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23602: LD_ADDR_EXP 114
23606: PUSH
23607: LD_EXP 114
23611: PPUSH
23612: LD_VAR 0 2
23616: PPUSH
23617: EMPTY
23618: PPUSH
23619: CALL_OW 1
23623: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23624: LD_ADDR_EXP 115
23628: PUSH
23629: LD_EXP 115
23633: PPUSH
23634: LD_VAR 0 2
23638: PPUSH
23639: EMPTY
23640: PPUSH
23641: CALL_OW 1
23645: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23646: LD_ADDR_EXP 104
23650: PUSH
23651: LD_EXP 104
23655: PPUSH
23656: LD_VAR 0 2
23660: PPUSH
23661: LD_INT 0
23663: PPUSH
23664: CALL_OW 1
23668: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23669: LD_ADDR_EXP 117
23673: PUSH
23674: LD_EXP 117
23678: PPUSH
23679: LD_VAR 0 2
23683: PPUSH
23684: LD_INT 0
23686: PPUSH
23687: CALL_OW 1
23691: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23692: LD_ADDR_EXP 105
23696: PUSH
23697: LD_EXP 105
23701: PPUSH
23702: LD_VAR 0 2
23706: PPUSH
23707: EMPTY
23708: PPUSH
23709: CALL_OW 1
23713: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23714: LD_ADDR_EXP 116
23718: PUSH
23719: LD_EXP 116
23723: PPUSH
23724: LD_VAR 0 2
23728: PPUSH
23729: LD_INT 0
23731: PPUSH
23732: CALL_OW 1
23736: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23737: LD_ADDR_EXP 118
23741: PUSH
23742: LD_EXP 118
23746: PPUSH
23747: LD_VAR 0 2
23751: PPUSH
23752: EMPTY
23753: PPUSH
23754: CALL_OW 1
23758: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23759: LD_ADDR_EXP 121
23763: PUSH
23764: LD_EXP 121
23768: PPUSH
23769: LD_VAR 0 2
23773: PPUSH
23774: LD_INT 0
23776: PPUSH
23777: CALL_OW 1
23781: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23782: LD_ADDR_EXP 122
23786: PUSH
23787: LD_EXP 122
23791: PPUSH
23792: LD_VAR 0 2
23796: PPUSH
23797: EMPTY
23798: PPUSH
23799: CALL_OW 1
23803: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23804: LD_ADDR_EXP 123
23808: PUSH
23809: LD_EXP 123
23813: PPUSH
23814: LD_VAR 0 2
23818: PPUSH
23819: EMPTY
23820: PPUSH
23821: CALL_OW 1
23825: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23826: LD_ADDR_EXP 124
23830: PUSH
23831: LD_EXP 124
23835: PPUSH
23836: LD_VAR 0 2
23840: PPUSH
23841: EMPTY
23842: PPUSH
23843: CALL_OW 1
23847: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23848: LD_ADDR_EXP 126
23852: PUSH
23853: LD_EXP 126
23857: PPUSH
23858: LD_VAR 0 2
23862: PPUSH
23863: LD_EXP 93
23867: PUSH
23868: LD_VAR 0 2
23872: ARRAY
23873: PPUSH
23874: LD_INT 2
23876: PUSH
23877: LD_INT 30
23879: PUSH
23880: LD_INT 6
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 30
23889: PUSH
23890: LD_INT 7
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: PUSH
23897: LD_INT 30
23899: PUSH
23900: LD_INT 8
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: LIST
23911: LIST
23912: PPUSH
23913: CALL_OW 72
23917: PPUSH
23918: CALL_OW 1
23922: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23923: LD_ADDR_EXP 127
23927: PUSH
23928: LD_EXP 127
23932: PPUSH
23933: LD_VAR 0 2
23937: PPUSH
23938: EMPTY
23939: PPUSH
23940: CALL_OW 1
23944: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23945: LD_ADDR_EXP 128
23949: PUSH
23950: LD_EXP 128
23954: PPUSH
23955: LD_VAR 0 2
23959: PPUSH
23960: EMPTY
23961: PPUSH
23962: CALL_OW 1
23966: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23967: LD_ADDR_EXP 129
23971: PUSH
23972: LD_EXP 129
23976: PPUSH
23977: LD_VAR 0 2
23981: PPUSH
23982: EMPTY
23983: PPUSH
23984: CALL_OW 1
23988: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23989: LD_ADDR_EXP 130
23993: PUSH
23994: LD_EXP 130
23998: PPUSH
23999: LD_VAR 0 2
24003: PPUSH
24004: EMPTY
24005: PPUSH
24006: CALL_OW 1
24010: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24011: LD_ADDR_EXP 131
24015: PUSH
24016: LD_EXP 131
24020: PPUSH
24021: LD_VAR 0 2
24025: PPUSH
24026: EMPTY
24027: PPUSH
24028: CALL_OW 1
24032: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24033: LD_ADDR_EXP 132
24037: PUSH
24038: LD_EXP 132
24042: PPUSH
24043: LD_VAR 0 2
24047: PPUSH
24048: EMPTY
24049: PPUSH
24050: CALL_OW 1
24054: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24055: LD_ADDR_EXP 133
24059: PUSH
24060: LD_EXP 133
24064: PPUSH
24065: LD_VAR 0 2
24069: PPUSH
24070: EMPTY
24071: PPUSH
24072: CALL_OW 1
24076: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24077: LD_ADDR_EXP 134
24081: PUSH
24082: LD_EXP 134
24086: PPUSH
24087: LD_VAR 0 2
24091: PPUSH
24092: EMPTY
24093: PPUSH
24094: CALL_OW 1
24098: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24099: LD_ADDR_EXP 135
24103: PUSH
24104: LD_EXP 135
24108: PPUSH
24109: LD_VAR 0 2
24113: PPUSH
24114: LD_INT 0
24116: PPUSH
24117: CALL_OW 1
24121: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24122: LD_ADDR_EXP 136
24126: PUSH
24127: LD_EXP 136
24131: PPUSH
24132: LD_VAR 0 2
24136: PPUSH
24137: LD_INT 0
24139: PPUSH
24140: CALL_OW 1
24144: ST_TO_ADDR
// end ;
24145: GO 23046
24147: POP
24148: POP
// MC_InitSides ( ) ;
24149: CALL 24435 0 0
// MC_InitResearch ( ) ;
24153: CALL 24174 0 0
// CustomInitMacro ( ) ;
24157: CALL 217 0 0
// skirmish := true ;
24161: LD_ADDR_EXP 91
24165: PUSH
24166: LD_INT 1
24168: ST_TO_ADDR
// end ;
24169: LD_VAR 0 1
24173: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24174: LD_INT 0
24176: PPUSH
24177: PPUSH
24178: PPUSH
24179: PPUSH
24180: PPUSH
24181: PPUSH
// if not mc_bases then
24182: LD_EXP 93
24186: NOT
24187: IFFALSE 24191
// exit ;
24189: GO 24430
// for i = 1 to 8 do
24191: LD_ADDR_VAR 0 2
24195: PUSH
24196: DOUBLE
24197: LD_INT 1
24199: DEC
24200: ST_TO_ADDR
24201: LD_INT 8
24203: PUSH
24204: FOR_TO
24205: IFFALSE 24231
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24207: LD_ADDR_EXP 120
24211: PUSH
24212: LD_EXP 120
24216: PPUSH
24217: LD_VAR 0 2
24221: PPUSH
24222: EMPTY
24223: PPUSH
24224: CALL_OW 1
24228: ST_TO_ADDR
24229: GO 24204
24231: POP
24232: POP
// tmp := [ ] ;
24233: LD_ADDR_VAR 0 5
24237: PUSH
24238: EMPTY
24239: ST_TO_ADDR
// for i = 1 to mc_sides do
24240: LD_ADDR_VAR 0 2
24244: PUSH
24245: DOUBLE
24246: LD_INT 1
24248: DEC
24249: ST_TO_ADDR
24250: LD_EXP 119
24254: PUSH
24255: FOR_TO
24256: IFFALSE 24314
// if not mc_sides [ i ] in tmp then
24258: LD_EXP 119
24262: PUSH
24263: LD_VAR 0 2
24267: ARRAY
24268: PUSH
24269: LD_VAR 0 5
24273: IN
24274: NOT
24275: IFFALSE 24312
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24277: LD_ADDR_VAR 0 5
24281: PUSH
24282: LD_VAR 0 5
24286: PPUSH
24287: LD_VAR 0 5
24291: PUSH
24292: LD_INT 1
24294: PLUS
24295: PPUSH
24296: LD_EXP 119
24300: PUSH
24301: LD_VAR 0 2
24305: ARRAY
24306: PPUSH
24307: CALL_OW 2
24311: ST_TO_ADDR
24312: GO 24255
24314: POP
24315: POP
// if not tmp then
24316: LD_VAR 0 5
24320: NOT
24321: IFFALSE 24325
// exit ;
24323: GO 24430
// for j in tmp do
24325: LD_ADDR_VAR 0 3
24329: PUSH
24330: LD_VAR 0 5
24334: PUSH
24335: FOR_IN
24336: IFFALSE 24428
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24338: LD_ADDR_VAR 0 6
24342: PUSH
24343: LD_INT 22
24345: PUSH
24346: LD_VAR 0 3
24350: PUSH
24351: EMPTY
24352: LIST
24353: LIST
24354: PPUSH
24355: CALL_OW 69
24359: ST_TO_ADDR
// if not un then
24360: LD_VAR 0 6
24364: NOT
24365: IFFALSE 24369
// continue ;
24367: GO 24335
// nation := GetNation ( un [ 1 ] ) ;
24369: LD_ADDR_VAR 0 4
24373: PUSH
24374: LD_VAR 0 6
24378: PUSH
24379: LD_INT 1
24381: ARRAY
24382: PPUSH
24383: CALL_OW 248
24387: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24388: LD_ADDR_EXP 120
24392: PUSH
24393: LD_EXP 120
24397: PPUSH
24398: LD_VAR 0 3
24402: PPUSH
24403: LD_VAR 0 3
24407: PPUSH
24408: LD_VAR 0 4
24412: PPUSH
24413: LD_INT 1
24415: PPUSH
24416: CALL 51551 0 3
24420: PPUSH
24421: CALL_OW 1
24425: ST_TO_ADDR
// end ;
24426: GO 24335
24428: POP
24429: POP
// end ;
24430: LD_VAR 0 1
24434: RET
// export function MC_InitSides ( ) ; var i ; begin
24435: LD_INT 0
24437: PPUSH
24438: PPUSH
// if not mc_bases then
24439: LD_EXP 93
24443: NOT
24444: IFFALSE 24448
// exit ;
24446: GO 24522
// for i = 1 to mc_bases do
24448: LD_ADDR_VAR 0 2
24452: PUSH
24453: DOUBLE
24454: LD_INT 1
24456: DEC
24457: ST_TO_ADDR
24458: LD_EXP 93
24462: PUSH
24463: FOR_TO
24464: IFFALSE 24520
// if mc_bases [ i ] then
24466: LD_EXP 93
24470: PUSH
24471: LD_VAR 0 2
24475: ARRAY
24476: IFFALSE 24518
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24478: LD_ADDR_EXP 119
24482: PUSH
24483: LD_EXP 119
24487: PPUSH
24488: LD_VAR 0 2
24492: PPUSH
24493: LD_EXP 93
24497: PUSH
24498: LD_VAR 0 2
24502: ARRAY
24503: PUSH
24504: LD_INT 1
24506: ARRAY
24507: PPUSH
24508: CALL_OW 255
24512: PPUSH
24513: CALL_OW 1
24517: ST_TO_ADDR
24518: GO 24463
24520: POP
24521: POP
// end ;
24522: LD_VAR 0 1
24526: RET
// every 0 0$03 trigger skirmish do
24527: LD_EXP 91
24531: IFFALSE 24685
24533: GO 24535
24535: DISABLE
// begin enable ;
24536: ENABLE
// MC_CheckBuildings ( ) ;
24537: CALL 29183 0 0
// MC_CheckPeopleLife ( ) ;
24541: CALL 29344 0 0
// RaiseSailEvent ( 100 ) ;
24545: LD_INT 100
24547: PPUSH
24548: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24552: LD_INT 103
24554: PPUSH
24555: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24559: LD_INT 104
24561: PPUSH
24562: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24566: LD_INT 105
24568: PPUSH
24569: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24573: LD_INT 106
24575: PPUSH
24576: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24580: LD_INT 107
24582: PPUSH
24583: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24587: LD_INT 108
24589: PPUSH
24590: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24594: LD_INT 109
24596: PPUSH
24597: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24601: LD_INT 110
24603: PPUSH
24604: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24608: LD_INT 111
24610: PPUSH
24611: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24615: LD_INT 112
24617: PPUSH
24618: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24622: LD_INT 113
24624: PPUSH
24625: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24629: LD_INT 120
24631: PPUSH
24632: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24636: LD_INT 121
24638: PPUSH
24639: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24643: LD_INT 122
24645: PPUSH
24646: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24650: LD_INT 123
24652: PPUSH
24653: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24657: LD_INT 124
24659: PPUSH
24660: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24664: LD_INT 125
24666: PPUSH
24667: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24671: LD_INT 126
24673: PPUSH
24674: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24678: LD_INT 200
24680: PPUSH
24681: CALL_OW 427
// end ;
24685: END
// on SailEvent ( event ) do begin if event < 100 then
24686: LD_VAR 0 1
24690: PUSH
24691: LD_INT 100
24693: LESS
24694: IFFALSE 24705
// CustomEvent ( event ) ;
24696: LD_VAR 0 1
24700: PPUSH
24701: CALL 10473 0 1
// if event = 100 then
24705: LD_VAR 0 1
24709: PUSH
24710: LD_INT 100
24712: EQUAL
24713: IFFALSE 24719
// MC_ClassManager ( ) ;
24715: CALL 25111 0 0
// if event = 101 then
24719: LD_VAR 0 1
24723: PUSH
24724: LD_INT 101
24726: EQUAL
24727: IFFALSE 24733
// MC_RepairBuildings ( ) ;
24729: CALL 29929 0 0
// if event = 102 then
24733: LD_VAR 0 1
24737: PUSH
24738: LD_INT 102
24740: EQUAL
24741: IFFALSE 24747
// MC_Heal ( ) ;
24743: CALL 30836 0 0
// if event = 103 then
24747: LD_VAR 0 1
24751: PUSH
24752: LD_INT 103
24754: EQUAL
24755: IFFALSE 24761
// MC_Build ( ) ;
24757: CALL 31258 0 0
// if event = 104 then
24761: LD_VAR 0 1
24765: PUSH
24766: LD_INT 104
24768: EQUAL
24769: IFFALSE 24775
// MC_TurretWeapon ( ) ;
24771: CALL 32899 0 0
// if event = 105 then
24775: LD_VAR 0 1
24779: PUSH
24780: LD_INT 105
24782: EQUAL
24783: IFFALSE 24789
// MC_BuildUpgrade ( ) ;
24785: CALL 32450 0 0
// if event = 106 then
24789: LD_VAR 0 1
24793: PUSH
24794: LD_INT 106
24796: EQUAL
24797: IFFALSE 24803
// MC_PlantMines ( ) ;
24799: CALL 33329 0 0
// if event = 107 then
24803: LD_VAR 0 1
24807: PUSH
24808: LD_INT 107
24810: EQUAL
24811: IFFALSE 24817
// MC_CollectCrates ( ) ;
24813: CALL 34120 0 0
// if event = 108 then
24817: LD_VAR 0 1
24821: PUSH
24822: LD_INT 108
24824: EQUAL
24825: IFFALSE 24831
// MC_LinkRemoteControl ( ) ;
24827: CALL 35970 0 0
// if event = 109 then
24831: LD_VAR 0 1
24835: PUSH
24836: LD_INT 109
24838: EQUAL
24839: IFFALSE 24845
// MC_ProduceVehicle ( ) ;
24841: CALL 36151 0 0
// if event = 110 then
24845: LD_VAR 0 1
24849: PUSH
24850: LD_INT 110
24852: EQUAL
24853: IFFALSE 24859
// MC_SendAttack ( ) ;
24855: CALL 36617 0 0
// if event = 111 then
24859: LD_VAR 0 1
24863: PUSH
24864: LD_INT 111
24866: EQUAL
24867: IFFALSE 24873
// MC_Defend ( ) ;
24869: CALL 36725 0 0
// if event = 112 then
24873: LD_VAR 0 1
24877: PUSH
24878: LD_INT 112
24880: EQUAL
24881: IFFALSE 24887
// MC_Research ( ) ;
24883: CALL 37605 0 0
// if event = 113 then
24887: LD_VAR 0 1
24891: PUSH
24892: LD_INT 113
24894: EQUAL
24895: IFFALSE 24901
// MC_MinesTrigger ( ) ;
24897: CALL 38719 0 0
// if event = 120 then
24901: LD_VAR 0 1
24905: PUSH
24906: LD_INT 120
24908: EQUAL
24909: IFFALSE 24915
// MC_RepairVehicle ( ) ;
24911: CALL 38818 0 0
// if event = 121 then
24915: LD_VAR 0 1
24919: PUSH
24920: LD_INT 121
24922: EQUAL
24923: IFFALSE 24929
// MC_TameApe ( ) ;
24925: CALL 39559 0 0
// if event = 122 then
24929: LD_VAR 0 1
24933: PUSH
24934: LD_INT 122
24936: EQUAL
24937: IFFALSE 24943
// MC_ChangeApeClass ( ) ;
24939: CALL 40388 0 0
// if event = 123 then
24943: LD_VAR 0 1
24947: PUSH
24948: LD_INT 123
24950: EQUAL
24951: IFFALSE 24957
// MC_Bazooka ( ) ;
24953: CALL 41038 0 0
// if event = 124 then
24957: LD_VAR 0 1
24961: PUSH
24962: LD_INT 124
24964: EQUAL
24965: IFFALSE 24971
// MC_TeleportExit ( ) ;
24967: CALL 41236 0 0
// if event = 125 then
24971: LD_VAR 0 1
24975: PUSH
24976: LD_INT 125
24978: EQUAL
24979: IFFALSE 24985
// MC_Deposits ( ) ;
24981: CALL 41883 0 0
// if event = 126 then
24985: LD_VAR 0 1
24989: PUSH
24990: LD_INT 126
24992: EQUAL
24993: IFFALSE 24999
// MC_RemoteDriver ( ) ;
24995: CALL 42508 0 0
// if event = 200 then
24999: LD_VAR 0 1
25003: PUSH
25004: LD_INT 200
25006: EQUAL
25007: IFFALSE 25013
// MC_Idle ( ) ;
25009: CALL 44457 0 0
// end ;
25013: PPOPN 1
25015: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25016: LD_INT 0
25018: PPUSH
25019: PPUSH
// if not mc_bases [ base ] or not tag then
25020: LD_EXP 93
25024: PUSH
25025: LD_VAR 0 1
25029: ARRAY
25030: NOT
25031: PUSH
25032: LD_VAR 0 2
25036: NOT
25037: OR
25038: IFFALSE 25042
// exit ;
25040: GO 25106
// for i in mc_bases [ base ] union mc_ape [ base ] do
25042: LD_ADDR_VAR 0 4
25046: PUSH
25047: LD_EXP 93
25051: PUSH
25052: LD_VAR 0 1
25056: ARRAY
25057: PUSH
25058: LD_EXP 122
25062: PUSH
25063: LD_VAR 0 1
25067: ARRAY
25068: UNION
25069: PUSH
25070: FOR_IN
25071: IFFALSE 25104
// if GetTag ( i ) = tag then
25073: LD_VAR 0 4
25077: PPUSH
25078: CALL_OW 110
25082: PUSH
25083: LD_VAR 0 2
25087: EQUAL
25088: IFFALSE 25102
// SetTag ( i , 0 ) ;
25090: LD_VAR 0 4
25094: PPUSH
25095: LD_INT 0
25097: PPUSH
25098: CALL_OW 109
25102: GO 25070
25104: POP
25105: POP
// end ;
25106: LD_VAR 0 3
25110: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25111: LD_INT 0
25113: PPUSH
25114: PPUSH
25115: PPUSH
25116: PPUSH
25117: PPUSH
25118: PPUSH
25119: PPUSH
25120: PPUSH
// if not mc_bases then
25121: LD_EXP 93
25125: NOT
25126: IFFALSE 25130
// exit ;
25128: GO 25588
// for i = 1 to mc_bases do
25130: LD_ADDR_VAR 0 2
25134: PUSH
25135: DOUBLE
25136: LD_INT 1
25138: DEC
25139: ST_TO_ADDR
25140: LD_EXP 93
25144: PUSH
25145: FOR_TO
25146: IFFALSE 25586
// begin tmp := MC_ClassCheckReq ( i ) ;
25148: LD_ADDR_VAR 0 4
25152: PUSH
25153: LD_VAR 0 2
25157: PPUSH
25158: CALL 25593 0 1
25162: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25163: LD_ADDR_EXP 134
25167: PUSH
25168: LD_EXP 134
25172: PPUSH
25173: LD_VAR 0 2
25177: PPUSH
25178: LD_VAR 0 4
25182: PPUSH
25183: CALL_OW 1
25187: ST_TO_ADDR
// if not tmp then
25188: LD_VAR 0 4
25192: NOT
25193: IFFALSE 25197
// continue ;
25195: GO 25145
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25197: LD_ADDR_VAR 0 6
25201: PUSH
25202: LD_EXP 93
25206: PUSH
25207: LD_VAR 0 2
25211: ARRAY
25212: PPUSH
25213: LD_INT 2
25215: PUSH
25216: LD_INT 30
25218: PUSH
25219: LD_INT 4
25221: PUSH
25222: EMPTY
25223: LIST
25224: LIST
25225: PUSH
25226: LD_INT 30
25228: PUSH
25229: LD_INT 5
25231: PUSH
25232: EMPTY
25233: LIST
25234: LIST
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: LIST
25240: PPUSH
25241: CALL_OW 72
25245: PUSH
25246: LD_EXP 93
25250: PUSH
25251: LD_VAR 0 2
25255: ARRAY
25256: PPUSH
25257: LD_INT 2
25259: PUSH
25260: LD_INT 30
25262: PUSH
25263: LD_INT 0
25265: PUSH
25266: EMPTY
25267: LIST
25268: LIST
25269: PUSH
25270: LD_INT 30
25272: PUSH
25273: LD_INT 1
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: EMPTY
25281: LIST
25282: LIST
25283: LIST
25284: PPUSH
25285: CALL_OW 72
25289: PUSH
25290: LD_EXP 93
25294: PUSH
25295: LD_VAR 0 2
25299: ARRAY
25300: PPUSH
25301: LD_INT 30
25303: PUSH
25304: LD_INT 3
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: PPUSH
25311: CALL_OW 72
25315: PUSH
25316: LD_EXP 93
25320: PUSH
25321: LD_VAR 0 2
25325: ARRAY
25326: PPUSH
25327: LD_INT 2
25329: PUSH
25330: LD_INT 30
25332: PUSH
25333: LD_INT 6
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PUSH
25340: LD_INT 30
25342: PUSH
25343: LD_INT 7
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 30
25352: PUSH
25353: LD_INT 8
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: PUSH
25360: EMPTY
25361: LIST
25362: LIST
25363: LIST
25364: LIST
25365: PPUSH
25366: CALL_OW 72
25370: PUSH
25371: EMPTY
25372: LIST
25373: LIST
25374: LIST
25375: LIST
25376: ST_TO_ADDR
// for j = 1 to 4 do
25377: LD_ADDR_VAR 0 3
25381: PUSH
25382: DOUBLE
25383: LD_INT 1
25385: DEC
25386: ST_TO_ADDR
25387: LD_INT 4
25389: PUSH
25390: FOR_TO
25391: IFFALSE 25582
// begin if not tmp [ j ] then
25393: LD_VAR 0 4
25397: PUSH
25398: LD_VAR 0 3
25402: ARRAY
25403: NOT
25404: IFFALSE 25408
// continue ;
25406: GO 25390
// for p in tmp [ j ] do
25408: LD_ADDR_VAR 0 5
25412: PUSH
25413: LD_VAR 0 4
25417: PUSH
25418: LD_VAR 0 3
25422: ARRAY
25423: PUSH
25424: FOR_IN
25425: IFFALSE 25578
// begin if not b [ j ] then
25427: LD_VAR 0 6
25431: PUSH
25432: LD_VAR 0 3
25436: ARRAY
25437: NOT
25438: IFFALSE 25442
// break ;
25440: GO 25578
// e := 0 ;
25442: LD_ADDR_VAR 0 7
25446: PUSH
25447: LD_INT 0
25449: ST_TO_ADDR
// for k in b [ j ] do
25450: LD_ADDR_VAR 0 8
25454: PUSH
25455: LD_VAR 0 6
25459: PUSH
25460: LD_VAR 0 3
25464: ARRAY
25465: PUSH
25466: FOR_IN
25467: IFFALSE 25494
// if IsNotFull ( k ) then
25469: LD_VAR 0 8
25473: PPUSH
25474: CALL 53704 0 1
25478: IFFALSE 25492
// begin e := k ;
25480: LD_ADDR_VAR 0 7
25484: PUSH
25485: LD_VAR 0 8
25489: ST_TO_ADDR
// break ;
25490: GO 25494
// end ;
25492: GO 25466
25494: POP
25495: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25496: LD_VAR 0 7
25500: PUSH
25501: LD_VAR 0 5
25505: PPUSH
25506: LD_VAR 0 7
25510: PPUSH
25511: CALL 86868 0 2
25515: NOT
25516: AND
25517: IFFALSE 25576
// begin if IsInUnit ( p ) then
25519: LD_VAR 0 5
25523: PPUSH
25524: CALL_OW 310
25528: IFFALSE 25539
// ComExitBuilding ( p ) ;
25530: LD_VAR 0 5
25534: PPUSH
25535: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25539: LD_VAR 0 5
25543: PPUSH
25544: LD_VAR 0 7
25548: PPUSH
25549: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25553: LD_VAR 0 5
25557: PPUSH
25558: LD_VAR 0 3
25562: PPUSH
25563: CALL_OW 183
// AddComExitBuilding ( p ) ;
25567: LD_VAR 0 5
25571: PPUSH
25572: CALL_OW 182
// end ; end ;
25576: GO 25424
25578: POP
25579: POP
// end ;
25580: GO 25390
25582: POP
25583: POP
// end ;
25584: GO 25145
25586: POP
25587: POP
// end ;
25588: LD_VAR 0 1
25592: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25593: LD_INT 0
25595: PPUSH
25596: PPUSH
25597: PPUSH
25598: PPUSH
25599: PPUSH
25600: PPUSH
25601: PPUSH
25602: PPUSH
25603: PPUSH
25604: PPUSH
25605: PPUSH
25606: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25607: LD_VAR 0 1
25611: NOT
25612: PUSH
25613: LD_EXP 93
25617: PUSH
25618: LD_VAR 0 1
25622: ARRAY
25623: NOT
25624: OR
25625: PUSH
25626: LD_EXP 93
25630: PUSH
25631: LD_VAR 0 1
25635: ARRAY
25636: PPUSH
25637: LD_INT 2
25639: PUSH
25640: LD_INT 30
25642: PUSH
25643: LD_INT 0
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: PUSH
25650: LD_INT 30
25652: PUSH
25653: LD_INT 1
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: LIST
25664: PPUSH
25665: CALL_OW 72
25669: NOT
25670: OR
25671: IFFALSE 25675
// exit ;
25673: GO 29178
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25675: LD_ADDR_VAR 0 4
25679: PUSH
25680: LD_EXP 93
25684: PUSH
25685: LD_VAR 0 1
25689: ARRAY
25690: PPUSH
25691: LD_INT 2
25693: PUSH
25694: LD_INT 25
25696: PUSH
25697: LD_INT 1
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: LD_INT 25
25706: PUSH
25707: LD_INT 2
25709: PUSH
25710: EMPTY
25711: LIST
25712: LIST
25713: PUSH
25714: LD_INT 25
25716: PUSH
25717: LD_INT 3
25719: PUSH
25720: EMPTY
25721: LIST
25722: LIST
25723: PUSH
25724: LD_INT 25
25726: PUSH
25727: LD_INT 4
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: PUSH
25734: LD_INT 25
25736: PUSH
25737: LD_INT 5
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: PUSH
25744: LD_INT 25
25746: PUSH
25747: LD_INT 8
25749: PUSH
25750: EMPTY
25751: LIST
25752: LIST
25753: PUSH
25754: LD_INT 25
25756: PUSH
25757: LD_INT 9
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: LIST
25768: LIST
25769: LIST
25770: LIST
25771: LIST
25772: LIST
25773: PPUSH
25774: CALL_OW 72
25778: ST_TO_ADDR
// if not tmp then
25779: LD_VAR 0 4
25783: NOT
25784: IFFALSE 25788
// exit ;
25786: GO 29178
// for i in tmp do
25788: LD_ADDR_VAR 0 3
25792: PUSH
25793: LD_VAR 0 4
25797: PUSH
25798: FOR_IN
25799: IFFALSE 25830
// if GetTag ( i ) then
25801: LD_VAR 0 3
25805: PPUSH
25806: CALL_OW 110
25810: IFFALSE 25828
// tmp := tmp diff i ;
25812: LD_ADDR_VAR 0 4
25816: PUSH
25817: LD_VAR 0 4
25821: PUSH
25822: LD_VAR 0 3
25826: DIFF
25827: ST_TO_ADDR
25828: GO 25798
25830: POP
25831: POP
// if not tmp then
25832: LD_VAR 0 4
25836: NOT
25837: IFFALSE 25841
// exit ;
25839: GO 29178
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25841: LD_ADDR_VAR 0 5
25845: PUSH
25846: LD_EXP 93
25850: PUSH
25851: LD_VAR 0 1
25855: ARRAY
25856: PPUSH
25857: LD_INT 2
25859: PUSH
25860: LD_INT 25
25862: PUSH
25863: LD_INT 1
25865: PUSH
25866: EMPTY
25867: LIST
25868: LIST
25869: PUSH
25870: LD_INT 25
25872: PUSH
25873: LD_INT 5
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: PUSH
25880: LD_INT 25
25882: PUSH
25883: LD_INT 8
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 25
25892: PUSH
25893: LD_INT 9
25895: PUSH
25896: EMPTY
25897: LIST
25898: LIST
25899: PUSH
25900: EMPTY
25901: LIST
25902: LIST
25903: LIST
25904: LIST
25905: LIST
25906: PPUSH
25907: CALL_OW 72
25911: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25912: LD_ADDR_VAR 0 6
25916: PUSH
25917: LD_EXP 93
25921: PUSH
25922: LD_VAR 0 1
25926: ARRAY
25927: PPUSH
25928: LD_INT 25
25930: PUSH
25931: LD_INT 2
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PPUSH
25938: CALL_OW 72
25942: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25943: LD_ADDR_VAR 0 7
25947: PUSH
25948: LD_EXP 93
25952: PUSH
25953: LD_VAR 0 1
25957: ARRAY
25958: PPUSH
25959: LD_INT 25
25961: PUSH
25962: LD_INT 3
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PPUSH
25969: CALL_OW 72
25973: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25974: LD_ADDR_VAR 0 8
25978: PUSH
25979: LD_EXP 93
25983: PUSH
25984: LD_VAR 0 1
25988: ARRAY
25989: PPUSH
25990: LD_INT 25
25992: PUSH
25993: LD_INT 4
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: PUSH
26000: LD_INT 24
26002: PUSH
26003: LD_INT 251
26005: PUSH
26006: EMPTY
26007: LIST
26008: LIST
26009: PUSH
26010: EMPTY
26011: LIST
26012: LIST
26013: PPUSH
26014: CALL_OW 72
26018: ST_TO_ADDR
// if mc_is_defending [ base ] then
26019: LD_EXP 136
26023: PUSH
26024: LD_VAR 0 1
26028: ARRAY
26029: IFFALSE 26490
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26031: LD_ADDR_EXP 135
26035: PUSH
26036: LD_EXP 135
26040: PPUSH
26041: LD_VAR 0 1
26045: PPUSH
26046: LD_INT 4
26048: PPUSH
26049: CALL_OW 1
26053: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26054: LD_ADDR_VAR 0 12
26058: PUSH
26059: LD_EXP 93
26063: PUSH
26064: LD_VAR 0 1
26068: ARRAY
26069: PPUSH
26070: LD_INT 2
26072: PUSH
26073: LD_INT 30
26075: PUSH
26076: LD_INT 4
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PUSH
26083: LD_INT 30
26085: PUSH
26086: LD_INT 5
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: LIST
26097: PPUSH
26098: CALL_OW 72
26102: ST_TO_ADDR
// if not b then
26103: LD_VAR 0 12
26107: NOT
26108: IFFALSE 26112
// exit ;
26110: GO 29178
// p := [ ] ;
26112: LD_ADDR_VAR 0 11
26116: PUSH
26117: EMPTY
26118: ST_TO_ADDR
// if sci >= 2 then
26119: LD_VAR 0 8
26123: PUSH
26124: LD_INT 2
26126: GREATEREQUAL
26127: IFFALSE 26158
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26129: LD_ADDR_VAR 0 8
26133: PUSH
26134: LD_VAR 0 8
26138: PUSH
26139: LD_INT 1
26141: ARRAY
26142: PUSH
26143: LD_VAR 0 8
26147: PUSH
26148: LD_INT 2
26150: ARRAY
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: ST_TO_ADDR
26156: GO 26219
// if sci = 1 then
26158: LD_VAR 0 8
26162: PUSH
26163: LD_INT 1
26165: EQUAL
26166: IFFALSE 26187
// sci := [ sci [ 1 ] ] else
26168: LD_ADDR_VAR 0 8
26172: PUSH
26173: LD_VAR 0 8
26177: PUSH
26178: LD_INT 1
26180: ARRAY
26181: PUSH
26182: EMPTY
26183: LIST
26184: ST_TO_ADDR
26185: GO 26219
// if sci = 0 then
26187: LD_VAR 0 8
26191: PUSH
26192: LD_INT 0
26194: EQUAL
26195: IFFALSE 26219
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26197: LD_ADDR_VAR 0 11
26201: PUSH
26202: LD_VAR 0 4
26206: PPUSH
26207: LD_INT 4
26209: PPUSH
26210: CALL 86731 0 2
26214: PUSH
26215: LD_INT 1
26217: ARRAY
26218: ST_TO_ADDR
// if eng > 4 then
26219: LD_VAR 0 6
26223: PUSH
26224: LD_INT 4
26226: GREATER
26227: IFFALSE 26273
// for i = eng downto 4 do
26229: LD_ADDR_VAR 0 3
26233: PUSH
26234: DOUBLE
26235: LD_VAR 0 6
26239: INC
26240: ST_TO_ADDR
26241: LD_INT 4
26243: PUSH
26244: FOR_DOWNTO
26245: IFFALSE 26271
// eng := eng diff eng [ i ] ;
26247: LD_ADDR_VAR 0 6
26251: PUSH
26252: LD_VAR 0 6
26256: PUSH
26257: LD_VAR 0 6
26261: PUSH
26262: LD_VAR 0 3
26266: ARRAY
26267: DIFF
26268: ST_TO_ADDR
26269: GO 26244
26271: POP
26272: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26273: LD_ADDR_VAR 0 4
26277: PUSH
26278: LD_VAR 0 4
26282: PUSH
26283: LD_VAR 0 5
26287: PUSH
26288: LD_VAR 0 6
26292: UNION
26293: PUSH
26294: LD_VAR 0 7
26298: UNION
26299: PUSH
26300: LD_VAR 0 8
26304: UNION
26305: DIFF
26306: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26307: LD_ADDR_VAR 0 13
26311: PUSH
26312: LD_EXP 93
26316: PUSH
26317: LD_VAR 0 1
26321: ARRAY
26322: PPUSH
26323: LD_INT 2
26325: PUSH
26326: LD_INT 30
26328: PUSH
26329: LD_INT 32
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 30
26338: PUSH
26339: LD_INT 31
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: LIST
26350: PPUSH
26351: CALL_OW 72
26355: PUSH
26356: LD_EXP 93
26360: PUSH
26361: LD_VAR 0 1
26365: ARRAY
26366: PPUSH
26367: LD_INT 2
26369: PUSH
26370: LD_INT 30
26372: PUSH
26373: LD_INT 4
26375: PUSH
26376: EMPTY
26377: LIST
26378: LIST
26379: PUSH
26380: LD_INT 30
26382: PUSH
26383: LD_INT 5
26385: PUSH
26386: EMPTY
26387: LIST
26388: LIST
26389: PUSH
26390: EMPTY
26391: LIST
26392: LIST
26393: LIST
26394: PPUSH
26395: CALL_OW 72
26399: PUSH
26400: LD_INT 6
26402: MUL
26403: PLUS
26404: ST_TO_ADDR
// if bcount < tmp then
26405: LD_VAR 0 13
26409: PUSH
26410: LD_VAR 0 4
26414: LESS
26415: IFFALSE 26461
// for i = tmp downto bcount do
26417: LD_ADDR_VAR 0 3
26421: PUSH
26422: DOUBLE
26423: LD_VAR 0 4
26427: INC
26428: ST_TO_ADDR
26429: LD_VAR 0 13
26433: PUSH
26434: FOR_DOWNTO
26435: IFFALSE 26459
// tmp := Delete ( tmp , tmp ) ;
26437: LD_ADDR_VAR 0 4
26441: PUSH
26442: LD_VAR 0 4
26446: PPUSH
26447: LD_VAR 0 4
26451: PPUSH
26452: CALL_OW 3
26456: ST_TO_ADDR
26457: GO 26434
26459: POP
26460: POP
// result := [ tmp , 0 , 0 , p ] ;
26461: LD_ADDR_VAR 0 2
26465: PUSH
26466: LD_VAR 0 4
26470: PUSH
26471: LD_INT 0
26473: PUSH
26474: LD_INT 0
26476: PUSH
26477: LD_VAR 0 11
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: LIST
26486: LIST
26487: ST_TO_ADDR
// exit ;
26488: GO 29178
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26490: LD_EXP 93
26494: PUSH
26495: LD_VAR 0 1
26499: ARRAY
26500: PPUSH
26501: LD_INT 2
26503: PUSH
26504: LD_INT 30
26506: PUSH
26507: LD_INT 6
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PUSH
26514: LD_INT 30
26516: PUSH
26517: LD_INT 7
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: PUSH
26524: LD_INT 30
26526: PUSH
26527: LD_INT 8
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: LIST
26538: LIST
26539: PPUSH
26540: CALL_OW 72
26544: NOT
26545: PUSH
26546: LD_EXP 93
26550: PUSH
26551: LD_VAR 0 1
26555: ARRAY
26556: PPUSH
26557: LD_INT 30
26559: PUSH
26560: LD_INT 3
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: PPUSH
26567: CALL_OW 72
26571: NOT
26572: AND
26573: IFFALSE 26645
// begin if eng = tmp then
26575: LD_VAR 0 6
26579: PUSH
26580: LD_VAR 0 4
26584: EQUAL
26585: IFFALSE 26589
// exit ;
26587: GO 29178
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26589: LD_ADDR_EXP 135
26593: PUSH
26594: LD_EXP 135
26598: PPUSH
26599: LD_VAR 0 1
26603: PPUSH
26604: LD_INT 1
26606: PPUSH
26607: CALL_OW 1
26611: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26612: LD_ADDR_VAR 0 2
26616: PUSH
26617: LD_INT 0
26619: PUSH
26620: LD_VAR 0 4
26624: PUSH
26625: LD_VAR 0 6
26629: DIFF
26630: PUSH
26631: LD_INT 0
26633: PUSH
26634: LD_INT 0
26636: PUSH
26637: EMPTY
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: ST_TO_ADDR
// exit ;
26643: GO 29178
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26645: LD_EXP 120
26649: PUSH
26650: LD_EXP 119
26654: PUSH
26655: LD_VAR 0 1
26659: ARRAY
26660: ARRAY
26661: PUSH
26662: LD_EXP 93
26666: PUSH
26667: LD_VAR 0 1
26671: ARRAY
26672: PPUSH
26673: LD_INT 2
26675: PUSH
26676: LD_INT 30
26678: PUSH
26679: LD_INT 6
26681: PUSH
26682: EMPTY
26683: LIST
26684: LIST
26685: PUSH
26686: LD_INT 30
26688: PUSH
26689: LD_INT 7
26691: PUSH
26692: EMPTY
26693: LIST
26694: LIST
26695: PUSH
26696: LD_INT 30
26698: PUSH
26699: LD_INT 8
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: LIST
26710: LIST
26711: PPUSH
26712: CALL_OW 72
26716: AND
26717: PUSH
26718: LD_EXP 93
26722: PUSH
26723: LD_VAR 0 1
26727: ARRAY
26728: PPUSH
26729: LD_INT 30
26731: PUSH
26732: LD_INT 3
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL_OW 72
26743: NOT
26744: AND
26745: IFFALSE 26959
// begin if sci >= 6 then
26747: LD_VAR 0 8
26751: PUSH
26752: LD_INT 6
26754: GREATEREQUAL
26755: IFFALSE 26759
// exit ;
26757: GO 29178
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26759: LD_ADDR_EXP 135
26763: PUSH
26764: LD_EXP 135
26768: PPUSH
26769: LD_VAR 0 1
26773: PPUSH
26774: LD_INT 2
26776: PPUSH
26777: CALL_OW 1
26781: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26782: LD_ADDR_VAR 0 9
26786: PUSH
26787: LD_VAR 0 4
26791: PUSH
26792: LD_VAR 0 8
26796: DIFF
26797: PPUSH
26798: LD_INT 4
26800: PPUSH
26801: CALL 86731 0 2
26805: ST_TO_ADDR
// p := [ ] ;
26806: LD_ADDR_VAR 0 11
26810: PUSH
26811: EMPTY
26812: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26813: LD_VAR 0 8
26817: PUSH
26818: LD_INT 6
26820: LESS
26821: PUSH
26822: LD_VAR 0 9
26826: PUSH
26827: LD_INT 6
26829: GREATER
26830: AND
26831: IFFALSE 26912
// begin for i = 1 to 6 - sci do
26833: LD_ADDR_VAR 0 3
26837: PUSH
26838: DOUBLE
26839: LD_INT 1
26841: DEC
26842: ST_TO_ADDR
26843: LD_INT 6
26845: PUSH
26846: LD_VAR 0 8
26850: MINUS
26851: PUSH
26852: FOR_TO
26853: IFFALSE 26908
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26855: LD_ADDR_VAR 0 11
26859: PUSH
26860: LD_VAR 0 11
26864: PPUSH
26865: LD_VAR 0 11
26869: PUSH
26870: LD_INT 1
26872: PLUS
26873: PPUSH
26874: LD_VAR 0 9
26878: PUSH
26879: LD_INT 1
26881: ARRAY
26882: PPUSH
26883: CALL_OW 2
26887: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26888: LD_ADDR_VAR 0 9
26892: PUSH
26893: LD_VAR 0 9
26897: PPUSH
26898: LD_INT 1
26900: PPUSH
26901: CALL_OW 3
26905: ST_TO_ADDR
// end ;
26906: GO 26852
26908: POP
26909: POP
// end else
26910: GO 26932
// if sort then
26912: LD_VAR 0 9
26916: IFFALSE 26932
// p := sort [ 1 ] ;
26918: LD_ADDR_VAR 0 11
26922: PUSH
26923: LD_VAR 0 9
26927: PUSH
26928: LD_INT 1
26930: ARRAY
26931: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26932: LD_ADDR_VAR 0 2
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: LD_INT 0
26942: PUSH
26943: LD_INT 0
26945: PUSH
26946: LD_VAR 0 11
26950: PUSH
26951: EMPTY
26952: LIST
26953: LIST
26954: LIST
26955: LIST
26956: ST_TO_ADDR
// exit ;
26957: GO 29178
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26959: LD_EXP 120
26963: PUSH
26964: LD_EXP 119
26968: PUSH
26969: LD_VAR 0 1
26973: ARRAY
26974: ARRAY
26975: PUSH
26976: LD_EXP 93
26980: PUSH
26981: LD_VAR 0 1
26985: ARRAY
26986: PPUSH
26987: LD_INT 2
26989: PUSH
26990: LD_INT 30
26992: PUSH
26993: LD_INT 6
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: PUSH
27000: LD_INT 30
27002: PUSH
27003: LD_INT 7
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 30
27012: PUSH
27013: LD_INT 8
27015: PUSH
27016: EMPTY
27017: LIST
27018: LIST
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: PPUSH
27026: CALL_OW 72
27030: AND
27031: PUSH
27032: LD_EXP 93
27036: PUSH
27037: LD_VAR 0 1
27041: ARRAY
27042: PPUSH
27043: LD_INT 30
27045: PUSH
27046: LD_INT 3
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: PPUSH
27053: CALL_OW 72
27057: AND
27058: IFFALSE 27792
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27060: LD_ADDR_EXP 135
27064: PUSH
27065: LD_EXP 135
27069: PPUSH
27070: LD_VAR 0 1
27074: PPUSH
27075: LD_INT 3
27077: PPUSH
27078: CALL_OW 1
27082: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27083: LD_ADDR_VAR 0 2
27087: PUSH
27088: LD_INT 0
27090: PUSH
27091: LD_INT 0
27093: PUSH
27094: LD_INT 0
27096: PUSH
27097: LD_INT 0
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: LIST
27104: LIST
27105: ST_TO_ADDR
// if not eng then
27106: LD_VAR 0 6
27110: NOT
27111: IFFALSE 27174
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27113: LD_ADDR_VAR 0 11
27117: PUSH
27118: LD_VAR 0 4
27122: PPUSH
27123: LD_INT 2
27125: PPUSH
27126: CALL 86731 0 2
27130: PUSH
27131: LD_INT 1
27133: ARRAY
27134: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27135: LD_ADDR_VAR 0 2
27139: PUSH
27140: LD_VAR 0 2
27144: PPUSH
27145: LD_INT 2
27147: PPUSH
27148: LD_VAR 0 11
27152: PPUSH
27153: CALL_OW 1
27157: ST_TO_ADDR
// tmp := tmp diff p ;
27158: LD_ADDR_VAR 0 4
27162: PUSH
27163: LD_VAR 0 4
27167: PUSH
27168: LD_VAR 0 11
27172: DIFF
27173: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27174: LD_VAR 0 4
27178: PUSH
27179: LD_VAR 0 8
27183: PUSH
27184: LD_INT 6
27186: LESS
27187: AND
27188: IFFALSE 27376
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27190: LD_ADDR_VAR 0 9
27194: PUSH
27195: LD_VAR 0 4
27199: PUSH
27200: LD_VAR 0 8
27204: PUSH
27205: LD_VAR 0 7
27209: UNION
27210: DIFF
27211: PPUSH
27212: LD_INT 4
27214: PPUSH
27215: CALL 86731 0 2
27219: ST_TO_ADDR
// p := [ ] ;
27220: LD_ADDR_VAR 0 11
27224: PUSH
27225: EMPTY
27226: ST_TO_ADDR
// if sort then
27227: LD_VAR 0 9
27231: IFFALSE 27347
// for i = 1 to 6 - sci do
27233: LD_ADDR_VAR 0 3
27237: PUSH
27238: DOUBLE
27239: LD_INT 1
27241: DEC
27242: ST_TO_ADDR
27243: LD_INT 6
27245: PUSH
27246: LD_VAR 0 8
27250: MINUS
27251: PUSH
27252: FOR_TO
27253: IFFALSE 27345
// begin if i = sort then
27255: LD_VAR 0 3
27259: PUSH
27260: LD_VAR 0 9
27264: EQUAL
27265: IFFALSE 27269
// break ;
27267: GO 27345
// if GetClass ( i ) = 4 then
27269: LD_VAR 0 3
27273: PPUSH
27274: CALL_OW 257
27278: PUSH
27279: LD_INT 4
27281: EQUAL
27282: IFFALSE 27286
// continue ;
27284: GO 27252
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27286: LD_ADDR_VAR 0 11
27290: PUSH
27291: LD_VAR 0 11
27295: PPUSH
27296: LD_VAR 0 11
27300: PUSH
27301: LD_INT 1
27303: PLUS
27304: PPUSH
27305: LD_VAR 0 9
27309: PUSH
27310: LD_VAR 0 3
27314: ARRAY
27315: PPUSH
27316: CALL_OW 2
27320: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27321: LD_ADDR_VAR 0 4
27325: PUSH
27326: LD_VAR 0 4
27330: PUSH
27331: LD_VAR 0 9
27335: PUSH
27336: LD_VAR 0 3
27340: ARRAY
27341: DIFF
27342: ST_TO_ADDR
// end ;
27343: GO 27252
27345: POP
27346: POP
// if p then
27347: LD_VAR 0 11
27351: IFFALSE 27376
// result := Replace ( result , 4 , p ) ;
27353: LD_ADDR_VAR 0 2
27357: PUSH
27358: LD_VAR 0 2
27362: PPUSH
27363: LD_INT 4
27365: PPUSH
27366: LD_VAR 0 11
27370: PPUSH
27371: CALL_OW 1
27375: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27376: LD_VAR 0 4
27380: PUSH
27381: LD_VAR 0 7
27385: PUSH
27386: LD_INT 6
27388: LESS
27389: AND
27390: IFFALSE 27578
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27392: LD_ADDR_VAR 0 9
27396: PUSH
27397: LD_VAR 0 4
27401: PUSH
27402: LD_VAR 0 8
27406: PUSH
27407: LD_VAR 0 7
27411: UNION
27412: DIFF
27413: PPUSH
27414: LD_INT 3
27416: PPUSH
27417: CALL 86731 0 2
27421: ST_TO_ADDR
// p := [ ] ;
27422: LD_ADDR_VAR 0 11
27426: PUSH
27427: EMPTY
27428: ST_TO_ADDR
// if sort then
27429: LD_VAR 0 9
27433: IFFALSE 27549
// for i = 1 to 6 - mech do
27435: LD_ADDR_VAR 0 3
27439: PUSH
27440: DOUBLE
27441: LD_INT 1
27443: DEC
27444: ST_TO_ADDR
27445: LD_INT 6
27447: PUSH
27448: LD_VAR 0 7
27452: MINUS
27453: PUSH
27454: FOR_TO
27455: IFFALSE 27547
// begin if i = sort then
27457: LD_VAR 0 3
27461: PUSH
27462: LD_VAR 0 9
27466: EQUAL
27467: IFFALSE 27471
// break ;
27469: GO 27547
// if GetClass ( i ) = 3 then
27471: LD_VAR 0 3
27475: PPUSH
27476: CALL_OW 257
27480: PUSH
27481: LD_INT 3
27483: EQUAL
27484: IFFALSE 27488
// continue ;
27486: GO 27454
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27488: LD_ADDR_VAR 0 11
27492: PUSH
27493: LD_VAR 0 11
27497: PPUSH
27498: LD_VAR 0 11
27502: PUSH
27503: LD_INT 1
27505: PLUS
27506: PPUSH
27507: LD_VAR 0 9
27511: PUSH
27512: LD_VAR 0 3
27516: ARRAY
27517: PPUSH
27518: CALL_OW 2
27522: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27523: LD_ADDR_VAR 0 4
27527: PUSH
27528: LD_VAR 0 4
27532: PUSH
27533: LD_VAR 0 9
27537: PUSH
27538: LD_VAR 0 3
27542: ARRAY
27543: DIFF
27544: ST_TO_ADDR
// end ;
27545: GO 27454
27547: POP
27548: POP
// if p then
27549: LD_VAR 0 11
27553: IFFALSE 27578
// result := Replace ( result , 3 , p ) ;
27555: LD_ADDR_VAR 0 2
27559: PUSH
27560: LD_VAR 0 2
27564: PPUSH
27565: LD_INT 3
27567: PPUSH
27568: LD_VAR 0 11
27572: PPUSH
27573: CALL_OW 1
27577: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27578: LD_VAR 0 4
27582: PUSH
27583: LD_INT 6
27585: GREATER
27586: PUSH
27587: LD_VAR 0 6
27591: PUSH
27592: LD_INT 6
27594: LESS
27595: AND
27596: IFFALSE 27790
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27598: LD_ADDR_VAR 0 9
27602: PUSH
27603: LD_VAR 0 4
27607: PUSH
27608: LD_VAR 0 8
27612: PUSH
27613: LD_VAR 0 7
27617: UNION
27618: PUSH
27619: LD_VAR 0 6
27623: UNION
27624: DIFF
27625: PPUSH
27626: LD_INT 2
27628: PPUSH
27629: CALL 86731 0 2
27633: ST_TO_ADDR
// p := [ ] ;
27634: LD_ADDR_VAR 0 11
27638: PUSH
27639: EMPTY
27640: ST_TO_ADDR
// if sort then
27641: LD_VAR 0 9
27645: IFFALSE 27761
// for i = 1 to 6 - eng do
27647: LD_ADDR_VAR 0 3
27651: PUSH
27652: DOUBLE
27653: LD_INT 1
27655: DEC
27656: ST_TO_ADDR
27657: LD_INT 6
27659: PUSH
27660: LD_VAR 0 6
27664: MINUS
27665: PUSH
27666: FOR_TO
27667: IFFALSE 27759
// begin if i = sort then
27669: LD_VAR 0 3
27673: PUSH
27674: LD_VAR 0 9
27678: EQUAL
27679: IFFALSE 27683
// break ;
27681: GO 27759
// if GetClass ( i ) = 2 then
27683: LD_VAR 0 3
27687: PPUSH
27688: CALL_OW 257
27692: PUSH
27693: LD_INT 2
27695: EQUAL
27696: IFFALSE 27700
// continue ;
27698: GO 27666
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27700: LD_ADDR_VAR 0 11
27704: PUSH
27705: LD_VAR 0 11
27709: PPUSH
27710: LD_VAR 0 11
27714: PUSH
27715: LD_INT 1
27717: PLUS
27718: PPUSH
27719: LD_VAR 0 9
27723: PUSH
27724: LD_VAR 0 3
27728: ARRAY
27729: PPUSH
27730: CALL_OW 2
27734: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27735: LD_ADDR_VAR 0 4
27739: PUSH
27740: LD_VAR 0 4
27744: PUSH
27745: LD_VAR 0 9
27749: PUSH
27750: LD_VAR 0 3
27754: ARRAY
27755: DIFF
27756: ST_TO_ADDR
// end ;
27757: GO 27666
27759: POP
27760: POP
// if p then
27761: LD_VAR 0 11
27765: IFFALSE 27790
// result := Replace ( result , 2 , p ) ;
27767: LD_ADDR_VAR 0 2
27771: PUSH
27772: LD_VAR 0 2
27776: PPUSH
27777: LD_INT 2
27779: PPUSH
27780: LD_VAR 0 11
27784: PPUSH
27785: CALL_OW 1
27789: ST_TO_ADDR
// end ; exit ;
27790: GO 29178
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27792: LD_EXP 120
27796: PUSH
27797: LD_EXP 119
27801: PUSH
27802: LD_VAR 0 1
27806: ARRAY
27807: ARRAY
27808: NOT
27809: PUSH
27810: LD_EXP 93
27814: PUSH
27815: LD_VAR 0 1
27819: ARRAY
27820: PPUSH
27821: LD_INT 30
27823: PUSH
27824: LD_INT 3
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PPUSH
27831: CALL_OW 72
27835: AND
27836: PUSH
27837: LD_EXP 98
27841: PUSH
27842: LD_VAR 0 1
27846: ARRAY
27847: AND
27848: IFFALSE 28456
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27850: LD_ADDR_EXP 135
27854: PUSH
27855: LD_EXP 135
27859: PPUSH
27860: LD_VAR 0 1
27864: PPUSH
27865: LD_INT 5
27867: PPUSH
27868: CALL_OW 1
27872: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27873: LD_ADDR_VAR 0 2
27877: PUSH
27878: LD_INT 0
27880: PUSH
27881: LD_INT 0
27883: PUSH
27884: LD_INT 0
27886: PUSH
27887: LD_INT 0
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: LIST
27894: LIST
27895: ST_TO_ADDR
// if sci > 1 then
27896: LD_VAR 0 8
27900: PUSH
27901: LD_INT 1
27903: GREATER
27904: IFFALSE 27932
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27906: LD_ADDR_VAR 0 4
27910: PUSH
27911: LD_VAR 0 4
27915: PUSH
27916: LD_VAR 0 8
27920: PUSH
27921: LD_VAR 0 8
27925: PUSH
27926: LD_INT 1
27928: ARRAY
27929: DIFF
27930: DIFF
27931: ST_TO_ADDR
// if tmp and not sci then
27932: LD_VAR 0 4
27936: PUSH
27937: LD_VAR 0 8
27941: NOT
27942: AND
27943: IFFALSE 28012
// begin sort := SortBySkill ( tmp , 4 ) ;
27945: LD_ADDR_VAR 0 9
27949: PUSH
27950: LD_VAR 0 4
27954: PPUSH
27955: LD_INT 4
27957: PPUSH
27958: CALL 86731 0 2
27962: ST_TO_ADDR
// if sort then
27963: LD_VAR 0 9
27967: IFFALSE 27983
// p := sort [ 1 ] ;
27969: LD_ADDR_VAR 0 11
27973: PUSH
27974: LD_VAR 0 9
27978: PUSH
27979: LD_INT 1
27981: ARRAY
27982: ST_TO_ADDR
// if p then
27983: LD_VAR 0 11
27987: IFFALSE 28012
// result := Replace ( result , 4 , p ) ;
27989: LD_ADDR_VAR 0 2
27993: PUSH
27994: LD_VAR 0 2
27998: PPUSH
27999: LD_INT 4
28001: PPUSH
28002: LD_VAR 0 11
28006: PPUSH
28007: CALL_OW 1
28011: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28012: LD_ADDR_VAR 0 4
28016: PUSH
28017: LD_VAR 0 4
28021: PUSH
28022: LD_VAR 0 7
28026: DIFF
28027: ST_TO_ADDR
// if tmp and mech < 6 then
28028: LD_VAR 0 4
28032: PUSH
28033: LD_VAR 0 7
28037: PUSH
28038: LD_INT 6
28040: LESS
28041: AND
28042: IFFALSE 28230
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28044: LD_ADDR_VAR 0 9
28048: PUSH
28049: LD_VAR 0 4
28053: PUSH
28054: LD_VAR 0 8
28058: PUSH
28059: LD_VAR 0 7
28063: UNION
28064: DIFF
28065: PPUSH
28066: LD_INT 3
28068: PPUSH
28069: CALL 86731 0 2
28073: ST_TO_ADDR
// p := [ ] ;
28074: LD_ADDR_VAR 0 11
28078: PUSH
28079: EMPTY
28080: ST_TO_ADDR
// if sort then
28081: LD_VAR 0 9
28085: IFFALSE 28201
// for i = 1 to 6 - mech do
28087: LD_ADDR_VAR 0 3
28091: PUSH
28092: DOUBLE
28093: LD_INT 1
28095: DEC
28096: ST_TO_ADDR
28097: LD_INT 6
28099: PUSH
28100: LD_VAR 0 7
28104: MINUS
28105: PUSH
28106: FOR_TO
28107: IFFALSE 28199
// begin if i = sort then
28109: LD_VAR 0 3
28113: PUSH
28114: LD_VAR 0 9
28118: EQUAL
28119: IFFALSE 28123
// break ;
28121: GO 28199
// if GetClass ( i ) = 3 then
28123: LD_VAR 0 3
28127: PPUSH
28128: CALL_OW 257
28132: PUSH
28133: LD_INT 3
28135: EQUAL
28136: IFFALSE 28140
// continue ;
28138: GO 28106
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28140: LD_ADDR_VAR 0 11
28144: PUSH
28145: LD_VAR 0 11
28149: PPUSH
28150: LD_VAR 0 11
28154: PUSH
28155: LD_INT 1
28157: PLUS
28158: PPUSH
28159: LD_VAR 0 9
28163: PUSH
28164: LD_VAR 0 3
28168: ARRAY
28169: PPUSH
28170: CALL_OW 2
28174: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28175: LD_ADDR_VAR 0 4
28179: PUSH
28180: LD_VAR 0 4
28184: PUSH
28185: LD_VAR 0 9
28189: PUSH
28190: LD_VAR 0 3
28194: ARRAY
28195: DIFF
28196: ST_TO_ADDR
// end ;
28197: GO 28106
28199: POP
28200: POP
// if p then
28201: LD_VAR 0 11
28205: IFFALSE 28230
// result := Replace ( result , 3 , p ) ;
28207: LD_ADDR_VAR 0 2
28211: PUSH
28212: LD_VAR 0 2
28216: PPUSH
28217: LD_INT 3
28219: PPUSH
28220: LD_VAR 0 11
28224: PPUSH
28225: CALL_OW 1
28229: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28230: LD_ADDR_VAR 0 4
28234: PUSH
28235: LD_VAR 0 4
28239: PUSH
28240: LD_VAR 0 6
28244: DIFF
28245: ST_TO_ADDR
// if tmp and eng < 6 then
28246: LD_VAR 0 4
28250: PUSH
28251: LD_VAR 0 6
28255: PUSH
28256: LD_INT 6
28258: LESS
28259: AND
28260: IFFALSE 28454
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28262: LD_ADDR_VAR 0 9
28266: PUSH
28267: LD_VAR 0 4
28271: PUSH
28272: LD_VAR 0 8
28276: PUSH
28277: LD_VAR 0 7
28281: UNION
28282: PUSH
28283: LD_VAR 0 6
28287: UNION
28288: DIFF
28289: PPUSH
28290: LD_INT 2
28292: PPUSH
28293: CALL 86731 0 2
28297: ST_TO_ADDR
// p := [ ] ;
28298: LD_ADDR_VAR 0 11
28302: PUSH
28303: EMPTY
28304: ST_TO_ADDR
// if sort then
28305: LD_VAR 0 9
28309: IFFALSE 28425
// for i = 1 to 6 - eng do
28311: LD_ADDR_VAR 0 3
28315: PUSH
28316: DOUBLE
28317: LD_INT 1
28319: DEC
28320: ST_TO_ADDR
28321: LD_INT 6
28323: PUSH
28324: LD_VAR 0 6
28328: MINUS
28329: PUSH
28330: FOR_TO
28331: IFFALSE 28423
// begin if i = sort then
28333: LD_VAR 0 3
28337: PUSH
28338: LD_VAR 0 9
28342: EQUAL
28343: IFFALSE 28347
// break ;
28345: GO 28423
// if GetClass ( i ) = 2 then
28347: LD_VAR 0 3
28351: PPUSH
28352: CALL_OW 257
28356: PUSH
28357: LD_INT 2
28359: EQUAL
28360: IFFALSE 28364
// continue ;
28362: GO 28330
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28364: LD_ADDR_VAR 0 11
28368: PUSH
28369: LD_VAR 0 11
28373: PPUSH
28374: LD_VAR 0 11
28378: PUSH
28379: LD_INT 1
28381: PLUS
28382: PPUSH
28383: LD_VAR 0 9
28387: PUSH
28388: LD_VAR 0 3
28392: ARRAY
28393: PPUSH
28394: CALL_OW 2
28398: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28399: LD_ADDR_VAR 0 4
28403: PUSH
28404: LD_VAR 0 4
28408: PUSH
28409: LD_VAR 0 9
28413: PUSH
28414: LD_VAR 0 3
28418: ARRAY
28419: DIFF
28420: ST_TO_ADDR
// end ;
28421: GO 28330
28423: POP
28424: POP
// if p then
28425: LD_VAR 0 11
28429: IFFALSE 28454
// result := Replace ( result , 2 , p ) ;
28431: LD_ADDR_VAR 0 2
28435: PUSH
28436: LD_VAR 0 2
28440: PPUSH
28441: LD_INT 2
28443: PPUSH
28444: LD_VAR 0 11
28448: PPUSH
28449: CALL_OW 1
28453: ST_TO_ADDR
// end ; exit ;
28454: GO 29178
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28456: LD_EXP 120
28460: PUSH
28461: LD_EXP 119
28465: PUSH
28466: LD_VAR 0 1
28470: ARRAY
28471: ARRAY
28472: NOT
28473: PUSH
28474: LD_EXP 93
28478: PUSH
28479: LD_VAR 0 1
28483: ARRAY
28484: PPUSH
28485: LD_INT 30
28487: PUSH
28488: LD_INT 3
28490: PUSH
28491: EMPTY
28492: LIST
28493: LIST
28494: PPUSH
28495: CALL_OW 72
28499: AND
28500: PUSH
28501: LD_EXP 98
28505: PUSH
28506: LD_VAR 0 1
28510: ARRAY
28511: NOT
28512: AND
28513: IFFALSE 29178
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28515: LD_ADDR_EXP 135
28519: PUSH
28520: LD_EXP 135
28524: PPUSH
28525: LD_VAR 0 1
28529: PPUSH
28530: LD_INT 6
28532: PPUSH
28533: CALL_OW 1
28537: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28538: LD_ADDR_VAR 0 2
28542: PUSH
28543: LD_INT 0
28545: PUSH
28546: LD_INT 0
28548: PUSH
28549: LD_INT 0
28551: PUSH
28552: LD_INT 0
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: LIST
28559: LIST
28560: ST_TO_ADDR
// if sci >= 1 then
28561: LD_VAR 0 8
28565: PUSH
28566: LD_INT 1
28568: GREATEREQUAL
28569: IFFALSE 28591
// tmp := tmp diff sci [ 1 ] ;
28571: LD_ADDR_VAR 0 4
28575: PUSH
28576: LD_VAR 0 4
28580: PUSH
28581: LD_VAR 0 8
28585: PUSH
28586: LD_INT 1
28588: ARRAY
28589: DIFF
28590: ST_TO_ADDR
// if tmp and not sci then
28591: LD_VAR 0 4
28595: PUSH
28596: LD_VAR 0 8
28600: NOT
28601: AND
28602: IFFALSE 28671
// begin sort := SortBySkill ( tmp , 4 ) ;
28604: LD_ADDR_VAR 0 9
28608: PUSH
28609: LD_VAR 0 4
28613: PPUSH
28614: LD_INT 4
28616: PPUSH
28617: CALL 86731 0 2
28621: ST_TO_ADDR
// if sort then
28622: LD_VAR 0 9
28626: IFFALSE 28642
// p := sort [ 1 ] ;
28628: LD_ADDR_VAR 0 11
28632: PUSH
28633: LD_VAR 0 9
28637: PUSH
28638: LD_INT 1
28640: ARRAY
28641: ST_TO_ADDR
// if p then
28642: LD_VAR 0 11
28646: IFFALSE 28671
// result := Replace ( result , 4 , p ) ;
28648: LD_ADDR_VAR 0 2
28652: PUSH
28653: LD_VAR 0 2
28657: PPUSH
28658: LD_INT 4
28660: PPUSH
28661: LD_VAR 0 11
28665: PPUSH
28666: CALL_OW 1
28670: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28671: LD_ADDR_VAR 0 4
28675: PUSH
28676: LD_VAR 0 4
28680: PUSH
28681: LD_VAR 0 7
28685: DIFF
28686: ST_TO_ADDR
// if tmp and mech < 6 then
28687: LD_VAR 0 4
28691: PUSH
28692: LD_VAR 0 7
28696: PUSH
28697: LD_INT 6
28699: LESS
28700: AND
28701: IFFALSE 28883
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28703: LD_ADDR_VAR 0 9
28707: PUSH
28708: LD_VAR 0 4
28712: PUSH
28713: LD_VAR 0 7
28717: DIFF
28718: PPUSH
28719: LD_INT 3
28721: PPUSH
28722: CALL 86731 0 2
28726: ST_TO_ADDR
// p := [ ] ;
28727: LD_ADDR_VAR 0 11
28731: PUSH
28732: EMPTY
28733: ST_TO_ADDR
// if sort then
28734: LD_VAR 0 9
28738: IFFALSE 28854
// for i = 1 to 6 - mech do
28740: LD_ADDR_VAR 0 3
28744: PUSH
28745: DOUBLE
28746: LD_INT 1
28748: DEC
28749: ST_TO_ADDR
28750: LD_INT 6
28752: PUSH
28753: LD_VAR 0 7
28757: MINUS
28758: PUSH
28759: FOR_TO
28760: IFFALSE 28852
// begin if i = sort then
28762: LD_VAR 0 3
28766: PUSH
28767: LD_VAR 0 9
28771: EQUAL
28772: IFFALSE 28776
// break ;
28774: GO 28852
// if GetClass ( i ) = 3 then
28776: LD_VAR 0 3
28780: PPUSH
28781: CALL_OW 257
28785: PUSH
28786: LD_INT 3
28788: EQUAL
28789: IFFALSE 28793
// continue ;
28791: GO 28759
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28793: LD_ADDR_VAR 0 11
28797: PUSH
28798: LD_VAR 0 11
28802: PPUSH
28803: LD_VAR 0 11
28807: PUSH
28808: LD_INT 1
28810: PLUS
28811: PPUSH
28812: LD_VAR 0 9
28816: PUSH
28817: LD_VAR 0 3
28821: ARRAY
28822: PPUSH
28823: CALL_OW 2
28827: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28828: LD_ADDR_VAR 0 4
28832: PUSH
28833: LD_VAR 0 4
28837: PUSH
28838: LD_VAR 0 9
28842: PUSH
28843: LD_VAR 0 3
28847: ARRAY
28848: DIFF
28849: ST_TO_ADDR
// end ;
28850: GO 28759
28852: POP
28853: POP
// if p then
28854: LD_VAR 0 11
28858: IFFALSE 28883
// result := Replace ( result , 3 , p ) ;
28860: LD_ADDR_VAR 0 2
28864: PUSH
28865: LD_VAR 0 2
28869: PPUSH
28870: LD_INT 3
28872: PPUSH
28873: LD_VAR 0 11
28877: PPUSH
28878: CALL_OW 1
28882: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28883: LD_ADDR_VAR 0 4
28887: PUSH
28888: LD_VAR 0 4
28892: PUSH
28893: LD_VAR 0 6
28897: DIFF
28898: ST_TO_ADDR
// if tmp and eng < 4 then
28899: LD_VAR 0 4
28903: PUSH
28904: LD_VAR 0 6
28908: PUSH
28909: LD_INT 4
28911: LESS
28912: AND
28913: IFFALSE 29103
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28915: LD_ADDR_VAR 0 9
28919: PUSH
28920: LD_VAR 0 4
28924: PUSH
28925: LD_VAR 0 7
28929: PUSH
28930: LD_VAR 0 6
28934: UNION
28935: DIFF
28936: PPUSH
28937: LD_INT 2
28939: PPUSH
28940: CALL 86731 0 2
28944: ST_TO_ADDR
// p := [ ] ;
28945: LD_ADDR_VAR 0 11
28949: PUSH
28950: EMPTY
28951: ST_TO_ADDR
// if sort then
28952: LD_VAR 0 9
28956: IFFALSE 29072
// for i = 1 to 4 - eng do
28958: LD_ADDR_VAR 0 3
28962: PUSH
28963: DOUBLE
28964: LD_INT 1
28966: DEC
28967: ST_TO_ADDR
28968: LD_INT 4
28970: PUSH
28971: LD_VAR 0 6
28975: MINUS
28976: PUSH
28977: FOR_TO
28978: IFFALSE 29070
// begin if i = sort then
28980: LD_VAR 0 3
28984: PUSH
28985: LD_VAR 0 9
28989: EQUAL
28990: IFFALSE 28994
// break ;
28992: GO 29070
// if GetClass ( i ) = 2 then
28994: LD_VAR 0 3
28998: PPUSH
28999: CALL_OW 257
29003: PUSH
29004: LD_INT 2
29006: EQUAL
29007: IFFALSE 29011
// continue ;
29009: GO 28977
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29011: LD_ADDR_VAR 0 11
29015: PUSH
29016: LD_VAR 0 11
29020: PPUSH
29021: LD_VAR 0 11
29025: PUSH
29026: LD_INT 1
29028: PLUS
29029: PPUSH
29030: LD_VAR 0 9
29034: PUSH
29035: LD_VAR 0 3
29039: ARRAY
29040: PPUSH
29041: CALL_OW 2
29045: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29046: LD_ADDR_VAR 0 4
29050: PUSH
29051: LD_VAR 0 4
29055: PUSH
29056: LD_VAR 0 9
29060: PUSH
29061: LD_VAR 0 3
29065: ARRAY
29066: DIFF
29067: ST_TO_ADDR
// end ;
29068: GO 28977
29070: POP
29071: POP
// if p then
29072: LD_VAR 0 11
29076: IFFALSE 29101
// result := Replace ( result , 2 , p ) ;
29078: LD_ADDR_VAR 0 2
29082: PUSH
29083: LD_VAR 0 2
29087: PPUSH
29088: LD_INT 2
29090: PPUSH
29091: LD_VAR 0 11
29095: PPUSH
29096: CALL_OW 1
29100: ST_TO_ADDR
// end else
29101: GO 29147
// for i = eng downto 5 do
29103: LD_ADDR_VAR 0 3
29107: PUSH
29108: DOUBLE
29109: LD_VAR 0 6
29113: INC
29114: ST_TO_ADDR
29115: LD_INT 5
29117: PUSH
29118: FOR_DOWNTO
29119: IFFALSE 29145
// tmp := tmp union eng [ i ] ;
29121: LD_ADDR_VAR 0 4
29125: PUSH
29126: LD_VAR 0 4
29130: PUSH
29131: LD_VAR 0 6
29135: PUSH
29136: LD_VAR 0 3
29140: ARRAY
29141: UNION
29142: ST_TO_ADDR
29143: GO 29118
29145: POP
29146: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29147: LD_ADDR_VAR 0 2
29151: PUSH
29152: LD_VAR 0 2
29156: PPUSH
29157: LD_INT 1
29159: PPUSH
29160: LD_VAR 0 4
29164: PUSH
29165: LD_VAR 0 5
29169: DIFF
29170: PPUSH
29171: CALL_OW 1
29175: ST_TO_ADDR
// exit ;
29176: GO 29178
// end ; end ;
29178: LD_VAR 0 2
29182: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29183: LD_INT 0
29185: PPUSH
29186: PPUSH
29187: PPUSH
// if not mc_bases then
29188: LD_EXP 93
29192: NOT
29193: IFFALSE 29197
// exit ;
29195: GO 29339
// for i = 1 to mc_bases do
29197: LD_ADDR_VAR 0 2
29201: PUSH
29202: DOUBLE
29203: LD_INT 1
29205: DEC
29206: ST_TO_ADDR
29207: LD_EXP 93
29211: PUSH
29212: FOR_TO
29213: IFFALSE 29330
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29215: LD_ADDR_VAR 0 3
29219: PUSH
29220: LD_EXP 93
29224: PUSH
29225: LD_VAR 0 2
29229: ARRAY
29230: PPUSH
29231: LD_INT 21
29233: PUSH
29234: LD_INT 3
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 3
29243: PUSH
29244: LD_INT 2
29246: PUSH
29247: LD_INT 30
29249: PUSH
29250: LD_INT 29
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 30
29259: PUSH
29260: LD_INT 30
29262: PUSH
29263: EMPTY
29264: LIST
29265: LIST
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: LIST
29271: PUSH
29272: EMPTY
29273: LIST
29274: LIST
29275: PUSH
29276: LD_INT 3
29278: PUSH
29279: LD_INT 24
29281: PUSH
29282: LD_INT 1000
29284: PUSH
29285: EMPTY
29286: LIST
29287: LIST
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: EMPTY
29294: LIST
29295: LIST
29296: LIST
29297: PPUSH
29298: CALL_OW 72
29302: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29303: LD_ADDR_EXP 94
29307: PUSH
29308: LD_EXP 94
29312: PPUSH
29313: LD_VAR 0 2
29317: PPUSH
29318: LD_VAR 0 3
29322: PPUSH
29323: CALL_OW 1
29327: ST_TO_ADDR
// end ;
29328: GO 29212
29330: POP
29331: POP
// RaiseSailEvent ( 101 ) ;
29332: LD_INT 101
29334: PPUSH
29335: CALL_OW 427
// end ;
29339: LD_VAR 0 1
29343: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29344: LD_INT 0
29346: PPUSH
29347: PPUSH
29348: PPUSH
29349: PPUSH
29350: PPUSH
29351: PPUSH
29352: PPUSH
// if not mc_bases then
29353: LD_EXP 93
29357: NOT
29358: IFFALSE 29362
// exit ;
29360: GO 29924
// for i = 1 to mc_bases do
29362: LD_ADDR_VAR 0 2
29366: PUSH
29367: DOUBLE
29368: LD_INT 1
29370: DEC
29371: ST_TO_ADDR
29372: LD_EXP 93
29376: PUSH
29377: FOR_TO
29378: IFFALSE 29915
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29380: LD_ADDR_VAR 0 5
29384: PUSH
29385: LD_EXP 93
29389: PUSH
29390: LD_VAR 0 2
29394: ARRAY
29395: PUSH
29396: LD_EXP 122
29400: PUSH
29401: LD_VAR 0 2
29405: ARRAY
29406: UNION
29407: PPUSH
29408: LD_INT 21
29410: PUSH
29411: LD_INT 1
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 1
29420: PUSH
29421: LD_INT 3
29423: PUSH
29424: LD_INT 54
29426: PUSH
29427: EMPTY
29428: LIST
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: LD_INT 3
29436: PUSH
29437: LD_INT 24
29439: PUSH
29440: LD_INT 1000
29442: PUSH
29443: EMPTY
29444: LIST
29445: LIST
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: LIST
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: PPUSH
29460: CALL_OW 72
29464: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29465: LD_ADDR_VAR 0 6
29469: PUSH
29470: LD_EXP 93
29474: PUSH
29475: LD_VAR 0 2
29479: ARRAY
29480: PPUSH
29481: LD_INT 21
29483: PUSH
29484: LD_INT 1
29486: PUSH
29487: EMPTY
29488: LIST
29489: LIST
29490: PUSH
29491: LD_INT 1
29493: PUSH
29494: LD_INT 3
29496: PUSH
29497: LD_INT 54
29499: PUSH
29500: EMPTY
29501: LIST
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: LD_INT 3
29509: PUSH
29510: LD_INT 24
29512: PUSH
29513: LD_INT 250
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: LIST
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PPUSH
29533: CALL_OW 72
29537: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29538: LD_ADDR_VAR 0 7
29542: PUSH
29543: LD_VAR 0 5
29547: PUSH
29548: LD_VAR 0 6
29552: DIFF
29553: ST_TO_ADDR
// if not need_heal_1 then
29554: LD_VAR 0 6
29558: NOT
29559: IFFALSE 29592
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29561: LD_ADDR_EXP 96
29565: PUSH
29566: LD_EXP 96
29570: PPUSH
29571: LD_VAR 0 2
29575: PUSH
29576: LD_INT 1
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PPUSH
29583: EMPTY
29584: PPUSH
29585: CALL 56474 0 3
29589: ST_TO_ADDR
29590: GO 29662
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29592: LD_ADDR_EXP 96
29596: PUSH
29597: LD_EXP 96
29601: PPUSH
29602: LD_VAR 0 2
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PPUSH
29614: LD_EXP 96
29618: PUSH
29619: LD_VAR 0 2
29623: ARRAY
29624: PUSH
29625: LD_INT 1
29627: ARRAY
29628: PPUSH
29629: LD_INT 3
29631: PUSH
29632: LD_INT 24
29634: PUSH
29635: LD_INT 1000
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: PPUSH
29646: CALL_OW 72
29650: PUSH
29651: LD_VAR 0 6
29655: UNION
29656: PPUSH
29657: CALL 56474 0 3
29661: ST_TO_ADDR
// if not need_heal_2 then
29662: LD_VAR 0 7
29666: NOT
29667: IFFALSE 29700
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29669: LD_ADDR_EXP 96
29673: PUSH
29674: LD_EXP 96
29678: PPUSH
29679: LD_VAR 0 2
29683: PUSH
29684: LD_INT 2
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: PPUSH
29691: EMPTY
29692: PPUSH
29693: CALL 56474 0 3
29697: ST_TO_ADDR
29698: GO 29732
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29700: LD_ADDR_EXP 96
29704: PUSH
29705: LD_EXP 96
29709: PPUSH
29710: LD_VAR 0 2
29714: PUSH
29715: LD_INT 2
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PPUSH
29722: LD_VAR 0 7
29726: PPUSH
29727: CALL 56474 0 3
29731: ST_TO_ADDR
// if need_heal_2 then
29732: LD_VAR 0 7
29736: IFFALSE 29897
// for j in need_heal_2 do
29738: LD_ADDR_VAR 0 3
29742: PUSH
29743: LD_VAR 0 7
29747: PUSH
29748: FOR_IN
29749: IFFALSE 29895
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29751: LD_ADDR_VAR 0 5
29755: PUSH
29756: LD_EXP 93
29760: PUSH
29761: LD_VAR 0 2
29765: ARRAY
29766: PPUSH
29767: LD_INT 2
29769: PUSH
29770: LD_INT 30
29772: PUSH
29773: LD_INT 6
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PUSH
29780: LD_INT 30
29782: PUSH
29783: LD_INT 7
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 30
29792: PUSH
29793: LD_INT 8
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 30
29802: PUSH
29803: LD_INT 0
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 30
29812: PUSH
29813: LD_INT 1
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PUSH
29820: EMPTY
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: PPUSH
29828: CALL_OW 72
29832: ST_TO_ADDR
// if tmp then
29833: LD_VAR 0 5
29837: IFFALSE 29893
// begin k := NearestUnitToUnit ( tmp , j ) ;
29839: LD_ADDR_VAR 0 4
29843: PUSH
29844: LD_VAR 0 5
29848: PPUSH
29849: LD_VAR 0 3
29853: PPUSH
29854: CALL_OW 74
29858: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29859: LD_VAR 0 3
29863: PPUSH
29864: LD_VAR 0 4
29868: PPUSH
29869: CALL_OW 296
29873: PUSH
29874: LD_INT 5
29876: GREATER
29877: IFFALSE 29893
// ComMoveToNearbyEntrance ( j , k ) ;
29879: LD_VAR 0 3
29883: PPUSH
29884: LD_VAR 0 4
29888: PPUSH
29889: CALL 89092 0 2
// end ; end ;
29893: GO 29748
29895: POP
29896: POP
// if not need_heal_1 and not need_heal_2 then
29897: LD_VAR 0 6
29901: NOT
29902: PUSH
29903: LD_VAR 0 7
29907: NOT
29908: AND
29909: IFFALSE 29913
// continue ;
29911: GO 29377
// end ;
29913: GO 29377
29915: POP
29916: POP
// RaiseSailEvent ( 102 ) ;
29917: LD_INT 102
29919: PPUSH
29920: CALL_OW 427
// end ;
29924: LD_VAR 0 1
29928: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29929: LD_INT 0
29931: PPUSH
29932: PPUSH
29933: PPUSH
29934: PPUSH
29935: PPUSH
29936: PPUSH
29937: PPUSH
29938: PPUSH
// if not mc_bases then
29939: LD_EXP 93
29943: NOT
29944: IFFALSE 29948
// exit ;
29946: GO 30831
// for i = 1 to mc_bases do
29948: LD_ADDR_VAR 0 2
29952: PUSH
29953: DOUBLE
29954: LD_INT 1
29956: DEC
29957: ST_TO_ADDR
29958: LD_EXP 93
29962: PUSH
29963: FOR_TO
29964: IFFALSE 30829
// begin if not mc_building_need_repair [ i ] then
29966: LD_EXP 94
29970: PUSH
29971: LD_VAR 0 2
29975: ARRAY
29976: NOT
29977: IFFALSE 30164
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
29979: LD_ADDR_VAR 0 6
29983: PUSH
29984: LD_EXP 112
29988: PUSH
29989: LD_VAR 0 2
29993: ARRAY
29994: PPUSH
29995: LD_INT 3
29997: PUSH
29998: LD_INT 24
30000: PUSH
30001: LD_INT 1000
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 2
30014: PUSH
30015: LD_INT 34
30017: PUSH
30018: LD_INT 13
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: LD_INT 34
30027: PUSH
30028: LD_INT 52
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 34
30037: PUSH
30038: LD_EXP 78
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PPUSH
30057: CALL_OW 72
30061: ST_TO_ADDR
// if cranes then
30062: LD_VAR 0 6
30066: IFFALSE 30128
// for j in cranes do
30068: LD_ADDR_VAR 0 3
30072: PUSH
30073: LD_VAR 0 6
30077: PUSH
30078: FOR_IN
30079: IFFALSE 30126
// if not IsInArea ( j , mc_parking [ i ] ) then
30081: LD_VAR 0 3
30085: PPUSH
30086: LD_EXP 117
30090: PUSH
30091: LD_VAR 0 2
30095: ARRAY
30096: PPUSH
30097: CALL_OW 308
30101: NOT
30102: IFFALSE 30124
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30104: LD_VAR 0 3
30108: PPUSH
30109: LD_EXP 117
30113: PUSH
30114: LD_VAR 0 2
30118: ARRAY
30119: PPUSH
30120: CALL_OW 113
30124: GO 30078
30126: POP
30127: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30128: LD_ADDR_EXP 95
30132: PUSH
30133: LD_EXP 95
30137: PPUSH
30138: LD_VAR 0 2
30142: PPUSH
30143: EMPTY
30144: PPUSH
30145: CALL_OW 1
30149: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30150: LD_VAR 0 2
30154: PPUSH
30155: LD_INT 101
30157: PPUSH
30158: CALL 25016 0 2
// continue ;
30162: GO 29963
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30164: LD_ADDR_EXP 99
30168: PUSH
30169: LD_EXP 99
30173: PPUSH
30174: LD_VAR 0 2
30178: PPUSH
30179: EMPTY
30180: PPUSH
30181: CALL_OW 1
30185: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30186: LD_VAR 0 2
30190: PPUSH
30191: LD_INT 103
30193: PPUSH
30194: CALL 25016 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30198: LD_ADDR_VAR 0 5
30202: PUSH
30203: LD_EXP 93
30207: PUSH
30208: LD_VAR 0 2
30212: ARRAY
30213: PUSH
30214: LD_EXP 122
30218: PUSH
30219: LD_VAR 0 2
30223: ARRAY
30224: UNION
30225: PPUSH
30226: LD_INT 2
30228: PUSH
30229: LD_INT 25
30231: PUSH
30232: LD_INT 2
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 25
30241: PUSH
30242: LD_INT 16
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: PPUSH
30257: CALL_OW 72
30261: ST_TO_ADDR
// if mc_need_heal [ i ] then
30262: LD_EXP 96
30266: PUSH
30267: LD_VAR 0 2
30271: ARRAY
30272: IFFALSE 30316
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30274: LD_ADDR_VAR 0 5
30278: PUSH
30279: LD_VAR 0 5
30283: PUSH
30284: LD_EXP 96
30288: PUSH
30289: LD_VAR 0 2
30293: ARRAY
30294: PUSH
30295: LD_INT 1
30297: ARRAY
30298: PUSH
30299: LD_EXP 96
30303: PUSH
30304: LD_VAR 0 2
30308: ARRAY
30309: PUSH
30310: LD_INT 2
30312: ARRAY
30313: UNION
30314: DIFF
30315: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30316: LD_ADDR_VAR 0 6
30320: PUSH
30321: LD_EXP 112
30325: PUSH
30326: LD_VAR 0 2
30330: ARRAY
30331: PPUSH
30332: LD_INT 2
30334: PUSH
30335: LD_INT 34
30337: PUSH
30338: LD_INT 13
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: LD_INT 34
30347: PUSH
30348: LD_INT 52
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 34
30357: PUSH
30358: LD_EXP 78
30362: PUSH
30363: EMPTY
30364: LIST
30365: LIST
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: PPUSH
30373: CALL_OW 72
30377: ST_TO_ADDR
// if cranes then
30378: LD_VAR 0 6
30382: IFFALSE 30518
// begin for j in cranes do
30384: LD_ADDR_VAR 0 3
30388: PUSH
30389: LD_VAR 0 6
30393: PUSH
30394: FOR_IN
30395: IFFALSE 30516
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30397: LD_VAR 0 3
30401: PPUSH
30402: CALL_OW 256
30406: PUSH
30407: LD_INT 1000
30409: EQUAL
30410: PUSH
30411: LD_VAR 0 3
30415: PPUSH
30416: CALL_OW 314
30420: NOT
30421: AND
30422: IFFALSE 30456
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30424: LD_VAR 0 3
30428: PPUSH
30429: LD_EXP 94
30433: PUSH
30434: LD_VAR 0 2
30438: ARRAY
30439: PPUSH
30440: LD_VAR 0 3
30444: PPUSH
30445: CALL_OW 74
30449: PPUSH
30450: CALL_OW 130
30454: GO 30514
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30456: LD_VAR 0 3
30460: PPUSH
30461: CALL_OW 256
30465: PUSH
30466: LD_INT 500
30468: LESS
30469: PUSH
30470: LD_VAR 0 3
30474: PPUSH
30475: LD_EXP 117
30479: PUSH
30480: LD_VAR 0 2
30484: ARRAY
30485: PPUSH
30486: CALL_OW 308
30490: NOT
30491: AND
30492: IFFALSE 30514
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30494: LD_VAR 0 3
30498: PPUSH
30499: LD_EXP 117
30503: PUSH
30504: LD_VAR 0 2
30508: ARRAY
30509: PPUSH
30510: CALL_OW 113
// end ;
30514: GO 30394
30516: POP
30517: POP
// end ; if tmp > 3 then
30518: LD_VAR 0 5
30522: PUSH
30523: LD_INT 3
30525: GREATER
30526: IFFALSE 30546
// tmp := ShrinkArray ( tmp , 4 ) ;
30528: LD_ADDR_VAR 0 5
30532: PUSH
30533: LD_VAR 0 5
30537: PPUSH
30538: LD_INT 4
30540: PPUSH
30541: CALL 88540 0 2
30545: ST_TO_ADDR
// if not tmp then
30546: LD_VAR 0 5
30550: NOT
30551: IFFALSE 30555
// continue ;
30553: GO 29963
// for j in tmp do
30555: LD_ADDR_VAR 0 3
30559: PUSH
30560: LD_VAR 0 5
30564: PUSH
30565: FOR_IN
30566: IFFALSE 30825
// begin if IsInUnit ( j ) then
30568: LD_VAR 0 3
30572: PPUSH
30573: CALL_OW 310
30577: IFFALSE 30588
// ComExitBuilding ( j ) ;
30579: LD_VAR 0 3
30583: PPUSH
30584: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30588: LD_VAR 0 3
30592: PUSH
30593: LD_EXP 95
30597: PUSH
30598: LD_VAR 0 2
30602: ARRAY
30603: IN
30604: NOT
30605: IFFALSE 30663
// begin SetTag ( j , 101 ) ;
30607: LD_VAR 0 3
30611: PPUSH
30612: LD_INT 101
30614: PPUSH
30615: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30619: LD_ADDR_EXP 95
30623: PUSH
30624: LD_EXP 95
30628: PPUSH
30629: LD_VAR 0 2
30633: PUSH
30634: LD_EXP 95
30638: PUSH
30639: LD_VAR 0 2
30643: ARRAY
30644: PUSH
30645: LD_INT 1
30647: PLUS
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PPUSH
30653: LD_VAR 0 3
30657: PPUSH
30658: CALL 56474 0 3
30662: ST_TO_ADDR
// end ; wait ( 1 ) ;
30663: LD_INT 1
30665: PPUSH
30666: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30670: LD_ADDR_VAR 0 7
30674: PUSH
30675: LD_EXP 94
30679: PUSH
30680: LD_VAR 0 2
30684: ARRAY
30685: ST_TO_ADDR
// if mc_scan [ i ] then
30686: LD_EXP 116
30690: PUSH
30691: LD_VAR 0 2
30695: ARRAY
30696: IFFALSE 30758
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30698: LD_ADDR_VAR 0 7
30702: PUSH
30703: LD_EXP 94
30707: PUSH
30708: LD_VAR 0 2
30712: ARRAY
30713: PPUSH
30714: LD_INT 3
30716: PUSH
30717: LD_INT 30
30719: PUSH
30720: LD_INT 32
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: LD_INT 30
30729: PUSH
30730: LD_INT 33
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: PUSH
30737: LD_INT 30
30739: PUSH
30740: LD_INT 31
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: LIST
30751: LIST
30752: PPUSH
30753: CALL_OW 72
30757: ST_TO_ADDR
// if not to_repair_tmp then
30758: LD_VAR 0 7
30762: NOT
30763: IFFALSE 30767
// continue ;
30765: GO 30565
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30767: LD_ADDR_VAR 0 8
30771: PUSH
30772: LD_VAR 0 7
30776: PPUSH
30777: LD_VAR 0 3
30781: PPUSH
30782: CALL_OW 74
30786: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30787: LD_VAR 0 8
30791: PPUSH
30792: LD_INT 16
30794: PPUSH
30795: CALL 59073 0 2
30799: PUSH
30800: LD_INT 4
30802: ARRAY
30803: PUSH
30804: LD_INT 10
30806: LESS
30807: IFFALSE 30823
// ComRepairBuilding ( j , to_repair ) ;
30809: LD_VAR 0 3
30813: PPUSH
30814: LD_VAR 0 8
30818: PPUSH
30819: CALL_OW 130
// end ;
30823: GO 30565
30825: POP
30826: POP
// end ;
30827: GO 29963
30829: POP
30830: POP
// end ;
30831: LD_VAR 0 1
30835: RET
// export function MC_Heal ; var i , j , tmp ; begin
30836: LD_INT 0
30838: PPUSH
30839: PPUSH
30840: PPUSH
30841: PPUSH
// if not mc_bases then
30842: LD_EXP 93
30846: NOT
30847: IFFALSE 30851
// exit ;
30849: GO 31253
// for i = 1 to mc_bases do
30851: LD_ADDR_VAR 0 2
30855: PUSH
30856: DOUBLE
30857: LD_INT 1
30859: DEC
30860: ST_TO_ADDR
30861: LD_EXP 93
30865: PUSH
30866: FOR_TO
30867: IFFALSE 31251
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30869: LD_EXP 96
30873: PUSH
30874: LD_VAR 0 2
30878: ARRAY
30879: PUSH
30880: LD_INT 1
30882: ARRAY
30883: NOT
30884: PUSH
30885: LD_EXP 96
30889: PUSH
30890: LD_VAR 0 2
30894: ARRAY
30895: PUSH
30896: LD_INT 2
30898: ARRAY
30899: NOT
30900: AND
30901: IFFALSE 30939
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30903: LD_ADDR_EXP 97
30907: PUSH
30908: LD_EXP 97
30912: PPUSH
30913: LD_VAR 0 2
30917: PPUSH
30918: EMPTY
30919: PPUSH
30920: CALL_OW 1
30924: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30925: LD_VAR 0 2
30929: PPUSH
30930: LD_INT 102
30932: PPUSH
30933: CALL 25016 0 2
// continue ;
30937: GO 30866
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30939: LD_ADDR_VAR 0 4
30943: PUSH
30944: LD_EXP 93
30948: PUSH
30949: LD_VAR 0 2
30953: ARRAY
30954: PPUSH
30955: LD_INT 25
30957: PUSH
30958: LD_INT 4
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PPUSH
30965: CALL_OW 72
30969: ST_TO_ADDR
// if not tmp then
30970: LD_VAR 0 4
30974: NOT
30975: IFFALSE 30979
// continue ;
30977: GO 30866
// if mc_taming [ i ] then
30979: LD_EXP 124
30983: PUSH
30984: LD_VAR 0 2
30988: ARRAY
30989: IFFALSE 31013
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30991: LD_ADDR_EXP 124
30995: PUSH
30996: LD_EXP 124
31000: PPUSH
31001: LD_VAR 0 2
31005: PPUSH
31006: EMPTY
31007: PPUSH
31008: CALL_OW 1
31012: ST_TO_ADDR
// for j in tmp do
31013: LD_ADDR_VAR 0 3
31017: PUSH
31018: LD_VAR 0 4
31022: PUSH
31023: FOR_IN
31024: IFFALSE 31247
// begin if IsInUnit ( j ) then
31026: LD_VAR 0 3
31030: PPUSH
31031: CALL_OW 310
31035: IFFALSE 31046
// ComExitBuilding ( j ) ;
31037: LD_VAR 0 3
31041: PPUSH
31042: CALL_OW 122
// if not j in mc_healers [ i ] then
31046: LD_VAR 0 3
31050: PUSH
31051: LD_EXP 97
31055: PUSH
31056: LD_VAR 0 2
31060: ARRAY
31061: IN
31062: NOT
31063: IFFALSE 31109
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31065: LD_ADDR_EXP 97
31069: PUSH
31070: LD_EXP 97
31074: PPUSH
31075: LD_VAR 0 2
31079: PUSH
31080: LD_EXP 97
31084: PUSH
31085: LD_VAR 0 2
31089: ARRAY
31090: PUSH
31091: LD_INT 1
31093: PLUS
31094: PUSH
31095: EMPTY
31096: LIST
31097: LIST
31098: PPUSH
31099: LD_VAR 0 3
31103: PPUSH
31104: CALL 56474 0 3
31108: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31109: LD_VAR 0 3
31113: PPUSH
31114: CALL_OW 110
31118: PUSH
31119: LD_INT 102
31121: NONEQUAL
31122: IFFALSE 31136
// SetTag ( j , 102 ) ;
31124: LD_VAR 0 3
31128: PPUSH
31129: LD_INT 102
31131: PPUSH
31132: CALL_OW 109
// Wait ( 3 ) ;
31136: LD_INT 3
31138: PPUSH
31139: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31143: LD_EXP 96
31147: PUSH
31148: LD_VAR 0 2
31152: ARRAY
31153: PUSH
31154: LD_INT 1
31156: ARRAY
31157: IFFALSE 31189
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31159: LD_VAR 0 3
31163: PPUSH
31164: LD_EXP 96
31168: PUSH
31169: LD_VAR 0 2
31173: ARRAY
31174: PUSH
31175: LD_INT 1
31177: ARRAY
31178: PUSH
31179: LD_INT 1
31181: ARRAY
31182: PPUSH
31183: CALL_OW 128
31187: GO 31245
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31189: LD_VAR 0 3
31193: PPUSH
31194: CALL_OW 314
31198: NOT
31199: PUSH
31200: LD_EXP 96
31204: PUSH
31205: LD_VAR 0 2
31209: ARRAY
31210: PUSH
31211: LD_INT 2
31213: ARRAY
31214: AND
31215: IFFALSE 31245
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31217: LD_VAR 0 3
31221: PPUSH
31222: LD_EXP 96
31226: PUSH
31227: LD_VAR 0 2
31231: ARRAY
31232: PUSH
31233: LD_INT 2
31235: ARRAY
31236: PUSH
31237: LD_INT 1
31239: ARRAY
31240: PPUSH
31241: CALL_OW 128
// end ;
31245: GO 31023
31247: POP
31248: POP
// end ;
31249: GO 30866
31251: POP
31252: POP
// end ;
31253: LD_VAR 0 1
31257: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31258: LD_INT 0
31260: PPUSH
31261: PPUSH
31262: PPUSH
31263: PPUSH
31264: PPUSH
// if not mc_bases then
31265: LD_EXP 93
31269: NOT
31270: IFFALSE 31274
// exit ;
31272: GO 32445
// for i = 1 to mc_bases do
31274: LD_ADDR_VAR 0 2
31278: PUSH
31279: DOUBLE
31280: LD_INT 1
31282: DEC
31283: ST_TO_ADDR
31284: LD_EXP 93
31288: PUSH
31289: FOR_TO
31290: IFFALSE 32443
// begin if mc_scan [ i ] then
31292: LD_EXP 116
31296: PUSH
31297: LD_VAR 0 2
31301: ARRAY
31302: IFFALSE 31306
// continue ;
31304: GO 31289
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31306: LD_EXP 98
31310: PUSH
31311: LD_VAR 0 2
31315: ARRAY
31316: NOT
31317: PUSH
31318: LD_EXP 100
31322: PUSH
31323: LD_VAR 0 2
31327: ARRAY
31328: NOT
31329: AND
31330: PUSH
31331: LD_EXP 99
31335: PUSH
31336: LD_VAR 0 2
31340: ARRAY
31341: AND
31342: IFFALSE 31380
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31344: LD_ADDR_EXP 99
31348: PUSH
31349: LD_EXP 99
31353: PPUSH
31354: LD_VAR 0 2
31358: PPUSH
31359: EMPTY
31360: PPUSH
31361: CALL_OW 1
31365: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31366: LD_VAR 0 2
31370: PPUSH
31371: LD_INT 103
31373: PPUSH
31374: CALL 25016 0 2
// continue ;
31378: GO 31289
// end ; if mc_construct_list [ i ] then
31380: LD_EXP 100
31384: PUSH
31385: LD_VAR 0 2
31389: ARRAY
31390: IFFALSE 31610
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31392: LD_ADDR_VAR 0 4
31396: PUSH
31397: LD_EXP 93
31401: PUSH
31402: LD_VAR 0 2
31406: ARRAY
31407: PPUSH
31408: LD_INT 25
31410: PUSH
31411: LD_INT 2
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PPUSH
31418: CALL_OW 72
31422: PUSH
31423: LD_EXP 95
31427: PUSH
31428: LD_VAR 0 2
31432: ARRAY
31433: DIFF
31434: ST_TO_ADDR
// if not tmp then
31435: LD_VAR 0 4
31439: NOT
31440: IFFALSE 31444
// continue ;
31442: GO 31289
// for j in tmp do
31444: LD_ADDR_VAR 0 3
31448: PUSH
31449: LD_VAR 0 4
31453: PUSH
31454: FOR_IN
31455: IFFALSE 31606
// begin if not mc_builders [ i ] then
31457: LD_EXP 99
31461: PUSH
31462: LD_VAR 0 2
31466: ARRAY
31467: NOT
31468: IFFALSE 31526
// begin SetTag ( j , 103 ) ;
31470: LD_VAR 0 3
31474: PPUSH
31475: LD_INT 103
31477: PPUSH
31478: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31482: LD_ADDR_EXP 99
31486: PUSH
31487: LD_EXP 99
31491: PPUSH
31492: LD_VAR 0 2
31496: PUSH
31497: LD_EXP 99
31501: PUSH
31502: LD_VAR 0 2
31506: ARRAY
31507: PUSH
31508: LD_INT 1
31510: PLUS
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PPUSH
31516: LD_VAR 0 3
31520: PPUSH
31521: CALL 56474 0 3
31525: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31526: LD_VAR 0 3
31530: PPUSH
31531: CALL_OW 310
31535: IFFALSE 31546
// ComExitBuilding ( j ) ;
31537: LD_VAR 0 3
31541: PPUSH
31542: CALL_OW 122
// wait ( 3 ) ;
31546: LD_INT 3
31548: PPUSH
31549: CALL_OW 67
// if not mc_construct_list [ i ] then
31553: LD_EXP 100
31557: PUSH
31558: LD_VAR 0 2
31562: ARRAY
31563: NOT
31564: IFFALSE 31568
// break ;
31566: GO 31606
// if not HasTask ( j ) then
31568: LD_VAR 0 3
31572: PPUSH
31573: CALL_OW 314
31577: NOT
31578: IFFALSE 31604
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31580: LD_VAR 0 3
31584: PPUSH
31585: LD_EXP 100
31589: PUSH
31590: LD_VAR 0 2
31594: ARRAY
31595: PUSH
31596: LD_INT 1
31598: ARRAY
31599: PPUSH
31600: CALL 59337 0 2
// end ;
31604: GO 31454
31606: POP
31607: POP
// end else
31608: GO 32441
// if mc_build_list [ i ] then
31610: LD_EXP 98
31614: PUSH
31615: LD_VAR 0 2
31619: ARRAY
31620: IFFALSE 32441
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31622: LD_ADDR_VAR 0 5
31626: PUSH
31627: LD_EXP 93
31631: PUSH
31632: LD_VAR 0 2
31636: ARRAY
31637: PPUSH
31638: LD_INT 2
31640: PUSH
31641: LD_INT 30
31643: PUSH
31644: LD_INT 0
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: PUSH
31651: LD_INT 30
31653: PUSH
31654: LD_INT 1
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: LIST
31665: PPUSH
31666: CALL_OW 72
31670: ST_TO_ADDR
// if depot then
31671: LD_VAR 0 5
31675: IFFALSE 31693
// depot := depot [ 1 ] else
31677: LD_ADDR_VAR 0 5
31681: PUSH
31682: LD_VAR 0 5
31686: PUSH
31687: LD_INT 1
31689: ARRAY
31690: ST_TO_ADDR
31691: GO 31701
// depot := 0 ;
31693: LD_ADDR_VAR 0 5
31697: PUSH
31698: LD_INT 0
31700: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31701: LD_EXP 98
31705: PUSH
31706: LD_VAR 0 2
31710: ARRAY
31711: PUSH
31712: LD_INT 1
31714: ARRAY
31715: PUSH
31716: LD_INT 1
31718: ARRAY
31719: PPUSH
31720: CALL 59161 0 1
31724: PUSH
31725: LD_EXP 93
31729: PUSH
31730: LD_VAR 0 2
31734: ARRAY
31735: PPUSH
31736: LD_INT 2
31738: PUSH
31739: LD_INT 30
31741: PUSH
31742: LD_INT 2
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 30
31751: PUSH
31752: LD_INT 3
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: LIST
31763: PPUSH
31764: CALL_OW 72
31768: NOT
31769: AND
31770: IFFALSE 31875
// begin for j = 1 to mc_build_list [ i ] do
31772: LD_ADDR_VAR 0 3
31776: PUSH
31777: DOUBLE
31778: LD_INT 1
31780: DEC
31781: ST_TO_ADDR
31782: LD_EXP 98
31786: PUSH
31787: LD_VAR 0 2
31791: ARRAY
31792: PUSH
31793: FOR_TO
31794: IFFALSE 31873
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31796: LD_EXP 98
31800: PUSH
31801: LD_VAR 0 2
31805: ARRAY
31806: PUSH
31807: LD_VAR 0 3
31811: ARRAY
31812: PUSH
31813: LD_INT 1
31815: ARRAY
31816: PUSH
31817: LD_INT 2
31819: EQUAL
31820: IFFALSE 31871
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31822: LD_ADDR_EXP 98
31826: PUSH
31827: LD_EXP 98
31831: PPUSH
31832: LD_VAR 0 2
31836: PPUSH
31837: LD_EXP 98
31841: PUSH
31842: LD_VAR 0 2
31846: ARRAY
31847: PPUSH
31848: LD_VAR 0 3
31852: PPUSH
31853: LD_INT 1
31855: PPUSH
31856: LD_INT 0
31858: PPUSH
31859: CALL 55892 0 4
31863: PPUSH
31864: CALL_OW 1
31868: ST_TO_ADDR
// break ;
31869: GO 31873
// end ;
31871: GO 31793
31873: POP
31874: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31875: LD_EXP 98
31879: PUSH
31880: LD_VAR 0 2
31884: ARRAY
31885: PUSH
31886: LD_INT 1
31888: ARRAY
31889: PUSH
31890: LD_INT 1
31892: ARRAY
31893: PUSH
31894: LD_INT 0
31896: EQUAL
31897: PUSH
31898: LD_VAR 0 5
31902: PUSH
31903: LD_VAR 0 5
31907: PPUSH
31908: LD_EXP 98
31912: PUSH
31913: LD_VAR 0 2
31917: ARRAY
31918: PUSH
31919: LD_INT 1
31921: ARRAY
31922: PUSH
31923: LD_INT 1
31925: ARRAY
31926: PPUSH
31927: LD_EXP 98
31931: PUSH
31932: LD_VAR 0 2
31936: ARRAY
31937: PUSH
31938: LD_INT 1
31940: ARRAY
31941: PUSH
31942: LD_INT 2
31944: ARRAY
31945: PPUSH
31946: LD_EXP 98
31950: PUSH
31951: LD_VAR 0 2
31955: ARRAY
31956: PUSH
31957: LD_INT 1
31959: ARRAY
31960: PUSH
31961: LD_INT 3
31963: ARRAY
31964: PPUSH
31965: LD_EXP 98
31969: PUSH
31970: LD_VAR 0 2
31974: ARRAY
31975: PUSH
31976: LD_INT 1
31978: ARRAY
31979: PUSH
31980: LD_INT 4
31982: ARRAY
31983: PPUSH
31984: CALL 64577 0 5
31988: AND
31989: OR
31990: IFFALSE 32271
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31992: LD_ADDR_VAR 0 4
31996: PUSH
31997: LD_EXP 93
32001: PUSH
32002: LD_VAR 0 2
32006: ARRAY
32007: PPUSH
32008: LD_INT 25
32010: PUSH
32011: LD_INT 2
32013: PUSH
32014: EMPTY
32015: LIST
32016: LIST
32017: PPUSH
32018: CALL_OW 72
32022: PUSH
32023: LD_EXP 95
32027: PUSH
32028: LD_VAR 0 2
32032: ARRAY
32033: DIFF
32034: ST_TO_ADDR
// if not tmp then
32035: LD_VAR 0 4
32039: NOT
32040: IFFALSE 32044
// continue ;
32042: GO 31289
// for j in tmp do
32044: LD_ADDR_VAR 0 3
32048: PUSH
32049: LD_VAR 0 4
32053: PUSH
32054: FOR_IN
32055: IFFALSE 32267
// begin if not mc_builders [ i ] then
32057: LD_EXP 99
32061: PUSH
32062: LD_VAR 0 2
32066: ARRAY
32067: NOT
32068: IFFALSE 32126
// begin SetTag ( j , 103 ) ;
32070: LD_VAR 0 3
32074: PPUSH
32075: LD_INT 103
32077: PPUSH
32078: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32082: LD_ADDR_EXP 99
32086: PUSH
32087: LD_EXP 99
32091: PPUSH
32092: LD_VAR 0 2
32096: PUSH
32097: LD_EXP 99
32101: PUSH
32102: LD_VAR 0 2
32106: ARRAY
32107: PUSH
32108: LD_INT 1
32110: PLUS
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PPUSH
32116: LD_VAR 0 3
32120: PPUSH
32121: CALL 56474 0 3
32125: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32126: LD_VAR 0 3
32130: PPUSH
32131: CALL_OW 310
32135: IFFALSE 32146
// ComExitBuilding ( j ) ;
32137: LD_VAR 0 3
32141: PPUSH
32142: CALL_OW 122
// wait ( 3 ) ;
32146: LD_INT 3
32148: PPUSH
32149: CALL_OW 67
// if not mc_build_list [ i ] then
32153: LD_EXP 98
32157: PUSH
32158: LD_VAR 0 2
32162: ARRAY
32163: NOT
32164: IFFALSE 32168
// break ;
32166: GO 32267
// if not HasTask ( j ) then
32168: LD_VAR 0 3
32172: PPUSH
32173: CALL_OW 314
32177: NOT
32178: IFFALSE 32265
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32180: LD_VAR 0 3
32184: PPUSH
32185: LD_EXP 98
32189: PUSH
32190: LD_VAR 0 2
32194: ARRAY
32195: PUSH
32196: LD_INT 1
32198: ARRAY
32199: PUSH
32200: LD_INT 1
32202: ARRAY
32203: PPUSH
32204: LD_EXP 98
32208: PUSH
32209: LD_VAR 0 2
32213: ARRAY
32214: PUSH
32215: LD_INT 1
32217: ARRAY
32218: PUSH
32219: LD_INT 2
32221: ARRAY
32222: PPUSH
32223: LD_EXP 98
32227: PUSH
32228: LD_VAR 0 2
32232: ARRAY
32233: PUSH
32234: LD_INT 1
32236: ARRAY
32237: PUSH
32238: LD_INT 3
32240: ARRAY
32241: PPUSH
32242: LD_EXP 98
32246: PUSH
32247: LD_VAR 0 2
32251: ARRAY
32252: PUSH
32253: LD_INT 1
32255: ARRAY
32256: PUSH
32257: LD_INT 4
32259: ARRAY
32260: PPUSH
32261: CALL_OW 145
// end ;
32265: GO 32054
32267: POP
32268: POP
// end else
32269: GO 32441
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32271: LD_EXP 93
32275: PUSH
32276: LD_VAR 0 2
32280: ARRAY
32281: PPUSH
32282: LD_EXP 98
32286: PUSH
32287: LD_VAR 0 2
32291: ARRAY
32292: PUSH
32293: LD_INT 1
32295: ARRAY
32296: PUSH
32297: LD_INT 1
32299: ARRAY
32300: PPUSH
32301: LD_EXP 98
32305: PUSH
32306: LD_VAR 0 2
32310: ARRAY
32311: PUSH
32312: LD_INT 1
32314: ARRAY
32315: PUSH
32316: LD_INT 2
32318: ARRAY
32319: PPUSH
32320: LD_EXP 98
32324: PUSH
32325: LD_VAR 0 2
32329: ARRAY
32330: PUSH
32331: LD_INT 1
32333: ARRAY
32334: PUSH
32335: LD_INT 3
32337: ARRAY
32338: PPUSH
32339: LD_EXP 98
32343: PUSH
32344: LD_VAR 0 2
32348: ARRAY
32349: PUSH
32350: LD_INT 1
32352: ARRAY
32353: PUSH
32354: LD_INT 4
32356: ARRAY
32357: PPUSH
32358: LD_EXP 93
32362: PUSH
32363: LD_VAR 0 2
32367: ARRAY
32368: PPUSH
32369: LD_INT 21
32371: PUSH
32372: LD_INT 3
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PPUSH
32379: CALL_OW 72
32383: PPUSH
32384: EMPTY
32385: PPUSH
32386: CALL 63327 0 7
32390: NOT
32391: IFFALSE 32441
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32393: LD_ADDR_EXP 98
32397: PUSH
32398: LD_EXP 98
32402: PPUSH
32403: LD_VAR 0 2
32407: PPUSH
32408: LD_EXP 98
32412: PUSH
32413: LD_VAR 0 2
32417: ARRAY
32418: PPUSH
32419: LD_INT 1
32421: PPUSH
32422: LD_INT 1
32424: NEG
32425: PPUSH
32426: LD_INT 0
32428: PPUSH
32429: CALL 55892 0 4
32433: PPUSH
32434: CALL_OW 1
32438: ST_TO_ADDR
// continue ;
32439: GO 31289
// end ; end ; end ;
32441: GO 31289
32443: POP
32444: POP
// end ;
32445: LD_VAR 0 1
32449: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32450: LD_INT 0
32452: PPUSH
32453: PPUSH
32454: PPUSH
32455: PPUSH
32456: PPUSH
32457: PPUSH
// if not mc_bases then
32458: LD_EXP 93
32462: NOT
32463: IFFALSE 32467
// exit ;
32465: GO 32894
// for i = 1 to mc_bases do
32467: LD_ADDR_VAR 0 2
32471: PUSH
32472: DOUBLE
32473: LD_INT 1
32475: DEC
32476: ST_TO_ADDR
32477: LD_EXP 93
32481: PUSH
32482: FOR_TO
32483: IFFALSE 32892
// begin tmp := mc_build_upgrade [ i ] ;
32485: LD_ADDR_VAR 0 4
32489: PUSH
32490: LD_EXP 125
32494: PUSH
32495: LD_VAR 0 2
32499: ARRAY
32500: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32501: LD_ADDR_VAR 0 6
32505: PUSH
32506: LD_EXP 126
32510: PUSH
32511: LD_VAR 0 2
32515: ARRAY
32516: PPUSH
32517: LD_INT 2
32519: PUSH
32520: LD_INT 30
32522: PUSH
32523: LD_INT 6
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 30
32532: PUSH
32533: LD_INT 7
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: LIST
32544: PPUSH
32545: CALL_OW 72
32549: ST_TO_ADDR
// if not tmp and not lab then
32550: LD_VAR 0 4
32554: NOT
32555: PUSH
32556: LD_VAR 0 6
32560: NOT
32561: AND
32562: IFFALSE 32566
// continue ;
32564: GO 32482
// if tmp then
32566: LD_VAR 0 4
32570: IFFALSE 32690
// for j in tmp do
32572: LD_ADDR_VAR 0 3
32576: PUSH
32577: LD_VAR 0 4
32581: PUSH
32582: FOR_IN
32583: IFFALSE 32688
// begin if UpgradeCost ( j ) then
32585: LD_VAR 0 3
32589: PPUSH
32590: CALL 62987 0 1
32594: IFFALSE 32686
// begin ComUpgrade ( j ) ;
32596: LD_VAR 0 3
32600: PPUSH
32601: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32605: LD_ADDR_EXP 125
32609: PUSH
32610: LD_EXP 125
32614: PPUSH
32615: LD_VAR 0 2
32619: PPUSH
32620: LD_EXP 125
32624: PUSH
32625: LD_VAR 0 2
32629: ARRAY
32630: PUSH
32631: LD_VAR 0 3
32635: DIFF
32636: PPUSH
32637: CALL_OW 1
32641: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32642: LD_ADDR_EXP 100
32646: PUSH
32647: LD_EXP 100
32651: PPUSH
32652: LD_VAR 0 2
32656: PUSH
32657: LD_EXP 100
32661: PUSH
32662: LD_VAR 0 2
32666: ARRAY
32667: PUSH
32668: LD_INT 1
32670: PLUS
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PPUSH
32676: LD_VAR 0 3
32680: PPUSH
32681: CALL 56474 0 3
32685: ST_TO_ADDR
// end ; end ;
32686: GO 32582
32688: POP
32689: POP
// if not lab or not mc_lab_upgrade [ i ] then
32690: LD_VAR 0 6
32694: NOT
32695: PUSH
32696: LD_EXP 127
32700: PUSH
32701: LD_VAR 0 2
32705: ARRAY
32706: NOT
32707: OR
32708: IFFALSE 32712
// continue ;
32710: GO 32482
// for j in lab do
32712: LD_ADDR_VAR 0 3
32716: PUSH
32717: LD_VAR 0 6
32721: PUSH
32722: FOR_IN
32723: IFFALSE 32888
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32725: LD_VAR 0 3
32729: PPUSH
32730: CALL_OW 266
32734: PUSH
32735: LD_INT 6
32737: PUSH
32738: LD_INT 7
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: IN
32745: PUSH
32746: LD_VAR 0 3
32750: PPUSH
32751: CALL_OW 461
32755: PUSH
32756: LD_INT 1
32758: NONEQUAL
32759: AND
32760: IFFALSE 32886
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32762: LD_VAR 0 3
32766: PPUSH
32767: LD_EXP 127
32771: PUSH
32772: LD_VAR 0 2
32776: ARRAY
32777: PUSH
32778: LD_INT 1
32780: ARRAY
32781: PPUSH
32782: CALL 63192 0 2
32786: IFFALSE 32886
// begin ComCancel ( j ) ;
32788: LD_VAR 0 3
32792: PPUSH
32793: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32797: LD_VAR 0 3
32801: PPUSH
32802: LD_EXP 127
32806: PUSH
32807: LD_VAR 0 2
32811: ARRAY
32812: PUSH
32813: LD_INT 1
32815: ARRAY
32816: PPUSH
32817: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32821: LD_VAR 0 3
32825: PUSH
32826: LD_EXP 100
32830: PUSH
32831: LD_VAR 0 2
32835: ARRAY
32836: IN
32837: NOT
32838: IFFALSE 32884
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32840: LD_ADDR_EXP 100
32844: PUSH
32845: LD_EXP 100
32849: PPUSH
32850: LD_VAR 0 2
32854: PUSH
32855: LD_EXP 100
32859: PUSH
32860: LD_VAR 0 2
32864: ARRAY
32865: PUSH
32866: LD_INT 1
32868: PLUS
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PPUSH
32874: LD_VAR 0 3
32878: PPUSH
32879: CALL 56474 0 3
32883: ST_TO_ADDR
// break ;
32884: GO 32888
// end ; end ; end ;
32886: GO 32722
32888: POP
32889: POP
// end ;
32890: GO 32482
32892: POP
32893: POP
// end ;
32894: LD_VAR 0 1
32898: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32899: LD_INT 0
32901: PPUSH
32902: PPUSH
32903: PPUSH
32904: PPUSH
32905: PPUSH
32906: PPUSH
32907: PPUSH
32908: PPUSH
32909: PPUSH
// if not mc_bases then
32910: LD_EXP 93
32914: NOT
32915: IFFALSE 32919
// exit ;
32917: GO 33324
// for i = 1 to mc_bases do
32919: LD_ADDR_VAR 0 2
32923: PUSH
32924: DOUBLE
32925: LD_INT 1
32927: DEC
32928: ST_TO_ADDR
32929: LD_EXP 93
32933: PUSH
32934: FOR_TO
32935: IFFALSE 33322
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32937: LD_EXP 101
32941: PUSH
32942: LD_VAR 0 2
32946: ARRAY
32947: NOT
32948: PUSH
32949: LD_EXP 93
32953: PUSH
32954: LD_VAR 0 2
32958: ARRAY
32959: PPUSH
32960: LD_INT 30
32962: PUSH
32963: LD_INT 3
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PPUSH
32970: CALL_OW 72
32974: NOT
32975: OR
32976: IFFALSE 32980
// continue ;
32978: GO 32934
// busy := false ;
32980: LD_ADDR_VAR 0 8
32984: PUSH
32985: LD_INT 0
32987: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32988: LD_ADDR_VAR 0 4
32992: PUSH
32993: LD_EXP 93
32997: PUSH
32998: LD_VAR 0 2
33002: ARRAY
33003: PPUSH
33004: LD_INT 30
33006: PUSH
33007: LD_INT 3
33009: PUSH
33010: EMPTY
33011: LIST
33012: LIST
33013: PPUSH
33014: CALL_OW 72
33018: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33019: LD_ADDR_VAR 0 6
33023: PUSH
33024: LD_EXP 101
33028: PUSH
33029: LD_VAR 0 2
33033: ARRAY
33034: PPUSH
33035: LD_INT 2
33037: PUSH
33038: LD_INT 30
33040: PUSH
33041: LD_INT 32
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 30
33050: PUSH
33051: LD_INT 33
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: LIST
33062: PPUSH
33063: CALL_OW 72
33067: ST_TO_ADDR
// if not t then
33068: LD_VAR 0 6
33072: NOT
33073: IFFALSE 33077
// continue ;
33075: GO 32934
// for j in tmp do
33077: LD_ADDR_VAR 0 3
33081: PUSH
33082: LD_VAR 0 4
33086: PUSH
33087: FOR_IN
33088: IFFALSE 33118
// if not BuildingStatus ( j ) = bs_idle then
33090: LD_VAR 0 3
33094: PPUSH
33095: CALL_OW 461
33099: PUSH
33100: LD_INT 2
33102: EQUAL
33103: NOT
33104: IFFALSE 33116
// begin busy := true ;
33106: LD_ADDR_VAR 0 8
33110: PUSH
33111: LD_INT 1
33113: ST_TO_ADDR
// break ;
33114: GO 33118
// end ;
33116: GO 33087
33118: POP
33119: POP
// if busy then
33120: LD_VAR 0 8
33124: IFFALSE 33128
// continue ;
33126: GO 32934
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33128: LD_ADDR_VAR 0 7
33132: PUSH
33133: LD_VAR 0 6
33137: PPUSH
33138: LD_INT 35
33140: PUSH
33141: LD_INT 0
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PPUSH
33148: CALL_OW 72
33152: ST_TO_ADDR
// if tw then
33153: LD_VAR 0 7
33157: IFFALSE 33234
// begin tw := tw [ 1 ] ;
33159: LD_ADDR_VAR 0 7
33163: PUSH
33164: LD_VAR 0 7
33168: PUSH
33169: LD_INT 1
33171: ARRAY
33172: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33173: LD_ADDR_VAR 0 9
33177: PUSH
33178: LD_VAR 0 7
33182: PPUSH
33183: LD_EXP 118
33187: PUSH
33188: LD_VAR 0 2
33192: ARRAY
33193: PPUSH
33194: CALL 61484 0 2
33198: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33199: LD_EXP 132
33203: PUSH
33204: LD_VAR 0 2
33208: ARRAY
33209: IFFALSE 33232
// if not weapon in mc_allowed_tower_weapons [ i ] then
33211: LD_VAR 0 9
33215: PUSH
33216: LD_EXP 132
33220: PUSH
33221: LD_VAR 0 2
33225: ARRAY
33226: IN
33227: NOT
33228: IFFALSE 33232
// continue ;
33230: GO 32934
// end else
33232: GO 33297
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33234: LD_ADDR_VAR 0 5
33238: PUSH
33239: LD_EXP 101
33243: PUSH
33244: LD_VAR 0 2
33248: ARRAY
33249: PPUSH
33250: LD_VAR 0 4
33254: PPUSH
33255: CALL 87773 0 2
33259: ST_TO_ADDR
// if not tmp2 then
33260: LD_VAR 0 5
33264: NOT
33265: IFFALSE 33269
// continue ;
33267: GO 32934
// tw := tmp2 [ 1 ] ;
33269: LD_ADDR_VAR 0 7
33273: PUSH
33274: LD_VAR 0 5
33278: PUSH
33279: LD_INT 1
33281: ARRAY
33282: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33283: LD_ADDR_VAR 0 9
33287: PUSH
33288: LD_VAR 0 5
33292: PUSH
33293: LD_INT 2
33295: ARRAY
33296: ST_TO_ADDR
// end ; if not weapon then
33297: LD_VAR 0 9
33301: NOT
33302: IFFALSE 33306
// continue ;
33304: GO 32934
// ComPlaceWeapon ( tw , weapon ) ;
33306: LD_VAR 0 7
33310: PPUSH
33311: LD_VAR 0 9
33315: PPUSH
33316: CALL_OW 148
// end ;
33320: GO 32934
33322: POP
33323: POP
// end ;
33324: LD_VAR 0 1
33328: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33329: LD_INT 0
33331: PPUSH
33332: PPUSH
33333: PPUSH
33334: PPUSH
33335: PPUSH
33336: PPUSH
33337: PPUSH
// if not mc_bases then
33338: LD_EXP 93
33342: NOT
33343: IFFALSE 33347
// exit ;
33345: GO 34115
// for i = 1 to mc_bases do
33347: LD_ADDR_VAR 0 2
33351: PUSH
33352: DOUBLE
33353: LD_INT 1
33355: DEC
33356: ST_TO_ADDR
33357: LD_EXP 93
33361: PUSH
33362: FOR_TO
33363: IFFALSE 34113
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33365: LD_EXP 106
33369: PUSH
33370: LD_VAR 0 2
33374: ARRAY
33375: NOT
33376: PUSH
33377: LD_EXP 106
33381: PUSH
33382: LD_VAR 0 2
33386: ARRAY
33387: PUSH
33388: LD_EXP 107
33392: PUSH
33393: LD_VAR 0 2
33397: ARRAY
33398: EQUAL
33399: OR
33400: PUSH
33401: LD_EXP 116
33405: PUSH
33406: LD_VAR 0 2
33410: ARRAY
33411: OR
33412: IFFALSE 33416
// continue ;
33414: GO 33362
// if mc_miners [ i ] then
33416: LD_EXP 107
33420: PUSH
33421: LD_VAR 0 2
33425: ARRAY
33426: IFFALSE 33800
// begin for j = mc_miners [ i ] downto 1 do
33428: LD_ADDR_VAR 0 3
33432: PUSH
33433: DOUBLE
33434: LD_EXP 107
33438: PUSH
33439: LD_VAR 0 2
33443: ARRAY
33444: INC
33445: ST_TO_ADDR
33446: LD_INT 1
33448: PUSH
33449: FOR_DOWNTO
33450: IFFALSE 33798
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33452: LD_EXP 107
33456: PUSH
33457: LD_VAR 0 2
33461: ARRAY
33462: PUSH
33463: LD_VAR 0 3
33467: ARRAY
33468: PPUSH
33469: CALL_OW 301
33473: PUSH
33474: LD_EXP 107
33478: PUSH
33479: LD_VAR 0 2
33483: ARRAY
33484: PUSH
33485: LD_VAR 0 3
33489: ARRAY
33490: PPUSH
33491: CALL_OW 257
33495: PUSH
33496: LD_INT 1
33498: NONEQUAL
33499: OR
33500: IFFALSE 33563
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33502: LD_ADDR_VAR 0 5
33506: PUSH
33507: LD_EXP 107
33511: PUSH
33512: LD_VAR 0 2
33516: ARRAY
33517: PUSH
33518: LD_EXP 107
33522: PUSH
33523: LD_VAR 0 2
33527: ARRAY
33528: PUSH
33529: LD_VAR 0 3
33533: ARRAY
33534: DIFF
33535: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33536: LD_ADDR_EXP 107
33540: PUSH
33541: LD_EXP 107
33545: PPUSH
33546: LD_VAR 0 2
33550: PPUSH
33551: LD_VAR 0 5
33555: PPUSH
33556: CALL_OW 1
33560: ST_TO_ADDR
// continue ;
33561: GO 33449
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33563: LD_EXP 107
33567: PUSH
33568: LD_VAR 0 2
33572: ARRAY
33573: PUSH
33574: LD_VAR 0 3
33578: ARRAY
33579: PPUSH
33580: CALL_OW 257
33584: PUSH
33585: LD_INT 1
33587: EQUAL
33588: PUSH
33589: LD_EXP 107
33593: PUSH
33594: LD_VAR 0 2
33598: ARRAY
33599: PUSH
33600: LD_VAR 0 3
33604: ARRAY
33605: PPUSH
33606: CALL_OW 459
33610: NOT
33611: AND
33612: PUSH
33613: LD_EXP 107
33617: PUSH
33618: LD_VAR 0 2
33622: ARRAY
33623: PUSH
33624: LD_VAR 0 3
33628: ARRAY
33629: PPUSH
33630: CALL_OW 314
33634: NOT
33635: AND
33636: IFFALSE 33796
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33638: LD_EXP 107
33642: PUSH
33643: LD_VAR 0 2
33647: ARRAY
33648: PUSH
33649: LD_VAR 0 3
33653: ARRAY
33654: PPUSH
33655: CALL_OW 310
33659: IFFALSE 33682
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33661: LD_EXP 107
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: PUSH
33672: LD_VAR 0 3
33676: ARRAY
33677: PPUSH
33678: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33682: LD_EXP 107
33686: PUSH
33687: LD_VAR 0 2
33691: ARRAY
33692: PUSH
33693: LD_VAR 0 3
33697: ARRAY
33698: PPUSH
33699: CALL_OW 314
33703: NOT
33704: IFFALSE 33796
// begin r := rand ( 1 , mc_mines [ i ] ) ;
33706: LD_ADDR_VAR 0 7
33710: PUSH
33711: LD_INT 1
33713: PPUSH
33714: LD_EXP 106
33718: PUSH
33719: LD_VAR 0 2
33723: ARRAY
33724: PPUSH
33725: CALL_OW 12
33729: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
33730: LD_EXP 107
33734: PUSH
33735: LD_VAR 0 2
33739: ARRAY
33740: PUSH
33741: LD_VAR 0 3
33745: ARRAY
33746: PPUSH
33747: LD_EXP 106
33751: PUSH
33752: LD_VAR 0 2
33756: ARRAY
33757: PUSH
33758: LD_VAR 0 7
33762: ARRAY
33763: PUSH
33764: LD_INT 1
33766: ARRAY
33767: PPUSH
33768: LD_EXP 106
33772: PUSH
33773: LD_VAR 0 2
33777: ARRAY
33778: PUSH
33779: LD_VAR 0 7
33783: ARRAY
33784: PUSH
33785: LD_INT 2
33787: ARRAY
33788: PPUSH
33789: LD_INT 0
33791: PPUSH
33792: CALL_OW 193
// end ; end ; end ;
33796: GO 33449
33798: POP
33799: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33800: LD_ADDR_VAR 0 5
33804: PUSH
33805: LD_EXP 93
33809: PUSH
33810: LD_VAR 0 2
33814: ARRAY
33815: PPUSH
33816: LD_INT 2
33818: PUSH
33819: LD_INT 30
33821: PUSH
33822: LD_INT 4
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 30
33831: PUSH
33832: LD_INT 5
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 30
33841: PUSH
33842: LD_INT 32
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: PPUSH
33855: CALL_OW 72
33859: ST_TO_ADDR
// if not tmp then
33860: LD_VAR 0 5
33864: NOT
33865: IFFALSE 33869
// continue ;
33867: GO 33362
// list := [ ] ;
33869: LD_ADDR_VAR 0 6
33873: PUSH
33874: EMPTY
33875: ST_TO_ADDR
// for j in tmp do
33876: LD_ADDR_VAR 0 3
33880: PUSH
33881: LD_VAR 0 5
33885: PUSH
33886: FOR_IN
33887: IFFALSE 33956
// begin for k in UnitsInside ( j ) do
33889: LD_ADDR_VAR 0 4
33893: PUSH
33894: LD_VAR 0 3
33898: PPUSH
33899: CALL_OW 313
33903: PUSH
33904: FOR_IN
33905: IFFALSE 33952
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33907: LD_VAR 0 4
33911: PPUSH
33912: CALL_OW 257
33916: PUSH
33917: LD_INT 1
33919: EQUAL
33920: PUSH
33921: LD_VAR 0 4
33925: PPUSH
33926: CALL_OW 459
33930: NOT
33931: AND
33932: IFFALSE 33950
// list := list ^ k ;
33934: LD_ADDR_VAR 0 6
33938: PUSH
33939: LD_VAR 0 6
33943: PUSH
33944: LD_VAR 0 4
33948: ADD
33949: ST_TO_ADDR
33950: GO 33904
33952: POP
33953: POP
// end ;
33954: GO 33886
33956: POP
33957: POP
// list := list diff mc_miners [ i ] ;
33958: LD_ADDR_VAR 0 6
33962: PUSH
33963: LD_VAR 0 6
33967: PUSH
33968: LD_EXP 107
33972: PUSH
33973: LD_VAR 0 2
33977: ARRAY
33978: DIFF
33979: ST_TO_ADDR
// if not list then
33980: LD_VAR 0 6
33984: NOT
33985: IFFALSE 33989
// continue ;
33987: GO 33362
// k := mc_mines [ i ] - mc_miners [ i ] ;
33989: LD_ADDR_VAR 0 4
33993: PUSH
33994: LD_EXP 106
33998: PUSH
33999: LD_VAR 0 2
34003: ARRAY
34004: PUSH
34005: LD_EXP 107
34009: PUSH
34010: LD_VAR 0 2
34014: ARRAY
34015: MINUS
34016: ST_TO_ADDR
// if k > list then
34017: LD_VAR 0 4
34021: PUSH
34022: LD_VAR 0 6
34026: GREATER
34027: IFFALSE 34039
// k := list ;
34029: LD_ADDR_VAR 0 4
34033: PUSH
34034: LD_VAR 0 6
34038: ST_TO_ADDR
// for j = 1 to k do
34039: LD_ADDR_VAR 0 3
34043: PUSH
34044: DOUBLE
34045: LD_INT 1
34047: DEC
34048: ST_TO_ADDR
34049: LD_VAR 0 4
34053: PUSH
34054: FOR_TO
34055: IFFALSE 34109
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34057: LD_ADDR_EXP 107
34061: PUSH
34062: LD_EXP 107
34066: PPUSH
34067: LD_VAR 0 2
34071: PUSH
34072: LD_EXP 107
34076: PUSH
34077: LD_VAR 0 2
34081: ARRAY
34082: PUSH
34083: LD_INT 1
34085: PLUS
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PPUSH
34091: LD_VAR 0 6
34095: PUSH
34096: LD_VAR 0 3
34100: ARRAY
34101: PPUSH
34102: CALL 56474 0 3
34106: ST_TO_ADDR
34107: GO 34054
34109: POP
34110: POP
// end ;
34111: GO 33362
34113: POP
34114: POP
// end ;
34115: LD_VAR 0 1
34119: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34120: LD_INT 0
34122: PPUSH
34123: PPUSH
34124: PPUSH
34125: PPUSH
34126: PPUSH
34127: PPUSH
34128: PPUSH
34129: PPUSH
34130: PPUSH
34131: PPUSH
34132: PPUSH
// if not mc_bases then
34133: LD_EXP 93
34137: NOT
34138: IFFALSE 34142
// exit ;
34140: GO 35965
// for i = 1 to mc_bases do
34142: LD_ADDR_VAR 0 2
34146: PUSH
34147: DOUBLE
34148: LD_INT 1
34150: DEC
34151: ST_TO_ADDR
34152: LD_EXP 93
34156: PUSH
34157: FOR_TO
34158: IFFALSE 35963
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34160: LD_EXP 93
34164: PUSH
34165: LD_VAR 0 2
34169: ARRAY
34170: NOT
34171: PUSH
34172: LD_EXP 100
34176: PUSH
34177: LD_VAR 0 2
34181: ARRAY
34182: OR
34183: IFFALSE 34187
// continue ;
34185: GO 34157
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34187: LD_EXP 109
34191: PUSH
34192: LD_VAR 0 2
34196: ARRAY
34197: NOT
34198: PUSH
34199: LD_EXP 110
34203: PUSH
34204: LD_VAR 0 2
34208: ARRAY
34209: AND
34210: IFFALSE 34248
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34212: LD_ADDR_EXP 110
34216: PUSH
34217: LD_EXP 110
34221: PPUSH
34222: LD_VAR 0 2
34226: PPUSH
34227: EMPTY
34228: PPUSH
34229: CALL_OW 1
34233: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34234: LD_VAR 0 2
34238: PPUSH
34239: LD_INT 107
34241: PPUSH
34242: CALL 25016 0 2
// continue ;
34246: GO 34157
// end ; target := [ ] ;
34248: LD_ADDR_VAR 0 7
34252: PUSH
34253: EMPTY
34254: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34255: LD_ADDR_VAR 0 6
34259: PUSH
34260: LD_EXP 93
34264: PUSH
34265: LD_VAR 0 2
34269: ARRAY
34270: PUSH
34271: LD_INT 1
34273: ARRAY
34274: PPUSH
34275: CALL_OW 255
34279: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34280: LD_ADDR_VAR 0 9
34284: PUSH
34285: LD_EXP 93
34289: PUSH
34290: LD_VAR 0 2
34294: ARRAY
34295: PPUSH
34296: LD_INT 2
34298: PUSH
34299: LD_INT 30
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 30
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: LIST
34323: PPUSH
34324: CALL_OW 72
34328: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34329: LD_ADDR_VAR 0 3
34333: PUSH
34334: DOUBLE
34335: LD_EXP 109
34339: PUSH
34340: LD_VAR 0 2
34344: ARRAY
34345: INC
34346: ST_TO_ADDR
34347: LD_INT 1
34349: PUSH
34350: FOR_DOWNTO
34351: IFFALSE 34596
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34353: LD_EXP 109
34357: PUSH
34358: LD_VAR 0 2
34362: ARRAY
34363: PUSH
34364: LD_VAR 0 3
34368: ARRAY
34369: PUSH
34370: LD_INT 2
34372: ARRAY
34373: PPUSH
34374: LD_EXP 109
34378: PUSH
34379: LD_VAR 0 2
34383: ARRAY
34384: PUSH
34385: LD_VAR 0 3
34389: ARRAY
34390: PUSH
34391: LD_INT 3
34393: ARRAY
34394: PPUSH
34395: CALL_OW 488
34399: PUSH
34400: LD_EXP 109
34404: PUSH
34405: LD_VAR 0 2
34409: ARRAY
34410: PUSH
34411: LD_VAR 0 3
34415: ARRAY
34416: PUSH
34417: LD_INT 2
34419: ARRAY
34420: PPUSH
34421: LD_EXP 109
34425: PUSH
34426: LD_VAR 0 2
34430: ARRAY
34431: PUSH
34432: LD_VAR 0 3
34436: ARRAY
34437: PUSH
34438: LD_INT 3
34440: ARRAY
34441: PPUSH
34442: CALL_OW 284
34446: PUSH
34447: LD_INT 0
34449: EQUAL
34450: AND
34451: IFFALSE 34506
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34453: LD_ADDR_VAR 0 5
34457: PUSH
34458: LD_EXP 109
34462: PUSH
34463: LD_VAR 0 2
34467: ARRAY
34468: PPUSH
34469: LD_VAR 0 3
34473: PPUSH
34474: CALL_OW 3
34478: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34479: LD_ADDR_EXP 109
34483: PUSH
34484: LD_EXP 109
34488: PPUSH
34489: LD_VAR 0 2
34493: PPUSH
34494: LD_VAR 0 5
34498: PPUSH
34499: CALL_OW 1
34503: ST_TO_ADDR
// continue ;
34504: GO 34350
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34506: LD_VAR 0 6
34510: PPUSH
34511: LD_EXP 109
34515: PUSH
34516: LD_VAR 0 2
34520: ARRAY
34521: PUSH
34522: LD_VAR 0 3
34526: ARRAY
34527: PUSH
34528: LD_INT 2
34530: ARRAY
34531: PPUSH
34532: LD_EXP 109
34536: PUSH
34537: LD_VAR 0 2
34541: ARRAY
34542: PUSH
34543: LD_VAR 0 3
34547: ARRAY
34548: PUSH
34549: LD_INT 3
34551: ARRAY
34552: PPUSH
34553: LD_INT 30
34555: PPUSH
34556: CALL 57370 0 4
34560: PUSH
34561: LD_INT 4
34563: ARRAY
34564: PUSH
34565: LD_INT 0
34567: EQUAL
34568: IFFALSE 34594
// begin target := mc_crates [ i ] [ j ] ;
34570: LD_ADDR_VAR 0 7
34574: PUSH
34575: LD_EXP 109
34579: PUSH
34580: LD_VAR 0 2
34584: ARRAY
34585: PUSH
34586: LD_VAR 0 3
34590: ARRAY
34591: ST_TO_ADDR
// break ;
34592: GO 34596
// end ; end ;
34594: GO 34350
34596: POP
34597: POP
// if not target then
34598: LD_VAR 0 7
34602: NOT
34603: IFFALSE 34607
// continue ;
34605: GO 34157
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34607: LD_ADDR_VAR 0 8
34611: PUSH
34612: LD_EXP 112
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: PPUSH
34623: LD_INT 2
34625: PUSH
34626: LD_INT 3
34628: PUSH
34629: LD_INT 58
34631: PUSH
34632: EMPTY
34633: LIST
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 61
34641: PUSH
34642: EMPTY
34643: LIST
34644: PUSH
34645: LD_INT 33
34647: PUSH
34648: LD_INT 5
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 33
34657: PUSH
34658: LD_INT 3
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 2
34674: PUSH
34675: LD_INT 34
34677: PUSH
34678: LD_INT 32
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 34
34687: PUSH
34688: LD_INT 51
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: LD_INT 34
34697: PUSH
34698: LD_INT 12
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PPUSH
34715: CALL_OW 72
34719: ST_TO_ADDR
// if not cargo then
34720: LD_VAR 0 8
34724: NOT
34725: IFFALSE 35431
// begin if mc_crates_collector [ i ] < 5 then
34727: LD_EXP 110
34731: PUSH
34732: LD_VAR 0 2
34736: ARRAY
34737: PUSH
34738: LD_INT 5
34740: LESS
34741: IFFALSE 35107
// begin if mc_ape [ i ] then
34743: LD_EXP 122
34747: PUSH
34748: LD_VAR 0 2
34752: ARRAY
34753: IFFALSE 34800
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34755: LD_ADDR_VAR 0 5
34759: PUSH
34760: LD_EXP 122
34764: PUSH
34765: LD_VAR 0 2
34769: ARRAY
34770: PPUSH
34771: LD_INT 25
34773: PUSH
34774: LD_INT 16
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 24
34783: PUSH
34784: LD_INT 750
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PPUSH
34795: CALL_OW 72
34799: ST_TO_ADDR
// if not tmp then
34800: LD_VAR 0 5
34804: NOT
34805: IFFALSE 34852
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34807: LD_ADDR_VAR 0 5
34811: PUSH
34812: LD_EXP 93
34816: PUSH
34817: LD_VAR 0 2
34821: ARRAY
34822: PPUSH
34823: LD_INT 25
34825: PUSH
34826: LD_INT 2
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 24
34835: PUSH
34836: LD_INT 750
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PPUSH
34847: CALL_OW 72
34851: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34852: LD_EXP 122
34856: PUSH
34857: LD_VAR 0 2
34861: ARRAY
34862: PUSH
34863: LD_EXP 93
34867: PUSH
34868: LD_VAR 0 2
34872: ARRAY
34873: PPUSH
34874: LD_INT 25
34876: PUSH
34877: LD_INT 2
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 24
34886: PUSH
34887: LD_INT 750
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PPUSH
34898: CALL_OW 72
34902: AND
34903: PUSH
34904: LD_VAR 0 5
34908: PUSH
34909: LD_INT 5
34911: LESS
34912: AND
34913: IFFALSE 34995
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34915: LD_ADDR_VAR 0 3
34919: PUSH
34920: LD_EXP 93
34924: PUSH
34925: LD_VAR 0 2
34929: ARRAY
34930: PPUSH
34931: LD_INT 25
34933: PUSH
34934: LD_INT 2
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 24
34943: PUSH
34944: LD_INT 750
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PPUSH
34955: CALL_OW 72
34959: PUSH
34960: FOR_IN
34961: IFFALSE 34993
// begin tmp := tmp union j ;
34963: LD_ADDR_VAR 0 5
34967: PUSH
34968: LD_VAR 0 5
34972: PUSH
34973: LD_VAR 0 3
34977: UNION
34978: ST_TO_ADDR
// if tmp >= 5 then
34979: LD_VAR 0 5
34983: PUSH
34984: LD_INT 5
34986: GREATEREQUAL
34987: IFFALSE 34991
// break ;
34989: GO 34993
// end ;
34991: GO 34960
34993: POP
34994: POP
// end ; if not tmp then
34995: LD_VAR 0 5
34999: NOT
35000: IFFALSE 35004
// continue ;
35002: GO 34157
// for j in tmp do
35004: LD_ADDR_VAR 0 3
35008: PUSH
35009: LD_VAR 0 5
35013: PUSH
35014: FOR_IN
35015: IFFALSE 35105
// if not GetTag ( j ) then
35017: LD_VAR 0 3
35021: PPUSH
35022: CALL_OW 110
35026: NOT
35027: IFFALSE 35103
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35029: LD_ADDR_EXP 110
35033: PUSH
35034: LD_EXP 110
35038: PPUSH
35039: LD_VAR 0 2
35043: PUSH
35044: LD_EXP 110
35048: PUSH
35049: LD_VAR 0 2
35053: ARRAY
35054: PUSH
35055: LD_INT 1
35057: PLUS
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PPUSH
35063: LD_VAR 0 3
35067: PPUSH
35068: CALL 56474 0 3
35072: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35073: LD_VAR 0 3
35077: PPUSH
35078: LD_INT 107
35080: PPUSH
35081: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35085: LD_EXP 110
35089: PUSH
35090: LD_VAR 0 2
35094: ARRAY
35095: PUSH
35096: LD_INT 5
35098: GREATEREQUAL
35099: IFFALSE 35103
// break ;
35101: GO 35105
// end ;
35103: GO 35014
35105: POP
35106: POP
// end ; if mc_crates_collector [ i ] and target then
35107: LD_EXP 110
35111: PUSH
35112: LD_VAR 0 2
35116: ARRAY
35117: PUSH
35118: LD_VAR 0 7
35122: AND
35123: IFFALSE 35429
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35125: LD_EXP 110
35129: PUSH
35130: LD_VAR 0 2
35134: ARRAY
35135: PUSH
35136: LD_VAR 0 7
35140: PUSH
35141: LD_INT 1
35143: ARRAY
35144: LESS
35145: IFFALSE 35165
// tmp := mc_crates_collector [ i ] else
35147: LD_ADDR_VAR 0 5
35151: PUSH
35152: LD_EXP 110
35156: PUSH
35157: LD_VAR 0 2
35161: ARRAY
35162: ST_TO_ADDR
35163: GO 35179
// tmp := target [ 1 ] ;
35165: LD_ADDR_VAR 0 5
35169: PUSH
35170: LD_VAR 0 7
35174: PUSH
35175: LD_INT 1
35177: ARRAY
35178: ST_TO_ADDR
// k := 0 ;
35179: LD_ADDR_VAR 0 4
35183: PUSH
35184: LD_INT 0
35186: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35187: LD_ADDR_VAR 0 3
35191: PUSH
35192: LD_EXP 110
35196: PUSH
35197: LD_VAR 0 2
35201: ARRAY
35202: PUSH
35203: FOR_IN
35204: IFFALSE 35427
// begin k := k + 1 ;
35206: LD_ADDR_VAR 0 4
35210: PUSH
35211: LD_VAR 0 4
35215: PUSH
35216: LD_INT 1
35218: PLUS
35219: ST_TO_ADDR
// if k > tmp then
35220: LD_VAR 0 4
35224: PUSH
35225: LD_VAR 0 5
35229: GREATER
35230: IFFALSE 35234
// break ;
35232: GO 35427
// if not GetClass ( j ) in [ 2 , 16 ] then
35234: LD_VAR 0 3
35238: PPUSH
35239: CALL_OW 257
35243: PUSH
35244: LD_INT 2
35246: PUSH
35247: LD_INT 16
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: IN
35254: NOT
35255: IFFALSE 35308
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35257: LD_ADDR_EXP 110
35261: PUSH
35262: LD_EXP 110
35266: PPUSH
35267: LD_VAR 0 2
35271: PPUSH
35272: LD_EXP 110
35276: PUSH
35277: LD_VAR 0 2
35281: ARRAY
35282: PUSH
35283: LD_VAR 0 3
35287: DIFF
35288: PPUSH
35289: CALL_OW 1
35293: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35294: LD_VAR 0 3
35298: PPUSH
35299: LD_INT 0
35301: PPUSH
35302: CALL_OW 109
// continue ;
35306: GO 35203
// end ; if IsInUnit ( j ) then
35308: LD_VAR 0 3
35312: PPUSH
35313: CALL_OW 310
35317: IFFALSE 35328
// ComExitBuilding ( j ) ;
35319: LD_VAR 0 3
35323: PPUSH
35324: CALL_OW 122
// wait ( 3 ) ;
35328: LD_INT 3
35330: PPUSH
35331: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35335: LD_VAR 0 3
35339: PPUSH
35340: CALL_OW 314
35344: PUSH
35345: LD_VAR 0 6
35349: PPUSH
35350: LD_VAR 0 7
35354: PUSH
35355: LD_INT 2
35357: ARRAY
35358: PPUSH
35359: LD_VAR 0 7
35363: PUSH
35364: LD_INT 3
35366: ARRAY
35367: PPUSH
35368: LD_INT 30
35370: PPUSH
35371: CALL 57370 0 4
35375: PUSH
35376: LD_INT 4
35378: ARRAY
35379: AND
35380: IFFALSE 35398
// ComStandNearbyBuilding ( j , depot ) else
35382: LD_VAR 0 3
35386: PPUSH
35387: LD_VAR 0 9
35391: PPUSH
35392: CALL 53052 0 2
35396: GO 35425
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35398: LD_VAR 0 3
35402: PPUSH
35403: LD_VAR 0 7
35407: PUSH
35408: LD_INT 2
35410: ARRAY
35411: PPUSH
35412: LD_VAR 0 7
35416: PUSH
35417: LD_INT 3
35419: ARRAY
35420: PPUSH
35421: CALL_OW 117
// end ;
35425: GO 35203
35427: POP
35428: POP
// end ; end else
35429: GO 35961
// begin for j in cargo do
35431: LD_ADDR_VAR 0 3
35435: PUSH
35436: LD_VAR 0 8
35440: PUSH
35441: FOR_IN
35442: IFFALSE 35959
// begin if GetTag ( j ) <> 0 then
35444: LD_VAR 0 3
35448: PPUSH
35449: CALL_OW 110
35453: PUSH
35454: LD_INT 0
35456: NONEQUAL
35457: IFFALSE 35461
// continue ;
35459: GO 35441
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35461: LD_VAR 0 3
35465: PPUSH
35466: CALL_OW 256
35470: PUSH
35471: LD_INT 1000
35473: LESS
35474: PUSH
35475: LD_VAR 0 3
35479: PPUSH
35480: LD_EXP 117
35484: PUSH
35485: LD_VAR 0 2
35489: ARRAY
35490: PPUSH
35491: CALL_OW 308
35495: NOT
35496: AND
35497: IFFALSE 35519
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35499: LD_VAR 0 3
35503: PPUSH
35504: LD_EXP 117
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PPUSH
35515: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35519: LD_VAR 0 3
35523: PPUSH
35524: CALL_OW 256
35528: PUSH
35529: LD_INT 1000
35531: LESS
35532: PUSH
35533: LD_VAR 0 3
35537: PPUSH
35538: LD_EXP 117
35542: PUSH
35543: LD_VAR 0 2
35547: ARRAY
35548: PPUSH
35549: CALL_OW 308
35553: AND
35554: IFFALSE 35558
// continue ;
35556: GO 35441
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35558: LD_VAR 0 3
35562: PPUSH
35563: CALL_OW 262
35567: PUSH
35568: LD_INT 2
35570: EQUAL
35571: PUSH
35572: LD_VAR 0 3
35576: PPUSH
35577: CALL_OW 261
35581: PUSH
35582: LD_INT 15
35584: LESS
35585: AND
35586: IFFALSE 35590
// continue ;
35588: GO 35441
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35590: LD_VAR 0 3
35594: PPUSH
35595: CALL_OW 262
35599: PUSH
35600: LD_INT 1
35602: EQUAL
35603: PUSH
35604: LD_VAR 0 3
35608: PPUSH
35609: CALL_OW 261
35613: PUSH
35614: LD_INT 10
35616: LESS
35617: AND
35618: IFFALSE 35898
// begin if not depot then
35620: LD_VAR 0 9
35624: NOT
35625: IFFALSE 35629
// continue ;
35627: GO 35441
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35629: LD_VAR 0 3
35633: PPUSH
35634: LD_VAR 0 9
35638: PPUSH
35639: LD_VAR 0 3
35643: PPUSH
35644: CALL_OW 74
35648: PPUSH
35649: CALL_OW 296
35653: PUSH
35654: LD_INT 6
35656: LESS
35657: IFFALSE 35673
// SetFuel ( j , 100 ) else
35659: LD_VAR 0 3
35663: PPUSH
35664: LD_INT 100
35666: PPUSH
35667: CALL_OW 240
35671: GO 35898
// if GetFuel ( j ) = 0 then
35673: LD_VAR 0 3
35677: PPUSH
35678: CALL_OW 261
35682: PUSH
35683: LD_INT 0
35685: EQUAL
35686: IFFALSE 35898
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35688: LD_ADDR_EXP 112
35692: PUSH
35693: LD_EXP 112
35697: PPUSH
35698: LD_VAR 0 2
35702: PPUSH
35703: LD_EXP 112
35707: PUSH
35708: LD_VAR 0 2
35712: ARRAY
35713: PUSH
35714: LD_VAR 0 3
35718: DIFF
35719: PPUSH
35720: CALL_OW 1
35724: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35725: LD_VAR 0 3
35729: PPUSH
35730: CALL_OW 263
35734: PUSH
35735: LD_INT 1
35737: EQUAL
35738: IFFALSE 35754
// ComExitVehicle ( IsInUnit ( j ) ) ;
35740: LD_VAR 0 3
35744: PPUSH
35745: CALL_OW 310
35749: PPUSH
35750: CALL_OW 121
// if GetControl ( j ) = control_remote then
35754: LD_VAR 0 3
35758: PPUSH
35759: CALL_OW 263
35763: PUSH
35764: LD_INT 2
35766: EQUAL
35767: IFFALSE 35778
// ComUnlink ( j ) ;
35769: LD_VAR 0 3
35773: PPUSH
35774: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35778: LD_ADDR_VAR 0 10
35782: PUSH
35783: LD_VAR 0 2
35787: PPUSH
35788: LD_INT 3
35790: PPUSH
35791: CALL 45537 0 2
35795: ST_TO_ADDR
// if fac then
35796: LD_VAR 0 10
35800: IFFALSE 35896
// begin for k in fac do
35802: LD_ADDR_VAR 0 4
35806: PUSH
35807: LD_VAR 0 10
35811: PUSH
35812: FOR_IN
35813: IFFALSE 35894
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35815: LD_ADDR_VAR 0 11
35819: PUSH
35820: LD_VAR 0 10
35824: PPUSH
35825: LD_VAR 0 3
35829: PPUSH
35830: CALL_OW 265
35834: PPUSH
35835: LD_VAR 0 3
35839: PPUSH
35840: CALL_OW 262
35844: PPUSH
35845: LD_VAR 0 3
35849: PPUSH
35850: CALL_OW 263
35854: PPUSH
35855: LD_VAR 0 3
35859: PPUSH
35860: CALL_OW 264
35864: PPUSH
35865: CALL 53970 0 5
35869: ST_TO_ADDR
// if components then
35870: LD_VAR 0 11
35874: IFFALSE 35892
// begin MC_InsertProduceList ( i , components ) ;
35876: LD_VAR 0 2
35880: PPUSH
35881: LD_VAR 0 11
35885: PPUSH
35886: CALL 45082 0 2
// break ;
35890: GO 35894
// end ; end ;
35892: GO 35812
35894: POP
35895: POP
// end ; continue ;
35896: GO 35441
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35898: LD_VAR 0 3
35902: PPUSH
35903: LD_INT 1
35905: PPUSH
35906: CALL_OW 289
35910: PUSH
35911: LD_INT 100
35913: LESS
35914: PUSH
35915: LD_VAR 0 3
35919: PPUSH
35920: CALL_OW 314
35924: NOT
35925: AND
35926: IFFALSE 35955
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35928: LD_VAR 0 3
35932: PPUSH
35933: LD_VAR 0 7
35937: PUSH
35938: LD_INT 2
35940: ARRAY
35941: PPUSH
35942: LD_VAR 0 7
35946: PUSH
35947: LD_INT 3
35949: ARRAY
35950: PPUSH
35951: CALL_OW 117
// break ;
35955: GO 35959
// end ;
35957: GO 35441
35959: POP
35960: POP
// end ; end ;
35961: GO 34157
35963: POP
35964: POP
// end ;
35965: LD_VAR 0 1
35969: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35970: LD_INT 0
35972: PPUSH
35973: PPUSH
35974: PPUSH
35975: PPUSH
// if not mc_bases then
35976: LD_EXP 93
35980: NOT
35981: IFFALSE 35985
// exit ;
35983: GO 36146
// for i = 1 to mc_bases do
35985: LD_ADDR_VAR 0 2
35989: PUSH
35990: DOUBLE
35991: LD_INT 1
35993: DEC
35994: ST_TO_ADDR
35995: LD_EXP 93
35999: PUSH
36000: FOR_TO
36001: IFFALSE 36144
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36003: LD_ADDR_VAR 0 4
36007: PUSH
36008: LD_EXP 112
36012: PUSH
36013: LD_VAR 0 2
36017: ARRAY
36018: PUSH
36019: LD_EXP 115
36023: PUSH
36024: LD_VAR 0 2
36028: ARRAY
36029: UNION
36030: PPUSH
36031: LD_INT 33
36033: PUSH
36034: LD_INT 2
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PPUSH
36041: CALL_OW 72
36045: ST_TO_ADDR
// if tmp then
36046: LD_VAR 0 4
36050: IFFALSE 36142
// for j in tmp do
36052: LD_ADDR_VAR 0 3
36056: PUSH
36057: LD_VAR 0 4
36061: PUSH
36062: FOR_IN
36063: IFFALSE 36140
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36065: LD_VAR 0 3
36069: PPUSH
36070: CALL_OW 312
36074: NOT
36075: PUSH
36076: LD_VAR 0 3
36080: PPUSH
36081: CALL_OW 256
36085: PUSH
36086: LD_INT 250
36088: GREATEREQUAL
36089: AND
36090: IFFALSE 36103
// Connect ( j ) else
36092: LD_VAR 0 3
36096: PPUSH
36097: CALL 59445 0 1
36101: GO 36138
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36103: LD_VAR 0 3
36107: PPUSH
36108: CALL_OW 256
36112: PUSH
36113: LD_INT 250
36115: LESS
36116: PUSH
36117: LD_VAR 0 3
36121: PPUSH
36122: CALL_OW 312
36126: AND
36127: IFFALSE 36138
// ComUnlink ( j ) ;
36129: LD_VAR 0 3
36133: PPUSH
36134: CALL_OW 136
36138: GO 36062
36140: POP
36141: POP
// end ;
36142: GO 36000
36144: POP
36145: POP
// end ;
36146: LD_VAR 0 1
36150: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36151: LD_INT 0
36153: PPUSH
36154: PPUSH
36155: PPUSH
36156: PPUSH
36157: PPUSH
// if not mc_bases then
36158: LD_EXP 93
36162: NOT
36163: IFFALSE 36167
// exit ;
36165: GO 36612
// for i = 1 to mc_bases do
36167: LD_ADDR_VAR 0 2
36171: PUSH
36172: DOUBLE
36173: LD_INT 1
36175: DEC
36176: ST_TO_ADDR
36177: LD_EXP 93
36181: PUSH
36182: FOR_TO
36183: IFFALSE 36610
// begin if not mc_produce [ i ] then
36185: LD_EXP 114
36189: PUSH
36190: LD_VAR 0 2
36194: ARRAY
36195: NOT
36196: IFFALSE 36200
// continue ;
36198: GO 36182
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36200: LD_ADDR_VAR 0 5
36204: PUSH
36205: LD_EXP 93
36209: PUSH
36210: LD_VAR 0 2
36214: ARRAY
36215: PPUSH
36216: LD_INT 30
36218: PUSH
36219: LD_INT 3
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PPUSH
36226: CALL_OW 72
36230: ST_TO_ADDR
// if not fac then
36231: LD_VAR 0 5
36235: NOT
36236: IFFALSE 36240
// continue ;
36238: GO 36182
// for j in fac do
36240: LD_ADDR_VAR 0 3
36244: PUSH
36245: LD_VAR 0 5
36249: PUSH
36250: FOR_IN
36251: IFFALSE 36606
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36253: LD_VAR 0 3
36257: PPUSH
36258: CALL_OW 461
36262: PUSH
36263: LD_INT 2
36265: NONEQUAL
36266: PUSH
36267: LD_VAR 0 3
36271: PPUSH
36272: LD_INT 15
36274: PPUSH
36275: CALL 59073 0 2
36279: PUSH
36280: LD_INT 4
36282: ARRAY
36283: OR
36284: IFFALSE 36288
// continue ;
36286: GO 36250
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36288: LD_VAR 0 3
36292: PPUSH
36293: LD_EXP 114
36297: PUSH
36298: LD_VAR 0 2
36302: ARRAY
36303: PUSH
36304: LD_INT 1
36306: ARRAY
36307: PUSH
36308: LD_INT 1
36310: ARRAY
36311: PPUSH
36312: LD_EXP 114
36316: PUSH
36317: LD_VAR 0 2
36321: ARRAY
36322: PUSH
36323: LD_INT 1
36325: ARRAY
36326: PUSH
36327: LD_INT 2
36329: ARRAY
36330: PPUSH
36331: LD_EXP 114
36335: PUSH
36336: LD_VAR 0 2
36340: ARRAY
36341: PUSH
36342: LD_INT 1
36344: ARRAY
36345: PUSH
36346: LD_INT 3
36348: ARRAY
36349: PPUSH
36350: LD_EXP 114
36354: PUSH
36355: LD_VAR 0 2
36359: ARRAY
36360: PUSH
36361: LD_INT 1
36363: ARRAY
36364: PUSH
36365: LD_INT 4
36367: ARRAY
36368: PPUSH
36369: CALL_OW 448
36373: PUSH
36374: LD_VAR 0 3
36378: PPUSH
36379: LD_EXP 114
36383: PUSH
36384: LD_VAR 0 2
36388: ARRAY
36389: PUSH
36390: LD_INT 1
36392: ARRAY
36393: PUSH
36394: LD_INT 1
36396: ARRAY
36397: PUSH
36398: LD_EXP 114
36402: PUSH
36403: LD_VAR 0 2
36407: ARRAY
36408: PUSH
36409: LD_INT 1
36411: ARRAY
36412: PUSH
36413: LD_INT 2
36415: ARRAY
36416: PUSH
36417: LD_EXP 114
36421: PUSH
36422: LD_VAR 0 2
36426: ARRAY
36427: PUSH
36428: LD_INT 1
36430: ARRAY
36431: PUSH
36432: LD_INT 3
36434: ARRAY
36435: PUSH
36436: LD_EXP 114
36440: PUSH
36441: LD_VAR 0 2
36445: ARRAY
36446: PUSH
36447: LD_INT 1
36449: ARRAY
36450: PUSH
36451: LD_INT 4
36453: ARRAY
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: PPUSH
36461: CALL 62840 0 2
36465: AND
36466: IFFALSE 36604
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36468: LD_VAR 0 3
36472: PPUSH
36473: LD_EXP 114
36477: PUSH
36478: LD_VAR 0 2
36482: ARRAY
36483: PUSH
36484: LD_INT 1
36486: ARRAY
36487: PUSH
36488: LD_INT 1
36490: ARRAY
36491: PPUSH
36492: LD_EXP 114
36496: PUSH
36497: LD_VAR 0 2
36501: ARRAY
36502: PUSH
36503: LD_INT 1
36505: ARRAY
36506: PUSH
36507: LD_INT 2
36509: ARRAY
36510: PPUSH
36511: LD_EXP 114
36515: PUSH
36516: LD_VAR 0 2
36520: ARRAY
36521: PUSH
36522: LD_INT 1
36524: ARRAY
36525: PUSH
36526: LD_INT 3
36528: ARRAY
36529: PPUSH
36530: LD_EXP 114
36534: PUSH
36535: LD_VAR 0 2
36539: ARRAY
36540: PUSH
36541: LD_INT 1
36543: ARRAY
36544: PUSH
36545: LD_INT 4
36547: ARRAY
36548: PPUSH
36549: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36553: LD_ADDR_VAR 0 4
36557: PUSH
36558: LD_EXP 114
36562: PUSH
36563: LD_VAR 0 2
36567: ARRAY
36568: PPUSH
36569: LD_INT 1
36571: PPUSH
36572: CALL_OW 3
36576: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36577: LD_ADDR_EXP 114
36581: PUSH
36582: LD_EXP 114
36586: PPUSH
36587: LD_VAR 0 2
36591: PPUSH
36592: LD_VAR 0 4
36596: PPUSH
36597: CALL_OW 1
36601: ST_TO_ADDR
// break ;
36602: GO 36606
// end ; end ;
36604: GO 36250
36606: POP
36607: POP
// end ;
36608: GO 36182
36610: POP
36611: POP
// end ;
36612: LD_VAR 0 1
36616: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36617: LD_INT 0
36619: PPUSH
36620: PPUSH
36621: PPUSH
// if not mc_bases then
36622: LD_EXP 93
36626: NOT
36627: IFFALSE 36631
// exit ;
36629: GO 36720
// for i = 1 to mc_bases do
36631: LD_ADDR_VAR 0 2
36635: PUSH
36636: DOUBLE
36637: LD_INT 1
36639: DEC
36640: ST_TO_ADDR
36641: LD_EXP 93
36645: PUSH
36646: FOR_TO
36647: IFFALSE 36718
// begin if mc_attack [ i ] then
36649: LD_EXP 113
36653: PUSH
36654: LD_VAR 0 2
36658: ARRAY
36659: IFFALSE 36716
// begin tmp := mc_attack [ i ] [ 1 ] ;
36661: LD_ADDR_VAR 0 3
36665: PUSH
36666: LD_EXP 113
36670: PUSH
36671: LD_VAR 0 2
36675: ARRAY
36676: PUSH
36677: LD_INT 1
36679: ARRAY
36680: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36681: LD_ADDR_EXP 113
36685: PUSH
36686: LD_EXP 113
36690: PPUSH
36691: LD_VAR 0 2
36695: PPUSH
36696: EMPTY
36697: PPUSH
36698: CALL_OW 1
36702: ST_TO_ADDR
// Attack ( tmp ) ;
36703: LD_VAR 0 3
36707: PPUSH
36708: CALL 108230 0 1
// exit ;
36712: POP
36713: POP
36714: GO 36720
// end ; end ;
36716: GO 36646
36718: POP
36719: POP
// end ;
36720: LD_VAR 0 1
36724: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36725: LD_INT 0
36727: PPUSH
36728: PPUSH
36729: PPUSH
36730: PPUSH
36731: PPUSH
36732: PPUSH
36733: PPUSH
// if not mc_bases then
36734: LD_EXP 93
36738: NOT
36739: IFFALSE 36743
// exit ;
36741: GO 37600
// for i = 1 to mc_bases do
36743: LD_ADDR_VAR 0 2
36747: PUSH
36748: DOUBLE
36749: LD_INT 1
36751: DEC
36752: ST_TO_ADDR
36753: LD_EXP 93
36757: PUSH
36758: FOR_TO
36759: IFFALSE 37598
// begin if not mc_bases [ i ] then
36761: LD_EXP 93
36765: PUSH
36766: LD_VAR 0 2
36770: ARRAY
36771: NOT
36772: IFFALSE 36776
// continue ;
36774: GO 36758
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36776: LD_ADDR_VAR 0 7
36780: PUSH
36781: LD_EXP 93
36785: PUSH
36786: LD_VAR 0 2
36790: ARRAY
36791: PUSH
36792: LD_INT 1
36794: ARRAY
36795: PPUSH
36796: CALL 53274 0 1
36800: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36801: LD_ADDR_EXP 116
36805: PUSH
36806: LD_EXP 116
36810: PPUSH
36811: LD_VAR 0 2
36815: PPUSH
36816: LD_EXP 93
36820: PUSH
36821: LD_VAR 0 2
36825: ARRAY
36826: PUSH
36827: LD_INT 1
36829: ARRAY
36830: PPUSH
36831: CALL_OW 255
36835: PPUSH
36836: LD_EXP 118
36840: PUSH
36841: LD_VAR 0 2
36845: ARRAY
36846: PPUSH
36847: CALL 53239 0 2
36851: PPUSH
36852: CALL_OW 1
36856: ST_TO_ADDR
// if not mc_scan [ i ] then
36857: LD_EXP 116
36861: PUSH
36862: LD_VAR 0 2
36866: ARRAY
36867: NOT
36868: IFFALSE 37046
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
36870: LD_ADDR_EXP 136
36874: PUSH
36875: LD_EXP 136
36879: PPUSH
36880: LD_VAR 0 2
36884: PPUSH
36885: LD_INT 0
36887: PPUSH
36888: CALL_OW 1
36892: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36893: LD_ADDR_VAR 0 4
36897: PUSH
36898: LD_EXP 93
36902: PUSH
36903: LD_VAR 0 2
36907: ARRAY
36908: PPUSH
36909: LD_INT 2
36911: PUSH
36912: LD_INT 25
36914: PUSH
36915: LD_INT 5
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: PUSH
36922: LD_INT 25
36924: PUSH
36925: LD_INT 8
36927: PUSH
36928: EMPTY
36929: LIST
36930: LIST
36931: PUSH
36932: LD_INT 25
36934: PUSH
36935: LD_INT 9
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: PPUSH
36948: CALL_OW 72
36952: ST_TO_ADDR
// if not tmp then
36953: LD_VAR 0 4
36957: NOT
36958: IFFALSE 36962
// continue ;
36960: GO 36758
// for j in tmp do
36962: LD_ADDR_VAR 0 3
36966: PUSH
36967: LD_VAR 0 4
36971: PUSH
36972: FOR_IN
36973: IFFALSE 37044
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36975: LD_VAR 0 3
36979: PPUSH
36980: CALL_OW 310
36984: PPUSH
36985: CALL_OW 266
36989: PUSH
36990: LD_INT 5
36992: EQUAL
36993: PUSH
36994: LD_VAR 0 3
36998: PPUSH
36999: CALL_OW 257
37003: PUSH
37004: LD_INT 1
37006: EQUAL
37007: AND
37008: PUSH
37009: LD_VAR 0 3
37013: PPUSH
37014: CALL_OW 459
37018: NOT
37019: AND
37020: PUSH
37021: LD_VAR 0 7
37025: AND
37026: IFFALSE 37042
// ComChangeProfession ( j , class ) ;
37028: LD_VAR 0 3
37032: PPUSH
37033: LD_VAR 0 7
37037: PPUSH
37038: CALL_OW 123
37042: GO 36972
37044: POP
37045: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37046: LD_EXP 116
37050: PUSH
37051: LD_VAR 0 2
37055: ARRAY
37056: PUSH
37057: LD_EXP 136
37061: PUSH
37062: LD_VAR 0 2
37066: ARRAY
37067: NOT
37068: AND
37069: PUSH
37070: LD_EXP 115
37074: PUSH
37075: LD_VAR 0 2
37079: ARRAY
37080: NOT
37081: AND
37082: PUSH
37083: LD_EXP 93
37087: PUSH
37088: LD_VAR 0 2
37092: ARRAY
37093: PPUSH
37094: LD_INT 50
37096: PUSH
37097: EMPTY
37098: LIST
37099: PUSH
37100: LD_INT 2
37102: PUSH
37103: LD_INT 30
37105: PUSH
37106: LD_INT 32
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 30
37115: PUSH
37116: LD_INT 33
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 30
37125: PUSH
37126: LD_INT 4
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 30
37135: PUSH
37136: LD_INT 5
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: LIST
37147: LIST
37148: LIST
37149: PUSH
37150: EMPTY
37151: LIST
37152: LIST
37153: PPUSH
37154: CALL_OW 72
37158: PUSH
37159: LD_INT 4
37161: LESS
37162: PUSH
37163: LD_EXP 93
37167: PUSH
37168: LD_VAR 0 2
37172: ARRAY
37173: PPUSH
37174: LD_INT 3
37176: PUSH
37177: LD_INT 24
37179: PUSH
37180: LD_INT 1000
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 2
37193: PUSH
37194: LD_INT 30
37196: PUSH
37197: LD_INT 0
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 30
37206: PUSH
37207: LD_INT 1
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: LIST
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PPUSH
37223: CALL_OW 72
37227: OR
37228: AND
37229: IFFALSE 37480
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37231: LD_ADDR_EXP 136
37235: PUSH
37236: LD_EXP 136
37240: PPUSH
37241: LD_VAR 0 2
37245: PPUSH
37246: LD_INT 1
37248: PPUSH
37249: CALL_OW 1
37253: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37254: LD_ADDR_VAR 0 4
37258: PUSH
37259: LD_EXP 93
37263: PUSH
37264: LD_VAR 0 2
37268: ARRAY
37269: PPUSH
37270: LD_INT 2
37272: PUSH
37273: LD_INT 25
37275: PUSH
37276: LD_INT 1
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 25
37285: PUSH
37286: LD_INT 5
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 25
37295: PUSH
37296: LD_INT 8
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 25
37305: PUSH
37306: LD_INT 9
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: PPUSH
37320: CALL_OW 72
37324: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37325: LD_ADDR_VAR 0 4
37329: PUSH
37330: LD_VAR 0 4
37334: PUSH
37335: LD_VAR 0 4
37339: PPUSH
37340: LD_INT 18
37342: PPUSH
37343: CALL 85743 0 2
37347: DIFF
37348: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37349: LD_VAR 0 4
37353: NOT
37354: PUSH
37355: LD_EXP 93
37359: PUSH
37360: LD_VAR 0 2
37364: ARRAY
37365: PPUSH
37366: LD_INT 2
37368: PUSH
37369: LD_INT 30
37371: PUSH
37372: LD_INT 4
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 30
37381: PUSH
37382: LD_INT 5
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: LIST
37393: PPUSH
37394: CALL_OW 72
37398: NOT
37399: AND
37400: IFFALSE 37462
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37402: LD_ADDR_VAR 0 4
37406: PUSH
37407: LD_EXP 93
37411: PUSH
37412: LD_VAR 0 2
37416: ARRAY
37417: PPUSH
37418: LD_INT 2
37420: PUSH
37421: LD_INT 25
37423: PUSH
37424: LD_INT 2
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: LD_INT 25
37433: PUSH
37434: LD_INT 3
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 25
37443: PUSH
37444: LD_INT 4
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: LIST
37455: LIST
37456: PPUSH
37457: CALL_OW 72
37461: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
37462: LD_VAR 0 2
37466: PPUSH
37467: LD_VAR 0 4
37471: PPUSH
37472: CALL 112939 0 2
// exit ;
37476: POP
37477: POP
37478: GO 37600
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37480: LD_EXP 116
37484: PUSH
37485: LD_VAR 0 2
37489: ARRAY
37490: PUSH
37491: LD_EXP 136
37495: PUSH
37496: LD_VAR 0 2
37500: ARRAY
37501: NOT
37502: AND
37503: PUSH
37504: LD_EXP 115
37508: PUSH
37509: LD_VAR 0 2
37513: ARRAY
37514: AND
37515: IFFALSE 37596
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37517: LD_ADDR_EXP 136
37521: PUSH
37522: LD_EXP 136
37526: PPUSH
37527: LD_VAR 0 2
37531: PPUSH
37532: LD_INT 1
37534: PPUSH
37535: CALL_OW 1
37539: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
37540: LD_ADDR_VAR 0 4
37544: PUSH
37545: LD_EXP 115
37549: PUSH
37550: LD_VAR 0 2
37554: ARRAY
37555: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37556: LD_ADDR_EXP 115
37560: PUSH
37561: LD_EXP 115
37565: PPUSH
37566: LD_VAR 0 2
37570: PPUSH
37571: EMPTY
37572: PPUSH
37573: CALL_OW 1
37577: ST_TO_ADDR
// Defend ( i , tmp ) ;
37578: LD_VAR 0 2
37582: PPUSH
37583: LD_VAR 0 4
37587: PPUSH
37588: CALL 113535 0 2
// exit ;
37592: POP
37593: POP
37594: GO 37600
// end ; end ;
37596: GO 36758
37598: POP
37599: POP
// end ;
37600: LD_VAR 0 1
37604: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37605: LD_INT 0
37607: PPUSH
37608: PPUSH
37609: PPUSH
37610: PPUSH
37611: PPUSH
37612: PPUSH
37613: PPUSH
37614: PPUSH
37615: PPUSH
37616: PPUSH
37617: PPUSH
// if not mc_bases then
37618: LD_EXP 93
37622: NOT
37623: IFFALSE 37627
// exit ;
37625: GO 38714
// for i = 1 to mc_bases do
37627: LD_ADDR_VAR 0 2
37631: PUSH
37632: DOUBLE
37633: LD_INT 1
37635: DEC
37636: ST_TO_ADDR
37637: LD_EXP 93
37641: PUSH
37642: FOR_TO
37643: IFFALSE 38712
// begin tmp := mc_lab [ i ] ;
37645: LD_ADDR_VAR 0 6
37649: PUSH
37650: LD_EXP 126
37654: PUSH
37655: LD_VAR 0 2
37659: ARRAY
37660: ST_TO_ADDR
// if not tmp then
37661: LD_VAR 0 6
37665: NOT
37666: IFFALSE 37670
// continue ;
37668: GO 37642
// idle_lab := 0 ;
37670: LD_ADDR_VAR 0 11
37674: PUSH
37675: LD_INT 0
37677: ST_TO_ADDR
// for j in tmp do
37678: LD_ADDR_VAR 0 3
37682: PUSH
37683: LD_VAR 0 6
37687: PUSH
37688: FOR_IN
37689: IFFALSE 38708
// begin researching := false ;
37691: LD_ADDR_VAR 0 10
37695: PUSH
37696: LD_INT 0
37698: ST_TO_ADDR
// side := GetSide ( j ) ;
37699: LD_ADDR_VAR 0 4
37703: PUSH
37704: LD_VAR 0 3
37708: PPUSH
37709: CALL_OW 255
37713: ST_TO_ADDR
// if not mc_tech [ side ] then
37714: LD_EXP 120
37718: PUSH
37719: LD_VAR 0 4
37723: ARRAY
37724: NOT
37725: IFFALSE 37729
// continue ;
37727: GO 37688
// if BuildingStatus ( j ) = bs_idle then
37729: LD_VAR 0 3
37733: PPUSH
37734: CALL_OW 461
37738: PUSH
37739: LD_INT 2
37741: EQUAL
37742: IFFALSE 37930
// begin if idle_lab and UnitsInside ( j ) < 6 then
37744: LD_VAR 0 11
37748: PUSH
37749: LD_VAR 0 3
37753: PPUSH
37754: CALL_OW 313
37758: PUSH
37759: LD_INT 6
37761: LESS
37762: AND
37763: IFFALSE 37834
// begin tmp2 := UnitsInside ( idle_lab ) ;
37765: LD_ADDR_VAR 0 9
37769: PUSH
37770: LD_VAR 0 11
37774: PPUSH
37775: CALL_OW 313
37779: ST_TO_ADDR
// if tmp2 then
37780: LD_VAR 0 9
37784: IFFALSE 37826
// for x in tmp2 do
37786: LD_ADDR_VAR 0 7
37790: PUSH
37791: LD_VAR 0 9
37795: PUSH
37796: FOR_IN
37797: IFFALSE 37824
// begin ComExitBuilding ( x ) ;
37799: LD_VAR 0 7
37803: PPUSH
37804: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37808: LD_VAR 0 7
37812: PPUSH
37813: LD_VAR 0 3
37817: PPUSH
37818: CALL_OW 180
// end ;
37822: GO 37796
37824: POP
37825: POP
// idle_lab := 0 ;
37826: LD_ADDR_VAR 0 11
37830: PUSH
37831: LD_INT 0
37833: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37834: LD_ADDR_VAR 0 5
37838: PUSH
37839: LD_EXP 120
37843: PUSH
37844: LD_VAR 0 4
37848: ARRAY
37849: PUSH
37850: FOR_IN
37851: IFFALSE 37911
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37853: LD_VAR 0 3
37857: PPUSH
37858: LD_VAR 0 5
37862: PPUSH
37863: CALL_OW 430
37867: PUSH
37868: LD_VAR 0 4
37872: PPUSH
37873: LD_VAR 0 5
37877: PPUSH
37878: CALL 52344 0 2
37882: AND
37883: IFFALSE 37909
// begin researching := true ;
37885: LD_ADDR_VAR 0 10
37889: PUSH
37890: LD_INT 1
37892: ST_TO_ADDR
// ComResearch ( j , t ) ;
37893: LD_VAR 0 3
37897: PPUSH
37898: LD_VAR 0 5
37902: PPUSH
37903: CALL_OW 124
// break ;
37907: GO 37911
// end ;
37909: GO 37850
37911: POP
37912: POP
// if not researching then
37913: LD_VAR 0 10
37917: NOT
37918: IFFALSE 37930
// idle_lab := j ;
37920: LD_ADDR_VAR 0 11
37924: PUSH
37925: LD_VAR 0 3
37929: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37930: LD_VAR 0 3
37934: PPUSH
37935: CALL_OW 461
37939: PUSH
37940: LD_INT 10
37942: EQUAL
37943: IFFALSE 38531
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37945: LD_EXP 122
37949: PUSH
37950: LD_VAR 0 2
37954: ARRAY
37955: NOT
37956: PUSH
37957: LD_EXP 123
37961: PUSH
37962: LD_VAR 0 2
37966: ARRAY
37967: NOT
37968: AND
37969: PUSH
37970: LD_EXP 120
37974: PUSH
37975: LD_VAR 0 4
37979: ARRAY
37980: PUSH
37981: LD_INT 1
37983: GREATER
37984: AND
37985: IFFALSE 38116
// begin ComCancel ( j ) ;
37987: LD_VAR 0 3
37991: PPUSH
37992: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37996: LD_ADDR_EXP 120
38000: PUSH
38001: LD_EXP 120
38005: PPUSH
38006: LD_VAR 0 4
38010: PPUSH
38011: LD_EXP 120
38015: PUSH
38016: LD_VAR 0 4
38020: ARRAY
38021: PPUSH
38022: LD_EXP 120
38026: PUSH
38027: LD_VAR 0 4
38031: ARRAY
38032: PUSH
38033: LD_INT 1
38035: MINUS
38036: PPUSH
38037: LD_EXP 120
38041: PUSH
38042: LD_VAR 0 4
38046: ARRAY
38047: PPUSH
38048: LD_INT 0
38050: PPUSH
38051: CALL 55892 0 4
38055: PPUSH
38056: CALL_OW 1
38060: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38061: LD_ADDR_EXP 120
38065: PUSH
38066: LD_EXP 120
38070: PPUSH
38071: LD_VAR 0 4
38075: PPUSH
38076: LD_EXP 120
38080: PUSH
38081: LD_VAR 0 4
38085: ARRAY
38086: PPUSH
38087: LD_EXP 120
38091: PUSH
38092: LD_VAR 0 4
38096: ARRAY
38097: PPUSH
38098: LD_INT 1
38100: PPUSH
38101: LD_INT 0
38103: PPUSH
38104: CALL 55892 0 4
38108: PPUSH
38109: CALL_OW 1
38113: ST_TO_ADDR
// continue ;
38114: GO 37688
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38116: LD_EXP 122
38120: PUSH
38121: LD_VAR 0 2
38125: ARRAY
38126: PUSH
38127: LD_EXP 123
38131: PUSH
38132: LD_VAR 0 2
38136: ARRAY
38137: NOT
38138: AND
38139: IFFALSE 38266
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38141: LD_ADDR_EXP 123
38145: PUSH
38146: LD_EXP 123
38150: PPUSH
38151: LD_VAR 0 2
38155: PUSH
38156: LD_EXP 123
38160: PUSH
38161: LD_VAR 0 2
38165: ARRAY
38166: PUSH
38167: LD_INT 1
38169: PLUS
38170: PUSH
38171: EMPTY
38172: LIST
38173: LIST
38174: PPUSH
38175: LD_EXP 122
38179: PUSH
38180: LD_VAR 0 2
38184: ARRAY
38185: PUSH
38186: LD_INT 1
38188: ARRAY
38189: PPUSH
38190: CALL 56474 0 3
38194: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38195: LD_EXP 122
38199: PUSH
38200: LD_VAR 0 2
38204: ARRAY
38205: PUSH
38206: LD_INT 1
38208: ARRAY
38209: PPUSH
38210: LD_INT 112
38212: PPUSH
38213: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38217: LD_ADDR_VAR 0 9
38221: PUSH
38222: LD_EXP 122
38226: PUSH
38227: LD_VAR 0 2
38231: ARRAY
38232: PPUSH
38233: LD_INT 1
38235: PPUSH
38236: CALL_OW 3
38240: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38241: LD_ADDR_EXP 122
38245: PUSH
38246: LD_EXP 122
38250: PPUSH
38251: LD_VAR 0 2
38255: PPUSH
38256: LD_VAR 0 9
38260: PPUSH
38261: CALL_OW 1
38265: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38266: LD_EXP 122
38270: PUSH
38271: LD_VAR 0 2
38275: ARRAY
38276: PUSH
38277: LD_EXP 123
38281: PUSH
38282: LD_VAR 0 2
38286: ARRAY
38287: AND
38288: PUSH
38289: LD_EXP 123
38293: PUSH
38294: LD_VAR 0 2
38298: ARRAY
38299: PUSH
38300: LD_INT 1
38302: ARRAY
38303: PPUSH
38304: CALL_OW 310
38308: NOT
38309: AND
38310: PUSH
38311: LD_VAR 0 3
38315: PPUSH
38316: CALL_OW 313
38320: PUSH
38321: LD_INT 6
38323: EQUAL
38324: AND
38325: IFFALSE 38381
// begin tmp2 := UnitsInside ( j ) ;
38327: LD_ADDR_VAR 0 9
38331: PUSH
38332: LD_VAR 0 3
38336: PPUSH
38337: CALL_OW 313
38341: ST_TO_ADDR
// if tmp2 = 6 then
38342: LD_VAR 0 9
38346: PUSH
38347: LD_INT 6
38349: EQUAL
38350: IFFALSE 38381
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38352: LD_VAR 0 9
38356: PUSH
38357: LD_INT 1
38359: ARRAY
38360: PPUSH
38361: LD_INT 112
38363: PPUSH
38364: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38368: LD_VAR 0 9
38372: PUSH
38373: LD_INT 1
38375: ARRAY
38376: PPUSH
38377: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38381: LD_EXP 123
38385: PUSH
38386: LD_VAR 0 2
38390: ARRAY
38391: PUSH
38392: LD_EXP 123
38396: PUSH
38397: LD_VAR 0 2
38401: ARRAY
38402: PUSH
38403: LD_INT 1
38405: ARRAY
38406: PPUSH
38407: CALL_OW 314
38411: NOT
38412: AND
38413: PUSH
38414: LD_EXP 123
38418: PUSH
38419: LD_VAR 0 2
38423: ARRAY
38424: PUSH
38425: LD_INT 1
38427: ARRAY
38428: PPUSH
38429: CALL_OW 310
38433: NOT
38434: AND
38435: IFFALSE 38461
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38437: LD_EXP 123
38441: PUSH
38442: LD_VAR 0 2
38446: ARRAY
38447: PUSH
38448: LD_INT 1
38450: ARRAY
38451: PPUSH
38452: LD_VAR 0 3
38456: PPUSH
38457: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38461: LD_EXP 123
38465: PUSH
38466: LD_VAR 0 2
38470: ARRAY
38471: PUSH
38472: LD_INT 1
38474: ARRAY
38475: PPUSH
38476: CALL_OW 310
38480: PUSH
38481: LD_EXP 123
38485: PUSH
38486: LD_VAR 0 2
38490: ARRAY
38491: PUSH
38492: LD_INT 1
38494: ARRAY
38495: PPUSH
38496: CALL_OW 310
38500: PPUSH
38501: CALL_OW 461
38505: PUSH
38506: LD_INT 3
38508: NONEQUAL
38509: AND
38510: IFFALSE 38531
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
38512: LD_EXP 123
38516: PUSH
38517: LD_VAR 0 2
38521: ARRAY
38522: PUSH
38523: LD_INT 1
38525: ARRAY
38526: PPUSH
38527: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
38531: LD_VAR 0 3
38535: PPUSH
38536: CALL_OW 461
38540: PUSH
38541: LD_INT 6
38543: EQUAL
38544: PUSH
38545: LD_VAR 0 6
38549: PUSH
38550: LD_INT 1
38552: GREATER
38553: AND
38554: IFFALSE 38706
// begin sci := [ ] ;
38556: LD_ADDR_VAR 0 8
38560: PUSH
38561: EMPTY
38562: ST_TO_ADDR
// for x in ( tmp diff j ) do
38563: LD_ADDR_VAR 0 7
38567: PUSH
38568: LD_VAR 0 6
38572: PUSH
38573: LD_VAR 0 3
38577: DIFF
38578: PUSH
38579: FOR_IN
38580: IFFALSE 38632
// begin if sci = 6 then
38582: LD_VAR 0 8
38586: PUSH
38587: LD_INT 6
38589: EQUAL
38590: IFFALSE 38594
// break ;
38592: GO 38632
// if BuildingStatus ( x ) = bs_idle then
38594: LD_VAR 0 7
38598: PPUSH
38599: CALL_OW 461
38603: PUSH
38604: LD_INT 2
38606: EQUAL
38607: IFFALSE 38630
// sci := sci ^ UnitsInside ( x ) ;
38609: LD_ADDR_VAR 0 8
38613: PUSH
38614: LD_VAR 0 8
38618: PUSH
38619: LD_VAR 0 7
38623: PPUSH
38624: CALL_OW 313
38628: ADD
38629: ST_TO_ADDR
// end ;
38630: GO 38579
38632: POP
38633: POP
// if not sci then
38634: LD_VAR 0 8
38638: NOT
38639: IFFALSE 38643
// continue ;
38641: GO 37688
// for x in sci do
38643: LD_ADDR_VAR 0 7
38647: PUSH
38648: LD_VAR 0 8
38652: PUSH
38653: FOR_IN
38654: IFFALSE 38704
// if IsInUnit ( x ) and not HasTask ( x ) then
38656: LD_VAR 0 7
38660: PPUSH
38661: CALL_OW 310
38665: PUSH
38666: LD_VAR 0 7
38670: PPUSH
38671: CALL_OW 314
38675: NOT
38676: AND
38677: IFFALSE 38702
// begin ComExitBuilding ( x ) ;
38679: LD_VAR 0 7
38683: PPUSH
38684: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38688: LD_VAR 0 7
38692: PPUSH
38693: LD_VAR 0 3
38697: PPUSH
38698: CALL_OW 180
// end ;
38702: GO 38653
38704: POP
38705: POP
// end ; end ;
38706: GO 37688
38708: POP
38709: POP
// end ;
38710: GO 37642
38712: POP
38713: POP
// end ;
38714: LD_VAR 0 1
38718: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38719: LD_INT 0
38721: PPUSH
38722: PPUSH
// if not mc_bases then
38723: LD_EXP 93
38727: NOT
38728: IFFALSE 38732
// exit ;
38730: GO 38813
// for i = 1 to mc_bases do
38732: LD_ADDR_VAR 0 2
38736: PUSH
38737: DOUBLE
38738: LD_INT 1
38740: DEC
38741: ST_TO_ADDR
38742: LD_EXP 93
38746: PUSH
38747: FOR_TO
38748: IFFALSE 38811
// if mc_mines [ i ] and mc_miners [ i ] then
38750: LD_EXP 106
38754: PUSH
38755: LD_VAR 0 2
38759: ARRAY
38760: PUSH
38761: LD_EXP 107
38765: PUSH
38766: LD_VAR 0 2
38770: ARRAY
38771: AND
38772: IFFALSE 38809
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38774: LD_EXP 107
38778: PUSH
38779: LD_VAR 0 2
38783: ARRAY
38784: PUSH
38785: LD_INT 1
38787: ARRAY
38788: PPUSH
38789: CALL_OW 255
38793: PPUSH
38794: LD_EXP 106
38798: PUSH
38799: LD_VAR 0 2
38803: ARRAY
38804: PPUSH
38805: CALL 53427 0 2
38809: GO 38747
38811: POP
38812: POP
// end ;
38813: LD_VAR 0 1
38817: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38818: LD_INT 0
38820: PPUSH
38821: PPUSH
38822: PPUSH
38823: PPUSH
38824: PPUSH
38825: PPUSH
38826: PPUSH
38827: PPUSH
// if not mc_bases or not mc_parking then
38828: LD_EXP 93
38832: NOT
38833: PUSH
38834: LD_EXP 117
38838: NOT
38839: OR
38840: IFFALSE 38844
// exit ;
38842: GO 39554
// for i = 1 to mc_bases do
38844: LD_ADDR_VAR 0 2
38848: PUSH
38849: DOUBLE
38850: LD_INT 1
38852: DEC
38853: ST_TO_ADDR
38854: LD_EXP 93
38858: PUSH
38859: FOR_TO
38860: IFFALSE 39552
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38862: LD_EXP 93
38866: PUSH
38867: LD_VAR 0 2
38871: ARRAY
38872: NOT
38873: PUSH
38874: LD_EXP 117
38878: PUSH
38879: LD_VAR 0 2
38883: ARRAY
38884: NOT
38885: OR
38886: IFFALSE 38890
// continue ;
38888: GO 38859
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38890: LD_ADDR_VAR 0 5
38894: PUSH
38895: LD_EXP 93
38899: PUSH
38900: LD_VAR 0 2
38904: ARRAY
38905: PUSH
38906: LD_INT 1
38908: ARRAY
38909: PPUSH
38910: CALL_OW 255
38914: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38915: LD_ADDR_VAR 0 6
38919: PUSH
38920: LD_EXP 93
38924: PUSH
38925: LD_VAR 0 2
38929: ARRAY
38930: PPUSH
38931: LD_INT 30
38933: PUSH
38934: LD_INT 3
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PPUSH
38941: CALL_OW 72
38945: ST_TO_ADDR
// if not fac then
38946: LD_VAR 0 6
38950: NOT
38951: IFFALSE 39002
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38953: LD_ADDR_VAR 0 6
38957: PUSH
38958: LD_EXP 93
38962: PUSH
38963: LD_VAR 0 2
38967: ARRAY
38968: PPUSH
38969: LD_INT 2
38971: PUSH
38972: LD_INT 30
38974: PUSH
38975: LD_INT 0
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 30
38984: PUSH
38985: LD_INT 1
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: LIST
38996: PPUSH
38997: CALL_OW 72
39001: ST_TO_ADDR
// if not fac then
39002: LD_VAR 0 6
39006: NOT
39007: IFFALSE 39011
// continue ;
39009: GO 38859
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39011: LD_ADDR_VAR 0 7
39015: PUSH
39016: LD_EXP 117
39020: PUSH
39021: LD_VAR 0 2
39025: ARRAY
39026: PPUSH
39027: LD_INT 22
39029: PUSH
39030: LD_VAR 0 5
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 21
39041: PUSH
39042: LD_INT 2
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: LD_INT 3
39051: PUSH
39052: LD_INT 24
39054: PUSH
39055: LD_INT 1000
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: LIST
39070: PPUSH
39071: CALL_OW 70
39075: ST_TO_ADDR
// for j in fac do
39076: LD_ADDR_VAR 0 3
39080: PUSH
39081: LD_VAR 0 6
39085: PUSH
39086: FOR_IN
39087: IFFALSE 39168
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39089: LD_ADDR_VAR 0 7
39093: PUSH
39094: LD_VAR 0 7
39098: PUSH
39099: LD_INT 22
39101: PUSH
39102: LD_VAR 0 5
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 91
39113: PUSH
39114: LD_VAR 0 3
39118: PUSH
39119: LD_INT 15
39121: PUSH
39122: EMPTY
39123: LIST
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 21
39129: PUSH
39130: LD_INT 2
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 3
39139: PUSH
39140: LD_INT 24
39142: PUSH
39143: LD_INT 1000
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: LIST
39158: LIST
39159: PPUSH
39160: CALL_OW 69
39164: UNION
39165: ST_TO_ADDR
39166: GO 39086
39168: POP
39169: POP
// if not vehs then
39170: LD_VAR 0 7
39174: NOT
39175: IFFALSE 39201
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39177: LD_ADDR_EXP 105
39181: PUSH
39182: LD_EXP 105
39186: PPUSH
39187: LD_VAR 0 2
39191: PPUSH
39192: EMPTY
39193: PPUSH
39194: CALL_OW 1
39198: ST_TO_ADDR
// continue ;
39199: GO 38859
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39201: LD_ADDR_VAR 0 8
39205: PUSH
39206: LD_EXP 93
39210: PUSH
39211: LD_VAR 0 2
39215: ARRAY
39216: PPUSH
39217: LD_INT 30
39219: PUSH
39220: LD_INT 3
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PPUSH
39227: CALL_OW 72
39231: ST_TO_ADDR
// if tmp then
39232: LD_VAR 0 8
39236: IFFALSE 39339
// begin for j in tmp do
39238: LD_ADDR_VAR 0 3
39242: PUSH
39243: LD_VAR 0 8
39247: PUSH
39248: FOR_IN
39249: IFFALSE 39337
// for k in UnitsInside ( j ) do
39251: LD_ADDR_VAR 0 4
39255: PUSH
39256: LD_VAR 0 3
39260: PPUSH
39261: CALL_OW 313
39265: PUSH
39266: FOR_IN
39267: IFFALSE 39333
// if k then
39269: LD_VAR 0 4
39273: IFFALSE 39331
// if not k in mc_repair_vehicle [ i ] then
39275: LD_VAR 0 4
39279: PUSH
39280: LD_EXP 105
39284: PUSH
39285: LD_VAR 0 2
39289: ARRAY
39290: IN
39291: NOT
39292: IFFALSE 39331
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39294: LD_ADDR_EXP 105
39298: PUSH
39299: LD_EXP 105
39303: PPUSH
39304: LD_VAR 0 2
39308: PPUSH
39309: LD_EXP 105
39313: PUSH
39314: LD_VAR 0 2
39318: ARRAY
39319: PUSH
39320: LD_VAR 0 4
39324: UNION
39325: PPUSH
39326: CALL_OW 1
39330: ST_TO_ADDR
39331: GO 39266
39333: POP
39334: POP
39335: GO 39248
39337: POP
39338: POP
// end ; if not mc_repair_vehicle [ i ] then
39339: LD_EXP 105
39343: PUSH
39344: LD_VAR 0 2
39348: ARRAY
39349: NOT
39350: IFFALSE 39354
// continue ;
39352: GO 38859
// for j in mc_repair_vehicle [ i ] do
39354: LD_ADDR_VAR 0 3
39358: PUSH
39359: LD_EXP 105
39363: PUSH
39364: LD_VAR 0 2
39368: ARRAY
39369: PUSH
39370: FOR_IN
39371: IFFALSE 39548
// begin if GetClass ( j ) <> 3 then
39373: LD_VAR 0 3
39377: PPUSH
39378: CALL_OW 257
39382: PUSH
39383: LD_INT 3
39385: NONEQUAL
39386: IFFALSE 39427
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39388: LD_ADDR_EXP 105
39392: PUSH
39393: LD_EXP 105
39397: PPUSH
39398: LD_VAR 0 2
39402: PPUSH
39403: LD_EXP 105
39407: PUSH
39408: LD_VAR 0 2
39412: ARRAY
39413: PUSH
39414: LD_VAR 0 3
39418: DIFF
39419: PPUSH
39420: CALL_OW 1
39424: ST_TO_ADDR
// continue ;
39425: GO 39370
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39427: LD_VAR 0 3
39431: PPUSH
39432: CALL_OW 311
39436: NOT
39437: PUSH
39438: LD_VAR 0 3
39442: PUSH
39443: LD_EXP 96
39447: PUSH
39448: LD_VAR 0 2
39452: ARRAY
39453: PUSH
39454: LD_INT 1
39456: ARRAY
39457: IN
39458: NOT
39459: AND
39460: PUSH
39461: LD_VAR 0 3
39465: PUSH
39466: LD_EXP 96
39470: PUSH
39471: LD_VAR 0 2
39475: ARRAY
39476: PUSH
39477: LD_INT 2
39479: ARRAY
39480: IN
39481: NOT
39482: AND
39483: IFFALSE 39546
// begin if IsInUnit ( j ) then
39485: LD_VAR 0 3
39489: PPUSH
39490: CALL_OW 310
39494: IFFALSE 39507
// ComExitBuilding ( j ) else
39496: LD_VAR 0 3
39500: PPUSH
39501: CALL_OW 122
39505: GO 39546
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
39507: LD_VAR 0 3
39511: PPUSH
39512: LD_VAR 0 7
39516: PUSH
39517: LD_INT 1
39519: ARRAY
39520: PPUSH
39521: CALL 90081 0 2
39525: NOT
39526: IFFALSE 39546
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
39528: LD_VAR 0 3
39532: PPUSH
39533: LD_VAR 0 7
39537: PUSH
39538: LD_INT 1
39540: ARRAY
39541: PPUSH
39542: CALL_OW 129
// end ; end ;
39546: GO 39370
39548: POP
39549: POP
// end ;
39550: GO 38859
39552: POP
39553: POP
// end ;
39554: LD_VAR 0 1
39558: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
39559: LD_INT 0
39561: PPUSH
39562: PPUSH
39563: PPUSH
39564: PPUSH
39565: PPUSH
39566: PPUSH
39567: PPUSH
39568: PPUSH
39569: PPUSH
39570: PPUSH
39571: PPUSH
// if not mc_bases then
39572: LD_EXP 93
39576: NOT
39577: IFFALSE 39581
// exit ;
39579: GO 40383
// for i = 1 to mc_bases do
39581: LD_ADDR_VAR 0 2
39585: PUSH
39586: DOUBLE
39587: LD_INT 1
39589: DEC
39590: ST_TO_ADDR
39591: LD_EXP 93
39595: PUSH
39596: FOR_TO
39597: IFFALSE 40381
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39599: LD_EXP 121
39603: PUSH
39604: LD_VAR 0 2
39608: ARRAY
39609: NOT
39610: PUSH
39611: LD_EXP 96
39615: PUSH
39616: LD_VAR 0 2
39620: ARRAY
39621: PUSH
39622: LD_INT 1
39624: ARRAY
39625: OR
39626: PUSH
39627: LD_EXP 96
39631: PUSH
39632: LD_VAR 0 2
39636: ARRAY
39637: PUSH
39638: LD_INT 2
39640: ARRAY
39641: OR
39642: PUSH
39643: LD_EXP 119
39647: PUSH
39648: LD_VAR 0 2
39652: ARRAY
39653: PPUSH
39654: LD_INT 1
39656: PPUSH
39657: CALL_OW 325
39661: NOT
39662: OR
39663: PUSH
39664: LD_EXP 116
39668: PUSH
39669: LD_VAR 0 2
39673: ARRAY
39674: OR
39675: IFFALSE 39679
// continue ;
39677: GO 39596
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39679: LD_ADDR_VAR 0 8
39683: PUSH
39684: LD_EXP 93
39688: PUSH
39689: LD_VAR 0 2
39693: ARRAY
39694: PPUSH
39695: LD_INT 25
39697: PUSH
39698: LD_INT 4
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 50
39707: PUSH
39708: EMPTY
39709: LIST
39710: PUSH
39711: LD_INT 3
39713: PUSH
39714: LD_INT 60
39716: PUSH
39717: EMPTY
39718: LIST
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: LIST
39728: PPUSH
39729: CALL_OW 72
39733: PUSH
39734: LD_EXP 97
39738: PUSH
39739: LD_VAR 0 2
39743: ARRAY
39744: DIFF
39745: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39746: LD_ADDR_VAR 0 9
39750: PUSH
39751: LD_EXP 93
39755: PUSH
39756: LD_VAR 0 2
39760: ARRAY
39761: PPUSH
39762: LD_INT 2
39764: PUSH
39765: LD_INT 30
39767: PUSH
39768: LD_INT 0
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 30
39777: PUSH
39778: LD_INT 1
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: LIST
39789: PPUSH
39790: CALL_OW 72
39794: ST_TO_ADDR
// if not tmp or not dep then
39795: LD_VAR 0 8
39799: NOT
39800: PUSH
39801: LD_VAR 0 9
39805: NOT
39806: OR
39807: IFFALSE 39811
// continue ;
39809: GO 39596
// side := GetSide ( tmp [ 1 ] ) ;
39811: LD_ADDR_VAR 0 11
39815: PUSH
39816: LD_VAR 0 8
39820: PUSH
39821: LD_INT 1
39823: ARRAY
39824: PPUSH
39825: CALL_OW 255
39829: ST_TO_ADDR
// dep := dep [ 1 ] ;
39830: LD_ADDR_VAR 0 9
39834: PUSH
39835: LD_VAR 0 9
39839: PUSH
39840: LD_INT 1
39842: ARRAY
39843: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39844: LD_ADDR_VAR 0 7
39848: PUSH
39849: LD_EXP 121
39853: PUSH
39854: LD_VAR 0 2
39858: ARRAY
39859: PPUSH
39860: LD_INT 22
39862: PUSH
39863: LD_INT 0
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 25
39872: PUSH
39873: LD_INT 12
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PPUSH
39884: CALL_OW 70
39888: PUSH
39889: LD_INT 22
39891: PUSH
39892: LD_INT 0
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 25
39901: PUSH
39902: LD_INT 12
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: PUSH
39909: LD_INT 91
39911: PUSH
39912: LD_VAR 0 9
39916: PUSH
39917: LD_INT 20
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: LIST
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: LIST
39929: PPUSH
39930: CALL_OW 69
39934: UNION
39935: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39936: LD_ADDR_VAR 0 10
39940: PUSH
39941: LD_EXP 121
39945: PUSH
39946: LD_VAR 0 2
39950: ARRAY
39951: PPUSH
39952: LD_INT 81
39954: PUSH
39955: LD_VAR 0 11
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PPUSH
39964: CALL_OW 70
39968: ST_TO_ADDR
// if not apes or danger_at_area then
39969: LD_VAR 0 7
39973: NOT
39974: PUSH
39975: LD_VAR 0 10
39979: OR
39980: IFFALSE 40030
// begin if mc_taming [ i ] then
39982: LD_EXP 124
39986: PUSH
39987: LD_VAR 0 2
39991: ARRAY
39992: IFFALSE 40028
// begin MC_Reset ( i , 121 ) ;
39994: LD_VAR 0 2
39998: PPUSH
39999: LD_INT 121
40001: PPUSH
40002: CALL 25016 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40006: LD_ADDR_EXP 124
40010: PUSH
40011: LD_EXP 124
40015: PPUSH
40016: LD_VAR 0 2
40020: PPUSH
40021: EMPTY
40022: PPUSH
40023: CALL_OW 1
40027: ST_TO_ADDR
// end ; continue ;
40028: GO 39596
// end ; for j in tmp do
40030: LD_ADDR_VAR 0 3
40034: PUSH
40035: LD_VAR 0 8
40039: PUSH
40040: FOR_IN
40041: IFFALSE 40377
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40043: LD_VAR 0 3
40047: PUSH
40048: LD_EXP 124
40052: PUSH
40053: LD_VAR 0 2
40057: ARRAY
40058: IN
40059: NOT
40060: PUSH
40061: LD_EXP 124
40065: PUSH
40066: LD_VAR 0 2
40070: ARRAY
40071: PUSH
40072: LD_INT 3
40074: LESS
40075: AND
40076: IFFALSE 40134
// begin SetTag ( j , 121 ) ;
40078: LD_VAR 0 3
40082: PPUSH
40083: LD_INT 121
40085: PPUSH
40086: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40090: LD_ADDR_EXP 124
40094: PUSH
40095: LD_EXP 124
40099: PPUSH
40100: LD_VAR 0 2
40104: PUSH
40105: LD_EXP 124
40109: PUSH
40110: LD_VAR 0 2
40114: ARRAY
40115: PUSH
40116: LD_INT 1
40118: PLUS
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PPUSH
40124: LD_VAR 0 3
40128: PPUSH
40129: CALL 56474 0 3
40133: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40134: LD_VAR 0 3
40138: PUSH
40139: LD_EXP 124
40143: PUSH
40144: LD_VAR 0 2
40148: ARRAY
40149: IN
40150: IFFALSE 40375
// begin if GetClass ( j ) <> 4 then
40152: LD_VAR 0 3
40156: PPUSH
40157: CALL_OW 257
40161: PUSH
40162: LD_INT 4
40164: NONEQUAL
40165: IFFALSE 40218
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40167: LD_ADDR_EXP 124
40171: PUSH
40172: LD_EXP 124
40176: PPUSH
40177: LD_VAR 0 2
40181: PPUSH
40182: LD_EXP 124
40186: PUSH
40187: LD_VAR 0 2
40191: ARRAY
40192: PUSH
40193: LD_VAR 0 3
40197: DIFF
40198: PPUSH
40199: CALL_OW 1
40203: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40204: LD_VAR 0 3
40208: PPUSH
40209: LD_INT 0
40211: PPUSH
40212: CALL_OW 109
// continue ;
40216: GO 40040
// end ; if IsInUnit ( j ) then
40218: LD_VAR 0 3
40222: PPUSH
40223: CALL_OW 310
40227: IFFALSE 40238
// ComExitBuilding ( j ) ;
40229: LD_VAR 0 3
40233: PPUSH
40234: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40238: LD_ADDR_VAR 0 6
40242: PUSH
40243: LD_VAR 0 7
40247: PPUSH
40248: LD_VAR 0 3
40252: PPUSH
40253: CALL_OW 74
40257: ST_TO_ADDR
// if not ape then
40258: LD_VAR 0 6
40262: NOT
40263: IFFALSE 40267
// break ;
40265: GO 40377
// x := GetX ( ape ) ;
40267: LD_ADDR_VAR 0 4
40271: PUSH
40272: LD_VAR 0 6
40276: PPUSH
40277: CALL_OW 250
40281: ST_TO_ADDR
// y := GetY ( ape ) ;
40282: LD_ADDR_VAR 0 5
40286: PUSH
40287: LD_VAR 0 6
40291: PPUSH
40292: CALL_OW 251
40296: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40297: LD_VAR 0 4
40301: PPUSH
40302: LD_VAR 0 5
40306: PPUSH
40307: CALL_OW 488
40311: NOT
40312: PUSH
40313: LD_VAR 0 11
40317: PPUSH
40318: LD_VAR 0 4
40322: PPUSH
40323: LD_VAR 0 5
40327: PPUSH
40328: LD_INT 20
40330: PPUSH
40331: CALL 57370 0 4
40335: PUSH
40336: LD_INT 4
40338: ARRAY
40339: OR
40340: IFFALSE 40344
// break ;
40342: GO 40377
// if not HasTask ( j ) then
40344: LD_VAR 0 3
40348: PPUSH
40349: CALL_OW 314
40353: NOT
40354: IFFALSE 40375
// ComTameXY ( j , x , y ) ;
40356: LD_VAR 0 3
40360: PPUSH
40361: LD_VAR 0 4
40365: PPUSH
40366: LD_VAR 0 5
40370: PPUSH
40371: CALL_OW 131
// end ; end ;
40375: GO 40040
40377: POP
40378: POP
// end ;
40379: GO 39596
40381: POP
40382: POP
// end ;
40383: LD_VAR 0 1
40387: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40388: LD_INT 0
40390: PPUSH
40391: PPUSH
40392: PPUSH
40393: PPUSH
40394: PPUSH
40395: PPUSH
40396: PPUSH
40397: PPUSH
// if not mc_bases then
40398: LD_EXP 93
40402: NOT
40403: IFFALSE 40407
// exit ;
40405: GO 41033
// for i = 1 to mc_bases do
40407: LD_ADDR_VAR 0 2
40411: PUSH
40412: DOUBLE
40413: LD_INT 1
40415: DEC
40416: ST_TO_ADDR
40417: LD_EXP 93
40421: PUSH
40422: FOR_TO
40423: IFFALSE 41031
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40425: LD_EXP 122
40429: PUSH
40430: LD_VAR 0 2
40434: ARRAY
40435: NOT
40436: PUSH
40437: LD_EXP 122
40441: PUSH
40442: LD_VAR 0 2
40446: ARRAY
40447: PPUSH
40448: LD_INT 25
40450: PUSH
40451: LD_INT 12
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PPUSH
40458: CALL_OW 72
40462: NOT
40463: OR
40464: IFFALSE 40468
// continue ;
40466: GO 40422
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40468: LD_ADDR_VAR 0 5
40472: PUSH
40473: LD_EXP 122
40477: PUSH
40478: LD_VAR 0 2
40482: ARRAY
40483: PUSH
40484: LD_INT 1
40486: ARRAY
40487: PPUSH
40488: CALL_OW 255
40492: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40493: LD_VAR 0 5
40497: PPUSH
40498: LD_INT 2
40500: PPUSH
40501: CALL_OW 325
40505: IFFALSE 40758
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40507: LD_ADDR_VAR 0 4
40511: PUSH
40512: LD_EXP 122
40516: PUSH
40517: LD_VAR 0 2
40521: ARRAY
40522: PPUSH
40523: LD_INT 25
40525: PUSH
40526: LD_INT 16
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PPUSH
40533: CALL_OW 72
40537: ST_TO_ADDR
// if tmp < 6 then
40538: LD_VAR 0 4
40542: PUSH
40543: LD_INT 6
40545: LESS
40546: IFFALSE 40758
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40548: LD_ADDR_VAR 0 6
40552: PUSH
40553: LD_EXP 93
40557: PUSH
40558: LD_VAR 0 2
40562: ARRAY
40563: PPUSH
40564: LD_INT 2
40566: PUSH
40567: LD_INT 30
40569: PUSH
40570: LD_INT 0
40572: PUSH
40573: EMPTY
40574: LIST
40575: LIST
40576: PUSH
40577: LD_INT 30
40579: PUSH
40580: LD_INT 1
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: LIST
40591: PPUSH
40592: CALL_OW 72
40596: ST_TO_ADDR
// if depot then
40597: LD_VAR 0 6
40601: IFFALSE 40758
// begin selected := 0 ;
40603: LD_ADDR_VAR 0 7
40607: PUSH
40608: LD_INT 0
40610: ST_TO_ADDR
// for j in depot do
40611: LD_ADDR_VAR 0 3
40615: PUSH
40616: LD_VAR 0 6
40620: PUSH
40621: FOR_IN
40622: IFFALSE 40653
// begin if UnitsInside ( j ) < 6 then
40624: LD_VAR 0 3
40628: PPUSH
40629: CALL_OW 313
40633: PUSH
40634: LD_INT 6
40636: LESS
40637: IFFALSE 40651
// begin selected := j ;
40639: LD_ADDR_VAR 0 7
40643: PUSH
40644: LD_VAR 0 3
40648: ST_TO_ADDR
// break ;
40649: GO 40653
// end ; end ;
40651: GO 40621
40653: POP
40654: POP
// if selected then
40655: LD_VAR 0 7
40659: IFFALSE 40758
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40661: LD_ADDR_VAR 0 3
40665: PUSH
40666: LD_EXP 122
40670: PUSH
40671: LD_VAR 0 2
40675: ARRAY
40676: PPUSH
40677: LD_INT 25
40679: PUSH
40680: LD_INT 12
40682: PUSH
40683: EMPTY
40684: LIST
40685: LIST
40686: PPUSH
40687: CALL_OW 72
40691: PUSH
40692: FOR_IN
40693: IFFALSE 40756
// if not HasTask ( j ) then
40695: LD_VAR 0 3
40699: PPUSH
40700: CALL_OW 314
40704: NOT
40705: IFFALSE 40754
// begin if not IsInUnit ( j ) then
40707: LD_VAR 0 3
40711: PPUSH
40712: CALL_OW 310
40716: NOT
40717: IFFALSE 40733
// ComEnterUnit ( j , selected ) ;
40719: LD_VAR 0 3
40723: PPUSH
40724: LD_VAR 0 7
40728: PPUSH
40729: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40733: LD_VAR 0 3
40737: PPUSH
40738: LD_INT 16
40740: PPUSH
40741: CALL_OW 183
// AddComExitBuilding ( j ) ;
40745: LD_VAR 0 3
40749: PPUSH
40750: CALL_OW 182
// end ;
40754: GO 40692
40756: POP
40757: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40758: LD_VAR 0 5
40762: PPUSH
40763: LD_INT 11
40765: PPUSH
40766: CALL_OW 325
40770: IFFALSE 41029
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40772: LD_ADDR_VAR 0 4
40776: PUSH
40777: LD_EXP 122
40781: PUSH
40782: LD_VAR 0 2
40786: ARRAY
40787: PPUSH
40788: LD_INT 25
40790: PUSH
40791: LD_INT 16
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PPUSH
40798: CALL_OW 72
40802: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40803: LD_VAR 0 4
40807: PUSH
40808: LD_INT 6
40810: GREATEREQUAL
40811: PUSH
40812: LD_VAR 0 5
40816: PPUSH
40817: LD_INT 2
40819: PPUSH
40820: CALL_OW 325
40824: NOT
40825: OR
40826: IFFALSE 41029
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40828: LD_ADDR_VAR 0 8
40832: PUSH
40833: LD_EXP 93
40837: PUSH
40838: LD_VAR 0 2
40842: ARRAY
40843: PPUSH
40844: LD_INT 2
40846: PUSH
40847: LD_INT 30
40849: PUSH
40850: LD_INT 4
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 30
40859: PUSH
40860: LD_INT 5
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: LIST
40871: PPUSH
40872: CALL_OW 72
40876: ST_TO_ADDR
// if barracks then
40877: LD_VAR 0 8
40881: IFFALSE 41029
// begin selected := 0 ;
40883: LD_ADDR_VAR 0 7
40887: PUSH
40888: LD_INT 0
40890: ST_TO_ADDR
// for j in barracks do
40891: LD_ADDR_VAR 0 3
40895: PUSH
40896: LD_VAR 0 8
40900: PUSH
40901: FOR_IN
40902: IFFALSE 40933
// begin if UnitsInside ( j ) < 6 then
40904: LD_VAR 0 3
40908: PPUSH
40909: CALL_OW 313
40913: PUSH
40914: LD_INT 6
40916: LESS
40917: IFFALSE 40931
// begin selected := j ;
40919: LD_ADDR_VAR 0 7
40923: PUSH
40924: LD_VAR 0 3
40928: ST_TO_ADDR
// break ;
40929: GO 40933
// end ; end ;
40931: GO 40901
40933: POP
40934: POP
// if selected then
40935: LD_VAR 0 7
40939: IFFALSE 41029
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40941: LD_ADDR_VAR 0 3
40945: PUSH
40946: LD_EXP 122
40950: PUSH
40951: LD_VAR 0 2
40955: ARRAY
40956: PPUSH
40957: LD_INT 25
40959: PUSH
40960: LD_INT 12
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PPUSH
40967: CALL_OW 72
40971: PUSH
40972: FOR_IN
40973: IFFALSE 41027
// if not IsInUnit ( j ) and not HasTask ( j ) then
40975: LD_VAR 0 3
40979: PPUSH
40980: CALL_OW 310
40984: NOT
40985: PUSH
40986: LD_VAR 0 3
40990: PPUSH
40991: CALL_OW 314
40995: NOT
40996: AND
40997: IFFALSE 41025
// begin ComEnterUnit ( j , selected ) ;
40999: LD_VAR 0 3
41003: PPUSH
41004: LD_VAR 0 7
41008: PPUSH
41009: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41013: LD_VAR 0 3
41017: PPUSH
41018: LD_INT 15
41020: PPUSH
41021: CALL_OW 183
// end ;
41025: GO 40972
41027: POP
41028: POP
// end ; end ; end ; end ; end ;
41029: GO 40422
41031: POP
41032: POP
// end ;
41033: LD_VAR 0 1
41037: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41038: LD_INT 0
41040: PPUSH
41041: PPUSH
41042: PPUSH
41043: PPUSH
// if not mc_bases then
41044: LD_EXP 93
41048: NOT
41049: IFFALSE 41053
// exit ;
41051: GO 41231
// for i = 1 to mc_bases do
41053: LD_ADDR_VAR 0 2
41057: PUSH
41058: DOUBLE
41059: LD_INT 1
41061: DEC
41062: ST_TO_ADDR
41063: LD_EXP 93
41067: PUSH
41068: FOR_TO
41069: IFFALSE 41229
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41071: LD_ADDR_VAR 0 4
41075: PUSH
41076: LD_EXP 93
41080: PUSH
41081: LD_VAR 0 2
41085: ARRAY
41086: PPUSH
41087: LD_INT 25
41089: PUSH
41090: LD_INT 9
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PPUSH
41097: CALL_OW 72
41101: ST_TO_ADDR
// if not tmp then
41102: LD_VAR 0 4
41106: NOT
41107: IFFALSE 41111
// continue ;
41109: GO 41068
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41111: LD_EXP 119
41115: PUSH
41116: LD_VAR 0 2
41120: ARRAY
41121: PPUSH
41122: LD_INT 29
41124: PPUSH
41125: CALL_OW 325
41129: NOT
41130: PUSH
41131: LD_EXP 119
41135: PUSH
41136: LD_VAR 0 2
41140: ARRAY
41141: PPUSH
41142: LD_INT 28
41144: PPUSH
41145: CALL_OW 325
41149: NOT
41150: AND
41151: IFFALSE 41155
// continue ;
41153: GO 41068
// for j in tmp do
41155: LD_ADDR_VAR 0 3
41159: PUSH
41160: LD_VAR 0 4
41164: PUSH
41165: FOR_IN
41166: IFFALSE 41225
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41168: LD_VAR 0 3
41172: PUSH
41173: LD_EXP 96
41177: PUSH
41178: LD_VAR 0 2
41182: ARRAY
41183: PUSH
41184: LD_INT 1
41186: ARRAY
41187: IN
41188: NOT
41189: PUSH
41190: LD_VAR 0 3
41194: PUSH
41195: LD_EXP 96
41199: PUSH
41200: LD_VAR 0 2
41204: ARRAY
41205: PUSH
41206: LD_INT 2
41208: ARRAY
41209: IN
41210: NOT
41211: AND
41212: IFFALSE 41223
// ComSpaceTimeShoot ( j ) ;
41214: LD_VAR 0 3
41218: PPUSH
41219: CALL 52435 0 1
41223: GO 41165
41225: POP
41226: POP
// end ;
41227: GO 41068
41229: POP
41230: POP
// end ;
41231: LD_VAR 0 1
41235: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41236: LD_INT 0
41238: PPUSH
41239: PPUSH
41240: PPUSH
41241: PPUSH
41242: PPUSH
41243: PPUSH
41244: PPUSH
41245: PPUSH
41246: PPUSH
// if not mc_bases then
41247: LD_EXP 93
41251: NOT
41252: IFFALSE 41256
// exit ;
41254: GO 41878
// for i = 1 to mc_bases do
41256: LD_ADDR_VAR 0 2
41260: PUSH
41261: DOUBLE
41262: LD_INT 1
41264: DEC
41265: ST_TO_ADDR
41266: LD_EXP 93
41270: PUSH
41271: FOR_TO
41272: IFFALSE 41876
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41274: LD_EXP 128
41278: PUSH
41279: LD_VAR 0 2
41283: ARRAY
41284: NOT
41285: PUSH
41286: LD_INT 38
41288: PPUSH
41289: LD_EXP 119
41293: PUSH
41294: LD_VAR 0 2
41298: ARRAY
41299: PPUSH
41300: CALL_OW 321
41304: PUSH
41305: LD_INT 2
41307: NONEQUAL
41308: OR
41309: IFFALSE 41313
// continue ;
41311: GO 41271
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41313: LD_ADDR_VAR 0 8
41317: PUSH
41318: LD_EXP 93
41322: PUSH
41323: LD_VAR 0 2
41327: ARRAY
41328: PPUSH
41329: LD_INT 30
41331: PUSH
41332: LD_INT 34
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PPUSH
41339: CALL_OW 72
41343: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41344: LD_ADDR_VAR 0 9
41348: PUSH
41349: LD_EXP 93
41353: PUSH
41354: LD_VAR 0 2
41358: ARRAY
41359: PPUSH
41360: LD_INT 25
41362: PUSH
41363: LD_INT 4
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PPUSH
41370: CALL_OW 72
41374: PPUSH
41375: LD_INT 0
41377: PPUSH
41378: CALL 85743 0 2
41382: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41383: LD_VAR 0 9
41387: NOT
41388: PUSH
41389: LD_VAR 0 8
41393: NOT
41394: OR
41395: PUSH
41396: LD_EXP 93
41400: PUSH
41401: LD_VAR 0 2
41405: ARRAY
41406: PPUSH
41407: LD_INT 124
41409: PPUSH
41410: CALL 85743 0 2
41414: OR
41415: IFFALSE 41419
// continue ;
41417: GO 41271
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41419: LD_EXP 129
41423: PUSH
41424: LD_VAR 0 2
41428: ARRAY
41429: PUSH
41430: LD_EXP 128
41434: PUSH
41435: LD_VAR 0 2
41439: ARRAY
41440: LESS
41441: PUSH
41442: LD_EXP 129
41446: PUSH
41447: LD_VAR 0 2
41451: ARRAY
41452: PUSH
41453: LD_VAR 0 8
41457: LESS
41458: AND
41459: IFFALSE 41874
// begin tmp := sci [ 1 ] ;
41461: LD_ADDR_VAR 0 7
41465: PUSH
41466: LD_VAR 0 9
41470: PUSH
41471: LD_INT 1
41473: ARRAY
41474: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41475: LD_VAR 0 7
41479: PPUSH
41480: LD_INT 124
41482: PPUSH
41483: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41487: LD_ADDR_VAR 0 3
41491: PUSH
41492: DOUBLE
41493: LD_EXP 128
41497: PUSH
41498: LD_VAR 0 2
41502: ARRAY
41503: INC
41504: ST_TO_ADDR
41505: LD_EXP 128
41509: PUSH
41510: LD_VAR 0 2
41514: ARRAY
41515: PUSH
41516: FOR_DOWNTO
41517: IFFALSE 41860
// begin if IsInUnit ( tmp ) then
41519: LD_VAR 0 7
41523: PPUSH
41524: CALL_OW 310
41528: IFFALSE 41539
// ComExitBuilding ( tmp ) ;
41530: LD_VAR 0 7
41534: PPUSH
41535: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
41539: LD_INT 35
41541: PPUSH
41542: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
41546: LD_VAR 0 7
41550: PPUSH
41551: CALL_OW 310
41555: NOT
41556: PUSH
41557: LD_VAR 0 7
41561: PPUSH
41562: CALL_OW 314
41566: NOT
41567: AND
41568: IFFALSE 41539
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
41570: LD_ADDR_VAR 0 6
41574: PUSH
41575: LD_VAR 0 7
41579: PPUSH
41580: CALL_OW 250
41584: PUSH
41585: LD_VAR 0 7
41589: PPUSH
41590: CALL_OW 251
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41599: LD_INT 35
41601: PPUSH
41602: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41606: LD_ADDR_VAR 0 4
41610: PUSH
41611: LD_EXP 128
41615: PUSH
41616: LD_VAR 0 2
41620: ARRAY
41621: PUSH
41622: LD_VAR 0 3
41626: ARRAY
41627: PUSH
41628: LD_INT 1
41630: ARRAY
41631: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
41632: LD_ADDR_VAR 0 5
41636: PUSH
41637: LD_EXP 128
41641: PUSH
41642: LD_VAR 0 2
41646: ARRAY
41647: PUSH
41648: LD_VAR 0 3
41652: ARRAY
41653: PUSH
41654: LD_INT 2
41656: ARRAY
41657: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
41658: LD_VAR 0 7
41662: PPUSH
41663: LD_INT 10
41665: PPUSH
41666: CALL 59073 0 2
41670: PUSH
41671: LD_INT 4
41673: ARRAY
41674: IFFALSE 41712
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41676: LD_VAR 0 7
41680: PPUSH
41681: LD_VAR 0 6
41685: PUSH
41686: LD_INT 1
41688: ARRAY
41689: PPUSH
41690: LD_VAR 0 6
41694: PUSH
41695: LD_INT 2
41697: ARRAY
41698: PPUSH
41699: CALL_OW 111
// wait ( 0 0$10 ) ;
41703: LD_INT 350
41705: PPUSH
41706: CALL_OW 67
// end else
41710: GO 41738
// begin ComMoveXY ( tmp , x , y ) ;
41712: LD_VAR 0 7
41716: PPUSH
41717: LD_VAR 0 4
41721: PPUSH
41722: LD_VAR 0 5
41726: PPUSH
41727: CALL_OW 111
// wait ( 0 0$3 ) ;
41731: LD_INT 105
41733: PPUSH
41734: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41738: LD_VAR 0 7
41742: PPUSH
41743: LD_VAR 0 4
41747: PPUSH
41748: LD_VAR 0 5
41752: PPUSH
41753: CALL_OW 307
41757: IFFALSE 41599
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41759: LD_VAR 0 7
41763: PPUSH
41764: LD_VAR 0 4
41768: PPUSH
41769: LD_VAR 0 5
41773: PPUSH
41774: LD_VAR 0 8
41778: PUSH
41779: LD_VAR 0 3
41783: ARRAY
41784: PPUSH
41785: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41789: LD_INT 35
41791: PPUSH
41792: CALL_OW 67
// until not HasTask ( tmp ) ;
41796: LD_VAR 0 7
41800: PPUSH
41801: CALL_OW 314
41805: NOT
41806: IFFALSE 41789
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41808: LD_ADDR_EXP 129
41812: PUSH
41813: LD_EXP 129
41817: PPUSH
41818: LD_VAR 0 2
41822: PUSH
41823: LD_EXP 129
41827: PUSH
41828: LD_VAR 0 2
41832: ARRAY
41833: PUSH
41834: LD_INT 1
41836: PLUS
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PPUSH
41842: LD_VAR 0 8
41846: PUSH
41847: LD_VAR 0 3
41851: ARRAY
41852: PPUSH
41853: CALL 56474 0 3
41857: ST_TO_ADDR
// end ;
41858: GO 41516
41860: POP
41861: POP
// MC_Reset ( i , 124 ) ;
41862: LD_VAR 0 2
41866: PPUSH
41867: LD_INT 124
41869: PPUSH
41870: CALL 25016 0 2
// end ; end ;
41874: GO 41271
41876: POP
41877: POP
// end ;
41878: LD_VAR 0 1
41882: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41883: LD_INT 0
41885: PPUSH
41886: PPUSH
41887: PPUSH
// if not mc_bases then
41888: LD_EXP 93
41892: NOT
41893: IFFALSE 41897
// exit ;
41895: GO 42503
// for i = 1 to mc_bases do
41897: LD_ADDR_VAR 0 2
41901: PUSH
41902: DOUBLE
41903: LD_INT 1
41905: DEC
41906: ST_TO_ADDR
41907: LD_EXP 93
41911: PUSH
41912: FOR_TO
41913: IFFALSE 42501
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41915: LD_ADDR_VAR 0 3
41919: PUSH
41920: LD_EXP 93
41924: PUSH
41925: LD_VAR 0 2
41929: ARRAY
41930: PPUSH
41931: LD_INT 25
41933: PUSH
41934: LD_INT 4
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PPUSH
41941: CALL_OW 72
41945: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41946: LD_VAR 0 3
41950: NOT
41951: PUSH
41952: LD_EXP 130
41956: PUSH
41957: LD_VAR 0 2
41961: ARRAY
41962: NOT
41963: OR
41964: PUSH
41965: LD_EXP 93
41969: PUSH
41970: LD_VAR 0 2
41974: ARRAY
41975: PPUSH
41976: LD_INT 2
41978: PUSH
41979: LD_INT 30
41981: PUSH
41982: LD_INT 0
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 30
41991: PUSH
41992: LD_INT 1
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: LIST
42003: PPUSH
42004: CALL_OW 72
42008: NOT
42009: OR
42010: IFFALSE 42060
// begin if mc_deposits_finder [ i ] then
42012: LD_EXP 131
42016: PUSH
42017: LD_VAR 0 2
42021: ARRAY
42022: IFFALSE 42058
// begin MC_Reset ( i , 125 ) ;
42024: LD_VAR 0 2
42028: PPUSH
42029: LD_INT 125
42031: PPUSH
42032: CALL 25016 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42036: LD_ADDR_EXP 131
42040: PUSH
42041: LD_EXP 131
42045: PPUSH
42046: LD_VAR 0 2
42050: PPUSH
42051: EMPTY
42052: PPUSH
42053: CALL_OW 1
42057: ST_TO_ADDR
// end ; continue ;
42058: GO 41912
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42060: LD_EXP 130
42064: PUSH
42065: LD_VAR 0 2
42069: ARRAY
42070: PUSH
42071: LD_INT 1
42073: ARRAY
42074: PUSH
42075: LD_INT 3
42077: ARRAY
42078: PUSH
42079: LD_INT 1
42081: EQUAL
42082: PUSH
42083: LD_INT 20
42085: PPUSH
42086: LD_EXP 119
42090: PUSH
42091: LD_VAR 0 2
42095: ARRAY
42096: PPUSH
42097: CALL_OW 321
42101: PUSH
42102: LD_INT 2
42104: NONEQUAL
42105: AND
42106: IFFALSE 42156
// begin if mc_deposits_finder [ i ] then
42108: LD_EXP 131
42112: PUSH
42113: LD_VAR 0 2
42117: ARRAY
42118: IFFALSE 42154
// begin MC_Reset ( i , 125 ) ;
42120: LD_VAR 0 2
42124: PPUSH
42125: LD_INT 125
42127: PPUSH
42128: CALL 25016 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42132: LD_ADDR_EXP 131
42136: PUSH
42137: LD_EXP 131
42141: PPUSH
42142: LD_VAR 0 2
42146: PPUSH
42147: EMPTY
42148: PPUSH
42149: CALL_OW 1
42153: ST_TO_ADDR
// end ; continue ;
42154: GO 41912
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42156: LD_EXP 130
42160: PUSH
42161: LD_VAR 0 2
42165: ARRAY
42166: PUSH
42167: LD_INT 1
42169: ARRAY
42170: PUSH
42171: LD_INT 1
42173: ARRAY
42174: PPUSH
42175: LD_EXP 130
42179: PUSH
42180: LD_VAR 0 2
42184: ARRAY
42185: PUSH
42186: LD_INT 1
42188: ARRAY
42189: PUSH
42190: LD_INT 2
42192: ARRAY
42193: PPUSH
42194: LD_EXP 119
42198: PUSH
42199: LD_VAR 0 2
42203: ARRAY
42204: PPUSH
42205: CALL_OW 440
42209: IFFALSE 42252
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42211: LD_ADDR_EXP 130
42215: PUSH
42216: LD_EXP 130
42220: PPUSH
42221: LD_VAR 0 2
42225: PPUSH
42226: LD_EXP 130
42230: PUSH
42231: LD_VAR 0 2
42235: ARRAY
42236: PPUSH
42237: LD_INT 1
42239: PPUSH
42240: CALL_OW 3
42244: PPUSH
42245: CALL_OW 1
42249: ST_TO_ADDR
42250: GO 42499
// begin if not mc_deposits_finder [ i ] then
42252: LD_EXP 131
42256: PUSH
42257: LD_VAR 0 2
42261: ARRAY
42262: NOT
42263: IFFALSE 42315
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42265: LD_ADDR_EXP 131
42269: PUSH
42270: LD_EXP 131
42274: PPUSH
42275: LD_VAR 0 2
42279: PPUSH
42280: LD_VAR 0 3
42284: PUSH
42285: LD_INT 1
42287: ARRAY
42288: PUSH
42289: EMPTY
42290: LIST
42291: PPUSH
42292: CALL_OW 1
42296: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42297: LD_VAR 0 3
42301: PUSH
42302: LD_INT 1
42304: ARRAY
42305: PPUSH
42306: LD_INT 125
42308: PPUSH
42309: CALL_OW 109
// end else
42313: GO 42499
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42315: LD_EXP 131
42319: PUSH
42320: LD_VAR 0 2
42324: ARRAY
42325: PUSH
42326: LD_INT 1
42328: ARRAY
42329: PPUSH
42330: CALL_OW 310
42334: IFFALSE 42357
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42336: LD_EXP 131
42340: PUSH
42341: LD_VAR 0 2
42345: ARRAY
42346: PUSH
42347: LD_INT 1
42349: ARRAY
42350: PPUSH
42351: CALL_OW 122
42355: GO 42499
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42357: LD_EXP 131
42361: PUSH
42362: LD_VAR 0 2
42366: ARRAY
42367: PUSH
42368: LD_INT 1
42370: ARRAY
42371: PPUSH
42372: CALL_OW 314
42376: NOT
42377: PUSH
42378: LD_EXP 131
42382: PUSH
42383: LD_VAR 0 2
42387: ARRAY
42388: PUSH
42389: LD_INT 1
42391: ARRAY
42392: PPUSH
42393: LD_EXP 130
42397: PUSH
42398: LD_VAR 0 2
42402: ARRAY
42403: PUSH
42404: LD_INT 1
42406: ARRAY
42407: PUSH
42408: LD_INT 1
42410: ARRAY
42411: PPUSH
42412: LD_EXP 130
42416: PUSH
42417: LD_VAR 0 2
42421: ARRAY
42422: PUSH
42423: LD_INT 1
42425: ARRAY
42426: PUSH
42427: LD_INT 2
42429: ARRAY
42430: PPUSH
42431: CALL_OW 297
42435: PUSH
42436: LD_INT 6
42438: GREATER
42439: AND
42440: IFFALSE 42499
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42442: LD_EXP 131
42446: PUSH
42447: LD_VAR 0 2
42451: ARRAY
42452: PUSH
42453: LD_INT 1
42455: ARRAY
42456: PPUSH
42457: LD_EXP 130
42461: PUSH
42462: LD_VAR 0 2
42466: ARRAY
42467: PUSH
42468: LD_INT 1
42470: ARRAY
42471: PUSH
42472: LD_INT 1
42474: ARRAY
42475: PPUSH
42476: LD_EXP 130
42480: PUSH
42481: LD_VAR 0 2
42485: ARRAY
42486: PUSH
42487: LD_INT 1
42489: ARRAY
42490: PUSH
42491: LD_INT 2
42493: ARRAY
42494: PPUSH
42495: CALL_OW 111
// end ; end ; end ;
42499: GO 41912
42501: POP
42502: POP
// end ;
42503: LD_VAR 0 1
42507: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
42508: LD_INT 0
42510: PPUSH
42511: PPUSH
42512: PPUSH
42513: PPUSH
42514: PPUSH
42515: PPUSH
42516: PPUSH
42517: PPUSH
42518: PPUSH
42519: PPUSH
42520: PPUSH
// if not mc_bases then
42521: LD_EXP 93
42525: NOT
42526: IFFALSE 42530
// exit ;
42528: GO 43470
// for i = 1 to mc_bases do
42530: LD_ADDR_VAR 0 2
42534: PUSH
42535: DOUBLE
42536: LD_INT 1
42538: DEC
42539: ST_TO_ADDR
42540: LD_EXP 93
42544: PUSH
42545: FOR_TO
42546: IFFALSE 43468
// begin if not mc_bases [ i ] or mc_scan [ i ] then
42548: LD_EXP 93
42552: PUSH
42553: LD_VAR 0 2
42557: ARRAY
42558: NOT
42559: PUSH
42560: LD_EXP 116
42564: PUSH
42565: LD_VAR 0 2
42569: ARRAY
42570: OR
42571: IFFALSE 42575
// continue ;
42573: GO 42545
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
42575: LD_ADDR_VAR 0 7
42579: PUSH
42580: LD_EXP 93
42584: PUSH
42585: LD_VAR 0 2
42589: ARRAY
42590: PUSH
42591: LD_INT 1
42593: ARRAY
42594: PPUSH
42595: CALL_OW 248
42599: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42600: LD_VAR 0 7
42604: PUSH
42605: LD_INT 3
42607: EQUAL
42608: PUSH
42609: LD_EXP 112
42613: PUSH
42614: LD_VAR 0 2
42618: ARRAY
42619: PUSH
42620: LD_EXP 115
42624: PUSH
42625: LD_VAR 0 2
42629: ARRAY
42630: UNION
42631: PPUSH
42632: LD_INT 33
42634: PUSH
42635: LD_INT 2
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PPUSH
42642: CALL_OW 72
42646: NOT
42647: OR
42648: IFFALSE 42652
// continue ;
42650: GO 42545
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
42652: LD_ADDR_VAR 0 9
42656: PUSH
42657: LD_EXP 93
42661: PUSH
42662: LD_VAR 0 2
42666: ARRAY
42667: PPUSH
42668: LD_INT 30
42670: PUSH
42671: LD_INT 36
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PPUSH
42678: CALL_OW 72
42682: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42683: LD_ADDR_VAR 0 10
42687: PUSH
42688: LD_EXP 112
42692: PUSH
42693: LD_VAR 0 2
42697: ARRAY
42698: PPUSH
42699: LD_INT 34
42701: PUSH
42702: LD_INT 31
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PPUSH
42709: CALL_OW 72
42713: ST_TO_ADDR
// if not cts and not mcts then
42714: LD_VAR 0 9
42718: NOT
42719: PUSH
42720: LD_VAR 0 10
42724: NOT
42725: AND
42726: IFFALSE 42730
// continue ;
42728: GO 42545
// x := cts ;
42730: LD_ADDR_VAR 0 11
42734: PUSH
42735: LD_VAR 0 9
42739: ST_TO_ADDR
// if not x then
42740: LD_VAR 0 11
42744: NOT
42745: IFFALSE 42757
// x := mcts ;
42747: LD_ADDR_VAR 0 11
42751: PUSH
42752: LD_VAR 0 10
42756: ST_TO_ADDR
// if not x then
42757: LD_VAR 0 11
42761: NOT
42762: IFFALSE 42766
// continue ;
42764: GO 42545
// if mc_remote_driver [ i ] then
42766: LD_EXP 133
42770: PUSH
42771: LD_VAR 0 2
42775: ARRAY
42776: IFFALSE 43163
// for j in mc_remote_driver [ i ] do
42778: LD_ADDR_VAR 0 3
42782: PUSH
42783: LD_EXP 133
42787: PUSH
42788: LD_VAR 0 2
42792: ARRAY
42793: PUSH
42794: FOR_IN
42795: IFFALSE 43161
// begin if GetClass ( j ) <> 3 then
42797: LD_VAR 0 3
42801: PPUSH
42802: CALL_OW 257
42806: PUSH
42807: LD_INT 3
42809: NONEQUAL
42810: IFFALSE 42863
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42812: LD_ADDR_EXP 133
42816: PUSH
42817: LD_EXP 133
42821: PPUSH
42822: LD_VAR 0 2
42826: PPUSH
42827: LD_EXP 133
42831: PUSH
42832: LD_VAR 0 2
42836: ARRAY
42837: PUSH
42838: LD_VAR 0 3
42842: DIFF
42843: PPUSH
42844: CALL_OW 1
42848: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42849: LD_VAR 0 3
42853: PPUSH
42854: LD_INT 0
42856: PPUSH
42857: CALL_OW 109
// continue ;
42861: GO 42794
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42863: LD_EXP 112
42867: PUSH
42868: LD_VAR 0 2
42872: ARRAY
42873: PPUSH
42874: LD_INT 34
42876: PUSH
42877: LD_INT 31
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: LD_INT 58
42886: PUSH
42887: EMPTY
42888: LIST
42889: PUSH
42890: EMPTY
42891: LIST
42892: LIST
42893: PPUSH
42894: CALL_OW 72
42898: PUSH
42899: LD_VAR 0 3
42903: PPUSH
42904: CALL 85831 0 1
42908: NOT
42909: AND
42910: IFFALSE 42981
// begin if IsInUnit ( j ) then
42912: LD_VAR 0 3
42916: PPUSH
42917: CALL_OW 310
42921: IFFALSE 42932
// ComExitBuilding ( j ) ;
42923: LD_VAR 0 3
42927: PPUSH
42928: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42932: LD_VAR 0 3
42936: PPUSH
42937: LD_EXP 112
42941: PUSH
42942: LD_VAR 0 2
42946: ARRAY
42947: PPUSH
42948: LD_INT 34
42950: PUSH
42951: LD_INT 31
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: LD_INT 58
42960: PUSH
42961: EMPTY
42962: LIST
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PPUSH
42968: CALL_OW 72
42972: PUSH
42973: LD_INT 1
42975: ARRAY
42976: PPUSH
42977: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42981: LD_VAR 0 3
42985: PPUSH
42986: CALL_OW 310
42990: NOT
42991: PUSH
42992: LD_VAR 0 3
42996: PPUSH
42997: CALL_OW 310
43001: PPUSH
43002: CALL_OW 266
43006: PUSH
43007: LD_INT 36
43009: NONEQUAL
43010: PUSH
43011: LD_VAR 0 3
43015: PPUSH
43016: CALL 85831 0 1
43020: NOT
43021: AND
43022: OR
43023: IFFALSE 43159
// begin if IsInUnit ( j ) then
43025: LD_VAR 0 3
43029: PPUSH
43030: CALL_OW 310
43034: IFFALSE 43045
// ComExitBuilding ( j ) ;
43036: LD_VAR 0 3
43040: PPUSH
43041: CALL_OW 122
// ct := 0 ;
43045: LD_ADDR_VAR 0 8
43049: PUSH
43050: LD_INT 0
43052: ST_TO_ADDR
// for k in x do
43053: LD_ADDR_VAR 0 4
43057: PUSH
43058: LD_VAR 0 11
43062: PUSH
43063: FOR_IN
43064: IFFALSE 43137
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43066: LD_VAR 0 4
43070: PPUSH
43071: CALL_OW 264
43075: PUSH
43076: LD_INT 31
43078: EQUAL
43079: PUSH
43080: LD_VAR 0 4
43084: PPUSH
43085: CALL_OW 311
43089: NOT
43090: AND
43091: PUSH
43092: LD_VAR 0 4
43096: PPUSH
43097: CALL_OW 266
43101: PUSH
43102: LD_INT 36
43104: EQUAL
43105: PUSH
43106: LD_VAR 0 4
43110: PPUSH
43111: CALL_OW 313
43115: PUSH
43116: LD_INT 3
43118: LESS
43119: AND
43120: OR
43121: IFFALSE 43135
// begin ct := k ;
43123: LD_ADDR_VAR 0 8
43127: PUSH
43128: LD_VAR 0 4
43132: ST_TO_ADDR
// break ;
43133: GO 43137
// end ;
43135: GO 43063
43137: POP
43138: POP
// if ct then
43139: LD_VAR 0 8
43143: IFFALSE 43159
// ComEnterUnit ( j , ct ) ;
43145: LD_VAR 0 3
43149: PPUSH
43150: LD_VAR 0 8
43154: PPUSH
43155: CALL_OW 120
// end ; end ;
43159: GO 42794
43161: POP
43162: POP
// places := 0 ;
43163: LD_ADDR_VAR 0 5
43167: PUSH
43168: LD_INT 0
43170: ST_TO_ADDR
// for j = 1 to x do
43171: LD_ADDR_VAR 0 3
43175: PUSH
43176: DOUBLE
43177: LD_INT 1
43179: DEC
43180: ST_TO_ADDR
43181: LD_VAR 0 11
43185: PUSH
43186: FOR_TO
43187: IFFALSE 43263
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43189: LD_VAR 0 11
43193: PUSH
43194: LD_VAR 0 3
43198: ARRAY
43199: PPUSH
43200: CALL_OW 264
43204: PUSH
43205: LD_INT 31
43207: EQUAL
43208: IFFALSE 43226
// places := places + 1 else
43210: LD_ADDR_VAR 0 5
43214: PUSH
43215: LD_VAR 0 5
43219: PUSH
43220: LD_INT 1
43222: PLUS
43223: ST_TO_ADDR
43224: GO 43261
// if GetBType ( x [ j ] ) = b_control_tower then
43226: LD_VAR 0 11
43230: PUSH
43231: LD_VAR 0 3
43235: ARRAY
43236: PPUSH
43237: CALL_OW 266
43241: PUSH
43242: LD_INT 36
43244: EQUAL
43245: IFFALSE 43261
// places := places + 3 ;
43247: LD_ADDR_VAR 0 5
43251: PUSH
43252: LD_VAR 0 5
43256: PUSH
43257: LD_INT 3
43259: PLUS
43260: ST_TO_ADDR
43261: GO 43186
43263: POP
43264: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43265: LD_VAR 0 5
43269: PUSH
43270: LD_INT 0
43272: EQUAL
43273: PUSH
43274: LD_VAR 0 5
43278: PUSH
43279: LD_EXP 133
43283: PUSH
43284: LD_VAR 0 2
43288: ARRAY
43289: LESSEQUAL
43290: OR
43291: IFFALSE 43295
// continue ;
43293: GO 42545
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43295: LD_ADDR_VAR 0 6
43299: PUSH
43300: LD_EXP 93
43304: PUSH
43305: LD_VAR 0 2
43309: ARRAY
43310: PPUSH
43311: LD_INT 25
43313: PUSH
43314: LD_INT 3
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PPUSH
43321: CALL_OW 72
43325: PUSH
43326: LD_EXP 133
43330: PUSH
43331: LD_VAR 0 2
43335: ARRAY
43336: DIFF
43337: PPUSH
43338: LD_INT 3
43340: PPUSH
43341: CALL 86731 0 2
43345: ST_TO_ADDR
// for j in tmp do
43346: LD_ADDR_VAR 0 3
43350: PUSH
43351: LD_VAR 0 6
43355: PUSH
43356: FOR_IN
43357: IFFALSE 43392
// if GetTag ( j ) > 0 then
43359: LD_VAR 0 3
43363: PPUSH
43364: CALL_OW 110
43368: PUSH
43369: LD_INT 0
43371: GREATER
43372: IFFALSE 43390
// tmp := tmp diff j ;
43374: LD_ADDR_VAR 0 6
43378: PUSH
43379: LD_VAR 0 6
43383: PUSH
43384: LD_VAR 0 3
43388: DIFF
43389: ST_TO_ADDR
43390: GO 43356
43392: POP
43393: POP
// if not tmp then
43394: LD_VAR 0 6
43398: NOT
43399: IFFALSE 43403
// continue ;
43401: GO 42545
// if places then
43403: LD_VAR 0 5
43407: IFFALSE 43466
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43409: LD_ADDR_EXP 133
43413: PUSH
43414: LD_EXP 133
43418: PPUSH
43419: LD_VAR 0 2
43423: PPUSH
43424: LD_EXP 133
43428: PUSH
43429: LD_VAR 0 2
43433: ARRAY
43434: PUSH
43435: LD_VAR 0 6
43439: PUSH
43440: LD_INT 1
43442: ARRAY
43443: UNION
43444: PPUSH
43445: CALL_OW 1
43449: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43450: LD_VAR 0 6
43454: PUSH
43455: LD_INT 1
43457: ARRAY
43458: PPUSH
43459: LD_INT 126
43461: PPUSH
43462: CALL_OW 109
// end ; end ;
43466: GO 42545
43468: POP
43469: POP
// end ;
43470: LD_VAR 0 1
43474: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43475: LD_INT 0
43477: PPUSH
43478: PPUSH
43479: PPUSH
43480: PPUSH
43481: PPUSH
43482: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43483: LD_VAR 0 1
43487: NOT
43488: PUSH
43489: LD_VAR 0 2
43493: NOT
43494: OR
43495: PUSH
43496: LD_VAR 0 3
43500: NOT
43501: OR
43502: PUSH
43503: LD_VAR 0 4
43507: PUSH
43508: LD_INT 1
43510: PUSH
43511: LD_INT 2
43513: PUSH
43514: LD_INT 3
43516: PUSH
43517: LD_INT 4
43519: PUSH
43520: LD_INT 5
43522: PUSH
43523: LD_INT 8
43525: PUSH
43526: LD_INT 9
43528: PUSH
43529: LD_INT 15
43531: PUSH
43532: LD_INT 16
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: IN
43546: NOT
43547: OR
43548: IFFALSE 43552
// exit ;
43550: GO 44452
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
43552: LD_ADDR_VAR 0 2
43556: PUSH
43557: LD_VAR 0 2
43561: PPUSH
43562: LD_INT 21
43564: PUSH
43565: LD_INT 3
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 24
43574: PUSH
43575: LD_INT 250
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PPUSH
43586: CALL_OW 72
43590: ST_TO_ADDR
// case class of 1 , 15 :
43591: LD_VAR 0 4
43595: PUSH
43596: LD_INT 1
43598: DOUBLE
43599: EQUAL
43600: IFTRUE 43610
43602: LD_INT 15
43604: DOUBLE
43605: EQUAL
43606: IFTRUE 43610
43608: GO 43695
43610: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43611: LD_ADDR_VAR 0 8
43615: PUSH
43616: LD_VAR 0 2
43620: PPUSH
43621: LD_INT 2
43623: PUSH
43624: LD_INT 30
43626: PUSH
43627: LD_INT 32
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 30
43636: PUSH
43637: LD_INT 31
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: LIST
43648: PPUSH
43649: CALL_OW 72
43653: PUSH
43654: LD_VAR 0 2
43658: PPUSH
43659: LD_INT 2
43661: PUSH
43662: LD_INT 30
43664: PUSH
43665: LD_INT 4
43667: PUSH
43668: EMPTY
43669: LIST
43670: LIST
43671: PUSH
43672: LD_INT 30
43674: PUSH
43675: LD_INT 5
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: LIST
43686: PPUSH
43687: CALL_OW 72
43691: ADD
43692: ST_TO_ADDR
43693: GO 43941
43695: LD_INT 2
43697: DOUBLE
43698: EQUAL
43699: IFTRUE 43709
43701: LD_INT 16
43703: DOUBLE
43704: EQUAL
43705: IFTRUE 43709
43707: GO 43755
43709: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43710: LD_ADDR_VAR 0 8
43714: PUSH
43715: LD_VAR 0 2
43719: PPUSH
43720: LD_INT 2
43722: PUSH
43723: LD_INT 30
43725: PUSH
43726: LD_INT 0
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: PUSH
43733: LD_INT 30
43735: PUSH
43736: LD_INT 1
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: LIST
43747: PPUSH
43748: CALL_OW 72
43752: ST_TO_ADDR
43753: GO 43941
43755: LD_INT 3
43757: DOUBLE
43758: EQUAL
43759: IFTRUE 43763
43761: GO 43809
43763: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43764: LD_ADDR_VAR 0 8
43768: PUSH
43769: LD_VAR 0 2
43773: PPUSH
43774: LD_INT 2
43776: PUSH
43777: LD_INT 30
43779: PUSH
43780: LD_INT 2
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 30
43789: PUSH
43790: LD_INT 3
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: LIST
43801: PPUSH
43802: CALL_OW 72
43806: ST_TO_ADDR
43807: GO 43941
43809: LD_INT 4
43811: DOUBLE
43812: EQUAL
43813: IFTRUE 43817
43815: GO 43874
43817: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43818: LD_ADDR_VAR 0 8
43822: PUSH
43823: LD_VAR 0 2
43827: PPUSH
43828: LD_INT 2
43830: PUSH
43831: LD_INT 30
43833: PUSH
43834: LD_INT 6
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 30
43843: PUSH
43844: LD_INT 7
43846: PUSH
43847: EMPTY
43848: LIST
43849: LIST
43850: PUSH
43851: LD_INT 30
43853: PUSH
43854: LD_INT 8
43856: PUSH
43857: EMPTY
43858: LIST
43859: LIST
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: PPUSH
43867: CALL_OW 72
43871: ST_TO_ADDR
43872: GO 43941
43874: LD_INT 5
43876: DOUBLE
43877: EQUAL
43878: IFTRUE 43894
43880: LD_INT 8
43882: DOUBLE
43883: EQUAL
43884: IFTRUE 43894
43886: LD_INT 9
43888: DOUBLE
43889: EQUAL
43890: IFTRUE 43894
43892: GO 43940
43894: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43895: LD_ADDR_VAR 0 8
43899: PUSH
43900: LD_VAR 0 2
43904: PPUSH
43905: LD_INT 2
43907: PUSH
43908: LD_INT 30
43910: PUSH
43911: LD_INT 4
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 30
43920: PUSH
43921: LD_INT 5
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: LIST
43932: PPUSH
43933: CALL_OW 72
43937: ST_TO_ADDR
43938: GO 43941
43940: POP
// if not tmp then
43941: LD_VAR 0 8
43945: NOT
43946: IFFALSE 43950
// exit ;
43948: GO 44452
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43950: LD_VAR 0 4
43954: PUSH
43955: LD_INT 1
43957: PUSH
43958: LD_INT 15
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: IN
43965: PUSH
43966: LD_EXP 102
43970: PUSH
43971: LD_VAR 0 1
43975: ARRAY
43976: AND
43977: IFFALSE 44133
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43979: LD_ADDR_VAR 0 9
43983: PUSH
43984: LD_EXP 102
43988: PUSH
43989: LD_VAR 0 1
43993: ARRAY
43994: PUSH
43995: LD_INT 1
43997: ARRAY
43998: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43999: LD_VAR 0 9
44003: PUSH
44004: LD_EXP 103
44008: PUSH
44009: LD_VAR 0 1
44013: ARRAY
44014: IN
44015: NOT
44016: IFFALSE 44131
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44018: LD_ADDR_EXP 103
44022: PUSH
44023: LD_EXP 103
44027: PPUSH
44028: LD_VAR 0 1
44032: PUSH
44033: LD_EXP 103
44037: PUSH
44038: LD_VAR 0 1
44042: ARRAY
44043: PUSH
44044: LD_INT 1
44046: PLUS
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PPUSH
44052: LD_VAR 0 9
44056: PPUSH
44057: CALL 56474 0 3
44061: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44062: LD_ADDR_EXP 102
44066: PUSH
44067: LD_EXP 102
44071: PPUSH
44072: LD_VAR 0 1
44076: PPUSH
44077: LD_EXP 102
44081: PUSH
44082: LD_VAR 0 1
44086: ARRAY
44087: PUSH
44088: LD_VAR 0 9
44092: DIFF
44093: PPUSH
44094: CALL_OW 1
44098: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44099: LD_VAR 0 3
44103: PPUSH
44104: LD_EXP 103
44108: PUSH
44109: LD_VAR 0 1
44113: ARRAY
44114: PUSH
44115: LD_EXP 103
44119: PUSH
44120: LD_VAR 0 1
44124: ARRAY
44125: ARRAY
44126: PPUSH
44127: CALL_OW 120
// end ; exit ;
44131: GO 44452
// end ; if tmp > 1 then
44133: LD_VAR 0 8
44137: PUSH
44138: LD_INT 1
44140: GREATER
44141: IFFALSE 44245
// for i = 2 to tmp do
44143: LD_ADDR_VAR 0 6
44147: PUSH
44148: DOUBLE
44149: LD_INT 2
44151: DEC
44152: ST_TO_ADDR
44153: LD_VAR 0 8
44157: PUSH
44158: FOR_TO
44159: IFFALSE 44243
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44161: LD_VAR 0 8
44165: PUSH
44166: LD_VAR 0 6
44170: ARRAY
44171: PPUSH
44172: CALL_OW 461
44176: PUSH
44177: LD_INT 6
44179: EQUAL
44180: IFFALSE 44241
// begin x := tmp [ i ] ;
44182: LD_ADDR_VAR 0 9
44186: PUSH
44187: LD_VAR 0 8
44191: PUSH
44192: LD_VAR 0 6
44196: ARRAY
44197: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44198: LD_ADDR_VAR 0 8
44202: PUSH
44203: LD_VAR 0 8
44207: PPUSH
44208: LD_VAR 0 6
44212: PPUSH
44213: CALL_OW 3
44217: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44218: LD_ADDR_VAR 0 8
44222: PUSH
44223: LD_VAR 0 8
44227: PPUSH
44228: LD_INT 1
44230: PPUSH
44231: LD_VAR 0 9
44235: PPUSH
44236: CALL_OW 2
44240: ST_TO_ADDR
// end ;
44241: GO 44158
44243: POP
44244: POP
// for i in tmp do
44245: LD_ADDR_VAR 0 6
44249: PUSH
44250: LD_VAR 0 8
44254: PUSH
44255: FOR_IN
44256: IFFALSE 44325
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44258: LD_VAR 0 6
44262: PPUSH
44263: CALL_OW 313
44267: PUSH
44268: LD_INT 6
44270: LESS
44271: PUSH
44272: LD_VAR 0 6
44276: PPUSH
44277: CALL_OW 266
44281: PUSH
44282: LD_INT 31
44284: PUSH
44285: LD_INT 32
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: IN
44292: NOT
44293: AND
44294: PUSH
44295: LD_VAR 0 6
44299: PPUSH
44300: CALL_OW 313
44304: PUSH
44305: LD_INT 0
44307: EQUAL
44308: OR
44309: IFFALSE 44323
// begin j := i ;
44311: LD_ADDR_VAR 0 7
44315: PUSH
44316: LD_VAR 0 6
44320: ST_TO_ADDR
// break ;
44321: GO 44325
// end ; end ;
44323: GO 44255
44325: POP
44326: POP
// if j then
44327: LD_VAR 0 7
44331: IFFALSE 44349
// ComEnterUnit ( unit , j ) else
44333: LD_VAR 0 3
44337: PPUSH
44338: LD_VAR 0 7
44342: PPUSH
44343: CALL_OW 120
44347: GO 44452
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44349: LD_ADDR_VAR 0 10
44353: PUSH
44354: LD_VAR 0 2
44358: PPUSH
44359: LD_INT 2
44361: PUSH
44362: LD_INT 30
44364: PUSH
44365: LD_INT 0
44367: PUSH
44368: EMPTY
44369: LIST
44370: LIST
44371: PUSH
44372: LD_INT 30
44374: PUSH
44375: LD_INT 1
44377: PUSH
44378: EMPTY
44379: LIST
44380: LIST
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: LIST
44386: PPUSH
44387: CALL_OW 72
44391: ST_TO_ADDR
// if depot then
44392: LD_VAR 0 10
44396: IFFALSE 44452
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44398: LD_ADDR_VAR 0 10
44402: PUSH
44403: LD_VAR 0 10
44407: PPUSH
44408: LD_VAR 0 3
44412: PPUSH
44413: CALL_OW 74
44417: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44418: LD_VAR 0 3
44422: PPUSH
44423: LD_VAR 0 10
44427: PPUSH
44428: CALL_OW 296
44432: PUSH
44433: LD_INT 10
44435: GREATER
44436: IFFALSE 44452
// ComStandNearbyBuilding ( unit , depot ) ;
44438: LD_VAR 0 3
44442: PPUSH
44443: LD_VAR 0 10
44447: PPUSH
44448: CALL 53052 0 2
// end ; end ; end ;
44452: LD_VAR 0 5
44456: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44457: LD_INT 0
44459: PPUSH
44460: PPUSH
44461: PPUSH
44462: PPUSH
// if not mc_bases then
44463: LD_EXP 93
44467: NOT
44468: IFFALSE 44472
// exit ;
44470: GO 44711
// for i = 1 to mc_bases do
44472: LD_ADDR_VAR 0 2
44476: PUSH
44477: DOUBLE
44478: LD_INT 1
44480: DEC
44481: ST_TO_ADDR
44482: LD_EXP 93
44486: PUSH
44487: FOR_TO
44488: IFFALSE 44709
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44490: LD_ADDR_VAR 0 4
44494: PUSH
44495: LD_EXP 93
44499: PUSH
44500: LD_VAR 0 2
44504: ARRAY
44505: PPUSH
44506: LD_INT 21
44508: PUSH
44509: LD_INT 1
44511: PUSH
44512: EMPTY
44513: LIST
44514: LIST
44515: PPUSH
44516: CALL_OW 72
44520: PUSH
44521: LD_EXP 122
44525: PUSH
44526: LD_VAR 0 2
44530: ARRAY
44531: UNION
44532: ST_TO_ADDR
// if not tmp then
44533: LD_VAR 0 4
44537: NOT
44538: IFFALSE 44542
// continue ;
44540: GO 44487
// for j in tmp do
44542: LD_ADDR_VAR 0 3
44546: PUSH
44547: LD_VAR 0 4
44551: PUSH
44552: FOR_IN
44553: IFFALSE 44705
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
44555: LD_VAR 0 3
44559: PPUSH
44560: CALL_OW 110
44564: NOT
44565: PUSH
44566: LD_VAR 0 3
44570: PPUSH
44571: CALL_OW 314
44575: NOT
44576: AND
44577: PUSH
44578: LD_VAR 0 3
44582: PPUSH
44583: CALL_OW 311
44587: NOT
44588: AND
44589: PUSH
44590: LD_VAR 0 3
44594: PPUSH
44595: CALL_OW 310
44599: NOT
44600: AND
44601: PUSH
44602: LD_VAR 0 3
44606: PUSH
44607: LD_EXP 96
44611: PUSH
44612: LD_VAR 0 2
44616: ARRAY
44617: PUSH
44618: LD_INT 1
44620: ARRAY
44621: IN
44622: NOT
44623: AND
44624: PUSH
44625: LD_VAR 0 3
44629: PUSH
44630: LD_EXP 96
44634: PUSH
44635: LD_VAR 0 2
44639: ARRAY
44640: PUSH
44641: LD_INT 2
44643: ARRAY
44644: IN
44645: NOT
44646: AND
44647: PUSH
44648: LD_VAR 0 3
44652: PUSH
44653: LD_EXP 105
44657: PUSH
44658: LD_VAR 0 2
44662: ARRAY
44663: IN
44664: NOT
44665: AND
44666: IFFALSE 44703
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
44668: LD_VAR 0 2
44672: PPUSH
44673: LD_EXP 93
44677: PUSH
44678: LD_VAR 0 2
44682: ARRAY
44683: PPUSH
44684: LD_VAR 0 3
44688: PPUSH
44689: LD_VAR 0 3
44693: PPUSH
44694: CALL_OW 257
44698: PPUSH
44699: CALL 43475 0 4
// end ;
44703: GO 44552
44705: POP
44706: POP
// end ;
44707: GO 44487
44709: POP
44710: POP
// end ;
44711: LD_VAR 0 1
44715: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44716: LD_INT 0
44718: PPUSH
44719: PPUSH
44720: PPUSH
44721: PPUSH
44722: PPUSH
44723: PPUSH
// if not mc_bases [ base ] then
44724: LD_EXP 93
44728: PUSH
44729: LD_VAR 0 1
44733: ARRAY
44734: NOT
44735: IFFALSE 44739
// exit ;
44737: GO 44921
// tmp := [ ] ;
44739: LD_ADDR_VAR 0 6
44743: PUSH
44744: EMPTY
44745: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44746: LD_ADDR_VAR 0 7
44750: PUSH
44751: LD_VAR 0 3
44755: PPUSH
44756: LD_INT 0
44758: PPUSH
44759: CALL_OW 517
44763: ST_TO_ADDR
// if not list then
44764: LD_VAR 0 7
44768: NOT
44769: IFFALSE 44773
// exit ;
44771: GO 44921
// for i = 1 to amount do
44773: LD_ADDR_VAR 0 5
44777: PUSH
44778: DOUBLE
44779: LD_INT 1
44781: DEC
44782: ST_TO_ADDR
44783: LD_VAR 0 2
44787: PUSH
44788: FOR_TO
44789: IFFALSE 44869
// begin x := rand ( 1 , list [ 1 ] ) ;
44791: LD_ADDR_VAR 0 8
44795: PUSH
44796: LD_INT 1
44798: PPUSH
44799: LD_VAR 0 7
44803: PUSH
44804: LD_INT 1
44806: ARRAY
44807: PPUSH
44808: CALL_OW 12
44812: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44813: LD_ADDR_VAR 0 6
44817: PUSH
44818: LD_VAR 0 6
44822: PPUSH
44823: LD_VAR 0 5
44827: PPUSH
44828: LD_VAR 0 7
44832: PUSH
44833: LD_INT 1
44835: ARRAY
44836: PUSH
44837: LD_VAR 0 8
44841: ARRAY
44842: PUSH
44843: LD_VAR 0 7
44847: PUSH
44848: LD_INT 2
44850: ARRAY
44851: PUSH
44852: LD_VAR 0 8
44856: ARRAY
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: PPUSH
44862: CALL_OW 1
44866: ST_TO_ADDR
// end ;
44867: GO 44788
44869: POP
44870: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44871: LD_ADDR_EXP 106
44875: PUSH
44876: LD_EXP 106
44880: PPUSH
44881: LD_VAR 0 1
44885: PPUSH
44886: LD_VAR 0 6
44890: PPUSH
44891: CALL_OW 1
44895: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44896: LD_ADDR_EXP 108
44900: PUSH
44901: LD_EXP 108
44905: PPUSH
44906: LD_VAR 0 1
44910: PPUSH
44911: LD_VAR 0 3
44915: PPUSH
44916: CALL_OW 1
44920: ST_TO_ADDR
// end ;
44921: LD_VAR 0 4
44925: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44926: LD_INT 0
44928: PPUSH
// if not mc_bases [ base ] then
44929: LD_EXP 93
44933: PUSH
44934: LD_VAR 0 1
44938: ARRAY
44939: NOT
44940: IFFALSE 44944
// exit ;
44942: GO 44969
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44944: LD_ADDR_EXP 98
44948: PUSH
44949: LD_EXP 98
44953: PPUSH
44954: LD_VAR 0 1
44958: PPUSH
44959: LD_VAR 0 2
44963: PPUSH
44964: CALL_OW 1
44968: ST_TO_ADDR
// end ;
44969: LD_VAR 0 3
44973: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44974: LD_INT 0
44976: PPUSH
// if not mc_bases [ base ] then
44977: LD_EXP 93
44981: PUSH
44982: LD_VAR 0 1
44986: ARRAY
44987: NOT
44988: IFFALSE 44992
// exit ;
44990: GO 45029
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44992: LD_ADDR_EXP 98
44996: PUSH
44997: LD_EXP 98
45001: PPUSH
45002: LD_VAR 0 1
45006: PPUSH
45007: LD_EXP 98
45011: PUSH
45012: LD_VAR 0 1
45016: ARRAY
45017: PUSH
45018: LD_VAR 0 2
45022: UNION
45023: PPUSH
45024: CALL_OW 1
45028: ST_TO_ADDR
// end ;
45029: LD_VAR 0 3
45033: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45034: LD_INT 0
45036: PPUSH
// if not mc_bases [ base ] then
45037: LD_EXP 93
45041: PUSH
45042: LD_VAR 0 1
45046: ARRAY
45047: NOT
45048: IFFALSE 45052
// exit ;
45050: GO 45077
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45052: LD_ADDR_EXP 114
45056: PUSH
45057: LD_EXP 114
45061: PPUSH
45062: LD_VAR 0 1
45066: PPUSH
45067: LD_VAR 0 2
45071: PPUSH
45072: CALL_OW 1
45076: ST_TO_ADDR
// end ;
45077: LD_VAR 0 3
45081: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45082: LD_INT 0
45084: PPUSH
// if not mc_bases [ base ] then
45085: LD_EXP 93
45089: PUSH
45090: LD_VAR 0 1
45094: ARRAY
45095: NOT
45096: IFFALSE 45100
// exit ;
45098: GO 45137
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45100: LD_ADDR_EXP 114
45104: PUSH
45105: LD_EXP 114
45109: PPUSH
45110: LD_VAR 0 1
45114: PPUSH
45115: LD_EXP 114
45119: PUSH
45120: LD_VAR 0 1
45124: ARRAY
45125: PUSH
45126: LD_VAR 0 2
45130: ADD
45131: PPUSH
45132: CALL_OW 1
45136: ST_TO_ADDR
// end ;
45137: LD_VAR 0 3
45141: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45142: LD_INT 0
45144: PPUSH
// if not mc_bases [ base ] then
45145: LD_EXP 93
45149: PUSH
45150: LD_VAR 0 1
45154: ARRAY
45155: NOT
45156: IFFALSE 45160
// exit ;
45158: GO 45214
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45160: LD_ADDR_EXP 115
45164: PUSH
45165: LD_EXP 115
45169: PPUSH
45170: LD_VAR 0 1
45174: PPUSH
45175: LD_VAR 0 2
45179: PPUSH
45180: CALL_OW 1
45184: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45185: LD_ADDR_EXP 104
45189: PUSH
45190: LD_EXP 104
45194: PPUSH
45195: LD_VAR 0 1
45199: PPUSH
45200: LD_VAR 0 2
45204: PUSH
45205: LD_INT 0
45207: PLUS
45208: PPUSH
45209: CALL_OW 1
45213: ST_TO_ADDR
// end ;
45214: LD_VAR 0 3
45218: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45219: LD_INT 0
45221: PPUSH
// if not mc_bases [ base ] then
45222: LD_EXP 93
45226: PUSH
45227: LD_VAR 0 1
45231: ARRAY
45232: NOT
45233: IFFALSE 45237
// exit ;
45235: GO 45262
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45237: LD_ADDR_EXP 104
45241: PUSH
45242: LD_EXP 104
45246: PPUSH
45247: LD_VAR 0 1
45251: PPUSH
45252: LD_VAR 0 2
45256: PPUSH
45257: CALL_OW 1
45261: ST_TO_ADDR
// end ;
45262: LD_VAR 0 3
45266: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45267: LD_INT 0
45269: PPUSH
45270: PPUSH
45271: PPUSH
45272: PPUSH
// if not mc_bases [ base ] then
45273: LD_EXP 93
45277: PUSH
45278: LD_VAR 0 1
45282: ARRAY
45283: NOT
45284: IFFALSE 45288
// exit ;
45286: GO 45353
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45288: LD_ADDR_EXP 113
45292: PUSH
45293: LD_EXP 113
45297: PPUSH
45298: LD_VAR 0 1
45302: PUSH
45303: LD_EXP 113
45307: PUSH
45308: LD_VAR 0 1
45312: ARRAY
45313: PUSH
45314: LD_INT 1
45316: PLUS
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PPUSH
45322: LD_VAR 0 1
45326: PUSH
45327: LD_VAR 0 2
45331: PUSH
45332: LD_VAR 0 3
45336: PUSH
45337: LD_VAR 0 4
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: PPUSH
45348: CALL 56474 0 3
45352: ST_TO_ADDR
// end ;
45353: LD_VAR 0 5
45357: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45358: LD_INT 0
45360: PPUSH
// if not mc_bases [ base ] then
45361: LD_EXP 93
45365: PUSH
45366: LD_VAR 0 1
45370: ARRAY
45371: NOT
45372: IFFALSE 45376
// exit ;
45374: GO 45401
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45376: LD_ADDR_EXP 130
45380: PUSH
45381: LD_EXP 130
45385: PPUSH
45386: LD_VAR 0 1
45390: PPUSH
45391: LD_VAR 0 2
45395: PPUSH
45396: CALL_OW 1
45400: ST_TO_ADDR
// end ;
45401: LD_VAR 0 3
45405: RET
// export function MC_GetMinesField ( base ) ; begin
45406: LD_INT 0
45408: PPUSH
// result := mc_mines [ base ] ;
45409: LD_ADDR_VAR 0 2
45413: PUSH
45414: LD_EXP 106
45418: PUSH
45419: LD_VAR 0 1
45423: ARRAY
45424: ST_TO_ADDR
// end ;
45425: LD_VAR 0 2
45429: RET
// export function MC_GetProduceList ( base ) ; begin
45430: LD_INT 0
45432: PPUSH
// result := mc_produce [ base ] ;
45433: LD_ADDR_VAR 0 2
45437: PUSH
45438: LD_EXP 114
45442: PUSH
45443: LD_VAR 0 1
45447: ARRAY
45448: ST_TO_ADDR
// end ;
45449: LD_VAR 0 2
45453: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45454: LD_INT 0
45456: PPUSH
45457: PPUSH
// if not mc_bases then
45458: LD_EXP 93
45462: NOT
45463: IFFALSE 45467
// exit ;
45465: GO 45532
// if mc_bases [ base ] then
45467: LD_EXP 93
45471: PUSH
45472: LD_VAR 0 1
45476: ARRAY
45477: IFFALSE 45532
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45479: LD_ADDR_VAR 0 3
45483: PUSH
45484: LD_EXP 93
45488: PUSH
45489: LD_VAR 0 1
45493: ARRAY
45494: PPUSH
45495: LD_INT 30
45497: PUSH
45498: LD_VAR 0 2
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PPUSH
45507: CALL_OW 72
45511: ST_TO_ADDR
// if result then
45512: LD_VAR 0 3
45516: IFFALSE 45532
// result := result [ 1 ] ;
45518: LD_ADDR_VAR 0 3
45522: PUSH
45523: LD_VAR 0 3
45527: PUSH
45528: LD_INT 1
45530: ARRAY
45531: ST_TO_ADDR
// end ; end ;
45532: LD_VAR 0 3
45536: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
45537: LD_INT 0
45539: PPUSH
45540: PPUSH
// if not mc_bases then
45541: LD_EXP 93
45545: NOT
45546: IFFALSE 45550
// exit ;
45548: GO 45595
// if mc_bases [ base ] then
45550: LD_EXP 93
45554: PUSH
45555: LD_VAR 0 1
45559: ARRAY
45560: IFFALSE 45595
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45562: LD_ADDR_VAR 0 3
45566: PUSH
45567: LD_EXP 93
45571: PUSH
45572: LD_VAR 0 1
45576: ARRAY
45577: PPUSH
45578: LD_INT 30
45580: PUSH
45581: LD_VAR 0 2
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: PPUSH
45590: CALL_OW 72
45594: ST_TO_ADDR
// end ;
45595: LD_VAR 0 3
45599: RET
// export function MC_SetTame ( base , area ) ; begin
45600: LD_INT 0
45602: PPUSH
// if not mc_bases or not base then
45603: LD_EXP 93
45607: NOT
45608: PUSH
45609: LD_VAR 0 1
45613: NOT
45614: OR
45615: IFFALSE 45619
// exit ;
45617: GO 45644
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45619: LD_ADDR_EXP 121
45623: PUSH
45624: LD_EXP 121
45628: PPUSH
45629: LD_VAR 0 1
45633: PPUSH
45634: LD_VAR 0 2
45638: PPUSH
45639: CALL_OW 1
45643: ST_TO_ADDR
// end ;
45644: LD_VAR 0 3
45648: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
45649: LD_INT 0
45651: PPUSH
45652: PPUSH
// if not mc_bases or not base then
45653: LD_EXP 93
45657: NOT
45658: PUSH
45659: LD_VAR 0 1
45663: NOT
45664: OR
45665: IFFALSE 45669
// exit ;
45667: GO 45771
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45669: LD_ADDR_VAR 0 4
45673: PUSH
45674: LD_EXP 93
45678: PUSH
45679: LD_VAR 0 1
45683: ARRAY
45684: PPUSH
45685: LD_INT 30
45687: PUSH
45688: LD_VAR 0 2
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PPUSH
45697: CALL_OW 72
45701: ST_TO_ADDR
// if not tmp then
45702: LD_VAR 0 4
45706: NOT
45707: IFFALSE 45711
// exit ;
45709: GO 45771
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45711: LD_ADDR_EXP 125
45715: PUSH
45716: LD_EXP 125
45720: PPUSH
45721: LD_VAR 0 1
45725: PPUSH
45726: LD_EXP 125
45730: PUSH
45731: LD_VAR 0 1
45735: ARRAY
45736: PPUSH
45737: LD_EXP 125
45741: PUSH
45742: LD_VAR 0 1
45746: ARRAY
45747: PUSH
45748: LD_INT 1
45750: PLUS
45751: PPUSH
45752: LD_VAR 0 4
45756: PUSH
45757: LD_INT 1
45759: ARRAY
45760: PPUSH
45761: CALL_OW 2
45765: PPUSH
45766: CALL_OW 1
45770: ST_TO_ADDR
// end ;
45771: LD_VAR 0 3
45775: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45776: LD_INT 0
45778: PPUSH
45779: PPUSH
// if not mc_bases or not base or not kinds then
45780: LD_EXP 93
45784: NOT
45785: PUSH
45786: LD_VAR 0 1
45790: NOT
45791: OR
45792: PUSH
45793: LD_VAR 0 2
45797: NOT
45798: OR
45799: IFFALSE 45803
// exit ;
45801: GO 45864
// for i in kinds do
45803: LD_ADDR_VAR 0 4
45807: PUSH
45808: LD_VAR 0 2
45812: PUSH
45813: FOR_IN
45814: IFFALSE 45862
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45816: LD_ADDR_EXP 127
45820: PUSH
45821: LD_EXP 127
45825: PPUSH
45826: LD_VAR 0 1
45830: PUSH
45831: LD_EXP 127
45835: PUSH
45836: LD_VAR 0 1
45840: ARRAY
45841: PUSH
45842: LD_INT 1
45844: PLUS
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PPUSH
45850: LD_VAR 0 4
45854: PPUSH
45855: CALL 56474 0 3
45859: ST_TO_ADDR
45860: GO 45813
45862: POP
45863: POP
// end ;
45864: LD_VAR 0 3
45868: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45869: LD_INT 0
45871: PPUSH
// if not mc_bases or not base or not areas then
45872: LD_EXP 93
45876: NOT
45877: PUSH
45878: LD_VAR 0 1
45882: NOT
45883: OR
45884: PUSH
45885: LD_VAR 0 2
45889: NOT
45890: OR
45891: IFFALSE 45895
// exit ;
45893: GO 45920
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45895: LD_ADDR_EXP 111
45899: PUSH
45900: LD_EXP 111
45904: PPUSH
45905: LD_VAR 0 1
45909: PPUSH
45910: LD_VAR 0 2
45914: PPUSH
45915: CALL_OW 1
45919: ST_TO_ADDR
// end ;
45920: LD_VAR 0 3
45924: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45925: LD_INT 0
45927: PPUSH
// if not mc_bases or not base or not teleports_exit then
45928: LD_EXP 93
45932: NOT
45933: PUSH
45934: LD_VAR 0 1
45938: NOT
45939: OR
45940: PUSH
45941: LD_VAR 0 2
45945: NOT
45946: OR
45947: IFFALSE 45951
// exit ;
45949: GO 45976
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45951: LD_ADDR_EXP 128
45955: PUSH
45956: LD_EXP 128
45960: PPUSH
45961: LD_VAR 0 1
45965: PPUSH
45966: LD_VAR 0 2
45970: PPUSH
45971: CALL_OW 1
45975: ST_TO_ADDR
// end ;
45976: LD_VAR 0 3
45980: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45981: LD_INT 0
45983: PPUSH
45984: PPUSH
45985: PPUSH
// if not mc_bases or not base or not ext_list then
45986: LD_EXP 93
45990: NOT
45991: PUSH
45992: LD_VAR 0 1
45996: NOT
45997: OR
45998: PUSH
45999: LD_VAR 0 5
46003: NOT
46004: OR
46005: IFFALSE 46009
// exit ;
46007: GO 46182
// tmp := GetFacExtXYD ( x , y , d ) ;
46009: LD_ADDR_VAR 0 8
46013: PUSH
46014: LD_VAR 0 2
46018: PPUSH
46019: LD_VAR 0 3
46023: PPUSH
46024: LD_VAR 0 4
46028: PPUSH
46029: CALL 85861 0 3
46033: ST_TO_ADDR
// if not tmp then
46034: LD_VAR 0 8
46038: NOT
46039: IFFALSE 46043
// exit ;
46041: GO 46182
// for i in tmp do
46043: LD_ADDR_VAR 0 7
46047: PUSH
46048: LD_VAR 0 8
46052: PUSH
46053: FOR_IN
46054: IFFALSE 46180
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46056: LD_ADDR_EXP 98
46060: PUSH
46061: LD_EXP 98
46065: PPUSH
46066: LD_VAR 0 1
46070: PPUSH
46071: LD_EXP 98
46075: PUSH
46076: LD_VAR 0 1
46080: ARRAY
46081: PPUSH
46082: LD_EXP 98
46086: PUSH
46087: LD_VAR 0 1
46091: ARRAY
46092: PUSH
46093: LD_INT 1
46095: PLUS
46096: PPUSH
46097: LD_VAR 0 5
46101: PUSH
46102: LD_INT 1
46104: ARRAY
46105: PUSH
46106: LD_VAR 0 7
46110: PUSH
46111: LD_INT 1
46113: ARRAY
46114: PUSH
46115: LD_VAR 0 7
46119: PUSH
46120: LD_INT 2
46122: ARRAY
46123: PUSH
46124: LD_VAR 0 7
46128: PUSH
46129: LD_INT 3
46131: ARRAY
46132: PUSH
46133: EMPTY
46134: LIST
46135: LIST
46136: LIST
46137: LIST
46138: PPUSH
46139: CALL_OW 2
46143: PPUSH
46144: CALL_OW 1
46148: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46149: LD_ADDR_VAR 0 5
46153: PUSH
46154: LD_VAR 0 5
46158: PPUSH
46159: LD_INT 1
46161: PPUSH
46162: CALL_OW 3
46166: ST_TO_ADDR
// if not ext_list then
46167: LD_VAR 0 5
46171: NOT
46172: IFFALSE 46178
// exit ;
46174: POP
46175: POP
46176: GO 46182
// end ;
46178: GO 46053
46180: POP
46181: POP
// end ;
46182: LD_VAR 0 6
46186: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46187: LD_INT 0
46189: PPUSH
// if not mc_bases or not base or not weapon_list then
46190: LD_EXP 93
46194: NOT
46195: PUSH
46196: LD_VAR 0 1
46200: NOT
46201: OR
46202: PUSH
46203: LD_VAR 0 2
46207: NOT
46208: OR
46209: IFFALSE 46213
// exit ;
46211: GO 46238
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46213: LD_ADDR_EXP 132
46217: PUSH
46218: LD_EXP 132
46222: PPUSH
46223: LD_VAR 0 1
46227: PPUSH
46228: LD_VAR 0 2
46232: PPUSH
46233: CALL_OW 1
46237: ST_TO_ADDR
// end ;
46238: LD_VAR 0 3
46242: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46243: LD_INT 0
46245: PPUSH
// if not mc_bases or not base or not tech_list then
46246: LD_EXP 93
46250: NOT
46251: PUSH
46252: LD_VAR 0 1
46256: NOT
46257: OR
46258: PUSH
46259: LD_VAR 0 2
46263: NOT
46264: OR
46265: IFFALSE 46269
// exit ;
46267: GO 46294
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46269: LD_ADDR_EXP 120
46273: PUSH
46274: LD_EXP 120
46278: PPUSH
46279: LD_VAR 0 1
46283: PPUSH
46284: LD_VAR 0 2
46288: PPUSH
46289: CALL_OW 1
46293: ST_TO_ADDR
// end ;
46294: LD_VAR 0 3
46298: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46299: LD_INT 0
46301: PPUSH
// if not mc_bases or not parking_area or not base then
46302: LD_EXP 93
46306: NOT
46307: PUSH
46308: LD_VAR 0 2
46312: NOT
46313: OR
46314: PUSH
46315: LD_VAR 0 1
46319: NOT
46320: OR
46321: IFFALSE 46325
// exit ;
46323: GO 46350
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46325: LD_ADDR_EXP 117
46329: PUSH
46330: LD_EXP 117
46334: PPUSH
46335: LD_VAR 0 1
46339: PPUSH
46340: LD_VAR 0 2
46344: PPUSH
46345: CALL_OW 1
46349: ST_TO_ADDR
// end ;
46350: LD_VAR 0 3
46354: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46355: LD_INT 0
46357: PPUSH
// if not mc_bases or not base or not scan_area then
46358: LD_EXP 93
46362: NOT
46363: PUSH
46364: LD_VAR 0 1
46368: NOT
46369: OR
46370: PUSH
46371: LD_VAR 0 2
46375: NOT
46376: OR
46377: IFFALSE 46381
// exit ;
46379: GO 46406
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46381: LD_ADDR_EXP 118
46385: PUSH
46386: LD_EXP 118
46390: PPUSH
46391: LD_VAR 0 1
46395: PPUSH
46396: LD_VAR 0 2
46400: PPUSH
46401: CALL_OW 1
46405: ST_TO_ADDR
// end ;
46406: LD_VAR 0 3
46410: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46411: LD_INT 0
46413: PPUSH
46414: PPUSH
// if not mc_bases or not base then
46415: LD_EXP 93
46419: NOT
46420: PUSH
46421: LD_VAR 0 1
46425: NOT
46426: OR
46427: IFFALSE 46431
// exit ;
46429: GO 46495
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46431: LD_ADDR_VAR 0 3
46435: PUSH
46436: LD_INT 1
46438: PUSH
46439: LD_INT 2
46441: PUSH
46442: LD_INT 3
46444: PUSH
46445: LD_INT 4
46447: PUSH
46448: LD_INT 11
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46458: LD_ADDR_EXP 120
46462: PUSH
46463: LD_EXP 120
46467: PPUSH
46468: LD_VAR 0 1
46472: PPUSH
46473: LD_EXP 120
46477: PUSH
46478: LD_VAR 0 1
46482: ARRAY
46483: PUSH
46484: LD_VAR 0 3
46488: DIFF
46489: PPUSH
46490: CALL_OW 1
46494: ST_TO_ADDR
// end ;
46495: LD_VAR 0 2
46499: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
46500: LD_INT 0
46502: PPUSH
// result := mc_vehicles [ base ] ;
46503: LD_ADDR_VAR 0 3
46507: PUSH
46508: LD_EXP 112
46512: PUSH
46513: LD_VAR 0 1
46517: ARRAY
46518: ST_TO_ADDR
// if onlyCombat then
46519: LD_VAR 0 2
46523: IFFALSE 46701
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
46525: LD_ADDR_VAR 0 3
46529: PUSH
46530: LD_VAR 0 3
46534: PUSH
46535: LD_VAR 0 3
46539: PPUSH
46540: LD_INT 2
46542: PUSH
46543: LD_INT 34
46545: PUSH
46546: LD_INT 12
46548: PUSH
46549: EMPTY
46550: LIST
46551: LIST
46552: PUSH
46553: LD_INT 34
46555: PUSH
46556: LD_INT 51
46558: PUSH
46559: EMPTY
46560: LIST
46561: LIST
46562: PUSH
46563: LD_INT 34
46565: PUSH
46566: LD_EXP 73
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 34
46577: PUSH
46578: LD_INT 32
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: PUSH
46585: LD_INT 34
46587: PUSH
46588: LD_INT 13
46590: PUSH
46591: EMPTY
46592: LIST
46593: LIST
46594: PUSH
46595: LD_INT 34
46597: PUSH
46598: LD_INT 52
46600: PUSH
46601: EMPTY
46602: LIST
46603: LIST
46604: PUSH
46605: LD_INT 34
46607: PUSH
46608: LD_EXP 78
46612: PUSH
46613: EMPTY
46614: LIST
46615: LIST
46616: PUSH
46617: LD_INT 34
46619: PUSH
46620: LD_INT 14
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PUSH
46627: LD_INT 34
46629: PUSH
46630: LD_INT 53
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: LD_INT 34
46639: PUSH
46640: LD_EXP 72
46644: PUSH
46645: EMPTY
46646: LIST
46647: LIST
46648: PUSH
46649: LD_INT 34
46651: PUSH
46652: LD_INT 31
46654: PUSH
46655: EMPTY
46656: LIST
46657: LIST
46658: PUSH
46659: LD_INT 34
46661: PUSH
46662: LD_INT 48
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: PUSH
46669: LD_INT 34
46671: PUSH
46672: LD_INT 8
46674: PUSH
46675: EMPTY
46676: LIST
46677: LIST
46678: PUSH
46679: EMPTY
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: LIST
46692: LIST
46693: LIST
46694: PPUSH
46695: CALL_OW 72
46699: DIFF
46700: ST_TO_ADDR
// end ; end_of_file
46701: LD_VAR 0 3
46705: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46706: LD_INT 0
46708: PPUSH
46709: PPUSH
46710: PPUSH
// if not mc_bases or not skirmish then
46711: LD_EXP 93
46715: NOT
46716: PUSH
46717: LD_EXP 91
46721: NOT
46722: OR
46723: IFFALSE 46727
// exit ;
46725: GO 46892
// for i = 1 to mc_bases do
46727: LD_ADDR_VAR 0 4
46731: PUSH
46732: DOUBLE
46733: LD_INT 1
46735: DEC
46736: ST_TO_ADDR
46737: LD_EXP 93
46741: PUSH
46742: FOR_TO
46743: IFFALSE 46890
// begin if sci in mc_bases [ i ] then
46745: LD_VAR 0 2
46749: PUSH
46750: LD_EXP 93
46754: PUSH
46755: LD_VAR 0 4
46759: ARRAY
46760: IN
46761: IFFALSE 46888
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46763: LD_ADDR_EXP 122
46767: PUSH
46768: LD_EXP 122
46772: PPUSH
46773: LD_VAR 0 4
46777: PUSH
46778: LD_EXP 122
46782: PUSH
46783: LD_VAR 0 4
46787: ARRAY
46788: PUSH
46789: LD_INT 1
46791: PLUS
46792: PUSH
46793: EMPTY
46794: LIST
46795: LIST
46796: PPUSH
46797: LD_VAR 0 1
46801: PPUSH
46802: CALL 56474 0 3
46806: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46807: LD_ADDR_VAR 0 5
46811: PUSH
46812: LD_EXP 93
46816: PUSH
46817: LD_VAR 0 4
46821: ARRAY
46822: PPUSH
46823: LD_INT 2
46825: PUSH
46826: LD_INT 30
46828: PUSH
46829: LD_INT 0
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 30
46838: PUSH
46839: LD_INT 1
46841: PUSH
46842: EMPTY
46843: LIST
46844: LIST
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: LIST
46850: PPUSH
46851: CALL_OW 72
46855: PPUSH
46856: LD_VAR 0 1
46860: PPUSH
46861: CALL_OW 74
46865: ST_TO_ADDR
// if tmp then
46866: LD_VAR 0 5
46870: IFFALSE 46886
// ComStandNearbyBuilding ( ape , tmp ) ;
46872: LD_VAR 0 1
46876: PPUSH
46877: LD_VAR 0 5
46881: PPUSH
46882: CALL 53052 0 2
// break ;
46886: GO 46890
// end ; end ;
46888: GO 46742
46890: POP
46891: POP
// end ;
46892: LD_VAR 0 3
46896: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46897: LD_INT 0
46899: PPUSH
46900: PPUSH
46901: PPUSH
// if not mc_bases or not skirmish then
46902: LD_EXP 93
46906: NOT
46907: PUSH
46908: LD_EXP 91
46912: NOT
46913: OR
46914: IFFALSE 46918
// exit ;
46916: GO 47007
// for i = 1 to mc_bases do
46918: LD_ADDR_VAR 0 4
46922: PUSH
46923: DOUBLE
46924: LD_INT 1
46926: DEC
46927: ST_TO_ADDR
46928: LD_EXP 93
46932: PUSH
46933: FOR_TO
46934: IFFALSE 47005
// begin if building in mc_busy_turret_list [ i ] then
46936: LD_VAR 0 1
46940: PUSH
46941: LD_EXP 103
46945: PUSH
46946: LD_VAR 0 4
46950: ARRAY
46951: IN
46952: IFFALSE 47003
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46954: LD_ADDR_VAR 0 5
46958: PUSH
46959: LD_EXP 103
46963: PUSH
46964: LD_VAR 0 4
46968: ARRAY
46969: PUSH
46970: LD_VAR 0 1
46974: DIFF
46975: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46976: LD_ADDR_EXP 103
46980: PUSH
46981: LD_EXP 103
46985: PPUSH
46986: LD_VAR 0 4
46990: PPUSH
46991: LD_VAR 0 5
46995: PPUSH
46996: CALL_OW 1
47000: ST_TO_ADDR
// break ;
47001: GO 47005
// end ; end ;
47003: GO 46933
47005: POP
47006: POP
// end ;
47007: LD_VAR 0 3
47011: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47012: LD_INT 0
47014: PPUSH
47015: PPUSH
47016: PPUSH
// if not mc_bases or not skirmish then
47017: LD_EXP 93
47021: NOT
47022: PUSH
47023: LD_EXP 91
47027: NOT
47028: OR
47029: IFFALSE 47033
// exit ;
47031: GO 47232
// for i = 1 to mc_bases do
47033: LD_ADDR_VAR 0 5
47037: PUSH
47038: DOUBLE
47039: LD_INT 1
47041: DEC
47042: ST_TO_ADDR
47043: LD_EXP 93
47047: PUSH
47048: FOR_TO
47049: IFFALSE 47230
// if building in mc_bases [ i ] then
47051: LD_VAR 0 1
47055: PUSH
47056: LD_EXP 93
47060: PUSH
47061: LD_VAR 0 5
47065: ARRAY
47066: IN
47067: IFFALSE 47228
// begin tmp := mc_bases [ i ] diff building ;
47069: LD_ADDR_VAR 0 6
47073: PUSH
47074: LD_EXP 93
47078: PUSH
47079: LD_VAR 0 5
47083: ARRAY
47084: PUSH
47085: LD_VAR 0 1
47089: DIFF
47090: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47091: LD_ADDR_EXP 93
47095: PUSH
47096: LD_EXP 93
47100: PPUSH
47101: LD_VAR 0 5
47105: PPUSH
47106: LD_VAR 0 6
47110: PPUSH
47111: CALL_OW 1
47115: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47116: LD_VAR 0 1
47120: PUSH
47121: LD_EXP 101
47125: PUSH
47126: LD_VAR 0 5
47130: ARRAY
47131: IN
47132: IFFALSE 47171
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47134: LD_ADDR_EXP 101
47138: PUSH
47139: LD_EXP 101
47143: PPUSH
47144: LD_VAR 0 5
47148: PPUSH
47149: LD_EXP 101
47153: PUSH
47154: LD_VAR 0 5
47158: ARRAY
47159: PUSH
47160: LD_VAR 0 1
47164: DIFF
47165: PPUSH
47166: CALL_OW 1
47170: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47171: LD_VAR 0 1
47175: PUSH
47176: LD_EXP 102
47180: PUSH
47181: LD_VAR 0 5
47185: ARRAY
47186: IN
47187: IFFALSE 47226
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47189: LD_ADDR_EXP 102
47193: PUSH
47194: LD_EXP 102
47198: PPUSH
47199: LD_VAR 0 5
47203: PPUSH
47204: LD_EXP 102
47208: PUSH
47209: LD_VAR 0 5
47213: ARRAY
47214: PUSH
47215: LD_VAR 0 1
47219: DIFF
47220: PPUSH
47221: CALL_OW 1
47225: ST_TO_ADDR
// break ;
47226: GO 47230
// end ;
47228: GO 47048
47230: POP
47231: POP
// end ;
47232: LD_VAR 0 4
47236: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47237: LD_INT 0
47239: PPUSH
47240: PPUSH
47241: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47242: LD_EXP 93
47246: NOT
47247: PUSH
47248: LD_EXP 91
47252: NOT
47253: OR
47254: PUSH
47255: LD_VAR 0 3
47259: PUSH
47260: LD_EXP 119
47264: IN
47265: NOT
47266: OR
47267: IFFALSE 47271
// exit ;
47269: GO 47394
// for i = 1 to mc_vehicles do
47271: LD_ADDR_VAR 0 6
47275: PUSH
47276: DOUBLE
47277: LD_INT 1
47279: DEC
47280: ST_TO_ADDR
47281: LD_EXP 112
47285: PUSH
47286: FOR_TO
47287: IFFALSE 47392
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47289: LD_VAR 0 2
47293: PUSH
47294: LD_EXP 112
47298: PUSH
47299: LD_VAR 0 6
47303: ARRAY
47304: IN
47305: PUSH
47306: LD_VAR 0 1
47310: PUSH
47311: LD_EXP 112
47315: PUSH
47316: LD_VAR 0 6
47320: ARRAY
47321: IN
47322: OR
47323: IFFALSE 47390
// begin tmp := mc_vehicles [ i ] diff old ;
47325: LD_ADDR_VAR 0 7
47329: PUSH
47330: LD_EXP 112
47334: PUSH
47335: LD_VAR 0 6
47339: ARRAY
47340: PUSH
47341: LD_VAR 0 2
47345: DIFF
47346: ST_TO_ADDR
// tmp := tmp diff new ;
47347: LD_ADDR_VAR 0 7
47351: PUSH
47352: LD_VAR 0 7
47356: PUSH
47357: LD_VAR 0 1
47361: DIFF
47362: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47363: LD_ADDR_EXP 112
47367: PUSH
47368: LD_EXP 112
47372: PPUSH
47373: LD_VAR 0 6
47377: PPUSH
47378: LD_VAR 0 7
47382: PPUSH
47383: CALL_OW 1
47387: ST_TO_ADDR
// break ;
47388: GO 47392
// end ;
47390: GO 47286
47392: POP
47393: POP
// end ;
47394: LD_VAR 0 5
47398: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47399: LD_INT 0
47401: PPUSH
47402: PPUSH
47403: PPUSH
47404: PPUSH
// if not mc_bases or not skirmish then
47405: LD_EXP 93
47409: NOT
47410: PUSH
47411: LD_EXP 91
47415: NOT
47416: OR
47417: IFFALSE 47421
// exit ;
47419: GO 47813
// side := GetSide ( vehicle ) ;
47421: LD_ADDR_VAR 0 5
47425: PUSH
47426: LD_VAR 0 1
47430: PPUSH
47431: CALL_OW 255
47435: ST_TO_ADDR
// for i = 1 to mc_bases do
47436: LD_ADDR_VAR 0 4
47440: PUSH
47441: DOUBLE
47442: LD_INT 1
47444: DEC
47445: ST_TO_ADDR
47446: LD_EXP 93
47450: PUSH
47451: FOR_TO
47452: IFFALSE 47811
// begin if factory in mc_bases [ i ] then
47454: LD_VAR 0 2
47458: PUSH
47459: LD_EXP 93
47463: PUSH
47464: LD_VAR 0 4
47468: ARRAY
47469: IN
47470: IFFALSE 47809
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47472: LD_EXP 115
47476: PUSH
47477: LD_VAR 0 4
47481: ARRAY
47482: PUSH
47483: LD_EXP 104
47487: PUSH
47488: LD_VAR 0 4
47492: ARRAY
47493: LESS
47494: PUSH
47495: LD_VAR 0 1
47499: PPUSH
47500: CALL_OW 264
47504: PUSH
47505: LD_INT 31
47507: PUSH
47508: LD_INT 32
47510: PUSH
47511: LD_INT 51
47513: PUSH
47514: LD_EXP 73
47518: PUSH
47519: LD_INT 12
47521: PUSH
47522: LD_INT 30
47524: PUSH
47525: LD_EXP 72
47529: PUSH
47530: LD_INT 11
47532: PUSH
47533: LD_INT 53
47535: PUSH
47536: LD_INT 14
47538: PUSH
47539: LD_EXP 76
47543: PUSH
47544: LD_INT 29
47546: PUSH
47547: LD_EXP 74
47551: PUSH
47552: LD_INT 13
47554: PUSH
47555: LD_INT 52
47557: PUSH
47558: LD_EXP 78
47562: PUSH
47563: LD_INT 48
47565: PUSH
47566: LD_INT 8
47568: PUSH
47569: EMPTY
47570: LIST
47571: LIST
47572: LIST
47573: LIST
47574: LIST
47575: LIST
47576: LIST
47577: LIST
47578: LIST
47579: LIST
47580: LIST
47581: LIST
47582: LIST
47583: LIST
47584: LIST
47585: LIST
47586: LIST
47587: LIST
47588: IN
47589: NOT
47590: AND
47591: IFFALSE 47639
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
47593: LD_ADDR_EXP 115
47597: PUSH
47598: LD_EXP 115
47602: PPUSH
47603: LD_VAR 0 4
47607: PUSH
47608: LD_EXP 115
47612: PUSH
47613: LD_VAR 0 4
47617: ARRAY
47618: PUSH
47619: LD_INT 1
47621: PLUS
47622: PUSH
47623: EMPTY
47624: LIST
47625: LIST
47626: PPUSH
47627: LD_VAR 0 1
47631: PPUSH
47632: CALL 56474 0 3
47636: ST_TO_ADDR
47637: GO 47683
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
47639: LD_ADDR_EXP 112
47643: PUSH
47644: LD_EXP 112
47648: PPUSH
47649: LD_VAR 0 4
47653: PUSH
47654: LD_EXP 112
47658: PUSH
47659: LD_VAR 0 4
47663: ARRAY
47664: PUSH
47665: LD_INT 1
47667: PLUS
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: PPUSH
47673: LD_VAR 0 1
47677: PPUSH
47678: CALL 56474 0 3
47682: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
47683: LD_VAR 0 1
47687: PPUSH
47688: CALL_OW 263
47692: PUSH
47693: LD_INT 2
47695: EQUAL
47696: IFFALSE 47725
// begin repeat wait ( 0 0$3 ) ;
47698: LD_INT 105
47700: PPUSH
47701: CALL_OW 67
// Connect ( vehicle ) ;
47705: LD_VAR 0 1
47709: PPUSH
47710: CALL 59445 0 1
// until IsControledBy ( vehicle ) ;
47714: LD_VAR 0 1
47718: PPUSH
47719: CALL_OW 312
47723: IFFALSE 47698
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47725: LD_VAR 0 1
47729: PPUSH
47730: LD_EXP 117
47734: PUSH
47735: LD_VAR 0 4
47739: ARRAY
47740: PPUSH
47741: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47745: LD_VAR 0 1
47749: PPUSH
47750: CALL_OW 263
47754: PUSH
47755: LD_INT 1
47757: NONEQUAL
47758: IFFALSE 47762
// break ;
47760: GO 47811
// repeat wait ( 0 0$1 ) ;
47762: LD_INT 35
47764: PPUSH
47765: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47769: LD_VAR 0 1
47773: PPUSH
47774: LD_EXP 117
47778: PUSH
47779: LD_VAR 0 4
47783: ARRAY
47784: PPUSH
47785: CALL_OW 308
47789: IFFALSE 47762
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47791: LD_VAR 0 1
47795: PPUSH
47796: CALL_OW 311
47800: PPUSH
47801: CALL_OW 121
// exit ;
47805: POP
47806: POP
47807: GO 47813
// end ; end ;
47809: GO 47451
47811: POP
47812: POP
// end ;
47813: LD_VAR 0 3
47817: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47818: LD_INT 0
47820: PPUSH
47821: PPUSH
47822: PPUSH
47823: PPUSH
// if not mc_bases or not skirmish then
47824: LD_EXP 93
47828: NOT
47829: PUSH
47830: LD_EXP 91
47834: NOT
47835: OR
47836: IFFALSE 47840
// exit ;
47838: GO 48193
// repeat wait ( 0 0$1 ) ;
47840: LD_INT 35
47842: PPUSH
47843: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47847: LD_VAR 0 2
47851: PPUSH
47852: LD_VAR 0 3
47856: PPUSH
47857: CALL_OW 284
47861: IFFALSE 47840
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47863: LD_VAR 0 2
47867: PPUSH
47868: LD_VAR 0 3
47872: PPUSH
47873: CALL_OW 283
47877: PUSH
47878: LD_INT 4
47880: EQUAL
47881: IFFALSE 47885
// exit ;
47883: GO 48193
// for i = 1 to mc_bases do
47885: LD_ADDR_VAR 0 7
47889: PUSH
47890: DOUBLE
47891: LD_INT 1
47893: DEC
47894: ST_TO_ADDR
47895: LD_EXP 93
47899: PUSH
47900: FOR_TO
47901: IFFALSE 48191
// begin if mc_crates_area [ i ] then
47903: LD_EXP 111
47907: PUSH
47908: LD_VAR 0 7
47912: ARRAY
47913: IFFALSE 48024
// for j in mc_crates_area [ i ] do
47915: LD_ADDR_VAR 0 8
47919: PUSH
47920: LD_EXP 111
47924: PUSH
47925: LD_VAR 0 7
47929: ARRAY
47930: PUSH
47931: FOR_IN
47932: IFFALSE 48022
// if InArea ( x , y , j ) then
47934: LD_VAR 0 2
47938: PPUSH
47939: LD_VAR 0 3
47943: PPUSH
47944: LD_VAR 0 8
47948: PPUSH
47949: CALL_OW 309
47953: IFFALSE 48020
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47955: LD_ADDR_EXP 109
47959: PUSH
47960: LD_EXP 109
47964: PPUSH
47965: LD_VAR 0 7
47969: PUSH
47970: LD_EXP 109
47974: PUSH
47975: LD_VAR 0 7
47979: ARRAY
47980: PUSH
47981: LD_INT 1
47983: PLUS
47984: PUSH
47985: EMPTY
47986: LIST
47987: LIST
47988: PPUSH
47989: LD_VAR 0 4
47993: PUSH
47994: LD_VAR 0 2
47998: PUSH
47999: LD_VAR 0 3
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: LIST
48008: PPUSH
48009: CALL 56474 0 3
48013: ST_TO_ADDR
// exit ;
48014: POP
48015: POP
48016: POP
48017: POP
48018: GO 48193
// end ;
48020: GO 47931
48022: POP
48023: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48024: LD_ADDR_VAR 0 9
48028: PUSH
48029: LD_EXP 93
48033: PUSH
48034: LD_VAR 0 7
48038: ARRAY
48039: PPUSH
48040: LD_INT 2
48042: PUSH
48043: LD_INT 30
48045: PUSH
48046: LD_INT 0
48048: PUSH
48049: EMPTY
48050: LIST
48051: LIST
48052: PUSH
48053: LD_INT 30
48055: PUSH
48056: LD_INT 1
48058: PUSH
48059: EMPTY
48060: LIST
48061: LIST
48062: PUSH
48063: EMPTY
48064: LIST
48065: LIST
48066: LIST
48067: PPUSH
48068: CALL_OW 72
48072: ST_TO_ADDR
// if not depot then
48073: LD_VAR 0 9
48077: NOT
48078: IFFALSE 48082
// continue ;
48080: GO 47900
// for j in depot do
48082: LD_ADDR_VAR 0 8
48086: PUSH
48087: LD_VAR 0 9
48091: PUSH
48092: FOR_IN
48093: IFFALSE 48187
// if GetDistUnitXY ( j , x , y ) < 30 then
48095: LD_VAR 0 8
48099: PPUSH
48100: LD_VAR 0 2
48104: PPUSH
48105: LD_VAR 0 3
48109: PPUSH
48110: CALL_OW 297
48114: PUSH
48115: LD_INT 30
48117: LESS
48118: IFFALSE 48185
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48120: LD_ADDR_EXP 109
48124: PUSH
48125: LD_EXP 109
48129: PPUSH
48130: LD_VAR 0 7
48134: PUSH
48135: LD_EXP 109
48139: PUSH
48140: LD_VAR 0 7
48144: ARRAY
48145: PUSH
48146: LD_INT 1
48148: PLUS
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PPUSH
48154: LD_VAR 0 4
48158: PUSH
48159: LD_VAR 0 2
48163: PUSH
48164: LD_VAR 0 3
48168: PUSH
48169: EMPTY
48170: LIST
48171: LIST
48172: LIST
48173: PPUSH
48174: CALL 56474 0 3
48178: ST_TO_ADDR
// exit ;
48179: POP
48180: POP
48181: POP
48182: POP
48183: GO 48193
// end ;
48185: GO 48092
48187: POP
48188: POP
// end ;
48189: GO 47900
48191: POP
48192: POP
// end ;
48193: LD_VAR 0 6
48197: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48198: LD_INT 0
48200: PPUSH
48201: PPUSH
48202: PPUSH
48203: PPUSH
// if not mc_bases or not skirmish then
48204: LD_EXP 93
48208: NOT
48209: PUSH
48210: LD_EXP 91
48214: NOT
48215: OR
48216: IFFALSE 48220
// exit ;
48218: GO 48497
// side := GetSide ( lab ) ;
48220: LD_ADDR_VAR 0 4
48224: PUSH
48225: LD_VAR 0 2
48229: PPUSH
48230: CALL_OW 255
48234: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48235: LD_VAR 0 4
48239: PUSH
48240: LD_EXP 119
48244: IN
48245: NOT
48246: PUSH
48247: LD_EXP 120
48251: NOT
48252: OR
48253: PUSH
48254: LD_EXP 93
48258: NOT
48259: OR
48260: IFFALSE 48264
// exit ;
48262: GO 48497
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48264: LD_ADDR_EXP 120
48268: PUSH
48269: LD_EXP 120
48273: PPUSH
48274: LD_VAR 0 4
48278: PPUSH
48279: LD_EXP 120
48283: PUSH
48284: LD_VAR 0 4
48288: ARRAY
48289: PUSH
48290: LD_VAR 0 1
48294: DIFF
48295: PPUSH
48296: CALL_OW 1
48300: ST_TO_ADDR
// for i = 1 to mc_bases do
48301: LD_ADDR_VAR 0 5
48305: PUSH
48306: DOUBLE
48307: LD_INT 1
48309: DEC
48310: ST_TO_ADDR
48311: LD_EXP 93
48315: PUSH
48316: FOR_TO
48317: IFFALSE 48495
// begin if lab in mc_bases [ i ] then
48319: LD_VAR 0 2
48323: PUSH
48324: LD_EXP 93
48328: PUSH
48329: LD_VAR 0 5
48333: ARRAY
48334: IN
48335: IFFALSE 48493
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48337: LD_VAR 0 1
48341: PUSH
48342: LD_INT 11
48344: PUSH
48345: LD_INT 4
48347: PUSH
48348: LD_INT 3
48350: PUSH
48351: LD_INT 2
48353: PUSH
48354: EMPTY
48355: LIST
48356: LIST
48357: LIST
48358: LIST
48359: IN
48360: PUSH
48361: LD_EXP 123
48365: PUSH
48366: LD_VAR 0 5
48370: ARRAY
48371: AND
48372: IFFALSE 48493
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48374: LD_ADDR_VAR 0 6
48378: PUSH
48379: LD_EXP 123
48383: PUSH
48384: LD_VAR 0 5
48388: ARRAY
48389: PUSH
48390: LD_INT 1
48392: ARRAY
48393: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48394: LD_ADDR_EXP 123
48398: PUSH
48399: LD_EXP 123
48403: PPUSH
48404: LD_VAR 0 5
48408: PPUSH
48409: EMPTY
48410: PPUSH
48411: CALL_OW 1
48415: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48416: LD_VAR 0 6
48420: PPUSH
48421: LD_INT 0
48423: PPUSH
48424: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48428: LD_VAR 0 6
48432: PPUSH
48433: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48437: LD_ADDR_EXP 122
48441: PUSH
48442: LD_EXP 122
48446: PPUSH
48447: LD_VAR 0 5
48451: PPUSH
48452: LD_EXP 122
48456: PUSH
48457: LD_VAR 0 5
48461: ARRAY
48462: PPUSH
48463: LD_INT 1
48465: PPUSH
48466: LD_VAR 0 6
48470: PPUSH
48471: CALL_OW 2
48475: PPUSH
48476: CALL_OW 1
48480: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48481: LD_VAR 0 5
48485: PPUSH
48486: LD_INT 112
48488: PPUSH
48489: CALL 25016 0 2
// end ; end ; end ;
48493: GO 48316
48495: POP
48496: POP
// end ;
48497: LD_VAR 0 3
48501: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
48502: LD_INT 0
48504: PPUSH
48505: PPUSH
48506: PPUSH
48507: PPUSH
48508: PPUSH
48509: PPUSH
48510: PPUSH
48511: PPUSH
// if not mc_bases or not skirmish then
48512: LD_EXP 93
48516: NOT
48517: PUSH
48518: LD_EXP 91
48522: NOT
48523: OR
48524: IFFALSE 48528
// exit ;
48526: GO 49899
// for i = 1 to mc_bases do
48528: LD_ADDR_VAR 0 3
48532: PUSH
48533: DOUBLE
48534: LD_INT 1
48536: DEC
48537: ST_TO_ADDR
48538: LD_EXP 93
48542: PUSH
48543: FOR_TO
48544: IFFALSE 49897
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
48546: LD_VAR 0 1
48550: PUSH
48551: LD_EXP 93
48555: PUSH
48556: LD_VAR 0 3
48560: ARRAY
48561: IN
48562: PUSH
48563: LD_VAR 0 1
48567: PUSH
48568: LD_EXP 100
48572: PUSH
48573: LD_VAR 0 3
48577: ARRAY
48578: IN
48579: OR
48580: PUSH
48581: LD_VAR 0 1
48585: PUSH
48586: LD_EXP 115
48590: PUSH
48591: LD_VAR 0 3
48595: ARRAY
48596: IN
48597: OR
48598: PUSH
48599: LD_VAR 0 1
48603: PUSH
48604: LD_EXP 112
48608: PUSH
48609: LD_VAR 0 3
48613: ARRAY
48614: IN
48615: OR
48616: PUSH
48617: LD_VAR 0 1
48621: PUSH
48622: LD_EXP 122
48626: PUSH
48627: LD_VAR 0 3
48631: ARRAY
48632: IN
48633: OR
48634: PUSH
48635: LD_VAR 0 1
48639: PUSH
48640: LD_EXP 123
48644: PUSH
48645: LD_VAR 0 3
48649: ARRAY
48650: IN
48651: OR
48652: IFFALSE 49895
// begin if un in mc_ape [ i ] then
48654: LD_VAR 0 1
48658: PUSH
48659: LD_EXP 122
48663: PUSH
48664: LD_VAR 0 3
48668: ARRAY
48669: IN
48670: IFFALSE 48709
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
48672: LD_ADDR_EXP 122
48676: PUSH
48677: LD_EXP 122
48681: PPUSH
48682: LD_VAR 0 3
48686: PPUSH
48687: LD_EXP 122
48691: PUSH
48692: LD_VAR 0 3
48696: ARRAY
48697: PUSH
48698: LD_VAR 0 1
48702: DIFF
48703: PPUSH
48704: CALL_OW 1
48708: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48709: LD_VAR 0 1
48713: PUSH
48714: LD_EXP 123
48718: PUSH
48719: LD_VAR 0 3
48723: ARRAY
48724: IN
48725: IFFALSE 48749
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48727: LD_ADDR_EXP 123
48731: PUSH
48732: LD_EXP 123
48736: PPUSH
48737: LD_VAR 0 3
48741: PPUSH
48742: EMPTY
48743: PPUSH
48744: CALL_OW 1
48748: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48749: LD_VAR 0 1
48753: PPUSH
48754: CALL_OW 247
48758: PUSH
48759: LD_INT 2
48761: EQUAL
48762: PUSH
48763: LD_VAR 0 1
48767: PPUSH
48768: CALL_OW 110
48772: PUSH
48773: LD_INT 20
48775: EQUAL
48776: PUSH
48777: LD_VAR 0 1
48781: PUSH
48782: LD_EXP 115
48786: PUSH
48787: LD_VAR 0 3
48791: ARRAY
48792: IN
48793: OR
48794: PUSH
48795: LD_VAR 0 1
48799: PPUSH
48800: CALL_OW 264
48804: PUSH
48805: LD_INT 12
48807: PUSH
48808: LD_INT 51
48810: PUSH
48811: LD_EXP 73
48815: PUSH
48816: LD_INT 32
48818: PUSH
48819: LD_INT 13
48821: PUSH
48822: LD_INT 52
48824: PUSH
48825: LD_INT 31
48827: PUSH
48828: EMPTY
48829: LIST
48830: LIST
48831: LIST
48832: LIST
48833: LIST
48834: LIST
48835: LIST
48836: IN
48837: OR
48838: AND
48839: IFFALSE 49147
// begin if un in mc_defender [ i ] then
48841: LD_VAR 0 1
48845: PUSH
48846: LD_EXP 115
48850: PUSH
48851: LD_VAR 0 3
48855: ARRAY
48856: IN
48857: IFFALSE 48896
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48859: LD_ADDR_EXP 115
48863: PUSH
48864: LD_EXP 115
48868: PPUSH
48869: LD_VAR 0 3
48873: PPUSH
48874: LD_EXP 115
48878: PUSH
48879: LD_VAR 0 3
48883: ARRAY
48884: PUSH
48885: LD_VAR 0 1
48889: DIFF
48890: PPUSH
48891: CALL_OW 1
48895: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48896: LD_ADDR_VAR 0 8
48900: PUSH
48901: LD_VAR 0 3
48905: PPUSH
48906: LD_INT 3
48908: PPUSH
48909: CALL 45537 0 2
48913: ST_TO_ADDR
// if fac then
48914: LD_VAR 0 8
48918: IFFALSE 49147
// begin for j in fac do
48920: LD_ADDR_VAR 0 4
48924: PUSH
48925: LD_VAR 0 8
48929: PUSH
48930: FOR_IN
48931: IFFALSE 49145
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48933: LD_ADDR_VAR 0 9
48937: PUSH
48938: LD_VAR 0 8
48942: PPUSH
48943: LD_VAR 0 1
48947: PPUSH
48948: CALL_OW 265
48952: PPUSH
48953: LD_VAR 0 1
48957: PPUSH
48958: CALL_OW 262
48962: PPUSH
48963: LD_VAR 0 1
48967: PPUSH
48968: CALL_OW 263
48972: PPUSH
48973: LD_VAR 0 1
48977: PPUSH
48978: CALL_OW 264
48982: PPUSH
48983: CALL 53970 0 5
48987: ST_TO_ADDR
// if components then
48988: LD_VAR 0 9
48992: IFFALSE 49143
// begin if GetWeapon ( un ) = ar_control_tower then
48994: LD_VAR 0 1
48998: PPUSH
48999: CALL_OW 264
49003: PUSH
49004: LD_INT 31
49006: EQUAL
49007: IFFALSE 49124
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49009: LD_VAR 0 1
49013: PPUSH
49014: CALL_OW 311
49018: PPUSH
49019: LD_INT 0
49021: PPUSH
49022: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49026: LD_ADDR_EXP 133
49030: PUSH
49031: LD_EXP 133
49035: PPUSH
49036: LD_VAR 0 3
49040: PPUSH
49041: LD_EXP 133
49045: PUSH
49046: LD_VAR 0 3
49050: ARRAY
49051: PUSH
49052: LD_VAR 0 1
49056: PPUSH
49057: CALL_OW 311
49061: DIFF
49062: PPUSH
49063: CALL_OW 1
49067: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49068: LD_ADDR_VAR 0 7
49072: PUSH
49073: LD_EXP 114
49077: PUSH
49078: LD_VAR 0 3
49082: ARRAY
49083: PPUSH
49084: LD_INT 1
49086: PPUSH
49087: LD_VAR 0 9
49091: PPUSH
49092: CALL_OW 2
49096: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49097: LD_ADDR_EXP 114
49101: PUSH
49102: LD_EXP 114
49106: PPUSH
49107: LD_VAR 0 3
49111: PPUSH
49112: LD_VAR 0 7
49116: PPUSH
49117: CALL_OW 1
49121: ST_TO_ADDR
// end else
49122: GO 49141
// MC_InsertProduceList ( i , [ components ] ) ;
49124: LD_VAR 0 3
49128: PPUSH
49129: LD_VAR 0 9
49133: PUSH
49134: EMPTY
49135: LIST
49136: PPUSH
49137: CALL 45082 0 2
// break ;
49141: GO 49145
// end ; end ;
49143: GO 48930
49145: POP
49146: POP
// end ; end ; if GetType ( un ) = unit_building then
49147: LD_VAR 0 1
49151: PPUSH
49152: CALL_OW 247
49156: PUSH
49157: LD_INT 3
49159: EQUAL
49160: IFFALSE 49563
// begin btype := GetBType ( un ) ;
49162: LD_ADDR_VAR 0 5
49166: PUSH
49167: LD_VAR 0 1
49171: PPUSH
49172: CALL_OW 266
49176: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49177: LD_VAR 0 5
49181: PUSH
49182: LD_INT 29
49184: PUSH
49185: LD_INT 30
49187: PUSH
49188: EMPTY
49189: LIST
49190: LIST
49191: IN
49192: IFFALSE 49265
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49194: LD_VAR 0 1
49198: PPUSH
49199: CALL_OW 250
49203: PPUSH
49204: LD_VAR 0 1
49208: PPUSH
49209: CALL_OW 251
49213: PPUSH
49214: LD_VAR 0 1
49218: PPUSH
49219: CALL_OW 255
49223: PPUSH
49224: CALL_OW 440
49228: NOT
49229: IFFALSE 49265
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49231: LD_VAR 0 1
49235: PPUSH
49236: CALL_OW 250
49240: PPUSH
49241: LD_VAR 0 1
49245: PPUSH
49246: CALL_OW 251
49250: PPUSH
49251: LD_VAR 0 1
49255: PPUSH
49256: CALL_OW 255
49260: PPUSH
49261: CALL_OW 441
// end ; if btype = b_warehouse then
49265: LD_VAR 0 5
49269: PUSH
49270: LD_INT 1
49272: EQUAL
49273: IFFALSE 49291
// begin btype := b_depot ;
49275: LD_ADDR_VAR 0 5
49279: PUSH
49280: LD_INT 0
49282: ST_TO_ADDR
// pos := 1 ;
49283: LD_ADDR_VAR 0 6
49287: PUSH
49288: LD_INT 1
49290: ST_TO_ADDR
// end ; if btype = b_factory then
49291: LD_VAR 0 5
49295: PUSH
49296: LD_INT 3
49298: EQUAL
49299: IFFALSE 49317
// begin btype := b_workshop ;
49301: LD_ADDR_VAR 0 5
49305: PUSH
49306: LD_INT 2
49308: ST_TO_ADDR
// pos := 1 ;
49309: LD_ADDR_VAR 0 6
49313: PUSH
49314: LD_INT 1
49316: ST_TO_ADDR
// end ; if btype = b_barracks then
49317: LD_VAR 0 5
49321: PUSH
49322: LD_INT 5
49324: EQUAL
49325: IFFALSE 49335
// btype := b_armoury ;
49327: LD_ADDR_VAR 0 5
49331: PUSH
49332: LD_INT 4
49334: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49335: LD_VAR 0 5
49339: PUSH
49340: LD_INT 7
49342: PUSH
49343: LD_INT 8
49345: PUSH
49346: EMPTY
49347: LIST
49348: LIST
49349: IN
49350: IFFALSE 49360
// btype := b_lab ;
49352: LD_ADDR_VAR 0 5
49356: PUSH
49357: LD_INT 6
49359: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49360: LD_ADDR_EXP 98
49364: PUSH
49365: LD_EXP 98
49369: PPUSH
49370: LD_VAR 0 3
49374: PUSH
49375: LD_EXP 98
49379: PUSH
49380: LD_VAR 0 3
49384: ARRAY
49385: PUSH
49386: LD_INT 1
49388: PLUS
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PPUSH
49394: LD_VAR 0 5
49398: PUSH
49399: LD_VAR 0 1
49403: PPUSH
49404: CALL_OW 250
49408: PUSH
49409: LD_VAR 0 1
49413: PPUSH
49414: CALL_OW 251
49418: PUSH
49419: LD_VAR 0 1
49423: PPUSH
49424: CALL_OW 254
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: LIST
49433: LIST
49434: PPUSH
49435: CALL 56474 0 3
49439: ST_TO_ADDR
// if pos = 1 then
49440: LD_VAR 0 6
49444: PUSH
49445: LD_INT 1
49447: EQUAL
49448: IFFALSE 49563
// begin tmp := mc_build_list [ i ] ;
49450: LD_ADDR_VAR 0 7
49454: PUSH
49455: LD_EXP 98
49459: PUSH
49460: LD_VAR 0 3
49464: ARRAY
49465: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49466: LD_VAR 0 7
49470: PPUSH
49471: LD_INT 2
49473: PUSH
49474: LD_INT 30
49476: PUSH
49477: LD_INT 0
49479: PUSH
49480: EMPTY
49481: LIST
49482: LIST
49483: PUSH
49484: LD_INT 30
49486: PUSH
49487: LD_INT 1
49489: PUSH
49490: EMPTY
49491: LIST
49492: LIST
49493: PUSH
49494: EMPTY
49495: LIST
49496: LIST
49497: LIST
49498: PPUSH
49499: CALL_OW 72
49503: IFFALSE 49513
// pos := 2 ;
49505: LD_ADDR_VAR 0 6
49509: PUSH
49510: LD_INT 2
49512: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
49513: LD_ADDR_VAR 0 7
49517: PUSH
49518: LD_VAR 0 7
49522: PPUSH
49523: LD_VAR 0 6
49527: PPUSH
49528: LD_VAR 0 7
49532: PPUSH
49533: CALL 56800 0 3
49537: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
49538: LD_ADDR_EXP 98
49542: PUSH
49543: LD_EXP 98
49547: PPUSH
49548: LD_VAR 0 3
49552: PPUSH
49553: LD_VAR 0 7
49557: PPUSH
49558: CALL_OW 1
49562: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
49563: LD_VAR 0 1
49567: PUSH
49568: LD_EXP 93
49572: PUSH
49573: LD_VAR 0 3
49577: ARRAY
49578: IN
49579: IFFALSE 49618
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
49581: LD_ADDR_EXP 93
49585: PUSH
49586: LD_EXP 93
49590: PPUSH
49591: LD_VAR 0 3
49595: PPUSH
49596: LD_EXP 93
49600: PUSH
49601: LD_VAR 0 3
49605: ARRAY
49606: PUSH
49607: LD_VAR 0 1
49611: DIFF
49612: PPUSH
49613: CALL_OW 1
49617: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49618: LD_VAR 0 1
49622: PUSH
49623: LD_EXP 100
49627: PUSH
49628: LD_VAR 0 3
49632: ARRAY
49633: IN
49634: IFFALSE 49673
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49636: LD_ADDR_EXP 100
49640: PUSH
49641: LD_EXP 100
49645: PPUSH
49646: LD_VAR 0 3
49650: PPUSH
49651: LD_EXP 100
49655: PUSH
49656: LD_VAR 0 3
49660: ARRAY
49661: PUSH
49662: LD_VAR 0 1
49666: DIFF
49667: PPUSH
49668: CALL_OW 1
49672: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
49673: LD_VAR 0 1
49677: PUSH
49678: LD_EXP 112
49682: PUSH
49683: LD_VAR 0 3
49687: ARRAY
49688: IN
49689: IFFALSE 49728
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
49691: LD_ADDR_EXP 112
49695: PUSH
49696: LD_EXP 112
49700: PPUSH
49701: LD_VAR 0 3
49705: PPUSH
49706: LD_EXP 112
49710: PUSH
49711: LD_VAR 0 3
49715: ARRAY
49716: PUSH
49717: LD_VAR 0 1
49721: DIFF
49722: PPUSH
49723: CALL_OW 1
49727: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49728: LD_VAR 0 1
49732: PUSH
49733: LD_EXP 115
49737: PUSH
49738: LD_VAR 0 3
49742: ARRAY
49743: IN
49744: IFFALSE 49783
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49746: LD_ADDR_EXP 115
49750: PUSH
49751: LD_EXP 115
49755: PPUSH
49756: LD_VAR 0 3
49760: PPUSH
49761: LD_EXP 115
49765: PUSH
49766: LD_VAR 0 3
49770: ARRAY
49771: PUSH
49772: LD_VAR 0 1
49776: DIFF
49777: PPUSH
49778: CALL_OW 1
49782: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49783: LD_VAR 0 1
49787: PUSH
49788: LD_EXP 102
49792: PUSH
49793: LD_VAR 0 3
49797: ARRAY
49798: IN
49799: IFFALSE 49838
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49801: LD_ADDR_EXP 102
49805: PUSH
49806: LD_EXP 102
49810: PPUSH
49811: LD_VAR 0 3
49815: PPUSH
49816: LD_EXP 102
49820: PUSH
49821: LD_VAR 0 3
49825: ARRAY
49826: PUSH
49827: LD_VAR 0 1
49831: DIFF
49832: PPUSH
49833: CALL_OW 1
49837: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49838: LD_VAR 0 1
49842: PUSH
49843: LD_EXP 101
49847: PUSH
49848: LD_VAR 0 3
49852: ARRAY
49853: IN
49854: IFFALSE 49893
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49856: LD_ADDR_EXP 101
49860: PUSH
49861: LD_EXP 101
49865: PPUSH
49866: LD_VAR 0 3
49870: PPUSH
49871: LD_EXP 101
49875: PUSH
49876: LD_VAR 0 3
49880: ARRAY
49881: PUSH
49882: LD_VAR 0 1
49886: DIFF
49887: PPUSH
49888: CALL_OW 1
49892: ST_TO_ADDR
// end ; break ;
49893: GO 49897
// end ;
49895: GO 48543
49897: POP
49898: POP
// end ;
49899: LD_VAR 0 2
49903: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49904: LD_INT 0
49906: PPUSH
49907: PPUSH
49908: PPUSH
// if not mc_bases or not skirmish then
49909: LD_EXP 93
49913: NOT
49914: PUSH
49915: LD_EXP 91
49919: NOT
49920: OR
49921: IFFALSE 49925
// exit ;
49923: GO 50140
// for i = 1 to mc_bases do
49925: LD_ADDR_VAR 0 3
49929: PUSH
49930: DOUBLE
49931: LD_INT 1
49933: DEC
49934: ST_TO_ADDR
49935: LD_EXP 93
49939: PUSH
49940: FOR_TO
49941: IFFALSE 50138
// begin if building in mc_construct_list [ i ] then
49943: LD_VAR 0 1
49947: PUSH
49948: LD_EXP 100
49952: PUSH
49953: LD_VAR 0 3
49957: ARRAY
49958: IN
49959: IFFALSE 50136
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49961: LD_ADDR_EXP 100
49965: PUSH
49966: LD_EXP 100
49970: PPUSH
49971: LD_VAR 0 3
49975: PPUSH
49976: LD_EXP 100
49980: PUSH
49981: LD_VAR 0 3
49985: ARRAY
49986: PUSH
49987: LD_VAR 0 1
49991: DIFF
49992: PPUSH
49993: CALL_OW 1
49997: ST_TO_ADDR
// if building in mc_lab [ i ] then
49998: LD_VAR 0 1
50002: PUSH
50003: LD_EXP 126
50007: PUSH
50008: LD_VAR 0 3
50012: ARRAY
50013: IN
50014: IFFALSE 50069
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50016: LD_ADDR_EXP 127
50020: PUSH
50021: LD_EXP 127
50025: PPUSH
50026: LD_VAR 0 3
50030: PPUSH
50031: LD_EXP 127
50035: PUSH
50036: LD_VAR 0 3
50040: ARRAY
50041: PPUSH
50042: LD_INT 1
50044: PPUSH
50045: LD_EXP 127
50049: PUSH
50050: LD_VAR 0 3
50054: ARRAY
50055: PPUSH
50056: LD_INT 0
50058: PPUSH
50059: CALL 55892 0 4
50063: PPUSH
50064: CALL_OW 1
50068: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50069: LD_VAR 0 1
50073: PUSH
50074: LD_EXP 93
50078: PUSH
50079: LD_VAR 0 3
50083: ARRAY
50084: IN
50085: NOT
50086: IFFALSE 50132
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50088: LD_ADDR_EXP 93
50092: PUSH
50093: LD_EXP 93
50097: PPUSH
50098: LD_VAR 0 3
50102: PUSH
50103: LD_EXP 93
50107: PUSH
50108: LD_VAR 0 3
50112: ARRAY
50113: PUSH
50114: LD_INT 1
50116: PLUS
50117: PUSH
50118: EMPTY
50119: LIST
50120: LIST
50121: PPUSH
50122: LD_VAR 0 1
50126: PPUSH
50127: CALL 56474 0 3
50131: ST_TO_ADDR
// exit ;
50132: POP
50133: POP
50134: GO 50140
// end ; end ;
50136: GO 49940
50138: POP
50139: POP
// end ;
50140: LD_VAR 0 2
50144: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50145: LD_INT 0
50147: PPUSH
50148: PPUSH
50149: PPUSH
50150: PPUSH
50151: PPUSH
50152: PPUSH
50153: PPUSH
// if not mc_bases or not skirmish then
50154: LD_EXP 93
50158: NOT
50159: PUSH
50160: LD_EXP 91
50164: NOT
50165: OR
50166: IFFALSE 50170
// exit ;
50168: GO 50831
// for i = 1 to mc_bases do
50170: LD_ADDR_VAR 0 3
50174: PUSH
50175: DOUBLE
50176: LD_INT 1
50178: DEC
50179: ST_TO_ADDR
50180: LD_EXP 93
50184: PUSH
50185: FOR_TO
50186: IFFALSE 50829
// begin if building in mc_construct_list [ i ] then
50188: LD_VAR 0 1
50192: PUSH
50193: LD_EXP 100
50197: PUSH
50198: LD_VAR 0 3
50202: ARRAY
50203: IN
50204: IFFALSE 50827
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50206: LD_ADDR_EXP 100
50210: PUSH
50211: LD_EXP 100
50215: PPUSH
50216: LD_VAR 0 3
50220: PPUSH
50221: LD_EXP 100
50225: PUSH
50226: LD_VAR 0 3
50230: ARRAY
50231: PUSH
50232: LD_VAR 0 1
50236: DIFF
50237: PPUSH
50238: CALL_OW 1
50242: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50243: LD_ADDR_EXP 93
50247: PUSH
50248: LD_EXP 93
50252: PPUSH
50253: LD_VAR 0 3
50257: PUSH
50258: LD_EXP 93
50262: PUSH
50263: LD_VAR 0 3
50267: ARRAY
50268: PUSH
50269: LD_INT 1
50271: PLUS
50272: PUSH
50273: EMPTY
50274: LIST
50275: LIST
50276: PPUSH
50277: LD_VAR 0 1
50281: PPUSH
50282: CALL 56474 0 3
50286: ST_TO_ADDR
// btype := GetBType ( building ) ;
50287: LD_ADDR_VAR 0 5
50291: PUSH
50292: LD_VAR 0 1
50296: PPUSH
50297: CALL_OW 266
50301: ST_TO_ADDR
// side := GetSide ( building ) ;
50302: LD_ADDR_VAR 0 8
50306: PUSH
50307: LD_VAR 0 1
50311: PPUSH
50312: CALL_OW 255
50316: ST_TO_ADDR
// if btype = b_lab then
50317: LD_VAR 0 5
50321: PUSH
50322: LD_INT 6
50324: EQUAL
50325: IFFALSE 50375
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50327: LD_ADDR_EXP 126
50331: PUSH
50332: LD_EXP 126
50336: PPUSH
50337: LD_VAR 0 3
50341: PUSH
50342: LD_EXP 126
50346: PUSH
50347: LD_VAR 0 3
50351: ARRAY
50352: PUSH
50353: LD_INT 1
50355: PLUS
50356: PUSH
50357: EMPTY
50358: LIST
50359: LIST
50360: PPUSH
50361: LD_VAR 0 1
50365: PPUSH
50366: CALL 56474 0 3
50370: ST_TO_ADDR
// exit ;
50371: POP
50372: POP
50373: GO 50831
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50375: LD_VAR 0 5
50379: PUSH
50380: LD_INT 0
50382: PUSH
50383: LD_INT 2
50385: PUSH
50386: LD_INT 4
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: LIST
50393: IN
50394: IFFALSE 50518
// begin if btype = b_armoury then
50396: LD_VAR 0 5
50400: PUSH
50401: LD_INT 4
50403: EQUAL
50404: IFFALSE 50414
// btype := b_barracks ;
50406: LD_ADDR_VAR 0 5
50410: PUSH
50411: LD_INT 5
50413: ST_TO_ADDR
// if btype = b_depot then
50414: LD_VAR 0 5
50418: PUSH
50419: LD_INT 0
50421: EQUAL
50422: IFFALSE 50432
// btype := b_warehouse ;
50424: LD_ADDR_VAR 0 5
50428: PUSH
50429: LD_INT 1
50431: ST_TO_ADDR
// if btype = b_workshop then
50432: LD_VAR 0 5
50436: PUSH
50437: LD_INT 2
50439: EQUAL
50440: IFFALSE 50450
// btype := b_factory ;
50442: LD_ADDR_VAR 0 5
50446: PUSH
50447: LD_INT 3
50449: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50450: LD_VAR 0 5
50454: PPUSH
50455: LD_VAR 0 8
50459: PPUSH
50460: CALL_OW 323
50464: PUSH
50465: LD_INT 1
50467: EQUAL
50468: IFFALSE 50514
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50470: LD_ADDR_EXP 125
50474: PUSH
50475: LD_EXP 125
50479: PPUSH
50480: LD_VAR 0 3
50484: PUSH
50485: LD_EXP 125
50489: PUSH
50490: LD_VAR 0 3
50494: ARRAY
50495: PUSH
50496: LD_INT 1
50498: PLUS
50499: PUSH
50500: EMPTY
50501: LIST
50502: LIST
50503: PPUSH
50504: LD_VAR 0 1
50508: PPUSH
50509: CALL 56474 0 3
50513: ST_TO_ADDR
// exit ;
50514: POP
50515: POP
50516: GO 50831
// end ; if btype in [ b_bunker , b_turret ] then
50518: LD_VAR 0 5
50522: PUSH
50523: LD_INT 32
50525: PUSH
50526: LD_INT 33
50528: PUSH
50529: EMPTY
50530: LIST
50531: LIST
50532: IN
50533: IFFALSE 50823
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
50535: LD_ADDR_EXP 101
50539: PUSH
50540: LD_EXP 101
50544: PPUSH
50545: LD_VAR 0 3
50549: PUSH
50550: LD_EXP 101
50554: PUSH
50555: LD_VAR 0 3
50559: ARRAY
50560: PUSH
50561: LD_INT 1
50563: PLUS
50564: PUSH
50565: EMPTY
50566: LIST
50567: LIST
50568: PPUSH
50569: LD_VAR 0 1
50573: PPUSH
50574: CALL 56474 0 3
50578: ST_TO_ADDR
// if btype = b_bunker then
50579: LD_VAR 0 5
50583: PUSH
50584: LD_INT 32
50586: EQUAL
50587: IFFALSE 50823
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50589: LD_ADDR_EXP 102
50593: PUSH
50594: LD_EXP 102
50598: PPUSH
50599: LD_VAR 0 3
50603: PUSH
50604: LD_EXP 102
50608: PUSH
50609: LD_VAR 0 3
50613: ARRAY
50614: PUSH
50615: LD_INT 1
50617: PLUS
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PPUSH
50623: LD_VAR 0 1
50627: PPUSH
50628: CALL 56474 0 3
50632: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50633: LD_ADDR_VAR 0 6
50637: PUSH
50638: LD_EXP 93
50642: PUSH
50643: LD_VAR 0 3
50647: ARRAY
50648: PPUSH
50649: LD_INT 25
50651: PUSH
50652: LD_INT 1
50654: PUSH
50655: EMPTY
50656: LIST
50657: LIST
50658: PUSH
50659: LD_INT 3
50661: PUSH
50662: LD_INT 54
50664: PUSH
50665: EMPTY
50666: LIST
50667: PUSH
50668: EMPTY
50669: LIST
50670: LIST
50671: PUSH
50672: EMPTY
50673: LIST
50674: LIST
50675: PPUSH
50676: CALL_OW 72
50680: ST_TO_ADDR
// if tmp then
50681: LD_VAR 0 6
50685: IFFALSE 50691
// exit ;
50687: POP
50688: POP
50689: GO 50831
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
50691: LD_ADDR_VAR 0 6
50695: PUSH
50696: LD_EXP 93
50700: PUSH
50701: LD_VAR 0 3
50705: ARRAY
50706: PPUSH
50707: LD_INT 2
50709: PUSH
50710: LD_INT 30
50712: PUSH
50713: LD_INT 4
50715: PUSH
50716: EMPTY
50717: LIST
50718: LIST
50719: PUSH
50720: LD_INT 30
50722: PUSH
50723: LD_INT 5
50725: PUSH
50726: EMPTY
50727: LIST
50728: LIST
50729: PUSH
50730: EMPTY
50731: LIST
50732: LIST
50733: LIST
50734: PPUSH
50735: CALL_OW 72
50739: ST_TO_ADDR
// if not tmp then
50740: LD_VAR 0 6
50744: NOT
50745: IFFALSE 50751
// exit ;
50747: POP
50748: POP
50749: GO 50831
// for j in tmp do
50751: LD_ADDR_VAR 0 4
50755: PUSH
50756: LD_VAR 0 6
50760: PUSH
50761: FOR_IN
50762: IFFALSE 50821
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50764: LD_ADDR_VAR 0 7
50768: PUSH
50769: LD_VAR 0 4
50773: PPUSH
50774: CALL_OW 313
50778: PPUSH
50779: LD_INT 25
50781: PUSH
50782: LD_INT 1
50784: PUSH
50785: EMPTY
50786: LIST
50787: LIST
50788: PPUSH
50789: CALL_OW 72
50793: ST_TO_ADDR
// if units then
50794: LD_VAR 0 7
50798: IFFALSE 50819
// begin ComExitBuilding ( units [ 1 ] ) ;
50800: LD_VAR 0 7
50804: PUSH
50805: LD_INT 1
50807: ARRAY
50808: PPUSH
50809: CALL_OW 122
// exit ;
50813: POP
50814: POP
50815: POP
50816: POP
50817: GO 50831
// end ; end ;
50819: GO 50761
50821: POP
50822: POP
// end ; end ; exit ;
50823: POP
50824: POP
50825: GO 50831
// end ; end ;
50827: GO 50185
50829: POP
50830: POP
// end ;
50831: LD_VAR 0 2
50835: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50836: LD_INT 0
50838: PPUSH
50839: PPUSH
50840: PPUSH
50841: PPUSH
50842: PPUSH
50843: PPUSH
50844: PPUSH
// if not mc_bases or not skirmish then
50845: LD_EXP 93
50849: NOT
50850: PUSH
50851: LD_EXP 91
50855: NOT
50856: OR
50857: IFFALSE 50861
// exit ;
50859: GO 51126
// btype := GetBType ( building ) ;
50861: LD_ADDR_VAR 0 6
50865: PUSH
50866: LD_VAR 0 1
50870: PPUSH
50871: CALL_OW 266
50875: ST_TO_ADDR
// x := GetX ( building ) ;
50876: LD_ADDR_VAR 0 7
50880: PUSH
50881: LD_VAR 0 1
50885: PPUSH
50886: CALL_OW 250
50890: ST_TO_ADDR
// y := GetY ( building ) ;
50891: LD_ADDR_VAR 0 8
50895: PUSH
50896: LD_VAR 0 1
50900: PPUSH
50901: CALL_OW 251
50905: ST_TO_ADDR
// d := GetDir ( building ) ;
50906: LD_ADDR_VAR 0 9
50910: PUSH
50911: LD_VAR 0 1
50915: PPUSH
50916: CALL_OW 254
50920: ST_TO_ADDR
// for i = 1 to mc_bases do
50921: LD_ADDR_VAR 0 4
50925: PUSH
50926: DOUBLE
50927: LD_INT 1
50929: DEC
50930: ST_TO_ADDR
50931: LD_EXP 93
50935: PUSH
50936: FOR_TO
50937: IFFALSE 51124
// begin if not mc_build_list [ i ] then
50939: LD_EXP 98
50943: PUSH
50944: LD_VAR 0 4
50948: ARRAY
50949: NOT
50950: IFFALSE 50954
// continue ;
50952: GO 50936
// for j := 1 to mc_build_list [ i ] do
50954: LD_ADDR_VAR 0 5
50958: PUSH
50959: DOUBLE
50960: LD_INT 1
50962: DEC
50963: ST_TO_ADDR
50964: LD_EXP 98
50968: PUSH
50969: LD_VAR 0 4
50973: ARRAY
50974: PUSH
50975: FOR_TO
50976: IFFALSE 51120
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
50978: LD_VAR 0 6
50982: PUSH
50983: LD_VAR 0 7
50987: PUSH
50988: LD_VAR 0 8
50992: PUSH
50993: LD_VAR 0 9
50997: PUSH
50998: EMPTY
50999: LIST
51000: LIST
51001: LIST
51002: LIST
51003: PPUSH
51004: LD_EXP 98
51008: PUSH
51009: LD_VAR 0 4
51013: ARRAY
51014: PUSH
51015: LD_VAR 0 5
51019: ARRAY
51020: PPUSH
51021: CALL 62656 0 2
51025: IFFALSE 51118
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51027: LD_ADDR_EXP 98
51031: PUSH
51032: LD_EXP 98
51036: PPUSH
51037: LD_VAR 0 4
51041: PPUSH
51042: LD_EXP 98
51046: PUSH
51047: LD_VAR 0 4
51051: ARRAY
51052: PPUSH
51053: LD_VAR 0 5
51057: PPUSH
51058: CALL_OW 3
51062: PPUSH
51063: CALL_OW 1
51067: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51068: LD_ADDR_EXP 100
51072: PUSH
51073: LD_EXP 100
51077: PPUSH
51078: LD_VAR 0 4
51082: PUSH
51083: LD_EXP 100
51087: PUSH
51088: LD_VAR 0 4
51092: ARRAY
51093: PUSH
51094: LD_INT 1
51096: PLUS
51097: PUSH
51098: EMPTY
51099: LIST
51100: LIST
51101: PPUSH
51102: LD_VAR 0 1
51106: PPUSH
51107: CALL 56474 0 3
51111: ST_TO_ADDR
// exit ;
51112: POP
51113: POP
51114: POP
51115: POP
51116: GO 51126
// end ;
51118: GO 50975
51120: POP
51121: POP
// end ;
51122: GO 50936
51124: POP
51125: POP
// end ;
51126: LD_VAR 0 3
51130: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51131: LD_INT 0
51133: PPUSH
51134: PPUSH
51135: PPUSH
// if not mc_bases or not skirmish then
51136: LD_EXP 93
51140: NOT
51141: PUSH
51142: LD_EXP 91
51146: NOT
51147: OR
51148: IFFALSE 51152
// exit ;
51150: GO 51342
// for i = 1 to mc_bases do
51152: LD_ADDR_VAR 0 4
51156: PUSH
51157: DOUBLE
51158: LD_INT 1
51160: DEC
51161: ST_TO_ADDR
51162: LD_EXP 93
51166: PUSH
51167: FOR_TO
51168: IFFALSE 51255
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51170: LD_VAR 0 1
51174: PUSH
51175: LD_EXP 101
51179: PUSH
51180: LD_VAR 0 4
51184: ARRAY
51185: IN
51186: PUSH
51187: LD_VAR 0 1
51191: PUSH
51192: LD_EXP 102
51196: PUSH
51197: LD_VAR 0 4
51201: ARRAY
51202: IN
51203: NOT
51204: AND
51205: IFFALSE 51253
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51207: LD_ADDR_EXP 102
51211: PUSH
51212: LD_EXP 102
51216: PPUSH
51217: LD_VAR 0 4
51221: PUSH
51222: LD_EXP 102
51226: PUSH
51227: LD_VAR 0 4
51231: ARRAY
51232: PUSH
51233: LD_INT 1
51235: PLUS
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: PPUSH
51241: LD_VAR 0 1
51245: PPUSH
51246: CALL 56474 0 3
51250: ST_TO_ADDR
// break ;
51251: GO 51255
// end ; end ;
51253: GO 51167
51255: POP
51256: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51257: LD_VAR 0 1
51261: PPUSH
51262: CALL_OW 257
51266: PUSH
51267: LD_EXP 119
51271: IN
51272: PUSH
51273: LD_VAR 0 1
51277: PPUSH
51278: CALL_OW 266
51282: PUSH
51283: LD_INT 5
51285: EQUAL
51286: AND
51287: PUSH
51288: LD_VAR 0 2
51292: PPUSH
51293: CALL_OW 110
51297: PUSH
51298: LD_INT 18
51300: NONEQUAL
51301: AND
51302: IFFALSE 51342
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51304: LD_VAR 0 2
51308: PPUSH
51309: CALL_OW 257
51313: PUSH
51314: LD_INT 5
51316: PUSH
51317: LD_INT 8
51319: PUSH
51320: LD_INT 9
51322: PUSH
51323: EMPTY
51324: LIST
51325: LIST
51326: LIST
51327: IN
51328: IFFALSE 51342
// SetClass ( unit , 1 ) ;
51330: LD_VAR 0 2
51334: PPUSH
51335: LD_INT 1
51337: PPUSH
51338: CALL_OW 336
// end ;
51342: LD_VAR 0 3
51346: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51347: LD_INT 0
51349: PPUSH
51350: PPUSH
// if not mc_bases or not skirmish then
51351: LD_EXP 93
51355: NOT
51356: PUSH
51357: LD_EXP 91
51361: NOT
51362: OR
51363: IFFALSE 51367
// exit ;
51365: GO 51483
// if GetLives ( abandoned_vehicle ) > 250 then
51367: LD_VAR 0 2
51371: PPUSH
51372: CALL_OW 256
51376: PUSH
51377: LD_INT 250
51379: GREATER
51380: IFFALSE 51384
// exit ;
51382: GO 51483
// for i = 1 to mc_bases do
51384: LD_ADDR_VAR 0 6
51388: PUSH
51389: DOUBLE
51390: LD_INT 1
51392: DEC
51393: ST_TO_ADDR
51394: LD_EXP 93
51398: PUSH
51399: FOR_TO
51400: IFFALSE 51481
// begin if driver in mc_bases [ i ] then
51402: LD_VAR 0 1
51406: PUSH
51407: LD_EXP 93
51411: PUSH
51412: LD_VAR 0 6
51416: ARRAY
51417: IN
51418: IFFALSE 51479
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51420: LD_VAR 0 1
51424: PPUSH
51425: LD_EXP 93
51429: PUSH
51430: LD_VAR 0 6
51434: ARRAY
51435: PPUSH
51436: LD_INT 2
51438: PUSH
51439: LD_INT 30
51441: PUSH
51442: LD_INT 0
51444: PUSH
51445: EMPTY
51446: LIST
51447: LIST
51448: PUSH
51449: LD_INT 30
51451: PUSH
51452: LD_INT 1
51454: PUSH
51455: EMPTY
51456: LIST
51457: LIST
51458: PUSH
51459: EMPTY
51460: LIST
51461: LIST
51462: LIST
51463: PPUSH
51464: CALL_OW 72
51468: PUSH
51469: LD_INT 1
51471: ARRAY
51472: PPUSH
51473: CALL 89092 0 2
// break ;
51477: GO 51481
// end ; end ;
51479: GO 51399
51481: POP
51482: POP
// end ; end_of_file
51483: LD_VAR 0 5
51487: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51488: LD_INT 0
51490: PPUSH
51491: PPUSH
// if exist_mode then
51492: LD_VAR 0 2
51496: IFFALSE 51521
// unit := CreateCharacter ( prefix & ident ) else
51498: LD_ADDR_VAR 0 5
51502: PUSH
51503: LD_VAR 0 3
51507: PUSH
51508: LD_VAR 0 1
51512: STR
51513: PPUSH
51514: CALL_OW 34
51518: ST_TO_ADDR
51519: GO 51536
// unit := NewCharacter ( ident ) ;
51521: LD_ADDR_VAR 0 5
51525: PUSH
51526: LD_VAR 0 1
51530: PPUSH
51531: CALL_OW 25
51535: ST_TO_ADDR
// result := unit ;
51536: LD_ADDR_VAR 0 4
51540: PUSH
51541: LD_VAR 0 5
51545: ST_TO_ADDR
// end ;
51546: LD_VAR 0 4
51550: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
51551: LD_INT 0
51553: PPUSH
51554: PPUSH
// if not side or not nation then
51555: LD_VAR 0 1
51559: NOT
51560: PUSH
51561: LD_VAR 0 2
51565: NOT
51566: OR
51567: IFFALSE 51571
// exit ;
51569: GO 52339
// case nation of nation_american :
51571: LD_VAR 0 2
51575: PUSH
51576: LD_INT 1
51578: DOUBLE
51579: EQUAL
51580: IFTRUE 51584
51582: GO 51798
51584: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
51585: LD_ADDR_VAR 0 4
51589: PUSH
51590: LD_INT 35
51592: PUSH
51593: LD_INT 45
51595: PUSH
51596: LD_INT 46
51598: PUSH
51599: LD_INT 47
51601: PUSH
51602: LD_INT 82
51604: PUSH
51605: LD_INT 83
51607: PUSH
51608: LD_INT 84
51610: PUSH
51611: LD_INT 85
51613: PUSH
51614: LD_INT 86
51616: PUSH
51617: LD_INT 1
51619: PUSH
51620: LD_INT 2
51622: PUSH
51623: LD_INT 6
51625: PUSH
51626: LD_INT 15
51628: PUSH
51629: LD_INT 16
51631: PUSH
51632: LD_INT 7
51634: PUSH
51635: LD_INT 12
51637: PUSH
51638: LD_INT 13
51640: PUSH
51641: LD_INT 10
51643: PUSH
51644: LD_INT 14
51646: PUSH
51647: LD_INT 20
51649: PUSH
51650: LD_INT 21
51652: PUSH
51653: LD_INT 22
51655: PUSH
51656: LD_INT 25
51658: PUSH
51659: LD_INT 32
51661: PUSH
51662: LD_INT 27
51664: PUSH
51665: LD_INT 36
51667: PUSH
51668: LD_INT 69
51670: PUSH
51671: LD_INT 39
51673: PUSH
51674: LD_INT 34
51676: PUSH
51677: LD_INT 40
51679: PUSH
51680: LD_INT 48
51682: PUSH
51683: LD_INT 49
51685: PUSH
51686: LD_INT 50
51688: PUSH
51689: LD_INT 51
51691: PUSH
51692: LD_INT 52
51694: PUSH
51695: LD_INT 53
51697: PUSH
51698: LD_INT 54
51700: PUSH
51701: LD_INT 55
51703: PUSH
51704: LD_INT 56
51706: PUSH
51707: LD_INT 57
51709: PUSH
51710: LD_INT 58
51712: PUSH
51713: LD_INT 59
51715: PUSH
51716: LD_INT 60
51718: PUSH
51719: LD_INT 61
51721: PUSH
51722: LD_INT 62
51724: PUSH
51725: LD_INT 80
51727: PUSH
51728: LD_INT 82
51730: PUSH
51731: LD_INT 83
51733: PUSH
51734: LD_INT 84
51736: PUSH
51737: LD_INT 85
51739: PUSH
51740: LD_INT 86
51742: PUSH
51743: EMPTY
51744: LIST
51745: LIST
51746: LIST
51747: LIST
51748: LIST
51749: LIST
51750: LIST
51751: LIST
51752: LIST
51753: LIST
51754: LIST
51755: LIST
51756: LIST
51757: LIST
51758: LIST
51759: LIST
51760: LIST
51761: LIST
51762: LIST
51763: LIST
51764: LIST
51765: LIST
51766: LIST
51767: LIST
51768: LIST
51769: LIST
51770: LIST
51771: LIST
51772: LIST
51773: LIST
51774: LIST
51775: LIST
51776: LIST
51777: LIST
51778: LIST
51779: LIST
51780: LIST
51781: LIST
51782: LIST
51783: LIST
51784: LIST
51785: LIST
51786: LIST
51787: LIST
51788: LIST
51789: LIST
51790: LIST
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: ST_TO_ADDR
51796: GO 52263
51798: LD_INT 2
51800: DOUBLE
51801: EQUAL
51802: IFTRUE 51806
51804: GO 52032
51806: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
51807: LD_ADDR_VAR 0 4
51811: PUSH
51812: LD_INT 35
51814: PUSH
51815: LD_INT 45
51817: PUSH
51818: LD_INT 46
51820: PUSH
51821: LD_INT 47
51823: PUSH
51824: LD_INT 82
51826: PUSH
51827: LD_INT 83
51829: PUSH
51830: LD_INT 84
51832: PUSH
51833: LD_INT 85
51835: PUSH
51836: LD_INT 87
51838: PUSH
51839: LD_INT 70
51841: PUSH
51842: LD_INT 1
51844: PUSH
51845: LD_INT 11
51847: PUSH
51848: LD_INT 3
51850: PUSH
51851: LD_INT 4
51853: PUSH
51854: LD_INT 5
51856: PUSH
51857: LD_INT 6
51859: PUSH
51860: LD_INT 15
51862: PUSH
51863: LD_INT 18
51865: PUSH
51866: LD_INT 7
51868: PUSH
51869: LD_INT 17
51871: PUSH
51872: LD_INT 8
51874: PUSH
51875: LD_INT 20
51877: PUSH
51878: LD_INT 21
51880: PUSH
51881: LD_INT 22
51883: PUSH
51884: LD_INT 72
51886: PUSH
51887: LD_INT 26
51889: PUSH
51890: LD_INT 69
51892: PUSH
51893: LD_INT 39
51895: PUSH
51896: LD_INT 40
51898: PUSH
51899: LD_INT 41
51901: PUSH
51902: LD_INT 42
51904: PUSH
51905: LD_INT 43
51907: PUSH
51908: LD_INT 48
51910: PUSH
51911: LD_INT 49
51913: PUSH
51914: LD_INT 50
51916: PUSH
51917: LD_INT 51
51919: PUSH
51920: LD_INT 52
51922: PUSH
51923: LD_INT 53
51925: PUSH
51926: LD_INT 54
51928: PUSH
51929: LD_INT 55
51931: PUSH
51932: LD_INT 56
51934: PUSH
51935: LD_INT 60
51937: PUSH
51938: LD_INT 61
51940: PUSH
51941: LD_INT 62
51943: PUSH
51944: LD_INT 66
51946: PUSH
51947: LD_INT 67
51949: PUSH
51950: LD_INT 68
51952: PUSH
51953: LD_INT 81
51955: PUSH
51956: LD_INT 82
51958: PUSH
51959: LD_INT 83
51961: PUSH
51962: LD_INT 84
51964: PUSH
51965: LD_INT 85
51967: PUSH
51968: LD_INT 87
51970: PUSH
51971: LD_INT 88
51973: PUSH
51974: EMPTY
51975: LIST
51976: LIST
51977: LIST
51978: LIST
51979: LIST
51980: LIST
51981: LIST
51982: LIST
51983: LIST
51984: LIST
51985: LIST
51986: LIST
51987: LIST
51988: LIST
51989: LIST
51990: LIST
51991: LIST
51992: LIST
51993: LIST
51994: LIST
51995: LIST
51996: LIST
51997: LIST
51998: LIST
51999: LIST
52000: LIST
52001: LIST
52002: LIST
52003: LIST
52004: LIST
52005: LIST
52006: LIST
52007: LIST
52008: LIST
52009: LIST
52010: LIST
52011: LIST
52012: LIST
52013: LIST
52014: LIST
52015: LIST
52016: LIST
52017: LIST
52018: LIST
52019: LIST
52020: LIST
52021: LIST
52022: LIST
52023: LIST
52024: LIST
52025: LIST
52026: LIST
52027: LIST
52028: LIST
52029: ST_TO_ADDR
52030: GO 52263
52032: LD_INT 3
52034: DOUBLE
52035: EQUAL
52036: IFTRUE 52040
52038: GO 52262
52040: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52041: LD_ADDR_VAR 0 4
52045: PUSH
52046: LD_INT 46
52048: PUSH
52049: LD_INT 47
52051: PUSH
52052: LD_INT 1
52054: PUSH
52055: LD_INT 2
52057: PUSH
52058: LD_INT 82
52060: PUSH
52061: LD_INT 83
52063: PUSH
52064: LD_INT 84
52066: PUSH
52067: LD_INT 85
52069: PUSH
52070: LD_INT 86
52072: PUSH
52073: LD_INT 11
52075: PUSH
52076: LD_INT 9
52078: PUSH
52079: LD_INT 20
52081: PUSH
52082: LD_INT 19
52084: PUSH
52085: LD_INT 21
52087: PUSH
52088: LD_INT 24
52090: PUSH
52091: LD_INT 22
52093: PUSH
52094: LD_INT 25
52096: PUSH
52097: LD_INT 28
52099: PUSH
52100: LD_INT 29
52102: PUSH
52103: LD_INT 30
52105: PUSH
52106: LD_INT 31
52108: PUSH
52109: LD_INT 37
52111: PUSH
52112: LD_INT 38
52114: PUSH
52115: LD_INT 32
52117: PUSH
52118: LD_INT 27
52120: PUSH
52121: LD_INT 33
52123: PUSH
52124: LD_INT 69
52126: PUSH
52127: LD_INT 39
52129: PUSH
52130: LD_INT 34
52132: PUSH
52133: LD_INT 40
52135: PUSH
52136: LD_INT 71
52138: PUSH
52139: LD_INT 23
52141: PUSH
52142: LD_INT 44
52144: PUSH
52145: LD_INT 48
52147: PUSH
52148: LD_INT 49
52150: PUSH
52151: LD_INT 50
52153: PUSH
52154: LD_INT 51
52156: PUSH
52157: LD_INT 52
52159: PUSH
52160: LD_INT 53
52162: PUSH
52163: LD_INT 54
52165: PUSH
52166: LD_INT 55
52168: PUSH
52169: LD_INT 56
52171: PUSH
52172: LD_INT 57
52174: PUSH
52175: LD_INT 58
52177: PUSH
52178: LD_INT 59
52180: PUSH
52181: LD_INT 63
52183: PUSH
52184: LD_INT 64
52186: PUSH
52187: LD_INT 65
52189: PUSH
52190: LD_INT 82
52192: PUSH
52193: LD_INT 83
52195: PUSH
52196: LD_INT 84
52198: PUSH
52199: LD_INT 85
52201: PUSH
52202: LD_INT 86
52204: PUSH
52205: EMPTY
52206: LIST
52207: LIST
52208: LIST
52209: LIST
52210: LIST
52211: LIST
52212: LIST
52213: LIST
52214: LIST
52215: LIST
52216: LIST
52217: LIST
52218: LIST
52219: LIST
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: LIST
52226: LIST
52227: LIST
52228: LIST
52229: LIST
52230: LIST
52231: LIST
52232: LIST
52233: LIST
52234: LIST
52235: LIST
52236: LIST
52237: LIST
52238: LIST
52239: LIST
52240: LIST
52241: LIST
52242: LIST
52243: LIST
52244: LIST
52245: LIST
52246: LIST
52247: LIST
52248: LIST
52249: LIST
52250: LIST
52251: LIST
52252: LIST
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: LIST
52258: LIST
52259: ST_TO_ADDR
52260: GO 52263
52262: POP
// if state > - 1 and state < 3 then
52263: LD_VAR 0 3
52267: PUSH
52268: LD_INT 1
52270: NEG
52271: GREATER
52272: PUSH
52273: LD_VAR 0 3
52277: PUSH
52278: LD_INT 3
52280: LESS
52281: AND
52282: IFFALSE 52339
// for i in result do
52284: LD_ADDR_VAR 0 5
52288: PUSH
52289: LD_VAR 0 4
52293: PUSH
52294: FOR_IN
52295: IFFALSE 52337
// if GetTech ( i , side ) <> state then
52297: LD_VAR 0 5
52301: PPUSH
52302: LD_VAR 0 1
52306: PPUSH
52307: CALL_OW 321
52311: PUSH
52312: LD_VAR 0 3
52316: NONEQUAL
52317: IFFALSE 52335
// result := result diff i ;
52319: LD_ADDR_VAR 0 4
52323: PUSH
52324: LD_VAR 0 4
52328: PUSH
52329: LD_VAR 0 5
52333: DIFF
52334: ST_TO_ADDR
52335: GO 52294
52337: POP
52338: POP
// end ;
52339: LD_VAR 0 4
52343: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52344: LD_INT 0
52346: PPUSH
52347: PPUSH
52348: PPUSH
// result := true ;
52349: LD_ADDR_VAR 0 3
52353: PUSH
52354: LD_INT 1
52356: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52357: LD_ADDR_VAR 0 5
52361: PUSH
52362: LD_VAR 0 2
52366: PPUSH
52367: CALL_OW 480
52371: ST_TO_ADDR
// if not tmp then
52372: LD_VAR 0 5
52376: NOT
52377: IFFALSE 52381
// exit ;
52379: GO 52430
// for i in tmp do
52381: LD_ADDR_VAR 0 4
52385: PUSH
52386: LD_VAR 0 5
52390: PUSH
52391: FOR_IN
52392: IFFALSE 52428
// if GetTech ( i , side ) <> state_researched then
52394: LD_VAR 0 4
52398: PPUSH
52399: LD_VAR 0 1
52403: PPUSH
52404: CALL_OW 321
52408: PUSH
52409: LD_INT 2
52411: NONEQUAL
52412: IFFALSE 52426
// begin result := false ;
52414: LD_ADDR_VAR 0 3
52418: PUSH
52419: LD_INT 0
52421: ST_TO_ADDR
// exit ;
52422: POP
52423: POP
52424: GO 52430
// end ;
52426: GO 52391
52428: POP
52429: POP
// end ;
52430: LD_VAR 0 3
52434: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52435: LD_INT 0
52437: PPUSH
52438: PPUSH
52439: PPUSH
52440: PPUSH
52441: PPUSH
52442: PPUSH
52443: PPUSH
52444: PPUSH
52445: PPUSH
52446: PPUSH
52447: PPUSH
52448: PPUSH
52449: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52450: LD_VAR 0 1
52454: NOT
52455: PUSH
52456: LD_VAR 0 1
52460: PPUSH
52461: CALL_OW 257
52465: PUSH
52466: LD_INT 9
52468: NONEQUAL
52469: OR
52470: IFFALSE 52474
// exit ;
52472: GO 53047
// side := GetSide ( unit ) ;
52474: LD_ADDR_VAR 0 9
52478: PUSH
52479: LD_VAR 0 1
52483: PPUSH
52484: CALL_OW 255
52488: ST_TO_ADDR
// tech_space := tech_spacanom ;
52489: LD_ADDR_VAR 0 12
52493: PUSH
52494: LD_INT 29
52496: ST_TO_ADDR
// tech_time := tech_taurad ;
52497: LD_ADDR_VAR 0 13
52501: PUSH
52502: LD_INT 28
52504: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
52505: LD_ADDR_VAR 0 11
52509: PUSH
52510: LD_VAR 0 1
52514: PPUSH
52515: CALL_OW 310
52519: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
52520: LD_VAR 0 11
52524: PPUSH
52525: CALL_OW 247
52529: PUSH
52530: LD_INT 2
52532: EQUAL
52533: IFFALSE 52537
// exit ;
52535: GO 53047
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52537: LD_ADDR_VAR 0 8
52541: PUSH
52542: LD_INT 81
52544: PUSH
52545: LD_VAR 0 9
52549: PUSH
52550: EMPTY
52551: LIST
52552: LIST
52553: PUSH
52554: LD_INT 3
52556: PUSH
52557: LD_INT 21
52559: PUSH
52560: LD_INT 3
52562: PUSH
52563: EMPTY
52564: LIST
52565: LIST
52566: PUSH
52567: EMPTY
52568: LIST
52569: LIST
52570: PUSH
52571: EMPTY
52572: LIST
52573: LIST
52574: PPUSH
52575: CALL_OW 69
52579: ST_TO_ADDR
// if not tmp then
52580: LD_VAR 0 8
52584: NOT
52585: IFFALSE 52589
// exit ;
52587: GO 53047
// if in_unit then
52589: LD_VAR 0 11
52593: IFFALSE 52617
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
52595: LD_ADDR_VAR 0 10
52599: PUSH
52600: LD_VAR 0 8
52604: PPUSH
52605: LD_VAR 0 11
52609: PPUSH
52610: CALL_OW 74
52614: ST_TO_ADDR
52615: GO 52637
// enemy := NearestUnitToUnit ( tmp , unit ) ;
52617: LD_ADDR_VAR 0 10
52621: PUSH
52622: LD_VAR 0 8
52626: PPUSH
52627: LD_VAR 0 1
52631: PPUSH
52632: CALL_OW 74
52636: ST_TO_ADDR
// if not enemy then
52637: LD_VAR 0 10
52641: NOT
52642: IFFALSE 52646
// exit ;
52644: GO 53047
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
52646: LD_VAR 0 11
52650: PUSH
52651: LD_VAR 0 11
52655: PPUSH
52656: LD_VAR 0 10
52660: PPUSH
52661: CALL_OW 296
52665: PUSH
52666: LD_INT 13
52668: GREATER
52669: AND
52670: PUSH
52671: LD_VAR 0 1
52675: PPUSH
52676: LD_VAR 0 10
52680: PPUSH
52681: CALL_OW 296
52685: PUSH
52686: LD_INT 12
52688: GREATER
52689: OR
52690: IFFALSE 52694
// exit ;
52692: GO 53047
// missile := [ 1 ] ;
52694: LD_ADDR_VAR 0 14
52698: PUSH
52699: LD_INT 1
52701: PUSH
52702: EMPTY
52703: LIST
52704: ST_TO_ADDR
// if Researched ( side , tech_space ) then
52705: LD_VAR 0 9
52709: PPUSH
52710: LD_VAR 0 12
52714: PPUSH
52715: CALL_OW 325
52719: IFFALSE 52748
// missile := Insert ( missile , missile + 1 , 2 ) ;
52721: LD_ADDR_VAR 0 14
52725: PUSH
52726: LD_VAR 0 14
52730: PPUSH
52731: LD_VAR 0 14
52735: PUSH
52736: LD_INT 1
52738: PLUS
52739: PPUSH
52740: LD_INT 2
52742: PPUSH
52743: CALL_OW 2
52747: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52748: LD_VAR 0 9
52752: PPUSH
52753: LD_VAR 0 13
52757: PPUSH
52758: CALL_OW 325
52762: PUSH
52763: LD_VAR 0 10
52767: PPUSH
52768: CALL_OW 255
52772: PPUSH
52773: LD_VAR 0 13
52777: PPUSH
52778: CALL_OW 325
52782: NOT
52783: AND
52784: IFFALSE 52813
// missile := Insert ( missile , missile + 1 , 3 ) ;
52786: LD_ADDR_VAR 0 14
52790: PUSH
52791: LD_VAR 0 14
52795: PPUSH
52796: LD_VAR 0 14
52800: PUSH
52801: LD_INT 1
52803: PLUS
52804: PPUSH
52805: LD_INT 3
52807: PPUSH
52808: CALL_OW 2
52812: ST_TO_ADDR
// if missile < 2 then
52813: LD_VAR 0 14
52817: PUSH
52818: LD_INT 2
52820: LESS
52821: IFFALSE 52825
// exit ;
52823: GO 53047
// x := GetX ( enemy ) ;
52825: LD_ADDR_VAR 0 4
52829: PUSH
52830: LD_VAR 0 10
52834: PPUSH
52835: CALL_OW 250
52839: ST_TO_ADDR
// y := GetY ( enemy ) ;
52840: LD_ADDR_VAR 0 5
52844: PUSH
52845: LD_VAR 0 10
52849: PPUSH
52850: CALL_OW 251
52854: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52855: LD_ADDR_VAR 0 6
52859: PUSH
52860: LD_VAR 0 4
52864: PUSH
52865: LD_INT 1
52867: NEG
52868: PPUSH
52869: LD_INT 1
52871: PPUSH
52872: CALL_OW 12
52876: PLUS
52877: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52878: LD_ADDR_VAR 0 7
52882: PUSH
52883: LD_VAR 0 5
52887: PUSH
52888: LD_INT 1
52890: NEG
52891: PPUSH
52892: LD_INT 1
52894: PPUSH
52895: CALL_OW 12
52899: PLUS
52900: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52901: LD_VAR 0 6
52905: PPUSH
52906: LD_VAR 0 7
52910: PPUSH
52911: CALL_OW 488
52915: NOT
52916: IFFALSE 52938
// begin _x := x ;
52918: LD_ADDR_VAR 0 6
52922: PUSH
52923: LD_VAR 0 4
52927: ST_TO_ADDR
// _y := y ;
52928: LD_ADDR_VAR 0 7
52932: PUSH
52933: LD_VAR 0 5
52937: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52938: LD_ADDR_VAR 0 3
52942: PUSH
52943: LD_INT 1
52945: PPUSH
52946: LD_VAR 0 14
52950: PPUSH
52951: CALL_OW 12
52955: ST_TO_ADDR
// case i of 1 :
52956: LD_VAR 0 3
52960: PUSH
52961: LD_INT 1
52963: DOUBLE
52964: EQUAL
52965: IFTRUE 52969
52967: GO 52986
52969: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52970: LD_VAR 0 1
52974: PPUSH
52975: LD_VAR 0 10
52979: PPUSH
52980: CALL_OW 115
52984: GO 53047
52986: LD_INT 2
52988: DOUBLE
52989: EQUAL
52990: IFTRUE 52994
52992: GO 53016
52994: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52995: LD_VAR 0 1
52999: PPUSH
53000: LD_VAR 0 6
53004: PPUSH
53005: LD_VAR 0 7
53009: PPUSH
53010: CALL_OW 153
53014: GO 53047
53016: LD_INT 3
53018: DOUBLE
53019: EQUAL
53020: IFTRUE 53024
53022: GO 53046
53024: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53025: LD_VAR 0 1
53029: PPUSH
53030: LD_VAR 0 6
53034: PPUSH
53035: LD_VAR 0 7
53039: PPUSH
53040: CALL_OW 154
53044: GO 53047
53046: POP
// end ;
53047: LD_VAR 0 2
53051: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53052: LD_INT 0
53054: PPUSH
53055: PPUSH
53056: PPUSH
53057: PPUSH
53058: PPUSH
53059: PPUSH
// if not unit or not building then
53060: LD_VAR 0 1
53064: NOT
53065: PUSH
53066: LD_VAR 0 2
53070: NOT
53071: OR
53072: IFFALSE 53076
// exit ;
53074: GO 53234
// x := GetX ( building ) ;
53076: LD_ADDR_VAR 0 5
53080: PUSH
53081: LD_VAR 0 2
53085: PPUSH
53086: CALL_OW 250
53090: ST_TO_ADDR
// y := GetY ( building ) ;
53091: LD_ADDR_VAR 0 6
53095: PUSH
53096: LD_VAR 0 2
53100: PPUSH
53101: CALL_OW 251
53105: ST_TO_ADDR
// for i = 0 to 5 do
53106: LD_ADDR_VAR 0 4
53110: PUSH
53111: DOUBLE
53112: LD_INT 0
53114: DEC
53115: ST_TO_ADDR
53116: LD_INT 5
53118: PUSH
53119: FOR_TO
53120: IFFALSE 53232
// begin _x := ShiftX ( x , i , 3 ) ;
53122: LD_ADDR_VAR 0 7
53126: PUSH
53127: LD_VAR 0 5
53131: PPUSH
53132: LD_VAR 0 4
53136: PPUSH
53137: LD_INT 3
53139: PPUSH
53140: CALL_OW 272
53144: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53145: LD_ADDR_VAR 0 8
53149: PUSH
53150: LD_VAR 0 6
53154: PPUSH
53155: LD_VAR 0 4
53159: PPUSH
53160: LD_INT 3
53162: PPUSH
53163: CALL_OW 273
53167: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53168: LD_VAR 0 7
53172: PPUSH
53173: LD_VAR 0 8
53177: PPUSH
53178: CALL_OW 488
53182: NOT
53183: IFFALSE 53187
// continue ;
53185: GO 53119
// if HexInfo ( _x , _y ) = 0 then
53187: LD_VAR 0 7
53191: PPUSH
53192: LD_VAR 0 8
53196: PPUSH
53197: CALL_OW 428
53201: PUSH
53202: LD_INT 0
53204: EQUAL
53205: IFFALSE 53230
// begin ComMoveXY ( unit , _x , _y ) ;
53207: LD_VAR 0 1
53211: PPUSH
53212: LD_VAR 0 7
53216: PPUSH
53217: LD_VAR 0 8
53221: PPUSH
53222: CALL_OW 111
// exit ;
53226: POP
53227: POP
53228: GO 53234
// end ; end ;
53230: GO 53119
53232: POP
53233: POP
// end ;
53234: LD_VAR 0 3
53238: RET
// export function ScanBase ( side , base_area ) ; begin
53239: LD_INT 0
53241: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53242: LD_ADDR_VAR 0 3
53246: PUSH
53247: LD_VAR 0 2
53251: PPUSH
53252: LD_INT 81
53254: PUSH
53255: LD_VAR 0 1
53259: PUSH
53260: EMPTY
53261: LIST
53262: LIST
53263: PPUSH
53264: CALL_OW 70
53268: ST_TO_ADDR
// end ;
53269: LD_VAR 0 3
53273: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53274: LD_INT 0
53276: PPUSH
53277: PPUSH
53278: PPUSH
53279: PPUSH
// result := false ;
53280: LD_ADDR_VAR 0 2
53284: PUSH
53285: LD_INT 0
53287: ST_TO_ADDR
// side := GetSide ( unit ) ;
53288: LD_ADDR_VAR 0 3
53292: PUSH
53293: LD_VAR 0 1
53297: PPUSH
53298: CALL_OW 255
53302: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53303: LD_ADDR_VAR 0 4
53307: PUSH
53308: LD_VAR 0 1
53312: PPUSH
53313: CALL_OW 248
53317: ST_TO_ADDR
// case nat of 1 :
53318: LD_VAR 0 4
53322: PUSH
53323: LD_INT 1
53325: DOUBLE
53326: EQUAL
53327: IFTRUE 53331
53329: GO 53342
53331: POP
// tech := tech_lassight ; 2 :
53332: LD_ADDR_VAR 0 5
53336: PUSH
53337: LD_INT 12
53339: ST_TO_ADDR
53340: GO 53381
53342: LD_INT 2
53344: DOUBLE
53345: EQUAL
53346: IFTRUE 53350
53348: GO 53361
53350: POP
// tech := tech_mortar ; 3 :
53351: LD_ADDR_VAR 0 5
53355: PUSH
53356: LD_INT 41
53358: ST_TO_ADDR
53359: GO 53381
53361: LD_INT 3
53363: DOUBLE
53364: EQUAL
53365: IFTRUE 53369
53367: GO 53380
53369: POP
// tech := tech_bazooka ; end ;
53370: LD_ADDR_VAR 0 5
53374: PUSH
53375: LD_INT 44
53377: ST_TO_ADDR
53378: GO 53381
53380: POP
// if Researched ( side , tech ) then
53381: LD_VAR 0 3
53385: PPUSH
53386: LD_VAR 0 5
53390: PPUSH
53391: CALL_OW 325
53395: IFFALSE 53422
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53397: LD_ADDR_VAR 0 2
53401: PUSH
53402: LD_INT 5
53404: PUSH
53405: LD_INT 8
53407: PUSH
53408: LD_INT 9
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: LIST
53415: PUSH
53416: LD_VAR 0 4
53420: ARRAY
53421: ST_TO_ADDR
// end ;
53422: LD_VAR 0 2
53426: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53427: LD_INT 0
53429: PPUSH
53430: PPUSH
53431: PPUSH
// if not mines then
53432: LD_VAR 0 2
53436: NOT
53437: IFFALSE 53441
// exit ;
53439: GO 53585
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53441: LD_ADDR_VAR 0 5
53445: PUSH
53446: LD_INT 81
53448: PUSH
53449: LD_VAR 0 1
53453: PUSH
53454: EMPTY
53455: LIST
53456: LIST
53457: PUSH
53458: LD_INT 3
53460: PUSH
53461: LD_INT 21
53463: PUSH
53464: LD_INT 3
53466: PUSH
53467: EMPTY
53468: LIST
53469: LIST
53470: PUSH
53471: EMPTY
53472: LIST
53473: LIST
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: PPUSH
53479: CALL_OW 69
53483: ST_TO_ADDR
// for i in mines do
53484: LD_ADDR_VAR 0 4
53488: PUSH
53489: LD_VAR 0 2
53493: PUSH
53494: FOR_IN
53495: IFFALSE 53583
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53497: LD_VAR 0 4
53501: PUSH
53502: LD_INT 1
53504: ARRAY
53505: PPUSH
53506: LD_VAR 0 4
53510: PUSH
53511: LD_INT 2
53513: ARRAY
53514: PPUSH
53515: CALL_OW 458
53519: NOT
53520: IFFALSE 53524
// continue ;
53522: GO 53494
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53524: LD_VAR 0 4
53528: PUSH
53529: LD_INT 1
53531: ARRAY
53532: PPUSH
53533: LD_VAR 0 4
53537: PUSH
53538: LD_INT 2
53540: ARRAY
53541: PPUSH
53542: CALL_OW 428
53546: PUSH
53547: LD_VAR 0 5
53551: IN
53552: IFFALSE 53581
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53554: LD_VAR 0 4
53558: PUSH
53559: LD_INT 1
53561: ARRAY
53562: PPUSH
53563: LD_VAR 0 4
53567: PUSH
53568: LD_INT 2
53570: ARRAY
53571: PPUSH
53572: LD_VAR 0 1
53576: PPUSH
53577: CALL_OW 456
// end ;
53581: GO 53494
53583: POP
53584: POP
// end ;
53585: LD_VAR 0 3
53589: RET
// export function Count ( array ) ; var i ; begin
53590: LD_INT 0
53592: PPUSH
53593: PPUSH
// result := 0 ;
53594: LD_ADDR_VAR 0 2
53598: PUSH
53599: LD_INT 0
53601: ST_TO_ADDR
// for i in array do
53602: LD_ADDR_VAR 0 3
53606: PUSH
53607: LD_VAR 0 1
53611: PUSH
53612: FOR_IN
53613: IFFALSE 53637
// if i then
53615: LD_VAR 0 3
53619: IFFALSE 53635
// result := result + 1 ;
53621: LD_ADDR_VAR 0 2
53625: PUSH
53626: LD_VAR 0 2
53630: PUSH
53631: LD_INT 1
53633: PLUS
53634: ST_TO_ADDR
53635: GO 53612
53637: POP
53638: POP
// end ;
53639: LD_VAR 0 2
53643: RET
// export function IsEmpty ( building ) ; begin
53644: LD_INT 0
53646: PPUSH
// if not building then
53647: LD_VAR 0 1
53651: NOT
53652: IFFALSE 53656
// exit ;
53654: GO 53699
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53656: LD_ADDR_VAR 0 2
53660: PUSH
53661: LD_VAR 0 1
53665: PUSH
53666: LD_INT 22
53668: PUSH
53669: LD_VAR 0 1
53673: PPUSH
53674: CALL_OW 255
53678: PUSH
53679: EMPTY
53680: LIST
53681: LIST
53682: PUSH
53683: LD_INT 58
53685: PUSH
53686: EMPTY
53687: LIST
53688: PUSH
53689: EMPTY
53690: LIST
53691: LIST
53692: PPUSH
53693: CALL_OW 69
53697: IN
53698: ST_TO_ADDR
// end ;
53699: LD_VAR 0 2
53703: RET
// export function IsNotFull ( building ) ; begin
53704: LD_INT 0
53706: PPUSH
// if not building then
53707: LD_VAR 0 1
53711: NOT
53712: IFFALSE 53716
// exit ;
53714: GO 53735
// result := UnitsInside ( building ) < 6 ;
53716: LD_ADDR_VAR 0 2
53720: PUSH
53721: LD_VAR 0 1
53725: PPUSH
53726: CALL_OW 313
53730: PUSH
53731: LD_INT 6
53733: LESS
53734: ST_TO_ADDR
// end ;
53735: LD_VAR 0 2
53739: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53740: LD_INT 0
53742: PPUSH
53743: PPUSH
53744: PPUSH
53745: PPUSH
// tmp := [ ] ;
53746: LD_ADDR_VAR 0 3
53750: PUSH
53751: EMPTY
53752: ST_TO_ADDR
// list := [ ] ;
53753: LD_ADDR_VAR 0 5
53757: PUSH
53758: EMPTY
53759: ST_TO_ADDR
// for i = 16 to 25 do
53760: LD_ADDR_VAR 0 4
53764: PUSH
53765: DOUBLE
53766: LD_INT 16
53768: DEC
53769: ST_TO_ADDR
53770: LD_INT 25
53772: PUSH
53773: FOR_TO
53774: IFFALSE 53847
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53776: LD_ADDR_VAR 0 3
53780: PUSH
53781: LD_VAR 0 3
53785: PUSH
53786: LD_INT 22
53788: PUSH
53789: LD_VAR 0 1
53793: PPUSH
53794: CALL_OW 255
53798: PUSH
53799: EMPTY
53800: LIST
53801: LIST
53802: PUSH
53803: LD_INT 91
53805: PUSH
53806: LD_VAR 0 1
53810: PUSH
53811: LD_INT 6
53813: PUSH
53814: EMPTY
53815: LIST
53816: LIST
53817: LIST
53818: PUSH
53819: LD_INT 30
53821: PUSH
53822: LD_VAR 0 4
53826: PUSH
53827: EMPTY
53828: LIST
53829: LIST
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: LIST
53835: PUSH
53836: EMPTY
53837: LIST
53838: PPUSH
53839: CALL_OW 69
53843: ADD
53844: ST_TO_ADDR
53845: GO 53773
53847: POP
53848: POP
// for i = 1 to tmp do
53849: LD_ADDR_VAR 0 4
53853: PUSH
53854: DOUBLE
53855: LD_INT 1
53857: DEC
53858: ST_TO_ADDR
53859: LD_VAR 0 3
53863: PUSH
53864: FOR_TO
53865: IFFALSE 53953
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53867: LD_ADDR_VAR 0 5
53871: PUSH
53872: LD_VAR 0 5
53876: PUSH
53877: LD_VAR 0 3
53881: PUSH
53882: LD_VAR 0 4
53886: ARRAY
53887: PPUSH
53888: CALL_OW 266
53892: PUSH
53893: LD_VAR 0 3
53897: PUSH
53898: LD_VAR 0 4
53902: ARRAY
53903: PPUSH
53904: CALL_OW 250
53908: PUSH
53909: LD_VAR 0 3
53913: PUSH
53914: LD_VAR 0 4
53918: ARRAY
53919: PPUSH
53920: CALL_OW 251
53924: PUSH
53925: LD_VAR 0 3
53929: PUSH
53930: LD_VAR 0 4
53934: ARRAY
53935: PPUSH
53936: CALL_OW 254
53940: PUSH
53941: EMPTY
53942: LIST
53943: LIST
53944: LIST
53945: LIST
53946: PUSH
53947: EMPTY
53948: LIST
53949: ADD
53950: ST_TO_ADDR
53951: GO 53864
53953: POP
53954: POP
// result := list ;
53955: LD_ADDR_VAR 0 2
53959: PUSH
53960: LD_VAR 0 5
53964: ST_TO_ADDR
// end ;
53965: LD_VAR 0 2
53969: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53970: LD_INT 0
53972: PPUSH
53973: PPUSH
53974: PPUSH
53975: PPUSH
53976: PPUSH
53977: PPUSH
53978: PPUSH
// if not factory then
53979: LD_VAR 0 1
53983: NOT
53984: IFFALSE 53988
// exit ;
53986: GO 54581
// if control = control_apeman then
53988: LD_VAR 0 4
53992: PUSH
53993: LD_INT 5
53995: EQUAL
53996: IFFALSE 54105
// begin tmp := UnitsInside ( factory ) ;
53998: LD_ADDR_VAR 0 8
54002: PUSH
54003: LD_VAR 0 1
54007: PPUSH
54008: CALL_OW 313
54012: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54013: LD_VAR 0 8
54017: PPUSH
54018: LD_INT 25
54020: PUSH
54021: LD_INT 12
54023: PUSH
54024: EMPTY
54025: LIST
54026: LIST
54027: PPUSH
54028: CALL_OW 72
54032: NOT
54033: IFFALSE 54043
// control := control_manual ;
54035: LD_ADDR_VAR 0 4
54039: PUSH
54040: LD_INT 1
54042: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54043: LD_ADDR_VAR 0 8
54047: PUSH
54048: LD_VAR 0 1
54052: PPUSH
54053: CALL 53740 0 1
54057: ST_TO_ADDR
// if tmp then
54058: LD_VAR 0 8
54062: IFFALSE 54105
// begin for i in tmp do
54064: LD_ADDR_VAR 0 7
54068: PUSH
54069: LD_VAR 0 8
54073: PUSH
54074: FOR_IN
54075: IFFALSE 54103
// if i [ 1 ] = b_ext_radio then
54077: LD_VAR 0 7
54081: PUSH
54082: LD_INT 1
54084: ARRAY
54085: PUSH
54086: LD_INT 22
54088: EQUAL
54089: IFFALSE 54101
// begin control := control_remote ;
54091: LD_ADDR_VAR 0 4
54095: PUSH
54096: LD_INT 2
54098: ST_TO_ADDR
// break ;
54099: GO 54103
// end ;
54101: GO 54074
54103: POP
54104: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54105: LD_VAR 0 1
54109: PPUSH
54110: LD_VAR 0 2
54114: PPUSH
54115: LD_VAR 0 3
54119: PPUSH
54120: LD_VAR 0 4
54124: PPUSH
54125: LD_VAR 0 5
54129: PPUSH
54130: CALL_OW 448
54134: IFFALSE 54169
// begin result := [ chassis , engine , control , weapon ] ;
54136: LD_ADDR_VAR 0 6
54140: PUSH
54141: LD_VAR 0 2
54145: PUSH
54146: LD_VAR 0 3
54150: PUSH
54151: LD_VAR 0 4
54155: PUSH
54156: LD_VAR 0 5
54160: PUSH
54161: EMPTY
54162: LIST
54163: LIST
54164: LIST
54165: LIST
54166: ST_TO_ADDR
// exit ;
54167: GO 54581
// end ; _chassis := AvailableChassisList ( factory ) ;
54169: LD_ADDR_VAR 0 9
54173: PUSH
54174: LD_VAR 0 1
54178: PPUSH
54179: CALL_OW 475
54183: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54184: LD_ADDR_VAR 0 11
54188: PUSH
54189: LD_VAR 0 1
54193: PPUSH
54194: CALL_OW 476
54198: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54199: LD_ADDR_VAR 0 12
54203: PUSH
54204: LD_VAR 0 1
54208: PPUSH
54209: CALL_OW 477
54213: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54214: LD_ADDR_VAR 0 10
54218: PUSH
54219: LD_VAR 0 1
54223: PPUSH
54224: CALL_OW 478
54228: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54229: LD_VAR 0 9
54233: NOT
54234: PUSH
54235: LD_VAR 0 11
54239: NOT
54240: OR
54241: PUSH
54242: LD_VAR 0 12
54246: NOT
54247: OR
54248: PUSH
54249: LD_VAR 0 10
54253: NOT
54254: OR
54255: IFFALSE 54290
// begin result := [ chassis , engine , control , weapon ] ;
54257: LD_ADDR_VAR 0 6
54261: PUSH
54262: LD_VAR 0 2
54266: PUSH
54267: LD_VAR 0 3
54271: PUSH
54272: LD_VAR 0 4
54276: PUSH
54277: LD_VAR 0 5
54281: PUSH
54282: EMPTY
54283: LIST
54284: LIST
54285: LIST
54286: LIST
54287: ST_TO_ADDR
// exit ;
54288: GO 54581
// end ; if not chassis in _chassis then
54290: LD_VAR 0 2
54294: PUSH
54295: LD_VAR 0 9
54299: IN
54300: NOT
54301: IFFALSE 54327
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54303: LD_ADDR_VAR 0 2
54307: PUSH
54308: LD_VAR 0 9
54312: PUSH
54313: LD_INT 1
54315: PPUSH
54316: LD_VAR 0 9
54320: PPUSH
54321: CALL_OW 12
54325: ARRAY
54326: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54327: LD_VAR 0 2
54331: PPUSH
54332: LD_VAR 0 3
54336: PPUSH
54337: CALL 54586 0 2
54341: NOT
54342: IFFALSE 54401
// repeat engine := _engine [ 1 ] ;
54344: LD_ADDR_VAR 0 3
54348: PUSH
54349: LD_VAR 0 11
54353: PUSH
54354: LD_INT 1
54356: ARRAY
54357: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54358: LD_ADDR_VAR 0 11
54362: PUSH
54363: LD_VAR 0 11
54367: PPUSH
54368: LD_INT 1
54370: PPUSH
54371: CALL_OW 3
54375: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54376: LD_VAR 0 2
54380: PPUSH
54381: LD_VAR 0 3
54385: PPUSH
54386: CALL 54586 0 2
54390: PUSH
54391: LD_VAR 0 11
54395: PUSH
54396: EMPTY
54397: EQUAL
54398: OR
54399: IFFALSE 54344
// if not control in _control then
54401: LD_VAR 0 4
54405: PUSH
54406: LD_VAR 0 12
54410: IN
54411: NOT
54412: IFFALSE 54438
// control := _control [ rand ( 1 , _control ) ] ;
54414: LD_ADDR_VAR 0 4
54418: PUSH
54419: LD_VAR 0 12
54423: PUSH
54424: LD_INT 1
54426: PPUSH
54427: LD_VAR 0 12
54431: PPUSH
54432: CALL_OW 12
54436: ARRAY
54437: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54438: LD_VAR 0 2
54442: PPUSH
54443: LD_VAR 0 5
54447: PPUSH
54448: CALL 54806 0 2
54452: NOT
54453: IFFALSE 54512
// repeat weapon := _weapon [ 1 ] ;
54455: LD_ADDR_VAR 0 5
54459: PUSH
54460: LD_VAR 0 10
54464: PUSH
54465: LD_INT 1
54467: ARRAY
54468: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54469: LD_ADDR_VAR 0 10
54473: PUSH
54474: LD_VAR 0 10
54478: PPUSH
54479: LD_INT 1
54481: PPUSH
54482: CALL_OW 3
54486: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54487: LD_VAR 0 2
54491: PPUSH
54492: LD_VAR 0 5
54496: PPUSH
54497: CALL 54806 0 2
54501: PUSH
54502: LD_VAR 0 10
54506: PUSH
54507: EMPTY
54508: EQUAL
54509: OR
54510: IFFALSE 54455
// result := [ ] ;
54512: LD_ADDR_VAR 0 6
54516: PUSH
54517: EMPTY
54518: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54519: LD_VAR 0 1
54523: PPUSH
54524: LD_VAR 0 2
54528: PPUSH
54529: LD_VAR 0 3
54533: PPUSH
54534: LD_VAR 0 4
54538: PPUSH
54539: LD_VAR 0 5
54543: PPUSH
54544: CALL_OW 448
54548: IFFALSE 54581
// result := [ chassis , engine , control , weapon ] ;
54550: LD_ADDR_VAR 0 6
54554: PUSH
54555: LD_VAR 0 2
54559: PUSH
54560: LD_VAR 0 3
54564: PUSH
54565: LD_VAR 0 4
54569: PUSH
54570: LD_VAR 0 5
54574: PUSH
54575: EMPTY
54576: LIST
54577: LIST
54578: LIST
54579: LIST
54580: ST_TO_ADDR
// end ;
54581: LD_VAR 0 6
54585: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
54586: LD_INT 0
54588: PPUSH
// if not chassis or not engine then
54589: LD_VAR 0 1
54593: NOT
54594: PUSH
54595: LD_VAR 0 2
54599: NOT
54600: OR
54601: IFFALSE 54605
// exit ;
54603: GO 54801
// case engine of engine_solar :
54605: LD_VAR 0 2
54609: PUSH
54610: LD_INT 2
54612: DOUBLE
54613: EQUAL
54614: IFTRUE 54618
54616: GO 54656
54618: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54619: LD_ADDR_VAR 0 3
54623: PUSH
54624: LD_INT 11
54626: PUSH
54627: LD_INT 12
54629: PUSH
54630: LD_INT 13
54632: PUSH
54633: LD_INT 14
54635: PUSH
54636: LD_INT 1
54638: PUSH
54639: LD_INT 2
54641: PUSH
54642: LD_INT 3
54644: PUSH
54645: EMPTY
54646: LIST
54647: LIST
54648: LIST
54649: LIST
54650: LIST
54651: LIST
54652: LIST
54653: ST_TO_ADDR
54654: GO 54785
54656: LD_INT 1
54658: DOUBLE
54659: EQUAL
54660: IFTRUE 54664
54662: GO 54726
54664: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54665: LD_ADDR_VAR 0 3
54669: PUSH
54670: LD_INT 11
54672: PUSH
54673: LD_INT 12
54675: PUSH
54676: LD_INT 13
54678: PUSH
54679: LD_INT 14
54681: PUSH
54682: LD_INT 1
54684: PUSH
54685: LD_INT 2
54687: PUSH
54688: LD_INT 3
54690: PUSH
54691: LD_INT 4
54693: PUSH
54694: LD_INT 5
54696: PUSH
54697: LD_INT 21
54699: PUSH
54700: LD_INT 23
54702: PUSH
54703: LD_INT 22
54705: PUSH
54706: LD_INT 24
54708: PUSH
54709: EMPTY
54710: LIST
54711: LIST
54712: LIST
54713: LIST
54714: LIST
54715: LIST
54716: LIST
54717: LIST
54718: LIST
54719: LIST
54720: LIST
54721: LIST
54722: LIST
54723: ST_TO_ADDR
54724: GO 54785
54726: LD_INT 3
54728: DOUBLE
54729: EQUAL
54730: IFTRUE 54734
54732: GO 54784
54734: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54735: LD_ADDR_VAR 0 3
54739: PUSH
54740: LD_INT 13
54742: PUSH
54743: LD_INT 14
54745: PUSH
54746: LD_INT 2
54748: PUSH
54749: LD_INT 3
54751: PUSH
54752: LD_INT 4
54754: PUSH
54755: LD_INT 5
54757: PUSH
54758: LD_INT 21
54760: PUSH
54761: LD_INT 22
54763: PUSH
54764: LD_INT 23
54766: PUSH
54767: LD_INT 24
54769: PUSH
54770: EMPTY
54771: LIST
54772: LIST
54773: LIST
54774: LIST
54775: LIST
54776: LIST
54777: LIST
54778: LIST
54779: LIST
54780: LIST
54781: ST_TO_ADDR
54782: GO 54785
54784: POP
// result := ( chassis in result ) ;
54785: LD_ADDR_VAR 0 3
54789: PUSH
54790: LD_VAR 0 1
54794: PUSH
54795: LD_VAR 0 3
54799: IN
54800: ST_TO_ADDR
// end ;
54801: LD_VAR 0 3
54805: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54806: LD_INT 0
54808: PPUSH
// if not chassis or not weapon then
54809: LD_VAR 0 1
54813: NOT
54814: PUSH
54815: LD_VAR 0 2
54819: NOT
54820: OR
54821: IFFALSE 54825
// exit ;
54823: GO 55887
// case weapon of us_machine_gun :
54825: LD_VAR 0 2
54829: PUSH
54830: LD_INT 2
54832: DOUBLE
54833: EQUAL
54834: IFTRUE 54838
54836: GO 54868
54838: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54839: LD_ADDR_VAR 0 3
54843: PUSH
54844: LD_INT 1
54846: PUSH
54847: LD_INT 2
54849: PUSH
54850: LD_INT 3
54852: PUSH
54853: LD_INT 4
54855: PUSH
54856: LD_INT 5
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: LIST
54863: LIST
54864: LIST
54865: ST_TO_ADDR
54866: GO 55871
54868: LD_INT 3
54870: DOUBLE
54871: EQUAL
54872: IFTRUE 54876
54874: GO 54906
54876: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54877: LD_ADDR_VAR 0 3
54881: PUSH
54882: LD_INT 1
54884: PUSH
54885: LD_INT 2
54887: PUSH
54888: LD_INT 3
54890: PUSH
54891: LD_INT 4
54893: PUSH
54894: LD_INT 5
54896: PUSH
54897: EMPTY
54898: LIST
54899: LIST
54900: LIST
54901: LIST
54902: LIST
54903: ST_TO_ADDR
54904: GO 55871
54906: LD_INT 11
54908: DOUBLE
54909: EQUAL
54910: IFTRUE 54914
54912: GO 54944
54914: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54915: LD_ADDR_VAR 0 3
54919: PUSH
54920: LD_INT 1
54922: PUSH
54923: LD_INT 2
54925: PUSH
54926: LD_INT 3
54928: PUSH
54929: LD_INT 4
54931: PUSH
54932: LD_INT 5
54934: PUSH
54935: EMPTY
54936: LIST
54937: LIST
54938: LIST
54939: LIST
54940: LIST
54941: ST_TO_ADDR
54942: GO 55871
54944: LD_INT 4
54946: DOUBLE
54947: EQUAL
54948: IFTRUE 54952
54950: GO 54978
54952: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54953: LD_ADDR_VAR 0 3
54957: PUSH
54958: LD_INT 2
54960: PUSH
54961: LD_INT 3
54963: PUSH
54964: LD_INT 4
54966: PUSH
54967: LD_INT 5
54969: PUSH
54970: EMPTY
54971: LIST
54972: LIST
54973: LIST
54974: LIST
54975: ST_TO_ADDR
54976: GO 55871
54978: LD_INT 5
54980: DOUBLE
54981: EQUAL
54982: IFTRUE 54986
54984: GO 55012
54986: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54987: LD_ADDR_VAR 0 3
54991: PUSH
54992: LD_INT 2
54994: PUSH
54995: LD_INT 3
54997: PUSH
54998: LD_INT 4
55000: PUSH
55001: LD_INT 5
55003: PUSH
55004: EMPTY
55005: LIST
55006: LIST
55007: LIST
55008: LIST
55009: ST_TO_ADDR
55010: GO 55871
55012: LD_INT 9
55014: DOUBLE
55015: EQUAL
55016: IFTRUE 55020
55018: GO 55046
55020: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55021: LD_ADDR_VAR 0 3
55025: PUSH
55026: LD_INT 2
55028: PUSH
55029: LD_INT 3
55031: PUSH
55032: LD_INT 4
55034: PUSH
55035: LD_INT 5
55037: PUSH
55038: EMPTY
55039: LIST
55040: LIST
55041: LIST
55042: LIST
55043: ST_TO_ADDR
55044: GO 55871
55046: LD_INT 7
55048: DOUBLE
55049: EQUAL
55050: IFTRUE 55054
55052: GO 55080
55054: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55055: LD_ADDR_VAR 0 3
55059: PUSH
55060: LD_INT 2
55062: PUSH
55063: LD_INT 3
55065: PUSH
55066: LD_INT 4
55068: PUSH
55069: LD_INT 5
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: LIST
55076: LIST
55077: ST_TO_ADDR
55078: GO 55871
55080: LD_INT 12
55082: DOUBLE
55083: EQUAL
55084: IFTRUE 55088
55086: GO 55114
55088: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55089: LD_ADDR_VAR 0 3
55093: PUSH
55094: LD_INT 2
55096: PUSH
55097: LD_INT 3
55099: PUSH
55100: LD_INT 4
55102: PUSH
55103: LD_INT 5
55105: PUSH
55106: EMPTY
55107: LIST
55108: LIST
55109: LIST
55110: LIST
55111: ST_TO_ADDR
55112: GO 55871
55114: LD_INT 13
55116: DOUBLE
55117: EQUAL
55118: IFTRUE 55122
55120: GO 55148
55122: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55123: LD_ADDR_VAR 0 3
55127: PUSH
55128: LD_INT 2
55130: PUSH
55131: LD_INT 3
55133: PUSH
55134: LD_INT 4
55136: PUSH
55137: LD_INT 5
55139: PUSH
55140: EMPTY
55141: LIST
55142: LIST
55143: LIST
55144: LIST
55145: ST_TO_ADDR
55146: GO 55871
55148: LD_INT 14
55150: DOUBLE
55151: EQUAL
55152: IFTRUE 55156
55154: GO 55174
55156: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55157: LD_ADDR_VAR 0 3
55161: PUSH
55162: LD_INT 4
55164: PUSH
55165: LD_INT 5
55167: PUSH
55168: EMPTY
55169: LIST
55170: LIST
55171: ST_TO_ADDR
55172: GO 55871
55174: LD_INT 6
55176: DOUBLE
55177: EQUAL
55178: IFTRUE 55182
55180: GO 55200
55182: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55183: LD_ADDR_VAR 0 3
55187: PUSH
55188: LD_INT 4
55190: PUSH
55191: LD_INT 5
55193: PUSH
55194: EMPTY
55195: LIST
55196: LIST
55197: ST_TO_ADDR
55198: GO 55871
55200: LD_INT 10
55202: DOUBLE
55203: EQUAL
55204: IFTRUE 55208
55206: GO 55226
55208: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55209: LD_ADDR_VAR 0 3
55213: PUSH
55214: LD_INT 4
55216: PUSH
55217: LD_INT 5
55219: PUSH
55220: EMPTY
55221: LIST
55222: LIST
55223: ST_TO_ADDR
55224: GO 55871
55226: LD_INT 22
55228: DOUBLE
55229: EQUAL
55230: IFTRUE 55234
55232: GO 55260
55234: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55235: LD_ADDR_VAR 0 3
55239: PUSH
55240: LD_INT 11
55242: PUSH
55243: LD_INT 12
55245: PUSH
55246: LD_INT 13
55248: PUSH
55249: LD_INT 14
55251: PUSH
55252: EMPTY
55253: LIST
55254: LIST
55255: LIST
55256: LIST
55257: ST_TO_ADDR
55258: GO 55871
55260: LD_INT 23
55262: DOUBLE
55263: EQUAL
55264: IFTRUE 55268
55266: GO 55294
55268: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55269: LD_ADDR_VAR 0 3
55273: PUSH
55274: LD_INT 11
55276: PUSH
55277: LD_INT 12
55279: PUSH
55280: LD_INT 13
55282: PUSH
55283: LD_INT 14
55285: PUSH
55286: EMPTY
55287: LIST
55288: LIST
55289: LIST
55290: LIST
55291: ST_TO_ADDR
55292: GO 55871
55294: LD_INT 24
55296: DOUBLE
55297: EQUAL
55298: IFTRUE 55302
55300: GO 55328
55302: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55303: LD_ADDR_VAR 0 3
55307: PUSH
55308: LD_INT 11
55310: PUSH
55311: LD_INT 12
55313: PUSH
55314: LD_INT 13
55316: PUSH
55317: LD_INT 14
55319: PUSH
55320: EMPTY
55321: LIST
55322: LIST
55323: LIST
55324: LIST
55325: ST_TO_ADDR
55326: GO 55871
55328: LD_INT 30
55330: DOUBLE
55331: EQUAL
55332: IFTRUE 55336
55334: GO 55362
55336: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55337: LD_ADDR_VAR 0 3
55341: PUSH
55342: LD_INT 11
55344: PUSH
55345: LD_INT 12
55347: PUSH
55348: LD_INT 13
55350: PUSH
55351: LD_INT 14
55353: PUSH
55354: EMPTY
55355: LIST
55356: LIST
55357: LIST
55358: LIST
55359: ST_TO_ADDR
55360: GO 55871
55362: LD_INT 25
55364: DOUBLE
55365: EQUAL
55366: IFTRUE 55370
55368: GO 55388
55370: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55371: LD_ADDR_VAR 0 3
55375: PUSH
55376: LD_INT 13
55378: PUSH
55379: LD_INT 14
55381: PUSH
55382: EMPTY
55383: LIST
55384: LIST
55385: ST_TO_ADDR
55386: GO 55871
55388: LD_INT 27
55390: DOUBLE
55391: EQUAL
55392: IFTRUE 55396
55394: GO 55414
55396: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55397: LD_ADDR_VAR 0 3
55401: PUSH
55402: LD_INT 13
55404: PUSH
55405: LD_INT 14
55407: PUSH
55408: EMPTY
55409: LIST
55410: LIST
55411: ST_TO_ADDR
55412: GO 55871
55414: LD_EXP 77
55418: DOUBLE
55419: EQUAL
55420: IFTRUE 55424
55422: GO 55450
55424: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55425: LD_ADDR_VAR 0 3
55429: PUSH
55430: LD_INT 11
55432: PUSH
55433: LD_INT 12
55435: PUSH
55436: LD_INT 13
55438: PUSH
55439: LD_INT 14
55441: PUSH
55442: EMPTY
55443: LIST
55444: LIST
55445: LIST
55446: LIST
55447: ST_TO_ADDR
55448: GO 55871
55450: LD_INT 28
55452: DOUBLE
55453: EQUAL
55454: IFTRUE 55458
55456: GO 55476
55458: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55459: LD_ADDR_VAR 0 3
55463: PUSH
55464: LD_INT 13
55466: PUSH
55467: LD_INT 14
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: ST_TO_ADDR
55474: GO 55871
55476: LD_INT 29
55478: DOUBLE
55479: EQUAL
55480: IFTRUE 55484
55482: GO 55502
55484: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55485: LD_ADDR_VAR 0 3
55489: PUSH
55490: LD_INT 13
55492: PUSH
55493: LD_INT 14
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: ST_TO_ADDR
55500: GO 55871
55502: LD_INT 31
55504: DOUBLE
55505: EQUAL
55506: IFTRUE 55510
55508: GO 55528
55510: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55511: LD_ADDR_VAR 0 3
55515: PUSH
55516: LD_INT 13
55518: PUSH
55519: LD_INT 14
55521: PUSH
55522: EMPTY
55523: LIST
55524: LIST
55525: ST_TO_ADDR
55526: GO 55871
55528: LD_INT 26
55530: DOUBLE
55531: EQUAL
55532: IFTRUE 55536
55534: GO 55554
55536: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
55537: LD_ADDR_VAR 0 3
55541: PUSH
55542: LD_INT 13
55544: PUSH
55545: LD_INT 14
55547: PUSH
55548: EMPTY
55549: LIST
55550: LIST
55551: ST_TO_ADDR
55552: GO 55871
55554: LD_INT 42
55556: DOUBLE
55557: EQUAL
55558: IFTRUE 55562
55560: GO 55588
55562: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
55563: LD_ADDR_VAR 0 3
55567: PUSH
55568: LD_INT 21
55570: PUSH
55571: LD_INT 22
55573: PUSH
55574: LD_INT 23
55576: PUSH
55577: LD_INT 24
55579: PUSH
55580: EMPTY
55581: LIST
55582: LIST
55583: LIST
55584: LIST
55585: ST_TO_ADDR
55586: GO 55871
55588: LD_INT 43
55590: DOUBLE
55591: EQUAL
55592: IFTRUE 55596
55594: GO 55622
55596: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
55597: LD_ADDR_VAR 0 3
55601: PUSH
55602: LD_INT 21
55604: PUSH
55605: LD_INT 22
55607: PUSH
55608: LD_INT 23
55610: PUSH
55611: LD_INT 24
55613: PUSH
55614: EMPTY
55615: LIST
55616: LIST
55617: LIST
55618: LIST
55619: ST_TO_ADDR
55620: GO 55871
55622: LD_INT 44
55624: DOUBLE
55625: EQUAL
55626: IFTRUE 55630
55628: GO 55656
55630: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
55631: LD_ADDR_VAR 0 3
55635: PUSH
55636: LD_INT 21
55638: PUSH
55639: LD_INT 22
55641: PUSH
55642: LD_INT 23
55644: PUSH
55645: LD_INT 24
55647: PUSH
55648: EMPTY
55649: LIST
55650: LIST
55651: LIST
55652: LIST
55653: ST_TO_ADDR
55654: GO 55871
55656: LD_INT 45
55658: DOUBLE
55659: EQUAL
55660: IFTRUE 55664
55662: GO 55690
55664: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55665: LD_ADDR_VAR 0 3
55669: PUSH
55670: LD_INT 21
55672: PUSH
55673: LD_INT 22
55675: PUSH
55676: LD_INT 23
55678: PUSH
55679: LD_INT 24
55681: PUSH
55682: EMPTY
55683: LIST
55684: LIST
55685: LIST
55686: LIST
55687: ST_TO_ADDR
55688: GO 55871
55690: LD_INT 49
55692: DOUBLE
55693: EQUAL
55694: IFTRUE 55698
55696: GO 55724
55698: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55699: LD_ADDR_VAR 0 3
55703: PUSH
55704: LD_INT 21
55706: PUSH
55707: LD_INT 22
55709: PUSH
55710: LD_INT 23
55712: PUSH
55713: LD_INT 24
55715: PUSH
55716: EMPTY
55717: LIST
55718: LIST
55719: LIST
55720: LIST
55721: ST_TO_ADDR
55722: GO 55871
55724: LD_INT 51
55726: DOUBLE
55727: EQUAL
55728: IFTRUE 55732
55730: GO 55758
55732: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55733: LD_ADDR_VAR 0 3
55737: PUSH
55738: LD_INT 21
55740: PUSH
55741: LD_INT 22
55743: PUSH
55744: LD_INT 23
55746: PUSH
55747: LD_INT 24
55749: PUSH
55750: EMPTY
55751: LIST
55752: LIST
55753: LIST
55754: LIST
55755: ST_TO_ADDR
55756: GO 55871
55758: LD_INT 52
55760: DOUBLE
55761: EQUAL
55762: IFTRUE 55766
55764: GO 55792
55766: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55767: LD_ADDR_VAR 0 3
55771: PUSH
55772: LD_INT 21
55774: PUSH
55775: LD_INT 22
55777: PUSH
55778: LD_INT 23
55780: PUSH
55781: LD_INT 24
55783: PUSH
55784: EMPTY
55785: LIST
55786: LIST
55787: LIST
55788: LIST
55789: ST_TO_ADDR
55790: GO 55871
55792: LD_INT 53
55794: DOUBLE
55795: EQUAL
55796: IFTRUE 55800
55798: GO 55818
55800: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55801: LD_ADDR_VAR 0 3
55805: PUSH
55806: LD_INT 23
55808: PUSH
55809: LD_INT 24
55811: PUSH
55812: EMPTY
55813: LIST
55814: LIST
55815: ST_TO_ADDR
55816: GO 55871
55818: LD_INT 46
55820: DOUBLE
55821: EQUAL
55822: IFTRUE 55826
55824: GO 55844
55826: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55827: LD_ADDR_VAR 0 3
55831: PUSH
55832: LD_INT 23
55834: PUSH
55835: LD_INT 24
55837: PUSH
55838: EMPTY
55839: LIST
55840: LIST
55841: ST_TO_ADDR
55842: GO 55871
55844: LD_INT 47
55846: DOUBLE
55847: EQUAL
55848: IFTRUE 55852
55850: GO 55870
55852: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55853: LD_ADDR_VAR 0 3
55857: PUSH
55858: LD_INT 23
55860: PUSH
55861: LD_INT 24
55863: PUSH
55864: EMPTY
55865: LIST
55866: LIST
55867: ST_TO_ADDR
55868: GO 55871
55870: POP
// result := ( chassis in result ) ;
55871: LD_ADDR_VAR 0 3
55875: PUSH
55876: LD_VAR 0 1
55880: PUSH
55881: LD_VAR 0 3
55885: IN
55886: ST_TO_ADDR
// end ;
55887: LD_VAR 0 3
55891: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55892: LD_INT 0
55894: PPUSH
55895: PPUSH
55896: PPUSH
55897: PPUSH
55898: PPUSH
55899: PPUSH
55900: PPUSH
// result := array ;
55901: LD_ADDR_VAR 0 5
55905: PUSH
55906: LD_VAR 0 1
55910: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55911: LD_VAR 0 1
55915: NOT
55916: PUSH
55917: LD_VAR 0 2
55921: NOT
55922: OR
55923: PUSH
55924: LD_VAR 0 3
55928: NOT
55929: OR
55930: PUSH
55931: LD_VAR 0 2
55935: PUSH
55936: LD_VAR 0 1
55940: GREATER
55941: OR
55942: PUSH
55943: LD_VAR 0 3
55947: PUSH
55948: LD_VAR 0 1
55952: GREATER
55953: OR
55954: IFFALSE 55958
// exit ;
55956: GO 56254
// if direction then
55958: LD_VAR 0 4
55962: IFFALSE 56026
// begin d := 1 ;
55964: LD_ADDR_VAR 0 9
55968: PUSH
55969: LD_INT 1
55971: ST_TO_ADDR
// if i_from > i_to then
55972: LD_VAR 0 2
55976: PUSH
55977: LD_VAR 0 3
55981: GREATER
55982: IFFALSE 56008
// length := ( array - i_from ) + i_to else
55984: LD_ADDR_VAR 0 11
55988: PUSH
55989: LD_VAR 0 1
55993: PUSH
55994: LD_VAR 0 2
55998: MINUS
55999: PUSH
56000: LD_VAR 0 3
56004: PLUS
56005: ST_TO_ADDR
56006: GO 56024
// length := i_to - i_from ;
56008: LD_ADDR_VAR 0 11
56012: PUSH
56013: LD_VAR 0 3
56017: PUSH
56018: LD_VAR 0 2
56022: MINUS
56023: ST_TO_ADDR
// end else
56024: GO 56087
// begin d := - 1 ;
56026: LD_ADDR_VAR 0 9
56030: PUSH
56031: LD_INT 1
56033: NEG
56034: ST_TO_ADDR
// if i_from > i_to then
56035: LD_VAR 0 2
56039: PUSH
56040: LD_VAR 0 3
56044: GREATER
56045: IFFALSE 56065
// length := i_from - i_to else
56047: LD_ADDR_VAR 0 11
56051: PUSH
56052: LD_VAR 0 2
56056: PUSH
56057: LD_VAR 0 3
56061: MINUS
56062: ST_TO_ADDR
56063: GO 56087
// length := ( array - i_to ) + i_from ;
56065: LD_ADDR_VAR 0 11
56069: PUSH
56070: LD_VAR 0 1
56074: PUSH
56075: LD_VAR 0 3
56079: MINUS
56080: PUSH
56081: LD_VAR 0 2
56085: PLUS
56086: ST_TO_ADDR
// end ; if not length then
56087: LD_VAR 0 11
56091: NOT
56092: IFFALSE 56096
// exit ;
56094: GO 56254
// tmp := array ;
56096: LD_ADDR_VAR 0 10
56100: PUSH
56101: LD_VAR 0 1
56105: ST_TO_ADDR
// for i = 1 to length do
56106: LD_ADDR_VAR 0 6
56110: PUSH
56111: DOUBLE
56112: LD_INT 1
56114: DEC
56115: ST_TO_ADDR
56116: LD_VAR 0 11
56120: PUSH
56121: FOR_TO
56122: IFFALSE 56242
// begin for j = 1 to array do
56124: LD_ADDR_VAR 0 7
56128: PUSH
56129: DOUBLE
56130: LD_INT 1
56132: DEC
56133: ST_TO_ADDR
56134: LD_VAR 0 1
56138: PUSH
56139: FOR_TO
56140: IFFALSE 56228
// begin k := j + d ;
56142: LD_ADDR_VAR 0 8
56146: PUSH
56147: LD_VAR 0 7
56151: PUSH
56152: LD_VAR 0 9
56156: PLUS
56157: ST_TO_ADDR
// if k > array then
56158: LD_VAR 0 8
56162: PUSH
56163: LD_VAR 0 1
56167: GREATER
56168: IFFALSE 56178
// k := 1 ;
56170: LD_ADDR_VAR 0 8
56174: PUSH
56175: LD_INT 1
56177: ST_TO_ADDR
// if not k then
56178: LD_VAR 0 8
56182: NOT
56183: IFFALSE 56195
// k := array ;
56185: LD_ADDR_VAR 0 8
56189: PUSH
56190: LD_VAR 0 1
56194: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56195: LD_ADDR_VAR 0 10
56199: PUSH
56200: LD_VAR 0 10
56204: PPUSH
56205: LD_VAR 0 8
56209: PPUSH
56210: LD_VAR 0 1
56214: PUSH
56215: LD_VAR 0 7
56219: ARRAY
56220: PPUSH
56221: CALL_OW 1
56225: ST_TO_ADDR
// end ;
56226: GO 56139
56228: POP
56229: POP
// array := tmp ;
56230: LD_ADDR_VAR 0 1
56234: PUSH
56235: LD_VAR 0 10
56239: ST_TO_ADDR
// end ;
56240: GO 56121
56242: POP
56243: POP
// result := array ;
56244: LD_ADDR_VAR 0 5
56248: PUSH
56249: LD_VAR 0 1
56253: ST_TO_ADDR
// end ;
56254: LD_VAR 0 5
56258: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56259: LD_INT 0
56261: PPUSH
56262: PPUSH
// result := 0 ;
56263: LD_ADDR_VAR 0 3
56267: PUSH
56268: LD_INT 0
56270: ST_TO_ADDR
// if not array or not value in array then
56271: LD_VAR 0 1
56275: NOT
56276: PUSH
56277: LD_VAR 0 2
56281: PUSH
56282: LD_VAR 0 1
56286: IN
56287: NOT
56288: OR
56289: IFFALSE 56293
// exit ;
56291: GO 56347
// for i = 1 to array do
56293: LD_ADDR_VAR 0 4
56297: PUSH
56298: DOUBLE
56299: LD_INT 1
56301: DEC
56302: ST_TO_ADDR
56303: LD_VAR 0 1
56307: PUSH
56308: FOR_TO
56309: IFFALSE 56345
// if value = array [ i ] then
56311: LD_VAR 0 2
56315: PUSH
56316: LD_VAR 0 1
56320: PUSH
56321: LD_VAR 0 4
56325: ARRAY
56326: EQUAL
56327: IFFALSE 56343
// begin result := i ;
56329: LD_ADDR_VAR 0 3
56333: PUSH
56334: LD_VAR 0 4
56338: ST_TO_ADDR
// exit ;
56339: POP
56340: POP
56341: GO 56347
// end ;
56343: GO 56308
56345: POP
56346: POP
// end ;
56347: LD_VAR 0 3
56351: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56352: LD_INT 0
56354: PPUSH
// vc_chassis := chassis ;
56355: LD_ADDR_OWVAR 37
56359: PUSH
56360: LD_VAR 0 1
56364: ST_TO_ADDR
// vc_engine := engine ;
56365: LD_ADDR_OWVAR 39
56369: PUSH
56370: LD_VAR 0 2
56374: ST_TO_ADDR
// vc_control := control ;
56375: LD_ADDR_OWVAR 38
56379: PUSH
56380: LD_VAR 0 3
56384: ST_TO_ADDR
// vc_weapon := weapon ;
56385: LD_ADDR_OWVAR 40
56389: PUSH
56390: LD_VAR 0 4
56394: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56395: LD_ADDR_OWVAR 41
56399: PUSH
56400: LD_VAR 0 5
56404: ST_TO_ADDR
// end ;
56405: LD_VAR 0 6
56409: RET
// export function WantPlant ( unit ) ; var task ; begin
56410: LD_INT 0
56412: PPUSH
56413: PPUSH
// result := false ;
56414: LD_ADDR_VAR 0 2
56418: PUSH
56419: LD_INT 0
56421: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56422: LD_ADDR_VAR 0 3
56426: PUSH
56427: LD_VAR 0 1
56431: PPUSH
56432: CALL_OW 437
56436: ST_TO_ADDR
// if task then
56437: LD_VAR 0 3
56441: IFFALSE 56469
// if task [ 1 ] [ 1 ] = p then
56443: LD_VAR 0 3
56447: PUSH
56448: LD_INT 1
56450: ARRAY
56451: PUSH
56452: LD_INT 1
56454: ARRAY
56455: PUSH
56456: LD_STRING p
56458: EQUAL
56459: IFFALSE 56469
// result := true ;
56461: LD_ADDR_VAR 0 2
56465: PUSH
56466: LD_INT 1
56468: ST_TO_ADDR
// end ;
56469: LD_VAR 0 2
56473: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56474: LD_INT 0
56476: PPUSH
56477: PPUSH
56478: PPUSH
56479: PPUSH
// if pos < 1 then
56480: LD_VAR 0 2
56484: PUSH
56485: LD_INT 1
56487: LESS
56488: IFFALSE 56492
// exit ;
56490: GO 56795
// if pos = 1 then
56492: LD_VAR 0 2
56496: PUSH
56497: LD_INT 1
56499: EQUAL
56500: IFFALSE 56533
// result := Replace ( arr , pos [ 1 ] , value ) else
56502: LD_ADDR_VAR 0 4
56506: PUSH
56507: LD_VAR 0 1
56511: PPUSH
56512: LD_VAR 0 2
56516: PUSH
56517: LD_INT 1
56519: ARRAY
56520: PPUSH
56521: LD_VAR 0 3
56525: PPUSH
56526: CALL_OW 1
56530: ST_TO_ADDR
56531: GO 56795
// begin tmp := arr ;
56533: LD_ADDR_VAR 0 6
56537: PUSH
56538: LD_VAR 0 1
56542: ST_TO_ADDR
// s_arr := [ tmp ] ;
56543: LD_ADDR_VAR 0 7
56547: PUSH
56548: LD_VAR 0 6
56552: PUSH
56553: EMPTY
56554: LIST
56555: ST_TO_ADDR
// for i = 1 to pos - 1 do
56556: LD_ADDR_VAR 0 5
56560: PUSH
56561: DOUBLE
56562: LD_INT 1
56564: DEC
56565: ST_TO_ADDR
56566: LD_VAR 0 2
56570: PUSH
56571: LD_INT 1
56573: MINUS
56574: PUSH
56575: FOR_TO
56576: IFFALSE 56621
// begin tmp := tmp [ pos [ i ] ] ;
56578: LD_ADDR_VAR 0 6
56582: PUSH
56583: LD_VAR 0 6
56587: PUSH
56588: LD_VAR 0 2
56592: PUSH
56593: LD_VAR 0 5
56597: ARRAY
56598: ARRAY
56599: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
56600: LD_ADDR_VAR 0 7
56604: PUSH
56605: LD_VAR 0 7
56609: PUSH
56610: LD_VAR 0 6
56614: PUSH
56615: EMPTY
56616: LIST
56617: ADD
56618: ST_TO_ADDR
// end ;
56619: GO 56575
56621: POP
56622: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
56623: LD_ADDR_VAR 0 6
56627: PUSH
56628: LD_VAR 0 6
56632: PPUSH
56633: LD_VAR 0 2
56637: PUSH
56638: LD_VAR 0 2
56642: ARRAY
56643: PPUSH
56644: LD_VAR 0 3
56648: PPUSH
56649: CALL_OW 1
56653: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56654: LD_ADDR_VAR 0 7
56658: PUSH
56659: LD_VAR 0 7
56663: PPUSH
56664: LD_VAR 0 7
56668: PPUSH
56669: LD_VAR 0 6
56673: PPUSH
56674: CALL_OW 1
56678: ST_TO_ADDR
// for i = s_arr downto 2 do
56679: LD_ADDR_VAR 0 5
56683: PUSH
56684: DOUBLE
56685: LD_VAR 0 7
56689: INC
56690: ST_TO_ADDR
56691: LD_INT 2
56693: PUSH
56694: FOR_DOWNTO
56695: IFFALSE 56779
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56697: LD_ADDR_VAR 0 6
56701: PUSH
56702: LD_VAR 0 7
56706: PUSH
56707: LD_VAR 0 5
56711: PUSH
56712: LD_INT 1
56714: MINUS
56715: ARRAY
56716: PPUSH
56717: LD_VAR 0 2
56721: PUSH
56722: LD_VAR 0 5
56726: PUSH
56727: LD_INT 1
56729: MINUS
56730: ARRAY
56731: PPUSH
56732: LD_VAR 0 7
56736: PUSH
56737: LD_VAR 0 5
56741: ARRAY
56742: PPUSH
56743: CALL_OW 1
56747: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56748: LD_ADDR_VAR 0 7
56752: PUSH
56753: LD_VAR 0 7
56757: PPUSH
56758: LD_VAR 0 5
56762: PUSH
56763: LD_INT 1
56765: MINUS
56766: PPUSH
56767: LD_VAR 0 6
56771: PPUSH
56772: CALL_OW 1
56776: ST_TO_ADDR
// end ;
56777: GO 56694
56779: POP
56780: POP
// result := s_arr [ 1 ] ;
56781: LD_ADDR_VAR 0 4
56785: PUSH
56786: LD_VAR 0 7
56790: PUSH
56791: LD_INT 1
56793: ARRAY
56794: ST_TO_ADDR
// end ; end ;
56795: LD_VAR 0 4
56799: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56800: LD_INT 0
56802: PPUSH
56803: PPUSH
// if not list then
56804: LD_VAR 0 1
56808: NOT
56809: IFFALSE 56813
// exit ;
56811: GO 56904
// i := list [ pos1 ] ;
56813: LD_ADDR_VAR 0 5
56817: PUSH
56818: LD_VAR 0 1
56822: PUSH
56823: LD_VAR 0 2
56827: ARRAY
56828: ST_TO_ADDR
// if not i then
56829: LD_VAR 0 5
56833: NOT
56834: IFFALSE 56838
// exit ;
56836: GO 56904
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56838: LD_ADDR_VAR 0 1
56842: PUSH
56843: LD_VAR 0 1
56847: PPUSH
56848: LD_VAR 0 2
56852: PPUSH
56853: LD_VAR 0 1
56857: PUSH
56858: LD_VAR 0 3
56862: ARRAY
56863: PPUSH
56864: CALL_OW 1
56868: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56869: LD_ADDR_VAR 0 1
56873: PUSH
56874: LD_VAR 0 1
56878: PPUSH
56879: LD_VAR 0 3
56883: PPUSH
56884: LD_VAR 0 5
56888: PPUSH
56889: CALL_OW 1
56893: ST_TO_ADDR
// result := list ;
56894: LD_ADDR_VAR 0 4
56898: PUSH
56899: LD_VAR 0 1
56903: ST_TO_ADDR
// end ;
56904: LD_VAR 0 4
56908: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56909: LD_INT 0
56911: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56912: LD_ADDR_VAR 0 5
56916: PUSH
56917: LD_VAR 0 1
56921: PPUSH
56922: CALL_OW 250
56926: PPUSH
56927: LD_VAR 0 1
56931: PPUSH
56932: CALL_OW 251
56936: PPUSH
56937: LD_VAR 0 2
56941: PPUSH
56942: LD_VAR 0 3
56946: PPUSH
56947: LD_VAR 0 4
56951: PPUSH
56952: CALL 56962 0 5
56956: ST_TO_ADDR
// end ;
56957: LD_VAR 0 5
56961: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56962: LD_INT 0
56964: PPUSH
56965: PPUSH
56966: PPUSH
56967: PPUSH
// if not list then
56968: LD_VAR 0 3
56972: NOT
56973: IFFALSE 56977
// exit ;
56975: GO 57365
// result := [ ] ;
56977: LD_ADDR_VAR 0 6
56981: PUSH
56982: EMPTY
56983: ST_TO_ADDR
// for i in list do
56984: LD_ADDR_VAR 0 7
56988: PUSH
56989: LD_VAR 0 3
56993: PUSH
56994: FOR_IN
56995: IFFALSE 57197
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56997: LD_ADDR_VAR 0 9
57001: PUSH
57002: LD_VAR 0 7
57006: PPUSH
57007: LD_VAR 0 1
57011: PPUSH
57012: LD_VAR 0 2
57016: PPUSH
57017: CALL_OW 297
57021: ST_TO_ADDR
// if not result then
57022: LD_VAR 0 6
57026: NOT
57027: IFFALSE 57053
// result := [ [ i , tmp ] ] else
57029: LD_ADDR_VAR 0 6
57033: PUSH
57034: LD_VAR 0 7
57038: PUSH
57039: LD_VAR 0 9
57043: PUSH
57044: EMPTY
57045: LIST
57046: LIST
57047: PUSH
57048: EMPTY
57049: LIST
57050: ST_TO_ADDR
57051: GO 57195
// begin if result [ result ] [ 2 ] < tmp then
57053: LD_VAR 0 6
57057: PUSH
57058: LD_VAR 0 6
57062: ARRAY
57063: PUSH
57064: LD_INT 2
57066: ARRAY
57067: PUSH
57068: LD_VAR 0 9
57072: LESS
57073: IFFALSE 57115
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57075: LD_ADDR_VAR 0 6
57079: PUSH
57080: LD_VAR 0 6
57084: PPUSH
57085: LD_VAR 0 6
57089: PUSH
57090: LD_INT 1
57092: PLUS
57093: PPUSH
57094: LD_VAR 0 7
57098: PUSH
57099: LD_VAR 0 9
57103: PUSH
57104: EMPTY
57105: LIST
57106: LIST
57107: PPUSH
57108: CALL_OW 2
57112: ST_TO_ADDR
57113: GO 57195
// for j = 1 to result do
57115: LD_ADDR_VAR 0 8
57119: PUSH
57120: DOUBLE
57121: LD_INT 1
57123: DEC
57124: ST_TO_ADDR
57125: LD_VAR 0 6
57129: PUSH
57130: FOR_TO
57131: IFFALSE 57193
// begin if tmp < result [ j ] [ 2 ] then
57133: LD_VAR 0 9
57137: PUSH
57138: LD_VAR 0 6
57142: PUSH
57143: LD_VAR 0 8
57147: ARRAY
57148: PUSH
57149: LD_INT 2
57151: ARRAY
57152: LESS
57153: IFFALSE 57191
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57155: LD_ADDR_VAR 0 6
57159: PUSH
57160: LD_VAR 0 6
57164: PPUSH
57165: LD_VAR 0 8
57169: PPUSH
57170: LD_VAR 0 7
57174: PUSH
57175: LD_VAR 0 9
57179: PUSH
57180: EMPTY
57181: LIST
57182: LIST
57183: PPUSH
57184: CALL_OW 2
57188: ST_TO_ADDR
// break ;
57189: GO 57193
// end ; end ;
57191: GO 57130
57193: POP
57194: POP
// end ; end ;
57195: GO 56994
57197: POP
57198: POP
// if result and not asc then
57199: LD_VAR 0 6
57203: PUSH
57204: LD_VAR 0 4
57208: NOT
57209: AND
57210: IFFALSE 57285
// begin tmp := result ;
57212: LD_ADDR_VAR 0 9
57216: PUSH
57217: LD_VAR 0 6
57221: ST_TO_ADDR
// for i = tmp downto 1 do
57222: LD_ADDR_VAR 0 7
57226: PUSH
57227: DOUBLE
57228: LD_VAR 0 9
57232: INC
57233: ST_TO_ADDR
57234: LD_INT 1
57236: PUSH
57237: FOR_DOWNTO
57238: IFFALSE 57283
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57240: LD_ADDR_VAR 0 6
57244: PUSH
57245: LD_VAR 0 6
57249: PPUSH
57250: LD_VAR 0 9
57254: PUSH
57255: LD_VAR 0 7
57259: MINUS
57260: PUSH
57261: LD_INT 1
57263: PLUS
57264: PPUSH
57265: LD_VAR 0 9
57269: PUSH
57270: LD_VAR 0 7
57274: ARRAY
57275: PPUSH
57276: CALL_OW 1
57280: ST_TO_ADDR
57281: GO 57237
57283: POP
57284: POP
// end ; tmp := [ ] ;
57285: LD_ADDR_VAR 0 9
57289: PUSH
57290: EMPTY
57291: ST_TO_ADDR
// if mode then
57292: LD_VAR 0 5
57296: IFFALSE 57365
// begin for i = 1 to result do
57298: LD_ADDR_VAR 0 7
57302: PUSH
57303: DOUBLE
57304: LD_INT 1
57306: DEC
57307: ST_TO_ADDR
57308: LD_VAR 0 6
57312: PUSH
57313: FOR_TO
57314: IFFALSE 57353
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57316: LD_ADDR_VAR 0 9
57320: PUSH
57321: LD_VAR 0 9
57325: PPUSH
57326: LD_VAR 0 7
57330: PPUSH
57331: LD_VAR 0 6
57335: PUSH
57336: LD_VAR 0 7
57340: ARRAY
57341: PUSH
57342: LD_INT 1
57344: ARRAY
57345: PPUSH
57346: CALL_OW 1
57350: ST_TO_ADDR
57351: GO 57313
57353: POP
57354: POP
// result := tmp ;
57355: LD_ADDR_VAR 0 6
57359: PUSH
57360: LD_VAR 0 9
57364: ST_TO_ADDR
// end ; end ;
57365: LD_VAR 0 6
57369: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57370: LD_INT 0
57372: PPUSH
57373: PPUSH
57374: PPUSH
57375: PPUSH
57376: PPUSH
57377: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57378: LD_ADDR_VAR 0 5
57382: PUSH
57383: LD_INT 0
57385: PUSH
57386: LD_INT 0
57388: PUSH
57389: LD_INT 0
57391: PUSH
57392: EMPTY
57393: PUSH
57394: EMPTY
57395: LIST
57396: LIST
57397: LIST
57398: LIST
57399: ST_TO_ADDR
// if not x or not y then
57400: LD_VAR 0 2
57404: NOT
57405: PUSH
57406: LD_VAR 0 3
57410: NOT
57411: OR
57412: IFFALSE 57416
// exit ;
57414: GO 59068
// if not range then
57416: LD_VAR 0 4
57420: NOT
57421: IFFALSE 57431
// range := 10 ;
57423: LD_ADDR_VAR 0 4
57427: PUSH
57428: LD_INT 10
57430: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57431: LD_ADDR_VAR 0 8
57435: PUSH
57436: LD_INT 81
57438: PUSH
57439: LD_VAR 0 1
57443: PUSH
57444: EMPTY
57445: LIST
57446: LIST
57447: PUSH
57448: LD_INT 92
57450: PUSH
57451: LD_VAR 0 2
57455: PUSH
57456: LD_VAR 0 3
57460: PUSH
57461: LD_VAR 0 4
57465: PUSH
57466: EMPTY
57467: LIST
57468: LIST
57469: LIST
57470: LIST
57471: PUSH
57472: LD_INT 3
57474: PUSH
57475: LD_INT 21
57477: PUSH
57478: LD_INT 3
57480: PUSH
57481: EMPTY
57482: LIST
57483: LIST
57484: PUSH
57485: EMPTY
57486: LIST
57487: LIST
57488: PUSH
57489: EMPTY
57490: LIST
57491: LIST
57492: LIST
57493: PPUSH
57494: CALL_OW 69
57498: ST_TO_ADDR
// if not tmp then
57499: LD_VAR 0 8
57503: NOT
57504: IFFALSE 57508
// exit ;
57506: GO 59068
// for i in tmp do
57508: LD_ADDR_VAR 0 6
57512: PUSH
57513: LD_VAR 0 8
57517: PUSH
57518: FOR_IN
57519: IFFALSE 59043
// begin points := [ 0 , 0 , 0 ] ;
57521: LD_ADDR_VAR 0 9
57525: PUSH
57526: LD_INT 0
57528: PUSH
57529: LD_INT 0
57531: PUSH
57532: LD_INT 0
57534: PUSH
57535: EMPTY
57536: LIST
57537: LIST
57538: LIST
57539: ST_TO_ADDR
// bpoints := 1 ;
57540: LD_ADDR_VAR 0 10
57544: PUSH
57545: LD_INT 1
57547: ST_TO_ADDR
// case GetType ( i ) of unit_human :
57548: LD_VAR 0 6
57552: PPUSH
57553: CALL_OW 247
57557: PUSH
57558: LD_INT 1
57560: DOUBLE
57561: EQUAL
57562: IFTRUE 57566
57564: GO 58144
57566: POP
// begin if GetClass ( i ) = 1 then
57567: LD_VAR 0 6
57571: PPUSH
57572: CALL_OW 257
57576: PUSH
57577: LD_INT 1
57579: EQUAL
57580: IFFALSE 57601
// points := [ 10 , 5 , 3 ] ;
57582: LD_ADDR_VAR 0 9
57586: PUSH
57587: LD_INT 10
57589: PUSH
57590: LD_INT 5
57592: PUSH
57593: LD_INT 3
57595: PUSH
57596: EMPTY
57597: LIST
57598: LIST
57599: LIST
57600: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
57601: LD_VAR 0 6
57605: PPUSH
57606: CALL_OW 257
57610: PUSH
57611: LD_INT 2
57613: PUSH
57614: LD_INT 3
57616: PUSH
57617: LD_INT 4
57619: PUSH
57620: EMPTY
57621: LIST
57622: LIST
57623: LIST
57624: IN
57625: IFFALSE 57646
// points := [ 3 , 2 , 1 ] ;
57627: LD_ADDR_VAR 0 9
57631: PUSH
57632: LD_INT 3
57634: PUSH
57635: LD_INT 2
57637: PUSH
57638: LD_INT 1
57640: PUSH
57641: EMPTY
57642: LIST
57643: LIST
57644: LIST
57645: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57646: LD_VAR 0 6
57650: PPUSH
57651: CALL_OW 257
57655: PUSH
57656: LD_INT 5
57658: EQUAL
57659: IFFALSE 57680
// points := [ 130 , 5 , 2 ] ;
57661: LD_ADDR_VAR 0 9
57665: PUSH
57666: LD_INT 130
57668: PUSH
57669: LD_INT 5
57671: PUSH
57672: LD_INT 2
57674: PUSH
57675: EMPTY
57676: LIST
57677: LIST
57678: LIST
57679: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57680: LD_VAR 0 6
57684: PPUSH
57685: CALL_OW 257
57689: PUSH
57690: LD_INT 8
57692: EQUAL
57693: IFFALSE 57714
// points := [ 35 , 35 , 30 ] ;
57695: LD_ADDR_VAR 0 9
57699: PUSH
57700: LD_INT 35
57702: PUSH
57703: LD_INT 35
57705: PUSH
57706: LD_INT 30
57708: PUSH
57709: EMPTY
57710: LIST
57711: LIST
57712: LIST
57713: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57714: LD_VAR 0 6
57718: PPUSH
57719: CALL_OW 257
57723: PUSH
57724: LD_INT 9
57726: EQUAL
57727: IFFALSE 57748
// points := [ 20 , 55 , 40 ] ;
57729: LD_ADDR_VAR 0 9
57733: PUSH
57734: LD_INT 20
57736: PUSH
57737: LD_INT 55
57739: PUSH
57740: LD_INT 40
57742: PUSH
57743: EMPTY
57744: LIST
57745: LIST
57746: LIST
57747: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57748: LD_VAR 0 6
57752: PPUSH
57753: CALL_OW 257
57757: PUSH
57758: LD_INT 12
57760: PUSH
57761: LD_INT 16
57763: PUSH
57764: EMPTY
57765: LIST
57766: LIST
57767: IN
57768: IFFALSE 57789
// points := [ 5 , 3 , 2 ] ;
57770: LD_ADDR_VAR 0 9
57774: PUSH
57775: LD_INT 5
57777: PUSH
57778: LD_INT 3
57780: PUSH
57781: LD_INT 2
57783: PUSH
57784: EMPTY
57785: LIST
57786: LIST
57787: LIST
57788: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57789: LD_VAR 0 6
57793: PPUSH
57794: CALL_OW 257
57798: PUSH
57799: LD_INT 17
57801: EQUAL
57802: IFFALSE 57823
// points := [ 100 , 50 , 75 ] ;
57804: LD_ADDR_VAR 0 9
57808: PUSH
57809: LD_INT 100
57811: PUSH
57812: LD_INT 50
57814: PUSH
57815: LD_INT 75
57817: PUSH
57818: EMPTY
57819: LIST
57820: LIST
57821: LIST
57822: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57823: LD_VAR 0 6
57827: PPUSH
57828: CALL_OW 257
57832: PUSH
57833: LD_INT 15
57835: EQUAL
57836: IFFALSE 57857
// points := [ 10 , 5 , 3 ] ;
57838: LD_ADDR_VAR 0 9
57842: PUSH
57843: LD_INT 10
57845: PUSH
57846: LD_INT 5
57848: PUSH
57849: LD_INT 3
57851: PUSH
57852: EMPTY
57853: LIST
57854: LIST
57855: LIST
57856: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57857: LD_VAR 0 6
57861: PPUSH
57862: CALL_OW 257
57866: PUSH
57867: LD_INT 14
57869: EQUAL
57870: IFFALSE 57891
// points := [ 10 , 0 , 0 ] ;
57872: LD_ADDR_VAR 0 9
57876: PUSH
57877: LD_INT 10
57879: PUSH
57880: LD_INT 0
57882: PUSH
57883: LD_INT 0
57885: PUSH
57886: EMPTY
57887: LIST
57888: LIST
57889: LIST
57890: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57891: LD_VAR 0 6
57895: PPUSH
57896: CALL_OW 257
57900: PUSH
57901: LD_INT 11
57903: EQUAL
57904: IFFALSE 57925
// points := [ 30 , 10 , 5 ] ;
57906: LD_ADDR_VAR 0 9
57910: PUSH
57911: LD_INT 30
57913: PUSH
57914: LD_INT 10
57916: PUSH
57917: LD_INT 5
57919: PUSH
57920: EMPTY
57921: LIST
57922: LIST
57923: LIST
57924: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57925: LD_VAR 0 1
57929: PPUSH
57930: LD_INT 5
57932: PPUSH
57933: CALL_OW 321
57937: PUSH
57938: LD_INT 2
57940: EQUAL
57941: IFFALSE 57958
// bpoints := bpoints * 1.8 ;
57943: LD_ADDR_VAR 0 10
57947: PUSH
57948: LD_VAR 0 10
57952: PUSH
57953: LD_REAL  1.80000000000000E+0000
57956: MUL
57957: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57958: LD_VAR 0 6
57962: PPUSH
57963: CALL_OW 257
57967: PUSH
57968: LD_INT 1
57970: PUSH
57971: LD_INT 2
57973: PUSH
57974: LD_INT 3
57976: PUSH
57977: LD_INT 4
57979: PUSH
57980: EMPTY
57981: LIST
57982: LIST
57983: LIST
57984: LIST
57985: IN
57986: PUSH
57987: LD_VAR 0 1
57991: PPUSH
57992: LD_INT 51
57994: PPUSH
57995: CALL_OW 321
57999: PUSH
58000: LD_INT 2
58002: EQUAL
58003: AND
58004: IFFALSE 58021
// bpoints := bpoints * 1.2 ;
58006: LD_ADDR_VAR 0 10
58010: PUSH
58011: LD_VAR 0 10
58015: PUSH
58016: LD_REAL  1.20000000000000E+0000
58019: MUL
58020: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58021: LD_VAR 0 6
58025: PPUSH
58026: CALL_OW 257
58030: PUSH
58031: LD_INT 5
58033: PUSH
58034: LD_INT 7
58036: PUSH
58037: LD_INT 9
58039: PUSH
58040: EMPTY
58041: LIST
58042: LIST
58043: LIST
58044: IN
58045: PUSH
58046: LD_VAR 0 1
58050: PPUSH
58051: LD_INT 52
58053: PPUSH
58054: CALL_OW 321
58058: PUSH
58059: LD_INT 2
58061: EQUAL
58062: AND
58063: IFFALSE 58080
// bpoints := bpoints * 1.5 ;
58065: LD_ADDR_VAR 0 10
58069: PUSH
58070: LD_VAR 0 10
58074: PUSH
58075: LD_REAL  1.50000000000000E+0000
58078: MUL
58079: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58080: LD_VAR 0 1
58084: PPUSH
58085: LD_INT 66
58087: PPUSH
58088: CALL_OW 321
58092: PUSH
58093: LD_INT 2
58095: EQUAL
58096: IFFALSE 58113
// bpoints := bpoints * 1.1 ;
58098: LD_ADDR_VAR 0 10
58102: PUSH
58103: LD_VAR 0 10
58107: PUSH
58108: LD_REAL  1.10000000000000E+0000
58111: MUL
58112: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58113: LD_ADDR_VAR 0 10
58117: PUSH
58118: LD_VAR 0 10
58122: PUSH
58123: LD_VAR 0 6
58127: PPUSH
58128: LD_INT 1
58130: PPUSH
58131: CALL_OW 259
58135: PUSH
58136: LD_REAL  1.15000000000000E+0000
58139: MUL
58140: MUL
58141: ST_TO_ADDR
// end ; unit_vehicle :
58142: GO 58972
58144: LD_INT 2
58146: DOUBLE
58147: EQUAL
58148: IFTRUE 58152
58150: GO 58960
58152: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58153: LD_VAR 0 6
58157: PPUSH
58158: CALL_OW 264
58162: PUSH
58163: LD_INT 2
58165: PUSH
58166: LD_INT 42
58168: PUSH
58169: LD_INT 24
58171: PUSH
58172: EMPTY
58173: LIST
58174: LIST
58175: LIST
58176: IN
58177: IFFALSE 58198
// points := [ 25 , 5 , 3 ] ;
58179: LD_ADDR_VAR 0 9
58183: PUSH
58184: LD_INT 25
58186: PUSH
58187: LD_INT 5
58189: PUSH
58190: LD_INT 3
58192: PUSH
58193: EMPTY
58194: LIST
58195: LIST
58196: LIST
58197: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58198: LD_VAR 0 6
58202: PPUSH
58203: CALL_OW 264
58207: PUSH
58208: LD_INT 4
58210: PUSH
58211: LD_INT 43
58213: PUSH
58214: LD_INT 25
58216: PUSH
58217: EMPTY
58218: LIST
58219: LIST
58220: LIST
58221: IN
58222: IFFALSE 58243
// points := [ 40 , 15 , 5 ] ;
58224: LD_ADDR_VAR 0 9
58228: PUSH
58229: LD_INT 40
58231: PUSH
58232: LD_INT 15
58234: PUSH
58235: LD_INT 5
58237: PUSH
58238: EMPTY
58239: LIST
58240: LIST
58241: LIST
58242: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58243: LD_VAR 0 6
58247: PPUSH
58248: CALL_OW 264
58252: PUSH
58253: LD_INT 3
58255: PUSH
58256: LD_INT 23
58258: PUSH
58259: EMPTY
58260: LIST
58261: LIST
58262: IN
58263: IFFALSE 58284
// points := [ 7 , 25 , 8 ] ;
58265: LD_ADDR_VAR 0 9
58269: PUSH
58270: LD_INT 7
58272: PUSH
58273: LD_INT 25
58275: PUSH
58276: LD_INT 8
58278: PUSH
58279: EMPTY
58280: LIST
58281: LIST
58282: LIST
58283: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58284: LD_VAR 0 6
58288: PPUSH
58289: CALL_OW 264
58293: PUSH
58294: LD_INT 5
58296: PUSH
58297: LD_INT 27
58299: PUSH
58300: LD_INT 44
58302: PUSH
58303: EMPTY
58304: LIST
58305: LIST
58306: LIST
58307: IN
58308: IFFALSE 58329
// points := [ 14 , 50 , 16 ] ;
58310: LD_ADDR_VAR 0 9
58314: PUSH
58315: LD_INT 14
58317: PUSH
58318: LD_INT 50
58320: PUSH
58321: LD_INT 16
58323: PUSH
58324: EMPTY
58325: LIST
58326: LIST
58327: LIST
58328: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58329: LD_VAR 0 6
58333: PPUSH
58334: CALL_OW 264
58338: PUSH
58339: LD_INT 6
58341: PUSH
58342: LD_INT 46
58344: PUSH
58345: EMPTY
58346: LIST
58347: LIST
58348: IN
58349: IFFALSE 58370
// points := [ 32 , 120 , 70 ] ;
58351: LD_ADDR_VAR 0 9
58355: PUSH
58356: LD_INT 32
58358: PUSH
58359: LD_INT 120
58361: PUSH
58362: LD_INT 70
58364: PUSH
58365: EMPTY
58366: LIST
58367: LIST
58368: LIST
58369: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58370: LD_VAR 0 6
58374: PPUSH
58375: CALL_OW 264
58379: PUSH
58380: LD_INT 7
58382: PUSH
58383: LD_INT 28
58385: PUSH
58386: LD_INT 45
58388: PUSH
58389: LD_EXP 77
58393: PUSH
58394: EMPTY
58395: LIST
58396: LIST
58397: LIST
58398: LIST
58399: IN
58400: IFFALSE 58421
// points := [ 35 , 20 , 45 ] ;
58402: LD_ADDR_VAR 0 9
58406: PUSH
58407: LD_INT 35
58409: PUSH
58410: LD_INT 20
58412: PUSH
58413: LD_INT 45
58415: PUSH
58416: EMPTY
58417: LIST
58418: LIST
58419: LIST
58420: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58421: LD_VAR 0 6
58425: PPUSH
58426: CALL_OW 264
58430: PUSH
58431: LD_INT 47
58433: PUSH
58434: EMPTY
58435: LIST
58436: IN
58437: IFFALSE 58458
// points := [ 67 , 45 , 75 ] ;
58439: LD_ADDR_VAR 0 9
58443: PUSH
58444: LD_INT 67
58446: PUSH
58447: LD_INT 45
58449: PUSH
58450: LD_INT 75
58452: PUSH
58453: EMPTY
58454: LIST
58455: LIST
58456: LIST
58457: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58458: LD_VAR 0 6
58462: PPUSH
58463: CALL_OW 264
58467: PUSH
58468: LD_INT 26
58470: PUSH
58471: EMPTY
58472: LIST
58473: IN
58474: IFFALSE 58495
// points := [ 120 , 30 , 80 ] ;
58476: LD_ADDR_VAR 0 9
58480: PUSH
58481: LD_INT 120
58483: PUSH
58484: LD_INT 30
58486: PUSH
58487: LD_INT 80
58489: PUSH
58490: EMPTY
58491: LIST
58492: LIST
58493: LIST
58494: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58495: LD_VAR 0 6
58499: PPUSH
58500: CALL_OW 264
58504: PUSH
58505: LD_INT 22
58507: PUSH
58508: EMPTY
58509: LIST
58510: IN
58511: IFFALSE 58532
// points := [ 40 , 1 , 1 ] ;
58513: LD_ADDR_VAR 0 9
58517: PUSH
58518: LD_INT 40
58520: PUSH
58521: LD_INT 1
58523: PUSH
58524: LD_INT 1
58526: PUSH
58527: EMPTY
58528: LIST
58529: LIST
58530: LIST
58531: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
58532: LD_VAR 0 6
58536: PPUSH
58537: CALL_OW 264
58541: PUSH
58542: LD_INT 29
58544: PUSH
58545: EMPTY
58546: LIST
58547: IN
58548: IFFALSE 58569
// points := [ 70 , 200 , 400 ] ;
58550: LD_ADDR_VAR 0 9
58554: PUSH
58555: LD_INT 70
58557: PUSH
58558: LD_INT 200
58560: PUSH
58561: LD_INT 400
58563: PUSH
58564: EMPTY
58565: LIST
58566: LIST
58567: LIST
58568: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
58569: LD_VAR 0 6
58573: PPUSH
58574: CALL_OW 264
58578: PUSH
58579: LD_INT 14
58581: PUSH
58582: LD_INT 53
58584: PUSH
58585: EMPTY
58586: LIST
58587: LIST
58588: IN
58589: IFFALSE 58610
// points := [ 40 , 10 , 20 ] ;
58591: LD_ADDR_VAR 0 9
58595: PUSH
58596: LD_INT 40
58598: PUSH
58599: LD_INT 10
58601: PUSH
58602: LD_INT 20
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: LIST
58609: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
58610: LD_VAR 0 6
58614: PPUSH
58615: CALL_OW 264
58619: PUSH
58620: LD_INT 9
58622: PUSH
58623: EMPTY
58624: LIST
58625: IN
58626: IFFALSE 58647
// points := [ 5 , 70 , 20 ] ;
58628: LD_ADDR_VAR 0 9
58632: PUSH
58633: LD_INT 5
58635: PUSH
58636: LD_INT 70
58638: PUSH
58639: LD_INT 20
58641: PUSH
58642: EMPTY
58643: LIST
58644: LIST
58645: LIST
58646: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58647: LD_VAR 0 6
58651: PPUSH
58652: CALL_OW 264
58656: PUSH
58657: LD_INT 10
58659: PUSH
58660: EMPTY
58661: LIST
58662: IN
58663: IFFALSE 58684
// points := [ 35 , 110 , 70 ] ;
58665: LD_ADDR_VAR 0 9
58669: PUSH
58670: LD_INT 35
58672: PUSH
58673: LD_INT 110
58675: PUSH
58676: LD_INT 70
58678: PUSH
58679: EMPTY
58680: LIST
58681: LIST
58682: LIST
58683: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58684: LD_VAR 0 6
58688: PPUSH
58689: CALL_OW 265
58693: PUSH
58694: LD_INT 25
58696: EQUAL
58697: IFFALSE 58718
// points := [ 80 , 65 , 100 ] ;
58699: LD_ADDR_VAR 0 9
58703: PUSH
58704: LD_INT 80
58706: PUSH
58707: LD_INT 65
58709: PUSH
58710: LD_INT 100
58712: PUSH
58713: EMPTY
58714: LIST
58715: LIST
58716: LIST
58717: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58718: LD_VAR 0 6
58722: PPUSH
58723: CALL_OW 263
58727: PUSH
58728: LD_INT 1
58730: EQUAL
58731: IFFALSE 58766
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58733: LD_ADDR_VAR 0 10
58737: PUSH
58738: LD_VAR 0 10
58742: PUSH
58743: LD_VAR 0 6
58747: PPUSH
58748: CALL_OW 311
58752: PPUSH
58753: LD_INT 3
58755: PPUSH
58756: CALL_OW 259
58760: PUSH
58761: LD_INT 4
58763: MUL
58764: MUL
58765: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58766: LD_VAR 0 6
58770: PPUSH
58771: CALL_OW 263
58775: PUSH
58776: LD_INT 2
58778: EQUAL
58779: IFFALSE 58830
// begin j := IsControledBy ( i ) ;
58781: LD_ADDR_VAR 0 7
58785: PUSH
58786: LD_VAR 0 6
58790: PPUSH
58791: CALL_OW 312
58795: ST_TO_ADDR
// if j then
58796: LD_VAR 0 7
58800: IFFALSE 58830
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58802: LD_ADDR_VAR 0 10
58806: PUSH
58807: LD_VAR 0 10
58811: PUSH
58812: LD_VAR 0 7
58816: PPUSH
58817: LD_INT 3
58819: PPUSH
58820: CALL_OW 259
58824: PUSH
58825: LD_INT 3
58827: MUL
58828: MUL
58829: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58830: LD_VAR 0 6
58834: PPUSH
58835: CALL_OW 264
58839: PUSH
58840: LD_INT 5
58842: PUSH
58843: LD_INT 6
58845: PUSH
58846: LD_INT 46
58848: PUSH
58849: LD_INT 44
58851: PUSH
58852: LD_INT 47
58854: PUSH
58855: LD_INT 45
58857: PUSH
58858: LD_INT 28
58860: PUSH
58861: LD_INT 7
58863: PUSH
58864: LD_INT 27
58866: PUSH
58867: LD_INT 29
58869: PUSH
58870: EMPTY
58871: LIST
58872: LIST
58873: LIST
58874: LIST
58875: LIST
58876: LIST
58877: LIST
58878: LIST
58879: LIST
58880: LIST
58881: IN
58882: PUSH
58883: LD_VAR 0 1
58887: PPUSH
58888: LD_INT 52
58890: PPUSH
58891: CALL_OW 321
58895: PUSH
58896: LD_INT 2
58898: EQUAL
58899: AND
58900: IFFALSE 58917
// bpoints := bpoints * 1.2 ;
58902: LD_ADDR_VAR 0 10
58906: PUSH
58907: LD_VAR 0 10
58911: PUSH
58912: LD_REAL  1.20000000000000E+0000
58915: MUL
58916: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58917: LD_VAR 0 6
58921: PPUSH
58922: CALL_OW 264
58926: PUSH
58927: LD_INT 6
58929: PUSH
58930: LD_INT 46
58932: PUSH
58933: LD_INT 47
58935: PUSH
58936: EMPTY
58937: LIST
58938: LIST
58939: LIST
58940: IN
58941: IFFALSE 58958
// bpoints := bpoints * 1.2 ;
58943: LD_ADDR_VAR 0 10
58947: PUSH
58948: LD_VAR 0 10
58952: PUSH
58953: LD_REAL  1.20000000000000E+0000
58956: MUL
58957: ST_TO_ADDR
// end ; unit_building :
58958: GO 58972
58960: LD_INT 3
58962: DOUBLE
58963: EQUAL
58964: IFTRUE 58968
58966: GO 58971
58968: POP
// ; end ;
58969: GO 58972
58971: POP
// for j = 1 to 3 do
58972: LD_ADDR_VAR 0 7
58976: PUSH
58977: DOUBLE
58978: LD_INT 1
58980: DEC
58981: ST_TO_ADDR
58982: LD_INT 3
58984: PUSH
58985: FOR_TO
58986: IFFALSE 59039
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58988: LD_ADDR_VAR 0 5
58992: PUSH
58993: LD_VAR 0 5
58997: PPUSH
58998: LD_VAR 0 7
59002: PPUSH
59003: LD_VAR 0 5
59007: PUSH
59008: LD_VAR 0 7
59012: ARRAY
59013: PUSH
59014: LD_VAR 0 9
59018: PUSH
59019: LD_VAR 0 7
59023: ARRAY
59024: PUSH
59025: LD_VAR 0 10
59029: MUL
59030: PLUS
59031: PPUSH
59032: CALL_OW 1
59036: ST_TO_ADDR
59037: GO 58985
59039: POP
59040: POP
// end ;
59041: GO 57518
59043: POP
59044: POP
// result := Replace ( result , 4 , tmp ) ;
59045: LD_ADDR_VAR 0 5
59049: PUSH
59050: LD_VAR 0 5
59054: PPUSH
59055: LD_INT 4
59057: PPUSH
59058: LD_VAR 0 8
59062: PPUSH
59063: CALL_OW 1
59067: ST_TO_ADDR
// end ;
59068: LD_VAR 0 5
59072: RET
// export function DangerAtRange ( unit , range ) ; begin
59073: LD_INT 0
59075: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59076: LD_ADDR_VAR 0 3
59080: PUSH
59081: LD_VAR 0 1
59085: PPUSH
59086: CALL_OW 255
59090: PPUSH
59091: LD_VAR 0 1
59095: PPUSH
59096: CALL_OW 250
59100: PPUSH
59101: LD_VAR 0 1
59105: PPUSH
59106: CALL_OW 251
59110: PPUSH
59111: LD_VAR 0 2
59115: PPUSH
59116: CALL 57370 0 4
59120: ST_TO_ADDR
// end ;
59121: LD_VAR 0 3
59125: RET
// export function DangerInArea ( side , area ) ; begin
59126: LD_INT 0
59128: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59129: LD_ADDR_VAR 0 3
59133: PUSH
59134: LD_VAR 0 2
59138: PPUSH
59139: LD_INT 81
59141: PUSH
59142: LD_VAR 0 1
59146: PUSH
59147: EMPTY
59148: LIST
59149: LIST
59150: PPUSH
59151: CALL_OW 70
59155: ST_TO_ADDR
// end ;
59156: LD_VAR 0 3
59160: RET
// export function IsExtension ( b ) ; begin
59161: LD_INT 0
59163: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59164: LD_ADDR_VAR 0 2
59168: PUSH
59169: LD_VAR 0 1
59173: PUSH
59174: LD_INT 23
59176: PUSH
59177: LD_INT 20
59179: PUSH
59180: LD_INT 22
59182: PUSH
59183: LD_INT 17
59185: PUSH
59186: LD_INT 24
59188: PUSH
59189: LD_INT 21
59191: PUSH
59192: LD_INT 19
59194: PUSH
59195: LD_INT 16
59197: PUSH
59198: LD_INT 25
59200: PUSH
59201: LD_INT 18
59203: PUSH
59204: EMPTY
59205: LIST
59206: LIST
59207: LIST
59208: LIST
59209: LIST
59210: LIST
59211: LIST
59212: LIST
59213: LIST
59214: LIST
59215: IN
59216: ST_TO_ADDR
// end ;
59217: LD_VAR 0 2
59221: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59222: LD_INT 0
59224: PPUSH
59225: PPUSH
59226: PPUSH
// result := [ ] ;
59227: LD_ADDR_VAR 0 4
59231: PUSH
59232: EMPTY
59233: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59234: LD_ADDR_VAR 0 5
59238: PUSH
59239: LD_VAR 0 2
59243: PPUSH
59244: LD_INT 21
59246: PUSH
59247: LD_INT 3
59249: PUSH
59250: EMPTY
59251: LIST
59252: LIST
59253: PPUSH
59254: CALL_OW 70
59258: ST_TO_ADDR
// if not tmp then
59259: LD_VAR 0 5
59263: NOT
59264: IFFALSE 59268
// exit ;
59266: GO 59332
// if checkLink then
59268: LD_VAR 0 3
59272: IFFALSE 59322
// begin for i in tmp do
59274: LD_ADDR_VAR 0 6
59278: PUSH
59279: LD_VAR 0 5
59283: PUSH
59284: FOR_IN
59285: IFFALSE 59320
// if GetBase ( i ) <> base then
59287: LD_VAR 0 6
59291: PPUSH
59292: CALL_OW 274
59296: PUSH
59297: LD_VAR 0 1
59301: NONEQUAL
59302: IFFALSE 59318
// ComLinkToBase ( base , i ) ;
59304: LD_VAR 0 1
59308: PPUSH
59309: LD_VAR 0 6
59313: PPUSH
59314: CALL_OW 169
59318: GO 59284
59320: POP
59321: POP
// end ; result := tmp ;
59322: LD_ADDR_VAR 0 4
59326: PUSH
59327: LD_VAR 0 5
59331: ST_TO_ADDR
// end ;
59332: LD_VAR 0 4
59336: RET
// export function ComComplete ( units , b ) ; var i ; begin
59337: LD_INT 0
59339: PPUSH
59340: PPUSH
// if not units then
59341: LD_VAR 0 1
59345: NOT
59346: IFFALSE 59350
// exit ;
59348: GO 59440
// for i in units do
59350: LD_ADDR_VAR 0 4
59354: PUSH
59355: LD_VAR 0 1
59359: PUSH
59360: FOR_IN
59361: IFFALSE 59438
// if BuildingStatus ( b ) = bs_build then
59363: LD_VAR 0 2
59367: PPUSH
59368: CALL_OW 461
59372: PUSH
59373: LD_INT 1
59375: EQUAL
59376: IFFALSE 59436
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59378: LD_VAR 0 4
59382: PPUSH
59383: LD_STRING h
59385: PUSH
59386: LD_VAR 0 2
59390: PPUSH
59391: CALL_OW 250
59395: PUSH
59396: LD_VAR 0 2
59400: PPUSH
59401: CALL_OW 251
59405: PUSH
59406: LD_VAR 0 2
59410: PUSH
59411: LD_INT 0
59413: PUSH
59414: LD_INT 0
59416: PUSH
59417: LD_INT 0
59419: PUSH
59420: EMPTY
59421: LIST
59422: LIST
59423: LIST
59424: LIST
59425: LIST
59426: LIST
59427: LIST
59428: PUSH
59429: EMPTY
59430: LIST
59431: PPUSH
59432: CALL_OW 446
59436: GO 59360
59438: POP
59439: POP
// end ;
59440: LD_VAR 0 3
59444: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59445: LD_INT 0
59447: PPUSH
59448: PPUSH
59449: PPUSH
59450: PPUSH
59451: PPUSH
59452: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
59453: LD_VAR 0 1
59457: NOT
59458: PUSH
59459: LD_VAR 0 1
59463: PPUSH
59464: CALL_OW 263
59468: PUSH
59469: LD_INT 2
59471: NONEQUAL
59472: OR
59473: IFFALSE 59477
// exit ;
59475: GO 59793
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59477: LD_ADDR_VAR 0 6
59481: PUSH
59482: LD_INT 22
59484: PUSH
59485: LD_VAR 0 1
59489: PPUSH
59490: CALL_OW 255
59494: PUSH
59495: EMPTY
59496: LIST
59497: LIST
59498: PUSH
59499: LD_INT 2
59501: PUSH
59502: LD_INT 30
59504: PUSH
59505: LD_INT 36
59507: PUSH
59508: EMPTY
59509: LIST
59510: LIST
59511: PUSH
59512: LD_INT 34
59514: PUSH
59515: LD_INT 31
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: LIST
59526: PUSH
59527: EMPTY
59528: LIST
59529: LIST
59530: PPUSH
59531: CALL_OW 69
59535: ST_TO_ADDR
// if not tmp then
59536: LD_VAR 0 6
59540: NOT
59541: IFFALSE 59545
// exit ;
59543: GO 59793
// result := [ ] ;
59545: LD_ADDR_VAR 0 2
59549: PUSH
59550: EMPTY
59551: ST_TO_ADDR
// for i in tmp do
59552: LD_ADDR_VAR 0 3
59556: PUSH
59557: LD_VAR 0 6
59561: PUSH
59562: FOR_IN
59563: IFFALSE 59634
// begin t := UnitsInside ( i ) ;
59565: LD_ADDR_VAR 0 4
59569: PUSH
59570: LD_VAR 0 3
59574: PPUSH
59575: CALL_OW 313
59579: ST_TO_ADDR
// if t then
59580: LD_VAR 0 4
59584: IFFALSE 59632
// for j in t do
59586: LD_ADDR_VAR 0 7
59590: PUSH
59591: LD_VAR 0 4
59595: PUSH
59596: FOR_IN
59597: IFFALSE 59630
// result := Replace ( result , result + 1 , j ) ;
59599: LD_ADDR_VAR 0 2
59603: PUSH
59604: LD_VAR 0 2
59608: PPUSH
59609: LD_VAR 0 2
59613: PUSH
59614: LD_INT 1
59616: PLUS
59617: PPUSH
59618: LD_VAR 0 7
59622: PPUSH
59623: CALL_OW 1
59627: ST_TO_ADDR
59628: GO 59596
59630: POP
59631: POP
// end ;
59632: GO 59562
59634: POP
59635: POP
// if not result then
59636: LD_VAR 0 2
59640: NOT
59641: IFFALSE 59645
// exit ;
59643: GO 59793
// mech := result [ 1 ] ;
59645: LD_ADDR_VAR 0 5
59649: PUSH
59650: LD_VAR 0 2
59654: PUSH
59655: LD_INT 1
59657: ARRAY
59658: ST_TO_ADDR
// if result > 1 then
59659: LD_VAR 0 2
59663: PUSH
59664: LD_INT 1
59666: GREATER
59667: IFFALSE 59779
// begin for i = 2 to result do
59669: LD_ADDR_VAR 0 3
59673: PUSH
59674: DOUBLE
59675: LD_INT 2
59677: DEC
59678: ST_TO_ADDR
59679: LD_VAR 0 2
59683: PUSH
59684: FOR_TO
59685: IFFALSE 59777
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59687: LD_ADDR_VAR 0 4
59691: PUSH
59692: LD_VAR 0 2
59696: PUSH
59697: LD_VAR 0 3
59701: ARRAY
59702: PPUSH
59703: LD_INT 3
59705: PPUSH
59706: CALL_OW 259
59710: PUSH
59711: LD_VAR 0 2
59715: PUSH
59716: LD_VAR 0 3
59720: ARRAY
59721: PPUSH
59722: CALL_OW 432
59726: MINUS
59727: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59728: LD_VAR 0 4
59732: PUSH
59733: LD_VAR 0 5
59737: PPUSH
59738: LD_INT 3
59740: PPUSH
59741: CALL_OW 259
59745: PUSH
59746: LD_VAR 0 5
59750: PPUSH
59751: CALL_OW 432
59755: MINUS
59756: GREATEREQUAL
59757: IFFALSE 59775
// mech := result [ i ] ;
59759: LD_ADDR_VAR 0 5
59763: PUSH
59764: LD_VAR 0 2
59768: PUSH
59769: LD_VAR 0 3
59773: ARRAY
59774: ST_TO_ADDR
// end ;
59775: GO 59684
59777: POP
59778: POP
// end ; ComLinkTo ( vehicle , mech ) ;
59779: LD_VAR 0 1
59783: PPUSH
59784: LD_VAR 0 5
59788: PPUSH
59789: CALL_OW 135
// end ;
59793: LD_VAR 0 2
59797: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59798: LD_INT 0
59800: PPUSH
59801: PPUSH
59802: PPUSH
59803: PPUSH
59804: PPUSH
59805: PPUSH
59806: PPUSH
59807: PPUSH
59808: PPUSH
59809: PPUSH
59810: PPUSH
59811: PPUSH
59812: PPUSH
// result := [ ] ;
59813: LD_ADDR_VAR 0 7
59817: PUSH
59818: EMPTY
59819: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59820: LD_VAR 0 1
59824: PPUSH
59825: CALL_OW 266
59829: PUSH
59830: LD_INT 0
59832: PUSH
59833: LD_INT 1
59835: PUSH
59836: EMPTY
59837: LIST
59838: LIST
59839: IN
59840: NOT
59841: IFFALSE 59845
// exit ;
59843: GO 61479
// if name then
59845: LD_VAR 0 3
59849: IFFALSE 59865
// SetBName ( base_dep , name ) ;
59851: LD_VAR 0 1
59855: PPUSH
59856: LD_VAR 0 3
59860: PPUSH
59861: CALL_OW 500
// base := GetBase ( base_dep ) ;
59865: LD_ADDR_VAR 0 15
59869: PUSH
59870: LD_VAR 0 1
59874: PPUSH
59875: CALL_OW 274
59879: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59880: LD_ADDR_VAR 0 16
59884: PUSH
59885: LD_VAR 0 1
59889: PPUSH
59890: CALL_OW 255
59894: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59895: LD_ADDR_VAR 0 17
59899: PUSH
59900: LD_VAR 0 1
59904: PPUSH
59905: CALL_OW 248
59909: ST_TO_ADDR
// if sources then
59910: LD_VAR 0 5
59914: IFFALSE 59961
// for i = 1 to 3 do
59916: LD_ADDR_VAR 0 8
59920: PUSH
59921: DOUBLE
59922: LD_INT 1
59924: DEC
59925: ST_TO_ADDR
59926: LD_INT 3
59928: PUSH
59929: FOR_TO
59930: IFFALSE 59959
// AddResourceType ( base , i , sources [ i ] ) ;
59932: LD_VAR 0 15
59936: PPUSH
59937: LD_VAR 0 8
59941: PPUSH
59942: LD_VAR 0 5
59946: PUSH
59947: LD_VAR 0 8
59951: ARRAY
59952: PPUSH
59953: CALL_OW 276
59957: GO 59929
59959: POP
59960: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
59961: LD_ADDR_VAR 0 18
59965: PUSH
59966: LD_VAR 0 15
59970: PPUSH
59971: LD_VAR 0 2
59975: PPUSH
59976: LD_INT 1
59978: PPUSH
59979: CALL 59222 0 3
59983: ST_TO_ADDR
// InitHc ;
59984: CALL_OW 19
// InitUc ;
59988: CALL_OW 18
// uc_side := side ;
59992: LD_ADDR_OWVAR 20
59996: PUSH
59997: LD_VAR 0 16
60001: ST_TO_ADDR
// uc_nation := nation ;
60002: LD_ADDR_OWVAR 21
60006: PUSH
60007: LD_VAR 0 17
60011: ST_TO_ADDR
// if buildings then
60012: LD_VAR 0 18
60016: IFFALSE 61338
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60018: LD_ADDR_VAR 0 19
60022: PUSH
60023: LD_VAR 0 18
60027: PPUSH
60028: LD_INT 2
60030: PUSH
60031: LD_INT 30
60033: PUSH
60034: LD_INT 29
60036: PUSH
60037: EMPTY
60038: LIST
60039: LIST
60040: PUSH
60041: LD_INT 30
60043: PUSH
60044: LD_INT 30
60046: PUSH
60047: EMPTY
60048: LIST
60049: LIST
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: LIST
60055: PPUSH
60056: CALL_OW 72
60060: ST_TO_ADDR
// if tmp then
60061: LD_VAR 0 19
60065: IFFALSE 60113
// for i in tmp do
60067: LD_ADDR_VAR 0 8
60071: PUSH
60072: LD_VAR 0 19
60076: PUSH
60077: FOR_IN
60078: IFFALSE 60111
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60080: LD_VAR 0 8
60084: PPUSH
60085: CALL_OW 250
60089: PPUSH
60090: LD_VAR 0 8
60094: PPUSH
60095: CALL_OW 251
60099: PPUSH
60100: LD_VAR 0 16
60104: PPUSH
60105: CALL_OW 441
60109: GO 60077
60111: POP
60112: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60113: LD_VAR 0 18
60117: PPUSH
60118: LD_INT 2
60120: PUSH
60121: LD_INT 30
60123: PUSH
60124: LD_INT 32
60126: PUSH
60127: EMPTY
60128: LIST
60129: LIST
60130: PUSH
60131: LD_INT 30
60133: PUSH
60134: LD_INT 33
60136: PUSH
60137: EMPTY
60138: LIST
60139: LIST
60140: PUSH
60141: EMPTY
60142: LIST
60143: LIST
60144: LIST
60145: PPUSH
60146: CALL_OW 72
60150: IFFALSE 60238
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60152: LD_ADDR_VAR 0 8
60156: PUSH
60157: LD_VAR 0 18
60161: PPUSH
60162: LD_INT 2
60164: PUSH
60165: LD_INT 30
60167: PUSH
60168: LD_INT 32
60170: PUSH
60171: EMPTY
60172: LIST
60173: LIST
60174: PUSH
60175: LD_INT 30
60177: PUSH
60178: LD_INT 33
60180: PUSH
60181: EMPTY
60182: LIST
60183: LIST
60184: PUSH
60185: EMPTY
60186: LIST
60187: LIST
60188: LIST
60189: PPUSH
60190: CALL_OW 72
60194: PUSH
60195: FOR_IN
60196: IFFALSE 60236
// begin if not GetBWeapon ( i ) then
60198: LD_VAR 0 8
60202: PPUSH
60203: CALL_OW 269
60207: NOT
60208: IFFALSE 60234
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60210: LD_VAR 0 8
60214: PPUSH
60215: LD_VAR 0 8
60219: PPUSH
60220: LD_VAR 0 2
60224: PPUSH
60225: CALL 61484 0 2
60229: PPUSH
60230: CALL_OW 431
// end ;
60234: GO 60195
60236: POP
60237: POP
// end ; for i = 1 to personel do
60238: LD_ADDR_VAR 0 8
60242: PUSH
60243: DOUBLE
60244: LD_INT 1
60246: DEC
60247: ST_TO_ADDR
60248: LD_VAR 0 6
60252: PUSH
60253: FOR_TO
60254: IFFALSE 61318
// begin if i > 4 then
60256: LD_VAR 0 8
60260: PUSH
60261: LD_INT 4
60263: GREATER
60264: IFFALSE 60268
// break ;
60266: GO 61318
// case i of 1 :
60268: LD_VAR 0 8
60272: PUSH
60273: LD_INT 1
60275: DOUBLE
60276: EQUAL
60277: IFTRUE 60281
60279: GO 60361
60281: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60282: LD_ADDR_VAR 0 12
60286: PUSH
60287: LD_VAR 0 18
60291: PPUSH
60292: LD_INT 22
60294: PUSH
60295: LD_VAR 0 16
60299: PUSH
60300: EMPTY
60301: LIST
60302: LIST
60303: PUSH
60304: LD_INT 58
60306: PUSH
60307: EMPTY
60308: LIST
60309: PUSH
60310: LD_INT 2
60312: PUSH
60313: LD_INT 30
60315: PUSH
60316: LD_INT 32
60318: PUSH
60319: EMPTY
60320: LIST
60321: LIST
60322: PUSH
60323: LD_INT 30
60325: PUSH
60326: LD_INT 4
60328: PUSH
60329: EMPTY
60330: LIST
60331: LIST
60332: PUSH
60333: LD_INT 30
60335: PUSH
60336: LD_INT 5
60338: PUSH
60339: EMPTY
60340: LIST
60341: LIST
60342: PUSH
60343: EMPTY
60344: LIST
60345: LIST
60346: LIST
60347: LIST
60348: PUSH
60349: EMPTY
60350: LIST
60351: LIST
60352: LIST
60353: PPUSH
60354: CALL_OW 72
60358: ST_TO_ADDR
60359: GO 60583
60361: LD_INT 2
60363: DOUBLE
60364: EQUAL
60365: IFTRUE 60369
60367: GO 60431
60369: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60370: LD_ADDR_VAR 0 12
60374: PUSH
60375: LD_VAR 0 18
60379: PPUSH
60380: LD_INT 22
60382: PUSH
60383: LD_VAR 0 16
60387: PUSH
60388: EMPTY
60389: LIST
60390: LIST
60391: PUSH
60392: LD_INT 2
60394: PUSH
60395: LD_INT 30
60397: PUSH
60398: LD_INT 0
60400: PUSH
60401: EMPTY
60402: LIST
60403: LIST
60404: PUSH
60405: LD_INT 30
60407: PUSH
60408: LD_INT 1
60410: PUSH
60411: EMPTY
60412: LIST
60413: LIST
60414: PUSH
60415: EMPTY
60416: LIST
60417: LIST
60418: LIST
60419: PUSH
60420: EMPTY
60421: LIST
60422: LIST
60423: PPUSH
60424: CALL_OW 72
60428: ST_TO_ADDR
60429: GO 60583
60431: LD_INT 3
60433: DOUBLE
60434: EQUAL
60435: IFTRUE 60439
60437: GO 60501
60439: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60440: LD_ADDR_VAR 0 12
60444: PUSH
60445: LD_VAR 0 18
60449: PPUSH
60450: LD_INT 22
60452: PUSH
60453: LD_VAR 0 16
60457: PUSH
60458: EMPTY
60459: LIST
60460: LIST
60461: PUSH
60462: LD_INT 2
60464: PUSH
60465: LD_INT 30
60467: PUSH
60468: LD_INT 2
60470: PUSH
60471: EMPTY
60472: LIST
60473: LIST
60474: PUSH
60475: LD_INT 30
60477: PUSH
60478: LD_INT 3
60480: PUSH
60481: EMPTY
60482: LIST
60483: LIST
60484: PUSH
60485: EMPTY
60486: LIST
60487: LIST
60488: LIST
60489: PUSH
60490: EMPTY
60491: LIST
60492: LIST
60493: PPUSH
60494: CALL_OW 72
60498: ST_TO_ADDR
60499: GO 60583
60501: LD_INT 4
60503: DOUBLE
60504: EQUAL
60505: IFTRUE 60509
60507: GO 60582
60509: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60510: LD_ADDR_VAR 0 12
60514: PUSH
60515: LD_VAR 0 18
60519: PPUSH
60520: LD_INT 22
60522: PUSH
60523: LD_VAR 0 16
60527: PUSH
60528: EMPTY
60529: LIST
60530: LIST
60531: PUSH
60532: LD_INT 2
60534: PUSH
60535: LD_INT 30
60537: PUSH
60538: LD_INT 6
60540: PUSH
60541: EMPTY
60542: LIST
60543: LIST
60544: PUSH
60545: LD_INT 30
60547: PUSH
60548: LD_INT 7
60550: PUSH
60551: EMPTY
60552: LIST
60553: LIST
60554: PUSH
60555: LD_INT 30
60557: PUSH
60558: LD_INT 8
60560: PUSH
60561: EMPTY
60562: LIST
60563: LIST
60564: PUSH
60565: EMPTY
60566: LIST
60567: LIST
60568: LIST
60569: LIST
60570: PUSH
60571: EMPTY
60572: LIST
60573: LIST
60574: PPUSH
60575: CALL_OW 72
60579: ST_TO_ADDR
60580: GO 60583
60582: POP
// if i = 1 then
60583: LD_VAR 0 8
60587: PUSH
60588: LD_INT 1
60590: EQUAL
60591: IFFALSE 60702
// begin tmp := [ ] ;
60593: LD_ADDR_VAR 0 19
60597: PUSH
60598: EMPTY
60599: ST_TO_ADDR
// for j in f do
60600: LD_ADDR_VAR 0 9
60604: PUSH
60605: LD_VAR 0 12
60609: PUSH
60610: FOR_IN
60611: IFFALSE 60684
// if GetBType ( j ) = b_bunker then
60613: LD_VAR 0 9
60617: PPUSH
60618: CALL_OW 266
60622: PUSH
60623: LD_INT 32
60625: EQUAL
60626: IFFALSE 60653
// tmp := Insert ( tmp , 1 , j ) else
60628: LD_ADDR_VAR 0 19
60632: PUSH
60633: LD_VAR 0 19
60637: PPUSH
60638: LD_INT 1
60640: PPUSH
60641: LD_VAR 0 9
60645: PPUSH
60646: CALL_OW 2
60650: ST_TO_ADDR
60651: GO 60682
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60653: LD_ADDR_VAR 0 19
60657: PUSH
60658: LD_VAR 0 19
60662: PPUSH
60663: LD_VAR 0 19
60667: PUSH
60668: LD_INT 1
60670: PLUS
60671: PPUSH
60672: LD_VAR 0 9
60676: PPUSH
60677: CALL_OW 2
60681: ST_TO_ADDR
60682: GO 60610
60684: POP
60685: POP
// if tmp then
60686: LD_VAR 0 19
60690: IFFALSE 60702
// f := tmp ;
60692: LD_ADDR_VAR 0 12
60696: PUSH
60697: LD_VAR 0 19
60701: ST_TO_ADDR
// end ; x := personel [ i ] ;
60702: LD_ADDR_VAR 0 13
60706: PUSH
60707: LD_VAR 0 6
60711: PUSH
60712: LD_VAR 0 8
60716: ARRAY
60717: ST_TO_ADDR
// if x = - 1 then
60718: LD_VAR 0 13
60722: PUSH
60723: LD_INT 1
60725: NEG
60726: EQUAL
60727: IFFALSE 60936
// begin for j in f do
60729: LD_ADDR_VAR 0 9
60733: PUSH
60734: LD_VAR 0 12
60738: PUSH
60739: FOR_IN
60740: IFFALSE 60932
// repeat InitHc ;
60742: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60746: LD_VAR 0 9
60750: PPUSH
60751: CALL_OW 266
60755: PUSH
60756: LD_INT 5
60758: EQUAL
60759: IFFALSE 60829
// begin if UnitsInside ( j ) < 3 then
60761: LD_VAR 0 9
60765: PPUSH
60766: CALL_OW 313
60770: PUSH
60771: LD_INT 3
60773: LESS
60774: IFFALSE 60810
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60776: LD_INT 0
60778: PPUSH
60779: LD_INT 5
60781: PUSH
60782: LD_INT 8
60784: PUSH
60785: LD_INT 9
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: LIST
60792: PUSH
60793: LD_VAR 0 17
60797: ARRAY
60798: PPUSH
60799: LD_VAR 0 4
60803: PPUSH
60804: CALL_OW 380
60808: GO 60827
// PrepareHuman ( false , i , skill ) ;
60810: LD_INT 0
60812: PPUSH
60813: LD_VAR 0 8
60817: PPUSH
60818: LD_VAR 0 4
60822: PPUSH
60823: CALL_OW 380
// end else
60827: GO 60846
// PrepareHuman ( false , i , skill ) ;
60829: LD_INT 0
60831: PPUSH
60832: LD_VAR 0 8
60836: PPUSH
60837: LD_VAR 0 4
60841: PPUSH
60842: CALL_OW 380
// un := CreateHuman ;
60846: LD_ADDR_VAR 0 14
60850: PUSH
60851: CALL_OW 44
60855: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60856: LD_ADDR_VAR 0 7
60860: PUSH
60861: LD_VAR 0 7
60865: PPUSH
60866: LD_INT 1
60868: PPUSH
60869: LD_VAR 0 14
60873: PPUSH
60874: CALL_OW 2
60878: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60879: LD_VAR 0 14
60883: PPUSH
60884: LD_VAR 0 9
60888: PPUSH
60889: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60893: LD_VAR 0 9
60897: PPUSH
60898: CALL_OW 313
60902: PUSH
60903: LD_INT 6
60905: EQUAL
60906: PUSH
60907: LD_VAR 0 9
60911: PPUSH
60912: CALL_OW 266
60916: PUSH
60917: LD_INT 32
60919: PUSH
60920: LD_INT 31
60922: PUSH
60923: EMPTY
60924: LIST
60925: LIST
60926: IN
60927: OR
60928: IFFALSE 60742
60930: GO 60739
60932: POP
60933: POP
// end else
60934: GO 61316
// for j = 1 to x do
60936: LD_ADDR_VAR 0 9
60940: PUSH
60941: DOUBLE
60942: LD_INT 1
60944: DEC
60945: ST_TO_ADDR
60946: LD_VAR 0 13
60950: PUSH
60951: FOR_TO
60952: IFFALSE 61314
// begin InitHc ;
60954: CALL_OW 19
// if not f then
60958: LD_VAR 0 12
60962: NOT
60963: IFFALSE 61052
// begin PrepareHuman ( false , i , skill ) ;
60965: LD_INT 0
60967: PPUSH
60968: LD_VAR 0 8
60972: PPUSH
60973: LD_VAR 0 4
60977: PPUSH
60978: CALL_OW 380
// un := CreateHuman ;
60982: LD_ADDR_VAR 0 14
60986: PUSH
60987: CALL_OW 44
60991: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60992: LD_ADDR_VAR 0 7
60996: PUSH
60997: LD_VAR 0 7
61001: PPUSH
61002: LD_INT 1
61004: PPUSH
61005: LD_VAR 0 14
61009: PPUSH
61010: CALL_OW 2
61014: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61015: LD_VAR 0 14
61019: PPUSH
61020: LD_VAR 0 1
61024: PPUSH
61025: CALL_OW 250
61029: PPUSH
61030: LD_VAR 0 1
61034: PPUSH
61035: CALL_OW 251
61039: PPUSH
61040: LD_INT 10
61042: PPUSH
61043: LD_INT 0
61045: PPUSH
61046: CALL_OW 50
// continue ;
61050: GO 60951
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61052: LD_VAR 0 12
61056: PUSH
61057: LD_INT 1
61059: ARRAY
61060: PPUSH
61061: CALL_OW 313
61065: PUSH
61066: LD_VAR 0 12
61070: PUSH
61071: LD_INT 1
61073: ARRAY
61074: PPUSH
61075: CALL_OW 266
61079: PUSH
61080: LD_INT 32
61082: PUSH
61083: LD_INT 31
61085: PUSH
61086: EMPTY
61087: LIST
61088: LIST
61089: IN
61090: AND
61091: PUSH
61092: LD_VAR 0 12
61096: PUSH
61097: LD_INT 1
61099: ARRAY
61100: PPUSH
61101: CALL_OW 313
61105: PUSH
61106: LD_INT 6
61108: EQUAL
61109: OR
61110: IFFALSE 61130
// f := Delete ( f , 1 ) ;
61112: LD_ADDR_VAR 0 12
61116: PUSH
61117: LD_VAR 0 12
61121: PPUSH
61122: LD_INT 1
61124: PPUSH
61125: CALL_OW 3
61129: ST_TO_ADDR
// if not f then
61130: LD_VAR 0 12
61134: NOT
61135: IFFALSE 61153
// begin x := x + 2 ;
61137: LD_ADDR_VAR 0 13
61141: PUSH
61142: LD_VAR 0 13
61146: PUSH
61147: LD_INT 2
61149: PLUS
61150: ST_TO_ADDR
// continue ;
61151: GO 60951
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61153: LD_VAR 0 12
61157: PUSH
61158: LD_INT 1
61160: ARRAY
61161: PPUSH
61162: CALL_OW 266
61166: PUSH
61167: LD_INT 5
61169: EQUAL
61170: IFFALSE 61244
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61172: LD_VAR 0 12
61176: PUSH
61177: LD_INT 1
61179: ARRAY
61180: PPUSH
61181: CALL_OW 313
61185: PUSH
61186: LD_INT 3
61188: LESS
61189: IFFALSE 61225
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61191: LD_INT 0
61193: PPUSH
61194: LD_INT 5
61196: PUSH
61197: LD_INT 8
61199: PUSH
61200: LD_INT 9
61202: PUSH
61203: EMPTY
61204: LIST
61205: LIST
61206: LIST
61207: PUSH
61208: LD_VAR 0 17
61212: ARRAY
61213: PPUSH
61214: LD_VAR 0 4
61218: PPUSH
61219: CALL_OW 380
61223: GO 61242
// PrepareHuman ( false , i , skill ) ;
61225: LD_INT 0
61227: PPUSH
61228: LD_VAR 0 8
61232: PPUSH
61233: LD_VAR 0 4
61237: PPUSH
61238: CALL_OW 380
// end else
61242: GO 61261
// PrepareHuman ( false , i , skill ) ;
61244: LD_INT 0
61246: PPUSH
61247: LD_VAR 0 8
61251: PPUSH
61252: LD_VAR 0 4
61256: PPUSH
61257: CALL_OW 380
// un := CreateHuman ;
61261: LD_ADDR_VAR 0 14
61265: PUSH
61266: CALL_OW 44
61270: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61271: LD_ADDR_VAR 0 7
61275: PUSH
61276: LD_VAR 0 7
61280: PPUSH
61281: LD_INT 1
61283: PPUSH
61284: LD_VAR 0 14
61288: PPUSH
61289: CALL_OW 2
61293: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61294: LD_VAR 0 14
61298: PPUSH
61299: LD_VAR 0 12
61303: PUSH
61304: LD_INT 1
61306: ARRAY
61307: PPUSH
61308: CALL_OW 52
// end ;
61312: GO 60951
61314: POP
61315: POP
// end ;
61316: GO 60253
61318: POP
61319: POP
// result := result ^ buildings ;
61320: LD_ADDR_VAR 0 7
61324: PUSH
61325: LD_VAR 0 7
61329: PUSH
61330: LD_VAR 0 18
61334: ADD
61335: ST_TO_ADDR
// end else
61336: GO 61479
// begin for i = 1 to personel do
61338: LD_ADDR_VAR 0 8
61342: PUSH
61343: DOUBLE
61344: LD_INT 1
61346: DEC
61347: ST_TO_ADDR
61348: LD_VAR 0 6
61352: PUSH
61353: FOR_TO
61354: IFFALSE 61477
// begin if i > 4 then
61356: LD_VAR 0 8
61360: PUSH
61361: LD_INT 4
61363: GREATER
61364: IFFALSE 61368
// break ;
61366: GO 61477
// x := personel [ i ] ;
61368: LD_ADDR_VAR 0 13
61372: PUSH
61373: LD_VAR 0 6
61377: PUSH
61378: LD_VAR 0 8
61382: ARRAY
61383: ST_TO_ADDR
// if x = - 1 then
61384: LD_VAR 0 13
61388: PUSH
61389: LD_INT 1
61391: NEG
61392: EQUAL
61393: IFFALSE 61397
// continue ;
61395: GO 61353
// PrepareHuman ( false , i , skill ) ;
61397: LD_INT 0
61399: PPUSH
61400: LD_VAR 0 8
61404: PPUSH
61405: LD_VAR 0 4
61409: PPUSH
61410: CALL_OW 380
// un := CreateHuman ;
61414: LD_ADDR_VAR 0 14
61418: PUSH
61419: CALL_OW 44
61423: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61424: LD_VAR 0 14
61428: PPUSH
61429: LD_VAR 0 1
61433: PPUSH
61434: CALL_OW 250
61438: PPUSH
61439: LD_VAR 0 1
61443: PPUSH
61444: CALL_OW 251
61448: PPUSH
61449: LD_INT 10
61451: PPUSH
61452: LD_INT 0
61454: PPUSH
61455: CALL_OW 50
// result := result ^ un ;
61459: LD_ADDR_VAR 0 7
61463: PUSH
61464: LD_VAR 0 7
61468: PUSH
61469: LD_VAR 0 14
61473: ADD
61474: ST_TO_ADDR
// end ;
61475: GO 61353
61477: POP
61478: POP
// end ; end ;
61479: LD_VAR 0 7
61483: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61484: LD_INT 0
61486: PPUSH
61487: PPUSH
61488: PPUSH
61489: PPUSH
61490: PPUSH
61491: PPUSH
61492: PPUSH
61493: PPUSH
61494: PPUSH
61495: PPUSH
61496: PPUSH
61497: PPUSH
61498: PPUSH
61499: PPUSH
61500: PPUSH
61501: PPUSH
// result := false ;
61502: LD_ADDR_VAR 0 3
61506: PUSH
61507: LD_INT 0
61509: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61510: LD_VAR 0 1
61514: NOT
61515: PUSH
61516: LD_VAR 0 1
61520: PPUSH
61521: CALL_OW 266
61525: PUSH
61526: LD_INT 32
61528: PUSH
61529: LD_INT 33
61531: PUSH
61532: EMPTY
61533: LIST
61534: LIST
61535: IN
61536: NOT
61537: OR
61538: IFFALSE 61542
// exit ;
61540: GO 62651
// nat := GetNation ( tower ) ;
61542: LD_ADDR_VAR 0 12
61546: PUSH
61547: LD_VAR 0 1
61551: PPUSH
61552: CALL_OW 248
61556: ST_TO_ADDR
// side := GetSide ( tower ) ;
61557: LD_ADDR_VAR 0 16
61561: PUSH
61562: LD_VAR 0 1
61566: PPUSH
61567: CALL_OW 255
61571: ST_TO_ADDR
// x := GetX ( tower ) ;
61572: LD_ADDR_VAR 0 10
61576: PUSH
61577: LD_VAR 0 1
61581: PPUSH
61582: CALL_OW 250
61586: ST_TO_ADDR
// y := GetY ( tower ) ;
61587: LD_ADDR_VAR 0 11
61591: PUSH
61592: LD_VAR 0 1
61596: PPUSH
61597: CALL_OW 251
61601: ST_TO_ADDR
// if not x or not y then
61602: LD_VAR 0 10
61606: NOT
61607: PUSH
61608: LD_VAR 0 11
61612: NOT
61613: OR
61614: IFFALSE 61618
// exit ;
61616: GO 62651
// weapon := 0 ;
61618: LD_ADDR_VAR 0 18
61622: PUSH
61623: LD_INT 0
61625: ST_TO_ADDR
// fac_list := [ ] ;
61626: LD_ADDR_VAR 0 17
61630: PUSH
61631: EMPTY
61632: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
61633: LD_ADDR_VAR 0 6
61637: PUSH
61638: LD_VAR 0 1
61642: PPUSH
61643: CALL_OW 274
61647: PPUSH
61648: LD_VAR 0 2
61652: PPUSH
61653: LD_INT 0
61655: PPUSH
61656: CALL 59222 0 3
61660: PPUSH
61661: LD_INT 30
61663: PUSH
61664: LD_INT 3
61666: PUSH
61667: EMPTY
61668: LIST
61669: LIST
61670: PPUSH
61671: CALL_OW 72
61675: ST_TO_ADDR
// if not factories then
61676: LD_VAR 0 6
61680: NOT
61681: IFFALSE 61685
// exit ;
61683: GO 62651
// for i in factories do
61685: LD_ADDR_VAR 0 8
61689: PUSH
61690: LD_VAR 0 6
61694: PUSH
61695: FOR_IN
61696: IFFALSE 61721
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61698: LD_ADDR_VAR 0 17
61702: PUSH
61703: LD_VAR 0 17
61707: PUSH
61708: LD_VAR 0 8
61712: PPUSH
61713: CALL_OW 478
61717: UNION
61718: ST_TO_ADDR
61719: GO 61695
61721: POP
61722: POP
// if not fac_list then
61723: LD_VAR 0 17
61727: NOT
61728: IFFALSE 61732
// exit ;
61730: GO 62651
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61732: LD_ADDR_VAR 0 5
61736: PUSH
61737: LD_INT 4
61739: PUSH
61740: LD_INT 5
61742: PUSH
61743: LD_INT 9
61745: PUSH
61746: LD_INT 10
61748: PUSH
61749: LD_INT 6
61751: PUSH
61752: LD_INT 7
61754: PUSH
61755: LD_INT 11
61757: PUSH
61758: EMPTY
61759: LIST
61760: LIST
61761: LIST
61762: LIST
61763: LIST
61764: LIST
61765: LIST
61766: PUSH
61767: LD_INT 27
61769: PUSH
61770: LD_INT 28
61772: PUSH
61773: LD_INT 26
61775: PUSH
61776: LD_INT 30
61778: PUSH
61779: EMPTY
61780: LIST
61781: LIST
61782: LIST
61783: LIST
61784: PUSH
61785: LD_INT 43
61787: PUSH
61788: LD_INT 44
61790: PUSH
61791: LD_INT 46
61793: PUSH
61794: LD_INT 45
61796: PUSH
61797: LD_INT 47
61799: PUSH
61800: LD_INT 49
61802: PUSH
61803: EMPTY
61804: LIST
61805: LIST
61806: LIST
61807: LIST
61808: LIST
61809: LIST
61810: PUSH
61811: EMPTY
61812: LIST
61813: LIST
61814: LIST
61815: PUSH
61816: LD_VAR 0 12
61820: ARRAY
61821: ST_TO_ADDR
// list := list isect fac_list ;
61822: LD_ADDR_VAR 0 5
61826: PUSH
61827: LD_VAR 0 5
61831: PUSH
61832: LD_VAR 0 17
61836: ISECT
61837: ST_TO_ADDR
// if not list then
61838: LD_VAR 0 5
61842: NOT
61843: IFFALSE 61847
// exit ;
61845: GO 62651
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61847: LD_VAR 0 12
61851: PUSH
61852: LD_INT 3
61854: EQUAL
61855: PUSH
61856: LD_INT 49
61858: PUSH
61859: LD_VAR 0 5
61863: IN
61864: AND
61865: PUSH
61866: LD_INT 31
61868: PPUSH
61869: LD_VAR 0 16
61873: PPUSH
61874: CALL_OW 321
61878: PUSH
61879: LD_INT 2
61881: EQUAL
61882: AND
61883: IFFALSE 61943
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61885: LD_INT 22
61887: PUSH
61888: LD_VAR 0 16
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: PUSH
61897: LD_INT 35
61899: PUSH
61900: LD_INT 49
61902: PUSH
61903: EMPTY
61904: LIST
61905: LIST
61906: PUSH
61907: LD_INT 91
61909: PUSH
61910: LD_VAR 0 1
61914: PUSH
61915: LD_INT 10
61917: PUSH
61918: EMPTY
61919: LIST
61920: LIST
61921: LIST
61922: PUSH
61923: EMPTY
61924: LIST
61925: LIST
61926: LIST
61927: PPUSH
61928: CALL_OW 69
61932: NOT
61933: IFFALSE 61943
// weapon := ru_time_lapser ;
61935: LD_ADDR_VAR 0 18
61939: PUSH
61940: LD_INT 49
61942: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61943: LD_VAR 0 12
61947: PUSH
61948: LD_INT 1
61950: PUSH
61951: LD_INT 2
61953: PUSH
61954: EMPTY
61955: LIST
61956: LIST
61957: IN
61958: PUSH
61959: LD_INT 11
61961: PUSH
61962: LD_VAR 0 5
61966: IN
61967: PUSH
61968: LD_INT 30
61970: PUSH
61971: LD_VAR 0 5
61975: IN
61976: OR
61977: AND
61978: PUSH
61979: LD_INT 6
61981: PPUSH
61982: LD_VAR 0 16
61986: PPUSH
61987: CALL_OW 321
61991: PUSH
61992: LD_INT 2
61994: EQUAL
61995: AND
61996: IFFALSE 62161
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61998: LD_INT 22
62000: PUSH
62001: LD_VAR 0 16
62005: PUSH
62006: EMPTY
62007: LIST
62008: LIST
62009: PUSH
62010: LD_INT 2
62012: PUSH
62013: LD_INT 35
62015: PUSH
62016: LD_INT 11
62018: PUSH
62019: EMPTY
62020: LIST
62021: LIST
62022: PUSH
62023: LD_INT 35
62025: PUSH
62026: LD_INT 30
62028: PUSH
62029: EMPTY
62030: LIST
62031: LIST
62032: PUSH
62033: EMPTY
62034: LIST
62035: LIST
62036: LIST
62037: PUSH
62038: LD_INT 91
62040: PUSH
62041: LD_VAR 0 1
62045: PUSH
62046: LD_INT 18
62048: PUSH
62049: EMPTY
62050: LIST
62051: LIST
62052: LIST
62053: PUSH
62054: EMPTY
62055: LIST
62056: LIST
62057: LIST
62058: PPUSH
62059: CALL_OW 69
62063: NOT
62064: PUSH
62065: LD_INT 22
62067: PUSH
62068: LD_VAR 0 16
62072: PUSH
62073: EMPTY
62074: LIST
62075: LIST
62076: PUSH
62077: LD_INT 2
62079: PUSH
62080: LD_INT 30
62082: PUSH
62083: LD_INT 32
62085: PUSH
62086: EMPTY
62087: LIST
62088: LIST
62089: PUSH
62090: LD_INT 30
62092: PUSH
62093: LD_INT 33
62095: PUSH
62096: EMPTY
62097: LIST
62098: LIST
62099: PUSH
62100: EMPTY
62101: LIST
62102: LIST
62103: LIST
62104: PUSH
62105: LD_INT 91
62107: PUSH
62108: LD_VAR 0 1
62112: PUSH
62113: LD_INT 12
62115: PUSH
62116: EMPTY
62117: LIST
62118: LIST
62119: LIST
62120: PUSH
62121: EMPTY
62122: LIST
62123: LIST
62124: LIST
62125: PUSH
62126: EMPTY
62127: LIST
62128: PPUSH
62129: CALL_OW 69
62133: PUSH
62134: LD_INT 2
62136: GREATER
62137: AND
62138: IFFALSE 62161
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62140: LD_ADDR_VAR 0 18
62144: PUSH
62145: LD_INT 11
62147: PUSH
62148: LD_INT 30
62150: PUSH
62151: EMPTY
62152: LIST
62153: LIST
62154: PUSH
62155: LD_VAR 0 12
62159: ARRAY
62160: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62161: LD_VAR 0 18
62165: NOT
62166: PUSH
62167: LD_INT 40
62169: PPUSH
62170: LD_VAR 0 16
62174: PPUSH
62175: CALL_OW 321
62179: PUSH
62180: LD_INT 2
62182: EQUAL
62183: AND
62184: PUSH
62185: LD_INT 7
62187: PUSH
62188: LD_VAR 0 5
62192: IN
62193: PUSH
62194: LD_INT 28
62196: PUSH
62197: LD_VAR 0 5
62201: IN
62202: OR
62203: PUSH
62204: LD_INT 45
62206: PUSH
62207: LD_VAR 0 5
62211: IN
62212: OR
62213: AND
62214: IFFALSE 62468
// begin hex := GetHexInfo ( x , y ) ;
62216: LD_ADDR_VAR 0 4
62220: PUSH
62221: LD_VAR 0 10
62225: PPUSH
62226: LD_VAR 0 11
62230: PPUSH
62231: CALL_OW 546
62235: ST_TO_ADDR
// if hex [ 1 ] then
62236: LD_VAR 0 4
62240: PUSH
62241: LD_INT 1
62243: ARRAY
62244: IFFALSE 62248
// exit ;
62246: GO 62651
// height := hex [ 2 ] ;
62248: LD_ADDR_VAR 0 15
62252: PUSH
62253: LD_VAR 0 4
62257: PUSH
62258: LD_INT 2
62260: ARRAY
62261: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62262: LD_ADDR_VAR 0 14
62266: PUSH
62267: LD_INT 0
62269: PUSH
62270: LD_INT 2
62272: PUSH
62273: LD_INT 3
62275: PUSH
62276: LD_INT 5
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: LIST
62283: LIST
62284: ST_TO_ADDR
// for i in tmp do
62285: LD_ADDR_VAR 0 8
62289: PUSH
62290: LD_VAR 0 14
62294: PUSH
62295: FOR_IN
62296: IFFALSE 62466
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62298: LD_ADDR_VAR 0 9
62302: PUSH
62303: LD_VAR 0 10
62307: PPUSH
62308: LD_VAR 0 8
62312: PPUSH
62313: LD_INT 5
62315: PPUSH
62316: CALL_OW 272
62320: PUSH
62321: LD_VAR 0 11
62325: PPUSH
62326: LD_VAR 0 8
62330: PPUSH
62331: LD_INT 5
62333: PPUSH
62334: CALL_OW 273
62338: PUSH
62339: EMPTY
62340: LIST
62341: LIST
62342: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62343: LD_VAR 0 9
62347: PUSH
62348: LD_INT 1
62350: ARRAY
62351: PPUSH
62352: LD_VAR 0 9
62356: PUSH
62357: LD_INT 2
62359: ARRAY
62360: PPUSH
62361: CALL_OW 488
62365: IFFALSE 62464
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62367: LD_ADDR_VAR 0 4
62371: PUSH
62372: LD_VAR 0 9
62376: PUSH
62377: LD_INT 1
62379: ARRAY
62380: PPUSH
62381: LD_VAR 0 9
62385: PUSH
62386: LD_INT 2
62388: ARRAY
62389: PPUSH
62390: CALL_OW 546
62394: ST_TO_ADDR
// if hex [ 1 ] then
62395: LD_VAR 0 4
62399: PUSH
62400: LD_INT 1
62402: ARRAY
62403: IFFALSE 62407
// continue ;
62405: GO 62295
// h := hex [ 2 ] ;
62407: LD_ADDR_VAR 0 13
62411: PUSH
62412: LD_VAR 0 4
62416: PUSH
62417: LD_INT 2
62419: ARRAY
62420: ST_TO_ADDR
// if h + 7 < height then
62421: LD_VAR 0 13
62425: PUSH
62426: LD_INT 7
62428: PLUS
62429: PUSH
62430: LD_VAR 0 15
62434: LESS
62435: IFFALSE 62464
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62437: LD_ADDR_VAR 0 18
62441: PUSH
62442: LD_INT 7
62444: PUSH
62445: LD_INT 28
62447: PUSH
62448: LD_INT 45
62450: PUSH
62451: EMPTY
62452: LIST
62453: LIST
62454: LIST
62455: PUSH
62456: LD_VAR 0 12
62460: ARRAY
62461: ST_TO_ADDR
// break ;
62462: GO 62466
// end ; end ; end ;
62464: GO 62295
62466: POP
62467: POP
// end ; if not weapon then
62468: LD_VAR 0 18
62472: NOT
62473: IFFALSE 62533
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62475: LD_ADDR_VAR 0 5
62479: PUSH
62480: LD_VAR 0 5
62484: PUSH
62485: LD_INT 11
62487: PUSH
62488: LD_INT 30
62490: PUSH
62491: LD_INT 49
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: LIST
62498: DIFF
62499: ST_TO_ADDR
// if not list then
62500: LD_VAR 0 5
62504: NOT
62505: IFFALSE 62509
// exit ;
62507: GO 62651
// weapon := list [ rand ( 1 , list ) ] ;
62509: LD_ADDR_VAR 0 18
62513: PUSH
62514: LD_VAR 0 5
62518: PUSH
62519: LD_INT 1
62521: PPUSH
62522: LD_VAR 0 5
62526: PPUSH
62527: CALL_OW 12
62531: ARRAY
62532: ST_TO_ADDR
// end ; if weapon then
62533: LD_VAR 0 18
62537: IFFALSE 62651
// begin tmp := CostOfWeapon ( weapon ) ;
62539: LD_ADDR_VAR 0 14
62543: PUSH
62544: LD_VAR 0 18
62548: PPUSH
62549: CALL_OW 451
62553: ST_TO_ADDR
// j := GetBase ( tower ) ;
62554: LD_ADDR_VAR 0 9
62558: PUSH
62559: LD_VAR 0 1
62563: PPUSH
62564: CALL_OW 274
62568: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
62569: LD_VAR 0 9
62573: PPUSH
62574: LD_INT 1
62576: PPUSH
62577: CALL_OW 275
62581: PUSH
62582: LD_VAR 0 14
62586: PUSH
62587: LD_INT 1
62589: ARRAY
62590: GREATEREQUAL
62591: PUSH
62592: LD_VAR 0 9
62596: PPUSH
62597: LD_INT 2
62599: PPUSH
62600: CALL_OW 275
62604: PUSH
62605: LD_VAR 0 14
62609: PUSH
62610: LD_INT 2
62612: ARRAY
62613: GREATEREQUAL
62614: AND
62615: PUSH
62616: LD_VAR 0 9
62620: PPUSH
62621: LD_INT 3
62623: PPUSH
62624: CALL_OW 275
62628: PUSH
62629: LD_VAR 0 14
62633: PUSH
62634: LD_INT 3
62636: ARRAY
62637: GREATEREQUAL
62638: AND
62639: IFFALSE 62651
// result := weapon ;
62641: LD_ADDR_VAR 0 3
62645: PUSH
62646: LD_VAR 0 18
62650: ST_TO_ADDR
// end ; end ;
62651: LD_VAR 0 3
62655: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62656: LD_INT 0
62658: PPUSH
62659: PPUSH
// result := true ;
62660: LD_ADDR_VAR 0 3
62664: PUSH
62665: LD_INT 1
62667: ST_TO_ADDR
// if array1 = array2 then
62668: LD_VAR 0 1
62672: PUSH
62673: LD_VAR 0 2
62677: EQUAL
62678: IFFALSE 62738
// begin for i = 1 to array1 do
62680: LD_ADDR_VAR 0 4
62684: PUSH
62685: DOUBLE
62686: LD_INT 1
62688: DEC
62689: ST_TO_ADDR
62690: LD_VAR 0 1
62694: PUSH
62695: FOR_TO
62696: IFFALSE 62734
// if array1 [ i ] <> array2 [ i ] then
62698: LD_VAR 0 1
62702: PUSH
62703: LD_VAR 0 4
62707: ARRAY
62708: PUSH
62709: LD_VAR 0 2
62713: PUSH
62714: LD_VAR 0 4
62718: ARRAY
62719: NONEQUAL
62720: IFFALSE 62732
// begin result := false ;
62722: LD_ADDR_VAR 0 3
62726: PUSH
62727: LD_INT 0
62729: ST_TO_ADDR
// break ;
62730: GO 62734
// end ;
62732: GO 62695
62734: POP
62735: POP
// end else
62736: GO 62746
// result := false ;
62738: LD_ADDR_VAR 0 3
62742: PUSH
62743: LD_INT 0
62745: ST_TO_ADDR
// end ;
62746: LD_VAR 0 3
62750: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
62751: LD_INT 0
62753: PPUSH
62754: PPUSH
// if not array1 or not array2 then
62755: LD_VAR 0 1
62759: NOT
62760: PUSH
62761: LD_VAR 0 2
62765: NOT
62766: OR
62767: IFFALSE 62771
// exit ;
62769: GO 62835
// result := true ;
62771: LD_ADDR_VAR 0 3
62775: PUSH
62776: LD_INT 1
62778: ST_TO_ADDR
// for i = 1 to array1 do
62779: LD_ADDR_VAR 0 4
62783: PUSH
62784: DOUBLE
62785: LD_INT 1
62787: DEC
62788: ST_TO_ADDR
62789: LD_VAR 0 1
62793: PUSH
62794: FOR_TO
62795: IFFALSE 62833
// if array1 [ i ] <> array2 [ i ] then
62797: LD_VAR 0 1
62801: PUSH
62802: LD_VAR 0 4
62806: ARRAY
62807: PUSH
62808: LD_VAR 0 2
62812: PUSH
62813: LD_VAR 0 4
62817: ARRAY
62818: NONEQUAL
62819: IFFALSE 62831
// begin result := false ;
62821: LD_ADDR_VAR 0 3
62825: PUSH
62826: LD_INT 0
62828: ST_TO_ADDR
// break ;
62829: GO 62833
// end ;
62831: GO 62794
62833: POP
62834: POP
// end ;
62835: LD_VAR 0 3
62839: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62840: LD_INT 0
62842: PPUSH
62843: PPUSH
62844: PPUSH
// pom := GetBase ( fac ) ;
62845: LD_ADDR_VAR 0 5
62849: PUSH
62850: LD_VAR 0 1
62854: PPUSH
62855: CALL_OW 274
62859: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62860: LD_ADDR_VAR 0 4
62864: PUSH
62865: LD_VAR 0 2
62869: PUSH
62870: LD_INT 1
62872: ARRAY
62873: PPUSH
62874: LD_VAR 0 2
62878: PUSH
62879: LD_INT 2
62881: ARRAY
62882: PPUSH
62883: LD_VAR 0 2
62887: PUSH
62888: LD_INT 3
62890: ARRAY
62891: PPUSH
62892: LD_VAR 0 2
62896: PUSH
62897: LD_INT 4
62899: ARRAY
62900: PPUSH
62901: CALL_OW 449
62905: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62906: LD_ADDR_VAR 0 3
62910: PUSH
62911: LD_VAR 0 5
62915: PPUSH
62916: LD_INT 1
62918: PPUSH
62919: CALL_OW 275
62923: PUSH
62924: LD_VAR 0 4
62928: PUSH
62929: LD_INT 1
62931: ARRAY
62932: GREATEREQUAL
62933: PUSH
62934: LD_VAR 0 5
62938: PPUSH
62939: LD_INT 2
62941: PPUSH
62942: CALL_OW 275
62946: PUSH
62947: LD_VAR 0 4
62951: PUSH
62952: LD_INT 2
62954: ARRAY
62955: GREATEREQUAL
62956: AND
62957: PUSH
62958: LD_VAR 0 5
62962: PPUSH
62963: LD_INT 3
62965: PPUSH
62966: CALL_OW 275
62970: PUSH
62971: LD_VAR 0 4
62975: PUSH
62976: LD_INT 3
62978: ARRAY
62979: GREATEREQUAL
62980: AND
62981: ST_TO_ADDR
// end ;
62982: LD_VAR 0 3
62986: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62987: LD_INT 0
62989: PPUSH
62990: PPUSH
62991: PPUSH
62992: PPUSH
// pom := GetBase ( building ) ;
62993: LD_ADDR_VAR 0 3
62997: PUSH
62998: LD_VAR 0 1
63002: PPUSH
63003: CALL_OW 274
63007: ST_TO_ADDR
// if not pom then
63008: LD_VAR 0 3
63012: NOT
63013: IFFALSE 63017
// exit ;
63015: GO 63187
// btype := GetBType ( building ) ;
63017: LD_ADDR_VAR 0 5
63021: PUSH
63022: LD_VAR 0 1
63026: PPUSH
63027: CALL_OW 266
63031: ST_TO_ADDR
// if btype = b_armoury then
63032: LD_VAR 0 5
63036: PUSH
63037: LD_INT 4
63039: EQUAL
63040: IFFALSE 63050
// btype := b_barracks ;
63042: LD_ADDR_VAR 0 5
63046: PUSH
63047: LD_INT 5
63049: ST_TO_ADDR
// if btype = b_depot then
63050: LD_VAR 0 5
63054: PUSH
63055: LD_INT 0
63057: EQUAL
63058: IFFALSE 63068
// btype := b_warehouse ;
63060: LD_ADDR_VAR 0 5
63064: PUSH
63065: LD_INT 1
63067: ST_TO_ADDR
// if btype = b_workshop then
63068: LD_VAR 0 5
63072: PUSH
63073: LD_INT 2
63075: EQUAL
63076: IFFALSE 63086
// btype := b_factory ;
63078: LD_ADDR_VAR 0 5
63082: PUSH
63083: LD_INT 3
63085: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63086: LD_ADDR_VAR 0 4
63090: PUSH
63091: LD_VAR 0 5
63095: PPUSH
63096: LD_VAR 0 1
63100: PPUSH
63101: CALL_OW 248
63105: PPUSH
63106: CALL_OW 450
63110: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63111: LD_ADDR_VAR 0 2
63115: PUSH
63116: LD_VAR 0 3
63120: PPUSH
63121: LD_INT 1
63123: PPUSH
63124: CALL_OW 275
63128: PUSH
63129: LD_VAR 0 4
63133: PUSH
63134: LD_INT 1
63136: ARRAY
63137: GREATEREQUAL
63138: PUSH
63139: LD_VAR 0 3
63143: PPUSH
63144: LD_INT 2
63146: PPUSH
63147: CALL_OW 275
63151: PUSH
63152: LD_VAR 0 4
63156: PUSH
63157: LD_INT 2
63159: ARRAY
63160: GREATEREQUAL
63161: AND
63162: PUSH
63163: LD_VAR 0 3
63167: PPUSH
63168: LD_INT 3
63170: PPUSH
63171: CALL_OW 275
63175: PUSH
63176: LD_VAR 0 4
63180: PUSH
63181: LD_INT 3
63183: ARRAY
63184: GREATEREQUAL
63185: AND
63186: ST_TO_ADDR
// end ;
63187: LD_VAR 0 2
63191: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63192: LD_INT 0
63194: PPUSH
63195: PPUSH
63196: PPUSH
// pom := GetBase ( building ) ;
63197: LD_ADDR_VAR 0 4
63201: PUSH
63202: LD_VAR 0 1
63206: PPUSH
63207: CALL_OW 274
63211: ST_TO_ADDR
// if not pom then
63212: LD_VAR 0 4
63216: NOT
63217: IFFALSE 63221
// exit ;
63219: GO 63322
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63221: LD_ADDR_VAR 0 5
63225: PUSH
63226: LD_VAR 0 2
63230: PPUSH
63231: LD_VAR 0 1
63235: PPUSH
63236: CALL_OW 248
63240: PPUSH
63241: CALL_OW 450
63245: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63246: LD_ADDR_VAR 0 3
63250: PUSH
63251: LD_VAR 0 4
63255: PPUSH
63256: LD_INT 1
63258: PPUSH
63259: CALL_OW 275
63263: PUSH
63264: LD_VAR 0 5
63268: PUSH
63269: LD_INT 1
63271: ARRAY
63272: GREATEREQUAL
63273: PUSH
63274: LD_VAR 0 4
63278: PPUSH
63279: LD_INT 2
63281: PPUSH
63282: CALL_OW 275
63286: PUSH
63287: LD_VAR 0 5
63291: PUSH
63292: LD_INT 2
63294: ARRAY
63295: GREATEREQUAL
63296: AND
63297: PUSH
63298: LD_VAR 0 4
63302: PPUSH
63303: LD_INT 3
63305: PPUSH
63306: CALL_OW 275
63310: PUSH
63311: LD_VAR 0 5
63315: PUSH
63316: LD_INT 3
63318: ARRAY
63319: GREATEREQUAL
63320: AND
63321: ST_TO_ADDR
// end ;
63322: LD_VAR 0 3
63326: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63327: LD_INT 0
63329: PPUSH
63330: PPUSH
63331: PPUSH
63332: PPUSH
63333: PPUSH
63334: PPUSH
63335: PPUSH
63336: PPUSH
63337: PPUSH
63338: PPUSH
63339: PPUSH
// result := false ;
63340: LD_ADDR_VAR 0 8
63344: PUSH
63345: LD_INT 0
63347: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63348: LD_VAR 0 5
63352: NOT
63353: PUSH
63354: LD_VAR 0 1
63358: NOT
63359: OR
63360: PUSH
63361: LD_VAR 0 2
63365: NOT
63366: OR
63367: PUSH
63368: LD_VAR 0 3
63372: NOT
63373: OR
63374: IFFALSE 63378
// exit ;
63376: GO 64192
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63378: LD_ADDR_VAR 0 14
63382: PUSH
63383: LD_VAR 0 1
63387: PPUSH
63388: LD_VAR 0 2
63392: PPUSH
63393: LD_VAR 0 3
63397: PPUSH
63398: LD_VAR 0 4
63402: PPUSH
63403: LD_VAR 0 5
63407: PUSH
63408: LD_INT 1
63410: ARRAY
63411: PPUSH
63412: CALL_OW 248
63416: PPUSH
63417: LD_INT 0
63419: PPUSH
63420: CALL 65429 0 6
63424: ST_TO_ADDR
// if not hexes then
63425: LD_VAR 0 14
63429: NOT
63430: IFFALSE 63434
// exit ;
63432: GO 64192
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63434: LD_ADDR_VAR 0 17
63438: PUSH
63439: LD_VAR 0 5
63443: PPUSH
63444: LD_INT 22
63446: PUSH
63447: LD_VAR 0 13
63451: PPUSH
63452: CALL_OW 255
63456: PUSH
63457: EMPTY
63458: LIST
63459: LIST
63460: PUSH
63461: LD_INT 2
63463: PUSH
63464: LD_INT 30
63466: PUSH
63467: LD_INT 0
63469: PUSH
63470: EMPTY
63471: LIST
63472: LIST
63473: PUSH
63474: LD_INT 30
63476: PUSH
63477: LD_INT 1
63479: PUSH
63480: EMPTY
63481: LIST
63482: LIST
63483: PUSH
63484: EMPTY
63485: LIST
63486: LIST
63487: LIST
63488: PUSH
63489: EMPTY
63490: LIST
63491: LIST
63492: PPUSH
63493: CALL_OW 72
63497: ST_TO_ADDR
// for i = 1 to hexes do
63498: LD_ADDR_VAR 0 9
63502: PUSH
63503: DOUBLE
63504: LD_INT 1
63506: DEC
63507: ST_TO_ADDR
63508: LD_VAR 0 14
63512: PUSH
63513: FOR_TO
63514: IFFALSE 64190
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63516: LD_ADDR_VAR 0 13
63520: PUSH
63521: LD_VAR 0 14
63525: PUSH
63526: LD_VAR 0 9
63530: ARRAY
63531: PUSH
63532: LD_INT 1
63534: ARRAY
63535: PPUSH
63536: LD_VAR 0 14
63540: PUSH
63541: LD_VAR 0 9
63545: ARRAY
63546: PUSH
63547: LD_INT 2
63549: ARRAY
63550: PPUSH
63551: CALL_OW 428
63555: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63556: LD_VAR 0 14
63560: PUSH
63561: LD_VAR 0 9
63565: ARRAY
63566: PUSH
63567: LD_INT 1
63569: ARRAY
63570: PPUSH
63571: LD_VAR 0 14
63575: PUSH
63576: LD_VAR 0 9
63580: ARRAY
63581: PUSH
63582: LD_INT 2
63584: ARRAY
63585: PPUSH
63586: CALL_OW 351
63590: PUSH
63591: LD_VAR 0 14
63595: PUSH
63596: LD_VAR 0 9
63600: ARRAY
63601: PUSH
63602: LD_INT 1
63604: ARRAY
63605: PPUSH
63606: LD_VAR 0 14
63610: PUSH
63611: LD_VAR 0 9
63615: ARRAY
63616: PUSH
63617: LD_INT 2
63619: ARRAY
63620: PPUSH
63621: CALL_OW 488
63625: NOT
63626: OR
63627: PUSH
63628: LD_VAR 0 13
63632: PPUSH
63633: CALL_OW 247
63637: PUSH
63638: LD_INT 3
63640: EQUAL
63641: OR
63642: IFFALSE 63648
// exit ;
63644: POP
63645: POP
63646: GO 64192
// if not tmp then
63648: LD_VAR 0 13
63652: NOT
63653: IFFALSE 63657
// continue ;
63655: GO 63513
// result := true ;
63657: LD_ADDR_VAR 0 8
63661: PUSH
63662: LD_INT 1
63664: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
63665: LD_VAR 0 6
63669: PUSH
63670: LD_VAR 0 13
63674: PPUSH
63675: CALL_OW 247
63679: PUSH
63680: LD_INT 2
63682: EQUAL
63683: AND
63684: PUSH
63685: LD_VAR 0 13
63689: PPUSH
63690: CALL_OW 263
63694: PUSH
63695: LD_INT 1
63697: EQUAL
63698: AND
63699: IFFALSE 63863
// begin if IsDrivenBy ( tmp ) then
63701: LD_VAR 0 13
63705: PPUSH
63706: CALL_OW 311
63710: IFFALSE 63714
// continue ;
63712: GO 63513
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
63714: LD_VAR 0 6
63718: PPUSH
63719: LD_INT 3
63721: PUSH
63722: LD_INT 60
63724: PUSH
63725: EMPTY
63726: LIST
63727: PUSH
63728: EMPTY
63729: LIST
63730: LIST
63731: PUSH
63732: LD_INT 3
63734: PUSH
63735: LD_INT 55
63737: PUSH
63738: EMPTY
63739: LIST
63740: PUSH
63741: EMPTY
63742: LIST
63743: LIST
63744: PUSH
63745: EMPTY
63746: LIST
63747: LIST
63748: PPUSH
63749: CALL_OW 72
63753: IFFALSE 63861
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
63755: LD_ADDR_VAR 0 18
63759: PUSH
63760: LD_VAR 0 6
63764: PPUSH
63765: LD_INT 3
63767: PUSH
63768: LD_INT 60
63770: PUSH
63771: EMPTY
63772: LIST
63773: PUSH
63774: EMPTY
63775: LIST
63776: LIST
63777: PUSH
63778: LD_INT 3
63780: PUSH
63781: LD_INT 55
63783: PUSH
63784: EMPTY
63785: LIST
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: PPUSH
63795: CALL_OW 72
63799: PUSH
63800: LD_INT 1
63802: ARRAY
63803: ST_TO_ADDR
// if IsInUnit ( driver ) then
63804: LD_VAR 0 18
63808: PPUSH
63809: CALL_OW 310
63813: IFFALSE 63824
// ComExit ( driver ) ;
63815: LD_VAR 0 18
63819: PPUSH
63820: CALL 88613 0 1
// AddComEnterUnit ( driver , tmp ) ;
63824: LD_VAR 0 18
63828: PPUSH
63829: LD_VAR 0 13
63833: PPUSH
63834: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
63838: LD_VAR 0 18
63842: PPUSH
63843: LD_VAR 0 7
63847: PPUSH
63848: CALL_OW 173
// AddComExitVehicle ( driver ) ;
63852: LD_VAR 0 18
63856: PPUSH
63857: CALL_OW 181
// end ; continue ;
63861: GO 63513
// end ; if not cleaners or not tmp in cleaners then
63863: LD_VAR 0 6
63867: NOT
63868: PUSH
63869: LD_VAR 0 13
63873: PUSH
63874: LD_VAR 0 6
63878: IN
63879: NOT
63880: OR
63881: IFFALSE 64188
// begin if dep then
63883: LD_VAR 0 17
63887: IFFALSE 64023
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63889: LD_ADDR_VAR 0 16
63893: PUSH
63894: LD_VAR 0 17
63898: PUSH
63899: LD_INT 1
63901: ARRAY
63902: PPUSH
63903: CALL_OW 250
63907: PPUSH
63908: LD_VAR 0 17
63912: PUSH
63913: LD_INT 1
63915: ARRAY
63916: PPUSH
63917: CALL_OW 254
63921: PPUSH
63922: LD_INT 5
63924: PPUSH
63925: CALL_OW 272
63929: PUSH
63930: LD_VAR 0 17
63934: PUSH
63935: LD_INT 1
63937: ARRAY
63938: PPUSH
63939: CALL_OW 251
63943: PPUSH
63944: LD_VAR 0 17
63948: PUSH
63949: LD_INT 1
63951: ARRAY
63952: PPUSH
63953: CALL_OW 254
63957: PPUSH
63958: LD_INT 5
63960: PPUSH
63961: CALL_OW 273
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63970: LD_VAR 0 16
63974: PUSH
63975: LD_INT 1
63977: ARRAY
63978: PPUSH
63979: LD_VAR 0 16
63983: PUSH
63984: LD_INT 2
63986: ARRAY
63987: PPUSH
63988: CALL_OW 488
63992: IFFALSE 64023
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63994: LD_VAR 0 13
63998: PPUSH
63999: LD_VAR 0 16
64003: PUSH
64004: LD_INT 1
64006: ARRAY
64007: PPUSH
64008: LD_VAR 0 16
64012: PUSH
64013: LD_INT 2
64015: ARRAY
64016: PPUSH
64017: CALL_OW 111
// continue ;
64021: GO 63513
// end ; end ; r := GetDir ( tmp ) ;
64023: LD_ADDR_VAR 0 15
64027: PUSH
64028: LD_VAR 0 13
64032: PPUSH
64033: CALL_OW 254
64037: ST_TO_ADDR
// if r = 5 then
64038: LD_VAR 0 15
64042: PUSH
64043: LD_INT 5
64045: EQUAL
64046: IFFALSE 64056
// r := 0 ;
64048: LD_ADDR_VAR 0 15
64052: PUSH
64053: LD_INT 0
64055: ST_TO_ADDR
// for j = r to 5 do
64056: LD_ADDR_VAR 0 10
64060: PUSH
64061: DOUBLE
64062: LD_VAR 0 15
64066: DEC
64067: ST_TO_ADDR
64068: LD_INT 5
64070: PUSH
64071: FOR_TO
64072: IFFALSE 64186
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64074: LD_ADDR_VAR 0 11
64078: PUSH
64079: LD_VAR 0 13
64083: PPUSH
64084: CALL_OW 250
64088: PPUSH
64089: LD_VAR 0 10
64093: PPUSH
64094: LD_INT 2
64096: PPUSH
64097: CALL_OW 272
64101: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64102: LD_ADDR_VAR 0 12
64106: PUSH
64107: LD_VAR 0 13
64111: PPUSH
64112: CALL_OW 251
64116: PPUSH
64117: LD_VAR 0 10
64121: PPUSH
64122: LD_INT 2
64124: PPUSH
64125: CALL_OW 273
64129: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64130: LD_VAR 0 11
64134: PPUSH
64135: LD_VAR 0 12
64139: PPUSH
64140: CALL_OW 488
64144: PUSH
64145: LD_VAR 0 11
64149: PPUSH
64150: LD_VAR 0 12
64154: PPUSH
64155: CALL_OW 428
64159: NOT
64160: AND
64161: IFFALSE 64184
// begin ComMoveXY ( tmp , _x , _y ) ;
64163: LD_VAR 0 13
64167: PPUSH
64168: LD_VAR 0 11
64172: PPUSH
64173: LD_VAR 0 12
64177: PPUSH
64178: CALL_OW 111
// break ;
64182: GO 64186
// end ; end ;
64184: GO 64071
64186: POP
64187: POP
// end ; end ;
64188: GO 63513
64190: POP
64191: POP
// end ;
64192: LD_VAR 0 8
64196: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64197: LD_INT 0
64199: PPUSH
// result := true ;
64200: LD_ADDR_VAR 0 3
64204: PUSH
64205: LD_INT 1
64207: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64208: LD_VAR 0 2
64212: PUSH
64213: LD_INT 24
64215: DOUBLE
64216: EQUAL
64217: IFTRUE 64227
64219: LD_INT 33
64221: DOUBLE
64222: EQUAL
64223: IFTRUE 64227
64225: GO 64252
64227: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64228: LD_ADDR_VAR 0 3
64232: PUSH
64233: LD_INT 32
64235: PPUSH
64236: LD_VAR 0 1
64240: PPUSH
64241: CALL_OW 321
64245: PUSH
64246: LD_INT 2
64248: EQUAL
64249: ST_TO_ADDR
64250: GO 64572
64252: LD_INT 20
64254: DOUBLE
64255: EQUAL
64256: IFTRUE 64260
64258: GO 64285
64260: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64261: LD_ADDR_VAR 0 3
64265: PUSH
64266: LD_INT 6
64268: PPUSH
64269: LD_VAR 0 1
64273: PPUSH
64274: CALL_OW 321
64278: PUSH
64279: LD_INT 2
64281: EQUAL
64282: ST_TO_ADDR
64283: GO 64572
64285: LD_INT 22
64287: DOUBLE
64288: EQUAL
64289: IFTRUE 64299
64291: LD_INT 36
64293: DOUBLE
64294: EQUAL
64295: IFTRUE 64299
64297: GO 64324
64299: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64300: LD_ADDR_VAR 0 3
64304: PUSH
64305: LD_INT 15
64307: PPUSH
64308: LD_VAR 0 1
64312: PPUSH
64313: CALL_OW 321
64317: PUSH
64318: LD_INT 2
64320: EQUAL
64321: ST_TO_ADDR
64322: GO 64572
64324: LD_INT 30
64326: DOUBLE
64327: EQUAL
64328: IFTRUE 64332
64330: GO 64357
64332: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64333: LD_ADDR_VAR 0 3
64337: PUSH
64338: LD_INT 20
64340: PPUSH
64341: LD_VAR 0 1
64345: PPUSH
64346: CALL_OW 321
64350: PUSH
64351: LD_INT 2
64353: EQUAL
64354: ST_TO_ADDR
64355: GO 64572
64357: LD_INT 28
64359: DOUBLE
64360: EQUAL
64361: IFTRUE 64371
64363: LD_INT 21
64365: DOUBLE
64366: EQUAL
64367: IFTRUE 64371
64369: GO 64396
64371: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64372: LD_ADDR_VAR 0 3
64376: PUSH
64377: LD_INT 21
64379: PPUSH
64380: LD_VAR 0 1
64384: PPUSH
64385: CALL_OW 321
64389: PUSH
64390: LD_INT 2
64392: EQUAL
64393: ST_TO_ADDR
64394: GO 64572
64396: LD_INT 16
64398: DOUBLE
64399: EQUAL
64400: IFTRUE 64404
64402: GO 64431
64404: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64405: LD_ADDR_VAR 0 3
64409: PUSH
64410: LD_EXP 84
64414: PPUSH
64415: LD_VAR 0 1
64419: PPUSH
64420: CALL_OW 321
64424: PUSH
64425: LD_INT 2
64427: EQUAL
64428: ST_TO_ADDR
64429: GO 64572
64431: LD_INT 19
64433: DOUBLE
64434: EQUAL
64435: IFTRUE 64445
64437: LD_INT 23
64439: DOUBLE
64440: EQUAL
64441: IFTRUE 64445
64443: GO 64472
64445: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64446: LD_ADDR_VAR 0 3
64450: PUSH
64451: LD_EXP 83
64455: PPUSH
64456: LD_VAR 0 1
64460: PPUSH
64461: CALL_OW 321
64465: PUSH
64466: LD_INT 2
64468: EQUAL
64469: ST_TO_ADDR
64470: GO 64572
64472: LD_INT 17
64474: DOUBLE
64475: EQUAL
64476: IFTRUE 64480
64478: GO 64505
64480: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
64481: LD_ADDR_VAR 0 3
64485: PUSH
64486: LD_INT 39
64488: PPUSH
64489: LD_VAR 0 1
64493: PPUSH
64494: CALL_OW 321
64498: PUSH
64499: LD_INT 2
64501: EQUAL
64502: ST_TO_ADDR
64503: GO 64572
64505: LD_INT 18
64507: DOUBLE
64508: EQUAL
64509: IFTRUE 64513
64511: GO 64538
64513: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
64514: LD_ADDR_VAR 0 3
64518: PUSH
64519: LD_INT 40
64521: PPUSH
64522: LD_VAR 0 1
64526: PPUSH
64527: CALL_OW 321
64531: PUSH
64532: LD_INT 2
64534: EQUAL
64535: ST_TO_ADDR
64536: GO 64572
64538: LD_INT 27
64540: DOUBLE
64541: EQUAL
64542: IFTRUE 64546
64544: GO 64571
64546: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
64547: LD_ADDR_VAR 0 3
64551: PUSH
64552: LD_INT 35
64554: PPUSH
64555: LD_VAR 0 1
64559: PPUSH
64560: CALL_OW 321
64564: PUSH
64565: LD_INT 2
64567: EQUAL
64568: ST_TO_ADDR
64569: GO 64572
64571: POP
// end ;
64572: LD_VAR 0 3
64576: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
64577: LD_INT 0
64579: PPUSH
64580: PPUSH
64581: PPUSH
64582: PPUSH
64583: PPUSH
64584: PPUSH
64585: PPUSH
64586: PPUSH
64587: PPUSH
64588: PPUSH
64589: PPUSH
// result := false ;
64590: LD_ADDR_VAR 0 6
64594: PUSH
64595: LD_INT 0
64597: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64598: LD_VAR 0 1
64602: NOT
64603: PUSH
64604: LD_VAR 0 1
64608: PPUSH
64609: CALL_OW 266
64613: PUSH
64614: LD_INT 0
64616: PUSH
64617: LD_INT 1
64619: PUSH
64620: EMPTY
64621: LIST
64622: LIST
64623: IN
64624: NOT
64625: OR
64626: PUSH
64627: LD_VAR 0 2
64631: NOT
64632: OR
64633: PUSH
64634: LD_VAR 0 5
64638: PUSH
64639: LD_INT 0
64641: PUSH
64642: LD_INT 1
64644: PUSH
64645: LD_INT 2
64647: PUSH
64648: LD_INT 3
64650: PUSH
64651: LD_INT 4
64653: PUSH
64654: LD_INT 5
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: LIST
64661: LIST
64662: LIST
64663: LIST
64664: IN
64665: NOT
64666: OR
64667: PUSH
64668: LD_VAR 0 3
64672: PPUSH
64673: LD_VAR 0 4
64677: PPUSH
64678: CALL_OW 488
64682: NOT
64683: OR
64684: IFFALSE 64688
// exit ;
64686: GO 65424
// side := GetSide ( depot ) ;
64688: LD_ADDR_VAR 0 9
64692: PUSH
64693: LD_VAR 0 1
64697: PPUSH
64698: CALL_OW 255
64702: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
64703: LD_VAR 0 9
64707: PPUSH
64708: LD_VAR 0 2
64712: PPUSH
64713: CALL 64197 0 2
64717: NOT
64718: IFFALSE 64722
// exit ;
64720: GO 65424
// pom := GetBase ( depot ) ;
64722: LD_ADDR_VAR 0 10
64726: PUSH
64727: LD_VAR 0 1
64731: PPUSH
64732: CALL_OW 274
64736: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64737: LD_ADDR_VAR 0 11
64741: PUSH
64742: LD_VAR 0 2
64746: PPUSH
64747: LD_VAR 0 1
64751: PPUSH
64752: CALL_OW 248
64756: PPUSH
64757: CALL_OW 450
64761: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64762: LD_VAR 0 10
64766: PPUSH
64767: LD_INT 1
64769: PPUSH
64770: CALL_OW 275
64774: PUSH
64775: LD_VAR 0 11
64779: PUSH
64780: LD_INT 1
64782: ARRAY
64783: GREATEREQUAL
64784: PUSH
64785: LD_VAR 0 10
64789: PPUSH
64790: LD_INT 2
64792: PPUSH
64793: CALL_OW 275
64797: PUSH
64798: LD_VAR 0 11
64802: PUSH
64803: LD_INT 2
64805: ARRAY
64806: GREATEREQUAL
64807: AND
64808: PUSH
64809: LD_VAR 0 10
64813: PPUSH
64814: LD_INT 3
64816: PPUSH
64817: CALL_OW 275
64821: PUSH
64822: LD_VAR 0 11
64826: PUSH
64827: LD_INT 3
64829: ARRAY
64830: GREATEREQUAL
64831: AND
64832: NOT
64833: IFFALSE 64837
// exit ;
64835: GO 65424
// if GetBType ( depot ) = b_depot then
64837: LD_VAR 0 1
64841: PPUSH
64842: CALL_OW 266
64846: PUSH
64847: LD_INT 0
64849: EQUAL
64850: IFFALSE 64862
// dist := 28 else
64852: LD_ADDR_VAR 0 14
64856: PUSH
64857: LD_INT 28
64859: ST_TO_ADDR
64860: GO 64870
// dist := 36 ;
64862: LD_ADDR_VAR 0 14
64866: PUSH
64867: LD_INT 36
64869: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
64870: LD_VAR 0 1
64874: PPUSH
64875: LD_VAR 0 3
64879: PPUSH
64880: LD_VAR 0 4
64884: PPUSH
64885: CALL_OW 297
64889: PUSH
64890: LD_VAR 0 14
64894: GREATER
64895: IFFALSE 64899
// exit ;
64897: GO 65424
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
64899: LD_ADDR_VAR 0 12
64903: PUSH
64904: LD_VAR 0 2
64908: PPUSH
64909: LD_VAR 0 3
64913: PPUSH
64914: LD_VAR 0 4
64918: PPUSH
64919: LD_VAR 0 5
64923: PPUSH
64924: LD_VAR 0 1
64928: PPUSH
64929: CALL_OW 248
64933: PPUSH
64934: LD_INT 0
64936: PPUSH
64937: CALL 65429 0 6
64941: ST_TO_ADDR
// if not hexes then
64942: LD_VAR 0 12
64946: NOT
64947: IFFALSE 64951
// exit ;
64949: GO 65424
// hex := GetHexInfo ( x , y ) ;
64951: LD_ADDR_VAR 0 15
64955: PUSH
64956: LD_VAR 0 3
64960: PPUSH
64961: LD_VAR 0 4
64965: PPUSH
64966: CALL_OW 546
64970: ST_TO_ADDR
// if hex [ 1 ] then
64971: LD_VAR 0 15
64975: PUSH
64976: LD_INT 1
64978: ARRAY
64979: IFFALSE 64983
// exit ;
64981: GO 65424
// height := hex [ 2 ] ;
64983: LD_ADDR_VAR 0 13
64987: PUSH
64988: LD_VAR 0 15
64992: PUSH
64993: LD_INT 2
64995: ARRAY
64996: ST_TO_ADDR
// for i = 1 to hexes do
64997: LD_ADDR_VAR 0 7
65001: PUSH
65002: DOUBLE
65003: LD_INT 1
65005: DEC
65006: ST_TO_ADDR
65007: LD_VAR 0 12
65011: PUSH
65012: FOR_TO
65013: IFFALSE 65343
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65015: LD_VAR 0 12
65019: PUSH
65020: LD_VAR 0 7
65024: ARRAY
65025: PUSH
65026: LD_INT 1
65028: ARRAY
65029: PPUSH
65030: LD_VAR 0 12
65034: PUSH
65035: LD_VAR 0 7
65039: ARRAY
65040: PUSH
65041: LD_INT 2
65043: ARRAY
65044: PPUSH
65045: CALL_OW 488
65049: NOT
65050: PUSH
65051: LD_VAR 0 12
65055: PUSH
65056: LD_VAR 0 7
65060: ARRAY
65061: PUSH
65062: LD_INT 1
65064: ARRAY
65065: PPUSH
65066: LD_VAR 0 12
65070: PUSH
65071: LD_VAR 0 7
65075: ARRAY
65076: PUSH
65077: LD_INT 2
65079: ARRAY
65080: PPUSH
65081: CALL_OW 428
65085: PUSH
65086: LD_INT 0
65088: GREATER
65089: OR
65090: PUSH
65091: LD_VAR 0 12
65095: PUSH
65096: LD_VAR 0 7
65100: ARRAY
65101: PUSH
65102: LD_INT 1
65104: ARRAY
65105: PPUSH
65106: LD_VAR 0 12
65110: PUSH
65111: LD_VAR 0 7
65115: ARRAY
65116: PUSH
65117: LD_INT 2
65119: ARRAY
65120: PPUSH
65121: CALL_OW 351
65125: OR
65126: IFFALSE 65132
// exit ;
65128: POP
65129: POP
65130: GO 65424
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65132: LD_ADDR_VAR 0 8
65136: PUSH
65137: LD_VAR 0 12
65141: PUSH
65142: LD_VAR 0 7
65146: ARRAY
65147: PUSH
65148: LD_INT 1
65150: ARRAY
65151: PPUSH
65152: LD_VAR 0 12
65156: PUSH
65157: LD_VAR 0 7
65161: ARRAY
65162: PUSH
65163: LD_INT 2
65165: ARRAY
65166: PPUSH
65167: CALL_OW 546
65171: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65172: LD_VAR 0 8
65176: PUSH
65177: LD_INT 1
65179: ARRAY
65180: PUSH
65181: LD_VAR 0 8
65185: PUSH
65186: LD_INT 2
65188: ARRAY
65189: PUSH
65190: LD_VAR 0 13
65194: PUSH
65195: LD_INT 2
65197: PLUS
65198: GREATER
65199: OR
65200: PUSH
65201: LD_VAR 0 8
65205: PUSH
65206: LD_INT 2
65208: ARRAY
65209: PUSH
65210: LD_VAR 0 13
65214: PUSH
65215: LD_INT 2
65217: MINUS
65218: LESS
65219: OR
65220: PUSH
65221: LD_VAR 0 8
65225: PUSH
65226: LD_INT 3
65228: ARRAY
65229: PUSH
65230: LD_INT 0
65232: PUSH
65233: LD_INT 8
65235: PUSH
65236: LD_INT 9
65238: PUSH
65239: LD_INT 10
65241: PUSH
65242: LD_INT 11
65244: PUSH
65245: LD_INT 12
65247: PUSH
65248: LD_INT 13
65250: PUSH
65251: LD_INT 16
65253: PUSH
65254: LD_INT 17
65256: PUSH
65257: LD_INT 18
65259: PUSH
65260: LD_INT 19
65262: PUSH
65263: LD_INT 20
65265: PUSH
65266: LD_INT 21
65268: PUSH
65269: EMPTY
65270: LIST
65271: LIST
65272: LIST
65273: LIST
65274: LIST
65275: LIST
65276: LIST
65277: LIST
65278: LIST
65279: LIST
65280: LIST
65281: LIST
65282: LIST
65283: IN
65284: NOT
65285: OR
65286: PUSH
65287: LD_VAR 0 8
65291: PUSH
65292: LD_INT 5
65294: ARRAY
65295: NOT
65296: OR
65297: PUSH
65298: LD_VAR 0 8
65302: PUSH
65303: LD_INT 6
65305: ARRAY
65306: PUSH
65307: LD_INT 1
65309: PUSH
65310: LD_INT 2
65312: PUSH
65313: LD_INT 7
65315: PUSH
65316: LD_INT 9
65318: PUSH
65319: LD_INT 10
65321: PUSH
65322: LD_INT 11
65324: PUSH
65325: EMPTY
65326: LIST
65327: LIST
65328: LIST
65329: LIST
65330: LIST
65331: LIST
65332: IN
65333: NOT
65334: OR
65335: IFFALSE 65341
// exit ;
65337: POP
65338: POP
65339: GO 65424
// end ;
65341: GO 65012
65343: POP
65344: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65345: LD_VAR 0 9
65349: PPUSH
65350: LD_VAR 0 3
65354: PPUSH
65355: LD_VAR 0 4
65359: PPUSH
65360: LD_INT 20
65362: PPUSH
65363: CALL 57370 0 4
65367: PUSH
65368: LD_INT 4
65370: ARRAY
65371: IFFALSE 65375
// exit ;
65373: GO 65424
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65375: LD_VAR 0 2
65379: PUSH
65380: LD_INT 29
65382: PUSH
65383: LD_INT 30
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: IN
65390: PUSH
65391: LD_VAR 0 3
65395: PPUSH
65396: LD_VAR 0 4
65400: PPUSH
65401: LD_VAR 0 9
65405: PPUSH
65406: CALL_OW 440
65410: NOT
65411: AND
65412: IFFALSE 65416
// exit ;
65414: GO 65424
// result := true ;
65416: LD_ADDR_VAR 0 6
65420: PUSH
65421: LD_INT 1
65423: ST_TO_ADDR
// end ;
65424: LD_VAR 0 6
65428: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65429: LD_INT 0
65431: PPUSH
65432: PPUSH
65433: PPUSH
65434: PPUSH
65435: PPUSH
65436: PPUSH
65437: PPUSH
65438: PPUSH
65439: PPUSH
65440: PPUSH
65441: PPUSH
65442: PPUSH
65443: PPUSH
65444: PPUSH
65445: PPUSH
65446: PPUSH
65447: PPUSH
65448: PPUSH
65449: PPUSH
65450: PPUSH
65451: PPUSH
65452: PPUSH
65453: PPUSH
65454: PPUSH
65455: PPUSH
65456: PPUSH
65457: PPUSH
65458: PPUSH
65459: PPUSH
65460: PPUSH
65461: PPUSH
65462: PPUSH
65463: PPUSH
65464: PPUSH
65465: PPUSH
65466: PPUSH
65467: PPUSH
65468: PPUSH
65469: PPUSH
65470: PPUSH
65471: PPUSH
65472: PPUSH
65473: PPUSH
65474: PPUSH
65475: PPUSH
65476: PPUSH
65477: PPUSH
65478: PPUSH
65479: PPUSH
65480: PPUSH
65481: PPUSH
65482: PPUSH
65483: PPUSH
65484: PPUSH
65485: PPUSH
65486: PPUSH
65487: PPUSH
65488: PPUSH
// result = [ ] ;
65489: LD_ADDR_VAR 0 7
65493: PUSH
65494: EMPTY
65495: ST_TO_ADDR
// temp_list = [ ] ;
65496: LD_ADDR_VAR 0 9
65500: PUSH
65501: EMPTY
65502: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65503: LD_VAR 0 4
65507: PUSH
65508: LD_INT 0
65510: PUSH
65511: LD_INT 1
65513: PUSH
65514: LD_INT 2
65516: PUSH
65517: LD_INT 3
65519: PUSH
65520: LD_INT 4
65522: PUSH
65523: LD_INT 5
65525: PUSH
65526: EMPTY
65527: LIST
65528: LIST
65529: LIST
65530: LIST
65531: LIST
65532: LIST
65533: IN
65534: NOT
65535: PUSH
65536: LD_VAR 0 1
65540: PUSH
65541: LD_INT 0
65543: PUSH
65544: LD_INT 1
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: IN
65551: PUSH
65552: LD_VAR 0 5
65556: PUSH
65557: LD_INT 1
65559: PUSH
65560: LD_INT 2
65562: PUSH
65563: LD_INT 3
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: LIST
65570: IN
65571: NOT
65572: AND
65573: OR
65574: IFFALSE 65578
// exit ;
65576: GO 83969
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65578: LD_VAR 0 1
65582: PUSH
65583: LD_INT 6
65585: PUSH
65586: LD_INT 7
65588: PUSH
65589: LD_INT 8
65591: PUSH
65592: LD_INT 13
65594: PUSH
65595: LD_INT 12
65597: PUSH
65598: LD_INT 15
65600: PUSH
65601: LD_INT 11
65603: PUSH
65604: LD_INT 14
65606: PUSH
65607: LD_INT 10
65609: PUSH
65610: EMPTY
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: IN
65621: IFFALSE 65631
// btype = b_lab ;
65623: LD_ADDR_VAR 0 1
65627: PUSH
65628: LD_INT 6
65630: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65631: LD_VAR 0 6
65635: PUSH
65636: LD_INT 0
65638: PUSH
65639: LD_INT 1
65641: PUSH
65642: LD_INT 2
65644: PUSH
65645: EMPTY
65646: LIST
65647: LIST
65648: LIST
65649: IN
65650: NOT
65651: PUSH
65652: LD_VAR 0 1
65656: PUSH
65657: LD_INT 0
65659: PUSH
65660: LD_INT 1
65662: PUSH
65663: LD_INT 2
65665: PUSH
65666: LD_INT 3
65668: PUSH
65669: LD_INT 6
65671: PUSH
65672: LD_INT 36
65674: PUSH
65675: LD_INT 4
65677: PUSH
65678: LD_INT 5
65680: PUSH
65681: LD_INT 31
65683: PUSH
65684: LD_INT 32
65686: PUSH
65687: LD_INT 33
65689: PUSH
65690: EMPTY
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: IN
65703: NOT
65704: PUSH
65705: LD_VAR 0 6
65709: PUSH
65710: LD_INT 1
65712: EQUAL
65713: AND
65714: OR
65715: PUSH
65716: LD_VAR 0 1
65720: PUSH
65721: LD_INT 2
65723: PUSH
65724: LD_INT 3
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: IN
65731: NOT
65732: PUSH
65733: LD_VAR 0 6
65737: PUSH
65738: LD_INT 2
65740: EQUAL
65741: AND
65742: OR
65743: IFFALSE 65753
// mode = 0 ;
65745: LD_ADDR_VAR 0 6
65749: PUSH
65750: LD_INT 0
65752: ST_TO_ADDR
// case mode of 0 :
65753: LD_VAR 0 6
65757: PUSH
65758: LD_INT 0
65760: DOUBLE
65761: EQUAL
65762: IFTRUE 65766
65764: GO 77219
65766: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65767: LD_ADDR_VAR 0 11
65771: PUSH
65772: LD_INT 0
65774: PUSH
65775: LD_INT 0
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 0
65784: PUSH
65785: LD_INT 1
65787: NEG
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: PUSH
65793: LD_INT 1
65795: PUSH
65796: LD_INT 0
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 1
65805: PUSH
65806: LD_INT 1
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 0
65815: PUSH
65816: LD_INT 1
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 1
65825: NEG
65826: PUSH
65827: LD_INT 0
65829: PUSH
65830: EMPTY
65831: LIST
65832: LIST
65833: PUSH
65834: LD_INT 1
65836: NEG
65837: PUSH
65838: LD_INT 1
65840: NEG
65841: PUSH
65842: EMPTY
65843: LIST
65844: LIST
65845: PUSH
65846: LD_INT 1
65848: NEG
65849: PUSH
65850: LD_INT 2
65852: NEG
65853: PUSH
65854: EMPTY
65855: LIST
65856: LIST
65857: PUSH
65858: LD_INT 0
65860: PUSH
65861: LD_INT 2
65863: NEG
65864: PUSH
65865: EMPTY
65866: LIST
65867: LIST
65868: PUSH
65869: LD_INT 1
65871: PUSH
65872: LD_INT 1
65874: NEG
65875: PUSH
65876: EMPTY
65877: LIST
65878: LIST
65879: PUSH
65880: LD_INT 1
65882: PUSH
65883: LD_INT 2
65885: PUSH
65886: EMPTY
65887: LIST
65888: LIST
65889: PUSH
65890: LD_INT 0
65892: PUSH
65893: LD_INT 2
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PUSH
65900: LD_INT 1
65902: NEG
65903: PUSH
65904: LD_INT 1
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 1
65913: PUSH
65914: LD_INT 3
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: LD_INT 0
65923: PUSH
65924: LD_INT 3
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: LD_INT 1
65933: NEG
65934: PUSH
65935: LD_INT 2
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: EMPTY
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: LIST
65948: LIST
65949: LIST
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65960: LD_ADDR_VAR 0 12
65964: PUSH
65965: LD_INT 0
65967: PUSH
65968: LD_INT 0
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 0
65977: PUSH
65978: LD_INT 1
65980: NEG
65981: PUSH
65982: EMPTY
65983: LIST
65984: LIST
65985: PUSH
65986: LD_INT 1
65988: PUSH
65989: LD_INT 0
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 1
65998: PUSH
65999: LD_INT 1
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PUSH
66006: LD_INT 0
66008: PUSH
66009: LD_INT 1
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 1
66018: NEG
66019: PUSH
66020: LD_INT 0
66022: PUSH
66023: EMPTY
66024: LIST
66025: LIST
66026: PUSH
66027: LD_INT 1
66029: NEG
66030: PUSH
66031: LD_INT 1
66033: NEG
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 1
66041: PUSH
66042: LD_INT 1
66044: NEG
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 2
66052: PUSH
66053: LD_INT 0
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: LD_INT 2
66062: PUSH
66063: LD_INT 1
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: PUSH
66070: LD_INT 1
66072: NEG
66073: PUSH
66074: LD_INT 1
66076: PUSH
66077: EMPTY
66078: LIST
66079: LIST
66080: PUSH
66081: LD_INT 2
66083: NEG
66084: PUSH
66085: LD_INT 0
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PUSH
66092: LD_INT 2
66094: NEG
66095: PUSH
66096: LD_INT 1
66098: NEG
66099: PUSH
66100: EMPTY
66101: LIST
66102: LIST
66103: PUSH
66104: LD_INT 2
66106: NEG
66107: PUSH
66108: LD_INT 1
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: LD_INT 3
66117: NEG
66118: PUSH
66119: LD_INT 0
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PUSH
66126: LD_INT 3
66128: NEG
66129: PUSH
66130: LD_INT 1
66132: NEG
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66156: LD_ADDR_VAR 0 13
66160: PUSH
66161: LD_INT 0
66163: PUSH
66164: LD_INT 0
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: PUSH
66171: LD_INT 0
66173: PUSH
66174: LD_INT 1
66176: NEG
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 1
66184: PUSH
66185: LD_INT 0
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 1
66194: PUSH
66195: LD_INT 1
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PUSH
66202: LD_INT 0
66204: PUSH
66205: LD_INT 1
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PUSH
66212: LD_INT 1
66214: NEG
66215: PUSH
66216: LD_INT 0
66218: PUSH
66219: EMPTY
66220: LIST
66221: LIST
66222: PUSH
66223: LD_INT 1
66225: NEG
66226: PUSH
66227: LD_INT 1
66229: NEG
66230: PUSH
66231: EMPTY
66232: LIST
66233: LIST
66234: PUSH
66235: LD_INT 1
66237: NEG
66238: PUSH
66239: LD_INT 2
66241: NEG
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: PUSH
66247: LD_INT 2
66249: PUSH
66250: LD_INT 1
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: PUSH
66257: LD_INT 2
66259: PUSH
66260: LD_INT 2
66262: PUSH
66263: EMPTY
66264: LIST
66265: LIST
66266: PUSH
66267: LD_INT 1
66269: PUSH
66270: LD_INT 2
66272: PUSH
66273: EMPTY
66274: LIST
66275: LIST
66276: PUSH
66277: LD_INT 2
66279: NEG
66280: PUSH
66281: LD_INT 1
66283: NEG
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: LD_INT 2
66291: NEG
66292: PUSH
66293: LD_INT 2
66295: NEG
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PUSH
66301: LD_INT 2
66303: NEG
66304: PUSH
66305: LD_INT 3
66307: NEG
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 3
66315: NEG
66316: PUSH
66317: LD_INT 2
66319: NEG
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 3
66327: NEG
66328: PUSH
66329: LD_INT 3
66331: NEG
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: LIST
66341: LIST
66342: LIST
66343: LIST
66344: LIST
66345: LIST
66346: LIST
66347: LIST
66348: LIST
66349: LIST
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66355: LD_ADDR_VAR 0 14
66359: PUSH
66360: LD_INT 0
66362: PUSH
66363: LD_INT 0
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PUSH
66370: LD_INT 0
66372: PUSH
66373: LD_INT 1
66375: NEG
66376: PUSH
66377: EMPTY
66378: LIST
66379: LIST
66380: PUSH
66381: LD_INT 1
66383: PUSH
66384: LD_INT 0
66386: PUSH
66387: EMPTY
66388: LIST
66389: LIST
66390: PUSH
66391: LD_INT 1
66393: PUSH
66394: LD_INT 1
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 0
66403: PUSH
66404: LD_INT 1
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 1
66413: NEG
66414: PUSH
66415: LD_INT 0
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 1
66424: NEG
66425: PUSH
66426: LD_INT 1
66428: NEG
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 1
66436: NEG
66437: PUSH
66438: LD_INT 2
66440: NEG
66441: PUSH
66442: EMPTY
66443: LIST
66444: LIST
66445: PUSH
66446: LD_INT 0
66448: PUSH
66449: LD_INT 2
66451: NEG
66452: PUSH
66453: EMPTY
66454: LIST
66455: LIST
66456: PUSH
66457: LD_INT 1
66459: PUSH
66460: LD_INT 1
66462: NEG
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: LD_INT 1
66470: PUSH
66471: LD_INT 2
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 0
66480: PUSH
66481: LD_INT 2
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 1
66490: NEG
66491: PUSH
66492: LD_INT 1
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: PUSH
66499: LD_INT 1
66501: NEG
66502: PUSH
66503: LD_INT 3
66505: NEG
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: PUSH
66511: LD_INT 0
66513: PUSH
66514: LD_INT 3
66516: NEG
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 1
66524: PUSH
66525: LD_INT 2
66527: NEG
66528: PUSH
66529: EMPTY
66530: LIST
66531: LIST
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: LIST
66537: LIST
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: LIST
66544: LIST
66545: LIST
66546: LIST
66547: LIST
66548: LIST
66549: LIST
66550: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66551: LD_ADDR_VAR 0 15
66555: PUSH
66556: LD_INT 0
66558: PUSH
66559: LD_INT 0
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: LD_INT 0
66568: PUSH
66569: LD_INT 1
66571: NEG
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 1
66579: PUSH
66580: LD_INT 0
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 1
66589: PUSH
66590: LD_INT 1
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 0
66599: PUSH
66600: LD_INT 1
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 1
66609: NEG
66610: PUSH
66611: LD_INT 0
66613: PUSH
66614: EMPTY
66615: LIST
66616: LIST
66617: PUSH
66618: LD_INT 1
66620: NEG
66621: PUSH
66622: LD_INT 1
66624: NEG
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 1
66632: PUSH
66633: LD_INT 1
66635: NEG
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: PUSH
66641: LD_INT 2
66643: PUSH
66644: LD_INT 0
66646: PUSH
66647: EMPTY
66648: LIST
66649: LIST
66650: PUSH
66651: LD_INT 2
66653: PUSH
66654: LD_INT 1
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: LD_INT 1
66663: NEG
66664: PUSH
66665: LD_INT 1
66667: PUSH
66668: EMPTY
66669: LIST
66670: LIST
66671: PUSH
66672: LD_INT 2
66674: NEG
66675: PUSH
66676: LD_INT 0
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PUSH
66683: LD_INT 2
66685: NEG
66686: PUSH
66687: LD_INT 1
66689: NEG
66690: PUSH
66691: EMPTY
66692: LIST
66693: LIST
66694: PUSH
66695: LD_INT 2
66697: PUSH
66698: LD_INT 1
66700: NEG
66701: PUSH
66702: EMPTY
66703: LIST
66704: LIST
66705: PUSH
66706: LD_INT 3
66708: PUSH
66709: LD_INT 0
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 3
66718: PUSH
66719: LD_INT 1
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66744: LD_ADDR_VAR 0 16
66748: PUSH
66749: LD_INT 0
66751: PUSH
66752: LD_INT 0
66754: PUSH
66755: EMPTY
66756: LIST
66757: LIST
66758: PUSH
66759: LD_INT 0
66761: PUSH
66762: LD_INT 1
66764: NEG
66765: PUSH
66766: EMPTY
66767: LIST
66768: LIST
66769: PUSH
66770: LD_INT 1
66772: PUSH
66773: LD_INT 0
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 1
66782: PUSH
66783: LD_INT 1
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 0
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 1
66802: NEG
66803: PUSH
66804: LD_INT 0
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: LD_INT 1
66813: NEG
66814: PUSH
66815: LD_INT 1
66817: NEG
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 1
66825: NEG
66826: PUSH
66827: LD_INT 2
66829: NEG
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: LD_INT 2
66837: PUSH
66838: LD_INT 1
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 2
66847: PUSH
66848: LD_INT 2
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: LD_INT 1
66857: PUSH
66858: LD_INT 2
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 2
66867: NEG
66868: PUSH
66869: LD_INT 1
66871: NEG
66872: PUSH
66873: EMPTY
66874: LIST
66875: LIST
66876: PUSH
66877: LD_INT 2
66879: NEG
66880: PUSH
66881: LD_INT 2
66883: NEG
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: PUSH
66889: LD_INT 3
66891: PUSH
66892: LD_INT 2
66894: PUSH
66895: EMPTY
66896: LIST
66897: LIST
66898: PUSH
66899: LD_INT 3
66901: PUSH
66902: LD_INT 3
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: PUSH
66909: LD_INT 2
66911: PUSH
66912: LD_INT 3
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: LIST
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66937: LD_ADDR_VAR 0 17
66941: PUSH
66942: LD_INT 0
66944: PUSH
66945: LD_INT 0
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: LD_INT 0
66954: PUSH
66955: LD_INT 1
66957: NEG
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: PUSH
66963: LD_INT 1
66965: PUSH
66966: LD_INT 0
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 1
66975: PUSH
66976: LD_INT 1
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 0
66985: PUSH
66986: LD_INT 1
66988: PUSH
66989: EMPTY
66990: LIST
66991: LIST
66992: PUSH
66993: LD_INT 1
66995: NEG
66996: PUSH
66997: LD_INT 0
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: PUSH
67004: LD_INT 1
67006: NEG
67007: PUSH
67008: LD_INT 1
67010: NEG
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 1
67018: NEG
67019: PUSH
67020: LD_INT 2
67022: NEG
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: LD_INT 2
67033: NEG
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 1
67041: PUSH
67042: LD_INT 1
67044: NEG
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: LD_INT 2
67052: PUSH
67053: LD_INT 0
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 2
67062: PUSH
67063: LD_INT 1
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: PUSH
67070: LD_INT 2
67072: PUSH
67073: LD_INT 2
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 1
67082: PUSH
67083: LD_INT 2
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 0
67092: PUSH
67093: LD_INT 2
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 1
67102: NEG
67103: PUSH
67104: LD_INT 1
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 2
67113: NEG
67114: PUSH
67115: LD_INT 0
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 2
67124: NEG
67125: PUSH
67126: LD_INT 1
67128: NEG
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 2
67136: NEG
67137: PUSH
67138: LD_INT 2
67140: NEG
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: LIST
67159: LIST
67160: LIST
67161: LIST
67162: LIST
67163: LIST
67164: LIST
67165: LIST
67166: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67167: LD_ADDR_VAR 0 18
67171: PUSH
67172: LD_INT 0
67174: PUSH
67175: LD_INT 0
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 0
67184: PUSH
67185: LD_INT 1
67187: NEG
67188: PUSH
67189: EMPTY
67190: LIST
67191: LIST
67192: PUSH
67193: LD_INT 1
67195: PUSH
67196: LD_INT 0
67198: PUSH
67199: EMPTY
67200: LIST
67201: LIST
67202: PUSH
67203: LD_INT 1
67205: PUSH
67206: LD_INT 1
67208: PUSH
67209: EMPTY
67210: LIST
67211: LIST
67212: PUSH
67213: LD_INT 0
67215: PUSH
67216: LD_INT 1
67218: PUSH
67219: EMPTY
67220: LIST
67221: LIST
67222: PUSH
67223: LD_INT 1
67225: NEG
67226: PUSH
67227: LD_INT 0
67229: PUSH
67230: EMPTY
67231: LIST
67232: LIST
67233: PUSH
67234: LD_INT 1
67236: NEG
67237: PUSH
67238: LD_INT 1
67240: NEG
67241: PUSH
67242: EMPTY
67243: LIST
67244: LIST
67245: PUSH
67246: LD_INT 1
67248: NEG
67249: PUSH
67250: LD_INT 2
67252: NEG
67253: PUSH
67254: EMPTY
67255: LIST
67256: LIST
67257: PUSH
67258: LD_INT 0
67260: PUSH
67261: LD_INT 2
67263: NEG
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 1
67271: PUSH
67272: LD_INT 1
67274: NEG
67275: PUSH
67276: EMPTY
67277: LIST
67278: LIST
67279: PUSH
67280: LD_INT 2
67282: PUSH
67283: LD_INT 0
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 2
67292: PUSH
67293: LD_INT 1
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: LD_INT 2
67302: PUSH
67303: LD_INT 2
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: PUSH
67310: LD_INT 1
67312: PUSH
67313: LD_INT 2
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: LD_INT 0
67322: PUSH
67323: LD_INT 2
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PUSH
67330: LD_INT 1
67332: NEG
67333: PUSH
67334: LD_INT 1
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: PUSH
67341: LD_INT 2
67343: NEG
67344: PUSH
67345: LD_INT 0
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: LD_INT 2
67354: NEG
67355: PUSH
67356: LD_INT 1
67358: NEG
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 2
67366: NEG
67367: PUSH
67368: LD_INT 2
67370: NEG
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: LIST
67391: LIST
67392: LIST
67393: LIST
67394: LIST
67395: LIST
67396: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67397: LD_ADDR_VAR 0 19
67401: PUSH
67402: LD_INT 0
67404: PUSH
67405: LD_INT 0
67407: PUSH
67408: EMPTY
67409: LIST
67410: LIST
67411: PUSH
67412: LD_INT 0
67414: PUSH
67415: LD_INT 1
67417: NEG
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: PUSH
67423: LD_INT 1
67425: PUSH
67426: LD_INT 0
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 1
67435: PUSH
67436: LD_INT 1
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 0
67445: PUSH
67446: LD_INT 1
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 1
67455: NEG
67456: PUSH
67457: LD_INT 0
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 1
67466: NEG
67467: PUSH
67468: LD_INT 1
67470: NEG
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: LD_INT 1
67478: NEG
67479: PUSH
67480: LD_INT 2
67482: NEG
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 0
67490: PUSH
67491: LD_INT 2
67493: NEG
67494: PUSH
67495: EMPTY
67496: LIST
67497: LIST
67498: PUSH
67499: LD_INT 1
67501: PUSH
67502: LD_INT 1
67504: NEG
67505: PUSH
67506: EMPTY
67507: LIST
67508: LIST
67509: PUSH
67510: LD_INT 2
67512: PUSH
67513: LD_INT 0
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: PUSH
67520: LD_INT 2
67522: PUSH
67523: LD_INT 1
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 2
67532: PUSH
67533: LD_INT 2
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: LD_INT 1
67542: PUSH
67543: LD_INT 2
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: LD_INT 0
67552: PUSH
67553: LD_INT 2
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 1
67562: NEG
67563: PUSH
67564: LD_INT 1
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 2
67573: NEG
67574: PUSH
67575: LD_INT 0
67577: PUSH
67578: EMPTY
67579: LIST
67580: LIST
67581: PUSH
67582: LD_INT 2
67584: NEG
67585: PUSH
67586: LD_INT 1
67588: NEG
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 2
67596: NEG
67597: PUSH
67598: LD_INT 2
67600: NEG
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67627: LD_ADDR_VAR 0 20
67631: PUSH
67632: LD_INT 0
67634: PUSH
67635: LD_INT 0
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: PUSH
67642: LD_INT 0
67644: PUSH
67645: LD_INT 1
67647: NEG
67648: PUSH
67649: EMPTY
67650: LIST
67651: LIST
67652: PUSH
67653: LD_INT 1
67655: PUSH
67656: LD_INT 0
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: PUSH
67663: LD_INT 1
67665: PUSH
67666: LD_INT 1
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 0
67675: PUSH
67676: LD_INT 1
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 1
67685: NEG
67686: PUSH
67687: LD_INT 0
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 1
67696: NEG
67697: PUSH
67698: LD_INT 1
67700: NEG
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 1
67708: NEG
67709: PUSH
67710: LD_INT 2
67712: NEG
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 0
67720: PUSH
67721: LD_INT 2
67723: NEG
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 1
67731: PUSH
67732: LD_INT 1
67734: NEG
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: PUSH
67740: LD_INT 2
67742: PUSH
67743: LD_INT 0
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: PUSH
67750: LD_INT 2
67752: PUSH
67753: LD_INT 1
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 2
67762: PUSH
67763: LD_INT 2
67765: PUSH
67766: EMPTY
67767: LIST
67768: LIST
67769: PUSH
67770: LD_INT 1
67772: PUSH
67773: LD_INT 2
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 0
67782: PUSH
67783: LD_INT 2
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 1
67792: NEG
67793: PUSH
67794: LD_INT 1
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 2
67803: NEG
67804: PUSH
67805: LD_INT 0
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: LD_INT 2
67814: NEG
67815: PUSH
67816: LD_INT 1
67818: NEG
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 2
67826: NEG
67827: PUSH
67828: LD_INT 2
67830: NEG
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67857: LD_ADDR_VAR 0 21
67861: PUSH
67862: LD_INT 0
67864: PUSH
67865: LD_INT 0
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: LD_INT 0
67874: PUSH
67875: LD_INT 1
67877: NEG
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: PUSH
67883: LD_INT 1
67885: PUSH
67886: LD_INT 0
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: LD_INT 1
67895: PUSH
67896: LD_INT 1
67898: PUSH
67899: EMPTY
67900: LIST
67901: LIST
67902: PUSH
67903: LD_INT 0
67905: PUSH
67906: LD_INT 1
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: PUSH
67913: LD_INT 1
67915: NEG
67916: PUSH
67917: LD_INT 0
67919: PUSH
67920: EMPTY
67921: LIST
67922: LIST
67923: PUSH
67924: LD_INT 1
67926: NEG
67927: PUSH
67928: LD_INT 1
67930: NEG
67931: PUSH
67932: EMPTY
67933: LIST
67934: LIST
67935: PUSH
67936: LD_INT 1
67938: NEG
67939: PUSH
67940: LD_INT 2
67942: NEG
67943: PUSH
67944: EMPTY
67945: LIST
67946: LIST
67947: PUSH
67948: LD_INT 0
67950: PUSH
67951: LD_INT 2
67953: NEG
67954: PUSH
67955: EMPTY
67956: LIST
67957: LIST
67958: PUSH
67959: LD_INT 1
67961: PUSH
67962: LD_INT 1
67964: NEG
67965: PUSH
67966: EMPTY
67967: LIST
67968: LIST
67969: PUSH
67970: LD_INT 2
67972: PUSH
67973: LD_INT 0
67975: PUSH
67976: EMPTY
67977: LIST
67978: LIST
67979: PUSH
67980: LD_INT 2
67982: PUSH
67983: LD_INT 1
67985: PUSH
67986: EMPTY
67987: LIST
67988: LIST
67989: PUSH
67990: LD_INT 2
67992: PUSH
67993: LD_INT 2
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: PUSH
68000: LD_INT 1
68002: PUSH
68003: LD_INT 2
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: LD_INT 0
68012: PUSH
68013: LD_INT 2
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: PUSH
68020: LD_INT 1
68022: NEG
68023: PUSH
68024: LD_INT 1
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PUSH
68031: LD_INT 2
68033: NEG
68034: PUSH
68035: LD_INT 0
68037: PUSH
68038: EMPTY
68039: LIST
68040: LIST
68041: PUSH
68042: LD_INT 2
68044: NEG
68045: PUSH
68046: LD_INT 1
68048: NEG
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 2
68056: NEG
68057: PUSH
68058: LD_INT 2
68060: NEG
68061: PUSH
68062: EMPTY
68063: LIST
68064: LIST
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68087: LD_ADDR_VAR 0 22
68091: PUSH
68092: LD_INT 0
68094: PUSH
68095: LD_INT 0
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 0
68104: PUSH
68105: LD_INT 1
68107: NEG
68108: PUSH
68109: EMPTY
68110: LIST
68111: LIST
68112: PUSH
68113: LD_INT 1
68115: PUSH
68116: LD_INT 0
68118: PUSH
68119: EMPTY
68120: LIST
68121: LIST
68122: PUSH
68123: LD_INT 1
68125: PUSH
68126: LD_INT 1
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: LD_INT 0
68135: PUSH
68136: LD_INT 1
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PUSH
68143: LD_INT 1
68145: NEG
68146: PUSH
68147: LD_INT 0
68149: PUSH
68150: EMPTY
68151: LIST
68152: LIST
68153: PUSH
68154: LD_INT 1
68156: NEG
68157: PUSH
68158: LD_INT 1
68160: NEG
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 1
68168: NEG
68169: PUSH
68170: LD_INT 2
68172: NEG
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PUSH
68178: LD_INT 0
68180: PUSH
68181: LD_INT 2
68183: NEG
68184: PUSH
68185: EMPTY
68186: LIST
68187: LIST
68188: PUSH
68189: LD_INT 1
68191: PUSH
68192: LD_INT 1
68194: NEG
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 2
68202: PUSH
68203: LD_INT 0
68205: PUSH
68206: EMPTY
68207: LIST
68208: LIST
68209: PUSH
68210: LD_INT 2
68212: PUSH
68213: LD_INT 1
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: PUSH
68220: LD_INT 2
68222: PUSH
68223: LD_INT 2
68225: PUSH
68226: EMPTY
68227: LIST
68228: LIST
68229: PUSH
68230: LD_INT 1
68232: PUSH
68233: LD_INT 2
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 0
68242: PUSH
68243: LD_INT 2
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 1
68252: NEG
68253: PUSH
68254: LD_INT 1
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 2
68263: NEG
68264: PUSH
68265: LD_INT 0
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: LD_INT 2
68274: NEG
68275: PUSH
68276: LD_INT 1
68278: NEG
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 2
68286: NEG
68287: PUSH
68288: LD_INT 2
68290: NEG
68291: PUSH
68292: EMPTY
68293: LIST
68294: LIST
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68317: LD_ADDR_VAR 0 23
68321: PUSH
68322: LD_INT 0
68324: PUSH
68325: LD_INT 0
68327: PUSH
68328: EMPTY
68329: LIST
68330: LIST
68331: PUSH
68332: LD_INT 0
68334: PUSH
68335: LD_INT 1
68337: NEG
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: PUSH
68343: LD_INT 1
68345: PUSH
68346: LD_INT 0
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 1
68355: PUSH
68356: LD_INT 1
68358: PUSH
68359: EMPTY
68360: LIST
68361: LIST
68362: PUSH
68363: LD_INT 0
68365: PUSH
68366: LD_INT 1
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: PUSH
68373: LD_INT 1
68375: NEG
68376: PUSH
68377: LD_INT 0
68379: PUSH
68380: EMPTY
68381: LIST
68382: LIST
68383: PUSH
68384: LD_INT 1
68386: NEG
68387: PUSH
68388: LD_INT 1
68390: NEG
68391: PUSH
68392: EMPTY
68393: LIST
68394: LIST
68395: PUSH
68396: LD_INT 1
68398: NEG
68399: PUSH
68400: LD_INT 2
68402: NEG
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: LD_INT 0
68410: PUSH
68411: LD_INT 2
68413: NEG
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: LD_INT 1
68421: PUSH
68422: LD_INT 1
68424: NEG
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 2
68432: PUSH
68433: LD_INT 0
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 2
68442: PUSH
68443: LD_INT 1
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: LD_INT 2
68452: PUSH
68453: LD_INT 2
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 1
68462: PUSH
68463: LD_INT 2
68465: PUSH
68466: EMPTY
68467: LIST
68468: LIST
68469: PUSH
68470: LD_INT 0
68472: PUSH
68473: LD_INT 2
68475: PUSH
68476: EMPTY
68477: LIST
68478: LIST
68479: PUSH
68480: LD_INT 1
68482: NEG
68483: PUSH
68484: LD_INT 1
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: LD_INT 2
68493: NEG
68494: PUSH
68495: LD_INT 0
68497: PUSH
68498: EMPTY
68499: LIST
68500: LIST
68501: PUSH
68502: LD_INT 2
68504: NEG
68505: PUSH
68506: LD_INT 1
68508: NEG
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 2
68516: NEG
68517: PUSH
68518: LD_INT 2
68520: NEG
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: PUSH
68526: LD_INT 2
68528: NEG
68529: PUSH
68530: LD_INT 3
68532: NEG
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 1
68540: NEG
68541: PUSH
68542: LD_INT 3
68544: NEG
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: PUSH
68550: LD_INT 1
68552: PUSH
68553: LD_INT 2
68555: NEG
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 2
68563: PUSH
68564: LD_INT 1
68566: NEG
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: LIST
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: LIST
68589: LIST
68590: LIST
68591: LIST
68592: LIST
68593: LIST
68594: LIST
68595: LIST
68596: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68597: LD_ADDR_VAR 0 24
68601: PUSH
68602: LD_INT 0
68604: PUSH
68605: LD_INT 0
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PUSH
68612: LD_INT 0
68614: PUSH
68615: LD_INT 1
68617: NEG
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PUSH
68623: LD_INT 1
68625: PUSH
68626: LD_INT 0
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 1
68635: PUSH
68636: LD_INT 1
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 0
68645: PUSH
68646: LD_INT 1
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 1
68655: NEG
68656: PUSH
68657: LD_INT 0
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 1
68666: NEG
68667: PUSH
68668: LD_INT 1
68670: NEG
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 1
68678: NEG
68679: PUSH
68680: LD_INT 2
68682: NEG
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 0
68690: PUSH
68691: LD_INT 2
68693: NEG
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: LD_INT 1
68701: PUSH
68702: LD_INT 1
68704: NEG
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 2
68712: PUSH
68713: LD_INT 0
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: PUSH
68720: LD_INT 2
68722: PUSH
68723: LD_INT 1
68725: PUSH
68726: EMPTY
68727: LIST
68728: LIST
68729: PUSH
68730: LD_INT 2
68732: PUSH
68733: LD_INT 2
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: LD_INT 1
68742: PUSH
68743: LD_INT 2
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 0
68752: PUSH
68753: LD_INT 2
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 1
68762: NEG
68763: PUSH
68764: LD_INT 1
68766: PUSH
68767: EMPTY
68768: LIST
68769: LIST
68770: PUSH
68771: LD_INT 2
68773: NEG
68774: PUSH
68775: LD_INT 0
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 2
68784: NEG
68785: PUSH
68786: LD_INT 1
68788: NEG
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: PUSH
68794: LD_INT 2
68796: NEG
68797: PUSH
68798: LD_INT 2
68800: NEG
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 1
68808: PUSH
68809: LD_INT 2
68811: NEG
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 2
68819: PUSH
68820: LD_INT 1
68822: NEG
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 3
68830: PUSH
68831: LD_INT 1
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: PUSH
68838: LD_INT 3
68840: PUSH
68841: LD_INT 2
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
68873: LD_ADDR_VAR 0 25
68877: PUSH
68878: LD_INT 0
68880: PUSH
68881: LD_INT 0
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: PUSH
68888: LD_INT 0
68890: PUSH
68891: LD_INT 1
68893: NEG
68894: PUSH
68895: EMPTY
68896: LIST
68897: LIST
68898: PUSH
68899: LD_INT 1
68901: PUSH
68902: LD_INT 0
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PUSH
68909: LD_INT 1
68911: PUSH
68912: LD_INT 1
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 0
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: LD_INT 1
68931: NEG
68932: PUSH
68933: LD_INT 0
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PUSH
68940: LD_INT 1
68942: NEG
68943: PUSH
68944: LD_INT 1
68946: NEG
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: PUSH
68952: LD_INT 1
68954: NEG
68955: PUSH
68956: LD_INT 2
68958: NEG
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PUSH
68964: LD_INT 0
68966: PUSH
68967: LD_INT 2
68969: NEG
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 1
68977: PUSH
68978: LD_INT 1
68980: NEG
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 2
68988: PUSH
68989: LD_INT 0
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: PUSH
68996: LD_INT 2
68998: PUSH
68999: LD_INT 1
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: PUSH
69006: LD_INT 2
69008: PUSH
69009: LD_INT 2
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: PUSH
69016: LD_INT 1
69018: PUSH
69019: LD_INT 2
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PUSH
69026: LD_INT 0
69028: PUSH
69029: LD_INT 2
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: LD_INT 1
69038: NEG
69039: PUSH
69040: LD_INT 1
69042: PUSH
69043: EMPTY
69044: LIST
69045: LIST
69046: PUSH
69047: LD_INT 2
69049: NEG
69050: PUSH
69051: LD_INT 0
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PUSH
69058: LD_INT 2
69060: NEG
69061: PUSH
69062: LD_INT 1
69064: NEG
69065: PUSH
69066: EMPTY
69067: LIST
69068: LIST
69069: PUSH
69070: LD_INT 2
69072: NEG
69073: PUSH
69074: LD_INT 2
69076: NEG
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: LD_INT 3
69084: PUSH
69085: LD_INT 1
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 3
69094: PUSH
69095: LD_INT 2
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 2
69104: PUSH
69105: LD_INT 3
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 1
69114: PUSH
69115: LD_INT 3
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69147: LD_ADDR_VAR 0 26
69151: PUSH
69152: LD_INT 0
69154: PUSH
69155: LD_INT 0
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: PUSH
69162: LD_INT 0
69164: PUSH
69165: LD_INT 1
69167: NEG
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 1
69175: PUSH
69176: LD_INT 0
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: PUSH
69183: LD_INT 1
69185: PUSH
69186: LD_INT 1
69188: PUSH
69189: EMPTY
69190: LIST
69191: LIST
69192: PUSH
69193: LD_INT 0
69195: PUSH
69196: LD_INT 1
69198: PUSH
69199: EMPTY
69200: LIST
69201: LIST
69202: PUSH
69203: LD_INT 1
69205: NEG
69206: PUSH
69207: LD_INT 0
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 1
69216: NEG
69217: PUSH
69218: LD_INT 1
69220: NEG
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 1
69228: NEG
69229: PUSH
69230: LD_INT 2
69232: NEG
69233: PUSH
69234: EMPTY
69235: LIST
69236: LIST
69237: PUSH
69238: LD_INT 0
69240: PUSH
69241: LD_INT 2
69243: NEG
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 1
69251: PUSH
69252: LD_INT 1
69254: NEG
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 2
69262: PUSH
69263: LD_INT 0
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 2
69272: PUSH
69273: LD_INT 1
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 2
69282: PUSH
69283: LD_INT 2
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 1
69292: PUSH
69293: LD_INT 2
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: LD_INT 0
69302: PUSH
69303: LD_INT 2
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: LD_INT 1
69312: NEG
69313: PUSH
69314: LD_INT 1
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 2
69323: NEG
69324: PUSH
69325: LD_INT 0
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 2
69334: NEG
69335: PUSH
69336: LD_INT 1
69338: NEG
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 2
69346: NEG
69347: PUSH
69348: LD_INT 2
69350: NEG
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: PUSH
69356: LD_INT 2
69358: PUSH
69359: LD_INT 3
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 1
69368: PUSH
69369: LD_INT 3
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 1
69378: NEG
69379: PUSH
69380: LD_INT 2
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 2
69389: NEG
69390: PUSH
69391: LD_INT 1
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69423: LD_ADDR_VAR 0 27
69427: PUSH
69428: LD_INT 0
69430: PUSH
69431: LD_INT 0
69433: PUSH
69434: EMPTY
69435: LIST
69436: LIST
69437: PUSH
69438: LD_INT 0
69440: PUSH
69441: LD_INT 1
69443: NEG
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 1
69451: PUSH
69452: LD_INT 0
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 1
69461: PUSH
69462: LD_INT 1
69464: PUSH
69465: EMPTY
69466: LIST
69467: LIST
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: LD_INT 1
69474: PUSH
69475: EMPTY
69476: LIST
69477: LIST
69478: PUSH
69479: LD_INT 1
69481: NEG
69482: PUSH
69483: LD_INT 0
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: LD_INT 1
69496: NEG
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: LD_INT 1
69504: NEG
69505: PUSH
69506: LD_INT 2
69508: NEG
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 0
69516: PUSH
69517: LD_INT 2
69519: NEG
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: LD_INT 1
69527: PUSH
69528: LD_INT 1
69530: NEG
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 2
69538: PUSH
69539: LD_INT 0
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: PUSH
69546: LD_INT 2
69548: PUSH
69549: LD_INT 1
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: LD_INT 2
69558: PUSH
69559: LD_INT 2
69561: PUSH
69562: EMPTY
69563: LIST
69564: LIST
69565: PUSH
69566: LD_INT 1
69568: PUSH
69569: LD_INT 2
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 0
69578: PUSH
69579: LD_INT 2
69581: PUSH
69582: EMPTY
69583: LIST
69584: LIST
69585: PUSH
69586: LD_INT 1
69588: NEG
69589: PUSH
69590: LD_INT 1
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 2
69599: NEG
69600: PUSH
69601: LD_INT 0
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 2
69610: NEG
69611: PUSH
69612: LD_INT 1
69614: NEG
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 2
69622: NEG
69623: PUSH
69624: LD_INT 2
69626: NEG
69627: PUSH
69628: EMPTY
69629: LIST
69630: LIST
69631: PUSH
69632: LD_INT 1
69634: NEG
69635: PUSH
69636: LD_INT 2
69638: PUSH
69639: EMPTY
69640: LIST
69641: LIST
69642: PUSH
69643: LD_INT 2
69645: NEG
69646: PUSH
69647: LD_INT 1
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 3
69656: NEG
69657: PUSH
69658: LD_INT 1
69660: NEG
69661: PUSH
69662: EMPTY
69663: LIST
69664: LIST
69665: PUSH
69666: LD_INT 3
69668: NEG
69669: PUSH
69670: LD_INT 2
69672: NEG
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: PUSH
69678: EMPTY
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: LIST
69689: LIST
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69703: LD_ADDR_VAR 0 28
69707: PUSH
69708: LD_INT 0
69710: PUSH
69711: LD_INT 0
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 0
69720: PUSH
69721: LD_INT 1
69723: NEG
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 1
69731: PUSH
69732: LD_INT 0
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: LD_INT 1
69741: PUSH
69742: LD_INT 1
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PUSH
69749: LD_INT 0
69751: PUSH
69752: LD_INT 1
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: PUSH
69759: LD_INT 1
69761: NEG
69762: PUSH
69763: LD_INT 0
69765: PUSH
69766: EMPTY
69767: LIST
69768: LIST
69769: PUSH
69770: LD_INT 1
69772: NEG
69773: PUSH
69774: LD_INT 1
69776: NEG
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 1
69784: NEG
69785: PUSH
69786: LD_INT 2
69788: NEG
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 0
69796: PUSH
69797: LD_INT 2
69799: NEG
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PUSH
69805: LD_INT 1
69807: PUSH
69808: LD_INT 1
69810: NEG
69811: PUSH
69812: EMPTY
69813: LIST
69814: LIST
69815: PUSH
69816: LD_INT 2
69818: PUSH
69819: LD_INT 0
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: PUSH
69826: LD_INT 2
69828: PUSH
69829: LD_INT 1
69831: PUSH
69832: EMPTY
69833: LIST
69834: LIST
69835: PUSH
69836: LD_INT 2
69838: PUSH
69839: LD_INT 2
69841: PUSH
69842: EMPTY
69843: LIST
69844: LIST
69845: PUSH
69846: LD_INT 1
69848: PUSH
69849: LD_INT 2
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: PUSH
69856: LD_INT 0
69858: PUSH
69859: LD_INT 2
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: LD_INT 1
69868: NEG
69869: PUSH
69870: LD_INT 1
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 2
69879: NEG
69880: PUSH
69881: LD_INT 0
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: PUSH
69888: LD_INT 2
69890: NEG
69891: PUSH
69892: LD_INT 1
69894: NEG
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 2
69902: NEG
69903: PUSH
69904: LD_INT 2
69906: NEG
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 2
69914: NEG
69915: PUSH
69916: LD_INT 3
69918: NEG
69919: PUSH
69920: EMPTY
69921: LIST
69922: LIST
69923: PUSH
69924: LD_INT 1
69926: NEG
69927: PUSH
69928: LD_INT 3
69930: NEG
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: PUSH
69936: LD_INT 3
69938: NEG
69939: PUSH
69940: LD_INT 1
69942: NEG
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: PUSH
69948: LD_INT 3
69950: NEG
69951: PUSH
69952: LD_INT 2
69954: NEG
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69985: LD_ADDR_VAR 0 29
69989: PUSH
69990: LD_INT 0
69992: PUSH
69993: LD_INT 0
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PUSH
70000: LD_INT 0
70002: PUSH
70003: LD_INT 1
70005: NEG
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PUSH
70011: LD_INT 1
70013: PUSH
70014: LD_INT 0
70016: PUSH
70017: EMPTY
70018: LIST
70019: LIST
70020: PUSH
70021: LD_INT 1
70023: PUSH
70024: LD_INT 1
70026: PUSH
70027: EMPTY
70028: LIST
70029: LIST
70030: PUSH
70031: LD_INT 0
70033: PUSH
70034: LD_INT 1
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: PUSH
70041: LD_INT 1
70043: NEG
70044: PUSH
70045: LD_INT 0
70047: PUSH
70048: EMPTY
70049: LIST
70050: LIST
70051: PUSH
70052: LD_INT 1
70054: NEG
70055: PUSH
70056: LD_INT 1
70058: NEG
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: PUSH
70064: LD_INT 1
70066: NEG
70067: PUSH
70068: LD_INT 2
70070: NEG
70071: PUSH
70072: EMPTY
70073: LIST
70074: LIST
70075: PUSH
70076: LD_INT 0
70078: PUSH
70079: LD_INT 2
70081: NEG
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 1
70089: PUSH
70090: LD_INT 1
70092: NEG
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 2
70100: PUSH
70101: LD_INT 0
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 2
70110: PUSH
70111: LD_INT 1
70113: PUSH
70114: EMPTY
70115: LIST
70116: LIST
70117: PUSH
70118: LD_INT 1
70120: PUSH
70121: LD_INT 2
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: PUSH
70128: LD_INT 0
70130: PUSH
70131: LD_INT 2
70133: PUSH
70134: EMPTY
70135: LIST
70136: LIST
70137: PUSH
70138: LD_INT 1
70140: NEG
70141: PUSH
70142: LD_INT 1
70144: PUSH
70145: EMPTY
70146: LIST
70147: LIST
70148: PUSH
70149: LD_INT 2
70151: NEG
70152: PUSH
70153: LD_INT 1
70155: NEG
70156: PUSH
70157: EMPTY
70158: LIST
70159: LIST
70160: PUSH
70161: LD_INT 2
70163: NEG
70164: PUSH
70165: LD_INT 2
70167: NEG
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 2
70175: NEG
70176: PUSH
70177: LD_INT 3
70179: NEG
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: PUSH
70185: LD_INT 2
70187: PUSH
70188: LD_INT 1
70190: NEG
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 3
70198: PUSH
70199: LD_INT 1
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 1
70208: PUSH
70209: LD_INT 3
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 1
70218: NEG
70219: PUSH
70220: LD_INT 2
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 3
70229: NEG
70230: PUSH
70231: LD_INT 2
70233: NEG
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: LIST
70243: LIST
70244: LIST
70245: LIST
70246: LIST
70247: LIST
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70264: LD_ADDR_VAR 0 30
70268: PUSH
70269: LD_INT 0
70271: PUSH
70272: LD_INT 0
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 0
70281: PUSH
70282: LD_INT 1
70284: NEG
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: PUSH
70290: LD_INT 1
70292: PUSH
70293: LD_INT 0
70295: PUSH
70296: EMPTY
70297: LIST
70298: LIST
70299: PUSH
70300: LD_INT 1
70302: PUSH
70303: LD_INT 1
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 0
70312: PUSH
70313: LD_INT 1
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: LD_INT 0
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: PUSH
70331: LD_INT 1
70333: NEG
70334: PUSH
70335: LD_INT 1
70337: NEG
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: LD_INT 1
70345: NEG
70346: PUSH
70347: LD_INT 2
70349: NEG
70350: PUSH
70351: EMPTY
70352: LIST
70353: LIST
70354: PUSH
70355: LD_INT 0
70357: PUSH
70358: LD_INT 2
70360: NEG
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 2
70379: PUSH
70380: LD_INT 0
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 2
70389: PUSH
70390: LD_INT 1
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: LD_INT 2
70399: PUSH
70400: LD_INT 2
70402: PUSH
70403: EMPTY
70404: LIST
70405: LIST
70406: PUSH
70407: LD_INT 1
70409: PUSH
70410: LD_INT 2
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 1
70419: NEG
70420: PUSH
70421: LD_INT 1
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 2
70430: NEG
70431: PUSH
70432: LD_INT 0
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: LD_INT 2
70441: NEG
70442: PUSH
70443: LD_INT 1
70445: NEG
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: LD_INT 3
70457: NEG
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: PUSH
70463: LD_INT 1
70465: PUSH
70466: LD_INT 2
70468: NEG
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: LD_INT 3
70476: PUSH
70477: LD_INT 2
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: PUSH
70484: LD_INT 2
70486: PUSH
70487: LD_INT 3
70489: PUSH
70490: EMPTY
70491: LIST
70492: LIST
70493: PUSH
70494: LD_INT 2
70496: NEG
70497: PUSH
70498: LD_INT 1
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PUSH
70505: LD_INT 3
70507: NEG
70508: PUSH
70509: LD_INT 1
70511: NEG
70512: PUSH
70513: EMPTY
70514: LIST
70515: LIST
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: LIST
70521: LIST
70522: LIST
70523: LIST
70524: LIST
70525: LIST
70526: LIST
70527: LIST
70528: LIST
70529: LIST
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70542: LD_ADDR_VAR 0 31
70546: PUSH
70547: LD_INT 0
70549: PUSH
70550: LD_INT 0
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: PUSH
70557: LD_INT 0
70559: PUSH
70560: LD_INT 1
70562: NEG
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: LD_INT 1
70570: PUSH
70571: LD_INT 0
70573: PUSH
70574: EMPTY
70575: LIST
70576: LIST
70577: PUSH
70578: LD_INT 1
70580: PUSH
70581: LD_INT 1
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: PUSH
70588: LD_INT 0
70590: PUSH
70591: LD_INT 1
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: PUSH
70598: LD_INT 1
70600: NEG
70601: PUSH
70602: LD_INT 0
70604: PUSH
70605: EMPTY
70606: LIST
70607: LIST
70608: PUSH
70609: LD_INT 1
70611: NEG
70612: PUSH
70613: LD_INT 1
70615: NEG
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 1
70623: NEG
70624: PUSH
70625: LD_INT 2
70627: NEG
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: LD_INT 1
70635: PUSH
70636: LD_INT 1
70638: NEG
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 2
70646: PUSH
70647: LD_INT 0
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: PUSH
70654: LD_INT 2
70656: PUSH
70657: LD_INT 1
70659: PUSH
70660: EMPTY
70661: LIST
70662: LIST
70663: PUSH
70664: LD_INT 2
70666: PUSH
70667: LD_INT 2
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 1
70676: PUSH
70677: LD_INT 2
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: PUSH
70684: LD_INT 0
70686: PUSH
70687: LD_INT 2
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: PUSH
70694: LD_INT 1
70696: NEG
70697: PUSH
70698: LD_INT 1
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: LD_INT 2
70707: NEG
70708: PUSH
70709: LD_INT 1
70711: NEG
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: LD_INT 2
70719: NEG
70720: PUSH
70721: LD_INT 2
70723: NEG
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: LD_INT 2
70731: NEG
70732: PUSH
70733: LD_INT 3
70735: NEG
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: PUSH
70741: LD_INT 2
70743: PUSH
70744: LD_INT 1
70746: NEG
70747: PUSH
70748: EMPTY
70749: LIST
70750: LIST
70751: PUSH
70752: LD_INT 3
70754: PUSH
70755: LD_INT 1
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: PUSH
70762: LD_INT 1
70764: PUSH
70765: LD_INT 3
70767: PUSH
70768: EMPTY
70769: LIST
70770: LIST
70771: PUSH
70772: LD_INT 1
70774: NEG
70775: PUSH
70776: LD_INT 2
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: PUSH
70783: LD_INT 3
70785: NEG
70786: PUSH
70787: LD_INT 2
70789: NEG
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70820: LD_ADDR_VAR 0 32
70824: PUSH
70825: LD_INT 0
70827: PUSH
70828: LD_INT 0
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 0
70837: PUSH
70838: LD_INT 1
70840: NEG
70841: PUSH
70842: EMPTY
70843: LIST
70844: LIST
70845: PUSH
70846: LD_INT 1
70848: PUSH
70849: LD_INT 0
70851: PUSH
70852: EMPTY
70853: LIST
70854: LIST
70855: PUSH
70856: LD_INT 1
70858: PUSH
70859: LD_INT 1
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 0
70868: PUSH
70869: LD_INT 1
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: LD_INT 1
70878: NEG
70879: PUSH
70880: LD_INT 0
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 1
70889: NEG
70890: PUSH
70891: LD_INT 1
70893: NEG
70894: PUSH
70895: EMPTY
70896: LIST
70897: LIST
70898: PUSH
70899: LD_INT 1
70901: NEG
70902: PUSH
70903: LD_INT 2
70905: NEG
70906: PUSH
70907: EMPTY
70908: LIST
70909: LIST
70910: PUSH
70911: LD_INT 0
70913: PUSH
70914: LD_INT 2
70916: NEG
70917: PUSH
70918: EMPTY
70919: LIST
70920: LIST
70921: PUSH
70922: LD_INT 1
70924: PUSH
70925: LD_INT 1
70927: NEG
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: LD_INT 2
70935: PUSH
70936: LD_INT 1
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 2
70945: PUSH
70946: LD_INT 2
70948: PUSH
70949: EMPTY
70950: LIST
70951: LIST
70952: PUSH
70953: LD_INT 1
70955: PUSH
70956: LD_INT 2
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 0
70965: PUSH
70966: LD_INT 2
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: LD_INT 1
70975: NEG
70976: PUSH
70977: LD_INT 1
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 2
70986: NEG
70987: PUSH
70988: LD_INT 0
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: PUSH
70995: LD_INT 2
70997: NEG
70998: PUSH
70999: LD_INT 1
71001: NEG
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 1
71009: NEG
71010: PUSH
71011: LD_INT 3
71013: NEG
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 1
71021: PUSH
71022: LD_INT 2
71024: NEG
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 3
71032: PUSH
71033: LD_INT 2
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 2
71042: PUSH
71043: LD_INT 3
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 2
71052: NEG
71053: PUSH
71054: LD_INT 1
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 3
71063: NEG
71064: PUSH
71065: LD_INT 1
71067: NEG
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71098: LD_ADDR_VAR 0 33
71102: PUSH
71103: LD_INT 0
71105: PUSH
71106: LD_INT 0
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: LD_INT 0
71115: PUSH
71116: LD_INT 1
71118: NEG
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 1
71126: PUSH
71127: LD_INT 0
71129: PUSH
71130: EMPTY
71131: LIST
71132: LIST
71133: PUSH
71134: LD_INT 1
71136: PUSH
71137: LD_INT 1
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PUSH
71144: LD_INT 0
71146: PUSH
71147: LD_INT 1
71149: PUSH
71150: EMPTY
71151: LIST
71152: LIST
71153: PUSH
71154: LD_INT 1
71156: NEG
71157: PUSH
71158: LD_INT 0
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PUSH
71165: LD_INT 1
71167: NEG
71168: PUSH
71169: LD_INT 1
71171: NEG
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: PUSH
71177: LD_INT 1
71179: NEG
71180: PUSH
71181: LD_INT 2
71183: NEG
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 1
71191: PUSH
71192: LD_INT 1
71194: NEG
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 2
71202: PUSH
71203: LD_INT 0
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 2
71212: PUSH
71213: LD_INT 1
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 1
71222: PUSH
71223: LD_INT 2
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: PUSH
71230: LD_INT 0
71232: PUSH
71233: LD_INT 2
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: PUSH
71240: LD_INT 1
71242: NEG
71243: PUSH
71244: LD_INT 1
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 2
71253: NEG
71254: PUSH
71255: LD_INT 0
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 2
71264: NEG
71265: PUSH
71266: LD_INT 1
71268: NEG
71269: PUSH
71270: EMPTY
71271: LIST
71272: LIST
71273: PUSH
71274: LD_INT 2
71276: NEG
71277: PUSH
71278: LD_INT 2
71280: NEG
71281: PUSH
71282: EMPTY
71283: LIST
71284: LIST
71285: PUSH
71286: LD_INT 2
71288: NEG
71289: PUSH
71290: LD_INT 3
71292: NEG
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: PUSH
71298: LD_INT 2
71300: PUSH
71301: LD_INT 1
71303: NEG
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: PUSH
71309: LD_INT 3
71311: PUSH
71312: LD_INT 1
71314: PUSH
71315: EMPTY
71316: LIST
71317: LIST
71318: PUSH
71319: LD_INT 1
71321: PUSH
71322: LD_INT 3
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: LD_INT 1
71331: NEG
71332: PUSH
71333: LD_INT 2
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 3
71342: NEG
71343: PUSH
71344: LD_INT 2
71346: NEG
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71377: LD_ADDR_VAR 0 34
71381: PUSH
71382: LD_INT 0
71384: PUSH
71385: LD_INT 0
71387: PUSH
71388: EMPTY
71389: LIST
71390: LIST
71391: PUSH
71392: LD_INT 0
71394: PUSH
71395: LD_INT 1
71397: NEG
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: PUSH
71403: LD_INT 1
71405: PUSH
71406: LD_INT 0
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 1
71415: PUSH
71416: LD_INT 1
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PUSH
71423: LD_INT 0
71425: PUSH
71426: LD_INT 1
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: PUSH
71433: LD_INT 1
71435: NEG
71436: PUSH
71437: LD_INT 0
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PUSH
71444: LD_INT 1
71446: NEG
71447: PUSH
71448: LD_INT 1
71450: NEG
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: PUSH
71456: LD_INT 1
71458: NEG
71459: PUSH
71460: LD_INT 2
71462: NEG
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: LD_INT 0
71470: PUSH
71471: LD_INT 2
71473: NEG
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 1
71481: PUSH
71482: LD_INT 1
71484: NEG
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: PUSH
71490: LD_INT 2
71492: PUSH
71493: LD_INT 1
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 2
71502: PUSH
71503: LD_INT 2
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: PUSH
71510: LD_INT 1
71512: PUSH
71513: LD_INT 2
71515: PUSH
71516: EMPTY
71517: LIST
71518: LIST
71519: PUSH
71520: LD_INT 1
71522: NEG
71523: PUSH
71524: LD_INT 1
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 2
71533: NEG
71534: PUSH
71535: LD_INT 0
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PUSH
71542: LD_INT 2
71544: NEG
71545: PUSH
71546: LD_INT 1
71548: NEG
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: LD_INT 2
71556: NEG
71557: PUSH
71558: LD_INT 2
71560: NEG
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 1
71568: NEG
71569: PUSH
71570: LD_INT 3
71572: NEG
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PUSH
71578: LD_INT 1
71580: PUSH
71581: LD_INT 2
71583: NEG
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: PUSH
71589: LD_INT 3
71591: PUSH
71592: LD_INT 2
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: LD_INT 2
71601: PUSH
71602: LD_INT 3
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: PUSH
71609: LD_INT 2
71611: NEG
71612: PUSH
71613: LD_INT 1
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: PUSH
71620: LD_INT 3
71622: NEG
71623: PUSH
71624: LD_INT 1
71626: NEG
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: LIST
71648: LIST
71649: LIST
71650: LIST
71651: LIST
71652: LIST
71653: LIST
71654: LIST
71655: LIST
71656: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71657: LD_ADDR_VAR 0 35
71661: PUSH
71662: LD_INT 0
71664: PUSH
71665: LD_INT 0
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 0
71674: PUSH
71675: LD_INT 1
71677: NEG
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 1
71685: PUSH
71686: LD_INT 0
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: LD_INT 1
71695: PUSH
71696: LD_INT 1
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 0
71705: PUSH
71706: LD_INT 1
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 1
71715: NEG
71716: PUSH
71717: LD_INT 0
71719: PUSH
71720: EMPTY
71721: LIST
71722: LIST
71723: PUSH
71724: LD_INT 1
71726: NEG
71727: PUSH
71728: LD_INT 1
71730: NEG
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 2
71738: PUSH
71739: LD_INT 1
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PUSH
71746: LD_INT 2
71748: NEG
71749: PUSH
71750: LD_INT 1
71752: NEG
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: EMPTY
71759: LIST
71760: LIST
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: LIST
71767: LIST
71768: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71769: LD_ADDR_VAR 0 36
71773: PUSH
71774: LD_INT 0
71776: PUSH
71777: LD_INT 0
71779: PUSH
71780: EMPTY
71781: LIST
71782: LIST
71783: PUSH
71784: LD_INT 0
71786: PUSH
71787: LD_INT 1
71789: NEG
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 1
71797: PUSH
71798: LD_INT 0
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 1
71807: PUSH
71808: LD_INT 1
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: LD_INT 0
71817: PUSH
71818: LD_INT 1
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 1
71827: NEG
71828: PUSH
71829: LD_INT 0
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 1
71838: NEG
71839: PUSH
71840: LD_INT 1
71842: NEG
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 1
71850: NEG
71851: PUSH
71852: LD_INT 2
71854: NEG
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 1
71862: PUSH
71863: LD_INT 2
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71881: LD_ADDR_VAR 0 37
71885: PUSH
71886: LD_INT 0
71888: PUSH
71889: LD_INT 0
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: LD_INT 1
71901: NEG
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: PUSH
71907: LD_INT 1
71909: PUSH
71910: LD_INT 0
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: LD_INT 1
71919: PUSH
71920: LD_INT 1
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: PUSH
71927: LD_INT 0
71929: PUSH
71930: LD_INT 1
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: PUSH
71937: LD_INT 1
71939: NEG
71940: PUSH
71941: LD_INT 0
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: LD_INT 1
71950: NEG
71951: PUSH
71952: LD_INT 1
71954: NEG
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: LD_INT 1
71962: PUSH
71963: LD_INT 1
71965: NEG
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: PUSH
71971: LD_INT 1
71973: NEG
71974: PUSH
71975: LD_INT 1
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: EMPTY
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: LIST
71989: LIST
71990: LIST
71991: LIST
71992: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71993: LD_ADDR_VAR 0 38
71997: PUSH
71998: LD_INT 0
72000: PUSH
72001: LD_INT 0
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 0
72010: PUSH
72011: LD_INT 1
72013: NEG
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: PUSH
72019: LD_INT 1
72021: PUSH
72022: LD_INT 0
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 1
72031: PUSH
72032: LD_INT 1
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: PUSH
72039: LD_INT 0
72041: PUSH
72042: LD_INT 1
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: LD_INT 1
72051: NEG
72052: PUSH
72053: LD_INT 0
72055: PUSH
72056: EMPTY
72057: LIST
72058: LIST
72059: PUSH
72060: LD_INT 1
72062: NEG
72063: PUSH
72064: LD_INT 1
72066: NEG
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: LD_INT 2
72074: PUSH
72075: LD_INT 1
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: LD_INT 2
72084: NEG
72085: PUSH
72086: LD_INT 1
72088: NEG
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PUSH
72094: EMPTY
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72105: LD_ADDR_VAR 0 39
72109: PUSH
72110: LD_INT 0
72112: PUSH
72113: LD_INT 0
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 0
72122: PUSH
72123: LD_INT 1
72125: NEG
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: LD_INT 1
72133: PUSH
72134: LD_INT 0
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: LD_INT 1
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 0
72153: PUSH
72154: LD_INT 1
72156: PUSH
72157: EMPTY
72158: LIST
72159: LIST
72160: PUSH
72161: LD_INT 1
72163: NEG
72164: PUSH
72165: LD_INT 0
72167: PUSH
72168: EMPTY
72169: LIST
72170: LIST
72171: PUSH
72172: LD_INT 1
72174: NEG
72175: PUSH
72176: LD_INT 1
72178: NEG
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: LD_INT 1
72186: NEG
72187: PUSH
72188: LD_INT 2
72190: NEG
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: LD_INT 1
72198: PUSH
72199: LD_INT 2
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: LIST
72210: LIST
72211: LIST
72212: LIST
72213: LIST
72214: LIST
72215: LIST
72216: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72217: LD_ADDR_VAR 0 40
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: LD_INT 0
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 0
72234: PUSH
72235: LD_INT 1
72237: NEG
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: LD_INT 1
72245: PUSH
72246: LD_INT 0
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 1
72255: PUSH
72256: LD_INT 1
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: LD_INT 0
72265: PUSH
72266: LD_INT 1
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 1
72275: NEG
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 1
72286: NEG
72287: PUSH
72288: LD_INT 1
72290: NEG
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: LD_INT 1
72298: PUSH
72299: LD_INT 1
72301: NEG
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 1
72309: NEG
72310: PUSH
72311: LD_INT 1
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72329: LD_ADDR_VAR 0 41
72333: PUSH
72334: LD_INT 0
72336: PUSH
72337: LD_INT 0
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 0
72346: PUSH
72347: LD_INT 1
72349: NEG
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: PUSH
72355: LD_INT 1
72357: PUSH
72358: LD_INT 0
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: LD_INT 1
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 0
72377: PUSH
72378: LD_INT 1
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 1
72387: NEG
72388: PUSH
72389: LD_INT 0
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: PUSH
72396: LD_INT 1
72398: NEG
72399: PUSH
72400: LD_INT 1
72402: NEG
72403: PUSH
72404: EMPTY
72405: LIST
72406: LIST
72407: PUSH
72408: LD_INT 1
72410: NEG
72411: PUSH
72412: LD_INT 2
72414: NEG
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 1
72422: PUSH
72423: LD_INT 1
72425: NEG
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: PUSH
72431: LD_INT 2
72433: PUSH
72434: LD_INT 0
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 2
72443: PUSH
72444: LD_INT 1
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: LD_INT 2
72453: PUSH
72454: LD_INT 2
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 1
72463: PUSH
72464: LD_INT 2
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: PUSH
72471: LD_INT 1
72473: NEG
72474: PUSH
72475: LD_INT 1
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 2
72484: NEG
72485: PUSH
72486: LD_INT 0
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: LD_INT 2
72495: NEG
72496: PUSH
72497: LD_INT 1
72499: NEG
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 2
72507: NEG
72508: PUSH
72509: LD_INT 2
72511: NEG
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 2
72519: NEG
72520: PUSH
72521: LD_INT 3
72523: NEG
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 2
72531: PUSH
72532: LD_INT 1
72534: NEG
72535: PUSH
72536: EMPTY
72537: LIST
72538: LIST
72539: PUSH
72540: LD_INT 3
72542: PUSH
72543: LD_INT 0
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 3
72552: PUSH
72553: LD_INT 1
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 3
72562: PUSH
72563: LD_INT 2
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: LD_INT 3
72572: PUSH
72573: LD_INT 3
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 2
72582: PUSH
72583: LD_INT 3
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: PUSH
72590: LD_INT 2
72592: NEG
72593: PUSH
72594: LD_INT 1
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: PUSH
72601: LD_INT 3
72603: NEG
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 3
72614: NEG
72615: PUSH
72616: LD_INT 1
72618: NEG
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 3
72626: NEG
72627: PUSH
72628: LD_INT 2
72630: NEG
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 3
72638: NEG
72639: PUSH
72640: LD_INT 3
72642: NEG
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72679: LD_ADDR_VAR 0 42
72683: PUSH
72684: LD_INT 0
72686: PUSH
72687: LD_INT 0
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 0
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 1
72707: PUSH
72708: LD_INT 0
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 1
72717: PUSH
72718: LD_INT 1
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 0
72727: PUSH
72728: LD_INT 1
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PUSH
72735: LD_INT 1
72737: NEG
72738: PUSH
72739: LD_INT 0
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 1
72748: NEG
72749: PUSH
72750: LD_INT 1
72752: NEG
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 1
72760: NEG
72761: PUSH
72762: LD_INT 2
72764: NEG
72765: PUSH
72766: EMPTY
72767: LIST
72768: LIST
72769: PUSH
72770: LD_INT 0
72772: PUSH
72773: LD_INT 2
72775: NEG
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 1
72783: PUSH
72784: LD_INT 1
72786: NEG
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: PUSH
72792: LD_INT 2
72794: PUSH
72795: LD_INT 1
72797: PUSH
72798: EMPTY
72799: LIST
72800: LIST
72801: PUSH
72802: LD_INT 2
72804: PUSH
72805: LD_INT 2
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: PUSH
72812: LD_INT 1
72814: PUSH
72815: LD_INT 2
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 0
72824: PUSH
72825: LD_INT 2
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 1
72834: NEG
72835: PUSH
72836: LD_INT 1
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: PUSH
72843: LD_INT 2
72845: NEG
72846: PUSH
72847: LD_INT 1
72849: NEG
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 2
72857: NEG
72858: PUSH
72859: LD_INT 2
72861: NEG
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 2
72869: NEG
72870: PUSH
72871: LD_INT 3
72873: NEG
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: LD_INT 1
72881: NEG
72882: PUSH
72883: LD_INT 3
72885: NEG
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: LD_INT 0
72893: PUSH
72894: LD_INT 3
72896: NEG
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: PUSH
72902: LD_INT 1
72904: PUSH
72905: LD_INT 2
72907: NEG
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 3
72915: PUSH
72916: LD_INT 2
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 3
72925: PUSH
72926: LD_INT 3
72928: PUSH
72929: EMPTY
72930: LIST
72931: LIST
72932: PUSH
72933: LD_INT 2
72935: PUSH
72936: LD_INT 3
72938: PUSH
72939: EMPTY
72940: LIST
72941: LIST
72942: PUSH
72943: LD_INT 1
72945: PUSH
72946: LD_INT 3
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: LD_INT 0
72955: PUSH
72956: LD_INT 3
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PUSH
72963: LD_INT 1
72965: NEG
72966: PUSH
72967: LD_INT 2
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 3
72976: NEG
72977: PUSH
72978: LD_INT 2
72980: NEG
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 3
72988: NEG
72989: PUSH
72990: LD_INT 3
72992: NEG
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: LIST
73015: LIST
73016: LIST
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: LIST
73022: LIST
73023: LIST
73024: LIST
73025: LIST
73026: LIST
73027: LIST
73028: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73029: LD_ADDR_VAR 0 43
73033: PUSH
73034: LD_INT 0
73036: PUSH
73037: LD_INT 0
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: LD_INT 0
73046: PUSH
73047: LD_INT 1
73049: NEG
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 1
73057: PUSH
73058: LD_INT 0
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 1
73067: PUSH
73068: LD_INT 1
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 0
73077: PUSH
73078: LD_INT 1
73080: PUSH
73081: EMPTY
73082: LIST
73083: LIST
73084: PUSH
73085: LD_INT 1
73087: NEG
73088: PUSH
73089: LD_INT 0
73091: PUSH
73092: EMPTY
73093: LIST
73094: LIST
73095: PUSH
73096: LD_INT 1
73098: NEG
73099: PUSH
73100: LD_INT 1
73102: NEG
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 1
73110: NEG
73111: PUSH
73112: LD_INT 2
73114: NEG
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: PUSH
73120: LD_INT 0
73122: PUSH
73123: LD_INT 2
73125: NEG
73126: PUSH
73127: EMPTY
73128: LIST
73129: LIST
73130: PUSH
73131: LD_INT 1
73133: PUSH
73134: LD_INT 1
73136: NEG
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 2
73144: PUSH
73145: LD_INT 0
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PUSH
73152: LD_INT 2
73154: PUSH
73155: LD_INT 1
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: LD_INT 1
73164: PUSH
73165: LD_INT 2
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 0
73174: PUSH
73175: LD_INT 2
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 1
73184: NEG
73185: PUSH
73186: LD_INT 1
73188: PUSH
73189: EMPTY
73190: LIST
73191: LIST
73192: PUSH
73193: LD_INT 2
73195: NEG
73196: PUSH
73197: LD_INT 0
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: PUSH
73204: LD_INT 2
73206: NEG
73207: PUSH
73208: LD_INT 1
73210: NEG
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PUSH
73216: LD_INT 1
73218: NEG
73219: PUSH
73220: LD_INT 3
73222: NEG
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 0
73230: PUSH
73231: LD_INT 3
73233: NEG
73234: PUSH
73235: EMPTY
73236: LIST
73237: LIST
73238: PUSH
73239: LD_INT 1
73241: PUSH
73242: LD_INT 2
73244: NEG
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 2
73252: PUSH
73253: LD_INT 1
73255: NEG
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 3
73263: PUSH
73264: LD_INT 0
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: PUSH
73271: LD_INT 3
73273: PUSH
73274: LD_INT 1
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: LD_INT 3
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: PUSH
73291: LD_INT 0
73293: PUSH
73294: LD_INT 3
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PUSH
73301: LD_INT 1
73303: NEG
73304: PUSH
73305: LD_INT 2
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 2
73314: NEG
73315: PUSH
73316: LD_INT 1
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 3
73325: NEG
73326: PUSH
73327: LD_INT 0
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 3
73336: NEG
73337: PUSH
73338: LD_INT 1
73340: NEG
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: LIST
73350: LIST
73351: LIST
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73377: LD_ADDR_VAR 0 44
73381: PUSH
73382: LD_INT 0
73384: PUSH
73385: LD_INT 0
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: PUSH
73392: LD_INT 0
73394: PUSH
73395: LD_INT 1
73397: NEG
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 1
73405: PUSH
73406: LD_INT 0
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 1
73415: PUSH
73416: LD_INT 1
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: PUSH
73423: LD_INT 0
73425: PUSH
73426: LD_INT 1
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 1
73435: NEG
73436: PUSH
73437: LD_INT 0
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: LD_INT 1
73446: NEG
73447: PUSH
73448: LD_INT 1
73450: NEG
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 1
73458: NEG
73459: PUSH
73460: LD_INT 2
73462: NEG
73463: PUSH
73464: EMPTY
73465: LIST
73466: LIST
73467: PUSH
73468: LD_INT 1
73470: PUSH
73471: LD_INT 1
73473: NEG
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: PUSH
73479: LD_INT 2
73481: PUSH
73482: LD_INT 0
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: LD_INT 2
73491: PUSH
73492: LD_INT 1
73494: PUSH
73495: EMPTY
73496: LIST
73497: LIST
73498: PUSH
73499: LD_INT 2
73501: PUSH
73502: LD_INT 2
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: PUSH
73509: LD_INT 1
73511: PUSH
73512: LD_INT 2
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: PUSH
73519: LD_INT 1
73521: NEG
73522: PUSH
73523: LD_INT 1
73525: PUSH
73526: EMPTY
73527: LIST
73528: LIST
73529: PUSH
73530: LD_INT 2
73532: NEG
73533: PUSH
73534: LD_INT 0
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: PUSH
73541: LD_INT 2
73543: NEG
73544: PUSH
73545: LD_INT 1
73547: NEG
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PUSH
73553: LD_INT 2
73555: NEG
73556: PUSH
73557: LD_INT 2
73559: NEG
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 2
73567: NEG
73568: PUSH
73569: LD_INT 3
73571: NEG
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 2
73579: PUSH
73580: LD_INT 1
73582: NEG
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: LD_INT 3
73590: PUSH
73591: LD_INT 0
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: PUSH
73598: LD_INT 3
73600: PUSH
73601: LD_INT 1
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 3
73610: PUSH
73611: LD_INT 2
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 3
73620: PUSH
73621: LD_INT 3
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 2
73630: PUSH
73631: LD_INT 3
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: LD_INT 2
73640: NEG
73641: PUSH
73642: LD_INT 1
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 3
73651: NEG
73652: PUSH
73653: LD_INT 0
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: PUSH
73660: LD_INT 3
73662: NEG
73663: PUSH
73664: LD_INT 1
73666: NEG
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 3
73674: NEG
73675: PUSH
73676: LD_INT 2
73678: NEG
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 3
73686: NEG
73687: PUSH
73688: LD_INT 3
73690: NEG
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: LIST
73704: LIST
73705: LIST
73706: LIST
73707: LIST
73708: LIST
73709: LIST
73710: LIST
73711: LIST
73712: LIST
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: LIST
73718: LIST
73719: LIST
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: LIST
73725: LIST
73726: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73727: LD_ADDR_VAR 0 45
73731: PUSH
73732: LD_INT 0
73734: PUSH
73735: LD_INT 0
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 0
73744: PUSH
73745: LD_INT 1
73747: NEG
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 1
73755: PUSH
73756: LD_INT 0
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: LD_INT 1
73765: PUSH
73766: LD_INT 1
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: PUSH
73773: LD_INT 0
73775: PUSH
73776: LD_INT 1
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: LD_INT 1
73785: NEG
73786: PUSH
73787: LD_INT 0
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 1
73796: NEG
73797: PUSH
73798: LD_INT 1
73800: NEG
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 1
73808: NEG
73809: PUSH
73810: LD_INT 2
73812: NEG
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: PUSH
73818: LD_INT 0
73820: PUSH
73821: LD_INT 2
73823: NEG
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 1
73831: PUSH
73832: LD_INT 1
73834: NEG
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: LD_INT 2
73842: PUSH
73843: LD_INT 1
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 2
73852: PUSH
73853: LD_INT 2
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 1
73862: PUSH
73863: LD_INT 2
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 0
73872: PUSH
73873: LD_INT 2
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 1
73882: NEG
73883: PUSH
73884: LD_INT 1
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 2
73893: NEG
73894: PUSH
73895: LD_INT 1
73897: NEG
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 2
73905: NEG
73906: PUSH
73907: LD_INT 2
73909: NEG
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 2
73917: NEG
73918: PUSH
73919: LD_INT 3
73921: NEG
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 1
73929: NEG
73930: PUSH
73931: LD_INT 3
73933: NEG
73934: PUSH
73935: EMPTY
73936: LIST
73937: LIST
73938: PUSH
73939: LD_INT 0
73941: PUSH
73942: LD_INT 3
73944: NEG
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 1
73952: PUSH
73953: LD_INT 2
73955: NEG
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 3
73963: PUSH
73964: LD_INT 2
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 3
73973: PUSH
73974: LD_INT 3
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 2
73983: PUSH
73984: LD_INT 3
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: PUSH
73991: LD_INT 1
73993: PUSH
73994: LD_INT 3
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 0
74003: PUSH
74004: LD_INT 3
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: LD_INT 1
74013: NEG
74014: PUSH
74015: LD_INT 2
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 3
74024: NEG
74025: PUSH
74026: LD_INT 2
74028: NEG
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 3
74036: NEG
74037: PUSH
74038: LD_INT 3
74040: NEG
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: LIST
74075: LIST
74076: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74077: LD_ADDR_VAR 0 46
74081: PUSH
74082: LD_INT 0
74084: PUSH
74085: LD_INT 0
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: PUSH
74092: LD_INT 0
74094: PUSH
74095: LD_INT 1
74097: NEG
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 1
74105: PUSH
74106: LD_INT 0
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: PUSH
74113: LD_INT 1
74115: PUSH
74116: LD_INT 1
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: LD_INT 1
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: PUSH
74133: LD_INT 1
74135: NEG
74136: PUSH
74137: LD_INT 0
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PUSH
74144: LD_INT 1
74146: NEG
74147: PUSH
74148: LD_INT 1
74150: NEG
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: LD_INT 1
74158: NEG
74159: PUSH
74160: LD_INT 2
74162: NEG
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 0
74170: PUSH
74171: LD_INT 2
74173: NEG
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: PUSH
74179: LD_INT 1
74181: PUSH
74182: LD_INT 1
74184: NEG
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: LD_INT 2
74192: PUSH
74193: LD_INT 0
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: LD_INT 2
74202: PUSH
74203: LD_INT 1
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 1
74212: PUSH
74213: LD_INT 2
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: LD_INT 0
74222: PUSH
74223: LD_INT 2
74225: PUSH
74226: EMPTY
74227: LIST
74228: LIST
74229: PUSH
74230: LD_INT 1
74232: NEG
74233: PUSH
74234: LD_INT 1
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PUSH
74241: LD_INT 2
74243: NEG
74244: PUSH
74245: LD_INT 0
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 2
74254: NEG
74255: PUSH
74256: LD_INT 1
74258: NEG
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 1
74266: NEG
74267: PUSH
74268: LD_INT 3
74270: NEG
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: PUSH
74276: LD_INT 0
74278: PUSH
74279: LD_INT 3
74281: NEG
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: PUSH
74287: LD_INT 1
74289: PUSH
74290: LD_INT 2
74292: NEG
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: LD_INT 2
74300: PUSH
74301: LD_INT 1
74303: NEG
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 3
74311: PUSH
74312: LD_INT 0
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: PUSH
74319: LD_INT 3
74321: PUSH
74322: LD_INT 1
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 1
74331: PUSH
74332: LD_INT 3
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: PUSH
74339: LD_INT 0
74341: PUSH
74342: LD_INT 3
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: LD_INT 1
74351: NEG
74352: PUSH
74353: LD_INT 2
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: PUSH
74360: LD_INT 2
74362: NEG
74363: PUSH
74364: LD_INT 1
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 3
74373: NEG
74374: PUSH
74375: LD_INT 0
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 3
74384: NEG
74385: PUSH
74386: LD_INT 1
74388: NEG
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: LIST
74398: LIST
74399: LIST
74400: LIST
74401: LIST
74402: LIST
74403: LIST
74404: LIST
74405: LIST
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74425: LD_ADDR_VAR 0 47
74429: PUSH
74430: LD_INT 0
74432: PUSH
74433: LD_INT 0
74435: PUSH
74436: EMPTY
74437: LIST
74438: LIST
74439: PUSH
74440: LD_INT 0
74442: PUSH
74443: LD_INT 1
74445: NEG
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: LD_INT 1
74453: PUSH
74454: LD_INT 0
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 1
74463: PUSH
74464: LD_INT 1
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: LD_INT 0
74473: PUSH
74474: LD_INT 1
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: LD_INT 1
74483: NEG
74484: PUSH
74485: LD_INT 0
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 1
74494: NEG
74495: PUSH
74496: LD_INT 1
74498: NEG
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: LD_INT 1
74506: NEG
74507: PUSH
74508: LD_INT 2
74510: NEG
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: PUSH
74516: LD_INT 0
74518: PUSH
74519: LD_INT 2
74521: NEG
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 1
74529: PUSH
74530: LD_INT 1
74532: NEG
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 2
74540: NEG
74541: PUSH
74542: LD_INT 1
74544: NEG
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 2
74552: NEG
74553: PUSH
74554: LD_INT 2
74556: NEG
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: LIST
74571: LIST
74572: LIST
74573: LIST
74574: LIST
74575: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74576: LD_ADDR_VAR 0 48
74580: PUSH
74581: LD_INT 0
74583: PUSH
74584: LD_INT 0
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: PUSH
74591: LD_INT 0
74593: PUSH
74594: LD_INT 1
74596: NEG
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PUSH
74602: LD_INT 1
74604: PUSH
74605: LD_INT 0
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 1
74614: PUSH
74615: LD_INT 1
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 0
74624: PUSH
74625: LD_INT 1
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: PUSH
74632: LD_INT 1
74634: NEG
74635: PUSH
74636: LD_INT 0
74638: PUSH
74639: EMPTY
74640: LIST
74641: LIST
74642: PUSH
74643: LD_INT 1
74645: NEG
74646: PUSH
74647: LD_INT 1
74649: NEG
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: LD_INT 1
74657: NEG
74658: PUSH
74659: LD_INT 2
74661: NEG
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PUSH
74667: LD_INT 0
74669: PUSH
74670: LD_INT 2
74672: NEG
74673: PUSH
74674: EMPTY
74675: LIST
74676: LIST
74677: PUSH
74678: LD_INT 1
74680: PUSH
74681: LD_INT 1
74683: NEG
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 2
74691: PUSH
74692: LD_INT 0
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 2
74701: PUSH
74702: LD_INT 1
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: LIST
74713: LIST
74714: LIST
74715: LIST
74716: LIST
74717: LIST
74718: LIST
74719: LIST
74720: LIST
74721: LIST
74722: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74723: LD_ADDR_VAR 0 49
74727: PUSH
74728: LD_INT 0
74730: PUSH
74731: LD_INT 0
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 0
74740: PUSH
74741: LD_INT 1
74743: NEG
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 1
74751: PUSH
74752: LD_INT 0
74754: PUSH
74755: EMPTY
74756: LIST
74757: LIST
74758: PUSH
74759: LD_INT 1
74761: PUSH
74762: LD_INT 1
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: LD_INT 1
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 1
74781: NEG
74782: PUSH
74783: LD_INT 0
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 1
74792: NEG
74793: PUSH
74794: LD_INT 1
74796: NEG
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: LD_INT 1
74804: PUSH
74805: LD_INT 1
74807: NEG
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: PUSH
74813: LD_INT 2
74815: PUSH
74816: LD_INT 0
74818: PUSH
74819: EMPTY
74820: LIST
74821: LIST
74822: PUSH
74823: LD_INT 2
74825: PUSH
74826: LD_INT 1
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: PUSH
74833: LD_INT 2
74835: PUSH
74836: LD_INT 2
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: PUSH
74843: LD_INT 1
74845: PUSH
74846: LD_INT 2
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: LIST
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74867: LD_ADDR_VAR 0 50
74871: PUSH
74872: LD_INT 0
74874: PUSH
74875: LD_INT 0
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 0
74884: PUSH
74885: LD_INT 1
74887: NEG
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 1
74895: PUSH
74896: LD_INT 0
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 1
74905: PUSH
74906: LD_INT 1
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 0
74915: PUSH
74916: LD_INT 1
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 1
74925: NEG
74926: PUSH
74927: LD_INT 0
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 1
74936: NEG
74937: PUSH
74938: LD_INT 1
74940: NEG
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: PUSH
74946: LD_INT 2
74948: PUSH
74949: LD_INT 1
74951: PUSH
74952: EMPTY
74953: LIST
74954: LIST
74955: PUSH
74956: LD_INT 2
74958: PUSH
74959: LD_INT 2
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 1
74968: PUSH
74969: LD_INT 2
74971: PUSH
74972: EMPTY
74973: LIST
74974: LIST
74975: PUSH
74976: LD_INT 0
74978: PUSH
74979: LD_INT 2
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 1
74988: NEG
74989: PUSH
74990: LD_INT 1
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: LIST
75001: LIST
75002: LIST
75003: LIST
75004: LIST
75005: LIST
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75011: LD_ADDR_VAR 0 51
75015: PUSH
75016: LD_INT 0
75018: PUSH
75019: LD_INT 0
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 0
75028: PUSH
75029: LD_INT 1
75031: NEG
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 1
75039: PUSH
75040: LD_INT 0
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 1
75049: PUSH
75050: LD_INT 1
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 0
75059: PUSH
75060: LD_INT 1
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: LD_INT 1
75069: NEG
75070: PUSH
75071: LD_INT 0
75073: PUSH
75074: EMPTY
75075: LIST
75076: LIST
75077: PUSH
75078: LD_INT 1
75080: NEG
75081: PUSH
75082: LD_INT 1
75084: NEG
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 1
75092: PUSH
75093: LD_INT 2
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: LD_INT 0
75102: PUSH
75103: LD_INT 2
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: PUSH
75110: LD_INT 1
75112: NEG
75113: PUSH
75114: LD_INT 1
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: PUSH
75121: LD_INT 2
75123: NEG
75124: PUSH
75125: LD_INT 0
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: LD_INT 2
75134: NEG
75135: PUSH
75136: LD_INT 1
75138: NEG
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: LIST
75148: LIST
75149: LIST
75150: LIST
75151: LIST
75152: LIST
75153: LIST
75154: LIST
75155: LIST
75156: LIST
75157: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75158: LD_ADDR_VAR 0 52
75162: PUSH
75163: LD_INT 0
75165: PUSH
75166: LD_INT 0
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: LD_INT 0
75175: PUSH
75176: LD_INT 1
75178: NEG
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 1
75186: PUSH
75187: LD_INT 0
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 1
75196: PUSH
75197: LD_INT 1
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: LD_INT 0
75206: PUSH
75207: LD_INT 1
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: PUSH
75214: LD_INT 1
75216: NEG
75217: PUSH
75218: LD_INT 0
75220: PUSH
75221: EMPTY
75222: LIST
75223: LIST
75224: PUSH
75225: LD_INT 1
75227: NEG
75228: PUSH
75229: LD_INT 1
75231: NEG
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: PUSH
75237: LD_INT 1
75239: NEG
75240: PUSH
75241: LD_INT 2
75243: NEG
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: LD_INT 1
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 2
75262: NEG
75263: PUSH
75264: LD_INT 0
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: PUSH
75271: LD_INT 2
75273: NEG
75274: PUSH
75275: LD_INT 1
75277: NEG
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: PUSH
75283: LD_INT 2
75285: NEG
75286: PUSH
75287: LD_INT 2
75289: NEG
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: LIST
75299: LIST
75300: LIST
75301: LIST
75302: LIST
75303: LIST
75304: LIST
75305: LIST
75306: LIST
75307: LIST
75308: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75309: LD_ADDR_VAR 0 53
75313: PUSH
75314: LD_INT 0
75316: PUSH
75317: LD_INT 0
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PUSH
75324: LD_INT 0
75326: PUSH
75327: LD_INT 1
75329: NEG
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 1
75337: PUSH
75338: LD_INT 0
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 1
75347: PUSH
75348: LD_INT 1
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 0
75357: PUSH
75358: LD_INT 1
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: LD_INT 1
75367: NEG
75368: PUSH
75369: LD_INT 0
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 1
75378: NEG
75379: PUSH
75380: LD_INT 1
75382: NEG
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: LD_INT 1
75390: NEG
75391: PUSH
75392: LD_INT 2
75394: NEG
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 0
75402: PUSH
75403: LD_INT 2
75405: NEG
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: LD_INT 1
75413: PUSH
75414: LD_INT 1
75416: NEG
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: PUSH
75422: LD_INT 2
75424: PUSH
75425: LD_INT 0
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 2
75434: PUSH
75435: LD_INT 1
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 2
75444: PUSH
75445: LD_INT 2
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: LD_INT 1
75454: PUSH
75455: LD_INT 2
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: LD_INT 0
75464: PUSH
75465: LD_INT 2
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 1
75474: NEG
75475: PUSH
75476: LD_INT 1
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 2
75485: NEG
75486: PUSH
75487: LD_INT 0
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 2
75496: NEG
75497: PUSH
75498: LD_INT 1
75500: NEG
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 2
75508: NEG
75509: PUSH
75510: LD_INT 2
75512: NEG
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: EMPTY
75519: LIST
75520: LIST
75521: LIST
75522: LIST
75523: LIST
75524: LIST
75525: LIST
75526: LIST
75527: LIST
75528: LIST
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: LIST
75536: LIST
75537: LIST
75538: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75539: LD_ADDR_VAR 0 54
75543: PUSH
75544: LD_INT 0
75546: PUSH
75547: LD_INT 0
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: LD_INT 1
75559: NEG
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: PUSH
75565: LD_INT 1
75567: PUSH
75568: LD_INT 0
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 1
75577: PUSH
75578: LD_INT 1
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: LD_INT 1
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 1
75597: NEG
75598: PUSH
75599: LD_INT 0
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: LD_INT 1
75608: NEG
75609: PUSH
75610: LD_INT 1
75612: NEG
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 1
75620: NEG
75621: PUSH
75622: LD_INT 2
75624: NEG
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: PUSH
75630: LD_INT 0
75632: PUSH
75633: LD_INT 2
75635: NEG
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 1
75643: PUSH
75644: LD_INT 1
75646: NEG
75647: PUSH
75648: EMPTY
75649: LIST
75650: LIST
75651: PUSH
75652: LD_INT 2
75654: PUSH
75655: LD_INT 0
75657: PUSH
75658: EMPTY
75659: LIST
75660: LIST
75661: PUSH
75662: LD_INT 2
75664: PUSH
75665: LD_INT 1
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: PUSH
75672: LD_INT 2
75674: PUSH
75675: LD_INT 2
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 1
75684: PUSH
75685: LD_INT 2
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 0
75694: PUSH
75695: LD_INT 2
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 1
75704: NEG
75705: PUSH
75706: LD_INT 1
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: LD_INT 2
75715: NEG
75716: PUSH
75717: LD_INT 0
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: PUSH
75724: LD_INT 2
75726: NEG
75727: PUSH
75728: LD_INT 1
75730: NEG
75731: PUSH
75732: EMPTY
75733: LIST
75734: LIST
75735: PUSH
75736: LD_INT 2
75738: NEG
75739: PUSH
75740: LD_INT 2
75742: NEG
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: LIST
75766: LIST
75767: LIST
75768: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75769: LD_ADDR_VAR 0 55
75773: PUSH
75774: LD_INT 0
75776: PUSH
75777: LD_INT 0
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: LD_INT 0
75786: PUSH
75787: LD_INT 1
75789: NEG
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 1
75797: PUSH
75798: LD_INT 0
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: LD_INT 1
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 0
75817: PUSH
75818: LD_INT 1
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_INT 1
75827: NEG
75828: PUSH
75829: LD_INT 0
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 1
75838: NEG
75839: PUSH
75840: LD_INT 1
75842: NEG
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 1
75850: NEG
75851: PUSH
75852: LD_INT 2
75854: NEG
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: LD_INT 0
75862: PUSH
75863: LD_INT 2
75865: NEG
75866: PUSH
75867: EMPTY
75868: LIST
75869: LIST
75870: PUSH
75871: LD_INT 1
75873: PUSH
75874: LD_INT 1
75876: NEG
75877: PUSH
75878: EMPTY
75879: LIST
75880: LIST
75881: PUSH
75882: LD_INT 2
75884: PUSH
75885: LD_INT 0
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 2
75894: PUSH
75895: LD_INT 1
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PUSH
75902: LD_INT 2
75904: PUSH
75905: LD_INT 2
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 1
75914: PUSH
75915: LD_INT 2
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: LD_INT 0
75924: PUSH
75925: LD_INT 2
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 1
75934: NEG
75935: PUSH
75936: LD_INT 1
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 2
75945: NEG
75946: PUSH
75947: LD_INT 0
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 2
75956: NEG
75957: PUSH
75958: LD_INT 1
75960: NEG
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 2
75968: NEG
75969: PUSH
75970: LD_INT 2
75972: NEG
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: LIST
75982: LIST
75983: LIST
75984: LIST
75985: LIST
75986: LIST
75987: LIST
75988: LIST
75989: LIST
75990: LIST
75991: LIST
75992: LIST
75993: LIST
75994: LIST
75995: LIST
75996: LIST
75997: LIST
75998: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75999: LD_ADDR_VAR 0 56
76003: PUSH
76004: LD_INT 0
76006: PUSH
76007: LD_INT 0
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PUSH
76014: LD_INT 0
76016: PUSH
76017: LD_INT 1
76019: NEG
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 1
76027: PUSH
76028: LD_INT 0
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: LD_INT 1
76037: PUSH
76038: LD_INT 1
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 0
76047: PUSH
76048: LD_INT 1
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PUSH
76055: LD_INT 1
76057: NEG
76058: PUSH
76059: LD_INT 0
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: PUSH
76066: LD_INT 1
76068: NEG
76069: PUSH
76070: LD_INT 1
76072: NEG
76073: PUSH
76074: EMPTY
76075: LIST
76076: LIST
76077: PUSH
76078: LD_INT 1
76080: NEG
76081: PUSH
76082: LD_INT 2
76084: NEG
76085: PUSH
76086: EMPTY
76087: LIST
76088: LIST
76089: PUSH
76090: LD_INT 0
76092: PUSH
76093: LD_INT 2
76095: NEG
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 1
76103: PUSH
76104: LD_INT 1
76106: NEG
76107: PUSH
76108: EMPTY
76109: LIST
76110: LIST
76111: PUSH
76112: LD_INT 2
76114: PUSH
76115: LD_INT 0
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: LD_INT 2
76124: PUSH
76125: LD_INT 1
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PUSH
76132: LD_INT 2
76134: PUSH
76135: LD_INT 2
76137: PUSH
76138: EMPTY
76139: LIST
76140: LIST
76141: PUSH
76142: LD_INT 1
76144: PUSH
76145: LD_INT 2
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: LD_INT 0
76154: PUSH
76155: LD_INT 2
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: LD_INT 1
76164: NEG
76165: PUSH
76166: LD_INT 1
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 2
76175: NEG
76176: PUSH
76177: LD_INT 0
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: PUSH
76184: LD_INT 2
76186: NEG
76187: PUSH
76188: LD_INT 1
76190: NEG
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 2
76198: NEG
76199: PUSH
76200: LD_INT 2
76202: NEG
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: LIST
76222: LIST
76223: LIST
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76229: LD_ADDR_VAR 0 57
76233: PUSH
76234: LD_INT 0
76236: PUSH
76237: LD_INT 0
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 0
76246: PUSH
76247: LD_INT 1
76249: NEG
76250: PUSH
76251: EMPTY
76252: LIST
76253: LIST
76254: PUSH
76255: LD_INT 1
76257: PUSH
76258: LD_INT 0
76260: PUSH
76261: EMPTY
76262: LIST
76263: LIST
76264: PUSH
76265: LD_INT 1
76267: PUSH
76268: LD_INT 1
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: PUSH
76275: LD_INT 0
76277: PUSH
76278: LD_INT 1
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 1
76287: NEG
76288: PUSH
76289: LD_INT 0
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 1
76298: NEG
76299: PUSH
76300: LD_INT 1
76302: NEG
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: LD_INT 1
76310: NEG
76311: PUSH
76312: LD_INT 2
76314: NEG
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PUSH
76320: LD_INT 0
76322: PUSH
76323: LD_INT 2
76325: NEG
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 1
76333: PUSH
76334: LD_INT 1
76336: NEG
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: PUSH
76342: LD_INT 2
76344: PUSH
76345: LD_INT 0
76347: PUSH
76348: EMPTY
76349: LIST
76350: LIST
76351: PUSH
76352: LD_INT 2
76354: PUSH
76355: LD_INT 1
76357: PUSH
76358: EMPTY
76359: LIST
76360: LIST
76361: PUSH
76362: LD_INT 2
76364: PUSH
76365: LD_INT 2
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: LD_INT 1
76374: PUSH
76375: LD_INT 2
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: PUSH
76382: LD_INT 0
76384: PUSH
76385: LD_INT 2
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 1
76394: NEG
76395: PUSH
76396: LD_INT 1
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 2
76405: NEG
76406: PUSH
76407: LD_INT 0
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: LD_INT 2
76416: NEG
76417: PUSH
76418: LD_INT 1
76420: NEG
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: LD_INT 2
76428: NEG
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: LIST
76451: LIST
76452: LIST
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: LIST
76458: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76459: LD_ADDR_VAR 0 58
76463: PUSH
76464: LD_INT 0
76466: PUSH
76467: LD_INT 0
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: LD_INT 0
76476: PUSH
76477: LD_INT 1
76479: NEG
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: PUSH
76485: LD_INT 1
76487: PUSH
76488: LD_INT 0
76490: PUSH
76491: EMPTY
76492: LIST
76493: LIST
76494: PUSH
76495: LD_INT 1
76497: PUSH
76498: LD_INT 1
76500: PUSH
76501: EMPTY
76502: LIST
76503: LIST
76504: PUSH
76505: LD_INT 0
76507: PUSH
76508: LD_INT 1
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PUSH
76515: LD_INT 1
76517: NEG
76518: PUSH
76519: LD_INT 0
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PUSH
76526: LD_INT 1
76528: NEG
76529: PUSH
76530: LD_INT 1
76532: NEG
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 1
76540: NEG
76541: PUSH
76542: LD_INT 2
76544: NEG
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: PUSH
76550: LD_INT 0
76552: PUSH
76553: LD_INT 2
76555: NEG
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: PUSH
76561: LD_INT 1
76563: PUSH
76564: LD_INT 1
76566: NEG
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 2
76574: PUSH
76575: LD_INT 0
76577: PUSH
76578: EMPTY
76579: LIST
76580: LIST
76581: PUSH
76582: LD_INT 2
76584: PUSH
76585: LD_INT 1
76587: PUSH
76588: EMPTY
76589: LIST
76590: LIST
76591: PUSH
76592: LD_INT 2
76594: PUSH
76595: LD_INT 2
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 1
76604: PUSH
76605: LD_INT 2
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: LD_INT 0
76614: PUSH
76615: LD_INT 2
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 1
76624: NEG
76625: PUSH
76626: LD_INT 1
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 2
76635: NEG
76636: PUSH
76637: LD_INT 0
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 2
76646: NEG
76647: PUSH
76648: LD_INT 1
76650: NEG
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 2
76658: NEG
76659: PUSH
76660: LD_INT 2
76662: NEG
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: LIST
76682: LIST
76683: LIST
76684: LIST
76685: LIST
76686: LIST
76687: LIST
76688: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76689: LD_ADDR_VAR 0 59
76693: PUSH
76694: LD_INT 0
76696: PUSH
76697: LD_INT 0
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 0
76706: PUSH
76707: LD_INT 1
76709: NEG
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: LD_INT 1
76717: PUSH
76718: LD_INT 0
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: LD_INT 1
76727: PUSH
76728: LD_INT 1
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 0
76737: PUSH
76738: LD_INT 1
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 1
76747: NEG
76748: PUSH
76749: LD_INT 0
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: LD_INT 1
76758: NEG
76759: PUSH
76760: LD_INT 1
76762: NEG
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: LIST
76772: LIST
76773: LIST
76774: LIST
76775: LIST
76776: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76777: LD_ADDR_VAR 0 60
76781: PUSH
76782: LD_INT 0
76784: PUSH
76785: LD_INT 0
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 0
76794: PUSH
76795: LD_INT 1
76797: NEG
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 1
76805: PUSH
76806: LD_INT 0
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 1
76815: PUSH
76816: LD_INT 1
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: LD_INT 0
76825: PUSH
76826: LD_INT 1
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: PUSH
76833: LD_INT 1
76835: NEG
76836: PUSH
76837: LD_INT 0
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: PUSH
76844: LD_INT 1
76846: NEG
76847: PUSH
76848: LD_INT 1
76850: NEG
76851: PUSH
76852: EMPTY
76853: LIST
76854: LIST
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: LIST
76860: LIST
76861: LIST
76862: LIST
76863: LIST
76864: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76865: LD_ADDR_VAR 0 61
76869: PUSH
76870: LD_INT 0
76872: PUSH
76873: LD_INT 0
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 0
76882: PUSH
76883: LD_INT 1
76885: NEG
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: LD_INT 1
76893: PUSH
76894: LD_INT 0
76896: PUSH
76897: EMPTY
76898: LIST
76899: LIST
76900: PUSH
76901: LD_INT 1
76903: PUSH
76904: LD_INT 1
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: LD_INT 0
76913: PUSH
76914: LD_INT 1
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: PUSH
76921: LD_INT 1
76923: NEG
76924: PUSH
76925: LD_INT 0
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: LD_INT 1
76934: NEG
76935: PUSH
76936: LD_INT 1
76938: NEG
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: LIST
76948: LIST
76949: LIST
76950: LIST
76951: LIST
76952: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76953: LD_ADDR_VAR 0 62
76957: PUSH
76958: LD_INT 0
76960: PUSH
76961: LD_INT 0
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 0
76970: PUSH
76971: LD_INT 1
76973: NEG
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 1
76981: PUSH
76982: LD_INT 0
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: LD_INT 1
76991: PUSH
76992: LD_INT 1
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: PUSH
76999: LD_INT 0
77001: PUSH
77002: LD_INT 1
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PUSH
77009: LD_INT 1
77011: NEG
77012: PUSH
77013: LD_INT 0
77015: PUSH
77016: EMPTY
77017: LIST
77018: LIST
77019: PUSH
77020: LD_INT 1
77022: NEG
77023: PUSH
77024: LD_INT 1
77026: NEG
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: LIST
77036: LIST
77037: LIST
77038: LIST
77039: LIST
77040: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77041: LD_ADDR_VAR 0 63
77045: PUSH
77046: LD_INT 0
77048: PUSH
77049: LD_INT 0
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 0
77058: PUSH
77059: LD_INT 1
77061: NEG
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 1
77069: PUSH
77070: LD_INT 0
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: LD_INT 1
77079: PUSH
77080: LD_INT 1
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PUSH
77087: LD_INT 0
77089: PUSH
77090: LD_INT 1
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 1
77099: NEG
77100: PUSH
77101: LD_INT 0
77103: PUSH
77104: EMPTY
77105: LIST
77106: LIST
77107: PUSH
77108: LD_INT 1
77110: NEG
77111: PUSH
77112: LD_INT 1
77114: NEG
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: LIST
77124: LIST
77125: LIST
77126: LIST
77127: LIST
77128: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77129: LD_ADDR_VAR 0 64
77133: PUSH
77134: LD_INT 0
77136: PUSH
77137: LD_INT 0
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 0
77146: PUSH
77147: LD_INT 1
77149: NEG
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: PUSH
77155: LD_INT 1
77157: PUSH
77158: LD_INT 0
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 1
77167: PUSH
77168: LD_INT 1
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: PUSH
77175: LD_INT 0
77177: PUSH
77178: LD_INT 1
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: PUSH
77185: LD_INT 1
77187: NEG
77188: PUSH
77189: LD_INT 0
77191: PUSH
77192: EMPTY
77193: LIST
77194: LIST
77195: PUSH
77196: LD_INT 1
77198: NEG
77199: PUSH
77200: LD_INT 1
77202: NEG
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: ST_TO_ADDR
// end ; 1 :
77217: GO 83114
77219: LD_INT 1
77221: DOUBLE
77222: EQUAL
77223: IFTRUE 77227
77225: GO 79850
77227: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77228: LD_ADDR_VAR 0 11
77232: PUSH
77233: LD_INT 1
77235: NEG
77236: PUSH
77237: LD_INT 3
77239: NEG
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 0
77247: PUSH
77248: LD_INT 3
77250: NEG
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 1
77258: PUSH
77259: LD_INT 2
77261: NEG
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: EMPTY
77268: LIST
77269: LIST
77270: LIST
77271: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77272: LD_ADDR_VAR 0 12
77276: PUSH
77277: LD_INT 2
77279: PUSH
77280: LD_INT 1
77282: NEG
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: LD_INT 3
77290: PUSH
77291: LD_INT 0
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 3
77300: PUSH
77301: LD_INT 1
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: EMPTY
77309: LIST
77310: LIST
77311: LIST
77312: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77313: LD_ADDR_VAR 0 13
77317: PUSH
77318: LD_INT 3
77320: PUSH
77321: LD_INT 2
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PUSH
77328: LD_INT 3
77330: PUSH
77331: LD_INT 3
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 2
77340: PUSH
77341: LD_INT 3
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: LIST
77352: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77353: LD_ADDR_VAR 0 14
77357: PUSH
77358: LD_INT 1
77360: PUSH
77361: LD_INT 3
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: LD_INT 0
77370: PUSH
77371: LD_INT 3
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PUSH
77378: LD_INT 1
77380: NEG
77381: PUSH
77382: LD_INT 2
77384: PUSH
77385: EMPTY
77386: LIST
77387: LIST
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: LIST
77393: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77394: LD_ADDR_VAR 0 15
77398: PUSH
77399: LD_INT 2
77401: NEG
77402: PUSH
77403: LD_INT 1
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: PUSH
77410: LD_INT 3
77412: NEG
77413: PUSH
77414: LD_INT 0
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 3
77423: NEG
77424: PUSH
77425: LD_INT 1
77427: NEG
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: LIST
77437: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77438: LD_ADDR_VAR 0 16
77442: PUSH
77443: LD_INT 2
77445: NEG
77446: PUSH
77447: LD_INT 3
77449: NEG
77450: PUSH
77451: EMPTY
77452: LIST
77453: LIST
77454: PUSH
77455: LD_INT 3
77457: NEG
77458: PUSH
77459: LD_INT 2
77461: NEG
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PUSH
77467: LD_INT 3
77469: NEG
77470: PUSH
77471: LD_INT 3
77473: NEG
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: LIST
77483: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77484: LD_ADDR_VAR 0 17
77488: PUSH
77489: LD_INT 1
77491: NEG
77492: PUSH
77493: LD_INT 3
77495: NEG
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 0
77503: PUSH
77504: LD_INT 3
77506: NEG
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 1
77514: PUSH
77515: LD_INT 2
77517: NEG
77518: PUSH
77519: EMPTY
77520: LIST
77521: LIST
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: LIST
77527: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77528: LD_ADDR_VAR 0 18
77532: PUSH
77533: LD_INT 2
77535: PUSH
77536: LD_INT 1
77538: NEG
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: LD_INT 3
77546: PUSH
77547: LD_INT 0
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PUSH
77554: LD_INT 3
77556: PUSH
77557: LD_INT 1
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: EMPTY
77565: LIST
77566: LIST
77567: LIST
77568: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77569: LD_ADDR_VAR 0 19
77573: PUSH
77574: LD_INT 3
77576: PUSH
77577: LD_INT 2
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 3
77586: PUSH
77587: LD_INT 3
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 2
77596: PUSH
77597: LD_INT 3
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: LIST
77608: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77609: LD_ADDR_VAR 0 20
77613: PUSH
77614: LD_INT 1
77616: PUSH
77617: LD_INT 3
77619: PUSH
77620: EMPTY
77621: LIST
77622: LIST
77623: PUSH
77624: LD_INT 0
77626: PUSH
77627: LD_INT 3
77629: PUSH
77630: EMPTY
77631: LIST
77632: LIST
77633: PUSH
77634: LD_INT 1
77636: NEG
77637: PUSH
77638: LD_INT 2
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: LIST
77649: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77650: LD_ADDR_VAR 0 21
77654: PUSH
77655: LD_INT 2
77657: NEG
77658: PUSH
77659: LD_INT 1
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 3
77668: NEG
77669: PUSH
77670: LD_INT 0
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 3
77679: NEG
77680: PUSH
77681: LD_INT 1
77683: NEG
77684: PUSH
77685: EMPTY
77686: LIST
77687: LIST
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: LIST
77693: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77694: LD_ADDR_VAR 0 22
77698: PUSH
77699: LD_INT 2
77701: NEG
77702: PUSH
77703: LD_INT 3
77705: NEG
77706: PUSH
77707: EMPTY
77708: LIST
77709: LIST
77710: PUSH
77711: LD_INT 3
77713: NEG
77714: PUSH
77715: LD_INT 2
77717: NEG
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PUSH
77723: LD_INT 3
77725: NEG
77726: PUSH
77727: LD_INT 3
77729: NEG
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: LIST
77739: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77740: LD_ADDR_VAR 0 23
77744: PUSH
77745: LD_INT 0
77747: PUSH
77748: LD_INT 3
77750: NEG
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 1
77758: NEG
77759: PUSH
77760: LD_INT 4
77762: NEG
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: LD_INT 1
77770: PUSH
77771: LD_INT 3
77773: NEG
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: LIST
77783: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
77784: LD_ADDR_VAR 0 24
77788: PUSH
77789: LD_INT 3
77791: PUSH
77792: LD_INT 0
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 3
77801: PUSH
77802: LD_INT 1
77804: NEG
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: LD_INT 4
77812: PUSH
77813: LD_INT 1
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: LIST
77824: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
77825: LD_ADDR_VAR 0 25
77829: PUSH
77830: LD_INT 3
77832: PUSH
77833: LD_INT 3
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: PUSH
77840: LD_INT 4
77842: PUSH
77843: LD_INT 3
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 3
77852: PUSH
77853: LD_INT 4
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: LIST
77864: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
77865: LD_ADDR_VAR 0 26
77869: PUSH
77870: LD_INT 0
77872: PUSH
77873: LD_INT 3
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PUSH
77880: LD_INT 1
77882: PUSH
77883: LD_INT 4
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 1
77892: NEG
77893: PUSH
77894: LD_INT 3
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: LIST
77905: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
77906: LD_ADDR_VAR 0 27
77910: PUSH
77911: LD_INT 3
77913: NEG
77914: PUSH
77915: LD_INT 0
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PUSH
77922: LD_INT 3
77924: NEG
77925: PUSH
77926: LD_INT 1
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: PUSH
77933: LD_INT 4
77935: NEG
77936: PUSH
77937: LD_INT 1
77939: NEG
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: LIST
77949: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77950: LD_ADDR_VAR 0 28
77954: PUSH
77955: LD_INT 3
77957: NEG
77958: PUSH
77959: LD_INT 3
77961: NEG
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: PUSH
77967: LD_INT 3
77969: NEG
77970: PUSH
77971: LD_INT 4
77973: NEG
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 4
77981: NEG
77982: PUSH
77983: LD_INT 3
77985: NEG
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: LIST
77995: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77996: LD_ADDR_VAR 0 29
78000: PUSH
78001: LD_INT 1
78003: NEG
78004: PUSH
78005: LD_INT 3
78007: NEG
78008: PUSH
78009: EMPTY
78010: LIST
78011: LIST
78012: PUSH
78013: LD_INT 0
78015: PUSH
78016: LD_INT 3
78018: NEG
78019: PUSH
78020: EMPTY
78021: LIST
78022: LIST
78023: PUSH
78024: LD_INT 1
78026: PUSH
78027: LD_INT 2
78029: NEG
78030: PUSH
78031: EMPTY
78032: LIST
78033: LIST
78034: PUSH
78035: LD_INT 1
78037: NEG
78038: PUSH
78039: LD_INT 4
78041: NEG
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 0
78049: PUSH
78050: LD_INT 4
78052: NEG
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: PUSH
78058: LD_INT 1
78060: PUSH
78061: LD_INT 3
78063: NEG
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: LD_INT 1
78071: NEG
78072: PUSH
78073: LD_INT 5
78075: NEG
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: LD_INT 0
78083: PUSH
78084: LD_INT 5
78086: NEG
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 1
78094: PUSH
78095: LD_INT 4
78097: NEG
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: PUSH
78103: LD_INT 1
78105: NEG
78106: PUSH
78107: LD_INT 6
78109: NEG
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 0
78117: PUSH
78118: LD_INT 6
78120: NEG
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: PUSH
78126: LD_INT 1
78128: PUSH
78129: LD_INT 5
78131: NEG
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: PUSH
78137: EMPTY
78138: LIST
78139: LIST
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78151: LD_ADDR_VAR 0 30
78155: PUSH
78156: LD_INT 2
78158: PUSH
78159: LD_INT 1
78161: NEG
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 3
78169: PUSH
78170: LD_INT 0
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 3
78179: PUSH
78180: LD_INT 1
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: PUSH
78187: LD_INT 3
78189: PUSH
78190: LD_INT 1
78192: NEG
78193: PUSH
78194: EMPTY
78195: LIST
78196: LIST
78197: PUSH
78198: LD_INT 4
78200: PUSH
78201: LD_INT 0
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: PUSH
78208: LD_INT 4
78210: PUSH
78211: LD_INT 1
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: LD_INT 4
78220: PUSH
78221: LD_INT 1
78223: NEG
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: LD_INT 5
78231: PUSH
78232: LD_INT 0
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: PUSH
78239: LD_INT 5
78241: PUSH
78242: LD_INT 1
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 5
78251: PUSH
78252: LD_INT 1
78254: NEG
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 6
78262: PUSH
78263: LD_INT 0
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: LD_INT 6
78272: PUSH
78273: LD_INT 1
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: LIST
78286: LIST
78287: LIST
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78294: LD_ADDR_VAR 0 31
78298: PUSH
78299: LD_INT 3
78301: PUSH
78302: LD_INT 2
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: LD_INT 3
78311: PUSH
78312: LD_INT 3
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 2
78321: PUSH
78322: LD_INT 3
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 4
78331: PUSH
78332: LD_INT 3
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 4
78341: PUSH
78342: LD_INT 4
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: PUSH
78349: LD_INT 3
78351: PUSH
78352: LD_INT 4
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: PUSH
78359: LD_INT 5
78361: PUSH
78362: LD_INT 4
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PUSH
78369: LD_INT 5
78371: PUSH
78372: LD_INT 5
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 4
78381: PUSH
78382: LD_INT 5
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: PUSH
78389: LD_INT 6
78391: PUSH
78392: LD_INT 5
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 6
78401: PUSH
78402: LD_INT 6
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 5
78411: PUSH
78412: LD_INT 6
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: LIST
78426: LIST
78427: LIST
78428: LIST
78429: LIST
78430: LIST
78431: LIST
78432: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78433: LD_ADDR_VAR 0 32
78437: PUSH
78438: LD_INT 1
78440: PUSH
78441: LD_INT 3
78443: PUSH
78444: EMPTY
78445: LIST
78446: LIST
78447: PUSH
78448: LD_INT 0
78450: PUSH
78451: LD_INT 3
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: PUSH
78458: LD_INT 1
78460: NEG
78461: PUSH
78462: LD_INT 2
78464: PUSH
78465: EMPTY
78466: LIST
78467: LIST
78468: PUSH
78469: LD_INT 1
78471: PUSH
78472: LD_INT 4
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: PUSH
78479: LD_INT 0
78481: PUSH
78482: LD_INT 4
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 1
78491: NEG
78492: PUSH
78493: LD_INT 3
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: PUSH
78500: LD_INT 1
78502: PUSH
78503: LD_INT 5
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 0
78512: PUSH
78513: LD_INT 5
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: LD_INT 1
78522: NEG
78523: PUSH
78524: LD_INT 4
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 1
78533: PUSH
78534: LD_INT 6
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: PUSH
78541: LD_INT 0
78543: PUSH
78544: LD_INT 6
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 1
78553: NEG
78554: PUSH
78555: LD_INT 5
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: EMPTY
78563: LIST
78564: LIST
78565: LIST
78566: LIST
78567: LIST
78568: LIST
78569: LIST
78570: LIST
78571: LIST
78572: LIST
78573: LIST
78574: LIST
78575: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78576: LD_ADDR_VAR 0 33
78580: PUSH
78581: LD_INT 2
78583: NEG
78584: PUSH
78585: LD_INT 1
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: LD_INT 3
78594: NEG
78595: PUSH
78596: LD_INT 0
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 3
78605: NEG
78606: PUSH
78607: LD_INT 1
78609: NEG
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_INT 3
78617: NEG
78618: PUSH
78619: LD_INT 1
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 4
78628: NEG
78629: PUSH
78630: LD_INT 0
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 4
78639: NEG
78640: PUSH
78641: LD_INT 1
78643: NEG
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 4
78651: NEG
78652: PUSH
78653: LD_INT 1
78655: PUSH
78656: EMPTY
78657: LIST
78658: LIST
78659: PUSH
78660: LD_INT 5
78662: NEG
78663: PUSH
78664: LD_INT 0
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: PUSH
78671: LD_INT 5
78673: NEG
78674: PUSH
78675: LD_INT 1
78677: NEG
78678: PUSH
78679: EMPTY
78680: LIST
78681: LIST
78682: PUSH
78683: LD_INT 5
78685: NEG
78686: PUSH
78687: LD_INT 1
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 6
78696: NEG
78697: PUSH
78698: LD_INT 0
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 6
78707: NEG
78708: PUSH
78709: LD_INT 1
78711: NEG
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: LIST
78721: LIST
78722: LIST
78723: LIST
78724: LIST
78725: LIST
78726: LIST
78727: LIST
78728: LIST
78729: LIST
78730: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78731: LD_ADDR_VAR 0 34
78735: PUSH
78736: LD_INT 2
78738: NEG
78739: PUSH
78740: LD_INT 3
78742: NEG
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 3
78750: NEG
78751: PUSH
78752: LD_INT 2
78754: NEG
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 3
78762: NEG
78763: PUSH
78764: LD_INT 3
78766: NEG
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 3
78774: NEG
78775: PUSH
78776: LD_INT 4
78778: NEG
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 4
78786: NEG
78787: PUSH
78788: LD_INT 3
78790: NEG
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: PUSH
78796: LD_INT 4
78798: NEG
78799: PUSH
78800: LD_INT 4
78802: NEG
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 4
78810: NEG
78811: PUSH
78812: LD_INT 5
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 5
78822: NEG
78823: PUSH
78824: LD_INT 4
78826: NEG
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 5
78834: NEG
78835: PUSH
78836: LD_INT 5
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 5
78846: NEG
78847: PUSH
78848: LD_INT 6
78850: NEG
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 6
78858: NEG
78859: PUSH
78860: LD_INT 5
78862: NEG
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 6
78870: NEG
78871: PUSH
78872: LD_INT 6
78874: NEG
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: PUSH
78880: EMPTY
78881: LIST
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
78894: LD_ADDR_VAR 0 41
78898: PUSH
78899: LD_INT 0
78901: PUSH
78902: LD_INT 2
78904: NEG
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 1
78912: NEG
78913: PUSH
78914: LD_INT 3
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 1
78924: PUSH
78925: LD_INT 2
78927: NEG
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: LIST
78937: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
78938: LD_ADDR_VAR 0 42
78942: PUSH
78943: LD_INT 2
78945: PUSH
78946: LD_INT 0
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 2
78955: PUSH
78956: LD_INT 1
78958: NEG
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 3
78966: PUSH
78967: LD_INT 1
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: LIST
78978: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78979: LD_ADDR_VAR 0 43
78983: PUSH
78984: LD_INT 2
78986: PUSH
78987: LD_INT 2
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 3
78996: PUSH
78997: LD_INT 2
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: PUSH
79004: LD_INT 2
79006: PUSH
79007: LD_INT 3
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: LIST
79018: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79019: LD_ADDR_VAR 0 44
79023: PUSH
79024: LD_INT 0
79026: PUSH
79027: LD_INT 2
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 1
79036: PUSH
79037: LD_INT 3
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 1
79046: NEG
79047: PUSH
79048: LD_INT 2
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: LIST
79059: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79060: LD_ADDR_VAR 0 45
79064: PUSH
79065: LD_INT 2
79067: NEG
79068: PUSH
79069: LD_INT 0
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 2
79078: NEG
79079: PUSH
79080: LD_INT 1
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: LD_INT 3
79089: NEG
79090: PUSH
79091: LD_INT 1
79093: NEG
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: LIST
79103: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79104: LD_ADDR_VAR 0 46
79108: PUSH
79109: LD_INT 2
79111: NEG
79112: PUSH
79113: LD_INT 2
79115: NEG
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: LD_INT 2
79123: NEG
79124: PUSH
79125: LD_INT 3
79127: NEG
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 3
79135: NEG
79136: PUSH
79137: LD_INT 2
79139: NEG
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: LIST
79149: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79150: LD_ADDR_VAR 0 47
79154: PUSH
79155: LD_INT 2
79157: NEG
79158: PUSH
79159: LD_INT 3
79161: NEG
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 1
79169: NEG
79170: PUSH
79171: LD_INT 3
79173: NEG
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79183: LD_ADDR_VAR 0 48
79187: PUSH
79188: LD_INT 1
79190: PUSH
79191: LD_INT 2
79193: NEG
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PUSH
79199: LD_INT 2
79201: PUSH
79202: LD_INT 1
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79214: LD_ADDR_VAR 0 49
79218: PUSH
79219: LD_INT 3
79221: PUSH
79222: LD_INT 1
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 3
79231: PUSH
79232: LD_INT 2
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79243: LD_ADDR_VAR 0 50
79247: PUSH
79248: LD_INT 2
79250: PUSH
79251: LD_INT 3
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 1
79260: PUSH
79261: LD_INT 3
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79272: LD_ADDR_VAR 0 51
79276: PUSH
79277: LD_INT 1
79279: NEG
79280: PUSH
79281: LD_INT 2
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: PUSH
79288: LD_INT 2
79290: NEG
79291: PUSH
79292: LD_INT 1
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79303: LD_ADDR_VAR 0 52
79307: PUSH
79308: LD_INT 3
79310: NEG
79311: PUSH
79312: LD_INT 1
79314: NEG
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 3
79322: NEG
79323: PUSH
79324: LD_INT 2
79326: NEG
79327: PUSH
79328: EMPTY
79329: LIST
79330: LIST
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79336: LD_ADDR_VAR 0 53
79340: PUSH
79341: LD_INT 1
79343: NEG
79344: PUSH
79345: LD_INT 3
79347: NEG
79348: PUSH
79349: EMPTY
79350: LIST
79351: LIST
79352: PUSH
79353: LD_INT 0
79355: PUSH
79356: LD_INT 3
79358: NEG
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 1
79366: PUSH
79367: LD_INT 2
79369: NEG
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: LIST
79379: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79380: LD_ADDR_VAR 0 54
79384: PUSH
79385: LD_INT 2
79387: PUSH
79388: LD_INT 1
79390: NEG
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 3
79398: PUSH
79399: LD_INT 0
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 3
79408: PUSH
79409: LD_INT 1
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: LIST
79420: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79421: LD_ADDR_VAR 0 55
79425: PUSH
79426: LD_INT 3
79428: PUSH
79429: LD_INT 2
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 3
79438: PUSH
79439: LD_INT 3
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 2
79448: PUSH
79449: LD_INT 3
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: LIST
79460: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79461: LD_ADDR_VAR 0 56
79465: PUSH
79466: LD_INT 1
79468: PUSH
79469: LD_INT 3
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 0
79478: PUSH
79479: LD_INT 3
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 1
79488: NEG
79489: PUSH
79490: LD_INT 2
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: LIST
79501: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79502: LD_ADDR_VAR 0 57
79506: PUSH
79507: LD_INT 2
79509: NEG
79510: PUSH
79511: LD_INT 1
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 3
79520: NEG
79521: PUSH
79522: LD_INT 0
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 3
79531: NEG
79532: PUSH
79533: LD_INT 1
79535: NEG
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: LIST
79545: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79546: LD_ADDR_VAR 0 58
79550: PUSH
79551: LD_INT 2
79553: NEG
79554: PUSH
79555: LD_INT 3
79557: NEG
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PUSH
79563: LD_INT 3
79565: NEG
79566: PUSH
79567: LD_INT 2
79569: NEG
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 3
79577: NEG
79578: PUSH
79579: LD_INT 3
79581: NEG
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: LIST
79591: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79592: LD_ADDR_VAR 0 59
79596: PUSH
79597: LD_INT 1
79599: NEG
79600: PUSH
79601: LD_INT 2
79603: NEG
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 0
79611: PUSH
79612: LD_INT 2
79614: NEG
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 1
79622: PUSH
79623: LD_INT 1
79625: NEG
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: LIST
79635: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79636: LD_ADDR_VAR 0 60
79640: PUSH
79641: LD_INT 1
79643: PUSH
79644: LD_INT 1
79646: NEG
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 2
79654: PUSH
79655: LD_INT 0
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 2
79664: PUSH
79665: LD_INT 1
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: LIST
79676: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79677: LD_ADDR_VAR 0 61
79681: PUSH
79682: LD_INT 2
79684: PUSH
79685: LD_INT 1
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: PUSH
79692: LD_INT 2
79694: PUSH
79695: LD_INT 2
79697: PUSH
79698: EMPTY
79699: LIST
79700: LIST
79701: PUSH
79702: LD_INT 1
79704: PUSH
79705: LD_INT 2
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: LIST
79716: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79717: LD_ADDR_VAR 0 62
79721: PUSH
79722: LD_INT 1
79724: PUSH
79725: LD_INT 2
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 0
79734: PUSH
79735: LD_INT 2
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 1
79744: NEG
79745: PUSH
79746: LD_INT 1
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: LIST
79757: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79758: LD_ADDR_VAR 0 63
79762: PUSH
79763: LD_INT 1
79765: NEG
79766: PUSH
79767: LD_INT 1
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 2
79776: NEG
79777: PUSH
79778: LD_INT 0
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_INT 2
79787: NEG
79788: PUSH
79789: LD_INT 1
79791: NEG
79792: PUSH
79793: EMPTY
79794: LIST
79795: LIST
79796: PUSH
79797: EMPTY
79798: LIST
79799: LIST
79800: LIST
79801: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79802: LD_ADDR_VAR 0 64
79806: PUSH
79807: LD_INT 1
79809: NEG
79810: PUSH
79811: LD_INT 2
79813: NEG
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 2
79821: NEG
79822: PUSH
79823: LD_INT 1
79825: NEG
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: LD_INT 2
79833: NEG
79834: PUSH
79835: LD_INT 2
79837: NEG
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: LIST
79847: ST_TO_ADDR
// end ; 2 :
79848: GO 83114
79850: LD_INT 2
79852: DOUBLE
79853: EQUAL
79854: IFTRUE 79858
79856: GO 83113
79858: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
79859: LD_ADDR_VAR 0 29
79863: PUSH
79864: LD_INT 4
79866: PUSH
79867: LD_INT 0
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 4
79876: PUSH
79877: LD_INT 1
79879: NEG
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 5
79887: PUSH
79888: LD_INT 0
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 5
79897: PUSH
79898: LD_INT 1
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PUSH
79905: LD_INT 4
79907: PUSH
79908: LD_INT 1
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 3
79917: PUSH
79918: LD_INT 0
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 3
79927: PUSH
79928: LD_INT 1
79930: NEG
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 3
79938: PUSH
79939: LD_INT 2
79941: NEG
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: PUSH
79947: LD_INT 5
79949: PUSH
79950: LD_INT 2
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 3
79959: PUSH
79960: LD_INT 3
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 3
79969: PUSH
79970: LD_INT 2
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 4
79979: PUSH
79980: LD_INT 3
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: PUSH
79987: LD_INT 4
79989: PUSH
79990: LD_INT 4
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 3
79999: PUSH
80000: LD_INT 4
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 2
80009: PUSH
80010: LD_INT 3
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 2
80019: PUSH
80020: LD_INT 2
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 4
80029: PUSH
80030: LD_INT 2
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 2
80039: PUSH
80040: LD_INT 4
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 0
80049: PUSH
80050: LD_INT 4
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: LD_INT 0
80059: PUSH
80060: LD_INT 3
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 1
80069: PUSH
80070: LD_INT 4
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 1
80079: PUSH
80080: LD_INT 5
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 0
80089: PUSH
80090: LD_INT 5
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 1
80099: NEG
80100: PUSH
80101: LD_INT 4
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 1
80110: NEG
80111: PUSH
80112: LD_INT 3
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 2
80121: PUSH
80122: LD_INT 5
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 2
80131: NEG
80132: PUSH
80133: LD_INT 3
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 3
80142: NEG
80143: PUSH
80144: LD_INT 0
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: PUSH
80151: LD_INT 3
80153: NEG
80154: PUSH
80155: LD_INT 1
80157: NEG
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: PUSH
80163: LD_INT 2
80165: NEG
80166: PUSH
80167: LD_INT 0
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 2
80176: NEG
80177: PUSH
80178: LD_INT 1
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: LD_INT 3
80187: NEG
80188: PUSH
80189: LD_INT 1
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 4
80198: NEG
80199: PUSH
80200: LD_INT 0
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 4
80209: NEG
80210: PUSH
80211: LD_INT 1
80213: NEG
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PUSH
80219: LD_INT 4
80221: NEG
80222: PUSH
80223: LD_INT 2
80225: NEG
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 2
80233: NEG
80234: PUSH
80235: LD_INT 2
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 4
80244: NEG
80245: PUSH
80246: LD_INT 4
80248: NEG
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: PUSH
80254: LD_INT 4
80256: NEG
80257: PUSH
80258: LD_INT 5
80260: NEG
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 3
80268: NEG
80269: PUSH
80270: LD_INT 4
80272: NEG
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 3
80280: NEG
80281: PUSH
80282: LD_INT 3
80284: NEG
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 4
80292: NEG
80293: PUSH
80294: LD_INT 3
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 5
80304: NEG
80305: PUSH
80306: LD_INT 4
80308: NEG
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 5
80316: NEG
80317: PUSH
80318: LD_INT 5
80320: NEG
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: LD_INT 3
80328: NEG
80329: PUSH
80330: LD_INT 5
80332: NEG
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 5
80340: NEG
80341: PUSH
80342: LD_INT 3
80344: NEG
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80397: LD_ADDR_VAR 0 30
80401: PUSH
80402: LD_INT 4
80404: PUSH
80405: LD_INT 4
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 4
80414: PUSH
80415: LD_INT 3
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: LD_INT 5
80424: PUSH
80425: LD_INT 4
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 5
80434: PUSH
80435: LD_INT 5
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 4
80444: PUSH
80445: LD_INT 5
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: LD_INT 3
80454: PUSH
80455: LD_INT 4
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 3
80464: PUSH
80465: LD_INT 3
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: LD_INT 5
80474: PUSH
80475: LD_INT 3
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 3
80484: PUSH
80485: LD_INT 5
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PUSH
80492: LD_INT 0
80494: PUSH
80495: LD_INT 3
80497: PUSH
80498: EMPTY
80499: LIST
80500: LIST
80501: PUSH
80502: LD_INT 0
80504: PUSH
80505: LD_INT 2
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 1
80514: PUSH
80515: LD_INT 3
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: PUSH
80522: LD_INT 1
80524: PUSH
80525: LD_INT 4
80527: PUSH
80528: EMPTY
80529: LIST
80530: LIST
80531: PUSH
80532: LD_INT 0
80534: PUSH
80535: LD_INT 4
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 1
80544: NEG
80545: PUSH
80546: LD_INT 3
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 1
80555: NEG
80556: PUSH
80557: LD_INT 2
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 2
80566: PUSH
80567: LD_INT 4
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: LD_INT 2
80576: NEG
80577: PUSH
80578: LD_INT 2
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 4
80587: NEG
80588: PUSH
80589: LD_INT 0
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 4
80598: NEG
80599: PUSH
80600: LD_INT 1
80602: NEG
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 3
80610: NEG
80611: PUSH
80612: LD_INT 0
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 3
80621: NEG
80622: PUSH
80623: LD_INT 1
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 4
80632: NEG
80633: PUSH
80634: LD_INT 1
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 5
80643: NEG
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 5
80654: NEG
80655: PUSH
80656: LD_INT 1
80658: NEG
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 5
80666: NEG
80667: PUSH
80668: LD_INT 2
80670: NEG
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 3
80678: NEG
80679: PUSH
80680: LD_INT 2
80682: PUSH
80683: EMPTY
80684: LIST
80685: LIST
80686: PUSH
80687: LD_INT 3
80689: NEG
80690: PUSH
80691: LD_INT 3
80693: NEG
80694: PUSH
80695: EMPTY
80696: LIST
80697: LIST
80698: PUSH
80699: LD_INT 3
80701: NEG
80702: PUSH
80703: LD_INT 4
80705: NEG
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 2
80713: NEG
80714: PUSH
80715: LD_INT 3
80717: NEG
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 2
80725: NEG
80726: PUSH
80727: LD_INT 2
80729: NEG
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 3
80737: NEG
80738: PUSH
80739: LD_INT 2
80741: NEG
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PUSH
80747: LD_INT 4
80749: NEG
80750: PUSH
80751: LD_INT 3
80753: NEG
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 4
80761: NEG
80762: PUSH
80763: LD_INT 4
80765: NEG
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 2
80773: NEG
80774: PUSH
80775: LD_INT 4
80777: NEG
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: PUSH
80783: LD_INT 4
80785: NEG
80786: PUSH
80787: LD_INT 2
80789: NEG
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 0
80797: PUSH
80798: LD_INT 4
80800: NEG
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 5
80811: NEG
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 1
80819: PUSH
80820: LD_INT 4
80822: NEG
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 1
80830: PUSH
80831: LD_INT 3
80833: NEG
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: LD_INT 3
80844: NEG
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 1
80852: NEG
80853: PUSH
80854: LD_INT 4
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: NEG
80865: PUSH
80866: LD_INT 5
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 2
80876: PUSH
80877: LD_INT 3
80879: NEG
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 2
80887: NEG
80888: PUSH
80889: LD_INT 5
80891: NEG
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80944: LD_ADDR_VAR 0 31
80948: PUSH
80949: LD_INT 0
80951: PUSH
80952: LD_INT 4
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 0
80961: PUSH
80962: LD_INT 3
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 1
80971: PUSH
80972: LD_INT 4
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 1
80981: PUSH
80982: LD_INT 5
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 0
80991: PUSH
80992: LD_INT 5
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 1
81001: NEG
81002: PUSH
81003: LD_INT 4
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 1
81012: NEG
81013: PUSH
81014: LD_INT 3
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 2
81023: PUSH
81024: LD_INT 5
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 2
81033: NEG
81034: PUSH
81035: LD_INT 3
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 3
81044: NEG
81045: PUSH
81046: LD_INT 0
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 3
81055: NEG
81056: PUSH
81057: LD_INT 1
81059: NEG
81060: PUSH
81061: EMPTY
81062: LIST
81063: LIST
81064: PUSH
81065: LD_INT 2
81067: NEG
81068: PUSH
81069: LD_INT 0
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 2
81078: NEG
81079: PUSH
81080: LD_INT 1
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: LD_INT 3
81089: NEG
81090: PUSH
81091: LD_INT 1
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 4
81100: NEG
81101: PUSH
81102: LD_INT 0
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: PUSH
81109: LD_INT 4
81111: NEG
81112: PUSH
81113: LD_INT 1
81115: NEG
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 4
81123: NEG
81124: PUSH
81125: LD_INT 2
81127: NEG
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 2
81135: NEG
81136: PUSH
81137: LD_INT 2
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PUSH
81144: LD_INT 4
81146: NEG
81147: PUSH
81148: LD_INT 4
81150: NEG
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 4
81158: NEG
81159: PUSH
81160: LD_INT 5
81162: NEG
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 3
81170: NEG
81171: PUSH
81172: LD_INT 4
81174: NEG
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 3
81182: NEG
81183: PUSH
81184: LD_INT 3
81186: NEG
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 4
81194: NEG
81195: PUSH
81196: LD_INT 3
81198: NEG
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 5
81206: NEG
81207: PUSH
81208: LD_INT 4
81210: NEG
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 5
81218: NEG
81219: PUSH
81220: LD_INT 5
81222: NEG
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 3
81230: NEG
81231: PUSH
81232: LD_INT 5
81234: NEG
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 5
81242: NEG
81243: PUSH
81244: LD_INT 3
81246: NEG
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 0
81254: PUSH
81255: LD_INT 3
81257: NEG
81258: PUSH
81259: EMPTY
81260: LIST
81261: LIST
81262: PUSH
81263: LD_INT 0
81265: PUSH
81266: LD_INT 4
81268: NEG
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 1
81276: PUSH
81277: LD_INT 3
81279: NEG
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 1
81287: PUSH
81288: LD_INT 2
81290: NEG
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 0
81298: PUSH
81299: LD_INT 2
81301: NEG
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 1
81309: NEG
81310: PUSH
81311: LD_INT 3
81313: NEG
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 1
81321: NEG
81322: PUSH
81323: LD_INT 4
81325: NEG
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 2
81333: PUSH
81334: LD_INT 2
81336: NEG
81337: PUSH
81338: EMPTY
81339: LIST
81340: LIST
81341: PUSH
81342: LD_INT 2
81344: NEG
81345: PUSH
81346: LD_INT 4
81348: NEG
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 4
81356: PUSH
81357: LD_INT 0
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: PUSH
81364: LD_INT 4
81366: PUSH
81367: LD_INT 1
81369: NEG
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: PUSH
81375: LD_INT 5
81377: PUSH
81378: LD_INT 0
81380: PUSH
81381: EMPTY
81382: LIST
81383: LIST
81384: PUSH
81385: LD_INT 5
81387: PUSH
81388: LD_INT 1
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 4
81397: PUSH
81398: LD_INT 1
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 3
81407: PUSH
81408: LD_INT 0
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 3
81417: PUSH
81418: LD_INT 1
81420: NEG
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 3
81428: PUSH
81429: LD_INT 2
81431: NEG
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 5
81439: PUSH
81440: LD_INT 2
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81494: LD_ADDR_VAR 0 32
81498: PUSH
81499: LD_INT 4
81501: NEG
81502: PUSH
81503: LD_INT 0
81505: PUSH
81506: EMPTY
81507: LIST
81508: LIST
81509: PUSH
81510: LD_INT 4
81512: NEG
81513: PUSH
81514: LD_INT 1
81516: NEG
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PUSH
81522: LD_INT 3
81524: NEG
81525: PUSH
81526: LD_INT 0
81528: PUSH
81529: EMPTY
81530: LIST
81531: LIST
81532: PUSH
81533: LD_INT 3
81535: NEG
81536: PUSH
81537: LD_INT 1
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: PUSH
81544: LD_INT 4
81546: NEG
81547: PUSH
81548: LD_INT 1
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 5
81557: NEG
81558: PUSH
81559: LD_INT 0
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PUSH
81566: LD_INT 5
81568: NEG
81569: PUSH
81570: LD_INT 1
81572: NEG
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PUSH
81578: LD_INT 5
81580: NEG
81581: PUSH
81582: LD_INT 2
81584: NEG
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 3
81592: NEG
81593: PUSH
81594: LD_INT 2
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 3
81603: NEG
81604: PUSH
81605: LD_INT 3
81607: NEG
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 3
81615: NEG
81616: PUSH
81617: LD_INT 4
81619: NEG
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: LD_INT 2
81627: NEG
81628: PUSH
81629: LD_INT 3
81631: NEG
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 2
81639: NEG
81640: PUSH
81641: LD_INT 2
81643: NEG
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 3
81651: NEG
81652: PUSH
81653: LD_INT 2
81655: NEG
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 4
81663: NEG
81664: PUSH
81665: LD_INT 3
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 4
81675: NEG
81676: PUSH
81677: LD_INT 4
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 2
81687: NEG
81688: PUSH
81689: LD_INT 4
81691: NEG
81692: PUSH
81693: EMPTY
81694: LIST
81695: LIST
81696: PUSH
81697: LD_INT 4
81699: NEG
81700: PUSH
81701: LD_INT 2
81703: NEG
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 0
81711: PUSH
81712: LD_INT 4
81714: NEG
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: PUSH
81720: LD_INT 0
81722: PUSH
81723: LD_INT 5
81725: NEG
81726: PUSH
81727: EMPTY
81728: LIST
81729: LIST
81730: PUSH
81731: LD_INT 1
81733: PUSH
81734: LD_INT 4
81736: NEG
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 1
81744: PUSH
81745: LD_INT 3
81747: NEG
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: LD_INT 0
81755: PUSH
81756: LD_INT 3
81758: NEG
81759: PUSH
81760: EMPTY
81761: LIST
81762: LIST
81763: PUSH
81764: LD_INT 1
81766: NEG
81767: PUSH
81768: LD_INT 4
81770: NEG
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 1
81778: NEG
81779: PUSH
81780: LD_INT 5
81782: NEG
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 2
81790: PUSH
81791: LD_INT 3
81793: NEG
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 2
81801: NEG
81802: PUSH
81803: LD_INT 5
81805: NEG
81806: PUSH
81807: EMPTY
81808: LIST
81809: LIST
81810: PUSH
81811: LD_INT 3
81813: PUSH
81814: LD_INT 0
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: PUSH
81821: LD_INT 3
81823: PUSH
81824: LD_INT 1
81826: NEG
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: LD_INT 4
81834: PUSH
81835: LD_INT 0
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 4
81844: PUSH
81845: LD_INT 1
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 3
81854: PUSH
81855: LD_INT 1
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 2
81864: PUSH
81865: LD_INT 0
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 2
81874: PUSH
81875: LD_INT 1
81877: NEG
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 2
81885: PUSH
81886: LD_INT 2
81888: NEG
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 4
81896: PUSH
81897: LD_INT 2
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 4
81906: PUSH
81907: LD_INT 4
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: LD_INT 4
81916: PUSH
81917: LD_INT 3
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: PUSH
81924: LD_INT 5
81926: PUSH
81927: LD_INT 4
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 5
81936: PUSH
81937: LD_INT 5
81939: PUSH
81940: EMPTY
81941: LIST
81942: LIST
81943: PUSH
81944: LD_INT 4
81946: PUSH
81947: LD_INT 5
81949: PUSH
81950: EMPTY
81951: LIST
81952: LIST
81953: PUSH
81954: LD_INT 3
81956: PUSH
81957: LD_INT 4
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 3
81966: PUSH
81967: LD_INT 3
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: PUSH
81974: LD_INT 5
81976: PUSH
81977: LD_INT 3
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: PUSH
81984: LD_INT 3
81986: PUSH
81987: LD_INT 5
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82041: LD_ADDR_VAR 0 33
82045: PUSH
82046: LD_INT 4
82048: NEG
82049: PUSH
82050: LD_INT 4
82052: NEG
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 4
82060: NEG
82061: PUSH
82062: LD_INT 5
82064: NEG
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 3
82072: NEG
82073: PUSH
82074: LD_INT 4
82076: NEG
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 3
82084: NEG
82085: PUSH
82086: LD_INT 3
82088: NEG
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PUSH
82094: LD_INT 4
82096: NEG
82097: PUSH
82098: LD_INT 3
82100: NEG
82101: PUSH
82102: EMPTY
82103: LIST
82104: LIST
82105: PUSH
82106: LD_INT 5
82108: NEG
82109: PUSH
82110: LD_INT 4
82112: NEG
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 5
82120: NEG
82121: PUSH
82122: LD_INT 5
82124: NEG
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 3
82132: NEG
82133: PUSH
82134: LD_INT 5
82136: NEG
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 5
82144: NEG
82145: PUSH
82146: LD_INT 3
82148: NEG
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 0
82156: PUSH
82157: LD_INT 3
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 0
82167: PUSH
82168: LD_INT 4
82170: NEG
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: PUSH
82176: LD_INT 1
82178: PUSH
82179: LD_INT 3
82181: NEG
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: PUSH
82187: LD_INT 1
82189: PUSH
82190: LD_INT 2
82192: NEG
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 0
82200: PUSH
82201: LD_INT 2
82203: NEG
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 1
82211: NEG
82212: PUSH
82213: LD_INT 3
82215: NEG
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 1
82223: NEG
82224: PUSH
82225: LD_INT 4
82227: NEG
82228: PUSH
82229: EMPTY
82230: LIST
82231: LIST
82232: PUSH
82233: LD_INT 2
82235: PUSH
82236: LD_INT 2
82238: NEG
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 2
82246: NEG
82247: PUSH
82248: LD_INT 4
82250: NEG
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PUSH
82256: LD_INT 4
82258: PUSH
82259: LD_INT 0
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 4
82268: PUSH
82269: LD_INT 1
82271: NEG
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 5
82279: PUSH
82280: LD_INT 0
82282: PUSH
82283: EMPTY
82284: LIST
82285: LIST
82286: PUSH
82287: LD_INT 5
82289: PUSH
82290: LD_INT 1
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PUSH
82297: LD_INT 4
82299: PUSH
82300: LD_INT 1
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: PUSH
82307: LD_INT 3
82309: PUSH
82310: LD_INT 0
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 3
82319: PUSH
82320: LD_INT 1
82322: NEG
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PUSH
82328: LD_INT 3
82330: PUSH
82331: LD_INT 2
82333: NEG
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PUSH
82339: LD_INT 5
82341: PUSH
82342: LD_INT 2
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 3
82351: PUSH
82352: LD_INT 3
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 3
82361: PUSH
82362: LD_INT 2
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: LD_INT 4
82371: PUSH
82372: LD_INT 3
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 4
82381: PUSH
82382: LD_INT 4
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: PUSH
82389: LD_INT 3
82391: PUSH
82392: LD_INT 4
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 2
82401: PUSH
82402: LD_INT 3
82404: PUSH
82405: EMPTY
82406: LIST
82407: LIST
82408: PUSH
82409: LD_INT 2
82411: PUSH
82412: LD_INT 2
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: PUSH
82419: LD_INT 4
82421: PUSH
82422: LD_INT 2
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 2
82431: PUSH
82432: LD_INT 4
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 0
82441: PUSH
82442: LD_INT 4
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 0
82451: PUSH
82452: LD_INT 3
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 1
82461: PUSH
82462: LD_INT 4
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 1
82471: PUSH
82472: LD_INT 5
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 0
82481: PUSH
82482: LD_INT 5
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 1
82491: NEG
82492: PUSH
82493: LD_INT 4
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 1
82502: NEG
82503: PUSH
82504: LD_INT 3
82506: PUSH
82507: EMPTY
82508: LIST
82509: LIST
82510: PUSH
82511: LD_INT 2
82513: PUSH
82514: LD_INT 5
82516: PUSH
82517: EMPTY
82518: LIST
82519: LIST
82520: PUSH
82521: LD_INT 2
82523: NEG
82524: PUSH
82525: LD_INT 3
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82579: LD_ADDR_VAR 0 34
82583: PUSH
82584: LD_INT 0
82586: PUSH
82587: LD_INT 4
82589: NEG
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 0
82597: PUSH
82598: LD_INT 5
82600: NEG
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 1
82608: PUSH
82609: LD_INT 4
82611: NEG
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 1
82619: PUSH
82620: LD_INT 3
82622: NEG
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 0
82630: PUSH
82631: LD_INT 3
82633: NEG
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 1
82641: NEG
82642: PUSH
82643: LD_INT 4
82645: NEG
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: PUSH
82651: LD_INT 1
82653: NEG
82654: PUSH
82655: LD_INT 5
82657: NEG
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: LD_INT 2
82665: PUSH
82666: LD_INT 3
82668: NEG
82669: PUSH
82670: EMPTY
82671: LIST
82672: LIST
82673: PUSH
82674: LD_INT 2
82676: NEG
82677: PUSH
82678: LD_INT 5
82680: NEG
82681: PUSH
82682: EMPTY
82683: LIST
82684: LIST
82685: PUSH
82686: LD_INT 3
82688: PUSH
82689: LD_INT 0
82691: PUSH
82692: EMPTY
82693: LIST
82694: LIST
82695: PUSH
82696: LD_INT 3
82698: PUSH
82699: LD_INT 1
82701: NEG
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 4
82709: PUSH
82710: LD_INT 0
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 4
82719: PUSH
82720: LD_INT 1
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 3
82729: PUSH
82730: LD_INT 1
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 2
82739: PUSH
82740: LD_INT 0
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: PUSH
82747: LD_INT 2
82749: PUSH
82750: LD_INT 1
82752: NEG
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: PUSH
82758: LD_INT 2
82760: PUSH
82761: LD_INT 2
82763: NEG
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 4
82771: PUSH
82772: LD_INT 2
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 4
82781: PUSH
82782: LD_INT 4
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 4
82791: PUSH
82792: LD_INT 3
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 5
82801: PUSH
82802: LD_INT 4
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 5
82811: PUSH
82812: LD_INT 5
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 4
82821: PUSH
82822: LD_INT 5
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 3
82831: PUSH
82832: LD_INT 4
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 3
82841: PUSH
82842: LD_INT 3
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 5
82851: PUSH
82852: LD_INT 3
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 3
82861: PUSH
82862: LD_INT 5
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 0
82871: PUSH
82872: LD_INT 3
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 0
82881: PUSH
82882: LD_INT 2
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 1
82891: PUSH
82892: LD_INT 3
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 1
82901: PUSH
82902: LD_INT 4
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: LD_INT 0
82911: PUSH
82912: LD_INT 4
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_INT 1
82921: NEG
82922: PUSH
82923: LD_INT 3
82925: PUSH
82926: EMPTY
82927: LIST
82928: LIST
82929: PUSH
82930: LD_INT 1
82932: NEG
82933: PUSH
82934: LD_INT 2
82936: PUSH
82937: EMPTY
82938: LIST
82939: LIST
82940: PUSH
82941: LD_INT 2
82943: PUSH
82944: LD_INT 4
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 2
82953: NEG
82954: PUSH
82955: LD_INT 2
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 4
82964: NEG
82965: PUSH
82966: LD_INT 0
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 4
82975: NEG
82976: PUSH
82977: LD_INT 1
82979: NEG
82980: PUSH
82981: EMPTY
82982: LIST
82983: LIST
82984: PUSH
82985: LD_INT 3
82987: NEG
82988: PUSH
82989: LD_INT 0
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: PUSH
82996: LD_INT 3
82998: NEG
82999: PUSH
83000: LD_INT 1
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: LD_INT 4
83009: NEG
83010: PUSH
83011: LD_INT 1
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: LD_INT 5
83020: NEG
83021: PUSH
83022: LD_INT 0
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 5
83031: NEG
83032: PUSH
83033: LD_INT 1
83035: NEG
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 5
83043: NEG
83044: PUSH
83045: LD_INT 2
83047: NEG
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 3
83055: NEG
83056: PUSH
83057: LD_INT 2
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: ST_TO_ADDR
// end ; end ;
83111: GO 83114
83113: POP
// case btype of b_depot , b_warehouse :
83114: LD_VAR 0 1
83118: PUSH
83119: LD_INT 0
83121: DOUBLE
83122: EQUAL
83123: IFTRUE 83133
83125: LD_INT 1
83127: DOUBLE
83128: EQUAL
83129: IFTRUE 83133
83131: GO 83334
83133: POP
// case nation of nation_american :
83134: LD_VAR 0 5
83138: PUSH
83139: LD_INT 1
83141: DOUBLE
83142: EQUAL
83143: IFTRUE 83147
83145: GO 83203
83147: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83148: LD_ADDR_VAR 0 9
83152: PUSH
83153: LD_VAR 0 11
83157: PUSH
83158: LD_VAR 0 12
83162: PUSH
83163: LD_VAR 0 13
83167: PUSH
83168: LD_VAR 0 14
83172: PUSH
83173: LD_VAR 0 15
83177: PUSH
83178: LD_VAR 0 16
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: LIST
83189: LIST
83190: PUSH
83191: LD_VAR 0 4
83195: PUSH
83196: LD_INT 1
83198: PLUS
83199: ARRAY
83200: ST_TO_ADDR
83201: GO 83332
83203: LD_INT 2
83205: DOUBLE
83206: EQUAL
83207: IFTRUE 83211
83209: GO 83267
83211: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83212: LD_ADDR_VAR 0 9
83216: PUSH
83217: LD_VAR 0 17
83221: PUSH
83222: LD_VAR 0 18
83226: PUSH
83227: LD_VAR 0 19
83231: PUSH
83232: LD_VAR 0 20
83236: PUSH
83237: LD_VAR 0 21
83241: PUSH
83242: LD_VAR 0 22
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: PUSH
83255: LD_VAR 0 4
83259: PUSH
83260: LD_INT 1
83262: PLUS
83263: ARRAY
83264: ST_TO_ADDR
83265: GO 83332
83267: LD_INT 3
83269: DOUBLE
83270: EQUAL
83271: IFTRUE 83275
83273: GO 83331
83275: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83276: LD_ADDR_VAR 0 9
83280: PUSH
83281: LD_VAR 0 23
83285: PUSH
83286: LD_VAR 0 24
83290: PUSH
83291: LD_VAR 0 25
83295: PUSH
83296: LD_VAR 0 26
83300: PUSH
83301: LD_VAR 0 27
83305: PUSH
83306: LD_VAR 0 28
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: LIST
83315: LIST
83316: LIST
83317: LIST
83318: PUSH
83319: LD_VAR 0 4
83323: PUSH
83324: LD_INT 1
83326: PLUS
83327: ARRAY
83328: ST_TO_ADDR
83329: GO 83332
83331: POP
83332: GO 83887
83334: LD_INT 2
83336: DOUBLE
83337: EQUAL
83338: IFTRUE 83348
83340: LD_INT 3
83342: DOUBLE
83343: EQUAL
83344: IFTRUE 83348
83346: GO 83404
83348: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83349: LD_ADDR_VAR 0 9
83353: PUSH
83354: LD_VAR 0 29
83358: PUSH
83359: LD_VAR 0 30
83363: PUSH
83364: LD_VAR 0 31
83368: PUSH
83369: LD_VAR 0 32
83373: PUSH
83374: LD_VAR 0 33
83378: PUSH
83379: LD_VAR 0 34
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: PUSH
83392: LD_VAR 0 4
83396: PUSH
83397: LD_INT 1
83399: PLUS
83400: ARRAY
83401: ST_TO_ADDR
83402: GO 83887
83404: LD_INT 16
83406: DOUBLE
83407: EQUAL
83408: IFTRUE 83466
83410: LD_INT 17
83412: DOUBLE
83413: EQUAL
83414: IFTRUE 83466
83416: LD_INT 18
83418: DOUBLE
83419: EQUAL
83420: IFTRUE 83466
83422: LD_INT 19
83424: DOUBLE
83425: EQUAL
83426: IFTRUE 83466
83428: LD_INT 22
83430: DOUBLE
83431: EQUAL
83432: IFTRUE 83466
83434: LD_INT 20
83436: DOUBLE
83437: EQUAL
83438: IFTRUE 83466
83440: LD_INT 21
83442: DOUBLE
83443: EQUAL
83444: IFTRUE 83466
83446: LD_INT 23
83448: DOUBLE
83449: EQUAL
83450: IFTRUE 83466
83452: LD_INT 24
83454: DOUBLE
83455: EQUAL
83456: IFTRUE 83466
83458: LD_INT 25
83460: DOUBLE
83461: EQUAL
83462: IFTRUE 83466
83464: GO 83522
83466: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83467: LD_ADDR_VAR 0 9
83471: PUSH
83472: LD_VAR 0 35
83476: PUSH
83477: LD_VAR 0 36
83481: PUSH
83482: LD_VAR 0 37
83486: PUSH
83487: LD_VAR 0 38
83491: PUSH
83492: LD_VAR 0 39
83496: PUSH
83497: LD_VAR 0 40
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: LIST
83506: LIST
83507: LIST
83508: LIST
83509: PUSH
83510: LD_VAR 0 4
83514: PUSH
83515: LD_INT 1
83517: PLUS
83518: ARRAY
83519: ST_TO_ADDR
83520: GO 83887
83522: LD_INT 6
83524: DOUBLE
83525: EQUAL
83526: IFTRUE 83578
83528: LD_INT 7
83530: DOUBLE
83531: EQUAL
83532: IFTRUE 83578
83534: LD_INT 8
83536: DOUBLE
83537: EQUAL
83538: IFTRUE 83578
83540: LD_INT 13
83542: DOUBLE
83543: EQUAL
83544: IFTRUE 83578
83546: LD_INT 12
83548: DOUBLE
83549: EQUAL
83550: IFTRUE 83578
83552: LD_INT 15
83554: DOUBLE
83555: EQUAL
83556: IFTRUE 83578
83558: LD_INT 11
83560: DOUBLE
83561: EQUAL
83562: IFTRUE 83578
83564: LD_INT 14
83566: DOUBLE
83567: EQUAL
83568: IFTRUE 83578
83570: LD_INT 10
83572: DOUBLE
83573: EQUAL
83574: IFTRUE 83578
83576: GO 83634
83578: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
83579: LD_ADDR_VAR 0 9
83583: PUSH
83584: LD_VAR 0 41
83588: PUSH
83589: LD_VAR 0 42
83593: PUSH
83594: LD_VAR 0 43
83598: PUSH
83599: LD_VAR 0 44
83603: PUSH
83604: LD_VAR 0 45
83608: PUSH
83609: LD_VAR 0 46
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: PUSH
83622: LD_VAR 0 4
83626: PUSH
83627: LD_INT 1
83629: PLUS
83630: ARRAY
83631: ST_TO_ADDR
83632: GO 83887
83634: LD_INT 36
83636: DOUBLE
83637: EQUAL
83638: IFTRUE 83642
83640: GO 83698
83642: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83643: LD_ADDR_VAR 0 9
83647: PUSH
83648: LD_VAR 0 47
83652: PUSH
83653: LD_VAR 0 48
83657: PUSH
83658: LD_VAR 0 49
83662: PUSH
83663: LD_VAR 0 50
83667: PUSH
83668: LD_VAR 0 51
83672: PUSH
83673: LD_VAR 0 52
83677: PUSH
83678: EMPTY
83679: LIST
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: LIST
83685: PUSH
83686: LD_VAR 0 4
83690: PUSH
83691: LD_INT 1
83693: PLUS
83694: ARRAY
83695: ST_TO_ADDR
83696: GO 83887
83698: LD_INT 4
83700: DOUBLE
83701: EQUAL
83702: IFTRUE 83724
83704: LD_INT 5
83706: DOUBLE
83707: EQUAL
83708: IFTRUE 83724
83710: LD_INT 34
83712: DOUBLE
83713: EQUAL
83714: IFTRUE 83724
83716: LD_INT 37
83718: DOUBLE
83719: EQUAL
83720: IFTRUE 83724
83722: GO 83780
83724: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83725: LD_ADDR_VAR 0 9
83729: PUSH
83730: LD_VAR 0 53
83734: PUSH
83735: LD_VAR 0 54
83739: PUSH
83740: LD_VAR 0 55
83744: PUSH
83745: LD_VAR 0 56
83749: PUSH
83750: LD_VAR 0 57
83754: PUSH
83755: LD_VAR 0 58
83759: PUSH
83760: EMPTY
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: LIST
83767: PUSH
83768: LD_VAR 0 4
83772: PUSH
83773: LD_INT 1
83775: PLUS
83776: ARRAY
83777: ST_TO_ADDR
83778: GO 83887
83780: LD_INT 31
83782: DOUBLE
83783: EQUAL
83784: IFTRUE 83830
83786: LD_INT 32
83788: DOUBLE
83789: EQUAL
83790: IFTRUE 83830
83792: LD_INT 33
83794: DOUBLE
83795: EQUAL
83796: IFTRUE 83830
83798: LD_INT 27
83800: DOUBLE
83801: EQUAL
83802: IFTRUE 83830
83804: LD_INT 26
83806: DOUBLE
83807: EQUAL
83808: IFTRUE 83830
83810: LD_INT 28
83812: DOUBLE
83813: EQUAL
83814: IFTRUE 83830
83816: LD_INT 29
83818: DOUBLE
83819: EQUAL
83820: IFTRUE 83830
83822: LD_INT 30
83824: DOUBLE
83825: EQUAL
83826: IFTRUE 83830
83828: GO 83886
83830: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
83831: LD_ADDR_VAR 0 9
83835: PUSH
83836: LD_VAR 0 59
83840: PUSH
83841: LD_VAR 0 60
83845: PUSH
83846: LD_VAR 0 61
83850: PUSH
83851: LD_VAR 0 62
83855: PUSH
83856: LD_VAR 0 63
83860: PUSH
83861: LD_VAR 0 64
83865: PUSH
83866: EMPTY
83867: LIST
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: LIST
83873: PUSH
83874: LD_VAR 0 4
83878: PUSH
83879: LD_INT 1
83881: PLUS
83882: ARRAY
83883: ST_TO_ADDR
83884: GO 83887
83886: POP
// temp_list2 = [ ] ;
83887: LD_ADDR_VAR 0 10
83891: PUSH
83892: EMPTY
83893: ST_TO_ADDR
// for i in temp_list do
83894: LD_ADDR_VAR 0 8
83898: PUSH
83899: LD_VAR 0 9
83903: PUSH
83904: FOR_IN
83905: IFFALSE 83957
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
83907: LD_ADDR_VAR 0 10
83911: PUSH
83912: LD_VAR 0 10
83916: PUSH
83917: LD_VAR 0 8
83921: PUSH
83922: LD_INT 1
83924: ARRAY
83925: PUSH
83926: LD_VAR 0 2
83930: PLUS
83931: PUSH
83932: LD_VAR 0 8
83936: PUSH
83937: LD_INT 2
83939: ARRAY
83940: PUSH
83941: LD_VAR 0 3
83945: PLUS
83946: PUSH
83947: EMPTY
83948: LIST
83949: LIST
83950: PUSH
83951: EMPTY
83952: LIST
83953: ADD
83954: ST_TO_ADDR
83955: GO 83904
83957: POP
83958: POP
// result = temp_list2 ;
83959: LD_ADDR_VAR 0 7
83963: PUSH
83964: LD_VAR 0 10
83968: ST_TO_ADDR
// end ;
83969: LD_VAR 0 7
83973: RET
// export function EnemyInRange ( unit , dist ) ; begin
83974: LD_INT 0
83976: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83977: LD_ADDR_VAR 0 3
83981: PUSH
83982: LD_VAR 0 1
83986: PPUSH
83987: CALL_OW 255
83991: PPUSH
83992: LD_VAR 0 1
83996: PPUSH
83997: CALL_OW 250
84001: PPUSH
84002: LD_VAR 0 1
84006: PPUSH
84007: CALL_OW 251
84011: PPUSH
84012: LD_VAR 0 2
84016: PPUSH
84017: CALL 57370 0 4
84021: PUSH
84022: LD_INT 4
84024: ARRAY
84025: ST_TO_ADDR
// end ;
84026: LD_VAR 0 3
84030: RET
// export function PlayerSeeMe ( unit ) ; begin
84031: LD_INT 0
84033: PPUSH
// result := See ( your_side , unit ) ;
84034: LD_ADDR_VAR 0 2
84038: PUSH
84039: LD_OWVAR 2
84043: PPUSH
84044: LD_VAR 0 1
84048: PPUSH
84049: CALL_OW 292
84053: ST_TO_ADDR
// end ;
84054: LD_VAR 0 2
84058: RET
// export function ReverseDir ( unit ) ; begin
84059: LD_INT 0
84061: PPUSH
// if not unit then
84062: LD_VAR 0 1
84066: NOT
84067: IFFALSE 84071
// exit ;
84069: GO 84094
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84071: LD_ADDR_VAR 0 2
84075: PUSH
84076: LD_VAR 0 1
84080: PPUSH
84081: CALL_OW 254
84085: PUSH
84086: LD_INT 3
84088: PLUS
84089: PUSH
84090: LD_INT 6
84092: MOD
84093: ST_TO_ADDR
// end ;
84094: LD_VAR 0 2
84098: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84099: LD_INT 0
84101: PPUSH
84102: PPUSH
84103: PPUSH
84104: PPUSH
84105: PPUSH
// if not hexes then
84106: LD_VAR 0 2
84110: NOT
84111: IFFALSE 84115
// exit ;
84113: GO 84263
// dist := 9999 ;
84115: LD_ADDR_VAR 0 5
84119: PUSH
84120: LD_INT 9999
84122: ST_TO_ADDR
// for i = 1 to hexes do
84123: LD_ADDR_VAR 0 4
84127: PUSH
84128: DOUBLE
84129: LD_INT 1
84131: DEC
84132: ST_TO_ADDR
84133: LD_VAR 0 2
84137: PUSH
84138: FOR_TO
84139: IFFALSE 84251
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84141: LD_VAR 0 1
84145: PPUSH
84146: LD_VAR 0 2
84150: PUSH
84151: LD_VAR 0 4
84155: ARRAY
84156: PUSH
84157: LD_INT 1
84159: ARRAY
84160: PPUSH
84161: LD_VAR 0 2
84165: PUSH
84166: LD_VAR 0 4
84170: ARRAY
84171: PUSH
84172: LD_INT 2
84174: ARRAY
84175: PPUSH
84176: CALL_OW 297
84180: PUSH
84181: LD_VAR 0 5
84185: LESS
84186: IFFALSE 84249
// begin hex := hexes [ i ] ;
84188: LD_ADDR_VAR 0 7
84192: PUSH
84193: LD_VAR 0 2
84197: PUSH
84198: LD_VAR 0 4
84202: ARRAY
84203: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84204: LD_ADDR_VAR 0 5
84208: PUSH
84209: LD_VAR 0 1
84213: PPUSH
84214: LD_VAR 0 2
84218: PUSH
84219: LD_VAR 0 4
84223: ARRAY
84224: PUSH
84225: LD_INT 1
84227: ARRAY
84228: PPUSH
84229: LD_VAR 0 2
84233: PUSH
84234: LD_VAR 0 4
84238: ARRAY
84239: PUSH
84240: LD_INT 2
84242: ARRAY
84243: PPUSH
84244: CALL_OW 297
84248: ST_TO_ADDR
// end ; end ;
84249: GO 84138
84251: POP
84252: POP
// result := hex ;
84253: LD_ADDR_VAR 0 3
84257: PUSH
84258: LD_VAR 0 7
84262: ST_TO_ADDR
// end ;
84263: LD_VAR 0 3
84267: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84268: LD_INT 0
84270: PPUSH
84271: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84272: LD_VAR 0 1
84276: NOT
84277: PUSH
84278: LD_VAR 0 1
84282: PUSH
84283: LD_INT 21
84285: PUSH
84286: LD_INT 2
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 23
84295: PUSH
84296: LD_INT 2
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PPUSH
84307: CALL_OW 69
84311: IN
84312: NOT
84313: OR
84314: IFFALSE 84318
// exit ;
84316: GO 84365
// for i = 1 to 3 do
84318: LD_ADDR_VAR 0 3
84322: PUSH
84323: DOUBLE
84324: LD_INT 1
84326: DEC
84327: ST_TO_ADDR
84328: LD_INT 3
84330: PUSH
84331: FOR_TO
84332: IFFALSE 84363
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84334: LD_VAR 0 1
84338: PPUSH
84339: CALL_OW 250
84343: PPUSH
84344: LD_VAR 0 1
84348: PPUSH
84349: CALL_OW 251
84353: PPUSH
84354: LD_INT 1
84356: PPUSH
84357: CALL_OW 453
84361: GO 84331
84363: POP
84364: POP
// end ;
84365: LD_VAR 0 2
84369: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84370: LD_INT 0
84372: PPUSH
84373: PPUSH
84374: PPUSH
84375: PPUSH
84376: PPUSH
84377: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84378: LD_VAR 0 1
84382: NOT
84383: PUSH
84384: LD_VAR 0 2
84388: NOT
84389: OR
84390: PUSH
84391: LD_VAR 0 1
84395: PPUSH
84396: CALL_OW 314
84400: OR
84401: IFFALSE 84405
// exit ;
84403: GO 84846
// x := GetX ( enemy_unit ) ;
84405: LD_ADDR_VAR 0 7
84409: PUSH
84410: LD_VAR 0 2
84414: PPUSH
84415: CALL_OW 250
84419: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84420: LD_ADDR_VAR 0 8
84424: PUSH
84425: LD_VAR 0 2
84429: PPUSH
84430: CALL_OW 251
84434: ST_TO_ADDR
// if not x or not y then
84435: LD_VAR 0 7
84439: NOT
84440: PUSH
84441: LD_VAR 0 8
84445: NOT
84446: OR
84447: IFFALSE 84451
// exit ;
84449: GO 84846
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84451: LD_ADDR_VAR 0 6
84455: PUSH
84456: LD_VAR 0 7
84460: PPUSH
84461: LD_INT 0
84463: PPUSH
84464: LD_INT 4
84466: PPUSH
84467: CALL_OW 272
84471: PUSH
84472: LD_VAR 0 8
84476: PPUSH
84477: LD_INT 0
84479: PPUSH
84480: LD_INT 4
84482: PPUSH
84483: CALL_OW 273
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: PUSH
84492: LD_VAR 0 7
84496: PPUSH
84497: LD_INT 1
84499: PPUSH
84500: LD_INT 4
84502: PPUSH
84503: CALL_OW 272
84507: PUSH
84508: LD_VAR 0 8
84512: PPUSH
84513: LD_INT 1
84515: PPUSH
84516: LD_INT 4
84518: PPUSH
84519: CALL_OW 273
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PUSH
84528: LD_VAR 0 7
84532: PPUSH
84533: LD_INT 2
84535: PPUSH
84536: LD_INT 4
84538: PPUSH
84539: CALL_OW 272
84543: PUSH
84544: LD_VAR 0 8
84548: PPUSH
84549: LD_INT 2
84551: PPUSH
84552: LD_INT 4
84554: PPUSH
84555: CALL_OW 273
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: PUSH
84564: LD_VAR 0 7
84568: PPUSH
84569: LD_INT 3
84571: PPUSH
84572: LD_INT 4
84574: PPUSH
84575: CALL_OW 272
84579: PUSH
84580: LD_VAR 0 8
84584: PPUSH
84585: LD_INT 3
84587: PPUSH
84588: LD_INT 4
84590: PPUSH
84591: CALL_OW 273
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: PUSH
84600: LD_VAR 0 7
84604: PPUSH
84605: LD_INT 4
84607: PPUSH
84608: LD_INT 4
84610: PPUSH
84611: CALL_OW 272
84615: PUSH
84616: LD_VAR 0 8
84620: PPUSH
84621: LD_INT 4
84623: PPUSH
84624: LD_INT 4
84626: PPUSH
84627: CALL_OW 273
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: LD_VAR 0 7
84640: PPUSH
84641: LD_INT 5
84643: PPUSH
84644: LD_INT 4
84646: PPUSH
84647: CALL_OW 272
84651: PUSH
84652: LD_VAR 0 8
84656: PPUSH
84657: LD_INT 5
84659: PPUSH
84660: LD_INT 4
84662: PPUSH
84663: CALL_OW 273
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: ST_TO_ADDR
// for i = tmp downto 1 do
84680: LD_ADDR_VAR 0 4
84684: PUSH
84685: DOUBLE
84686: LD_VAR 0 6
84690: INC
84691: ST_TO_ADDR
84692: LD_INT 1
84694: PUSH
84695: FOR_DOWNTO
84696: IFFALSE 84797
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84698: LD_VAR 0 6
84702: PUSH
84703: LD_VAR 0 4
84707: ARRAY
84708: PUSH
84709: LD_INT 1
84711: ARRAY
84712: PPUSH
84713: LD_VAR 0 6
84717: PUSH
84718: LD_VAR 0 4
84722: ARRAY
84723: PUSH
84724: LD_INT 2
84726: ARRAY
84727: PPUSH
84728: CALL_OW 488
84732: NOT
84733: PUSH
84734: LD_VAR 0 6
84738: PUSH
84739: LD_VAR 0 4
84743: ARRAY
84744: PUSH
84745: LD_INT 1
84747: ARRAY
84748: PPUSH
84749: LD_VAR 0 6
84753: PUSH
84754: LD_VAR 0 4
84758: ARRAY
84759: PUSH
84760: LD_INT 2
84762: ARRAY
84763: PPUSH
84764: CALL_OW 428
84768: PUSH
84769: LD_INT 0
84771: NONEQUAL
84772: OR
84773: IFFALSE 84795
// tmp := Delete ( tmp , i ) ;
84775: LD_ADDR_VAR 0 6
84779: PUSH
84780: LD_VAR 0 6
84784: PPUSH
84785: LD_VAR 0 4
84789: PPUSH
84790: CALL_OW 3
84794: ST_TO_ADDR
84795: GO 84695
84797: POP
84798: POP
// j := GetClosestHex ( unit , tmp ) ;
84799: LD_ADDR_VAR 0 5
84803: PUSH
84804: LD_VAR 0 1
84808: PPUSH
84809: LD_VAR 0 6
84813: PPUSH
84814: CALL 84099 0 2
84818: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
84819: LD_VAR 0 1
84823: PPUSH
84824: LD_VAR 0 5
84828: PUSH
84829: LD_INT 1
84831: ARRAY
84832: PPUSH
84833: LD_VAR 0 5
84837: PUSH
84838: LD_INT 2
84840: ARRAY
84841: PPUSH
84842: CALL_OW 111
// end ;
84846: LD_VAR 0 3
84850: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84851: LD_INT 0
84853: PPUSH
84854: PPUSH
84855: PPUSH
// uc_side = 0 ;
84856: LD_ADDR_OWVAR 20
84860: PUSH
84861: LD_INT 0
84863: ST_TO_ADDR
// uc_nation = 0 ;
84864: LD_ADDR_OWVAR 21
84868: PUSH
84869: LD_INT 0
84871: ST_TO_ADDR
// InitHc_All ( ) ;
84872: CALL_OW 584
// InitVc ;
84876: CALL_OW 20
// if mastodonts then
84880: LD_VAR 0 6
84884: IFFALSE 84951
// for i = 1 to mastodonts do
84886: LD_ADDR_VAR 0 11
84890: PUSH
84891: DOUBLE
84892: LD_INT 1
84894: DEC
84895: ST_TO_ADDR
84896: LD_VAR 0 6
84900: PUSH
84901: FOR_TO
84902: IFFALSE 84949
// begin vc_chassis := 31 ;
84904: LD_ADDR_OWVAR 37
84908: PUSH
84909: LD_INT 31
84911: ST_TO_ADDR
// vc_control := control_rider ;
84912: LD_ADDR_OWVAR 38
84916: PUSH
84917: LD_INT 4
84919: ST_TO_ADDR
// animal := CreateVehicle ;
84920: LD_ADDR_VAR 0 12
84924: PUSH
84925: CALL_OW 45
84929: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84930: LD_VAR 0 12
84934: PPUSH
84935: LD_VAR 0 8
84939: PPUSH
84940: LD_INT 0
84942: PPUSH
84943: CALL 87139 0 3
// end ;
84947: GO 84901
84949: POP
84950: POP
// if horses then
84951: LD_VAR 0 5
84955: IFFALSE 85022
// for i = 1 to horses do
84957: LD_ADDR_VAR 0 11
84961: PUSH
84962: DOUBLE
84963: LD_INT 1
84965: DEC
84966: ST_TO_ADDR
84967: LD_VAR 0 5
84971: PUSH
84972: FOR_TO
84973: IFFALSE 85020
// begin hc_class := 21 ;
84975: LD_ADDR_OWVAR 28
84979: PUSH
84980: LD_INT 21
84982: ST_TO_ADDR
// hc_gallery :=  ;
84983: LD_ADDR_OWVAR 33
84987: PUSH
84988: LD_STRING 
84990: ST_TO_ADDR
// animal := CreateHuman ;
84991: LD_ADDR_VAR 0 12
84995: PUSH
84996: CALL_OW 44
85000: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85001: LD_VAR 0 12
85005: PPUSH
85006: LD_VAR 0 8
85010: PPUSH
85011: LD_INT 0
85013: PPUSH
85014: CALL 87139 0 3
// end ;
85018: GO 84972
85020: POP
85021: POP
// if birds then
85022: LD_VAR 0 1
85026: IFFALSE 85093
// for i = 1 to birds do
85028: LD_ADDR_VAR 0 11
85032: PUSH
85033: DOUBLE
85034: LD_INT 1
85036: DEC
85037: ST_TO_ADDR
85038: LD_VAR 0 1
85042: PUSH
85043: FOR_TO
85044: IFFALSE 85091
// begin hc_class = 18 ;
85046: LD_ADDR_OWVAR 28
85050: PUSH
85051: LD_INT 18
85053: ST_TO_ADDR
// hc_gallery =  ;
85054: LD_ADDR_OWVAR 33
85058: PUSH
85059: LD_STRING 
85061: ST_TO_ADDR
// animal := CreateHuman ;
85062: LD_ADDR_VAR 0 12
85066: PUSH
85067: CALL_OW 44
85071: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85072: LD_VAR 0 12
85076: PPUSH
85077: LD_VAR 0 8
85081: PPUSH
85082: LD_INT 0
85084: PPUSH
85085: CALL 87139 0 3
// end ;
85089: GO 85043
85091: POP
85092: POP
// if tigers then
85093: LD_VAR 0 2
85097: IFFALSE 85181
// for i = 1 to tigers do
85099: LD_ADDR_VAR 0 11
85103: PUSH
85104: DOUBLE
85105: LD_INT 1
85107: DEC
85108: ST_TO_ADDR
85109: LD_VAR 0 2
85113: PUSH
85114: FOR_TO
85115: IFFALSE 85179
// begin hc_class = class_tiger ;
85117: LD_ADDR_OWVAR 28
85121: PUSH
85122: LD_INT 14
85124: ST_TO_ADDR
// hc_gallery =  ;
85125: LD_ADDR_OWVAR 33
85129: PUSH
85130: LD_STRING 
85132: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85133: LD_ADDR_OWVAR 35
85137: PUSH
85138: LD_INT 7
85140: NEG
85141: PPUSH
85142: LD_INT 7
85144: PPUSH
85145: CALL_OW 12
85149: ST_TO_ADDR
// animal := CreateHuman ;
85150: LD_ADDR_VAR 0 12
85154: PUSH
85155: CALL_OW 44
85159: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85160: LD_VAR 0 12
85164: PPUSH
85165: LD_VAR 0 8
85169: PPUSH
85170: LD_INT 0
85172: PPUSH
85173: CALL 87139 0 3
// end ;
85177: GO 85114
85179: POP
85180: POP
// if apemans then
85181: LD_VAR 0 3
85185: IFFALSE 85308
// for i = 1 to apemans do
85187: LD_ADDR_VAR 0 11
85191: PUSH
85192: DOUBLE
85193: LD_INT 1
85195: DEC
85196: ST_TO_ADDR
85197: LD_VAR 0 3
85201: PUSH
85202: FOR_TO
85203: IFFALSE 85306
// begin hc_class = class_apeman ;
85205: LD_ADDR_OWVAR 28
85209: PUSH
85210: LD_INT 12
85212: ST_TO_ADDR
// hc_gallery =  ;
85213: LD_ADDR_OWVAR 33
85217: PUSH
85218: LD_STRING 
85220: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
85221: LD_ADDR_OWVAR 35
85225: PUSH
85226: LD_INT 2
85228: NEG
85229: PPUSH
85230: LD_INT 2
85232: PPUSH
85233: CALL_OW 12
85237: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85238: LD_ADDR_OWVAR 31
85242: PUSH
85243: LD_INT 1
85245: PPUSH
85246: LD_INT 3
85248: PPUSH
85249: CALL_OW 12
85253: PUSH
85254: LD_INT 1
85256: PPUSH
85257: LD_INT 3
85259: PPUSH
85260: CALL_OW 12
85264: PUSH
85265: LD_INT 0
85267: PUSH
85268: LD_INT 0
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: LIST
85275: LIST
85276: ST_TO_ADDR
// animal := CreateHuman ;
85277: LD_ADDR_VAR 0 12
85281: PUSH
85282: CALL_OW 44
85286: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85287: LD_VAR 0 12
85291: PPUSH
85292: LD_VAR 0 8
85296: PPUSH
85297: LD_INT 0
85299: PPUSH
85300: CALL 87139 0 3
// end ;
85304: GO 85202
85306: POP
85307: POP
// if enchidnas then
85308: LD_VAR 0 4
85312: IFFALSE 85379
// for i = 1 to enchidnas do
85314: LD_ADDR_VAR 0 11
85318: PUSH
85319: DOUBLE
85320: LD_INT 1
85322: DEC
85323: ST_TO_ADDR
85324: LD_VAR 0 4
85328: PUSH
85329: FOR_TO
85330: IFFALSE 85377
// begin hc_class = 13 ;
85332: LD_ADDR_OWVAR 28
85336: PUSH
85337: LD_INT 13
85339: ST_TO_ADDR
// hc_gallery =  ;
85340: LD_ADDR_OWVAR 33
85344: PUSH
85345: LD_STRING 
85347: ST_TO_ADDR
// animal := CreateHuman ;
85348: LD_ADDR_VAR 0 12
85352: PUSH
85353: CALL_OW 44
85357: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85358: LD_VAR 0 12
85362: PPUSH
85363: LD_VAR 0 8
85367: PPUSH
85368: LD_INT 0
85370: PPUSH
85371: CALL 87139 0 3
// end ;
85375: GO 85329
85377: POP
85378: POP
// if fishes then
85379: LD_VAR 0 7
85383: IFFALSE 85450
// for i = 1 to fishes do
85385: LD_ADDR_VAR 0 11
85389: PUSH
85390: DOUBLE
85391: LD_INT 1
85393: DEC
85394: ST_TO_ADDR
85395: LD_VAR 0 7
85399: PUSH
85400: FOR_TO
85401: IFFALSE 85448
// begin hc_class = 20 ;
85403: LD_ADDR_OWVAR 28
85407: PUSH
85408: LD_INT 20
85410: ST_TO_ADDR
// hc_gallery =  ;
85411: LD_ADDR_OWVAR 33
85415: PUSH
85416: LD_STRING 
85418: ST_TO_ADDR
// animal := CreateHuman ;
85419: LD_ADDR_VAR 0 12
85423: PUSH
85424: CALL_OW 44
85428: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85429: LD_VAR 0 12
85433: PPUSH
85434: LD_VAR 0 9
85438: PPUSH
85439: LD_INT 0
85441: PPUSH
85442: CALL 87139 0 3
// end ;
85446: GO 85400
85448: POP
85449: POP
// end ;
85450: LD_VAR 0 10
85454: RET
// export function WantHeal ( sci , unit ) ; begin
85455: LD_INT 0
85457: PPUSH
// if GetTaskList ( sci ) > 0 then
85458: LD_VAR 0 1
85462: PPUSH
85463: CALL_OW 437
85467: PUSH
85468: LD_INT 0
85470: GREATER
85471: IFFALSE 85541
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85473: LD_VAR 0 1
85477: PPUSH
85478: CALL_OW 437
85482: PUSH
85483: LD_INT 1
85485: ARRAY
85486: PUSH
85487: LD_INT 1
85489: ARRAY
85490: PUSH
85491: LD_STRING l
85493: EQUAL
85494: PUSH
85495: LD_VAR 0 1
85499: PPUSH
85500: CALL_OW 437
85504: PUSH
85505: LD_INT 1
85507: ARRAY
85508: PUSH
85509: LD_INT 4
85511: ARRAY
85512: PUSH
85513: LD_VAR 0 2
85517: EQUAL
85518: AND
85519: IFFALSE 85531
// result := true else
85521: LD_ADDR_VAR 0 3
85525: PUSH
85526: LD_INT 1
85528: ST_TO_ADDR
85529: GO 85539
// result := false ;
85531: LD_ADDR_VAR 0 3
85535: PUSH
85536: LD_INT 0
85538: ST_TO_ADDR
// end else
85539: GO 85549
// result := false ;
85541: LD_ADDR_VAR 0 3
85545: PUSH
85546: LD_INT 0
85548: ST_TO_ADDR
// end ;
85549: LD_VAR 0 3
85553: RET
// export function HealTarget ( sci ) ; begin
85554: LD_INT 0
85556: PPUSH
// if not sci then
85557: LD_VAR 0 1
85561: NOT
85562: IFFALSE 85566
// exit ;
85564: GO 85631
// result := 0 ;
85566: LD_ADDR_VAR 0 2
85570: PUSH
85571: LD_INT 0
85573: ST_TO_ADDR
// if GetTaskList ( sci ) then
85574: LD_VAR 0 1
85578: PPUSH
85579: CALL_OW 437
85583: IFFALSE 85631
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85585: LD_VAR 0 1
85589: PPUSH
85590: CALL_OW 437
85594: PUSH
85595: LD_INT 1
85597: ARRAY
85598: PUSH
85599: LD_INT 1
85601: ARRAY
85602: PUSH
85603: LD_STRING l
85605: EQUAL
85606: IFFALSE 85631
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85608: LD_ADDR_VAR 0 2
85612: PUSH
85613: LD_VAR 0 1
85617: PPUSH
85618: CALL_OW 437
85622: PUSH
85623: LD_INT 1
85625: ARRAY
85626: PUSH
85627: LD_INT 4
85629: ARRAY
85630: ST_TO_ADDR
// end ;
85631: LD_VAR 0 2
85635: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
85636: LD_INT 0
85638: PPUSH
85639: PPUSH
85640: PPUSH
85641: PPUSH
// if not base_units then
85642: LD_VAR 0 1
85646: NOT
85647: IFFALSE 85651
// exit ;
85649: GO 85738
// result := false ;
85651: LD_ADDR_VAR 0 2
85655: PUSH
85656: LD_INT 0
85658: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
85659: LD_ADDR_VAR 0 5
85663: PUSH
85664: LD_VAR 0 1
85668: PPUSH
85669: LD_INT 21
85671: PUSH
85672: LD_INT 3
85674: PUSH
85675: EMPTY
85676: LIST
85677: LIST
85678: PPUSH
85679: CALL_OW 72
85683: ST_TO_ADDR
// if not tmp then
85684: LD_VAR 0 5
85688: NOT
85689: IFFALSE 85693
// exit ;
85691: GO 85738
// for i in tmp do
85693: LD_ADDR_VAR 0 3
85697: PUSH
85698: LD_VAR 0 5
85702: PUSH
85703: FOR_IN
85704: IFFALSE 85736
// begin result := EnemyInRange ( i , 22 ) ;
85706: LD_ADDR_VAR 0 2
85710: PUSH
85711: LD_VAR 0 3
85715: PPUSH
85716: LD_INT 22
85718: PPUSH
85719: CALL 83974 0 2
85723: ST_TO_ADDR
// if result then
85724: LD_VAR 0 2
85728: IFFALSE 85734
// exit ;
85730: POP
85731: POP
85732: GO 85738
// end ;
85734: GO 85703
85736: POP
85737: POP
// end ;
85738: LD_VAR 0 2
85742: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
85743: LD_INT 0
85745: PPUSH
85746: PPUSH
// if not units then
85747: LD_VAR 0 1
85751: NOT
85752: IFFALSE 85756
// exit ;
85754: GO 85826
// result := [ ] ;
85756: LD_ADDR_VAR 0 3
85760: PUSH
85761: EMPTY
85762: ST_TO_ADDR
// for i in units do
85763: LD_ADDR_VAR 0 4
85767: PUSH
85768: LD_VAR 0 1
85772: PUSH
85773: FOR_IN
85774: IFFALSE 85824
// if GetTag ( i ) = tag then
85776: LD_VAR 0 4
85780: PPUSH
85781: CALL_OW 110
85785: PUSH
85786: LD_VAR 0 2
85790: EQUAL
85791: IFFALSE 85822
// result := Replace ( result , result + 1 , i ) ;
85793: LD_ADDR_VAR 0 3
85797: PUSH
85798: LD_VAR 0 3
85802: PPUSH
85803: LD_VAR 0 3
85807: PUSH
85808: LD_INT 1
85810: PLUS
85811: PPUSH
85812: LD_VAR 0 4
85816: PPUSH
85817: CALL_OW 1
85821: ST_TO_ADDR
85822: GO 85773
85824: POP
85825: POP
// end ;
85826: LD_VAR 0 3
85830: RET
// export function IsDriver ( un ) ; begin
85831: LD_INT 0
85833: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
85834: LD_ADDR_VAR 0 2
85838: PUSH
85839: LD_VAR 0 1
85843: PUSH
85844: LD_INT 55
85846: PUSH
85847: EMPTY
85848: LIST
85849: PPUSH
85850: CALL_OW 69
85854: IN
85855: ST_TO_ADDR
// end ;
85856: LD_VAR 0 2
85860: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
85861: LD_INT 0
85863: PPUSH
85864: PPUSH
// list := [ ] ;
85865: LD_ADDR_VAR 0 5
85869: PUSH
85870: EMPTY
85871: ST_TO_ADDR
// case d of 0 :
85872: LD_VAR 0 3
85876: PUSH
85877: LD_INT 0
85879: DOUBLE
85880: EQUAL
85881: IFTRUE 85885
85883: GO 86018
85885: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
85886: LD_ADDR_VAR 0 5
85890: PUSH
85891: LD_VAR 0 1
85895: PUSH
85896: LD_INT 4
85898: MINUS
85899: PUSH
85900: LD_VAR 0 2
85904: PUSH
85905: LD_INT 4
85907: MINUS
85908: PUSH
85909: LD_INT 2
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: LIST
85916: PUSH
85917: LD_VAR 0 1
85921: PUSH
85922: LD_INT 3
85924: MINUS
85925: PUSH
85926: LD_VAR 0 2
85930: PUSH
85931: LD_INT 1
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: LIST
85938: PUSH
85939: LD_VAR 0 1
85943: PUSH
85944: LD_INT 4
85946: PLUS
85947: PUSH
85948: LD_VAR 0 2
85952: PUSH
85953: LD_INT 4
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: LIST
85960: PUSH
85961: LD_VAR 0 1
85965: PUSH
85966: LD_INT 3
85968: PLUS
85969: PUSH
85970: LD_VAR 0 2
85974: PUSH
85975: LD_INT 3
85977: PLUS
85978: PUSH
85979: LD_INT 5
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: LIST
85986: PUSH
85987: LD_VAR 0 1
85991: PUSH
85992: LD_VAR 0 2
85996: PUSH
85997: LD_INT 4
85999: PLUS
86000: PUSH
86001: LD_INT 0
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: LIST
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: LIST
86013: LIST
86014: LIST
86015: ST_TO_ADDR
// end ; 1 :
86016: GO 86716
86018: LD_INT 1
86020: DOUBLE
86021: EQUAL
86022: IFTRUE 86026
86024: GO 86159
86026: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
86027: LD_ADDR_VAR 0 5
86031: PUSH
86032: LD_VAR 0 1
86036: PUSH
86037: LD_VAR 0 2
86041: PUSH
86042: LD_INT 4
86044: MINUS
86045: PUSH
86046: LD_INT 3
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: LIST
86053: PUSH
86054: LD_VAR 0 1
86058: PUSH
86059: LD_INT 3
86061: MINUS
86062: PUSH
86063: LD_VAR 0 2
86067: PUSH
86068: LD_INT 3
86070: MINUS
86071: PUSH
86072: LD_INT 2
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: LIST
86079: PUSH
86080: LD_VAR 0 1
86084: PUSH
86085: LD_INT 4
86087: MINUS
86088: PUSH
86089: LD_VAR 0 2
86093: PUSH
86094: LD_INT 1
86096: PUSH
86097: EMPTY
86098: LIST
86099: LIST
86100: LIST
86101: PUSH
86102: LD_VAR 0 1
86106: PUSH
86107: LD_VAR 0 2
86111: PUSH
86112: LD_INT 3
86114: PLUS
86115: PUSH
86116: LD_INT 0
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: LIST
86123: PUSH
86124: LD_VAR 0 1
86128: PUSH
86129: LD_INT 4
86131: PLUS
86132: PUSH
86133: LD_VAR 0 2
86137: PUSH
86138: LD_INT 4
86140: PLUS
86141: PUSH
86142: LD_INT 5
86144: PUSH
86145: EMPTY
86146: LIST
86147: LIST
86148: LIST
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: ST_TO_ADDR
// end ; 2 :
86157: GO 86716
86159: LD_INT 2
86161: DOUBLE
86162: EQUAL
86163: IFTRUE 86167
86165: GO 86296
86167: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
86168: LD_ADDR_VAR 0 5
86172: PUSH
86173: LD_VAR 0 1
86177: PUSH
86178: LD_VAR 0 2
86182: PUSH
86183: LD_INT 3
86185: MINUS
86186: PUSH
86187: LD_INT 3
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: LIST
86194: PUSH
86195: LD_VAR 0 1
86199: PUSH
86200: LD_INT 4
86202: PLUS
86203: PUSH
86204: LD_VAR 0 2
86208: PUSH
86209: LD_INT 4
86211: PUSH
86212: EMPTY
86213: LIST
86214: LIST
86215: LIST
86216: PUSH
86217: LD_VAR 0 1
86221: PUSH
86222: LD_VAR 0 2
86226: PUSH
86227: LD_INT 4
86229: PLUS
86230: PUSH
86231: LD_INT 0
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: LIST
86238: PUSH
86239: LD_VAR 0 1
86243: PUSH
86244: LD_INT 3
86246: MINUS
86247: PUSH
86248: LD_VAR 0 2
86252: PUSH
86253: LD_INT 1
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: LIST
86260: PUSH
86261: LD_VAR 0 1
86265: PUSH
86266: LD_INT 4
86268: MINUS
86269: PUSH
86270: LD_VAR 0 2
86274: PUSH
86275: LD_INT 4
86277: MINUS
86278: PUSH
86279: LD_INT 2
86281: PUSH
86282: EMPTY
86283: LIST
86284: LIST
86285: LIST
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: LIST
86291: LIST
86292: LIST
86293: ST_TO_ADDR
// end ; 3 :
86294: GO 86716
86296: LD_INT 3
86298: DOUBLE
86299: EQUAL
86300: IFTRUE 86304
86302: GO 86437
86304: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86305: LD_ADDR_VAR 0 5
86309: PUSH
86310: LD_VAR 0 1
86314: PUSH
86315: LD_INT 3
86317: PLUS
86318: PUSH
86319: LD_VAR 0 2
86323: PUSH
86324: LD_INT 4
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: LIST
86331: PUSH
86332: LD_VAR 0 1
86336: PUSH
86337: LD_INT 4
86339: PLUS
86340: PUSH
86341: LD_VAR 0 2
86345: PUSH
86346: LD_INT 4
86348: PLUS
86349: PUSH
86350: LD_INT 5
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: LIST
86357: PUSH
86358: LD_VAR 0 1
86362: PUSH
86363: LD_INT 4
86365: MINUS
86366: PUSH
86367: LD_VAR 0 2
86371: PUSH
86372: LD_INT 1
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: LIST
86379: PUSH
86380: LD_VAR 0 1
86384: PUSH
86385: LD_VAR 0 2
86389: PUSH
86390: LD_INT 4
86392: MINUS
86393: PUSH
86394: LD_INT 3
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: LIST
86401: PUSH
86402: LD_VAR 0 1
86406: PUSH
86407: LD_INT 3
86409: MINUS
86410: PUSH
86411: LD_VAR 0 2
86415: PUSH
86416: LD_INT 3
86418: MINUS
86419: PUSH
86420: LD_INT 2
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: LIST
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: ST_TO_ADDR
// end ; 4 :
86435: GO 86716
86437: LD_INT 4
86439: DOUBLE
86440: EQUAL
86441: IFTRUE 86445
86443: GO 86578
86445: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86446: LD_ADDR_VAR 0 5
86450: PUSH
86451: LD_VAR 0 1
86455: PUSH
86456: LD_VAR 0 2
86460: PUSH
86461: LD_INT 4
86463: PLUS
86464: PUSH
86465: LD_INT 0
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: LIST
86472: PUSH
86473: LD_VAR 0 1
86477: PUSH
86478: LD_INT 3
86480: PLUS
86481: PUSH
86482: LD_VAR 0 2
86486: PUSH
86487: LD_INT 3
86489: PLUS
86490: PUSH
86491: LD_INT 5
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: LIST
86498: PUSH
86499: LD_VAR 0 1
86503: PUSH
86504: LD_INT 4
86506: PLUS
86507: PUSH
86508: LD_VAR 0 2
86512: PUSH
86513: LD_INT 4
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: LIST
86520: PUSH
86521: LD_VAR 0 1
86525: PUSH
86526: LD_VAR 0 2
86530: PUSH
86531: LD_INT 3
86533: MINUS
86534: PUSH
86535: LD_INT 3
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: LIST
86542: PUSH
86543: LD_VAR 0 1
86547: PUSH
86548: LD_INT 4
86550: MINUS
86551: PUSH
86552: LD_VAR 0 2
86556: PUSH
86557: LD_INT 4
86559: MINUS
86560: PUSH
86561: LD_INT 2
86563: PUSH
86564: EMPTY
86565: LIST
86566: LIST
86567: LIST
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: ST_TO_ADDR
// end ; 5 :
86576: GO 86716
86578: LD_INT 5
86580: DOUBLE
86581: EQUAL
86582: IFTRUE 86586
86584: GO 86715
86586: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
86587: LD_ADDR_VAR 0 5
86591: PUSH
86592: LD_VAR 0 1
86596: PUSH
86597: LD_INT 4
86599: MINUS
86600: PUSH
86601: LD_VAR 0 2
86605: PUSH
86606: LD_INT 1
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: LIST
86613: PUSH
86614: LD_VAR 0 1
86618: PUSH
86619: LD_VAR 0 2
86623: PUSH
86624: LD_INT 4
86626: MINUS
86627: PUSH
86628: LD_INT 3
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: LIST
86635: PUSH
86636: LD_VAR 0 1
86640: PUSH
86641: LD_INT 4
86643: PLUS
86644: PUSH
86645: LD_VAR 0 2
86649: PUSH
86650: LD_INT 4
86652: PLUS
86653: PUSH
86654: LD_INT 5
86656: PUSH
86657: EMPTY
86658: LIST
86659: LIST
86660: LIST
86661: PUSH
86662: LD_VAR 0 1
86666: PUSH
86667: LD_INT 3
86669: PLUS
86670: PUSH
86671: LD_VAR 0 2
86675: PUSH
86676: LD_INT 4
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: LIST
86683: PUSH
86684: LD_VAR 0 1
86688: PUSH
86689: LD_VAR 0 2
86693: PUSH
86694: LD_INT 3
86696: PLUS
86697: PUSH
86698: LD_INT 0
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: LIST
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: ST_TO_ADDR
// end ; end ;
86713: GO 86716
86715: POP
// result := list ;
86716: LD_ADDR_VAR 0 4
86720: PUSH
86721: LD_VAR 0 5
86725: ST_TO_ADDR
// end ;
86726: LD_VAR 0 4
86730: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
86731: LD_INT 0
86733: PPUSH
86734: PPUSH
86735: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
86736: LD_VAR 0 1
86740: NOT
86741: PUSH
86742: LD_VAR 0 2
86746: PUSH
86747: LD_INT 1
86749: PUSH
86750: LD_INT 2
86752: PUSH
86753: LD_INT 3
86755: PUSH
86756: LD_INT 4
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: LIST
86763: LIST
86764: IN
86765: NOT
86766: OR
86767: IFFALSE 86771
// exit ;
86769: GO 86863
// tmp := [ ] ;
86771: LD_ADDR_VAR 0 5
86775: PUSH
86776: EMPTY
86777: ST_TO_ADDR
// for i in units do
86778: LD_ADDR_VAR 0 4
86782: PUSH
86783: LD_VAR 0 1
86787: PUSH
86788: FOR_IN
86789: IFFALSE 86832
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
86791: LD_ADDR_VAR 0 5
86795: PUSH
86796: LD_VAR 0 5
86800: PPUSH
86801: LD_VAR 0 5
86805: PUSH
86806: LD_INT 1
86808: PLUS
86809: PPUSH
86810: LD_VAR 0 4
86814: PPUSH
86815: LD_VAR 0 2
86819: PPUSH
86820: CALL_OW 259
86824: PPUSH
86825: CALL_OW 2
86829: ST_TO_ADDR
86830: GO 86788
86832: POP
86833: POP
// if not tmp then
86834: LD_VAR 0 5
86838: NOT
86839: IFFALSE 86843
// exit ;
86841: GO 86863
// result := SortListByListDesc ( units , tmp ) ;
86843: LD_ADDR_VAR 0 3
86847: PUSH
86848: LD_VAR 0 1
86852: PPUSH
86853: LD_VAR 0 5
86857: PPUSH
86858: CALL_OW 77
86862: ST_TO_ADDR
// end ;
86863: LD_VAR 0 3
86867: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
86868: LD_INT 0
86870: PPUSH
86871: PPUSH
86872: PPUSH
// result := false ;
86873: LD_ADDR_VAR 0 3
86877: PUSH
86878: LD_INT 0
86880: ST_TO_ADDR
// x := GetX ( building ) ;
86881: LD_ADDR_VAR 0 4
86885: PUSH
86886: LD_VAR 0 2
86890: PPUSH
86891: CALL_OW 250
86895: ST_TO_ADDR
// y := GetY ( building ) ;
86896: LD_ADDR_VAR 0 5
86900: PUSH
86901: LD_VAR 0 2
86905: PPUSH
86906: CALL_OW 251
86910: ST_TO_ADDR
// if not building or not x or not y then
86911: LD_VAR 0 2
86915: NOT
86916: PUSH
86917: LD_VAR 0 4
86921: NOT
86922: OR
86923: PUSH
86924: LD_VAR 0 5
86928: NOT
86929: OR
86930: IFFALSE 86934
// exit ;
86932: GO 87026
// if GetTaskList ( unit ) then
86934: LD_VAR 0 1
86938: PPUSH
86939: CALL_OW 437
86943: IFFALSE 87026
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86945: LD_STRING e
86947: PUSH
86948: LD_VAR 0 1
86952: PPUSH
86953: CALL_OW 437
86957: PUSH
86958: LD_INT 1
86960: ARRAY
86961: PUSH
86962: LD_INT 1
86964: ARRAY
86965: EQUAL
86966: PUSH
86967: LD_VAR 0 4
86971: PUSH
86972: LD_VAR 0 1
86976: PPUSH
86977: CALL_OW 437
86981: PUSH
86982: LD_INT 1
86984: ARRAY
86985: PUSH
86986: LD_INT 2
86988: ARRAY
86989: EQUAL
86990: AND
86991: PUSH
86992: LD_VAR 0 5
86996: PUSH
86997: LD_VAR 0 1
87001: PPUSH
87002: CALL_OW 437
87006: PUSH
87007: LD_INT 1
87009: ARRAY
87010: PUSH
87011: LD_INT 3
87013: ARRAY
87014: EQUAL
87015: AND
87016: IFFALSE 87026
// result := true end ;
87018: LD_ADDR_VAR 0 3
87022: PUSH
87023: LD_INT 1
87025: ST_TO_ADDR
// end ;
87026: LD_VAR 0 3
87030: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
87031: LD_INT 0
87033: PPUSH
// result := false ;
87034: LD_ADDR_VAR 0 4
87038: PUSH
87039: LD_INT 0
87041: ST_TO_ADDR
// if GetTaskList ( unit ) then
87042: LD_VAR 0 1
87046: PPUSH
87047: CALL_OW 437
87051: IFFALSE 87134
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87053: LD_STRING M
87055: PUSH
87056: LD_VAR 0 1
87060: PPUSH
87061: CALL_OW 437
87065: PUSH
87066: LD_INT 1
87068: ARRAY
87069: PUSH
87070: LD_INT 1
87072: ARRAY
87073: EQUAL
87074: PUSH
87075: LD_VAR 0 2
87079: PUSH
87080: LD_VAR 0 1
87084: PPUSH
87085: CALL_OW 437
87089: PUSH
87090: LD_INT 1
87092: ARRAY
87093: PUSH
87094: LD_INT 2
87096: ARRAY
87097: EQUAL
87098: AND
87099: PUSH
87100: LD_VAR 0 3
87104: PUSH
87105: LD_VAR 0 1
87109: PPUSH
87110: CALL_OW 437
87114: PUSH
87115: LD_INT 1
87117: ARRAY
87118: PUSH
87119: LD_INT 3
87121: ARRAY
87122: EQUAL
87123: AND
87124: IFFALSE 87134
// result := true ;
87126: LD_ADDR_VAR 0 4
87130: PUSH
87131: LD_INT 1
87133: ST_TO_ADDR
// end ; end ;
87134: LD_VAR 0 4
87138: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
87139: LD_INT 0
87141: PPUSH
87142: PPUSH
87143: PPUSH
87144: PPUSH
// if not unit or not area then
87145: LD_VAR 0 1
87149: NOT
87150: PUSH
87151: LD_VAR 0 2
87155: NOT
87156: OR
87157: IFFALSE 87161
// exit ;
87159: GO 87325
// tmp := AreaToList ( area , i ) ;
87161: LD_ADDR_VAR 0 6
87165: PUSH
87166: LD_VAR 0 2
87170: PPUSH
87171: LD_VAR 0 5
87175: PPUSH
87176: CALL_OW 517
87180: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
87181: LD_ADDR_VAR 0 5
87185: PUSH
87186: DOUBLE
87187: LD_INT 1
87189: DEC
87190: ST_TO_ADDR
87191: LD_VAR 0 6
87195: PUSH
87196: LD_INT 1
87198: ARRAY
87199: PUSH
87200: FOR_TO
87201: IFFALSE 87323
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
87203: LD_ADDR_VAR 0 7
87207: PUSH
87208: LD_VAR 0 6
87212: PUSH
87213: LD_INT 1
87215: ARRAY
87216: PUSH
87217: LD_VAR 0 5
87221: ARRAY
87222: PUSH
87223: LD_VAR 0 6
87227: PUSH
87228: LD_INT 2
87230: ARRAY
87231: PUSH
87232: LD_VAR 0 5
87236: ARRAY
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
87242: LD_VAR 0 7
87246: PUSH
87247: LD_INT 1
87249: ARRAY
87250: PPUSH
87251: LD_VAR 0 7
87255: PUSH
87256: LD_INT 2
87258: ARRAY
87259: PPUSH
87260: CALL_OW 428
87264: PUSH
87265: LD_INT 0
87267: EQUAL
87268: IFFALSE 87321
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
87270: LD_VAR 0 1
87274: PPUSH
87275: LD_VAR 0 7
87279: PUSH
87280: LD_INT 1
87282: ARRAY
87283: PPUSH
87284: LD_VAR 0 7
87288: PUSH
87289: LD_INT 2
87291: ARRAY
87292: PPUSH
87293: LD_VAR 0 3
87297: PPUSH
87298: CALL_OW 48
// result := IsPlaced ( unit ) ;
87302: LD_ADDR_VAR 0 4
87306: PUSH
87307: LD_VAR 0 1
87311: PPUSH
87312: CALL_OW 305
87316: ST_TO_ADDR
// exit ;
87317: POP
87318: POP
87319: GO 87325
// end ; end ;
87321: GO 87200
87323: POP
87324: POP
// end ;
87325: LD_VAR 0 4
87329: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87330: LD_INT 0
87332: PPUSH
87333: PPUSH
87334: PPUSH
// if not side or side > 8 then
87335: LD_VAR 0 1
87339: NOT
87340: PUSH
87341: LD_VAR 0 1
87345: PUSH
87346: LD_INT 8
87348: GREATER
87349: OR
87350: IFFALSE 87354
// exit ;
87352: GO 87541
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
87354: LD_ADDR_VAR 0 4
87358: PUSH
87359: LD_INT 22
87361: PUSH
87362: LD_VAR 0 1
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 21
87373: PUSH
87374: LD_INT 3
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: PPUSH
87385: CALL_OW 69
87389: ST_TO_ADDR
// if not tmp then
87390: LD_VAR 0 4
87394: NOT
87395: IFFALSE 87399
// exit ;
87397: GO 87541
// enable_addtolog := true ;
87399: LD_ADDR_OWVAR 81
87403: PUSH
87404: LD_INT 1
87406: ST_TO_ADDR
// AddToLog ( [ ) ;
87407: LD_STRING [
87409: PPUSH
87410: CALL_OW 561
// for i in tmp do
87414: LD_ADDR_VAR 0 3
87418: PUSH
87419: LD_VAR 0 4
87423: PUSH
87424: FOR_IN
87425: IFFALSE 87532
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87427: LD_STRING [
87429: PUSH
87430: LD_VAR 0 3
87434: PPUSH
87435: CALL_OW 266
87439: STR
87440: PUSH
87441: LD_STRING , 
87443: STR
87444: PUSH
87445: LD_VAR 0 3
87449: PPUSH
87450: CALL_OW 250
87454: STR
87455: PUSH
87456: LD_STRING , 
87458: STR
87459: PUSH
87460: LD_VAR 0 3
87464: PPUSH
87465: CALL_OW 251
87469: STR
87470: PUSH
87471: LD_STRING , 
87473: STR
87474: PUSH
87475: LD_VAR 0 3
87479: PPUSH
87480: CALL_OW 254
87484: STR
87485: PUSH
87486: LD_STRING , 
87488: STR
87489: PUSH
87490: LD_VAR 0 3
87494: PPUSH
87495: LD_INT 1
87497: PPUSH
87498: CALL_OW 268
87502: STR
87503: PUSH
87504: LD_STRING , 
87506: STR
87507: PUSH
87508: LD_VAR 0 3
87512: PPUSH
87513: LD_INT 2
87515: PPUSH
87516: CALL_OW 268
87520: STR
87521: PUSH
87522: LD_STRING ],
87524: STR
87525: PPUSH
87526: CALL_OW 561
// end ;
87530: GO 87424
87532: POP
87533: POP
// AddToLog ( ]; ) ;
87534: LD_STRING ];
87536: PPUSH
87537: CALL_OW 561
// end ;
87541: LD_VAR 0 2
87545: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
87546: LD_INT 0
87548: PPUSH
87549: PPUSH
87550: PPUSH
87551: PPUSH
87552: PPUSH
// if not area or not rate or not max then
87553: LD_VAR 0 1
87557: NOT
87558: PUSH
87559: LD_VAR 0 2
87563: NOT
87564: OR
87565: PUSH
87566: LD_VAR 0 4
87570: NOT
87571: OR
87572: IFFALSE 87576
// exit ;
87574: GO 87768
// while 1 do
87576: LD_INT 1
87578: IFFALSE 87768
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
87580: LD_ADDR_VAR 0 9
87584: PUSH
87585: LD_VAR 0 1
87589: PPUSH
87590: LD_INT 1
87592: PPUSH
87593: CALL_OW 287
87597: PUSH
87598: LD_INT 10
87600: MUL
87601: ST_TO_ADDR
// r := rate / 10 ;
87602: LD_ADDR_VAR 0 7
87606: PUSH
87607: LD_VAR 0 2
87611: PUSH
87612: LD_INT 10
87614: DIVREAL
87615: ST_TO_ADDR
// time := 1 1$00 ;
87616: LD_ADDR_VAR 0 8
87620: PUSH
87621: LD_INT 2100
87623: ST_TO_ADDR
// if amount < min then
87624: LD_VAR 0 9
87628: PUSH
87629: LD_VAR 0 3
87633: LESS
87634: IFFALSE 87652
// r := r * 2 else
87636: LD_ADDR_VAR 0 7
87640: PUSH
87641: LD_VAR 0 7
87645: PUSH
87646: LD_INT 2
87648: MUL
87649: ST_TO_ADDR
87650: GO 87678
// if amount > max then
87652: LD_VAR 0 9
87656: PUSH
87657: LD_VAR 0 4
87661: GREATER
87662: IFFALSE 87678
// r := r / 2 ;
87664: LD_ADDR_VAR 0 7
87668: PUSH
87669: LD_VAR 0 7
87673: PUSH
87674: LD_INT 2
87676: DIVREAL
87677: ST_TO_ADDR
// time := time / r ;
87678: LD_ADDR_VAR 0 8
87682: PUSH
87683: LD_VAR 0 8
87687: PUSH
87688: LD_VAR 0 7
87692: DIVREAL
87693: ST_TO_ADDR
// if time < 0 then
87694: LD_VAR 0 8
87698: PUSH
87699: LD_INT 0
87701: LESS
87702: IFFALSE 87719
// time := time * - 1 ;
87704: LD_ADDR_VAR 0 8
87708: PUSH
87709: LD_VAR 0 8
87713: PUSH
87714: LD_INT 1
87716: NEG
87717: MUL
87718: ST_TO_ADDR
// wait ( time ) ;
87719: LD_VAR 0 8
87723: PPUSH
87724: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
87728: LD_INT 35
87730: PPUSH
87731: LD_INT 875
87733: PPUSH
87734: CALL_OW 12
87738: PPUSH
87739: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
87743: LD_INT 1
87745: PPUSH
87746: LD_INT 5
87748: PPUSH
87749: CALL_OW 12
87753: PPUSH
87754: LD_VAR 0 1
87758: PPUSH
87759: LD_INT 1
87761: PPUSH
87762: CALL_OW 55
// end ;
87766: GO 87576
// end ;
87768: LD_VAR 0 5
87772: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
87773: LD_INT 0
87775: PPUSH
87776: PPUSH
87777: PPUSH
87778: PPUSH
87779: PPUSH
87780: PPUSH
87781: PPUSH
87782: PPUSH
// if not turrets or not factories then
87783: LD_VAR 0 1
87787: NOT
87788: PUSH
87789: LD_VAR 0 2
87793: NOT
87794: OR
87795: IFFALSE 87799
// exit ;
87797: GO 88106
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
87799: LD_ADDR_VAR 0 10
87803: PUSH
87804: LD_INT 5
87806: PUSH
87807: LD_INT 6
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 2
87816: PUSH
87817: LD_INT 4
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: PUSH
87824: LD_INT 3
87826: PUSH
87827: LD_INT 5
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 24
87841: PUSH
87842: LD_INT 25
87844: PUSH
87845: EMPTY
87846: LIST
87847: LIST
87848: PUSH
87849: LD_INT 23
87851: PUSH
87852: LD_INT 27
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: EMPTY
87860: LIST
87861: LIST
87862: PUSH
87863: LD_INT 42
87865: PUSH
87866: LD_INT 43
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: PUSH
87873: LD_INT 44
87875: PUSH
87876: LD_INT 46
87878: PUSH
87879: EMPTY
87880: LIST
87881: LIST
87882: PUSH
87883: LD_INT 45
87885: PUSH
87886: LD_INT 47
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: LIST
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: LIST
87902: ST_TO_ADDR
// result := [ ] ;
87903: LD_ADDR_VAR 0 3
87907: PUSH
87908: EMPTY
87909: ST_TO_ADDR
// for i in turrets do
87910: LD_ADDR_VAR 0 4
87914: PUSH
87915: LD_VAR 0 1
87919: PUSH
87920: FOR_IN
87921: IFFALSE 88104
// begin nat := GetNation ( i ) ;
87923: LD_ADDR_VAR 0 7
87927: PUSH
87928: LD_VAR 0 4
87932: PPUSH
87933: CALL_OW 248
87937: ST_TO_ADDR
// weapon := 0 ;
87938: LD_ADDR_VAR 0 8
87942: PUSH
87943: LD_INT 0
87945: ST_TO_ADDR
// if not nat then
87946: LD_VAR 0 7
87950: NOT
87951: IFFALSE 87955
// continue ;
87953: GO 87920
// for j in list [ nat ] do
87955: LD_ADDR_VAR 0 5
87959: PUSH
87960: LD_VAR 0 10
87964: PUSH
87965: LD_VAR 0 7
87969: ARRAY
87970: PUSH
87971: FOR_IN
87972: IFFALSE 88013
// if GetBWeapon ( i ) = j [ 1 ] then
87974: LD_VAR 0 4
87978: PPUSH
87979: CALL_OW 269
87983: PUSH
87984: LD_VAR 0 5
87988: PUSH
87989: LD_INT 1
87991: ARRAY
87992: EQUAL
87993: IFFALSE 88011
// begin weapon := j [ 2 ] ;
87995: LD_ADDR_VAR 0 8
87999: PUSH
88000: LD_VAR 0 5
88004: PUSH
88005: LD_INT 2
88007: ARRAY
88008: ST_TO_ADDR
// break ;
88009: GO 88013
// end ;
88011: GO 87971
88013: POP
88014: POP
// if not weapon then
88015: LD_VAR 0 8
88019: NOT
88020: IFFALSE 88024
// continue ;
88022: GO 87920
// for k in factories do
88024: LD_ADDR_VAR 0 6
88028: PUSH
88029: LD_VAR 0 2
88033: PUSH
88034: FOR_IN
88035: IFFALSE 88100
// begin weapons := AvailableWeaponList ( k ) ;
88037: LD_ADDR_VAR 0 9
88041: PUSH
88042: LD_VAR 0 6
88046: PPUSH
88047: CALL_OW 478
88051: ST_TO_ADDR
// if not weapons then
88052: LD_VAR 0 9
88056: NOT
88057: IFFALSE 88061
// continue ;
88059: GO 88034
// if weapon in weapons then
88061: LD_VAR 0 8
88065: PUSH
88066: LD_VAR 0 9
88070: IN
88071: IFFALSE 88098
// begin result := [ i , weapon ] ;
88073: LD_ADDR_VAR 0 3
88077: PUSH
88078: LD_VAR 0 4
88082: PUSH
88083: LD_VAR 0 8
88087: PUSH
88088: EMPTY
88089: LIST
88090: LIST
88091: ST_TO_ADDR
// exit ;
88092: POP
88093: POP
88094: POP
88095: POP
88096: GO 88106
// end ; end ;
88098: GO 88034
88100: POP
88101: POP
// end ;
88102: GO 87920
88104: POP
88105: POP
// end ;
88106: LD_VAR 0 3
88110: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
88111: LD_INT 0
88113: PPUSH
// if not side or side > 8 then
88114: LD_VAR 0 3
88118: NOT
88119: PUSH
88120: LD_VAR 0 3
88124: PUSH
88125: LD_INT 8
88127: GREATER
88128: OR
88129: IFFALSE 88133
// exit ;
88131: GO 88192
// if not range then
88133: LD_VAR 0 4
88137: NOT
88138: IFFALSE 88149
// range := - 12 ;
88140: LD_ADDR_VAR 0 4
88144: PUSH
88145: LD_INT 12
88147: NEG
88148: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
88149: LD_VAR 0 1
88153: PPUSH
88154: LD_VAR 0 2
88158: PPUSH
88159: LD_VAR 0 3
88163: PPUSH
88164: LD_VAR 0 4
88168: PPUSH
88169: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
88173: LD_VAR 0 1
88177: PPUSH
88178: LD_VAR 0 2
88182: PPUSH
88183: LD_VAR 0 3
88187: PPUSH
88188: CALL_OW 331
// end ;
88192: LD_VAR 0 5
88196: RET
// export function Video ( mode ) ; begin
88197: LD_INT 0
88199: PPUSH
// ingame_video = mode ;
88200: LD_ADDR_OWVAR 52
88204: PUSH
88205: LD_VAR 0 1
88209: ST_TO_ADDR
// interface_hidden = mode ;
88210: LD_ADDR_OWVAR 54
88214: PUSH
88215: LD_VAR 0 1
88219: ST_TO_ADDR
// end ;
88220: LD_VAR 0 2
88224: RET
// export function Join ( array , element ) ; begin
88225: LD_INT 0
88227: PPUSH
// result := Replace ( array , array + 1 , element ) ;
88228: LD_ADDR_VAR 0 3
88232: PUSH
88233: LD_VAR 0 1
88237: PPUSH
88238: LD_VAR 0 1
88242: PUSH
88243: LD_INT 1
88245: PLUS
88246: PPUSH
88247: LD_VAR 0 2
88251: PPUSH
88252: CALL_OW 1
88256: ST_TO_ADDR
// end ;
88257: LD_VAR 0 3
88261: RET
// export function JoinUnion ( array , element ) ; begin
88262: LD_INT 0
88264: PPUSH
// result := array union element ;
88265: LD_ADDR_VAR 0 3
88269: PUSH
88270: LD_VAR 0 1
88274: PUSH
88275: LD_VAR 0 2
88279: UNION
88280: ST_TO_ADDR
// end ;
88281: LD_VAR 0 3
88285: RET
// export function GetBehemoths ( side ) ; begin
88286: LD_INT 0
88288: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
88289: LD_ADDR_VAR 0 2
88293: PUSH
88294: LD_INT 22
88296: PUSH
88297: LD_VAR 0 1
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: PUSH
88306: LD_INT 31
88308: PUSH
88309: LD_INT 25
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: PPUSH
88320: CALL_OW 69
88324: ST_TO_ADDR
// end ;
88325: LD_VAR 0 2
88329: RET
// export function Shuffle ( array ) ; var i , index ; begin
88330: LD_INT 0
88332: PPUSH
88333: PPUSH
88334: PPUSH
// result := [ ] ;
88335: LD_ADDR_VAR 0 2
88339: PUSH
88340: EMPTY
88341: ST_TO_ADDR
// if not array then
88342: LD_VAR 0 1
88346: NOT
88347: IFFALSE 88351
// exit ;
88349: GO 88450
// Randomize ;
88351: CALL_OW 10
// for i = array downto 1 do
88355: LD_ADDR_VAR 0 3
88359: PUSH
88360: DOUBLE
88361: LD_VAR 0 1
88365: INC
88366: ST_TO_ADDR
88367: LD_INT 1
88369: PUSH
88370: FOR_DOWNTO
88371: IFFALSE 88448
// begin index := rand ( 1 , array ) ;
88373: LD_ADDR_VAR 0 4
88377: PUSH
88378: LD_INT 1
88380: PPUSH
88381: LD_VAR 0 1
88385: PPUSH
88386: CALL_OW 12
88390: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88391: LD_ADDR_VAR 0 2
88395: PUSH
88396: LD_VAR 0 2
88400: PPUSH
88401: LD_VAR 0 2
88405: PUSH
88406: LD_INT 1
88408: PLUS
88409: PPUSH
88410: LD_VAR 0 1
88414: PUSH
88415: LD_VAR 0 4
88419: ARRAY
88420: PPUSH
88421: CALL_OW 2
88425: ST_TO_ADDR
// array := Delete ( array , index ) ;
88426: LD_ADDR_VAR 0 1
88430: PUSH
88431: LD_VAR 0 1
88435: PPUSH
88436: LD_VAR 0 4
88440: PPUSH
88441: CALL_OW 3
88445: ST_TO_ADDR
// end ;
88446: GO 88370
88448: POP
88449: POP
// end ;
88450: LD_VAR 0 2
88454: RET
// export function GetBaseMaterials ( base ) ; begin
88455: LD_INT 0
88457: PPUSH
// result := [ 0 , 0 , 0 ] ;
88458: LD_ADDR_VAR 0 2
88462: PUSH
88463: LD_INT 0
88465: PUSH
88466: LD_INT 0
88468: PUSH
88469: LD_INT 0
88471: PUSH
88472: EMPTY
88473: LIST
88474: LIST
88475: LIST
88476: ST_TO_ADDR
// if not base then
88477: LD_VAR 0 1
88481: NOT
88482: IFFALSE 88486
// exit ;
88484: GO 88535
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
88486: LD_ADDR_VAR 0 2
88490: PUSH
88491: LD_VAR 0 1
88495: PPUSH
88496: LD_INT 1
88498: PPUSH
88499: CALL_OW 275
88503: PUSH
88504: LD_VAR 0 1
88508: PPUSH
88509: LD_INT 2
88511: PPUSH
88512: CALL_OW 275
88516: PUSH
88517: LD_VAR 0 1
88521: PPUSH
88522: LD_INT 3
88524: PPUSH
88525: CALL_OW 275
88529: PUSH
88530: EMPTY
88531: LIST
88532: LIST
88533: LIST
88534: ST_TO_ADDR
// end ;
88535: LD_VAR 0 2
88539: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
88540: LD_INT 0
88542: PPUSH
88543: PPUSH
// result := array ;
88544: LD_ADDR_VAR 0 3
88548: PUSH
88549: LD_VAR 0 1
88553: ST_TO_ADDR
// if size > 0 then
88554: LD_VAR 0 2
88558: PUSH
88559: LD_INT 0
88561: GREATER
88562: IFFALSE 88608
// for i := array downto size do
88564: LD_ADDR_VAR 0 4
88568: PUSH
88569: DOUBLE
88570: LD_VAR 0 1
88574: INC
88575: ST_TO_ADDR
88576: LD_VAR 0 2
88580: PUSH
88581: FOR_DOWNTO
88582: IFFALSE 88606
// result := Delete ( result , result ) ;
88584: LD_ADDR_VAR 0 3
88588: PUSH
88589: LD_VAR 0 3
88593: PPUSH
88594: LD_VAR 0 3
88598: PPUSH
88599: CALL_OW 3
88603: ST_TO_ADDR
88604: GO 88581
88606: POP
88607: POP
// end ;
88608: LD_VAR 0 3
88612: RET
// export function ComExit ( unit ) ; var tmp ; begin
88613: LD_INT 0
88615: PPUSH
88616: PPUSH
// if not IsInUnit ( unit ) then
88617: LD_VAR 0 1
88621: PPUSH
88622: CALL_OW 310
88626: NOT
88627: IFFALSE 88631
// exit ;
88629: GO 88691
// tmp := IsInUnit ( unit ) ;
88631: LD_ADDR_VAR 0 3
88635: PUSH
88636: LD_VAR 0 1
88640: PPUSH
88641: CALL_OW 310
88645: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
88646: LD_VAR 0 3
88650: PPUSH
88651: CALL_OW 247
88655: PUSH
88656: LD_INT 2
88658: EQUAL
88659: IFFALSE 88672
// ComExitVehicle ( unit ) else
88661: LD_VAR 0 1
88665: PPUSH
88666: CALL_OW 121
88670: GO 88681
// ComExitBuilding ( unit ) ;
88672: LD_VAR 0 1
88676: PPUSH
88677: CALL_OW 122
// result := tmp ;
88681: LD_ADDR_VAR 0 2
88685: PUSH
88686: LD_VAR 0 3
88690: ST_TO_ADDR
// end ;
88691: LD_VAR 0 2
88695: RET
// export function ComExitAll ( units ) ; var i ; begin
88696: LD_INT 0
88698: PPUSH
88699: PPUSH
// if not units then
88700: LD_VAR 0 1
88704: NOT
88705: IFFALSE 88709
// exit ;
88707: GO 88735
// for i in units do
88709: LD_ADDR_VAR 0 3
88713: PUSH
88714: LD_VAR 0 1
88718: PUSH
88719: FOR_IN
88720: IFFALSE 88733
// ComExit ( i ) ;
88722: LD_VAR 0 3
88726: PPUSH
88727: CALL 88613 0 1
88731: GO 88719
88733: POP
88734: POP
// end ;
88735: LD_VAR 0 2
88739: RET
// export function ResetHc ; begin
88740: LD_INT 0
88742: PPUSH
// InitHc ;
88743: CALL_OW 19
// hc_importance := 0 ;
88747: LD_ADDR_OWVAR 32
88751: PUSH
88752: LD_INT 0
88754: ST_TO_ADDR
// end ;
88755: LD_VAR 0 1
88759: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
88760: LD_INT 0
88762: PPUSH
88763: PPUSH
88764: PPUSH
// _x := ( x1 + x2 ) div 2 ;
88765: LD_ADDR_VAR 0 6
88769: PUSH
88770: LD_VAR 0 1
88774: PUSH
88775: LD_VAR 0 3
88779: PLUS
88780: PUSH
88781: LD_INT 2
88783: DIV
88784: ST_TO_ADDR
// if _x < 0 then
88785: LD_VAR 0 6
88789: PUSH
88790: LD_INT 0
88792: LESS
88793: IFFALSE 88810
// _x := _x * - 1 ;
88795: LD_ADDR_VAR 0 6
88799: PUSH
88800: LD_VAR 0 6
88804: PUSH
88805: LD_INT 1
88807: NEG
88808: MUL
88809: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
88810: LD_ADDR_VAR 0 7
88814: PUSH
88815: LD_VAR 0 2
88819: PUSH
88820: LD_VAR 0 4
88824: PLUS
88825: PUSH
88826: LD_INT 2
88828: DIV
88829: ST_TO_ADDR
// if _y < 0 then
88830: LD_VAR 0 7
88834: PUSH
88835: LD_INT 0
88837: LESS
88838: IFFALSE 88855
// _y := _y * - 1 ;
88840: LD_ADDR_VAR 0 7
88844: PUSH
88845: LD_VAR 0 7
88849: PUSH
88850: LD_INT 1
88852: NEG
88853: MUL
88854: ST_TO_ADDR
// result := [ _x , _y ] ;
88855: LD_ADDR_VAR 0 5
88859: PUSH
88860: LD_VAR 0 6
88864: PUSH
88865: LD_VAR 0 7
88869: PUSH
88870: EMPTY
88871: LIST
88872: LIST
88873: ST_TO_ADDR
// end ;
88874: LD_VAR 0 5
88878: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
88879: LD_INT 0
88881: PPUSH
88882: PPUSH
88883: PPUSH
88884: PPUSH
// task := GetTaskList ( unit ) ;
88885: LD_ADDR_VAR 0 7
88889: PUSH
88890: LD_VAR 0 1
88894: PPUSH
88895: CALL_OW 437
88899: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
88900: LD_VAR 0 7
88904: NOT
88905: PUSH
88906: LD_VAR 0 1
88910: PPUSH
88911: LD_VAR 0 2
88915: PPUSH
88916: CALL_OW 308
88920: NOT
88921: AND
88922: IFFALSE 88926
// exit ;
88924: GO 89044
// if IsInArea ( unit , area ) then
88926: LD_VAR 0 1
88930: PPUSH
88931: LD_VAR 0 2
88935: PPUSH
88936: CALL_OW 308
88940: IFFALSE 88958
// begin ComMoveToArea ( unit , goAway ) ;
88942: LD_VAR 0 1
88946: PPUSH
88947: LD_VAR 0 3
88951: PPUSH
88952: CALL_OW 113
// exit ;
88956: GO 89044
// end ; if task [ 1 ] [ 1 ] <> M then
88958: LD_VAR 0 7
88962: PUSH
88963: LD_INT 1
88965: ARRAY
88966: PUSH
88967: LD_INT 1
88969: ARRAY
88970: PUSH
88971: LD_STRING M
88973: NONEQUAL
88974: IFFALSE 88978
// exit ;
88976: GO 89044
// x := task [ 1 ] [ 2 ] ;
88978: LD_ADDR_VAR 0 5
88982: PUSH
88983: LD_VAR 0 7
88987: PUSH
88988: LD_INT 1
88990: ARRAY
88991: PUSH
88992: LD_INT 2
88994: ARRAY
88995: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
88996: LD_ADDR_VAR 0 6
89000: PUSH
89001: LD_VAR 0 7
89005: PUSH
89006: LD_INT 1
89008: ARRAY
89009: PUSH
89010: LD_INT 3
89012: ARRAY
89013: ST_TO_ADDR
// if InArea ( x , y , area ) then
89014: LD_VAR 0 5
89018: PPUSH
89019: LD_VAR 0 6
89023: PPUSH
89024: LD_VAR 0 2
89028: PPUSH
89029: CALL_OW 309
89033: IFFALSE 89044
// ComStop ( unit ) ;
89035: LD_VAR 0 1
89039: PPUSH
89040: CALL_OW 141
// end ;
89044: LD_VAR 0 4
89048: RET
// export function Abs ( value ) ; begin
89049: LD_INT 0
89051: PPUSH
// result := value ;
89052: LD_ADDR_VAR 0 2
89056: PUSH
89057: LD_VAR 0 1
89061: ST_TO_ADDR
// if value < 0 then
89062: LD_VAR 0 1
89066: PUSH
89067: LD_INT 0
89069: LESS
89070: IFFALSE 89087
// result := value * - 1 ;
89072: LD_ADDR_VAR 0 2
89076: PUSH
89077: LD_VAR 0 1
89081: PUSH
89082: LD_INT 1
89084: NEG
89085: MUL
89086: ST_TO_ADDR
// end ;
89087: LD_VAR 0 2
89091: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
89092: LD_INT 0
89094: PPUSH
89095: PPUSH
89096: PPUSH
89097: PPUSH
89098: PPUSH
89099: PPUSH
89100: PPUSH
89101: PPUSH
// if not unit or not building then
89102: LD_VAR 0 1
89106: NOT
89107: PUSH
89108: LD_VAR 0 2
89112: NOT
89113: OR
89114: IFFALSE 89118
// exit ;
89116: GO 89344
// x := GetX ( building ) ;
89118: LD_ADDR_VAR 0 4
89122: PUSH
89123: LD_VAR 0 2
89127: PPUSH
89128: CALL_OW 250
89132: ST_TO_ADDR
// y := GetY ( building ) ;
89133: LD_ADDR_VAR 0 6
89137: PUSH
89138: LD_VAR 0 2
89142: PPUSH
89143: CALL_OW 251
89147: ST_TO_ADDR
// d := GetDir ( building ) ;
89148: LD_ADDR_VAR 0 8
89152: PUSH
89153: LD_VAR 0 2
89157: PPUSH
89158: CALL_OW 254
89162: ST_TO_ADDR
// r := 4 ;
89163: LD_ADDR_VAR 0 9
89167: PUSH
89168: LD_INT 4
89170: ST_TO_ADDR
// for i := 1 to 5 do
89171: LD_ADDR_VAR 0 10
89175: PUSH
89176: DOUBLE
89177: LD_INT 1
89179: DEC
89180: ST_TO_ADDR
89181: LD_INT 5
89183: PUSH
89184: FOR_TO
89185: IFFALSE 89342
// begin _x := ShiftX ( x , d , r + i ) ;
89187: LD_ADDR_VAR 0 5
89191: PUSH
89192: LD_VAR 0 4
89196: PPUSH
89197: LD_VAR 0 8
89201: PPUSH
89202: LD_VAR 0 9
89206: PUSH
89207: LD_VAR 0 10
89211: PLUS
89212: PPUSH
89213: CALL_OW 272
89217: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
89218: LD_ADDR_VAR 0 7
89222: PUSH
89223: LD_VAR 0 6
89227: PPUSH
89228: LD_VAR 0 8
89232: PPUSH
89233: LD_VAR 0 9
89237: PUSH
89238: LD_VAR 0 10
89242: PLUS
89243: PPUSH
89244: CALL_OW 273
89248: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
89249: LD_VAR 0 5
89253: PPUSH
89254: LD_VAR 0 7
89258: PPUSH
89259: CALL_OW 488
89263: PUSH
89264: LD_VAR 0 5
89268: PPUSH
89269: LD_VAR 0 7
89273: PPUSH
89274: CALL_OW 428
89278: PPUSH
89279: CALL_OW 247
89283: PUSH
89284: LD_INT 3
89286: PUSH
89287: LD_INT 2
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: IN
89294: NOT
89295: AND
89296: IFFALSE 89340
// begin ComMoveXY ( unit , _x , _y ) ;
89298: LD_VAR 0 1
89302: PPUSH
89303: LD_VAR 0 5
89307: PPUSH
89308: LD_VAR 0 7
89312: PPUSH
89313: CALL_OW 111
// result := [ _x , _y ] ;
89317: LD_ADDR_VAR 0 3
89321: PUSH
89322: LD_VAR 0 5
89326: PUSH
89327: LD_VAR 0 7
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: ST_TO_ADDR
// exit ;
89336: POP
89337: POP
89338: GO 89344
// end ; end ;
89340: GO 89184
89342: POP
89343: POP
// end ;
89344: LD_VAR 0 3
89348: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
89349: LD_INT 0
89351: PPUSH
89352: PPUSH
89353: PPUSH
// result := 0 ;
89354: LD_ADDR_VAR 0 3
89358: PUSH
89359: LD_INT 0
89361: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
89362: LD_VAR 0 1
89366: PUSH
89367: LD_INT 0
89369: LESS
89370: PUSH
89371: LD_VAR 0 1
89375: PUSH
89376: LD_INT 8
89378: GREATER
89379: OR
89380: PUSH
89381: LD_VAR 0 2
89385: PUSH
89386: LD_INT 0
89388: LESS
89389: OR
89390: PUSH
89391: LD_VAR 0 2
89395: PUSH
89396: LD_INT 8
89398: GREATER
89399: OR
89400: IFFALSE 89404
// exit ;
89402: GO 89479
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89404: LD_ADDR_VAR 0 4
89408: PUSH
89409: LD_INT 22
89411: PUSH
89412: LD_VAR 0 2
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: PPUSH
89421: CALL_OW 69
89425: PUSH
89426: FOR_IN
89427: IFFALSE 89477
// begin un := UnitShoot ( i ) ;
89429: LD_ADDR_VAR 0 5
89433: PUSH
89434: LD_VAR 0 4
89438: PPUSH
89439: CALL_OW 504
89443: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89444: LD_VAR 0 5
89448: PPUSH
89449: CALL_OW 255
89453: PUSH
89454: LD_VAR 0 1
89458: EQUAL
89459: IFFALSE 89475
// begin result := un ;
89461: LD_ADDR_VAR 0 3
89465: PUSH
89466: LD_VAR 0 5
89470: ST_TO_ADDR
// exit ;
89471: POP
89472: POP
89473: GO 89479
// end ; end ;
89475: GO 89426
89477: POP
89478: POP
// end ;
89479: LD_VAR 0 3
89483: RET
// export function GetCargoBay ( units ) ; begin
89484: LD_INT 0
89486: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
89487: LD_ADDR_VAR 0 2
89491: PUSH
89492: LD_VAR 0 1
89496: PPUSH
89497: LD_INT 2
89499: PUSH
89500: LD_INT 34
89502: PUSH
89503: LD_INT 12
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 34
89512: PUSH
89513: LD_INT 51
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: LD_INT 34
89522: PUSH
89523: LD_INT 32
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: LD_INT 34
89532: PUSH
89533: LD_EXP 73
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: PPUSH
89549: CALL_OW 72
89553: ST_TO_ADDR
// end ;
89554: LD_VAR 0 2
89558: RET
// export function Negate ( value ) ; begin
89559: LD_INT 0
89561: PPUSH
// result := not value ;
89562: LD_ADDR_VAR 0 2
89566: PUSH
89567: LD_VAR 0 1
89571: NOT
89572: ST_TO_ADDR
// end ;
89573: LD_VAR 0 2
89577: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
89578: LD_INT 0
89580: PPUSH
// if x1 = x2 then
89581: LD_VAR 0 1
89585: PUSH
89586: LD_VAR 0 3
89590: EQUAL
89591: IFFALSE 89625
// begin if y1 > y2 then
89593: LD_VAR 0 2
89597: PUSH
89598: LD_VAR 0 4
89602: GREATER
89603: IFFALSE 89615
// result := 0 else
89605: LD_ADDR_VAR 0 5
89609: PUSH
89610: LD_INT 0
89612: ST_TO_ADDR
89613: GO 89623
// result := 3 ;
89615: LD_ADDR_VAR 0 5
89619: PUSH
89620: LD_INT 3
89622: ST_TO_ADDR
// exit ;
89623: GO 89711
// end ; if y1 = y2 then
89625: LD_VAR 0 2
89629: PUSH
89630: LD_VAR 0 4
89634: EQUAL
89635: IFFALSE 89669
// begin if x1 > x2 then
89637: LD_VAR 0 1
89641: PUSH
89642: LD_VAR 0 3
89646: GREATER
89647: IFFALSE 89659
// result := 1 else
89649: LD_ADDR_VAR 0 5
89653: PUSH
89654: LD_INT 1
89656: ST_TO_ADDR
89657: GO 89667
// result := 4 ;
89659: LD_ADDR_VAR 0 5
89663: PUSH
89664: LD_INT 4
89666: ST_TO_ADDR
// exit ;
89667: GO 89711
// end ; if x1 > x2 and y1 > y2 then
89669: LD_VAR 0 1
89673: PUSH
89674: LD_VAR 0 3
89678: GREATER
89679: PUSH
89680: LD_VAR 0 2
89684: PUSH
89685: LD_VAR 0 4
89689: GREATER
89690: AND
89691: IFFALSE 89703
// result := 2 else
89693: LD_ADDR_VAR 0 5
89697: PUSH
89698: LD_INT 2
89700: ST_TO_ADDR
89701: GO 89711
// result := 5 ;
89703: LD_ADDR_VAR 0 5
89707: PUSH
89708: LD_INT 5
89710: ST_TO_ADDR
// end ;
89711: LD_VAR 0 5
89715: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89716: LD_INT 0
89718: PPUSH
89719: PPUSH
// if not driver or not IsInUnit ( driver ) then
89720: LD_VAR 0 1
89724: NOT
89725: PUSH
89726: LD_VAR 0 1
89730: PPUSH
89731: CALL_OW 310
89735: NOT
89736: OR
89737: IFFALSE 89741
// exit ;
89739: GO 89831
// vehicle := IsInUnit ( driver ) ;
89741: LD_ADDR_VAR 0 3
89745: PUSH
89746: LD_VAR 0 1
89750: PPUSH
89751: CALL_OW 310
89755: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89756: LD_VAR 0 1
89760: PPUSH
89761: LD_STRING \
89763: PUSH
89764: LD_INT 0
89766: PUSH
89767: LD_INT 0
89769: PUSH
89770: LD_INT 0
89772: PUSH
89773: LD_INT 0
89775: PUSH
89776: LD_INT 0
89778: PUSH
89779: LD_INT 0
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: PUSH
89791: LD_STRING E
89793: PUSH
89794: LD_INT 0
89796: PUSH
89797: LD_INT 0
89799: PUSH
89800: LD_VAR 0 3
89804: PUSH
89805: LD_INT 0
89807: PUSH
89808: LD_INT 0
89810: PUSH
89811: LD_INT 0
89813: PUSH
89814: EMPTY
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PPUSH
89827: CALL_OW 446
// end ;
89831: LD_VAR 0 2
89835: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89836: LD_INT 0
89838: PPUSH
89839: PPUSH
// if not driver or not IsInUnit ( driver ) then
89840: LD_VAR 0 1
89844: NOT
89845: PUSH
89846: LD_VAR 0 1
89850: PPUSH
89851: CALL_OW 310
89855: NOT
89856: OR
89857: IFFALSE 89861
// exit ;
89859: GO 89951
// vehicle := IsInUnit ( driver ) ;
89861: LD_ADDR_VAR 0 3
89865: PUSH
89866: LD_VAR 0 1
89870: PPUSH
89871: CALL_OW 310
89875: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89876: LD_VAR 0 1
89880: PPUSH
89881: LD_STRING \
89883: PUSH
89884: LD_INT 0
89886: PUSH
89887: LD_INT 0
89889: PUSH
89890: LD_INT 0
89892: PUSH
89893: LD_INT 0
89895: PUSH
89896: LD_INT 0
89898: PUSH
89899: LD_INT 0
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: PUSH
89911: LD_STRING E
89913: PUSH
89914: LD_INT 0
89916: PUSH
89917: LD_INT 0
89919: PUSH
89920: LD_VAR 0 3
89924: PUSH
89925: LD_INT 0
89927: PUSH
89928: LD_INT 0
89930: PUSH
89931: LD_INT 0
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: LIST
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PPUSH
89947: CALL_OW 447
// end ;
89951: LD_VAR 0 2
89955: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
89956: LD_INT 0
89958: PPUSH
89959: PPUSH
89960: PPUSH
// tmp := [ ] ;
89961: LD_ADDR_VAR 0 5
89965: PUSH
89966: EMPTY
89967: ST_TO_ADDR
// for i in units do
89968: LD_ADDR_VAR 0 4
89972: PUSH
89973: LD_VAR 0 1
89977: PUSH
89978: FOR_IN
89979: IFFALSE 90017
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
89981: LD_ADDR_VAR 0 5
89985: PUSH
89986: LD_VAR 0 5
89990: PPUSH
89991: LD_VAR 0 5
89995: PUSH
89996: LD_INT 1
89998: PLUS
89999: PPUSH
90000: LD_VAR 0 4
90004: PPUSH
90005: CALL_OW 256
90009: PPUSH
90010: CALL_OW 2
90014: ST_TO_ADDR
90015: GO 89978
90017: POP
90018: POP
// if not tmp then
90019: LD_VAR 0 5
90023: NOT
90024: IFFALSE 90028
// exit ;
90026: GO 90076
// if asc then
90028: LD_VAR 0 2
90032: IFFALSE 90056
// result := SortListByListAsc ( units , tmp ) else
90034: LD_ADDR_VAR 0 3
90038: PUSH
90039: LD_VAR 0 1
90043: PPUSH
90044: LD_VAR 0 5
90048: PPUSH
90049: CALL_OW 76
90053: ST_TO_ADDR
90054: GO 90076
// result := SortListByListDesc ( units , tmp ) ;
90056: LD_ADDR_VAR 0 3
90060: PUSH
90061: LD_VAR 0 1
90065: PPUSH
90066: LD_VAR 0 5
90070: PPUSH
90071: CALL_OW 77
90075: ST_TO_ADDR
// end ;
90076: LD_VAR 0 3
90080: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
90081: LD_INT 0
90083: PPUSH
90084: PPUSH
// task := GetTaskList ( mech ) ;
90085: LD_ADDR_VAR 0 4
90089: PUSH
90090: LD_VAR 0 1
90094: PPUSH
90095: CALL_OW 437
90099: ST_TO_ADDR
// if not task then
90100: LD_VAR 0 4
90104: NOT
90105: IFFALSE 90109
// exit ;
90107: GO 90151
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
90109: LD_ADDR_VAR 0 3
90113: PUSH
90114: LD_VAR 0 4
90118: PUSH
90119: LD_INT 1
90121: ARRAY
90122: PUSH
90123: LD_INT 1
90125: ARRAY
90126: PUSH
90127: LD_STRING r
90129: EQUAL
90130: PUSH
90131: LD_VAR 0 4
90135: PUSH
90136: LD_INT 1
90138: ARRAY
90139: PUSH
90140: LD_INT 4
90142: ARRAY
90143: PUSH
90144: LD_VAR 0 2
90148: EQUAL
90149: AND
90150: ST_TO_ADDR
// end ;
90151: LD_VAR 0 3
90155: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
90156: LD_INT 0
90158: PPUSH
// SetDir ( unit , d ) ;
90159: LD_VAR 0 1
90163: PPUSH
90164: LD_VAR 0 4
90168: PPUSH
90169: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
90173: LD_VAR 0 1
90177: PPUSH
90178: LD_VAR 0 2
90182: PPUSH
90183: LD_VAR 0 3
90187: PPUSH
90188: LD_VAR 0 5
90192: PPUSH
90193: CALL_OW 48
// end ;
90197: LD_VAR 0 6
90201: RET
// export function ToNaturalNumber ( number ) ; begin
90202: LD_INT 0
90204: PPUSH
// result := number div 1 ;
90205: LD_ADDR_VAR 0 2
90209: PUSH
90210: LD_VAR 0 1
90214: PUSH
90215: LD_INT 1
90217: DIV
90218: ST_TO_ADDR
// if number < 0 then
90219: LD_VAR 0 1
90223: PUSH
90224: LD_INT 0
90226: LESS
90227: IFFALSE 90237
// result := 0 ;
90229: LD_ADDR_VAR 0 2
90233: PUSH
90234: LD_INT 0
90236: ST_TO_ADDR
// end ;
90237: LD_VAR 0 2
90241: RET
// export function SortByClass ( units , class ) ; var un ; begin
90242: LD_INT 0
90244: PPUSH
90245: PPUSH
// if not units or not class then
90246: LD_VAR 0 1
90250: NOT
90251: PUSH
90252: LD_VAR 0 2
90256: NOT
90257: OR
90258: IFFALSE 90262
// exit ;
90260: GO 90357
// result := [ ] ;
90262: LD_ADDR_VAR 0 3
90266: PUSH
90267: EMPTY
90268: ST_TO_ADDR
// for un in units do
90269: LD_ADDR_VAR 0 4
90273: PUSH
90274: LD_VAR 0 1
90278: PUSH
90279: FOR_IN
90280: IFFALSE 90355
// if GetClass ( un ) = class then
90282: LD_VAR 0 4
90286: PPUSH
90287: CALL_OW 257
90291: PUSH
90292: LD_VAR 0 2
90296: EQUAL
90297: IFFALSE 90324
// result := Insert ( result , 1 , un ) else
90299: LD_ADDR_VAR 0 3
90303: PUSH
90304: LD_VAR 0 3
90308: PPUSH
90309: LD_INT 1
90311: PPUSH
90312: LD_VAR 0 4
90316: PPUSH
90317: CALL_OW 2
90321: ST_TO_ADDR
90322: GO 90353
// result := Replace ( result , result + 1 , un ) ;
90324: LD_ADDR_VAR 0 3
90328: PUSH
90329: LD_VAR 0 3
90333: PPUSH
90334: LD_VAR 0 3
90338: PUSH
90339: LD_INT 1
90341: PLUS
90342: PPUSH
90343: LD_VAR 0 4
90347: PPUSH
90348: CALL_OW 1
90352: ST_TO_ADDR
90353: GO 90279
90355: POP
90356: POP
// end ;
90357: LD_VAR 0 3
90361: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
90362: LD_INT 0
90364: PPUSH
90365: PPUSH
90366: PPUSH
90367: PPUSH
90368: PPUSH
90369: PPUSH
90370: PPUSH
// result := [ ] ;
90371: LD_ADDR_VAR 0 4
90375: PUSH
90376: EMPTY
90377: ST_TO_ADDR
// if x - r < 0 then
90378: LD_VAR 0 1
90382: PUSH
90383: LD_VAR 0 3
90387: MINUS
90388: PUSH
90389: LD_INT 0
90391: LESS
90392: IFFALSE 90404
// min_x := 0 else
90394: LD_ADDR_VAR 0 8
90398: PUSH
90399: LD_INT 0
90401: ST_TO_ADDR
90402: GO 90420
// min_x := x - r ;
90404: LD_ADDR_VAR 0 8
90408: PUSH
90409: LD_VAR 0 1
90413: PUSH
90414: LD_VAR 0 3
90418: MINUS
90419: ST_TO_ADDR
// if y - r < 0 then
90420: LD_VAR 0 2
90424: PUSH
90425: LD_VAR 0 3
90429: MINUS
90430: PUSH
90431: LD_INT 0
90433: LESS
90434: IFFALSE 90446
// min_y := 0 else
90436: LD_ADDR_VAR 0 7
90440: PUSH
90441: LD_INT 0
90443: ST_TO_ADDR
90444: GO 90462
// min_y := y - r ;
90446: LD_ADDR_VAR 0 7
90450: PUSH
90451: LD_VAR 0 2
90455: PUSH
90456: LD_VAR 0 3
90460: MINUS
90461: ST_TO_ADDR
// max_x := x + r ;
90462: LD_ADDR_VAR 0 9
90466: PUSH
90467: LD_VAR 0 1
90471: PUSH
90472: LD_VAR 0 3
90476: PLUS
90477: ST_TO_ADDR
// max_y := y + r ;
90478: LD_ADDR_VAR 0 10
90482: PUSH
90483: LD_VAR 0 2
90487: PUSH
90488: LD_VAR 0 3
90492: PLUS
90493: ST_TO_ADDR
// for _x = min_x to max_x do
90494: LD_ADDR_VAR 0 5
90498: PUSH
90499: DOUBLE
90500: LD_VAR 0 8
90504: DEC
90505: ST_TO_ADDR
90506: LD_VAR 0 9
90510: PUSH
90511: FOR_TO
90512: IFFALSE 90613
// for _y = min_y to max_y do
90514: LD_ADDR_VAR 0 6
90518: PUSH
90519: DOUBLE
90520: LD_VAR 0 7
90524: DEC
90525: ST_TO_ADDR
90526: LD_VAR 0 10
90530: PUSH
90531: FOR_TO
90532: IFFALSE 90609
// begin if not ValidHex ( _x , _y ) then
90534: LD_VAR 0 5
90538: PPUSH
90539: LD_VAR 0 6
90543: PPUSH
90544: CALL_OW 488
90548: NOT
90549: IFFALSE 90553
// continue ;
90551: GO 90531
// if GetResourceTypeXY ( _x , _y ) then
90553: LD_VAR 0 5
90557: PPUSH
90558: LD_VAR 0 6
90562: PPUSH
90563: CALL_OW 283
90567: IFFALSE 90607
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
90569: LD_ADDR_VAR 0 4
90573: PUSH
90574: LD_VAR 0 4
90578: PPUSH
90579: LD_VAR 0 4
90583: PUSH
90584: LD_INT 1
90586: PLUS
90587: PPUSH
90588: LD_VAR 0 5
90592: PUSH
90593: LD_VAR 0 6
90597: PUSH
90598: EMPTY
90599: LIST
90600: LIST
90601: PPUSH
90602: CALL_OW 1
90606: ST_TO_ADDR
// end ;
90607: GO 90531
90609: POP
90610: POP
90611: GO 90511
90613: POP
90614: POP
// end ;
90615: LD_VAR 0 4
90619: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
90620: LD_INT 0
90622: PPUSH
90623: PPUSH
90624: PPUSH
90625: PPUSH
90626: PPUSH
90627: PPUSH
// if not units then
90628: LD_VAR 0 1
90632: NOT
90633: IFFALSE 90637
// exit ;
90635: GO 91038
// result := UnitFilter ( units , [ f_ok ] ) ;
90637: LD_ADDR_VAR 0 3
90641: PUSH
90642: LD_VAR 0 1
90646: PPUSH
90647: LD_INT 50
90649: PUSH
90650: EMPTY
90651: LIST
90652: PPUSH
90653: CALL_OW 72
90657: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
90658: LD_ADDR_VAR 0 7
90662: PUSH
90663: LD_VAR 0 1
90667: PUSH
90668: LD_INT 1
90670: ARRAY
90671: PPUSH
90672: CALL_OW 255
90676: ST_TO_ADDR
// if not result then
90677: LD_VAR 0 3
90681: NOT
90682: IFFALSE 90686
// exit ;
90684: GO 91038
// for i in result do
90686: LD_ADDR_VAR 0 4
90690: PUSH
90691: LD_VAR 0 3
90695: PUSH
90696: FOR_IN
90697: IFFALSE 91036
// begin tag := GetTag ( i ) + 1 ;
90699: LD_ADDR_VAR 0 8
90703: PUSH
90704: LD_VAR 0 4
90708: PPUSH
90709: CALL_OW 110
90713: PUSH
90714: LD_INT 1
90716: PLUS
90717: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
90718: LD_ADDR_VAR 0 6
90722: PUSH
90723: LD_VAR 0 4
90727: PPUSH
90728: CALL_OW 250
90732: PPUSH
90733: LD_VAR 0 4
90737: PPUSH
90738: CALL_OW 251
90742: PPUSH
90743: LD_INT 6
90745: PPUSH
90746: CALL 90362 0 3
90750: ST_TO_ADDR
// if cr then
90751: LD_VAR 0 6
90755: IFFALSE 90794
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
90757: LD_VAR 0 4
90761: PPUSH
90762: LD_VAR 0 6
90766: PUSH
90767: LD_INT 1
90769: ARRAY
90770: PUSH
90771: LD_INT 1
90773: ARRAY
90774: PPUSH
90775: LD_VAR 0 6
90779: PUSH
90780: LD_INT 1
90782: ARRAY
90783: PUSH
90784: LD_INT 2
90786: ARRAY
90787: PPUSH
90788: CALL_OW 116
90792: GO 91034
// if path > tag then
90794: LD_VAR 0 2
90798: PUSH
90799: LD_VAR 0 8
90803: GREATER
90804: IFFALSE 90982
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
90806: LD_ADDR_VAR 0 5
90810: PUSH
90811: LD_INT 81
90813: PUSH
90814: LD_VAR 0 7
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 91
90825: PUSH
90826: LD_VAR 0 4
90830: PUSH
90831: LD_INT 12
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: LIST
90838: PUSH
90839: EMPTY
90840: LIST
90841: LIST
90842: PPUSH
90843: CALL_OW 69
90847: ST_TO_ADDR
// if enemy then
90848: LD_VAR 0 5
90852: IFFALSE 90880
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
90854: LD_VAR 0 4
90858: PPUSH
90859: LD_VAR 0 5
90863: PPUSH
90864: LD_VAR 0 4
90868: PPUSH
90869: CALL_OW 74
90873: PPUSH
90874: CALL_OW 115
90878: GO 90980
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
90880: LD_VAR 0 4
90884: PPUSH
90885: LD_VAR 0 2
90889: PUSH
90890: LD_VAR 0 8
90894: ARRAY
90895: PUSH
90896: LD_INT 1
90898: ARRAY
90899: PPUSH
90900: LD_VAR 0 2
90904: PUSH
90905: LD_VAR 0 8
90909: ARRAY
90910: PUSH
90911: LD_INT 2
90913: ARRAY
90914: PPUSH
90915: CALL_OW 297
90919: PUSH
90920: LD_INT 6
90922: GREATER
90923: IFFALSE 90966
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
90925: LD_VAR 0 4
90929: PPUSH
90930: LD_VAR 0 2
90934: PUSH
90935: LD_VAR 0 8
90939: ARRAY
90940: PUSH
90941: LD_INT 1
90943: ARRAY
90944: PPUSH
90945: LD_VAR 0 2
90949: PUSH
90950: LD_VAR 0 8
90954: ARRAY
90955: PUSH
90956: LD_INT 2
90958: ARRAY
90959: PPUSH
90960: CALL_OW 114
90964: GO 90980
// SetTag ( i , tag ) ;
90966: LD_VAR 0 4
90970: PPUSH
90971: LD_VAR 0 8
90975: PPUSH
90976: CALL_OW 109
// end else
90980: GO 91034
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
90982: LD_ADDR_VAR 0 5
90986: PUSH
90987: LD_INT 81
90989: PUSH
90990: LD_VAR 0 7
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PPUSH
90999: CALL_OW 69
91003: ST_TO_ADDR
// if enemy then
91004: LD_VAR 0 5
91008: IFFALSE 91034
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
91010: LD_VAR 0 4
91014: PPUSH
91015: LD_VAR 0 5
91019: PPUSH
91020: LD_VAR 0 4
91024: PPUSH
91025: CALL_OW 74
91029: PPUSH
91030: CALL_OW 115
// end ; end ;
91034: GO 90696
91036: POP
91037: POP
// end ; end_of_file end_of_file
91038: LD_VAR 0 3
91042: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91043: LD_INT 0
91045: PPUSH
// if p2 = 100 then
91046: LD_VAR 0 2
91050: PUSH
91051: LD_INT 100
91053: EQUAL
91054: IFFALSE 92003
// begin if not StreamModeActive then
91056: LD_EXP 137
91060: NOT
91061: IFFALSE 91071
// StreamModeActive := true ;
91063: LD_ADDR_EXP 137
91067: PUSH
91068: LD_INT 1
91070: ST_TO_ADDR
// if p3 = 0 then
91071: LD_VAR 0 3
91075: PUSH
91076: LD_INT 0
91078: EQUAL
91079: IFFALSE 91085
// InitStreamMode ;
91081: CALL 92163 0 0
// if p3 = 1 then
91085: LD_VAR 0 3
91089: PUSH
91090: LD_INT 1
91092: EQUAL
91093: IFFALSE 91103
// sRocket := true ;
91095: LD_ADDR_EXP 142
91099: PUSH
91100: LD_INT 1
91102: ST_TO_ADDR
// if p3 = 2 then
91103: LD_VAR 0 3
91107: PUSH
91108: LD_INT 2
91110: EQUAL
91111: IFFALSE 91121
// sSpeed := true ;
91113: LD_ADDR_EXP 141
91117: PUSH
91118: LD_INT 1
91120: ST_TO_ADDR
// if p3 = 3 then
91121: LD_VAR 0 3
91125: PUSH
91126: LD_INT 3
91128: EQUAL
91129: IFFALSE 91139
// sEngine := true ;
91131: LD_ADDR_EXP 143
91135: PUSH
91136: LD_INT 1
91138: ST_TO_ADDR
// if p3 = 4 then
91139: LD_VAR 0 3
91143: PUSH
91144: LD_INT 4
91146: EQUAL
91147: IFFALSE 91157
// sSpec := true ;
91149: LD_ADDR_EXP 140
91153: PUSH
91154: LD_INT 1
91156: ST_TO_ADDR
// if p3 = 5 then
91157: LD_VAR 0 3
91161: PUSH
91162: LD_INT 5
91164: EQUAL
91165: IFFALSE 91175
// sLevel := true ;
91167: LD_ADDR_EXP 144
91171: PUSH
91172: LD_INT 1
91174: ST_TO_ADDR
// if p3 = 6 then
91175: LD_VAR 0 3
91179: PUSH
91180: LD_INT 6
91182: EQUAL
91183: IFFALSE 91193
// sArmoury := true ;
91185: LD_ADDR_EXP 145
91189: PUSH
91190: LD_INT 1
91192: ST_TO_ADDR
// if p3 = 7 then
91193: LD_VAR 0 3
91197: PUSH
91198: LD_INT 7
91200: EQUAL
91201: IFFALSE 91211
// sRadar := true ;
91203: LD_ADDR_EXP 146
91207: PUSH
91208: LD_INT 1
91210: ST_TO_ADDR
// if p3 = 8 then
91211: LD_VAR 0 3
91215: PUSH
91216: LD_INT 8
91218: EQUAL
91219: IFFALSE 91229
// sBunker := true ;
91221: LD_ADDR_EXP 147
91225: PUSH
91226: LD_INT 1
91228: ST_TO_ADDR
// if p3 = 9 then
91229: LD_VAR 0 3
91233: PUSH
91234: LD_INT 9
91236: EQUAL
91237: IFFALSE 91247
// sHack := true ;
91239: LD_ADDR_EXP 148
91243: PUSH
91244: LD_INT 1
91246: ST_TO_ADDR
// if p3 = 10 then
91247: LD_VAR 0 3
91251: PUSH
91252: LD_INT 10
91254: EQUAL
91255: IFFALSE 91265
// sFire := true ;
91257: LD_ADDR_EXP 149
91261: PUSH
91262: LD_INT 1
91264: ST_TO_ADDR
// if p3 = 11 then
91265: LD_VAR 0 3
91269: PUSH
91270: LD_INT 11
91272: EQUAL
91273: IFFALSE 91283
// sRefresh := true ;
91275: LD_ADDR_EXP 150
91279: PUSH
91280: LD_INT 1
91282: ST_TO_ADDR
// if p3 = 12 then
91283: LD_VAR 0 3
91287: PUSH
91288: LD_INT 12
91290: EQUAL
91291: IFFALSE 91301
// sExp := true ;
91293: LD_ADDR_EXP 151
91297: PUSH
91298: LD_INT 1
91300: ST_TO_ADDR
// if p3 = 13 then
91301: LD_VAR 0 3
91305: PUSH
91306: LD_INT 13
91308: EQUAL
91309: IFFALSE 91319
// sDepot := true ;
91311: LD_ADDR_EXP 152
91315: PUSH
91316: LD_INT 1
91318: ST_TO_ADDR
// if p3 = 14 then
91319: LD_VAR 0 3
91323: PUSH
91324: LD_INT 14
91326: EQUAL
91327: IFFALSE 91337
// sFlag := true ;
91329: LD_ADDR_EXP 153
91333: PUSH
91334: LD_INT 1
91336: ST_TO_ADDR
// if p3 = 15 then
91337: LD_VAR 0 3
91341: PUSH
91342: LD_INT 15
91344: EQUAL
91345: IFFALSE 91355
// sKamikadze := true ;
91347: LD_ADDR_EXP 161
91351: PUSH
91352: LD_INT 1
91354: ST_TO_ADDR
// if p3 = 16 then
91355: LD_VAR 0 3
91359: PUSH
91360: LD_INT 16
91362: EQUAL
91363: IFFALSE 91373
// sTroll := true ;
91365: LD_ADDR_EXP 162
91369: PUSH
91370: LD_INT 1
91372: ST_TO_ADDR
// if p3 = 17 then
91373: LD_VAR 0 3
91377: PUSH
91378: LD_INT 17
91380: EQUAL
91381: IFFALSE 91391
// sSlow := true ;
91383: LD_ADDR_EXP 163
91387: PUSH
91388: LD_INT 1
91390: ST_TO_ADDR
// if p3 = 18 then
91391: LD_VAR 0 3
91395: PUSH
91396: LD_INT 18
91398: EQUAL
91399: IFFALSE 91409
// sLack := true ;
91401: LD_ADDR_EXP 164
91405: PUSH
91406: LD_INT 1
91408: ST_TO_ADDR
// if p3 = 19 then
91409: LD_VAR 0 3
91413: PUSH
91414: LD_INT 19
91416: EQUAL
91417: IFFALSE 91427
// sTank := true ;
91419: LD_ADDR_EXP 166
91423: PUSH
91424: LD_INT 1
91426: ST_TO_ADDR
// if p3 = 20 then
91427: LD_VAR 0 3
91431: PUSH
91432: LD_INT 20
91434: EQUAL
91435: IFFALSE 91445
// sRemote := true ;
91437: LD_ADDR_EXP 167
91441: PUSH
91442: LD_INT 1
91444: ST_TO_ADDR
// if p3 = 21 then
91445: LD_VAR 0 3
91449: PUSH
91450: LD_INT 21
91452: EQUAL
91453: IFFALSE 91463
// sPowell := true ;
91455: LD_ADDR_EXP 168
91459: PUSH
91460: LD_INT 1
91462: ST_TO_ADDR
// if p3 = 22 then
91463: LD_VAR 0 3
91467: PUSH
91468: LD_INT 22
91470: EQUAL
91471: IFFALSE 91481
// sTeleport := true ;
91473: LD_ADDR_EXP 171
91477: PUSH
91478: LD_INT 1
91480: ST_TO_ADDR
// if p3 = 23 then
91481: LD_VAR 0 3
91485: PUSH
91486: LD_INT 23
91488: EQUAL
91489: IFFALSE 91499
// sOilTower := true ;
91491: LD_ADDR_EXP 173
91495: PUSH
91496: LD_INT 1
91498: ST_TO_ADDR
// if p3 = 24 then
91499: LD_VAR 0 3
91503: PUSH
91504: LD_INT 24
91506: EQUAL
91507: IFFALSE 91517
// sShovel := true ;
91509: LD_ADDR_EXP 174
91513: PUSH
91514: LD_INT 1
91516: ST_TO_ADDR
// if p3 = 25 then
91517: LD_VAR 0 3
91521: PUSH
91522: LD_INT 25
91524: EQUAL
91525: IFFALSE 91535
// sSheik := true ;
91527: LD_ADDR_EXP 175
91531: PUSH
91532: LD_INT 1
91534: ST_TO_ADDR
// if p3 = 26 then
91535: LD_VAR 0 3
91539: PUSH
91540: LD_INT 26
91542: EQUAL
91543: IFFALSE 91553
// sEarthquake := true ;
91545: LD_ADDR_EXP 177
91549: PUSH
91550: LD_INT 1
91552: ST_TO_ADDR
// if p3 = 27 then
91553: LD_VAR 0 3
91557: PUSH
91558: LD_INT 27
91560: EQUAL
91561: IFFALSE 91571
// sAI := true ;
91563: LD_ADDR_EXP 178
91567: PUSH
91568: LD_INT 1
91570: ST_TO_ADDR
// if p3 = 28 then
91571: LD_VAR 0 3
91575: PUSH
91576: LD_INT 28
91578: EQUAL
91579: IFFALSE 91589
// sCargo := true ;
91581: LD_ADDR_EXP 181
91585: PUSH
91586: LD_INT 1
91588: ST_TO_ADDR
// if p3 = 29 then
91589: LD_VAR 0 3
91593: PUSH
91594: LD_INT 29
91596: EQUAL
91597: IFFALSE 91607
// sDLaser := true ;
91599: LD_ADDR_EXP 182
91603: PUSH
91604: LD_INT 1
91606: ST_TO_ADDR
// if p3 = 30 then
91607: LD_VAR 0 3
91611: PUSH
91612: LD_INT 30
91614: EQUAL
91615: IFFALSE 91625
// sExchange := true ;
91617: LD_ADDR_EXP 183
91621: PUSH
91622: LD_INT 1
91624: ST_TO_ADDR
// if p3 = 31 then
91625: LD_VAR 0 3
91629: PUSH
91630: LD_INT 31
91632: EQUAL
91633: IFFALSE 91643
// sFac := true ;
91635: LD_ADDR_EXP 184
91639: PUSH
91640: LD_INT 1
91642: ST_TO_ADDR
// if p3 = 32 then
91643: LD_VAR 0 3
91647: PUSH
91648: LD_INT 32
91650: EQUAL
91651: IFFALSE 91661
// sPower := true ;
91653: LD_ADDR_EXP 185
91657: PUSH
91658: LD_INT 1
91660: ST_TO_ADDR
// if p3 = 33 then
91661: LD_VAR 0 3
91665: PUSH
91666: LD_INT 33
91668: EQUAL
91669: IFFALSE 91679
// sRandom := true ;
91671: LD_ADDR_EXP 186
91675: PUSH
91676: LD_INT 1
91678: ST_TO_ADDR
// if p3 = 34 then
91679: LD_VAR 0 3
91683: PUSH
91684: LD_INT 34
91686: EQUAL
91687: IFFALSE 91697
// sShield := true ;
91689: LD_ADDR_EXP 187
91693: PUSH
91694: LD_INT 1
91696: ST_TO_ADDR
// if p3 = 35 then
91697: LD_VAR 0 3
91701: PUSH
91702: LD_INT 35
91704: EQUAL
91705: IFFALSE 91715
// sTime := true ;
91707: LD_ADDR_EXP 188
91711: PUSH
91712: LD_INT 1
91714: ST_TO_ADDR
// if p3 = 36 then
91715: LD_VAR 0 3
91719: PUSH
91720: LD_INT 36
91722: EQUAL
91723: IFFALSE 91733
// sTools := true ;
91725: LD_ADDR_EXP 189
91729: PUSH
91730: LD_INT 1
91732: ST_TO_ADDR
// if p3 = 101 then
91733: LD_VAR 0 3
91737: PUSH
91738: LD_INT 101
91740: EQUAL
91741: IFFALSE 91751
// sSold := true ;
91743: LD_ADDR_EXP 154
91747: PUSH
91748: LD_INT 1
91750: ST_TO_ADDR
// if p3 = 102 then
91751: LD_VAR 0 3
91755: PUSH
91756: LD_INT 102
91758: EQUAL
91759: IFFALSE 91769
// sDiff := true ;
91761: LD_ADDR_EXP 155
91765: PUSH
91766: LD_INT 1
91768: ST_TO_ADDR
// if p3 = 103 then
91769: LD_VAR 0 3
91773: PUSH
91774: LD_INT 103
91776: EQUAL
91777: IFFALSE 91787
// sFog := true ;
91779: LD_ADDR_EXP 158
91783: PUSH
91784: LD_INT 1
91786: ST_TO_ADDR
// if p3 = 104 then
91787: LD_VAR 0 3
91791: PUSH
91792: LD_INT 104
91794: EQUAL
91795: IFFALSE 91805
// sReset := true ;
91797: LD_ADDR_EXP 159
91801: PUSH
91802: LD_INT 1
91804: ST_TO_ADDR
// if p3 = 105 then
91805: LD_VAR 0 3
91809: PUSH
91810: LD_INT 105
91812: EQUAL
91813: IFFALSE 91823
// sSun := true ;
91815: LD_ADDR_EXP 160
91819: PUSH
91820: LD_INT 1
91822: ST_TO_ADDR
// if p3 = 106 then
91823: LD_VAR 0 3
91827: PUSH
91828: LD_INT 106
91830: EQUAL
91831: IFFALSE 91841
// sTiger := true ;
91833: LD_ADDR_EXP 156
91837: PUSH
91838: LD_INT 1
91840: ST_TO_ADDR
// if p3 = 107 then
91841: LD_VAR 0 3
91845: PUSH
91846: LD_INT 107
91848: EQUAL
91849: IFFALSE 91859
// sBomb := true ;
91851: LD_ADDR_EXP 157
91855: PUSH
91856: LD_INT 1
91858: ST_TO_ADDR
// if p3 = 108 then
91859: LD_VAR 0 3
91863: PUSH
91864: LD_INT 108
91866: EQUAL
91867: IFFALSE 91877
// sWound := true ;
91869: LD_ADDR_EXP 165
91873: PUSH
91874: LD_INT 1
91876: ST_TO_ADDR
// if p3 = 109 then
91877: LD_VAR 0 3
91881: PUSH
91882: LD_INT 109
91884: EQUAL
91885: IFFALSE 91895
// sBetray := true ;
91887: LD_ADDR_EXP 169
91891: PUSH
91892: LD_INT 1
91894: ST_TO_ADDR
// if p3 = 110 then
91895: LD_VAR 0 3
91899: PUSH
91900: LD_INT 110
91902: EQUAL
91903: IFFALSE 91913
// sContamin := true ;
91905: LD_ADDR_EXP 170
91909: PUSH
91910: LD_INT 1
91912: ST_TO_ADDR
// if p3 = 111 then
91913: LD_VAR 0 3
91917: PUSH
91918: LD_INT 111
91920: EQUAL
91921: IFFALSE 91931
// sOil := true ;
91923: LD_ADDR_EXP 172
91927: PUSH
91928: LD_INT 1
91930: ST_TO_ADDR
// if p3 = 112 then
91931: LD_VAR 0 3
91935: PUSH
91936: LD_INT 112
91938: EQUAL
91939: IFFALSE 91949
// sStu := true ;
91941: LD_ADDR_EXP 176
91945: PUSH
91946: LD_INT 1
91948: ST_TO_ADDR
// if p3 = 113 then
91949: LD_VAR 0 3
91953: PUSH
91954: LD_INT 113
91956: EQUAL
91957: IFFALSE 91967
// sBazooka := true ;
91959: LD_ADDR_EXP 179
91963: PUSH
91964: LD_INT 1
91966: ST_TO_ADDR
// if p3 = 114 then
91967: LD_VAR 0 3
91971: PUSH
91972: LD_INT 114
91974: EQUAL
91975: IFFALSE 91985
// sMortar := true ;
91977: LD_ADDR_EXP 180
91981: PUSH
91982: LD_INT 1
91984: ST_TO_ADDR
// if p3 = 115 then
91985: LD_VAR 0 3
91989: PUSH
91990: LD_INT 115
91992: EQUAL
91993: IFFALSE 92003
// sRanger := true ;
91995: LD_ADDR_EXP 190
91999: PUSH
92000: LD_INT 1
92002: ST_TO_ADDR
// end ; if p2 = 101 then
92003: LD_VAR 0 2
92007: PUSH
92008: LD_INT 101
92010: EQUAL
92011: IFFALSE 92139
// begin case p3 of 1 :
92013: LD_VAR 0 3
92017: PUSH
92018: LD_INT 1
92020: DOUBLE
92021: EQUAL
92022: IFTRUE 92026
92024: GO 92033
92026: POP
// hHackUnlimitedResources ; 2 :
92027: CALL 103176 0 0
92031: GO 92139
92033: LD_INT 2
92035: DOUBLE
92036: EQUAL
92037: IFTRUE 92041
92039: GO 92048
92041: POP
// hHackSetLevel10 ; 3 :
92042: CALL 103309 0 0
92046: GO 92139
92048: LD_INT 3
92050: DOUBLE
92051: EQUAL
92052: IFTRUE 92056
92054: GO 92063
92056: POP
// hHackSetLevel10YourUnits ; 4 :
92057: CALL 103394 0 0
92061: GO 92139
92063: LD_INT 4
92065: DOUBLE
92066: EQUAL
92067: IFTRUE 92071
92069: GO 92078
92071: POP
// hHackInvincible ; 5 :
92072: CALL 103842 0 0
92076: GO 92139
92078: LD_INT 5
92080: DOUBLE
92081: EQUAL
92082: IFTRUE 92086
92084: GO 92093
92086: POP
// hHackInvisible ; 6 :
92087: CALL 103953 0 0
92091: GO 92139
92093: LD_INT 6
92095: DOUBLE
92096: EQUAL
92097: IFTRUE 92101
92099: GO 92108
92101: POP
// hHackChangeYourSide ; 7 :
92102: CALL 104010 0 0
92106: GO 92139
92108: LD_INT 7
92110: DOUBLE
92111: EQUAL
92112: IFTRUE 92116
92114: GO 92123
92116: POP
// hHackChangeUnitSide ; 8 :
92117: CALL 104052 0 0
92121: GO 92139
92123: LD_INT 8
92125: DOUBLE
92126: EQUAL
92127: IFTRUE 92131
92129: GO 92138
92131: POP
// hHackFog ; end ;
92132: CALL 104153 0 0
92136: GO 92139
92138: POP
// end ; end ;
92139: LD_VAR 0 7
92143: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
92144: GO 92146
92146: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
92147: LD_STRING initStreamRollete();
92149: PPUSH
92150: CALL_OW 559
// InitStreamMode ;
92154: CALL 92163 0 0
// DefineStreamItems ( ) ;
92158: CALL 92603 0 0
// end ;
92162: END
// function InitStreamMode ; begin
92163: LD_INT 0
92165: PPUSH
// streamModeActive := false ;
92166: LD_ADDR_EXP 137
92170: PUSH
92171: LD_INT 0
92173: ST_TO_ADDR
// normalCounter := 36 ;
92174: LD_ADDR_EXP 138
92178: PUSH
92179: LD_INT 36
92181: ST_TO_ADDR
// hardcoreCounter := 16 ;
92182: LD_ADDR_EXP 139
92186: PUSH
92187: LD_INT 16
92189: ST_TO_ADDR
// sRocket := false ;
92190: LD_ADDR_EXP 142
92194: PUSH
92195: LD_INT 0
92197: ST_TO_ADDR
// sSpeed := false ;
92198: LD_ADDR_EXP 141
92202: PUSH
92203: LD_INT 0
92205: ST_TO_ADDR
// sEngine := false ;
92206: LD_ADDR_EXP 143
92210: PUSH
92211: LD_INT 0
92213: ST_TO_ADDR
// sSpec := false ;
92214: LD_ADDR_EXP 140
92218: PUSH
92219: LD_INT 0
92221: ST_TO_ADDR
// sLevel := false ;
92222: LD_ADDR_EXP 144
92226: PUSH
92227: LD_INT 0
92229: ST_TO_ADDR
// sArmoury := false ;
92230: LD_ADDR_EXP 145
92234: PUSH
92235: LD_INT 0
92237: ST_TO_ADDR
// sRadar := false ;
92238: LD_ADDR_EXP 146
92242: PUSH
92243: LD_INT 0
92245: ST_TO_ADDR
// sBunker := false ;
92246: LD_ADDR_EXP 147
92250: PUSH
92251: LD_INT 0
92253: ST_TO_ADDR
// sHack := false ;
92254: LD_ADDR_EXP 148
92258: PUSH
92259: LD_INT 0
92261: ST_TO_ADDR
// sFire := false ;
92262: LD_ADDR_EXP 149
92266: PUSH
92267: LD_INT 0
92269: ST_TO_ADDR
// sRefresh := false ;
92270: LD_ADDR_EXP 150
92274: PUSH
92275: LD_INT 0
92277: ST_TO_ADDR
// sExp := false ;
92278: LD_ADDR_EXP 151
92282: PUSH
92283: LD_INT 0
92285: ST_TO_ADDR
// sDepot := false ;
92286: LD_ADDR_EXP 152
92290: PUSH
92291: LD_INT 0
92293: ST_TO_ADDR
// sFlag := false ;
92294: LD_ADDR_EXP 153
92298: PUSH
92299: LD_INT 0
92301: ST_TO_ADDR
// sKamikadze := false ;
92302: LD_ADDR_EXP 161
92306: PUSH
92307: LD_INT 0
92309: ST_TO_ADDR
// sTroll := false ;
92310: LD_ADDR_EXP 162
92314: PUSH
92315: LD_INT 0
92317: ST_TO_ADDR
// sSlow := false ;
92318: LD_ADDR_EXP 163
92322: PUSH
92323: LD_INT 0
92325: ST_TO_ADDR
// sLack := false ;
92326: LD_ADDR_EXP 164
92330: PUSH
92331: LD_INT 0
92333: ST_TO_ADDR
// sTank := false ;
92334: LD_ADDR_EXP 166
92338: PUSH
92339: LD_INT 0
92341: ST_TO_ADDR
// sRemote := false ;
92342: LD_ADDR_EXP 167
92346: PUSH
92347: LD_INT 0
92349: ST_TO_ADDR
// sPowell := false ;
92350: LD_ADDR_EXP 168
92354: PUSH
92355: LD_INT 0
92357: ST_TO_ADDR
// sTeleport := false ;
92358: LD_ADDR_EXP 171
92362: PUSH
92363: LD_INT 0
92365: ST_TO_ADDR
// sOilTower := false ;
92366: LD_ADDR_EXP 173
92370: PUSH
92371: LD_INT 0
92373: ST_TO_ADDR
// sShovel := false ;
92374: LD_ADDR_EXP 174
92378: PUSH
92379: LD_INT 0
92381: ST_TO_ADDR
// sSheik := false ;
92382: LD_ADDR_EXP 175
92386: PUSH
92387: LD_INT 0
92389: ST_TO_ADDR
// sEarthquake := false ;
92390: LD_ADDR_EXP 177
92394: PUSH
92395: LD_INT 0
92397: ST_TO_ADDR
// sAI := false ;
92398: LD_ADDR_EXP 178
92402: PUSH
92403: LD_INT 0
92405: ST_TO_ADDR
// sCargo := false ;
92406: LD_ADDR_EXP 181
92410: PUSH
92411: LD_INT 0
92413: ST_TO_ADDR
// sDLaser := false ;
92414: LD_ADDR_EXP 182
92418: PUSH
92419: LD_INT 0
92421: ST_TO_ADDR
// sExchange := false ;
92422: LD_ADDR_EXP 183
92426: PUSH
92427: LD_INT 0
92429: ST_TO_ADDR
// sFac := false ;
92430: LD_ADDR_EXP 184
92434: PUSH
92435: LD_INT 0
92437: ST_TO_ADDR
// sPower := false ;
92438: LD_ADDR_EXP 185
92442: PUSH
92443: LD_INT 0
92445: ST_TO_ADDR
// sRandom := false ;
92446: LD_ADDR_EXP 186
92450: PUSH
92451: LD_INT 0
92453: ST_TO_ADDR
// sShield := false ;
92454: LD_ADDR_EXP 187
92458: PUSH
92459: LD_INT 0
92461: ST_TO_ADDR
// sTime := false ;
92462: LD_ADDR_EXP 188
92466: PUSH
92467: LD_INT 0
92469: ST_TO_ADDR
// sTools := false ;
92470: LD_ADDR_EXP 189
92474: PUSH
92475: LD_INT 0
92477: ST_TO_ADDR
// sSold := false ;
92478: LD_ADDR_EXP 154
92482: PUSH
92483: LD_INT 0
92485: ST_TO_ADDR
// sDiff := false ;
92486: LD_ADDR_EXP 155
92490: PUSH
92491: LD_INT 0
92493: ST_TO_ADDR
// sFog := false ;
92494: LD_ADDR_EXP 158
92498: PUSH
92499: LD_INT 0
92501: ST_TO_ADDR
// sReset := false ;
92502: LD_ADDR_EXP 159
92506: PUSH
92507: LD_INT 0
92509: ST_TO_ADDR
// sSun := false ;
92510: LD_ADDR_EXP 160
92514: PUSH
92515: LD_INT 0
92517: ST_TO_ADDR
// sTiger := false ;
92518: LD_ADDR_EXP 156
92522: PUSH
92523: LD_INT 0
92525: ST_TO_ADDR
// sBomb := false ;
92526: LD_ADDR_EXP 157
92530: PUSH
92531: LD_INT 0
92533: ST_TO_ADDR
// sWound := false ;
92534: LD_ADDR_EXP 165
92538: PUSH
92539: LD_INT 0
92541: ST_TO_ADDR
// sBetray := false ;
92542: LD_ADDR_EXP 169
92546: PUSH
92547: LD_INT 0
92549: ST_TO_ADDR
// sContamin := false ;
92550: LD_ADDR_EXP 170
92554: PUSH
92555: LD_INT 0
92557: ST_TO_ADDR
// sOil := false ;
92558: LD_ADDR_EXP 172
92562: PUSH
92563: LD_INT 0
92565: ST_TO_ADDR
// sStu := false ;
92566: LD_ADDR_EXP 176
92570: PUSH
92571: LD_INT 0
92573: ST_TO_ADDR
// sBazooka := false ;
92574: LD_ADDR_EXP 179
92578: PUSH
92579: LD_INT 0
92581: ST_TO_ADDR
// sMortar := false ;
92582: LD_ADDR_EXP 180
92586: PUSH
92587: LD_INT 0
92589: ST_TO_ADDR
// sRanger := false ;
92590: LD_ADDR_EXP 190
92594: PUSH
92595: LD_INT 0
92597: ST_TO_ADDR
// end ;
92598: LD_VAR 0 1
92602: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
92603: LD_INT 0
92605: PPUSH
92606: PPUSH
92607: PPUSH
92608: PPUSH
92609: PPUSH
// result := [ ] ;
92610: LD_ADDR_VAR 0 1
92614: PUSH
92615: EMPTY
92616: ST_TO_ADDR
// if campaign_id = 1 then
92617: LD_OWVAR 69
92621: PUSH
92622: LD_INT 1
92624: EQUAL
92625: IFFALSE 95563
// begin case mission_number of 1 :
92627: LD_OWVAR 70
92631: PUSH
92632: LD_INT 1
92634: DOUBLE
92635: EQUAL
92636: IFTRUE 92640
92638: GO 92704
92640: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
92641: LD_ADDR_VAR 0 1
92645: PUSH
92646: LD_INT 2
92648: PUSH
92649: LD_INT 4
92651: PUSH
92652: LD_INT 11
92654: PUSH
92655: LD_INT 12
92657: PUSH
92658: LD_INT 15
92660: PUSH
92661: LD_INT 16
92663: PUSH
92664: LD_INT 22
92666: PUSH
92667: LD_INT 23
92669: PUSH
92670: LD_INT 26
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: PUSH
92684: LD_INT 101
92686: PUSH
92687: LD_INT 102
92689: PUSH
92690: LD_INT 106
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: LIST
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: ST_TO_ADDR
92702: GO 95561
92704: LD_INT 2
92706: DOUBLE
92707: EQUAL
92708: IFTRUE 92712
92710: GO 92784
92712: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
92713: LD_ADDR_VAR 0 1
92717: PUSH
92718: LD_INT 2
92720: PUSH
92721: LD_INT 4
92723: PUSH
92724: LD_INT 11
92726: PUSH
92727: LD_INT 12
92729: PUSH
92730: LD_INT 15
92732: PUSH
92733: LD_INT 16
92735: PUSH
92736: LD_INT 22
92738: PUSH
92739: LD_INT 23
92741: PUSH
92742: LD_INT 26
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: LIST
92749: LIST
92750: LIST
92751: LIST
92752: LIST
92753: LIST
92754: LIST
92755: PUSH
92756: LD_INT 101
92758: PUSH
92759: LD_INT 102
92761: PUSH
92762: LD_INT 105
92764: PUSH
92765: LD_INT 106
92767: PUSH
92768: LD_INT 108
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: PUSH
92778: EMPTY
92779: LIST
92780: LIST
92781: ST_TO_ADDR
92782: GO 95561
92784: LD_INT 3
92786: DOUBLE
92787: EQUAL
92788: IFTRUE 92792
92790: GO 92868
92792: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
92793: LD_ADDR_VAR 0 1
92797: PUSH
92798: LD_INT 2
92800: PUSH
92801: LD_INT 4
92803: PUSH
92804: LD_INT 5
92806: PUSH
92807: LD_INT 11
92809: PUSH
92810: LD_INT 12
92812: PUSH
92813: LD_INT 15
92815: PUSH
92816: LD_INT 16
92818: PUSH
92819: LD_INT 22
92821: PUSH
92822: LD_INT 26
92824: PUSH
92825: LD_INT 36
92827: PUSH
92828: EMPTY
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: PUSH
92840: LD_INT 101
92842: PUSH
92843: LD_INT 102
92845: PUSH
92846: LD_INT 105
92848: PUSH
92849: LD_INT 106
92851: PUSH
92852: LD_INT 108
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: PUSH
92862: EMPTY
92863: LIST
92864: LIST
92865: ST_TO_ADDR
92866: GO 95561
92868: LD_INT 4
92870: DOUBLE
92871: EQUAL
92872: IFTRUE 92876
92874: GO 92960
92876: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
92877: LD_ADDR_VAR 0 1
92881: PUSH
92882: LD_INT 2
92884: PUSH
92885: LD_INT 4
92887: PUSH
92888: LD_INT 5
92890: PUSH
92891: LD_INT 8
92893: PUSH
92894: LD_INT 11
92896: PUSH
92897: LD_INT 12
92899: PUSH
92900: LD_INT 15
92902: PUSH
92903: LD_INT 16
92905: PUSH
92906: LD_INT 22
92908: PUSH
92909: LD_INT 23
92911: PUSH
92912: LD_INT 26
92914: PUSH
92915: LD_INT 36
92917: PUSH
92918: EMPTY
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: PUSH
92932: LD_INT 101
92934: PUSH
92935: LD_INT 102
92937: PUSH
92938: LD_INT 105
92940: PUSH
92941: LD_INT 106
92943: PUSH
92944: LD_INT 108
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: PUSH
92954: EMPTY
92955: LIST
92956: LIST
92957: ST_TO_ADDR
92958: GO 95561
92960: LD_INT 5
92962: DOUBLE
92963: EQUAL
92964: IFTRUE 92968
92966: GO 93068
92968: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
92969: LD_ADDR_VAR 0 1
92973: PUSH
92974: LD_INT 2
92976: PUSH
92977: LD_INT 4
92979: PUSH
92980: LD_INT 5
92982: PUSH
92983: LD_INT 6
92985: PUSH
92986: LD_INT 8
92988: PUSH
92989: LD_INT 11
92991: PUSH
92992: LD_INT 12
92994: PUSH
92995: LD_INT 15
92997: PUSH
92998: LD_INT 16
93000: PUSH
93001: LD_INT 22
93003: PUSH
93004: LD_INT 23
93006: PUSH
93007: LD_INT 25
93009: PUSH
93010: LD_INT 26
93012: PUSH
93013: LD_INT 36
93015: PUSH
93016: EMPTY
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: LIST
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: PUSH
93032: LD_INT 101
93034: PUSH
93035: LD_INT 102
93037: PUSH
93038: LD_INT 105
93040: PUSH
93041: LD_INT 106
93043: PUSH
93044: LD_INT 108
93046: PUSH
93047: LD_INT 109
93049: PUSH
93050: LD_INT 112
93052: PUSH
93053: EMPTY
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: LIST
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: ST_TO_ADDR
93066: GO 95561
93068: LD_INT 6
93070: DOUBLE
93071: EQUAL
93072: IFTRUE 93076
93074: GO 93196
93076: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
93077: LD_ADDR_VAR 0 1
93081: PUSH
93082: LD_INT 2
93084: PUSH
93085: LD_INT 4
93087: PUSH
93088: LD_INT 5
93090: PUSH
93091: LD_INT 6
93093: PUSH
93094: LD_INT 8
93096: PUSH
93097: LD_INT 11
93099: PUSH
93100: LD_INT 12
93102: PUSH
93103: LD_INT 15
93105: PUSH
93106: LD_INT 16
93108: PUSH
93109: LD_INT 20
93111: PUSH
93112: LD_INT 21
93114: PUSH
93115: LD_INT 22
93117: PUSH
93118: LD_INT 23
93120: PUSH
93121: LD_INT 25
93123: PUSH
93124: LD_INT 26
93126: PUSH
93127: LD_INT 30
93129: PUSH
93130: LD_INT 31
93132: PUSH
93133: LD_INT 32
93135: PUSH
93136: LD_INT 36
93138: PUSH
93139: EMPTY
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 101
93162: PUSH
93163: LD_INT 102
93165: PUSH
93166: LD_INT 105
93168: PUSH
93169: LD_INT 106
93171: PUSH
93172: LD_INT 108
93174: PUSH
93175: LD_INT 109
93177: PUSH
93178: LD_INT 112
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: ST_TO_ADDR
93194: GO 95561
93196: LD_INT 7
93198: DOUBLE
93199: EQUAL
93200: IFTRUE 93204
93202: GO 93304
93204: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
93205: LD_ADDR_VAR 0 1
93209: PUSH
93210: LD_INT 2
93212: PUSH
93213: LD_INT 4
93215: PUSH
93216: LD_INT 5
93218: PUSH
93219: LD_INT 7
93221: PUSH
93222: LD_INT 11
93224: PUSH
93225: LD_INT 12
93227: PUSH
93228: LD_INT 15
93230: PUSH
93231: LD_INT 16
93233: PUSH
93234: LD_INT 20
93236: PUSH
93237: LD_INT 21
93239: PUSH
93240: LD_INT 22
93242: PUSH
93243: LD_INT 23
93245: PUSH
93246: LD_INT 25
93248: PUSH
93249: LD_INT 26
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: PUSH
93268: LD_INT 101
93270: PUSH
93271: LD_INT 102
93273: PUSH
93274: LD_INT 103
93276: PUSH
93277: LD_INT 105
93279: PUSH
93280: LD_INT 106
93282: PUSH
93283: LD_INT 108
93285: PUSH
93286: LD_INT 112
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: ST_TO_ADDR
93302: GO 95561
93304: LD_INT 8
93306: DOUBLE
93307: EQUAL
93308: IFTRUE 93312
93310: GO 93440
93312: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
93313: LD_ADDR_VAR 0 1
93317: PUSH
93318: LD_INT 2
93320: PUSH
93321: LD_INT 4
93323: PUSH
93324: LD_INT 5
93326: PUSH
93327: LD_INT 6
93329: PUSH
93330: LD_INT 7
93332: PUSH
93333: LD_INT 8
93335: PUSH
93336: LD_INT 11
93338: PUSH
93339: LD_INT 12
93341: PUSH
93342: LD_INT 15
93344: PUSH
93345: LD_INT 16
93347: PUSH
93348: LD_INT 20
93350: PUSH
93351: LD_INT 21
93353: PUSH
93354: LD_INT 22
93356: PUSH
93357: LD_INT 23
93359: PUSH
93360: LD_INT 25
93362: PUSH
93363: LD_INT 26
93365: PUSH
93366: LD_INT 30
93368: PUSH
93369: LD_INT 31
93371: PUSH
93372: LD_INT 32
93374: PUSH
93375: LD_INT 36
93377: PUSH
93378: EMPTY
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: LIST
93393: LIST
93394: LIST
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: PUSH
93400: LD_INT 101
93402: PUSH
93403: LD_INT 102
93405: PUSH
93406: LD_INT 103
93408: PUSH
93409: LD_INT 105
93411: PUSH
93412: LD_INT 106
93414: PUSH
93415: LD_INT 108
93417: PUSH
93418: LD_INT 109
93420: PUSH
93421: LD_INT 112
93423: PUSH
93424: EMPTY
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: ST_TO_ADDR
93438: GO 95561
93440: LD_INT 9
93442: DOUBLE
93443: EQUAL
93444: IFTRUE 93448
93446: GO 93584
93448: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
93449: LD_ADDR_VAR 0 1
93453: PUSH
93454: LD_INT 2
93456: PUSH
93457: LD_INT 4
93459: PUSH
93460: LD_INT 5
93462: PUSH
93463: LD_INT 6
93465: PUSH
93466: LD_INT 7
93468: PUSH
93469: LD_INT 8
93471: PUSH
93472: LD_INT 11
93474: PUSH
93475: LD_INT 12
93477: PUSH
93478: LD_INT 15
93480: PUSH
93481: LD_INT 16
93483: PUSH
93484: LD_INT 20
93486: PUSH
93487: LD_INT 21
93489: PUSH
93490: LD_INT 22
93492: PUSH
93493: LD_INT 23
93495: PUSH
93496: LD_INT 25
93498: PUSH
93499: LD_INT 26
93501: PUSH
93502: LD_INT 28
93504: PUSH
93505: LD_INT 30
93507: PUSH
93508: LD_INT 31
93510: PUSH
93511: LD_INT 32
93513: PUSH
93514: LD_INT 36
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: LIST
93527: LIST
93528: LIST
93529: LIST
93530: LIST
93531: LIST
93532: LIST
93533: LIST
93534: LIST
93535: LIST
93536: LIST
93537: LIST
93538: LIST
93539: PUSH
93540: LD_INT 101
93542: PUSH
93543: LD_INT 102
93545: PUSH
93546: LD_INT 103
93548: PUSH
93549: LD_INT 105
93551: PUSH
93552: LD_INT 106
93554: PUSH
93555: LD_INT 108
93557: PUSH
93558: LD_INT 109
93560: PUSH
93561: LD_INT 112
93563: PUSH
93564: LD_INT 114
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: PUSH
93578: EMPTY
93579: LIST
93580: LIST
93581: ST_TO_ADDR
93582: GO 95561
93584: LD_INT 10
93586: DOUBLE
93587: EQUAL
93588: IFTRUE 93592
93590: GO 93776
93592: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
93593: LD_ADDR_VAR 0 1
93597: PUSH
93598: LD_INT 2
93600: PUSH
93601: LD_INT 4
93603: PUSH
93604: LD_INT 5
93606: PUSH
93607: LD_INT 6
93609: PUSH
93610: LD_INT 7
93612: PUSH
93613: LD_INT 8
93615: PUSH
93616: LD_INT 9
93618: PUSH
93619: LD_INT 10
93621: PUSH
93622: LD_INT 11
93624: PUSH
93625: LD_INT 12
93627: PUSH
93628: LD_INT 13
93630: PUSH
93631: LD_INT 14
93633: PUSH
93634: LD_INT 15
93636: PUSH
93637: LD_INT 16
93639: PUSH
93640: LD_INT 17
93642: PUSH
93643: LD_INT 18
93645: PUSH
93646: LD_INT 19
93648: PUSH
93649: LD_INT 20
93651: PUSH
93652: LD_INT 21
93654: PUSH
93655: LD_INT 22
93657: PUSH
93658: LD_INT 23
93660: PUSH
93661: LD_INT 24
93663: PUSH
93664: LD_INT 25
93666: PUSH
93667: LD_INT 26
93669: PUSH
93670: LD_INT 28
93672: PUSH
93673: LD_INT 30
93675: PUSH
93676: LD_INT 31
93678: PUSH
93679: LD_INT 32
93681: PUSH
93682: LD_INT 36
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: PUSH
93716: LD_INT 101
93718: PUSH
93719: LD_INT 102
93721: PUSH
93722: LD_INT 103
93724: PUSH
93725: LD_INT 104
93727: PUSH
93728: LD_INT 105
93730: PUSH
93731: LD_INT 106
93733: PUSH
93734: LD_INT 107
93736: PUSH
93737: LD_INT 108
93739: PUSH
93740: LD_INT 109
93742: PUSH
93743: LD_INT 110
93745: PUSH
93746: LD_INT 111
93748: PUSH
93749: LD_INT 112
93751: PUSH
93752: LD_INT 114
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: ST_TO_ADDR
93774: GO 95561
93776: LD_INT 11
93778: DOUBLE
93779: EQUAL
93780: IFTRUE 93784
93782: GO 93976
93784: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
93785: LD_ADDR_VAR 0 1
93789: PUSH
93790: LD_INT 2
93792: PUSH
93793: LD_INT 3
93795: PUSH
93796: LD_INT 4
93798: PUSH
93799: LD_INT 5
93801: PUSH
93802: LD_INT 6
93804: PUSH
93805: LD_INT 7
93807: PUSH
93808: LD_INT 8
93810: PUSH
93811: LD_INT 9
93813: PUSH
93814: LD_INT 10
93816: PUSH
93817: LD_INT 11
93819: PUSH
93820: LD_INT 12
93822: PUSH
93823: LD_INT 13
93825: PUSH
93826: LD_INT 14
93828: PUSH
93829: LD_INT 15
93831: PUSH
93832: LD_INT 16
93834: PUSH
93835: LD_INT 17
93837: PUSH
93838: LD_INT 18
93840: PUSH
93841: LD_INT 19
93843: PUSH
93844: LD_INT 20
93846: PUSH
93847: LD_INT 21
93849: PUSH
93850: LD_INT 22
93852: PUSH
93853: LD_INT 23
93855: PUSH
93856: LD_INT 24
93858: PUSH
93859: LD_INT 25
93861: PUSH
93862: LD_INT 26
93864: PUSH
93865: LD_INT 28
93867: PUSH
93868: LD_INT 30
93870: PUSH
93871: LD_INT 31
93873: PUSH
93874: LD_INT 32
93876: PUSH
93877: LD_INT 34
93879: PUSH
93880: LD_INT 36
93882: PUSH
93883: EMPTY
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 101
93918: PUSH
93919: LD_INT 102
93921: PUSH
93922: LD_INT 103
93924: PUSH
93925: LD_INT 104
93927: PUSH
93928: LD_INT 105
93930: PUSH
93931: LD_INT 106
93933: PUSH
93934: LD_INT 107
93936: PUSH
93937: LD_INT 108
93939: PUSH
93940: LD_INT 109
93942: PUSH
93943: LD_INT 110
93945: PUSH
93946: LD_INT 111
93948: PUSH
93949: LD_INT 112
93951: PUSH
93952: LD_INT 114
93954: PUSH
93955: EMPTY
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: ST_TO_ADDR
93974: GO 95561
93976: LD_INT 12
93978: DOUBLE
93979: EQUAL
93980: IFTRUE 93984
93982: GO 94192
93984: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
93985: LD_ADDR_VAR 0 1
93989: PUSH
93990: LD_INT 1
93992: PUSH
93993: LD_INT 2
93995: PUSH
93996: LD_INT 3
93998: PUSH
93999: LD_INT 4
94001: PUSH
94002: LD_INT 5
94004: PUSH
94005: LD_INT 6
94007: PUSH
94008: LD_INT 7
94010: PUSH
94011: LD_INT 8
94013: PUSH
94014: LD_INT 9
94016: PUSH
94017: LD_INT 10
94019: PUSH
94020: LD_INT 11
94022: PUSH
94023: LD_INT 12
94025: PUSH
94026: LD_INT 13
94028: PUSH
94029: LD_INT 14
94031: PUSH
94032: LD_INT 15
94034: PUSH
94035: LD_INT 16
94037: PUSH
94038: LD_INT 17
94040: PUSH
94041: LD_INT 18
94043: PUSH
94044: LD_INT 19
94046: PUSH
94047: LD_INT 20
94049: PUSH
94050: LD_INT 21
94052: PUSH
94053: LD_INT 22
94055: PUSH
94056: LD_INT 23
94058: PUSH
94059: LD_INT 24
94061: PUSH
94062: LD_INT 25
94064: PUSH
94065: LD_INT 26
94067: PUSH
94068: LD_INT 27
94070: PUSH
94071: LD_INT 28
94073: PUSH
94074: LD_INT 30
94076: PUSH
94077: LD_INT 31
94079: PUSH
94080: LD_INT 32
94082: PUSH
94083: LD_INT 33
94085: PUSH
94086: LD_INT 34
94088: PUSH
94089: LD_INT 36
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: PUSH
94128: LD_INT 101
94130: PUSH
94131: LD_INT 102
94133: PUSH
94134: LD_INT 103
94136: PUSH
94137: LD_INT 104
94139: PUSH
94140: LD_INT 105
94142: PUSH
94143: LD_INT 106
94145: PUSH
94146: LD_INT 107
94148: PUSH
94149: LD_INT 108
94151: PUSH
94152: LD_INT 109
94154: PUSH
94155: LD_INT 110
94157: PUSH
94158: LD_INT 111
94160: PUSH
94161: LD_INT 112
94163: PUSH
94164: LD_INT 113
94166: PUSH
94167: LD_INT 114
94169: PUSH
94170: EMPTY
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: LIST
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: ST_TO_ADDR
94190: GO 95561
94192: LD_INT 13
94194: DOUBLE
94195: EQUAL
94196: IFTRUE 94200
94198: GO 94396
94200: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
94201: LD_ADDR_VAR 0 1
94205: PUSH
94206: LD_INT 1
94208: PUSH
94209: LD_INT 2
94211: PUSH
94212: LD_INT 3
94214: PUSH
94215: LD_INT 4
94217: PUSH
94218: LD_INT 5
94220: PUSH
94221: LD_INT 8
94223: PUSH
94224: LD_INT 9
94226: PUSH
94227: LD_INT 10
94229: PUSH
94230: LD_INT 11
94232: PUSH
94233: LD_INT 12
94235: PUSH
94236: LD_INT 14
94238: PUSH
94239: LD_INT 15
94241: PUSH
94242: LD_INT 16
94244: PUSH
94245: LD_INT 17
94247: PUSH
94248: LD_INT 18
94250: PUSH
94251: LD_INT 19
94253: PUSH
94254: LD_INT 20
94256: PUSH
94257: LD_INT 21
94259: PUSH
94260: LD_INT 22
94262: PUSH
94263: LD_INT 23
94265: PUSH
94266: LD_INT 24
94268: PUSH
94269: LD_INT 25
94271: PUSH
94272: LD_INT 26
94274: PUSH
94275: LD_INT 27
94277: PUSH
94278: LD_INT 28
94280: PUSH
94281: LD_INT 30
94283: PUSH
94284: LD_INT 31
94286: PUSH
94287: LD_INT 32
94289: PUSH
94290: LD_INT 33
94292: PUSH
94293: LD_INT 34
94295: PUSH
94296: LD_INT 36
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 101
94334: PUSH
94335: LD_INT 102
94337: PUSH
94338: LD_INT 103
94340: PUSH
94341: LD_INT 104
94343: PUSH
94344: LD_INT 105
94346: PUSH
94347: LD_INT 106
94349: PUSH
94350: LD_INT 107
94352: PUSH
94353: LD_INT 108
94355: PUSH
94356: LD_INT 109
94358: PUSH
94359: LD_INT 110
94361: PUSH
94362: LD_INT 111
94364: PUSH
94365: LD_INT 112
94367: PUSH
94368: LD_INT 113
94370: PUSH
94371: LD_INT 114
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: ST_TO_ADDR
94394: GO 95561
94396: LD_INT 14
94398: DOUBLE
94399: EQUAL
94400: IFTRUE 94404
94402: GO 94616
94404: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
94405: LD_ADDR_VAR 0 1
94409: PUSH
94410: LD_INT 1
94412: PUSH
94413: LD_INT 2
94415: PUSH
94416: LD_INT 3
94418: PUSH
94419: LD_INT 4
94421: PUSH
94422: LD_INT 5
94424: PUSH
94425: LD_INT 6
94427: PUSH
94428: LD_INT 7
94430: PUSH
94431: LD_INT 8
94433: PUSH
94434: LD_INT 9
94436: PUSH
94437: LD_INT 10
94439: PUSH
94440: LD_INT 11
94442: PUSH
94443: LD_INT 12
94445: PUSH
94446: LD_INT 13
94448: PUSH
94449: LD_INT 14
94451: PUSH
94452: LD_INT 15
94454: PUSH
94455: LD_INT 16
94457: PUSH
94458: LD_INT 17
94460: PUSH
94461: LD_INT 18
94463: PUSH
94464: LD_INT 19
94466: PUSH
94467: LD_INT 20
94469: PUSH
94470: LD_INT 21
94472: PUSH
94473: LD_INT 22
94475: PUSH
94476: LD_INT 23
94478: PUSH
94479: LD_INT 24
94481: PUSH
94482: LD_INT 25
94484: PUSH
94485: LD_INT 26
94487: PUSH
94488: LD_INT 27
94490: PUSH
94491: LD_INT 28
94493: PUSH
94494: LD_INT 29
94496: PUSH
94497: LD_INT 30
94499: PUSH
94500: LD_INT 31
94502: PUSH
94503: LD_INT 32
94505: PUSH
94506: LD_INT 33
94508: PUSH
94509: LD_INT 34
94511: PUSH
94512: LD_INT 36
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: PUSH
94552: LD_INT 101
94554: PUSH
94555: LD_INT 102
94557: PUSH
94558: LD_INT 103
94560: PUSH
94561: LD_INT 104
94563: PUSH
94564: LD_INT 105
94566: PUSH
94567: LD_INT 106
94569: PUSH
94570: LD_INT 107
94572: PUSH
94573: LD_INT 108
94575: PUSH
94576: LD_INT 109
94578: PUSH
94579: LD_INT 110
94581: PUSH
94582: LD_INT 111
94584: PUSH
94585: LD_INT 112
94587: PUSH
94588: LD_INT 113
94590: PUSH
94591: LD_INT 114
94593: PUSH
94594: EMPTY
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: PUSH
94610: EMPTY
94611: LIST
94612: LIST
94613: ST_TO_ADDR
94614: GO 95561
94616: LD_INT 15
94618: DOUBLE
94619: EQUAL
94620: IFTRUE 94624
94622: GO 94836
94624: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
94625: LD_ADDR_VAR 0 1
94629: PUSH
94630: LD_INT 1
94632: PUSH
94633: LD_INT 2
94635: PUSH
94636: LD_INT 3
94638: PUSH
94639: LD_INT 4
94641: PUSH
94642: LD_INT 5
94644: PUSH
94645: LD_INT 6
94647: PUSH
94648: LD_INT 7
94650: PUSH
94651: LD_INT 8
94653: PUSH
94654: LD_INT 9
94656: PUSH
94657: LD_INT 10
94659: PUSH
94660: LD_INT 11
94662: PUSH
94663: LD_INT 12
94665: PUSH
94666: LD_INT 13
94668: PUSH
94669: LD_INT 14
94671: PUSH
94672: LD_INT 15
94674: PUSH
94675: LD_INT 16
94677: PUSH
94678: LD_INT 17
94680: PUSH
94681: LD_INT 18
94683: PUSH
94684: LD_INT 19
94686: PUSH
94687: LD_INT 20
94689: PUSH
94690: LD_INT 21
94692: PUSH
94693: LD_INT 22
94695: PUSH
94696: LD_INT 23
94698: PUSH
94699: LD_INT 24
94701: PUSH
94702: LD_INT 25
94704: PUSH
94705: LD_INT 26
94707: PUSH
94708: LD_INT 27
94710: PUSH
94711: LD_INT 28
94713: PUSH
94714: LD_INT 29
94716: PUSH
94717: LD_INT 30
94719: PUSH
94720: LD_INT 31
94722: PUSH
94723: LD_INT 32
94725: PUSH
94726: LD_INT 33
94728: PUSH
94729: LD_INT 34
94731: PUSH
94732: LD_INT 36
94734: PUSH
94735: EMPTY
94736: LIST
94737: LIST
94738: LIST
94739: LIST
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: PUSH
94772: LD_INT 101
94774: PUSH
94775: LD_INT 102
94777: PUSH
94778: LD_INT 103
94780: PUSH
94781: LD_INT 104
94783: PUSH
94784: LD_INT 105
94786: PUSH
94787: LD_INT 106
94789: PUSH
94790: LD_INT 107
94792: PUSH
94793: LD_INT 108
94795: PUSH
94796: LD_INT 109
94798: PUSH
94799: LD_INT 110
94801: PUSH
94802: LD_INT 111
94804: PUSH
94805: LD_INT 112
94807: PUSH
94808: LD_INT 113
94810: PUSH
94811: LD_INT 114
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: ST_TO_ADDR
94834: GO 95561
94836: LD_INT 16
94838: DOUBLE
94839: EQUAL
94840: IFTRUE 94844
94842: GO 94968
94844: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
94845: LD_ADDR_VAR 0 1
94849: PUSH
94850: LD_INT 2
94852: PUSH
94853: LD_INT 4
94855: PUSH
94856: LD_INT 5
94858: PUSH
94859: LD_INT 7
94861: PUSH
94862: LD_INT 11
94864: PUSH
94865: LD_INT 12
94867: PUSH
94868: LD_INT 15
94870: PUSH
94871: LD_INT 16
94873: PUSH
94874: LD_INT 20
94876: PUSH
94877: LD_INT 21
94879: PUSH
94880: LD_INT 22
94882: PUSH
94883: LD_INT 23
94885: PUSH
94886: LD_INT 25
94888: PUSH
94889: LD_INT 26
94891: PUSH
94892: LD_INT 30
94894: PUSH
94895: LD_INT 31
94897: PUSH
94898: LD_INT 32
94900: PUSH
94901: LD_INT 33
94903: PUSH
94904: LD_INT 34
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: PUSH
94928: LD_INT 101
94930: PUSH
94931: LD_INT 102
94933: PUSH
94934: LD_INT 103
94936: PUSH
94937: LD_INT 106
94939: PUSH
94940: LD_INT 108
94942: PUSH
94943: LD_INT 112
94945: PUSH
94946: LD_INT 113
94948: PUSH
94949: LD_INT 114
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: ST_TO_ADDR
94966: GO 95561
94968: LD_INT 17
94970: DOUBLE
94971: EQUAL
94972: IFTRUE 94976
94974: GO 95188
94976: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
94977: LD_ADDR_VAR 0 1
94981: PUSH
94982: LD_INT 1
94984: PUSH
94985: LD_INT 2
94987: PUSH
94988: LD_INT 3
94990: PUSH
94991: LD_INT 4
94993: PUSH
94994: LD_INT 5
94996: PUSH
94997: LD_INT 6
94999: PUSH
95000: LD_INT 7
95002: PUSH
95003: LD_INT 8
95005: PUSH
95006: LD_INT 9
95008: PUSH
95009: LD_INT 10
95011: PUSH
95012: LD_INT 11
95014: PUSH
95015: LD_INT 12
95017: PUSH
95018: LD_INT 13
95020: PUSH
95021: LD_INT 14
95023: PUSH
95024: LD_INT 15
95026: PUSH
95027: LD_INT 16
95029: PUSH
95030: LD_INT 17
95032: PUSH
95033: LD_INT 18
95035: PUSH
95036: LD_INT 19
95038: PUSH
95039: LD_INT 20
95041: PUSH
95042: LD_INT 21
95044: PUSH
95045: LD_INT 22
95047: PUSH
95048: LD_INT 23
95050: PUSH
95051: LD_INT 24
95053: PUSH
95054: LD_INT 25
95056: PUSH
95057: LD_INT 26
95059: PUSH
95060: LD_INT 27
95062: PUSH
95063: LD_INT 28
95065: PUSH
95066: LD_INT 29
95068: PUSH
95069: LD_INT 30
95071: PUSH
95072: LD_INT 31
95074: PUSH
95075: LD_INT 32
95077: PUSH
95078: LD_INT 33
95080: PUSH
95081: LD_INT 34
95083: PUSH
95084: LD_INT 36
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: PUSH
95124: LD_INT 101
95126: PUSH
95127: LD_INT 102
95129: PUSH
95130: LD_INT 103
95132: PUSH
95133: LD_INT 104
95135: PUSH
95136: LD_INT 105
95138: PUSH
95139: LD_INT 106
95141: PUSH
95142: LD_INT 107
95144: PUSH
95145: LD_INT 108
95147: PUSH
95148: LD_INT 109
95150: PUSH
95151: LD_INT 110
95153: PUSH
95154: LD_INT 111
95156: PUSH
95157: LD_INT 112
95159: PUSH
95160: LD_INT 113
95162: PUSH
95163: LD_INT 114
95165: PUSH
95166: EMPTY
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: PUSH
95182: EMPTY
95183: LIST
95184: LIST
95185: ST_TO_ADDR
95186: GO 95561
95188: LD_INT 18
95190: DOUBLE
95191: EQUAL
95192: IFTRUE 95196
95194: GO 95332
95196: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
95197: LD_ADDR_VAR 0 1
95201: PUSH
95202: LD_INT 2
95204: PUSH
95205: LD_INT 4
95207: PUSH
95208: LD_INT 5
95210: PUSH
95211: LD_INT 7
95213: PUSH
95214: LD_INT 11
95216: PUSH
95217: LD_INT 12
95219: PUSH
95220: LD_INT 15
95222: PUSH
95223: LD_INT 16
95225: PUSH
95226: LD_INT 20
95228: PUSH
95229: LD_INT 21
95231: PUSH
95232: LD_INT 22
95234: PUSH
95235: LD_INT 23
95237: PUSH
95238: LD_INT 25
95240: PUSH
95241: LD_INT 26
95243: PUSH
95244: LD_INT 30
95246: PUSH
95247: LD_INT 31
95249: PUSH
95250: LD_INT 32
95252: PUSH
95253: LD_INT 33
95255: PUSH
95256: LD_INT 34
95258: PUSH
95259: LD_INT 35
95261: PUSH
95262: LD_INT 36
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: LIST
95286: LIST
95287: PUSH
95288: LD_INT 101
95290: PUSH
95291: LD_INT 102
95293: PUSH
95294: LD_INT 103
95296: PUSH
95297: LD_INT 106
95299: PUSH
95300: LD_INT 108
95302: PUSH
95303: LD_INT 112
95305: PUSH
95306: LD_INT 113
95308: PUSH
95309: LD_INT 114
95311: PUSH
95312: LD_INT 115
95314: PUSH
95315: EMPTY
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: PUSH
95326: EMPTY
95327: LIST
95328: LIST
95329: ST_TO_ADDR
95330: GO 95561
95332: LD_INT 19
95334: DOUBLE
95335: EQUAL
95336: IFTRUE 95340
95338: GO 95560
95340: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
95341: LD_ADDR_VAR 0 1
95345: PUSH
95346: LD_INT 1
95348: PUSH
95349: LD_INT 2
95351: PUSH
95352: LD_INT 3
95354: PUSH
95355: LD_INT 4
95357: PUSH
95358: LD_INT 5
95360: PUSH
95361: LD_INT 6
95363: PUSH
95364: LD_INT 7
95366: PUSH
95367: LD_INT 8
95369: PUSH
95370: LD_INT 9
95372: PUSH
95373: LD_INT 10
95375: PUSH
95376: LD_INT 11
95378: PUSH
95379: LD_INT 12
95381: PUSH
95382: LD_INT 13
95384: PUSH
95385: LD_INT 14
95387: PUSH
95388: LD_INT 15
95390: PUSH
95391: LD_INT 16
95393: PUSH
95394: LD_INT 17
95396: PUSH
95397: LD_INT 18
95399: PUSH
95400: LD_INT 19
95402: PUSH
95403: LD_INT 20
95405: PUSH
95406: LD_INT 21
95408: PUSH
95409: LD_INT 22
95411: PUSH
95412: LD_INT 23
95414: PUSH
95415: LD_INT 24
95417: PUSH
95418: LD_INT 25
95420: PUSH
95421: LD_INT 26
95423: PUSH
95424: LD_INT 27
95426: PUSH
95427: LD_INT 28
95429: PUSH
95430: LD_INT 29
95432: PUSH
95433: LD_INT 30
95435: PUSH
95436: LD_INT 31
95438: PUSH
95439: LD_INT 32
95441: PUSH
95442: LD_INT 33
95444: PUSH
95445: LD_INT 34
95447: PUSH
95448: LD_INT 35
95450: PUSH
95451: LD_INT 36
95453: PUSH
95454: EMPTY
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: PUSH
95492: LD_INT 101
95494: PUSH
95495: LD_INT 102
95497: PUSH
95498: LD_INT 103
95500: PUSH
95501: LD_INT 104
95503: PUSH
95504: LD_INT 105
95506: PUSH
95507: LD_INT 106
95509: PUSH
95510: LD_INT 107
95512: PUSH
95513: LD_INT 108
95515: PUSH
95516: LD_INT 109
95518: PUSH
95519: LD_INT 110
95521: PUSH
95522: LD_INT 111
95524: PUSH
95525: LD_INT 112
95527: PUSH
95528: LD_INT 113
95530: PUSH
95531: LD_INT 114
95533: PUSH
95534: LD_INT 115
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: PUSH
95554: EMPTY
95555: LIST
95556: LIST
95557: ST_TO_ADDR
95558: GO 95561
95560: POP
// end else
95561: GO 95780
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
95563: LD_ADDR_VAR 0 1
95567: PUSH
95568: LD_INT 1
95570: PUSH
95571: LD_INT 2
95573: PUSH
95574: LD_INT 3
95576: PUSH
95577: LD_INT 4
95579: PUSH
95580: LD_INT 5
95582: PUSH
95583: LD_INT 6
95585: PUSH
95586: LD_INT 7
95588: PUSH
95589: LD_INT 8
95591: PUSH
95592: LD_INT 9
95594: PUSH
95595: LD_INT 10
95597: PUSH
95598: LD_INT 11
95600: PUSH
95601: LD_INT 12
95603: PUSH
95604: LD_INT 13
95606: PUSH
95607: LD_INT 14
95609: PUSH
95610: LD_INT 15
95612: PUSH
95613: LD_INT 16
95615: PUSH
95616: LD_INT 17
95618: PUSH
95619: LD_INT 18
95621: PUSH
95622: LD_INT 19
95624: PUSH
95625: LD_INT 20
95627: PUSH
95628: LD_INT 21
95630: PUSH
95631: LD_INT 22
95633: PUSH
95634: LD_INT 23
95636: PUSH
95637: LD_INT 24
95639: PUSH
95640: LD_INT 25
95642: PUSH
95643: LD_INT 26
95645: PUSH
95646: LD_INT 27
95648: PUSH
95649: LD_INT 28
95651: PUSH
95652: LD_INT 29
95654: PUSH
95655: LD_INT 30
95657: PUSH
95658: LD_INT 31
95660: PUSH
95661: LD_INT 32
95663: PUSH
95664: LD_INT 33
95666: PUSH
95667: LD_INT 34
95669: PUSH
95670: LD_INT 35
95672: PUSH
95673: LD_INT 36
95675: PUSH
95676: EMPTY
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: PUSH
95714: LD_INT 101
95716: PUSH
95717: LD_INT 102
95719: PUSH
95720: LD_INT 103
95722: PUSH
95723: LD_INT 104
95725: PUSH
95726: LD_INT 105
95728: PUSH
95729: LD_INT 106
95731: PUSH
95732: LD_INT 107
95734: PUSH
95735: LD_INT 108
95737: PUSH
95738: LD_INT 109
95740: PUSH
95741: LD_INT 110
95743: PUSH
95744: LD_INT 111
95746: PUSH
95747: LD_INT 112
95749: PUSH
95750: LD_INT 113
95752: PUSH
95753: LD_INT 114
95755: PUSH
95756: LD_INT 115
95758: PUSH
95759: EMPTY
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: PUSH
95776: EMPTY
95777: LIST
95778: LIST
95779: ST_TO_ADDR
// if result then
95780: LD_VAR 0 1
95784: IFFALSE 96073
// begin normal :=  ;
95786: LD_ADDR_VAR 0 3
95790: PUSH
95791: LD_STRING 
95793: ST_TO_ADDR
// hardcore :=  ;
95794: LD_ADDR_VAR 0 4
95798: PUSH
95799: LD_STRING 
95801: ST_TO_ADDR
// for i = 1 to normalCounter do
95802: LD_ADDR_VAR 0 5
95806: PUSH
95807: DOUBLE
95808: LD_INT 1
95810: DEC
95811: ST_TO_ADDR
95812: LD_EXP 138
95816: PUSH
95817: FOR_TO
95818: IFFALSE 95919
// begin tmp := 0 ;
95820: LD_ADDR_VAR 0 2
95824: PUSH
95825: LD_STRING 0
95827: ST_TO_ADDR
// if result [ 1 ] then
95828: LD_VAR 0 1
95832: PUSH
95833: LD_INT 1
95835: ARRAY
95836: IFFALSE 95901
// if result [ 1 ] [ 1 ] = i then
95838: LD_VAR 0 1
95842: PUSH
95843: LD_INT 1
95845: ARRAY
95846: PUSH
95847: LD_INT 1
95849: ARRAY
95850: PUSH
95851: LD_VAR 0 5
95855: EQUAL
95856: IFFALSE 95901
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95858: LD_ADDR_VAR 0 1
95862: PUSH
95863: LD_VAR 0 1
95867: PPUSH
95868: LD_INT 1
95870: PPUSH
95871: LD_VAR 0 1
95875: PUSH
95876: LD_INT 1
95878: ARRAY
95879: PPUSH
95880: LD_INT 1
95882: PPUSH
95883: CALL_OW 3
95887: PPUSH
95888: CALL_OW 1
95892: ST_TO_ADDR
// tmp := 1 ;
95893: LD_ADDR_VAR 0 2
95897: PUSH
95898: LD_STRING 1
95900: ST_TO_ADDR
// end ; normal := normal & tmp ;
95901: LD_ADDR_VAR 0 3
95905: PUSH
95906: LD_VAR 0 3
95910: PUSH
95911: LD_VAR 0 2
95915: STR
95916: ST_TO_ADDR
// end ;
95917: GO 95817
95919: POP
95920: POP
// for i = 1 to hardcoreCounter do
95921: LD_ADDR_VAR 0 5
95925: PUSH
95926: DOUBLE
95927: LD_INT 1
95929: DEC
95930: ST_TO_ADDR
95931: LD_EXP 139
95935: PUSH
95936: FOR_TO
95937: IFFALSE 96042
// begin tmp := 0 ;
95939: LD_ADDR_VAR 0 2
95943: PUSH
95944: LD_STRING 0
95946: ST_TO_ADDR
// if result [ 2 ] then
95947: LD_VAR 0 1
95951: PUSH
95952: LD_INT 2
95954: ARRAY
95955: IFFALSE 96024
// if result [ 2 ] [ 1 ] = 100 + i then
95957: LD_VAR 0 1
95961: PUSH
95962: LD_INT 2
95964: ARRAY
95965: PUSH
95966: LD_INT 1
95968: ARRAY
95969: PUSH
95970: LD_INT 100
95972: PUSH
95973: LD_VAR 0 5
95977: PLUS
95978: EQUAL
95979: IFFALSE 96024
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95981: LD_ADDR_VAR 0 1
95985: PUSH
95986: LD_VAR 0 1
95990: PPUSH
95991: LD_INT 2
95993: PPUSH
95994: LD_VAR 0 1
95998: PUSH
95999: LD_INT 2
96001: ARRAY
96002: PPUSH
96003: LD_INT 1
96005: PPUSH
96006: CALL_OW 3
96010: PPUSH
96011: CALL_OW 1
96015: ST_TO_ADDR
// tmp := 1 ;
96016: LD_ADDR_VAR 0 2
96020: PUSH
96021: LD_STRING 1
96023: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96024: LD_ADDR_VAR 0 4
96028: PUSH
96029: LD_VAR 0 4
96033: PUSH
96034: LD_VAR 0 2
96038: STR
96039: ST_TO_ADDR
// end ;
96040: GO 95936
96042: POP
96043: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
96044: LD_STRING getStreamItemsFromMission("
96046: PUSH
96047: LD_VAR 0 3
96051: STR
96052: PUSH
96053: LD_STRING ","
96055: STR
96056: PUSH
96057: LD_VAR 0 4
96061: STR
96062: PUSH
96063: LD_STRING ")
96065: STR
96066: PPUSH
96067: CALL_OW 559
// end else
96071: GO 96080
// ToLua ( getStreamItemsFromMission("","") ) ;
96073: LD_STRING getStreamItemsFromMission("","")
96075: PPUSH
96076: CALL_OW 559
// end ;
96080: LD_VAR 0 1
96084: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96085: LD_EXP 137
96089: PUSH
96090: LD_EXP 142
96094: AND
96095: IFFALSE 96219
96097: GO 96099
96099: DISABLE
96100: LD_INT 0
96102: PPUSH
96103: PPUSH
// begin enable ;
96104: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96105: LD_ADDR_VAR 0 2
96109: PUSH
96110: LD_INT 22
96112: PUSH
96113: LD_OWVAR 2
96117: PUSH
96118: EMPTY
96119: LIST
96120: LIST
96121: PUSH
96122: LD_INT 2
96124: PUSH
96125: LD_INT 34
96127: PUSH
96128: LD_INT 7
96130: PUSH
96131: EMPTY
96132: LIST
96133: LIST
96134: PUSH
96135: LD_INT 34
96137: PUSH
96138: LD_INT 45
96140: PUSH
96141: EMPTY
96142: LIST
96143: LIST
96144: PUSH
96145: LD_INT 34
96147: PUSH
96148: LD_INT 28
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: PUSH
96155: LD_INT 34
96157: PUSH
96158: LD_INT 47
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: PUSH
96165: EMPTY
96166: LIST
96167: LIST
96168: LIST
96169: LIST
96170: LIST
96171: PUSH
96172: EMPTY
96173: LIST
96174: LIST
96175: PPUSH
96176: CALL_OW 69
96180: ST_TO_ADDR
// if not tmp then
96181: LD_VAR 0 2
96185: NOT
96186: IFFALSE 96190
// exit ;
96188: GO 96219
// for i in tmp do
96190: LD_ADDR_VAR 0 1
96194: PUSH
96195: LD_VAR 0 2
96199: PUSH
96200: FOR_IN
96201: IFFALSE 96217
// begin SetLives ( i , 0 ) ;
96203: LD_VAR 0 1
96207: PPUSH
96208: LD_INT 0
96210: PPUSH
96211: CALL_OW 234
// end ;
96215: GO 96200
96217: POP
96218: POP
// end ;
96219: PPOPN 2
96221: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96222: LD_EXP 137
96226: PUSH
96227: LD_EXP 143
96231: AND
96232: IFFALSE 96316
96234: GO 96236
96236: DISABLE
96237: LD_INT 0
96239: PPUSH
96240: PPUSH
// begin enable ;
96241: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96242: LD_ADDR_VAR 0 2
96246: PUSH
96247: LD_INT 22
96249: PUSH
96250: LD_OWVAR 2
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: LD_INT 32
96261: PUSH
96262: LD_INT 3
96264: PUSH
96265: EMPTY
96266: LIST
96267: LIST
96268: PUSH
96269: EMPTY
96270: LIST
96271: LIST
96272: PPUSH
96273: CALL_OW 69
96277: ST_TO_ADDR
// if not tmp then
96278: LD_VAR 0 2
96282: NOT
96283: IFFALSE 96287
// exit ;
96285: GO 96316
// for i in tmp do
96287: LD_ADDR_VAR 0 1
96291: PUSH
96292: LD_VAR 0 2
96296: PUSH
96297: FOR_IN
96298: IFFALSE 96314
// begin SetLives ( i , 0 ) ;
96300: LD_VAR 0 1
96304: PPUSH
96305: LD_INT 0
96307: PPUSH
96308: CALL_OW 234
// end ;
96312: GO 96297
96314: POP
96315: POP
// end ;
96316: PPOPN 2
96318: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96319: LD_EXP 137
96323: PUSH
96324: LD_EXP 140
96328: AND
96329: IFFALSE 96422
96331: GO 96333
96333: DISABLE
96334: LD_INT 0
96336: PPUSH
// begin enable ;
96337: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96338: LD_ADDR_VAR 0 1
96342: PUSH
96343: LD_INT 22
96345: PUSH
96346: LD_OWVAR 2
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: PUSH
96355: LD_INT 2
96357: PUSH
96358: LD_INT 25
96360: PUSH
96361: LD_INT 5
96363: PUSH
96364: EMPTY
96365: LIST
96366: LIST
96367: PUSH
96368: LD_INT 25
96370: PUSH
96371: LD_INT 9
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: PUSH
96378: LD_INT 25
96380: PUSH
96381: LD_INT 8
96383: PUSH
96384: EMPTY
96385: LIST
96386: LIST
96387: PUSH
96388: EMPTY
96389: LIST
96390: LIST
96391: LIST
96392: LIST
96393: PUSH
96394: EMPTY
96395: LIST
96396: LIST
96397: PPUSH
96398: CALL_OW 69
96402: PUSH
96403: FOR_IN
96404: IFFALSE 96420
// begin SetClass ( i , 1 ) ;
96406: LD_VAR 0 1
96410: PPUSH
96411: LD_INT 1
96413: PPUSH
96414: CALL_OW 336
// end ;
96418: GO 96403
96420: POP
96421: POP
// end ;
96422: PPOPN 1
96424: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96425: LD_EXP 137
96429: PUSH
96430: LD_EXP 141
96434: AND
96435: PUSH
96436: LD_OWVAR 65
96440: PUSH
96441: LD_INT 7
96443: LESS
96444: AND
96445: IFFALSE 96459
96447: GO 96449
96449: DISABLE
// begin enable ;
96450: ENABLE
// game_speed := 7 ;
96451: LD_ADDR_OWVAR 65
96455: PUSH
96456: LD_INT 7
96458: ST_TO_ADDR
// end ;
96459: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96460: LD_EXP 137
96464: PUSH
96465: LD_EXP 144
96469: AND
96470: IFFALSE 96672
96472: GO 96474
96474: DISABLE
96475: LD_INT 0
96477: PPUSH
96478: PPUSH
96479: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96480: LD_ADDR_VAR 0 3
96484: PUSH
96485: LD_INT 81
96487: PUSH
96488: LD_OWVAR 2
96492: PUSH
96493: EMPTY
96494: LIST
96495: LIST
96496: PUSH
96497: LD_INT 21
96499: PUSH
96500: LD_INT 1
96502: PUSH
96503: EMPTY
96504: LIST
96505: LIST
96506: PUSH
96507: EMPTY
96508: LIST
96509: LIST
96510: PPUSH
96511: CALL_OW 69
96515: ST_TO_ADDR
// if not tmp then
96516: LD_VAR 0 3
96520: NOT
96521: IFFALSE 96525
// exit ;
96523: GO 96672
// if tmp > 5 then
96525: LD_VAR 0 3
96529: PUSH
96530: LD_INT 5
96532: GREATER
96533: IFFALSE 96545
// k := 5 else
96535: LD_ADDR_VAR 0 2
96539: PUSH
96540: LD_INT 5
96542: ST_TO_ADDR
96543: GO 96555
// k := tmp ;
96545: LD_ADDR_VAR 0 2
96549: PUSH
96550: LD_VAR 0 3
96554: ST_TO_ADDR
// for i := 1 to k do
96555: LD_ADDR_VAR 0 1
96559: PUSH
96560: DOUBLE
96561: LD_INT 1
96563: DEC
96564: ST_TO_ADDR
96565: LD_VAR 0 2
96569: PUSH
96570: FOR_TO
96571: IFFALSE 96670
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96573: LD_VAR 0 3
96577: PUSH
96578: LD_VAR 0 1
96582: ARRAY
96583: PPUSH
96584: LD_VAR 0 1
96588: PUSH
96589: LD_INT 4
96591: MOD
96592: PUSH
96593: LD_INT 1
96595: PLUS
96596: PPUSH
96597: CALL_OW 259
96601: PUSH
96602: LD_INT 10
96604: LESS
96605: IFFALSE 96668
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96607: LD_VAR 0 3
96611: PUSH
96612: LD_VAR 0 1
96616: ARRAY
96617: PPUSH
96618: LD_VAR 0 1
96622: PUSH
96623: LD_INT 4
96625: MOD
96626: PUSH
96627: LD_INT 1
96629: PLUS
96630: PPUSH
96631: LD_VAR 0 3
96635: PUSH
96636: LD_VAR 0 1
96640: ARRAY
96641: PPUSH
96642: LD_VAR 0 1
96646: PUSH
96647: LD_INT 4
96649: MOD
96650: PUSH
96651: LD_INT 1
96653: PLUS
96654: PPUSH
96655: CALL_OW 259
96659: PUSH
96660: LD_INT 1
96662: PLUS
96663: PPUSH
96664: CALL_OW 237
96668: GO 96570
96670: POP
96671: POP
// end ;
96672: PPOPN 3
96674: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96675: LD_EXP 137
96679: PUSH
96680: LD_EXP 145
96684: AND
96685: IFFALSE 96705
96687: GO 96689
96689: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96690: LD_INT 4
96692: PPUSH
96693: LD_OWVAR 2
96697: PPUSH
96698: LD_INT 0
96700: PPUSH
96701: CALL_OW 324
96705: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96706: LD_EXP 137
96710: PUSH
96711: LD_EXP 174
96715: AND
96716: IFFALSE 96736
96718: GO 96720
96720: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96721: LD_INT 19
96723: PPUSH
96724: LD_OWVAR 2
96728: PPUSH
96729: LD_INT 0
96731: PPUSH
96732: CALL_OW 324
96736: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96737: LD_EXP 137
96741: PUSH
96742: LD_EXP 146
96746: AND
96747: IFFALSE 96849
96749: GO 96751
96751: DISABLE
96752: LD_INT 0
96754: PPUSH
96755: PPUSH
// begin enable ;
96756: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96757: LD_ADDR_VAR 0 2
96761: PUSH
96762: LD_INT 22
96764: PUSH
96765: LD_OWVAR 2
96769: PUSH
96770: EMPTY
96771: LIST
96772: LIST
96773: PUSH
96774: LD_INT 2
96776: PUSH
96777: LD_INT 34
96779: PUSH
96780: LD_INT 11
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: PUSH
96787: LD_INT 34
96789: PUSH
96790: LD_INT 30
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: EMPTY
96798: LIST
96799: LIST
96800: LIST
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PPUSH
96806: CALL_OW 69
96810: ST_TO_ADDR
// if not tmp then
96811: LD_VAR 0 2
96815: NOT
96816: IFFALSE 96820
// exit ;
96818: GO 96849
// for i in tmp do
96820: LD_ADDR_VAR 0 1
96824: PUSH
96825: LD_VAR 0 2
96829: PUSH
96830: FOR_IN
96831: IFFALSE 96847
// begin SetLives ( i , 0 ) ;
96833: LD_VAR 0 1
96837: PPUSH
96838: LD_INT 0
96840: PPUSH
96841: CALL_OW 234
// end ;
96845: GO 96830
96847: POP
96848: POP
// end ;
96849: PPOPN 2
96851: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96852: LD_EXP 137
96856: PUSH
96857: LD_EXP 147
96861: AND
96862: IFFALSE 96882
96864: GO 96866
96866: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96867: LD_INT 32
96869: PPUSH
96870: LD_OWVAR 2
96874: PPUSH
96875: LD_INT 0
96877: PPUSH
96878: CALL_OW 324
96882: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96883: LD_EXP 137
96887: PUSH
96888: LD_EXP 148
96892: AND
96893: IFFALSE 97074
96895: GO 96897
96897: DISABLE
96898: LD_INT 0
96900: PPUSH
96901: PPUSH
96902: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96903: LD_ADDR_VAR 0 2
96907: PUSH
96908: LD_INT 22
96910: PUSH
96911: LD_OWVAR 2
96915: PUSH
96916: EMPTY
96917: LIST
96918: LIST
96919: PUSH
96920: LD_INT 33
96922: PUSH
96923: LD_INT 3
96925: PUSH
96926: EMPTY
96927: LIST
96928: LIST
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: PPUSH
96934: CALL_OW 69
96938: ST_TO_ADDR
// if not tmp then
96939: LD_VAR 0 2
96943: NOT
96944: IFFALSE 96948
// exit ;
96946: GO 97074
// side := 0 ;
96948: LD_ADDR_VAR 0 3
96952: PUSH
96953: LD_INT 0
96955: ST_TO_ADDR
// for i := 1 to 8 do
96956: LD_ADDR_VAR 0 1
96960: PUSH
96961: DOUBLE
96962: LD_INT 1
96964: DEC
96965: ST_TO_ADDR
96966: LD_INT 8
96968: PUSH
96969: FOR_TO
96970: IFFALSE 97018
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96972: LD_OWVAR 2
96976: PUSH
96977: LD_VAR 0 1
96981: NONEQUAL
96982: PUSH
96983: LD_OWVAR 2
96987: PPUSH
96988: LD_VAR 0 1
96992: PPUSH
96993: CALL_OW 81
96997: PUSH
96998: LD_INT 2
97000: EQUAL
97001: AND
97002: IFFALSE 97016
// begin side := i ;
97004: LD_ADDR_VAR 0 3
97008: PUSH
97009: LD_VAR 0 1
97013: ST_TO_ADDR
// break ;
97014: GO 97018
// end ;
97016: GO 96969
97018: POP
97019: POP
// if not side then
97020: LD_VAR 0 3
97024: NOT
97025: IFFALSE 97029
// exit ;
97027: GO 97074
// for i := 1 to tmp do
97029: LD_ADDR_VAR 0 1
97033: PUSH
97034: DOUBLE
97035: LD_INT 1
97037: DEC
97038: ST_TO_ADDR
97039: LD_VAR 0 2
97043: PUSH
97044: FOR_TO
97045: IFFALSE 97072
// if Prob ( 60 ) then
97047: LD_INT 60
97049: PPUSH
97050: CALL_OW 13
97054: IFFALSE 97070
// SetSide ( i , side ) ;
97056: LD_VAR 0 1
97060: PPUSH
97061: LD_VAR 0 3
97065: PPUSH
97066: CALL_OW 235
97070: GO 97044
97072: POP
97073: POP
// end ;
97074: PPOPN 3
97076: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97077: LD_EXP 137
97081: PUSH
97082: LD_EXP 150
97086: AND
97087: IFFALSE 97206
97089: GO 97091
97091: DISABLE
97092: LD_INT 0
97094: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97095: LD_ADDR_VAR 0 1
97099: PUSH
97100: LD_INT 22
97102: PUSH
97103: LD_OWVAR 2
97107: PUSH
97108: EMPTY
97109: LIST
97110: LIST
97111: PUSH
97112: LD_INT 21
97114: PUSH
97115: LD_INT 1
97117: PUSH
97118: EMPTY
97119: LIST
97120: LIST
97121: PUSH
97122: LD_INT 3
97124: PUSH
97125: LD_INT 23
97127: PUSH
97128: LD_INT 0
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: PUSH
97135: EMPTY
97136: LIST
97137: LIST
97138: PUSH
97139: EMPTY
97140: LIST
97141: LIST
97142: LIST
97143: PPUSH
97144: CALL_OW 69
97148: PUSH
97149: FOR_IN
97150: IFFALSE 97204
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97152: LD_VAR 0 1
97156: PPUSH
97157: CALL_OW 257
97161: PUSH
97162: LD_INT 1
97164: PUSH
97165: LD_INT 2
97167: PUSH
97168: LD_INT 3
97170: PUSH
97171: LD_INT 4
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: IN
97180: IFFALSE 97202
// SetClass ( un , rand ( 1 , 4 ) ) ;
97182: LD_VAR 0 1
97186: PPUSH
97187: LD_INT 1
97189: PPUSH
97190: LD_INT 4
97192: PPUSH
97193: CALL_OW 12
97197: PPUSH
97198: CALL_OW 336
97202: GO 97149
97204: POP
97205: POP
// end ;
97206: PPOPN 1
97208: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97209: LD_EXP 137
97213: PUSH
97214: LD_EXP 149
97218: AND
97219: IFFALSE 97298
97221: GO 97223
97223: DISABLE
97224: LD_INT 0
97226: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97227: LD_ADDR_VAR 0 1
97231: PUSH
97232: LD_INT 22
97234: PUSH
97235: LD_OWVAR 2
97239: PUSH
97240: EMPTY
97241: LIST
97242: LIST
97243: PUSH
97244: LD_INT 21
97246: PUSH
97247: LD_INT 3
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: PPUSH
97258: CALL_OW 69
97262: ST_TO_ADDR
// if not tmp then
97263: LD_VAR 0 1
97267: NOT
97268: IFFALSE 97272
// exit ;
97270: GO 97298
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97272: LD_VAR 0 1
97276: PUSH
97277: LD_INT 1
97279: PPUSH
97280: LD_VAR 0 1
97284: PPUSH
97285: CALL_OW 12
97289: ARRAY
97290: PPUSH
97291: LD_INT 100
97293: PPUSH
97294: CALL_OW 234
// end ;
97298: PPOPN 1
97300: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97301: LD_EXP 137
97305: PUSH
97306: LD_EXP 151
97310: AND
97311: IFFALSE 97409
97313: GO 97315
97315: DISABLE
97316: LD_INT 0
97318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97319: LD_ADDR_VAR 0 1
97323: PUSH
97324: LD_INT 22
97326: PUSH
97327: LD_OWVAR 2
97331: PUSH
97332: EMPTY
97333: LIST
97334: LIST
97335: PUSH
97336: LD_INT 21
97338: PUSH
97339: LD_INT 1
97341: PUSH
97342: EMPTY
97343: LIST
97344: LIST
97345: PUSH
97346: EMPTY
97347: LIST
97348: LIST
97349: PPUSH
97350: CALL_OW 69
97354: ST_TO_ADDR
// if not tmp then
97355: LD_VAR 0 1
97359: NOT
97360: IFFALSE 97364
// exit ;
97362: GO 97409
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97364: LD_VAR 0 1
97368: PUSH
97369: LD_INT 1
97371: PPUSH
97372: LD_VAR 0 1
97376: PPUSH
97377: CALL_OW 12
97381: ARRAY
97382: PPUSH
97383: LD_INT 1
97385: PPUSH
97386: LD_INT 4
97388: PPUSH
97389: CALL_OW 12
97393: PPUSH
97394: LD_INT 3000
97396: PPUSH
97397: LD_INT 9000
97399: PPUSH
97400: CALL_OW 12
97404: PPUSH
97405: CALL_OW 492
// end ;
97409: PPOPN 1
97411: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97412: LD_EXP 137
97416: PUSH
97417: LD_EXP 152
97421: AND
97422: IFFALSE 97442
97424: GO 97426
97426: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97427: LD_INT 1
97429: PPUSH
97430: LD_OWVAR 2
97434: PPUSH
97435: LD_INT 0
97437: PPUSH
97438: CALL_OW 324
97442: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97443: LD_EXP 137
97447: PUSH
97448: LD_EXP 153
97452: AND
97453: IFFALSE 97536
97455: GO 97457
97457: DISABLE
97458: LD_INT 0
97460: PPUSH
97461: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97462: LD_ADDR_VAR 0 2
97466: PUSH
97467: LD_INT 22
97469: PUSH
97470: LD_OWVAR 2
97474: PUSH
97475: EMPTY
97476: LIST
97477: LIST
97478: PUSH
97479: LD_INT 21
97481: PUSH
97482: LD_INT 3
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: PUSH
97489: EMPTY
97490: LIST
97491: LIST
97492: PPUSH
97493: CALL_OW 69
97497: ST_TO_ADDR
// if not tmp then
97498: LD_VAR 0 2
97502: NOT
97503: IFFALSE 97507
// exit ;
97505: GO 97536
// for i in tmp do
97507: LD_ADDR_VAR 0 1
97511: PUSH
97512: LD_VAR 0 2
97516: PUSH
97517: FOR_IN
97518: IFFALSE 97534
// SetBLevel ( i , 10 ) ;
97520: LD_VAR 0 1
97524: PPUSH
97525: LD_INT 10
97527: PPUSH
97528: CALL_OW 241
97532: GO 97517
97534: POP
97535: POP
// end ;
97536: PPOPN 2
97538: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97539: LD_EXP 137
97543: PUSH
97544: LD_EXP 154
97548: AND
97549: IFFALSE 97660
97551: GO 97553
97553: DISABLE
97554: LD_INT 0
97556: PPUSH
97557: PPUSH
97558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97559: LD_ADDR_VAR 0 3
97563: PUSH
97564: LD_INT 22
97566: PUSH
97567: LD_OWVAR 2
97571: PUSH
97572: EMPTY
97573: LIST
97574: LIST
97575: PUSH
97576: LD_INT 25
97578: PUSH
97579: LD_INT 1
97581: PUSH
97582: EMPTY
97583: LIST
97584: LIST
97585: PUSH
97586: EMPTY
97587: LIST
97588: LIST
97589: PPUSH
97590: CALL_OW 69
97594: ST_TO_ADDR
// if not tmp then
97595: LD_VAR 0 3
97599: NOT
97600: IFFALSE 97604
// exit ;
97602: GO 97660
// un := tmp [ rand ( 1 , tmp ) ] ;
97604: LD_ADDR_VAR 0 2
97608: PUSH
97609: LD_VAR 0 3
97613: PUSH
97614: LD_INT 1
97616: PPUSH
97617: LD_VAR 0 3
97621: PPUSH
97622: CALL_OW 12
97626: ARRAY
97627: ST_TO_ADDR
// if Crawls ( un ) then
97628: LD_VAR 0 2
97632: PPUSH
97633: CALL_OW 318
97637: IFFALSE 97648
// ComWalk ( un ) ;
97639: LD_VAR 0 2
97643: PPUSH
97644: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97648: LD_VAR 0 2
97652: PPUSH
97653: LD_INT 5
97655: PPUSH
97656: CALL_OW 336
// end ;
97660: PPOPN 3
97662: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97663: LD_EXP 137
97667: PUSH
97668: LD_EXP 155
97672: AND
97673: PUSH
97674: LD_OWVAR 67
97678: PUSH
97679: LD_INT 4
97681: LESS
97682: AND
97683: IFFALSE 97702
97685: GO 97687
97687: DISABLE
// begin Difficulty := Difficulty + 1 ;
97688: LD_ADDR_OWVAR 67
97692: PUSH
97693: LD_OWVAR 67
97697: PUSH
97698: LD_INT 1
97700: PLUS
97701: ST_TO_ADDR
// end ;
97702: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97703: LD_EXP 137
97707: PUSH
97708: LD_EXP 156
97712: AND
97713: IFFALSE 97816
97715: GO 97717
97717: DISABLE
97718: LD_INT 0
97720: PPUSH
// begin for i := 1 to 5 do
97721: LD_ADDR_VAR 0 1
97725: PUSH
97726: DOUBLE
97727: LD_INT 1
97729: DEC
97730: ST_TO_ADDR
97731: LD_INT 5
97733: PUSH
97734: FOR_TO
97735: IFFALSE 97814
// begin uc_nation := nation_nature ;
97737: LD_ADDR_OWVAR 21
97741: PUSH
97742: LD_INT 0
97744: ST_TO_ADDR
// uc_side := 0 ;
97745: LD_ADDR_OWVAR 20
97749: PUSH
97750: LD_INT 0
97752: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97753: LD_ADDR_OWVAR 29
97757: PUSH
97758: LD_INT 12
97760: PUSH
97761: LD_INT 12
97763: PUSH
97764: EMPTY
97765: LIST
97766: LIST
97767: ST_TO_ADDR
// hc_agressivity := 20 ;
97768: LD_ADDR_OWVAR 35
97772: PUSH
97773: LD_INT 20
97775: ST_TO_ADDR
// hc_class := class_tiger ;
97776: LD_ADDR_OWVAR 28
97780: PUSH
97781: LD_INT 14
97783: ST_TO_ADDR
// hc_gallery :=  ;
97784: LD_ADDR_OWVAR 33
97788: PUSH
97789: LD_STRING 
97791: ST_TO_ADDR
// hc_name :=  ;
97792: LD_ADDR_OWVAR 26
97796: PUSH
97797: LD_STRING 
97799: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97800: CALL_OW 44
97804: PPUSH
97805: LD_INT 0
97807: PPUSH
97808: CALL_OW 51
// end ;
97812: GO 97734
97814: POP
97815: POP
// end ;
97816: PPOPN 1
97818: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97819: LD_EXP 137
97823: PUSH
97824: LD_EXP 157
97828: AND
97829: IFFALSE 97838
97831: GO 97833
97833: DISABLE
// StreamSibBomb ;
97834: CALL 97839 0 0
97838: END
// export function StreamSibBomb ; var i , x , y ; begin
97839: LD_INT 0
97841: PPUSH
97842: PPUSH
97843: PPUSH
97844: PPUSH
// result := false ;
97845: LD_ADDR_VAR 0 1
97849: PUSH
97850: LD_INT 0
97852: ST_TO_ADDR
// for i := 1 to 16 do
97853: LD_ADDR_VAR 0 2
97857: PUSH
97858: DOUBLE
97859: LD_INT 1
97861: DEC
97862: ST_TO_ADDR
97863: LD_INT 16
97865: PUSH
97866: FOR_TO
97867: IFFALSE 98066
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97869: LD_ADDR_VAR 0 3
97873: PUSH
97874: LD_INT 10
97876: PUSH
97877: LD_INT 20
97879: PUSH
97880: LD_INT 30
97882: PUSH
97883: LD_INT 40
97885: PUSH
97886: LD_INT 50
97888: PUSH
97889: LD_INT 60
97891: PUSH
97892: LD_INT 70
97894: PUSH
97895: LD_INT 80
97897: PUSH
97898: LD_INT 90
97900: PUSH
97901: LD_INT 100
97903: PUSH
97904: LD_INT 110
97906: PUSH
97907: LD_INT 120
97909: PUSH
97910: LD_INT 130
97912: PUSH
97913: LD_INT 140
97915: PUSH
97916: LD_INT 150
97918: PUSH
97919: EMPTY
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: PUSH
97936: LD_INT 1
97938: PPUSH
97939: LD_INT 15
97941: PPUSH
97942: CALL_OW 12
97946: ARRAY
97947: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97948: LD_ADDR_VAR 0 4
97952: PUSH
97953: LD_INT 10
97955: PUSH
97956: LD_INT 20
97958: PUSH
97959: LD_INT 30
97961: PUSH
97962: LD_INT 40
97964: PUSH
97965: LD_INT 50
97967: PUSH
97968: LD_INT 60
97970: PUSH
97971: LD_INT 70
97973: PUSH
97974: LD_INT 80
97976: PUSH
97977: LD_INT 90
97979: PUSH
97980: LD_INT 100
97982: PUSH
97983: LD_INT 110
97985: PUSH
97986: LD_INT 120
97988: PUSH
97989: LD_INT 130
97991: PUSH
97992: LD_INT 140
97994: PUSH
97995: LD_INT 150
97997: PUSH
97998: EMPTY
97999: LIST
98000: LIST
98001: LIST
98002: LIST
98003: LIST
98004: LIST
98005: LIST
98006: LIST
98007: LIST
98008: LIST
98009: LIST
98010: LIST
98011: LIST
98012: LIST
98013: LIST
98014: PUSH
98015: LD_INT 1
98017: PPUSH
98018: LD_INT 15
98020: PPUSH
98021: CALL_OW 12
98025: ARRAY
98026: ST_TO_ADDR
// if ValidHex ( x , y ) then
98027: LD_VAR 0 3
98031: PPUSH
98032: LD_VAR 0 4
98036: PPUSH
98037: CALL_OW 488
98041: IFFALSE 98064
// begin result := [ x , y ] ;
98043: LD_ADDR_VAR 0 1
98047: PUSH
98048: LD_VAR 0 3
98052: PUSH
98053: LD_VAR 0 4
98057: PUSH
98058: EMPTY
98059: LIST
98060: LIST
98061: ST_TO_ADDR
// break ;
98062: GO 98066
// end ; end ;
98064: GO 97866
98066: POP
98067: POP
// if result then
98068: LD_VAR 0 1
98072: IFFALSE 98132
// begin ToLua ( playSibBomb() ) ;
98074: LD_STRING playSibBomb()
98076: PPUSH
98077: CALL_OW 559
// wait ( 0 0$14 ) ;
98081: LD_INT 490
98083: PPUSH
98084: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98088: LD_VAR 0 1
98092: PUSH
98093: LD_INT 1
98095: ARRAY
98096: PPUSH
98097: LD_VAR 0 1
98101: PUSH
98102: LD_INT 2
98104: ARRAY
98105: PPUSH
98106: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98110: LD_VAR 0 1
98114: PUSH
98115: LD_INT 1
98117: ARRAY
98118: PPUSH
98119: LD_VAR 0 1
98123: PUSH
98124: LD_INT 2
98126: ARRAY
98127: PPUSH
98128: CALL_OW 429
// end ; end ;
98132: LD_VAR 0 1
98136: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98137: LD_EXP 137
98141: PUSH
98142: LD_EXP 159
98146: AND
98147: IFFALSE 98159
98149: GO 98151
98151: DISABLE
// YouLost (  ) ;
98152: LD_STRING 
98154: PPUSH
98155: CALL_OW 104
98159: END
// every 0 0$1 trigger StreamModeActive and sFog do
98160: LD_EXP 137
98164: PUSH
98165: LD_EXP 158
98169: AND
98170: IFFALSE 98184
98172: GO 98174
98174: DISABLE
// FogOff ( your_side ) ;
98175: LD_OWVAR 2
98179: PPUSH
98180: CALL_OW 344
98184: END
// every 0 0$1 trigger StreamModeActive and sSun do
98185: LD_EXP 137
98189: PUSH
98190: LD_EXP 160
98194: AND
98195: IFFALSE 98223
98197: GO 98199
98199: DISABLE
// begin solar_recharge_percent := 0 ;
98200: LD_ADDR_OWVAR 79
98204: PUSH
98205: LD_INT 0
98207: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98208: LD_INT 10500
98210: PPUSH
98211: CALL_OW 67
// solar_recharge_percent := 100 ;
98215: LD_ADDR_OWVAR 79
98219: PUSH
98220: LD_INT 100
98222: ST_TO_ADDR
// end ;
98223: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98224: LD_EXP 137
98228: PUSH
98229: LD_EXP 161
98233: AND
98234: IFFALSE 98473
98236: GO 98238
98238: DISABLE
98239: LD_INT 0
98241: PPUSH
98242: PPUSH
98243: PPUSH
// begin tmp := [ ] ;
98244: LD_ADDR_VAR 0 3
98248: PUSH
98249: EMPTY
98250: ST_TO_ADDR
// for i := 1 to 6 do
98251: LD_ADDR_VAR 0 1
98255: PUSH
98256: DOUBLE
98257: LD_INT 1
98259: DEC
98260: ST_TO_ADDR
98261: LD_INT 6
98263: PUSH
98264: FOR_TO
98265: IFFALSE 98370
// begin uc_nation := nation_nature ;
98267: LD_ADDR_OWVAR 21
98271: PUSH
98272: LD_INT 0
98274: ST_TO_ADDR
// uc_side := 0 ;
98275: LD_ADDR_OWVAR 20
98279: PUSH
98280: LD_INT 0
98282: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98283: LD_ADDR_OWVAR 29
98287: PUSH
98288: LD_INT 12
98290: PUSH
98291: LD_INT 12
98293: PUSH
98294: EMPTY
98295: LIST
98296: LIST
98297: ST_TO_ADDR
// hc_agressivity := 20 ;
98298: LD_ADDR_OWVAR 35
98302: PUSH
98303: LD_INT 20
98305: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98306: LD_ADDR_OWVAR 28
98310: PUSH
98311: LD_INT 17
98313: ST_TO_ADDR
// hc_gallery :=  ;
98314: LD_ADDR_OWVAR 33
98318: PUSH
98319: LD_STRING 
98321: ST_TO_ADDR
// hc_name :=  ;
98322: LD_ADDR_OWVAR 26
98326: PUSH
98327: LD_STRING 
98329: ST_TO_ADDR
// un := CreateHuman ;
98330: LD_ADDR_VAR 0 2
98334: PUSH
98335: CALL_OW 44
98339: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98340: LD_VAR 0 2
98344: PPUSH
98345: LD_INT 1
98347: PPUSH
98348: CALL_OW 51
// tmp := tmp ^ un ;
98352: LD_ADDR_VAR 0 3
98356: PUSH
98357: LD_VAR 0 3
98361: PUSH
98362: LD_VAR 0 2
98366: ADD
98367: ST_TO_ADDR
// end ;
98368: GO 98264
98370: POP
98371: POP
// repeat wait ( 0 0$1 ) ;
98372: LD_INT 35
98374: PPUSH
98375: CALL_OW 67
// for un in tmp do
98379: LD_ADDR_VAR 0 2
98383: PUSH
98384: LD_VAR 0 3
98388: PUSH
98389: FOR_IN
98390: IFFALSE 98464
// begin if IsDead ( un ) then
98392: LD_VAR 0 2
98396: PPUSH
98397: CALL_OW 301
98401: IFFALSE 98421
// begin tmp := tmp diff un ;
98403: LD_ADDR_VAR 0 3
98407: PUSH
98408: LD_VAR 0 3
98412: PUSH
98413: LD_VAR 0 2
98417: DIFF
98418: ST_TO_ADDR
// continue ;
98419: GO 98389
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98421: LD_VAR 0 2
98425: PPUSH
98426: LD_INT 3
98428: PUSH
98429: LD_INT 22
98431: PUSH
98432: LD_INT 0
98434: PUSH
98435: EMPTY
98436: LIST
98437: LIST
98438: PUSH
98439: EMPTY
98440: LIST
98441: LIST
98442: PPUSH
98443: CALL_OW 69
98447: PPUSH
98448: LD_VAR 0 2
98452: PPUSH
98453: CALL_OW 74
98457: PPUSH
98458: CALL_OW 115
// end ;
98462: GO 98389
98464: POP
98465: POP
// until not tmp ;
98466: LD_VAR 0 3
98470: NOT
98471: IFFALSE 98372
// end ;
98473: PPOPN 3
98475: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98476: LD_EXP 137
98480: PUSH
98481: LD_EXP 162
98485: AND
98486: IFFALSE 98540
98488: GO 98490
98490: DISABLE
// begin ToLua ( displayTroll(); ) ;
98491: LD_STRING displayTroll();
98493: PPUSH
98494: CALL_OW 559
// wait ( 3 3$00 ) ;
98498: LD_INT 6300
98500: PPUSH
98501: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98505: LD_STRING hideTroll();
98507: PPUSH
98508: CALL_OW 559
// wait ( 1 1$00 ) ;
98512: LD_INT 2100
98514: PPUSH
98515: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98519: LD_STRING displayTroll();
98521: PPUSH
98522: CALL_OW 559
// wait ( 1 1$00 ) ;
98526: LD_INT 2100
98528: PPUSH
98529: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98533: LD_STRING hideTroll();
98535: PPUSH
98536: CALL_OW 559
// end ;
98540: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98541: LD_EXP 137
98545: PUSH
98546: LD_EXP 163
98550: AND
98551: IFFALSE 98614
98553: GO 98555
98555: DISABLE
98556: LD_INT 0
98558: PPUSH
// begin p := 0 ;
98559: LD_ADDR_VAR 0 1
98563: PUSH
98564: LD_INT 0
98566: ST_TO_ADDR
// repeat game_speed := 1 ;
98567: LD_ADDR_OWVAR 65
98571: PUSH
98572: LD_INT 1
98574: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98575: LD_INT 35
98577: PPUSH
98578: CALL_OW 67
// p := p + 1 ;
98582: LD_ADDR_VAR 0 1
98586: PUSH
98587: LD_VAR 0 1
98591: PUSH
98592: LD_INT 1
98594: PLUS
98595: ST_TO_ADDR
// until p >= 60 ;
98596: LD_VAR 0 1
98600: PUSH
98601: LD_INT 60
98603: GREATEREQUAL
98604: IFFALSE 98567
// game_speed := 4 ;
98606: LD_ADDR_OWVAR 65
98610: PUSH
98611: LD_INT 4
98613: ST_TO_ADDR
// end ;
98614: PPOPN 1
98616: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98617: LD_EXP 137
98621: PUSH
98622: LD_EXP 164
98626: AND
98627: IFFALSE 98773
98629: GO 98631
98631: DISABLE
98632: LD_INT 0
98634: PPUSH
98635: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98636: LD_ADDR_VAR 0 1
98640: PUSH
98641: LD_INT 22
98643: PUSH
98644: LD_OWVAR 2
98648: PUSH
98649: EMPTY
98650: LIST
98651: LIST
98652: PUSH
98653: LD_INT 2
98655: PUSH
98656: LD_INT 30
98658: PUSH
98659: LD_INT 0
98661: PUSH
98662: EMPTY
98663: LIST
98664: LIST
98665: PUSH
98666: LD_INT 30
98668: PUSH
98669: LD_INT 1
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: PUSH
98676: EMPTY
98677: LIST
98678: LIST
98679: LIST
98680: PUSH
98681: EMPTY
98682: LIST
98683: LIST
98684: PPUSH
98685: CALL_OW 69
98689: ST_TO_ADDR
// if not depot then
98690: LD_VAR 0 1
98694: NOT
98695: IFFALSE 98699
// exit ;
98697: GO 98773
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98699: LD_ADDR_VAR 0 2
98703: PUSH
98704: LD_VAR 0 1
98708: PUSH
98709: LD_INT 1
98711: PPUSH
98712: LD_VAR 0 1
98716: PPUSH
98717: CALL_OW 12
98721: ARRAY
98722: PPUSH
98723: CALL_OW 274
98727: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98728: LD_VAR 0 2
98732: PPUSH
98733: LD_INT 1
98735: PPUSH
98736: LD_INT 0
98738: PPUSH
98739: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98743: LD_VAR 0 2
98747: PPUSH
98748: LD_INT 2
98750: PPUSH
98751: LD_INT 0
98753: PPUSH
98754: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98758: LD_VAR 0 2
98762: PPUSH
98763: LD_INT 3
98765: PPUSH
98766: LD_INT 0
98768: PPUSH
98769: CALL_OW 277
// end ;
98773: PPOPN 2
98775: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98776: LD_EXP 137
98780: PUSH
98781: LD_EXP 165
98785: AND
98786: IFFALSE 98883
98788: GO 98790
98790: DISABLE
98791: LD_INT 0
98793: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98794: LD_ADDR_VAR 0 1
98798: PUSH
98799: LD_INT 22
98801: PUSH
98802: LD_OWVAR 2
98806: PUSH
98807: EMPTY
98808: LIST
98809: LIST
98810: PUSH
98811: LD_INT 21
98813: PUSH
98814: LD_INT 1
98816: PUSH
98817: EMPTY
98818: LIST
98819: LIST
98820: PUSH
98821: LD_INT 3
98823: PUSH
98824: LD_INT 23
98826: PUSH
98827: LD_INT 0
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: PUSH
98834: EMPTY
98835: LIST
98836: LIST
98837: PUSH
98838: EMPTY
98839: LIST
98840: LIST
98841: LIST
98842: PPUSH
98843: CALL_OW 69
98847: ST_TO_ADDR
// if not tmp then
98848: LD_VAR 0 1
98852: NOT
98853: IFFALSE 98857
// exit ;
98855: GO 98883
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98857: LD_VAR 0 1
98861: PUSH
98862: LD_INT 1
98864: PPUSH
98865: LD_VAR 0 1
98869: PPUSH
98870: CALL_OW 12
98874: ARRAY
98875: PPUSH
98876: LD_INT 200
98878: PPUSH
98879: CALL_OW 234
// end ;
98883: PPOPN 1
98885: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98886: LD_EXP 137
98890: PUSH
98891: LD_EXP 166
98895: AND
98896: IFFALSE 98975
98898: GO 98900
98900: DISABLE
98901: LD_INT 0
98903: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98904: LD_ADDR_VAR 0 1
98908: PUSH
98909: LD_INT 22
98911: PUSH
98912: LD_OWVAR 2
98916: PUSH
98917: EMPTY
98918: LIST
98919: LIST
98920: PUSH
98921: LD_INT 21
98923: PUSH
98924: LD_INT 2
98926: PUSH
98927: EMPTY
98928: LIST
98929: LIST
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: PPUSH
98935: CALL_OW 69
98939: ST_TO_ADDR
// if not tmp then
98940: LD_VAR 0 1
98944: NOT
98945: IFFALSE 98949
// exit ;
98947: GO 98975
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98949: LD_VAR 0 1
98953: PUSH
98954: LD_INT 1
98956: PPUSH
98957: LD_VAR 0 1
98961: PPUSH
98962: CALL_OW 12
98966: ARRAY
98967: PPUSH
98968: LD_INT 60
98970: PPUSH
98971: CALL_OW 234
// end ;
98975: PPOPN 1
98977: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98978: LD_EXP 137
98982: PUSH
98983: LD_EXP 167
98987: AND
98988: IFFALSE 99087
98990: GO 98992
98992: DISABLE
98993: LD_INT 0
98995: PPUSH
98996: PPUSH
// begin enable ;
98997: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98998: LD_ADDR_VAR 0 1
99002: PUSH
99003: LD_INT 22
99005: PUSH
99006: LD_OWVAR 2
99010: PUSH
99011: EMPTY
99012: LIST
99013: LIST
99014: PUSH
99015: LD_INT 61
99017: PUSH
99018: EMPTY
99019: LIST
99020: PUSH
99021: LD_INT 33
99023: PUSH
99024: LD_INT 2
99026: PUSH
99027: EMPTY
99028: LIST
99029: LIST
99030: PUSH
99031: EMPTY
99032: LIST
99033: LIST
99034: LIST
99035: PPUSH
99036: CALL_OW 69
99040: ST_TO_ADDR
// if not tmp then
99041: LD_VAR 0 1
99045: NOT
99046: IFFALSE 99050
// exit ;
99048: GO 99087
// for i in tmp do
99050: LD_ADDR_VAR 0 2
99054: PUSH
99055: LD_VAR 0 1
99059: PUSH
99060: FOR_IN
99061: IFFALSE 99085
// if IsControledBy ( i ) then
99063: LD_VAR 0 2
99067: PPUSH
99068: CALL_OW 312
99072: IFFALSE 99083
// ComUnlink ( i ) ;
99074: LD_VAR 0 2
99078: PPUSH
99079: CALL_OW 136
99083: GO 99060
99085: POP
99086: POP
// end ;
99087: PPOPN 2
99089: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99090: LD_EXP 137
99094: PUSH
99095: LD_EXP 168
99099: AND
99100: IFFALSE 99240
99102: GO 99104
99104: DISABLE
99105: LD_INT 0
99107: PPUSH
99108: PPUSH
// begin ToLua ( displayPowell(); ) ;
99109: LD_STRING displayPowell();
99111: PPUSH
99112: CALL_OW 559
// uc_side := 0 ;
99116: LD_ADDR_OWVAR 20
99120: PUSH
99121: LD_INT 0
99123: ST_TO_ADDR
// uc_nation := 2 ;
99124: LD_ADDR_OWVAR 21
99128: PUSH
99129: LD_INT 2
99131: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99132: LD_ADDR_OWVAR 37
99136: PUSH
99137: LD_INT 14
99139: ST_TO_ADDR
// vc_engine := engine_siberite ;
99140: LD_ADDR_OWVAR 39
99144: PUSH
99145: LD_INT 3
99147: ST_TO_ADDR
// vc_control := control_apeman ;
99148: LD_ADDR_OWVAR 38
99152: PUSH
99153: LD_INT 5
99155: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99156: LD_ADDR_OWVAR 40
99160: PUSH
99161: LD_INT 29
99163: ST_TO_ADDR
// un := CreateVehicle ;
99164: LD_ADDR_VAR 0 2
99168: PUSH
99169: CALL_OW 45
99173: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99174: LD_VAR 0 2
99178: PPUSH
99179: LD_INT 1
99181: PPUSH
99182: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99186: LD_INT 35
99188: PPUSH
99189: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99193: LD_VAR 0 2
99197: PPUSH
99198: LD_INT 22
99200: PUSH
99201: LD_OWVAR 2
99205: PUSH
99206: EMPTY
99207: LIST
99208: LIST
99209: PPUSH
99210: CALL_OW 69
99214: PPUSH
99215: LD_VAR 0 2
99219: PPUSH
99220: CALL_OW 74
99224: PPUSH
99225: CALL_OW 115
// until IsDead ( un ) ;
99229: LD_VAR 0 2
99233: PPUSH
99234: CALL_OW 301
99238: IFFALSE 99186
// end ;
99240: PPOPN 2
99242: END
// every 0 0$1 trigger StreamModeActive and sStu do
99243: LD_EXP 137
99247: PUSH
99248: LD_EXP 176
99252: AND
99253: IFFALSE 99269
99255: GO 99257
99257: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99258: LD_STRING displayStucuk();
99260: PPUSH
99261: CALL_OW 559
// ResetFog ;
99265: CALL_OW 335
// end ;
99269: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99270: LD_EXP 137
99274: PUSH
99275: LD_EXP 169
99279: AND
99280: IFFALSE 99421
99282: GO 99284
99284: DISABLE
99285: LD_INT 0
99287: PPUSH
99288: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99289: LD_ADDR_VAR 0 2
99293: PUSH
99294: LD_INT 22
99296: PUSH
99297: LD_OWVAR 2
99301: PUSH
99302: EMPTY
99303: LIST
99304: LIST
99305: PUSH
99306: LD_INT 21
99308: PUSH
99309: LD_INT 1
99311: PUSH
99312: EMPTY
99313: LIST
99314: LIST
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: PPUSH
99320: CALL_OW 69
99324: ST_TO_ADDR
// if not tmp then
99325: LD_VAR 0 2
99329: NOT
99330: IFFALSE 99334
// exit ;
99332: GO 99421
// un := tmp [ rand ( 1 , tmp ) ] ;
99334: LD_ADDR_VAR 0 1
99338: PUSH
99339: LD_VAR 0 2
99343: PUSH
99344: LD_INT 1
99346: PPUSH
99347: LD_VAR 0 2
99351: PPUSH
99352: CALL_OW 12
99356: ARRAY
99357: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99358: LD_VAR 0 1
99362: PPUSH
99363: LD_INT 0
99365: PPUSH
99366: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99370: LD_VAR 0 1
99374: PPUSH
99375: LD_OWVAR 3
99379: PUSH
99380: LD_VAR 0 1
99384: DIFF
99385: PPUSH
99386: LD_VAR 0 1
99390: PPUSH
99391: CALL_OW 74
99395: PPUSH
99396: CALL_OW 115
// wait ( 0 0$20 ) ;
99400: LD_INT 700
99402: PPUSH
99403: CALL_OW 67
// SetSide ( un , your_side ) ;
99407: LD_VAR 0 1
99411: PPUSH
99412: LD_OWVAR 2
99416: PPUSH
99417: CALL_OW 235
// end ;
99421: PPOPN 2
99423: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99424: LD_EXP 137
99428: PUSH
99429: LD_EXP 170
99433: AND
99434: IFFALSE 99540
99436: GO 99438
99438: DISABLE
99439: LD_INT 0
99441: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99442: LD_ADDR_VAR 0 1
99446: PUSH
99447: LD_INT 22
99449: PUSH
99450: LD_OWVAR 2
99454: PUSH
99455: EMPTY
99456: LIST
99457: LIST
99458: PUSH
99459: LD_INT 2
99461: PUSH
99462: LD_INT 30
99464: PUSH
99465: LD_INT 0
99467: PUSH
99468: EMPTY
99469: LIST
99470: LIST
99471: PUSH
99472: LD_INT 30
99474: PUSH
99475: LD_INT 1
99477: PUSH
99478: EMPTY
99479: LIST
99480: LIST
99481: PUSH
99482: EMPTY
99483: LIST
99484: LIST
99485: LIST
99486: PUSH
99487: EMPTY
99488: LIST
99489: LIST
99490: PPUSH
99491: CALL_OW 69
99495: ST_TO_ADDR
// if not depot then
99496: LD_VAR 0 1
99500: NOT
99501: IFFALSE 99505
// exit ;
99503: GO 99540
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99505: LD_VAR 0 1
99509: PUSH
99510: LD_INT 1
99512: ARRAY
99513: PPUSH
99514: CALL_OW 250
99518: PPUSH
99519: LD_VAR 0 1
99523: PUSH
99524: LD_INT 1
99526: ARRAY
99527: PPUSH
99528: CALL_OW 251
99532: PPUSH
99533: LD_INT 70
99535: PPUSH
99536: CALL_OW 495
// end ;
99540: PPOPN 1
99542: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99543: LD_EXP 137
99547: PUSH
99548: LD_EXP 171
99552: AND
99553: IFFALSE 99764
99555: GO 99557
99557: DISABLE
99558: LD_INT 0
99560: PPUSH
99561: PPUSH
99562: PPUSH
99563: PPUSH
99564: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99565: LD_ADDR_VAR 0 5
99569: PUSH
99570: LD_INT 22
99572: PUSH
99573: LD_OWVAR 2
99577: PUSH
99578: EMPTY
99579: LIST
99580: LIST
99581: PUSH
99582: LD_INT 21
99584: PUSH
99585: LD_INT 1
99587: PUSH
99588: EMPTY
99589: LIST
99590: LIST
99591: PUSH
99592: EMPTY
99593: LIST
99594: LIST
99595: PPUSH
99596: CALL_OW 69
99600: ST_TO_ADDR
// if not tmp then
99601: LD_VAR 0 5
99605: NOT
99606: IFFALSE 99610
// exit ;
99608: GO 99764
// for i in tmp do
99610: LD_ADDR_VAR 0 1
99614: PUSH
99615: LD_VAR 0 5
99619: PUSH
99620: FOR_IN
99621: IFFALSE 99762
// begin d := rand ( 0 , 5 ) ;
99623: LD_ADDR_VAR 0 4
99627: PUSH
99628: LD_INT 0
99630: PPUSH
99631: LD_INT 5
99633: PPUSH
99634: CALL_OW 12
99638: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99639: LD_ADDR_VAR 0 2
99643: PUSH
99644: LD_VAR 0 1
99648: PPUSH
99649: CALL_OW 250
99653: PPUSH
99654: LD_VAR 0 4
99658: PPUSH
99659: LD_INT 3
99661: PPUSH
99662: LD_INT 12
99664: PPUSH
99665: CALL_OW 12
99669: PPUSH
99670: CALL_OW 272
99674: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99675: LD_ADDR_VAR 0 3
99679: PUSH
99680: LD_VAR 0 1
99684: PPUSH
99685: CALL_OW 251
99689: PPUSH
99690: LD_VAR 0 4
99694: PPUSH
99695: LD_INT 3
99697: PPUSH
99698: LD_INT 12
99700: PPUSH
99701: CALL_OW 12
99705: PPUSH
99706: CALL_OW 273
99710: ST_TO_ADDR
// if ValidHex ( x , y ) then
99711: LD_VAR 0 2
99715: PPUSH
99716: LD_VAR 0 3
99720: PPUSH
99721: CALL_OW 488
99725: IFFALSE 99760
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99727: LD_VAR 0 1
99731: PPUSH
99732: LD_VAR 0 2
99736: PPUSH
99737: LD_VAR 0 3
99741: PPUSH
99742: LD_INT 3
99744: PPUSH
99745: LD_INT 6
99747: PPUSH
99748: CALL_OW 12
99752: PPUSH
99753: LD_INT 1
99755: PPUSH
99756: CALL_OW 483
// end ;
99760: GO 99620
99762: POP
99763: POP
// end ;
99764: PPOPN 5
99766: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99767: LD_EXP 137
99771: PUSH
99772: LD_EXP 172
99776: AND
99777: IFFALSE 99871
99779: GO 99781
99781: DISABLE
99782: LD_INT 0
99784: PPUSH
99785: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99786: LD_ADDR_VAR 0 2
99790: PUSH
99791: LD_INT 22
99793: PUSH
99794: LD_OWVAR 2
99798: PUSH
99799: EMPTY
99800: LIST
99801: LIST
99802: PUSH
99803: LD_INT 32
99805: PUSH
99806: LD_INT 1
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: PUSH
99813: LD_INT 21
99815: PUSH
99816: LD_INT 2
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: PUSH
99823: EMPTY
99824: LIST
99825: LIST
99826: LIST
99827: PPUSH
99828: CALL_OW 69
99832: ST_TO_ADDR
// if not tmp then
99833: LD_VAR 0 2
99837: NOT
99838: IFFALSE 99842
// exit ;
99840: GO 99871
// for i in tmp do
99842: LD_ADDR_VAR 0 1
99846: PUSH
99847: LD_VAR 0 2
99851: PUSH
99852: FOR_IN
99853: IFFALSE 99869
// SetFuel ( i , 0 ) ;
99855: LD_VAR 0 1
99859: PPUSH
99860: LD_INT 0
99862: PPUSH
99863: CALL_OW 240
99867: GO 99852
99869: POP
99870: POP
// end ;
99871: PPOPN 2
99873: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99874: LD_EXP 137
99878: PUSH
99879: LD_EXP 173
99883: AND
99884: IFFALSE 99950
99886: GO 99888
99888: DISABLE
99889: LD_INT 0
99891: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99892: LD_ADDR_VAR 0 1
99896: PUSH
99897: LD_INT 22
99899: PUSH
99900: LD_OWVAR 2
99904: PUSH
99905: EMPTY
99906: LIST
99907: LIST
99908: PUSH
99909: LD_INT 30
99911: PUSH
99912: LD_INT 29
99914: PUSH
99915: EMPTY
99916: LIST
99917: LIST
99918: PUSH
99919: EMPTY
99920: LIST
99921: LIST
99922: PPUSH
99923: CALL_OW 69
99927: ST_TO_ADDR
// if not tmp then
99928: LD_VAR 0 1
99932: NOT
99933: IFFALSE 99937
// exit ;
99935: GO 99950
// DestroyUnit ( tmp [ 1 ] ) ;
99937: LD_VAR 0 1
99941: PUSH
99942: LD_INT 1
99944: ARRAY
99945: PPUSH
99946: CALL_OW 65
// end ;
99950: PPOPN 1
99952: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99953: LD_EXP 137
99957: PUSH
99958: LD_EXP 175
99962: AND
99963: IFFALSE 100092
99965: GO 99967
99967: DISABLE
99968: LD_INT 0
99970: PPUSH
// begin uc_side := 0 ;
99971: LD_ADDR_OWVAR 20
99975: PUSH
99976: LD_INT 0
99978: ST_TO_ADDR
// uc_nation := nation_arabian ;
99979: LD_ADDR_OWVAR 21
99983: PUSH
99984: LD_INT 2
99986: ST_TO_ADDR
// hc_gallery :=  ;
99987: LD_ADDR_OWVAR 33
99991: PUSH
99992: LD_STRING 
99994: ST_TO_ADDR
// hc_name :=  ;
99995: LD_ADDR_OWVAR 26
99999: PUSH
100000: LD_STRING 
100002: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100003: LD_INT 1
100005: PPUSH
100006: LD_INT 11
100008: PPUSH
100009: LD_INT 10
100011: PPUSH
100012: CALL_OW 380
// un := CreateHuman ;
100016: LD_ADDR_VAR 0 1
100020: PUSH
100021: CALL_OW 44
100025: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100026: LD_VAR 0 1
100030: PPUSH
100031: LD_INT 1
100033: PPUSH
100034: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100038: LD_INT 35
100040: PPUSH
100041: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100045: LD_VAR 0 1
100049: PPUSH
100050: LD_INT 22
100052: PUSH
100053: LD_OWVAR 2
100057: PUSH
100058: EMPTY
100059: LIST
100060: LIST
100061: PPUSH
100062: CALL_OW 69
100066: PPUSH
100067: LD_VAR 0 1
100071: PPUSH
100072: CALL_OW 74
100076: PPUSH
100077: CALL_OW 115
// until IsDead ( un ) ;
100081: LD_VAR 0 1
100085: PPUSH
100086: CALL_OW 301
100090: IFFALSE 100038
// end ;
100092: PPOPN 1
100094: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100095: LD_EXP 137
100099: PUSH
100100: LD_EXP 177
100104: AND
100105: IFFALSE 100117
100107: GO 100109
100109: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100110: LD_STRING earthquake(getX(game), 0, 32)
100112: PPUSH
100113: CALL_OW 559
100117: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100118: LD_EXP 137
100122: PUSH
100123: LD_EXP 178
100127: AND
100128: IFFALSE 100219
100130: GO 100132
100132: DISABLE
100133: LD_INT 0
100135: PPUSH
// begin enable ;
100136: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100137: LD_ADDR_VAR 0 1
100141: PUSH
100142: LD_INT 22
100144: PUSH
100145: LD_OWVAR 2
100149: PUSH
100150: EMPTY
100151: LIST
100152: LIST
100153: PUSH
100154: LD_INT 21
100156: PUSH
100157: LD_INT 2
100159: PUSH
100160: EMPTY
100161: LIST
100162: LIST
100163: PUSH
100164: LD_INT 33
100166: PUSH
100167: LD_INT 3
100169: PUSH
100170: EMPTY
100171: LIST
100172: LIST
100173: PUSH
100174: EMPTY
100175: LIST
100176: LIST
100177: LIST
100178: PPUSH
100179: CALL_OW 69
100183: ST_TO_ADDR
// if not tmp then
100184: LD_VAR 0 1
100188: NOT
100189: IFFALSE 100193
// exit ;
100191: GO 100219
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100193: LD_VAR 0 1
100197: PUSH
100198: LD_INT 1
100200: PPUSH
100201: LD_VAR 0 1
100205: PPUSH
100206: CALL_OW 12
100210: ARRAY
100211: PPUSH
100212: LD_INT 1
100214: PPUSH
100215: CALL_OW 234
// end ;
100219: PPOPN 1
100221: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100222: LD_EXP 137
100226: PUSH
100227: LD_EXP 179
100231: AND
100232: IFFALSE 100373
100234: GO 100236
100236: DISABLE
100237: LD_INT 0
100239: PPUSH
100240: PPUSH
100241: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100242: LD_ADDR_VAR 0 3
100246: PUSH
100247: LD_INT 22
100249: PUSH
100250: LD_OWVAR 2
100254: PUSH
100255: EMPTY
100256: LIST
100257: LIST
100258: PUSH
100259: LD_INT 25
100261: PUSH
100262: LD_INT 1
100264: PUSH
100265: EMPTY
100266: LIST
100267: LIST
100268: PUSH
100269: EMPTY
100270: LIST
100271: LIST
100272: PPUSH
100273: CALL_OW 69
100277: ST_TO_ADDR
// if not tmp then
100278: LD_VAR 0 3
100282: NOT
100283: IFFALSE 100287
// exit ;
100285: GO 100373
// un := tmp [ rand ( 1 , tmp ) ] ;
100287: LD_ADDR_VAR 0 2
100291: PUSH
100292: LD_VAR 0 3
100296: PUSH
100297: LD_INT 1
100299: PPUSH
100300: LD_VAR 0 3
100304: PPUSH
100305: CALL_OW 12
100309: ARRAY
100310: ST_TO_ADDR
// if Crawls ( un ) then
100311: LD_VAR 0 2
100315: PPUSH
100316: CALL_OW 318
100320: IFFALSE 100331
// ComWalk ( un ) ;
100322: LD_VAR 0 2
100326: PPUSH
100327: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100331: LD_VAR 0 2
100335: PPUSH
100336: LD_INT 9
100338: PPUSH
100339: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100343: LD_INT 28
100345: PPUSH
100346: LD_OWVAR 2
100350: PPUSH
100351: LD_INT 2
100353: PPUSH
100354: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100358: LD_INT 29
100360: PPUSH
100361: LD_OWVAR 2
100365: PPUSH
100366: LD_INT 2
100368: PPUSH
100369: CALL_OW 322
// end ;
100373: PPOPN 3
100375: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100376: LD_EXP 137
100380: PUSH
100381: LD_EXP 180
100385: AND
100386: IFFALSE 100497
100388: GO 100390
100390: DISABLE
100391: LD_INT 0
100393: PPUSH
100394: PPUSH
100395: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100396: LD_ADDR_VAR 0 3
100400: PUSH
100401: LD_INT 22
100403: PUSH
100404: LD_OWVAR 2
100408: PUSH
100409: EMPTY
100410: LIST
100411: LIST
100412: PUSH
100413: LD_INT 25
100415: PUSH
100416: LD_INT 1
100418: PUSH
100419: EMPTY
100420: LIST
100421: LIST
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: PPUSH
100427: CALL_OW 69
100431: ST_TO_ADDR
// if not tmp then
100432: LD_VAR 0 3
100436: NOT
100437: IFFALSE 100441
// exit ;
100439: GO 100497
// un := tmp [ rand ( 1 , tmp ) ] ;
100441: LD_ADDR_VAR 0 2
100445: PUSH
100446: LD_VAR 0 3
100450: PUSH
100451: LD_INT 1
100453: PPUSH
100454: LD_VAR 0 3
100458: PPUSH
100459: CALL_OW 12
100463: ARRAY
100464: ST_TO_ADDR
// if Crawls ( un ) then
100465: LD_VAR 0 2
100469: PPUSH
100470: CALL_OW 318
100474: IFFALSE 100485
// ComWalk ( un ) ;
100476: LD_VAR 0 2
100480: PPUSH
100481: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100485: LD_VAR 0 2
100489: PPUSH
100490: LD_INT 8
100492: PPUSH
100493: CALL_OW 336
// end ;
100497: PPOPN 3
100499: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100500: LD_EXP 137
100504: PUSH
100505: LD_EXP 181
100509: AND
100510: IFFALSE 100654
100512: GO 100514
100514: DISABLE
100515: LD_INT 0
100517: PPUSH
100518: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100519: LD_ADDR_VAR 0 2
100523: PUSH
100524: LD_INT 22
100526: PUSH
100527: LD_OWVAR 2
100531: PUSH
100532: EMPTY
100533: LIST
100534: LIST
100535: PUSH
100536: LD_INT 21
100538: PUSH
100539: LD_INT 2
100541: PUSH
100542: EMPTY
100543: LIST
100544: LIST
100545: PUSH
100546: LD_INT 2
100548: PUSH
100549: LD_INT 34
100551: PUSH
100552: LD_INT 12
100554: PUSH
100555: EMPTY
100556: LIST
100557: LIST
100558: PUSH
100559: LD_INT 34
100561: PUSH
100562: LD_INT 51
100564: PUSH
100565: EMPTY
100566: LIST
100567: LIST
100568: PUSH
100569: LD_INT 34
100571: PUSH
100572: LD_INT 32
100574: PUSH
100575: EMPTY
100576: LIST
100577: LIST
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: LIST
100583: LIST
100584: PUSH
100585: EMPTY
100586: LIST
100587: LIST
100588: LIST
100589: PPUSH
100590: CALL_OW 69
100594: ST_TO_ADDR
// if not tmp then
100595: LD_VAR 0 2
100599: NOT
100600: IFFALSE 100604
// exit ;
100602: GO 100654
// for i in tmp do
100604: LD_ADDR_VAR 0 1
100608: PUSH
100609: LD_VAR 0 2
100613: PUSH
100614: FOR_IN
100615: IFFALSE 100652
// if GetCargo ( i , mat_artifact ) = 0 then
100617: LD_VAR 0 1
100621: PPUSH
100622: LD_INT 4
100624: PPUSH
100625: CALL_OW 289
100629: PUSH
100630: LD_INT 0
100632: EQUAL
100633: IFFALSE 100650
// SetCargo ( i , mat_siberit , 100 ) ;
100635: LD_VAR 0 1
100639: PPUSH
100640: LD_INT 3
100642: PPUSH
100643: LD_INT 100
100645: PPUSH
100646: CALL_OW 290
100650: GO 100614
100652: POP
100653: POP
// end ;
100654: PPOPN 2
100656: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100657: LD_EXP 137
100661: PUSH
100662: LD_EXP 182
100666: AND
100667: IFFALSE 100850
100669: GO 100671
100671: DISABLE
100672: LD_INT 0
100674: PPUSH
100675: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100676: LD_ADDR_VAR 0 2
100680: PUSH
100681: LD_INT 22
100683: PUSH
100684: LD_OWVAR 2
100688: PUSH
100689: EMPTY
100690: LIST
100691: LIST
100692: PPUSH
100693: CALL_OW 69
100697: ST_TO_ADDR
// if not tmp then
100698: LD_VAR 0 2
100702: NOT
100703: IFFALSE 100707
// exit ;
100705: GO 100850
// for i := 1 to 2 do
100707: LD_ADDR_VAR 0 1
100711: PUSH
100712: DOUBLE
100713: LD_INT 1
100715: DEC
100716: ST_TO_ADDR
100717: LD_INT 2
100719: PUSH
100720: FOR_TO
100721: IFFALSE 100848
// begin uc_side := your_side ;
100723: LD_ADDR_OWVAR 20
100727: PUSH
100728: LD_OWVAR 2
100732: ST_TO_ADDR
// uc_nation := nation_american ;
100733: LD_ADDR_OWVAR 21
100737: PUSH
100738: LD_INT 1
100740: ST_TO_ADDR
// vc_chassis := us_morphling ;
100741: LD_ADDR_OWVAR 37
100745: PUSH
100746: LD_INT 5
100748: ST_TO_ADDR
// vc_engine := engine_siberite ;
100749: LD_ADDR_OWVAR 39
100753: PUSH
100754: LD_INT 3
100756: ST_TO_ADDR
// vc_control := control_computer ;
100757: LD_ADDR_OWVAR 38
100761: PUSH
100762: LD_INT 3
100764: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100765: LD_ADDR_OWVAR 40
100769: PUSH
100770: LD_INT 10
100772: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100773: LD_VAR 0 2
100777: PUSH
100778: LD_INT 1
100780: ARRAY
100781: PPUSH
100782: CALL_OW 310
100786: NOT
100787: IFFALSE 100834
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100789: CALL_OW 45
100793: PPUSH
100794: LD_VAR 0 2
100798: PUSH
100799: LD_INT 1
100801: ARRAY
100802: PPUSH
100803: CALL_OW 250
100807: PPUSH
100808: LD_VAR 0 2
100812: PUSH
100813: LD_INT 1
100815: ARRAY
100816: PPUSH
100817: CALL_OW 251
100821: PPUSH
100822: LD_INT 12
100824: PPUSH
100825: LD_INT 1
100827: PPUSH
100828: CALL_OW 50
100832: GO 100846
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100834: CALL_OW 45
100838: PPUSH
100839: LD_INT 1
100841: PPUSH
100842: CALL_OW 51
// end ;
100846: GO 100720
100848: POP
100849: POP
// end ;
100850: PPOPN 2
100852: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100853: LD_EXP 137
100857: PUSH
100858: LD_EXP 183
100862: AND
100863: IFFALSE 101085
100865: GO 100867
100867: DISABLE
100868: LD_INT 0
100870: PPUSH
100871: PPUSH
100872: PPUSH
100873: PPUSH
100874: PPUSH
100875: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100876: LD_ADDR_VAR 0 6
100880: PUSH
100881: LD_INT 22
100883: PUSH
100884: LD_OWVAR 2
100888: PUSH
100889: EMPTY
100890: LIST
100891: LIST
100892: PUSH
100893: LD_INT 21
100895: PUSH
100896: LD_INT 1
100898: PUSH
100899: EMPTY
100900: LIST
100901: LIST
100902: PUSH
100903: LD_INT 3
100905: PUSH
100906: LD_INT 23
100908: PUSH
100909: LD_INT 0
100911: PUSH
100912: EMPTY
100913: LIST
100914: LIST
100915: PUSH
100916: EMPTY
100917: LIST
100918: LIST
100919: PUSH
100920: EMPTY
100921: LIST
100922: LIST
100923: LIST
100924: PPUSH
100925: CALL_OW 69
100929: ST_TO_ADDR
// if not tmp then
100930: LD_VAR 0 6
100934: NOT
100935: IFFALSE 100939
// exit ;
100937: GO 101085
// s1 := rand ( 1 , 4 ) ;
100939: LD_ADDR_VAR 0 2
100943: PUSH
100944: LD_INT 1
100946: PPUSH
100947: LD_INT 4
100949: PPUSH
100950: CALL_OW 12
100954: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100955: LD_ADDR_VAR 0 4
100959: PUSH
100960: LD_VAR 0 6
100964: PUSH
100965: LD_INT 1
100967: ARRAY
100968: PPUSH
100969: LD_VAR 0 2
100973: PPUSH
100974: CALL_OW 259
100978: ST_TO_ADDR
// if s1 = 1 then
100979: LD_VAR 0 2
100983: PUSH
100984: LD_INT 1
100986: EQUAL
100987: IFFALSE 101007
// s2 := rand ( 2 , 4 ) else
100989: LD_ADDR_VAR 0 3
100993: PUSH
100994: LD_INT 2
100996: PPUSH
100997: LD_INT 4
100999: PPUSH
101000: CALL_OW 12
101004: ST_TO_ADDR
101005: GO 101015
// s2 := 1 ;
101007: LD_ADDR_VAR 0 3
101011: PUSH
101012: LD_INT 1
101014: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101015: LD_ADDR_VAR 0 5
101019: PUSH
101020: LD_VAR 0 6
101024: PUSH
101025: LD_INT 1
101027: ARRAY
101028: PPUSH
101029: LD_VAR 0 3
101033: PPUSH
101034: CALL_OW 259
101038: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101039: LD_VAR 0 6
101043: PUSH
101044: LD_INT 1
101046: ARRAY
101047: PPUSH
101048: LD_VAR 0 2
101052: PPUSH
101053: LD_VAR 0 5
101057: PPUSH
101058: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101062: LD_VAR 0 6
101066: PUSH
101067: LD_INT 1
101069: ARRAY
101070: PPUSH
101071: LD_VAR 0 3
101075: PPUSH
101076: LD_VAR 0 4
101080: PPUSH
101081: CALL_OW 237
// end ;
101085: PPOPN 6
101087: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101088: LD_EXP 137
101092: PUSH
101093: LD_EXP 184
101097: AND
101098: IFFALSE 101177
101100: GO 101102
101102: DISABLE
101103: LD_INT 0
101105: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101106: LD_ADDR_VAR 0 1
101110: PUSH
101111: LD_INT 22
101113: PUSH
101114: LD_OWVAR 2
101118: PUSH
101119: EMPTY
101120: LIST
101121: LIST
101122: PUSH
101123: LD_INT 30
101125: PUSH
101126: LD_INT 3
101128: PUSH
101129: EMPTY
101130: LIST
101131: LIST
101132: PUSH
101133: EMPTY
101134: LIST
101135: LIST
101136: PPUSH
101137: CALL_OW 69
101141: ST_TO_ADDR
// if not tmp then
101142: LD_VAR 0 1
101146: NOT
101147: IFFALSE 101151
// exit ;
101149: GO 101177
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101151: LD_VAR 0 1
101155: PUSH
101156: LD_INT 1
101158: PPUSH
101159: LD_VAR 0 1
101163: PPUSH
101164: CALL_OW 12
101168: ARRAY
101169: PPUSH
101170: LD_INT 1
101172: PPUSH
101173: CALL_OW 234
// end ;
101177: PPOPN 1
101179: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101180: LD_EXP 137
101184: PUSH
101185: LD_EXP 185
101189: AND
101190: IFFALSE 101302
101192: GO 101194
101194: DISABLE
101195: LD_INT 0
101197: PPUSH
101198: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101199: LD_ADDR_VAR 0 2
101203: PUSH
101204: LD_INT 22
101206: PUSH
101207: LD_OWVAR 2
101211: PUSH
101212: EMPTY
101213: LIST
101214: LIST
101215: PUSH
101216: LD_INT 2
101218: PUSH
101219: LD_INT 30
101221: PUSH
101222: LD_INT 27
101224: PUSH
101225: EMPTY
101226: LIST
101227: LIST
101228: PUSH
101229: LD_INT 30
101231: PUSH
101232: LD_INT 26
101234: PUSH
101235: EMPTY
101236: LIST
101237: LIST
101238: PUSH
101239: LD_INT 30
101241: PUSH
101242: LD_INT 28
101244: PUSH
101245: EMPTY
101246: LIST
101247: LIST
101248: PUSH
101249: EMPTY
101250: LIST
101251: LIST
101252: LIST
101253: LIST
101254: PUSH
101255: EMPTY
101256: LIST
101257: LIST
101258: PPUSH
101259: CALL_OW 69
101263: ST_TO_ADDR
// if not tmp then
101264: LD_VAR 0 2
101268: NOT
101269: IFFALSE 101273
// exit ;
101271: GO 101302
// for i in tmp do
101273: LD_ADDR_VAR 0 1
101277: PUSH
101278: LD_VAR 0 2
101282: PUSH
101283: FOR_IN
101284: IFFALSE 101300
// SetLives ( i , 1 ) ;
101286: LD_VAR 0 1
101290: PPUSH
101291: LD_INT 1
101293: PPUSH
101294: CALL_OW 234
101298: GO 101283
101300: POP
101301: POP
// end ;
101302: PPOPN 2
101304: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101305: LD_EXP 137
101309: PUSH
101310: LD_EXP 186
101314: AND
101315: IFFALSE 101589
101317: GO 101319
101319: DISABLE
101320: LD_INT 0
101322: PPUSH
101323: PPUSH
101324: PPUSH
// begin i := rand ( 1 , 7 ) ;
101325: LD_ADDR_VAR 0 1
101329: PUSH
101330: LD_INT 1
101332: PPUSH
101333: LD_INT 7
101335: PPUSH
101336: CALL_OW 12
101340: ST_TO_ADDR
// case i of 1 :
101341: LD_VAR 0 1
101345: PUSH
101346: LD_INT 1
101348: DOUBLE
101349: EQUAL
101350: IFTRUE 101354
101352: GO 101364
101354: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101355: LD_STRING earthquake(getX(game), 0, 32)
101357: PPUSH
101358: CALL_OW 559
101362: GO 101589
101364: LD_INT 2
101366: DOUBLE
101367: EQUAL
101368: IFTRUE 101372
101370: GO 101386
101372: POP
// begin ToLua ( displayStucuk(); ) ;
101373: LD_STRING displayStucuk();
101375: PPUSH
101376: CALL_OW 559
// ResetFog ;
101380: CALL_OW 335
// end ; 3 :
101384: GO 101589
101386: LD_INT 3
101388: DOUBLE
101389: EQUAL
101390: IFTRUE 101394
101392: GO 101498
101394: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101395: LD_ADDR_VAR 0 2
101399: PUSH
101400: LD_INT 22
101402: PUSH
101403: LD_OWVAR 2
101407: PUSH
101408: EMPTY
101409: LIST
101410: LIST
101411: PUSH
101412: LD_INT 25
101414: PUSH
101415: LD_INT 1
101417: PUSH
101418: EMPTY
101419: LIST
101420: LIST
101421: PUSH
101422: EMPTY
101423: LIST
101424: LIST
101425: PPUSH
101426: CALL_OW 69
101430: ST_TO_ADDR
// if not tmp then
101431: LD_VAR 0 2
101435: NOT
101436: IFFALSE 101440
// exit ;
101438: GO 101589
// un := tmp [ rand ( 1 , tmp ) ] ;
101440: LD_ADDR_VAR 0 3
101444: PUSH
101445: LD_VAR 0 2
101449: PUSH
101450: LD_INT 1
101452: PPUSH
101453: LD_VAR 0 2
101457: PPUSH
101458: CALL_OW 12
101462: ARRAY
101463: ST_TO_ADDR
// if Crawls ( un ) then
101464: LD_VAR 0 3
101468: PPUSH
101469: CALL_OW 318
101473: IFFALSE 101484
// ComWalk ( un ) ;
101475: LD_VAR 0 3
101479: PPUSH
101480: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101484: LD_VAR 0 3
101488: PPUSH
101489: LD_INT 8
101491: PPUSH
101492: CALL_OW 336
// end ; 4 :
101496: GO 101589
101498: LD_INT 4
101500: DOUBLE
101501: EQUAL
101502: IFTRUE 101506
101504: GO 101567
101506: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101507: LD_ADDR_VAR 0 2
101511: PUSH
101512: LD_INT 22
101514: PUSH
101515: LD_OWVAR 2
101519: PUSH
101520: EMPTY
101521: LIST
101522: LIST
101523: PUSH
101524: LD_INT 30
101526: PUSH
101527: LD_INT 29
101529: PUSH
101530: EMPTY
101531: LIST
101532: LIST
101533: PUSH
101534: EMPTY
101535: LIST
101536: LIST
101537: PPUSH
101538: CALL_OW 69
101542: ST_TO_ADDR
// if not tmp then
101543: LD_VAR 0 2
101547: NOT
101548: IFFALSE 101552
// exit ;
101550: GO 101589
// DestroyUnit ( tmp [ 1 ] ) ;
101552: LD_VAR 0 2
101556: PUSH
101557: LD_INT 1
101559: ARRAY
101560: PPUSH
101561: CALL_OW 65
// end ; 5 .. 7 :
101565: GO 101589
101567: LD_INT 5
101569: DOUBLE
101570: GREATEREQUAL
101571: IFFALSE 101579
101573: LD_INT 7
101575: DOUBLE
101576: LESSEQUAL
101577: IFTRUE 101581
101579: GO 101588
101581: POP
// StreamSibBomb ; end ;
101582: CALL 97839 0 0
101586: GO 101589
101588: POP
// end ;
101589: PPOPN 3
101591: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101592: LD_EXP 137
101596: PUSH
101597: LD_EXP 187
101601: AND
101602: IFFALSE 101758
101604: GO 101606
101606: DISABLE
101607: LD_INT 0
101609: PPUSH
101610: PPUSH
101611: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101612: LD_ADDR_VAR 0 2
101616: PUSH
101617: LD_INT 81
101619: PUSH
101620: LD_OWVAR 2
101624: PUSH
101625: EMPTY
101626: LIST
101627: LIST
101628: PUSH
101629: LD_INT 2
101631: PUSH
101632: LD_INT 21
101634: PUSH
101635: LD_INT 1
101637: PUSH
101638: EMPTY
101639: LIST
101640: LIST
101641: PUSH
101642: LD_INT 21
101644: PUSH
101645: LD_INT 2
101647: PUSH
101648: EMPTY
101649: LIST
101650: LIST
101651: PUSH
101652: EMPTY
101653: LIST
101654: LIST
101655: LIST
101656: PUSH
101657: EMPTY
101658: LIST
101659: LIST
101660: PPUSH
101661: CALL_OW 69
101665: ST_TO_ADDR
// if not tmp then
101666: LD_VAR 0 2
101670: NOT
101671: IFFALSE 101675
// exit ;
101673: GO 101758
// p := 0 ;
101675: LD_ADDR_VAR 0 3
101679: PUSH
101680: LD_INT 0
101682: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101683: LD_INT 35
101685: PPUSH
101686: CALL_OW 67
// p := p + 1 ;
101690: LD_ADDR_VAR 0 3
101694: PUSH
101695: LD_VAR 0 3
101699: PUSH
101700: LD_INT 1
101702: PLUS
101703: ST_TO_ADDR
// for i in tmp do
101704: LD_ADDR_VAR 0 1
101708: PUSH
101709: LD_VAR 0 2
101713: PUSH
101714: FOR_IN
101715: IFFALSE 101746
// if GetLives ( i ) < 1000 then
101717: LD_VAR 0 1
101721: PPUSH
101722: CALL_OW 256
101726: PUSH
101727: LD_INT 1000
101729: LESS
101730: IFFALSE 101744
// SetLives ( i , 1000 ) ;
101732: LD_VAR 0 1
101736: PPUSH
101737: LD_INT 1000
101739: PPUSH
101740: CALL_OW 234
101744: GO 101714
101746: POP
101747: POP
// until p > 20 ;
101748: LD_VAR 0 3
101752: PUSH
101753: LD_INT 20
101755: GREATER
101756: IFFALSE 101683
// end ;
101758: PPOPN 3
101760: END
// every 0 0$1 trigger StreamModeActive and sTime do
101761: LD_EXP 137
101765: PUSH
101766: LD_EXP 188
101770: AND
101771: IFFALSE 101806
101773: GO 101775
101775: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101776: LD_INT 28
101778: PPUSH
101779: LD_OWVAR 2
101783: PPUSH
101784: LD_INT 2
101786: PPUSH
101787: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101791: LD_INT 30
101793: PPUSH
101794: LD_OWVAR 2
101798: PPUSH
101799: LD_INT 2
101801: PPUSH
101802: CALL_OW 322
// end ;
101806: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101807: LD_EXP 137
101811: PUSH
101812: LD_EXP 189
101816: AND
101817: IFFALSE 101938
101819: GO 101821
101821: DISABLE
101822: LD_INT 0
101824: PPUSH
101825: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101826: LD_ADDR_VAR 0 2
101830: PUSH
101831: LD_INT 22
101833: PUSH
101834: LD_OWVAR 2
101838: PUSH
101839: EMPTY
101840: LIST
101841: LIST
101842: PUSH
101843: LD_INT 21
101845: PUSH
101846: LD_INT 1
101848: PUSH
101849: EMPTY
101850: LIST
101851: LIST
101852: PUSH
101853: LD_INT 3
101855: PUSH
101856: LD_INT 23
101858: PUSH
101859: LD_INT 0
101861: PUSH
101862: EMPTY
101863: LIST
101864: LIST
101865: PUSH
101866: EMPTY
101867: LIST
101868: LIST
101869: PUSH
101870: EMPTY
101871: LIST
101872: LIST
101873: LIST
101874: PPUSH
101875: CALL_OW 69
101879: ST_TO_ADDR
// if not tmp then
101880: LD_VAR 0 2
101884: NOT
101885: IFFALSE 101889
// exit ;
101887: GO 101938
// for i in tmp do
101889: LD_ADDR_VAR 0 1
101893: PUSH
101894: LD_VAR 0 2
101898: PUSH
101899: FOR_IN
101900: IFFALSE 101936
// begin if Crawls ( i ) then
101902: LD_VAR 0 1
101906: PPUSH
101907: CALL_OW 318
101911: IFFALSE 101922
// ComWalk ( i ) ;
101913: LD_VAR 0 1
101917: PPUSH
101918: CALL_OW 138
// SetClass ( i , 2 ) ;
101922: LD_VAR 0 1
101926: PPUSH
101927: LD_INT 2
101929: PPUSH
101930: CALL_OW 336
// end ;
101934: GO 101899
101936: POP
101937: POP
// end ;
101938: PPOPN 2
101940: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101941: LD_EXP 137
101945: PUSH
101946: LD_EXP 190
101950: AND
101951: IFFALSE 102232
101953: GO 101955
101955: DISABLE
101956: LD_INT 0
101958: PPUSH
101959: PPUSH
101960: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101961: LD_OWVAR 2
101965: PPUSH
101966: LD_INT 9
101968: PPUSH
101969: LD_INT 1
101971: PPUSH
101972: LD_INT 1
101974: PPUSH
101975: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101979: LD_INT 9
101981: PPUSH
101982: LD_OWVAR 2
101986: PPUSH
101987: CALL_OW 343
// uc_side := 9 ;
101991: LD_ADDR_OWVAR 20
101995: PUSH
101996: LD_INT 9
101998: ST_TO_ADDR
// uc_nation := 2 ;
101999: LD_ADDR_OWVAR 21
102003: PUSH
102004: LD_INT 2
102006: ST_TO_ADDR
// hc_name := Dark Warrior ;
102007: LD_ADDR_OWVAR 26
102011: PUSH
102012: LD_STRING Dark Warrior
102014: ST_TO_ADDR
// hc_gallery :=  ;
102015: LD_ADDR_OWVAR 33
102019: PUSH
102020: LD_STRING 
102022: ST_TO_ADDR
// hc_noskilllimit := true ;
102023: LD_ADDR_OWVAR 76
102027: PUSH
102028: LD_INT 1
102030: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102031: LD_ADDR_OWVAR 31
102035: PUSH
102036: LD_INT 30
102038: PUSH
102039: LD_INT 30
102041: PUSH
102042: LD_INT 30
102044: PUSH
102045: LD_INT 30
102047: PUSH
102048: EMPTY
102049: LIST
102050: LIST
102051: LIST
102052: LIST
102053: ST_TO_ADDR
// un := CreateHuman ;
102054: LD_ADDR_VAR 0 3
102058: PUSH
102059: CALL_OW 44
102063: ST_TO_ADDR
// hc_noskilllimit := false ;
102064: LD_ADDR_OWVAR 76
102068: PUSH
102069: LD_INT 0
102071: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102072: LD_VAR 0 3
102076: PPUSH
102077: LD_INT 1
102079: PPUSH
102080: CALL_OW 51
// p := 0 ;
102084: LD_ADDR_VAR 0 2
102088: PUSH
102089: LD_INT 0
102091: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102092: LD_INT 35
102094: PPUSH
102095: CALL_OW 67
// p := p + 1 ;
102099: LD_ADDR_VAR 0 2
102103: PUSH
102104: LD_VAR 0 2
102108: PUSH
102109: LD_INT 1
102111: PLUS
102112: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102113: LD_VAR 0 3
102117: PPUSH
102118: CALL_OW 256
102122: PUSH
102123: LD_INT 1000
102125: LESS
102126: IFFALSE 102140
// SetLives ( un , 1000 ) ;
102128: LD_VAR 0 3
102132: PPUSH
102133: LD_INT 1000
102135: PPUSH
102136: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102140: LD_VAR 0 3
102144: PPUSH
102145: LD_INT 81
102147: PUSH
102148: LD_OWVAR 2
102152: PUSH
102153: EMPTY
102154: LIST
102155: LIST
102156: PUSH
102157: LD_INT 91
102159: PUSH
102160: LD_VAR 0 3
102164: PUSH
102165: LD_INT 30
102167: PUSH
102168: EMPTY
102169: LIST
102170: LIST
102171: LIST
102172: PUSH
102173: EMPTY
102174: LIST
102175: LIST
102176: PPUSH
102177: CALL_OW 69
102181: PPUSH
102182: LD_VAR 0 3
102186: PPUSH
102187: CALL_OW 74
102191: PPUSH
102192: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
102196: LD_VAR 0 2
102200: PUSH
102201: LD_INT 60
102203: GREATER
102204: PUSH
102205: LD_VAR 0 3
102209: PPUSH
102210: CALL_OW 301
102214: OR
102215: IFFALSE 102092
// if un then
102217: LD_VAR 0 3
102221: IFFALSE 102232
// RemoveUnit ( un ) ;
102223: LD_VAR 0 3
102227: PPUSH
102228: CALL_OW 64
// end ;
102232: PPOPN 3
102234: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102235: LD_INT 0
102237: PPUSH
// case cmd of 301 :
102238: LD_VAR 0 1
102242: PUSH
102243: LD_INT 301
102245: DOUBLE
102246: EQUAL
102247: IFTRUE 102251
102249: GO 102283
102251: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102252: LD_VAR 0 6
102256: PPUSH
102257: LD_VAR 0 7
102261: PPUSH
102262: LD_VAR 0 8
102266: PPUSH
102267: LD_VAR 0 4
102271: PPUSH
102272: LD_VAR 0 5
102276: PPUSH
102277: CALL 103484 0 5
102281: GO 102404
102283: LD_INT 302
102285: DOUBLE
102286: EQUAL
102287: IFTRUE 102291
102289: GO 102328
102291: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102292: LD_VAR 0 6
102296: PPUSH
102297: LD_VAR 0 7
102301: PPUSH
102302: LD_VAR 0 8
102306: PPUSH
102307: LD_VAR 0 9
102311: PPUSH
102312: LD_VAR 0 4
102316: PPUSH
102317: LD_VAR 0 5
102321: PPUSH
102322: CALL 103575 0 6
102326: GO 102404
102328: LD_INT 303
102330: DOUBLE
102331: EQUAL
102332: IFTRUE 102336
102334: GO 102373
102336: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102337: LD_VAR 0 6
102341: PPUSH
102342: LD_VAR 0 7
102346: PPUSH
102347: LD_VAR 0 8
102351: PPUSH
102352: LD_VAR 0 9
102356: PPUSH
102357: LD_VAR 0 4
102361: PPUSH
102362: LD_VAR 0 5
102366: PPUSH
102367: CALL 102409 0 6
102371: GO 102404
102373: LD_INT 304
102375: DOUBLE
102376: EQUAL
102377: IFTRUE 102381
102379: GO 102403
102381: POP
// hHackTeleport ( unit , x , y ) ; end ;
102382: LD_VAR 0 2
102386: PPUSH
102387: LD_VAR 0 4
102391: PPUSH
102392: LD_VAR 0 5
102396: PPUSH
102397: CALL 104168 0 3
102401: GO 102404
102403: POP
// end ;
102404: LD_VAR 0 12
102408: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102409: LD_INT 0
102411: PPUSH
102412: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102413: LD_VAR 0 1
102417: PUSH
102418: LD_INT 1
102420: LESS
102421: PUSH
102422: LD_VAR 0 1
102426: PUSH
102427: LD_INT 3
102429: GREATER
102430: OR
102431: PUSH
102432: LD_VAR 0 5
102436: PPUSH
102437: LD_VAR 0 6
102441: PPUSH
102442: CALL_OW 428
102446: OR
102447: IFFALSE 102451
// exit ;
102449: GO 103171
// uc_side := your_side ;
102451: LD_ADDR_OWVAR 20
102455: PUSH
102456: LD_OWVAR 2
102460: ST_TO_ADDR
// uc_nation := nation ;
102461: LD_ADDR_OWVAR 21
102465: PUSH
102466: LD_VAR 0 1
102470: ST_TO_ADDR
// bc_level = 1 ;
102471: LD_ADDR_OWVAR 43
102475: PUSH
102476: LD_INT 1
102478: ST_TO_ADDR
// case btype of 1 :
102479: LD_VAR 0 2
102483: PUSH
102484: LD_INT 1
102486: DOUBLE
102487: EQUAL
102488: IFTRUE 102492
102490: GO 102503
102492: POP
// bc_type := b_depot ; 2 :
102493: LD_ADDR_OWVAR 42
102497: PUSH
102498: LD_INT 0
102500: ST_TO_ADDR
102501: GO 103115
102503: LD_INT 2
102505: DOUBLE
102506: EQUAL
102507: IFTRUE 102511
102509: GO 102522
102511: POP
// bc_type := b_warehouse ; 3 :
102512: LD_ADDR_OWVAR 42
102516: PUSH
102517: LD_INT 1
102519: ST_TO_ADDR
102520: GO 103115
102522: LD_INT 3
102524: DOUBLE
102525: EQUAL
102526: IFTRUE 102530
102528: GO 102541
102530: POP
// bc_type := b_lab ; 4 .. 9 :
102531: LD_ADDR_OWVAR 42
102535: PUSH
102536: LD_INT 6
102538: ST_TO_ADDR
102539: GO 103115
102541: LD_INT 4
102543: DOUBLE
102544: GREATEREQUAL
102545: IFFALSE 102553
102547: LD_INT 9
102549: DOUBLE
102550: LESSEQUAL
102551: IFTRUE 102555
102553: GO 102607
102555: POP
// begin bc_type := b_lab_half ;
102556: LD_ADDR_OWVAR 42
102560: PUSH
102561: LD_INT 7
102563: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102564: LD_ADDR_OWVAR 44
102568: PUSH
102569: LD_INT 10
102571: PUSH
102572: LD_INT 11
102574: PUSH
102575: LD_INT 12
102577: PUSH
102578: LD_INT 15
102580: PUSH
102581: LD_INT 14
102583: PUSH
102584: LD_INT 13
102586: PUSH
102587: EMPTY
102588: LIST
102589: LIST
102590: LIST
102591: LIST
102592: LIST
102593: LIST
102594: PUSH
102595: LD_VAR 0 2
102599: PUSH
102600: LD_INT 3
102602: MINUS
102603: ARRAY
102604: ST_TO_ADDR
// end ; 10 .. 13 :
102605: GO 103115
102607: LD_INT 10
102609: DOUBLE
102610: GREATEREQUAL
102611: IFFALSE 102619
102613: LD_INT 13
102615: DOUBLE
102616: LESSEQUAL
102617: IFTRUE 102621
102619: GO 102698
102621: POP
// begin bc_type := b_lab_full ;
102622: LD_ADDR_OWVAR 42
102626: PUSH
102627: LD_INT 8
102629: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102630: LD_ADDR_OWVAR 44
102634: PUSH
102635: LD_INT 10
102637: PUSH
102638: LD_INT 12
102640: PUSH
102641: LD_INT 14
102643: PUSH
102644: LD_INT 13
102646: PUSH
102647: EMPTY
102648: LIST
102649: LIST
102650: LIST
102651: LIST
102652: PUSH
102653: LD_VAR 0 2
102657: PUSH
102658: LD_INT 9
102660: MINUS
102661: ARRAY
102662: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102663: LD_ADDR_OWVAR 45
102667: PUSH
102668: LD_INT 11
102670: PUSH
102671: LD_INT 15
102673: PUSH
102674: LD_INT 12
102676: PUSH
102677: LD_INT 15
102679: PUSH
102680: EMPTY
102681: LIST
102682: LIST
102683: LIST
102684: LIST
102685: PUSH
102686: LD_VAR 0 2
102690: PUSH
102691: LD_INT 9
102693: MINUS
102694: ARRAY
102695: ST_TO_ADDR
// end ; 14 :
102696: GO 103115
102698: LD_INT 14
102700: DOUBLE
102701: EQUAL
102702: IFTRUE 102706
102704: GO 102717
102706: POP
// bc_type := b_workshop ; 15 :
102707: LD_ADDR_OWVAR 42
102711: PUSH
102712: LD_INT 2
102714: ST_TO_ADDR
102715: GO 103115
102717: LD_INT 15
102719: DOUBLE
102720: EQUAL
102721: IFTRUE 102725
102723: GO 102736
102725: POP
// bc_type := b_factory ; 16 :
102726: LD_ADDR_OWVAR 42
102730: PUSH
102731: LD_INT 3
102733: ST_TO_ADDR
102734: GO 103115
102736: LD_INT 16
102738: DOUBLE
102739: EQUAL
102740: IFTRUE 102744
102742: GO 102755
102744: POP
// bc_type := b_ext_gun ; 17 :
102745: LD_ADDR_OWVAR 42
102749: PUSH
102750: LD_INT 17
102752: ST_TO_ADDR
102753: GO 103115
102755: LD_INT 17
102757: DOUBLE
102758: EQUAL
102759: IFTRUE 102763
102761: GO 102791
102763: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102764: LD_ADDR_OWVAR 42
102768: PUSH
102769: LD_INT 19
102771: PUSH
102772: LD_INT 23
102774: PUSH
102775: LD_INT 19
102777: PUSH
102778: EMPTY
102779: LIST
102780: LIST
102781: LIST
102782: PUSH
102783: LD_VAR 0 1
102787: ARRAY
102788: ST_TO_ADDR
102789: GO 103115
102791: LD_INT 18
102793: DOUBLE
102794: EQUAL
102795: IFTRUE 102799
102797: GO 102810
102799: POP
// bc_type := b_ext_radar ; 19 :
102800: LD_ADDR_OWVAR 42
102804: PUSH
102805: LD_INT 20
102807: ST_TO_ADDR
102808: GO 103115
102810: LD_INT 19
102812: DOUBLE
102813: EQUAL
102814: IFTRUE 102818
102816: GO 102829
102818: POP
// bc_type := b_ext_radio ; 20 :
102819: LD_ADDR_OWVAR 42
102823: PUSH
102824: LD_INT 22
102826: ST_TO_ADDR
102827: GO 103115
102829: LD_INT 20
102831: DOUBLE
102832: EQUAL
102833: IFTRUE 102837
102835: GO 102848
102837: POP
// bc_type := b_ext_siberium ; 21 :
102838: LD_ADDR_OWVAR 42
102842: PUSH
102843: LD_INT 21
102845: ST_TO_ADDR
102846: GO 103115
102848: LD_INT 21
102850: DOUBLE
102851: EQUAL
102852: IFTRUE 102856
102854: GO 102867
102856: POP
// bc_type := b_ext_computer ; 22 :
102857: LD_ADDR_OWVAR 42
102861: PUSH
102862: LD_INT 24
102864: ST_TO_ADDR
102865: GO 103115
102867: LD_INT 22
102869: DOUBLE
102870: EQUAL
102871: IFTRUE 102875
102873: GO 102886
102875: POP
// bc_type := b_ext_track ; 23 :
102876: LD_ADDR_OWVAR 42
102880: PUSH
102881: LD_INT 16
102883: ST_TO_ADDR
102884: GO 103115
102886: LD_INT 23
102888: DOUBLE
102889: EQUAL
102890: IFTRUE 102894
102892: GO 102905
102894: POP
// bc_type := b_ext_laser ; 24 :
102895: LD_ADDR_OWVAR 42
102899: PUSH
102900: LD_INT 25
102902: ST_TO_ADDR
102903: GO 103115
102905: LD_INT 24
102907: DOUBLE
102908: EQUAL
102909: IFTRUE 102913
102911: GO 102924
102913: POP
// bc_type := b_control_tower ; 25 :
102914: LD_ADDR_OWVAR 42
102918: PUSH
102919: LD_INT 36
102921: ST_TO_ADDR
102922: GO 103115
102924: LD_INT 25
102926: DOUBLE
102927: EQUAL
102928: IFTRUE 102932
102930: GO 102943
102932: POP
// bc_type := b_breastwork ; 26 :
102933: LD_ADDR_OWVAR 42
102937: PUSH
102938: LD_INT 31
102940: ST_TO_ADDR
102941: GO 103115
102943: LD_INT 26
102945: DOUBLE
102946: EQUAL
102947: IFTRUE 102951
102949: GO 102962
102951: POP
// bc_type := b_bunker ; 27 :
102952: LD_ADDR_OWVAR 42
102956: PUSH
102957: LD_INT 32
102959: ST_TO_ADDR
102960: GO 103115
102962: LD_INT 27
102964: DOUBLE
102965: EQUAL
102966: IFTRUE 102970
102968: GO 102981
102970: POP
// bc_type := b_turret ; 28 :
102971: LD_ADDR_OWVAR 42
102975: PUSH
102976: LD_INT 33
102978: ST_TO_ADDR
102979: GO 103115
102981: LD_INT 28
102983: DOUBLE
102984: EQUAL
102985: IFTRUE 102989
102987: GO 103000
102989: POP
// bc_type := b_armoury ; 29 :
102990: LD_ADDR_OWVAR 42
102994: PUSH
102995: LD_INT 4
102997: ST_TO_ADDR
102998: GO 103115
103000: LD_INT 29
103002: DOUBLE
103003: EQUAL
103004: IFTRUE 103008
103006: GO 103019
103008: POP
// bc_type := b_barracks ; 30 :
103009: LD_ADDR_OWVAR 42
103013: PUSH
103014: LD_INT 5
103016: ST_TO_ADDR
103017: GO 103115
103019: LD_INT 30
103021: DOUBLE
103022: EQUAL
103023: IFTRUE 103027
103025: GO 103038
103027: POP
// bc_type := b_solar_power ; 31 :
103028: LD_ADDR_OWVAR 42
103032: PUSH
103033: LD_INT 27
103035: ST_TO_ADDR
103036: GO 103115
103038: LD_INT 31
103040: DOUBLE
103041: EQUAL
103042: IFTRUE 103046
103044: GO 103057
103046: POP
// bc_type := b_oil_power ; 32 :
103047: LD_ADDR_OWVAR 42
103051: PUSH
103052: LD_INT 26
103054: ST_TO_ADDR
103055: GO 103115
103057: LD_INT 32
103059: DOUBLE
103060: EQUAL
103061: IFTRUE 103065
103063: GO 103076
103065: POP
// bc_type := b_siberite_power ; 33 :
103066: LD_ADDR_OWVAR 42
103070: PUSH
103071: LD_INT 28
103073: ST_TO_ADDR
103074: GO 103115
103076: LD_INT 33
103078: DOUBLE
103079: EQUAL
103080: IFTRUE 103084
103082: GO 103095
103084: POP
// bc_type := b_oil_mine ; 34 :
103085: LD_ADDR_OWVAR 42
103089: PUSH
103090: LD_INT 29
103092: ST_TO_ADDR
103093: GO 103115
103095: LD_INT 34
103097: DOUBLE
103098: EQUAL
103099: IFTRUE 103103
103101: GO 103114
103103: POP
// bc_type := b_siberite_mine ; end ;
103104: LD_ADDR_OWVAR 42
103108: PUSH
103109: LD_INT 30
103111: ST_TO_ADDR
103112: GO 103115
103114: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103115: LD_ADDR_VAR 0 8
103119: PUSH
103120: LD_VAR 0 5
103124: PPUSH
103125: LD_VAR 0 6
103129: PPUSH
103130: LD_VAR 0 3
103134: PPUSH
103135: CALL_OW 47
103139: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103140: LD_OWVAR 42
103144: PUSH
103145: LD_INT 32
103147: PUSH
103148: LD_INT 33
103150: PUSH
103151: EMPTY
103152: LIST
103153: LIST
103154: IN
103155: IFFALSE 103171
// PlaceWeaponTurret ( b , weapon ) ;
103157: LD_VAR 0 8
103161: PPUSH
103162: LD_VAR 0 4
103166: PPUSH
103167: CALL_OW 431
// end ;
103171: LD_VAR 0 7
103175: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103176: LD_INT 0
103178: PPUSH
103179: PPUSH
103180: PPUSH
103181: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103182: LD_ADDR_VAR 0 4
103186: PUSH
103187: LD_INT 22
103189: PUSH
103190: LD_OWVAR 2
103194: PUSH
103195: EMPTY
103196: LIST
103197: LIST
103198: PUSH
103199: LD_INT 2
103201: PUSH
103202: LD_INT 30
103204: PUSH
103205: LD_INT 0
103207: PUSH
103208: EMPTY
103209: LIST
103210: LIST
103211: PUSH
103212: LD_INT 30
103214: PUSH
103215: LD_INT 1
103217: PUSH
103218: EMPTY
103219: LIST
103220: LIST
103221: PUSH
103222: EMPTY
103223: LIST
103224: LIST
103225: LIST
103226: PUSH
103227: EMPTY
103228: LIST
103229: LIST
103230: PPUSH
103231: CALL_OW 69
103235: ST_TO_ADDR
// if not tmp then
103236: LD_VAR 0 4
103240: NOT
103241: IFFALSE 103245
// exit ;
103243: GO 103304
// for i in tmp do
103245: LD_ADDR_VAR 0 2
103249: PUSH
103250: LD_VAR 0 4
103254: PUSH
103255: FOR_IN
103256: IFFALSE 103302
// for j = 1 to 3 do
103258: LD_ADDR_VAR 0 3
103262: PUSH
103263: DOUBLE
103264: LD_INT 1
103266: DEC
103267: ST_TO_ADDR
103268: LD_INT 3
103270: PUSH
103271: FOR_TO
103272: IFFALSE 103298
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103274: LD_VAR 0 2
103278: PPUSH
103279: CALL_OW 274
103283: PPUSH
103284: LD_VAR 0 3
103288: PPUSH
103289: LD_INT 99999
103291: PPUSH
103292: CALL_OW 277
103296: GO 103271
103298: POP
103299: POP
103300: GO 103255
103302: POP
103303: POP
// end ;
103304: LD_VAR 0 1
103308: RET
// export function hHackSetLevel10 ; var i , j ; begin
103309: LD_INT 0
103311: PPUSH
103312: PPUSH
103313: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103314: LD_ADDR_VAR 0 2
103318: PUSH
103319: LD_INT 21
103321: PUSH
103322: LD_INT 1
103324: PUSH
103325: EMPTY
103326: LIST
103327: LIST
103328: PPUSH
103329: CALL_OW 69
103333: PUSH
103334: FOR_IN
103335: IFFALSE 103387
// if IsSelected ( i ) then
103337: LD_VAR 0 2
103341: PPUSH
103342: CALL_OW 306
103346: IFFALSE 103385
// begin for j := 1 to 4 do
103348: LD_ADDR_VAR 0 3
103352: PUSH
103353: DOUBLE
103354: LD_INT 1
103356: DEC
103357: ST_TO_ADDR
103358: LD_INT 4
103360: PUSH
103361: FOR_TO
103362: IFFALSE 103383
// SetSkill ( i , j , 10 ) ;
103364: LD_VAR 0 2
103368: PPUSH
103369: LD_VAR 0 3
103373: PPUSH
103374: LD_INT 10
103376: PPUSH
103377: CALL_OW 237
103381: GO 103361
103383: POP
103384: POP
// end ;
103385: GO 103334
103387: POP
103388: POP
// end ;
103389: LD_VAR 0 1
103393: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103394: LD_INT 0
103396: PPUSH
103397: PPUSH
103398: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103399: LD_ADDR_VAR 0 2
103403: PUSH
103404: LD_INT 22
103406: PUSH
103407: LD_OWVAR 2
103411: PUSH
103412: EMPTY
103413: LIST
103414: LIST
103415: PUSH
103416: LD_INT 21
103418: PUSH
103419: LD_INT 1
103421: PUSH
103422: EMPTY
103423: LIST
103424: LIST
103425: PUSH
103426: EMPTY
103427: LIST
103428: LIST
103429: PPUSH
103430: CALL_OW 69
103434: PUSH
103435: FOR_IN
103436: IFFALSE 103477
// begin for j := 1 to 4 do
103438: LD_ADDR_VAR 0 3
103442: PUSH
103443: DOUBLE
103444: LD_INT 1
103446: DEC
103447: ST_TO_ADDR
103448: LD_INT 4
103450: PUSH
103451: FOR_TO
103452: IFFALSE 103473
// SetSkill ( i , j , 10 ) ;
103454: LD_VAR 0 2
103458: PPUSH
103459: LD_VAR 0 3
103463: PPUSH
103464: LD_INT 10
103466: PPUSH
103467: CALL_OW 237
103471: GO 103451
103473: POP
103474: POP
// end ;
103475: GO 103435
103477: POP
103478: POP
// end ;
103479: LD_VAR 0 1
103483: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103484: LD_INT 0
103486: PPUSH
// uc_side := your_side ;
103487: LD_ADDR_OWVAR 20
103491: PUSH
103492: LD_OWVAR 2
103496: ST_TO_ADDR
// uc_nation := nation ;
103497: LD_ADDR_OWVAR 21
103501: PUSH
103502: LD_VAR 0 1
103506: ST_TO_ADDR
// InitHc ;
103507: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103511: LD_INT 0
103513: PPUSH
103514: LD_VAR 0 2
103518: PPUSH
103519: LD_VAR 0 3
103523: PPUSH
103524: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103528: LD_VAR 0 4
103532: PPUSH
103533: LD_VAR 0 5
103537: PPUSH
103538: CALL_OW 428
103542: PUSH
103543: LD_INT 0
103545: EQUAL
103546: IFFALSE 103570
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103548: CALL_OW 44
103552: PPUSH
103553: LD_VAR 0 4
103557: PPUSH
103558: LD_VAR 0 5
103562: PPUSH
103563: LD_INT 1
103565: PPUSH
103566: CALL_OW 48
// end ;
103570: LD_VAR 0 6
103574: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103575: LD_INT 0
103577: PPUSH
103578: PPUSH
// uc_side := your_side ;
103579: LD_ADDR_OWVAR 20
103583: PUSH
103584: LD_OWVAR 2
103588: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103589: LD_VAR 0 1
103593: PUSH
103594: LD_INT 1
103596: PUSH
103597: LD_INT 2
103599: PUSH
103600: LD_INT 3
103602: PUSH
103603: LD_INT 4
103605: PUSH
103606: LD_INT 5
103608: PUSH
103609: EMPTY
103610: LIST
103611: LIST
103612: LIST
103613: LIST
103614: LIST
103615: IN
103616: IFFALSE 103628
// uc_nation := nation_american else
103618: LD_ADDR_OWVAR 21
103622: PUSH
103623: LD_INT 1
103625: ST_TO_ADDR
103626: GO 103671
// if chassis in [ 11 , 12 , 13 , 14 ] then
103628: LD_VAR 0 1
103632: PUSH
103633: LD_INT 11
103635: PUSH
103636: LD_INT 12
103638: PUSH
103639: LD_INT 13
103641: PUSH
103642: LD_INT 14
103644: PUSH
103645: EMPTY
103646: LIST
103647: LIST
103648: LIST
103649: LIST
103650: IN
103651: IFFALSE 103663
// uc_nation := nation_arabian else
103653: LD_ADDR_OWVAR 21
103657: PUSH
103658: LD_INT 2
103660: ST_TO_ADDR
103661: GO 103671
// uc_nation := nation_russian ;
103663: LD_ADDR_OWVAR 21
103667: PUSH
103668: LD_INT 3
103670: ST_TO_ADDR
// vc_chassis := chassis ;
103671: LD_ADDR_OWVAR 37
103675: PUSH
103676: LD_VAR 0 1
103680: ST_TO_ADDR
// vc_engine := engine ;
103681: LD_ADDR_OWVAR 39
103685: PUSH
103686: LD_VAR 0 2
103690: ST_TO_ADDR
// vc_control := control ;
103691: LD_ADDR_OWVAR 38
103695: PUSH
103696: LD_VAR 0 3
103700: ST_TO_ADDR
// vc_weapon := weapon ;
103701: LD_ADDR_OWVAR 40
103705: PUSH
103706: LD_VAR 0 4
103710: ST_TO_ADDR
// un := CreateVehicle ;
103711: LD_ADDR_VAR 0 8
103715: PUSH
103716: CALL_OW 45
103720: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103721: LD_VAR 0 8
103725: PPUSH
103726: LD_INT 0
103728: PPUSH
103729: LD_INT 5
103731: PPUSH
103732: CALL_OW 12
103736: PPUSH
103737: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103741: LD_VAR 0 8
103745: PPUSH
103746: LD_VAR 0 5
103750: PPUSH
103751: LD_VAR 0 6
103755: PPUSH
103756: LD_INT 1
103758: PPUSH
103759: CALL_OW 48
// end ;
103763: LD_VAR 0 7
103767: RET
// export hInvincible ; every 1 do
103768: GO 103770
103770: DISABLE
// hInvincible := [ ] ;
103771: LD_ADDR_EXP 191
103775: PUSH
103776: EMPTY
103777: ST_TO_ADDR
103778: END
// every 10 do var i ;
103779: GO 103781
103781: DISABLE
103782: LD_INT 0
103784: PPUSH
// begin enable ;
103785: ENABLE
// if not hInvincible then
103786: LD_EXP 191
103790: NOT
103791: IFFALSE 103795
// exit ;
103793: GO 103839
// for i in hInvincible do
103795: LD_ADDR_VAR 0 1
103799: PUSH
103800: LD_EXP 191
103804: PUSH
103805: FOR_IN
103806: IFFALSE 103837
// if GetLives ( i ) < 1000 then
103808: LD_VAR 0 1
103812: PPUSH
103813: CALL_OW 256
103817: PUSH
103818: LD_INT 1000
103820: LESS
103821: IFFALSE 103835
// SetLives ( i , 1000 ) ;
103823: LD_VAR 0 1
103827: PPUSH
103828: LD_INT 1000
103830: PPUSH
103831: CALL_OW 234
103835: GO 103805
103837: POP
103838: POP
// end ;
103839: PPOPN 1
103841: END
// export function hHackInvincible ; var i ; begin
103842: LD_INT 0
103844: PPUSH
103845: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103846: LD_ADDR_VAR 0 2
103850: PUSH
103851: LD_INT 2
103853: PUSH
103854: LD_INT 21
103856: PUSH
103857: LD_INT 1
103859: PUSH
103860: EMPTY
103861: LIST
103862: LIST
103863: PUSH
103864: LD_INT 21
103866: PUSH
103867: LD_INT 2
103869: PUSH
103870: EMPTY
103871: LIST
103872: LIST
103873: PUSH
103874: EMPTY
103875: LIST
103876: LIST
103877: LIST
103878: PPUSH
103879: CALL_OW 69
103883: PUSH
103884: FOR_IN
103885: IFFALSE 103946
// if IsSelected ( i ) then
103887: LD_VAR 0 2
103891: PPUSH
103892: CALL_OW 306
103896: IFFALSE 103944
// begin if i in hInvincible then
103898: LD_VAR 0 2
103902: PUSH
103903: LD_EXP 191
103907: IN
103908: IFFALSE 103928
// hInvincible := hInvincible diff i else
103910: LD_ADDR_EXP 191
103914: PUSH
103915: LD_EXP 191
103919: PUSH
103920: LD_VAR 0 2
103924: DIFF
103925: ST_TO_ADDR
103926: GO 103944
// hInvincible := hInvincible union i ;
103928: LD_ADDR_EXP 191
103932: PUSH
103933: LD_EXP 191
103937: PUSH
103938: LD_VAR 0 2
103942: UNION
103943: ST_TO_ADDR
// end ;
103944: GO 103884
103946: POP
103947: POP
// end ;
103948: LD_VAR 0 1
103952: RET
// export function hHackInvisible ; var i , j ; begin
103953: LD_INT 0
103955: PPUSH
103956: PPUSH
103957: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103958: LD_ADDR_VAR 0 2
103962: PUSH
103963: LD_INT 21
103965: PUSH
103966: LD_INT 1
103968: PUSH
103969: EMPTY
103970: LIST
103971: LIST
103972: PPUSH
103973: CALL_OW 69
103977: PUSH
103978: FOR_IN
103979: IFFALSE 104003
// if IsSelected ( i ) then
103981: LD_VAR 0 2
103985: PPUSH
103986: CALL_OW 306
103990: IFFALSE 104001
// ComForceInvisible ( i ) ;
103992: LD_VAR 0 2
103996: PPUSH
103997: CALL_OW 496
104001: GO 103978
104003: POP
104004: POP
// end ;
104005: LD_VAR 0 1
104009: RET
// export function hHackChangeYourSide ; begin
104010: LD_INT 0
104012: PPUSH
// if your_side = 8 then
104013: LD_OWVAR 2
104017: PUSH
104018: LD_INT 8
104020: EQUAL
104021: IFFALSE 104033
// your_side := 0 else
104023: LD_ADDR_OWVAR 2
104027: PUSH
104028: LD_INT 0
104030: ST_TO_ADDR
104031: GO 104047
// your_side := your_side + 1 ;
104033: LD_ADDR_OWVAR 2
104037: PUSH
104038: LD_OWVAR 2
104042: PUSH
104043: LD_INT 1
104045: PLUS
104046: ST_TO_ADDR
// end ;
104047: LD_VAR 0 1
104051: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104052: LD_INT 0
104054: PPUSH
104055: PPUSH
104056: PPUSH
// for i in all_units do
104057: LD_ADDR_VAR 0 2
104061: PUSH
104062: LD_OWVAR 3
104066: PUSH
104067: FOR_IN
104068: IFFALSE 104146
// if IsSelected ( i ) then
104070: LD_VAR 0 2
104074: PPUSH
104075: CALL_OW 306
104079: IFFALSE 104144
// begin j := GetSide ( i ) ;
104081: LD_ADDR_VAR 0 3
104085: PUSH
104086: LD_VAR 0 2
104090: PPUSH
104091: CALL_OW 255
104095: ST_TO_ADDR
// if j = 8 then
104096: LD_VAR 0 3
104100: PUSH
104101: LD_INT 8
104103: EQUAL
104104: IFFALSE 104116
// j := 0 else
104106: LD_ADDR_VAR 0 3
104110: PUSH
104111: LD_INT 0
104113: ST_TO_ADDR
104114: GO 104130
// j := j + 1 ;
104116: LD_ADDR_VAR 0 3
104120: PUSH
104121: LD_VAR 0 3
104125: PUSH
104126: LD_INT 1
104128: PLUS
104129: ST_TO_ADDR
// SetSide ( i , j ) ;
104130: LD_VAR 0 2
104134: PPUSH
104135: LD_VAR 0 3
104139: PPUSH
104140: CALL_OW 235
// end ;
104144: GO 104067
104146: POP
104147: POP
// end ;
104148: LD_VAR 0 1
104152: RET
// export function hHackFog ; begin
104153: LD_INT 0
104155: PPUSH
// FogOff ( true ) ;
104156: LD_INT 1
104158: PPUSH
104159: CALL_OW 344
// end ;
104163: LD_VAR 0 1
104167: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104168: LD_INT 0
104170: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104171: LD_VAR 0 1
104175: PPUSH
104176: LD_VAR 0 2
104180: PPUSH
104181: LD_VAR 0 3
104185: PPUSH
104186: LD_INT 1
104188: PPUSH
104189: LD_INT 1
104191: PPUSH
104192: CALL_OW 483
// CenterOnXY ( x , y ) ;
104196: LD_VAR 0 2
104200: PPUSH
104201: LD_VAR 0 3
104205: PPUSH
104206: CALL_OW 84
// end ; end_of_file
104210: LD_VAR 0 4
104214: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
104215: LD_INT 0
104217: PPUSH
104218: PPUSH
104219: PPUSH
104220: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
104221: LD_VAR 0 1
104225: PPUSH
104226: CALL_OW 264
104230: PUSH
104231: LD_EXP 76
104235: EQUAL
104236: IFFALSE 104308
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
104238: LD_INT 68
104240: PPUSH
104241: LD_VAR 0 1
104245: PPUSH
104246: CALL_OW 255
104250: PPUSH
104251: CALL_OW 321
104255: PUSH
104256: LD_INT 2
104258: EQUAL
104259: IFFALSE 104271
// eff := 70 else
104261: LD_ADDR_VAR 0 4
104265: PUSH
104266: LD_INT 70
104268: ST_TO_ADDR
104269: GO 104279
// eff := 30 ;
104271: LD_ADDR_VAR 0 4
104275: PUSH
104276: LD_INT 30
104278: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
104279: LD_VAR 0 1
104283: PPUSH
104284: CALL_OW 250
104288: PPUSH
104289: LD_VAR 0 1
104293: PPUSH
104294: CALL_OW 251
104298: PPUSH
104299: LD_VAR 0 4
104303: PPUSH
104304: CALL_OW 495
// end ; end ;
104308: LD_VAR 0 2
104312: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
104313: LD_INT 0
104315: PPUSH
// end ;
104316: LD_VAR 0 4
104320: RET
// export function SOS_Command ( cmd ) ; begin
104321: LD_INT 0
104323: PPUSH
// end ;
104324: LD_VAR 0 2
104328: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
104329: LD_INT 0
104331: PPUSH
// if cmd = 121 then
104332: LD_VAR 0 1
104336: PUSH
104337: LD_INT 121
104339: EQUAL
104340: IFFALSE 104342
// end ;
104342: LD_VAR 0 6
104346: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
104347: LD_INT 0
104349: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
104350: LD_VAR 0 1
104354: PUSH
104355: LD_INT 250
104357: EQUAL
104358: PUSH
104359: LD_VAR 0 2
104363: PPUSH
104364: CALL_OW 264
104368: PUSH
104369: LD_EXP 79
104373: EQUAL
104374: AND
104375: IFFALSE 104396
// MinerPlaceMine ( unit , x , y ) ;
104377: LD_VAR 0 2
104381: PPUSH
104382: LD_VAR 0 4
104386: PPUSH
104387: LD_VAR 0 5
104391: PPUSH
104392: CALL 106745 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
104396: LD_VAR 0 1
104400: PUSH
104401: LD_INT 251
104403: EQUAL
104404: PUSH
104405: LD_VAR 0 2
104409: PPUSH
104410: CALL_OW 264
104414: PUSH
104415: LD_EXP 79
104419: EQUAL
104420: AND
104421: IFFALSE 104442
// MinerDetonateMine ( unit , x , y ) ;
104423: LD_VAR 0 2
104427: PPUSH
104428: LD_VAR 0 4
104432: PPUSH
104433: LD_VAR 0 5
104437: PPUSH
104438: CALL 107022 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
104442: LD_VAR 0 1
104446: PUSH
104447: LD_INT 252
104449: EQUAL
104450: PUSH
104451: LD_VAR 0 2
104455: PPUSH
104456: CALL_OW 264
104460: PUSH
104461: LD_EXP 79
104465: EQUAL
104466: AND
104467: IFFALSE 104488
// MinerCreateMinefield ( unit , x , y ) ;
104469: LD_VAR 0 2
104473: PPUSH
104474: LD_VAR 0 4
104478: PPUSH
104479: LD_VAR 0 5
104483: PPUSH
104484: CALL 107439 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
104488: LD_VAR 0 1
104492: PUSH
104493: LD_INT 253
104495: EQUAL
104496: PUSH
104497: LD_VAR 0 2
104501: PPUSH
104502: CALL_OW 257
104506: PUSH
104507: LD_INT 5
104509: EQUAL
104510: AND
104511: IFFALSE 104532
// ComBinocular ( unit , x , y ) ;
104513: LD_VAR 0 2
104517: PPUSH
104518: LD_VAR 0 4
104522: PPUSH
104523: LD_VAR 0 5
104527: PPUSH
104528: CALL 107810 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
104532: LD_VAR 0 1
104536: PUSH
104537: LD_INT 254
104539: EQUAL
104540: PUSH
104541: LD_VAR 0 2
104545: PPUSH
104546: CALL_OW 264
104550: PUSH
104551: LD_EXP 74
104555: EQUAL
104556: AND
104557: PUSH
104558: LD_VAR 0 3
104562: PPUSH
104563: CALL_OW 263
104567: PUSH
104568: LD_INT 3
104570: EQUAL
104571: AND
104572: IFFALSE 104588
// HackDestroyVehicle ( unit , selectedUnit ) ;
104574: LD_VAR 0 2
104578: PPUSH
104579: LD_VAR 0 3
104583: PPUSH
104584: CALL 106105 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
104588: LD_VAR 0 1
104592: PUSH
104593: LD_INT 255
104595: EQUAL
104596: PUSH
104597: LD_VAR 0 2
104601: PPUSH
104602: CALL_OW 264
104606: PUSH
104607: LD_INT 14
104609: PUSH
104610: LD_INT 53
104612: PUSH
104613: EMPTY
104614: LIST
104615: LIST
104616: IN
104617: AND
104618: PUSH
104619: LD_VAR 0 4
104623: PPUSH
104624: LD_VAR 0 5
104628: PPUSH
104629: CALL_OW 488
104633: AND
104634: IFFALSE 104658
// CutTreeXYR ( unit , x , y , 12 ) ;
104636: LD_VAR 0 2
104640: PPUSH
104641: LD_VAR 0 4
104645: PPUSH
104646: LD_VAR 0 5
104650: PPUSH
104651: LD_INT 12
104653: PPUSH
104654: CALL 104671 0 4
// end ;
104658: LD_VAR 0 6
104662: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
104663: LD_INT 0
104665: PPUSH
// end ;
104666: LD_VAR 0 4
104670: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104671: LD_INT 0
104673: PPUSH
104674: PPUSH
104675: PPUSH
104676: PPUSH
104677: PPUSH
104678: PPUSH
104679: PPUSH
104680: PPUSH
104681: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
104682: LD_VAR 0 1
104686: NOT
104687: PUSH
104688: LD_VAR 0 2
104692: PPUSH
104693: LD_VAR 0 3
104697: PPUSH
104698: CALL_OW 488
104702: NOT
104703: OR
104704: PUSH
104705: LD_VAR 0 4
104709: NOT
104710: OR
104711: IFFALSE 104715
// exit ;
104713: GO 105055
// list := [ ] ;
104715: LD_ADDR_VAR 0 13
104719: PUSH
104720: EMPTY
104721: ST_TO_ADDR
// if x - r < 0 then
104722: LD_VAR 0 2
104726: PUSH
104727: LD_VAR 0 4
104731: MINUS
104732: PUSH
104733: LD_INT 0
104735: LESS
104736: IFFALSE 104748
// min_x := 0 else
104738: LD_ADDR_VAR 0 7
104742: PUSH
104743: LD_INT 0
104745: ST_TO_ADDR
104746: GO 104764
// min_x := x - r ;
104748: LD_ADDR_VAR 0 7
104752: PUSH
104753: LD_VAR 0 2
104757: PUSH
104758: LD_VAR 0 4
104762: MINUS
104763: ST_TO_ADDR
// if y - r < 0 then
104764: LD_VAR 0 3
104768: PUSH
104769: LD_VAR 0 4
104773: MINUS
104774: PUSH
104775: LD_INT 0
104777: LESS
104778: IFFALSE 104790
// min_y := 0 else
104780: LD_ADDR_VAR 0 8
104784: PUSH
104785: LD_INT 0
104787: ST_TO_ADDR
104788: GO 104806
// min_y := y - r ;
104790: LD_ADDR_VAR 0 8
104794: PUSH
104795: LD_VAR 0 3
104799: PUSH
104800: LD_VAR 0 4
104804: MINUS
104805: ST_TO_ADDR
// max_x := x + r ;
104806: LD_ADDR_VAR 0 9
104810: PUSH
104811: LD_VAR 0 2
104815: PUSH
104816: LD_VAR 0 4
104820: PLUS
104821: ST_TO_ADDR
// max_y := y + r ;
104822: LD_ADDR_VAR 0 10
104826: PUSH
104827: LD_VAR 0 3
104831: PUSH
104832: LD_VAR 0 4
104836: PLUS
104837: ST_TO_ADDR
// for _x = min_x to max_x do
104838: LD_ADDR_VAR 0 11
104842: PUSH
104843: DOUBLE
104844: LD_VAR 0 7
104848: DEC
104849: ST_TO_ADDR
104850: LD_VAR 0 9
104854: PUSH
104855: FOR_TO
104856: IFFALSE 104973
// for _y = min_y to max_y do
104858: LD_ADDR_VAR 0 12
104862: PUSH
104863: DOUBLE
104864: LD_VAR 0 8
104868: DEC
104869: ST_TO_ADDR
104870: LD_VAR 0 10
104874: PUSH
104875: FOR_TO
104876: IFFALSE 104969
// begin if not ValidHex ( _x , _y ) then
104878: LD_VAR 0 11
104882: PPUSH
104883: LD_VAR 0 12
104887: PPUSH
104888: CALL_OW 488
104892: NOT
104893: IFFALSE 104897
// continue ;
104895: GO 104875
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
104897: LD_VAR 0 11
104901: PPUSH
104902: LD_VAR 0 12
104906: PPUSH
104907: CALL_OW 351
104911: PUSH
104912: LD_VAR 0 11
104916: PPUSH
104917: LD_VAR 0 12
104921: PPUSH
104922: CALL_OW 554
104926: AND
104927: IFFALSE 104967
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
104929: LD_ADDR_VAR 0 13
104933: PUSH
104934: LD_VAR 0 13
104938: PPUSH
104939: LD_VAR 0 13
104943: PUSH
104944: LD_INT 1
104946: PLUS
104947: PPUSH
104948: LD_VAR 0 11
104952: PUSH
104953: LD_VAR 0 12
104957: PUSH
104958: EMPTY
104959: LIST
104960: LIST
104961: PPUSH
104962: CALL_OW 2
104966: ST_TO_ADDR
// end ;
104967: GO 104875
104969: POP
104970: POP
104971: GO 104855
104973: POP
104974: POP
// if not list then
104975: LD_VAR 0 13
104979: NOT
104980: IFFALSE 104984
// exit ;
104982: GO 105055
// for i in list do
104984: LD_ADDR_VAR 0 6
104988: PUSH
104989: LD_VAR 0 13
104993: PUSH
104994: FOR_IN
104995: IFFALSE 105053
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
104997: LD_VAR 0 1
105001: PPUSH
105002: LD_STRING M
105004: PUSH
105005: LD_VAR 0 6
105009: PUSH
105010: LD_INT 1
105012: ARRAY
105013: PUSH
105014: LD_VAR 0 6
105018: PUSH
105019: LD_INT 2
105021: ARRAY
105022: PUSH
105023: LD_INT 0
105025: PUSH
105026: LD_INT 0
105028: PUSH
105029: LD_INT 0
105031: PUSH
105032: LD_INT 0
105034: PUSH
105035: EMPTY
105036: LIST
105037: LIST
105038: LIST
105039: LIST
105040: LIST
105041: LIST
105042: LIST
105043: PUSH
105044: EMPTY
105045: LIST
105046: PPUSH
105047: CALL_OW 447
105051: GO 104994
105053: POP
105054: POP
// end ;
105055: LD_VAR 0 5
105059: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
105060: LD_EXP 194
105064: NOT
105065: IFFALSE 105115
105067: GO 105069
105069: DISABLE
// begin initHack := true ;
105070: LD_ADDR_EXP 194
105074: PUSH
105075: LD_INT 1
105077: ST_TO_ADDR
// hackTanks := [ ] ;
105078: LD_ADDR_EXP 195
105082: PUSH
105083: EMPTY
105084: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
105085: LD_ADDR_EXP 196
105089: PUSH
105090: EMPTY
105091: ST_TO_ADDR
// hackLimit := 3 ;
105092: LD_ADDR_EXP 197
105096: PUSH
105097: LD_INT 3
105099: ST_TO_ADDR
// hackDist := 12 ;
105100: LD_ADDR_EXP 198
105104: PUSH
105105: LD_INT 12
105107: ST_TO_ADDR
// hackCounter := [ ] ;
105108: LD_ADDR_EXP 199
105112: PUSH
105113: EMPTY
105114: ST_TO_ADDR
// end ;
105115: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
105116: LD_EXP 194
105120: PUSH
105121: LD_INT 34
105123: PUSH
105124: LD_EXP 74
105128: PUSH
105129: EMPTY
105130: LIST
105131: LIST
105132: PPUSH
105133: CALL_OW 69
105137: AND
105138: IFFALSE 105393
105140: GO 105142
105142: DISABLE
105143: LD_INT 0
105145: PPUSH
105146: PPUSH
// begin enable ;
105147: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
105148: LD_ADDR_VAR 0 1
105152: PUSH
105153: LD_INT 34
105155: PUSH
105156: LD_EXP 74
105160: PUSH
105161: EMPTY
105162: LIST
105163: LIST
105164: PPUSH
105165: CALL_OW 69
105169: PUSH
105170: FOR_IN
105171: IFFALSE 105391
// begin if not i in hackTanks then
105173: LD_VAR 0 1
105177: PUSH
105178: LD_EXP 195
105182: IN
105183: NOT
105184: IFFALSE 105267
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
105186: LD_ADDR_EXP 195
105190: PUSH
105191: LD_EXP 195
105195: PPUSH
105196: LD_EXP 195
105200: PUSH
105201: LD_INT 1
105203: PLUS
105204: PPUSH
105205: LD_VAR 0 1
105209: PPUSH
105210: CALL_OW 1
105214: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
105215: LD_ADDR_EXP 196
105219: PUSH
105220: LD_EXP 196
105224: PPUSH
105225: LD_EXP 196
105229: PUSH
105230: LD_INT 1
105232: PLUS
105233: PPUSH
105234: EMPTY
105235: PPUSH
105236: CALL_OW 1
105240: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
105241: LD_ADDR_EXP 199
105245: PUSH
105246: LD_EXP 199
105250: PPUSH
105251: LD_EXP 199
105255: PUSH
105256: LD_INT 1
105258: PLUS
105259: PPUSH
105260: EMPTY
105261: PPUSH
105262: CALL_OW 1
105266: ST_TO_ADDR
// end ; if not IsOk ( i ) then
105267: LD_VAR 0 1
105271: PPUSH
105272: CALL_OW 302
105276: NOT
105277: IFFALSE 105290
// begin HackUnlinkAll ( i ) ;
105279: LD_VAR 0 1
105283: PPUSH
105284: CALL 105396 0 1
// continue ;
105288: GO 105170
// end ; HackCheckCapturedStatus ( i ) ;
105290: LD_VAR 0 1
105294: PPUSH
105295: CALL 105839 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
105299: LD_ADDR_VAR 0 2
105303: PUSH
105304: LD_INT 81
105306: PUSH
105307: LD_VAR 0 1
105311: PPUSH
105312: CALL_OW 255
105316: PUSH
105317: EMPTY
105318: LIST
105319: LIST
105320: PUSH
105321: LD_INT 33
105323: PUSH
105324: LD_INT 3
105326: PUSH
105327: EMPTY
105328: LIST
105329: LIST
105330: PUSH
105331: LD_INT 91
105333: PUSH
105334: LD_VAR 0 1
105338: PUSH
105339: LD_EXP 198
105343: PUSH
105344: EMPTY
105345: LIST
105346: LIST
105347: LIST
105348: PUSH
105349: LD_INT 50
105351: PUSH
105352: EMPTY
105353: LIST
105354: PUSH
105355: EMPTY
105356: LIST
105357: LIST
105358: LIST
105359: LIST
105360: PPUSH
105361: CALL_OW 69
105365: ST_TO_ADDR
// if not tmp then
105366: LD_VAR 0 2
105370: NOT
105371: IFFALSE 105375
// continue ;
105373: GO 105170
// HackLink ( i , tmp ) ;
105375: LD_VAR 0 1
105379: PPUSH
105380: LD_VAR 0 2
105384: PPUSH
105385: CALL 105532 0 2
// end ;
105389: GO 105170
105391: POP
105392: POP
// end ;
105393: PPOPN 2
105395: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
105396: LD_INT 0
105398: PPUSH
105399: PPUSH
105400: PPUSH
// if not hack in hackTanks then
105401: LD_VAR 0 1
105405: PUSH
105406: LD_EXP 195
105410: IN
105411: NOT
105412: IFFALSE 105416
// exit ;
105414: GO 105527
// index := GetElementIndex ( hackTanks , hack ) ;
105416: LD_ADDR_VAR 0 4
105420: PUSH
105421: LD_EXP 195
105425: PPUSH
105426: LD_VAR 0 1
105430: PPUSH
105431: CALL 56259 0 2
105435: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
105436: LD_EXP 196
105440: PUSH
105441: LD_VAR 0 4
105445: ARRAY
105446: IFFALSE 105527
// begin for i in hackTanksCaptured [ index ] do
105448: LD_ADDR_VAR 0 3
105452: PUSH
105453: LD_EXP 196
105457: PUSH
105458: LD_VAR 0 4
105462: ARRAY
105463: PUSH
105464: FOR_IN
105465: IFFALSE 105491
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
105467: LD_VAR 0 3
105471: PUSH
105472: LD_INT 1
105474: ARRAY
105475: PPUSH
105476: LD_VAR 0 3
105480: PUSH
105481: LD_INT 2
105483: ARRAY
105484: PPUSH
105485: CALL_OW 235
105489: GO 105464
105491: POP
105492: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
105493: LD_ADDR_EXP 196
105497: PUSH
105498: LD_EXP 196
105502: PPUSH
105503: LD_VAR 0 4
105507: PPUSH
105508: EMPTY
105509: PPUSH
105510: CALL_OW 1
105514: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
105515: LD_VAR 0 1
105519: PPUSH
105520: LD_INT 0
105522: PPUSH
105523: CALL_OW 505
// end ; end ;
105527: LD_VAR 0 2
105531: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
105532: LD_INT 0
105534: PPUSH
105535: PPUSH
105536: PPUSH
// if not hack in hackTanks or not vehicles then
105537: LD_VAR 0 1
105541: PUSH
105542: LD_EXP 195
105546: IN
105547: NOT
105548: PUSH
105549: LD_VAR 0 2
105553: NOT
105554: OR
105555: IFFALSE 105559
// exit ;
105557: GO 105834
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
105559: LD_ADDR_VAR 0 2
105563: PUSH
105564: LD_VAR 0 1
105568: PPUSH
105569: LD_VAR 0 2
105573: PPUSH
105574: LD_INT 1
105576: PPUSH
105577: LD_INT 1
105579: PPUSH
105580: CALL 56909 0 4
105584: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
105585: LD_ADDR_VAR 0 5
105589: PUSH
105590: LD_EXP 195
105594: PPUSH
105595: LD_VAR 0 1
105599: PPUSH
105600: CALL 56259 0 2
105604: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
105605: LD_EXP 196
105609: PUSH
105610: LD_VAR 0 5
105614: ARRAY
105615: PUSH
105616: LD_EXP 197
105620: LESS
105621: IFFALSE 105810
// begin for i := 1 to vehicles do
105623: LD_ADDR_VAR 0 4
105627: PUSH
105628: DOUBLE
105629: LD_INT 1
105631: DEC
105632: ST_TO_ADDR
105633: LD_VAR 0 2
105637: PUSH
105638: FOR_TO
105639: IFFALSE 105808
// begin if hackTanksCaptured [ index ] = hackLimit then
105641: LD_EXP 196
105645: PUSH
105646: LD_VAR 0 5
105650: ARRAY
105651: PUSH
105652: LD_EXP 197
105656: EQUAL
105657: IFFALSE 105661
// break ;
105659: GO 105808
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
105661: LD_ADDR_EXP 199
105665: PUSH
105666: LD_EXP 199
105670: PPUSH
105671: LD_VAR 0 5
105675: PPUSH
105676: LD_EXP 199
105680: PUSH
105681: LD_VAR 0 5
105685: ARRAY
105686: PUSH
105687: LD_INT 1
105689: PLUS
105690: PPUSH
105691: CALL_OW 1
105695: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
105696: LD_ADDR_EXP 196
105700: PUSH
105701: LD_EXP 196
105705: PPUSH
105706: LD_VAR 0 5
105710: PUSH
105711: LD_EXP 196
105715: PUSH
105716: LD_VAR 0 5
105720: ARRAY
105721: PUSH
105722: LD_INT 1
105724: PLUS
105725: PUSH
105726: EMPTY
105727: LIST
105728: LIST
105729: PPUSH
105730: LD_VAR 0 2
105734: PUSH
105735: LD_VAR 0 4
105739: ARRAY
105740: PUSH
105741: LD_VAR 0 2
105745: PUSH
105746: LD_VAR 0 4
105750: ARRAY
105751: PPUSH
105752: CALL_OW 255
105756: PUSH
105757: EMPTY
105758: LIST
105759: LIST
105760: PPUSH
105761: CALL 56474 0 3
105765: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
105766: LD_VAR 0 2
105770: PUSH
105771: LD_VAR 0 4
105775: ARRAY
105776: PPUSH
105777: LD_VAR 0 1
105781: PPUSH
105782: CALL_OW 255
105786: PPUSH
105787: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
105791: LD_VAR 0 2
105795: PUSH
105796: LD_VAR 0 4
105800: ARRAY
105801: PPUSH
105802: CALL_OW 141
// end ;
105806: GO 105638
105808: POP
105809: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105810: LD_VAR 0 1
105814: PPUSH
105815: LD_EXP 196
105819: PUSH
105820: LD_VAR 0 5
105824: ARRAY
105825: PUSH
105826: LD_INT 0
105828: PLUS
105829: PPUSH
105830: CALL_OW 505
// end ;
105834: LD_VAR 0 3
105838: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
105839: LD_INT 0
105841: PPUSH
105842: PPUSH
105843: PPUSH
105844: PPUSH
// if not hack in hackTanks then
105845: LD_VAR 0 1
105849: PUSH
105850: LD_EXP 195
105854: IN
105855: NOT
105856: IFFALSE 105860
// exit ;
105858: GO 106100
// index := GetElementIndex ( hackTanks , hack ) ;
105860: LD_ADDR_VAR 0 4
105864: PUSH
105865: LD_EXP 195
105869: PPUSH
105870: LD_VAR 0 1
105874: PPUSH
105875: CALL 56259 0 2
105879: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
105880: LD_ADDR_VAR 0 3
105884: PUSH
105885: DOUBLE
105886: LD_EXP 196
105890: PUSH
105891: LD_VAR 0 4
105895: ARRAY
105896: INC
105897: ST_TO_ADDR
105898: LD_INT 1
105900: PUSH
105901: FOR_DOWNTO
105902: IFFALSE 106074
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
105904: LD_ADDR_VAR 0 5
105908: PUSH
105909: LD_EXP 196
105913: PUSH
105914: LD_VAR 0 4
105918: ARRAY
105919: PUSH
105920: LD_VAR 0 3
105924: ARRAY
105925: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
105926: LD_VAR 0 5
105930: PUSH
105931: LD_INT 1
105933: ARRAY
105934: PPUSH
105935: CALL_OW 302
105939: NOT
105940: PUSH
105941: LD_VAR 0 5
105945: PUSH
105946: LD_INT 1
105948: ARRAY
105949: PPUSH
105950: CALL_OW 255
105954: PUSH
105955: LD_VAR 0 1
105959: PPUSH
105960: CALL_OW 255
105964: NONEQUAL
105965: OR
105966: IFFALSE 106072
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
105968: LD_VAR 0 5
105972: PUSH
105973: LD_INT 1
105975: ARRAY
105976: PPUSH
105977: CALL_OW 305
105981: PUSH
105982: LD_VAR 0 5
105986: PUSH
105987: LD_INT 1
105989: ARRAY
105990: PPUSH
105991: CALL_OW 255
105995: PUSH
105996: LD_VAR 0 1
106000: PPUSH
106001: CALL_OW 255
106005: EQUAL
106006: AND
106007: IFFALSE 106031
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
106009: LD_VAR 0 5
106013: PUSH
106014: LD_INT 1
106016: ARRAY
106017: PPUSH
106018: LD_VAR 0 5
106022: PUSH
106023: LD_INT 2
106025: ARRAY
106026: PPUSH
106027: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
106031: LD_ADDR_EXP 196
106035: PUSH
106036: LD_EXP 196
106040: PPUSH
106041: LD_VAR 0 4
106045: PPUSH
106046: LD_EXP 196
106050: PUSH
106051: LD_VAR 0 4
106055: ARRAY
106056: PPUSH
106057: LD_VAR 0 3
106061: PPUSH
106062: CALL_OW 3
106066: PPUSH
106067: CALL_OW 1
106071: ST_TO_ADDR
// end ; end ;
106072: GO 105901
106074: POP
106075: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
106076: LD_VAR 0 1
106080: PPUSH
106081: LD_EXP 196
106085: PUSH
106086: LD_VAR 0 4
106090: ARRAY
106091: PUSH
106092: LD_INT 0
106094: PLUS
106095: PPUSH
106096: CALL_OW 505
// end ;
106100: LD_VAR 0 2
106104: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
106105: LD_INT 0
106107: PPUSH
106108: PPUSH
106109: PPUSH
106110: PPUSH
// if not hack in hackTanks then
106111: LD_VAR 0 1
106115: PUSH
106116: LD_EXP 195
106120: IN
106121: NOT
106122: IFFALSE 106126
// exit ;
106124: GO 106211
// index := GetElementIndex ( hackTanks , hack ) ;
106126: LD_ADDR_VAR 0 5
106130: PUSH
106131: LD_EXP 195
106135: PPUSH
106136: LD_VAR 0 1
106140: PPUSH
106141: CALL 56259 0 2
106145: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
106146: LD_ADDR_VAR 0 4
106150: PUSH
106151: DOUBLE
106152: LD_INT 1
106154: DEC
106155: ST_TO_ADDR
106156: LD_EXP 196
106160: PUSH
106161: LD_VAR 0 5
106165: ARRAY
106166: PUSH
106167: FOR_TO
106168: IFFALSE 106209
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
106170: LD_EXP 196
106174: PUSH
106175: LD_VAR 0 5
106179: ARRAY
106180: PUSH
106181: LD_VAR 0 4
106185: ARRAY
106186: PUSH
106187: LD_INT 1
106189: ARRAY
106190: PUSH
106191: LD_VAR 0 2
106195: EQUAL
106196: IFFALSE 106207
// KillUnit ( vehicle ) ;
106198: LD_VAR 0 2
106202: PPUSH
106203: CALL_OW 66
106207: GO 106167
106209: POP
106210: POP
// end ;
106211: LD_VAR 0 3
106215: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
106216: LD_EXP 200
106220: NOT
106221: IFFALSE 106256
106223: GO 106225
106225: DISABLE
// begin initMiner := true ;
106226: LD_ADDR_EXP 200
106230: PUSH
106231: LD_INT 1
106233: ST_TO_ADDR
// minersList := [ ] ;
106234: LD_ADDR_EXP 201
106238: PUSH
106239: EMPTY
106240: ST_TO_ADDR
// minerMinesList := [ ] ;
106241: LD_ADDR_EXP 202
106245: PUSH
106246: EMPTY
106247: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
106248: LD_ADDR_EXP 203
106252: PUSH
106253: LD_INT 5
106255: ST_TO_ADDR
// end ;
106256: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
106257: LD_EXP 200
106261: PUSH
106262: LD_INT 34
106264: PUSH
106265: LD_EXP 79
106269: PUSH
106270: EMPTY
106271: LIST
106272: LIST
106273: PPUSH
106274: CALL_OW 69
106278: AND
106279: IFFALSE 106742
106281: GO 106283
106283: DISABLE
106284: LD_INT 0
106286: PPUSH
106287: PPUSH
106288: PPUSH
106289: PPUSH
// begin enable ;
106290: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
106291: LD_ADDR_VAR 0 1
106295: PUSH
106296: LD_INT 34
106298: PUSH
106299: LD_EXP 79
106303: PUSH
106304: EMPTY
106305: LIST
106306: LIST
106307: PPUSH
106308: CALL_OW 69
106312: PUSH
106313: FOR_IN
106314: IFFALSE 106386
// begin if not i in minersList then
106316: LD_VAR 0 1
106320: PUSH
106321: LD_EXP 201
106325: IN
106326: NOT
106327: IFFALSE 106384
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
106329: LD_ADDR_EXP 201
106333: PUSH
106334: LD_EXP 201
106338: PPUSH
106339: LD_EXP 201
106343: PUSH
106344: LD_INT 1
106346: PLUS
106347: PPUSH
106348: LD_VAR 0 1
106352: PPUSH
106353: CALL_OW 1
106357: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
106358: LD_ADDR_EXP 202
106362: PUSH
106363: LD_EXP 202
106367: PPUSH
106368: LD_EXP 202
106372: PUSH
106373: LD_INT 1
106375: PLUS
106376: PPUSH
106377: EMPTY
106378: PPUSH
106379: CALL_OW 1
106383: ST_TO_ADDR
// end end ;
106384: GO 106313
106386: POP
106387: POP
// for i := minerMinesList downto 1 do
106388: LD_ADDR_VAR 0 1
106392: PUSH
106393: DOUBLE
106394: LD_EXP 202
106398: INC
106399: ST_TO_ADDR
106400: LD_INT 1
106402: PUSH
106403: FOR_DOWNTO
106404: IFFALSE 106740
// begin if IsLive ( minersList [ i ] ) then
106406: LD_EXP 201
106410: PUSH
106411: LD_VAR 0 1
106415: ARRAY
106416: PPUSH
106417: CALL_OW 300
106421: IFFALSE 106449
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
106423: LD_EXP 201
106427: PUSH
106428: LD_VAR 0 1
106432: ARRAY
106433: PPUSH
106434: LD_EXP 202
106438: PUSH
106439: LD_VAR 0 1
106443: ARRAY
106444: PPUSH
106445: CALL_OW 505
// if not minerMinesList [ i ] then
106449: LD_EXP 202
106453: PUSH
106454: LD_VAR 0 1
106458: ARRAY
106459: NOT
106460: IFFALSE 106464
// continue ;
106462: GO 106403
// for j := minerMinesList [ i ] downto 1 do
106464: LD_ADDR_VAR 0 2
106468: PUSH
106469: DOUBLE
106470: LD_EXP 202
106474: PUSH
106475: LD_VAR 0 1
106479: ARRAY
106480: INC
106481: ST_TO_ADDR
106482: LD_INT 1
106484: PUSH
106485: FOR_DOWNTO
106486: IFFALSE 106736
// begin side := GetSide ( minersList [ i ] ) ;
106488: LD_ADDR_VAR 0 3
106492: PUSH
106493: LD_EXP 201
106497: PUSH
106498: LD_VAR 0 1
106502: ARRAY
106503: PPUSH
106504: CALL_OW 255
106508: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
106509: LD_ADDR_VAR 0 4
106513: PUSH
106514: LD_EXP 202
106518: PUSH
106519: LD_VAR 0 1
106523: ARRAY
106524: PUSH
106525: LD_VAR 0 2
106529: ARRAY
106530: PUSH
106531: LD_INT 1
106533: ARRAY
106534: PPUSH
106535: LD_EXP 202
106539: PUSH
106540: LD_VAR 0 1
106544: ARRAY
106545: PUSH
106546: LD_VAR 0 2
106550: ARRAY
106551: PUSH
106552: LD_INT 2
106554: ARRAY
106555: PPUSH
106556: CALL_OW 428
106560: ST_TO_ADDR
// if not tmp then
106561: LD_VAR 0 4
106565: NOT
106566: IFFALSE 106570
// continue ;
106568: GO 106485
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
106570: LD_VAR 0 4
106574: PUSH
106575: LD_INT 81
106577: PUSH
106578: LD_VAR 0 3
106582: PUSH
106583: EMPTY
106584: LIST
106585: LIST
106586: PPUSH
106587: CALL_OW 69
106591: IN
106592: PUSH
106593: LD_EXP 202
106597: PUSH
106598: LD_VAR 0 1
106602: ARRAY
106603: PUSH
106604: LD_VAR 0 2
106608: ARRAY
106609: PUSH
106610: LD_INT 1
106612: ARRAY
106613: PPUSH
106614: LD_EXP 202
106618: PUSH
106619: LD_VAR 0 1
106623: ARRAY
106624: PUSH
106625: LD_VAR 0 2
106629: ARRAY
106630: PUSH
106631: LD_INT 2
106633: ARRAY
106634: PPUSH
106635: CALL_OW 458
106639: AND
106640: IFFALSE 106734
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
106642: LD_EXP 202
106646: PUSH
106647: LD_VAR 0 1
106651: ARRAY
106652: PUSH
106653: LD_VAR 0 2
106657: ARRAY
106658: PUSH
106659: LD_INT 1
106661: ARRAY
106662: PPUSH
106663: LD_EXP 202
106667: PUSH
106668: LD_VAR 0 1
106672: ARRAY
106673: PUSH
106674: LD_VAR 0 2
106678: ARRAY
106679: PUSH
106680: LD_INT 2
106682: ARRAY
106683: PPUSH
106684: LD_VAR 0 3
106688: PPUSH
106689: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
106693: LD_ADDR_EXP 202
106697: PUSH
106698: LD_EXP 202
106702: PPUSH
106703: LD_VAR 0 1
106707: PPUSH
106708: LD_EXP 202
106712: PUSH
106713: LD_VAR 0 1
106717: ARRAY
106718: PPUSH
106719: LD_VAR 0 2
106723: PPUSH
106724: CALL_OW 3
106728: PPUSH
106729: CALL_OW 1
106733: ST_TO_ADDR
// end ; end ;
106734: GO 106485
106736: POP
106737: POP
// end ;
106738: GO 106403
106740: POP
106741: POP
// end ;
106742: PPOPN 4
106744: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
106745: LD_INT 0
106747: PPUSH
106748: PPUSH
// result := false ;
106749: LD_ADDR_VAR 0 4
106753: PUSH
106754: LD_INT 0
106756: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
106757: LD_VAR 0 1
106761: PPUSH
106762: CALL_OW 264
106766: PUSH
106767: LD_EXP 79
106771: EQUAL
106772: NOT
106773: IFFALSE 106777
// exit ;
106775: GO 107017
// index := GetElementIndex ( minersList , unit ) ;
106777: LD_ADDR_VAR 0 5
106781: PUSH
106782: LD_EXP 201
106786: PPUSH
106787: LD_VAR 0 1
106791: PPUSH
106792: CALL 56259 0 2
106796: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
106797: LD_EXP 202
106801: PUSH
106802: LD_VAR 0 5
106806: ARRAY
106807: PUSH
106808: LD_EXP 203
106812: GREATEREQUAL
106813: IFFALSE 106817
// exit ;
106815: GO 107017
// ComMoveXY ( unit , x , y ) ;
106817: LD_VAR 0 1
106821: PPUSH
106822: LD_VAR 0 2
106826: PPUSH
106827: LD_VAR 0 3
106831: PPUSH
106832: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106836: LD_INT 35
106838: PPUSH
106839: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
106843: LD_VAR 0 1
106847: PPUSH
106848: LD_VAR 0 2
106852: PPUSH
106853: LD_VAR 0 3
106857: PPUSH
106858: CALL 87031 0 3
106862: NOT
106863: PUSH
106864: LD_VAR 0 1
106868: PPUSH
106869: CALL_OW 314
106873: AND
106874: IFFALSE 106878
// exit ;
106876: GO 107017
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
106878: LD_VAR 0 2
106882: PPUSH
106883: LD_VAR 0 3
106887: PPUSH
106888: CALL_OW 428
106892: PUSH
106893: LD_VAR 0 1
106897: EQUAL
106898: PUSH
106899: LD_VAR 0 1
106903: PPUSH
106904: CALL_OW 314
106908: NOT
106909: AND
106910: IFFALSE 106836
// PlaySoundXY ( x , y , PlantMine ) ;
106912: LD_VAR 0 2
106916: PPUSH
106917: LD_VAR 0 3
106921: PPUSH
106922: LD_STRING PlantMine
106924: PPUSH
106925: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
106929: LD_VAR 0 2
106933: PPUSH
106934: LD_VAR 0 3
106938: PPUSH
106939: LD_VAR 0 1
106943: PPUSH
106944: CALL_OW 255
106948: PPUSH
106949: LD_INT 0
106951: PPUSH
106952: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
106956: LD_ADDR_EXP 202
106960: PUSH
106961: LD_EXP 202
106965: PPUSH
106966: LD_VAR 0 5
106970: PUSH
106971: LD_EXP 202
106975: PUSH
106976: LD_VAR 0 5
106980: ARRAY
106981: PUSH
106982: LD_INT 1
106984: PLUS
106985: PUSH
106986: EMPTY
106987: LIST
106988: LIST
106989: PPUSH
106990: LD_VAR 0 2
106994: PUSH
106995: LD_VAR 0 3
106999: PUSH
107000: EMPTY
107001: LIST
107002: LIST
107003: PPUSH
107004: CALL 56474 0 3
107008: ST_TO_ADDR
// result := true ;
107009: LD_ADDR_VAR 0 4
107013: PUSH
107014: LD_INT 1
107016: ST_TO_ADDR
// end ;
107017: LD_VAR 0 4
107021: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
107022: LD_INT 0
107024: PPUSH
107025: PPUSH
107026: PPUSH
// if not unit in minersList then
107027: LD_VAR 0 1
107031: PUSH
107032: LD_EXP 201
107036: IN
107037: NOT
107038: IFFALSE 107042
// exit ;
107040: GO 107434
// index := GetElementIndex ( minersList , unit ) ;
107042: LD_ADDR_VAR 0 6
107046: PUSH
107047: LD_EXP 201
107051: PPUSH
107052: LD_VAR 0 1
107056: PPUSH
107057: CALL 56259 0 2
107061: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
107062: LD_ADDR_VAR 0 5
107066: PUSH
107067: DOUBLE
107068: LD_EXP 202
107072: PUSH
107073: LD_VAR 0 6
107077: ARRAY
107078: INC
107079: ST_TO_ADDR
107080: LD_INT 1
107082: PUSH
107083: FOR_DOWNTO
107084: IFFALSE 107245
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
107086: LD_EXP 202
107090: PUSH
107091: LD_VAR 0 6
107095: ARRAY
107096: PUSH
107097: LD_VAR 0 5
107101: ARRAY
107102: PUSH
107103: LD_INT 1
107105: ARRAY
107106: PUSH
107107: LD_VAR 0 2
107111: EQUAL
107112: PUSH
107113: LD_EXP 202
107117: PUSH
107118: LD_VAR 0 6
107122: ARRAY
107123: PUSH
107124: LD_VAR 0 5
107128: ARRAY
107129: PUSH
107130: LD_INT 2
107132: ARRAY
107133: PUSH
107134: LD_VAR 0 3
107138: EQUAL
107139: AND
107140: IFFALSE 107243
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
107142: LD_EXP 202
107146: PUSH
107147: LD_VAR 0 6
107151: ARRAY
107152: PUSH
107153: LD_VAR 0 5
107157: ARRAY
107158: PUSH
107159: LD_INT 1
107161: ARRAY
107162: PPUSH
107163: LD_EXP 202
107167: PUSH
107168: LD_VAR 0 6
107172: ARRAY
107173: PUSH
107174: LD_VAR 0 5
107178: ARRAY
107179: PUSH
107180: LD_INT 2
107182: ARRAY
107183: PPUSH
107184: LD_VAR 0 1
107188: PPUSH
107189: CALL_OW 255
107193: PPUSH
107194: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107198: LD_ADDR_EXP 202
107202: PUSH
107203: LD_EXP 202
107207: PPUSH
107208: LD_VAR 0 6
107212: PPUSH
107213: LD_EXP 202
107217: PUSH
107218: LD_VAR 0 6
107222: ARRAY
107223: PPUSH
107224: LD_VAR 0 5
107228: PPUSH
107229: CALL_OW 3
107233: PPUSH
107234: CALL_OW 1
107238: ST_TO_ADDR
// exit ;
107239: POP
107240: POP
107241: GO 107434
// end ; end ;
107243: GO 107083
107245: POP
107246: POP
// for i := minerMinesList [ index ] downto 1 do
107247: LD_ADDR_VAR 0 5
107251: PUSH
107252: DOUBLE
107253: LD_EXP 202
107257: PUSH
107258: LD_VAR 0 6
107262: ARRAY
107263: INC
107264: ST_TO_ADDR
107265: LD_INT 1
107267: PUSH
107268: FOR_DOWNTO
107269: IFFALSE 107432
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
107271: LD_EXP 202
107275: PUSH
107276: LD_VAR 0 6
107280: ARRAY
107281: PUSH
107282: LD_VAR 0 5
107286: ARRAY
107287: PUSH
107288: LD_INT 1
107290: ARRAY
107291: PPUSH
107292: LD_EXP 202
107296: PUSH
107297: LD_VAR 0 6
107301: ARRAY
107302: PUSH
107303: LD_VAR 0 5
107307: ARRAY
107308: PUSH
107309: LD_INT 2
107311: ARRAY
107312: PPUSH
107313: LD_VAR 0 2
107317: PPUSH
107318: LD_VAR 0 3
107322: PPUSH
107323: CALL_OW 298
107327: PUSH
107328: LD_INT 6
107330: LESS
107331: IFFALSE 107430
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
107333: LD_EXP 202
107337: PUSH
107338: LD_VAR 0 6
107342: ARRAY
107343: PUSH
107344: LD_VAR 0 5
107348: ARRAY
107349: PUSH
107350: LD_INT 1
107352: ARRAY
107353: PPUSH
107354: LD_EXP 202
107358: PUSH
107359: LD_VAR 0 6
107363: ARRAY
107364: PUSH
107365: LD_VAR 0 5
107369: ARRAY
107370: PUSH
107371: LD_INT 2
107373: ARRAY
107374: PPUSH
107375: LD_VAR 0 1
107379: PPUSH
107380: CALL_OW 255
107384: PPUSH
107385: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107389: LD_ADDR_EXP 202
107393: PUSH
107394: LD_EXP 202
107398: PPUSH
107399: LD_VAR 0 6
107403: PPUSH
107404: LD_EXP 202
107408: PUSH
107409: LD_VAR 0 6
107413: ARRAY
107414: PPUSH
107415: LD_VAR 0 5
107419: PPUSH
107420: CALL_OW 3
107424: PPUSH
107425: CALL_OW 1
107429: ST_TO_ADDR
// end ; end ;
107430: GO 107268
107432: POP
107433: POP
// end ;
107434: LD_VAR 0 4
107438: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
107439: LD_INT 0
107441: PPUSH
107442: PPUSH
107443: PPUSH
107444: PPUSH
107445: PPUSH
107446: PPUSH
107447: PPUSH
107448: PPUSH
107449: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
107450: LD_VAR 0 1
107454: PPUSH
107455: CALL_OW 264
107459: PUSH
107460: LD_EXP 79
107464: EQUAL
107465: NOT
107466: PUSH
107467: LD_VAR 0 1
107471: PUSH
107472: LD_EXP 201
107476: IN
107477: NOT
107478: OR
107479: IFFALSE 107483
// exit ;
107481: GO 107805
// index := GetElementIndex ( minersList , unit ) ;
107483: LD_ADDR_VAR 0 6
107487: PUSH
107488: LD_EXP 201
107492: PPUSH
107493: LD_VAR 0 1
107497: PPUSH
107498: CALL 56259 0 2
107502: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
107503: LD_ADDR_VAR 0 8
107507: PUSH
107508: LD_EXP 203
107512: PUSH
107513: LD_EXP 202
107517: PUSH
107518: LD_VAR 0 6
107522: ARRAY
107523: MINUS
107524: ST_TO_ADDR
// if not minesFreeAmount then
107525: LD_VAR 0 8
107529: NOT
107530: IFFALSE 107534
// exit ;
107532: GO 107805
// tmp := [ ] ;
107534: LD_ADDR_VAR 0 7
107538: PUSH
107539: EMPTY
107540: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
107541: LD_ADDR_VAR 0 5
107545: PUSH
107546: DOUBLE
107547: LD_INT 1
107549: DEC
107550: ST_TO_ADDR
107551: LD_VAR 0 8
107555: PUSH
107556: FOR_TO
107557: IFFALSE 107752
// begin _d := rand ( 0 , 5 ) ;
107559: LD_ADDR_VAR 0 11
107563: PUSH
107564: LD_INT 0
107566: PPUSH
107567: LD_INT 5
107569: PPUSH
107570: CALL_OW 12
107574: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
107575: LD_ADDR_VAR 0 12
107579: PUSH
107580: LD_INT 2
107582: PPUSH
107583: LD_INT 6
107585: PPUSH
107586: CALL_OW 12
107590: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
107591: LD_ADDR_VAR 0 9
107595: PUSH
107596: LD_VAR 0 2
107600: PPUSH
107601: LD_VAR 0 11
107605: PPUSH
107606: LD_VAR 0 12
107610: PPUSH
107611: CALL_OW 272
107615: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
107616: LD_ADDR_VAR 0 10
107620: PUSH
107621: LD_VAR 0 3
107625: PPUSH
107626: LD_VAR 0 11
107630: PPUSH
107631: LD_VAR 0 12
107635: PPUSH
107636: CALL_OW 273
107640: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
107641: LD_VAR 0 9
107645: PPUSH
107646: LD_VAR 0 10
107650: PPUSH
107651: CALL_OW 488
107655: PUSH
107656: LD_VAR 0 9
107660: PUSH
107661: LD_VAR 0 10
107665: PUSH
107666: EMPTY
107667: LIST
107668: LIST
107669: PUSH
107670: LD_VAR 0 7
107674: IN
107675: NOT
107676: AND
107677: PUSH
107678: LD_VAR 0 9
107682: PPUSH
107683: LD_VAR 0 10
107687: PPUSH
107688: CALL_OW 458
107692: NOT
107693: AND
107694: IFFALSE 107736
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
107696: LD_ADDR_VAR 0 7
107700: PUSH
107701: LD_VAR 0 7
107705: PPUSH
107706: LD_VAR 0 7
107710: PUSH
107711: LD_INT 1
107713: PLUS
107714: PPUSH
107715: LD_VAR 0 9
107719: PUSH
107720: LD_VAR 0 10
107724: PUSH
107725: EMPTY
107726: LIST
107727: LIST
107728: PPUSH
107729: CALL_OW 1
107733: ST_TO_ADDR
107734: GO 107750
// i := i - 1 ;
107736: LD_ADDR_VAR 0 5
107740: PUSH
107741: LD_VAR 0 5
107745: PUSH
107746: LD_INT 1
107748: MINUS
107749: ST_TO_ADDR
// end ;
107750: GO 107556
107752: POP
107753: POP
// for i in tmp do
107754: LD_ADDR_VAR 0 5
107758: PUSH
107759: LD_VAR 0 7
107763: PUSH
107764: FOR_IN
107765: IFFALSE 107803
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
107767: LD_VAR 0 1
107771: PPUSH
107772: LD_VAR 0 5
107776: PUSH
107777: LD_INT 1
107779: ARRAY
107780: PPUSH
107781: LD_VAR 0 5
107785: PUSH
107786: LD_INT 2
107788: ARRAY
107789: PPUSH
107790: CALL 106745 0 3
107794: NOT
107795: IFFALSE 107801
// exit ;
107797: POP
107798: POP
107799: GO 107805
107801: GO 107764
107803: POP
107804: POP
// end ;
107805: LD_VAR 0 4
107809: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
107810: LD_INT 0
107812: PPUSH
107813: PPUSH
107814: PPUSH
107815: PPUSH
107816: PPUSH
107817: PPUSH
107818: PPUSH
// if not GetClass ( unit ) = class_sniper then
107819: LD_VAR 0 1
107823: PPUSH
107824: CALL_OW 257
107828: PUSH
107829: LD_INT 5
107831: EQUAL
107832: NOT
107833: IFFALSE 107837
// exit ;
107835: GO 108225
// dist := 8 ;
107837: LD_ADDR_VAR 0 5
107841: PUSH
107842: LD_INT 8
107844: ST_TO_ADDR
// viewRange := 12 ;
107845: LD_ADDR_VAR 0 7
107849: PUSH
107850: LD_INT 12
107852: ST_TO_ADDR
// side := GetSide ( unit ) ;
107853: LD_ADDR_VAR 0 6
107857: PUSH
107858: LD_VAR 0 1
107862: PPUSH
107863: CALL_OW 255
107867: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
107868: LD_INT 61
107870: PPUSH
107871: LD_VAR 0 6
107875: PPUSH
107876: CALL_OW 321
107880: PUSH
107881: LD_INT 2
107883: EQUAL
107884: IFFALSE 107894
// viewRange := 16 ;
107886: LD_ADDR_VAR 0 7
107890: PUSH
107891: LD_INT 16
107893: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
107894: LD_VAR 0 1
107898: PPUSH
107899: LD_VAR 0 2
107903: PPUSH
107904: LD_VAR 0 3
107908: PPUSH
107909: CALL_OW 297
107913: PUSH
107914: LD_VAR 0 5
107918: GREATER
107919: IFFALSE 107998
// begin ComMoveXY ( unit , x , y ) ;
107921: LD_VAR 0 1
107925: PPUSH
107926: LD_VAR 0 2
107930: PPUSH
107931: LD_VAR 0 3
107935: PPUSH
107936: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107940: LD_INT 35
107942: PPUSH
107943: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
107947: LD_VAR 0 1
107951: PPUSH
107952: LD_VAR 0 2
107956: PPUSH
107957: LD_VAR 0 3
107961: PPUSH
107962: CALL 87031 0 3
107966: NOT
107967: IFFALSE 107971
// exit ;
107969: GO 108225
// until GetDistUnitXY ( unit , x , y ) < dist ;
107971: LD_VAR 0 1
107975: PPUSH
107976: LD_VAR 0 2
107980: PPUSH
107981: LD_VAR 0 3
107985: PPUSH
107986: CALL_OW 297
107990: PUSH
107991: LD_VAR 0 5
107995: LESS
107996: IFFALSE 107940
// end ; ComTurnXY ( unit , x , y ) ;
107998: LD_VAR 0 1
108002: PPUSH
108003: LD_VAR 0 2
108007: PPUSH
108008: LD_VAR 0 3
108012: PPUSH
108013: CALL_OW 118
// wait ( 5 ) ;
108017: LD_INT 5
108019: PPUSH
108020: CALL_OW 67
// _d := GetDir ( unit ) ;
108024: LD_ADDR_VAR 0 10
108028: PUSH
108029: LD_VAR 0 1
108033: PPUSH
108034: CALL_OW 254
108038: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
108039: LD_ADDR_VAR 0 8
108043: PUSH
108044: LD_VAR 0 1
108048: PPUSH
108049: CALL_OW 250
108053: PPUSH
108054: LD_VAR 0 10
108058: PPUSH
108059: LD_VAR 0 5
108063: PPUSH
108064: CALL_OW 272
108068: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
108069: LD_ADDR_VAR 0 9
108073: PUSH
108074: LD_VAR 0 1
108078: PPUSH
108079: CALL_OW 251
108083: PPUSH
108084: LD_VAR 0 10
108088: PPUSH
108089: LD_VAR 0 5
108093: PPUSH
108094: CALL_OW 273
108098: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
108099: LD_VAR 0 8
108103: PPUSH
108104: LD_VAR 0 9
108108: PPUSH
108109: CALL_OW 488
108113: NOT
108114: IFFALSE 108118
// exit ;
108116: GO 108225
// ComAnimCustom ( unit , 1 ) ;
108118: LD_VAR 0 1
108122: PPUSH
108123: LD_INT 1
108125: PPUSH
108126: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
108130: LD_VAR 0 8
108134: PPUSH
108135: LD_VAR 0 9
108139: PPUSH
108140: LD_VAR 0 6
108144: PPUSH
108145: LD_VAR 0 7
108149: PPUSH
108150: CALL_OW 330
// repeat wait ( 1 ) ;
108154: LD_INT 1
108156: PPUSH
108157: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
108161: LD_VAR 0 1
108165: PPUSH
108166: CALL_OW 316
108170: PUSH
108171: LD_VAR 0 1
108175: PPUSH
108176: CALL_OW 314
108180: OR
108181: PUSH
108182: LD_VAR 0 1
108186: PPUSH
108187: CALL_OW 302
108191: NOT
108192: OR
108193: PUSH
108194: LD_VAR 0 1
108198: PPUSH
108199: CALL_OW 301
108203: OR
108204: IFFALSE 108154
// RemoveSeeing ( _x , _y , side ) ;
108206: LD_VAR 0 8
108210: PPUSH
108211: LD_VAR 0 9
108215: PPUSH
108216: LD_VAR 0 6
108220: PPUSH
108221: CALL_OW 331
// end ; end_of_file
108225: LD_VAR 0 4
108229: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
108230: LD_INT 0
108232: PPUSH
108233: PPUSH
108234: PPUSH
108235: PPUSH
108236: PPUSH
108237: PPUSH
108238: PPUSH
108239: PPUSH
108240: PPUSH
108241: PPUSH
108242: PPUSH
108243: PPUSH
108244: PPUSH
108245: PPUSH
108246: PPUSH
108247: PPUSH
108248: PPUSH
108249: PPUSH
108250: PPUSH
108251: PPUSH
108252: PPUSH
108253: PPUSH
108254: PPUSH
108255: PPUSH
108256: PPUSH
108257: PPUSH
108258: PPUSH
108259: PPUSH
108260: PPUSH
108261: PPUSH
108262: PPUSH
108263: PPUSH
108264: PPUSH
108265: PPUSH
// if not list then
108266: LD_VAR 0 1
108270: NOT
108271: IFFALSE 108275
// exit ;
108273: GO 112934
// base := list [ 1 ] ;
108275: LD_ADDR_VAR 0 3
108279: PUSH
108280: LD_VAR 0 1
108284: PUSH
108285: LD_INT 1
108287: ARRAY
108288: ST_TO_ADDR
// group := list [ 2 ] ;
108289: LD_ADDR_VAR 0 4
108293: PUSH
108294: LD_VAR 0 1
108298: PUSH
108299: LD_INT 2
108301: ARRAY
108302: ST_TO_ADDR
// path := list [ 3 ] ;
108303: LD_ADDR_VAR 0 5
108307: PUSH
108308: LD_VAR 0 1
108312: PUSH
108313: LD_INT 3
108315: ARRAY
108316: ST_TO_ADDR
// flags := list [ 4 ] ;
108317: LD_ADDR_VAR 0 6
108321: PUSH
108322: LD_VAR 0 1
108326: PUSH
108327: LD_INT 4
108329: ARRAY
108330: ST_TO_ADDR
// mined := [ ] ;
108331: LD_ADDR_VAR 0 27
108335: PUSH
108336: EMPTY
108337: ST_TO_ADDR
// bombed := [ ] ;
108338: LD_ADDR_VAR 0 28
108342: PUSH
108343: EMPTY
108344: ST_TO_ADDR
// healers := [ ] ;
108345: LD_ADDR_VAR 0 31
108349: PUSH
108350: EMPTY
108351: ST_TO_ADDR
// to_heal := [ ] ;
108352: LD_ADDR_VAR 0 30
108356: PUSH
108357: EMPTY
108358: ST_TO_ADDR
// repairs := [ ] ;
108359: LD_ADDR_VAR 0 33
108363: PUSH
108364: EMPTY
108365: ST_TO_ADDR
// to_repair := [ ] ;
108366: LD_ADDR_VAR 0 32
108370: PUSH
108371: EMPTY
108372: ST_TO_ADDR
// if not group or not path then
108373: LD_VAR 0 4
108377: NOT
108378: PUSH
108379: LD_VAR 0 5
108383: NOT
108384: OR
108385: IFFALSE 108389
// exit ;
108387: GO 112934
// side := GetSide ( group [ 1 ] ) ;
108389: LD_ADDR_VAR 0 35
108393: PUSH
108394: LD_VAR 0 4
108398: PUSH
108399: LD_INT 1
108401: ARRAY
108402: PPUSH
108403: CALL_OW 255
108407: ST_TO_ADDR
// if flags then
108408: LD_VAR 0 6
108412: IFFALSE 108556
// begin f_ignore_area := flags [ 1 ] ;
108414: LD_ADDR_VAR 0 17
108418: PUSH
108419: LD_VAR 0 6
108423: PUSH
108424: LD_INT 1
108426: ARRAY
108427: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
108428: LD_ADDR_VAR 0 18
108432: PUSH
108433: LD_VAR 0 6
108437: PUSH
108438: LD_INT 2
108440: ARRAY
108441: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
108442: LD_ADDR_VAR 0 19
108446: PUSH
108447: LD_VAR 0 6
108451: PUSH
108452: LD_INT 3
108454: ARRAY
108455: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
108456: LD_ADDR_VAR 0 20
108460: PUSH
108461: LD_VAR 0 6
108465: PUSH
108466: LD_INT 4
108468: ARRAY
108469: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
108470: LD_ADDR_VAR 0 21
108474: PUSH
108475: LD_VAR 0 6
108479: PUSH
108480: LD_INT 5
108482: ARRAY
108483: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
108484: LD_ADDR_VAR 0 22
108488: PUSH
108489: LD_VAR 0 6
108493: PUSH
108494: LD_INT 6
108496: ARRAY
108497: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
108498: LD_ADDR_VAR 0 23
108502: PUSH
108503: LD_VAR 0 6
108507: PUSH
108508: LD_INT 7
108510: ARRAY
108511: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
108512: LD_ADDR_VAR 0 24
108516: PUSH
108517: LD_VAR 0 6
108521: PUSH
108522: LD_INT 8
108524: ARRAY
108525: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
108526: LD_ADDR_VAR 0 25
108530: PUSH
108531: LD_VAR 0 6
108535: PUSH
108536: LD_INT 9
108538: ARRAY
108539: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
108540: LD_ADDR_VAR 0 26
108544: PUSH
108545: LD_VAR 0 6
108549: PUSH
108550: LD_INT 10
108552: ARRAY
108553: ST_TO_ADDR
// end else
108554: GO 108636
// begin f_ignore_area := false ;
108556: LD_ADDR_VAR 0 17
108560: PUSH
108561: LD_INT 0
108563: ST_TO_ADDR
// f_capture := false ;
108564: LD_ADDR_VAR 0 18
108568: PUSH
108569: LD_INT 0
108571: ST_TO_ADDR
// f_ignore_civ := false ;
108572: LD_ADDR_VAR 0 19
108576: PUSH
108577: LD_INT 0
108579: ST_TO_ADDR
// f_murder := false ;
108580: LD_ADDR_VAR 0 20
108584: PUSH
108585: LD_INT 0
108587: ST_TO_ADDR
// f_mines := false ;
108588: LD_ADDR_VAR 0 21
108592: PUSH
108593: LD_INT 0
108595: ST_TO_ADDR
// f_repair := false ;
108596: LD_ADDR_VAR 0 22
108600: PUSH
108601: LD_INT 0
108603: ST_TO_ADDR
// f_heal := false ;
108604: LD_ADDR_VAR 0 23
108608: PUSH
108609: LD_INT 0
108611: ST_TO_ADDR
// f_spacetime := false ;
108612: LD_ADDR_VAR 0 24
108616: PUSH
108617: LD_INT 0
108619: ST_TO_ADDR
// f_attack_depot := false ;
108620: LD_ADDR_VAR 0 25
108624: PUSH
108625: LD_INT 0
108627: ST_TO_ADDR
// f_crawl := false ;
108628: LD_ADDR_VAR 0 26
108632: PUSH
108633: LD_INT 0
108635: ST_TO_ADDR
// end ; if f_heal then
108636: LD_VAR 0 23
108640: IFFALSE 108667
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
108642: LD_ADDR_VAR 0 31
108646: PUSH
108647: LD_VAR 0 4
108651: PPUSH
108652: LD_INT 25
108654: PUSH
108655: LD_INT 4
108657: PUSH
108658: EMPTY
108659: LIST
108660: LIST
108661: PPUSH
108662: CALL_OW 72
108666: ST_TO_ADDR
// if f_repair then
108667: LD_VAR 0 22
108671: IFFALSE 108698
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
108673: LD_ADDR_VAR 0 33
108677: PUSH
108678: LD_VAR 0 4
108682: PPUSH
108683: LD_INT 25
108685: PUSH
108686: LD_INT 3
108688: PUSH
108689: EMPTY
108690: LIST
108691: LIST
108692: PPUSH
108693: CALL_OW 72
108697: ST_TO_ADDR
// units_path := [ ] ;
108698: LD_ADDR_VAR 0 16
108702: PUSH
108703: EMPTY
108704: ST_TO_ADDR
// for i = 1 to group do
108705: LD_ADDR_VAR 0 7
108709: PUSH
108710: DOUBLE
108711: LD_INT 1
108713: DEC
108714: ST_TO_ADDR
108715: LD_VAR 0 4
108719: PUSH
108720: FOR_TO
108721: IFFALSE 108750
// units_path := Replace ( units_path , i , path ) ;
108723: LD_ADDR_VAR 0 16
108727: PUSH
108728: LD_VAR 0 16
108732: PPUSH
108733: LD_VAR 0 7
108737: PPUSH
108738: LD_VAR 0 5
108742: PPUSH
108743: CALL_OW 1
108747: ST_TO_ADDR
108748: GO 108720
108750: POP
108751: POP
// repeat for i = group downto 1 do
108752: LD_ADDR_VAR 0 7
108756: PUSH
108757: DOUBLE
108758: LD_VAR 0 4
108762: INC
108763: ST_TO_ADDR
108764: LD_INT 1
108766: PUSH
108767: FOR_DOWNTO
108768: IFFALSE 112890
// begin wait ( 5 ) ;
108770: LD_INT 5
108772: PPUSH
108773: CALL_OW 67
// tmp := [ ] ;
108777: LD_ADDR_VAR 0 14
108781: PUSH
108782: EMPTY
108783: ST_TO_ADDR
// attacking := false ;
108784: LD_ADDR_VAR 0 29
108788: PUSH
108789: LD_INT 0
108791: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
108792: LD_VAR 0 4
108796: PUSH
108797: LD_VAR 0 7
108801: ARRAY
108802: PPUSH
108803: CALL_OW 301
108807: PUSH
108808: LD_VAR 0 4
108812: PUSH
108813: LD_VAR 0 7
108817: ARRAY
108818: NOT
108819: OR
108820: IFFALSE 108929
// begin if GetType ( group [ i ] ) = unit_human then
108822: LD_VAR 0 4
108826: PUSH
108827: LD_VAR 0 7
108831: ARRAY
108832: PPUSH
108833: CALL_OW 247
108837: PUSH
108838: LD_INT 1
108840: EQUAL
108841: IFFALSE 108887
// begin to_heal := to_heal diff group [ i ] ;
108843: LD_ADDR_VAR 0 30
108847: PUSH
108848: LD_VAR 0 30
108852: PUSH
108853: LD_VAR 0 4
108857: PUSH
108858: LD_VAR 0 7
108862: ARRAY
108863: DIFF
108864: ST_TO_ADDR
// healers := healers diff group [ i ] ;
108865: LD_ADDR_VAR 0 31
108869: PUSH
108870: LD_VAR 0 31
108874: PUSH
108875: LD_VAR 0 4
108879: PUSH
108880: LD_VAR 0 7
108884: ARRAY
108885: DIFF
108886: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
108887: LD_ADDR_VAR 0 4
108891: PUSH
108892: LD_VAR 0 4
108896: PPUSH
108897: LD_VAR 0 7
108901: PPUSH
108902: CALL_OW 3
108906: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
108907: LD_ADDR_VAR 0 16
108911: PUSH
108912: LD_VAR 0 16
108916: PPUSH
108917: LD_VAR 0 7
108921: PPUSH
108922: CALL_OW 3
108926: ST_TO_ADDR
// continue ;
108927: GO 108767
// end ; if f_repair then
108929: LD_VAR 0 22
108933: IFFALSE 109422
// begin if GetType ( group [ i ] ) = unit_vehicle then
108935: LD_VAR 0 4
108939: PUSH
108940: LD_VAR 0 7
108944: ARRAY
108945: PPUSH
108946: CALL_OW 247
108950: PUSH
108951: LD_INT 2
108953: EQUAL
108954: IFFALSE 109144
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
108956: LD_VAR 0 4
108960: PUSH
108961: LD_VAR 0 7
108965: ARRAY
108966: PPUSH
108967: CALL_OW 256
108971: PUSH
108972: LD_INT 700
108974: LESS
108975: PUSH
108976: LD_VAR 0 4
108980: PUSH
108981: LD_VAR 0 7
108985: ARRAY
108986: PUSH
108987: LD_VAR 0 32
108991: IN
108992: NOT
108993: AND
108994: IFFALSE 109018
// to_repair := to_repair union group [ i ] ;
108996: LD_ADDR_VAR 0 32
109000: PUSH
109001: LD_VAR 0 32
109005: PUSH
109006: LD_VAR 0 4
109010: PUSH
109011: LD_VAR 0 7
109015: ARRAY
109016: UNION
109017: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
109018: LD_VAR 0 4
109022: PUSH
109023: LD_VAR 0 7
109027: ARRAY
109028: PPUSH
109029: CALL_OW 256
109033: PUSH
109034: LD_INT 1000
109036: EQUAL
109037: PUSH
109038: LD_VAR 0 4
109042: PUSH
109043: LD_VAR 0 7
109047: ARRAY
109048: PUSH
109049: LD_VAR 0 32
109053: IN
109054: AND
109055: IFFALSE 109079
// to_repair := to_repair diff group [ i ] ;
109057: LD_ADDR_VAR 0 32
109061: PUSH
109062: LD_VAR 0 32
109066: PUSH
109067: LD_VAR 0 4
109071: PUSH
109072: LD_VAR 0 7
109076: ARRAY
109077: DIFF
109078: ST_TO_ADDR
// if group [ i ] in to_repair then
109079: LD_VAR 0 4
109083: PUSH
109084: LD_VAR 0 7
109088: ARRAY
109089: PUSH
109090: LD_VAR 0 32
109094: IN
109095: IFFALSE 109142
// begin if not IsInArea ( group [ i ] , f_repair ) then
109097: LD_VAR 0 4
109101: PUSH
109102: LD_VAR 0 7
109106: ARRAY
109107: PPUSH
109108: LD_VAR 0 22
109112: PPUSH
109113: CALL_OW 308
109117: NOT
109118: IFFALSE 109140
// ComMoveToArea ( group [ i ] , f_repair ) ;
109120: LD_VAR 0 4
109124: PUSH
109125: LD_VAR 0 7
109129: ARRAY
109130: PPUSH
109131: LD_VAR 0 22
109135: PPUSH
109136: CALL_OW 113
// continue ;
109140: GO 108767
// end ; end else
109142: GO 109422
// if group [ i ] in repairs then
109144: LD_VAR 0 4
109148: PUSH
109149: LD_VAR 0 7
109153: ARRAY
109154: PUSH
109155: LD_VAR 0 33
109159: IN
109160: IFFALSE 109422
// begin if IsInUnit ( group [ i ] ) then
109162: LD_VAR 0 4
109166: PUSH
109167: LD_VAR 0 7
109171: ARRAY
109172: PPUSH
109173: CALL_OW 310
109177: IFFALSE 109245
// begin z := IsInUnit ( group [ i ] ) ;
109179: LD_ADDR_VAR 0 13
109183: PUSH
109184: LD_VAR 0 4
109188: PUSH
109189: LD_VAR 0 7
109193: ARRAY
109194: PPUSH
109195: CALL_OW 310
109199: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
109200: LD_VAR 0 13
109204: PUSH
109205: LD_VAR 0 32
109209: IN
109210: PUSH
109211: LD_VAR 0 13
109215: PPUSH
109216: LD_VAR 0 22
109220: PPUSH
109221: CALL_OW 308
109225: AND
109226: IFFALSE 109243
// ComExitVehicle ( group [ i ] ) ;
109228: LD_VAR 0 4
109232: PUSH
109233: LD_VAR 0 7
109237: ARRAY
109238: PPUSH
109239: CALL_OW 121
// end else
109243: GO 109422
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
109245: LD_ADDR_VAR 0 13
109249: PUSH
109250: LD_VAR 0 4
109254: PPUSH
109255: LD_INT 95
109257: PUSH
109258: LD_VAR 0 22
109262: PUSH
109263: EMPTY
109264: LIST
109265: LIST
109266: PUSH
109267: LD_INT 58
109269: PUSH
109270: EMPTY
109271: LIST
109272: PUSH
109273: EMPTY
109274: LIST
109275: LIST
109276: PPUSH
109277: CALL_OW 72
109281: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
109282: LD_VAR 0 4
109286: PUSH
109287: LD_VAR 0 7
109291: ARRAY
109292: PPUSH
109293: CALL_OW 314
109297: NOT
109298: IFFALSE 109420
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
109300: LD_ADDR_VAR 0 10
109304: PUSH
109305: LD_VAR 0 13
109309: PPUSH
109310: LD_VAR 0 4
109314: PUSH
109315: LD_VAR 0 7
109319: ARRAY
109320: PPUSH
109321: CALL_OW 74
109325: ST_TO_ADDR
// if not x then
109326: LD_VAR 0 10
109330: NOT
109331: IFFALSE 109335
// continue ;
109333: GO 108767
// if GetLives ( x ) < 1000 then
109335: LD_VAR 0 10
109339: PPUSH
109340: CALL_OW 256
109344: PUSH
109345: LD_INT 1000
109347: LESS
109348: IFFALSE 109372
// ComRepairVehicle ( group [ i ] , x ) else
109350: LD_VAR 0 4
109354: PUSH
109355: LD_VAR 0 7
109359: ARRAY
109360: PPUSH
109361: LD_VAR 0 10
109365: PPUSH
109366: CALL_OW 129
109370: GO 109420
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
109372: LD_VAR 0 23
109376: PUSH
109377: LD_VAR 0 4
109381: PUSH
109382: LD_VAR 0 7
109386: ARRAY
109387: PPUSH
109388: CALL_OW 256
109392: PUSH
109393: LD_INT 1000
109395: LESS
109396: AND
109397: NOT
109398: IFFALSE 109420
// ComEnterUnit ( group [ i ] , x ) ;
109400: LD_VAR 0 4
109404: PUSH
109405: LD_VAR 0 7
109409: ARRAY
109410: PPUSH
109411: LD_VAR 0 10
109415: PPUSH
109416: CALL_OW 120
// end ; continue ;
109420: GO 108767
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
109422: LD_VAR 0 23
109426: PUSH
109427: LD_VAR 0 4
109431: PUSH
109432: LD_VAR 0 7
109436: ARRAY
109437: PPUSH
109438: CALL_OW 247
109442: PUSH
109443: LD_INT 1
109445: EQUAL
109446: AND
109447: IFFALSE 109925
// begin if group [ i ] in healers then
109449: LD_VAR 0 4
109453: PUSH
109454: LD_VAR 0 7
109458: ARRAY
109459: PUSH
109460: LD_VAR 0 31
109464: IN
109465: IFFALSE 109738
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
109467: LD_VAR 0 4
109471: PUSH
109472: LD_VAR 0 7
109476: ARRAY
109477: PPUSH
109478: LD_VAR 0 23
109482: PPUSH
109483: CALL_OW 308
109487: NOT
109488: PUSH
109489: LD_VAR 0 4
109493: PUSH
109494: LD_VAR 0 7
109498: ARRAY
109499: PPUSH
109500: CALL_OW 314
109504: NOT
109505: AND
109506: IFFALSE 109530
// ComMoveToArea ( group [ i ] , f_heal ) else
109508: LD_VAR 0 4
109512: PUSH
109513: LD_VAR 0 7
109517: ARRAY
109518: PPUSH
109519: LD_VAR 0 23
109523: PPUSH
109524: CALL_OW 113
109528: GO 109736
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
109530: LD_VAR 0 4
109534: PUSH
109535: LD_VAR 0 7
109539: ARRAY
109540: PPUSH
109541: CALL 85554 0 1
109545: PPUSH
109546: CALL_OW 256
109550: PUSH
109551: LD_INT 1000
109553: EQUAL
109554: IFFALSE 109573
// ComStop ( group [ i ] ) else
109556: LD_VAR 0 4
109560: PUSH
109561: LD_VAR 0 7
109565: ARRAY
109566: PPUSH
109567: CALL_OW 141
109571: GO 109736
// if not HasTask ( group [ i ] ) and to_heal then
109573: LD_VAR 0 4
109577: PUSH
109578: LD_VAR 0 7
109582: ARRAY
109583: PPUSH
109584: CALL_OW 314
109588: NOT
109589: PUSH
109590: LD_VAR 0 30
109594: AND
109595: IFFALSE 109736
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
109597: LD_ADDR_VAR 0 13
109601: PUSH
109602: LD_VAR 0 30
109606: PPUSH
109607: LD_INT 3
109609: PUSH
109610: LD_INT 54
109612: PUSH
109613: EMPTY
109614: LIST
109615: PUSH
109616: EMPTY
109617: LIST
109618: LIST
109619: PPUSH
109620: CALL_OW 72
109624: PPUSH
109625: LD_VAR 0 4
109629: PUSH
109630: LD_VAR 0 7
109634: ARRAY
109635: PPUSH
109636: CALL_OW 74
109640: ST_TO_ADDR
// if z then
109641: LD_VAR 0 13
109645: IFFALSE 109736
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
109647: LD_INT 91
109649: PUSH
109650: LD_VAR 0 13
109654: PUSH
109655: LD_INT 10
109657: PUSH
109658: EMPTY
109659: LIST
109660: LIST
109661: LIST
109662: PUSH
109663: LD_INT 81
109665: PUSH
109666: LD_VAR 0 13
109670: PPUSH
109671: CALL_OW 255
109675: PUSH
109676: EMPTY
109677: LIST
109678: LIST
109679: PUSH
109680: EMPTY
109681: LIST
109682: LIST
109683: PPUSH
109684: CALL_OW 69
109688: PUSH
109689: LD_INT 0
109691: EQUAL
109692: IFFALSE 109716
// ComHeal ( group [ i ] , z ) else
109694: LD_VAR 0 4
109698: PUSH
109699: LD_VAR 0 7
109703: ARRAY
109704: PPUSH
109705: LD_VAR 0 13
109709: PPUSH
109710: CALL_OW 128
109714: GO 109736
// ComMoveToArea ( group [ i ] , f_heal ) ;
109716: LD_VAR 0 4
109720: PUSH
109721: LD_VAR 0 7
109725: ARRAY
109726: PPUSH
109727: LD_VAR 0 23
109731: PPUSH
109732: CALL_OW 113
// end ; continue ;
109736: GO 108767
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
109738: LD_VAR 0 4
109742: PUSH
109743: LD_VAR 0 7
109747: ARRAY
109748: PPUSH
109749: CALL_OW 256
109753: PUSH
109754: LD_INT 700
109756: LESS
109757: PUSH
109758: LD_VAR 0 4
109762: PUSH
109763: LD_VAR 0 7
109767: ARRAY
109768: PUSH
109769: LD_VAR 0 30
109773: IN
109774: NOT
109775: AND
109776: IFFALSE 109800
// to_heal := to_heal union group [ i ] ;
109778: LD_ADDR_VAR 0 30
109782: PUSH
109783: LD_VAR 0 30
109787: PUSH
109788: LD_VAR 0 4
109792: PUSH
109793: LD_VAR 0 7
109797: ARRAY
109798: UNION
109799: ST_TO_ADDR
// if group [ i ] in to_heal then
109800: LD_VAR 0 4
109804: PUSH
109805: LD_VAR 0 7
109809: ARRAY
109810: PUSH
109811: LD_VAR 0 30
109815: IN
109816: IFFALSE 109925
// begin if GetLives ( group [ i ] ) = 1000 then
109818: LD_VAR 0 4
109822: PUSH
109823: LD_VAR 0 7
109827: ARRAY
109828: PPUSH
109829: CALL_OW 256
109833: PUSH
109834: LD_INT 1000
109836: EQUAL
109837: IFFALSE 109863
// to_heal := to_heal diff group [ i ] else
109839: LD_ADDR_VAR 0 30
109843: PUSH
109844: LD_VAR 0 30
109848: PUSH
109849: LD_VAR 0 4
109853: PUSH
109854: LD_VAR 0 7
109858: ARRAY
109859: DIFF
109860: ST_TO_ADDR
109861: GO 109925
// begin if not IsInArea ( group [ i ] , to_heal ) then
109863: LD_VAR 0 4
109867: PUSH
109868: LD_VAR 0 7
109872: ARRAY
109873: PPUSH
109874: LD_VAR 0 30
109878: PPUSH
109879: CALL_OW 308
109883: NOT
109884: IFFALSE 109908
// ComMoveToArea ( group [ i ] , f_heal ) else
109886: LD_VAR 0 4
109890: PUSH
109891: LD_VAR 0 7
109895: ARRAY
109896: PPUSH
109897: LD_VAR 0 23
109901: PPUSH
109902: CALL_OW 113
109906: GO 109923
// ComHold ( group [ i ] ) ;
109908: LD_VAR 0 4
109912: PUSH
109913: LD_VAR 0 7
109917: ARRAY
109918: PPUSH
109919: CALL_OW 140
// continue ;
109923: GO 108767
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
109925: LD_VAR 0 4
109929: PUSH
109930: LD_VAR 0 7
109934: ARRAY
109935: PPUSH
109936: LD_INT 10
109938: PPUSH
109939: CALL 83974 0 2
109943: NOT
109944: PUSH
109945: LD_VAR 0 16
109949: PUSH
109950: LD_VAR 0 7
109954: ARRAY
109955: PUSH
109956: EMPTY
109957: EQUAL
109958: NOT
109959: AND
109960: IFFALSE 110226
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
109962: LD_VAR 0 4
109966: PUSH
109967: LD_VAR 0 7
109971: ARRAY
109972: PPUSH
109973: CALL_OW 262
109977: PUSH
109978: LD_INT 1
109980: PUSH
109981: LD_INT 2
109983: PUSH
109984: EMPTY
109985: LIST
109986: LIST
109987: IN
109988: IFFALSE 110029
// if GetFuel ( group [ i ] ) < 10 then
109990: LD_VAR 0 4
109994: PUSH
109995: LD_VAR 0 7
109999: ARRAY
110000: PPUSH
110001: CALL_OW 261
110005: PUSH
110006: LD_INT 10
110008: LESS
110009: IFFALSE 110029
// SetFuel ( group [ i ] , 12 ) ;
110011: LD_VAR 0 4
110015: PUSH
110016: LD_VAR 0 7
110020: ARRAY
110021: PPUSH
110022: LD_INT 12
110024: PPUSH
110025: CALL_OW 240
// if units_path [ i ] then
110029: LD_VAR 0 16
110033: PUSH
110034: LD_VAR 0 7
110038: ARRAY
110039: IFFALSE 110224
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
110041: LD_VAR 0 4
110045: PUSH
110046: LD_VAR 0 7
110050: ARRAY
110051: PPUSH
110052: LD_VAR 0 16
110056: PUSH
110057: LD_VAR 0 7
110061: ARRAY
110062: PUSH
110063: LD_INT 1
110065: ARRAY
110066: PUSH
110067: LD_INT 1
110069: ARRAY
110070: PPUSH
110071: LD_VAR 0 16
110075: PUSH
110076: LD_VAR 0 7
110080: ARRAY
110081: PUSH
110082: LD_INT 1
110084: ARRAY
110085: PUSH
110086: LD_INT 2
110088: ARRAY
110089: PPUSH
110090: CALL_OW 297
110094: PUSH
110095: LD_INT 6
110097: GREATER
110098: IFFALSE 110173
// begin if not HasTask ( group [ i ] ) then
110100: LD_VAR 0 4
110104: PUSH
110105: LD_VAR 0 7
110109: ARRAY
110110: PPUSH
110111: CALL_OW 314
110115: NOT
110116: IFFALSE 110171
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
110118: LD_VAR 0 4
110122: PUSH
110123: LD_VAR 0 7
110127: ARRAY
110128: PPUSH
110129: LD_VAR 0 16
110133: PUSH
110134: LD_VAR 0 7
110138: ARRAY
110139: PUSH
110140: LD_INT 1
110142: ARRAY
110143: PUSH
110144: LD_INT 1
110146: ARRAY
110147: PPUSH
110148: LD_VAR 0 16
110152: PUSH
110153: LD_VAR 0 7
110157: ARRAY
110158: PUSH
110159: LD_INT 1
110161: ARRAY
110162: PUSH
110163: LD_INT 2
110165: ARRAY
110166: PPUSH
110167: CALL_OW 114
// end else
110171: GO 110224
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
110173: LD_ADDR_VAR 0 15
110177: PUSH
110178: LD_VAR 0 16
110182: PUSH
110183: LD_VAR 0 7
110187: ARRAY
110188: PPUSH
110189: LD_INT 1
110191: PPUSH
110192: CALL_OW 3
110196: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
110197: LD_ADDR_VAR 0 16
110201: PUSH
110202: LD_VAR 0 16
110206: PPUSH
110207: LD_VAR 0 7
110211: PPUSH
110212: LD_VAR 0 15
110216: PPUSH
110217: CALL_OW 1
110221: ST_TO_ADDR
// continue ;
110222: GO 108767
// end ; end ; end else
110224: GO 112888
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
110226: LD_ADDR_VAR 0 14
110230: PUSH
110231: LD_INT 81
110233: PUSH
110234: LD_VAR 0 4
110238: PUSH
110239: LD_VAR 0 7
110243: ARRAY
110244: PPUSH
110245: CALL_OW 255
110249: PUSH
110250: EMPTY
110251: LIST
110252: LIST
110253: PPUSH
110254: CALL_OW 69
110258: ST_TO_ADDR
// if not tmp then
110259: LD_VAR 0 14
110263: NOT
110264: IFFALSE 110268
// continue ;
110266: GO 108767
// if f_ignore_area then
110268: LD_VAR 0 17
110272: IFFALSE 110360
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
110274: LD_ADDR_VAR 0 15
110278: PUSH
110279: LD_VAR 0 14
110283: PPUSH
110284: LD_INT 3
110286: PUSH
110287: LD_INT 92
110289: PUSH
110290: LD_VAR 0 17
110294: PUSH
110295: LD_INT 1
110297: ARRAY
110298: PUSH
110299: LD_VAR 0 17
110303: PUSH
110304: LD_INT 2
110306: ARRAY
110307: PUSH
110308: LD_VAR 0 17
110312: PUSH
110313: LD_INT 3
110315: ARRAY
110316: PUSH
110317: EMPTY
110318: LIST
110319: LIST
110320: LIST
110321: LIST
110322: PUSH
110323: EMPTY
110324: LIST
110325: LIST
110326: PPUSH
110327: CALL_OW 72
110331: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110332: LD_VAR 0 14
110336: PUSH
110337: LD_VAR 0 15
110341: DIFF
110342: IFFALSE 110360
// tmp := tmp diff tmp2 ;
110344: LD_ADDR_VAR 0 14
110348: PUSH
110349: LD_VAR 0 14
110353: PUSH
110354: LD_VAR 0 15
110358: DIFF
110359: ST_TO_ADDR
// end ; if not f_murder then
110360: LD_VAR 0 20
110364: NOT
110365: IFFALSE 110423
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
110367: LD_ADDR_VAR 0 15
110371: PUSH
110372: LD_VAR 0 14
110376: PPUSH
110377: LD_INT 3
110379: PUSH
110380: LD_INT 50
110382: PUSH
110383: EMPTY
110384: LIST
110385: PUSH
110386: EMPTY
110387: LIST
110388: LIST
110389: PPUSH
110390: CALL_OW 72
110394: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110395: LD_VAR 0 14
110399: PUSH
110400: LD_VAR 0 15
110404: DIFF
110405: IFFALSE 110423
// tmp := tmp diff tmp2 ;
110407: LD_ADDR_VAR 0 14
110411: PUSH
110412: LD_VAR 0 14
110416: PUSH
110417: LD_VAR 0 15
110421: DIFF
110422: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
110423: LD_ADDR_VAR 0 14
110427: PUSH
110428: LD_VAR 0 4
110432: PUSH
110433: LD_VAR 0 7
110437: ARRAY
110438: PPUSH
110439: LD_VAR 0 14
110443: PPUSH
110444: LD_INT 1
110446: PPUSH
110447: LD_INT 1
110449: PPUSH
110450: CALL 56909 0 4
110454: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
110455: LD_VAR 0 4
110459: PUSH
110460: LD_VAR 0 7
110464: ARRAY
110465: PPUSH
110466: CALL_OW 257
110470: PUSH
110471: LD_INT 1
110473: EQUAL
110474: IFFALSE 110922
// begin if WantPlant ( group [ i ] ) then
110476: LD_VAR 0 4
110480: PUSH
110481: LD_VAR 0 7
110485: ARRAY
110486: PPUSH
110487: CALL 56410 0 1
110491: IFFALSE 110495
// continue ;
110493: GO 108767
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
110495: LD_VAR 0 18
110499: PUSH
110500: LD_VAR 0 4
110504: PUSH
110505: LD_VAR 0 7
110509: ARRAY
110510: PPUSH
110511: CALL_OW 310
110515: NOT
110516: AND
110517: PUSH
110518: LD_VAR 0 14
110522: PUSH
110523: LD_INT 1
110525: ARRAY
110526: PUSH
110527: LD_VAR 0 14
110531: PPUSH
110532: LD_INT 21
110534: PUSH
110535: LD_INT 2
110537: PUSH
110538: EMPTY
110539: LIST
110540: LIST
110541: PUSH
110542: LD_INT 58
110544: PUSH
110545: EMPTY
110546: LIST
110547: PUSH
110548: EMPTY
110549: LIST
110550: LIST
110551: PPUSH
110552: CALL_OW 72
110556: IN
110557: AND
110558: IFFALSE 110594
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
110560: LD_VAR 0 4
110564: PUSH
110565: LD_VAR 0 7
110569: ARRAY
110570: PPUSH
110571: LD_VAR 0 14
110575: PUSH
110576: LD_INT 1
110578: ARRAY
110579: PPUSH
110580: CALL_OW 120
// attacking := true ;
110584: LD_ADDR_VAR 0 29
110588: PUSH
110589: LD_INT 1
110591: ST_TO_ADDR
// continue ;
110592: GO 108767
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
110594: LD_VAR 0 26
110598: PUSH
110599: LD_VAR 0 4
110603: PUSH
110604: LD_VAR 0 7
110608: ARRAY
110609: PPUSH
110610: CALL_OW 257
110614: PUSH
110615: LD_INT 1
110617: EQUAL
110618: AND
110619: PUSH
110620: LD_VAR 0 4
110624: PUSH
110625: LD_VAR 0 7
110629: ARRAY
110630: PPUSH
110631: CALL_OW 256
110635: PUSH
110636: LD_INT 800
110638: LESS
110639: AND
110640: PUSH
110641: LD_VAR 0 4
110645: PUSH
110646: LD_VAR 0 7
110650: ARRAY
110651: PPUSH
110652: CALL_OW 318
110656: NOT
110657: AND
110658: IFFALSE 110675
// ComCrawl ( group [ i ] ) ;
110660: LD_VAR 0 4
110664: PUSH
110665: LD_VAR 0 7
110669: ARRAY
110670: PPUSH
110671: CALL_OW 137
// if f_mines then
110675: LD_VAR 0 21
110679: IFFALSE 110922
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
110681: LD_VAR 0 14
110685: PUSH
110686: LD_INT 1
110688: ARRAY
110689: PPUSH
110690: CALL_OW 247
110694: PUSH
110695: LD_INT 3
110697: EQUAL
110698: PUSH
110699: LD_VAR 0 14
110703: PUSH
110704: LD_INT 1
110706: ARRAY
110707: PUSH
110708: LD_VAR 0 27
110712: IN
110713: NOT
110714: AND
110715: IFFALSE 110922
// begin x := GetX ( tmp [ 1 ] ) ;
110717: LD_ADDR_VAR 0 10
110721: PUSH
110722: LD_VAR 0 14
110726: PUSH
110727: LD_INT 1
110729: ARRAY
110730: PPUSH
110731: CALL_OW 250
110735: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
110736: LD_ADDR_VAR 0 11
110740: PUSH
110741: LD_VAR 0 14
110745: PUSH
110746: LD_INT 1
110748: ARRAY
110749: PPUSH
110750: CALL_OW 251
110754: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
110755: LD_ADDR_VAR 0 12
110759: PUSH
110760: LD_VAR 0 4
110764: PUSH
110765: LD_VAR 0 7
110769: ARRAY
110770: PPUSH
110771: CALL 84059 0 1
110775: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
110776: LD_VAR 0 4
110780: PUSH
110781: LD_VAR 0 7
110785: ARRAY
110786: PPUSH
110787: LD_VAR 0 10
110791: PPUSH
110792: LD_VAR 0 11
110796: PPUSH
110797: LD_VAR 0 14
110801: PUSH
110802: LD_INT 1
110804: ARRAY
110805: PPUSH
110806: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
110810: LD_VAR 0 4
110814: PUSH
110815: LD_VAR 0 7
110819: ARRAY
110820: PPUSH
110821: LD_VAR 0 10
110825: PPUSH
110826: LD_VAR 0 12
110830: PPUSH
110831: LD_INT 7
110833: PPUSH
110834: CALL_OW 272
110838: PPUSH
110839: LD_VAR 0 11
110843: PPUSH
110844: LD_VAR 0 12
110848: PPUSH
110849: LD_INT 7
110851: PPUSH
110852: CALL_OW 273
110856: PPUSH
110857: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
110861: LD_VAR 0 4
110865: PUSH
110866: LD_VAR 0 7
110870: ARRAY
110871: PPUSH
110872: LD_INT 71
110874: PPUSH
110875: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
110879: LD_ADDR_VAR 0 27
110883: PUSH
110884: LD_VAR 0 27
110888: PPUSH
110889: LD_VAR 0 27
110893: PUSH
110894: LD_INT 1
110896: PLUS
110897: PPUSH
110898: LD_VAR 0 14
110902: PUSH
110903: LD_INT 1
110905: ARRAY
110906: PPUSH
110907: CALL_OW 1
110911: ST_TO_ADDR
// attacking := true ;
110912: LD_ADDR_VAR 0 29
110916: PUSH
110917: LD_INT 1
110919: ST_TO_ADDR
// continue ;
110920: GO 108767
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
110922: LD_VAR 0 4
110926: PUSH
110927: LD_VAR 0 7
110931: ARRAY
110932: PPUSH
110933: CALL_OW 257
110937: PUSH
110938: LD_INT 17
110940: EQUAL
110941: PUSH
110942: LD_VAR 0 4
110946: PUSH
110947: LD_VAR 0 7
110951: ARRAY
110952: PPUSH
110953: CALL_OW 110
110957: PUSH
110958: LD_INT 71
110960: EQUAL
110961: NOT
110962: AND
110963: IFFALSE 111109
// begin attacking := false ;
110965: LD_ADDR_VAR 0 29
110969: PUSH
110970: LD_INT 0
110972: ST_TO_ADDR
// k := 5 ;
110973: LD_ADDR_VAR 0 9
110977: PUSH
110978: LD_INT 5
110980: ST_TO_ADDR
// if tmp < k then
110981: LD_VAR 0 14
110985: PUSH
110986: LD_VAR 0 9
110990: LESS
110991: IFFALSE 111003
// k := tmp ;
110993: LD_ADDR_VAR 0 9
110997: PUSH
110998: LD_VAR 0 14
111002: ST_TO_ADDR
// for j = 1 to k do
111003: LD_ADDR_VAR 0 8
111007: PUSH
111008: DOUBLE
111009: LD_INT 1
111011: DEC
111012: ST_TO_ADDR
111013: LD_VAR 0 9
111017: PUSH
111018: FOR_TO
111019: IFFALSE 111107
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
111021: LD_VAR 0 14
111025: PUSH
111026: LD_VAR 0 8
111030: ARRAY
111031: PUSH
111032: LD_VAR 0 14
111036: PPUSH
111037: LD_INT 58
111039: PUSH
111040: EMPTY
111041: LIST
111042: PPUSH
111043: CALL_OW 72
111047: IN
111048: NOT
111049: IFFALSE 111105
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111051: LD_VAR 0 4
111055: PUSH
111056: LD_VAR 0 7
111060: ARRAY
111061: PPUSH
111062: LD_VAR 0 14
111066: PUSH
111067: LD_VAR 0 8
111071: ARRAY
111072: PPUSH
111073: CALL_OW 115
// attacking := true ;
111077: LD_ADDR_VAR 0 29
111081: PUSH
111082: LD_INT 1
111084: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
111085: LD_VAR 0 4
111089: PUSH
111090: LD_VAR 0 7
111094: ARRAY
111095: PPUSH
111096: LD_INT 71
111098: PPUSH
111099: CALL_OW 109
// continue ;
111103: GO 111018
// end ; end ;
111105: GO 111018
111107: POP
111108: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
111109: LD_VAR 0 4
111113: PUSH
111114: LD_VAR 0 7
111118: ARRAY
111119: PPUSH
111120: CALL_OW 257
111124: PUSH
111125: LD_INT 8
111127: EQUAL
111128: PUSH
111129: LD_VAR 0 4
111133: PUSH
111134: LD_VAR 0 7
111138: ARRAY
111139: PPUSH
111140: CALL_OW 264
111144: PUSH
111145: LD_INT 28
111147: PUSH
111148: LD_INT 45
111150: PUSH
111151: LD_INT 7
111153: PUSH
111154: LD_INT 47
111156: PUSH
111157: EMPTY
111158: LIST
111159: LIST
111160: LIST
111161: LIST
111162: IN
111163: OR
111164: IFFALSE 111420
// begin attacking := false ;
111166: LD_ADDR_VAR 0 29
111170: PUSH
111171: LD_INT 0
111173: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
111174: LD_VAR 0 14
111178: PUSH
111179: LD_INT 1
111181: ARRAY
111182: PPUSH
111183: CALL_OW 266
111187: PUSH
111188: LD_INT 32
111190: PUSH
111191: LD_INT 31
111193: PUSH
111194: LD_INT 33
111196: PUSH
111197: LD_INT 4
111199: PUSH
111200: LD_INT 5
111202: PUSH
111203: EMPTY
111204: LIST
111205: LIST
111206: LIST
111207: LIST
111208: LIST
111209: IN
111210: IFFALSE 111396
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
111212: LD_ADDR_VAR 0 9
111216: PUSH
111217: LD_VAR 0 14
111221: PUSH
111222: LD_INT 1
111224: ARRAY
111225: PPUSH
111226: CALL_OW 266
111230: PPUSH
111231: LD_VAR 0 14
111235: PUSH
111236: LD_INT 1
111238: ARRAY
111239: PPUSH
111240: CALL_OW 250
111244: PPUSH
111245: LD_VAR 0 14
111249: PUSH
111250: LD_INT 1
111252: ARRAY
111253: PPUSH
111254: CALL_OW 251
111258: PPUSH
111259: LD_VAR 0 14
111263: PUSH
111264: LD_INT 1
111266: ARRAY
111267: PPUSH
111268: CALL_OW 254
111272: PPUSH
111273: LD_VAR 0 14
111277: PUSH
111278: LD_INT 1
111280: ARRAY
111281: PPUSH
111282: CALL_OW 248
111286: PPUSH
111287: LD_INT 0
111289: PPUSH
111290: CALL 65429 0 6
111294: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
111295: LD_ADDR_VAR 0 8
111299: PUSH
111300: LD_VAR 0 4
111304: PUSH
111305: LD_VAR 0 7
111309: ARRAY
111310: PPUSH
111311: LD_VAR 0 9
111315: PPUSH
111316: CALL 84099 0 2
111320: ST_TO_ADDR
// if j then
111321: LD_VAR 0 8
111325: IFFALSE 111394
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
111327: LD_VAR 0 8
111331: PUSH
111332: LD_INT 1
111334: ARRAY
111335: PPUSH
111336: LD_VAR 0 8
111340: PUSH
111341: LD_INT 2
111343: ARRAY
111344: PPUSH
111345: CALL_OW 488
111349: IFFALSE 111394
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
111351: LD_VAR 0 4
111355: PUSH
111356: LD_VAR 0 7
111360: ARRAY
111361: PPUSH
111362: LD_VAR 0 8
111366: PUSH
111367: LD_INT 1
111369: ARRAY
111370: PPUSH
111371: LD_VAR 0 8
111375: PUSH
111376: LD_INT 2
111378: ARRAY
111379: PPUSH
111380: CALL_OW 116
// attacking := true ;
111384: LD_ADDR_VAR 0 29
111388: PUSH
111389: LD_INT 1
111391: ST_TO_ADDR
// continue ;
111392: GO 108767
// end ; end else
111394: GO 111420
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111396: LD_VAR 0 4
111400: PUSH
111401: LD_VAR 0 7
111405: ARRAY
111406: PPUSH
111407: LD_VAR 0 14
111411: PUSH
111412: LD_INT 1
111414: ARRAY
111415: PPUSH
111416: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
111420: LD_VAR 0 4
111424: PUSH
111425: LD_VAR 0 7
111429: ARRAY
111430: PPUSH
111431: CALL_OW 265
111435: PUSH
111436: LD_INT 11
111438: EQUAL
111439: IFFALSE 111717
// begin k := 10 ;
111441: LD_ADDR_VAR 0 9
111445: PUSH
111446: LD_INT 10
111448: ST_TO_ADDR
// x := 0 ;
111449: LD_ADDR_VAR 0 10
111453: PUSH
111454: LD_INT 0
111456: ST_TO_ADDR
// if tmp < k then
111457: LD_VAR 0 14
111461: PUSH
111462: LD_VAR 0 9
111466: LESS
111467: IFFALSE 111479
// k := tmp ;
111469: LD_ADDR_VAR 0 9
111473: PUSH
111474: LD_VAR 0 14
111478: ST_TO_ADDR
// for j = k downto 1 do
111479: LD_ADDR_VAR 0 8
111483: PUSH
111484: DOUBLE
111485: LD_VAR 0 9
111489: INC
111490: ST_TO_ADDR
111491: LD_INT 1
111493: PUSH
111494: FOR_DOWNTO
111495: IFFALSE 111570
// begin if GetType ( tmp [ j ] ) = unit_human then
111497: LD_VAR 0 14
111501: PUSH
111502: LD_VAR 0 8
111506: ARRAY
111507: PPUSH
111508: CALL_OW 247
111512: PUSH
111513: LD_INT 1
111515: EQUAL
111516: IFFALSE 111568
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
111518: LD_VAR 0 4
111522: PUSH
111523: LD_VAR 0 7
111527: ARRAY
111528: PPUSH
111529: LD_VAR 0 14
111533: PUSH
111534: LD_VAR 0 8
111538: ARRAY
111539: PPUSH
111540: CALL 84370 0 2
// x := tmp [ j ] ;
111544: LD_ADDR_VAR 0 10
111548: PUSH
111549: LD_VAR 0 14
111553: PUSH
111554: LD_VAR 0 8
111558: ARRAY
111559: ST_TO_ADDR
// attacking := true ;
111560: LD_ADDR_VAR 0 29
111564: PUSH
111565: LD_INT 1
111567: ST_TO_ADDR
// end ; end ;
111568: GO 111494
111570: POP
111571: POP
// if not x then
111572: LD_VAR 0 10
111576: NOT
111577: IFFALSE 111717
// begin attacking := true ;
111579: LD_ADDR_VAR 0 29
111583: PUSH
111584: LD_INT 1
111586: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
111587: LD_VAR 0 4
111591: PUSH
111592: LD_VAR 0 7
111596: ARRAY
111597: PPUSH
111598: CALL_OW 250
111602: PPUSH
111603: LD_VAR 0 4
111607: PUSH
111608: LD_VAR 0 7
111612: ARRAY
111613: PPUSH
111614: CALL_OW 251
111618: PPUSH
111619: CALL_OW 546
111623: PUSH
111624: LD_INT 2
111626: ARRAY
111627: PUSH
111628: LD_VAR 0 14
111632: PUSH
111633: LD_INT 1
111635: ARRAY
111636: PPUSH
111637: CALL_OW 250
111641: PPUSH
111642: LD_VAR 0 14
111646: PUSH
111647: LD_INT 1
111649: ARRAY
111650: PPUSH
111651: CALL_OW 251
111655: PPUSH
111656: CALL_OW 546
111660: PUSH
111661: LD_INT 2
111663: ARRAY
111664: EQUAL
111665: IFFALSE 111693
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
111667: LD_VAR 0 4
111671: PUSH
111672: LD_VAR 0 7
111676: ARRAY
111677: PPUSH
111678: LD_VAR 0 14
111682: PUSH
111683: LD_INT 1
111685: ARRAY
111686: PPUSH
111687: CALL 84370 0 2
111691: GO 111717
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111693: LD_VAR 0 4
111697: PUSH
111698: LD_VAR 0 7
111702: ARRAY
111703: PPUSH
111704: LD_VAR 0 14
111708: PUSH
111709: LD_INT 1
111711: ARRAY
111712: PPUSH
111713: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
111717: LD_VAR 0 4
111721: PUSH
111722: LD_VAR 0 7
111726: ARRAY
111727: PPUSH
111728: CALL_OW 264
111732: PUSH
111733: LD_INT 29
111735: EQUAL
111736: IFFALSE 112102
// begin if WantsToAttack ( group [ i ] ) in bombed then
111738: LD_VAR 0 4
111742: PUSH
111743: LD_VAR 0 7
111747: ARRAY
111748: PPUSH
111749: CALL_OW 319
111753: PUSH
111754: LD_VAR 0 28
111758: IN
111759: IFFALSE 111763
// continue ;
111761: GO 108767
// k := 8 ;
111763: LD_ADDR_VAR 0 9
111767: PUSH
111768: LD_INT 8
111770: ST_TO_ADDR
// x := 0 ;
111771: LD_ADDR_VAR 0 10
111775: PUSH
111776: LD_INT 0
111778: ST_TO_ADDR
// if tmp < k then
111779: LD_VAR 0 14
111783: PUSH
111784: LD_VAR 0 9
111788: LESS
111789: IFFALSE 111801
// k := tmp ;
111791: LD_ADDR_VAR 0 9
111795: PUSH
111796: LD_VAR 0 14
111800: ST_TO_ADDR
// for j = 1 to k do
111801: LD_ADDR_VAR 0 8
111805: PUSH
111806: DOUBLE
111807: LD_INT 1
111809: DEC
111810: ST_TO_ADDR
111811: LD_VAR 0 9
111815: PUSH
111816: FOR_TO
111817: IFFALSE 111949
// begin if GetType ( tmp [ j ] ) = unit_building then
111819: LD_VAR 0 14
111823: PUSH
111824: LD_VAR 0 8
111828: ARRAY
111829: PPUSH
111830: CALL_OW 247
111834: PUSH
111835: LD_INT 3
111837: EQUAL
111838: IFFALSE 111947
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
111840: LD_VAR 0 14
111844: PUSH
111845: LD_VAR 0 8
111849: ARRAY
111850: PUSH
111851: LD_VAR 0 28
111855: IN
111856: NOT
111857: PUSH
111858: LD_VAR 0 14
111862: PUSH
111863: LD_VAR 0 8
111867: ARRAY
111868: PPUSH
111869: CALL_OW 313
111873: AND
111874: IFFALSE 111947
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111876: LD_VAR 0 4
111880: PUSH
111881: LD_VAR 0 7
111885: ARRAY
111886: PPUSH
111887: LD_VAR 0 14
111891: PUSH
111892: LD_VAR 0 8
111896: ARRAY
111897: PPUSH
111898: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
111902: LD_ADDR_VAR 0 28
111906: PUSH
111907: LD_VAR 0 28
111911: PPUSH
111912: LD_VAR 0 28
111916: PUSH
111917: LD_INT 1
111919: PLUS
111920: PPUSH
111921: LD_VAR 0 14
111925: PUSH
111926: LD_VAR 0 8
111930: ARRAY
111931: PPUSH
111932: CALL_OW 1
111936: ST_TO_ADDR
// attacking := true ;
111937: LD_ADDR_VAR 0 29
111941: PUSH
111942: LD_INT 1
111944: ST_TO_ADDR
// break ;
111945: GO 111949
// end ; end ;
111947: GO 111816
111949: POP
111950: POP
// if not attacking and f_attack_depot then
111951: LD_VAR 0 29
111955: NOT
111956: PUSH
111957: LD_VAR 0 25
111961: AND
111962: IFFALSE 112057
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111964: LD_ADDR_VAR 0 13
111968: PUSH
111969: LD_VAR 0 14
111973: PPUSH
111974: LD_INT 2
111976: PUSH
111977: LD_INT 30
111979: PUSH
111980: LD_INT 0
111982: PUSH
111983: EMPTY
111984: LIST
111985: LIST
111986: PUSH
111987: LD_INT 30
111989: PUSH
111990: LD_INT 1
111992: PUSH
111993: EMPTY
111994: LIST
111995: LIST
111996: PUSH
111997: EMPTY
111998: LIST
111999: LIST
112000: LIST
112001: PPUSH
112002: CALL_OW 72
112006: ST_TO_ADDR
// if z then
112007: LD_VAR 0 13
112011: IFFALSE 112057
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
112013: LD_VAR 0 4
112017: PUSH
112018: LD_VAR 0 7
112022: ARRAY
112023: PPUSH
112024: LD_VAR 0 13
112028: PPUSH
112029: LD_VAR 0 4
112033: PUSH
112034: LD_VAR 0 7
112038: ARRAY
112039: PPUSH
112040: CALL_OW 74
112044: PPUSH
112045: CALL_OW 115
// attacking := true ;
112049: LD_ADDR_VAR 0 29
112053: PUSH
112054: LD_INT 1
112056: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
112057: LD_VAR 0 4
112061: PUSH
112062: LD_VAR 0 7
112066: ARRAY
112067: PPUSH
112068: CALL_OW 256
112072: PUSH
112073: LD_INT 500
112075: LESS
112076: IFFALSE 112102
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112078: LD_VAR 0 4
112082: PUSH
112083: LD_VAR 0 7
112087: ARRAY
112088: PPUSH
112089: LD_VAR 0 14
112093: PUSH
112094: LD_INT 1
112096: ARRAY
112097: PPUSH
112098: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
112102: LD_VAR 0 4
112106: PUSH
112107: LD_VAR 0 7
112111: ARRAY
112112: PPUSH
112113: CALL_OW 264
112117: PUSH
112118: LD_INT 49
112120: EQUAL
112121: IFFALSE 112242
// begin if not HasTask ( group [ i ] ) then
112123: LD_VAR 0 4
112127: PUSH
112128: LD_VAR 0 7
112132: ARRAY
112133: PPUSH
112134: CALL_OW 314
112138: NOT
112139: IFFALSE 112242
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
112141: LD_ADDR_VAR 0 9
112145: PUSH
112146: LD_INT 81
112148: PUSH
112149: LD_VAR 0 4
112153: PUSH
112154: LD_VAR 0 7
112158: ARRAY
112159: PPUSH
112160: CALL_OW 255
112164: PUSH
112165: EMPTY
112166: LIST
112167: LIST
112168: PPUSH
112169: CALL_OW 69
112173: PPUSH
112174: LD_VAR 0 4
112178: PUSH
112179: LD_VAR 0 7
112183: ARRAY
112184: PPUSH
112185: CALL_OW 74
112189: ST_TO_ADDR
// if k then
112190: LD_VAR 0 9
112194: IFFALSE 112242
// if GetDistUnits ( group [ i ] , k ) > 10 then
112196: LD_VAR 0 4
112200: PUSH
112201: LD_VAR 0 7
112205: ARRAY
112206: PPUSH
112207: LD_VAR 0 9
112211: PPUSH
112212: CALL_OW 296
112216: PUSH
112217: LD_INT 10
112219: GREATER
112220: IFFALSE 112242
// ComMoveUnit ( group [ i ] , k ) ;
112222: LD_VAR 0 4
112226: PUSH
112227: LD_VAR 0 7
112231: ARRAY
112232: PPUSH
112233: LD_VAR 0 9
112237: PPUSH
112238: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
112242: LD_VAR 0 4
112246: PUSH
112247: LD_VAR 0 7
112251: ARRAY
112252: PPUSH
112253: CALL_OW 256
112257: PUSH
112258: LD_INT 250
112260: LESS
112261: PUSH
112262: LD_VAR 0 4
112266: PUSH
112267: LD_VAR 0 7
112271: ARRAY
112272: PUSH
112273: LD_INT 21
112275: PUSH
112276: LD_INT 2
112278: PUSH
112279: EMPTY
112280: LIST
112281: LIST
112282: PUSH
112283: LD_INT 23
112285: PUSH
112286: LD_INT 2
112288: PUSH
112289: EMPTY
112290: LIST
112291: LIST
112292: PUSH
112293: EMPTY
112294: LIST
112295: LIST
112296: PPUSH
112297: CALL_OW 69
112301: IN
112302: AND
112303: IFFALSE 112428
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
112305: LD_ADDR_VAR 0 9
112309: PUSH
112310: LD_OWVAR 3
112314: PUSH
112315: LD_VAR 0 4
112319: PUSH
112320: LD_VAR 0 7
112324: ARRAY
112325: DIFF
112326: PPUSH
112327: LD_VAR 0 4
112331: PUSH
112332: LD_VAR 0 7
112336: ARRAY
112337: PPUSH
112338: CALL_OW 74
112342: ST_TO_ADDR
// if not k then
112343: LD_VAR 0 9
112347: NOT
112348: IFFALSE 112352
// continue ;
112350: GO 108767
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
112352: LD_VAR 0 9
112356: PUSH
112357: LD_INT 81
112359: PUSH
112360: LD_VAR 0 4
112364: PUSH
112365: LD_VAR 0 7
112369: ARRAY
112370: PPUSH
112371: CALL_OW 255
112375: PUSH
112376: EMPTY
112377: LIST
112378: LIST
112379: PPUSH
112380: CALL_OW 69
112384: IN
112385: PUSH
112386: LD_VAR 0 9
112390: PPUSH
112391: LD_VAR 0 4
112395: PUSH
112396: LD_VAR 0 7
112400: ARRAY
112401: PPUSH
112402: CALL_OW 296
112406: PUSH
112407: LD_INT 5
112409: LESS
112410: AND
112411: IFFALSE 112428
// ComAutodestruct ( group [ i ] ) ;
112413: LD_VAR 0 4
112417: PUSH
112418: LD_VAR 0 7
112422: ARRAY
112423: PPUSH
112424: CALL 84268 0 1
// end ; if f_attack_depot then
112428: LD_VAR 0 25
112432: IFFALSE 112544
// begin k := 6 ;
112434: LD_ADDR_VAR 0 9
112438: PUSH
112439: LD_INT 6
112441: ST_TO_ADDR
// if tmp < k then
112442: LD_VAR 0 14
112446: PUSH
112447: LD_VAR 0 9
112451: LESS
112452: IFFALSE 112464
// k := tmp ;
112454: LD_ADDR_VAR 0 9
112458: PUSH
112459: LD_VAR 0 14
112463: ST_TO_ADDR
// for j = 1 to k do
112464: LD_ADDR_VAR 0 8
112468: PUSH
112469: DOUBLE
112470: LD_INT 1
112472: DEC
112473: ST_TO_ADDR
112474: LD_VAR 0 9
112478: PUSH
112479: FOR_TO
112480: IFFALSE 112542
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
112482: LD_VAR 0 8
112486: PPUSH
112487: CALL_OW 266
112491: PUSH
112492: LD_INT 0
112494: PUSH
112495: LD_INT 1
112497: PUSH
112498: EMPTY
112499: LIST
112500: LIST
112501: IN
112502: IFFALSE 112540
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112504: LD_VAR 0 4
112508: PUSH
112509: LD_VAR 0 7
112513: ARRAY
112514: PPUSH
112515: LD_VAR 0 14
112519: PUSH
112520: LD_VAR 0 8
112524: ARRAY
112525: PPUSH
112526: CALL_OW 115
// attacking := true ;
112530: LD_ADDR_VAR 0 29
112534: PUSH
112535: LD_INT 1
112537: ST_TO_ADDR
// break ;
112538: GO 112542
// end ;
112540: GO 112479
112542: POP
112543: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
112544: LD_VAR 0 4
112548: PUSH
112549: LD_VAR 0 7
112553: ARRAY
112554: PPUSH
112555: CALL_OW 302
112559: PUSH
112560: LD_VAR 0 29
112564: NOT
112565: AND
112566: IFFALSE 112888
// begin if GetTag ( group [ i ] ) = 71 then
112568: LD_VAR 0 4
112572: PUSH
112573: LD_VAR 0 7
112577: ARRAY
112578: PPUSH
112579: CALL_OW 110
112583: PUSH
112584: LD_INT 71
112586: EQUAL
112587: IFFALSE 112628
// begin if HasTask ( group [ i ] ) then
112589: LD_VAR 0 4
112593: PUSH
112594: LD_VAR 0 7
112598: ARRAY
112599: PPUSH
112600: CALL_OW 314
112604: IFFALSE 112610
// continue else
112606: GO 108767
112608: GO 112628
// SetTag ( group [ i ] , 0 ) ;
112610: LD_VAR 0 4
112614: PUSH
112615: LD_VAR 0 7
112619: ARRAY
112620: PPUSH
112621: LD_INT 0
112623: PPUSH
112624: CALL_OW 109
// end ; k := 8 ;
112628: LD_ADDR_VAR 0 9
112632: PUSH
112633: LD_INT 8
112635: ST_TO_ADDR
// x := 0 ;
112636: LD_ADDR_VAR 0 10
112640: PUSH
112641: LD_INT 0
112643: ST_TO_ADDR
// if tmp < k then
112644: LD_VAR 0 14
112648: PUSH
112649: LD_VAR 0 9
112653: LESS
112654: IFFALSE 112666
// k := tmp ;
112656: LD_ADDR_VAR 0 9
112660: PUSH
112661: LD_VAR 0 14
112665: ST_TO_ADDR
// for j = 1 to k do
112666: LD_ADDR_VAR 0 8
112670: PUSH
112671: DOUBLE
112672: LD_INT 1
112674: DEC
112675: ST_TO_ADDR
112676: LD_VAR 0 9
112680: PUSH
112681: FOR_TO
112682: IFFALSE 112780
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
112684: LD_VAR 0 14
112688: PUSH
112689: LD_VAR 0 8
112693: ARRAY
112694: PPUSH
112695: CALL_OW 247
112699: PUSH
112700: LD_INT 1
112702: EQUAL
112703: PUSH
112704: LD_VAR 0 14
112708: PUSH
112709: LD_VAR 0 8
112713: ARRAY
112714: PPUSH
112715: CALL_OW 256
112719: PUSH
112720: LD_INT 250
112722: LESS
112723: PUSH
112724: LD_VAR 0 20
112728: AND
112729: PUSH
112730: LD_VAR 0 20
112734: NOT
112735: PUSH
112736: LD_VAR 0 14
112740: PUSH
112741: LD_VAR 0 8
112745: ARRAY
112746: PPUSH
112747: CALL_OW 256
112751: PUSH
112752: LD_INT 250
112754: GREATEREQUAL
112755: AND
112756: OR
112757: AND
112758: IFFALSE 112778
// begin x := tmp [ j ] ;
112760: LD_ADDR_VAR 0 10
112764: PUSH
112765: LD_VAR 0 14
112769: PUSH
112770: LD_VAR 0 8
112774: ARRAY
112775: ST_TO_ADDR
// break ;
112776: GO 112780
// end ;
112778: GO 112681
112780: POP
112781: POP
// if x then
112782: LD_VAR 0 10
112786: IFFALSE 112810
// ComAttackUnit ( group [ i ] , x ) else
112788: LD_VAR 0 4
112792: PUSH
112793: LD_VAR 0 7
112797: ARRAY
112798: PPUSH
112799: LD_VAR 0 10
112803: PPUSH
112804: CALL_OW 115
112808: GO 112834
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112810: LD_VAR 0 4
112814: PUSH
112815: LD_VAR 0 7
112819: ARRAY
112820: PPUSH
112821: LD_VAR 0 14
112825: PUSH
112826: LD_INT 1
112828: ARRAY
112829: PPUSH
112830: CALL_OW 115
// if not HasTask ( group [ i ] ) then
112834: LD_VAR 0 4
112838: PUSH
112839: LD_VAR 0 7
112843: ARRAY
112844: PPUSH
112845: CALL_OW 314
112849: NOT
112850: IFFALSE 112888
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
112852: LD_VAR 0 4
112856: PUSH
112857: LD_VAR 0 7
112861: ARRAY
112862: PPUSH
112863: LD_VAR 0 14
112867: PPUSH
112868: LD_VAR 0 4
112872: PUSH
112873: LD_VAR 0 7
112877: ARRAY
112878: PPUSH
112879: CALL_OW 74
112883: PPUSH
112884: CALL_OW 115
// end ; end ; end ;
112888: GO 108767
112890: POP
112891: POP
// wait ( 0 0$2 ) ;
112892: LD_INT 70
112894: PPUSH
112895: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
112899: LD_VAR 0 4
112903: NOT
112904: PUSH
112905: LD_VAR 0 4
112909: PUSH
112910: EMPTY
112911: EQUAL
112912: OR
112913: PUSH
112914: LD_INT 81
112916: PUSH
112917: LD_VAR 0 35
112921: PUSH
112922: EMPTY
112923: LIST
112924: LIST
112925: PPUSH
112926: CALL_OW 69
112930: NOT
112931: OR
112932: IFFALSE 108752
// end ;
112934: LD_VAR 0 2
112938: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
112939: LD_INT 0
112941: PPUSH
112942: PPUSH
112943: PPUSH
112944: PPUSH
112945: PPUSH
112946: PPUSH
// if not base or not mc_bases [ base ] or not solds then
112947: LD_VAR 0 1
112951: NOT
112952: PUSH
112953: LD_EXP 93
112957: PUSH
112958: LD_VAR 0 1
112962: ARRAY
112963: NOT
112964: OR
112965: PUSH
112966: LD_VAR 0 2
112970: NOT
112971: OR
112972: IFFALSE 112976
// exit ;
112974: GO 113530
// side := mc_sides [ base ] ;
112976: LD_ADDR_VAR 0 6
112980: PUSH
112981: LD_EXP 119
112985: PUSH
112986: LD_VAR 0 1
112990: ARRAY
112991: ST_TO_ADDR
// if not side then
112992: LD_VAR 0 6
112996: NOT
112997: IFFALSE 113001
// exit ;
112999: GO 113530
// for i in solds do
113001: LD_ADDR_VAR 0 7
113005: PUSH
113006: LD_VAR 0 2
113010: PUSH
113011: FOR_IN
113012: IFFALSE 113073
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
113014: LD_VAR 0 7
113018: PPUSH
113019: CALL_OW 310
113023: PPUSH
113024: CALL_OW 266
113028: PUSH
113029: LD_INT 32
113031: PUSH
113032: LD_INT 31
113034: PUSH
113035: EMPTY
113036: LIST
113037: LIST
113038: IN
113039: IFFALSE 113059
// solds := solds diff i else
113041: LD_ADDR_VAR 0 2
113045: PUSH
113046: LD_VAR 0 2
113050: PUSH
113051: LD_VAR 0 7
113055: DIFF
113056: ST_TO_ADDR
113057: GO 113071
// SetTag ( i , 18 ) ;
113059: LD_VAR 0 7
113063: PPUSH
113064: LD_INT 18
113066: PPUSH
113067: CALL_OW 109
113071: GO 113011
113073: POP
113074: POP
// if not solds then
113075: LD_VAR 0 2
113079: NOT
113080: IFFALSE 113084
// exit ;
113082: GO 113530
// repeat wait ( 0 0$2 ) ;
113084: LD_INT 70
113086: PPUSH
113087: CALL_OW 67
// enemy := mc_scan [ base ] ;
113091: LD_ADDR_VAR 0 4
113095: PUSH
113096: LD_EXP 116
113100: PUSH
113101: LD_VAR 0 1
113105: ARRAY
113106: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113107: LD_EXP 93
113111: PUSH
113112: LD_VAR 0 1
113116: ARRAY
113117: NOT
113118: PUSH
113119: LD_EXP 93
113123: PUSH
113124: LD_VAR 0 1
113128: ARRAY
113129: PUSH
113130: EMPTY
113131: EQUAL
113132: OR
113133: IFFALSE 113170
// begin for i in solds do
113135: LD_ADDR_VAR 0 7
113139: PUSH
113140: LD_VAR 0 2
113144: PUSH
113145: FOR_IN
113146: IFFALSE 113159
// ComStop ( i ) ;
113148: LD_VAR 0 7
113152: PPUSH
113153: CALL_OW 141
113157: GO 113145
113159: POP
113160: POP
// solds := [ ] ;
113161: LD_ADDR_VAR 0 2
113165: PUSH
113166: EMPTY
113167: ST_TO_ADDR
// exit ;
113168: GO 113530
// end ; for i in solds do
113170: LD_ADDR_VAR 0 7
113174: PUSH
113175: LD_VAR 0 2
113179: PUSH
113180: FOR_IN
113181: IFFALSE 113502
// begin if IsInUnit ( i ) then
113183: LD_VAR 0 7
113187: PPUSH
113188: CALL_OW 310
113192: IFFALSE 113203
// ComExitBuilding ( i ) ;
113194: LD_VAR 0 7
113198: PPUSH
113199: CALL_OW 122
// if GetLives ( i ) > 500 then
113203: LD_VAR 0 7
113207: PPUSH
113208: CALL_OW 256
113212: PUSH
113213: LD_INT 500
113215: GREATER
113216: IFFALSE 113269
// begin e := NearestUnitToUnit ( enemy , i ) ;
113218: LD_ADDR_VAR 0 5
113222: PUSH
113223: LD_VAR 0 4
113227: PPUSH
113228: LD_VAR 0 7
113232: PPUSH
113233: CALL_OW 74
113237: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
113238: LD_VAR 0 7
113242: PPUSH
113243: LD_VAR 0 5
113247: PPUSH
113248: CALL_OW 250
113252: PPUSH
113253: LD_VAR 0 5
113257: PPUSH
113258: CALL_OW 251
113262: PPUSH
113263: CALL_OW 114
// end else
113267: GO 113500
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
113269: LD_VAR 0 7
113273: PPUSH
113274: LD_EXP 93
113278: PUSH
113279: LD_VAR 0 1
113283: ARRAY
113284: PPUSH
113285: LD_INT 2
113287: PUSH
113288: LD_INT 30
113290: PUSH
113291: LD_INT 0
113293: PUSH
113294: EMPTY
113295: LIST
113296: LIST
113297: PUSH
113298: LD_INT 30
113300: PUSH
113301: LD_INT 1
113303: PUSH
113304: EMPTY
113305: LIST
113306: LIST
113307: PUSH
113308: LD_INT 30
113310: PUSH
113311: LD_INT 6
113313: PUSH
113314: EMPTY
113315: LIST
113316: LIST
113317: PUSH
113318: EMPTY
113319: LIST
113320: LIST
113321: LIST
113322: LIST
113323: PPUSH
113324: CALL_OW 72
113328: PPUSH
113329: LD_VAR 0 7
113333: PPUSH
113334: CALL_OW 74
113338: PPUSH
113339: CALL_OW 296
113343: PUSH
113344: LD_INT 10
113346: GREATER
113347: IFFALSE 113500
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
113349: LD_ADDR_VAR 0 8
113353: PUSH
113354: LD_EXP 93
113358: PUSH
113359: LD_VAR 0 1
113363: ARRAY
113364: PPUSH
113365: LD_INT 2
113367: PUSH
113368: LD_INT 30
113370: PUSH
113371: LD_INT 0
113373: PUSH
113374: EMPTY
113375: LIST
113376: LIST
113377: PUSH
113378: LD_INT 30
113380: PUSH
113381: LD_INT 1
113383: PUSH
113384: EMPTY
113385: LIST
113386: LIST
113387: PUSH
113388: LD_INT 30
113390: PUSH
113391: LD_INT 6
113393: PUSH
113394: EMPTY
113395: LIST
113396: LIST
113397: PUSH
113398: EMPTY
113399: LIST
113400: LIST
113401: LIST
113402: LIST
113403: PPUSH
113404: CALL_OW 72
113408: PPUSH
113409: LD_VAR 0 7
113413: PPUSH
113414: CALL_OW 74
113418: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
113419: LD_VAR 0 7
113423: PPUSH
113424: LD_VAR 0 8
113428: PPUSH
113429: CALL_OW 250
113433: PPUSH
113434: LD_INT 3
113436: PPUSH
113437: LD_INT 5
113439: PPUSH
113440: CALL_OW 272
113444: PPUSH
113445: LD_VAR 0 8
113449: PPUSH
113450: CALL_OW 251
113454: PPUSH
113455: LD_INT 3
113457: PPUSH
113458: LD_INT 5
113460: PPUSH
113461: CALL_OW 273
113465: PPUSH
113466: CALL_OW 111
// SetTag ( i , 0 ) ;
113470: LD_VAR 0 7
113474: PPUSH
113475: LD_INT 0
113477: PPUSH
113478: CALL_OW 109
// solds := solds diff i ;
113482: LD_ADDR_VAR 0 2
113486: PUSH
113487: LD_VAR 0 2
113491: PUSH
113492: LD_VAR 0 7
113496: DIFF
113497: ST_TO_ADDR
// continue ;
113498: GO 113180
// end ; end ;
113500: GO 113180
113502: POP
113503: POP
// until not solds or not enemy ;
113504: LD_VAR 0 2
113508: NOT
113509: PUSH
113510: LD_VAR 0 4
113514: NOT
113515: OR
113516: IFFALSE 113084
// MC_Reset ( base , 18 ) ;
113518: LD_VAR 0 1
113522: PPUSH
113523: LD_INT 18
113525: PPUSH
113526: CALL 25016 0 2
// end ;
113530: LD_VAR 0 3
113534: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
113535: LD_INT 0
113537: PPUSH
113538: PPUSH
113539: PPUSH
113540: PPUSH
113541: PPUSH
113542: PPUSH
113543: PPUSH
113544: PPUSH
113545: PPUSH
113546: PPUSH
113547: PPUSH
113548: PPUSH
113549: PPUSH
113550: PPUSH
113551: PPUSH
113552: PPUSH
113553: PPUSH
113554: PPUSH
113555: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
113556: LD_ADDR_VAR 0 12
113560: PUSH
113561: LD_EXP 93
113565: PUSH
113566: LD_VAR 0 1
113570: ARRAY
113571: PPUSH
113572: LD_INT 25
113574: PUSH
113575: LD_INT 3
113577: PUSH
113578: EMPTY
113579: LIST
113580: LIST
113581: PPUSH
113582: CALL_OW 72
113586: ST_TO_ADDR
// if mc_remote_driver [ base ] then
113587: LD_EXP 133
113591: PUSH
113592: LD_VAR 0 1
113596: ARRAY
113597: IFFALSE 113621
// mechs := mechs diff mc_remote_driver [ base ] ;
113599: LD_ADDR_VAR 0 12
113603: PUSH
113604: LD_VAR 0 12
113608: PUSH
113609: LD_EXP 133
113613: PUSH
113614: LD_VAR 0 1
113618: ARRAY
113619: DIFF
113620: ST_TO_ADDR
// for i in mechs do
113621: LD_ADDR_VAR 0 4
113625: PUSH
113626: LD_VAR 0 12
113630: PUSH
113631: FOR_IN
113632: IFFALSE 113667
// if GetTag ( i ) > 0 then
113634: LD_VAR 0 4
113638: PPUSH
113639: CALL_OW 110
113643: PUSH
113644: LD_INT 0
113646: GREATER
113647: IFFALSE 113665
// mechs := mechs diff i ;
113649: LD_ADDR_VAR 0 12
113653: PUSH
113654: LD_VAR 0 12
113658: PUSH
113659: LD_VAR 0 4
113663: DIFF
113664: ST_TO_ADDR
113665: GO 113631
113667: POP
113668: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113669: LD_ADDR_VAR 0 8
113673: PUSH
113674: LD_EXP 93
113678: PUSH
113679: LD_VAR 0 1
113683: ARRAY
113684: PPUSH
113685: LD_INT 2
113687: PUSH
113688: LD_INT 25
113690: PUSH
113691: LD_INT 1
113693: PUSH
113694: EMPTY
113695: LIST
113696: LIST
113697: PUSH
113698: LD_INT 25
113700: PUSH
113701: LD_INT 5
113703: PUSH
113704: EMPTY
113705: LIST
113706: LIST
113707: PUSH
113708: LD_INT 25
113710: PUSH
113711: LD_INT 8
113713: PUSH
113714: EMPTY
113715: LIST
113716: LIST
113717: PUSH
113718: LD_INT 25
113720: PUSH
113721: LD_INT 9
113723: PUSH
113724: EMPTY
113725: LIST
113726: LIST
113727: PUSH
113728: EMPTY
113729: LIST
113730: LIST
113731: LIST
113732: LIST
113733: LIST
113734: PPUSH
113735: CALL_OW 72
113739: ST_TO_ADDR
// if not defenders and not solds then
113740: LD_VAR 0 2
113744: NOT
113745: PUSH
113746: LD_VAR 0 8
113750: NOT
113751: AND
113752: IFFALSE 113756
// exit ;
113754: GO 115526
// depot_under_attack := false ;
113756: LD_ADDR_VAR 0 16
113760: PUSH
113761: LD_INT 0
113763: ST_TO_ADDR
// sold_defenders := [ ] ;
113764: LD_ADDR_VAR 0 17
113768: PUSH
113769: EMPTY
113770: ST_TO_ADDR
// if mechs then
113771: LD_VAR 0 12
113775: IFFALSE 113928
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
113777: LD_ADDR_VAR 0 4
113781: PUSH
113782: LD_VAR 0 2
113786: PPUSH
113787: LD_INT 21
113789: PUSH
113790: LD_INT 2
113792: PUSH
113793: EMPTY
113794: LIST
113795: LIST
113796: PPUSH
113797: CALL_OW 72
113801: PUSH
113802: FOR_IN
113803: IFFALSE 113926
// begin if GetTag ( i ) <> 20 then
113805: LD_VAR 0 4
113809: PPUSH
113810: CALL_OW 110
113814: PUSH
113815: LD_INT 20
113817: NONEQUAL
113818: IFFALSE 113832
// SetTag ( i , 20 ) ;
113820: LD_VAR 0 4
113824: PPUSH
113825: LD_INT 20
113827: PPUSH
113828: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
113832: LD_VAR 0 4
113836: PPUSH
113837: CALL_OW 263
113841: PUSH
113842: LD_INT 1
113844: EQUAL
113845: PUSH
113846: LD_VAR 0 4
113850: PPUSH
113851: CALL_OW 311
113855: NOT
113856: AND
113857: IFFALSE 113924
// begin un := mechs [ 1 ] ;
113859: LD_ADDR_VAR 0 10
113863: PUSH
113864: LD_VAR 0 12
113868: PUSH
113869: LD_INT 1
113871: ARRAY
113872: ST_TO_ADDR
// ComExit ( un ) ;
113873: LD_VAR 0 10
113877: PPUSH
113878: CALL 88613 0 1
// AddComEnterUnit ( un , i ) ;
113882: LD_VAR 0 10
113886: PPUSH
113887: LD_VAR 0 4
113891: PPUSH
113892: CALL_OW 180
// SetTag ( un , 19 ) ;
113896: LD_VAR 0 10
113900: PPUSH
113901: LD_INT 19
113903: PPUSH
113904: CALL_OW 109
// mechs := mechs diff un ;
113908: LD_ADDR_VAR 0 12
113912: PUSH
113913: LD_VAR 0 12
113917: PUSH
113918: LD_VAR 0 10
113922: DIFF
113923: ST_TO_ADDR
// end ; end ;
113924: GO 113802
113926: POP
113927: POP
// if solds then
113928: LD_VAR 0 8
113932: IFFALSE 113991
// for i in solds do
113934: LD_ADDR_VAR 0 4
113938: PUSH
113939: LD_VAR 0 8
113943: PUSH
113944: FOR_IN
113945: IFFALSE 113989
// if not GetTag ( i ) then
113947: LD_VAR 0 4
113951: PPUSH
113952: CALL_OW 110
113956: NOT
113957: IFFALSE 113987
// begin defenders := defenders union i ;
113959: LD_ADDR_VAR 0 2
113963: PUSH
113964: LD_VAR 0 2
113968: PUSH
113969: LD_VAR 0 4
113973: UNION
113974: ST_TO_ADDR
// SetTag ( i , 18 ) ;
113975: LD_VAR 0 4
113979: PPUSH
113980: LD_INT 18
113982: PPUSH
113983: CALL_OW 109
// end ;
113987: GO 113944
113989: POP
113990: POP
// repeat wait ( 0 0$2 ) ;
113991: LD_INT 70
113993: PPUSH
113994: CALL_OW 67
// enemy := mc_scan [ base ] ;
113998: LD_ADDR_VAR 0 21
114002: PUSH
114003: LD_EXP 116
114007: PUSH
114008: LD_VAR 0 1
114012: ARRAY
114013: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114014: LD_EXP 93
114018: PUSH
114019: LD_VAR 0 1
114023: ARRAY
114024: NOT
114025: PUSH
114026: LD_EXP 93
114030: PUSH
114031: LD_VAR 0 1
114035: ARRAY
114036: PUSH
114037: EMPTY
114038: EQUAL
114039: OR
114040: IFFALSE 114077
// begin for i in defenders do
114042: LD_ADDR_VAR 0 4
114046: PUSH
114047: LD_VAR 0 2
114051: PUSH
114052: FOR_IN
114053: IFFALSE 114066
// ComStop ( i ) ;
114055: LD_VAR 0 4
114059: PPUSH
114060: CALL_OW 141
114064: GO 114052
114066: POP
114067: POP
// defenders := [ ] ;
114068: LD_ADDR_VAR 0 2
114072: PUSH
114073: EMPTY
114074: ST_TO_ADDR
// exit ;
114075: GO 115526
// end ; for i in defenders do
114077: LD_ADDR_VAR 0 4
114081: PUSH
114082: LD_VAR 0 2
114086: PUSH
114087: FOR_IN
114088: IFFALSE 114986
// begin e := NearestUnitToUnit ( enemy , i ) ;
114090: LD_ADDR_VAR 0 13
114094: PUSH
114095: LD_VAR 0 21
114099: PPUSH
114100: LD_VAR 0 4
114104: PPUSH
114105: CALL_OW 74
114109: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114110: LD_ADDR_VAR 0 7
114114: PUSH
114115: LD_EXP 93
114119: PUSH
114120: LD_VAR 0 1
114124: ARRAY
114125: PPUSH
114126: LD_INT 2
114128: PUSH
114129: LD_INT 30
114131: PUSH
114132: LD_INT 0
114134: PUSH
114135: EMPTY
114136: LIST
114137: LIST
114138: PUSH
114139: LD_INT 30
114141: PUSH
114142: LD_INT 1
114144: PUSH
114145: EMPTY
114146: LIST
114147: LIST
114148: PUSH
114149: EMPTY
114150: LIST
114151: LIST
114152: LIST
114153: PPUSH
114154: CALL_OW 72
114158: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
114159: LD_ADDR_VAR 0 16
114163: PUSH
114164: LD_VAR 0 7
114168: NOT
114169: PUSH
114170: LD_VAR 0 7
114174: PPUSH
114175: LD_INT 3
114177: PUSH
114178: LD_INT 24
114180: PUSH
114181: LD_INT 600
114183: PUSH
114184: EMPTY
114185: LIST
114186: LIST
114187: PUSH
114188: EMPTY
114189: LIST
114190: LIST
114191: PPUSH
114192: CALL_OW 72
114196: OR
114197: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
114198: LD_VAR 0 4
114202: PPUSH
114203: CALL_OW 247
114207: PUSH
114208: LD_INT 2
114210: DOUBLE
114211: EQUAL
114212: IFTRUE 114216
114214: GO 114612
114216: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
114217: LD_VAR 0 4
114221: PPUSH
114222: CALL_OW 256
114226: PUSH
114227: LD_INT 1000
114229: EQUAL
114230: PUSH
114231: LD_VAR 0 4
114235: PPUSH
114236: LD_VAR 0 13
114240: PPUSH
114241: CALL_OW 296
114245: PUSH
114246: LD_INT 40
114248: LESS
114249: PUSH
114250: LD_VAR 0 13
114254: PPUSH
114255: LD_EXP 118
114259: PUSH
114260: LD_VAR 0 1
114264: ARRAY
114265: PPUSH
114266: CALL_OW 308
114270: OR
114271: AND
114272: IFFALSE 114394
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
114274: LD_VAR 0 4
114278: PPUSH
114279: CALL_OW 262
114283: PUSH
114284: LD_INT 1
114286: EQUAL
114287: PUSH
114288: LD_VAR 0 4
114292: PPUSH
114293: CALL_OW 261
114297: PUSH
114298: LD_INT 30
114300: LESS
114301: AND
114302: PUSH
114303: LD_VAR 0 7
114307: AND
114308: IFFALSE 114378
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
114310: LD_VAR 0 4
114314: PPUSH
114315: LD_VAR 0 7
114319: PPUSH
114320: LD_VAR 0 4
114324: PPUSH
114325: CALL_OW 74
114329: PPUSH
114330: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
114334: LD_VAR 0 4
114338: PPUSH
114339: LD_VAR 0 7
114343: PPUSH
114344: LD_VAR 0 4
114348: PPUSH
114349: CALL_OW 74
114353: PPUSH
114354: CALL_OW 296
114358: PUSH
114359: LD_INT 6
114361: LESS
114362: IFFALSE 114376
// SetFuel ( i , 100 ) ;
114364: LD_VAR 0 4
114368: PPUSH
114369: LD_INT 100
114371: PPUSH
114372: CALL_OW 240
// end else
114376: GO 114392
// ComAttackUnit ( i , e ) ;
114378: LD_VAR 0 4
114382: PPUSH
114383: LD_VAR 0 13
114387: PPUSH
114388: CALL_OW 115
// end else
114392: GO 114495
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
114394: LD_VAR 0 13
114398: PPUSH
114399: LD_EXP 118
114403: PUSH
114404: LD_VAR 0 1
114408: ARRAY
114409: PPUSH
114410: CALL_OW 308
114414: NOT
114415: PUSH
114416: LD_VAR 0 4
114420: PPUSH
114421: LD_VAR 0 13
114425: PPUSH
114426: CALL_OW 296
114430: PUSH
114431: LD_INT 40
114433: GREATEREQUAL
114434: AND
114435: PUSH
114436: LD_VAR 0 4
114440: PPUSH
114441: CALL_OW 256
114445: PUSH
114446: LD_INT 650
114448: LESSEQUAL
114449: OR
114450: PUSH
114451: LD_VAR 0 4
114455: PPUSH
114456: LD_EXP 117
114460: PUSH
114461: LD_VAR 0 1
114465: ARRAY
114466: PPUSH
114467: CALL_OW 308
114471: NOT
114472: AND
114473: IFFALSE 114495
// ComMoveToArea ( i , mc_parking [ base ] ) ;
114475: LD_VAR 0 4
114479: PPUSH
114480: LD_EXP 117
114484: PUSH
114485: LD_VAR 0 1
114489: ARRAY
114490: PPUSH
114491: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
114495: LD_VAR 0 4
114499: PPUSH
114500: CALL_OW 256
114504: PUSH
114505: LD_INT 1000
114507: LESS
114508: PUSH
114509: LD_VAR 0 4
114513: PPUSH
114514: CALL_OW 263
114518: PUSH
114519: LD_INT 1
114521: EQUAL
114522: AND
114523: PUSH
114524: LD_VAR 0 4
114528: PPUSH
114529: CALL_OW 311
114533: AND
114534: PUSH
114535: LD_VAR 0 4
114539: PPUSH
114540: LD_EXP 117
114544: PUSH
114545: LD_VAR 0 1
114549: ARRAY
114550: PPUSH
114551: CALL_OW 308
114555: AND
114556: IFFALSE 114610
// begin mech := IsDrivenBy ( i ) ;
114558: LD_ADDR_VAR 0 9
114562: PUSH
114563: LD_VAR 0 4
114567: PPUSH
114568: CALL_OW 311
114572: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
114573: LD_VAR 0 9
114577: PPUSH
114578: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
114582: LD_VAR 0 9
114586: PPUSH
114587: LD_VAR 0 4
114591: PPUSH
114592: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
114596: LD_VAR 0 9
114600: PPUSH
114601: LD_VAR 0 4
114605: PPUSH
114606: CALL_OW 180
// end ; end ; unit_human :
114610: GO 114957
114612: LD_INT 1
114614: DOUBLE
114615: EQUAL
114616: IFTRUE 114620
114618: GO 114956
114620: POP
// begin b := IsInUnit ( i ) ;
114621: LD_ADDR_VAR 0 18
114625: PUSH
114626: LD_VAR 0 4
114630: PPUSH
114631: CALL_OW 310
114635: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
114636: LD_ADDR_VAR 0 19
114640: PUSH
114641: LD_VAR 0 18
114645: NOT
114646: PUSH
114647: LD_VAR 0 18
114651: PPUSH
114652: CALL_OW 266
114656: PUSH
114657: LD_INT 32
114659: PUSH
114660: LD_INT 31
114662: PUSH
114663: EMPTY
114664: LIST
114665: LIST
114666: IN
114667: OR
114668: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
114669: LD_VAR 0 18
114673: PPUSH
114674: CALL_OW 266
114678: PUSH
114679: LD_INT 5
114681: EQUAL
114682: PUSH
114683: LD_VAR 0 4
114687: PPUSH
114688: CALL_OW 257
114692: PUSH
114693: LD_INT 1
114695: PUSH
114696: LD_INT 2
114698: PUSH
114699: LD_INT 3
114701: PUSH
114702: LD_INT 4
114704: PUSH
114705: EMPTY
114706: LIST
114707: LIST
114708: LIST
114709: LIST
114710: IN
114711: AND
114712: IFFALSE 114749
// begin class := AllowSpecClass ( i ) ;
114714: LD_ADDR_VAR 0 20
114718: PUSH
114719: LD_VAR 0 4
114723: PPUSH
114724: CALL 53274 0 1
114728: ST_TO_ADDR
// if class then
114729: LD_VAR 0 20
114733: IFFALSE 114749
// ComChangeProfession ( i , class ) ;
114735: LD_VAR 0 4
114739: PPUSH
114740: LD_VAR 0 20
114744: PPUSH
114745: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
114749: LD_VAR 0 16
114753: PUSH
114754: LD_VAR 0 2
114758: PPUSH
114759: LD_INT 21
114761: PUSH
114762: LD_INT 2
114764: PUSH
114765: EMPTY
114766: LIST
114767: LIST
114768: PPUSH
114769: CALL_OW 72
114773: PUSH
114774: LD_INT 1
114776: LESSEQUAL
114777: OR
114778: PUSH
114779: LD_VAR 0 19
114783: AND
114784: PUSH
114785: LD_VAR 0 4
114789: PUSH
114790: LD_VAR 0 17
114794: IN
114795: NOT
114796: AND
114797: IFFALSE 114890
// begin if b then
114799: LD_VAR 0 18
114803: IFFALSE 114852
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
114805: LD_VAR 0 18
114809: PPUSH
114810: LD_VAR 0 21
114814: PPUSH
114815: LD_VAR 0 18
114819: PPUSH
114820: CALL_OW 74
114824: PPUSH
114825: CALL_OW 296
114829: PUSH
114830: LD_INT 10
114832: LESS
114833: PUSH
114834: LD_VAR 0 18
114838: PPUSH
114839: CALL_OW 461
114843: PUSH
114844: LD_INT 7
114846: NONEQUAL
114847: AND
114848: IFFALSE 114852
// continue ;
114850: GO 114087
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
114852: LD_ADDR_VAR 0 17
114856: PUSH
114857: LD_VAR 0 17
114861: PPUSH
114862: LD_VAR 0 17
114866: PUSH
114867: LD_INT 1
114869: PLUS
114870: PPUSH
114871: LD_VAR 0 4
114875: PPUSH
114876: CALL_OW 1
114880: ST_TO_ADDR
// ComExitBuilding ( i ) ;
114881: LD_VAR 0 4
114885: PPUSH
114886: CALL_OW 122
// end ; if sold_defenders then
114890: LD_VAR 0 17
114894: IFFALSE 114954
// if i in sold_defenders then
114896: LD_VAR 0 4
114900: PUSH
114901: LD_VAR 0 17
114905: IN
114906: IFFALSE 114954
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
114908: LD_VAR 0 4
114912: PPUSH
114913: CALL_OW 314
114917: NOT
114918: PUSH
114919: LD_VAR 0 4
114923: PPUSH
114924: LD_VAR 0 13
114928: PPUSH
114929: CALL_OW 296
114933: PUSH
114934: LD_INT 30
114936: LESS
114937: AND
114938: IFFALSE 114954
// ComAttackUnit ( i , e ) ;
114940: LD_VAR 0 4
114944: PPUSH
114945: LD_VAR 0 13
114949: PPUSH
114950: CALL_OW 115
// end ; end ; end ;
114954: GO 114957
114956: POP
// if IsDead ( i ) then
114957: LD_VAR 0 4
114961: PPUSH
114962: CALL_OW 301
114966: IFFALSE 114984
// defenders := defenders diff i ;
114968: LD_ADDR_VAR 0 2
114972: PUSH
114973: LD_VAR 0 2
114977: PUSH
114978: LD_VAR 0 4
114982: DIFF
114983: ST_TO_ADDR
// end ;
114984: GO 114087
114986: POP
114987: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
114988: LD_VAR 0 21
114992: NOT
114993: PUSH
114994: LD_VAR 0 2
114998: NOT
114999: OR
115000: PUSH
115001: LD_EXP 93
115005: PUSH
115006: LD_VAR 0 1
115010: ARRAY
115011: NOT
115012: OR
115013: IFFALSE 113991
// MC_Reset ( base , 18 ) ;
115015: LD_VAR 0 1
115019: PPUSH
115020: LD_INT 18
115022: PPUSH
115023: CALL 25016 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115027: LD_ADDR_VAR 0 2
115031: PUSH
115032: LD_VAR 0 2
115036: PUSH
115037: LD_VAR 0 2
115041: PPUSH
115042: LD_INT 2
115044: PUSH
115045: LD_INT 25
115047: PUSH
115048: LD_INT 1
115050: PUSH
115051: EMPTY
115052: LIST
115053: LIST
115054: PUSH
115055: LD_INT 25
115057: PUSH
115058: LD_INT 5
115060: PUSH
115061: EMPTY
115062: LIST
115063: LIST
115064: PUSH
115065: LD_INT 25
115067: PUSH
115068: LD_INT 8
115070: PUSH
115071: EMPTY
115072: LIST
115073: LIST
115074: PUSH
115075: LD_INT 25
115077: PUSH
115078: LD_INT 9
115080: PUSH
115081: EMPTY
115082: LIST
115083: LIST
115084: PUSH
115085: EMPTY
115086: LIST
115087: LIST
115088: LIST
115089: LIST
115090: LIST
115091: PPUSH
115092: CALL_OW 72
115096: DIFF
115097: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
115098: LD_VAR 0 21
115102: NOT
115103: PUSH
115104: LD_VAR 0 2
115108: PPUSH
115109: LD_INT 21
115111: PUSH
115112: LD_INT 2
115114: PUSH
115115: EMPTY
115116: LIST
115117: LIST
115118: PPUSH
115119: CALL_OW 72
115123: AND
115124: IFFALSE 115462
// begin tmp := FilterByTag ( defenders , 19 ) ;
115126: LD_ADDR_VAR 0 11
115130: PUSH
115131: LD_VAR 0 2
115135: PPUSH
115136: LD_INT 19
115138: PPUSH
115139: CALL 85743 0 2
115143: ST_TO_ADDR
// if tmp then
115144: LD_VAR 0 11
115148: IFFALSE 115218
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
115150: LD_ADDR_VAR 0 11
115154: PUSH
115155: LD_VAR 0 11
115159: PPUSH
115160: LD_INT 25
115162: PUSH
115163: LD_INT 3
115165: PUSH
115166: EMPTY
115167: LIST
115168: LIST
115169: PPUSH
115170: CALL_OW 72
115174: ST_TO_ADDR
// if tmp then
115175: LD_VAR 0 11
115179: IFFALSE 115218
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
115181: LD_ADDR_EXP 105
115185: PUSH
115186: LD_EXP 105
115190: PPUSH
115191: LD_VAR 0 1
115195: PPUSH
115196: LD_EXP 105
115200: PUSH
115201: LD_VAR 0 1
115205: ARRAY
115206: PUSH
115207: LD_VAR 0 11
115211: UNION
115212: PPUSH
115213: CALL_OW 1
115217: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
115218: LD_VAR 0 1
115222: PPUSH
115223: LD_INT 19
115225: PPUSH
115226: CALL 25016 0 2
// repeat wait ( 0 0$1 ) ;
115230: LD_INT 35
115232: PPUSH
115233: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115237: LD_EXP 93
115241: PUSH
115242: LD_VAR 0 1
115246: ARRAY
115247: NOT
115248: PUSH
115249: LD_EXP 93
115253: PUSH
115254: LD_VAR 0 1
115258: ARRAY
115259: PUSH
115260: EMPTY
115261: EQUAL
115262: OR
115263: IFFALSE 115300
// begin for i in defenders do
115265: LD_ADDR_VAR 0 4
115269: PUSH
115270: LD_VAR 0 2
115274: PUSH
115275: FOR_IN
115276: IFFALSE 115289
// ComStop ( i ) ;
115278: LD_VAR 0 4
115282: PPUSH
115283: CALL_OW 141
115287: GO 115275
115289: POP
115290: POP
// defenders := [ ] ;
115291: LD_ADDR_VAR 0 2
115295: PUSH
115296: EMPTY
115297: ST_TO_ADDR
// exit ;
115298: GO 115526
// end ; for i in defenders do
115300: LD_ADDR_VAR 0 4
115304: PUSH
115305: LD_VAR 0 2
115309: PUSH
115310: FOR_IN
115311: IFFALSE 115400
// begin if not IsInArea ( i , mc_parking [ base ] ) then
115313: LD_VAR 0 4
115317: PPUSH
115318: LD_EXP 117
115322: PUSH
115323: LD_VAR 0 1
115327: ARRAY
115328: PPUSH
115329: CALL_OW 308
115333: NOT
115334: IFFALSE 115358
// ComMoveToArea ( i , mc_parking [ base ] ) else
115336: LD_VAR 0 4
115340: PPUSH
115341: LD_EXP 117
115345: PUSH
115346: LD_VAR 0 1
115350: ARRAY
115351: PPUSH
115352: CALL_OW 113
115356: GO 115398
// if GetControl ( i ) = control_manual then
115358: LD_VAR 0 4
115362: PPUSH
115363: CALL_OW 263
115367: PUSH
115368: LD_INT 1
115370: EQUAL
115371: IFFALSE 115398
// if IsDrivenBy ( i ) then
115373: LD_VAR 0 4
115377: PPUSH
115378: CALL_OW 311
115382: IFFALSE 115398
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
115384: LD_VAR 0 4
115388: PPUSH
115389: CALL_OW 311
115393: PPUSH
115394: CALL_OW 121
// end ;
115398: GO 115310
115400: POP
115401: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
115402: LD_VAR 0 2
115406: PPUSH
115407: LD_INT 95
115409: PUSH
115410: LD_EXP 117
115414: PUSH
115415: LD_VAR 0 1
115419: ARRAY
115420: PUSH
115421: EMPTY
115422: LIST
115423: LIST
115424: PPUSH
115425: CALL_OW 72
115429: PUSH
115430: LD_VAR 0 2
115434: EQUAL
115435: PUSH
115436: LD_EXP 116
115440: PUSH
115441: LD_VAR 0 1
115445: ARRAY
115446: OR
115447: PUSH
115448: LD_EXP 93
115452: PUSH
115453: LD_VAR 0 1
115457: ARRAY
115458: NOT
115459: OR
115460: IFFALSE 115230
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
115462: LD_ADDR_EXP 115
115466: PUSH
115467: LD_EXP 115
115471: PPUSH
115472: LD_VAR 0 1
115476: PPUSH
115477: LD_VAR 0 2
115481: PPUSH
115482: LD_INT 21
115484: PUSH
115485: LD_INT 2
115487: PUSH
115488: EMPTY
115489: LIST
115490: LIST
115491: PPUSH
115492: CALL_OW 72
115496: PPUSH
115497: CALL_OW 1
115501: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
115502: LD_VAR 0 1
115506: PPUSH
115507: LD_INT 19
115509: PPUSH
115510: CALL 25016 0 2
// MC_Reset ( base , 20 ) ;
115514: LD_VAR 0 1
115518: PPUSH
115519: LD_INT 20
115521: PPUSH
115522: CALL 25016 0 2
// end ; end_of_file
115526: LD_VAR 0 3
115530: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
115531: LD_VAR 0 1
115535: PUSH
115536: LD_INT 200
115538: DOUBLE
115539: GREATEREQUAL
115540: IFFALSE 115548
115542: LD_INT 299
115544: DOUBLE
115545: LESSEQUAL
115546: IFTRUE 115550
115548: GO 115582
115550: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
115551: LD_VAR 0 1
115555: PPUSH
115556: LD_VAR 0 2
115560: PPUSH
115561: LD_VAR 0 3
115565: PPUSH
115566: LD_VAR 0 4
115570: PPUSH
115571: LD_VAR 0 5
115575: PPUSH
115576: CALL 104347 0 5
115580: GO 115659
115582: LD_INT 300
115584: DOUBLE
115585: GREATEREQUAL
115586: IFFALSE 115594
115588: LD_INT 399
115590: DOUBLE
115591: LESSEQUAL
115592: IFTRUE 115596
115594: GO 115658
115596: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
115597: LD_VAR 0 1
115601: PPUSH
115602: LD_VAR 0 2
115606: PPUSH
115607: LD_VAR 0 3
115611: PPUSH
115612: LD_VAR 0 4
115616: PPUSH
115617: LD_VAR 0 5
115621: PPUSH
115622: LD_VAR 0 6
115626: PPUSH
115627: LD_VAR 0 7
115631: PPUSH
115632: LD_VAR 0 8
115636: PPUSH
115637: LD_VAR 0 9
115641: PPUSH
115642: LD_VAR 0 10
115646: PPUSH
115647: LD_VAR 0 11
115651: PPUSH
115652: CALL 102235 0 11
115656: GO 115659
115658: POP
// end ;
115659: PPOPN 11
115661: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
115662: LD_VAR 0 1
115666: PPUSH
115667: LD_VAR 0 2
115671: PPUSH
115672: LD_VAR 0 3
115676: PPUSH
115677: LD_VAR 0 4
115681: PPUSH
115682: LD_VAR 0 5
115686: PPUSH
115687: CALL 104329 0 5
// end ; end_of_file
115691: PPOPN 5
115693: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
115694: LD_VAR 0 1
115698: PPUSH
115699: LD_VAR 0 2
115703: PPUSH
115704: LD_VAR 0 3
115708: PPUSH
115709: LD_VAR 0 4
115713: PPUSH
115714: LD_VAR 0 5
115718: PPUSH
115719: LD_VAR 0 6
115723: PPUSH
115724: CALL 91043 0 6
// end ;
115728: PPOPN 6
115730: END
