// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 19563 0 0
// InitNature ;
  19: CALL 16235 0 0
// InitArtifact ;
  23: CALL 16848 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4072 0 0
// PrepareAlliance ;
  44: CALL 1209 0 0
// PrepareArabian ;
  48: CALL 5802 0 0
// PrepareRussian ;
  52: CALL 7753 0 0
// PrepareLegion ;
  56: CALL 6196 0 0
// Action ;
  60: CALL 10248 0 0
// MC_Start ( ) ;
  64: CALL 21675 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// end ;
 168: LD_VAR 0 1
 172: RET
// export function CustomInitMacro ( ) ; begin
 173: LD_INT 0
 175: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 176: LD_ADDR_EXP 98
 180: PUSH
 181: LD_INT 26
 183: PUSH
 184: LD_INT 1
 186: PUSH
 187: LD_INT 4
 189: PUSH
 190: LD_INT 8
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 199: LD_ADDR_EXP 99
 203: PUSH
 204: LD_INT 27
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 7
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: LIST
 221: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 222: LD_INT 1
 224: PPUSH
 225: LD_INT 6
 227: PUSH
 228: LD_INT 7
 230: PUSH
 231: LD_INT 9
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: PPUSH
 245: LD_INT 28
 247: PPUSH
 248: CALL 42780 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 252: LD_INT 1
 254: PPUSH
 255: LD_INT 10
 257: PUSH
 258: LD_INT 11
 260: PUSH
 261: LD_INT 13
 263: PUSH
 264: LD_INT 15
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: PPUSH
 273: CALL 43840 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 29
 282: PUSH
 283: EMPTY
 284: LIST
 285: PPUSH
 286: CALL 43933 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 290: LD_ADDR_EXP 103
 294: PUSH
 295: LD_EXP 103
 299: PPUSH
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 22
 305: PUSH
 306: LD_INT 2
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: PUSH
 313: LD_INT 25
 315: PUSH
 316: LD_INT 15
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: PPUSH
 327: CALL_OW 69
 331: PPUSH
 332: CALL_OW 1
 336: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 337: LD_INT 1
 339: PPUSH
 340: LD_INT 13
 342: PUSH
 343: LD_INT 2
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 31
 351: PUSH
 352: EMPTY
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: PUSH
 358: LD_INT 13
 360: PUSH
 361: LD_INT 2
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: LD_INT 31
 369: PUSH
 370: EMPTY
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 13
 378: PUSH
 379: LD_INT 1
 381: PUSH
 382: LD_INT 1
 384: PUSH
 385: LD_INT 28
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: PUSH
 394: LD_INT 13
 396: PUSH
 397: LD_INT 1
 399: PUSH
 400: LD_INT 1
 402: PUSH
 403: LD_INT 28
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: PUSH
 412: LD_INT 13
 414: PUSH
 415: LD_INT 1
 417: PUSH
 418: LD_INT 1
 420: PUSH
 421: LD_INT 28
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 13
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: LD_INT 28
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PPUSH
 456: CALL 43098 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 460: LD_INT 1
 462: PPUSH
 463: LD_INT 4
 465: PPUSH
 466: CALL 43283 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 470: LD_INT 2
 472: PPUSH
 473: LD_INT 10
 475: PUSH
 476: LD_INT 11
 478: PUSH
 479: LD_INT 12
 481: PUSH
 482: LD_INT 14
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL 43840 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 495: LD_INT 2
 497: PPUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: PPUSH
 504: CALL 43933 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 508: LD_INT 2
 510: PPUSH
 511: LD_INT 21
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 51
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 22
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: LD_INT 3
 537: PUSH
 538: LD_INT 52
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 22
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: LD_INT 3
 555: PUSH
 556: LD_INT 52
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 24
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: LD_INT 3
 573: PUSH
 574: LD_INT 47
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 24
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 3
 591: PUSH
 592: LD_INT 47
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: LD_INT 24
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: LD_INT 47
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: PUSH
 619: LD_INT 24
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 3
 627: PUSH
 628: LD_INT 47
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 24
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 47
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PPUSH
 665: CALL 43098 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 669: LD_INT 2
 671: PPUSH
 672: LD_INT 5
 674: PPUSH
 675: CALL 43283 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 0
 684: PPUSH
 685: CALL 43713 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 689: LD_INT 3
 691: PPUSH
 692: LD_INT 10
 694: PUSH
 695: LD_INT 12
 697: PUSH
 698: LD_INT 15
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_OWVAR 67
 710: ARRAY
 711: PPUSH
 712: LD_INT 24
 714: PPUSH
 715: CALL 42780 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 719: LD_INT 3
 721: PPUSH
 722: LD_INT 10
 724: PUSH
 725: LD_INT 11
 727: PUSH
 728: LD_INT 13
 730: PUSH
 731: LD_INT 15
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: PPUSH
 740: CALL 43840 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 744: LD_INT 3
 746: PPUSH
 747: LD_INT 13
 749: PUSH
 750: EMPTY
 751: LIST
 752: PPUSH
 753: CALL 43933 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 757: LD_ADDR_EXP 103
 761: PUSH
 762: LD_EXP 103
 766: PPUSH
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 22
 772: PUSH
 773: LD_INT 8
 775: PUSH
 776: EMPTY
 777: LIST
 778: LIST
 779: PUSH
 780: LD_INT 25
 782: PUSH
 783: LD_INT 15
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: PPUSH
 794: CALL_OW 69
 798: PPUSH
 799: CALL_OW 1
 803: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 804: LD_INT 3
 806: PPUSH
 807: LD_INT 13
 809: PUSH
 810: LD_INT 2
 812: PUSH
 813: LD_INT 1
 815: PUSH
 816: LD_INT 31
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 13
 827: PUSH
 828: LD_INT 2
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 31
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 13
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 2
 851: PUSH
 852: LD_INT 32
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: LD_INT 14
 863: PUSH
 864: LD_INT 1
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 28
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 14
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 28
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: PUSH
 897: LD_INT 14
 899: PUSH
 900: LD_INT 1
 902: PUSH
 903: LD_INT 1
 905: PUSH
 906: LD_INT 28
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 14
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: LD_INT 1
 923: PUSH
 924: LD_INT 28
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 43098 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 4
 951: PPUSH
 952: CALL 43283 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 956: LD_INT 4
 958: PPUSH
 959: LD_INT 10
 961: PUSH
 962: LD_INT 12
 964: PUSH
 965: LD_INT 11
 967: PUSH
 968: LD_INT 15
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL 43840 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 981: LD_INT 4
 983: PPUSH
 984: LD_INT 33
 986: PUSH
 987: EMPTY
 988: LIST
 989: PPUSH
 990: CALL 43933 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 994: LD_INT 4
 996: PPUSH
 997: LD_INT 5
 999: PUSH
1000: LD_INT 6
1002: PUSH
1003: LD_INT 7
1005: PUSH
1006: LD_INT 9
1008: PUSH
1009: LD_INT 10
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PPUSH
1019: CALL 44251 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1023: LD_INT 4
1025: PPUSH
1026: LD_INT 54
1028: PPUSH
1029: LD_INT 85
1031: PPUSH
1032: LD_INT 2
1034: PPUSH
1035: LD_INT 25
1037: PUSH
1038: LD_INT 16
1040: PUSH
1041: LD_INT 17
1043: PUSH
1044: LD_INT 18
1046: PUSH
1047: LD_INT 22
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL 44045 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1061: LD_INT 4
1063: PPUSH
1064: LD_INT 5
1066: PUSH
1067: LD_INT 1
1069: PUSH
1070: LD_INT 1
1072: PUSH
1073: LD_INT 7
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 5
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: LD_INT 1
1090: PUSH
1091: LD_INT 6
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 5
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 1
1108: PUSH
1109: LD_INT 7
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_INT 5
1120: PUSH
1121: LD_INT 1
1123: PUSH
1124: LD_INT 1
1126: PUSH
1127: LD_INT 6
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 5
1138: PUSH
1139: LD_INT 1
1141: PUSH
1142: LD_INT 3
1144: PUSH
1145: LD_INT 12
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PUSH
1154: LD_INT 3
1156: PUSH
1157: LD_INT 1
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: LD_INT 13
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PPUSH
1180: CALL 43098 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1184: LD_INT 4
1186: PPUSH
1187: LD_INT 4
1189: PPUSH
1190: CALL 43283 0 2
// MC_SetTame ( 4 , powellApe ) ;
1194: LD_INT 4
1196: PPUSH
1197: LD_INT 11
1199: PPUSH
1200: CALL 43664 0 2
// end ; end_of_file
1204: LD_VAR 0 1
1208: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1209: LD_INT 0
1211: PPUSH
1212: PPUSH
1213: PPUSH
1214: PPUSH
1215: PPUSH
// uc_side := 7 ;
1216: LD_ADDR_OWVAR 20
1220: PUSH
1221: LD_INT 7
1223: ST_TO_ADDR
// tmp := [ ] ;
1224: LD_ADDR_VAR 0 5
1228: PUSH
1229: EMPTY
1230: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1231: LD_ADDR_EXP 12
1235: PUSH
1236: LD_STRING JMM
1238: PPUSH
1239: LD_EXP 1
1243: NOT
1244: PPUSH
1245: LD_STRING 14a_
1247: PPUSH
1248: CALL 49356 0 3
1252: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1253: LD_ADDR_EXP 44
1257: PUSH
1258: LD_STRING Burlak
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 14a_
1269: PPUSH
1270: CALL 49356 0 3
1274: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1275: LD_ADDR_EXP 27
1279: PUSH
1280: LD_STRING Joan
1282: PPUSH
1283: LD_EXP 1
1287: NOT
1288: PPUSH
1289: LD_STRING 13a_
1291: PPUSH
1292: CALL 49356 0 3
1296: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1297: LD_ADDR_EXP 13
1301: PUSH
1302: LD_STRING Roth
1304: PPUSH
1305: LD_EXP 1
1309: NOT
1310: PPUSH
1311: LD_STRING 13a_
1313: PPUSH
1314: CALL 49356 0 3
1318: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1319: LD_ADDR_EXP 30
1323: PUSH
1324: LD_STRING Gossudarov
1326: PPUSH
1327: LD_EXP 1
1331: NOT
1332: PPUSH
1333: LD_STRING 13a_
1335: PPUSH
1336: CALL 49356 0 3
1340: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1341: LD_ADDR_EXP 28
1345: PUSH
1346: LD_STRING DeltaDoctor
1348: PPUSH
1349: LD_EXP 1
1353: NOT
1354: PPUSH
1355: LD_STRING 13a_
1357: PPUSH
1358: CALL 49356 0 3
1362: ST_TO_ADDR
// if DeltaDoctor then
1363: LD_EXP 28
1367: IFFALSE 1385
// tmp := tmp ^ DeltaDoctor ;
1369: LD_ADDR_VAR 0 5
1373: PUSH
1374: LD_VAR 0 5
1378: PUSH
1379: LD_EXP 28
1383: ADD
1384: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1385: LD_ADDR_EXP 26
1389: PUSH
1390: LD_STRING Simms
1392: PPUSH
1393: LD_EXP 1
1397: NOT
1398: PPUSH
1399: LD_STRING 13a_
1401: PPUSH
1402: CALL 49356 0 3
1406: ST_TO_ADDR
// if Simms then
1407: LD_EXP 26
1411: IFFALSE 1429
// tmp := tmp ^ Simms ;
1413: LD_ADDR_VAR 0 5
1417: PUSH
1418: LD_VAR 0 5
1422: PUSH
1423: LD_EXP 26
1427: ADD
1428: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1429: LD_ADDR_EXP 24
1433: PUSH
1434: LD_STRING Frank
1436: PPUSH
1437: LD_EXP 1
1441: NOT
1442: PPUSH
1443: LD_STRING 13a_
1445: PPUSH
1446: CALL 49356 0 3
1450: ST_TO_ADDR
// if Frank then
1451: LD_EXP 24
1455: IFFALSE 1473
// tmp := tmp ^ Frank ;
1457: LD_ADDR_VAR 0 5
1461: PUSH
1462: LD_VAR 0 5
1466: PUSH
1467: LD_EXP 24
1471: ADD
1472: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1473: LD_ADDR_EXP 31
1477: PUSH
1478: LD_STRING Kirilenkova
1480: PPUSH
1481: LD_EXP 1
1485: NOT
1486: PPUSH
1487: LD_STRING 13a_
1489: PPUSH
1490: CALL 49356 0 3
1494: ST_TO_ADDR
// if Kirilenkova then
1495: LD_EXP 31
1499: IFFALSE 1517
// tmp := tmp ^ Kirilenkova ;
1501: LD_ADDR_VAR 0 5
1505: PUSH
1506: LD_VAR 0 5
1510: PUSH
1511: LD_EXP 31
1515: ADD
1516: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1517: LD_ADDR_EXP 32
1521: PUSH
1522: LD_STRING Titov
1524: PPUSH
1525: LD_EXP 1
1529: NOT
1530: PPUSH
1531: LD_STRING 13a_
1533: PPUSH
1534: CALL 49356 0 3
1538: ST_TO_ADDR
// if Titov then
1539: LD_EXP 32
1543: IFFALSE 1561
// tmp := tmp ^ Titov ;
1545: LD_ADDR_VAR 0 5
1549: PUSH
1550: LD_VAR 0 5
1554: PUSH
1555: LD_EXP 32
1559: ADD
1560: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1561: LD_ADDR_EXP 33
1565: PUSH
1566: LD_STRING Fadeev
1568: PPUSH
1569: LD_EXP 1
1573: NOT
1574: PPUSH
1575: LD_STRING 13a_
1577: PPUSH
1578: CALL 49356 0 3
1582: ST_TO_ADDR
// if Fadeev then
1583: LD_EXP 33
1587: IFFALSE 1605
// tmp := tmp ^ Fadeev ;
1589: LD_ADDR_VAR 0 5
1593: PUSH
1594: LD_VAR 0 5
1598: PUSH
1599: LD_EXP 33
1603: ADD
1604: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1605: LD_ADDR_EXP 34
1609: PUSH
1610: LD_STRING Dolgov
1612: PPUSH
1613: LD_EXP 1
1617: NOT
1618: PPUSH
1619: LD_STRING 13a_
1621: PPUSH
1622: CALL 49356 0 3
1626: ST_TO_ADDR
// if Dolgov then
1627: LD_EXP 34
1631: IFFALSE 1649
// tmp := tmp ^ Dolgov ;
1633: LD_ADDR_VAR 0 5
1637: PUSH
1638: LD_VAR 0 5
1642: PUSH
1643: LD_EXP 34
1647: ADD
1648: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1649: LD_ADDR_EXP 35
1653: PUSH
1654: LD_STRING Petrosyan
1656: PPUSH
1657: LD_EXP 1
1661: NOT
1662: PPUSH
1663: LD_STRING 13a_
1665: PPUSH
1666: CALL 49356 0 3
1670: ST_TO_ADDR
// if Petrosyan then
1671: LD_EXP 35
1675: IFFALSE 1693
// tmp := tmp ^ Petrosyan ;
1677: LD_ADDR_VAR 0 5
1681: PUSH
1682: LD_VAR 0 5
1686: PUSH
1687: LD_EXP 35
1691: ADD
1692: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1693: LD_ADDR_EXP 36
1697: PUSH
1698: LD_STRING Scholtze
1700: PPUSH
1701: LD_EXP 1
1705: NOT
1706: PPUSH
1707: LD_STRING 13a_
1709: PPUSH
1710: CALL 49356 0 3
1714: ST_TO_ADDR
// if Scholtze then
1715: LD_EXP 36
1719: IFFALSE 1737
// tmp := tmp ^ Scholtze ;
1721: LD_ADDR_VAR 0 5
1725: PUSH
1726: LD_VAR 0 5
1730: PUSH
1731: LD_EXP 36
1735: ADD
1736: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1737: LD_ADDR_EXP 37
1741: PUSH
1742: LD_STRING Oblukov
1744: PPUSH
1745: LD_EXP 1
1749: NOT
1750: PPUSH
1751: LD_STRING 13a_
1753: PPUSH
1754: CALL 49356 0 3
1758: ST_TO_ADDR
// if Oblukov then
1759: LD_EXP 37
1763: IFFALSE 1781
// tmp := tmp ^ Oblukov ;
1765: LD_ADDR_VAR 0 5
1769: PUSH
1770: LD_VAR 0 5
1774: PUSH
1775: LD_EXP 37
1779: ADD
1780: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1781: LD_ADDR_EXP 38
1785: PUSH
1786: LD_STRING Kapitsova
1788: PPUSH
1789: LD_EXP 1
1793: NOT
1794: PPUSH
1795: LD_STRING 13a_
1797: PPUSH
1798: CALL 49356 0 3
1802: ST_TO_ADDR
// if Kapitsova then
1803: LD_EXP 38
1807: IFFALSE 1825
// tmp := tmp ^ Kapitsova ;
1809: LD_ADDR_VAR 0 5
1813: PUSH
1814: LD_VAR 0 5
1818: PUSH
1819: LD_EXP 38
1823: ADD
1824: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1825: LD_ADDR_EXP 39
1829: PUSH
1830: LD_STRING Lipshchin
1832: PPUSH
1833: LD_EXP 1
1837: NOT
1838: PPUSH
1839: LD_STRING 13a_
1841: PPUSH
1842: CALL 49356 0 3
1846: ST_TO_ADDR
// if Lipshchin then
1847: LD_EXP 39
1851: IFFALSE 1869
// tmp := tmp ^ Lipshchin ;
1853: LD_ADDR_VAR 0 5
1857: PUSH
1858: LD_VAR 0 5
1862: PUSH
1863: LD_EXP 39
1867: ADD
1868: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
1869: LD_ADDR_EXP 40
1873: PUSH
1874: LD_STRING Petrovova
1876: PPUSH
1877: LD_EXP 1
1881: NOT
1882: PPUSH
1883: LD_STRING 13a_
1885: PPUSH
1886: CALL 49356 0 3
1890: ST_TO_ADDR
// if Petrovova then
1891: LD_EXP 40
1895: IFFALSE 1913
// tmp := tmp ^ Petrovova ;
1897: LD_ADDR_VAR 0 5
1901: PUSH
1902: LD_VAR 0 5
1906: PUSH
1907: LD_EXP 40
1911: ADD
1912: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
1913: LD_ADDR_EXP 41
1917: PUSH
1918: LD_STRING Kovalyuk
1920: PPUSH
1921: LD_EXP 1
1925: NOT
1926: PPUSH
1927: LD_STRING 13a_
1929: PPUSH
1930: CALL 49356 0 3
1934: ST_TO_ADDR
// if Kovalyuk then
1935: LD_EXP 41
1939: IFFALSE 1957
// tmp := tmp ^ Kovalyuk ;
1941: LD_ADDR_VAR 0 5
1945: PUSH
1946: LD_VAR 0 5
1950: PUSH
1951: LD_EXP 41
1955: ADD
1956: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
1957: LD_ADDR_EXP 42
1961: PUSH
1962: LD_STRING Kuzmov
1964: PPUSH
1965: LD_EXP 1
1969: NOT
1970: PPUSH
1971: LD_STRING 13a_
1973: PPUSH
1974: CALL 49356 0 3
1978: ST_TO_ADDR
// if Kuzmov then
1979: LD_EXP 42
1983: IFFALSE 2001
// tmp := tmp ^ Kuzmov ;
1985: LD_ADDR_VAR 0 5
1989: PUSH
1990: LD_VAR 0 5
1994: PUSH
1995: LD_EXP 42
1999: ADD
2000: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2001: LD_ADDR_EXP 43
2005: PUSH
2006: LD_STRING Karamazov
2008: PPUSH
2009: LD_EXP 1
2013: NOT
2014: PPUSH
2015: LD_STRING 13a_
2017: PPUSH
2018: CALL 49356 0 3
2022: ST_TO_ADDR
// if Karamazov then
2023: LD_EXP 43
2027: IFFALSE 2045
// tmp := tmp ^ Karamazov ;
2029: LD_ADDR_VAR 0 5
2033: PUSH
2034: LD_VAR 0 5
2038: PUSH
2039: LD_EXP 43
2043: ADD
2044: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2045: LD_ADDR_EXP 45
2049: PUSH
2050: LD_STRING Belkov
2052: PPUSH
2053: LD_EXP 1
2057: NOT
2058: PPUSH
2059: LD_STRING 13a_
2061: PPUSH
2062: CALL 49356 0 3
2066: ST_TO_ADDR
// if Belkov then
2067: LD_EXP 45
2071: IFFALSE 2089
// tmp := tmp ^ Belkov ;
2073: LD_ADDR_VAR 0 5
2077: PUSH
2078: LD_VAR 0 5
2082: PUSH
2083: LD_EXP 45
2087: ADD
2088: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2089: LD_ADDR_EXP 46
2093: PUSH
2094: LD_STRING Gnyevko
2096: PPUSH
2097: LD_EXP 1
2101: NOT
2102: PPUSH
2103: LD_STRING 13a_
2105: PPUSH
2106: CALL 49356 0 3
2110: ST_TO_ADDR
// if Gnyevko then
2111: LD_EXP 46
2115: IFFALSE 2133
// tmp := tmp ^ Gnyevko ;
2117: LD_ADDR_VAR 0 5
2121: PUSH
2122: LD_VAR 0 5
2126: PUSH
2127: LD_EXP 46
2131: ADD
2132: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2133: LD_ADDR_EXP 29
2137: PUSH
2138: LD_STRING Coonie
2140: PPUSH
2141: CALL_OW 25
2145: ST_TO_ADDR
// if not Lisa then
2146: LD_EXP 14
2150: NOT
2151: IFFALSE 2197
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2153: LD_ADDR_EXP 14
2157: PUSH
2158: LD_STRING Lisa
2160: PPUSH
2161: LD_EXP 1
2165: NOT
2166: PPUSH
2167: LD_STRING 13a_
2169: PPUSH
2170: CALL 49356 0 3
2174: ST_TO_ADDR
// if Lisa then
2175: LD_EXP 14
2179: IFFALSE 2197
// tmp := tmp ^ Lisa ;
2181: LD_ADDR_VAR 0 5
2185: PUSH
2186: LD_VAR 0 5
2190: PUSH
2191: LD_EXP 14
2195: ADD
2196: ST_TO_ADDR
// end ; if not Donaldson then
2197: LD_EXP 15
2201: NOT
2202: IFFALSE 2248
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2204: LD_ADDR_EXP 15
2208: PUSH
2209: LD_STRING Donaldson
2211: PPUSH
2212: LD_EXP 1
2216: NOT
2217: PPUSH
2218: LD_STRING 13a_
2220: PPUSH
2221: CALL 49356 0 3
2225: ST_TO_ADDR
// if Donaldson then
2226: LD_EXP 15
2230: IFFALSE 2248
// tmp := tmp ^ Donaldson ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_VAR 0 5
2241: PUSH
2242: LD_EXP 15
2246: ADD
2247: ST_TO_ADDR
// end ; if not Bobby then
2248: LD_EXP 16
2252: NOT
2253: IFFALSE 2299
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2255: LD_ADDR_EXP 16
2259: PUSH
2260: LD_STRING Bobby
2262: PPUSH
2263: LD_EXP 1
2267: NOT
2268: PPUSH
2269: LD_STRING 13a_
2271: PPUSH
2272: CALL 49356 0 3
2276: ST_TO_ADDR
// if Bobby then
2277: LD_EXP 16
2281: IFFALSE 2299
// tmp := tmp ^ Bobby ;
2283: LD_ADDR_VAR 0 5
2287: PUSH
2288: LD_VAR 0 5
2292: PUSH
2293: LD_EXP 16
2297: ADD
2298: ST_TO_ADDR
// end ; if not Cyrus then
2299: LD_EXP 17
2303: NOT
2304: IFFALSE 2350
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2306: LD_ADDR_EXP 17
2310: PUSH
2311: LD_STRING Cyrus
2313: PPUSH
2314: LD_EXP 1
2318: NOT
2319: PPUSH
2320: LD_STRING 13a_
2322: PPUSH
2323: CALL 49356 0 3
2327: ST_TO_ADDR
// if Cyrus then
2328: LD_EXP 17
2332: IFFALSE 2350
// tmp := tmp ^ Cyrus ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 5
2343: PUSH
2344: LD_EXP 17
2348: ADD
2349: ST_TO_ADDR
// end ; if not Brown then
2350: LD_EXP 19
2354: NOT
2355: IFFALSE 2401
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2357: LD_ADDR_EXP 19
2361: PUSH
2362: LD_STRING Brown
2364: PPUSH
2365: LD_EXP 1
2369: NOT
2370: PPUSH
2371: LD_STRING 13a_
2373: PPUSH
2374: CALL 49356 0 3
2378: ST_TO_ADDR
// if Brown then
2379: LD_EXP 19
2383: IFFALSE 2401
// tmp := tmp ^ Brown ;
2385: LD_ADDR_VAR 0 5
2389: PUSH
2390: LD_VAR 0 5
2394: PUSH
2395: LD_EXP 19
2399: ADD
2400: ST_TO_ADDR
// end ; if not Gladstone then
2401: LD_EXP 20
2405: NOT
2406: IFFALSE 2452
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2408: LD_ADDR_EXP 20
2412: PUSH
2413: LD_STRING Gladstone
2415: PPUSH
2416: LD_EXP 1
2420: NOT
2421: PPUSH
2422: LD_STRING 13a_
2424: PPUSH
2425: CALL 49356 0 3
2429: ST_TO_ADDR
// if Gladstone then
2430: LD_EXP 20
2434: IFFALSE 2452
// tmp := tmp ^ Gladstone ;
2436: LD_ADDR_VAR 0 5
2440: PUSH
2441: LD_VAR 0 5
2445: PUSH
2446: LD_EXP 20
2450: ADD
2451: ST_TO_ADDR
// end ; if not Cornel then
2452: LD_EXP 22
2456: NOT
2457: IFFALSE 2503
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2459: LD_ADDR_EXP 22
2463: PUSH
2464: LD_STRING Cornel
2466: PPUSH
2467: LD_EXP 1
2471: NOT
2472: PPUSH
2473: LD_STRING 13a_
2475: PPUSH
2476: CALL 49356 0 3
2480: ST_TO_ADDR
// if Cornel then
2481: LD_EXP 22
2485: IFFALSE 2503
// tmp := tmp ^ Cornel ;
2487: LD_ADDR_VAR 0 5
2491: PUSH
2492: LD_VAR 0 5
2496: PUSH
2497: LD_EXP 22
2501: ADD
2502: ST_TO_ADDR
// end ; if not Houten then
2503: LD_EXP 21
2507: NOT
2508: IFFALSE 2554
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2510: LD_ADDR_EXP 21
2514: PUSH
2515: LD_STRING Houten
2517: PPUSH
2518: LD_EXP 1
2522: NOT
2523: PPUSH
2524: LD_STRING 13a_
2526: PPUSH
2527: CALL 49356 0 3
2531: ST_TO_ADDR
// if Houten then
2532: LD_EXP 21
2536: IFFALSE 2554
// tmp := tmp ^ Houten ;
2538: LD_ADDR_VAR 0 5
2542: PUSH
2543: LD_VAR 0 5
2547: PUSH
2548: LD_EXP 21
2552: ADD
2553: ST_TO_ADDR
// end ; if not Gary then
2554: LD_EXP 23
2558: NOT
2559: IFFALSE 2605
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2561: LD_ADDR_EXP 23
2565: PUSH
2566: LD_STRING Gary
2568: PPUSH
2569: LD_EXP 1
2573: NOT
2574: PPUSH
2575: LD_STRING 13a_
2577: PPUSH
2578: CALL 49356 0 3
2582: ST_TO_ADDR
// if Gary then
2583: LD_EXP 23
2587: IFFALSE 2605
// tmp := tmp ^ Gary ;
2589: LD_ADDR_VAR 0 5
2593: PUSH
2594: LD_VAR 0 5
2598: PUSH
2599: LD_EXP 23
2603: ADD
2604: ST_TO_ADDR
// end ; if not Kikuchi then
2605: LD_EXP 25
2609: NOT
2610: IFFALSE 2656
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2612: LD_ADDR_EXP 25
2616: PUSH
2617: LD_STRING Kikuchi
2619: PPUSH
2620: LD_EXP 1
2624: NOT
2625: PPUSH
2626: LD_STRING 13a_
2628: PPUSH
2629: CALL 49356 0 3
2633: ST_TO_ADDR
// if Kikuchi then
2634: LD_EXP 25
2638: IFFALSE 2656
// tmp := tmp ^ Kikuchi ;
2640: LD_ADDR_VAR 0 5
2644: PUSH
2645: LD_VAR 0 5
2649: PUSH
2650: LD_EXP 25
2654: ADD
2655: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2656: LD_ADDR_VAR 0 5
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_STRING 13a_others
2668: PPUSH
2669: CALL_OW 31
2673: UNION
2674: ST_TO_ADDR
// tmp := tmp diff 0 ;
2675: LD_ADDR_VAR 0 5
2679: PUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_INT 0
2687: DIFF
2688: ST_TO_ADDR
// if tmp < 15 then
2689: LD_VAR 0 5
2693: PUSH
2694: LD_INT 15
2696: LESS
2697: IFFALSE 2785
// for i = 15 downto tmp do
2699: LD_ADDR_VAR 0 2
2703: PUSH
2704: DOUBLE
2705: LD_INT 15
2707: INC
2708: ST_TO_ADDR
2709: LD_VAR 0 5
2713: PUSH
2714: FOR_DOWNTO
2715: IFFALSE 2783
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2717: LD_ADDR_OWVAR 21
2721: PUSH
2722: LD_INT 1
2724: PUSH
2725: LD_INT 3
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: PUSH
2732: LD_INT 1
2734: PPUSH
2735: LD_INT 2
2737: PPUSH
2738: CALL_OW 12
2742: ARRAY
2743: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2744: LD_INT 0
2746: PPUSH
2747: LD_INT 1
2749: PPUSH
2750: LD_INT 4
2752: PPUSH
2753: CALL_OW 12
2757: PPUSH
2758: LD_INT 8
2760: PPUSH
2761: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2765: LD_ADDR_VAR 0 5
2769: PUSH
2770: LD_VAR 0 5
2774: PUSH
2775: CALL_OW 44
2779: ADD
2780: ST_TO_ADDR
// end ;
2781: GO 2714
2783: POP
2784: POP
// if not debug then
2785: LD_EXP 1
2789: NOT
2790: IFFALSE 2962
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2792: LD_ADDR_VAR 0 4
2796: PUSH
2797: LD_STRING 
2799: PPUSH
2800: LD_INT 15
2802: PUSH
2803: LD_INT 14
2805: PUSH
2806: LD_INT 13
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: PUSH
2814: LD_OWVAR 67
2818: ARRAY
2819: PPUSH
2820: LD_INT 15
2822: PUSH
2823: LD_INT 14
2825: PUSH
2826: LD_INT 13
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: PUSH
2834: LD_OWVAR 67
2838: ARRAY
2839: PPUSH
2840: LD_INT -6
2842: PUSH
2843: LD_EXP 12
2847: PUSH
2848: LD_EXP 44
2852: PUSH
2853: LD_EXP 13
2857: PUSH
2858: LD_EXP 27
2862: PUSH
2863: LD_EXP 18
2867: PUSH
2868: LD_EXP 30
2872: PUSH
2873: LD_INT -2
2875: PUSH
2876: LD_INT -3
2878: PUSH
2879: LD_INT -5
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: LIST
2889: LIST
2890: LIST
2891: LIST
2892: LIST
2893: PUSH
2894: LD_VAR 0 5
2898: ADD
2899: PPUSH
2900: LD_INT 1
2902: PUSH
2903: LD_INT 4
2905: PUSH
2906: LD_INT 2
2908: PUSH
2909: LD_INT 1
2911: PUSH
2912: EMPTY
2913: LIST
2914: LIST
2915: PUSH
2916: LD_INT 3
2918: PUSH
2919: LD_INT 5
2921: PUSH
2922: LD_INT 0
2924: PUSH
2925: LD_INT 3
2927: PUSH
2928: EMPTY
2929: LIST
2930: LIST
2931: LIST
2932: PUSH
2933: LD_INT 9
2935: PUSH
2936: LD_INT 0
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: LIST
2951: LIST
2952: LIST
2953: LIST
2954: PPUSH
2955: CALL_OW 42
2959: ST_TO_ADDR
2960: GO 3041
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
2962: LD_ADDR_VAR 0 4
2966: PUSH
2967: LD_EXP 32
2971: PUSH
2972: LD_EXP 33
2976: PUSH
2977: LD_EXP 34
2981: PUSH
2982: LD_EXP 35
2986: PUSH
2987: LD_EXP 36
2991: PUSH
2992: LD_EXP 37
2996: PUSH
2997: LD_EXP 38
3001: PUSH
3002: LD_EXP 39
3006: PUSH
3007: LD_EXP 40
3011: PUSH
3012: LD_EXP 41
3016: PUSH
3017: LD_EXP 42
3021: PUSH
3022: LD_EXP 43
3026: PUSH
3027: EMPTY
3028: LIST
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: LIST
3034: LIST
3035: LIST
3036: LIST
3037: LIST
3038: LIST
3039: LIST
3040: ST_TO_ADDR
// uc_nation := 1 ;
3041: LD_ADDR_OWVAR 21
3045: PUSH
3046: LD_INT 1
3048: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3049: LD_INT 5
3051: PPUSH
3052: LD_INT 3
3054: PPUSH
3055: LD_INT 1
3057: PPUSH
3058: LD_INT 6
3060: PPUSH
3061: LD_INT 100
3063: PPUSH
3064: CALL 56107 0 5
// veh := CreateVehicle ;
3068: LD_ADDR_VAR 0 3
3072: PUSH
3073: CALL_OW 45
3077: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3078: LD_VAR 0 3
3082: PPUSH
3083: LD_INT 7
3085: NEG
3086: PPUSH
3087: CALL_OW 242
// SetDir ( veh , 3 ) ;
3091: LD_VAR 0 3
3095: PPUSH
3096: LD_INT 3
3098: PPUSH
3099: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3103: LD_VAR 0 3
3107: PPUSH
3108: LD_INT 31
3110: PPUSH
3111: LD_INT 0
3113: PPUSH
3114: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3118: LD_EXP 12
3122: PPUSH
3123: LD_VAR 0 3
3127: PPUSH
3128: CALL_OW 52
// uc_nation := 3 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 3
3139: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3140: LD_INT 22
3142: PPUSH
3143: LD_INT 3
3145: PPUSH
3146: LD_INT 1
3148: PPUSH
3149: LD_INT 45
3151: PPUSH
3152: LD_INT 100
3154: PPUSH
3155: CALL 56107 0 5
// veh := CreateVehicle ;
3159: LD_ADDR_VAR 0 3
3163: PUSH
3164: CALL_OW 45
3168: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3169: LD_VAR 0 3
3173: PPUSH
3174: LD_INT 7
3176: NEG
3177: PPUSH
3178: CALL_OW 242
// SetDir ( veh , 3 ) ;
3182: LD_VAR 0 3
3186: PPUSH
3187: LD_INT 3
3189: PPUSH
3190: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3194: LD_VAR 0 3
3198: PPUSH
3199: LD_INT 31
3201: PPUSH
3202: LD_INT 0
3204: PPUSH
3205: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3209: LD_EXP 44
3213: PPUSH
3214: LD_VAR 0 3
3218: PPUSH
3219: CALL_OW 52
// for i in selected do
3223: LD_ADDR_VAR 0 2
3227: PUSH
3228: LD_VAR 0 4
3232: PUSH
3233: FOR_IN
3234: IFFALSE 3792
// begin uc_nation := GetNation ( i ) ;
3236: LD_ADDR_OWVAR 21
3240: PUSH
3241: LD_VAR 0 2
3245: PPUSH
3246: CALL_OW 248
3250: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3251: LD_VAR 0 2
3255: PUSH
3256: LD_EXP 14
3260: PUSH
3261: LD_EXP 15
3265: PUSH
3266: LD_EXP 17
3270: PUSH
3271: LD_EXP 16
3275: PUSH
3276: EMPTY
3277: LIST
3278: LIST
3279: LIST
3280: LIST
3281: IN
3282: IFFALSE 3305
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3284: LD_INT 5
3286: PPUSH
3287: LD_INT 3
3289: PPUSH
3290: LD_INT 1
3292: PPUSH
3293: LD_INT 6
3295: PPUSH
3296: LD_INT 100
3298: PPUSH
3299: CALL 56107 0 5
3303: GO 3739
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3305: LD_VAR 0 2
3309: PUSH
3310: LD_EXP 37
3314: PUSH
3315: LD_EXP 42
3319: PUSH
3320: LD_EXP 40
3324: PUSH
3325: LD_EXP 32
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: LIST
3334: LIST
3335: IN
3336: IFFALSE 3367
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3338: LD_INT 24
3340: PPUSH
3341: LD_INT 1
3343: PPUSH
3344: LD_INT 1
3346: PPUSH
3347: LD_INT 46
3349: PPUSH
3350: LD_INT 65
3352: PPUSH
3353: LD_INT 75
3355: PPUSH
3356: CALL_OW 12
3360: PPUSH
3361: CALL 56107 0 5
3365: GO 3739
// if i = Karamazov then
3367: LD_VAR 0 2
3371: PUSH
3372: LD_EXP 43
3376: EQUAL
3377: IFFALSE 3400
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3379: LD_INT 22
3381: PPUSH
3382: LD_INT 3
3384: PPUSH
3385: LD_INT 1
3387: PPUSH
3388: LD_INT 52
3390: PPUSH
3391: LD_INT 100
3393: PPUSH
3394: CALL 56107 0 5
3398: GO 3739
// if i = Brown then
3400: LD_VAR 0 2
3404: PUSH
3405: LD_EXP 19
3409: EQUAL
3410: IFFALSE 3433
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3412: LD_INT 3
3414: PPUSH
3415: LD_INT 3
3417: PPUSH
3418: LD_INT 1
3420: PPUSH
3421: LD_INT 13
3423: PPUSH
3424: LD_INT 100
3426: PPUSH
3427: CALL 56107 0 5
3431: GO 3739
// if uc_nation = nation_american then
3433: LD_OWVAR 21
3437: PUSH
3438: LD_INT 1
3440: EQUAL
3441: IFFALSE 3592
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3443: LD_INT 3
3445: PUSH
3446: LD_INT 5
3448: PUSH
3449: LD_INT 5
3451: PUSH
3452: EMPTY
3453: LIST
3454: LIST
3455: LIST
3456: PUSH
3457: LD_OWVAR 21
3461: PUSH
3462: LD_INT 3
3464: MOD
3465: PUSH
3466: LD_INT 1
3468: PLUS
3469: ARRAY
3470: PPUSH
3471: LD_INT 1
3473: PUSH
3474: LD_INT 3
3476: PUSH
3477: LD_INT 1
3479: PUSH
3480: EMPTY
3481: LIST
3482: LIST
3483: LIST
3484: PUSH
3485: LD_OWVAR 21
3489: PUSH
3490: LD_INT 3
3492: MOD
3493: PUSH
3494: LD_INT 1
3496: PLUS
3497: ARRAY
3498: PPUSH
3499: LD_INT 1
3501: PPUSH
3502: LD_INT 11
3504: PUSH
3505: LD_INT 4
3507: PUSH
3508: LD_INT 5
3510: PUSH
3511: EMPTY
3512: LIST
3513: LIST
3514: LIST
3515: PUSH
3516: LD_INT 6
3518: PUSH
3519: LD_INT 7
3521: PUSH
3522: LD_INT 9
3524: PUSH
3525: EMPTY
3526: LIST
3527: LIST
3528: LIST
3529: PUSH
3530: LD_INT 6
3532: PUSH
3533: LD_INT 9
3535: PUSH
3536: LD_INT 12
3538: PUSH
3539: EMPTY
3540: LIST
3541: LIST
3542: LIST
3543: PUSH
3544: EMPTY
3545: LIST
3546: LIST
3547: LIST
3548: PUSH
3549: LD_OWVAR 21
3553: PUSH
3554: LD_INT 3
3556: MOD
3557: PUSH
3558: LD_INT 1
3560: PLUS
3561: ARRAY
3562: PUSH
3563: LD_INT 1
3565: PPUSH
3566: LD_INT 3
3568: PPUSH
3569: CALL_OW 12
3573: ARRAY
3574: PPUSH
3575: LD_INT 65
3577: PPUSH
3578: LD_INT 75
3580: PPUSH
3581: CALL_OW 12
3585: PPUSH
3586: CALL 56107 0 5
// end else
3590: GO 3739
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3592: LD_INT 22
3594: PUSH
3595: LD_INT 23
3597: PUSH
3598: LD_INT 23
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: LIST
3605: PUSH
3606: LD_OWVAR 21
3610: PUSH
3611: LD_INT 3
3613: MOD
3614: PUSH
3615: LD_INT 1
3617: PLUS
3618: ARRAY
3619: PPUSH
3620: LD_INT 1
3622: PUSH
3623: LD_INT 3
3625: PUSH
3626: LD_INT 1
3628: PUSH
3629: EMPTY
3630: LIST
3631: LIST
3632: LIST
3633: PUSH
3634: LD_OWVAR 21
3638: PUSH
3639: LD_INT 3
3641: MOD
3642: PUSH
3643: LD_INT 1
3645: PLUS
3646: ARRAY
3647: PPUSH
3648: LD_INT 1
3650: PPUSH
3651: LD_INT 45
3653: PUSH
3654: LD_INT 43
3656: PUSH
3657: LD_INT 44
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: LIST
3664: PUSH
3665: LD_INT 46
3667: PUSH
3668: LD_INT 45
3670: PUSH
3671: LD_INT 44
3673: PUSH
3674: EMPTY
3675: LIST
3676: LIST
3677: LIST
3678: PUSH
3679: LD_INT 46
3681: PUSH
3682: LD_INT 43
3684: PUSH
3685: LD_INT 45
3687: PUSH
3688: EMPTY
3689: LIST
3690: LIST
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: LIST
3697: PUSH
3698: LD_OWVAR 21
3702: PUSH
3703: LD_INT 3
3705: MOD
3706: PUSH
3707: LD_INT 1
3709: PLUS
3710: ARRAY
3711: PUSH
3712: LD_INT 1
3714: PPUSH
3715: LD_INT 3
3717: PPUSH
3718: CALL_OW 12
3722: ARRAY
3723: PPUSH
3724: LD_INT 65
3726: PPUSH
3727: LD_INT 75
3729: PPUSH
3730: CALL_OW 12
3734: PPUSH
3735: CALL 56107 0 5
// end ; veh := CreateVehicle ;
3739: LD_ADDR_VAR 0 3
3743: PUSH
3744: CALL_OW 45
3748: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3749: LD_VAR 0 3
3753: PPUSH
3754: LD_INT 3
3756: PPUSH
3757: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 30
3768: PPUSH
3769: LD_INT 0
3771: PPUSH
3772: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
3776: LD_VAR 0 2
3780: PPUSH
3781: LD_VAR 0 3
3785: PPUSH
3786: CALL_OW 52
// end ;
3790: GO 3233
3792: POP
3793: POP
// if artifactArCaptured then
3794: LD_EXP 6
3798: IFFALSE 3884
// begin uc_nation := nation_american ;
3800: LD_ADDR_OWVAR 21
3804: PUSH
3805: LD_INT 1
3807: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
3808: LD_INT 3
3810: PPUSH
3811: LD_INT 3
3813: PPUSH
3814: LD_INT 3
3816: PPUSH
3817: LD_INT 12
3819: PPUSH
3820: LD_INT 100
3822: PPUSH
3823: CALL 56107 0 5
// veh := CreateVehicle ;
3827: LD_ADDR_VAR 0 3
3831: PUSH
3832: CALL_OW 45
3836: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3837: LD_VAR 0 3
3841: PPUSH
3842: LD_INT 3
3844: PPUSH
3845: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
3849: LD_VAR 0 3
3853: PPUSH
3854: LD_INT 198
3856: PPUSH
3857: LD_INT 22
3859: PPUSH
3860: LD_INT 0
3862: PPUSH
3863: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
3867: LD_VAR 0 3
3871: PPUSH
3872: LD_INT 4
3874: PPUSH
3875: LD_INT 50
3877: PPUSH
3878: CALL_OW 290
// end else
3882: GO 3903
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
3884: LD_INT 4
3886: PPUSH
3887: LD_INT 267
3889: PPUSH
3890: LD_INT 226
3892: PPUSH
3893: LD_INT 5
3895: PPUSH
3896: LD_INT 0
3898: PPUSH
3899: CALL_OW 58
// end ; uc_nation := nation_american ;
3903: LD_ADDR_OWVAR 21
3907: PUSH
3908: LD_INT 1
3910: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
3911: LD_INT 3
3913: PPUSH
3914: LD_INT 3
3916: PPUSH
3917: LD_INT 3
3919: PPUSH
3920: LD_INT 12
3922: PPUSH
3923: LD_INT 100
3925: PPUSH
3926: CALL 56107 0 5
// veh := CreateVehicle ;
3930: LD_ADDR_VAR 0 3
3934: PUSH
3935: CALL_OW 45
3939: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3940: LD_VAR 0 3
3944: PPUSH
3945: LD_INT 3
3947: PPUSH
3948: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
3952: LD_VAR 0 3
3956: PPUSH
3957: LD_INT 218
3959: PPUSH
3960: LD_INT 23
3962: PPUSH
3963: LD_INT 0
3965: PPUSH
3966: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
3970: LD_VAR 0 3
3974: PPUSH
3975: LD_INT 4
3977: PPUSH
3978: LD_INT 30
3980: PPUSH
3981: CALL_OW 290
// uc_nation := nation_russian ;
3985: LD_ADDR_OWVAR 21
3989: PUSH
3990: LD_INT 3
3992: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
3993: LD_INT 22
3995: PPUSH
3996: LD_INT 3
3998: PPUSH
3999: LD_INT 3
4001: PPUSH
4002: LD_INT 51
4004: PPUSH
4005: LD_INT 100
4007: PPUSH
4008: CALL 56107 0 5
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 3
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4022: LD_VAR 0 3
4026: PPUSH
4027: LD_INT 3
4029: PPUSH
4030: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4034: LD_VAR 0 3
4038: PPUSH
4039: LD_INT 214
4041: PPUSH
4042: LD_INT 20
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4052: LD_VAR 0 3
4056: PPUSH
4057: LD_INT 4
4059: PPUSH
4060: LD_INT 40
4062: PPUSH
4063: CALL_OW 290
// end ; end_of_file
4067: LD_VAR 0 1
4071: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4072: LD_INT 0
4074: PPUSH
4075: PPUSH
4076: PPUSH
4077: PPUSH
4078: PPUSH
4079: PPUSH
4080: PPUSH
4081: PPUSH
4082: PPUSH
4083: PPUSH
// InitHc ;
4084: CALL_OW 19
// uc_side := 1 ;
4088: LD_ADDR_OWVAR 20
4092: PUSH
4093: LD_INT 1
4095: ST_TO_ADDR
// uc_nation := 1 ;
4096: LD_ADDR_OWVAR 21
4100: PUSH
4101: LD_INT 1
4103: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4104: LD_INT 387
4106: PPUSH
4107: CALL_OW 274
4111: PPUSH
4112: LD_INT 1
4114: PPUSH
4115: LD_INT 25500
4117: PPUSH
4118: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4122: LD_INT 387
4124: PPUSH
4125: CALL_OW 274
4129: PPUSH
4130: LD_INT 2
4132: PPUSH
4133: LD_INT 4000
4135: PPUSH
4136: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4140: LD_INT 387
4142: PPUSH
4143: CALL_OW 274
4147: PPUSH
4148: LD_INT 3
4150: PPUSH
4151: LD_INT 50
4153: PPUSH
4154: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4158: LD_INT 476
4160: PPUSH
4161: CALL_OW 274
4165: PPUSH
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 7500
4171: PPUSH
4172: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4176: LD_INT 476
4178: PPUSH
4179: CALL_OW 274
4183: PPUSH
4184: LD_INT 2
4186: PPUSH
4187: LD_INT 4000
4189: PPUSH
4190: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4194: LD_INT 476
4196: PPUSH
4197: CALL_OW 274
4201: PPUSH
4202: LD_INT 3
4204: PPUSH
4205: LD_INT 10
4207: PPUSH
4208: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4212: LD_ADDR_EXP 47
4216: PUSH
4217: LD_STRING Powell
4219: PPUSH
4220: CALL_OW 25
4224: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
4225: LD_EXP 47
4229: PPUSH
4230: LD_INT 57
4232: PPUSH
4233: LD_INT 94
4235: PPUSH
4236: LD_INT 0
4238: PPUSH
4239: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
4243: LD_EXP 47
4247: PPUSH
4248: LD_INT 58
4250: PPUSH
4251: LD_INT 94
4253: PPUSH
4254: CALL_OW 118
// tmp := [ ] ;
4258: LD_ADDR_VAR 0 6
4262: PUSH
4263: EMPTY
4264: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4265: LD_ADDR_EXP 14
4269: PUSH
4270: LD_STRING Lisa
4272: PPUSH
4273: LD_EXP 1
4277: NOT
4278: PPUSH
4279: LD_STRING 12p_
4281: PPUSH
4282: CALL 49356 0 3
4286: ST_TO_ADDR
// if Lisa then
4287: LD_EXP 14
4291: IFFALSE 4309
// tmp := tmp ^ Lisa ;
4293: LD_ADDR_VAR 0 6
4297: PUSH
4298: LD_VAR 0 6
4302: PUSH
4303: LD_EXP 14
4307: ADD
4308: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4309: LD_ADDR_EXP 15
4313: PUSH
4314: LD_STRING Donaldson
4316: PPUSH
4317: LD_EXP 1
4321: NOT
4322: PPUSH
4323: LD_STRING 12p_
4325: PPUSH
4326: CALL 49356 0 3
4330: ST_TO_ADDR
// if Donaldson then
4331: LD_EXP 15
4335: IFFALSE 4353
// tmp := tmp ^ Donaldson ;
4337: LD_ADDR_VAR 0 6
4341: PUSH
4342: LD_VAR 0 6
4346: PUSH
4347: LD_EXP 15
4351: ADD
4352: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4353: LD_ADDR_EXP 16
4357: PUSH
4358: LD_STRING Bobby
4360: PPUSH
4361: LD_EXP 1
4365: NOT
4366: PPUSH
4367: LD_STRING 12p_
4369: PPUSH
4370: CALL 49356 0 3
4374: ST_TO_ADDR
// if Bobby then
4375: LD_EXP 16
4379: IFFALSE 4397
// tmp := tmp ^ Bobby ;
4381: LD_ADDR_VAR 0 6
4385: PUSH
4386: LD_VAR 0 6
4390: PUSH
4391: LD_EXP 16
4395: ADD
4396: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4397: LD_ADDR_EXP 17
4401: PUSH
4402: LD_STRING Cyrus
4404: PPUSH
4405: LD_EXP 1
4409: NOT
4410: PPUSH
4411: LD_STRING 12p_
4413: PPUSH
4414: CALL 49356 0 3
4418: ST_TO_ADDR
// if Cyrus then
4419: LD_EXP 17
4423: IFFALSE 4441
// tmp := tmp ^ Cyrus ;
4425: LD_ADDR_VAR 0 6
4429: PUSH
4430: LD_VAR 0 6
4434: PUSH
4435: LD_EXP 17
4439: ADD
4440: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4441: LD_ADDR_EXP 19
4445: PUSH
4446: LD_STRING Brown
4448: PPUSH
4449: LD_EXP 1
4453: NOT
4454: PPUSH
4455: LD_STRING 12p_
4457: PPUSH
4458: CALL 49356 0 3
4462: ST_TO_ADDR
// if Brown then
4463: LD_EXP 19
4467: IFFALSE 4485
// tmp := tmp ^ Brown ;
4469: LD_ADDR_VAR 0 6
4473: PUSH
4474: LD_VAR 0 6
4478: PUSH
4479: LD_EXP 19
4483: ADD
4484: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4485: LD_ADDR_EXP 20
4489: PUSH
4490: LD_STRING Gladstone
4492: PPUSH
4493: LD_EXP 1
4497: NOT
4498: PPUSH
4499: LD_STRING 12p_
4501: PPUSH
4502: CALL 49356 0 3
4506: ST_TO_ADDR
// if Gladstone then
4507: LD_EXP 20
4511: IFFALSE 4529
// tmp := tmp ^ Gladstone ;
4513: LD_ADDR_VAR 0 6
4517: PUSH
4518: LD_VAR 0 6
4522: PUSH
4523: LD_EXP 20
4527: ADD
4528: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4529: LD_ADDR_EXP 21
4533: PUSH
4534: LD_STRING Houten
4536: PPUSH
4537: LD_EXP 1
4541: NOT
4542: PPUSH
4543: LD_STRING 12p_
4545: PPUSH
4546: CALL 49356 0 3
4550: ST_TO_ADDR
// if Houten then
4551: LD_EXP 21
4555: IFFALSE 4573
// tmp := tmp ^ Houten ;
4557: LD_ADDR_VAR 0 6
4561: PUSH
4562: LD_VAR 0 6
4566: PUSH
4567: LD_EXP 21
4571: ADD
4572: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
4573: LD_ADDR_EXP 22
4577: PUSH
4578: LD_STRING Cornel
4580: PPUSH
4581: LD_EXP 1
4585: NOT
4586: PPUSH
4587: LD_STRING 12p_
4589: PPUSH
4590: CALL 49356 0 3
4594: ST_TO_ADDR
// if Cornel then
4595: LD_EXP 22
4599: IFFALSE 4617
// tmp := tmp ^ Cornel ;
4601: LD_ADDR_VAR 0 6
4605: PUSH
4606: LD_VAR 0 6
4610: PUSH
4611: LD_EXP 22
4615: ADD
4616: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
4617: LD_ADDR_EXP 23
4621: PUSH
4622: LD_STRING Gary
4624: PPUSH
4625: LD_EXP 1
4629: NOT
4630: PPUSH
4631: LD_STRING 12p_
4633: PPUSH
4634: CALL 49356 0 3
4638: ST_TO_ADDR
// if Gary then
4639: LD_EXP 23
4643: IFFALSE 4661
// tmp := tmp ^ Gary ;
4645: LD_ADDR_VAR 0 6
4649: PUSH
4650: LD_VAR 0 6
4654: PUSH
4655: LD_EXP 23
4659: ADD
4660: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
4661: LD_ADDR_EXP 25
4665: PUSH
4666: LD_STRING Kikuchi
4668: PPUSH
4669: LD_EXP 1
4673: NOT
4674: PPUSH
4675: LD_STRING 12p_
4677: PPUSH
4678: CALL 49356 0 3
4682: ST_TO_ADDR
// if Kikuchi then
4683: LD_EXP 25
4687: IFFALSE 4705
// tmp := tmp ^ Kikuchi ;
4689: LD_ADDR_VAR 0 6
4693: PUSH
4694: LD_VAR 0 6
4698: PUSH
4699: LD_EXP 25
4703: ADD
4704: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
4705: LD_ADDR_VAR 0 6
4709: PUSH
4710: LD_VAR 0 6
4714: PUSH
4715: LD_STRING 12p_others
4717: PPUSH
4718: CALL_OW 31
4722: UNION
4723: ST_TO_ADDR
// if tmp < 36 then
4724: LD_VAR 0 6
4728: PUSH
4729: LD_INT 36
4731: LESS
4732: IFFALSE 4799
// for i = 1 to 36 - tmp do
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: DOUBLE
4740: LD_INT 1
4742: DEC
4743: ST_TO_ADDR
4744: LD_INT 36
4746: PUSH
4747: LD_VAR 0 6
4751: MINUS
4752: PUSH
4753: FOR_TO
4754: IFFALSE 4797
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
4756: LD_INT 1
4758: PPUSH
4759: LD_VAR 0 2
4763: PUSH
4764: LD_INT 4
4766: MOD
4767: PUSH
4768: LD_INT 1
4770: PLUS
4771: PPUSH
4772: LD_INT 10
4774: PPUSH
4775: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
4779: LD_ADDR_VAR 0 6
4783: PUSH
4784: LD_VAR 0 6
4788: PUSH
4789: CALL_OW 44
4793: ADD
4794: ST_TO_ADDR
// end ;
4795: GO 4753
4797: POP
4798: POP
// for i in tmp do
4799: LD_ADDR_VAR 0 2
4803: PUSH
4804: LD_VAR 0 6
4808: PUSH
4809: FOR_IN
4810: IFFALSE 4835
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
4812: LD_VAR 0 2
4816: PPUSH
4817: LD_INT 62
4819: PPUSH
4820: LD_INT 93
4822: PPUSH
4823: LD_INT 9
4825: PPUSH
4826: LD_INT 0
4828: PPUSH
4829: CALL_OW 50
4833: GO 4809
4835: POP
4836: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
4837: LD_ADDR_EXP 74
4841: PUSH
4842: LD_EXP 74
4846: PPUSH
4847: LD_INT 4
4849: PPUSH
4850: LD_INT 22
4852: PUSH
4853: LD_INT 1
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: PPUSH
4860: CALL_OW 69
4864: PPUSH
4865: CALL_OW 1
4869: ST_TO_ADDR
// uc_side := 0 ;
4870: LD_ADDR_OWVAR 20
4874: PUSH
4875: LD_INT 0
4877: ST_TO_ADDR
// uc_nation := 0 ;
4878: LD_ADDR_OWVAR 21
4882: PUSH
4883: LD_INT 0
4885: ST_TO_ADDR
// for i = 1 to 4 do
4886: LD_ADDR_VAR 0 2
4890: PUSH
4891: DOUBLE
4892: LD_INT 1
4894: DEC
4895: ST_TO_ADDR
4896: LD_INT 4
4898: PUSH
4899: FOR_TO
4900: IFFALSE 4931
// begin InitHc ;
4902: CALL_OW 19
// hc_class := class_apeman ;
4906: LD_ADDR_OWVAR 28
4910: PUSH
4911: LD_INT 12
4913: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4914: CALL_OW 44
4918: PPUSH
4919: LD_INT 11
4921: PPUSH
4922: LD_INT 0
4924: PPUSH
4925: CALL_OW 49
// end ;
4929: GO 4899
4931: POP
4932: POP
// end ;
4933: LD_VAR 0 1
4937: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
4938: LD_EXP 4
4942: NOT
4943: PUSH
4944: LD_INT 4
4946: PPUSH
4947: LD_INT 1
4949: PPUSH
4950: CALL 44564 0 2
4954: NOT
4955: AND
4956: IFFALSE 5728
4958: GO 4960
4960: DISABLE
4961: LD_INT 0
4963: PPUSH
4964: PPUSH
4965: PPUSH
// begin enable ;
4966: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
4967: LD_INT 22
4969: PUSH
4970: LD_INT 1
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PUSH
4977: LD_INT 23
4979: PUSH
4980: LD_INT 1
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 30
4989: PUSH
4990: LD_INT 3
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: LIST
5001: PPUSH
5002: CALL_OW 69
5006: NOT
5007: IFFALSE 5011
// exit ;
5009: GO 5728
// if Prob ( 40 ) then
5011: LD_INT 40
5013: PPUSH
5014: CALL_OW 13
5018: IFFALSE 5145
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5020: LD_INT 4
5022: PPUSH
5023: LD_INT 5
5025: PUSH
5026: LD_INT 1
5028: PUSH
5029: LD_INT 2
5031: PUSH
5032: LD_INT 7
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 5
5043: PUSH
5044: LD_INT 1
5046: PUSH
5047: LD_INT 2
5049: PUSH
5050: LD_INT 7
5052: PUSH
5053: EMPTY
5054: LIST
5055: LIST
5056: LIST
5057: LIST
5058: PUSH
5059: LD_INT 5
5061: PUSH
5062: LD_INT 1
5064: PUSH
5065: LD_INT 2
5067: PUSH
5068: LD_INT 7
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: LIST
5075: LIST
5076: PUSH
5077: LD_INT 5
5079: PUSH
5080: LD_INT 1
5082: PUSH
5083: LD_INT 2
5085: PUSH
5086: LD_INT 6
5088: PUSH
5089: EMPTY
5090: LIST
5091: LIST
5092: LIST
5093: LIST
5094: PUSH
5095: LD_INT 5
5097: PUSH
5098: LD_INT 1
5100: PUSH
5101: LD_INT 2
5103: PUSH
5104: LD_INT 6
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: PUSH
5113: LD_INT 5
5115: PUSH
5116: LD_INT 1
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 6
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: LIST
5129: LIST
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: LIST
5135: LIST
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL 43146 0 2
// end else
5143: GO 5268
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5145: LD_INT 4
5147: PPUSH
5148: LD_INT 5
5150: PUSH
5151: LD_INT 1
5153: PUSH
5154: LD_INT 2
5156: PUSH
5157: LD_INT 7
5159: PUSH
5160: EMPTY
5161: LIST
5162: LIST
5163: LIST
5164: LIST
5165: PUSH
5166: LD_INT 5
5168: PUSH
5169: LD_INT 1
5171: PUSH
5172: LD_INT 2
5174: PUSH
5175: LD_INT 9
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: LIST
5182: LIST
5183: PUSH
5184: LD_INT 5
5186: PUSH
5187: LD_INT 1
5189: PUSH
5190: LD_INT 2
5192: PUSH
5193: LD_INT 9
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: PUSH
5202: LD_INT 5
5204: PUSH
5205: LD_INT 1
5207: PUSH
5208: LD_INT 2
5210: PUSH
5211: LD_INT 6
5213: PUSH
5214: EMPTY
5215: LIST
5216: LIST
5217: LIST
5218: LIST
5219: PUSH
5220: LD_INT 5
5222: PUSH
5223: LD_INT 1
5225: PUSH
5226: LD_INT 2
5228: PUSH
5229: LD_INT 6
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: LIST
5237: PUSH
5238: LD_INT 5
5240: PUSH
5241: LD_INT 1
5243: PUSH
5244: LD_INT 2
5246: PUSH
5247: LD_INT 6
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: LIST
5254: LIST
5255: PUSH
5256: EMPTY
5257: LIST
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: LIST
5263: PPUSH
5264: CALL 43146 0 2
// end ; repeat wait ( 0 0$1 ) ;
5268: LD_INT 35
5270: PPUSH
5271: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5275: LD_INT 4
5277: PPUSH
5278: LD_INT 1
5280: PPUSH
5281: CALL 44564 0 2
5285: PUSH
5286: LD_INT 6
5288: GREATEREQUAL
5289: IFFALSE 5268
// wait ( 0 0$30 ) ;
5291: LD_INT 1050
5293: PPUSH
5294: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5298: LD_ADDR_VAR 0 2
5302: PUSH
5303: LD_INT 4
5305: PPUSH
5306: LD_INT 1
5308: PPUSH
5309: CALL 44564 0 2
5313: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5314: LD_ADDR_EXP 93
5318: PUSH
5319: LD_EXP 93
5323: PPUSH
5324: LD_INT 4
5326: PPUSH
5327: LD_EXP 93
5331: PUSH
5332: LD_INT 4
5334: ARRAY
5335: PUSH
5336: LD_VAR 0 2
5340: DIFF
5341: PPUSH
5342: CALL_OW 1
5346: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5347: LD_ADDR_VAR 0 3
5351: PUSH
5352: LD_INT 0
5354: PPUSH
5355: LD_INT 2
5357: PPUSH
5358: CALL_OW 12
5362: ST_TO_ADDR
// if target then
5363: LD_VAR 0 3
5367: IFFALSE 5495
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5369: LD_ADDR_VAR 0 2
5373: PUSH
5374: LD_VAR 0 2
5378: PPUSH
5379: LD_INT 24
5381: PUSH
5382: LD_INT 250
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PPUSH
5389: CALL_OW 72
5393: ST_TO_ADDR
// for i in tmp do
5394: LD_ADDR_VAR 0 1
5398: PUSH
5399: LD_VAR 0 2
5403: PUSH
5404: FOR_IN
5405: IFFALSE 5445
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5407: LD_VAR 0 1
5411: PPUSH
5412: LD_INT 114
5414: PPUSH
5415: LD_INT 108
5417: PPUSH
5418: CALL_OW 297
5422: PUSH
5423: LD_INT 9
5425: GREATER
5426: IFFALSE 5443
// ComMoveXY ( i , 114 , 108 ) ;
5428: LD_VAR 0 1
5432: PPUSH
5433: LD_INT 114
5435: PPUSH
5436: LD_INT 108
5438: PPUSH
5439: CALL_OW 111
5443: GO 5404
5445: POP
5446: POP
// wait ( 0 0$1 ) ;
5447: LD_INT 35
5449: PPUSH
5450: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5454: LD_VAR 0 2
5458: PPUSH
5459: LD_INT 92
5461: PUSH
5462: LD_INT 114
5464: PUSH
5465: LD_INT 108
5467: PUSH
5468: LD_INT 9
5470: PUSH
5471: EMPTY
5472: LIST
5473: LIST
5474: LIST
5475: LIST
5476: PPUSH
5477: CALL_OW 72
5481: PUSH
5482: LD_VAR 0 2
5486: PUSH
5487: LD_INT 1
5489: MINUS
5490: GREATEREQUAL
5491: IFFALSE 5369
// end else
5493: GO 5619
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5495: LD_ADDR_VAR 0 2
5499: PUSH
5500: LD_VAR 0 2
5504: PPUSH
5505: LD_INT 24
5507: PUSH
5508: LD_INT 250
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: PPUSH
5515: CALL_OW 72
5519: ST_TO_ADDR
// for i in tmp do
5520: LD_ADDR_VAR 0 1
5524: PUSH
5525: LD_VAR 0 2
5529: PUSH
5530: FOR_IN
5531: IFFALSE 5571
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5533: LD_VAR 0 1
5537: PPUSH
5538: LD_INT 129
5540: PPUSH
5541: LD_INT 139
5543: PPUSH
5544: CALL_OW 297
5548: PUSH
5549: LD_INT 9
5551: GREATER
5552: IFFALSE 5569
// ComMoveXY ( i , 129 , 139 ) ;
5554: LD_VAR 0 1
5558: PPUSH
5559: LD_INT 129
5561: PPUSH
5562: LD_INT 139
5564: PPUSH
5565: CALL_OW 111
5569: GO 5530
5571: POP
5572: POP
// wait ( 0 0$1 ) ;
5573: LD_INT 35
5575: PPUSH
5576: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
5580: LD_VAR 0 2
5584: PPUSH
5585: LD_INT 92
5587: PUSH
5588: LD_INT 129
5590: PUSH
5591: LD_INT 139
5593: PUSH
5594: LD_INT 9
5596: PUSH
5597: EMPTY
5598: LIST
5599: LIST
5600: LIST
5601: LIST
5602: PPUSH
5603: CALL_OW 72
5607: PUSH
5608: LD_VAR 0 2
5612: PUSH
5613: LD_INT 1
5615: MINUS
5616: GREATEREQUAL
5617: IFFALSE 5495
// end ; repeat wait ( 0 0$1 ) ;
5619: LD_INT 35
5621: PPUSH
5622: CALL_OW 67
// for i in tmp do
5626: LD_ADDR_VAR 0 1
5630: PUSH
5631: LD_VAR 0 2
5635: PUSH
5636: FOR_IN
5637: IFFALSE 5719
// begin if GetLives ( i ) > 251 then
5639: LD_VAR 0 1
5643: PPUSH
5644: CALL_OW 256
5648: PUSH
5649: LD_INT 251
5651: GREATER
5652: IFFALSE 5690
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
5654: LD_VAR 0 1
5658: PPUSH
5659: LD_INT 81
5661: PUSH
5662: LD_INT 1
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: PPUSH
5669: CALL_OW 69
5673: PPUSH
5674: LD_VAR 0 1
5678: PPUSH
5679: CALL_OW 74
5683: PPUSH
5684: CALL_OW 115
5688: GO 5717
// if IsDead ( i ) then
5690: LD_VAR 0 1
5694: PPUSH
5695: CALL_OW 301
5699: IFFALSE 5717
// tmp := tmp diff i ;
5701: LD_ADDR_VAR 0 2
5705: PUSH
5706: LD_VAR 0 2
5710: PUSH
5711: LD_VAR 0 1
5715: DIFF
5716: ST_TO_ADDR
// end ;
5717: GO 5636
5719: POP
5720: POP
// until not tmp ;
5721: LD_VAR 0 2
5725: NOT
5726: IFFALSE 5619
// end ;
5728: PPOPN 3
5730: END
// every 30 30$00 trigger not americanDestroyed do
5731: LD_EXP 4
5735: NOT
5736: IFFALSE 5801
5738: GO 5740
5740: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
5741: LD_INT 63000
5743: PUSH
5744: LD_INT 42000
5746: PUSH
5747: LD_INT 21000
5749: PUSH
5750: EMPTY
5751: LIST
5752: LIST
5753: LIST
5754: PUSH
5755: LD_OWVAR 67
5759: ARRAY
5760: PPUSH
5761: CALL_OW 67
// if americanDestroyed then
5765: LD_EXP 4
5769: IFFALSE 5773
// exit ;
5771: GO 5801
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
5773: LD_INT 4
5775: PPUSH
5776: LD_INT 5
5778: PUSH
5779: LD_INT 3
5781: PUSH
5782: LD_INT 1
5784: PUSH
5785: LD_INT 8
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: LIST
5793: PUSH
5794: EMPTY
5795: LIST
5796: PPUSH
5797: CALL 43146 0 2
// end ; end_of_file
5801: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
5802: LD_INT 0
5804: PPUSH
5805: PPUSH
5806: PPUSH
5807: PPUSH
5808: PPUSH
// side := 2 ;
5809: LD_ADDR_VAR 0 5
5813: PUSH
5814: LD_INT 2
5816: ST_TO_ADDR
// InitHc ;
5817: CALL_OW 19
// uc_side := side ;
5821: LD_ADDR_OWVAR 20
5825: PUSH
5826: LD_VAR 0 5
5830: ST_TO_ADDR
// uc_nation := 2 ;
5831: LD_ADDR_OWVAR 21
5835: PUSH
5836: LD_INT 2
5838: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
5839: LD_ADDR_VAR 0 4
5843: PUSH
5844: LD_INT 22
5846: PUSH
5847: LD_VAR 0 5
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: PUSH
5856: LD_INT 30
5858: PUSH
5859: LD_INT 32
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PUSH
5866: LD_INT 58
5868: PUSH
5869: EMPTY
5870: LIST
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: LIST
5876: PPUSH
5877: CALL_OW 69
5881: ST_TO_ADDR
// for i = 1 to 10 do
5882: LD_ADDR_VAR 0 2
5886: PUSH
5887: DOUBLE
5888: LD_INT 1
5890: DEC
5891: ST_TO_ADDR
5892: LD_INT 10
5894: PUSH
5895: FOR_TO
5896: IFFALSE 5968
// begin uc_nation := nation_nature ;
5898: LD_ADDR_OWVAR 21
5902: PUSH
5903: LD_INT 0
5905: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5906: LD_ADDR_OWVAR 28
5910: PUSH
5911: LD_INT 15
5913: ST_TO_ADDR
// hc_gallery :=  ;
5914: LD_ADDR_OWVAR 33
5918: PUSH
5919: LD_STRING 
5921: ST_TO_ADDR
// hc_name :=  ;
5922: LD_ADDR_OWVAR 26
5926: PUSH
5927: LD_STRING 
5929: ST_TO_ADDR
// un := CreateHuman ;
5930: LD_ADDR_VAR 0 3
5934: PUSH
5935: CALL_OW 44
5939: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5940: LD_VAR 0 3
5944: PPUSH
5945: LD_VAR 0 4
5949: PUSH
5950: LD_VAR 0 4
5954: PUSH
5955: LD_VAR 0 2
5959: MINUS
5960: ARRAY
5961: PPUSH
5962: CALL_OW 52
// end ;
5966: GO 5895
5968: POP
5969: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
5970: LD_INT 503
5972: PPUSH
5973: LD_INT 27
5975: PPUSH
5976: LD_STRING 
5978: PPUSH
5979: LD_INT 8
5981: PUSH
5982: LD_INT 9
5984: PUSH
5985: LD_INT 10
5987: PUSH
5988: EMPTY
5989: LIST
5990: LIST
5991: LIST
5992: PUSH
5993: LD_OWVAR 67
5997: ARRAY
5998: PPUSH
5999: LD_INT 3000
6001: PUSH
6002: LD_INT 500
6004: PUSH
6005: LD_INT 150
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: LIST
6012: PPUSH
6013: LD_INT 16
6015: PUSH
6016: LD_INT 6
6018: PUSH
6019: LD_INT 6
6021: PUSH
6022: LD_INT 6
6024: PUSH
6025: EMPTY
6026: LIST
6027: LIST
6028: LIST
6029: LIST
6030: PPUSH
6031: CALL 59516 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6035: LD_ADDR_EXP 74
6039: PUSH
6040: LD_EXP 74
6044: PPUSH
6045: LD_INT 1
6047: PPUSH
6048: LD_INT 22
6050: PUSH
6051: LD_VAR 0 5
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PUSH
6060: LD_INT 23
6062: PUSH
6063: LD_INT 2
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: PUSH
6070: LD_INT 3
6072: PUSH
6073: LD_INT 21
6075: PUSH
6076: LD_INT 2
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PUSH
6087: EMPTY
6088: LIST
6089: LIST
6090: LIST
6091: PPUSH
6092: CALL_OW 69
6096: PPUSH
6097: CALL_OW 1
6101: ST_TO_ADDR
// end ;
6102: LD_VAR 0 1
6106: RET
// export Omar ; export function PrepareOmarAli ; begin
6107: LD_INT 0
6109: PPUSH
// uc_side := 5 ;
6110: LD_ADDR_OWVAR 20
6114: PUSH
6115: LD_INT 5
6117: ST_TO_ADDR
// uc_nation := 2 ;
6118: LD_ADDR_OWVAR 21
6122: PUSH
6123: LD_INT 2
6125: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6126: LD_ADDR_EXP 48
6130: PUSH
6131: LD_STRING Omar
6133: PPUSH
6134: CALL_OW 25
6138: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6139: LD_EXP 48
6143: PPUSH
6144: LD_INT 330
6146: PPUSH
6147: LD_INT 244
6149: PPUSH
6150: LD_INT 0
6152: PPUSH
6153: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6157: LD_EXP 48
6161: PPUSH
6162: LD_INT 22
6164: PUSH
6165: LD_INT 7
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: PPUSH
6172: CALL_OW 69
6176: PPUSH
6177: LD_EXP 48
6181: PPUSH
6182: CALL_OW 74
6186: PPUSH
6187: CALL_OW 112
// end ; end_of_file
6191: LD_VAR 0 1
6195: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6196: LD_INT 0
6198: PPUSH
6199: PPUSH
6200: PPUSH
6201: PPUSH
6202: PPUSH
// side := 8 ;
6203: LD_ADDR_VAR 0 3
6207: PUSH
6208: LD_INT 8
6210: ST_TO_ADDR
// InitHc ;
6211: CALL_OW 19
// uc_side := side ;
6215: LD_ADDR_OWVAR 20
6219: PUSH
6220: LD_VAR 0 3
6224: ST_TO_ADDR
// uc_nation := 2 ;
6225: LD_ADDR_OWVAR 21
6229: PUSH
6230: LD_INT 2
6232: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6233: LD_ADDR_VAR 0 2
6237: PUSH
6238: LD_INT 22
6240: PUSH
6241: LD_VAR 0 3
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: PUSH
6250: LD_INT 21
6252: PUSH
6253: LD_INT 3
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: PUSH
6260: EMPTY
6261: LIST
6262: LIST
6263: PPUSH
6264: CALL_OW 69
6268: PUSH
6269: FOR_IN
6270: IFFALSE 6286
// SetBLevel ( i , 10 ) ;
6272: LD_VAR 0 2
6276: PPUSH
6277: LD_INT 10
6279: PPUSH
6280: CALL_OW 241
6284: GO 6269
6286: POP
6287: POP
// Schulz := NewCharacter ( Schulz ) ;
6288: LD_ADDR_EXP 49
6292: PUSH
6293: LD_STRING Schulz
6295: PPUSH
6296: CALL_OW 25
6300: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6301: LD_ADDR_EXP 50
6305: PUSH
6306: LD_STRING Kozlov
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_STRING 
6314: PPUSH
6315: CALL 49356 0 3
6319: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6320: LD_EXP 50
6324: PPUSH
6325: LD_INT 22
6327: PUSH
6328: LD_INT 8
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PUSH
6335: LD_INT 23
6337: PUSH
6338: LD_INT 3
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: PUSH
6345: LD_INT 30
6347: PUSH
6348: LD_INT 8
6350: PUSH
6351: EMPTY
6352: LIST
6353: LIST
6354: PUSH
6355: EMPTY
6356: LIST
6357: LIST
6358: LIST
6359: PPUSH
6360: CALL_OW 69
6364: PUSH
6365: LD_INT 1
6367: ARRAY
6368: PPUSH
6369: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6373: LD_EXP 50
6377: PPUSH
6378: LD_INT 3
6380: PPUSH
6381: LD_INT 10
6383: PPUSH
6384: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6388: LD_ADDR_VAR 0 5
6392: PUSH
6393: LD_INT 22
6395: PUSH
6396: LD_VAR 0 3
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 30
6407: PUSH
6408: LD_INT 32
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: PUSH
6415: LD_INT 58
6417: PUSH
6418: EMPTY
6419: LIST
6420: PUSH
6421: EMPTY
6422: LIST
6423: LIST
6424: LIST
6425: PPUSH
6426: CALL_OW 69
6430: ST_TO_ADDR
// for i = 1 to 10 do
6431: LD_ADDR_VAR 0 2
6435: PUSH
6436: DOUBLE
6437: LD_INT 1
6439: DEC
6440: ST_TO_ADDR
6441: LD_INT 10
6443: PUSH
6444: FOR_TO
6445: IFFALSE 6517
// begin uc_nation := nation_nature ;
6447: LD_ADDR_OWVAR 21
6451: PUSH
6452: LD_INT 0
6454: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6455: LD_ADDR_OWVAR 28
6459: PUSH
6460: LD_INT 15
6462: ST_TO_ADDR
// hc_gallery :=  ;
6463: LD_ADDR_OWVAR 33
6467: PUSH
6468: LD_STRING 
6470: ST_TO_ADDR
// hc_name :=  ;
6471: LD_ADDR_OWVAR 26
6475: PUSH
6476: LD_STRING 
6478: ST_TO_ADDR
// un := CreateHuman ;
6479: LD_ADDR_VAR 0 4
6483: PUSH
6484: CALL_OW 44
6488: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6489: LD_VAR 0 4
6493: PPUSH
6494: LD_VAR 0 5
6498: PUSH
6499: LD_VAR 0 5
6503: PUSH
6504: LD_VAR 0 2
6508: MINUS
6509: ARRAY
6510: PPUSH
6511: CALL_OW 52
// end ;
6515: GO 6444
6517: POP
6518: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6519: LD_INT 324
6521: PPUSH
6522: LD_INT 3
6524: PPUSH
6525: LD_STRING 
6527: PPUSH
6528: LD_INT 8
6530: PUSH
6531: LD_INT 9
6533: PUSH
6534: LD_INT 10
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: LIST
6541: PUSH
6542: LD_OWVAR 67
6546: ARRAY
6547: PPUSH
6548: LD_INT 3000
6550: PUSH
6551: LD_INT 500
6553: PUSH
6554: LD_INT 150
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: LIST
6561: PPUSH
6562: LD_INT 16
6564: PUSH
6565: LD_INT 6
6567: PUSH
6568: LD_INT 6
6570: PUSH
6571: LD_INT 8
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PPUSH
6580: CALL 59516 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
6584: LD_ADDR_EXP 74
6588: PUSH
6589: LD_EXP 74
6593: PPUSH
6594: LD_INT 3
6596: PPUSH
6597: LD_INT 22
6599: PUSH
6600: LD_VAR 0 3
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: PUSH
6609: LD_INT 23
6611: PUSH
6612: LD_INT 2
6614: PUSH
6615: EMPTY
6616: LIST
6617: LIST
6618: PUSH
6619: LD_INT 3
6621: PUSH
6622: LD_INT 21
6624: PUSH
6625: LD_INT 2
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: LIST
6640: PPUSH
6641: CALL_OW 69
6645: PUSH
6646: LD_EXP 49
6650: DIFF
6651: PPUSH
6652: CALL_OW 1
6656: ST_TO_ADDR
// end ;
6657: LD_VAR 0 1
6661: RET
// export function BuildKozlovBomb ; begin
6662: LD_INT 0
6664: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
6665: LD_INT 332
6667: PPUSH
6668: CALL_OW 302
6672: NOT
6673: PUSH
6674: LD_INT 336
6676: PPUSH
6677: CALL_OW 302
6681: NOT
6682: OR
6683: IFFALSE 6687
// exit ;
6685: GO 6784
// ComChangeProfession ( Kozlov , 4 ) ;
6687: LD_EXP 50
6691: PPUSH
6692: LD_INT 4
6694: PPUSH
6695: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
6699: LD_INT 336
6701: PPUSH
6702: LD_INT 25
6704: PPUSH
6705: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
6709: LD_INT 35
6711: PPUSH
6712: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
6716: LD_INT 25
6718: PPUSH
6719: LD_INT 8
6721: PPUSH
6722: CALL_OW 321
6726: PUSH
6727: LD_INT 2
6729: EQUAL
6730: IFFALSE 6709
// ComExitBuilding ( Kozlov ) ;
6732: LD_EXP 50
6736: PPUSH
6737: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
6741: LD_EXP 50
6745: PPUSH
6746: LD_INT 332
6748: PPUSH
6749: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
6753: LD_EXP 50
6757: PPUSH
6758: LD_INT 3
6760: PPUSH
6761: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
6765: LD_INT 332
6767: PPUSH
6768: LD_INT 23
6770: PPUSH
6771: LD_INT 3
6773: PPUSH
6774: LD_INT 1
6776: PPUSH
6777: LD_INT 48
6779: PPUSH
6780: CALL_OW 125
// end ;
6784: LD_VAR 0 1
6788: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
6789: LD_EXP 3
6793: NOT
6794: PUSH
6795: LD_INT 3
6797: PPUSH
6798: LD_INT 1
6800: PPUSH
6801: CALL 44564 0 2
6805: NOT
6806: AND
6807: IFFALSE 7647
6809: GO 6811
6811: DISABLE
6812: LD_INT 0
6814: PPUSH
6815: PPUSH
6816: PPUSH
// begin enable ;
6817: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6818: LD_INT 22
6820: PUSH
6821: LD_INT 8
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: PUSH
6828: LD_INT 23
6830: PUSH
6831: LD_INT 2
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: PUSH
6838: LD_INT 30
6840: PUSH
6841: LD_INT 3
6843: PUSH
6844: EMPTY
6845: LIST
6846: LIST
6847: PUSH
6848: EMPTY
6849: LIST
6850: LIST
6851: LIST
6852: PPUSH
6853: CALL_OW 69
6857: NOT
6858: IFFALSE 6862
// exit ;
6860: GO 7647
// if Prob ( 40 ) then
6862: LD_INT 40
6864: PPUSH
6865: CALL_OW 13
6869: IFFALSE 6996
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6871: LD_INT 3
6873: PPUSH
6874: LD_INT 14
6876: PUSH
6877: LD_INT 1
6879: PUSH
6880: LD_INT 2
6882: PUSH
6883: LD_INT 28
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: LIST
6890: LIST
6891: PUSH
6892: LD_INT 14
6894: PUSH
6895: LD_INT 1
6897: PUSH
6898: LD_INT 2
6900: PUSH
6901: LD_INT 28
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: LIST
6908: LIST
6909: PUSH
6910: LD_INT 14
6912: PUSH
6913: LD_INT 1
6915: PUSH
6916: LD_INT 2
6918: PUSH
6919: LD_INT 28
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: LIST
6926: LIST
6927: PUSH
6928: LD_INT 14
6930: PUSH
6931: LD_INT 1
6933: PUSH
6934: LD_INT 2
6936: PUSH
6937: LD_INT 28
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_INT 14
6948: PUSH
6949: LD_INT 1
6951: PUSH
6952: LD_INT 2
6954: PUSH
6955: LD_INT 28
6957: PUSH
6958: EMPTY
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: PUSH
6964: LD_INT 14
6966: PUSH
6967: LD_INT 1
6969: PUSH
6970: LD_INT 2
6972: PUSH
6973: LD_INT 26
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: LIST
6980: LIST
6981: PUSH
6982: EMPTY
6983: LIST
6984: LIST
6985: LIST
6986: LIST
6987: LIST
6988: LIST
6989: PPUSH
6990: CALL 43146 0 2
// end else
6994: GO 7187
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6996: LD_INT 3
6998: PPUSH
6999: LD_INT 14
7001: PUSH
7002: LD_INT 1
7004: PUSH
7005: LD_INT 2
7007: PUSH
7008: LD_INT 27
7010: PUSH
7011: LD_INT 26
7013: PUSH
7014: LD_INT 26
7016: PUSH
7017: EMPTY
7018: LIST
7019: LIST
7020: LIST
7021: PUSH
7022: LD_OWVAR 67
7026: ARRAY
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: PUSH
7034: LD_INT 14
7036: PUSH
7037: LD_INT 1
7039: PUSH
7040: LD_INT 2
7042: PUSH
7043: LD_INT 27
7045: PUSH
7046: LD_INT 26
7048: PUSH
7049: LD_INT 26
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: PUSH
7057: LD_OWVAR 67
7061: ARRAY
7062: PUSH
7063: EMPTY
7064: LIST
7065: LIST
7066: LIST
7067: LIST
7068: PUSH
7069: LD_INT 14
7071: PUSH
7072: LD_INT 1
7074: PUSH
7075: LD_INT 2
7077: PUSH
7078: LD_INT 26
7080: PUSH
7081: LD_INT 26
7083: PUSH
7084: LD_INT 29
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_OWVAR 67
7096: ARRAY
7097: PUSH
7098: EMPTY
7099: LIST
7100: LIST
7101: LIST
7102: LIST
7103: PUSH
7104: LD_INT 13
7106: PUSH
7107: LD_INT 1
7109: PUSH
7110: LD_INT 2
7112: PUSH
7113: LD_INT 26
7115: PUSH
7116: LD_INT 29
7118: PUSH
7119: LD_INT 29
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: LIST
7126: PUSH
7127: LD_OWVAR 67
7131: ARRAY
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: LIST
7137: LIST
7138: PUSH
7139: LD_INT 13
7141: PUSH
7142: LD_INT 1
7144: PUSH
7145: LD_INT 2
7147: PUSH
7148: LD_INT 29
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PUSH
7157: LD_INT 14
7159: PUSH
7160: LD_INT 1
7162: PUSH
7163: LD_INT 2
7165: PUSH
7166: LD_INT 26
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: PUSH
7175: EMPTY
7176: LIST
7177: LIST
7178: LIST
7179: LIST
7180: LIST
7181: LIST
7182: PPUSH
7183: CALL 43146 0 2
// end ; repeat wait ( 0 0$1 ) ;
7187: LD_INT 35
7189: PPUSH
7190: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7194: LD_INT 3
7196: PPUSH
7197: LD_INT 1
7199: PPUSH
7200: CALL 44564 0 2
7204: PUSH
7205: LD_INT 6
7207: GREATEREQUAL
7208: IFFALSE 7187
// wait ( 0 0$30 ) ;
7210: LD_INT 1050
7212: PPUSH
7213: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7217: LD_ADDR_VAR 0 2
7221: PUSH
7222: LD_INT 3
7224: PPUSH
7225: LD_INT 1
7227: PPUSH
7228: CALL 44564 0 2
7232: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7233: LD_ADDR_EXP 93
7237: PUSH
7238: LD_EXP 93
7242: PPUSH
7243: LD_INT 3
7245: PPUSH
7246: LD_EXP 93
7250: PUSH
7251: LD_INT 3
7253: ARRAY
7254: PUSH
7255: LD_VAR 0 2
7259: DIFF
7260: PPUSH
7261: CALL_OW 1
7265: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7266: LD_ADDR_VAR 0 3
7270: PUSH
7271: LD_INT 0
7273: PPUSH
7274: LD_INT 2
7276: PPUSH
7277: CALL_OW 12
7281: ST_TO_ADDR
// if target then
7282: LD_VAR 0 3
7286: IFFALSE 7414
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7288: LD_ADDR_VAR 0 2
7292: PUSH
7293: LD_VAR 0 2
7297: PPUSH
7298: LD_INT 24
7300: PUSH
7301: LD_INT 250
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: PPUSH
7308: CALL_OW 72
7312: ST_TO_ADDR
// for i in tmp do
7313: LD_ADDR_VAR 0 1
7317: PUSH
7318: LD_VAR 0 2
7322: PUSH
7323: FOR_IN
7324: IFFALSE 7364
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7326: LD_VAR 0 1
7330: PPUSH
7331: LD_INT 89
7333: PPUSH
7334: LD_INT 71
7336: PPUSH
7337: CALL_OW 297
7341: PUSH
7342: LD_INT 9
7344: GREATER
7345: IFFALSE 7362
// ComMoveXY ( i , 89 , 71 ) ;
7347: LD_VAR 0 1
7351: PPUSH
7352: LD_INT 89
7354: PPUSH
7355: LD_INT 71
7357: PPUSH
7358: CALL_OW 111
7362: GO 7323
7364: POP
7365: POP
// wait ( 0 0$1 ) ;
7366: LD_INT 35
7368: PPUSH
7369: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7373: LD_VAR 0 2
7377: PPUSH
7378: LD_INT 92
7380: PUSH
7381: LD_INT 89
7383: PUSH
7384: LD_INT 71
7386: PUSH
7387: LD_INT 9
7389: PUSH
7390: EMPTY
7391: LIST
7392: LIST
7393: LIST
7394: LIST
7395: PPUSH
7396: CALL_OW 72
7400: PUSH
7401: LD_VAR 0 2
7405: PUSH
7406: LD_INT 1
7408: MINUS
7409: GREATEREQUAL
7410: IFFALSE 7288
// end else
7412: GO 7538
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7414: LD_ADDR_VAR 0 2
7418: PUSH
7419: LD_VAR 0 2
7423: PPUSH
7424: LD_INT 24
7426: PUSH
7427: LD_INT 250
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: PPUSH
7434: CALL_OW 72
7438: ST_TO_ADDR
// for i in tmp do
7439: LD_ADDR_VAR 0 1
7443: PUSH
7444: LD_VAR 0 2
7448: PUSH
7449: FOR_IN
7450: IFFALSE 7490
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7452: LD_VAR 0 1
7456: PPUSH
7457: LD_INT 147
7459: PPUSH
7460: LD_INT 4
7462: PPUSH
7463: CALL_OW 297
7467: PUSH
7468: LD_INT 9
7470: GREATER
7471: IFFALSE 7488
// ComMoveXY ( i , 147 , 4 ) ;
7473: LD_VAR 0 1
7477: PPUSH
7478: LD_INT 147
7480: PPUSH
7481: LD_INT 4
7483: PPUSH
7484: CALL_OW 111
7488: GO 7449
7490: POP
7491: POP
// wait ( 0 0$1 ) ;
7492: LD_INT 35
7494: PPUSH
7495: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7499: LD_VAR 0 2
7503: PPUSH
7504: LD_INT 92
7506: PUSH
7507: LD_INT 147
7509: PUSH
7510: LD_INT 4
7512: PUSH
7513: LD_INT 9
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: LIST
7520: LIST
7521: PPUSH
7522: CALL_OW 72
7526: PUSH
7527: LD_VAR 0 2
7531: PUSH
7532: LD_INT 1
7534: MINUS
7535: GREATEREQUAL
7536: IFFALSE 7414
// end ; repeat wait ( 0 0$1 ) ;
7538: LD_INT 35
7540: PPUSH
7541: CALL_OW 67
// for i in tmp do
7545: LD_ADDR_VAR 0 1
7549: PUSH
7550: LD_VAR 0 2
7554: PUSH
7555: FOR_IN
7556: IFFALSE 7638
// begin if GetLives ( i ) > 251 then
7558: LD_VAR 0 1
7562: PPUSH
7563: CALL_OW 256
7567: PUSH
7568: LD_INT 251
7570: GREATER
7571: IFFALSE 7609
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
7573: LD_VAR 0 1
7577: PPUSH
7578: LD_INT 81
7580: PUSH
7581: LD_INT 8
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PPUSH
7588: CALL_OW 69
7592: PPUSH
7593: LD_VAR 0 1
7597: PPUSH
7598: CALL_OW 74
7602: PPUSH
7603: CALL_OW 115
7607: GO 7636
// if IsDead ( i ) then
7609: LD_VAR 0 1
7613: PPUSH
7614: CALL_OW 301
7618: IFFALSE 7636
// tmp := tmp diff i ;
7620: LD_ADDR_VAR 0 2
7624: PUSH
7625: LD_VAR 0 2
7629: PUSH
7630: LD_VAR 0 1
7634: DIFF
7635: ST_TO_ADDR
// end ;
7636: GO 7555
7638: POP
7639: POP
// until not tmp ;
7640: LD_VAR 0 2
7644: NOT
7645: IFFALSE 7538
// end ;
7647: PPOPN 3
7649: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
7650: LD_EXP 50
7654: PPUSH
7655: CALL_OW 302
7659: PUSH
7660: LD_EXP 3
7664: NOT
7665: AND
7666: IFFALSE 7675
7668: GO 7670
7670: DISABLE
// BuildKozlovBomb ;
7671: CALL 6662 0 0
7675: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
7676: LD_INT 22
7678: PUSH
7679: LD_INT 8
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 34
7688: PUSH
7689: LD_INT 48
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PPUSH
7700: CALL_OW 69
7704: IFFALSE 7752
7706: GO 7708
7708: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
7709: LD_INT 22
7711: PUSH
7712: LD_INT 8
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: PUSH
7719: LD_INT 34
7721: PUSH
7722: LD_INT 48
7724: PUSH
7725: EMPTY
7726: LIST
7727: LIST
7728: PUSH
7729: EMPTY
7730: LIST
7731: LIST
7732: PPUSH
7733: CALL_OW 69
7737: PUSH
7738: LD_INT 1
7740: ARRAY
7741: PPUSH
7742: LD_INT 173
7744: PPUSH
7745: LD_INT 96
7747: PPUSH
7748: CALL_OW 116
// end ; end_of_file
7752: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7753: LD_INT 0
7755: PPUSH
7756: PPUSH
7757: PPUSH
7758: PPUSH
7759: PPUSH
7760: PPUSH
7761: PPUSH
7762: PPUSH
7763: PPUSH
// side := 3 ;
7764: LD_ADDR_VAR 0 6
7768: PUSH
7769: LD_INT 3
7771: ST_TO_ADDR
// InitHc ;
7772: CALL_OW 19
// uc_side := side ;
7776: LD_ADDR_OWVAR 20
7780: PUSH
7781: LD_VAR 0 6
7785: ST_TO_ADDR
// uc_nation := 3 ;
7786: LD_ADDR_OWVAR 21
7790: PUSH
7791: LD_INT 3
7793: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7794: LD_ADDR_VAR 0 2
7798: PUSH
7799: LD_INT 22
7801: PUSH
7802: LD_VAR 0 6
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PUSH
7811: LD_INT 21
7813: PUSH
7814: LD_INT 3
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: PPUSH
7825: CALL_OW 69
7829: PUSH
7830: FOR_IN
7831: IFFALSE 7847
// SetBLevel ( i , 10 ) ;
7833: LD_VAR 0 2
7837: PPUSH
7838: LD_INT 10
7840: PPUSH
7841: CALL_OW 241
7845: GO 7830
7847: POP
7848: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7849: LD_ADDR_VAR 0 9
7853: PUSH
7854: LD_INT 22
7856: PUSH
7857: LD_VAR 0 6
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PUSH
7866: LD_INT 30
7868: PUSH
7869: LD_INT 34
7871: PUSH
7872: EMPTY
7873: LIST
7874: LIST
7875: PUSH
7876: EMPTY
7877: LIST
7878: LIST
7879: PPUSH
7880: CALL_OW 69
7884: ST_TO_ADDR
// if teleport then
7885: LD_VAR 0 9
7889: IFFALSE 7910
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7891: LD_VAR 0 9
7895: PUSH
7896: LD_INT 1
7898: ARRAY
7899: PPUSH
7900: LD_INT 123
7902: PPUSH
7903: LD_INT 122
7905: PPUSH
7906: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7910: LD_ADDR_EXP 51
7914: PUSH
7915: LD_STRING Platonov
7917: PPUSH
7918: CALL_OW 25
7922: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7923: LD_ADDR_EXP 52
7927: PUSH
7928: LD_STRING Yakotich
7930: PPUSH
7931: CALL_OW 25
7935: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7936: LD_ADDR_EXP 53
7940: PUSH
7941: LD_STRING Gleb
7943: PPUSH
7944: CALL_OW 25
7948: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7949: LD_STRING 03_Cornel
7951: PPUSH
7952: CALL_OW 28
7956: IFFALSE 8004
// begin Bierezov := NewCharacter ( Mikhail ) ;
7958: LD_ADDR_EXP 54
7962: PUSH
7963: LD_STRING Mikhail
7965: PPUSH
7966: CALL_OW 25
7970: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7971: LD_EXP 54
7975: PPUSH
7976: LD_INT 197
7978: PPUSH
7979: LD_INT 111
7981: PPUSH
7982: LD_INT 9
7984: PPUSH
7985: LD_INT 0
7987: PPUSH
7988: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7992: LD_EXP 54
7996: PPUSH
7997: LD_INT 3
7999: PPUSH
8000: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8004: LD_EXP 51
8008: PPUSH
8009: LD_INT 126
8011: PPUSH
8012: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8016: LD_EXP 52
8020: PPUSH
8021: LD_INT 197
8023: PPUSH
8024: LD_INT 111
8026: PPUSH
8027: LD_INT 9
8029: PPUSH
8030: LD_INT 0
8032: PPUSH
8033: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8037: LD_EXP 53
8041: PPUSH
8042: LD_INT 197
8044: PPUSH
8045: LD_INT 111
8047: PPUSH
8048: LD_INT 9
8050: PPUSH
8051: LD_INT 0
8053: PPUSH
8054: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8058: LD_ADDR_VAR 0 5
8062: PUSH
8063: LD_INT 126
8065: PPUSH
8066: LD_INT 2
8068: PPUSH
8069: LD_STRING zhukov
8071: PPUSH
8072: LD_INT 9
8074: PUSH
8075: LD_INT 10
8077: PUSH
8078: LD_INT 10
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: LIST
8085: PUSH
8086: LD_OWVAR 67
8090: ARRAY
8091: PPUSH
8092: LD_INT 90000
8094: PUSH
8095: LD_INT 1000
8097: PUSH
8098: LD_INT 300
8100: PUSH
8101: EMPTY
8102: LIST
8103: LIST
8104: LIST
8105: PPUSH
8106: LD_INT 21
8108: PUSH
8109: LD_INT 8
8111: PUSH
8112: LD_INT 13
8114: PUSH
8115: LD_INT 8
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: LIST
8122: LIST
8123: PPUSH
8124: CALL 59516 0 6
8128: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8129: LD_ADDR_VAR 0 4
8133: PUSH
8134: LD_INT 267
8136: PPUSH
8137: CALL_OW 274
8141: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8142: LD_VAR 0 4
8146: PPUSH
8147: LD_INT 1
8149: PPUSH
8150: LD_INT 5000
8152: PPUSH
8153: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8157: LD_VAR 0 4
8161: PPUSH
8162: LD_INT 2
8164: PPUSH
8165: LD_INT 200
8167: PPUSH
8168: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8172: LD_VAR 0 4
8176: PPUSH
8177: LD_INT 3
8179: PPUSH
8180: LD_INT 200
8182: PPUSH
8183: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8187: LD_ADDR_EXP 74
8191: PUSH
8192: LD_EXP 74
8196: PPUSH
8197: LD_INT 2
8199: PPUSH
8200: LD_VAR 0 5
8204: PUSH
8205: LD_INT 22
8207: PUSH
8208: LD_VAR 0 6
8212: PUSH
8213: EMPTY
8214: LIST
8215: LIST
8216: PUSH
8217: LD_INT 3
8219: PUSH
8220: LD_INT 21
8222: PUSH
8223: LD_INT 2
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PUSH
8234: EMPTY
8235: LIST
8236: LIST
8237: PPUSH
8238: CALL_OW 69
8242: UNION
8243: PUSH
8244: LD_EXP 51
8248: DIFF
8249: PPUSH
8250: CALL_OW 1
8254: ST_TO_ADDR
// behemoths := [ ] ;
8255: LD_ADDR_EXP 55
8259: PUSH
8260: EMPTY
8261: ST_TO_ADDR
// behemothBuilders := [ ] ;
8262: LD_ADDR_EXP 56
8266: PUSH
8267: EMPTY
8268: ST_TO_ADDR
// j := 3 ;
8269: LD_ADDR_VAR 0 3
8273: PUSH
8274: LD_INT 3
8276: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8277: LD_ADDR_VAR 0 2
8281: PUSH
8282: LD_INT 22
8284: PUSH
8285: LD_INT 3
8287: PUSH
8288: EMPTY
8289: LIST
8290: LIST
8291: PUSH
8292: LD_INT 25
8294: PUSH
8295: LD_INT 3
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: PPUSH
8306: CALL_OW 69
8310: PUSH
8311: FOR_IN
8312: IFFALSE 8362
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8314: LD_ADDR_EXP 56
8318: PUSH
8319: LD_EXP 56
8323: PPUSH
8324: LD_VAR 0 2
8328: PPUSH
8329: CALL 91852 0 2
8333: ST_TO_ADDR
// j := j - 1 ;
8334: LD_ADDR_VAR 0 3
8338: PUSH
8339: LD_VAR 0 3
8343: PUSH
8344: LD_INT 1
8346: MINUS
8347: ST_TO_ADDR
// if j = 0 then
8348: LD_VAR 0 3
8352: PUSH
8353: LD_INT 0
8355: EQUAL
8356: IFFALSE 8360
// break ;
8358: GO 8362
// end ;
8360: GO 8311
8362: POP
8363: POP
// end ;
8364: LD_VAR 0 1
8368: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8369: LD_INT 0
8371: PPUSH
8372: PPUSH
8373: PPUSH
8374: PPUSH
8375: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8376: LD_ADDR_VAR 0 4
8380: PUSH
8381: LD_INT 209
8383: PUSH
8384: LD_INT 149
8386: PUSH
8387: EMPTY
8388: LIST
8389: LIST
8390: PUSH
8391: LD_INT 219
8393: PUSH
8394: LD_INT 154
8396: PUSH
8397: EMPTY
8398: LIST
8399: LIST
8400: PUSH
8401: LD_INT 223
8403: PUSH
8404: LD_INT 149
8406: PUSH
8407: EMPTY
8408: LIST
8409: LIST
8410: PUSH
8411: LD_INT 232
8413: PUSH
8414: LD_INT 155
8416: PUSH
8417: EMPTY
8418: LIST
8419: LIST
8420: PUSH
8421: EMPTY
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: ST_TO_ADDR
// if not behemothBuilders then
8427: LD_EXP 56
8431: NOT
8432: IFFALSE 8436
// exit ;
8434: GO 8540
// j := 1 ;
8436: LD_ADDR_VAR 0 3
8440: PUSH
8441: LD_INT 1
8443: ST_TO_ADDR
// for i in behemothBuilders do
8444: LD_ADDR_VAR 0 2
8448: PUSH
8449: LD_EXP 56
8453: PUSH
8454: FOR_IN
8455: IFFALSE 8538
// begin if IsInUnit ( i ) then
8457: LD_VAR 0 2
8461: PPUSH
8462: CALL_OW 310
8466: IFFALSE 8477
// ComExitBuilding ( i ) ;
8468: LD_VAR 0 2
8472: PPUSH
8473: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8477: LD_VAR 0 2
8481: PPUSH
8482: LD_INT 37
8484: PPUSH
8485: LD_VAR 0 4
8489: PUSH
8490: LD_VAR 0 3
8494: ARRAY
8495: PUSH
8496: LD_INT 1
8498: ARRAY
8499: PPUSH
8500: LD_VAR 0 4
8504: PUSH
8505: LD_VAR 0 3
8509: ARRAY
8510: PUSH
8511: LD_INT 2
8513: ARRAY
8514: PPUSH
8515: LD_INT 0
8517: PPUSH
8518: CALL_OW 230
// j := j + 1 ;
8522: LD_ADDR_VAR 0 3
8526: PUSH
8527: LD_VAR 0 3
8531: PUSH
8532: LD_INT 1
8534: PLUS
8535: ST_TO_ADDR
// end ;
8536: GO 8454
8538: POP
8539: POP
// end ;
8540: LD_VAR 0 1
8544: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8545: LD_INT 3
8547: PPUSH
8548: CALL 91900 0 1
8552: PUSH
8553: LD_INT 22
8555: PUSH
8556: LD_INT 3
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: LD_INT 30
8565: PUSH
8566: LD_INT 37
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: NOT
8582: AND
8583: IFFALSE 8769
8585: GO 8587
8587: DISABLE
8588: LD_INT 0
8590: PPUSH
8591: PPUSH
// begin enable ;
8592: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8593: LD_ADDR_VAR 0 2
8597: PUSH
8598: LD_INT 3
8600: PPUSH
8601: CALL 91900 0 1
8605: ST_TO_ADDR
// for i in tmp do
8606: LD_ADDR_VAR 0 1
8610: PUSH
8611: LD_VAR 0 2
8615: PUSH
8616: FOR_IN
8617: IFFALSE 8767
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8619: LD_VAR 0 1
8623: PPUSH
8624: LD_INT 7
8626: PPUSH
8627: CALL_OW 308
8631: PUSH
8632: LD_VAR 0 1
8636: PPUSH
8637: CALL_OW 110
8641: PUSH
8642: LD_INT 2
8644: EQUAL
8645: NOT
8646: AND
8647: IFFALSE 8661
// SetTag ( i , 2 ) ;
8649: LD_VAR 0 1
8653: PPUSH
8654: LD_INT 2
8656: PPUSH
8657: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8661: LD_INT 81
8663: PUSH
8664: LD_INT 3
8666: PUSH
8667: EMPTY
8668: LIST
8669: LIST
8670: PUSH
8671: LD_INT 91
8673: PUSH
8674: LD_VAR 0 1
8678: PUSH
8679: LD_INT 12
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: LIST
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PPUSH
8691: CALL_OW 69
8695: NOT
8696: PUSH
8697: LD_VAR 0 1
8701: PPUSH
8702: CALL_OW 110
8706: PUSH
8707: LD_INT 2
8709: EQUAL
8710: NOT
8711: AND
8712: IFFALSE 8731
// ComAgressiveMove ( i , 64 , 93 ) else
8714: LD_VAR 0 1
8718: PPUSH
8719: LD_INT 64
8721: PPUSH
8722: LD_INT 93
8724: PPUSH
8725: CALL_OW 114
8729: GO 8765
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8731: LD_VAR 0 1
8735: PPUSH
8736: LD_INT 81
8738: PUSH
8739: LD_INT 3
8741: PUSH
8742: EMPTY
8743: LIST
8744: LIST
8745: PPUSH
8746: CALL_OW 69
8750: PPUSH
8751: LD_VAR 0 1
8755: PPUSH
8756: CALL_OW 74
8760: PPUSH
8761: CALL_OW 115
// end ;
8765: GO 8616
8767: POP
8768: POP
// end ;
8769: PPOPN 2
8771: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
8772: LD_EXP 2
8776: NOT
8777: PUSH
8778: LD_INT 2
8780: PPUSH
8781: LD_INT 1
8783: PPUSH
8784: CALL 44564 0 2
8788: NOT
8789: AND
8790: IFFALSE 9710
8792: GO 8794
8794: DISABLE
8795: LD_INT 0
8797: PPUSH
8798: PPUSH
8799: PPUSH
8800: PPUSH
// begin enable ;
8801: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8802: LD_INT 22
8804: PUSH
8805: LD_INT 3
8807: PUSH
8808: EMPTY
8809: LIST
8810: LIST
8811: PUSH
8812: LD_INT 30
8814: PUSH
8815: LD_INT 3
8817: PUSH
8818: EMPTY
8819: LIST
8820: LIST
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: PPUSH
8826: CALL_OW 69
8830: NOT
8831: IFFALSE 8835
// exit ;
8833: GO 9710
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
8835: LD_ADDR_VAR 0 4
8839: PUSH
8840: LD_INT 22
8842: PUSH
8843: LD_INT 3
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 30
8852: PUSH
8853: LD_INT 34
8855: PUSH
8856: EMPTY
8857: LIST
8858: LIST
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PPUSH
8864: CALL_OW 69
8868: ST_TO_ADDR
// if Prob ( 40 ) then
8869: LD_INT 40
8871: PPUSH
8872: CALL_OW 13
8876: IFFALSE 9003
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
8878: LD_INT 2
8880: PPUSH
8881: LD_INT 22
8883: PUSH
8884: LD_INT 3
8886: PUSH
8887: LD_INT 3
8889: PUSH
8890: LD_INT 49
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: LIST
8898: PUSH
8899: LD_INT 22
8901: PUSH
8902: LD_INT 3
8904: PUSH
8905: LD_INT 3
8907: PUSH
8908: LD_INT 49
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: LIST
8915: LIST
8916: PUSH
8917: LD_INT 22
8919: PUSH
8920: LD_INT 3
8922: PUSH
8923: LD_INT 3
8925: PUSH
8926: LD_INT 49
8928: PUSH
8929: EMPTY
8930: LIST
8931: LIST
8932: LIST
8933: LIST
8934: PUSH
8935: LD_INT 24
8937: PUSH
8938: LD_INT 3
8940: PUSH
8941: LD_INT 3
8943: PUSH
8944: LD_INT 46
8946: PUSH
8947: EMPTY
8948: LIST
8949: LIST
8950: LIST
8951: LIST
8952: PUSH
8953: LD_INT 24
8955: PUSH
8956: LD_INT 3
8958: PUSH
8959: LD_INT 3
8961: PUSH
8962: LD_INT 46
8964: PUSH
8965: EMPTY
8966: LIST
8967: LIST
8968: LIST
8969: LIST
8970: PUSH
8971: LD_INT 24
8973: PUSH
8974: LD_INT 3
8976: PUSH
8977: LD_INT 3
8979: PUSH
8980: LD_INT 46
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: LIST
8987: LIST
8988: PUSH
8989: EMPTY
8990: LIST
8991: LIST
8992: LIST
8993: LIST
8994: LIST
8995: LIST
8996: PPUSH
8997: CALL 43146 0 2
// end else
9001: GO 9126
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9003: LD_INT 2
9005: PPUSH
9006: LD_INT 24
9008: PUSH
9009: LD_INT 3
9011: PUSH
9012: LD_INT 3
9014: PUSH
9015: LD_INT 47
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 24
9026: PUSH
9027: LD_INT 3
9029: PUSH
9030: LD_INT 3
9032: PUSH
9033: LD_INT 47
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: LIST
9040: LIST
9041: PUSH
9042: LD_INT 24
9044: PUSH
9045: LD_INT 3
9047: PUSH
9048: LD_INT 3
9050: PUSH
9051: LD_INT 47
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: LIST
9058: LIST
9059: PUSH
9060: LD_INT 24
9062: PUSH
9063: LD_INT 3
9065: PUSH
9066: LD_INT 3
9068: PUSH
9069: LD_INT 46
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: LIST
9076: LIST
9077: PUSH
9078: LD_INT 24
9080: PUSH
9081: LD_INT 3
9083: PUSH
9084: LD_INT 3
9086: PUSH
9087: LD_INT 46
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: LIST
9094: LIST
9095: PUSH
9096: LD_INT 24
9098: PUSH
9099: LD_INT 3
9101: PUSH
9102: LD_INT 3
9104: PUSH
9105: LD_INT 46
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: LIST
9112: LIST
9113: PUSH
9114: EMPTY
9115: LIST
9116: LIST
9117: LIST
9118: LIST
9119: LIST
9120: LIST
9121: PPUSH
9122: CALL 43146 0 2
// end ; if Difficulty > 1 then
9126: LD_OWVAR 67
9130: PUSH
9131: LD_INT 1
9133: GREATER
9134: IFFALSE 9164
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9136: LD_INT 2
9138: PPUSH
9139: LD_INT 24
9141: PUSH
9142: LD_INT 3
9144: PUSH
9145: LD_INT 3
9147: PUSH
9148: LD_INT 47
9150: PUSH
9151: EMPTY
9152: LIST
9153: LIST
9154: LIST
9155: LIST
9156: PUSH
9157: EMPTY
9158: LIST
9159: PPUSH
9160: CALL 43146 0 2
// repeat wait ( 0 0$1 ) ;
9164: LD_INT 35
9166: PPUSH
9167: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9171: LD_INT 2
9173: PPUSH
9174: LD_INT 1
9176: PPUSH
9177: CALL 44564 0 2
9181: PUSH
9182: LD_INT 6
9184: PUSH
9185: LD_INT 7
9187: PUSH
9188: LD_INT 7
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: LIST
9195: PUSH
9196: LD_OWVAR 67
9200: ARRAY
9201: GREATEREQUAL
9202: IFFALSE 9164
// wait ( 0 0$30 ) ;
9204: LD_INT 1050
9206: PPUSH
9207: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9211: LD_ADDR_VAR 0 2
9215: PUSH
9216: LD_INT 2
9218: PPUSH
9219: LD_INT 1
9221: PPUSH
9222: CALL 44564 0 2
9226: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9227: LD_ADDR_EXP 93
9231: PUSH
9232: LD_EXP 93
9236: PPUSH
9237: LD_INT 2
9239: PPUSH
9240: LD_EXP 93
9244: PUSH
9245: LD_INT 2
9247: ARRAY
9248: PUSH
9249: LD_VAR 0 2
9253: DIFF
9254: PPUSH
9255: CALL_OW 1
9259: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9260: LD_ADDR_VAR 0 3
9264: PUSH
9265: LD_INT 0
9267: PPUSH
9268: LD_INT 1
9270: PPUSH
9271: CALL_OW 12
9275: ST_TO_ADDR
// if target then
9276: LD_VAR 0 3
9280: IFFALSE 9408
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9282: LD_ADDR_VAR 0 2
9286: PUSH
9287: LD_VAR 0 2
9291: PPUSH
9292: LD_INT 24
9294: PUSH
9295: LD_INT 250
9297: PUSH
9298: EMPTY
9299: LIST
9300: LIST
9301: PPUSH
9302: CALL_OW 72
9306: ST_TO_ADDR
// for i in tmp do
9307: LD_ADDR_VAR 0 1
9311: PUSH
9312: LD_VAR 0 2
9316: PUSH
9317: FOR_IN
9318: IFFALSE 9358
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9320: LD_VAR 0 1
9324: PPUSH
9325: LD_INT 139
9327: PPUSH
9328: LD_INT 89
9330: PPUSH
9331: CALL_OW 297
9335: PUSH
9336: LD_INT 9
9338: GREATER
9339: IFFALSE 9356
// ComMoveXY ( i , 139 , 89 ) ;
9341: LD_VAR 0 1
9345: PPUSH
9346: LD_INT 139
9348: PPUSH
9349: LD_INT 89
9351: PPUSH
9352: CALL_OW 111
9356: GO 9317
9358: POP
9359: POP
// wait ( 0 0$1 ) ;
9360: LD_INT 35
9362: PPUSH
9363: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9367: LD_VAR 0 2
9371: PPUSH
9372: LD_INT 92
9374: PUSH
9375: LD_INT 139
9377: PUSH
9378: LD_INT 89
9380: PUSH
9381: LD_INT 9
9383: PUSH
9384: EMPTY
9385: LIST
9386: LIST
9387: LIST
9388: LIST
9389: PPUSH
9390: CALL_OW 72
9394: PUSH
9395: LD_VAR 0 2
9399: PUSH
9400: LD_INT 1
9402: MINUS
9403: GREATEREQUAL
9404: IFFALSE 9282
// end else
9406: GO 9550
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9408: LD_VAR 0 2
9412: PPUSH
9413: LD_VAR 0 4
9417: PUSH
9418: LD_INT 1
9420: ARRAY
9421: PPUSH
9422: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9426: LD_ADDR_VAR 0 2
9430: PUSH
9431: LD_VAR 0 2
9435: PPUSH
9436: LD_INT 24
9438: PUSH
9439: LD_INT 250
9441: PUSH
9442: EMPTY
9443: LIST
9444: LIST
9445: PPUSH
9446: CALL_OW 72
9450: ST_TO_ADDR
// for i in tmp do
9451: LD_ADDR_VAR 0 1
9455: PUSH
9456: LD_VAR 0 2
9460: PUSH
9461: FOR_IN
9462: IFFALSE 9502
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9464: LD_VAR 0 1
9468: PPUSH
9469: LD_INT 124
9471: PPUSH
9472: LD_INT 139
9474: PPUSH
9475: CALL_OW 297
9479: PUSH
9480: LD_INT 9
9482: GREATER
9483: IFFALSE 9500
// ComMoveXY ( i , 124 , 139 ) ;
9485: LD_VAR 0 1
9489: PPUSH
9490: LD_INT 124
9492: PPUSH
9493: LD_INT 139
9495: PPUSH
9496: CALL_OW 111
9500: GO 9461
9502: POP
9503: POP
// wait ( 0 0$1 ) ;
9504: LD_INT 35
9506: PPUSH
9507: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9511: LD_VAR 0 2
9515: PPUSH
9516: LD_INT 92
9518: PUSH
9519: LD_INT 124
9521: PUSH
9522: LD_INT 139
9524: PUSH
9525: LD_INT 9
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: PPUSH
9534: CALL_OW 72
9538: PUSH
9539: LD_VAR 0 2
9543: PUSH
9544: LD_INT 1
9546: MINUS
9547: GREATEREQUAL
9548: IFFALSE 9426
// end ; repeat wait ( 0 0$1 ) ;
9550: LD_INT 35
9552: PPUSH
9553: CALL_OW 67
// for i in tmp do
9557: LD_ADDR_VAR 0 1
9561: PUSH
9562: LD_VAR 0 2
9566: PUSH
9567: FOR_IN
9568: IFFALSE 9701
// begin if GetLives ( i ) > 251 then
9570: LD_VAR 0 1
9574: PPUSH
9575: CALL_OW 256
9579: PUSH
9580: LD_INT 251
9582: GREATER
9583: IFFALSE 9672
// begin if GetWeapon ( i ) = ru_time_lapser then
9585: LD_VAR 0 1
9589: PPUSH
9590: CALL_OW 264
9594: PUSH
9595: LD_INT 49
9597: EQUAL
9598: IFFALSE 9636
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
9600: LD_VAR 0 1
9604: PPUSH
9605: LD_INT 81
9607: PUSH
9608: LD_INT 3
9610: PUSH
9611: EMPTY
9612: LIST
9613: LIST
9614: PPUSH
9615: CALL_OW 69
9619: PPUSH
9620: LD_VAR 0 1
9624: PPUSH
9625: CALL_OW 74
9629: PPUSH
9630: CALL_OW 112
9634: GO 9670
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9636: LD_VAR 0 1
9640: PPUSH
9641: LD_INT 81
9643: PUSH
9644: LD_INT 3
9646: PUSH
9647: EMPTY
9648: LIST
9649: LIST
9650: PPUSH
9651: CALL_OW 69
9655: PPUSH
9656: LD_VAR 0 1
9660: PPUSH
9661: CALL_OW 74
9665: PPUSH
9666: CALL_OW 115
// end else
9670: GO 9699
// if IsDead ( i ) then
9672: LD_VAR 0 1
9676: PPUSH
9677: CALL_OW 301
9681: IFFALSE 9699
// tmp := tmp diff i ;
9683: LD_ADDR_VAR 0 2
9687: PUSH
9688: LD_VAR 0 2
9692: PUSH
9693: LD_VAR 0 1
9697: DIFF
9698: ST_TO_ADDR
// end ;
9699: GO 9567
9701: POP
9702: POP
// until not tmp ;
9703: LD_VAR 0 2
9707: NOT
9708: IFFALSE 9550
// end ;
9710: PPOPN 4
9712: END
// every 30 30$00 trigger not russianDestroyed do
9713: LD_EXP 2
9717: NOT
9718: IFFALSE 9783
9720: GO 9722
9722: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
9723: LD_INT 105000
9725: PUSH
9726: LD_INT 84000
9728: PUSH
9729: LD_INT 63000
9731: PUSH
9732: EMPTY
9733: LIST
9734: LIST
9735: LIST
9736: PUSH
9737: LD_OWVAR 67
9741: ARRAY
9742: PPUSH
9743: CALL_OW 67
// if russianDestroyed then
9747: LD_EXP 2
9751: IFFALSE 9755
// exit ;
9753: GO 9783
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
9755: LD_INT 2
9757: PPUSH
9758: LD_INT 23
9760: PUSH
9761: LD_INT 3
9763: PUSH
9764: LD_INT 1
9766: PUSH
9767: LD_INT 48
9769: PUSH
9770: EMPTY
9771: LIST
9772: LIST
9773: LIST
9774: LIST
9775: PUSH
9776: EMPTY
9777: LIST
9778: PPUSH
9779: CALL 43146 0 2
// end ; end_of_file
9783: END
// export function CustomEvent ( event ) ; begin
9784: LD_INT 0
9786: PPUSH
// end ;
9787: LD_VAR 0 2
9791: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
9792: LD_VAR 0 2
9796: PPUSH
9797: LD_VAR 0 3
9801: PPUSH
9802: LD_INT 15
9804: PPUSH
9805: CALL_OW 309
9809: IFFALSE 9818
// YouLost ( MothContaminate ) ;
9811: LD_STRING MothContaminate
9813: PPUSH
9814: CALL_OW 104
// end ;
9818: PPOPN 3
9820: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
9821: LD_VAR 0 2
9825: PPUSH
9826: LD_VAR 0 3
9830: PPUSH
9831: LD_INT 15
9833: PPUSH
9834: CALL_OW 309
9838: IFFALSE 9854
// begin wait ( 0 0$6 ) ;
9840: LD_INT 210
9842: PPUSH
9843: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
9847: LD_STRING MothContaminateBomb
9849: PPUSH
9850: CALL_OW 104
// end ; end ;
9854: PPOPN 3
9856: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9857: LD_VAR 0 1
9861: PUSH
9862: LD_EXP 12
9866: EQUAL
9867: IFFALSE 9878
// begin YouLost ( JMM ) ;
9869: LD_STRING JMM
9871: PPUSH
9872: CALL_OW 104
// exit ;
9876: GO 9927
// end ; if un = Powell then
9878: LD_VAR 0 1
9882: PUSH
9883: LD_EXP 47
9887: EQUAL
9888: IFFALSE 9898
// americanDestroyed := true ;
9890: LD_ADDR_EXP 4
9894: PUSH
9895: LD_INT 1
9897: ST_TO_ADDR
// if un = Platonov then
9898: LD_VAR 0 1
9902: PUSH
9903: LD_EXP 51
9907: EQUAL
9908: IFFALSE 9918
// russianDestroyed := true ;
9910: LD_ADDR_EXP 2
9914: PUSH
9915: LD_INT 1
9917: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
9918: LD_VAR 0 1
9922: PPUSH
9923: CALL 46538 0 1
// end ;
9927: PPOPN 1
9929: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9930: LD_VAR 0 1
9934: PPUSH
9935: LD_VAR 0 2
9939: PPUSH
9940: CALL 48738 0 2
// end ;
9944: PPOPN 2
9946: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
9947: LD_VAR 0 1
9951: PPUSH
9952: CALL 47806 0 1
// end ;
9956: PPOPN 1
9958: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
9959: LD_VAR 0 1
9963: PUSH
9964: LD_INT 22
9966: PUSH
9967: LD_INT 8
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PUSH
9974: LD_INT 30
9976: PUSH
9977: LD_INT 2
9979: PUSH
9980: EMPTY
9981: LIST
9982: LIST
9983: PUSH
9984: LD_INT 23
9986: PUSH
9987: LD_INT 3
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: PPUSH
9999: CALL_OW 69
10003: IN
10004: IFFALSE 10031
// begin ComUpgrade ( building ) ;
10006: LD_VAR 0 1
10010: PPUSH
10011: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10015: LD_EXP 50
10019: PPUSH
10020: LD_VAR 0 1
10024: PPUSH
10025: CALL 59080 0 2
// exit ;
10029: GO 10040
// end ; MCE_BuildingComplete ( building ) ;
10031: LD_VAR 0 1
10035: PPUSH
10036: CALL 48047 0 1
// end ;
10040: PPOPN 1
10042: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10043: LD_VAR 0 1
10047: PPUSH
10048: LD_VAR 0 2
10052: PPUSH
10053: CALL 46234 0 2
// end ;
10057: PPOPN 2
10059: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10060: LD_VAR 0 1
10064: PPUSH
10065: LD_VAR 0 2
10069: PPUSH
10070: LD_VAR 0 3
10074: PPUSH
10075: LD_VAR 0 4
10079: PPUSH
10080: LD_VAR 0 5
10084: PPUSH
10085: CALL 45854 0 5
// end ;
10089: PPOPN 5
10091: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10092: LD_VAR 0 1
10096: PPUSH
10097: LD_VAR 0 2
10101: PPUSH
10102: CALL 45450 0 2
// end ;
10106: PPOPN 2
10108: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10109: LD_VAR 0 1
10113: PPUSH
10114: LD_VAR 0 2
10118: PPUSH
10119: LD_VAR 0 3
10123: PPUSH
10124: LD_VAR 0 4
10128: PPUSH
10129: CALL 45288 0 4
// end ;
10133: PPOPN 4
10135: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10136: LD_VAR 0 1
10140: PPUSH
10141: LD_VAR 0 2
10145: PPUSH
10146: LD_VAR 0 3
10150: PPUSH
10151: CALL 45063 0 3
// end ;
10155: PPOPN 3
10157: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10158: LD_VAR 0 1
10162: PPUSH
10163: LD_VAR 0 2
10167: PPUSH
10168: CALL 44948 0 2
// end ;
10172: PPOPN 2
10174: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10175: LD_VAR 0 1
10179: PPUSH
10180: LD_VAR 0 2
10184: PPUSH
10185: CALL 48999 0 2
// end ;
10189: PPOPN 2
10191: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10192: LD_VAR 0 1
10196: PPUSH
10197: LD_VAR 0 2
10201: PPUSH
10202: LD_VAR 0 3
10206: PPUSH
10207: LD_VAR 0 4
10211: PPUSH
10212: CALL 49215 0 4
// end ;
10216: PPOPN 4
10218: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10219: LD_VAR 0 1
10223: PPUSH
10224: LD_VAR 0 2
10228: PPUSH
10229: CALL 44757 0 2
// end ;
10233: PPOPN 2
10235: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10236: LD_VAR 0 1
10240: PPUSH
10241: CALL 92252 0 1
// end ; end_of_file
10245: PPOPN 1
10247: END
// export function Action ; begin
10248: LD_INT 0
10250: PPUSH
// InGameOn ;
10251: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10255: LD_INT 206
10257: PPUSH
10258: LD_INT 11
10260: PPUSH
10261: CALL_OW 86
// wait ( 0 0$1 ) ;
10265: LD_INT 35
10267: PPUSH
10268: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10272: LD_EXP 12
10276: PPUSH
10277: LD_STRING DStart-JMM-JMM-1
10279: PPUSH
10280: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10284: LD_EXP 44
10288: PPUSH
10289: LD_STRING DStart-JMM-Bur-1
10291: PPUSH
10292: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10296: LD_EXP 12
10300: PPUSH
10301: LD_STRING DStart-JMM-JMM-2
10303: PPUSH
10304: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10308: LD_EXP 44
10312: PPUSH
10313: LD_STRING DStart-JMM-Bur-2
10315: PPUSH
10316: CALL_OW 88
// InGameOff ;
10320: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10324: LD_STRING MStart
10326: PPUSH
10327: CALL_OW 337
// end ;
10331: LD_VAR 0 1
10335: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10336: LD_INT 7
10338: PPUSH
10339: LD_INT 255
10341: PPUSH
10342: LD_INT 219
10344: PPUSH
10345: CALL_OW 293
10349: IFFALSE 10958
10351: GO 10353
10353: DISABLE
10354: LD_INT 0
10356: PPUSH
// begin wait ( 0 0$3 ) ;
10357: LD_INT 105
10359: PPUSH
10360: CALL_OW 67
// alienSpotted := true ;
10364: LD_ADDR_EXP 7
10368: PUSH
10369: LD_INT 1
10371: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10372: LD_ADDR_VAR 0 1
10376: PUSH
10377: LD_INT 22
10379: PUSH
10380: LD_INT 7
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 23
10389: PUSH
10390: LD_INT 3
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: PUSH
10397: LD_INT 21
10399: PUSH
10400: LD_INT 1
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: PUSH
10407: LD_INT 26
10409: PUSH
10410: LD_INT 1
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: PUSH
10417: EMPTY
10418: LIST
10419: LIST
10420: LIST
10421: LIST
10422: PPUSH
10423: CALL_OW 69
10427: PUSH
10428: LD_EXP 44
10432: PUSH
10433: LD_EXP 32
10437: PUSH
10438: LD_EXP 34
10442: PUSH
10443: LD_EXP 35
10447: PUSH
10448: LD_EXP 42
10452: PUSH
10453: LD_EXP 41
10457: PUSH
10458: LD_EXP 36
10462: PUSH
10463: EMPTY
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: LIST
10470: LIST
10471: DIFF
10472: ST_TO_ADDR
// DialogueOn ;
10473: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
10477: LD_INT 255
10479: PPUSH
10480: LD_INT 219
10482: PPUSH
10483: LD_INT 7
10485: PPUSH
10486: LD_INT 20
10488: NEG
10489: PPUSH
10490: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
10494: LD_INT 255
10496: PPUSH
10497: LD_INT 219
10499: PPUSH
10500: CALL_OW 86
// if speaker then
10504: LD_VAR 0 1
10508: IFFALSE 10526
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
10510: LD_VAR 0 1
10514: PUSH
10515: LD_INT 1
10517: ARRAY
10518: PPUSH
10519: LD_STRING DAlienBase-RSol1-1
10521: PPUSH
10522: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
10526: LD_EXP 12
10530: PPUSH
10531: LD_STRING DAlienBase-JMM-1
10533: PPUSH
10534: CALL_OW 88
// if IsOk ( Burlak ) then
10538: LD_EXP 44
10542: PPUSH
10543: CALL_OW 302
10547: IFFALSE 10568
// begin dwait ( 0 0$1 ) ;
10549: LD_INT 35
10551: PPUSH
10552: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
10556: LD_EXP 44
10560: PPUSH
10561: LD_STRING DAlienBase-Bur-1
10563: PPUSH
10564: CALL_OW 88
// end ; if IsOk ( Roth ) then
10568: LD_EXP 13
10572: PPUSH
10573: CALL_OW 302
10577: IFFALSE 10591
// Say ( Roth , DAlienBase-Roth-1 ) ;
10579: LD_EXP 13
10583: PPUSH
10584: LD_STRING DAlienBase-Roth-1
10586: PPUSH
10587: CALL_OW 88
// if IsOk ( Gossudarov ) then
10591: LD_EXP 30
10595: PPUSH
10596: CALL_OW 302
10600: IFFALSE 10616
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
10602: LD_EXP 30
10606: PPUSH
10607: LD_STRING DAlienBase-Gos-1
10609: PPUSH
10610: CALL_OW 88
10614: GO 10733
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
10616: LD_ADDR_VAR 0 1
10620: PUSH
10621: LD_INT 22
10623: PUSH
10624: LD_INT 7
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: LD_INT 25
10633: PUSH
10634: LD_INT 4
10636: PUSH
10637: EMPTY
10638: LIST
10639: LIST
10640: PUSH
10641: LD_INT 21
10643: PUSH
10644: LD_INT 1
10646: PUSH
10647: EMPTY
10648: LIST
10649: LIST
10650: PUSH
10651: LD_INT 26
10653: PUSH
10654: LD_INT 1
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: PUSH
10661: EMPTY
10662: LIST
10663: LIST
10664: LIST
10665: LIST
10666: PPUSH
10667: CALL_OW 69
10671: PUSH
10672: LD_EXP 13
10676: PUSH
10677: LD_EXP 12
10681: PUSH
10682: LD_EXP 44
10686: PUSH
10687: LD_EXP 32
10691: PUSH
10692: LD_EXP 42
10696: PUSH
10697: LD_EXP 41
10701: PUSH
10702: EMPTY
10703: LIST
10704: LIST
10705: LIST
10706: LIST
10707: LIST
10708: LIST
10709: DIFF
10710: ST_TO_ADDR
// if speaker then
10711: LD_VAR 0 1
10715: IFFALSE 10733
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
10717: LD_VAR 0 1
10721: PUSH
10722: LD_INT 1
10724: ARRAY
10725: PPUSH
10726: LD_STRING DAlienBase-Sci1-1
10728: PPUSH
10729: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
10733: LD_INT 255
10735: PPUSH
10736: LD_INT 219
10738: PPUSH
10739: LD_INT 7
10741: PPUSH
10742: CALL_OW 331
// DialogueOff ;
10746: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
10750: LD_INT 35
10752: PPUSH
10753: CALL_OW 67
// until IsSelected ( alien ) ;
10757: LD_INT 1
10759: PPUSH
10760: CALL_OW 306
10764: IFFALSE 10750
// if not artifactIResearched or not artifactIIResearched then
10766: LD_EXP 9
10770: NOT
10771: PUSH
10772: LD_EXP 10
10776: NOT
10777: OR
10778: IFFALSE 10958
// begin if IsOk ( Roth ) then
10780: LD_EXP 13
10784: PPUSH
10785: CALL_OW 302
10789: IFFALSE 10805
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
10791: LD_EXP 13
10795: PPUSH
10796: LD_STRING DAlieBaseNotReady-Roth-1
10798: PPUSH
10799: CALL_OW 88
10803: GO 10958
// if IsOk ( Gossudarov ) then
10805: LD_EXP 30
10809: PPUSH
10810: CALL_OW 302
10814: IFFALSE 10830
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
10816: LD_EXP 30
10820: PPUSH
10821: LD_STRING DAlieBaseNotReady-Gos-1
10823: PPUSH
10824: CALL_OW 88
10828: GO 10958
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
10830: LD_ADDR_VAR 0 1
10834: PUSH
10835: LD_INT 22
10837: PUSH
10838: LD_INT 7
10840: PUSH
10841: EMPTY
10842: LIST
10843: LIST
10844: PUSH
10845: LD_INT 23
10847: PUSH
10848: LD_INT 3
10850: PUSH
10851: EMPTY
10852: LIST
10853: LIST
10854: PUSH
10855: LD_INT 25
10857: PUSH
10858: LD_INT 4
10860: PUSH
10861: EMPTY
10862: LIST
10863: LIST
10864: PUSH
10865: LD_INT 21
10867: PUSH
10868: LD_INT 1
10870: PUSH
10871: EMPTY
10872: LIST
10873: LIST
10874: PUSH
10875: LD_INT 26
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PUSH
10885: EMPTY
10886: LIST
10887: LIST
10888: LIST
10889: LIST
10890: LIST
10891: PPUSH
10892: CALL_OW 69
10896: PUSH
10897: LD_EXP 13
10901: PUSH
10902: LD_EXP 12
10906: PUSH
10907: LD_EXP 44
10911: PUSH
10912: LD_EXP 32
10916: PUSH
10917: LD_EXP 42
10921: PUSH
10922: LD_EXP 41
10926: PUSH
10927: EMPTY
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: LIST
10933: LIST
10934: DIFF
10935: ST_TO_ADDR
// if speaker then
10936: LD_VAR 0 1
10940: IFFALSE 10958
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
10942: LD_VAR 0 1
10946: PUSH
10947: LD_INT 1
10949: ARRAY
10950: PPUSH
10951: LD_STRING DAlieBaseNotReady-RSci1-1
10953: PPUSH
10954: CALL_OW 88
// end ; end ; end ;
10958: PPOPN 1
10960: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
10961: LD_INT 24
10963: PPUSH
10964: LD_INT 7
10966: PPUSH
10967: CALL_OW 321
10971: PUSH
10972: LD_INT 2
10974: EQUAL
10975: IFFALSE 11666
10977: GO 10979
10979: DISABLE
10980: LD_INT 0
10982: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
10983: LD_ADDR_VAR 0 1
10987: PUSH
10988: LD_INT 22
10990: PUSH
10991: LD_INT 7
10993: PUSH
10994: EMPTY
10995: LIST
10996: LIST
10997: PUSH
10998: LD_INT 23
11000: PUSH
11001: LD_INT 3
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PUSH
11008: LD_INT 25
11010: PUSH
11011: LD_INT 4
11013: PUSH
11014: EMPTY
11015: LIST
11016: LIST
11017: PUSH
11018: LD_INT 21
11020: PUSH
11021: LD_INT 1
11023: PUSH
11024: EMPTY
11025: LIST
11026: LIST
11027: PUSH
11028: LD_INT 26
11030: PUSH
11031: LD_INT 1
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PUSH
11038: EMPTY
11039: LIST
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: PPUSH
11045: CALL_OW 69
11049: PUSH
11050: LD_EXP 13
11054: PUSH
11055: LD_EXP 12
11059: PUSH
11060: LD_EXP 44
11064: PUSH
11065: LD_EXP 32
11069: PUSH
11070: LD_EXP 42
11074: PUSH
11075: LD_EXP 41
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: LIST
11084: LIST
11085: LIST
11086: LIST
11087: DIFF
11088: ST_TO_ADDR
// if not speaker then
11089: LD_VAR 0 1
11093: NOT
11094: IFFALSE 11098
// exit ;
11096: GO 11666
// DialogueOn ;
11098: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11102: LD_VAR 0 1
11106: PUSH
11107: LD_INT 1
11109: ARRAY
11110: PPUSH
11111: LD_STRING DArtefTechnology-RSci1-1
11113: PPUSH
11114: CALL_OW 88
// if IsOk ( Burlak ) then
11118: LD_EXP 44
11122: PPUSH
11123: CALL_OW 302
11127: IFFALSE 11141
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11129: LD_EXP 44
11133: PPUSH
11134: LD_STRING DArtefTechnology-Bur-1
11136: PPUSH
11137: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11141: LD_VAR 0 1
11145: PUSH
11146: LD_INT 1
11148: ARRAY
11149: PPUSH
11150: LD_STRING DArtefTechnology-RSci1-2
11152: PPUSH
11153: CALL_OW 88
// if Denis then
11157: LD_EXP 18
11161: IFFALSE 11178
// speaker := [ Denis ] else
11163: LD_ADDR_VAR 0 1
11167: PUSH
11168: LD_EXP 18
11172: PUSH
11173: EMPTY
11174: LIST
11175: ST_TO_ADDR
11176: GO 11284
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11178: LD_ADDR_VAR 0 1
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 7
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PUSH
11193: LD_INT 23
11195: PUSH
11196: LD_INT 1
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: LD_INT 25
11205: PUSH
11206: LD_INT 4
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: LD_INT 21
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PUSH
11223: LD_INT 26
11225: PUSH
11226: LD_INT 1
11228: PUSH
11229: EMPTY
11230: LIST
11231: LIST
11232: PUSH
11233: EMPTY
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: PPUSH
11240: CALL_OW 69
11244: PUSH
11245: LD_EXP 13
11249: PUSH
11250: LD_EXP 12
11254: PUSH
11255: LD_EXP 44
11259: PUSH
11260: LD_EXP 32
11264: PUSH
11265: LD_EXP 42
11269: PUSH
11270: LD_EXP 41
11274: PUSH
11275: EMPTY
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: DIFF
11283: ST_TO_ADDR
// if speaker then
11284: LD_VAR 0 1
11288: IFFALSE 11306
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11290: LD_VAR 0 1
11294: PUSH
11295: LD_INT 1
11297: ARRAY
11298: PPUSH
11299: LD_STRING DArtefTechnology-Sci1-2
11301: PPUSH
11302: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11306: LD_ADDR_VAR 0 1
11310: PUSH
11311: LD_INT 22
11313: PUSH
11314: LD_INT 7
11316: PUSH
11317: EMPTY
11318: LIST
11319: LIST
11320: PUSH
11321: LD_INT 23
11323: PUSH
11324: LD_INT 3
11326: PUSH
11327: EMPTY
11328: LIST
11329: LIST
11330: PUSH
11331: LD_INT 25
11333: PUSH
11334: LD_INT 4
11336: PUSH
11337: EMPTY
11338: LIST
11339: LIST
11340: PUSH
11341: LD_INT 21
11343: PUSH
11344: LD_INT 1
11346: PUSH
11347: EMPTY
11348: LIST
11349: LIST
11350: PUSH
11351: LD_INT 26
11353: PUSH
11354: LD_INT 1
11356: PUSH
11357: EMPTY
11358: LIST
11359: LIST
11360: PUSH
11361: EMPTY
11362: LIST
11363: LIST
11364: LIST
11365: LIST
11366: LIST
11367: PPUSH
11368: CALL_OW 69
11372: PUSH
11373: LD_EXP 13
11377: PUSH
11378: LD_EXP 12
11382: PUSH
11383: LD_EXP 44
11387: PUSH
11388: LD_EXP 32
11392: PUSH
11393: LD_EXP 42
11397: PUSH
11398: LD_EXP 41
11402: PUSH
11403: EMPTY
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: DIFF
11411: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
11412: LD_VAR 0 1
11416: PUSH
11417: LD_EXP 6
11421: PUSH
11422: LD_EXP 5
11426: OR
11427: AND
11428: IFFALSE 11662
// begin if arabianDestroyed and IsOk ( Burlak ) then
11430: LD_EXP 5
11434: PUSH
11435: LD_EXP 44
11439: PPUSH
11440: CALL_OW 302
11444: AND
11445: IFFALSE 11461
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
11447: LD_EXP 44
11451: PPUSH
11452: LD_STRING DArtefTechnology-Bur-2
11454: PPUSH
11455: CALL_OW 88
11459: GO 11473
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
11461: LD_EXP 12
11465: PPUSH
11466: LD_STRING DArtefTechnology-JMM-2
11468: PPUSH
11469: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
11473: LD_VAR 0 1
11477: PUSH
11478: LD_INT 1
11480: ARRAY
11481: PPUSH
11482: LD_STRING DArtefTechnology-RSci1-3
11484: PPUSH
11485: CALL_OW 88
// if Denis then
11489: LD_EXP 18
11493: IFFALSE 11510
// speaker := [ Denis ] else
11495: LD_ADDR_VAR 0 1
11499: PUSH
11500: LD_EXP 18
11504: PUSH
11505: EMPTY
11506: LIST
11507: ST_TO_ADDR
11508: GO 11616
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11510: LD_ADDR_VAR 0 1
11514: PUSH
11515: LD_INT 22
11517: PUSH
11518: LD_INT 7
11520: PUSH
11521: EMPTY
11522: LIST
11523: LIST
11524: PUSH
11525: LD_INT 23
11527: PUSH
11528: LD_INT 1
11530: PUSH
11531: EMPTY
11532: LIST
11533: LIST
11534: PUSH
11535: LD_INT 25
11537: PUSH
11538: LD_INT 4
11540: PUSH
11541: EMPTY
11542: LIST
11543: LIST
11544: PUSH
11545: LD_INT 21
11547: PUSH
11548: LD_INT 1
11550: PUSH
11551: EMPTY
11552: LIST
11553: LIST
11554: PUSH
11555: LD_INT 26
11557: PUSH
11558: LD_INT 1
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: PUSH
11565: EMPTY
11566: LIST
11567: LIST
11568: LIST
11569: LIST
11570: LIST
11571: PPUSH
11572: CALL_OW 69
11576: PUSH
11577: LD_EXP 13
11581: PUSH
11582: LD_EXP 12
11586: PUSH
11587: LD_EXP 44
11591: PUSH
11592: LD_EXP 32
11596: PUSH
11597: LD_EXP 42
11601: PUSH
11602: LD_EXP 41
11606: PUSH
11607: EMPTY
11608: LIST
11609: LIST
11610: LIST
11611: LIST
11612: LIST
11613: LIST
11614: DIFF
11615: ST_TO_ADDR
// if speaker then
11616: LD_VAR 0 1
11620: IFFALSE 11662
// if alienSpotted then
11622: LD_EXP 7
11626: IFFALSE 11646
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
11628: LD_VAR 0 1
11632: PUSH
11633: LD_INT 1
11635: ARRAY
11636: PPUSH
11637: LD_STRING DArtefTechnology-Sci1-3
11639: PPUSH
11640: CALL_OW 88
11644: GO 11662
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
11646: LD_VAR 0 1
11650: PUSH
11651: LD_INT 1
11653: ARRAY
11654: PPUSH
11655: LD_STRING DArtefTechnology-Sci1-3a
11657: PPUSH
11658: CALL_OW 88
// end ; DialogueOff ;
11662: CALL_OW 7
// end ;
11666: PPOPN 1
11668: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
11669: LD_EXP 9
11673: IFFALSE 11868
11675: GO 11677
11677: DISABLE
11678: LD_INT 0
11680: PPUSH
// begin if Denis then
11681: LD_EXP 18
11685: IFFALSE 11702
// speaker := [ Denis ] else
11687: LD_ADDR_VAR 0 1
11691: PUSH
11692: LD_EXP 18
11696: PUSH
11697: EMPTY
11698: LIST
11699: ST_TO_ADDR
11700: GO 11808
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11702: LD_ADDR_VAR 0 1
11706: PUSH
11707: LD_INT 22
11709: PUSH
11710: LD_INT 7
11712: PUSH
11713: EMPTY
11714: LIST
11715: LIST
11716: PUSH
11717: LD_INT 23
11719: PUSH
11720: LD_INT 1
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PUSH
11727: LD_INT 25
11729: PUSH
11730: LD_INT 4
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: PUSH
11737: LD_INT 21
11739: PUSH
11740: LD_INT 1
11742: PUSH
11743: EMPTY
11744: LIST
11745: LIST
11746: PUSH
11747: LD_INT 26
11749: PUSH
11750: LD_INT 1
11752: PUSH
11753: EMPTY
11754: LIST
11755: LIST
11756: PUSH
11757: EMPTY
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: PPUSH
11764: CALL_OW 69
11768: PUSH
11769: LD_EXP 13
11773: PUSH
11774: LD_EXP 12
11778: PUSH
11779: LD_EXP 44
11783: PUSH
11784: LD_EXP 32
11788: PUSH
11789: LD_EXP 42
11793: PUSH
11794: LD_EXP 41
11798: PUSH
11799: EMPTY
11800: LIST
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: DIFF
11807: ST_TO_ADDR
// if not speaker then
11808: LD_VAR 0 1
11812: NOT
11813: IFFALSE 11817
// exit ;
11815: GO 11868
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
11817: LD_VAR 0 1
11821: PUSH
11822: LD_INT 1
11824: ARRAY
11825: PPUSH
11826: LD_STRING DArtefTechnologyAm-Sci1-1
11828: PPUSH
11829: CALL_OW 88
// if IsOk ( Burlak ) then
11833: LD_EXP 44
11837: PPUSH
11838: CALL_OW 302
11842: IFFALSE 11856
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
11844: LD_EXP 44
11848: PPUSH
11849: LD_STRING DArtefTechnologyAm-Bur-1
11851: PPUSH
11852: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
11856: LD_EXP 12
11860: PPUSH
11861: LD_STRING DArtefTechnologyAm-JMM-1
11863: PPUSH
11864: CALL_OW 88
// end ;
11868: PPOPN 1
11870: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
11871: LD_EXP 10
11875: IFFALSE 12086
11877: GO 11879
11879: DISABLE
11880: LD_INT 0
11882: PPUSH
// begin if Denis then
11883: LD_EXP 18
11887: IFFALSE 11904
// speaker := [ Denis ] else
11889: LD_ADDR_VAR 0 1
11893: PUSH
11894: LD_EXP 18
11898: PUSH
11899: EMPTY
11900: LIST
11901: ST_TO_ADDR
11902: GO 12010
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11904: LD_ADDR_VAR 0 1
11908: PUSH
11909: LD_INT 22
11911: PUSH
11912: LD_INT 7
11914: PUSH
11915: EMPTY
11916: LIST
11917: LIST
11918: PUSH
11919: LD_INT 23
11921: PUSH
11922: LD_INT 3
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PUSH
11929: LD_INT 25
11931: PUSH
11932: LD_INT 4
11934: PUSH
11935: EMPTY
11936: LIST
11937: LIST
11938: PUSH
11939: LD_INT 21
11941: PUSH
11942: LD_INT 1
11944: PUSH
11945: EMPTY
11946: LIST
11947: LIST
11948: PUSH
11949: LD_INT 26
11951: PUSH
11952: LD_INT 1
11954: PUSH
11955: EMPTY
11956: LIST
11957: LIST
11958: PUSH
11959: EMPTY
11960: LIST
11961: LIST
11962: LIST
11963: LIST
11964: LIST
11965: PPUSH
11966: CALL_OW 69
11970: PUSH
11971: LD_EXP 13
11975: PUSH
11976: LD_EXP 12
11980: PUSH
11981: LD_EXP 44
11985: PUSH
11986: LD_EXP 32
11990: PUSH
11991: LD_EXP 42
11995: PUSH
11996: LD_EXP 41
12000: PUSH
12001: EMPTY
12002: LIST
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: DIFF
12009: ST_TO_ADDR
// if not speaker then
12010: LD_VAR 0 1
12014: NOT
12015: IFFALSE 12019
// exit ;
12017: GO 12086
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12019: LD_VAR 0 1
12023: PUSH
12024: LD_INT 1
12026: ARRAY
12027: PPUSH
12028: LD_STRING DArtefTechnologyRu-RSci1-1
12030: PPUSH
12031: CALL_OW 88
// if IsOk ( Burlak ) then
12035: LD_EXP 44
12039: PPUSH
12040: CALL_OW 302
12044: IFFALSE 12058
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12046: LD_EXP 44
12050: PPUSH
12051: LD_STRING DArtefTechnologyRu-Bur-1
12053: PPUSH
12054: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12058: LD_VAR 0 1
12062: PUSH
12063: LD_INT 1
12065: ARRAY
12066: PPUSH
12067: LD_STRING DArtefTechnologyRu-RSci1-2
12069: PPUSH
12070: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12074: LD_EXP 12
12078: PPUSH
12079: LD_STRING DArtefTechnologyRu-JMM-1
12081: PPUSH
12082: CALL_OW 88
// end ;
12086: PPOPN 1
12088: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12089: LD_INT 24
12091: PPUSH
12092: LD_INT 7
12094: PPUSH
12095: CALL_OW 321
12099: PUSH
12100: LD_INT 2
12102: EQUAL
12103: PUSH
12104: LD_INT 1
12106: PPUSH
12107: CALL_OW 255
12111: PUSH
12112: LD_INT 7
12114: EQUAL
12115: AND
12116: IFFALSE 12276
12118: GO 12120
12120: DISABLE
12121: LD_INT 0
12123: PPUSH
// begin if Denis then
12124: LD_EXP 18
12128: IFFALSE 12145
// speaker := [ Denis ] else
12130: LD_ADDR_VAR 0 1
12134: PUSH
12135: LD_EXP 18
12139: PUSH
12140: EMPTY
12141: LIST
12142: ST_TO_ADDR
12143: GO 12251
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12145: LD_ADDR_VAR 0 1
12149: PUSH
12150: LD_INT 22
12152: PUSH
12153: LD_INT 7
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: PUSH
12160: LD_INT 23
12162: PUSH
12163: LD_INT 1
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PUSH
12170: LD_INT 25
12172: PUSH
12173: LD_INT 4
12175: PUSH
12176: EMPTY
12177: LIST
12178: LIST
12179: PUSH
12180: LD_INT 21
12182: PUSH
12183: LD_INT 1
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: LD_INT 26
12192: PUSH
12193: LD_INT 1
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: LIST
12204: LIST
12205: LIST
12206: PPUSH
12207: CALL_OW 69
12211: PUSH
12212: LD_EXP 13
12216: PUSH
12217: LD_EXP 12
12221: PUSH
12222: LD_EXP 44
12226: PUSH
12227: LD_EXP 32
12231: PUSH
12232: LD_EXP 42
12236: PUSH
12237: LD_EXP 41
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: LIST
12248: LIST
12249: DIFF
12250: ST_TO_ADDR
// if not speaker then
12251: LD_VAR 0 1
12255: NOT
12256: IFFALSE 12260
// exit ;
12258: GO 12276
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12260: LD_VAR 0 1
12264: PUSH
12265: LD_INT 1
12267: ARRAY
12268: PPUSH
12269: LD_STRING DArtefTechnologyArStart-Sci1-1
12271: PPUSH
12272: CALL_OW 88
// end ;
12276: PPOPN 1
12278: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12279: LD_EXP 11
12283: IFFALSE 12564
12285: GO 12287
12287: DISABLE
12288: LD_INT 0
12290: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12291: LD_ADDR_VAR 0 1
12295: PUSH
12296: LD_INT 22
12298: PUSH
12299: LD_INT 7
12301: PUSH
12302: EMPTY
12303: LIST
12304: LIST
12305: PUSH
12306: LD_INT 23
12308: PUSH
12309: LD_INT 3
12311: PUSH
12312: EMPTY
12313: LIST
12314: LIST
12315: PUSH
12316: LD_INT 25
12318: PUSH
12319: LD_INT 4
12321: PUSH
12322: EMPTY
12323: LIST
12324: LIST
12325: PUSH
12326: LD_INT 21
12328: PUSH
12329: LD_INT 1
12331: PUSH
12332: EMPTY
12333: LIST
12334: LIST
12335: PUSH
12336: LD_INT 26
12338: PUSH
12339: LD_INT 1
12341: PUSH
12342: EMPTY
12343: LIST
12344: LIST
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: LIST
12350: LIST
12351: LIST
12352: PPUSH
12353: CALL_OW 69
12357: PUSH
12358: LD_EXP 13
12362: PUSH
12363: LD_EXP 12
12367: PUSH
12368: LD_EXP 44
12372: PUSH
12373: LD_EXP 32
12377: PUSH
12378: LD_EXP 42
12382: PUSH
12383: LD_EXP 41
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: LIST
12395: DIFF
12396: ST_TO_ADDR
// if not speaker then
12397: LD_VAR 0 1
12401: NOT
12402: IFFALSE 12406
// exit ;
12404: GO 12564
// DialogueOn ;
12406: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
12410: LD_VAR 0 1
12414: PUSH
12415: LD_INT 1
12417: ARRAY
12418: PPUSH
12419: LD_STRING DArtefTechnologyAr-RSci1-1
12421: PPUSH
12422: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
12426: LD_EXP 12
12430: PPUSH
12431: LD_STRING DArtefTechnologyAr-JMM-1
12433: PPUSH
12434: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
12438: LD_VAR 0 1
12442: PUSH
12443: LD_INT 1
12445: ARRAY
12446: PPUSH
12447: LD_STRING DArtefTechnologyAr-RSci1-2
12449: PPUSH
12450: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
12454: LD_EXP 12
12458: PPUSH
12459: LD_STRING DArtefTechnologyAr-JMM-2
12461: PPUSH
12462: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
12466: LD_VAR 0 1
12470: PUSH
12471: LD_INT 1
12473: ARRAY
12474: PPUSH
12475: LD_STRING DArtefTechnologyAr-RSci1-3
12477: PPUSH
12478: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
12482: LD_EXP 12
12486: PPUSH
12487: LD_STRING DArtefTechnologyAr-JMM-3
12489: PPUSH
12490: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
12494: LD_VAR 0 1
12498: PUSH
12499: LD_INT 1
12501: ARRAY
12502: PPUSH
12503: LD_STRING DArtefTechnologyAr-RSci1-4
12505: PPUSH
12506: CALL_OW 88
// if IsOk ( Burlak ) then
12510: LD_EXP 44
12514: PPUSH
12515: CALL_OW 302
12519: IFFALSE 12533
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
12521: LD_EXP 44
12525: PPUSH
12526: LD_STRING DArtefTechnologyAr-Bur-4
12528: PPUSH
12529: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
12533: LD_EXP 12
12537: PPUSH
12538: LD_STRING DArtefTechnologyAr-JMM-4
12540: PPUSH
12541: CALL_OW 88
// DialogueOff ;
12545: CALL_OW 7
// wait ( 0 0$45 ) ;
12549: LD_INT 1575
12551: PPUSH
12552: CALL_OW 67
// spawnOmar := true ;
12556: LD_ADDR_EXP 8
12560: PUSH
12561: LD_INT 1
12563: ST_TO_ADDR
// end ;
12564: PPOPN 1
12566: END
// every 0 0$1 trigger spawnOmar do
12567: LD_EXP 8
12571: IFFALSE 12869
12573: GO 12575
12575: DISABLE
// begin PrepareOmarAli ;
12576: CALL 6107 0 0
// if not Omar then
12580: LD_EXP 48
12584: NOT
12585: IFFALSE 12589
// exit ;
12587: GO 12869
// repeat wait ( 0 0$1 ) ;
12589: LD_INT 35
12591: PPUSH
12592: CALL_OW 67
// until See ( 7 , Omar ) ;
12596: LD_INT 7
12598: PPUSH
12599: LD_EXP 48
12603: PPUSH
12604: CALL_OW 292
12608: IFFALSE 12589
// CenterNowOnUnits ( Omar ) ;
12610: LD_EXP 48
12614: PPUSH
12615: CALL_OW 87
// DialogueOn ;
12619: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
12623: LD_EXP 48
12627: PPUSH
12628: LD_STRING DOmar-Omar-1
12630: PPUSH
12631: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
12635: LD_EXP 12
12639: PPUSH
12640: LD_STRING DOmar-JMM-1
12642: PPUSH
12643: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
12647: LD_EXP 48
12651: PPUSH
12652: LD_STRING DOmar-Omar-2
12654: PPUSH
12655: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
12659: LD_EXP 12
12663: PPUSH
12664: LD_STRING DOmar-JMM-2
12666: PPUSH
12667: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
12671: LD_EXP 48
12675: PPUSH
12676: LD_STRING DOmar-Omar-3
12678: PPUSH
12679: CALL_OW 88
// if IsOk ( Burlak ) then
12683: LD_EXP 44
12687: PPUSH
12688: CALL_OW 302
12692: IFFALSE 12708
// Say ( Burlak , DOmar-Bur-3 ) else
12694: LD_EXP 44
12698: PPUSH
12699: LD_STRING DOmar-Bur-3
12701: PPUSH
12702: CALL_OW 88
12706: GO 12720
// Say ( JMM , DOmar-JMM-3 ) ;
12708: LD_EXP 12
12712: PPUSH
12713: LD_STRING DOmar-JMM-3
12715: PPUSH
12716: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
12720: LD_EXP 48
12724: PPUSH
12725: LD_STRING DOmar-Omar-4
12727: PPUSH
12728: CALL_OW 88
// case Query ( QAccept ) of 1 :
12732: LD_STRING QAccept
12734: PPUSH
12735: CALL_OW 97
12739: PUSH
12740: LD_INT 1
12742: DOUBLE
12743: EQUAL
12744: IFTRUE 12748
12746: GO 12784
12748: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
12749: LD_EXP 12
12753: PPUSH
12754: LD_STRING DQrAccept#1-JMM-1
12756: PPUSH
12757: CALL_OW 88
// SetSide ( Omar , 7 ) ;
12761: LD_EXP 48
12765: PPUSH
12766: LD_INT 7
12768: PPUSH
12769: CALL_OW 235
// ComStop ( Omar ) ;
12773: LD_EXP 48
12777: PPUSH
12778: CALL_OW 141
// end ; 2 :
12782: GO 12833
12784: LD_INT 2
12786: DOUBLE
12787: EQUAL
12788: IFTRUE 12792
12790: GO 12832
12792: POP
// begin if IsOk ( Burlak ) then
12793: LD_EXP 44
12797: PPUSH
12798: CALL_OW 302
12802: IFFALSE 12818
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
12804: LD_EXP 44
12808: PPUSH
12809: LD_STRING DQrAccept#2-Bur-1
12811: PPUSH
12812: CALL_OW 88
12816: GO 12830
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
12818: LD_EXP 12
12822: PPUSH
12823: LD_STRING DQrAccept#2-JMM-1
12825: PPUSH
12826: CALL_OW 88
// end ; end ;
12830: GO 12833
12832: POP
// DialogueOff ;
12833: CALL_OW 7
// if GetSide ( Omar ) = 7 then
12837: LD_EXP 48
12841: PPUSH
12842: CALL_OW 255
12846: PUSH
12847: LD_INT 7
12849: EQUAL
12850: IFFALSE 12854
// exit ;
12852: GO 12869
// ComMoveXY ( Omar , 202 , 115 ) ;
12854: LD_EXP 48
12858: PPUSH
12859: LD_INT 202
12861: PPUSH
12862: LD_INT 115
12864: PPUSH
12865: CALL_OW 111
// end ;
12869: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
12870: LD_EXP 48
12874: PPUSH
12875: LD_INT 200
12877: PPUSH
12878: LD_INT 98
12880: PPUSH
12881: CALL_OW 297
12885: PUSH
12886: LD_INT 40
12888: LESS
12889: PUSH
12890: LD_EXP 2
12894: AND
12895: IFFALSE 13113
12897: GO 12899
12899: DISABLE
// begin SetSide ( Omar , 5 ) ;
12900: LD_EXP 48
12904: PPUSH
12905: LD_INT 5
12907: PPUSH
12908: CALL_OW 235
// if IsInUnit ( Omar ) then
12912: LD_EXP 48
12916: PPUSH
12917: CALL_OW 310
12921: IFFALSE 12932
// ComExitVehicle ( Omar ) ;
12923: LD_EXP 48
12927: PPUSH
12928: CALL_OW 121
// if IsInUnit ( Omar ) then
12932: LD_EXP 48
12936: PPUSH
12937: CALL_OW 310
12941: IFFALSE 12952
// ComExitBuilding ( Omar ) ;
12943: LD_EXP 48
12947: PPUSH
12948: CALL_OW 122
// wait ( 0 0$1 ) ;
12952: LD_INT 35
12954: PPUSH
12955: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
12959: LD_EXP 48
12963: PPUSH
12964: LD_INT 203
12966: PPUSH
12967: LD_INT 120
12969: PPUSH
12970: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
12974: LD_INT 35
12976: PPUSH
12977: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
12981: LD_EXP 48
12985: PPUSH
12986: CALL_OW 306
12990: PUSH
12991: LD_EXP 48
12995: PPUSH
12996: LD_INT 203
12998: PPUSH
12999: LD_INT 120
13001: PPUSH
13002: CALL_OW 297
13006: PUSH
13007: LD_INT 6
13009: LESS
13010: OR
13011: IFFALSE 12974
// CenterNowOnUnits ( Omar ) ;
13013: LD_EXP 48
13017: PPUSH
13018: CALL_OW 87
// DialogueOn ;
13022: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13026: LD_EXP 12
13030: PPUSH
13031: LD_STRING DOmarContam-JMM-1
13033: PPUSH
13034: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13038: LD_EXP 48
13042: PPUSH
13043: LD_STRING DOmarContam-Omar-1
13045: PPUSH
13046: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13050: LD_EXP 12
13054: PPUSH
13055: LD_STRING DOmarContam-JMM-2
13057: PPUSH
13058: CALL_OW 88
// DialogueOff ;
13062: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13066: LD_INT 5
13068: PPUSH
13069: LD_INT 7
13071: PPUSH
13072: LD_INT 2
13074: PPUSH
13075: LD_INT 1
13077: PPUSH
13078: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13082: LD_INT 105
13084: PPUSH
13085: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13089: LD_EXP 48
13093: PPUSH
13094: LD_INT 203
13096: PPUSH
13097: LD_INT 120
13099: PPUSH
13100: CALL_OW 307
13104: IFFALSE 13082
// YouLost ( MothContaminate ) ;
13106: LD_STRING MothContaminate
13108: PPUSH
13109: CALL_OW 104
// end ;
13113: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13114: LD_EXP 4
13118: NOT
13119: PUSH
13120: LD_INT 22
13122: PUSH
13123: LD_INT 1
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: PUSH
13130: LD_INT 34
13132: PUSH
13133: LD_INT 8
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: PUSH
13140: EMPTY
13141: LIST
13142: LIST
13143: PPUSH
13144: CALL_OW 69
13148: AND
13149: IFFALSE 13230
13151: GO 13153
13153: DISABLE
// begin if not IsOk ( Powell ) then
13154: LD_EXP 47
13158: PPUSH
13159: CALL_OW 302
13163: NOT
13164: IFFALSE 13168
// exit ;
13166: GO 13230
// DialogueOn ;
13168: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13172: LD_EXP 47
13176: PPUSH
13177: LD_STRING DWinAmericans-Pow-1
13179: PPUSH
13180: CALL_OW 94
// if IsOk ( Burlak ) then
13184: LD_EXP 44
13188: PPUSH
13189: CALL_OW 302
13193: IFFALSE 13207
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13195: LD_EXP 44
13199: PPUSH
13200: LD_STRING DWinAmericans-Bur-1
13202: PPUSH
13203: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13207: LD_EXP 12
13211: PPUSH
13212: LD_STRING DWinAmericans-JMM-1
13214: PPUSH
13215: CALL_OW 88
// DialogueOff ;
13219: CALL_OW 7
// YouLost ( AmBomb ) ;
13223: LD_STRING AmBomb
13225: PPUSH
13226: CALL_OW 104
// end ;
13230: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13231: LD_EXP 2
13235: NOT
13236: PUSH
13237: LD_INT 22
13239: PUSH
13240: LD_INT 3
13242: PUSH
13243: EMPTY
13244: LIST
13245: LIST
13246: PUSH
13247: LD_INT 34
13249: PUSH
13250: LD_INT 48
13252: PUSH
13253: EMPTY
13254: LIST
13255: LIST
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: PPUSH
13261: CALL_OW 69
13265: AND
13266: IFFALSE 13347
13268: GO 13270
13270: DISABLE
// begin if not IsOk ( Platonov ) then
13271: LD_EXP 51
13275: PPUSH
13276: CALL_OW 302
13280: NOT
13281: IFFALSE 13285
// exit ;
13283: GO 13347
// DialogueOn ;
13285: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13289: LD_EXP 51
13293: PPUSH
13294: LD_STRING DWinRussians-Pla-1
13296: PPUSH
13297: CALL_OW 94
// if IsOk ( Burlak ) then
13301: LD_EXP 44
13305: PPUSH
13306: CALL_OW 302
13310: IFFALSE 13324
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13312: LD_EXP 44
13316: PPUSH
13317: LD_STRING DWinRussians-Bur-1
13319: PPUSH
13320: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13324: LD_EXP 12
13328: PPUSH
13329: LD_STRING DWinRussians-JMM-1
13331: PPUSH
13332: CALL_OW 88
// DialogueOff ;
13336: CALL_OW 7
// YouLost ( RuBomb ) ;
13340: LD_STRING RuBomb
13342: PPUSH
13343: CALL_OW 104
// end ;
13347: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13348: LD_INT 7
13350: PPUSH
13351: LD_INT 22
13353: PUSH
13354: LD_INT 7
13356: PUSH
13357: EMPTY
13358: LIST
13359: LIST
13360: PPUSH
13361: CALL_OW 70
13365: PUSH
13366: LD_EXP 4
13370: NOT
13371: AND
13372: IFFALSE 13401
13374: GO 13376
13376: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13377: LD_EXP 47
13381: PPUSH
13382: LD_STRING DSurrenderAmericans-Pow-1
13384: PPUSH
13385: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
13389: LD_EXP 12
13393: PPUSH
13394: LD_STRING DSurrenderAmericans-JMM-1
13396: PPUSH
13397: CALL_OW 88
// end ;
13401: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
13402: LD_INT 2
13404: PPUSH
13405: LD_INT 22
13407: PUSH
13408: LD_INT 7
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: PPUSH
13415: CALL_OW 70
13419: PUSH
13420: LD_EXP 2
13424: NOT
13425: AND
13426: PUSH
13427: LD_EXP 44
13431: AND
13432: IFFALSE 13461
13434: GO 13436
13436: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
13437: LD_EXP 51
13441: PPUSH
13442: LD_STRING DSurrenderRussians-Pla-1
13444: PPUSH
13445: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
13449: LD_EXP 44
13453: PPUSH
13454: LD_STRING DSurrenderRussians-Bur-1
13456: PPUSH
13457: CALL_OW 88
// end ;
13461: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
13462: LD_EXP 4
13466: IFFALSE 13841
13468: GO 13470
13470: DISABLE
13471: LD_INT 0
13473: PPUSH
13474: PPUSH
13475: PPUSH
// begin MC_Kill ( 4 ) ;
13476: LD_INT 4
13478: PPUSH
13479: CALL 19798 0 1
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
13483: LD_ADDR_VAR 0 3
13487: PUSH
13488: LD_INT 22
13490: PUSH
13491: LD_INT 1
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: PUSH
13498: LD_INT 26
13500: PUSH
13501: LD_INT 1
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: PUSH
13508: LD_INT 23
13510: PUSH
13511: LD_INT 1
13513: PUSH
13514: EMPTY
13515: LIST
13516: LIST
13517: PUSH
13518: EMPTY
13519: LIST
13520: LIST
13521: LIST
13522: PPUSH
13523: CALL_OW 69
13527: PUSH
13528: LD_EXP 47
13532: PUSH
13533: LD_EXP 20
13537: PUSH
13538: LD_EXP 17
13542: PUSH
13543: LD_EXP 16
13547: PUSH
13548: LD_EXP 23
13552: PUSH
13553: LD_EXP 21
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: LIST
13562: LIST
13563: LIST
13564: LIST
13565: DIFF
13566: ST_TO_ADDR
// if speaker then
13567: LD_VAR 0 3
13571: IFFALSE 13597
// begin DialogueOn ;
13573: CALL_OW 6
// Say ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
13577: LD_VAR 0 3
13581: PUSH
13582: LD_INT 1
13584: ARRAY
13585: PPUSH
13586: LD_STRING DSurrenderAmericans-Sol1-1a
13588: PPUSH
13589: CALL_OW 88
// DialogueOff ;
13593: CALL_OW 7
// end ; SetAttitude ( 1 , 7 , att_friend , true ) ;
13597: LD_INT 1
13599: PPUSH
13600: LD_INT 7
13602: PPUSH
13603: LD_INT 1
13605: PPUSH
13606: LD_INT 1
13608: PPUSH
13609: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
13613: LD_ADDR_VAR 0 2
13617: PUSH
13618: LD_INT 22
13620: PUSH
13621: LD_INT 1
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: LD_INT 21
13630: PUSH
13631: LD_INT 1
13633: PUSH
13634: EMPTY
13635: LIST
13636: LIST
13637: PUSH
13638: EMPTY
13639: LIST
13640: LIST
13641: PPUSH
13642: CALL_OW 69
13646: PUSH
13647: LD_INT 22
13649: PUSH
13650: LD_INT 1
13652: PUSH
13653: EMPTY
13654: LIST
13655: LIST
13656: PUSH
13657: LD_INT 21
13659: PUSH
13660: LD_INT 2
13662: PUSH
13663: EMPTY
13664: LIST
13665: LIST
13666: PUSH
13667: LD_INT 1
13669: PUSH
13670: EMPTY
13671: LIST
13672: PUSH
13673: EMPTY
13674: LIST
13675: LIST
13676: LIST
13677: PPUSH
13678: CALL_OW 69
13682: ADD
13683: ST_TO_ADDR
// if tmp then
13684: LD_VAR 0 2
13688: IFFALSE 13841
// repeat wait ( 0 0$1 ) ;
13690: LD_INT 35
13692: PPUSH
13693: CALL_OW 67
// for i in tmp do
13697: LD_ADDR_VAR 0 1
13701: PUSH
13702: LD_VAR 0 2
13706: PUSH
13707: FOR_IN
13708: IFFALSE 13790
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
13710: LD_VAR 0 1
13714: PPUSH
13715: CALL_OW 310
13719: PUSH
13720: LD_VAR 0 1
13724: PPUSH
13725: CALL_OW 310
13729: PPUSH
13730: CALL_OW 247
13734: PUSH
13735: LD_INT 3
13737: EQUAL
13738: AND
13739: IFFALSE 13750
// ComExitBuilding ( i ) ;
13741: LD_VAR 0 1
13745: PPUSH
13746: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
13750: LD_VAR 0 1
13754: PPUSH
13755: LD_INT 122
13757: PPUSH
13758: LD_INT 242
13760: PPUSH
13761: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
13765: LD_VAR 0 1
13769: PPUSH
13770: LD_INT 35
13772: PPUSH
13773: CALL_OW 308
13777: IFFALSE 13788
// RemoveUnit ( i ) ;
13779: LD_VAR 0 1
13783: PPUSH
13784: CALL_OW 64
// end ;
13788: GO 13707
13790: POP
13791: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
13792: LD_INT 22
13794: PUSH
13795: LD_INT 1
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 2
13804: PUSH
13805: LD_INT 21
13807: PUSH
13808: LD_INT 1
13810: PUSH
13811: EMPTY
13812: LIST
13813: LIST
13814: PUSH
13815: LD_INT 33
13817: PUSH
13818: LD_INT 1
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PUSH
13825: EMPTY
13826: LIST
13827: LIST
13828: LIST
13829: PUSH
13830: EMPTY
13831: LIST
13832: LIST
13833: PPUSH
13834: CALL_OW 69
13838: NOT
13839: IFFALSE 13690
// end ;
13841: PPOPN 3
13843: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
13844: LD_EXP 2
13848: IFFALSE 14241
13850: GO 13852
13852: DISABLE
13853: LD_INT 0
13855: PPUSH
13856: PPUSH
13857: PPUSH
// begin repeat wait ( 0 0$1 ) ;
13858: LD_INT 35
13860: PPUSH
13861: CALL_OW 67
// until IsDead ( Yakotich ) ;
13865: LD_EXP 52
13869: PPUSH
13870: CALL_OW 301
13874: IFFALSE 13858
// MC_Kill ( 2 ) ;
13876: LD_INT 2
13878: PPUSH
13879: CALL 19798 0 1
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
13883: LD_ADDR_VAR 0 3
13887: PUSH
13888: LD_INT 22
13890: PUSH
13891: LD_INT 3
13893: PUSH
13894: EMPTY
13895: LIST
13896: LIST
13897: PUSH
13898: LD_INT 26
13900: PUSH
13901: LD_INT 1
13903: PUSH
13904: EMPTY
13905: LIST
13906: LIST
13907: PUSH
13908: LD_INT 23
13910: PUSH
13911: LD_INT 3
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: LIST
13922: PPUSH
13923: CALL_OW 69
13927: PUSH
13928: LD_EXP 51
13932: PUSH
13933: LD_EXP 52
13937: PUSH
13938: EMPTY
13939: LIST
13940: LIST
13941: DIFF
13942: ST_TO_ADDR
// if speaker then
13943: LD_VAR 0 3
13947: IFFALSE 13997
// begin DialogueOn ;
13949: CALL_OW 6
// if Burlak then
13953: LD_EXP 44
13957: IFFALSE 13977
// Say ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
13959: LD_VAR 0 3
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PPUSH
13968: LD_STRING DSurrenderRussians-RSol1-1
13970: PPUSH
13971: CALL_OW 88
13975: GO 13993
// Say ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
13977: LD_VAR 0 3
13981: PUSH
13982: LD_INT 1
13984: ARRAY
13985: PPUSH
13986: LD_STRING DSurrenderRussians-RSol1-1a
13988: PPUSH
13989: CALL_OW 88
// DialogueOff ;
13993: CALL_OW 7
// end ; SetAttitude ( 3 , 7 , att_friend , true ) ;
13997: LD_INT 3
13999: PPUSH
14000: LD_INT 7
14002: PPUSH
14003: LD_INT 1
14005: PPUSH
14006: LD_INT 1
14008: PPUSH
14009: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14013: LD_ADDR_VAR 0 2
14017: PUSH
14018: LD_INT 22
14020: PUSH
14021: LD_INT 3
14023: PUSH
14024: EMPTY
14025: LIST
14026: LIST
14027: PUSH
14028: LD_INT 21
14030: PUSH
14031: LD_INT 1
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: PPUSH
14042: CALL_OW 69
14046: PUSH
14047: LD_INT 22
14049: PUSH
14050: LD_INT 3
14052: PUSH
14053: EMPTY
14054: LIST
14055: LIST
14056: PUSH
14057: LD_INT 21
14059: PUSH
14060: LD_INT 2
14062: PUSH
14063: EMPTY
14064: LIST
14065: LIST
14066: PUSH
14067: LD_INT 1
14069: PUSH
14070: EMPTY
14071: LIST
14072: PUSH
14073: EMPTY
14074: LIST
14075: LIST
14076: LIST
14077: PPUSH
14078: CALL_OW 69
14082: ADD
14083: ST_TO_ADDR
// if tmp then
14084: LD_VAR 0 2
14088: IFFALSE 14241
// repeat wait ( 0 0$1 ) ;
14090: LD_INT 35
14092: PPUSH
14093: CALL_OW 67
// for i in tmp do
14097: LD_ADDR_VAR 0 1
14101: PUSH
14102: LD_VAR 0 2
14106: PUSH
14107: FOR_IN
14108: IFFALSE 14190
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14110: LD_VAR 0 1
14114: PPUSH
14115: CALL_OW 310
14119: PUSH
14120: LD_VAR 0 1
14124: PPUSH
14125: CALL_OW 310
14129: PPUSH
14130: CALL_OW 247
14134: PUSH
14135: LD_INT 3
14137: EQUAL
14138: AND
14139: IFFALSE 14150
// ComExitBuilding ( i ) ;
14141: LD_VAR 0 1
14145: PPUSH
14146: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14150: LD_VAR 0 1
14154: PPUSH
14155: LD_INT 154
14157: PPUSH
14158: LD_INT 1
14160: PPUSH
14161: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14165: LD_VAR 0 1
14169: PPUSH
14170: LD_INT 36
14172: PPUSH
14173: CALL_OW 308
14177: IFFALSE 14188
// RemoveUnit ( i ) ;
14179: LD_VAR 0 1
14183: PPUSH
14184: CALL_OW 64
// end ;
14188: GO 14107
14190: POP
14191: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14192: LD_INT 22
14194: PUSH
14195: LD_INT 3
14197: PUSH
14198: EMPTY
14199: LIST
14200: LIST
14201: PUSH
14202: LD_INT 2
14204: PUSH
14205: LD_INT 21
14207: PUSH
14208: LD_INT 1
14210: PUSH
14211: EMPTY
14212: LIST
14213: LIST
14214: PUSH
14215: LD_INT 33
14217: PUSH
14218: LD_INT 1
14220: PUSH
14221: EMPTY
14222: LIST
14223: LIST
14224: PUSH
14225: EMPTY
14226: LIST
14227: LIST
14228: LIST
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: PPUSH
14234: CALL_OW 69
14238: NOT
14239: IFFALSE 14090
// end ;
14241: PPOPN 3
14243: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) do
14244: LD_INT 22
14246: PUSH
14247: LD_INT 8
14249: PUSH
14250: EMPTY
14251: LIST
14252: LIST
14253: PUSH
14254: LD_INT 21
14256: PUSH
14257: LD_INT 1
14259: PUSH
14260: EMPTY
14261: LIST
14262: LIST
14263: PUSH
14264: LD_INT 23
14266: PUSH
14267: LD_INT 2
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: PUSH
14274: EMPTY
14275: LIST
14276: LIST
14277: LIST
14278: PPUSH
14279: CALL_OW 69
14283: PUSH
14284: LD_INT 18
14286: LESS
14287: PUSH
14288: LD_EXP 50
14292: PPUSH
14293: CALL_OW 301
14297: OR
14298: IFFALSE 14311
14300: GO 14302
14302: DISABLE
// legionDestroyed := true ;
14303: LD_ADDR_EXP 3
14307: PUSH
14308: LD_INT 1
14310: ST_TO_ADDR
14311: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14312: LD_INT 22
14314: PUSH
14315: LD_INT 2
14317: PUSH
14318: EMPTY
14319: LIST
14320: LIST
14321: PUSH
14322: LD_INT 21
14324: PUSH
14325: LD_INT 1
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: PUSH
14332: LD_INT 23
14334: PUSH
14335: LD_INT 2
14337: PUSH
14338: EMPTY
14339: LIST
14340: LIST
14341: PUSH
14342: EMPTY
14343: LIST
14344: LIST
14345: LIST
14346: PPUSH
14347: CALL_OW 69
14351: PUSH
14352: LD_INT 9
14354: LESS
14355: IFFALSE 14368
14357: GO 14359
14359: DISABLE
// arabianDestroyed := true ;
14360: LD_ADDR_EXP 5
14364: PUSH
14365: LD_INT 1
14367: ST_TO_ADDR
14368: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14369: LD_EXP 5
14373: IFFALSE 14633
14375: GO 14377
14377: DISABLE
14378: LD_INT 0
14380: PPUSH
14381: PPUSH
// begin MC_Kill ( 1 ) ;
14382: LD_INT 1
14384: PPUSH
14385: CALL 19798 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
14389: LD_INT 2
14391: PPUSH
14392: LD_INT 7
14394: PPUSH
14395: LD_INT 1
14397: PPUSH
14398: LD_INT 1
14400: PPUSH
14401: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14405: LD_ADDR_VAR 0 2
14409: PUSH
14410: LD_INT 22
14412: PUSH
14413: LD_INT 2
14415: PUSH
14416: EMPTY
14417: LIST
14418: LIST
14419: PUSH
14420: LD_INT 21
14422: PUSH
14423: LD_INT 1
14425: PUSH
14426: EMPTY
14427: LIST
14428: LIST
14429: PUSH
14430: EMPTY
14431: LIST
14432: LIST
14433: PPUSH
14434: CALL_OW 69
14438: PUSH
14439: LD_INT 22
14441: PUSH
14442: LD_INT 8
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: LD_INT 21
14451: PUSH
14452: LD_INT 2
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: PUSH
14459: LD_INT 1
14461: PUSH
14462: EMPTY
14463: LIST
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: LIST
14469: PPUSH
14470: CALL_OW 69
14474: ADD
14475: ST_TO_ADDR
// if tmp then
14476: LD_VAR 0 2
14480: IFFALSE 14633
// repeat wait ( 0 0$1 ) ;
14482: LD_INT 35
14484: PPUSH
14485: CALL_OW 67
// for i in tmp do
14489: LD_ADDR_VAR 0 1
14493: PUSH
14494: LD_VAR 0 2
14498: PUSH
14499: FOR_IN
14500: IFFALSE 14582
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14502: LD_VAR 0 1
14506: PPUSH
14507: CALL_OW 310
14511: PUSH
14512: LD_VAR 0 1
14516: PPUSH
14517: CALL_OW 310
14521: PPUSH
14522: CALL_OW 247
14526: PUSH
14527: LD_INT 3
14529: EQUAL
14530: AND
14531: IFFALSE 14542
// ComExitBuilding ( i ) ;
14533: LD_VAR 0 1
14537: PPUSH
14538: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
14542: LD_VAR 0 1
14546: PPUSH
14547: LD_INT 254
14549: PPUSH
14550: LD_INT 268
14552: PPUSH
14553: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
14557: LD_VAR 0 1
14561: PPUSH
14562: LD_INT 34
14564: PPUSH
14565: CALL_OW 308
14569: IFFALSE 14580
// RemoveUnit ( i ) ;
14571: LD_VAR 0 1
14575: PPUSH
14576: CALL_OW 64
// end ;
14580: GO 14499
14582: POP
14583: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14584: LD_INT 22
14586: PUSH
14587: LD_INT 2
14589: PUSH
14590: EMPTY
14591: LIST
14592: LIST
14593: PUSH
14594: LD_INT 2
14596: PUSH
14597: LD_INT 21
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: EMPTY
14604: LIST
14605: LIST
14606: PUSH
14607: LD_INT 33
14609: PUSH
14610: LD_INT 1
14612: PUSH
14613: EMPTY
14614: LIST
14615: LIST
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: LIST
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: PPUSH
14626: CALL_OW 69
14630: NOT
14631: IFFALSE 14482
// end ;
14633: PPOPN 2
14635: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
14636: LD_EXP 3
14640: IFFALSE 14973
14642: GO 14644
14644: DISABLE
14645: LD_INT 0
14647: PPUSH
14648: PPUSH
// begin MC_Kill ( 3 ) ;
14649: LD_INT 3
14651: PPUSH
14652: CALL 19798 0 1
// SayRadio ( Schulz , D15-Szulc-1 ) ;
14656: LD_EXP 49
14660: PPUSH
14661: LD_STRING D15-Szulc-1
14663: PPUSH
14664: CALL_OW 94
// SetAttitude ( 8 , 7 , att_friend , true ) ;
14668: LD_INT 8
14670: PPUSH
14671: LD_INT 7
14673: PPUSH
14674: LD_INT 1
14676: PPUSH
14677: LD_INT 1
14679: PPUSH
14680: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
14684: LD_ADDR_VAR 0 1
14688: PUSH
14689: LD_INT 22
14691: PUSH
14692: LD_INT 8
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: PUSH
14699: LD_INT 21
14701: PUSH
14702: LD_INT 3
14704: PUSH
14705: EMPTY
14706: LIST
14707: LIST
14708: PUSH
14709: LD_INT 23
14711: PUSH
14712: LD_INT 3
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: LIST
14723: PPUSH
14724: CALL_OW 69
14728: PUSH
14729: FOR_IN
14730: IFFALSE 14743
// DestroyUnit ( i ) ;
14732: LD_VAR 0 1
14736: PPUSH
14737: CALL_OW 65
14741: GO 14729
14743: POP
14744: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14745: LD_ADDR_VAR 0 2
14749: PUSH
14750: LD_INT 22
14752: PUSH
14753: LD_INT 8
14755: PUSH
14756: EMPTY
14757: LIST
14758: LIST
14759: PUSH
14760: LD_INT 21
14762: PUSH
14763: LD_INT 1
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: PUSH
14770: EMPTY
14771: LIST
14772: LIST
14773: PPUSH
14774: CALL_OW 69
14778: PUSH
14779: LD_INT 22
14781: PUSH
14782: LD_INT 8
14784: PUSH
14785: EMPTY
14786: LIST
14787: LIST
14788: PUSH
14789: LD_INT 21
14791: PUSH
14792: LD_INT 2
14794: PUSH
14795: EMPTY
14796: LIST
14797: LIST
14798: PUSH
14799: LD_INT 1
14801: PUSH
14802: EMPTY
14803: LIST
14804: PUSH
14805: EMPTY
14806: LIST
14807: LIST
14808: LIST
14809: PPUSH
14810: CALL_OW 69
14814: ADD
14815: ST_TO_ADDR
// if tmp then
14816: LD_VAR 0 2
14820: IFFALSE 14973
// repeat wait ( 0 0$1 ) ;
14822: LD_INT 35
14824: PPUSH
14825: CALL_OW 67
// for i in tmp do
14829: LD_ADDR_VAR 0 1
14833: PUSH
14834: LD_VAR 0 2
14838: PUSH
14839: FOR_IN
14840: IFFALSE 14922
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14842: LD_VAR 0 1
14846: PPUSH
14847: CALL_OW 310
14851: PUSH
14852: LD_VAR 0 1
14856: PPUSH
14857: CALL_OW 310
14861: PPUSH
14862: CALL_OW 247
14866: PUSH
14867: LD_INT 3
14869: EQUAL
14870: AND
14871: IFFALSE 14882
// ComExitBuilding ( i ) ;
14873: LD_VAR 0 1
14877: PPUSH
14878: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
14882: LD_VAR 0 1
14886: PPUSH
14887: LD_INT 10
14889: PPUSH
14890: LD_INT 1
14892: PPUSH
14893: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
14897: LD_VAR 0 1
14901: PPUSH
14902: LD_INT 32
14904: PPUSH
14905: CALL_OW 308
14909: IFFALSE 14920
// RemoveUnit ( i ) ;
14911: LD_VAR 0 1
14915: PPUSH
14916: CALL_OW 64
// end ;
14920: GO 14839
14922: POP
14923: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14924: LD_INT 22
14926: PUSH
14927: LD_INT 8
14929: PUSH
14930: EMPTY
14931: LIST
14932: LIST
14933: PUSH
14934: LD_INT 2
14936: PUSH
14937: LD_INT 21
14939: PUSH
14940: LD_INT 1
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PUSH
14947: LD_INT 33
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: EMPTY
14954: LIST
14955: LIST
14956: PUSH
14957: EMPTY
14958: LIST
14959: LIST
14960: LIST
14961: PUSH
14962: EMPTY
14963: LIST
14964: LIST
14965: PPUSH
14966: CALL_OW 69
14970: NOT
14971: IFFALSE 14822
// end ;
14973: PPOPN 2
14975: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do
14976: LD_EXP 4
14980: PUSH
14981: LD_EXP 2
14985: AND
14986: PUSH
14987: LD_EXP 3
14991: AND
14992: PUSH
14993: LD_EXP 5
14997: AND
14998: IFFALSE 16234
15000: GO 15002
15002: DISABLE
// begin CenterNowOnUnits ( JMM ) ;
15003: LD_EXP 12
15007: PPUSH
15008: CALL_OW 87
// InGameOn ;
15012: CALL_OW 8
// DialogueOn ;
15016: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15020: LD_EXP 12
15024: PPUSH
15025: LD_STRING DEnd-JMM-JMM-1
15027: PPUSH
15028: CALL_OW 88
// if Joan then
15032: LD_EXP 27
15036: IFFALSE 15052
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15038: LD_EXP 27
15042: PPUSH
15043: LD_STRING DEnd-JMM-Joan-1
15045: PPUSH
15046: CALL_OW 88
15050: GO 15096
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15052: LD_EXP 14
15056: PUSH
15057: LD_EXP 14
15061: PPUSH
15062: CALL_OW 255
15066: PUSH
15067: LD_INT 7
15069: EQUAL
15070: AND
15071: PUSH
15072: LD_EXP 14
15076: PPUSH
15077: CALL_OW 305
15081: AND
15082: IFFALSE 15096
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15084: LD_EXP 14
15088: PPUSH
15089: LD_STRING DEnd-JMM-Lisa-1
15091: PPUSH
15092: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15096: LD_EXP 24
15100: PUSH
15101: LD_EXP 24
15105: PPUSH
15106: CALL_OW 305
15110: AND
15111: IFFALSE 15125
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15113: LD_EXP 24
15117: PPUSH
15118: LD_STRING DEnd-JMM-Frank-1
15120: PPUSH
15121: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15125: LD_EXP 17
15129: PUSH
15130: LD_EXP 17
15134: PPUSH
15135: CALL_OW 255
15139: PUSH
15140: LD_INT 7
15142: EQUAL
15143: AND
15144: PUSH
15145: LD_EXP 17
15149: PPUSH
15150: CALL_OW 305
15154: AND
15155: IFFALSE 15169
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15157: LD_EXP 17
15161: PPUSH
15162: LD_STRING DEnd-JMM-Cyrus-1
15164: PPUSH
15165: CALL_OW 88
// if Burlak then
15169: LD_EXP 44
15173: IFFALSE 15187
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15175: LD_EXP 44
15179: PPUSH
15180: LD_STRING DEnd-JMM-Bur-1
15182: PPUSH
15183: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15187: LD_EXP 27
15191: PUSH
15192: LD_EXP 14
15196: AND
15197: PUSH
15198: LD_EXP 14
15202: PPUSH
15203: CALL_OW 255
15207: PUSH
15208: LD_INT 7
15210: EQUAL
15211: AND
15212: PUSH
15213: LD_EXP 14
15217: PPUSH
15218: CALL_OW 305
15222: AND
15223: IFFALSE 15237
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15225: LD_EXP 14
15229: PPUSH
15230: LD_STRING DEnd-Burlak-Lisa-1
15232: PPUSH
15233: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15237: LD_EXP 45
15241: PUSH
15242: LD_EXP 45
15246: PPUSH
15247: CALL_OW 305
15251: AND
15252: IFFALSE 15266
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15254: LD_EXP 45
15258: PPUSH
15259: LD_STRING DEnd-JMM-Bel-1
15261: PPUSH
15262: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15266: LD_EXP 46
15270: PUSH
15271: LD_EXP 46
15275: PPUSH
15276: CALL_OW 305
15280: AND
15281: IFFALSE 15295
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15283: LD_EXP 46
15287: PPUSH
15288: LD_STRING DEnd-JMM-Gny-1
15290: PPUSH
15291: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15295: LD_EXP 22
15299: PUSH
15300: LD_EXP 22
15304: PPUSH
15305: CALL_OW 255
15309: PUSH
15310: LD_INT 7
15312: EQUAL
15313: AND
15314: PUSH
15315: LD_EXP 22
15319: PPUSH
15320: CALL_OW 305
15324: AND
15325: IFFALSE 15339
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
15327: LD_EXP 22
15331: PPUSH
15332: LD_STRING DEnd-JMM-Corn-1
15334: PPUSH
15335: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
15339: LD_EXP 15
15343: PUSH
15344: LD_EXP 15
15348: PPUSH
15349: CALL_OW 255
15353: PUSH
15354: LD_INT 7
15356: EQUAL
15357: AND
15358: PUSH
15359: LD_EXP 15
15363: PPUSH
15364: CALL_OW 305
15368: AND
15369: IFFALSE 15383
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
15371: LD_EXP 15
15375: PPUSH
15376: LD_STRING DEnd-JMM-Don-1
15378: PPUSH
15379: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
15383: LD_EXP 16
15387: PUSH
15388: LD_EXP 16
15392: PPUSH
15393: CALL_OW 255
15397: PUSH
15398: LD_INT 7
15400: EQUAL
15401: AND
15402: PUSH
15403: LD_EXP 16
15407: PPUSH
15408: CALL_OW 305
15412: AND
15413: IFFALSE 15427
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
15415: LD_EXP 16
15419: PPUSH
15420: LD_STRING DEnd-JMM-Bobby-1
15422: PPUSH
15423: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
15427: LD_EXP 18
15431: PUSH
15432: LD_EXP 18
15436: PPUSH
15437: CALL_OW 255
15441: PUSH
15442: LD_INT 7
15444: EQUAL
15445: AND
15446: PUSH
15447: LD_EXP 18
15451: PPUSH
15452: CALL_OW 305
15456: AND
15457: IFFALSE 15471
// Say ( Denis , DEnd-JMM-Den-1 ) ;
15459: LD_EXP 18
15463: PPUSH
15464: LD_STRING DEnd-JMM-Den-1
15466: PPUSH
15467: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
15471: LD_EXP 20
15475: PUSH
15476: LD_EXP 20
15480: PPUSH
15481: CALL_OW 255
15485: PUSH
15486: LD_INT 7
15488: EQUAL
15489: AND
15490: PUSH
15491: LD_EXP 20
15495: PPUSH
15496: CALL_OW 305
15500: AND
15501: IFFALSE 15515
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
15503: LD_EXP 20
15507: PPUSH
15508: LD_STRING DEnd-JMM-Glad-1
15510: PPUSH
15511: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
15515: LD_EXP 25
15519: PUSH
15520: LD_EXP 25
15524: PPUSH
15525: CALL_OW 255
15529: PUSH
15530: LD_INT 7
15532: EQUAL
15533: AND
15534: PUSH
15535: LD_EXP 25
15539: PPUSH
15540: CALL_OW 305
15544: AND
15545: IFFALSE 15559
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
15547: LD_EXP 25
15551: PPUSH
15552: LD_STRING DEnd-JMM-Yam-1
15554: PPUSH
15555: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
15559: LD_EXP 19
15563: PUSH
15564: LD_EXP 19
15568: PPUSH
15569: CALL_OW 255
15573: PUSH
15574: LD_INT 7
15576: EQUAL
15577: AND
15578: PUSH
15579: LD_EXP 19
15583: PPUSH
15584: CALL_OW 305
15588: AND
15589: IFFALSE 15603
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
15591: LD_EXP 19
15595: PPUSH
15596: LD_STRING DEnd-JMM-Brown-1
15598: PPUSH
15599: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
15603: LD_EXP 29
15607: PUSH
15608: LD_EXP 29
15612: PPUSH
15613: CALL_OW 255
15617: PUSH
15618: LD_INT 7
15620: EQUAL
15621: AND
15622: PUSH
15623: LD_EXP 29
15627: PPUSH
15628: CALL_OW 305
15632: AND
15633: IFFALSE 15647
// Say ( Connie , DEnd-JMM-Con-1 ) ;
15635: LD_EXP 29
15639: PPUSH
15640: LD_STRING DEnd-JMM-Con-1
15642: PPUSH
15643: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
15647: LD_EXP 23
15651: PUSH
15652: LD_EXP 23
15656: PPUSH
15657: CALL_OW 255
15661: PUSH
15662: LD_INT 7
15664: EQUAL
15665: AND
15666: PUSH
15667: LD_EXP 23
15671: PPUSH
15672: CALL_OW 305
15676: AND
15677: IFFALSE 15691
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
15679: LD_EXP 23
15683: PPUSH
15684: LD_STRING DEnd-JMM-Gary-1
15686: PPUSH
15687: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
15691: LD_EXP 26
15695: PUSH
15696: LD_EXP 13
15700: AND
15701: PUSH
15702: LD_EXP 26
15706: PPUSH
15707: CALL_OW 305
15711: AND
15712: IFFALSE 15726
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
15714: LD_EXP 26
15718: PPUSH
15719: LD_STRING DEnd-JMM-Sim-1
15721: PPUSH
15722: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
15726: LD_EXP 21
15730: PUSH
15731: LD_EXP 21
15735: PPUSH
15736: CALL_OW 255
15740: PUSH
15741: LD_INT 7
15743: EQUAL
15744: AND
15745: PUSH
15746: LD_EXP 21
15750: PPUSH
15751: CALL_OW 305
15755: AND
15756: IFFALSE 15770
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
15758: LD_EXP 21
15762: PPUSH
15763: LD_STRING DEnd-JMM-VanH-1
15765: PPUSH
15766: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
15770: LD_EXP 34
15774: PUSH
15775: LD_EXP 34
15779: PPUSH
15780: CALL_OW 305
15784: AND
15785: IFFALSE 15799
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
15787: LD_EXP 34
15791: PPUSH
15792: LD_STRING DEnd-JMM-Dol-1
15794: PPUSH
15795: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
15799: LD_EXP 34
15803: PUSH
15804: LD_EXP 34
15808: PPUSH
15809: CALL_OW 305
15813: AND
15814: IFFALSE 15828
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
15816: LD_EXP 34
15820: PPUSH
15821: LD_STRING DEnd-JMM-Dol-1
15823: PPUSH
15824: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
15828: LD_EXP 38
15832: PUSH
15833: LD_EXP 38
15837: PPUSH
15838: CALL_OW 305
15842: AND
15843: IFFALSE 15857
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
15845: LD_EXP 38
15849: PPUSH
15850: LD_STRING DEnd-JMM-Kap-1
15852: PPUSH
15853: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
15857: LD_EXP 41
15861: PUSH
15862: LD_EXP 41
15866: PPUSH
15867: CALL_OW 305
15871: AND
15872: IFFALSE 15886
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
15874: LD_EXP 41
15878: PPUSH
15879: LD_STRING DEnd-JMM-Kov-1
15881: PPUSH
15882: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
15886: LD_EXP 36
15890: PUSH
15891: LD_EXP 36
15895: PPUSH
15896: CALL_OW 305
15900: AND
15901: IFFALSE 15915
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
15903: LD_EXP 36
15907: PPUSH
15908: LD_STRING DEnd-JMM-Sch-1
15910: PPUSH
15911: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
15915: LD_EXP 32
15919: PUSH
15920: LD_EXP 32
15924: PPUSH
15925: CALL_OW 305
15929: AND
15930: IFFALSE 15944
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
15932: LD_EXP 32
15936: PPUSH
15937: LD_STRING DEnd-JMM-Tit-1
15939: PPUSH
15940: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
15944: LD_EXP 37
15948: PUSH
15949: LD_EXP 37
15953: PPUSH
15954: CALL_OW 305
15958: AND
15959: IFFALSE 15973
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
15961: LD_EXP 37
15965: PPUSH
15966: LD_STRING DEnd-JMM-Obl-1
15968: PPUSH
15969: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
15973: LD_EXP 39
15977: PUSH
15978: LD_EXP 39
15982: PPUSH
15983: CALL_OW 305
15987: AND
15988: IFFALSE 16002
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
15990: LD_EXP 39
15994: PPUSH
15995: LD_STRING DEnd-JMM-Lip-1
15997: PPUSH
15998: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16002: LD_EXP 33
16006: PUSH
16007: LD_EXP 33
16011: PPUSH
16012: CALL_OW 305
16016: AND
16017: PUSH
16018: LD_EXP 44
16022: AND
16023: IFFALSE 16037
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16025: LD_EXP 33
16029: PPUSH
16030: LD_STRING DEnd-Burlak-Fad-1
16032: PPUSH
16033: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16037: LD_EXP 40
16041: PUSH
16042: LD_EXP 40
16046: PPUSH
16047: CALL_OW 305
16051: AND
16052: IFFALSE 16066
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16054: LD_EXP 40
16058: PPUSH
16059: LD_STRING DEnd-Burlak-Ptr-1
16061: PPUSH
16062: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16066: LD_EXP 42
16070: PUSH
16071: LD_EXP 42
16075: PPUSH
16076: CALL_OW 305
16080: AND
16081: IFFALSE 16095
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16083: LD_EXP 42
16087: PPUSH
16088: LD_STRING DEnd-Burlak-Kuz-1
16090: PPUSH
16091: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16095: LD_EXP 31
16099: PUSH
16100: LD_EXP 31
16104: PPUSH
16105: CALL_OW 305
16109: AND
16110: PUSH
16111: LD_EXP 44
16115: AND
16116: IFFALSE 16130
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16118: LD_EXP 31
16122: PPUSH
16123: LD_STRING DEnd-Burlak-Kir-1
16125: PPUSH
16126: CALL_OW 88
// if Burlak then
16130: LD_EXP 44
16134: IFFALSE 16148
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16136: LD_EXP 12
16140: PPUSH
16141: LD_STRING DEnd-Burlak-JMM-1
16143: PPUSH
16144: CALL_OW 88
// AddMedal ( Hero , 1 ) ;
16148: LD_STRING Hero
16150: PPUSH
16151: LD_INT 1
16153: PPUSH
16154: CALL_OW 101
// AddMedal ( Artefact , [ - 1 , 1 ] [ artifactIResearched and artifactIIResearched and artifactIIIResearched ] ) ;
16158: LD_STRING Artefact
16160: PPUSH
16161: LD_INT 1
16163: NEG
16164: PUSH
16165: LD_INT 1
16167: PUSH
16168: EMPTY
16169: LIST
16170: LIST
16171: PUSH
16172: LD_EXP 9
16176: PUSH
16177: LD_EXP 10
16181: AND
16182: PUSH
16183: LD_EXP 11
16187: AND
16188: ARRAY
16189: PPUSH
16190: CALL_OW 101
// AddMedal ( ReconcileBurlak , [ - 1 , 1 ] [ IsLive ( Burlak ) ] ) ;
16194: LD_STRING ReconcileBurlak
16196: PPUSH
16197: LD_INT 1
16199: NEG
16200: PUSH
16201: LD_INT 1
16203: PUSH
16204: EMPTY
16205: LIST
16206: LIST
16207: PUSH
16208: LD_EXP 44
16212: PPUSH
16213: CALL_OW 300
16217: ARRAY
16218: PPUSH
16219: CALL_OW 101
// GiveMedals ( MAIN ) ;
16223: LD_STRING MAIN
16225: PPUSH
16226: CALL_OW 102
// YouWin ;
16230: CALL_OW 103
// end ; end_of_file
16234: END
// export function InitNature ; begin
16235: LD_INT 0
16237: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
16238: LD_INT 3
16240: PPUSH
16241: LD_INT 3
16243: PPUSH
16244: LD_INT 2
16246: PPUSH
16247: LD_INT 1
16249: PPUSH
16250: LD_INT 1
16252: PPUSH
16253: LD_INT 0
16255: PPUSH
16256: LD_INT 0
16258: PPUSH
16259: LD_INT 17
16261: PPUSH
16262: LD_INT 0
16264: PPUSH
16265: CALL 83921 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
16269: LD_INT 2
16271: PPUSH
16272: LD_INT 1
16274: PPUSH
16275: LD_INT 1
16277: PPUSH
16278: LD_INT 1
16280: PPUSH
16281: LD_INT 1
16283: PPUSH
16284: LD_INT 0
16286: PPUSH
16287: LD_INT 0
16289: PPUSH
16290: LD_INT 18
16292: PPUSH
16293: LD_INT 0
16295: PPUSH
16296: CALL 83921 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
16300: LD_INT 4
16302: PPUSH
16303: LD_INT 1
16305: PPUSH
16306: LD_INT 2
16308: PPUSH
16309: LD_INT 4
16311: PPUSH
16312: LD_INT 2
16314: PPUSH
16315: LD_INT 1
16317: PPUSH
16318: LD_INT 0
16320: PPUSH
16321: LD_INT 19
16323: PPUSH
16324: LD_INT 0
16326: PPUSH
16327: CALL 83921 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
16331: LD_INT 0
16333: PPUSH
16334: LD_INT 0
16336: PPUSH
16337: LD_INT 0
16339: PPUSH
16340: LD_INT 0
16342: PPUSH
16343: LD_INT 0
16345: PPUSH
16346: LD_INT 0
16348: PPUSH
16349: LD_INT 9
16351: PPUSH
16352: LD_INT 0
16354: PPUSH
16355: LD_INT 20
16357: PPUSH
16358: CALL 83921 0 9
// end ; end_of_file
16362: LD_VAR 0 1
16366: RET
// every 0 0$30 do var time ;
16367: GO 16369
16369: DISABLE
16370: LD_INT 0
16372: PPUSH
// begin time := 0 0$50 ;
16373: LD_ADDR_VAR 0 1
16377: PUSH
16378: LD_INT 1750
16380: ST_TO_ADDR
// repeat wait ( time ) ;
16381: LD_VAR 0 1
16385: PPUSH
16386: CALL_OW 67
// if Prob ( 50 ) then
16390: LD_INT 50
16392: PPUSH
16393: CALL_OW 13
16397: IFFALSE 16426
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
16399: LD_INT 1
16401: PPUSH
16402: LD_INT 5
16404: PPUSH
16405: CALL_OW 12
16409: PPUSH
16410: LD_INT 106
16412: PPUSH
16413: LD_INT 89
16415: PPUSH
16416: LD_INT 45
16418: PPUSH
16419: LD_INT 1
16421: PPUSH
16422: CALL_OW 56
// time := time + 0 0$3 ;
16426: LD_ADDR_VAR 0 1
16430: PUSH
16431: LD_VAR 0 1
16435: PUSH
16436: LD_INT 105
16438: PLUS
16439: ST_TO_ADDR
// if Prob ( 30 ) then
16440: LD_INT 30
16442: PPUSH
16443: CALL_OW 13
16447: IFFALSE 16493
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
16449: LD_INT 525
16451: PPUSH
16452: LD_INT 735
16454: PPUSH
16455: CALL_OW 12
16459: PPUSH
16460: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
16464: LD_INT 1
16466: PPUSH
16467: LD_INT 5
16469: PPUSH
16470: CALL_OW 12
16474: PPUSH
16475: LD_INT 21
16477: PPUSH
16478: LD_INT 26
16480: PPUSH
16481: LD_INT 12
16483: PPUSH
16484: LD_INT 1
16486: PPUSH
16487: CALL_OW 56
// end else
16491: GO 16529
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
16493: LD_INT 700
16495: PPUSH
16496: LD_INT 1225
16498: PPUSH
16499: CALL_OW 12
16503: PPUSH
16504: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
16508: LD_INT 1
16510: PPUSH
16511: LD_INT 5
16513: PPUSH
16514: CALL_OW 12
16518: PPUSH
16519: LD_INT 14
16521: PPUSH
16522: LD_INT 1
16524: PPUSH
16525: CALL_OW 55
// end ; if Prob ( 50 ) then
16529: LD_INT 50
16531: PPUSH
16532: CALL_OW 13
16536: IFFALSE 16582
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
16538: LD_INT 700
16540: PPUSH
16541: LD_INT 1050
16543: PPUSH
16544: CALL_OW 12
16548: PPUSH
16549: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
16553: LD_INT 1
16555: PPUSH
16556: LD_INT 5
16558: PPUSH
16559: CALL_OW 12
16563: PPUSH
16564: LD_INT 181
16566: PPUSH
16567: LD_INT 218
16569: PPUSH
16570: LD_INT 16
16572: PPUSH
16573: LD_INT 1
16575: PPUSH
16576: CALL_OW 56
// end else
16580: GO 16654
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
16582: LD_INT 350
16584: PPUSH
16585: LD_INT 525
16587: PPUSH
16588: CALL_OW 12
16592: PPUSH
16593: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
16597: LD_INT 1
16599: PPUSH
16600: LD_INT 5
16602: PPUSH
16603: CALL_OW 12
16607: PPUSH
16608: LD_INT 13
16610: PPUSH
16611: LD_INT 1
16613: PPUSH
16614: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
16618: LD_INT 350
16620: PPUSH
16621: LD_INT 700
16623: PPUSH
16624: CALL_OW 12
16628: PPUSH
16629: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
16633: LD_INT 1
16635: PPUSH
16636: LD_INT 5
16638: PPUSH
16639: CALL_OW 12
16643: PPUSH
16644: LD_INT 33
16646: PPUSH
16647: LD_INT 1
16649: PPUSH
16650: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
16654: LD_INT 65
16656: PUSH
16657: LD_INT 62
16659: PUSH
16660: LD_INT 55
16662: PUSH
16663: EMPTY
16664: LIST
16665: LIST
16666: LIST
16667: PUSH
16668: LD_OWVAR 67
16672: ARRAY
16673: PPUSH
16674: CALL_OW 13
16678: IFFALSE 16724
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
16680: LD_INT 525
16682: PPUSH
16683: LD_INT 875
16685: PPUSH
16686: CALL_OW 12
16690: PPUSH
16691: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
16695: LD_INT 1
16697: PPUSH
16698: LD_INT 5
16700: PPUSH
16701: CALL_OW 12
16705: PPUSH
16706: LD_INT 294
16708: PPUSH
16709: LD_INT 211
16711: PPUSH
16712: LD_INT 30
16714: PPUSH
16715: LD_INT 1
16717: PPUSH
16718: CALL_OW 56
// end else
16722: GO 16766
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
16724: LD_INT 420
16726: PPUSH
16727: LD_INT 770
16729: PPUSH
16730: CALL_OW 12
16734: PPUSH
16735: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
16739: LD_INT 1
16741: PPUSH
16742: LD_INT 5
16744: PPUSH
16745: CALL_OW 12
16749: PPUSH
16750: LD_INT 294
16752: PPUSH
16753: LD_INT 211
16755: PPUSH
16756: LD_INT 30
16758: PPUSH
16759: LD_INT 1
16761: PPUSH
16762: CALL_OW 56
// end ; if time > 2 2$20 then
16766: LD_VAR 0 1
16770: PUSH
16771: LD_INT 4900
16773: GREATER
16774: IFFALSE 16784
// time := 0 0$50 ;
16776: LD_ADDR_VAR 0 1
16780: PUSH
16781: LD_INT 1750
16783: ST_TO_ADDR
// until false ;
16784: LD_INT 0
16786: IFFALSE 16381
// end ;
16788: PPOPN 1
16790: END
// every 0 0$45 trigger tick < 10 10$00 do
16791: LD_OWVAR 1
16795: PUSH
16796: LD_INT 21000
16798: LESS
16799: IFFALSE 16847
16801: GO 16803
16803: DISABLE
// begin enable ;
16804: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
16805: LD_INT 350
16807: PPUSH
16808: LD_INT 700
16810: PPUSH
16811: CALL_OW 12
16815: PPUSH
16816: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
16820: LD_INT 3
16822: PPUSH
16823: LD_INT 5
16825: PPUSH
16826: CALL_OW 12
16830: PPUSH
16831: LD_INT 181
16833: PPUSH
16834: LD_INT 13
16836: PPUSH
16837: LD_INT 20
16839: PPUSH
16840: LD_INT 1
16842: PPUSH
16843: CALL_OW 56
// end ; end_of_file
16847: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
16848: LD_INT 0
16850: PPUSH
// SetArtifactRes ( 7 , true ) ;
16851: LD_INT 7
16853: PPUSH
16854: LD_INT 1
16856: PPUSH
16857: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
16861: LD_ADDR_EXP 57
16865: PUSH
16866: EMPTY
16867: PUSH
16868: EMPTY
16869: PUSH
16870: EMPTY
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
16877: LD_ADDR_EXP 58
16881: PUSH
16882: LD_INT 1050
16884: PUSH
16885: LD_OWVAR 67
16889: MUL
16890: PUSH
16891: LD_INT 2800
16893: PUSH
16894: LD_OWVAR 67
16898: MUL
16899: PUSH
16900: LD_INT 1
16902: NEG
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
16909: LD_ADDR_EXP 59
16913: PUSH
16914: LD_INT 10
16916: PUSH
16917: LD_INT 35
16919: PUSH
16920: LD_INT 100
16922: PUSH
16923: EMPTY
16924: LIST
16925: LIST
16926: LIST
16927: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
16928: LD_ADDR_EXP 60
16932: PUSH
16933: LD_INT 0
16935: PUSH
16936: LD_INT 0
16938: PUSH
16939: LD_INT 0
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: LIST
16946: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
16947: LD_ADDR_EXP 62
16951: PUSH
16952: LD_INT 300
16954: PUSH
16955: LD_INT 500
16957: PUSH
16958: LD_INT 800
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: LIST
16965: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
16966: LD_ADDR_EXP 63
16970: PUSH
16971: LD_INT 0
16973: PUSH
16974: LD_INT 0
16976: PUSH
16977: LD_INT 0
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: LIST
16984: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
16985: LD_ADDR_EXP 64
16989: PUSH
16990: LD_INT 0
16992: PUSH
16993: LD_INT 0
16995: PUSH
16996: LD_INT 0
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: LIST
17003: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17004: LD_ADDR_EXP 61
17008: PUSH
17009: LD_INT 0
17011: PUSH
17012: LD_INT 0
17014: PUSH
17015: LD_INT 0
17017: PUSH
17018: EMPTY
17019: LIST
17020: LIST
17021: LIST
17022: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17023: LD_ADDR_EXP 65
17027: PUSH
17028: LD_INT 4
17030: PUSH
17031: LD_INT 3
17033: PUSH
17034: LD_INT 1
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: LIST
17041: PUSH
17042: LD_INT 5
17044: PUSH
17045: LD_INT 4
17047: PUSH
17048: LD_INT 2
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: LIST
17055: PUSH
17056: LD_INT 6
17058: PUSH
17059: LD_INT 3
17061: PUSH
17062: LD_INT 3
17064: PUSH
17065: EMPTY
17066: LIST
17067: LIST
17068: LIST
17069: PUSH
17070: EMPTY
17071: LIST
17072: LIST
17073: LIST
17074: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17075: LD_ADDR_EXP 66
17079: PUSH
17080: LD_INT 0
17082: PUSH
17083: LD_INT 0
17085: PUSH
17086: LD_INT 0
17088: PUSH
17089: EMPTY
17090: LIST
17091: LIST
17092: LIST
17093: ST_TO_ADDR
// end ;
17094: LD_VAR 0 1
17098: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17099: LD_INT 24
17101: PPUSH
17102: LD_INT 7
17104: PPUSH
17105: CALL_OW 321
17109: PUSH
17110: LD_INT 2
17112: EQUAL
17113: IFFALSE 18039
17115: GO 17117
17117: DISABLE
17118: LD_INT 0
17120: PPUSH
17121: PPUSH
17122: PPUSH
17123: PPUSH
17124: PPUSH
// begin enable ;
17125: ENABLE
// for i = 1 to 3 do
17126: LD_ADDR_VAR 0 1
17130: PUSH
17131: DOUBLE
17132: LD_INT 1
17134: DEC
17135: ST_TO_ADDR
17136: LD_INT 3
17138: PUSH
17139: FOR_TO
17140: IFFALSE 18037
// begin pos := FindArtifact ( i + 2 ) ;
17142: LD_ADDR_VAR 0 2
17146: PUSH
17147: LD_VAR 0 1
17151: PUSH
17152: LD_INT 2
17154: PLUS
17155: PPUSH
17156: CALL_OW 469
17160: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17161: LD_ADDR_EXP 57
17165: PUSH
17166: LD_EXP 57
17170: PPUSH
17171: LD_VAR 0 1
17175: PPUSH
17176: LD_VAR 0 2
17180: PPUSH
17181: CALL_OW 1
17185: ST_TO_ADDR
// if pos then
17186: LD_VAR 0 2
17190: IFFALSE 17898
// begin case i of 1 :
17192: LD_VAR 0 1
17196: PUSH
17197: LD_INT 1
17199: DOUBLE
17200: EQUAL
17201: IFTRUE 17205
17203: GO 17282
17205: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17206: LD_ADDR_VAR 0 4
17210: PUSH
17211: LD_INT 22
17213: PUSH
17214: LD_INT 7
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: PUSH
17221: LD_INT 23
17223: PUSH
17224: LD_INT 1
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: PUSH
17231: LD_INT 2
17233: PUSH
17234: LD_INT 30
17236: PUSH
17237: LD_INT 8
17239: PUSH
17240: EMPTY
17241: LIST
17242: LIST
17243: PUSH
17244: LD_INT 30
17246: PUSH
17247: LD_INT 7
17249: PUSH
17250: EMPTY
17251: LIST
17252: LIST
17253: PUSH
17254: LD_INT 30
17256: PUSH
17257: LD_INT 11
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: LIST
17268: LIST
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: LIST
17274: PPUSH
17275: CALL_OW 69
17279: ST_TO_ADDR
17280: GO 17390
17282: LD_INT 2
17284: DOUBLE
17285: EQUAL
17286: IFTRUE 17290
17288: GO 17367
17290: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
17291: LD_ADDR_VAR 0 4
17295: PUSH
17296: LD_INT 22
17298: PUSH
17299: LD_INT 7
17301: PUSH
17302: EMPTY
17303: LIST
17304: LIST
17305: PUSH
17306: LD_INT 23
17308: PUSH
17309: LD_INT 3
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: PUSH
17316: LD_INT 2
17318: PUSH
17319: LD_INT 30
17321: PUSH
17322: LD_INT 8
17324: PUSH
17325: EMPTY
17326: LIST
17327: LIST
17328: PUSH
17329: LD_INT 30
17331: PUSH
17332: LD_INT 7
17334: PUSH
17335: EMPTY
17336: LIST
17337: LIST
17338: PUSH
17339: LD_INT 30
17341: PUSH
17342: LD_INT 11
17344: PUSH
17345: EMPTY
17346: LIST
17347: LIST
17348: PUSH
17349: EMPTY
17350: LIST
17351: LIST
17352: LIST
17353: LIST
17354: PUSH
17355: EMPTY
17356: LIST
17357: LIST
17358: LIST
17359: PPUSH
17360: CALL_OW 69
17364: ST_TO_ADDR
17365: GO 17390
17367: LD_INT 3
17369: DOUBLE
17370: EQUAL
17371: IFTRUE 17375
17373: GO 17389
17375: POP
// labs := [ alien ] ; end ;
17376: LD_ADDR_VAR 0 4
17380: PUSH
17381: LD_INT 1
17383: PUSH
17384: EMPTY
17385: LIST
17386: ST_TO_ADDR
17387: GO 17390
17389: POP
// if not labs then
17390: LD_VAR 0 4
17394: NOT
17395: IFFALSE 17399
// continue ;
17397: GO 17139
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
17399: LD_ADDR_VAR 0 5
17403: PUSH
17404: LD_VAR 0 4
17408: PPUSH
17409: LD_EXP 57
17413: PUSH
17414: LD_VAR 0 1
17418: ARRAY
17419: PUSH
17420: LD_INT 1
17422: ARRAY
17423: PPUSH
17424: LD_EXP 57
17428: PUSH
17429: LD_VAR 0 1
17433: ARRAY
17434: PUSH
17435: LD_INT 2
17437: ARRAY
17438: PPUSH
17439: CALL_OW 73
17443: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
17444: LD_VAR 0 5
17448: NOT
17449: PUSH
17450: LD_VAR 0 5
17454: PUSH
17455: LD_EXP 64
17459: PUSH
17460: LD_VAR 0 1
17464: ARRAY
17465: NONEQUAL
17466: OR
17467: IFFALSE 17572
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
17469: LD_INT 7
17471: PPUSH
17472: LD_EXP 65
17476: PUSH
17477: LD_VAR 0 1
17481: ARRAY
17482: PUSH
17483: LD_INT 3
17485: ARRAY
17486: PPUSH
17487: LD_INT 0
17489: PPUSH
17490: LD_EXP 64
17494: PUSH
17495: LD_VAR 0 1
17499: ARRAY
17500: PPUSH
17501: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
17505: LD_INT 7
17507: PPUSH
17508: LD_EXP 65
17512: PUSH
17513: LD_VAR 0 1
17517: ARRAY
17518: PUSH
17519: LD_INT 1
17521: ARRAY
17522: PPUSH
17523: LD_INT 0
17525: PPUSH
17526: LD_EXP 64
17530: PUSH
17531: LD_VAR 0 1
17535: ARRAY
17536: PPUSH
17537: CALL_OW 468
// if nearestLab then
17541: LD_VAR 0 5
17545: IFFALSE 17572
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
17547: LD_ADDR_EXP 64
17551: PUSH
17552: LD_EXP 64
17556: PPUSH
17557: LD_VAR 0 1
17561: PPUSH
17562: LD_VAR 0 5
17566: PPUSH
17567: CALL_OW 1
17571: ST_TO_ADDR
// end ; if not nearestLab then
17572: LD_VAR 0 5
17576: NOT
17577: IFFALSE 17581
// continue ;
17579: GO 17139
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
17581: LD_VAR 0 5
17585: PPUSH
17586: LD_EXP 57
17590: PUSH
17591: LD_VAR 0 1
17595: ARRAY
17596: PUSH
17597: LD_INT 1
17599: ARRAY
17600: PPUSH
17601: LD_EXP 57
17605: PUSH
17606: LD_VAR 0 1
17610: ARRAY
17611: PUSH
17612: LD_INT 2
17614: ARRAY
17615: PPUSH
17616: CALL_OW 297
17620: PUSH
17621: LD_INT 8
17623: LESS
17624: IFFALSE 17821
// begin if not artifactsResearched [ i ] then
17626: LD_EXP 60
17630: PUSH
17631: LD_VAR 0 1
17635: ARRAY
17636: NOT
17637: IFFALSE 17718
// begin if BuildingStatus ( nearestLab ) = bs_idle then
17639: LD_VAR 0 5
17643: PPUSH
17644: CALL_OW 461
17648: PUSH
17649: LD_INT 2
17651: EQUAL
17652: IFFALSE 17686
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
17654: LD_INT 7
17656: PPUSH
17657: LD_EXP 65
17661: PUSH
17662: LD_VAR 0 1
17666: ARRAY
17667: PUSH
17668: LD_INT 3
17670: ARRAY
17671: PPUSH
17672: LD_INT 2
17674: PPUSH
17675: LD_VAR 0 5
17679: PPUSH
17680: CALL_OW 468
17684: GO 17716
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
17686: LD_INT 7
17688: PPUSH
17689: LD_EXP 65
17693: PUSH
17694: LD_VAR 0 1
17698: ARRAY
17699: PUSH
17700: LD_INT 3
17702: ARRAY
17703: PPUSH
17704: LD_INT 1
17706: PPUSH
17707: LD_VAR 0 5
17711: PPUSH
17712: CALL_OW 468
// end else
17716: GO 17819
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
17718: LD_VAR 0 5
17722: PPUSH
17723: CALL_OW 461
17727: PUSH
17728: LD_INT 2
17730: EQUAL
17731: PUSH
17732: LD_EXP 66
17736: PUSH
17737: LD_VAR 0 1
17741: ARRAY
17742: AND
17743: IFFALSE 17789
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
17745: LD_INT 7
17747: PPUSH
17748: LD_EXP 65
17752: PUSH
17753: LD_VAR 0 1
17757: ARRAY
17758: PUSH
17759: LD_INT 1
17761: ARRAY
17762: PPUSH
17763: LD_EXP 65
17767: PUSH
17768: LD_VAR 0 1
17772: ARRAY
17773: PUSH
17774: LD_INT 2
17776: ARRAY
17777: PPUSH
17778: LD_VAR 0 5
17782: PPUSH
17783: CALL_OW 468
17787: GO 17819
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
17789: LD_INT 7
17791: PPUSH
17792: LD_EXP 65
17796: PUSH
17797: LD_VAR 0 1
17801: ARRAY
17802: PUSH
17803: LD_INT 1
17805: ARRAY
17806: PPUSH
17807: LD_INT 1
17809: PPUSH
17810: LD_VAR 0 5
17814: PPUSH
17815: CALL_OW 468
// end else
17819: GO 17896
// begin if not artifactsResearched [ i ] then
17821: LD_EXP 60
17825: PUSH
17826: LD_VAR 0 1
17830: ARRAY
17831: NOT
17832: IFFALSE 17866
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
17834: LD_INT 7
17836: PPUSH
17837: LD_EXP 65
17841: PUSH
17842: LD_VAR 0 1
17846: ARRAY
17847: PUSH
17848: LD_INT 3
17850: ARRAY
17851: PPUSH
17852: LD_INT 0
17854: PPUSH
17855: LD_VAR 0 5
17859: PPUSH
17860: CALL_OW 468
17864: GO 17896
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
17866: LD_INT 7
17868: PPUSH
17869: LD_EXP 65
17873: PUSH
17874: LD_VAR 0 1
17878: ARRAY
17879: PUSH
17880: LD_INT 1
17882: ARRAY
17883: PPUSH
17884: LD_INT 0
17886: PPUSH
17887: LD_VAR 0 5
17891: PPUSH
17892: CALL_OW 468
// end ; end else
17896: GO 18035
// begin if not artifactsLabs [ i ] then
17898: LD_EXP 64
17902: PUSH
17903: LD_VAR 0 1
17907: ARRAY
17908: NOT
17909: IFFALSE 17913
// continue ;
17911: GO 17139
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
17913: LD_INT 7
17915: PPUSH
17916: LD_EXP 65
17920: PUSH
17921: LD_VAR 0 1
17925: ARRAY
17926: PUSH
17927: LD_INT 3
17929: ARRAY
17930: PPUSH
17931: LD_INT 0
17933: PPUSH
17934: LD_EXP 64
17938: PUSH
17939: LD_VAR 0 1
17943: ARRAY
17944: PPUSH
17945: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
17949: LD_INT 7
17951: PPUSH
17952: LD_EXP 65
17956: PUSH
17957: LD_VAR 0 1
17961: ARRAY
17962: PUSH
17963: LD_INT 1
17965: ARRAY
17966: PPUSH
17967: LD_INT 0
17969: PPUSH
17970: LD_EXP 64
17974: PUSH
17975: LD_VAR 0 1
17979: ARRAY
17980: PPUSH
17981: CALL_OW 468
// if artifactsLabsWorking [ i ] then
17985: LD_EXP 61
17989: PUSH
17990: LD_VAR 0 1
17994: ARRAY
17995: IFFALSE 18035
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
17997: LD_ADDR_EXP 61
18001: PUSH
18002: LD_EXP 61
18006: PPUSH
18007: LD_VAR 0 1
18011: PPUSH
18012: LD_INT 0
18014: PPUSH
18015: CALL_OW 1
18019: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18020: LD_EXP 64
18024: PUSH
18025: LD_VAR 0 1
18029: ARRAY
18030: PPUSH
18031: CALL_OW 127
// end ; end ; end ;
18035: GO 17139
18037: POP
18038: POP
// end ;
18039: PPOPN 5
18041: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18042: LD_INT 0
18044: PPUSH
18045: PPUSH
18046: PPUSH
18047: PPUSH
18048: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18049: LD_VAR 0 2
18053: PUSH
18054: LD_EXP 65
18058: PUSH
18059: LD_INT 1
18061: ARRAY
18062: PUSH
18063: LD_INT 3
18065: ARRAY
18066: EQUAL
18067: IFFALSE 18190
// begin lab := artifactsLabs [ 1 ] ;
18069: LD_ADDR_VAR 0 6
18073: PUSH
18074: LD_EXP 64
18078: PUSH
18079: LD_INT 1
18081: ARRAY
18082: ST_TO_ADDR
// if not lab then
18083: LD_VAR 0 6
18087: NOT
18088: IFFALSE 18092
// exit ;
18090: GO 19124
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18092: LD_VAR 0 6
18096: PPUSH
18097: LD_EXP 62
18101: PUSH
18102: LD_INT 1
18104: ARRAY
18105: PPUSH
18106: LD_INT 1
18108: PPUSH
18109: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18113: LD_EXP 63
18117: PUSH
18118: LD_INT 1
18120: ARRAY
18121: IFFALSE 18141
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18123: LD_VAR 0 6
18127: PPUSH
18128: LD_EXP 63
18132: PUSH
18133: LD_INT 1
18135: ARRAY
18136: PPUSH
18137: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18141: LD_ADDR_EXP 61
18145: PUSH
18146: LD_EXP 61
18150: PPUSH
18151: LD_INT 1
18153: PPUSH
18154: LD_INT 1
18156: PPUSH
18157: CALL_OW 1
18161: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18162: LD_INT 7
18164: PPUSH
18165: LD_EXP 65
18169: PUSH
18170: LD_INT 1
18172: ARRAY
18173: PUSH
18174: LD_INT 3
18176: ARRAY
18177: PPUSH
18178: LD_INT 0
18180: PPUSH
18181: LD_VAR 0 6
18185: PPUSH
18186: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18190: LD_VAR 0 2
18194: PUSH
18195: LD_EXP 65
18199: PUSH
18200: LD_INT 2
18202: ARRAY
18203: PUSH
18204: LD_INT 3
18206: ARRAY
18207: EQUAL
18208: IFFALSE 18331
// begin lab := artifactsLabs [ 2 ] ;
18210: LD_ADDR_VAR 0 6
18214: PUSH
18215: LD_EXP 64
18219: PUSH
18220: LD_INT 2
18222: ARRAY
18223: ST_TO_ADDR
// if not lab then
18224: LD_VAR 0 6
18228: NOT
18229: IFFALSE 18233
// exit ;
18231: GO 19124
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
18233: LD_VAR 0 6
18237: PPUSH
18238: LD_EXP 62
18242: PUSH
18243: LD_INT 2
18245: ARRAY
18246: PPUSH
18247: LD_INT 1
18249: PPUSH
18250: CALL_OW 486
// if artifactsResProgress [ 2 ] then
18254: LD_EXP 63
18258: PUSH
18259: LD_INT 2
18261: ARRAY
18262: IFFALSE 18282
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
18264: LD_VAR 0 6
18268: PPUSH
18269: LD_EXP 63
18273: PUSH
18274: LD_INT 2
18276: ARRAY
18277: PPUSH
18278: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
18282: LD_ADDR_EXP 61
18286: PUSH
18287: LD_EXP 61
18291: PPUSH
18292: LD_INT 2
18294: PPUSH
18295: LD_INT 1
18297: PPUSH
18298: CALL_OW 1
18302: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
18303: LD_INT 7
18305: PPUSH
18306: LD_EXP 65
18310: PUSH
18311: LD_INT 2
18313: ARRAY
18314: PUSH
18315: LD_INT 3
18317: ARRAY
18318: PPUSH
18319: LD_INT 0
18321: PPUSH
18322: LD_VAR 0 6
18326: PPUSH
18327: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
18331: LD_VAR 0 2
18335: PUSH
18336: LD_EXP 65
18340: PUSH
18341: LD_INT 3
18343: ARRAY
18344: PUSH
18345: LD_INT 3
18347: ARRAY
18348: EQUAL
18349: IFFALSE 18472
// begin lab := artifactsLabs [ 3 ] ;
18351: LD_ADDR_VAR 0 6
18355: PUSH
18356: LD_EXP 64
18360: PUSH
18361: LD_INT 3
18363: ARRAY
18364: ST_TO_ADDR
// if not lab then
18365: LD_VAR 0 6
18369: NOT
18370: IFFALSE 18374
// exit ;
18372: GO 19124
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
18374: LD_VAR 0 6
18378: PPUSH
18379: LD_EXP 62
18383: PUSH
18384: LD_INT 3
18386: ARRAY
18387: PPUSH
18388: LD_INT 1
18390: PPUSH
18391: CALL_OW 486
// if artifactsResProgress [ 3 ] then
18395: LD_EXP 63
18399: PUSH
18400: LD_INT 3
18402: ARRAY
18403: IFFALSE 18423
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
18405: LD_VAR 0 6
18409: PPUSH
18410: LD_EXP 63
18414: PUSH
18415: LD_INT 3
18417: ARRAY
18418: PPUSH
18419: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
18423: LD_ADDR_EXP 61
18427: PUSH
18428: LD_EXP 61
18432: PPUSH
18433: LD_INT 3
18435: PPUSH
18436: LD_INT 1
18438: PPUSH
18439: CALL_OW 1
18443: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
18444: LD_INT 7
18446: PPUSH
18447: LD_EXP 65
18451: PUSH
18452: LD_INT 3
18454: ARRAY
18455: PUSH
18456: LD_INT 3
18458: ARRAY
18459: PPUSH
18460: LD_INT 0
18462: PPUSH
18463: LD_VAR 0 6
18467: PPUSH
18468: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
18472: LD_VAR 0 2
18476: PUSH
18477: LD_EXP 65
18481: PUSH
18482: LD_INT 1
18484: ARRAY
18485: PUSH
18486: LD_INT 1
18488: ARRAY
18489: EQUAL
18490: IFFALSE 18648
// begin lab := artifactsLabs [ 1 ] ;
18492: LD_ADDR_VAR 0 6
18496: PUSH
18497: LD_EXP 64
18501: PUSH
18502: LD_INT 1
18504: ARRAY
18505: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
18506: LD_VAR 0 6
18510: PPUSH
18511: CALL_OW 274
18515: PPUSH
18516: CALL 92069 0 1
18520: PUSH
18521: LD_INT 3
18523: ARRAY
18524: PUSH
18525: LD_EXP 59
18529: PUSH
18530: LD_INT 1
18532: ARRAY
18533: LESS
18534: IFFALSE 18548
// begin HintSpec ( ArtifactCost , 2 ) ;
18536: LD_STRING ArtifactCost
18538: PPUSH
18539: LD_INT 2
18541: PPUSH
18542: CALL_OW 338
// exit ;
18546: GO 19124
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
18548: LD_ADDR_EXP 66
18552: PUSH
18553: LD_EXP 66
18557: PPUSH
18558: LD_INT 1
18560: PPUSH
18561: LD_INT 0
18563: PPUSH
18564: CALL_OW 1
18568: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
18569: LD_VAR 0 3
18573: PPUSH
18574: LD_VAR 0 4
18578: PPUSH
18579: LD_INT 7
18581: PPUSH
18582: LD_INT 12
18584: NEG
18585: PPUSH
18586: CALL_OW 330
// wait ( 0 0$30 ) ;
18590: LD_INT 1050
18592: PPUSH
18593: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
18597: LD_VAR 0 3
18601: PPUSH
18602: LD_VAR 0 4
18606: PPUSH
18607: LD_INT 7
18609: PPUSH
18610: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
18614: LD_EXP 58
18618: PUSH
18619: LD_INT 1
18621: ARRAY
18622: PPUSH
18623: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
18627: LD_ADDR_EXP 66
18631: PUSH
18632: LD_EXP 66
18636: PPUSH
18637: LD_INT 1
18639: PPUSH
18640: LD_INT 1
18642: PPUSH
18643: CALL_OW 1
18647: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
18648: LD_VAR 0 2
18652: PUSH
18653: LD_EXP 65
18657: PUSH
18658: LD_INT 2
18660: ARRAY
18661: PUSH
18662: LD_INT 1
18664: ARRAY
18665: EQUAL
18666: IFFALSE 18878
// begin lab := artifactsLabs [ 2 ] ;
18668: LD_ADDR_VAR 0 6
18672: PUSH
18673: LD_EXP 64
18677: PUSH
18678: LD_INT 2
18680: ARRAY
18681: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
18682: LD_VAR 0 3
18686: PUSH
18687: LD_INT 81
18689: PUSH
18690: LD_INT 7
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: PUSH
18697: LD_INT 2
18699: PUSH
18700: LD_INT 32
18702: PUSH
18703: LD_INT 3
18705: PUSH
18706: EMPTY
18707: LIST
18708: LIST
18709: PUSH
18710: LD_INT 30
18712: PUSH
18713: LD_INT 28
18715: PUSH
18716: EMPTY
18717: LIST
18718: LIST
18719: PUSH
18720: LD_INT 30
18722: PUSH
18723: LD_INT 30
18725: PUSH
18726: EMPTY
18727: LIST
18728: LIST
18729: PUSH
18730: LD_INT 35
18732: PUSH
18733: LD_INT 49
18735: PUSH
18736: EMPTY
18737: LIST
18738: LIST
18739: PUSH
18740: LD_INT 34
18742: PUSH
18743: LD_INT 49
18745: PUSH
18746: EMPTY
18747: LIST
18748: LIST
18749: PUSH
18750: EMPTY
18751: LIST
18752: LIST
18753: LIST
18754: LIST
18755: LIST
18756: LIST
18757: PUSH
18758: EMPTY
18759: LIST
18760: LIST
18761: PPUSH
18762: CALL_OW 69
18766: IN
18767: NOT
18768: IFFALSE 18772
// exit ;
18770: GO 19124
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
18772: LD_VAR 0 6
18776: PPUSH
18777: CALL_OW 274
18781: PPUSH
18782: CALL 92069 0 1
18786: PUSH
18787: LD_INT 3
18789: ARRAY
18790: PUSH
18791: LD_EXP 59
18795: PUSH
18796: LD_INT 2
18798: ARRAY
18799: LESS
18800: IFFALSE 18814
// begin HintSpec ( ArtifactCost , 2 ) ;
18802: LD_STRING ArtifactCost
18804: PPUSH
18805: LD_INT 2
18807: PPUSH
18808: CALL_OW 338
// exit ;
18812: GO 19124
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
18814: LD_ADDR_EXP 66
18818: PUSH
18819: LD_EXP 66
18823: PPUSH
18824: LD_INT 2
18826: PPUSH
18827: LD_INT 0
18829: PPUSH
18830: CALL_OW 1
18834: ST_TO_ADDR
// KillUnit ( x ) ;
18835: LD_VAR 0 3
18839: PPUSH
18840: CALL_OW 66
// wait ( artifactsRecharge [ 2 ] ) ;
18844: LD_EXP 58
18848: PUSH
18849: LD_INT 2
18851: ARRAY
18852: PPUSH
18853: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
18857: LD_ADDR_EXP 66
18861: PUSH
18862: LD_EXP 66
18866: PPUSH
18867: LD_INT 2
18869: PPUSH
18870: LD_INT 1
18872: PPUSH
18873: CALL_OW 1
18877: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
18878: LD_VAR 0 2
18882: PUSH
18883: LD_EXP 65
18887: PUSH
18888: LD_INT 3
18890: ARRAY
18891: PUSH
18892: LD_INT 1
18894: ARRAY
18895: EQUAL
18896: IFFALSE 19124
// begin lab := artifactsLabs [ 3 ] ;
18898: LD_ADDR_VAR 0 6
18902: PUSH
18903: LD_EXP 64
18907: PUSH
18908: LD_INT 3
18910: ARRAY
18911: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
18912: LD_VAR 0 6
18916: PPUSH
18917: CALL_OW 274
18921: PPUSH
18922: CALL 92069 0 1
18926: PUSH
18927: LD_INT 3
18929: ARRAY
18930: PUSH
18931: LD_EXP 59
18935: PUSH
18936: LD_INT 3
18938: ARRAY
18939: LESS
18940: IFFALSE 18954
// begin HintSpec ( ArtifactCost , 2 ) ;
18942: LD_STRING ArtifactCost
18944: PPUSH
18945: LD_INT 2
18947: PPUSH
18948: CALL_OW 338
// exit ;
18952: GO 19124
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
18954: LD_INT 37
18956: PPUSH
18957: LD_INT 1
18959: PPUSH
18960: CALL_OW 424
// time := 0 0$30 ;
18964: LD_ADDR_VAR 0 7
18968: PUSH
18969: LD_INT 1050
18971: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
18972: LD_ADDR_OWVAR 47
18976: PUSH
18977: LD_STRING Am15a-1
18979: PUSH
18980: LD_VAR 0 7
18984: PUSH
18985: EMPTY
18986: LIST
18987: LIST
18988: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18989: LD_INT 35
18991: PPUSH
18992: CALL_OW 67
// time := time - 0 0$1 ;
18996: LD_ADDR_VAR 0 7
19000: PUSH
19001: LD_VAR 0 7
19005: PUSH
19006: LD_INT 35
19008: MINUS
19009: ST_TO_ADDR
// until time = 0 0$00 ;
19010: LD_VAR 0 7
19014: PUSH
19015: LD_INT 0
19017: EQUAL
19018: IFFALSE 18972
// display_strings :=  ;
19020: LD_ADDR_OWVAR 47
19024: PUSH
19025: LD_STRING 
19027: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19028: LD_INT 37
19030: PPUSH
19031: LD_INT 0
19033: PPUSH
19034: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19038: LD_ADDR_VAR 0 8
19042: PUSH
19043: LD_INT 37
19045: PPUSH
19046: LD_INT 3
19048: PUSH
19049: LD_INT 21
19051: PUSH
19052: LD_INT 3
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: PUSH
19059: EMPTY
19060: LIST
19061: LIST
19062: PPUSH
19063: CALL_OW 70
19067: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19068: LD_VAR 0 3
19072: PPUSH
19073: LD_VAR 0 4
19077: PPUSH
19078: CALL_OW 84
// for un in list do
19082: LD_ADDR_VAR 0 9
19086: PUSH
19087: LD_VAR 0 8
19091: PUSH
19092: FOR_IN
19093: IFFALSE 19122
// TeleportUnit ( un , x , y , 12 , true ) ;
19095: LD_VAR 0 9
19099: PPUSH
19100: LD_VAR 0 3
19104: PPUSH
19105: LD_VAR 0 4
19109: PPUSH
19110: LD_INT 12
19112: PPUSH
19113: LD_INT 1
19115: PPUSH
19116: CALL_OW 483
19120: GO 19092
19122: POP
19123: POP
// end ; end ;
19124: PPOPN 9
19126: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19127: LD_INT 0
19129: PPUSH
19130: PPUSH
// begin labNum := 0 ;
19131: LD_ADDR_VAR 0 4
19135: PUSH
19136: LD_INT 0
19138: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19139: LD_ADDR_VAR 0 3
19143: PUSH
19144: DOUBLE
19145: LD_INT 1
19147: DEC
19148: ST_TO_ADDR
19149: LD_EXP 64
19153: PUSH
19154: FOR_TO
19155: IFFALSE 19189
// if artifactsLabs [ i ] = lab then
19157: LD_EXP 64
19161: PUSH
19162: LD_VAR 0 3
19166: ARRAY
19167: PUSH
19168: LD_VAR 0 1
19172: EQUAL
19173: IFFALSE 19187
// begin labNum := i ;
19175: LD_ADDR_VAR 0 4
19179: PUSH
19180: LD_VAR 0 3
19184: ST_TO_ADDR
// break ;
19185: GO 19189
// end ;
19187: GO 19154
19189: POP
19190: POP
// if not labNum then
19191: LD_VAR 0 4
19195: NOT
19196: IFFALSE 19200
// exit ;
19198: GO 19278
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
19200: LD_INT 7
19202: PPUSH
19203: LD_EXP 65
19207: PUSH
19208: LD_VAR 0 4
19212: ARRAY
19213: PUSH
19214: LD_INT 3
19216: ARRAY
19217: PPUSH
19218: LD_INT 2
19220: PPUSH
19221: LD_VAR 0 1
19225: PPUSH
19226: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
19230: LD_ADDR_EXP 63
19234: PUSH
19235: LD_EXP 63
19239: PPUSH
19240: LD_VAR 0 4
19244: PPUSH
19245: LD_VAR 0 2
19249: PPUSH
19250: CALL_OW 1
19254: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
19255: LD_ADDR_EXP 61
19259: PUSH
19260: LD_EXP 61
19264: PPUSH
19265: LD_VAR 0 4
19269: PPUSH
19270: LD_INT 0
19272: PPUSH
19273: CALL_OW 1
19277: ST_TO_ADDR
// end ;
19278: PPOPN 4
19280: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
19281: LD_INT 0
19283: PPUSH
19284: PPUSH
// begin labNum := 0 ;
19285: LD_ADDR_VAR 0 3
19289: PUSH
19290: LD_INT 0
19292: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19293: LD_ADDR_VAR 0 2
19297: PUSH
19298: DOUBLE
19299: LD_INT 1
19301: DEC
19302: ST_TO_ADDR
19303: LD_EXP 64
19307: PUSH
19308: FOR_TO
19309: IFFALSE 19343
// if artifactsLabs [ i ] = lab then
19311: LD_EXP 64
19315: PUSH
19316: LD_VAR 0 2
19320: ARRAY
19321: PUSH
19322: LD_VAR 0 1
19326: EQUAL
19327: IFFALSE 19341
// begin labNum := i ;
19329: LD_ADDR_VAR 0 3
19333: PUSH
19334: LD_VAR 0 2
19338: ST_TO_ADDR
// break ;
19339: GO 19343
// end ;
19341: GO 19308
19343: POP
19344: POP
// if not labNum then
19345: LD_VAR 0 3
19349: NOT
19350: IFFALSE 19354
// exit ;
19352: GO 19516
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
19354: LD_INT 7
19356: PPUSH
19357: LD_EXP 65
19361: PUSH
19362: LD_VAR 0 3
19366: ARRAY
19367: PUSH
19368: LD_INT 3
19370: ARRAY
19371: PPUSH
19372: LD_INT 0
19374: PPUSH
19375: LD_VAR 0 1
19379: PPUSH
19380: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
19384: LD_ADDR_EXP 60
19388: PUSH
19389: LD_EXP 60
19393: PPUSH
19394: LD_VAR 0 3
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: CALL_OW 1
19406: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
19407: LD_ADDR_EXP 66
19411: PUSH
19412: LD_EXP 66
19416: PPUSH
19417: LD_VAR 0 3
19421: PPUSH
19422: LD_INT 1
19424: PPUSH
19425: CALL_OW 1
19429: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
19430: LD_ADDR_EXP 61
19434: PUSH
19435: LD_EXP 61
19439: PPUSH
19440: LD_VAR 0 3
19444: PPUSH
19445: LD_INT 0
19447: PPUSH
19448: CALL_OW 1
19452: ST_TO_ADDR
// case labNum of 1 :
19453: LD_VAR 0 3
19457: PUSH
19458: LD_INT 1
19460: DOUBLE
19461: EQUAL
19462: IFTRUE 19466
19464: GO 19477
19466: POP
// artifactIResearched := true ; 2 :
19467: LD_ADDR_EXP 9
19471: PUSH
19472: LD_INT 1
19474: ST_TO_ADDR
19475: GO 19516
19477: LD_INT 2
19479: DOUBLE
19480: EQUAL
19481: IFTRUE 19485
19483: GO 19496
19485: POP
// artifactIIResearched := true ; 3 :
19486: LD_ADDR_EXP 10
19490: PUSH
19491: LD_INT 1
19493: ST_TO_ADDR
19494: GO 19516
19496: LD_INT 3
19498: DOUBLE
19499: EQUAL
19500: IFTRUE 19504
19502: GO 19515
19504: POP
// artifactIIIResearched := true ; end ;
19505: LD_ADDR_EXP 11
19509: PUSH
19510: LD_INT 1
19512: ST_TO_ADDR
19513: GO 19516
19515: POP
// end ; end_of_file
19516: PPOPN 3
19518: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
19519: GO 19521
19521: DISABLE
// begin ru_radar := 98 ;
19522: LD_ADDR_EXP 67
19526: PUSH
19527: LD_INT 98
19529: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
19530: LD_ADDR_EXP 68
19534: PUSH
19535: LD_INT 89
19537: ST_TO_ADDR
// us_hack := 99 ;
19538: LD_ADDR_EXP 69
19542: PUSH
19543: LD_INT 99
19545: ST_TO_ADDR
// us_artillery := 97 ;
19546: LD_ADDR_EXP 70
19550: PUSH
19551: LD_INT 97
19553: ST_TO_ADDR
// ar_bio_bomb := 91 ;
19554: LD_ADDR_EXP 71
19558: PUSH
19559: LD_INT 91
19561: ST_TO_ADDR
// end ; end_of_file
19562: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
19563: LD_INT 0
19565: PPUSH
19566: PPUSH
// skirmish := false ;
19567: LD_ADDR_EXP 72
19571: PUSH
19572: LD_INT 0
19574: ST_TO_ADDR
// debug_mc := false ;
19575: LD_ADDR_EXP 73
19579: PUSH
19580: LD_INT 0
19582: ST_TO_ADDR
// mc_bases := [ ] ;
19583: LD_ADDR_EXP 74
19587: PUSH
19588: EMPTY
19589: ST_TO_ADDR
// mc_sides := [ ] ;
19590: LD_ADDR_EXP 100
19594: PUSH
19595: EMPTY
19596: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
19597: LD_ADDR_EXP 75
19601: PUSH
19602: EMPTY
19603: ST_TO_ADDR
// mc_building_repairs := [ ] ;
19604: LD_ADDR_EXP 76
19608: PUSH
19609: EMPTY
19610: ST_TO_ADDR
// mc_need_heal := [ ] ;
19611: LD_ADDR_EXP 77
19615: PUSH
19616: EMPTY
19617: ST_TO_ADDR
// mc_healers := [ ] ;
19618: LD_ADDR_EXP 78
19622: PUSH
19623: EMPTY
19624: ST_TO_ADDR
// mc_build_list := [ ] ;
19625: LD_ADDR_EXP 79
19629: PUSH
19630: EMPTY
19631: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
19632: LD_ADDR_EXP 106
19636: PUSH
19637: EMPTY
19638: ST_TO_ADDR
// mc_builders := [ ] ;
19639: LD_ADDR_EXP 80
19643: PUSH
19644: EMPTY
19645: ST_TO_ADDR
// mc_construct_list := [ ] ;
19646: LD_ADDR_EXP 81
19650: PUSH
19651: EMPTY
19652: ST_TO_ADDR
// mc_turret_list := [ ] ;
19653: LD_ADDR_EXP 82
19657: PUSH
19658: EMPTY
19659: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
19660: LD_ADDR_EXP 83
19664: PUSH
19665: EMPTY
19666: ST_TO_ADDR
// mc_miners := [ ] ;
19667: LD_ADDR_EXP 88
19671: PUSH
19672: EMPTY
19673: ST_TO_ADDR
// mc_mines := [ ] ;
19674: LD_ADDR_EXP 87
19678: PUSH
19679: EMPTY
19680: ST_TO_ADDR
// mc_minefields := [ ] ;
19681: LD_ADDR_EXP 89
19685: PUSH
19686: EMPTY
19687: ST_TO_ADDR
// mc_crates := [ ] ;
19688: LD_ADDR_EXP 90
19692: PUSH
19693: EMPTY
19694: ST_TO_ADDR
// mc_crates_collector := [ ] ;
19695: LD_ADDR_EXP 91
19699: PUSH
19700: EMPTY
19701: ST_TO_ADDR
// mc_crates_area := [ ] ;
19702: LD_ADDR_EXP 92
19706: PUSH
19707: EMPTY
19708: ST_TO_ADDR
// mc_vehicles := [ ] ;
19709: LD_ADDR_EXP 93
19713: PUSH
19714: EMPTY
19715: ST_TO_ADDR
// mc_attack := [ ] ;
19716: LD_ADDR_EXP 94
19720: PUSH
19721: EMPTY
19722: ST_TO_ADDR
// mc_produce := [ ] ;
19723: LD_ADDR_EXP 95
19727: PUSH
19728: EMPTY
19729: ST_TO_ADDR
// mc_defender := [ ] ;
19730: LD_ADDR_EXP 96
19734: PUSH
19735: EMPTY
19736: ST_TO_ADDR
// mc_parking := [ ] ;
19737: LD_ADDR_EXP 98
19741: PUSH
19742: EMPTY
19743: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
19744: LD_ADDR_EXP 84
19748: PUSH
19749: EMPTY
19750: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
19751: LD_ADDR_EXP 86
19755: PUSH
19756: EMPTY
19757: ST_TO_ADDR
// mc_scan := [ ] ;
19758: LD_ADDR_EXP 97
19762: PUSH
19763: EMPTY
19764: ST_TO_ADDR
// mc_scan_area := [ ] ;
19765: LD_ADDR_EXP 99
19769: PUSH
19770: EMPTY
19771: ST_TO_ADDR
// mc_tech := [ ] ;
19772: LD_ADDR_EXP 101
19776: PUSH
19777: EMPTY
19778: ST_TO_ADDR
// mc_class := [ ] ;
19779: LD_ADDR_EXP 115
19783: PUSH
19784: EMPTY
19785: ST_TO_ADDR
// mc_class_case_use := [ ] ;
19786: LD_ADDR_EXP 116
19790: PUSH
19791: EMPTY
19792: ST_TO_ADDR
// end ;
19793: LD_VAR 0 1
19797: RET
// export function MC_Kill ( base ) ; begin
19798: LD_INT 0
19800: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
19801: LD_ADDR_EXP 74
19805: PUSH
19806: LD_EXP 74
19810: PPUSH
19811: LD_VAR 0 1
19815: PPUSH
19816: EMPTY
19817: PPUSH
19818: CALL_OW 1
19822: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19823: LD_ADDR_EXP 75
19827: PUSH
19828: LD_EXP 75
19832: PPUSH
19833: LD_VAR 0 1
19837: PPUSH
19838: EMPTY
19839: PPUSH
19840: CALL_OW 1
19844: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19845: LD_ADDR_EXP 76
19849: PUSH
19850: LD_EXP 76
19854: PPUSH
19855: LD_VAR 0 1
19859: PPUSH
19860: EMPTY
19861: PPUSH
19862: CALL_OW 1
19866: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19867: LD_ADDR_EXP 77
19871: PUSH
19872: LD_EXP 77
19876: PPUSH
19877: LD_VAR 0 1
19881: PPUSH
19882: EMPTY
19883: PPUSH
19884: CALL_OW 1
19888: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19889: LD_ADDR_EXP 78
19893: PUSH
19894: LD_EXP 78
19898: PPUSH
19899: LD_VAR 0 1
19903: PPUSH
19904: EMPTY
19905: PPUSH
19906: CALL_OW 1
19910: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19911: LD_ADDR_EXP 79
19915: PUSH
19916: LD_EXP 79
19920: PPUSH
19921: LD_VAR 0 1
19925: PPUSH
19926: EMPTY
19927: PPUSH
19928: CALL_OW 1
19932: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19933: LD_ADDR_EXP 80
19937: PUSH
19938: LD_EXP 80
19942: PPUSH
19943: LD_VAR 0 1
19947: PPUSH
19948: EMPTY
19949: PPUSH
19950: CALL_OW 1
19954: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19955: LD_ADDR_EXP 81
19959: PUSH
19960: LD_EXP 81
19964: PPUSH
19965: LD_VAR 0 1
19969: PPUSH
19970: EMPTY
19971: PPUSH
19972: CALL_OW 1
19976: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19977: LD_ADDR_EXP 82
19981: PUSH
19982: LD_EXP 82
19986: PPUSH
19987: LD_VAR 0 1
19991: PPUSH
19992: EMPTY
19993: PPUSH
19994: CALL_OW 1
19998: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19999: LD_ADDR_EXP 83
20003: PUSH
20004: LD_EXP 83
20008: PPUSH
20009: LD_VAR 0 1
20013: PPUSH
20014: EMPTY
20015: PPUSH
20016: CALL_OW 1
20020: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20021: LD_ADDR_EXP 84
20025: PUSH
20026: LD_EXP 84
20030: PPUSH
20031: LD_VAR 0 1
20035: PPUSH
20036: EMPTY
20037: PPUSH
20038: CALL_OW 1
20042: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20043: LD_ADDR_EXP 85
20047: PUSH
20048: LD_EXP 85
20052: PPUSH
20053: LD_VAR 0 1
20057: PPUSH
20058: LD_INT 0
20060: PPUSH
20061: CALL_OW 1
20065: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20066: LD_ADDR_EXP 86
20070: PUSH
20071: LD_EXP 86
20075: PPUSH
20076: LD_VAR 0 1
20080: PPUSH
20081: EMPTY
20082: PPUSH
20083: CALL_OW 1
20087: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20088: LD_ADDR_EXP 87
20092: PUSH
20093: LD_EXP 87
20097: PPUSH
20098: LD_VAR 0 1
20102: PPUSH
20103: EMPTY
20104: PPUSH
20105: CALL_OW 1
20109: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20110: LD_ADDR_EXP 88
20114: PUSH
20115: LD_EXP 88
20119: PPUSH
20120: LD_VAR 0 1
20124: PPUSH
20125: EMPTY
20126: PPUSH
20127: CALL_OW 1
20131: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20132: LD_ADDR_EXP 89
20136: PUSH
20137: LD_EXP 89
20141: PPUSH
20142: LD_VAR 0 1
20146: PPUSH
20147: EMPTY
20148: PPUSH
20149: CALL_OW 1
20153: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20154: LD_ADDR_EXP 90
20158: PUSH
20159: LD_EXP 90
20163: PPUSH
20164: LD_VAR 0 1
20168: PPUSH
20169: EMPTY
20170: PPUSH
20171: CALL_OW 1
20175: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20176: LD_ADDR_EXP 91
20180: PUSH
20181: LD_EXP 91
20185: PPUSH
20186: LD_VAR 0 1
20190: PPUSH
20191: EMPTY
20192: PPUSH
20193: CALL_OW 1
20197: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20198: LD_ADDR_EXP 92
20202: PUSH
20203: LD_EXP 92
20207: PPUSH
20208: LD_VAR 0 1
20212: PPUSH
20213: EMPTY
20214: PPUSH
20215: CALL_OW 1
20219: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20220: LD_ADDR_EXP 93
20224: PUSH
20225: LD_EXP 93
20229: PPUSH
20230: LD_VAR 0 1
20234: PPUSH
20235: EMPTY
20236: PPUSH
20237: CALL_OW 1
20241: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20242: LD_ADDR_EXP 94
20246: PUSH
20247: LD_EXP 94
20251: PPUSH
20252: LD_VAR 0 1
20256: PPUSH
20257: EMPTY
20258: PPUSH
20259: CALL_OW 1
20263: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20264: LD_ADDR_EXP 95
20268: PUSH
20269: LD_EXP 95
20273: PPUSH
20274: LD_VAR 0 1
20278: PPUSH
20279: EMPTY
20280: PPUSH
20281: CALL_OW 1
20285: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20286: LD_ADDR_EXP 96
20290: PUSH
20291: LD_EXP 96
20295: PPUSH
20296: LD_VAR 0 1
20300: PPUSH
20301: EMPTY
20302: PPUSH
20303: CALL_OW 1
20307: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20308: LD_ADDR_EXP 97
20312: PUSH
20313: LD_EXP 97
20317: PPUSH
20318: LD_VAR 0 1
20322: PPUSH
20323: EMPTY
20324: PPUSH
20325: CALL_OW 1
20329: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20330: LD_ADDR_EXP 98
20334: PUSH
20335: LD_EXP 98
20339: PPUSH
20340: LD_VAR 0 1
20344: PPUSH
20345: EMPTY
20346: PPUSH
20347: CALL_OW 1
20351: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20352: LD_ADDR_EXP 99
20356: PUSH
20357: LD_EXP 99
20361: PPUSH
20362: LD_VAR 0 1
20366: PPUSH
20367: EMPTY
20368: PPUSH
20369: CALL_OW 1
20373: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20374: LD_ADDR_EXP 101
20378: PUSH
20379: LD_EXP 101
20383: PPUSH
20384: LD_VAR 0 1
20388: PPUSH
20389: EMPTY
20390: PPUSH
20391: CALL_OW 1
20395: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20396: LD_ADDR_EXP 103
20400: PUSH
20401: LD_EXP 103
20405: PPUSH
20406: LD_VAR 0 1
20410: PPUSH
20411: EMPTY
20412: PPUSH
20413: CALL_OW 1
20417: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20418: LD_ADDR_EXP 104
20422: PUSH
20423: LD_EXP 104
20427: PPUSH
20428: LD_VAR 0 1
20432: PPUSH
20433: EMPTY
20434: PPUSH
20435: CALL_OW 1
20439: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20440: LD_ADDR_EXP 105
20444: PUSH
20445: LD_EXP 105
20449: PPUSH
20450: LD_VAR 0 1
20454: PPUSH
20455: EMPTY
20456: PPUSH
20457: CALL_OW 1
20461: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20462: LD_ADDR_EXP 106
20466: PUSH
20467: LD_EXP 106
20471: PPUSH
20472: LD_VAR 0 1
20476: PPUSH
20477: EMPTY
20478: PPUSH
20479: CALL_OW 1
20483: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20484: LD_ADDR_EXP 107
20488: PUSH
20489: LD_EXP 107
20493: PPUSH
20494: LD_VAR 0 1
20498: PPUSH
20499: EMPTY
20500: PPUSH
20501: CALL_OW 1
20505: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20506: LD_ADDR_EXP 108
20510: PUSH
20511: LD_EXP 108
20515: PPUSH
20516: LD_VAR 0 1
20520: PPUSH
20521: EMPTY
20522: PPUSH
20523: CALL_OW 1
20527: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20528: LD_ADDR_EXP 109
20532: PUSH
20533: LD_EXP 109
20537: PPUSH
20538: LD_VAR 0 1
20542: PPUSH
20543: EMPTY
20544: PPUSH
20545: CALL_OW 1
20549: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20550: LD_ADDR_EXP 110
20554: PUSH
20555: LD_EXP 110
20559: PPUSH
20560: LD_VAR 0 1
20564: PPUSH
20565: EMPTY
20566: PPUSH
20567: CALL_OW 1
20571: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20572: LD_ADDR_EXP 111
20576: PUSH
20577: LD_EXP 111
20581: PPUSH
20582: LD_VAR 0 1
20586: PPUSH
20587: EMPTY
20588: PPUSH
20589: CALL_OW 1
20593: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20594: LD_ADDR_EXP 112
20598: PUSH
20599: LD_EXP 112
20603: PPUSH
20604: LD_VAR 0 1
20608: PPUSH
20609: EMPTY
20610: PPUSH
20611: CALL_OW 1
20615: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20616: LD_ADDR_EXP 113
20620: PUSH
20621: LD_EXP 113
20625: PPUSH
20626: LD_VAR 0 1
20630: PPUSH
20631: EMPTY
20632: PPUSH
20633: CALL_OW 1
20637: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20638: LD_ADDR_EXP 114
20642: PUSH
20643: LD_EXP 114
20647: PPUSH
20648: LD_VAR 0 1
20652: PPUSH
20653: EMPTY
20654: PPUSH
20655: CALL_OW 1
20659: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20660: LD_ADDR_EXP 115
20664: PUSH
20665: LD_EXP 115
20669: PPUSH
20670: LD_VAR 0 1
20674: PPUSH
20675: EMPTY
20676: PPUSH
20677: CALL_OW 1
20681: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20682: LD_ADDR_EXP 116
20686: PUSH
20687: LD_EXP 116
20691: PPUSH
20692: LD_VAR 0 1
20696: PPUSH
20697: LD_INT 0
20699: PPUSH
20700: CALL_OW 1
20704: ST_TO_ADDR
// end ;
20705: LD_VAR 0 2
20709: RET
// export function MC_Add ( side , units ) ; var base ; begin
20710: LD_INT 0
20712: PPUSH
20713: PPUSH
// base := mc_bases + 1 ;
20714: LD_ADDR_VAR 0 4
20718: PUSH
20719: LD_EXP 74
20723: PUSH
20724: LD_INT 1
20726: PLUS
20727: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
20728: LD_ADDR_EXP 100
20732: PUSH
20733: LD_EXP 100
20737: PPUSH
20738: LD_VAR 0 4
20742: PPUSH
20743: LD_VAR 0 1
20747: PPUSH
20748: CALL_OW 1
20752: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
20753: LD_ADDR_EXP 74
20757: PUSH
20758: LD_EXP 74
20762: PPUSH
20763: LD_VAR 0 4
20767: PPUSH
20768: LD_VAR 0 2
20772: PPUSH
20773: CALL_OW 1
20777: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20778: LD_ADDR_EXP 75
20782: PUSH
20783: LD_EXP 75
20787: PPUSH
20788: LD_VAR 0 4
20792: PPUSH
20793: EMPTY
20794: PPUSH
20795: CALL_OW 1
20799: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20800: LD_ADDR_EXP 76
20804: PUSH
20805: LD_EXP 76
20809: PPUSH
20810: LD_VAR 0 4
20814: PPUSH
20815: EMPTY
20816: PPUSH
20817: CALL_OW 1
20821: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20822: LD_ADDR_EXP 77
20826: PUSH
20827: LD_EXP 77
20831: PPUSH
20832: LD_VAR 0 4
20836: PPUSH
20837: EMPTY
20838: PPUSH
20839: CALL_OW 1
20843: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20844: LD_ADDR_EXP 78
20848: PUSH
20849: LD_EXP 78
20853: PPUSH
20854: LD_VAR 0 4
20858: PPUSH
20859: EMPTY
20860: PPUSH
20861: CALL_OW 1
20865: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20866: LD_ADDR_EXP 79
20870: PUSH
20871: LD_EXP 79
20875: PPUSH
20876: LD_VAR 0 4
20880: PPUSH
20881: EMPTY
20882: PPUSH
20883: CALL_OW 1
20887: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20888: LD_ADDR_EXP 80
20892: PUSH
20893: LD_EXP 80
20897: PPUSH
20898: LD_VAR 0 4
20902: PPUSH
20903: EMPTY
20904: PPUSH
20905: CALL_OW 1
20909: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20910: LD_ADDR_EXP 81
20914: PUSH
20915: LD_EXP 81
20919: PPUSH
20920: LD_VAR 0 4
20924: PPUSH
20925: EMPTY
20926: PPUSH
20927: CALL_OW 1
20931: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20932: LD_ADDR_EXP 82
20936: PUSH
20937: LD_EXP 82
20941: PPUSH
20942: LD_VAR 0 4
20946: PPUSH
20947: EMPTY
20948: PPUSH
20949: CALL_OW 1
20953: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20954: LD_ADDR_EXP 83
20958: PUSH
20959: LD_EXP 83
20963: PPUSH
20964: LD_VAR 0 4
20968: PPUSH
20969: EMPTY
20970: PPUSH
20971: CALL_OW 1
20975: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20976: LD_ADDR_EXP 84
20980: PUSH
20981: LD_EXP 84
20985: PPUSH
20986: LD_VAR 0 4
20990: PPUSH
20991: EMPTY
20992: PPUSH
20993: CALL_OW 1
20997: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20998: LD_ADDR_EXP 85
21002: PUSH
21003: LD_EXP 85
21007: PPUSH
21008: LD_VAR 0 4
21012: PPUSH
21013: LD_INT 0
21015: PPUSH
21016: CALL_OW 1
21020: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21021: LD_ADDR_EXP 86
21025: PUSH
21026: LD_EXP 86
21030: PPUSH
21031: LD_VAR 0 4
21035: PPUSH
21036: EMPTY
21037: PPUSH
21038: CALL_OW 1
21042: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21043: LD_ADDR_EXP 87
21047: PUSH
21048: LD_EXP 87
21052: PPUSH
21053: LD_VAR 0 4
21057: PPUSH
21058: EMPTY
21059: PPUSH
21060: CALL_OW 1
21064: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21065: LD_ADDR_EXP 88
21069: PUSH
21070: LD_EXP 88
21074: PPUSH
21075: LD_VAR 0 4
21079: PPUSH
21080: EMPTY
21081: PPUSH
21082: CALL_OW 1
21086: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21087: LD_ADDR_EXP 89
21091: PUSH
21092: LD_EXP 89
21096: PPUSH
21097: LD_VAR 0 4
21101: PPUSH
21102: EMPTY
21103: PPUSH
21104: CALL_OW 1
21108: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21109: LD_ADDR_EXP 90
21113: PUSH
21114: LD_EXP 90
21118: PPUSH
21119: LD_VAR 0 4
21123: PPUSH
21124: EMPTY
21125: PPUSH
21126: CALL_OW 1
21130: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21131: LD_ADDR_EXP 91
21135: PUSH
21136: LD_EXP 91
21140: PPUSH
21141: LD_VAR 0 4
21145: PPUSH
21146: EMPTY
21147: PPUSH
21148: CALL_OW 1
21152: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21153: LD_ADDR_EXP 92
21157: PUSH
21158: LD_EXP 92
21162: PPUSH
21163: LD_VAR 0 4
21167: PPUSH
21168: EMPTY
21169: PPUSH
21170: CALL_OW 1
21174: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21175: LD_ADDR_EXP 93
21179: PUSH
21180: LD_EXP 93
21184: PPUSH
21185: LD_VAR 0 4
21189: PPUSH
21190: EMPTY
21191: PPUSH
21192: CALL_OW 1
21196: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21197: LD_ADDR_EXP 94
21201: PUSH
21202: LD_EXP 94
21206: PPUSH
21207: LD_VAR 0 4
21211: PPUSH
21212: EMPTY
21213: PPUSH
21214: CALL_OW 1
21218: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21219: LD_ADDR_EXP 95
21223: PUSH
21224: LD_EXP 95
21228: PPUSH
21229: LD_VAR 0 4
21233: PPUSH
21234: EMPTY
21235: PPUSH
21236: CALL_OW 1
21240: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21241: LD_ADDR_EXP 96
21245: PUSH
21246: LD_EXP 96
21250: PPUSH
21251: LD_VAR 0 4
21255: PPUSH
21256: EMPTY
21257: PPUSH
21258: CALL_OW 1
21262: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21263: LD_ADDR_EXP 97
21267: PUSH
21268: LD_EXP 97
21272: PPUSH
21273: LD_VAR 0 4
21277: PPUSH
21278: EMPTY
21279: PPUSH
21280: CALL_OW 1
21284: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21285: LD_ADDR_EXP 98
21289: PUSH
21290: LD_EXP 98
21294: PPUSH
21295: LD_VAR 0 4
21299: PPUSH
21300: EMPTY
21301: PPUSH
21302: CALL_OW 1
21306: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21307: LD_ADDR_EXP 99
21311: PUSH
21312: LD_EXP 99
21316: PPUSH
21317: LD_VAR 0 4
21321: PPUSH
21322: EMPTY
21323: PPUSH
21324: CALL_OW 1
21328: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21329: LD_ADDR_EXP 101
21333: PUSH
21334: LD_EXP 101
21338: PPUSH
21339: LD_VAR 0 4
21343: PPUSH
21344: EMPTY
21345: PPUSH
21346: CALL_OW 1
21350: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21351: LD_ADDR_EXP 103
21355: PUSH
21356: LD_EXP 103
21360: PPUSH
21361: LD_VAR 0 4
21365: PPUSH
21366: EMPTY
21367: PPUSH
21368: CALL_OW 1
21372: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21373: LD_ADDR_EXP 104
21377: PUSH
21378: LD_EXP 104
21382: PPUSH
21383: LD_VAR 0 4
21387: PPUSH
21388: EMPTY
21389: PPUSH
21390: CALL_OW 1
21394: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21395: LD_ADDR_EXP 105
21399: PUSH
21400: LD_EXP 105
21404: PPUSH
21405: LD_VAR 0 4
21409: PPUSH
21410: EMPTY
21411: PPUSH
21412: CALL_OW 1
21416: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21417: LD_ADDR_EXP 106
21421: PUSH
21422: LD_EXP 106
21426: PPUSH
21427: LD_VAR 0 4
21431: PPUSH
21432: EMPTY
21433: PPUSH
21434: CALL_OW 1
21438: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21439: LD_ADDR_EXP 107
21443: PUSH
21444: LD_EXP 107
21448: PPUSH
21449: LD_VAR 0 4
21453: PPUSH
21454: EMPTY
21455: PPUSH
21456: CALL_OW 1
21460: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21461: LD_ADDR_EXP 108
21465: PUSH
21466: LD_EXP 108
21470: PPUSH
21471: LD_VAR 0 4
21475: PPUSH
21476: EMPTY
21477: PPUSH
21478: CALL_OW 1
21482: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21483: LD_ADDR_EXP 109
21487: PUSH
21488: LD_EXP 109
21492: PPUSH
21493: LD_VAR 0 4
21497: PPUSH
21498: EMPTY
21499: PPUSH
21500: CALL_OW 1
21504: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21505: LD_ADDR_EXP 110
21509: PUSH
21510: LD_EXP 110
21514: PPUSH
21515: LD_VAR 0 4
21519: PPUSH
21520: EMPTY
21521: PPUSH
21522: CALL_OW 1
21526: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21527: LD_ADDR_EXP 111
21531: PUSH
21532: LD_EXP 111
21536: PPUSH
21537: LD_VAR 0 4
21541: PPUSH
21542: EMPTY
21543: PPUSH
21544: CALL_OW 1
21548: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21549: LD_ADDR_EXP 112
21553: PUSH
21554: LD_EXP 112
21558: PPUSH
21559: LD_VAR 0 4
21563: PPUSH
21564: EMPTY
21565: PPUSH
21566: CALL_OW 1
21570: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21571: LD_ADDR_EXP 113
21575: PUSH
21576: LD_EXP 113
21580: PPUSH
21581: LD_VAR 0 4
21585: PPUSH
21586: EMPTY
21587: PPUSH
21588: CALL_OW 1
21592: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21593: LD_ADDR_EXP 114
21597: PUSH
21598: LD_EXP 114
21602: PPUSH
21603: LD_VAR 0 4
21607: PPUSH
21608: EMPTY
21609: PPUSH
21610: CALL_OW 1
21614: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21615: LD_ADDR_EXP 115
21619: PUSH
21620: LD_EXP 115
21624: PPUSH
21625: LD_VAR 0 4
21629: PPUSH
21630: EMPTY
21631: PPUSH
21632: CALL_OW 1
21636: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21637: LD_ADDR_EXP 116
21641: PUSH
21642: LD_EXP 116
21646: PPUSH
21647: LD_VAR 0 4
21651: PPUSH
21652: LD_INT 0
21654: PPUSH
21655: CALL_OW 1
21659: ST_TO_ADDR
// result := base ;
21660: LD_ADDR_VAR 0 3
21664: PUSH
21665: LD_VAR 0 4
21669: ST_TO_ADDR
// end ;
21670: LD_VAR 0 3
21674: RET
// export function MC_Start ( ) ; var i ; begin
21675: LD_INT 0
21677: PPUSH
21678: PPUSH
// for i = 1 to mc_bases do
21679: LD_ADDR_VAR 0 2
21683: PUSH
21684: DOUBLE
21685: LD_INT 1
21687: DEC
21688: ST_TO_ADDR
21689: LD_EXP 74
21693: PUSH
21694: FOR_TO
21695: IFFALSE 22772
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
21697: LD_ADDR_EXP 74
21701: PUSH
21702: LD_EXP 74
21706: PPUSH
21707: LD_VAR 0 2
21711: PPUSH
21712: LD_EXP 74
21716: PUSH
21717: LD_VAR 0 2
21721: ARRAY
21722: PUSH
21723: LD_INT 0
21725: DIFF
21726: PPUSH
21727: CALL_OW 1
21731: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
21732: LD_ADDR_EXP 75
21736: PUSH
21737: LD_EXP 75
21741: PPUSH
21742: LD_VAR 0 2
21746: PPUSH
21747: EMPTY
21748: PPUSH
21749: CALL_OW 1
21753: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
21754: LD_ADDR_EXP 76
21758: PUSH
21759: LD_EXP 76
21763: PPUSH
21764: LD_VAR 0 2
21768: PPUSH
21769: EMPTY
21770: PPUSH
21771: CALL_OW 1
21775: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
21776: LD_ADDR_EXP 77
21780: PUSH
21781: LD_EXP 77
21785: PPUSH
21786: LD_VAR 0 2
21790: PPUSH
21791: EMPTY
21792: PPUSH
21793: CALL_OW 1
21797: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
21798: LD_ADDR_EXP 78
21802: PUSH
21803: LD_EXP 78
21807: PPUSH
21808: LD_VAR 0 2
21812: PPUSH
21813: EMPTY
21814: PUSH
21815: EMPTY
21816: PUSH
21817: EMPTY
21818: LIST
21819: LIST
21820: PPUSH
21821: CALL_OW 1
21825: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
21826: LD_ADDR_EXP 79
21830: PUSH
21831: LD_EXP 79
21835: PPUSH
21836: LD_VAR 0 2
21840: PPUSH
21841: EMPTY
21842: PPUSH
21843: CALL_OW 1
21847: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
21848: LD_ADDR_EXP 106
21852: PUSH
21853: LD_EXP 106
21857: PPUSH
21858: LD_VAR 0 2
21862: PPUSH
21863: EMPTY
21864: PPUSH
21865: CALL_OW 1
21869: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
21870: LD_ADDR_EXP 80
21874: PUSH
21875: LD_EXP 80
21879: PPUSH
21880: LD_VAR 0 2
21884: PPUSH
21885: EMPTY
21886: PPUSH
21887: CALL_OW 1
21891: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
21892: LD_ADDR_EXP 81
21896: PUSH
21897: LD_EXP 81
21901: PPUSH
21902: LD_VAR 0 2
21906: PPUSH
21907: EMPTY
21908: PPUSH
21909: CALL_OW 1
21913: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
21914: LD_ADDR_EXP 82
21918: PUSH
21919: LD_EXP 82
21923: PPUSH
21924: LD_VAR 0 2
21928: PPUSH
21929: LD_EXP 74
21933: PUSH
21934: LD_VAR 0 2
21938: ARRAY
21939: PPUSH
21940: LD_INT 2
21942: PUSH
21943: LD_INT 30
21945: PUSH
21946: LD_INT 32
21948: PUSH
21949: EMPTY
21950: LIST
21951: LIST
21952: PUSH
21953: LD_INT 30
21955: PUSH
21956: LD_INT 33
21958: PUSH
21959: EMPTY
21960: LIST
21961: LIST
21962: PUSH
21963: EMPTY
21964: LIST
21965: LIST
21966: LIST
21967: PPUSH
21968: CALL_OW 72
21972: PPUSH
21973: CALL_OW 1
21977: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
21978: LD_ADDR_EXP 83
21982: PUSH
21983: LD_EXP 83
21987: PPUSH
21988: LD_VAR 0 2
21992: PPUSH
21993: LD_EXP 74
21997: PUSH
21998: LD_VAR 0 2
22002: ARRAY
22003: PPUSH
22004: LD_INT 2
22006: PUSH
22007: LD_INT 30
22009: PUSH
22010: LD_INT 32
22012: PUSH
22013: EMPTY
22014: LIST
22015: LIST
22016: PUSH
22017: LD_INT 30
22019: PUSH
22020: LD_INT 31
22022: PUSH
22023: EMPTY
22024: LIST
22025: LIST
22026: PUSH
22027: EMPTY
22028: LIST
22029: LIST
22030: LIST
22031: PUSH
22032: LD_INT 58
22034: PUSH
22035: EMPTY
22036: LIST
22037: PUSH
22038: EMPTY
22039: LIST
22040: LIST
22041: PPUSH
22042: CALL_OW 72
22046: PPUSH
22047: CALL_OW 1
22051: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22052: LD_ADDR_EXP 84
22056: PUSH
22057: LD_EXP 84
22061: PPUSH
22062: LD_VAR 0 2
22066: PPUSH
22067: EMPTY
22068: PPUSH
22069: CALL_OW 1
22073: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22074: LD_ADDR_EXP 88
22078: PUSH
22079: LD_EXP 88
22083: PPUSH
22084: LD_VAR 0 2
22088: PPUSH
22089: EMPTY
22090: PPUSH
22091: CALL_OW 1
22095: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22096: LD_ADDR_EXP 87
22100: PUSH
22101: LD_EXP 87
22105: PPUSH
22106: LD_VAR 0 2
22110: PPUSH
22111: EMPTY
22112: PPUSH
22113: CALL_OW 1
22117: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22118: LD_ADDR_EXP 89
22122: PUSH
22123: LD_EXP 89
22127: PPUSH
22128: LD_VAR 0 2
22132: PPUSH
22133: EMPTY
22134: PPUSH
22135: CALL_OW 1
22139: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22140: LD_ADDR_EXP 90
22144: PUSH
22145: LD_EXP 90
22149: PPUSH
22150: LD_VAR 0 2
22154: PPUSH
22155: EMPTY
22156: PPUSH
22157: CALL_OW 1
22161: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22162: LD_ADDR_EXP 91
22166: PUSH
22167: LD_EXP 91
22171: PPUSH
22172: LD_VAR 0 2
22176: PPUSH
22177: EMPTY
22178: PPUSH
22179: CALL_OW 1
22183: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22184: LD_ADDR_EXP 92
22188: PUSH
22189: LD_EXP 92
22193: PPUSH
22194: LD_VAR 0 2
22198: PPUSH
22199: EMPTY
22200: PPUSH
22201: CALL_OW 1
22205: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
22206: LD_ADDR_EXP 93
22210: PUSH
22211: LD_EXP 93
22215: PPUSH
22216: LD_VAR 0 2
22220: PPUSH
22221: EMPTY
22222: PPUSH
22223: CALL_OW 1
22227: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22228: LD_ADDR_EXP 94
22232: PUSH
22233: LD_EXP 94
22237: PPUSH
22238: LD_VAR 0 2
22242: PPUSH
22243: EMPTY
22244: PPUSH
22245: CALL_OW 1
22249: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
22250: LD_ADDR_EXP 95
22254: PUSH
22255: LD_EXP 95
22259: PPUSH
22260: LD_VAR 0 2
22264: PPUSH
22265: EMPTY
22266: PPUSH
22267: CALL_OW 1
22271: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
22272: LD_ADDR_EXP 96
22276: PUSH
22277: LD_EXP 96
22281: PPUSH
22282: LD_VAR 0 2
22286: PPUSH
22287: EMPTY
22288: PPUSH
22289: CALL_OW 1
22293: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
22294: LD_ADDR_EXP 85
22298: PUSH
22299: LD_EXP 85
22303: PPUSH
22304: LD_VAR 0 2
22308: PPUSH
22309: LD_INT 0
22311: PPUSH
22312: CALL_OW 1
22316: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
22317: LD_ADDR_EXP 98
22321: PUSH
22322: LD_EXP 98
22326: PPUSH
22327: LD_VAR 0 2
22331: PPUSH
22332: LD_INT 0
22334: PPUSH
22335: CALL_OW 1
22339: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
22340: LD_ADDR_EXP 86
22344: PUSH
22345: LD_EXP 86
22349: PPUSH
22350: LD_VAR 0 2
22354: PPUSH
22355: EMPTY
22356: PPUSH
22357: CALL_OW 1
22361: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
22362: LD_ADDR_EXP 97
22366: PUSH
22367: LD_EXP 97
22371: PPUSH
22372: LD_VAR 0 2
22376: PPUSH
22377: LD_INT 0
22379: PPUSH
22380: CALL_OW 1
22384: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
22385: LD_ADDR_EXP 99
22389: PUSH
22390: LD_EXP 99
22394: PPUSH
22395: LD_VAR 0 2
22399: PPUSH
22400: EMPTY
22401: PPUSH
22402: CALL_OW 1
22406: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
22407: LD_ADDR_EXP 102
22411: PUSH
22412: LD_EXP 102
22416: PPUSH
22417: LD_VAR 0 2
22421: PPUSH
22422: LD_INT 0
22424: PPUSH
22425: CALL_OW 1
22429: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
22430: LD_ADDR_EXP 103
22434: PUSH
22435: LD_EXP 103
22439: PPUSH
22440: LD_VAR 0 2
22444: PPUSH
22445: EMPTY
22446: PPUSH
22447: CALL_OW 1
22451: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
22452: LD_ADDR_EXP 104
22456: PUSH
22457: LD_EXP 104
22461: PPUSH
22462: LD_VAR 0 2
22466: PPUSH
22467: EMPTY
22468: PPUSH
22469: CALL_OW 1
22473: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
22474: LD_ADDR_EXP 105
22478: PUSH
22479: LD_EXP 105
22483: PPUSH
22484: LD_VAR 0 2
22488: PPUSH
22489: EMPTY
22490: PPUSH
22491: CALL_OW 1
22495: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
22496: LD_ADDR_EXP 107
22500: PUSH
22501: LD_EXP 107
22505: PPUSH
22506: LD_VAR 0 2
22510: PPUSH
22511: LD_EXP 74
22515: PUSH
22516: LD_VAR 0 2
22520: ARRAY
22521: PPUSH
22522: LD_INT 2
22524: PUSH
22525: LD_INT 30
22527: PUSH
22528: LD_INT 6
22530: PUSH
22531: EMPTY
22532: LIST
22533: LIST
22534: PUSH
22535: LD_INT 30
22537: PUSH
22538: LD_INT 7
22540: PUSH
22541: EMPTY
22542: LIST
22543: LIST
22544: PUSH
22545: LD_INT 30
22547: PUSH
22548: LD_INT 8
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: PPUSH
22561: CALL_OW 72
22565: PPUSH
22566: CALL_OW 1
22570: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
22571: LD_ADDR_EXP 108
22575: PUSH
22576: LD_EXP 108
22580: PPUSH
22581: LD_VAR 0 2
22585: PPUSH
22586: EMPTY
22587: PPUSH
22588: CALL_OW 1
22592: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
22593: LD_ADDR_EXP 109
22597: PUSH
22598: LD_EXP 109
22602: PPUSH
22603: LD_VAR 0 2
22607: PPUSH
22608: EMPTY
22609: PPUSH
22610: CALL_OW 1
22614: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
22615: LD_ADDR_EXP 110
22619: PUSH
22620: LD_EXP 110
22624: PPUSH
22625: LD_VAR 0 2
22629: PPUSH
22630: EMPTY
22631: PPUSH
22632: CALL_OW 1
22636: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
22637: LD_ADDR_EXP 111
22641: PUSH
22642: LD_EXP 111
22646: PPUSH
22647: LD_VAR 0 2
22651: PPUSH
22652: EMPTY
22653: PPUSH
22654: CALL_OW 1
22658: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
22659: LD_ADDR_EXP 112
22663: PUSH
22664: LD_EXP 112
22668: PPUSH
22669: LD_VAR 0 2
22673: PPUSH
22674: EMPTY
22675: PPUSH
22676: CALL_OW 1
22680: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
22681: LD_ADDR_EXP 113
22685: PUSH
22686: LD_EXP 113
22690: PPUSH
22691: LD_VAR 0 2
22695: PPUSH
22696: EMPTY
22697: PPUSH
22698: CALL_OW 1
22702: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
22703: LD_ADDR_EXP 114
22707: PUSH
22708: LD_EXP 114
22712: PPUSH
22713: LD_VAR 0 2
22717: PPUSH
22718: EMPTY
22719: PPUSH
22720: CALL_OW 1
22724: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
22725: LD_ADDR_EXP 115
22729: PUSH
22730: LD_EXP 115
22734: PPUSH
22735: LD_VAR 0 2
22739: PPUSH
22740: EMPTY
22741: PPUSH
22742: CALL_OW 1
22746: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
22747: LD_ADDR_EXP 116
22751: PUSH
22752: LD_EXP 116
22756: PPUSH
22757: LD_VAR 0 2
22761: PPUSH
22762: LD_INT 0
22764: PPUSH
22765: CALL_OW 1
22769: ST_TO_ADDR
// end ;
22770: GO 21694
22772: POP
22773: POP
// MC_InitSides ( ) ;
22774: CALL 23060 0 0
// MC_InitResearch ( ) ;
22778: CALL 22799 0 0
// CustomInitMacro ( ) ;
22782: CALL 173 0 0
// skirmish := true ;
22786: LD_ADDR_EXP 72
22790: PUSH
22791: LD_INT 1
22793: ST_TO_ADDR
// end ;
22794: LD_VAR 0 1
22798: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
22799: LD_INT 0
22801: PPUSH
22802: PPUSH
22803: PPUSH
22804: PPUSH
22805: PPUSH
22806: PPUSH
// if not mc_bases then
22807: LD_EXP 74
22811: NOT
22812: IFFALSE 22816
// exit ;
22814: GO 23055
// for i = 1 to 8 do
22816: LD_ADDR_VAR 0 2
22820: PUSH
22821: DOUBLE
22822: LD_INT 1
22824: DEC
22825: ST_TO_ADDR
22826: LD_INT 8
22828: PUSH
22829: FOR_TO
22830: IFFALSE 22856
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
22832: LD_ADDR_EXP 101
22836: PUSH
22837: LD_EXP 101
22841: PPUSH
22842: LD_VAR 0 2
22846: PPUSH
22847: EMPTY
22848: PPUSH
22849: CALL_OW 1
22853: ST_TO_ADDR
22854: GO 22829
22856: POP
22857: POP
// tmp := [ ] ;
22858: LD_ADDR_VAR 0 5
22862: PUSH
22863: EMPTY
22864: ST_TO_ADDR
// for i = 1 to mc_sides do
22865: LD_ADDR_VAR 0 2
22869: PUSH
22870: DOUBLE
22871: LD_INT 1
22873: DEC
22874: ST_TO_ADDR
22875: LD_EXP 100
22879: PUSH
22880: FOR_TO
22881: IFFALSE 22939
// if not mc_sides [ i ] in tmp then
22883: LD_EXP 100
22887: PUSH
22888: LD_VAR 0 2
22892: ARRAY
22893: PUSH
22894: LD_VAR 0 5
22898: IN
22899: NOT
22900: IFFALSE 22937
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
22902: LD_ADDR_VAR 0 5
22906: PUSH
22907: LD_VAR 0 5
22911: PPUSH
22912: LD_VAR 0 5
22916: PUSH
22917: LD_INT 1
22919: PLUS
22920: PPUSH
22921: LD_EXP 100
22925: PUSH
22926: LD_VAR 0 2
22930: ARRAY
22931: PPUSH
22932: CALL_OW 2
22936: ST_TO_ADDR
22937: GO 22880
22939: POP
22940: POP
// if not tmp then
22941: LD_VAR 0 5
22945: NOT
22946: IFFALSE 22950
// exit ;
22948: GO 23055
// for j in tmp do
22950: LD_ADDR_VAR 0 3
22954: PUSH
22955: LD_VAR 0 5
22959: PUSH
22960: FOR_IN
22961: IFFALSE 23053
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
22963: LD_ADDR_VAR 0 6
22967: PUSH
22968: LD_INT 22
22970: PUSH
22971: LD_VAR 0 3
22975: PUSH
22976: EMPTY
22977: LIST
22978: LIST
22979: PPUSH
22980: CALL_OW 69
22984: ST_TO_ADDR
// if not un then
22985: LD_VAR 0 6
22989: NOT
22990: IFFALSE 22994
// continue ;
22992: GO 22960
// nation := GetNation ( un [ 1 ] ) ;
22994: LD_ADDR_VAR 0 4
22998: PUSH
22999: LD_VAR 0 6
23003: PUSH
23004: LD_INT 1
23006: ARRAY
23007: PPUSH
23008: CALL_OW 248
23012: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23013: LD_ADDR_EXP 101
23017: PUSH
23018: LD_EXP 101
23022: PPUSH
23023: LD_VAR 0 3
23027: PPUSH
23028: LD_VAR 0 3
23032: PPUSH
23033: LD_VAR 0 4
23037: PPUSH
23038: LD_INT 1
23040: PPUSH
23041: CALL 49419 0 3
23045: PPUSH
23046: CALL_OW 1
23050: ST_TO_ADDR
// end ;
23051: GO 22960
23053: POP
23054: POP
// end ;
23055: LD_VAR 0 1
23059: RET
// export function MC_InitSides ( ) ; var i ; begin
23060: LD_INT 0
23062: PPUSH
23063: PPUSH
// if not mc_bases then
23064: LD_EXP 74
23068: NOT
23069: IFFALSE 23073
// exit ;
23071: GO 23147
// for i = 1 to mc_bases do
23073: LD_ADDR_VAR 0 2
23077: PUSH
23078: DOUBLE
23079: LD_INT 1
23081: DEC
23082: ST_TO_ADDR
23083: LD_EXP 74
23087: PUSH
23088: FOR_TO
23089: IFFALSE 23145
// if mc_bases [ i ] then
23091: LD_EXP 74
23095: PUSH
23096: LD_VAR 0 2
23100: ARRAY
23101: IFFALSE 23143
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23103: LD_ADDR_EXP 100
23107: PUSH
23108: LD_EXP 100
23112: PPUSH
23113: LD_VAR 0 2
23117: PPUSH
23118: LD_EXP 74
23122: PUSH
23123: LD_VAR 0 2
23127: ARRAY
23128: PUSH
23129: LD_INT 1
23131: ARRAY
23132: PPUSH
23133: CALL_OW 255
23137: PPUSH
23138: CALL_OW 1
23142: ST_TO_ADDR
23143: GO 23088
23145: POP
23146: POP
// end ;
23147: LD_VAR 0 1
23151: RET
// every 0 0$01 trigger skirmish do
23152: LD_EXP 72
23156: IFFALSE 23310
23158: GO 23160
23160: DISABLE
// begin enable ;
23161: ENABLE
// MC_CheckBuildings ( ) ;
23162: CALL 27808 0 0
// MC_CheckPeopleLife ( ) ;
23166: CALL 27933 0 0
// RaiseSailEvent ( 100 ) ;
23170: LD_INT 100
23172: PPUSH
23173: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23177: LD_INT 103
23179: PPUSH
23180: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23184: LD_INT 104
23186: PPUSH
23187: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23191: LD_INT 105
23193: PPUSH
23194: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
23198: LD_INT 106
23200: PPUSH
23201: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
23205: LD_INT 107
23207: PPUSH
23208: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
23212: LD_INT 108
23214: PPUSH
23215: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
23219: LD_INT 109
23221: PPUSH
23222: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
23226: LD_INT 110
23228: PPUSH
23229: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
23233: LD_INT 111
23235: PPUSH
23236: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
23240: LD_INT 112
23242: PPUSH
23243: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
23247: LD_INT 113
23249: PPUSH
23250: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
23254: LD_INT 120
23256: PPUSH
23257: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
23261: LD_INT 121
23263: PPUSH
23264: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
23268: LD_INT 122
23270: PPUSH
23271: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
23275: LD_INT 123
23277: PPUSH
23278: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
23282: LD_INT 124
23284: PPUSH
23285: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
23289: LD_INT 125
23291: PPUSH
23292: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
23296: LD_INT 126
23298: PPUSH
23299: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
23303: LD_INT 200
23305: PPUSH
23306: CALL_OW 427
// end ;
23310: END
// on SailEvent ( event ) do begin if event < 100 then
23311: LD_VAR 0 1
23315: PUSH
23316: LD_INT 100
23318: LESS
23319: IFFALSE 23330
// CustomEvent ( event ) ;
23321: LD_VAR 0 1
23325: PPUSH
23326: CALL 9784 0 1
// if event = 100 then
23330: LD_VAR 0 1
23334: PUSH
23335: LD_INT 100
23337: EQUAL
23338: IFFALSE 23344
// MC_ClassManager ( ) ;
23340: CALL 23736 0 0
// if event = 101 then
23344: LD_VAR 0 1
23348: PUSH
23349: LD_INT 101
23351: EQUAL
23352: IFFALSE 23358
// MC_RepairBuildings ( ) ;
23354: CALL 28529 0 0
// if event = 102 then
23358: LD_VAR 0 1
23362: PUSH
23363: LD_INT 102
23365: EQUAL
23366: IFFALSE 23372
// MC_Heal ( ) ;
23368: CALL 29261 0 0
// if event = 103 then
23372: LD_VAR 0 1
23376: PUSH
23377: LD_INT 103
23379: EQUAL
23380: IFFALSE 23386
// MC_Build ( ) ;
23382: CALL 29683 0 0
// if event = 104 then
23386: LD_VAR 0 1
23390: PUSH
23391: LD_INT 104
23393: EQUAL
23394: IFFALSE 23400
// MC_TurretWeapon ( ) ;
23396: CALL 31296 0 0
// if event = 105 then
23400: LD_VAR 0 1
23404: PUSH
23405: LD_INT 105
23407: EQUAL
23408: IFFALSE 23414
// MC_BuildUpgrade ( ) ;
23410: CALL 30847 0 0
// if event = 106 then
23414: LD_VAR 0 1
23418: PUSH
23419: LD_INT 106
23421: EQUAL
23422: IFFALSE 23428
// MC_PlantMines ( ) ;
23424: CALL 31726 0 0
// if event = 107 then
23428: LD_VAR 0 1
23432: PUSH
23433: LD_INT 107
23435: EQUAL
23436: IFFALSE 23442
// MC_CollectCrates ( ) ;
23438: CALL 32760 0 0
// if event = 108 then
23442: LD_VAR 0 1
23446: PUSH
23447: LD_INT 108
23449: EQUAL
23450: IFFALSE 23456
// MC_LinkRemoteControl ( ) ;
23452: CALL 34536 0 0
// if event = 109 then
23456: LD_VAR 0 1
23460: PUSH
23461: LD_INT 109
23463: EQUAL
23464: IFFALSE 23470
// MC_ProduceVehicle ( ) ;
23466: CALL 34717 0 0
// if event = 110 then
23470: LD_VAR 0 1
23474: PUSH
23475: LD_INT 110
23477: EQUAL
23478: IFFALSE 23484
// MC_SendAttack ( ) ;
23480: CALL 35183 0 0
// if event = 111 then
23484: LD_VAR 0 1
23488: PUSH
23489: LD_INT 111
23491: EQUAL
23492: IFFALSE 23498
// MC_Defend ( ) ;
23494: CALL 35291 0 0
// if event = 112 then
23498: LD_VAR 0 1
23502: PUSH
23503: LD_INT 112
23505: EQUAL
23506: IFFALSE 23512
// MC_Research ( ) ;
23508: CALL 35896 0 0
// if event = 113 then
23512: LD_VAR 0 1
23516: PUSH
23517: LD_INT 113
23519: EQUAL
23520: IFFALSE 23526
// MC_MinesTrigger ( ) ;
23522: CALL 37010 0 0
// if event = 120 then
23526: LD_VAR 0 1
23530: PUSH
23531: LD_INT 120
23533: EQUAL
23534: IFFALSE 23540
// MC_RepairVehicle ( ) ;
23536: CALL 37109 0 0
// if event = 121 then
23540: LD_VAR 0 1
23544: PUSH
23545: LD_INT 121
23547: EQUAL
23548: IFFALSE 23554
// MC_TameApe ( ) ;
23550: CALL 37839 0 0
// if event = 122 then
23554: LD_VAR 0 1
23558: PUSH
23559: LD_INT 122
23561: EQUAL
23562: IFFALSE 23568
// MC_ChangeApeClass ( ) ;
23564: CALL 38668 0 0
// if event = 123 then
23568: LD_VAR 0 1
23572: PUSH
23573: LD_INT 123
23575: EQUAL
23576: IFFALSE 23582
// MC_Bazooka ( ) ;
23578: CALL 39318 0 0
// if event = 124 then
23582: LD_VAR 0 1
23586: PUSH
23587: LD_INT 124
23589: EQUAL
23590: IFFALSE 23596
// MC_TeleportExit ( ) ;
23592: CALL 39516 0 0
// if event = 125 then
23596: LD_VAR 0 1
23600: PUSH
23601: LD_INT 125
23603: EQUAL
23604: IFFALSE 23610
// MC_Deposits ( ) ;
23606: CALL 40163 0 0
// if event = 126 then
23610: LD_VAR 0 1
23614: PUSH
23615: LD_INT 126
23617: EQUAL
23618: IFFALSE 23624
// MC_RemoteDriver ( ) ;
23620: CALL 40788 0 0
// if event = 200 then
23624: LD_VAR 0 1
23628: PUSH
23629: LD_INT 200
23631: EQUAL
23632: IFFALSE 23638
// MC_Idle ( ) ;
23634: CALL 42521 0 0
// end ;
23638: PPOPN 1
23640: END
// export function MC_Reset ( base , tag ) ; var i ; begin
23641: LD_INT 0
23643: PPUSH
23644: PPUSH
// if not mc_bases [ base ] or not tag then
23645: LD_EXP 74
23649: PUSH
23650: LD_VAR 0 1
23654: ARRAY
23655: NOT
23656: PUSH
23657: LD_VAR 0 2
23661: NOT
23662: OR
23663: IFFALSE 23667
// exit ;
23665: GO 23731
// for i in mc_bases [ base ] union mc_ape [ base ] do
23667: LD_ADDR_VAR 0 4
23671: PUSH
23672: LD_EXP 74
23676: PUSH
23677: LD_VAR 0 1
23681: ARRAY
23682: PUSH
23683: LD_EXP 103
23687: PUSH
23688: LD_VAR 0 1
23692: ARRAY
23693: UNION
23694: PUSH
23695: FOR_IN
23696: IFFALSE 23729
// if GetTag ( i ) = tag then
23698: LD_VAR 0 4
23702: PPUSH
23703: CALL_OW 110
23707: PUSH
23708: LD_VAR 0 2
23712: EQUAL
23713: IFFALSE 23727
// SetTag ( i , 0 ) ;
23715: LD_VAR 0 4
23719: PPUSH
23720: LD_INT 0
23722: PPUSH
23723: CALL_OW 109
23727: GO 23695
23729: POP
23730: POP
// end ;
23731: LD_VAR 0 3
23735: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
23736: LD_INT 0
23738: PPUSH
23739: PPUSH
23740: PPUSH
23741: PPUSH
23742: PPUSH
23743: PPUSH
23744: PPUSH
23745: PPUSH
// if not mc_bases then
23746: LD_EXP 74
23750: NOT
23751: IFFALSE 23755
// exit ;
23753: GO 24213
// for i = 1 to mc_bases do
23755: LD_ADDR_VAR 0 2
23759: PUSH
23760: DOUBLE
23761: LD_INT 1
23763: DEC
23764: ST_TO_ADDR
23765: LD_EXP 74
23769: PUSH
23770: FOR_TO
23771: IFFALSE 24211
// begin tmp := MC_ClassCheckReq ( i ) ;
23773: LD_ADDR_VAR 0 4
23777: PUSH
23778: LD_VAR 0 2
23782: PPUSH
23783: CALL 24218 0 1
23787: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
23788: LD_ADDR_EXP 115
23792: PUSH
23793: LD_EXP 115
23797: PPUSH
23798: LD_VAR 0 2
23802: PPUSH
23803: LD_VAR 0 4
23807: PPUSH
23808: CALL_OW 1
23812: ST_TO_ADDR
// if not tmp then
23813: LD_VAR 0 4
23817: NOT
23818: IFFALSE 23822
// continue ;
23820: GO 23770
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
23822: LD_ADDR_VAR 0 6
23826: PUSH
23827: LD_EXP 74
23831: PUSH
23832: LD_VAR 0 2
23836: ARRAY
23837: PPUSH
23838: LD_INT 2
23840: PUSH
23841: LD_INT 30
23843: PUSH
23844: LD_INT 4
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: PUSH
23851: LD_INT 30
23853: PUSH
23854: LD_INT 5
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: PUSH
23861: EMPTY
23862: LIST
23863: LIST
23864: LIST
23865: PPUSH
23866: CALL_OW 72
23870: PUSH
23871: LD_EXP 74
23875: PUSH
23876: LD_VAR 0 2
23880: ARRAY
23881: PPUSH
23882: LD_INT 2
23884: PUSH
23885: LD_INT 30
23887: PUSH
23888: LD_INT 0
23890: PUSH
23891: EMPTY
23892: LIST
23893: LIST
23894: PUSH
23895: LD_INT 30
23897: PUSH
23898: LD_INT 1
23900: PUSH
23901: EMPTY
23902: LIST
23903: LIST
23904: PUSH
23905: EMPTY
23906: LIST
23907: LIST
23908: LIST
23909: PPUSH
23910: CALL_OW 72
23914: PUSH
23915: LD_EXP 74
23919: PUSH
23920: LD_VAR 0 2
23924: ARRAY
23925: PPUSH
23926: LD_INT 30
23928: PUSH
23929: LD_INT 3
23931: PUSH
23932: EMPTY
23933: LIST
23934: LIST
23935: PPUSH
23936: CALL_OW 72
23940: PUSH
23941: LD_EXP 74
23945: PUSH
23946: LD_VAR 0 2
23950: ARRAY
23951: PPUSH
23952: LD_INT 2
23954: PUSH
23955: LD_INT 30
23957: PUSH
23958: LD_INT 6
23960: PUSH
23961: EMPTY
23962: LIST
23963: LIST
23964: PUSH
23965: LD_INT 30
23967: PUSH
23968: LD_INT 7
23970: PUSH
23971: EMPTY
23972: LIST
23973: LIST
23974: PUSH
23975: LD_INT 30
23977: PUSH
23978: LD_INT 8
23980: PUSH
23981: EMPTY
23982: LIST
23983: LIST
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: LIST
23989: LIST
23990: PPUSH
23991: CALL_OW 72
23995: PUSH
23996: EMPTY
23997: LIST
23998: LIST
23999: LIST
24000: LIST
24001: ST_TO_ADDR
// for j = 1 to 4 do
24002: LD_ADDR_VAR 0 3
24006: PUSH
24007: DOUBLE
24008: LD_INT 1
24010: DEC
24011: ST_TO_ADDR
24012: LD_INT 4
24014: PUSH
24015: FOR_TO
24016: IFFALSE 24207
// begin if not tmp [ j ] then
24018: LD_VAR 0 4
24022: PUSH
24023: LD_VAR 0 3
24027: ARRAY
24028: NOT
24029: IFFALSE 24033
// continue ;
24031: GO 24015
// for p in tmp [ j ] do
24033: LD_ADDR_VAR 0 5
24037: PUSH
24038: LD_VAR 0 4
24042: PUSH
24043: LD_VAR 0 3
24047: ARRAY
24048: PUSH
24049: FOR_IN
24050: IFFALSE 24203
// begin if not b [ j ] then
24052: LD_VAR 0 6
24056: PUSH
24057: LD_VAR 0 3
24061: ARRAY
24062: NOT
24063: IFFALSE 24067
// break ;
24065: GO 24203
// e := 0 ;
24067: LD_ADDR_VAR 0 7
24071: PUSH
24072: LD_INT 0
24074: ST_TO_ADDR
// for k in b [ j ] do
24075: LD_ADDR_VAR 0 8
24079: PUSH
24080: LD_VAR 0 6
24084: PUSH
24085: LD_VAR 0 3
24089: ARRAY
24090: PUSH
24091: FOR_IN
24092: IFFALSE 24119
// if IsNotFull ( k ) then
24094: LD_VAR 0 8
24098: PPUSH
24099: CALL 53495 0 1
24103: IFFALSE 24117
// begin e := k ;
24105: LD_ADDR_VAR 0 7
24109: PUSH
24110: LD_VAR 0 8
24114: ST_TO_ADDR
// break ;
24115: GO 24119
// end ;
24117: GO 24091
24119: POP
24120: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24121: LD_VAR 0 7
24125: PUSH
24126: LD_VAR 0 5
24130: PPUSH
24131: LD_VAR 0 7
24135: PPUSH
24136: CALL 90614 0 2
24140: NOT
24141: AND
24142: IFFALSE 24201
// begin if IsInUnit ( p ) then
24144: LD_VAR 0 5
24148: PPUSH
24149: CALL_OW 310
24153: IFFALSE 24164
// ComExitBuilding ( p ) ;
24155: LD_VAR 0 5
24159: PPUSH
24160: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24164: LD_VAR 0 5
24168: PPUSH
24169: LD_VAR 0 7
24173: PPUSH
24174: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24178: LD_VAR 0 5
24182: PPUSH
24183: LD_VAR 0 3
24187: PPUSH
24188: CALL_OW 183
// AddComExitBuilding ( p ) ;
24192: LD_VAR 0 5
24196: PPUSH
24197: CALL_OW 182
// end ; end ;
24201: GO 24049
24203: POP
24204: POP
// end ;
24205: GO 24015
24207: POP
24208: POP
// end ;
24209: GO 23770
24211: POP
24212: POP
// end ;
24213: LD_VAR 0 1
24217: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
24218: LD_INT 0
24220: PPUSH
24221: PPUSH
24222: PPUSH
24223: PPUSH
24224: PPUSH
24225: PPUSH
24226: PPUSH
24227: PPUSH
24228: PPUSH
24229: PPUSH
24230: PPUSH
24231: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24232: LD_VAR 0 1
24236: NOT
24237: PUSH
24238: LD_EXP 74
24242: PUSH
24243: LD_VAR 0 1
24247: ARRAY
24248: NOT
24249: OR
24250: PUSH
24251: LD_EXP 74
24255: PUSH
24256: LD_VAR 0 1
24260: ARRAY
24261: PPUSH
24262: LD_INT 2
24264: PUSH
24265: LD_INT 30
24267: PUSH
24268: LD_INT 0
24270: PUSH
24271: EMPTY
24272: LIST
24273: LIST
24274: PUSH
24275: LD_INT 30
24277: PUSH
24278: LD_INT 1
24280: PUSH
24281: EMPTY
24282: LIST
24283: LIST
24284: PUSH
24285: EMPTY
24286: LIST
24287: LIST
24288: LIST
24289: PPUSH
24290: CALL_OW 72
24294: NOT
24295: OR
24296: IFFALSE 24300
// exit ;
24298: GO 27803
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24300: LD_ADDR_VAR 0 4
24304: PUSH
24305: LD_EXP 74
24309: PUSH
24310: LD_VAR 0 1
24314: ARRAY
24315: PPUSH
24316: LD_INT 2
24318: PUSH
24319: LD_INT 25
24321: PUSH
24322: LD_INT 1
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: PUSH
24329: LD_INT 25
24331: PUSH
24332: LD_INT 2
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: LD_INT 25
24341: PUSH
24342: LD_INT 3
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: LD_INT 25
24351: PUSH
24352: LD_INT 4
24354: PUSH
24355: EMPTY
24356: LIST
24357: LIST
24358: PUSH
24359: LD_INT 25
24361: PUSH
24362: LD_INT 5
24364: PUSH
24365: EMPTY
24366: LIST
24367: LIST
24368: PUSH
24369: LD_INT 25
24371: PUSH
24372: LD_INT 8
24374: PUSH
24375: EMPTY
24376: LIST
24377: LIST
24378: PUSH
24379: LD_INT 25
24381: PUSH
24382: LD_INT 9
24384: PUSH
24385: EMPTY
24386: LIST
24387: LIST
24388: PUSH
24389: EMPTY
24390: LIST
24391: LIST
24392: LIST
24393: LIST
24394: LIST
24395: LIST
24396: LIST
24397: LIST
24398: PPUSH
24399: CALL_OW 72
24403: ST_TO_ADDR
// if not tmp then
24404: LD_VAR 0 4
24408: NOT
24409: IFFALSE 24413
// exit ;
24411: GO 27803
// for i in tmp do
24413: LD_ADDR_VAR 0 3
24417: PUSH
24418: LD_VAR 0 4
24422: PUSH
24423: FOR_IN
24424: IFFALSE 24455
// if GetTag ( i ) then
24426: LD_VAR 0 3
24430: PPUSH
24431: CALL_OW 110
24435: IFFALSE 24453
// tmp := tmp diff i ;
24437: LD_ADDR_VAR 0 4
24441: PUSH
24442: LD_VAR 0 4
24446: PUSH
24447: LD_VAR 0 3
24451: DIFF
24452: ST_TO_ADDR
24453: GO 24423
24455: POP
24456: POP
// if not tmp then
24457: LD_VAR 0 4
24461: NOT
24462: IFFALSE 24466
// exit ;
24464: GO 27803
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24466: LD_ADDR_VAR 0 5
24470: PUSH
24471: LD_EXP 74
24475: PUSH
24476: LD_VAR 0 1
24480: ARRAY
24481: PPUSH
24482: LD_INT 2
24484: PUSH
24485: LD_INT 25
24487: PUSH
24488: LD_INT 1
24490: PUSH
24491: EMPTY
24492: LIST
24493: LIST
24494: PUSH
24495: LD_INT 25
24497: PUSH
24498: LD_INT 5
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: PUSH
24505: LD_INT 25
24507: PUSH
24508: LD_INT 8
24510: PUSH
24511: EMPTY
24512: LIST
24513: LIST
24514: PUSH
24515: LD_INT 25
24517: PUSH
24518: LD_INT 9
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: LIST
24529: LIST
24530: LIST
24531: PPUSH
24532: CALL_OW 72
24536: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
24537: LD_ADDR_VAR 0 6
24541: PUSH
24542: LD_EXP 74
24546: PUSH
24547: LD_VAR 0 1
24551: ARRAY
24552: PPUSH
24553: LD_INT 25
24555: PUSH
24556: LD_INT 2
24558: PUSH
24559: EMPTY
24560: LIST
24561: LIST
24562: PPUSH
24563: CALL_OW 72
24567: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
24568: LD_ADDR_VAR 0 7
24572: PUSH
24573: LD_EXP 74
24577: PUSH
24578: LD_VAR 0 1
24582: ARRAY
24583: PPUSH
24584: LD_INT 25
24586: PUSH
24587: LD_INT 3
24589: PUSH
24590: EMPTY
24591: LIST
24592: LIST
24593: PPUSH
24594: CALL_OW 72
24598: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
24599: LD_ADDR_VAR 0 8
24603: PUSH
24604: LD_EXP 74
24608: PUSH
24609: LD_VAR 0 1
24613: ARRAY
24614: PPUSH
24615: LD_INT 25
24617: PUSH
24618: LD_INT 4
24620: PUSH
24621: EMPTY
24622: LIST
24623: LIST
24624: PUSH
24625: LD_INT 24
24627: PUSH
24628: LD_INT 251
24630: PUSH
24631: EMPTY
24632: LIST
24633: LIST
24634: PUSH
24635: EMPTY
24636: LIST
24637: LIST
24638: PPUSH
24639: CALL_OW 72
24643: ST_TO_ADDR
// if mc_scan [ base ] then
24644: LD_EXP 97
24648: PUSH
24649: LD_VAR 0 1
24653: ARRAY
24654: IFFALSE 25115
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
24656: LD_ADDR_EXP 116
24660: PUSH
24661: LD_EXP 116
24665: PPUSH
24666: LD_VAR 0 1
24670: PPUSH
24671: LD_INT 4
24673: PPUSH
24674: CALL_OW 1
24678: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
24679: LD_ADDR_VAR 0 12
24683: PUSH
24684: LD_EXP 74
24688: PUSH
24689: LD_VAR 0 1
24693: ARRAY
24694: PPUSH
24695: LD_INT 2
24697: PUSH
24698: LD_INT 30
24700: PUSH
24701: LD_INT 4
24703: PUSH
24704: EMPTY
24705: LIST
24706: LIST
24707: PUSH
24708: LD_INT 30
24710: PUSH
24711: LD_INT 5
24713: PUSH
24714: EMPTY
24715: LIST
24716: LIST
24717: PUSH
24718: EMPTY
24719: LIST
24720: LIST
24721: LIST
24722: PPUSH
24723: CALL_OW 72
24727: ST_TO_ADDR
// if not b then
24728: LD_VAR 0 12
24732: NOT
24733: IFFALSE 24737
// exit ;
24735: GO 27803
// p := [ ] ;
24737: LD_ADDR_VAR 0 11
24741: PUSH
24742: EMPTY
24743: ST_TO_ADDR
// if sci >= 2 then
24744: LD_VAR 0 8
24748: PUSH
24749: LD_INT 2
24751: GREATEREQUAL
24752: IFFALSE 24783
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
24754: LD_ADDR_VAR 0 8
24758: PUSH
24759: LD_VAR 0 8
24763: PUSH
24764: LD_INT 1
24766: ARRAY
24767: PUSH
24768: LD_VAR 0 8
24772: PUSH
24773: LD_INT 2
24775: ARRAY
24776: PUSH
24777: EMPTY
24778: LIST
24779: LIST
24780: ST_TO_ADDR
24781: GO 24844
// if sci = 1 then
24783: LD_VAR 0 8
24787: PUSH
24788: LD_INT 1
24790: EQUAL
24791: IFFALSE 24812
// sci := [ sci [ 1 ] ] else
24793: LD_ADDR_VAR 0 8
24797: PUSH
24798: LD_VAR 0 8
24802: PUSH
24803: LD_INT 1
24805: ARRAY
24806: PUSH
24807: EMPTY
24808: LIST
24809: ST_TO_ADDR
24810: GO 24844
// if sci = 0 then
24812: LD_VAR 0 8
24816: PUSH
24817: LD_INT 0
24819: EQUAL
24820: IFFALSE 24844
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
24822: LD_ADDR_VAR 0 11
24826: PUSH
24827: LD_VAR 0 4
24831: PPUSH
24832: LD_INT 4
24834: PPUSH
24835: CALL 90477 0 2
24839: PUSH
24840: LD_INT 1
24842: ARRAY
24843: ST_TO_ADDR
// if eng > 4 then
24844: LD_VAR 0 6
24848: PUSH
24849: LD_INT 4
24851: GREATER
24852: IFFALSE 24898
// for i = eng downto 4 do
24854: LD_ADDR_VAR 0 3
24858: PUSH
24859: DOUBLE
24860: LD_VAR 0 6
24864: INC
24865: ST_TO_ADDR
24866: LD_INT 4
24868: PUSH
24869: FOR_DOWNTO
24870: IFFALSE 24896
// eng := eng diff eng [ i ] ;
24872: LD_ADDR_VAR 0 6
24876: PUSH
24877: LD_VAR 0 6
24881: PUSH
24882: LD_VAR 0 6
24886: PUSH
24887: LD_VAR 0 3
24891: ARRAY
24892: DIFF
24893: ST_TO_ADDR
24894: GO 24869
24896: POP
24897: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
24898: LD_ADDR_VAR 0 4
24902: PUSH
24903: LD_VAR 0 4
24907: PUSH
24908: LD_VAR 0 5
24912: PUSH
24913: LD_VAR 0 6
24917: UNION
24918: PUSH
24919: LD_VAR 0 7
24923: UNION
24924: PUSH
24925: LD_VAR 0 8
24929: UNION
24930: DIFF
24931: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
24932: LD_ADDR_VAR 0 13
24936: PUSH
24937: LD_EXP 74
24941: PUSH
24942: LD_VAR 0 1
24946: ARRAY
24947: PPUSH
24948: LD_INT 2
24950: PUSH
24951: LD_INT 30
24953: PUSH
24954: LD_INT 32
24956: PUSH
24957: EMPTY
24958: LIST
24959: LIST
24960: PUSH
24961: LD_INT 30
24963: PUSH
24964: LD_INT 31
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: PUSH
24971: EMPTY
24972: LIST
24973: LIST
24974: LIST
24975: PPUSH
24976: CALL_OW 72
24980: PUSH
24981: LD_EXP 74
24985: PUSH
24986: LD_VAR 0 1
24990: ARRAY
24991: PPUSH
24992: LD_INT 2
24994: PUSH
24995: LD_INT 30
24997: PUSH
24998: LD_INT 4
25000: PUSH
25001: EMPTY
25002: LIST
25003: LIST
25004: PUSH
25005: LD_INT 30
25007: PUSH
25008: LD_INT 5
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: EMPTY
25016: LIST
25017: LIST
25018: LIST
25019: PPUSH
25020: CALL_OW 72
25024: PUSH
25025: LD_INT 6
25027: MUL
25028: PLUS
25029: ST_TO_ADDR
// if bcount < tmp then
25030: LD_VAR 0 13
25034: PUSH
25035: LD_VAR 0 4
25039: LESS
25040: IFFALSE 25086
// for i = tmp downto bcount do
25042: LD_ADDR_VAR 0 3
25046: PUSH
25047: DOUBLE
25048: LD_VAR 0 4
25052: INC
25053: ST_TO_ADDR
25054: LD_VAR 0 13
25058: PUSH
25059: FOR_DOWNTO
25060: IFFALSE 25084
// tmp := Delete ( tmp , tmp ) ;
25062: LD_ADDR_VAR 0 4
25066: PUSH
25067: LD_VAR 0 4
25071: PPUSH
25072: LD_VAR 0 4
25076: PPUSH
25077: CALL_OW 3
25081: ST_TO_ADDR
25082: GO 25059
25084: POP
25085: POP
// result := [ tmp , 0 , 0 , p ] ;
25086: LD_ADDR_VAR 0 2
25090: PUSH
25091: LD_VAR 0 4
25095: PUSH
25096: LD_INT 0
25098: PUSH
25099: LD_INT 0
25101: PUSH
25102: LD_VAR 0 11
25106: PUSH
25107: EMPTY
25108: LIST
25109: LIST
25110: LIST
25111: LIST
25112: ST_TO_ADDR
// exit ;
25113: GO 27803
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25115: LD_EXP 74
25119: PUSH
25120: LD_VAR 0 1
25124: ARRAY
25125: PPUSH
25126: LD_INT 2
25128: PUSH
25129: LD_INT 30
25131: PUSH
25132: LD_INT 6
25134: PUSH
25135: EMPTY
25136: LIST
25137: LIST
25138: PUSH
25139: LD_INT 30
25141: PUSH
25142: LD_INT 7
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: PUSH
25149: LD_INT 30
25151: PUSH
25152: LD_INT 8
25154: PUSH
25155: EMPTY
25156: LIST
25157: LIST
25158: PUSH
25159: EMPTY
25160: LIST
25161: LIST
25162: LIST
25163: LIST
25164: PPUSH
25165: CALL_OW 72
25169: NOT
25170: PUSH
25171: LD_EXP 74
25175: PUSH
25176: LD_VAR 0 1
25180: ARRAY
25181: PPUSH
25182: LD_INT 30
25184: PUSH
25185: LD_INT 3
25187: PUSH
25188: EMPTY
25189: LIST
25190: LIST
25191: PPUSH
25192: CALL_OW 72
25196: NOT
25197: AND
25198: IFFALSE 25270
// begin if eng = tmp then
25200: LD_VAR 0 6
25204: PUSH
25205: LD_VAR 0 4
25209: EQUAL
25210: IFFALSE 25214
// exit ;
25212: GO 27803
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
25214: LD_ADDR_EXP 116
25218: PUSH
25219: LD_EXP 116
25223: PPUSH
25224: LD_VAR 0 1
25228: PPUSH
25229: LD_INT 1
25231: PPUSH
25232: CALL_OW 1
25236: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
25237: LD_ADDR_VAR 0 2
25241: PUSH
25242: LD_INT 0
25244: PUSH
25245: LD_VAR 0 4
25249: PUSH
25250: LD_VAR 0 6
25254: DIFF
25255: PUSH
25256: LD_INT 0
25258: PUSH
25259: LD_INT 0
25261: PUSH
25262: EMPTY
25263: LIST
25264: LIST
25265: LIST
25266: LIST
25267: ST_TO_ADDR
// exit ;
25268: GO 27803
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25270: LD_EXP 101
25274: PUSH
25275: LD_EXP 100
25279: PUSH
25280: LD_VAR 0 1
25284: ARRAY
25285: ARRAY
25286: PUSH
25287: LD_EXP 74
25291: PUSH
25292: LD_VAR 0 1
25296: ARRAY
25297: PPUSH
25298: LD_INT 2
25300: PUSH
25301: LD_INT 30
25303: PUSH
25304: LD_INT 6
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: PUSH
25311: LD_INT 30
25313: PUSH
25314: LD_INT 7
25316: PUSH
25317: EMPTY
25318: LIST
25319: LIST
25320: PUSH
25321: LD_INT 30
25323: PUSH
25324: LD_INT 8
25326: PUSH
25327: EMPTY
25328: LIST
25329: LIST
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: LIST
25335: LIST
25336: PPUSH
25337: CALL_OW 72
25341: AND
25342: PUSH
25343: LD_EXP 74
25347: PUSH
25348: LD_VAR 0 1
25352: ARRAY
25353: PPUSH
25354: LD_INT 30
25356: PUSH
25357: LD_INT 3
25359: PUSH
25360: EMPTY
25361: LIST
25362: LIST
25363: PPUSH
25364: CALL_OW 72
25368: NOT
25369: AND
25370: IFFALSE 25584
// begin if sci >= 6 then
25372: LD_VAR 0 8
25376: PUSH
25377: LD_INT 6
25379: GREATEREQUAL
25380: IFFALSE 25384
// exit ;
25382: GO 27803
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
25384: LD_ADDR_EXP 116
25388: PUSH
25389: LD_EXP 116
25393: PPUSH
25394: LD_VAR 0 1
25398: PPUSH
25399: LD_INT 2
25401: PPUSH
25402: CALL_OW 1
25406: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
25407: LD_ADDR_VAR 0 9
25411: PUSH
25412: LD_VAR 0 4
25416: PUSH
25417: LD_VAR 0 8
25421: DIFF
25422: PPUSH
25423: LD_INT 4
25425: PPUSH
25426: CALL 90477 0 2
25430: ST_TO_ADDR
// p := [ ] ;
25431: LD_ADDR_VAR 0 11
25435: PUSH
25436: EMPTY
25437: ST_TO_ADDR
// if sci < 6 and sort > 6 then
25438: LD_VAR 0 8
25442: PUSH
25443: LD_INT 6
25445: LESS
25446: PUSH
25447: LD_VAR 0 9
25451: PUSH
25452: LD_INT 6
25454: GREATER
25455: AND
25456: IFFALSE 25537
// begin for i = 1 to 6 - sci do
25458: LD_ADDR_VAR 0 3
25462: PUSH
25463: DOUBLE
25464: LD_INT 1
25466: DEC
25467: ST_TO_ADDR
25468: LD_INT 6
25470: PUSH
25471: LD_VAR 0 8
25475: MINUS
25476: PUSH
25477: FOR_TO
25478: IFFALSE 25533
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
25480: LD_ADDR_VAR 0 11
25484: PUSH
25485: LD_VAR 0 11
25489: PPUSH
25490: LD_VAR 0 11
25494: PUSH
25495: LD_INT 1
25497: PLUS
25498: PPUSH
25499: LD_VAR 0 9
25503: PUSH
25504: LD_INT 1
25506: ARRAY
25507: PPUSH
25508: CALL_OW 2
25512: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
25513: LD_ADDR_VAR 0 9
25517: PUSH
25518: LD_VAR 0 9
25522: PPUSH
25523: LD_INT 1
25525: PPUSH
25526: CALL_OW 3
25530: ST_TO_ADDR
// end ;
25531: GO 25477
25533: POP
25534: POP
// end else
25535: GO 25557
// if sort then
25537: LD_VAR 0 9
25541: IFFALSE 25557
// p := sort [ 1 ] ;
25543: LD_ADDR_VAR 0 11
25547: PUSH
25548: LD_VAR 0 9
25552: PUSH
25553: LD_INT 1
25555: ARRAY
25556: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
25557: LD_ADDR_VAR 0 2
25561: PUSH
25562: LD_INT 0
25564: PUSH
25565: LD_INT 0
25567: PUSH
25568: LD_INT 0
25570: PUSH
25571: LD_VAR 0 11
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: LIST
25580: LIST
25581: ST_TO_ADDR
// exit ;
25582: GO 27803
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25584: LD_EXP 101
25588: PUSH
25589: LD_EXP 100
25593: PUSH
25594: LD_VAR 0 1
25598: ARRAY
25599: ARRAY
25600: PUSH
25601: LD_EXP 74
25605: PUSH
25606: LD_VAR 0 1
25610: ARRAY
25611: PPUSH
25612: LD_INT 2
25614: PUSH
25615: LD_INT 30
25617: PUSH
25618: LD_INT 6
25620: PUSH
25621: EMPTY
25622: LIST
25623: LIST
25624: PUSH
25625: LD_INT 30
25627: PUSH
25628: LD_INT 7
25630: PUSH
25631: EMPTY
25632: LIST
25633: LIST
25634: PUSH
25635: LD_INT 30
25637: PUSH
25638: LD_INT 8
25640: PUSH
25641: EMPTY
25642: LIST
25643: LIST
25644: PUSH
25645: EMPTY
25646: LIST
25647: LIST
25648: LIST
25649: LIST
25650: PPUSH
25651: CALL_OW 72
25655: AND
25656: PUSH
25657: LD_EXP 74
25661: PUSH
25662: LD_VAR 0 1
25666: ARRAY
25667: PPUSH
25668: LD_INT 30
25670: PUSH
25671: LD_INT 3
25673: PUSH
25674: EMPTY
25675: LIST
25676: LIST
25677: PPUSH
25678: CALL_OW 72
25682: AND
25683: IFFALSE 26417
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
25685: LD_ADDR_EXP 116
25689: PUSH
25690: LD_EXP 116
25694: PPUSH
25695: LD_VAR 0 1
25699: PPUSH
25700: LD_INT 3
25702: PPUSH
25703: CALL_OW 1
25707: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25708: LD_ADDR_VAR 0 2
25712: PUSH
25713: LD_INT 0
25715: PUSH
25716: LD_INT 0
25718: PUSH
25719: LD_INT 0
25721: PUSH
25722: LD_INT 0
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: LIST
25729: LIST
25730: ST_TO_ADDR
// if not eng then
25731: LD_VAR 0 6
25735: NOT
25736: IFFALSE 25799
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
25738: LD_ADDR_VAR 0 11
25742: PUSH
25743: LD_VAR 0 4
25747: PPUSH
25748: LD_INT 2
25750: PPUSH
25751: CALL 90477 0 2
25755: PUSH
25756: LD_INT 1
25758: ARRAY
25759: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
25760: LD_ADDR_VAR 0 2
25764: PUSH
25765: LD_VAR 0 2
25769: PPUSH
25770: LD_INT 2
25772: PPUSH
25773: LD_VAR 0 11
25777: PPUSH
25778: CALL_OW 1
25782: ST_TO_ADDR
// tmp := tmp diff p ;
25783: LD_ADDR_VAR 0 4
25787: PUSH
25788: LD_VAR 0 4
25792: PUSH
25793: LD_VAR 0 11
25797: DIFF
25798: ST_TO_ADDR
// end ; if tmp and sci < 6 then
25799: LD_VAR 0 4
25803: PUSH
25804: LD_VAR 0 8
25808: PUSH
25809: LD_INT 6
25811: LESS
25812: AND
25813: IFFALSE 26001
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
25815: LD_ADDR_VAR 0 9
25819: PUSH
25820: LD_VAR 0 4
25824: PUSH
25825: LD_VAR 0 8
25829: PUSH
25830: LD_VAR 0 7
25834: UNION
25835: DIFF
25836: PPUSH
25837: LD_INT 4
25839: PPUSH
25840: CALL 90477 0 2
25844: ST_TO_ADDR
// p := [ ] ;
25845: LD_ADDR_VAR 0 11
25849: PUSH
25850: EMPTY
25851: ST_TO_ADDR
// if sort then
25852: LD_VAR 0 9
25856: IFFALSE 25972
// for i = 1 to 6 - sci do
25858: LD_ADDR_VAR 0 3
25862: PUSH
25863: DOUBLE
25864: LD_INT 1
25866: DEC
25867: ST_TO_ADDR
25868: LD_INT 6
25870: PUSH
25871: LD_VAR 0 8
25875: MINUS
25876: PUSH
25877: FOR_TO
25878: IFFALSE 25970
// begin if i = sort then
25880: LD_VAR 0 3
25884: PUSH
25885: LD_VAR 0 9
25889: EQUAL
25890: IFFALSE 25894
// break ;
25892: GO 25970
// if GetClass ( i ) = 4 then
25894: LD_VAR 0 3
25898: PPUSH
25899: CALL_OW 257
25903: PUSH
25904: LD_INT 4
25906: EQUAL
25907: IFFALSE 25911
// continue ;
25909: GO 25877
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25911: LD_ADDR_VAR 0 11
25915: PUSH
25916: LD_VAR 0 11
25920: PPUSH
25921: LD_VAR 0 11
25925: PUSH
25926: LD_INT 1
25928: PLUS
25929: PPUSH
25930: LD_VAR 0 9
25934: PUSH
25935: LD_VAR 0 3
25939: ARRAY
25940: PPUSH
25941: CALL_OW 2
25945: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25946: LD_ADDR_VAR 0 4
25950: PUSH
25951: LD_VAR 0 4
25955: PUSH
25956: LD_VAR 0 9
25960: PUSH
25961: LD_VAR 0 3
25965: ARRAY
25966: DIFF
25967: ST_TO_ADDR
// end ;
25968: GO 25877
25970: POP
25971: POP
// if p then
25972: LD_VAR 0 11
25976: IFFALSE 26001
// result := Replace ( result , 4 , p ) ;
25978: LD_ADDR_VAR 0 2
25982: PUSH
25983: LD_VAR 0 2
25987: PPUSH
25988: LD_INT 4
25990: PPUSH
25991: LD_VAR 0 11
25995: PPUSH
25996: CALL_OW 1
26000: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26001: LD_VAR 0 4
26005: PUSH
26006: LD_VAR 0 7
26010: PUSH
26011: LD_INT 6
26013: LESS
26014: AND
26015: IFFALSE 26203
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26017: LD_ADDR_VAR 0 9
26021: PUSH
26022: LD_VAR 0 4
26026: PUSH
26027: LD_VAR 0 8
26031: PUSH
26032: LD_VAR 0 7
26036: UNION
26037: DIFF
26038: PPUSH
26039: LD_INT 3
26041: PPUSH
26042: CALL 90477 0 2
26046: ST_TO_ADDR
// p := [ ] ;
26047: LD_ADDR_VAR 0 11
26051: PUSH
26052: EMPTY
26053: ST_TO_ADDR
// if sort then
26054: LD_VAR 0 9
26058: IFFALSE 26174
// for i = 1 to 6 - mech do
26060: LD_ADDR_VAR 0 3
26064: PUSH
26065: DOUBLE
26066: LD_INT 1
26068: DEC
26069: ST_TO_ADDR
26070: LD_INT 6
26072: PUSH
26073: LD_VAR 0 7
26077: MINUS
26078: PUSH
26079: FOR_TO
26080: IFFALSE 26172
// begin if i = sort then
26082: LD_VAR 0 3
26086: PUSH
26087: LD_VAR 0 9
26091: EQUAL
26092: IFFALSE 26096
// break ;
26094: GO 26172
// if GetClass ( i ) = 3 then
26096: LD_VAR 0 3
26100: PPUSH
26101: CALL_OW 257
26105: PUSH
26106: LD_INT 3
26108: EQUAL
26109: IFFALSE 26113
// continue ;
26111: GO 26079
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26113: LD_ADDR_VAR 0 11
26117: PUSH
26118: LD_VAR 0 11
26122: PPUSH
26123: LD_VAR 0 11
26127: PUSH
26128: LD_INT 1
26130: PLUS
26131: PPUSH
26132: LD_VAR 0 9
26136: PUSH
26137: LD_VAR 0 3
26141: ARRAY
26142: PPUSH
26143: CALL_OW 2
26147: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26148: LD_ADDR_VAR 0 4
26152: PUSH
26153: LD_VAR 0 4
26157: PUSH
26158: LD_VAR 0 9
26162: PUSH
26163: LD_VAR 0 3
26167: ARRAY
26168: DIFF
26169: ST_TO_ADDR
// end ;
26170: GO 26079
26172: POP
26173: POP
// if p then
26174: LD_VAR 0 11
26178: IFFALSE 26203
// result := Replace ( result , 3 , p ) ;
26180: LD_ADDR_VAR 0 2
26184: PUSH
26185: LD_VAR 0 2
26189: PPUSH
26190: LD_INT 3
26192: PPUSH
26193: LD_VAR 0 11
26197: PPUSH
26198: CALL_OW 1
26202: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
26203: LD_VAR 0 4
26207: PUSH
26208: LD_INT 6
26210: GREATER
26211: PUSH
26212: LD_VAR 0 6
26216: PUSH
26217: LD_INT 6
26219: LESS
26220: AND
26221: IFFALSE 26415
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26223: LD_ADDR_VAR 0 9
26227: PUSH
26228: LD_VAR 0 4
26232: PUSH
26233: LD_VAR 0 8
26237: PUSH
26238: LD_VAR 0 7
26242: UNION
26243: PUSH
26244: LD_VAR 0 6
26248: UNION
26249: DIFF
26250: PPUSH
26251: LD_INT 2
26253: PPUSH
26254: CALL 90477 0 2
26258: ST_TO_ADDR
// p := [ ] ;
26259: LD_ADDR_VAR 0 11
26263: PUSH
26264: EMPTY
26265: ST_TO_ADDR
// if sort then
26266: LD_VAR 0 9
26270: IFFALSE 26386
// for i = 1 to 6 - eng do
26272: LD_ADDR_VAR 0 3
26276: PUSH
26277: DOUBLE
26278: LD_INT 1
26280: DEC
26281: ST_TO_ADDR
26282: LD_INT 6
26284: PUSH
26285: LD_VAR 0 6
26289: MINUS
26290: PUSH
26291: FOR_TO
26292: IFFALSE 26384
// begin if i = sort then
26294: LD_VAR 0 3
26298: PUSH
26299: LD_VAR 0 9
26303: EQUAL
26304: IFFALSE 26308
// break ;
26306: GO 26384
// if GetClass ( i ) = 2 then
26308: LD_VAR 0 3
26312: PPUSH
26313: CALL_OW 257
26317: PUSH
26318: LD_INT 2
26320: EQUAL
26321: IFFALSE 26325
// continue ;
26323: GO 26291
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26325: LD_ADDR_VAR 0 11
26329: PUSH
26330: LD_VAR 0 11
26334: PPUSH
26335: LD_VAR 0 11
26339: PUSH
26340: LD_INT 1
26342: PLUS
26343: PPUSH
26344: LD_VAR 0 9
26348: PUSH
26349: LD_VAR 0 3
26353: ARRAY
26354: PPUSH
26355: CALL_OW 2
26359: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26360: LD_ADDR_VAR 0 4
26364: PUSH
26365: LD_VAR 0 4
26369: PUSH
26370: LD_VAR 0 9
26374: PUSH
26375: LD_VAR 0 3
26379: ARRAY
26380: DIFF
26381: ST_TO_ADDR
// end ;
26382: GO 26291
26384: POP
26385: POP
// if p then
26386: LD_VAR 0 11
26390: IFFALSE 26415
// result := Replace ( result , 2 , p ) ;
26392: LD_ADDR_VAR 0 2
26396: PUSH
26397: LD_VAR 0 2
26401: PPUSH
26402: LD_INT 2
26404: PPUSH
26405: LD_VAR 0 11
26409: PPUSH
26410: CALL_OW 1
26414: ST_TO_ADDR
// end ; exit ;
26415: GO 27803
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
26417: LD_EXP 101
26421: PUSH
26422: LD_EXP 100
26426: PUSH
26427: LD_VAR 0 1
26431: ARRAY
26432: ARRAY
26433: NOT
26434: PUSH
26435: LD_EXP 74
26439: PUSH
26440: LD_VAR 0 1
26444: ARRAY
26445: PPUSH
26446: LD_INT 30
26448: PUSH
26449: LD_INT 3
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: PPUSH
26456: CALL_OW 72
26460: AND
26461: PUSH
26462: LD_EXP 79
26466: PUSH
26467: LD_VAR 0 1
26471: ARRAY
26472: AND
26473: IFFALSE 27081
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
26475: LD_ADDR_EXP 116
26479: PUSH
26480: LD_EXP 116
26484: PPUSH
26485: LD_VAR 0 1
26489: PPUSH
26490: LD_INT 5
26492: PPUSH
26493: CALL_OW 1
26497: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26498: LD_ADDR_VAR 0 2
26502: PUSH
26503: LD_INT 0
26505: PUSH
26506: LD_INT 0
26508: PUSH
26509: LD_INT 0
26511: PUSH
26512: LD_INT 0
26514: PUSH
26515: EMPTY
26516: LIST
26517: LIST
26518: LIST
26519: LIST
26520: ST_TO_ADDR
// if sci > 1 then
26521: LD_VAR 0 8
26525: PUSH
26526: LD_INT 1
26528: GREATER
26529: IFFALSE 26557
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
26531: LD_ADDR_VAR 0 4
26535: PUSH
26536: LD_VAR 0 4
26540: PUSH
26541: LD_VAR 0 8
26545: PUSH
26546: LD_VAR 0 8
26550: PUSH
26551: LD_INT 1
26553: ARRAY
26554: DIFF
26555: DIFF
26556: ST_TO_ADDR
// if tmp and not sci then
26557: LD_VAR 0 4
26561: PUSH
26562: LD_VAR 0 8
26566: NOT
26567: AND
26568: IFFALSE 26637
// begin sort := SortBySkill ( tmp , 4 ) ;
26570: LD_ADDR_VAR 0 9
26574: PUSH
26575: LD_VAR 0 4
26579: PPUSH
26580: LD_INT 4
26582: PPUSH
26583: CALL 90477 0 2
26587: ST_TO_ADDR
// if sort then
26588: LD_VAR 0 9
26592: IFFALSE 26608
// p := sort [ 1 ] ;
26594: LD_ADDR_VAR 0 11
26598: PUSH
26599: LD_VAR 0 9
26603: PUSH
26604: LD_INT 1
26606: ARRAY
26607: ST_TO_ADDR
// if p then
26608: LD_VAR 0 11
26612: IFFALSE 26637
// result := Replace ( result , 4 , p ) ;
26614: LD_ADDR_VAR 0 2
26618: PUSH
26619: LD_VAR 0 2
26623: PPUSH
26624: LD_INT 4
26626: PPUSH
26627: LD_VAR 0 11
26631: PPUSH
26632: CALL_OW 1
26636: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26637: LD_ADDR_VAR 0 4
26641: PUSH
26642: LD_VAR 0 4
26646: PUSH
26647: LD_VAR 0 7
26651: DIFF
26652: ST_TO_ADDR
// if tmp and mech < 6 then
26653: LD_VAR 0 4
26657: PUSH
26658: LD_VAR 0 7
26662: PUSH
26663: LD_INT 6
26665: LESS
26666: AND
26667: IFFALSE 26855
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26669: LD_ADDR_VAR 0 9
26673: PUSH
26674: LD_VAR 0 4
26678: PUSH
26679: LD_VAR 0 8
26683: PUSH
26684: LD_VAR 0 7
26688: UNION
26689: DIFF
26690: PPUSH
26691: LD_INT 3
26693: PPUSH
26694: CALL 90477 0 2
26698: ST_TO_ADDR
// p := [ ] ;
26699: LD_ADDR_VAR 0 11
26703: PUSH
26704: EMPTY
26705: ST_TO_ADDR
// if sort then
26706: LD_VAR 0 9
26710: IFFALSE 26826
// for i = 1 to 6 - mech do
26712: LD_ADDR_VAR 0 3
26716: PUSH
26717: DOUBLE
26718: LD_INT 1
26720: DEC
26721: ST_TO_ADDR
26722: LD_INT 6
26724: PUSH
26725: LD_VAR 0 7
26729: MINUS
26730: PUSH
26731: FOR_TO
26732: IFFALSE 26824
// begin if i = sort then
26734: LD_VAR 0 3
26738: PUSH
26739: LD_VAR 0 9
26743: EQUAL
26744: IFFALSE 26748
// break ;
26746: GO 26824
// if GetClass ( i ) = 3 then
26748: LD_VAR 0 3
26752: PPUSH
26753: CALL_OW 257
26757: PUSH
26758: LD_INT 3
26760: EQUAL
26761: IFFALSE 26765
// continue ;
26763: GO 26731
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26765: LD_ADDR_VAR 0 11
26769: PUSH
26770: LD_VAR 0 11
26774: PPUSH
26775: LD_VAR 0 11
26779: PUSH
26780: LD_INT 1
26782: PLUS
26783: PPUSH
26784: LD_VAR 0 9
26788: PUSH
26789: LD_VAR 0 3
26793: ARRAY
26794: PPUSH
26795: CALL_OW 2
26799: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26800: LD_ADDR_VAR 0 4
26804: PUSH
26805: LD_VAR 0 4
26809: PUSH
26810: LD_VAR 0 9
26814: PUSH
26815: LD_VAR 0 3
26819: ARRAY
26820: DIFF
26821: ST_TO_ADDR
// end ;
26822: GO 26731
26824: POP
26825: POP
// if p then
26826: LD_VAR 0 11
26830: IFFALSE 26855
// result := Replace ( result , 3 , p ) ;
26832: LD_ADDR_VAR 0 2
26836: PUSH
26837: LD_VAR 0 2
26841: PPUSH
26842: LD_INT 3
26844: PPUSH
26845: LD_VAR 0 11
26849: PPUSH
26850: CALL_OW 1
26854: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26855: LD_ADDR_VAR 0 4
26859: PUSH
26860: LD_VAR 0 4
26864: PUSH
26865: LD_VAR 0 6
26869: DIFF
26870: ST_TO_ADDR
// if tmp and eng < 6 then
26871: LD_VAR 0 4
26875: PUSH
26876: LD_VAR 0 6
26880: PUSH
26881: LD_INT 6
26883: LESS
26884: AND
26885: IFFALSE 27079
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26887: LD_ADDR_VAR 0 9
26891: PUSH
26892: LD_VAR 0 4
26896: PUSH
26897: LD_VAR 0 8
26901: PUSH
26902: LD_VAR 0 7
26906: UNION
26907: PUSH
26908: LD_VAR 0 6
26912: UNION
26913: DIFF
26914: PPUSH
26915: LD_INT 2
26917: PPUSH
26918: CALL 90477 0 2
26922: ST_TO_ADDR
// p := [ ] ;
26923: LD_ADDR_VAR 0 11
26927: PUSH
26928: EMPTY
26929: ST_TO_ADDR
// if sort then
26930: LD_VAR 0 9
26934: IFFALSE 27050
// for i = 1 to 6 - eng do
26936: LD_ADDR_VAR 0 3
26940: PUSH
26941: DOUBLE
26942: LD_INT 1
26944: DEC
26945: ST_TO_ADDR
26946: LD_INT 6
26948: PUSH
26949: LD_VAR 0 6
26953: MINUS
26954: PUSH
26955: FOR_TO
26956: IFFALSE 27048
// begin if i = sort then
26958: LD_VAR 0 3
26962: PUSH
26963: LD_VAR 0 9
26967: EQUAL
26968: IFFALSE 26972
// break ;
26970: GO 27048
// if GetClass ( i ) = 2 then
26972: LD_VAR 0 3
26976: PPUSH
26977: CALL_OW 257
26981: PUSH
26982: LD_INT 2
26984: EQUAL
26985: IFFALSE 26989
// continue ;
26987: GO 26955
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26989: LD_ADDR_VAR 0 11
26993: PUSH
26994: LD_VAR 0 11
26998: PPUSH
26999: LD_VAR 0 11
27003: PUSH
27004: LD_INT 1
27006: PLUS
27007: PPUSH
27008: LD_VAR 0 9
27012: PUSH
27013: LD_VAR 0 3
27017: ARRAY
27018: PPUSH
27019: CALL_OW 2
27023: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27024: LD_ADDR_VAR 0 4
27028: PUSH
27029: LD_VAR 0 4
27033: PUSH
27034: LD_VAR 0 9
27038: PUSH
27039: LD_VAR 0 3
27043: ARRAY
27044: DIFF
27045: ST_TO_ADDR
// end ;
27046: GO 26955
27048: POP
27049: POP
// if p then
27050: LD_VAR 0 11
27054: IFFALSE 27079
// result := Replace ( result , 2 , p ) ;
27056: LD_ADDR_VAR 0 2
27060: PUSH
27061: LD_VAR 0 2
27065: PPUSH
27066: LD_INT 2
27068: PPUSH
27069: LD_VAR 0 11
27073: PPUSH
27074: CALL_OW 1
27078: ST_TO_ADDR
// end ; exit ;
27079: GO 27803
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27081: LD_EXP 101
27085: PUSH
27086: LD_EXP 100
27090: PUSH
27091: LD_VAR 0 1
27095: ARRAY
27096: ARRAY
27097: NOT
27098: PUSH
27099: LD_EXP 74
27103: PUSH
27104: LD_VAR 0 1
27108: ARRAY
27109: PPUSH
27110: LD_INT 30
27112: PUSH
27113: LD_INT 3
27115: PUSH
27116: EMPTY
27117: LIST
27118: LIST
27119: PPUSH
27120: CALL_OW 72
27124: AND
27125: PUSH
27126: LD_EXP 79
27130: PUSH
27131: LD_VAR 0 1
27135: ARRAY
27136: NOT
27137: AND
27138: IFFALSE 27803
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27140: LD_ADDR_EXP 116
27144: PUSH
27145: LD_EXP 116
27149: PPUSH
27150: LD_VAR 0 1
27154: PPUSH
27155: LD_INT 6
27157: PPUSH
27158: CALL_OW 1
27162: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27163: LD_ADDR_VAR 0 2
27167: PUSH
27168: LD_INT 0
27170: PUSH
27171: LD_INT 0
27173: PUSH
27174: LD_INT 0
27176: PUSH
27177: LD_INT 0
27179: PUSH
27180: EMPTY
27181: LIST
27182: LIST
27183: LIST
27184: LIST
27185: ST_TO_ADDR
// if sci >= 1 then
27186: LD_VAR 0 8
27190: PUSH
27191: LD_INT 1
27193: GREATEREQUAL
27194: IFFALSE 27216
// tmp := tmp diff sci [ 1 ] ;
27196: LD_ADDR_VAR 0 4
27200: PUSH
27201: LD_VAR 0 4
27205: PUSH
27206: LD_VAR 0 8
27210: PUSH
27211: LD_INT 1
27213: ARRAY
27214: DIFF
27215: ST_TO_ADDR
// if tmp and not sci then
27216: LD_VAR 0 4
27220: PUSH
27221: LD_VAR 0 8
27225: NOT
27226: AND
27227: IFFALSE 27296
// begin sort := SortBySkill ( tmp , 4 ) ;
27229: LD_ADDR_VAR 0 9
27233: PUSH
27234: LD_VAR 0 4
27238: PPUSH
27239: LD_INT 4
27241: PPUSH
27242: CALL 90477 0 2
27246: ST_TO_ADDR
// if sort then
27247: LD_VAR 0 9
27251: IFFALSE 27267
// p := sort [ 1 ] ;
27253: LD_ADDR_VAR 0 11
27257: PUSH
27258: LD_VAR 0 9
27262: PUSH
27263: LD_INT 1
27265: ARRAY
27266: ST_TO_ADDR
// if p then
27267: LD_VAR 0 11
27271: IFFALSE 27296
// result := Replace ( result , 4 , p ) ;
27273: LD_ADDR_VAR 0 2
27277: PUSH
27278: LD_VAR 0 2
27282: PPUSH
27283: LD_INT 4
27285: PPUSH
27286: LD_VAR 0 11
27290: PPUSH
27291: CALL_OW 1
27295: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27296: LD_ADDR_VAR 0 4
27300: PUSH
27301: LD_VAR 0 4
27305: PUSH
27306: LD_VAR 0 7
27310: DIFF
27311: ST_TO_ADDR
// if tmp and mech < 6 then
27312: LD_VAR 0 4
27316: PUSH
27317: LD_VAR 0 7
27321: PUSH
27322: LD_INT 6
27324: LESS
27325: AND
27326: IFFALSE 27508
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
27328: LD_ADDR_VAR 0 9
27332: PUSH
27333: LD_VAR 0 4
27337: PUSH
27338: LD_VAR 0 7
27342: DIFF
27343: PPUSH
27344: LD_INT 3
27346: PPUSH
27347: CALL 90477 0 2
27351: ST_TO_ADDR
// p := [ ] ;
27352: LD_ADDR_VAR 0 11
27356: PUSH
27357: EMPTY
27358: ST_TO_ADDR
// if sort then
27359: LD_VAR 0 9
27363: IFFALSE 27479
// for i = 1 to 6 - mech do
27365: LD_ADDR_VAR 0 3
27369: PUSH
27370: DOUBLE
27371: LD_INT 1
27373: DEC
27374: ST_TO_ADDR
27375: LD_INT 6
27377: PUSH
27378: LD_VAR 0 7
27382: MINUS
27383: PUSH
27384: FOR_TO
27385: IFFALSE 27477
// begin if i = sort then
27387: LD_VAR 0 3
27391: PUSH
27392: LD_VAR 0 9
27396: EQUAL
27397: IFFALSE 27401
// break ;
27399: GO 27477
// if GetClass ( i ) = 3 then
27401: LD_VAR 0 3
27405: PPUSH
27406: CALL_OW 257
27410: PUSH
27411: LD_INT 3
27413: EQUAL
27414: IFFALSE 27418
// continue ;
27416: GO 27384
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27418: LD_ADDR_VAR 0 11
27422: PUSH
27423: LD_VAR 0 11
27427: PPUSH
27428: LD_VAR 0 11
27432: PUSH
27433: LD_INT 1
27435: PLUS
27436: PPUSH
27437: LD_VAR 0 9
27441: PUSH
27442: LD_VAR 0 3
27446: ARRAY
27447: PPUSH
27448: CALL_OW 2
27452: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27453: LD_ADDR_VAR 0 4
27457: PUSH
27458: LD_VAR 0 4
27462: PUSH
27463: LD_VAR 0 9
27467: PUSH
27468: LD_VAR 0 3
27472: ARRAY
27473: DIFF
27474: ST_TO_ADDR
// end ;
27475: GO 27384
27477: POP
27478: POP
// if p then
27479: LD_VAR 0 11
27483: IFFALSE 27508
// result := Replace ( result , 3 , p ) ;
27485: LD_ADDR_VAR 0 2
27489: PUSH
27490: LD_VAR 0 2
27494: PPUSH
27495: LD_INT 3
27497: PPUSH
27498: LD_VAR 0 11
27502: PPUSH
27503: CALL_OW 1
27507: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27508: LD_ADDR_VAR 0 4
27512: PUSH
27513: LD_VAR 0 4
27517: PUSH
27518: LD_VAR 0 6
27522: DIFF
27523: ST_TO_ADDR
// if tmp and eng < 4 then
27524: LD_VAR 0 4
27528: PUSH
27529: LD_VAR 0 6
27533: PUSH
27534: LD_INT 4
27536: LESS
27537: AND
27538: IFFALSE 27728
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
27540: LD_ADDR_VAR 0 9
27544: PUSH
27545: LD_VAR 0 4
27549: PUSH
27550: LD_VAR 0 7
27554: PUSH
27555: LD_VAR 0 6
27559: UNION
27560: DIFF
27561: PPUSH
27562: LD_INT 2
27564: PPUSH
27565: CALL 90477 0 2
27569: ST_TO_ADDR
// p := [ ] ;
27570: LD_ADDR_VAR 0 11
27574: PUSH
27575: EMPTY
27576: ST_TO_ADDR
// if sort then
27577: LD_VAR 0 9
27581: IFFALSE 27697
// for i = 1 to 4 - eng do
27583: LD_ADDR_VAR 0 3
27587: PUSH
27588: DOUBLE
27589: LD_INT 1
27591: DEC
27592: ST_TO_ADDR
27593: LD_INT 4
27595: PUSH
27596: LD_VAR 0 6
27600: MINUS
27601: PUSH
27602: FOR_TO
27603: IFFALSE 27695
// begin if i = sort then
27605: LD_VAR 0 3
27609: PUSH
27610: LD_VAR 0 9
27614: EQUAL
27615: IFFALSE 27619
// break ;
27617: GO 27695
// if GetClass ( i ) = 2 then
27619: LD_VAR 0 3
27623: PPUSH
27624: CALL_OW 257
27628: PUSH
27629: LD_INT 2
27631: EQUAL
27632: IFFALSE 27636
// continue ;
27634: GO 27602
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27636: LD_ADDR_VAR 0 11
27640: PUSH
27641: LD_VAR 0 11
27645: PPUSH
27646: LD_VAR 0 11
27650: PUSH
27651: LD_INT 1
27653: PLUS
27654: PPUSH
27655: LD_VAR 0 9
27659: PUSH
27660: LD_VAR 0 3
27664: ARRAY
27665: PPUSH
27666: CALL_OW 2
27670: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27671: LD_ADDR_VAR 0 4
27675: PUSH
27676: LD_VAR 0 4
27680: PUSH
27681: LD_VAR 0 9
27685: PUSH
27686: LD_VAR 0 3
27690: ARRAY
27691: DIFF
27692: ST_TO_ADDR
// end ;
27693: GO 27602
27695: POP
27696: POP
// if p then
27697: LD_VAR 0 11
27701: IFFALSE 27726
// result := Replace ( result , 2 , p ) ;
27703: LD_ADDR_VAR 0 2
27707: PUSH
27708: LD_VAR 0 2
27712: PPUSH
27713: LD_INT 2
27715: PPUSH
27716: LD_VAR 0 11
27720: PPUSH
27721: CALL_OW 1
27725: ST_TO_ADDR
// end else
27726: GO 27772
// for i = eng downto 5 do
27728: LD_ADDR_VAR 0 3
27732: PUSH
27733: DOUBLE
27734: LD_VAR 0 6
27738: INC
27739: ST_TO_ADDR
27740: LD_INT 5
27742: PUSH
27743: FOR_DOWNTO
27744: IFFALSE 27770
// tmp := tmp union eng [ i ] ;
27746: LD_ADDR_VAR 0 4
27750: PUSH
27751: LD_VAR 0 4
27755: PUSH
27756: LD_VAR 0 6
27760: PUSH
27761: LD_VAR 0 3
27765: ARRAY
27766: UNION
27767: ST_TO_ADDR
27768: GO 27743
27770: POP
27771: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
27772: LD_ADDR_VAR 0 2
27776: PUSH
27777: LD_VAR 0 2
27781: PPUSH
27782: LD_INT 1
27784: PPUSH
27785: LD_VAR 0 4
27789: PUSH
27790: LD_VAR 0 5
27794: DIFF
27795: PPUSH
27796: CALL_OW 1
27800: ST_TO_ADDR
// exit ;
27801: GO 27803
// end ; end ;
27803: LD_VAR 0 2
27807: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
27808: LD_INT 0
27810: PPUSH
27811: PPUSH
27812: PPUSH
// if not mc_bases then
27813: LD_EXP 74
27817: NOT
27818: IFFALSE 27822
// exit ;
27820: GO 27928
// for i = 1 to mc_bases do
27822: LD_ADDR_VAR 0 2
27826: PUSH
27827: DOUBLE
27828: LD_INT 1
27830: DEC
27831: ST_TO_ADDR
27832: LD_EXP 74
27836: PUSH
27837: FOR_TO
27838: IFFALSE 27919
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
27840: LD_ADDR_VAR 0 3
27844: PUSH
27845: LD_EXP 74
27849: PUSH
27850: LD_VAR 0 2
27854: ARRAY
27855: PPUSH
27856: LD_INT 21
27858: PUSH
27859: LD_INT 3
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: LD_INT 3
27868: PUSH
27869: LD_INT 24
27871: PUSH
27872: LD_INT 1000
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: EMPTY
27880: LIST
27881: LIST
27882: PUSH
27883: EMPTY
27884: LIST
27885: LIST
27886: PPUSH
27887: CALL_OW 72
27891: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
27892: LD_ADDR_EXP 75
27896: PUSH
27897: LD_EXP 75
27901: PPUSH
27902: LD_VAR 0 2
27906: PPUSH
27907: LD_VAR 0 3
27911: PPUSH
27912: CALL_OW 1
27916: ST_TO_ADDR
// end ;
27917: GO 27837
27919: POP
27920: POP
// RaiseSailEvent ( 101 ) ;
27921: LD_INT 101
27923: PPUSH
27924: CALL_OW 427
// end ;
27928: LD_VAR 0 1
27932: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
27933: LD_INT 0
27935: PPUSH
27936: PPUSH
27937: PPUSH
27938: PPUSH
27939: PPUSH
27940: PPUSH
27941: PPUSH
// if not mc_bases then
27942: LD_EXP 74
27946: NOT
27947: IFFALSE 27951
// exit ;
27949: GO 28524
// for i = 1 to mc_bases do
27951: LD_ADDR_VAR 0 2
27955: PUSH
27956: DOUBLE
27957: LD_INT 1
27959: DEC
27960: ST_TO_ADDR
27961: LD_EXP 74
27965: PUSH
27966: FOR_TO
27967: IFFALSE 28515
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
27969: LD_ADDR_VAR 0 5
27973: PUSH
27974: LD_EXP 74
27978: PUSH
27979: LD_VAR 0 2
27983: ARRAY
27984: PUSH
27985: LD_EXP 103
27989: PUSH
27990: LD_VAR 0 2
27994: ARRAY
27995: UNION
27996: PPUSH
27997: LD_INT 21
27999: PUSH
28000: LD_INT 1
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 1
28009: PUSH
28010: LD_INT 3
28012: PUSH
28013: LD_INT 54
28015: PUSH
28016: EMPTY
28017: LIST
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PUSH
28023: LD_INT 3
28025: PUSH
28026: LD_INT 24
28028: PUSH
28029: LD_INT 800
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: LIST
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: PPUSH
28049: CALL_OW 72
28053: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28054: LD_ADDR_VAR 0 6
28058: PUSH
28059: LD_EXP 74
28063: PUSH
28064: LD_VAR 0 2
28068: ARRAY
28069: PPUSH
28070: LD_INT 21
28072: PUSH
28073: LD_INT 1
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 1
28082: PUSH
28083: LD_INT 3
28085: PUSH
28086: LD_INT 54
28088: PUSH
28089: EMPTY
28090: LIST
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: LD_INT 3
28098: PUSH
28099: LD_INT 24
28101: PUSH
28102: LD_INT 250
28104: PUSH
28105: EMPTY
28106: LIST
28107: LIST
28108: PUSH
28109: EMPTY
28110: LIST
28111: LIST
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: LIST
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PPUSH
28122: CALL_OW 72
28126: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28127: LD_ADDR_VAR 0 7
28131: PUSH
28132: LD_VAR 0 5
28136: PUSH
28137: LD_VAR 0 6
28141: DIFF
28142: ST_TO_ADDR
// if not need_heal_1 then
28143: LD_VAR 0 6
28147: NOT
28148: IFFALSE 28181
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28150: LD_ADDR_EXP 77
28154: PUSH
28155: LD_EXP 77
28159: PPUSH
28160: LD_VAR 0 2
28164: PUSH
28165: LD_INT 1
28167: PUSH
28168: EMPTY
28169: LIST
28170: LIST
28171: PPUSH
28172: EMPTY
28173: PPUSH
28174: CALL 56229 0 3
28178: ST_TO_ADDR
28179: GO 28251
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28181: LD_ADDR_EXP 77
28185: PUSH
28186: LD_EXP 77
28190: PPUSH
28191: LD_VAR 0 2
28195: PUSH
28196: LD_INT 1
28198: PUSH
28199: EMPTY
28200: LIST
28201: LIST
28202: PPUSH
28203: LD_EXP 77
28207: PUSH
28208: LD_VAR 0 2
28212: ARRAY
28213: PUSH
28214: LD_INT 1
28216: ARRAY
28217: PPUSH
28218: LD_INT 3
28220: PUSH
28221: LD_INT 24
28223: PUSH
28224: LD_INT 1000
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: EMPTY
28232: LIST
28233: LIST
28234: PPUSH
28235: CALL_OW 72
28239: PUSH
28240: LD_VAR 0 6
28244: UNION
28245: PPUSH
28246: CALL 56229 0 3
28250: ST_TO_ADDR
// if not need_heal_2 then
28251: LD_VAR 0 7
28255: NOT
28256: IFFALSE 28289
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
28258: LD_ADDR_EXP 77
28262: PUSH
28263: LD_EXP 77
28267: PPUSH
28268: LD_VAR 0 2
28272: PUSH
28273: LD_INT 2
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: PPUSH
28280: EMPTY
28281: PPUSH
28282: CALL 56229 0 3
28286: ST_TO_ADDR
28287: GO 28321
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
28289: LD_ADDR_EXP 77
28293: PUSH
28294: LD_EXP 77
28298: PPUSH
28299: LD_VAR 0 2
28303: PUSH
28304: LD_INT 2
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PPUSH
28311: LD_VAR 0 7
28315: PPUSH
28316: CALL 56229 0 3
28320: ST_TO_ADDR
// if need_heal_2 then
28321: LD_VAR 0 7
28325: IFFALSE 28497
// for j in need_heal_2 do
28327: LD_ADDR_VAR 0 3
28331: PUSH
28332: LD_VAR 0 7
28336: PUSH
28337: FOR_IN
28338: IFFALSE 28495
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
28340: LD_ADDR_VAR 0 5
28344: PUSH
28345: LD_EXP 74
28349: PUSH
28350: LD_VAR 0 2
28354: ARRAY
28355: PPUSH
28356: LD_INT 2
28358: PUSH
28359: LD_INT 30
28361: PUSH
28362: LD_INT 6
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PUSH
28369: LD_INT 30
28371: PUSH
28372: LD_INT 7
28374: PUSH
28375: EMPTY
28376: LIST
28377: LIST
28378: PUSH
28379: LD_INT 30
28381: PUSH
28382: LD_INT 8
28384: PUSH
28385: EMPTY
28386: LIST
28387: LIST
28388: PUSH
28389: LD_INT 30
28391: PUSH
28392: LD_INT 0
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: PUSH
28399: LD_INT 30
28401: PUSH
28402: LD_INT 1
28404: PUSH
28405: EMPTY
28406: LIST
28407: LIST
28408: PUSH
28409: LD_INT 25
28411: PUSH
28412: LD_INT 4
28414: PUSH
28415: EMPTY
28416: LIST
28417: LIST
28418: PUSH
28419: EMPTY
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: LIST
28427: PPUSH
28428: CALL_OW 72
28432: ST_TO_ADDR
// if tmp then
28433: LD_VAR 0 5
28437: IFFALSE 28493
// begin k := NearestUnitToUnit ( tmp , j ) ;
28439: LD_ADDR_VAR 0 4
28443: PUSH
28444: LD_VAR 0 5
28448: PPUSH
28449: LD_VAR 0 3
28453: PPUSH
28454: CALL_OW 74
28458: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
28459: LD_VAR 0 3
28463: PPUSH
28464: LD_VAR 0 4
28468: PPUSH
28469: CALL_OW 296
28473: PUSH
28474: LD_INT 7
28476: GREATER
28477: IFFALSE 28493
// ComMoveUnit ( j , k ) ;
28479: LD_VAR 0 3
28483: PPUSH
28484: LD_VAR 0 4
28488: PPUSH
28489: CALL_OW 112
// end ; end ;
28493: GO 28337
28495: POP
28496: POP
// if not need_heal_1 and not need_heal_2 then
28497: LD_VAR 0 6
28501: NOT
28502: PUSH
28503: LD_VAR 0 7
28507: NOT
28508: AND
28509: IFFALSE 28513
// continue ;
28511: GO 27966
// end ;
28513: GO 27966
28515: POP
28516: POP
// RaiseSailEvent ( 102 ) ;
28517: LD_INT 102
28519: PPUSH
28520: CALL_OW 427
// end ;
28524: LD_VAR 0 1
28528: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
28529: LD_INT 0
28531: PPUSH
28532: PPUSH
28533: PPUSH
28534: PPUSH
28535: PPUSH
28536: PPUSH
// if not mc_bases then
28537: LD_EXP 74
28541: NOT
28542: IFFALSE 28546
// exit ;
28544: GO 29256
// for i = 1 to mc_bases do
28546: LD_ADDR_VAR 0 2
28550: PUSH
28551: DOUBLE
28552: LD_INT 1
28554: DEC
28555: ST_TO_ADDR
28556: LD_EXP 74
28560: PUSH
28561: FOR_TO
28562: IFFALSE 29254
// begin if not mc_building_need_repair [ i ] then
28564: LD_EXP 75
28568: PUSH
28569: LD_VAR 0 2
28573: ARRAY
28574: NOT
28575: IFFALSE 28749
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
28577: LD_ADDR_VAR 0 6
28581: PUSH
28582: LD_EXP 93
28586: PUSH
28587: LD_VAR 0 2
28591: ARRAY
28592: PPUSH
28593: LD_INT 3
28595: PUSH
28596: LD_INT 24
28598: PUSH
28599: LD_INT 1000
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: EMPTY
28607: LIST
28608: LIST
28609: PUSH
28610: LD_INT 2
28612: PUSH
28613: LD_INT 34
28615: PUSH
28616: LD_INT 13
28618: PUSH
28619: EMPTY
28620: LIST
28621: LIST
28622: PUSH
28623: LD_INT 34
28625: PUSH
28626: LD_INT 52
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: LIST
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: PPUSH
28642: CALL_OW 72
28646: ST_TO_ADDR
// if cranes then
28647: LD_VAR 0 6
28651: IFFALSE 28713
// for j in cranes do
28653: LD_ADDR_VAR 0 3
28657: PUSH
28658: LD_VAR 0 6
28662: PUSH
28663: FOR_IN
28664: IFFALSE 28711
// if not IsInArea ( j , mc_parking [ i ] ) then
28666: LD_VAR 0 3
28670: PPUSH
28671: LD_EXP 98
28675: PUSH
28676: LD_VAR 0 2
28680: ARRAY
28681: PPUSH
28682: CALL_OW 308
28686: NOT
28687: IFFALSE 28709
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28689: LD_VAR 0 3
28693: PPUSH
28694: LD_EXP 98
28698: PUSH
28699: LD_VAR 0 2
28703: ARRAY
28704: PPUSH
28705: CALL_OW 113
28709: GO 28663
28711: POP
28712: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
28713: LD_ADDR_EXP 76
28717: PUSH
28718: LD_EXP 76
28722: PPUSH
28723: LD_VAR 0 2
28727: PPUSH
28728: EMPTY
28729: PPUSH
28730: CALL_OW 1
28734: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
28735: LD_VAR 0 2
28739: PPUSH
28740: LD_INT 101
28742: PPUSH
28743: CALL 23641 0 2
// continue ;
28747: GO 28561
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
28749: LD_ADDR_EXP 80
28753: PUSH
28754: LD_EXP 80
28758: PPUSH
28759: LD_VAR 0 2
28763: PPUSH
28764: EMPTY
28765: PPUSH
28766: CALL_OW 1
28770: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28771: LD_VAR 0 2
28775: PPUSH
28776: LD_INT 103
28778: PPUSH
28779: CALL 23641 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
28783: LD_ADDR_VAR 0 5
28787: PUSH
28788: LD_EXP 74
28792: PUSH
28793: LD_VAR 0 2
28797: ARRAY
28798: PUSH
28799: LD_EXP 103
28803: PUSH
28804: LD_VAR 0 2
28808: ARRAY
28809: UNION
28810: PPUSH
28811: LD_INT 2
28813: PUSH
28814: LD_INT 25
28816: PUSH
28817: LD_INT 2
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PUSH
28824: LD_INT 25
28826: PUSH
28827: LD_INT 16
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: LIST
28838: PUSH
28839: EMPTY
28840: LIST
28841: PPUSH
28842: CALL_OW 72
28846: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
28847: LD_ADDR_VAR 0 6
28851: PUSH
28852: LD_EXP 93
28856: PUSH
28857: LD_VAR 0 2
28861: ARRAY
28862: PPUSH
28863: LD_INT 2
28865: PUSH
28866: LD_INT 34
28868: PUSH
28869: LD_INT 13
28871: PUSH
28872: EMPTY
28873: LIST
28874: LIST
28875: PUSH
28876: LD_INT 34
28878: PUSH
28879: LD_INT 52
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: EMPTY
28887: LIST
28888: LIST
28889: LIST
28890: PPUSH
28891: CALL_OW 72
28895: ST_TO_ADDR
// if cranes then
28896: LD_VAR 0 6
28900: IFFALSE 29036
// begin for j in cranes do
28902: LD_ADDR_VAR 0 3
28906: PUSH
28907: LD_VAR 0 6
28911: PUSH
28912: FOR_IN
28913: IFFALSE 29034
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
28915: LD_VAR 0 3
28919: PPUSH
28920: CALL_OW 256
28924: PUSH
28925: LD_INT 500
28927: GREATEREQUAL
28928: PUSH
28929: LD_VAR 0 3
28933: PPUSH
28934: CALL_OW 314
28938: NOT
28939: AND
28940: IFFALSE 28974
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
28942: LD_VAR 0 3
28946: PPUSH
28947: LD_EXP 75
28951: PUSH
28952: LD_VAR 0 2
28956: ARRAY
28957: PPUSH
28958: LD_VAR 0 3
28962: PPUSH
28963: CALL_OW 74
28967: PPUSH
28968: CALL_OW 130
28972: GO 29032
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28974: LD_VAR 0 3
28978: PPUSH
28979: CALL_OW 256
28983: PUSH
28984: LD_INT 500
28986: LESS
28987: PUSH
28988: LD_VAR 0 3
28992: PPUSH
28993: LD_EXP 98
28997: PUSH
28998: LD_VAR 0 2
29002: ARRAY
29003: PPUSH
29004: CALL_OW 308
29008: NOT
29009: AND
29010: IFFALSE 29032
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29012: LD_VAR 0 3
29016: PPUSH
29017: LD_EXP 98
29021: PUSH
29022: LD_VAR 0 2
29026: ARRAY
29027: PPUSH
29028: CALL_OW 113
29032: GO 28912
29034: POP
29035: POP
// end ; if not tmp then
29036: LD_VAR 0 5
29040: NOT
29041: IFFALSE 29045
// continue ;
29043: GO 28561
// for j in tmp do
29045: LD_ADDR_VAR 0 3
29049: PUSH
29050: LD_VAR 0 5
29054: PUSH
29055: FOR_IN
29056: IFFALSE 29250
// begin if mc_need_heal [ i ] then
29058: LD_EXP 77
29062: PUSH
29063: LD_VAR 0 2
29067: ARRAY
29068: IFFALSE 29116
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29070: LD_VAR 0 3
29074: PUSH
29075: LD_EXP 77
29079: PUSH
29080: LD_VAR 0 2
29084: ARRAY
29085: PUSH
29086: LD_INT 1
29088: ARRAY
29089: IN
29090: PUSH
29091: LD_VAR 0 3
29095: PUSH
29096: LD_EXP 77
29100: PUSH
29101: LD_VAR 0 2
29105: ARRAY
29106: PUSH
29107: LD_INT 2
29109: ARRAY
29110: IN
29111: OR
29112: IFFALSE 29116
// continue ;
29114: GO 29055
// if IsInUnit ( j ) then
29116: LD_VAR 0 3
29120: PPUSH
29121: CALL_OW 310
29125: IFFALSE 29136
// ComExitBuilding ( j ) ;
29127: LD_VAR 0 3
29131: PPUSH
29132: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29136: LD_VAR 0 3
29140: PUSH
29141: LD_EXP 76
29145: PUSH
29146: LD_VAR 0 2
29150: ARRAY
29151: IN
29152: NOT
29153: IFFALSE 29211
// begin SetTag ( j , 101 ) ;
29155: LD_VAR 0 3
29159: PPUSH
29160: LD_INT 101
29162: PPUSH
29163: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29167: LD_ADDR_EXP 76
29171: PUSH
29172: LD_EXP 76
29176: PPUSH
29177: LD_VAR 0 2
29181: PUSH
29182: LD_EXP 76
29186: PUSH
29187: LD_VAR 0 2
29191: ARRAY
29192: PUSH
29193: LD_INT 1
29195: PLUS
29196: PUSH
29197: EMPTY
29198: LIST
29199: LIST
29200: PPUSH
29201: LD_VAR 0 3
29205: PPUSH
29206: CALL 56229 0 3
29210: ST_TO_ADDR
// end ; wait ( 1 ) ;
29211: LD_INT 1
29213: PPUSH
29214: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
29218: LD_VAR 0 3
29222: PPUSH
29223: LD_EXP 75
29227: PUSH
29228: LD_VAR 0 2
29232: ARRAY
29233: PPUSH
29234: LD_VAR 0 3
29238: PPUSH
29239: CALL_OW 74
29243: PPUSH
29244: CALL_OW 130
// end ;
29248: GO 29055
29250: POP
29251: POP
// end ;
29252: GO 28561
29254: POP
29255: POP
// end ;
29256: LD_VAR 0 1
29260: RET
// export function MC_Heal ; var i , j , tmp ; begin
29261: LD_INT 0
29263: PPUSH
29264: PPUSH
29265: PPUSH
29266: PPUSH
// if not mc_bases then
29267: LD_EXP 74
29271: NOT
29272: IFFALSE 29276
// exit ;
29274: GO 29678
// for i = 1 to mc_bases do
29276: LD_ADDR_VAR 0 2
29280: PUSH
29281: DOUBLE
29282: LD_INT 1
29284: DEC
29285: ST_TO_ADDR
29286: LD_EXP 74
29290: PUSH
29291: FOR_TO
29292: IFFALSE 29676
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
29294: LD_EXP 77
29298: PUSH
29299: LD_VAR 0 2
29303: ARRAY
29304: PUSH
29305: LD_INT 1
29307: ARRAY
29308: NOT
29309: PUSH
29310: LD_EXP 77
29314: PUSH
29315: LD_VAR 0 2
29319: ARRAY
29320: PUSH
29321: LD_INT 2
29323: ARRAY
29324: NOT
29325: AND
29326: IFFALSE 29364
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
29328: LD_ADDR_EXP 78
29332: PUSH
29333: LD_EXP 78
29337: PPUSH
29338: LD_VAR 0 2
29342: PPUSH
29343: EMPTY
29344: PPUSH
29345: CALL_OW 1
29349: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
29350: LD_VAR 0 2
29354: PPUSH
29355: LD_INT 102
29357: PPUSH
29358: CALL 23641 0 2
// continue ;
29362: GO 29291
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
29364: LD_ADDR_VAR 0 4
29368: PUSH
29369: LD_EXP 74
29373: PUSH
29374: LD_VAR 0 2
29378: ARRAY
29379: PPUSH
29380: LD_INT 25
29382: PUSH
29383: LD_INT 4
29385: PUSH
29386: EMPTY
29387: LIST
29388: LIST
29389: PPUSH
29390: CALL_OW 72
29394: ST_TO_ADDR
// if not tmp then
29395: LD_VAR 0 4
29399: NOT
29400: IFFALSE 29404
// continue ;
29402: GO 29291
// if mc_taming [ i ] then
29404: LD_EXP 105
29408: PUSH
29409: LD_VAR 0 2
29413: ARRAY
29414: IFFALSE 29438
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
29416: LD_ADDR_EXP 105
29420: PUSH
29421: LD_EXP 105
29425: PPUSH
29426: LD_VAR 0 2
29430: PPUSH
29431: EMPTY
29432: PPUSH
29433: CALL_OW 1
29437: ST_TO_ADDR
// for j in tmp do
29438: LD_ADDR_VAR 0 3
29442: PUSH
29443: LD_VAR 0 4
29447: PUSH
29448: FOR_IN
29449: IFFALSE 29672
// begin if IsInUnit ( j ) then
29451: LD_VAR 0 3
29455: PPUSH
29456: CALL_OW 310
29460: IFFALSE 29471
// ComExitBuilding ( j ) ;
29462: LD_VAR 0 3
29466: PPUSH
29467: CALL_OW 122
// if not j in mc_healers [ i ] then
29471: LD_VAR 0 3
29475: PUSH
29476: LD_EXP 78
29480: PUSH
29481: LD_VAR 0 2
29485: ARRAY
29486: IN
29487: NOT
29488: IFFALSE 29534
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
29490: LD_ADDR_EXP 78
29494: PUSH
29495: LD_EXP 78
29499: PPUSH
29500: LD_VAR 0 2
29504: PUSH
29505: LD_EXP 78
29509: PUSH
29510: LD_VAR 0 2
29514: ARRAY
29515: PUSH
29516: LD_INT 1
29518: PLUS
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PPUSH
29524: LD_VAR 0 3
29528: PPUSH
29529: CALL 56229 0 3
29533: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
29534: LD_VAR 0 3
29538: PPUSH
29539: CALL_OW 110
29543: PUSH
29544: LD_INT 102
29546: NONEQUAL
29547: IFFALSE 29561
// SetTag ( j , 102 ) ;
29549: LD_VAR 0 3
29553: PPUSH
29554: LD_INT 102
29556: PPUSH
29557: CALL_OW 109
// Wait ( 3 ) ;
29561: LD_INT 3
29563: PPUSH
29564: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
29568: LD_EXP 77
29572: PUSH
29573: LD_VAR 0 2
29577: ARRAY
29578: PUSH
29579: LD_INT 1
29581: ARRAY
29582: IFFALSE 29614
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
29584: LD_VAR 0 3
29588: PPUSH
29589: LD_EXP 77
29593: PUSH
29594: LD_VAR 0 2
29598: ARRAY
29599: PUSH
29600: LD_INT 1
29602: ARRAY
29603: PUSH
29604: LD_INT 1
29606: ARRAY
29607: PPUSH
29608: CALL_OW 128
29612: GO 29670
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
29614: LD_VAR 0 3
29618: PPUSH
29619: CALL_OW 314
29623: NOT
29624: PUSH
29625: LD_EXP 77
29629: PUSH
29630: LD_VAR 0 2
29634: ARRAY
29635: PUSH
29636: LD_INT 2
29638: ARRAY
29639: AND
29640: IFFALSE 29670
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
29642: LD_VAR 0 3
29646: PPUSH
29647: LD_EXP 77
29651: PUSH
29652: LD_VAR 0 2
29656: ARRAY
29657: PUSH
29658: LD_INT 2
29660: ARRAY
29661: PUSH
29662: LD_INT 1
29664: ARRAY
29665: PPUSH
29666: CALL_OW 128
// end ;
29670: GO 29448
29672: POP
29673: POP
// end ;
29674: GO 29291
29676: POP
29677: POP
// end ;
29678: LD_VAR 0 1
29682: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
29683: LD_INT 0
29685: PPUSH
29686: PPUSH
29687: PPUSH
29688: PPUSH
29689: PPUSH
// if not mc_bases then
29690: LD_EXP 74
29694: NOT
29695: IFFALSE 29699
// exit ;
29697: GO 30842
// for i = 1 to mc_bases do
29699: LD_ADDR_VAR 0 2
29703: PUSH
29704: DOUBLE
29705: LD_INT 1
29707: DEC
29708: ST_TO_ADDR
29709: LD_EXP 74
29713: PUSH
29714: FOR_TO
29715: IFFALSE 30840
// begin if mc_scan [ i ] then
29717: LD_EXP 97
29721: PUSH
29722: LD_VAR 0 2
29726: ARRAY
29727: IFFALSE 29731
// continue ;
29729: GO 29714
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
29731: LD_EXP 79
29735: PUSH
29736: LD_VAR 0 2
29740: ARRAY
29741: NOT
29742: PUSH
29743: LD_EXP 81
29747: PUSH
29748: LD_VAR 0 2
29752: ARRAY
29753: NOT
29754: AND
29755: PUSH
29756: LD_EXP 80
29760: PUSH
29761: LD_VAR 0 2
29765: ARRAY
29766: AND
29767: IFFALSE 29805
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
29769: LD_ADDR_EXP 80
29773: PUSH
29774: LD_EXP 80
29778: PPUSH
29779: LD_VAR 0 2
29783: PPUSH
29784: EMPTY
29785: PPUSH
29786: CALL_OW 1
29790: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29791: LD_VAR 0 2
29795: PPUSH
29796: LD_INT 103
29798: PPUSH
29799: CALL 23641 0 2
// continue ;
29803: GO 29714
// end ; if mc_construct_list [ i ] then
29805: LD_EXP 81
29809: PUSH
29810: LD_VAR 0 2
29814: ARRAY
29815: IFFALSE 30035
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29817: LD_ADDR_VAR 0 4
29821: PUSH
29822: LD_EXP 74
29826: PUSH
29827: LD_VAR 0 2
29831: ARRAY
29832: PPUSH
29833: LD_INT 25
29835: PUSH
29836: LD_INT 2
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PPUSH
29843: CALL_OW 72
29847: PUSH
29848: LD_EXP 76
29852: PUSH
29853: LD_VAR 0 2
29857: ARRAY
29858: DIFF
29859: ST_TO_ADDR
// if not tmp then
29860: LD_VAR 0 4
29864: NOT
29865: IFFALSE 29869
// continue ;
29867: GO 29714
// for j in tmp do
29869: LD_ADDR_VAR 0 3
29873: PUSH
29874: LD_VAR 0 4
29878: PUSH
29879: FOR_IN
29880: IFFALSE 30031
// begin if not mc_builders [ i ] then
29882: LD_EXP 80
29886: PUSH
29887: LD_VAR 0 2
29891: ARRAY
29892: NOT
29893: IFFALSE 29951
// begin SetTag ( j , 103 ) ;
29895: LD_VAR 0 3
29899: PPUSH
29900: LD_INT 103
29902: PPUSH
29903: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29907: LD_ADDR_EXP 80
29911: PUSH
29912: LD_EXP 80
29916: PPUSH
29917: LD_VAR 0 2
29921: PUSH
29922: LD_EXP 80
29926: PUSH
29927: LD_VAR 0 2
29931: ARRAY
29932: PUSH
29933: LD_INT 1
29935: PLUS
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PPUSH
29941: LD_VAR 0 3
29945: PPUSH
29946: CALL 56229 0 3
29950: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29951: LD_VAR 0 3
29955: PPUSH
29956: CALL_OW 310
29960: IFFALSE 29971
// ComExitBuilding ( j ) ;
29962: LD_VAR 0 3
29966: PPUSH
29967: CALL_OW 122
// wait ( 3 ) ;
29971: LD_INT 3
29973: PPUSH
29974: CALL_OW 67
// if not mc_construct_list [ i ] then
29978: LD_EXP 81
29982: PUSH
29983: LD_VAR 0 2
29987: ARRAY
29988: NOT
29989: IFFALSE 29993
// break ;
29991: GO 30031
// if not HasTask ( j ) then
29993: LD_VAR 0 3
29997: PPUSH
29998: CALL_OW 314
30002: NOT
30003: IFFALSE 30029
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30005: LD_VAR 0 3
30009: PPUSH
30010: LD_EXP 81
30014: PUSH
30015: LD_VAR 0 2
30019: ARRAY
30020: PUSH
30021: LD_INT 1
30023: ARRAY
30024: PPUSH
30025: CALL 59080 0 2
// end ;
30029: GO 29879
30031: POP
30032: POP
// end else
30033: GO 30838
// if mc_build_list [ i ] then
30035: LD_EXP 79
30039: PUSH
30040: LD_VAR 0 2
30044: ARRAY
30045: IFFALSE 30838
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30047: LD_ADDR_VAR 0 5
30051: PUSH
30052: LD_EXP 74
30056: PUSH
30057: LD_VAR 0 2
30061: ARRAY
30062: PPUSH
30063: LD_INT 2
30065: PUSH
30066: LD_INT 30
30068: PUSH
30069: LD_INT 0
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 30
30078: PUSH
30079: LD_INT 1
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: LIST
30090: PPUSH
30091: CALL_OW 72
30095: ST_TO_ADDR
// if depot then
30096: LD_VAR 0 5
30100: IFFALSE 30118
// depot := depot [ 1 ] else
30102: LD_ADDR_VAR 0 5
30106: PUSH
30107: LD_VAR 0 5
30111: PUSH
30112: LD_INT 1
30114: ARRAY
30115: ST_TO_ADDR
30116: GO 30126
// depot := 0 ;
30118: LD_ADDR_VAR 0 5
30122: PUSH
30123: LD_INT 0
30125: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
30126: LD_EXP 79
30130: PUSH
30131: LD_VAR 0 2
30135: ARRAY
30136: PUSH
30137: LD_INT 1
30139: ARRAY
30140: PUSH
30141: LD_INT 1
30143: ARRAY
30144: PPUSH
30145: CALL 58910 0 1
30149: PUSH
30150: LD_EXP 74
30154: PUSH
30155: LD_VAR 0 2
30159: ARRAY
30160: PPUSH
30161: LD_INT 2
30163: PUSH
30164: LD_INT 30
30166: PUSH
30167: LD_INT 2
30169: PUSH
30170: EMPTY
30171: LIST
30172: LIST
30173: PUSH
30174: LD_INT 30
30176: PUSH
30177: LD_INT 3
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: LIST
30188: PPUSH
30189: CALL_OW 72
30193: NOT
30194: AND
30195: IFFALSE 30300
// begin for j = 1 to mc_build_list [ i ] do
30197: LD_ADDR_VAR 0 3
30201: PUSH
30202: DOUBLE
30203: LD_INT 1
30205: DEC
30206: ST_TO_ADDR
30207: LD_EXP 79
30211: PUSH
30212: LD_VAR 0 2
30216: ARRAY
30217: PUSH
30218: FOR_TO
30219: IFFALSE 30298
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
30221: LD_EXP 79
30225: PUSH
30226: LD_VAR 0 2
30230: ARRAY
30231: PUSH
30232: LD_VAR 0 3
30236: ARRAY
30237: PUSH
30238: LD_INT 1
30240: ARRAY
30241: PUSH
30242: LD_INT 2
30244: EQUAL
30245: IFFALSE 30296
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
30247: LD_ADDR_EXP 79
30251: PUSH
30252: LD_EXP 79
30256: PPUSH
30257: LD_VAR 0 2
30261: PPUSH
30262: LD_EXP 79
30266: PUSH
30267: LD_VAR 0 2
30271: ARRAY
30272: PPUSH
30273: LD_VAR 0 3
30277: PPUSH
30278: LD_INT 1
30280: PPUSH
30281: LD_INT 0
30283: PPUSH
30284: CALL 55647 0 4
30288: PPUSH
30289: CALL_OW 1
30293: ST_TO_ADDR
// break ;
30294: GO 30298
// end ;
30296: GO 30218
30298: POP
30299: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
30300: LD_EXP 79
30304: PUSH
30305: LD_VAR 0 2
30309: ARRAY
30310: PUSH
30311: LD_INT 1
30313: ARRAY
30314: PUSH
30315: LD_INT 1
30317: ARRAY
30318: PUSH
30319: LD_INT 0
30321: EQUAL
30322: PUSH
30323: LD_VAR 0 5
30327: PUSH
30328: LD_VAR 0 5
30332: PPUSH
30333: LD_EXP 79
30337: PUSH
30338: LD_VAR 0 2
30342: ARRAY
30343: PUSH
30344: LD_INT 1
30346: ARRAY
30347: PUSH
30348: LD_INT 1
30350: ARRAY
30351: PPUSH
30352: LD_EXP 79
30356: PUSH
30357: LD_VAR 0 2
30361: ARRAY
30362: PUSH
30363: LD_INT 1
30365: ARRAY
30366: PUSH
30367: LD_INT 2
30369: ARRAY
30370: PPUSH
30371: LD_EXP 79
30375: PUSH
30376: LD_VAR 0 2
30380: ARRAY
30381: PUSH
30382: LD_INT 1
30384: ARRAY
30385: PUSH
30386: LD_INT 3
30388: ARRAY
30389: PPUSH
30390: LD_EXP 79
30394: PUSH
30395: LD_VAR 0 2
30399: ARRAY
30400: PUSH
30401: LD_INT 1
30403: ARRAY
30404: PUSH
30405: LD_INT 4
30407: ARRAY
30408: PPUSH
30409: CALL 63644 0 5
30413: AND
30414: OR
30415: IFFALSE 30696
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30417: LD_ADDR_VAR 0 4
30421: PUSH
30422: LD_EXP 74
30426: PUSH
30427: LD_VAR 0 2
30431: ARRAY
30432: PPUSH
30433: LD_INT 25
30435: PUSH
30436: LD_INT 2
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PPUSH
30443: CALL_OW 72
30447: PUSH
30448: LD_EXP 76
30452: PUSH
30453: LD_VAR 0 2
30457: ARRAY
30458: DIFF
30459: ST_TO_ADDR
// if not tmp then
30460: LD_VAR 0 4
30464: NOT
30465: IFFALSE 30469
// continue ;
30467: GO 29714
// for j in tmp do
30469: LD_ADDR_VAR 0 3
30473: PUSH
30474: LD_VAR 0 4
30478: PUSH
30479: FOR_IN
30480: IFFALSE 30692
// begin if not mc_builders [ i ] then
30482: LD_EXP 80
30486: PUSH
30487: LD_VAR 0 2
30491: ARRAY
30492: NOT
30493: IFFALSE 30551
// begin SetTag ( j , 103 ) ;
30495: LD_VAR 0 3
30499: PPUSH
30500: LD_INT 103
30502: PPUSH
30503: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30507: LD_ADDR_EXP 80
30511: PUSH
30512: LD_EXP 80
30516: PPUSH
30517: LD_VAR 0 2
30521: PUSH
30522: LD_EXP 80
30526: PUSH
30527: LD_VAR 0 2
30531: ARRAY
30532: PUSH
30533: LD_INT 1
30535: PLUS
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PPUSH
30541: LD_VAR 0 3
30545: PPUSH
30546: CALL 56229 0 3
30550: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30551: LD_VAR 0 3
30555: PPUSH
30556: CALL_OW 310
30560: IFFALSE 30571
// ComExitBuilding ( j ) ;
30562: LD_VAR 0 3
30566: PPUSH
30567: CALL_OW 122
// wait ( 3 ) ;
30571: LD_INT 3
30573: PPUSH
30574: CALL_OW 67
// if not mc_build_list [ i ] then
30578: LD_EXP 79
30582: PUSH
30583: LD_VAR 0 2
30587: ARRAY
30588: NOT
30589: IFFALSE 30593
// break ;
30591: GO 30692
// if not HasTask ( j ) then
30593: LD_VAR 0 3
30597: PPUSH
30598: CALL_OW 314
30602: NOT
30603: IFFALSE 30690
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
30605: LD_VAR 0 3
30609: PPUSH
30610: LD_EXP 79
30614: PUSH
30615: LD_VAR 0 2
30619: ARRAY
30620: PUSH
30621: LD_INT 1
30623: ARRAY
30624: PUSH
30625: LD_INT 1
30627: ARRAY
30628: PPUSH
30629: LD_EXP 79
30633: PUSH
30634: LD_VAR 0 2
30638: ARRAY
30639: PUSH
30640: LD_INT 1
30642: ARRAY
30643: PUSH
30644: LD_INT 2
30646: ARRAY
30647: PPUSH
30648: LD_EXP 79
30652: PUSH
30653: LD_VAR 0 2
30657: ARRAY
30658: PUSH
30659: LD_INT 1
30661: ARRAY
30662: PUSH
30663: LD_INT 3
30665: ARRAY
30666: PPUSH
30667: LD_EXP 79
30671: PUSH
30672: LD_VAR 0 2
30676: ARRAY
30677: PUSH
30678: LD_INT 1
30680: ARRAY
30681: PUSH
30682: LD_INT 4
30684: ARRAY
30685: PPUSH
30686: CALL_OW 145
// end ;
30690: GO 30479
30692: POP
30693: POP
// end else
30694: GO 30838
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
30696: LD_EXP 74
30700: PUSH
30701: LD_VAR 0 2
30705: ARRAY
30706: PPUSH
30707: LD_EXP 79
30711: PUSH
30712: LD_VAR 0 2
30716: ARRAY
30717: PUSH
30718: LD_INT 1
30720: ARRAY
30721: PUSH
30722: LD_INT 1
30724: ARRAY
30725: PPUSH
30726: LD_EXP 79
30730: PUSH
30731: LD_VAR 0 2
30735: ARRAY
30736: PUSH
30737: LD_INT 1
30739: ARRAY
30740: PUSH
30741: LD_INT 2
30743: ARRAY
30744: PPUSH
30745: LD_EXP 79
30749: PUSH
30750: LD_VAR 0 2
30754: ARRAY
30755: PUSH
30756: LD_INT 1
30758: ARRAY
30759: PUSH
30760: LD_INT 3
30762: ARRAY
30763: PPUSH
30764: LD_EXP 79
30768: PUSH
30769: LD_VAR 0 2
30773: ARRAY
30774: PUSH
30775: LD_INT 1
30777: ARRAY
30778: PUSH
30779: LD_INT 4
30781: ARRAY
30782: PPUSH
30783: CALL 62980 0 5
30787: NOT
30788: IFFALSE 30838
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
30790: LD_ADDR_EXP 79
30794: PUSH
30795: LD_EXP 79
30799: PPUSH
30800: LD_VAR 0 2
30804: PPUSH
30805: LD_EXP 79
30809: PUSH
30810: LD_VAR 0 2
30814: ARRAY
30815: PPUSH
30816: LD_INT 1
30818: PPUSH
30819: LD_INT 1
30821: NEG
30822: PPUSH
30823: LD_INT 0
30825: PPUSH
30826: CALL 55647 0 4
30830: PPUSH
30831: CALL_OW 1
30835: ST_TO_ADDR
// continue ;
30836: GO 29714
// end ; end ; end ;
30838: GO 29714
30840: POP
30841: POP
// end ;
30842: LD_VAR 0 1
30846: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30847: LD_INT 0
30849: PPUSH
30850: PPUSH
30851: PPUSH
30852: PPUSH
30853: PPUSH
30854: PPUSH
// if not mc_bases then
30855: LD_EXP 74
30859: NOT
30860: IFFALSE 30864
// exit ;
30862: GO 31291
// for i = 1 to mc_bases do
30864: LD_ADDR_VAR 0 2
30868: PUSH
30869: DOUBLE
30870: LD_INT 1
30872: DEC
30873: ST_TO_ADDR
30874: LD_EXP 74
30878: PUSH
30879: FOR_TO
30880: IFFALSE 31289
// begin tmp := mc_build_upgrade [ i ] ;
30882: LD_ADDR_VAR 0 4
30886: PUSH
30887: LD_EXP 106
30891: PUSH
30892: LD_VAR 0 2
30896: ARRAY
30897: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30898: LD_ADDR_VAR 0 6
30902: PUSH
30903: LD_EXP 107
30907: PUSH
30908: LD_VAR 0 2
30912: ARRAY
30913: PPUSH
30914: LD_INT 2
30916: PUSH
30917: LD_INT 30
30919: PUSH
30920: LD_INT 6
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: PUSH
30927: LD_INT 30
30929: PUSH
30930: LD_INT 7
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: EMPTY
30938: LIST
30939: LIST
30940: LIST
30941: PPUSH
30942: CALL_OW 72
30946: ST_TO_ADDR
// if not tmp and not lab then
30947: LD_VAR 0 4
30951: NOT
30952: PUSH
30953: LD_VAR 0 6
30957: NOT
30958: AND
30959: IFFALSE 30963
// continue ;
30961: GO 30879
// if tmp then
30963: LD_VAR 0 4
30967: IFFALSE 31087
// for j in tmp do
30969: LD_ADDR_VAR 0 3
30973: PUSH
30974: LD_VAR 0 4
30978: PUSH
30979: FOR_IN
30980: IFFALSE 31085
// begin if UpgradeCost ( j ) then
30982: LD_VAR 0 3
30986: PPUSH
30987: CALL 62640 0 1
30991: IFFALSE 31083
// begin ComUpgrade ( j ) ;
30993: LD_VAR 0 3
30997: PPUSH
30998: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31002: LD_ADDR_EXP 106
31006: PUSH
31007: LD_EXP 106
31011: PPUSH
31012: LD_VAR 0 2
31016: PPUSH
31017: LD_EXP 106
31021: PUSH
31022: LD_VAR 0 2
31026: ARRAY
31027: PUSH
31028: LD_VAR 0 3
31032: DIFF
31033: PPUSH
31034: CALL_OW 1
31038: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31039: LD_ADDR_EXP 81
31043: PUSH
31044: LD_EXP 81
31048: PPUSH
31049: LD_VAR 0 2
31053: PUSH
31054: LD_EXP 81
31058: PUSH
31059: LD_VAR 0 2
31063: ARRAY
31064: PUSH
31065: LD_INT 1
31067: PLUS
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: PPUSH
31073: LD_VAR 0 3
31077: PPUSH
31078: CALL 56229 0 3
31082: ST_TO_ADDR
// end ; end ;
31083: GO 30979
31085: POP
31086: POP
// if not lab or not mc_lab_upgrade [ i ] then
31087: LD_VAR 0 6
31091: NOT
31092: PUSH
31093: LD_EXP 108
31097: PUSH
31098: LD_VAR 0 2
31102: ARRAY
31103: NOT
31104: OR
31105: IFFALSE 31109
// continue ;
31107: GO 30879
// for j in lab do
31109: LD_ADDR_VAR 0 3
31113: PUSH
31114: LD_VAR 0 6
31118: PUSH
31119: FOR_IN
31120: IFFALSE 31285
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
31122: LD_VAR 0 3
31126: PPUSH
31127: CALL_OW 266
31131: PUSH
31132: LD_INT 6
31134: PUSH
31135: LD_INT 7
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: IN
31142: PUSH
31143: LD_VAR 0 3
31147: PPUSH
31148: CALL_OW 461
31152: PUSH
31153: LD_INT 1
31155: NONEQUAL
31156: AND
31157: IFFALSE 31283
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
31159: LD_VAR 0 3
31163: PPUSH
31164: LD_EXP 108
31168: PUSH
31169: LD_VAR 0 2
31173: ARRAY
31174: PUSH
31175: LD_INT 1
31177: ARRAY
31178: PPUSH
31179: CALL 62845 0 2
31183: IFFALSE 31283
// begin ComCancel ( j ) ;
31185: LD_VAR 0 3
31189: PPUSH
31190: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
31194: LD_VAR 0 3
31198: PPUSH
31199: LD_EXP 108
31203: PUSH
31204: LD_VAR 0 2
31208: ARRAY
31209: PUSH
31210: LD_INT 1
31212: ARRAY
31213: PPUSH
31214: CALL_OW 207
// if not j in mc_construct_list [ i ] then
31218: LD_VAR 0 3
31222: PUSH
31223: LD_EXP 81
31227: PUSH
31228: LD_VAR 0 2
31232: ARRAY
31233: IN
31234: NOT
31235: IFFALSE 31281
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31237: LD_ADDR_EXP 81
31241: PUSH
31242: LD_EXP 81
31246: PPUSH
31247: LD_VAR 0 2
31251: PUSH
31252: LD_EXP 81
31256: PUSH
31257: LD_VAR 0 2
31261: ARRAY
31262: PUSH
31263: LD_INT 1
31265: PLUS
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PPUSH
31271: LD_VAR 0 3
31275: PPUSH
31276: CALL 56229 0 3
31280: ST_TO_ADDR
// break ;
31281: GO 31285
// end ; end ; end ;
31283: GO 31119
31285: POP
31286: POP
// end ;
31287: GO 30879
31289: POP
31290: POP
// end ;
31291: LD_VAR 0 1
31295: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
31296: LD_INT 0
31298: PPUSH
31299: PPUSH
31300: PPUSH
31301: PPUSH
31302: PPUSH
31303: PPUSH
31304: PPUSH
31305: PPUSH
31306: PPUSH
// if not mc_bases then
31307: LD_EXP 74
31311: NOT
31312: IFFALSE 31316
// exit ;
31314: GO 31721
// for i = 1 to mc_bases do
31316: LD_ADDR_VAR 0 2
31320: PUSH
31321: DOUBLE
31322: LD_INT 1
31324: DEC
31325: ST_TO_ADDR
31326: LD_EXP 74
31330: PUSH
31331: FOR_TO
31332: IFFALSE 31719
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
31334: LD_EXP 82
31338: PUSH
31339: LD_VAR 0 2
31343: ARRAY
31344: NOT
31345: PUSH
31346: LD_EXP 74
31350: PUSH
31351: LD_VAR 0 2
31355: ARRAY
31356: PPUSH
31357: LD_INT 30
31359: PUSH
31360: LD_INT 3
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PPUSH
31367: CALL_OW 72
31371: NOT
31372: OR
31373: IFFALSE 31377
// continue ;
31375: GO 31331
// busy := false ;
31377: LD_ADDR_VAR 0 8
31381: PUSH
31382: LD_INT 0
31384: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
31385: LD_ADDR_VAR 0 4
31389: PUSH
31390: LD_EXP 74
31394: PUSH
31395: LD_VAR 0 2
31399: ARRAY
31400: PPUSH
31401: LD_INT 30
31403: PUSH
31404: LD_INT 3
31406: PUSH
31407: EMPTY
31408: LIST
31409: LIST
31410: PPUSH
31411: CALL_OW 72
31415: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
31416: LD_ADDR_VAR 0 6
31420: PUSH
31421: LD_EXP 82
31425: PUSH
31426: LD_VAR 0 2
31430: ARRAY
31431: PPUSH
31432: LD_INT 2
31434: PUSH
31435: LD_INT 30
31437: PUSH
31438: LD_INT 32
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 30
31447: PUSH
31448: LD_INT 33
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: LIST
31459: PPUSH
31460: CALL_OW 72
31464: ST_TO_ADDR
// if not t then
31465: LD_VAR 0 6
31469: NOT
31470: IFFALSE 31474
// continue ;
31472: GO 31331
// for j in tmp do
31474: LD_ADDR_VAR 0 3
31478: PUSH
31479: LD_VAR 0 4
31483: PUSH
31484: FOR_IN
31485: IFFALSE 31515
// if not BuildingStatus ( j ) = bs_idle then
31487: LD_VAR 0 3
31491: PPUSH
31492: CALL_OW 461
31496: PUSH
31497: LD_INT 2
31499: EQUAL
31500: NOT
31501: IFFALSE 31513
// begin busy := true ;
31503: LD_ADDR_VAR 0 8
31507: PUSH
31508: LD_INT 1
31510: ST_TO_ADDR
// break ;
31511: GO 31515
// end ;
31513: GO 31484
31515: POP
31516: POP
// if busy then
31517: LD_VAR 0 8
31521: IFFALSE 31525
// continue ;
31523: GO 31331
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
31525: LD_ADDR_VAR 0 7
31529: PUSH
31530: LD_VAR 0 6
31534: PPUSH
31535: LD_INT 35
31537: PUSH
31538: LD_INT 0
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PPUSH
31545: CALL_OW 72
31549: ST_TO_ADDR
// if tw then
31550: LD_VAR 0 7
31554: IFFALSE 31631
// begin tw := tw [ 1 ] ;
31556: LD_ADDR_VAR 0 7
31560: PUSH
31561: LD_VAR 0 7
31565: PUSH
31566: LD_INT 1
31568: ARRAY
31569: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
31570: LD_ADDR_VAR 0 9
31574: PUSH
31575: LD_VAR 0 7
31579: PPUSH
31580: LD_EXP 99
31584: PUSH
31585: LD_VAR 0 2
31589: ARRAY
31590: PPUSH
31591: CALL 61199 0 2
31595: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
31596: LD_EXP 113
31600: PUSH
31601: LD_VAR 0 2
31605: ARRAY
31606: IFFALSE 31629
// if not weapon in mc_allowed_tower_weapons [ i ] then
31608: LD_VAR 0 9
31612: PUSH
31613: LD_EXP 113
31617: PUSH
31618: LD_VAR 0 2
31622: ARRAY
31623: IN
31624: NOT
31625: IFFALSE 31629
// continue ;
31627: GO 31331
// end else
31629: GO 31694
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
31631: LD_ADDR_VAR 0 5
31635: PUSH
31636: LD_EXP 82
31640: PUSH
31641: LD_VAR 0 2
31645: ARRAY
31646: PPUSH
31647: LD_VAR 0 4
31651: PPUSH
31652: CALL 91400 0 2
31656: ST_TO_ADDR
// if not tmp2 then
31657: LD_VAR 0 5
31661: NOT
31662: IFFALSE 31666
// continue ;
31664: GO 31331
// tw := tmp2 [ 1 ] ;
31666: LD_ADDR_VAR 0 7
31670: PUSH
31671: LD_VAR 0 5
31675: PUSH
31676: LD_INT 1
31678: ARRAY
31679: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
31680: LD_ADDR_VAR 0 9
31684: PUSH
31685: LD_VAR 0 5
31689: PUSH
31690: LD_INT 2
31692: ARRAY
31693: ST_TO_ADDR
// end ; if not weapon then
31694: LD_VAR 0 9
31698: NOT
31699: IFFALSE 31703
// continue ;
31701: GO 31331
// ComPlaceWeapon ( tw , weapon ) ;
31703: LD_VAR 0 7
31707: PPUSH
31708: LD_VAR 0 9
31712: PPUSH
31713: CALL_OW 148
// end ;
31717: GO 31331
31719: POP
31720: POP
// end ;
31721: LD_VAR 0 1
31725: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
31726: LD_INT 0
31728: PPUSH
31729: PPUSH
31730: PPUSH
31731: PPUSH
31732: PPUSH
31733: PPUSH
// if not mc_bases then
31734: LD_EXP 74
31738: NOT
31739: IFFALSE 31743
// exit ;
31741: GO 32755
// for i = 1 to mc_bases do
31743: LD_ADDR_VAR 0 2
31747: PUSH
31748: DOUBLE
31749: LD_INT 1
31751: DEC
31752: ST_TO_ADDR
31753: LD_EXP 74
31757: PUSH
31758: FOR_TO
31759: IFFALSE 32753
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
31761: LD_EXP 87
31765: PUSH
31766: LD_VAR 0 2
31770: ARRAY
31771: NOT
31772: PUSH
31773: LD_EXP 87
31777: PUSH
31778: LD_VAR 0 2
31782: ARRAY
31783: PUSH
31784: LD_EXP 88
31788: PUSH
31789: LD_VAR 0 2
31793: ARRAY
31794: EQUAL
31795: OR
31796: IFFALSE 31800
// continue ;
31798: GO 31758
// if mc_miners [ i ] then
31800: LD_EXP 88
31804: PUSH
31805: LD_VAR 0 2
31809: ARRAY
31810: IFFALSE 32440
// begin k := 1 ;
31812: LD_ADDR_VAR 0 4
31816: PUSH
31817: LD_INT 1
31819: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
31820: LD_ADDR_VAR 0 3
31824: PUSH
31825: DOUBLE
31826: LD_EXP 88
31830: PUSH
31831: LD_VAR 0 2
31835: ARRAY
31836: INC
31837: ST_TO_ADDR
31838: LD_INT 1
31840: PUSH
31841: FOR_DOWNTO
31842: IFFALSE 32438
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31844: LD_EXP 88
31848: PUSH
31849: LD_VAR 0 2
31853: ARRAY
31854: PUSH
31855: LD_VAR 0 3
31859: ARRAY
31860: PPUSH
31861: CALL_OW 301
31865: PUSH
31866: LD_EXP 88
31870: PUSH
31871: LD_VAR 0 2
31875: ARRAY
31876: PUSH
31877: LD_VAR 0 3
31881: ARRAY
31882: PPUSH
31883: CALL_OW 257
31887: PUSH
31888: LD_INT 1
31890: NONEQUAL
31891: OR
31892: IFFALSE 31955
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31894: LD_ADDR_VAR 0 5
31898: PUSH
31899: LD_EXP 88
31903: PUSH
31904: LD_VAR 0 2
31908: ARRAY
31909: PUSH
31910: LD_EXP 88
31914: PUSH
31915: LD_VAR 0 2
31919: ARRAY
31920: PUSH
31921: LD_VAR 0 3
31925: ARRAY
31926: DIFF
31927: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31928: LD_ADDR_EXP 88
31932: PUSH
31933: LD_EXP 88
31937: PPUSH
31938: LD_VAR 0 2
31942: PPUSH
31943: LD_VAR 0 5
31947: PPUSH
31948: CALL_OW 1
31952: ST_TO_ADDR
// continue ;
31953: GO 31841
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
31955: LD_EXP 88
31959: PUSH
31960: LD_VAR 0 2
31964: ARRAY
31965: PUSH
31966: LD_VAR 0 3
31970: ARRAY
31971: PPUSH
31972: CALL 56165 0 1
31976: PUSH
31977: LD_EXP 88
31981: PUSH
31982: LD_VAR 0 2
31986: ARRAY
31987: PUSH
31988: LD_VAR 0 3
31992: ARRAY
31993: PPUSH
31994: CALL_OW 255
31998: PPUSH
31999: LD_EXP 87
32003: PUSH
32004: LD_VAR 0 2
32008: ARRAY
32009: PUSH
32010: LD_VAR 0 4
32014: ARRAY
32015: PUSH
32016: LD_INT 1
32018: ARRAY
32019: PPUSH
32020: LD_EXP 87
32024: PUSH
32025: LD_VAR 0 2
32029: ARRAY
32030: PUSH
32031: LD_VAR 0 4
32035: ARRAY
32036: PUSH
32037: LD_INT 2
32039: ARRAY
32040: PPUSH
32041: LD_INT 15
32043: PPUSH
32044: CALL 57125 0 4
32048: PUSH
32049: LD_INT 4
32051: ARRAY
32052: PUSH
32053: LD_EXP 88
32057: PUSH
32058: LD_VAR 0 2
32062: ARRAY
32063: PUSH
32064: LD_VAR 0 3
32068: ARRAY
32069: PPUSH
32070: LD_INT 10
32072: PPUSH
32073: CALL 58822 0 2
32077: PUSH
32078: LD_INT 4
32080: ARRAY
32081: OR
32082: AND
32083: IFFALSE 32106
// ComStop ( mc_miners [ i ] [ j ] ) ;
32085: LD_EXP 88
32089: PUSH
32090: LD_VAR 0 2
32094: ARRAY
32095: PUSH
32096: LD_VAR 0 3
32100: ARRAY
32101: PPUSH
32102: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
32106: LD_EXP 88
32110: PUSH
32111: LD_VAR 0 2
32115: ARRAY
32116: PUSH
32117: LD_VAR 0 3
32121: ARRAY
32122: PPUSH
32123: CALL_OW 257
32127: PUSH
32128: LD_INT 1
32130: EQUAL
32131: PUSH
32132: LD_EXP 88
32136: PUSH
32137: LD_VAR 0 2
32141: ARRAY
32142: PUSH
32143: LD_VAR 0 3
32147: ARRAY
32148: PPUSH
32149: CALL_OW 459
32153: NOT
32154: AND
32155: PUSH
32156: LD_EXP 88
32160: PUSH
32161: LD_VAR 0 2
32165: ARRAY
32166: PUSH
32167: LD_VAR 0 3
32171: ARRAY
32172: PPUSH
32173: CALL_OW 255
32177: PPUSH
32178: LD_EXP 87
32182: PUSH
32183: LD_VAR 0 2
32187: ARRAY
32188: PUSH
32189: LD_VAR 0 4
32193: ARRAY
32194: PUSH
32195: LD_INT 1
32197: ARRAY
32198: PPUSH
32199: LD_EXP 87
32203: PUSH
32204: LD_VAR 0 2
32208: ARRAY
32209: PUSH
32210: LD_VAR 0 4
32214: ARRAY
32215: PUSH
32216: LD_INT 2
32218: ARRAY
32219: PPUSH
32220: LD_INT 15
32222: PPUSH
32223: CALL 57125 0 4
32227: PUSH
32228: LD_INT 4
32230: ARRAY
32231: PUSH
32232: LD_INT 0
32234: EQUAL
32235: AND
32236: PUSH
32237: LD_EXP 88
32241: PUSH
32242: LD_VAR 0 2
32246: ARRAY
32247: PUSH
32248: LD_VAR 0 3
32252: ARRAY
32253: PPUSH
32254: CALL_OW 314
32258: NOT
32259: AND
32260: IFFALSE 32436
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32262: LD_EXP 88
32266: PUSH
32267: LD_VAR 0 2
32271: ARRAY
32272: PUSH
32273: LD_VAR 0 3
32277: ARRAY
32278: PPUSH
32279: CALL_OW 310
32283: IFFALSE 32306
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32285: LD_EXP 88
32289: PUSH
32290: LD_VAR 0 2
32294: ARRAY
32295: PUSH
32296: LD_VAR 0 3
32300: ARRAY
32301: PPUSH
32302: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
32306: LD_EXP 88
32310: PUSH
32311: LD_VAR 0 2
32315: ARRAY
32316: PUSH
32317: LD_VAR 0 3
32321: ARRAY
32322: PPUSH
32323: CALL_OW 314
32327: NOT
32328: IFFALSE 32396
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
32330: LD_EXP 88
32334: PUSH
32335: LD_VAR 0 2
32339: ARRAY
32340: PUSH
32341: LD_VAR 0 3
32345: ARRAY
32346: PPUSH
32347: LD_EXP 87
32351: PUSH
32352: LD_VAR 0 2
32356: ARRAY
32357: PUSH
32358: LD_VAR 0 4
32362: ARRAY
32363: PUSH
32364: LD_INT 1
32366: ARRAY
32367: PPUSH
32368: LD_EXP 87
32372: PUSH
32373: LD_VAR 0 2
32377: ARRAY
32378: PUSH
32379: LD_VAR 0 4
32383: ARRAY
32384: PUSH
32385: LD_INT 2
32387: ARRAY
32388: PPUSH
32389: LD_INT 0
32391: PPUSH
32392: CALL_OW 193
// k := k + 1 ;
32396: LD_ADDR_VAR 0 4
32400: PUSH
32401: LD_VAR 0 4
32405: PUSH
32406: LD_INT 1
32408: PLUS
32409: ST_TO_ADDR
// if k > mc_mines [ i ] then
32410: LD_VAR 0 4
32414: PUSH
32415: LD_EXP 87
32419: PUSH
32420: LD_VAR 0 2
32424: ARRAY
32425: GREATER
32426: IFFALSE 32436
// k := 1 ;
32428: LD_ADDR_VAR 0 4
32432: PUSH
32433: LD_INT 1
32435: ST_TO_ADDR
// end ; end ;
32436: GO 31841
32438: POP
32439: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
32440: LD_ADDR_VAR 0 5
32444: PUSH
32445: LD_EXP 74
32449: PUSH
32450: LD_VAR 0 2
32454: ARRAY
32455: PPUSH
32456: LD_INT 2
32458: PUSH
32459: LD_INT 30
32461: PUSH
32462: LD_INT 4
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 30
32471: PUSH
32472: LD_INT 5
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 30
32481: PUSH
32482: LD_INT 32
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: PPUSH
32495: CALL_OW 72
32499: ST_TO_ADDR
// if not tmp then
32500: LD_VAR 0 5
32504: NOT
32505: IFFALSE 32509
// continue ;
32507: GO 31758
// list := [ ] ;
32509: LD_ADDR_VAR 0 6
32513: PUSH
32514: EMPTY
32515: ST_TO_ADDR
// for j in tmp do
32516: LD_ADDR_VAR 0 3
32520: PUSH
32521: LD_VAR 0 5
32525: PUSH
32526: FOR_IN
32527: IFFALSE 32596
// begin for k in UnitsInside ( j ) do
32529: LD_ADDR_VAR 0 4
32533: PUSH
32534: LD_VAR 0 3
32538: PPUSH
32539: CALL_OW 313
32543: PUSH
32544: FOR_IN
32545: IFFALSE 32592
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
32547: LD_VAR 0 4
32551: PPUSH
32552: CALL_OW 257
32556: PUSH
32557: LD_INT 1
32559: EQUAL
32560: PUSH
32561: LD_VAR 0 4
32565: PPUSH
32566: CALL_OW 459
32570: NOT
32571: AND
32572: IFFALSE 32590
// list := list ^ k ;
32574: LD_ADDR_VAR 0 6
32578: PUSH
32579: LD_VAR 0 6
32583: PUSH
32584: LD_VAR 0 4
32588: ADD
32589: ST_TO_ADDR
32590: GO 32544
32592: POP
32593: POP
// end ;
32594: GO 32526
32596: POP
32597: POP
// list := list diff mc_miners [ i ] ;
32598: LD_ADDR_VAR 0 6
32602: PUSH
32603: LD_VAR 0 6
32607: PUSH
32608: LD_EXP 88
32612: PUSH
32613: LD_VAR 0 2
32617: ARRAY
32618: DIFF
32619: ST_TO_ADDR
// if not list then
32620: LD_VAR 0 6
32624: NOT
32625: IFFALSE 32629
// continue ;
32627: GO 31758
// k := mc_mines [ i ] - mc_miners [ i ] ;
32629: LD_ADDR_VAR 0 4
32633: PUSH
32634: LD_EXP 87
32638: PUSH
32639: LD_VAR 0 2
32643: ARRAY
32644: PUSH
32645: LD_EXP 88
32649: PUSH
32650: LD_VAR 0 2
32654: ARRAY
32655: MINUS
32656: ST_TO_ADDR
// if k > list then
32657: LD_VAR 0 4
32661: PUSH
32662: LD_VAR 0 6
32666: GREATER
32667: IFFALSE 32679
// k := list ;
32669: LD_ADDR_VAR 0 4
32673: PUSH
32674: LD_VAR 0 6
32678: ST_TO_ADDR
// for j = 1 to k do
32679: LD_ADDR_VAR 0 3
32683: PUSH
32684: DOUBLE
32685: LD_INT 1
32687: DEC
32688: ST_TO_ADDR
32689: LD_VAR 0 4
32693: PUSH
32694: FOR_TO
32695: IFFALSE 32749
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
32697: LD_ADDR_EXP 88
32701: PUSH
32702: LD_EXP 88
32706: PPUSH
32707: LD_VAR 0 2
32711: PUSH
32712: LD_EXP 88
32716: PUSH
32717: LD_VAR 0 2
32721: ARRAY
32722: PUSH
32723: LD_INT 1
32725: PLUS
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PPUSH
32731: LD_VAR 0 6
32735: PUSH
32736: LD_VAR 0 3
32740: ARRAY
32741: PPUSH
32742: CALL 56229 0 3
32746: ST_TO_ADDR
32747: GO 32694
32749: POP
32750: POP
// end ;
32751: GO 31758
32753: POP
32754: POP
// end ;
32755: LD_VAR 0 1
32759: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
32760: LD_INT 0
32762: PPUSH
32763: PPUSH
32764: PPUSH
32765: PPUSH
32766: PPUSH
32767: PPUSH
32768: PPUSH
32769: PPUSH
32770: PPUSH
32771: PPUSH
// if not mc_bases then
32772: LD_EXP 74
32776: NOT
32777: IFFALSE 32781
// exit ;
32779: GO 34531
// for i = 1 to mc_bases do
32781: LD_ADDR_VAR 0 2
32785: PUSH
32786: DOUBLE
32787: LD_INT 1
32789: DEC
32790: ST_TO_ADDR
32791: LD_EXP 74
32795: PUSH
32796: FOR_TO
32797: IFFALSE 34529
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
32799: LD_EXP 74
32803: PUSH
32804: LD_VAR 0 2
32808: ARRAY
32809: NOT
32810: PUSH
32811: LD_EXP 81
32815: PUSH
32816: LD_VAR 0 2
32820: ARRAY
32821: OR
32822: IFFALSE 32826
// continue ;
32824: GO 32796
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
32826: LD_EXP 90
32830: PUSH
32831: LD_VAR 0 2
32835: ARRAY
32836: NOT
32837: PUSH
32838: LD_EXP 91
32842: PUSH
32843: LD_VAR 0 2
32847: ARRAY
32848: AND
32849: IFFALSE 32887
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
32851: LD_ADDR_EXP 91
32855: PUSH
32856: LD_EXP 91
32860: PPUSH
32861: LD_VAR 0 2
32865: PPUSH
32866: EMPTY
32867: PPUSH
32868: CALL_OW 1
32872: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
32873: LD_VAR 0 2
32877: PPUSH
32878: LD_INT 107
32880: PPUSH
32881: CALL 23641 0 2
// continue ;
32885: GO 32796
// end ; target := [ ] ;
32887: LD_ADDR_VAR 0 6
32891: PUSH
32892: EMPTY
32893: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
32894: LD_ADDR_VAR 0 3
32898: PUSH
32899: DOUBLE
32900: LD_EXP 90
32904: PUSH
32905: LD_VAR 0 2
32909: ARRAY
32910: INC
32911: ST_TO_ADDR
32912: LD_INT 1
32914: PUSH
32915: FOR_DOWNTO
32916: IFFALSE 33176
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
32918: LD_EXP 90
32922: PUSH
32923: LD_VAR 0 2
32927: ARRAY
32928: PUSH
32929: LD_VAR 0 3
32933: ARRAY
32934: PUSH
32935: LD_INT 2
32937: ARRAY
32938: PPUSH
32939: LD_EXP 90
32943: PUSH
32944: LD_VAR 0 2
32948: ARRAY
32949: PUSH
32950: LD_VAR 0 3
32954: ARRAY
32955: PUSH
32956: LD_INT 3
32958: ARRAY
32959: PPUSH
32960: CALL_OW 488
32964: PUSH
32965: LD_EXP 90
32969: PUSH
32970: LD_VAR 0 2
32974: ARRAY
32975: PUSH
32976: LD_VAR 0 3
32980: ARRAY
32981: PUSH
32982: LD_INT 2
32984: ARRAY
32985: PPUSH
32986: LD_EXP 90
32990: PUSH
32991: LD_VAR 0 2
32995: ARRAY
32996: PUSH
32997: LD_VAR 0 3
33001: ARRAY
33002: PUSH
33003: LD_INT 3
33005: ARRAY
33006: PPUSH
33007: CALL_OW 284
33011: PUSH
33012: LD_INT 0
33014: EQUAL
33015: AND
33016: IFFALSE 33071
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33018: LD_ADDR_VAR 0 5
33022: PUSH
33023: LD_EXP 90
33027: PUSH
33028: LD_VAR 0 2
33032: ARRAY
33033: PPUSH
33034: LD_VAR 0 3
33038: PPUSH
33039: CALL_OW 3
33043: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33044: LD_ADDR_EXP 90
33048: PUSH
33049: LD_EXP 90
33053: PPUSH
33054: LD_VAR 0 2
33058: PPUSH
33059: LD_VAR 0 5
33063: PPUSH
33064: CALL_OW 1
33068: ST_TO_ADDR
// continue ;
33069: GO 32915
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33071: LD_EXP 74
33075: PUSH
33076: LD_VAR 0 2
33080: ARRAY
33081: PUSH
33082: LD_INT 1
33084: ARRAY
33085: PPUSH
33086: CALL_OW 255
33090: PPUSH
33091: LD_EXP 90
33095: PUSH
33096: LD_VAR 0 2
33100: ARRAY
33101: PUSH
33102: LD_VAR 0 3
33106: ARRAY
33107: PUSH
33108: LD_INT 2
33110: ARRAY
33111: PPUSH
33112: LD_EXP 90
33116: PUSH
33117: LD_VAR 0 2
33121: ARRAY
33122: PUSH
33123: LD_VAR 0 3
33127: ARRAY
33128: PUSH
33129: LD_INT 3
33131: ARRAY
33132: PPUSH
33133: LD_INT 30
33135: PPUSH
33136: CALL 57125 0 4
33140: PUSH
33141: LD_INT 4
33143: ARRAY
33144: PUSH
33145: LD_INT 0
33147: EQUAL
33148: IFFALSE 33174
// begin target := mc_crates [ i ] [ j ] ;
33150: LD_ADDR_VAR 0 6
33154: PUSH
33155: LD_EXP 90
33159: PUSH
33160: LD_VAR 0 2
33164: ARRAY
33165: PUSH
33166: LD_VAR 0 3
33170: ARRAY
33171: ST_TO_ADDR
// break ;
33172: GO 33176
// end ; end ;
33174: GO 32915
33176: POP
33177: POP
// if not target then
33178: LD_VAR 0 6
33182: NOT
33183: IFFALSE 33187
// continue ;
33185: GO 32796
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33187: LD_ADDR_VAR 0 7
33191: PUSH
33192: LD_EXP 93
33196: PUSH
33197: LD_VAR 0 2
33201: ARRAY
33202: PPUSH
33203: LD_INT 2
33205: PUSH
33206: LD_INT 3
33208: PUSH
33209: LD_INT 58
33211: PUSH
33212: EMPTY
33213: LIST
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 61
33221: PUSH
33222: EMPTY
33223: LIST
33224: PUSH
33225: LD_INT 33
33227: PUSH
33228: LD_INT 5
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 33
33237: PUSH
33238: LD_INT 3
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: LIST
33249: LIST
33250: LIST
33251: PUSH
33252: LD_INT 2
33254: PUSH
33255: LD_INT 34
33257: PUSH
33258: LD_INT 32
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 34
33267: PUSH
33268: LD_INT 51
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 34
33277: PUSH
33278: LD_INT 12
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: LIST
33289: LIST
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PPUSH
33295: CALL_OW 72
33299: ST_TO_ADDR
// if not cargo then
33300: LD_VAR 0 7
33304: NOT
33305: IFFALSE 33948
// begin if mc_crates_collector [ i ] < 5 then
33307: LD_EXP 91
33311: PUSH
33312: LD_VAR 0 2
33316: ARRAY
33317: PUSH
33318: LD_INT 5
33320: LESS
33321: IFFALSE 33687
// begin if mc_ape [ i ] then
33323: LD_EXP 103
33327: PUSH
33328: LD_VAR 0 2
33332: ARRAY
33333: IFFALSE 33380
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
33335: LD_ADDR_VAR 0 5
33339: PUSH
33340: LD_EXP 103
33344: PUSH
33345: LD_VAR 0 2
33349: ARRAY
33350: PPUSH
33351: LD_INT 25
33353: PUSH
33354: LD_INT 16
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: LD_INT 24
33363: PUSH
33364: LD_INT 750
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PPUSH
33375: CALL_OW 72
33379: ST_TO_ADDR
// if not tmp then
33380: LD_VAR 0 5
33384: NOT
33385: IFFALSE 33432
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
33387: LD_ADDR_VAR 0 5
33391: PUSH
33392: LD_EXP 74
33396: PUSH
33397: LD_VAR 0 2
33401: ARRAY
33402: PPUSH
33403: LD_INT 25
33405: PUSH
33406: LD_INT 2
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 24
33415: PUSH
33416: LD_INT 750
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PPUSH
33427: CALL_OW 72
33431: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
33432: LD_EXP 103
33436: PUSH
33437: LD_VAR 0 2
33441: ARRAY
33442: PUSH
33443: LD_EXP 74
33447: PUSH
33448: LD_VAR 0 2
33452: ARRAY
33453: PPUSH
33454: LD_INT 25
33456: PUSH
33457: LD_INT 2
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: PUSH
33464: LD_INT 24
33466: PUSH
33467: LD_INT 750
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: PPUSH
33478: CALL_OW 72
33482: AND
33483: PUSH
33484: LD_VAR 0 5
33488: PUSH
33489: LD_INT 5
33491: LESS
33492: AND
33493: IFFALSE 33575
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
33495: LD_ADDR_VAR 0 3
33499: PUSH
33500: LD_EXP 74
33504: PUSH
33505: LD_VAR 0 2
33509: ARRAY
33510: PPUSH
33511: LD_INT 25
33513: PUSH
33514: LD_INT 2
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 24
33523: PUSH
33524: LD_INT 750
33526: PUSH
33527: EMPTY
33528: LIST
33529: LIST
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PPUSH
33535: CALL_OW 72
33539: PUSH
33540: FOR_IN
33541: IFFALSE 33573
// begin tmp := tmp union j ;
33543: LD_ADDR_VAR 0 5
33547: PUSH
33548: LD_VAR 0 5
33552: PUSH
33553: LD_VAR 0 3
33557: UNION
33558: ST_TO_ADDR
// if tmp >= 5 then
33559: LD_VAR 0 5
33563: PUSH
33564: LD_INT 5
33566: GREATEREQUAL
33567: IFFALSE 33571
// break ;
33569: GO 33573
// end ;
33571: GO 33540
33573: POP
33574: POP
// end ; if not tmp then
33575: LD_VAR 0 5
33579: NOT
33580: IFFALSE 33584
// continue ;
33582: GO 32796
// for j in tmp do
33584: LD_ADDR_VAR 0 3
33588: PUSH
33589: LD_VAR 0 5
33593: PUSH
33594: FOR_IN
33595: IFFALSE 33685
// if not GetTag ( j ) then
33597: LD_VAR 0 3
33601: PPUSH
33602: CALL_OW 110
33606: NOT
33607: IFFALSE 33683
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
33609: LD_ADDR_EXP 91
33613: PUSH
33614: LD_EXP 91
33618: PPUSH
33619: LD_VAR 0 2
33623: PUSH
33624: LD_EXP 91
33628: PUSH
33629: LD_VAR 0 2
33633: ARRAY
33634: PUSH
33635: LD_INT 1
33637: PLUS
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PPUSH
33643: LD_VAR 0 3
33647: PPUSH
33648: CALL 56229 0 3
33652: ST_TO_ADDR
// SetTag ( j , 107 ) ;
33653: LD_VAR 0 3
33657: PPUSH
33658: LD_INT 107
33660: PPUSH
33661: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
33665: LD_EXP 91
33669: PUSH
33670: LD_VAR 0 2
33674: ARRAY
33675: PUSH
33676: LD_INT 5
33678: GREATEREQUAL
33679: IFFALSE 33683
// break ;
33681: GO 33685
// end ;
33683: GO 33594
33685: POP
33686: POP
// end ; if mc_crates_collector [ i ] and target then
33687: LD_EXP 91
33691: PUSH
33692: LD_VAR 0 2
33696: ARRAY
33697: PUSH
33698: LD_VAR 0 6
33702: AND
33703: IFFALSE 33946
// begin if mc_crates_collector [ i ] < target [ 1 ] then
33705: LD_EXP 91
33709: PUSH
33710: LD_VAR 0 2
33714: ARRAY
33715: PUSH
33716: LD_VAR 0 6
33720: PUSH
33721: LD_INT 1
33723: ARRAY
33724: LESS
33725: IFFALSE 33745
// tmp := mc_crates_collector [ i ] else
33727: LD_ADDR_VAR 0 5
33731: PUSH
33732: LD_EXP 91
33736: PUSH
33737: LD_VAR 0 2
33741: ARRAY
33742: ST_TO_ADDR
33743: GO 33759
// tmp := target [ 1 ] ;
33745: LD_ADDR_VAR 0 5
33749: PUSH
33750: LD_VAR 0 6
33754: PUSH
33755: LD_INT 1
33757: ARRAY
33758: ST_TO_ADDR
// k := 0 ;
33759: LD_ADDR_VAR 0 4
33763: PUSH
33764: LD_INT 0
33766: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
33767: LD_ADDR_VAR 0 3
33771: PUSH
33772: LD_EXP 91
33776: PUSH
33777: LD_VAR 0 2
33781: ARRAY
33782: PUSH
33783: FOR_IN
33784: IFFALSE 33944
// begin k := k + 1 ;
33786: LD_ADDR_VAR 0 4
33790: PUSH
33791: LD_VAR 0 4
33795: PUSH
33796: LD_INT 1
33798: PLUS
33799: ST_TO_ADDR
// if k > tmp then
33800: LD_VAR 0 4
33804: PUSH
33805: LD_VAR 0 5
33809: GREATER
33810: IFFALSE 33814
// break ;
33812: GO 33944
// if not GetClass ( j ) in [ 2 , 16 ] then
33814: LD_VAR 0 3
33818: PPUSH
33819: CALL_OW 257
33823: PUSH
33824: LD_INT 2
33826: PUSH
33827: LD_INT 16
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: IN
33834: NOT
33835: IFFALSE 33888
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
33837: LD_ADDR_EXP 91
33841: PUSH
33842: LD_EXP 91
33846: PPUSH
33847: LD_VAR 0 2
33851: PPUSH
33852: LD_EXP 91
33856: PUSH
33857: LD_VAR 0 2
33861: ARRAY
33862: PUSH
33863: LD_VAR 0 3
33867: DIFF
33868: PPUSH
33869: CALL_OW 1
33873: ST_TO_ADDR
// SetTag ( j , 0 ) ;
33874: LD_VAR 0 3
33878: PPUSH
33879: LD_INT 0
33881: PPUSH
33882: CALL_OW 109
// continue ;
33886: GO 33783
// end ; if IsInUnit ( j ) then
33888: LD_VAR 0 3
33892: PPUSH
33893: CALL_OW 310
33897: IFFALSE 33908
// ComExitBuilding ( j ) ;
33899: LD_VAR 0 3
33903: PPUSH
33904: CALL_OW 122
// wait ( 3 ) ;
33908: LD_INT 3
33910: PPUSH
33911: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33915: LD_VAR 0 3
33919: PPUSH
33920: LD_VAR 0 6
33924: PUSH
33925: LD_INT 2
33927: ARRAY
33928: PPUSH
33929: LD_VAR 0 6
33933: PUSH
33934: LD_INT 3
33936: ARRAY
33937: PPUSH
33938: CALL_OW 117
// end ;
33942: GO 33783
33944: POP
33945: POP
// end ; end else
33946: GO 34527
// begin for j in cargo do
33948: LD_ADDR_VAR 0 3
33952: PUSH
33953: LD_VAR 0 7
33957: PUSH
33958: FOR_IN
33959: IFFALSE 34525
// begin if GetTag ( j ) <> 0 then
33961: LD_VAR 0 3
33965: PPUSH
33966: CALL_OW 110
33970: PUSH
33971: LD_INT 0
33973: NONEQUAL
33974: IFFALSE 33978
// continue ;
33976: GO 33958
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33978: LD_VAR 0 3
33982: PPUSH
33983: CALL_OW 256
33987: PUSH
33988: LD_INT 1000
33990: LESS
33991: PUSH
33992: LD_VAR 0 3
33996: PPUSH
33997: LD_EXP 98
34001: PUSH
34002: LD_VAR 0 2
34006: ARRAY
34007: PPUSH
34008: CALL_OW 308
34012: NOT
34013: AND
34014: IFFALSE 34036
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34016: LD_VAR 0 3
34020: PPUSH
34021: LD_EXP 98
34025: PUSH
34026: LD_VAR 0 2
34030: ARRAY
34031: PPUSH
34032: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34036: LD_VAR 0 3
34040: PPUSH
34041: CALL_OW 256
34045: PUSH
34046: LD_INT 1000
34048: LESS
34049: PUSH
34050: LD_VAR 0 3
34054: PPUSH
34055: LD_EXP 98
34059: PUSH
34060: LD_VAR 0 2
34064: ARRAY
34065: PPUSH
34066: CALL_OW 308
34070: AND
34071: IFFALSE 34075
// continue ;
34073: GO 33958
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34075: LD_VAR 0 3
34079: PPUSH
34080: CALL_OW 262
34084: PUSH
34085: LD_INT 2
34087: EQUAL
34088: PUSH
34089: LD_VAR 0 3
34093: PPUSH
34094: CALL_OW 261
34098: PUSH
34099: LD_INT 15
34101: LESS
34102: AND
34103: IFFALSE 34107
// continue ;
34105: GO 33958
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34107: LD_VAR 0 3
34111: PPUSH
34112: CALL_OW 262
34116: PUSH
34117: LD_INT 1
34119: EQUAL
34120: PUSH
34121: LD_VAR 0 3
34125: PPUSH
34126: CALL_OW 261
34130: PUSH
34131: LD_INT 10
34133: LESS
34134: AND
34135: IFFALSE 34464
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34137: LD_ADDR_VAR 0 8
34141: PUSH
34142: LD_EXP 74
34146: PUSH
34147: LD_VAR 0 2
34151: ARRAY
34152: PPUSH
34153: LD_INT 2
34155: PUSH
34156: LD_INT 30
34158: PUSH
34159: LD_INT 0
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 30
34168: PUSH
34169: LD_INT 1
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: LIST
34180: PPUSH
34181: CALL_OW 72
34185: ST_TO_ADDR
// if not depot then
34186: LD_VAR 0 8
34190: NOT
34191: IFFALSE 34195
// continue ;
34193: GO 33958
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34195: LD_VAR 0 3
34199: PPUSH
34200: LD_VAR 0 8
34204: PPUSH
34205: LD_VAR 0 3
34209: PPUSH
34210: CALL_OW 74
34214: PPUSH
34215: CALL_OW 296
34219: PUSH
34220: LD_INT 6
34222: LESS
34223: IFFALSE 34239
// SetFuel ( j , 100 ) else
34225: LD_VAR 0 3
34229: PPUSH
34230: LD_INT 100
34232: PPUSH
34233: CALL_OW 240
34237: GO 34464
// if GetFuel ( j ) = 0 then
34239: LD_VAR 0 3
34243: PPUSH
34244: CALL_OW 261
34248: PUSH
34249: LD_INT 0
34251: EQUAL
34252: IFFALSE 34464
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34254: LD_ADDR_EXP 93
34258: PUSH
34259: LD_EXP 93
34263: PPUSH
34264: LD_VAR 0 2
34268: PPUSH
34269: LD_EXP 93
34273: PUSH
34274: LD_VAR 0 2
34278: ARRAY
34279: PUSH
34280: LD_VAR 0 3
34284: DIFF
34285: PPUSH
34286: CALL_OW 1
34290: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34291: LD_VAR 0 3
34295: PPUSH
34296: CALL_OW 263
34300: PUSH
34301: LD_INT 1
34303: EQUAL
34304: IFFALSE 34320
// ComExitVehicle ( IsInUnit ( j ) ) ;
34306: LD_VAR 0 3
34310: PPUSH
34311: CALL_OW 310
34315: PPUSH
34316: CALL_OW 121
// if GetControl ( j ) = control_remote then
34320: LD_VAR 0 3
34324: PPUSH
34325: CALL_OW 263
34329: PUSH
34330: LD_INT 2
34332: EQUAL
34333: IFFALSE 34344
// ComUnlink ( j ) ;
34335: LD_VAR 0 3
34339: PPUSH
34340: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
34344: LD_ADDR_VAR 0 9
34348: PUSH
34349: LD_VAR 0 2
34353: PPUSH
34354: LD_INT 3
34356: PPUSH
34357: CALL 43601 0 2
34361: ST_TO_ADDR
// if fac then
34362: LD_VAR 0 9
34366: IFFALSE 34462
// begin for k in fac do
34368: LD_ADDR_VAR 0 4
34372: PUSH
34373: LD_VAR 0 9
34377: PUSH
34378: FOR_IN
34379: IFFALSE 34460
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
34381: LD_ADDR_VAR 0 10
34385: PUSH
34386: LD_VAR 0 9
34390: PPUSH
34391: LD_VAR 0 3
34395: PPUSH
34396: CALL_OW 265
34400: PPUSH
34401: LD_VAR 0 3
34405: PPUSH
34406: CALL_OW 262
34410: PPUSH
34411: LD_VAR 0 3
34415: PPUSH
34416: CALL_OW 263
34420: PPUSH
34421: LD_VAR 0 3
34425: PPUSH
34426: CALL_OW 264
34430: PPUSH
34431: CALL 53761 0 5
34435: ST_TO_ADDR
// if components then
34436: LD_VAR 0 10
34440: IFFALSE 34458
// begin MC_InsertProduceList ( i , components ) ;
34442: LD_VAR 0 2
34446: PPUSH
34447: LD_VAR 0 10
34451: PPUSH
34452: CALL 43146 0 2
// break ;
34456: GO 34460
// end ; end ;
34458: GO 34378
34460: POP
34461: POP
// end ; continue ;
34462: GO 33958
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
34464: LD_VAR 0 3
34468: PPUSH
34469: LD_INT 1
34471: PPUSH
34472: CALL_OW 289
34476: PUSH
34477: LD_INT 100
34479: LESS
34480: PUSH
34481: LD_VAR 0 3
34485: PPUSH
34486: CALL_OW 314
34490: NOT
34491: AND
34492: IFFALSE 34521
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34494: LD_VAR 0 3
34498: PPUSH
34499: LD_VAR 0 6
34503: PUSH
34504: LD_INT 2
34506: ARRAY
34507: PPUSH
34508: LD_VAR 0 6
34512: PUSH
34513: LD_INT 3
34515: ARRAY
34516: PPUSH
34517: CALL_OW 117
// break ;
34521: GO 34525
// end ;
34523: GO 33958
34525: POP
34526: POP
// end ; end ;
34527: GO 32796
34529: POP
34530: POP
// end ;
34531: LD_VAR 0 1
34535: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
34536: LD_INT 0
34538: PPUSH
34539: PPUSH
34540: PPUSH
34541: PPUSH
// if not mc_bases then
34542: LD_EXP 74
34546: NOT
34547: IFFALSE 34551
// exit ;
34549: GO 34712
// for i = 1 to mc_bases do
34551: LD_ADDR_VAR 0 2
34555: PUSH
34556: DOUBLE
34557: LD_INT 1
34559: DEC
34560: ST_TO_ADDR
34561: LD_EXP 74
34565: PUSH
34566: FOR_TO
34567: IFFALSE 34710
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
34569: LD_ADDR_VAR 0 4
34573: PUSH
34574: LD_EXP 93
34578: PUSH
34579: LD_VAR 0 2
34583: ARRAY
34584: PUSH
34585: LD_EXP 96
34589: PUSH
34590: LD_VAR 0 2
34594: ARRAY
34595: UNION
34596: PPUSH
34597: LD_INT 33
34599: PUSH
34600: LD_INT 2
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PPUSH
34607: CALL_OW 72
34611: ST_TO_ADDR
// if tmp then
34612: LD_VAR 0 4
34616: IFFALSE 34708
// for j in tmp do
34618: LD_ADDR_VAR 0 3
34622: PUSH
34623: LD_VAR 0 4
34627: PUSH
34628: FOR_IN
34629: IFFALSE 34706
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
34631: LD_VAR 0 3
34635: PPUSH
34636: CALL_OW 312
34640: NOT
34641: PUSH
34642: LD_VAR 0 3
34646: PPUSH
34647: CALL_OW 256
34651: PUSH
34652: LD_INT 250
34654: GREATEREQUAL
34655: AND
34656: IFFALSE 34669
// Connect ( j ) else
34658: LD_VAR 0 3
34662: PPUSH
34663: CALL 59162 0 1
34667: GO 34704
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
34669: LD_VAR 0 3
34673: PPUSH
34674: CALL_OW 256
34678: PUSH
34679: LD_INT 250
34681: LESS
34682: PUSH
34683: LD_VAR 0 3
34687: PPUSH
34688: CALL_OW 312
34692: AND
34693: IFFALSE 34704
// ComUnlink ( j ) ;
34695: LD_VAR 0 3
34699: PPUSH
34700: CALL_OW 136
34704: GO 34628
34706: POP
34707: POP
// end ;
34708: GO 34566
34710: POP
34711: POP
// end ;
34712: LD_VAR 0 1
34716: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
34717: LD_INT 0
34719: PPUSH
34720: PPUSH
34721: PPUSH
34722: PPUSH
34723: PPUSH
// if not mc_bases then
34724: LD_EXP 74
34728: NOT
34729: IFFALSE 34733
// exit ;
34731: GO 35178
// for i = 1 to mc_bases do
34733: LD_ADDR_VAR 0 2
34737: PUSH
34738: DOUBLE
34739: LD_INT 1
34741: DEC
34742: ST_TO_ADDR
34743: LD_EXP 74
34747: PUSH
34748: FOR_TO
34749: IFFALSE 35176
// begin if not mc_produce [ i ] then
34751: LD_EXP 95
34755: PUSH
34756: LD_VAR 0 2
34760: ARRAY
34761: NOT
34762: IFFALSE 34766
// continue ;
34764: GO 34748
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34766: LD_ADDR_VAR 0 5
34770: PUSH
34771: LD_EXP 74
34775: PUSH
34776: LD_VAR 0 2
34780: ARRAY
34781: PPUSH
34782: LD_INT 30
34784: PUSH
34785: LD_INT 3
34787: PUSH
34788: EMPTY
34789: LIST
34790: LIST
34791: PPUSH
34792: CALL_OW 72
34796: ST_TO_ADDR
// if not fac then
34797: LD_VAR 0 5
34801: NOT
34802: IFFALSE 34806
// continue ;
34804: GO 34748
// for j in fac do
34806: LD_ADDR_VAR 0 3
34810: PUSH
34811: LD_VAR 0 5
34815: PUSH
34816: FOR_IN
34817: IFFALSE 35172
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
34819: LD_VAR 0 3
34823: PPUSH
34824: CALL_OW 461
34828: PUSH
34829: LD_INT 2
34831: NONEQUAL
34832: PUSH
34833: LD_VAR 0 3
34837: PPUSH
34838: LD_INT 15
34840: PPUSH
34841: CALL 58822 0 2
34845: PUSH
34846: LD_INT 4
34848: ARRAY
34849: OR
34850: IFFALSE 34854
// continue ;
34852: GO 34816
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
34854: LD_VAR 0 3
34858: PPUSH
34859: LD_EXP 95
34863: PUSH
34864: LD_VAR 0 2
34868: ARRAY
34869: PUSH
34870: LD_INT 1
34872: ARRAY
34873: PUSH
34874: LD_INT 1
34876: ARRAY
34877: PPUSH
34878: LD_EXP 95
34882: PUSH
34883: LD_VAR 0 2
34887: ARRAY
34888: PUSH
34889: LD_INT 1
34891: ARRAY
34892: PUSH
34893: LD_INT 2
34895: ARRAY
34896: PPUSH
34897: LD_EXP 95
34901: PUSH
34902: LD_VAR 0 2
34906: ARRAY
34907: PUSH
34908: LD_INT 1
34910: ARRAY
34911: PUSH
34912: LD_INT 3
34914: ARRAY
34915: PPUSH
34916: LD_EXP 95
34920: PUSH
34921: LD_VAR 0 2
34925: ARRAY
34926: PUSH
34927: LD_INT 1
34929: ARRAY
34930: PUSH
34931: LD_INT 4
34933: ARRAY
34934: PPUSH
34935: CALL_OW 448
34939: PUSH
34940: LD_VAR 0 3
34944: PPUSH
34945: LD_EXP 95
34949: PUSH
34950: LD_VAR 0 2
34954: ARRAY
34955: PUSH
34956: LD_INT 1
34958: ARRAY
34959: PUSH
34960: LD_INT 1
34962: ARRAY
34963: PUSH
34964: LD_EXP 95
34968: PUSH
34969: LD_VAR 0 2
34973: ARRAY
34974: PUSH
34975: LD_INT 1
34977: ARRAY
34978: PUSH
34979: LD_INT 2
34981: ARRAY
34982: PUSH
34983: LD_EXP 95
34987: PUSH
34988: LD_VAR 0 2
34992: ARRAY
34993: PUSH
34994: LD_INT 1
34996: ARRAY
34997: PUSH
34998: LD_INT 3
35000: ARRAY
35001: PUSH
35002: LD_EXP 95
35006: PUSH
35007: LD_VAR 0 2
35011: ARRAY
35012: PUSH
35013: LD_INT 1
35015: ARRAY
35016: PUSH
35017: LD_INT 4
35019: ARRAY
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: LIST
35025: LIST
35026: PPUSH
35027: CALL 62493 0 2
35031: AND
35032: IFFALSE 35170
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35034: LD_VAR 0 3
35038: PPUSH
35039: LD_EXP 95
35043: PUSH
35044: LD_VAR 0 2
35048: ARRAY
35049: PUSH
35050: LD_INT 1
35052: ARRAY
35053: PUSH
35054: LD_INT 1
35056: ARRAY
35057: PPUSH
35058: LD_EXP 95
35062: PUSH
35063: LD_VAR 0 2
35067: ARRAY
35068: PUSH
35069: LD_INT 1
35071: ARRAY
35072: PUSH
35073: LD_INT 2
35075: ARRAY
35076: PPUSH
35077: LD_EXP 95
35081: PUSH
35082: LD_VAR 0 2
35086: ARRAY
35087: PUSH
35088: LD_INT 1
35090: ARRAY
35091: PUSH
35092: LD_INT 3
35094: ARRAY
35095: PPUSH
35096: LD_EXP 95
35100: PUSH
35101: LD_VAR 0 2
35105: ARRAY
35106: PUSH
35107: LD_INT 1
35109: ARRAY
35110: PUSH
35111: LD_INT 4
35113: ARRAY
35114: PPUSH
35115: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35119: LD_ADDR_VAR 0 4
35123: PUSH
35124: LD_EXP 95
35128: PUSH
35129: LD_VAR 0 2
35133: ARRAY
35134: PPUSH
35135: LD_INT 1
35137: PPUSH
35138: CALL_OW 3
35142: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35143: LD_ADDR_EXP 95
35147: PUSH
35148: LD_EXP 95
35152: PPUSH
35153: LD_VAR 0 2
35157: PPUSH
35158: LD_VAR 0 4
35162: PPUSH
35163: CALL_OW 1
35167: ST_TO_ADDR
// break ;
35168: GO 35172
// end ; end ;
35170: GO 34816
35172: POP
35173: POP
// end ;
35174: GO 34748
35176: POP
35177: POP
// end ;
35178: LD_VAR 0 1
35182: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35183: LD_INT 0
35185: PPUSH
35186: PPUSH
35187: PPUSH
// if not mc_bases then
35188: LD_EXP 74
35192: NOT
35193: IFFALSE 35197
// exit ;
35195: GO 35286
// for i = 1 to mc_bases do
35197: LD_ADDR_VAR 0 2
35201: PUSH
35202: DOUBLE
35203: LD_INT 1
35205: DEC
35206: ST_TO_ADDR
35207: LD_EXP 74
35211: PUSH
35212: FOR_TO
35213: IFFALSE 35284
// begin if mc_attack [ i ] then
35215: LD_EXP 94
35219: PUSH
35220: LD_VAR 0 2
35224: ARRAY
35225: IFFALSE 35282
// begin tmp := mc_attack [ i ] [ 1 ] ;
35227: LD_ADDR_VAR 0 3
35231: PUSH
35232: LD_EXP 94
35236: PUSH
35237: LD_VAR 0 2
35241: ARRAY
35242: PUSH
35243: LD_INT 1
35245: ARRAY
35246: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35247: LD_ADDR_EXP 94
35251: PUSH
35252: LD_EXP 94
35256: PPUSH
35257: LD_VAR 0 2
35261: PPUSH
35262: EMPTY
35263: PPUSH
35264: CALL_OW 1
35268: ST_TO_ADDR
// Attack ( tmp ) ;
35269: LD_VAR 0 3
35273: PPUSH
35274: CALL 84706 0 1
// exit ;
35278: POP
35279: POP
35280: GO 35286
// end ; end ;
35282: GO 35212
35284: POP
35285: POP
// end ;
35286: LD_VAR 0 1
35290: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35291: LD_INT 0
35293: PPUSH
35294: PPUSH
35295: PPUSH
35296: PPUSH
35297: PPUSH
35298: PPUSH
35299: PPUSH
// if not mc_bases then
35300: LD_EXP 74
35304: NOT
35305: IFFALSE 35309
// exit ;
35307: GO 35891
// for i = 1 to mc_bases do
35309: LD_ADDR_VAR 0 2
35313: PUSH
35314: DOUBLE
35315: LD_INT 1
35317: DEC
35318: ST_TO_ADDR
35319: LD_EXP 74
35323: PUSH
35324: FOR_TO
35325: IFFALSE 35889
// begin if not mc_bases [ i ] then
35327: LD_EXP 74
35331: PUSH
35332: LD_VAR 0 2
35336: ARRAY
35337: NOT
35338: IFFALSE 35342
// continue ;
35340: GO 35324
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
35342: LD_ADDR_VAR 0 7
35346: PUSH
35347: LD_EXP 74
35351: PUSH
35352: LD_VAR 0 2
35356: ARRAY
35357: PUSH
35358: LD_INT 1
35360: ARRAY
35361: PPUSH
35362: CALL 53065 0 1
35366: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
35367: LD_ADDR_EXP 97
35371: PUSH
35372: LD_EXP 97
35376: PPUSH
35377: LD_VAR 0 2
35381: PPUSH
35382: LD_EXP 74
35386: PUSH
35387: LD_VAR 0 2
35391: ARRAY
35392: PUSH
35393: LD_INT 1
35395: ARRAY
35396: PPUSH
35397: CALL_OW 255
35401: PPUSH
35402: LD_EXP 99
35406: PUSH
35407: LD_VAR 0 2
35411: ARRAY
35412: PPUSH
35413: CALL 50983 0 2
35417: PPUSH
35418: CALL_OW 1
35422: ST_TO_ADDR
// if not mc_scan [ i ] then
35423: LD_EXP 97
35427: PUSH
35428: LD_VAR 0 2
35432: ARRAY
35433: NOT
35434: IFFALSE 35589
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35436: LD_ADDR_VAR 0 4
35440: PUSH
35441: LD_EXP 74
35445: PUSH
35446: LD_VAR 0 2
35450: ARRAY
35451: PPUSH
35452: LD_INT 2
35454: PUSH
35455: LD_INT 25
35457: PUSH
35458: LD_INT 5
35460: PUSH
35461: EMPTY
35462: LIST
35463: LIST
35464: PUSH
35465: LD_INT 25
35467: PUSH
35468: LD_INT 8
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 25
35477: PUSH
35478: LD_INT 9
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: PPUSH
35491: CALL_OW 72
35495: ST_TO_ADDR
// if not tmp then
35496: LD_VAR 0 4
35500: NOT
35501: IFFALSE 35505
// continue ;
35503: GO 35324
// for j in tmp do
35505: LD_ADDR_VAR 0 3
35509: PUSH
35510: LD_VAR 0 4
35514: PUSH
35515: FOR_IN
35516: IFFALSE 35587
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
35518: LD_VAR 0 3
35522: PPUSH
35523: CALL_OW 310
35527: PPUSH
35528: CALL_OW 266
35532: PUSH
35533: LD_INT 5
35535: EQUAL
35536: PUSH
35537: LD_VAR 0 3
35541: PPUSH
35542: CALL_OW 257
35546: PUSH
35547: LD_INT 1
35549: EQUAL
35550: AND
35551: PUSH
35552: LD_VAR 0 3
35556: PPUSH
35557: CALL_OW 459
35561: NOT
35562: AND
35563: PUSH
35564: LD_VAR 0 7
35568: AND
35569: IFFALSE 35585
// ComChangeProfession ( j , class ) ;
35571: LD_VAR 0 3
35575: PPUSH
35576: LD_VAR 0 7
35580: PPUSH
35581: CALL_OW 123
35585: GO 35515
35587: POP
35588: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
35589: LD_EXP 97
35593: PUSH
35594: LD_VAR 0 2
35598: ARRAY
35599: PUSH
35600: LD_EXP 96
35604: PUSH
35605: LD_VAR 0 2
35609: ARRAY
35610: NOT
35611: AND
35612: PUSH
35613: LD_EXP 74
35617: PUSH
35618: LD_VAR 0 2
35622: ARRAY
35623: PPUSH
35624: LD_INT 30
35626: PUSH
35627: LD_INT 32
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PPUSH
35634: CALL_OW 72
35638: NOT
35639: AND
35640: PUSH
35641: LD_EXP 74
35645: PUSH
35646: LD_VAR 0 2
35650: ARRAY
35651: PPUSH
35652: LD_INT 2
35654: PUSH
35655: LD_INT 30
35657: PUSH
35658: LD_INT 4
35660: PUSH
35661: EMPTY
35662: LIST
35663: LIST
35664: PUSH
35665: LD_INT 30
35667: PUSH
35668: LD_INT 5
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: LIST
35679: PPUSH
35680: CALL_OW 72
35684: NOT
35685: AND
35686: IFFALSE 35818
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35688: LD_ADDR_VAR 0 4
35692: PUSH
35693: LD_EXP 74
35697: PUSH
35698: LD_VAR 0 2
35702: ARRAY
35703: PPUSH
35704: LD_INT 2
35706: PUSH
35707: LD_INT 25
35709: PUSH
35710: LD_INT 1
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: LD_INT 25
35719: PUSH
35720: LD_INT 5
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: LD_INT 25
35729: PUSH
35730: LD_INT 8
35732: PUSH
35733: EMPTY
35734: LIST
35735: LIST
35736: PUSH
35737: LD_INT 25
35739: PUSH
35740: LD_INT 9
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: LIST
35753: PPUSH
35754: CALL_OW 72
35758: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
35759: LD_ADDR_VAR 0 4
35763: PUSH
35764: LD_VAR 0 4
35768: PUSH
35769: LD_VAR 0 4
35773: PPUSH
35774: LD_INT 18
35776: PPUSH
35777: CALL 89489 0 2
35781: DIFF
35782: ST_TO_ADDR
// if tmp then
35783: LD_VAR 0 4
35787: IFFALSE 35818
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
35789: LD_VAR 0 2
35793: PPUSH
35794: LD_VAR 0 4
35798: PPUSH
35799: LD_EXP 99
35803: PUSH
35804: LD_VAR 0 2
35808: ARRAY
35809: PPUSH
35810: CALL 51018 0 3
// exit ;
35814: POP
35815: POP
35816: GO 35891
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
35818: LD_EXP 97
35822: PUSH
35823: LD_VAR 0 2
35827: ARRAY
35828: PUSH
35829: LD_EXP 96
35833: PUSH
35834: LD_VAR 0 2
35838: ARRAY
35839: AND
35840: IFFALSE 35887
// begin tmp := mc_defender [ i ] ;
35842: LD_ADDR_VAR 0 4
35846: PUSH
35847: LD_EXP 96
35851: PUSH
35852: LD_VAR 0 2
35856: ARRAY
35857: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
35858: LD_VAR 0 2
35862: PPUSH
35863: LD_VAR 0 4
35867: PPUSH
35868: LD_EXP 97
35872: PUSH
35873: LD_VAR 0 2
35877: ARRAY
35878: PPUSH
35879: CALL 51516 0 3
// exit ;
35883: POP
35884: POP
35885: GO 35891
// end ; end ;
35887: GO 35324
35889: POP
35890: POP
// end ;
35891: LD_VAR 0 1
35895: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35896: LD_INT 0
35898: PPUSH
35899: PPUSH
35900: PPUSH
35901: PPUSH
35902: PPUSH
35903: PPUSH
35904: PPUSH
35905: PPUSH
35906: PPUSH
35907: PPUSH
35908: PPUSH
// if not mc_bases then
35909: LD_EXP 74
35913: NOT
35914: IFFALSE 35918
// exit ;
35916: GO 37005
// for i = 1 to mc_bases do
35918: LD_ADDR_VAR 0 2
35922: PUSH
35923: DOUBLE
35924: LD_INT 1
35926: DEC
35927: ST_TO_ADDR
35928: LD_EXP 74
35932: PUSH
35933: FOR_TO
35934: IFFALSE 37003
// begin tmp := mc_lab [ i ] ;
35936: LD_ADDR_VAR 0 6
35940: PUSH
35941: LD_EXP 107
35945: PUSH
35946: LD_VAR 0 2
35950: ARRAY
35951: ST_TO_ADDR
// if not tmp then
35952: LD_VAR 0 6
35956: NOT
35957: IFFALSE 35961
// continue ;
35959: GO 35933
// idle_lab := 0 ;
35961: LD_ADDR_VAR 0 11
35965: PUSH
35966: LD_INT 0
35968: ST_TO_ADDR
// for j in tmp do
35969: LD_ADDR_VAR 0 3
35973: PUSH
35974: LD_VAR 0 6
35978: PUSH
35979: FOR_IN
35980: IFFALSE 36999
// begin researching := false ;
35982: LD_ADDR_VAR 0 10
35986: PUSH
35987: LD_INT 0
35989: ST_TO_ADDR
// side := GetSide ( j ) ;
35990: LD_ADDR_VAR 0 4
35994: PUSH
35995: LD_VAR 0 3
35999: PPUSH
36000: CALL_OW 255
36004: ST_TO_ADDR
// if not mc_tech [ side ] then
36005: LD_EXP 101
36009: PUSH
36010: LD_VAR 0 4
36014: ARRAY
36015: NOT
36016: IFFALSE 36020
// continue ;
36018: GO 35979
// if BuildingStatus ( j ) = bs_idle then
36020: LD_VAR 0 3
36024: PPUSH
36025: CALL_OW 461
36029: PUSH
36030: LD_INT 2
36032: EQUAL
36033: IFFALSE 36221
// begin if idle_lab and UnitsInside ( j ) < 6 then
36035: LD_VAR 0 11
36039: PUSH
36040: LD_VAR 0 3
36044: PPUSH
36045: CALL_OW 313
36049: PUSH
36050: LD_INT 6
36052: LESS
36053: AND
36054: IFFALSE 36125
// begin tmp2 := UnitsInside ( idle_lab ) ;
36056: LD_ADDR_VAR 0 9
36060: PUSH
36061: LD_VAR 0 11
36065: PPUSH
36066: CALL_OW 313
36070: ST_TO_ADDR
// if tmp2 then
36071: LD_VAR 0 9
36075: IFFALSE 36117
// for x in tmp2 do
36077: LD_ADDR_VAR 0 7
36081: PUSH
36082: LD_VAR 0 9
36086: PUSH
36087: FOR_IN
36088: IFFALSE 36115
// begin ComExitBuilding ( x ) ;
36090: LD_VAR 0 7
36094: PPUSH
36095: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36099: LD_VAR 0 7
36103: PPUSH
36104: LD_VAR 0 3
36108: PPUSH
36109: CALL_OW 180
// end ;
36113: GO 36087
36115: POP
36116: POP
// idle_lab := 0 ;
36117: LD_ADDR_VAR 0 11
36121: PUSH
36122: LD_INT 0
36124: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36125: LD_ADDR_VAR 0 5
36129: PUSH
36130: LD_EXP 101
36134: PUSH
36135: LD_VAR 0 4
36139: ARRAY
36140: PUSH
36141: FOR_IN
36142: IFFALSE 36202
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36144: LD_VAR 0 3
36148: PPUSH
36149: LD_VAR 0 5
36153: PPUSH
36154: CALL_OW 430
36158: PUSH
36159: LD_VAR 0 4
36163: PPUSH
36164: LD_VAR 0 5
36168: PPUSH
36169: CALL 50088 0 2
36173: AND
36174: IFFALSE 36200
// begin researching := true ;
36176: LD_ADDR_VAR 0 10
36180: PUSH
36181: LD_INT 1
36183: ST_TO_ADDR
// ComResearch ( j , t ) ;
36184: LD_VAR 0 3
36188: PPUSH
36189: LD_VAR 0 5
36193: PPUSH
36194: CALL_OW 124
// break ;
36198: GO 36202
// end ;
36200: GO 36141
36202: POP
36203: POP
// if not researching then
36204: LD_VAR 0 10
36208: NOT
36209: IFFALSE 36221
// idle_lab := j ;
36211: LD_ADDR_VAR 0 11
36215: PUSH
36216: LD_VAR 0 3
36220: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36221: LD_VAR 0 3
36225: PPUSH
36226: CALL_OW 461
36230: PUSH
36231: LD_INT 10
36233: EQUAL
36234: IFFALSE 36822
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36236: LD_EXP 103
36240: PUSH
36241: LD_VAR 0 2
36245: ARRAY
36246: NOT
36247: PUSH
36248: LD_EXP 104
36252: PUSH
36253: LD_VAR 0 2
36257: ARRAY
36258: NOT
36259: AND
36260: PUSH
36261: LD_EXP 101
36265: PUSH
36266: LD_VAR 0 4
36270: ARRAY
36271: PUSH
36272: LD_INT 1
36274: GREATER
36275: AND
36276: IFFALSE 36407
// begin ComCancel ( j ) ;
36278: LD_VAR 0 3
36282: PPUSH
36283: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36287: LD_ADDR_EXP 101
36291: PUSH
36292: LD_EXP 101
36296: PPUSH
36297: LD_VAR 0 4
36301: PPUSH
36302: LD_EXP 101
36306: PUSH
36307: LD_VAR 0 4
36311: ARRAY
36312: PPUSH
36313: LD_EXP 101
36317: PUSH
36318: LD_VAR 0 4
36322: ARRAY
36323: PUSH
36324: LD_INT 1
36326: MINUS
36327: PPUSH
36328: LD_EXP 101
36332: PUSH
36333: LD_VAR 0 4
36337: ARRAY
36338: PPUSH
36339: LD_INT 0
36341: PPUSH
36342: CALL 55647 0 4
36346: PPUSH
36347: CALL_OW 1
36351: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
36352: LD_ADDR_EXP 101
36356: PUSH
36357: LD_EXP 101
36361: PPUSH
36362: LD_VAR 0 4
36366: PPUSH
36367: LD_EXP 101
36371: PUSH
36372: LD_VAR 0 4
36376: ARRAY
36377: PPUSH
36378: LD_EXP 101
36382: PUSH
36383: LD_VAR 0 4
36387: ARRAY
36388: PPUSH
36389: LD_INT 1
36391: PPUSH
36392: LD_INT 0
36394: PPUSH
36395: CALL 55647 0 4
36399: PPUSH
36400: CALL_OW 1
36404: ST_TO_ADDR
// continue ;
36405: GO 35979
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
36407: LD_EXP 103
36411: PUSH
36412: LD_VAR 0 2
36416: ARRAY
36417: PUSH
36418: LD_EXP 104
36422: PUSH
36423: LD_VAR 0 2
36427: ARRAY
36428: NOT
36429: AND
36430: IFFALSE 36557
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
36432: LD_ADDR_EXP 104
36436: PUSH
36437: LD_EXP 104
36441: PPUSH
36442: LD_VAR 0 2
36446: PUSH
36447: LD_EXP 104
36451: PUSH
36452: LD_VAR 0 2
36456: ARRAY
36457: PUSH
36458: LD_INT 1
36460: PLUS
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PPUSH
36466: LD_EXP 103
36470: PUSH
36471: LD_VAR 0 2
36475: ARRAY
36476: PUSH
36477: LD_INT 1
36479: ARRAY
36480: PPUSH
36481: CALL 56229 0 3
36485: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
36486: LD_EXP 103
36490: PUSH
36491: LD_VAR 0 2
36495: ARRAY
36496: PUSH
36497: LD_INT 1
36499: ARRAY
36500: PPUSH
36501: LD_INT 112
36503: PPUSH
36504: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
36508: LD_ADDR_VAR 0 9
36512: PUSH
36513: LD_EXP 103
36517: PUSH
36518: LD_VAR 0 2
36522: ARRAY
36523: PPUSH
36524: LD_INT 1
36526: PPUSH
36527: CALL_OW 3
36531: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
36532: LD_ADDR_EXP 103
36536: PUSH
36537: LD_EXP 103
36541: PPUSH
36542: LD_VAR 0 2
36546: PPUSH
36547: LD_VAR 0 9
36551: PPUSH
36552: CALL_OW 1
36556: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
36557: LD_EXP 103
36561: PUSH
36562: LD_VAR 0 2
36566: ARRAY
36567: PUSH
36568: LD_EXP 104
36572: PUSH
36573: LD_VAR 0 2
36577: ARRAY
36578: AND
36579: PUSH
36580: LD_EXP 104
36584: PUSH
36585: LD_VAR 0 2
36589: ARRAY
36590: PUSH
36591: LD_INT 1
36593: ARRAY
36594: PPUSH
36595: CALL_OW 310
36599: NOT
36600: AND
36601: PUSH
36602: LD_VAR 0 3
36606: PPUSH
36607: CALL_OW 313
36611: PUSH
36612: LD_INT 6
36614: EQUAL
36615: AND
36616: IFFALSE 36672
// begin tmp2 := UnitsInside ( j ) ;
36618: LD_ADDR_VAR 0 9
36622: PUSH
36623: LD_VAR 0 3
36627: PPUSH
36628: CALL_OW 313
36632: ST_TO_ADDR
// if tmp2 = 6 then
36633: LD_VAR 0 9
36637: PUSH
36638: LD_INT 6
36640: EQUAL
36641: IFFALSE 36672
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
36643: LD_VAR 0 9
36647: PUSH
36648: LD_INT 1
36650: ARRAY
36651: PPUSH
36652: LD_INT 112
36654: PPUSH
36655: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
36659: LD_VAR 0 9
36663: PUSH
36664: LD_INT 1
36666: ARRAY
36667: PPUSH
36668: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
36672: LD_EXP 104
36676: PUSH
36677: LD_VAR 0 2
36681: ARRAY
36682: PUSH
36683: LD_EXP 104
36687: PUSH
36688: LD_VAR 0 2
36692: ARRAY
36693: PUSH
36694: LD_INT 1
36696: ARRAY
36697: PPUSH
36698: CALL_OW 314
36702: NOT
36703: AND
36704: PUSH
36705: LD_EXP 104
36709: PUSH
36710: LD_VAR 0 2
36714: ARRAY
36715: PUSH
36716: LD_INT 1
36718: ARRAY
36719: PPUSH
36720: CALL_OW 310
36724: NOT
36725: AND
36726: IFFALSE 36752
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36728: LD_EXP 104
36732: PUSH
36733: LD_VAR 0 2
36737: ARRAY
36738: PUSH
36739: LD_INT 1
36741: ARRAY
36742: PPUSH
36743: LD_VAR 0 3
36747: PPUSH
36748: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36752: LD_EXP 104
36756: PUSH
36757: LD_VAR 0 2
36761: ARRAY
36762: PUSH
36763: LD_INT 1
36765: ARRAY
36766: PPUSH
36767: CALL_OW 310
36771: PUSH
36772: LD_EXP 104
36776: PUSH
36777: LD_VAR 0 2
36781: ARRAY
36782: PUSH
36783: LD_INT 1
36785: ARRAY
36786: PPUSH
36787: CALL_OW 310
36791: PPUSH
36792: CALL_OW 461
36796: PUSH
36797: LD_INT 3
36799: NONEQUAL
36800: AND
36801: IFFALSE 36822
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36803: LD_EXP 104
36807: PUSH
36808: LD_VAR 0 2
36812: ARRAY
36813: PUSH
36814: LD_INT 1
36816: ARRAY
36817: PPUSH
36818: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36822: LD_VAR 0 3
36826: PPUSH
36827: CALL_OW 461
36831: PUSH
36832: LD_INT 6
36834: EQUAL
36835: PUSH
36836: LD_VAR 0 6
36840: PUSH
36841: LD_INT 1
36843: GREATER
36844: AND
36845: IFFALSE 36997
// begin sci := [ ] ;
36847: LD_ADDR_VAR 0 8
36851: PUSH
36852: EMPTY
36853: ST_TO_ADDR
// for x in ( tmp diff j ) do
36854: LD_ADDR_VAR 0 7
36858: PUSH
36859: LD_VAR 0 6
36863: PUSH
36864: LD_VAR 0 3
36868: DIFF
36869: PUSH
36870: FOR_IN
36871: IFFALSE 36923
// begin if sci = 6 then
36873: LD_VAR 0 8
36877: PUSH
36878: LD_INT 6
36880: EQUAL
36881: IFFALSE 36885
// break ;
36883: GO 36923
// if BuildingStatus ( x ) = bs_idle then
36885: LD_VAR 0 7
36889: PPUSH
36890: CALL_OW 461
36894: PUSH
36895: LD_INT 2
36897: EQUAL
36898: IFFALSE 36921
// sci := sci ^ UnitsInside ( x ) ;
36900: LD_ADDR_VAR 0 8
36904: PUSH
36905: LD_VAR 0 8
36909: PUSH
36910: LD_VAR 0 7
36914: PPUSH
36915: CALL_OW 313
36919: ADD
36920: ST_TO_ADDR
// end ;
36921: GO 36870
36923: POP
36924: POP
// if not sci then
36925: LD_VAR 0 8
36929: NOT
36930: IFFALSE 36934
// continue ;
36932: GO 35979
// for x in sci do
36934: LD_ADDR_VAR 0 7
36938: PUSH
36939: LD_VAR 0 8
36943: PUSH
36944: FOR_IN
36945: IFFALSE 36995
// if IsInUnit ( x ) and not HasTask ( x ) then
36947: LD_VAR 0 7
36951: PPUSH
36952: CALL_OW 310
36956: PUSH
36957: LD_VAR 0 7
36961: PPUSH
36962: CALL_OW 314
36966: NOT
36967: AND
36968: IFFALSE 36993
// begin ComExitBuilding ( x ) ;
36970: LD_VAR 0 7
36974: PPUSH
36975: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36979: LD_VAR 0 7
36983: PPUSH
36984: LD_VAR 0 3
36988: PPUSH
36989: CALL_OW 180
// end ;
36993: GO 36944
36995: POP
36996: POP
// end ; end ;
36997: GO 35979
36999: POP
37000: POP
// end ;
37001: GO 35933
37003: POP
37004: POP
// end ;
37005: LD_VAR 0 1
37009: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37010: LD_INT 0
37012: PPUSH
37013: PPUSH
// if not mc_bases then
37014: LD_EXP 74
37018: NOT
37019: IFFALSE 37023
// exit ;
37021: GO 37104
// for i = 1 to mc_bases do
37023: LD_ADDR_VAR 0 2
37027: PUSH
37028: DOUBLE
37029: LD_INT 1
37031: DEC
37032: ST_TO_ADDR
37033: LD_EXP 74
37037: PUSH
37038: FOR_TO
37039: IFFALSE 37102
// if mc_mines [ i ] and mc_miners [ i ] then
37041: LD_EXP 87
37045: PUSH
37046: LD_VAR 0 2
37050: ARRAY
37051: PUSH
37052: LD_EXP 88
37056: PUSH
37057: LD_VAR 0 2
37061: ARRAY
37062: AND
37063: IFFALSE 37100
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37065: LD_EXP 88
37069: PUSH
37070: LD_VAR 0 2
37074: ARRAY
37075: PUSH
37076: LD_INT 1
37078: ARRAY
37079: PPUSH
37080: CALL_OW 255
37084: PPUSH
37085: LD_EXP 87
37089: PUSH
37090: LD_VAR 0 2
37094: ARRAY
37095: PPUSH
37096: CALL 53218 0 2
37100: GO 37038
37102: POP
37103: POP
// end ;
37104: LD_VAR 0 1
37108: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37109: LD_INT 0
37111: PPUSH
37112: PPUSH
37113: PPUSH
37114: PPUSH
37115: PPUSH
37116: PPUSH
37117: PPUSH
37118: PPUSH
// if not mc_bases or not mc_parking then
37119: LD_EXP 74
37123: NOT
37124: PUSH
37125: LD_EXP 98
37129: NOT
37130: OR
37131: IFFALSE 37135
// exit ;
37133: GO 37834
// for i = 1 to mc_bases do
37135: LD_ADDR_VAR 0 2
37139: PUSH
37140: DOUBLE
37141: LD_INT 1
37143: DEC
37144: ST_TO_ADDR
37145: LD_EXP 74
37149: PUSH
37150: FOR_TO
37151: IFFALSE 37832
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37153: LD_EXP 74
37157: PUSH
37158: LD_VAR 0 2
37162: ARRAY
37163: NOT
37164: PUSH
37165: LD_EXP 98
37169: PUSH
37170: LD_VAR 0 2
37174: ARRAY
37175: NOT
37176: OR
37177: IFFALSE 37181
// continue ;
37179: GO 37150
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37181: LD_ADDR_VAR 0 5
37185: PUSH
37186: LD_EXP 74
37190: PUSH
37191: LD_VAR 0 2
37195: ARRAY
37196: PUSH
37197: LD_INT 1
37199: ARRAY
37200: PPUSH
37201: CALL_OW 255
37205: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37206: LD_ADDR_VAR 0 6
37210: PUSH
37211: LD_EXP 74
37215: PUSH
37216: LD_VAR 0 2
37220: ARRAY
37221: PPUSH
37222: LD_INT 30
37224: PUSH
37225: LD_INT 3
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PPUSH
37232: CALL_OW 72
37236: ST_TO_ADDR
// if not fac then
37237: LD_VAR 0 6
37241: NOT
37242: IFFALSE 37293
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37244: LD_ADDR_VAR 0 6
37248: PUSH
37249: LD_EXP 74
37253: PUSH
37254: LD_VAR 0 2
37258: ARRAY
37259: PPUSH
37260: LD_INT 2
37262: PUSH
37263: LD_INT 30
37265: PUSH
37266: LD_INT 0
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 30
37275: PUSH
37276: LD_INT 1
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: LIST
37287: PPUSH
37288: CALL_OW 72
37292: ST_TO_ADDR
// if not fac then
37293: LD_VAR 0 6
37297: NOT
37298: IFFALSE 37302
// continue ;
37300: GO 37150
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37302: LD_ADDR_VAR 0 7
37306: PUSH
37307: LD_EXP 98
37311: PUSH
37312: LD_VAR 0 2
37316: ARRAY
37317: PPUSH
37318: LD_INT 22
37320: PUSH
37321: LD_VAR 0 5
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 21
37332: PUSH
37333: LD_INT 2
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 3
37342: PUSH
37343: LD_INT 24
37345: PUSH
37346: LD_INT 1000
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: LIST
37361: PPUSH
37362: CALL_OW 70
37366: ST_TO_ADDR
// for j in fac do
37367: LD_ADDR_VAR 0 3
37371: PUSH
37372: LD_VAR 0 6
37376: PUSH
37377: FOR_IN
37378: IFFALSE 37459
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37380: LD_ADDR_VAR 0 7
37384: PUSH
37385: LD_VAR 0 7
37389: PUSH
37390: LD_INT 22
37392: PUSH
37393: LD_VAR 0 5
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 91
37404: PUSH
37405: LD_VAR 0 3
37409: PUSH
37410: LD_INT 15
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: LIST
37417: PUSH
37418: LD_INT 21
37420: PUSH
37421: LD_INT 2
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PUSH
37428: LD_INT 3
37430: PUSH
37431: LD_INT 24
37433: PUSH
37434: LD_INT 1000
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: LIST
37449: LIST
37450: PPUSH
37451: CALL_OW 69
37455: UNION
37456: ST_TO_ADDR
37457: GO 37377
37459: POP
37460: POP
// if not vehs then
37461: LD_VAR 0 7
37465: NOT
37466: IFFALSE 37492
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37468: LD_ADDR_EXP 86
37472: PUSH
37473: LD_EXP 86
37477: PPUSH
37478: LD_VAR 0 2
37482: PPUSH
37483: EMPTY
37484: PPUSH
37485: CALL_OW 1
37489: ST_TO_ADDR
// continue ;
37490: GO 37150
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37492: LD_ADDR_VAR 0 8
37496: PUSH
37497: LD_EXP 74
37501: PUSH
37502: LD_VAR 0 2
37506: ARRAY
37507: PPUSH
37508: LD_INT 30
37510: PUSH
37511: LD_INT 3
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PPUSH
37518: CALL_OW 72
37522: ST_TO_ADDR
// if tmp then
37523: LD_VAR 0 8
37527: IFFALSE 37630
// begin for j in tmp do
37529: LD_ADDR_VAR 0 3
37533: PUSH
37534: LD_VAR 0 8
37538: PUSH
37539: FOR_IN
37540: IFFALSE 37628
// for k in UnitsInside ( j ) do
37542: LD_ADDR_VAR 0 4
37546: PUSH
37547: LD_VAR 0 3
37551: PPUSH
37552: CALL_OW 313
37556: PUSH
37557: FOR_IN
37558: IFFALSE 37624
// if k then
37560: LD_VAR 0 4
37564: IFFALSE 37622
// if not k in mc_repair_vehicle [ i ] then
37566: LD_VAR 0 4
37570: PUSH
37571: LD_EXP 86
37575: PUSH
37576: LD_VAR 0 2
37580: ARRAY
37581: IN
37582: NOT
37583: IFFALSE 37622
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
37585: LD_ADDR_EXP 86
37589: PUSH
37590: LD_EXP 86
37594: PPUSH
37595: LD_VAR 0 2
37599: PPUSH
37600: LD_EXP 86
37604: PUSH
37605: LD_VAR 0 2
37609: ARRAY
37610: PUSH
37611: LD_VAR 0 4
37615: UNION
37616: PPUSH
37617: CALL_OW 1
37621: ST_TO_ADDR
37622: GO 37557
37624: POP
37625: POP
37626: GO 37539
37628: POP
37629: POP
// end ; if not mc_repair_vehicle [ i ] then
37630: LD_EXP 86
37634: PUSH
37635: LD_VAR 0 2
37639: ARRAY
37640: NOT
37641: IFFALSE 37645
// continue ;
37643: GO 37150
// for j in mc_repair_vehicle [ i ] do
37645: LD_ADDR_VAR 0 3
37649: PUSH
37650: LD_EXP 86
37654: PUSH
37655: LD_VAR 0 2
37659: ARRAY
37660: PUSH
37661: FOR_IN
37662: IFFALSE 37828
// begin if GetClass ( j ) <> 3 then
37664: LD_VAR 0 3
37668: PPUSH
37669: CALL_OW 257
37673: PUSH
37674: LD_INT 3
37676: NONEQUAL
37677: IFFALSE 37718
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37679: LD_ADDR_EXP 86
37683: PUSH
37684: LD_EXP 86
37688: PPUSH
37689: LD_VAR 0 2
37693: PPUSH
37694: LD_EXP 86
37698: PUSH
37699: LD_VAR 0 2
37703: ARRAY
37704: PUSH
37705: LD_VAR 0 3
37709: DIFF
37710: PPUSH
37711: CALL_OW 1
37715: ST_TO_ADDR
// continue ;
37716: GO 37661
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37718: LD_VAR 0 3
37722: PPUSH
37723: CALL_OW 311
37727: NOT
37728: PUSH
37729: LD_VAR 0 3
37733: PUSH
37734: LD_EXP 77
37738: PUSH
37739: LD_VAR 0 2
37743: ARRAY
37744: PUSH
37745: LD_INT 1
37747: ARRAY
37748: IN
37749: NOT
37750: AND
37751: PUSH
37752: LD_VAR 0 3
37756: PUSH
37757: LD_EXP 77
37761: PUSH
37762: LD_VAR 0 2
37766: ARRAY
37767: PUSH
37768: LD_INT 2
37770: ARRAY
37771: IN
37772: NOT
37773: AND
37774: IFFALSE 37826
// begin if IsInUnit ( j ) then
37776: LD_VAR 0 3
37780: PPUSH
37781: CALL_OW 310
37785: IFFALSE 37796
// ComExitBuilding ( j ) ;
37787: LD_VAR 0 3
37791: PPUSH
37792: CALL_OW 122
// if not HasTask ( j ) then
37796: LD_VAR 0 3
37800: PPUSH
37801: CALL_OW 314
37805: NOT
37806: IFFALSE 37826
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
37808: LD_VAR 0 3
37812: PPUSH
37813: LD_VAR 0 7
37817: PUSH
37818: LD_INT 1
37820: ARRAY
37821: PPUSH
37822: CALL_OW 189
// end ; end ;
37826: GO 37661
37828: POP
37829: POP
// end ;
37830: GO 37150
37832: POP
37833: POP
// end ;
37834: LD_VAR 0 1
37838: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37839: LD_INT 0
37841: PPUSH
37842: PPUSH
37843: PPUSH
37844: PPUSH
37845: PPUSH
37846: PPUSH
37847: PPUSH
37848: PPUSH
37849: PPUSH
37850: PPUSH
37851: PPUSH
// if not mc_bases then
37852: LD_EXP 74
37856: NOT
37857: IFFALSE 37861
// exit ;
37859: GO 38663
// for i = 1 to mc_bases do
37861: LD_ADDR_VAR 0 2
37865: PUSH
37866: DOUBLE
37867: LD_INT 1
37869: DEC
37870: ST_TO_ADDR
37871: LD_EXP 74
37875: PUSH
37876: FOR_TO
37877: IFFALSE 38661
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37879: LD_EXP 102
37883: PUSH
37884: LD_VAR 0 2
37888: ARRAY
37889: NOT
37890: PUSH
37891: LD_EXP 77
37895: PUSH
37896: LD_VAR 0 2
37900: ARRAY
37901: PUSH
37902: LD_INT 1
37904: ARRAY
37905: OR
37906: PUSH
37907: LD_EXP 77
37911: PUSH
37912: LD_VAR 0 2
37916: ARRAY
37917: PUSH
37918: LD_INT 2
37920: ARRAY
37921: OR
37922: PUSH
37923: LD_EXP 100
37927: PUSH
37928: LD_VAR 0 2
37932: ARRAY
37933: PPUSH
37934: LD_INT 1
37936: PPUSH
37937: CALL_OW 325
37941: NOT
37942: OR
37943: PUSH
37944: LD_EXP 97
37948: PUSH
37949: LD_VAR 0 2
37953: ARRAY
37954: OR
37955: IFFALSE 37959
// continue ;
37957: GO 37876
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37959: LD_ADDR_VAR 0 8
37963: PUSH
37964: LD_EXP 74
37968: PUSH
37969: LD_VAR 0 2
37973: ARRAY
37974: PPUSH
37975: LD_INT 25
37977: PUSH
37978: LD_INT 4
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 50
37987: PUSH
37988: EMPTY
37989: LIST
37990: PUSH
37991: LD_INT 3
37993: PUSH
37994: LD_INT 60
37996: PUSH
37997: EMPTY
37998: LIST
37999: PUSH
38000: EMPTY
38001: LIST
38002: LIST
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: LIST
38008: PPUSH
38009: CALL_OW 72
38013: PUSH
38014: LD_EXP 78
38018: PUSH
38019: LD_VAR 0 2
38023: ARRAY
38024: DIFF
38025: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38026: LD_ADDR_VAR 0 9
38030: PUSH
38031: LD_EXP 74
38035: PUSH
38036: LD_VAR 0 2
38040: ARRAY
38041: PPUSH
38042: LD_INT 2
38044: PUSH
38045: LD_INT 30
38047: PUSH
38048: LD_INT 0
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 30
38057: PUSH
38058: LD_INT 1
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: EMPTY
38066: LIST
38067: LIST
38068: LIST
38069: PPUSH
38070: CALL_OW 72
38074: ST_TO_ADDR
// if not tmp or not dep then
38075: LD_VAR 0 8
38079: NOT
38080: PUSH
38081: LD_VAR 0 9
38085: NOT
38086: OR
38087: IFFALSE 38091
// continue ;
38089: GO 37876
// side := GetSide ( tmp [ 1 ] ) ;
38091: LD_ADDR_VAR 0 11
38095: PUSH
38096: LD_VAR 0 8
38100: PUSH
38101: LD_INT 1
38103: ARRAY
38104: PPUSH
38105: CALL_OW 255
38109: ST_TO_ADDR
// dep := dep [ 1 ] ;
38110: LD_ADDR_VAR 0 9
38114: PUSH
38115: LD_VAR 0 9
38119: PUSH
38120: LD_INT 1
38122: ARRAY
38123: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38124: LD_ADDR_VAR 0 7
38128: PUSH
38129: LD_EXP 102
38133: PUSH
38134: LD_VAR 0 2
38138: ARRAY
38139: PPUSH
38140: LD_INT 22
38142: PUSH
38143: LD_INT 0
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 25
38152: PUSH
38153: LD_INT 12
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PPUSH
38164: CALL_OW 70
38168: PUSH
38169: LD_INT 22
38171: PUSH
38172: LD_INT 0
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 25
38181: PUSH
38182: LD_INT 12
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 91
38191: PUSH
38192: LD_VAR 0 9
38196: PUSH
38197: LD_INT 20
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: LIST
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: LIST
38209: PPUSH
38210: CALL_OW 69
38214: UNION
38215: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38216: LD_ADDR_VAR 0 10
38220: PUSH
38221: LD_EXP 102
38225: PUSH
38226: LD_VAR 0 2
38230: ARRAY
38231: PPUSH
38232: LD_INT 81
38234: PUSH
38235: LD_VAR 0 11
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PPUSH
38244: CALL_OW 70
38248: ST_TO_ADDR
// if not apes or danger_at_area then
38249: LD_VAR 0 7
38253: NOT
38254: PUSH
38255: LD_VAR 0 10
38259: OR
38260: IFFALSE 38310
// begin if mc_taming [ i ] then
38262: LD_EXP 105
38266: PUSH
38267: LD_VAR 0 2
38271: ARRAY
38272: IFFALSE 38308
// begin MC_Reset ( i , 121 ) ;
38274: LD_VAR 0 2
38278: PPUSH
38279: LD_INT 121
38281: PPUSH
38282: CALL 23641 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38286: LD_ADDR_EXP 105
38290: PUSH
38291: LD_EXP 105
38295: PPUSH
38296: LD_VAR 0 2
38300: PPUSH
38301: EMPTY
38302: PPUSH
38303: CALL_OW 1
38307: ST_TO_ADDR
// end ; continue ;
38308: GO 37876
// end ; for j in tmp do
38310: LD_ADDR_VAR 0 3
38314: PUSH
38315: LD_VAR 0 8
38319: PUSH
38320: FOR_IN
38321: IFFALSE 38657
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
38323: LD_VAR 0 3
38327: PUSH
38328: LD_EXP 105
38332: PUSH
38333: LD_VAR 0 2
38337: ARRAY
38338: IN
38339: NOT
38340: PUSH
38341: LD_EXP 105
38345: PUSH
38346: LD_VAR 0 2
38350: ARRAY
38351: PUSH
38352: LD_INT 3
38354: LESS
38355: AND
38356: IFFALSE 38414
// begin SetTag ( j , 121 ) ;
38358: LD_VAR 0 3
38362: PPUSH
38363: LD_INT 121
38365: PPUSH
38366: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
38370: LD_ADDR_EXP 105
38374: PUSH
38375: LD_EXP 105
38379: PPUSH
38380: LD_VAR 0 2
38384: PUSH
38385: LD_EXP 105
38389: PUSH
38390: LD_VAR 0 2
38394: ARRAY
38395: PUSH
38396: LD_INT 1
38398: PLUS
38399: PUSH
38400: EMPTY
38401: LIST
38402: LIST
38403: PPUSH
38404: LD_VAR 0 3
38408: PPUSH
38409: CALL 56229 0 3
38413: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
38414: LD_VAR 0 3
38418: PUSH
38419: LD_EXP 105
38423: PUSH
38424: LD_VAR 0 2
38428: ARRAY
38429: IN
38430: IFFALSE 38655
// begin if GetClass ( j ) <> 4 then
38432: LD_VAR 0 3
38436: PPUSH
38437: CALL_OW 257
38441: PUSH
38442: LD_INT 4
38444: NONEQUAL
38445: IFFALSE 38498
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
38447: LD_ADDR_EXP 105
38451: PUSH
38452: LD_EXP 105
38456: PPUSH
38457: LD_VAR 0 2
38461: PPUSH
38462: LD_EXP 105
38466: PUSH
38467: LD_VAR 0 2
38471: ARRAY
38472: PUSH
38473: LD_VAR 0 3
38477: DIFF
38478: PPUSH
38479: CALL_OW 1
38483: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38484: LD_VAR 0 3
38488: PPUSH
38489: LD_INT 0
38491: PPUSH
38492: CALL_OW 109
// continue ;
38496: GO 38320
// end ; if IsInUnit ( j ) then
38498: LD_VAR 0 3
38502: PPUSH
38503: CALL_OW 310
38507: IFFALSE 38518
// ComExitBuilding ( j ) ;
38509: LD_VAR 0 3
38513: PPUSH
38514: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
38518: LD_ADDR_VAR 0 6
38522: PUSH
38523: LD_VAR 0 7
38527: PPUSH
38528: LD_VAR 0 3
38532: PPUSH
38533: CALL_OW 74
38537: ST_TO_ADDR
// if not ape then
38538: LD_VAR 0 6
38542: NOT
38543: IFFALSE 38547
// break ;
38545: GO 38657
// x := GetX ( ape ) ;
38547: LD_ADDR_VAR 0 4
38551: PUSH
38552: LD_VAR 0 6
38556: PPUSH
38557: CALL_OW 250
38561: ST_TO_ADDR
// y := GetY ( ape ) ;
38562: LD_ADDR_VAR 0 5
38566: PUSH
38567: LD_VAR 0 6
38571: PPUSH
38572: CALL_OW 251
38576: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
38577: LD_VAR 0 4
38581: PPUSH
38582: LD_VAR 0 5
38586: PPUSH
38587: CALL_OW 488
38591: NOT
38592: PUSH
38593: LD_VAR 0 11
38597: PPUSH
38598: LD_VAR 0 4
38602: PPUSH
38603: LD_VAR 0 5
38607: PPUSH
38608: LD_INT 20
38610: PPUSH
38611: CALL 57125 0 4
38615: PUSH
38616: LD_INT 4
38618: ARRAY
38619: OR
38620: IFFALSE 38624
// break ;
38622: GO 38657
// if not HasTask ( j ) then
38624: LD_VAR 0 3
38628: PPUSH
38629: CALL_OW 314
38633: NOT
38634: IFFALSE 38655
// ComTameXY ( j , x , y ) ;
38636: LD_VAR 0 3
38640: PPUSH
38641: LD_VAR 0 4
38645: PPUSH
38646: LD_VAR 0 5
38650: PPUSH
38651: CALL_OW 131
// end ; end ;
38655: GO 38320
38657: POP
38658: POP
// end ;
38659: GO 37876
38661: POP
38662: POP
// end ;
38663: LD_VAR 0 1
38667: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38668: LD_INT 0
38670: PPUSH
38671: PPUSH
38672: PPUSH
38673: PPUSH
38674: PPUSH
38675: PPUSH
38676: PPUSH
38677: PPUSH
// if not mc_bases then
38678: LD_EXP 74
38682: NOT
38683: IFFALSE 38687
// exit ;
38685: GO 39313
// for i = 1 to mc_bases do
38687: LD_ADDR_VAR 0 2
38691: PUSH
38692: DOUBLE
38693: LD_INT 1
38695: DEC
38696: ST_TO_ADDR
38697: LD_EXP 74
38701: PUSH
38702: FOR_TO
38703: IFFALSE 39311
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38705: LD_EXP 103
38709: PUSH
38710: LD_VAR 0 2
38714: ARRAY
38715: NOT
38716: PUSH
38717: LD_EXP 103
38721: PUSH
38722: LD_VAR 0 2
38726: ARRAY
38727: PPUSH
38728: LD_INT 25
38730: PUSH
38731: LD_INT 12
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PPUSH
38738: CALL_OW 72
38742: NOT
38743: OR
38744: IFFALSE 38748
// continue ;
38746: GO 38702
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38748: LD_ADDR_VAR 0 5
38752: PUSH
38753: LD_EXP 103
38757: PUSH
38758: LD_VAR 0 2
38762: ARRAY
38763: PUSH
38764: LD_INT 1
38766: ARRAY
38767: PPUSH
38768: CALL_OW 255
38772: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38773: LD_VAR 0 5
38777: PPUSH
38778: LD_INT 2
38780: PPUSH
38781: CALL_OW 325
38785: IFFALSE 39038
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38787: LD_ADDR_VAR 0 4
38791: PUSH
38792: LD_EXP 103
38796: PUSH
38797: LD_VAR 0 2
38801: ARRAY
38802: PPUSH
38803: LD_INT 25
38805: PUSH
38806: LD_INT 16
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: PPUSH
38813: CALL_OW 72
38817: ST_TO_ADDR
// if tmp < 6 then
38818: LD_VAR 0 4
38822: PUSH
38823: LD_INT 6
38825: LESS
38826: IFFALSE 39038
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38828: LD_ADDR_VAR 0 6
38832: PUSH
38833: LD_EXP 74
38837: PUSH
38838: LD_VAR 0 2
38842: ARRAY
38843: PPUSH
38844: LD_INT 2
38846: PUSH
38847: LD_INT 30
38849: PUSH
38850: LD_INT 0
38852: PUSH
38853: EMPTY
38854: LIST
38855: LIST
38856: PUSH
38857: LD_INT 30
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: LIST
38871: PPUSH
38872: CALL_OW 72
38876: ST_TO_ADDR
// if depot then
38877: LD_VAR 0 6
38881: IFFALSE 39038
// begin selected := 0 ;
38883: LD_ADDR_VAR 0 7
38887: PUSH
38888: LD_INT 0
38890: ST_TO_ADDR
// for j in depot do
38891: LD_ADDR_VAR 0 3
38895: PUSH
38896: LD_VAR 0 6
38900: PUSH
38901: FOR_IN
38902: IFFALSE 38933
// begin if UnitsInside ( j ) < 6 then
38904: LD_VAR 0 3
38908: PPUSH
38909: CALL_OW 313
38913: PUSH
38914: LD_INT 6
38916: LESS
38917: IFFALSE 38931
// begin selected := j ;
38919: LD_ADDR_VAR 0 7
38923: PUSH
38924: LD_VAR 0 3
38928: ST_TO_ADDR
// break ;
38929: GO 38933
// end ; end ;
38931: GO 38901
38933: POP
38934: POP
// if selected then
38935: LD_VAR 0 7
38939: IFFALSE 39038
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38941: LD_ADDR_VAR 0 3
38945: PUSH
38946: LD_EXP 103
38950: PUSH
38951: LD_VAR 0 2
38955: ARRAY
38956: PPUSH
38957: LD_INT 25
38959: PUSH
38960: LD_INT 12
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PPUSH
38967: CALL_OW 72
38971: PUSH
38972: FOR_IN
38973: IFFALSE 39036
// if not HasTask ( j ) then
38975: LD_VAR 0 3
38979: PPUSH
38980: CALL_OW 314
38984: NOT
38985: IFFALSE 39034
// begin if not IsInUnit ( j ) then
38987: LD_VAR 0 3
38991: PPUSH
38992: CALL_OW 310
38996: NOT
38997: IFFALSE 39013
// ComEnterUnit ( j , selected ) ;
38999: LD_VAR 0 3
39003: PPUSH
39004: LD_VAR 0 7
39008: PPUSH
39009: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39013: LD_VAR 0 3
39017: PPUSH
39018: LD_INT 16
39020: PPUSH
39021: CALL_OW 183
// AddComExitBuilding ( j ) ;
39025: LD_VAR 0 3
39029: PPUSH
39030: CALL_OW 182
// end ;
39034: GO 38972
39036: POP
39037: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39038: LD_VAR 0 5
39042: PPUSH
39043: LD_INT 11
39045: PPUSH
39046: CALL_OW 325
39050: IFFALSE 39309
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39052: LD_ADDR_VAR 0 4
39056: PUSH
39057: LD_EXP 103
39061: PUSH
39062: LD_VAR 0 2
39066: ARRAY
39067: PPUSH
39068: LD_INT 25
39070: PUSH
39071: LD_INT 16
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PPUSH
39078: CALL_OW 72
39082: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39083: LD_VAR 0 4
39087: PUSH
39088: LD_INT 6
39090: GREATEREQUAL
39091: PUSH
39092: LD_VAR 0 5
39096: PPUSH
39097: LD_INT 2
39099: PPUSH
39100: CALL_OW 325
39104: NOT
39105: OR
39106: IFFALSE 39309
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39108: LD_ADDR_VAR 0 8
39112: PUSH
39113: LD_EXP 74
39117: PUSH
39118: LD_VAR 0 2
39122: ARRAY
39123: PPUSH
39124: LD_INT 2
39126: PUSH
39127: LD_INT 30
39129: PUSH
39130: LD_INT 4
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 30
39139: PUSH
39140: LD_INT 5
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: LIST
39151: PPUSH
39152: CALL_OW 72
39156: ST_TO_ADDR
// if barracks then
39157: LD_VAR 0 8
39161: IFFALSE 39309
// begin selected := 0 ;
39163: LD_ADDR_VAR 0 7
39167: PUSH
39168: LD_INT 0
39170: ST_TO_ADDR
// for j in barracks do
39171: LD_ADDR_VAR 0 3
39175: PUSH
39176: LD_VAR 0 8
39180: PUSH
39181: FOR_IN
39182: IFFALSE 39213
// begin if UnitsInside ( j ) < 6 then
39184: LD_VAR 0 3
39188: PPUSH
39189: CALL_OW 313
39193: PUSH
39194: LD_INT 6
39196: LESS
39197: IFFALSE 39211
// begin selected := j ;
39199: LD_ADDR_VAR 0 7
39203: PUSH
39204: LD_VAR 0 3
39208: ST_TO_ADDR
// break ;
39209: GO 39213
// end ; end ;
39211: GO 39181
39213: POP
39214: POP
// if selected then
39215: LD_VAR 0 7
39219: IFFALSE 39309
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39221: LD_ADDR_VAR 0 3
39225: PUSH
39226: LD_EXP 103
39230: PUSH
39231: LD_VAR 0 2
39235: ARRAY
39236: PPUSH
39237: LD_INT 25
39239: PUSH
39240: LD_INT 12
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PPUSH
39247: CALL_OW 72
39251: PUSH
39252: FOR_IN
39253: IFFALSE 39307
// if not IsInUnit ( j ) and not HasTask ( j ) then
39255: LD_VAR 0 3
39259: PPUSH
39260: CALL_OW 310
39264: NOT
39265: PUSH
39266: LD_VAR 0 3
39270: PPUSH
39271: CALL_OW 314
39275: NOT
39276: AND
39277: IFFALSE 39305
// begin ComEnterUnit ( j , selected ) ;
39279: LD_VAR 0 3
39283: PPUSH
39284: LD_VAR 0 7
39288: PPUSH
39289: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39293: LD_VAR 0 3
39297: PPUSH
39298: LD_INT 15
39300: PPUSH
39301: CALL_OW 183
// end ;
39305: GO 39252
39307: POP
39308: POP
// end ; end ; end ; end ; end ;
39309: GO 38702
39311: POP
39312: POP
// end ;
39313: LD_VAR 0 1
39317: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
39318: LD_INT 0
39320: PPUSH
39321: PPUSH
39322: PPUSH
39323: PPUSH
// if not mc_bases then
39324: LD_EXP 74
39328: NOT
39329: IFFALSE 39333
// exit ;
39331: GO 39511
// for i = 1 to mc_bases do
39333: LD_ADDR_VAR 0 2
39337: PUSH
39338: DOUBLE
39339: LD_INT 1
39341: DEC
39342: ST_TO_ADDR
39343: LD_EXP 74
39347: PUSH
39348: FOR_TO
39349: IFFALSE 39509
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
39351: LD_ADDR_VAR 0 4
39355: PUSH
39356: LD_EXP 74
39360: PUSH
39361: LD_VAR 0 2
39365: ARRAY
39366: PPUSH
39367: LD_INT 25
39369: PUSH
39370: LD_INT 9
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PPUSH
39377: CALL_OW 72
39381: ST_TO_ADDR
// if not tmp then
39382: LD_VAR 0 4
39386: NOT
39387: IFFALSE 39391
// continue ;
39389: GO 39348
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
39391: LD_EXP 100
39395: PUSH
39396: LD_VAR 0 2
39400: ARRAY
39401: PPUSH
39402: LD_INT 29
39404: PPUSH
39405: CALL_OW 325
39409: NOT
39410: PUSH
39411: LD_EXP 100
39415: PUSH
39416: LD_VAR 0 2
39420: ARRAY
39421: PPUSH
39422: LD_INT 28
39424: PPUSH
39425: CALL_OW 325
39429: NOT
39430: AND
39431: IFFALSE 39435
// continue ;
39433: GO 39348
// for j in tmp do
39435: LD_ADDR_VAR 0 3
39439: PUSH
39440: LD_VAR 0 4
39444: PUSH
39445: FOR_IN
39446: IFFALSE 39505
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39448: LD_VAR 0 3
39452: PUSH
39453: LD_EXP 77
39457: PUSH
39458: LD_VAR 0 2
39462: ARRAY
39463: PUSH
39464: LD_INT 1
39466: ARRAY
39467: IN
39468: NOT
39469: PUSH
39470: LD_VAR 0 3
39474: PUSH
39475: LD_EXP 77
39479: PUSH
39480: LD_VAR 0 2
39484: ARRAY
39485: PUSH
39486: LD_INT 2
39488: ARRAY
39489: IN
39490: NOT
39491: AND
39492: IFFALSE 39503
// ComSpaceTimeShoot ( j ) ;
39494: LD_VAR 0 3
39498: PPUSH
39499: CALL 50179 0 1
39503: GO 39445
39505: POP
39506: POP
// end ;
39507: GO 39348
39509: POP
39510: POP
// end ;
39511: LD_VAR 0 1
39515: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
39516: LD_INT 0
39518: PPUSH
39519: PPUSH
39520: PPUSH
39521: PPUSH
39522: PPUSH
39523: PPUSH
39524: PPUSH
39525: PPUSH
39526: PPUSH
// if not mc_bases then
39527: LD_EXP 74
39531: NOT
39532: IFFALSE 39536
// exit ;
39534: GO 40158
// for i = 1 to mc_bases do
39536: LD_ADDR_VAR 0 2
39540: PUSH
39541: DOUBLE
39542: LD_INT 1
39544: DEC
39545: ST_TO_ADDR
39546: LD_EXP 74
39550: PUSH
39551: FOR_TO
39552: IFFALSE 40156
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
39554: LD_EXP 109
39558: PUSH
39559: LD_VAR 0 2
39563: ARRAY
39564: NOT
39565: PUSH
39566: LD_INT 38
39568: PPUSH
39569: LD_EXP 100
39573: PUSH
39574: LD_VAR 0 2
39578: ARRAY
39579: PPUSH
39580: CALL_OW 321
39584: PUSH
39585: LD_INT 2
39587: NONEQUAL
39588: OR
39589: IFFALSE 39593
// continue ;
39591: GO 39551
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
39593: LD_ADDR_VAR 0 8
39597: PUSH
39598: LD_EXP 74
39602: PUSH
39603: LD_VAR 0 2
39607: ARRAY
39608: PPUSH
39609: LD_INT 30
39611: PUSH
39612: LD_INT 34
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PPUSH
39619: CALL_OW 72
39623: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
39624: LD_ADDR_VAR 0 9
39628: PUSH
39629: LD_EXP 74
39633: PUSH
39634: LD_VAR 0 2
39638: ARRAY
39639: PPUSH
39640: LD_INT 25
39642: PUSH
39643: LD_INT 4
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: PPUSH
39650: CALL_OW 72
39654: PPUSH
39655: LD_INT 0
39657: PPUSH
39658: CALL 89489 0 2
39662: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39663: LD_VAR 0 9
39667: NOT
39668: PUSH
39669: LD_VAR 0 8
39673: NOT
39674: OR
39675: PUSH
39676: LD_EXP 74
39680: PUSH
39681: LD_VAR 0 2
39685: ARRAY
39686: PPUSH
39687: LD_INT 124
39689: PPUSH
39690: CALL 89489 0 2
39694: OR
39695: IFFALSE 39699
// continue ;
39697: GO 39551
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39699: LD_EXP 110
39703: PUSH
39704: LD_VAR 0 2
39708: ARRAY
39709: PUSH
39710: LD_EXP 109
39714: PUSH
39715: LD_VAR 0 2
39719: ARRAY
39720: LESS
39721: PUSH
39722: LD_EXP 110
39726: PUSH
39727: LD_VAR 0 2
39731: ARRAY
39732: PUSH
39733: LD_VAR 0 8
39737: LESS
39738: AND
39739: IFFALSE 40154
// begin tmp := sci [ 1 ] ;
39741: LD_ADDR_VAR 0 7
39745: PUSH
39746: LD_VAR 0 9
39750: PUSH
39751: LD_INT 1
39753: ARRAY
39754: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39755: LD_VAR 0 7
39759: PPUSH
39760: LD_INT 124
39762: PPUSH
39763: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39767: LD_ADDR_VAR 0 3
39771: PUSH
39772: DOUBLE
39773: LD_EXP 109
39777: PUSH
39778: LD_VAR 0 2
39782: ARRAY
39783: INC
39784: ST_TO_ADDR
39785: LD_EXP 109
39789: PUSH
39790: LD_VAR 0 2
39794: ARRAY
39795: PUSH
39796: FOR_DOWNTO
39797: IFFALSE 40140
// begin if IsInUnit ( tmp ) then
39799: LD_VAR 0 7
39803: PPUSH
39804: CALL_OW 310
39808: IFFALSE 39819
// ComExitBuilding ( tmp ) ;
39810: LD_VAR 0 7
39814: PPUSH
39815: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39819: LD_INT 35
39821: PPUSH
39822: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39826: LD_VAR 0 7
39830: PPUSH
39831: CALL_OW 310
39835: NOT
39836: PUSH
39837: LD_VAR 0 7
39841: PPUSH
39842: CALL_OW 314
39846: NOT
39847: AND
39848: IFFALSE 39819
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39850: LD_ADDR_VAR 0 6
39854: PUSH
39855: LD_VAR 0 7
39859: PPUSH
39860: CALL_OW 250
39864: PUSH
39865: LD_VAR 0 7
39869: PPUSH
39870: CALL_OW 251
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39879: LD_INT 35
39881: PPUSH
39882: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39886: LD_ADDR_VAR 0 4
39890: PUSH
39891: LD_EXP 109
39895: PUSH
39896: LD_VAR 0 2
39900: ARRAY
39901: PUSH
39902: LD_VAR 0 3
39906: ARRAY
39907: PUSH
39908: LD_INT 1
39910: ARRAY
39911: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39912: LD_ADDR_VAR 0 5
39916: PUSH
39917: LD_EXP 109
39921: PUSH
39922: LD_VAR 0 2
39926: ARRAY
39927: PUSH
39928: LD_VAR 0 3
39932: ARRAY
39933: PUSH
39934: LD_INT 2
39936: ARRAY
39937: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39938: LD_VAR 0 7
39942: PPUSH
39943: LD_INT 10
39945: PPUSH
39946: CALL 58822 0 2
39950: PUSH
39951: LD_INT 4
39953: ARRAY
39954: IFFALSE 39992
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39956: LD_VAR 0 7
39960: PPUSH
39961: LD_VAR 0 6
39965: PUSH
39966: LD_INT 1
39968: ARRAY
39969: PPUSH
39970: LD_VAR 0 6
39974: PUSH
39975: LD_INT 2
39977: ARRAY
39978: PPUSH
39979: CALL_OW 111
// wait ( 0 0$10 ) ;
39983: LD_INT 350
39985: PPUSH
39986: CALL_OW 67
// end else
39990: GO 40018
// begin ComMoveXY ( tmp , x , y ) ;
39992: LD_VAR 0 7
39996: PPUSH
39997: LD_VAR 0 4
40001: PPUSH
40002: LD_VAR 0 5
40006: PPUSH
40007: CALL_OW 111
// wait ( 0 0$3 ) ;
40011: LD_INT 105
40013: PPUSH
40014: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40018: LD_VAR 0 7
40022: PPUSH
40023: LD_VAR 0 4
40027: PPUSH
40028: LD_VAR 0 5
40032: PPUSH
40033: CALL_OW 307
40037: IFFALSE 39879
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40039: LD_VAR 0 7
40043: PPUSH
40044: LD_VAR 0 4
40048: PPUSH
40049: LD_VAR 0 5
40053: PPUSH
40054: LD_VAR 0 8
40058: PUSH
40059: LD_VAR 0 3
40063: ARRAY
40064: PPUSH
40065: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40069: LD_INT 35
40071: PPUSH
40072: CALL_OW 67
// until not HasTask ( tmp ) ;
40076: LD_VAR 0 7
40080: PPUSH
40081: CALL_OW 314
40085: NOT
40086: IFFALSE 40069
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40088: LD_ADDR_EXP 110
40092: PUSH
40093: LD_EXP 110
40097: PPUSH
40098: LD_VAR 0 2
40102: PUSH
40103: LD_EXP 110
40107: PUSH
40108: LD_VAR 0 2
40112: ARRAY
40113: PUSH
40114: LD_INT 1
40116: PLUS
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PPUSH
40122: LD_VAR 0 8
40126: PUSH
40127: LD_VAR 0 3
40131: ARRAY
40132: PPUSH
40133: CALL 56229 0 3
40137: ST_TO_ADDR
// end ;
40138: GO 39796
40140: POP
40141: POP
// MC_Reset ( i , 124 ) ;
40142: LD_VAR 0 2
40146: PPUSH
40147: LD_INT 124
40149: PPUSH
40150: CALL 23641 0 2
// end ; end ;
40154: GO 39551
40156: POP
40157: POP
// end ;
40158: LD_VAR 0 1
40162: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40163: LD_INT 0
40165: PPUSH
40166: PPUSH
40167: PPUSH
// if not mc_bases then
40168: LD_EXP 74
40172: NOT
40173: IFFALSE 40177
// exit ;
40175: GO 40783
// for i = 1 to mc_bases do
40177: LD_ADDR_VAR 0 2
40181: PUSH
40182: DOUBLE
40183: LD_INT 1
40185: DEC
40186: ST_TO_ADDR
40187: LD_EXP 74
40191: PUSH
40192: FOR_TO
40193: IFFALSE 40781
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40195: LD_ADDR_VAR 0 3
40199: PUSH
40200: LD_EXP 74
40204: PUSH
40205: LD_VAR 0 2
40209: ARRAY
40210: PPUSH
40211: LD_INT 25
40213: PUSH
40214: LD_INT 4
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PPUSH
40221: CALL_OW 72
40225: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40226: LD_VAR 0 3
40230: NOT
40231: PUSH
40232: LD_EXP 111
40236: PUSH
40237: LD_VAR 0 2
40241: ARRAY
40242: NOT
40243: OR
40244: PUSH
40245: LD_EXP 74
40249: PUSH
40250: LD_VAR 0 2
40254: ARRAY
40255: PPUSH
40256: LD_INT 2
40258: PUSH
40259: LD_INT 30
40261: PUSH
40262: LD_INT 0
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 30
40271: PUSH
40272: LD_INT 1
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: EMPTY
40280: LIST
40281: LIST
40282: LIST
40283: PPUSH
40284: CALL_OW 72
40288: NOT
40289: OR
40290: IFFALSE 40340
// begin if mc_deposits_finder [ i ] then
40292: LD_EXP 112
40296: PUSH
40297: LD_VAR 0 2
40301: ARRAY
40302: IFFALSE 40338
// begin MC_Reset ( i , 125 ) ;
40304: LD_VAR 0 2
40308: PPUSH
40309: LD_INT 125
40311: PPUSH
40312: CALL 23641 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40316: LD_ADDR_EXP 112
40320: PUSH
40321: LD_EXP 112
40325: PPUSH
40326: LD_VAR 0 2
40330: PPUSH
40331: EMPTY
40332: PPUSH
40333: CALL_OW 1
40337: ST_TO_ADDR
// end ; continue ;
40338: GO 40192
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
40340: LD_EXP 111
40344: PUSH
40345: LD_VAR 0 2
40349: ARRAY
40350: PUSH
40351: LD_INT 1
40353: ARRAY
40354: PUSH
40355: LD_INT 3
40357: ARRAY
40358: PUSH
40359: LD_INT 1
40361: EQUAL
40362: PUSH
40363: LD_INT 20
40365: PPUSH
40366: LD_EXP 100
40370: PUSH
40371: LD_VAR 0 2
40375: ARRAY
40376: PPUSH
40377: CALL_OW 321
40381: PUSH
40382: LD_INT 2
40384: NONEQUAL
40385: AND
40386: IFFALSE 40436
// begin if mc_deposits_finder [ i ] then
40388: LD_EXP 112
40392: PUSH
40393: LD_VAR 0 2
40397: ARRAY
40398: IFFALSE 40434
// begin MC_Reset ( i , 125 ) ;
40400: LD_VAR 0 2
40404: PPUSH
40405: LD_INT 125
40407: PPUSH
40408: CALL 23641 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40412: LD_ADDR_EXP 112
40416: PUSH
40417: LD_EXP 112
40421: PPUSH
40422: LD_VAR 0 2
40426: PPUSH
40427: EMPTY
40428: PPUSH
40429: CALL_OW 1
40433: ST_TO_ADDR
// end ; continue ;
40434: GO 40192
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
40436: LD_EXP 111
40440: PUSH
40441: LD_VAR 0 2
40445: ARRAY
40446: PUSH
40447: LD_INT 1
40449: ARRAY
40450: PUSH
40451: LD_INT 1
40453: ARRAY
40454: PPUSH
40455: LD_EXP 111
40459: PUSH
40460: LD_VAR 0 2
40464: ARRAY
40465: PUSH
40466: LD_INT 1
40468: ARRAY
40469: PUSH
40470: LD_INT 2
40472: ARRAY
40473: PPUSH
40474: LD_EXP 100
40478: PUSH
40479: LD_VAR 0 2
40483: ARRAY
40484: PPUSH
40485: CALL_OW 440
40489: IFFALSE 40532
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
40491: LD_ADDR_EXP 111
40495: PUSH
40496: LD_EXP 111
40500: PPUSH
40501: LD_VAR 0 2
40505: PPUSH
40506: LD_EXP 111
40510: PUSH
40511: LD_VAR 0 2
40515: ARRAY
40516: PPUSH
40517: LD_INT 1
40519: PPUSH
40520: CALL_OW 3
40524: PPUSH
40525: CALL_OW 1
40529: ST_TO_ADDR
40530: GO 40779
// begin if not mc_deposits_finder [ i ] then
40532: LD_EXP 112
40536: PUSH
40537: LD_VAR 0 2
40541: ARRAY
40542: NOT
40543: IFFALSE 40595
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
40545: LD_ADDR_EXP 112
40549: PUSH
40550: LD_EXP 112
40554: PPUSH
40555: LD_VAR 0 2
40559: PPUSH
40560: LD_VAR 0 3
40564: PUSH
40565: LD_INT 1
40567: ARRAY
40568: PUSH
40569: EMPTY
40570: LIST
40571: PPUSH
40572: CALL_OW 1
40576: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
40577: LD_VAR 0 3
40581: PUSH
40582: LD_INT 1
40584: ARRAY
40585: PPUSH
40586: LD_INT 125
40588: PPUSH
40589: CALL_OW 109
// end else
40593: GO 40779
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
40595: LD_EXP 112
40599: PUSH
40600: LD_VAR 0 2
40604: ARRAY
40605: PUSH
40606: LD_INT 1
40608: ARRAY
40609: PPUSH
40610: CALL_OW 310
40614: IFFALSE 40637
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
40616: LD_EXP 112
40620: PUSH
40621: LD_VAR 0 2
40625: ARRAY
40626: PUSH
40627: LD_INT 1
40629: ARRAY
40630: PPUSH
40631: CALL_OW 122
40635: GO 40779
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
40637: LD_EXP 112
40641: PUSH
40642: LD_VAR 0 2
40646: ARRAY
40647: PUSH
40648: LD_INT 1
40650: ARRAY
40651: PPUSH
40652: CALL_OW 314
40656: NOT
40657: PUSH
40658: LD_EXP 112
40662: PUSH
40663: LD_VAR 0 2
40667: ARRAY
40668: PUSH
40669: LD_INT 1
40671: ARRAY
40672: PPUSH
40673: LD_EXP 111
40677: PUSH
40678: LD_VAR 0 2
40682: ARRAY
40683: PUSH
40684: LD_INT 1
40686: ARRAY
40687: PUSH
40688: LD_INT 1
40690: ARRAY
40691: PPUSH
40692: LD_EXP 111
40696: PUSH
40697: LD_VAR 0 2
40701: ARRAY
40702: PUSH
40703: LD_INT 1
40705: ARRAY
40706: PUSH
40707: LD_INT 2
40709: ARRAY
40710: PPUSH
40711: CALL_OW 297
40715: PUSH
40716: LD_INT 6
40718: GREATER
40719: AND
40720: IFFALSE 40779
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40722: LD_EXP 112
40726: PUSH
40727: LD_VAR 0 2
40731: ARRAY
40732: PUSH
40733: LD_INT 1
40735: ARRAY
40736: PPUSH
40737: LD_EXP 111
40741: PUSH
40742: LD_VAR 0 2
40746: ARRAY
40747: PUSH
40748: LD_INT 1
40750: ARRAY
40751: PUSH
40752: LD_INT 1
40754: ARRAY
40755: PPUSH
40756: LD_EXP 111
40760: PUSH
40761: LD_VAR 0 2
40765: ARRAY
40766: PUSH
40767: LD_INT 1
40769: ARRAY
40770: PUSH
40771: LD_INT 2
40773: ARRAY
40774: PPUSH
40775: CALL_OW 111
// end ; end ; end ;
40779: GO 40192
40781: POP
40782: POP
// end ;
40783: LD_VAR 0 1
40787: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40788: LD_INT 0
40790: PPUSH
40791: PPUSH
40792: PPUSH
40793: PPUSH
40794: PPUSH
40795: PPUSH
40796: PPUSH
40797: PPUSH
40798: PPUSH
40799: PPUSH
40800: PPUSH
// if not mc_bases then
40801: LD_EXP 74
40805: NOT
40806: IFFALSE 40810
// exit ;
40808: GO 41534
// for i = 1 to mc_bases do
40810: LD_ADDR_VAR 0 2
40814: PUSH
40815: DOUBLE
40816: LD_INT 1
40818: DEC
40819: ST_TO_ADDR
40820: LD_EXP 74
40824: PUSH
40825: FOR_TO
40826: IFFALSE 41532
// begin if not mc_bases [ i ] then
40828: LD_EXP 74
40832: PUSH
40833: LD_VAR 0 2
40837: ARRAY
40838: NOT
40839: IFFALSE 40843
// continue ;
40841: GO 40825
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40843: LD_ADDR_VAR 0 7
40847: PUSH
40848: LD_EXP 74
40852: PUSH
40853: LD_VAR 0 2
40857: ARRAY
40858: PUSH
40859: LD_INT 1
40861: ARRAY
40862: PPUSH
40863: CALL_OW 248
40867: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40868: LD_VAR 0 7
40872: PUSH
40873: LD_INT 3
40875: EQUAL
40876: PUSH
40877: LD_EXP 93
40881: PUSH
40882: LD_VAR 0 2
40886: ARRAY
40887: PUSH
40888: LD_EXP 96
40892: PUSH
40893: LD_VAR 0 2
40897: ARRAY
40898: UNION
40899: PPUSH
40900: LD_INT 33
40902: PUSH
40903: LD_INT 2
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PPUSH
40910: CALL_OW 72
40914: NOT
40915: OR
40916: IFFALSE 40920
// continue ;
40918: GO 40825
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40920: LD_ADDR_VAR 0 9
40924: PUSH
40925: LD_EXP 74
40929: PUSH
40930: LD_VAR 0 2
40934: ARRAY
40935: PPUSH
40936: LD_INT 30
40938: PUSH
40939: LD_INT 36
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PPUSH
40946: CALL_OW 72
40950: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40951: LD_ADDR_VAR 0 10
40955: PUSH
40956: LD_EXP 93
40960: PUSH
40961: LD_VAR 0 2
40965: ARRAY
40966: PPUSH
40967: LD_INT 34
40969: PUSH
40970: LD_INT 31
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PPUSH
40977: CALL_OW 72
40981: ST_TO_ADDR
// if not cts and not mcts then
40982: LD_VAR 0 9
40986: NOT
40987: PUSH
40988: LD_VAR 0 10
40992: NOT
40993: AND
40994: IFFALSE 40998
// continue ;
40996: GO 40825
// x := cts ;
40998: LD_ADDR_VAR 0 11
41002: PUSH
41003: LD_VAR 0 9
41007: ST_TO_ADDR
// if not x then
41008: LD_VAR 0 11
41012: NOT
41013: IFFALSE 41025
// x := mcts ;
41015: LD_ADDR_VAR 0 11
41019: PUSH
41020: LD_VAR 0 10
41024: ST_TO_ADDR
// if mc_remote_driver [ i ] then
41025: LD_EXP 114
41029: PUSH
41030: LD_VAR 0 2
41034: ARRAY
41035: IFFALSE 41304
// for j in mc_remote_driver [ i ] do
41037: LD_ADDR_VAR 0 3
41041: PUSH
41042: LD_EXP 114
41046: PUSH
41047: LD_VAR 0 2
41051: ARRAY
41052: PUSH
41053: FOR_IN
41054: IFFALSE 41302
// begin if GetClass ( j ) <> 3 then
41056: LD_VAR 0 3
41060: PPUSH
41061: CALL_OW 257
41065: PUSH
41066: LD_INT 3
41068: NONEQUAL
41069: IFFALSE 41122
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41071: LD_ADDR_EXP 114
41075: PUSH
41076: LD_EXP 114
41080: PPUSH
41081: LD_VAR 0 2
41085: PPUSH
41086: LD_EXP 114
41090: PUSH
41091: LD_VAR 0 2
41095: ARRAY
41096: PUSH
41097: LD_VAR 0 3
41101: DIFF
41102: PPUSH
41103: CALL_OW 1
41107: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41108: LD_VAR 0 3
41112: PPUSH
41113: LD_INT 0
41115: PPUSH
41116: CALL_OW 109
// continue ;
41120: GO 41053
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41122: LD_VAR 0 3
41126: PPUSH
41127: CALL_OW 310
41131: NOT
41132: PUSH
41133: LD_VAR 0 3
41137: PPUSH
41138: CALL_OW 310
41142: PPUSH
41143: CALL_OW 266
41147: PUSH
41148: LD_INT 36
41150: NONEQUAL
41151: PUSH
41152: LD_VAR 0 3
41156: PPUSH
41157: CALL 89577 0 1
41161: NOT
41162: AND
41163: OR
41164: IFFALSE 41300
// begin if IsInUnit ( j ) then
41166: LD_VAR 0 3
41170: PPUSH
41171: CALL_OW 310
41175: IFFALSE 41186
// ComExitBuilding ( j ) ;
41177: LD_VAR 0 3
41181: PPUSH
41182: CALL_OW 122
// ct := 0 ;
41186: LD_ADDR_VAR 0 8
41190: PUSH
41191: LD_INT 0
41193: ST_TO_ADDR
// for k in x do
41194: LD_ADDR_VAR 0 4
41198: PUSH
41199: LD_VAR 0 11
41203: PUSH
41204: FOR_IN
41205: IFFALSE 41278
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
41207: LD_VAR 0 4
41211: PPUSH
41212: CALL_OW 264
41216: PUSH
41217: LD_INT 31
41219: EQUAL
41220: PUSH
41221: LD_VAR 0 4
41225: PPUSH
41226: CALL_OW 311
41230: NOT
41231: AND
41232: PUSH
41233: LD_VAR 0 4
41237: PPUSH
41238: CALL_OW 266
41242: PUSH
41243: LD_INT 36
41245: EQUAL
41246: PUSH
41247: LD_VAR 0 4
41251: PPUSH
41252: CALL_OW 313
41256: PUSH
41257: LD_INT 3
41259: LESS
41260: AND
41261: OR
41262: IFFALSE 41276
// begin ct := k ;
41264: LD_ADDR_VAR 0 8
41268: PUSH
41269: LD_VAR 0 4
41273: ST_TO_ADDR
// break ;
41274: GO 41278
// end ;
41276: GO 41204
41278: POP
41279: POP
// if ct then
41280: LD_VAR 0 8
41284: IFFALSE 41300
// ComEnterUnit ( j , ct ) ;
41286: LD_VAR 0 3
41290: PPUSH
41291: LD_VAR 0 8
41295: PPUSH
41296: CALL_OW 120
// end ; end ;
41300: GO 41053
41302: POP
41303: POP
// places := 0 ;
41304: LD_ADDR_VAR 0 5
41308: PUSH
41309: LD_INT 0
41311: ST_TO_ADDR
// for j = 1 to x do
41312: LD_ADDR_VAR 0 3
41316: PUSH
41317: DOUBLE
41318: LD_INT 1
41320: DEC
41321: ST_TO_ADDR
41322: LD_VAR 0 11
41326: PUSH
41327: FOR_TO
41328: IFFALSE 41383
// if GetWeapon ( x [ j ] ) = ar_control_tower then
41330: LD_VAR 0 11
41334: PUSH
41335: LD_VAR 0 3
41339: ARRAY
41340: PPUSH
41341: CALL_OW 264
41345: PUSH
41346: LD_INT 31
41348: EQUAL
41349: IFFALSE 41367
// places := places + 1 else
41351: LD_ADDR_VAR 0 5
41355: PUSH
41356: LD_VAR 0 5
41360: PUSH
41361: LD_INT 1
41363: PLUS
41364: ST_TO_ADDR
41365: GO 41381
// places := places + 3 ;
41367: LD_ADDR_VAR 0 5
41371: PUSH
41372: LD_VAR 0 5
41376: PUSH
41377: LD_INT 3
41379: PLUS
41380: ST_TO_ADDR
41381: GO 41327
41383: POP
41384: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
41385: LD_ADDR_VAR 0 6
41389: PUSH
41390: LD_EXP 74
41394: PUSH
41395: LD_VAR 0 2
41399: ARRAY
41400: PPUSH
41401: LD_INT 25
41403: PUSH
41404: LD_INT 3
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PPUSH
41411: CALL_OW 72
41415: PUSH
41416: LD_EXP 114
41420: PUSH
41421: LD_VAR 0 2
41425: ARRAY
41426: DIFF
41427: PPUSH
41428: LD_INT 3
41430: PPUSH
41431: CALL 90477 0 2
41435: ST_TO_ADDR
// if not tmp then
41436: LD_VAR 0 6
41440: NOT
41441: IFFALSE 41445
// continue ;
41443: GO 40825
// places := places - mc_remote_driver [ i ] ;
41445: LD_ADDR_VAR 0 5
41449: PUSH
41450: LD_VAR 0 5
41454: PUSH
41455: LD_EXP 114
41459: PUSH
41460: LD_VAR 0 2
41464: ARRAY
41465: MINUS
41466: ST_TO_ADDR
// if places then
41467: LD_VAR 0 5
41471: IFFALSE 41530
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41473: LD_ADDR_EXP 114
41477: PUSH
41478: LD_EXP 114
41482: PPUSH
41483: LD_VAR 0 2
41487: PPUSH
41488: LD_EXP 114
41492: PUSH
41493: LD_VAR 0 2
41497: ARRAY
41498: PUSH
41499: LD_VAR 0 6
41503: PUSH
41504: LD_INT 1
41506: ARRAY
41507: UNION
41508: PPUSH
41509: CALL_OW 1
41513: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41514: LD_VAR 0 6
41518: PUSH
41519: LD_INT 1
41521: ARRAY
41522: PPUSH
41523: LD_INT 126
41525: PPUSH
41526: CALL_OW 109
// end ; end ;
41530: GO 40825
41532: POP
41533: POP
// end ;
41534: LD_VAR 0 1
41538: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41539: LD_INT 0
41541: PPUSH
41542: PPUSH
41543: PPUSH
41544: PPUSH
41545: PPUSH
41546: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41547: LD_VAR 0 1
41551: NOT
41552: PUSH
41553: LD_VAR 0 2
41557: NOT
41558: OR
41559: PUSH
41560: LD_VAR 0 3
41564: NOT
41565: OR
41566: PUSH
41567: LD_VAR 0 4
41571: PUSH
41572: LD_INT 1
41574: PUSH
41575: LD_INT 2
41577: PUSH
41578: LD_INT 3
41580: PUSH
41581: LD_INT 4
41583: PUSH
41584: LD_INT 5
41586: PUSH
41587: LD_INT 8
41589: PUSH
41590: LD_INT 9
41592: PUSH
41593: LD_INT 15
41595: PUSH
41596: LD_INT 16
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: IN
41610: NOT
41611: OR
41612: IFFALSE 41616
// exit ;
41614: GO 42516
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41616: LD_ADDR_VAR 0 2
41620: PUSH
41621: LD_VAR 0 2
41625: PPUSH
41626: LD_INT 21
41628: PUSH
41629: LD_INT 3
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 24
41638: PUSH
41639: LD_INT 250
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: EMPTY
41647: LIST
41648: LIST
41649: PPUSH
41650: CALL_OW 72
41654: ST_TO_ADDR
// case class of 1 , 15 :
41655: LD_VAR 0 4
41659: PUSH
41660: LD_INT 1
41662: DOUBLE
41663: EQUAL
41664: IFTRUE 41674
41666: LD_INT 15
41668: DOUBLE
41669: EQUAL
41670: IFTRUE 41674
41672: GO 41759
41674: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41675: LD_ADDR_VAR 0 8
41679: PUSH
41680: LD_VAR 0 2
41684: PPUSH
41685: LD_INT 2
41687: PUSH
41688: LD_INT 30
41690: PUSH
41691: LD_INT 32
41693: PUSH
41694: EMPTY
41695: LIST
41696: LIST
41697: PUSH
41698: LD_INT 30
41700: PUSH
41701: LD_INT 31
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: LIST
41712: PPUSH
41713: CALL_OW 72
41717: PUSH
41718: LD_VAR 0 2
41722: PPUSH
41723: LD_INT 2
41725: PUSH
41726: LD_INT 30
41728: PUSH
41729: LD_INT 4
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 30
41738: PUSH
41739: LD_INT 5
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: EMPTY
41747: LIST
41748: LIST
41749: LIST
41750: PPUSH
41751: CALL_OW 72
41755: ADD
41756: ST_TO_ADDR
41757: GO 42005
41759: LD_INT 2
41761: DOUBLE
41762: EQUAL
41763: IFTRUE 41773
41765: LD_INT 16
41767: DOUBLE
41768: EQUAL
41769: IFTRUE 41773
41771: GO 41819
41773: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41774: LD_ADDR_VAR 0 8
41778: PUSH
41779: LD_VAR 0 2
41783: PPUSH
41784: LD_INT 2
41786: PUSH
41787: LD_INT 30
41789: PUSH
41790: LD_INT 0
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PUSH
41797: LD_INT 30
41799: PUSH
41800: LD_INT 1
41802: PUSH
41803: EMPTY
41804: LIST
41805: LIST
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: LIST
41811: PPUSH
41812: CALL_OW 72
41816: ST_TO_ADDR
41817: GO 42005
41819: LD_INT 3
41821: DOUBLE
41822: EQUAL
41823: IFTRUE 41827
41825: GO 41873
41827: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41828: LD_ADDR_VAR 0 8
41832: PUSH
41833: LD_VAR 0 2
41837: PPUSH
41838: LD_INT 2
41840: PUSH
41841: LD_INT 30
41843: PUSH
41844: LD_INT 2
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 30
41853: PUSH
41854: LD_INT 3
41856: PUSH
41857: EMPTY
41858: LIST
41859: LIST
41860: PUSH
41861: EMPTY
41862: LIST
41863: LIST
41864: LIST
41865: PPUSH
41866: CALL_OW 72
41870: ST_TO_ADDR
41871: GO 42005
41873: LD_INT 4
41875: DOUBLE
41876: EQUAL
41877: IFTRUE 41881
41879: GO 41938
41881: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41882: LD_ADDR_VAR 0 8
41886: PUSH
41887: LD_VAR 0 2
41891: PPUSH
41892: LD_INT 2
41894: PUSH
41895: LD_INT 30
41897: PUSH
41898: LD_INT 6
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 30
41907: PUSH
41908: LD_INT 7
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 30
41917: PUSH
41918: LD_INT 8
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: LIST
41929: LIST
41930: PPUSH
41931: CALL_OW 72
41935: ST_TO_ADDR
41936: GO 42005
41938: LD_INT 5
41940: DOUBLE
41941: EQUAL
41942: IFTRUE 41958
41944: LD_INT 8
41946: DOUBLE
41947: EQUAL
41948: IFTRUE 41958
41950: LD_INT 9
41952: DOUBLE
41953: EQUAL
41954: IFTRUE 41958
41956: GO 42004
41958: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41959: LD_ADDR_VAR 0 8
41963: PUSH
41964: LD_VAR 0 2
41968: PPUSH
41969: LD_INT 2
41971: PUSH
41972: LD_INT 30
41974: PUSH
41975: LD_INT 4
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PUSH
41982: LD_INT 30
41984: PUSH
41985: LD_INT 5
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: LIST
41996: PPUSH
41997: CALL_OW 72
42001: ST_TO_ADDR
42002: GO 42005
42004: POP
// if not tmp then
42005: LD_VAR 0 8
42009: NOT
42010: IFFALSE 42014
// exit ;
42012: GO 42516
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42014: LD_VAR 0 4
42018: PUSH
42019: LD_INT 1
42021: PUSH
42022: LD_INT 15
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: IN
42029: PUSH
42030: LD_EXP 83
42034: PUSH
42035: LD_VAR 0 1
42039: ARRAY
42040: AND
42041: IFFALSE 42197
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42043: LD_ADDR_VAR 0 9
42047: PUSH
42048: LD_EXP 83
42052: PUSH
42053: LD_VAR 0 1
42057: ARRAY
42058: PUSH
42059: LD_INT 1
42061: ARRAY
42062: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42063: LD_VAR 0 9
42067: PUSH
42068: LD_EXP 84
42072: PUSH
42073: LD_VAR 0 1
42077: ARRAY
42078: IN
42079: NOT
42080: IFFALSE 42195
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42082: LD_ADDR_EXP 84
42086: PUSH
42087: LD_EXP 84
42091: PPUSH
42092: LD_VAR 0 1
42096: PUSH
42097: LD_EXP 84
42101: PUSH
42102: LD_VAR 0 1
42106: ARRAY
42107: PUSH
42108: LD_INT 1
42110: PLUS
42111: PUSH
42112: EMPTY
42113: LIST
42114: LIST
42115: PPUSH
42116: LD_VAR 0 9
42120: PPUSH
42121: CALL 56229 0 3
42125: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
42126: LD_ADDR_EXP 83
42130: PUSH
42131: LD_EXP 83
42135: PPUSH
42136: LD_VAR 0 1
42140: PPUSH
42141: LD_EXP 83
42145: PUSH
42146: LD_VAR 0 1
42150: ARRAY
42151: PUSH
42152: LD_VAR 0 9
42156: DIFF
42157: PPUSH
42158: CALL_OW 1
42162: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
42163: LD_VAR 0 3
42167: PPUSH
42168: LD_EXP 84
42172: PUSH
42173: LD_VAR 0 1
42177: ARRAY
42178: PUSH
42179: LD_EXP 84
42183: PUSH
42184: LD_VAR 0 1
42188: ARRAY
42189: ARRAY
42190: PPUSH
42191: CALL_OW 120
// end ; exit ;
42195: GO 42516
// end ; if tmp > 1 then
42197: LD_VAR 0 8
42201: PUSH
42202: LD_INT 1
42204: GREATER
42205: IFFALSE 42309
// for i = 2 to tmp do
42207: LD_ADDR_VAR 0 6
42211: PUSH
42212: DOUBLE
42213: LD_INT 2
42215: DEC
42216: ST_TO_ADDR
42217: LD_VAR 0 8
42221: PUSH
42222: FOR_TO
42223: IFFALSE 42307
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
42225: LD_VAR 0 8
42229: PUSH
42230: LD_VAR 0 6
42234: ARRAY
42235: PPUSH
42236: CALL_OW 461
42240: PUSH
42241: LD_INT 6
42243: EQUAL
42244: IFFALSE 42305
// begin x := tmp [ i ] ;
42246: LD_ADDR_VAR 0 9
42250: PUSH
42251: LD_VAR 0 8
42255: PUSH
42256: LD_VAR 0 6
42260: ARRAY
42261: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
42262: LD_ADDR_VAR 0 8
42266: PUSH
42267: LD_VAR 0 8
42271: PPUSH
42272: LD_VAR 0 6
42276: PPUSH
42277: CALL_OW 3
42281: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
42282: LD_ADDR_VAR 0 8
42286: PUSH
42287: LD_VAR 0 8
42291: PPUSH
42292: LD_INT 1
42294: PPUSH
42295: LD_VAR 0 9
42299: PPUSH
42300: CALL_OW 2
42304: ST_TO_ADDR
// end ;
42305: GO 42222
42307: POP
42308: POP
// for i in tmp do
42309: LD_ADDR_VAR 0 6
42313: PUSH
42314: LD_VAR 0 8
42318: PUSH
42319: FOR_IN
42320: IFFALSE 42389
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
42322: LD_VAR 0 6
42326: PPUSH
42327: CALL_OW 313
42331: PUSH
42332: LD_INT 6
42334: LESS
42335: PUSH
42336: LD_VAR 0 6
42340: PPUSH
42341: CALL_OW 266
42345: PUSH
42346: LD_INT 31
42348: PUSH
42349: LD_INT 32
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: IN
42356: NOT
42357: AND
42358: PUSH
42359: LD_VAR 0 6
42363: PPUSH
42364: CALL_OW 313
42368: PUSH
42369: LD_INT 0
42371: EQUAL
42372: OR
42373: IFFALSE 42387
// begin j := i ;
42375: LD_ADDR_VAR 0 7
42379: PUSH
42380: LD_VAR 0 6
42384: ST_TO_ADDR
// break ;
42385: GO 42389
// end ; end ;
42387: GO 42319
42389: POP
42390: POP
// if j then
42391: LD_VAR 0 7
42395: IFFALSE 42413
// ComEnterUnit ( unit , j ) else
42397: LD_VAR 0 3
42401: PPUSH
42402: LD_VAR 0 7
42406: PPUSH
42407: CALL_OW 120
42411: GO 42516
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42413: LD_ADDR_VAR 0 10
42417: PUSH
42418: LD_VAR 0 2
42422: PPUSH
42423: LD_INT 2
42425: PUSH
42426: LD_INT 30
42428: PUSH
42429: LD_INT 0
42431: PUSH
42432: EMPTY
42433: LIST
42434: LIST
42435: PUSH
42436: LD_INT 30
42438: PUSH
42439: LD_INT 1
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: LIST
42450: PPUSH
42451: CALL_OW 72
42455: ST_TO_ADDR
// if depot then
42456: LD_VAR 0 10
42460: IFFALSE 42516
// begin depot := NearestUnitToUnit ( depot , unit ) ;
42462: LD_ADDR_VAR 0 10
42466: PUSH
42467: LD_VAR 0 10
42471: PPUSH
42472: LD_VAR 0 3
42476: PPUSH
42477: CALL_OW 74
42481: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
42482: LD_VAR 0 3
42486: PPUSH
42487: LD_VAR 0 10
42491: PPUSH
42492: CALL_OW 296
42496: PUSH
42497: LD_INT 10
42499: GREATER
42500: IFFALSE 42516
// ComStandNearbyBuilding ( unit , depot ) ;
42502: LD_VAR 0 3
42506: PPUSH
42507: LD_VAR 0 10
42511: PPUSH
42512: CALL 50796 0 2
// end ; end ; end ;
42516: LD_VAR 0 5
42520: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42521: LD_INT 0
42523: PPUSH
42524: PPUSH
42525: PPUSH
42526: PPUSH
// if not mc_bases then
42527: LD_EXP 74
42531: NOT
42532: IFFALSE 42536
// exit ;
42534: GO 42775
// for i = 1 to mc_bases do
42536: LD_ADDR_VAR 0 2
42540: PUSH
42541: DOUBLE
42542: LD_INT 1
42544: DEC
42545: ST_TO_ADDR
42546: LD_EXP 74
42550: PUSH
42551: FOR_TO
42552: IFFALSE 42773
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42554: LD_ADDR_VAR 0 4
42558: PUSH
42559: LD_EXP 74
42563: PUSH
42564: LD_VAR 0 2
42568: ARRAY
42569: PPUSH
42570: LD_INT 21
42572: PUSH
42573: LD_INT 1
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PPUSH
42580: CALL_OW 72
42584: PUSH
42585: LD_EXP 103
42589: PUSH
42590: LD_VAR 0 2
42594: ARRAY
42595: UNION
42596: ST_TO_ADDR
// if not tmp then
42597: LD_VAR 0 4
42601: NOT
42602: IFFALSE 42606
// continue ;
42604: GO 42551
// for j in tmp do
42606: LD_ADDR_VAR 0 3
42610: PUSH
42611: LD_VAR 0 4
42615: PUSH
42616: FOR_IN
42617: IFFALSE 42769
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42619: LD_VAR 0 3
42623: PPUSH
42624: CALL_OW 110
42628: NOT
42629: PUSH
42630: LD_VAR 0 3
42634: PPUSH
42635: CALL_OW 314
42639: NOT
42640: AND
42641: PUSH
42642: LD_VAR 0 3
42646: PPUSH
42647: CALL_OW 311
42651: NOT
42652: AND
42653: PUSH
42654: LD_VAR 0 3
42658: PPUSH
42659: CALL_OW 310
42663: NOT
42664: AND
42665: PUSH
42666: LD_VAR 0 3
42670: PUSH
42671: LD_EXP 77
42675: PUSH
42676: LD_VAR 0 2
42680: ARRAY
42681: PUSH
42682: LD_INT 1
42684: ARRAY
42685: IN
42686: NOT
42687: AND
42688: PUSH
42689: LD_VAR 0 3
42693: PUSH
42694: LD_EXP 77
42698: PUSH
42699: LD_VAR 0 2
42703: ARRAY
42704: PUSH
42705: LD_INT 2
42707: ARRAY
42708: IN
42709: NOT
42710: AND
42711: PUSH
42712: LD_VAR 0 3
42716: PUSH
42717: LD_EXP 86
42721: PUSH
42722: LD_VAR 0 2
42726: ARRAY
42727: IN
42728: NOT
42729: AND
42730: IFFALSE 42767
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42732: LD_VAR 0 2
42736: PPUSH
42737: LD_EXP 74
42741: PUSH
42742: LD_VAR 0 2
42746: ARRAY
42747: PPUSH
42748: LD_VAR 0 3
42752: PPUSH
42753: LD_VAR 0 3
42757: PPUSH
42758: CALL_OW 257
42762: PPUSH
42763: CALL 41539 0 4
// end ;
42767: GO 42616
42769: POP
42770: POP
// end ;
42771: GO 42551
42773: POP
42774: POP
// end ;
42775: LD_VAR 0 1
42779: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
42780: LD_INT 0
42782: PPUSH
42783: PPUSH
42784: PPUSH
42785: PPUSH
42786: PPUSH
42787: PPUSH
// if not mc_bases [ base ] then
42788: LD_EXP 74
42792: PUSH
42793: LD_VAR 0 1
42797: ARRAY
42798: NOT
42799: IFFALSE 42803
// exit ;
42801: GO 42985
// tmp := [ ] ;
42803: LD_ADDR_VAR 0 6
42807: PUSH
42808: EMPTY
42809: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42810: LD_ADDR_VAR 0 7
42814: PUSH
42815: LD_VAR 0 3
42819: PPUSH
42820: LD_INT 0
42822: PPUSH
42823: CALL_OW 517
42827: ST_TO_ADDR
// if not list then
42828: LD_VAR 0 7
42832: NOT
42833: IFFALSE 42837
// exit ;
42835: GO 42985
// for i = 1 to amount do
42837: LD_ADDR_VAR 0 5
42841: PUSH
42842: DOUBLE
42843: LD_INT 1
42845: DEC
42846: ST_TO_ADDR
42847: LD_VAR 0 2
42851: PUSH
42852: FOR_TO
42853: IFFALSE 42933
// begin x := rand ( 1 , list [ 1 ] ) ;
42855: LD_ADDR_VAR 0 8
42859: PUSH
42860: LD_INT 1
42862: PPUSH
42863: LD_VAR 0 7
42867: PUSH
42868: LD_INT 1
42870: ARRAY
42871: PPUSH
42872: CALL_OW 12
42876: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
42877: LD_ADDR_VAR 0 6
42881: PUSH
42882: LD_VAR 0 6
42886: PPUSH
42887: LD_VAR 0 5
42891: PPUSH
42892: LD_VAR 0 7
42896: PUSH
42897: LD_INT 1
42899: ARRAY
42900: PUSH
42901: LD_VAR 0 8
42905: ARRAY
42906: PUSH
42907: LD_VAR 0 7
42911: PUSH
42912: LD_INT 2
42914: ARRAY
42915: PUSH
42916: LD_VAR 0 8
42920: ARRAY
42921: PUSH
42922: EMPTY
42923: LIST
42924: LIST
42925: PPUSH
42926: CALL_OW 1
42930: ST_TO_ADDR
// end ;
42931: GO 42852
42933: POP
42934: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42935: LD_ADDR_EXP 87
42939: PUSH
42940: LD_EXP 87
42944: PPUSH
42945: LD_VAR 0 1
42949: PPUSH
42950: LD_VAR 0 6
42954: PPUSH
42955: CALL_OW 1
42959: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42960: LD_ADDR_EXP 89
42964: PUSH
42965: LD_EXP 89
42969: PPUSH
42970: LD_VAR 0 1
42974: PPUSH
42975: LD_VAR 0 3
42979: PPUSH
42980: CALL_OW 1
42984: ST_TO_ADDR
// end ;
42985: LD_VAR 0 4
42989: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42990: LD_INT 0
42992: PPUSH
// if not mc_bases [ base ] then
42993: LD_EXP 74
42997: PUSH
42998: LD_VAR 0 1
43002: ARRAY
43003: NOT
43004: IFFALSE 43008
// exit ;
43006: GO 43033
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43008: LD_ADDR_EXP 79
43012: PUSH
43013: LD_EXP 79
43017: PPUSH
43018: LD_VAR 0 1
43022: PPUSH
43023: LD_VAR 0 2
43027: PPUSH
43028: CALL_OW 1
43032: ST_TO_ADDR
// end ;
43033: LD_VAR 0 3
43037: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43038: LD_INT 0
43040: PPUSH
// if not mc_bases [ base ] then
43041: LD_EXP 74
43045: PUSH
43046: LD_VAR 0 1
43050: ARRAY
43051: NOT
43052: IFFALSE 43056
// exit ;
43054: GO 43093
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43056: LD_ADDR_EXP 79
43060: PUSH
43061: LD_EXP 79
43065: PPUSH
43066: LD_VAR 0 1
43070: PPUSH
43071: LD_EXP 79
43075: PUSH
43076: LD_VAR 0 1
43080: ARRAY
43081: PUSH
43082: LD_VAR 0 2
43086: UNION
43087: PPUSH
43088: CALL_OW 1
43092: ST_TO_ADDR
// end ;
43093: LD_VAR 0 3
43097: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
43098: LD_INT 0
43100: PPUSH
// if not mc_bases [ base ] then
43101: LD_EXP 74
43105: PUSH
43106: LD_VAR 0 1
43110: ARRAY
43111: NOT
43112: IFFALSE 43116
// exit ;
43114: GO 43141
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
43116: LD_ADDR_EXP 95
43120: PUSH
43121: LD_EXP 95
43125: PPUSH
43126: LD_VAR 0 1
43130: PPUSH
43131: LD_VAR 0 2
43135: PPUSH
43136: CALL_OW 1
43140: ST_TO_ADDR
// end ;
43141: LD_VAR 0 3
43145: RET
// export function MC_InsertProduceList ( base , components ) ; begin
43146: LD_INT 0
43148: PPUSH
// if not mc_bases [ base ] then
43149: LD_EXP 74
43153: PUSH
43154: LD_VAR 0 1
43158: ARRAY
43159: NOT
43160: IFFALSE 43164
// exit ;
43162: GO 43201
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
43164: LD_ADDR_EXP 95
43168: PUSH
43169: LD_EXP 95
43173: PPUSH
43174: LD_VAR 0 1
43178: PPUSH
43179: LD_EXP 95
43183: PUSH
43184: LD_VAR 0 1
43188: ARRAY
43189: PUSH
43190: LD_VAR 0 2
43194: ADD
43195: PPUSH
43196: CALL_OW 1
43200: ST_TO_ADDR
// end ;
43201: LD_VAR 0 3
43205: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
43206: LD_INT 0
43208: PPUSH
// if not mc_bases [ base ] then
43209: LD_EXP 74
43213: PUSH
43214: LD_VAR 0 1
43218: ARRAY
43219: NOT
43220: IFFALSE 43224
// exit ;
43222: GO 43278
// mc_defender := Replace ( mc_defender , base , deflist ) ;
43224: LD_ADDR_EXP 96
43228: PUSH
43229: LD_EXP 96
43233: PPUSH
43234: LD_VAR 0 1
43238: PPUSH
43239: LD_VAR 0 2
43243: PPUSH
43244: CALL_OW 1
43248: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
43249: LD_ADDR_EXP 85
43253: PUSH
43254: LD_EXP 85
43258: PPUSH
43259: LD_VAR 0 1
43263: PPUSH
43264: LD_VAR 0 2
43268: PUSH
43269: LD_INT 0
43271: PLUS
43272: PPUSH
43273: CALL_OW 1
43277: ST_TO_ADDR
// end ;
43278: LD_VAR 0 3
43282: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
43283: LD_INT 0
43285: PPUSH
// if not mc_bases [ base ] then
43286: LD_EXP 74
43290: PUSH
43291: LD_VAR 0 1
43295: ARRAY
43296: NOT
43297: IFFALSE 43301
// exit ;
43299: GO 43326
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
43301: LD_ADDR_EXP 85
43305: PUSH
43306: LD_EXP 85
43310: PPUSH
43311: LD_VAR 0 1
43315: PPUSH
43316: LD_VAR 0 2
43320: PPUSH
43321: CALL_OW 1
43325: ST_TO_ADDR
// end ;
43326: LD_VAR 0 3
43330: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
43331: LD_INT 0
43333: PPUSH
43334: PPUSH
43335: PPUSH
43336: PPUSH
// if not mc_bases [ base ] then
43337: LD_EXP 74
43341: PUSH
43342: LD_VAR 0 1
43346: ARRAY
43347: NOT
43348: IFFALSE 43352
// exit ;
43350: GO 43417
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
43352: LD_ADDR_EXP 94
43356: PUSH
43357: LD_EXP 94
43361: PPUSH
43362: LD_VAR 0 1
43366: PUSH
43367: LD_EXP 94
43371: PUSH
43372: LD_VAR 0 1
43376: ARRAY
43377: PUSH
43378: LD_INT 1
43380: PLUS
43381: PUSH
43382: EMPTY
43383: LIST
43384: LIST
43385: PPUSH
43386: LD_VAR 0 1
43390: PUSH
43391: LD_VAR 0 2
43395: PUSH
43396: LD_VAR 0 3
43400: PUSH
43401: LD_VAR 0 4
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: LIST
43410: LIST
43411: PPUSH
43412: CALL 56229 0 3
43416: ST_TO_ADDR
// end ;
43417: LD_VAR 0 5
43421: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
43422: LD_INT 0
43424: PPUSH
// if not mc_bases [ base ] then
43425: LD_EXP 74
43429: PUSH
43430: LD_VAR 0 1
43434: ARRAY
43435: NOT
43436: IFFALSE 43440
// exit ;
43438: GO 43465
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
43440: LD_ADDR_EXP 111
43444: PUSH
43445: LD_EXP 111
43449: PPUSH
43450: LD_VAR 0 1
43454: PPUSH
43455: LD_VAR 0 2
43459: PPUSH
43460: CALL_OW 1
43464: ST_TO_ADDR
// end ;
43465: LD_VAR 0 3
43469: RET
// export function MC_GetMinesField ( base ) ; begin
43470: LD_INT 0
43472: PPUSH
// result := mc_mines [ base ] ;
43473: LD_ADDR_VAR 0 2
43477: PUSH
43478: LD_EXP 87
43482: PUSH
43483: LD_VAR 0 1
43487: ARRAY
43488: ST_TO_ADDR
// end ;
43489: LD_VAR 0 2
43493: RET
// export function MC_GetProduceList ( base ) ; begin
43494: LD_INT 0
43496: PPUSH
// result := mc_produce [ base ] ;
43497: LD_ADDR_VAR 0 2
43501: PUSH
43502: LD_EXP 95
43506: PUSH
43507: LD_VAR 0 1
43511: ARRAY
43512: ST_TO_ADDR
// end ;
43513: LD_VAR 0 2
43517: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43518: LD_INT 0
43520: PPUSH
43521: PPUSH
// if not mc_bases then
43522: LD_EXP 74
43526: NOT
43527: IFFALSE 43531
// exit ;
43529: GO 43596
// if mc_bases [ base ] then
43531: LD_EXP 74
43535: PUSH
43536: LD_VAR 0 1
43540: ARRAY
43541: IFFALSE 43596
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43543: LD_ADDR_VAR 0 3
43547: PUSH
43548: LD_EXP 74
43552: PUSH
43553: LD_VAR 0 1
43557: ARRAY
43558: PPUSH
43559: LD_INT 30
43561: PUSH
43562: LD_VAR 0 2
43566: PUSH
43567: EMPTY
43568: LIST
43569: LIST
43570: PPUSH
43571: CALL_OW 72
43575: ST_TO_ADDR
// if result then
43576: LD_VAR 0 3
43580: IFFALSE 43596
// result := result [ 1 ] ;
43582: LD_ADDR_VAR 0 3
43586: PUSH
43587: LD_VAR 0 3
43591: PUSH
43592: LD_INT 1
43594: ARRAY
43595: ST_TO_ADDR
// end ; end ;
43596: LD_VAR 0 3
43600: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43601: LD_INT 0
43603: PPUSH
43604: PPUSH
// if not mc_bases then
43605: LD_EXP 74
43609: NOT
43610: IFFALSE 43614
// exit ;
43612: GO 43659
// if mc_bases [ base ] then
43614: LD_EXP 74
43618: PUSH
43619: LD_VAR 0 1
43623: ARRAY
43624: IFFALSE 43659
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43626: LD_ADDR_VAR 0 3
43630: PUSH
43631: LD_EXP 74
43635: PUSH
43636: LD_VAR 0 1
43640: ARRAY
43641: PPUSH
43642: LD_INT 30
43644: PUSH
43645: LD_VAR 0 2
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PPUSH
43654: CALL_OW 72
43658: ST_TO_ADDR
// end ;
43659: LD_VAR 0 3
43663: RET
// export function MC_SetTame ( base , area ) ; begin
43664: LD_INT 0
43666: PPUSH
// if not mc_bases or not base then
43667: LD_EXP 74
43671: NOT
43672: PUSH
43673: LD_VAR 0 1
43677: NOT
43678: OR
43679: IFFALSE 43683
// exit ;
43681: GO 43708
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43683: LD_ADDR_EXP 102
43687: PUSH
43688: LD_EXP 102
43692: PPUSH
43693: LD_VAR 0 1
43697: PPUSH
43698: LD_VAR 0 2
43702: PPUSH
43703: CALL_OW 1
43707: ST_TO_ADDR
// end ;
43708: LD_VAR 0 3
43712: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43713: LD_INT 0
43715: PPUSH
43716: PPUSH
// if not mc_bases or not base then
43717: LD_EXP 74
43721: NOT
43722: PUSH
43723: LD_VAR 0 1
43727: NOT
43728: OR
43729: IFFALSE 43733
// exit ;
43731: GO 43835
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43733: LD_ADDR_VAR 0 4
43737: PUSH
43738: LD_EXP 74
43742: PUSH
43743: LD_VAR 0 1
43747: ARRAY
43748: PPUSH
43749: LD_INT 30
43751: PUSH
43752: LD_VAR 0 2
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PPUSH
43761: CALL_OW 72
43765: ST_TO_ADDR
// if not tmp then
43766: LD_VAR 0 4
43770: NOT
43771: IFFALSE 43775
// exit ;
43773: GO 43835
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43775: LD_ADDR_EXP 106
43779: PUSH
43780: LD_EXP 106
43784: PPUSH
43785: LD_VAR 0 1
43789: PPUSH
43790: LD_EXP 106
43794: PUSH
43795: LD_VAR 0 1
43799: ARRAY
43800: PPUSH
43801: LD_EXP 106
43805: PUSH
43806: LD_VAR 0 1
43810: ARRAY
43811: PUSH
43812: LD_INT 1
43814: PLUS
43815: PPUSH
43816: LD_VAR 0 4
43820: PUSH
43821: LD_INT 1
43823: ARRAY
43824: PPUSH
43825: CALL_OW 2
43829: PPUSH
43830: CALL_OW 1
43834: ST_TO_ADDR
// end ;
43835: LD_VAR 0 3
43839: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43840: LD_INT 0
43842: PPUSH
43843: PPUSH
// if not mc_bases or not base or not kinds then
43844: LD_EXP 74
43848: NOT
43849: PUSH
43850: LD_VAR 0 1
43854: NOT
43855: OR
43856: PUSH
43857: LD_VAR 0 2
43861: NOT
43862: OR
43863: IFFALSE 43867
// exit ;
43865: GO 43928
// for i in kinds do
43867: LD_ADDR_VAR 0 4
43871: PUSH
43872: LD_VAR 0 2
43876: PUSH
43877: FOR_IN
43878: IFFALSE 43926
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43880: LD_ADDR_EXP 108
43884: PUSH
43885: LD_EXP 108
43889: PPUSH
43890: LD_VAR 0 1
43894: PUSH
43895: LD_EXP 108
43899: PUSH
43900: LD_VAR 0 1
43904: ARRAY
43905: PUSH
43906: LD_INT 1
43908: PLUS
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PPUSH
43914: LD_VAR 0 4
43918: PPUSH
43919: CALL 56229 0 3
43923: ST_TO_ADDR
43924: GO 43877
43926: POP
43927: POP
// end ;
43928: LD_VAR 0 3
43932: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43933: LD_INT 0
43935: PPUSH
// if not mc_bases or not base or not areas then
43936: LD_EXP 74
43940: NOT
43941: PUSH
43942: LD_VAR 0 1
43946: NOT
43947: OR
43948: PUSH
43949: LD_VAR 0 2
43953: NOT
43954: OR
43955: IFFALSE 43959
// exit ;
43957: GO 43984
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43959: LD_ADDR_EXP 92
43963: PUSH
43964: LD_EXP 92
43968: PPUSH
43969: LD_VAR 0 1
43973: PPUSH
43974: LD_VAR 0 2
43978: PPUSH
43979: CALL_OW 1
43983: ST_TO_ADDR
// end ;
43984: LD_VAR 0 3
43988: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43989: LD_INT 0
43991: PPUSH
// if not mc_bases or not base or not teleports_exit then
43992: LD_EXP 74
43996: NOT
43997: PUSH
43998: LD_VAR 0 1
44002: NOT
44003: OR
44004: PUSH
44005: LD_VAR 0 2
44009: NOT
44010: OR
44011: IFFALSE 44015
// exit ;
44013: GO 44040
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44015: LD_ADDR_EXP 109
44019: PUSH
44020: LD_EXP 109
44024: PPUSH
44025: LD_VAR 0 1
44029: PPUSH
44030: LD_VAR 0 2
44034: PPUSH
44035: CALL_OW 1
44039: ST_TO_ADDR
// end ;
44040: LD_VAR 0 3
44044: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44045: LD_INT 0
44047: PPUSH
44048: PPUSH
44049: PPUSH
// if not mc_bases or not base or not ext_list then
44050: LD_EXP 74
44054: NOT
44055: PUSH
44056: LD_VAR 0 1
44060: NOT
44061: OR
44062: PUSH
44063: LD_VAR 0 5
44067: NOT
44068: OR
44069: IFFALSE 44073
// exit ;
44071: GO 44246
// tmp := GetFacExtXYD ( x , y , d ) ;
44073: LD_ADDR_VAR 0 8
44077: PUSH
44078: LD_VAR 0 2
44082: PPUSH
44083: LD_VAR 0 3
44087: PPUSH
44088: LD_VAR 0 4
44092: PPUSH
44093: CALL 89607 0 3
44097: ST_TO_ADDR
// if not tmp then
44098: LD_VAR 0 8
44102: NOT
44103: IFFALSE 44107
// exit ;
44105: GO 44246
// for i in tmp do
44107: LD_ADDR_VAR 0 7
44111: PUSH
44112: LD_VAR 0 8
44116: PUSH
44117: FOR_IN
44118: IFFALSE 44244
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
44120: LD_ADDR_EXP 79
44124: PUSH
44125: LD_EXP 79
44129: PPUSH
44130: LD_VAR 0 1
44134: PPUSH
44135: LD_EXP 79
44139: PUSH
44140: LD_VAR 0 1
44144: ARRAY
44145: PPUSH
44146: LD_EXP 79
44150: PUSH
44151: LD_VAR 0 1
44155: ARRAY
44156: PUSH
44157: LD_INT 1
44159: PLUS
44160: PPUSH
44161: LD_VAR 0 5
44165: PUSH
44166: LD_INT 1
44168: ARRAY
44169: PUSH
44170: LD_VAR 0 7
44174: PUSH
44175: LD_INT 1
44177: ARRAY
44178: PUSH
44179: LD_VAR 0 7
44183: PUSH
44184: LD_INT 2
44186: ARRAY
44187: PUSH
44188: LD_VAR 0 7
44192: PUSH
44193: LD_INT 3
44195: ARRAY
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: LIST
44201: LIST
44202: PPUSH
44203: CALL_OW 2
44207: PPUSH
44208: CALL_OW 1
44212: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
44213: LD_ADDR_VAR 0 5
44217: PUSH
44218: LD_VAR 0 5
44222: PPUSH
44223: LD_INT 1
44225: PPUSH
44226: CALL_OW 3
44230: ST_TO_ADDR
// if not ext_list then
44231: LD_VAR 0 5
44235: NOT
44236: IFFALSE 44242
// exit ;
44238: POP
44239: POP
44240: GO 44246
// end ;
44242: GO 44117
44244: POP
44245: POP
// end ;
44246: LD_VAR 0 6
44250: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
44251: LD_INT 0
44253: PPUSH
// if not mc_bases or not base or not weapon_list then
44254: LD_EXP 74
44258: NOT
44259: PUSH
44260: LD_VAR 0 1
44264: NOT
44265: OR
44266: PUSH
44267: LD_VAR 0 2
44271: NOT
44272: OR
44273: IFFALSE 44277
// exit ;
44275: GO 44302
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
44277: LD_ADDR_EXP 113
44281: PUSH
44282: LD_EXP 113
44286: PPUSH
44287: LD_VAR 0 1
44291: PPUSH
44292: LD_VAR 0 2
44296: PPUSH
44297: CALL_OW 1
44301: ST_TO_ADDR
// end ;
44302: LD_VAR 0 3
44306: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
44307: LD_INT 0
44309: PPUSH
// if not mc_bases or not base or not tech_list then
44310: LD_EXP 74
44314: NOT
44315: PUSH
44316: LD_VAR 0 1
44320: NOT
44321: OR
44322: PUSH
44323: LD_VAR 0 2
44327: NOT
44328: OR
44329: IFFALSE 44333
// exit ;
44331: GO 44358
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
44333: LD_ADDR_EXP 101
44337: PUSH
44338: LD_EXP 101
44342: PPUSH
44343: LD_VAR 0 1
44347: PPUSH
44348: LD_VAR 0 2
44352: PPUSH
44353: CALL_OW 1
44357: ST_TO_ADDR
// end ;
44358: LD_VAR 0 3
44362: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
44363: LD_INT 0
44365: PPUSH
// if not mc_bases or not parking_area or not base then
44366: LD_EXP 74
44370: NOT
44371: PUSH
44372: LD_VAR 0 2
44376: NOT
44377: OR
44378: PUSH
44379: LD_VAR 0 1
44383: NOT
44384: OR
44385: IFFALSE 44389
// exit ;
44387: GO 44414
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
44389: LD_ADDR_EXP 98
44393: PUSH
44394: LD_EXP 98
44398: PPUSH
44399: LD_VAR 0 1
44403: PPUSH
44404: LD_VAR 0 2
44408: PPUSH
44409: CALL_OW 1
44413: ST_TO_ADDR
// end ;
44414: LD_VAR 0 3
44418: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
44419: LD_INT 0
44421: PPUSH
// if not mc_bases or not base or not scan_area then
44422: LD_EXP 74
44426: NOT
44427: PUSH
44428: LD_VAR 0 1
44432: NOT
44433: OR
44434: PUSH
44435: LD_VAR 0 2
44439: NOT
44440: OR
44441: IFFALSE 44445
// exit ;
44443: GO 44470
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
44445: LD_ADDR_EXP 99
44449: PUSH
44450: LD_EXP 99
44454: PPUSH
44455: LD_VAR 0 1
44459: PPUSH
44460: LD_VAR 0 2
44464: PPUSH
44465: CALL_OW 1
44469: ST_TO_ADDR
// end ;
44470: LD_VAR 0 3
44474: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44475: LD_INT 0
44477: PPUSH
44478: PPUSH
// if not mc_bases or not base then
44479: LD_EXP 74
44483: NOT
44484: PUSH
44485: LD_VAR 0 1
44489: NOT
44490: OR
44491: IFFALSE 44495
// exit ;
44493: GO 44559
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44495: LD_ADDR_VAR 0 3
44499: PUSH
44500: LD_INT 1
44502: PUSH
44503: LD_INT 2
44505: PUSH
44506: LD_INT 3
44508: PUSH
44509: LD_INT 4
44511: PUSH
44512: LD_INT 11
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: LIST
44519: LIST
44520: LIST
44521: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44522: LD_ADDR_EXP 101
44526: PUSH
44527: LD_EXP 101
44531: PPUSH
44532: LD_VAR 0 1
44536: PPUSH
44537: LD_EXP 101
44541: PUSH
44542: LD_VAR 0 1
44546: ARRAY
44547: PUSH
44548: LD_VAR 0 3
44552: DIFF
44553: PPUSH
44554: CALL_OW 1
44558: ST_TO_ADDR
// end ;
44559: LD_VAR 0 2
44563: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44564: LD_INT 0
44566: PPUSH
// result := mc_vehicles [ base ] ;
44567: LD_ADDR_VAR 0 3
44571: PUSH
44572: LD_EXP 93
44576: PUSH
44577: LD_VAR 0 1
44581: ARRAY
44582: ST_TO_ADDR
// if onlyCombat then
44583: LD_VAR 0 2
44587: IFFALSE 44752
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44589: LD_ADDR_VAR 0 3
44593: PUSH
44594: LD_VAR 0 3
44598: PUSH
44599: LD_VAR 0 3
44603: PPUSH
44604: LD_INT 2
44606: PUSH
44607: LD_INT 34
44609: PUSH
44610: LD_INT 12
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PUSH
44617: LD_INT 34
44619: PUSH
44620: LD_INT 51
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 34
44629: PUSH
44630: LD_EXP 68
44634: PUSH
44635: EMPTY
44636: LIST
44637: LIST
44638: PUSH
44639: LD_INT 34
44641: PUSH
44642: LD_INT 32
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: LD_INT 34
44651: PUSH
44652: LD_INT 13
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: PUSH
44659: LD_INT 34
44661: PUSH
44662: LD_INT 52
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 34
44671: PUSH
44672: LD_INT 14
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PUSH
44679: LD_INT 34
44681: PUSH
44682: LD_INT 53
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: LD_INT 34
44691: PUSH
44692: LD_EXP 67
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: PUSH
44701: LD_INT 34
44703: PUSH
44704: LD_INT 31
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: LD_INT 34
44713: PUSH
44714: LD_INT 48
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PUSH
44721: LD_INT 34
44723: PUSH
44724: LD_INT 8
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: PPUSH
44746: CALL_OW 72
44750: DIFF
44751: ST_TO_ADDR
// end ; end_of_file
44752: LD_VAR 0 3
44756: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44757: LD_INT 0
44759: PPUSH
44760: PPUSH
44761: PPUSH
// if not mc_bases or not skirmish then
44762: LD_EXP 74
44766: NOT
44767: PUSH
44768: LD_EXP 72
44772: NOT
44773: OR
44774: IFFALSE 44778
// exit ;
44776: GO 44943
// for i = 1 to mc_bases do
44778: LD_ADDR_VAR 0 4
44782: PUSH
44783: DOUBLE
44784: LD_INT 1
44786: DEC
44787: ST_TO_ADDR
44788: LD_EXP 74
44792: PUSH
44793: FOR_TO
44794: IFFALSE 44941
// begin if sci in mc_bases [ i ] then
44796: LD_VAR 0 2
44800: PUSH
44801: LD_EXP 74
44805: PUSH
44806: LD_VAR 0 4
44810: ARRAY
44811: IN
44812: IFFALSE 44939
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44814: LD_ADDR_EXP 103
44818: PUSH
44819: LD_EXP 103
44823: PPUSH
44824: LD_VAR 0 4
44828: PUSH
44829: LD_EXP 103
44833: PUSH
44834: LD_VAR 0 4
44838: ARRAY
44839: PUSH
44840: LD_INT 1
44842: PLUS
44843: PUSH
44844: EMPTY
44845: LIST
44846: LIST
44847: PPUSH
44848: LD_VAR 0 1
44852: PPUSH
44853: CALL 56229 0 3
44857: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44858: LD_ADDR_VAR 0 5
44862: PUSH
44863: LD_EXP 74
44867: PUSH
44868: LD_VAR 0 4
44872: ARRAY
44873: PPUSH
44874: LD_INT 2
44876: PUSH
44877: LD_INT 30
44879: PUSH
44880: LD_INT 0
44882: PUSH
44883: EMPTY
44884: LIST
44885: LIST
44886: PUSH
44887: LD_INT 30
44889: PUSH
44890: LD_INT 1
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: LIST
44901: PPUSH
44902: CALL_OW 72
44906: PPUSH
44907: LD_VAR 0 1
44911: PPUSH
44912: CALL_OW 74
44916: ST_TO_ADDR
// if tmp then
44917: LD_VAR 0 5
44921: IFFALSE 44937
// ComStandNearbyBuilding ( ape , tmp ) ;
44923: LD_VAR 0 1
44927: PPUSH
44928: LD_VAR 0 5
44932: PPUSH
44933: CALL 50796 0 2
// break ;
44937: GO 44941
// end ; end ;
44939: GO 44793
44941: POP
44942: POP
// end ;
44943: LD_VAR 0 3
44947: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44948: LD_INT 0
44950: PPUSH
44951: PPUSH
44952: PPUSH
// if not mc_bases or not skirmish then
44953: LD_EXP 74
44957: NOT
44958: PUSH
44959: LD_EXP 72
44963: NOT
44964: OR
44965: IFFALSE 44969
// exit ;
44967: GO 45058
// for i = 1 to mc_bases do
44969: LD_ADDR_VAR 0 4
44973: PUSH
44974: DOUBLE
44975: LD_INT 1
44977: DEC
44978: ST_TO_ADDR
44979: LD_EXP 74
44983: PUSH
44984: FOR_TO
44985: IFFALSE 45056
// begin if building in mc_busy_turret_list [ i ] then
44987: LD_VAR 0 1
44991: PUSH
44992: LD_EXP 84
44996: PUSH
44997: LD_VAR 0 4
45001: ARRAY
45002: IN
45003: IFFALSE 45054
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45005: LD_ADDR_VAR 0 5
45009: PUSH
45010: LD_EXP 84
45014: PUSH
45015: LD_VAR 0 4
45019: ARRAY
45020: PUSH
45021: LD_VAR 0 1
45025: DIFF
45026: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45027: LD_ADDR_EXP 84
45031: PUSH
45032: LD_EXP 84
45036: PPUSH
45037: LD_VAR 0 4
45041: PPUSH
45042: LD_VAR 0 5
45046: PPUSH
45047: CALL_OW 1
45051: ST_TO_ADDR
// break ;
45052: GO 45056
// end ; end ;
45054: GO 44984
45056: POP
45057: POP
// end ;
45058: LD_VAR 0 3
45062: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45063: LD_INT 0
45065: PPUSH
45066: PPUSH
45067: PPUSH
// if not mc_bases or not skirmish then
45068: LD_EXP 74
45072: NOT
45073: PUSH
45074: LD_EXP 72
45078: NOT
45079: OR
45080: IFFALSE 45084
// exit ;
45082: GO 45283
// for i = 1 to mc_bases do
45084: LD_ADDR_VAR 0 5
45088: PUSH
45089: DOUBLE
45090: LD_INT 1
45092: DEC
45093: ST_TO_ADDR
45094: LD_EXP 74
45098: PUSH
45099: FOR_TO
45100: IFFALSE 45281
// if building in mc_bases [ i ] then
45102: LD_VAR 0 1
45106: PUSH
45107: LD_EXP 74
45111: PUSH
45112: LD_VAR 0 5
45116: ARRAY
45117: IN
45118: IFFALSE 45279
// begin tmp := mc_bases [ i ] diff building ;
45120: LD_ADDR_VAR 0 6
45124: PUSH
45125: LD_EXP 74
45129: PUSH
45130: LD_VAR 0 5
45134: ARRAY
45135: PUSH
45136: LD_VAR 0 1
45140: DIFF
45141: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
45142: LD_ADDR_EXP 74
45146: PUSH
45147: LD_EXP 74
45151: PPUSH
45152: LD_VAR 0 5
45156: PPUSH
45157: LD_VAR 0 6
45161: PPUSH
45162: CALL_OW 1
45166: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
45167: LD_VAR 0 1
45171: PUSH
45172: LD_EXP 82
45176: PUSH
45177: LD_VAR 0 5
45181: ARRAY
45182: IN
45183: IFFALSE 45222
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
45185: LD_ADDR_EXP 82
45189: PUSH
45190: LD_EXP 82
45194: PPUSH
45195: LD_VAR 0 5
45199: PPUSH
45200: LD_EXP 82
45204: PUSH
45205: LD_VAR 0 5
45209: ARRAY
45210: PUSH
45211: LD_VAR 0 1
45215: DIFF
45216: PPUSH
45217: CALL_OW 1
45221: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
45222: LD_VAR 0 1
45226: PUSH
45227: LD_EXP 83
45231: PUSH
45232: LD_VAR 0 5
45236: ARRAY
45237: IN
45238: IFFALSE 45277
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
45240: LD_ADDR_EXP 83
45244: PUSH
45245: LD_EXP 83
45249: PPUSH
45250: LD_VAR 0 5
45254: PPUSH
45255: LD_EXP 83
45259: PUSH
45260: LD_VAR 0 5
45264: ARRAY
45265: PUSH
45266: LD_VAR 0 1
45270: DIFF
45271: PPUSH
45272: CALL_OW 1
45276: ST_TO_ADDR
// break ;
45277: GO 45281
// end ;
45279: GO 45099
45281: POP
45282: POP
// end ;
45283: LD_VAR 0 4
45287: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
45288: LD_INT 0
45290: PPUSH
45291: PPUSH
45292: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
45293: LD_EXP 74
45297: NOT
45298: PUSH
45299: LD_EXP 72
45303: NOT
45304: OR
45305: PUSH
45306: LD_VAR 0 3
45310: PUSH
45311: LD_EXP 100
45315: IN
45316: NOT
45317: OR
45318: IFFALSE 45322
// exit ;
45320: GO 45445
// for i = 1 to mc_vehicles do
45322: LD_ADDR_VAR 0 6
45326: PUSH
45327: DOUBLE
45328: LD_INT 1
45330: DEC
45331: ST_TO_ADDR
45332: LD_EXP 93
45336: PUSH
45337: FOR_TO
45338: IFFALSE 45443
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
45340: LD_VAR 0 2
45344: PUSH
45345: LD_EXP 93
45349: PUSH
45350: LD_VAR 0 6
45354: ARRAY
45355: IN
45356: PUSH
45357: LD_VAR 0 1
45361: PUSH
45362: LD_EXP 93
45366: PUSH
45367: LD_VAR 0 6
45371: ARRAY
45372: IN
45373: OR
45374: IFFALSE 45441
// begin tmp := mc_vehicles [ i ] diff old ;
45376: LD_ADDR_VAR 0 7
45380: PUSH
45381: LD_EXP 93
45385: PUSH
45386: LD_VAR 0 6
45390: ARRAY
45391: PUSH
45392: LD_VAR 0 2
45396: DIFF
45397: ST_TO_ADDR
// tmp := tmp diff new ;
45398: LD_ADDR_VAR 0 7
45402: PUSH
45403: LD_VAR 0 7
45407: PUSH
45408: LD_VAR 0 1
45412: DIFF
45413: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
45414: LD_ADDR_EXP 93
45418: PUSH
45419: LD_EXP 93
45423: PPUSH
45424: LD_VAR 0 6
45428: PPUSH
45429: LD_VAR 0 7
45433: PPUSH
45434: CALL_OW 1
45438: ST_TO_ADDR
// break ;
45439: GO 45443
// end ;
45441: GO 45337
45443: POP
45444: POP
// end ;
45445: LD_VAR 0 5
45449: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
45450: LD_INT 0
45452: PPUSH
45453: PPUSH
45454: PPUSH
45455: PPUSH
// if not mc_bases or not skirmish then
45456: LD_EXP 74
45460: NOT
45461: PUSH
45462: LD_EXP 72
45466: NOT
45467: OR
45468: IFFALSE 45472
// exit ;
45470: GO 45849
// side := GetSide ( vehicle ) ;
45472: LD_ADDR_VAR 0 5
45476: PUSH
45477: LD_VAR 0 1
45481: PPUSH
45482: CALL_OW 255
45486: ST_TO_ADDR
// for i = 1 to mc_bases do
45487: LD_ADDR_VAR 0 4
45491: PUSH
45492: DOUBLE
45493: LD_INT 1
45495: DEC
45496: ST_TO_ADDR
45497: LD_EXP 74
45501: PUSH
45502: FOR_TO
45503: IFFALSE 45847
// begin if factory in mc_bases [ i ] then
45505: LD_VAR 0 2
45509: PUSH
45510: LD_EXP 74
45514: PUSH
45515: LD_VAR 0 4
45519: ARRAY
45520: IN
45521: IFFALSE 45845
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
45523: LD_EXP 96
45527: PUSH
45528: LD_VAR 0 4
45532: ARRAY
45533: PUSH
45534: LD_EXP 85
45538: PUSH
45539: LD_VAR 0 4
45543: ARRAY
45544: LESS
45545: PUSH
45546: LD_VAR 0 1
45550: PPUSH
45551: CALL_OW 264
45555: PUSH
45556: LD_INT 31
45558: PUSH
45559: LD_INT 32
45561: PUSH
45562: LD_INT 51
45564: PUSH
45565: LD_EXP 68
45569: PUSH
45570: LD_INT 12
45572: PUSH
45573: LD_INT 30
45575: PUSH
45576: LD_EXP 67
45580: PUSH
45581: LD_INT 11
45583: PUSH
45584: LD_INT 53
45586: PUSH
45587: LD_INT 14
45589: PUSH
45590: LD_EXP 71
45594: PUSH
45595: LD_INT 29
45597: PUSH
45598: LD_EXP 69
45602: PUSH
45603: LD_INT 13
45605: PUSH
45606: LD_INT 52
45608: PUSH
45609: LD_INT 48
45611: PUSH
45612: LD_INT 8
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: IN
45634: NOT
45635: AND
45636: IFFALSE 45684
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45638: LD_ADDR_EXP 96
45642: PUSH
45643: LD_EXP 96
45647: PPUSH
45648: LD_VAR 0 4
45652: PUSH
45653: LD_EXP 96
45657: PUSH
45658: LD_VAR 0 4
45662: ARRAY
45663: PUSH
45664: LD_INT 1
45666: PLUS
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: PPUSH
45672: LD_VAR 0 1
45676: PPUSH
45677: CALL 56229 0 3
45681: ST_TO_ADDR
45682: GO 45728
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45684: LD_ADDR_EXP 93
45688: PUSH
45689: LD_EXP 93
45693: PPUSH
45694: LD_VAR 0 4
45698: PUSH
45699: LD_EXP 93
45703: PUSH
45704: LD_VAR 0 4
45708: ARRAY
45709: PUSH
45710: LD_INT 1
45712: PLUS
45713: PUSH
45714: EMPTY
45715: LIST
45716: LIST
45717: PPUSH
45718: LD_VAR 0 1
45722: PPUSH
45723: CALL 56229 0 3
45727: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45728: LD_VAR 0 1
45732: PPUSH
45733: CALL_OW 263
45737: PUSH
45738: LD_INT 2
45740: EQUAL
45741: IFFALSE 45761
// begin repeat wait ( 0 0$1 ) ;
45743: LD_INT 35
45745: PPUSH
45746: CALL_OW 67
// until IsControledBy ( vehicle ) ;
45750: LD_VAR 0 1
45754: PPUSH
45755: CALL_OW 312
45759: IFFALSE 45743
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45761: LD_VAR 0 1
45765: PPUSH
45766: LD_EXP 98
45770: PUSH
45771: LD_VAR 0 4
45775: ARRAY
45776: PPUSH
45777: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45781: LD_VAR 0 1
45785: PPUSH
45786: CALL_OW 263
45790: PUSH
45791: LD_INT 1
45793: NONEQUAL
45794: IFFALSE 45798
// break ;
45796: GO 45847
// repeat wait ( 0 0$1 ) ;
45798: LD_INT 35
45800: PPUSH
45801: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45805: LD_VAR 0 1
45809: PPUSH
45810: LD_EXP 98
45814: PUSH
45815: LD_VAR 0 4
45819: ARRAY
45820: PPUSH
45821: CALL_OW 308
45825: IFFALSE 45798
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45827: LD_VAR 0 1
45831: PPUSH
45832: CALL_OW 311
45836: PPUSH
45837: CALL_OW 121
// exit ;
45841: POP
45842: POP
45843: GO 45849
// end ; end ;
45845: GO 45502
45847: POP
45848: POP
// end ;
45849: LD_VAR 0 3
45853: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45854: LD_INT 0
45856: PPUSH
45857: PPUSH
45858: PPUSH
45859: PPUSH
// if not mc_bases or not skirmish then
45860: LD_EXP 74
45864: NOT
45865: PUSH
45866: LD_EXP 72
45870: NOT
45871: OR
45872: IFFALSE 45876
// exit ;
45874: GO 46229
// repeat wait ( 0 0$1 ) ;
45876: LD_INT 35
45878: PPUSH
45879: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45883: LD_VAR 0 2
45887: PPUSH
45888: LD_VAR 0 3
45892: PPUSH
45893: CALL_OW 284
45897: IFFALSE 45876
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45899: LD_VAR 0 2
45903: PPUSH
45904: LD_VAR 0 3
45908: PPUSH
45909: CALL_OW 283
45913: PUSH
45914: LD_INT 4
45916: EQUAL
45917: IFFALSE 45921
// exit ;
45919: GO 46229
// for i = 1 to mc_bases do
45921: LD_ADDR_VAR 0 7
45925: PUSH
45926: DOUBLE
45927: LD_INT 1
45929: DEC
45930: ST_TO_ADDR
45931: LD_EXP 74
45935: PUSH
45936: FOR_TO
45937: IFFALSE 46227
// begin if mc_crates_area [ i ] then
45939: LD_EXP 92
45943: PUSH
45944: LD_VAR 0 7
45948: ARRAY
45949: IFFALSE 46060
// for j in mc_crates_area [ i ] do
45951: LD_ADDR_VAR 0 8
45955: PUSH
45956: LD_EXP 92
45960: PUSH
45961: LD_VAR 0 7
45965: ARRAY
45966: PUSH
45967: FOR_IN
45968: IFFALSE 46058
// if InArea ( x , y , j ) then
45970: LD_VAR 0 2
45974: PPUSH
45975: LD_VAR 0 3
45979: PPUSH
45980: LD_VAR 0 8
45984: PPUSH
45985: CALL_OW 309
45989: IFFALSE 46056
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45991: LD_ADDR_EXP 90
45995: PUSH
45996: LD_EXP 90
46000: PPUSH
46001: LD_VAR 0 7
46005: PUSH
46006: LD_EXP 90
46010: PUSH
46011: LD_VAR 0 7
46015: ARRAY
46016: PUSH
46017: LD_INT 1
46019: PLUS
46020: PUSH
46021: EMPTY
46022: LIST
46023: LIST
46024: PPUSH
46025: LD_VAR 0 4
46029: PUSH
46030: LD_VAR 0 2
46034: PUSH
46035: LD_VAR 0 3
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: LIST
46044: PPUSH
46045: CALL 56229 0 3
46049: ST_TO_ADDR
// exit ;
46050: POP
46051: POP
46052: POP
46053: POP
46054: GO 46229
// end ;
46056: GO 45967
46058: POP
46059: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46060: LD_ADDR_VAR 0 9
46064: PUSH
46065: LD_EXP 74
46069: PUSH
46070: LD_VAR 0 7
46074: ARRAY
46075: PPUSH
46076: LD_INT 2
46078: PUSH
46079: LD_INT 30
46081: PUSH
46082: LD_INT 0
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: LD_INT 30
46091: PUSH
46092: LD_INT 1
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: LIST
46103: PPUSH
46104: CALL_OW 72
46108: ST_TO_ADDR
// if not depot then
46109: LD_VAR 0 9
46113: NOT
46114: IFFALSE 46118
// continue ;
46116: GO 45936
// for j in depot do
46118: LD_ADDR_VAR 0 8
46122: PUSH
46123: LD_VAR 0 9
46127: PUSH
46128: FOR_IN
46129: IFFALSE 46223
// if GetDistUnitXY ( j , x , y ) < 30 then
46131: LD_VAR 0 8
46135: PPUSH
46136: LD_VAR 0 2
46140: PPUSH
46141: LD_VAR 0 3
46145: PPUSH
46146: CALL_OW 297
46150: PUSH
46151: LD_INT 30
46153: LESS
46154: IFFALSE 46221
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46156: LD_ADDR_EXP 90
46160: PUSH
46161: LD_EXP 90
46165: PPUSH
46166: LD_VAR 0 7
46170: PUSH
46171: LD_EXP 90
46175: PUSH
46176: LD_VAR 0 7
46180: ARRAY
46181: PUSH
46182: LD_INT 1
46184: PLUS
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: PPUSH
46190: LD_VAR 0 4
46194: PUSH
46195: LD_VAR 0 2
46199: PUSH
46200: LD_VAR 0 3
46204: PUSH
46205: EMPTY
46206: LIST
46207: LIST
46208: LIST
46209: PPUSH
46210: CALL 56229 0 3
46214: ST_TO_ADDR
// exit ;
46215: POP
46216: POP
46217: POP
46218: POP
46219: GO 46229
// end ;
46221: GO 46128
46223: POP
46224: POP
// end ;
46225: GO 45936
46227: POP
46228: POP
// end ;
46229: LD_VAR 0 6
46233: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
46234: LD_INT 0
46236: PPUSH
46237: PPUSH
46238: PPUSH
46239: PPUSH
// if not mc_bases or not skirmish then
46240: LD_EXP 74
46244: NOT
46245: PUSH
46246: LD_EXP 72
46250: NOT
46251: OR
46252: IFFALSE 46256
// exit ;
46254: GO 46533
// side := GetSide ( lab ) ;
46256: LD_ADDR_VAR 0 4
46260: PUSH
46261: LD_VAR 0 2
46265: PPUSH
46266: CALL_OW 255
46270: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
46271: LD_VAR 0 4
46275: PUSH
46276: LD_EXP 100
46280: IN
46281: NOT
46282: PUSH
46283: LD_EXP 101
46287: NOT
46288: OR
46289: PUSH
46290: LD_EXP 74
46294: NOT
46295: OR
46296: IFFALSE 46300
// exit ;
46298: GO 46533
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
46300: LD_ADDR_EXP 101
46304: PUSH
46305: LD_EXP 101
46309: PPUSH
46310: LD_VAR 0 4
46314: PPUSH
46315: LD_EXP 101
46319: PUSH
46320: LD_VAR 0 4
46324: ARRAY
46325: PUSH
46326: LD_VAR 0 1
46330: DIFF
46331: PPUSH
46332: CALL_OW 1
46336: ST_TO_ADDR
// for i = 1 to mc_bases do
46337: LD_ADDR_VAR 0 5
46341: PUSH
46342: DOUBLE
46343: LD_INT 1
46345: DEC
46346: ST_TO_ADDR
46347: LD_EXP 74
46351: PUSH
46352: FOR_TO
46353: IFFALSE 46531
// begin if lab in mc_bases [ i ] then
46355: LD_VAR 0 2
46359: PUSH
46360: LD_EXP 74
46364: PUSH
46365: LD_VAR 0 5
46369: ARRAY
46370: IN
46371: IFFALSE 46529
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
46373: LD_VAR 0 1
46377: PUSH
46378: LD_INT 11
46380: PUSH
46381: LD_INT 4
46383: PUSH
46384: LD_INT 3
46386: PUSH
46387: LD_INT 2
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: IN
46396: PUSH
46397: LD_EXP 104
46401: PUSH
46402: LD_VAR 0 5
46406: ARRAY
46407: AND
46408: IFFALSE 46529
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
46410: LD_ADDR_VAR 0 6
46414: PUSH
46415: LD_EXP 104
46419: PUSH
46420: LD_VAR 0 5
46424: ARRAY
46425: PUSH
46426: LD_INT 1
46428: ARRAY
46429: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46430: LD_ADDR_EXP 104
46434: PUSH
46435: LD_EXP 104
46439: PPUSH
46440: LD_VAR 0 5
46444: PPUSH
46445: EMPTY
46446: PPUSH
46447: CALL_OW 1
46451: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46452: LD_VAR 0 6
46456: PPUSH
46457: LD_INT 0
46459: PPUSH
46460: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46464: LD_VAR 0 6
46468: PPUSH
46469: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46473: LD_ADDR_EXP 103
46477: PUSH
46478: LD_EXP 103
46482: PPUSH
46483: LD_VAR 0 5
46487: PPUSH
46488: LD_EXP 103
46492: PUSH
46493: LD_VAR 0 5
46497: ARRAY
46498: PPUSH
46499: LD_INT 1
46501: PPUSH
46502: LD_VAR 0 6
46506: PPUSH
46507: CALL_OW 2
46511: PPUSH
46512: CALL_OW 1
46516: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46517: LD_VAR 0 5
46521: PPUSH
46522: LD_INT 112
46524: PPUSH
46525: CALL 23641 0 2
// end ; end ; end ;
46529: GO 46352
46531: POP
46532: POP
// end ;
46533: LD_VAR 0 3
46537: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46538: LD_INT 0
46540: PPUSH
46541: PPUSH
46542: PPUSH
46543: PPUSH
46544: PPUSH
46545: PPUSH
46546: PPUSH
46547: PPUSH
// if not mc_bases or not skirmish then
46548: LD_EXP 74
46552: NOT
46553: PUSH
46554: LD_EXP 72
46558: NOT
46559: OR
46560: IFFALSE 46564
// exit ;
46562: GO 47801
// for i = 1 to mc_bases do
46564: LD_ADDR_VAR 0 3
46568: PUSH
46569: DOUBLE
46570: LD_INT 1
46572: DEC
46573: ST_TO_ADDR
46574: LD_EXP 74
46578: PUSH
46579: FOR_TO
46580: IFFALSE 47799
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46582: LD_VAR 0 1
46586: PUSH
46587: LD_EXP 74
46591: PUSH
46592: LD_VAR 0 3
46596: ARRAY
46597: IN
46598: PUSH
46599: LD_VAR 0 1
46603: PUSH
46604: LD_EXP 81
46608: PUSH
46609: LD_VAR 0 3
46613: ARRAY
46614: IN
46615: OR
46616: PUSH
46617: LD_VAR 0 1
46621: PUSH
46622: LD_EXP 96
46626: PUSH
46627: LD_VAR 0 3
46631: ARRAY
46632: IN
46633: OR
46634: PUSH
46635: LD_VAR 0 1
46639: PUSH
46640: LD_EXP 93
46644: PUSH
46645: LD_VAR 0 3
46649: ARRAY
46650: IN
46651: OR
46652: PUSH
46653: LD_VAR 0 1
46657: PUSH
46658: LD_EXP 103
46662: PUSH
46663: LD_VAR 0 3
46667: ARRAY
46668: IN
46669: OR
46670: PUSH
46671: LD_VAR 0 1
46675: PUSH
46676: LD_EXP 104
46680: PUSH
46681: LD_VAR 0 3
46685: ARRAY
46686: IN
46687: OR
46688: IFFALSE 47797
// begin if un in mc_ape [ i ] then
46690: LD_VAR 0 1
46694: PUSH
46695: LD_EXP 103
46699: PUSH
46700: LD_VAR 0 3
46704: ARRAY
46705: IN
46706: IFFALSE 46745
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46708: LD_ADDR_EXP 103
46712: PUSH
46713: LD_EXP 103
46717: PPUSH
46718: LD_VAR 0 3
46722: PPUSH
46723: LD_EXP 103
46727: PUSH
46728: LD_VAR 0 3
46732: ARRAY
46733: PUSH
46734: LD_VAR 0 1
46738: DIFF
46739: PPUSH
46740: CALL_OW 1
46744: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46745: LD_VAR 0 1
46749: PUSH
46750: LD_EXP 104
46754: PUSH
46755: LD_VAR 0 3
46759: ARRAY
46760: IN
46761: IFFALSE 46785
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46763: LD_ADDR_EXP 104
46767: PUSH
46768: LD_EXP 104
46772: PPUSH
46773: LD_VAR 0 3
46777: PPUSH
46778: EMPTY
46779: PPUSH
46780: CALL_OW 1
46784: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
46785: LD_VAR 0 1
46789: PPUSH
46790: CALL_OW 247
46794: PUSH
46795: LD_INT 2
46797: EQUAL
46798: PUSH
46799: LD_VAR 0 1
46803: PPUSH
46804: CALL_OW 110
46808: PUSH
46809: LD_INT 20
46811: EQUAL
46812: PUSH
46813: LD_VAR 0 1
46817: PUSH
46818: LD_EXP 96
46822: PUSH
46823: LD_VAR 0 3
46827: ARRAY
46828: IN
46829: OR
46830: PUSH
46831: LD_VAR 0 1
46835: PPUSH
46836: CALL_OW 264
46840: PUSH
46841: LD_INT 12
46843: PUSH
46844: LD_INT 51
46846: PUSH
46847: LD_EXP 68
46851: PUSH
46852: LD_INT 32
46854: PUSH
46855: LD_INT 13
46857: PUSH
46858: LD_INT 52
46860: PUSH
46861: EMPTY
46862: LIST
46863: LIST
46864: LIST
46865: LIST
46866: LIST
46867: LIST
46868: IN
46869: OR
46870: AND
46871: IFFALSE 47049
// begin if un in mc_defender [ i ] then
46873: LD_VAR 0 1
46877: PUSH
46878: LD_EXP 96
46882: PUSH
46883: LD_VAR 0 3
46887: ARRAY
46888: IN
46889: IFFALSE 46928
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46891: LD_ADDR_EXP 96
46895: PUSH
46896: LD_EXP 96
46900: PPUSH
46901: LD_VAR 0 3
46905: PPUSH
46906: LD_EXP 96
46910: PUSH
46911: LD_VAR 0 3
46915: ARRAY
46916: PUSH
46917: LD_VAR 0 1
46921: DIFF
46922: PPUSH
46923: CALL_OW 1
46927: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46928: LD_ADDR_VAR 0 8
46932: PUSH
46933: LD_VAR 0 3
46937: PPUSH
46938: LD_INT 3
46940: PPUSH
46941: CALL 43601 0 2
46945: ST_TO_ADDR
// if fac then
46946: LD_VAR 0 8
46950: IFFALSE 47049
// begin for j in fac do
46952: LD_ADDR_VAR 0 4
46956: PUSH
46957: LD_VAR 0 8
46961: PUSH
46962: FOR_IN
46963: IFFALSE 47047
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46965: LD_ADDR_VAR 0 9
46969: PUSH
46970: LD_VAR 0 8
46974: PPUSH
46975: LD_VAR 0 1
46979: PPUSH
46980: CALL_OW 265
46984: PPUSH
46985: LD_VAR 0 1
46989: PPUSH
46990: CALL_OW 262
46994: PPUSH
46995: LD_VAR 0 1
46999: PPUSH
47000: CALL_OW 263
47004: PPUSH
47005: LD_VAR 0 1
47009: PPUSH
47010: CALL_OW 264
47014: PPUSH
47015: CALL 53761 0 5
47019: ST_TO_ADDR
// if components then
47020: LD_VAR 0 9
47024: IFFALSE 47045
// begin MC_InsertProduceList ( i , [ components ] ) ;
47026: LD_VAR 0 3
47030: PPUSH
47031: LD_VAR 0 9
47035: PUSH
47036: EMPTY
47037: LIST
47038: PPUSH
47039: CALL 43146 0 2
// break ;
47043: GO 47047
// end ; end ;
47045: GO 46962
47047: POP
47048: POP
// end ; end ; if GetType ( un ) = unit_building then
47049: LD_VAR 0 1
47053: PPUSH
47054: CALL_OW 247
47058: PUSH
47059: LD_INT 3
47061: EQUAL
47062: IFFALSE 47465
// begin btype := GetBType ( un ) ;
47064: LD_ADDR_VAR 0 5
47068: PUSH
47069: LD_VAR 0 1
47073: PPUSH
47074: CALL_OW 266
47078: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
47079: LD_VAR 0 5
47083: PUSH
47084: LD_INT 29
47086: PUSH
47087: LD_INT 30
47089: PUSH
47090: EMPTY
47091: LIST
47092: LIST
47093: IN
47094: IFFALSE 47167
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
47096: LD_VAR 0 1
47100: PPUSH
47101: CALL_OW 250
47105: PPUSH
47106: LD_VAR 0 1
47110: PPUSH
47111: CALL_OW 251
47115: PPUSH
47116: LD_VAR 0 1
47120: PPUSH
47121: CALL_OW 255
47125: PPUSH
47126: CALL_OW 440
47130: NOT
47131: IFFALSE 47167
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
47133: LD_VAR 0 1
47137: PPUSH
47138: CALL_OW 250
47142: PPUSH
47143: LD_VAR 0 1
47147: PPUSH
47148: CALL_OW 251
47152: PPUSH
47153: LD_VAR 0 1
47157: PPUSH
47158: CALL_OW 255
47162: PPUSH
47163: CALL_OW 441
// end ; if btype = b_warehouse then
47167: LD_VAR 0 5
47171: PUSH
47172: LD_INT 1
47174: EQUAL
47175: IFFALSE 47193
// begin btype := b_depot ;
47177: LD_ADDR_VAR 0 5
47181: PUSH
47182: LD_INT 0
47184: ST_TO_ADDR
// pos := 1 ;
47185: LD_ADDR_VAR 0 6
47189: PUSH
47190: LD_INT 1
47192: ST_TO_ADDR
// end ; if btype = b_factory then
47193: LD_VAR 0 5
47197: PUSH
47198: LD_INT 3
47200: EQUAL
47201: IFFALSE 47219
// begin btype := b_workshop ;
47203: LD_ADDR_VAR 0 5
47207: PUSH
47208: LD_INT 2
47210: ST_TO_ADDR
// pos := 1 ;
47211: LD_ADDR_VAR 0 6
47215: PUSH
47216: LD_INT 1
47218: ST_TO_ADDR
// end ; if btype = b_barracks then
47219: LD_VAR 0 5
47223: PUSH
47224: LD_INT 5
47226: EQUAL
47227: IFFALSE 47237
// btype := b_armoury ;
47229: LD_ADDR_VAR 0 5
47233: PUSH
47234: LD_INT 4
47236: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
47237: LD_VAR 0 5
47241: PUSH
47242: LD_INT 7
47244: PUSH
47245: LD_INT 8
47247: PUSH
47248: EMPTY
47249: LIST
47250: LIST
47251: IN
47252: IFFALSE 47262
// btype := b_lab ;
47254: LD_ADDR_VAR 0 5
47258: PUSH
47259: LD_INT 6
47261: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
47262: LD_ADDR_EXP 79
47266: PUSH
47267: LD_EXP 79
47271: PPUSH
47272: LD_VAR 0 3
47276: PUSH
47277: LD_EXP 79
47281: PUSH
47282: LD_VAR 0 3
47286: ARRAY
47287: PUSH
47288: LD_INT 1
47290: PLUS
47291: PUSH
47292: EMPTY
47293: LIST
47294: LIST
47295: PPUSH
47296: LD_VAR 0 5
47300: PUSH
47301: LD_VAR 0 1
47305: PPUSH
47306: CALL_OW 250
47310: PUSH
47311: LD_VAR 0 1
47315: PPUSH
47316: CALL_OW 251
47320: PUSH
47321: LD_VAR 0 1
47325: PPUSH
47326: CALL_OW 254
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: LIST
47335: LIST
47336: PPUSH
47337: CALL 56229 0 3
47341: ST_TO_ADDR
// if pos = 1 then
47342: LD_VAR 0 6
47346: PUSH
47347: LD_INT 1
47349: EQUAL
47350: IFFALSE 47465
// begin tmp := mc_build_list [ i ] ;
47352: LD_ADDR_VAR 0 7
47356: PUSH
47357: LD_EXP 79
47361: PUSH
47362: LD_VAR 0 3
47366: ARRAY
47367: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47368: LD_VAR 0 7
47372: PPUSH
47373: LD_INT 2
47375: PUSH
47376: LD_INT 30
47378: PUSH
47379: LD_INT 0
47381: PUSH
47382: EMPTY
47383: LIST
47384: LIST
47385: PUSH
47386: LD_INT 30
47388: PUSH
47389: LD_INT 1
47391: PUSH
47392: EMPTY
47393: LIST
47394: LIST
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: LIST
47400: PPUSH
47401: CALL_OW 72
47405: IFFALSE 47415
// pos := 2 ;
47407: LD_ADDR_VAR 0 6
47411: PUSH
47412: LD_INT 2
47414: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47415: LD_ADDR_VAR 0 7
47419: PUSH
47420: LD_VAR 0 7
47424: PPUSH
47425: LD_VAR 0 6
47429: PPUSH
47430: LD_VAR 0 7
47434: PPUSH
47435: CALL 56555 0 3
47439: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47440: LD_ADDR_EXP 79
47444: PUSH
47445: LD_EXP 79
47449: PPUSH
47450: LD_VAR 0 3
47454: PPUSH
47455: LD_VAR 0 7
47459: PPUSH
47460: CALL_OW 1
47464: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47465: LD_VAR 0 1
47469: PUSH
47470: LD_EXP 74
47474: PUSH
47475: LD_VAR 0 3
47479: ARRAY
47480: IN
47481: IFFALSE 47520
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47483: LD_ADDR_EXP 74
47487: PUSH
47488: LD_EXP 74
47492: PPUSH
47493: LD_VAR 0 3
47497: PPUSH
47498: LD_EXP 74
47502: PUSH
47503: LD_VAR 0 3
47507: ARRAY
47508: PUSH
47509: LD_VAR 0 1
47513: DIFF
47514: PPUSH
47515: CALL_OW 1
47519: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47520: LD_VAR 0 1
47524: PUSH
47525: LD_EXP 81
47529: PUSH
47530: LD_VAR 0 3
47534: ARRAY
47535: IN
47536: IFFALSE 47575
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47538: LD_ADDR_EXP 81
47542: PUSH
47543: LD_EXP 81
47547: PPUSH
47548: LD_VAR 0 3
47552: PPUSH
47553: LD_EXP 81
47557: PUSH
47558: LD_VAR 0 3
47562: ARRAY
47563: PUSH
47564: LD_VAR 0 1
47568: DIFF
47569: PPUSH
47570: CALL_OW 1
47574: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47575: LD_VAR 0 1
47579: PUSH
47580: LD_EXP 93
47584: PUSH
47585: LD_VAR 0 3
47589: ARRAY
47590: IN
47591: IFFALSE 47630
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47593: LD_ADDR_EXP 93
47597: PUSH
47598: LD_EXP 93
47602: PPUSH
47603: LD_VAR 0 3
47607: PPUSH
47608: LD_EXP 93
47612: PUSH
47613: LD_VAR 0 3
47617: ARRAY
47618: PUSH
47619: LD_VAR 0 1
47623: DIFF
47624: PPUSH
47625: CALL_OW 1
47629: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47630: LD_VAR 0 1
47634: PUSH
47635: LD_EXP 96
47639: PUSH
47640: LD_VAR 0 3
47644: ARRAY
47645: IN
47646: IFFALSE 47685
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47648: LD_ADDR_EXP 96
47652: PUSH
47653: LD_EXP 96
47657: PPUSH
47658: LD_VAR 0 3
47662: PPUSH
47663: LD_EXP 96
47667: PUSH
47668: LD_VAR 0 3
47672: ARRAY
47673: PUSH
47674: LD_VAR 0 1
47678: DIFF
47679: PPUSH
47680: CALL_OW 1
47684: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47685: LD_VAR 0 1
47689: PUSH
47690: LD_EXP 83
47694: PUSH
47695: LD_VAR 0 3
47699: ARRAY
47700: IN
47701: IFFALSE 47740
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47703: LD_ADDR_EXP 83
47707: PUSH
47708: LD_EXP 83
47712: PPUSH
47713: LD_VAR 0 3
47717: PPUSH
47718: LD_EXP 83
47722: PUSH
47723: LD_VAR 0 3
47727: ARRAY
47728: PUSH
47729: LD_VAR 0 1
47733: DIFF
47734: PPUSH
47735: CALL_OW 1
47739: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47740: LD_VAR 0 1
47744: PUSH
47745: LD_EXP 82
47749: PUSH
47750: LD_VAR 0 3
47754: ARRAY
47755: IN
47756: IFFALSE 47795
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47758: LD_ADDR_EXP 82
47762: PUSH
47763: LD_EXP 82
47767: PPUSH
47768: LD_VAR 0 3
47772: PPUSH
47773: LD_EXP 82
47777: PUSH
47778: LD_VAR 0 3
47782: ARRAY
47783: PUSH
47784: LD_VAR 0 1
47788: DIFF
47789: PPUSH
47790: CALL_OW 1
47794: ST_TO_ADDR
// end ; break ;
47795: GO 47799
// end ;
47797: GO 46579
47799: POP
47800: POP
// end ;
47801: LD_VAR 0 2
47805: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47806: LD_INT 0
47808: PPUSH
47809: PPUSH
47810: PPUSH
// if not mc_bases or not skirmish then
47811: LD_EXP 74
47815: NOT
47816: PUSH
47817: LD_EXP 72
47821: NOT
47822: OR
47823: IFFALSE 47827
// exit ;
47825: GO 48042
// for i = 1 to mc_bases do
47827: LD_ADDR_VAR 0 3
47831: PUSH
47832: DOUBLE
47833: LD_INT 1
47835: DEC
47836: ST_TO_ADDR
47837: LD_EXP 74
47841: PUSH
47842: FOR_TO
47843: IFFALSE 48040
// begin if building in mc_construct_list [ i ] then
47845: LD_VAR 0 1
47849: PUSH
47850: LD_EXP 81
47854: PUSH
47855: LD_VAR 0 3
47859: ARRAY
47860: IN
47861: IFFALSE 48038
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47863: LD_ADDR_EXP 81
47867: PUSH
47868: LD_EXP 81
47872: PPUSH
47873: LD_VAR 0 3
47877: PPUSH
47878: LD_EXP 81
47882: PUSH
47883: LD_VAR 0 3
47887: ARRAY
47888: PUSH
47889: LD_VAR 0 1
47893: DIFF
47894: PPUSH
47895: CALL_OW 1
47899: ST_TO_ADDR
// if building in mc_lab [ i ] then
47900: LD_VAR 0 1
47904: PUSH
47905: LD_EXP 107
47909: PUSH
47910: LD_VAR 0 3
47914: ARRAY
47915: IN
47916: IFFALSE 47971
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47918: LD_ADDR_EXP 108
47922: PUSH
47923: LD_EXP 108
47927: PPUSH
47928: LD_VAR 0 3
47932: PPUSH
47933: LD_EXP 108
47937: PUSH
47938: LD_VAR 0 3
47942: ARRAY
47943: PPUSH
47944: LD_INT 1
47946: PPUSH
47947: LD_EXP 108
47951: PUSH
47952: LD_VAR 0 3
47956: ARRAY
47957: PPUSH
47958: LD_INT 0
47960: PPUSH
47961: CALL 55647 0 4
47965: PPUSH
47966: CALL_OW 1
47970: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47971: LD_VAR 0 1
47975: PUSH
47976: LD_EXP 74
47980: PUSH
47981: LD_VAR 0 3
47985: ARRAY
47986: IN
47987: NOT
47988: IFFALSE 48034
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47990: LD_ADDR_EXP 74
47994: PUSH
47995: LD_EXP 74
47999: PPUSH
48000: LD_VAR 0 3
48004: PUSH
48005: LD_EXP 74
48009: PUSH
48010: LD_VAR 0 3
48014: ARRAY
48015: PUSH
48016: LD_INT 1
48018: PLUS
48019: PUSH
48020: EMPTY
48021: LIST
48022: LIST
48023: PPUSH
48024: LD_VAR 0 1
48028: PPUSH
48029: CALL 56229 0 3
48033: ST_TO_ADDR
// exit ;
48034: POP
48035: POP
48036: GO 48042
// end ; end ;
48038: GO 47842
48040: POP
48041: POP
// end ;
48042: LD_VAR 0 2
48046: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
48047: LD_INT 0
48049: PPUSH
48050: PPUSH
48051: PPUSH
48052: PPUSH
48053: PPUSH
48054: PPUSH
48055: PPUSH
// if not mc_bases or not skirmish then
48056: LD_EXP 74
48060: NOT
48061: PUSH
48062: LD_EXP 72
48066: NOT
48067: OR
48068: IFFALSE 48072
// exit ;
48070: GO 48733
// for i = 1 to mc_bases do
48072: LD_ADDR_VAR 0 3
48076: PUSH
48077: DOUBLE
48078: LD_INT 1
48080: DEC
48081: ST_TO_ADDR
48082: LD_EXP 74
48086: PUSH
48087: FOR_TO
48088: IFFALSE 48731
// begin if building in mc_construct_list [ i ] then
48090: LD_VAR 0 1
48094: PUSH
48095: LD_EXP 81
48099: PUSH
48100: LD_VAR 0 3
48104: ARRAY
48105: IN
48106: IFFALSE 48729
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48108: LD_ADDR_EXP 81
48112: PUSH
48113: LD_EXP 81
48117: PPUSH
48118: LD_VAR 0 3
48122: PPUSH
48123: LD_EXP 81
48127: PUSH
48128: LD_VAR 0 3
48132: ARRAY
48133: PUSH
48134: LD_VAR 0 1
48138: DIFF
48139: PPUSH
48140: CALL_OW 1
48144: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48145: LD_ADDR_EXP 74
48149: PUSH
48150: LD_EXP 74
48154: PPUSH
48155: LD_VAR 0 3
48159: PUSH
48160: LD_EXP 74
48164: PUSH
48165: LD_VAR 0 3
48169: ARRAY
48170: PUSH
48171: LD_INT 1
48173: PLUS
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: PPUSH
48179: LD_VAR 0 1
48183: PPUSH
48184: CALL 56229 0 3
48188: ST_TO_ADDR
// btype := GetBType ( building ) ;
48189: LD_ADDR_VAR 0 5
48193: PUSH
48194: LD_VAR 0 1
48198: PPUSH
48199: CALL_OW 266
48203: ST_TO_ADDR
// side := GetSide ( building ) ;
48204: LD_ADDR_VAR 0 8
48208: PUSH
48209: LD_VAR 0 1
48213: PPUSH
48214: CALL_OW 255
48218: ST_TO_ADDR
// if btype = b_lab then
48219: LD_VAR 0 5
48223: PUSH
48224: LD_INT 6
48226: EQUAL
48227: IFFALSE 48277
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
48229: LD_ADDR_EXP 107
48233: PUSH
48234: LD_EXP 107
48238: PPUSH
48239: LD_VAR 0 3
48243: PUSH
48244: LD_EXP 107
48248: PUSH
48249: LD_VAR 0 3
48253: ARRAY
48254: PUSH
48255: LD_INT 1
48257: PLUS
48258: PUSH
48259: EMPTY
48260: LIST
48261: LIST
48262: PPUSH
48263: LD_VAR 0 1
48267: PPUSH
48268: CALL 56229 0 3
48272: ST_TO_ADDR
// exit ;
48273: POP
48274: POP
48275: GO 48733
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
48277: LD_VAR 0 5
48281: PUSH
48282: LD_INT 0
48284: PUSH
48285: LD_INT 2
48287: PUSH
48288: LD_INT 4
48290: PUSH
48291: EMPTY
48292: LIST
48293: LIST
48294: LIST
48295: IN
48296: IFFALSE 48420
// begin if btype = b_armoury then
48298: LD_VAR 0 5
48302: PUSH
48303: LD_INT 4
48305: EQUAL
48306: IFFALSE 48316
// btype := b_barracks ;
48308: LD_ADDR_VAR 0 5
48312: PUSH
48313: LD_INT 5
48315: ST_TO_ADDR
// if btype = b_depot then
48316: LD_VAR 0 5
48320: PUSH
48321: LD_INT 0
48323: EQUAL
48324: IFFALSE 48334
// btype := b_warehouse ;
48326: LD_ADDR_VAR 0 5
48330: PUSH
48331: LD_INT 1
48333: ST_TO_ADDR
// if btype = b_workshop then
48334: LD_VAR 0 5
48338: PUSH
48339: LD_INT 2
48341: EQUAL
48342: IFFALSE 48352
// btype := b_factory ;
48344: LD_ADDR_VAR 0 5
48348: PUSH
48349: LD_INT 3
48351: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48352: LD_VAR 0 5
48356: PPUSH
48357: LD_VAR 0 8
48361: PPUSH
48362: CALL_OW 323
48366: PUSH
48367: LD_INT 1
48369: EQUAL
48370: IFFALSE 48416
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48372: LD_ADDR_EXP 106
48376: PUSH
48377: LD_EXP 106
48381: PPUSH
48382: LD_VAR 0 3
48386: PUSH
48387: LD_EXP 106
48391: PUSH
48392: LD_VAR 0 3
48396: ARRAY
48397: PUSH
48398: LD_INT 1
48400: PLUS
48401: PUSH
48402: EMPTY
48403: LIST
48404: LIST
48405: PPUSH
48406: LD_VAR 0 1
48410: PPUSH
48411: CALL 56229 0 3
48415: ST_TO_ADDR
// exit ;
48416: POP
48417: POP
48418: GO 48733
// end ; if btype in [ b_bunker , b_turret ] then
48420: LD_VAR 0 5
48424: PUSH
48425: LD_INT 32
48427: PUSH
48428: LD_INT 33
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: IN
48435: IFFALSE 48725
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48437: LD_ADDR_EXP 82
48441: PUSH
48442: LD_EXP 82
48446: PPUSH
48447: LD_VAR 0 3
48451: PUSH
48452: LD_EXP 82
48456: PUSH
48457: LD_VAR 0 3
48461: ARRAY
48462: PUSH
48463: LD_INT 1
48465: PLUS
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: PPUSH
48471: LD_VAR 0 1
48475: PPUSH
48476: CALL 56229 0 3
48480: ST_TO_ADDR
// if btype = b_bunker then
48481: LD_VAR 0 5
48485: PUSH
48486: LD_INT 32
48488: EQUAL
48489: IFFALSE 48725
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48491: LD_ADDR_EXP 83
48495: PUSH
48496: LD_EXP 83
48500: PPUSH
48501: LD_VAR 0 3
48505: PUSH
48506: LD_EXP 83
48510: PUSH
48511: LD_VAR 0 3
48515: ARRAY
48516: PUSH
48517: LD_INT 1
48519: PLUS
48520: PUSH
48521: EMPTY
48522: LIST
48523: LIST
48524: PPUSH
48525: LD_VAR 0 1
48529: PPUSH
48530: CALL 56229 0 3
48534: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48535: LD_ADDR_VAR 0 6
48539: PUSH
48540: LD_EXP 74
48544: PUSH
48545: LD_VAR 0 3
48549: ARRAY
48550: PPUSH
48551: LD_INT 25
48553: PUSH
48554: LD_INT 1
48556: PUSH
48557: EMPTY
48558: LIST
48559: LIST
48560: PUSH
48561: LD_INT 3
48563: PUSH
48564: LD_INT 54
48566: PUSH
48567: EMPTY
48568: LIST
48569: PUSH
48570: EMPTY
48571: LIST
48572: LIST
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PPUSH
48578: CALL_OW 72
48582: ST_TO_ADDR
// if tmp then
48583: LD_VAR 0 6
48587: IFFALSE 48593
// exit ;
48589: POP
48590: POP
48591: GO 48733
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48593: LD_ADDR_VAR 0 6
48597: PUSH
48598: LD_EXP 74
48602: PUSH
48603: LD_VAR 0 3
48607: ARRAY
48608: PPUSH
48609: LD_INT 2
48611: PUSH
48612: LD_INT 30
48614: PUSH
48615: LD_INT 4
48617: PUSH
48618: EMPTY
48619: LIST
48620: LIST
48621: PUSH
48622: LD_INT 30
48624: PUSH
48625: LD_INT 5
48627: PUSH
48628: EMPTY
48629: LIST
48630: LIST
48631: PUSH
48632: EMPTY
48633: LIST
48634: LIST
48635: LIST
48636: PPUSH
48637: CALL_OW 72
48641: ST_TO_ADDR
// if not tmp then
48642: LD_VAR 0 6
48646: NOT
48647: IFFALSE 48653
// exit ;
48649: POP
48650: POP
48651: GO 48733
// for j in tmp do
48653: LD_ADDR_VAR 0 4
48657: PUSH
48658: LD_VAR 0 6
48662: PUSH
48663: FOR_IN
48664: IFFALSE 48723
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48666: LD_ADDR_VAR 0 7
48670: PUSH
48671: LD_VAR 0 4
48675: PPUSH
48676: CALL_OW 313
48680: PPUSH
48681: LD_INT 25
48683: PUSH
48684: LD_INT 1
48686: PUSH
48687: EMPTY
48688: LIST
48689: LIST
48690: PPUSH
48691: CALL_OW 72
48695: ST_TO_ADDR
// if units then
48696: LD_VAR 0 7
48700: IFFALSE 48721
// begin ComExitBuilding ( units [ 1 ] ) ;
48702: LD_VAR 0 7
48706: PUSH
48707: LD_INT 1
48709: ARRAY
48710: PPUSH
48711: CALL_OW 122
// exit ;
48715: POP
48716: POP
48717: POP
48718: POP
48719: GO 48733
// end ; end ;
48721: GO 48663
48723: POP
48724: POP
// end ; end ; exit ;
48725: POP
48726: POP
48727: GO 48733
// end ; end ;
48729: GO 48087
48731: POP
48732: POP
// end ;
48733: LD_VAR 0 2
48737: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48738: LD_INT 0
48740: PPUSH
48741: PPUSH
48742: PPUSH
48743: PPUSH
48744: PPUSH
48745: PPUSH
48746: PPUSH
// if not mc_bases or not skirmish then
48747: LD_EXP 74
48751: NOT
48752: PUSH
48753: LD_EXP 72
48757: NOT
48758: OR
48759: IFFALSE 48763
// exit ;
48761: GO 48994
// btype := GetBType ( building ) ;
48763: LD_ADDR_VAR 0 6
48767: PUSH
48768: LD_VAR 0 1
48772: PPUSH
48773: CALL_OW 266
48777: ST_TO_ADDR
// x := GetX ( building ) ;
48778: LD_ADDR_VAR 0 7
48782: PUSH
48783: LD_VAR 0 1
48787: PPUSH
48788: CALL_OW 250
48792: ST_TO_ADDR
// y := GetY ( building ) ;
48793: LD_ADDR_VAR 0 8
48797: PUSH
48798: LD_VAR 0 1
48802: PPUSH
48803: CALL_OW 251
48807: ST_TO_ADDR
// d := GetDir ( building ) ;
48808: LD_ADDR_VAR 0 9
48812: PUSH
48813: LD_VAR 0 1
48817: PPUSH
48818: CALL_OW 254
48822: ST_TO_ADDR
// for i = 1 to mc_bases do
48823: LD_ADDR_VAR 0 4
48827: PUSH
48828: DOUBLE
48829: LD_INT 1
48831: DEC
48832: ST_TO_ADDR
48833: LD_EXP 74
48837: PUSH
48838: FOR_TO
48839: IFFALSE 48992
// begin if not mc_build_list [ i ] then
48841: LD_EXP 79
48845: PUSH
48846: LD_VAR 0 4
48850: ARRAY
48851: NOT
48852: IFFALSE 48856
// continue ;
48854: GO 48838
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
48856: LD_VAR 0 6
48860: PUSH
48861: LD_VAR 0 7
48865: PUSH
48866: LD_VAR 0 8
48870: PUSH
48871: LD_VAR 0 9
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: LIST
48880: LIST
48881: PPUSH
48882: LD_EXP 79
48886: PUSH
48887: LD_VAR 0 4
48891: ARRAY
48892: PUSH
48893: LD_INT 1
48895: ARRAY
48896: PPUSH
48897: CALL 62398 0 2
48901: IFFALSE 48990
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
48903: LD_ADDR_EXP 79
48907: PUSH
48908: LD_EXP 79
48912: PPUSH
48913: LD_VAR 0 4
48917: PPUSH
48918: LD_EXP 79
48922: PUSH
48923: LD_VAR 0 4
48927: ARRAY
48928: PPUSH
48929: LD_INT 1
48931: PPUSH
48932: CALL_OW 3
48936: PPUSH
48937: CALL_OW 1
48941: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48942: LD_ADDR_EXP 81
48946: PUSH
48947: LD_EXP 81
48951: PPUSH
48952: LD_VAR 0 4
48956: PUSH
48957: LD_EXP 81
48961: PUSH
48962: LD_VAR 0 4
48966: ARRAY
48967: PUSH
48968: LD_INT 1
48970: PLUS
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PPUSH
48976: LD_VAR 0 1
48980: PPUSH
48981: CALL 56229 0 3
48985: ST_TO_ADDR
// exit ;
48986: POP
48987: POP
48988: GO 48994
// end ; end ;
48990: GO 48838
48992: POP
48993: POP
// end ;
48994: LD_VAR 0 3
48998: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48999: LD_INT 0
49001: PPUSH
49002: PPUSH
49003: PPUSH
// if not mc_bases or not skirmish then
49004: LD_EXP 74
49008: NOT
49009: PUSH
49010: LD_EXP 72
49014: NOT
49015: OR
49016: IFFALSE 49020
// exit ;
49018: GO 49210
// for i = 1 to mc_bases do
49020: LD_ADDR_VAR 0 4
49024: PUSH
49025: DOUBLE
49026: LD_INT 1
49028: DEC
49029: ST_TO_ADDR
49030: LD_EXP 74
49034: PUSH
49035: FOR_TO
49036: IFFALSE 49123
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
49038: LD_VAR 0 1
49042: PUSH
49043: LD_EXP 82
49047: PUSH
49048: LD_VAR 0 4
49052: ARRAY
49053: IN
49054: PUSH
49055: LD_VAR 0 1
49059: PUSH
49060: LD_EXP 83
49064: PUSH
49065: LD_VAR 0 4
49069: ARRAY
49070: IN
49071: NOT
49072: AND
49073: IFFALSE 49121
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49075: LD_ADDR_EXP 83
49079: PUSH
49080: LD_EXP 83
49084: PPUSH
49085: LD_VAR 0 4
49089: PUSH
49090: LD_EXP 83
49094: PUSH
49095: LD_VAR 0 4
49099: ARRAY
49100: PUSH
49101: LD_INT 1
49103: PLUS
49104: PUSH
49105: EMPTY
49106: LIST
49107: LIST
49108: PPUSH
49109: LD_VAR 0 1
49113: PPUSH
49114: CALL 56229 0 3
49118: ST_TO_ADDR
// break ;
49119: GO 49123
// end ; end ;
49121: GO 49035
49123: POP
49124: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
49125: LD_VAR 0 1
49129: PPUSH
49130: CALL_OW 257
49134: PUSH
49135: LD_EXP 100
49139: IN
49140: PUSH
49141: LD_VAR 0 1
49145: PPUSH
49146: CALL_OW 266
49150: PUSH
49151: LD_INT 5
49153: EQUAL
49154: AND
49155: PUSH
49156: LD_VAR 0 2
49160: PPUSH
49161: CALL_OW 110
49165: PUSH
49166: LD_INT 18
49168: NONEQUAL
49169: AND
49170: IFFALSE 49210
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
49172: LD_VAR 0 2
49176: PPUSH
49177: CALL_OW 257
49181: PUSH
49182: LD_INT 5
49184: PUSH
49185: LD_INT 8
49187: PUSH
49188: LD_INT 9
49190: PUSH
49191: EMPTY
49192: LIST
49193: LIST
49194: LIST
49195: IN
49196: IFFALSE 49210
// SetClass ( unit , 1 ) ;
49198: LD_VAR 0 2
49202: PPUSH
49203: LD_INT 1
49205: PPUSH
49206: CALL_OW 336
// end ;
49210: LD_VAR 0 3
49214: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
49215: LD_INT 0
49217: PPUSH
49218: PPUSH
// if not mc_bases or not skirmish then
49219: LD_EXP 74
49223: NOT
49224: PUSH
49225: LD_EXP 72
49229: NOT
49230: OR
49231: IFFALSE 49235
// exit ;
49233: GO 49351
// if GetLives ( abandoned_vehicle ) > 250 then
49235: LD_VAR 0 2
49239: PPUSH
49240: CALL_OW 256
49244: PUSH
49245: LD_INT 250
49247: GREATER
49248: IFFALSE 49252
// exit ;
49250: GO 49351
// for i = 1 to mc_bases do
49252: LD_ADDR_VAR 0 6
49256: PUSH
49257: DOUBLE
49258: LD_INT 1
49260: DEC
49261: ST_TO_ADDR
49262: LD_EXP 74
49266: PUSH
49267: FOR_TO
49268: IFFALSE 49349
// begin if driver in mc_bases [ i ] then
49270: LD_VAR 0 1
49274: PUSH
49275: LD_EXP 74
49279: PUSH
49280: LD_VAR 0 6
49284: ARRAY
49285: IN
49286: IFFALSE 49347
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49288: LD_VAR 0 1
49292: PPUSH
49293: LD_EXP 74
49297: PUSH
49298: LD_VAR 0 6
49302: ARRAY
49303: PPUSH
49304: LD_INT 2
49306: PUSH
49307: LD_INT 30
49309: PUSH
49310: LD_INT 0
49312: PUSH
49313: EMPTY
49314: LIST
49315: LIST
49316: PUSH
49317: LD_INT 30
49319: PUSH
49320: LD_INT 1
49322: PUSH
49323: EMPTY
49324: LIST
49325: LIST
49326: PUSH
49327: EMPTY
49328: LIST
49329: LIST
49330: LIST
49331: PPUSH
49332: CALL_OW 72
49336: PUSH
49337: LD_INT 1
49339: ARRAY
49340: PPUSH
49341: CALL_OW 112
// break ;
49345: GO 49349
// end ; end ;
49347: GO 49267
49349: POP
49350: POP
// end ; end_of_file
49351: LD_VAR 0 5
49355: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49356: LD_INT 0
49358: PPUSH
49359: PPUSH
// if exist_mode then
49360: LD_VAR 0 2
49364: IFFALSE 49389
// unit := CreateCharacter ( prefix & ident ) else
49366: LD_ADDR_VAR 0 5
49370: PUSH
49371: LD_VAR 0 3
49375: PUSH
49376: LD_VAR 0 1
49380: STR
49381: PPUSH
49382: CALL_OW 34
49386: ST_TO_ADDR
49387: GO 49404
// unit := NewCharacter ( ident ) ;
49389: LD_ADDR_VAR 0 5
49393: PUSH
49394: LD_VAR 0 1
49398: PPUSH
49399: CALL_OW 25
49403: ST_TO_ADDR
// result := unit ;
49404: LD_ADDR_VAR 0 4
49408: PUSH
49409: LD_VAR 0 5
49413: ST_TO_ADDR
// end ;
49414: LD_VAR 0 4
49418: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49419: LD_INT 0
49421: PPUSH
49422: PPUSH
// if not side or not nation then
49423: LD_VAR 0 1
49427: NOT
49428: PUSH
49429: LD_VAR 0 2
49433: NOT
49434: OR
49435: IFFALSE 49439
// exit ;
49437: GO 50083
// case nation of nation_american :
49439: LD_VAR 0 2
49443: PUSH
49444: LD_INT 1
49446: DOUBLE
49447: EQUAL
49448: IFTRUE 49452
49450: GO 49626
49452: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
49453: LD_ADDR_VAR 0 4
49457: PUSH
49458: LD_INT 35
49460: PUSH
49461: LD_INT 45
49463: PUSH
49464: LD_INT 46
49466: PUSH
49467: LD_INT 47
49469: PUSH
49470: LD_INT 1
49472: PUSH
49473: LD_INT 2
49475: PUSH
49476: LD_INT 6
49478: PUSH
49479: LD_INT 15
49481: PUSH
49482: LD_INT 16
49484: PUSH
49485: LD_INT 7
49487: PUSH
49488: LD_INT 12
49490: PUSH
49491: LD_INT 13
49493: PUSH
49494: LD_INT 10
49496: PUSH
49497: LD_INT 14
49499: PUSH
49500: LD_INT 20
49502: PUSH
49503: LD_INT 21
49505: PUSH
49506: LD_INT 22
49508: PUSH
49509: LD_INT 25
49511: PUSH
49512: LD_INT 32
49514: PUSH
49515: LD_INT 27
49517: PUSH
49518: LD_INT 36
49520: PUSH
49521: LD_INT 69
49523: PUSH
49524: LD_INT 39
49526: PUSH
49527: LD_INT 34
49529: PUSH
49530: LD_INT 40
49532: PUSH
49533: LD_INT 48
49535: PUSH
49536: LD_INT 49
49538: PUSH
49539: LD_INT 50
49541: PUSH
49542: LD_INT 51
49544: PUSH
49545: LD_INT 52
49547: PUSH
49548: LD_INT 53
49550: PUSH
49551: LD_INT 54
49553: PUSH
49554: LD_INT 55
49556: PUSH
49557: LD_INT 56
49559: PUSH
49560: LD_INT 57
49562: PUSH
49563: LD_INT 58
49565: PUSH
49566: LD_INT 59
49568: PUSH
49569: LD_INT 60
49571: PUSH
49572: LD_INT 61
49574: PUSH
49575: LD_INT 62
49577: PUSH
49578: LD_INT 80
49580: PUSH
49581: EMPTY
49582: LIST
49583: LIST
49584: LIST
49585: LIST
49586: LIST
49587: LIST
49588: LIST
49589: LIST
49590: LIST
49591: LIST
49592: LIST
49593: LIST
49594: LIST
49595: LIST
49596: LIST
49597: LIST
49598: LIST
49599: LIST
49600: LIST
49601: LIST
49602: LIST
49603: LIST
49604: LIST
49605: LIST
49606: LIST
49607: LIST
49608: LIST
49609: LIST
49610: LIST
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: ST_TO_ADDR
49624: GO 50007
49626: LD_INT 2
49628: DOUBLE
49629: EQUAL
49630: IFTRUE 49634
49632: GO 49816
49634: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
49635: LD_ADDR_VAR 0 4
49639: PUSH
49640: LD_INT 35
49642: PUSH
49643: LD_INT 45
49645: PUSH
49646: LD_INT 46
49648: PUSH
49649: LD_INT 47
49651: PUSH
49652: LD_INT 70
49654: PUSH
49655: LD_INT 1
49657: PUSH
49658: LD_INT 11
49660: PUSH
49661: LD_INT 3
49663: PUSH
49664: LD_INT 4
49666: PUSH
49667: LD_INT 5
49669: PUSH
49670: LD_INT 6
49672: PUSH
49673: LD_INT 15
49675: PUSH
49676: LD_INT 18
49678: PUSH
49679: LD_INT 7
49681: PUSH
49682: LD_INT 17
49684: PUSH
49685: LD_INT 8
49687: PUSH
49688: LD_INT 20
49690: PUSH
49691: LD_INT 21
49693: PUSH
49694: LD_INT 22
49696: PUSH
49697: LD_INT 72
49699: PUSH
49700: LD_INT 26
49702: PUSH
49703: LD_INT 69
49705: PUSH
49706: LD_INT 39
49708: PUSH
49709: LD_INT 40
49711: PUSH
49712: LD_INT 41
49714: PUSH
49715: LD_INT 42
49717: PUSH
49718: LD_INT 43
49720: PUSH
49721: LD_INT 48
49723: PUSH
49724: LD_INT 49
49726: PUSH
49727: LD_INT 50
49729: PUSH
49730: LD_INT 51
49732: PUSH
49733: LD_INT 52
49735: PUSH
49736: LD_INT 53
49738: PUSH
49739: LD_INT 54
49741: PUSH
49742: LD_INT 55
49744: PUSH
49745: LD_INT 56
49747: PUSH
49748: LD_INT 60
49750: PUSH
49751: LD_INT 61
49753: PUSH
49754: LD_INT 62
49756: PUSH
49757: LD_INT 66
49759: PUSH
49760: LD_INT 67
49762: PUSH
49763: LD_INT 68
49765: PUSH
49766: LD_INT 81
49768: PUSH
49769: EMPTY
49770: LIST
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: LIST
49776: LIST
49777: LIST
49778: LIST
49779: LIST
49780: LIST
49781: LIST
49782: LIST
49783: LIST
49784: LIST
49785: LIST
49786: LIST
49787: LIST
49788: LIST
49789: LIST
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: LIST
49795: LIST
49796: LIST
49797: LIST
49798: LIST
49799: LIST
49800: LIST
49801: LIST
49802: LIST
49803: LIST
49804: LIST
49805: LIST
49806: LIST
49807: LIST
49808: LIST
49809: LIST
49810: LIST
49811: LIST
49812: LIST
49813: ST_TO_ADDR
49814: GO 50007
49816: LD_INT 3
49818: DOUBLE
49819: EQUAL
49820: IFTRUE 49824
49822: GO 50006
49824: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
49825: LD_ADDR_VAR 0 4
49829: PUSH
49830: LD_INT 46
49832: PUSH
49833: LD_INT 47
49835: PUSH
49836: LD_INT 1
49838: PUSH
49839: LD_INT 2
49841: PUSH
49842: LD_INT 11
49844: PUSH
49845: LD_INT 9
49847: PUSH
49848: LD_INT 20
49850: PUSH
49851: LD_INT 19
49853: PUSH
49854: LD_INT 21
49856: PUSH
49857: LD_INT 24
49859: PUSH
49860: LD_INT 22
49862: PUSH
49863: LD_INT 25
49865: PUSH
49866: LD_INT 28
49868: PUSH
49869: LD_INT 29
49871: PUSH
49872: LD_INT 30
49874: PUSH
49875: LD_INT 31
49877: PUSH
49878: LD_INT 37
49880: PUSH
49881: LD_INT 38
49883: PUSH
49884: LD_INT 32
49886: PUSH
49887: LD_INT 27
49889: PUSH
49890: LD_INT 33
49892: PUSH
49893: LD_INT 69
49895: PUSH
49896: LD_INT 39
49898: PUSH
49899: LD_INT 34
49901: PUSH
49902: LD_INT 40
49904: PUSH
49905: LD_INT 71
49907: PUSH
49908: LD_INT 23
49910: PUSH
49911: LD_INT 44
49913: PUSH
49914: LD_INT 48
49916: PUSH
49917: LD_INT 49
49919: PUSH
49920: LD_INT 50
49922: PUSH
49923: LD_INT 51
49925: PUSH
49926: LD_INT 52
49928: PUSH
49929: LD_INT 53
49931: PUSH
49932: LD_INT 54
49934: PUSH
49935: LD_INT 55
49937: PUSH
49938: LD_INT 56
49940: PUSH
49941: LD_INT 57
49943: PUSH
49944: LD_INT 58
49946: PUSH
49947: LD_INT 59
49949: PUSH
49950: LD_INT 63
49952: PUSH
49953: LD_INT 64
49955: PUSH
49956: LD_INT 65
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: LIST
49963: LIST
49964: LIST
49965: LIST
49966: LIST
49967: LIST
49968: LIST
49969: LIST
49970: LIST
49971: LIST
49972: LIST
49973: LIST
49974: LIST
49975: LIST
49976: LIST
49977: LIST
49978: LIST
49979: LIST
49980: LIST
49981: LIST
49982: LIST
49983: LIST
49984: LIST
49985: LIST
49986: LIST
49987: LIST
49988: LIST
49989: LIST
49990: LIST
49991: LIST
49992: LIST
49993: LIST
49994: LIST
49995: LIST
49996: LIST
49997: LIST
49998: LIST
49999: LIST
50000: LIST
50001: LIST
50002: LIST
50003: ST_TO_ADDR
50004: GO 50007
50006: POP
// if state > - 1 and state < 3 then
50007: LD_VAR 0 3
50011: PUSH
50012: LD_INT 1
50014: NEG
50015: GREATER
50016: PUSH
50017: LD_VAR 0 3
50021: PUSH
50022: LD_INT 3
50024: LESS
50025: AND
50026: IFFALSE 50083
// for i in result do
50028: LD_ADDR_VAR 0 5
50032: PUSH
50033: LD_VAR 0 4
50037: PUSH
50038: FOR_IN
50039: IFFALSE 50081
// if GetTech ( i , side ) <> state then
50041: LD_VAR 0 5
50045: PPUSH
50046: LD_VAR 0 1
50050: PPUSH
50051: CALL_OW 321
50055: PUSH
50056: LD_VAR 0 3
50060: NONEQUAL
50061: IFFALSE 50079
// result := result diff i ;
50063: LD_ADDR_VAR 0 4
50067: PUSH
50068: LD_VAR 0 4
50072: PUSH
50073: LD_VAR 0 5
50077: DIFF
50078: ST_TO_ADDR
50079: GO 50038
50081: POP
50082: POP
// end ;
50083: LD_VAR 0 4
50087: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50088: LD_INT 0
50090: PPUSH
50091: PPUSH
50092: PPUSH
// result := true ;
50093: LD_ADDR_VAR 0 3
50097: PUSH
50098: LD_INT 1
50100: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50101: LD_ADDR_VAR 0 5
50105: PUSH
50106: LD_VAR 0 2
50110: PPUSH
50111: CALL_OW 480
50115: ST_TO_ADDR
// if not tmp then
50116: LD_VAR 0 5
50120: NOT
50121: IFFALSE 50125
// exit ;
50123: GO 50174
// for i in tmp do
50125: LD_ADDR_VAR 0 4
50129: PUSH
50130: LD_VAR 0 5
50134: PUSH
50135: FOR_IN
50136: IFFALSE 50172
// if GetTech ( i , side ) <> state_researched then
50138: LD_VAR 0 4
50142: PPUSH
50143: LD_VAR 0 1
50147: PPUSH
50148: CALL_OW 321
50152: PUSH
50153: LD_INT 2
50155: NONEQUAL
50156: IFFALSE 50170
// begin result := false ;
50158: LD_ADDR_VAR 0 3
50162: PUSH
50163: LD_INT 0
50165: ST_TO_ADDR
// exit ;
50166: POP
50167: POP
50168: GO 50174
// end ;
50170: GO 50135
50172: POP
50173: POP
// end ;
50174: LD_VAR 0 3
50178: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50179: LD_INT 0
50181: PPUSH
50182: PPUSH
50183: PPUSH
50184: PPUSH
50185: PPUSH
50186: PPUSH
50187: PPUSH
50188: PPUSH
50189: PPUSH
50190: PPUSH
50191: PPUSH
50192: PPUSH
50193: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50194: LD_VAR 0 1
50198: NOT
50199: PUSH
50200: LD_VAR 0 1
50204: PPUSH
50205: CALL_OW 257
50209: PUSH
50210: LD_INT 9
50212: NONEQUAL
50213: OR
50214: IFFALSE 50218
// exit ;
50216: GO 50791
// side := GetSide ( unit ) ;
50218: LD_ADDR_VAR 0 9
50222: PUSH
50223: LD_VAR 0 1
50227: PPUSH
50228: CALL_OW 255
50232: ST_TO_ADDR
// tech_space := tech_spacanom ;
50233: LD_ADDR_VAR 0 12
50237: PUSH
50238: LD_INT 29
50240: ST_TO_ADDR
// tech_time := tech_taurad ;
50241: LD_ADDR_VAR 0 13
50245: PUSH
50246: LD_INT 28
50248: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50249: LD_ADDR_VAR 0 11
50253: PUSH
50254: LD_VAR 0 1
50258: PPUSH
50259: CALL_OW 310
50263: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50264: LD_VAR 0 11
50268: PPUSH
50269: CALL_OW 247
50273: PUSH
50274: LD_INT 2
50276: EQUAL
50277: IFFALSE 50281
// exit ;
50279: GO 50791
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50281: LD_ADDR_VAR 0 8
50285: PUSH
50286: LD_INT 81
50288: PUSH
50289: LD_VAR 0 9
50293: PUSH
50294: EMPTY
50295: LIST
50296: LIST
50297: PUSH
50298: LD_INT 3
50300: PUSH
50301: LD_INT 21
50303: PUSH
50304: LD_INT 3
50306: PUSH
50307: EMPTY
50308: LIST
50309: LIST
50310: PUSH
50311: EMPTY
50312: LIST
50313: LIST
50314: PUSH
50315: EMPTY
50316: LIST
50317: LIST
50318: PPUSH
50319: CALL_OW 69
50323: ST_TO_ADDR
// if not tmp then
50324: LD_VAR 0 8
50328: NOT
50329: IFFALSE 50333
// exit ;
50331: GO 50791
// if in_unit then
50333: LD_VAR 0 11
50337: IFFALSE 50361
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50339: LD_ADDR_VAR 0 10
50343: PUSH
50344: LD_VAR 0 8
50348: PPUSH
50349: LD_VAR 0 11
50353: PPUSH
50354: CALL_OW 74
50358: ST_TO_ADDR
50359: GO 50381
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50361: LD_ADDR_VAR 0 10
50365: PUSH
50366: LD_VAR 0 8
50370: PPUSH
50371: LD_VAR 0 1
50375: PPUSH
50376: CALL_OW 74
50380: ST_TO_ADDR
// if not enemy then
50381: LD_VAR 0 10
50385: NOT
50386: IFFALSE 50390
// exit ;
50388: GO 50791
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50390: LD_VAR 0 11
50394: PUSH
50395: LD_VAR 0 11
50399: PPUSH
50400: LD_VAR 0 10
50404: PPUSH
50405: CALL_OW 296
50409: PUSH
50410: LD_INT 13
50412: GREATER
50413: AND
50414: PUSH
50415: LD_VAR 0 1
50419: PPUSH
50420: LD_VAR 0 10
50424: PPUSH
50425: CALL_OW 296
50429: PUSH
50430: LD_INT 12
50432: GREATER
50433: OR
50434: IFFALSE 50438
// exit ;
50436: GO 50791
// missile := [ 1 ] ;
50438: LD_ADDR_VAR 0 14
50442: PUSH
50443: LD_INT 1
50445: PUSH
50446: EMPTY
50447: LIST
50448: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50449: LD_VAR 0 9
50453: PPUSH
50454: LD_VAR 0 12
50458: PPUSH
50459: CALL_OW 325
50463: IFFALSE 50492
// missile := Insert ( missile , missile + 1 , 2 ) ;
50465: LD_ADDR_VAR 0 14
50469: PUSH
50470: LD_VAR 0 14
50474: PPUSH
50475: LD_VAR 0 14
50479: PUSH
50480: LD_INT 1
50482: PLUS
50483: PPUSH
50484: LD_INT 2
50486: PPUSH
50487: CALL_OW 2
50491: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50492: LD_VAR 0 9
50496: PPUSH
50497: LD_VAR 0 13
50501: PPUSH
50502: CALL_OW 325
50506: PUSH
50507: LD_VAR 0 10
50511: PPUSH
50512: CALL_OW 255
50516: PPUSH
50517: LD_VAR 0 13
50521: PPUSH
50522: CALL_OW 325
50526: NOT
50527: AND
50528: IFFALSE 50557
// missile := Insert ( missile , missile + 1 , 3 ) ;
50530: LD_ADDR_VAR 0 14
50534: PUSH
50535: LD_VAR 0 14
50539: PPUSH
50540: LD_VAR 0 14
50544: PUSH
50545: LD_INT 1
50547: PLUS
50548: PPUSH
50549: LD_INT 3
50551: PPUSH
50552: CALL_OW 2
50556: ST_TO_ADDR
// if missile < 2 then
50557: LD_VAR 0 14
50561: PUSH
50562: LD_INT 2
50564: LESS
50565: IFFALSE 50569
// exit ;
50567: GO 50791
// x := GetX ( enemy ) ;
50569: LD_ADDR_VAR 0 4
50573: PUSH
50574: LD_VAR 0 10
50578: PPUSH
50579: CALL_OW 250
50583: ST_TO_ADDR
// y := GetY ( enemy ) ;
50584: LD_ADDR_VAR 0 5
50588: PUSH
50589: LD_VAR 0 10
50593: PPUSH
50594: CALL_OW 251
50598: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50599: LD_ADDR_VAR 0 6
50603: PUSH
50604: LD_VAR 0 4
50608: PUSH
50609: LD_INT 1
50611: NEG
50612: PPUSH
50613: LD_INT 1
50615: PPUSH
50616: CALL_OW 12
50620: PLUS
50621: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50622: LD_ADDR_VAR 0 7
50626: PUSH
50627: LD_VAR 0 5
50631: PUSH
50632: LD_INT 1
50634: NEG
50635: PPUSH
50636: LD_INT 1
50638: PPUSH
50639: CALL_OW 12
50643: PLUS
50644: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50645: LD_VAR 0 6
50649: PPUSH
50650: LD_VAR 0 7
50654: PPUSH
50655: CALL_OW 488
50659: NOT
50660: IFFALSE 50682
// begin _x := x ;
50662: LD_ADDR_VAR 0 6
50666: PUSH
50667: LD_VAR 0 4
50671: ST_TO_ADDR
// _y := y ;
50672: LD_ADDR_VAR 0 7
50676: PUSH
50677: LD_VAR 0 5
50681: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50682: LD_ADDR_VAR 0 3
50686: PUSH
50687: LD_INT 1
50689: PPUSH
50690: LD_VAR 0 14
50694: PPUSH
50695: CALL_OW 12
50699: ST_TO_ADDR
// case i of 1 :
50700: LD_VAR 0 3
50704: PUSH
50705: LD_INT 1
50707: DOUBLE
50708: EQUAL
50709: IFTRUE 50713
50711: GO 50730
50713: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50714: LD_VAR 0 1
50718: PPUSH
50719: LD_VAR 0 10
50723: PPUSH
50724: CALL_OW 115
50728: GO 50791
50730: LD_INT 2
50732: DOUBLE
50733: EQUAL
50734: IFTRUE 50738
50736: GO 50760
50738: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50739: LD_VAR 0 1
50743: PPUSH
50744: LD_VAR 0 6
50748: PPUSH
50749: LD_VAR 0 7
50753: PPUSH
50754: CALL_OW 153
50758: GO 50791
50760: LD_INT 3
50762: DOUBLE
50763: EQUAL
50764: IFTRUE 50768
50766: GO 50790
50768: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50769: LD_VAR 0 1
50773: PPUSH
50774: LD_VAR 0 6
50778: PPUSH
50779: LD_VAR 0 7
50783: PPUSH
50784: CALL_OW 154
50788: GO 50791
50790: POP
// end ;
50791: LD_VAR 0 2
50795: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50796: LD_INT 0
50798: PPUSH
50799: PPUSH
50800: PPUSH
50801: PPUSH
50802: PPUSH
50803: PPUSH
// if not unit or not building then
50804: LD_VAR 0 1
50808: NOT
50809: PUSH
50810: LD_VAR 0 2
50814: NOT
50815: OR
50816: IFFALSE 50820
// exit ;
50818: GO 50978
// x := GetX ( building ) ;
50820: LD_ADDR_VAR 0 5
50824: PUSH
50825: LD_VAR 0 2
50829: PPUSH
50830: CALL_OW 250
50834: ST_TO_ADDR
// y := GetY ( building ) ;
50835: LD_ADDR_VAR 0 6
50839: PUSH
50840: LD_VAR 0 2
50844: PPUSH
50845: CALL_OW 251
50849: ST_TO_ADDR
// for i = 0 to 5 do
50850: LD_ADDR_VAR 0 4
50854: PUSH
50855: DOUBLE
50856: LD_INT 0
50858: DEC
50859: ST_TO_ADDR
50860: LD_INT 5
50862: PUSH
50863: FOR_TO
50864: IFFALSE 50976
// begin _x := ShiftX ( x , i , 3 ) ;
50866: LD_ADDR_VAR 0 7
50870: PUSH
50871: LD_VAR 0 5
50875: PPUSH
50876: LD_VAR 0 4
50880: PPUSH
50881: LD_INT 3
50883: PPUSH
50884: CALL_OW 272
50888: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50889: LD_ADDR_VAR 0 8
50893: PUSH
50894: LD_VAR 0 6
50898: PPUSH
50899: LD_VAR 0 4
50903: PPUSH
50904: LD_INT 3
50906: PPUSH
50907: CALL_OW 273
50911: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50912: LD_VAR 0 7
50916: PPUSH
50917: LD_VAR 0 8
50921: PPUSH
50922: CALL_OW 488
50926: NOT
50927: IFFALSE 50931
// continue ;
50929: GO 50863
// if HexInfo ( _x , _y ) = 0 then
50931: LD_VAR 0 7
50935: PPUSH
50936: LD_VAR 0 8
50940: PPUSH
50941: CALL_OW 428
50945: PUSH
50946: LD_INT 0
50948: EQUAL
50949: IFFALSE 50974
// begin ComMoveXY ( unit , _x , _y ) ;
50951: LD_VAR 0 1
50955: PPUSH
50956: LD_VAR 0 7
50960: PPUSH
50961: LD_VAR 0 8
50965: PPUSH
50966: CALL_OW 111
// exit ;
50970: POP
50971: POP
50972: GO 50978
// end ; end ;
50974: GO 50863
50976: POP
50977: POP
// end ;
50978: LD_VAR 0 3
50982: RET
// export function ScanBase ( side , base_area ) ; begin
50983: LD_INT 0
50985: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50986: LD_ADDR_VAR 0 3
50990: PUSH
50991: LD_VAR 0 2
50995: PPUSH
50996: LD_INT 81
50998: PUSH
50999: LD_VAR 0 1
51003: PUSH
51004: EMPTY
51005: LIST
51006: LIST
51007: PPUSH
51008: CALL_OW 70
51012: ST_TO_ADDR
// end ;
51013: LD_VAR 0 3
51017: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
51018: LD_INT 0
51020: PPUSH
51021: PPUSH
51022: PPUSH
51023: PPUSH
51024: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
51025: LD_VAR 0 1
51029: NOT
51030: PUSH
51031: LD_EXP 74
51035: PUSH
51036: LD_VAR 0 1
51040: ARRAY
51041: NOT
51042: OR
51043: PUSH
51044: LD_VAR 0 2
51048: NOT
51049: OR
51050: PUSH
51051: LD_VAR 0 3
51055: NOT
51056: OR
51057: IFFALSE 51061
// exit ;
51059: GO 51511
// side := mc_sides [ base ] ;
51061: LD_ADDR_VAR 0 6
51065: PUSH
51066: LD_EXP 100
51070: PUSH
51071: LD_VAR 0 1
51075: ARRAY
51076: ST_TO_ADDR
// if not side then
51077: LD_VAR 0 6
51081: NOT
51082: IFFALSE 51086
// exit ;
51084: GO 51511
// for i in solds do
51086: LD_ADDR_VAR 0 7
51090: PUSH
51091: LD_VAR 0 2
51095: PUSH
51096: FOR_IN
51097: IFFALSE 51158
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
51099: LD_VAR 0 7
51103: PPUSH
51104: CALL_OW 310
51108: PPUSH
51109: CALL_OW 266
51113: PUSH
51114: LD_INT 32
51116: PUSH
51117: LD_INT 31
51119: PUSH
51120: EMPTY
51121: LIST
51122: LIST
51123: IN
51124: IFFALSE 51144
// solds := solds diff i else
51126: LD_ADDR_VAR 0 2
51130: PUSH
51131: LD_VAR 0 2
51135: PUSH
51136: LD_VAR 0 7
51140: DIFF
51141: ST_TO_ADDR
51142: GO 51156
// SetTag ( i , 18 ) ;
51144: LD_VAR 0 7
51148: PPUSH
51149: LD_INT 18
51151: PPUSH
51152: CALL_OW 109
51156: GO 51096
51158: POP
51159: POP
// if not solds then
51160: LD_VAR 0 2
51164: NOT
51165: IFFALSE 51169
// exit ;
51167: GO 51511
// repeat wait ( 0 0$1 ) ;
51169: LD_INT 35
51171: PPUSH
51172: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
51176: LD_ADDR_VAR 0 5
51180: PUSH
51181: LD_VAR 0 6
51185: PPUSH
51186: LD_VAR 0 3
51190: PPUSH
51191: CALL 50983 0 2
51195: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
51196: LD_VAR 0 5
51200: NOT
51201: PUSH
51202: LD_VAR 0 5
51206: PUSH
51207: LD_INT 3
51209: GREATER
51210: OR
51211: PUSH
51212: LD_EXP 96
51216: PUSH
51217: LD_VAR 0 1
51221: ARRAY
51222: OR
51223: IFFALSE 51264
// begin for i in solds do
51225: LD_ADDR_VAR 0 7
51229: PUSH
51230: LD_VAR 0 2
51234: PUSH
51235: FOR_IN
51236: IFFALSE 51260
// if HasTask ( i ) then
51238: LD_VAR 0 7
51242: PPUSH
51243: CALL_OW 314
51247: IFFALSE 51258
// ComStop ( i ) ;
51249: LD_VAR 0 7
51253: PPUSH
51254: CALL_OW 141
51258: GO 51235
51260: POP
51261: POP
// break ;
51262: GO 51499
// end ; for i in solds do
51264: LD_ADDR_VAR 0 7
51268: PUSH
51269: LD_VAR 0 2
51273: PUSH
51274: FOR_IN
51275: IFFALSE 51491
// begin if IsInUnit ( i ) then
51277: LD_VAR 0 7
51281: PPUSH
51282: CALL_OW 310
51286: IFFALSE 51297
// ComExitBuilding ( i ) ;
51288: LD_VAR 0 7
51292: PPUSH
51293: CALL_OW 122
// if GetLives ( i ) > 333 then
51297: LD_VAR 0 7
51301: PPUSH
51302: CALL_OW 256
51306: PUSH
51307: LD_INT 333
51309: GREATER
51310: IFFALSE 51338
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51312: LD_VAR 0 7
51316: PPUSH
51317: LD_VAR 0 5
51321: PPUSH
51322: LD_VAR 0 7
51326: PPUSH
51327: CALL_OW 74
51331: PPUSH
51332: CALL_OW 115
51336: GO 51489
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
51338: LD_ADDR_VAR 0 8
51342: PUSH
51343: LD_EXP 74
51347: PUSH
51348: LD_VAR 0 1
51352: ARRAY
51353: PPUSH
51354: LD_INT 2
51356: PUSH
51357: LD_INT 30
51359: PUSH
51360: LD_INT 0
51362: PUSH
51363: EMPTY
51364: LIST
51365: LIST
51366: PUSH
51367: LD_INT 30
51369: PUSH
51370: LD_INT 1
51372: PUSH
51373: EMPTY
51374: LIST
51375: LIST
51376: PUSH
51377: LD_INT 30
51379: PUSH
51380: LD_INT 6
51382: PUSH
51383: EMPTY
51384: LIST
51385: LIST
51386: PUSH
51387: EMPTY
51388: LIST
51389: LIST
51390: LIST
51391: LIST
51392: PPUSH
51393: CALL_OW 72
51397: PPUSH
51398: LD_VAR 0 7
51402: PPUSH
51403: CALL_OW 74
51407: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
51408: LD_VAR 0 7
51412: PPUSH
51413: LD_VAR 0 8
51417: PPUSH
51418: CALL_OW 250
51422: PPUSH
51423: LD_INT 3
51425: PPUSH
51426: LD_INT 5
51428: PPUSH
51429: CALL_OW 272
51433: PPUSH
51434: LD_VAR 0 8
51438: PPUSH
51439: CALL_OW 251
51443: PPUSH
51444: LD_INT 3
51446: PPUSH
51447: LD_INT 5
51449: PPUSH
51450: CALL_OW 273
51454: PPUSH
51455: CALL_OW 111
// SetTag ( i , 0 ) ;
51459: LD_VAR 0 7
51463: PPUSH
51464: LD_INT 0
51466: PPUSH
51467: CALL_OW 109
// solds := solds diff i ;
51471: LD_ADDR_VAR 0 2
51475: PUSH
51476: LD_VAR 0 2
51480: PUSH
51481: LD_VAR 0 7
51485: DIFF
51486: ST_TO_ADDR
// continue ;
51487: GO 51274
// end ; end ;
51489: GO 51274
51491: POP
51492: POP
// until solds ;
51493: LD_VAR 0 2
51497: IFFALSE 51169
// MC_Reset ( base , 18 ) ;
51499: LD_VAR 0 1
51503: PPUSH
51504: LD_INT 18
51506: PPUSH
51507: CALL 23641 0 2
// end ;
51511: LD_VAR 0 4
51515: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
51516: LD_INT 0
51518: PPUSH
51519: PPUSH
51520: PPUSH
51521: PPUSH
51522: PPUSH
51523: PPUSH
51524: PPUSH
51525: PPUSH
51526: PPUSH
51527: PPUSH
51528: PPUSH
51529: PPUSH
51530: PPUSH
51531: PPUSH
51532: PPUSH
51533: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
51534: LD_ADDR_VAR 0 12
51538: PUSH
51539: LD_EXP 74
51543: PUSH
51544: LD_VAR 0 1
51548: ARRAY
51549: PPUSH
51550: LD_INT 25
51552: PUSH
51553: LD_INT 3
51555: PUSH
51556: EMPTY
51557: LIST
51558: LIST
51559: PPUSH
51560: CALL_OW 72
51564: ST_TO_ADDR
// if mc_remote_driver [ base ] then
51565: LD_EXP 114
51569: PUSH
51570: LD_VAR 0 1
51574: ARRAY
51575: IFFALSE 51599
// mechs := mechs diff mc_remote_driver [ base ] ;
51577: LD_ADDR_VAR 0 12
51581: PUSH
51582: LD_VAR 0 12
51586: PUSH
51587: LD_EXP 114
51591: PUSH
51592: LD_VAR 0 1
51596: ARRAY
51597: DIFF
51598: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51599: LD_ADDR_VAR 0 8
51603: PUSH
51604: LD_EXP 74
51608: PUSH
51609: LD_VAR 0 1
51613: ARRAY
51614: PPUSH
51615: LD_INT 2
51617: PUSH
51618: LD_INT 25
51620: PUSH
51621: LD_INT 1
51623: PUSH
51624: EMPTY
51625: LIST
51626: LIST
51627: PUSH
51628: LD_INT 25
51630: PUSH
51631: LD_INT 5
51633: PUSH
51634: EMPTY
51635: LIST
51636: LIST
51637: PUSH
51638: LD_INT 25
51640: PUSH
51641: LD_INT 8
51643: PUSH
51644: EMPTY
51645: LIST
51646: LIST
51647: PUSH
51648: LD_INT 25
51650: PUSH
51651: LD_INT 9
51653: PUSH
51654: EMPTY
51655: LIST
51656: LIST
51657: PUSH
51658: EMPTY
51659: LIST
51660: LIST
51661: LIST
51662: LIST
51663: LIST
51664: PPUSH
51665: CALL_OW 72
51669: ST_TO_ADDR
// if not defenders and not solds then
51670: LD_VAR 0 2
51674: NOT
51675: PUSH
51676: LD_VAR 0 8
51680: NOT
51681: AND
51682: IFFALSE 51686
// exit ;
51684: GO 53060
// depot_under_attack := false ;
51686: LD_ADDR_VAR 0 16
51690: PUSH
51691: LD_INT 0
51693: ST_TO_ADDR
// sold_defenders := [ ] ;
51694: LD_ADDR_VAR 0 17
51698: PUSH
51699: EMPTY
51700: ST_TO_ADDR
// if mechs then
51701: LD_VAR 0 12
51705: IFFALSE 51834
// for i in defenders do
51707: LD_ADDR_VAR 0 5
51711: PUSH
51712: LD_VAR 0 2
51716: PUSH
51717: FOR_IN
51718: IFFALSE 51832
// begin SetTag ( i , 20 ) ;
51720: LD_VAR 0 5
51724: PPUSH
51725: LD_INT 20
51727: PPUSH
51728: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
51732: LD_VAR 0 5
51736: PPUSH
51737: CALL_OW 263
51741: PUSH
51742: LD_INT 1
51744: EQUAL
51745: PUSH
51746: LD_VAR 0 5
51750: PPUSH
51751: CALL_OW 311
51755: NOT
51756: AND
51757: PUSH
51758: LD_VAR 0 12
51762: AND
51763: IFFALSE 51830
// begin un := mechs [ 1 ] ;
51765: LD_ADDR_VAR 0 10
51769: PUSH
51770: LD_VAR 0 12
51774: PUSH
51775: LD_INT 1
51777: ARRAY
51778: ST_TO_ADDR
// ComExitBuilding ( un ) ;
51779: LD_VAR 0 10
51783: PPUSH
51784: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
51788: LD_VAR 0 10
51792: PPUSH
51793: LD_VAR 0 5
51797: PPUSH
51798: CALL_OW 180
// SetTag ( un , 19 ) ;
51802: LD_VAR 0 10
51806: PPUSH
51807: LD_INT 19
51809: PPUSH
51810: CALL_OW 109
// mechs := mechs diff un ;
51814: LD_ADDR_VAR 0 12
51818: PUSH
51819: LD_VAR 0 12
51823: PUSH
51824: LD_VAR 0 10
51828: DIFF
51829: ST_TO_ADDR
// end ; end ;
51830: GO 51717
51832: POP
51833: POP
// if solds then
51834: LD_VAR 0 8
51838: IFFALSE 51897
// for i in solds do
51840: LD_ADDR_VAR 0 5
51844: PUSH
51845: LD_VAR 0 8
51849: PUSH
51850: FOR_IN
51851: IFFALSE 51895
// if not GetTag ( i ) then
51853: LD_VAR 0 5
51857: PPUSH
51858: CALL_OW 110
51862: NOT
51863: IFFALSE 51893
// begin defenders := defenders union i ;
51865: LD_ADDR_VAR 0 2
51869: PUSH
51870: LD_VAR 0 2
51874: PUSH
51875: LD_VAR 0 5
51879: UNION
51880: ST_TO_ADDR
// SetTag ( i , 18 ) ;
51881: LD_VAR 0 5
51885: PPUSH
51886: LD_INT 18
51888: PPUSH
51889: CALL_OW 109
// end ;
51893: GO 51850
51895: POP
51896: POP
// repeat wait ( 0 0$1 ) ;
51897: LD_INT 35
51899: PPUSH
51900: CALL_OW 67
// enemy := mc_scan [ base ] ;
51904: LD_ADDR_VAR 0 3
51908: PUSH
51909: LD_EXP 97
51913: PUSH
51914: LD_VAR 0 1
51918: ARRAY
51919: ST_TO_ADDR
// for i in defenders do
51920: LD_ADDR_VAR 0 5
51924: PUSH
51925: LD_VAR 0 2
51929: PUSH
51930: FOR_IN
51931: IFFALSE 52661
// begin e := NearestUnitToUnit ( enemy , i ) ;
51933: LD_ADDR_VAR 0 13
51937: PUSH
51938: LD_VAR 0 3
51942: PPUSH
51943: LD_VAR 0 5
51947: PPUSH
51948: CALL_OW 74
51952: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
51953: LD_ADDR_VAR 0 16
51957: PUSH
51958: LD_EXP 74
51962: PUSH
51963: LD_VAR 0 1
51967: ARRAY
51968: PPUSH
51969: LD_INT 2
51971: PUSH
51972: LD_INT 30
51974: PUSH
51975: LD_INT 0
51977: PUSH
51978: EMPTY
51979: LIST
51980: LIST
51981: PUSH
51982: LD_INT 30
51984: PUSH
51985: LD_INT 1
51987: PUSH
51988: EMPTY
51989: LIST
51990: LIST
51991: PUSH
51992: EMPTY
51993: LIST
51994: LIST
51995: LIST
51996: PPUSH
51997: CALL_OW 72
52001: NOT
52002: PUSH
52003: LD_EXP 74
52007: PUSH
52008: LD_VAR 0 1
52012: ARRAY
52013: PPUSH
52014: LD_INT 2
52016: PUSH
52017: LD_INT 30
52019: PUSH
52020: LD_INT 0
52022: PUSH
52023: EMPTY
52024: LIST
52025: LIST
52026: PUSH
52027: LD_INT 30
52029: PUSH
52030: LD_INT 1
52032: PUSH
52033: EMPTY
52034: LIST
52035: LIST
52036: PUSH
52037: EMPTY
52038: LIST
52039: LIST
52040: LIST
52041: PPUSH
52042: CALL_OW 72
52046: PPUSH
52047: CALL_OW 256
52051: PUSH
52052: LD_INT 600
52054: LESS
52055: OR
52056: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
52057: LD_VAR 0 5
52061: PPUSH
52062: CALL_OW 247
52066: PUSH
52067: LD_INT 2
52069: DOUBLE
52070: EQUAL
52071: IFTRUE 52075
52073: GO 52367
52075: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
52076: LD_VAR 0 5
52080: PPUSH
52081: CALL_OW 256
52085: PUSH
52086: LD_INT 650
52088: GREATER
52089: PUSH
52090: LD_VAR 0 5
52094: PPUSH
52095: LD_VAR 0 13
52099: PPUSH
52100: CALL_OW 296
52104: PUSH
52105: LD_INT 40
52107: LESS
52108: PUSH
52109: LD_VAR 0 13
52113: PPUSH
52114: LD_EXP 99
52118: PUSH
52119: LD_VAR 0 1
52123: ARRAY
52124: PPUSH
52125: CALL_OW 308
52129: OR
52130: AND
52131: IFFALSE 52149
// ComAttackUnit ( i , e ) else
52133: LD_VAR 0 5
52137: PPUSH
52138: LD_VAR 0 13
52142: PPUSH
52143: CALL_OW 115
52147: GO 52250
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
52149: LD_VAR 0 13
52153: PPUSH
52154: LD_EXP 99
52158: PUSH
52159: LD_VAR 0 1
52163: ARRAY
52164: PPUSH
52165: CALL_OW 308
52169: NOT
52170: PUSH
52171: LD_VAR 0 5
52175: PPUSH
52176: LD_VAR 0 13
52180: PPUSH
52181: CALL_OW 296
52185: PUSH
52186: LD_INT 40
52188: GREATEREQUAL
52189: AND
52190: PUSH
52191: LD_VAR 0 5
52195: PPUSH
52196: CALL_OW 256
52200: PUSH
52201: LD_INT 650
52203: LESSEQUAL
52204: OR
52205: PUSH
52206: LD_VAR 0 5
52210: PPUSH
52211: LD_EXP 98
52215: PUSH
52216: LD_VAR 0 1
52220: ARRAY
52221: PPUSH
52222: CALL_OW 308
52226: NOT
52227: AND
52228: IFFALSE 52250
// ComMoveToArea ( i , mc_parking [ base ] ) ;
52230: LD_VAR 0 5
52234: PPUSH
52235: LD_EXP 98
52239: PUSH
52240: LD_VAR 0 1
52244: ARRAY
52245: PPUSH
52246: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
52250: LD_VAR 0 5
52254: PPUSH
52255: CALL_OW 256
52259: PUSH
52260: LD_INT 998
52262: LESS
52263: PUSH
52264: LD_VAR 0 5
52268: PPUSH
52269: CALL_OW 263
52273: PUSH
52274: LD_INT 1
52276: EQUAL
52277: AND
52278: PUSH
52279: LD_VAR 0 5
52283: PPUSH
52284: CALL_OW 311
52288: AND
52289: PUSH
52290: LD_VAR 0 5
52294: PPUSH
52295: LD_EXP 98
52299: PUSH
52300: LD_VAR 0 1
52304: ARRAY
52305: PPUSH
52306: CALL_OW 308
52310: AND
52311: IFFALSE 52365
// begin mech := IsDrivenBy ( i ) ;
52313: LD_ADDR_VAR 0 9
52317: PUSH
52318: LD_VAR 0 5
52322: PPUSH
52323: CALL_OW 311
52327: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
52328: LD_VAR 0 9
52332: PPUSH
52333: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
52337: LD_VAR 0 9
52341: PPUSH
52342: LD_VAR 0 5
52346: PPUSH
52347: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
52351: LD_VAR 0 9
52355: PPUSH
52356: LD_VAR 0 5
52360: PPUSH
52361: CALL_OW 180
// end ; end ; unit_human :
52365: GO 52632
52367: LD_INT 1
52369: DOUBLE
52370: EQUAL
52371: IFTRUE 52375
52373: GO 52631
52375: POP
// begin b := IsInUnit ( i ) ;
52376: LD_ADDR_VAR 0 18
52380: PUSH
52381: LD_VAR 0 5
52385: PPUSH
52386: CALL_OW 310
52390: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
52391: LD_ADDR_VAR 0 19
52395: PUSH
52396: LD_VAR 0 18
52400: NOT
52401: PUSH
52402: LD_VAR 0 18
52406: PPUSH
52407: CALL_OW 266
52411: PUSH
52412: LD_INT 32
52414: PUSH
52415: LD_INT 31
52417: PUSH
52418: EMPTY
52419: LIST
52420: LIST
52421: IN
52422: OR
52423: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
52424: LD_VAR 0 16
52428: PUSH
52429: LD_VAR 0 2
52433: PPUSH
52434: LD_INT 21
52436: PUSH
52437: LD_INT 2
52439: PUSH
52440: EMPTY
52441: LIST
52442: LIST
52443: PPUSH
52444: CALL_OW 72
52448: PUSH
52449: LD_INT 1
52451: LESSEQUAL
52452: OR
52453: PUSH
52454: LD_VAR 0 19
52458: AND
52459: PUSH
52460: LD_VAR 0 5
52464: PUSH
52465: LD_VAR 0 17
52469: IN
52470: NOT
52471: AND
52472: IFFALSE 52565
// begin if b then
52474: LD_VAR 0 18
52478: IFFALSE 52527
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
52480: LD_VAR 0 18
52484: PPUSH
52485: LD_VAR 0 3
52489: PPUSH
52490: LD_VAR 0 18
52494: PPUSH
52495: CALL_OW 74
52499: PPUSH
52500: CALL_OW 296
52504: PUSH
52505: LD_INT 10
52507: LESS
52508: PUSH
52509: LD_VAR 0 18
52513: PPUSH
52514: CALL_OW 461
52518: PUSH
52519: LD_INT 7
52521: NONEQUAL
52522: AND
52523: IFFALSE 52527
// continue ;
52525: GO 51930
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
52527: LD_ADDR_VAR 0 17
52531: PUSH
52532: LD_VAR 0 17
52536: PPUSH
52537: LD_VAR 0 17
52541: PUSH
52542: LD_INT 1
52544: PLUS
52545: PPUSH
52546: LD_VAR 0 5
52550: PPUSH
52551: CALL_OW 1
52555: ST_TO_ADDR
// ComExitBuilding ( i ) ;
52556: LD_VAR 0 5
52560: PPUSH
52561: CALL_OW 122
// end ; if sold_defenders then
52565: LD_VAR 0 17
52569: IFFALSE 52629
// if i in sold_defenders then
52571: LD_VAR 0 5
52575: PUSH
52576: LD_VAR 0 17
52580: IN
52581: IFFALSE 52629
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
52583: LD_VAR 0 5
52587: PPUSH
52588: CALL_OW 314
52592: NOT
52593: PUSH
52594: LD_VAR 0 5
52598: PPUSH
52599: LD_VAR 0 13
52603: PPUSH
52604: CALL_OW 296
52608: PUSH
52609: LD_INT 30
52611: LESS
52612: AND
52613: IFFALSE 52629
// ComAttackUnit ( i , e ) ;
52615: LD_VAR 0 5
52619: PPUSH
52620: LD_VAR 0 13
52624: PPUSH
52625: CALL_OW 115
// end ; end ; end ;
52629: GO 52632
52631: POP
// if IsDead ( i ) then
52632: LD_VAR 0 5
52636: PPUSH
52637: CALL_OW 301
52641: IFFALSE 52659
// defenders := defenders diff i ;
52643: LD_ADDR_VAR 0 2
52647: PUSH
52648: LD_VAR 0 2
52652: PUSH
52653: LD_VAR 0 5
52657: DIFF
52658: ST_TO_ADDR
// end ;
52659: GO 51930
52661: POP
52662: POP
// until not enemy or not defenders ;
52663: LD_VAR 0 3
52667: NOT
52668: PUSH
52669: LD_VAR 0 2
52673: NOT
52674: OR
52675: IFFALSE 51897
// MC_Reset ( base , 18 ) ;
52677: LD_VAR 0 1
52681: PPUSH
52682: LD_INT 18
52684: PPUSH
52685: CALL 23641 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52689: LD_ADDR_VAR 0 2
52693: PUSH
52694: LD_VAR 0 2
52698: PUSH
52699: LD_VAR 0 2
52703: PPUSH
52704: LD_INT 2
52706: PUSH
52707: LD_INT 25
52709: PUSH
52710: LD_INT 1
52712: PUSH
52713: EMPTY
52714: LIST
52715: LIST
52716: PUSH
52717: LD_INT 25
52719: PUSH
52720: LD_INT 5
52722: PUSH
52723: EMPTY
52724: LIST
52725: LIST
52726: PUSH
52727: LD_INT 25
52729: PUSH
52730: LD_INT 8
52732: PUSH
52733: EMPTY
52734: LIST
52735: LIST
52736: PUSH
52737: LD_INT 25
52739: PUSH
52740: LD_INT 9
52742: PUSH
52743: EMPTY
52744: LIST
52745: LIST
52746: PUSH
52747: EMPTY
52748: LIST
52749: LIST
52750: LIST
52751: LIST
52752: LIST
52753: PPUSH
52754: CALL_OW 72
52758: DIFF
52759: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
52760: LD_VAR 0 3
52764: NOT
52765: PUSH
52766: LD_VAR 0 2
52770: PPUSH
52771: LD_INT 21
52773: PUSH
52774: LD_INT 2
52776: PUSH
52777: EMPTY
52778: LIST
52779: LIST
52780: PPUSH
52781: CALL_OW 72
52785: AND
52786: IFFALSE 53048
// begin tmp := FilterByTag ( defenders , 19 ) ;
52788: LD_ADDR_VAR 0 11
52792: PUSH
52793: LD_VAR 0 2
52797: PPUSH
52798: LD_INT 19
52800: PPUSH
52801: CALL 89489 0 2
52805: ST_TO_ADDR
// if tmp then
52806: LD_VAR 0 11
52810: IFFALSE 52880
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
52812: LD_ADDR_VAR 0 11
52816: PUSH
52817: LD_VAR 0 11
52821: PPUSH
52822: LD_INT 25
52824: PUSH
52825: LD_INT 3
52827: PUSH
52828: EMPTY
52829: LIST
52830: LIST
52831: PPUSH
52832: CALL_OW 72
52836: ST_TO_ADDR
// if tmp then
52837: LD_VAR 0 11
52841: IFFALSE 52880
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
52843: LD_ADDR_EXP 86
52847: PUSH
52848: LD_EXP 86
52852: PPUSH
52853: LD_VAR 0 1
52857: PPUSH
52858: LD_EXP 86
52862: PUSH
52863: LD_VAR 0 1
52867: ARRAY
52868: PUSH
52869: LD_VAR 0 11
52873: UNION
52874: PPUSH
52875: CALL_OW 1
52879: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
52880: LD_VAR 0 1
52884: PPUSH
52885: LD_INT 19
52887: PPUSH
52888: CALL 23641 0 2
// repeat wait ( 0 0$1 ) ;
52892: LD_INT 35
52894: PPUSH
52895: CALL_OW 67
// for i in defenders do
52899: LD_ADDR_VAR 0 5
52903: PUSH
52904: LD_VAR 0 2
52908: PUSH
52909: FOR_IN
52910: IFFALSE 52999
// begin if not IsInArea ( i , mc_parking [ base ] ) then
52912: LD_VAR 0 5
52916: PPUSH
52917: LD_EXP 98
52921: PUSH
52922: LD_VAR 0 1
52926: ARRAY
52927: PPUSH
52928: CALL_OW 308
52932: NOT
52933: IFFALSE 52957
// ComMoveToArea ( i , mc_parking [ base ] ) else
52935: LD_VAR 0 5
52939: PPUSH
52940: LD_EXP 98
52944: PUSH
52945: LD_VAR 0 1
52949: ARRAY
52950: PPUSH
52951: CALL_OW 113
52955: GO 52997
// if GetControl ( i ) = control_manual then
52957: LD_VAR 0 5
52961: PPUSH
52962: CALL_OW 263
52966: PUSH
52967: LD_INT 1
52969: EQUAL
52970: IFFALSE 52997
// if IsDrivenBy ( i ) then
52972: LD_VAR 0 5
52976: PPUSH
52977: CALL_OW 311
52981: IFFALSE 52997
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
52983: LD_VAR 0 5
52987: PPUSH
52988: CALL_OW 311
52992: PPUSH
52993: CALL_OW 121
// end ;
52997: GO 52909
52999: POP
53000: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
53001: LD_VAR 0 2
53005: PPUSH
53006: LD_INT 95
53008: PUSH
53009: LD_EXP 98
53013: PUSH
53014: LD_VAR 0 1
53018: ARRAY
53019: PUSH
53020: EMPTY
53021: LIST
53022: LIST
53023: PPUSH
53024: CALL_OW 72
53028: PUSH
53029: LD_VAR 0 2
53033: EQUAL
53034: PUSH
53035: LD_EXP 97
53039: PUSH
53040: LD_VAR 0 1
53044: ARRAY
53045: OR
53046: IFFALSE 52892
// end ; MC_Reset ( base , 20 ) ;
53048: LD_VAR 0 1
53052: PPUSH
53053: LD_INT 20
53055: PPUSH
53056: CALL 23641 0 2
// end ;
53060: LD_VAR 0 4
53064: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53065: LD_INT 0
53067: PPUSH
53068: PPUSH
53069: PPUSH
53070: PPUSH
// result := false ;
53071: LD_ADDR_VAR 0 2
53075: PUSH
53076: LD_INT 0
53078: ST_TO_ADDR
// side := GetSide ( unit ) ;
53079: LD_ADDR_VAR 0 3
53083: PUSH
53084: LD_VAR 0 1
53088: PPUSH
53089: CALL_OW 255
53093: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53094: LD_ADDR_VAR 0 4
53098: PUSH
53099: LD_VAR 0 1
53103: PPUSH
53104: CALL_OW 248
53108: ST_TO_ADDR
// case nat of 1 :
53109: LD_VAR 0 4
53113: PUSH
53114: LD_INT 1
53116: DOUBLE
53117: EQUAL
53118: IFTRUE 53122
53120: GO 53133
53122: POP
// tech := tech_lassight ; 2 :
53123: LD_ADDR_VAR 0 5
53127: PUSH
53128: LD_INT 12
53130: ST_TO_ADDR
53131: GO 53172
53133: LD_INT 2
53135: DOUBLE
53136: EQUAL
53137: IFTRUE 53141
53139: GO 53152
53141: POP
// tech := tech_mortar ; 3 :
53142: LD_ADDR_VAR 0 5
53146: PUSH
53147: LD_INT 41
53149: ST_TO_ADDR
53150: GO 53172
53152: LD_INT 3
53154: DOUBLE
53155: EQUAL
53156: IFTRUE 53160
53158: GO 53171
53160: POP
// tech := tech_bazooka ; end ;
53161: LD_ADDR_VAR 0 5
53165: PUSH
53166: LD_INT 44
53168: ST_TO_ADDR
53169: GO 53172
53171: POP
// if Researched ( side , tech ) then
53172: LD_VAR 0 3
53176: PPUSH
53177: LD_VAR 0 5
53181: PPUSH
53182: CALL_OW 325
53186: IFFALSE 53213
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53188: LD_ADDR_VAR 0 2
53192: PUSH
53193: LD_INT 5
53195: PUSH
53196: LD_INT 8
53198: PUSH
53199: LD_INT 9
53201: PUSH
53202: EMPTY
53203: LIST
53204: LIST
53205: LIST
53206: PUSH
53207: LD_VAR 0 4
53211: ARRAY
53212: ST_TO_ADDR
// end ;
53213: LD_VAR 0 2
53217: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53218: LD_INT 0
53220: PPUSH
53221: PPUSH
53222: PPUSH
// if not mines then
53223: LD_VAR 0 2
53227: NOT
53228: IFFALSE 53232
// exit ;
53230: GO 53376
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53232: LD_ADDR_VAR 0 5
53236: PUSH
53237: LD_INT 81
53239: PUSH
53240: LD_VAR 0 1
53244: PUSH
53245: EMPTY
53246: LIST
53247: LIST
53248: PUSH
53249: LD_INT 3
53251: PUSH
53252: LD_INT 21
53254: PUSH
53255: LD_INT 3
53257: PUSH
53258: EMPTY
53259: LIST
53260: LIST
53261: PUSH
53262: EMPTY
53263: LIST
53264: LIST
53265: PUSH
53266: EMPTY
53267: LIST
53268: LIST
53269: PPUSH
53270: CALL_OW 69
53274: ST_TO_ADDR
// for i in mines do
53275: LD_ADDR_VAR 0 4
53279: PUSH
53280: LD_VAR 0 2
53284: PUSH
53285: FOR_IN
53286: IFFALSE 53374
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53288: LD_VAR 0 4
53292: PUSH
53293: LD_INT 1
53295: ARRAY
53296: PPUSH
53297: LD_VAR 0 4
53301: PUSH
53302: LD_INT 2
53304: ARRAY
53305: PPUSH
53306: CALL_OW 458
53310: NOT
53311: IFFALSE 53315
// continue ;
53313: GO 53285
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53315: LD_VAR 0 4
53319: PUSH
53320: LD_INT 1
53322: ARRAY
53323: PPUSH
53324: LD_VAR 0 4
53328: PUSH
53329: LD_INT 2
53331: ARRAY
53332: PPUSH
53333: CALL_OW 428
53337: PUSH
53338: LD_VAR 0 5
53342: IN
53343: IFFALSE 53372
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53345: LD_VAR 0 4
53349: PUSH
53350: LD_INT 1
53352: ARRAY
53353: PPUSH
53354: LD_VAR 0 4
53358: PUSH
53359: LD_INT 2
53361: ARRAY
53362: PPUSH
53363: LD_VAR 0 1
53367: PPUSH
53368: CALL_OW 456
// end ;
53372: GO 53285
53374: POP
53375: POP
// end ;
53376: LD_VAR 0 3
53380: RET
// export function Count ( array ) ; var i ; begin
53381: LD_INT 0
53383: PPUSH
53384: PPUSH
// result := 0 ;
53385: LD_ADDR_VAR 0 2
53389: PUSH
53390: LD_INT 0
53392: ST_TO_ADDR
// for i in array do
53393: LD_ADDR_VAR 0 3
53397: PUSH
53398: LD_VAR 0 1
53402: PUSH
53403: FOR_IN
53404: IFFALSE 53428
// if i then
53406: LD_VAR 0 3
53410: IFFALSE 53426
// result := result + 1 ;
53412: LD_ADDR_VAR 0 2
53416: PUSH
53417: LD_VAR 0 2
53421: PUSH
53422: LD_INT 1
53424: PLUS
53425: ST_TO_ADDR
53426: GO 53403
53428: POP
53429: POP
// end ;
53430: LD_VAR 0 2
53434: RET
// export function IsEmpty ( building ) ; begin
53435: LD_INT 0
53437: PPUSH
// if not building then
53438: LD_VAR 0 1
53442: NOT
53443: IFFALSE 53447
// exit ;
53445: GO 53490
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53447: LD_ADDR_VAR 0 2
53451: PUSH
53452: LD_VAR 0 1
53456: PUSH
53457: LD_INT 22
53459: PUSH
53460: LD_VAR 0 1
53464: PPUSH
53465: CALL_OW 255
53469: PUSH
53470: EMPTY
53471: LIST
53472: LIST
53473: PUSH
53474: LD_INT 58
53476: PUSH
53477: EMPTY
53478: LIST
53479: PUSH
53480: EMPTY
53481: LIST
53482: LIST
53483: PPUSH
53484: CALL_OW 69
53488: IN
53489: ST_TO_ADDR
// end ;
53490: LD_VAR 0 2
53494: RET
// export function IsNotFull ( building ) ; begin
53495: LD_INT 0
53497: PPUSH
// if not building then
53498: LD_VAR 0 1
53502: NOT
53503: IFFALSE 53507
// exit ;
53505: GO 53526
// result := UnitsInside ( building ) < 6 ;
53507: LD_ADDR_VAR 0 2
53511: PUSH
53512: LD_VAR 0 1
53516: PPUSH
53517: CALL_OW 313
53521: PUSH
53522: LD_INT 6
53524: LESS
53525: ST_TO_ADDR
// end ;
53526: LD_VAR 0 2
53530: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53531: LD_INT 0
53533: PPUSH
53534: PPUSH
53535: PPUSH
53536: PPUSH
// tmp := [ ] ;
53537: LD_ADDR_VAR 0 3
53541: PUSH
53542: EMPTY
53543: ST_TO_ADDR
// list := [ ] ;
53544: LD_ADDR_VAR 0 5
53548: PUSH
53549: EMPTY
53550: ST_TO_ADDR
// for i = 16 to 25 do
53551: LD_ADDR_VAR 0 4
53555: PUSH
53556: DOUBLE
53557: LD_INT 16
53559: DEC
53560: ST_TO_ADDR
53561: LD_INT 25
53563: PUSH
53564: FOR_TO
53565: IFFALSE 53638
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53567: LD_ADDR_VAR 0 3
53571: PUSH
53572: LD_VAR 0 3
53576: PUSH
53577: LD_INT 22
53579: PUSH
53580: LD_VAR 0 1
53584: PPUSH
53585: CALL_OW 255
53589: PUSH
53590: EMPTY
53591: LIST
53592: LIST
53593: PUSH
53594: LD_INT 91
53596: PUSH
53597: LD_VAR 0 1
53601: PUSH
53602: LD_INT 6
53604: PUSH
53605: EMPTY
53606: LIST
53607: LIST
53608: LIST
53609: PUSH
53610: LD_INT 30
53612: PUSH
53613: LD_VAR 0 4
53617: PUSH
53618: EMPTY
53619: LIST
53620: LIST
53621: PUSH
53622: EMPTY
53623: LIST
53624: LIST
53625: LIST
53626: PUSH
53627: EMPTY
53628: LIST
53629: PPUSH
53630: CALL_OW 69
53634: ADD
53635: ST_TO_ADDR
53636: GO 53564
53638: POP
53639: POP
// for i = 1 to tmp do
53640: LD_ADDR_VAR 0 4
53644: PUSH
53645: DOUBLE
53646: LD_INT 1
53648: DEC
53649: ST_TO_ADDR
53650: LD_VAR 0 3
53654: PUSH
53655: FOR_TO
53656: IFFALSE 53744
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53658: LD_ADDR_VAR 0 5
53662: PUSH
53663: LD_VAR 0 5
53667: PUSH
53668: LD_VAR 0 3
53672: PUSH
53673: LD_VAR 0 4
53677: ARRAY
53678: PPUSH
53679: CALL_OW 266
53683: PUSH
53684: LD_VAR 0 3
53688: PUSH
53689: LD_VAR 0 4
53693: ARRAY
53694: PPUSH
53695: CALL_OW 250
53699: PUSH
53700: LD_VAR 0 3
53704: PUSH
53705: LD_VAR 0 4
53709: ARRAY
53710: PPUSH
53711: CALL_OW 251
53715: PUSH
53716: LD_VAR 0 3
53720: PUSH
53721: LD_VAR 0 4
53725: ARRAY
53726: PPUSH
53727: CALL_OW 254
53731: PUSH
53732: EMPTY
53733: LIST
53734: LIST
53735: LIST
53736: LIST
53737: PUSH
53738: EMPTY
53739: LIST
53740: ADD
53741: ST_TO_ADDR
53742: GO 53655
53744: POP
53745: POP
// result := list ;
53746: LD_ADDR_VAR 0 2
53750: PUSH
53751: LD_VAR 0 5
53755: ST_TO_ADDR
// end ;
53756: LD_VAR 0 2
53760: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53761: LD_INT 0
53763: PPUSH
53764: PPUSH
53765: PPUSH
53766: PPUSH
53767: PPUSH
53768: PPUSH
53769: PPUSH
// if not factory then
53770: LD_VAR 0 1
53774: NOT
53775: IFFALSE 53779
// exit ;
53777: GO 54372
// if control = control_apeman then
53779: LD_VAR 0 4
53783: PUSH
53784: LD_INT 5
53786: EQUAL
53787: IFFALSE 53896
// begin tmp := UnitsInside ( factory ) ;
53789: LD_ADDR_VAR 0 8
53793: PUSH
53794: LD_VAR 0 1
53798: PPUSH
53799: CALL_OW 313
53803: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53804: LD_VAR 0 8
53808: PPUSH
53809: LD_INT 25
53811: PUSH
53812: LD_INT 12
53814: PUSH
53815: EMPTY
53816: LIST
53817: LIST
53818: PPUSH
53819: CALL_OW 72
53823: NOT
53824: IFFALSE 53834
// control := control_manual ;
53826: LD_ADDR_VAR 0 4
53830: PUSH
53831: LD_INT 1
53833: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53834: LD_ADDR_VAR 0 8
53838: PUSH
53839: LD_VAR 0 1
53843: PPUSH
53844: CALL 53531 0 1
53848: ST_TO_ADDR
// if tmp then
53849: LD_VAR 0 8
53853: IFFALSE 53896
// begin for i in tmp do
53855: LD_ADDR_VAR 0 7
53859: PUSH
53860: LD_VAR 0 8
53864: PUSH
53865: FOR_IN
53866: IFFALSE 53894
// if i [ 1 ] = b_ext_radio then
53868: LD_VAR 0 7
53872: PUSH
53873: LD_INT 1
53875: ARRAY
53876: PUSH
53877: LD_INT 22
53879: EQUAL
53880: IFFALSE 53892
// begin control := control_remote ;
53882: LD_ADDR_VAR 0 4
53886: PUSH
53887: LD_INT 2
53889: ST_TO_ADDR
// break ;
53890: GO 53894
// end ;
53892: GO 53865
53894: POP
53895: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53896: LD_VAR 0 1
53900: PPUSH
53901: LD_VAR 0 2
53905: PPUSH
53906: LD_VAR 0 3
53910: PPUSH
53911: LD_VAR 0 4
53915: PPUSH
53916: LD_VAR 0 5
53920: PPUSH
53921: CALL_OW 448
53925: IFFALSE 53960
// begin result := [ chassis , engine , control , weapon ] ;
53927: LD_ADDR_VAR 0 6
53931: PUSH
53932: LD_VAR 0 2
53936: PUSH
53937: LD_VAR 0 3
53941: PUSH
53942: LD_VAR 0 4
53946: PUSH
53947: LD_VAR 0 5
53951: PUSH
53952: EMPTY
53953: LIST
53954: LIST
53955: LIST
53956: LIST
53957: ST_TO_ADDR
// exit ;
53958: GO 54372
// end ; _chassis := AvailableChassisList ( factory ) ;
53960: LD_ADDR_VAR 0 9
53964: PUSH
53965: LD_VAR 0 1
53969: PPUSH
53970: CALL_OW 475
53974: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53975: LD_ADDR_VAR 0 11
53979: PUSH
53980: LD_VAR 0 1
53984: PPUSH
53985: CALL_OW 476
53989: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53990: LD_ADDR_VAR 0 12
53994: PUSH
53995: LD_VAR 0 1
53999: PPUSH
54000: CALL_OW 477
54004: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54005: LD_ADDR_VAR 0 10
54009: PUSH
54010: LD_VAR 0 1
54014: PPUSH
54015: CALL_OW 478
54019: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54020: LD_VAR 0 9
54024: NOT
54025: PUSH
54026: LD_VAR 0 11
54030: NOT
54031: OR
54032: PUSH
54033: LD_VAR 0 12
54037: NOT
54038: OR
54039: PUSH
54040: LD_VAR 0 10
54044: NOT
54045: OR
54046: IFFALSE 54081
// begin result := [ chassis , engine , control , weapon ] ;
54048: LD_ADDR_VAR 0 6
54052: PUSH
54053: LD_VAR 0 2
54057: PUSH
54058: LD_VAR 0 3
54062: PUSH
54063: LD_VAR 0 4
54067: PUSH
54068: LD_VAR 0 5
54072: PUSH
54073: EMPTY
54074: LIST
54075: LIST
54076: LIST
54077: LIST
54078: ST_TO_ADDR
// exit ;
54079: GO 54372
// end ; if not chassis in _chassis then
54081: LD_VAR 0 2
54085: PUSH
54086: LD_VAR 0 9
54090: IN
54091: NOT
54092: IFFALSE 54118
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54094: LD_ADDR_VAR 0 2
54098: PUSH
54099: LD_VAR 0 9
54103: PUSH
54104: LD_INT 1
54106: PPUSH
54107: LD_VAR 0 9
54111: PPUSH
54112: CALL_OW 12
54116: ARRAY
54117: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54118: LD_VAR 0 2
54122: PPUSH
54123: LD_VAR 0 3
54127: PPUSH
54128: CALL 54377 0 2
54132: NOT
54133: IFFALSE 54192
// repeat engine := _engine [ 1 ] ;
54135: LD_ADDR_VAR 0 3
54139: PUSH
54140: LD_VAR 0 11
54144: PUSH
54145: LD_INT 1
54147: ARRAY
54148: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54149: LD_ADDR_VAR 0 11
54153: PUSH
54154: LD_VAR 0 11
54158: PPUSH
54159: LD_INT 1
54161: PPUSH
54162: CALL_OW 3
54166: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54167: LD_VAR 0 2
54171: PPUSH
54172: LD_VAR 0 3
54176: PPUSH
54177: CALL 54377 0 2
54181: PUSH
54182: LD_VAR 0 11
54186: PUSH
54187: EMPTY
54188: EQUAL
54189: OR
54190: IFFALSE 54135
// if not control in _control then
54192: LD_VAR 0 4
54196: PUSH
54197: LD_VAR 0 12
54201: IN
54202: NOT
54203: IFFALSE 54229
// control := _control [ rand ( 1 , _control ) ] ;
54205: LD_ADDR_VAR 0 4
54209: PUSH
54210: LD_VAR 0 12
54214: PUSH
54215: LD_INT 1
54217: PPUSH
54218: LD_VAR 0 12
54222: PPUSH
54223: CALL_OW 12
54227: ARRAY
54228: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54229: LD_VAR 0 2
54233: PPUSH
54234: LD_VAR 0 5
54238: PPUSH
54239: CALL 54597 0 2
54243: NOT
54244: IFFALSE 54303
// repeat weapon := _weapon [ 1 ] ;
54246: LD_ADDR_VAR 0 5
54250: PUSH
54251: LD_VAR 0 10
54255: PUSH
54256: LD_INT 1
54258: ARRAY
54259: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54260: LD_ADDR_VAR 0 10
54264: PUSH
54265: LD_VAR 0 10
54269: PPUSH
54270: LD_INT 1
54272: PPUSH
54273: CALL_OW 3
54277: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54278: LD_VAR 0 2
54282: PPUSH
54283: LD_VAR 0 5
54287: PPUSH
54288: CALL 54597 0 2
54292: PUSH
54293: LD_VAR 0 10
54297: PUSH
54298: EMPTY
54299: EQUAL
54300: OR
54301: IFFALSE 54246
// result := [ ] ;
54303: LD_ADDR_VAR 0 6
54307: PUSH
54308: EMPTY
54309: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54310: LD_VAR 0 1
54314: PPUSH
54315: LD_VAR 0 2
54319: PPUSH
54320: LD_VAR 0 3
54324: PPUSH
54325: LD_VAR 0 4
54329: PPUSH
54330: LD_VAR 0 5
54334: PPUSH
54335: CALL_OW 448
54339: IFFALSE 54372
// result := [ chassis , engine , control , weapon ] ;
54341: LD_ADDR_VAR 0 6
54345: PUSH
54346: LD_VAR 0 2
54350: PUSH
54351: LD_VAR 0 3
54355: PUSH
54356: LD_VAR 0 4
54360: PUSH
54361: LD_VAR 0 5
54365: PUSH
54366: EMPTY
54367: LIST
54368: LIST
54369: LIST
54370: LIST
54371: ST_TO_ADDR
// end ;
54372: LD_VAR 0 6
54376: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
54377: LD_INT 0
54379: PPUSH
// if not chassis or not engine then
54380: LD_VAR 0 1
54384: NOT
54385: PUSH
54386: LD_VAR 0 2
54390: NOT
54391: OR
54392: IFFALSE 54396
// exit ;
54394: GO 54592
// case engine of engine_solar :
54396: LD_VAR 0 2
54400: PUSH
54401: LD_INT 2
54403: DOUBLE
54404: EQUAL
54405: IFTRUE 54409
54407: GO 54447
54409: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54410: LD_ADDR_VAR 0 3
54414: PUSH
54415: LD_INT 11
54417: PUSH
54418: LD_INT 12
54420: PUSH
54421: LD_INT 13
54423: PUSH
54424: LD_INT 14
54426: PUSH
54427: LD_INT 1
54429: PUSH
54430: LD_INT 2
54432: PUSH
54433: LD_INT 3
54435: PUSH
54436: EMPTY
54437: LIST
54438: LIST
54439: LIST
54440: LIST
54441: LIST
54442: LIST
54443: LIST
54444: ST_TO_ADDR
54445: GO 54576
54447: LD_INT 1
54449: DOUBLE
54450: EQUAL
54451: IFTRUE 54455
54453: GO 54517
54455: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54456: LD_ADDR_VAR 0 3
54460: PUSH
54461: LD_INT 11
54463: PUSH
54464: LD_INT 12
54466: PUSH
54467: LD_INT 13
54469: PUSH
54470: LD_INT 14
54472: PUSH
54473: LD_INT 1
54475: PUSH
54476: LD_INT 2
54478: PUSH
54479: LD_INT 3
54481: PUSH
54482: LD_INT 4
54484: PUSH
54485: LD_INT 5
54487: PUSH
54488: LD_INT 21
54490: PUSH
54491: LD_INT 23
54493: PUSH
54494: LD_INT 22
54496: PUSH
54497: LD_INT 24
54499: PUSH
54500: EMPTY
54501: LIST
54502: LIST
54503: LIST
54504: LIST
54505: LIST
54506: LIST
54507: LIST
54508: LIST
54509: LIST
54510: LIST
54511: LIST
54512: LIST
54513: LIST
54514: ST_TO_ADDR
54515: GO 54576
54517: LD_INT 3
54519: DOUBLE
54520: EQUAL
54521: IFTRUE 54525
54523: GO 54575
54525: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54526: LD_ADDR_VAR 0 3
54530: PUSH
54531: LD_INT 13
54533: PUSH
54534: LD_INT 14
54536: PUSH
54537: LD_INT 2
54539: PUSH
54540: LD_INT 3
54542: PUSH
54543: LD_INT 4
54545: PUSH
54546: LD_INT 5
54548: PUSH
54549: LD_INT 21
54551: PUSH
54552: LD_INT 22
54554: PUSH
54555: LD_INT 23
54557: PUSH
54558: LD_INT 24
54560: PUSH
54561: EMPTY
54562: LIST
54563: LIST
54564: LIST
54565: LIST
54566: LIST
54567: LIST
54568: LIST
54569: LIST
54570: LIST
54571: LIST
54572: ST_TO_ADDR
54573: GO 54576
54575: POP
// result := ( chassis in result ) ;
54576: LD_ADDR_VAR 0 3
54580: PUSH
54581: LD_VAR 0 1
54585: PUSH
54586: LD_VAR 0 3
54590: IN
54591: ST_TO_ADDR
// end ;
54592: LD_VAR 0 3
54596: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54597: LD_INT 0
54599: PPUSH
// if not chassis or not weapon then
54600: LD_VAR 0 1
54604: NOT
54605: PUSH
54606: LD_VAR 0 2
54610: NOT
54611: OR
54612: IFFALSE 54616
// exit ;
54614: GO 55642
// case weapon of us_machine_gun :
54616: LD_VAR 0 2
54620: PUSH
54621: LD_INT 2
54623: DOUBLE
54624: EQUAL
54625: IFTRUE 54629
54627: GO 54659
54629: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54630: LD_ADDR_VAR 0 3
54634: PUSH
54635: LD_INT 1
54637: PUSH
54638: LD_INT 2
54640: PUSH
54641: LD_INT 3
54643: PUSH
54644: LD_INT 4
54646: PUSH
54647: LD_INT 5
54649: PUSH
54650: EMPTY
54651: LIST
54652: LIST
54653: LIST
54654: LIST
54655: LIST
54656: ST_TO_ADDR
54657: GO 55626
54659: LD_INT 3
54661: DOUBLE
54662: EQUAL
54663: IFTRUE 54667
54665: GO 54697
54667: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54668: LD_ADDR_VAR 0 3
54672: PUSH
54673: LD_INT 1
54675: PUSH
54676: LD_INT 2
54678: PUSH
54679: LD_INT 3
54681: PUSH
54682: LD_INT 4
54684: PUSH
54685: LD_INT 5
54687: PUSH
54688: EMPTY
54689: LIST
54690: LIST
54691: LIST
54692: LIST
54693: LIST
54694: ST_TO_ADDR
54695: GO 55626
54697: LD_INT 11
54699: DOUBLE
54700: EQUAL
54701: IFTRUE 54705
54703: GO 54735
54705: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54706: LD_ADDR_VAR 0 3
54710: PUSH
54711: LD_INT 1
54713: PUSH
54714: LD_INT 2
54716: PUSH
54717: LD_INT 3
54719: PUSH
54720: LD_INT 4
54722: PUSH
54723: LD_INT 5
54725: PUSH
54726: EMPTY
54727: LIST
54728: LIST
54729: LIST
54730: LIST
54731: LIST
54732: ST_TO_ADDR
54733: GO 55626
54735: LD_INT 4
54737: DOUBLE
54738: EQUAL
54739: IFTRUE 54743
54741: GO 54769
54743: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54744: LD_ADDR_VAR 0 3
54748: PUSH
54749: LD_INT 2
54751: PUSH
54752: LD_INT 3
54754: PUSH
54755: LD_INT 4
54757: PUSH
54758: LD_INT 5
54760: PUSH
54761: EMPTY
54762: LIST
54763: LIST
54764: LIST
54765: LIST
54766: ST_TO_ADDR
54767: GO 55626
54769: LD_INT 5
54771: DOUBLE
54772: EQUAL
54773: IFTRUE 54777
54775: GO 54803
54777: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54778: LD_ADDR_VAR 0 3
54782: PUSH
54783: LD_INT 2
54785: PUSH
54786: LD_INT 3
54788: PUSH
54789: LD_INT 4
54791: PUSH
54792: LD_INT 5
54794: PUSH
54795: EMPTY
54796: LIST
54797: LIST
54798: LIST
54799: LIST
54800: ST_TO_ADDR
54801: GO 55626
54803: LD_INT 9
54805: DOUBLE
54806: EQUAL
54807: IFTRUE 54811
54809: GO 54837
54811: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54812: LD_ADDR_VAR 0 3
54816: PUSH
54817: LD_INT 2
54819: PUSH
54820: LD_INT 3
54822: PUSH
54823: LD_INT 4
54825: PUSH
54826: LD_INT 5
54828: PUSH
54829: EMPTY
54830: LIST
54831: LIST
54832: LIST
54833: LIST
54834: ST_TO_ADDR
54835: GO 55626
54837: LD_INT 7
54839: DOUBLE
54840: EQUAL
54841: IFTRUE 54845
54843: GO 54871
54845: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54846: LD_ADDR_VAR 0 3
54850: PUSH
54851: LD_INT 2
54853: PUSH
54854: LD_INT 3
54856: PUSH
54857: LD_INT 4
54859: PUSH
54860: LD_INT 5
54862: PUSH
54863: EMPTY
54864: LIST
54865: LIST
54866: LIST
54867: LIST
54868: ST_TO_ADDR
54869: GO 55626
54871: LD_INT 12
54873: DOUBLE
54874: EQUAL
54875: IFTRUE 54879
54877: GO 54905
54879: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54880: LD_ADDR_VAR 0 3
54884: PUSH
54885: LD_INT 2
54887: PUSH
54888: LD_INT 3
54890: PUSH
54891: LD_INT 4
54893: PUSH
54894: LD_INT 5
54896: PUSH
54897: EMPTY
54898: LIST
54899: LIST
54900: LIST
54901: LIST
54902: ST_TO_ADDR
54903: GO 55626
54905: LD_INT 13
54907: DOUBLE
54908: EQUAL
54909: IFTRUE 54913
54911: GO 54939
54913: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54914: LD_ADDR_VAR 0 3
54918: PUSH
54919: LD_INT 2
54921: PUSH
54922: LD_INT 3
54924: PUSH
54925: LD_INT 4
54927: PUSH
54928: LD_INT 5
54930: PUSH
54931: EMPTY
54932: LIST
54933: LIST
54934: LIST
54935: LIST
54936: ST_TO_ADDR
54937: GO 55626
54939: LD_INT 14
54941: DOUBLE
54942: EQUAL
54943: IFTRUE 54947
54945: GO 54965
54947: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54948: LD_ADDR_VAR 0 3
54952: PUSH
54953: LD_INT 4
54955: PUSH
54956: LD_INT 5
54958: PUSH
54959: EMPTY
54960: LIST
54961: LIST
54962: ST_TO_ADDR
54963: GO 55626
54965: LD_INT 6
54967: DOUBLE
54968: EQUAL
54969: IFTRUE 54973
54971: GO 54991
54973: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54974: LD_ADDR_VAR 0 3
54978: PUSH
54979: LD_INT 4
54981: PUSH
54982: LD_INT 5
54984: PUSH
54985: EMPTY
54986: LIST
54987: LIST
54988: ST_TO_ADDR
54989: GO 55626
54991: LD_INT 10
54993: DOUBLE
54994: EQUAL
54995: IFTRUE 54999
54997: GO 55017
54999: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55000: LD_ADDR_VAR 0 3
55004: PUSH
55005: LD_INT 4
55007: PUSH
55008: LD_INT 5
55010: PUSH
55011: EMPTY
55012: LIST
55013: LIST
55014: ST_TO_ADDR
55015: GO 55626
55017: LD_INT 22
55019: DOUBLE
55020: EQUAL
55021: IFTRUE 55025
55023: GO 55051
55025: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55026: LD_ADDR_VAR 0 3
55030: PUSH
55031: LD_INT 11
55033: PUSH
55034: LD_INT 12
55036: PUSH
55037: LD_INT 13
55039: PUSH
55040: LD_INT 14
55042: PUSH
55043: EMPTY
55044: LIST
55045: LIST
55046: LIST
55047: LIST
55048: ST_TO_ADDR
55049: GO 55626
55051: LD_INT 23
55053: DOUBLE
55054: EQUAL
55055: IFTRUE 55059
55057: GO 55085
55059: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55060: LD_ADDR_VAR 0 3
55064: PUSH
55065: LD_INT 11
55067: PUSH
55068: LD_INT 12
55070: PUSH
55071: LD_INT 13
55073: PUSH
55074: LD_INT 14
55076: PUSH
55077: EMPTY
55078: LIST
55079: LIST
55080: LIST
55081: LIST
55082: ST_TO_ADDR
55083: GO 55626
55085: LD_INT 24
55087: DOUBLE
55088: EQUAL
55089: IFTRUE 55093
55091: GO 55119
55093: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55094: LD_ADDR_VAR 0 3
55098: PUSH
55099: LD_INT 11
55101: PUSH
55102: LD_INT 12
55104: PUSH
55105: LD_INT 13
55107: PUSH
55108: LD_INT 14
55110: PUSH
55111: EMPTY
55112: LIST
55113: LIST
55114: LIST
55115: LIST
55116: ST_TO_ADDR
55117: GO 55626
55119: LD_INT 30
55121: DOUBLE
55122: EQUAL
55123: IFTRUE 55127
55125: GO 55153
55127: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55128: LD_ADDR_VAR 0 3
55132: PUSH
55133: LD_INT 11
55135: PUSH
55136: LD_INT 12
55138: PUSH
55139: LD_INT 13
55141: PUSH
55142: LD_INT 14
55144: PUSH
55145: EMPTY
55146: LIST
55147: LIST
55148: LIST
55149: LIST
55150: ST_TO_ADDR
55151: GO 55626
55153: LD_INT 25
55155: DOUBLE
55156: EQUAL
55157: IFTRUE 55161
55159: GO 55179
55161: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55162: LD_ADDR_VAR 0 3
55166: PUSH
55167: LD_INT 13
55169: PUSH
55170: LD_INT 14
55172: PUSH
55173: EMPTY
55174: LIST
55175: LIST
55176: ST_TO_ADDR
55177: GO 55626
55179: LD_INT 27
55181: DOUBLE
55182: EQUAL
55183: IFTRUE 55187
55185: GO 55205
55187: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55188: LD_ADDR_VAR 0 3
55192: PUSH
55193: LD_INT 13
55195: PUSH
55196: LD_INT 14
55198: PUSH
55199: EMPTY
55200: LIST
55201: LIST
55202: ST_TO_ADDR
55203: GO 55626
55205: LD_INT 28
55207: DOUBLE
55208: EQUAL
55209: IFTRUE 55213
55211: GO 55231
55213: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55214: LD_ADDR_VAR 0 3
55218: PUSH
55219: LD_INT 13
55221: PUSH
55222: LD_INT 14
55224: PUSH
55225: EMPTY
55226: LIST
55227: LIST
55228: ST_TO_ADDR
55229: GO 55626
55231: LD_INT 29
55233: DOUBLE
55234: EQUAL
55235: IFTRUE 55239
55237: GO 55257
55239: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55240: LD_ADDR_VAR 0 3
55244: PUSH
55245: LD_INT 13
55247: PUSH
55248: LD_INT 14
55250: PUSH
55251: EMPTY
55252: LIST
55253: LIST
55254: ST_TO_ADDR
55255: GO 55626
55257: LD_INT 31
55259: DOUBLE
55260: EQUAL
55261: IFTRUE 55265
55263: GO 55283
55265: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55266: LD_ADDR_VAR 0 3
55270: PUSH
55271: LD_INT 13
55273: PUSH
55274: LD_INT 14
55276: PUSH
55277: EMPTY
55278: LIST
55279: LIST
55280: ST_TO_ADDR
55281: GO 55626
55283: LD_INT 26
55285: DOUBLE
55286: EQUAL
55287: IFTRUE 55291
55289: GO 55309
55291: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
55292: LD_ADDR_VAR 0 3
55296: PUSH
55297: LD_INT 13
55299: PUSH
55300: LD_INT 14
55302: PUSH
55303: EMPTY
55304: LIST
55305: LIST
55306: ST_TO_ADDR
55307: GO 55626
55309: LD_INT 42
55311: DOUBLE
55312: EQUAL
55313: IFTRUE 55317
55315: GO 55343
55317: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
55318: LD_ADDR_VAR 0 3
55322: PUSH
55323: LD_INT 21
55325: PUSH
55326: LD_INT 22
55328: PUSH
55329: LD_INT 23
55331: PUSH
55332: LD_INT 24
55334: PUSH
55335: EMPTY
55336: LIST
55337: LIST
55338: LIST
55339: LIST
55340: ST_TO_ADDR
55341: GO 55626
55343: LD_INT 43
55345: DOUBLE
55346: EQUAL
55347: IFTRUE 55351
55349: GO 55377
55351: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
55352: LD_ADDR_VAR 0 3
55356: PUSH
55357: LD_INT 21
55359: PUSH
55360: LD_INT 22
55362: PUSH
55363: LD_INT 23
55365: PUSH
55366: LD_INT 24
55368: PUSH
55369: EMPTY
55370: LIST
55371: LIST
55372: LIST
55373: LIST
55374: ST_TO_ADDR
55375: GO 55626
55377: LD_INT 44
55379: DOUBLE
55380: EQUAL
55381: IFTRUE 55385
55383: GO 55411
55385: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
55386: LD_ADDR_VAR 0 3
55390: PUSH
55391: LD_INT 21
55393: PUSH
55394: LD_INT 22
55396: PUSH
55397: LD_INT 23
55399: PUSH
55400: LD_INT 24
55402: PUSH
55403: EMPTY
55404: LIST
55405: LIST
55406: LIST
55407: LIST
55408: ST_TO_ADDR
55409: GO 55626
55411: LD_INT 45
55413: DOUBLE
55414: EQUAL
55415: IFTRUE 55419
55417: GO 55445
55419: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55420: LD_ADDR_VAR 0 3
55424: PUSH
55425: LD_INT 21
55427: PUSH
55428: LD_INT 22
55430: PUSH
55431: LD_INT 23
55433: PUSH
55434: LD_INT 24
55436: PUSH
55437: EMPTY
55438: LIST
55439: LIST
55440: LIST
55441: LIST
55442: ST_TO_ADDR
55443: GO 55626
55445: LD_INT 49
55447: DOUBLE
55448: EQUAL
55449: IFTRUE 55453
55451: GO 55479
55453: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55454: LD_ADDR_VAR 0 3
55458: PUSH
55459: LD_INT 21
55461: PUSH
55462: LD_INT 22
55464: PUSH
55465: LD_INT 23
55467: PUSH
55468: LD_INT 24
55470: PUSH
55471: EMPTY
55472: LIST
55473: LIST
55474: LIST
55475: LIST
55476: ST_TO_ADDR
55477: GO 55626
55479: LD_INT 51
55481: DOUBLE
55482: EQUAL
55483: IFTRUE 55487
55485: GO 55513
55487: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55488: LD_ADDR_VAR 0 3
55492: PUSH
55493: LD_INT 21
55495: PUSH
55496: LD_INT 22
55498: PUSH
55499: LD_INT 23
55501: PUSH
55502: LD_INT 24
55504: PUSH
55505: EMPTY
55506: LIST
55507: LIST
55508: LIST
55509: LIST
55510: ST_TO_ADDR
55511: GO 55626
55513: LD_INT 52
55515: DOUBLE
55516: EQUAL
55517: IFTRUE 55521
55519: GO 55547
55521: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55522: LD_ADDR_VAR 0 3
55526: PUSH
55527: LD_INT 21
55529: PUSH
55530: LD_INT 22
55532: PUSH
55533: LD_INT 23
55535: PUSH
55536: LD_INT 24
55538: PUSH
55539: EMPTY
55540: LIST
55541: LIST
55542: LIST
55543: LIST
55544: ST_TO_ADDR
55545: GO 55626
55547: LD_INT 53
55549: DOUBLE
55550: EQUAL
55551: IFTRUE 55555
55553: GO 55573
55555: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55556: LD_ADDR_VAR 0 3
55560: PUSH
55561: LD_INT 23
55563: PUSH
55564: LD_INT 24
55566: PUSH
55567: EMPTY
55568: LIST
55569: LIST
55570: ST_TO_ADDR
55571: GO 55626
55573: LD_INT 46
55575: DOUBLE
55576: EQUAL
55577: IFTRUE 55581
55579: GO 55599
55581: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55582: LD_ADDR_VAR 0 3
55586: PUSH
55587: LD_INT 23
55589: PUSH
55590: LD_INT 24
55592: PUSH
55593: EMPTY
55594: LIST
55595: LIST
55596: ST_TO_ADDR
55597: GO 55626
55599: LD_INT 47
55601: DOUBLE
55602: EQUAL
55603: IFTRUE 55607
55605: GO 55625
55607: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55608: LD_ADDR_VAR 0 3
55612: PUSH
55613: LD_INT 23
55615: PUSH
55616: LD_INT 24
55618: PUSH
55619: EMPTY
55620: LIST
55621: LIST
55622: ST_TO_ADDR
55623: GO 55626
55625: POP
// result := ( chassis in result ) ;
55626: LD_ADDR_VAR 0 3
55630: PUSH
55631: LD_VAR 0 1
55635: PUSH
55636: LD_VAR 0 3
55640: IN
55641: ST_TO_ADDR
// end ;
55642: LD_VAR 0 3
55646: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55647: LD_INT 0
55649: PPUSH
55650: PPUSH
55651: PPUSH
55652: PPUSH
55653: PPUSH
55654: PPUSH
55655: PPUSH
// result := array ;
55656: LD_ADDR_VAR 0 5
55660: PUSH
55661: LD_VAR 0 1
55665: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55666: LD_VAR 0 1
55670: NOT
55671: PUSH
55672: LD_VAR 0 2
55676: NOT
55677: OR
55678: PUSH
55679: LD_VAR 0 3
55683: NOT
55684: OR
55685: PUSH
55686: LD_VAR 0 2
55690: PUSH
55691: LD_VAR 0 1
55695: GREATER
55696: OR
55697: PUSH
55698: LD_VAR 0 3
55702: PUSH
55703: LD_VAR 0 1
55707: GREATER
55708: OR
55709: IFFALSE 55713
// exit ;
55711: GO 56009
// if direction then
55713: LD_VAR 0 4
55717: IFFALSE 55781
// begin d := 1 ;
55719: LD_ADDR_VAR 0 9
55723: PUSH
55724: LD_INT 1
55726: ST_TO_ADDR
// if i_from > i_to then
55727: LD_VAR 0 2
55731: PUSH
55732: LD_VAR 0 3
55736: GREATER
55737: IFFALSE 55763
// length := ( array - i_from ) + i_to else
55739: LD_ADDR_VAR 0 11
55743: PUSH
55744: LD_VAR 0 1
55748: PUSH
55749: LD_VAR 0 2
55753: MINUS
55754: PUSH
55755: LD_VAR 0 3
55759: PLUS
55760: ST_TO_ADDR
55761: GO 55779
// length := i_to - i_from ;
55763: LD_ADDR_VAR 0 11
55767: PUSH
55768: LD_VAR 0 3
55772: PUSH
55773: LD_VAR 0 2
55777: MINUS
55778: ST_TO_ADDR
// end else
55779: GO 55842
// begin d := - 1 ;
55781: LD_ADDR_VAR 0 9
55785: PUSH
55786: LD_INT 1
55788: NEG
55789: ST_TO_ADDR
// if i_from > i_to then
55790: LD_VAR 0 2
55794: PUSH
55795: LD_VAR 0 3
55799: GREATER
55800: IFFALSE 55820
// length := i_from - i_to else
55802: LD_ADDR_VAR 0 11
55806: PUSH
55807: LD_VAR 0 2
55811: PUSH
55812: LD_VAR 0 3
55816: MINUS
55817: ST_TO_ADDR
55818: GO 55842
// length := ( array - i_to ) + i_from ;
55820: LD_ADDR_VAR 0 11
55824: PUSH
55825: LD_VAR 0 1
55829: PUSH
55830: LD_VAR 0 3
55834: MINUS
55835: PUSH
55836: LD_VAR 0 2
55840: PLUS
55841: ST_TO_ADDR
// end ; if not length then
55842: LD_VAR 0 11
55846: NOT
55847: IFFALSE 55851
// exit ;
55849: GO 56009
// tmp := array ;
55851: LD_ADDR_VAR 0 10
55855: PUSH
55856: LD_VAR 0 1
55860: ST_TO_ADDR
// for i = 1 to length do
55861: LD_ADDR_VAR 0 6
55865: PUSH
55866: DOUBLE
55867: LD_INT 1
55869: DEC
55870: ST_TO_ADDR
55871: LD_VAR 0 11
55875: PUSH
55876: FOR_TO
55877: IFFALSE 55997
// begin for j = 1 to array do
55879: LD_ADDR_VAR 0 7
55883: PUSH
55884: DOUBLE
55885: LD_INT 1
55887: DEC
55888: ST_TO_ADDR
55889: LD_VAR 0 1
55893: PUSH
55894: FOR_TO
55895: IFFALSE 55983
// begin k := j + d ;
55897: LD_ADDR_VAR 0 8
55901: PUSH
55902: LD_VAR 0 7
55906: PUSH
55907: LD_VAR 0 9
55911: PLUS
55912: ST_TO_ADDR
// if k > array then
55913: LD_VAR 0 8
55917: PUSH
55918: LD_VAR 0 1
55922: GREATER
55923: IFFALSE 55933
// k := 1 ;
55925: LD_ADDR_VAR 0 8
55929: PUSH
55930: LD_INT 1
55932: ST_TO_ADDR
// if not k then
55933: LD_VAR 0 8
55937: NOT
55938: IFFALSE 55950
// k := array ;
55940: LD_ADDR_VAR 0 8
55944: PUSH
55945: LD_VAR 0 1
55949: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55950: LD_ADDR_VAR 0 10
55954: PUSH
55955: LD_VAR 0 10
55959: PPUSH
55960: LD_VAR 0 8
55964: PPUSH
55965: LD_VAR 0 1
55969: PUSH
55970: LD_VAR 0 7
55974: ARRAY
55975: PPUSH
55976: CALL_OW 1
55980: ST_TO_ADDR
// end ;
55981: GO 55894
55983: POP
55984: POP
// array := tmp ;
55985: LD_ADDR_VAR 0 1
55989: PUSH
55990: LD_VAR 0 10
55994: ST_TO_ADDR
// end ;
55995: GO 55876
55997: POP
55998: POP
// result := array ;
55999: LD_ADDR_VAR 0 5
56003: PUSH
56004: LD_VAR 0 1
56008: ST_TO_ADDR
// end ;
56009: LD_VAR 0 5
56013: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56014: LD_INT 0
56016: PPUSH
56017: PPUSH
// result := 0 ;
56018: LD_ADDR_VAR 0 3
56022: PUSH
56023: LD_INT 0
56025: ST_TO_ADDR
// if not array or not value in array then
56026: LD_VAR 0 1
56030: NOT
56031: PUSH
56032: LD_VAR 0 2
56036: PUSH
56037: LD_VAR 0 1
56041: IN
56042: NOT
56043: OR
56044: IFFALSE 56048
// exit ;
56046: GO 56102
// for i = 1 to array do
56048: LD_ADDR_VAR 0 4
56052: PUSH
56053: DOUBLE
56054: LD_INT 1
56056: DEC
56057: ST_TO_ADDR
56058: LD_VAR 0 1
56062: PUSH
56063: FOR_TO
56064: IFFALSE 56100
// if value = array [ i ] then
56066: LD_VAR 0 2
56070: PUSH
56071: LD_VAR 0 1
56075: PUSH
56076: LD_VAR 0 4
56080: ARRAY
56081: EQUAL
56082: IFFALSE 56098
// begin result := i ;
56084: LD_ADDR_VAR 0 3
56088: PUSH
56089: LD_VAR 0 4
56093: ST_TO_ADDR
// exit ;
56094: POP
56095: POP
56096: GO 56102
// end ;
56098: GO 56063
56100: POP
56101: POP
// end ;
56102: LD_VAR 0 3
56106: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56107: LD_INT 0
56109: PPUSH
// vc_chassis := chassis ;
56110: LD_ADDR_OWVAR 37
56114: PUSH
56115: LD_VAR 0 1
56119: ST_TO_ADDR
// vc_engine := engine ;
56120: LD_ADDR_OWVAR 39
56124: PUSH
56125: LD_VAR 0 2
56129: ST_TO_ADDR
// vc_control := control ;
56130: LD_ADDR_OWVAR 38
56134: PUSH
56135: LD_VAR 0 3
56139: ST_TO_ADDR
// vc_weapon := weapon ;
56140: LD_ADDR_OWVAR 40
56144: PUSH
56145: LD_VAR 0 4
56149: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56150: LD_ADDR_OWVAR 41
56154: PUSH
56155: LD_VAR 0 5
56159: ST_TO_ADDR
// end ;
56160: LD_VAR 0 6
56164: RET
// export function WantPlant ( unit ) ; var task ; begin
56165: LD_INT 0
56167: PPUSH
56168: PPUSH
// result := false ;
56169: LD_ADDR_VAR 0 2
56173: PUSH
56174: LD_INT 0
56176: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56177: LD_ADDR_VAR 0 3
56181: PUSH
56182: LD_VAR 0 1
56186: PPUSH
56187: CALL_OW 437
56191: ST_TO_ADDR
// if task then
56192: LD_VAR 0 3
56196: IFFALSE 56224
// if task [ 1 ] [ 1 ] = p then
56198: LD_VAR 0 3
56202: PUSH
56203: LD_INT 1
56205: ARRAY
56206: PUSH
56207: LD_INT 1
56209: ARRAY
56210: PUSH
56211: LD_STRING p
56213: EQUAL
56214: IFFALSE 56224
// result := true ;
56216: LD_ADDR_VAR 0 2
56220: PUSH
56221: LD_INT 1
56223: ST_TO_ADDR
// end ;
56224: LD_VAR 0 2
56228: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56229: LD_INT 0
56231: PPUSH
56232: PPUSH
56233: PPUSH
56234: PPUSH
// if pos < 1 then
56235: LD_VAR 0 2
56239: PUSH
56240: LD_INT 1
56242: LESS
56243: IFFALSE 56247
// exit ;
56245: GO 56550
// if pos = 1 then
56247: LD_VAR 0 2
56251: PUSH
56252: LD_INT 1
56254: EQUAL
56255: IFFALSE 56288
// result := Replace ( arr , pos [ 1 ] , value ) else
56257: LD_ADDR_VAR 0 4
56261: PUSH
56262: LD_VAR 0 1
56266: PPUSH
56267: LD_VAR 0 2
56271: PUSH
56272: LD_INT 1
56274: ARRAY
56275: PPUSH
56276: LD_VAR 0 3
56280: PPUSH
56281: CALL_OW 1
56285: ST_TO_ADDR
56286: GO 56550
// begin tmp := arr ;
56288: LD_ADDR_VAR 0 6
56292: PUSH
56293: LD_VAR 0 1
56297: ST_TO_ADDR
// s_arr := [ tmp ] ;
56298: LD_ADDR_VAR 0 7
56302: PUSH
56303: LD_VAR 0 6
56307: PUSH
56308: EMPTY
56309: LIST
56310: ST_TO_ADDR
// for i = 1 to pos - 1 do
56311: LD_ADDR_VAR 0 5
56315: PUSH
56316: DOUBLE
56317: LD_INT 1
56319: DEC
56320: ST_TO_ADDR
56321: LD_VAR 0 2
56325: PUSH
56326: LD_INT 1
56328: MINUS
56329: PUSH
56330: FOR_TO
56331: IFFALSE 56376
// begin tmp := tmp [ pos [ i ] ] ;
56333: LD_ADDR_VAR 0 6
56337: PUSH
56338: LD_VAR 0 6
56342: PUSH
56343: LD_VAR 0 2
56347: PUSH
56348: LD_VAR 0 5
56352: ARRAY
56353: ARRAY
56354: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
56355: LD_ADDR_VAR 0 7
56359: PUSH
56360: LD_VAR 0 7
56364: PUSH
56365: LD_VAR 0 6
56369: PUSH
56370: EMPTY
56371: LIST
56372: ADD
56373: ST_TO_ADDR
// end ;
56374: GO 56330
56376: POP
56377: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
56378: LD_ADDR_VAR 0 6
56382: PUSH
56383: LD_VAR 0 6
56387: PPUSH
56388: LD_VAR 0 2
56392: PUSH
56393: LD_VAR 0 2
56397: ARRAY
56398: PPUSH
56399: LD_VAR 0 3
56403: PPUSH
56404: CALL_OW 1
56408: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56409: LD_ADDR_VAR 0 7
56413: PUSH
56414: LD_VAR 0 7
56418: PPUSH
56419: LD_VAR 0 7
56423: PPUSH
56424: LD_VAR 0 6
56428: PPUSH
56429: CALL_OW 1
56433: ST_TO_ADDR
// for i = s_arr downto 2 do
56434: LD_ADDR_VAR 0 5
56438: PUSH
56439: DOUBLE
56440: LD_VAR 0 7
56444: INC
56445: ST_TO_ADDR
56446: LD_INT 2
56448: PUSH
56449: FOR_DOWNTO
56450: IFFALSE 56534
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56452: LD_ADDR_VAR 0 6
56456: PUSH
56457: LD_VAR 0 7
56461: PUSH
56462: LD_VAR 0 5
56466: PUSH
56467: LD_INT 1
56469: MINUS
56470: ARRAY
56471: PPUSH
56472: LD_VAR 0 2
56476: PUSH
56477: LD_VAR 0 5
56481: PUSH
56482: LD_INT 1
56484: MINUS
56485: ARRAY
56486: PPUSH
56487: LD_VAR 0 7
56491: PUSH
56492: LD_VAR 0 5
56496: ARRAY
56497: PPUSH
56498: CALL_OW 1
56502: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56503: LD_ADDR_VAR 0 7
56507: PUSH
56508: LD_VAR 0 7
56512: PPUSH
56513: LD_VAR 0 5
56517: PUSH
56518: LD_INT 1
56520: MINUS
56521: PPUSH
56522: LD_VAR 0 6
56526: PPUSH
56527: CALL_OW 1
56531: ST_TO_ADDR
// end ;
56532: GO 56449
56534: POP
56535: POP
// result := s_arr [ 1 ] ;
56536: LD_ADDR_VAR 0 4
56540: PUSH
56541: LD_VAR 0 7
56545: PUSH
56546: LD_INT 1
56548: ARRAY
56549: ST_TO_ADDR
// end ; end ;
56550: LD_VAR 0 4
56554: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56555: LD_INT 0
56557: PPUSH
56558: PPUSH
// if not list then
56559: LD_VAR 0 1
56563: NOT
56564: IFFALSE 56568
// exit ;
56566: GO 56659
// i := list [ pos1 ] ;
56568: LD_ADDR_VAR 0 5
56572: PUSH
56573: LD_VAR 0 1
56577: PUSH
56578: LD_VAR 0 2
56582: ARRAY
56583: ST_TO_ADDR
// if not i then
56584: LD_VAR 0 5
56588: NOT
56589: IFFALSE 56593
// exit ;
56591: GO 56659
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56593: LD_ADDR_VAR 0 1
56597: PUSH
56598: LD_VAR 0 1
56602: PPUSH
56603: LD_VAR 0 2
56607: PPUSH
56608: LD_VAR 0 1
56612: PUSH
56613: LD_VAR 0 3
56617: ARRAY
56618: PPUSH
56619: CALL_OW 1
56623: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56624: LD_ADDR_VAR 0 1
56628: PUSH
56629: LD_VAR 0 1
56633: PPUSH
56634: LD_VAR 0 3
56638: PPUSH
56639: LD_VAR 0 5
56643: PPUSH
56644: CALL_OW 1
56648: ST_TO_ADDR
// result := list ;
56649: LD_ADDR_VAR 0 4
56653: PUSH
56654: LD_VAR 0 1
56658: ST_TO_ADDR
// end ;
56659: LD_VAR 0 4
56663: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56664: LD_INT 0
56666: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56667: LD_ADDR_VAR 0 5
56671: PUSH
56672: LD_VAR 0 1
56676: PPUSH
56677: CALL_OW 250
56681: PPUSH
56682: LD_VAR 0 1
56686: PPUSH
56687: CALL_OW 251
56691: PPUSH
56692: LD_VAR 0 2
56696: PPUSH
56697: LD_VAR 0 3
56701: PPUSH
56702: LD_VAR 0 4
56706: PPUSH
56707: CALL 56717 0 5
56711: ST_TO_ADDR
// end ;
56712: LD_VAR 0 5
56716: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56717: LD_INT 0
56719: PPUSH
56720: PPUSH
56721: PPUSH
56722: PPUSH
// if not list then
56723: LD_VAR 0 3
56727: NOT
56728: IFFALSE 56732
// exit ;
56730: GO 57120
// result := [ ] ;
56732: LD_ADDR_VAR 0 6
56736: PUSH
56737: EMPTY
56738: ST_TO_ADDR
// for i in list do
56739: LD_ADDR_VAR 0 7
56743: PUSH
56744: LD_VAR 0 3
56748: PUSH
56749: FOR_IN
56750: IFFALSE 56952
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56752: LD_ADDR_VAR 0 9
56756: PUSH
56757: LD_VAR 0 7
56761: PPUSH
56762: LD_VAR 0 1
56766: PPUSH
56767: LD_VAR 0 2
56771: PPUSH
56772: CALL_OW 297
56776: ST_TO_ADDR
// if not result then
56777: LD_VAR 0 6
56781: NOT
56782: IFFALSE 56808
// result := [ [ i , tmp ] ] else
56784: LD_ADDR_VAR 0 6
56788: PUSH
56789: LD_VAR 0 7
56793: PUSH
56794: LD_VAR 0 9
56798: PUSH
56799: EMPTY
56800: LIST
56801: LIST
56802: PUSH
56803: EMPTY
56804: LIST
56805: ST_TO_ADDR
56806: GO 56950
// begin if result [ result ] [ 2 ] < tmp then
56808: LD_VAR 0 6
56812: PUSH
56813: LD_VAR 0 6
56817: ARRAY
56818: PUSH
56819: LD_INT 2
56821: ARRAY
56822: PUSH
56823: LD_VAR 0 9
56827: LESS
56828: IFFALSE 56870
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56830: LD_ADDR_VAR 0 6
56834: PUSH
56835: LD_VAR 0 6
56839: PPUSH
56840: LD_VAR 0 6
56844: PUSH
56845: LD_INT 1
56847: PLUS
56848: PPUSH
56849: LD_VAR 0 7
56853: PUSH
56854: LD_VAR 0 9
56858: PUSH
56859: EMPTY
56860: LIST
56861: LIST
56862: PPUSH
56863: CALL_OW 2
56867: ST_TO_ADDR
56868: GO 56950
// for j = 1 to result do
56870: LD_ADDR_VAR 0 8
56874: PUSH
56875: DOUBLE
56876: LD_INT 1
56878: DEC
56879: ST_TO_ADDR
56880: LD_VAR 0 6
56884: PUSH
56885: FOR_TO
56886: IFFALSE 56948
// begin if tmp < result [ j ] [ 2 ] then
56888: LD_VAR 0 9
56892: PUSH
56893: LD_VAR 0 6
56897: PUSH
56898: LD_VAR 0 8
56902: ARRAY
56903: PUSH
56904: LD_INT 2
56906: ARRAY
56907: LESS
56908: IFFALSE 56946
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56910: LD_ADDR_VAR 0 6
56914: PUSH
56915: LD_VAR 0 6
56919: PPUSH
56920: LD_VAR 0 8
56924: PPUSH
56925: LD_VAR 0 7
56929: PUSH
56930: LD_VAR 0 9
56934: PUSH
56935: EMPTY
56936: LIST
56937: LIST
56938: PPUSH
56939: CALL_OW 2
56943: ST_TO_ADDR
// break ;
56944: GO 56948
// end ; end ;
56946: GO 56885
56948: POP
56949: POP
// end ; end ;
56950: GO 56749
56952: POP
56953: POP
// if result and not asc then
56954: LD_VAR 0 6
56958: PUSH
56959: LD_VAR 0 4
56963: NOT
56964: AND
56965: IFFALSE 57040
// begin tmp := result ;
56967: LD_ADDR_VAR 0 9
56971: PUSH
56972: LD_VAR 0 6
56976: ST_TO_ADDR
// for i = tmp downto 1 do
56977: LD_ADDR_VAR 0 7
56981: PUSH
56982: DOUBLE
56983: LD_VAR 0 9
56987: INC
56988: ST_TO_ADDR
56989: LD_INT 1
56991: PUSH
56992: FOR_DOWNTO
56993: IFFALSE 57038
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56995: LD_ADDR_VAR 0 6
56999: PUSH
57000: LD_VAR 0 6
57004: PPUSH
57005: LD_VAR 0 9
57009: PUSH
57010: LD_VAR 0 7
57014: MINUS
57015: PUSH
57016: LD_INT 1
57018: PLUS
57019: PPUSH
57020: LD_VAR 0 9
57024: PUSH
57025: LD_VAR 0 7
57029: ARRAY
57030: PPUSH
57031: CALL_OW 1
57035: ST_TO_ADDR
57036: GO 56992
57038: POP
57039: POP
// end ; tmp := [ ] ;
57040: LD_ADDR_VAR 0 9
57044: PUSH
57045: EMPTY
57046: ST_TO_ADDR
// if mode then
57047: LD_VAR 0 5
57051: IFFALSE 57120
// begin for i = 1 to result do
57053: LD_ADDR_VAR 0 7
57057: PUSH
57058: DOUBLE
57059: LD_INT 1
57061: DEC
57062: ST_TO_ADDR
57063: LD_VAR 0 6
57067: PUSH
57068: FOR_TO
57069: IFFALSE 57108
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57071: LD_ADDR_VAR 0 9
57075: PUSH
57076: LD_VAR 0 9
57080: PPUSH
57081: LD_VAR 0 7
57085: PPUSH
57086: LD_VAR 0 6
57090: PUSH
57091: LD_VAR 0 7
57095: ARRAY
57096: PUSH
57097: LD_INT 1
57099: ARRAY
57100: PPUSH
57101: CALL_OW 1
57105: ST_TO_ADDR
57106: GO 57068
57108: POP
57109: POP
// result := tmp ;
57110: LD_ADDR_VAR 0 6
57114: PUSH
57115: LD_VAR 0 9
57119: ST_TO_ADDR
// end ; end ;
57120: LD_VAR 0 6
57124: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57125: LD_INT 0
57127: PPUSH
57128: PPUSH
57129: PPUSH
57130: PPUSH
57131: PPUSH
57132: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57133: LD_ADDR_VAR 0 5
57137: PUSH
57138: LD_INT 0
57140: PUSH
57141: LD_INT 0
57143: PUSH
57144: LD_INT 0
57146: PUSH
57147: EMPTY
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: LIST
57153: LIST
57154: ST_TO_ADDR
// if not x or not y then
57155: LD_VAR 0 2
57159: NOT
57160: PUSH
57161: LD_VAR 0 3
57165: NOT
57166: OR
57167: IFFALSE 57171
// exit ;
57169: GO 58817
// if not range then
57171: LD_VAR 0 4
57175: NOT
57176: IFFALSE 57186
// range := 10 ;
57178: LD_ADDR_VAR 0 4
57182: PUSH
57183: LD_INT 10
57185: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57186: LD_ADDR_VAR 0 8
57190: PUSH
57191: LD_INT 81
57193: PUSH
57194: LD_VAR 0 1
57198: PUSH
57199: EMPTY
57200: LIST
57201: LIST
57202: PUSH
57203: LD_INT 92
57205: PUSH
57206: LD_VAR 0 2
57210: PUSH
57211: LD_VAR 0 3
57215: PUSH
57216: LD_VAR 0 4
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: LIST
57225: LIST
57226: PUSH
57227: LD_INT 3
57229: PUSH
57230: LD_INT 21
57232: PUSH
57233: LD_INT 3
57235: PUSH
57236: EMPTY
57237: LIST
57238: LIST
57239: PUSH
57240: EMPTY
57241: LIST
57242: LIST
57243: PUSH
57244: EMPTY
57245: LIST
57246: LIST
57247: LIST
57248: PPUSH
57249: CALL_OW 69
57253: ST_TO_ADDR
// if not tmp then
57254: LD_VAR 0 8
57258: NOT
57259: IFFALSE 57263
// exit ;
57261: GO 58817
// for i in tmp do
57263: LD_ADDR_VAR 0 6
57267: PUSH
57268: LD_VAR 0 8
57272: PUSH
57273: FOR_IN
57274: IFFALSE 58792
// begin points := [ 0 , 0 , 0 ] ;
57276: LD_ADDR_VAR 0 9
57280: PUSH
57281: LD_INT 0
57283: PUSH
57284: LD_INT 0
57286: PUSH
57287: LD_INT 0
57289: PUSH
57290: EMPTY
57291: LIST
57292: LIST
57293: LIST
57294: ST_TO_ADDR
// bpoints := 1 ;
57295: LD_ADDR_VAR 0 10
57299: PUSH
57300: LD_INT 1
57302: ST_TO_ADDR
// case GetType ( i ) of unit_human :
57303: LD_VAR 0 6
57307: PPUSH
57308: CALL_OW 247
57312: PUSH
57313: LD_INT 1
57315: DOUBLE
57316: EQUAL
57317: IFTRUE 57321
57319: GO 57899
57321: POP
// begin if GetClass ( i ) = 1 then
57322: LD_VAR 0 6
57326: PPUSH
57327: CALL_OW 257
57331: PUSH
57332: LD_INT 1
57334: EQUAL
57335: IFFALSE 57356
// points := [ 10 , 5 , 3 ] ;
57337: LD_ADDR_VAR 0 9
57341: PUSH
57342: LD_INT 10
57344: PUSH
57345: LD_INT 5
57347: PUSH
57348: LD_INT 3
57350: PUSH
57351: EMPTY
57352: LIST
57353: LIST
57354: LIST
57355: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
57356: LD_VAR 0 6
57360: PPUSH
57361: CALL_OW 257
57365: PUSH
57366: LD_INT 2
57368: PUSH
57369: LD_INT 3
57371: PUSH
57372: LD_INT 4
57374: PUSH
57375: EMPTY
57376: LIST
57377: LIST
57378: LIST
57379: IN
57380: IFFALSE 57401
// points := [ 3 , 2 , 1 ] ;
57382: LD_ADDR_VAR 0 9
57386: PUSH
57387: LD_INT 3
57389: PUSH
57390: LD_INT 2
57392: PUSH
57393: LD_INT 1
57395: PUSH
57396: EMPTY
57397: LIST
57398: LIST
57399: LIST
57400: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57401: LD_VAR 0 6
57405: PPUSH
57406: CALL_OW 257
57410: PUSH
57411: LD_INT 5
57413: EQUAL
57414: IFFALSE 57435
// points := [ 130 , 5 , 2 ] ;
57416: LD_ADDR_VAR 0 9
57420: PUSH
57421: LD_INT 130
57423: PUSH
57424: LD_INT 5
57426: PUSH
57427: LD_INT 2
57429: PUSH
57430: EMPTY
57431: LIST
57432: LIST
57433: LIST
57434: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57435: LD_VAR 0 6
57439: PPUSH
57440: CALL_OW 257
57444: PUSH
57445: LD_INT 8
57447: EQUAL
57448: IFFALSE 57469
// points := [ 35 , 35 , 30 ] ;
57450: LD_ADDR_VAR 0 9
57454: PUSH
57455: LD_INT 35
57457: PUSH
57458: LD_INT 35
57460: PUSH
57461: LD_INT 30
57463: PUSH
57464: EMPTY
57465: LIST
57466: LIST
57467: LIST
57468: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57469: LD_VAR 0 6
57473: PPUSH
57474: CALL_OW 257
57478: PUSH
57479: LD_INT 9
57481: EQUAL
57482: IFFALSE 57503
// points := [ 20 , 55 , 40 ] ;
57484: LD_ADDR_VAR 0 9
57488: PUSH
57489: LD_INT 20
57491: PUSH
57492: LD_INT 55
57494: PUSH
57495: LD_INT 40
57497: PUSH
57498: EMPTY
57499: LIST
57500: LIST
57501: LIST
57502: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57503: LD_VAR 0 6
57507: PPUSH
57508: CALL_OW 257
57512: PUSH
57513: LD_INT 12
57515: PUSH
57516: LD_INT 16
57518: PUSH
57519: EMPTY
57520: LIST
57521: LIST
57522: IN
57523: IFFALSE 57544
// points := [ 5 , 3 , 2 ] ;
57525: LD_ADDR_VAR 0 9
57529: PUSH
57530: LD_INT 5
57532: PUSH
57533: LD_INT 3
57535: PUSH
57536: LD_INT 2
57538: PUSH
57539: EMPTY
57540: LIST
57541: LIST
57542: LIST
57543: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57544: LD_VAR 0 6
57548: PPUSH
57549: CALL_OW 257
57553: PUSH
57554: LD_INT 17
57556: EQUAL
57557: IFFALSE 57578
// points := [ 100 , 50 , 75 ] ;
57559: LD_ADDR_VAR 0 9
57563: PUSH
57564: LD_INT 100
57566: PUSH
57567: LD_INT 50
57569: PUSH
57570: LD_INT 75
57572: PUSH
57573: EMPTY
57574: LIST
57575: LIST
57576: LIST
57577: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57578: LD_VAR 0 6
57582: PPUSH
57583: CALL_OW 257
57587: PUSH
57588: LD_INT 15
57590: EQUAL
57591: IFFALSE 57612
// points := [ 10 , 5 , 3 ] ;
57593: LD_ADDR_VAR 0 9
57597: PUSH
57598: LD_INT 10
57600: PUSH
57601: LD_INT 5
57603: PUSH
57604: LD_INT 3
57606: PUSH
57607: EMPTY
57608: LIST
57609: LIST
57610: LIST
57611: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57612: LD_VAR 0 6
57616: PPUSH
57617: CALL_OW 257
57621: PUSH
57622: LD_INT 14
57624: EQUAL
57625: IFFALSE 57646
// points := [ 10 , 0 , 0 ] ;
57627: LD_ADDR_VAR 0 9
57631: PUSH
57632: LD_INT 10
57634: PUSH
57635: LD_INT 0
57637: PUSH
57638: LD_INT 0
57640: PUSH
57641: EMPTY
57642: LIST
57643: LIST
57644: LIST
57645: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57646: LD_VAR 0 6
57650: PPUSH
57651: CALL_OW 257
57655: PUSH
57656: LD_INT 11
57658: EQUAL
57659: IFFALSE 57680
// points := [ 30 , 10 , 5 ] ;
57661: LD_ADDR_VAR 0 9
57665: PUSH
57666: LD_INT 30
57668: PUSH
57669: LD_INT 10
57671: PUSH
57672: LD_INT 5
57674: PUSH
57675: EMPTY
57676: LIST
57677: LIST
57678: LIST
57679: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57680: LD_VAR 0 1
57684: PPUSH
57685: LD_INT 5
57687: PPUSH
57688: CALL_OW 321
57692: PUSH
57693: LD_INT 2
57695: EQUAL
57696: IFFALSE 57713
// bpoints := bpoints * 1.8 ;
57698: LD_ADDR_VAR 0 10
57702: PUSH
57703: LD_VAR 0 10
57707: PUSH
57708: LD_REAL  1.80000000000000E+0000
57711: MUL
57712: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57713: LD_VAR 0 6
57717: PPUSH
57718: CALL_OW 257
57722: PUSH
57723: LD_INT 1
57725: PUSH
57726: LD_INT 2
57728: PUSH
57729: LD_INT 3
57731: PUSH
57732: LD_INT 4
57734: PUSH
57735: EMPTY
57736: LIST
57737: LIST
57738: LIST
57739: LIST
57740: IN
57741: PUSH
57742: LD_VAR 0 1
57746: PPUSH
57747: LD_INT 51
57749: PPUSH
57750: CALL_OW 321
57754: PUSH
57755: LD_INT 2
57757: EQUAL
57758: AND
57759: IFFALSE 57776
// bpoints := bpoints * 1.2 ;
57761: LD_ADDR_VAR 0 10
57765: PUSH
57766: LD_VAR 0 10
57770: PUSH
57771: LD_REAL  1.20000000000000E+0000
57774: MUL
57775: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57776: LD_VAR 0 6
57780: PPUSH
57781: CALL_OW 257
57785: PUSH
57786: LD_INT 5
57788: PUSH
57789: LD_INT 7
57791: PUSH
57792: LD_INT 9
57794: PUSH
57795: EMPTY
57796: LIST
57797: LIST
57798: LIST
57799: IN
57800: PUSH
57801: LD_VAR 0 1
57805: PPUSH
57806: LD_INT 52
57808: PPUSH
57809: CALL_OW 321
57813: PUSH
57814: LD_INT 2
57816: EQUAL
57817: AND
57818: IFFALSE 57835
// bpoints := bpoints * 1.5 ;
57820: LD_ADDR_VAR 0 10
57824: PUSH
57825: LD_VAR 0 10
57829: PUSH
57830: LD_REAL  1.50000000000000E+0000
57833: MUL
57834: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57835: LD_VAR 0 1
57839: PPUSH
57840: LD_INT 66
57842: PPUSH
57843: CALL_OW 321
57847: PUSH
57848: LD_INT 2
57850: EQUAL
57851: IFFALSE 57868
// bpoints := bpoints * 1.1 ;
57853: LD_ADDR_VAR 0 10
57857: PUSH
57858: LD_VAR 0 10
57862: PUSH
57863: LD_REAL  1.10000000000000E+0000
57866: MUL
57867: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57868: LD_ADDR_VAR 0 10
57872: PUSH
57873: LD_VAR 0 10
57877: PUSH
57878: LD_VAR 0 6
57882: PPUSH
57883: LD_INT 1
57885: PPUSH
57886: CALL_OW 259
57890: PUSH
57891: LD_REAL  1.15000000000000E+0000
57894: MUL
57895: MUL
57896: ST_TO_ADDR
// end ; unit_vehicle :
57897: GO 58721
57899: LD_INT 2
57901: DOUBLE
57902: EQUAL
57903: IFTRUE 57907
57905: GO 58709
57907: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57908: LD_VAR 0 6
57912: PPUSH
57913: CALL_OW 264
57917: PUSH
57918: LD_INT 2
57920: PUSH
57921: LD_INT 42
57923: PUSH
57924: LD_INT 24
57926: PUSH
57927: EMPTY
57928: LIST
57929: LIST
57930: LIST
57931: IN
57932: IFFALSE 57953
// points := [ 25 , 5 , 3 ] ;
57934: LD_ADDR_VAR 0 9
57938: PUSH
57939: LD_INT 25
57941: PUSH
57942: LD_INT 5
57944: PUSH
57945: LD_INT 3
57947: PUSH
57948: EMPTY
57949: LIST
57950: LIST
57951: LIST
57952: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57953: LD_VAR 0 6
57957: PPUSH
57958: CALL_OW 264
57962: PUSH
57963: LD_INT 4
57965: PUSH
57966: LD_INT 43
57968: PUSH
57969: LD_INT 25
57971: PUSH
57972: EMPTY
57973: LIST
57974: LIST
57975: LIST
57976: IN
57977: IFFALSE 57998
// points := [ 40 , 15 , 5 ] ;
57979: LD_ADDR_VAR 0 9
57983: PUSH
57984: LD_INT 40
57986: PUSH
57987: LD_INT 15
57989: PUSH
57990: LD_INT 5
57992: PUSH
57993: EMPTY
57994: LIST
57995: LIST
57996: LIST
57997: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57998: LD_VAR 0 6
58002: PPUSH
58003: CALL_OW 264
58007: PUSH
58008: LD_INT 3
58010: PUSH
58011: LD_INT 23
58013: PUSH
58014: EMPTY
58015: LIST
58016: LIST
58017: IN
58018: IFFALSE 58039
// points := [ 7 , 25 , 8 ] ;
58020: LD_ADDR_VAR 0 9
58024: PUSH
58025: LD_INT 7
58027: PUSH
58028: LD_INT 25
58030: PUSH
58031: LD_INT 8
58033: PUSH
58034: EMPTY
58035: LIST
58036: LIST
58037: LIST
58038: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58039: LD_VAR 0 6
58043: PPUSH
58044: CALL_OW 264
58048: PUSH
58049: LD_INT 5
58051: PUSH
58052: LD_INT 27
58054: PUSH
58055: LD_INT 44
58057: PUSH
58058: EMPTY
58059: LIST
58060: LIST
58061: LIST
58062: IN
58063: IFFALSE 58084
// points := [ 14 , 50 , 16 ] ;
58065: LD_ADDR_VAR 0 9
58069: PUSH
58070: LD_INT 14
58072: PUSH
58073: LD_INT 50
58075: PUSH
58076: LD_INT 16
58078: PUSH
58079: EMPTY
58080: LIST
58081: LIST
58082: LIST
58083: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58084: LD_VAR 0 6
58088: PPUSH
58089: CALL_OW 264
58093: PUSH
58094: LD_INT 6
58096: PUSH
58097: LD_INT 46
58099: PUSH
58100: EMPTY
58101: LIST
58102: LIST
58103: IN
58104: IFFALSE 58125
// points := [ 32 , 120 , 70 ] ;
58106: LD_ADDR_VAR 0 9
58110: PUSH
58111: LD_INT 32
58113: PUSH
58114: LD_INT 120
58116: PUSH
58117: LD_INT 70
58119: PUSH
58120: EMPTY
58121: LIST
58122: LIST
58123: LIST
58124: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
58125: LD_VAR 0 6
58129: PPUSH
58130: CALL_OW 264
58134: PUSH
58135: LD_INT 7
58137: PUSH
58138: LD_INT 28
58140: PUSH
58141: LD_INT 45
58143: PUSH
58144: EMPTY
58145: LIST
58146: LIST
58147: LIST
58148: IN
58149: IFFALSE 58170
// points := [ 35 , 20 , 45 ] ;
58151: LD_ADDR_VAR 0 9
58155: PUSH
58156: LD_INT 35
58158: PUSH
58159: LD_INT 20
58161: PUSH
58162: LD_INT 45
58164: PUSH
58165: EMPTY
58166: LIST
58167: LIST
58168: LIST
58169: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58170: LD_VAR 0 6
58174: PPUSH
58175: CALL_OW 264
58179: PUSH
58180: LD_INT 47
58182: PUSH
58183: EMPTY
58184: LIST
58185: IN
58186: IFFALSE 58207
// points := [ 67 , 45 , 75 ] ;
58188: LD_ADDR_VAR 0 9
58192: PUSH
58193: LD_INT 67
58195: PUSH
58196: LD_INT 45
58198: PUSH
58199: LD_INT 75
58201: PUSH
58202: EMPTY
58203: LIST
58204: LIST
58205: LIST
58206: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58207: LD_VAR 0 6
58211: PPUSH
58212: CALL_OW 264
58216: PUSH
58217: LD_INT 26
58219: PUSH
58220: EMPTY
58221: LIST
58222: IN
58223: IFFALSE 58244
// points := [ 120 , 30 , 80 ] ;
58225: LD_ADDR_VAR 0 9
58229: PUSH
58230: LD_INT 120
58232: PUSH
58233: LD_INT 30
58235: PUSH
58236: LD_INT 80
58238: PUSH
58239: EMPTY
58240: LIST
58241: LIST
58242: LIST
58243: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58244: LD_VAR 0 6
58248: PPUSH
58249: CALL_OW 264
58253: PUSH
58254: LD_INT 22
58256: PUSH
58257: EMPTY
58258: LIST
58259: IN
58260: IFFALSE 58281
// points := [ 40 , 1 , 1 ] ;
58262: LD_ADDR_VAR 0 9
58266: PUSH
58267: LD_INT 40
58269: PUSH
58270: LD_INT 1
58272: PUSH
58273: LD_INT 1
58275: PUSH
58276: EMPTY
58277: LIST
58278: LIST
58279: LIST
58280: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
58281: LD_VAR 0 6
58285: PPUSH
58286: CALL_OW 264
58290: PUSH
58291: LD_INT 29
58293: PUSH
58294: EMPTY
58295: LIST
58296: IN
58297: IFFALSE 58318
// points := [ 70 , 200 , 400 ] ;
58299: LD_ADDR_VAR 0 9
58303: PUSH
58304: LD_INT 70
58306: PUSH
58307: LD_INT 200
58309: PUSH
58310: LD_INT 400
58312: PUSH
58313: EMPTY
58314: LIST
58315: LIST
58316: LIST
58317: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
58318: LD_VAR 0 6
58322: PPUSH
58323: CALL_OW 264
58327: PUSH
58328: LD_INT 14
58330: PUSH
58331: LD_INT 53
58333: PUSH
58334: EMPTY
58335: LIST
58336: LIST
58337: IN
58338: IFFALSE 58359
// points := [ 40 , 10 , 20 ] ;
58340: LD_ADDR_VAR 0 9
58344: PUSH
58345: LD_INT 40
58347: PUSH
58348: LD_INT 10
58350: PUSH
58351: LD_INT 20
58353: PUSH
58354: EMPTY
58355: LIST
58356: LIST
58357: LIST
58358: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
58359: LD_VAR 0 6
58363: PPUSH
58364: CALL_OW 264
58368: PUSH
58369: LD_INT 9
58371: PUSH
58372: EMPTY
58373: LIST
58374: IN
58375: IFFALSE 58396
// points := [ 5 , 70 , 20 ] ;
58377: LD_ADDR_VAR 0 9
58381: PUSH
58382: LD_INT 5
58384: PUSH
58385: LD_INT 70
58387: PUSH
58388: LD_INT 20
58390: PUSH
58391: EMPTY
58392: LIST
58393: LIST
58394: LIST
58395: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58396: LD_VAR 0 6
58400: PPUSH
58401: CALL_OW 264
58405: PUSH
58406: LD_INT 10
58408: PUSH
58409: EMPTY
58410: LIST
58411: IN
58412: IFFALSE 58433
// points := [ 35 , 110 , 70 ] ;
58414: LD_ADDR_VAR 0 9
58418: PUSH
58419: LD_INT 35
58421: PUSH
58422: LD_INT 110
58424: PUSH
58425: LD_INT 70
58427: PUSH
58428: EMPTY
58429: LIST
58430: LIST
58431: LIST
58432: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58433: LD_VAR 0 6
58437: PPUSH
58438: CALL_OW 265
58442: PUSH
58443: LD_INT 25
58445: EQUAL
58446: IFFALSE 58467
// points := [ 80 , 65 , 100 ] ;
58448: LD_ADDR_VAR 0 9
58452: PUSH
58453: LD_INT 80
58455: PUSH
58456: LD_INT 65
58458: PUSH
58459: LD_INT 100
58461: PUSH
58462: EMPTY
58463: LIST
58464: LIST
58465: LIST
58466: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58467: LD_VAR 0 6
58471: PPUSH
58472: CALL_OW 263
58476: PUSH
58477: LD_INT 1
58479: EQUAL
58480: IFFALSE 58515
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58482: LD_ADDR_VAR 0 10
58486: PUSH
58487: LD_VAR 0 10
58491: PUSH
58492: LD_VAR 0 6
58496: PPUSH
58497: CALL_OW 311
58501: PPUSH
58502: LD_INT 3
58504: PPUSH
58505: CALL_OW 259
58509: PUSH
58510: LD_INT 4
58512: MUL
58513: MUL
58514: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58515: LD_VAR 0 6
58519: PPUSH
58520: CALL_OW 263
58524: PUSH
58525: LD_INT 2
58527: EQUAL
58528: IFFALSE 58579
// begin j := IsControledBy ( i ) ;
58530: LD_ADDR_VAR 0 7
58534: PUSH
58535: LD_VAR 0 6
58539: PPUSH
58540: CALL_OW 312
58544: ST_TO_ADDR
// if j then
58545: LD_VAR 0 7
58549: IFFALSE 58579
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58551: LD_ADDR_VAR 0 10
58555: PUSH
58556: LD_VAR 0 10
58560: PUSH
58561: LD_VAR 0 7
58565: PPUSH
58566: LD_INT 3
58568: PPUSH
58569: CALL_OW 259
58573: PUSH
58574: LD_INT 3
58576: MUL
58577: MUL
58578: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58579: LD_VAR 0 6
58583: PPUSH
58584: CALL_OW 264
58588: PUSH
58589: LD_INT 5
58591: PUSH
58592: LD_INT 6
58594: PUSH
58595: LD_INT 46
58597: PUSH
58598: LD_INT 44
58600: PUSH
58601: LD_INT 47
58603: PUSH
58604: LD_INT 45
58606: PUSH
58607: LD_INT 28
58609: PUSH
58610: LD_INT 7
58612: PUSH
58613: LD_INT 27
58615: PUSH
58616: LD_INT 29
58618: PUSH
58619: EMPTY
58620: LIST
58621: LIST
58622: LIST
58623: LIST
58624: LIST
58625: LIST
58626: LIST
58627: LIST
58628: LIST
58629: LIST
58630: IN
58631: PUSH
58632: LD_VAR 0 1
58636: PPUSH
58637: LD_INT 52
58639: PPUSH
58640: CALL_OW 321
58644: PUSH
58645: LD_INT 2
58647: EQUAL
58648: AND
58649: IFFALSE 58666
// bpoints := bpoints * 1.2 ;
58651: LD_ADDR_VAR 0 10
58655: PUSH
58656: LD_VAR 0 10
58660: PUSH
58661: LD_REAL  1.20000000000000E+0000
58664: MUL
58665: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58666: LD_VAR 0 6
58670: PPUSH
58671: CALL_OW 264
58675: PUSH
58676: LD_INT 6
58678: PUSH
58679: LD_INT 46
58681: PUSH
58682: LD_INT 47
58684: PUSH
58685: EMPTY
58686: LIST
58687: LIST
58688: LIST
58689: IN
58690: IFFALSE 58707
// bpoints := bpoints * 1.2 ;
58692: LD_ADDR_VAR 0 10
58696: PUSH
58697: LD_VAR 0 10
58701: PUSH
58702: LD_REAL  1.20000000000000E+0000
58705: MUL
58706: ST_TO_ADDR
// end ; unit_building :
58707: GO 58721
58709: LD_INT 3
58711: DOUBLE
58712: EQUAL
58713: IFTRUE 58717
58715: GO 58720
58717: POP
// ; end ;
58718: GO 58721
58720: POP
// for j = 1 to 3 do
58721: LD_ADDR_VAR 0 7
58725: PUSH
58726: DOUBLE
58727: LD_INT 1
58729: DEC
58730: ST_TO_ADDR
58731: LD_INT 3
58733: PUSH
58734: FOR_TO
58735: IFFALSE 58788
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58737: LD_ADDR_VAR 0 5
58741: PUSH
58742: LD_VAR 0 5
58746: PPUSH
58747: LD_VAR 0 7
58751: PPUSH
58752: LD_VAR 0 5
58756: PUSH
58757: LD_VAR 0 7
58761: ARRAY
58762: PUSH
58763: LD_VAR 0 9
58767: PUSH
58768: LD_VAR 0 7
58772: ARRAY
58773: PUSH
58774: LD_VAR 0 10
58778: MUL
58779: PLUS
58780: PPUSH
58781: CALL_OW 1
58785: ST_TO_ADDR
58786: GO 58734
58788: POP
58789: POP
// end ;
58790: GO 57273
58792: POP
58793: POP
// result := Replace ( result , 4 , tmp ) ;
58794: LD_ADDR_VAR 0 5
58798: PUSH
58799: LD_VAR 0 5
58803: PPUSH
58804: LD_INT 4
58806: PPUSH
58807: LD_VAR 0 8
58811: PPUSH
58812: CALL_OW 1
58816: ST_TO_ADDR
// end ;
58817: LD_VAR 0 5
58821: RET
// export function DangerAtRange ( unit , range ) ; begin
58822: LD_INT 0
58824: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58825: LD_ADDR_VAR 0 3
58829: PUSH
58830: LD_VAR 0 1
58834: PPUSH
58835: CALL_OW 255
58839: PPUSH
58840: LD_VAR 0 1
58844: PPUSH
58845: CALL_OW 250
58849: PPUSH
58850: LD_VAR 0 1
58854: PPUSH
58855: CALL_OW 251
58859: PPUSH
58860: LD_VAR 0 2
58864: PPUSH
58865: CALL 57125 0 4
58869: ST_TO_ADDR
// end ;
58870: LD_VAR 0 3
58874: RET
// export function DangerInArea ( side , area ) ; begin
58875: LD_INT 0
58877: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58878: LD_ADDR_VAR 0 3
58882: PUSH
58883: LD_VAR 0 2
58887: PPUSH
58888: LD_INT 81
58890: PUSH
58891: LD_VAR 0 1
58895: PUSH
58896: EMPTY
58897: LIST
58898: LIST
58899: PPUSH
58900: CALL_OW 70
58904: ST_TO_ADDR
// end ;
58905: LD_VAR 0 3
58909: RET
// export function IsExtension ( b ) ; begin
58910: LD_INT 0
58912: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58913: LD_ADDR_VAR 0 2
58917: PUSH
58918: LD_VAR 0 1
58922: PUSH
58923: LD_INT 23
58925: PUSH
58926: LD_INT 20
58928: PUSH
58929: LD_INT 22
58931: PUSH
58932: LD_INT 17
58934: PUSH
58935: LD_INT 24
58937: PUSH
58938: LD_INT 21
58940: PUSH
58941: LD_INT 19
58943: PUSH
58944: LD_INT 16
58946: PUSH
58947: LD_INT 25
58949: PUSH
58950: LD_INT 18
58952: PUSH
58953: EMPTY
58954: LIST
58955: LIST
58956: LIST
58957: LIST
58958: LIST
58959: LIST
58960: LIST
58961: LIST
58962: LIST
58963: LIST
58964: IN
58965: ST_TO_ADDR
// end ;
58966: LD_VAR 0 2
58970: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
58971: LD_INT 0
58973: PPUSH
58974: PPUSH
58975: PPUSH
// result := [ ] ;
58976: LD_ADDR_VAR 0 3
58980: PUSH
58981: EMPTY
58982: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58983: LD_ADDR_VAR 0 4
58987: PUSH
58988: LD_VAR 0 2
58992: PPUSH
58993: LD_INT 21
58995: PUSH
58996: LD_INT 3
58998: PUSH
58999: EMPTY
59000: LIST
59001: LIST
59002: PPUSH
59003: CALL_OW 70
59007: ST_TO_ADDR
// if not tmp then
59008: LD_VAR 0 4
59012: NOT
59013: IFFALSE 59017
// exit ;
59015: GO 59075
// for i in tmp do
59017: LD_ADDR_VAR 0 5
59021: PUSH
59022: LD_VAR 0 4
59026: PUSH
59027: FOR_IN
59028: IFFALSE 59063
// if GetBase ( i ) <> base then
59030: LD_VAR 0 5
59034: PPUSH
59035: CALL_OW 274
59039: PUSH
59040: LD_VAR 0 1
59044: NONEQUAL
59045: IFFALSE 59061
// ComLinkToBase ( base , i ) ;
59047: LD_VAR 0 1
59051: PPUSH
59052: LD_VAR 0 5
59056: PPUSH
59057: CALL_OW 169
59061: GO 59027
59063: POP
59064: POP
// result := tmp ;
59065: LD_ADDR_VAR 0 3
59069: PUSH
59070: LD_VAR 0 4
59074: ST_TO_ADDR
// end ;
59075: LD_VAR 0 3
59079: RET
// export function ComComplete ( unit , b ) ; var i ; begin
59080: LD_INT 0
59082: PPUSH
59083: PPUSH
// if BuildingStatus ( b ) = bs_build then
59084: LD_VAR 0 2
59088: PPUSH
59089: CALL_OW 461
59093: PUSH
59094: LD_INT 1
59096: EQUAL
59097: IFFALSE 59157
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59099: LD_VAR 0 1
59103: PPUSH
59104: LD_STRING h
59106: PUSH
59107: LD_VAR 0 2
59111: PPUSH
59112: CALL_OW 250
59116: PUSH
59117: LD_VAR 0 2
59121: PPUSH
59122: CALL_OW 251
59126: PUSH
59127: LD_VAR 0 2
59131: PUSH
59132: LD_INT 0
59134: PUSH
59135: LD_INT 0
59137: PUSH
59138: LD_INT 0
59140: PUSH
59141: EMPTY
59142: LIST
59143: LIST
59144: LIST
59145: LIST
59146: LIST
59147: LIST
59148: LIST
59149: PUSH
59150: EMPTY
59151: LIST
59152: PPUSH
59153: CALL_OW 446
// end ;
59157: LD_VAR 0 3
59161: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59162: LD_INT 0
59164: PPUSH
59165: PPUSH
59166: PPUSH
59167: PPUSH
59168: PPUSH
59169: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
59170: LD_VAR 0 1
59174: NOT
59175: PUSH
59176: LD_VAR 0 1
59180: PPUSH
59181: CALL_OW 263
59185: PUSH
59186: LD_INT 2
59188: EQUAL
59189: NOT
59190: OR
59191: IFFALSE 59195
// exit ;
59193: GO 59511
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59195: LD_ADDR_VAR 0 6
59199: PUSH
59200: LD_INT 22
59202: PUSH
59203: LD_VAR 0 1
59207: PPUSH
59208: CALL_OW 255
59212: PUSH
59213: EMPTY
59214: LIST
59215: LIST
59216: PUSH
59217: LD_INT 2
59219: PUSH
59220: LD_INT 30
59222: PUSH
59223: LD_INT 36
59225: PUSH
59226: EMPTY
59227: LIST
59228: LIST
59229: PUSH
59230: LD_INT 34
59232: PUSH
59233: LD_INT 31
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: PUSH
59240: EMPTY
59241: LIST
59242: LIST
59243: LIST
59244: PUSH
59245: EMPTY
59246: LIST
59247: LIST
59248: PPUSH
59249: CALL_OW 69
59253: ST_TO_ADDR
// if not tmp then
59254: LD_VAR 0 6
59258: NOT
59259: IFFALSE 59263
// exit ;
59261: GO 59511
// result := [ ] ;
59263: LD_ADDR_VAR 0 2
59267: PUSH
59268: EMPTY
59269: ST_TO_ADDR
// for i in tmp do
59270: LD_ADDR_VAR 0 3
59274: PUSH
59275: LD_VAR 0 6
59279: PUSH
59280: FOR_IN
59281: IFFALSE 59352
// begin t := UnitsInside ( i ) ;
59283: LD_ADDR_VAR 0 4
59287: PUSH
59288: LD_VAR 0 3
59292: PPUSH
59293: CALL_OW 313
59297: ST_TO_ADDR
// if t then
59298: LD_VAR 0 4
59302: IFFALSE 59350
// for j in t do
59304: LD_ADDR_VAR 0 7
59308: PUSH
59309: LD_VAR 0 4
59313: PUSH
59314: FOR_IN
59315: IFFALSE 59348
// result := Insert ( result , result + 1 , j ) ;
59317: LD_ADDR_VAR 0 2
59321: PUSH
59322: LD_VAR 0 2
59326: PPUSH
59327: LD_VAR 0 2
59331: PUSH
59332: LD_INT 1
59334: PLUS
59335: PPUSH
59336: LD_VAR 0 7
59340: PPUSH
59341: CALL_OW 2
59345: ST_TO_ADDR
59346: GO 59314
59348: POP
59349: POP
// end ;
59350: GO 59280
59352: POP
59353: POP
// if not result then
59354: LD_VAR 0 2
59358: NOT
59359: IFFALSE 59363
// exit ;
59361: GO 59511
// mech := result [ 1 ] ;
59363: LD_ADDR_VAR 0 5
59367: PUSH
59368: LD_VAR 0 2
59372: PUSH
59373: LD_INT 1
59375: ARRAY
59376: ST_TO_ADDR
// if result > 1 then
59377: LD_VAR 0 2
59381: PUSH
59382: LD_INT 1
59384: GREATER
59385: IFFALSE 59497
// for i = 2 to result do
59387: LD_ADDR_VAR 0 3
59391: PUSH
59392: DOUBLE
59393: LD_INT 2
59395: DEC
59396: ST_TO_ADDR
59397: LD_VAR 0 2
59401: PUSH
59402: FOR_TO
59403: IFFALSE 59495
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59405: LD_ADDR_VAR 0 4
59409: PUSH
59410: LD_VAR 0 2
59414: PUSH
59415: LD_VAR 0 3
59419: ARRAY
59420: PPUSH
59421: LD_INT 3
59423: PPUSH
59424: CALL_OW 259
59428: PUSH
59429: LD_VAR 0 2
59433: PUSH
59434: LD_VAR 0 3
59438: ARRAY
59439: PPUSH
59440: CALL_OW 432
59444: MINUS
59445: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59446: LD_VAR 0 4
59450: PUSH
59451: LD_VAR 0 5
59455: PPUSH
59456: LD_INT 3
59458: PPUSH
59459: CALL_OW 259
59463: PUSH
59464: LD_VAR 0 5
59468: PPUSH
59469: CALL_OW 432
59473: MINUS
59474: GREATEREQUAL
59475: IFFALSE 59493
// mech := result [ i ] ;
59477: LD_ADDR_VAR 0 5
59481: PUSH
59482: LD_VAR 0 2
59486: PUSH
59487: LD_VAR 0 3
59491: ARRAY
59492: ST_TO_ADDR
// end ;
59493: GO 59402
59495: POP
59496: POP
// ComLinkTo ( vehicle , mech ) ;
59497: LD_VAR 0 1
59501: PPUSH
59502: LD_VAR 0 5
59506: PPUSH
59507: CALL_OW 135
// end ;
59511: LD_VAR 0 2
59515: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59516: LD_INT 0
59518: PPUSH
59519: PPUSH
59520: PPUSH
59521: PPUSH
59522: PPUSH
59523: PPUSH
59524: PPUSH
59525: PPUSH
59526: PPUSH
59527: PPUSH
59528: PPUSH
59529: PPUSH
59530: PPUSH
// result := [ ] ;
59531: LD_ADDR_VAR 0 7
59535: PUSH
59536: EMPTY
59537: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59538: LD_VAR 0 1
59542: PPUSH
59543: CALL_OW 266
59547: PUSH
59548: LD_INT 0
59550: PUSH
59551: LD_INT 1
59553: PUSH
59554: EMPTY
59555: LIST
59556: LIST
59557: IN
59558: NOT
59559: IFFALSE 59563
// exit ;
59561: GO 61194
// if name then
59563: LD_VAR 0 3
59567: IFFALSE 59583
// SetBName ( base_dep , name ) ;
59569: LD_VAR 0 1
59573: PPUSH
59574: LD_VAR 0 3
59578: PPUSH
59579: CALL_OW 500
// base := GetBase ( base_dep ) ;
59583: LD_ADDR_VAR 0 15
59587: PUSH
59588: LD_VAR 0 1
59592: PPUSH
59593: CALL_OW 274
59597: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59598: LD_ADDR_VAR 0 16
59602: PUSH
59603: LD_VAR 0 1
59607: PPUSH
59608: CALL_OW 255
59612: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59613: LD_ADDR_VAR 0 17
59617: PUSH
59618: LD_VAR 0 1
59622: PPUSH
59623: CALL_OW 248
59627: ST_TO_ADDR
// if sources then
59628: LD_VAR 0 5
59632: IFFALSE 59679
// for i = 1 to 3 do
59634: LD_ADDR_VAR 0 8
59638: PUSH
59639: DOUBLE
59640: LD_INT 1
59642: DEC
59643: ST_TO_ADDR
59644: LD_INT 3
59646: PUSH
59647: FOR_TO
59648: IFFALSE 59677
// AddResourceType ( base , i , sources [ i ] ) ;
59650: LD_VAR 0 15
59654: PPUSH
59655: LD_VAR 0 8
59659: PPUSH
59660: LD_VAR 0 5
59664: PUSH
59665: LD_VAR 0 8
59669: ARRAY
59670: PPUSH
59671: CALL_OW 276
59675: GO 59647
59677: POP
59678: POP
// buildings := GetBaseBuildings ( base , area ) ;
59679: LD_ADDR_VAR 0 18
59683: PUSH
59684: LD_VAR 0 15
59688: PPUSH
59689: LD_VAR 0 2
59693: PPUSH
59694: CALL 58971 0 2
59698: ST_TO_ADDR
// InitHc ;
59699: CALL_OW 19
// InitUc ;
59703: CALL_OW 18
// uc_side := side ;
59707: LD_ADDR_OWVAR 20
59711: PUSH
59712: LD_VAR 0 16
59716: ST_TO_ADDR
// uc_nation := nation ;
59717: LD_ADDR_OWVAR 21
59721: PUSH
59722: LD_VAR 0 17
59726: ST_TO_ADDR
// if buildings then
59727: LD_VAR 0 18
59731: IFFALSE 61053
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59733: LD_ADDR_VAR 0 19
59737: PUSH
59738: LD_VAR 0 18
59742: PPUSH
59743: LD_INT 2
59745: PUSH
59746: LD_INT 30
59748: PUSH
59749: LD_INT 29
59751: PUSH
59752: EMPTY
59753: LIST
59754: LIST
59755: PUSH
59756: LD_INT 30
59758: PUSH
59759: LD_INT 30
59761: PUSH
59762: EMPTY
59763: LIST
59764: LIST
59765: PUSH
59766: EMPTY
59767: LIST
59768: LIST
59769: LIST
59770: PPUSH
59771: CALL_OW 72
59775: ST_TO_ADDR
// if tmp then
59776: LD_VAR 0 19
59780: IFFALSE 59828
// for i in tmp do
59782: LD_ADDR_VAR 0 8
59786: PUSH
59787: LD_VAR 0 19
59791: PUSH
59792: FOR_IN
59793: IFFALSE 59826
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59795: LD_VAR 0 8
59799: PPUSH
59800: CALL_OW 250
59804: PPUSH
59805: LD_VAR 0 8
59809: PPUSH
59810: CALL_OW 251
59814: PPUSH
59815: LD_VAR 0 16
59819: PPUSH
59820: CALL_OW 441
59824: GO 59792
59826: POP
59827: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59828: LD_VAR 0 18
59832: PPUSH
59833: LD_INT 2
59835: PUSH
59836: LD_INT 30
59838: PUSH
59839: LD_INT 32
59841: PUSH
59842: EMPTY
59843: LIST
59844: LIST
59845: PUSH
59846: LD_INT 30
59848: PUSH
59849: LD_INT 33
59851: PUSH
59852: EMPTY
59853: LIST
59854: LIST
59855: PUSH
59856: EMPTY
59857: LIST
59858: LIST
59859: LIST
59860: PPUSH
59861: CALL_OW 72
59865: IFFALSE 59953
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59867: LD_ADDR_VAR 0 8
59871: PUSH
59872: LD_VAR 0 18
59876: PPUSH
59877: LD_INT 2
59879: PUSH
59880: LD_INT 30
59882: PUSH
59883: LD_INT 32
59885: PUSH
59886: EMPTY
59887: LIST
59888: LIST
59889: PUSH
59890: LD_INT 30
59892: PUSH
59893: LD_INT 33
59895: PUSH
59896: EMPTY
59897: LIST
59898: LIST
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: LIST
59904: PPUSH
59905: CALL_OW 72
59909: PUSH
59910: FOR_IN
59911: IFFALSE 59951
// begin if not GetBWeapon ( i ) then
59913: LD_VAR 0 8
59917: PPUSH
59918: CALL_OW 269
59922: NOT
59923: IFFALSE 59949
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59925: LD_VAR 0 8
59929: PPUSH
59930: LD_VAR 0 8
59934: PPUSH
59935: LD_VAR 0 2
59939: PPUSH
59940: CALL 61199 0 2
59944: PPUSH
59945: CALL_OW 431
// end ;
59949: GO 59910
59951: POP
59952: POP
// end ; for i = 1 to personel do
59953: LD_ADDR_VAR 0 8
59957: PUSH
59958: DOUBLE
59959: LD_INT 1
59961: DEC
59962: ST_TO_ADDR
59963: LD_VAR 0 6
59967: PUSH
59968: FOR_TO
59969: IFFALSE 61033
// begin if i > 4 then
59971: LD_VAR 0 8
59975: PUSH
59976: LD_INT 4
59978: GREATER
59979: IFFALSE 59983
// break ;
59981: GO 61033
// case i of 1 :
59983: LD_VAR 0 8
59987: PUSH
59988: LD_INT 1
59990: DOUBLE
59991: EQUAL
59992: IFTRUE 59996
59994: GO 60076
59996: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59997: LD_ADDR_VAR 0 12
60001: PUSH
60002: LD_VAR 0 18
60006: PPUSH
60007: LD_INT 22
60009: PUSH
60010: LD_VAR 0 16
60014: PUSH
60015: EMPTY
60016: LIST
60017: LIST
60018: PUSH
60019: LD_INT 58
60021: PUSH
60022: EMPTY
60023: LIST
60024: PUSH
60025: LD_INT 2
60027: PUSH
60028: LD_INT 30
60030: PUSH
60031: LD_INT 32
60033: PUSH
60034: EMPTY
60035: LIST
60036: LIST
60037: PUSH
60038: LD_INT 30
60040: PUSH
60041: LD_INT 4
60043: PUSH
60044: EMPTY
60045: LIST
60046: LIST
60047: PUSH
60048: LD_INT 30
60050: PUSH
60051: LD_INT 5
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PUSH
60058: EMPTY
60059: LIST
60060: LIST
60061: LIST
60062: LIST
60063: PUSH
60064: EMPTY
60065: LIST
60066: LIST
60067: LIST
60068: PPUSH
60069: CALL_OW 72
60073: ST_TO_ADDR
60074: GO 60298
60076: LD_INT 2
60078: DOUBLE
60079: EQUAL
60080: IFTRUE 60084
60082: GO 60146
60084: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60085: LD_ADDR_VAR 0 12
60089: PUSH
60090: LD_VAR 0 18
60094: PPUSH
60095: LD_INT 22
60097: PUSH
60098: LD_VAR 0 16
60102: PUSH
60103: EMPTY
60104: LIST
60105: LIST
60106: PUSH
60107: LD_INT 2
60109: PUSH
60110: LD_INT 30
60112: PUSH
60113: LD_INT 0
60115: PUSH
60116: EMPTY
60117: LIST
60118: LIST
60119: PUSH
60120: LD_INT 30
60122: PUSH
60123: LD_INT 1
60125: PUSH
60126: EMPTY
60127: LIST
60128: LIST
60129: PUSH
60130: EMPTY
60131: LIST
60132: LIST
60133: LIST
60134: PUSH
60135: EMPTY
60136: LIST
60137: LIST
60138: PPUSH
60139: CALL_OW 72
60143: ST_TO_ADDR
60144: GO 60298
60146: LD_INT 3
60148: DOUBLE
60149: EQUAL
60150: IFTRUE 60154
60152: GO 60216
60154: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60155: LD_ADDR_VAR 0 12
60159: PUSH
60160: LD_VAR 0 18
60164: PPUSH
60165: LD_INT 22
60167: PUSH
60168: LD_VAR 0 16
60172: PUSH
60173: EMPTY
60174: LIST
60175: LIST
60176: PUSH
60177: LD_INT 2
60179: PUSH
60180: LD_INT 30
60182: PUSH
60183: LD_INT 2
60185: PUSH
60186: EMPTY
60187: LIST
60188: LIST
60189: PUSH
60190: LD_INT 30
60192: PUSH
60193: LD_INT 3
60195: PUSH
60196: EMPTY
60197: LIST
60198: LIST
60199: PUSH
60200: EMPTY
60201: LIST
60202: LIST
60203: LIST
60204: PUSH
60205: EMPTY
60206: LIST
60207: LIST
60208: PPUSH
60209: CALL_OW 72
60213: ST_TO_ADDR
60214: GO 60298
60216: LD_INT 4
60218: DOUBLE
60219: EQUAL
60220: IFTRUE 60224
60222: GO 60297
60224: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60225: LD_ADDR_VAR 0 12
60229: PUSH
60230: LD_VAR 0 18
60234: PPUSH
60235: LD_INT 22
60237: PUSH
60238: LD_VAR 0 16
60242: PUSH
60243: EMPTY
60244: LIST
60245: LIST
60246: PUSH
60247: LD_INT 2
60249: PUSH
60250: LD_INT 30
60252: PUSH
60253: LD_INT 6
60255: PUSH
60256: EMPTY
60257: LIST
60258: LIST
60259: PUSH
60260: LD_INT 30
60262: PUSH
60263: LD_INT 7
60265: PUSH
60266: EMPTY
60267: LIST
60268: LIST
60269: PUSH
60270: LD_INT 30
60272: PUSH
60273: LD_INT 8
60275: PUSH
60276: EMPTY
60277: LIST
60278: LIST
60279: PUSH
60280: EMPTY
60281: LIST
60282: LIST
60283: LIST
60284: LIST
60285: PUSH
60286: EMPTY
60287: LIST
60288: LIST
60289: PPUSH
60290: CALL_OW 72
60294: ST_TO_ADDR
60295: GO 60298
60297: POP
// if i = 1 then
60298: LD_VAR 0 8
60302: PUSH
60303: LD_INT 1
60305: EQUAL
60306: IFFALSE 60417
// begin tmp := [ ] ;
60308: LD_ADDR_VAR 0 19
60312: PUSH
60313: EMPTY
60314: ST_TO_ADDR
// for j in f do
60315: LD_ADDR_VAR 0 9
60319: PUSH
60320: LD_VAR 0 12
60324: PUSH
60325: FOR_IN
60326: IFFALSE 60399
// if GetBType ( j ) = b_bunker then
60328: LD_VAR 0 9
60332: PPUSH
60333: CALL_OW 266
60337: PUSH
60338: LD_INT 32
60340: EQUAL
60341: IFFALSE 60368
// tmp := Insert ( tmp , 1 , j ) else
60343: LD_ADDR_VAR 0 19
60347: PUSH
60348: LD_VAR 0 19
60352: PPUSH
60353: LD_INT 1
60355: PPUSH
60356: LD_VAR 0 9
60360: PPUSH
60361: CALL_OW 2
60365: ST_TO_ADDR
60366: GO 60397
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60368: LD_ADDR_VAR 0 19
60372: PUSH
60373: LD_VAR 0 19
60377: PPUSH
60378: LD_VAR 0 19
60382: PUSH
60383: LD_INT 1
60385: PLUS
60386: PPUSH
60387: LD_VAR 0 9
60391: PPUSH
60392: CALL_OW 2
60396: ST_TO_ADDR
60397: GO 60325
60399: POP
60400: POP
// if tmp then
60401: LD_VAR 0 19
60405: IFFALSE 60417
// f := tmp ;
60407: LD_ADDR_VAR 0 12
60411: PUSH
60412: LD_VAR 0 19
60416: ST_TO_ADDR
// end ; x := personel [ i ] ;
60417: LD_ADDR_VAR 0 13
60421: PUSH
60422: LD_VAR 0 6
60426: PUSH
60427: LD_VAR 0 8
60431: ARRAY
60432: ST_TO_ADDR
// if x = - 1 then
60433: LD_VAR 0 13
60437: PUSH
60438: LD_INT 1
60440: NEG
60441: EQUAL
60442: IFFALSE 60651
// begin for j in f do
60444: LD_ADDR_VAR 0 9
60448: PUSH
60449: LD_VAR 0 12
60453: PUSH
60454: FOR_IN
60455: IFFALSE 60647
// repeat InitHc ;
60457: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60461: LD_VAR 0 9
60465: PPUSH
60466: CALL_OW 266
60470: PUSH
60471: LD_INT 5
60473: EQUAL
60474: IFFALSE 60544
// begin if UnitsInside ( j ) < 3 then
60476: LD_VAR 0 9
60480: PPUSH
60481: CALL_OW 313
60485: PUSH
60486: LD_INT 3
60488: LESS
60489: IFFALSE 60525
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60491: LD_INT 0
60493: PPUSH
60494: LD_INT 5
60496: PUSH
60497: LD_INT 8
60499: PUSH
60500: LD_INT 9
60502: PUSH
60503: EMPTY
60504: LIST
60505: LIST
60506: LIST
60507: PUSH
60508: LD_VAR 0 17
60512: ARRAY
60513: PPUSH
60514: LD_VAR 0 4
60518: PPUSH
60519: CALL_OW 380
60523: GO 60542
// PrepareHuman ( false , i , skill ) ;
60525: LD_INT 0
60527: PPUSH
60528: LD_VAR 0 8
60532: PPUSH
60533: LD_VAR 0 4
60537: PPUSH
60538: CALL_OW 380
// end else
60542: GO 60561
// PrepareHuman ( false , i , skill ) ;
60544: LD_INT 0
60546: PPUSH
60547: LD_VAR 0 8
60551: PPUSH
60552: LD_VAR 0 4
60556: PPUSH
60557: CALL_OW 380
// un := CreateHuman ;
60561: LD_ADDR_VAR 0 14
60565: PUSH
60566: CALL_OW 44
60570: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60571: LD_ADDR_VAR 0 7
60575: PUSH
60576: LD_VAR 0 7
60580: PPUSH
60581: LD_INT 1
60583: PPUSH
60584: LD_VAR 0 14
60588: PPUSH
60589: CALL_OW 2
60593: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60594: LD_VAR 0 14
60598: PPUSH
60599: LD_VAR 0 9
60603: PPUSH
60604: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60608: LD_VAR 0 9
60612: PPUSH
60613: CALL_OW 313
60617: PUSH
60618: LD_INT 6
60620: EQUAL
60621: PUSH
60622: LD_VAR 0 9
60626: PPUSH
60627: CALL_OW 266
60631: PUSH
60632: LD_INT 32
60634: PUSH
60635: LD_INT 31
60637: PUSH
60638: EMPTY
60639: LIST
60640: LIST
60641: IN
60642: OR
60643: IFFALSE 60457
60645: GO 60454
60647: POP
60648: POP
// end else
60649: GO 61031
// for j = 1 to x do
60651: LD_ADDR_VAR 0 9
60655: PUSH
60656: DOUBLE
60657: LD_INT 1
60659: DEC
60660: ST_TO_ADDR
60661: LD_VAR 0 13
60665: PUSH
60666: FOR_TO
60667: IFFALSE 61029
// begin InitHc ;
60669: CALL_OW 19
// if not f then
60673: LD_VAR 0 12
60677: NOT
60678: IFFALSE 60767
// begin PrepareHuman ( false , i , skill ) ;
60680: LD_INT 0
60682: PPUSH
60683: LD_VAR 0 8
60687: PPUSH
60688: LD_VAR 0 4
60692: PPUSH
60693: CALL_OW 380
// un := CreateHuman ;
60697: LD_ADDR_VAR 0 14
60701: PUSH
60702: CALL_OW 44
60706: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60707: LD_ADDR_VAR 0 7
60711: PUSH
60712: LD_VAR 0 7
60716: PPUSH
60717: LD_INT 1
60719: PPUSH
60720: LD_VAR 0 14
60724: PPUSH
60725: CALL_OW 2
60729: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60730: LD_VAR 0 14
60734: PPUSH
60735: LD_VAR 0 1
60739: PPUSH
60740: CALL_OW 250
60744: PPUSH
60745: LD_VAR 0 1
60749: PPUSH
60750: CALL_OW 251
60754: PPUSH
60755: LD_INT 10
60757: PPUSH
60758: LD_INT 0
60760: PPUSH
60761: CALL_OW 50
// continue ;
60765: GO 60666
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60767: LD_VAR 0 12
60771: PUSH
60772: LD_INT 1
60774: ARRAY
60775: PPUSH
60776: CALL_OW 313
60780: PUSH
60781: LD_VAR 0 12
60785: PUSH
60786: LD_INT 1
60788: ARRAY
60789: PPUSH
60790: CALL_OW 266
60794: PUSH
60795: LD_INT 32
60797: PUSH
60798: LD_INT 31
60800: PUSH
60801: EMPTY
60802: LIST
60803: LIST
60804: IN
60805: AND
60806: PUSH
60807: LD_VAR 0 12
60811: PUSH
60812: LD_INT 1
60814: ARRAY
60815: PPUSH
60816: CALL_OW 313
60820: PUSH
60821: LD_INT 6
60823: EQUAL
60824: OR
60825: IFFALSE 60845
// f := Delete ( f , 1 ) ;
60827: LD_ADDR_VAR 0 12
60831: PUSH
60832: LD_VAR 0 12
60836: PPUSH
60837: LD_INT 1
60839: PPUSH
60840: CALL_OW 3
60844: ST_TO_ADDR
// if not f then
60845: LD_VAR 0 12
60849: NOT
60850: IFFALSE 60868
// begin x := x + 2 ;
60852: LD_ADDR_VAR 0 13
60856: PUSH
60857: LD_VAR 0 13
60861: PUSH
60862: LD_INT 2
60864: PLUS
60865: ST_TO_ADDR
// continue ;
60866: GO 60666
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60868: LD_VAR 0 12
60872: PUSH
60873: LD_INT 1
60875: ARRAY
60876: PPUSH
60877: CALL_OW 266
60881: PUSH
60882: LD_INT 5
60884: EQUAL
60885: IFFALSE 60959
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60887: LD_VAR 0 12
60891: PUSH
60892: LD_INT 1
60894: ARRAY
60895: PPUSH
60896: CALL_OW 313
60900: PUSH
60901: LD_INT 3
60903: LESS
60904: IFFALSE 60940
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60906: LD_INT 0
60908: PPUSH
60909: LD_INT 5
60911: PUSH
60912: LD_INT 8
60914: PUSH
60915: LD_INT 9
60917: PUSH
60918: EMPTY
60919: LIST
60920: LIST
60921: LIST
60922: PUSH
60923: LD_VAR 0 17
60927: ARRAY
60928: PPUSH
60929: LD_VAR 0 4
60933: PPUSH
60934: CALL_OW 380
60938: GO 60957
// PrepareHuman ( false , i , skill ) ;
60940: LD_INT 0
60942: PPUSH
60943: LD_VAR 0 8
60947: PPUSH
60948: LD_VAR 0 4
60952: PPUSH
60953: CALL_OW 380
// end else
60957: GO 60976
// PrepareHuman ( false , i , skill ) ;
60959: LD_INT 0
60961: PPUSH
60962: LD_VAR 0 8
60966: PPUSH
60967: LD_VAR 0 4
60971: PPUSH
60972: CALL_OW 380
// un := CreateHuman ;
60976: LD_ADDR_VAR 0 14
60980: PUSH
60981: CALL_OW 44
60985: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60986: LD_ADDR_VAR 0 7
60990: PUSH
60991: LD_VAR 0 7
60995: PPUSH
60996: LD_INT 1
60998: PPUSH
60999: LD_VAR 0 14
61003: PPUSH
61004: CALL_OW 2
61008: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61009: LD_VAR 0 14
61013: PPUSH
61014: LD_VAR 0 12
61018: PUSH
61019: LD_INT 1
61021: ARRAY
61022: PPUSH
61023: CALL_OW 52
// end ;
61027: GO 60666
61029: POP
61030: POP
// end ;
61031: GO 59968
61033: POP
61034: POP
// result := result ^ buildings ;
61035: LD_ADDR_VAR 0 7
61039: PUSH
61040: LD_VAR 0 7
61044: PUSH
61045: LD_VAR 0 18
61049: ADD
61050: ST_TO_ADDR
// end else
61051: GO 61194
// begin for i = 1 to personel do
61053: LD_ADDR_VAR 0 8
61057: PUSH
61058: DOUBLE
61059: LD_INT 1
61061: DEC
61062: ST_TO_ADDR
61063: LD_VAR 0 6
61067: PUSH
61068: FOR_TO
61069: IFFALSE 61192
// begin if i > 4 then
61071: LD_VAR 0 8
61075: PUSH
61076: LD_INT 4
61078: GREATER
61079: IFFALSE 61083
// break ;
61081: GO 61192
// x := personel [ i ] ;
61083: LD_ADDR_VAR 0 13
61087: PUSH
61088: LD_VAR 0 6
61092: PUSH
61093: LD_VAR 0 8
61097: ARRAY
61098: ST_TO_ADDR
// if x = - 1 then
61099: LD_VAR 0 13
61103: PUSH
61104: LD_INT 1
61106: NEG
61107: EQUAL
61108: IFFALSE 61112
// continue ;
61110: GO 61068
// PrepareHuman ( false , i , skill ) ;
61112: LD_INT 0
61114: PPUSH
61115: LD_VAR 0 8
61119: PPUSH
61120: LD_VAR 0 4
61124: PPUSH
61125: CALL_OW 380
// un := CreateHuman ;
61129: LD_ADDR_VAR 0 14
61133: PUSH
61134: CALL_OW 44
61138: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61139: LD_VAR 0 14
61143: PPUSH
61144: LD_VAR 0 1
61148: PPUSH
61149: CALL_OW 250
61153: PPUSH
61154: LD_VAR 0 1
61158: PPUSH
61159: CALL_OW 251
61163: PPUSH
61164: LD_INT 10
61166: PPUSH
61167: LD_INT 0
61169: PPUSH
61170: CALL_OW 50
// result := result ^ un ;
61174: LD_ADDR_VAR 0 7
61178: PUSH
61179: LD_VAR 0 7
61183: PUSH
61184: LD_VAR 0 14
61188: ADD
61189: ST_TO_ADDR
// end ;
61190: GO 61068
61192: POP
61193: POP
// end ; end ;
61194: LD_VAR 0 7
61198: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61199: LD_INT 0
61201: PPUSH
61202: PPUSH
61203: PPUSH
61204: PPUSH
61205: PPUSH
61206: PPUSH
61207: PPUSH
61208: PPUSH
61209: PPUSH
61210: PPUSH
61211: PPUSH
61212: PPUSH
61213: PPUSH
61214: PPUSH
61215: PPUSH
61216: PPUSH
// result := false ;
61217: LD_ADDR_VAR 0 3
61221: PUSH
61222: LD_INT 0
61224: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61225: LD_VAR 0 1
61229: NOT
61230: PUSH
61231: LD_VAR 0 1
61235: PPUSH
61236: CALL_OW 266
61240: PUSH
61241: LD_INT 32
61243: PUSH
61244: LD_INT 33
61246: PUSH
61247: EMPTY
61248: LIST
61249: LIST
61250: IN
61251: NOT
61252: OR
61253: IFFALSE 61257
// exit ;
61255: GO 62393
// nat := GetNation ( tower ) ;
61257: LD_ADDR_VAR 0 12
61261: PUSH
61262: LD_VAR 0 1
61266: PPUSH
61267: CALL_OW 248
61271: ST_TO_ADDR
// side := GetSide ( tower ) ;
61272: LD_ADDR_VAR 0 16
61276: PUSH
61277: LD_VAR 0 1
61281: PPUSH
61282: CALL_OW 255
61286: ST_TO_ADDR
// x := GetX ( tower ) ;
61287: LD_ADDR_VAR 0 10
61291: PUSH
61292: LD_VAR 0 1
61296: PPUSH
61297: CALL_OW 250
61301: ST_TO_ADDR
// y := GetY ( tower ) ;
61302: LD_ADDR_VAR 0 11
61306: PUSH
61307: LD_VAR 0 1
61311: PPUSH
61312: CALL_OW 251
61316: ST_TO_ADDR
// if not x or not y then
61317: LD_VAR 0 10
61321: NOT
61322: PUSH
61323: LD_VAR 0 11
61327: NOT
61328: OR
61329: IFFALSE 61333
// exit ;
61331: GO 62393
// weapon := 0 ;
61333: LD_ADDR_VAR 0 18
61337: PUSH
61338: LD_INT 0
61340: ST_TO_ADDR
// fac_list := [ ] ;
61341: LD_ADDR_VAR 0 17
61345: PUSH
61346: EMPTY
61347: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
61348: LD_ADDR_VAR 0 6
61352: PUSH
61353: LD_VAR 0 1
61357: PPUSH
61358: CALL_OW 274
61362: PPUSH
61363: LD_VAR 0 2
61367: PPUSH
61368: CALL 58971 0 2
61372: PPUSH
61373: LD_INT 30
61375: PUSH
61376: LD_INT 3
61378: PUSH
61379: EMPTY
61380: LIST
61381: LIST
61382: PPUSH
61383: CALL_OW 72
61387: ST_TO_ADDR
// if not factories then
61388: LD_VAR 0 6
61392: NOT
61393: IFFALSE 61397
// exit ;
61395: GO 62393
// for i in factories do
61397: LD_ADDR_VAR 0 8
61401: PUSH
61402: LD_VAR 0 6
61406: PUSH
61407: FOR_IN
61408: IFFALSE 61433
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61410: LD_ADDR_VAR 0 17
61414: PUSH
61415: LD_VAR 0 17
61419: PUSH
61420: LD_VAR 0 8
61424: PPUSH
61425: CALL_OW 478
61429: UNION
61430: ST_TO_ADDR
61431: GO 61407
61433: POP
61434: POP
// if not fac_list then
61435: LD_VAR 0 17
61439: NOT
61440: IFFALSE 61444
// exit ;
61442: GO 62393
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61444: LD_ADDR_VAR 0 5
61448: PUSH
61449: LD_INT 4
61451: PUSH
61452: LD_INT 5
61454: PUSH
61455: LD_INT 9
61457: PUSH
61458: LD_INT 10
61460: PUSH
61461: LD_INT 6
61463: PUSH
61464: LD_INT 7
61466: PUSH
61467: LD_INT 11
61469: PUSH
61470: EMPTY
61471: LIST
61472: LIST
61473: LIST
61474: LIST
61475: LIST
61476: LIST
61477: LIST
61478: PUSH
61479: LD_INT 27
61481: PUSH
61482: LD_INT 28
61484: PUSH
61485: LD_INT 26
61487: PUSH
61488: LD_INT 30
61490: PUSH
61491: EMPTY
61492: LIST
61493: LIST
61494: LIST
61495: LIST
61496: PUSH
61497: LD_INT 43
61499: PUSH
61500: LD_INT 44
61502: PUSH
61503: LD_INT 46
61505: PUSH
61506: LD_INT 45
61508: PUSH
61509: LD_INT 47
61511: PUSH
61512: LD_INT 49
61514: PUSH
61515: EMPTY
61516: LIST
61517: LIST
61518: LIST
61519: LIST
61520: LIST
61521: LIST
61522: PUSH
61523: EMPTY
61524: LIST
61525: LIST
61526: LIST
61527: PUSH
61528: LD_VAR 0 12
61532: ARRAY
61533: ST_TO_ADDR
// for i in list do
61534: LD_ADDR_VAR 0 8
61538: PUSH
61539: LD_VAR 0 5
61543: PUSH
61544: FOR_IN
61545: IFFALSE 61578
// if not i in fac_list then
61547: LD_VAR 0 8
61551: PUSH
61552: LD_VAR 0 17
61556: IN
61557: NOT
61558: IFFALSE 61576
// list := list diff i ;
61560: LD_ADDR_VAR 0 5
61564: PUSH
61565: LD_VAR 0 5
61569: PUSH
61570: LD_VAR 0 8
61574: DIFF
61575: ST_TO_ADDR
61576: GO 61544
61578: POP
61579: POP
// if not list then
61580: LD_VAR 0 5
61584: NOT
61585: IFFALSE 61589
// exit ;
61587: GO 62393
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61589: LD_VAR 0 12
61593: PUSH
61594: LD_INT 3
61596: EQUAL
61597: PUSH
61598: LD_INT 49
61600: PUSH
61601: LD_VAR 0 5
61605: IN
61606: AND
61607: PUSH
61608: LD_INT 31
61610: PPUSH
61611: LD_VAR 0 16
61615: PPUSH
61616: CALL_OW 321
61620: PUSH
61621: LD_INT 2
61623: EQUAL
61624: AND
61625: IFFALSE 61685
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61627: LD_INT 22
61629: PUSH
61630: LD_VAR 0 16
61634: PUSH
61635: EMPTY
61636: LIST
61637: LIST
61638: PUSH
61639: LD_INT 35
61641: PUSH
61642: LD_INT 49
61644: PUSH
61645: EMPTY
61646: LIST
61647: LIST
61648: PUSH
61649: LD_INT 91
61651: PUSH
61652: LD_VAR 0 1
61656: PUSH
61657: LD_INT 10
61659: PUSH
61660: EMPTY
61661: LIST
61662: LIST
61663: LIST
61664: PUSH
61665: EMPTY
61666: LIST
61667: LIST
61668: LIST
61669: PPUSH
61670: CALL_OW 69
61674: NOT
61675: IFFALSE 61685
// weapon := ru_time_lapser ;
61677: LD_ADDR_VAR 0 18
61681: PUSH
61682: LD_INT 49
61684: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61685: LD_VAR 0 12
61689: PUSH
61690: LD_INT 1
61692: PUSH
61693: LD_INT 2
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: IN
61700: PUSH
61701: LD_INT 11
61703: PUSH
61704: LD_VAR 0 5
61708: IN
61709: PUSH
61710: LD_INT 30
61712: PUSH
61713: LD_VAR 0 5
61717: IN
61718: OR
61719: AND
61720: PUSH
61721: LD_INT 6
61723: PPUSH
61724: LD_VAR 0 16
61728: PPUSH
61729: CALL_OW 321
61733: PUSH
61734: LD_INT 2
61736: EQUAL
61737: AND
61738: IFFALSE 61903
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61740: LD_INT 22
61742: PUSH
61743: LD_VAR 0 16
61747: PUSH
61748: EMPTY
61749: LIST
61750: LIST
61751: PUSH
61752: LD_INT 2
61754: PUSH
61755: LD_INT 35
61757: PUSH
61758: LD_INT 11
61760: PUSH
61761: EMPTY
61762: LIST
61763: LIST
61764: PUSH
61765: LD_INT 35
61767: PUSH
61768: LD_INT 30
61770: PUSH
61771: EMPTY
61772: LIST
61773: LIST
61774: PUSH
61775: EMPTY
61776: LIST
61777: LIST
61778: LIST
61779: PUSH
61780: LD_INT 91
61782: PUSH
61783: LD_VAR 0 1
61787: PUSH
61788: LD_INT 18
61790: PUSH
61791: EMPTY
61792: LIST
61793: LIST
61794: LIST
61795: PUSH
61796: EMPTY
61797: LIST
61798: LIST
61799: LIST
61800: PPUSH
61801: CALL_OW 69
61805: NOT
61806: PUSH
61807: LD_INT 22
61809: PUSH
61810: LD_VAR 0 16
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: PUSH
61819: LD_INT 2
61821: PUSH
61822: LD_INT 30
61824: PUSH
61825: LD_INT 32
61827: PUSH
61828: EMPTY
61829: LIST
61830: LIST
61831: PUSH
61832: LD_INT 30
61834: PUSH
61835: LD_INT 33
61837: PUSH
61838: EMPTY
61839: LIST
61840: LIST
61841: PUSH
61842: EMPTY
61843: LIST
61844: LIST
61845: LIST
61846: PUSH
61847: LD_INT 91
61849: PUSH
61850: LD_VAR 0 1
61854: PUSH
61855: LD_INT 12
61857: PUSH
61858: EMPTY
61859: LIST
61860: LIST
61861: LIST
61862: PUSH
61863: EMPTY
61864: LIST
61865: LIST
61866: LIST
61867: PUSH
61868: EMPTY
61869: LIST
61870: PPUSH
61871: CALL_OW 69
61875: PUSH
61876: LD_INT 2
61878: GREATER
61879: AND
61880: IFFALSE 61903
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61882: LD_ADDR_VAR 0 18
61886: PUSH
61887: LD_INT 11
61889: PUSH
61890: LD_INT 30
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: PUSH
61897: LD_VAR 0 12
61901: ARRAY
61902: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61903: LD_VAR 0 18
61907: NOT
61908: PUSH
61909: LD_INT 40
61911: PPUSH
61912: LD_VAR 0 16
61916: PPUSH
61917: CALL_OW 321
61921: PUSH
61922: LD_INT 2
61924: EQUAL
61925: AND
61926: PUSH
61927: LD_INT 7
61929: PUSH
61930: LD_VAR 0 5
61934: IN
61935: PUSH
61936: LD_INT 28
61938: PUSH
61939: LD_VAR 0 5
61943: IN
61944: OR
61945: PUSH
61946: LD_INT 45
61948: PUSH
61949: LD_VAR 0 5
61953: IN
61954: OR
61955: AND
61956: IFFALSE 62210
// begin hex := GetHexInfo ( x , y ) ;
61958: LD_ADDR_VAR 0 4
61962: PUSH
61963: LD_VAR 0 10
61967: PPUSH
61968: LD_VAR 0 11
61972: PPUSH
61973: CALL_OW 546
61977: ST_TO_ADDR
// if hex [ 1 ] then
61978: LD_VAR 0 4
61982: PUSH
61983: LD_INT 1
61985: ARRAY
61986: IFFALSE 61990
// exit ;
61988: GO 62393
// height := hex [ 2 ] ;
61990: LD_ADDR_VAR 0 15
61994: PUSH
61995: LD_VAR 0 4
61999: PUSH
62000: LD_INT 2
62002: ARRAY
62003: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62004: LD_ADDR_VAR 0 14
62008: PUSH
62009: LD_INT 0
62011: PUSH
62012: LD_INT 2
62014: PUSH
62015: LD_INT 3
62017: PUSH
62018: LD_INT 5
62020: PUSH
62021: EMPTY
62022: LIST
62023: LIST
62024: LIST
62025: LIST
62026: ST_TO_ADDR
// for i in tmp do
62027: LD_ADDR_VAR 0 8
62031: PUSH
62032: LD_VAR 0 14
62036: PUSH
62037: FOR_IN
62038: IFFALSE 62208
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62040: LD_ADDR_VAR 0 9
62044: PUSH
62045: LD_VAR 0 10
62049: PPUSH
62050: LD_VAR 0 8
62054: PPUSH
62055: LD_INT 5
62057: PPUSH
62058: CALL_OW 272
62062: PUSH
62063: LD_VAR 0 11
62067: PPUSH
62068: LD_VAR 0 8
62072: PPUSH
62073: LD_INT 5
62075: PPUSH
62076: CALL_OW 273
62080: PUSH
62081: EMPTY
62082: LIST
62083: LIST
62084: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62085: LD_VAR 0 9
62089: PUSH
62090: LD_INT 1
62092: ARRAY
62093: PPUSH
62094: LD_VAR 0 9
62098: PUSH
62099: LD_INT 2
62101: ARRAY
62102: PPUSH
62103: CALL_OW 488
62107: IFFALSE 62206
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62109: LD_ADDR_VAR 0 4
62113: PUSH
62114: LD_VAR 0 9
62118: PUSH
62119: LD_INT 1
62121: ARRAY
62122: PPUSH
62123: LD_VAR 0 9
62127: PUSH
62128: LD_INT 2
62130: ARRAY
62131: PPUSH
62132: CALL_OW 546
62136: ST_TO_ADDR
// if hex [ 1 ] then
62137: LD_VAR 0 4
62141: PUSH
62142: LD_INT 1
62144: ARRAY
62145: IFFALSE 62149
// continue ;
62147: GO 62037
// h := hex [ 2 ] ;
62149: LD_ADDR_VAR 0 13
62153: PUSH
62154: LD_VAR 0 4
62158: PUSH
62159: LD_INT 2
62161: ARRAY
62162: ST_TO_ADDR
// if h + 7 < height then
62163: LD_VAR 0 13
62167: PUSH
62168: LD_INT 7
62170: PLUS
62171: PUSH
62172: LD_VAR 0 15
62176: LESS
62177: IFFALSE 62206
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62179: LD_ADDR_VAR 0 18
62183: PUSH
62184: LD_INT 7
62186: PUSH
62187: LD_INT 28
62189: PUSH
62190: LD_INT 45
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: LIST
62197: PUSH
62198: LD_VAR 0 12
62202: ARRAY
62203: ST_TO_ADDR
// break ;
62204: GO 62208
// end ; end ; end ;
62206: GO 62037
62208: POP
62209: POP
// end ; if not weapon then
62210: LD_VAR 0 18
62214: NOT
62215: IFFALSE 62275
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62217: LD_ADDR_VAR 0 5
62221: PUSH
62222: LD_VAR 0 5
62226: PUSH
62227: LD_INT 11
62229: PUSH
62230: LD_INT 30
62232: PUSH
62233: LD_INT 49
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: LIST
62240: DIFF
62241: ST_TO_ADDR
// if not list then
62242: LD_VAR 0 5
62246: NOT
62247: IFFALSE 62251
// exit ;
62249: GO 62393
// weapon := list [ rand ( 1 , list ) ] ;
62251: LD_ADDR_VAR 0 18
62255: PUSH
62256: LD_VAR 0 5
62260: PUSH
62261: LD_INT 1
62263: PPUSH
62264: LD_VAR 0 5
62268: PPUSH
62269: CALL_OW 12
62273: ARRAY
62274: ST_TO_ADDR
// end ; if weapon then
62275: LD_VAR 0 18
62279: IFFALSE 62393
// begin tmp := CostOfWeapon ( weapon ) ;
62281: LD_ADDR_VAR 0 14
62285: PUSH
62286: LD_VAR 0 18
62290: PPUSH
62291: CALL_OW 451
62295: ST_TO_ADDR
// j := GetBase ( tower ) ;
62296: LD_ADDR_VAR 0 9
62300: PUSH
62301: LD_VAR 0 1
62305: PPUSH
62306: CALL_OW 274
62310: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
62311: LD_VAR 0 9
62315: PPUSH
62316: LD_INT 1
62318: PPUSH
62319: CALL_OW 275
62323: PUSH
62324: LD_VAR 0 14
62328: PUSH
62329: LD_INT 1
62331: ARRAY
62332: GREATEREQUAL
62333: PUSH
62334: LD_VAR 0 9
62338: PPUSH
62339: LD_INT 2
62341: PPUSH
62342: CALL_OW 275
62346: PUSH
62347: LD_VAR 0 14
62351: PUSH
62352: LD_INT 2
62354: ARRAY
62355: GREATEREQUAL
62356: AND
62357: PUSH
62358: LD_VAR 0 9
62362: PPUSH
62363: LD_INT 3
62365: PPUSH
62366: CALL_OW 275
62370: PUSH
62371: LD_VAR 0 14
62375: PUSH
62376: LD_INT 3
62378: ARRAY
62379: GREATEREQUAL
62380: AND
62381: IFFALSE 62393
// result := weapon ;
62383: LD_ADDR_VAR 0 3
62387: PUSH
62388: LD_VAR 0 18
62392: ST_TO_ADDR
// end ; end ;
62393: LD_VAR 0 3
62397: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62398: LD_INT 0
62400: PPUSH
62401: PPUSH
// result := true ;
62402: LD_ADDR_VAR 0 3
62406: PUSH
62407: LD_INT 1
62409: ST_TO_ADDR
// if array1 = array2 then
62410: LD_VAR 0 1
62414: PUSH
62415: LD_VAR 0 2
62419: EQUAL
62420: IFFALSE 62480
// begin for i = 1 to array1 do
62422: LD_ADDR_VAR 0 4
62426: PUSH
62427: DOUBLE
62428: LD_INT 1
62430: DEC
62431: ST_TO_ADDR
62432: LD_VAR 0 1
62436: PUSH
62437: FOR_TO
62438: IFFALSE 62476
// if array1 [ i ] <> array2 [ i ] then
62440: LD_VAR 0 1
62444: PUSH
62445: LD_VAR 0 4
62449: ARRAY
62450: PUSH
62451: LD_VAR 0 2
62455: PUSH
62456: LD_VAR 0 4
62460: ARRAY
62461: NONEQUAL
62462: IFFALSE 62474
// begin result := false ;
62464: LD_ADDR_VAR 0 3
62468: PUSH
62469: LD_INT 0
62471: ST_TO_ADDR
// break ;
62472: GO 62476
// end ;
62474: GO 62437
62476: POP
62477: POP
// end else
62478: GO 62488
// result := false ;
62480: LD_ADDR_VAR 0 3
62484: PUSH
62485: LD_INT 0
62487: ST_TO_ADDR
// end ;
62488: LD_VAR 0 3
62492: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62493: LD_INT 0
62495: PPUSH
62496: PPUSH
62497: PPUSH
// pom := GetBase ( fac ) ;
62498: LD_ADDR_VAR 0 5
62502: PUSH
62503: LD_VAR 0 1
62507: PPUSH
62508: CALL_OW 274
62512: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62513: LD_ADDR_VAR 0 4
62517: PUSH
62518: LD_VAR 0 2
62522: PUSH
62523: LD_INT 1
62525: ARRAY
62526: PPUSH
62527: LD_VAR 0 2
62531: PUSH
62532: LD_INT 2
62534: ARRAY
62535: PPUSH
62536: LD_VAR 0 2
62540: PUSH
62541: LD_INT 3
62543: ARRAY
62544: PPUSH
62545: LD_VAR 0 2
62549: PUSH
62550: LD_INT 4
62552: ARRAY
62553: PPUSH
62554: CALL_OW 449
62558: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62559: LD_ADDR_VAR 0 3
62563: PUSH
62564: LD_VAR 0 5
62568: PPUSH
62569: LD_INT 1
62571: PPUSH
62572: CALL_OW 275
62576: PUSH
62577: LD_VAR 0 4
62581: PUSH
62582: LD_INT 1
62584: ARRAY
62585: GREATEREQUAL
62586: PUSH
62587: LD_VAR 0 5
62591: PPUSH
62592: LD_INT 2
62594: PPUSH
62595: CALL_OW 275
62599: PUSH
62600: LD_VAR 0 4
62604: PUSH
62605: LD_INT 2
62607: ARRAY
62608: GREATEREQUAL
62609: AND
62610: PUSH
62611: LD_VAR 0 5
62615: PPUSH
62616: LD_INT 3
62618: PPUSH
62619: CALL_OW 275
62623: PUSH
62624: LD_VAR 0 4
62628: PUSH
62629: LD_INT 3
62631: ARRAY
62632: GREATEREQUAL
62633: AND
62634: ST_TO_ADDR
// end ;
62635: LD_VAR 0 3
62639: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62640: LD_INT 0
62642: PPUSH
62643: PPUSH
62644: PPUSH
62645: PPUSH
// pom := GetBase ( building ) ;
62646: LD_ADDR_VAR 0 3
62650: PUSH
62651: LD_VAR 0 1
62655: PPUSH
62656: CALL_OW 274
62660: ST_TO_ADDR
// if not pom then
62661: LD_VAR 0 3
62665: NOT
62666: IFFALSE 62670
// exit ;
62668: GO 62840
// btype := GetBType ( building ) ;
62670: LD_ADDR_VAR 0 5
62674: PUSH
62675: LD_VAR 0 1
62679: PPUSH
62680: CALL_OW 266
62684: ST_TO_ADDR
// if btype = b_armoury then
62685: LD_VAR 0 5
62689: PUSH
62690: LD_INT 4
62692: EQUAL
62693: IFFALSE 62703
// btype := b_barracks ;
62695: LD_ADDR_VAR 0 5
62699: PUSH
62700: LD_INT 5
62702: ST_TO_ADDR
// if btype = b_depot then
62703: LD_VAR 0 5
62707: PUSH
62708: LD_INT 0
62710: EQUAL
62711: IFFALSE 62721
// btype := b_warehouse ;
62713: LD_ADDR_VAR 0 5
62717: PUSH
62718: LD_INT 1
62720: ST_TO_ADDR
// if btype = b_workshop then
62721: LD_VAR 0 5
62725: PUSH
62726: LD_INT 2
62728: EQUAL
62729: IFFALSE 62739
// btype := b_factory ;
62731: LD_ADDR_VAR 0 5
62735: PUSH
62736: LD_INT 3
62738: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62739: LD_ADDR_VAR 0 4
62743: PUSH
62744: LD_VAR 0 5
62748: PPUSH
62749: LD_VAR 0 1
62753: PPUSH
62754: CALL_OW 248
62758: PPUSH
62759: CALL_OW 450
62763: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62764: LD_ADDR_VAR 0 2
62768: PUSH
62769: LD_VAR 0 3
62773: PPUSH
62774: LD_INT 1
62776: PPUSH
62777: CALL_OW 275
62781: PUSH
62782: LD_VAR 0 4
62786: PUSH
62787: LD_INT 1
62789: ARRAY
62790: GREATEREQUAL
62791: PUSH
62792: LD_VAR 0 3
62796: PPUSH
62797: LD_INT 2
62799: PPUSH
62800: CALL_OW 275
62804: PUSH
62805: LD_VAR 0 4
62809: PUSH
62810: LD_INT 2
62812: ARRAY
62813: GREATEREQUAL
62814: AND
62815: PUSH
62816: LD_VAR 0 3
62820: PPUSH
62821: LD_INT 3
62823: PPUSH
62824: CALL_OW 275
62828: PUSH
62829: LD_VAR 0 4
62833: PUSH
62834: LD_INT 3
62836: ARRAY
62837: GREATEREQUAL
62838: AND
62839: ST_TO_ADDR
// end ;
62840: LD_VAR 0 2
62844: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62845: LD_INT 0
62847: PPUSH
62848: PPUSH
62849: PPUSH
// pom := GetBase ( building ) ;
62850: LD_ADDR_VAR 0 4
62854: PUSH
62855: LD_VAR 0 1
62859: PPUSH
62860: CALL_OW 274
62864: ST_TO_ADDR
// if not pom then
62865: LD_VAR 0 4
62869: NOT
62870: IFFALSE 62874
// exit ;
62872: GO 62975
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62874: LD_ADDR_VAR 0 5
62878: PUSH
62879: LD_VAR 0 2
62883: PPUSH
62884: LD_VAR 0 1
62888: PPUSH
62889: CALL_OW 248
62893: PPUSH
62894: CALL_OW 450
62898: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62899: LD_ADDR_VAR 0 3
62903: PUSH
62904: LD_VAR 0 4
62908: PPUSH
62909: LD_INT 1
62911: PPUSH
62912: CALL_OW 275
62916: PUSH
62917: LD_VAR 0 5
62921: PUSH
62922: LD_INT 1
62924: ARRAY
62925: GREATEREQUAL
62926: PUSH
62927: LD_VAR 0 4
62931: PPUSH
62932: LD_INT 2
62934: PPUSH
62935: CALL_OW 275
62939: PUSH
62940: LD_VAR 0 5
62944: PUSH
62945: LD_INT 2
62947: ARRAY
62948: GREATEREQUAL
62949: AND
62950: PUSH
62951: LD_VAR 0 4
62955: PPUSH
62956: LD_INT 3
62958: PPUSH
62959: CALL_OW 275
62963: PUSH
62964: LD_VAR 0 5
62968: PUSH
62969: LD_INT 3
62971: ARRAY
62972: GREATEREQUAL
62973: AND
62974: ST_TO_ADDR
// end ;
62975: LD_VAR 0 3
62979: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
62980: LD_INT 0
62982: PPUSH
62983: PPUSH
62984: PPUSH
62985: PPUSH
62986: PPUSH
62987: PPUSH
62988: PPUSH
62989: PPUSH
62990: PPUSH
62991: PPUSH
// result := false ;
62992: LD_ADDR_VAR 0 6
62996: PUSH
62997: LD_INT 0
62999: ST_TO_ADDR
// if not base or not btype or not x or not y then
63000: LD_VAR 0 1
63004: NOT
63005: PUSH
63006: LD_VAR 0 2
63010: NOT
63011: OR
63012: PUSH
63013: LD_VAR 0 3
63017: NOT
63018: OR
63019: PUSH
63020: LD_VAR 0 4
63024: NOT
63025: OR
63026: IFFALSE 63030
// exit ;
63028: GO 63639
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
63030: LD_ADDR_VAR 0 12
63034: PUSH
63035: LD_VAR 0 2
63039: PPUSH
63040: LD_VAR 0 3
63044: PPUSH
63045: LD_VAR 0 4
63049: PPUSH
63050: LD_VAR 0 5
63054: PPUSH
63055: LD_VAR 0 1
63059: PUSH
63060: LD_INT 1
63062: ARRAY
63063: PPUSH
63064: CALL_OW 248
63068: PPUSH
63069: LD_INT 0
63071: PPUSH
63072: CALL 64476 0 6
63076: ST_TO_ADDR
// if not hexes then
63077: LD_VAR 0 12
63081: NOT
63082: IFFALSE 63086
// exit ;
63084: GO 63639
// for i = 1 to hexes do
63086: LD_ADDR_VAR 0 7
63090: PUSH
63091: DOUBLE
63092: LD_INT 1
63094: DEC
63095: ST_TO_ADDR
63096: LD_VAR 0 12
63100: PUSH
63101: FOR_TO
63102: IFFALSE 63637
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63104: LD_ADDR_VAR 0 11
63108: PUSH
63109: LD_VAR 0 12
63113: PUSH
63114: LD_VAR 0 7
63118: ARRAY
63119: PUSH
63120: LD_INT 1
63122: ARRAY
63123: PPUSH
63124: LD_VAR 0 12
63128: PUSH
63129: LD_VAR 0 7
63133: ARRAY
63134: PUSH
63135: LD_INT 2
63137: ARRAY
63138: PPUSH
63139: CALL_OW 428
63143: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63144: LD_VAR 0 12
63148: PUSH
63149: LD_VAR 0 7
63153: ARRAY
63154: PUSH
63155: LD_INT 1
63157: ARRAY
63158: PPUSH
63159: LD_VAR 0 12
63163: PUSH
63164: LD_VAR 0 7
63168: ARRAY
63169: PUSH
63170: LD_INT 2
63172: ARRAY
63173: PPUSH
63174: CALL_OW 351
63178: PUSH
63179: LD_VAR 0 12
63183: PUSH
63184: LD_VAR 0 7
63188: ARRAY
63189: PUSH
63190: LD_INT 1
63192: ARRAY
63193: PPUSH
63194: LD_VAR 0 12
63198: PUSH
63199: LD_VAR 0 7
63203: ARRAY
63204: PUSH
63205: LD_INT 2
63207: ARRAY
63208: PPUSH
63209: CALL_OW 488
63213: NOT
63214: OR
63215: PUSH
63216: LD_VAR 0 11
63220: PPUSH
63221: CALL_OW 247
63225: PUSH
63226: LD_INT 3
63228: EQUAL
63229: OR
63230: IFFALSE 63236
// exit ;
63232: POP
63233: POP
63234: GO 63639
// if not tmp or not tmp in base then
63236: LD_VAR 0 11
63240: NOT
63241: PUSH
63242: LD_VAR 0 11
63246: PUSH
63247: LD_VAR 0 1
63251: IN
63252: NOT
63253: OR
63254: IFFALSE 63258
// continue ;
63256: GO 63101
// result := true ;
63258: LD_ADDR_VAR 0 6
63262: PUSH
63263: LD_INT 1
63265: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63266: LD_ADDR_VAR 0 15
63270: PUSH
63271: LD_VAR 0 1
63275: PPUSH
63276: LD_INT 22
63278: PUSH
63279: LD_VAR 0 11
63283: PPUSH
63284: CALL_OW 255
63288: PUSH
63289: EMPTY
63290: LIST
63291: LIST
63292: PUSH
63293: LD_INT 2
63295: PUSH
63296: LD_INT 30
63298: PUSH
63299: LD_INT 0
63301: PUSH
63302: EMPTY
63303: LIST
63304: LIST
63305: PUSH
63306: LD_INT 30
63308: PUSH
63309: LD_INT 1
63311: PUSH
63312: EMPTY
63313: LIST
63314: LIST
63315: PUSH
63316: EMPTY
63317: LIST
63318: LIST
63319: LIST
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: PPUSH
63325: CALL_OW 72
63329: ST_TO_ADDR
// if dep then
63330: LD_VAR 0 15
63334: IFFALSE 63470
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63336: LD_ADDR_VAR 0 14
63340: PUSH
63341: LD_VAR 0 15
63345: PUSH
63346: LD_INT 1
63348: ARRAY
63349: PPUSH
63350: CALL_OW 250
63354: PPUSH
63355: LD_VAR 0 15
63359: PUSH
63360: LD_INT 1
63362: ARRAY
63363: PPUSH
63364: CALL_OW 254
63368: PPUSH
63369: LD_INT 5
63371: PPUSH
63372: CALL_OW 272
63376: PUSH
63377: LD_VAR 0 15
63381: PUSH
63382: LD_INT 1
63384: ARRAY
63385: PPUSH
63386: CALL_OW 251
63390: PPUSH
63391: LD_VAR 0 15
63395: PUSH
63396: LD_INT 1
63398: ARRAY
63399: PPUSH
63400: CALL_OW 254
63404: PPUSH
63405: LD_INT 5
63407: PPUSH
63408: CALL_OW 273
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63417: LD_VAR 0 14
63421: PUSH
63422: LD_INT 1
63424: ARRAY
63425: PPUSH
63426: LD_VAR 0 14
63430: PUSH
63431: LD_INT 2
63433: ARRAY
63434: PPUSH
63435: CALL_OW 488
63439: IFFALSE 63470
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63441: LD_VAR 0 11
63445: PPUSH
63446: LD_VAR 0 14
63450: PUSH
63451: LD_INT 1
63453: ARRAY
63454: PPUSH
63455: LD_VAR 0 14
63459: PUSH
63460: LD_INT 2
63462: ARRAY
63463: PPUSH
63464: CALL_OW 111
// continue ;
63468: GO 63101
// end ; end ; r := GetDir ( tmp ) ;
63470: LD_ADDR_VAR 0 13
63474: PUSH
63475: LD_VAR 0 11
63479: PPUSH
63480: CALL_OW 254
63484: ST_TO_ADDR
// if r = 5 then
63485: LD_VAR 0 13
63489: PUSH
63490: LD_INT 5
63492: EQUAL
63493: IFFALSE 63503
// r := 0 ;
63495: LD_ADDR_VAR 0 13
63499: PUSH
63500: LD_INT 0
63502: ST_TO_ADDR
// for j = r to 5 do
63503: LD_ADDR_VAR 0 8
63507: PUSH
63508: DOUBLE
63509: LD_VAR 0 13
63513: DEC
63514: ST_TO_ADDR
63515: LD_INT 5
63517: PUSH
63518: FOR_TO
63519: IFFALSE 63633
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63521: LD_ADDR_VAR 0 9
63525: PUSH
63526: LD_VAR 0 11
63530: PPUSH
63531: CALL_OW 250
63535: PPUSH
63536: LD_VAR 0 8
63540: PPUSH
63541: LD_INT 2
63543: PPUSH
63544: CALL_OW 272
63548: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63549: LD_ADDR_VAR 0 10
63553: PUSH
63554: LD_VAR 0 11
63558: PPUSH
63559: CALL_OW 251
63563: PPUSH
63564: LD_VAR 0 8
63568: PPUSH
63569: LD_INT 2
63571: PPUSH
63572: CALL_OW 273
63576: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63577: LD_VAR 0 9
63581: PPUSH
63582: LD_VAR 0 10
63586: PPUSH
63587: CALL_OW 488
63591: PUSH
63592: LD_VAR 0 9
63596: PPUSH
63597: LD_VAR 0 10
63601: PPUSH
63602: CALL_OW 428
63606: NOT
63607: AND
63608: IFFALSE 63631
// begin ComMoveXY ( tmp , _x , _y ) ;
63610: LD_VAR 0 11
63614: PPUSH
63615: LD_VAR 0 9
63619: PPUSH
63620: LD_VAR 0 10
63624: PPUSH
63625: CALL_OW 111
// break ;
63629: GO 63633
// end ; end ;
63631: GO 63518
63633: POP
63634: POP
// end ;
63635: GO 63101
63637: POP
63638: POP
// end ;
63639: LD_VAR 0 6
63643: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
63644: LD_INT 0
63646: PPUSH
63647: PPUSH
63648: PPUSH
63649: PPUSH
63650: PPUSH
63651: PPUSH
63652: PPUSH
63653: PPUSH
63654: PPUSH
63655: PPUSH
// result := false ;
63656: LD_ADDR_VAR 0 6
63660: PUSH
63661: LD_INT 0
63663: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63664: LD_VAR 0 1
63668: NOT
63669: PUSH
63670: LD_VAR 0 1
63674: PPUSH
63675: CALL_OW 266
63679: PUSH
63680: LD_INT 0
63682: PUSH
63683: LD_INT 1
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: IN
63690: NOT
63691: OR
63692: PUSH
63693: LD_VAR 0 2
63697: NOT
63698: OR
63699: PUSH
63700: LD_VAR 0 5
63704: PUSH
63705: LD_INT 0
63707: PUSH
63708: LD_INT 1
63710: PUSH
63711: LD_INT 2
63713: PUSH
63714: LD_INT 3
63716: PUSH
63717: LD_INT 4
63719: PUSH
63720: LD_INT 5
63722: PUSH
63723: EMPTY
63724: LIST
63725: LIST
63726: LIST
63727: LIST
63728: LIST
63729: LIST
63730: IN
63731: NOT
63732: OR
63733: PUSH
63734: LD_VAR 0 3
63738: PPUSH
63739: LD_VAR 0 4
63743: PPUSH
63744: CALL_OW 488
63748: NOT
63749: OR
63750: IFFALSE 63754
// exit ;
63752: GO 64471
// pom := GetBase ( depot ) ;
63754: LD_ADDR_VAR 0 10
63758: PUSH
63759: LD_VAR 0 1
63763: PPUSH
63764: CALL_OW 274
63768: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63769: LD_ADDR_VAR 0 11
63773: PUSH
63774: LD_VAR 0 2
63778: PPUSH
63779: LD_VAR 0 1
63783: PPUSH
63784: CALL_OW 248
63788: PPUSH
63789: CALL_OW 450
63793: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63794: LD_VAR 0 10
63798: PPUSH
63799: LD_INT 1
63801: PPUSH
63802: CALL_OW 275
63806: PUSH
63807: LD_VAR 0 11
63811: PUSH
63812: LD_INT 1
63814: ARRAY
63815: GREATEREQUAL
63816: PUSH
63817: LD_VAR 0 10
63821: PPUSH
63822: LD_INT 2
63824: PPUSH
63825: CALL_OW 275
63829: PUSH
63830: LD_VAR 0 11
63834: PUSH
63835: LD_INT 2
63837: ARRAY
63838: GREATEREQUAL
63839: AND
63840: PUSH
63841: LD_VAR 0 10
63845: PPUSH
63846: LD_INT 3
63848: PPUSH
63849: CALL_OW 275
63853: PUSH
63854: LD_VAR 0 11
63858: PUSH
63859: LD_INT 3
63861: ARRAY
63862: GREATEREQUAL
63863: AND
63864: NOT
63865: IFFALSE 63869
// exit ;
63867: GO 64471
// if GetBType ( depot ) = b_depot then
63869: LD_VAR 0 1
63873: PPUSH
63874: CALL_OW 266
63878: PUSH
63879: LD_INT 0
63881: EQUAL
63882: IFFALSE 63894
// dist := 28 else
63884: LD_ADDR_VAR 0 14
63888: PUSH
63889: LD_INT 28
63891: ST_TO_ADDR
63892: GO 63902
// dist := 36 ;
63894: LD_ADDR_VAR 0 14
63898: PUSH
63899: LD_INT 36
63901: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63902: LD_VAR 0 1
63906: PPUSH
63907: LD_VAR 0 3
63911: PPUSH
63912: LD_VAR 0 4
63916: PPUSH
63917: CALL_OW 297
63921: PUSH
63922: LD_VAR 0 14
63926: GREATER
63927: IFFALSE 63931
// exit ;
63929: GO 64471
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63931: LD_ADDR_VAR 0 12
63935: PUSH
63936: LD_VAR 0 2
63940: PPUSH
63941: LD_VAR 0 3
63945: PPUSH
63946: LD_VAR 0 4
63950: PPUSH
63951: LD_VAR 0 5
63955: PPUSH
63956: LD_VAR 0 1
63960: PPUSH
63961: CALL_OW 248
63965: PPUSH
63966: LD_INT 0
63968: PPUSH
63969: CALL 64476 0 6
63973: ST_TO_ADDR
// if not hexes then
63974: LD_VAR 0 12
63978: NOT
63979: IFFALSE 63983
// exit ;
63981: GO 64471
// hex := GetHexInfo ( x , y ) ;
63983: LD_ADDR_VAR 0 15
63987: PUSH
63988: LD_VAR 0 3
63992: PPUSH
63993: LD_VAR 0 4
63997: PPUSH
63998: CALL_OW 546
64002: ST_TO_ADDR
// if hex [ 1 ] then
64003: LD_VAR 0 15
64007: PUSH
64008: LD_INT 1
64010: ARRAY
64011: IFFALSE 64015
// exit ;
64013: GO 64471
// height := hex [ 2 ] ;
64015: LD_ADDR_VAR 0 13
64019: PUSH
64020: LD_VAR 0 15
64024: PUSH
64025: LD_INT 2
64027: ARRAY
64028: ST_TO_ADDR
// for i = 1 to hexes do
64029: LD_ADDR_VAR 0 7
64033: PUSH
64034: DOUBLE
64035: LD_INT 1
64037: DEC
64038: ST_TO_ADDR
64039: LD_VAR 0 12
64043: PUSH
64044: FOR_TO
64045: IFFALSE 64375
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
64047: LD_VAR 0 12
64051: PUSH
64052: LD_VAR 0 7
64056: ARRAY
64057: PUSH
64058: LD_INT 1
64060: ARRAY
64061: PPUSH
64062: LD_VAR 0 12
64066: PUSH
64067: LD_VAR 0 7
64071: ARRAY
64072: PUSH
64073: LD_INT 2
64075: ARRAY
64076: PPUSH
64077: CALL_OW 488
64081: NOT
64082: PUSH
64083: LD_VAR 0 12
64087: PUSH
64088: LD_VAR 0 7
64092: ARRAY
64093: PUSH
64094: LD_INT 1
64096: ARRAY
64097: PPUSH
64098: LD_VAR 0 12
64102: PUSH
64103: LD_VAR 0 7
64107: ARRAY
64108: PUSH
64109: LD_INT 2
64111: ARRAY
64112: PPUSH
64113: CALL_OW 428
64117: PUSH
64118: LD_INT 0
64120: GREATER
64121: OR
64122: PUSH
64123: LD_VAR 0 12
64127: PUSH
64128: LD_VAR 0 7
64132: ARRAY
64133: PUSH
64134: LD_INT 1
64136: ARRAY
64137: PPUSH
64138: LD_VAR 0 12
64142: PUSH
64143: LD_VAR 0 7
64147: ARRAY
64148: PUSH
64149: LD_INT 2
64151: ARRAY
64152: PPUSH
64153: CALL_OW 351
64157: OR
64158: IFFALSE 64164
// exit ;
64160: POP
64161: POP
64162: GO 64471
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64164: LD_ADDR_VAR 0 8
64168: PUSH
64169: LD_VAR 0 12
64173: PUSH
64174: LD_VAR 0 7
64178: ARRAY
64179: PUSH
64180: LD_INT 1
64182: ARRAY
64183: PPUSH
64184: LD_VAR 0 12
64188: PUSH
64189: LD_VAR 0 7
64193: ARRAY
64194: PUSH
64195: LD_INT 2
64197: ARRAY
64198: PPUSH
64199: CALL_OW 546
64203: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64204: LD_VAR 0 8
64208: PUSH
64209: LD_INT 1
64211: ARRAY
64212: PUSH
64213: LD_VAR 0 8
64217: PUSH
64218: LD_INT 2
64220: ARRAY
64221: PUSH
64222: LD_VAR 0 13
64226: PUSH
64227: LD_INT 2
64229: PLUS
64230: GREATER
64231: OR
64232: PUSH
64233: LD_VAR 0 8
64237: PUSH
64238: LD_INT 2
64240: ARRAY
64241: PUSH
64242: LD_VAR 0 13
64246: PUSH
64247: LD_INT 2
64249: MINUS
64250: LESS
64251: OR
64252: PUSH
64253: LD_VAR 0 8
64257: PUSH
64258: LD_INT 3
64260: ARRAY
64261: PUSH
64262: LD_INT 0
64264: PUSH
64265: LD_INT 8
64267: PUSH
64268: LD_INT 9
64270: PUSH
64271: LD_INT 10
64273: PUSH
64274: LD_INT 11
64276: PUSH
64277: LD_INT 12
64279: PUSH
64280: LD_INT 13
64282: PUSH
64283: LD_INT 16
64285: PUSH
64286: LD_INT 17
64288: PUSH
64289: LD_INT 18
64291: PUSH
64292: LD_INT 19
64294: PUSH
64295: LD_INT 20
64297: PUSH
64298: LD_INT 21
64300: PUSH
64301: EMPTY
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: IN
64316: NOT
64317: OR
64318: PUSH
64319: LD_VAR 0 8
64323: PUSH
64324: LD_INT 5
64326: ARRAY
64327: NOT
64328: OR
64329: PUSH
64330: LD_VAR 0 8
64334: PUSH
64335: LD_INT 6
64337: ARRAY
64338: PUSH
64339: LD_INT 1
64341: PUSH
64342: LD_INT 2
64344: PUSH
64345: LD_INT 7
64347: PUSH
64348: LD_INT 9
64350: PUSH
64351: LD_INT 10
64353: PUSH
64354: LD_INT 11
64356: PUSH
64357: EMPTY
64358: LIST
64359: LIST
64360: LIST
64361: LIST
64362: LIST
64363: LIST
64364: IN
64365: NOT
64366: OR
64367: IFFALSE 64373
// exit ;
64369: POP
64370: POP
64371: GO 64471
// end ;
64373: GO 64044
64375: POP
64376: POP
// side := GetSide ( depot ) ;
64377: LD_ADDR_VAR 0 9
64381: PUSH
64382: LD_VAR 0 1
64386: PPUSH
64387: CALL_OW 255
64391: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
64392: LD_VAR 0 9
64396: PPUSH
64397: LD_VAR 0 3
64401: PPUSH
64402: LD_VAR 0 4
64406: PPUSH
64407: LD_INT 20
64409: PPUSH
64410: CALL 57125 0 4
64414: PUSH
64415: LD_INT 4
64417: ARRAY
64418: IFFALSE 64422
// exit ;
64420: GO 64471
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
64422: LD_VAR 0 2
64426: PUSH
64427: LD_INT 29
64429: PUSH
64430: LD_INT 30
64432: PUSH
64433: EMPTY
64434: LIST
64435: LIST
64436: IN
64437: PUSH
64438: LD_VAR 0 3
64442: PPUSH
64443: LD_VAR 0 4
64447: PPUSH
64448: LD_VAR 0 9
64452: PPUSH
64453: CALL_OW 440
64457: NOT
64458: AND
64459: IFFALSE 64463
// exit ;
64461: GO 64471
// result := true ;
64463: LD_ADDR_VAR 0 6
64467: PUSH
64468: LD_INT 1
64470: ST_TO_ADDR
// end ;
64471: LD_VAR 0 6
64475: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
64476: LD_INT 0
64478: PPUSH
64479: PPUSH
64480: PPUSH
64481: PPUSH
64482: PPUSH
64483: PPUSH
64484: PPUSH
64485: PPUSH
64486: PPUSH
64487: PPUSH
64488: PPUSH
64489: PPUSH
64490: PPUSH
64491: PPUSH
64492: PPUSH
64493: PPUSH
64494: PPUSH
64495: PPUSH
64496: PPUSH
64497: PPUSH
64498: PPUSH
64499: PPUSH
64500: PPUSH
64501: PPUSH
64502: PPUSH
64503: PPUSH
64504: PPUSH
64505: PPUSH
64506: PPUSH
64507: PPUSH
64508: PPUSH
64509: PPUSH
64510: PPUSH
64511: PPUSH
64512: PPUSH
64513: PPUSH
64514: PPUSH
64515: PPUSH
64516: PPUSH
64517: PPUSH
64518: PPUSH
64519: PPUSH
64520: PPUSH
64521: PPUSH
64522: PPUSH
64523: PPUSH
64524: PPUSH
64525: PPUSH
64526: PPUSH
64527: PPUSH
64528: PPUSH
64529: PPUSH
64530: PPUSH
64531: PPUSH
64532: PPUSH
64533: PPUSH
64534: PPUSH
64535: PPUSH
// result = [ ] ;
64536: LD_ADDR_VAR 0 7
64540: PUSH
64541: EMPTY
64542: ST_TO_ADDR
// temp_list = [ ] ;
64543: LD_ADDR_VAR 0 9
64547: PUSH
64548: EMPTY
64549: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
64550: LD_VAR 0 4
64554: PUSH
64555: LD_INT 0
64557: PUSH
64558: LD_INT 1
64560: PUSH
64561: LD_INT 2
64563: PUSH
64564: LD_INT 3
64566: PUSH
64567: LD_INT 4
64569: PUSH
64570: LD_INT 5
64572: PUSH
64573: EMPTY
64574: LIST
64575: LIST
64576: LIST
64577: LIST
64578: LIST
64579: LIST
64580: IN
64581: NOT
64582: PUSH
64583: LD_VAR 0 1
64587: PUSH
64588: LD_INT 0
64590: PUSH
64591: LD_INT 1
64593: PUSH
64594: EMPTY
64595: LIST
64596: LIST
64597: IN
64598: PUSH
64599: LD_VAR 0 5
64603: PUSH
64604: LD_INT 1
64606: PUSH
64607: LD_INT 2
64609: PUSH
64610: LD_INT 3
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: LIST
64617: IN
64618: NOT
64619: AND
64620: OR
64621: IFFALSE 64625
// exit ;
64623: GO 83016
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64625: LD_VAR 0 1
64629: PUSH
64630: LD_INT 6
64632: PUSH
64633: LD_INT 7
64635: PUSH
64636: LD_INT 8
64638: PUSH
64639: LD_INT 13
64641: PUSH
64642: LD_INT 12
64644: PUSH
64645: LD_INT 15
64647: PUSH
64648: LD_INT 11
64650: PUSH
64651: LD_INT 14
64653: PUSH
64654: LD_INT 10
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: LIST
64661: LIST
64662: LIST
64663: LIST
64664: LIST
64665: LIST
64666: LIST
64667: IN
64668: IFFALSE 64678
// btype = b_lab ;
64670: LD_ADDR_VAR 0 1
64674: PUSH
64675: LD_INT 6
64677: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64678: LD_VAR 0 6
64682: PUSH
64683: LD_INT 0
64685: PUSH
64686: LD_INT 1
64688: PUSH
64689: LD_INT 2
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: LIST
64696: IN
64697: NOT
64698: PUSH
64699: LD_VAR 0 1
64703: PUSH
64704: LD_INT 0
64706: PUSH
64707: LD_INT 1
64709: PUSH
64710: LD_INT 2
64712: PUSH
64713: LD_INT 3
64715: PUSH
64716: LD_INT 6
64718: PUSH
64719: LD_INT 36
64721: PUSH
64722: LD_INT 4
64724: PUSH
64725: LD_INT 5
64727: PUSH
64728: LD_INT 31
64730: PUSH
64731: LD_INT 32
64733: PUSH
64734: LD_INT 33
64736: PUSH
64737: EMPTY
64738: LIST
64739: LIST
64740: LIST
64741: LIST
64742: LIST
64743: LIST
64744: LIST
64745: LIST
64746: LIST
64747: LIST
64748: LIST
64749: IN
64750: NOT
64751: PUSH
64752: LD_VAR 0 6
64756: PUSH
64757: LD_INT 1
64759: EQUAL
64760: AND
64761: OR
64762: PUSH
64763: LD_VAR 0 1
64767: PUSH
64768: LD_INT 2
64770: PUSH
64771: LD_INT 3
64773: PUSH
64774: EMPTY
64775: LIST
64776: LIST
64777: IN
64778: NOT
64779: PUSH
64780: LD_VAR 0 6
64784: PUSH
64785: LD_INT 2
64787: EQUAL
64788: AND
64789: OR
64790: IFFALSE 64800
// mode = 0 ;
64792: LD_ADDR_VAR 0 6
64796: PUSH
64797: LD_INT 0
64799: ST_TO_ADDR
// case mode of 0 :
64800: LD_VAR 0 6
64804: PUSH
64805: LD_INT 0
64807: DOUBLE
64808: EQUAL
64809: IFTRUE 64813
64811: GO 76266
64813: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64814: LD_ADDR_VAR 0 11
64818: PUSH
64819: LD_INT 0
64821: PUSH
64822: LD_INT 0
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PUSH
64829: LD_INT 0
64831: PUSH
64832: LD_INT 1
64834: NEG
64835: PUSH
64836: EMPTY
64837: LIST
64838: LIST
64839: PUSH
64840: LD_INT 1
64842: PUSH
64843: LD_INT 0
64845: PUSH
64846: EMPTY
64847: LIST
64848: LIST
64849: PUSH
64850: LD_INT 1
64852: PUSH
64853: LD_INT 1
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: PUSH
64860: LD_INT 0
64862: PUSH
64863: LD_INT 1
64865: PUSH
64866: EMPTY
64867: LIST
64868: LIST
64869: PUSH
64870: LD_INT 1
64872: NEG
64873: PUSH
64874: LD_INT 0
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PUSH
64881: LD_INT 1
64883: NEG
64884: PUSH
64885: LD_INT 1
64887: NEG
64888: PUSH
64889: EMPTY
64890: LIST
64891: LIST
64892: PUSH
64893: LD_INT 1
64895: NEG
64896: PUSH
64897: LD_INT 2
64899: NEG
64900: PUSH
64901: EMPTY
64902: LIST
64903: LIST
64904: PUSH
64905: LD_INT 0
64907: PUSH
64908: LD_INT 2
64910: NEG
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: PUSH
64916: LD_INT 1
64918: PUSH
64919: LD_INT 1
64921: NEG
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PUSH
64927: LD_INT 1
64929: PUSH
64930: LD_INT 2
64932: PUSH
64933: EMPTY
64934: LIST
64935: LIST
64936: PUSH
64937: LD_INT 0
64939: PUSH
64940: LD_INT 2
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: PUSH
64947: LD_INT 1
64949: NEG
64950: PUSH
64951: LD_INT 1
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: PUSH
64958: LD_INT 1
64960: PUSH
64961: LD_INT 3
64963: PUSH
64964: EMPTY
64965: LIST
64966: LIST
64967: PUSH
64968: LD_INT 0
64970: PUSH
64971: LD_INT 3
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: PUSH
64978: LD_INT 1
64980: NEG
64981: PUSH
64982: LD_INT 2
64984: PUSH
64985: EMPTY
64986: LIST
64987: LIST
64988: PUSH
64989: EMPTY
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65007: LD_ADDR_VAR 0 12
65011: PUSH
65012: LD_INT 0
65014: PUSH
65015: LD_INT 0
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: PUSH
65022: LD_INT 0
65024: PUSH
65025: LD_INT 1
65027: NEG
65028: PUSH
65029: EMPTY
65030: LIST
65031: LIST
65032: PUSH
65033: LD_INT 1
65035: PUSH
65036: LD_INT 0
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: PUSH
65043: LD_INT 1
65045: PUSH
65046: LD_INT 1
65048: PUSH
65049: EMPTY
65050: LIST
65051: LIST
65052: PUSH
65053: LD_INT 0
65055: PUSH
65056: LD_INT 1
65058: PUSH
65059: EMPTY
65060: LIST
65061: LIST
65062: PUSH
65063: LD_INT 1
65065: NEG
65066: PUSH
65067: LD_INT 0
65069: PUSH
65070: EMPTY
65071: LIST
65072: LIST
65073: PUSH
65074: LD_INT 1
65076: NEG
65077: PUSH
65078: LD_INT 1
65080: NEG
65081: PUSH
65082: EMPTY
65083: LIST
65084: LIST
65085: PUSH
65086: LD_INT 1
65088: PUSH
65089: LD_INT 1
65091: NEG
65092: PUSH
65093: EMPTY
65094: LIST
65095: LIST
65096: PUSH
65097: LD_INT 2
65099: PUSH
65100: LD_INT 0
65102: PUSH
65103: EMPTY
65104: LIST
65105: LIST
65106: PUSH
65107: LD_INT 2
65109: PUSH
65110: LD_INT 1
65112: PUSH
65113: EMPTY
65114: LIST
65115: LIST
65116: PUSH
65117: LD_INT 1
65119: NEG
65120: PUSH
65121: LD_INT 1
65123: PUSH
65124: EMPTY
65125: LIST
65126: LIST
65127: PUSH
65128: LD_INT 2
65130: NEG
65131: PUSH
65132: LD_INT 0
65134: PUSH
65135: EMPTY
65136: LIST
65137: LIST
65138: PUSH
65139: LD_INT 2
65141: NEG
65142: PUSH
65143: LD_INT 1
65145: NEG
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: PUSH
65151: LD_INT 2
65153: NEG
65154: PUSH
65155: LD_INT 1
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: PUSH
65162: LD_INT 3
65164: NEG
65165: PUSH
65166: LD_INT 0
65168: PUSH
65169: EMPTY
65170: LIST
65171: LIST
65172: PUSH
65173: LD_INT 3
65175: NEG
65176: PUSH
65177: LD_INT 1
65179: NEG
65180: PUSH
65181: EMPTY
65182: LIST
65183: LIST
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: LIST
65189: LIST
65190: LIST
65191: LIST
65192: LIST
65193: LIST
65194: LIST
65195: LIST
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65203: LD_ADDR_VAR 0 13
65207: PUSH
65208: LD_INT 0
65210: PUSH
65211: LD_INT 0
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PUSH
65218: LD_INT 0
65220: PUSH
65221: LD_INT 1
65223: NEG
65224: PUSH
65225: EMPTY
65226: LIST
65227: LIST
65228: PUSH
65229: LD_INT 1
65231: PUSH
65232: LD_INT 0
65234: PUSH
65235: EMPTY
65236: LIST
65237: LIST
65238: PUSH
65239: LD_INT 1
65241: PUSH
65242: LD_INT 1
65244: PUSH
65245: EMPTY
65246: LIST
65247: LIST
65248: PUSH
65249: LD_INT 0
65251: PUSH
65252: LD_INT 1
65254: PUSH
65255: EMPTY
65256: LIST
65257: LIST
65258: PUSH
65259: LD_INT 1
65261: NEG
65262: PUSH
65263: LD_INT 0
65265: PUSH
65266: EMPTY
65267: LIST
65268: LIST
65269: PUSH
65270: LD_INT 1
65272: NEG
65273: PUSH
65274: LD_INT 1
65276: NEG
65277: PUSH
65278: EMPTY
65279: LIST
65280: LIST
65281: PUSH
65282: LD_INT 1
65284: NEG
65285: PUSH
65286: LD_INT 2
65288: NEG
65289: PUSH
65290: EMPTY
65291: LIST
65292: LIST
65293: PUSH
65294: LD_INT 2
65296: PUSH
65297: LD_INT 1
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: PUSH
65304: LD_INT 2
65306: PUSH
65307: LD_INT 2
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PUSH
65314: LD_INT 1
65316: PUSH
65317: LD_INT 2
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: LD_INT 2
65326: NEG
65327: PUSH
65328: LD_INT 1
65330: NEG
65331: PUSH
65332: EMPTY
65333: LIST
65334: LIST
65335: PUSH
65336: LD_INT 2
65338: NEG
65339: PUSH
65340: LD_INT 2
65342: NEG
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: PUSH
65348: LD_INT 2
65350: NEG
65351: PUSH
65352: LD_INT 3
65354: NEG
65355: PUSH
65356: EMPTY
65357: LIST
65358: LIST
65359: PUSH
65360: LD_INT 3
65362: NEG
65363: PUSH
65364: LD_INT 2
65366: NEG
65367: PUSH
65368: EMPTY
65369: LIST
65370: LIST
65371: PUSH
65372: LD_INT 3
65374: NEG
65375: PUSH
65376: LD_INT 3
65378: NEG
65379: PUSH
65380: EMPTY
65381: LIST
65382: LIST
65383: PUSH
65384: EMPTY
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
65402: LD_ADDR_VAR 0 14
65406: PUSH
65407: LD_INT 0
65409: PUSH
65410: LD_INT 0
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 0
65419: PUSH
65420: LD_INT 1
65422: NEG
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 1
65430: PUSH
65431: LD_INT 0
65433: PUSH
65434: EMPTY
65435: LIST
65436: LIST
65437: PUSH
65438: LD_INT 1
65440: PUSH
65441: LD_INT 1
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 0
65450: PUSH
65451: LD_INT 1
65453: PUSH
65454: EMPTY
65455: LIST
65456: LIST
65457: PUSH
65458: LD_INT 1
65460: NEG
65461: PUSH
65462: LD_INT 0
65464: PUSH
65465: EMPTY
65466: LIST
65467: LIST
65468: PUSH
65469: LD_INT 1
65471: NEG
65472: PUSH
65473: LD_INT 1
65475: NEG
65476: PUSH
65477: EMPTY
65478: LIST
65479: LIST
65480: PUSH
65481: LD_INT 1
65483: NEG
65484: PUSH
65485: LD_INT 2
65487: NEG
65488: PUSH
65489: EMPTY
65490: LIST
65491: LIST
65492: PUSH
65493: LD_INT 0
65495: PUSH
65496: LD_INT 2
65498: NEG
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: PUSH
65504: LD_INT 1
65506: PUSH
65507: LD_INT 1
65509: NEG
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PUSH
65515: LD_INT 1
65517: PUSH
65518: LD_INT 2
65520: PUSH
65521: EMPTY
65522: LIST
65523: LIST
65524: PUSH
65525: LD_INT 0
65527: PUSH
65528: LD_INT 2
65530: PUSH
65531: EMPTY
65532: LIST
65533: LIST
65534: PUSH
65535: LD_INT 1
65537: NEG
65538: PUSH
65539: LD_INT 1
65541: PUSH
65542: EMPTY
65543: LIST
65544: LIST
65545: PUSH
65546: LD_INT 1
65548: NEG
65549: PUSH
65550: LD_INT 3
65552: NEG
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: PUSH
65558: LD_INT 0
65560: PUSH
65561: LD_INT 3
65563: NEG
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 1
65571: PUSH
65572: LD_INT 2
65574: NEG
65575: PUSH
65576: EMPTY
65577: LIST
65578: LIST
65579: PUSH
65580: EMPTY
65581: LIST
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
65598: LD_ADDR_VAR 0 15
65602: PUSH
65603: LD_INT 0
65605: PUSH
65606: LD_INT 0
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PUSH
65613: LD_INT 0
65615: PUSH
65616: LD_INT 1
65618: NEG
65619: PUSH
65620: EMPTY
65621: LIST
65622: LIST
65623: PUSH
65624: LD_INT 1
65626: PUSH
65627: LD_INT 0
65629: PUSH
65630: EMPTY
65631: LIST
65632: LIST
65633: PUSH
65634: LD_INT 1
65636: PUSH
65637: LD_INT 1
65639: PUSH
65640: EMPTY
65641: LIST
65642: LIST
65643: PUSH
65644: LD_INT 0
65646: PUSH
65647: LD_INT 1
65649: PUSH
65650: EMPTY
65651: LIST
65652: LIST
65653: PUSH
65654: LD_INT 1
65656: NEG
65657: PUSH
65658: LD_INT 0
65660: PUSH
65661: EMPTY
65662: LIST
65663: LIST
65664: PUSH
65665: LD_INT 1
65667: NEG
65668: PUSH
65669: LD_INT 1
65671: NEG
65672: PUSH
65673: EMPTY
65674: LIST
65675: LIST
65676: PUSH
65677: LD_INT 1
65679: PUSH
65680: LD_INT 1
65682: NEG
65683: PUSH
65684: EMPTY
65685: LIST
65686: LIST
65687: PUSH
65688: LD_INT 2
65690: PUSH
65691: LD_INT 0
65693: PUSH
65694: EMPTY
65695: LIST
65696: LIST
65697: PUSH
65698: LD_INT 2
65700: PUSH
65701: LD_INT 1
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PUSH
65708: LD_INT 1
65710: NEG
65711: PUSH
65712: LD_INT 1
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: LD_INT 2
65721: NEG
65722: PUSH
65723: LD_INT 0
65725: PUSH
65726: EMPTY
65727: LIST
65728: LIST
65729: PUSH
65730: LD_INT 2
65732: NEG
65733: PUSH
65734: LD_INT 1
65736: NEG
65737: PUSH
65738: EMPTY
65739: LIST
65740: LIST
65741: PUSH
65742: LD_INT 2
65744: PUSH
65745: LD_INT 1
65747: NEG
65748: PUSH
65749: EMPTY
65750: LIST
65751: LIST
65752: PUSH
65753: LD_INT 3
65755: PUSH
65756: LD_INT 0
65758: PUSH
65759: EMPTY
65760: LIST
65761: LIST
65762: PUSH
65763: LD_INT 3
65765: PUSH
65766: LD_INT 1
65768: PUSH
65769: EMPTY
65770: LIST
65771: LIST
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: LIST
65785: LIST
65786: LIST
65787: LIST
65788: LIST
65789: LIST
65790: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65791: LD_ADDR_VAR 0 16
65795: PUSH
65796: LD_INT 0
65798: PUSH
65799: LD_INT 0
65801: PUSH
65802: EMPTY
65803: LIST
65804: LIST
65805: PUSH
65806: LD_INT 0
65808: PUSH
65809: LD_INT 1
65811: NEG
65812: PUSH
65813: EMPTY
65814: LIST
65815: LIST
65816: PUSH
65817: LD_INT 1
65819: PUSH
65820: LD_INT 0
65822: PUSH
65823: EMPTY
65824: LIST
65825: LIST
65826: PUSH
65827: LD_INT 1
65829: PUSH
65830: LD_INT 1
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: PUSH
65837: LD_INT 0
65839: PUSH
65840: LD_INT 1
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: PUSH
65847: LD_INT 1
65849: NEG
65850: PUSH
65851: LD_INT 0
65853: PUSH
65854: EMPTY
65855: LIST
65856: LIST
65857: PUSH
65858: LD_INT 1
65860: NEG
65861: PUSH
65862: LD_INT 1
65864: NEG
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: PUSH
65870: LD_INT 1
65872: NEG
65873: PUSH
65874: LD_INT 2
65876: NEG
65877: PUSH
65878: EMPTY
65879: LIST
65880: LIST
65881: PUSH
65882: LD_INT 2
65884: PUSH
65885: LD_INT 1
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PUSH
65892: LD_INT 2
65894: PUSH
65895: LD_INT 2
65897: PUSH
65898: EMPTY
65899: LIST
65900: LIST
65901: PUSH
65902: LD_INT 1
65904: PUSH
65905: LD_INT 2
65907: PUSH
65908: EMPTY
65909: LIST
65910: LIST
65911: PUSH
65912: LD_INT 2
65914: NEG
65915: PUSH
65916: LD_INT 1
65918: NEG
65919: PUSH
65920: EMPTY
65921: LIST
65922: LIST
65923: PUSH
65924: LD_INT 2
65926: NEG
65927: PUSH
65928: LD_INT 2
65930: NEG
65931: PUSH
65932: EMPTY
65933: LIST
65934: LIST
65935: PUSH
65936: LD_INT 3
65938: PUSH
65939: LD_INT 2
65941: PUSH
65942: EMPTY
65943: LIST
65944: LIST
65945: PUSH
65946: LD_INT 3
65948: PUSH
65949: LD_INT 3
65951: PUSH
65952: EMPTY
65953: LIST
65954: LIST
65955: PUSH
65956: LD_INT 2
65958: PUSH
65959: LD_INT 3
65961: PUSH
65962: EMPTY
65963: LIST
65964: LIST
65965: PUSH
65966: EMPTY
65967: LIST
65968: LIST
65969: LIST
65970: LIST
65971: LIST
65972: LIST
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: LIST
65981: LIST
65982: LIST
65983: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65984: LD_ADDR_VAR 0 17
65988: PUSH
65989: LD_INT 0
65991: PUSH
65992: LD_INT 0
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: PUSH
65999: LD_INT 0
66001: PUSH
66002: LD_INT 1
66004: NEG
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PUSH
66010: LD_INT 1
66012: PUSH
66013: LD_INT 0
66015: PUSH
66016: EMPTY
66017: LIST
66018: LIST
66019: PUSH
66020: LD_INT 1
66022: PUSH
66023: LD_INT 1
66025: PUSH
66026: EMPTY
66027: LIST
66028: LIST
66029: PUSH
66030: LD_INT 0
66032: PUSH
66033: LD_INT 1
66035: PUSH
66036: EMPTY
66037: LIST
66038: LIST
66039: PUSH
66040: LD_INT 1
66042: NEG
66043: PUSH
66044: LD_INT 0
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: PUSH
66051: LD_INT 1
66053: NEG
66054: PUSH
66055: LD_INT 1
66057: NEG
66058: PUSH
66059: EMPTY
66060: LIST
66061: LIST
66062: PUSH
66063: LD_INT 1
66065: NEG
66066: PUSH
66067: LD_INT 2
66069: NEG
66070: PUSH
66071: EMPTY
66072: LIST
66073: LIST
66074: PUSH
66075: LD_INT 0
66077: PUSH
66078: LD_INT 2
66080: NEG
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: LD_INT 1
66088: PUSH
66089: LD_INT 1
66091: NEG
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PUSH
66097: LD_INT 2
66099: PUSH
66100: LD_INT 0
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: LD_INT 2
66109: PUSH
66110: LD_INT 1
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 2
66119: PUSH
66120: LD_INT 2
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 1
66129: PUSH
66130: LD_INT 2
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 0
66139: PUSH
66140: LD_INT 2
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PUSH
66147: LD_INT 1
66149: NEG
66150: PUSH
66151: LD_INT 1
66153: PUSH
66154: EMPTY
66155: LIST
66156: LIST
66157: PUSH
66158: LD_INT 2
66160: NEG
66161: PUSH
66162: LD_INT 0
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: PUSH
66169: LD_INT 2
66171: NEG
66172: PUSH
66173: LD_INT 1
66175: NEG
66176: PUSH
66177: EMPTY
66178: LIST
66179: LIST
66180: PUSH
66181: LD_INT 2
66183: NEG
66184: PUSH
66185: LD_INT 2
66187: NEG
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: PUSH
66193: EMPTY
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66214: LD_ADDR_VAR 0 18
66218: PUSH
66219: LD_INT 0
66221: PUSH
66222: LD_INT 0
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: PUSH
66229: LD_INT 0
66231: PUSH
66232: LD_INT 1
66234: NEG
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 1
66242: PUSH
66243: LD_INT 0
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 1
66252: PUSH
66253: LD_INT 1
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: PUSH
66260: LD_INT 0
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 1
66272: NEG
66273: PUSH
66274: LD_INT 0
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 1
66283: NEG
66284: PUSH
66285: LD_INT 1
66287: NEG
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PUSH
66293: LD_INT 1
66295: NEG
66296: PUSH
66297: LD_INT 2
66299: NEG
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: LD_INT 0
66307: PUSH
66308: LD_INT 2
66310: NEG
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: PUSH
66316: LD_INT 1
66318: PUSH
66319: LD_INT 1
66321: NEG
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: PUSH
66327: LD_INT 2
66329: PUSH
66330: LD_INT 0
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 2
66339: PUSH
66340: LD_INT 1
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 2
66349: PUSH
66350: LD_INT 2
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 1
66359: PUSH
66360: LD_INT 2
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: PUSH
66367: LD_INT 0
66369: PUSH
66370: LD_INT 2
66372: PUSH
66373: EMPTY
66374: LIST
66375: LIST
66376: PUSH
66377: LD_INT 1
66379: NEG
66380: PUSH
66381: LD_INT 1
66383: PUSH
66384: EMPTY
66385: LIST
66386: LIST
66387: PUSH
66388: LD_INT 2
66390: NEG
66391: PUSH
66392: LD_INT 0
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: PUSH
66399: LD_INT 2
66401: NEG
66402: PUSH
66403: LD_INT 1
66405: NEG
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 2
66413: NEG
66414: PUSH
66415: LD_INT 2
66417: NEG
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: EMPTY
66424: LIST
66425: LIST
66426: LIST
66427: LIST
66428: LIST
66429: LIST
66430: LIST
66431: LIST
66432: LIST
66433: LIST
66434: LIST
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66444: LD_ADDR_VAR 0 19
66448: PUSH
66449: LD_INT 0
66451: PUSH
66452: LD_INT 0
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PUSH
66459: LD_INT 0
66461: PUSH
66462: LD_INT 1
66464: NEG
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PUSH
66470: LD_INT 1
66472: PUSH
66473: LD_INT 0
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: PUSH
66480: LD_INT 1
66482: PUSH
66483: LD_INT 1
66485: PUSH
66486: EMPTY
66487: LIST
66488: LIST
66489: PUSH
66490: LD_INT 0
66492: PUSH
66493: LD_INT 1
66495: PUSH
66496: EMPTY
66497: LIST
66498: LIST
66499: PUSH
66500: LD_INT 1
66502: NEG
66503: PUSH
66504: LD_INT 0
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: PUSH
66511: LD_INT 1
66513: NEG
66514: PUSH
66515: LD_INT 1
66517: NEG
66518: PUSH
66519: EMPTY
66520: LIST
66521: LIST
66522: PUSH
66523: LD_INT 1
66525: NEG
66526: PUSH
66527: LD_INT 2
66529: NEG
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 0
66537: PUSH
66538: LD_INT 2
66540: NEG
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PUSH
66546: LD_INT 1
66548: PUSH
66549: LD_INT 1
66551: NEG
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PUSH
66557: LD_INT 2
66559: PUSH
66560: LD_INT 0
66562: PUSH
66563: EMPTY
66564: LIST
66565: LIST
66566: PUSH
66567: LD_INT 2
66569: PUSH
66570: LD_INT 1
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 2
66579: PUSH
66580: LD_INT 2
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 1
66589: PUSH
66590: LD_INT 2
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 0
66599: PUSH
66600: LD_INT 2
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 1
66609: NEG
66610: PUSH
66611: LD_INT 1
66613: PUSH
66614: EMPTY
66615: LIST
66616: LIST
66617: PUSH
66618: LD_INT 2
66620: NEG
66621: PUSH
66622: LD_INT 0
66624: PUSH
66625: EMPTY
66626: LIST
66627: LIST
66628: PUSH
66629: LD_INT 2
66631: NEG
66632: PUSH
66633: LD_INT 1
66635: NEG
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: PUSH
66641: LD_INT 2
66643: NEG
66644: PUSH
66645: LD_INT 2
66647: NEG
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: LIST
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: LIST
66671: LIST
66672: LIST
66673: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66674: LD_ADDR_VAR 0 20
66678: PUSH
66679: LD_INT 0
66681: PUSH
66682: LD_INT 0
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 0
66691: PUSH
66692: LD_INT 1
66694: NEG
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: LD_INT 1
66702: PUSH
66703: LD_INT 0
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: LD_INT 1
66712: PUSH
66713: LD_INT 1
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: LD_INT 0
66722: PUSH
66723: LD_INT 1
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: LD_INT 1
66732: NEG
66733: PUSH
66734: LD_INT 0
66736: PUSH
66737: EMPTY
66738: LIST
66739: LIST
66740: PUSH
66741: LD_INT 1
66743: NEG
66744: PUSH
66745: LD_INT 1
66747: NEG
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: PUSH
66753: LD_INT 1
66755: NEG
66756: PUSH
66757: LD_INT 2
66759: NEG
66760: PUSH
66761: EMPTY
66762: LIST
66763: LIST
66764: PUSH
66765: LD_INT 0
66767: PUSH
66768: LD_INT 2
66770: NEG
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PUSH
66776: LD_INT 1
66778: PUSH
66779: LD_INT 1
66781: NEG
66782: PUSH
66783: EMPTY
66784: LIST
66785: LIST
66786: PUSH
66787: LD_INT 2
66789: PUSH
66790: LD_INT 0
66792: PUSH
66793: EMPTY
66794: LIST
66795: LIST
66796: PUSH
66797: LD_INT 2
66799: PUSH
66800: LD_INT 1
66802: PUSH
66803: EMPTY
66804: LIST
66805: LIST
66806: PUSH
66807: LD_INT 2
66809: PUSH
66810: LD_INT 2
66812: PUSH
66813: EMPTY
66814: LIST
66815: LIST
66816: PUSH
66817: LD_INT 1
66819: PUSH
66820: LD_INT 2
66822: PUSH
66823: EMPTY
66824: LIST
66825: LIST
66826: PUSH
66827: LD_INT 0
66829: PUSH
66830: LD_INT 2
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PUSH
66837: LD_INT 1
66839: NEG
66840: PUSH
66841: LD_INT 1
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: PUSH
66848: LD_INT 2
66850: NEG
66851: PUSH
66852: LD_INT 0
66854: PUSH
66855: EMPTY
66856: LIST
66857: LIST
66858: PUSH
66859: LD_INT 2
66861: NEG
66862: PUSH
66863: LD_INT 1
66865: NEG
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: LD_INT 2
66873: NEG
66874: PUSH
66875: LD_INT 2
66877: NEG
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: LIST
66893: LIST
66894: LIST
66895: LIST
66896: LIST
66897: LIST
66898: LIST
66899: LIST
66900: LIST
66901: LIST
66902: LIST
66903: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66904: LD_ADDR_VAR 0 21
66908: PUSH
66909: LD_INT 0
66911: PUSH
66912: LD_INT 0
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: LD_INT 0
66921: PUSH
66922: LD_INT 1
66924: NEG
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: PUSH
66930: LD_INT 1
66932: PUSH
66933: LD_INT 0
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: PUSH
66940: LD_INT 1
66942: PUSH
66943: LD_INT 1
66945: PUSH
66946: EMPTY
66947: LIST
66948: LIST
66949: PUSH
66950: LD_INT 0
66952: PUSH
66953: LD_INT 1
66955: PUSH
66956: EMPTY
66957: LIST
66958: LIST
66959: PUSH
66960: LD_INT 1
66962: NEG
66963: PUSH
66964: LD_INT 0
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PUSH
66971: LD_INT 1
66973: NEG
66974: PUSH
66975: LD_INT 1
66977: NEG
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 1
66985: NEG
66986: PUSH
66987: LD_INT 2
66989: NEG
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: LD_INT 0
66997: PUSH
66998: LD_INT 2
67000: NEG
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: PUSH
67006: LD_INT 1
67008: PUSH
67009: LD_INT 1
67011: NEG
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PUSH
67017: LD_INT 2
67019: PUSH
67020: LD_INT 0
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: LD_INT 2
67029: PUSH
67030: LD_INT 1
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: PUSH
67037: LD_INT 2
67039: PUSH
67040: LD_INT 2
67042: PUSH
67043: EMPTY
67044: LIST
67045: LIST
67046: PUSH
67047: LD_INT 1
67049: PUSH
67050: LD_INT 2
67052: PUSH
67053: EMPTY
67054: LIST
67055: LIST
67056: PUSH
67057: LD_INT 0
67059: PUSH
67060: LD_INT 2
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: PUSH
67067: LD_INT 1
67069: NEG
67070: PUSH
67071: LD_INT 1
67073: PUSH
67074: EMPTY
67075: LIST
67076: LIST
67077: PUSH
67078: LD_INT 2
67080: NEG
67081: PUSH
67082: LD_INT 0
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PUSH
67089: LD_INT 2
67091: NEG
67092: PUSH
67093: LD_INT 1
67095: NEG
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: PUSH
67101: LD_INT 2
67103: NEG
67104: PUSH
67105: LD_INT 2
67107: NEG
67108: PUSH
67109: EMPTY
67110: LIST
67111: LIST
67112: PUSH
67113: EMPTY
67114: LIST
67115: LIST
67116: LIST
67117: LIST
67118: LIST
67119: LIST
67120: LIST
67121: LIST
67122: LIST
67123: LIST
67124: LIST
67125: LIST
67126: LIST
67127: LIST
67128: LIST
67129: LIST
67130: LIST
67131: LIST
67132: LIST
67133: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67134: LD_ADDR_VAR 0 22
67138: PUSH
67139: LD_INT 0
67141: PUSH
67142: LD_INT 0
67144: PUSH
67145: EMPTY
67146: LIST
67147: LIST
67148: PUSH
67149: LD_INT 0
67151: PUSH
67152: LD_INT 1
67154: NEG
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: LD_INT 1
67162: PUSH
67163: LD_INT 0
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: LD_INT 1
67172: PUSH
67173: LD_INT 1
67175: PUSH
67176: EMPTY
67177: LIST
67178: LIST
67179: PUSH
67180: LD_INT 0
67182: PUSH
67183: LD_INT 1
67185: PUSH
67186: EMPTY
67187: LIST
67188: LIST
67189: PUSH
67190: LD_INT 1
67192: NEG
67193: PUSH
67194: LD_INT 0
67196: PUSH
67197: EMPTY
67198: LIST
67199: LIST
67200: PUSH
67201: LD_INT 1
67203: NEG
67204: PUSH
67205: LD_INT 1
67207: NEG
67208: PUSH
67209: EMPTY
67210: LIST
67211: LIST
67212: PUSH
67213: LD_INT 1
67215: NEG
67216: PUSH
67217: LD_INT 2
67219: NEG
67220: PUSH
67221: EMPTY
67222: LIST
67223: LIST
67224: PUSH
67225: LD_INT 0
67227: PUSH
67228: LD_INT 2
67230: NEG
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: LD_INT 1
67238: PUSH
67239: LD_INT 1
67241: NEG
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: PUSH
67247: LD_INT 2
67249: PUSH
67250: LD_INT 0
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 2
67259: PUSH
67260: LD_INT 1
67262: PUSH
67263: EMPTY
67264: LIST
67265: LIST
67266: PUSH
67267: LD_INT 2
67269: PUSH
67270: LD_INT 2
67272: PUSH
67273: EMPTY
67274: LIST
67275: LIST
67276: PUSH
67277: LD_INT 1
67279: PUSH
67280: LD_INT 2
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: PUSH
67287: LD_INT 0
67289: PUSH
67290: LD_INT 2
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 1
67299: NEG
67300: PUSH
67301: LD_INT 1
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: PUSH
67308: LD_INT 2
67310: NEG
67311: PUSH
67312: LD_INT 0
67314: PUSH
67315: EMPTY
67316: LIST
67317: LIST
67318: PUSH
67319: LD_INT 2
67321: NEG
67322: PUSH
67323: LD_INT 1
67325: NEG
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: LD_INT 2
67333: NEG
67334: PUSH
67335: LD_INT 2
67337: NEG
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: EMPTY
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: LIST
67355: LIST
67356: LIST
67357: LIST
67358: LIST
67359: LIST
67360: LIST
67361: LIST
67362: LIST
67363: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
67364: LD_ADDR_VAR 0 23
67368: PUSH
67369: LD_INT 0
67371: PUSH
67372: LD_INT 0
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: PUSH
67379: LD_INT 0
67381: PUSH
67382: LD_INT 1
67384: NEG
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: LD_INT 1
67392: PUSH
67393: LD_INT 0
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 1
67402: PUSH
67403: LD_INT 1
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 0
67412: PUSH
67413: LD_INT 1
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 1
67422: NEG
67423: PUSH
67424: LD_INT 0
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: PUSH
67431: LD_INT 1
67433: NEG
67434: PUSH
67435: LD_INT 1
67437: NEG
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 1
67445: NEG
67446: PUSH
67447: LD_INT 2
67449: NEG
67450: PUSH
67451: EMPTY
67452: LIST
67453: LIST
67454: PUSH
67455: LD_INT 0
67457: PUSH
67458: LD_INT 2
67460: NEG
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 1
67468: PUSH
67469: LD_INT 1
67471: NEG
67472: PUSH
67473: EMPTY
67474: LIST
67475: LIST
67476: PUSH
67477: LD_INT 2
67479: PUSH
67480: LD_INT 0
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: PUSH
67487: LD_INT 2
67489: PUSH
67490: LD_INT 1
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: PUSH
67497: LD_INT 2
67499: PUSH
67500: LD_INT 2
67502: PUSH
67503: EMPTY
67504: LIST
67505: LIST
67506: PUSH
67507: LD_INT 1
67509: PUSH
67510: LD_INT 2
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 0
67519: PUSH
67520: LD_INT 2
67522: PUSH
67523: EMPTY
67524: LIST
67525: LIST
67526: PUSH
67527: LD_INT 1
67529: NEG
67530: PUSH
67531: LD_INT 1
67533: PUSH
67534: EMPTY
67535: LIST
67536: LIST
67537: PUSH
67538: LD_INT 2
67540: NEG
67541: PUSH
67542: LD_INT 0
67544: PUSH
67545: EMPTY
67546: LIST
67547: LIST
67548: PUSH
67549: LD_INT 2
67551: NEG
67552: PUSH
67553: LD_INT 1
67555: NEG
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PUSH
67561: LD_INT 2
67563: NEG
67564: PUSH
67565: LD_INT 2
67567: NEG
67568: PUSH
67569: EMPTY
67570: LIST
67571: LIST
67572: PUSH
67573: LD_INT 2
67575: NEG
67576: PUSH
67577: LD_INT 3
67579: NEG
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 1
67587: NEG
67588: PUSH
67589: LD_INT 3
67591: NEG
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: PUSH
67597: LD_INT 1
67599: PUSH
67600: LD_INT 2
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 2
67610: PUSH
67611: LD_INT 1
67613: NEG
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: PUSH
67619: EMPTY
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67644: LD_ADDR_VAR 0 24
67648: PUSH
67649: LD_INT 0
67651: PUSH
67652: LD_INT 0
67654: PUSH
67655: EMPTY
67656: LIST
67657: LIST
67658: PUSH
67659: LD_INT 0
67661: PUSH
67662: LD_INT 1
67664: NEG
67665: PUSH
67666: EMPTY
67667: LIST
67668: LIST
67669: PUSH
67670: LD_INT 1
67672: PUSH
67673: LD_INT 0
67675: PUSH
67676: EMPTY
67677: LIST
67678: LIST
67679: PUSH
67680: LD_INT 1
67682: PUSH
67683: LD_INT 1
67685: PUSH
67686: EMPTY
67687: LIST
67688: LIST
67689: PUSH
67690: LD_INT 0
67692: PUSH
67693: LD_INT 1
67695: PUSH
67696: EMPTY
67697: LIST
67698: LIST
67699: PUSH
67700: LD_INT 1
67702: NEG
67703: PUSH
67704: LD_INT 0
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: PUSH
67711: LD_INT 1
67713: NEG
67714: PUSH
67715: LD_INT 1
67717: NEG
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 1
67725: NEG
67726: PUSH
67727: LD_INT 2
67729: NEG
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 0
67737: PUSH
67738: LD_INT 2
67740: NEG
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: LD_INT 1
67748: PUSH
67749: LD_INT 1
67751: NEG
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: PUSH
67757: LD_INT 2
67759: PUSH
67760: LD_INT 0
67762: PUSH
67763: EMPTY
67764: LIST
67765: LIST
67766: PUSH
67767: LD_INT 2
67769: PUSH
67770: LD_INT 1
67772: PUSH
67773: EMPTY
67774: LIST
67775: LIST
67776: PUSH
67777: LD_INT 2
67779: PUSH
67780: LD_INT 2
67782: PUSH
67783: EMPTY
67784: LIST
67785: LIST
67786: PUSH
67787: LD_INT 1
67789: PUSH
67790: LD_INT 2
67792: PUSH
67793: EMPTY
67794: LIST
67795: LIST
67796: PUSH
67797: LD_INT 0
67799: PUSH
67800: LD_INT 2
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 1
67809: NEG
67810: PUSH
67811: LD_INT 1
67813: PUSH
67814: EMPTY
67815: LIST
67816: LIST
67817: PUSH
67818: LD_INT 2
67820: NEG
67821: PUSH
67822: LD_INT 0
67824: PUSH
67825: EMPTY
67826: LIST
67827: LIST
67828: PUSH
67829: LD_INT 2
67831: NEG
67832: PUSH
67833: LD_INT 1
67835: NEG
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: PUSH
67841: LD_INT 2
67843: NEG
67844: PUSH
67845: LD_INT 2
67847: NEG
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 1
67855: PUSH
67856: LD_INT 2
67858: NEG
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: LD_INT 2
67866: PUSH
67867: LD_INT 1
67869: NEG
67870: PUSH
67871: EMPTY
67872: LIST
67873: LIST
67874: PUSH
67875: LD_INT 3
67877: PUSH
67878: LD_INT 1
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PUSH
67885: LD_INT 3
67887: PUSH
67888: LD_INT 2
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: LIST
67899: LIST
67900: LIST
67901: LIST
67902: LIST
67903: LIST
67904: LIST
67905: LIST
67906: LIST
67907: LIST
67908: LIST
67909: LIST
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67920: LD_ADDR_VAR 0 25
67924: PUSH
67925: LD_INT 0
67927: PUSH
67928: LD_INT 0
67930: PUSH
67931: EMPTY
67932: LIST
67933: LIST
67934: PUSH
67935: LD_INT 0
67937: PUSH
67938: LD_INT 1
67940: NEG
67941: PUSH
67942: EMPTY
67943: LIST
67944: LIST
67945: PUSH
67946: LD_INT 1
67948: PUSH
67949: LD_INT 0
67951: PUSH
67952: EMPTY
67953: LIST
67954: LIST
67955: PUSH
67956: LD_INT 1
67958: PUSH
67959: LD_INT 1
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 0
67968: PUSH
67969: LD_INT 1
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 1
67978: NEG
67979: PUSH
67980: LD_INT 0
67982: PUSH
67983: EMPTY
67984: LIST
67985: LIST
67986: PUSH
67987: LD_INT 1
67989: NEG
67990: PUSH
67991: LD_INT 1
67993: NEG
67994: PUSH
67995: EMPTY
67996: LIST
67997: LIST
67998: PUSH
67999: LD_INT 1
68001: NEG
68002: PUSH
68003: LD_INT 2
68005: NEG
68006: PUSH
68007: EMPTY
68008: LIST
68009: LIST
68010: PUSH
68011: LD_INT 0
68013: PUSH
68014: LD_INT 2
68016: NEG
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: LD_INT 1
68024: PUSH
68025: LD_INT 1
68027: NEG
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 2
68035: PUSH
68036: LD_INT 0
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: PUSH
68043: LD_INT 2
68045: PUSH
68046: LD_INT 1
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: PUSH
68053: LD_INT 2
68055: PUSH
68056: LD_INT 2
68058: PUSH
68059: EMPTY
68060: LIST
68061: LIST
68062: PUSH
68063: LD_INT 1
68065: PUSH
68066: LD_INT 2
68068: PUSH
68069: EMPTY
68070: LIST
68071: LIST
68072: PUSH
68073: LD_INT 0
68075: PUSH
68076: LD_INT 2
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 1
68085: NEG
68086: PUSH
68087: LD_INT 1
68089: PUSH
68090: EMPTY
68091: LIST
68092: LIST
68093: PUSH
68094: LD_INT 2
68096: NEG
68097: PUSH
68098: LD_INT 0
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: LD_INT 2
68107: NEG
68108: PUSH
68109: LD_INT 1
68111: NEG
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: LD_INT 2
68119: NEG
68120: PUSH
68121: LD_INT 2
68123: NEG
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PUSH
68129: LD_INT 3
68131: PUSH
68132: LD_INT 1
68134: PUSH
68135: EMPTY
68136: LIST
68137: LIST
68138: PUSH
68139: LD_INT 3
68141: PUSH
68142: LD_INT 2
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: PUSH
68149: LD_INT 2
68151: PUSH
68152: LD_INT 3
68154: PUSH
68155: EMPTY
68156: LIST
68157: LIST
68158: PUSH
68159: LD_INT 1
68161: PUSH
68162: LD_INT 3
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68194: LD_ADDR_VAR 0 26
68198: PUSH
68199: LD_INT 0
68201: PUSH
68202: LD_INT 0
68204: PUSH
68205: EMPTY
68206: LIST
68207: LIST
68208: PUSH
68209: LD_INT 0
68211: PUSH
68212: LD_INT 1
68214: NEG
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: PUSH
68220: LD_INT 1
68222: PUSH
68223: LD_INT 0
68225: PUSH
68226: EMPTY
68227: LIST
68228: LIST
68229: PUSH
68230: LD_INT 1
68232: PUSH
68233: LD_INT 1
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 0
68242: PUSH
68243: LD_INT 1
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 1
68252: NEG
68253: PUSH
68254: LD_INT 0
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 1
68263: NEG
68264: PUSH
68265: LD_INT 1
68267: NEG
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: PUSH
68273: LD_INT 1
68275: NEG
68276: PUSH
68277: LD_INT 2
68279: NEG
68280: PUSH
68281: EMPTY
68282: LIST
68283: LIST
68284: PUSH
68285: LD_INT 0
68287: PUSH
68288: LD_INT 2
68290: NEG
68291: PUSH
68292: EMPTY
68293: LIST
68294: LIST
68295: PUSH
68296: LD_INT 1
68298: PUSH
68299: LD_INT 1
68301: NEG
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 2
68309: PUSH
68310: LD_INT 0
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: PUSH
68317: LD_INT 2
68319: PUSH
68320: LD_INT 1
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PUSH
68327: LD_INT 2
68329: PUSH
68330: LD_INT 2
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 1
68339: PUSH
68340: LD_INT 2
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: PUSH
68347: LD_INT 0
68349: PUSH
68350: LD_INT 2
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 1
68359: NEG
68360: PUSH
68361: LD_INT 1
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: LD_INT 2
68370: NEG
68371: PUSH
68372: LD_INT 0
68374: PUSH
68375: EMPTY
68376: LIST
68377: LIST
68378: PUSH
68379: LD_INT 2
68381: NEG
68382: PUSH
68383: LD_INT 1
68385: NEG
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 2
68393: NEG
68394: PUSH
68395: LD_INT 2
68397: NEG
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: PUSH
68403: LD_INT 2
68405: PUSH
68406: LD_INT 3
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 1
68415: PUSH
68416: LD_INT 3
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 1
68425: NEG
68426: PUSH
68427: LD_INT 2
68429: PUSH
68430: EMPTY
68431: LIST
68432: LIST
68433: PUSH
68434: LD_INT 2
68436: NEG
68437: PUSH
68438: LD_INT 1
68440: PUSH
68441: EMPTY
68442: LIST
68443: LIST
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: LIST
68461: LIST
68462: LIST
68463: LIST
68464: LIST
68465: LIST
68466: LIST
68467: LIST
68468: LIST
68469: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68470: LD_ADDR_VAR 0 27
68474: PUSH
68475: LD_INT 0
68477: PUSH
68478: LD_INT 0
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: PUSH
68485: LD_INT 0
68487: PUSH
68488: LD_INT 1
68490: NEG
68491: PUSH
68492: EMPTY
68493: LIST
68494: LIST
68495: PUSH
68496: LD_INT 1
68498: PUSH
68499: LD_INT 0
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: PUSH
68506: LD_INT 1
68508: PUSH
68509: LD_INT 1
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: LD_INT 0
68518: PUSH
68519: LD_INT 1
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: PUSH
68526: LD_INT 1
68528: NEG
68529: PUSH
68530: LD_INT 0
68532: PUSH
68533: EMPTY
68534: LIST
68535: LIST
68536: PUSH
68537: LD_INT 1
68539: NEG
68540: PUSH
68541: LD_INT 1
68543: NEG
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 1
68551: NEG
68552: PUSH
68553: LD_INT 2
68555: NEG
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 0
68563: PUSH
68564: LD_INT 2
68566: NEG
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 1
68574: PUSH
68575: LD_INT 1
68577: NEG
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 2
68585: PUSH
68586: LD_INT 0
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 2
68595: PUSH
68596: LD_INT 1
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: LD_INT 2
68605: PUSH
68606: LD_INT 2
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 1
68615: PUSH
68616: LD_INT 2
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PUSH
68623: LD_INT 0
68625: PUSH
68626: LD_INT 2
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 1
68635: NEG
68636: PUSH
68637: LD_INT 1
68639: PUSH
68640: EMPTY
68641: LIST
68642: LIST
68643: PUSH
68644: LD_INT 2
68646: NEG
68647: PUSH
68648: LD_INT 0
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 2
68657: NEG
68658: PUSH
68659: LD_INT 1
68661: NEG
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: PUSH
68667: LD_INT 2
68669: NEG
68670: PUSH
68671: LD_INT 2
68673: NEG
68674: PUSH
68675: EMPTY
68676: LIST
68677: LIST
68678: PUSH
68679: LD_INT 1
68681: NEG
68682: PUSH
68683: LD_INT 2
68685: PUSH
68686: EMPTY
68687: LIST
68688: LIST
68689: PUSH
68690: LD_INT 2
68692: NEG
68693: PUSH
68694: LD_INT 1
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 3
68703: NEG
68704: PUSH
68705: LD_INT 1
68707: NEG
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 3
68715: NEG
68716: PUSH
68717: LD_INT 2
68719: NEG
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: LIST
68734: LIST
68735: LIST
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: LIST
68746: LIST
68747: LIST
68748: LIST
68749: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68750: LD_ADDR_VAR 0 28
68754: PUSH
68755: LD_INT 0
68757: PUSH
68758: LD_INT 0
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 0
68767: PUSH
68768: LD_INT 1
68770: NEG
68771: PUSH
68772: EMPTY
68773: LIST
68774: LIST
68775: PUSH
68776: LD_INT 1
68778: PUSH
68779: LD_INT 0
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: PUSH
68786: LD_INT 1
68788: PUSH
68789: LD_INT 1
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: LD_INT 0
68798: PUSH
68799: LD_INT 1
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 1
68808: NEG
68809: PUSH
68810: LD_INT 0
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 1
68819: NEG
68820: PUSH
68821: LD_INT 1
68823: NEG
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 1
68831: NEG
68832: PUSH
68833: LD_INT 2
68835: NEG
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 0
68843: PUSH
68844: LD_INT 2
68846: NEG
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 1
68854: PUSH
68855: LD_INT 1
68857: NEG
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 2
68865: PUSH
68866: LD_INT 0
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 2
68875: PUSH
68876: LD_INT 1
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 2
68885: PUSH
68886: LD_INT 2
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 1
68895: PUSH
68896: LD_INT 2
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: LD_INT 0
68905: PUSH
68906: LD_INT 2
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: LD_INT 1
68915: NEG
68916: PUSH
68917: LD_INT 1
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 2
68926: NEG
68927: PUSH
68928: LD_INT 0
68930: PUSH
68931: EMPTY
68932: LIST
68933: LIST
68934: PUSH
68935: LD_INT 2
68937: NEG
68938: PUSH
68939: LD_INT 1
68941: NEG
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 2
68949: NEG
68950: PUSH
68951: LD_INT 2
68953: NEG
68954: PUSH
68955: EMPTY
68956: LIST
68957: LIST
68958: PUSH
68959: LD_INT 2
68961: NEG
68962: PUSH
68963: LD_INT 3
68965: NEG
68966: PUSH
68967: EMPTY
68968: LIST
68969: LIST
68970: PUSH
68971: LD_INT 1
68973: NEG
68974: PUSH
68975: LD_INT 3
68977: NEG
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: LD_INT 3
68985: NEG
68986: PUSH
68987: LD_INT 1
68989: NEG
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 3
68997: NEG
68998: PUSH
68999: LD_INT 2
69001: NEG
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: EMPTY
69008: LIST
69009: LIST
69010: LIST
69011: LIST
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: LIST
69028: LIST
69029: LIST
69030: LIST
69031: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69032: LD_ADDR_VAR 0 29
69036: PUSH
69037: LD_INT 0
69039: PUSH
69040: LD_INT 0
69042: PUSH
69043: EMPTY
69044: LIST
69045: LIST
69046: PUSH
69047: LD_INT 0
69049: PUSH
69050: LD_INT 1
69052: NEG
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PUSH
69058: LD_INT 1
69060: PUSH
69061: LD_INT 0
69063: PUSH
69064: EMPTY
69065: LIST
69066: LIST
69067: PUSH
69068: LD_INT 1
69070: PUSH
69071: LD_INT 1
69073: PUSH
69074: EMPTY
69075: LIST
69076: LIST
69077: PUSH
69078: LD_INT 0
69080: PUSH
69081: LD_INT 1
69083: PUSH
69084: EMPTY
69085: LIST
69086: LIST
69087: PUSH
69088: LD_INT 1
69090: NEG
69091: PUSH
69092: LD_INT 0
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 1
69101: NEG
69102: PUSH
69103: LD_INT 1
69105: NEG
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PUSH
69111: LD_INT 1
69113: NEG
69114: PUSH
69115: LD_INT 2
69117: NEG
69118: PUSH
69119: EMPTY
69120: LIST
69121: LIST
69122: PUSH
69123: LD_INT 0
69125: PUSH
69126: LD_INT 2
69128: NEG
69129: PUSH
69130: EMPTY
69131: LIST
69132: LIST
69133: PUSH
69134: LD_INT 1
69136: PUSH
69137: LD_INT 1
69139: NEG
69140: PUSH
69141: EMPTY
69142: LIST
69143: LIST
69144: PUSH
69145: LD_INT 2
69147: PUSH
69148: LD_INT 0
69150: PUSH
69151: EMPTY
69152: LIST
69153: LIST
69154: PUSH
69155: LD_INT 2
69157: PUSH
69158: LD_INT 1
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: PUSH
69165: LD_INT 1
69167: PUSH
69168: LD_INT 2
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PUSH
69175: LD_INT 0
69177: PUSH
69178: LD_INT 2
69180: PUSH
69181: EMPTY
69182: LIST
69183: LIST
69184: PUSH
69185: LD_INT 1
69187: NEG
69188: PUSH
69189: LD_INT 1
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PUSH
69196: LD_INT 2
69198: NEG
69199: PUSH
69200: LD_INT 1
69202: NEG
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 2
69210: NEG
69211: PUSH
69212: LD_INT 2
69214: NEG
69215: PUSH
69216: EMPTY
69217: LIST
69218: LIST
69219: PUSH
69220: LD_INT 2
69222: NEG
69223: PUSH
69224: LD_INT 3
69226: NEG
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 2
69234: PUSH
69235: LD_INT 1
69237: NEG
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: PUSH
69243: LD_INT 3
69245: PUSH
69246: LD_INT 1
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 1
69255: PUSH
69256: LD_INT 3
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 1
69265: NEG
69266: PUSH
69267: LD_INT 2
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PUSH
69274: LD_INT 3
69276: NEG
69277: PUSH
69278: LD_INT 2
69280: NEG
69281: PUSH
69282: EMPTY
69283: LIST
69284: LIST
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: LIST
69310: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69311: LD_ADDR_VAR 0 30
69315: PUSH
69316: LD_INT 0
69318: PUSH
69319: LD_INT 0
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: PUSH
69326: LD_INT 0
69328: PUSH
69329: LD_INT 1
69331: NEG
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: LD_INT 1
69339: PUSH
69340: LD_INT 0
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: PUSH
69347: LD_INT 1
69349: PUSH
69350: LD_INT 1
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 0
69359: PUSH
69360: LD_INT 1
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 1
69369: NEG
69370: PUSH
69371: LD_INT 0
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: PUSH
69378: LD_INT 1
69380: NEG
69381: PUSH
69382: LD_INT 1
69384: NEG
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 1
69392: NEG
69393: PUSH
69394: LD_INT 2
69396: NEG
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 0
69404: PUSH
69405: LD_INT 2
69407: NEG
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: PUSH
69413: LD_INT 1
69415: PUSH
69416: LD_INT 1
69418: NEG
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: LD_INT 2
69426: PUSH
69427: LD_INT 0
69429: PUSH
69430: EMPTY
69431: LIST
69432: LIST
69433: PUSH
69434: LD_INT 2
69436: PUSH
69437: LD_INT 1
69439: PUSH
69440: EMPTY
69441: LIST
69442: LIST
69443: PUSH
69444: LD_INT 2
69446: PUSH
69447: LD_INT 2
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 1
69456: PUSH
69457: LD_INT 2
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: PUSH
69464: LD_INT 1
69466: NEG
69467: PUSH
69468: LD_INT 1
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 2
69477: NEG
69478: PUSH
69479: LD_INT 0
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: LD_INT 2
69488: NEG
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 1
69500: NEG
69501: PUSH
69502: LD_INT 3
69504: NEG
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: PUSH
69510: LD_INT 1
69512: PUSH
69513: LD_INT 2
69515: NEG
69516: PUSH
69517: EMPTY
69518: LIST
69519: LIST
69520: PUSH
69521: LD_INT 3
69523: PUSH
69524: LD_INT 2
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 2
69533: PUSH
69534: LD_INT 3
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 2
69543: NEG
69544: PUSH
69545: LD_INT 1
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 3
69554: NEG
69555: PUSH
69556: LD_INT 1
69558: NEG
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: EMPTY
69565: LIST
69566: LIST
69567: LIST
69568: LIST
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: LIST
69574: LIST
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69589: LD_ADDR_VAR 0 31
69593: PUSH
69594: LD_INT 0
69596: PUSH
69597: LD_INT 0
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: LD_INT 0
69606: PUSH
69607: LD_INT 1
69609: NEG
69610: PUSH
69611: EMPTY
69612: LIST
69613: LIST
69614: PUSH
69615: LD_INT 1
69617: PUSH
69618: LD_INT 0
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 1
69627: PUSH
69628: LD_INT 1
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 0
69637: PUSH
69638: LD_INT 1
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 1
69647: NEG
69648: PUSH
69649: LD_INT 0
69651: PUSH
69652: EMPTY
69653: LIST
69654: LIST
69655: PUSH
69656: LD_INT 1
69658: NEG
69659: PUSH
69660: LD_INT 1
69662: NEG
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: PUSH
69668: LD_INT 1
69670: NEG
69671: PUSH
69672: LD_INT 2
69674: NEG
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 1
69682: PUSH
69683: LD_INT 1
69685: NEG
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: LD_INT 2
69693: PUSH
69694: LD_INT 0
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PUSH
69701: LD_INT 2
69703: PUSH
69704: LD_INT 1
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 2
69713: PUSH
69714: LD_INT 2
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: PUSH
69721: LD_INT 1
69723: PUSH
69724: LD_INT 2
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 0
69733: PUSH
69734: LD_INT 2
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 1
69743: NEG
69744: PUSH
69745: LD_INT 1
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 2
69754: NEG
69755: PUSH
69756: LD_INT 1
69758: NEG
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 2
69766: NEG
69767: PUSH
69768: LD_INT 2
69770: NEG
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 2
69778: NEG
69779: PUSH
69780: LD_INT 3
69782: NEG
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PUSH
69788: LD_INT 2
69790: PUSH
69791: LD_INT 1
69793: NEG
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 3
69801: PUSH
69802: LD_INT 1
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 1
69811: PUSH
69812: LD_INT 3
69814: PUSH
69815: EMPTY
69816: LIST
69817: LIST
69818: PUSH
69819: LD_INT 1
69821: NEG
69822: PUSH
69823: LD_INT 2
69825: PUSH
69826: EMPTY
69827: LIST
69828: LIST
69829: PUSH
69830: LD_INT 3
69832: NEG
69833: PUSH
69834: LD_INT 2
69836: NEG
69837: PUSH
69838: EMPTY
69839: LIST
69840: LIST
69841: PUSH
69842: EMPTY
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69867: LD_ADDR_VAR 0 32
69871: PUSH
69872: LD_INT 0
69874: PUSH
69875: LD_INT 0
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: PUSH
69882: LD_INT 0
69884: PUSH
69885: LD_INT 1
69887: NEG
69888: PUSH
69889: EMPTY
69890: LIST
69891: LIST
69892: PUSH
69893: LD_INT 1
69895: PUSH
69896: LD_INT 0
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: LD_INT 1
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: LD_INT 0
69915: PUSH
69916: LD_INT 1
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: LD_INT 1
69925: NEG
69926: PUSH
69927: LD_INT 0
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 1
69936: NEG
69937: PUSH
69938: LD_INT 1
69940: NEG
69941: PUSH
69942: EMPTY
69943: LIST
69944: LIST
69945: PUSH
69946: LD_INT 1
69948: NEG
69949: PUSH
69950: LD_INT 2
69952: NEG
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 0
69960: PUSH
69961: LD_INT 2
69963: NEG
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 1
69971: PUSH
69972: LD_INT 1
69974: NEG
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: PUSH
69980: LD_INT 2
69982: PUSH
69983: LD_INT 1
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: LD_INT 2
69992: PUSH
69993: LD_INT 2
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PUSH
70000: LD_INT 1
70002: PUSH
70003: LD_INT 2
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 0
70012: PUSH
70013: LD_INT 2
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 1
70022: NEG
70023: PUSH
70024: LD_INT 1
70026: PUSH
70027: EMPTY
70028: LIST
70029: LIST
70030: PUSH
70031: LD_INT 2
70033: NEG
70034: PUSH
70035: LD_INT 0
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: PUSH
70042: LD_INT 2
70044: NEG
70045: PUSH
70046: LD_INT 1
70048: NEG
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: PUSH
70054: LD_INT 1
70056: NEG
70057: PUSH
70058: LD_INT 3
70060: NEG
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: PUSH
70066: LD_INT 1
70068: PUSH
70069: LD_INT 2
70071: NEG
70072: PUSH
70073: EMPTY
70074: LIST
70075: LIST
70076: PUSH
70077: LD_INT 3
70079: PUSH
70080: LD_INT 2
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 2
70089: PUSH
70090: LD_INT 3
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PUSH
70097: LD_INT 2
70099: NEG
70100: PUSH
70101: LD_INT 1
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 3
70110: NEG
70111: PUSH
70112: LD_INT 1
70114: NEG
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: LIST
70124: LIST
70125: LIST
70126: LIST
70127: LIST
70128: LIST
70129: LIST
70130: LIST
70131: LIST
70132: LIST
70133: LIST
70134: LIST
70135: LIST
70136: LIST
70137: LIST
70138: LIST
70139: LIST
70140: LIST
70141: LIST
70142: LIST
70143: LIST
70144: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70145: LD_ADDR_VAR 0 33
70149: PUSH
70150: LD_INT 0
70152: PUSH
70153: LD_INT 0
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: LD_INT 0
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 1
70173: PUSH
70174: LD_INT 0
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 1
70183: PUSH
70184: LD_INT 1
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 0
70193: PUSH
70194: LD_INT 1
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 1
70203: NEG
70204: PUSH
70205: LD_INT 0
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: PUSH
70212: LD_INT 1
70214: NEG
70215: PUSH
70216: LD_INT 1
70218: NEG
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: PUSH
70224: LD_INT 1
70226: NEG
70227: PUSH
70228: LD_INT 2
70230: NEG
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: LD_INT 1
70238: PUSH
70239: LD_INT 1
70241: NEG
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: LD_INT 2
70249: PUSH
70250: LD_INT 0
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 2
70259: PUSH
70260: LD_INT 1
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: LD_INT 1
70269: PUSH
70270: LD_INT 2
70272: PUSH
70273: EMPTY
70274: LIST
70275: LIST
70276: PUSH
70277: LD_INT 0
70279: PUSH
70280: LD_INT 2
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 1
70289: NEG
70290: PUSH
70291: LD_INT 1
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: PUSH
70298: LD_INT 2
70300: NEG
70301: PUSH
70302: LD_INT 0
70304: PUSH
70305: EMPTY
70306: LIST
70307: LIST
70308: PUSH
70309: LD_INT 2
70311: NEG
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: PUSH
70321: LD_INT 2
70323: NEG
70324: PUSH
70325: LD_INT 2
70327: NEG
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PUSH
70333: LD_INT 2
70335: NEG
70336: PUSH
70337: LD_INT 3
70339: NEG
70340: PUSH
70341: EMPTY
70342: LIST
70343: LIST
70344: PUSH
70345: LD_INT 2
70347: PUSH
70348: LD_INT 1
70350: NEG
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 3
70358: PUSH
70359: LD_INT 1
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: LD_INT 3
70371: PUSH
70372: EMPTY
70373: LIST
70374: LIST
70375: PUSH
70376: LD_INT 1
70378: NEG
70379: PUSH
70380: LD_INT 2
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 3
70389: NEG
70390: PUSH
70391: LD_INT 2
70393: NEG
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: LIST
70403: LIST
70404: LIST
70405: LIST
70406: LIST
70407: LIST
70408: LIST
70409: LIST
70410: LIST
70411: LIST
70412: LIST
70413: LIST
70414: LIST
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: LIST
70423: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70424: LD_ADDR_VAR 0 34
70428: PUSH
70429: LD_INT 0
70431: PUSH
70432: LD_INT 0
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: LD_INT 0
70441: PUSH
70442: LD_INT 1
70444: NEG
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: LD_INT 1
70452: PUSH
70453: LD_INT 0
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: PUSH
70460: LD_INT 1
70462: PUSH
70463: LD_INT 1
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 0
70472: PUSH
70473: LD_INT 1
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: LD_INT 1
70482: NEG
70483: PUSH
70484: LD_INT 0
70486: PUSH
70487: EMPTY
70488: LIST
70489: LIST
70490: PUSH
70491: LD_INT 1
70493: NEG
70494: PUSH
70495: LD_INT 1
70497: NEG
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 1
70505: NEG
70506: PUSH
70507: LD_INT 2
70509: NEG
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PUSH
70515: LD_INT 0
70517: PUSH
70518: LD_INT 2
70520: NEG
70521: PUSH
70522: EMPTY
70523: LIST
70524: LIST
70525: PUSH
70526: LD_INT 1
70528: PUSH
70529: LD_INT 1
70531: NEG
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 2
70539: PUSH
70540: LD_INT 1
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: PUSH
70547: LD_INT 2
70549: PUSH
70550: LD_INT 2
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: PUSH
70557: LD_INT 1
70559: PUSH
70560: LD_INT 2
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: PUSH
70567: LD_INT 1
70569: NEG
70570: PUSH
70571: LD_INT 1
70573: PUSH
70574: EMPTY
70575: LIST
70576: LIST
70577: PUSH
70578: LD_INT 2
70580: NEG
70581: PUSH
70582: LD_INT 0
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PUSH
70589: LD_INT 2
70591: NEG
70592: PUSH
70593: LD_INT 1
70595: NEG
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 2
70603: NEG
70604: PUSH
70605: LD_INT 2
70607: NEG
70608: PUSH
70609: EMPTY
70610: LIST
70611: LIST
70612: PUSH
70613: LD_INT 1
70615: NEG
70616: PUSH
70617: LD_INT 3
70619: NEG
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: PUSH
70625: LD_INT 1
70627: PUSH
70628: LD_INT 2
70630: NEG
70631: PUSH
70632: EMPTY
70633: LIST
70634: LIST
70635: PUSH
70636: LD_INT 3
70638: PUSH
70639: LD_INT 2
70641: PUSH
70642: EMPTY
70643: LIST
70644: LIST
70645: PUSH
70646: LD_INT 2
70648: PUSH
70649: LD_INT 3
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: PUSH
70656: LD_INT 2
70658: NEG
70659: PUSH
70660: LD_INT 1
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: LD_INT 3
70669: NEG
70670: PUSH
70671: LD_INT 1
70673: NEG
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: LIST
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70704: LD_ADDR_VAR 0 35
70708: PUSH
70709: LD_INT 0
70711: PUSH
70712: LD_INT 0
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 0
70721: PUSH
70722: LD_INT 1
70724: NEG
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 1
70732: PUSH
70733: LD_INT 0
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 1
70742: PUSH
70743: LD_INT 1
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 0
70752: PUSH
70753: LD_INT 1
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: LD_INT 1
70762: NEG
70763: PUSH
70764: LD_INT 0
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: PUSH
70771: LD_INT 1
70773: NEG
70774: PUSH
70775: LD_INT 1
70777: NEG
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: PUSH
70783: LD_INT 2
70785: PUSH
70786: LD_INT 1
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: PUSH
70793: LD_INT 2
70795: NEG
70796: PUSH
70797: LD_INT 1
70799: NEG
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70816: LD_ADDR_VAR 0 36
70820: PUSH
70821: LD_INT 0
70823: PUSH
70824: LD_INT 0
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 0
70833: PUSH
70834: LD_INT 1
70836: NEG
70837: PUSH
70838: EMPTY
70839: LIST
70840: LIST
70841: PUSH
70842: LD_INT 1
70844: PUSH
70845: LD_INT 0
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PUSH
70852: LD_INT 1
70854: PUSH
70855: LD_INT 1
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 0
70864: PUSH
70865: LD_INT 1
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: PUSH
70872: LD_INT 1
70874: NEG
70875: PUSH
70876: LD_INT 0
70878: PUSH
70879: EMPTY
70880: LIST
70881: LIST
70882: PUSH
70883: LD_INT 1
70885: NEG
70886: PUSH
70887: LD_INT 1
70889: NEG
70890: PUSH
70891: EMPTY
70892: LIST
70893: LIST
70894: PUSH
70895: LD_INT 1
70897: NEG
70898: PUSH
70899: LD_INT 2
70901: NEG
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 1
70909: PUSH
70910: LD_INT 2
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70928: LD_ADDR_VAR 0 37
70932: PUSH
70933: LD_INT 0
70935: PUSH
70936: LD_INT 0
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 0
70945: PUSH
70946: LD_INT 1
70948: NEG
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: LD_INT 1
70956: PUSH
70957: LD_INT 0
70959: PUSH
70960: EMPTY
70961: LIST
70962: LIST
70963: PUSH
70964: LD_INT 1
70966: PUSH
70967: LD_INT 1
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: PUSH
70974: LD_INT 0
70976: PUSH
70977: LD_INT 1
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 1
70986: NEG
70987: PUSH
70988: LD_INT 0
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: PUSH
70995: LD_INT 1
70997: NEG
70998: PUSH
70999: LD_INT 1
71001: NEG
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 1
71009: PUSH
71010: LD_INT 1
71012: NEG
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 1
71020: NEG
71021: PUSH
71022: LD_INT 1
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71040: LD_ADDR_VAR 0 38
71044: PUSH
71045: LD_INT 0
71047: PUSH
71048: LD_INT 0
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: PUSH
71055: LD_INT 0
71057: PUSH
71058: LD_INT 1
71060: NEG
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: PUSH
71066: LD_INT 1
71068: PUSH
71069: LD_INT 0
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: PUSH
71076: LD_INT 1
71078: PUSH
71079: LD_INT 1
71081: PUSH
71082: EMPTY
71083: LIST
71084: LIST
71085: PUSH
71086: LD_INT 0
71088: PUSH
71089: LD_INT 1
71091: PUSH
71092: EMPTY
71093: LIST
71094: LIST
71095: PUSH
71096: LD_INT 1
71098: NEG
71099: PUSH
71100: LD_INT 0
71102: PUSH
71103: EMPTY
71104: LIST
71105: LIST
71106: PUSH
71107: LD_INT 1
71109: NEG
71110: PUSH
71111: LD_INT 1
71113: NEG
71114: PUSH
71115: EMPTY
71116: LIST
71117: LIST
71118: PUSH
71119: LD_INT 2
71121: PUSH
71122: LD_INT 1
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: PUSH
71129: LD_INT 2
71131: NEG
71132: PUSH
71133: LD_INT 1
71135: NEG
71136: PUSH
71137: EMPTY
71138: LIST
71139: LIST
71140: PUSH
71141: EMPTY
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71152: LD_ADDR_VAR 0 39
71156: PUSH
71157: LD_INT 0
71159: PUSH
71160: LD_INT 0
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 0
71169: PUSH
71170: LD_INT 1
71172: NEG
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PUSH
71178: LD_INT 1
71180: PUSH
71181: LD_INT 0
71183: PUSH
71184: EMPTY
71185: LIST
71186: LIST
71187: PUSH
71188: LD_INT 1
71190: PUSH
71191: LD_INT 1
71193: PUSH
71194: EMPTY
71195: LIST
71196: LIST
71197: PUSH
71198: LD_INT 0
71200: PUSH
71201: LD_INT 1
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: PUSH
71208: LD_INT 1
71210: NEG
71211: PUSH
71212: LD_INT 0
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PUSH
71219: LD_INT 1
71221: NEG
71222: PUSH
71223: LD_INT 1
71225: NEG
71226: PUSH
71227: EMPTY
71228: LIST
71229: LIST
71230: PUSH
71231: LD_INT 1
71233: NEG
71234: PUSH
71235: LD_INT 2
71237: NEG
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PUSH
71243: LD_INT 1
71245: PUSH
71246: LD_INT 2
71248: PUSH
71249: EMPTY
71250: LIST
71251: LIST
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71264: LD_ADDR_VAR 0 40
71268: PUSH
71269: LD_INT 0
71271: PUSH
71272: LD_INT 0
71274: PUSH
71275: EMPTY
71276: LIST
71277: LIST
71278: PUSH
71279: LD_INT 0
71281: PUSH
71282: LD_INT 1
71284: NEG
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 1
71292: PUSH
71293: LD_INT 0
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: LD_INT 1
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 0
71312: PUSH
71313: LD_INT 1
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 1
71322: NEG
71323: PUSH
71324: LD_INT 0
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 1
71333: NEG
71334: PUSH
71335: LD_INT 1
71337: NEG
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 1
71345: PUSH
71346: LD_INT 1
71348: NEG
71349: PUSH
71350: EMPTY
71351: LIST
71352: LIST
71353: PUSH
71354: LD_INT 1
71356: NEG
71357: PUSH
71358: LD_INT 1
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71376: LD_ADDR_VAR 0 41
71380: PUSH
71381: LD_INT 0
71383: PUSH
71384: LD_INT 0
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: PUSH
71391: LD_INT 0
71393: PUSH
71394: LD_INT 1
71396: NEG
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: LD_INT 1
71404: PUSH
71405: LD_INT 0
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 1
71414: PUSH
71415: LD_INT 1
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: PUSH
71422: LD_INT 0
71424: PUSH
71425: LD_INT 1
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: PUSH
71432: LD_INT 1
71434: NEG
71435: PUSH
71436: LD_INT 0
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: PUSH
71443: LD_INT 1
71445: NEG
71446: PUSH
71447: LD_INT 1
71449: NEG
71450: PUSH
71451: EMPTY
71452: LIST
71453: LIST
71454: PUSH
71455: LD_INT 1
71457: NEG
71458: PUSH
71459: LD_INT 2
71461: NEG
71462: PUSH
71463: EMPTY
71464: LIST
71465: LIST
71466: PUSH
71467: LD_INT 1
71469: PUSH
71470: LD_INT 1
71472: NEG
71473: PUSH
71474: EMPTY
71475: LIST
71476: LIST
71477: PUSH
71478: LD_INT 2
71480: PUSH
71481: LD_INT 0
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: PUSH
71488: LD_INT 2
71490: PUSH
71491: LD_INT 1
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: PUSH
71498: LD_INT 2
71500: PUSH
71501: LD_INT 2
71503: PUSH
71504: EMPTY
71505: LIST
71506: LIST
71507: PUSH
71508: LD_INT 1
71510: PUSH
71511: LD_INT 2
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PUSH
71518: LD_INT 1
71520: NEG
71521: PUSH
71522: LD_INT 1
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 2
71531: NEG
71532: PUSH
71533: LD_INT 0
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 2
71542: NEG
71543: PUSH
71544: LD_INT 1
71546: NEG
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PUSH
71552: LD_INT 2
71554: NEG
71555: PUSH
71556: LD_INT 2
71558: NEG
71559: PUSH
71560: EMPTY
71561: LIST
71562: LIST
71563: PUSH
71564: LD_INT 2
71566: NEG
71567: PUSH
71568: LD_INT 3
71570: NEG
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: LD_INT 2
71578: PUSH
71579: LD_INT 1
71581: NEG
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 3
71589: PUSH
71590: LD_INT 0
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: LD_INT 3
71599: PUSH
71600: LD_INT 1
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 3
71609: PUSH
71610: LD_INT 2
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: LD_INT 3
71619: PUSH
71620: LD_INT 3
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 2
71629: PUSH
71630: LD_INT 3
71632: PUSH
71633: EMPTY
71634: LIST
71635: LIST
71636: PUSH
71637: LD_INT 2
71639: NEG
71640: PUSH
71641: LD_INT 1
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 3
71650: NEG
71651: PUSH
71652: LD_INT 0
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: PUSH
71659: LD_INT 3
71661: NEG
71662: PUSH
71663: LD_INT 1
71665: NEG
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: PUSH
71671: LD_INT 3
71673: NEG
71674: PUSH
71675: LD_INT 2
71677: NEG
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 3
71685: NEG
71686: PUSH
71687: LD_INT 3
71689: NEG
71690: PUSH
71691: EMPTY
71692: LIST
71693: LIST
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: LIST
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71726: LD_ADDR_VAR 0 42
71730: PUSH
71731: LD_INT 0
71733: PUSH
71734: LD_INT 0
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 0
71743: PUSH
71744: LD_INT 1
71746: NEG
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: LD_INT 1
71754: PUSH
71755: LD_INT 0
71757: PUSH
71758: EMPTY
71759: LIST
71760: LIST
71761: PUSH
71762: LD_INT 1
71764: PUSH
71765: LD_INT 1
71767: PUSH
71768: EMPTY
71769: LIST
71770: LIST
71771: PUSH
71772: LD_INT 0
71774: PUSH
71775: LD_INT 1
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 1
71784: NEG
71785: PUSH
71786: LD_INT 0
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: LD_INT 1
71795: NEG
71796: PUSH
71797: LD_INT 1
71799: NEG
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 1
71807: NEG
71808: PUSH
71809: LD_INT 2
71811: NEG
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: PUSH
71817: LD_INT 0
71819: PUSH
71820: LD_INT 2
71822: NEG
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: LD_INT 1
71830: PUSH
71831: LD_INT 1
71833: NEG
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: PUSH
71839: LD_INT 2
71841: PUSH
71842: LD_INT 1
71844: PUSH
71845: EMPTY
71846: LIST
71847: LIST
71848: PUSH
71849: LD_INT 2
71851: PUSH
71852: LD_INT 2
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 1
71861: PUSH
71862: LD_INT 2
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 0
71871: PUSH
71872: LD_INT 2
71874: PUSH
71875: EMPTY
71876: LIST
71877: LIST
71878: PUSH
71879: LD_INT 1
71881: NEG
71882: PUSH
71883: LD_INT 1
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PUSH
71890: LD_INT 2
71892: NEG
71893: PUSH
71894: LD_INT 1
71896: NEG
71897: PUSH
71898: EMPTY
71899: LIST
71900: LIST
71901: PUSH
71902: LD_INT 2
71904: NEG
71905: PUSH
71906: LD_INT 2
71908: NEG
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 2
71916: NEG
71917: PUSH
71918: LD_INT 3
71920: NEG
71921: PUSH
71922: EMPTY
71923: LIST
71924: LIST
71925: PUSH
71926: LD_INT 1
71928: NEG
71929: PUSH
71930: LD_INT 3
71932: NEG
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: PUSH
71938: LD_INT 0
71940: PUSH
71941: LD_INT 3
71943: NEG
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 1
71951: PUSH
71952: LD_INT 2
71954: NEG
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: LD_INT 3
71962: PUSH
71963: LD_INT 2
71965: PUSH
71966: EMPTY
71967: LIST
71968: LIST
71969: PUSH
71970: LD_INT 3
71972: PUSH
71973: LD_INT 3
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: PUSH
71980: LD_INT 2
71982: PUSH
71983: LD_INT 3
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: PUSH
71990: LD_INT 1
71992: PUSH
71993: LD_INT 3
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 0
72002: PUSH
72003: LD_INT 3
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: LD_INT 1
72012: NEG
72013: PUSH
72014: LD_INT 2
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 3
72023: NEG
72024: PUSH
72025: LD_INT 2
72027: NEG
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 3
72035: NEG
72036: PUSH
72037: LD_INT 3
72039: NEG
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: LIST
72055: LIST
72056: LIST
72057: LIST
72058: LIST
72059: LIST
72060: LIST
72061: LIST
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: LIST
72074: LIST
72075: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72076: LD_ADDR_VAR 0 43
72080: PUSH
72081: LD_INT 0
72083: PUSH
72084: LD_INT 0
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: PUSH
72091: LD_INT 0
72093: PUSH
72094: LD_INT 1
72096: NEG
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: PUSH
72102: LD_INT 1
72104: PUSH
72105: LD_INT 0
72107: PUSH
72108: EMPTY
72109: LIST
72110: LIST
72111: PUSH
72112: LD_INT 1
72114: PUSH
72115: LD_INT 1
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 0
72124: PUSH
72125: LD_INT 1
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 1
72134: NEG
72135: PUSH
72136: LD_INT 0
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: PUSH
72143: LD_INT 1
72145: NEG
72146: PUSH
72147: LD_INT 1
72149: NEG
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: PUSH
72155: LD_INT 1
72157: NEG
72158: PUSH
72159: LD_INT 2
72161: NEG
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: LD_INT 2
72172: NEG
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: LD_INT 1
72180: PUSH
72181: LD_INT 1
72183: NEG
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 2
72191: PUSH
72192: LD_INT 0
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: LD_INT 2
72201: PUSH
72202: LD_INT 1
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PUSH
72209: LD_INT 1
72211: PUSH
72212: LD_INT 2
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: PUSH
72219: LD_INT 0
72221: PUSH
72222: LD_INT 2
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 1
72231: NEG
72232: PUSH
72233: LD_INT 1
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 2
72242: NEG
72243: PUSH
72244: LD_INT 0
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 2
72253: NEG
72254: PUSH
72255: LD_INT 1
72257: NEG
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: LD_INT 1
72265: NEG
72266: PUSH
72267: LD_INT 3
72269: NEG
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 0
72277: PUSH
72278: LD_INT 3
72280: NEG
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: PUSH
72286: LD_INT 1
72288: PUSH
72289: LD_INT 2
72291: NEG
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 2
72299: PUSH
72300: LD_INT 1
72302: NEG
72303: PUSH
72304: EMPTY
72305: LIST
72306: LIST
72307: PUSH
72308: LD_INT 3
72310: PUSH
72311: LD_INT 0
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: PUSH
72318: LD_INT 3
72320: PUSH
72321: LD_INT 1
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: LD_INT 1
72330: PUSH
72331: LD_INT 3
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: LD_INT 0
72340: PUSH
72341: LD_INT 3
72343: PUSH
72344: EMPTY
72345: LIST
72346: LIST
72347: PUSH
72348: LD_INT 1
72350: NEG
72351: PUSH
72352: LD_INT 2
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: PUSH
72359: LD_INT 2
72361: NEG
72362: PUSH
72363: LD_INT 1
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: LD_INT 3
72372: NEG
72373: PUSH
72374: LD_INT 0
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: PUSH
72381: LD_INT 3
72383: NEG
72384: PUSH
72385: LD_INT 1
72387: NEG
72388: PUSH
72389: EMPTY
72390: LIST
72391: LIST
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: LIST
72402: LIST
72403: LIST
72404: LIST
72405: LIST
72406: LIST
72407: LIST
72408: LIST
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: LIST
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: LIST
72419: LIST
72420: LIST
72421: LIST
72422: LIST
72423: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72424: LD_ADDR_VAR 0 44
72428: PUSH
72429: LD_INT 0
72431: PUSH
72432: LD_INT 0
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: PUSH
72439: LD_INT 0
72441: PUSH
72442: LD_INT 1
72444: NEG
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PUSH
72450: LD_INT 1
72452: PUSH
72453: LD_INT 0
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: PUSH
72460: LD_INT 1
72462: PUSH
72463: LD_INT 1
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: LD_INT 1
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 1
72482: NEG
72483: PUSH
72484: LD_INT 0
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: PUSH
72491: LD_INT 1
72493: NEG
72494: PUSH
72495: LD_INT 1
72497: NEG
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 1
72505: NEG
72506: PUSH
72507: LD_INT 2
72509: NEG
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: PUSH
72515: LD_INT 1
72517: PUSH
72518: LD_INT 1
72520: NEG
72521: PUSH
72522: EMPTY
72523: LIST
72524: LIST
72525: PUSH
72526: LD_INT 2
72528: PUSH
72529: LD_INT 0
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: LD_INT 2
72538: PUSH
72539: LD_INT 1
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 2
72548: PUSH
72549: LD_INT 2
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: LD_INT 1
72558: PUSH
72559: LD_INT 2
72561: PUSH
72562: EMPTY
72563: LIST
72564: LIST
72565: PUSH
72566: LD_INT 1
72568: NEG
72569: PUSH
72570: LD_INT 1
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 2
72579: NEG
72580: PUSH
72581: LD_INT 0
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: LD_INT 2
72590: NEG
72591: PUSH
72592: LD_INT 1
72594: NEG
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 2
72602: NEG
72603: PUSH
72604: LD_INT 2
72606: NEG
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 2
72614: NEG
72615: PUSH
72616: LD_INT 3
72618: NEG
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 2
72626: PUSH
72627: LD_INT 1
72629: NEG
72630: PUSH
72631: EMPTY
72632: LIST
72633: LIST
72634: PUSH
72635: LD_INT 3
72637: PUSH
72638: LD_INT 0
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 3
72647: PUSH
72648: LD_INT 1
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: LD_INT 3
72657: PUSH
72658: LD_INT 2
72660: PUSH
72661: EMPTY
72662: LIST
72663: LIST
72664: PUSH
72665: LD_INT 3
72667: PUSH
72668: LD_INT 3
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: PUSH
72675: LD_INT 2
72677: PUSH
72678: LD_INT 3
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: LD_INT 2
72687: NEG
72688: PUSH
72689: LD_INT 1
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 3
72698: NEG
72699: PUSH
72700: LD_INT 0
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: PUSH
72707: LD_INT 3
72709: NEG
72710: PUSH
72711: LD_INT 1
72713: NEG
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: PUSH
72719: LD_INT 3
72721: NEG
72722: PUSH
72723: LD_INT 2
72725: NEG
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: PUSH
72731: LD_INT 3
72733: NEG
72734: PUSH
72735: LD_INT 3
72737: NEG
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: EMPTY
72744: LIST
72745: LIST
72746: LIST
72747: LIST
72748: LIST
72749: LIST
72750: LIST
72751: LIST
72752: LIST
72753: LIST
72754: LIST
72755: LIST
72756: LIST
72757: LIST
72758: LIST
72759: LIST
72760: LIST
72761: LIST
72762: LIST
72763: LIST
72764: LIST
72765: LIST
72766: LIST
72767: LIST
72768: LIST
72769: LIST
72770: LIST
72771: LIST
72772: LIST
72773: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72774: LD_ADDR_VAR 0 45
72778: PUSH
72779: LD_INT 0
72781: PUSH
72782: LD_INT 0
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: LD_INT 0
72791: PUSH
72792: LD_INT 1
72794: NEG
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 1
72802: PUSH
72803: LD_INT 0
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 1
72812: PUSH
72813: LD_INT 1
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: LD_INT 0
72822: PUSH
72823: LD_INT 1
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: LD_INT 1
72832: NEG
72833: PUSH
72834: LD_INT 0
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PUSH
72841: LD_INT 1
72843: NEG
72844: PUSH
72845: LD_INT 1
72847: NEG
72848: PUSH
72849: EMPTY
72850: LIST
72851: LIST
72852: PUSH
72853: LD_INT 1
72855: NEG
72856: PUSH
72857: LD_INT 2
72859: NEG
72860: PUSH
72861: EMPTY
72862: LIST
72863: LIST
72864: PUSH
72865: LD_INT 0
72867: PUSH
72868: LD_INT 2
72870: NEG
72871: PUSH
72872: EMPTY
72873: LIST
72874: LIST
72875: PUSH
72876: LD_INT 1
72878: PUSH
72879: LD_INT 1
72881: NEG
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 2
72889: PUSH
72890: LD_INT 1
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 2
72899: PUSH
72900: LD_INT 2
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: PUSH
72910: LD_INT 2
72912: PUSH
72913: EMPTY
72914: LIST
72915: LIST
72916: PUSH
72917: LD_INT 0
72919: PUSH
72920: LD_INT 2
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 1
72929: NEG
72930: PUSH
72931: LD_INT 1
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 2
72940: NEG
72941: PUSH
72942: LD_INT 1
72944: NEG
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: PUSH
72950: LD_INT 2
72952: NEG
72953: PUSH
72954: LD_INT 2
72956: NEG
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 2
72964: NEG
72965: PUSH
72966: LD_INT 3
72968: NEG
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 1
72976: NEG
72977: PUSH
72978: LD_INT 3
72980: NEG
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 0
72988: PUSH
72989: LD_INT 3
72991: NEG
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 1
72999: PUSH
73000: LD_INT 2
73002: NEG
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: PUSH
73008: LD_INT 3
73010: PUSH
73011: LD_INT 2
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 3
73020: PUSH
73021: LD_INT 3
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PUSH
73028: LD_INT 2
73030: PUSH
73031: LD_INT 3
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 1
73040: PUSH
73041: LD_INT 3
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 0
73050: PUSH
73051: LD_INT 3
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PUSH
73058: LD_INT 1
73060: NEG
73061: PUSH
73062: LD_INT 2
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 3
73071: NEG
73072: PUSH
73073: LD_INT 2
73075: NEG
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: LD_INT 3
73083: NEG
73084: PUSH
73085: LD_INT 3
73087: NEG
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PUSH
73093: EMPTY
73094: LIST
73095: LIST
73096: LIST
73097: LIST
73098: LIST
73099: LIST
73100: LIST
73101: LIST
73102: LIST
73103: LIST
73104: LIST
73105: LIST
73106: LIST
73107: LIST
73108: LIST
73109: LIST
73110: LIST
73111: LIST
73112: LIST
73113: LIST
73114: LIST
73115: LIST
73116: LIST
73117: LIST
73118: LIST
73119: LIST
73120: LIST
73121: LIST
73122: LIST
73123: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73124: LD_ADDR_VAR 0 46
73128: PUSH
73129: LD_INT 0
73131: PUSH
73132: LD_INT 0
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: LD_INT 0
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: LD_INT 1
73152: PUSH
73153: LD_INT 0
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 1
73162: PUSH
73163: LD_INT 1
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PUSH
73170: LD_INT 0
73172: PUSH
73173: LD_INT 1
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PUSH
73180: LD_INT 1
73182: NEG
73183: PUSH
73184: LD_INT 0
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 1
73193: NEG
73194: PUSH
73195: LD_INT 1
73197: NEG
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: PUSH
73203: LD_INT 1
73205: NEG
73206: PUSH
73207: LD_INT 2
73209: NEG
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: PUSH
73215: LD_INT 0
73217: PUSH
73218: LD_INT 2
73220: NEG
73221: PUSH
73222: EMPTY
73223: LIST
73224: LIST
73225: PUSH
73226: LD_INT 1
73228: PUSH
73229: LD_INT 1
73231: NEG
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: LD_INT 2
73239: PUSH
73240: LD_INT 0
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: LD_INT 2
73249: PUSH
73250: LD_INT 1
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: LD_INT 2
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: LD_INT 0
73269: PUSH
73270: LD_INT 2
73272: PUSH
73273: EMPTY
73274: LIST
73275: LIST
73276: PUSH
73277: LD_INT 1
73279: NEG
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 2
73290: NEG
73291: PUSH
73292: LD_INT 0
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: LD_INT 2
73301: NEG
73302: PUSH
73303: LD_INT 1
73305: NEG
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 1
73313: NEG
73314: PUSH
73315: LD_INT 3
73317: NEG
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 0
73325: PUSH
73326: LD_INT 3
73328: NEG
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 1
73336: PUSH
73337: LD_INT 2
73339: NEG
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 2
73347: PUSH
73348: LD_INT 1
73350: NEG
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: LD_INT 3
73358: PUSH
73359: LD_INT 0
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 3
73368: PUSH
73369: LD_INT 1
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 1
73378: PUSH
73379: LD_INT 3
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: LD_INT 0
73388: PUSH
73389: LD_INT 3
73391: PUSH
73392: EMPTY
73393: LIST
73394: LIST
73395: PUSH
73396: LD_INT 1
73398: NEG
73399: PUSH
73400: LD_INT 2
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 2
73409: NEG
73410: PUSH
73411: LD_INT 1
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 3
73420: NEG
73421: PUSH
73422: LD_INT 0
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 3
73431: NEG
73432: PUSH
73433: LD_INT 1
73435: NEG
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: LIST
73445: LIST
73446: LIST
73447: LIST
73448: LIST
73449: LIST
73450: LIST
73451: LIST
73452: LIST
73453: LIST
73454: LIST
73455: LIST
73456: LIST
73457: LIST
73458: LIST
73459: LIST
73460: LIST
73461: LIST
73462: LIST
73463: LIST
73464: LIST
73465: LIST
73466: LIST
73467: LIST
73468: LIST
73469: LIST
73470: LIST
73471: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73472: LD_ADDR_VAR 0 47
73476: PUSH
73477: LD_INT 0
73479: PUSH
73480: LD_INT 0
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: LD_INT 0
73489: PUSH
73490: LD_INT 1
73492: NEG
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 1
73500: PUSH
73501: LD_INT 0
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 1
73510: PUSH
73511: LD_INT 1
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: LD_INT 0
73520: PUSH
73521: LD_INT 1
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 1
73530: NEG
73531: PUSH
73532: LD_INT 0
73534: PUSH
73535: EMPTY
73536: LIST
73537: LIST
73538: PUSH
73539: LD_INT 1
73541: NEG
73542: PUSH
73543: LD_INT 1
73545: NEG
73546: PUSH
73547: EMPTY
73548: LIST
73549: LIST
73550: PUSH
73551: LD_INT 1
73553: NEG
73554: PUSH
73555: LD_INT 2
73557: NEG
73558: PUSH
73559: EMPTY
73560: LIST
73561: LIST
73562: PUSH
73563: LD_INT 0
73565: PUSH
73566: LD_INT 2
73568: NEG
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 1
73576: PUSH
73577: LD_INT 1
73579: NEG
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 2
73587: NEG
73588: PUSH
73589: LD_INT 1
73591: NEG
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 2
73599: NEG
73600: PUSH
73601: LD_INT 2
73603: NEG
73604: PUSH
73605: EMPTY
73606: LIST
73607: LIST
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: LIST
73622: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73623: LD_ADDR_VAR 0 48
73627: PUSH
73628: LD_INT 0
73630: PUSH
73631: LD_INT 0
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: LD_INT 0
73640: PUSH
73641: LD_INT 1
73643: NEG
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 1
73651: PUSH
73652: LD_INT 0
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 1
73661: PUSH
73662: LD_INT 1
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 0
73671: PUSH
73672: LD_INT 1
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 1
73681: NEG
73682: PUSH
73683: LD_INT 0
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 1
73692: NEG
73693: PUSH
73694: LD_INT 1
73696: NEG
73697: PUSH
73698: EMPTY
73699: LIST
73700: LIST
73701: PUSH
73702: LD_INT 1
73704: NEG
73705: PUSH
73706: LD_INT 2
73708: NEG
73709: PUSH
73710: EMPTY
73711: LIST
73712: LIST
73713: PUSH
73714: LD_INT 0
73716: PUSH
73717: LD_INT 2
73719: NEG
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PUSH
73725: LD_INT 1
73727: PUSH
73728: LD_INT 1
73730: NEG
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PUSH
73736: LD_INT 2
73738: PUSH
73739: LD_INT 0
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PUSH
73746: LD_INT 2
73748: PUSH
73749: LD_INT 1
73751: PUSH
73752: EMPTY
73753: LIST
73754: LIST
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: LIST
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73770: LD_ADDR_VAR 0 49
73774: PUSH
73775: LD_INT 0
73777: PUSH
73778: LD_INT 0
73780: PUSH
73781: EMPTY
73782: LIST
73783: LIST
73784: PUSH
73785: LD_INT 0
73787: PUSH
73788: LD_INT 1
73790: NEG
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: PUSH
73796: LD_INT 1
73798: PUSH
73799: LD_INT 0
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 1
73808: PUSH
73809: LD_INT 1
73811: PUSH
73812: EMPTY
73813: LIST
73814: LIST
73815: PUSH
73816: LD_INT 0
73818: PUSH
73819: LD_INT 1
73821: PUSH
73822: EMPTY
73823: LIST
73824: LIST
73825: PUSH
73826: LD_INT 1
73828: NEG
73829: PUSH
73830: LD_INT 0
73832: PUSH
73833: EMPTY
73834: LIST
73835: LIST
73836: PUSH
73837: LD_INT 1
73839: NEG
73840: PUSH
73841: LD_INT 1
73843: NEG
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 1
73851: PUSH
73852: LD_INT 1
73854: NEG
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 2
73862: PUSH
73863: LD_INT 0
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 2
73872: PUSH
73873: LD_INT 1
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 2
73882: PUSH
73883: LD_INT 2
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: LD_INT 1
73892: PUSH
73893: LD_INT 2
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: EMPTY
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73914: LD_ADDR_VAR 0 50
73918: PUSH
73919: LD_INT 0
73921: PUSH
73922: LD_INT 0
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: PUSH
73929: LD_INT 0
73931: PUSH
73932: LD_INT 1
73934: NEG
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 1
73942: PUSH
73943: LD_INT 0
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 1
73952: PUSH
73953: LD_INT 1
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: PUSH
73960: LD_INT 0
73962: PUSH
73963: LD_INT 1
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: PUSH
73970: LD_INT 1
73972: NEG
73973: PUSH
73974: LD_INT 0
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 1
73983: NEG
73984: PUSH
73985: LD_INT 1
73987: NEG
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: PUSH
73993: LD_INT 2
73995: PUSH
73996: LD_INT 1
73998: PUSH
73999: EMPTY
74000: LIST
74001: LIST
74002: PUSH
74003: LD_INT 2
74005: PUSH
74006: LD_INT 2
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: PUSH
74013: LD_INT 1
74015: PUSH
74016: LD_INT 2
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 0
74025: PUSH
74026: LD_INT 2
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: PUSH
74033: LD_INT 1
74035: NEG
74036: PUSH
74037: LD_INT 1
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74058: LD_ADDR_VAR 0 51
74062: PUSH
74063: LD_INT 0
74065: PUSH
74066: LD_INT 0
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: LD_INT 0
74075: PUSH
74076: LD_INT 1
74078: NEG
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 1
74086: PUSH
74087: LD_INT 0
74089: PUSH
74090: EMPTY
74091: LIST
74092: LIST
74093: PUSH
74094: LD_INT 1
74096: PUSH
74097: LD_INT 1
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: PUSH
74104: LD_INT 0
74106: PUSH
74107: LD_INT 1
74109: PUSH
74110: EMPTY
74111: LIST
74112: LIST
74113: PUSH
74114: LD_INT 1
74116: NEG
74117: PUSH
74118: LD_INT 0
74120: PUSH
74121: EMPTY
74122: LIST
74123: LIST
74124: PUSH
74125: LD_INT 1
74127: NEG
74128: PUSH
74129: LD_INT 1
74131: NEG
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: PUSH
74137: LD_INT 1
74139: PUSH
74140: LD_INT 2
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: PUSH
74147: LD_INT 0
74149: PUSH
74150: LD_INT 2
74152: PUSH
74153: EMPTY
74154: LIST
74155: LIST
74156: PUSH
74157: LD_INT 1
74159: NEG
74160: PUSH
74161: LD_INT 1
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 2
74170: NEG
74171: PUSH
74172: LD_INT 0
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: PUSH
74179: LD_INT 2
74181: NEG
74182: PUSH
74183: LD_INT 1
74185: NEG
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: PUSH
74191: EMPTY
74192: LIST
74193: LIST
74194: LIST
74195: LIST
74196: LIST
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: LIST
74204: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74205: LD_ADDR_VAR 0 52
74209: PUSH
74210: LD_INT 0
74212: PUSH
74213: LD_INT 0
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: LD_INT 0
74222: PUSH
74223: LD_INT 1
74225: NEG
74226: PUSH
74227: EMPTY
74228: LIST
74229: LIST
74230: PUSH
74231: LD_INT 1
74233: PUSH
74234: LD_INT 0
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PUSH
74241: LD_INT 1
74243: PUSH
74244: LD_INT 1
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: PUSH
74251: LD_INT 0
74253: PUSH
74254: LD_INT 1
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: LD_INT 1
74263: NEG
74264: PUSH
74265: LD_INT 0
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 1
74274: NEG
74275: PUSH
74276: LD_INT 1
74278: NEG
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 1
74286: NEG
74287: PUSH
74288: LD_INT 2
74290: NEG
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: LD_INT 1
74298: NEG
74299: PUSH
74300: LD_INT 1
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: PUSH
74307: LD_INT 2
74309: NEG
74310: PUSH
74311: LD_INT 0
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 2
74320: NEG
74321: PUSH
74322: LD_INT 1
74324: NEG
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: PUSH
74330: LD_INT 2
74332: NEG
74333: PUSH
74334: LD_INT 2
74336: NEG
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: PUSH
74342: EMPTY
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: LIST
74350: LIST
74351: LIST
74352: LIST
74353: LIST
74354: LIST
74355: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74356: LD_ADDR_VAR 0 53
74360: PUSH
74361: LD_INT 0
74363: PUSH
74364: LD_INT 0
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 0
74373: PUSH
74374: LD_INT 1
74376: NEG
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 1
74384: PUSH
74385: LD_INT 0
74387: PUSH
74388: EMPTY
74389: LIST
74390: LIST
74391: PUSH
74392: LD_INT 1
74394: PUSH
74395: LD_INT 1
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: LD_INT 0
74404: PUSH
74405: LD_INT 1
74407: PUSH
74408: EMPTY
74409: LIST
74410: LIST
74411: PUSH
74412: LD_INT 1
74414: NEG
74415: PUSH
74416: LD_INT 0
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: LD_INT 1
74425: NEG
74426: PUSH
74427: LD_INT 1
74429: NEG
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PUSH
74435: LD_INT 1
74437: NEG
74438: PUSH
74439: LD_INT 2
74441: NEG
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: PUSH
74447: LD_INT 0
74449: PUSH
74450: LD_INT 2
74452: NEG
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 1
74460: PUSH
74461: LD_INT 1
74463: NEG
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: PUSH
74469: LD_INT 2
74471: PUSH
74472: LD_INT 0
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: PUSH
74479: LD_INT 2
74481: PUSH
74482: LD_INT 1
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 2
74491: PUSH
74492: LD_INT 2
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 1
74501: PUSH
74502: LD_INT 2
74504: PUSH
74505: EMPTY
74506: LIST
74507: LIST
74508: PUSH
74509: LD_INT 0
74511: PUSH
74512: LD_INT 2
74514: PUSH
74515: EMPTY
74516: LIST
74517: LIST
74518: PUSH
74519: LD_INT 1
74521: NEG
74522: PUSH
74523: LD_INT 1
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: LD_INT 2
74532: NEG
74533: PUSH
74534: LD_INT 0
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: PUSH
74541: LD_INT 2
74543: NEG
74544: PUSH
74545: LD_INT 1
74547: NEG
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: PUSH
74553: LD_INT 2
74555: NEG
74556: PUSH
74557: LD_INT 2
74559: NEG
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: LIST
74571: LIST
74572: LIST
74573: LIST
74574: LIST
74575: LIST
74576: LIST
74577: LIST
74578: LIST
74579: LIST
74580: LIST
74581: LIST
74582: LIST
74583: LIST
74584: LIST
74585: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74586: LD_ADDR_VAR 0 54
74590: PUSH
74591: LD_INT 0
74593: PUSH
74594: LD_INT 0
74596: PUSH
74597: EMPTY
74598: LIST
74599: LIST
74600: PUSH
74601: LD_INT 0
74603: PUSH
74604: LD_INT 1
74606: NEG
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 1
74614: PUSH
74615: LD_INT 0
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 1
74624: PUSH
74625: LD_INT 1
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: PUSH
74632: LD_INT 0
74634: PUSH
74635: LD_INT 1
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: PUSH
74642: LD_INT 1
74644: NEG
74645: PUSH
74646: LD_INT 0
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 1
74655: NEG
74656: PUSH
74657: LD_INT 1
74659: NEG
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 1
74667: NEG
74668: PUSH
74669: LD_INT 2
74671: NEG
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 0
74679: PUSH
74680: LD_INT 2
74682: NEG
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 1
74690: PUSH
74691: LD_INT 1
74693: NEG
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 2
74701: PUSH
74702: LD_INT 0
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: LD_INT 2
74711: PUSH
74712: LD_INT 1
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 2
74721: PUSH
74722: LD_INT 2
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PUSH
74729: LD_INT 1
74731: PUSH
74732: LD_INT 2
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: PUSH
74739: LD_INT 0
74741: PUSH
74742: LD_INT 2
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 1
74751: NEG
74752: PUSH
74753: LD_INT 1
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PUSH
74760: LD_INT 2
74762: NEG
74763: PUSH
74764: LD_INT 0
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: LD_INT 2
74773: NEG
74774: PUSH
74775: LD_INT 1
74777: NEG
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: LD_INT 2
74785: NEG
74786: PUSH
74787: LD_INT 2
74789: NEG
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: PUSH
74795: EMPTY
74796: LIST
74797: LIST
74798: LIST
74799: LIST
74800: LIST
74801: LIST
74802: LIST
74803: LIST
74804: LIST
74805: LIST
74806: LIST
74807: LIST
74808: LIST
74809: LIST
74810: LIST
74811: LIST
74812: LIST
74813: LIST
74814: LIST
74815: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74816: LD_ADDR_VAR 0 55
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: LD_INT 0
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 0
74833: PUSH
74834: LD_INT 1
74836: NEG
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 1
74844: PUSH
74845: LD_INT 0
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 1
74854: PUSH
74855: LD_INT 1
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PUSH
74862: LD_INT 0
74864: PUSH
74865: LD_INT 1
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 1
74874: NEG
74875: PUSH
74876: LD_INT 0
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: LD_INT 1
74885: NEG
74886: PUSH
74887: LD_INT 1
74889: NEG
74890: PUSH
74891: EMPTY
74892: LIST
74893: LIST
74894: PUSH
74895: LD_INT 1
74897: NEG
74898: PUSH
74899: LD_INT 2
74901: NEG
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 0
74909: PUSH
74910: LD_INT 2
74912: NEG
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 1
74920: PUSH
74921: LD_INT 1
74923: NEG
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 2
74931: PUSH
74932: LD_INT 0
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: PUSH
74939: LD_INT 2
74941: PUSH
74942: LD_INT 1
74944: PUSH
74945: EMPTY
74946: LIST
74947: LIST
74948: PUSH
74949: LD_INT 2
74951: PUSH
74952: LD_INT 2
74954: PUSH
74955: EMPTY
74956: LIST
74957: LIST
74958: PUSH
74959: LD_INT 1
74961: PUSH
74962: LD_INT 2
74964: PUSH
74965: EMPTY
74966: LIST
74967: LIST
74968: PUSH
74969: LD_INT 0
74971: PUSH
74972: LD_INT 2
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: PUSH
74979: LD_INT 1
74981: NEG
74982: PUSH
74983: LD_INT 1
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: LD_INT 2
74992: NEG
74993: PUSH
74994: LD_INT 0
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: PUSH
75001: LD_INT 2
75003: NEG
75004: PUSH
75005: LD_INT 1
75007: NEG
75008: PUSH
75009: EMPTY
75010: LIST
75011: LIST
75012: PUSH
75013: LD_INT 2
75015: NEG
75016: PUSH
75017: LD_INT 2
75019: NEG
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: LIST
75029: LIST
75030: LIST
75031: LIST
75032: LIST
75033: LIST
75034: LIST
75035: LIST
75036: LIST
75037: LIST
75038: LIST
75039: LIST
75040: LIST
75041: LIST
75042: LIST
75043: LIST
75044: LIST
75045: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75046: LD_ADDR_VAR 0 56
75050: PUSH
75051: LD_INT 0
75053: PUSH
75054: LD_INT 0
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 0
75063: PUSH
75064: LD_INT 1
75066: NEG
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 1
75074: PUSH
75075: LD_INT 0
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 1
75084: PUSH
75085: LD_INT 1
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PUSH
75092: LD_INT 0
75094: PUSH
75095: LD_INT 1
75097: PUSH
75098: EMPTY
75099: LIST
75100: LIST
75101: PUSH
75102: LD_INT 1
75104: NEG
75105: PUSH
75106: LD_INT 0
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 1
75115: NEG
75116: PUSH
75117: LD_INT 1
75119: NEG
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: LD_INT 1
75127: NEG
75128: PUSH
75129: LD_INT 2
75131: NEG
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: LD_INT 0
75139: PUSH
75140: LD_INT 2
75142: NEG
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 1
75150: PUSH
75151: LD_INT 1
75153: NEG
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 2
75161: PUSH
75162: LD_INT 0
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: LD_INT 2
75171: PUSH
75172: LD_INT 1
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PUSH
75179: LD_INT 2
75181: PUSH
75182: LD_INT 2
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: LD_INT 1
75191: PUSH
75192: LD_INT 2
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 0
75201: PUSH
75202: LD_INT 2
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: PUSH
75209: LD_INT 1
75211: NEG
75212: PUSH
75213: LD_INT 1
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: LD_INT 2
75222: NEG
75223: PUSH
75224: LD_INT 0
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: LD_INT 2
75233: NEG
75234: PUSH
75235: LD_INT 1
75237: NEG
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 2
75245: NEG
75246: PUSH
75247: LD_INT 2
75249: NEG
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: PUSH
75255: EMPTY
75256: LIST
75257: LIST
75258: LIST
75259: LIST
75260: LIST
75261: LIST
75262: LIST
75263: LIST
75264: LIST
75265: LIST
75266: LIST
75267: LIST
75268: LIST
75269: LIST
75270: LIST
75271: LIST
75272: LIST
75273: LIST
75274: LIST
75275: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75276: LD_ADDR_VAR 0 57
75280: PUSH
75281: LD_INT 0
75283: PUSH
75284: LD_INT 0
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 0
75293: PUSH
75294: LD_INT 1
75296: NEG
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: LD_INT 1
75304: PUSH
75305: LD_INT 0
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 1
75314: PUSH
75315: LD_INT 1
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: LD_INT 0
75324: PUSH
75325: LD_INT 1
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: PUSH
75332: LD_INT 1
75334: NEG
75335: PUSH
75336: LD_INT 0
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: PUSH
75343: LD_INT 1
75345: NEG
75346: PUSH
75347: LD_INT 1
75349: NEG
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 1
75357: NEG
75358: PUSH
75359: LD_INT 2
75361: NEG
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 0
75369: PUSH
75370: LD_INT 2
75372: NEG
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 1
75380: PUSH
75381: LD_INT 1
75383: NEG
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 2
75391: PUSH
75392: LD_INT 0
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: LD_INT 2
75401: PUSH
75402: LD_INT 1
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: LD_INT 2
75411: PUSH
75412: LD_INT 2
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: PUSH
75419: LD_INT 1
75421: PUSH
75422: LD_INT 2
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: PUSH
75429: LD_INT 0
75431: PUSH
75432: LD_INT 2
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PUSH
75439: LD_INT 1
75441: NEG
75442: PUSH
75443: LD_INT 1
75445: PUSH
75446: EMPTY
75447: LIST
75448: LIST
75449: PUSH
75450: LD_INT 2
75452: NEG
75453: PUSH
75454: LD_INT 0
75456: PUSH
75457: EMPTY
75458: LIST
75459: LIST
75460: PUSH
75461: LD_INT 2
75463: NEG
75464: PUSH
75465: LD_INT 1
75467: NEG
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: LD_INT 2
75475: NEG
75476: PUSH
75477: LD_INT 2
75479: NEG
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: LIST
75500: LIST
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75506: LD_ADDR_VAR 0 58
75510: PUSH
75511: LD_INT 0
75513: PUSH
75514: LD_INT 0
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: LD_INT 0
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: PUSH
75532: LD_INT 1
75534: PUSH
75535: LD_INT 0
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 1
75544: PUSH
75545: LD_INT 1
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 0
75554: PUSH
75555: LD_INT 1
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: LD_INT 1
75564: NEG
75565: PUSH
75566: LD_INT 0
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: LD_INT 1
75575: NEG
75576: PUSH
75577: LD_INT 1
75579: NEG
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 1
75587: NEG
75588: PUSH
75589: LD_INT 2
75591: NEG
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: LD_INT 0
75599: PUSH
75600: LD_INT 2
75602: NEG
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 1
75610: PUSH
75611: LD_INT 1
75613: NEG
75614: PUSH
75615: EMPTY
75616: LIST
75617: LIST
75618: PUSH
75619: LD_INT 2
75621: PUSH
75622: LD_INT 0
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 2
75631: PUSH
75632: LD_INT 1
75634: PUSH
75635: EMPTY
75636: LIST
75637: LIST
75638: PUSH
75639: LD_INT 2
75641: PUSH
75642: LD_INT 2
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: LD_INT 1
75651: PUSH
75652: LD_INT 2
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 0
75661: PUSH
75662: LD_INT 2
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: PUSH
75669: LD_INT 1
75671: NEG
75672: PUSH
75673: LD_INT 1
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 2
75682: NEG
75683: PUSH
75684: LD_INT 0
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 2
75693: NEG
75694: PUSH
75695: LD_INT 1
75697: NEG
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: LD_INT 2
75705: NEG
75706: PUSH
75707: LD_INT 2
75709: NEG
75710: PUSH
75711: EMPTY
75712: LIST
75713: LIST
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: LIST
75719: LIST
75720: LIST
75721: LIST
75722: LIST
75723: LIST
75724: LIST
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: LIST
75730: LIST
75731: LIST
75732: LIST
75733: LIST
75734: LIST
75735: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75736: LD_ADDR_VAR 0 59
75740: PUSH
75741: LD_INT 0
75743: PUSH
75744: LD_INT 0
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PUSH
75751: LD_INT 0
75753: PUSH
75754: LD_INT 1
75756: NEG
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PUSH
75762: LD_INT 1
75764: PUSH
75765: LD_INT 0
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 1
75774: PUSH
75775: LD_INT 1
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: PUSH
75782: LD_INT 0
75784: PUSH
75785: LD_INT 1
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: LD_INT 1
75794: NEG
75795: PUSH
75796: LD_INT 0
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PUSH
75803: LD_INT 1
75805: NEG
75806: PUSH
75807: LD_INT 1
75809: NEG
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: LIST
75819: LIST
75820: LIST
75821: LIST
75822: LIST
75823: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75824: LD_ADDR_VAR 0 60
75828: PUSH
75829: LD_INT 0
75831: PUSH
75832: LD_INT 0
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 0
75841: PUSH
75842: LD_INT 1
75844: NEG
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 1
75852: PUSH
75853: LD_INT 0
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: LD_INT 1
75862: PUSH
75863: LD_INT 1
75865: PUSH
75866: EMPTY
75867: LIST
75868: LIST
75869: PUSH
75870: LD_INT 0
75872: PUSH
75873: LD_INT 1
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: LD_INT 1
75882: NEG
75883: PUSH
75884: LD_INT 0
75886: PUSH
75887: EMPTY
75888: LIST
75889: LIST
75890: PUSH
75891: LD_INT 1
75893: NEG
75894: PUSH
75895: LD_INT 1
75897: NEG
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: LIST
75907: LIST
75908: LIST
75909: LIST
75910: LIST
75911: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75912: LD_ADDR_VAR 0 61
75916: PUSH
75917: LD_INT 0
75919: PUSH
75920: LD_INT 0
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: PUSH
75927: LD_INT 0
75929: PUSH
75930: LD_INT 1
75932: NEG
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 1
75940: PUSH
75941: LD_INT 0
75943: PUSH
75944: EMPTY
75945: LIST
75946: LIST
75947: PUSH
75948: LD_INT 1
75950: PUSH
75951: LD_INT 1
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: LD_INT 0
75960: PUSH
75961: LD_INT 1
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: PUSH
75968: LD_INT 1
75970: NEG
75971: PUSH
75972: LD_INT 0
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: LD_INT 1
75981: NEG
75982: PUSH
75983: LD_INT 1
75985: NEG
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: LIST
75995: LIST
75996: LIST
75997: LIST
75998: LIST
75999: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76000: LD_ADDR_VAR 0 62
76004: PUSH
76005: LD_INT 0
76007: PUSH
76008: LD_INT 0
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 0
76017: PUSH
76018: LD_INT 1
76020: NEG
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PUSH
76026: LD_INT 1
76028: PUSH
76029: LD_INT 0
76031: PUSH
76032: EMPTY
76033: LIST
76034: LIST
76035: PUSH
76036: LD_INT 1
76038: PUSH
76039: LD_INT 1
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: PUSH
76046: LD_INT 0
76048: PUSH
76049: LD_INT 1
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: LD_INT 1
76058: NEG
76059: PUSH
76060: LD_INT 0
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 1
76069: NEG
76070: PUSH
76071: LD_INT 1
76073: NEG
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: LIST
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76088: LD_ADDR_VAR 0 63
76092: PUSH
76093: LD_INT 0
76095: PUSH
76096: LD_INT 0
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 0
76105: PUSH
76106: LD_INT 1
76108: NEG
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: LD_INT 1
76116: PUSH
76117: LD_INT 0
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: LD_INT 1
76126: PUSH
76127: LD_INT 1
76129: PUSH
76130: EMPTY
76131: LIST
76132: LIST
76133: PUSH
76134: LD_INT 0
76136: PUSH
76137: LD_INT 1
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 1
76146: NEG
76147: PUSH
76148: LD_INT 0
76150: PUSH
76151: EMPTY
76152: LIST
76153: LIST
76154: PUSH
76155: LD_INT 1
76157: NEG
76158: PUSH
76159: LD_INT 1
76161: NEG
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: LIST
76171: LIST
76172: LIST
76173: LIST
76174: LIST
76175: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76176: LD_ADDR_VAR 0 64
76180: PUSH
76181: LD_INT 0
76183: PUSH
76184: LD_INT 0
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: PUSH
76191: LD_INT 0
76193: PUSH
76194: LD_INT 1
76196: NEG
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 1
76204: PUSH
76205: LD_INT 0
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: LD_INT 1
76214: PUSH
76215: LD_INT 1
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: PUSH
76222: LD_INT 0
76224: PUSH
76225: LD_INT 1
76227: PUSH
76228: EMPTY
76229: LIST
76230: LIST
76231: PUSH
76232: LD_INT 1
76234: NEG
76235: PUSH
76236: LD_INT 0
76238: PUSH
76239: EMPTY
76240: LIST
76241: LIST
76242: PUSH
76243: LD_INT 1
76245: NEG
76246: PUSH
76247: LD_INT 1
76249: NEG
76250: PUSH
76251: EMPTY
76252: LIST
76253: LIST
76254: PUSH
76255: EMPTY
76256: LIST
76257: LIST
76258: LIST
76259: LIST
76260: LIST
76261: LIST
76262: LIST
76263: ST_TO_ADDR
// end ; 1 :
76264: GO 82161
76266: LD_INT 1
76268: DOUBLE
76269: EQUAL
76270: IFTRUE 76274
76272: GO 78897
76274: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76275: LD_ADDR_VAR 0 11
76279: PUSH
76280: LD_INT 1
76282: NEG
76283: PUSH
76284: LD_INT 3
76286: NEG
76287: PUSH
76288: EMPTY
76289: LIST
76290: LIST
76291: PUSH
76292: LD_INT 0
76294: PUSH
76295: LD_INT 3
76297: NEG
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 1
76305: PUSH
76306: LD_INT 2
76308: NEG
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: EMPTY
76315: LIST
76316: LIST
76317: LIST
76318: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76319: LD_ADDR_VAR 0 12
76323: PUSH
76324: LD_INT 2
76326: PUSH
76327: LD_INT 1
76329: NEG
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: LD_INT 3
76337: PUSH
76338: LD_INT 0
76340: PUSH
76341: EMPTY
76342: LIST
76343: LIST
76344: PUSH
76345: LD_INT 3
76347: PUSH
76348: LD_INT 1
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: LIST
76359: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76360: LD_ADDR_VAR 0 13
76364: PUSH
76365: LD_INT 3
76367: PUSH
76368: LD_INT 2
76370: PUSH
76371: EMPTY
76372: LIST
76373: LIST
76374: PUSH
76375: LD_INT 3
76377: PUSH
76378: LD_INT 3
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: PUSH
76385: LD_INT 2
76387: PUSH
76388: LD_INT 3
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: LIST
76399: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76400: LD_ADDR_VAR 0 14
76404: PUSH
76405: LD_INT 1
76407: PUSH
76408: LD_INT 3
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: PUSH
76415: LD_INT 0
76417: PUSH
76418: LD_INT 3
76420: PUSH
76421: EMPTY
76422: LIST
76423: LIST
76424: PUSH
76425: LD_INT 1
76427: NEG
76428: PUSH
76429: LD_INT 2
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: LIST
76440: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76441: LD_ADDR_VAR 0 15
76445: PUSH
76446: LD_INT 2
76448: NEG
76449: PUSH
76450: LD_INT 1
76452: PUSH
76453: EMPTY
76454: LIST
76455: LIST
76456: PUSH
76457: LD_INT 3
76459: NEG
76460: PUSH
76461: LD_INT 0
76463: PUSH
76464: EMPTY
76465: LIST
76466: LIST
76467: PUSH
76468: LD_INT 3
76470: NEG
76471: PUSH
76472: LD_INT 1
76474: NEG
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: LIST
76484: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76485: LD_ADDR_VAR 0 16
76489: PUSH
76490: LD_INT 2
76492: NEG
76493: PUSH
76494: LD_INT 3
76496: NEG
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PUSH
76502: LD_INT 3
76504: NEG
76505: PUSH
76506: LD_INT 2
76508: NEG
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: PUSH
76514: LD_INT 3
76516: NEG
76517: PUSH
76518: LD_INT 3
76520: NEG
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: LIST
76530: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76531: LD_ADDR_VAR 0 17
76535: PUSH
76536: LD_INT 1
76538: NEG
76539: PUSH
76540: LD_INT 3
76542: NEG
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: PUSH
76548: LD_INT 0
76550: PUSH
76551: LD_INT 3
76553: NEG
76554: PUSH
76555: EMPTY
76556: LIST
76557: LIST
76558: PUSH
76559: LD_INT 1
76561: PUSH
76562: LD_INT 2
76564: NEG
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: LIST
76574: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76575: LD_ADDR_VAR 0 18
76579: PUSH
76580: LD_INT 2
76582: PUSH
76583: LD_INT 1
76585: NEG
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PUSH
76591: LD_INT 3
76593: PUSH
76594: LD_INT 0
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: LD_INT 3
76603: PUSH
76604: LD_INT 1
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: LIST
76615: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76616: LD_ADDR_VAR 0 19
76620: PUSH
76621: LD_INT 3
76623: PUSH
76624: LD_INT 2
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: LD_INT 3
76633: PUSH
76634: LD_INT 3
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 2
76643: PUSH
76644: LD_INT 3
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: LIST
76655: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76656: LD_ADDR_VAR 0 20
76660: PUSH
76661: LD_INT 1
76663: PUSH
76664: LD_INT 3
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PUSH
76671: LD_INT 0
76673: PUSH
76674: LD_INT 3
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PUSH
76681: LD_INT 1
76683: NEG
76684: PUSH
76685: LD_INT 2
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: LIST
76696: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76697: LD_ADDR_VAR 0 21
76701: PUSH
76702: LD_INT 2
76704: NEG
76705: PUSH
76706: LD_INT 1
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: LD_INT 3
76715: NEG
76716: PUSH
76717: LD_INT 0
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: LD_INT 3
76726: NEG
76727: PUSH
76728: LD_INT 1
76730: NEG
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: LIST
76740: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76741: LD_ADDR_VAR 0 22
76745: PUSH
76746: LD_INT 2
76748: NEG
76749: PUSH
76750: LD_INT 3
76752: NEG
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 3
76760: NEG
76761: PUSH
76762: LD_INT 2
76764: NEG
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: PUSH
76770: LD_INT 3
76772: NEG
76773: PUSH
76774: LD_INT 3
76776: NEG
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: LIST
76786: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76787: LD_ADDR_VAR 0 23
76791: PUSH
76792: LD_INT 0
76794: PUSH
76795: LD_INT 3
76797: NEG
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 1
76805: NEG
76806: PUSH
76807: LD_INT 4
76809: NEG
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 1
76817: PUSH
76818: LD_INT 3
76820: NEG
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: LIST
76830: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76831: LD_ADDR_VAR 0 24
76835: PUSH
76836: LD_INT 3
76838: PUSH
76839: LD_INT 0
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 3
76848: PUSH
76849: LD_INT 1
76851: NEG
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: PUSH
76857: LD_INT 4
76859: PUSH
76860: LD_INT 1
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: EMPTY
76868: LIST
76869: LIST
76870: LIST
76871: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76872: LD_ADDR_VAR 0 25
76876: PUSH
76877: LD_INT 3
76879: PUSH
76880: LD_INT 3
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: LD_INT 4
76889: PUSH
76890: LD_INT 3
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: PUSH
76897: LD_INT 3
76899: PUSH
76900: LD_INT 4
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: LIST
76911: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76912: LD_ADDR_VAR 0 26
76916: PUSH
76917: LD_INT 0
76919: PUSH
76920: LD_INT 3
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 1
76929: PUSH
76930: LD_INT 4
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 1
76939: NEG
76940: PUSH
76941: LD_INT 3
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: LIST
76952: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76953: LD_ADDR_VAR 0 27
76957: PUSH
76958: LD_INT 3
76960: NEG
76961: PUSH
76962: LD_INT 0
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 3
76971: NEG
76972: PUSH
76973: LD_INT 1
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 4
76982: NEG
76983: PUSH
76984: LD_INT 1
76986: NEG
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: LIST
76996: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76997: LD_ADDR_VAR 0 28
77001: PUSH
77002: LD_INT 3
77004: NEG
77005: PUSH
77006: LD_INT 3
77008: NEG
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 3
77016: NEG
77017: PUSH
77018: LD_INT 4
77020: NEG
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 4
77028: NEG
77029: PUSH
77030: LD_INT 3
77032: NEG
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: LIST
77042: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77043: LD_ADDR_VAR 0 29
77047: PUSH
77048: LD_INT 1
77050: NEG
77051: PUSH
77052: LD_INT 3
77054: NEG
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 0
77062: PUSH
77063: LD_INT 3
77065: NEG
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: PUSH
77071: LD_INT 1
77073: PUSH
77074: LD_INT 2
77076: NEG
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: PUSH
77082: LD_INT 1
77084: NEG
77085: PUSH
77086: LD_INT 4
77088: NEG
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: LD_INT 0
77096: PUSH
77097: LD_INT 4
77099: NEG
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PUSH
77105: LD_INT 1
77107: PUSH
77108: LD_INT 3
77110: NEG
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PUSH
77116: LD_INT 1
77118: NEG
77119: PUSH
77120: LD_INT 5
77122: NEG
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: PUSH
77128: LD_INT 0
77130: PUSH
77131: LD_INT 5
77133: NEG
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: PUSH
77139: LD_INT 1
77141: PUSH
77142: LD_INT 4
77144: NEG
77145: PUSH
77146: EMPTY
77147: LIST
77148: LIST
77149: PUSH
77150: LD_INT 1
77152: NEG
77153: PUSH
77154: LD_INT 6
77156: NEG
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: PUSH
77162: LD_INT 0
77164: PUSH
77165: LD_INT 6
77167: NEG
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PUSH
77173: LD_INT 1
77175: PUSH
77176: LD_INT 5
77178: NEG
77179: PUSH
77180: EMPTY
77181: LIST
77182: LIST
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: LIST
77188: LIST
77189: LIST
77190: LIST
77191: LIST
77192: LIST
77193: LIST
77194: LIST
77195: LIST
77196: LIST
77197: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77198: LD_ADDR_VAR 0 30
77202: PUSH
77203: LD_INT 2
77205: PUSH
77206: LD_INT 1
77208: NEG
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: LD_INT 3
77216: PUSH
77217: LD_INT 0
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PUSH
77224: LD_INT 3
77226: PUSH
77227: LD_INT 1
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 3
77236: PUSH
77237: LD_INT 1
77239: NEG
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 4
77247: PUSH
77248: LD_INT 0
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: PUSH
77255: LD_INT 4
77257: PUSH
77258: LD_INT 1
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 4
77267: PUSH
77268: LD_INT 1
77270: NEG
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 5
77278: PUSH
77279: LD_INT 0
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 5
77288: PUSH
77289: LD_INT 1
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 5
77298: PUSH
77299: LD_INT 1
77301: NEG
77302: PUSH
77303: EMPTY
77304: LIST
77305: LIST
77306: PUSH
77307: LD_INT 6
77309: PUSH
77310: LD_INT 0
77312: PUSH
77313: EMPTY
77314: LIST
77315: LIST
77316: PUSH
77317: LD_INT 6
77319: PUSH
77320: LD_INT 1
77322: PUSH
77323: EMPTY
77324: LIST
77325: LIST
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: LIST
77331: LIST
77332: LIST
77333: LIST
77334: LIST
77335: LIST
77336: LIST
77337: LIST
77338: LIST
77339: LIST
77340: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
77341: LD_ADDR_VAR 0 31
77345: PUSH
77346: LD_INT 3
77348: PUSH
77349: LD_INT 2
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: LD_INT 3
77358: PUSH
77359: LD_INT 3
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: PUSH
77366: LD_INT 2
77368: PUSH
77369: LD_INT 3
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: LD_INT 4
77378: PUSH
77379: LD_INT 3
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: LD_INT 4
77388: PUSH
77389: LD_INT 4
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: LD_INT 3
77398: PUSH
77399: LD_INT 4
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 5
77408: PUSH
77409: LD_INT 4
77411: PUSH
77412: EMPTY
77413: LIST
77414: LIST
77415: PUSH
77416: LD_INT 5
77418: PUSH
77419: LD_INT 5
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PUSH
77426: LD_INT 4
77428: PUSH
77429: LD_INT 5
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 6
77438: PUSH
77439: LD_INT 5
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PUSH
77446: LD_INT 6
77448: PUSH
77449: LD_INT 6
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: LD_INT 5
77458: PUSH
77459: LD_INT 6
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: LIST
77470: LIST
77471: LIST
77472: LIST
77473: LIST
77474: LIST
77475: LIST
77476: LIST
77477: LIST
77478: LIST
77479: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
77480: LD_ADDR_VAR 0 32
77484: PUSH
77485: LD_INT 1
77487: PUSH
77488: LD_INT 3
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 0
77497: PUSH
77498: LD_INT 3
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 1
77507: NEG
77508: PUSH
77509: LD_INT 2
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 1
77518: PUSH
77519: LD_INT 4
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: LD_INT 0
77528: PUSH
77529: LD_INT 4
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 1
77538: NEG
77539: PUSH
77540: LD_INT 3
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 1
77549: PUSH
77550: LD_INT 5
77552: PUSH
77553: EMPTY
77554: LIST
77555: LIST
77556: PUSH
77557: LD_INT 0
77559: PUSH
77560: LD_INT 5
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PUSH
77567: LD_INT 1
77569: NEG
77570: PUSH
77571: LD_INT 4
77573: PUSH
77574: EMPTY
77575: LIST
77576: LIST
77577: PUSH
77578: LD_INT 1
77580: PUSH
77581: LD_INT 6
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PUSH
77588: LD_INT 0
77590: PUSH
77591: LD_INT 6
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 1
77600: NEG
77601: PUSH
77602: LD_INT 5
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: EMPTY
77610: LIST
77611: LIST
77612: LIST
77613: LIST
77614: LIST
77615: LIST
77616: LIST
77617: LIST
77618: LIST
77619: LIST
77620: LIST
77621: LIST
77622: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77623: LD_ADDR_VAR 0 33
77627: PUSH
77628: LD_INT 2
77630: NEG
77631: PUSH
77632: LD_INT 1
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: PUSH
77639: LD_INT 3
77641: NEG
77642: PUSH
77643: LD_INT 0
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 3
77652: NEG
77653: PUSH
77654: LD_INT 1
77656: NEG
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: LD_INT 3
77664: NEG
77665: PUSH
77666: LD_INT 1
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 4
77675: NEG
77676: PUSH
77677: LD_INT 0
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PUSH
77684: LD_INT 4
77686: NEG
77687: PUSH
77688: LD_INT 1
77690: NEG
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 4
77698: NEG
77699: PUSH
77700: LD_INT 1
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PUSH
77707: LD_INT 5
77709: NEG
77710: PUSH
77711: LD_INT 0
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 5
77720: NEG
77721: PUSH
77722: LD_INT 1
77724: NEG
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: PUSH
77730: LD_INT 5
77732: NEG
77733: PUSH
77734: LD_INT 1
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: PUSH
77741: LD_INT 6
77743: NEG
77744: PUSH
77745: LD_INT 0
77747: PUSH
77748: EMPTY
77749: LIST
77750: LIST
77751: PUSH
77752: LD_INT 6
77754: NEG
77755: PUSH
77756: LD_INT 1
77758: NEG
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: LIST
77768: LIST
77769: LIST
77770: LIST
77771: LIST
77772: LIST
77773: LIST
77774: LIST
77775: LIST
77776: LIST
77777: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77778: LD_ADDR_VAR 0 34
77782: PUSH
77783: LD_INT 2
77785: NEG
77786: PUSH
77787: LD_INT 3
77789: NEG
77790: PUSH
77791: EMPTY
77792: LIST
77793: LIST
77794: PUSH
77795: LD_INT 3
77797: NEG
77798: PUSH
77799: LD_INT 2
77801: NEG
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 3
77809: NEG
77810: PUSH
77811: LD_INT 3
77813: NEG
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: LD_INT 3
77821: NEG
77822: PUSH
77823: LD_INT 4
77825: NEG
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 4
77833: NEG
77834: PUSH
77835: LD_INT 3
77837: NEG
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: LD_INT 4
77845: NEG
77846: PUSH
77847: LD_INT 4
77849: NEG
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 4
77857: NEG
77858: PUSH
77859: LD_INT 5
77861: NEG
77862: PUSH
77863: EMPTY
77864: LIST
77865: LIST
77866: PUSH
77867: LD_INT 5
77869: NEG
77870: PUSH
77871: LD_INT 4
77873: NEG
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 5
77881: NEG
77882: PUSH
77883: LD_INT 5
77885: NEG
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: PUSH
77891: LD_INT 5
77893: NEG
77894: PUSH
77895: LD_INT 6
77897: NEG
77898: PUSH
77899: EMPTY
77900: LIST
77901: LIST
77902: PUSH
77903: LD_INT 6
77905: NEG
77906: PUSH
77907: LD_INT 5
77909: NEG
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 6
77917: NEG
77918: PUSH
77919: LD_INT 6
77921: NEG
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: LIST
77931: LIST
77932: LIST
77933: LIST
77934: LIST
77935: LIST
77936: LIST
77937: LIST
77938: LIST
77939: LIST
77940: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77941: LD_ADDR_VAR 0 41
77945: PUSH
77946: LD_INT 0
77948: PUSH
77949: LD_INT 2
77951: NEG
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: PUSH
77957: LD_INT 1
77959: NEG
77960: PUSH
77961: LD_INT 3
77963: NEG
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 1
77971: PUSH
77972: LD_INT 2
77974: NEG
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: LIST
77984: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77985: LD_ADDR_VAR 0 42
77989: PUSH
77990: LD_INT 2
77992: PUSH
77993: LD_INT 0
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 2
78002: PUSH
78003: LD_INT 1
78005: NEG
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_INT 3
78013: PUSH
78014: LD_INT 1
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: LIST
78025: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78026: LD_ADDR_VAR 0 43
78030: PUSH
78031: LD_INT 2
78033: PUSH
78034: LD_INT 2
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 3
78043: PUSH
78044: LD_INT 2
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: LD_INT 2
78053: PUSH
78054: LD_INT 3
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: EMPTY
78062: LIST
78063: LIST
78064: LIST
78065: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78066: LD_ADDR_VAR 0 44
78070: PUSH
78071: LD_INT 0
78073: PUSH
78074: LD_INT 2
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: LD_INT 1
78083: PUSH
78084: LD_INT 3
78086: PUSH
78087: EMPTY
78088: LIST
78089: LIST
78090: PUSH
78091: LD_INT 1
78093: NEG
78094: PUSH
78095: LD_INT 2
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: LIST
78106: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78107: LD_ADDR_VAR 0 45
78111: PUSH
78112: LD_INT 2
78114: NEG
78115: PUSH
78116: LD_INT 0
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 2
78125: NEG
78126: PUSH
78127: LD_INT 1
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 3
78136: NEG
78137: PUSH
78138: LD_INT 1
78140: NEG
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: LIST
78150: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78151: LD_ADDR_VAR 0 46
78155: PUSH
78156: LD_INT 2
78158: NEG
78159: PUSH
78160: LD_INT 2
78162: NEG
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: PUSH
78168: LD_INT 2
78170: NEG
78171: PUSH
78172: LD_INT 3
78174: NEG
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 3
78182: NEG
78183: PUSH
78184: LD_INT 2
78186: NEG
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: LIST
78196: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78197: LD_ADDR_VAR 0 47
78201: PUSH
78202: LD_INT 2
78204: NEG
78205: PUSH
78206: LD_INT 3
78208: NEG
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PUSH
78214: LD_INT 1
78216: NEG
78217: PUSH
78218: LD_INT 3
78220: NEG
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78230: LD_ADDR_VAR 0 48
78234: PUSH
78235: LD_INT 1
78237: PUSH
78238: LD_INT 2
78240: NEG
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: PUSH
78246: LD_INT 2
78248: PUSH
78249: LD_INT 1
78251: NEG
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
78261: LD_ADDR_VAR 0 49
78265: PUSH
78266: LD_INT 3
78268: PUSH
78269: LD_INT 1
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 3
78278: PUSH
78279: LD_INT 2
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
78290: LD_ADDR_VAR 0 50
78294: PUSH
78295: LD_INT 2
78297: PUSH
78298: LD_INT 3
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: PUSH
78305: LD_INT 1
78307: PUSH
78308: LD_INT 3
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78319: LD_ADDR_VAR 0 51
78323: PUSH
78324: LD_INT 1
78326: NEG
78327: PUSH
78328: LD_INT 2
78330: PUSH
78331: EMPTY
78332: LIST
78333: LIST
78334: PUSH
78335: LD_INT 2
78337: NEG
78338: PUSH
78339: LD_INT 1
78341: PUSH
78342: EMPTY
78343: LIST
78344: LIST
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78350: LD_ADDR_VAR 0 52
78354: PUSH
78355: LD_INT 3
78357: NEG
78358: PUSH
78359: LD_INT 1
78361: NEG
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: PUSH
78367: LD_INT 3
78369: NEG
78370: PUSH
78371: LD_INT 2
78373: NEG
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78383: LD_ADDR_VAR 0 53
78387: PUSH
78388: LD_INT 1
78390: NEG
78391: PUSH
78392: LD_INT 3
78394: NEG
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: LD_INT 0
78402: PUSH
78403: LD_INT 3
78405: NEG
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 1
78413: PUSH
78414: LD_INT 2
78416: NEG
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: LIST
78426: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78427: LD_ADDR_VAR 0 54
78431: PUSH
78432: LD_INT 2
78434: PUSH
78435: LD_INT 1
78437: NEG
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: PUSH
78443: LD_INT 3
78445: PUSH
78446: LD_INT 0
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 3
78455: PUSH
78456: LD_INT 1
78458: PUSH
78459: EMPTY
78460: LIST
78461: LIST
78462: PUSH
78463: EMPTY
78464: LIST
78465: LIST
78466: LIST
78467: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78468: LD_ADDR_VAR 0 55
78472: PUSH
78473: LD_INT 3
78475: PUSH
78476: LD_INT 2
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: LD_INT 3
78485: PUSH
78486: LD_INT 3
78488: PUSH
78489: EMPTY
78490: LIST
78491: LIST
78492: PUSH
78493: LD_INT 2
78495: PUSH
78496: LD_INT 3
78498: PUSH
78499: EMPTY
78500: LIST
78501: LIST
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: LIST
78507: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78508: LD_ADDR_VAR 0 56
78512: PUSH
78513: LD_INT 1
78515: PUSH
78516: LD_INT 3
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: PUSH
78523: LD_INT 0
78525: PUSH
78526: LD_INT 3
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 1
78535: NEG
78536: PUSH
78537: LD_INT 2
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: PUSH
78544: EMPTY
78545: LIST
78546: LIST
78547: LIST
78548: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78549: LD_ADDR_VAR 0 57
78553: PUSH
78554: LD_INT 2
78556: NEG
78557: PUSH
78558: LD_INT 1
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 3
78567: NEG
78568: PUSH
78569: LD_INT 0
78571: PUSH
78572: EMPTY
78573: LIST
78574: LIST
78575: PUSH
78576: LD_INT 3
78578: NEG
78579: PUSH
78580: LD_INT 1
78582: NEG
78583: PUSH
78584: EMPTY
78585: LIST
78586: LIST
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: LIST
78592: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78593: LD_ADDR_VAR 0 58
78597: PUSH
78598: LD_INT 2
78600: NEG
78601: PUSH
78602: LD_INT 3
78604: NEG
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: PUSH
78610: LD_INT 3
78612: NEG
78613: PUSH
78614: LD_INT 2
78616: NEG
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 3
78624: NEG
78625: PUSH
78626: LD_INT 3
78628: NEG
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: LIST
78638: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78639: LD_ADDR_VAR 0 59
78643: PUSH
78644: LD_INT 1
78646: NEG
78647: PUSH
78648: LD_INT 2
78650: NEG
78651: PUSH
78652: EMPTY
78653: LIST
78654: LIST
78655: PUSH
78656: LD_INT 0
78658: PUSH
78659: LD_INT 2
78661: NEG
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: LD_INT 1
78669: PUSH
78670: LD_INT 1
78672: NEG
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: LIST
78682: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78683: LD_ADDR_VAR 0 60
78687: PUSH
78688: LD_INT 1
78690: PUSH
78691: LD_INT 1
78693: NEG
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: PUSH
78699: LD_INT 2
78701: PUSH
78702: LD_INT 0
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: PUSH
78709: LD_INT 2
78711: PUSH
78712: LD_INT 1
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: EMPTY
78720: LIST
78721: LIST
78722: LIST
78723: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78724: LD_ADDR_VAR 0 61
78728: PUSH
78729: LD_INT 2
78731: PUSH
78732: LD_INT 1
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: LD_INT 2
78741: PUSH
78742: LD_INT 2
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 1
78751: PUSH
78752: LD_INT 2
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: LIST
78763: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78764: LD_ADDR_VAR 0 62
78768: PUSH
78769: LD_INT 1
78771: PUSH
78772: LD_INT 2
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PUSH
78779: LD_INT 0
78781: PUSH
78782: LD_INT 2
78784: PUSH
78785: EMPTY
78786: LIST
78787: LIST
78788: PUSH
78789: LD_INT 1
78791: NEG
78792: PUSH
78793: LD_INT 1
78795: PUSH
78796: EMPTY
78797: LIST
78798: LIST
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: LIST
78804: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78805: LD_ADDR_VAR 0 63
78809: PUSH
78810: LD_INT 1
78812: NEG
78813: PUSH
78814: LD_INT 1
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PUSH
78821: LD_INT 2
78823: NEG
78824: PUSH
78825: LD_INT 0
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 2
78834: NEG
78835: PUSH
78836: LD_INT 1
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: LIST
78848: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78849: LD_ADDR_VAR 0 64
78853: PUSH
78854: LD_INT 1
78856: NEG
78857: PUSH
78858: LD_INT 2
78860: NEG
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 2
78868: NEG
78869: PUSH
78870: LD_INT 1
78872: NEG
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 2
78880: NEG
78881: PUSH
78882: LD_INT 2
78884: NEG
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: LIST
78894: ST_TO_ADDR
// end ; 2 :
78895: GO 82161
78897: LD_INT 2
78899: DOUBLE
78900: EQUAL
78901: IFTRUE 78905
78903: GO 82160
78905: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78906: LD_ADDR_VAR 0 29
78910: PUSH
78911: LD_INT 4
78913: PUSH
78914: LD_INT 0
78916: PUSH
78917: EMPTY
78918: LIST
78919: LIST
78920: PUSH
78921: LD_INT 4
78923: PUSH
78924: LD_INT 1
78926: NEG
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: PUSH
78932: LD_INT 5
78934: PUSH
78935: LD_INT 0
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: PUSH
78942: LD_INT 5
78944: PUSH
78945: LD_INT 1
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 4
78954: PUSH
78955: LD_INT 1
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: LD_INT 3
78964: PUSH
78965: LD_INT 0
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: LD_INT 3
78974: PUSH
78975: LD_INT 1
78977: NEG
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 3
78985: PUSH
78986: LD_INT 2
78988: NEG
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 5
78996: PUSH
78997: LD_INT 2
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: PUSH
79004: LD_INT 3
79006: PUSH
79007: LD_INT 3
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 3
79016: PUSH
79017: LD_INT 2
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 4
79026: PUSH
79027: LD_INT 3
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 4
79036: PUSH
79037: LD_INT 4
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 3
79046: PUSH
79047: LD_INT 4
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 2
79056: PUSH
79057: LD_INT 3
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 2
79066: PUSH
79067: LD_INT 2
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 4
79076: PUSH
79077: LD_INT 2
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 2
79086: PUSH
79087: LD_INT 4
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 0
79096: PUSH
79097: LD_INT 4
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 0
79106: PUSH
79107: LD_INT 3
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 1
79116: PUSH
79117: LD_INT 4
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 1
79126: PUSH
79127: LD_INT 5
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 0
79136: PUSH
79137: LD_INT 5
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 1
79146: NEG
79147: PUSH
79148: LD_INT 4
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: LD_INT 1
79157: NEG
79158: PUSH
79159: LD_INT 3
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: PUSH
79166: LD_INT 2
79168: PUSH
79169: LD_INT 5
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 2
79178: NEG
79179: PUSH
79180: LD_INT 3
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 3
79189: NEG
79190: PUSH
79191: LD_INT 0
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 3
79200: NEG
79201: PUSH
79202: LD_INT 1
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 2
79212: NEG
79213: PUSH
79214: LD_INT 0
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 2
79223: NEG
79224: PUSH
79225: LD_INT 1
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 3
79234: NEG
79235: PUSH
79236: LD_INT 1
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 4
79245: NEG
79246: PUSH
79247: LD_INT 0
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 4
79256: NEG
79257: PUSH
79258: LD_INT 1
79260: NEG
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 4
79268: NEG
79269: PUSH
79270: LD_INT 2
79272: NEG
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 2
79280: NEG
79281: PUSH
79282: LD_INT 2
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 4
79291: NEG
79292: PUSH
79293: LD_INT 4
79295: NEG
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PUSH
79301: LD_INT 4
79303: NEG
79304: PUSH
79305: LD_INT 5
79307: NEG
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 3
79315: NEG
79316: PUSH
79317: LD_INT 4
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 3
79327: NEG
79328: PUSH
79329: LD_INT 3
79331: NEG
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 4
79339: NEG
79340: PUSH
79341: LD_INT 3
79343: NEG
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 5
79351: NEG
79352: PUSH
79353: LD_INT 4
79355: NEG
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 5
79363: NEG
79364: PUSH
79365: LD_INT 5
79367: NEG
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: LD_INT 3
79375: NEG
79376: PUSH
79377: LD_INT 5
79379: NEG
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 5
79387: NEG
79388: PUSH
79389: LD_INT 3
79391: NEG
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: EMPTY
79398: LIST
79399: LIST
79400: LIST
79401: LIST
79402: LIST
79403: LIST
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
79444: LD_ADDR_VAR 0 30
79448: PUSH
79449: LD_INT 4
79451: PUSH
79452: LD_INT 4
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 4
79461: PUSH
79462: LD_INT 3
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 5
79471: PUSH
79472: LD_INT 4
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 5
79481: PUSH
79482: LD_INT 5
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 4
79491: PUSH
79492: LD_INT 5
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 3
79501: PUSH
79502: LD_INT 4
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: LD_INT 3
79511: PUSH
79512: LD_INT 3
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: PUSH
79519: LD_INT 5
79521: PUSH
79522: LD_INT 3
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 3
79531: PUSH
79532: LD_INT 5
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 0
79541: PUSH
79542: LD_INT 3
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 0
79551: PUSH
79552: LD_INT 2
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 1
79561: PUSH
79562: LD_INT 3
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 1
79571: PUSH
79572: LD_INT 4
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 0
79581: PUSH
79582: LD_INT 4
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 1
79591: NEG
79592: PUSH
79593: LD_INT 3
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: PUSH
79600: LD_INT 1
79602: NEG
79603: PUSH
79604: LD_INT 2
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: PUSH
79611: LD_INT 2
79613: PUSH
79614: LD_INT 4
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 2
79623: NEG
79624: PUSH
79625: LD_INT 2
79627: PUSH
79628: EMPTY
79629: LIST
79630: LIST
79631: PUSH
79632: LD_INT 4
79634: NEG
79635: PUSH
79636: LD_INT 0
79638: PUSH
79639: EMPTY
79640: LIST
79641: LIST
79642: PUSH
79643: LD_INT 4
79645: NEG
79646: PUSH
79647: LD_INT 1
79649: NEG
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: PUSH
79655: LD_INT 3
79657: NEG
79658: PUSH
79659: LD_INT 0
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: PUSH
79666: LD_INT 3
79668: NEG
79669: PUSH
79670: LD_INT 1
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_INT 4
79679: NEG
79680: PUSH
79681: LD_INT 1
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 5
79690: NEG
79691: PUSH
79692: LD_INT 0
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 5
79701: NEG
79702: PUSH
79703: LD_INT 1
79705: NEG
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 5
79713: NEG
79714: PUSH
79715: LD_INT 2
79717: NEG
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 3
79725: NEG
79726: PUSH
79727: LD_INT 2
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 3
79736: NEG
79737: PUSH
79738: LD_INT 3
79740: NEG
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 3
79748: NEG
79749: PUSH
79750: LD_INT 4
79752: NEG
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 2
79760: NEG
79761: PUSH
79762: LD_INT 3
79764: NEG
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 2
79772: NEG
79773: PUSH
79774: LD_INT 2
79776: NEG
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 3
79784: NEG
79785: PUSH
79786: LD_INT 2
79788: NEG
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 4
79796: NEG
79797: PUSH
79798: LD_INT 3
79800: NEG
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: LD_INT 4
79808: NEG
79809: PUSH
79810: LD_INT 4
79812: NEG
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 2
79820: NEG
79821: PUSH
79822: LD_INT 4
79824: NEG
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 4
79832: NEG
79833: PUSH
79834: LD_INT 2
79836: NEG
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_INT 0
79844: PUSH
79845: LD_INT 4
79847: NEG
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PUSH
79853: LD_INT 0
79855: PUSH
79856: LD_INT 5
79858: NEG
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: LD_INT 1
79866: PUSH
79867: LD_INT 4
79869: NEG
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: LD_INT 1
79877: PUSH
79878: LD_INT 3
79880: NEG
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 0
79888: PUSH
79889: LD_INT 3
79891: NEG
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: LD_INT 1
79899: NEG
79900: PUSH
79901: LD_INT 4
79903: NEG
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 1
79911: NEG
79912: PUSH
79913: LD_INT 5
79915: NEG
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: LD_INT 2
79923: PUSH
79924: LD_INT 3
79926: NEG
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: LD_INT 2
79934: NEG
79935: PUSH
79936: LD_INT 5
79938: NEG
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: LIST
79948: LIST
79949: LIST
79950: LIST
79951: LIST
79952: LIST
79953: LIST
79954: LIST
79955: LIST
79956: LIST
79957: LIST
79958: LIST
79959: LIST
79960: LIST
79961: LIST
79962: LIST
79963: LIST
79964: LIST
79965: LIST
79966: LIST
79967: LIST
79968: LIST
79969: LIST
79970: LIST
79971: LIST
79972: LIST
79973: LIST
79974: LIST
79975: LIST
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79991: LD_ADDR_VAR 0 31
79995: PUSH
79996: LD_INT 0
79998: PUSH
79999: LD_INT 4
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: PUSH
80006: LD_INT 0
80008: PUSH
80009: LD_INT 3
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 1
80018: PUSH
80019: LD_INT 4
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: LD_INT 5
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 0
80038: PUSH
80039: LD_INT 5
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 1
80048: NEG
80049: PUSH
80050: LD_INT 4
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: LD_INT 1
80059: NEG
80060: PUSH
80061: LD_INT 3
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 2
80070: PUSH
80071: LD_INT 5
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 2
80080: NEG
80081: PUSH
80082: LD_INT 3
80084: PUSH
80085: EMPTY
80086: LIST
80087: LIST
80088: PUSH
80089: LD_INT 3
80091: NEG
80092: PUSH
80093: LD_INT 0
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: PUSH
80100: LD_INT 3
80102: NEG
80103: PUSH
80104: LD_INT 1
80106: NEG
80107: PUSH
80108: EMPTY
80109: LIST
80110: LIST
80111: PUSH
80112: LD_INT 2
80114: NEG
80115: PUSH
80116: LD_INT 0
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PUSH
80123: LD_INT 2
80125: NEG
80126: PUSH
80127: LD_INT 1
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: PUSH
80134: LD_INT 3
80136: NEG
80137: PUSH
80138: LD_INT 1
80140: PUSH
80141: EMPTY
80142: LIST
80143: LIST
80144: PUSH
80145: LD_INT 4
80147: NEG
80148: PUSH
80149: LD_INT 0
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 4
80158: NEG
80159: PUSH
80160: LD_INT 1
80162: NEG
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: LD_INT 4
80170: NEG
80171: PUSH
80172: LD_INT 2
80174: NEG
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 2
80182: NEG
80183: PUSH
80184: LD_INT 2
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: LD_INT 4
80193: NEG
80194: PUSH
80195: LD_INT 4
80197: NEG
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 4
80205: NEG
80206: PUSH
80207: LD_INT 5
80209: NEG
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 3
80217: NEG
80218: PUSH
80219: LD_INT 4
80221: NEG
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 3
80229: NEG
80230: PUSH
80231: LD_INT 3
80233: NEG
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 4
80241: NEG
80242: PUSH
80243: LD_INT 3
80245: NEG
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: LD_INT 5
80253: NEG
80254: PUSH
80255: LD_INT 4
80257: NEG
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 5
80265: NEG
80266: PUSH
80267: LD_INT 5
80269: NEG
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 3
80277: NEG
80278: PUSH
80279: LD_INT 5
80281: NEG
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 5
80289: NEG
80290: PUSH
80291: LD_INT 3
80293: NEG
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 0
80301: PUSH
80302: LD_INT 3
80304: NEG
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 0
80312: PUSH
80313: LD_INT 4
80315: NEG
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PUSH
80321: LD_INT 1
80323: PUSH
80324: LD_INT 3
80326: NEG
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 1
80334: PUSH
80335: LD_INT 2
80337: NEG
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 0
80345: PUSH
80346: LD_INT 2
80348: NEG
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: PUSH
80354: LD_INT 1
80356: NEG
80357: PUSH
80358: LD_INT 3
80360: NEG
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 1
80368: NEG
80369: PUSH
80370: LD_INT 4
80372: NEG
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 2
80380: PUSH
80381: LD_INT 2
80383: NEG
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 2
80391: NEG
80392: PUSH
80393: LD_INT 4
80395: NEG
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 4
80403: PUSH
80404: LD_INT 0
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 4
80413: PUSH
80414: LD_INT 1
80416: NEG
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: LD_INT 5
80424: PUSH
80425: LD_INT 0
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 5
80434: PUSH
80435: LD_INT 1
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 4
80444: PUSH
80445: LD_INT 1
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: LD_INT 3
80454: PUSH
80455: LD_INT 0
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 3
80464: PUSH
80465: LD_INT 1
80467: NEG
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 3
80475: PUSH
80476: LD_INT 2
80478: NEG
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 5
80486: PUSH
80487: LD_INT 2
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: LIST
80498: LIST
80499: LIST
80500: LIST
80501: LIST
80502: LIST
80503: LIST
80504: LIST
80505: LIST
80506: LIST
80507: LIST
80508: LIST
80509: LIST
80510: LIST
80511: LIST
80512: LIST
80513: LIST
80514: LIST
80515: LIST
80516: LIST
80517: LIST
80518: LIST
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
80541: LD_ADDR_VAR 0 32
80545: PUSH
80546: LD_INT 4
80548: NEG
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 4
80559: NEG
80560: PUSH
80561: LD_INT 1
80563: NEG
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 3
80571: NEG
80572: PUSH
80573: LD_INT 0
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: LD_INT 3
80582: NEG
80583: PUSH
80584: LD_INT 1
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 4
80593: NEG
80594: PUSH
80595: LD_INT 1
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 5
80604: NEG
80605: PUSH
80606: LD_INT 0
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: PUSH
80613: LD_INT 5
80615: NEG
80616: PUSH
80617: LD_INT 1
80619: NEG
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: PUSH
80625: LD_INT 5
80627: NEG
80628: PUSH
80629: LD_INT 2
80631: NEG
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: LD_INT 3
80639: NEG
80640: PUSH
80641: LD_INT 2
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 3
80650: NEG
80651: PUSH
80652: LD_INT 3
80654: NEG
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 3
80662: NEG
80663: PUSH
80664: LD_INT 4
80666: NEG
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: LD_INT 2
80674: NEG
80675: PUSH
80676: LD_INT 3
80678: NEG
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: PUSH
80684: LD_INT 2
80686: NEG
80687: PUSH
80688: LD_INT 2
80690: NEG
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 3
80698: NEG
80699: PUSH
80700: LD_INT 2
80702: NEG
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: PUSH
80708: LD_INT 4
80710: NEG
80711: PUSH
80712: LD_INT 3
80714: NEG
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 4
80722: NEG
80723: PUSH
80724: LD_INT 4
80726: NEG
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 2
80734: NEG
80735: PUSH
80736: LD_INT 4
80738: NEG
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 4
80746: NEG
80747: PUSH
80748: LD_INT 2
80750: NEG
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: LD_INT 0
80758: PUSH
80759: LD_INT 4
80761: NEG
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 0
80769: PUSH
80770: LD_INT 5
80772: NEG
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: PUSH
80778: LD_INT 1
80780: PUSH
80781: LD_INT 4
80783: NEG
80784: PUSH
80785: EMPTY
80786: LIST
80787: LIST
80788: PUSH
80789: LD_INT 1
80791: PUSH
80792: LD_INT 3
80794: NEG
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: LD_INT 0
80802: PUSH
80803: LD_INT 3
80805: NEG
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: LD_INT 1
80813: NEG
80814: PUSH
80815: LD_INT 4
80817: NEG
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 1
80825: NEG
80826: PUSH
80827: LD_INT 5
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 2
80837: PUSH
80838: LD_INT 3
80840: NEG
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 2
80848: NEG
80849: PUSH
80850: LD_INT 5
80852: NEG
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 3
80860: PUSH
80861: LD_INT 0
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: LD_INT 3
80870: PUSH
80871: LD_INT 1
80873: NEG
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: PUSH
80879: LD_INT 4
80881: PUSH
80882: LD_INT 0
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 4
80891: PUSH
80892: LD_INT 1
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 3
80901: PUSH
80902: LD_INT 1
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PUSH
80909: LD_INT 2
80911: PUSH
80912: LD_INT 0
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: PUSH
80919: LD_INT 2
80921: PUSH
80922: LD_INT 1
80924: NEG
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 2
80932: PUSH
80933: LD_INT 2
80935: NEG
80936: PUSH
80937: EMPTY
80938: LIST
80939: LIST
80940: PUSH
80941: LD_INT 4
80943: PUSH
80944: LD_INT 2
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: LD_INT 4
80953: PUSH
80954: LD_INT 4
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 4
80963: PUSH
80964: LD_INT 3
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 5
80973: PUSH
80974: LD_INT 4
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 5
80983: PUSH
80984: LD_INT 5
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 4
80993: PUSH
80994: LD_INT 5
80996: PUSH
80997: EMPTY
80998: LIST
80999: LIST
81000: PUSH
81001: LD_INT 3
81003: PUSH
81004: LD_INT 4
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 3
81013: PUSH
81014: LD_INT 3
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 5
81023: PUSH
81024: LD_INT 3
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 3
81033: PUSH
81034: LD_INT 5
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81088: LD_ADDR_VAR 0 33
81092: PUSH
81093: LD_INT 4
81095: NEG
81096: PUSH
81097: LD_INT 4
81099: NEG
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 4
81107: NEG
81108: PUSH
81109: LD_INT 5
81111: NEG
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 3
81119: NEG
81120: PUSH
81121: LD_INT 4
81123: NEG
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: PUSH
81129: LD_INT 3
81131: NEG
81132: PUSH
81133: LD_INT 3
81135: NEG
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 4
81143: NEG
81144: PUSH
81145: LD_INT 3
81147: NEG
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 5
81155: NEG
81156: PUSH
81157: LD_INT 4
81159: NEG
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 5
81167: NEG
81168: PUSH
81169: LD_INT 5
81171: NEG
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 3
81179: NEG
81180: PUSH
81181: LD_INT 5
81183: NEG
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 5
81191: NEG
81192: PUSH
81193: LD_INT 3
81195: NEG
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: LD_INT 0
81203: PUSH
81204: LD_INT 3
81206: NEG
81207: PUSH
81208: EMPTY
81209: LIST
81210: LIST
81211: PUSH
81212: LD_INT 0
81214: PUSH
81215: LD_INT 4
81217: NEG
81218: PUSH
81219: EMPTY
81220: LIST
81221: LIST
81222: PUSH
81223: LD_INT 1
81225: PUSH
81226: LD_INT 3
81228: NEG
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: PUSH
81234: LD_INT 1
81236: PUSH
81237: LD_INT 2
81239: NEG
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PUSH
81245: LD_INT 0
81247: PUSH
81248: LD_INT 2
81250: NEG
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 1
81258: NEG
81259: PUSH
81260: LD_INT 3
81262: NEG
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 1
81270: NEG
81271: PUSH
81272: LD_INT 4
81274: NEG
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 2
81282: PUSH
81283: LD_INT 2
81285: NEG
81286: PUSH
81287: EMPTY
81288: LIST
81289: LIST
81290: PUSH
81291: LD_INT 2
81293: NEG
81294: PUSH
81295: LD_INT 4
81297: NEG
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: PUSH
81303: LD_INT 4
81305: PUSH
81306: LD_INT 0
81308: PUSH
81309: EMPTY
81310: LIST
81311: LIST
81312: PUSH
81313: LD_INT 4
81315: PUSH
81316: LD_INT 1
81318: NEG
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 5
81326: PUSH
81327: LD_INT 0
81329: PUSH
81330: EMPTY
81331: LIST
81332: LIST
81333: PUSH
81334: LD_INT 5
81336: PUSH
81337: LD_INT 1
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 4
81346: PUSH
81347: LD_INT 1
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 3
81356: PUSH
81357: LD_INT 0
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: PUSH
81364: LD_INT 3
81366: PUSH
81367: LD_INT 1
81369: NEG
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: PUSH
81375: LD_INT 3
81377: PUSH
81378: LD_INT 2
81380: NEG
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 5
81388: PUSH
81389: LD_INT 2
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 3
81398: PUSH
81399: LD_INT 3
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 3
81408: PUSH
81409: LD_INT 2
81411: PUSH
81412: EMPTY
81413: LIST
81414: LIST
81415: PUSH
81416: LD_INT 4
81418: PUSH
81419: LD_INT 3
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 4
81428: PUSH
81429: LD_INT 4
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: LD_INT 3
81438: PUSH
81439: LD_INT 4
81441: PUSH
81442: EMPTY
81443: LIST
81444: LIST
81445: PUSH
81446: LD_INT 2
81448: PUSH
81449: LD_INT 3
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 2
81458: PUSH
81459: LD_INT 2
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PUSH
81466: LD_INT 4
81468: PUSH
81469: LD_INT 2
81471: PUSH
81472: EMPTY
81473: LIST
81474: LIST
81475: PUSH
81476: LD_INT 2
81478: PUSH
81479: LD_INT 4
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: PUSH
81486: LD_INT 0
81488: PUSH
81489: LD_INT 4
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: PUSH
81496: LD_INT 0
81498: PUSH
81499: LD_INT 3
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: PUSH
81506: LD_INT 1
81508: PUSH
81509: LD_INT 4
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: PUSH
81516: LD_INT 1
81518: PUSH
81519: LD_INT 5
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 0
81528: PUSH
81529: LD_INT 5
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 1
81538: NEG
81539: PUSH
81540: LD_INT 4
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 1
81549: NEG
81550: PUSH
81551: LD_INT 3
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 2
81560: PUSH
81561: LD_INT 5
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: PUSH
81568: LD_INT 2
81570: NEG
81571: PUSH
81572: LD_INT 3
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: LIST
81585: LIST
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81626: LD_ADDR_VAR 0 34
81630: PUSH
81631: LD_INT 0
81633: PUSH
81634: LD_INT 4
81636: NEG
81637: PUSH
81638: EMPTY
81639: LIST
81640: LIST
81641: PUSH
81642: LD_INT 0
81644: PUSH
81645: LD_INT 5
81647: NEG
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 1
81655: PUSH
81656: LD_INT 4
81658: NEG
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: LD_INT 1
81666: PUSH
81667: LD_INT 3
81669: NEG
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: LD_INT 0
81677: PUSH
81678: LD_INT 3
81680: NEG
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: PUSH
81686: LD_INT 1
81688: NEG
81689: PUSH
81690: LD_INT 4
81692: NEG
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 1
81700: NEG
81701: PUSH
81702: LD_INT 5
81704: NEG
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 2
81712: PUSH
81713: LD_INT 3
81715: NEG
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 2
81723: NEG
81724: PUSH
81725: LD_INT 5
81727: NEG
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 3
81735: PUSH
81736: LD_INT 0
81738: PUSH
81739: EMPTY
81740: LIST
81741: LIST
81742: PUSH
81743: LD_INT 3
81745: PUSH
81746: LD_INT 1
81748: NEG
81749: PUSH
81750: EMPTY
81751: LIST
81752: LIST
81753: PUSH
81754: LD_INT 4
81756: PUSH
81757: LD_INT 0
81759: PUSH
81760: EMPTY
81761: LIST
81762: LIST
81763: PUSH
81764: LD_INT 4
81766: PUSH
81767: LD_INT 1
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PUSH
81774: LD_INT 3
81776: PUSH
81777: LD_INT 1
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: PUSH
81784: LD_INT 2
81786: PUSH
81787: LD_INT 0
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: PUSH
81794: LD_INT 2
81796: PUSH
81797: LD_INT 1
81799: NEG
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 2
81807: PUSH
81808: LD_INT 2
81810: NEG
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 4
81818: PUSH
81819: LD_INT 2
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 4
81828: PUSH
81829: LD_INT 4
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 4
81838: PUSH
81839: LD_INT 3
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 5
81848: PUSH
81849: LD_INT 4
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 5
81858: PUSH
81859: LD_INT 5
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 4
81868: PUSH
81869: LD_INT 5
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: PUSH
81876: LD_INT 3
81878: PUSH
81879: LD_INT 4
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 3
81888: PUSH
81889: LD_INT 3
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PUSH
81896: LD_INT 5
81898: PUSH
81899: LD_INT 3
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: PUSH
81906: LD_INT 3
81908: PUSH
81909: LD_INT 5
81911: PUSH
81912: EMPTY
81913: LIST
81914: LIST
81915: PUSH
81916: LD_INT 0
81918: PUSH
81919: LD_INT 3
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 0
81928: PUSH
81929: LD_INT 2
81931: PUSH
81932: EMPTY
81933: LIST
81934: LIST
81935: PUSH
81936: LD_INT 1
81938: PUSH
81939: LD_INT 3
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 1
81948: PUSH
81949: LD_INT 4
81951: PUSH
81952: EMPTY
81953: LIST
81954: LIST
81955: PUSH
81956: LD_INT 0
81958: PUSH
81959: LD_INT 4
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: PUSH
81966: LD_INT 1
81968: NEG
81969: PUSH
81970: LD_INT 3
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 1
81979: NEG
81980: PUSH
81981: LD_INT 2
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: LD_INT 2
81990: PUSH
81991: LD_INT 4
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PUSH
81998: LD_INT 2
82000: NEG
82001: PUSH
82002: LD_INT 2
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 4
82011: NEG
82012: PUSH
82013: LD_INT 0
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: PUSH
82020: LD_INT 4
82022: NEG
82023: PUSH
82024: LD_INT 1
82026: NEG
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 3
82034: NEG
82035: PUSH
82036: LD_INT 0
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: PUSH
82043: LD_INT 3
82045: NEG
82046: PUSH
82047: LD_INT 1
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PUSH
82054: LD_INT 4
82056: NEG
82057: PUSH
82058: LD_INT 1
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 5
82067: NEG
82068: PUSH
82069: LD_INT 0
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: LD_INT 5
82078: NEG
82079: PUSH
82080: LD_INT 1
82082: NEG
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 5
82090: NEG
82091: PUSH
82092: LD_INT 2
82094: NEG
82095: PUSH
82096: EMPTY
82097: LIST
82098: LIST
82099: PUSH
82100: LD_INT 3
82102: NEG
82103: PUSH
82104: LD_INT 2
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: LIST
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: LIST
82121: LIST
82122: LIST
82123: LIST
82124: LIST
82125: LIST
82126: LIST
82127: LIST
82128: LIST
82129: LIST
82130: LIST
82131: LIST
82132: LIST
82133: LIST
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: ST_TO_ADDR
// end ; end ;
82158: GO 82161
82160: POP
// case btype of b_depot , b_warehouse :
82161: LD_VAR 0 1
82165: PUSH
82166: LD_INT 0
82168: DOUBLE
82169: EQUAL
82170: IFTRUE 82180
82172: LD_INT 1
82174: DOUBLE
82175: EQUAL
82176: IFTRUE 82180
82178: GO 82381
82180: POP
// case nation of nation_american :
82181: LD_VAR 0 5
82185: PUSH
82186: LD_INT 1
82188: DOUBLE
82189: EQUAL
82190: IFTRUE 82194
82192: GO 82250
82194: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
82195: LD_ADDR_VAR 0 9
82199: PUSH
82200: LD_VAR 0 11
82204: PUSH
82205: LD_VAR 0 12
82209: PUSH
82210: LD_VAR 0 13
82214: PUSH
82215: LD_VAR 0 14
82219: PUSH
82220: LD_VAR 0 15
82224: PUSH
82225: LD_VAR 0 16
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: PUSH
82238: LD_VAR 0 4
82242: PUSH
82243: LD_INT 1
82245: PLUS
82246: ARRAY
82247: ST_TO_ADDR
82248: GO 82379
82250: LD_INT 2
82252: DOUBLE
82253: EQUAL
82254: IFTRUE 82258
82256: GO 82314
82258: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
82259: LD_ADDR_VAR 0 9
82263: PUSH
82264: LD_VAR 0 17
82268: PUSH
82269: LD_VAR 0 18
82273: PUSH
82274: LD_VAR 0 19
82278: PUSH
82279: LD_VAR 0 20
82283: PUSH
82284: LD_VAR 0 21
82288: PUSH
82289: LD_VAR 0 22
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: LIST
82298: LIST
82299: LIST
82300: LIST
82301: PUSH
82302: LD_VAR 0 4
82306: PUSH
82307: LD_INT 1
82309: PLUS
82310: ARRAY
82311: ST_TO_ADDR
82312: GO 82379
82314: LD_INT 3
82316: DOUBLE
82317: EQUAL
82318: IFTRUE 82322
82320: GO 82378
82322: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
82323: LD_ADDR_VAR 0 9
82327: PUSH
82328: LD_VAR 0 23
82332: PUSH
82333: LD_VAR 0 24
82337: PUSH
82338: LD_VAR 0 25
82342: PUSH
82343: LD_VAR 0 26
82347: PUSH
82348: LD_VAR 0 27
82352: PUSH
82353: LD_VAR 0 28
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: LIST
82362: LIST
82363: LIST
82364: LIST
82365: PUSH
82366: LD_VAR 0 4
82370: PUSH
82371: LD_INT 1
82373: PLUS
82374: ARRAY
82375: ST_TO_ADDR
82376: GO 82379
82378: POP
82379: GO 82934
82381: LD_INT 2
82383: DOUBLE
82384: EQUAL
82385: IFTRUE 82395
82387: LD_INT 3
82389: DOUBLE
82390: EQUAL
82391: IFTRUE 82395
82393: GO 82451
82395: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
82396: LD_ADDR_VAR 0 9
82400: PUSH
82401: LD_VAR 0 29
82405: PUSH
82406: LD_VAR 0 30
82410: PUSH
82411: LD_VAR 0 31
82415: PUSH
82416: LD_VAR 0 32
82420: PUSH
82421: LD_VAR 0 33
82425: PUSH
82426: LD_VAR 0 34
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: LIST
82437: LIST
82438: PUSH
82439: LD_VAR 0 4
82443: PUSH
82444: LD_INT 1
82446: PLUS
82447: ARRAY
82448: ST_TO_ADDR
82449: GO 82934
82451: LD_INT 16
82453: DOUBLE
82454: EQUAL
82455: IFTRUE 82513
82457: LD_INT 17
82459: DOUBLE
82460: EQUAL
82461: IFTRUE 82513
82463: LD_INT 18
82465: DOUBLE
82466: EQUAL
82467: IFTRUE 82513
82469: LD_INT 19
82471: DOUBLE
82472: EQUAL
82473: IFTRUE 82513
82475: LD_INT 22
82477: DOUBLE
82478: EQUAL
82479: IFTRUE 82513
82481: LD_INT 20
82483: DOUBLE
82484: EQUAL
82485: IFTRUE 82513
82487: LD_INT 21
82489: DOUBLE
82490: EQUAL
82491: IFTRUE 82513
82493: LD_INT 23
82495: DOUBLE
82496: EQUAL
82497: IFTRUE 82513
82499: LD_INT 24
82501: DOUBLE
82502: EQUAL
82503: IFTRUE 82513
82505: LD_INT 25
82507: DOUBLE
82508: EQUAL
82509: IFTRUE 82513
82511: GO 82569
82513: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
82514: LD_ADDR_VAR 0 9
82518: PUSH
82519: LD_VAR 0 35
82523: PUSH
82524: LD_VAR 0 36
82528: PUSH
82529: LD_VAR 0 37
82533: PUSH
82534: LD_VAR 0 38
82538: PUSH
82539: LD_VAR 0 39
82543: PUSH
82544: LD_VAR 0 40
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: PUSH
82557: LD_VAR 0 4
82561: PUSH
82562: LD_INT 1
82564: PLUS
82565: ARRAY
82566: ST_TO_ADDR
82567: GO 82934
82569: LD_INT 6
82571: DOUBLE
82572: EQUAL
82573: IFTRUE 82625
82575: LD_INT 7
82577: DOUBLE
82578: EQUAL
82579: IFTRUE 82625
82581: LD_INT 8
82583: DOUBLE
82584: EQUAL
82585: IFTRUE 82625
82587: LD_INT 13
82589: DOUBLE
82590: EQUAL
82591: IFTRUE 82625
82593: LD_INT 12
82595: DOUBLE
82596: EQUAL
82597: IFTRUE 82625
82599: LD_INT 15
82601: DOUBLE
82602: EQUAL
82603: IFTRUE 82625
82605: LD_INT 11
82607: DOUBLE
82608: EQUAL
82609: IFTRUE 82625
82611: LD_INT 14
82613: DOUBLE
82614: EQUAL
82615: IFTRUE 82625
82617: LD_INT 10
82619: DOUBLE
82620: EQUAL
82621: IFTRUE 82625
82623: GO 82681
82625: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
82626: LD_ADDR_VAR 0 9
82630: PUSH
82631: LD_VAR 0 41
82635: PUSH
82636: LD_VAR 0 42
82640: PUSH
82641: LD_VAR 0 43
82645: PUSH
82646: LD_VAR 0 44
82650: PUSH
82651: LD_VAR 0 45
82655: PUSH
82656: LD_VAR 0 46
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: PUSH
82669: LD_VAR 0 4
82673: PUSH
82674: LD_INT 1
82676: PLUS
82677: ARRAY
82678: ST_TO_ADDR
82679: GO 82934
82681: LD_INT 36
82683: DOUBLE
82684: EQUAL
82685: IFTRUE 82689
82687: GO 82745
82689: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82690: LD_ADDR_VAR 0 9
82694: PUSH
82695: LD_VAR 0 47
82699: PUSH
82700: LD_VAR 0 48
82704: PUSH
82705: LD_VAR 0 49
82709: PUSH
82710: LD_VAR 0 50
82714: PUSH
82715: LD_VAR 0 51
82719: PUSH
82720: LD_VAR 0 52
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: PUSH
82733: LD_VAR 0 4
82737: PUSH
82738: LD_INT 1
82740: PLUS
82741: ARRAY
82742: ST_TO_ADDR
82743: GO 82934
82745: LD_INT 4
82747: DOUBLE
82748: EQUAL
82749: IFTRUE 82771
82751: LD_INT 5
82753: DOUBLE
82754: EQUAL
82755: IFTRUE 82771
82757: LD_INT 34
82759: DOUBLE
82760: EQUAL
82761: IFTRUE 82771
82763: LD_INT 37
82765: DOUBLE
82766: EQUAL
82767: IFTRUE 82771
82769: GO 82827
82771: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82772: LD_ADDR_VAR 0 9
82776: PUSH
82777: LD_VAR 0 53
82781: PUSH
82782: LD_VAR 0 54
82786: PUSH
82787: LD_VAR 0 55
82791: PUSH
82792: LD_VAR 0 56
82796: PUSH
82797: LD_VAR 0 57
82801: PUSH
82802: LD_VAR 0 58
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: PUSH
82815: LD_VAR 0 4
82819: PUSH
82820: LD_INT 1
82822: PLUS
82823: ARRAY
82824: ST_TO_ADDR
82825: GO 82934
82827: LD_INT 31
82829: DOUBLE
82830: EQUAL
82831: IFTRUE 82877
82833: LD_INT 32
82835: DOUBLE
82836: EQUAL
82837: IFTRUE 82877
82839: LD_INT 33
82841: DOUBLE
82842: EQUAL
82843: IFTRUE 82877
82845: LD_INT 27
82847: DOUBLE
82848: EQUAL
82849: IFTRUE 82877
82851: LD_INT 26
82853: DOUBLE
82854: EQUAL
82855: IFTRUE 82877
82857: LD_INT 28
82859: DOUBLE
82860: EQUAL
82861: IFTRUE 82877
82863: LD_INT 29
82865: DOUBLE
82866: EQUAL
82867: IFTRUE 82877
82869: LD_INT 30
82871: DOUBLE
82872: EQUAL
82873: IFTRUE 82877
82875: GO 82933
82877: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
82878: LD_ADDR_VAR 0 9
82882: PUSH
82883: LD_VAR 0 59
82887: PUSH
82888: LD_VAR 0 60
82892: PUSH
82893: LD_VAR 0 61
82897: PUSH
82898: LD_VAR 0 62
82902: PUSH
82903: LD_VAR 0 63
82907: PUSH
82908: LD_VAR 0 64
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: PUSH
82921: LD_VAR 0 4
82925: PUSH
82926: LD_INT 1
82928: PLUS
82929: ARRAY
82930: ST_TO_ADDR
82931: GO 82934
82933: POP
// temp_list2 = [ ] ;
82934: LD_ADDR_VAR 0 10
82938: PUSH
82939: EMPTY
82940: ST_TO_ADDR
// for i in temp_list do
82941: LD_ADDR_VAR 0 8
82945: PUSH
82946: LD_VAR 0 9
82950: PUSH
82951: FOR_IN
82952: IFFALSE 83004
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82954: LD_ADDR_VAR 0 10
82958: PUSH
82959: LD_VAR 0 10
82963: PUSH
82964: LD_VAR 0 8
82968: PUSH
82969: LD_INT 1
82971: ARRAY
82972: PUSH
82973: LD_VAR 0 2
82977: PLUS
82978: PUSH
82979: LD_VAR 0 8
82983: PUSH
82984: LD_INT 2
82986: ARRAY
82987: PUSH
82988: LD_VAR 0 3
82992: PLUS
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: EMPTY
82999: LIST
83000: ADD
83001: ST_TO_ADDR
83002: GO 82951
83004: POP
83005: POP
// result = temp_list2 ;
83006: LD_ADDR_VAR 0 7
83010: PUSH
83011: LD_VAR 0 10
83015: ST_TO_ADDR
// end ;
83016: LD_VAR 0 7
83020: RET
// export function EnemyInRange ( unit , dist ) ; begin
83021: LD_INT 0
83023: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83024: LD_ADDR_VAR 0 3
83028: PUSH
83029: LD_VAR 0 1
83033: PPUSH
83034: CALL_OW 255
83038: PPUSH
83039: LD_VAR 0 1
83043: PPUSH
83044: CALL_OW 250
83048: PPUSH
83049: LD_VAR 0 1
83053: PPUSH
83054: CALL_OW 251
83058: PPUSH
83059: LD_VAR 0 2
83063: PPUSH
83064: CALL 57125 0 4
83068: PUSH
83069: LD_INT 4
83071: ARRAY
83072: ST_TO_ADDR
// end ;
83073: LD_VAR 0 3
83077: RET
// export function PlayerSeeMe ( unit ) ; begin
83078: LD_INT 0
83080: PPUSH
// result := See ( your_side , unit ) ;
83081: LD_ADDR_VAR 0 2
83085: PUSH
83086: LD_OWVAR 2
83090: PPUSH
83091: LD_VAR 0 1
83095: PPUSH
83096: CALL_OW 292
83100: ST_TO_ADDR
// end ;
83101: LD_VAR 0 2
83105: RET
// export function ReverseDir ( unit ) ; begin
83106: LD_INT 0
83108: PPUSH
// if not unit then
83109: LD_VAR 0 1
83113: NOT
83114: IFFALSE 83118
// exit ;
83116: GO 83164
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
83118: LD_ADDR_VAR 0 2
83122: PUSH
83123: LD_INT 3
83125: PUSH
83126: LD_INT 4
83128: PUSH
83129: LD_INT 5
83131: PUSH
83132: LD_INT 0
83134: PUSH
83135: LD_INT 1
83137: PUSH
83138: LD_INT 2
83140: PUSH
83141: EMPTY
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: PUSH
83149: LD_VAR 0 1
83153: PPUSH
83154: CALL_OW 254
83158: PUSH
83159: LD_INT 1
83161: PLUS
83162: ARRAY
83163: ST_TO_ADDR
// end ;
83164: LD_VAR 0 2
83168: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83169: LD_INT 0
83171: PPUSH
83172: PPUSH
83173: PPUSH
83174: PPUSH
83175: PPUSH
// if not hexes then
83176: LD_VAR 0 2
83180: NOT
83181: IFFALSE 83185
// exit ;
83183: GO 83333
// dist := 9999 ;
83185: LD_ADDR_VAR 0 5
83189: PUSH
83190: LD_INT 9999
83192: ST_TO_ADDR
// for i = 1 to hexes do
83193: LD_ADDR_VAR 0 4
83197: PUSH
83198: DOUBLE
83199: LD_INT 1
83201: DEC
83202: ST_TO_ADDR
83203: LD_VAR 0 2
83207: PUSH
83208: FOR_TO
83209: IFFALSE 83321
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83211: LD_VAR 0 1
83215: PPUSH
83216: LD_VAR 0 2
83220: PUSH
83221: LD_VAR 0 4
83225: ARRAY
83226: PUSH
83227: LD_INT 1
83229: ARRAY
83230: PPUSH
83231: LD_VAR 0 2
83235: PUSH
83236: LD_VAR 0 4
83240: ARRAY
83241: PUSH
83242: LD_INT 2
83244: ARRAY
83245: PPUSH
83246: CALL_OW 297
83250: PUSH
83251: LD_VAR 0 5
83255: LESS
83256: IFFALSE 83319
// begin hex := hexes [ i ] ;
83258: LD_ADDR_VAR 0 7
83262: PUSH
83263: LD_VAR 0 2
83267: PUSH
83268: LD_VAR 0 4
83272: ARRAY
83273: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83274: LD_ADDR_VAR 0 5
83278: PUSH
83279: LD_VAR 0 1
83283: PPUSH
83284: LD_VAR 0 2
83288: PUSH
83289: LD_VAR 0 4
83293: ARRAY
83294: PUSH
83295: LD_INT 1
83297: ARRAY
83298: PPUSH
83299: LD_VAR 0 2
83303: PUSH
83304: LD_VAR 0 4
83308: ARRAY
83309: PUSH
83310: LD_INT 2
83312: ARRAY
83313: PPUSH
83314: CALL_OW 297
83318: ST_TO_ADDR
// end ; end ;
83319: GO 83208
83321: POP
83322: POP
// result := hex ;
83323: LD_ADDR_VAR 0 3
83327: PUSH
83328: LD_VAR 0 7
83332: ST_TO_ADDR
// end ;
83333: LD_VAR 0 3
83337: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
83338: LD_INT 0
83340: PPUSH
83341: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83342: LD_VAR 0 1
83346: NOT
83347: PUSH
83348: LD_VAR 0 1
83352: PUSH
83353: LD_INT 21
83355: PUSH
83356: LD_INT 2
83358: PUSH
83359: EMPTY
83360: LIST
83361: LIST
83362: PUSH
83363: LD_INT 23
83365: PUSH
83366: LD_INT 2
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PPUSH
83377: CALL_OW 69
83381: IN
83382: NOT
83383: OR
83384: IFFALSE 83388
// exit ;
83386: GO 83435
// for i = 1 to 3 do
83388: LD_ADDR_VAR 0 3
83392: PUSH
83393: DOUBLE
83394: LD_INT 1
83396: DEC
83397: ST_TO_ADDR
83398: LD_INT 3
83400: PUSH
83401: FOR_TO
83402: IFFALSE 83433
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
83404: LD_VAR 0 1
83408: PPUSH
83409: CALL_OW 250
83413: PPUSH
83414: LD_VAR 0 1
83418: PPUSH
83419: CALL_OW 251
83423: PPUSH
83424: LD_INT 1
83426: PPUSH
83427: CALL_OW 453
83431: GO 83401
83433: POP
83434: POP
// end ;
83435: LD_VAR 0 2
83439: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
83440: LD_INT 0
83442: PPUSH
83443: PPUSH
83444: PPUSH
83445: PPUSH
83446: PPUSH
83447: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
83448: LD_VAR 0 1
83452: NOT
83453: PUSH
83454: LD_VAR 0 2
83458: NOT
83459: OR
83460: PUSH
83461: LD_VAR 0 1
83465: PPUSH
83466: CALL_OW 314
83470: OR
83471: IFFALSE 83475
// exit ;
83473: GO 83916
// x := GetX ( enemy_unit ) ;
83475: LD_ADDR_VAR 0 7
83479: PUSH
83480: LD_VAR 0 2
83484: PPUSH
83485: CALL_OW 250
83489: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
83490: LD_ADDR_VAR 0 8
83494: PUSH
83495: LD_VAR 0 2
83499: PPUSH
83500: CALL_OW 251
83504: ST_TO_ADDR
// if not x or not y then
83505: LD_VAR 0 7
83509: NOT
83510: PUSH
83511: LD_VAR 0 8
83515: NOT
83516: OR
83517: IFFALSE 83521
// exit ;
83519: GO 83916
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
83521: LD_ADDR_VAR 0 6
83525: PUSH
83526: LD_VAR 0 7
83530: PPUSH
83531: LD_INT 0
83533: PPUSH
83534: LD_INT 4
83536: PPUSH
83537: CALL_OW 272
83541: PUSH
83542: LD_VAR 0 8
83546: PPUSH
83547: LD_INT 0
83549: PPUSH
83550: LD_INT 4
83552: PPUSH
83553: CALL_OW 273
83557: PUSH
83558: EMPTY
83559: LIST
83560: LIST
83561: PUSH
83562: LD_VAR 0 7
83566: PPUSH
83567: LD_INT 1
83569: PPUSH
83570: LD_INT 4
83572: PPUSH
83573: CALL_OW 272
83577: PUSH
83578: LD_VAR 0 8
83582: PPUSH
83583: LD_INT 1
83585: PPUSH
83586: LD_INT 4
83588: PPUSH
83589: CALL_OW 273
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PUSH
83598: LD_VAR 0 7
83602: PPUSH
83603: LD_INT 2
83605: PPUSH
83606: LD_INT 4
83608: PPUSH
83609: CALL_OW 272
83613: PUSH
83614: LD_VAR 0 8
83618: PPUSH
83619: LD_INT 2
83621: PPUSH
83622: LD_INT 4
83624: PPUSH
83625: CALL_OW 273
83629: PUSH
83630: EMPTY
83631: LIST
83632: LIST
83633: PUSH
83634: LD_VAR 0 7
83638: PPUSH
83639: LD_INT 3
83641: PPUSH
83642: LD_INT 4
83644: PPUSH
83645: CALL_OW 272
83649: PUSH
83650: LD_VAR 0 8
83654: PPUSH
83655: LD_INT 3
83657: PPUSH
83658: LD_INT 4
83660: PPUSH
83661: CALL_OW 273
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_VAR 0 7
83674: PPUSH
83675: LD_INT 4
83677: PPUSH
83678: LD_INT 4
83680: PPUSH
83681: CALL_OW 272
83685: PUSH
83686: LD_VAR 0 8
83690: PPUSH
83691: LD_INT 4
83693: PPUSH
83694: LD_INT 4
83696: PPUSH
83697: CALL_OW 273
83701: PUSH
83702: EMPTY
83703: LIST
83704: LIST
83705: PUSH
83706: LD_VAR 0 7
83710: PPUSH
83711: LD_INT 5
83713: PPUSH
83714: LD_INT 4
83716: PPUSH
83717: CALL_OW 272
83721: PUSH
83722: LD_VAR 0 8
83726: PPUSH
83727: LD_INT 5
83729: PPUSH
83730: LD_INT 4
83732: PPUSH
83733: CALL_OW 273
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: ST_TO_ADDR
// for i = tmp downto 1 do
83750: LD_ADDR_VAR 0 4
83754: PUSH
83755: DOUBLE
83756: LD_VAR 0 6
83760: INC
83761: ST_TO_ADDR
83762: LD_INT 1
83764: PUSH
83765: FOR_DOWNTO
83766: IFFALSE 83867
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83768: LD_VAR 0 6
83772: PUSH
83773: LD_VAR 0 4
83777: ARRAY
83778: PUSH
83779: LD_INT 1
83781: ARRAY
83782: PPUSH
83783: LD_VAR 0 6
83787: PUSH
83788: LD_VAR 0 4
83792: ARRAY
83793: PUSH
83794: LD_INT 2
83796: ARRAY
83797: PPUSH
83798: CALL_OW 488
83802: NOT
83803: PUSH
83804: LD_VAR 0 6
83808: PUSH
83809: LD_VAR 0 4
83813: ARRAY
83814: PUSH
83815: LD_INT 1
83817: ARRAY
83818: PPUSH
83819: LD_VAR 0 6
83823: PUSH
83824: LD_VAR 0 4
83828: ARRAY
83829: PUSH
83830: LD_INT 2
83832: ARRAY
83833: PPUSH
83834: CALL_OW 428
83838: PUSH
83839: LD_INT 0
83841: NONEQUAL
83842: OR
83843: IFFALSE 83865
// tmp := Delete ( tmp , i ) ;
83845: LD_ADDR_VAR 0 6
83849: PUSH
83850: LD_VAR 0 6
83854: PPUSH
83855: LD_VAR 0 4
83859: PPUSH
83860: CALL_OW 3
83864: ST_TO_ADDR
83865: GO 83765
83867: POP
83868: POP
// j := GetClosestHex ( unit , tmp ) ;
83869: LD_ADDR_VAR 0 5
83873: PUSH
83874: LD_VAR 0 1
83878: PPUSH
83879: LD_VAR 0 6
83883: PPUSH
83884: CALL 83169 0 2
83888: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83889: LD_VAR 0 1
83893: PPUSH
83894: LD_VAR 0 5
83898: PUSH
83899: LD_INT 1
83901: ARRAY
83902: PPUSH
83903: LD_VAR 0 5
83907: PUSH
83908: LD_INT 2
83910: ARRAY
83911: PPUSH
83912: CALL_OW 111
// end ;
83916: LD_VAR 0 3
83920: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83921: LD_INT 0
83923: PPUSH
83924: PPUSH
83925: PPUSH
// uc_side = 0 ;
83926: LD_ADDR_OWVAR 20
83930: PUSH
83931: LD_INT 0
83933: ST_TO_ADDR
// uc_nation = 0 ;
83934: LD_ADDR_OWVAR 21
83938: PUSH
83939: LD_INT 0
83941: ST_TO_ADDR
// InitHc ;
83942: CALL_OW 19
// InitVc ;
83946: CALL_OW 20
// if mastodonts then
83950: LD_VAR 0 6
83954: IFFALSE 84021
// for i = 1 to mastodonts do
83956: LD_ADDR_VAR 0 11
83960: PUSH
83961: DOUBLE
83962: LD_INT 1
83964: DEC
83965: ST_TO_ADDR
83966: LD_VAR 0 6
83970: PUSH
83971: FOR_TO
83972: IFFALSE 84019
// begin vc_chassis := 31 ;
83974: LD_ADDR_OWVAR 37
83978: PUSH
83979: LD_INT 31
83981: ST_TO_ADDR
// vc_control := control_rider ;
83982: LD_ADDR_OWVAR 38
83986: PUSH
83987: LD_INT 4
83989: ST_TO_ADDR
// animal := CreateVehicle ;
83990: LD_ADDR_VAR 0 12
83994: PUSH
83995: CALL_OW 45
83999: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84000: LD_VAR 0 12
84004: PPUSH
84005: LD_VAR 0 8
84009: PPUSH
84010: LD_INT 0
84012: PPUSH
84013: CALL 90766 0 3
// end ;
84017: GO 83971
84019: POP
84020: POP
// if horses then
84021: LD_VAR 0 5
84025: IFFALSE 84092
// for i = 1 to horses do
84027: LD_ADDR_VAR 0 11
84031: PUSH
84032: DOUBLE
84033: LD_INT 1
84035: DEC
84036: ST_TO_ADDR
84037: LD_VAR 0 5
84041: PUSH
84042: FOR_TO
84043: IFFALSE 84090
// begin hc_class := 21 ;
84045: LD_ADDR_OWVAR 28
84049: PUSH
84050: LD_INT 21
84052: ST_TO_ADDR
// hc_gallery :=  ;
84053: LD_ADDR_OWVAR 33
84057: PUSH
84058: LD_STRING 
84060: ST_TO_ADDR
// animal := CreateHuman ;
84061: LD_ADDR_VAR 0 12
84065: PUSH
84066: CALL_OW 44
84070: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84071: LD_VAR 0 12
84075: PPUSH
84076: LD_VAR 0 8
84080: PPUSH
84081: LD_INT 0
84083: PPUSH
84084: CALL 90766 0 3
// end ;
84088: GO 84042
84090: POP
84091: POP
// if birds then
84092: LD_VAR 0 1
84096: IFFALSE 84163
// for i = 1 to birds do
84098: LD_ADDR_VAR 0 11
84102: PUSH
84103: DOUBLE
84104: LD_INT 1
84106: DEC
84107: ST_TO_ADDR
84108: LD_VAR 0 1
84112: PUSH
84113: FOR_TO
84114: IFFALSE 84161
// begin hc_class = 18 ;
84116: LD_ADDR_OWVAR 28
84120: PUSH
84121: LD_INT 18
84123: ST_TO_ADDR
// hc_gallery =  ;
84124: LD_ADDR_OWVAR 33
84128: PUSH
84129: LD_STRING 
84131: ST_TO_ADDR
// animal := CreateHuman ;
84132: LD_ADDR_VAR 0 12
84136: PUSH
84137: CALL_OW 44
84141: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84142: LD_VAR 0 12
84146: PPUSH
84147: LD_VAR 0 8
84151: PPUSH
84152: LD_INT 0
84154: PPUSH
84155: CALL 90766 0 3
// end ;
84159: GO 84113
84161: POP
84162: POP
// if tigers then
84163: LD_VAR 0 2
84167: IFFALSE 84251
// for i = 1 to tigers do
84169: LD_ADDR_VAR 0 11
84173: PUSH
84174: DOUBLE
84175: LD_INT 1
84177: DEC
84178: ST_TO_ADDR
84179: LD_VAR 0 2
84183: PUSH
84184: FOR_TO
84185: IFFALSE 84249
// begin hc_class = class_tiger ;
84187: LD_ADDR_OWVAR 28
84191: PUSH
84192: LD_INT 14
84194: ST_TO_ADDR
// hc_gallery =  ;
84195: LD_ADDR_OWVAR 33
84199: PUSH
84200: LD_STRING 
84202: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84203: LD_ADDR_OWVAR 35
84207: PUSH
84208: LD_INT 7
84210: NEG
84211: PPUSH
84212: LD_INT 7
84214: PPUSH
84215: CALL_OW 12
84219: ST_TO_ADDR
// animal := CreateHuman ;
84220: LD_ADDR_VAR 0 12
84224: PUSH
84225: CALL_OW 44
84229: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84230: LD_VAR 0 12
84234: PPUSH
84235: LD_VAR 0 8
84239: PPUSH
84240: LD_INT 0
84242: PPUSH
84243: CALL 90766 0 3
// end ;
84247: GO 84184
84249: POP
84250: POP
// if apemans then
84251: LD_VAR 0 3
84255: IFFALSE 84378
// for i = 1 to apemans do
84257: LD_ADDR_VAR 0 11
84261: PUSH
84262: DOUBLE
84263: LD_INT 1
84265: DEC
84266: ST_TO_ADDR
84267: LD_VAR 0 3
84271: PUSH
84272: FOR_TO
84273: IFFALSE 84376
// begin hc_class = class_apeman ;
84275: LD_ADDR_OWVAR 28
84279: PUSH
84280: LD_INT 12
84282: ST_TO_ADDR
// hc_gallery =  ;
84283: LD_ADDR_OWVAR 33
84287: PUSH
84288: LD_STRING 
84290: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
84291: LD_ADDR_OWVAR 35
84295: PUSH
84296: LD_INT 5
84298: NEG
84299: PPUSH
84300: LD_INT 5
84302: PPUSH
84303: CALL_OW 12
84307: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
84308: LD_ADDR_OWVAR 31
84312: PUSH
84313: LD_INT 1
84315: PPUSH
84316: LD_INT 3
84318: PPUSH
84319: CALL_OW 12
84323: PUSH
84324: LD_INT 1
84326: PPUSH
84327: LD_INT 3
84329: PPUSH
84330: CALL_OW 12
84334: PUSH
84335: LD_INT 0
84337: PUSH
84338: LD_INT 0
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: LIST
84345: LIST
84346: ST_TO_ADDR
// animal := CreateHuman ;
84347: LD_ADDR_VAR 0 12
84351: PUSH
84352: CALL_OW 44
84356: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84357: LD_VAR 0 12
84361: PPUSH
84362: LD_VAR 0 8
84366: PPUSH
84367: LD_INT 0
84369: PPUSH
84370: CALL 90766 0 3
// end ;
84374: GO 84272
84376: POP
84377: POP
// if enchidnas then
84378: LD_VAR 0 4
84382: IFFALSE 84449
// for i = 1 to enchidnas do
84384: LD_ADDR_VAR 0 11
84388: PUSH
84389: DOUBLE
84390: LD_INT 1
84392: DEC
84393: ST_TO_ADDR
84394: LD_VAR 0 4
84398: PUSH
84399: FOR_TO
84400: IFFALSE 84447
// begin hc_class = 13 ;
84402: LD_ADDR_OWVAR 28
84406: PUSH
84407: LD_INT 13
84409: ST_TO_ADDR
// hc_gallery =  ;
84410: LD_ADDR_OWVAR 33
84414: PUSH
84415: LD_STRING 
84417: ST_TO_ADDR
// animal := CreateHuman ;
84418: LD_ADDR_VAR 0 12
84422: PUSH
84423: CALL_OW 44
84427: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84428: LD_VAR 0 12
84432: PPUSH
84433: LD_VAR 0 8
84437: PPUSH
84438: LD_INT 0
84440: PPUSH
84441: CALL 90766 0 3
// end ;
84445: GO 84399
84447: POP
84448: POP
// if fishes then
84449: LD_VAR 0 7
84453: IFFALSE 84520
// for i = 1 to fishes do
84455: LD_ADDR_VAR 0 11
84459: PUSH
84460: DOUBLE
84461: LD_INT 1
84463: DEC
84464: ST_TO_ADDR
84465: LD_VAR 0 7
84469: PUSH
84470: FOR_TO
84471: IFFALSE 84518
// begin hc_class = 20 ;
84473: LD_ADDR_OWVAR 28
84477: PUSH
84478: LD_INT 20
84480: ST_TO_ADDR
// hc_gallery =  ;
84481: LD_ADDR_OWVAR 33
84485: PUSH
84486: LD_STRING 
84488: ST_TO_ADDR
// animal := CreateHuman ;
84489: LD_ADDR_VAR 0 12
84493: PUSH
84494: CALL_OW 44
84498: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84499: LD_VAR 0 12
84503: PPUSH
84504: LD_VAR 0 9
84508: PPUSH
84509: LD_INT 0
84511: PPUSH
84512: CALL 90766 0 3
// end ;
84516: GO 84470
84518: POP
84519: POP
// end ;
84520: LD_VAR 0 10
84524: RET
// export function WantHeal ( sci , unit ) ; begin
84525: LD_INT 0
84527: PPUSH
// if GetTaskList ( sci ) > 0 then
84528: LD_VAR 0 1
84532: PPUSH
84533: CALL_OW 437
84537: PUSH
84538: LD_INT 0
84540: GREATER
84541: IFFALSE 84611
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84543: LD_VAR 0 1
84547: PPUSH
84548: CALL_OW 437
84552: PUSH
84553: LD_INT 1
84555: ARRAY
84556: PUSH
84557: LD_INT 1
84559: ARRAY
84560: PUSH
84561: LD_STRING l
84563: EQUAL
84564: PUSH
84565: LD_VAR 0 1
84569: PPUSH
84570: CALL_OW 437
84574: PUSH
84575: LD_INT 1
84577: ARRAY
84578: PUSH
84579: LD_INT 4
84581: ARRAY
84582: PUSH
84583: LD_VAR 0 2
84587: EQUAL
84588: AND
84589: IFFALSE 84601
// result := true else
84591: LD_ADDR_VAR 0 3
84595: PUSH
84596: LD_INT 1
84598: ST_TO_ADDR
84599: GO 84609
// result := false ;
84601: LD_ADDR_VAR 0 3
84605: PUSH
84606: LD_INT 0
84608: ST_TO_ADDR
// end else
84609: GO 84619
// result := false ;
84611: LD_ADDR_VAR 0 3
84615: PUSH
84616: LD_INT 0
84618: ST_TO_ADDR
// end ;
84619: LD_VAR 0 3
84623: RET
// export function HealTarget ( sci ) ; begin
84624: LD_INT 0
84626: PPUSH
// if not sci then
84627: LD_VAR 0 1
84631: NOT
84632: IFFALSE 84636
// exit ;
84634: GO 84701
// result := 0 ;
84636: LD_ADDR_VAR 0 2
84640: PUSH
84641: LD_INT 0
84643: ST_TO_ADDR
// if GetTaskList ( sci ) then
84644: LD_VAR 0 1
84648: PPUSH
84649: CALL_OW 437
84653: IFFALSE 84701
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84655: LD_VAR 0 1
84659: PPUSH
84660: CALL_OW 437
84664: PUSH
84665: LD_INT 1
84667: ARRAY
84668: PUSH
84669: LD_INT 1
84671: ARRAY
84672: PUSH
84673: LD_STRING l
84675: EQUAL
84676: IFFALSE 84701
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84678: LD_ADDR_VAR 0 2
84682: PUSH
84683: LD_VAR 0 1
84687: PPUSH
84688: CALL_OW 437
84692: PUSH
84693: LD_INT 1
84695: ARRAY
84696: PUSH
84697: LD_INT 4
84699: ARRAY
84700: ST_TO_ADDR
// end ;
84701: LD_VAR 0 2
84705: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
84706: LD_INT 0
84708: PPUSH
84709: PPUSH
84710: PPUSH
84711: PPUSH
84712: PPUSH
84713: PPUSH
84714: PPUSH
84715: PPUSH
84716: PPUSH
84717: PPUSH
84718: PPUSH
84719: PPUSH
84720: PPUSH
84721: PPUSH
84722: PPUSH
84723: PPUSH
84724: PPUSH
84725: PPUSH
84726: PPUSH
84727: PPUSH
84728: PPUSH
84729: PPUSH
84730: PPUSH
84731: PPUSH
84732: PPUSH
84733: PPUSH
84734: PPUSH
84735: PPUSH
84736: PPUSH
84737: PPUSH
84738: PPUSH
84739: PPUSH
84740: PPUSH
84741: PPUSH
// if not list then
84742: LD_VAR 0 1
84746: NOT
84747: IFFALSE 84751
// exit ;
84749: GO 89377
// base := list [ 1 ] ;
84751: LD_ADDR_VAR 0 3
84755: PUSH
84756: LD_VAR 0 1
84760: PUSH
84761: LD_INT 1
84763: ARRAY
84764: ST_TO_ADDR
// group := list [ 2 ] ;
84765: LD_ADDR_VAR 0 4
84769: PUSH
84770: LD_VAR 0 1
84774: PUSH
84775: LD_INT 2
84777: ARRAY
84778: ST_TO_ADDR
// path := list [ 3 ] ;
84779: LD_ADDR_VAR 0 5
84783: PUSH
84784: LD_VAR 0 1
84788: PUSH
84789: LD_INT 3
84791: ARRAY
84792: ST_TO_ADDR
// flags := list [ 4 ] ;
84793: LD_ADDR_VAR 0 6
84797: PUSH
84798: LD_VAR 0 1
84802: PUSH
84803: LD_INT 4
84805: ARRAY
84806: ST_TO_ADDR
// mined := [ ] ;
84807: LD_ADDR_VAR 0 27
84811: PUSH
84812: EMPTY
84813: ST_TO_ADDR
// bombed := [ ] ;
84814: LD_ADDR_VAR 0 28
84818: PUSH
84819: EMPTY
84820: ST_TO_ADDR
// healers := [ ] ;
84821: LD_ADDR_VAR 0 31
84825: PUSH
84826: EMPTY
84827: ST_TO_ADDR
// to_heal := [ ] ;
84828: LD_ADDR_VAR 0 30
84832: PUSH
84833: EMPTY
84834: ST_TO_ADDR
// repairs := [ ] ;
84835: LD_ADDR_VAR 0 33
84839: PUSH
84840: EMPTY
84841: ST_TO_ADDR
// to_repair := [ ] ;
84842: LD_ADDR_VAR 0 32
84846: PUSH
84847: EMPTY
84848: ST_TO_ADDR
// if not group or not path then
84849: LD_VAR 0 4
84853: NOT
84854: PUSH
84855: LD_VAR 0 5
84859: NOT
84860: OR
84861: IFFALSE 84865
// exit ;
84863: GO 89377
// side := GetSide ( group [ 1 ] ) ;
84865: LD_ADDR_VAR 0 35
84869: PUSH
84870: LD_VAR 0 4
84874: PUSH
84875: LD_INT 1
84877: ARRAY
84878: PPUSH
84879: CALL_OW 255
84883: ST_TO_ADDR
// if flags then
84884: LD_VAR 0 6
84888: IFFALSE 85032
// begin f_ignore_area := flags [ 1 ] ;
84890: LD_ADDR_VAR 0 17
84894: PUSH
84895: LD_VAR 0 6
84899: PUSH
84900: LD_INT 1
84902: ARRAY
84903: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
84904: LD_ADDR_VAR 0 18
84908: PUSH
84909: LD_VAR 0 6
84913: PUSH
84914: LD_INT 2
84916: ARRAY
84917: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
84918: LD_ADDR_VAR 0 19
84922: PUSH
84923: LD_VAR 0 6
84927: PUSH
84928: LD_INT 3
84930: ARRAY
84931: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
84932: LD_ADDR_VAR 0 20
84936: PUSH
84937: LD_VAR 0 6
84941: PUSH
84942: LD_INT 4
84944: ARRAY
84945: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
84946: LD_ADDR_VAR 0 21
84950: PUSH
84951: LD_VAR 0 6
84955: PUSH
84956: LD_INT 5
84958: ARRAY
84959: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
84960: LD_ADDR_VAR 0 22
84964: PUSH
84965: LD_VAR 0 6
84969: PUSH
84970: LD_INT 6
84972: ARRAY
84973: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
84974: LD_ADDR_VAR 0 23
84978: PUSH
84979: LD_VAR 0 6
84983: PUSH
84984: LD_INT 7
84986: ARRAY
84987: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
84988: LD_ADDR_VAR 0 24
84992: PUSH
84993: LD_VAR 0 6
84997: PUSH
84998: LD_INT 8
85000: ARRAY
85001: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
85002: LD_ADDR_VAR 0 25
85006: PUSH
85007: LD_VAR 0 6
85011: PUSH
85012: LD_INT 9
85014: ARRAY
85015: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
85016: LD_ADDR_VAR 0 26
85020: PUSH
85021: LD_VAR 0 6
85025: PUSH
85026: LD_INT 10
85028: ARRAY
85029: ST_TO_ADDR
// end else
85030: GO 85112
// begin f_ignore_area := false ;
85032: LD_ADDR_VAR 0 17
85036: PUSH
85037: LD_INT 0
85039: ST_TO_ADDR
// f_capture := false ;
85040: LD_ADDR_VAR 0 18
85044: PUSH
85045: LD_INT 0
85047: ST_TO_ADDR
// f_ignore_civ := false ;
85048: LD_ADDR_VAR 0 19
85052: PUSH
85053: LD_INT 0
85055: ST_TO_ADDR
// f_murder := false ;
85056: LD_ADDR_VAR 0 20
85060: PUSH
85061: LD_INT 0
85063: ST_TO_ADDR
// f_mines := false ;
85064: LD_ADDR_VAR 0 21
85068: PUSH
85069: LD_INT 0
85071: ST_TO_ADDR
// f_repair := false ;
85072: LD_ADDR_VAR 0 22
85076: PUSH
85077: LD_INT 0
85079: ST_TO_ADDR
// f_heal := false ;
85080: LD_ADDR_VAR 0 23
85084: PUSH
85085: LD_INT 0
85087: ST_TO_ADDR
// f_spacetime := false ;
85088: LD_ADDR_VAR 0 24
85092: PUSH
85093: LD_INT 0
85095: ST_TO_ADDR
// f_attack_depot := false ;
85096: LD_ADDR_VAR 0 25
85100: PUSH
85101: LD_INT 0
85103: ST_TO_ADDR
// f_crawl := false ;
85104: LD_ADDR_VAR 0 26
85108: PUSH
85109: LD_INT 0
85111: ST_TO_ADDR
// end ; if f_heal then
85112: LD_VAR 0 23
85116: IFFALSE 85143
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
85118: LD_ADDR_VAR 0 31
85122: PUSH
85123: LD_VAR 0 4
85127: PPUSH
85128: LD_INT 25
85130: PUSH
85131: LD_INT 4
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: PPUSH
85138: CALL_OW 72
85142: ST_TO_ADDR
// if f_repair then
85143: LD_VAR 0 22
85147: IFFALSE 85174
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
85149: LD_ADDR_VAR 0 33
85153: PUSH
85154: LD_VAR 0 4
85158: PPUSH
85159: LD_INT 25
85161: PUSH
85162: LD_INT 3
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PPUSH
85169: CALL_OW 72
85173: ST_TO_ADDR
// units_path := [ ] ;
85174: LD_ADDR_VAR 0 16
85178: PUSH
85179: EMPTY
85180: ST_TO_ADDR
// for i = 1 to group do
85181: LD_ADDR_VAR 0 7
85185: PUSH
85186: DOUBLE
85187: LD_INT 1
85189: DEC
85190: ST_TO_ADDR
85191: LD_VAR 0 4
85195: PUSH
85196: FOR_TO
85197: IFFALSE 85226
// units_path := Replace ( units_path , i , path ) ;
85199: LD_ADDR_VAR 0 16
85203: PUSH
85204: LD_VAR 0 16
85208: PPUSH
85209: LD_VAR 0 7
85213: PPUSH
85214: LD_VAR 0 5
85218: PPUSH
85219: CALL_OW 1
85223: ST_TO_ADDR
85224: GO 85196
85226: POP
85227: POP
// repeat for i = group downto 1 do
85228: LD_ADDR_VAR 0 7
85232: PUSH
85233: DOUBLE
85234: LD_VAR 0 4
85238: INC
85239: ST_TO_ADDR
85240: LD_INT 1
85242: PUSH
85243: FOR_DOWNTO
85244: IFFALSE 89340
// begin wait ( 5 ) ;
85246: LD_INT 5
85248: PPUSH
85249: CALL_OW 67
// tmp := [ ] ;
85253: LD_ADDR_VAR 0 14
85257: PUSH
85258: EMPTY
85259: ST_TO_ADDR
// attacking := false ;
85260: LD_ADDR_VAR 0 29
85264: PUSH
85265: LD_INT 0
85267: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
85268: LD_VAR 0 4
85272: PUSH
85273: LD_VAR 0 7
85277: ARRAY
85278: PPUSH
85279: CALL_OW 301
85283: PUSH
85284: LD_VAR 0 4
85288: PUSH
85289: LD_VAR 0 7
85293: ARRAY
85294: NOT
85295: OR
85296: IFFALSE 85405
// begin if GetType ( group [ i ] ) = unit_human then
85298: LD_VAR 0 4
85302: PUSH
85303: LD_VAR 0 7
85307: ARRAY
85308: PPUSH
85309: CALL_OW 247
85313: PUSH
85314: LD_INT 1
85316: EQUAL
85317: IFFALSE 85363
// begin to_heal := to_heal diff group [ i ] ;
85319: LD_ADDR_VAR 0 30
85323: PUSH
85324: LD_VAR 0 30
85328: PUSH
85329: LD_VAR 0 4
85333: PUSH
85334: LD_VAR 0 7
85338: ARRAY
85339: DIFF
85340: ST_TO_ADDR
// healers := healers diff group [ i ] ;
85341: LD_ADDR_VAR 0 31
85345: PUSH
85346: LD_VAR 0 31
85350: PUSH
85351: LD_VAR 0 4
85355: PUSH
85356: LD_VAR 0 7
85360: ARRAY
85361: DIFF
85362: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
85363: LD_ADDR_VAR 0 4
85367: PUSH
85368: LD_VAR 0 4
85372: PPUSH
85373: LD_VAR 0 7
85377: PPUSH
85378: CALL_OW 3
85382: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
85383: LD_ADDR_VAR 0 16
85387: PUSH
85388: LD_VAR 0 16
85392: PPUSH
85393: LD_VAR 0 7
85397: PPUSH
85398: CALL_OW 3
85402: ST_TO_ADDR
// continue ;
85403: GO 85243
// end ; if f_repair then
85405: LD_VAR 0 22
85409: IFFALSE 85898
// begin if GetType ( group [ i ] ) = unit_vehicle then
85411: LD_VAR 0 4
85415: PUSH
85416: LD_VAR 0 7
85420: ARRAY
85421: PPUSH
85422: CALL_OW 247
85426: PUSH
85427: LD_INT 2
85429: EQUAL
85430: IFFALSE 85620
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
85432: LD_VAR 0 4
85436: PUSH
85437: LD_VAR 0 7
85441: ARRAY
85442: PPUSH
85443: CALL_OW 256
85447: PUSH
85448: LD_INT 700
85450: LESS
85451: PUSH
85452: LD_VAR 0 4
85456: PUSH
85457: LD_VAR 0 7
85461: ARRAY
85462: PUSH
85463: LD_VAR 0 32
85467: IN
85468: NOT
85469: AND
85470: IFFALSE 85494
// to_repair := to_repair union group [ i ] ;
85472: LD_ADDR_VAR 0 32
85476: PUSH
85477: LD_VAR 0 32
85481: PUSH
85482: LD_VAR 0 4
85486: PUSH
85487: LD_VAR 0 7
85491: ARRAY
85492: UNION
85493: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
85494: LD_VAR 0 4
85498: PUSH
85499: LD_VAR 0 7
85503: ARRAY
85504: PPUSH
85505: CALL_OW 256
85509: PUSH
85510: LD_INT 1000
85512: EQUAL
85513: PUSH
85514: LD_VAR 0 4
85518: PUSH
85519: LD_VAR 0 7
85523: ARRAY
85524: PUSH
85525: LD_VAR 0 32
85529: IN
85530: AND
85531: IFFALSE 85555
// to_repair := to_repair diff group [ i ] ;
85533: LD_ADDR_VAR 0 32
85537: PUSH
85538: LD_VAR 0 32
85542: PUSH
85543: LD_VAR 0 4
85547: PUSH
85548: LD_VAR 0 7
85552: ARRAY
85553: DIFF
85554: ST_TO_ADDR
// if group [ i ] in to_repair then
85555: LD_VAR 0 4
85559: PUSH
85560: LD_VAR 0 7
85564: ARRAY
85565: PUSH
85566: LD_VAR 0 32
85570: IN
85571: IFFALSE 85618
// begin if not IsInArea ( group [ i ] , f_repair ) then
85573: LD_VAR 0 4
85577: PUSH
85578: LD_VAR 0 7
85582: ARRAY
85583: PPUSH
85584: LD_VAR 0 22
85588: PPUSH
85589: CALL_OW 308
85593: NOT
85594: IFFALSE 85616
// ComMoveToArea ( group [ i ] , f_repair ) ;
85596: LD_VAR 0 4
85600: PUSH
85601: LD_VAR 0 7
85605: ARRAY
85606: PPUSH
85607: LD_VAR 0 22
85611: PPUSH
85612: CALL_OW 113
// continue ;
85616: GO 85243
// end ; end else
85618: GO 85898
// if group [ i ] in repairs then
85620: LD_VAR 0 4
85624: PUSH
85625: LD_VAR 0 7
85629: ARRAY
85630: PUSH
85631: LD_VAR 0 33
85635: IN
85636: IFFALSE 85898
// begin if IsInUnit ( group [ i ] ) then
85638: LD_VAR 0 4
85642: PUSH
85643: LD_VAR 0 7
85647: ARRAY
85648: PPUSH
85649: CALL_OW 310
85653: IFFALSE 85721
// begin z := IsInUnit ( group [ i ] ) ;
85655: LD_ADDR_VAR 0 13
85659: PUSH
85660: LD_VAR 0 4
85664: PUSH
85665: LD_VAR 0 7
85669: ARRAY
85670: PPUSH
85671: CALL_OW 310
85675: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
85676: LD_VAR 0 13
85680: PUSH
85681: LD_VAR 0 32
85685: IN
85686: PUSH
85687: LD_VAR 0 13
85691: PPUSH
85692: LD_VAR 0 22
85696: PPUSH
85697: CALL_OW 308
85701: AND
85702: IFFALSE 85719
// ComExitVehicle ( group [ i ] ) ;
85704: LD_VAR 0 4
85708: PUSH
85709: LD_VAR 0 7
85713: ARRAY
85714: PPUSH
85715: CALL_OW 121
// end else
85719: GO 85898
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
85721: LD_ADDR_VAR 0 13
85725: PUSH
85726: LD_VAR 0 4
85730: PPUSH
85731: LD_INT 95
85733: PUSH
85734: LD_VAR 0 22
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: LD_INT 58
85745: PUSH
85746: EMPTY
85747: LIST
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PPUSH
85753: CALL_OW 72
85757: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
85758: LD_VAR 0 4
85762: PUSH
85763: LD_VAR 0 7
85767: ARRAY
85768: PPUSH
85769: CALL_OW 314
85773: NOT
85774: IFFALSE 85896
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
85776: LD_ADDR_VAR 0 10
85780: PUSH
85781: LD_VAR 0 13
85785: PPUSH
85786: LD_VAR 0 4
85790: PUSH
85791: LD_VAR 0 7
85795: ARRAY
85796: PPUSH
85797: CALL_OW 74
85801: ST_TO_ADDR
// if not x then
85802: LD_VAR 0 10
85806: NOT
85807: IFFALSE 85811
// continue ;
85809: GO 85243
// if GetLives ( x ) < 1000 then
85811: LD_VAR 0 10
85815: PPUSH
85816: CALL_OW 256
85820: PUSH
85821: LD_INT 1000
85823: LESS
85824: IFFALSE 85848
// ComRepairVehicle ( group [ i ] , x ) else
85826: LD_VAR 0 4
85830: PUSH
85831: LD_VAR 0 7
85835: ARRAY
85836: PPUSH
85837: LD_VAR 0 10
85841: PPUSH
85842: CALL_OW 129
85846: GO 85896
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
85848: LD_VAR 0 23
85852: PUSH
85853: LD_VAR 0 4
85857: PUSH
85858: LD_VAR 0 7
85862: ARRAY
85863: PPUSH
85864: CALL_OW 256
85868: PUSH
85869: LD_INT 1000
85871: LESS
85872: AND
85873: NOT
85874: IFFALSE 85896
// ComEnterUnit ( group [ i ] , x ) ;
85876: LD_VAR 0 4
85880: PUSH
85881: LD_VAR 0 7
85885: ARRAY
85886: PPUSH
85887: LD_VAR 0 10
85891: PPUSH
85892: CALL_OW 120
// end ; continue ;
85896: GO 85243
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
85898: LD_VAR 0 23
85902: PUSH
85903: LD_VAR 0 4
85907: PUSH
85908: LD_VAR 0 7
85912: ARRAY
85913: PPUSH
85914: CALL_OW 247
85918: PUSH
85919: LD_INT 1
85921: EQUAL
85922: AND
85923: IFFALSE 86401
// begin if group [ i ] in healers then
85925: LD_VAR 0 4
85929: PUSH
85930: LD_VAR 0 7
85934: ARRAY
85935: PUSH
85936: LD_VAR 0 31
85940: IN
85941: IFFALSE 86214
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
85943: LD_VAR 0 4
85947: PUSH
85948: LD_VAR 0 7
85952: ARRAY
85953: PPUSH
85954: LD_VAR 0 23
85958: PPUSH
85959: CALL_OW 308
85963: NOT
85964: PUSH
85965: LD_VAR 0 4
85969: PUSH
85970: LD_VAR 0 7
85974: ARRAY
85975: PPUSH
85976: CALL_OW 314
85980: NOT
85981: AND
85982: IFFALSE 86006
// ComMoveToArea ( group [ i ] , f_heal ) else
85984: LD_VAR 0 4
85988: PUSH
85989: LD_VAR 0 7
85993: ARRAY
85994: PPUSH
85995: LD_VAR 0 23
85999: PPUSH
86000: CALL_OW 113
86004: GO 86212
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
86006: LD_VAR 0 4
86010: PUSH
86011: LD_VAR 0 7
86015: ARRAY
86016: PPUSH
86017: CALL 84624 0 1
86021: PPUSH
86022: CALL_OW 256
86026: PUSH
86027: LD_INT 1000
86029: EQUAL
86030: IFFALSE 86049
// ComStop ( group [ i ] ) else
86032: LD_VAR 0 4
86036: PUSH
86037: LD_VAR 0 7
86041: ARRAY
86042: PPUSH
86043: CALL_OW 141
86047: GO 86212
// if not HasTask ( group [ i ] ) and to_heal then
86049: LD_VAR 0 4
86053: PUSH
86054: LD_VAR 0 7
86058: ARRAY
86059: PPUSH
86060: CALL_OW 314
86064: NOT
86065: PUSH
86066: LD_VAR 0 30
86070: AND
86071: IFFALSE 86212
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
86073: LD_ADDR_VAR 0 13
86077: PUSH
86078: LD_VAR 0 30
86082: PPUSH
86083: LD_INT 3
86085: PUSH
86086: LD_INT 54
86088: PUSH
86089: EMPTY
86090: LIST
86091: PUSH
86092: EMPTY
86093: LIST
86094: LIST
86095: PPUSH
86096: CALL_OW 72
86100: PPUSH
86101: LD_VAR 0 4
86105: PUSH
86106: LD_VAR 0 7
86110: ARRAY
86111: PPUSH
86112: CALL_OW 74
86116: ST_TO_ADDR
// if z then
86117: LD_VAR 0 13
86121: IFFALSE 86212
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
86123: LD_INT 91
86125: PUSH
86126: LD_VAR 0 13
86130: PUSH
86131: LD_INT 10
86133: PUSH
86134: EMPTY
86135: LIST
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 81
86141: PUSH
86142: LD_VAR 0 13
86146: PPUSH
86147: CALL_OW 255
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: PUSH
86156: EMPTY
86157: LIST
86158: LIST
86159: PPUSH
86160: CALL_OW 69
86164: PUSH
86165: LD_INT 0
86167: EQUAL
86168: IFFALSE 86192
// ComHeal ( group [ i ] , z ) else
86170: LD_VAR 0 4
86174: PUSH
86175: LD_VAR 0 7
86179: ARRAY
86180: PPUSH
86181: LD_VAR 0 13
86185: PPUSH
86186: CALL_OW 128
86190: GO 86212
// ComMoveToArea ( group [ i ] , f_heal ) ;
86192: LD_VAR 0 4
86196: PUSH
86197: LD_VAR 0 7
86201: ARRAY
86202: PPUSH
86203: LD_VAR 0 23
86207: PPUSH
86208: CALL_OW 113
// end ; continue ;
86212: GO 85243
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
86214: LD_VAR 0 4
86218: PUSH
86219: LD_VAR 0 7
86223: ARRAY
86224: PPUSH
86225: CALL_OW 256
86229: PUSH
86230: LD_INT 700
86232: LESS
86233: PUSH
86234: LD_VAR 0 4
86238: PUSH
86239: LD_VAR 0 7
86243: ARRAY
86244: PUSH
86245: LD_VAR 0 30
86249: IN
86250: NOT
86251: AND
86252: IFFALSE 86276
// to_heal := to_heal union group [ i ] ;
86254: LD_ADDR_VAR 0 30
86258: PUSH
86259: LD_VAR 0 30
86263: PUSH
86264: LD_VAR 0 4
86268: PUSH
86269: LD_VAR 0 7
86273: ARRAY
86274: UNION
86275: ST_TO_ADDR
// if group [ i ] in to_heal then
86276: LD_VAR 0 4
86280: PUSH
86281: LD_VAR 0 7
86285: ARRAY
86286: PUSH
86287: LD_VAR 0 30
86291: IN
86292: IFFALSE 86401
// begin if GetLives ( group [ i ] ) = 1000 then
86294: LD_VAR 0 4
86298: PUSH
86299: LD_VAR 0 7
86303: ARRAY
86304: PPUSH
86305: CALL_OW 256
86309: PUSH
86310: LD_INT 1000
86312: EQUAL
86313: IFFALSE 86339
// to_heal := to_heal diff group [ i ] else
86315: LD_ADDR_VAR 0 30
86319: PUSH
86320: LD_VAR 0 30
86324: PUSH
86325: LD_VAR 0 4
86329: PUSH
86330: LD_VAR 0 7
86334: ARRAY
86335: DIFF
86336: ST_TO_ADDR
86337: GO 86401
// begin if not IsInArea ( group [ i ] , to_heal ) then
86339: LD_VAR 0 4
86343: PUSH
86344: LD_VAR 0 7
86348: ARRAY
86349: PPUSH
86350: LD_VAR 0 30
86354: PPUSH
86355: CALL_OW 308
86359: NOT
86360: IFFALSE 86384
// ComMoveToArea ( group [ i ] , f_heal ) else
86362: LD_VAR 0 4
86366: PUSH
86367: LD_VAR 0 7
86371: ARRAY
86372: PPUSH
86373: LD_VAR 0 23
86377: PPUSH
86378: CALL_OW 113
86382: GO 86399
// ComHold ( group [ i ] ) ;
86384: LD_VAR 0 4
86388: PUSH
86389: LD_VAR 0 7
86393: ARRAY
86394: PPUSH
86395: CALL_OW 140
// continue ;
86399: GO 85243
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
86401: LD_VAR 0 4
86405: PUSH
86406: LD_VAR 0 7
86410: ARRAY
86411: PPUSH
86412: LD_INT 10
86414: PPUSH
86415: CALL 83021 0 2
86419: NOT
86420: PUSH
86421: LD_VAR 0 16
86425: PUSH
86426: LD_VAR 0 7
86430: ARRAY
86431: PUSH
86432: EMPTY
86433: EQUAL
86434: NOT
86435: AND
86436: IFFALSE 86702
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
86438: LD_VAR 0 4
86442: PUSH
86443: LD_VAR 0 7
86447: ARRAY
86448: PPUSH
86449: CALL_OW 262
86453: PUSH
86454: LD_INT 1
86456: PUSH
86457: LD_INT 2
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: IN
86464: IFFALSE 86505
// if GetFuel ( group [ i ] ) < 10 then
86466: LD_VAR 0 4
86470: PUSH
86471: LD_VAR 0 7
86475: ARRAY
86476: PPUSH
86477: CALL_OW 261
86481: PUSH
86482: LD_INT 10
86484: LESS
86485: IFFALSE 86505
// SetFuel ( group [ i ] , 12 ) ;
86487: LD_VAR 0 4
86491: PUSH
86492: LD_VAR 0 7
86496: ARRAY
86497: PPUSH
86498: LD_INT 12
86500: PPUSH
86501: CALL_OW 240
// if units_path [ i ] then
86505: LD_VAR 0 16
86509: PUSH
86510: LD_VAR 0 7
86514: ARRAY
86515: IFFALSE 86700
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
86517: LD_VAR 0 4
86521: PUSH
86522: LD_VAR 0 7
86526: ARRAY
86527: PPUSH
86528: LD_VAR 0 16
86532: PUSH
86533: LD_VAR 0 7
86537: ARRAY
86538: PUSH
86539: LD_INT 1
86541: ARRAY
86542: PUSH
86543: LD_INT 1
86545: ARRAY
86546: PPUSH
86547: LD_VAR 0 16
86551: PUSH
86552: LD_VAR 0 7
86556: ARRAY
86557: PUSH
86558: LD_INT 1
86560: ARRAY
86561: PUSH
86562: LD_INT 2
86564: ARRAY
86565: PPUSH
86566: CALL_OW 297
86570: PUSH
86571: LD_INT 6
86573: GREATER
86574: IFFALSE 86649
// begin if not HasTask ( group [ i ] ) then
86576: LD_VAR 0 4
86580: PUSH
86581: LD_VAR 0 7
86585: ARRAY
86586: PPUSH
86587: CALL_OW 314
86591: NOT
86592: IFFALSE 86647
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
86594: LD_VAR 0 4
86598: PUSH
86599: LD_VAR 0 7
86603: ARRAY
86604: PPUSH
86605: LD_VAR 0 16
86609: PUSH
86610: LD_VAR 0 7
86614: ARRAY
86615: PUSH
86616: LD_INT 1
86618: ARRAY
86619: PUSH
86620: LD_INT 1
86622: ARRAY
86623: PPUSH
86624: LD_VAR 0 16
86628: PUSH
86629: LD_VAR 0 7
86633: ARRAY
86634: PUSH
86635: LD_INT 1
86637: ARRAY
86638: PUSH
86639: LD_INT 2
86641: ARRAY
86642: PPUSH
86643: CALL_OW 114
// end else
86647: GO 86700
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
86649: LD_ADDR_VAR 0 15
86653: PUSH
86654: LD_VAR 0 16
86658: PUSH
86659: LD_VAR 0 7
86663: ARRAY
86664: PPUSH
86665: LD_INT 1
86667: PPUSH
86668: CALL_OW 3
86672: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
86673: LD_ADDR_VAR 0 16
86677: PUSH
86678: LD_VAR 0 16
86682: PPUSH
86683: LD_VAR 0 7
86687: PPUSH
86688: LD_VAR 0 15
86692: PPUSH
86693: CALL_OW 1
86697: ST_TO_ADDR
// continue ;
86698: GO 85243
// end ; end ; end else
86700: GO 89338
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
86702: LD_ADDR_VAR 0 14
86706: PUSH
86707: LD_INT 81
86709: PUSH
86710: LD_VAR 0 4
86714: PUSH
86715: LD_VAR 0 7
86719: ARRAY
86720: PPUSH
86721: CALL_OW 255
86725: PUSH
86726: EMPTY
86727: LIST
86728: LIST
86729: PPUSH
86730: CALL_OW 69
86734: ST_TO_ADDR
// if not tmp then
86735: LD_VAR 0 14
86739: NOT
86740: IFFALSE 86744
// continue ;
86742: GO 85243
// if f_ignore_area then
86744: LD_VAR 0 17
86748: IFFALSE 86836
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
86750: LD_ADDR_VAR 0 15
86754: PUSH
86755: LD_VAR 0 14
86759: PPUSH
86760: LD_INT 3
86762: PUSH
86763: LD_INT 92
86765: PUSH
86766: LD_VAR 0 17
86770: PUSH
86771: LD_INT 1
86773: ARRAY
86774: PUSH
86775: LD_VAR 0 17
86779: PUSH
86780: LD_INT 2
86782: ARRAY
86783: PUSH
86784: LD_VAR 0 17
86788: PUSH
86789: LD_INT 3
86791: ARRAY
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: PUSH
86799: EMPTY
86800: LIST
86801: LIST
86802: PPUSH
86803: CALL_OW 72
86807: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
86808: LD_VAR 0 14
86812: PUSH
86813: LD_VAR 0 15
86817: DIFF
86818: IFFALSE 86836
// tmp := tmp diff tmp2 ;
86820: LD_ADDR_VAR 0 14
86824: PUSH
86825: LD_VAR 0 14
86829: PUSH
86830: LD_VAR 0 15
86834: DIFF
86835: ST_TO_ADDR
// end ; if not f_murder then
86836: LD_VAR 0 20
86840: NOT
86841: IFFALSE 86899
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
86843: LD_ADDR_VAR 0 15
86847: PUSH
86848: LD_VAR 0 14
86852: PPUSH
86853: LD_INT 3
86855: PUSH
86856: LD_INT 50
86858: PUSH
86859: EMPTY
86860: LIST
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PPUSH
86866: CALL_OW 72
86870: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
86871: LD_VAR 0 14
86875: PUSH
86876: LD_VAR 0 15
86880: DIFF
86881: IFFALSE 86899
// tmp := tmp diff tmp2 ;
86883: LD_ADDR_VAR 0 14
86887: PUSH
86888: LD_VAR 0 14
86892: PUSH
86893: LD_VAR 0 15
86897: DIFF
86898: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
86899: LD_ADDR_VAR 0 14
86903: PUSH
86904: LD_VAR 0 4
86908: PUSH
86909: LD_VAR 0 7
86913: ARRAY
86914: PPUSH
86915: LD_VAR 0 14
86919: PPUSH
86920: LD_INT 1
86922: PPUSH
86923: LD_INT 1
86925: PPUSH
86926: CALL 56664 0 4
86930: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
86931: LD_VAR 0 4
86935: PUSH
86936: LD_VAR 0 7
86940: ARRAY
86941: PPUSH
86942: CALL_OW 257
86946: PUSH
86947: LD_INT 1
86949: EQUAL
86950: IFFALSE 87398
// begin if WantPlant ( group [ i ] ) then
86952: LD_VAR 0 4
86956: PUSH
86957: LD_VAR 0 7
86961: ARRAY
86962: PPUSH
86963: CALL 56165 0 1
86967: IFFALSE 86971
// continue ;
86969: GO 85243
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
86971: LD_VAR 0 18
86975: PUSH
86976: LD_VAR 0 4
86980: PUSH
86981: LD_VAR 0 7
86985: ARRAY
86986: PPUSH
86987: CALL_OW 310
86991: NOT
86992: AND
86993: PUSH
86994: LD_VAR 0 14
86998: PUSH
86999: LD_INT 1
87001: ARRAY
87002: PUSH
87003: LD_VAR 0 14
87007: PPUSH
87008: LD_INT 21
87010: PUSH
87011: LD_INT 2
87013: PUSH
87014: EMPTY
87015: LIST
87016: LIST
87017: PUSH
87018: LD_INT 58
87020: PUSH
87021: EMPTY
87022: LIST
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PPUSH
87028: CALL_OW 72
87032: IN
87033: AND
87034: IFFALSE 87070
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
87036: LD_VAR 0 4
87040: PUSH
87041: LD_VAR 0 7
87045: ARRAY
87046: PPUSH
87047: LD_VAR 0 14
87051: PUSH
87052: LD_INT 1
87054: ARRAY
87055: PPUSH
87056: CALL_OW 120
// attacking := true ;
87060: LD_ADDR_VAR 0 29
87064: PUSH
87065: LD_INT 1
87067: ST_TO_ADDR
// continue ;
87068: GO 85243
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
87070: LD_VAR 0 26
87074: PUSH
87075: LD_VAR 0 4
87079: PUSH
87080: LD_VAR 0 7
87084: ARRAY
87085: PPUSH
87086: CALL_OW 257
87090: PUSH
87091: LD_INT 1
87093: EQUAL
87094: AND
87095: PUSH
87096: LD_VAR 0 4
87100: PUSH
87101: LD_VAR 0 7
87105: ARRAY
87106: PPUSH
87107: CALL_OW 256
87111: PUSH
87112: LD_INT 800
87114: LESS
87115: AND
87116: PUSH
87117: LD_VAR 0 4
87121: PUSH
87122: LD_VAR 0 7
87126: ARRAY
87127: PPUSH
87128: CALL_OW 318
87132: NOT
87133: AND
87134: IFFALSE 87151
// ComCrawl ( group [ i ] ) ;
87136: LD_VAR 0 4
87140: PUSH
87141: LD_VAR 0 7
87145: ARRAY
87146: PPUSH
87147: CALL_OW 137
// if f_mines then
87151: LD_VAR 0 21
87155: IFFALSE 87398
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
87157: LD_VAR 0 14
87161: PUSH
87162: LD_INT 1
87164: ARRAY
87165: PPUSH
87166: CALL_OW 247
87170: PUSH
87171: LD_INT 3
87173: EQUAL
87174: PUSH
87175: LD_VAR 0 14
87179: PUSH
87180: LD_INT 1
87182: ARRAY
87183: PUSH
87184: LD_VAR 0 27
87188: IN
87189: NOT
87190: AND
87191: IFFALSE 87398
// begin x := GetX ( tmp [ 1 ] ) ;
87193: LD_ADDR_VAR 0 10
87197: PUSH
87198: LD_VAR 0 14
87202: PUSH
87203: LD_INT 1
87205: ARRAY
87206: PPUSH
87207: CALL_OW 250
87211: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
87212: LD_ADDR_VAR 0 11
87216: PUSH
87217: LD_VAR 0 14
87221: PUSH
87222: LD_INT 1
87224: ARRAY
87225: PPUSH
87226: CALL_OW 251
87230: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
87231: LD_ADDR_VAR 0 12
87235: PUSH
87236: LD_VAR 0 4
87240: PUSH
87241: LD_VAR 0 7
87245: ARRAY
87246: PPUSH
87247: CALL 83106 0 1
87251: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
87252: LD_VAR 0 4
87256: PUSH
87257: LD_VAR 0 7
87261: ARRAY
87262: PPUSH
87263: LD_VAR 0 10
87267: PPUSH
87268: LD_VAR 0 11
87272: PPUSH
87273: LD_VAR 0 14
87277: PUSH
87278: LD_INT 1
87280: ARRAY
87281: PPUSH
87282: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
87286: LD_VAR 0 4
87290: PUSH
87291: LD_VAR 0 7
87295: ARRAY
87296: PPUSH
87297: LD_VAR 0 10
87301: PPUSH
87302: LD_VAR 0 12
87306: PPUSH
87307: LD_INT 7
87309: PPUSH
87310: CALL_OW 272
87314: PPUSH
87315: LD_VAR 0 11
87319: PPUSH
87320: LD_VAR 0 12
87324: PPUSH
87325: LD_INT 7
87327: PPUSH
87328: CALL_OW 273
87332: PPUSH
87333: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
87337: LD_VAR 0 4
87341: PUSH
87342: LD_VAR 0 7
87346: ARRAY
87347: PPUSH
87348: LD_INT 71
87350: PPUSH
87351: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
87355: LD_ADDR_VAR 0 27
87359: PUSH
87360: LD_VAR 0 27
87364: PPUSH
87365: LD_VAR 0 27
87369: PUSH
87370: LD_INT 1
87372: PLUS
87373: PPUSH
87374: LD_VAR 0 14
87378: PUSH
87379: LD_INT 1
87381: ARRAY
87382: PPUSH
87383: CALL_OW 1
87387: ST_TO_ADDR
// attacking := true ;
87388: LD_ADDR_VAR 0 29
87392: PUSH
87393: LD_INT 1
87395: ST_TO_ADDR
// continue ;
87396: GO 85243
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
87398: LD_VAR 0 4
87402: PUSH
87403: LD_VAR 0 7
87407: ARRAY
87408: PPUSH
87409: CALL_OW 257
87413: PUSH
87414: LD_INT 17
87416: EQUAL
87417: PUSH
87418: LD_VAR 0 4
87422: PUSH
87423: LD_VAR 0 7
87427: ARRAY
87428: PPUSH
87429: CALL_OW 110
87433: PUSH
87434: LD_INT 71
87436: EQUAL
87437: NOT
87438: AND
87439: IFFALSE 87585
// begin attacking := false ;
87441: LD_ADDR_VAR 0 29
87445: PUSH
87446: LD_INT 0
87448: ST_TO_ADDR
// k := 5 ;
87449: LD_ADDR_VAR 0 9
87453: PUSH
87454: LD_INT 5
87456: ST_TO_ADDR
// if tmp < k then
87457: LD_VAR 0 14
87461: PUSH
87462: LD_VAR 0 9
87466: LESS
87467: IFFALSE 87479
// k := tmp ;
87469: LD_ADDR_VAR 0 9
87473: PUSH
87474: LD_VAR 0 14
87478: ST_TO_ADDR
// for j = 1 to k do
87479: LD_ADDR_VAR 0 8
87483: PUSH
87484: DOUBLE
87485: LD_INT 1
87487: DEC
87488: ST_TO_ADDR
87489: LD_VAR 0 9
87493: PUSH
87494: FOR_TO
87495: IFFALSE 87583
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
87497: LD_VAR 0 14
87501: PUSH
87502: LD_VAR 0 8
87506: ARRAY
87507: PUSH
87508: LD_VAR 0 14
87512: PPUSH
87513: LD_INT 58
87515: PUSH
87516: EMPTY
87517: LIST
87518: PPUSH
87519: CALL_OW 72
87523: IN
87524: NOT
87525: IFFALSE 87581
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87527: LD_VAR 0 4
87531: PUSH
87532: LD_VAR 0 7
87536: ARRAY
87537: PPUSH
87538: LD_VAR 0 14
87542: PUSH
87543: LD_VAR 0 8
87547: ARRAY
87548: PPUSH
87549: CALL_OW 115
// attacking := true ;
87553: LD_ADDR_VAR 0 29
87557: PUSH
87558: LD_INT 1
87560: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
87561: LD_VAR 0 4
87565: PUSH
87566: LD_VAR 0 7
87570: ARRAY
87571: PPUSH
87572: LD_INT 71
87574: PPUSH
87575: CALL_OW 109
// continue ;
87579: GO 87494
// end ; end ;
87581: GO 87494
87583: POP
87584: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
87585: LD_VAR 0 4
87589: PUSH
87590: LD_VAR 0 7
87594: ARRAY
87595: PPUSH
87596: CALL_OW 257
87600: PUSH
87601: LD_INT 8
87603: EQUAL
87604: PUSH
87605: LD_VAR 0 4
87609: PUSH
87610: LD_VAR 0 7
87614: ARRAY
87615: PPUSH
87616: CALL_OW 264
87620: PUSH
87621: LD_INT 28
87623: PUSH
87624: LD_INT 45
87626: PUSH
87627: LD_INT 7
87629: PUSH
87630: LD_INT 47
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: LIST
87637: LIST
87638: IN
87639: OR
87640: IFFALSE 87870
// begin attacking := false ;
87642: LD_ADDR_VAR 0 29
87646: PUSH
87647: LD_INT 0
87649: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
87650: LD_VAR 0 14
87654: PUSH
87655: LD_INT 1
87657: ARRAY
87658: PPUSH
87659: CALL_OW 266
87663: PUSH
87664: LD_INT 32
87666: PUSH
87667: LD_INT 31
87669: PUSH
87670: LD_INT 33
87672: PUSH
87673: LD_INT 4
87675: PUSH
87676: LD_INT 5
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: IN
87686: IFFALSE 87870
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
87688: LD_ADDR_VAR 0 9
87692: PUSH
87693: LD_VAR 0 14
87697: PUSH
87698: LD_INT 1
87700: ARRAY
87701: PPUSH
87702: CALL_OW 266
87706: PPUSH
87707: LD_VAR 0 14
87711: PUSH
87712: LD_INT 1
87714: ARRAY
87715: PPUSH
87716: CALL_OW 250
87720: PPUSH
87721: LD_VAR 0 14
87725: PUSH
87726: LD_INT 1
87728: ARRAY
87729: PPUSH
87730: CALL_OW 251
87734: PPUSH
87735: LD_VAR 0 14
87739: PUSH
87740: LD_INT 1
87742: ARRAY
87743: PPUSH
87744: CALL_OW 254
87748: PPUSH
87749: LD_VAR 0 14
87753: PUSH
87754: LD_INT 1
87756: ARRAY
87757: PPUSH
87758: CALL_OW 248
87762: PPUSH
87763: LD_INT 0
87765: PPUSH
87766: CALL 64476 0 6
87770: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
87771: LD_ADDR_VAR 0 8
87775: PUSH
87776: LD_VAR 0 4
87780: PUSH
87781: LD_VAR 0 7
87785: ARRAY
87786: PPUSH
87787: LD_VAR 0 9
87791: PPUSH
87792: CALL 83169 0 2
87796: ST_TO_ADDR
// if j then
87797: LD_VAR 0 8
87801: IFFALSE 87870
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
87803: LD_VAR 0 8
87807: PUSH
87808: LD_INT 1
87810: ARRAY
87811: PPUSH
87812: LD_VAR 0 8
87816: PUSH
87817: LD_INT 2
87819: ARRAY
87820: PPUSH
87821: CALL_OW 488
87825: IFFALSE 87870
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
87827: LD_VAR 0 4
87831: PUSH
87832: LD_VAR 0 7
87836: ARRAY
87837: PPUSH
87838: LD_VAR 0 8
87842: PUSH
87843: LD_INT 1
87845: ARRAY
87846: PPUSH
87847: LD_VAR 0 8
87851: PUSH
87852: LD_INT 2
87854: ARRAY
87855: PPUSH
87856: CALL_OW 116
// attacking := true ;
87860: LD_ADDR_VAR 0 29
87864: PUSH
87865: LD_INT 1
87867: ST_TO_ADDR
// continue ;
87868: GO 85243
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
87870: LD_VAR 0 4
87874: PUSH
87875: LD_VAR 0 7
87879: ARRAY
87880: PPUSH
87881: CALL_OW 265
87885: PUSH
87886: LD_INT 11
87888: EQUAL
87889: IFFALSE 88167
// begin k := 10 ;
87891: LD_ADDR_VAR 0 9
87895: PUSH
87896: LD_INT 10
87898: ST_TO_ADDR
// x := 0 ;
87899: LD_ADDR_VAR 0 10
87903: PUSH
87904: LD_INT 0
87906: ST_TO_ADDR
// if tmp < k then
87907: LD_VAR 0 14
87911: PUSH
87912: LD_VAR 0 9
87916: LESS
87917: IFFALSE 87929
// k := tmp ;
87919: LD_ADDR_VAR 0 9
87923: PUSH
87924: LD_VAR 0 14
87928: ST_TO_ADDR
// for j = k downto 1 do
87929: LD_ADDR_VAR 0 8
87933: PUSH
87934: DOUBLE
87935: LD_VAR 0 9
87939: INC
87940: ST_TO_ADDR
87941: LD_INT 1
87943: PUSH
87944: FOR_DOWNTO
87945: IFFALSE 88020
// begin if GetType ( tmp [ j ] ) = unit_human then
87947: LD_VAR 0 14
87951: PUSH
87952: LD_VAR 0 8
87956: ARRAY
87957: PPUSH
87958: CALL_OW 247
87962: PUSH
87963: LD_INT 1
87965: EQUAL
87966: IFFALSE 88018
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
87968: LD_VAR 0 4
87972: PUSH
87973: LD_VAR 0 7
87977: ARRAY
87978: PPUSH
87979: LD_VAR 0 14
87983: PUSH
87984: LD_VAR 0 8
87988: ARRAY
87989: PPUSH
87990: CALL 83440 0 2
// x := tmp [ j ] ;
87994: LD_ADDR_VAR 0 10
87998: PUSH
87999: LD_VAR 0 14
88003: PUSH
88004: LD_VAR 0 8
88008: ARRAY
88009: ST_TO_ADDR
// attacking := true ;
88010: LD_ADDR_VAR 0 29
88014: PUSH
88015: LD_INT 1
88017: ST_TO_ADDR
// end ; end ;
88018: GO 87944
88020: POP
88021: POP
// if not x then
88022: LD_VAR 0 10
88026: NOT
88027: IFFALSE 88167
// begin attacking := true ;
88029: LD_ADDR_VAR 0 29
88033: PUSH
88034: LD_INT 1
88036: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
88037: LD_VAR 0 4
88041: PUSH
88042: LD_VAR 0 7
88046: ARRAY
88047: PPUSH
88048: CALL_OW 250
88052: PPUSH
88053: LD_VAR 0 4
88057: PUSH
88058: LD_VAR 0 7
88062: ARRAY
88063: PPUSH
88064: CALL_OW 251
88068: PPUSH
88069: CALL_OW 546
88073: PUSH
88074: LD_INT 2
88076: ARRAY
88077: PUSH
88078: LD_VAR 0 14
88082: PUSH
88083: LD_INT 1
88085: ARRAY
88086: PPUSH
88087: CALL_OW 250
88091: PPUSH
88092: LD_VAR 0 14
88096: PUSH
88097: LD_INT 1
88099: ARRAY
88100: PPUSH
88101: CALL_OW 251
88105: PPUSH
88106: CALL_OW 546
88110: PUSH
88111: LD_INT 2
88113: ARRAY
88114: EQUAL
88115: IFFALSE 88143
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
88117: LD_VAR 0 4
88121: PUSH
88122: LD_VAR 0 7
88126: ARRAY
88127: PPUSH
88128: LD_VAR 0 14
88132: PUSH
88133: LD_INT 1
88135: ARRAY
88136: PPUSH
88137: CALL 83440 0 2
88141: GO 88167
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88143: LD_VAR 0 4
88147: PUSH
88148: LD_VAR 0 7
88152: ARRAY
88153: PPUSH
88154: LD_VAR 0 14
88158: PUSH
88159: LD_INT 1
88161: ARRAY
88162: PPUSH
88163: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
88167: LD_VAR 0 4
88171: PUSH
88172: LD_VAR 0 7
88176: ARRAY
88177: PPUSH
88178: CALL_OW 264
88182: PUSH
88183: LD_INT 29
88185: EQUAL
88186: IFFALSE 88552
// begin if WantsToAttack ( group [ i ] ) in bombed then
88188: LD_VAR 0 4
88192: PUSH
88193: LD_VAR 0 7
88197: ARRAY
88198: PPUSH
88199: CALL_OW 319
88203: PUSH
88204: LD_VAR 0 28
88208: IN
88209: IFFALSE 88213
// continue ;
88211: GO 85243
// k := 8 ;
88213: LD_ADDR_VAR 0 9
88217: PUSH
88218: LD_INT 8
88220: ST_TO_ADDR
// x := 0 ;
88221: LD_ADDR_VAR 0 10
88225: PUSH
88226: LD_INT 0
88228: ST_TO_ADDR
// if tmp < k then
88229: LD_VAR 0 14
88233: PUSH
88234: LD_VAR 0 9
88238: LESS
88239: IFFALSE 88251
// k := tmp ;
88241: LD_ADDR_VAR 0 9
88245: PUSH
88246: LD_VAR 0 14
88250: ST_TO_ADDR
// for j = 1 to k do
88251: LD_ADDR_VAR 0 8
88255: PUSH
88256: DOUBLE
88257: LD_INT 1
88259: DEC
88260: ST_TO_ADDR
88261: LD_VAR 0 9
88265: PUSH
88266: FOR_TO
88267: IFFALSE 88399
// begin if GetType ( tmp [ j ] ) = unit_building then
88269: LD_VAR 0 14
88273: PUSH
88274: LD_VAR 0 8
88278: ARRAY
88279: PPUSH
88280: CALL_OW 247
88284: PUSH
88285: LD_INT 3
88287: EQUAL
88288: IFFALSE 88397
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
88290: LD_VAR 0 14
88294: PUSH
88295: LD_VAR 0 8
88299: ARRAY
88300: PUSH
88301: LD_VAR 0 28
88305: IN
88306: NOT
88307: PUSH
88308: LD_VAR 0 14
88312: PUSH
88313: LD_VAR 0 8
88317: ARRAY
88318: PPUSH
88319: CALL_OW 313
88323: AND
88324: IFFALSE 88397
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88326: LD_VAR 0 4
88330: PUSH
88331: LD_VAR 0 7
88335: ARRAY
88336: PPUSH
88337: LD_VAR 0 14
88341: PUSH
88342: LD_VAR 0 8
88346: ARRAY
88347: PPUSH
88348: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
88352: LD_ADDR_VAR 0 28
88356: PUSH
88357: LD_VAR 0 28
88361: PPUSH
88362: LD_VAR 0 28
88366: PUSH
88367: LD_INT 1
88369: PLUS
88370: PPUSH
88371: LD_VAR 0 14
88375: PUSH
88376: LD_VAR 0 8
88380: ARRAY
88381: PPUSH
88382: CALL_OW 1
88386: ST_TO_ADDR
// attacking := true ;
88387: LD_ADDR_VAR 0 29
88391: PUSH
88392: LD_INT 1
88394: ST_TO_ADDR
// break ;
88395: GO 88399
// end ; end ;
88397: GO 88266
88399: POP
88400: POP
// if not attacking and f_attack_depot then
88401: LD_VAR 0 29
88405: NOT
88406: PUSH
88407: LD_VAR 0 25
88411: AND
88412: IFFALSE 88507
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88414: LD_ADDR_VAR 0 13
88418: PUSH
88419: LD_VAR 0 14
88423: PPUSH
88424: LD_INT 2
88426: PUSH
88427: LD_INT 30
88429: PUSH
88430: LD_INT 0
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: PUSH
88437: LD_INT 30
88439: PUSH
88440: LD_INT 1
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: LIST
88451: PPUSH
88452: CALL_OW 72
88456: ST_TO_ADDR
// if z then
88457: LD_VAR 0 13
88461: IFFALSE 88507
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
88463: LD_VAR 0 4
88467: PUSH
88468: LD_VAR 0 7
88472: ARRAY
88473: PPUSH
88474: LD_VAR 0 13
88478: PPUSH
88479: LD_VAR 0 4
88483: PUSH
88484: LD_VAR 0 7
88488: ARRAY
88489: PPUSH
88490: CALL_OW 74
88494: PPUSH
88495: CALL_OW 115
// attacking := true ;
88499: LD_ADDR_VAR 0 29
88503: PUSH
88504: LD_INT 1
88506: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
88507: LD_VAR 0 4
88511: PUSH
88512: LD_VAR 0 7
88516: ARRAY
88517: PPUSH
88518: CALL_OW 256
88522: PUSH
88523: LD_INT 500
88525: LESS
88526: IFFALSE 88552
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88528: LD_VAR 0 4
88532: PUSH
88533: LD_VAR 0 7
88537: ARRAY
88538: PPUSH
88539: LD_VAR 0 14
88543: PUSH
88544: LD_INT 1
88546: ARRAY
88547: PPUSH
88548: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
88552: LD_VAR 0 4
88556: PUSH
88557: LD_VAR 0 7
88561: ARRAY
88562: PPUSH
88563: CALL_OW 264
88567: PUSH
88568: LD_INT 49
88570: EQUAL
88571: IFFALSE 88692
// begin if not HasTask ( group [ i ] ) then
88573: LD_VAR 0 4
88577: PUSH
88578: LD_VAR 0 7
88582: ARRAY
88583: PPUSH
88584: CALL_OW 314
88588: NOT
88589: IFFALSE 88692
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
88591: LD_ADDR_VAR 0 9
88595: PUSH
88596: LD_INT 81
88598: PUSH
88599: LD_VAR 0 4
88603: PUSH
88604: LD_VAR 0 7
88608: ARRAY
88609: PPUSH
88610: CALL_OW 255
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PPUSH
88619: CALL_OW 69
88623: PPUSH
88624: LD_VAR 0 4
88628: PUSH
88629: LD_VAR 0 7
88633: ARRAY
88634: PPUSH
88635: CALL_OW 74
88639: ST_TO_ADDR
// if k then
88640: LD_VAR 0 9
88644: IFFALSE 88692
// if GetDistUnits ( group [ i ] , k ) > 10 then
88646: LD_VAR 0 4
88650: PUSH
88651: LD_VAR 0 7
88655: ARRAY
88656: PPUSH
88657: LD_VAR 0 9
88661: PPUSH
88662: CALL_OW 296
88666: PUSH
88667: LD_INT 10
88669: GREATER
88670: IFFALSE 88692
// ComMoveUnit ( group [ i ] , k ) ;
88672: LD_VAR 0 4
88676: PUSH
88677: LD_VAR 0 7
88681: ARRAY
88682: PPUSH
88683: LD_VAR 0 9
88687: PPUSH
88688: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
88692: LD_VAR 0 4
88696: PUSH
88697: LD_VAR 0 7
88701: ARRAY
88702: PPUSH
88703: CALL_OW 256
88707: PUSH
88708: LD_INT 250
88710: LESS
88711: PUSH
88712: LD_VAR 0 4
88716: PUSH
88717: LD_VAR 0 7
88721: ARRAY
88722: PUSH
88723: LD_INT 21
88725: PUSH
88726: LD_INT 2
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: PUSH
88733: LD_INT 23
88735: PUSH
88736: LD_INT 2
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: EMPTY
88744: LIST
88745: LIST
88746: PPUSH
88747: CALL_OW 69
88751: IN
88752: AND
88753: IFFALSE 88878
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
88755: LD_ADDR_VAR 0 9
88759: PUSH
88760: LD_OWVAR 3
88764: PUSH
88765: LD_VAR 0 4
88769: PUSH
88770: LD_VAR 0 7
88774: ARRAY
88775: DIFF
88776: PPUSH
88777: LD_VAR 0 4
88781: PUSH
88782: LD_VAR 0 7
88786: ARRAY
88787: PPUSH
88788: CALL_OW 74
88792: ST_TO_ADDR
// if not k then
88793: LD_VAR 0 9
88797: NOT
88798: IFFALSE 88802
// continue ;
88800: GO 85243
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
88802: LD_VAR 0 9
88806: PUSH
88807: LD_INT 81
88809: PUSH
88810: LD_VAR 0 4
88814: PUSH
88815: LD_VAR 0 7
88819: ARRAY
88820: PPUSH
88821: CALL_OW 255
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: PPUSH
88830: CALL_OW 69
88834: IN
88835: PUSH
88836: LD_VAR 0 9
88840: PPUSH
88841: LD_VAR 0 4
88845: PUSH
88846: LD_VAR 0 7
88850: ARRAY
88851: PPUSH
88852: CALL_OW 296
88856: PUSH
88857: LD_INT 5
88859: LESS
88860: AND
88861: IFFALSE 88878
// ComAutodestruct ( group [ i ] ) ;
88863: LD_VAR 0 4
88867: PUSH
88868: LD_VAR 0 7
88872: ARRAY
88873: PPUSH
88874: CALL 83338 0 1
// end ; if f_attack_depot then
88878: LD_VAR 0 25
88882: IFFALSE 88994
// begin k := 6 ;
88884: LD_ADDR_VAR 0 9
88888: PUSH
88889: LD_INT 6
88891: ST_TO_ADDR
// if tmp < k then
88892: LD_VAR 0 14
88896: PUSH
88897: LD_VAR 0 9
88901: LESS
88902: IFFALSE 88914
// k := tmp ;
88904: LD_ADDR_VAR 0 9
88908: PUSH
88909: LD_VAR 0 14
88913: ST_TO_ADDR
// for j = 1 to k do
88914: LD_ADDR_VAR 0 8
88918: PUSH
88919: DOUBLE
88920: LD_INT 1
88922: DEC
88923: ST_TO_ADDR
88924: LD_VAR 0 9
88928: PUSH
88929: FOR_TO
88930: IFFALSE 88992
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
88932: LD_VAR 0 8
88936: PPUSH
88937: CALL_OW 266
88941: PUSH
88942: LD_INT 0
88944: PUSH
88945: LD_INT 1
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: IN
88952: IFFALSE 88990
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88954: LD_VAR 0 4
88958: PUSH
88959: LD_VAR 0 7
88963: ARRAY
88964: PPUSH
88965: LD_VAR 0 14
88969: PUSH
88970: LD_VAR 0 8
88974: ARRAY
88975: PPUSH
88976: CALL_OW 115
// attacking := true ;
88980: LD_ADDR_VAR 0 29
88984: PUSH
88985: LD_INT 1
88987: ST_TO_ADDR
// break ;
88988: GO 88992
// end ;
88990: GO 88929
88992: POP
88993: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
88994: LD_VAR 0 4
88998: PUSH
88999: LD_VAR 0 7
89003: ARRAY
89004: PPUSH
89005: CALL_OW 302
89009: PUSH
89010: LD_VAR 0 29
89014: NOT
89015: AND
89016: IFFALSE 89338
// begin if GetTag ( group [ i ] ) = 71 then
89018: LD_VAR 0 4
89022: PUSH
89023: LD_VAR 0 7
89027: ARRAY
89028: PPUSH
89029: CALL_OW 110
89033: PUSH
89034: LD_INT 71
89036: EQUAL
89037: IFFALSE 89078
// begin if HasTask ( group [ i ] ) then
89039: LD_VAR 0 4
89043: PUSH
89044: LD_VAR 0 7
89048: ARRAY
89049: PPUSH
89050: CALL_OW 314
89054: IFFALSE 89060
// continue else
89056: GO 85243
89058: GO 89078
// SetTag ( group [ i ] , 0 ) ;
89060: LD_VAR 0 4
89064: PUSH
89065: LD_VAR 0 7
89069: ARRAY
89070: PPUSH
89071: LD_INT 0
89073: PPUSH
89074: CALL_OW 109
// end ; k := 8 ;
89078: LD_ADDR_VAR 0 9
89082: PUSH
89083: LD_INT 8
89085: ST_TO_ADDR
// x := 0 ;
89086: LD_ADDR_VAR 0 10
89090: PUSH
89091: LD_INT 0
89093: ST_TO_ADDR
// if tmp < k then
89094: LD_VAR 0 14
89098: PUSH
89099: LD_VAR 0 9
89103: LESS
89104: IFFALSE 89116
// k := tmp ;
89106: LD_ADDR_VAR 0 9
89110: PUSH
89111: LD_VAR 0 14
89115: ST_TO_ADDR
// for j = 1 to k do
89116: LD_ADDR_VAR 0 8
89120: PUSH
89121: DOUBLE
89122: LD_INT 1
89124: DEC
89125: ST_TO_ADDR
89126: LD_VAR 0 9
89130: PUSH
89131: FOR_TO
89132: IFFALSE 89230
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
89134: LD_VAR 0 14
89138: PUSH
89139: LD_VAR 0 8
89143: ARRAY
89144: PPUSH
89145: CALL_OW 247
89149: PUSH
89150: LD_INT 1
89152: EQUAL
89153: PUSH
89154: LD_VAR 0 14
89158: PUSH
89159: LD_VAR 0 8
89163: ARRAY
89164: PPUSH
89165: CALL_OW 256
89169: PUSH
89170: LD_INT 250
89172: LESS
89173: PUSH
89174: LD_VAR 0 20
89178: AND
89179: PUSH
89180: LD_VAR 0 20
89184: NOT
89185: PUSH
89186: LD_VAR 0 14
89190: PUSH
89191: LD_VAR 0 8
89195: ARRAY
89196: PPUSH
89197: CALL_OW 256
89201: PUSH
89202: LD_INT 250
89204: GREATEREQUAL
89205: AND
89206: OR
89207: AND
89208: IFFALSE 89228
// begin x := tmp [ j ] ;
89210: LD_ADDR_VAR 0 10
89214: PUSH
89215: LD_VAR 0 14
89219: PUSH
89220: LD_VAR 0 8
89224: ARRAY
89225: ST_TO_ADDR
// break ;
89226: GO 89230
// end ;
89228: GO 89131
89230: POP
89231: POP
// if x then
89232: LD_VAR 0 10
89236: IFFALSE 89260
// ComAttackUnit ( group [ i ] , x ) else
89238: LD_VAR 0 4
89242: PUSH
89243: LD_VAR 0 7
89247: ARRAY
89248: PPUSH
89249: LD_VAR 0 10
89253: PPUSH
89254: CALL_OW 115
89258: GO 89284
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89260: LD_VAR 0 4
89264: PUSH
89265: LD_VAR 0 7
89269: ARRAY
89270: PPUSH
89271: LD_VAR 0 14
89275: PUSH
89276: LD_INT 1
89278: ARRAY
89279: PPUSH
89280: CALL_OW 115
// if not HasTask ( group [ i ] ) then
89284: LD_VAR 0 4
89288: PUSH
89289: LD_VAR 0 7
89293: ARRAY
89294: PPUSH
89295: CALL_OW 314
89299: NOT
89300: IFFALSE 89338
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
89302: LD_VAR 0 4
89306: PUSH
89307: LD_VAR 0 7
89311: ARRAY
89312: PPUSH
89313: LD_VAR 0 14
89317: PPUSH
89318: LD_VAR 0 4
89322: PUSH
89323: LD_VAR 0 7
89327: ARRAY
89328: PPUSH
89329: CALL_OW 74
89333: PPUSH
89334: CALL_OW 115
// end ; end ; end ;
89338: GO 85243
89340: POP
89341: POP
// wait ( 0 0$1 ) ;
89342: LD_INT 35
89344: PPUSH
89345: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
89349: LD_VAR 0 4
89353: PUSH
89354: EMPTY
89355: EQUAL
89356: PUSH
89357: LD_INT 81
89359: PUSH
89360: LD_VAR 0 35
89364: PUSH
89365: EMPTY
89366: LIST
89367: LIST
89368: PPUSH
89369: CALL_OW 69
89373: NOT
89374: OR
89375: IFFALSE 85228
// end ;
89377: LD_VAR 0 2
89381: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
89382: LD_INT 0
89384: PPUSH
89385: PPUSH
89386: PPUSH
89387: PPUSH
// if not base_units then
89388: LD_VAR 0 1
89392: NOT
89393: IFFALSE 89397
// exit ;
89395: GO 89484
// result := false ;
89397: LD_ADDR_VAR 0 2
89401: PUSH
89402: LD_INT 0
89404: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
89405: LD_ADDR_VAR 0 5
89409: PUSH
89410: LD_VAR 0 1
89414: PPUSH
89415: LD_INT 21
89417: PUSH
89418: LD_INT 3
89420: PUSH
89421: EMPTY
89422: LIST
89423: LIST
89424: PPUSH
89425: CALL_OW 72
89429: ST_TO_ADDR
// if not tmp then
89430: LD_VAR 0 5
89434: NOT
89435: IFFALSE 89439
// exit ;
89437: GO 89484
// for i in tmp do
89439: LD_ADDR_VAR 0 3
89443: PUSH
89444: LD_VAR 0 5
89448: PUSH
89449: FOR_IN
89450: IFFALSE 89482
// begin result := EnemyInRange ( i , 22 ) ;
89452: LD_ADDR_VAR 0 2
89456: PUSH
89457: LD_VAR 0 3
89461: PPUSH
89462: LD_INT 22
89464: PPUSH
89465: CALL 83021 0 2
89469: ST_TO_ADDR
// if result then
89470: LD_VAR 0 2
89474: IFFALSE 89480
// exit ;
89476: POP
89477: POP
89478: GO 89484
// end ;
89480: GO 89449
89482: POP
89483: POP
// end ;
89484: LD_VAR 0 2
89488: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
89489: LD_INT 0
89491: PPUSH
89492: PPUSH
// if not units then
89493: LD_VAR 0 1
89497: NOT
89498: IFFALSE 89502
// exit ;
89500: GO 89572
// result := [ ] ;
89502: LD_ADDR_VAR 0 3
89506: PUSH
89507: EMPTY
89508: ST_TO_ADDR
// for i in units do
89509: LD_ADDR_VAR 0 4
89513: PUSH
89514: LD_VAR 0 1
89518: PUSH
89519: FOR_IN
89520: IFFALSE 89570
// if GetTag ( i ) = tag then
89522: LD_VAR 0 4
89526: PPUSH
89527: CALL_OW 110
89531: PUSH
89532: LD_VAR 0 2
89536: EQUAL
89537: IFFALSE 89568
// result := Insert ( result , result + 1 , i ) ;
89539: LD_ADDR_VAR 0 3
89543: PUSH
89544: LD_VAR 0 3
89548: PPUSH
89549: LD_VAR 0 3
89553: PUSH
89554: LD_INT 1
89556: PLUS
89557: PPUSH
89558: LD_VAR 0 4
89562: PPUSH
89563: CALL_OW 2
89567: ST_TO_ADDR
89568: GO 89519
89570: POP
89571: POP
// end ;
89572: LD_VAR 0 3
89576: RET
// export function IsDriver ( un ) ; begin
89577: LD_INT 0
89579: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
89580: LD_ADDR_VAR 0 2
89584: PUSH
89585: LD_VAR 0 1
89589: PUSH
89590: LD_INT 55
89592: PUSH
89593: EMPTY
89594: LIST
89595: PPUSH
89596: CALL_OW 69
89600: IN
89601: ST_TO_ADDR
// end ;
89602: LD_VAR 0 2
89606: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
89607: LD_INT 0
89609: PPUSH
89610: PPUSH
// list := [ ] ;
89611: LD_ADDR_VAR 0 5
89615: PUSH
89616: EMPTY
89617: ST_TO_ADDR
// case d of 0 :
89618: LD_VAR 0 3
89622: PUSH
89623: LD_INT 0
89625: DOUBLE
89626: EQUAL
89627: IFTRUE 89631
89629: GO 89764
89631: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
89632: LD_ADDR_VAR 0 5
89636: PUSH
89637: LD_VAR 0 1
89641: PUSH
89642: LD_INT 4
89644: MINUS
89645: PUSH
89646: LD_VAR 0 2
89650: PUSH
89651: LD_INT 4
89653: MINUS
89654: PUSH
89655: LD_INT 2
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: LIST
89662: PUSH
89663: LD_VAR 0 1
89667: PUSH
89668: LD_INT 3
89670: MINUS
89671: PUSH
89672: LD_VAR 0 2
89676: PUSH
89677: LD_INT 1
89679: PUSH
89680: EMPTY
89681: LIST
89682: LIST
89683: LIST
89684: PUSH
89685: LD_VAR 0 1
89689: PUSH
89690: LD_INT 4
89692: PLUS
89693: PUSH
89694: LD_VAR 0 2
89698: PUSH
89699: LD_INT 4
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: LIST
89706: PUSH
89707: LD_VAR 0 1
89711: PUSH
89712: LD_INT 3
89714: PLUS
89715: PUSH
89716: LD_VAR 0 2
89720: PUSH
89721: LD_INT 3
89723: PLUS
89724: PUSH
89725: LD_INT 5
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: LIST
89732: PUSH
89733: LD_VAR 0 1
89737: PUSH
89738: LD_VAR 0 2
89742: PUSH
89743: LD_INT 4
89745: PLUS
89746: PUSH
89747: LD_INT 0
89749: PUSH
89750: EMPTY
89751: LIST
89752: LIST
89753: LIST
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: LIST
89759: LIST
89760: LIST
89761: ST_TO_ADDR
// end ; 1 :
89762: GO 90462
89764: LD_INT 1
89766: DOUBLE
89767: EQUAL
89768: IFTRUE 89772
89770: GO 89905
89772: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
89773: LD_ADDR_VAR 0 5
89777: PUSH
89778: LD_VAR 0 1
89782: PUSH
89783: LD_VAR 0 2
89787: PUSH
89788: LD_INT 4
89790: MINUS
89791: PUSH
89792: LD_INT 3
89794: PUSH
89795: EMPTY
89796: LIST
89797: LIST
89798: LIST
89799: PUSH
89800: LD_VAR 0 1
89804: PUSH
89805: LD_INT 3
89807: MINUS
89808: PUSH
89809: LD_VAR 0 2
89813: PUSH
89814: LD_INT 3
89816: MINUS
89817: PUSH
89818: LD_INT 2
89820: PUSH
89821: EMPTY
89822: LIST
89823: LIST
89824: LIST
89825: PUSH
89826: LD_VAR 0 1
89830: PUSH
89831: LD_INT 4
89833: MINUS
89834: PUSH
89835: LD_VAR 0 2
89839: PUSH
89840: LD_INT 1
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: LIST
89847: PUSH
89848: LD_VAR 0 1
89852: PUSH
89853: LD_VAR 0 2
89857: PUSH
89858: LD_INT 3
89860: PLUS
89861: PUSH
89862: LD_INT 0
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: LIST
89869: PUSH
89870: LD_VAR 0 1
89874: PUSH
89875: LD_INT 4
89877: PLUS
89878: PUSH
89879: LD_VAR 0 2
89883: PUSH
89884: LD_INT 4
89886: PLUS
89887: PUSH
89888: LD_INT 5
89890: PUSH
89891: EMPTY
89892: LIST
89893: LIST
89894: LIST
89895: PUSH
89896: EMPTY
89897: LIST
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: ST_TO_ADDR
// end ; 2 :
89903: GO 90462
89905: LD_INT 2
89907: DOUBLE
89908: EQUAL
89909: IFTRUE 89913
89911: GO 90042
89913: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
89914: LD_ADDR_VAR 0 5
89918: PUSH
89919: LD_VAR 0 1
89923: PUSH
89924: LD_VAR 0 2
89928: PUSH
89929: LD_INT 3
89931: MINUS
89932: PUSH
89933: LD_INT 3
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: LIST
89940: PUSH
89941: LD_VAR 0 1
89945: PUSH
89946: LD_INT 4
89948: PLUS
89949: PUSH
89950: LD_VAR 0 2
89954: PUSH
89955: LD_INT 4
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: LIST
89962: PUSH
89963: LD_VAR 0 1
89967: PUSH
89968: LD_VAR 0 2
89972: PUSH
89973: LD_INT 4
89975: PLUS
89976: PUSH
89977: LD_INT 0
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: LIST
89984: PUSH
89985: LD_VAR 0 1
89989: PUSH
89990: LD_INT 3
89992: MINUS
89993: PUSH
89994: LD_VAR 0 2
89998: PUSH
89999: LD_INT 1
90001: PUSH
90002: EMPTY
90003: LIST
90004: LIST
90005: LIST
90006: PUSH
90007: LD_VAR 0 1
90011: PUSH
90012: LD_INT 4
90014: MINUS
90015: PUSH
90016: LD_VAR 0 2
90020: PUSH
90021: LD_INT 4
90023: MINUS
90024: PUSH
90025: LD_INT 2
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: LIST
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: ST_TO_ADDR
// end ; 3 :
90040: GO 90462
90042: LD_INT 3
90044: DOUBLE
90045: EQUAL
90046: IFTRUE 90050
90048: GO 90183
90050: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
90051: LD_ADDR_VAR 0 5
90055: PUSH
90056: LD_VAR 0 1
90060: PUSH
90061: LD_INT 3
90063: PLUS
90064: PUSH
90065: LD_VAR 0 2
90069: PUSH
90070: LD_INT 4
90072: PUSH
90073: EMPTY
90074: LIST
90075: LIST
90076: LIST
90077: PUSH
90078: LD_VAR 0 1
90082: PUSH
90083: LD_INT 4
90085: PLUS
90086: PUSH
90087: LD_VAR 0 2
90091: PUSH
90092: LD_INT 4
90094: PLUS
90095: PUSH
90096: LD_INT 5
90098: PUSH
90099: EMPTY
90100: LIST
90101: LIST
90102: LIST
90103: PUSH
90104: LD_VAR 0 1
90108: PUSH
90109: LD_INT 4
90111: MINUS
90112: PUSH
90113: LD_VAR 0 2
90117: PUSH
90118: LD_INT 1
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: LIST
90125: PUSH
90126: LD_VAR 0 1
90130: PUSH
90131: LD_VAR 0 2
90135: PUSH
90136: LD_INT 4
90138: MINUS
90139: PUSH
90140: LD_INT 3
90142: PUSH
90143: EMPTY
90144: LIST
90145: LIST
90146: LIST
90147: PUSH
90148: LD_VAR 0 1
90152: PUSH
90153: LD_INT 3
90155: MINUS
90156: PUSH
90157: LD_VAR 0 2
90161: PUSH
90162: LD_INT 3
90164: MINUS
90165: PUSH
90166: LD_INT 2
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: LIST
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: ST_TO_ADDR
// end ; 4 :
90181: GO 90462
90183: LD_INT 4
90185: DOUBLE
90186: EQUAL
90187: IFTRUE 90191
90189: GO 90324
90191: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
90192: LD_ADDR_VAR 0 5
90196: PUSH
90197: LD_VAR 0 1
90201: PUSH
90202: LD_VAR 0 2
90206: PUSH
90207: LD_INT 4
90209: PLUS
90210: PUSH
90211: LD_INT 0
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: LIST
90218: PUSH
90219: LD_VAR 0 1
90223: PUSH
90224: LD_INT 3
90226: PLUS
90227: PUSH
90228: LD_VAR 0 2
90232: PUSH
90233: LD_INT 3
90235: PLUS
90236: PUSH
90237: LD_INT 5
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: LIST
90244: PUSH
90245: LD_VAR 0 1
90249: PUSH
90250: LD_INT 4
90252: PLUS
90253: PUSH
90254: LD_VAR 0 2
90258: PUSH
90259: LD_INT 4
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: LIST
90266: PUSH
90267: LD_VAR 0 1
90271: PUSH
90272: LD_VAR 0 2
90276: PUSH
90277: LD_INT 3
90279: MINUS
90280: PUSH
90281: LD_INT 3
90283: PUSH
90284: EMPTY
90285: LIST
90286: LIST
90287: LIST
90288: PUSH
90289: LD_VAR 0 1
90293: PUSH
90294: LD_INT 4
90296: MINUS
90297: PUSH
90298: LD_VAR 0 2
90302: PUSH
90303: LD_INT 4
90305: MINUS
90306: PUSH
90307: LD_INT 2
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: LIST
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: ST_TO_ADDR
// end ; 5 :
90322: GO 90462
90324: LD_INT 5
90326: DOUBLE
90327: EQUAL
90328: IFTRUE 90332
90330: GO 90461
90332: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
90333: LD_ADDR_VAR 0 5
90337: PUSH
90338: LD_VAR 0 1
90342: PUSH
90343: LD_INT 4
90345: MINUS
90346: PUSH
90347: LD_VAR 0 2
90351: PUSH
90352: LD_INT 1
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: LIST
90359: PUSH
90360: LD_VAR 0 1
90364: PUSH
90365: LD_VAR 0 2
90369: PUSH
90370: LD_INT 4
90372: MINUS
90373: PUSH
90374: LD_INT 3
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: LIST
90381: PUSH
90382: LD_VAR 0 1
90386: PUSH
90387: LD_INT 4
90389: PLUS
90390: PUSH
90391: LD_VAR 0 2
90395: PUSH
90396: LD_INT 4
90398: PLUS
90399: PUSH
90400: LD_INT 5
90402: PUSH
90403: EMPTY
90404: LIST
90405: LIST
90406: LIST
90407: PUSH
90408: LD_VAR 0 1
90412: PUSH
90413: LD_INT 3
90415: PLUS
90416: PUSH
90417: LD_VAR 0 2
90421: PUSH
90422: LD_INT 4
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: LIST
90429: PUSH
90430: LD_VAR 0 1
90434: PUSH
90435: LD_VAR 0 2
90439: PUSH
90440: LD_INT 3
90442: PLUS
90443: PUSH
90444: LD_INT 0
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: LIST
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: LIST
90456: LIST
90457: LIST
90458: ST_TO_ADDR
// end ; end ;
90459: GO 90462
90461: POP
// result := list ;
90462: LD_ADDR_VAR 0 4
90466: PUSH
90467: LD_VAR 0 5
90471: ST_TO_ADDR
// end ;
90472: LD_VAR 0 4
90476: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
90477: LD_INT 0
90479: PPUSH
90480: PPUSH
90481: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
90482: LD_VAR 0 1
90486: NOT
90487: PUSH
90488: LD_VAR 0 2
90492: PUSH
90493: LD_INT 1
90495: PUSH
90496: LD_INT 2
90498: PUSH
90499: LD_INT 3
90501: PUSH
90502: LD_INT 4
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: IN
90511: NOT
90512: OR
90513: IFFALSE 90517
// exit ;
90515: GO 90609
// tmp := [ ] ;
90517: LD_ADDR_VAR 0 5
90521: PUSH
90522: EMPTY
90523: ST_TO_ADDR
// for i in units do
90524: LD_ADDR_VAR 0 4
90528: PUSH
90529: LD_VAR 0 1
90533: PUSH
90534: FOR_IN
90535: IFFALSE 90578
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
90537: LD_ADDR_VAR 0 5
90541: PUSH
90542: LD_VAR 0 5
90546: PPUSH
90547: LD_VAR 0 5
90551: PUSH
90552: LD_INT 1
90554: PLUS
90555: PPUSH
90556: LD_VAR 0 4
90560: PPUSH
90561: LD_VAR 0 2
90565: PPUSH
90566: CALL_OW 259
90570: PPUSH
90571: CALL_OW 2
90575: ST_TO_ADDR
90576: GO 90534
90578: POP
90579: POP
// if not tmp then
90580: LD_VAR 0 5
90584: NOT
90585: IFFALSE 90589
// exit ;
90587: GO 90609
// result := SortListByListDesc ( units , tmp ) ;
90589: LD_ADDR_VAR 0 3
90593: PUSH
90594: LD_VAR 0 1
90598: PPUSH
90599: LD_VAR 0 5
90603: PPUSH
90604: CALL_OW 77
90608: ST_TO_ADDR
// end ;
90609: LD_VAR 0 3
90613: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
90614: LD_INT 0
90616: PPUSH
90617: PPUSH
90618: PPUSH
// x := GetX ( building ) ;
90619: LD_ADDR_VAR 0 4
90623: PUSH
90624: LD_VAR 0 2
90628: PPUSH
90629: CALL_OW 250
90633: ST_TO_ADDR
// y := GetY ( building ) ;
90634: LD_ADDR_VAR 0 5
90638: PUSH
90639: LD_VAR 0 2
90643: PPUSH
90644: CALL_OW 251
90648: ST_TO_ADDR
// if GetTaskList ( unit ) then
90649: LD_VAR 0 1
90653: PPUSH
90654: CALL_OW 437
90658: IFFALSE 90753
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
90660: LD_STRING e
90662: PUSH
90663: LD_VAR 0 1
90667: PPUSH
90668: CALL_OW 437
90672: PUSH
90673: LD_INT 1
90675: ARRAY
90676: PUSH
90677: LD_INT 1
90679: ARRAY
90680: EQUAL
90681: PUSH
90682: LD_VAR 0 4
90686: PUSH
90687: LD_VAR 0 1
90691: PPUSH
90692: CALL_OW 437
90696: PUSH
90697: LD_INT 1
90699: ARRAY
90700: PUSH
90701: LD_INT 2
90703: ARRAY
90704: EQUAL
90705: AND
90706: PUSH
90707: LD_VAR 0 5
90711: PUSH
90712: LD_VAR 0 1
90716: PPUSH
90717: CALL_OW 437
90721: PUSH
90722: LD_INT 1
90724: ARRAY
90725: PUSH
90726: LD_INT 3
90728: ARRAY
90729: EQUAL
90730: AND
90731: IFFALSE 90743
// result := true else
90733: LD_ADDR_VAR 0 3
90737: PUSH
90738: LD_INT 1
90740: ST_TO_ADDR
90741: GO 90751
// result := false ;
90743: LD_ADDR_VAR 0 3
90747: PUSH
90748: LD_INT 0
90750: ST_TO_ADDR
// end else
90751: GO 90761
// result := false ;
90753: LD_ADDR_VAR 0 3
90757: PUSH
90758: LD_INT 0
90760: ST_TO_ADDR
// end ;
90761: LD_VAR 0 3
90765: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
90766: LD_INT 0
90768: PPUSH
90769: PPUSH
90770: PPUSH
90771: PPUSH
// if not unit or not area then
90772: LD_VAR 0 1
90776: NOT
90777: PUSH
90778: LD_VAR 0 2
90782: NOT
90783: OR
90784: IFFALSE 90788
// exit ;
90786: GO 90952
// tmp := AreaToList ( area , i ) ;
90788: LD_ADDR_VAR 0 6
90792: PUSH
90793: LD_VAR 0 2
90797: PPUSH
90798: LD_VAR 0 5
90802: PPUSH
90803: CALL_OW 517
90807: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
90808: LD_ADDR_VAR 0 5
90812: PUSH
90813: DOUBLE
90814: LD_INT 1
90816: DEC
90817: ST_TO_ADDR
90818: LD_VAR 0 6
90822: PUSH
90823: LD_INT 1
90825: ARRAY
90826: PUSH
90827: FOR_TO
90828: IFFALSE 90950
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
90830: LD_ADDR_VAR 0 7
90834: PUSH
90835: LD_VAR 0 6
90839: PUSH
90840: LD_INT 1
90842: ARRAY
90843: PUSH
90844: LD_VAR 0 5
90848: ARRAY
90849: PUSH
90850: LD_VAR 0 6
90854: PUSH
90855: LD_INT 2
90857: ARRAY
90858: PUSH
90859: LD_VAR 0 5
90863: ARRAY
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
90869: LD_VAR 0 7
90873: PUSH
90874: LD_INT 1
90876: ARRAY
90877: PPUSH
90878: LD_VAR 0 7
90882: PUSH
90883: LD_INT 2
90885: ARRAY
90886: PPUSH
90887: CALL_OW 428
90891: PUSH
90892: LD_INT 0
90894: EQUAL
90895: IFFALSE 90948
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
90897: LD_VAR 0 1
90901: PPUSH
90902: LD_VAR 0 7
90906: PUSH
90907: LD_INT 1
90909: ARRAY
90910: PPUSH
90911: LD_VAR 0 7
90915: PUSH
90916: LD_INT 2
90918: ARRAY
90919: PPUSH
90920: LD_VAR 0 3
90924: PPUSH
90925: CALL_OW 48
// result := IsPlaced ( unit ) ;
90929: LD_ADDR_VAR 0 4
90933: PUSH
90934: LD_VAR 0 1
90938: PPUSH
90939: CALL_OW 305
90943: ST_TO_ADDR
// exit ;
90944: POP
90945: POP
90946: GO 90952
// end ; end ;
90948: GO 90827
90950: POP
90951: POP
// end ;
90952: LD_VAR 0 4
90956: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
90957: LD_INT 0
90959: PPUSH
90960: PPUSH
90961: PPUSH
// if not side or side > 8 then
90962: LD_VAR 0 1
90966: NOT
90967: PUSH
90968: LD_VAR 0 1
90972: PUSH
90973: LD_INT 8
90975: GREATER
90976: OR
90977: IFFALSE 90981
// exit ;
90979: GO 91168
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
90981: LD_ADDR_VAR 0 4
90985: PUSH
90986: LD_INT 22
90988: PUSH
90989: LD_VAR 0 1
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: PUSH
90998: LD_INT 21
91000: PUSH
91001: LD_INT 3
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: EMPTY
91009: LIST
91010: LIST
91011: PPUSH
91012: CALL_OW 69
91016: ST_TO_ADDR
// if not tmp then
91017: LD_VAR 0 4
91021: NOT
91022: IFFALSE 91026
// exit ;
91024: GO 91168
// enable_addtolog := true ;
91026: LD_ADDR_OWVAR 81
91030: PUSH
91031: LD_INT 1
91033: ST_TO_ADDR
// AddToLog ( [ ) ;
91034: LD_STRING [
91036: PPUSH
91037: CALL_OW 561
// for i in tmp do
91041: LD_ADDR_VAR 0 3
91045: PUSH
91046: LD_VAR 0 4
91050: PUSH
91051: FOR_IN
91052: IFFALSE 91159
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
91054: LD_STRING [
91056: PUSH
91057: LD_VAR 0 3
91061: PPUSH
91062: CALL_OW 266
91066: STR
91067: PUSH
91068: LD_STRING , 
91070: STR
91071: PUSH
91072: LD_VAR 0 3
91076: PPUSH
91077: CALL_OW 250
91081: STR
91082: PUSH
91083: LD_STRING , 
91085: STR
91086: PUSH
91087: LD_VAR 0 3
91091: PPUSH
91092: CALL_OW 251
91096: STR
91097: PUSH
91098: LD_STRING , 
91100: STR
91101: PUSH
91102: LD_VAR 0 3
91106: PPUSH
91107: CALL_OW 254
91111: STR
91112: PUSH
91113: LD_STRING , 
91115: STR
91116: PUSH
91117: LD_VAR 0 3
91121: PPUSH
91122: LD_INT 1
91124: PPUSH
91125: CALL_OW 268
91129: STR
91130: PUSH
91131: LD_STRING , 
91133: STR
91134: PUSH
91135: LD_VAR 0 3
91139: PPUSH
91140: LD_INT 2
91142: PPUSH
91143: CALL_OW 268
91147: STR
91148: PUSH
91149: LD_STRING ],
91151: STR
91152: PPUSH
91153: CALL_OW 561
// end ;
91157: GO 91051
91159: POP
91160: POP
// AddToLog ( ]; ) ;
91161: LD_STRING ];
91163: PPUSH
91164: CALL_OW 561
// end ;
91168: LD_VAR 0 2
91172: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
91173: LD_INT 0
91175: PPUSH
91176: PPUSH
91177: PPUSH
91178: PPUSH
91179: PPUSH
// if not area or not rate or not max then
91180: LD_VAR 0 1
91184: NOT
91185: PUSH
91186: LD_VAR 0 2
91190: NOT
91191: OR
91192: PUSH
91193: LD_VAR 0 4
91197: NOT
91198: OR
91199: IFFALSE 91203
// exit ;
91201: GO 91395
// while 1 do
91203: LD_INT 1
91205: IFFALSE 91395
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
91207: LD_ADDR_VAR 0 9
91211: PUSH
91212: LD_VAR 0 1
91216: PPUSH
91217: LD_INT 1
91219: PPUSH
91220: CALL_OW 287
91224: PUSH
91225: LD_INT 10
91227: MUL
91228: ST_TO_ADDR
// r := rate / 10 ;
91229: LD_ADDR_VAR 0 7
91233: PUSH
91234: LD_VAR 0 2
91238: PUSH
91239: LD_INT 10
91241: DIVREAL
91242: ST_TO_ADDR
// time := 1 1$00 ;
91243: LD_ADDR_VAR 0 8
91247: PUSH
91248: LD_INT 2100
91250: ST_TO_ADDR
// if amount < min then
91251: LD_VAR 0 9
91255: PUSH
91256: LD_VAR 0 3
91260: LESS
91261: IFFALSE 91279
// r := r * 2 else
91263: LD_ADDR_VAR 0 7
91267: PUSH
91268: LD_VAR 0 7
91272: PUSH
91273: LD_INT 2
91275: MUL
91276: ST_TO_ADDR
91277: GO 91305
// if amount > max then
91279: LD_VAR 0 9
91283: PUSH
91284: LD_VAR 0 4
91288: GREATER
91289: IFFALSE 91305
// r := r / 2 ;
91291: LD_ADDR_VAR 0 7
91295: PUSH
91296: LD_VAR 0 7
91300: PUSH
91301: LD_INT 2
91303: DIVREAL
91304: ST_TO_ADDR
// time := time / r ;
91305: LD_ADDR_VAR 0 8
91309: PUSH
91310: LD_VAR 0 8
91314: PUSH
91315: LD_VAR 0 7
91319: DIVREAL
91320: ST_TO_ADDR
// if time < 0 then
91321: LD_VAR 0 8
91325: PUSH
91326: LD_INT 0
91328: LESS
91329: IFFALSE 91346
// time := time * - 1 ;
91331: LD_ADDR_VAR 0 8
91335: PUSH
91336: LD_VAR 0 8
91340: PUSH
91341: LD_INT 1
91343: NEG
91344: MUL
91345: ST_TO_ADDR
// wait ( time ) ;
91346: LD_VAR 0 8
91350: PPUSH
91351: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
91355: LD_INT 35
91357: PPUSH
91358: LD_INT 875
91360: PPUSH
91361: CALL_OW 12
91365: PPUSH
91366: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
91370: LD_INT 1
91372: PPUSH
91373: LD_INT 5
91375: PPUSH
91376: CALL_OW 12
91380: PPUSH
91381: LD_VAR 0 1
91385: PPUSH
91386: LD_INT 1
91388: PPUSH
91389: CALL_OW 55
// end ;
91393: GO 91203
// end ;
91395: LD_VAR 0 5
91399: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
91400: LD_INT 0
91402: PPUSH
91403: PPUSH
91404: PPUSH
91405: PPUSH
91406: PPUSH
91407: PPUSH
91408: PPUSH
91409: PPUSH
// if not turrets or not factories then
91410: LD_VAR 0 1
91414: NOT
91415: PUSH
91416: LD_VAR 0 2
91420: NOT
91421: OR
91422: IFFALSE 91426
// exit ;
91424: GO 91733
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
91426: LD_ADDR_VAR 0 10
91430: PUSH
91431: LD_INT 5
91433: PUSH
91434: LD_INT 6
91436: PUSH
91437: EMPTY
91438: LIST
91439: LIST
91440: PUSH
91441: LD_INT 2
91443: PUSH
91444: LD_INT 4
91446: PUSH
91447: EMPTY
91448: LIST
91449: LIST
91450: PUSH
91451: LD_INT 3
91453: PUSH
91454: LD_INT 5
91456: PUSH
91457: EMPTY
91458: LIST
91459: LIST
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 24
91468: PUSH
91469: LD_INT 25
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 23
91478: PUSH
91479: LD_INT 27
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: EMPTY
91487: LIST
91488: LIST
91489: PUSH
91490: LD_INT 42
91492: PUSH
91493: LD_INT 43
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: LD_INT 44
91502: PUSH
91503: LD_INT 46
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: PUSH
91510: LD_INT 45
91512: PUSH
91513: LD_INT 47
91515: PUSH
91516: EMPTY
91517: LIST
91518: LIST
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: LIST
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: LIST
91529: ST_TO_ADDR
// result := [ ] ;
91530: LD_ADDR_VAR 0 3
91534: PUSH
91535: EMPTY
91536: ST_TO_ADDR
// for i in turrets do
91537: LD_ADDR_VAR 0 4
91541: PUSH
91542: LD_VAR 0 1
91546: PUSH
91547: FOR_IN
91548: IFFALSE 91731
// begin nat := GetNation ( i ) ;
91550: LD_ADDR_VAR 0 7
91554: PUSH
91555: LD_VAR 0 4
91559: PPUSH
91560: CALL_OW 248
91564: ST_TO_ADDR
// weapon := 0 ;
91565: LD_ADDR_VAR 0 8
91569: PUSH
91570: LD_INT 0
91572: ST_TO_ADDR
// if not nat then
91573: LD_VAR 0 7
91577: NOT
91578: IFFALSE 91582
// continue ;
91580: GO 91547
// for j in list [ nat ] do
91582: LD_ADDR_VAR 0 5
91586: PUSH
91587: LD_VAR 0 10
91591: PUSH
91592: LD_VAR 0 7
91596: ARRAY
91597: PUSH
91598: FOR_IN
91599: IFFALSE 91640
// if GetBWeapon ( i ) = j [ 1 ] then
91601: LD_VAR 0 4
91605: PPUSH
91606: CALL_OW 269
91610: PUSH
91611: LD_VAR 0 5
91615: PUSH
91616: LD_INT 1
91618: ARRAY
91619: EQUAL
91620: IFFALSE 91638
// begin weapon := j [ 2 ] ;
91622: LD_ADDR_VAR 0 8
91626: PUSH
91627: LD_VAR 0 5
91631: PUSH
91632: LD_INT 2
91634: ARRAY
91635: ST_TO_ADDR
// break ;
91636: GO 91640
// end ;
91638: GO 91598
91640: POP
91641: POP
// if not weapon then
91642: LD_VAR 0 8
91646: NOT
91647: IFFALSE 91651
// continue ;
91649: GO 91547
// for k in factories do
91651: LD_ADDR_VAR 0 6
91655: PUSH
91656: LD_VAR 0 2
91660: PUSH
91661: FOR_IN
91662: IFFALSE 91727
// begin weapons := AvailableWeaponList ( k ) ;
91664: LD_ADDR_VAR 0 9
91668: PUSH
91669: LD_VAR 0 6
91673: PPUSH
91674: CALL_OW 478
91678: ST_TO_ADDR
// if not weapons then
91679: LD_VAR 0 9
91683: NOT
91684: IFFALSE 91688
// continue ;
91686: GO 91661
// if weapon in weapons then
91688: LD_VAR 0 8
91692: PUSH
91693: LD_VAR 0 9
91697: IN
91698: IFFALSE 91725
// begin result := [ i , weapon ] ;
91700: LD_ADDR_VAR 0 3
91704: PUSH
91705: LD_VAR 0 4
91709: PUSH
91710: LD_VAR 0 8
91714: PUSH
91715: EMPTY
91716: LIST
91717: LIST
91718: ST_TO_ADDR
// exit ;
91719: POP
91720: POP
91721: POP
91722: POP
91723: GO 91733
// end ; end ;
91725: GO 91661
91727: POP
91728: POP
// end ;
91729: GO 91547
91731: POP
91732: POP
// end ;
91733: LD_VAR 0 3
91737: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
91738: LD_INT 0
91740: PPUSH
// if not side or side > 8 then
91741: LD_VAR 0 3
91745: NOT
91746: PUSH
91747: LD_VAR 0 3
91751: PUSH
91752: LD_INT 8
91754: GREATER
91755: OR
91756: IFFALSE 91760
// exit ;
91758: GO 91819
// if not range then
91760: LD_VAR 0 4
91764: NOT
91765: IFFALSE 91776
// range := - 12 ;
91767: LD_ADDR_VAR 0 4
91771: PUSH
91772: LD_INT 12
91774: NEG
91775: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
91776: LD_VAR 0 1
91780: PPUSH
91781: LD_VAR 0 2
91785: PPUSH
91786: LD_VAR 0 3
91790: PPUSH
91791: LD_VAR 0 4
91795: PPUSH
91796: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
91800: LD_VAR 0 1
91804: PPUSH
91805: LD_VAR 0 2
91809: PPUSH
91810: LD_VAR 0 3
91814: PPUSH
91815: CALL_OW 331
// end ;
91819: LD_VAR 0 5
91823: RET
// export function Video ( mode ) ; begin
91824: LD_INT 0
91826: PPUSH
// ingame_video = mode ;
91827: LD_ADDR_OWVAR 52
91831: PUSH
91832: LD_VAR 0 1
91836: ST_TO_ADDR
// interface_hidden = mode ;
91837: LD_ADDR_OWVAR 54
91841: PUSH
91842: LD_VAR 0 1
91846: ST_TO_ADDR
// end ;
91847: LD_VAR 0 2
91851: RET
// export function Join ( array , element ) ; begin
91852: LD_INT 0
91854: PPUSH
// result := array ^ element ;
91855: LD_ADDR_VAR 0 3
91859: PUSH
91860: LD_VAR 0 1
91864: PUSH
91865: LD_VAR 0 2
91869: ADD
91870: ST_TO_ADDR
// end ;
91871: LD_VAR 0 3
91875: RET
// export function JoinUnion ( array , element ) ; begin
91876: LD_INT 0
91878: PPUSH
// result := array union element ;
91879: LD_ADDR_VAR 0 3
91883: PUSH
91884: LD_VAR 0 1
91888: PUSH
91889: LD_VAR 0 2
91893: UNION
91894: ST_TO_ADDR
// end ;
91895: LD_VAR 0 3
91899: RET
// export function GetBehemoths ( side ) ; begin
91900: LD_INT 0
91902: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
91903: LD_ADDR_VAR 0 2
91907: PUSH
91908: LD_INT 22
91910: PUSH
91911: LD_VAR 0 1
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: LD_INT 31
91922: PUSH
91923: LD_INT 25
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: PUSH
91930: EMPTY
91931: LIST
91932: LIST
91933: PPUSH
91934: CALL_OW 69
91938: ST_TO_ADDR
// end ;
91939: LD_VAR 0 2
91943: RET
// export function Shuffle ( array ) ; var i , index ; begin
91944: LD_INT 0
91946: PPUSH
91947: PPUSH
91948: PPUSH
// result := [ ] ;
91949: LD_ADDR_VAR 0 2
91953: PUSH
91954: EMPTY
91955: ST_TO_ADDR
// if not array then
91956: LD_VAR 0 1
91960: NOT
91961: IFFALSE 91965
// exit ;
91963: GO 92064
// Randomize ;
91965: CALL_OW 10
// for i = array downto 1 do
91969: LD_ADDR_VAR 0 3
91973: PUSH
91974: DOUBLE
91975: LD_VAR 0 1
91979: INC
91980: ST_TO_ADDR
91981: LD_INT 1
91983: PUSH
91984: FOR_DOWNTO
91985: IFFALSE 92062
// begin index := rand ( 1 , array ) ;
91987: LD_ADDR_VAR 0 4
91991: PUSH
91992: LD_INT 1
91994: PPUSH
91995: LD_VAR 0 1
91999: PPUSH
92000: CALL_OW 12
92004: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
92005: LD_ADDR_VAR 0 2
92009: PUSH
92010: LD_VAR 0 2
92014: PPUSH
92015: LD_VAR 0 2
92019: PUSH
92020: LD_INT 1
92022: PLUS
92023: PPUSH
92024: LD_VAR 0 1
92028: PUSH
92029: LD_VAR 0 4
92033: ARRAY
92034: PPUSH
92035: CALL_OW 2
92039: ST_TO_ADDR
// array := Delete ( array , index ) ;
92040: LD_ADDR_VAR 0 1
92044: PUSH
92045: LD_VAR 0 1
92049: PPUSH
92050: LD_VAR 0 4
92054: PPUSH
92055: CALL_OW 3
92059: ST_TO_ADDR
// end ;
92060: GO 91984
92062: POP
92063: POP
// end ;
92064: LD_VAR 0 2
92068: RET
// export function GetBaseMaterials ( base ) ; begin
92069: LD_INT 0
92071: PPUSH
// result := [ 0 , 0 , 0 ] ;
92072: LD_ADDR_VAR 0 2
92076: PUSH
92077: LD_INT 0
92079: PUSH
92080: LD_INT 0
92082: PUSH
92083: LD_INT 0
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: LIST
92090: ST_TO_ADDR
// if not base then
92091: LD_VAR 0 1
92095: NOT
92096: IFFALSE 92100
// exit ;
92098: GO 92149
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
92100: LD_ADDR_VAR 0 2
92104: PUSH
92105: LD_VAR 0 1
92109: PPUSH
92110: LD_INT 1
92112: PPUSH
92113: CALL_OW 275
92117: PUSH
92118: LD_VAR 0 1
92122: PPUSH
92123: LD_INT 2
92125: PPUSH
92126: CALL_OW 275
92130: PUSH
92131: LD_VAR 0 1
92135: PPUSH
92136: LD_INT 3
92138: PPUSH
92139: CALL_OW 275
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: LIST
92148: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
92149: LD_VAR 0 2
92153: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
92154: LD_INT 0
92156: PPUSH
92157: PPUSH
92158: PPUSH
92159: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
92160: LD_VAR 0 1
92164: PPUSH
92165: CALL_OW 264
92169: PUSH
92170: LD_EXP 71
92174: EQUAL
92175: IFFALSE 92247
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
92177: LD_INT 68
92179: PPUSH
92180: LD_VAR 0 1
92184: PPUSH
92185: CALL_OW 255
92189: PPUSH
92190: CALL_OW 321
92194: PUSH
92195: LD_INT 2
92197: EQUAL
92198: IFFALSE 92210
// eff := 70 else
92200: LD_ADDR_VAR 0 6
92204: PUSH
92205: LD_INT 70
92207: ST_TO_ADDR
92208: GO 92218
// eff := 30 ;
92210: LD_ADDR_VAR 0 6
92214: PUSH
92215: LD_INT 30
92217: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
92218: LD_VAR 0 1
92222: PPUSH
92223: CALL_OW 250
92227: PPUSH
92228: LD_VAR 0 1
92232: PPUSH
92233: CALL_OW 251
92237: PPUSH
92238: LD_VAR 0 6
92242: PPUSH
92243: CALL_OW 495
// end ; end ;
92247: LD_VAR 0 4
92251: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
92252: LD_INT 0
92254: PPUSH
92255: PPUSH
92256: PPUSH
92257: PPUSH
92258: PPUSH
92259: PPUSH
// if cmd = 124 then
92260: LD_VAR 0 1
92264: PUSH
92265: LD_INT 124
92267: EQUAL
92268: IFFALSE 92474
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
92270: LD_ADDR_VAR 0 5
92274: PUSH
92275: LD_INT 2
92277: PUSH
92278: LD_INT 34
92280: PUSH
92281: LD_INT 53
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 34
92290: PUSH
92291: LD_INT 14
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: LIST
92302: PPUSH
92303: CALL_OW 69
92307: ST_TO_ADDR
// if not tmp then
92308: LD_VAR 0 5
92312: NOT
92313: IFFALSE 92317
// exit ;
92315: GO 92474
// for i in tmp do
92317: LD_ADDR_VAR 0 3
92321: PUSH
92322: LD_VAR 0 5
92326: PUSH
92327: FOR_IN
92328: IFFALSE 92472
// begin taskList := GetTaskList ( i ) ;
92330: LD_ADDR_VAR 0 6
92334: PUSH
92335: LD_VAR 0 3
92339: PPUSH
92340: CALL_OW 437
92344: ST_TO_ADDR
// if not taskList then
92345: LD_VAR 0 6
92349: NOT
92350: IFFALSE 92354
// continue ;
92352: GO 92327
// for j = 1 to taskList do
92354: LD_ADDR_VAR 0 4
92358: PUSH
92359: DOUBLE
92360: LD_INT 1
92362: DEC
92363: ST_TO_ADDR
92364: LD_VAR 0 6
92368: PUSH
92369: FOR_TO
92370: IFFALSE 92468
// if taskList [ j ] [ 1 ] = | then
92372: LD_VAR 0 6
92376: PUSH
92377: LD_VAR 0 4
92381: ARRAY
92382: PUSH
92383: LD_INT 1
92385: ARRAY
92386: PUSH
92387: LD_STRING |
92389: EQUAL
92390: IFFALSE 92466
// begin _taskList := Delete ( taskList , 1 ) ;
92392: LD_ADDR_VAR 0 7
92396: PUSH
92397: LD_VAR 0 6
92401: PPUSH
92402: LD_INT 1
92404: PPUSH
92405: CALL_OW 3
92409: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
92410: LD_VAR 0 3
92414: PPUSH
92415: LD_VAR 0 7
92419: PPUSH
92420: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
92424: LD_VAR 0 3
92428: PPUSH
92429: LD_VAR 0 6
92433: PUSH
92434: LD_VAR 0 4
92438: ARRAY
92439: PUSH
92440: LD_INT 2
92442: ARRAY
92443: PPUSH
92444: LD_VAR 0 6
92448: PUSH
92449: LD_VAR 0 4
92453: ARRAY
92454: PUSH
92455: LD_INT 3
92457: ARRAY
92458: PPUSH
92459: LD_INT 8
92461: PPUSH
92462: CALL 92479 0 4
// end ;
92466: GO 92369
92468: POP
92469: POP
// end ;
92470: GO 92327
92472: POP
92473: POP
// end ; end ;
92474: LD_VAR 0 2
92478: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
92479: LD_INT 0
92481: PPUSH
92482: PPUSH
92483: PPUSH
92484: PPUSH
92485: PPUSH
92486: PPUSH
92487: PPUSH
92488: PPUSH
92489: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
92490: LD_VAR 0 1
92494: NOT
92495: PUSH
92496: LD_VAR 0 2
92500: PPUSH
92501: LD_VAR 0 3
92505: PPUSH
92506: CALL_OW 488
92510: NOT
92511: OR
92512: PUSH
92513: LD_VAR 0 4
92517: NOT
92518: OR
92519: IFFALSE 92523
// exit ;
92521: GO 92863
// list := [ ] ;
92523: LD_ADDR_VAR 0 13
92527: PUSH
92528: EMPTY
92529: ST_TO_ADDR
// if x - r < 0 then
92530: LD_VAR 0 2
92534: PUSH
92535: LD_VAR 0 4
92539: MINUS
92540: PUSH
92541: LD_INT 0
92543: LESS
92544: IFFALSE 92556
// min_x := 0 else
92546: LD_ADDR_VAR 0 7
92550: PUSH
92551: LD_INT 0
92553: ST_TO_ADDR
92554: GO 92572
// min_x := x - r ;
92556: LD_ADDR_VAR 0 7
92560: PUSH
92561: LD_VAR 0 2
92565: PUSH
92566: LD_VAR 0 4
92570: MINUS
92571: ST_TO_ADDR
// if y - r < 0 then
92572: LD_VAR 0 3
92576: PUSH
92577: LD_VAR 0 4
92581: MINUS
92582: PUSH
92583: LD_INT 0
92585: LESS
92586: IFFALSE 92598
// min_y := 0 else
92588: LD_ADDR_VAR 0 8
92592: PUSH
92593: LD_INT 0
92595: ST_TO_ADDR
92596: GO 92614
// min_y := y - r ;
92598: LD_ADDR_VAR 0 8
92602: PUSH
92603: LD_VAR 0 3
92607: PUSH
92608: LD_VAR 0 4
92612: MINUS
92613: ST_TO_ADDR
// max_x := x + r ;
92614: LD_ADDR_VAR 0 9
92618: PUSH
92619: LD_VAR 0 2
92623: PUSH
92624: LD_VAR 0 4
92628: PLUS
92629: ST_TO_ADDR
// max_y := y + r ;
92630: LD_ADDR_VAR 0 10
92634: PUSH
92635: LD_VAR 0 3
92639: PUSH
92640: LD_VAR 0 4
92644: PLUS
92645: ST_TO_ADDR
// for _x = min_x to max_x do
92646: LD_ADDR_VAR 0 11
92650: PUSH
92651: DOUBLE
92652: LD_VAR 0 7
92656: DEC
92657: ST_TO_ADDR
92658: LD_VAR 0 9
92662: PUSH
92663: FOR_TO
92664: IFFALSE 92781
// for _y = min_y to max_y do
92666: LD_ADDR_VAR 0 12
92670: PUSH
92671: DOUBLE
92672: LD_VAR 0 8
92676: DEC
92677: ST_TO_ADDR
92678: LD_VAR 0 10
92682: PUSH
92683: FOR_TO
92684: IFFALSE 92777
// begin if not ValidHex ( _x , _y ) then
92686: LD_VAR 0 11
92690: PPUSH
92691: LD_VAR 0 12
92695: PPUSH
92696: CALL_OW 488
92700: NOT
92701: IFFALSE 92705
// continue ;
92703: GO 92683
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
92705: LD_VAR 0 11
92709: PPUSH
92710: LD_VAR 0 12
92714: PPUSH
92715: CALL_OW 351
92719: PUSH
92720: LD_VAR 0 11
92724: PPUSH
92725: LD_VAR 0 12
92729: PPUSH
92730: CALL_OW 554
92734: AND
92735: IFFALSE 92775
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
92737: LD_ADDR_VAR 0 13
92741: PUSH
92742: LD_VAR 0 13
92746: PPUSH
92747: LD_VAR 0 13
92751: PUSH
92752: LD_INT 1
92754: PLUS
92755: PPUSH
92756: LD_VAR 0 11
92760: PUSH
92761: LD_VAR 0 12
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: PPUSH
92770: CALL_OW 2
92774: ST_TO_ADDR
// end ;
92775: GO 92683
92777: POP
92778: POP
92779: GO 92663
92781: POP
92782: POP
// if not list then
92783: LD_VAR 0 13
92787: NOT
92788: IFFALSE 92792
// exit ;
92790: GO 92863
// for i in list do
92792: LD_ADDR_VAR 0 6
92796: PUSH
92797: LD_VAR 0 13
92801: PUSH
92802: FOR_IN
92803: IFFALSE 92861
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
92805: LD_VAR 0 1
92809: PPUSH
92810: LD_STRING M
92812: PUSH
92813: LD_VAR 0 6
92817: PUSH
92818: LD_INT 1
92820: ARRAY
92821: PUSH
92822: LD_VAR 0 6
92826: PUSH
92827: LD_INT 2
92829: ARRAY
92830: PUSH
92831: LD_INT 0
92833: PUSH
92834: LD_INT 0
92836: PUSH
92837: LD_INT 0
92839: PUSH
92840: LD_INT 0
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: PUSH
92852: EMPTY
92853: LIST
92854: PPUSH
92855: CALL_OW 447
92859: GO 92802
92861: POP
92862: POP
// end ;
92863: LD_VAR 0 5
92867: RET
