// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20107 0 0
// InitNature ;
  19: CALL 16779 0 0
// InitArtifact ;
  23: CALL 17392 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4496 0 0
// PrepareAlliance ;
  44: CALL 1314 0 0
// PrepareArabian ;
  48: CALL 6205 0 0
// PrepareRussian ;
  52: CALL 8156 0 0
// PrepareLegion ;
  56: CALL 6599 0 0
// Action ;
  60: CALL 10659 0 0
// MC_Start ( ) ;
  64: CALL 22219 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// end ;
 168: LD_VAR 0 1
 172: RET
// export function CustomInitMacro ( ) ; begin
 173: LD_INT 0
 175: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 176: LD_ADDR_EXP 98
 180: PUSH
 181: LD_INT 26
 183: PUSH
 184: LD_INT 1
 186: PUSH
 187: LD_INT 4
 189: PUSH
 190: LD_INT 8
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 199: LD_ADDR_EXP 99
 203: PUSH
 204: LD_INT 27
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 7
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: LIST
 221: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 222: LD_INT 1
 224: PPUSH
 225: LD_INT 6
 227: PUSH
 228: LD_INT 7
 230: PUSH
 231: LD_INT 9
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: PPUSH
 245: LD_INT 28
 247: PPUSH
 248: CALL 43540 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 252: LD_INT 1
 254: PPUSH
 255: LD_INT 10
 257: PUSH
 258: LD_INT 11
 260: PUSH
 261: LD_INT 13
 263: PUSH
 264: LD_INT 15
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: PPUSH
 273: CALL 44600 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 29
 282: PUSH
 283: EMPTY
 284: LIST
 285: PPUSH
 286: CALL 44693 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 290: LD_ADDR_EXP 103
 294: PUSH
 295: LD_EXP 103
 299: PPUSH
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 22
 305: PUSH
 306: LD_INT 2
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: PUSH
 313: LD_INT 25
 315: PUSH
 316: LD_INT 15
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: PPUSH
 327: CALL_OW 69
 331: PPUSH
 332: CALL_OW 1
 336: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 337: LD_INT 1
 339: PPUSH
 340: LD_INT 13
 342: PUSH
 343: LD_INT 2
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 31
 351: PUSH
 352: EMPTY
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: PUSH
 358: LD_INT 13
 360: PUSH
 361: LD_INT 2
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: LD_INT 31
 369: PUSH
 370: EMPTY
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 13
 378: PUSH
 379: LD_INT 1
 381: PUSH
 382: LD_INT 1
 384: PUSH
 385: LD_INT 28
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: PUSH
 394: LD_INT 13
 396: PUSH
 397: LD_INT 1
 399: PUSH
 400: LD_INT 1
 402: PUSH
 403: LD_INT 28
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: PUSH
 412: LD_INT 13
 414: PUSH
 415: LD_INT 1
 417: PUSH
 418: LD_INT 1
 420: PUSH
 421: LD_INT 28
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 13
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: LD_INT 28
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PPUSH
 456: CALL 43858 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 460: LD_INT 1
 462: PPUSH
 463: LD_INT 4
 465: PPUSH
 466: CALL 44043 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 470: LD_INT 2
 472: PPUSH
 473: LD_INT 10
 475: PUSH
 476: LD_INT 11
 478: PUSH
 479: LD_INT 12
 481: PUSH
 482: LD_INT 14
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL 44600 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 495: LD_INT 2
 497: PPUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: PPUSH
 504: CALL 44693 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 508: LD_INT 2
 510: PPUSH
 511: LD_INT 21
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 51
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 22
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: LD_INT 3
 537: PUSH
 538: LD_INT 52
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 22
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: LD_INT 3
 555: PUSH
 556: LD_INT 52
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 24
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: LD_INT 3
 573: PUSH
 574: LD_INT 47
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 24
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 3
 591: PUSH
 592: LD_INT 47
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: LD_INT 24
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: LD_INT 47
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: PUSH
 619: LD_INT 24
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 3
 627: PUSH
 628: LD_INT 47
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 24
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 47
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PPUSH
 665: CALL 43858 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 669: LD_INT 2
 671: PPUSH
 672: LD_INT 5
 674: PPUSH
 675: CALL 44043 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 0
 684: PPUSH
 685: CALL 44473 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 689: LD_INT 3
 691: PPUSH
 692: LD_INT 10
 694: PUSH
 695: LD_INT 12
 697: PUSH
 698: LD_INT 15
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_OWVAR 67
 710: ARRAY
 711: PPUSH
 712: LD_INT 24
 714: PPUSH
 715: CALL 43540 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 719: LD_INT 3
 721: PPUSH
 722: LD_INT 10
 724: PUSH
 725: LD_INT 11
 727: PUSH
 728: LD_INT 13
 730: PUSH
 731: LD_INT 15
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: PPUSH
 740: CALL 44600 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 744: LD_INT 3
 746: PPUSH
 747: LD_INT 13
 749: PUSH
 750: EMPTY
 751: LIST
 752: PPUSH
 753: CALL 44693 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 757: LD_ADDR_EXP 103
 761: PUSH
 762: LD_EXP 103
 766: PPUSH
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 22
 772: PUSH
 773: LD_INT 8
 775: PUSH
 776: EMPTY
 777: LIST
 778: LIST
 779: PUSH
 780: LD_INT 25
 782: PUSH
 783: LD_INT 15
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: PPUSH
 794: CALL_OW 69
 798: PPUSH
 799: CALL_OW 1
 803: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 804: LD_INT 3
 806: PPUSH
 807: LD_INT 13
 809: PUSH
 810: LD_INT 2
 812: PUSH
 813: LD_INT 1
 815: PUSH
 816: LD_INT 31
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 13
 827: PUSH
 828: LD_INT 2
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 31
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 13
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 2
 851: PUSH
 852: LD_INT 32
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: LD_INT 14
 863: PUSH
 864: LD_INT 1
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 28
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 14
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 28
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: PUSH
 897: LD_INT 14
 899: PUSH
 900: LD_INT 1
 902: PUSH
 903: LD_INT 1
 905: PUSH
 906: LD_INT 28
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 14
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: LD_INT 1
 923: PUSH
 924: LD_INT 28
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 43858 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 4
 951: PPUSH
 952: CALL 44043 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 956: LD_INT 4
 958: PPUSH
 959: LD_INT 10
 961: PUSH
 962: LD_INT 12
 964: PUSH
 965: LD_INT 11
 967: PUSH
 968: LD_INT 15
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL 44600 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 981: LD_INT 4
 983: PPUSH
 984: LD_INT 33
 986: PUSH
 987: EMPTY
 988: LIST
 989: PPUSH
 990: CALL 44693 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 994: LD_INT 4
 996: PPUSH
 997: LD_INT 5
 999: PUSH
1000: LD_INT 6
1002: PUSH
1003: LD_INT 7
1005: PUSH
1006: LD_INT 9
1008: PUSH
1009: LD_INT 10
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PPUSH
1019: CALL 45011 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1023: LD_INT 4
1025: PPUSH
1026: LD_INT 54
1028: PPUSH
1029: LD_INT 85
1031: PPUSH
1032: LD_INT 2
1034: PPUSH
1035: LD_INT 25
1037: PUSH
1038: LD_INT 16
1040: PUSH
1041: LD_INT 17
1043: PUSH
1044: LD_INT 18
1046: PUSH
1047: LD_INT 22
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL 44805 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1061: LD_INT 4
1063: PPUSH
1064: LD_INT 5
1066: PUSH
1067: LD_INT 1
1069: PUSH
1070: LD_INT 1
1072: PUSH
1073: LD_INT 7
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 5
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: LD_INT 1
1090: PUSH
1091: LD_INT 6
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 5
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 1
1108: PUSH
1109: LD_INT 7
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_INT 5
1120: PUSH
1121: LD_INT 1
1123: PUSH
1124: LD_INT 1
1126: PUSH
1127: LD_INT 6
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 5
1138: PUSH
1139: LD_INT 1
1141: PUSH
1142: LD_INT 3
1144: PUSH
1145: LD_INT 12
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PUSH
1154: LD_INT 3
1156: PUSH
1157: LD_INT 1
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: LD_INT 13
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PPUSH
1180: CALL 43858 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1184: LD_INT 4
1186: PPUSH
1187: LD_INT 4
1189: PPUSH
1190: CALL 44043 0 2
// MC_SetTame ( 4 , powellApe ) ;
1194: LD_INT 4
1196: PPUSH
1197: LD_INT 11
1199: PPUSH
1200: CALL 44424 0 2
// end ;
1204: LD_VAR 0 1
1208: RET
// every 0 0$1 trigger debug do var i ;
1209: LD_EXP 1
1213: IFFALSE 1311
1215: GO 1217
1217: DISABLE
1218: LD_INT 0
1220: PPUSH
// begin enable ;
1221: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1222: LD_ADDR_VAR 0 1
1226: PUSH
1227: LD_INT 22
1229: PUSH
1230: LD_INT 7
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 2
1239: PUSH
1240: LD_INT 21
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: PUSH
1250: LD_INT 21
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: PUSH
1265: LD_INT 3
1267: PUSH
1268: LD_INT 24
1270: PUSH
1271: LD_INT 1000
1273: PUSH
1274: EMPTY
1275: LIST
1276: LIST
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: PPUSH
1287: CALL_OW 69
1291: PUSH
1292: FOR_IN
1293: IFFALSE 1309
// SetLives ( i , 1000 ) ;
1295: LD_VAR 0 1
1299: PPUSH
1300: LD_INT 1000
1302: PPUSH
1303: CALL_OW 234
1307: GO 1292
1309: POP
1310: POP
// end ; end_of_file
1311: PPOPN 1
1313: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1314: LD_INT 0
1316: PPUSH
1317: PPUSH
1318: PPUSH
1319: PPUSH
1320: PPUSH
// uc_side := 7 ;
1321: LD_ADDR_OWVAR 20
1325: PUSH
1326: LD_INT 7
1328: ST_TO_ADDR
// tmp := [ ] ;
1329: LD_ADDR_VAR 0 5
1333: PUSH
1334: EMPTY
1335: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1336: LD_ADDR_EXP 12
1340: PUSH
1341: LD_STRING JMM
1343: PPUSH
1344: LD_EXP 1
1348: NOT
1349: PPUSH
1350: LD_STRING 14a_
1352: PPUSH
1353: CALL 50250 0 3
1357: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1358: LD_ADDR_EXP 44
1362: PUSH
1363: LD_STRING Burlak
1365: PPUSH
1366: LD_EXP 1
1370: NOT
1371: PPUSH
1372: LD_STRING 14a_
1374: PPUSH
1375: CALL 50250 0 3
1379: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1380: LD_ADDR_EXP 27
1384: PUSH
1385: LD_STRING Joan
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: LD_STRING 13a_
1396: PPUSH
1397: CALL 50250 0 3
1401: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1402: LD_ADDR_EXP 13
1406: PUSH
1407: LD_STRING Roth
1409: PPUSH
1410: LD_EXP 1
1414: NOT
1415: PPUSH
1416: LD_STRING 13a_
1418: PPUSH
1419: CALL 50250 0 3
1423: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1424: LD_ADDR_EXP 30
1428: PUSH
1429: LD_STRING Gossudarov
1431: PPUSH
1432: LD_EXP 1
1436: NOT
1437: PPUSH
1438: LD_STRING 13a_
1440: PPUSH
1441: CALL 50250 0 3
1445: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1446: LD_ADDR_EXP 28
1450: PUSH
1451: LD_STRING DeltaDoctor
1453: PPUSH
1454: LD_EXP 1
1458: NOT
1459: PPUSH
1460: LD_STRING 13a_
1462: PPUSH
1463: CALL 50250 0 3
1467: ST_TO_ADDR
// if DeltaDoctor then
1468: LD_EXP 28
1472: IFFALSE 1490
// tmp := tmp ^ DeltaDoctor ;
1474: LD_ADDR_VAR 0 5
1478: PUSH
1479: LD_VAR 0 5
1483: PUSH
1484: LD_EXP 28
1488: ADD
1489: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1490: LD_ADDR_EXP 26
1494: PUSH
1495: LD_STRING Simms
1497: PPUSH
1498: LD_EXP 1
1502: NOT
1503: PPUSH
1504: LD_STRING 13a_
1506: PPUSH
1507: CALL 50250 0 3
1511: ST_TO_ADDR
// if Simms then
1512: LD_EXP 26
1516: IFFALSE 1534
// tmp := tmp ^ Simms ;
1518: LD_ADDR_VAR 0 5
1522: PUSH
1523: LD_VAR 0 5
1527: PUSH
1528: LD_EXP 26
1532: ADD
1533: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1534: LD_ADDR_EXP 24
1538: PUSH
1539: LD_STRING Frank
1541: PPUSH
1542: LD_EXP 1
1546: NOT
1547: PPUSH
1548: LD_STRING 13a_
1550: PPUSH
1551: CALL 50250 0 3
1555: ST_TO_ADDR
// if Frank then
1556: LD_EXP 24
1560: IFFALSE 1578
// tmp := tmp ^ Frank ;
1562: LD_ADDR_VAR 0 5
1566: PUSH
1567: LD_VAR 0 5
1571: PUSH
1572: LD_EXP 24
1576: ADD
1577: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1578: LD_ADDR_EXP 31
1582: PUSH
1583: LD_STRING Kirilenkova
1585: PPUSH
1586: LD_EXP 1
1590: NOT
1591: PPUSH
1592: LD_STRING 13a_
1594: PPUSH
1595: CALL 50250 0 3
1599: ST_TO_ADDR
// if Kirilenkova then
1600: LD_EXP 31
1604: IFFALSE 1622
// tmp := tmp ^ Kirilenkova ;
1606: LD_ADDR_VAR 0 5
1610: PUSH
1611: LD_VAR 0 5
1615: PUSH
1616: LD_EXP 31
1620: ADD
1621: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING Titov
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 13a_
1638: PPUSH
1639: CALL 50250 0 3
1643: ST_TO_ADDR
// if Titov then
1644: LD_EXP 32
1648: IFFALSE 1666
// tmp := tmp ^ Titov ;
1650: LD_ADDR_VAR 0 5
1654: PUSH
1655: LD_VAR 0 5
1659: PUSH
1660: LD_EXP 32
1664: ADD
1665: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1666: LD_ADDR_EXP 33
1670: PUSH
1671: LD_STRING Fadeev
1673: PPUSH
1674: LD_EXP 1
1678: NOT
1679: PPUSH
1680: LD_STRING 13a_
1682: PPUSH
1683: CALL 50250 0 3
1687: ST_TO_ADDR
// if Fadeev then
1688: LD_EXP 33
1692: IFFALSE 1710
// tmp := tmp ^ Fadeev ;
1694: LD_ADDR_VAR 0 5
1698: PUSH
1699: LD_VAR 0 5
1703: PUSH
1704: LD_EXP 33
1708: ADD
1709: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1710: LD_ADDR_EXP 34
1714: PUSH
1715: LD_STRING Dolgov
1717: PPUSH
1718: LD_EXP 1
1722: NOT
1723: PPUSH
1724: LD_STRING 13a_
1726: PPUSH
1727: CALL 50250 0 3
1731: ST_TO_ADDR
// if Dolgov then
1732: LD_EXP 34
1736: IFFALSE 1754
// tmp := tmp ^ Dolgov ;
1738: LD_ADDR_VAR 0 5
1742: PUSH
1743: LD_VAR 0 5
1747: PUSH
1748: LD_EXP 34
1752: ADD
1753: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1754: LD_ADDR_EXP 35
1758: PUSH
1759: LD_STRING Petrosyan
1761: PPUSH
1762: LD_EXP 1
1766: NOT
1767: PPUSH
1768: LD_STRING 13a_
1770: PPUSH
1771: CALL 50250 0 3
1775: ST_TO_ADDR
// if Petrosyan then
1776: LD_EXP 35
1780: IFFALSE 1798
// tmp := tmp ^ Petrosyan ;
1782: LD_ADDR_VAR 0 5
1786: PUSH
1787: LD_VAR 0 5
1791: PUSH
1792: LD_EXP 35
1796: ADD
1797: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1798: LD_ADDR_EXP 36
1802: PUSH
1803: LD_STRING Scholtze
1805: PPUSH
1806: LD_EXP 1
1810: NOT
1811: PPUSH
1812: LD_STRING 13a_
1814: PPUSH
1815: CALL 50250 0 3
1819: ST_TO_ADDR
// if Scholtze then
1820: LD_EXP 36
1824: IFFALSE 1842
// tmp := tmp ^ Scholtze ;
1826: LD_ADDR_VAR 0 5
1830: PUSH
1831: LD_VAR 0 5
1835: PUSH
1836: LD_EXP 36
1840: ADD
1841: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1842: LD_ADDR_EXP 37
1846: PUSH
1847: LD_STRING Oblukov
1849: PPUSH
1850: LD_EXP 1
1854: NOT
1855: PPUSH
1856: LD_STRING 13a_
1858: PPUSH
1859: CALL 50250 0 3
1863: ST_TO_ADDR
// if Oblukov then
1864: LD_EXP 37
1868: IFFALSE 1886
// tmp := tmp ^ Oblukov ;
1870: LD_ADDR_VAR 0 5
1874: PUSH
1875: LD_VAR 0 5
1879: PUSH
1880: LD_EXP 37
1884: ADD
1885: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1886: LD_ADDR_EXP 38
1890: PUSH
1891: LD_STRING Kapitsova
1893: PPUSH
1894: LD_EXP 1
1898: NOT
1899: PPUSH
1900: LD_STRING 13a_
1902: PPUSH
1903: CALL 50250 0 3
1907: ST_TO_ADDR
// if Kapitsova then
1908: LD_EXP 38
1912: IFFALSE 1930
// tmp := tmp ^ Kapitsova ;
1914: LD_ADDR_VAR 0 5
1918: PUSH
1919: LD_VAR 0 5
1923: PUSH
1924: LD_EXP 38
1928: ADD
1929: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1930: LD_ADDR_EXP 39
1934: PUSH
1935: LD_STRING Lipshchin
1937: PPUSH
1938: LD_EXP 1
1942: NOT
1943: PPUSH
1944: LD_STRING 13a_
1946: PPUSH
1947: CALL 50250 0 3
1951: ST_TO_ADDR
// if Lipshchin then
1952: LD_EXP 39
1956: IFFALSE 1974
// tmp := tmp ^ Lipshchin ;
1958: LD_ADDR_VAR 0 5
1962: PUSH
1963: LD_VAR 0 5
1967: PUSH
1968: LD_EXP 39
1972: ADD
1973: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
1974: LD_ADDR_EXP 40
1978: PUSH
1979: LD_STRING Petrovova
1981: PPUSH
1982: LD_EXP 1
1986: NOT
1987: PPUSH
1988: LD_STRING 13a_
1990: PPUSH
1991: CALL 50250 0 3
1995: ST_TO_ADDR
// if Petrovova then
1996: LD_EXP 40
2000: IFFALSE 2018
// tmp := tmp ^ Petrovova ;
2002: LD_ADDR_VAR 0 5
2006: PUSH
2007: LD_VAR 0 5
2011: PUSH
2012: LD_EXP 40
2016: ADD
2017: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2018: LD_ADDR_EXP 41
2022: PUSH
2023: LD_STRING Kovalyuk
2025: PPUSH
2026: LD_EXP 1
2030: NOT
2031: PPUSH
2032: LD_STRING 13a_
2034: PPUSH
2035: CALL 50250 0 3
2039: ST_TO_ADDR
// if Kovalyuk then
2040: LD_EXP 41
2044: IFFALSE 2062
// tmp := tmp ^ Kovalyuk ;
2046: LD_ADDR_VAR 0 5
2050: PUSH
2051: LD_VAR 0 5
2055: PUSH
2056: LD_EXP 41
2060: ADD
2061: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2062: LD_ADDR_EXP 42
2066: PUSH
2067: LD_STRING Kuzmov
2069: PPUSH
2070: LD_EXP 1
2074: NOT
2075: PPUSH
2076: LD_STRING 13a_
2078: PPUSH
2079: CALL 50250 0 3
2083: ST_TO_ADDR
// if Kuzmov then
2084: LD_EXP 42
2088: IFFALSE 2106
// tmp := tmp ^ Kuzmov ;
2090: LD_ADDR_VAR 0 5
2094: PUSH
2095: LD_VAR 0 5
2099: PUSH
2100: LD_EXP 42
2104: ADD
2105: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2106: LD_ADDR_EXP 43
2110: PUSH
2111: LD_STRING Karamazov
2113: PPUSH
2114: LD_EXP 1
2118: NOT
2119: PPUSH
2120: LD_STRING 13a_
2122: PPUSH
2123: CALL 50250 0 3
2127: ST_TO_ADDR
// if Karamazov then
2128: LD_EXP 43
2132: IFFALSE 2150
// tmp := tmp ^ Karamazov ;
2134: LD_ADDR_VAR 0 5
2138: PUSH
2139: LD_VAR 0 5
2143: PUSH
2144: LD_EXP 43
2148: ADD
2149: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2150: LD_ADDR_EXP 45
2154: PUSH
2155: LD_STRING Belkov
2157: PPUSH
2158: LD_EXP 1
2162: NOT
2163: PPUSH
2164: LD_STRING 13a_
2166: PPUSH
2167: CALL 50250 0 3
2171: ST_TO_ADDR
// if Belkov then
2172: LD_EXP 45
2176: IFFALSE 2194
// tmp := tmp ^ Belkov ;
2178: LD_ADDR_VAR 0 5
2182: PUSH
2183: LD_VAR 0 5
2187: PUSH
2188: LD_EXP 45
2192: ADD
2193: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2194: LD_ADDR_EXP 46
2198: PUSH
2199: LD_STRING Gnyevko
2201: PPUSH
2202: LD_EXP 1
2206: NOT
2207: PPUSH
2208: LD_STRING 13a_
2210: PPUSH
2211: CALL 50250 0 3
2215: ST_TO_ADDR
// if Gnyevko then
2216: LD_EXP 46
2220: IFFALSE 2238
// tmp := tmp ^ Gnyevko ;
2222: LD_ADDR_VAR 0 5
2226: PUSH
2227: LD_VAR 0 5
2231: PUSH
2232: LD_EXP 46
2236: ADD
2237: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2238: LD_ADDR_EXP 29
2242: PUSH
2243: LD_STRING Coonie
2245: PPUSH
2246: CALL_OW 25
2250: ST_TO_ADDR
// if not Lisa then
2251: LD_EXP 14
2255: NOT
2256: IFFALSE 2302
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 14
2262: PUSH
2263: LD_STRING Lisa
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 50250 0 3
2279: ST_TO_ADDR
// if Lisa then
2280: LD_EXP 14
2284: IFFALSE 2302
// tmp := tmp ^ Lisa ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 14
2300: ADD
2301: ST_TO_ADDR
// end ; if not Donaldson then
2302: LD_EXP 15
2306: NOT
2307: IFFALSE 2353
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2309: LD_ADDR_EXP 15
2313: PUSH
2314: LD_STRING Donaldson
2316: PPUSH
2317: LD_EXP 1
2321: NOT
2322: PPUSH
2323: LD_STRING 13a_
2325: PPUSH
2326: CALL 50250 0 3
2330: ST_TO_ADDR
// if Donaldson then
2331: LD_EXP 15
2335: IFFALSE 2353
// tmp := tmp ^ Donaldson ;
2337: LD_ADDR_VAR 0 5
2341: PUSH
2342: LD_VAR 0 5
2346: PUSH
2347: LD_EXP 15
2351: ADD
2352: ST_TO_ADDR
// end ; if not Bobby then
2353: LD_EXP 16
2357: NOT
2358: IFFALSE 2404
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 16
2364: PUSH
2365: LD_STRING Bobby
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 50250 0 3
2381: ST_TO_ADDR
// if Bobby then
2382: LD_EXP 16
2386: IFFALSE 2404
// tmp := tmp ^ Bobby ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 16
2402: ADD
2403: ST_TO_ADDR
// end ; if not Cyrus then
2404: LD_EXP 17
2408: NOT
2409: IFFALSE 2455
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2411: LD_ADDR_EXP 17
2415: PUSH
2416: LD_STRING Cyrus
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_STRING 13a_
2427: PPUSH
2428: CALL 50250 0 3
2432: ST_TO_ADDR
// if Cyrus then
2433: LD_EXP 17
2437: IFFALSE 2455
// tmp := tmp ^ Cyrus ;
2439: LD_ADDR_VAR 0 5
2443: PUSH
2444: LD_VAR 0 5
2448: PUSH
2449: LD_EXP 17
2453: ADD
2454: ST_TO_ADDR
// end ; if not Brown then
2455: LD_EXP 19
2459: NOT
2460: IFFALSE 2506
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2462: LD_ADDR_EXP 19
2466: PUSH
2467: LD_STRING Brown
2469: PPUSH
2470: LD_EXP 1
2474: NOT
2475: PPUSH
2476: LD_STRING 13a_
2478: PPUSH
2479: CALL 50250 0 3
2483: ST_TO_ADDR
// if Brown then
2484: LD_EXP 19
2488: IFFALSE 2506
// tmp := tmp ^ Brown ;
2490: LD_ADDR_VAR 0 5
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: LD_EXP 19
2504: ADD
2505: ST_TO_ADDR
// end ; if not Gladstone then
2506: LD_EXP 20
2510: NOT
2511: IFFALSE 2557
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2513: LD_ADDR_EXP 20
2517: PUSH
2518: LD_STRING Gladstone
2520: PPUSH
2521: LD_EXP 1
2525: NOT
2526: PPUSH
2527: LD_STRING 13a_
2529: PPUSH
2530: CALL 50250 0 3
2534: ST_TO_ADDR
// if Gladstone then
2535: LD_EXP 20
2539: IFFALSE 2557
// tmp := tmp ^ Gladstone ;
2541: LD_ADDR_VAR 0 5
2545: PUSH
2546: LD_VAR 0 5
2550: PUSH
2551: LD_EXP 20
2555: ADD
2556: ST_TO_ADDR
// end ; if not Cornel then
2557: LD_EXP 22
2561: NOT
2562: IFFALSE 2608
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2564: LD_ADDR_EXP 22
2568: PUSH
2569: LD_STRING Cornel
2571: PPUSH
2572: LD_EXP 1
2576: NOT
2577: PPUSH
2578: LD_STRING 13a_
2580: PPUSH
2581: CALL 50250 0 3
2585: ST_TO_ADDR
// if Cornel then
2586: LD_EXP 22
2590: IFFALSE 2608
// tmp := tmp ^ Cornel ;
2592: LD_ADDR_VAR 0 5
2596: PUSH
2597: LD_VAR 0 5
2601: PUSH
2602: LD_EXP 22
2606: ADD
2607: ST_TO_ADDR
// end ; if not Houten then
2608: LD_EXP 21
2612: NOT
2613: IFFALSE 2659
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2615: LD_ADDR_EXP 21
2619: PUSH
2620: LD_STRING Houten
2622: PPUSH
2623: LD_EXP 1
2627: NOT
2628: PPUSH
2629: LD_STRING 13a_
2631: PPUSH
2632: CALL 50250 0 3
2636: ST_TO_ADDR
// if Houten then
2637: LD_EXP 21
2641: IFFALSE 2659
// tmp := tmp ^ Houten ;
2643: LD_ADDR_VAR 0 5
2647: PUSH
2648: LD_VAR 0 5
2652: PUSH
2653: LD_EXP 21
2657: ADD
2658: ST_TO_ADDR
// end ; if not Gary then
2659: LD_EXP 23
2663: NOT
2664: IFFALSE 2710
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2666: LD_ADDR_EXP 23
2670: PUSH
2671: LD_STRING Gary
2673: PPUSH
2674: LD_EXP 1
2678: NOT
2679: PPUSH
2680: LD_STRING 13a_
2682: PPUSH
2683: CALL 50250 0 3
2687: ST_TO_ADDR
// if Gary then
2688: LD_EXP 23
2692: IFFALSE 2710
// tmp := tmp ^ Gary ;
2694: LD_ADDR_VAR 0 5
2698: PUSH
2699: LD_VAR 0 5
2703: PUSH
2704: LD_EXP 23
2708: ADD
2709: ST_TO_ADDR
// end ; if not Kikuchi then
2710: LD_EXP 25
2714: NOT
2715: IFFALSE 2761
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2717: LD_ADDR_EXP 25
2721: PUSH
2722: LD_STRING Kikuchi
2724: PPUSH
2725: LD_EXP 1
2729: NOT
2730: PPUSH
2731: LD_STRING 13a_
2733: PPUSH
2734: CALL 50250 0 3
2738: ST_TO_ADDR
// if Kikuchi then
2739: LD_EXP 25
2743: IFFALSE 2761
// tmp := tmp ^ Kikuchi ;
2745: LD_ADDR_VAR 0 5
2749: PUSH
2750: LD_VAR 0 5
2754: PUSH
2755: LD_EXP 25
2759: ADD
2760: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2761: LD_ADDR_VAR 0 5
2765: PUSH
2766: LD_VAR 0 5
2770: PUSH
2771: LD_STRING 13a_others
2773: PPUSH
2774: CALL_OW 31
2778: UNION
2779: ST_TO_ADDR
// tmp := tmp diff 0 ;
2780: LD_ADDR_VAR 0 5
2784: PUSH
2785: LD_VAR 0 5
2789: PUSH
2790: LD_INT 0
2792: DIFF
2793: ST_TO_ADDR
// if tmp < 15 then
2794: LD_VAR 0 5
2798: PUSH
2799: LD_INT 15
2801: LESS
2802: IFFALSE 2890
// for i = 15 downto tmp do
2804: LD_ADDR_VAR 0 2
2808: PUSH
2809: DOUBLE
2810: LD_INT 15
2812: INC
2813: ST_TO_ADDR
2814: LD_VAR 0 5
2818: PUSH
2819: FOR_DOWNTO
2820: IFFALSE 2888
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2822: LD_ADDR_OWVAR 21
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 3
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 1
2839: PPUSH
2840: LD_INT 2
2842: PPUSH
2843: CALL_OW 12
2847: ARRAY
2848: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2849: LD_INT 0
2851: PPUSH
2852: LD_INT 1
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: CALL_OW 12
2862: PPUSH
2863: LD_INT 8
2865: PPUSH
2866: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2870: LD_ADDR_VAR 0 5
2874: PUSH
2875: LD_VAR 0 5
2879: PUSH
2880: CALL_OW 44
2884: ADD
2885: ST_TO_ADDR
// end ;
2886: GO 2819
2888: POP
2889: POP
// if not debug then
2890: LD_EXP 1
2894: NOT
2895: IFFALSE 3067
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2897: LD_ADDR_VAR 0 4
2901: PUSH
2902: LD_STRING 
2904: PPUSH
2905: LD_INT 15
2907: PUSH
2908: LD_INT 14
2910: PUSH
2911: LD_INT 13
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: LIST
2918: PUSH
2919: LD_OWVAR 67
2923: ARRAY
2924: PPUSH
2925: LD_INT 15
2927: PUSH
2928: LD_INT 14
2930: PUSH
2931: LD_INT 13
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: LIST
2938: PUSH
2939: LD_OWVAR 67
2943: ARRAY
2944: PPUSH
2945: LD_INT -6
2947: PUSH
2948: LD_EXP 12
2952: PUSH
2953: LD_EXP 44
2957: PUSH
2958: LD_EXP 13
2962: PUSH
2963: LD_EXP 27
2967: PUSH
2968: LD_EXP 18
2972: PUSH
2973: LD_EXP 30
2977: PUSH
2978: LD_INT -2
2980: PUSH
2981: LD_INT -3
2983: PUSH
2984: LD_INT -5
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: LIST
2997: LIST
2998: PUSH
2999: LD_VAR 0 5
3003: ADD
3004: PPUSH
3005: LD_INT 1
3007: PUSH
3008: LD_INT 4
3010: PUSH
3011: LD_INT 2
3013: PUSH
3014: LD_INT 1
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 5
3026: PUSH
3027: LD_INT 0
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: LIST
3037: PUSH
3038: LD_INT 9
3040: PUSH
3041: LD_INT 0
3043: PUSH
3044: LD_INT 3
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PPUSH
3060: CALL_OW 42
3064: ST_TO_ADDR
3065: GO 3146
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3067: LD_ADDR_VAR 0 4
3071: PUSH
3072: LD_EXP 32
3076: PUSH
3077: LD_EXP 33
3081: PUSH
3082: LD_EXP 34
3086: PUSH
3087: LD_EXP 35
3091: PUSH
3092: LD_EXP 36
3096: PUSH
3097: LD_EXP 37
3101: PUSH
3102: LD_EXP 38
3106: PUSH
3107: LD_EXP 39
3111: PUSH
3112: LD_EXP 40
3116: PUSH
3117: LD_EXP 41
3121: PUSH
3122: LD_EXP 42
3126: PUSH
3127: LD_EXP 43
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: ST_TO_ADDR
// uc_nation := 1 ;
3146: LD_ADDR_OWVAR 21
3150: PUSH
3151: LD_INT 1
3153: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3154: LD_INT 5
3156: PPUSH
3157: LD_INT 3
3159: PPUSH
3160: LD_INT 1
3162: PPUSH
3163: LD_INT 6
3165: PPUSH
3166: LD_INT 100
3168: PPUSH
3169: CALL 57276 0 5
// veh := CreateVehicle ;
3173: LD_ADDR_VAR 0 3
3177: PUSH
3178: CALL_OW 45
3182: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3183: LD_VAR 0 3
3187: PPUSH
3188: LD_INT 7
3190: NEG
3191: PPUSH
3192: CALL_OW 242
// SetDir ( veh , 3 ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: LD_INT 3
3203: PPUSH
3204: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3208: LD_VAR 0 3
3212: PPUSH
3213: LD_INT 31
3215: PPUSH
3216: LD_INT 0
3218: PPUSH
3219: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3223: LD_EXP 12
3227: PPUSH
3228: LD_VAR 0 3
3232: PPUSH
3233: CALL_OW 52
// if Joan then
3237: LD_EXP 27
3241: IFFALSE 3313
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3243: LD_INT 3
3245: PPUSH
3246: LD_INT 3
3248: PPUSH
3249: LD_INT 1
3251: PPUSH
3252: LD_INT 11
3254: PPUSH
3255: LD_INT 100
3257: PPUSH
3258: CALL 57276 0 5
// veh := CreateVehicle ;
3262: LD_ADDR_VAR 0 3
3266: PUSH
3267: CALL_OW 45
3271: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3272: LD_VAR 0 3
3276: PPUSH
3277: LD_INT 3
3279: PPUSH
3280: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3284: LD_VAR 0 3
3288: PPUSH
3289: LD_INT 30
3291: PPUSH
3292: LD_INT 0
3294: PPUSH
3295: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3299: LD_EXP 27
3303: PPUSH
3304: LD_VAR 0 3
3308: PPUSH
3309: CALL_OW 52
// end ; if Roth then
3313: LD_EXP 13
3317: IFFALSE 3389
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3319: LD_INT 3
3321: PPUSH
3322: LD_INT 3
3324: PPUSH
3325: LD_INT 1
3327: PPUSH
3328: LD_INT 11
3330: PPUSH
3331: LD_INT 100
3333: PPUSH
3334: CALL 57276 0 5
// veh := CreateVehicle ;
3338: LD_ADDR_VAR 0 3
3342: PUSH
3343: CALL_OW 45
3347: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3348: LD_VAR 0 3
3352: PPUSH
3353: LD_INT 3
3355: PPUSH
3356: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3360: LD_VAR 0 3
3364: PPUSH
3365: LD_INT 30
3367: PPUSH
3368: LD_INT 0
3370: PPUSH
3371: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3375: LD_EXP 13
3379: PPUSH
3380: LD_VAR 0 3
3384: PPUSH
3385: CALL_OW 52
// end ; if Denis then
3389: LD_EXP 18
3393: IFFALSE 3465
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3395: LD_INT 5
3397: PPUSH
3398: LD_INT 3
3400: PPUSH
3401: LD_INT 1
3403: PPUSH
3404: LD_INT 9
3406: PPUSH
3407: LD_INT 100
3409: PPUSH
3410: CALL 57276 0 5
// veh := CreateVehicle ;
3414: LD_ADDR_VAR 0 3
3418: PUSH
3419: CALL_OW 45
3423: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3424: LD_VAR 0 3
3428: PPUSH
3429: LD_INT 3
3431: PPUSH
3432: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3436: LD_VAR 0 3
3440: PPUSH
3441: LD_INT 30
3443: PPUSH
3444: LD_INT 0
3446: PPUSH
3447: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3451: LD_EXP 18
3455: PPUSH
3456: LD_VAR 0 3
3460: PPUSH
3461: CALL_OW 52
// end ; uc_nation := 3 ;
3465: LD_ADDR_OWVAR 21
3469: PUSH
3470: LD_INT 3
3472: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3473: LD_INT 22
3475: PPUSH
3476: LD_INT 3
3478: PPUSH
3479: LD_INT 1
3481: PPUSH
3482: LD_INT 45
3484: PPUSH
3485: LD_INT 100
3487: PPUSH
3488: CALL 57276 0 5
// veh := CreateVehicle ;
3492: LD_ADDR_VAR 0 3
3496: PUSH
3497: CALL_OW 45
3501: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3502: LD_VAR 0 3
3506: PPUSH
3507: LD_INT 7
3509: NEG
3510: PPUSH
3511: CALL_OW 242
// SetDir ( veh , 3 ) ;
3515: LD_VAR 0 3
3519: PPUSH
3520: LD_INT 3
3522: PPUSH
3523: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3527: LD_VAR 0 3
3531: PPUSH
3532: LD_INT 31
3534: PPUSH
3535: LD_INT 0
3537: PPUSH
3538: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3542: LD_EXP 44
3546: PPUSH
3547: LD_VAR 0 3
3551: PPUSH
3552: CALL_OW 52
// if Gossudarov then
3556: LD_EXP 30
3560: IFFALSE 3647
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3562: LD_INT 22
3564: PPUSH
3565: LD_INT 3
3567: PPUSH
3568: LD_INT 1
3570: PPUSH
3571: LD_INT 51
3573: PPUSH
3574: LD_INT 100
3576: PPUSH
3577: CALL 57276 0 5
// veh := CreateVehicle ;
3581: LD_ADDR_VAR 0 3
3585: PUSH
3586: CALL_OW 45
3590: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3591: LD_VAR 0 3
3595: PPUSH
3596: LD_INT 3
3598: PPUSH
3599: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3603: LD_VAR 0 3
3607: PPUSH
3608: LD_INT 30
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3618: LD_EXP 30
3622: PPUSH
3623: LD_VAR 0 3
3627: PPUSH
3628: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3632: LD_VAR 0 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: LD_INT 100
3642: PPUSH
3643: CALL_OW 290
// end ; for i in selected do
3647: LD_ADDR_VAR 0 2
3651: PUSH
3652: LD_VAR 0 4
3656: PUSH
3657: FOR_IN
3658: IFFALSE 4216
// begin uc_nation := GetNation ( i ) ;
3660: LD_ADDR_OWVAR 21
3664: PUSH
3665: LD_VAR 0 2
3669: PPUSH
3670: CALL_OW 248
3674: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3675: LD_VAR 0 2
3679: PUSH
3680: LD_EXP 14
3684: PUSH
3685: LD_EXP 15
3689: PUSH
3690: LD_EXP 17
3694: PUSH
3695: LD_EXP 16
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: LIST
3704: LIST
3705: IN
3706: IFFALSE 3729
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3708: LD_INT 5
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 6
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 57276 0 5
3727: GO 4163
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3729: LD_VAR 0 2
3733: PUSH
3734: LD_EXP 37
3738: PUSH
3739: LD_EXP 42
3743: PUSH
3744: LD_EXP 40
3748: PUSH
3749: LD_EXP 32
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: LIST
3758: LIST
3759: IN
3760: IFFALSE 3791
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3762: LD_INT 24
3764: PPUSH
3765: LD_INT 1
3767: PPUSH
3768: LD_INT 1
3770: PPUSH
3771: LD_INT 46
3773: PPUSH
3774: LD_INT 65
3776: PPUSH
3777: LD_INT 75
3779: PPUSH
3780: CALL_OW 12
3784: PPUSH
3785: CALL 57276 0 5
3789: GO 4163
// if i = Karamazov then
3791: LD_VAR 0 2
3795: PUSH
3796: LD_EXP 43
3800: EQUAL
3801: IFFALSE 3824
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3803: LD_INT 22
3805: PPUSH
3806: LD_INT 3
3808: PPUSH
3809: LD_INT 1
3811: PPUSH
3812: LD_INT 52
3814: PPUSH
3815: LD_INT 100
3817: PPUSH
3818: CALL 57276 0 5
3822: GO 4163
// if i = Brown then
3824: LD_VAR 0 2
3828: PUSH
3829: LD_EXP 19
3833: EQUAL
3834: IFFALSE 3857
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3836: LD_INT 3
3838: PPUSH
3839: LD_INT 3
3841: PPUSH
3842: LD_INT 1
3844: PPUSH
3845: LD_INT 13
3847: PPUSH
3848: LD_INT 100
3850: PPUSH
3851: CALL 57276 0 5
3855: GO 4163
// if uc_nation = nation_american then
3857: LD_OWVAR 21
3861: PUSH
3862: LD_INT 1
3864: EQUAL
3865: IFFALSE 4016
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3867: LD_INT 3
3869: PUSH
3870: LD_INT 5
3872: PUSH
3873: LD_INT 5
3875: PUSH
3876: EMPTY
3877: LIST
3878: LIST
3879: LIST
3880: PUSH
3881: LD_OWVAR 21
3885: PUSH
3886: LD_INT 3
3888: MOD
3889: PUSH
3890: LD_INT 1
3892: PLUS
3893: ARRAY
3894: PPUSH
3895: LD_INT 1
3897: PUSH
3898: LD_INT 3
3900: PUSH
3901: LD_INT 1
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: PUSH
3909: LD_OWVAR 21
3913: PUSH
3914: LD_INT 3
3916: MOD
3917: PUSH
3918: LD_INT 1
3920: PLUS
3921: ARRAY
3922: PPUSH
3923: LD_INT 1
3925: PPUSH
3926: LD_INT 11
3928: PUSH
3929: LD_INT 4
3931: PUSH
3932: LD_INT 5
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 6
3942: PUSH
3943: LD_INT 7
3945: PUSH
3946: LD_INT 9
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: LIST
3953: PUSH
3954: LD_INT 6
3956: PUSH
3957: LD_INT 9
3959: PUSH
3960: LD_INT 12
3962: PUSH
3963: EMPTY
3964: LIST
3965: LIST
3966: LIST
3967: PUSH
3968: EMPTY
3969: LIST
3970: LIST
3971: LIST
3972: PUSH
3973: LD_OWVAR 21
3977: PUSH
3978: LD_INT 3
3980: MOD
3981: PUSH
3982: LD_INT 1
3984: PLUS
3985: ARRAY
3986: PUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 3
3992: PPUSH
3993: CALL_OW 12
3997: ARRAY
3998: PPUSH
3999: LD_INT 65
4001: PPUSH
4002: LD_INT 75
4004: PPUSH
4005: CALL_OW 12
4009: PPUSH
4010: CALL 57276 0 5
// end else
4014: GO 4163
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4016: LD_INT 22
4018: PUSH
4019: LD_INT 23
4021: PUSH
4022: LD_INT 23
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: PUSH
4030: LD_OWVAR 21
4034: PUSH
4035: LD_INT 3
4037: MOD
4038: PUSH
4039: LD_INT 1
4041: PLUS
4042: ARRAY
4043: PPUSH
4044: LD_INT 1
4046: PUSH
4047: LD_INT 3
4049: PUSH
4050: LD_INT 1
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: PUSH
4058: LD_OWVAR 21
4062: PUSH
4063: LD_INT 3
4065: MOD
4066: PUSH
4067: LD_INT 1
4069: PLUS
4070: ARRAY
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: LD_INT 45
4077: PUSH
4078: LD_INT 43
4080: PUSH
4081: LD_INT 44
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: LIST
4088: PUSH
4089: LD_INT 46
4091: PUSH
4092: LD_INT 45
4094: PUSH
4095: LD_INT 44
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: LIST
4102: PUSH
4103: LD_INT 46
4105: PUSH
4106: LD_INT 43
4108: PUSH
4109: LD_INT 45
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: LIST
4116: PUSH
4117: EMPTY
4118: LIST
4119: LIST
4120: LIST
4121: PUSH
4122: LD_OWVAR 21
4126: PUSH
4127: LD_INT 3
4129: MOD
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: ARRAY
4135: PUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 3
4141: PPUSH
4142: CALL_OW 12
4146: ARRAY
4147: PPUSH
4148: LD_INT 65
4150: PPUSH
4151: LD_INT 75
4153: PPUSH
4154: CALL_OW 12
4158: PPUSH
4159: CALL 57276 0 5
// end ; veh := CreateVehicle ;
4163: LD_ADDR_VAR 0 3
4167: PUSH
4168: CALL_OW 45
4172: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4173: LD_VAR 0 3
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4185: LD_VAR 0 3
4189: PPUSH
4190: LD_INT 30
4192: PPUSH
4193: LD_INT 0
4195: PPUSH
4196: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4200: LD_VAR 0 2
4204: PPUSH
4205: LD_VAR 0 3
4209: PPUSH
4210: CALL_OW 52
// end ;
4214: GO 3657
4216: POP
4217: POP
// if artifactArCaptured then
4218: LD_EXP 6
4222: IFFALSE 4308
// begin uc_nation := nation_american ;
4224: LD_ADDR_OWVAR 21
4228: PUSH
4229: LD_INT 1
4231: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4232: LD_INT 3
4234: PPUSH
4235: LD_INT 3
4237: PPUSH
4238: LD_INT 3
4240: PPUSH
4241: LD_INT 12
4243: PPUSH
4244: LD_INT 100
4246: PPUSH
4247: CALL 57276 0 5
// veh := CreateVehicle ;
4251: LD_ADDR_VAR 0 3
4255: PUSH
4256: CALL_OW 45
4260: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4261: LD_VAR 0 3
4265: PPUSH
4266: LD_INT 3
4268: PPUSH
4269: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4273: LD_VAR 0 3
4277: PPUSH
4278: LD_INT 198
4280: PPUSH
4281: LD_INT 22
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4291: LD_VAR 0 3
4295: PPUSH
4296: LD_INT 4
4298: PPUSH
4299: LD_INT 50
4301: PPUSH
4302: CALL_OW 290
// end else
4306: GO 4327
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4308: LD_INT 4
4310: PPUSH
4311: LD_INT 267
4313: PPUSH
4314: LD_INT 226
4316: PPUSH
4317: LD_INT 5
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 58
// end ; uc_nation := nation_american ;
4327: LD_ADDR_OWVAR 21
4331: PUSH
4332: LD_INT 1
4334: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4335: LD_INT 3
4337: PPUSH
4338: LD_INT 3
4340: PPUSH
4341: LD_INT 3
4343: PPUSH
4344: LD_INT 12
4346: PPUSH
4347: LD_INT 100
4349: PPUSH
4350: CALL 57276 0 5
// veh := CreateVehicle ;
4354: LD_ADDR_VAR 0 3
4358: PUSH
4359: CALL_OW 45
4363: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4364: LD_VAR 0 3
4368: PPUSH
4369: LD_INT 3
4371: PPUSH
4372: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4376: LD_VAR 0 3
4380: PPUSH
4381: LD_INT 218
4383: PPUSH
4384: LD_INT 23
4386: PPUSH
4387: LD_INT 0
4389: PPUSH
4390: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4394: LD_VAR 0 3
4398: PPUSH
4399: LD_INT 4
4401: PPUSH
4402: LD_INT 30
4404: PPUSH
4405: CALL_OW 290
// uc_nation := nation_russian ;
4409: LD_ADDR_OWVAR 21
4413: PUSH
4414: LD_INT 3
4416: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4417: LD_INT 22
4419: PPUSH
4420: LD_INT 3
4422: PPUSH
4423: LD_INT 3
4425: PPUSH
4426: LD_INT 51
4428: PPUSH
4429: LD_INT 100
4431: PPUSH
4432: CALL 57276 0 5
// veh := CreateVehicle ;
4436: LD_ADDR_VAR 0 3
4440: PUSH
4441: CALL_OW 45
4445: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4446: LD_VAR 0 3
4450: PPUSH
4451: LD_INT 3
4453: PPUSH
4454: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4458: LD_VAR 0 3
4462: PPUSH
4463: LD_INT 214
4465: PPUSH
4466: LD_INT 20
4468: PPUSH
4469: LD_INT 0
4471: PPUSH
4472: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 4
4483: PPUSH
4484: LD_INT 40
4486: PPUSH
4487: CALL_OW 290
// end ; end_of_file
4491: LD_VAR 0 1
4495: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4496: LD_INT 0
4498: PPUSH
4499: PPUSH
4500: PPUSH
4501: PPUSH
4502: PPUSH
4503: PPUSH
4504: PPUSH
4505: PPUSH
4506: PPUSH
4507: PPUSH
// InitHc ;
4508: CALL_OW 19
// uc_side := 1 ;
4512: LD_ADDR_OWVAR 20
4516: PUSH
4517: LD_INT 1
4519: ST_TO_ADDR
// uc_nation := 1 ;
4520: LD_ADDR_OWVAR 21
4524: PUSH
4525: LD_INT 1
4527: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4528: LD_INT 387
4530: PPUSH
4531: CALL_OW 274
4535: PPUSH
4536: LD_INT 1
4538: PPUSH
4539: LD_INT 25500
4541: PPUSH
4542: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4546: LD_INT 387
4548: PPUSH
4549: CALL_OW 274
4553: PPUSH
4554: LD_INT 2
4556: PPUSH
4557: LD_INT 4000
4559: PPUSH
4560: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4564: LD_INT 387
4566: PPUSH
4567: CALL_OW 274
4571: PPUSH
4572: LD_INT 3
4574: PPUSH
4575: LD_INT 50
4577: PPUSH
4578: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4582: LD_INT 476
4584: PPUSH
4585: CALL_OW 274
4589: PPUSH
4590: LD_INT 1
4592: PPUSH
4593: LD_INT 7500
4595: PPUSH
4596: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4600: LD_INT 476
4602: PPUSH
4603: CALL_OW 274
4607: PPUSH
4608: LD_INT 2
4610: PPUSH
4611: LD_INT 4000
4613: PPUSH
4614: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4618: LD_INT 476
4620: PPUSH
4621: CALL_OW 274
4625: PPUSH
4626: LD_INT 3
4628: PPUSH
4629: LD_INT 10
4631: PPUSH
4632: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4636: LD_ADDR_EXP 47
4640: PUSH
4641: LD_STRING Powell
4643: PPUSH
4644: CALL_OW 25
4648: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4649: LD_EXP 47
4653: PPUSH
4654: LD_INT 387
4656: PPUSH
4657: CALL_OW 52
// tmp := [ ] ;
4661: LD_ADDR_VAR 0 6
4665: PUSH
4666: EMPTY
4667: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4668: LD_ADDR_EXP 14
4672: PUSH
4673: LD_STRING Lisa
4675: PPUSH
4676: LD_EXP 1
4680: NOT
4681: PPUSH
4682: LD_STRING 12p_
4684: PPUSH
4685: CALL 50250 0 3
4689: ST_TO_ADDR
// if Lisa then
4690: LD_EXP 14
4694: IFFALSE 4712
// tmp := tmp ^ Lisa ;
4696: LD_ADDR_VAR 0 6
4700: PUSH
4701: LD_VAR 0 6
4705: PUSH
4706: LD_EXP 14
4710: ADD
4711: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4712: LD_ADDR_EXP 15
4716: PUSH
4717: LD_STRING Donaldson
4719: PPUSH
4720: LD_EXP 1
4724: NOT
4725: PPUSH
4726: LD_STRING 12p_
4728: PPUSH
4729: CALL 50250 0 3
4733: ST_TO_ADDR
// if Donaldson then
4734: LD_EXP 15
4738: IFFALSE 4756
// tmp := tmp ^ Donaldson ;
4740: LD_ADDR_VAR 0 6
4744: PUSH
4745: LD_VAR 0 6
4749: PUSH
4750: LD_EXP 15
4754: ADD
4755: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4756: LD_ADDR_EXP 16
4760: PUSH
4761: LD_STRING Bobby
4763: PPUSH
4764: LD_EXP 1
4768: NOT
4769: PPUSH
4770: LD_STRING 12p_
4772: PPUSH
4773: CALL 50250 0 3
4777: ST_TO_ADDR
// if Bobby then
4778: LD_EXP 16
4782: IFFALSE 4800
// tmp := tmp ^ Bobby ;
4784: LD_ADDR_VAR 0 6
4788: PUSH
4789: LD_VAR 0 6
4793: PUSH
4794: LD_EXP 16
4798: ADD
4799: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4800: LD_ADDR_EXP 17
4804: PUSH
4805: LD_STRING Cyrus
4807: PPUSH
4808: LD_EXP 1
4812: NOT
4813: PPUSH
4814: LD_STRING 12p_
4816: PPUSH
4817: CALL 50250 0 3
4821: ST_TO_ADDR
// if Cyrus then
4822: LD_EXP 17
4826: IFFALSE 4844
// tmp := tmp ^ Cyrus ;
4828: LD_ADDR_VAR 0 6
4832: PUSH
4833: LD_VAR 0 6
4837: PUSH
4838: LD_EXP 17
4842: ADD
4843: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4844: LD_ADDR_EXP 19
4848: PUSH
4849: LD_STRING Brown
4851: PPUSH
4852: LD_EXP 1
4856: NOT
4857: PPUSH
4858: LD_STRING 12p_
4860: PPUSH
4861: CALL 50250 0 3
4865: ST_TO_ADDR
// if Brown then
4866: LD_EXP 19
4870: IFFALSE 4888
// tmp := tmp ^ Brown ;
4872: LD_ADDR_VAR 0 6
4876: PUSH
4877: LD_VAR 0 6
4881: PUSH
4882: LD_EXP 19
4886: ADD
4887: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4888: LD_ADDR_EXP 20
4892: PUSH
4893: LD_STRING Gladstone
4895: PPUSH
4896: LD_EXP 1
4900: NOT
4901: PPUSH
4902: LD_STRING 12p_
4904: PPUSH
4905: CALL 50250 0 3
4909: ST_TO_ADDR
// if Gladstone then
4910: LD_EXP 20
4914: IFFALSE 4932
// tmp := tmp ^ Gladstone ;
4916: LD_ADDR_VAR 0 6
4920: PUSH
4921: LD_VAR 0 6
4925: PUSH
4926: LD_EXP 20
4930: ADD
4931: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4932: LD_ADDR_EXP 21
4936: PUSH
4937: LD_STRING Houten
4939: PPUSH
4940: LD_EXP 1
4944: NOT
4945: PPUSH
4946: LD_STRING 12p_
4948: PPUSH
4949: CALL 50250 0 3
4953: ST_TO_ADDR
// if Houten then
4954: LD_EXP 21
4958: IFFALSE 4976
// tmp := tmp ^ Houten ;
4960: LD_ADDR_VAR 0 6
4964: PUSH
4965: LD_VAR 0 6
4969: PUSH
4970: LD_EXP 21
4974: ADD
4975: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
4976: LD_ADDR_EXP 22
4980: PUSH
4981: LD_STRING Cornel
4983: PPUSH
4984: LD_EXP 1
4988: NOT
4989: PPUSH
4990: LD_STRING 12p_
4992: PPUSH
4993: CALL 50250 0 3
4997: ST_TO_ADDR
// if Cornel then
4998: LD_EXP 22
5002: IFFALSE 5020
// tmp := tmp ^ Cornel ;
5004: LD_ADDR_VAR 0 6
5008: PUSH
5009: LD_VAR 0 6
5013: PUSH
5014: LD_EXP 22
5018: ADD
5019: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5020: LD_ADDR_EXP 23
5024: PUSH
5025: LD_STRING Gary
5027: PPUSH
5028: LD_EXP 1
5032: NOT
5033: PPUSH
5034: LD_STRING 12p_
5036: PPUSH
5037: CALL 50250 0 3
5041: ST_TO_ADDR
// if Gary then
5042: LD_EXP 23
5046: IFFALSE 5064
// tmp := tmp ^ Gary ;
5048: LD_ADDR_VAR 0 6
5052: PUSH
5053: LD_VAR 0 6
5057: PUSH
5058: LD_EXP 23
5062: ADD
5063: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5064: LD_ADDR_EXP 25
5068: PUSH
5069: LD_STRING Kikuchi
5071: PPUSH
5072: LD_EXP 1
5076: NOT
5077: PPUSH
5078: LD_STRING 12p_
5080: PPUSH
5081: CALL 50250 0 3
5085: ST_TO_ADDR
// if Kikuchi then
5086: LD_EXP 25
5090: IFFALSE 5108
// tmp := tmp ^ Kikuchi ;
5092: LD_ADDR_VAR 0 6
5096: PUSH
5097: LD_VAR 0 6
5101: PUSH
5102: LD_EXP 25
5106: ADD
5107: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5108: LD_ADDR_VAR 0 6
5112: PUSH
5113: LD_VAR 0 6
5117: PUSH
5118: LD_STRING 12p_others
5120: PPUSH
5121: CALL_OW 31
5125: UNION
5126: ST_TO_ADDR
// if tmp < 36 then
5127: LD_VAR 0 6
5131: PUSH
5132: LD_INT 36
5134: LESS
5135: IFFALSE 5202
// for i = 1 to 36 - tmp do
5137: LD_ADDR_VAR 0 2
5141: PUSH
5142: DOUBLE
5143: LD_INT 1
5145: DEC
5146: ST_TO_ADDR
5147: LD_INT 36
5149: PUSH
5150: LD_VAR 0 6
5154: MINUS
5155: PUSH
5156: FOR_TO
5157: IFFALSE 5200
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5159: LD_INT 1
5161: PPUSH
5162: LD_VAR 0 2
5166: PUSH
5167: LD_INT 4
5169: MOD
5170: PUSH
5171: LD_INT 1
5173: PLUS
5174: PPUSH
5175: LD_INT 10
5177: PPUSH
5178: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5182: LD_ADDR_VAR 0 6
5186: PUSH
5187: LD_VAR 0 6
5191: PUSH
5192: CALL_OW 44
5196: ADD
5197: ST_TO_ADDR
// end ;
5198: GO 5156
5200: POP
5201: POP
// for i in tmp do
5202: LD_ADDR_VAR 0 2
5206: PUSH
5207: LD_VAR 0 6
5211: PUSH
5212: FOR_IN
5213: IFFALSE 5238
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5215: LD_VAR 0 2
5219: PPUSH
5220: LD_INT 62
5222: PPUSH
5223: LD_INT 93
5225: PPUSH
5226: LD_INT 9
5228: PPUSH
5229: LD_INT 0
5231: PPUSH
5232: CALL_OW 50
5236: GO 5212
5238: POP
5239: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
5240: LD_ADDR_EXP 74
5244: PUSH
5245: LD_EXP 74
5249: PPUSH
5250: LD_INT 4
5252: PPUSH
5253: LD_INT 22
5255: PUSH
5256: LD_INT 1
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PPUSH
5263: CALL_OW 69
5267: PPUSH
5268: CALL_OW 1
5272: ST_TO_ADDR
// uc_side := 0 ;
5273: LD_ADDR_OWVAR 20
5277: PUSH
5278: LD_INT 0
5280: ST_TO_ADDR
// uc_nation := 0 ;
5281: LD_ADDR_OWVAR 21
5285: PUSH
5286: LD_INT 0
5288: ST_TO_ADDR
// for i = 1 to 4 do
5289: LD_ADDR_VAR 0 2
5293: PUSH
5294: DOUBLE
5295: LD_INT 1
5297: DEC
5298: ST_TO_ADDR
5299: LD_INT 4
5301: PUSH
5302: FOR_TO
5303: IFFALSE 5334
// begin InitHc ;
5305: CALL_OW 19
// hc_class := class_apeman ;
5309: LD_ADDR_OWVAR 28
5313: PUSH
5314: LD_INT 12
5316: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5317: CALL_OW 44
5321: PPUSH
5322: LD_INT 11
5324: PPUSH
5325: LD_INT 0
5327: PPUSH
5328: CALL_OW 49
// end ;
5332: GO 5302
5334: POP
5335: POP
// end ;
5336: LD_VAR 0 1
5340: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5341: LD_EXP 4
5345: NOT
5346: PUSH
5347: LD_INT 4
5349: PPUSH
5350: LD_INT 1
5352: PPUSH
5353: CALL 45324 0 2
5357: NOT
5358: AND
5359: IFFALSE 6131
5361: GO 5363
5363: DISABLE
5364: LD_INT 0
5366: PPUSH
5367: PPUSH
5368: PPUSH
// begin enable ;
5369: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5370: LD_INT 22
5372: PUSH
5373: LD_INT 1
5375: PUSH
5376: EMPTY
5377: LIST
5378: LIST
5379: PUSH
5380: LD_INT 23
5382: PUSH
5383: LD_INT 1
5385: PUSH
5386: EMPTY
5387: LIST
5388: LIST
5389: PUSH
5390: LD_INT 30
5392: PUSH
5393: LD_INT 3
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PUSH
5400: EMPTY
5401: LIST
5402: LIST
5403: LIST
5404: PPUSH
5405: CALL_OW 69
5409: NOT
5410: IFFALSE 5414
// exit ;
5412: GO 6131
// if Prob ( 40 ) then
5414: LD_INT 40
5416: PPUSH
5417: CALL_OW 13
5421: IFFALSE 5548
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5423: LD_INT 4
5425: PPUSH
5426: LD_INT 5
5428: PUSH
5429: LD_INT 1
5431: PUSH
5432: LD_INT 2
5434: PUSH
5435: LD_INT 7
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: LIST
5442: LIST
5443: PUSH
5444: LD_INT 5
5446: PUSH
5447: LD_INT 1
5449: PUSH
5450: LD_INT 2
5452: PUSH
5453: LD_INT 7
5455: PUSH
5456: EMPTY
5457: LIST
5458: LIST
5459: LIST
5460: LIST
5461: PUSH
5462: LD_INT 5
5464: PUSH
5465: LD_INT 1
5467: PUSH
5468: LD_INT 2
5470: PUSH
5471: LD_INT 7
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 5
5482: PUSH
5483: LD_INT 1
5485: PUSH
5486: LD_INT 2
5488: PUSH
5489: LD_INT 6
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: PUSH
5498: LD_INT 5
5500: PUSH
5501: LD_INT 1
5503: PUSH
5504: LD_INT 2
5506: PUSH
5507: LD_INT 6
5509: PUSH
5510: EMPTY
5511: LIST
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_INT 5
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: LD_INT 2
5524: PUSH
5525: LD_INT 6
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: LIST
5532: LIST
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: LIST
5538: LIST
5539: LIST
5540: LIST
5541: PPUSH
5542: CALL 43906 0 2
// end else
5546: GO 5671
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5548: LD_INT 4
5550: PPUSH
5551: LD_INT 5
5553: PUSH
5554: LD_INT 1
5556: PUSH
5557: LD_INT 2
5559: PUSH
5560: LD_INT 7
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: LIST
5567: LIST
5568: PUSH
5569: LD_INT 5
5571: PUSH
5572: LD_INT 1
5574: PUSH
5575: LD_INT 2
5577: PUSH
5578: LD_INT 9
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: LIST
5585: LIST
5586: PUSH
5587: LD_INT 5
5589: PUSH
5590: LD_INT 1
5592: PUSH
5593: LD_INT 2
5595: PUSH
5596: LD_INT 9
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 5
5607: PUSH
5608: LD_INT 1
5610: PUSH
5611: LD_INT 2
5613: PUSH
5614: LD_INT 6
5616: PUSH
5617: EMPTY
5618: LIST
5619: LIST
5620: LIST
5621: LIST
5622: PUSH
5623: LD_INT 5
5625: PUSH
5626: LD_INT 1
5628: PUSH
5629: LD_INT 2
5631: PUSH
5632: LD_INT 6
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: PUSH
5641: LD_INT 5
5643: PUSH
5644: LD_INT 1
5646: PUSH
5647: LD_INT 2
5649: PUSH
5650: LD_INT 6
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: PUSH
5659: EMPTY
5660: LIST
5661: LIST
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: PPUSH
5667: CALL 43906 0 2
// end ; repeat wait ( 0 0$1 ) ;
5671: LD_INT 35
5673: PPUSH
5674: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5678: LD_INT 4
5680: PPUSH
5681: LD_INT 1
5683: PPUSH
5684: CALL 45324 0 2
5688: PUSH
5689: LD_INT 6
5691: GREATEREQUAL
5692: IFFALSE 5671
// wait ( 0 0$30 ) ;
5694: LD_INT 1050
5696: PPUSH
5697: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5701: LD_ADDR_VAR 0 2
5705: PUSH
5706: LD_INT 4
5708: PPUSH
5709: LD_INT 1
5711: PPUSH
5712: CALL 45324 0 2
5716: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5717: LD_ADDR_EXP 93
5721: PUSH
5722: LD_EXP 93
5726: PPUSH
5727: LD_INT 4
5729: PPUSH
5730: LD_EXP 93
5734: PUSH
5735: LD_INT 4
5737: ARRAY
5738: PUSH
5739: LD_VAR 0 2
5743: DIFF
5744: PPUSH
5745: CALL_OW 1
5749: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5750: LD_ADDR_VAR 0 3
5754: PUSH
5755: LD_INT 0
5757: PPUSH
5758: LD_INT 2
5760: PPUSH
5761: CALL_OW 12
5765: ST_TO_ADDR
// if target then
5766: LD_VAR 0 3
5770: IFFALSE 5898
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5772: LD_ADDR_VAR 0 2
5776: PUSH
5777: LD_VAR 0 2
5781: PPUSH
5782: LD_INT 24
5784: PUSH
5785: LD_INT 250
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: PPUSH
5792: CALL_OW 72
5796: ST_TO_ADDR
// for i in tmp do
5797: LD_ADDR_VAR 0 1
5801: PUSH
5802: LD_VAR 0 2
5806: PUSH
5807: FOR_IN
5808: IFFALSE 5848
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5810: LD_VAR 0 1
5814: PPUSH
5815: LD_INT 114
5817: PPUSH
5818: LD_INT 108
5820: PPUSH
5821: CALL_OW 297
5825: PUSH
5826: LD_INT 9
5828: GREATER
5829: IFFALSE 5846
// ComMoveXY ( i , 114 , 108 ) ;
5831: LD_VAR 0 1
5835: PPUSH
5836: LD_INT 114
5838: PPUSH
5839: LD_INT 108
5841: PPUSH
5842: CALL_OW 111
5846: GO 5807
5848: POP
5849: POP
// wait ( 0 0$1 ) ;
5850: LD_INT 35
5852: PPUSH
5853: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5857: LD_VAR 0 2
5861: PPUSH
5862: LD_INT 92
5864: PUSH
5865: LD_INT 114
5867: PUSH
5868: LD_INT 108
5870: PUSH
5871: LD_INT 9
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 72
5884: PUSH
5885: LD_VAR 0 2
5889: PUSH
5890: LD_INT 1
5892: MINUS
5893: GREATEREQUAL
5894: IFFALSE 5772
// end else
5896: GO 6022
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5898: LD_ADDR_VAR 0 2
5902: PUSH
5903: LD_VAR 0 2
5907: PPUSH
5908: LD_INT 24
5910: PUSH
5911: LD_INT 250
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PPUSH
5918: CALL_OW 72
5922: ST_TO_ADDR
// for i in tmp do
5923: LD_ADDR_VAR 0 1
5927: PUSH
5928: LD_VAR 0 2
5932: PUSH
5933: FOR_IN
5934: IFFALSE 5974
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5936: LD_VAR 0 1
5940: PPUSH
5941: LD_INT 129
5943: PPUSH
5944: LD_INT 139
5946: PPUSH
5947: CALL_OW 297
5951: PUSH
5952: LD_INT 9
5954: GREATER
5955: IFFALSE 5972
// ComMoveXY ( i , 129 , 139 ) ;
5957: LD_VAR 0 1
5961: PPUSH
5962: LD_INT 129
5964: PPUSH
5965: LD_INT 139
5967: PPUSH
5968: CALL_OW 111
5972: GO 5933
5974: POP
5975: POP
// wait ( 0 0$1 ) ;
5976: LD_INT 35
5978: PPUSH
5979: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
5983: LD_VAR 0 2
5987: PPUSH
5988: LD_INT 92
5990: PUSH
5991: LD_INT 129
5993: PUSH
5994: LD_INT 139
5996: PUSH
5997: LD_INT 9
5999: PUSH
6000: EMPTY
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: PPUSH
6006: CALL_OW 72
6010: PUSH
6011: LD_VAR 0 2
6015: PUSH
6016: LD_INT 1
6018: MINUS
6019: GREATEREQUAL
6020: IFFALSE 5898
// end ; repeat wait ( 0 0$1 ) ;
6022: LD_INT 35
6024: PPUSH
6025: CALL_OW 67
// for i in tmp do
6029: LD_ADDR_VAR 0 1
6033: PUSH
6034: LD_VAR 0 2
6038: PUSH
6039: FOR_IN
6040: IFFALSE 6122
// begin if GetLives ( i ) > 251 then
6042: LD_VAR 0 1
6046: PPUSH
6047: CALL_OW 256
6051: PUSH
6052: LD_INT 251
6054: GREATER
6055: IFFALSE 6093
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6057: LD_VAR 0 1
6061: PPUSH
6062: LD_INT 81
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: PPUSH
6072: CALL_OW 69
6076: PPUSH
6077: LD_VAR 0 1
6081: PPUSH
6082: CALL_OW 74
6086: PPUSH
6087: CALL_OW 115
6091: GO 6120
// if IsDead ( i ) then
6093: LD_VAR 0 1
6097: PPUSH
6098: CALL_OW 301
6102: IFFALSE 6120
// tmp := tmp diff i ;
6104: LD_ADDR_VAR 0 2
6108: PUSH
6109: LD_VAR 0 2
6113: PUSH
6114: LD_VAR 0 1
6118: DIFF
6119: ST_TO_ADDR
// end ;
6120: GO 6039
6122: POP
6123: POP
// until not tmp ;
6124: LD_VAR 0 2
6128: NOT
6129: IFFALSE 6022
// end ;
6131: PPOPN 3
6133: END
// every 30 30$00 trigger not americanDestroyed do
6134: LD_EXP 4
6138: NOT
6139: IFFALSE 6204
6141: GO 6143
6143: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6144: LD_INT 63000
6146: PUSH
6147: LD_INT 42000
6149: PUSH
6150: LD_INT 21000
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: LIST
6157: PUSH
6158: LD_OWVAR 67
6162: ARRAY
6163: PPUSH
6164: CALL_OW 67
// if americanDestroyed then
6168: LD_EXP 4
6172: IFFALSE 6176
// exit ;
6174: GO 6204
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6176: LD_INT 4
6178: PPUSH
6179: LD_INT 5
6181: PUSH
6182: LD_INT 3
6184: PUSH
6185: LD_INT 1
6187: PUSH
6188: LD_INT 8
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: EMPTY
6198: LIST
6199: PPUSH
6200: CALL 43906 0 2
// end ; end_of_file
6204: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6205: LD_INT 0
6207: PPUSH
6208: PPUSH
6209: PPUSH
6210: PPUSH
6211: PPUSH
// side := 2 ;
6212: LD_ADDR_VAR 0 5
6216: PUSH
6217: LD_INT 2
6219: ST_TO_ADDR
// InitHc ;
6220: CALL_OW 19
// uc_side := side ;
6224: LD_ADDR_OWVAR 20
6228: PUSH
6229: LD_VAR 0 5
6233: ST_TO_ADDR
// uc_nation := 2 ;
6234: LD_ADDR_OWVAR 21
6238: PUSH
6239: LD_INT 2
6241: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6242: LD_ADDR_VAR 0 4
6246: PUSH
6247: LD_INT 22
6249: PUSH
6250: LD_VAR 0 5
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: PUSH
6259: LD_INT 30
6261: PUSH
6262: LD_INT 32
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: PUSH
6269: LD_INT 58
6271: PUSH
6272: EMPTY
6273: LIST
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: LIST
6279: PPUSH
6280: CALL_OW 69
6284: ST_TO_ADDR
// for i = 1 to 10 do
6285: LD_ADDR_VAR 0 2
6289: PUSH
6290: DOUBLE
6291: LD_INT 1
6293: DEC
6294: ST_TO_ADDR
6295: LD_INT 10
6297: PUSH
6298: FOR_TO
6299: IFFALSE 6371
// begin uc_nation := nation_nature ;
6301: LD_ADDR_OWVAR 21
6305: PUSH
6306: LD_INT 0
6308: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6309: LD_ADDR_OWVAR 28
6313: PUSH
6314: LD_INT 15
6316: ST_TO_ADDR
// hc_gallery :=  ;
6317: LD_ADDR_OWVAR 33
6321: PUSH
6322: LD_STRING 
6324: ST_TO_ADDR
// hc_name :=  ;
6325: LD_ADDR_OWVAR 26
6329: PUSH
6330: LD_STRING 
6332: ST_TO_ADDR
// un := CreateHuman ;
6333: LD_ADDR_VAR 0 3
6337: PUSH
6338: CALL_OW 44
6342: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6343: LD_VAR 0 3
6347: PPUSH
6348: LD_VAR 0 4
6352: PUSH
6353: LD_VAR 0 4
6357: PUSH
6358: LD_VAR 0 2
6362: MINUS
6363: ARRAY
6364: PPUSH
6365: CALL_OW 52
// end ;
6369: GO 6298
6371: POP
6372: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6373: LD_INT 503
6375: PPUSH
6376: LD_INT 27
6378: PPUSH
6379: LD_STRING 
6381: PPUSH
6382: LD_INT 8
6384: PUSH
6385: LD_INT 9
6387: PUSH
6388: LD_INT 10
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_OWVAR 67
6400: ARRAY
6401: PPUSH
6402: LD_INT 3000
6404: PUSH
6405: LD_INT 500
6407: PUSH
6408: LD_INT 150
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: LIST
6415: PPUSH
6416: LD_INT 16
6418: PUSH
6419: LD_INT 6
6421: PUSH
6422: LD_INT 6
6424: PUSH
6425: LD_INT 6
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: LIST
6432: LIST
6433: PPUSH
6434: CALL 60685 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6438: LD_ADDR_EXP 74
6442: PUSH
6443: LD_EXP 74
6447: PPUSH
6448: LD_INT 1
6450: PPUSH
6451: LD_INT 22
6453: PUSH
6454: LD_VAR 0 5
6458: PUSH
6459: EMPTY
6460: LIST
6461: LIST
6462: PUSH
6463: LD_INT 23
6465: PUSH
6466: LD_INT 2
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 3
6475: PUSH
6476: LD_INT 21
6478: PUSH
6479: LD_INT 2
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: PUSH
6486: EMPTY
6487: LIST
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: PPUSH
6495: CALL_OW 69
6499: PPUSH
6500: CALL_OW 1
6504: ST_TO_ADDR
// end ;
6505: LD_VAR 0 1
6509: RET
// export Omar ; export function PrepareOmarAli ; begin
6510: LD_INT 0
6512: PPUSH
// uc_side := 5 ;
6513: LD_ADDR_OWVAR 20
6517: PUSH
6518: LD_INT 5
6520: ST_TO_ADDR
// uc_nation := 2 ;
6521: LD_ADDR_OWVAR 21
6525: PUSH
6526: LD_INT 2
6528: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6529: LD_ADDR_EXP 48
6533: PUSH
6534: LD_STRING Omar
6536: PPUSH
6537: CALL_OW 25
6541: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6542: LD_EXP 48
6546: PPUSH
6547: LD_INT 330
6549: PPUSH
6550: LD_INT 244
6552: PPUSH
6553: LD_INT 0
6555: PPUSH
6556: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6560: LD_EXP 48
6564: PPUSH
6565: LD_INT 22
6567: PUSH
6568: LD_INT 7
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: PPUSH
6575: CALL_OW 69
6579: PPUSH
6580: LD_EXP 48
6584: PPUSH
6585: CALL_OW 74
6589: PPUSH
6590: CALL_OW 112
// end ; end_of_file
6594: LD_VAR 0 1
6598: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6599: LD_INT 0
6601: PPUSH
6602: PPUSH
6603: PPUSH
6604: PPUSH
6605: PPUSH
// side := 8 ;
6606: LD_ADDR_VAR 0 3
6610: PUSH
6611: LD_INT 8
6613: ST_TO_ADDR
// InitHc ;
6614: CALL_OW 19
// uc_side := side ;
6618: LD_ADDR_OWVAR 20
6622: PUSH
6623: LD_VAR 0 3
6627: ST_TO_ADDR
// uc_nation := 2 ;
6628: LD_ADDR_OWVAR 21
6632: PUSH
6633: LD_INT 2
6635: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6636: LD_ADDR_VAR 0 2
6640: PUSH
6641: LD_INT 22
6643: PUSH
6644: LD_VAR 0 3
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PUSH
6653: LD_INT 21
6655: PUSH
6656: LD_INT 3
6658: PUSH
6659: EMPTY
6660: LIST
6661: LIST
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: PPUSH
6667: CALL_OW 69
6671: PUSH
6672: FOR_IN
6673: IFFALSE 6689
// SetBLevel ( i , 10 ) ;
6675: LD_VAR 0 2
6679: PPUSH
6680: LD_INT 10
6682: PPUSH
6683: CALL_OW 241
6687: GO 6672
6689: POP
6690: POP
// Schulz := NewCharacter ( Schulz ) ;
6691: LD_ADDR_EXP 49
6695: PUSH
6696: LD_STRING Schulz
6698: PPUSH
6699: CALL_OW 25
6703: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6704: LD_ADDR_EXP 50
6708: PUSH
6709: LD_STRING Kozlov
6711: PPUSH
6712: LD_INT 0
6714: PPUSH
6715: LD_STRING 
6717: PPUSH
6718: CALL 50250 0 3
6722: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6723: LD_EXP 50
6727: PPUSH
6728: LD_INT 22
6730: PUSH
6731: LD_INT 8
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PUSH
6738: LD_INT 23
6740: PUSH
6741: LD_INT 3
6743: PUSH
6744: EMPTY
6745: LIST
6746: LIST
6747: PUSH
6748: LD_INT 30
6750: PUSH
6751: LD_INT 8
6753: PUSH
6754: EMPTY
6755: LIST
6756: LIST
6757: PUSH
6758: EMPTY
6759: LIST
6760: LIST
6761: LIST
6762: PPUSH
6763: CALL_OW 69
6767: PUSH
6768: LD_INT 1
6770: ARRAY
6771: PPUSH
6772: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6776: LD_EXP 50
6780: PPUSH
6781: LD_INT 3
6783: PPUSH
6784: LD_INT 10
6786: PPUSH
6787: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6791: LD_ADDR_VAR 0 5
6795: PUSH
6796: LD_INT 22
6798: PUSH
6799: LD_VAR 0 3
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 30
6810: PUSH
6811: LD_INT 32
6813: PUSH
6814: EMPTY
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 58
6820: PUSH
6821: EMPTY
6822: LIST
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: LIST
6828: PPUSH
6829: CALL_OW 69
6833: ST_TO_ADDR
// for i = 1 to 10 do
6834: LD_ADDR_VAR 0 2
6838: PUSH
6839: DOUBLE
6840: LD_INT 1
6842: DEC
6843: ST_TO_ADDR
6844: LD_INT 10
6846: PUSH
6847: FOR_TO
6848: IFFALSE 6920
// begin uc_nation := nation_nature ;
6850: LD_ADDR_OWVAR 21
6854: PUSH
6855: LD_INT 0
6857: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6858: LD_ADDR_OWVAR 28
6862: PUSH
6863: LD_INT 15
6865: ST_TO_ADDR
// hc_gallery :=  ;
6866: LD_ADDR_OWVAR 33
6870: PUSH
6871: LD_STRING 
6873: ST_TO_ADDR
// hc_name :=  ;
6874: LD_ADDR_OWVAR 26
6878: PUSH
6879: LD_STRING 
6881: ST_TO_ADDR
// un := CreateHuman ;
6882: LD_ADDR_VAR 0 4
6886: PUSH
6887: CALL_OW 44
6891: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6892: LD_VAR 0 4
6896: PPUSH
6897: LD_VAR 0 5
6901: PUSH
6902: LD_VAR 0 5
6906: PUSH
6907: LD_VAR 0 2
6911: MINUS
6912: ARRAY
6913: PPUSH
6914: CALL_OW 52
// end ;
6918: GO 6847
6920: POP
6921: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6922: LD_INT 324
6924: PPUSH
6925: LD_INT 3
6927: PPUSH
6928: LD_STRING 
6930: PPUSH
6931: LD_INT 8
6933: PUSH
6934: LD_INT 9
6936: PUSH
6937: LD_INT 10
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: LIST
6944: PUSH
6945: LD_OWVAR 67
6949: ARRAY
6950: PPUSH
6951: LD_INT 3000
6953: PUSH
6954: LD_INT 500
6956: PUSH
6957: LD_INT 150
6959: PUSH
6960: EMPTY
6961: LIST
6962: LIST
6963: LIST
6964: PPUSH
6965: LD_INT 16
6967: PUSH
6968: LD_INT 6
6970: PUSH
6971: LD_INT 6
6973: PUSH
6974: LD_INT 8
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: LIST
6981: LIST
6982: PPUSH
6983: CALL 60685 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
6987: LD_ADDR_EXP 74
6991: PUSH
6992: LD_EXP 74
6996: PPUSH
6997: LD_INT 3
6999: PPUSH
7000: LD_INT 22
7002: PUSH
7003: LD_VAR 0 3
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: PUSH
7012: LD_INT 23
7014: PUSH
7015: LD_INT 2
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: PUSH
7022: LD_INT 3
7024: PUSH
7025: LD_INT 21
7027: PUSH
7028: LD_INT 2
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: EMPTY
7036: LIST
7037: LIST
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: LIST
7043: PPUSH
7044: CALL_OW 69
7048: PUSH
7049: LD_EXP 49
7053: DIFF
7054: PPUSH
7055: CALL_OW 1
7059: ST_TO_ADDR
// end ;
7060: LD_VAR 0 1
7064: RET
// export function BuildKozlovBomb ; begin
7065: LD_INT 0
7067: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7068: LD_INT 332
7070: PPUSH
7071: CALL_OW 302
7075: NOT
7076: PUSH
7077: LD_INT 336
7079: PPUSH
7080: CALL_OW 302
7084: NOT
7085: OR
7086: IFFALSE 7090
// exit ;
7088: GO 7187
// ComChangeProfession ( Kozlov , 4 ) ;
7090: LD_EXP 50
7094: PPUSH
7095: LD_INT 4
7097: PPUSH
7098: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7102: LD_INT 336
7104: PPUSH
7105: LD_INT 25
7107: PPUSH
7108: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7112: LD_INT 35
7114: PPUSH
7115: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7119: LD_INT 25
7121: PPUSH
7122: LD_INT 8
7124: PPUSH
7125: CALL_OW 321
7129: PUSH
7130: LD_INT 2
7132: EQUAL
7133: IFFALSE 7112
// ComExitBuilding ( Kozlov ) ;
7135: LD_EXP 50
7139: PPUSH
7140: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7144: LD_EXP 50
7148: PPUSH
7149: LD_INT 332
7151: PPUSH
7152: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7156: LD_EXP 50
7160: PPUSH
7161: LD_INT 3
7163: PPUSH
7164: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7168: LD_INT 332
7170: PPUSH
7171: LD_INT 23
7173: PPUSH
7174: LD_INT 3
7176: PPUSH
7177: LD_INT 1
7179: PPUSH
7180: LD_INT 48
7182: PPUSH
7183: CALL_OW 125
// end ;
7187: LD_VAR 0 1
7191: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7192: LD_EXP 3
7196: NOT
7197: PUSH
7198: LD_INT 3
7200: PPUSH
7201: LD_INT 1
7203: PPUSH
7204: CALL 45324 0 2
7208: NOT
7209: AND
7210: IFFALSE 8050
7212: GO 7214
7214: DISABLE
7215: LD_INT 0
7217: PPUSH
7218: PPUSH
7219: PPUSH
// begin enable ;
7220: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7221: LD_INT 22
7223: PUSH
7224: LD_INT 8
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PUSH
7231: LD_INT 23
7233: PUSH
7234: LD_INT 2
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: LD_INT 30
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: LIST
7255: PPUSH
7256: CALL_OW 69
7260: NOT
7261: IFFALSE 7265
// exit ;
7263: GO 8050
// if Prob ( 40 ) then
7265: LD_INT 40
7267: PPUSH
7268: CALL_OW 13
7272: IFFALSE 7399
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7274: LD_INT 3
7276: PPUSH
7277: LD_INT 14
7279: PUSH
7280: LD_INT 1
7282: PUSH
7283: LD_INT 2
7285: PUSH
7286: LD_INT 28
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: LIST
7293: LIST
7294: PUSH
7295: LD_INT 14
7297: PUSH
7298: LD_INT 1
7300: PUSH
7301: LD_INT 2
7303: PUSH
7304: LD_INT 28
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: LIST
7311: LIST
7312: PUSH
7313: LD_INT 14
7315: PUSH
7316: LD_INT 1
7318: PUSH
7319: LD_INT 2
7321: PUSH
7322: LD_INT 28
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: LIST
7329: LIST
7330: PUSH
7331: LD_INT 14
7333: PUSH
7334: LD_INT 1
7336: PUSH
7337: LD_INT 2
7339: PUSH
7340: LD_INT 28
7342: PUSH
7343: EMPTY
7344: LIST
7345: LIST
7346: LIST
7347: LIST
7348: PUSH
7349: LD_INT 14
7351: PUSH
7352: LD_INT 1
7354: PUSH
7355: LD_INT 2
7357: PUSH
7358: LD_INT 28
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: PUSH
7367: LD_INT 14
7369: PUSH
7370: LD_INT 1
7372: PUSH
7373: LD_INT 2
7375: PUSH
7376: LD_INT 26
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: LIST
7383: LIST
7384: PUSH
7385: EMPTY
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: LIST
7391: LIST
7392: PPUSH
7393: CALL 43906 0 2
// end else
7397: GO 7590
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7399: LD_INT 3
7401: PPUSH
7402: LD_INT 14
7404: PUSH
7405: LD_INT 1
7407: PUSH
7408: LD_INT 2
7410: PUSH
7411: LD_INT 27
7413: PUSH
7414: LD_INT 26
7416: PUSH
7417: LD_INT 26
7419: PUSH
7420: EMPTY
7421: LIST
7422: LIST
7423: LIST
7424: PUSH
7425: LD_OWVAR 67
7429: ARRAY
7430: PUSH
7431: EMPTY
7432: LIST
7433: LIST
7434: LIST
7435: LIST
7436: PUSH
7437: LD_INT 14
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: LD_INT 2
7445: PUSH
7446: LD_INT 27
7448: PUSH
7449: LD_INT 26
7451: PUSH
7452: LD_INT 26
7454: PUSH
7455: EMPTY
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_OWVAR 67
7464: ARRAY
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: LIST
7471: PUSH
7472: LD_INT 14
7474: PUSH
7475: LD_INT 1
7477: PUSH
7478: LD_INT 2
7480: PUSH
7481: LD_INT 26
7483: PUSH
7484: LD_INT 26
7486: PUSH
7487: LD_INT 29
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: PUSH
7495: LD_OWVAR 67
7499: ARRAY
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 13
7509: PUSH
7510: LD_INT 1
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 26
7518: PUSH
7519: LD_INT 29
7521: PUSH
7522: LD_INT 29
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: LIST
7529: PUSH
7530: LD_OWVAR 67
7534: ARRAY
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 13
7544: PUSH
7545: LD_INT 1
7547: PUSH
7548: LD_INT 2
7550: PUSH
7551: LD_INT 29
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: LD_INT 14
7562: PUSH
7563: LD_INT 1
7565: PUSH
7566: LD_INT 2
7568: PUSH
7569: LD_INT 26
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: LIST
7576: LIST
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: LIST
7583: LIST
7584: LIST
7585: PPUSH
7586: CALL 43906 0 2
// end ; repeat wait ( 0 0$1 ) ;
7590: LD_INT 35
7592: PPUSH
7593: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7597: LD_INT 3
7599: PPUSH
7600: LD_INT 1
7602: PPUSH
7603: CALL 45324 0 2
7607: PUSH
7608: LD_INT 6
7610: GREATEREQUAL
7611: IFFALSE 7590
// wait ( 0 0$30 ) ;
7613: LD_INT 1050
7615: PPUSH
7616: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7620: LD_ADDR_VAR 0 2
7624: PUSH
7625: LD_INT 3
7627: PPUSH
7628: LD_INT 1
7630: PPUSH
7631: CALL 45324 0 2
7635: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7636: LD_ADDR_EXP 93
7640: PUSH
7641: LD_EXP 93
7645: PPUSH
7646: LD_INT 3
7648: PPUSH
7649: LD_EXP 93
7653: PUSH
7654: LD_INT 3
7656: ARRAY
7657: PUSH
7658: LD_VAR 0 2
7662: DIFF
7663: PPUSH
7664: CALL_OW 1
7668: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7669: LD_ADDR_VAR 0 3
7673: PUSH
7674: LD_INT 0
7676: PPUSH
7677: LD_INT 2
7679: PPUSH
7680: CALL_OW 12
7684: ST_TO_ADDR
// if target then
7685: LD_VAR 0 3
7689: IFFALSE 7817
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7691: LD_ADDR_VAR 0 2
7695: PUSH
7696: LD_VAR 0 2
7700: PPUSH
7701: LD_INT 24
7703: PUSH
7704: LD_INT 250
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PPUSH
7711: CALL_OW 72
7715: ST_TO_ADDR
// for i in tmp do
7716: LD_ADDR_VAR 0 1
7720: PUSH
7721: LD_VAR 0 2
7725: PUSH
7726: FOR_IN
7727: IFFALSE 7767
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7729: LD_VAR 0 1
7733: PPUSH
7734: LD_INT 89
7736: PPUSH
7737: LD_INT 71
7739: PPUSH
7740: CALL_OW 297
7744: PUSH
7745: LD_INT 9
7747: GREATER
7748: IFFALSE 7765
// ComMoveXY ( i , 89 , 71 ) ;
7750: LD_VAR 0 1
7754: PPUSH
7755: LD_INT 89
7757: PPUSH
7758: LD_INT 71
7760: PPUSH
7761: CALL_OW 111
7765: GO 7726
7767: POP
7768: POP
// wait ( 0 0$1 ) ;
7769: LD_INT 35
7771: PPUSH
7772: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 92
7783: PUSH
7784: LD_INT 89
7786: PUSH
7787: LD_INT 71
7789: PUSH
7790: LD_INT 9
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: LIST
7797: LIST
7798: PPUSH
7799: CALL_OW 72
7803: PUSH
7804: LD_VAR 0 2
7808: PUSH
7809: LD_INT 1
7811: MINUS
7812: GREATEREQUAL
7813: IFFALSE 7691
// end else
7815: GO 7941
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7817: LD_ADDR_VAR 0 2
7821: PUSH
7822: LD_VAR 0 2
7826: PPUSH
7827: LD_INT 24
7829: PUSH
7830: LD_INT 250
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PPUSH
7837: CALL_OW 72
7841: ST_TO_ADDR
// for i in tmp do
7842: LD_ADDR_VAR 0 1
7846: PUSH
7847: LD_VAR 0 2
7851: PUSH
7852: FOR_IN
7853: IFFALSE 7893
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7855: LD_VAR 0 1
7859: PPUSH
7860: LD_INT 147
7862: PPUSH
7863: LD_INT 4
7865: PPUSH
7866: CALL_OW 297
7870: PUSH
7871: LD_INT 9
7873: GREATER
7874: IFFALSE 7891
// ComMoveXY ( i , 147 , 4 ) ;
7876: LD_VAR 0 1
7880: PPUSH
7881: LD_INT 147
7883: PPUSH
7884: LD_INT 4
7886: PPUSH
7887: CALL_OW 111
7891: GO 7852
7893: POP
7894: POP
// wait ( 0 0$1 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7902: LD_VAR 0 2
7906: PPUSH
7907: LD_INT 92
7909: PUSH
7910: LD_INT 147
7912: PUSH
7913: LD_INT 4
7915: PUSH
7916: LD_INT 9
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: LIST
7923: LIST
7924: PPUSH
7925: CALL_OW 72
7929: PUSH
7930: LD_VAR 0 2
7934: PUSH
7935: LD_INT 1
7937: MINUS
7938: GREATEREQUAL
7939: IFFALSE 7817
// end ; repeat wait ( 0 0$1 ) ;
7941: LD_INT 35
7943: PPUSH
7944: CALL_OW 67
// for i in tmp do
7948: LD_ADDR_VAR 0 1
7952: PUSH
7953: LD_VAR 0 2
7957: PUSH
7958: FOR_IN
7959: IFFALSE 8041
// begin if GetLives ( i ) > 251 then
7961: LD_VAR 0 1
7965: PPUSH
7966: CALL_OW 256
7970: PUSH
7971: LD_INT 251
7973: GREATER
7974: IFFALSE 8012
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
7976: LD_VAR 0 1
7980: PPUSH
7981: LD_INT 81
7983: PUSH
7984: LD_INT 8
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: PPUSH
7991: CALL_OW 69
7995: PPUSH
7996: LD_VAR 0 1
8000: PPUSH
8001: CALL_OW 74
8005: PPUSH
8006: CALL_OW 115
8010: GO 8039
// if IsDead ( i ) then
8012: LD_VAR 0 1
8016: PPUSH
8017: CALL_OW 301
8021: IFFALSE 8039
// tmp := tmp diff i ;
8023: LD_ADDR_VAR 0 2
8027: PUSH
8028: LD_VAR 0 2
8032: PUSH
8033: LD_VAR 0 1
8037: DIFF
8038: ST_TO_ADDR
// end ;
8039: GO 7958
8041: POP
8042: POP
// until not tmp ;
8043: LD_VAR 0 2
8047: NOT
8048: IFFALSE 7941
// end ;
8050: PPOPN 3
8052: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8053: LD_EXP 50
8057: PPUSH
8058: CALL_OW 302
8062: PUSH
8063: LD_EXP 3
8067: NOT
8068: AND
8069: IFFALSE 8078
8071: GO 8073
8073: DISABLE
// BuildKozlovBomb ;
8074: CALL 7065 0 0
8078: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8079: LD_INT 22
8081: PUSH
8082: LD_INT 8
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PUSH
8089: LD_INT 34
8091: PUSH
8092: LD_INT 48
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: PPUSH
8103: CALL_OW 69
8107: IFFALSE 8155
8109: GO 8111
8111: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8112: LD_INT 22
8114: PUSH
8115: LD_INT 8
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: LD_INT 34
8124: PUSH
8125: LD_INT 48
8127: PUSH
8128: EMPTY
8129: LIST
8130: LIST
8131: PUSH
8132: EMPTY
8133: LIST
8134: LIST
8135: PPUSH
8136: CALL_OW 69
8140: PUSH
8141: LD_INT 1
8143: ARRAY
8144: PPUSH
8145: LD_INT 173
8147: PPUSH
8148: LD_INT 96
8150: PPUSH
8151: CALL_OW 116
// end ; end_of_file
8155: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8156: LD_INT 0
8158: PPUSH
8159: PPUSH
8160: PPUSH
8161: PPUSH
8162: PPUSH
8163: PPUSH
8164: PPUSH
8165: PPUSH
8166: PPUSH
// side := 3 ;
8167: LD_ADDR_VAR 0 6
8171: PUSH
8172: LD_INT 3
8174: ST_TO_ADDR
// InitHc ;
8175: CALL_OW 19
// uc_side := side ;
8179: LD_ADDR_OWVAR 20
8183: PUSH
8184: LD_VAR 0 6
8188: ST_TO_ADDR
// uc_nation := 3 ;
8189: LD_ADDR_OWVAR 21
8193: PUSH
8194: LD_INT 3
8196: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8197: LD_ADDR_VAR 0 2
8201: PUSH
8202: LD_INT 22
8204: PUSH
8205: LD_VAR 0 6
8209: PUSH
8210: EMPTY
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 21
8216: PUSH
8217: LD_INT 3
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: PUSH
8224: EMPTY
8225: LIST
8226: LIST
8227: PPUSH
8228: CALL_OW 69
8232: PUSH
8233: FOR_IN
8234: IFFALSE 8250
// SetBLevel ( i , 10 ) ;
8236: LD_VAR 0 2
8240: PPUSH
8241: LD_INT 10
8243: PPUSH
8244: CALL_OW 241
8248: GO 8233
8250: POP
8251: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8252: LD_ADDR_VAR 0 9
8256: PUSH
8257: LD_INT 22
8259: PUSH
8260: LD_VAR 0 6
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 30
8271: PUSH
8272: LD_INT 34
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: PPUSH
8283: CALL_OW 69
8287: ST_TO_ADDR
// if teleport then
8288: LD_VAR 0 9
8292: IFFALSE 8313
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8294: LD_VAR 0 9
8298: PUSH
8299: LD_INT 1
8301: ARRAY
8302: PPUSH
8303: LD_INT 123
8305: PPUSH
8306: LD_INT 122
8308: PPUSH
8309: CALL_OW 243
// hc_importance := 0 ;
8313: LD_ADDR_OWVAR 32
8317: PUSH
8318: LD_INT 0
8320: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8321: LD_ADDR_EXP 51
8325: PUSH
8326: LD_STRING Platonov
8328: PPUSH
8329: CALL_OW 25
8333: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8334: LD_ADDR_EXP 52
8338: PUSH
8339: LD_STRING Yakotich
8341: PPUSH
8342: CALL_OW 25
8346: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8347: LD_ADDR_EXP 53
8351: PUSH
8352: LD_STRING Gleb
8354: PPUSH
8355: CALL_OW 25
8359: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8360: LD_STRING 03_Cornel
8362: PPUSH
8363: CALL_OW 28
8367: IFFALSE 8415
// begin Bierezov := NewCharacter ( Mikhail ) ;
8369: LD_ADDR_EXP 54
8373: PUSH
8374: LD_STRING Mikhail
8376: PPUSH
8377: CALL_OW 25
8381: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8382: LD_EXP 54
8386: PPUSH
8387: LD_INT 197
8389: PPUSH
8390: LD_INT 111
8392: PPUSH
8393: LD_INT 9
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8403: LD_EXP 54
8407: PPUSH
8408: LD_INT 3
8410: PPUSH
8411: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8415: LD_EXP 51
8419: PPUSH
8420: LD_INT 126
8422: PPUSH
8423: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8427: LD_EXP 52
8431: PPUSH
8432: LD_INT 197
8434: PPUSH
8435: LD_INT 111
8437: PPUSH
8438: LD_INT 9
8440: PPUSH
8441: LD_INT 0
8443: PPUSH
8444: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8448: LD_EXP 53
8452: PPUSH
8453: LD_INT 197
8455: PPUSH
8456: LD_INT 111
8458: PPUSH
8459: LD_INT 9
8461: PPUSH
8462: LD_INT 0
8464: PPUSH
8465: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8469: LD_ADDR_VAR 0 5
8473: PUSH
8474: LD_INT 126
8476: PPUSH
8477: LD_INT 2
8479: PPUSH
8480: LD_STRING zhukov
8482: PPUSH
8483: LD_INT 9
8485: PUSH
8486: LD_INT 10
8488: PUSH
8489: LD_INT 10
8491: PUSH
8492: EMPTY
8493: LIST
8494: LIST
8495: LIST
8496: PUSH
8497: LD_OWVAR 67
8501: ARRAY
8502: PPUSH
8503: LD_INT 90000
8505: PUSH
8506: LD_INT 1000
8508: PUSH
8509: LD_INT 300
8511: PUSH
8512: EMPTY
8513: LIST
8514: LIST
8515: LIST
8516: PPUSH
8517: LD_INT 21
8519: PUSH
8520: LD_INT 8
8522: PUSH
8523: LD_INT 13
8525: PUSH
8526: LD_INT 8
8528: PUSH
8529: EMPTY
8530: LIST
8531: LIST
8532: LIST
8533: LIST
8534: PPUSH
8535: CALL 60685 0 6
8539: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8540: LD_ADDR_VAR 0 4
8544: PUSH
8545: LD_INT 267
8547: PPUSH
8548: CALL_OW 274
8552: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8553: LD_VAR 0 4
8557: PPUSH
8558: LD_INT 1
8560: PPUSH
8561: LD_INT 5000
8563: PPUSH
8564: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8568: LD_VAR 0 4
8572: PPUSH
8573: LD_INT 2
8575: PPUSH
8576: LD_INT 200
8578: PPUSH
8579: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8583: LD_VAR 0 4
8587: PPUSH
8588: LD_INT 3
8590: PPUSH
8591: LD_INT 200
8593: PPUSH
8594: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8598: LD_ADDR_EXP 74
8602: PUSH
8603: LD_EXP 74
8607: PPUSH
8608: LD_INT 2
8610: PPUSH
8611: LD_VAR 0 5
8615: PUSH
8616: LD_INT 22
8618: PUSH
8619: LD_VAR 0 6
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PUSH
8628: LD_INT 3
8630: PUSH
8631: LD_INT 21
8633: PUSH
8634: LD_INT 2
8636: PUSH
8637: EMPTY
8638: LIST
8639: LIST
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PPUSH
8649: CALL_OW 69
8653: UNION
8654: PUSH
8655: LD_EXP 51
8659: DIFF
8660: PPUSH
8661: CALL_OW 1
8665: ST_TO_ADDR
// behemoths := [ ] ;
8666: LD_ADDR_EXP 55
8670: PUSH
8671: EMPTY
8672: ST_TO_ADDR
// behemothBuilders := [ ] ;
8673: LD_ADDR_EXP 56
8677: PUSH
8678: EMPTY
8679: ST_TO_ADDR
// j := 3 ;
8680: LD_ADDR_VAR 0 3
8684: PUSH
8685: LD_INT 3
8687: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8688: LD_ADDR_VAR 0 2
8692: PUSH
8693: LD_INT 22
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: PUSH
8703: LD_INT 25
8705: PUSH
8706: LD_INT 3
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: PUSH
8713: EMPTY
8714: LIST
8715: LIST
8716: PPUSH
8717: CALL_OW 69
8721: PUSH
8722: FOR_IN
8723: IFFALSE 8773
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8725: LD_ADDR_EXP 56
8729: PUSH
8730: LD_EXP 56
8734: PPUSH
8735: LD_VAR 0 2
8739: PPUSH
8740: CALL 93021 0 2
8744: ST_TO_ADDR
// j := j - 1 ;
8745: LD_ADDR_VAR 0 3
8749: PUSH
8750: LD_VAR 0 3
8754: PUSH
8755: LD_INT 1
8757: MINUS
8758: ST_TO_ADDR
// if j = 0 then
8759: LD_VAR 0 3
8763: PUSH
8764: LD_INT 0
8766: EQUAL
8767: IFFALSE 8771
// break ;
8769: GO 8773
// end ;
8771: GO 8722
8773: POP
8774: POP
// end ;
8775: LD_VAR 0 1
8779: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8780: LD_INT 0
8782: PPUSH
8783: PPUSH
8784: PPUSH
8785: PPUSH
8786: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8787: LD_ADDR_VAR 0 4
8791: PUSH
8792: LD_INT 209
8794: PUSH
8795: LD_INT 149
8797: PUSH
8798: EMPTY
8799: LIST
8800: LIST
8801: PUSH
8802: LD_INT 219
8804: PUSH
8805: LD_INT 154
8807: PUSH
8808: EMPTY
8809: LIST
8810: LIST
8811: PUSH
8812: LD_INT 223
8814: PUSH
8815: LD_INT 149
8817: PUSH
8818: EMPTY
8819: LIST
8820: LIST
8821: PUSH
8822: LD_INT 232
8824: PUSH
8825: LD_INT 155
8827: PUSH
8828: EMPTY
8829: LIST
8830: LIST
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: ST_TO_ADDR
// if not behemothBuilders then
8838: LD_EXP 56
8842: NOT
8843: IFFALSE 8847
// exit ;
8845: GO 8951
// j := 1 ;
8847: LD_ADDR_VAR 0 3
8851: PUSH
8852: LD_INT 1
8854: ST_TO_ADDR
// for i in behemothBuilders do
8855: LD_ADDR_VAR 0 2
8859: PUSH
8860: LD_EXP 56
8864: PUSH
8865: FOR_IN
8866: IFFALSE 8949
// begin if IsInUnit ( i ) then
8868: LD_VAR 0 2
8872: PPUSH
8873: CALL_OW 310
8877: IFFALSE 8888
// ComExitBuilding ( i ) ;
8879: LD_VAR 0 2
8883: PPUSH
8884: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8888: LD_VAR 0 2
8892: PPUSH
8893: LD_INT 37
8895: PPUSH
8896: LD_VAR 0 4
8900: PUSH
8901: LD_VAR 0 3
8905: ARRAY
8906: PUSH
8907: LD_INT 1
8909: ARRAY
8910: PPUSH
8911: LD_VAR 0 4
8915: PUSH
8916: LD_VAR 0 3
8920: ARRAY
8921: PUSH
8922: LD_INT 2
8924: ARRAY
8925: PPUSH
8926: LD_INT 0
8928: PPUSH
8929: CALL_OW 230
// j := j + 1 ;
8933: LD_ADDR_VAR 0 3
8937: PUSH
8938: LD_VAR 0 3
8942: PUSH
8943: LD_INT 1
8945: PLUS
8946: ST_TO_ADDR
// end ;
8947: GO 8865
8949: POP
8950: POP
// end ;
8951: LD_VAR 0 1
8955: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8956: LD_INT 3
8958: PPUSH
8959: CALL 93069 0 1
8963: PUSH
8964: LD_INT 22
8966: PUSH
8967: LD_INT 3
8969: PUSH
8970: EMPTY
8971: LIST
8972: LIST
8973: PUSH
8974: LD_INT 30
8976: PUSH
8977: LD_INT 37
8979: PUSH
8980: EMPTY
8981: LIST
8982: LIST
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: PPUSH
8988: CALL_OW 69
8992: NOT
8993: AND
8994: IFFALSE 9180
8996: GO 8998
8998: DISABLE
8999: LD_INT 0
9001: PPUSH
9002: PPUSH
// begin enable ;
9003: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9004: LD_ADDR_VAR 0 2
9008: PUSH
9009: LD_INT 3
9011: PPUSH
9012: CALL 93069 0 1
9016: ST_TO_ADDR
// for i in tmp do
9017: LD_ADDR_VAR 0 1
9021: PUSH
9022: LD_VAR 0 2
9026: PUSH
9027: FOR_IN
9028: IFFALSE 9178
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9030: LD_VAR 0 1
9034: PPUSH
9035: LD_INT 7
9037: PPUSH
9038: CALL_OW 308
9042: PUSH
9043: LD_VAR 0 1
9047: PPUSH
9048: CALL_OW 110
9052: PUSH
9053: LD_INT 2
9055: EQUAL
9056: NOT
9057: AND
9058: IFFALSE 9072
// SetTag ( i , 2 ) ;
9060: LD_VAR 0 1
9064: PPUSH
9065: LD_INT 2
9067: PPUSH
9068: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9072: LD_INT 81
9074: PUSH
9075: LD_INT 3
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PUSH
9082: LD_INT 91
9084: PUSH
9085: LD_VAR 0 1
9089: PUSH
9090: LD_INT 12
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: LIST
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PPUSH
9102: CALL_OW 69
9106: NOT
9107: PUSH
9108: LD_VAR 0 1
9112: PPUSH
9113: CALL_OW 110
9117: PUSH
9118: LD_INT 2
9120: EQUAL
9121: NOT
9122: AND
9123: IFFALSE 9142
// ComAgressiveMove ( i , 64 , 93 ) else
9125: LD_VAR 0 1
9129: PPUSH
9130: LD_INT 64
9132: PPUSH
9133: LD_INT 93
9135: PPUSH
9136: CALL_OW 114
9140: GO 9176
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9142: LD_VAR 0 1
9146: PPUSH
9147: LD_INT 81
9149: PUSH
9150: LD_INT 3
9152: PUSH
9153: EMPTY
9154: LIST
9155: LIST
9156: PPUSH
9157: CALL_OW 69
9161: PPUSH
9162: LD_VAR 0 1
9166: PPUSH
9167: CALL_OW 74
9171: PPUSH
9172: CALL_OW 115
// end ;
9176: GO 9027
9178: POP
9179: POP
// end ;
9180: PPOPN 2
9182: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9183: LD_EXP 2
9187: NOT
9188: PUSH
9189: LD_INT 2
9191: PPUSH
9192: LD_INT 1
9194: PPUSH
9195: CALL 45324 0 2
9199: NOT
9200: AND
9201: IFFALSE 10121
9203: GO 9205
9205: DISABLE
9206: LD_INT 0
9208: PPUSH
9209: PPUSH
9210: PPUSH
9211: PPUSH
// begin enable ;
9212: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9213: LD_INT 22
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PUSH
9223: LD_INT 30
9225: PUSH
9226: LD_INT 3
9228: PUSH
9229: EMPTY
9230: LIST
9231: LIST
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: PPUSH
9237: CALL_OW 69
9241: NOT
9242: IFFALSE 9246
// exit ;
9244: GO 10121
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9246: LD_ADDR_VAR 0 4
9250: PUSH
9251: LD_INT 22
9253: PUSH
9254: LD_INT 3
9256: PUSH
9257: EMPTY
9258: LIST
9259: LIST
9260: PUSH
9261: LD_INT 30
9263: PUSH
9264: LD_INT 34
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: PUSH
9271: EMPTY
9272: LIST
9273: LIST
9274: PPUSH
9275: CALL_OW 69
9279: ST_TO_ADDR
// if Prob ( 40 ) then
9280: LD_INT 40
9282: PPUSH
9283: CALL_OW 13
9287: IFFALSE 9414
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9289: LD_INT 2
9291: PPUSH
9292: LD_INT 22
9294: PUSH
9295: LD_INT 3
9297: PUSH
9298: LD_INT 3
9300: PUSH
9301: LD_INT 49
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: LIST
9308: LIST
9309: PUSH
9310: LD_INT 22
9312: PUSH
9313: LD_INT 3
9315: PUSH
9316: LD_INT 3
9318: PUSH
9319: LD_INT 49
9321: PUSH
9322: EMPTY
9323: LIST
9324: LIST
9325: LIST
9326: LIST
9327: PUSH
9328: LD_INT 22
9330: PUSH
9331: LD_INT 3
9333: PUSH
9334: LD_INT 3
9336: PUSH
9337: LD_INT 49
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: PUSH
9346: LD_INT 24
9348: PUSH
9349: LD_INT 3
9351: PUSH
9352: LD_INT 3
9354: PUSH
9355: LD_INT 46
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_INT 24
9366: PUSH
9367: LD_INT 3
9369: PUSH
9370: LD_INT 3
9372: PUSH
9373: LD_INT 46
9375: PUSH
9376: EMPTY
9377: LIST
9378: LIST
9379: LIST
9380: LIST
9381: PUSH
9382: LD_INT 24
9384: PUSH
9385: LD_INT 3
9387: PUSH
9388: LD_INT 3
9390: PUSH
9391: LD_INT 46
9393: PUSH
9394: EMPTY
9395: LIST
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: LIST
9406: LIST
9407: PPUSH
9408: CALL 43906 0 2
// end else
9412: GO 9537
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9414: LD_INT 2
9416: PPUSH
9417: LD_INT 24
9419: PUSH
9420: LD_INT 3
9422: PUSH
9423: LD_INT 3
9425: PUSH
9426: LD_INT 47
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: LIST
9433: LIST
9434: PUSH
9435: LD_INT 24
9437: PUSH
9438: LD_INT 3
9440: PUSH
9441: LD_INT 3
9443: PUSH
9444: LD_INT 47
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: PUSH
9453: LD_INT 24
9455: PUSH
9456: LD_INT 3
9458: PUSH
9459: LD_INT 3
9461: PUSH
9462: LD_INT 47
9464: PUSH
9465: EMPTY
9466: LIST
9467: LIST
9468: LIST
9469: LIST
9470: PUSH
9471: LD_INT 24
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: LD_INT 3
9479: PUSH
9480: LD_INT 46
9482: PUSH
9483: EMPTY
9484: LIST
9485: LIST
9486: LIST
9487: LIST
9488: PUSH
9489: LD_INT 24
9491: PUSH
9492: LD_INT 3
9494: PUSH
9495: LD_INT 3
9497: PUSH
9498: LD_INT 46
9500: PUSH
9501: EMPTY
9502: LIST
9503: LIST
9504: LIST
9505: LIST
9506: PUSH
9507: LD_INT 24
9509: PUSH
9510: LD_INT 3
9512: PUSH
9513: LD_INT 3
9515: PUSH
9516: LD_INT 46
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: LIST
9523: LIST
9524: PUSH
9525: EMPTY
9526: LIST
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: CALL 43906 0 2
// end ; if Difficulty > 1 then
9537: LD_OWVAR 67
9541: PUSH
9542: LD_INT 1
9544: GREATER
9545: IFFALSE 9575
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9547: LD_INT 2
9549: PPUSH
9550: LD_INT 24
9552: PUSH
9553: LD_INT 3
9555: PUSH
9556: LD_INT 3
9558: PUSH
9559: LD_INT 47
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: EMPTY
9569: LIST
9570: PPUSH
9571: CALL 43906 0 2
// repeat wait ( 0 0$1 ) ;
9575: LD_INT 35
9577: PPUSH
9578: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9582: LD_INT 2
9584: PPUSH
9585: LD_INT 1
9587: PPUSH
9588: CALL 45324 0 2
9592: PUSH
9593: LD_INT 6
9595: PUSH
9596: LD_INT 7
9598: PUSH
9599: LD_INT 7
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: LD_OWVAR 67
9611: ARRAY
9612: GREATEREQUAL
9613: IFFALSE 9575
// wait ( 0 0$30 ) ;
9615: LD_INT 1050
9617: PPUSH
9618: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9622: LD_ADDR_VAR 0 2
9626: PUSH
9627: LD_INT 2
9629: PPUSH
9630: LD_INT 1
9632: PPUSH
9633: CALL 45324 0 2
9637: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9638: LD_ADDR_EXP 93
9642: PUSH
9643: LD_EXP 93
9647: PPUSH
9648: LD_INT 2
9650: PPUSH
9651: LD_EXP 93
9655: PUSH
9656: LD_INT 2
9658: ARRAY
9659: PUSH
9660: LD_VAR 0 2
9664: DIFF
9665: PPUSH
9666: CALL_OW 1
9670: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9671: LD_ADDR_VAR 0 3
9675: PUSH
9676: LD_INT 0
9678: PPUSH
9679: LD_INT 1
9681: PPUSH
9682: CALL_OW 12
9686: ST_TO_ADDR
// if target then
9687: LD_VAR 0 3
9691: IFFALSE 9819
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9693: LD_ADDR_VAR 0 2
9697: PUSH
9698: LD_VAR 0 2
9702: PPUSH
9703: LD_INT 24
9705: PUSH
9706: LD_INT 250
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: PPUSH
9713: CALL_OW 72
9717: ST_TO_ADDR
// for i in tmp do
9718: LD_ADDR_VAR 0 1
9722: PUSH
9723: LD_VAR 0 2
9727: PUSH
9728: FOR_IN
9729: IFFALSE 9769
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9731: LD_VAR 0 1
9735: PPUSH
9736: LD_INT 139
9738: PPUSH
9739: LD_INT 89
9741: PPUSH
9742: CALL_OW 297
9746: PUSH
9747: LD_INT 9
9749: GREATER
9750: IFFALSE 9767
// ComMoveXY ( i , 139 , 89 ) ;
9752: LD_VAR 0 1
9756: PPUSH
9757: LD_INT 139
9759: PPUSH
9760: LD_INT 89
9762: PPUSH
9763: CALL_OW 111
9767: GO 9728
9769: POP
9770: POP
// wait ( 0 0$1 ) ;
9771: LD_INT 35
9773: PPUSH
9774: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9778: LD_VAR 0 2
9782: PPUSH
9783: LD_INT 92
9785: PUSH
9786: LD_INT 139
9788: PUSH
9789: LD_INT 89
9791: PUSH
9792: LD_INT 9
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: PPUSH
9801: CALL_OW 72
9805: PUSH
9806: LD_VAR 0 2
9810: PUSH
9811: LD_INT 1
9813: MINUS
9814: GREATEREQUAL
9815: IFFALSE 9693
// end else
9817: GO 9961
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9819: LD_VAR 0 2
9823: PPUSH
9824: LD_VAR 0 4
9828: PUSH
9829: LD_INT 1
9831: ARRAY
9832: PPUSH
9833: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9837: LD_ADDR_VAR 0 2
9841: PUSH
9842: LD_VAR 0 2
9846: PPUSH
9847: LD_INT 24
9849: PUSH
9850: LD_INT 250
9852: PUSH
9853: EMPTY
9854: LIST
9855: LIST
9856: PPUSH
9857: CALL_OW 72
9861: ST_TO_ADDR
// for i in tmp do
9862: LD_ADDR_VAR 0 1
9866: PUSH
9867: LD_VAR 0 2
9871: PUSH
9872: FOR_IN
9873: IFFALSE 9913
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9875: LD_VAR 0 1
9879: PPUSH
9880: LD_INT 124
9882: PPUSH
9883: LD_INT 139
9885: PPUSH
9886: CALL_OW 297
9890: PUSH
9891: LD_INT 9
9893: GREATER
9894: IFFALSE 9911
// ComMoveXY ( i , 124 , 139 ) ;
9896: LD_VAR 0 1
9900: PPUSH
9901: LD_INT 124
9903: PPUSH
9904: LD_INT 139
9906: PPUSH
9907: CALL_OW 111
9911: GO 9872
9913: POP
9914: POP
// wait ( 0 0$1 ) ;
9915: LD_INT 35
9917: PPUSH
9918: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9922: LD_VAR 0 2
9926: PPUSH
9927: LD_INT 92
9929: PUSH
9930: LD_INT 124
9932: PUSH
9933: LD_INT 139
9935: PUSH
9936: LD_INT 9
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: LIST
9943: LIST
9944: PPUSH
9945: CALL_OW 72
9949: PUSH
9950: LD_VAR 0 2
9954: PUSH
9955: LD_INT 1
9957: MINUS
9958: GREATEREQUAL
9959: IFFALSE 9837
// end ; repeat wait ( 0 0$1 ) ;
9961: LD_INT 35
9963: PPUSH
9964: CALL_OW 67
// for i in tmp do
9968: LD_ADDR_VAR 0 1
9972: PUSH
9973: LD_VAR 0 2
9977: PUSH
9978: FOR_IN
9979: IFFALSE 10112
// begin if GetLives ( i ) > 251 then
9981: LD_VAR 0 1
9985: PPUSH
9986: CALL_OW 256
9990: PUSH
9991: LD_INT 251
9993: GREATER
9994: IFFALSE 10083
// begin if GetWeapon ( i ) = ru_time_lapser then
9996: LD_VAR 0 1
10000: PPUSH
10001: CALL_OW 264
10005: PUSH
10006: LD_INT 49
10008: EQUAL
10009: IFFALSE 10047
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10011: LD_VAR 0 1
10015: PPUSH
10016: LD_INT 81
10018: PUSH
10019: LD_INT 3
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: PPUSH
10026: CALL_OW 69
10030: PPUSH
10031: LD_VAR 0 1
10035: PPUSH
10036: CALL_OW 74
10040: PPUSH
10041: CALL_OW 112
10045: GO 10081
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10047: LD_VAR 0 1
10051: PPUSH
10052: LD_INT 81
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: PPUSH
10062: CALL_OW 69
10066: PPUSH
10067: LD_VAR 0 1
10071: PPUSH
10072: CALL_OW 74
10076: PPUSH
10077: CALL_OW 115
// end else
10081: GO 10110
// if IsDead ( i ) then
10083: LD_VAR 0 1
10087: PPUSH
10088: CALL_OW 301
10092: IFFALSE 10110
// tmp := tmp diff i ;
10094: LD_ADDR_VAR 0 2
10098: PUSH
10099: LD_VAR 0 2
10103: PUSH
10104: LD_VAR 0 1
10108: DIFF
10109: ST_TO_ADDR
// end ;
10110: GO 9978
10112: POP
10113: POP
// until not tmp ;
10114: LD_VAR 0 2
10118: NOT
10119: IFFALSE 9961
// end ;
10121: PPOPN 4
10123: END
// every 30 30$00 trigger not russianDestroyed do
10124: LD_EXP 2
10128: NOT
10129: IFFALSE 10194
10131: GO 10133
10133: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10134: LD_INT 105000
10136: PUSH
10137: LD_INT 84000
10139: PUSH
10140: LD_INT 63000
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: PUSH
10148: LD_OWVAR 67
10152: ARRAY
10153: PPUSH
10154: CALL_OW 67
// if russianDestroyed then
10158: LD_EXP 2
10162: IFFALSE 10166
// exit ;
10164: GO 10194
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10166: LD_INT 2
10168: PPUSH
10169: LD_INT 23
10171: PUSH
10172: LD_INT 3
10174: PUSH
10175: LD_INT 1
10177: PUSH
10178: LD_INT 48
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: LIST
10186: PUSH
10187: EMPTY
10188: LIST
10189: PPUSH
10190: CALL 43906 0 2
// end ; end_of_file
10194: END
// export function CustomEvent ( event ) ; begin
10195: LD_INT 0
10197: PPUSH
// end ;
10198: LD_VAR 0 2
10202: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10203: LD_VAR 0 2
10207: PPUSH
10208: LD_VAR 0 3
10212: PPUSH
10213: LD_INT 15
10215: PPUSH
10216: CALL_OW 309
10220: IFFALSE 10229
// YouLost ( MothContaminate ) ;
10222: LD_STRING MothContaminate
10224: PPUSH
10225: CALL_OW 104
// end ;
10229: PPOPN 3
10231: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10232: LD_VAR 0 2
10236: PPUSH
10237: LD_VAR 0 3
10241: PPUSH
10242: LD_INT 15
10244: PPUSH
10245: CALL_OW 309
10249: IFFALSE 10265
// begin wait ( 0 0$6 ) ;
10251: LD_INT 210
10253: PPUSH
10254: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10258: LD_STRING MothContaminateBomb
10260: PPUSH
10261: CALL_OW 104
// end ; end ;
10265: PPOPN 3
10267: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10268: LD_VAR 0 1
10272: PUSH
10273: LD_EXP 12
10277: EQUAL
10278: IFFALSE 10289
// begin YouLost ( JMM ) ;
10280: LD_STRING JMM
10282: PPUSH
10283: CALL_OW 104
// exit ;
10287: GO 10338
// end ; if un = Powell then
10289: LD_VAR 0 1
10293: PUSH
10294: LD_EXP 47
10298: EQUAL
10299: IFFALSE 10309
// americanDestroyed := true ;
10301: LD_ADDR_EXP 4
10305: PUSH
10306: LD_INT 1
10308: ST_TO_ADDR
// if un = Platonov then
10309: LD_VAR 0 1
10313: PUSH
10314: LD_EXP 51
10318: EQUAL
10319: IFFALSE 10329
// russianDestroyed := true ;
10321: LD_ADDR_EXP 2
10325: PUSH
10326: LD_INT 1
10328: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10329: LD_VAR 0 1
10333: PPUSH
10334: CALL 47298 0 1
// end ;
10338: PPOPN 1
10340: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10341: LD_VAR 0 1
10345: PPUSH
10346: LD_VAR 0 2
10350: PPUSH
10351: CALL 49632 0 2
// end ;
10355: PPOPN 2
10357: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10358: LD_VAR 0 1
10362: PPUSH
10363: CALL 48700 0 1
// end ;
10367: PPOPN 1
10369: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10370: LD_VAR 0 1
10374: PUSH
10375: LD_INT 22
10377: PUSH
10378: LD_INT 8
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: PUSH
10385: LD_INT 30
10387: PUSH
10388: LD_INT 2
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 23
10397: PUSH
10398: LD_INT 3
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: LIST
10409: PPUSH
10410: CALL_OW 69
10414: IN
10415: IFFALSE 10442
// begin ComUpgrade ( building ) ;
10417: LD_VAR 0 1
10421: PPUSH
10422: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10426: LD_EXP 50
10430: PPUSH
10431: LD_VAR 0 1
10435: PPUSH
10436: CALL 60249 0 2
// exit ;
10440: GO 10451
// end ; MCE_BuildingComplete ( building ) ;
10442: LD_VAR 0 1
10446: PPUSH
10447: CALL 48941 0 1
// end ;
10451: PPOPN 1
10453: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10454: LD_VAR 0 1
10458: PPUSH
10459: LD_VAR 0 2
10463: PPUSH
10464: CALL 46994 0 2
// end ;
10468: PPOPN 2
10470: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10471: LD_VAR 0 1
10475: PPUSH
10476: LD_VAR 0 2
10480: PPUSH
10481: LD_VAR 0 3
10485: PPUSH
10486: LD_VAR 0 4
10490: PPUSH
10491: LD_VAR 0 5
10495: PPUSH
10496: CALL 46614 0 5
// end ;
10500: PPOPN 5
10502: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10503: LD_VAR 0 1
10507: PPUSH
10508: LD_VAR 0 2
10512: PPUSH
10513: CALL 46210 0 2
// end ;
10517: PPOPN 2
10519: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10520: LD_VAR 0 1
10524: PPUSH
10525: LD_VAR 0 2
10529: PPUSH
10530: LD_VAR 0 3
10534: PPUSH
10535: LD_VAR 0 4
10539: PPUSH
10540: CALL 46048 0 4
// end ;
10544: PPOPN 4
10546: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10547: LD_VAR 0 1
10551: PPUSH
10552: LD_VAR 0 2
10556: PPUSH
10557: LD_VAR 0 3
10561: PPUSH
10562: CALL 45823 0 3
// end ;
10566: PPOPN 3
10568: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10569: LD_VAR 0 1
10573: PPUSH
10574: LD_VAR 0 2
10578: PPUSH
10579: CALL 45708 0 2
// end ;
10583: PPOPN 2
10585: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10586: LD_VAR 0 1
10590: PPUSH
10591: LD_VAR 0 2
10595: PPUSH
10596: CALL 49893 0 2
// end ;
10600: PPOPN 2
10602: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_VAR 0 2
10612: PPUSH
10613: LD_VAR 0 3
10617: PPUSH
10618: LD_VAR 0 4
10622: PPUSH
10623: CALL 50109 0 4
// end ;
10627: PPOPN 4
10629: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10630: LD_VAR 0 1
10634: PPUSH
10635: LD_VAR 0 2
10639: PPUSH
10640: CALL 45517 0 2
// end ;
10644: PPOPN 2
10646: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10647: LD_VAR 0 1
10651: PPUSH
10652: CALL 93421 0 1
// end ; end_of_file
10656: PPOPN 1
10658: END
// export function Action ; begin
10659: LD_INT 0
10661: PPUSH
// InGameOn ;
10662: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10666: LD_INT 206
10668: PPUSH
10669: LD_INT 11
10671: PPUSH
10672: CALL_OW 86
// wait ( 0 0$1 ) ;
10676: LD_INT 35
10678: PPUSH
10679: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10683: LD_EXP 12
10687: PPUSH
10688: LD_STRING DStart-JMM-JMM-1
10690: PPUSH
10691: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10695: LD_EXP 44
10699: PPUSH
10700: LD_STRING DStart-JMM-Bur-1
10702: PPUSH
10703: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10707: LD_EXP 12
10711: PPUSH
10712: LD_STRING DStart-JMM-JMM-2
10714: PPUSH
10715: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10719: LD_EXP 44
10723: PPUSH
10724: LD_STRING DStart-JMM-Bur-2
10726: PPUSH
10727: CALL_OW 88
// InGameOff ;
10731: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10735: LD_STRING MStart
10737: PPUSH
10738: CALL_OW 337
// end ;
10742: LD_VAR 0 1
10746: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10747: LD_INT 7
10749: PPUSH
10750: LD_INT 255
10752: PPUSH
10753: LD_INT 219
10755: PPUSH
10756: CALL_OW 293
10760: IFFALSE 11369
10762: GO 10764
10764: DISABLE
10765: LD_INT 0
10767: PPUSH
// begin wait ( 0 0$3 ) ;
10768: LD_INT 105
10770: PPUSH
10771: CALL_OW 67
// alienSpotted := true ;
10775: LD_ADDR_EXP 7
10779: PUSH
10780: LD_INT 1
10782: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10783: LD_ADDR_VAR 0 1
10787: PUSH
10788: LD_INT 22
10790: PUSH
10791: LD_INT 7
10793: PUSH
10794: EMPTY
10795: LIST
10796: LIST
10797: PUSH
10798: LD_INT 23
10800: PUSH
10801: LD_INT 3
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: PUSH
10808: LD_INT 21
10810: PUSH
10811: LD_INT 1
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: PUSH
10818: LD_INT 26
10820: PUSH
10821: LD_INT 1
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PUSH
10828: EMPTY
10829: LIST
10830: LIST
10831: LIST
10832: LIST
10833: PPUSH
10834: CALL_OW 69
10838: PUSH
10839: LD_EXP 44
10843: PUSH
10844: LD_EXP 32
10848: PUSH
10849: LD_EXP 34
10853: PUSH
10854: LD_EXP 35
10858: PUSH
10859: LD_EXP 42
10863: PUSH
10864: LD_EXP 41
10868: PUSH
10869: LD_EXP 36
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: LIST
10882: DIFF
10883: ST_TO_ADDR
// DialogueOn ;
10884: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
10888: LD_INT 255
10890: PPUSH
10891: LD_INT 219
10893: PPUSH
10894: LD_INT 7
10896: PPUSH
10897: LD_INT 20
10899: NEG
10900: PPUSH
10901: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
10905: LD_INT 255
10907: PPUSH
10908: LD_INT 219
10910: PPUSH
10911: CALL_OW 86
// if speaker then
10915: LD_VAR 0 1
10919: IFFALSE 10937
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
10921: LD_VAR 0 1
10925: PUSH
10926: LD_INT 1
10928: ARRAY
10929: PPUSH
10930: LD_STRING DAlienBase-RSol1-1
10932: PPUSH
10933: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
10937: LD_EXP 12
10941: PPUSH
10942: LD_STRING DAlienBase-JMM-1
10944: PPUSH
10945: CALL_OW 88
// if IsOk ( Burlak ) then
10949: LD_EXP 44
10953: PPUSH
10954: CALL_OW 302
10958: IFFALSE 10979
// begin dwait ( 0 0$1 ) ;
10960: LD_INT 35
10962: PPUSH
10963: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
10967: LD_EXP 44
10971: PPUSH
10972: LD_STRING DAlienBase-Bur-1
10974: PPUSH
10975: CALL_OW 88
// end ; if IsOk ( Roth ) then
10979: LD_EXP 13
10983: PPUSH
10984: CALL_OW 302
10988: IFFALSE 11002
// Say ( Roth , DAlienBase-Roth-1 ) ;
10990: LD_EXP 13
10994: PPUSH
10995: LD_STRING DAlienBase-Roth-1
10997: PPUSH
10998: CALL_OW 88
// if IsOk ( Gossudarov ) then
11002: LD_EXP 30
11006: PPUSH
11007: CALL_OW 302
11011: IFFALSE 11027
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11013: LD_EXP 30
11017: PPUSH
11018: LD_STRING DAlienBase-Gos-1
11020: PPUSH
11021: CALL_OW 88
11025: GO 11144
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11027: LD_ADDR_VAR 0 1
11031: PUSH
11032: LD_INT 22
11034: PUSH
11035: LD_INT 7
11037: PUSH
11038: EMPTY
11039: LIST
11040: LIST
11041: PUSH
11042: LD_INT 25
11044: PUSH
11045: LD_INT 4
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: PUSH
11052: LD_INT 21
11054: PUSH
11055: LD_INT 1
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PUSH
11062: LD_INT 26
11064: PUSH
11065: LD_INT 1
11067: PUSH
11068: EMPTY
11069: LIST
11070: LIST
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: LIST
11076: LIST
11077: PPUSH
11078: CALL_OW 69
11082: PUSH
11083: LD_EXP 13
11087: PUSH
11088: LD_EXP 12
11092: PUSH
11093: LD_EXP 44
11097: PUSH
11098: LD_EXP 32
11102: PUSH
11103: LD_EXP 42
11107: PUSH
11108: LD_EXP 41
11112: PUSH
11113: EMPTY
11114: LIST
11115: LIST
11116: LIST
11117: LIST
11118: LIST
11119: LIST
11120: DIFF
11121: ST_TO_ADDR
// if speaker then
11122: LD_VAR 0 1
11126: IFFALSE 11144
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11128: LD_VAR 0 1
11132: PUSH
11133: LD_INT 1
11135: ARRAY
11136: PPUSH
11137: LD_STRING DAlienBase-Sci1-1
11139: PPUSH
11140: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11144: LD_INT 255
11146: PPUSH
11147: LD_INT 219
11149: PPUSH
11150: LD_INT 7
11152: PPUSH
11153: CALL_OW 331
// DialogueOff ;
11157: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11161: LD_INT 35
11163: PPUSH
11164: CALL_OW 67
// until IsSelected ( alien ) ;
11168: LD_INT 1
11170: PPUSH
11171: CALL_OW 306
11175: IFFALSE 11161
// if not artifactIResearched or not artifactIIResearched then
11177: LD_EXP 9
11181: NOT
11182: PUSH
11183: LD_EXP 10
11187: NOT
11188: OR
11189: IFFALSE 11369
// begin if IsOk ( Roth ) then
11191: LD_EXP 13
11195: PPUSH
11196: CALL_OW 302
11200: IFFALSE 11216
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11202: LD_EXP 13
11206: PPUSH
11207: LD_STRING DAlieBaseNotReady-Roth-1
11209: PPUSH
11210: CALL_OW 88
11214: GO 11369
// if IsOk ( Gossudarov ) then
11216: LD_EXP 30
11220: PPUSH
11221: CALL_OW 302
11225: IFFALSE 11241
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11227: LD_EXP 30
11231: PPUSH
11232: LD_STRING DAlieBaseNotReady-Gos-1
11234: PPUSH
11235: CALL_OW 88
11239: GO 11369
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11241: LD_ADDR_VAR 0 1
11245: PUSH
11246: LD_INT 22
11248: PUSH
11249: LD_INT 7
11251: PUSH
11252: EMPTY
11253: LIST
11254: LIST
11255: PUSH
11256: LD_INT 23
11258: PUSH
11259: LD_INT 3
11261: PUSH
11262: EMPTY
11263: LIST
11264: LIST
11265: PUSH
11266: LD_INT 25
11268: PUSH
11269: LD_INT 4
11271: PUSH
11272: EMPTY
11273: LIST
11274: LIST
11275: PUSH
11276: LD_INT 21
11278: PUSH
11279: LD_INT 1
11281: PUSH
11282: EMPTY
11283: LIST
11284: LIST
11285: PUSH
11286: LD_INT 26
11288: PUSH
11289: LD_INT 1
11291: PUSH
11292: EMPTY
11293: LIST
11294: LIST
11295: PUSH
11296: EMPTY
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: PPUSH
11303: CALL_OW 69
11307: PUSH
11308: LD_EXP 13
11312: PUSH
11313: LD_EXP 12
11317: PUSH
11318: LD_EXP 44
11322: PUSH
11323: LD_EXP 32
11327: PUSH
11328: LD_EXP 42
11332: PUSH
11333: LD_EXP 41
11337: PUSH
11338: EMPTY
11339: LIST
11340: LIST
11341: LIST
11342: LIST
11343: LIST
11344: LIST
11345: DIFF
11346: ST_TO_ADDR
// if speaker then
11347: LD_VAR 0 1
11351: IFFALSE 11369
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11353: LD_VAR 0 1
11357: PUSH
11358: LD_INT 1
11360: ARRAY
11361: PPUSH
11362: LD_STRING DAlieBaseNotReady-RSci1-1
11364: PPUSH
11365: CALL_OW 88
// end ; end ; end ;
11369: PPOPN 1
11371: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11372: LD_INT 24
11374: PPUSH
11375: LD_INT 7
11377: PPUSH
11378: CALL_OW 321
11382: PUSH
11383: LD_INT 2
11385: EQUAL
11386: IFFALSE 12077
11388: GO 11390
11390: DISABLE
11391: LD_INT 0
11393: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11394: LD_ADDR_VAR 0 1
11398: PUSH
11399: LD_INT 22
11401: PUSH
11402: LD_INT 7
11404: PUSH
11405: EMPTY
11406: LIST
11407: LIST
11408: PUSH
11409: LD_INT 23
11411: PUSH
11412: LD_INT 3
11414: PUSH
11415: EMPTY
11416: LIST
11417: LIST
11418: PUSH
11419: LD_INT 25
11421: PUSH
11422: LD_INT 4
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: PUSH
11429: LD_INT 21
11431: PUSH
11432: LD_INT 1
11434: PUSH
11435: EMPTY
11436: LIST
11437: LIST
11438: PUSH
11439: LD_INT 26
11441: PUSH
11442: LD_INT 1
11444: PUSH
11445: EMPTY
11446: LIST
11447: LIST
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: LIST
11455: PPUSH
11456: CALL_OW 69
11460: PUSH
11461: LD_EXP 13
11465: PUSH
11466: LD_EXP 12
11470: PUSH
11471: LD_EXP 44
11475: PUSH
11476: LD_EXP 32
11480: PUSH
11481: LD_EXP 42
11485: PUSH
11486: LD_EXP 41
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: DIFF
11499: ST_TO_ADDR
// if not speaker then
11500: LD_VAR 0 1
11504: NOT
11505: IFFALSE 11509
// exit ;
11507: GO 12077
// DialogueOn ;
11509: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11513: LD_VAR 0 1
11517: PUSH
11518: LD_INT 1
11520: ARRAY
11521: PPUSH
11522: LD_STRING DArtefTechnology-RSci1-1
11524: PPUSH
11525: CALL_OW 88
// if IsOk ( Burlak ) then
11529: LD_EXP 44
11533: PPUSH
11534: CALL_OW 302
11538: IFFALSE 11552
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11540: LD_EXP 44
11544: PPUSH
11545: LD_STRING DArtefTechnology-Bur-1
11547: PPUSH
11548: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11552: LD_VAR 0 1
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PPUSH
11561: LD_STRING DArtefTechnology-RSci1-2
11563: PPUSH
11564: CALL_OW 88
// if Denis then
11568: LD_EXP 18
11572: IFFALSE 11589
// speaker := [ Denis ] else
11574: LD_ADDR_VAR 0 1
11578: PUSH
11579: LD_EXP 18
11583: PUSH
11584: EMPTY
11585: LIST
11586: ST_TO_ADDR
11587: GO 11695
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11589: LD_ADDR_VAR 0 1
11593: PUSH
11594: LD_INT 22
11596: PUSH
11597: LD_INT 7
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: PUSH
11604: LD_INT 23
11606: PUSH
11607: LD_INT 1
11609: PUSH
11610: EMPTY
11611: LIST
11612: LIST
11613: PUSH
11614: LD_INT 25
11616: PUSH
11617: LD_INT 4
11619: PUSH
11620: EMPTY
11621: LIST
11622: LIST
11623: PUSH
11624: LD_INT 21
11626: PUSH
11627: LD_INT 1
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: PUSH
11634: LD_INT 26
11636: PUSH
11637: LD_INT 1
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PUSH
11644: EMPTY
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: PPUSH
11651: CALL_OW 69
11655: PUSH
11656: LD_EXP 13
11660: PUSH
11661: LD_EXP 12
11665: PUSH
11666: LD_EXP 44
11670: PUSH
11671: LD_EXP 32
11675: PUSH
11676: LD_EXP 42
11680: PUSH
11681: LD_EXP 41
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: LIST
11692: LIST
11693: DIFF
11694: ST_TO_ADDR
// if speaker then
11695: LD_VAR 0 1
11699: IFFALSE 11717
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11701: LD_VAR 0 1
11705: PUSH
11706: LD_INT 1
11708: ARRAY
11709: PPUSH
11710: LD_STRING DArtefTechnology-Sci1-2
11712: PPUSH
11713: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11717: LD_ADDR_VAR 0 1
11721: PUSH
11722: LD_INT 22
11724: PUSH
11725: LD_INT 7
11727: PUSH
11728: EMPTY
11729: LIST
11730: LIST
11731: PUSH
11732: LD_INT 23
11734: PUSH
11735: LD_INT 3
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 25
11744: PUSH
11745: LD_INT 4
11747: PUSH
11748: EMPTY
11749: LIST
11750: LIST
11751: PUSH
11752: LD_INT 21
11754: PUSH
11755: LD_INT 1
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: PUSH
11762: LD_INT 26
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: EMPTY
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: PPUSH
11779: CALL_OW 69
11783: PUSH
11784: LD_EXP 13
11788: PUSH
11789: LD_EXP 12
11793: PUSH
11794: LD_EXP 44
11798: PUSH
11799: LD_EXP 32
11803: PUSH
11804: LD_EXP 42
11808: PUSH
11809: LD_EXP 41
11813: PUSH
11814: EMPTY
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: DIFF
11822: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
11823: LD_VAR 0 1
11827: PUSH
11828: LD_EXP 6
11832: PUSH
11833: LD_EXP 5
11837: OR
11838: AND
11839: IFFALSE 12073
// begin if arabianDestroyed and IsOk ( Burlak ) then
11841: LD_EXP 5
11845: PUSH
11846: LD_EXP 44
11850: PPUSH
11851: CALL_OW 302
11855: AND
11856: IFFALSE 11872
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
11858: LD_EXP 44
11862: PPUSH
11863: LD_STRING DArtefTechnology-Bur-2
11865: PPUSH
11866: CALL_OW 88
11870: GO 11884
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
11872: LD_EXP 12
11876: PPUSH
11877: LD_STRING DArtefTechnology-JMM-2
11879: PPUSH
11880: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
11884: LD_VAR 0 1
11888: PUSH
11889: LD_INT 1
11891: ARRAY
11892: PPUSH
11893: LD_STRING DArtefTechnology-RSci1-3
11895: PPUSH
11896: CALL_OW 88
// if Denis then
11900: LD_EXP 18
11904: IFFALSE 11921
// speaker := [ Denis ] else
11906: LD_ADDR_VAR 0 1
11910: PUSH
11911: LD_EXP 18
11915: PUSH
11916: EMPTY
11917: LIST
11918: ST_TO_ADDR
11919: GO 12027
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11921: LD_ADDR_VAR 0 1
11925: PUSH
11926: LD_INT 22
11928: PUSH
11929: LD_INT 7
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: PUSH
11936: LD_INT 23
11938: PUSH
11939: LD_INT 1
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: PUSH
11946: LD_INT 25
11948: PUSH
11949: LD_INT 4
11951: PUSH
11952: EMPTY
11953: LIST
11954: LIST
11955: PUSH
11956: LD_INT 21
11958: PUSH
11959: LD_INT 1
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PUSH
11966: LD_INT 26
11968: PUSH
11969: LD_INT 1
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: PPUSH
11983: CALL_OW 69
11987: PUSH
11988: LD_EXP 13
11992: PUSH
11993: LD_EXP 12
11997: PUSH
11998: LD_EXP 44
12002: PUSH
12003: LD_EXP 32
12007: PUSH
12008: LD_EXP 42
12012: PUSH
12013: LD_EXP 41
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: LIST
12024: LIST
12025: DIFF
12026: ST_TO_ADDR
// if speaker then
12027: LD_VAR 0 1
12031: IFFALSE 12073
// if alienSpotted then
12033: LD_EXP 7
12037: IFFALSE 12057
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12039: LD_VAR 0 1
12043: PUSH
12044: LD_INT 1
12046: ARRAY
12047: PPUSH
12048: LD_STRING DArtefTechnology-Sci1-3
12050: PPUSH
12051: CALL_OW 88
12055: GO 12073
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12057: LD_VAR 0 1
12061: PUSH
12062: LD_INT 1
12064: ARRAY
12065: PPUSH
12066: LD_STRING DArtefTechnology-Sci1-3a
12068: PPUSH
12069: CALL_OW 88
// end ; DialogueOff ;
12073: CALL_OW 7
// end ;
12077: PPOPN 1
12079: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12080: LD_EXP 9
12084: IFFALSE 12279
12086: GO 12088
12088: DISABLE
12089: LD_INT 0
12091: PPUSH
// begin if Denis then
12092: LD_EXP 18
12096: IFFALSE 12113
// speaker := [ Denis ] else
12098: LD_ADDR_VAR 0 1
12102: PUSH
12103: LD_EXP 18
12107: PUSH
12108: EMPTY
12109: LIST
12110: ST_TO_ADDR
12111: GO 12219
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12113: LD_ADDR_VAR 0 1
12117: PUSH
12118: LD_INT 22
12120: PUSH
12121: LD_INT 7
12123: PUSH
12124: EMPTY
12125: LIST
12126: LIST
12127: PUSH
12128: LD_INT 23
12130: PUSH
12131: LD_INT 1
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PUSH
12138: LD_INT 25
12140: PUSH
12141: LD_INT 4
12143: PUSH
12144: EMPTY
12145: LIST
12146: LIST
12147: PUSH
12148: LD_INT 21
12150: PUSH
12151: LD_INT 1
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: PUSH
12158: LD_INT 26
12160: PUSH
12161: LD_INT 1
12163: PUSH
12164: EMPTY
12165: LIST
12166: LIST
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: LIST
12172: LIST
12173: LIST
12174: PPUSH
12175: CALL_OW 69
12179: PUSH
12180: LD_EXP 13
12184: PUSH
12185: LD_EXP 12
12189: PUSH
12190: LD_EXP 44
12194: PUSH
12195: LD_EXP 32
12199: PUSH
12200: LD_EXP 42
12204: PUSH
12205: LD_EXP 41
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: LIST
12214: LIST
12215: LIST
12216: LIST
12217: DIFF
12218: ST_TO_ADDR
// if not speaker then
12219: LD_VAR 0 1
12223: NOT
12224: IFFALSE 12228
// exit ;
12226: GO 12279
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12228: LD_VAR 0 1
12232: PUSH
12233: LD_INT 1
12235: ARRAY
12236: PPUSH
12237: LD_STRING DArtefTechnologyAm-Sci1-1
12239: PPUSH
12240: CALL_OW 88
// if IsOk ( Burlak ) then
12244: LD_EXP 44
12248: PPUSH
12249: CALL_OW 302
12253: IFFALSE 12267
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12255: LD_EXP 44
12259: PPUSH
12260: LD_STRING DArtefTechnologyAm-Bur-1
12262: PPUSH
12263: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12267: LD_EXP 12
12271: PPUSH
12272: LD_STRING DArtefTechnologyAm-JMM-1
12274: PPUSH
12275: CALL_OW 88
// end ;
12279: PPOPN 1
12281: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12282: LD_EXP 10
12286: IFFALSE 12497
12288: GO 12290
12290: DISABLE
12291: LD_INT 0
12293: PPUSH
// begin if Denis then
12294: LD_EXP 18
12298: IFFALSE 12315
// speaker := [ Denis ] else
12300: LD_ADDR_VAR 0 1
12304: PUSH
12305: LD_EXP 18
12309: PUSH
12310: EMPTY
12311: LIST
12312: ST_TO_ADDR
12313: GO 12421
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12315: LD_ADDR_VAR 0 1
12319: PUSH
12320: LD_INT 22
12322: PUSH
12323: LD_INT 7
12325: PUSH
12326: EMPTY
12327: LIST
12328: LIST
12329: PUSH
12330: LD_INT 23
12332: PUSH
12333: LD_INT 3
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PUSH
12340: LD_INT 25
12342: PUSH
12343: LD_INT 4
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 21
12352: PUSH
12353: LD_INT 1
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: LD_INT 26
12362: PUSH
12363: LD_INT 1
12365: PUSH
12366: EMPTY
12367: LIST
12368: LIST
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: LIST
12376: PPUSH
12377: CALL_OW 69
12381: PUSH
12382: LD_EXP 13
12386: PUSH
12387: LD_EXP 12
12391: PUSH
12392: LD_EXP 44
12396: PUSH
12397: LD_EXP 32
12401: PUSH
12402: LD_EXP 42
12406: PUSH
12407: LD_EXP 41
12411: PUSH
12412: EMPTY
12413: LIST
12414: LIST
12415: LIST
12416: LIST
12417: LIST
12418: LIST
12419: DIFF
12420: ST_TO_ADDR
// if not speaker then
12421: LD_VAR 0 1
12425: NOT
12426: IFFALSE 12430
// exit ;
12428: GO 12497
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12430: LD_VAR 0 1
12434: PUSH
12435: LD_INT 1
12437: ARRAY
12438: PPUSH
12439: LD_STRING DArtefTechnologyRu-RSci1-1
12441: PPUSH
12442: CALL_OW 88
// if IsOk ( Burlak ) then
12446: LD_EXP 44
12450: PPUSH
12451: CALL_OW 302
12455: IFFALSE 12469
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12457: LD_EXP 44
12461: PPUSH
12462: LD_STRING DArtefTechnologyRu-Bur-1
12464: PPUSH
12465: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12469: LD_VAR 0 1
12473: PUSH
12474: LD_INT 1
12476: ARRAY
12477: PPUSH
12478: LD_STRING DArtefTechnologyRu-RSci1-2
12480: PPUSH
12481: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12485: LD_EXP 12
12489: PPUSH
12490: LD_STRING DArtefTechnologyRu-JMM-1
12492: PPUSH
12493: CALL_OW 88
// end ;
12497: PPOPN 1
12499: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12500: LD_INT 24
12502: PPUSH
12503: LD_INT 7
12505: PPUSH
12506: CALL_OW 321
12510: PUSH
12511: LD_INT 2
12513: EQUAL
12514: PUSH
12515: LD_INT 1
12517: PPUSH
12518: CALL_OW 255
12522: PUSH
12523: LD_INT 7
12525: EQUAL
12526: AND
12527: IFFALSE 12687
12529: GO 12531
12531: DISABLE
12532: LD_INT 0
12534: PPUSH
// begin if Denis then
12535: LD_EXP 18
12539: IFFALSE 12556
// speaker := [ Denis ] else
12541: LD_ADDR_VAR 0 1
12545: PUSH
12546: LD_EXP 18
12550: PUSH
12551: EMPTY
12552: LIST
12553: ST_TO_ADDR
12554: GO 12662
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12556: LD_ADDR_VAR 0 1
12560: PUSH
12561: LD_INT 22
12563: PUSH
12564: LD_INT 7
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PUSH
12571: LD_INT 23
12573: PUSH
12574: LD_INT 1
12576: PUSH
12577: EMPTY
12578: LIST
12579: LIST
12580: PUSH
12581: LD_INT 25
12583: PUSH
12584: LD_INT 4
12586: PUSH
12587: EMPTY
12588: LIST
12589: LIST
12590: PUSH
12591: LD_INT 21
12593: PUSH
12594: LD_INT 1
12596: PUSH
12597: EMPTY
12598: LIST
12599: LIST
12600: PUSH
12601: LD_INT 26
12603: PUSH
12604: LD_INT 1
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: PPUSH
12618: CALL_OW 69
12622: PUSH
12623: LD_EXP 13
12627: PUSH
12628: LD_EXP 12
12632: PUSH
12633: LD_EXP 44
12637: PUSH
12638: LD_EXP 32
12642: PUSH
12643: LD_EXP 42
12647: PUSH
12648: LD_EXP 41
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: LIST
12657: LIST
12658: LIST
12659: LIST
12660: DIFF
12661: ST_TO_ADDR
// if not speaker then
12662: LD_VAR 0 1
12666: NOT
12667: IFFALSE 12671
// exit ;
12669: GO 12687
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12671: LD_VAR 0 1
12675: PUSH
12676: LD_INT 1
12678: ARRAY
12679: PPUSH
12680: LD_STRING DArtefTechnologyArStart-Sci1-1
12682: PPUSH
12683: CALL_OW 88
// end ;
12687: PPOPN 1
12689: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12690: LD_EXP 11
12694: IFFALSE 12975
12696: GO 12698
12698: DISABLE
12699: LD_INT 0
12701: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12702: LD_ADDR_VAR 0 1
12706: PUSH
12707: LD_INT 22
12709: PUSH
12710: LD_INT 7
12712: PUSH
12713: EMPTY
12714: LIST
12715: LIST
12716: PUSH
12717: LD_INT 23
12719: PUSH
12720: LD_INT 3
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 25
12729: PUSH
12730: LD_INT 4
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: PUSH
12737: LD_INT 21
12739: PUSH
12740: LD_INT 1
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: PUSH
12747: LD_INT 26
12749: PUSH
12750: LD_INT 1
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: LIST
12763: PPUSH
12764: CALL_OW 69
12768: PUSH
12769: LD_EXP 13
12773: PUSH
12774: LD_EXP 12
12778: PUSH
12779: LD_EXP 44
12783: PUSH
12784: LD_EXP 32
12788: PUSH
12789: LD_EXP 42
12793: PUSH
12794: LD_EXP 41
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: DIFF
12807: ST_TO_ADDR
// if not speaker then
12808: LD_VAR 0 1
12812: NOT
12813: IFFALSE 12817
// exit ;
12815: GO 12975
// DialogueOn ;
12817: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
12821: LD_VAR 0 1
12825: PUSH
12826: LD_INT 1
12828: ARRAY
12829: PPUSH
12830: LD_STRING DArtefTechnologyAr-RSci1-1
12832: PPUSH
12833: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
12837: LD_EXP 12
12841: PPUSH
12842: LD_STRING DArtefTechnologyAr-JMM-1
12844: PPUSH
12845: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
12849: LD_VAR 0 1
12853: PUSH
12854: LD_INT 1
12856: ARRAY
12857: PPUSH
12858: LD_STRING DArtefTechnologyAr-RSci1-2
12860: PPUSH
12861: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
12865: LD_EXP 12
12869: PPUSH
12870: LD_STRING DArtefTechnologyAr-JMM-2
12872: PPUSH
12873: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
12877: LD_VAR 0 1
12881: PUSH
12882: LD_INT 1
12884: ARRAY
12885: PPUSH
12886: LD_STRING DArtefTechnologyAr-RSci1-3
12888: PPUSH
12889: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
12893: LD_EXP 12
12897: PPUSH
12898: LD_STRING DArtefTechnologyAr-JMM-3
12900: PPUSH
12901: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
12905: LD_VAR 0 1
12909: PUSH
12910: LD_INT 1
12912: ARRAY
12913: PPUSH
12914: LD_STRING DArtefTechnologyAr-RSci1-4
12916: PPUSH
12917: CALL_OW 88
// if IsOk ( Burlak ) then
12921: LD_EXP 44
12925: PPUSH
12926: CALL_OW 302
12930: IFFALSE 12944
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
12932: LD_EXP 44
12936: PPUSH
12937: LD_STRING DArtefTechnologyAr-Bur-4
12939: PPUSH
12940: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
12944: LD_EXP 12
12948: PPUSH
12949: LD_STRING DArtefTechnologyAr-JMM-4
12951: PPUSH
12952: CALL_OW 88
// DialogueOff ;
12956: CALL_OW 7
// wait ( 0 0$45 ) ;
12960: LD_INT 1575
12962: PPUSH
12963: CALL_OW 67
// spawnOmar := true ;
12967: LD_ADDR_EXP 8
12971: PUSH
12972: LD_INT 1
12974: ST_TO_ADDR
// end ;
12975: PPOPN 1
12977: END
// every 0 0$1 trigger spawnOmar do
12978: LD_EXP 8
12982: IFFALSE 13280
12984: GO 12986
12986: DISABLE
// begin PrepareOmarAli ;
12987: CALL 6510 0 0
// if not Omar then
12991: LD_EXP 48
12995: NOT
12996: IFFALSE 13000
// exit ;
12998: GO 13280
// repeat wait ( 0 0$1 ) ;
13000: LD_INT 35
13002: PPUSH
13003: CALL_OW 67
// until See ( 7 , Omar ) ;
13007: LD_INT 7
13009: PPUSH
13010: LD_EXP 48
13014: PPUSH
13015: CALL_OW 292
13019: IFFALSE 13000
// CenterNowOnUnits ( Omar ) ;
13021: LD_EXP 48
13025: PPUSH
13026: CALL_OW 87
// DialogueOn ;
13030: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13034: LD_EXP 48
13038: PPUSH
13039: LD_STRING DOmar-Omar-1
13041: PPUSH
13042: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13046: LD_EXP 12
13050: PPUSH
13051: LD_STRING DOmar-JMM-1
13053: PPUSH
13054: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13058: LD_EXP 48
13062: PPUSH
13063: LD_STRING DOmar-Omar-2
13065: PPUSH
13066: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13070: LD_EXP 12
13074: PPUSH
13075: LD_STRING DOmar-JMM-2
13077: PPUSH
13078: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13082: LD_EXP 48
13086: PPUSH
13087: LD_STRING DOmar-Omar-3
13089: PPUSH
13090: CALL_OW 88
// if IsOk ( Burlak ) then
13094: LD_EXP 44
13098: PPUSH
13099: CALL_OW 302
13103: IFFALSE 13119
// Say ( Burlak , DOmar-Bur-3 ) else
13105: LD_EXP 44
13109: PPUSH
13110: LD_STRING DOmar-Bur-3
13112: PPUSH
13113: CALL_OW 88
13117: GO 13131
// Say ( JMM , DOmar-JMM-3 ) ;
13119: LD_EXP 12
13123: PPUSH
13124: LD_STRING DOmar-JMM-3
13126: PPUSH
13127: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13131: LD_EXP 48
13135: PPUSH
13136: LD_STRING DOmar-Omar-4
13138: PPUSH
13139: CALL_OW 88
// case Query ( QAccept ) of 1 :
13143: LD_STRING QAccept
13145: PPUSH
13146: CALL_OW 97
13150: PUSH
13151: LD_INT 1
13153: DOUBLE
13154: EQUAL
13155: IFTRUE 13159
13157: GO 13195
13159: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13160: LD_EXP 12
13164: PPUSH
13165: LD_STRING DQrAccept#1-JMM-1
13167: PPUSH
13168: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13172: LD_EXP 48
13176: PPUSH
13177: LD_INT 7
13179: PPUSH
13180: CALL_OW 235
// ComStop ( Omar ) ;
13184: LD_EXP 48
13188: PPUSH
13189: CALL_OW 141
// end ; 2 :
13193: GO 13244
13195: LD_INT 2
13197: DOUBLE
13198: EQUAL
13199: IFTRUE 13203
13201: GO 13243
13203: POP
// begin if IsOk ( Burlak ) then
13204: LD_EXP 44
13208: PPUSH
13209: CALL_OW 302
13213: IFFALSE 13229
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13215: LD_EXP 44
13219: PPUSH
13220: LD_STRING DQrAccept#2-Bur-1
13222: PPUSH
13223: CALL_OW 88
13227: GO 13241
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13229: LD_EXP 12
13233: PPUSH
13234: LD_STRING DQrAccept#2-JMM-1
13236: PPUSH
13237: CALL_OW 88
// end ; end ;
13241: GO 13244
13243: POP
// DialogueOff ;
13244: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13248: LD_EXP 48
13252: PPUSH
13253: CALL_OW 255
13257: PUSH
13258: LD_INT 7
13260: EQUAL
13261: IFFALSE 13265
// exit ;
13263: GO 13280
// ComMoveXY ( Omar , 202 , 115 ) ;
13265: LD_EXP 48
13269: PPUSH
13270: LD_INT 202
13272: PPUSH
13273: LD_INT 115
13275: PPUSH
13276: CALL_OW 111
// end ;
13280: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13281: LD_EXP 48
13285: PPUSH
13286: LD_INT 200
13288: PPUSH
13289: LD_INT 98
13291: PPUSH
13292: CALL_OW 297
13296: PUSH
13297: LD_INT 40
13299: LESS
13300: PUSH
13301: LD_EXP 2
13305: AND
13306: IFFALSE 13524
13308: GO 13310
13310: DISABLE
// begin SetSide ( Omar , 5 ) ;
13311: LD_EXP 48
13315: PPUSH
13316: LD_INT 5
13318: PPUSH
13319: CALL_OW 235
// if IsInUnit ( Omar ) then
13323: LD_EXP 48
13327: PPUSH
13328: CALL_OW 310
13332: IFFALSE 13343
// ComExitVehicle ( Omar ) ;
13334: LD_EXP 48
13338: PPUSH
13339: CALL_OW 121
// if IsInUnit ( Omar ) then
13343: LD_EXP 48
13347: PPUSH
13348: CALL_OW 310
13352: IFFALSE 13363
// ComExitBuilding ( Omar ) ;
13354: LD_EXP 48
13358: PPUSH
13359: CALL_OW 122
// wait ( 0 0$1 ) ;
13363: LD_INT 35
13365: PPUSH
13366: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13370: LD_EXP 48
13374: PPUSH
13375: LD_INT 203
13377: PPUSH
13378: LD_INT 120
13380: PPUSH
13381: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13385: LD_INT 35
13387: PPUSH
13388: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13392: LD_EXP 48
13396: PPUSH
13397: CALL_OW 306
13401: PUSH
13402: LD_EXP 48
13406: PPUSH
13407: LD_INT 203
13409: PPUSH
13410: LD_INT 120
13412: PPUSH
13413: CALL_OW 297
13417: PUSH
13418: LD_INT 6
13420: LESS
13421: OR
13422: IFFALSE 13385
// CenterNowOnUnits ( Omar ) ;
13424: LD_EXP 48
13428: PPUSH
13429: CALL_OW 87
// DialogueOn ;
13433: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13437: LD_EXP 12
13441: PPUSH
13442: LD_STRING DOmarContam-JMM-1
13444: PPUSH
13445: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13449: LD_EXP 48
13453: PPUSH
13454: LD_STRING DOmarContam-Omar-1
13456: PPUSH
13457: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13461: LD_EXP 12
13465: PPUSH
13466: LD_STRING DOmarContam-JMM-2
13468: PPUSH
13469: CALL_OW 88
// DialogueOff ;
13473: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13477: LD_INT 5
13479: PPUSH
13480: LD_INT 7
13482: PPUSH
13483: LD_INT 2
13485: PPUSH
13486: LD_INT 1
13488: PPUSH
13489: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13493: LD_INT 105
13495: PPUSH
13496: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13500: LD_EXP 48
13504: PPUSH
13505: LD_INT 203
13507: PPUSH
13508: LD_INT 120
13510: PPUSH
13511: CALL_OW 307
13515: IFFALSE 13493
// YouLost ( MothContaminate ) ;
13517: LD_STRING MothContaminate
13519: PPUSH
13520: CALL_OW 104
// end ;
13524: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13525: LD_EXP 4
13529: NOT
13530: PUSH
13531: LD_INT 22
13533: PUSH
13534: LD_INT 1
13536: PUSH
13537: EMPTY
13538: LIST
13539: LIST
13540: PUSH
13541: LD_INT 34
13543: PUSH
13544: LD_INT 8
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PPUSH
13555: CALL_OW 69
13559: AND
13560: IFFALSE 13641
13562: GO 13564
13564: DISABLE
// begin if not IsOk ( Powell ) then
13565: LD_EXP 47
13569: PPUSH
13570: CALL_OW 302
13574: NOT
13575: IFFALSE 13579
// exit ;
13577: GO 13641
// DialogueOn ;
13579: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13583: LD_EXP 47
13587: PPUSH
13588: LD_STRING DWinAmericans-Pow-1
13590: PPUSH
13591: CALL_OW 94
// if IsOk ( Burlak ) then
13595: LD_EXP 44
13599: PPUSH
13600: CALL_OW 302
13604: IFFALSE 13618
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13606: LD_EXP 44
13610: PPUSH
13611: LD_STRING DWinAmericans-Bur-1
13613: PPUSH
13614: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13618: LD_EXP 12
13622: PPUSH
13623: LD_STRING DWinAmericans-JMM-1
13625: PPUSH
13626: CALL_OW 88
// DialogueOff ;
13630: CALL_OW 7
// YouLost ( AmBomb ) ;
13634: LD_STRING AmBomb
13636: PPUSH
13637: CALL_OW 104
// end ;
13641: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13642: LD_EXP 2
13646: NOT
13647: PUSH
13648: LD_INT 22
13650: PUSH
13651: LD_INT 3
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PUSH
13658: LD_INT 34
13660: PUSH
13661: LD_INT 48
13663: PUSH
13664: EMPTY
13665: LIST
13666: LIST
13667: PUSH
13668: EMPTY
13669: LIST
13670: LIST
13671: PPUSH
13672: CALL_OW 69
13676: AND
13677: IFFALSE 13758
13679: GO 13681
13681: DISABLE
// begin if not IsOk ( Platonov ) then
13682: LD_EXP 51
13686: PPUSH
13687: CALL_OW 302
13691: NOT
13692: IFFALSE 13696
// exit ;
13694: GO 13758
// DialogueOn ;
13696: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13700: LD_EXP 51
13704: PPUSH
13705: LD_STRING DWinRussians-Pla-1
13707: PPUSH
13708: CALL_OW 94
// if IsOk ( Burlak ) then
13712: LD_EXP 44
13716: PPUSH
13717: CALL_OW 302
13721: IFFALSE 13735
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13723: LD_EXP 44
13727: PPUSH
13728: LD_STRING DWinRussians-Bur-1
13730: PPUSH
13731: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13735: LD_EXP 12
13739: PPUSH
13740: LD_STRING DWinRussians-JMM-1
13742: PPUSH
13743: CALL_OW 88
// DialogueOff ;
13747: CALL_OW 7
// YouLost ( RuBomb ) ;
13751: LD_STRING RuBomb
13753: PPUSH
13754: CALL_OW 104
// end ;
13758: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13759: LD_INT 7
13761: PPUSH
13762: LD_INT 22
13764: PUSH
13765: LD_INT 7
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: PPUSH
13772: CALL_OW 70
13776: PUSH
13777: LD_EXP 4
13781: NOT
13782: AND
13783: IFFALSE 13812
13785: GO 13787
13787: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13788: LD_EXP 47
13792: PPUSH
13793: LD_STRING DSurrenderAmericans-Pow-1
13795: PPUSH
13796: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
13800: LD_EXP 12
13804: PPUSH
13805: LD_STRING DSurrenderAmericans-JMM-1
13807: PPUSH
13808: CALL_OW 88
// end ;
13812: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
13813: LD_INT 2
13815: PPUSH
13816: LD_INT 22
13818: PUSH
13819: LD_INT 7
13821: PUSH
13822: EMPTY
13823: LIST
13824: LIST
13825: PPUSH
13826: CALL_OW 70
13830: PUSH
13831: LD_EXP 2
13835: NOT
13836: AND
13837: PUSH
13838: LD_EXP 44
13842: AND
13843: IFFALSE 13872
13845: GO 13847
13847: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
13848: LD_EXP 51
13852: PPUSH
13853: LD_STRING DSurrenderRussians-Pla-1
13855: PPUSH
13856: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
13860: LD_EXP 44
13864: PPUSH
13865: LD_STRING DSurrenderRussians-Bur-1
13867: PPUSH
13868: CALL_OW 88
// end ;
13872: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
13873: LD_EXP 4
13877: IFFALSE 14252
13879: GO 13881
13881: DISABLE
13882: LD_INT 0
13884: PPUSH
13885: PPUSH
13886: PPUSH
// begin MC_Kill ( 4 ) ;
13887: LD_INT 4
13889: PPUSH
13890: CALL 20342 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
13894: LD_INT 1
13896: PPUSH
13897: LD_INT 7
13899: PPUSH
13900: LD_INT 1
13902: PPUSH
13903: LD_INT 1
13905: PPUSH
13906: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
13910: LD_ADDR_VAR 0 3
13914: PUSH
13915: LD_INT 22
13917: PUSH
13918: LD_INT 1
13920: PUSH
13921: EMPTY
13922: LIST
13923: LIST
13924: PUSH
13925: LD_INT 26
13927: PUSH
13928: LD_INT 1
13930: PUSH
13931: EMPTY
13932: LIST
13933: LIST
13934: PUSH
13935: LD_INT 23
13937: PUSH
13938: LD_INT 1
13940: PUSH
13941: EMPTY
13942: LIST
13943: LIST
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: LIST
13949: PPUSH
13950: CALL_OW 69
13954: PUSH
13955: LD_EXP 47
13959: PUSH
13960: LD_EXP 20
13964: PUSH
13965: LD_EXP 17
13969: PUSH
13970: LD_EXP 16
13974: PUSH
13975: LD_EXP 23
13979: PUSH
13980: LD_EXP 21
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: LIST
13989: LIST
13990: LIST
13991: LIST
13992: DIFF
13993: ST_TO_ADDR
// if speaker then
13994: LD_VAR 0 3
13998: IFFALSE 14024
// begin DialogueOn ;
14000: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14004: LD_VAR 0 3
14008: PUSH
14009: LD_INT 1
14011: ARRAY
14012: PPUSH
14013: LD_STRING DSurrenderAmericans-Sol1-1a
14015: PPUSH
14016: CALL_OW 94
// DialogueOff ;
14020: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14024: LD_ADDR_VAR 0 2
14028: PUSH
14029: LD_INT 22
14031: PUSH
14032: LD_INT 1
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: LD_INT 21
14041: PUSH
14042: LD_INT 1
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: PPUSH
14053: CALL_OW 69
14057: PUSH
14058: LD_INT 22
14060: PUSH
14061: LD_INT 1
14063: PUSH
14064: EMPTY
14065: LIST
14066: LIST
14067: PUSH
14068: LD_INT 21
14070: PUSH
14071: LD_INT 2
14073: PUSH
14074: EMPTY
14075: LIST
14076: LIST
14077: PUSH
14078: LD_INT 1
14080: PUSH
14081: EMPTY
14082: LIST
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: PPUSH
14089: CALL_OW 69
14093: ADD
14094: ST_TO_ADDR
// if tmp then
14095: LD_VAR 0 2
14099: IFFALSE 14252
// repeat wait ( 0 0$1 ) ;
14101: LD_INT 35
14103: PPUSH
14104: CALL_OW 67
// for i in tmp do
14108: LD_ADDR_VAR 0 1
14112: PUSH
14113: LD_VAR 0 2
14117: PUSH
14118: FOR_IN
14119: IFFALSE 14201
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14121: LD_VAR 0 1
14125: PPUSH
14126: CALL_OW 310
14130: PUSH
14131: LD_VAR 0 1
14135: PPUSH
14136: CALL_OW 310
14140: PPUSH
14141: CALL_OW 247
14145: PUSH
14146: LD_INT 3
14148: EQUAL
14149: AND
14150: IFFALSE 14161
// ComExitBuilding ( i ) ;
14152: LD_VAR 0 1
14156: PPUSH
14157: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14161: LD_VAR 0 1
14165: PPUSH
14166: LD_INT 122
14168: PPUSH
14169: LD_INT 242
14171: PPUSH
14172: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14176: LD_VAR 0 1
14180: PPUSH
14181: LD_INT 35
14183: PPUSH
14184: CALL_OW 308
14188: IFFALSE 14199
// RemoveUnit ( i ) ;
14190: LD_VAR 0 1
14194: PPUSH
14195: CALL_OW 64
// end ;
14199: GO 14118
14201: POP
14202: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14203: LD_INT 22
14205: PUSH
14206: LD_INT 1
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: LD_INT 2
14215: PUSH
14216: LD_INT 21
14218: PUSH
14219: LD_INT 1
14221: PUSH
14222: EMPTY
14223: LIST
14224: LIST
14225: PUSH
14226: LD_INT 33
14228: PUSH
14229: LD_INT 1
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PUSH
14236: EMPTY
14237: LIST
14238: LIST
14239: LIST
14240: PUSH
14241: EMPTY
14242: LIST
14243: LIST
14244: PPUSH
14245: CALL_OW 69
14249: NOT
14250: IFFALSE 14101
// end ;
14252: PPOPN 3
14254: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14255: LD_EXP 2
14259: IFFALSE 14652
14261: GO 14263
14263: DISABLE
14264: LD_INT 0
14266: PPUSH
14267: PPUSH
14268: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14269: LD_INT 35
14271: PPUSH
14272: CALL_OW 67
// until IsDead ( Yakotich ) ;
14276: LD_EXP 52
14280: PPUSH
14281: CALL_OW 301
14285: IFFALSE 14269
// MC_Kill ( 2 ) ;
14287: LD_INT 2
14289: PPUSH
14290: CALL 20342 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14294: LD_INT 3
14296: PPUSH
14297: LD_INT 7
14299: PPUSH
14300: LD_INT 1
14302: PPUSH
14303: LD_INT 1
14305: PPUSH
14306: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14310: LD_ADDR_VAR 0 3
14314: PUSH
14315: LD_INT 22
14317: PUSH
14318: LD_INT 3
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: PUSH
14325: LD_INT 26
14327: PUSH
14328: LD_INT 1
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: PUSH
14335: LD_INT 23
14337: PUSH
14338: LD_INT 3
14340: PUSH
14341: EMPTY
14342: LIST
14343: LIST
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: LIST
14349: PPUSH
14350: CALL_OW 69
14354: PUSH
14355: LD_EXP 51
14359: PUSH
14360: LD_EXP 52
14364: PUSH
14365: EMPTY
14366: LIST
14367: LIST
14368: DIFF
14369: ST_TO_ADDR
// if speaker then
14370: LD_VAR 0 3
14374: IFFALSE 14424
// begin DialogueOn ;
14376: CALL_OW 6
// if Burlak then
14380: LD_EXP 44
14384: IFFALSE 14404
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14386: LD_VAR 0 3
14390: PUSH
14391: LD_INT 1
14393: ARRAY
14394: PPUSH
14395: LD_STRING DSurrenderRussians-RSol1-1
14397: PPUSH
14398: CALL_OW 94
14402: GO 14420
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14404: LD_VAR 0 3
14408: PUSH
14409: LD_INT 1
14411: ARRAY
14412: PPUSH
14413: LD_STRING DSurrenderRussians-RSol1-1a
14415: PPUSH
14416: CALL_OW 94
// DialogueOff ;
14420: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14424: LD_ADDR_VAR 0 2
14428: PUSH
14429: LD_INT 22
14431: PUSH
14432: LD_INT 3
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PUSH
14439: LD_INT 21
14441: PUSH
14442: LD_INT 1
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PPUSH
14453: CALL_OW 69
14457: PUSH
14458: LD_INT 22
14460: PUSH
14461: LD_INT 3
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: PUSH
14468: LD_INT 21
14470: PUSH
14471: LD_INT 2
14473: PUSH
14474: EMPTY
14475: LIST
14476: LIST
14477: PUSH
14478: LD_INT 1
14480: PUSH
14481: EMPTY
14482: LIST
14483: PUSH
14484: EMPTY
14485: LIST
14486: LIST
14487: LIST
14488: PPUSH
14489: CALL_OW 69
14493: ADD
14494: ST_TO_ADDR
// if tmp then
14495: LD_VAR 0 2
14499: IFFALSE 14652
// repeat wait ( 0 0$1 ) ;
14501: LD_INT 35
14503: PPUSH
14504: CALL_OW 67
// for i in tmp do
14508: LD_ADDR_VAR 0 1
14512: PUSH
14513: LD_VAR 0 2
14517: PUSH
14518: FOR_IN
14519: IFFALSE 14601
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14521: LD_VAR 0 1
14525: PPUSH
14526: CALL_OW 310
14530: PUSH
14531: LD_VAR 0 1
14535: PPUSH
14536: CALL_OW 310
14540: PPUSH
14541: CALL_OW 247
14545: PUSH
14546: LD_INT 3
14548: EQUAL
14549: AND
14550: IFFALSE 14561
// ComExitBuilding ( i ) ;
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14561: LD_VAR 0 1
14565: PPUSH
14566: LD_INT 154
14568: PPUSH
14569: LD_INT 1
14571: PPUSH
14572: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14576: LD_VAR 0 1
14580: PPUSH
14581: LD_INT 36
14583: PPUSH
14584: CALL_OW 308
14588: IFFALSE 14599
// RemoveUnit ( i ) ;
14590: LD_VAR 0 1
14594: PPUSH
14595: CALL_OW 64
// end ;
14599: GO 14518
14601: POP
14602: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14603: LD_INT 22
14605: PUSH
14606: LD_INT 3
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: PUSH
14613: LD_INT 2
14615: PUSH
14616: LD_INT 21
14618: PUSH
14619: LD_INT 1
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: PUSH
14626: LD_INT 33
14628: PUSH
14629: LD_INT 1
14631: PUSH
14632: EMPTY
14633: LIST
14634: LIST
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: LIST
14640: PUSH
14641: EMPTY
14642: LIST
14643: LIST
14644: PPUSH
14645: CALL_OW 69
14649: NOT
14650: IFFALSE 14501
// end ;
14652: PPOPN 3
14654: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14655: LD_INT 22
14657: PUSH
14658: LD_INT 8
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: PUSH
14665: LD_INT 21
14667: PUSH
14668: LD_INT 1
14670: PUSH
14671: EMPTY
14672: LIST
14673: LIST
14674: PUSH
14675: LD_INT 23
14677: PUSH
14678: LD_INT 2
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: LIST
14689: PPUSH
14690: CALL_OW 69
14694: PUSH
14695: LD_INT 18
14697: LESS
14698: PUSH
14699: LD_EXP 50
14703: PPUSH
14704: CALL_OW 301
14708: OR
14709: PUSH
14710: LD_INT 324
14712: PPUSH
14713: CALL_OW 255
14717: PUSH
14718: LD_INT 7
14720: EQUAL
14721: OR
14722: IFFALSE 14735
14724: GO 14726
14726: DISABLE
// legionDestroyed := true ;
14727: LD_ADDR_EXP 3
14731: PUSH
14732: LD_INT 1
14734: ST_TO_ADDR
14735: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14736: LD_INT 22
14738: PUSH
14739: LD_INT 2
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 21
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 23
14758: PUSH
14759: LD_INT 2
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: PUSH
14776: LD_INT 9
14778: LESS
14779: IFFALSE 14792
14781: GO 14783
14783: DISABLE
// arabianDestroyed := true ;
14784: LD_ADDR_EXP 5
14788: PUSH
14789: LD_INT 1
14791: ST_TO_ADDR
14792: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14793: LD_EXP 5
14797: IFFALSE 15057
14799: GO 14801
14801: DISABLE
14802: LD_INT 0
14804: PPUSH
14805: PPUSH
// begin MC_Kill ( 1 ) ;
14806: LD_INT 1
14808: PPUSH
14809: CALL 20342 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
14813: LD_INT 2
14815: PPUSH
14816: LD_INT 7
14818: PPUSH
14819: LD_INT 1
14821: PPUSH
14822: LD_INT 1
14824: PPUSH
14825: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14829: LD_ADDR_VAR 0 2
14833: PUSH
14834: LD_INT 22
14836: PUSH
14837: LD_INT 2
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: PUSH
14844: LD_INT 21
14846: PUSH
14847: LD_INT 1
14849: PUSH
14850: EMPTY
14851: LIST
14852: LIST
14853: PUSH
14854: EMPTY
14855: LIST
14856: LIST
14857: PPUSH
14858: CALL_OW 69
14862: PUSH
14863: LD_INT 22
14865: PUSH
14866: LD_INT 8
14868: PUSH
14869: EMPTY
14870: LIST
14871: LIST
14872: PUSH
14873: LD_INT 21
14875: PUSH
14876: LD_INT 2
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: PUSH
14883: LD_INT 1
14885: PUSH
14886: EMPTY
14887: LIST
14888: PUSH
14889: EMPTY
14890: LIST
14891: LIST
14892: LIST
14893: PPUSH
14894: CALL_OW 69
14898: ADD
14899: ST_TO_ADDR
// if tmp then
14900: LD_VAR 0 2
14904: IFFALSE 15057
// repeat wait ( 0 0$1 ) ;
14906: LD_INT 35
14908: PPUSH
14909: CALL_OW 67
// for i in tmp do
14913: LD_ADDR_VAR 0 1
14917: PUSH
14918: LD_VAR 0 2
14922: PUSH
14923: FOR_IN
14924: IFFALSE 15006
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14926: LD_VAR 0 1
14930: PPUSH
14931: CALL_OW 310
14935: PUSH
14936: LD_VAR 0 1
14940: PPUSH
14941: CALL_OW 310
14945: PPUSH
14946: CALL_OW 247
14950: PUSH
14951: LD_INT 3
14953: EQUAL
14954: AND
14955: IFFALSE 14966
// ComExitBuilding ( i ) ;
14957: LD_VAR 0 1
14961: PPUSH
14962: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
14966: LD_VAR 0 1
14970: PPUSH
14971: LD_INT 254
14973: PPUSH
14974: LD_INT 268
14976: PPUSH
14977: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
14981: LD_VAR 0 1
14985: PPUSH
14986: LD_INT 34
14988: PPUSH
14989: CALL_OW 308
14993: IFFALSE 15004
// RemoveUnit ( i ) ;
14995: LD_VAR 0 1
14999: PPUSH
15000: CALL_OW 64
// end ;
15004: GO 14923
15006: POP
15007: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15008: LD_INT 22
15010: PUSH
15011: LD_INT 2
15013: PUSH
15014: EMPTY
15015: LIST
15016: LIST
15017: PUSH
15018: LD_INT 2
15020: PUSH
15021: LD_INT 21
15023: PUSH
15024: LD_INT 1
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: PUSH
15031: LD_INT 33
15033: PUSH
15034: LD_INT 1
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PUSH
15041: EMPTY
15042: LIST
15043: LIST
15044: LIST
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: PPUSH
15050: CALL_OW 69
15054: NOT
15055: IFFALSE 14906
// end ;
15057: PPOPN 2
15059: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15060: LD_EXP 3
15064: IFFALSE 15408
15066: GO 15068
15068: DISABLE
15069: LD_INT 0
15071: PPUSH
15072: PPUSH
// begin MC_Kill ( 3 ) ;
15073: LD_INT 3
15075: PPUSH
15076: CALL 20342 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15080: LD_INT 8
15082: PPUSH
15083: LD_INT 7
15085: PPUSH
15086: LD_INT 1
15088: PPUSH
15089: LD_INT 1
15091: PPUSH
15092: CALL_OW 80
// DialogueOn ;
15096: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15100: LD_EXP 49
15104: PPUSH
15105: LD_STRING D15-Szulc-1
15107: PPUSH
15108: CALL_OW 94
// DialogueOff ;
15112: CALL_OW 7
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15116: LD_ADDR_VAR 0 1
15120: PUSH
15121: LD_INT 22
15123: PUSH
15124: LD_INT 8
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: PUSH
15131: LD_INT 21
15133: PUSH
15134: LD_INT 3
15136: PUSH
15137: EMPTY
15138: LIST
15139: LIST
15140: PUSH
15141: LD_INT 23
15143: PUSH
15144: LD_INT 3
15146: PUSH
15147: EMPTY
15148: LIST
15149: LIST
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: LIST
15155: PPUSH
15156: CALL_OW 69
15160: PUSH
15161: FOR_IN
15162: IFFALSE 15178
// SetLives ( i , 3 ) ;
15164: LD_VAR 0 1
15168: PPUSH
15169: LD_INT 3
15171: PPUSH
15172: CALL_OW 234
15176: GO 15161
15178: POP
15179: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15180: LD_ADDR_VAR 0 2
15184: PUSH
15185: LD_INT 22
15187: PUSH
15188: LD_INT 8
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: LD_INT 21
15197: PUSH
15198: LD_INT 1
15200: PUSH
15201: EMPTY
15202: LIST
15203: LIST
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: PPUSH
15209: CALL_OW 69
15213: PUSH
15214: LD_INT 22
15216: PUSH
15217: LD_INT 8
15219: PUSH
15220: EMPTY
15221: LIST
15222: LIST
15223: PUSH
15224: LD_INT 21
15226: PUSH
15227: LD_INT 2
15229: PUSH
15230: EMPTY
15231: LIST
15232: LIST
15233: PUSH
15234: LD_INT 1
15236: PUSH
15237: EMPTY
15238: LIST
15239: PUSH
15240: EMPTY
15241: LIST
15242: LIST
15243: LIST
15244: PPUSH
15245: CALL_OW 69
15249: ADD
15250: ST_TO_ADDR
// if tmp then
15251: LD_VAR 0 2
15255: IFFALSE 15408
// repeat wait ( 0 0$1 ) ;
15257: LD_INT 35
15259: PPUSH
15260: CALL_OW 67
// for i in tmp do
15264: LD_ADDR_VAR 0 1
15268: PUSH
15269: LD_VAR 0 2
15273: PUSH
15274: FOR_IN
15275: IFFALSE 15357
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15277: LD_VAR 0 1
15281: PPUSH
15282: CALL_OW 310
15286: PUSH
15287: LD_VAR 0 1
15291: PPUSH
15292: CALL_OW 310
15296: PPUSH
15297: CALL_OW 247
15301: PUSH
15302: LD_INT 3
15304: EQUAL
15305: AND
15306: IFFALSE 15317
// ComExitBuilding ( i ) ;
15308: LD_VAR 0 1
15312: PPUSH
15313: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15317: LD_VAR 0 1
15321: PPUSH
15322: LD_INT 10
15324: PPUSH
15325: LD_INT 1
15327: PPUSH
15328: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15332: LD_VAR 0 1
15336: PPUSH
15337: LD_INT 32
15339: PPUSH
15340: CALL_OW 308
15344: IFFALSE 15355
// RemoveUnit ( i ) ;
15346: LD_VAR 0 1
15350: PPUSH
15351: CALL_OW 64
// end ;
15355: GO 15274
15357: POP
15358: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15359: LD_INT 22
15361: PUSH
15362: LD_INT 8
15364: PUSH
15365: EMPTY
15366: LIST
15367: LIST
15368: PUSH
15369: LD_INT 2
15371: PUSH
15372: LD_INT 21
15374: PUSH
15375: LD_INT 1
15377: PUSH
15378: EMPTY
15379: LIST
15380: LIST
15381: PUSH
15382: LD_INT 33
15384: PUSH
15385: LD_INT 1
15387: PUSH
15388: EMPTY
15389: LIST
15390: LIST
15391: PUSH
15392: EMPTY
15393: LIST
15394: LIST
15395: LIST
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PPUSH
15401: CALL_OW 69
15405: NOT
15406: IFFALSE 15257
// end ;
15408: PPOPN 2
15410: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do var med1 , med2 ;
15411: LD_EXP 4
15415: PUSH
15416: LD_EXP 2
15420: AND
15421: PUSH
15422: LD_EXP 3
15426: AND
15427: PUSH
15428: LD_EXP 5
15432: AND
15433: IFFALSE 16776
15435: GO 15437
15437: DISABLE
15438: LD_INT 0
15440: PPUSH
15441: PPUSH
// begin music_class := 5 ;
15442: LD_ADDR_OWVAR 72
15446: PUSH
15447: LD_INT 5
15449: ST_TO_ADDR
// music_nat := 5 ;
15450: LD_ADDR_OWVAR 71
15454: PUSH
15455: LD_INT 5
15457: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
15458: LD_EXP 12
15462: PPUSH
15463: CALL_OW 87
// InGameOn ;
15467: CALL_OW 8
// DialogueOn ;
15471: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15475: LD_EXP 12
15479: PPUSH
15480: LD_STRING DEnd-JMM-JMM-1
15482: PPUSH
15483: CALL_OW 88
// if Joan then
15487: LD_EXP 27
15491: IFFALSE 15507
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15493: LD_EXP 27
15497: PPUSH
15498: LD_STRING DEnd-JMM-Joan-1
15500: PPUSH
15501: CALL_OW 88
15505: GO 15551
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15507: LD_EXP 14
15511: PUSH
15512: LD_EXP 14
15516: PPUSH
15517: CALL_OW 255
15521: PUSH
15522: LD_INT 7
15524: EQUAL
15525: AND
15526: PUSH
15527: LD_EXP 14
15531: PPUSH
15532: CALL_OW 305
15536: AND
15537: IFFALSE 15551
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15539: LD_EXP 14
15543: PPUSH
15544: LD_STRING DEnd-JMM-Lisa-1
15546: PPUSH
15547: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15551: LD_EXP 24
15555: PUSH
15556: LD_EXP 24
15560: PPUSH
15561: CALL_OW 305
15565: AND
15566: IFFALSE 15580
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15568: LD_EXP 24
15572: PPUSH
15573: LD_STRING DEnd-JMM-Frank-1
15575: PPUSH
15576: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15580: LD_EXP 17
15584: PUSH
15585: LD_EXP 17
15589: PPUSH
15590: CALL_OW 255
15594: PUSH
15595: LD_INT 7
15597: EQUAL
15598: AND
15599: PUSH
15600: LD_EXP 17
15604: PPUSH
15605: CALL_OW 305
15609: AND
15610: IFFALSE 15624
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15612: LD_EXP 17
15616: PPUSH
15617: LD_STRING DEnd-JMM-Cyrus-1
15619: PPUSH
15620: CALL_OW 88
// if Burlak then
15624: LD_EXP 44
15628: IFFALSE 15642
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15630: LD_EXP 44
15634: PPUSH
15635: LD_STRING DEnd-JMM-Bur-1
15637: PPUSH
15638: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15642: LD_EXP 27
15646: PUSH
15647: LD_EXP 14
15651: AND
15652: PUSH
15653: LD_EXP 14
15657: PPUSH
15658: CALL_OW 255
15662: PUSH
15663: LD_INT 7
15665: EQUAL
15666: AND
15667: PUSH
15668: LD_EXP 14
15672: PPUSH
15673: CALL_OW 305
15677: AND
15678: IFFALSE 15692
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15680: LD_EXP 14
15684: PPUSH
15685: LD_STRING DEnd-Burlak-Lisa-1
15687: PPUSH
15688: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15692: LD_EXP 45
15696: PUSH
15697: LD_EXP 45
15701: PPUSH
15702: CALL_OW 305
15706: AND
15707: IFFALSE 15721
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15709: LD_EXP 45
15713: PPUSH
15714: LD_STRING DEnd-JMM-Bel-1
15716: PPUSH
15717: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15721: LD_EXP 46
15725: PUSH
15726: LD_EXP 46
15730: PPUSH
15731: CALL_OW 305
15735: AND
15736: IFFALSE 15750
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15738: LD_EXP 46
15742: PPUSH
15743: LD_STRING DEnd-JMM-Gny-1
15745: PPUSH
15746: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15750: LD_EXP 22
15754: PUSH
15755: LD_EXP 22
15759: PPUSH
15760: CALL_OW 255
15764: PUSH
15765: LD_INT 7
15767: EQUAL
15768: AND
15769: PUSH
15770: LD_EXP 22
15774: PPUSH
15775: CALL_OW 305
15779: AND
15780: IFFALSE 15794
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
15782: LD_EXP 22
15786: PPUSH
15787: LD_STRING DEnd-JMM-Corn-1
15789: PPUSH
15790: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
15794: LD_EXP 15
15798: PUSH
15799: LD_EXP 15
15803: PPUSH
15804: CALL_OW 255
15808: PUSH
15809: LD_INT 7
15811: EQUAL
15812: AND
15813: PUSH
15814: LD_EXP 15
15818: PPUSH
15819: CALL_OW 305
15823: AND
15824: IFFALSE 15838
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
15826: LD_EXP 15
15830: PPUSH
15831: LD_STRING DEnd-JMM-Don-1
15833: PPUSH
15834: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
15838: LD_EXP 16
15842: PUSH
15843: LD_EXP 16
15847: PPUSH
15848: CALL_OW 255
15852: PUSH
15853: LD_INT 7
15855: EQUAL
15856: AND
15857: PUSH
15858: LD_EXP 16
15862: PPUSH
15863: CALL_OW 305
15867: AND
15868: IFFALSE 15882
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
15870: LD_EXP 16
15874: PPUSH
15875: LD_STRING DEnd-JMM-Bobby-1
15877: PPUSH
15878: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
15882: LD_EXP 18
15886: PUSH
15887: LD_EXP 18
15891: PPUSH
15892: CALL_OW 255
15896: PUSH
15897: LD_INT 7
15899: EQUAL
15900: AND
15901: PUSH
15902: LD_EXP 18
15906: PPUSH
15907: CALL_OW 305
15911: AND
15912: IFFALSE 15926
// Say ( Denis , DEnd-JMM-Den-1 ) ;
15914: LD_EXP 18
15918: PPUSH
15919: LD_STRING DEnd-JMM-Den-1
15921: PPUSH
15922: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
15926: LD_EXP 20
15930: PUSH
15931: LD_EXP 20
15935: PPUSH
15936: CALL_OW 255
15940: PUSH
15941: LD_INT 7
15943: EQUAL
15944: AND
15945: PUSH
15946: LD_EXP 20
15950: PPUSH
15951: CALL_OW 305
15955: AND
15956: IFFALSE 15970
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
15958: LD_EXP 20
15962: PPUSH
15963: LD_STRING DEnd-JMM-Glad-1
15965: PPUSH
15966: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
15970: LD_EXP 25
15974: PUSH
15975: LD_EXP 25
15979: PPUSH
15980: CALL_OW 255
15984: PUSH
15985: LD_INT 7
15987: EQUAL
15988: AND
15989: PUSH
15990: LD_EXP 25
15994: PPUSH
15995: CALL_OW 305
15999: AND
16000: IFFALSE 16014
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16002: LD_EXP 25
16006: PPUSH
16007: LD_STRING DEnd-JMM-Yam-1
16009: PPUSH
16010: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16014: LD_EXP 19
16018: PUSH
16019: LD_EXP 19
16023: PPUSH
16024: CALL_OW 255
16028: PUSH
16029: LD_INT 7
16031: EQUAL
16032: AND
16033: PUSH
16034: LD_EXP 19
16038: PPUSH
16039: CALL_OW 305
16043: AND
16044: IFFALSE 16058
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16046: LD_EXP 19
16050: PPUSH
16051: LD_STRING DEnd-JMM-Brown-1
16053: PPUSH
16054: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16058: LD_EXP 29
16062: PUSH
16063: LD_EXP 29
16067: PPUSH
16068: CALL_OW 255
16072: PUSH
16073: LD_INT 7
16075: EQUAL
16076: AND
16077: PUSH
16078: LD_EXP 29
16082: PPUSH
16083: CALL_OW 305
16087: AND
16088: IFFALSE 16102
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16090: LD_EXP 29
16094: PPUSH
16095: LD_STRING DEnd-JMM-Con-1
16097: PPUSH
16098: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16102: LD_EXP 23
16106: PUSH
16107: LD_EXP 23
16111: PPUSH
16112: CALL_OW 255
16116: PUSH
16117: LD_INT 7
16119: EQUAL
16120: AND
16121: PUSH
16122: LD_EXP 23
16126: PPUSH
16127: CALL_OW 305
16131: AND
16132: IFFALSE 16146
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16134: LD_EXP 23
16138: PPUSH
16139: LD_STRING DEnd-JMM-Gary-1
16141: PPUSH
16142: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16146: LD_EXP 26
16150: PUSH
16151: LD_EXP 13
16155: AND
16156: PUSH
16157: LD_EXP 26
16161: PPUSH
16162: CALL_OW 305
16166: AND
16167: IFFALSE 16181
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16169: LD_EXP 26
16173: PPUSH
16174: LD_STRING DEnd-JMM-Sim-1
16176: PPUSH
16177: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16181: LD_EXP 21
16185: PUSH
16186: LD_EXP 21
16190: PPUSH
16191: CALL_OW 255
16195: PUSH
16196: LD_INT 7
16198: EQUAL
16199: AND
16200: PUSH
16201: LD_EXP 21
16205: PPUSH
16206: CALL_OW 305
16210: AND
16211: IFFALSE 16225
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16213: LD_EXP 21
16217: PPUSH
16218: LD_STRING DEnd-JMM-VanH-1
16220: PPUSH
16221: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16225: LD_EXP 34
16229: PUSH
16230: LD_EXP 34
16234: PPUSH
16235: CALL_OW 305
16239: AND
16240: IFFALSE 16254
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16242: LD_EXP 34
16246: PPUSH
16247: LD_STRING DEnd-JMM-Dol-1
16249: PPUSH
16250: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16254: LD_EXP 38
16258: PUSH
16259: LD_EXP 38
16263: PPUSH
16264: CALL_OW 305
16268: AND
16269: IFFALSE 16283
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16271: LD_EXP 38
16275: PPUSH
16276: LD_STRING DEnd-JMM-Kap-1
16278: PPUSH
16279: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16283: LD_EXP 41
16287: PUSH
16288: LD_EXP 41
16292: PPUSH
16293: CALL_OW 305
16297: AND
16298: IFFALSE 16312
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16300: LD_EXP 41
16304: PPUSH
16305: LD_STRING DEnd-JMM-Kov-1
16307: PPUSH
16308: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16312: LD_EXP 36
16316: PUSH
16317: LD_EXP 36
16321: PPUSH
16322: CALL_OW 305
16326: AND
16327: IFFALSE 16341
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16329: LD_EXP 36
16333: PPUSH
16334: LD_STRING DEnd-JMM-Sch-1
16336: PPUSH
16337: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16341: LD_EXP 32
16345: PUSH
16346: LD_EXP 32
16350: PPUSH
16351: CALL_OW 305
16355: AND
16356: IFFALSE 16370
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16358: LD_EXP 32
16362: PPUSH
16363: LD_STRING DEnd-JMM-Tit-1
16365: PPUSH
16366: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16370: LD_EXP 37
16374: PUSH
16375: LD_EXP 37
16379: PPUSH
16380: CALL_OW 305
16384: AND
16385: IFFALSE 16399
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16387: LD_EXP 37
16391: PPUSH
16392: LD_STRING DEnd-JMM-Obl-1
16394: PPUSH
16395: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16399: LD_EXP 39
16403: PUSH
16404: LD_EXP 39
16408: PPUSH
16409: CALL_OW 305
16413: AND
16414: IFFALSE 16428
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16416: LD_EXP 39
16420: PPUSH
16421: LD_STRING DEnd-JMM-Lip-1
16423: PPUSH
16424: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16428: LD_EXP 33
16432: PUSH
16433: LD_EXP 33
16437: PPUSH
16438: CALL_OW 305
16442: AND
16443: PUSH
16444: LD_EXP 44
16448: AND
16449: IFFALSE 16463
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16451: LD_EXP 33
16455: PPUSH
16456: LD_STRING DEnd-Burlak-Fad-1
16458: PPUSH
16459: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16463: LD_EXP 40
16467: PUSH
16468: LD_EXP 40
16472: PPUSH
16473: CALL_OW 305
16477: AND
16478: IFFALSE 16492
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16480: LD_EXP 40
16484: PPUSH
16485: LD_STRING DEnd-Burlak-Ptr-1
16487: PPUSH
16488: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16492: LD_EXP 42
16496: PUSH
16497: LD_EXP 42
16501: PPUSH
16502: CALL_OW 305
16506: AND
16507: IFFALSE 16521
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16509: LD_EXP 42
16513: PPUSH
16514: LD_STRING DEnd-Burlak-Kuz-1
16516: PPUSH
16517: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16521: LD_EXP 31
16525: PUSH
16526: LD_EXP 31
16530: PPUSH
16531: CALL_OW 305
16535: AND
16536: PUSH
16537: LD_EXP 44
16541: AND
16542: IFFALSE 16556
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16544: LD_EXP 31
16548: PPUSH
16549: LD_STRING DEnd-Burlak-Kir-1
16551: PPUSH
16552: CALL_OW 88
// if Burlak then
16556: LD_EXP 44
16560: IFFALSE 16574
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16562: LD_EXP 12
16566: PPUSH
16567: LD_STRING DEnd-Burlak-JMM-1
16569: PPUSH
16570: CALL_OW 88
// dwait ( 0 0$2 ) ;
16574: LD_INT 70
16576: PPUSH
16577: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16581: LD_EXP 49
16585: PPUSH
16586: LD_STRING DEnd-Szulc
16588: PPUSH
16589: CALL_OW 94
// dwait ( 0 0$1 ) ;
16593: LD_INT 35
16595: PPUSH
16596: CALL_OW 68
// if IsLive ( Burlak ) then
16600: LD_EXP 44
16604: PPUSH
16605: CALL_OW 300
16609: IFFALSE 16621
// med1 := 1 else
16611: LD_ADDR_VAR 0 1
16615: PUSH
16616: LD_INT 1
16618: ST_TO_ADDR
16619: GO 16630
// med1 := - 1 ;
16621: LD_ADDR_VAR 0 1
16625: PUSH
16626: LD_INT 1
16628: NEG
16629: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16630: LD_EXP 9
16634: PUSH
16635: LD_EXP 10
16639: AND
16640: PUSH
16641: LD_EXP 11
16645: AND
16646: IFFALSE 16658
// med2 := 1 else
16648: LD_ADDR_VAR 0 2
16652: PUSH
16653: LD_INT 1
16655: ST_TO_ADDR
16656: GO 16667
// med2 := - 1 ;
16658: LD_ADDR_VAR 0 2
16662: PUSH
16663: LD_INT 1
16665: NEG
16666: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
16667: LD_STRING Hero
16669: PPUSH
16670: LD_INT 1
16672: PPUSH
16673: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
16677: LD_STRING Artefact
16679: PPUSH
16680: LD_VAR 0 2
16684: PPUSH
16685: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
16689: LD_STRING ReconcileBurlak
16691: PPUSH
16692: LD_VAR 0 1
16696: PPUSH
16697: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
16701: LD_OWVAR 67
16705: PUSH
16706: LD_INT 3
16708: EQUAL
16709: PUSH
16710: LD_VAR 0 1
16714: PUSH
16715: LD_INT 1
16717: EQUAL
16718: AND
16719: PUSH
16720: LD_VAR 0 2
16724: PUSH
16725: LD_INT 1
16727: EQUAL
16728: AND
16729: IFFALSE 16741
// SetAchievementEX ( ACH_AMER , 19 ) ;
16731: LD_STRING ACH_AMER
16733: PPUSH
16734: LD_INT 19
16736: PPUSH
16737: CALL_OW 564
// GiveMedals ( MAIN ) ;
16741: LD_STRING MAIN
16743: PPUSH
16744: CALL_OW 102
// InGameOff ;
16748: CALL_OW 9
// DialogueOff ;
16752: CALL_OW 7
// music_nat := 1 ;
16756: LD_ADDR_OWVAR 71
16760: PUSH
16761: LD_INT 1
16763: ST_TO_ADDR
// music_class := 4 ;
16764: LD_ADDR_OWVAR 72
16768: PUSH
16769: LD_INT 4
16771: ST_TO_ADDR
// YouWin ;
16772: CALL_OW 103
// end ; end_of_file
16776: PPOPN 2
16778: END
// export function InitNature ; begin
16779: LD_INT 0
16781: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
16782: LD_INT 3
16784: PPUSH
16785: LD_INT 3
16787: PPUSH
16788: LD_INT 2
16790: PPUSH
16791: LD_INT 1
16793: PPUSH
16794: LD_INT 1
16796: PPUSH
16797: LD_INT 0
16799: PPUSH
16800: LD_INT 0
16802: PPUSH
16803: LD_INT 17
16805: PPUSH
16806: LD_INT 0
16808: PPUSH
16809: CALL 85090 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
16813: LD_INT 2
16815: PPUSH
16816: LD_INT 1
16818: PPUSH
16819: LD_INT 1
16821: PPUSH
16822: LD_INT 1
16824: PPUSH
16825: LD_INT 1
16827: PPUSH
16828: LD_INT 0
16830: PPUSH
16831: LD_INT 0
16833: PPUSH
16834: LD_INT 18
16836: PPUSH
16837: LD_INT 0
16839: PPUSH
16840: CALL 85090 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
16844: LD_INT 4
16846: PPUSH
16847: LD_INT 1
16849: PPUSH
16850: LD_INT 2
16852: PPUSH
16853: LD_INT 4
16855: PPUSH
16856: LD_INT 2
16858: PPUSH
16859: LD_INT 1
16861: PPUSH
16862: LD_INT 0
16864: PPUSH
16865: LD_INT 19
16867: PPUSH
16868: LD_INT 0
16870: PPUSH
16871: CALL 85090 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
16875: LD_INT 0
16877: PPUSH
16878: LD_INT 0
16880: PPUSH
16881: LD_INT 0
16883: PPUSH
16884: LD_INT 0
16886: PPUSH
16887: LD_INT 0
16889: PPUSH
16890: LD_INT 0
16892: PPUSH
16893: LD_INT 9
16895: PPUSH
16896: LD_INT 0
16898: PPUSH
16899: LD_INT 20
16901: PPUSH
16902: CALL 85090 0 9
// end ; end_of_file
16906: LD_VAR 0 1
16910: RET
// every 0 0$30 do var time ;
16911: GO 16913
16913: DISABLE
16914: LD_INT 0
16916: PPUSH
// begin time := 0 0$50 ;
16917: LD_ADDR_VAR 0 1
16921: PUSH
16922: LD_INT 1750
16924: ST_TO_ADDR
// repeat wait ( time ) ;
16925: LD_VAR 0 1
16929: PPUSH
16930: CALL_OW 67
// if Prob ( 50 ) then
16934: LD_INT 50
16936: PPUSH
16937: CALL_OW 13
16941: IFFALSE 16970
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
16943: LD_INT 1
16945: PPUSH
16946: LD_INT 5
16948: PPUSH
16949: CALL_OW 12
16953: PPUSH
16954: LD_INT 106
16956: PPUSH
16957: LD_INT 89
16959: PPUSH
16960: LD_INT 45
16962: PPUSH
16963: LD_INT 1
16965: PPUSH
16966: CALL_OW 56
// time := time + 0 0$3 ;
16970: LD_ADDR_VAR 0 1
16974: PUSH
16975: LD_VAR 0 1
16979: PUSH
16980: LD_INT 105
16982: PLUS
16983: ST_TO_ADDR
// if Prob ( 30 ) then
16984: LD_INT 30
16986: PPUSH
16987: CALL_OW 13
16991: IFFALSE 17037
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
16993: LD_INT 525
16995: PPUSH
16996: LD_INT 735
16998: PPUSH
16999: CALL_OW 12
17003: PPUSH
17004: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17008: LD_INT 1
17010: PPUSH
17011: LD_INT 5
17013: PPUSH
17014: CALL_OW 12
17018: PPUSH
17019: LD_INT 21
17021: PPUSH
17022: LD_INT 26
17024: PPUSH
17025: LD_INT 12
17027: PPUSH
17028: LD_INT 1
17030: PPUSH
17031: CALL_OW 56
// end else
17035: GO 17073
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17037: LD_INT 700
17039: PPUSH
17040: LD_INT 1225
17042: PPUSH
17043: CALL_OW 12
17047: PPUSH
17048: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17052: LD_INT 1
17054: PPUSH
17055: LD_INT 5
17057: PPUSH
17058: CALL_OW 12
17062: PPUSH
17063: LD_INT 14
17065: PPUSH
17066: LD_INT 1
17068: PPUSH
17069: CALL_OW 55
// end ; if Prob ( 50 ) then
17073: LD_INT 50
17075: PPUSH
17076: CALL_OW 13
17080: IFFALSE 17126
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17082: LD_INT 700
17084: PPUSH
17085: LD_INT 1050
17087: PPUSH
17088: CALL_OW 12
17092: PPUSH
17093: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17097: LD_INT 1
17099: PPUSH
17100: LD_INT 5
17102: PPUSH
17103: CALL_OW 12
17107: PPUSH
17108: LD_INT 181
17110: PPUSH
17111: LD_INT 218
17113: PPUSH
17114: LD_INT 16
17116: PPUSH
17117: LD_INT 1
17119: PPUSH
17120: CALL_OW 56
// end else
17124: GO 17198
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17126: LD_INT 350
17128: PPUSH
17129: LD_INT 525
17131: PPUSH
17132: CALL_OW 12
17136: PPUSH
17137: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17141: LD_INT 1
17143: PPUSH
17144: LD_INT 5
17146: PPUSH
17147: CALL_OW 12
17151: PPUSH
17152: LD_INT 13
17154: PPUSH
17155: LD_INT 1
17157: PPUSH
17158: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17162: LD_INT 350
17164: PPUSH
17165: LD_INT 700
17167: PPUSH
17168: CALL_OW 12
17172: PPUSH
17173: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17177: LD_INT 1
17179: PPUSH
17180: LD_INT 5
17182: PPUSH
17183: CALL_OW 12
17187: PPUSH
17188: LD_INT 33
17190: PPUSH
17191: LD_INT 1
17193: PPUSH
17194: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17198: LD_INT 65
17200: PUSH
17201: LD_INT 62
17203: PUSH
17204: LD_INT 55
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: LIST
17211: PUSH
17212: LD_OWVAR 67
17216: ARRAY
17217: PPUSH
17218: CALL_OW 13
17222: IFFALSE 17268
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17224: LD_INT 525
17226: PPUSH
17227: LD_INT 875
17229: PPUSH
17230: CALL_OW 12
17234: PPUSH
17235: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17239: LD_INT 1
17241: PPUSH
17242: LD_INT 5
17244: PPUSH
17245: CALL_OW 12
17249: PPUSH
17250: LD_INT 294
17252: PPUSH
17253: LD_INT 211
17255: PPUSH
17256: LD_INT 30
17258: PPUSH
17259: LD_INT 1
17261: PPUSH
17262: CALL_OW 56
// end else
17266: GO 17310
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17268: LD_INT 420
17270: PPUSH
17271: LD_INT 770
17273: PPUSH
17274: CALL_OW 12
17278: PPUSH
17279: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17283: LD_INT 1
17285: PPUSH
17286: LD_INT 5
17288: PPUSH
17289: CALL_OW 12
17293: PPUSH
17294: LD_INT 294
17296: PPUSH
17297: LD_INT 211
17299: PPUSH
17300: LD_INT 30
17302: PPUSH
17303: LD_INT 1
17305: PPUSH
17306: CALL_OW 56
// end ; if time > 2 2$20 then
17310: LD_VAR 0 1
17314: PUSH
17315: LD_INT 4900
17317: GREATER
17318: IFFALSE 17328
// time := 0 0$50 ;
17320: LD_ADDR_VAR 0 1
17324: PUSH
17325: LD_INT 1750
17327: ST_TO_ADDR
// until false ;
17328: LD_INT 0
17330: IFFALSE 16925
// end ;
17332: PPOPN 1
17334: END
// every 0 0$45 trigger tick < 10 10$00 do
17335: LD_OWVAR 1
17339: PUSH
17340: LD_INT 21000
17342: LESS
17343: IFFALSE 17391
17345: GO 17347
17347: DISABLE
// begin enable ;
17348: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17349: LD_INT 350
17351: PPUSH
17352: LD_INT 700
17354: PPUSH
17355: CALL_OW 12
17359: PPUSH
17360: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17364: LD_INT 3
17366: PPUSH
17367: LD_INT 5
17369: PPUSH
17370: CALL_OW 12
17374: PPUSH
17375: LD_INT 181
17377: PPUSH
17378: LD_INT 13
17380: PPUSH
17381: LD_INT 20
17383: PPUSH
17384: LD_INT 1
17386: PPUSH
17387: CALL_OW 56
// end ; end_of_file
17391: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17392: LD_INT 0
17394: PPUSH
// SetArtifactRes ( 7 , true ) ;
17395: LD_INT 7
17397: PPUSH
17398: LD_INT 1
17400: PPUSH
17401: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17405: LD_ADDR_EXP 57
17409: PUSH
17410: EMPTY
17411: PUSH
17412: EMPTY
17413: PUSH
17414: EMPTY
17415: PUSH
17416: EMPTY
17417: LIST
17418: LIST
17419: LIST
17420: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17421: LD_ADDR_EXP 58
17425: PUSH
17426: LD_INT 1050
17428: PUSH
17429: LD_OWVAR 67
17433: MUL
17434: PUSH
17435: LD_INT 2800
17437: PUSH
17438: LD_OWVAR 67
17442: MUL
17443: PUSH
17444: LD_INT 1
17446: NEG
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: LIST
17452: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17453: LD_ADDR_EXP 59
17457: PUSH
17458: LD_INT 10
17460: PUSH
17461: LD_INT 35
17463: PUSH
17464: LD_INT 100
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17472: LD_ADDR_EXP 60
17476: PUSH
17477: LD_INT 0
17479: PUSH
17480: LD_INT 0
17482: PUSH
17483: LD_INT 0
17485: PUSH
17486: EMPTY
17487: LIST
17488: LIST
17489: LIST
17490: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17491: LD_ADDR_EXP 62
17495: PUSH
17496: LD_INT 300
17498: PUSH
17499: LD_INT 500
17501: PUSH
17502: LD_INT 800
17504: PUSH
17505: EMPTY
17506: LIST
17507: LIST
17508: LIST
17509: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17510: LD_ADDR_EXP 63
17514: PUSH
17515: LD_INT 0
17517: PUSH
17518: LD_INT 0
17520: PUSH
17521: LD_INT 0
17523: PUSH
17524: EMPTY
17525: LIST
17526: LIST
17527: LIST
17528: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17529: LD_ADDR_EXP 64
17533: PUSH
17534: LD_INT 0
17536: PUSH
17537: LD_INT 0
17539: PUSH
17540: LD_INT 0
17542: PUSH
17543: EMPTY
17544: LIST
17545: LIST
17546: LIST
17547: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17548: LD_ADDR_EXP 61
17552: PUSH
17553: LD_INT 0
17555: PUSH
17556: LD_INT 0
17558: PUSH
17559: LD_INT 0
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: LIST
17566: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17567: LD_ADDR_EXP 65
17571: PUSH
17572: LD_INT 4
17574: PUSH
17575: LD_INT 3
17577: PUSH
17578: LD_INT 1
17580: PUSH
17581: EMPTY
17582: LIST
17583: LIST
17584: LIST
17585: PUSH
17586: LD_INT 5
17588: PUSH
17589: LD_INT 4
17591: PUSH
17592: LD_INT 2
17594: PUSH
17595: EMPTY
17596: LIST
17597: LIST
17598: LIST
17599: PUSH
17600: LD_INT 6
17602: PUSH
17603: LD_INT 3
17605: PUSH
17606: LD_INT 3
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: LIST
17613: PUSH
17614: EMPTY
17615: LIST
17616: LIST
17617: LIST
17618: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17619: LD_ADDR_EXP 66
17623: PUSH
17624: LD_INT 0
17626: PUSH
17627: LD_INT 0
17629: PUSH
17630: LD_INT 0
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: LIST
17637: ST_TO_ADDR
// end ;
17638: LD_VAR 0 1
17642: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17643: LD_INT 24
17645: PPUSH
17646: LD_INT 7
17648: PPUSH
17649: CALL_OW 321
17653: PUSH
17654: LD_INT 2
17656: EQUAL
17657: IFFALSE 18583
17659: GO 17661
17661: DISABLE
17662: LD_INT 0
17664: PPUSH
17665: PPUSH
17666: PPUSH
17667: PPUSH
17668: PPUSH
// begin enable ;
17669: ENABLE
// for i = 1 to 3 do
17670: LD_ADDR_VAR 0 1
17674: PUSH
17675: DOUBLE
17676: LD_INT 1
17678: DEC
17679: ST_TO_ADDR
17680: LD_INT 3
17682: PUSH
17683: FOR_TO
17684: IFFALSE 18581
// begin pos := FindArtifact ( i + 2 ) ;
17686: LD_ADDR_VAR 0 2
17690: PUSH
17691: LD_VAR 0 1
17695: PUSH
17696: LD_INT 2
17698: PLUS
17699: PPUSH
17700: CALL_OW 469
17704: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17705: LD_ADDR_EXP 57
17709: PUSH
17710: LD_EXP 57
17714: PPUSH
17715: LD_VAR 0 1
17719: PPUSH
17720: LD_VAR 0 2
17724: PPUSH
17725: CALL_OW 1
17729: ST_TO_ADDR
// if pos then
17730: LD_VAR 0 2
17734: IFFALSE 18442
// begin case i of 1 :
17736: LD_VAR 0 1
17740: PUSH
17741: LD_INT 1
17743: DOUBLE
17744: EQUAL
17745: IFTRUE 17749
17747: GO 17826
17749: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17750: LD_ADDR_VAR 0 4
17754: PUSH
17755: LD_INT 22
17757: PUSH
17758: LD_INT 7
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: PUSH
17765: LD_INT 23
17767: PUSH
17768: LD_INT 1
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: LD_INT 2
17777: PUSH
17778: LD_INT 30
17780: PUSH
17781: LD_INT 8
17783: PUSH
17784: EMPTY
17785: LIST
17786: LIST
17787: PUSH
17788: LD_INT 30
17790: PUSH
17791: LD_INT 7
17793: PUSH
17794: EMPTY
17795: LIST
17796: LIST
17797: PUSH
17798: LD_INT 30
17800: PUSH
17801: LD_INT 11
17803: PUSH
17804: EMPTY
17805: LIST
17806: LIST
17807: PUSH
17808: EMPTY
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: PUSH
17814: EMPTY
17815: LIST
17816: LIST
17817: LIST
17818: PPUSH
17819: CALL_OW 69
17823: ST_TO_ADDR
17824: GO 17934
17826: LD_INT 2
17828: DOUBLE
17829: EQUAL
17830: IFTRUE 17834
17832: GO 17911
17834: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
17835: LD_ADDR_VAR 0 4
17839: PUSH
17840: LD_INT 22
17842: PUSH
17843: LD_INT 7
17845: PUSH
17846: EMPTY
17847: LIST
17848: LIST
17849: PUSH
17850: LD_INT 23
17852: PUSH
17853: LD_INT 3
17855: PUSH
17856: EMPTY
17857: LIST
17858: LIST
17859: PUSH
17860: LD_INT 2
17862: PUSH
17863: LD_INT 30
17865: PUSH
17866: LD_INT 8
17868: PUSH
17869: EMPTY
17870: LIST
17871: LIST
17872: PUSH
17873: LD_INT 30
17875: PUSH
17876: LD_INT 7
17878: PUSH
17879: EMPTY
17880: LIST
17881: LIST
17882: PUSH
17883: LD_INT 30
17885: PUSH
17886: LD_INT 11
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: PUSH
17899: EMPTY
17900: LIST
17901: LIST
17902: LIST
17903: PPUSH
17904: CALL_OW 69
17908: ST_TO_ADDR
17909: GO 17934
17911: LD_INT 3
17913: DOUBLE
17914: EQUAL
17915: IFTRUE 17919
17917: GO 17933
17919: POP
// labs := [ alien ] ; end ;
17920: LD_ADDR_VAR 0 4
17924: PUSH
17925: LD_INT 1
17927: PUSH
17928: EMPTY
17929: LIST
17930: ST_TO_ADDR
17931: GO 17934
17933: POP
// if not labs then
17934: LD_VAR 0 4
17938: NOT
17939: IFFALSE 17943
// continue ;
17941: GO 17683
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
17943: LD_ADDR_VAR 0 5
17947: PUSH
17948: LD_VAR 0 4
17952: PPUSH
17953: LD_EXP 57
17957: PUSH
17958: LD_VAR 0 1
17962: ARRAY
17963: PUSH
17964: LD_INT 1
17966: ARRAY
17967: PPUSH
17968: LD_EXP 57
17972: PUSH
17973: LD_VAR 0 1
17977: ARRAY
17978: PUSH
17979: LD_INT 2
17981: ARRAY
17982: PPUSH
17983: CALL_OW 73
17987: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
17988: LD_VAR 0 5
17992: NOT
17993: PUSH
17994: LD_VAR 0 5
17998: PUSH
17999: LD_EXP 64
18003: PUSH
18004: LD_VAR 0 1
18008: ARRAY
18009: NONEQUAL
18010: OR
18011: IFFALSE 18116
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18013: LD_INT 7
18015: PPUSH
18016: LD_EXP 65
18020: PUSH
18021: LD_VAR 0 1
18025: ARRAY
18026: PUSH
18027: LD_INT 3
18029: ARRAY
18030: PPUSH
18031: LD_INT 0
18033: PPUSH
18034: LD_EXP 64
18038: PUSH
18039: LD_VAR 0 1
18043: ARRAY
18044: PPUSH
18045: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18049: LD_INT 7
18051: PPUSH
18052: LD_EXP 65
18056: PUSH
18057: LD_VAR 0 1
18061: ARRAY
18062: PUSH
18063: LD_INT 1
18065: ARRAY
18066: PPUSH
18067: LD_INT 0
18069: PPUSH
18070: LD_EXP 64
18074: PUSH
18075: LD_VAR 0 1
18079: ARRAY
18080: PPUSH
18081: CALL_OW 468
// if nearestLab then
18085: LD_VAR 0 5
18089: IFFALSE 18116
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18091: LD_ADDR_EXP 64
18095: PUSH
18096: LD_EXP 64
18100: PPUSH
18101: LD_VAR 0 1
18105: PPUSH
18106: LD_VAR 0 5
18110: PPUSH
18111: CALL_OW 1
18115: ST_TO_ADDR
// end ; if not nearestLab then
18116: LD_VAR 0 5
18120: NOT
18121: IFFALSE 18125
// continue ;
18123: GO 17683
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18125: LD_VAR 0 5
18129: PPUSH
18130: LD_EXP 57
18134: PUSH
18135: LD_VAR 0 1
18139: ARRAY
18140: PUSH
18141: LD_INT 1
18143: ARRAY
18144: PPUSH
18145: LD_EXP 57
18149: PUSH
18150: LD_VAR 0 1
18154: ARRAY
18155: PUSH
18156: LD_INT 2
18158: ARRAY
18159: PPUSH
18160: CALL_OW 297
18164: PUSH
18165: LD_INT 8
18167: LESS
18168: IFFALSE 18365
// begin if not artifactsResearched [ i ] then
18170: LD_EXP 60
18174: PUSH
18175: LD_VAR 0 1
18179: ARRAY
18180: NOT
18181: IFFALSE 18262
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18183: LD_VAR 0 5
18187: PPUSH
18188: CALL_OW 461
18192: PUSH
18193: LD_INT 2
18195: EQUAL
18196: IFFALSE 18230
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18198: LD_INT 7
18200: PPUSH
18201: LD_EXP 65
18205: PUSH
18206: LD_VAR 0 1
18210: ARRAY
18211: PUSH
18212: LD_INT 3
18214: ARRAY
18215: PPUSH
18216: LD_INT 2
18218: PPUSH
18219: LD_VAR 0 5
18223: PPUSH
18224: CALL_OW 468
18228: GO 18260
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18230: LD_INT 7
18232: PPUSH
18233: LD_EXP 65
18237: PUSH
18238: LD_VAR 0 1
18242: ARRAY
18243: PUSH
18244: LD_INT 3
18246: ARRAY
18247: PPUSH
18248: LD_INT 1
18250: PPUSH
18251: LD_VAR 0 5
18255: PPUSH
18256: CALL_OW 468
// end else
18260: GO 18363
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18262: LD_VAR 0 5
18266: PPUSH
18267: CALL_OW 461
18271: PUSH
18272: LD_INT 2
18274: EQUAL
18275: PUSH
18276: LD_EXP 66
18280: PUSH
18281: LD_VAR 0 1
18285: ARRAY
18286: AND
18287: IFFALSE 18333
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18289: LD_INT 7
18291: PPUSH
18292: LD_EXP 65
18296: PUSH
18297: LD_VAR 0 1
18301: ARRAY
18302: PUSH
18303: LD_INT 1
18305: ARRAY
18306: PPUSH
18307: LD_EXP 65
18311: PUSH
18312: LD_VAR 0 1
18316: ARRAY
18317: PUSH
18318: LD_INT 2
18320: ARRAY
18321: PPUSH
18322: LD_VAR 0 5
18326: PPUSH
18327: CALL_OW 468
18331: GO 18363
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18333: LD_INT 7
18335: PPUSH
18336: LD_EXP 65
18340: PUSH
18341: LD_VAR 0 1
18345: ARRAY
18346: PUSH
18347: LD_INT 1
18349: ARRAY
18350: PPUSH
18351: LD_INT 1
18353: PPUSH
18354: LD_VAR 0 5
18358: PPUSH
18359: CALL_OW 468
// end else
18363: GO 18440
// begin if not artifactsResearched [ i ] then
18365: LD_EXP 60
18369: PUSH
18370: LD_VAR 0 1
18374: ARRAY
18375: NOT
18376: IFFALSE 18410
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18378: LD_INT 7
18380: PPUSH
18381: LD_EXP 65
18385: PUSH
18386: LD_VAR 0 1
18390: ARRAY
18391: PUSH
18392: LD_INT 3
18394: ARRAY
18395: PPUSH
18396: LD_INT 0
18398: PPUSH
18399: LD_VAR 0 5
18403: PPUSH
18404: CALL_OW 468
18408: GO 18440
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18410: LD_INT 7
18412: PPUSH
18413: LD_EXP 65
18417: PUSH
18418: LD_VAR 0 1
18422: ARRAY
18423: PUSH
18424: LD_INT 1
18426: ARRAY
18427: PPUSH
18428: LD_INT 0
18430: PPUSH
18431: LD_VAR 0 5
18435: PPUSH
18436: CALL_OW 468
// end ; end else
18440: GO 18579
// begin if not artifactsLabs [ i ] then
18442: LD_EXP 64
18446: PUSH
18447: LD_VAR 0 1
18451: ARRAY
18452: NOT
18453: IFFALSE 18457
// continue ;
18455: GO 17683
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18457: LD_INT 7
18459: PPUSH
18460: LD_EXP 65
18464: PUSH
18465: LD_VAR 0 1
18469: ARRAY
18470: PUSH
18471: LD_INT 3
18473: ARRAY
18474: PPUSH
18475: LD_INT 0
18477: PPUSH
18478: LD_EXP 64
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: PPUSH
18489: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18493: LD_INT 7
18495: PPUSH
18496: LD_EXP 65
18500: PUSH
18501: LD_VAR 0 1
18505: ARRAY
18506: PUSH
18507: LD_INT 1
18509: ARRAY
18510: PPUSH
18511: LD_INT 0
18513: PPUSH
18514: LD_EXP 64
18518: PUSH
18519: LD_VAR 0 1
18523: ARRAY
18524: PPUSH
18525: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18529: LD_EXP 61
18533: PUSH
18534: LD_VAR 0 1
18538: ARRAY
18539: IFFALSE 18579
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18541: LD_ADDR_EXP 61
18545: PUSH
18546: LD_EXP 61
18550: PPUSH
18551: LD_VAR 0 1
18555: PPUSH
18556: LD_INT 0
18558: PPUSH
18559: CALL_OW 1
18563: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18564: LD_EXP 64
18568: PUSH
18569: LD_VAR 0 1
18573: ARRAY
18574: PPUSH
18575: CALL_OW 127
// end ; end ; end ;
18579: GO 17683
18581: POP
18582: POP
// end ;
18583: PPOPN 5
18585: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18586: LD_INT 0
18588: PPUSH
18589: PPUSH
18590: PPUSH
18591: PPUSH
18592: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18593: LD_VAR 0 2
18597: PUSH
18598: LD_EXP 65
18602: PUSH
18603: LD_INT 1
18605: ARRAY
18606: PUSH
18607: LD_INT 3
18609: ARRAY
18610: EQUAL
18611: IFFALSE 18734
// begin lab := artifactsLabs [ 1 ] ;
18613: LD_ADDR_VAR 0 6
18617: PUSH
18618: LD_EXP 64
18622: PUSH
18623: LD_INT 1
18625: ARRAY
18626: ST_TO_ADDR
// if not lab then
18627: LD_VAR 0 6
18631: NOT
18632: IFFALSE 18636
// exit ;
18634: GO 19668
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18636: LD_VAR 0 6
18640: PPUSH
18641: LD_EXP 62
18645: PUSH
18646: LD_INT 1
18648: ARRAY
18649: PPUSH
18650: LD_INT 1
18652: PPUSH
18653: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18657: LD_EXP 63
18661: PUSH
18662: LD_INT 1
18664: ARRAY
18665: IFFALSE 18685
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18667: LD_VAR 0 6
18671: PPUSH
18672: LD_EXP 63
18676: PUSH
18677: LD_INT 1
18679: ARRAY
18680: PPUSH
18681: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18685: LD_ADDR_EXP 61
18689: PUSH
18690: LD_EXP 61
18694: PPUSH
18695: LD_INT 1
18697: PPUSH
18698: LD_INT 1
18700: PPUSH
18701: CALL_OW 1
18705: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18706: LD_INT 7
18708: PPUSH
18709: LD_EXP 65
18713: PUSH
18714: LD_INT 1
18716: ARRAY
18717: PUSH
18718: LD_INT 3
18720: ARRAY
18721: PPUSH
18722: LD_INT 0
18724: PPUSH
18725: LD_VAR 0 6
18729: PPUSH
18730: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18734: LD_VAR 0 2
18738: PUSH
18739: LD_EXP 65
18743: PUSH
18744: LD_INT 2
18746: ARRAY
18747: PUSH
18748: LD_INT 3
18750: ARRAY
18751: EQUAL
18752: IFFALSE 18875
// begin lab := artifactsLabs [ 2 ] ;
18754: LD_ADDR_VAR 0 6
18758: PUSH
18759: LD_EXP 64
18763: PUSH
18764: LD_INT 2
18766: ARRAY
18767: ST_TO_ADDR
// if not lab then
18768: LD_VAR 0 6
18772: NOT
18773: IFFALSE 18777
// exit ;
18775: GO 19668
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
18777: LD_VAR 0 6
18781: PPUSH
18782: LD_EXP 62
18786: PUSH
18787: LD_INT 2
18789: ARRAY
18790: PPUSH
18791: LD_INT 1
18793: PPUSH
18794: CALL_OW 486
// if artifactsResProgress [ 2 ] then
18798: LD_EXP 63
18802: PUSH
18803: LD_INT 2
18805: ARRAY
18806: IFFALSE 18826
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
18808: LD_VAR 0 6
18812: PPUSH
18813: LD_EXP 63
18817: PUSH
18818: LD_INT 2
18820: ARRAY
18821: PPUSH
18822: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
18826: LD_ADDR_EXP 61
18830: PUSH
18831: LD_EXP 61
18835: PPUSH
18836: LD_INT 2
18838: PPUSH
18839: LD_INT 1
18841: PPUSH
18842: CALL_OW 1
18846: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
18847: LD_INT 7
18849: PPUSH
18850: LD_EXP 65
18854: PUSH
18855: LD_INT 2
18857: ARRAY
18858: PUSH
18859: LD_INT 3
18861: ARRAY
18862: PPUSH
18863: LD_INT 0
18865: PPUSH
18866: LD_VAR 0 6
18870: PPUSH
18871: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
18875: LD_VAR 0 2
18879: PUSH
18880: LD_EXP 65
18884: PUSH
18885: LD_INT 3
18887: ARRAY
18888: PUSH
18889: LD_INT 3
18891: ARRAY
18892: EQUAL
18893: IFFALSE 19016
// begin lab := artifactsLabs [ 3 ] ;
18895: LD_ADDR_VAR 0 6
18899: PUSH
18900: LD_EXP 64
18904: PUSH
18905: LD_INT 3
18907: ARRAY
18908: ST_TO_ADDR
// if not lab then
18909: LD_VAR 0 6
18913: NOT
18914: IFFALSE 18918
// exit ;
18916: GO 19668
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
18918: LD_VAR 0 6
18922: PPUSH
18923: LD_EXP 62
18927: PUSH
18928: LD_INT 3
18930: ARRAY
18931: PPUSH
18932: LD_INT 1
18934: PPUSH
18935: CALL_OW 486
// if artifactsResProgress [ 3 ] then
18939: LD_EXP 63
18943: PUSH
18944: LD_INT 3
18946: ARRAY
18947: IFFALSE 18967
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
18949: LD_VAR 0 6
18953: PPUSH
18954: LD_EXP 63
18958: PUSH
18959: LD_INT 3
18961: ARRAY
18962: PPUSH
18963: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
18967: LD_ADDR_EXP 61
18971: PUSH
18972: LD_EXP 61
18976: PPUSH
18977: LD_INT 3
18979: PPUSH
18980: LD_INT 1
18982: PPUSH
18983: CALL_OW 1
18987: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
18988: LD_INT 7
18990: PPUSH
18991: LD_EXP 65
18995: PUSH
18996: LD_INT 3
18998: ARRAY
18999: PUSH
19000: LD_INT 3
19002: ARRAY
19003: PPUSH
19004: LD_INT 0
19006: PPUSH
19007: LD_VAR 0 6
19011: PPUSH
19012: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19016: LD_VAR 0 2
19020: PUSH
19021: LD_EXP 65
19025: PUSH
19026: LD_INT 1
19028: ARRAY
19029: PUSH
19030: LD_INT 1
19032: ARRAY
19033: EQUAL
19034: IFFALSE 19192
// begin lab := artifactsLabs [ 1 ] ;
19036: LD_ADDR_VAR 0 6
19040: PUSH
19041: LD_EXP 64
19045: PUSH
19046: LD_INT 1
19048: ARRAY
19049: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19050: LD_VAR 0 6
19054: PPUSH
19055: CALL_OW 274
19059: PPUSH
19060: CALL 93238 0 1
19064: PUSH
19065: LD_INT 3
19067: ARRAY
19068: PUSH
19069: LD_EXP 59
19073: PUSH
19074: LD_INT 1
19076: ARRAY
19077: LESS
19078: IFFALSE 19092
// begin HintSpec ( ArtifactCost , 2 ) ;
19080: LD_STRING ArtifactCost
19082: PPUSH
19083: LD_INT 2
19085: PPUSH
19086: CALL_OW 338
// exit ;
19090: GO 19668
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19092: LD_ADDR_EXP 66
19096: PUSH
19097: LD_EXP 66
19101: PPUSH
19102: LD_INT 1
19104: PPUSH
19105: LD_INT 0
19107: PPUSH
19108: CALL_OW 1
19112: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19113: LD_VAR 0 3
19117: PPUSH
19118: LD_VAR 0 4
19122: PPUSH
19123: LD_INT 7
19125: PPUSH
19126: LD_INT 12
19128: NEG
19129: PPUSH
19130: CALL_OW 330
// wait ( 0 0$30 ) ;
19134: LD_INT 1050
19136: PPUSH
19137: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19141: LD_VAR 0 3
19145: PPUSH
19146: LD_VAR 0 4
19150: PPUSH
19151: LD_INT 7
19153: PPUSH
19154: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19158: LD_EXP 58
19162: PUSH
19163: LD_INT 1
19165: ARRAY
19166: PPUSH
19167: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19171: LD_ADDR_EXP 66
19175: PUSH
19176: LD_EXP 66
19180: PPUSH
19181: LD_INT 1
19183: PPUSH
19184: LD_INT 1
19186: PPUSH
19187: CALL_OW 1
19191: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19192: LD_VAR 0 2
19196: PUSH
19197: LD_EXP 65
19201: PUSH
19202: LD_INT 2
19204: ARRAY
19205: PUSH
19206: LD_INT 1
19208: ARRAY
19209: EQUAL
19210: IFFALSE 19422
// begin lab := artifactsLabs [ 2 ] ;
19212: LD_ADDR_VAR 0 6
19216: PUSH
19217: LD_EXP 64
19221: PUSH
19222: LD_INT 2
19224: ARRAY
19225: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
19226: LD_VAR 0 3
19230: PUSH
19231: LD_INT 81
19233: PUSH
19234: LD_INT 7
19236: PUSH
19237: EMPTY
19238: LIST
19239: LIST
19240: PUSH
19241: LD_INT 2
19243: PUSH
19244: LD_INT 32
19246: PUSH
19247: LD_INT 3
19249: PUSH
19250: EMPTY
19251: LIST
19252: LIST
19253: PUSH
19254: LD_INT 30
19256: PUSH
19257: LD_INT 28
19259: PUSH
19260: EMPTY
19261: LIST
19262: LIST
19263: PUSH
19264: LD_INT 30
19266: PUSH
19267: LD_INT 30
19269: PUSH
19270: EMPTY
19271: LIST
19272: LIST
19273: PUSH
19274: LD_INT 35
19276: PUSH
19277: LD_INT 49
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: PUSH
19284: LD_INT 34
19286: PUSH
19287: LD_INT 49
19289: PUSH
19290: EMPTY
19291: LIST
19292: LIST
19293: PUSH
19294: EMPTY
19295: LIST
19296: LIST
19297: LIST
19298: LIST
19299: LIST
19300: LIST
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: PPUSH
19306: CALL_OW 69
19310: IN
19311: NOT
19312: IFFALSE 19316
// exit ;
19314: GO 19668
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19316: LD_VAR 0 6
19320: PPUSH
19321: CALL_OW 274
19325: PPUSH
19326: CALL 93238 0 1
19330: PUSH
19331: LD_INT 3
19333: ARRAY
19334: PUSH
19335: LD_EXP 59
19339: PUSH
19340: LD_INT 2
19342: ARRAY
19343: LESS
19344: IFFALSE 19358
// begin HintSpec ( ArtifactCost , 2 ) ;
19346: LD_STRING ArtifactCost
19348: PPUSH
19349: LD_INT 2
19351: PPUSH
19352: CALL_OW 338
// exit ;
19356: GO 19668
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19358: LD_ADDR_EXP 66
19362: PUSH
19363: LD_EXP 66
19367: PPUSH
19368: LD_INT 2
19370: PPUSH
19371: LD_INT 0
19373: PPUSH
19374: CALL_OW 1
19378: ST_TO_ADDR
// KillUnit ( x ) ;
19379: LD_VAR 0 3
19383: PPUSH
19384: CALL_OW 66
// wait ( artifactsRecharge [ 2 ] ) ;
19388: LD_EXP 58
19392: PUSH
19393: LD_INT 2
19395: ARRAY
19396: PPUSH
19397: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19401: LD_ADDR_EXP 66
19405: PUSH
19406: LD_EXP 66
19410: PPUSH
19411: LD_INT 2
19413: PPUSH
19414: LD_INT 1
19416: PPUSH
19417: CALL_OW 1
19421: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19422: LD_VAR 0 2
19426: PUSH
19427: LD_EXP 65
19431: PUSH
19432: LD_INT 3
19434: ARRAY
19435: PUSH
19436: LD_INT 1
19438: ARRAY
19439: EQUAL
19440: IFFALSE 19668
// begin lab := artifactsLabs [ 3 ] ;
19442: LD_ADDR_VAR 0 6
19446: PUSH
19447: LD_EXP 64
19451: PUSH
19452: LD_INT 3
19454: ARRAY
19455: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19456: LD_VAR 0 6
19460: PPUSH
19461: CALL_OW 274
19465: PPUSH
19466: CALL 93238 0 1
19470: PUSH
19471: LD_INT 3
19473: ARRAY
19474: PUSH
19475: LD_EXP 59
19479: PUSH
19480: LD_INT 3
19482: ARRAY
19483: LESS
19484: IFFALSE 19498
// begin HintSpec ( ArtifactCost , 2 ) ;
19486: LD_STRING ArtifactCost
19488: PPUSH
19489: LD_INT 2
19491: PPUSH
19492: CALL_OW 338
// exit ;
19496: GO 19668
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19498: LD_INT 37
19500: PPUSH
19501: LD_INT 1
19503: PPUSH
19504: CALL_OW 424
// time := 0 0$30 ;
19508: LD_ADDR_VAR 0 7
19512: PUSH
19513: LD_INT 1050
19515: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
19516: LD_ADDR_OWVAR 47
19520: PUSH
19521: LD_STRING Am15a-1
19523: PUSH
19524: LD_VAR 0 7
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19533: LD_INT 35
19535: PPUSH
19536: CALL_OW 67
// time := time - 0 0$1 ;
19540: LD_ADDR_VAR 0 7
19544: PUSH
19545: LD_VAR 0 7
19549: PUSH
19550: LD_INT 35
19552: MINUS
19553: ST_TO_ADDR
// until time = 0 0$00 ;
19554: LD_VAR 0 7
19558: PUSH
19559: LD_INT 0
19561: EQUAL
19562: IFFALSE 19516
// display_strings :=  ;
19564: LD_ADDR_OWVAR 47
19568: PUSH
19569: LD_STRING 
19571: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19572: LD_INT 37
19574: PPUSH
19575: LD_INT 0
19577: PPUSH
19578: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19582: LD_ADDR_VAR 0 8
19586: PUSH
19587: LD_INT 37
19589: PPUSH
19590: LD_INT 3
19592: PUSH
19593: LD_INT 21
19595: PUSH
19596: LD_INT 3
19598: PUSH
19599: EMPTY
19600: LIST
19601: LIST
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: PPUSH
19607: CALL_OW 70
19611: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19612: LD_VAR 0 3
19616: PPUSH
19617: LD_VAR 0 4
19621: PPUSH
19622: CALL_OW 84
// for un in list do
19626: LD_ADDR_VAR 0 9
19630: PUSH
19631: LD_VAR 0 8
19635: PUSH
19636: FOR_IN
19637: IFFALSE 19666
// TeleportUnit ( un , x , y , 12 , true ) ;
19639: LD_VAR 0 9
19643: PPUSH
19644: LD_VAR 0 3
19648: PPUSH
19649: LD_VAR 0 4
19653: PPUSH
19654: LD_INT 12
19656: PPUSH
19657: LD_INT 1
19659: PPUSH
19660: CALL_OW 483
19664: GO 19636
19666: POP
19667: POP
// end ; end ;
19668: PPOPN 9
19670: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19671: LD_INT 0
19673: PPUSH
19674: PPUSH
// begin labNum := 0 ;
19675: LD_ADDR_VAR 0 4
19679: PUSH
19680: LD_INT 0
19682: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19683: LD_ADDR_VAR 0 3
19687: PUSH
19688: DOUBLE
19689: LD_INT 1
19691: DEC
19692: ST_TO_ADDR
19693: LD_EXP 64
19697: PUSH
19698: FOR_TO
19699: IFFALSE 19733
// if artifactsLabs [ i ] = lab then
19701: LD_EXP 64
19705: PUSH
19706: LD_VAR 0 3
19710: ARRAY
19711: PUSH
19712: LD_VAR 0 1
19716: EQUAL
19717: IFFALSE 19731
// begin labNum := i ;
19719: LD_ADDR_VAR 0 4
19723: PUSH
19724: LD_VAR 0 3
19728: ST_TO_ADDR
// break ;
19729: GO 19733
// end ;
19731: GO 19698
19733: POP
19734: POP
// if not labNum then
19735: LD_VAR 0 4
19739: NOT
19740: IFFALSE 19744
// exit ;
19742: GO 19822
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
19744: LD_INT 7
19746: PPUSH
19747: LD_EXP 65
19751: PUSH
19752: LD_VAR 0 4
19756: ARRAY
19757: PUSH
19758: LD_INT 3
19760: ARRAY
19761: PPUSH
19762: LD_INT 2
19764: PPUSH
19765: LD_VAR 0 1
19769: PPUSH
19770: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
19774: LD_ADDR_EXP 63
19778: PUSH
19779: LD_EXP 63
19783: PPUSH
19784: LD_VAR 0 4
19788: PPUSH
19789: LD_VAR 0 2
19793: PPUSH
19794: CALL_OW 1
19798: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
19799: LD_ADDR_EXP 61
19803: PUSH
19804: LD_EXP 61
19808: PPUSH
19809: LD_VAR 0 4
19813: PPUSH
19814: LD_INT 0
19816: PPUSH
19817: CALL_OW 1
19821: ST_TO_ADDR
// end ;
19822: PPOPN 4
19824: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
19825: LD_INT 0
19827: PPUSH
19828: PPUSH
// begin labNum := 0 ;
19829: LD_ADDR_VAR 0 3
19833: PUSH
19834: LD_INT 0
19836: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19837: LD_ADDR_VAR 0 2
19841: PUSH
19842: DOUBLE
19843: LD_INT 1
19845: DEC
19846: ST_TO_ADDR
19847: LD_EXP 64
19851: PUSH
19852: FOR_TO
19853: IFFALSE 19887
// if artifactsLabs [ i ] = lab then
19855: LD_EXP 64
19859: PUSH
19860: LD_VAR 0 2
19864: ARRAY
19865: PUSH
19866: LD_VAR 0 1
19870: EQUAL
19871: IFFALSE 19885
// begin labNum := i ;
19873: LD_ADDR_VAR 0 3
19877: PUSH
19878: LD_VAR 0 2
19882: ST_TO_ADDR
// break ;
19883: GO 19887
// end ;
19885: GO 19852
19887: POP
19888: POP
// if not labNum then
19889: LD_VAR 0 3
19893: NOT
19894: IFFALSE 19898
// exit ;
19896: GO 20060
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
19898: LD_INT 7
19900: PPUSH
19901: LD_EXP 65
19905: PUSH
19906: LD_VAR 0 3
19910: ARRAY
19911: PUSH
19912: LD_INT 3
19914: ARRAY
19915: PPUSH
19916: LD_INT 0
19918: PPUSH
19919: LD_VAR 0 1
19923: PPUSH
19924: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
19928: LD_ADDR_EXP 60
19932: PUSH
19933: LD_EXP 60
19937: PPUSH
19938: LD_VAR 0 3
19942: PPUSH
19943: LD_INT 1
19945: PPUSH
19946: CALL_OW 1
19950: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
19951: LD_ADDR_EXP 66
19955: PUSH
19956: LD_EXP 66
19960: PPUSH
19961: LD_VAR 0 3
19965: PPUSH
19966: LD_INT 1
19968: PPUSH
19969: CALL_OW 1
19973: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
19974: LD_ADDR_EXP 61
19978: PUSH
19979: LD_EXP 61
19983: PPUSH
19984: LD_VAR 0 3
19988: PPUSH
19989: LD_INT 0
19991: PPUSH
19992: CALL_OW 1
19996: ST_TO_ADDR
// case labNum of 1 :
19997: LD_VAR 0 3
20001: PUSH
20002: LD_INT 1
20004: DOUBLE
20005: EQUAL
20006: IFTRUE 20010
20008: GO 20021
20010: POP
// artifactIResearched := true ; 2 :
20011: LD_ADDR_EXP 9
20015: PUSH
20016: LD_INT 1
20018: ST_TO_ADDR
20019: GO 20060
20021: LD_INT 2
20023: DOUBLE
20024: EQUAL
20025: IFTRUE 20029
20027: GO 20040
20029: POP
// artifactIIResearched := true ; 3 :
20030: LD_ADDR_EXP 10
20034: PUSH
20035: LD_INT 1
20037: ST_TO_ADDR
20038: GO 20060
20040: LD_INT 3
20042: DOUBLE
20043: EQUAL
20044: IFTRUE 20048
20046: GO 20059
20048: POP
// artifactIIIResearched := true ; end ;
20049: LD_ADDR_EXP 11
20053: PUSH
20054: LD_INT 1
20056: ST_TO_ADDR
20057: GO 20060
20059: POP
// end ; end_of_file
20060: PPOPN 3
20062: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20063: GO 20065
20065: DISABLE
// begin ru_radar := 98 ;
20066: LD_ADDR_EXP 67
20070: PUSH
20071: LD_INT 98
20073: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20074: LD_ADDR_EXP 68
20078: PUSH
20079: LD_INT 89
20081: ST_TO_ADDR
// us_hack := 99 ;
20082: LD_ADDR_EXP 69
20086: PUSH
20087: LD_INT 99
20089: ST_TO_ADDR
// us_artillery := 97 ;
20090: LD_ADDR_EXP 70
20094: PUSH
20095: LD_INT 97
20097: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20098: LD_ADDR_EXP 71
20102: PUSH
20103: LD_INT 91
20105: ST_TO_ADDR
// end ; end_of_file
20106: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20107: LD_INT 0
20109: PPUSH
20110: PPUSH
// skirmish := false ;
20111: LD_ADDR_EXP 72
20115: PUSH
20116: LD_INT 0
20118: ST_TO_ADDR
// debug_mc := false ;
20119: LD_ADDR_EXP 73
20123: PUSH
20124: LD_INT 0
20126: ST_TO_ADDR
// mc_bases := [ ] ;
20127: LD_ADDR_EXP 74
20131: PUSH
20132: EMPTY
20133: ST_TO_ADDR
// mc_sides := [ ] ;
20134: LD_ADDR_EXP 100
20138: PUSH
20139: EMPTY
20140: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20141: LD_ADDR_EXP 75
20145: PUSH
20146: EMPTY
20147: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20148: LD_ADDR_EXP 76
20152: PUSH
20153: EMPTY
20154: ST_TO_ADDR
// mc_need_heal := [ ] ;
20155: LD_ADDR_EXP 77
20159: PUSH
20160: EMPTY
20161: ST_TO_ADDR
// mc_healers := [ ] ;
20162: LD_ADDR_EXP 78
20166: PUSH
20167: EMPTY
20168: ST_TO_ADDR
// mc_build_list := [ ] ;
20169: LD_ADDR_EXP 79
20173: PUSH
20174: EMPTY
20175: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20176: LD_ADDR_EXP 106
20180: PUSH
20181: EMPTY
20182: ST_TO_ADDR
// mc_builders := [ ] ;
20183: LD_ADDR_EXP 80
20187: PUSH
20188: EMPTY
20189: ST_TO_ADDR
// mc_construct_list := [ ] ;
20190: LD_ADDR_EXP 81
20194: PUSH
20195: EMPTY
20196: ST_TO_ADDR
// mc_turret_list := [ ] ;
20197: LD_ADDR_EXP 82
20201: PUSH
20202: EMPTY
20203: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20204: LD_ADDR_EXP 83
20208: PUSH
20209: EMPTY
20210: ST_TO_ADDR
// mc_miners := [ ] ;
20211: LD_ADDR_EXP 88
20215: PUSH
20216: EMPTY
20217: ST_TO_ADDR
// mc_mines := [ ] ;
20218: LD_ADDR_EXP 87
20222: PUSH
20223: EMPTY
20224: ST_TO_ADDR
// mc_minefields := [ ] ;
20225: LD_ADDR_EXP 89
20229: PUSH
20230: EMPTY
20231: ST_TO_ADDR
// mc_crates := [ ] ;
20232: LD_ADDR_EXP 90
20236: PUSH
20237: EMPTY
20238: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20239: LD_ADDR_EXP 91
20243: PUSH
20244: EMPTY
20245: ST_TO_ADDR
// mc_crates_area := [ ] ;
20246: LD_ADDR_EXP 92
20250: PUSH
20251: EMPTY
20252: ST_TO_ADDR
// mc_vehicles := [ ] ;
20253: LD_ADDR_EXP 93
20257: PUSH
20258: EMPTY
20259: ST_TO_ADDR
// mc_attack := [ ] ;
20260: LD_ADDR_EXP 94
20264: PUSH
20265: EMPTY
20266: ST_TO_ADDR
// mc_produce := [ ] ;
20267: LD_ADDR_EXP 95
20271: PUSH
20272: EMPTY
20273: ST_TO_ADDR
// mc_defender := [ ] ;
20274: LD_ADDR_EXP 96
20278: PUSH
20279: EMPTY
20280: ST_TO_ADDR
// mc_parking := [ ] ;
20281: LD_ADDR_EXP 98
20285: PUSH
20286: EMPTY
20287: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20288: LD_ADDR_EXP 84
20292: PUSH
20293: EMPTY
20294: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20295: LD_ADDR_EXP 86
20299: PUSH
20300: EMPTY
20301: ST_TO_ADDR
// mc_scan := [ ] ;
20302: LD_ADDR_EXP 97
20306: PUSH
20307: EMPTY
20308: ST_TO_ADDR
// mc_scan_area := [ ] ;
20309: LD_ADDR_EXP 99
20313: PUSH
20314: EMPTY
20315: ST_TO_ADDR
// mc_tech := [ ] ;
20316: LD_ADDR_EXP 101
20320: PUSH
20321: EMPTY
20322: ST_TO_ADDR
// mc_class := [ ] ;
20323: LD_ADDR_EXP 115
20327: PUSH
20328: EMPTY
20329: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20330: LD_ADDR_EXP 116
20334: PUSH
20335: EMPTY
20336: ST_TO_ADDR
// end ;
20337: LD_VAR 0 1
20341: RET
// export function MC_Kill ( base ) ; begin
20342: LD_INT 0
20344: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20345: LD_ADDR_EXP 74
20349: PUSH
20350: LD_EXP 74
20354: PPUSH
20355: LD_VAR 0 1
20359: PPUSH
20360: EMPTY
20361: PPUSH
20362: CALL_OW 1
20366: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20367: LD_ADDR_EXP 75
20371: PUSH
20372: LD_EXP 75
20376: PPUSH
20377: LD_VAR 0 1
20381: PPUSH
20382: EMPTY
20383: PPUSH
20384: CALL_OW 1
20388: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20389: LD_ADDR_EXP 76
20393: PUSH
20394: LD_EXP 76
20398: PPUSH
20399: LD_VAR 0 1
20403: PPUSH
20404: EMPTY
20405: PPUSH
20406: CALL_OW 1
20410: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20411: LD_ADDR_EXP 77
20415: PUSH
20416: LD_EXP 77
20420: PPUSH
20421: LD_VAR 0 1
20425: PPUSH
20426: EMPTY
20427: PPUSH
20428: CALL_OW 1
20432: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20433: LD_ADDR_EXP 78
20437: PUSH
20438: LD_EXP 78
20442: PPUSH
20443: LD_VAR 0 1
20447: PPUSH
20448: EMPTY
20449: PPUSH
20450: CALL_OW 1
20454: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20455: LD_ADDR_EXP 79
20459: PUSH
20460: LD_EXP 79
20464: PPUSH
20465: LD_VAR 0 1
20469: PPUSH
20470: EMPTY
20471: PPUSH
20472: CALL_OW 1
20476: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20477: LD_ADDR_EXP 80
20481: PUSH
20482: LD_EXP 80
20486: PPUSH
20487: LD_VAR 0 1
20491: PPUSH
20492: EMPTY
20493: PPUSH
20494: CALL_OW 1
20498: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20499: LD_ADDR_EXP 81
20503: PUSH
20504: LD_EXP 81
20508: PPUSH
20509: LD_VAR 0 1
20513: PPUSH
20514: EMPTY
20515: PPUSH
20516: CALL_OW 1
20520: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20521: LD_ADDR_EXP 82
20525: PUSH
20526: LD_EXP 82
20530: PPUSH
20531: LD_VAR 0 1
20535: PPUSH
20536: EMPTY
20537: PPUSH
20538: CALL_OW 1
20542: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20543: LD_ADDR_EXP 83
20547: PUSH
20548: LD_EXP 83
20552: PPUSH
20553: LD_VAR 0 1
20557: PPUSH
20558: EMPTY
20559: PPUSH
20560: CALL_OW 1
20564: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20565: LD_ADDR_EXP 84
20569: PUSH
20570: LD_EXP 84
20574: PPUSH
20575: LD_VAR 0 1
20579: PPUSH
20580: EMPTY
20581: PPUSH
20582: CALL_OW 1
20586: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20587: LD_ADDR_EXP 85
20591: PUSH
20592: LD_EXP 85
20596: PPUSH
20597: LD_VAR 0 1
20601: PPUSH
20602: LD_INT 0
20604: PPUSH
20605: CALL_OW 1
20609: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20610: LD_ADDR_EXP 86
20614: PUSH
20615: LD_EXP 86
20619: PPUSH
20620: LD_VAR 0 1
20624: PPUSH
20625: EMPTY
20626: PPUSH
20627: CALL_OW 1
20631: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20632: LD_ADDR_EXP 87
20636: PUSH
20637: LD_EXP 87
20641: PPUSH
20642: LD_VAR 0 1
20646: PPUSH
20647: EMPTY
20648: PPUSH
20649: CALL_OW 1
20653: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20654: LD_ADDR_EXP 88
20658: PUSH
20659: LD_EXP 88
20663: PPUSH
20664: LD_VAR 0 1
20668: PPUSH
20669: EMPTY
20670: PPUSH
20671: CALL_OW 1
20675: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20676: LD_ADDR_EXP 89
20680: PUSH
20681: LD_EXP 89
20685: PPUSH
20686: LD_VAR 0 1
20690: PPUSH
20691: EMPTY
20692: PPUSH
20693: CALL_OW 1
20697: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20698: LD_ADDR_EXP 90
20702: PUSH
20703: LD_EXP 90
20707: PPUSH
20708: LD_VAR 0 1
20712: PPUSH
20713: EMPTY
20714: PPUSH
20715: CALL_OW 1
20719: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20720: LD_ADDR_EXP 91
20724: PUSH
20725: LD_EXP 91
20729: PPUSH
20730: LD_VAR 0 1
20734: PPUSH
20735: EMPTY
20736: PPUSH
20737: CALL_OW 1
20741: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20742: LD_ADDR_EXP 92
20746: PUSH
20747: LD_EXP 92
20751: PPUSH
20752: LD_VAR 0 1
20756: PPUSH
20757: EMPTY
20758: PPUSH
20759: CALL_OW 1
20763: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20764: LD_ADDR_EXP 93
20768: PUSH
20769: LD_EXP 93
20773: PPUSH
20774: LD_VAR 0 1
20778: PPUSH
20779: EMPTY
20780: PPUSH
20781: CALL_OW 1
20785: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20786: LD_ADDR_EXP 94
20790: PUSH
20791: LD_EXP 94
20795: PPUSH
20796: LD_VAR 0 1
20800: PPUSH
20801: EMPTY
20802: PPUSH
20803: CALL_OW 1
20807: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20808: LD_ADDR_EXP 95
20812: PUSH
20813: LD_EXP 95
20817: PPUSH
20818: LD_VAR 0 1
20822: PPUSH
20823: EMPTY
20824: PPUSH
20825: CALL_OW 1
20829: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20830: LD_ADDR_EXP 96
20834: PUSH
20835: LD_EXP 96
20839: PPUSH
20840: LD_VAR 0 1
20844: PPUSH
20845: EMPTY
20846: PPUSH
20847: CALL_OW 1
20851: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20852: LD_ADDR_EXP 97
20856: PUSH
20857: LD_EXP 97
20861: PPUSH
20862: LD_VAR 0 1
20866: PPUSH
20867: EMPTY
20868: PPUSH
20869: CALL_OW 1
20873: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20874: LD_ADDR_EXP 98
20878: PUSH
20879: LD_EXP 98
20883: PPUSH
20884: LD_VAR 0 1
20888: PPUSH
20889: EMPTY
20890: PPUSH
20891: CALL_OW 1
20895: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20896: LD_ADDR_EXP 99
20900: PUSH
20901: LD_EXP 99
20905: PPUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: EMPTY
20912: PPUSH
20913: CALL_OW 1
20917: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20918: LD_ADDR_EXP 101
20922: PUSH
20923: LD_EXP 101
20927: PPUSH
20928: LD_VAR 0 1
20932: PPUSH
20933: EMPTY
20934: PPUSH
20935: CALL_OW 1
20939: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20940: LD_ADDR_EXP 103
20944: PUSH
20945: LD_EXP 103
20949: PPUSH
20950: LD_VAR 0 1
20954: PPUSH
20955: EMPTY
20956: PPUSH
20957: CALL_OW 1
20961: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20962: LD_ADDR_EXP 104
20966: PUSH
20967: LD_EXP 104
20971: PPUSH
20972: LD_VAR 0 1
20976: PPUSH
20977: EMPTY
20978: PPUSH
20979: CALL_OW 1
20983: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20984: LD_ADDR_EXP 105
20988: PUSH
20989: LD_EXP 105
20993: PPUSH
20994: LD_VAR 0 1
20998: PPUSH
20999: EMPTY
21000: PPUSH
21001: CALL_OW 1
21005: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21006: LD_ADDR_EXP 106
21010: PUSH
21011: LD_EXP 106
21015: PPUSH
21016: LD_VAR 0 1
21020: PPUSH
21021: EMPTY
21022: PPUSH
21023: CALL_OW 1
21027: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21028: LD_ADDR_EXP 107
21032: PUSH
21033: LD_EXP 107
21037: PPUSH
21038: LD_VAR 0 1
21042: PPUSH
21043: EMPTY
21044: PPUSH
21045: CALL_OW 1
21049: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21050: LD_ADDR_EXP 108
21054: PUSH
21055: LD_EXP 108
21059: PPUSH
21060: LD_VAR 0 1
21064: PPUSH
21065: EMPTY
21066: PPUSH
21067: CALL_OW 1
21071: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21072: LD_ADDR_EXP 109
21076: PUSH
21077: LD_EXP 109
21081: PPUSH
21082: LD_VAR 0 1
21086: PPUSH
21087: EMPTY
21088: PPUSH
21089: CALL_OW 1
21093: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21094: LD_ADDR_EXP 110
21098: PUSH
21099: LD_EXP 110
21103: PPUSH
21104: LD_VAR 0 1
21108: PPUSH
21109: EMPTY
21110: PPUSH
21111: CALL_OW 1
21115: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21116: LD_ADDR_EXP 111
21120: PUSH
21121: LD_EXP 111
21125: PPUSH
21126: LD_VAR 0 1
21130: PPUSH
21131: EMPTY
21132: PPUSH
21133: CALL_OW 1
21137: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21138: LD_ADDR_EXP 112
21142: PUSH
21143: LD_EXP 112
21147: PPUSH
21148: LD_VAR 0 1
21152: PPUSH
21153: EMPTY
21154: PPUSH
21155: CALL_OW 1
21159: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21160: LD_ADDR_EXP 113
21164: PUSH
21165: LD_EXP 113
21169: PPUSH
21170: LD_VAR 0 1
21174: PPUSH
21175: EMPTY
21176: PPUSH
21177: CALL_OW 1
21181: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21182: LD_ADDR_EXP 114
21186: PUSH
21187: LD_EXP 114
21191: PPUSH
21192: LD_VAR 0 1
21196: PPUSH
21197: EMPTY
21198: PPUSH
21199: CALL_OW 1
21203: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21204: LD_ADDR_EXP 115
21208: PUSH
21209: LD_EXP 115
21213: PPUSH
21214: LD_VAR 0 1
21218: PPUSH
21219: EMPTY
21220: PPUSH
21221: CALL_OW 1
21225: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21226: LD_ADDR_EXP 116
21230: PUSH
21231: LD_EXP 116
21235: PPUSH
21236: LD_VAR 0 1
21240: PPUSH
21241: LD_INT 0
21243: PPUSH
21244: CALL_OW 1
21248: ST_TO_ADDR
// end ;
21249: LD_VAR 0 2
21253: RET
// export function MC_Add ( side , units ) ; var base ; begin
21254: LD_INT 0
21256: PPUSH
21257: PPUSH
// base := mc_bases + 1 ;
21258: LD_ADDR_VAR 0 4
21262: PUSH
21263: LD_EXP 74
21267: PUSH
21268: LD_INT 1
21270: PLUS
21271: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21272: LD_ADDR_EXP 100
21276: PUSH
21277: LD_EXP 100
21281: PPUSH
21282: LD_VAR 0 4
21286: PPUSH
21287: LD_VAR 0 1
21291: PPUSH
21292: CALL_OW 1
21296: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21297: LD_ADDR_EXP 74
21301: PUSH
21302: LD_EXP 74
21306: PPUSH
21307: LD_VAR 0 4
21311: PPUSH
21312: LD_VAR 0 2
21316: PPUSH
21317: CALL_OW 1
21321: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21322: LD_ADDR_EXP 75
21326: PUSH
21327: LD_EXP 75
21331: PPUSH
21332: LD_VAR 0 4
21336: PPUSH
21337: EMPTY
21338: PPUSH
21339: CALL_OW 1
21343: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21344: LD_ADDR_EXP 76
21348: PUSH
21349: LD_EXP 76
21353: PPUSH
21354: LD_VAR 0 4
21358: PPUSH
21359: EMPTY
21360: PPUSH
21361: CALL_OW 1
21365: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21366: LD_ADDR_EXP 77
21370: PUSH
21371: LD_EXP 77
21375: PPUSH
21376: LD_VAR 0 4
21380: PPUSH
21381: EMPTY
21382: PPUSH
21383: CALL_OW 1
21387: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21388: LD_ADDR_EXP 78
21392: PUSH
21393: LD_EXP 78
21397: PPUSH
21398: LD_VAR 0 4
21402: PPUSH
21403: EMPTY
21404: PPUSH
21405: CALL_OW 1
21409: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21410: LD_ADDR_EXP 79
21414: PUSH
21415: LD_EXP 79
21419: PPUSH
21420: LD_VAR 0 4
21424: PPUSH
21425: EMPTY
21426: PPUSH
21427: CALL_OW 1
21431: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21432: LD_ADDR_EXP 80
21436: PUSH
21437: LD_EXP 80
21441: PPUSH
21442: LD_VAR 0 4
21446: PPUSH
21447: EMPTY
21448: PPUSH
21449: CALL_OW 1
21453: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21454: LD_ADDR_EXP 81
21458: PUSH
21459: LD_EXP 81
21463: PPUSH
21464: LD_VAR 0 4
21468: PPUSH
21469: EMPTY
21470: PPUSH
21471: CALL_OW 1
21475: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21476: LD_ADDR_EXP 82
21480: PUSH
21481: LD_EXP 82
21485: PPUSH
21486: LD_VAR 0 4
21490: PPUSH
21491: EMPTY
21492: PPUSH
21493: CALL_OW 1
21497: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21498: LD_ADDR_EXP 83
21502: PUSH
21503: LD_EXP 83
21507: PPUSH
21508: LD_VAR 0 4
21512: PPUSH
21513: EMPTY
21514: PPUSH
21515: CALL_OW 1
21519: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21520: LD_ADDR_EXP 84
21524: PUSH
21525: LD_EXP 84
21529: PPUSH
21530: LD_VAR 0 4
21534: PPUSH
21535: EMPTY
21536: PPUSH
21537: CALL_OW 1
21541: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21542: LD_ADDR_EXP 85
21546: PUSH
21547: LD_EXP 85
21551: PPUSH
21552: LD_VAR 0 4
21556: PPUSH
21557: LD_INT 0
21559: PPUSH
21560: CALL_OW 1
21564: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21565: LD_ADDR_EXP 86
21569: PUSH
21570: LD_EXP 86
21574: PPUSH
21575: LD_VAR 0 4
21579: PPUSH
21580: EMPTY
21581: PPUSH
21582: CALL_OW 1
21586: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21587: LD_ADDR_EXP 87
21591: PUSH
21592: LD_EXP 87
21596: PPUSH
21597: LD_VAR 0 4
21601: PPUSH
21602: EMPTY
21603: PPUSH
21604: CALL_OW 1
21608: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21609: LD_ADDR_EXP 88
21613: PUSH
21614: LD_EXP 88
21618: PPUSH
21619: LD_VAR 0 4
21623: PPUSH
21624: EMPTY
21625: PPUSH
21626: CALL_OW 1
21630: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21631: LD_ADDR_EXP 89
21635: PUSH
21636: LD_EXP 89
21640: PPUSH
21641: LD_VAR 0 4
21645: PPUSH
21646: EMPTY
21647: PPUSH
21648: CALL_OW 1
21652: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21653: LD_ADDR_EXP 90
21657: PUSH
21658: LD_EXP 90
21662: PPUSH
21663: LD_VAR 0 4
21667: PPUSH
21668: EMPTY
21669: PPUSH
21670: CALL_OW 1
21674: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21675: LD_ADDR_EXP 91
21679: PUSH
21680: LD_EXP 91
21684: PPUSH
21685: LD_VAR 0 4
21689: PPUSH
21690: EMPTY
21691: PPUSH
21692: CALL_OW 1
21696: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21697: LD_ADDR_EXP 92
21701: PUSH
21702: LD_EXP 92
21706: PPUSH
21707: LD_VAR 0 4
21711: PPUSH
21712: EMPTY
21713: PPUSH
21714: CALL_OW 1
21718: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21719: LD_ADDR_EXP 93
21723: PUSH
21724: LD_EXP 93
21728: PPUSH
21729: LD_VAR 0 4
21733: PPUSH
21734: EMPTY
21735: PPUSH
21736: CALL_OW 1
21740: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21741: LD_ADDR_EXP 94
21745: PUSH
21746: LD_EXP 94
21750: PPUSH
21751: LD_VAR 0 4
21755: PPUSH
21756: EMPTY
21757: PPUSH
21758: CALL_OW 1
21762: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21763: LD_ADDR_EXP 95
21767: PUSH
21768: LD_EXP 95
21772: PPUSH
21773: LD_VAR 0 4
21777: PPUSH
21778: EMPTY
21779: PPUSH
21780: CALL_OW 1
21784: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21785: LD_ADDR_EXP 96
21789: PUSH
21790: LD_EXP 96
21794: PPUSH
21795: LD_VAR 0 4
21799: PPUSH
21800: EMPTY
21801: PPUSH
21802: CALL_OW 1
21806: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21807: LD_ADDR_EXP 97
21811: PUSH
21812: LD_EXP 97
21816: PPUSH
21817: LD_VAR 0 4
21821: PPUSH
21822: EMPTY
21823: PPUSH
21824: CALL_OW 1
21828: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21829: LD_ADDR_EXP 98
21833: PUSH
21834: LD_EXP 98
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: EMPTY
21845: PPUSH
21846: CALL_OW 1
21850: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21851: LD_ADDR_EXP 99
21855: PUSH
21856: LD_EXP 99
21860: PPUSH
21861: LD_VAR 0 4
21865: PPUSH
21866: EMPTY
21867: PPUSH
21868: CALL_OW 1
21872: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21873: LD_ADDR_EXP 101
21877: PUSH
21878: LD_EXP 101
21882: PPUSH
21883: LD_VAR 0 4
21887: PPUSH
21888: EMPTY
21889: PPUSH
21890: CALL_OW 1
21894: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21895: LD_ADDR_EXP 103
21899: PUSH
21900: LD_EXP 103
21904: PPUSH
21905: LD_VAR 0 4
21909: PPUSH
21910: EMPTY
21911: PPUSH
21912: CALL_OW 1
21916: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21917: LD_ADDR_EXP 104
21921: PUSH
21922: LD_EXP 104
21926: PPUSH
21927: LD_VAR 0 4
21931: PPUSH
21932: EMPTY
21933: PPUSH
21934: CALL_OW 1
21938: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21939: LD_ADDR_EXP 105
21943: PUSH
21944: LD_EXP 105
21948: PPUSH
21949: LD_VAR 0 4
21953: PPUSH
21954: EMPTY
21955: PPUSH
21956: CALL_OW 1
21960: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21961: LD_ADDR_EXP 106
21965: PUSH
21966: LD_EXP 106
21970: PPUSH
21971: LD_VAR 0 4
21975: PPUSH
21976: EMPTY
21977: PPUSH
21978: CALL_OW 1
21982: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21983: LD_ADDR_EXP 107
21987: PUSH
21988: LD_EXP 107
21992: PPUSH
21993: LD_VAR 0 4
21997: PPUSH
21998: EMPTY
21999: PPUSH
22000: CALL_OW 1
22004: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22005: LD_ADDR_EXP 108
22009: PUSH
22010: LD_EXP 108
22014: PPUSH
22015: LD_VAR 0 4
22019: PPUSH
22020: EMPTY
22021: PPUSH
22022: CALL_OW 1
22026: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22027: LD_ADDR_EXP 109
22031: PUSH
22032: LD_EXP 109
22036: PPUSH
22037: LD_VAR 0 4
22041: PPUSH
22042: EMPTY
22043: PPUSH
22044: CALL_OW 1
22048: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22049: LD_ADDR_EXP 110
22053: PUSH
22054: LD_EXP 110
22058: PPUSH
22059: LD_VAR 0 4
22063: PPUSH
22064: EMPTY
22065: PPUSH
22066: CALL_OW 1
22070: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22071: LD_ADDR_EXP 111
22075: PUSH
22076: LD_EXP 111
22080: PPUSH
22081: LD_VAR 0 4
22085: PPUSH
22086: EMPTY
22087: PPUSH
22088: CALL_OW 1
22092: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22093: LD_ADDR_EXP 112
22097: PUSH
22098: LD_EXP 112
22102: PPUSH
22103: LD_VAR 0 4
22107: PPUSH
22108: EMPTY
22109: PPUSH
22110: CALL_OW 1
22114: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22115: LD_ADDR_EXP 113
22119: PUSH
22120: LD_EXP 113
22124: PPUSH
22125: LD_VAR 0 4
22129: PPUSH
22130: EMPTY
22131: PPUSH
22132: CALL_OW 1
22136: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22137: LD_ADDR_EXP 114
22141: PUSH
22142: LD_EXP 114
22146: PPUSH
22147: LD_VAR 0 4
22151: PPUSH
22152: EMPTY
22153: PPUSH
22154: CALL_OW 1
22158: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22159: LD_ADDR_EXP 115
22163: PUSH
22164: LD_EXP 115
22168: PPUSH
22169: LD_VAR 0 4
22173: PPUSH
22174: EMPTY
22175: PPUSH
22176: CALL_OW 1
22180: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22181: LD_ADDR_EXP 116
22185: PUSH
22186: LD_EXP 116
22190: PPUSH
22191: LD_VAR 0 4
22195: PPUSH
22196: LD_INT 0
22198: PPUSH
22199: CALL_OW 1
22203: ST_TO_ADDR
// result := base ;
22204: LD_ADDR_VAR 0 3
22208: PUSH
22209: LD_VAR 0 4
22213: ST_TO_ADDR
// end ;
22214: LD_VAR 0 3
22218: RET
// export function MC_Start ( ) ; var i ; begin
22219: LD_INT 0
22221: PPUSH
22222: PPUSH
// for i = 1 to mc_bases do
22223: LD_ADDR_VAR 0 2
22227: PUSH
22228: DOUBLE
22229: LD_INT 1
22231: DEC
22232: ST_TO_ADDR
22233: LD_EXP 74
22237: PUSH
22238: FOR_TO
22239: IFFALSE 23316
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22241: LD_ADDR_EXP 74
22245: PUSH
22246: LD_EXP 74
22250: PPUSH
22251: LD_VAR 0 2
22255: PPUSH
22256: LD_EXP 74
22260: PUSH
22261: LD_VAR 0 2
22265: ARRAY
22266: PUSH
22267: LD_INT 0
22269: DIFF
22270: PPUSH
22271: CALL_OW 1
22275: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22276: LD_ADDR_EXP 75
22280: PUSH
22281: LD_EXP 75
22285: PPUSH
22286: LD_VAR 0 2
22290: PPUSH
22291: EMPTY
22292: PPUSH
22293: CALL_OW 1
22297: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22298: LD_ADDR_EXP 76
22302: PUSH
22303: LD_EXP 76
22307: PPUSH
22308: LD_VAR 0 2
22312: PPUSH
22313: EMPTY
22314: PPUSH
22315: CALL_OW 1
22319: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22320: LD_ADDR_EXP 77
22324: PUSH
22325: LD_EXP 77
22329: PPUSH
22330: LD_VAR 0 2
22334: PPUSH
22335: EMPTY
22336: PPUSH
22337: CALL_OW 1
22341: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22342: LD_ADDR_EXP 78
22346: PUSH
22347: LD_EXP 78
22351: PPUSH
22352: LD_VAR 0 2
22356: PPUSH
22357: EMPTY
22358: PUSH
22359: EMPTY
22360: PUSH
22361: EMPTY
22362: LIST
22363: LIST
22364: PPUSH
22365: CALL_OW 1
22369: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22370: LD_ADDR_EXP 79
22374: PUSH
22375: LD_EXP 79
22379: PPUSH
22380: LD_VAR 0 2
22384: PPUSH
22385: EMPTY
22386: PPUSH
22387: CALL_OW 1
22391: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22392: LD_ADDR_EXP 106
22396: PUSH
22397: LD_EXP 106
22401: PPUSH
22402: LD_VAR 0 2
22406: PPUSH
22407: EMPTY
22408: PPUSH
22409: CALL_OW 1
22413: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22414: LD_ADDR_EXP 80
22418: PUSH
22419: LD_EXP 80
22423: PPUSH
22424: LD_VAR 0 2
22428: PPUSH
22429: EMPTY
22430: PPUSH
22431: CALL_OW 1
22435: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22436: LD_ADDR_EXP 81
22440: PUSH
22441: LD_EXP 81
22445: PPUSH
22446: LD_VAR 0 2
22450: PPUSH
22451: EMPTY
22452: PPUSH
22453: CALL_OW 1
22457: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22458: LD_ADDR_EXP 82
22462: PUSH
22463: LD_EXP 82
22467: PPUSH
22468: LD_VAR 0 2
22472: PPUSH
22473: LD_EXP 74
22477: PUSH
22478: LD_VAR 0 2
22482: ARRAY
22483: PPUSH
22484: LD_INT 2
22486: PUSH
22487: LD_INT 30
22489: PUSH
22490: LD_INT 32
22492: PUSH
22493: EMPTY
22494: LIST
22495: LIST
22496: PUSH
22497: LD_INT 30
22499: PUSH
22500: LD_INT 33
22502: PUSH
22503: EMPTY
22504: LIST
22505: LIST
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: LIST
22511: PPUSH
22512: CALL_OW 72
22516: PPUSH
22517: CALL_OW 1
22521: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22522: LD_ADDR_EXP 83
22526: PUSH
22527: LD_EXP 83
22531: PPUSH
22532: LD_VAR 0 2
22536: PPUSH
22537: LD_EXP 74
22541: PUSH
22542: LD_VAR 0 2
22546: ARRAY
22547: PPUSH
22548: LD_INT 2
22550: PUSH
22551: LD_INT 30
22553: PUSH
22554: LD_INT 32
22556: PUSH
22557: EMPTY
22558: LIST
22559: LIST
22560: PUSH
22561: LD_INT 30
22563: PUSH
22564: LD_INT 31
22566: PUSH
22567: EMPTY
22568: LIST
22569: LIST
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: LIST
22575: PUSH
22576: LD_INT 58
22578: PUSH
22579: EMPTY
22580: LIST
22581: PUSH
22582: EMPTY
22583: LIST
22584: LIST
22585: PPUSH
22586: CALL_OW 72
22590: PPUSH
22591: CALL_OW 1
22595: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22596: LD_ADDR_EXP 84
22600: PUSH
22601: LD_EXP 84
22605: PPUSH
22606: LD_VAR 0 2
22610: PPUSH
22611: EMPTY
22612: PPUSH
22613: CALL_OW 1
22617: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22618: LD_ADDR_EXP 88
22622: PUSH
22623: LD_EXP 88
22627: PPUSH
22628: LD_VAR 0 2
22632: PPUSH
22633: EMPTY
22634: PPUSH
22635: CALL_OW 1
22639: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22640: LD_ADDR_EXP 87
22644: PUSH
22645: LD_EXP 87
22649: PPUSH
22650: LD_VAR 0 2
22654: PPUSH
22655: EMPTY
22656: PPUSH
22657: CALL_OW 1
22661: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22662: LD_ADDR_EXP 89
22666: PUSH
22667: LD_EXP 89
22671: PPUSH
22672: LD_VAR 0 2
22676: PPUSH
22677: EMPTY
22678: PPUSH
22679: CALL_OW 1
22683: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22684: LD_ADDR_EXP 90
22688: PUSH
22689: LD_EXP 90
22693: PPUSH
22694: LD_VAR 0 2
22698: PPUSH
22699: EMPTY
22700: PPUSH
22701: CALL_OW 1
22705: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22706: LD_ADDR_EXP 91
22710: PUSH
22711: LD_EXP 91
22715: PPUSH
22716: LD_VAR 0 2
22720: PPUSH
22721: EMPTY
22722: PPUSH
22723: CALL_OW 1
22727: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22728: LD_ADDR_EXP 92
22732: PUSH
22733: LD_EXP 92
22737: PPUSH
22738: LD_VAR 0 2
22742: PPUSH
22743: EMPTY
22744: PPUSH
22745: CALL_OW 1
22749: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
22750: LD_ADDR_EXP 93
22754: PUSH
22755: LD_EXP 93
22759: PPUSH
22760: LD_VAR 0 2
22764: PPUSH
22765: EMPTY
22766: PPUSH
22767: CALL_OW 1
22771: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22772: LD_ADDR_EXP 94
22776: PUSH
22777: LD_EXP 94
22781: PPUSH
22782: LD_VAR 0 2
22786: PPUSH
22787: EMPTY
22788: PPUSH
22789: CALL_OW 1
22793: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
22794: LD_ADDR_EXP 95
22798: PUSH
22799: LD_EXP 95
22803: PPUSH
22804: LD_VAR 0 2
22808: PPUSH
22809: EMPTY
22810: PPUSH
22811: CALL_OW 1
22815: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
22816: LD_ADDR_EXP 96
22820: PUSH
22821: LD_EXP 96
22825: PPUSH
22826: LD_VAR 0 2
22830: PPUSH
22831: EMPTY
22832: PPUSH
22833: CALL_OW 1
22837: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
22838: LD_ADDR_EXP 85
22842: PUSH
22843: LD_EXP 85
22847: PPUSH
22848: LD_VAR 0 2
22852: PPUSH
22853: LD_INT 0
22855: PPUSH
22856: CALL_OW 1
22860: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
22861: LD_ADDR_EXP 98
22865: PUSH
22866: LD_EXP 98
22870: PPUSH
22871: LD_VAR 0 2
22875: PPUSH
22876: LD_INT 0
22878: PPUSH
22879: CALL_OW 1
22883: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
22884: LD_ADDR_EXP 86
22888: PUSH
22889: LD_EXP 86
22893: PPUSH
22894: LD_VAR 0 2
22898: PPUSH
22899: EMPTY
22900: PPUSH
22901: CALL_OW 1
22905: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
22906: LD_ADDR_EXP 97
22910: PUSH
22911: LD_EXP 97
22915: PPUSH
22916: LD_VAR 0 2
22920: PPUSH
22921: LD_INT 0
22923: PPUSH
22924: CALL_OW 1
22928: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
22929: LD_ADDR_EXP 99
22933: PUSH
22934: LD_EXP 99
22938: PPUSH
22939: LD_VAR 0 2
22943: PPUSH
22944: EMPTY
22945: PPUSH
22946: CALL_OW 1
22950: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
22951: LD_ADDR_EXP 102
22955: PUSH
22956: LD_EXP 102
22960: PPUSH
22961: LD_VAR 0 2
22965: PPUSH
22966: LD_INT 0
22968: PPUSH
22969: CALL_OW 1
22973: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
22974: LD_ADDR_EXP 103
22978: PUSH
22979: LD_EXP 103
22983: PPUSH
22984: LD_VAR 0 2
22988: PPUSH
22989: EMPTY
22990: PPUSH
22991: CALL_OW 1
22995: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
22996: LD_ADDR_EXP 104
23000: PUSH
23001: LD_EXP 104
23005: PPUSH
23006: LD_VAR 0 2
23010: PPUSH
23011: EMPTY
23012: PPUSH
23013: CALL_OW 1
23017: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23018: LD_ADDR_EXP 105
23022: PUSH
23023: LD_EXP 105
23027: PPUSH
23028: LD_VAR 0 2
23032: PPUSH
23033: EMPTY
23034: PPUSH
23035: CALL_OW 1
23039: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23040: LD_ADDR_EXP 107
23044: PUSH
23045: LD_EXP 107
23049: PPUSH
23050: LD_VAR 0 2
23054: PPUSH
23055: LD_EXP 74
23059: PUSH
23060: LD_VAR 0 2
23064: ARRAY
23065: PPUSH
23066: LD_INT 2
23068: PUSH
23069: LD_INT 30
23071: PUSH
23072: LD_INT 6
23074: PUSH
23075: EMPTY
23076: LIST
23077: LIST
23078: PUSH
23079: LD_INT 30
23081: PUSH
23082: LD_INT 7
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: PUSH
23089: LD_INT 30
23091: PUSH
23092: LD_INT 8
23094: PUSH
23095: EMPTY
23096: LIST
23097: LIST
23098: PUSH
23099: EMPTY
23100: LIST
23101: LIST
23102: LIST
23103: LIST
23104: PPUSH
23105: CALL_OW 72
23109: PPUSH
23110: CALL_OW 1
23114: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23115: LD_ADDR_EXP 108
23119: PUSH
23120: LD_EXP 108
23124: PPUSH
23125: LD_VAR 0 2
23129: PPUSH
23130: EMPTY
23131: PPUSH
23132: CALL_OW 1
23136: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23137: LD_ADDR_EXP 109
23141: PUSH
23142: LD_EXP 109
23146: PPUSH
23147: LD_VAR 0 2
23151: PPUSH
23152: EMPTY
23153: PPUSH
23154: CALL_OW 1
23158: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23159: LD_ADDR_EXP 110
23163: PUSH
23164: LD_EXP 110
23168: PPUSH
23169: LD_VAR 0 2
23173: PPUSH
23174: EMPTY
23175: PPUSH
23176: CALL_OW 1
23180: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23181: LD_ADDR_EXP 111
23185: PUSH
23186: LD_EXP 111
23190: PPUSH
23191: LD_VAR 0 2
23195: PPUSH
23196: EMPTY
23197: PPUSH
23198: CALL_OW 1
23202: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23203: LD_ADDR_EXP 112
23207: PUSH
23208: LD_EXP 112
23212: PPUSH
23213: LD_VAR 0 2
23217: PPUSH
23218: EMPTY
23219: PPUSH
23220: CALL_OW 1
23224: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23225: LD_ADDR_EXP 113
23229: PUSH
23230: LD_EXP 113
23234: PPUSH
23235: LD_VAR 0 2
23239: PPUSH
23240: EMPTY
23241: PPUSH
23242: CALL_OW 1
23246: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23247: LD_ADDR_EXP 114
23251: PUSH
23252: LD_EXP 114
23256: PPUSH
23257: LD_VAR 0 2
23261: PPUSH
23262: EMPTY
23263: PPUSH
23264: CALL_OW 1
23268: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23269: LD_ADDR_EXP 115
23273: PUSH
23274: LD_EXP 115
23278: PPUSH
23279: LD_VAR 0 2
23283: PPUSH
23284: EMPTY
23285: PPUSH
23286: CALL_OW 1
23290: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23291: LD_ADDR_EXP 116
23295: PUSH
23296: LD_EXP 116
23300: PPUSH
23301: LD_VAR 0 2
23305: PPUSH
23306: LD_INT 0
23308: PPUSH
23309: CALL_OW 1
23313: ST_TO_ADDR
// end ;
23314: GO 22238
23316: POP
23317: POP
// MC_InitSides ( ) ;
23318: CALL 23604 0 0
// MC_InitResearch ( ) ;
23322: CALL 23343 0 0
// CustomInitMacro ( ) ;
23326: CALL 173 0 0
// skirmish := true ;
23330: LD_ADDR_EXP 72
23334: PUSH
23335: LD_INT 1
23337: ST_TO_ADDR
// end ;
23338: LD_VAR 0 1
23342: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23343: LD_INT 0
23345: PPUSH
23346: PPUSH
23347: PPUSH
23348: PPUSH
23349: PPUSH
23350: PPUSH
// if not mc_bases then
23351: LD_EXP 74
23355: NOT
23356: IFFALSE 23360
// exit ;
23358: GO 23599
// for i = 1 to 8 do
23360: LD_ADDR_VAR 0 2
23364: PUSH
23365: DOUBLE
23366: LD_INT 1
23368: DEC
23369: ST_TO_ADDR
23370: LD_INT 8
23372: PUSH
23373: FOR_TO
23374: IFFALSE 23400
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23376: LD_ADDR_EXP 101
23380: PUSH
23381: LD_EXP 101
23385: PPUSH
23386: LD_VAR 0 2
23390: PPUSH
23391: EMPTY
23392: PPUSH
23393: CALL_OW 1
23397: ST_TO_ADDR
23398: GO 23373
23400: POP
23401: POP
// tmp := [ ] ;
23402: LD_ADDR_VAR 0 5
23406: PUSH
23407: EMPTY
23408: ST_TO_ADDR
// for i = 1 to mc_sides do
23409: LD_ADDR_VAR 0 2
23413: PUSH
23414: DOUBLE
23415: LD_INT 1
23417: DEC
23418: ST_TO_ADDR
23419: LD_EXP 100
23423: PUSH
23424: FOR_TO
23425: IFFALSE 23483
// if not mc_sides [ i ] in tmp then
23427: LD_EXP 100
23431: PUSH
23432: LD_VAR 0 2
23436: ARRAY
23437: PUSH
23438: LD_VAR 0 5
23442: IN
23443: NOT
23444: IFFALSE 23481
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23446: LD_ADDR_VAR 0 5
23450: PUSH
23451: LD_VAR 0 5
23455: PPUSH
23456: LD_VAR 0 5
23460: PUSH
23461: LD_INT 1
23463: PLUS
23464: PPUSH
23465: LD_EXP 100
23469: PUSH
23470: LD_VAR 0 2
23474: ARRAY
23475: PPUSH
23476: CALL_OW 2
23480: ST_TO_ADDR
23481: GO 23424
23483: POP
23484: POP
// if not tmp then
23485: LD_VAR 0 5
23489: NOT
23490: IFFALSE 23494
// exit ;
23492: GO 23599
// for j in tmp do
23494: LD_ADDR_VAR 0 3
23498: PUSH
23499: LD_VAR 0 5
23503: PUSH
23504: FOR_IN
23505: IFFALSE 23597
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23507: LD_ADDR_VAR 0 6
23511: PUSH
23512: LD_INT 22
23514: PUSH
23515: LD_VAR 0 3
23519: PUSH
23520: EMPTY
23521: LIST
23522: LIST
23523: PPUSH
23524: CALL_OW 69
23528: ST_TO_ADDR
// if not un then
23529: LD_VAR 0 6
23533: NOT
23534: IFFALSE 23538
// continue ;
23536: GO 23504
// nation := GetNation ( un [ 1 ] ) ;
23538: LD_ADDR_VAR 0 4
23542: PUSH
23543: LD_VAR 0 6
23547: PUSH
23548: LD_INT 1
23550: ARRAY
23551: PPUSH
23552: CALL_OW 248
23556: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23557: LD_ADDR_EXP 101
23561: PUSH
23562: LD_EXP 101
23566: PPUSH
23567: LD_VAR 0 3
23571: PPUSH
23572: LD_VAR 0 3
23576: PPUSH
23577: LD_VAR 0 4
23581: PPUSH
23582: LD_INT 1
23584: PPUSH
23585: CALL 50313 0 3
23589: PPUSH
23590: CALL_OW 1
23594: ST_TO_ADDR
// end ;
23595: GO 23504
23597: POP
23598: POP
// end ;
23599: LD_VAR 0 1
23603: RET
// export function MC_InitSides ( ) ; var i ; begin
23604: LD_INT 0
23606: PPUSH
23607: PPUSH
// if not mc_bases then
23608: LD_EXP 74
23612: NOT
23613: IFFALSE 23617
// exit ;
23615: GO 23691
// for i = 1 to mc_bases do
23617: LD_ADDR_VAR 0 2
23621: PUSH
23622: DOUBLE
23623: LD_INT 1
23625: DEC
23626: ST_TO_ADDR
23627: LD_EXP 74
23631: PUSH
23632: FOR_TO
23633: IFFALSE 23689
// if mc_bases [ i ] then
23635: LD_EXP 74
23639: PUSH
23640: LD_VAR 0 2
23644: ARRAY
23645: IFFALSE 23687
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23647: LD_ADDR_EXP 100
23651: PUSH
23652: LD_EXP 100
23656: PPUSH
23657: LD_VAR 0 2
23661: PPUSH
23662: LD_EXP 74
23666: PUSH
23667: LD_VAR 0 2
23671: ARRAY
23672: PUSH
23673: LD_INT 1
23675: ARRAY
23676: PPUSH
23677: CALL_OW 255
23681: PPUSH
23682: CALL_OW 1
23686: ST_TO_ADDR
23687: GO 23632
23689: POP
23690: POP
// end ;
23691: LD_VAR 0 1
23695: RET
// every 0 0$01 trigger skirmish do
23696: LD_EXP 72
23700: IFFALSE 23854
23702: GO 23704
23704: DISABLE
// begin enable ;
23705: ENABLE
// MC_CheckBuildings ( ) ;
23706: CALL 28352 0 0
// MC_CheckPeopleLife ( ) ;
23710: CALL 28477 0 0
// RaiseSailEvent ( 100 ) ;
23714: LD_INT 100
23716: PPUSH
23717: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23721: LD_INT 103
23723: PPUSH
23724: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23728: LD_INT 104
23730: PPUSH
23731: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23735: LD_INT 105
23737: PPUSH
23738: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
23742: LD_INT 106
23744: PPUSH
23745: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
23749: LD_INT 107
23751: PPUSH
23752: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
23756: LD_INT 108
23758: PPUSH
23759: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
23763: LD_INT 109
23765: PPUSH
23766: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
23770: LD_INT 110
23772: PPUSH
23773: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
23777: LD_INT 111
23779: PPUSH
23780: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
23784: LD_INT 112
23786: PPUSH
23787: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
23791: LD_INT 113
23793: PPUSH
23794: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
23798: LD_INT 120
23800: PPUSH
23801: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
23805: LD_INT 121
23807: PPUSH
23808: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
23812: LD_INT 122
23814: PPUSH
23815: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
23819: LD_INT 123
23821: PPUSH
23822: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
23826: LD_INT 124
23828: PPUSH
23829: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
23833: LD_INT 125
23835: PPUSH
23836: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
23840: LD_INT 126
23842: PPUSH
23843: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
23847: LD_INT 200
23849: PPUSH
23850: CALL_OW 427
// end ;
23854: END
// on SailEvent ( event ) do begin if event < 100 then
23855: LD_VAR 0 1
23859: PUSH
23860: LD_INT 100
23862: LESS
23863: IFFALSE 23874
// CustomEvent ( event ) ;
23865: LD_VAR 0 1
23869: PPUSH
23870: CALL 10195 0 1
// if event = 100 then
23874: LD_VAR 0 1
23878: PUSH
23879: LD_INT 100
23881: EQUAL
23882: IFFALSE 23888
// MC_ClassManager ( ) ;
23884: CALL 24280 0 0
// if event = 101 then
23888: LD_VAR 0 1
23892: PUSH
23893: LD_INT 101
23895: EQUAL
23896: IFFALSE 23902
// MC_RepairBuildings ( ) ;
23898: CALL 29073 0 0
// if event = 102 then
23902: LD_VAR 0 1
23906: PUSH
23907: LD_INT 102
23909: EQUAL
23910: IFFALSE 23916
// MC_Heal ( ) ;
23912: CALL 29805 0 0
// if event = 103 then
23916: LD_VAR 0 1
23920: PUSH
23921: LD_INT 103
23923: EQUAL
23924: IFFALSE 23930
// MC_Build ( ) ;
23926: CALL 30227 0 0
// if event = 104 then
23930: LD_VAR 0 1
23934: PUSH
23935: LD_INT 104
23937: EQUAL
23938: IFFALSE 23944
// MC_TurretWeapon ( ) ;
23940: CALL 31840 0 0
// if event = 105 then
23944: LD_VAR 0 1
23948: PUSH
23949: LD_INT 105
23951: EQUAL
23952: IFFALSE 23958
// MC_BuildUpgrade ( ) ;
23954: CALL 31391 0 0
// if event = 106 then
23958: LD_VAR 0 1
23962: PUSH
23963: LD_INT 106
23965: EQUAL
23966: IFFALSE 23972
// MC_PlantMines ( ) ;
23968: CALL 32270 0 0
// if event = 107 then
23972: LD_VAR 0 1
23976: PUSH
23977: LD_INT 107
23979: EQUAL
23980: IFFALSE 23986
// MC_CollectCrates ( ) ;
23982: CALL 33304 0 0
// if event = 108 then
23986: LD_VAR 0 1
23990: PUSH
23991: LD_INT 108
23993: EQUAL
23994: IFFALSE 24000
// MC_LinkRemoteControl ( ) ;
23996: CALL 35080 0 0
// if event = 109 then
24000: LD_VAR 0 1
24004: PUSH
24005: LD_INT 109
24007: EQUAL
24008: IFFALSE 24014
// MC_ProduceVehicle ( ) ;
24010: CALL 35261 0 0
// if event = 110 then
24014: LD_VAR 0 1
24018: PUSH
24019: LD_INT 110
24021: EQUAL
24022: IFFALSE 24028
// MC_SendAttack ( ) ;
24024: CALL 35727 0 0
// if event = 111 then
24028: LD_VAR 0 1
24032: PUSH
24033: LD_INT 111
24035: EQUAL
24036: IFFALSE 24042
// MC_Defend ( ) ;
24038: CALL 35835 0 0
// if event = 112 then
24042: LD_VAR 0 1
24046: PUSH
24047: LD_INT 112
24049: EQUAL
24050: IFFALSE 24056
// MC_Research ( ) ;
24052: CALL 36440 0 0
// if event = 113 then
24056: LD_VAR 0 1
24060: PUSH
24061: LD_INT 113
24063: EQUAL
24064: IFFALSE 24070
// MC_MinesTrigger ( ) ;
24066: CALL 37554 0 0
// if event = 120 then
24070: LD_VAR 0 1
24074: PUSH
24075: LD_INT 120
24077: EQUAL
24078: IFFALSE 24084
// MC_RepairVehicle ( ) ;
24080: CALL 37653 0 0
// if event = 121 then
24084: LD_VAR 0 1
24088: PUSH
24089: LD_INT 121
24091: EQUAL
24092: IFFALSE 24098
// MC_TameApe ( ) ;
24094: CALL 38383 0 0
// if event = 122 then
24098: LD_VAR 0 1
24102: PUSH
24103: LD_INT 122
24105: EQUAL
24106: IFFALSE 24112
// MC_ChangeApeClass ( ) ;
24108: CALL 39212 0 0
// if event = 123 then
24112: LD_VAR 0 1
24116: PUSH
24117: LD_INT 123
24119: EQUAL
24120: IFFALSE 24126
// MC_Bazooka ( ) ;
24122: CALL 39862 0 0
// if event = 124 then
24126: LD_VAR 0 1
24130: PUSH
24131: LD_INT 124
24133: EQUAL
24134: IFFALSE 24140
// MC_TeleportExit ( ) ;
24136: CALL 40060 0 0
// if event = 125 then
24140: LD_VAR 0 1
24144: PUSH
24145: LD_INT 125
24147: EQUAL
24148: IFFALSE 24154
// MC_Deposits ( ) ;
24150: CALL 40707 0 0
// if event = 126 then
24154: LD_VAR 0 1
24158: PUSH
24159: LD_INT 126
24161: EQUAL
24162: IFFALSE 24168
// MC_RemoteDriver ( ) ;
24164: CALL 41332 0 0
// if event = 200 then
24168: LD_VAR 0 1
24172: PUSH
24173: LD_INT 200
24175: EQUAL
24176: IFFALSE 24182
// MC_Idle ( ) ;
24178: CALL 43281 0 0
// end ;
24182: PPOPN 1
24184: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24185: LD_INT 0
24187: PPUSH
24188: PPUSH
// if not mc_bases [ base ] or not tag then
24189: LD_EXP 74
24193: PUSH
24194: LD_VAR 0 1
24198: ARRAY
24199: NOT
24200: PUSH
24201: LD_VAR 0 2
24205: NOT
24206: OR
24207: IFFALSE 24211
// exit ;
24209: GO 24275
// for i in mc_bases [ base ] union mc_ape [ base ] do
24211: LD_ADDR_VAR 0 4
24215: PUSH
24216: LD_EXP 74
24220: PUSH
24221: LD_VAR 0 1
24225: ARRAY
24226: PUSH
24227: LD_EXP 103
24231: PUSH
24232: LD_VAR 0 1
24236: ARRAY
24237: UNION
24238: PUSH
24239: FOR_IN
24240: IFFALSE 24273
// if GetTag ( i ) = tag then
24242: LD_VAR 0 4
24246: PPUSH
24247: CALL_OW 110
24251: PUSH
24252: LD_VAR 0 2
24256: EQUAL
24257: IFFALSE 24271
// SetTag ( i , 0 ) ;
24259: LD_VAR 0 4
24263: PPUSH
24264: LD_INT 0
24266: PPUSH
24267: CALL_OW 109
24271: GO 24239
24273: POP
24274: POP
// end ;
24275: LD_VAR 0 3
24279: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24280: LD_INT 0
24282: PPUSH
24283: PPUSH
24284: PPUSH
24285: PPUSH
24286: PPUSH
24287: PPUSH
24288: PPUSH
24289: PPUSH
// if not mc_bases then
24290: LD_EXP 74
24294: NOT
24295: IFFALSE 24299
// exit ;
24297: GO 24757
// for i = 1 to mc_bases do
24299: LD_ADDR_VAR 0 2
24303: PUSH
24304: DOUBLE
24305: LD_INT 1
24307: DEC
24308: ST_TO_ADDR
24309: LD_EXP 74
24313: PUSH
24314: FOR_TO
24315: IFFALSE 24755
// begin tmp := MC_ClassCheckReq ( i ) ;
24317: LD_ADDR_VAR 0 4
24321: PUSH
24322: LD_VAR 0 2
24326: PPUSH
24327: CALL 24762 0 1
24331: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24332: LD_ADDR_EXP 115
24336: PUSH
24337: LD_EXP 115
24341: PPUSH
24342: LD_VAR 0 2
24346: PPUSH
24347: LD_VAR 0 4
24351: PPUSH
24352: CALL_OW 1
24356: ST_TO_ADDR
// if not tmp then
24357: LD_VAR 0 4
24361: NOT
24362: IFFALSE 24366
// continue ;
24364: GO 24314
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24366: LD_ADDR_VAR 0 6
24370: PUSH
24371: LD_EXP 74
24375: PUSH
24376: LD_VAR 0 2
24380: ARRAY
24381: PPUSH
24382: LD_INT 2
24384: PUSH
24385: LD_INT 30
24387: PUSH
24388: LD_INT 4
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: PUSH
24395: LD_INT 30
24397: PUSH
24398: LD_INT 5
24400: PUSH
24401: EMPTY
24402: LIST
24403: LIST
24404: PUSH
24405: EMPTY
24406: LIST
24407: LIST
24408: LIST
24409: PPUSH
24410: CALL_OW 72
24414: PUSH
24415: LD_EXP 74
24419: PUSH
24420: LD_VAR 0 2
24424: ARRAY
24425: PPUSH
24426: LD_INT 2
24428: PUSH
24429: LD_INT 30
24431: PUSH
24432: LD_INT 0
24434: PUSH
24435: EMPTY
24436: LIST
24437: LIST
24438: PUSH
24439: LD_INT 30
24441: PUSH
24442: LD_INT 1
24444: PUSH
24445: EMPTY
24446: LIST
24447: LIST
24448: PUSH
24449: EMPTY
24450: LIST
24451: LIST
24452: LIST
24453: PPUSH
24454: CALL_OW 72
24458: PUSH
24459: LD_EXP 74
24463: PUSH
24464: LD_VAR 0 2
24468: ARRAY
24469: PPUSH
24470: LD_INT 30
24472: PUSH
24473: LD_INT 3
24475: PUSH
24476: EMPTY
24477: LIST
24478: LIST
24479: PPUSH
24480: CALL_OW 72
24484: PUSH
24485: LD_EXP 74
24489: PUSH
24490: LD_VAR 0 2
24494: ARRAY
24495: PPUSH
24496: LD_INT 2
24498: PUSH
24499: LD_INT 30
24501: PUSH
24502: LD_INT 6
24504: PUSH
24505: EMPTY
24506: LIST
24507: LIST
24508: PUSH
24509: LD_INT 30
24511: PUSH
24512: LD_INT 7
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: PUSH
24519: LD_INT 30
24521: PUSH
24522: LD_INT 8
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: PUSH
24529: EMPTY
24530: LIST
24531: LIST
24532: LIST
24533: LIST
24534: PPUSH
24535: CALL_OW 72
24539: PUSH
24540: EMPTY
24541: LIST
24542: LIST
24543: LIST
24544: LIST
24545: ST_TO_ADDR
// for j = 1 to 4 do
24546: LD_ADDR_VAR 0 3
24550: PUSH
24551: DOUBLE
24552: LD_INT 1
24554: DEC
24555: ST_TO_ADDR
24556: LD_INT 4
24558: PUSH
24559: FOR_TO
24560: IFFALSE 24751
// begin if not tmp [ j ] then
24562: LD_VAR 0 4
24566: PUSH
24567: LD_VAR 0 3
24571: ARRAY
24572: NOT
24573: IFFALSE 24577
// continue ;
24575: GO 24559
// for p in tmp [ j ] do
24577: LD_ADDR_VAR 0 5
24581: PUSH
24582: LD_VAR 0 4
24586: PUSH
24587: LD_VAR 0 3
24591: ARRAY
24592: PUSH
24593: FOR_IN
24594: IFFALSE 24747
// begin if not b [ j ] then
24596: LD_VAR 0 6
24600: PUSH
24601: LD_VAR 0 3
24605: ARRAY
24606: NOT
24607: IFFALSE 24611
// break ;
24609: GO 24747
// e := 0 ;
24611: LD_ADDR_VAR 0 7
24615: PUSH
24616: LD_INT 0
24618: ST_TO_ADDR
// for k in b [ j ] do
24619: LD_ADDR_VAR 0 8
24623: PUSH
24624: LD_VAR 0 6
24628: PUSH
24629: LD_VAR 0 3
24633: ARRAY
24634: PUSH
24635: FOR_IN
24636: IFFALSE 24663
// if IsNotFull ( k ) then
24638: LD_VAR 0 8
24642: PPUSH
24643: CALL 54664 0 1
24647: IFFALSE 24661
// begin e := k ;
24649: LD_ADDR_VAR 0 7
24653: PUSH
24654: LD_VAR 0 8
24658: ST_TO_ADDR
// break ;
24659: GO 24663
// end ;
24661: GO 24635
24663: POP
24664: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24665: LD_VAR 0 7
24669: PUSH
24670: LD_VAR 0 5
24674: PPUSH
24675: LD_VAR 0 7
24679: PPUSH
24680: CALL 91783 0 2
24684: NOT
24685: AND
24686: IFFALSE 24745
// begin if IsInUnit ( p ) then
24688: LD_VAR 0 5
24692: PPUSH
24693: CALL_OW 310
24697: IFFALSE 24708
// ComExitBuilding ( p ) ;
24699: LD_VAR 0 5
24703: PPUSH
24704: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24708: LD_VAR 0 5
24712: PPUSH
24713: LD_VAR 0 7
24717: PPUSH
24718: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24722: LD_VAR 0 5
24726: PPUSH
24727: LD_VAR 0 3
24731: PPUSH
24732: CALL_OW 183
// AddComExitBuilding ( p ) ;
24736: LD_VAR 0 5
24740: PPUSH
24741: CALL_OW 182
// end ; end ;
24745: GO 24593
24747: POP
24748: POP
// end ;
24749: GO 24559
24751: POP
24752: POP
// end ;
24753: GO 24314
24755: POP
24756: POP
// end ;
24757: LD_VAR 0 1
24761: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
24762: LD_INT 0
24764: PPUSH
24765: PPUSH
24766: PPUSH
24767: PPUSH
24768: PPUSH
24769: PPUSH
24770: PPUSH
24771: PPUSH
24772: PPUSH
24773: PPUSH
24774: PPUSH
24775: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24776: LD_VAR 0 1
24780: NOT
24781: PUSH
24782: LD_EXP 74
24786: PUSH
24787: LD_VAR 0 1
24791: ARRAY
24792: NOT
24793: OR
24794: PUSH
24795: LD_EXP 74
24799: PUSH
24800: LD_VAR 0 1
24804: ARRAY
24805: PPUSH
24806: LD_INT 2
24808: PUSH
24809: LD_INT 30
24811: PUSH
24812: LD_INT 0
24814: PUSH
24815: EMPTY
24816: LIST
24817: LIST
24818: PUSH
24819: LD_INT 30
24821: PUSH
24822: LD_INT 1
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PUSH
24829: EMPTY
24830: LIST
24831: LIST
24832: LIST
24833: PPUSH
24834: CALL_OW 72
24838: NOT
24839: OR
24840: IFFALSE 24844
// exit ;
24842: GO 28347
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24844: LD_ADDR_VAR 0 4
24848: PUSH
24849: LD_EXP 74
24853: PUSH
24854: LD_VAR 0 1
24858: ARRAY
24859: PPUSH
24860: LD_INT 2
24862: PUSH
24863: LD_INT 25
24865: PUSH
24866: LD_INT 1
24868: PUSH
24869: EMPTY
24870: LIST
24871: LIST
24872: PUSH
24873: LD_INT 25
24875: PUSH
24876: LD_INT 2
24878: PUSH
24879: EMPTY
24880: LIST
24881: LIST
24882: PUSH
24883: LD_INT 25
24885: PUSH
24886: LD_INT 3
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PUSH
24893: LD_INT 25
24895: PUSH
24896: LD_INT 4
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: PUSH
24903: LD_INT 25
24905: PUSH
24906: LD_INT 5
24908: PUSH
24909: EMPTY
24910: LIST
24911: LIST
24912: PUSH
24913: LD_INT 25
24915: PUSH
24916: LD_INT 8
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: PUSH
24923: LD_INT 25
24925: PUSH
24926: LD_INT 9
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: LIST
24937: LIST
24938: LIST
24939: LIST
24940: LIST
24941: LIST
24942: PPUSH
24943: CALL_OW 72
24947: ST_TO_ADDR
// if not tmp then
24948: LD_VAR 0 4
24952: NOT
24953: IFFALSE 24957
// exit ;
24955: GO 28347
// for i in tmp do
24957: LD_ADDR_VAR 0 3
24961: PUSH
24962: LD_VAR 0 4
24966: PUSH
24967: FOR_IN
24968: IFFALSE 24999
// if GetTag ( i ) then
24970: LD_VAR 0 3
24974: PPUSH
24975: CALL_OW 110
24979: IFFALSE 24997
// tmp := tmp diff i ;
24981: LD_ADDR_VAR 0 4
24985: PUSH
24986: LD_VAR 0 4
24990: PUSH
24991: LD_VAR 0 3
24995: DIFF
24996: ST_TO_ADDR
24997: GO 24967
24999: POP
25000: POP
// if not tmp then
25001: LD_VAR 0 4
25005: NOT
25006: IFFALSE 25010
// exit ;
25008: GO 28347
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25010: LD_ADDR_VAR 0 5
25014: PUSH
25015: LD_EXP 74
25019: PUSH
25020: LD_VAR 0 1
25024: ARRAY
25025: PPUSH
25026: LD_INT 2
25028: PUSH
25029: LD_INT 25
25031: PUSH
25032: LD_INT 1
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: PUSH
25039: LD_INT 25
25041: PUSH
25042: LD_INT 5
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: LD_INT 25
25051: PUSH
25052: LD_INT 8
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: PUSH
25059: LD_INT 25
25061: PUSH
25062: LD_INT 9
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: PUSH
25069: EMPTY
25070: LIST
25071: LIST
25072: LIST
25073: LIST
25074: LIST
25075: PPUSH
25076: CALL_OW 72
25080: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25081: LD_ADDR_VAR 0 6
25085: PUSH
25086: LD_EXP 74
25090: PUSH
25091: LD_VAR 0 1
25095: ARRAY
25096: PPUSH
25097: LD_INT 25
25099: PUSH
25100: LD_INT 2
25102: PUSH
25103: EMPTY
25104: LIST
25105: LIST
25106: PPUSH
25107: CALL_OW 72
25111: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25112: LD_ADDR_VAR 0 7
25116: PUSH
25117: LD_EXP 74
25121: PUSH
25122: LD_VAR 0 1
25126: ARRAY
25127: PPUSH
25128: LD_INT 25
25130: PUSH
25131: LD_INT 3
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PPUSH
25138: CALL_OW 72
25142: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25143: LD_ADDR_VAR 0 8
25147: PUSH
25148: LD_EXP 74
25152: PUSH
25153: LD_VAR 0 1
25157: ARRAY
25158: PPUSH
25159: LD_INT 25
25161: PUSH
25162: LD_INT 4
25164: PUSH
25165: EMPTY
25166: LIST
25167: LIST
25168: PUSH
25169: LD_INT 24
25171: PUSH
25172: LD_INT 251
25174: PUSH
25175: EMPTY
25176: LIST
25177: LIST
25178: PUSH
25179: EMPTY
25180: LIST
25181: LIST
25182: PPUSH
25183: CALL_OW 72
25187: ST_TO_ADDR
// if mc_scan [ base ] then
25188: LD_EXP 97
25192: PUSH
25193: LD_VAR 0 1
25197: ARRAY
25198: IFFALSE 25659
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25200: LD_ADDR_EXP 116
25204: PUSH
25205: LD_EXP 116
25209: PPUSH
25210: LD_VAR 0 1
25214: PPUSH
25215: LD_INT 4
25217: PPUSH
25218: CALL_OW 1
25222: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25223: LD_ADDR_VAR 0 12
25227: PUSH
25228: LD_EXP 74
25232: PUSH
25233: LD_VAR 0 1
25237: ARRAY
25238: PPUSH
25239: LD_INT 2
25241: PUSH
25242: LD_INT 30
25244: PUSH
25245: LD_INT 4
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: LD_INT 30
25254: PUSH
25255: LD_INT 5
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PUSH
25262: EMPTY
25263: LIST
25264: LIST
25265: LIST
25266: PPUSH
25267: CALL_OW 72
25271: ST_TO_ADDR
// if not b then
25272: LD_VAR 0 12
25276: NOT
25277: IFFALSE 25281
// exit ;
25279: GO 28347
// p := [ ] ;
25281: LD_ADDR_VAR 0 11
25285: PUSH
25286: EMPTY
25287: ST_TO_ADDR
// if sci >= 2 then
25288: LD_VAR 0 8
25292: PUSH
25293: LD_INT 2
25295: GREATEREQUAL
25296: IFFALSE 25327
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25298: LD_ADDR_VAR 0 8
25302: PUSH
25303: LD_VAR 0 8
25307: PUSH
25308: LD_INT 1
25310: ARRAY
25311: PUSH
25312: LD_VAR 0 8
25316: PUSH
25317: LD_INT 2
25319: ARRAY
25320: PUSH
25321: EMPTY
25322: LIST
25323: LIST
25324: ST_TO_ADDR
25325: GO 25388
// if sci = 1 then
25327: LD_VAR 0 8
25331: PUSH
25332: LD_INT 1
25334: EQUAL
25335: IFFALSE 25356
// sci := [ sci [ 1 ] ] else
25337: LD_ADDR_VAR 0 8
25341: PUSH
25342: LD_VAR 0 8
25346: PUSH
25347: LD_INT 1
25349: ARRAY
25350: PUSH
25351: EMPTY
25352: LIST
25353: ST_TO_ADDR
25354: GO 25388
// if sci = 0 then
25356: LD_VAR 0 8
25360: PUSH
25361: LD_INT 0
25363: EQUAL
25364: IFFALSE 25388
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25366: LD_ADDR_VAR 0 11
25370: PUSH
25371: LD_VAR 0 4
25375: PPUSH
25376: LD_INT 4
25378: PPUSH
25379: CALL 91646 0 2
25383: PUSH
25384: LD_INT 1
25386: ARRAY
25387: ST_TO_ADDR
// if eng > 4 then
25388: LD_VAR 0 6
25392: PUSH
25393: LD_INT 4
25395: GREATER
25396: IFFALSE 25442
// for i = eng downto 4 do
25398: LD_ADDR_VAR 0 3
25402: PUSH
25403: DOUBLE
25404: LD_VAR 0 6
25408: INC
25409: ST_TO_ADDR
25410: LD_INT 4
25412: PUSH
25413: FOR_DOWNTO
25414: IFFALSE 25440
// eng := eng diff eng [ i ] ;
25416: LD_ADDR_VAR 0 6
25420: PUSH
25421: LD_VAR 0 6
25425: PUSH
25426: LD_VAR 0 6
25430: PUSH
25431: LD_VAR 0 3
25435: ARRAY
25436: DIFF
25437: ST_TO_ADDR
25438: GO 25413
25440: POP
25441: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25442: LD_ADDR_VAR 0 4
25446: PUSH
25447: LD_VAR 0 4
25451: PUSH
25452: LD_VAR 0 5
25456: PUSH
25457: LD_VAR 0 6
25461: UNION
25462: PUSH
25463: LD_VAR 0 7
25467: UNION
25468: PUSH
25469: LD_VAR 0 8
25473: UNION
25474: DIFF
25475: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25476: LD_ADDR_VAR 0 13
25480: PUSH
25481: LD_EXP 74
25485: PUSH
25486: LD_VAR 0 1
25490: ARRAY
25491: PPUSH
25492: LD_INT 2
25494: PUSH
25495: LD_INT 30
25497: PUSH
25498: LD_INT 32
25500: PUSH
25501: EMPTY
25502: LIST
25503: LIST
25504: PUSH
25505: LD_INT 30
25507: PUSH
25508: LD_INT 31
25510: PUSH
25511: EMPTY
25512: LIST
25513: LIST
25514: PUSH
25515: EMPTY
25516: LIST
25517: LIST
25518: LIST
25519: PPUSH
25520: CALL_OW 72
25524: PUSH
25525: LD_EXP 74
25529: PUSH
25530: LD_VAR 0 1
25534: ARRAY
25535: PPUSH
25536: LD_INT 2
25538: PUSH
25539: LD_INT 30
25541: PUSH
25542: LD_INT 4
25544: PUSH
25545: EMPTY
25546: LIST
25547: LIST
25548: PUSH
25549: LD_INT 30
25551: PUSH
25552: LD_INT 5
25554: PUSH
25555: EMPTY
25556: LIST
25557: LIST
25558: PUSH
25559: EMPTY
25560: LIST
25561: LIST
25562: LIST
25563: PPUSH
25564: CALL_OW 72
25568: PUSH
25569: LD_INT 6
25571: MUL
25572: PLUS
25573: ST_TO_ADDR
// if bcount < tmp then
25574: LD_VAR 0 13
25578: PUSH
25579: LD_VAR 0 4
25583: LESS
25584: IFFALSE 25630
// for i = tmp downto bcount do
25586: LD_ADDR_VAR 0 3
25590: PUSH
25591: DOUBLE
25592: LD_VAR 0 4
25596: INC
25597: ST_TO_ADDR
25598: LD_VAR 0 13
25602: PUSH
25603: FOR_DOWNTO
25604: IFFALSE 25628
// tmp := Delete ( tmp , tmp ) ;
25606: LD_ADDR_VAR 0 4
25610: PUSH
25611: LD_VAR 0 4
25615: PPUSH
25616: LD_VAR 0 4
25620: PPUSH
25621: CALL_OW 3
25625: ST_TO_ADDR
25626: GO 25603
25628: POP
25629: POP
// result := [ tmp , 0 , 0 , p ] ;
25630: LD_ADDR_VAR 0 2
25634: PUSH
25635: LD_VAR 0 4
25639: PUSH
25640: LD_INT 0
25642: PUSH
25643: LD_INT 0
25645: PUSH
25646: LD_VAR 0 11
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: LIST
25655: LIST
25656: ST_TO_ADDR
// exit ;
25657: GO 28347
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25659: LD_EXP 74
25663: PUSH
25664: LD_VAR 0 1
25668: ARRAY
25669: PPUSH
25670: LD_INT 2
25672: PUSH
25673: LD_INT 30
25675: PUSH
25676: LD_INT 6
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: LD_INT 30
25685: PUSH
25686: LD_INT 7
25688: PUSH
25689: EMPTY
25690: LIST
25691: LIST
25692: PUSH
25693: LD_INT 30
25695: PUSH
25696: LD_INT 8
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: EMPTY
25704: LIST
25705: LIST
25706: LIST
25707: LIST
25708: PPUSH
25709: CALL_OW 72
25713: NOT
25714: PUSH
25715: LD_EXP 74
25719: PUSH
25720: LD_VAR 0 1
25724: ARRAY
25725: PPUSH
25726: LD_INT 30
25728: PUSH
25729: LD_INT 3
25731: PUSH
25732: EMPTY
25733: LIST
25734: LIST
25735: PPUSH
25736: CALL_OW 72
25740: NOT
25741: AND
25742: IFFALSE 25814
// begin if eng = tmp then
25744: LD_VAR 0 6
25748: PUSH
25749: LD_VAR 0 4
25753: EQUAL
25754: IFFALSE 25758
// exit ;
25756: GO 28347
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
25758: LD_ADDR_EXP 116
25762: PUSH
25763: LD_EXP 116
25767: PPUSH
25768: LD_VAR 0 1
25772: PPUSH
25773: LD_INT 1
25775: PPUSH
25776: CALL_OW 1
25780: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
25781: LD_ADDR_VAR 0 2
25785: PUSH
25786: LD_INT 0
25788: PUSH
25789: LD_VAR 0 4
25793: PUSH
25794: LD_VAR 0 6
25798: DIFF
25799: PUSH
25800: LD_INT 0
25802: PUSH
25803: LD_INT 0
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: LIST
25810: LIST
25811: ST_TO_ADDR
// exit ;
25812: GO 28347
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25814: LD_EXP 101
25818: PUSH
25819: LD_EXP 100
25823: PUSH
25824: LD_VAR 0 1
25828: ARRAY
25829: ARRAY
25830: PUSH
25831: LD_EXP 74
25835: PUSH
25836: LD_VAR 0 1
25840: ARRAY
25841: PPUSH
25842: LD_INT 2
25844: PUSH
25845: LD_INT 30
25847: PUSH
25848: LD_INT 6
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PUSH
25855: LD_INT 30
25857: PUSH
25858: LD_INT 7
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: PUSH
25865: LD_INT 30
25867: PUSH
25868: LD_INT 8
25870: PUSH
25871: EMPTY
25872: LIST
25873: LIST
25874: PUSH
25875: EMPTY
25876: LIST
25877: LIST
25878: LIST
25879: LIST
25880: PPUSH
25881: CALL_OW 72
25885: AND
25886: PUSH
25887: LD_EXP 74
25891: PUSH
25892: LD_VAR 0 1
25896: ARRAY
25897: PPUSH
25898: LD_INT 30
25900: PUSH
25901: LD_INT 3
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: PPUSH
25908: CALL_OW 72
25912: NOT
25913: AND
25914: IFFALSE 26128
// begin if sci >= 6 then
25916: LD_VAR 0 8
25920: PUSH
25921: LD_INT 6
25923: GREATEREQUAL
25924: IFFALSE 25928
// exit ;
25926: GO 28347
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
25928: LD_ADDR_EXP 116
25932: PUSH
25933: LD_EXP 116
25937: PPUSH
25938: LD_VAR 0 1
25942: PPUSH
25943: LD_INT 2
25945: PPUSH
25946: CALL_OW 1
25950: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
25951: LD_ADDR_VAR 0 9
25955: PUSH
25956: LD_VAR 0 4
25960: PUSH
25961: LD_VAR 0 8
25965: DIFF
25966: PPUSH
25967: LD_INT 4
25969: PPUSH
25970: CALL 91646 0 2
25974: ST_TO_ADDR
// p := [ ] ;
25975: LD_ADDR_VAR 0 11
25979: PUSH
25980: EMPTY
25981: ST_TO_ADDR
// if sci < 6 and sort > 6 then
25982: LD_VAR 0 8
25986: PUSH
25987: LD_INT 6
25989: LESS
25990: PUSH
25991: LD_VAR 0 9
25995: PUSH
25996: LD_INT 6
25998: GREATER
25999: AND
26000: IFFALSE 26081
// begin for i = 1 to 6 - sci do
26002: LD_ADDR_VAR 0 3
26006: PUSH
26007: DOUBLE
26008: LD_INT 1
26010: DEC
26011: ST_TO_ADDR
26012: LD_INT 6
26014: PUSH
26015: LD_VAR 0 8
26019: MINUS
26020: PUSH
26021: FOR_TO
26022: IFFALSE 26077
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26024: LD_ADDR_VAR 0 11
26028: PUSH
26029: LD_VAR 0 11
26033: PPUSH
26034: LD_VAR 0 11
26038: PUSH
26039: LD_INT 1
26041: PLUS
26042: PPUSH
26043: LD_VAR 0 9
26047: PUSH
26048: LD_INT 1
26050: ARRAY
26051: PPUSH
26052: CALL_OW 2
26056: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26057: LD_ADDR_VAR 0 9
26061: PUSH
26062: LD_VAR 0 9
26066: PPUSH
26067: LD_INT 1
26069: PPUSH
26070: CALL_OW 3
26074: ST_TO_ADDR
// end ;
26075: GO 26021
26077: POP
26078: POP
// end else
26079: GO 26101
// if sort then
26081: LD_VAR 0 9
26085: IFFALSE 26101
// p := sort [ 1 ] ;
26087: LD_ADDR_VAR 0 11
26091: PUSH
26092: LD_VAR 0 9
26096: PUSH
26097: LD_INT 1
26099: ARRAY
26100: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26101: LD_ADDR_VAR 0 2
26105: PUSH
26106: LD_INT 0
26108: PUSH
26109: LD_INT 0
26111: PUSH
26112: LD_INT 0
26114: PUSH
26115: LD_VAR 0 11
26119: PUSH
26120: EMPTY
26121: LIST
26122: LIST
26123: LIST
26124: LIST
26125: ST_TO_ADDR
// exit ;
26126: GO 28347
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26128: LD_EXP 101
26132: PUSH
26133: LD_EXP 100
26137: PUSH
26138: LD_VAR 0 1
26142: ARRAY
26143: ARRAY
26144: PUSH
26145: LD_EXP 74
26149: PUSH
26150: LD_VAR 0 1
26154: ARRAY
26155: PPUSH
26156: LD_INT 2
26158: PUSH
26159: LD_INT 30
26161: PUSH
26162: LD_INT 6
26164: PUSH
26165: EMPTY
26166: LIST
26167: LIST
26168: PUSH
26169: LD_INT 30
26171: PUSH
26172: LD_INT 7
26174: PUSH
26175: EMPTY
26176: LIST
26177: LIST
26178: PUSH
26179: LD_INT 30
26181: PUSH
26182: LD_INT 8
26184: PUSH
26185: EMPTY
26186: LIST
26187: LIST
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: LIST
26193: LIST
26194: PPUSH
26195: CALL_OW 72
26199: AND
26200: PUSH
26201: LD_EXP 74
26205: PUSH
26206: LD_VAR 0 1
26210: ARRAY
26211: PPUSH
26212: LD_INT 30
26214: PUSH
26215: LD_INT 3
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PPUSH
26222: CALL_OW 72
26226: AND
26227: IFFALSE 26961
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26229: LD_ADDR_EXP 116
26233: PUSH
26234: LD_EXP 116
26238: PPUSH
26239: LD_VAR 0 1
26243: PPUSH
26244: LD_INT 3
26246: PPUSH
26247: CALL_OW 1
26251: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26252: LD_ADDR_VAR 0 2
26256: PUSH
26257: LD_INT 0
26259: PUSH
26260: LD_INT 0
26262: PUSH
26263: LD_INT 0
26265: PUSH
26266: LD_INT 0
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: LIST
26273: LIST
26274: ST_TO_ADDR
// if not eng then
26275: LD_VAR 0 6
26279: NOT
26280: IFFALSE 26343
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26282: LD_ADDR_VAR 0 11
26286: PUSH
26287: LD_VAR 0 4
26291: PPUSH
26292: LD_INT 2
26294: PPUSH
26295: CALL 91646 0 2
26299: PUSH
26300: LD_INT 1
26302: ARRAY
26303: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26304: LD_ADDR_VAR 0 2
26308: PUSH
26309: LD_VAR 0 2
26313: PPUSH
26314: LD_INT 2
26316: PPUSH
26317: LD_VAR 0 11
26321: PPUSH
26322: CALL_OW 1
26326: ST_TO_ADDR
// tmp := tmp diff p ;
26327: LD_ADDR_VAR 0 4
26331: PUSH
26332: LD_VAR 0 4
26336: PUSH
26337: LD_VAR 0 11
26341: DIFF
26342: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26343: LD_VAR 0 4
26347: PUSH
26348: LD_VAR 0 8
26352: PUSH
26353: LD_INT 6
26355: LESS
26356: AND
26357: IFFALSE 26545
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26359: LD_ADDR_VAR 0 9
26363: PUSH
26364: LD_VAR 0 4
26368: PUSH
26369: LD_VAR 0 8
26373: PUSH
26374: LD_VAR 0 7
26378: UNION
26379: DIFF
26380: PPUSH
26381: LD_INT 4
26383: PPUSH
26384: CALL 91646 0 2
26388: ST_TO_ADDR
// p := [ ] ;
26389: LD_ADDR_VAR 0 11
26393: PUSH
26394: EMPTY
26395: ST_TO_ADDR
// if sort then
26396: LD_VAR 0 9
26400: IFFALSE 26516
// for i = 1 to 6 - sci do
26402: LD_ADDR_VAR 0 3
26406: PUSH
26407: DOUBLE
26408: LD_INT 1
26410: DEC
26411: ST_TO_ADDR
26412: LD_INT 6
26414: PUSH
26415: LD_VAR 0 8
26419: MINUS
26420: PUSH
26421: FOR_TO
26422: IFFALSE 26514
// begin if i = sort then
26424: LD_VAR 0 3
26428: PUSH
26429: LD_VAR 0 9
26433: EQUAL
26434: IFFALSE 26438
// break ;
26436: GO 26514
// if GetClass ( i ) = 4 then
26438: LD_VAR 0 3
26442: PPUSH
26443: CALL_OW 257
26447: PUSH
26448: LD_INT 4
26450: EQUAL
26451: IFFALSE 26455
// continue ;
26453: GO 26421
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26455: LD_ADDR_VAR 0 11
26459: PUSH
26460: LD_VAR 0 11
26464: PPUSH
26465: LD_VAR 0 11
26469: PUSH
26470: LD_INT 1
26472: PLUS
26473: PPUSH
26474: LD_VAR 0 9
26478: PUSH
26479: LD_VAR 0 3
26483: ARRAY
26484: PPUSH
26485: CALL_OW 2
26489: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26490: LD_ADDR_VAR 0 4
26494: PUSH
26495: LD_VAR 0 4
26499: PUSH
26500: LD_VAR 0 9
26504: PUSH
26505: LD_VAR 0 3
26509: ARRAY
26510: DIFF
26511: ST_TO_ADDR
// end ;
26512: GO 26421
26514: POP
26515: POP
// if p then
26516: LD_VAR 0 11
26520: IFFALSE 26545
// result := Replace ( result , 4 , p ) ;
26522: LD_ADDR_VAR 0 2
26526: PUSH
26527: LD_VAR 0 2
26531: PPUSH
26532: LD_INT 4
26534: PPUSH
26535: LD_VAR 0 11
26539: PPUSH
26540: CALL_OW 1
26544: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26545: LD_VAR 0 4
26549: PUSH
26550: LD_VAR 0 7
26554: PUSH
26555: LD_INT 6
26557: LESS
26558: AND
26559: IFFALSE 26747
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26561: LD_ADDR_VAR 0 9
26565: PUSH
26566: LD_VAR 0 4
26570: PUSH
26571: LD_VAR 0 8
26575: PUSH
26576: LD_VAR 0 7
26580: UNION
26581: DIFF
26582: PPUSH
26583: LD_INT 3
26585: PPUSH
26586: CALL 91646 0 2
26590: ST_TO_ADDR
// p := [ ] ;
26591: LD_ADDR_VAR 0 11
26595: PUSH
26596: EMPTY
26597: ST_TO_ADDR
// if sort then
26598: LD_VAR 0 9
26602: IFFALSE 26718
// for i = 1 to 6 - mech do
26604: LD_ADDR_VAR 0 3
26608: PUSH
26609: DOUBLE
26610: LD_INT 1
26612: DEC
26613: ST_TO_ADDR
26614: LD_INT 6
26616: PUSH
26617: LD_VAR 0 7
26621: MINUS
26622: PUSH
26623: FOR_TO
26624: IFFALSE 26716
// begin if i = sort then
26626: LD_VAR 0 3
26630: PUSH
26631: LD_VAR 0 9
26635: EQUAL
26636: IFFALSE 26640
// break ;
26638: GO 26716
// if GetClass ( i ) = 3 then
26640: LD_VAR 0 3
26644: PPUSH
26645: CALL_OW 257
26649: PUSH
26650: LD_INT 3
26652: EQUAL
26653: IFFALSE 26657
// continue ;
26655: GO 26623
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26657: LD_ADDR_VAR 0 11
26661: PUSH
26662: LD_VAR 0 11
26666: PPUSH
26667: LD_VAR 0 11
26671: PUSH
26672: LD_INT 1
26674: PLUS
26675: PPUSH
26676: LD_VAR 0 9
26680: PUSH
26681: LD_VAR 0 3
26685: ARRAY
26686: PPUSH
26687: CALL_OW 2
26691: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26692: LD_ADDR_VAR 0 4
26696: PUSH
26697: LD_VAR 0 4
26701: PUSH
26702: LD_VAR 0 9
26706: PUSH
26707: LD_VAR 0 3
26711: ARRAY
26712: DIFF
26713: ST_TO_ADDR
// end ;
26714: GO 26623
26716: POP
26717: POP
// if p then
26718: LD_VAR 0 11
26722: IFFALSE 26747
// result := Replace ( result , 3 , p ) ;
26724: LD_ADDR_VAR 0 2
26728: PUSH
26729: LD_VAR 0 2
26733: PPUSH
26734: LD_INT 3
26736: PPUSH
26737: LD_VAR 0 11
26741: PPUSH
26742: CALL_OW 1
26746: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
26747: LD_VAR 0 4
26751: PUSH
26752: LD_INT 6
26754: GREATER
26755: PUSH
26756: LD_VAR 0 6
26760: PUSH
26761: LD_INT 6
26763: LESS
26764: AND
26765: IFFALSE 26959
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26767: LD_ADDR_VAR 0 9
26771: PUSH
26772: LD_VAR 0 4
26776: PUSH
26777: LD_VAR 0 8
26781: PUSH
26782: LD_VAR 0 7
26786: UNION
26787: PUSH
26788: LD_VAR 0 6
26792: UNION
26793: DIFF
26794: PPUSH
26795: LD_INT 2
26797: PPUSH
26798: CALL 91646 0 2
26802: ST_TO_ADDR
// p := [ ] ;
26803: LD_ADDR_VAR 0 11
26807: PUSH
26808: EMPTY
26809: ST_TO_ADDR
// if sort then
26810: LD_VAR 0 9
26814: IFFALSE 26930
// for i = 1 to 6 - eng do
26816: LD_ADDR_VAR 0 3
26820: PUSH
26821: DOUBLE
26822: LD_INT 1
26824: DEC
26825: ST_TO_ADDR
26826: LD_INT 6
26828: PUSH
26829: LD_VAR 0 6
26833: MINUS
26834: PUSH
26835: FOR_TO
26836: IFFALSE 26928
// begin if i = sort then
26838: LD_VAR 0 3
26842: PUSH
26843: LD_VAR 0 9
26847: EQUAL
26848: IFFALSE 26852
// break ;
26850: GO 26928
// if GetClass ( i ) = 2 then
26852: LD_VAR 0 3
26856: PPUSH
26857: CALL_OW 257
26861: PUSH
26862: LD_INT 2
26864: EQUAL
26865: IFFALSE 26869
// continue ;
26867: GO 26835
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26869: LD_ADDR_VAR 0 11
26873: PUSH
26874: LD_VAR 0 11
26878: PPUSH
26879: LD_VAR 0 11
26883: PUSH
26884: LD_INT 1
26886: PLUS
26887: PPUSH
26888: LD_VAR 0 9
26892: PUSH
26893: LD_VAR 0 3
26897: ARRAY
26898: PPUSH
26899: CALL_OW 2
26903: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26904: LD_ADDR_VAR 0 4
26908: PUSH
26909: LD_VAR 0 4
26913: PUSH
26914: LD_VAR 0 9
26918: PUSH
26919: LD_VAR 0 3
26923: ARRAY
26924: DIFF
26925: ST_TO_ADDR
// end ;
26926: GO 26835
26928: POP
26929: POP
// if p then
26930: LD_VAR 0 11
26934: IFFALSE 26959
// result := Replace ( result , 2 , p ) ;
26936: LD_ADDR_VAR 0 2
26940: PUSH
26941: LD_VAR 0 2
26945: PPUSH
26946: LD_INT 2
26948: PPUSH
26949: LD_VAR 0 11
26953: PPUSH
26954: CALL_OW 1
26958: ST_TO_ADDR
// end ; exit ;
26959: GO 28347
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
26961: LD_EXP 101
26965: PUSH
26966: LD_EXP 100
26970: PUSH
26971: LD_VAR 0 1
26975: ARRAY
26976: ARRAY
26977: NOT
26978: PUSH
26979: LD_EXP 74
26983: PUSH
26984: LD_VAR 0 1
26988: ARRAY
26989: PPUSH
26990: LD_INT 30
26992: PUSH
26993: LD_INT 3
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: PPUSH
27000: CALL_OW 72
27004: AND
27005: PUSH
27006: LD_EXP 79
27010: PUSH
27011: LD_VAR 0 1
27015: ARRAY
27016: AND
27017: IFFALSE 27625
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27019: LD_ADDR_EXP 116
27023: PUSH
27024: LD_EXP 116
27028: PPUSH
27029: LD_VAR 0 1
27033: PPUSH
27034: LD_INT 5
27036: PPUSH
27037: CALL_OW 1
27041: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27042: LD_ADDR_VAR 0 2
27046: PUSH
27047: LD_INT 0
27049: PUSH
27050: LD_INT 0
27052: PUSH
27053: LD_INT 0
27055: PUSH
27056: LD_INT 0
27058: PUSH
27059: EMPTY
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: ST_TO_ADDR
// if sci > 1 then
27065: LD_VAR 0 8
27069: PUSH
27070: LD_INT 1
27072: GREATER
27073: IFFALSE 27101
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27075: LD_ADDR_VAR 0 4
27079: PUSH
27080: LD_VAR 0 4
27084: PUSH
27085: LD_VAR 0 8
27089: PUSH
27090: LD_VAR 0 8
27094: PUSH
27095: LD_INT 1
27097: ARRAY
27098: DIFF
27099: DIFF
27100: ST_TO_ADDR
// if tmp and not sci then
27101: LD_VAR 0 4
27105: PUSH
27106: LD_VAR 0 8
27110: NOT
27111: AND
27112: IFFALSE 27181
// begin sort := SortBySkill ( tmp , 4 ) ;
27114: LD_ADDR_VAR 0 9
27118: PUSH
27119: LD_VAR 0 4
27123: PPUSH
27124: LD_INT 4
27126: PPUSH
27127: CALL 91646 0 2
27131: ST_TO_ADDR
// if sort then
27132: LD_VAR 0 9
27136: IFFALSE 27152
// p := sort [ 1 ] ;
27138: LD_ADDR_VAR 0 11
27142: PUSH
27143: LD_VAR 0 9
27147: PUSH
27148: LD_INT 1
27150: ARRAY
27151: ST_TO_ADDR
// if p then
27152: LD_VAR 0 11
27156: IFFALSE 27181
// result := Replace ( result , 4 , p ) ;
27158: LD_ADDR_VAR 0 2
27162: PUSH
27163: LD_VAR 0 2
27167: PPUSH
27168: LD_INT 4
27170: PPUSH
27171: LD_VAR 0 11
27175: PPUSH
27176: CALL_OW 1
27180: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27181: LD_ADDR_VAR 0 4
27185: PUSH
27186: LD_VAR 0 4
27190: PUSH
27191: LD_VAR 0 7
27195: DIFF
27196: ST_TO_ADDR
// if tmp and mech < 6 then
27197: LD_VAR 0 4
27201: PUSH
27202: LD_VAR 0 7
27206: PUSH
27207: LD_INT 6
27209: LESS
27210: AND
27211: IFFALSE 27399
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27213: LD_ADDR_VAR 0 9
27217: PUSH
27218: LD_VAR 0 4
27222: PUSH
27223: LD_VAR 0 8
27227: PUSH
27228: LD_VAR 0 7
27232: UNION
27233: DIFF
27234: PPUSH
27235: LD_INT 3
27237: PPUSH
27238: CALL 91646 0 2
27242: ST_TO_ADDR
// p := [ ] ;
27243: LD_ADDR_VAR 0 11
27247: PUSH
27248: EMPTY
27249: ST_TO_ADDR
// if sort then
27250: LD_VAR 0 9
27254: IFFALSE 27370
// for i = 1 to 6 - mech do
27256: LD_ADDR_VAR 0 3
27260: PUSH
27261: DOUBLE
27262: LD_INT 1
27264: DEC
27265: ST_TO_ADDR
27266: LD_INT 6
27268: PUSH
27269: LD_VAR 0 7
27273: MINUS
27274: PUSH
27275: FOR_TO
27276: IFFALSE 27368
// begin if i = sort then
27278: LD_VAR 0 3
27282: PUSH
27283: LD_VAR 0 9
27287: EQUAL
27288: IFFALSE 27292
// break ;
27290: GO 27368
// if GetClass ( i ) = 3 then
27292: LD_VAR 0 3
27296: PPUSH
27297: CALL_OW 257
27301: PUSH
27302: LD_INT 3
27304: EQUAL
27305: IFFALSE 27309
// continue ;
27307: GO 27275
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27309: LD_ADDR_VAR 0 11
27313: PUSH
27314: LD_VAR 0 11
27318: PPUSH
27319: LD_VAR 0 11
27323: PUSH
27324: LD_INT 1
27326: PLUS
27327: PPUSH
27328: LD_VAR 0 9
27332: PUSH
27333: LD_VAR 0 3
27337: ARRAY
27338: PPUSH
27339: CALL_OW 2
27343: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27344: LD_ADDR_VAR 0 4
27348: PUSH
27349: LD_VAR 0 4
27353: PUSH
27354: LD_VAR 0 9
27358: PUSH
27359: LD_VAR 0 3
27363: ARRAY
27364: DIFF
27365: ST_TO_ADDR
// end ;
27366: GO 27275
27368: POP
27369: POP
// if p then
27370: LD_VAR 0 11
27374: IFFALSE 27399
// result := Replace ( result , 3 , p ) ;
27376: LD_ADDR_VAR 0 2
27380: PUSH
27381: LD_VAR 0 2
27385: PPUSH
27386: LD_INT 3
27388: PPUSH
27389: LD_VAR 0 11
27393: PPUSH
27394: CALL_OW 1
27398: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27399: LD_ADDR_VAR 0 4
27403: PUSH
27404: LD_VAR 0 4
27408: PUSH
27409: LD_VAR 0 6
27413: DIFF
27414: ST_TO_ADDR
// if tmp and eng < 6 then
27415: LD_VAR 0 4
27419: PUSH
27420: LD_VAR 0 6
27424: PUSH
27425: LD_INT 6
27427: LESS
27428: AND
27429: IFFALSE 27623
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27431: LD_ADDR_VAR 0 9
27435: PUSH
27436: LD_VAR 0 4
27440: PUSH
27441: LD_VAR 0 8
27445: PUSH
27446: LD_VAR 0 7
27450: UNION
27451: PUSH
27452: LD_VAR 0 6
27456: UNION
27457: DIFF
27458: PPUSH
27459: LD_INT 2
27461: PPUSH
27462: CALL 91646 0 2
27466: ST_TO_ADDR
// p := [ ] ;
27467: LD_ADDR_VAR 0 11
27471: PUSH
27472: EMPTY
27473: ST_TO_ADDR
// if sort then
27474: LD_VAR 0 9
27478: IFFALSE 27594
// for i = 1 to 6 - eng do
27480: LD_ADDR_VAR 0 3
27484: PUSH
27485: DOUBLE
27486: LD_INT 1
27488: DEC
27489: ST_TO_ADDR
27490: LD_INT 6
27492: PUSH
27493: LD_VAR 0 6
27497: MINUS
27498: PUSH
27499: FOR_TO
27500: IFFALSE 27592
// begin if i = sort then
27502: LD_VAR 0 3
27506: PUSH
27507: LD_VAR 0 9
27511: EQUAL
27512: IFFALSE 27516
// break ;
27514: GO 27592
// if GetClass ( i ) = 2 then
27516: LD_VAR 0 3
27520: PPUSH
27521: CALL_OW 257
27525: PUSH
27526: LD_INT 2
27528: EQUAL
27529: IFFALSE 27533
// continue ;
27531: GO 27499
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27533: LD_ADDR_VAR 0 11
27537: PUSH
27538: LD_VAR 0 11
27542: PPUSH
27543: LD_VAR 0 11
27547: PUSH
27548: LD_INT 1
27550: PLUS
27551: PPUSH
27552: LD_VAR 0 9
27556: PUSH
27557: LD_VAR 0 3
27561: ARRAY
27562: PPUSH
27563: CALL_OW 2
27567: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27568: LD_ADDR_VAR 0 4
27572: PUSH
27573: LD_VAR 0 4
27577: PUSH
27578: LD_VAR 0 9
27582: PUSH
27583: LD_VAR 0 3
27587: ARRAY
27588: DIFF
27589: ST_TO_ADDR
// end ;
27590: GO 27499
27592: POP
27593: POP
// if p then
27594: LD_VAR 0 11
27598: IFFALSE 27623
// result := Replace ( result , 2 , p ) ;
27600: LD_ADDR_VAR 0 2
27604: PUSH
27605: LD_VAR 0 2
27609: PPUSH
27610: LD_INT 2
27612: PPUSH
27613: LD_VAR 0 11
27617: PPUSH
27618: CALL_OW 1
27622: ST_TO_ADDR
// end ; exit ;
27623: GO 28347
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27625: LD_EXP 101
27629: PUSH
27630: LD_EXP 100
27634: PUSH
27635: LD_VAR 0 1
27639: ARRAY
27640: ARRAY
27641: NOT
27642: PUSH
27643: LD_EXP 74
27647: PUSH
27648: LD_VAR 0 1
27652: ARRAY
27653: PPUSH
27654: LD_INT 30
27656: PUSH
27657: LD_INT 3
27659: PUSH
27660: EMPTY
27661: LIST
27662: LIST
27663: PPUSH
27664: CALL_OW 72
27668: AND
27669: PUSH
27670: LD_EXP 79
27674: PUSH
27675: LD_VAR 0 1
27679: ARRAY
27680: NOT
27681: AND
27682: IFFALSE 28347
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27684: LD_ADDR_EXP 116
27688: PUSH
27689: LD_EXP 116
27693: PPUSH
27694: LD_VAR 0 1
27698: PPUSH
27699: LD_INT 6
27701: PPUSH
27702: CALL_OW 1
27706: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27707: LD_ADDR_VAR 0 2
27711: PUSH
27712: LD_INT 0
27714: PUSH
27715: LD_INT 0
27717: PUSH
27718: LD_INT 0
27720: PUSH
27721: LD_INT 0
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: LIST
27728: LIST
27729: ST_TO_ADDR
// if sci >= 1 then
27730: LD_VAR 0 8
27734: PUSH
27735: LD_INT 1
27737: GREATEREQUAL
27738: IFFALSE 27760
// tmp := tmp diff sci [ 1 ] ;
27740: LD_ADDR_VAR 0 4
27744: PUSH
27745: LD_VAR 0 4
27749: PUSH
27750: LD_VAR 0 8
27754: PUSH
27755: LD_INT 1
27757: ARRAY
27758: DIFF
27759: ST_TO_ADDR
// if tmp and not sci then
27760: LD_VAR 0 4
27764: PUSH
27765: LD_VAR 0 8
27769: NOT
27770: AND
27771: IFFALSE 27840
// begin sort := SortBySkill ( tmp , 4 ) ;
27773: LD_ADDR_VAR 0 9
27777: PUSH
27778: LD_VAR 0 4
27782: PPUSH
27783: LD_INT 4
27785: PPUSH
27786: CALL 91646 0 2
27790: ST_TO_ADDR
// if sort then
27791: LD_VAR 0 9
27795: IFFALSE 27811
// p := sort [ 1 ] ;
27797: LD_ADDR_VAR 0 11
27801: PUSH
27802: LD_VAR 0 9
27806: PUSH
27807: LD_INT 1
27809: ARRAY
27810: ST_TO_ADDR
// if p then
27811: LD_VAR 0 11
27815: IFFALSE 27840
// result := Replace ( result , 4 , p ) ;
27817: LD_ADDR_VAR 0 2
27821: PUSH
27822: LD_VAR 0 2
27826: PPUSH
27827: LD_INT 4
27829: PPUSH
27830: LD_VAR 0 11
27834: PPUSH
27835: CALL_OW 1
27839: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27840: LD_ADDR_VAR 0 4
27844: PUSH
27845: LD_VAR 0 4
27849: PUSH
27850: LD_VAR 0 7
27854: DIFF
27855: ST_TO_ADDR
// if tmp and mech < 6 then
27856: LD_VAR 0 4
27860: PUSH
27861: LD_VAR 0 7
27865: PUSH
27866: LD_INT 6
27868: LESS
27869: AND
27870: IFFALSE 28052
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
27872: LD_ADDR_VAR 0 9
27876: PUSH
27877: LD_VAR 0 4
27881: PUSH
27882: LD_VAR 0 7
27886: DIFF
27887: PPUSH
27888: LD_INT 3
27890: PPUSH
27891: CALL 91646 0 2
27895: ST_TO_ADDR
// p := [ ] ;
27896: LD_ADDR_VAR 0 11
27900: PUSH
27901: EMPTY
27902: ST_TO_ADDR
// if sort then
27903: LD_VAR 0 9
27907: IFFALSE 28023
// for i = 1 to 6 - mech do
27909: LD_ADDR_VAR 0 3
27913: PUSH
27914: DOUBLE
27915: LD_INT 1
27917: DEC
27918: ST_TO_ADDR
27919: LD_INT 6
27921: PUSH
27922: LD_VAR 0 7
27926: MINUS
27927: PUSH
27928: FOR_TO
27929: IFFALSE 28021
// begin if i = sort then
27931: LD_VAR 0 3
27935: PUSH
27936: LD_VAR 0 9
27940: EQUAL
27941: IFFALSE 27945
// break ;
27943: GO 28021
// if GetClass ( i ) = 3 then
27945: LD_VAR 0 3
27949: PPUSH
27950: CALL_OW 257
27954: PUSH
27955: LD_INT 3
27957: EQUAL
27958: IFFALSE 27962
// continue ;
27960: GO 27928
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27962: LD_ADDR_VAR 0 11
27966: PUSH
27967: LD_VAR 0 11
27971: PPUSH
27972: LD_VAR 0 11
27976: PUSH
27977: LD_INT 1
27979: PLUS
27980: PPUSH
27981: LD_VAR 0 9
27985: PUSH
27986: LD_VAR 0 3
27990: ARRAY
27991: PPUSH
27992: CALL_OW 2
27996: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27997: LD_ADDR_VAR 0 4
28001: PUSH
28002: LD_VAR 0 4
28006: PUSH
28007: LD_VAR 0 9
28011: PUSH
28012: LD_VAR 0 3
28016: ARRAY
28017: DIFF
28018: ST_TO_ADDR
// end ;
28019: GO 27928
28021: POP
28022: POP
// if p then
28023: LD_VAR 0 11
28027: IFFALSE 28052
// result := Replace ( result , 3 , p ) ;
28029: LD_ADDR_VAR 0 2
28033: PUSH
28034: LD_VAR 0 2
28038: PPUSH
28039: LD_INT 3
28041: PPUSH
28042: LD_VAR 0 11
28046: PPUSH
28047: CALL_OW 1
28051: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28052: LD_ADDR_VAR 0 4
28056: PUSH
28057: LD_VAR 0 4
28061: PUSH
28062: LD_VAR 0 6
28066: DIFF
28067: ST_TO_ADDR
// if tmp and eng < 4 then
28068: LD_VAR 0 4
28072: PUSH
28073: LD_VAR 0 6
28077: PUSH
28078: LD_INT 4
28080: LESS
28081: AND
28082: IFFALSE 28272
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28084: LD_ADDR_VAR 0 9
28088: PUSH
28089: LD_VAR 0 4
28093: PUSH
28094: LD_VAR 0 7
28098: PUSH
28099: LD_VAR 0 6
28103: UNION
28104: DIFF
28105: PPUSH
28106: LD_INT 2
28108: PPUSH
28109: CALL 91646 0 2
28113: ST_TO_ADDR
// p := [ ] ;
28114: LD_ADDR_VAR 0 11
28118: PUSH
28119: EMPTY
28120: ST_TO_ADDR
// if sort then
28121: LD_VAR 0 9
28125: IFFALSE 28241
// for i = 1 to 4 - eng do
28127: LD_ADDR_VAR 0 3
28131: PUSH
28132: DOUBLE
28133: LD_INT 1
28135: DEC
28136: ST_TO_ADDR
28137: LD_INT 4
28139: PUSH
28140: LD_VAR 0 6
28144: MINUS
28145: PUSH
28146: FOR_TO
28147: IFFALSE 28239
// begin if i = sort then
28149: LD_VAR 0 3
28153: PUSH
28154: LD_VAR 0 9
28158: EQUAL
28159: IFFALSE 28163
// break ;
28161: GO 28239
// if GetClass ( i ) = 2 then
28163: LD_VAR 0 3
28167: PPUSH
28168: CALL_OW 257
28172: PUSH
28173: LD_INT 2
28175: EQUAL
28176: IFFALSE 28180
// continue ;
28178: GO 28146
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28180: LD_ADDR_VAR 0 11
28184: PUSH
28185: LD_VAR 0 11
28189: PPUSH
28190: LD_VAR 0 11
28194: PUSH
28195: LD_INT 1
28197: PLUS
28198: PPUSH
28199: LD_VAR 0 9
28203: PUSH
28204: LD_VAR 0 3
28208: ARRAY
28209: PPUSH
28210: CALL_OW 2
28214: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28215: LD_ADDR_VAR 0 4
28219: PUSH
28220: LD_VAR 0 4
28224: PUSH
28225: LD_VAR 0 9
28229: PUSH
28230: LD_VAR 0 3
28234: ARRAY
28235: DIFF
28236: ST_TO_ADDR
// end ;
28237: GO 28146
28239: POP
28240: POP
// if p then
28241: LD_VAR 0 11
28245: IFFALSE 28270
// result := Replace ( result , 2 , p ) ;
28247: LD_ADDR_VAR 0 2
28251: PUSH
28252: LD_VAR 0 2
28256: PPUSH
28257: LD_INT 2
28259: PPUSH
28260: LD_VAR 0 11
28264: PPUSH
28265: CALL_OW 1
28269: ST_TO_ADDR
// end else
28270: GO 28316
// for i = eng downto 5 do
28272: LD_ADDR_VAR 0 3
28276: PUSH
28277: DOUBLE
28278: LD_VAR 0 6
28282: INC
28283: ST_TO_ADDR
28284: LD_INT 5
28286: PUSH
28287: FOR_DOWNTO
28288: IFFALSE 28314
// tmp := tmp union eng [ i ] ;
28290: LD_ADDR_VAR 0 4
28294: PUSH
28295: LD_VAR 0 4
28299: PUSH
28300: LD_VAR 0 6
28304: PUSH
28305: LD_VAR 0 3
28309: ARRAY
28310: UNION
28311: ST_TO_ADDR
28312: GO 28287
28314: POP
28315: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28316: LD_ADDR_VAR 0 2
28320: PUSH
28321: LD_VAR 0 2
28325: PPUSH
28326: LD_INT 1
28328: PPUSH
28329: LD_VAR 0 4
28333: PUSH
28334: LD_VAR 0 5
28338: DIFF
28339: PPUSH
28340: CALL_OW 1
28344: ST_TO_ADDR
// exit ;
28345: GO 28347
// end ; end ;
28347: LD_VAR 0 2
28351: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28352: LD_INT 0
28354: PPUSH
28355: PPUSH
28356: PPUSH
// if not mc_bases then
28357: LD_EXP 74
28361: NOT
28362: IFFALSE 28366
// exit ;
28364: GO 28472
// for i = 1 to mc_bases do
28366: LD_ADDR_VAR 0 2
28370: PUSH
28371: DOUBLE
28372: LD_INT 1
28374: DEC
28375: ST_TO_ADDR
28376: LD_EXP 74
28380: PUSH
28381: FOR_TO
28382: IFFALSE 28463
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28384: LD_ADDR_VAR 0 3
28388: PUSH
28389: LD_EXP 74
28393: PUSH
28394: LD_VAR 0 2
28398: ARRAY
28399: PPUSH
28400: LD_INT 21
28402: PUSH
28403: LD_INT 3
28405: PUSH
28406: EMPTY
28407: LIST
28408: LIST
28409: PUSH
28410: LD_INT 3
28412: PUSH
28413: LD_INT 24
28415: PUSH
28416: LD_INT 1000
28418: PUSH
28419: EMPTY
28420: LIST
28421: LIST
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: EMPTY
28428: LIST
28429: LIST
28430: PPUSH
28431: CALL_OW 72
28435: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28436: LD_ADDR_EXP 75
28440: PUSH
28441: LD_EXP 75
28445: PPUSH
28446: LD_VAR 0 2
28450: PPUSH
28451: LD_VAR 0 3
28455: PPUSH
28456: CALL_OW 1
28460: ST_TO_ADDR
// end ;
28461: GO 28381
28463: POP
28464: POP
// RaiseSailEvent ( 101 ) ;
28465: LD_INT 101
28467: PPUSH
28468: CALL_OW 427
// end ;
28472: LD_VAR 0 1
28476: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28477: LD_INT 0
28479: PPUSH
28480: PPUSH
28481: PPUSH
28482: PPUSH
28483: PPUSH
28484: PPUSH
28485: PPUSH
// if not mc_bases then
28486: LD_EXP 74
28490: NOT
28491: IFFALSE 28495
// exit ;
28493: GO 29068
// for i = 1 to mc_bases do
28495: LD_ADDR_VAR 0 2
28499: PUSH
28500: DOUBLE
28501: LD_INT 1
28503: DEC
28504: ST_TO_ADDR
28505: LD_EXP 74
28509: PUSH
28510: FOR_TO
28511: IFFALSE 29059
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28513: LD_ADDR_VAR 0 5
28517: PUSH
28518: LD_EXP 74
28522: PUSH
28523: LD_VAR 0 2
28527: ARRAY
28528: PUSH
28529: LD_EXP 103
28533: PUSH
28534: LD_VAR 0 2
28538: ARRAY
28539: UNION
28540: PPUSH
28541: LD_INT 21
28543: PUSH
28544: LD_INT 1
28546: PUSH
28547: EMPTY
28548: LIST
28549: LIST
28550: PUSH
28551: LD_INT 1
28553: PUSH
28554: LD_INT 3
28556: PUSH
28557: LD_INT 54
28559: PUSH
28560: EMPTY
28561: LIST
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PUSH
28567: LD_INT 3
28569: PUSH
28570: LD_INT 24
28572: PUSH
28573: LD_INT 800
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: EMPTY
28581: LIST
28582: LIST
28583: PUSH
28584: EMPTY
28585: LIST
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PPUSH
28593: CALL_OW 72
28597: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28598: LD_ADDR_VAR 0 6
28602: PUSH
28603: LD_EXP 74
28607: PUSH
28608: LD_VAR 0 2
28612: ARRAY
28613: PPUSH
28614: LD_INT 21
28616: PUSH
28617: LD_INT 1
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: LD_INT 1
28626: PUSH
28627: LD_INT 3
28629: PUSH
28630: LD_INT 54
28632: PUSH
28633: EMPTY
28634: LIST
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: PUSH
28640: LD_INT 3
28642: PUSH
28643: LD_INT 24
28645: PUSH
28646: LD_INT 250
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: EMPTY
28654: LIST
28655: LIST
28656: PUSH
28657: EMPTY
28658: LIST
28659: LIST
28660: LIST
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PPUSH
28666: CALL_OW 72
28670: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28671: LD_ADDR_VAR 0 7
28675: PUSH
28676: LD_VAR 0 5
28680: PUSH
28681: LD_VAR 0 6
28685: DIFF
28686: ST_TO_ADDR
// if not need_heal_1 then
28687: LD_VAR 0 6
28691: NOT
28692: IFFALSE 28725
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28694: LD_ADDR_EXP 77
28698: PUSH
28699: LD_EXP 77
28703: PPUSH
28704: LD_VAR 0 2
28708: PUSH
28709: LD_INT 1
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PPUSH
28716: EMPTY
28717: PPUSH
28718: CALL 57398 0 3
28722: ST_TO_ADDR
28723: GO 28795
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28725: LD_ADDR_EXP 77
28729: PUSH
28730: LD_EXP 77
28734: PPUSH
28735: LD_VAR 0 2
28739: PUSH
28740: LD_INT 1
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PPUSH
28747: LD_EXP 77
28751: PUSH
28752: LD_VAR 0 2
28756: ARRAY
28757: PUSH
28758: LD_INT 1
28760: ARRAY
28761: PPUSH
28762: LD_INT 3
28764: PUSH
28765: LD_INT 24
28767: PUSH
28768: LD_INT 1000
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PPUSH
28779: CALL_OW 72
28783: PUSH
28784: LD_VAR 0 6
28788: UNION
28789: PPUSH
28790: CALL 57398 0 3
28794: ST_TO_ADDR
// if not need_heal_2 then
28795: LD_VAR 0 7
28799: NOT
28800: IFFALSE 28833
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
28802: LD_ADDR_EXP 77
28806: PUSH
28807: LD_EXP 77
28811: PPUSH
28812: LD_VAR 0 2
28816: PUSH
28817: LD_INT 2
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PPUSH
28824: EMPTY
28825: PPUSH
28826: CALL 57398 0 3
28830: ST_TO_ADDR
28831: GO 28865
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
28833: LD_ADDR_EXP 77
28837: PUSH
28838: LD_EXP 77
28842: PPUSH
28843: LD_VAR 0 2
28847: PUSH
28848: LD_INT 2
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PPUSH
28855: LD_VAR 0 7
28859: PPUSH
28860: CALL 57398 0 3
28864: ST_TO_ADDR
// if need_heal_2 then
28865: LD_VAR 0 7
28869: IFFALSE 29041
// for j in need_heal_2 do
28871: LD_ADDR_VAR 0 3
28875: PUSH
28876: LD_VAR 0 7
28880: PUSH
28881: FOR_IN
28882: IFFALSE 29039
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
28884: LD_ADDR_VAR 0 5
28888: PUSH
28889: LD_EXP 74
28893: PUSH
28894: LD_VAR 0 2
28898: ARRAY
28899: PPUSH
28900: LD_INT 2
28902: PUSH
28903: LD_INT 30
28905: PUSH
28906: LD_INT 6
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: LD_INT 30
28915: PUSH
28916: LD_INT 7
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: PUSH
28923: LD_INT 30
28925: PUSH
28926: LD_INT 8
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 30
28935: PUSH
28936: LD_INT 0
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: PUSH
28943: LD_INT 30
28945: PUSH
28946: LD_INT 1
28948: PUSH
28949: EMPTY
28950: LIST
28951: LIST
28952: PUSH
28953: LD_INT 25
28955: PUSH
28956: LD_INT 4
28958: PUSH
28959: EMPTY
28960: LIST
28961: LIST
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: LIST
28967: LIST
28968: LIST
28969: LIST
28970: LIST
28971: PPUSH
28972: CALL_OW 72
28976: ST_TO_ADDR
// if tmp then
28977: LD_VAR 0 5
28981: IFFALSE 29037
// begin k := NearestUnitToUnit ( tmp , j ) ;
28983: LD_ADDR_VAR 0 4
28987: PUSH
28988: LD_VAR 0 5
28992: PPUSH
28993: LD_VAR 0 3
28997: PPUSH
28998: CALL_OW 74
29002: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29003: LD_VAR 0 3
29007: PPUSH
29008: LD_VAR 0 4
29012: PPUSH
29013: CALL_OW 296
29017: PUSH
29018: LD_INT 7
29020: GREATER
29021: IFFALSE 29037
// ComMoveUnit ( j , k ) ;
29023: LD_VAR 0 3
29027: PPUSH
29028: LD_VAR 0 4
29032: PPUSH
29033: CALL_OW 112
// end ; end ;
29037: GO 28881
29039: POP
29040: POP
// if not need_heal_1 and not need_heal_2 then
29041: LD_VAR 0 6
29045: NOT
29046: PUSH
29047: LD_VAR 0 7
29051: NOT
29052: AND
29053: IFFALSE 29057
// continue ;
29055: GO 28510
// end ;
29057: GO 28510
29059: POP
29060: POP
// RaiseSailEvent ( 102 ) ;
29061: LD_INT 102
29063: PPUSH
29064: CALL_OW 427
// end ;
29068: LD_VAR 0 1
29072: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
29073: LD_INT 0
29075: PPUSH
29076: PPUSH
29077: PPUSH
29078: PPUSH
29079: PPUSH
29080: PPUSH
// if not mc_bases then
29081: LD_EXP 74
29085: NOT
29086: IFFALSE 29090
// exit ;
29088: GO 29800
// for i = 1 to mc_bases do
29090: LD_ADDR_VAR 0 2
29094: PUSH
29095: DOUBLE
29096: LD_INT 1
29098: DEC
29099: ST_TO_ADDR
29100: LD_EXP 74
29104: PUSH
29105: FOR_TO
29106: IFFALSE 29798
// begin if not mc_building_need_repair [ i ] then
29108: LD_EXP 75
29112: PUSH
29113: LD_VAR 0 2
29117: ARRAY
29118: NOT
29119: IFFALSE 29293
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29121: LD_ADDR_VAR 0 6
29125: PUSH
29126: LD_EXP 93
29130: PUSH
29131: LD_VAR 0 2
29135: ARRAY
29136: PPUSH
29137: LD_INT 3
29139: PUSH
29140: LD_INT 24
29142: PUSH
29143: LD_INT 1000
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: PUSH
29154: LD_INT 2
29156: PUSH
29157: LD_INT 34
29159: PUSH
29160: LD_INT 13
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 34
29169: PUSH
29170: LD_INT 52
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: LIST
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PPUSH
29186: CALL_OW 72
29190: ST_TO_ADDR
// if cranes then
29191: LD_VAR 0 6
29195: IFFALSE 29257
// for j in cranes do
29197: LD_ADDR_VAR 0 3
29201: PUSH
29202: LD_VAR 0 6
29206: PUSH
29207: FOR_IN
29208: IFFALSE 29255
// if not IsInArea ( j , mc_parking [ i ] ) then
29210: LD_VAR 0 3
29214: PPUSH
29215: LD_EXP 98
29219: PUSH
29220: LD_VAR 0 2
29224: ARRAY
29225: PPUSH
29226: CALL_OW 308
29230: NOT
29231: IFFALSE 29253
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29233: LD_VAR 0 3
29237: PPUSH
29238: LD_EXP 98
29242: PUSH
29243: LD_VAR 0 2
29247: ARRAY
29248: PPUSH
29249: CALL_OW 113
29253: GO 29207
29255: POP
29256: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29257: LD_ADDR_EXP 76
29261: PUSH
29262: LD_EXP 76
29266: PPUSH
29267: LD_VAR 0 2
29271: PPUSH
29272: EMPTY
29273: PPUSH
29274: CALL_OW 1
29278: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29279: LD_VAR 0 2
29283: PPUSH
29284: LD_INT 101
29286: PPUSH
29287: CALL 24185 0 2
// continue ;
29291: GO 29105
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29293: LD_ADDR_EXP 80
29297: PUSH
29298: LD_EXP 80
29302: PPUSH
29303: LD_VAR 0 2
29307: PPUSH
29308: EMPTY
29309: PPUSH
29310: CALL_OW 1
29314: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29315: LD_VAR 0 2
29319: PPUSH
29320: LD_INT 103
29322: PPUSH
29323: CALL 24185 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29327: LD_ADDR_VAR 0 5
29331: PUSH
29332: LD_EXP 74
29336: PUSH
29337: LD_VAR 0 2
29341: ARRAY
29342: PUSH
29343: LD_EXP 103
29347: PUSH
29348: LD_VAR 0 2
29352: ARRAY
29353: UNION
29354: PPUSH
29355: LD_INT 2
29357: PUSH
29358: LD_INT 25
29360: PUSH
29361: LD_INT 2
29363: PUSH
29364: EMPTY
29365: LIST
29366: LIST
29367: PUSH
29368: LD_INT 25
29370: PUSH
29371: LD_INT 16
29373: PUSH
29374: EMPTY
29375: LIST
29376: LIST
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: LIST
29382: PUSH
29383: EMPTY
29384: LIST
29385: PPUSH
29386: CALL_OW 72
29390: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29391: LD_ADDR_VAR 0 6
29395: PUSH
29396: LD_EXP 93
29400: PUSH
29401: LD_VAR 0 2
29405: ARRAY
29406: PPUSH
29407: LD_INT 2
29409: PUSH
29410: LD_INT 34
29412: PUSH
29413: LD_INT 13
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 34
29422: PUSH
29423: LD_INT 52
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: LIST
29434: PPUSH
29435: CALL_OW 72
29439: ST_TO_ADDR
// if cranes then
29440: LD_VAR 0 6
29444: IFFALSE 29580
// begin for j in cranes do
29446: LD_ADDR_VAR 0 3
29450: PUSH
29451: LD_VAR 0 6
29455: PUSH
29456: FOR_IN
29457: IFFALSE 29578
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29459: LD_VAR 0 3
29463: PPUSH
29464: CALL_OW 256
29468: PUSH
29469: LD_INT 500
29471: GREATEREQUAL
29472: PUSH
29473: LD_VAR 0 3
29477: PPUSH
29478: CALL_OW 314
29482: NOT
29483: AND
29484: IFFALSE 29518
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29486: LD_VAR 0 3
29490: PPUSH
29491: LD_EXP 75
29495: PUSH
29496: LD_VAR 0 2
29500: ARRAY
29501: PPUSH
29502: LD_VAR 0 3
29506: PPUSH
29507: CALL_OW 74
29511: PPUSH
29512: CALL_OW 130
29516: GO 29576
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29518: LD_VAR 0 3
29522: PPUSH
29523: CALL_OW 256
29527: PUSH
29528: LD_INT 500
29530: LESS
29531: PUSH
29532: LD_VAR 0 3
29536: PPUSH
29537: LD_EXP 98
29541: PUSH
29542: LD_VAR 0 2
29546: ARRAY
29547: PPUSH
29548: CALL_OW 308
29552: NOT
29553: AND
29554: IFFALSE 29576
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29556: LD_VAR 0 3
29560: PPUSH
29561: LD_EXP 98
29565: PUSH
29566: LD_VAR 0 2
29570: ARRAY
29571: PPUSH
29572: CALL_OW 113
29576: GO 29456
29578: POP
29579: POP
// end ; if not tmp then
29580: LD_VAR 0 5
29584: NOT
29585: IFFALSE 29589
// continue ;
29587: GO 29105
// for j in tmp do
29589: LD_ADDR_VAR 0 3
29593: PUSH
29594: LD_VAR 0 5
29598: PUSH
29599: FOR_IN
29600: IFFALSE 29794
// begin if mc_need_heal [ i ] then
29602: LD_EXP 77
29606: PUSH
29607: LD_VAR 0 2
29611: ARRAY
29612: IFFALSE 29660
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29614: LD_VAR 0 3
29618: PUSH
29619: LD_EXP 77
29623: PUSH
29624: LD_VAR 0 2
29628: ARRAY
29629: PUSH
29630: LD_INT 1
29632: ARRAY
29633: IN
29634: PUSH
29635: LD_VAR 0 3
29639: PUSH
29640: LD_EXP 77
29644: PUSH
29645: LD_VAR 0 2
29649: ARRAY
29650: PUSH
29651: LD_INT 2
29653: ARRAY
29654: IN
29655: OR
29656: IFFALSE 29660
// continue ;
29658: GO 29599
// if IsInUnit ( j ) then
29660: LD_VAR 0 3
29664: PPUSH
29665: CALL_OW 310
29669: IFFALSE 29680
// ComExitBuilding ( j ) ;
29671: LD_VAR 0 3
29675: PPUSH
29676: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29680: LD_VAR 0 3
29684: PUSH
29685: LD_EXP 76
29689: PUSH
29690: LD_VAR 0 2
29694: ARRAY
29695: IN
29696: NOT
29697: IFFALSE 29755
// begin SetTag ( j , 101 ) ;
29699: LD_VAR 0 3
29703: PPUSH
29704: LD_INT 101
29706: PPUSH
29707: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29711: LD_ADDR_EXP 76
29715: PUSH
29716: LD_EXP 76
29720: PPUSH
29721: LD_VAR 0 2
29725: PUSH
29726: LD_EXP 76
29730: PUSH
29731: LD_VAR 0 2
29735: ARRAY
29736: PUSH
29737: LD_INT 1
29739: PLUS
29740: PUSH
29741: EMPTY
29742: LIST
29743: LIST
29744: PPUSH
29745: LD_VAR 0 3
29749: PPUSH
29750: CALL 57398 0 3
29754: ST_TO_ADDR
// end ; wait ( 1 ) ;
29755: LD_INT 1
29757: PPUSH
29758: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
29762: LD_VAR 0 3
29766: PPUSH
29767: LD_EXP 75
29771: PUSH
29772: LD_VAR 0 2
29776: ARRAY
29777: PPUSH
29778: LD_VAR 0 3
29782: PPUSH
29783: CALL_OW 74
29787: PPUSH
29788: CALL_OW 130
// end ;
29792: GO 29599
29794: POP
29795: POP
// end ;
29796: GO 29105
29798: POP
29799: POP
// end ;
29800: LD_VAR 0 1
29804: RET
// export function MC_Heal ; var i , j , tmp ; begin
29805: LD_INT 0
29807: PPUSH
29808: PPUSH
29809: PPUSH
29810: PPUSH
// if not mc_bases then
29811: LD_EXP 74
29815: NOT
29816: IFFALSE 29820
// exit ;
29818: GO 30222
// for i = 1 to mc_bases do
29820: LD_ADDR_VAR 0 2
29824: PUSH
29825: DOUBLE
29826: LD_INT 1
29828: DEC
29829: ST_TO_ADDR
29830: LD_EXP 74
29834: PUSH
29835: FOR_TO
29836: IFFALSE 30220
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
29838: LD_EXP 77
29842: PUSH
29843: LD_VAR 0 2
29847: ARRAY
29848: PUSH
29849: LD_INT 1
29851: ARRAY
29852: NOT
29853: PUSH
29854: LD_EXP 77
29858: PUSH
29859: LD_VAR 0 2
29863: ARRAY
29864: PUSH
29865: LD_INT 2
29867: ARRAY
29868: NOT
29869: AND
29870: IFFALSE 29908
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
29872: LD_ADDR_EXP 78
29876: PUSH
29877: LD_EXP 78
29881: PPUSH
29882: LD_VAR 0 2
29886: PPUSH
29887: EMPTY
29888: PPUSH
29889: CALL_OW 1
29893: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
29894: LD_VAR 0 2
29898: PPUSH
29899: LD_INT 102
29901: PPUSH
29902: CALL 24185 0 2
// continue ;
29906: GO 29835
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
29908: LD_ADDR_VAR 0 4
29912: PUSH
29913: LD_EXP 74
29917: PUSH
29918: LD_VAR 0 2
29922: ARRAY
29923: PPUSH
29924: LD_INT 25
29926: PUSH
29927: LD_INT 4
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PPUSH
29934: CALL_OW 72
29938: ST_TO_ADDR
// if not tmp then
29939: LD_VAR 0 4
29943: NOT
29944: IFFALSE 29948
// continue ;
29946: GO 29835
// if mc_taming [ i ] then
29948: LD_EXP 105
29952: PUSH
29953: LD_VAR 0 2
29957: ARRAY
29958: IFFALSE 29982
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
29960: LD_ADDR_EXP 105
29964: PUSH
29965: LD_EXP 105
29969: PPUSH
29970: LD_VAR 0 2
29974: PPUSH
29975: EMPTY
29976: PPUSH
29977: CALL_OW 1
29981: ST_TO_ADDR
// for j in tmp do
29982: LD_ADDR_VAR 0 3
29986: PUSH
29987: LD_VAR 0 4
29991: PUSH
29992: FOR_IN
29993: IFFALSE 30216
// begin if IsInUnit ( j ) then
29995: LD_VAR 0 3
29999: PPUSH
30000: CALL_OW 310
30004: IFFALSE 30015
// ComExitBuilding ( j ) ;
30006: LD_VAR 0 3
30010: PPUSH
30011: CALL_OW 122
// if not j in mc_healers [ i ] then
30015: LD_VAR 0 3
30019: PUSH
30020: LD_EXP 78
30024: PUSH
30025: LD_VAR 0 2
30029: ARRAY
30030: IN
30031: NOT
30032: IFFALSE 30078
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30034: LD_ADDR_EXP 78
30038: PUSH
30039: LD_EXP 78
30043: PPUSH
30044: LD_VAR 0 2
30048: PUSH
30049: LD_EXP 78
30053: PUSH
30054: LD_VAR 0 2
30058: ARRAY
30059: PUSH
30060: LD_INT 1
30062: PLUS
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PPUSH
30068: LD_VAR 0 3
30072: PPUSH
30073: CALL 57398 0 3
30077: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30078: LD_VAR 0 3
30082: PPUSH
30083: CALL_OW 110
30087: PUSH
30088: LD_INT 102
30090: NONEQUAL
30091: IFFALSE 30105
// SetTag ( j , 102 ) ;
30093: LD_VAR 0 3
30097: PPUSH
30098: LD_INT 102
30100: PPUSH
30101: CALL_OW 109
// Wait ( 3 ) ;
30105: LD_INT 3
30107: PPUSH
30108: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30112: LD_EXP 77
30116: PUSH
30117: LD_VAR 0 2
30121: ARRAY
30122: PUSH
30123: LD_INT 1
30125: ARRAY
30126: IFFALSE 30158
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30128: LD_VAR 0 3
30132: PPUSH
30133: LD_EXP 77
30137: PUSH
30138: LD_VAR 0 2
30142: ARRAY
30143: PUSH
30144: LD_INT 1
30146: ARRAY
30147: PUSH
30148: LD_INT 1
30150: ARRAY
30151: PPUSH
30152: CALL_OW 128
30156: GO 30214
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30158: LD_VAR 0 3
30162: PPUSH
30163: CALL_OW 314
30167: NOT
30168: PUSH
30169: LD_EXP 77
30173: PUSH
30174: LD_VAR 0 2
30178: ARRAY
30179: PUSH
30180: LD_INT 2
30182: ARRAY
30183: AND
30184: IFFALSE 30214
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30186: LD_VAR 0 3
30190: PPUSH
30191: LD_EXP 77
30195: PUSH
30196: LD_VAR 0 2
30200: ARRAY
30201: PUSH
30202: LD_INT 2
30204: ARRAY
30205: PUSH
30206: LD_INT 1
30208: ARRAY
30209: PPUSH
30210: CALL_OW 128
// end ;
30214: GO 29992
30216: POP
30217: POP
// end ;
30218: GO 29835
30220: POP
30221: POP
// end ;
30222: LD_VAR 0 1
30226: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30227: LD_INT 0
30229: PPUSH
30230: PPUSH
30231: PPUSH
30232: PPUSH
30233: PPUSH
// if not mc_bases then
30234: LD_EXP 74
30238: NOT
30239: IFFALSE 30243
// exit ;
30241: GO 31386
// for i = 1 to mc_bases do
30243: LD_ADDR_VAR 0 2
30247: PUSH
30248: DOUBLE
30249: LD_INT 1
30251: DEC
30252: ST_TO_ADDR
30253: LD_EXP 74
30257: PUSH
30258: FOR_TO
30259: IFFALSE 31384
// begin if mc_scan [ i ] then
30261: LD_EXP 97
30265: PUSH
30266: LD_VAR 0 2
30270: ARRAY
30271: IFFALSE 30275
// continue ;
30273: GO 30258
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30275: LD_EXP 79
30279: PUSH
30280: LD_VAR 0 2
30284: ARRAY
30285: NOT
30286: PUSH
30287: LD_EXP 81
30291: PUSH
30292: LD_VAR 0 2
30296: ARRAY
30297: NOT
30298: AND
30299: PUSH
30300: LD_EXP 80
30304: PUSH
30305: LD_VAR 0 2
30309: ARRAY
30310: AND
30311: IFFALSE 30349
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30313: LD_ADDR_EXP 80
30317: PUSH
30318: LD_EXP 80
30322: PPUSH
30323: LD_VAR 0 2
30327: PPUSH
30328: EMPTY
30329: PPUSH
30330: CALL_OW 1
30334: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30335: LD_VAR 0 2
30339: PPUSH
30340: LD_INT 103
30342: PPUSH
30343: CALL 24185 0 2
// continue ;
30347: GO 30258
// end ; if mc_construct_list [ i ] then
30349: LD_EXP 81
30353: PUSH
30354: LD_VAR 0 2
30358: ARRAY
30359: IFFALSE 30579
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30361: LD_ADDR_VAR 0 4
30365: PUSH
30366: LD_EXP 74
30370: PUSH
30371: LD_VAR 0 2
30375: ARRAY
30376: PPUSH
30377: LD_INT 25
30379: PUSH
30380: LD_INT 2
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: PPUSH
30387: CALL_OW 72
30391: PUSH
30392: LD_EXP 76
30396: PUSH
30397: LD_VAR 0 2
30401: ARRAY
30402: DIFF
30403: ST_TO_ADDR
// if not tmp then
30404: LD_VAR 0 4
30408: NOT
30409: IFFALSE 30413
// continue ;
30411: GO 30258
// for j in tmp do
30413: LD_ADDR_VAR 0 3
30417: PUSH
30418: LD_VAR 0 4
30422: PUSH
30423: FOR_IN
30424: IFFALSE 30575
// begin if not mc_builders [ i ] then
30426: LD_EXP 80
30430: PUSH
30431: LD_VAR 0 2
30435: ARRAY
30436: NOT
30437: IFFALSE 30495
// begin SetTag ( j , 103 ) ;
30439: LD_VAR 0 3
30443: PPUSH
30444: LD_INT 103
30446: PPUSH
30447: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30451: LD_ADDR_EXP 80
30455: PUSH
30456: LD_EXP 80
30460: PPUSH
30461: LD_VAR 0 2
30465: PUSH
30466: LD_EXP 80
30470: PUSH
30471: LD_VAR 0 2
30475: ARRAY
30476: PUSH
30477: LD_INT 1
30479: PLUS
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: PPUSH
30485: LD_VAR 0 3
30489: PPUSH
30490: CALL 57398 0 3
30494: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30495: LD_VAR 0 3
30499: PPUSH
30500: CALL_OW 310
30504: IFFALSE 30515
// ComExitBuilding ( j ) ;
30506: LD_VAR 0 3
30510: PPUSH
30511: CALL_OW 122
// wait ( 3 ) ;
30515: LD_INT 3
30517: PPUSH
30518: CALL_OW 67
// if not mc_construct_list [ i ] then
30522: LD_EXP 81
30526: PUSH
30527: LD_VAR 0 2
30531: ARRAY
30532: NOT
30533: IFFALSE 30537
// break ;
30535: GO 30575
// if not HasTask ( j ) then
30537: LD_VAR 0 3
30541: PPUSH
30542: CALL_OW 314
30546: NOT
30547: IFFALSE 30573
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30549: LD_VAR 0 3
30553: PPUSH
30554: LD_EXP 81
30558: PUSH
30559: LD_VAR 0 2
30563: ARRAY
30564: PUSH
30565: LD_INT 1
30567: ARRAY
30568: PPUSH
30569: CALL 60249 0 2
// end ;
30573: GO 30423
30575: POP
30576: POP
// end else
30577: GO 31382
// if mc_build_list [ i ] then
30579: LD_EXP 79
30583: PUSH
30584: LD_VAR 0 2
30588: ARRAY
30589: IFFALSE 31382
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30591: LD_ADDR_VAR 0 5
30595: PUSH
30596: LD_EXP 74
30600: PUSH
30601: LD_VAR 0 2
30605: ARRAY
30606: PPUSH
30607: LD_INT 2
30609: PUSH
30610: LD_INT 30
30612: PUSH
30613: LD_INT 0
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PUSH
30620: LD_INT 30
30622: PUSH
30623: LD_INT 1
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: EMPTY
30631: LIST
30632: LIST
30633: LIST
30634: PPUSH
30635: CALL_OW 72
30639: ST_TO_ADDR
// if depot then
30640: LD_VAR 0 5
30644: IFFALSE 30662
// depot := depot [ 1 ] else
30646: LD_ADDR_VAR 0 5
30650: PUSH
30651: LD_VAR 0 5
30655: PUSH
30656: LD_INT 1
30658: ARRAY
30659: ST_TO_ADDR
30660: GO 30670
// depot := 0 ;
30662: LD_ADDR_VAR 0 5
30666: PUSH
30667: LD_INT 0
30669: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
30670: LD_EXP 79
30674: PUSH
30675: LD_VAR 0 2
30679: ARRAY
30680: PUSH
30681: LD_INT 1
30683: ARRAY
30684: PUSH
30685: LD_INT 1
30687: ARRAY
30688: PPUSH
30689: CALL 60079 0 1
30693: PUSH
30694: LD_EXP 74
30698: PUSH
30699: LD_VAR 0 2
30703: ARRAY
30704: PPUSH
30705: LD_INT 2
30707: PUSH
30708: LD_INT 30
30710: PUSH
30711: LD_INT 2
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 30
30720: PUSH
30721: LD_INT 3
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: LIST
30732: PPUSH
30733: CALL_OW 72
30737: NOT
30738: AND
30739: IFFALSE 30844
// begin for j = 1 to mc_build_list [ i ] do
30741: LD_ADDR_VAR 0 3
30745: PUSH
30746: DOUBLE
30747: LD_INT 1
30749: DEC
30750: ST_TO_ADDR
30751: LD_EXP 79
30755: PUSH
30756: LD_VAR 0 2
30760: ARRAY
30761: PUSH
30762: FOR_TO
30763: IFFALSE 30842
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
30765: LD_EXP 79
30769: PUSH
30770: LD_VAR 0 2
30774: ARRAY
30775: PUSH
30776: LD_VAR 0 3
30780: ARRAY
30781: PUSH
30782: LD_INT 1
30784: ARRAY
30785: PUSH
30786: LD_INT 2
30788: EQUAL
30789: IFFALSE 30840
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
30791: LD_ADDR_EXP 79
30795: PUSH
30796: LD_EXP 79
30800: PPUSH
30801: LD_VAR 0 2
30805: PPUSH
30806: LD_EXP 79
30810: PUSH
30811: LD_VAR 0 2
30815: ARRAY
30816: PPUSH
30817: LD_VAR 0 3
30821: PPUSH
30822: LD_INT 1
30824: PPUSH
30825: LD_INT 0
30827: PPUSH
30828: CALL 56816 0 4
30832: PPUSH
30833: CALL_OW 1
30837: ST_TO_ADDR
// break ;
30838: GO 30842
// end ;
30840: GO 30762
30842: POP
30843: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
30844: LD_EXP 79
30848: PUSH
30849: LD_VAR 0 2
30853: ARRAY
30854: PUSH
30855: LD_INT 1
30857: ARRAY
30858: PUSH
30859: LD_INT 1
30861: ARRAY
30862: PUSH
30863: LD_INT 0
30865: EQUAL
30866: PUSH
30867: LD_VAR 0 5
30871: PUSH
30872: LD_VAR 0 5
30876: PPUSH
30877: LD_EXP 79
30881: PUSH
30882: LD_VAR 0 2
30886: ARRAY
30887: PUSH
30888: LD_INT 1
30890: ARRAY
30891: PUSH
30892: LD_INT 1
30894: ARRAY
30895: PPUSH
30896: LD_EXP 79
30900: PUSH
30901: LD_VAR 0 2
30905: ARRAY
30906: PUSH
30907: LD_INT 1
30909: ARRAY
30910: PUSH
30911: LD_INT 2
30913: ARRAY
30914: PPUSH
30915: LD_EXP 79
30919: PUSH
30920: LD_VAR 0 2
30924: ARRAY
30925: PUSH
30926: LD_INT 1
30928: ARRAY
30929: PUSH
30930: LD_INT 3
30932: ARRAY
30933: PPUSH
30934: LD_EXP 79
30938: PUSH
30939: LD_VAR 0 2
30943: ARRAY
30944: PUSH
30945: LD_INT 1
30947: ARRAY
30948: PUSH
30949: LD_INT 4
30951: ARRAY
30952: PPUSH
30953: CALL 64813 0 5
30957: AND
30958: OR
30959: IFFALSE 31240
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30961: LD_ADDR_VAR 0 4
30965: PUSH
30966: LD_EXP 74
30970: PUSH
30971: LD_VAR 0 2
30975: ARRAY
30976: PPUSH
30977: LD_INT 25
30979: PUSH
30980: LD_INT 2
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PPUSH
30987: CALL_OW 72
30991: PUSH
30992: LD_EXP 76
30996: PUSH
30997: LD_VAR 0 2
31001: ARRAY
31002: DIFF
31003: ST_TO_ADDR
// if not tmp then
31004: LD_VAR 0 4
31008: NOT
31009: IFFALSE 31013
// continue ;
31011: GO 30258
// for j in tmp do
31013: LD_ADDR_VAR 0 3
31017: PUSH
31018: LD_VAR 0 4
31022: PUSH
31023: FOR_IN
31024: IFFALSE 31236
// begin if not mc_builders [ i ] then
31026: LD_EXP 80
31030: PUSH
31031: LD_VAR 0 2
31035: ARRAY
31036: NOT
31037: IFFALSE 31095
// begin SetTag ( j , 103 ) ;
31039: LD_VAR 0 3
31043: PPUSH
31044: LD_INT 103
31046: PPUSH
31047: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31051: LD_ADDR_EXP 80
31055: PUSH
31056: LD_EXP 80
31060: PPUSH
31061: LD_VAR 0 2
31065: PUSH
31066: LD_EXP 80
31070: PUSH
31071: LD_VAR 0 2
31075: ARRAY
31076: PUSH
31077: LD_INT 1
31079: PLUS
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PPUSH
31085: LD_VAR 0 3
31089: PPUSH
31090: CALL 57398 0 3
31094: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31095: LD_VAR 0 3
31099: PPUSH
31100: CALL_OW 310
31104: IFFALSE 31115
// ComExitBuilding ( j ) ;
31106: LD_VAR 0 3
31110: PPUSH
31111: CALL_OW 122
// wait ( 3 ) ;
31115: LD_INT 3
31117: PPUSH
31118: CALL_OW 67
// if not mc_build_list [ i ] then
31122: LD_EXP 79
31126: PUSH
31127: LD_VAR 0 2
31131: ARRAY
31132: NOT
31133: IFFALSE 31137
// break ;
31135: GO 31236
// if not HasTask ( j ) then
31137: LD_VAR 0 3
31141: PPUSH
31142: CALL_OW 314
31146: NOT
31147: IFFALSE 31234
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31149: LD_VAR 0 3
31153: PPUSH
31154: LD_EXP 79
31158: PUSH
31159: LD_VAR 0 2
31163: ARRAY
31164: PUSH
31165: LD_INT 1
31167: ARRAY
31168: PUSH
31169: LD_INT 1
31171: ARRAY
31172: PPUSH
31173: LD_EXP 79
31177: PUSH
31178: LD_VAR 0 2
31182: ARRAY
31183: PUSH
31184: LD_INT 1
31186: ARRAY
31187: PUSH
31188: LD_INT 2
31190: ARRAY
31191: PPUSH
31192: LD_EXP 79
31196: PUSH
31197: LD_VAR 0 2
31201: ARRAY
31202: PUSH
31203: LD_INT 1
31205: ARRAY
31206: PUSH
31207: LD_INT 3
31209: ARRAY
31210: PPUSH
31211: LD_EXP 79
31215: PUSH
31216: LD_VAR 0 2
31220: ARRAY
31221: PUSH
31222: LD_INT 1
31224: ARRAY
31225: PUSH
31226: LD_INT 4
31228: ARRAY
31229: PPUSH
31230: CALL_OW 145
// end ;
31234: GO 31023
31236: POP
31237: POP
// end else
31238: GO 31382
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31240: LD_EXP 74
31244: PUSH
31245: LD_VAR 0 2
31249: ARRAY
31250: PPUSH
31251: LD_EXP 79
31255: PUSH
31256: LD_VAR 0 2
31260: ARRAY
31261: PUSH
31262: LD_INT 1
31264: ARRAY
31265: PUSH
31266: LD_INT 1
31268: ARRAY
31269: PPUSH
31270: LD_EXP 79
31274: PUSH
31275: LD_VAR 0 2
31279: ARRAY
31280: PUSH
31281: LD_INT 1
31283: ARRAY
31284: PUSH
31285: LD_INT 2
31287: ARRAY
31288: PPUSH
31289: LD_EXP 79
31293: PUSH
31294: LD_VAR 0 2
31298: ARRAY
31299: PUSH
31300: LD_INT 1
31302: ARRAY
31303: PUSH
31304: LD_INT 3
31306: ARRAY
31307: PPUSH
31308: LD_EXP 79
31312: PUSH
31313: LD_VAR 0 2
31317: ARRAY
31318: PUSH
31319: LD_INT 1
31321: ARRAY
31322: PUSH
31323: LD_INT 4
31325: ARRAY
31326: PPUSH
31327: CALL 64149 0 5
31331: NOT
31332: IFFALSE 31382
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31334: LD_ADDR_EXP 79
31338: PUSH
31339: LD_EXP 79
31343: PPUSH
31344: LD_VAR 0 2
31348: PPUSH
31349: LD_EXP 79
31353: PUSH
31354: LD_VAR 0 2
31358: ARRAY
31359: PPUSH
31360: LD_INT 1
31362: PPUSH
31363: LD_INT 1
31365: NEG
31366: PPUSH
31367: LD_INT 0
31369: PPUSH
31370: CALL 56816 0 4
31374: PPUSH
31375: CALL_OW 1
31379: ST_TO_ADDR
// continue ;
31380: GO 30258
// end ; end ; end ;
31382: GO 30258
31384: POP
31385: POP
// end ;
31386: LD_VAR 0 1
31390: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31391: LD_INT 0
31393: PPUSH
31394: PPUSH
31395: PPUSH
31396: PPUSH
31397: PPUSH
31398: PPUSH
// if not mc_bases then
31399: LD_EXP 74
31403: NOT
31404: IFFALSE 31408
// exit ;
31406: GO 31835
// for i = 1 to mc_bases do
31408: LD_ADDR_VAR 0 2
31412: PUSH
31413: DOUBLE
31414: LD_INT 1
31416: DEC
31417: ST_TO_ADDR
31418: LD_EXP 74
31422: PUSH
31423: FOR_TO
31424: IFFALSE 31833
// begin tmp := mc_build_upgrade [ i ] ;
31426: LD_ADDR_VAR 0 4
31430: PUSH
31431: LD_EXP 106
31435: PUSH
31436: LD_VAR 0 2
31440: ARRAY
31441: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31442: LD_ADDR_VAR 0 6
31446: PUSH
31447: LD_EXP 107
31451: PUSH
31452: LD_VAR 0 2
31456: ARRAY
31457: PPUSH
31458: LD_INT 2
31460: PUSH
31461: LD_INT 30
31463: PUSH
31464: LD_INT 6
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 30
31473: PUSH
31474: LD_INT 7
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: LIST
31485: PPUSH
31486: CALL_OW 72
31490: ST_TO_ADDR
// if not tmp and not lab then
31491: LD_VAR 0 4
31495: NOT
31496: PUSH
31497: LD_VAR 0 6
31501: NOT
31502: AND
31503: IFFALSE 31507
// continue ;
31505: GO 31423
// if tmp then
31507: LD_VAR 0 4
31511: IFFALSE 31631
// for j in tmp do
31513: LD_ADDR_VAR 0 3
31517: PUSH
31518: LD_VAR 0 4
31522: PUSH
31523: FOR_IN
31524: IFFALSE 31629
// begin if UpgradeCost ( j ) then
31526: LD_VAR 0 3
31530: PPUSH
31531: CALL 63809 0 1
31535: IFFALSE 31627
// begin ComUpgrade ( j ) ;
31537: LD_VAR 0 3
31541: PPUSH
31542: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31546: LD_ADDR_EXP 106
31550: PUSH
31551: LD_EXP 106
31555: PPUSH
31556: LD_VAR 0 2
31560: PPUSH
31561: LD_EXP 106
31565: PUSH
31566: LD_VAR 0 2
31570: ARRAY
31571: PUSH
31572: LD_VAR 0 3
31576: DIFF
31577: PPUSH
31578: CALL_OW 1
31582: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31583: LD_ADDR_EXP 81
31587: PUSH
31588: LD_EXP 81
31592: PPUSH
31593: LD_VAR 0 2
31597: PUSH
31598: LD_EXP 81
31602: PUSH
31603: LD_VAR 0 2
31607: ARRAY
31608: PUSH
31609: LD_INT 1
31611: PLUS
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PPUSH
31617: LD_VAR 0 3
31621: PPUSH
31622: CALL 57398 0 3
31626: ST_TO_ADDR
// end ; end ;
31627: GO 31523
31629: POP
31630: POP
// if not lab or not mc_lab_upgrade [ i ] then
31631: LD_VAR 0 6
31635: NOT
31636: PUSH
31637: LD_EXP 108
31641: PUSH
31642: LD_VAR 0 2
31646: ARRAY
31647: NOT
31648: OR
31649: IFFALSE 31653
// continue ;
31651: GO 31423
// for j in lab do
31653: LD_ADDR_VAR 0 3
31657: PUSH
31658: LD_VAR 0 6
31662: PUSH
31663: FOR_IN
31664: IFFALSE 31829
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
31666: LD_VAR 0 3
31670: PPUSH
31671: CALL_OW 266
31675: PUSH
31676: LD_INT 6
31678: PUSH
31679: LD_INT 7
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: IN
31686: PUSH
31687: LD_VAR 0 3
31691: PPUSH
31692: CALL_OW 461
31696: PUSH
31697: LD_INT 1
31699: NONEQUAL
31700: AND
31701: IFFALSE 31827
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
31703: LD_VAR 0 3
31707: PPUSH
31708: LD_EXP 108
31712: PUSH
31713: LD_VAR 0 2
31717: ARRAY
31718: PUSH
31719: LD_INT 1
31721: ARRAY
31722: PPUSH
31723: CALL 64014 0 2
31727: IFFALSE 31827
// begin ComCancel ( j ) ;
31729: LD_VAR 0 3
31733: PPUSH
31734: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
31738: LD_VAR 0 3
31742: PPUSH
31743: LD_EXP 108
31747: PUSH
31748: LD_VAR 0 2
31752: ARRAY
31753: PUSH
31754: LD_INT 1
31756: ARRAY
31757: PPUSH
31758: CALL_OW 207
// if not j in mc_construct_list [ i ] then
31762: LD_VAR 0 3
31766: PUSH
31767: LD_EXP 81
31771: PUSH
31772: LD_VAR 0 2
31776: ARRAY
31777: IN
31778: NOT
31779: IFFALSE 31825
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31781: LD_ADDR_EXP 81
31785: PUSH
31786: LD_EXP 81
31790: PPUSH
31791: LD_VAR 0 2
31795: PUSH
31796: LD_EXP 81
31800: PUSH
31801: LD_VAR 0 2
31805: ARRAY
31806: PUSH
31807: LD_INT 1
31809: PLUS
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PPUSH
31815: LD_VAR 0 3
31819: PPUSH
31820: CALL 57398 0 3
31824: ST_TO_ADDR
// break ;
31825: GO 31829
// end ; end ; end ;
31827: GO 31663
31829: POP
31830: POP
// end ;
31831: GO 31423
31833: POP
31834: POP
// end ;
31835: LD_VAR 0 1
31839: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
31840: LD_INT 0
31842: PPUSH
31843: PPUSH
31844: PPUSH
31845: PPUSH
31846: PPUSH
31847: PPUSH
31848: PPUSH
31849: PPUSH
31850: PPUSH
// if not mc_bases then
31851: LD_EXP 74
31855: NOT
31856: IFFALSE 31860
// exit ;
31858: GO 32265
// for i = 1 to mc_bases do
31860: LD_ADDR_VAR 0 2
31864: PUSH
31865: DOUBLE
31866: LD_INT 1
31868: DEC
31869: ST_TO_ADDR
31870: LD_EXP 74
31874: PUSH
31875: FOR_TO
31876: IFFALSE 32263
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
31878: LD_EXP 82
31882: PUSH
31883: LD_VAR 0 2
31887: ARRAY
31888: NOT
31889: PUSH
31890: LD_EXP 74
31894: PUSH
31895: LD_VAR 0 2
31899: ARRAY
31900: PPUSH
31901: LD_INT 30
31903: PUSH
31904: LD_INT 3
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PPUSH
31911: CALL_OW 72
31915: NOT
31916: OR
31917: IFFALSE 31921
// continue ;
31919: GO 31875
// busy := false ;
31921: LD_ADDR_VAR 0 8
31925: PUSH
31926: LD_INT 0
31928: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
31929: LD_ADDR_VAR 0 4
31933: PUSH
31934: LD_EXP 74
31938: PUSH
31939: LD_VAR 0 2
31943: ARRAY
31944: PPUSH
31945: LD_INT 30
31947: PUSH
31948: LD_INT 3
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PPUSH
31955: CALL_OW 72
31959: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
31960: LD_ADDR_VAR 0 6
31964: PUSH
31965: LD_EXP 82
31969: PUSH
31970: LD_VAR 0 2
31974: ARRAY
31975: PPUSH
31976: LD_INT 2
31978: PUSH
31979: LD_INT 30
31981: PUSH
31982: LD_INT 32
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 30
31991: PUSH
31992: LD_INT 33
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: LIST
32003: PPUSH
32004: CALL_OW 72
32008: ST_TO_ADDR
// if not t then
32009: LD_VAR 0 6
32013: NOT
32014: IFFALSE 32018
// continue ;
32016: GO 31875
// for j in tmp do
32018: LD_ADDR_VAR 0 3
32022: PUSH
32023: LD_VAR 0 4
32027: PUSH
32028: FOR_IN
32029: IFFALSE 32059
// if not BuildingStatus ( j ) = bs_idle then
32031: LD_VAR 0 3
32035: PPUSH
32036: CALL_OW 461
32040: PUSH
32041: LD_INT 2
32043: EQUAL
32044: NOT
32045: IFFALSE 32057
// begin busy := true ;
32047: LD_ADDR_VAR 0 8
32051: PUSH
32052: LD_INT 1
32054: ST_TO_ADDR
// break ;
32055: GO 32059
// end ;
32057: GO 32028
32059: POP
32060: POP
// if busy then
32061: LD_VAR 0 8
32065: IFFALSE 32069
// continue ;
32067: GO 31875
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32069: LD_ADDR_VAR 0 7
32073: PUSH
32074: LD_VAR 0 6
32078: PPUSH
32079: LD_INT 35
32081: PUSH
32082: LD_INT 0
32084: PUSH
32085: EMPTY
32086: LIST
32087: LIST
32088: PPUSH
32089: CALL_OW 72
32093: ST_TO_ADDR
// if tw then
32094: LD_VAR 0 7
32098: IFFALSE 32175
// begin tw := tw [ 1 ] ;
32100: LD_ADDR_VAR 0 7
32104: PUSH
32105: LD_VAR 0 7
32109: PUSH
32110: LD_INT 1
32112: ARRAY
32113: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32114: LD_ADDR_VAR 0 9
32118: PUSH
32119: LD_VAR 0 7
32123: PPUSH
32124: LD_EXP 99
32128: PUSH
32129: LD_VAR 0 2
32133: ARRAY
32134: PPUSH
32135: CALL 62368 0 2
32139: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32140: LD_EXP 113
32144: PUSH
32145: LD_VAR 0 2
32149: ARRAY
32150: IFFALSE 32173
// if not weapon in mc_allowed_tower_weapons [ i ] then
32152: LD_VAR 0 9
32156: PUSH
32157: LD_EXP 113
32161: PUSH
32162: LD_VAR 0 2
32166: ARRAY
32167: IN
32168: NOT
32169: IFFALSE 32173
// continue ;
32171: GO 31875
// end else
32173: GO 32238
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32175: LD_ADDR_VAR 0 5
32179: PUSH
32180: LD_EXP 82
32184: PUSH
32185: LD_VAR 0 2
32189: ARRAY
32190: PPUSH
32191: LD_VAR 0 4
32195: PPUSH
32196: CALL 92569 0 2
32200: ST_TO_ADDR
// if not tmp2 then
32201: LD_VAR 0 5
32205: NOT
32206: IFFALSE 32210
// continue ;
32208: GO 31875
// tw := tmp2 [ 1 ] ;
32210: LD_ADDR_VAR 0 7
32214: PUSH
32215: LD_VAR 0 5
32219: PUSH
32220: LD_INT 1
32222: ARRAY
32223: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32224: LD_ADDR_VAR 0 9
32228: PUSH
32229: LD_VAR 0 5
32233: PUSH
32234: LD_INT 2
32236: ARRAY
32237: ST_TO_ADDR
// end ; if not weapon then
32238: LD_VAR 0 9
32242: NOT
32243: IFFALSE 32247
// continue ;
32245: GO 31875
// ComPlaceWeapon ( tw , weapon ) ;
32247: LD_VAR 0 7
32251: PPUSH
32252: LD_VAR 0 9
32256: PPUSH
32257: CALL_OW 148
// end ;
32261: GO 31875
32263: POP
32264: POP
// end ;
32265: LD_VAR 0 1
32269: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32270: LD_INT 0
32272: PPUSH
32273: PPUSH
32274: PPUSH
32275: PPUSH
32276: PPUSH
32277: PPUSH
// if not mc_bases then
32278: LD_EXP 74
32282: NOT
32283: IFFALSE 32287
// exit ;
32285: GO 33299
// for i = 1 to mc_bases do
32287: LD_ADDR_VAR 0 2
32291: PUSH
32292: DOUBLE
32293: LD_INT 1
32295: DEC
32296: ST_TO_ADDR
32297: LD_EXP 74
32301: PUSH
32302: FOR_TO
32303: IFFALSE 33297
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
32305: LD_EXP 87
32309: PUSH
32310: LD_VAR 0 2
32314: ARRAY
32315: NOT
32316: PUSH
32317: LD_EXP 87
32321: PUSH
32322: LD_VAR 0 2
32326: ARRAY
32327: PUSH
32328: LD_EXP 88
32332: PUSH
32333: LD_VAR 0 2
32337: ARRAY
32338: EQUAL
32339: OR
32340: IFFALSE 32344
// continue ;
32342: GO 32302
// if mc_miners [ i ] then
32344: LD_EXP 88
32348: PUSH
32349: LD_VAR 0 2
32353: ARRAY
32354: IFFALSE 32984
// begin k := 1 ;
32356: LD_ADDR_VAR 0 4
32360: PUSH
32361: LD_INT 1
32363: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
32364: LD_ADDR_VAR 0 3
32368: PUSH
32369: DOUBLE
32370: LD_EXP 88
32374: PUSH
32375: LD_VAR 0 2
32379: ARRAY
32380: INC
32381: ST_TO_ADDR
32382: LD_INT 1
32384: PUSH
32385: FOR_DOWNTO
32386: IFFALSE 32982
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32388: LD_EXP 88
32392: PUSH
32393: LD_VAR 0 2
32397: ARRAY
32398: PUSH
32399: LD_VAR 0 3
32403: ARRAY
32404: PPUSH
32405: CALL_OW 301
32409: PUSH
32410: LD_EXP 88
32414: PUSH
32415: LD_VAR 0 2
32419: ARRAY
32420: PUSH
32421: LD_VAR 0 3
32425: ARRAY
32426: PPUSH
32427: CALL_OW 257
32431: PUSH
32432: LD_INT 1
32434: NONEQUAL
32435: OR
32436: IFFALSE 32499
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32438: LD_ADDR_VAR 0 5
32442: PUSH
32443: LD_EXP 88
32447: PUSH
32448: LD_VAR 0 2
32452: ARRAY
32453: PUSH
32454: LD_EXP 88
32458: PUSH
32459: LD_VAR 0 2
32463: ARRAY
32464: PUSH
32465: LD_VAR 0 3
32469: ARRAY
32470: DIFF
32471: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
32472: LD_ADDR_EXP 88
32476: PUSH
32477: LD_EXP 88
32481: PPUSH
32482: LD_VAR 0 2
32486: PPUSH
32487: LD_VAR 0 5
32491: PPUSH
32492: CALL_OW 1
32496: ST_TO_ADDR
// continue ;
32497: GO 32385
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
32499: LD_EXP 88
32503: PUSH
32504: LD_VAR 0 2
32508: ARRAY
32509: PUSH
32510: LD_VAR 0 3
32514: ARRAY
32515: PPUSH
32516: CALL 57334 0 1
32520: PUSH
32521: LD_EXP 88
32525: PUSH
32526: LD_VAR 0 2
32530: ARRAY
32531: PUSH
32532: LD_VAR 0 3
32536: ARRAY
32537: PPUSH
32538: CALL_OW 255
32542: PPUSH
32543: LD_EXP 87
32547: PUSH
32548: LD_VAR 0 2
32552: ARRAY
32553: PUSH
32554: LD_VAR 0 4
32558: ARRAY
32559: PUSH
32560: LD_INT 1
32562: ARRAY
32563: PPUSH
32564: LD_EXP 87
32568: PUSH
32569: LD_VAR 0 2
32573: ARRAY
32574: PUSH
32575: LD_VAR 0 4
32579: ARRAY
32580: PUSH
32581: LD_INT 2
32583: ARRAY
32584: PPUSH
32585: LD_INT 15
32587: PPUSH
32588: CALL 58294 0 4
32592: PUSH
32593: LD_INT 4
32595: ARRAY
32596: PUSH
32597: LD_EXP 88
32601: PUSH
32602: LD_VAR 0 2
32606: ARRAY
32607: PUSH
32608: LD_VAR 0 3
32612: ARRAY
32613: PPUSH
32614: LD_INT 10
32616: PPUSH
32617: CALL 59991 0 2
32621: PUSH
32622: LD_INT 4
32624: ARRAY
32625: OR
32626: AND
32627: IFFALSE 32650
// ComStop ( mc_miners [ i ] [ j ] ) ;
32629: LD_EXP 88
32633: PUSH
32634: LD_VAR 0 2
32638: ARRAY
32639: PUSH
32640: LD_VAR 0 3
32644: ARRAY
32645: PPUSH
32646: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
32650: LD_EXP 88
32654: PUSH
32655: LD_VAR 0 2
32659: ARRAY
32660: PUSH
32661: LD_VAR 0 3
32665: ARRAY
32666: PPUSH
32667: CALL_OW 257
32671: PUSH
32672: LD_INT 1
32674: EQUAL
32675: PUSH
32676: LD_EXP 88
32680: PUSH
32681: LD_VAR 0 2
32685: ARRAY
32686: PUSH
32687: LD_VAR 0 3
32691: ARRAY
32692: PPUSH
32693: CALL_OW 459
32697: NOT
32698: AND
32699: PUSH
32700: LD_EXP 88
32704: PUSH
32705: LD_VAR 0 2
32709: ARRAY
32710: PUSH
32711: LD_VAR 0 3
32715: ARRAY
32716: PPUSH
32717: CALL_OW 255
32721: PPUSH
32722: LD_EXP 87
32726: PUSH
32727: LD_VAR 0 2
32731: ARRAY
32732: PUSH
32733: LD_VAR 0 4
32737: ARRAY
32738: PUSH
32739: LD_INT 1
32741: ARRAY
32742: PPUSH
32743: LD_EXP 87
32747: PUSH
32748: LD_VAR 0 2
32752: ARRAY
32753: PUSH
32754: LD_VAR 0 4
32758: ARRAY
32759: PUSH
32760: LD_INT 2
32762: ARRAY
32763: PPUSH
32764: LD_INT 15
32766: PPUSH
32767: CALL 58294 0 4
32771: PUSH
32772: LD_INT 4
32774: ARRAY
32775: PUSH
32776: LD_INT 0
32778: EQUAL
32779: AND
32780: PUSH
32781: LD_EXP 88
32785: PUSH
32786: LD_VAR 0 2
32790: ARRAY
32791: PUSH
32792: LD_VAR 0 3
32796: ARRAY
32797: PPUSH
32798: CALL_OW 314
32802: NOT
32803: AND
32804: IFFALSE 32980
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32806: LD_EXP 88
32810: PUSH
32811: LD_VAR 0 2
32815: ARRAY
32816: PUSH
32817: LD_VAR 0 3
32821: ARRAY
32822: PPUSH
32823: CALL_OW 310
32827: IFFALSE 32850
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32829: LD_EXP 88
32833: PUSH
32834: LD_VAR 0 2
32838: ARRAY
32839: PUSH
32840: LD_VAR 0 3
32844: ARRAY
32845: PPUSH
32846: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
32850: LD_EXP 88
32854: PUSH
32855: LD_VAR 0 2
32859: ARRAY
32860: PUSH
32861: LD_VAR 0 3
32865: ARRAY
32866: PPUSH
32867: CALL_OW 314
32871: NOT
32872: IFFALSE 32940
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
32874: LD_EXP 88
32878: PUSH
32879: LD_VAR 0 2
32883: ARRAY
32884: PUSH
32885: LD_VAR 0 3
32889: ARRAY
32890: PPUSH
32891: LD_EXP 87
32895: PUSH
32896: LD_VAR 0 2
32900: ARRAY
32901: PUSH
32902: LD_VAR 0 4
32906: ARRAY
32907: PUSH
32908: LD_INT 1
32910: ARRAY
32911: PPUSH
32912: LD_EXP 87
32916: PUSH
32917: LD_VAR 0 2
32921: ARRAY
32922: PUSH
32923: LD_VAR 0 4
32927: ARRAY
32928: PUSH
32929: LD_INT 2
32931: ARRAY
32932: PPUSH
32933: LD_INT 0
32935: PPUSH
32936: CALL_OW 193
// k := k + 1 ;
32940: LD_ADDR_VAR 0 4
32944: PUSH
32945: LD_VAR 0 4
32949: PUSH
32950: LD_INT 1
32952: PLUS
32953: ST_TO_ADDR
// if k > mc_mines [ i ] then
32954: LD_VAR 0 4
32958: PUSH
32959: LD_EXP 87
32963: PUSH
32964: LD_VAR 0 2
32968: ARRAY
32969: GREATER
32970: IFFALSE 32980
// k := 1 ;
32972: LD_ADDR_VAR 0 4
32976: PUSH
32977: LD_INT 1
32979: ST_TO_ADDR
// end ; end ;
32980: GO 32385
32982: POP
32983: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
32984: LD_ADDR_VAR 0 5
32988: PUSH
32989: LD_EXP 74
32993: PUSH
32994: LD_VAR 0 2
32998: ARRAY
32999: PPUSH
33000: LD_INT 2
33002: PUSH
33003: LD_INT 30
33005: PUSH
33006: LD_INT 4
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 30
33015: PUSH
33016: LD_INT 5
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: PUSH
33023: LD_INT 30
33025: PUSH
33026: LD_INT 32
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: EMPTY
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: PPUSH
33039: CALL_OW 72
33043: ST_TO_ADDR
// if not tmp then
33044: LD_VAR 0 5
33048: NOT
33049: IFFALSE 33053
// continue ;
33051: GO 32302
// list := [ ] ;
33053: LD_ADDR_VAR 0 6
33057: PUSH
33058: EMPTY
33059: ST_TO_ADDR
// for j in tmp do
33060: LD_ADDR_VAR 0 3
33064: PUSH
33065: LD_VAR 0 5
33069: PUSH
33070: FOR_IN
33071: IFFALSE 33140
// begin for k in UnitsInside ( j ) do
33073: LD_ADDR_VAR 0 4
33077: PUSH
33078: LD_VAR 0 3
33082: PPUSH
33083: CALL_OW 313
33087: PUSH
33088: FOR_IN
33089: IFFALSE 33136
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33091: LD_VAR 0 4
33095: PPUSH
33096: CALL_OW 257
33100: PUSH
33101: LD_INT 1
33103: EQUAL
33104: PUSH
33105: LD_VAR 0 4
33109: PPUSH
33110: CALL_OW 459
33114: NOT
33115: AND
33116: IFFALSE 33134
// list := list ^ k ;
33118: LD_ADDR_VAR 0 6
33122: PUSH
33123: LD_VAR 0 6
33127: PUSH
33128: LD_VAR 0 4
33132: ADD
33133: ST_TO_ADDR
33134: GO 33088
33136: POP
33137: POP
// end ;
33138: GO 33070
33140: POP
33141: POP
// list := list diff mc_miners [ i ] ;
33142: LD_ADDR_VAR 0 6
33146: PUSH
33147: LD_VAR 0 6
33151: PUSH
33152: LD_EXP 88
33156: PUSH
33157: LD_VAR 0 2
33161: ARRAY
33162: DIFF
33163: ST_TO_ADDR
// if not list then
33164: LD_VAR 0 6
33168: NOT
33169: IFFALSE 33173
// continue ;
33171: GO 32302
// k := mc_mines [ i ] - mc_miners [ i ] ;
33173: LD_ADDR_VAR 0 4
33177: PUSH
33178: LD_EXP 87
33182: PUSH
33183: LD_VAR 0 2
33187: ARRAY
33188: PUSH
33189: LD_EXP 88
33193: PUSH
33194: LD_VAR 0 2
33198: ARRAY
33199: MINUS
33200: ST_TO_ADDR
// if k > list then
33201: LD_VAR 0 4
33205: PUSH
33206: LD_VAR 0 6
33210: GREATER
33211: IFFALSE 33223
// k := list ;
33213: LD_ADDR_VAR 0 4
33217: PUSH
33218: LD_VAR 0 6
33222: ST_TO_ADDR
// for j = 1 to k do
33223: LD_ADDR_VAR 0 3
33227: PUSH
33228: DOUBLE
33229: LD_INT 1
33231: DEC
33232: ST_TO_ADDR
33233: LD_VAR 0 4
33237: PUSH
33238: FOR_TO
33239: IFFALSE 33293
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33241: LD_ADDR_EXP 88
33245: PUSH
33246: LD_EXP 88
33250: PPUSH
33251: LD_VAR 0 2
33255: PUSH
33256: LD_EXP 88
33260: PUSH
33261: LD_VAR 0 2
33265: ARRAY
33266: PUSH
33267: LD_INT 1
33269: PLUS
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PPUSH
33275: LD_VAR 0 6
33279: PUSH
33280: LD_VAR 0 3
33284: ARRAY
33285: PPUSH
33286: CALL 57398 0 3
33290: ST_TO_ADDR
33291: GO 33238
33293: POP
33294: POP
// end ;
33295: GO 32302
33297: POP
33298: POP
// end ;
33299: LD_VAR 0 1
33303: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33304: LD_INT 0
33306: PPUSH
33307: PPUSH
33308: PPUSH
33309: PPUSH
33310: PPUSH
33311: PPUSH
33312: PPUSH
33313: PPUSH
33314: PPUSH
33315: PPUSH
// if not mc_bases then
33316: LD_EXP 74
33320: NOT
33321: IFFALSE 33325
// exit ;
33323: GO 35075
// for i = 1 to mc_bases do
33325: LD_ADDR_VAR 0 2
33329: PUSH
33330: DOUBLE
33331: LD_INT 1
33333: DEC
33334: ST_TO_ADDR
33335: LD_EXP 74
33339: PUSH
33340: FOR_TO
33341: IFFALSE 35073
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33343: LD_EXP 74
33347: PUSH
33348: LD_VAR 0 2
33352: ARRAY
33353: NOT
33354: PUSH
33355: LD_EXP 81
33359: PUSH
33360: LD_VAR 0 2
33364: ARRAY
33365: OR
33366: IFFALSE 33370
// continue ;
33368: GO 33340
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33370: LD_EXP 90
33374: PUSH
33375: LD_VAR 0 2
33379: ARRAY
33380: NOT
33381: PUSH
33382: LD_EXP 91
33386: PUSH
33387: LD_VAR 0 2
33391: ARRAY
33392: AND
33393: IFFALSE 33431
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33395: LD_ADDR_EXP 91
33399: PUSH
33400: LD_EXP 91
33404: PPUSH
33405: LD_VAR 0 2
33409: PPUSH
33410: EMPTY
33411: PPUSH
33412: CALL_OW 1
33416: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33417: LD_VAR 0 2
33421: PPUSH
33422: LD_INT 107
33424: PPUSH
33425: CALL 24185 0 2
// continue ;
33429: GO 33340
// end ; target := [ ] ;
33431: LD_ADDR_VAR 0 6
33435: PUSH
33436: EMPTY
33437: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33438: LD_ADDR_VAR 0 3
33442: PUSH
33443: DOUBLE
33444: LD_EXP 90
33448: PUSH
33449: LD_VAR 0 2
33453: ARRAY
33454: INC
33455: ST_TO_ADDR
33456: LD_INT 1
33458: PUSH
33459: FOR_DOWNTO
33460: IFFALSE 33720
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33462: LD_EXP 90
33466: PUSH
33467: LD_VAR 0 2
33471: ARRAY
33472: PUSH
33473: LD_VAR 0 3
33477: ARRAY
33478: PUSH
33479: LD_INT 2
33481: ARRAY
33482: PPUSH
33483: LD_EXP 90
33487: PUSH
33488: LD_VAR 0 2
33492: ARRAY
33493: PUSH
33494: LD_VAR 0 3
33498: ARRAY
33499: PUSH
33500: LD_INT 3
33502: ARRAY
33503: PPUSH
33504: CALL_OW 488
33508: PUSH
33509: LD_EXP 90
33513: PUSH
33514: LD_VAR 0 2
33518: ARRAY
33519: PUSH
33520: LD_VAR 0 3
33524: ARRAY
33525: PUSH
33526: LD_INT 2
33528: ARRAY
33529: PPUSH
33530: LD_EXP 90
33534: PUSH
33535: LD_VAR 0 2
33539: ARRAY
33540: PUSH
33541: LD_VAR 0 3
33545: ARRAY
33546: PUSH
33547: LD_INT 3
33549: ARRAY
33550: PPUSH
33551: CALL_OW 284
33555: PUSH
33556: LD_INT 0
33558: EQUAL
33559: AND
33560: IFFALSE 33615
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33562: LD_ADDR_VAR 0 5
33566: PUSH
33567: LD_EXP 90
33571: PUSH
33572: LD_VAR 0 2
33576: ARRAY
33577: PPUSH
33578: LD_VAR 0 3
33582: PPUSH
33583: CALL_OW 3
33587: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33588: LD_ADDR_EXP 90
33592: PUSH
33593: LD_EXP 90
33597: PPUSH
33598: LD_VAR 0 2
33602: PPUSH
33603: LD_VAR 0 5
33607: PPUSH
33608: CALL_OW 1
33612: ST_TO_ADDR
// continue ;
33613: GO 33459
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33615: LD_EXP 74
33619: PUSH
33620: LD_VAR 0 2
33624: ARRAY
33625: PUSH
33626: LD_INT 1
33628: ARRAY
33629: PPUSH
33630: CALL_OW 255
33634: PPUSH
33635: LD_EXP 90
33639: PUSH
33640: LD_VAR 0 2
33644: ARRAY
33645: PUSH
33646: LD_VAR 0 3
33650: ARRAY
33651: PUSH
33652: LD_INT 2
33654: ARRAY
33655: PPUSH
33656: LD_EXP 90
33660: PUSH
33661: LD_VAR 0 2
33665: ARRAY
33666: PUSH
33667: LD_VAR 0 3
33671: ARRAY
33672: PUSH
33673: LD_INT 3
33675: ARRAY
33676: PPUSH
33677: LD_INT 30
33679: PPUSH
33680: CALL 58294 0 4
33684: PUSH
33685: LD_INT 4
33687: ARRAY
33688: PUSH
33689: LD_INT 0
33691: EQUAL
33692: IFFALSE 33718
// begin target := mc_crates [ i ] [ j ] ;
33694: LD_ADDR_VAR 0 6
33698: PUSH
33699: LD_EXP 90
33703: PUSH
33704: LD_VAR 0 2
33708: ARRAY
33709: PUSH
33710: LD_VAR 0 3
33714: ARRAY
33715: ST_TO_ADDR
// break ;
33716: GO 33720
// end ; end ;
33718: GO 33459
33720: POP
33721: POP
// if not target then
33722: LD_VAR 0 6
33726: NOT
33727: IFFALSE 33731
// continue ;
33729: GO 33340
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33731: LD_ADDR_VAR 0 7
33735: PUSH
33736: LD_EXP 93
33740: PUSH
33741: LD_VAR 0 2
33745: ARRAY
33746: PPUSH
33747: LD_INT 2
33749: PUSH
33750: LD_INT 3
33752: PUSH
33753: LD_INT 58
33755: PUSH
33756: EMPTY
33757: LIST
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 61
33765: PUSH
33766: EMPTY
33767: LIST
33768: PUSH
33769: LD_INT 33
33771: PUSH
33772: LD_INT 5
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 33
33781: PUSH
33782: LD_INT 3
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: LIST
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 2
33798: PUSH
33799: LD_INT 34
33801: PUSH
33802: LD_INT 32
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 34
33811: PUSH
33812: LD_INT 51
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 34
33821: PUSH
33822: LD_INT 12
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PPUSH
33839: CALL_OW 72
33843: ST_TO_ADDR
// if not cargo then
33844: LD_VAR 0 7
33848: NOT
33849: IFFALSE 34492
// begin if mc_crates_collector [ i ] < 5 then
33851: LD_EXP 91
33855: PUSH
33856: LD_VAR 0 2
33860: ARRAY
33861: PUSH
33862: LD_INT 5
33864: LESS
33865: IFFALSE 34231
// begin if mc_ape [ i ] then
33867: LD_EXP 103
33871: PUSH
33872: LD_VAR 0 2
33876: ARRAY
33877: IFFALSE 33924
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
33879: LD_ADDR_VAR 0 5
33883: PUSH
33884: LD_EXP 103
33888: PUSH
33889: LD_VAR 0 2
33893: ARRAY
33894: PPUSH
33895: LD_INT 25
33897: PUSH
33898: LD_INT 16
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 24
33907: PUSH
33908: LD_INT 750
33910: PUSH
33911: EMPTY
33912: LIST
33913: LIST
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PPUSH
33919: CALL_OW 72
33923: ST_TO_ADDR
// if not tmp then
33924: LD_VAR 0 5
33928: NOT
33929: IFFALSE 33976
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
33931: LD_ADDR_VAR 0 5
33935: PUSH
33936: LD_EXP 74
33940: PUSH
33941: LD_VAR 0 2
33945: ARRAY
33946: PPUSH
33947: LD_INT 25
33949: PUSH
33950: LD_INT 2
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 24
33959: PUSH
33960: LD_INT 750
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PPUSH
33971: CALL_OW 72
33975: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
33976: LD_EXP 103
33980: PUSH
33981: LD_VAR 0 2
33985: ARRAY
33986: PUSH
33987: LD_EXP 74
33991: PUSH
33992: LD_VAR 0 2
33996: ARRAY
33997: PPUSH
33998: LD_INT 25
34000: PUSH
34001: LD_INT 2
34003: PUSH
34004: EMPTY
34005: LIST
34006: LIST
34007: PUSH
34008: LD_INT 24
34010: PUSH
34011: LD_INT 750
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PPUSH
34022: CALL_OW 72
34026: AND
34027: PUSH
34028: LD_VAR 0 5
34032: PUSH
34033: LD_INT 5
34035: LESS
34036: AND
34037: IFFALSE 34119
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34039: LD_ADDR_VAR 0 3
34043: PUSH
34044: LD_EXP 74
34048: PUSH
34049: LD_VAR 0 2
34053: ARRAY
34054: PPUSH
34055: LD_INT 25
34057: PUSH
34058: LD_INT 2
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 24
34067: PUSH
34068: LD_INT 750
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PPUSH
34079: CALL_OW 72
34083: PUSH
34084: FOR_IN
34085: IFFALSE 34117
// begin tmp := tmp union j ;
34087: LD_ADDR_VAR 0 5
34091: PUSH
34092: LD_VAR 0 5
34096: PUSH
34097: LD_VAR 0 3
34101: UNION
34102: ST_TO_ADDR
// if tmp >= 5 then
34103: LD_VAR 0 5
34107: PUSH
34108: LD_INT 5
34110: GREATEREQUAL
34111: IFFALSE 34115
// break ;
34113: GO 34117
// end ;
34115: GO 34084
34117: POP
34118: POP
// end ; if not tmp then
34119: LD_VAR 0 5
34123: NOT
34124: IFFALSE 34128
// continue ;
34126: GO 33340
// for j in tmp do
34128: LD_ADDR_VAR 0 3
34132: PUSH
34133: LD_VAR 0 5
34137: PUSH
34138: FOR_IN
34139: IFFALSE 34229
// if not GetTag ( j ) then
34141: LD_VAR 0 3
34145: PPUSH
34146: CALL_OW 110
34150: NOT
34151: IFFALSE 34227
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34153: LD_ADDR_EXP 91
34157: PUSH
34158: LD_EXP 91
34162: PPUSH
34163: LD_VAR 0 2
34167: PUSH
34168: LD_EXP 91
34172: PUSH
34173: LD_VAR 0 2
34177: ARRAY
34178: PUSH
34179: LD_INT 1
34181: PLUS
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PPUSH
34187: LD_VAR 0 3
34191: PPUSH
34192: CALL 57398 0 3
34196: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34197: LD_VAR 0 3
34201: PPUSH
34202: LD_INT 107
34204: PPUSH
34205: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34209: LD_EXP 91
34213: PUSH
34214: LD_VAR 0 2
34218: ARRAY
34219: PUSH
34220: LD_INT 5
34222: GREATEREQUAL
34223: IFFALSE 34227
// break ;
34225: GO 34229
// end ;
34227: GO 34138
34229: POP
34230: POP
// end ; if mc_crates_collector [ i ] and target then
34231: LD_EXP 91
34235: PUSH
34236: LD_VAR 0 2
34240: ARRAY
34241: PUSH
34242: LD_VAR 0 6
34246: AND
34247: IFFALSE 34490
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34249: LD_EXP 91
34253: PUSH
34254: LD_VAR 0 2
34258: ARRAY
34259: PUSH
34260: LD_VAR 0 6
34264: PUSH
34265: LD_INT 1
34267: ARRAY
34268: LESS
34269: IFFALSE 34289
// tmp := mc_crates_collector [ i ] else
34271: LD_ADDR_VAR 0 5
34275: PUSH
34276: LD_EXP 91
34280: PUSH
34281: LD_VAR 0 2
34285: ARRAY
34286: ST_TO_ADDR
34287: GO 34303
// tmp := target [ 1 ] ;
34289: LD_ADDR_VAR 0 5
34293: PUSH
34294: LD_VAR 0 6
34298: PUSH
34299: LD_INT 1
34301: ARRAY
34302: ST_TO_ADDR
// k := 0 ;
34303: LD_ADDR_VAR 0 4
34307: PUSH
34308: LD_INT 0
34310: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34311: LD_ADDR_VAR 0 3
34315: PUSH
34316: LD_EXP 91
34320: PUSH
34321: LD_VAR 0 2
34325: ARRAY
34326: PUSH
34327: FOR_IN
34328: IFFALSE 34488
// begin k := k + 1 ;
34330: LD_ADDR_VAR 0 4
34334: PUSH
34335: LD_VAR 0 4
34339: PUSH
34340: LD_INT 1
34342: PLUS
34343: ST_TO_ADDR
// if k > tmp then
34344: LD_VAR 0 4
34348: PUSH
34349: LD_VAR 0 5
34353: GREATER
34354: IFFALSE 34358
// break ;
34356: GO 34488
// if not GetClass ( j ) in [ 2 , 16 ] then
34358: LD_VAR 0 3
34362: PPUSH
34363: CALL_OW 257
34367: PUSH
34368: LD_INT 2
34370: PUSH
34371: LD_INT 16
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: IN
34378: NOT
34379: IFFALSE 34432
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34381: LD_ADDR_EXP 91
34385: PUSH
34386: LD_EXP 91
34390: PPUSH
34391: LD_VAR 0 2
34395: PPUSH
34396: LD_EXP 91
34400: PUSH
34401: LD_VAR 0 2
34405: ARRAY
34406: PUSH
34407: LD_VAR 0 3
34411: DIFF
34412: PPUSH
34413: CALL_OW 1
34417: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34418: LD_VAR 0 3
34422: PPUSH
34423: LD_INT 0
34425: PPUSH
34426: CALL_OW 109
// continue ;
34430: GO 34327
// end ; if IsInUnit ( j ) then
34432: LD_VAR 0 3
34436: PPUSH
34437: CALL_OW 310
34441: IFFALSE 34452
// ComExitBuilding ( j ) ;
34443: LD_VAR 0 3
34447: PPUSH
34448: CALL_OW 122
// wait ( 3 ) ;
34452: LD_INT 3
34454: PPUSH
34455: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34459: LD_VAR 0 3
34463: PPUSH
34464: LD_VAR 0 6
34468: PUSH
34469: LD_INT 2
34471: ARRAY
34472: PPUSH
34473: LD_VAR 0 6
34477: PUSH
34478: LD_INT 3
34480: ARRAY
34481: PPUSH
34482: CALL_OW 117
// end ;
34486: GO 34327
34488: POP
34489: POP
// end ; end else
34490: GO 35071
// begin for j in cargo do
34492: LD_ADDR_VAR 0 3
34496: PUSH
34497: LD_VAR 0 7
34501: PUSH
34502: FOR_IN
34503: IFFALSE 35069
// begin if GetTag ( j ) <> 0 then
34505: LD_VAR 0 3
34509: PPUSH
34510: CALL_OW 110
34514: PUSH
34515: LD_INT 0
34517: NONEQUAL
34518: IFFALSE 34522
// continue ;
34520: GO 34502
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34522: LD_VAR 0 3
34526: PPUSH
34527: CALL_OW 256
34531: PUSH
34532: LD_INT 1000
34534: LESS
34535: PUSH
34536: LD_VAR 0 3
34540: PPUSH
34541: LD_EXP 98
34545: PUSH
34546: LD_VAR 0 2
34550: ARRAY
34551: PPUSH
34552: CALL_OW 308
34556: NOT
34557: AND
34558: IFFALSE 34580
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34560: LD_VAR 0 3
34564: PPUSH
34565: LD_EXP 98
34569: PUSH
34570: LD_VAR 0 2
34574: ARRAY
34575: PPUSH
34576: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34580: LD_VAR 0 3
34584: PPUSH
34585: CALL_OW 256
34589: PUSH
34590: LD_INT 1000
34592: LESS
34593: PUSH
34594: LD_VAR 0 3
34598: PPUSH
34599: LD_EXP 98
34603: PUSH
34604: LD_VAR 0 2
34608: ARRAY
34609: PPUSH
34610: CALL_OW 308
34614: AND
34615: IFFALSE 34619
// continue ;
34617: GO 34502
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34619: LD_VAR 0 3
34623: PPUSH
34624: CALL_OW 262
34628: PUSH
34629: LD_INT 2
34631: EQUAL
34632: PUSH
34633: LD_VAR 0 3
34637: PPUSH
34638: CALL_OW 261
34642: PUSH
34643: LD_INT 15
34645: LESS
34646: AND
34647: IFFALSE 34651
// continue ;
34649: GO 34502
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34651: LD_VAR 0 3
34655: PPUSH
34656: CALL_OW 262
34660: PUSH
34661: LD_INT 1
34663: EQUAL
34664: PUSH
34665: LD_VAR 0 3
34669: PPUSH
34670: CALL_OW 261
34674: PUSH
34675: LD_INT 10
34677: LESS
34678: AND
34679: IFFALSE 35008
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34681: LD_ADDR_VAR 0 8
34685: PUSH
34686: LD_EXP 74
34690: PUSH
34691: LD_VAR 0 2
34695: ARRAY
34696: PPUSH
34697: LD_INT 2
34699: PUSH
34700: LD_INT 30
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: LD_INT 30
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: LIST
34724: PPUSH
34725: CALL_OW 72
34729: ST_TO_ADDR
// if not depot then
34730: LD_VAR 0 8
34734: NOT
34735: IFFALSE 34739
// continue ;
34737: GO 34502
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34739: LD_VAR 0 3
34743: PPUSH
34744: LD_VAR 0 8
34748: PPUSH
34749: LD_VAR 0 3
34753: PPUSH
34754: CALL_OW 74
34758: PPUSH
34759: CALL_OW 296
34763: PUSH
34764: LD_INT 6
34766: LESS
34767: IFFALSE 34783
// SetFuel ( j , 100 ) else
34769: LD_VAR 0 3
34773: PPUSH
34774: LD_INT 100
34776: PPUSH
34777: CALL_OW 240
34781: GO 35008
// if GetFuel ( j ) = 0 then
34783: LD_VAR 0 3
34787: PPUSH
34788: CALL_OW 261
34792: PUSH
34793: LD_INT 0
34795: EQUAL
34796: IFFALSE 35008
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34798: LD_ADDR_EXP 93
34802: PUSH
34803: LD_EXP 93
34807: PPUSH
34808: LD_VAR 0 2
34812: PPUSH
34813: LD_EXP 93
34817: PUSH
34818: LD_VAR 0 2
34822: ARRAY
34823: PUSH
34824: LD_VAR 0 3
34828: DIFF
34829: PPUSH
34830: CALL_OW 1
34834: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34835: LD_VAR 0 3
34839: PPUSH
34840: CALL_OW 263
34844: PUSH
34845: LD_INT 1
34847: EQUAL
34848: IFFALSE 34864
// ComExitVehicle ( IsInUnit ( j ) ) ;
34850: LD_VAR 0 3
34854: PPUSH
34855: CALL_OW 310
34859: PPUSH
34860: CALL_OW 121
// if GetControl ( j ) = control_remote then
34864: LD_VAR 0 3
34868: PPUSH
34869: CALL_OW 263
34873: PUSH
34874: LD_INT 2
34876: EQUAL
34877: IFFALSE 34888
// ComUnlink ( j ) ;
34879: LD_VAR 0 3
34883: PPUSH
34884: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
34888: LD_ADDR_VAR 0 9
34892: PUSH
34893: LD_VAR 0 2
34897: PPUSH
34898: LD_INT 3
34900: PPUSH
34901: CALL 44361 0 2
34905: ST_TO_ADDR
// if fac then
34906: LD_VAR 0 9
34910: IFFALSE 35006
// begin for k in fac do
34912: LD_ADDR_VAR 0 4
34916: PUSH
34917: LD_VAR 0 9
34921: PUSH
34922: FOR_IN
34923: IFFALSE 35004
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
34925: LD_ADDR_VAR 0 10
34929: PUSH
34930: LD_VAR 0 9
34934: PPUSH
34935: LD_VAR 0 3
34939: PPUSH
34940: CALL_OW 265
34944: PPUSH
34945: LD_VAR 0 3
34949: PPUSH
34950: CALL_OW 262
34954: PPUSH
34955: LD_VAR 0 3
34959: PPUSH
34960: CALL_OW 263
34964: PPUSH
34965: LD_VAR 0 3
34969: PPUSH
34970: CALL_OW 264
34974: PPUSH
34975: CALL 54930 0 5
34979: ST_TO_ADDR
// if components then
34980: LD_VAR 0 10
34984: IFFALSE 35002
// begin MC_InsertProduceList ( i , components ) ;
34986: LD_VAR 0 2
34990: PPUSH
34991: LD_VAR 0 10
34995: PPUSH
34996: CALL 43906 0 2
// break ;
35000: GO 35004
// end ; end ;
35002: GO 34922
35004: POP
35005: POP
// end ; continue ;
35006: GO 34502
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35008: LD_VAR 0 3
35012: PPUSH
35013: LD_INT 1
35015: PPUSH
35016: CALL_OW 289
35020: PUSH
35021: LD_INT 100
35023: LESS
35024: PUSH
35025: LD_VAR 0 3
35029: PPUSH
35030: CALL_OW 314
35034: NOT
35035: AND
35036: IFFALSE 35065
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35038: LD_VAR 0 3
35042: PPUSH
35043: LD_VAR 0 6
35047: PUSH
35048: LD_INT 2
35050: ARRAY
35051: PPUSH
35052: LD_VAR 0 6
35056: PUSH
35057: LD_INT 3
35059: ARRAY
35060: PPUSH
35061: CALL_OW 117
// break ;
35065: GO 35069
// end ;
35067: GO 34502
35069: POP
35070: POP
// end ; end ;
35071: GO 33340
35073: POP
35074: POP
// end ;
35075: LD_VAR 0 1
35079: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35080: LD_INT 0
35082: PPUSH
35083: PPUSH
35084: PPUSH
35085: PPUSH
// if not mc_bases then
35086: LD_EXP 74
35090: NOT
35091: IFFALSE 35095
// exit ;
35093: GO 35256
// for i = 1 to mc_bases do
35095: LD_ADDR_VAR 0 2
35099: PUSH
35100: DOUBLE
35101: LD_INT 1
35103: DEC
35104: ST_TO_ADDR
35105: LD_EXP 74
35109: PUSH
35110: FOR_TO
35111: IFFALSE 35254
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35113: LD_ADDR_VAR 0 4
35117: PUSH
35118: LD_EXP 93
35122: PUSH
35123: LD_VAR 0 2
35127: ARRAY
35128: PUSH
35129: LD_EXP 96
35133: PUSH
35134: LD_VAR 0 2
35138: ARRAY
35139: UNION
35140: PPUSH
35141: LD_INT 33
35143: PUSH
35144: LD_INT 2
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PPUSH
35151: CALL_OW 72
35155: ST_TO_ADDR
// if tmp then
35156: LD_VAR 0 4
35160: IFFALSE 35252
// for j in tmp do
35162: LD_ADDR_VAR 0 3
35166: PUSH
35167: LD_VAR 0 4
35171: PUSH
35172: FOR_IN
35173: IFFALSE 35250
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35175: LD_VAR 0 3
35179: PPUSH
35180: CALL_OW 312
35184: NOT
35185: PUSH
35186: LD_VAR 0 3
35190: PPUSH
35191: CALL_OW 256
35195: PUSH
35196: LD_INT 250
35198: GREATEREQUAL
35199: AND
35200: IFFALSE 35213
// Connect ( j ) else
35202: LD_VAR 0 3
35206: PPUSH
35207: CALL 60331 0 1
35211: GO 35248
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35213: LD_VAR 0 3
35217: PPUSH
35218: CALL_OW 256
35222: PUSH
35223: LD_INT 250
35225: LESS
35226: PUSH
35227: LD_VAR 0 3
35231: PPUSH
35232: CALL_OW 312
35236: AND
35237: IFFALSE 35248
// ComUnlink ( j ) ;
35239: LD_VAR 0 3
35243: PPUSH
35244: CALL_OW 136
35248: GO 35172
35250: POP
35251: POP
// end ;
35252: GO 35110
35254: POP
35255: POP
// end ;
35256: LD_VAR 0 1
35260: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35261: LD_INT 0
35263: PPUSH
35264: PPUSH
35265: PPUSH
35266: PPUSH
35267: PPUSH
// if not mc_bases then
35268: LD_EXP 74
35272: NOT
35273: IFFALSE 35277
// exit ;
35275: GO 35722
// for i = 1 to mc_bases do
35277: LD_ADDR_VAR 0 2
35281: PUSH
35282: DOUBLE
35283: LD_INT 1
35285: DEC
35286: ST_TO_ADDR
35287: LD_EXP 74
35291: PUSH
35292: FOR_TO
35293: IFFALSE 35720
// begin if not mc_produce [ i ] then
35295: LD_EXP 95
35299: PUSH
35300: LD_VAR 0 2
35304: ARRAY
35305: NOT
35306: IFFALSE 35310
// continue ;
35308: GO 35292
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35310: LD_ADDR_VAR 0 5
35314: PUSH
35315: LD_EXP 74
35319: PUSH
35320: LD_VAR 0 2
35324: ARRAY
35325: PPUSH
35326: LD_INT 30
35328: PUSH
35329: LD_INT 3
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PPUSH
35336: CALL_OW 72
35340: ST_TO_ADDR
// if not fac then
35341: LD_VAR 0 5
35345: NOT
35346: IFFALSE 35350
// continue ;
35348: GO 35292
// for j in fac do
35350: LD_ADDR_VAR 0 3
35354: PUSH
35355: LD_VAR 0 5
35359: PUSH
35360: FOR_IN
35361: IFFALSE 35716
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35363: LD_VAR 0 3
35367: PPUSH
35368: CALL_OW 461
35372: PUSH
35373: LD_INT 2
35375: NONEQUAL
35376: PUSH
35377: LD_VAR 0 3
35381: PPUSH
35382: LD_INT 15
35384: PPUSH
35385: CALL 59991 0 2
35389: PUSH
35390: LD_INT 4
35392: ARRAY
35393: OR
35394: IFFALSE 35398
// continue ;
35396: GO 35360
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35398: LD_VAR 0 3
35402: PPUSH
35403: LD_EXP 95
35407: PUSH
35408: LD_VAR 0 2
35412: ARRAY
35413: PUSH
35414: LD_INT 1
35416: ARRAY
35417: PUSH
35418: LD_INT 1
35420: ARRAY
35421: PPUSH
35422: LD_EXP 95
35426: PUSH
35427: LD_VAR 0 2
35431: ARRAY
35432: PUSH
35433: LD_INT 1
35435: ARRAY
35436: PUSH
35437: LD_INT 2
35439: ARRAY
35440: PPUSH
35441: LD_EXP 95
35445: PUSH
35446: LD_VAR 0 2
35450: ARRAY
35451: PUSH
35452: LD_INT 1
35454: ARRAY
35455: PUSH
35456: LD_INT 3
35458: ARRAY
35459: PPUSH
35460: LD_EXP 95
35464: PUSH
35465: LD_VAR 0 2
35469: ARRAY
35470: PUSH
35471: LD_INT 1
35473: ARRAY
35474: PUSH
35475: LD_INT 4
35477: ARRAY
35478: PPUSH
35479: CALL_OW 448
35483: PUSH
35484: LD_VAR 0 3
35488: PPUSH
35489: LD_EXP 95
35493: PUSH
35494: LD_VAR 0 2
35498: ARRAY
35499: PUSH
35500: LD_INT 1
35502: ARRAY
35503: PUSH
35504: LD_INT 1
35506: ARRAY
35507: PUSH
35508: LD_EXP 95
35512: PUSH
35513: LD_VAR 0 2
35517: ARRAY
35518: PUSH
35519: LD_INT 1
35521: ARRAY
35522: PUSH
35523: LD_INT 2
35525: ARRAY
35526: PUSH
35527: LD_EXP 95
35531: PUSH
35532: LD_VAR 0 2
35536: ARRAY
35537: PUSH
35538: LD_INT 1
35540: ARRAY
35541: PUSH
35542: LD_INT 3
35544: ARRAY
35545: PUSH
35546: LD_EXP 95
35550: PUSH
35551: LD_VAR 0 2
35555: ARRAY
35556: PUSH
35557: LD_INT 1
35559: ARRAY
35560: PUSH
35561: LD_INT 4
35563: ARRAY
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: PPUSH
35571: CALL 63662 0 2
35575: AND
35576: IFFALSE 35714
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35578: LD_VAR 0 3
35582: PPUSH
35583: LD_EXP 95
35587: PUSH
35588: LD_VAR 0 2
35592: ARRAY
35593: PUSH
35594: LD_INT 1
35596: ARRAY
35597: PUSH
35598: LD_INT 1
35600: ARRAY
35601: PPUSH
35602: LD_EXP 95
35606: PUSH
35607: LD_VAR 0 2
35611: ARRAY
35612: PUSH
35613: LD_INT 1
35615: ARRAY
35616: PUSH
35617: LD_INT 2
35619: ARRAY
35620: PPUSH
35621: LD_EXP 95
35625: PUSH
35626: LD_VAR 0 2
35630: ARRAY
35631: PUSH
35632: LD_INT 1
35634: ARRAY
35635: PUSH
35636: LD_INT 3
35638: ARRAY
35639: PPUSH
35640: LD_EXP 95
35644: PUSH
35645: LD_VAR 0 2
35649: ARRAY
35650: PUSH
35651: LD_INT 1
35653: ARRAY
35654: PUSH
35655: LD_INT 4
35657: ARRAY
35658: PPUSH
35659: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35663: LD_ADDR_VAR 0 4
35667: PUSH
35668: LD_EXP 95
35672: PUSH
35673: LD_VAR 0 2
35677: ARRAY
35678: PPUSH
35679: LD_INT 1
35681: PPUSH
35682: CALL_OW 3
35686: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35687: LD_ADDR_EXP 95
35691: PUSH
35692: LD_EXP 95
35696: PPUSH
35697: LD_VAR 0 2
35701: PPUSH
35702: LD_VAR 0 4
35706: PPUSH
35707: CALL_OW 1
35711: ST_TO_ADDR
// break ;
35712: GO 35716
// end ; end ;
35714: GO 35360
35716: POP
35717: POP
// end ;
35718: GO 35292
35720: POP
35721: POP
// end ;
35722: LD_VAR 0 1
35726: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35727: LD_INT 0
35729: PPUSH
35730: PPUSH
35731: PPUSH
// if not mc_bases then
35732: LD_EXP 74
35736: NOT
35737: IFFALSE 35741
// exit ;
35739: GO 35830
// for i = 1 to mc_bases do
35741: LD_ADDR_VAR 0 2
35745: PUSH
35746: DOUBLE
35747: LD_INT 1
35749: DEC
35750: ST_TO_ADDR
35751: LD_EXP 74
35755: PUSH
35756: FOR_TO
35757: IFFALSE 35828
// begin if mc_attack [ i ] then
35759: LD_EXP 94
35763: PUSH
35764: LD_VAR 0 2
35768: ARRAY
35769: IFFALSE 35826
// begin tmp := mc_attack [ i ] [ 1 ] ;
35771: LD_ADDR_VAR 0 3
35775: PUSH
35776: LD_EXP 94
35780: PUSH
35781: LD_VAR 0 2
35785: ARRAY
35786: PUSH
35787: LD_INT 1
35789: ARRAY
35790: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35791: LD_ADDR_EXP 94
35795: PUSH
35796: LD_EXP 94
35800: PPUSH
35801: LD_VAR 0 2
35805: PPUSH
35806: EMPTY
35807: PPUSH
35808: CALL_OW 1
35812: ST_TO_ADDR
// Attack ( tmp ) ;
35813: LD_VAR 0 3
35817: PPUSH
35818: CALL 85875 0 1
// exit ;
35822: POP
35823: POP
35824: GO 35830
// end ; end ;
35826: GO 35756
35828: POP
35829: POP
// end ;
35830: LD_VAR 0 1
35834: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35835: LD_INT 0
35837: PPUSH
35838: PPUSH
35839: PPUSH
35840: PPUSH
35841: PPUSH
35842: PPUSH
35843: PPUSH
// if not mc_bases then
35844: LD_EXP 74
35848: NOT
35849: IFFALSE 35853
// exit ;
35851: GO 36435
// for i = 1 to mc_bases do
35853: LD_ADDR_VAR 0 2
35857: PUSH
35858: DOUBLE
35859: LD_INT 1
35861: DEC
35862: ST_TO_ADDR
35863: LD_EXP 74
35867: PUSH
35868: FOR_TO
35869: IFFALSE 36433
// begin if not mc_bases [ i ] then
35871: LD_EXP 74
35875: PUSH
35876: LD_VAR 0 2
35880: ARRAY
35881: NOT
35882: IFFALSE 35886
// continue ;
35884: GO 35868
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
35886: LD_ADDR_VAR 0 7
35890: PUSH
35891: LD_EXP 74
35895: PUSH
35896: LD_VAR 0 2
35900: ARRAY
35901: PUSH
35902: LD_INT 1
35904: ARRAY
35905: PPUSH
35906: CALL 54234 0 1
35910: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
35911: LD_ADDR_EXP 97
35915: PUSH
35916: LD_EXP 97
35920: PPUSH
35921: LD_VAR 0 2
35925: PPUSH
35926: LD_EXP 74
35930: PUSH
35931: LD_VAR 0 2
35935: ARRAY
35936: PUSH
35937: LD_INT 1
35939: ARRAY
35940: PPUSH
35941: CALL_OW 255
35945: PPUSH
35946: LD_EXP 99
35950: PUSH
35951: LD_VAR 0 2
35955: ARRAY
35956: PPUSH
35957: CALL 51877 0 2
35961: PPUSH
35962: CALL_OW 1
35966: ST_TO_ADDR
// if not mc_scan [ i ] then
35967: LD_EXP 97
35971: PUSH
35972: LD_VAR 0 2
35976: ARRAY
35977: NOT
35978: IFFALSE 36133
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35980: LD_ADDR_VAR 0 4
35984: PUSH
35985: LD_EXP 74
35989: PUSH
35990: LD_VAR 0 2
35994: ARRAY
35995: PPUSH
35996: LD_INT 2
35998: PUSH
35999: LD_INT 25
36001: PUSH
36002: LD_INT 5
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 25
36011: PUSH
36012: LD_INT 8
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 25
36021: PUSH
36022: LD_INT 9
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: LIST
36033: LIST
36034: PPUSH
36035: CALL_OW 72
36039: ST_TO_ADDR
// if not tmp then
36040: LD_VAR 0 4
36044: NOT
36045: IFFALSE 36049
// continue ;
36047: GO 35868
// for j in tmp do
36049: LD_ADDR_VAR 0 3
36053: PUSH
36054: LD_VAR 0 4
36058: PUSH
36059: FOR_IN
36060: IFFALSE 36131
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36062: LD_VAR 0 3
36066: PPUSH
36067: CALL_OW 310
36071: PPUSH
36072: CALL_OW 266
36076: PUSH
36077: LD_INT 5
36079: EQUAL
36080: PUSH
36081: LD_VAR 0 3
36085: PPUSH
36086: CALL_OW 257
36090: PUSH
36091: LD_INT 1
36093: EQUAL
36094: AND
36095: PUSH
36096: LD_VAR 0 3
36100: PPUSH
36101: CALL_OW 459
36105: NOT
36106: AND
36107: PUSH
36108: LD_VAR 0 7
36112: AND
36113: IFFALSE 36129
// ComChangeProfession ( j , class ) ;
36115: LD_VAR 0 3
36119: PPUSH
36120: LD_VAR 0 7
36124: PPUSH
36125: CALL_OW 123
36129: GO 36059
36131: POP
36132: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36133: LD_EXP 97
36137: PUSH
36138: LD_VAR 0 2
36142: ARRAY
36143: PUSH
36144: LD_EXP 96
36148: PUSH
36149: LD_VAR 0 2
36153: ARRAY
36154: NOT
36155: AND
36156: PUSH
36157: LD_EXP 74
36161: PUSH
36162: LD_VAR 0 2
36166: ARRAY
36167: PPUSH
36168: LD_INT 30
36170: PUSH
36171: LD_INT 32
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PPUSH
36178: CALL_OW 72
36182: NOT
36183: AND
36184: PUSH
36185: LD_EXP 74
36189: PUSH
36190: LD_VAR 0 2
36194: ARRAY
36195: PPUSH
36196: LD_INT 2
36198: PUSH
36199: LD_INT 30
36201: PUSH
36202: LD_INT 4
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: LD_INT 30
36211: PUSH
36212: LD_INT 5
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: LIST
36223: PPUSH
36224: CALL_OW 72
36228: NOT
36229: AND
36230: IFFALSE 36362
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36232: LD_ADDR_VAR 0 4
36236: PUSH
36237: LD_EXP 74
36241: PUSH
36242: LD_VAR 0 2
36246: ARRAY
36247: PPUSH
36248: LD_INT 2
36250: PUSH
36251: LD_INT 25
36253: PUSH
36254: LD_INT 1
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: PUSH
36261: LD_INT 25
36263: PUSH
36264: LD_INT 5
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PUSH
36271: LD_INT 25
36273: PUSH
36274: LD_INT 8
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 25
36283: PUSH
36284: LD_INT 9
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: LIST
36295: LIST
36296: LIST
36297: PPUSH
36298: CALL_OW 72
36302: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36303: LD_ADDR_VAR 0 4
36307: PUSH
36308: LD_VAR 0 4
36312: PUSH
36313: LD_VAR 0 4
36317: PPUSH
36318: LD_INT 18
36320: PPUSH
36321: CALL 90658 0 2
36325: DIFF
36326: ST_TO_ADDR
// if tmp then
36327: LD_VAR 0 4
36331: IFFALSE 36362
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36333: LD_VAR 0 2
36337: PPUSH
36338: LD_VAR 0 4
36342: PPUSH
36343: LD_EXP 99
36347: PUSH
36348: LD_VAR 0 2
36352: ARRAY
36353: PPUSH
36354: CALL 51912 0 3
// exit ;
36358: POP
36359: POP
36360: GO 36435
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36362: LD_EXP 97
36366: PUSH
36367: LD_VAR 0 2
36371: ARRAY
36372: PUSH
36373: LD_EXP 96
36377: PUSH
36378: LD_VAR 0 2
36382: ARRAY
36383: AND
36384: IFFALSE 36431
// begin tmp := mc_defender [ i ] ;
36386: LD_ADDR_VAR 0 4
36390: PUSH
36391: LD_EXP 96
36395: PUSH
36396: LD_VAR 0 2
36400: ARRAY
36401: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36402: LD_VAR 0 2
36406: PPUSH
36407: LD_VAR 0 4
36411: PPUSH
36412: LD_EXP 97
36416: PUSH
36417: LD_VAR 0 2
36421: ARRAY
36422: PPUSH
36423: CALL 52473 0 3
// exit ;
36427: POP
36428: POP
36429: GO 36435
// end ; end ;
36431: GO 35868
36433: POP
36434: POP
// end ;
36435: LD_VAR 0 1
36439: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36440: LD_INT 0
36442: PPUSH
36443: PPUSH
36444: PPUSH
36445: PPUSH
36446: PPUSH
36447: PPUSH
36448: PPUSH
36449: PPUSH
36450: PPUSH
36451: PPUSH
36452: PPUSH
// if not mc_bases then
36453: LD_EXP 74
36457: NOT
36458: IFFALSE 36462
// exit ;
36460: GO 37549
// for i = 1 to mc_bases do
36462: LD_ADDR_VAR 0 2
36466: PUSH
36467: DOUBLE
36468: LD_INT 1
36470: DEC
36471: ST_TO_ADDR
36472: LD_EXP 74
36476: PUSH
36477: FOR_TO
36478: IFFALSE 37547
// begin tmp := mc_lab [ i ] ;
36480: LD_ADDR_VAR 0 6
36484: PUSH
36485: LD_EXP 107
36489: PUSH
36490: LD_VAR 0 2
36494: ARRAY
36495: ST_TO_ADDR
// if not tmp then
36496: LD_VAR 0 6
36500: NOT
36501: IFFALSE 36505
// continue ;
36503: GO 36477
// idle_lab := 0 ;
36505: LD_ADDR_VAR 0 11
36509: PUSH
36510: LD_INT 0
36512: ST_TO_ADDR
// for j in tmp do
36513: LD_ADDR_VAR 0 3
36517: PUSH
36518: LD_VAR 0 6
36522: PUSH
36523: FOR_IN
36524: IFFALSE 37543
// begin researching := false ;
36526: LD_ADDR_VAR 0 10
36530: PUSH
36531: LD_INT 0
36533: ST_TO_ADDR
// side := GetSide ( j ) ;
36534: LD_ADDR_VAR 0 4
36538: PUSH
36539: LD_VAR 0 3
36543: PPUSH
36544: CALL_OW 255
36548: ST_TO_ADDR
// if not mc_tech [ side ] then
36549: LD_EXP 101
36553: PUSH
36554: LD_VAR 0 4
36558: ARRAY
36559: NOT
36560: IFFALSE 36564
// continue ;
36562: GO 36523
// if BuildingStatus ( j ) = bs_idle then
36564: LD_VAR 0 3
36568: PPUSH
36569: CALL_OW 461
36573: PUSH
36574: LD_INT 2
36576: EQUAL
36577: IFFALSE 36765
// begin if idle_lab and UnitsInside ( j ) < 6 then
36579: LD_VAR 0 11
36583: PUSH
36584: LD_VAR 0 3
36588: PPUSH
36589: CALL_OW 313
36593: PUSH
36594: LD_INT 6
36596: LESS
36597: AND
36598: IFFALSE 36669
// begin tmp2 := UnitsInside ( idle_lab ) ;
36600: LD_ADDR_VAR 0 9
36604: PUSH
36605: LD_VAR 0 11
36609: PPUSH
36610: CALL_OW 313
36614: ST_TO_ADDR
// if tmp2 then
36615: LD_VAR 0 9
36619: IFFALSE 36661
// for x in tmp2 do
36621: LD_ADDR_VAR 0 7
36625: PUSH
36626: LD_VAR 0 9
36630: PUSH
36631: FOR_IN
36632: IFFALSE 36659
// begin ComExitBuilding ( x ) ;
36634: LD_VAR 0 7
36638: PPUSH
36639: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36643: LD_VAR 0 7
36647: PPUSH
36648: LD_VAR 0 3
36652: PPUSH
36653: CALL_OW 180
// end ;
36657: GO 36631
36659: POP
36660: POP
// idle_lab := 0 ;
36661: LD_ADDR_VAR 0 11
36665: PUSH
36666: LD_INT 0
36668: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36669: LD_ADDR_VAR 0 5
36673: PUSH
36674: LD_EXP 101
36678: PUSH
36679: LD_VAR 0 4
36683: ARRAY
36684: PUSH
36685: FOR_IN
36686: IFFALSE 36746
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36688: LD_VAR 0 3
36692: PPUSH
36693: LD_VAR 0 5
36697: PPUSH
36698: CALL_OW 430
36702: PUSH
36703: LD_VAR 0 4
36707: PPUSH
36708: LD_VAR 0 5
36712: PPUSH
36713: CALL 50982 0 2
36717: AND
36718: IFFALSE 36744
// begin researching := true ;
36720: LD_ADDR_VAR 0 10
36724: PUSH
36725: LD_INT 1
36727: ST_TO_ADDR
// ComResearch ( j , t ) ;
36728: LD_VAR 0 3
36732: PPUSH
36733: LD_VAR 0 5
36737: PPUSH
36738: CALL_OW 124
// break ;
36742: GO 36746
// end ;
36744: GO 36685
36746: POP
36747: POP
// if not researching then
36748: LD_VAR 0 10
36752: NOT
36753: IFFALSE 36765
// idle_lab := j ;
36755: LD_ADDR_VAR 0 11
36759: PUSH
36760: LD_VAR 0 3
36764: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36765: LD_VAR 0 3
36769: PPUSH
36770: CALL_OW 461
36774: PUSH
36775: LD_INT 10
36777: EQUAL
36778: IFFALSE 37366
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36780: LD_EXP 103
36784: PUSH
36785: LD_VAR 0 2
36789: ARRAY
36790: NOT
36791: PUSH
36792: LD_EXP 104
36796: PUSH
36797: LD_VAR 0 2
36801: ARRAY
36802: NOT
36803: AND
36804: PUSH
36805: LD_EXP 101
36809: PUSH
36810: LD_VAR 0 4
36814: ARRAY
36815: PUSH
36816: LD_INT 1
36818: GREATER
36819: AND
36820: IFFALSE 36951
// begin ComCancel ( j ) ;
36822: LD_VAR 0 3
36826: PPUSH
36827: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36831: LD_ADDR_EXP 101
36835: PUSH
36836: LD_EXP 101
36840: PPUSH
36841: LD_VAR 0 4
36845: PPUSH
36846: LD_EXP 101
36850: PUSH
36851: LD_VAR 0 4
36855: ARRAY
36856: PPUSH
36857: LD_EXP 101
36861: PUSH
36862: LD_VAR 0 4
36866: ARRAY
36867: PUSH
36868: LD_INT 1
36870: MINUS
36871: PPUSH
36872: LD_EXP 101
36876: PUSH
36877: LD_VAR 0 4
36881: ARRAY
36882: PPUSH
36883: LD_INT 0
36885: PPUSH
36886: CALL 56816 0 4
36890: PPUSH
36891: CALL_OW 1
36895: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
36896: LD_ADDR_EXP 101
36900: PUSH
36901: LD_EXP 101
36905: PPUSH
36906: LD_VAR 0 4
36910: PPUSH
36911: LD_EXP 101
36915: PUSH
36916: LD_VAR 0 4
36920: ARRAY
36921: PPUSH
36922: LD_EXP 101
36926: PUSH
36927: LD_VAR 0 4
36931: ARRAY
36932: PPUSH
36933: LD_INT 1
36935: PPUSH
36936: LD_INT 0
36938: PPUSH
36939: CALL 56816 0 4
36943: PPUSH
36944: CALL_OW 1
36948: ST_TO_ADDR
// continue ;
36949: GO 36523
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
36951: LD_EXP 103
36955: PUSH
36956: LD_VAR 0 2
36960: ARRAY
36961: PUSH
36962: LD_EXP 104
36966: PUSH
36967: LD_VAR 0 2
36971: ARRAY
36972: NOT
36973: AND
36974: IFFALSE 37101
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
36976: LD_ADDR_EXP 104
36980: PUSH
36981: LD_EXP 104
36985: PPUSH
36986: LD_VAR 0 2
36990: PUSH
36991: LD_EXP 104
36995: PUSH
36996: LD_VAR 0 2
37000: ARRAY
37001: PUSH
37002: LD_INT 1
37004: PLUS
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PPUSH
37010: LD_EXP 103
37014: PUSH
37015: LD_VAR 0 2
37019: ARRAY
37020: PUSH
37021: LD_INT 1
37023: ARRAY
37024: PPUSH
37025: CALL 57398 0 3
37029: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37030: LD_EXP 103
37034: PUSH
37035: LD_VAR 0 2
37039: ARRAY
37040: PUSH
37041: LD_INT 1
37043: ARRAY
37044: PPUSH
37045: LD_INT 112
37047: PPUSH
37048: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37052: LD_ADDR_VAR 0 9
37056: PUSH
37057: LD_EXP 103
37061: PUSH
37062: LD_VAR 0 2
37066: ARRAY
37067: PPUSH
37068: LD_INT 1
37070: PPUSH
37071: CALL_OW 3
37075: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37076: LD_ADDR_EXP 103
37080: PUSH
37081: LD_EXP 103
37085: PPUSH
37086: LD_VAR 0 2
37090: PPUSH
37091: LD_VAR 0 9
37095: PPUSH
37096: CALL_OW 1
37100: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37101: LD_EXP 103
37105: PUSH
37106: LD_VAR 0 2
37110: ARRAY
37111: PUSH
37112: LD_EXP 104
37116: PUSH
37117: LD_VAR 0 2
37121: ARRAY
37122: AND
37123: PUSH
37124: LD_EXP 104
37128: PUSH
37129: LD_VAR 0 2
37133: ARRAY
37134: PUSH
37135: LD_INT 1
37137: ARRAY
37138: PPUSH
37139: CALL_OW 310
37143: NOT
37144: AND
37145: PUSH
37146: LD_VAR 0 3
37150: PPUSH
37151: CALL_OW 313
37155: PUSH
37156: LD_INT 6
37158: EQUAL
37159: AND
37160: IFFALSE 37216
// begin tmp2 := UnitsInside ( j ) ;
37162: LD_ADDR_VAR 0 9
37166: PUSH
37167: LD_VAR 0 3
37171: PPUSH
37172: CALL_OW 313
37176: ST_TO_ADDR
// if tmp2 = 6 then
37177: LD_VAR 0 9
37181: PUSH
37182: LD_INT 6
37184: EQUAL
37185: IFFALSE 37216
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37187: LD_VAR 0 9
37191: PUSH
37192: LD_INT 1
37194: ARRAY
37195: PPUSH
37196: LD_INT 112
37198: PPUSH
37199: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37203: LD_VAR 0 9
37207: PUSH
37208: LD_INT 1
37210: ARRAY
37211: PPUSH
37212: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37216: LD_EXP 104
37220: PUSH
37221: LD_VAR 0 2
37225: ARRAY
37226: PUSH
37227: LD_EXP 104
37231: PUSH
37232: LD_VAR 0 2
37236: ARRAY
37237: PUSH
37238: LD_INT 1
37240: ARRAY
37241: PPUSH
37242: CALL_OW 314
37246: NOT
37247: AND
37248: PUSH
37249: LD_EXP 104
37253: PUSH
37254: LD_VAR 0 2
37258: ARRAY
37259: PUSH
37260: LD_INT 1
37262: ARRAY
37263: PPUSH
37264: CALL_OW 310
37268: NOT
37269: AND
37270: IFFALSE 37296
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37272: LD_EXP 104
37276: PUSH
37277: LD_VAR 0 2
37281: ARRAY
37282: PUSH
37283: LD_INT 1
37285: ARRAY
37286: PPUSH
37287: LD_VAR 0 3
37291: PPUSH
37292: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37296: LD_EXP 104
37300: PUSH
37301: LD_VAR 0 2
37305: ARRAY
37306: PUSH
37307: LD_INT 1
37309: ARRAY
37310: PPUSH
37311: CALL_OW 310
37315: PUSH
37316: LD_EXP 104
37320: PUSH
37321: LD_VAR 0 2
37325: ARRAY
37326: PUSH
37327: LD_INT 1
37329: ARRAY
37330: PPUSH
37331: CALL_OW 310
37335: PPUSH
37336: CALL_OW 461
37340: PUSH
37341: LD_INT 3
37343: NONEQUAL
37344: AND
37345: IFFALSE 37366
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37347: LD_EXP 104
37351: PUSH
37352: LD_VAR 0 2
37356: ARRAY
37357: PUSH
37358: LD_INT 1
37360: ARRAY
37361: PPUSH
37362: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37366: LD_VAR 0 3
37370: PPUSH
37371: CALL_OW 461
37375: PUSH
37376: LD_INT 6
37378: EQUAL
37379: PUSH
37380: LD_VAR 0 6
37384: PUSH
37385: LD_INT 1
37387: GREATER
37388: AND
37389: IFFALSE 37541
// begin sci := [ ] ;
37391: LD_ADDR_VAR 0 8
37395: PUSH
37396: EMPTY
37397: ST_TO_ADDR
// for x in ( tmp diff j ) do
37398: LD_ADDR_VAR 0 7
37402: PUSH
37403: LD_VAR 0 6
37407: PUSH
37408: LD_VAR 0 3
37412: DIFF
37413: PUSH
37414: FOR_IN
37415: IFFALSE 37467
// begin if sci = 6 then
37417: LD_VAR 0 8
37421: PUSH
37422: LD_INT 6
37424: EQUAL
37425: IFFALSE 37429
// break ;
37427: GO 37467
// if BuildingStatus ( x ) = bs_idle then
37429: LD_VAR 0 7
37433: PPUSH
37434: CALL_OW 461
37438: PUSH
37439: LD_INT 2
37441: EQUAL
37442: IFFALSE 37465
// sci := sci ^ UnitsInside ( x ) ;
37444: LD_ADDR_VAR 0 8
37448: PUSH
37449: LD_VAR 0 8
37453: PUSH
37454: LD_VAR 0 7
37458: PPUSH
37459: CALL_OW 313
37463: ADD
37464: ST_TO_ADDR
// end ;
37465: GO 37414
37467: POP
37468: POP
// if not sci then
37469: LD_VAR 0 8
37473: NOT
37474: IFFALSE 37478
// continue ;
37476: GO 36523
// for x in sci do
37478: LD_ADDR_VAR 0 7
37482: PUSH
37483: LD_VAR 0 8
37487: PUSH
37488: FOR_IN
37489: IFFALSE 37539
// if IsInUnit ( x ) and not HasTask ( x ) then
37491: LD_VAR 0 7
37495: PPUSH
37496: CALL_OW 310
37500: PUSH
37501: LD_VAR 0 7
37505: PPUSH
37506: CALL_OW 314
37510: NOT
37511: AND
37512: IFFALSE 37537
// begin ComExitBuilding ( x ) ;
37514: LD_VAR 0 7
37518: PPUSH
37519: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37523: LD_VAR 0 7
37527: PPUSH
37528: LD_VAR 0 3
37532: PPUSH
37533: CALL_OW 180
// end ;
37537: GO 37488
37539: POP
37540: POP
// end ; end ;
37541: GO 36523
37543: POP
37544: POP
// end ;
37545: GO 36477
37547: POP
37548: POP
// end ;
37549: LD_VAR 0 1
37553: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37554: LD_INT 0
37556: PPUSH
37557: PPUSH
// if not mc_bases then
37558: LD_EXP 74
37562: NOT
37563: IFFALSE 37567
// exit ;
37565: GO 37648
// for i = 1 to mc_bases do
37567: LD_ADDR_VAR 0 2
37571: PUSH
37572: DOUBLE
37573: LD_INT 1
37575: DEC
37576: ST_TO_ADDR
37577: LD_EXP 74
37581: PUSH
37582: FOR_TO
37583: IFFALSE 37646
// if mc_mines [ i ] and mc_miners [ i ] then
37585: LD_EXP 87
37589: PUSH
37590: LD_VAR 0 2
37594: ARRAY
37595: PUSH
37596: LD_EXP 88
37600: PUSH
37601: LD_VAR 0 2
37605: ARRAY
37606: AND
37607: IFFALSE 37644
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37609: LD_EXP 88
37613: PUSH
37614: LD_VAR 0 2
37618: ARRAY
37619: PUSH
37620: LD_INT 1
37622: ARRAY
37623: PPUSH
37624: CALL_OW 255
37628: PPUSH
37629: LD_EXP 87
37633: PUSH
37634: LD_VAR 0 2
37638: ARRAY
37639: PPUSH
37640: CALL 54387 0 2
37644: GO 37582
37646: POP
37647: POP
// end ;
37648: LD_VAR 0 1
37652: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37653: LD_INT 0
37655: PPUSH
37656: PPUSH
37657: PPUSH
37658: PPUSH
37659: PPUSH
37660: PPUSH
37661: PPUSH
37662: PPUSH
// if not mc_bases or not mc_parking then
37663: LD_EXP 74
37667: NOT
37668: PUSH
37669: LD_EXP 98
37673: NOT
37674: OR
37675: IFFALSE 37679
// exit ;
37677: GO 38378
// for i = 1 to mc_bases do
37679: LD_ADDR_VAR 0 2
37683: PUSH
37684: DOUBLE
37685: LD_INT 1
37687: DEC
37688: ST_TO_ADDR
37689: LD_EXP 74
37693: PUSH
37694: FOR_TO
37695: IFFALSE 38376
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37697: LD_EXP 74
37701: PUSH
37702: LD_VAR 0 2
37706: ARRAY
37707: NOT
37708: PUSH
37709: LD_EXP 98
37713: PUSH
37714: LD_VAR 0 2
37718: ARRAY
37719: NOT
37720: OR
37721: IFFALSE 37725
// continue ;
37723: GO 37694
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37725: LD_ADDR_VAR 0 5
37729: PUSH
37730: LD_EXP 74
37734: PUSH
37735: LD_VAR 0 2
37739: ARRAY
37740: PUSH
37741: LD_INT 1
37743: ARRAY
37744: PPUSH
37745: CALL_OW 255
37749: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37750: LD_ADDR_VAR 0 6
37754: PUSH
37755: LD_EXP 74
37759: PUSH
37760: LD_VAR 0 2
37764: ARRAY
37765: PPUSH
37766: LD_INT 30
37768: PUSH
37769: LD_INT 3
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PPUSH
37776: CALL_OW 72
37780: ST_TO_ADDR
// if not fac then
37781: LD_VAR 0 6
37785: NOT
37786: IFFALSE 37837
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37788: LD_ADDR_VAR 0 6
37792: PUSH
37793: LD_EXP 74
37797: PUSH
37798: LD_VAR 0 2
37802: ARRAY
37803: PPUSH
37804: LD_INT 2
37806: PUSH
37807: LD_INT 30
37809: PUSH
37810: LD_INT 0
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 30
37819: PUSH
37820: LD_INT 1
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: LIST
37831: PPUSH
37832: CALL_OW 72
37836: ST_TO_ADDR
// if not fac then
37837: LD_VAR 0 6
37841: NOT
37842: IFFALSE 37846
// continue ;
37844: GO 37694
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37846: LD_ADDR_VAR 0 7
37850: PUSH
37851: LD_EXP 98
37855: PUSH
37856: LD_VAR 0 2
37860: ARRAY
37861: PPUSH
37862: LD_INT 22
37864: PUSH
37865: LD_VAR 0 5
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 21
37876: PUSH
37877: LD_INT 2
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 3
37886: PUSH
37887: LD_INT 24
37889: PUSH
37890: LD_INT 1000
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: LIST
37905: PPUSH
37906: CALL_OW 70
37910: ST_TO_ADDR
// for j in fac do
37911: LD_ADDR_VAR 0 3
37915: PUSH
37916: LD_VAR 0 6
37920: PUSH
37921: FOR_IN
37922: IFFALSE 38003
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37924: LD_ADDR_VAR 0 7
37928: PUSH
37929: LD_VAR 0 7
37933: PUSH
37934: LD_INT 22
37936: PUSH
37937: LD_VAR 0 5
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 91
37948: PUSH
37949: LD_VAR 0 3
37953: PUSH
37954: LD_INT 15
37956: PUSH
37957: EMPTY
37958: LIST
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 21
37964: PUSH
37965: LD_INT 2
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 3
37974: PUSH
37975: LD_INT 24
37977: PUSH
37978: LD_INT 1000
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: PPUSH
37995: CALL_OW 69
37999: UNION
38000: ST_TO_ADDR
38001: GO 37921
38003: POP
38004: POP
// if not vehs then
38005: LD_VAR 0 7
38009: NOT
38010: IFFALSE 38036
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38012: LD_ADDR_EXP 86
38016: PUSH
38017: LD_EXP 86
38021: PPUSH
38022: LD_VAR 0 2
38026: PPUSH
38027: EMPTY
38028: PPUSH
38029: CALL_OW 1
38033: ST_TO_ADDR
// continue ;
38034: GO 37694
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38036: LD_ADDR_VAR 0 8
38040: PUSH
38041: LD_EXP 74
38045: PUSH
38046: LD_VAR 0 2
38050: ARRAY
38051: PPUSH
38052: LD_INT 30
38054: PUSH
38055: LD_INT 3
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PPUSH
38062: CALL_OW 72
38066: ST_TO_ADDR
// if tmp then
38067: LD_VAR 0 8
38071: IFFALSE 38174
// begin for j in tmp do
38073: LD_ADDR_VAR 0 3
38077: PUSH
38078: LD_VAR 0 8
38082: PUSH
38083: FOR_IN
38084: IFFALSE 38172
// for k in UnitsInside ( j ) do
38086: LD_ADDR_VAR 0 4
38090: PUSH
38091: LD_VAR 0 3
38095: PPUSH
38096: CALL_OW 313
38100: PUSH
38101: FOR_IN
38102: IFFALSE 38168
// if k then
38104: LD_VAR 0 4
38108: IFFALSE 38166
// if not k in mc_repair_vehicle [ i ] then
38110: LD_VAR 0 4
38114: PUSH
38115: LD_EXP 86
38119: PUSH
38120: LD_VAR 0 2
38124: ARRAY
38125: IN
38126: NOT
38127: IFFALSE 38166
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38129: LD_ADDR_EXP 86
38133: PUSH
38134: LD_EXP 86
38138: PPUSH
38139: LD_VAR 0 2
38143: PPUSH
38144: LD_EXP 86
38148: PUSH
38149: LD_VAR 0 2
38153: ARRAY
38154: PUSH
38155: LD_VAR 0 4
38159: UNION
38160: PPUSH
38161: CALL_OW 1
38165: ST_TO_ADDR
38166: GO 38101
38168: POP
38169: POP
38170: GO 38083
38172: POP
38173: POP
// end ; if not mc_repair_vehicle [ i ] then
38174: LD_EXP 86
38178: PUSH
38179: LD_VAR 0 2
38183: ARRAY
38184: NOT
38185: IFFALSE 38189
// continue ;
38187: GO 37694
// for j in mc_repair_vehicle [ i ] do
38189: LD_ADDR_VAR 0 3
38193: PUSH
38194: LD_EXP 86
38198: PUSH
38199: LD_VAR 0 2
38203: ARRAY
38204: PUSH
38205: FOR_IN
38206: IFFALSE 38372
// begin if GetClass ( j ) <> 3 then
38208: LD_VAR 0 3
38212: PPUSH
38213: CALL_OW 257
38217: PUSH
38218: LD_INT 3
38220: NONEQUAL
38221: IFFALSE 38262
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38223: LD_ADDR_EXP 86
38227: PUSH
38228: LD_EXP 86
38232: PPUSH
38233: LD_VAR 0 2
38237: PPUSH
38238: LD_EXP 86
38242: PUSH
38243: LD_VAR 0 2
38247: ARRAY
38248: PUSH
38249: LD_VAR 0 3
38253: DIFF
38254: PPUSH
38255: CALL_OW 1
38259: ST_TO_ADDR
// continue ;
38260: GO 38205
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38262: LD_VAR 0 3
38266: PPUSH
38267: CALL_OW 311
38271: NOT
38272: PUSH
38273: LD_VAR 0 3
38277: PUSH
38278: LD_EXP 77
38282: PUSH
38283: LD_VAR 0 2
38287: ARRAY
38288: PUSH
38289: LD_INT 1
38291: ARRAY
38292: IN
38293: NOT
38294: AND
38295: PUSH
38296: LD_VAR 0 3
38300: PUSH
38301: LD_EXP 77
38305: PUSH
38306: LD_VAR 0 2
38310: ARRAY
38311: PUSH
38312: LD_INT 2
38314: ARRAY
38315: IN
38316: NOT
38317: AND
38318: IFFALSE 38370
// begin if IsInUnit ( j ) then
38320: LD_VAR 0 3
38324: PPUSH
38325: CALL_OW 310
38329: IFFALSE 38340
// ComExitBuilding ( j ) ;
38331: LD_VAR 0 3
38335: PPUSH
38336: CALL_OW 122
// if not HasTask ( j ) then
38340: LD_VAR 0 3
38344: PPUSH
38345: CALL_OW 314
38349: NOT
38350: IFFALSE 38370
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38352: LD_VAR 0 3
38356: PPUSH
38357: LD_VAR 0 7
38361: PUSH
38362: LD_INT 1
38364: ARRAY
38365: PPUSH
38366: CALL_OW 189
// end ; end ;
38370: GO 38205
38372: POP
38373: POP
// end ;
38374: GO 37694
38376: POP
38377: POP
// end ;
38378: LD_VAR 0 1
38382: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38383: LD_INT 0
38385: PPUSH
38386: PPUSH
38387: PPUSH
38388: PPUSH
38389: PPUSH
38390: PPUSH
38391: PPUSH
38392: PPUSH
38393: PPUSH
38394: PPUSH
38395: PPUSH
// if not mc_bases then
38396: LD_EXP 74
38400: NOT
38401: IFFALSE 38405
// exit ;
38403: GO 39207
// for i = 1 to mc_bases do
38405: LD_ADDR_VAR 0 2
38409: PUSH
38410: DOUBLE
38411: LD_INT 1
38413: DEC
38414: ST_TO_ADDR
38415: LD_EXP 74
38419: PUSH
38420: FOR_TO
38421: IFFALSE 39205
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38423: LD_EXP 102
38427: PUSH
38428: LD_VAR 0 2
38432: ARRAY
38433: NOT
38434: PUSH
38435: LD_EXP 77
38439: PUSH
38440: LD_VAR 0 2
38444: ARRAY
38445: PUSH
38446: LD_INT 1
38448: ARRAY
38449: OR
38450: PUSH
38451: LD_EXP 77
38455: PUSH
38456: LD_VAR 0 2
38460: ARRAY
38461: PUSH
38462: LD_INT 2
38464: ARRAY
38465: OR
38466: PUSH
38467: LD_EXP 100
38471: PUSH
38472: LD_VAR 0 2
38476: ARRAY
38477: PPUSH
38478: LD_INT 1
38480: PPUSH
38481: CALL_OW 325
38485: NOT
38486: OR
38487: PUSH
38488: LD_EXP 97
38492: PUSH
38493: LD_VAR 0 2
38497: ARRAY
38498: OR
38499: IFFALSE 38503
// continue ;
38501: GO 38420
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38503: LD_ADDR_VAR 0 8
38507: PUSH
38508: LD_EXP 74
38512: PUSH
38513: LD_VAR 0 2
38517: ARRAY
38518: PPUSH
38519: LD_INT 25
38521: PUSH
38522: LD_INT 4
38524: PUSH
38525: EMPTY
38526: LIST
38527: LIST
38528: PUSH
38529: LD_INT 50
38531: PUSH
38532: EMPTY
38533: LIST
38534: PUSH
38535: LD_INT 3
38537: PUSH
38538: LD_INT 60
38540: PUSH
38541: EMPTY
38542: LIST
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: LIST
38552: PPUSH
38553: CALL_OW 72
38557: PUSH
38558: LD_EXP 78
38562: PUSH
38563: LD_VAR 0 2
38567: ARRAY
38568: DIFF
38569: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38570: LD_ADDR_VAR 0 9
38574: PUSH
38575: LD_EXP 74
38579: PUSH
38580: LD_VAR 0 2
38584: ARRAY
38585: PPUSH
38586: LD_INT 2
38588: PUSH
38589: LD_INT 30
38591: PUSH
38592: LD_INT 0
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 30
38601: PUSH
38602: LD_INT 1
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: LIST
38613: PPUSH
38614: CALL_OW 72
38618: ST_TO_ADDR
// if not tmp or not dep then
38619: LD_VAR 0 8
38623: NOT
38624: PUSH
38625: LD_VAR 0 9
38629: NOT
38630: OR
38631: IFFALSE 38635
// continue ;
38633: GO 38420
// side := GetSide ( tmp [ 1 ] ) ;
38635: LD_ADDR_VAR 0 11
38639: PUSH
38640: LD_VAR 0 8
38644: PUSH
38645: LD_INT 1
38647: ARRAY
38648: PPUSH
38649: CALL_OW 255
38653: ST_TO_ADDR
// dep := dep [ 1 ] ;
38654: LD_ADDR_VAR 0 9
38658: PUSH
38659: LD_VAR 0 9
38663: PUSH
38664: LD_INT 1
38666: ARRAY
38667: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38668: LD_ADDR_VAR 0 7
38672: PUSH
38673: LD_EXP 102
38677: PUSH
38678: LD_VAR 0 2
38682: ARRAY
38683: PPUSH
38684: LD_INT 22
38686: PUSH
38687: LD_INT 0
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 25
38696: PUSH
38697: LD_INT 12
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PPUSH
38708: CALL_OW 70
38712: PUSH
38713: LD_INT 22
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PUSH
38723: LD_INT 25
38725: PUSH
38726: LD_INT 12
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: LD_INT 91
38735: PUSH
38736: LD_VAR 0 9
38740: PUSH
38741: LD_INT 20
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: LIST
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: LIST
38753: PPUSH
38754: CALL_OW 69
38758: UNION
38759: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38760: LD_ADDR_VAR 0 10
38764: PUSH
38765: LD_EXP 102
38769: PUSH
38770: LD_VAR 0 2
38774: ARRAY
38775: PPUSH
38776: LD_INT 81
38778: PUSH
38779: LD_VAR 0 11
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: PPUSH
38788: CALL_OW 70
38792: ST_TO_ADDR
// if not apes or danger_at_area then
38793: LD_VAR 0 7
38797: NOT
38798: PUSH
38799: LD_VAR 0 10
38803: OR
38804: IFFALSE 38854
// begin if mc_taming [ i ] then
38806: LD_EXP 105
38810: PUSH
38811: LD_VAR 0 2
38815: ARRAY
38816: IFFALSE 38852
// begin MC_Reset ( i , 121 ) ;
38818: LD_VAR 0 2
38822: PPUSH
38823: LD_INT 121
38825: PPUSH
38826: CALL 24185 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38830: LD_ADDR_EXP 105
38834: PUSH
38835: LD_EXP 105
38839: PPUSH
38840: LD_VAR 0 2
38844: PPUSH
38845: EMPTY
38846: PPUSH
38847: CALL_OW 1
38851: ST_TO_ADDR
// end ; continue ;
38852: GO 38420
// end ; for j in tmp do
38854: LD_ADDR_VAR 0 3
38858: PUSH
38859: LD_VAR 0 8
38863: PUSH
38864: FOR_IN
38865: IFFALSE 39201
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
38867: LD_VAR 0 3
38871: PUSH
38872: LD_EXP 105
38876: PUSH
38877: LD_VAR 0 2
38881: ARRAY
38882: IN
38883: NOT
38884: PUSH
38885: LD_EXP 105
38889: PUSH
38890: LD_VAR 0 2
38894: ARRAY
38895: PUSH
38896: LD_INT 3
38898: LESS
38899: AND
38900: IFFALSE 38958
// begin SetTag ( j , 121 ) ;
38902: LD_VAR 0 3
38906: PPUSH
38907: LD_INT 121
38909: PPUSH
38910: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
38914: LD_ADDR_EXP 105
38918: PUSH
38919: LD_EXP 105
38923: PPUSH
38924: LD_VAR 0 2
38928: PUSH
38929: LD_EXP 105
38933: PUSH
38934: LD_VAR 0 2
38938: ARRAY
38939: PUSH
38940: LD_INT 1
38942: PLUS
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PPUSH
38948: LD_VAR 0 3
38952: PPUSH
38953: CALL 57398 0 3
38957: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
38958: LD_VAR 0 3
38962: PUSH
38963: LD_EXP 105
38967: PUSH
38968: LD_VAR 0 2
38972: ARRAY
38973: IN
38974: IFFALSE 39199
// begin if GetClass ( j ) <> 4 then
38976: LD_VAR 0 3
38980: PPUSH
38981: CALL_OW 257
38985: PUSH
38986: LD_INT 4
38988: NONEQUAL
38989: IFFALSE 39042
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
38991: LD_ADDR_EXP 105
38995: PUSH
38996: LD_EXP 105
39000: PPUSH
39001: LD_VAR 0 2
39005: PPUSH
39006: LD_EXP 105
39010: PUSH
39011: LD_VAR 0 2
39015: ARRAY
39016: PUSH
39017: LD_VAR 0 3
39021: DIFF
39022: PPUSH
39023: CALL_OW 1
39027: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39028: LD_VAR 0 3
39032: PPUSH
39033: LD_INT 0
39035: PPUSH
39036: CALL_OW 109
// continue ;
39040: GO 38864
// end ; if IsInUnit ( j ) then
39042: LD_VAR 0 3
39046: PPUSH
39047: CALL_OW 310
39051: IFFALSE 39062
// ComExitBuilding ( j ) ;
39053: LD_VAR 0 3
39057: PPUSH
39058: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39062: LD_ADDR_VAR 0 6
39066: PUSH
39067: LD_VAR 0 7
39071: PPUSH
39072: LD_VAR 0 3
39076: PPUSH
39077: CALL_OW 74
39081: ST_TO_ADDR
// if not ape then
39082: LD_VAR 0 6
39086: NOT
39087: IFFALSE 39091
// break ;
39089: GO 39201
// x := GetX ( ape ) ;
39091: LD_ADDR_VAR 0 4
39095: PUSH
39096: LD_VAR 0 6
39100: PPUSH
39101: CALL_OW 250
39105: ST_TO_ADDR
// y := GetY ( ape ) ;
39106: LD_ADDR_VAR 0 5
39110: PUSH
39111: LD_VAR 0 6
39115: PPUSH
39116: CALL_OW 251
39120: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39121: LD_VAR 0 4
39125: PPUSH
39126: LD_VAR 0 5
39130: PPUSH
39131: CALL_OW 488
39135: NOT
39136: PUSH
39137: LD_VAR 0 11
39141: PPUSH
39142: LD_VAR 0 4
39146: PPUSH
39147: LD_VAR 0 5
39151: PPUSH
39152: LD_INT 20
39154: PPUSH
39155: CALL 58294 0 4
39159: PUSH
39160: LD_INT 4
39162: ARRAY
39163: OR
39164: IFFALSE 39168
// break ;
39166: GO 39201
// if not HasTask ( j ) then
39168: LD_VAR 0 3
39172: PPUSH
39173: CALL_OW 314
39177: NOT
39178: IFFALSE 39199
// ComTameXY ( j , x , y ) ;
39180: LD_VAR 0 3
39184: PPUSH
39185: LD_VAR 0 4
39189: PPUSH
39190: LD_VAR 0 5
39194: PPUSH
39195: CALL_OW 131
// end ; end ;
39199: GO 38864
39201: POP
39202: POP
// end ;
39203: GO 38420
39205: POP
39206: POP
// end ;
39207: LD_VAR 0 1
39211: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39212: LD_INT 0
39214: PPUSH
39215: PPUSH
39216: PPUSH
39217: PPUSH
39218: PPUSH
39219: PPUSH
39220: PPUSH
39221: PPUSH
// if not mc_bases then
39222: LD_EXP 74
39226: NOT
39227: IFFALSE 39231
// exit ;
39229: GO 39857
// for i = 1 to mc_bases do
39231: LD_ADDR_VAR 0 2
39235: PUSH
39236: DOUBLE
39237: LD_INT 1
39239: DEC
39240: ST_TO_ADDR
39241: LD_EXP 74
39245: PUSH
39246: FOR_TO
39247: IFFALSE 39855
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39249: LD_EXP 103
39253: PUSH
39254: LD_VAR 0 2
39258: ARRAY
39259: NOT
39260: PUSH
39261: LD_EXP 103
39265: PUSH
39266: LD_VAR 0 2
39270: ARRAY
39271: PPUSH
39272: LD_INT 25
39274: PUSH
39275: LD_INT 12
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PPUSH
39282: CALL_OW 72
39286: NOT
39287: OR
39288: IFFALSE 39292
// continue ;
39290: GO 39246
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39292: LD_ADDR_VAR 0 5
39296: PUSH
39297: LD_EXP 103
39301: PUSH
39302: LD_VAR 0 2
39306: ARRAY
39307: PUSH
39308: LD_INT 1
39310: ARRAY
39311: PPUSH
39312: CALL_OW 255
39316: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39317: LD_VAR 0 5
39321: PPUSH
39322: LD_INT 2
39324: PPUSH
39325: CALL_OW 325
39329: IFFALSE 39582
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39331: LD_ADDR_VAR 0 4
39335: PUSH
39336: LD_EXP 103
39340: PUSH
39341: LD_VAR 0 2
39345: ARRAY
39346: PPUSH
39347: LD_INT 25
39349: PUSH
39350: LD_INT 16
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PPUSH
39357: CALL_OW 72
39361: ST_TO_ADDR
// if tmp < 6 then
39362: LD_VAR 0 4
39366: PUSH
39367: LD_INT 6
39369: LESS
39370: IFFALSE 39582
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39372: LD_ADDR_VAR 0 6
39376: PUSH
39377: LD_EXP 74
39381: PUSH
39382: LD_VAR 0 2
39386: ARRAY
39387: PPUSH
39388: LD_INT 2
39390: PUSH
39391: LD_INT 30
39393: PUSH
39394: LD_INT 0
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 30
39403: PUSH
39404: LD_INT 1
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: LIST
39415: PPUSH
39416: CALL_OW 72
39420: ST_TO_ADDR
// if depot then
39421: LD_VAR 0 6
39425: IFFALSE 39582
// begin selected := 0 ;
39427: LD_ADDR_VAR 0 7
39431: PUSH
39432: LD_INT 0
39434: ST_TO_ADDR
// for j in depot do
39435: LD_ADDR_VAR 0 3
39439: PUSH
39440: LD_VAR 0 6
39444: PUSH
39445: FOR_IN
39446: IFFALSE 39477
// begin if UnitsInside ( j ) < 6 then
39448: LD_VAR 0 3
39452: PPUSH
39453: CALL_OW 313
39457: PUSH
39458: LD_INT 6
39460: LESS
39461: IFFALSE 39475
// begin selected := j ;
39463: LD_ADDR_VAR 0 7
39467: PUSH
39468: LD_VAR 0 3
39472: ST_TO_ADDR
// break ;
39473: GO 39477
// end ; end ;
39475: GO 39445
39477: POP
39478: POP
// if selected then
39479: LD_VAR 0 7
39483: IFFALSE 39582
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39485: LD_ADDR_VAR 0 3
39489: PUSH
39490: LD_EXP 103
39494: PUSH
39495: LD_VAR 0 2
39499: ARRAY
39500: PPUSH
39501: LD_INT 25
39503: PUSH
39504: LD_INT 12
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PPUSH
39511: CALL_OW 72
39515: PUSH
39516: FOR_IN
39517: IFFALSE 39580
// if not HasTask ( j ) then
39519: LD_VAR 0 3
39523: PPUSH
39524: CALL_OW 314
39528: NOT
39529: IFFALSE 39578
// begin if not IsInUnit ( j ) then
39531: LD_VAR 0 3
39535: PPUSH
39536: CALL_OW 310
39540: NOT
39541: IFFALSE 39557
// ComEnterUnit ( j , selected ) ;
39543: LD_VAR 0 3
39547: PPUSH
39548: LD_VAR 0 7
39552: PPUSH
39553: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39557: LD_VAR 0 3
39561: PPUSH
39562: LD_INT 16
39564: PPUSH
39565: CALL_OW 183
// AddComExitBuilding ( j ) ;
39569: LD_VAR 0 3
39573: PPUSH
39574: CALL_OW 182
// end ;
39578: GO 39516
39580: POP
39581: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39582: LD_VAR 0 5
39586: PPUSH
39587: LD_INT 11
39589: PPUSH
39590: CALL_OW 325
39594: IFFALSE 39853
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39596: LD_ADDR_VAR 0 4
39600: PUSH
39601: LD_EXP 103
39605: PUSH
39606: LD_VAR 0 2
39610: ARRAY
39611: PPUSH
39612: LD_INT 25
39614: PUSH
39615: LD_INT 16
39617: PUSH
39618: EMPTY
39619: LIST
39620: LIST
39621: PPUSH
39622: CALL_OW 72
39626: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39627: LD_VAR 0 4
39631: PUSH
39632: LD_INT 6
39634: GREATEREQUAL
39635: PUSH
39636: LD_VAR 0 5
39640: PPUSH
39641: LD_INT 2
39643: PPUSH
39644: CALL_OW 325
39648: NOT
39649: OR
39650: IFFALSE 39853
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39652: LD_ADDR_VAR 0 8
39656: PUSH
39657: LD_EXP 74
39661: PUSH
39662: LD_VAR 0 2
39666: ARRAY
39667: PPUSH
39668: LD_INT 2
39670: PUSH
39671: LD_INT 30
39673: PUSH
39674: LD_INT 4
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 30
39683: PUSH
39684: LD_INT 5
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: LIST
39695: PPUSH
39696: CALL_OW 72
39700: ST_TO_ADDR
// if barracks then
39701: LD_VAR 0 8
39705: IFFALSE 39853
// begin selected := 0 ;
39707: LD_ADDR_VAR 0 7
39711: PUSH
39712: LD_INT 0
39714: ST_TO_ADDR
// for j in barracks do
39715: LD_ADDR_VAR 0 3
39719: PUSH
39720: LD_VAR 0 8
39724: PUSH
39725: FOR_IN
39726: IFFALSE 39757
// begin if UnitsInside ( j ) < 6 then
39728: LD_VAR 0 3
39732: PPUSH
39733: CALL_OW 313
39737: PUSH
39738: LD_INT 6
39740: LESS
39741: IFFALSE 39755
// begin selected := j ;
39743: LD_ADDR_VAR 0 7
39747: PUSH
39748: LD_VAR 0 3
39752: ST_TO_ADDR
// break ;
39753: GO 39757
// end ; end ;
39755: GO 39725
39757: POP
39758: POP
// if selected then
39759: LD_VAR 0 7
39763: IFFALSE 39853
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39765: LD_ADDR_VAR 0 3
39769: PUSH
39770: LD_EXP 103
39774: PUSH
39775: LD_VAR 0 2
39779: ARRAY
39780: PPUSH
39781: LD_INT 25
39783: PUSH
39784: LD_INT 12
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PPUSH
39791: CALL_OW 72
39795: PUSH
39796: FOR_IN
39797: IFFALSE 39851
// if not IsInUnit ( j ) and not HasTask ( j ) then
39799: LD_VAR 0 3
39803: PPUSH
39804: CALL_OW 310
39808: NOT
39809: PUSH
39810: LD_VAR 0 3
39814: PPUSH
39815: CALL_OW 314
39819: NOT
39820: AND
39821: IFFALSE 39849
// begin ComEnterUnit ( j , selected ) ;
39823: LD_VAR 0 3
39827: PPUSH
39828: LD_VAR 0 7
39832: PPUSH
39833: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39837: LD_VAR 0 3
39841: PPUSH
39842: LD_INT 15
39844: PPUSH
39845: CALL_OW 183
// end ;
39849: GO 39796
39851: POP
39852: POP
// end ; end ; end ; end ; end ;
39853: GO 39246
39855: POP
39856: POP
// end ;
39857: LD_VAR 0 1
39861: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
39862: LD_INT 0
39864: PPUSH
39865: PPUSH
39866: PPUSH
39867: PPUSH
// if not mc_bases then
39868: LD_EXP 74
39872: NOT
39873: IFFALSE 39877
// exit ;
39875: GO 40055
// for i = 1 to mc_bases do
39877: LD_ADDR_VAR 0 2
39881: PUSH
39882: DOUBLE
39883: LD_INT 1
39885: DEC
39886: ST_TO_ADDR
39887: LD_EXP 74
39891: PUSH
39892: FOR_TO
39893: IFFALSE 40053
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
39895: LD_ADDR_VAR 0 4
39899: PUSH
39900: LD_EXP 74
39904: PUSH
39905: LD_VAR 0 2
39909: ARRAY
39910: PPUSH
39911: LD_INT 25
39913: PUSH
39914: LD_INT 9
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PPUSH
39921: CALL_OW 72
39925: ST_TO_ADDR
// if not tmp then
39926: LD_VAR 0 4
39930: NOT
39931: IFFALSE 39935
// continue ;
39933: GO 39892
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
39935: LD_EXP 100
39939: PUSH
39940: LD_VAR 0 2
39944: ARRAY
39945: PPUSH
39946: LD_INT 29
39948: PPUSH
39949: CALL_OW 325
39953: NOT
39954: PUSH
39955: LD_EXP 100
39959: PUSH
39960: LD_VAR 0 2
39964: ARRAY
39965: PPUSH
39966: LD_INT 28
39968: PPUSH
39969: CALL_OW 325
39973: NOT
39974: AND
39975: IFFALSE 39979
// continue ;
39977: GO 39892
// for j in tmp do
39979: LD_ADDR_VAR 0 3
39983: PUSH
39984: LD_VAR 0 4
39988: PUSH
39989: FOR_IN
39990: IFFALSE 40049
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39992: LD_VAR 0 3
39996: PUSH
39997: LD_EXP 77
40001: PUSH
40002: LD_VAR 0 2
40006: ARRAY
40007: PUSH
40008: LD_INT 1
40010: ARRAY
40011: IN
40012: NOT
40013: PUSH
40014: LD_VAR 0 3
40018: PUSH
40019: LD_EXP 77
40023: PUSH
40024: LD_VAR 0 2
40028: ARRAY
40029: PUSH
40030: LD_INT 2
40032: ARRAY
40033: IN
40034: NOT
40035: AND
40036: IFFALSE 40047
// ComSpaceTimeShoot ( j ) ;
40038: LD_VAR 0 3
40042: PPUSH
40043: CALL 51073 0 1
40047: GO 39989
40049: POP
40050: POP
// end ;
40051: GO 39892
40053: POP
40054: POP
// end ;
40055: LD_VAR 0 1
40059: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40060: LD_INT 0
40062: PPUSH
40063: PPUSH
40064: PPUSH
40065: PPUSH
40066: PPUSH
40067: PPUSH
40068: PPUSH
40069: PPUSH
40070: PPUSH
// if not mc_bases then
40071: LD_EXP 74
40075: NOT
40076: IFFALSE 40080
// exit ;
40078: GO 40702
// for i = 1 to mc_bases do
40080: LD_ADDR_VAR 0 2
40084: PUSH
40085: DOUBLE
40086: LD_INT 1
40088: DEC
40089: ST_TO_ADDR
40090: LD_EXP 74
40094: PUSH
40095: FOR_TO
40096: IFFALSE 40700
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40098: LD_EXP 109
40102: PUSH
40103: LD_VAR 0 2
40107: ARRAY
40108: NOT
40109: PUSH
40110: LD_INT 38
40112: PPUSH
40113: LD_EXP 100
40117: PUSH
40118: LD_VAR 0 2
40122: ARRAY
40123: PPUSH
40124: CALL_OW 321
40128: PUSH
40129: LD_INT 2
40131: NONEQUAL
40132: OR
40133: IFFALSE 40137
// continue ;
40135: GO 40095
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40137: LD_ADDR_VAR 0 8
40141: PUSH
40142: LD_EXP 74
40146: PUSH
40147: LD_VAR 0 2
40151: ARRAY
40152: PPUSH
40153: LD_INT 30
40155: PUSH
40156: LD_INT 34
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: PPUSH
40163: CALL_OW 72
40167: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40168: LD_ADDR_VAR 0 9
40172: PUSH
40173: LD_EXP 74
40177: PUSH
40178: LD_VAR 0 2
40182: ARRAY
40183: PPUSH
40184: LD_INT 25
40186: PUSH
40187: LD_INT 4
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PPUSH
40194: CALL_OW 72
40198: PPUSH
40199: LD_INT 0
40201: PPUSH
40202: CALL 90658 0 2
40206: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40207: LD_VAR 0 9
40211: NOT
40212: PUSH
40213: LD_VAR 0 8
40217: NOT
40218: OR
40219: PUSH
40220: LD_EXP 74
40224: PUSH
40225: LD_VAR 0 2
40229: ARRAY
40230: PPUSH
40231: LD_INT 124
40233: PPUSH
40234: CALL 90658 0 2
40238: OR
40239: IFFALSE 40243
// continue ;
40241: GO 40095
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40243: LD_EXP 110
40247: PUSH
40248: LD_VAR 0 2
40252: ARRAY
40253: PUSH
40254: LD_EXP 109
40258: PUSH
40259: LD_VAR 0 2
40263: ARRAY
40264: LESS
40265: PUSH
40266: LD_EXP 110
40270: PUSH
40271: LD_VAR 0 2
40275: ARRAY
40276: PUSH
40277: LD_VAR 0 8
40281: LESS
40282: AND
40283: IFFALSE 40698
// begin tmp := sci [ 1 ] ;
40285: LD_ADDR_VAR 0 7
40289: PUSH
40290: LD_VAR 0 9
40294: PUSH
40295: LD_INT 1
40297: ARRAY
40298: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40299: LD_VAR 0 7
40303: PPUSH
40304: LD_INT 124
40306: PPUSH
40307: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40311: LD_ADDR_VAR 0 3
40315: PUSH
40316: DOUBLE
40317: LD_EXP 109
40321: PUSH
40322: LD_VAR 0 2
40326: ARRAY
40327: INC
40328: ST_TO_ADDR
40329: LD_EXP 109
40333: PUSH
40334: LD_VAR 0 2
40338: ARRAY
40339: PUSH
40340: FOR_DOWNTO
40341: IFFALSE 40684
// begin if IsInUnit ( tmp ) then
40343: LD_VAR 0 7
40347: PPUSH
40348: CALL_OW 310
40352: IFFALSE 40363
// ComExitBuilding ( tmp ) ;
40354: LD_VAR 0 7
40358: PPUSH
40359: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40363: LD_INT 35
40365: PPUSH
40366: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40370: LD_VAR 0 7
40374: PPUSH
40375: CALL_OW 310
40379: NOT
40380: PUSH
40381: LD_VAR 0 7
40385: PPUSH
40386: CALL_OW 314
40390: NOT
40391: AND
40392: IFFALSE 40363
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40394: LD_ADDR_VAR 0 6
40398: PUSH
40399: LD_VAR 0 7
40403: PPUSH
40404: CALL_OW 250
40408: PUSH
40409: LD_VAR 0 7
40413: PPUSH
40414: CALL_OW 251
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40423: LD_INT 35
40425: PPUSH
40426: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40430: LD_ADDR_VAR 0 4
40434: PUSH
40435: LD_EXP 109
40439: PUSH
40440: LD_VAR 0 2
40444: ARRAY
40445: PUSH
40446: LD_VAR 0 3
40450: ARRAY
40451: PUSH
40452: LD_INT 1
40454: ARRAY
40455: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40456: LD_ADDR_VAR 0 5
40460: PUSH
40461: LD_EXP 109
40465: PUSH
40466: LD_VAR 0 2
40470: ARRAY
40471: PUSH
40472: LD_VAR 0 3
40476: ARRAY
40477: PUSH
40478: LD_INT 2
40480: ARRAY
40481: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40482: LD_VAR 0 7
40486: PPUSH
40487: LD_INT 10
40489: PPUSH
40490: CALL 59991 0 2
40494: PUSH
40495: LD_INT 4
40497: ARRAY
40498: IFFALSE 40536
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40500: LD_VAR 0 7
40504: PPUSH
40505: LD_VAR 0 6
40509: PUSH
40510: LD_INT 1
40512: ARRAY
40513: PPUSH
40514: LD_VAR 0 6
40518: PUSH
40519: LD_INT 2
40521: ARRAY
40522: PPUSH
40523: CALL_OW 111
// wait ( 0 0$10 ) ;
40527: LD_INT 350
40529: PPUSH
40530: CALL_OW 67
// end else
40534: GO 40562
// begin ComMoveXY ( tmp , x , y ) ;
40536: LD_VAR 0 7
40540: PPUSH
40541: LD_VAR 0 4
40545: PPUSH
40546: LD_VAR 0 5
40550: PPUSH
40551: CALL_OW 111
// wait ( 0 0$3 ) ;
40555: LD_INT 105
40557: PPUSH
40558: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40562: LD_VAR 0 7
40566: PPUSH
40567: LD_VAR 0 4
40571: PPUSH
40572: LD_VAR 0 5
40576: PPUSH
40577: CALL_OW 307
40581: IFFALSE 40423
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40583: LD_VAR 0 7
40587: PPUSH
40588: LD_VAR 0 4
40592: PPUSH
40593: LD_VAR 0 5
40597: PPUSH
40598: LD_VAR 0 8
40602: PUSH
40603: LD_VAR 0 3
40607: ARRAY
40608: PPUSH
40609: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40613: LD_INT 35
40615: PPUSH
40616: CALL_OW 67
// until not HasTask ( tmp ) ;
40620: LD_VAR 0 7
40624: PPUSH
40625: CALL_OW 314
40629: NOT
40630: IFFALSE 40613
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40632: LD_ADDR_EXP 110
40636: PUSH
40637: LD_EXP 110
40641: PPUSH
40642: LD_VAR 0 2
40646: PUSH
40647: LD_EXP 110
40651: PUSH
40652: LD_VAR 0 2
40656: ARRAY
40657: PUSH
40658: LD_INT 1
40660: PLUS
40661: PUSH
40662: EMPTY
40663: LIST
40664: LIST
40665: PPUSH
40666: LD_VAR 0 8
40670: PUSH
40671: LD_VAR 0 3
40675: ARRAY
40676: PPUSH
40677: CALL 57398 0 3
40681: ST_TO_ADDR
// end ;
40682: GO 40340
40684: POP
40685: POP
// MC_Reset ( i , 124 ) ;
40686: LD_VAR 0 2
40690: PPUSH
40691: LD_INT 124
40693: PPUSH
40694: CALL 24185 0 2
// end ; end ;
40698: GO 40095
40700: POP
40701: POP
// end ;
40702: LD_VAR 0 1
40706: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40707: LD_INT 0
40709: PPUSH
40710: PPUSH
40711: PPUSH
// if not mc_bases then
40712: LD_EXP 74
40716: NOT
40717: IFFALSE 40721
// exit ;
40719: GO 41327
// for i = 1 to mc_bases do
40721: LD_ADDR_VAR 0 2
40725: PUSH
40726: DOUBLE
40727: LD_INT 1
40729: DEC
40730: ST_TO_ADDR
40731: LD_EXP 74
40735: PUSH
40736: FOR_TO
40737: IFFALSE 41325
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40739: LD_ADDR_VAR 0 3
40743: PUSH
40744: LD_EXP 74
40748: PUSH
40749: LD_VAR 0 2
40753: ARRAY
40754: PPUSH
40755: LD_INT 25
40757: PUSH
40758: LD_INT 4
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PPUSH
40765: CALL_OW 72
40769: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40770: LD_VAR 0 3
40774: NOT
40775: PUSH
40776: LD_EXP 111
40780: PUSH
40781: LD_VAR 0 2
40785: ARRAY
40786: NOT
40787: OR
40788: PUSH
40789: LD_EXP 74
40793: PUSH
40794: LD_VAR 0 2
40798: ARRAY
40799: PPUSH
40800: LD_INT 2
40802: PUSH
40803: LD_INT 30
40805: PUSH
40806: LD_INT 0
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 30
40815: PUSH
40816: LD_INT 1
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: LIST
40827: PPUSH
40828: CALL_OW 72
40832: NOT
40833: OR
40834: IFFALSE 40884
// begin if mc_deposits_finder [ i ] then
40836: LD_EXP 112
40840: PUSH
40841: LD_VAR 0 2
40845: ARRAY
40846: IFFALSE 40882
// begin MC_Reset ( i , 125 ) ;
40848: LD_VAR 0 2
40852: PPUSH
40853: LD_INT 125
40855: PPUSH
40856: CALL 24185 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40860: LD_ADDR_EXP 112
40864: PUSH
40865: LD_EXP 112
40869: PPUSH
40870: LD_VAR 0 2
40874: PPUSH
40875: EMPTY
40876: PPUSH
40877: CALL_OW 1
40881: ST_TO_ADDR
// end ; continue ;
40882: GO 40736
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
40884: LD_EXP 111
40888: PUSH
40889: LD_VAR 0 2
40893: ARRAY
40894: PUSH
40895: LD_INT 1
40897: ARRAY
40898: PUSH
40899: LD_INT 3
40901: ARRAY
40902: PUSH
40903: LD_INT 1
40905: EQUAL
40906: PUSH
40907: LD_INT 20
40909: PPUSH
40910: LD_EXP 100
40914: PUSH
40915: LD_VAR 0 2
40919: ARRAY
40920: PPUSH
40921: CALL_OW 321
40925: PUSH
40926: LD_INT 2
40928: NONEQUAL
40929: AND
40930: IFFALSE 40980
// begin if mc_deposits_finder [ i ] then
40932: LD_EXP 112
40936: PUSH
40937: LD_VAR 0 2
40941: ARRAY
40942: IFFALSE 40978
// begin MC_Reset ( i , 125 ) ;
40944: LD_VAR 0 2
40948: PPUSH
40949: LD_INT 125
40951: PPUSH
40952: CALL 24185 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40956: LD_ADDR_EXP 112
40960: PUSH
40961: LD_EXP 112
40965: PPUSH
40966: LD_VAR 0 2
40970: PPUSH
40971: EMPTY
40972: PPUSH
40973: CALL_OW 1
40977: ST_TO_ADDR
// end ; continue ;
40978: GO 40736
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
40980: LD_EXP 111
40984: PUSH
40985: LD_VAR 0 2
40989: ARRAY
40990: PUSH
40991: LD_INT 1
40993: ARRAY
40994: PUSH
40995: LD_INT 1
40997: ARRAY
40998: PPUSH
40999: LD_EXP 111
41003: PUSH
41004: LD_VAR 0 2
41008: ARRAY
41009: PUSH
41010: LD_INT 1
41012: ARRAY
41013: PUSH
41014: LD_INT 2
41016: ARRAY
41017: PPUSH
41018: LD_EXP 100
41022: PUSH
41023: LD_VAR 0 2
41027: ARRAY
41028: PPUSH
41029: CALL_OW 440
41033: IFFALSE 41076
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41035: LD_ADDR_EXP 111
41039: PUSH
41040: LD_EXP 111
41044: PPUSH
41045: LD_VAR 0 2
41049: PPUSH
41050: LD_EXP 111
41054: PUSH
41055: LD_VAR 0 2
41059: ARRAY
41060: PPUSH
41061: LD_INT 1
41063: PPUSH
41064: CALL_OW 3
41068: PPUSH
41069: CALL_OW 1
41073: ST_TO_ADDR
41074: GO 41323
// begin if not mc_deposits_finder [ i ] then
41076: LD_EXP 112
41080: PUSH
41081: LD_VAR 0 2
41085: ARRAY
41086: NOT
41087: IFFALSE 41139
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41089: LD_ADDR_EXP 112
41093: PUSH
41094: LD_EXP 112
41098: PPUSH
41099: LD_VAR 0 2
41103: PPUSH
41104: LD_VAR 0 3
41108: PUSH
41109: LD_INT 1
41111: ARRAY
41112: PUSH
41113: EMPTY
41114: LIST
41115: PPUSH
41116: CALL_OW 1
41120: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41121: LD_VAR 0 3
41125: PUSH
41126: LD_INT 1
41128: ARRAY
41129: PPUSH
41130: LD_INT 125
41132: PPUSH
41133: CALL_OW 109
// end else
41137: GO 41323
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41139: LD_EXP 112
41143: PUSH
41144: LD_VAR 0 2
41148: ARRAY
41149: PUSH
41150: LD_INT 1
41152: ARRAY
41153: PPUSH
41154: CALL_OW 310
41158: IFFALSE 41181
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41160: LD_EXP 112
41164: PUSH
41165: LD_VAR 0 2
41169: ARRAY
41170: PUSH
41171: LD_INT 1
41173: ARRAY
41174: PPUSH
41175: CALL_OW 122
41179: GO 41323
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41181: LD_EXP 112
41185: PUSH
41186: LD_VAR 0 2
41190: ARRAY
41191: PUSH
41192: LD_INT 1
41194: ARRAY
41195: PPUSH
41196: CALL_OW 314
41200: NOT
41201: PUSH
41202: LD_EXP 112
41206: PUSH
41207: LD_VAR 0 2
41211: ARRAY
41212: PUSH
41213: LD_INT 1
41215: ARRAY
41216: PPUSH
41217: LD_EXP 111
41221: PUSH
41222: LD_VAR 0 2
41226: ARRAY
41227: PUSH
41228: LD_INT 1
41230: ARRAY
41231: PUSH
41232: LD_INT 1
41234: ARRAY
41235: PPUSH
41236: LD_EXP 111
41240: PUSH
41241: LD_VAR 0 2
41245: ARRAY
41246: PUSH
41247: LD_INT 1
41249: ARRAY
41250: PUSH
41251: LD_INT 2
41253: ARRAY
41254: PPUSH
41255: CALL_OW 297
41259: PUSH
41260: LD_INT 6
41262: GREATER
41263: AND
41264: IFFALSE 41323
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41266: LD_EXP 112
41270: PUSH
41271: LD_VAR 0 2
41275: ARRAY
41276: PUSH
41277: LD_INT 1
41279: ARRAY
41280: PPUSH
41281: LD_EXP 111
41285: PUSH
41286: LD_VAR 0 2
41290: ARRAY
41291: PUSH
41292: LD_INT 1
41294: ARRAY
41295: PUSH
41296: LD_INT 1
41298: ARRAY
41299: PPUSH
41300: LD_EXP 111
41304: PUSH
41305: LD_VAR 0 2
41309: ARRAY
41310: PUSH
41311: LD_INT 1
41313: ARRAY
41314: PUSH
41315: LD_INT 2
41317: ARRAY
41318: PPUSH
41319: CALL_OW 111
// end ; end ; end ;
41323: GO 40736
41325: POP
41326: POP
// end ;
41327: LD_VAR 0 1
41331: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41332: LD_INT 0
41334: PPUSH
41335: PPUSH
41336: PPUSH
41337: PPUSH
41338: PPUSH
41339: PPUSH
41340: PPUSH
41341: PPUSH
41342: PPUSH
41343: PPUSH
41344: PPUSH
// if not mc_bases then
41345: LD_EXP 74
41349: NOT
41350: IFFALSE 41354
// exit ;
41352: GO 42294
// for i = 1 to mc_bases do
41354: LD_ADDR_VAR 0 2
41358: PUSH
41359: DOUBLE
41360: LD_INT 1
41362: DEC
41363: ST_TO_ADDR
41364: LD_EXP 74
41368: PUSH
41369: FOR_TO
41370: IFFALSE 42292
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41372: LD_EXP 74
41376: PUSH
41377: LD_VAR 0 2
41381: ARRAY
41382: NOT
41383: PUSH
41384: LD_EXP 97
41388: PUSH
41389: LD_VAR 0 2
41393: ARRAY
41394: OR
41395: IFFALSE 41399
// continue ;
41397: GO 41369
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41399: LD_ADDR_VAR 0 7
41403: PUSH
41404: LD_EXP 74
41408: PUSH
41409: LD_VAR 0 2
41413: ARRAY
41414: PUSH
41415: LD_INT 1
41417: ARRAY
41418: PPUSH
41419: CALL_OW 248
41423: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41424: LD_VAR 0 7
41428: PUSH
41429: LD_INT 3
41431: EQUAL
41432: PUSH
41433: LD_EXP 93
41437: PUSH
41438: LD_VAR 0 2
41442: ARRAY
41443: PUSH
41444: LD_EXP 96
41448: PUSH
41449: LD_VAR 0 2
41453: ARRAY
41454: UNION
41455: PPUSH
41456: LD_INT 33
41458: PUSH
41459: LD_INT 2
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PPUSH
41466: CALL_OW 72
41470: NOT
41471: OR
41472: IFFALSE 41476
// continue ;
41474: GO 41369
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41476: LD_ADDR_VAR 0 9
41480: PUSH
41481: LD_EXP 74
41485: PUSH
41486: LD_VAR 0 2
41490: ARRAY
41491: PPUSH
41492: LD_INT 30
41494: PUSH
41495: LD_INT 36
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PPUSH
41502: CALL_OW 72
41506: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41507: LD_ADDR_VAR 0 10
41511: PUSH
41512: LD_EXP 93
41516: PUSH
41517: LD_VAR 0 2
41521: ARRAY
41522: PPUSH
41523: LD_INT 34
41525: PUSH
41526: LD_INT 31
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PPUSH
41533: CALL_OW 72
41537: ST_TO_ADDR
// if not cts and not mcts then
41538: LD_VAR 0 9
41542: NOT
41543: PUSH
41544: LD_VAR 0 10
41548: NOT
41549: AND
41550: IFFALSE 41554
// continue ;
41552: GO 41369
// x := cts ;
41554: LD_ADDR_VAR 0 11
41558: PUSH
41559: LD_VAR 0 9
41563: ST_TO_ADDR
// if not x then
41564: LD_VAR 0 11
41568: NOT
41569: IFFALSE 41581
// x := mcts ;
41571: LD_ADDR_VAR 0 11
41575: PUSH
41576: LD_VAR 0 10
41580: ST_TO_ADDR
// if not x then
41581: LD_VAR 0 11
41585: NOT
41586: IFFALSE 41590
// continue ;
41588: GO 41369
// if mc_remote_driver [ i ] then
41590: LD_EXP 114
41594: PUSH
41595: LD_VAR 0 2
41599: ARRAY
41600: IFFALSE 41987
// for j in mc_remote_driver [ i ] do
41602: LD_ADDR_VAR 0 3
41606: PUSH
41607: LD_EXP 114
41611: PUSH
41612: LD_VAR 0 2
41616: ARRAY
41617: PUSH
41618: FOR_IN
41619: IFFALSE 41985
// begin if GetClass ( j ) <> 3 then
41621: LD_VAR 0 3
41625: PPUSH
41626: CALL_OW 257
41630: PUSH
41631: LD_INT 3
41633: NONEQUAL
41634: IFFALSE 41687
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41636: LD_ADDR_EXP 114
41640: PUSH
41641: LD_EXP 114
41645: PPUSH
41646: LD_VAR 0 2
41650: PPUSH
41651: LD_EXP 114
41655: PUSH
41656: LD_VAR 0 2
41660: ARRAY
41661: PUSH
41662: LD_VAR 0 3
41666: DIFF
41667: PPUSH
41668: CALL_OW 1
41672: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41673: LD_VAR 0 3
41677: PPUSH
41678: LD_INT 0
41680: PPUSH
41681: CALL_OW 109
// continue ;
41685: GO 41618
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
41687: LD_EXP 93
41691: PUSH
41692: LD_VAR 0 2
41696: ARRAY
41697: PPUSH
41698: LD_INT 34
41700: PUSH
41701: LD_INT 31
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: LD_INT 58
41710: PUSH
41711: EMPTY
41712: LIST
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PPUSH
41718: CALL_OW 72
41722: PUSH
41723: LD_VAR 0 3
41727: PPUSH
41728: CALL 90746 0 1
41732: NOT
41733: AND
41734: IFFALSE 41805
// begin if IsInUnit ( j ) then
41736: LD_VAR 0 3
41740: PPUSH
41741: CALL_OW 310
41745: IFFALSE 41756
// ComExitBuilding ( j ) ;
41747: LD_VAR 0 3
41751: PPUSH
41752: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
41756: LD_VAR 0 3
41760: PPUSH
41761: LD_EXP 93
41765: PUSH
41766: LD_VAR 0 2
41770: ARRAY
41771: PPUSH
41772: LD_INT 34
41774: PUSH
41775: LD_INT 31
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 58
41784: PUSH
41785: EMPTY
41786: LIST
41787: PUSH
41788: EMPTY
41789: LIST
41790: LIST
41791: PPUSH
41792: CALL_OW 72
41796: PUSH
41797: LD_INT 1
41799: ARRAY
41800: PPUSH
41801: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41805: LD_VAR 0 3
41809: PPUSH
41810: CALL_OW 310
41814: NOT
41815: PUSH
41816: LD_VAR 0 3
41820: PPUSH
41821: CALL_OW 310
41825: PPUSH
41826: CALL_OW 266
41830: PUSH
41831: LD_INT 36
41833: NONEQUAL
41834: PUSH
41835: LD_VAR 0 3
41839: PPUSH
41840: CALL 90746 0 1
41844: NOT
41845: AND
41846: OR
41847: IFFALSE 41983
// begin if IsInUnit ( j ) then
41849: LD_VAR 0 3
41853: PPUSH
41854: CALL_OW 310
41858: IFFALSE 41869
// ComExitBuilding ( j ) ;
41860: LD_VAR 0 3
41864: PPUSH
41865: CALL_OW 122
// ct := 0 ;
41869: LD_ADDR_VAR 0 8
41873: PUSH
41874: LD_INT 0
41876: ST_TO_ADDR
// for k in x do
41877: LD_ADDR_VAR 0 4
41881: PUSH
41882: LD_VAR 0 11
41886: PUSH
41887: FOR_IN
41888: IFFALSE 41961
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
41890: LD_VAR 0 4
41894: PPUSH
41895: CALL_OW 264
41899: PUSH
41900: LD_INT 31
41902: EQUAL
41903: PUSH
41904: LD_VAR 0 4
41908: PPUSH
41909: CALL_OW 311
41913: NOT
41914: AND
41915: PUSH
41916: LD_VAR 0 4
41920: PPUSH
41921: CALL_OW 266
41925: PUSH
41926: LD_INT 36
41928: EQUAL
41929: PUSH
41930: LD_VAR 0 4
41934: PPUSH
41935: CALL_OW 313
41939: PUSH
41940: LD_INT 3
41942: LESS
41943: AND
41944: OR
41945: IFFALSE 41959
// begin ct := k ;
41947: LD_ADDR_VAR 0 8
41951: PUSH
41952: LD_VAR 0 4
41956: ST_TO_ADDR
// break ;
41957: GO 41961
// end ;
41959: GO 41887
41961: POP
41962: POP
// if ct then
41963: LD_VAR 0 8
41967: IFFALSE 41983
// ComEnterUnit ( j , ct ) ;
41969: LD_VAR 0 3
41973: PPUSH
41974: LD_VAR 0 8
41978: PPUSH
41979: CALL_OW 120
// end ; end ;
41983: GO 41618
41985: POP
41986: POP
// places := 0 ;
41987: LD_ADDR_VAR 0 5
41991: PUSH
41992: LD_INT 0
41994: ST_TO_ADDR
// for j = 1 to x do
41995: LD_ADDR_VAR 0 3
41999: PUSH
42000: DOUBLE
42001: LD_INT 1
42003: DEC
42004: ST_TO_ADDR
42005: LD_VAR 0 11
42009: PUSH
42010: FOR_TO
42011: IFFALSE 42087
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42013: LD_VAR 0 11
42017: PUSH
42018: LD_VAR 0 3
42022: ARRAY
42023: PPUSH
42024: CALL_OW 264
42028: PUSH
42029: LD_INT 31
42031: EQUAL
42032: IFFALSE 42050
// places := places + 1 else
42034: LD_ADDR_VAR 0 5
42038: PUSH
42039: LD_VAR 0 5
42043: PUSH
42044: LD_INT 1
42046: PLUS
42047: ST_TO_ADDR
42048: GO 42085
// if GetBType ( x [ j ] ) = b_control_tower then
42050: LD_VAR 0 11
42054: PUSH
42055: LD_VAR 0 3
42059: ARRAY
42060: PPUSH
42061: CALL_OW 266
42065: PUSH
42066: LD_INT 36
42068: EQUAL
42069: IFFALSE 42085
// places := places + 3 ;
42071: LD_ADDR_VAR 0 5
42075: PUSH
42076: LD_VAR 0 5
42080: PUSH
42081: LD_INT 3
42083: PLUS
42084: ST_TO_ADDR
42085: GO 42010
42087: POP
42088: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42089: LD_VAR 0 5
42093: PUSH
42094: LD_INT 0
42096: EQUAL
42097: PUSH
42098: LD_VAR 0 5
42102: PUSH
42103: LD_EXP 114
42107: PUSH
42108: LD_VAR 0 2
42112: ARRAY
42113: LESSEQUAL
42114: OR
42115: IFFALSE 42119
// continue ;
42117: GO 41369
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42119: LD_ADDR_VAR 0 6
42123: PUSH
42124: LD_EXP 74
42128: PUSH
42129: LD_VAR 0 2
42133: ARRAY
42134: PPUSH
42135: LD_INT 25
42137: PUSH
42138: LD_INT 3
42140: PUSH
42141: EMPTY
42142: LIST
42143: LIST
42144: PPUSH
42145: CALL_OW 72
42149: PUSH
42150: LD_EXP 114
42154: PUSH
42155: LD_VAR 0 2
42159: ARRAY
42160: DIFF
42161: PPUSH
42162: LD_INT 3
42164: PPUSH
42165: CALL 91646 0 2
42169: ST_TO_ADDR
// for j in tmp do
42170: LD_ADDR_VAR 0 3
42174: PUSH
42175: LD_VAR 0 6
42179: PUSH
42180: FOR_IN
42181: IFFALSE 42216
// if GetTag ( j ) > 0 then
42183: LD_VAR 0 3
42187: PPUSH
42188: CALL_OW 110
42192: PUSH
42193: LD_INT 0
42195: GREATER
42196: IFFALSE 42214
// tmp := tmp diff j ;
42198: LD_ADDR_VAR 0 6
42202: PUSH
42203: LD_VAR 0 6
42207: PUSH
42208: LD_VAR 0 3
42212: DIFF
42213: ST_TO_ADDR
42214: GO 42180
42216: POP
42217: POP
// if not tmp then
42218: LD_VAR 0 6
42222: NOT
42223: IFFALSE 42227
// continue ;
42225: GO 41369
// if places then
42227: LD_VAR 0 5
42231: IFFALSE 42290
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42233: LD_ADDR_EXP 114
42237: PUSH
42238: LD_EXP 114
42242: PPUSH
42243: LD_VAR 0 2
42247: PPUSH
42248: LD_EXP 114
42252: PUSH
42253: LD_VAR 0 2
42257: ARRAY
42258: PUSH
42259: LD_VAR 0 6
42263: PUSH
42264: LD_INT 1
42266: ARRAY
42267: UNION
42268: PPUSH
42269: CALL_OW 1
42273: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42274: LD_VAR 0 6
42278: PUSH
42279: LD_INT 1
42281: ARRAY
42282: PPUSH
42283: LD_INT 126
42285: PPUSH
42286: CALL_OW 109
// end ; end ;
42290: GO 41369
42292: POP
42293: POP
// end ;
42294: LD_VAR 0 1
42298: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42299: LD_INT 0
42301: PPUSH
42302: PPUSH
42303: PPUSH
42304: PPUSH
42305: PPUSH
42306: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42307: LD_VAR 0 1
42311: NOT
42312: PUSH
42313: LD_VAR 0 2
42317: NOT
42318: OR
42319: PUSH
42320: LD_VAR 0 3
42324: NOT
42325: OR
42326: PUSH
42327: LD_VAR 0 4
42331: PUSH
42332: LD_INT 1
42334: PUSH
42335: LD_INT 2
42337: PUSH
42338: LD_INT 3
42340: PUSH
42341: LD_INT 4
42343: PUSH
42344: LD_INT 5
42346: PUSH
42347: LD_INT 8
42349: PUSH
42350: LD_INT 9
42352: PUSH
42353: LD_INT 15
42355: PUSH
42356: LD_INT 16
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: LIST
42363: LIST
42364: LIST
42365: LIST
42366: LIST
42367: LIST
42368: LIST
42369: IN
42370: NOT
42371: OR
42372: IFFALSE 42376
// exit ;
42374: GO 43276
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42376: LD_ADDR_VAR 0 2
42380: PUSH
42381: LD_VAR 0 2
42385: PPUSH
42386: LD_INT 21
42388: PUSH
42389: LD_INT 3
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PUSH
42396: LD_INT 24
42398: PUSH
42399: LD_INT 250
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PPUSH
42410: CALL_OW 72
42414: ST_TO_ADDR
// case class of 1 , 15 :
42415: LD_VAR 0 4
42419: PUSH
42420: LD_INT 1
42422: DOUBLE
42423: EQUAL
42424: IFTRUE 42434
42426: LD_INT 15
42428: DOUBLE
42429: EQUAL
42430: IFTRUE 42434
42432: GO 42519
42434: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42435: LD_ADDR_VAR 0 8
42439: PUSH
42440: LD_VAR 0 2
42444: PPUSH
42445: LD_INT 2
42447: PUSH
42448: LD_INT 30
42450: PUSH
42451: LD_INT 32
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 30
42460: PUSH
42461: LD_INT 31
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: LIST
42472: PPUSH
42473: CALL_OW 72
42477: PUSH
42478: LD_VAR 0 2
42482: PPUSH
42483: LD_INT 2
42485: PUSH
42486: LD_INT 30
42488: PUSH
42489: LD_INT 4
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: PUSH
42496: LD_INT 30
42498: PUSH
42499: LD_INT 5
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: LIST
42510: PPUSH
42511: CALL_OW 72
42515: ADD
42516: ST_TO_ADDR
42517: GO 42765
42519: LD_INT 2
42521: DOUBLE
42522: EQUAL
42523: IFTRUE 42533
42525: LD_INT 16
42527: DOUBLE
42528: EQUAL
42529: IFTRUE 42533
42531: GO 42579
42533: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42534: LD_ADDR_VAR 0 8
42538: PUSH
42539: LD_VAR 0 2
42543: PPUSH
42544: LD_INT 2
42546: PUSH
42547: LD_INT 30
42549: PUSH
42550: LD_INT 0
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 30
42559: PUSH
42560: LD_INT 1
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: LIST
42571: PPUSH
42572: CALL_OW 72
42576: ST_TO_ADDR
42577: GO 42765
42579: LD_INT 3
42581: DOUBLE
42582: EQUAL
42583: IFTRUE 42587
42585: GO 42633
42587: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42588: LD_ADDR_VAR 0 8
42592: PUSH
42593: LD_VAR 0 2
42597: PPUSH
42598: LD_INT 2
42600: PUSH
42601: LD_INT 30
42603: PUSH
42604: LD_INT 2
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 30
42613: PUSH
42614: LD_INT 3
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: LIST
42625: PPUSH
42626: CALL_OW 72
42630: ST_TO_ADDR
42631: GO 42765
42633: LD_INT 4
42635: DOUBLE
42636: EQUAL
42637: IFTRUE 42641
42639: GO 42698
42641: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42642: LD_ADDR_VAR 0 8
42646: PUSH
42647: LD_VAR 0 2
42651: PPUSH
42652: LD_INT 2
42654: PUSH
42655: LD_INT 30
42657: PUSH
42658: LD_INT 6
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: PUSH
42665: LD_INT 30
42667: PUSH
42668: LD_INT 7
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 30
42677: PUSH
42678: LD_INT 8
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: LIST
42689: LIST
42690: PPUSH
42691: CALL_OW 72
42695: ST_TO_ADDR
42696: GO 42765
42698: LD_INT 5
42700: DOUBLE
42701: EQUAL
42702: IFTRUE 42718
42704: LD_INT 8
42706: DOUBLE
42707: EQUAL
42708: IFTRUE 42718
42710: LD_INT 9
42712: DOUBLE
42713: EQUAL
42714: IFTRUE 42718
42716: GO 42764
42718: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42719: LD_ADDR_VAR 0 8
42723: PUSH
42724: LD_VAR 0 2
42728: PPUSH
42729: LD_INT 2
42731: PUSH
42732: LD_INT 30
42734: PUSH
42735: LD_INT 4
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: LD_INT 30
42744: PUSH
42745: LD_INT 5
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: LIST
42756: PPUSH
42757: CALL_OW 72
42761: ST_TO_ADDR
42762: GO 42765
42764: POP
// if not tmp then
42765: LD_VAR 0 8
42769: NOT
42770: IFFALSE 42774
// exit ;
42772: GO 43276
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42774: LD_VAR 0 4
42778: PUSH
42779: LD_INT 1
42781: PUSH
42782: LD_INT 15
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: IN
42789: PUSH
42790: LD_EXP 83
42794: PUSH
42795: LD_VAR 0 1
42799: ARRAY
42800: AND
42801: IFFALSE 42957
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42803: LD_ADDR_VAR 0 9
42807: PUSH
42808: LD_EXP 83
42812: PUSH
42813: LD_VAR 0 1
42817: ARRAY
42818: PUSH
42819: LD_INT 1
42821: ARRAY
42822: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42823: LD_VAR 0 9
42827: PUSH
42828: LD_EXP 84
42832: PUSH
42833: LD_VAR 0 1
42837: ARRAY
42838: IN
42839: NOT
42840: IFFALSE 42955
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42842: LD_ADDR_EXP 84
42846: PUSH
42847: LD_EXP 84
42851: PPUSH
42852: LD_VAR 0 1
42856: PUSH
42857: LD_EXP 84
42861: PUSH
42862: LD_VAR 0 1
42866: ARRAY
42867: PUSH
42868: LD_INT 1
42870: PLUS
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PPUSH
42876: LD_VAR 0 9
42880: PPUSH
42881: CALL 57398 0 3
42885: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
42886: LD_ADDR_EXP 83
42890: PUSH
42891: LD_EXP 83
42895: PPUSH
42896: LD_VAR 0 1
42900: PPUSH
42901: LD_EXP 83
42905: PUSH
42906: LD_VAR 0 1
42910: ARRAY
42911: PUSH
42912: LD_VAR 0 9
42916: DIFF
42917: PPUSH
42918: CALL_OW 1
42922: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
42923: LD_VAR 0 3
42927: PPUSH
42928: LD_EXP 84
42932: PUSH
42933: LD_VAR 0 1
42937: ARRAY
42938: PUSH
42939: LD_EXP 84
42943: PUSH
42944: LD_VAR 0 1
42948: ARRAY
42949: ARRAY
42950: PPUSH
42951: CALL_OW 120
// end ; exit ;
42955: GO 43276
// end ; if tmp > 1 then
42957: LD_VAR 0 8
42961: PUSH
42962: LD_INT 1
42964: GREATER
42965: IFFALSE 43069
// for i = 2 to tmp do
42967: LD_ADDR_VAR 0 6
42971: PUSH
42972: DOUBLE
42973: LD_INT 2
42975: DEC
42976: ST_TO_ADDR
42977: LD_VAR 0 8
42981: PUSH
42982: FOR_TO
42983: IFFALSE 43067
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
42985: LD_VAR 0 8
42989: PUSH
42990: LD_VAR 0 6
42994: ARRAY
42995: PPUSH
42996: CALL_OW 461
43000: PUSH
43001: LD_INT 6
43003: EQUAL
43004: IFFALSE 43065
// begin x := tmp [ i ] ;
43006: LD_ADDR_VAR 0 9
43010: PUSH
43011: LD_VAR 0 8
43015: PUSH
43016: LD_VAR 0 6
43020: ARRAY
43021: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43022: LD_ADDR_VAR 0 8
43026: PUSH
43027: LD_VAR 0 8
43031: PPUSH
43032: LD_VAR 0 6
43036: PPUSH
43037: CALL_OW 3
43041: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43042: LD_ADDR_VAR 0 8
43046: PUSH
43047: LD_VAR 0 8
43051: PPUSH
43052: LD_INT 1
43054: PPUSH
43055: LD_VAR 0 9
43059: PPUSH
43060: CALL_OW 2
43064: ST_TO_ADDR
// end ;
43065: GO 42982
43067: POP
43068: POP
// for i in tmp do
43069: LD_ADDR_VAR 0 6
43073: PUSH
43074: LD_VAR 0 8
43078: PUSH
43079: FOR_IN
43080: IFFALSE 43149
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43082: LD_VAR 0 6
43086: PPUSH
43087: CALL_OW 313
43091: PUSH
43092: LD_INT 6
43094: LESS
43095: PUSH
43096: LD_VAR 0 6
43100: PPUSH
43101: CALL_OW 266
43105: PUSH
43106: LD_INT 31
43108: PUSH
43109: LD_INT 32
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: IN
43116: NOT
43117: AND
43118: PUSH
43119: LD_VAR 0 6
43123: PPUSH
43124: CALL_OW 313
43128: PUSH
43129: LD_INT 0
43131: EQUAL
43132: OR
43133: IFFALSE 43147
// begin j := i ;
43135: LD_ADDR_VAR 0 7
43139: PUSH
43140: LD_VAR 0 6
43144: ST_TO_ADDR
// break ;
43145: GO 43149
// end ; end ;
43147: GO 43079
43149: POP
43150: POP
// if j then
43151: LD_VAR 0 7
43155: IFFALSE 43173
// ComEnterUnit ( unit , j ) else
43157: LD_VAR 0 3
43161: PPUSH
43162: LD_VAR 0 7
43166: PPUSH
43167: CALL_OW 120
43171: GO 43276
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43173: LD_ADDR_VAR 0 10
43177: PUSH
43178: LD_VAR 0 2
43182: PPUSH
43183: LD_INT 2
43185: PUSH
43186: LD_INT 30
43188: PUSH
43189: LD_INT 0
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: LD_INT 30
43198: PUSH
43199: LD_INT 1
43201: PUSH
43202: EMPTY
43203: LIST
43204: LIST
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: LIST
43210: PPUSH
43211: CALL_OW 72
43215: ST_TO_ADDR
// if depot then
43216: LD_VAR 0 10
43220: IFFALSE 43276
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43222: LD_ADDR_VAR 0 10
43226: PUSH
43227: LD_VAR 0 10
43231: PPUSH
43232: LD_VAR 0 3
43236: PPUSH
43237: CALL_OW 74
43241: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43242: LD_VAR 0 3
43246: PPUSH
43247: LD_VAR 0 10
43251: PPUSH
43252: CALL_OW 296
43256: PUSH
43257: LD_INT 10
43259: GREATER
43260: IFFALSE 43276
// ComStandNearbyBuilding ( unit , depot ) ;
43262: LD_VAR 0 3
43266: PPUSH
43267: LD_VAR 0 10
43271: PPUSH
43272: CALL 51690 0 2
// end ; end ; end ;
43276: LD_VAR 0 5
43280: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43281: LD_INT 0
43283: PPUSH
43284: PPUSH
43285: PPUSH
43286: PPUSH
// if not mc_bases then
43287: LD_EXP 74
43291: NOT
43292: IFFALSE 43296
// exit ;
43294: GO 43535
// for i = 1 to mc_bases do
43296: LD_ADDR_VAR 0 2
43300: PUSH
43301: DOUBLE
43302: LD_INT 1
43304: DEC
43305: ST_TO_ADDR
43306: LD_EXP 74
43310: PUSH
43311: FOR_TO
43312: IFFALSE 43533
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43314: LD_ADDR_VAR 0 4
43318: PUSH
43319: LD_EXP 74
43323: PUSH
43324: LD_VAR 0 2
43328: ARRAY
43329: PPUSH
43330: LD_INT 21
43332: PUSH
43333: LD_INT 1
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PPUSH
43340: CALL_OW 72
43344: PUSH
43345: LD_EXP 103
43349: PUSH
43350: LD_VAR 0 2
43354: ARRAY
43355: UNION
43356: ST_TO_ADDR
// if not tmp then
43357: LD_VAR 0 4
43361: NOT
43362: IFFALSE 43366
// continue ;
43364: GO 43311
// for j in tmp do
43366: LD_ADDR_VAR 0 3
43370: PUSH
43371: LD_VAR 0 4
43375: PUSH
43376: FOR_IN
43377: IFFALSE 43529
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43379: LD_VAR 0 3
43383: PPUSH
43384: CALL_OW 110
43388: NOT
43389: PUSH
43390: LD_VAR 0 3
43394: PPUSH
43395: CALL_OW 314
43399: NOT
43400: AND
43401: PUSH
43402: LD_VAR 0 3
43406: PPUSH
43407: CALL_OW 311
43411: NOT
43412: AND
43413: PUSH
43414: LD_VAR 0 3
43418: PPUSH
43419: CALL_OW 310
43423: NOT
43424: AND
43425: PUSH
43426: LD_VAR 0 3
43430: PUSH
43431: LD_EXP 77
43435: PUSH
43436: LD_VAR 0 2
43440: ARRAY
43441: PUSH
43442: LD_INT 1
43444: ARRAY
43445: IN
43446: NOT
43447: AND
43448: PUSH
43449: LD_VAR 0 3
43453: PUSH
43454: LD_EXP 77
43458: PUSH
43459: LD_VAR 0 2
43463: ARRAY
43464: PUSH
43465: LD_INT 2
43467: ARRAY
43468: IN
43469: NOT
43470: AND
43471: PUSH
43472: LD_VAR 0 3
43476: PUSH
43477: LD_EXP 86
43481: PUSH
43482: LD_VAR 0 2
43486: ARRAY
43487: IN
43488: NOT
43489: AND
43490: IFFALSE 43527
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43492: LD_VAR 0 2
43496: PPUSH
43497: LD_EXP 74
43501: PUSH
43502: LD_VAR 0 2
43506: ARRAY
43507: PPUSH
43508: LD_VAR 0 3
43512: PPUSH
43513: LD_VAR 0 3
43517: PPUSH
43518: CALL_OW 257
43522: PPUSH
43523: CALL 42299 0 4
// end ;
43527: GO 43376
43529: POP
43530: POP
// end ;
43531: GO 43311
43533: POP
43534: POP
// end ;
43535: LD_VAR 0 1
43539: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43540: LD_INT 0
43542: PPUSH
43543: PPUSH
43544: PPUSH
43545: PPUSH
43546: PPUSH
43547: PPUSH
// if not mc_bases [ base ] then
43548: LD_EXP 74
43552: PUSH
43553: LD_VAR 0 1
43557: ARRAY
43558: NOT
43559: IFFALSE 43563
// exit ;
43561: GO 43745
// tmp := [ ] ;
43563: LD_ADDR_VAR 0 6
43567: PUSH
43568: EMPTY
43569: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43570: LD_ADDR_VAR 0 7
43574: PUSH
43575: LD_VAR 0 3
43579: PPUSH
43580: LD_INT 0
43582: PPUSH
43583: CALL_OW 517
43587: ST_TO_ADDR
// if not list then
43588: LD_VAR 0 7
43592: NOT
43593: IFFALSE 43597
// exit ;
43595: GO 43745
// for i = 1 to amount do
43597: LD_ADDR_VAR 0 5
43601: PUSH
43602: DOUBLE
43603: LD_INT 1
43605: DEC
43606: ST_TO_ADDR
43607: LD_VAR 0 2
43611: PUSH
43612: FOR_TO
43613: IFFALSE 43693
// begin x := rand ( 1 , list [ 1 ] ) ;
43615: LD_ADDR_VAR 0 8
43619: PUSH
43620: LD_INT 1
43622: PPUSH
43623: LD_VAR 0 7
43627: PUSH
43628: LD_INT 1
43630: ARRAY
43631: PPUSH
43632: CALL_OW 12
43636: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43637: LD_ADDR_VAR 0 6
43641: PUSH
43642: LD_VAR 0 6
43646: PPUSH
43647: LD_VAR 0 5
43651: PPUSH
43652: LD_VAR 0 7
43656: PUSH
43657: LD_INT 1
43659: ARRAY
43660: PUSH
43661: LD_VAR 0 8
43665: ARRAY
43666: PUSH
43667: LD_VAR 0 7
43671: PUSH
43672: LD_INT 2
43674: ARRAY
43675: PUSH
43676: LD_VAR 0 8
43680: ARRAY
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PPUSH
43686: CALL_OW 1
43690: ST_TO_ADDR
// end ;
43691: GO 43612
43693: POP
43694: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43695: LD_ADDR_EXP 87
43699: PUSH
43700: LD_EXP 87
43704: PPUSH
43705: LD_VAR 0 1
43709: PPUSH
43710: LD_VAR 0 6
43714: PPUSH
43715: CALL_OW 1
43719: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43720: LD_ADDR_EXP 89
43724: PUSH
43725: LD_EXP 89
43729: PPUSH
43730: LD_VAR 0 1
43734: PPUSH
43735: LD_VAR 0 3
43739: PPUSH
43740: CALL_OW 1
43744: ST_TO_ADDR
// end ;
43745: LD_VAR 0 4
43749: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
43750: LD_INT 0
43752: PPUSH
// if not mc_bases [ base ] then
43753: LD_EXP 74
43757: PUSH
43758: LD_VAR 0 1
43762: ARRAY
43763: NOT
43764: IFFALSE 43768
// exit ;
43766: GO 43793
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43768: LD_ADDR_EXP 79
43772: PUSH
43773: LD_EXP 79
43777: PPUSH
43778: LD_VAR 0 1
43782: PPUSH
43783: LD_VAR 0 2
43787: PPUSH
43788: CALL_OW 1
43792: ST_TO_ADDR
// end ;
43793: LD_VAR 0 3
43797: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43798: LD_INT 0
43800: PPUSH
// if not mc_bases [ base ] then
43801: LD_EXP 74
43805: PUSH
43806: LD_VAR 0 1
43810: ARRAY
43811: NOT
43812: IFFALSE 43816
// exit ;
43814: GO 43853
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43816: LD_ADDR_EXP 79
43820: PUSH
43821: LD_EXP 79
43825: PPUSH
43826: LD_VAR 0 1
43830: PPUSH
43831: LD_EXP 79
43835: PUSH
43836: LD_VAR 0 1
43840: ARRAY
43841: PUSH
43842: LD_VAR 0 2
43846: UNION
43847: PPUSH
43848: CALL_OW 1
43852: ST_TO_ADDR
// end ;
43853: LD_VAR 0 3
43857: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
43858: LD_INT 0
43860: PPUSH
// if not mc_bases [ base ] then
43861: LD_EXP 74
43865: PUSH
43866: LD_VAR 0 1
43870: ARRAY
43871: NOT
43872: IFFALSE 43876
// exit ;
43874: GO 43901
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
43876: LD_ADDR_EXP 95
43880: PUSH
43881: LD_EXP 95
43885: PPUSH
43886: LD_VAR 0 1
43890: PPUSH
43891: LD_VAR 0 2
43895: PPUSH
43896: CALL_OW 1
43900: ST_TO_ADDR
// end ;
43901: LD_VAR 0 3
43905: RET
// export function MC_InsertProduceList ( base , components ) ; begin
43906: LD_INT 0
43908: PPUSH
// if not mc_bases [ base ] then
43909: LD_EXP 74
43913: PUSH
43914: LD_VAR 0 1
43918: ARRAY
43919: NOT
43920: IFFALSE 43924
// exit ;
43922: GO 43961
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
43924: LD_ADDR_EXP 95
43928: PUSH
43929: LD_EXP 95
43933: PPUSH
43934: LD_VAR 0 1
43938: PPUSH
43939: LD_EXP 95
43943: PUSH
43944: LD_VAR 0 1
43948: ARRAY
43949: PUSH
43950: LD_VAR 0 2
43954: ADD
43955: PPUSH
43956: CALL_OW 1
43960: ST_TO_ADDR
// end ;
43961: LD_VAR 0 3
43965: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
43966: LD_INT 0
43968: PPUSH
// if not mc_bases [ base ] then
43969: LD_EXP 74
43973: PUSH
43974: LD_VAR 0 1
43978: ARRAY
43979: NOT
43980: IFFALSE 43984
// exit ;
43982: GO 44038
// mc_defender := Replace ( mc_defender , base , deflist ) ;
43984: LD_ADDR_EXP 96
43988: PUSH
43989: LD_EXP 96
43993: PPUSH
43994: LD_VAR 0 1
43998: PPUSH
43999: LD_VAR 0 2
44003: PPUSH
44004: CALL_OW 1
44008: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44009: LD_ADDR_EXP 85
44013: PUSH
44014: LD_EXP 85
44018: PPUSH
44019: LD_VAR 0 1
44023: PPUSH
44024: LD_VAR 0 2
44028: PUSH
44029: LD_INT 0
44031: PLUS
44032: PPUSH
44033: CALL_OW 1
44037: ST_TO_ADDR
// end ;
44038: LD_VAR 0 3
44042: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44043: LD_INT 0
44045: PPUSH
// if not mc_bases [ base ] then
44046: LD_EXP 74
44050: PUSH
44051: LD_VAR 0 1
44055: ARRAY
44056: NOT
44057: IFFALSE 44061
// exit ;
44059: GO 44086
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44061: LD_ADDR_EXP 85
44065: PUSH
44066: LD_EXP 85
44070: PPUSH
44071: LD_VAR 0 1
44075: PPUSH
44076: LD_VAR 0 2
44080: PPUSH
44081: CALL_OW 1
44085: ST_TO_ADDR
// end ;
44086: LD_VAR 0 3
44090: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44091: LD_INT 0
44093: PPUSH
44094: PPUSH
44095: PPUSH
44096: PPUSH
// if not mc_bases [ base ] then
44097: LD_EXP 74
44101: PUSH
44102: LD_VAR 0 1
44106: ARRAY
44107: NOT
44108: IFFALSE 44112
// exit ;
44110: GO 44177
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44112: LD_ADDR_EXP 94
44116: PUSH
44117: LD_EXP 94
44121: PPUSH
44122: LD_VAR 0 1
44126: PUSH
44127: LD_EXP 94
44131: PUSH
44132: LD_VAR 0 1
44136: ARRAY
44137: PUSH
44138: LD_INT 1
44140: PLUS
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PPUSH
44146: LD_VAR 0 1
44150: PUSH
44151: LD_VAR 0 2
44155: PUSH
44156: LD_VAR 0 3
44160: PUSH
44161: LD_VAR 0 4
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: LIST
44170: LIST
44171: PPUSH
44172: CALL 57398 0 3
44176: ST_TO_ADDR
// end ;
44177: LD_VAR 0 5
44181: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44182: LD_INT 0
44184: PPUSH
// if not mc_bases [ base ] then
44185: LD_EXP 74
44189: PUSH
44190: LD_VAR 0 1
44194: ARRAY
44195: NOT
44196: IFFALSE 44200
// exit ;
44198: GO 44225
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44200: LD_ADDR_EXP 111
44204: PUSH
44205: LD_EXP 111
44209: PPUSH
44210: LD_VAR 0 1
44214: PPUSH
44215: LD_VAR 0 2
44219: PPUSH
44220: CALL_OW 1
44224: ST_TO_ADDR
// end ;
44225: LD_VAR 0 3
44229: RET
// export function MC_GetMinesField ( base ) ; begin
44230: LD_INT 0
44232: PPUSH
// result := mc_mines [ base ] ;
44233: LD_ADDR_VAR 0 2
44237: PUSH
44238: LD_EXP 87
44242: PUSH
44243: LD_VAR 0 1
44247: ARRAY
44248: ST_TO_ADDR
// end ;
44249: LD_VAR 0 2
44253: RET
// export function MC_GetProduceList ( base ) ; begin
44254: LD_INT 0
44256: PPUSH
// result := mc_produce [ base ] ;
44257: LD_ADDR_VAR 0 2
44261: PUSH
44262: LD_EXP 95
44266: PUSH
44267: LD_VAR 0 1
44271: ARRAY
44272: ST_TO_ADDR
// end ;
44273: LD_VAR 0 2
44277: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44278: LD_INT 0
44280: PPUSH
44281: PPUSH
// if not mc_bases then
44282: LD_EXP 74
44286: NOT
44287: IFFALSE 44291
// exit ;
44289: GO 44356
// if mc_bases [ base ] then
44291: LD_EXP 74
44295: PUSH
44296: LD_VAR 0 1
44300: ARRAY
44301: IFFALSE 44356
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44303: LD_ADDR_VAR 0 3
44307: PUSH
44308: LD_EXP 74
44312: PUSH
44313: LD_VAR 0 1
44317: ARRAY
44318: PPUSH
44319: LD_INT 30
44321: PUSH
44322: LD_VAR 0 2
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: PPUSH
44331: CALL_OW 72
44335: ST_TO_ADDR
// if result then
44336: LD_VAR 0 3
44340: IFFALSE 44356
// result := result [ 1 ] ;
44342: LD_ADDR_VAR 0 3
44346: PUSH
44347: LD_VAR 0 3
44351: PUSH
44352: LD_INT 1
44354: ARRAY
44355: ST_TO_ADDR
// end ; end ;
44356: LD_VAR 0 3
44360: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44361: LD_INT 0
44363: PPUSH
44364: PPUSH
// if not mc_bases then
44365: LD_EXP 74
44369: NOT
44370: IFFALSE 44374
// exit ;
44372: GO 44419
// if mc_bases [ base ] then
44374: LD_EXP 74
44378: PUSH
44379: LD_VAR 0 1
44383: ARRAY
44384: IFFALSE 44419
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44386: LD_ADDR_VAR 0 3
44390: PUSH
44391: LD_EXP 74
44395: PUSH
44396: LD_VAR 0 1
44400: ARRAY
44401: PPUSH
44402: LD_INT 30
44404: PUSH
44405: LD_VAR 0 2
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PPUSH
44414: CALL_OW 72
44418: ST_TO_ADDR
// end ;
44419: LD_VAR 0 3
44423: RET
// export function MC_SetTame ( base , area ) ; begin
44424: LD_INT 0
44426: PPUSH
// if not mc_bases or not base then
44427: LD_EXP 74
44431: NOT
44432: PUSH
44433: LD_VAR 0 1
44437: NOT
44438: OR
44439: IFFALSE 44443
// exit ;
44441: GO 44468
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44443: LD_ADDR_EXP 102
44447: PUSH
44448: LD_EXP 102
44452: PPUSH
44453: LD_VAR 0 1
44457: PPUSH
44458: LD_VAR 0 2
44462: PPUSH
44463: CALL_OW 1
44467: ST_TO_ADDR
// end ;
44468: LD_VAR 0 3
44472: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44473: LD_INT 0
44475: PPUSH
44476: PPUSH
// if not mc_bases or not base then
44477: LD_EXP 74
44481: NOT
44482: PUSH
44483: LD_VAR 0 1
44487: NOT
44488: OR
44489: IFFALSE 44493
// exit ;
44491: GO 44595
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44493: LD_ADDR_VAR 0 4
44497: PUSH
44498: LD_EXP 74
44502: PUSH
44503: LD_VAR 0 1
44507: ARRAY
44508: PPUSH
44509: LD_INT 30
44511: PUSH
44512: LD_VAR 0 2
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PPUSH
44521: CALL_OW 72
44525: ST_TO_ADDR
// if not tmp then
44526: LD_VAR 0 4
44530: NOT
44531: IFFALSE 44535
// exit ;
44533: GO 44595
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44535: LD_ADDR_EXP 106
44539: PUSH
44540: LD_EXP 106
44544: PPUSH
44545: LD_VAR 0 1
44549: PPUSH
44550: LD_EXP 106
44554: PUSH
44555: LD_VAR 0 1
44559: ARRAY
44560: PPUSH
44561: LD_EXP 106
44565: PUSH
44566: LD_VAR 0 1
44570: ARRAY
44571: PUSH
44572: LD_INT 1
44574: PLUS
44575: PPUSH
44576: LD_VAR 0 4
44580: PUSH
44581: LD_INT 1
44583: ARRAY
44584: PPUSH
44585: CALL_OW 2
44589: PPUSH
44590: CALL_OW 1
44594: ST_TO_ADDR
// end ;
44595: LD_VAR 0 3
44599: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44600: LD_INT 0
44602: PPUSH
44603: PPUSH
// if not mc_bases or not base or not kinds then
44604: LD_EXP 74
44608: NOT
44609: PUSH
44610: LD_VAR 0 1
44614: NOT
44615: OR
44616: PUSH
44617: LD_VAR 0 2
44621: NOT
44622: OR
44623: IFFALSE 44627
// exit ;
44625: GO 44688
// for i in kinds do
44627: LD_ADDR_VAR 0 4
44631: PUSH
44632: LD_VAR 0 2
44636: PUSH
44637: FOR_IN
44638: IFFALSE 44686
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44640: LD_ADDR_EXP 108
44644: PUSH
44645: LD_EXP 108
44649: PPUSH
44650: LD_VAR 0 1
44654: PUSH
44655: LD_EXP 108
44659: PUSH
44660: LD_VAR 0 1
44664: ARRAY
44665: PUSH
44666: LD_INT 1
44668: PLUS
44669: PUSH
44670: EMPTY
44671: LIST
44672: LIST
44673: PPUSH
44674: LD_VAR 0 4
44678: PPUSH
44679: CALL 57398 0 3
44683: ST_TO_ADDR
44684: GO 44637
44686: POP
44687: POP
// end ;
44688: LD_VAR 0 3
44692: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44693: LD_INT 0
44695: PPUSH
// if not mc_bases or not base or not areas then
44696: LD_EXP 74
44700: NOT
44701: PUSH
44702: LD_VAR 0 1
44706: NOT
44707: OR
44708: PUSH
44709: LD_VAR 0 2
44713: NOT
44714: OR
44715: IFFALSE 44719
// exit ;
44717: GO 44744
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44719: LD_ADDR_EXP 92
44723: PUSH
44724: LD_EXP 92
44728: PPUSH
44729: LD_VAR 0 1
44733: PPUSH
44734: LD_VAR 0 2
44738: PPUSH
44739: CALL_OW 1
44743: ST_TO_ADDR
// end ;
44744: LD_VAR 0 3
44748: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
44749: LD_INT 0
44751: PPUSH
// if not mc_bases or not base or not teleports_exit then
44752: LD_EXP 74
44756: NOT
44757: PUSH
44758: LD_VAR 0 1
44762: NOT
44763: OR
44764: PUSH
44765: LD_VAR 0 2
44769: NOT
44770: OR
44771: IFFALSE 44775
// exit ;
44773: GO 44800
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44775: LD_ADDR_EXP 109
44779: PUSH
44780: LD_EXP 109
44784: PPUSH
44785: LD_VAR 0 1
44789: PPUSH
44790: LD_VAR 0 2
44794: PPUSH
44795: CALL_OW 1
44799: ST_TO_ADDR
// end ;
44800: LD_VAR 0 3
44804: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44805: LD_INT 0
44807: PPUSH
44808: PPUSH
44809: PPUSH
// if not mc_bases or not base or not ext_list then
44810: LD_EXP 74
44814: NOT
44815: PUSH
44816: LD_VAR 0 1
44820: NOT
44821: OR
44822: PUSH
44823: LD_VAR 0 5
44827: NOT
44828: OR
44829: IFFALSE 44833
// exit ;
44831: GO 45006
// tmp := GetFacExtXYD ( x , y , d ) ;
44833: LD_ADDR_VAR 0 8
44837: PUSH
44838: LD_VAR 0 2
44842: PPUSH
44843: LD_VAR 0 3
44847: PPUSH
44848: LD_VAR 0 4
44852: PPUSH
44853: CALL 90776 0 3
44857: ST_TO_ADDR
// if not tmp then
44858: LD_VAR 0 8
44862: NOT
44863: IFFALSE 44867
// exit ;
44865: GO 45006
// for i in tmp do
44867: LD_ADDR_VAR 0 7
44871: PUSH
44872: LD_VAR 0 8
44876: PUSH
44877: FOR_IN
44878: IFFALSE 45004
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
44880: LD_ADDR_EXP 79
44884: PUSH
44885: LD_EXP 79
44889: PPUSH
44890: LD_VAR 0 1
44894: PPUSH
44895: LD_EXP 79
44899: PUSH
44900: LD_VAR 0 1
44904: ARRAY
44905: PPUSH
44906: LD_EXP 79
44910: PUSH
44911: LD_VAR 0 1
44915: ARRAY
44916: PUSH
44917: LD_INT 1
44919: PLUS
44920: PPUSH
44921: LD_VAR 0 5
44925: PUSH
44926: LD_INT 1
44928: ARRAY
44929: PUSH
44930: LD_VAR 0 7
44934: PUSH
44935: LD_INT 1
44937: ARRAY
44938: PUSH
44939: LD_VAR 0 7
44943: PUSH
44944: LD_INT 2
44946: ARRAY
44947: PUSH
44948: LD_VAR 0 7
44952: PUSH
44953: LD_INT 3
44955: ARRAY
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: LIST
44961: LIST
44962: PPUSH
44963: CALL_OW 2
44967: PPUSH
44968: CALL_OW 1
44972: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
44973: LD_ADDR_VAR 0 5
44977: PUSH
44978: LD_VAR 0 5
44982: PPUSH
44983: LD_INT 1
44985: PPUSH
44986: CALL_OW 3
44990: ST_TO_ADDR
// if not ext_list then
44991: LD_VAR 0 5
44995: NOT
44996: IFFALSE 45002
// exit ;
44998: POP
44999: POP
45000: GO 45006
// end ;
45002: GO 44877
45004: POP
45005: POP
// end ;
45006: LD_VAR 0 6
45010: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45011: LD_INT 0
45013: PPUSH
// if not mc_bases or not base or not weapon_list then
45014: LD_EXP 74
45018: NOT
45019: PUSH
45020: LD_VAR 0 1
45024: NOT
45025: OR
45026: PUSH
45027: LD_VAR 0 2
45031: NOT
45032: OR
45033: IFFALSE 45037
// exit ;
45035: GO 45062
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45037: LD_ADDR_EXP 113
45041: PUSH
45042: LD_EXP 113
45046: PPUSH
45047: LD_VAR 0 1
45051: PPUSH
45052: LD_VAR 0 2
45056: PPUSH
45057: CALL_OW 1
45061: ST_TO_ADDR
// end ;
45062: LD_VAR 0 3
45066: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45067: LD_INT 0
45069: PPUSH
// if not mc_bases or not base or not tech_list then
45070: LD_EXP 74
45074: NOT
45075: PUSH
45076: LD_VAR 0 1
45080: NOT
45081: OR
45082: PUSH
45083: LD_VAR 0 2
45087: NOT
45088: OR
45089: IFFALSE 45093
// exit ;
45091: GO 45118
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45093: LD_ADDR_EXP 101
45097: PUSH
45098: LD_EXP 101
45102: PPUSH
45103: LD_VAR 0 1
45107: PPUSH
45108: LD_VAR 0 2
45112: PPUSH
45113: CALL_OW 1
45117: ST_TO_ADDR
// end ;
45118: LD_VAR 0 3
45122: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45123: LD_INT 0
45125: PPUSH
// if not mc_bases or not parking_area or not base then
45126: LD_EXP 74
45130: NOT
45131: PUSH
45132: LD_VAR 0 2
45136: NOT
45137: OR
45138: PUSH
45139: LD_VAR 0 1
45143: NOT
45144: OR
45145: IFFALSE 45149
// exit ;
45147: GO 45174
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45149: LD_ADDR_EXP 98
45153: PUSH
45154: LD_EXP 98
45158: PPUSH
45159: LD_VAR 0 1
45163: PPUSH
45164: LD_VAR 0 2
45168: PPUSH
45169: CALL_OW 1
45173: ST_TO_ADDR
// end ;
45174: LD_VAR 0 3
45178: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45179: LD_INT 0
45181: PPUSH
// if not mc_bases or not base or not scan_area then
45182: LD_EXP 74
45186: NOT
45187: PUSH
45188: LD_VAR 0 1
45192: NOT
45193: OR
45194: PUSH
45195: LD_VAR 0 2
45199: NOT
45200: OR
45201: IFFALSE 45205
// exit ;
45203: GO 45230
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45205: LD_ADDR_EXP 99
45209: PUSH
45210: LD_EXP 99
45214: PPUSH
45215: LD_VAR 0 1
45219: PPUSH
45220: LD_VAR 0 2
45224: PPUSH
45225: CALL_OW 1
45229: ST_TO_ADDR
// end ;
45230: LD_VAR 0 3
45234: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45235: LD_INT 0
45237: PPUSH
45238: PPUSH
// if not mc_bases or not base then
45239: LD_EXP 74
45243: NOT
45244: PUSH
45245: LD_VAR 0 1
45249: NOT
45250: OR
45251: IFFALSE 45255
// exit ;
45253: GO 45319
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45255: LD_ADDR_VAR 0 3
45259: PUSH
45260: LD_INT 1
45262: PUSH
45263: LD_INT 2
45265: PUSH
45266: LD_INT 3
45268: PUSH
45269: LD_INT 4
45271: PUSH
45272: LD_INT 11
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45282: LD_ADDR_EXP 101
45286: PUSH
45287: LD_EXP 101
45291: PPUSH
45292: LD_VAR 0 1
45296: PPUSH
45297: LD_EXP 101
45301: PUSH
45302: LD_VAR 0 1
45306: ARRAY
45307: PUSH
45308: LD_VAR 0 3
45312: DIFF
45313: PPUSH
45314: CALL_OW 1
45318: ST_TO_ADDR
// end ;
45319: LD_VAR 0 2
45323: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45324: LD_INT 0
45326: PPUSH
// result := mc_vehicles [ base ] ;
45327: LD_ADDR_VAR 0 3
45331: PUSH
45332: LD_EXP 93
45336: PUSH
45337: LD_VAR 0 1
45341: ARRAY
45342: ST_TO_ADDR
// if onlyCombat then
45343: LD_VAR 0 2
45347: IFFALSE 45512
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45349: LD_ADDR_VAR 0 3
45353: PUSH
45354: LD_VAR 0 3
45358: PUSH
45359: LD_VAR 0 3
45363: PPUSH
45364: LD_INT 2
45366: PUSH
45367: LD_INT 34
45369: PUSH
45370: LD_INT 12
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 34
45379: PUSH
45380: LD_INT 51
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 34
45389: PUSH
45390: LD_EXP 68
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PUSH
45399: LD_INT 34
45401: PUSH
45402: LD_INT 32
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 34
45411: PUSH
45412: LD_INT 13
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 34
45421: PUSH
45422: LD_INT 52
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 34
45431: PUSH
45432: LD_INT 14
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 34
45441: PUSH
45442: LD_INT 53
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 34
45451: PUSH
45452: LD_EXP 67
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: PUSH
45461: LD_INT 34
45463: PUSH
45464: LD_INT 31
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: LD_INT 34
45473: PUSH
45474: LD_INT 48
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: PUSH
45481: LD_INT 34
45483: PUSH
45484: LD_INT 8
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: PPUSH
45506: CALL_OW 72
45510: DIFF
45511: ST_TO_ADDR
// end ; end_of_file
45512: LD_VAR 0 3
45516: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45517: LD_INT 0
45519: PPUSH
45520: PPUSH
45521: PPUSH
// if not mc_bases or not skirmish then
45522: LD_EXP 74
45526: NOT
45527: PUSH
45528: LD_EXP 72
45532: NOT
45533: OR
45534: IFFALSE 45538
// exit ;
45536: GO 45703
// for i = 1 to mc_bases do
45538: LD_ADDR_VAR 0 4
45542: PUSH
45543: DOUBLE
45544: LD_INT 1
45546: DEC
45547: ST_TO_ADDR
45548: LD_EXP 74
45552: PUSH
45553: FOR_TO
45554: IFFALSE 45701
// begin if sci in mc_bases [ i ] then
45556: LD_VAR 0 2
45560: PUSH
45561: LD_EXP 74
45565: PUSH
45566: LD_VAR 0 4
45570: ARRAY
45571: IN
45572: IFFALSE 45699
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45574: LD_ADDR_EXP 103
45578: PUSH
45579: LD_EXP 103
45583: PPUSH
45584: LD_VAR 0 4
45588: PUSH
45589: LD_EXP 103
45593: PUSH
45594: LD_VAR 0 4
45598: ARRAY
45599: PUSH
45600: LD_INT 1
45602: PLUS
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PPUSH
45608: LD_VAR 0 1
45612: PPUSH
45613: CALL 57398 0 3
45617: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45618: LD_ADDR_VAR 0 5
45622: PUSH
45623: LD_EXP 74
45627: PUSH
45628: LD_VAR 0 4
45632: ARRAY
45633: PPUSH
45634: LD_INT 2
45636: PUSH
45637: LD_INT 30
45639: PUSH
45640: LD_INT 0
45642: PUSH
45643: EMPTY
45644: LIST
45645: LIST
45646: PUSH
45647: LD_INT 30
45649: PUSH
45650: LD_INT 1
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: PUSH
45657: EMPTY
45658: LIST
45659: LIST
45660: LIST
45661: PPUSH
45662: CALL_OW 72
45666: PPUSH
45667: LD_VAR 0 1
45671: PPUSH
45672: CALL_OW 74
45676: ST_TO_ADDR
// if tmp then
45677: LD_VAR 0 5
45681: IFFALSE 45697
// ComStandNearbyBuilding ( ape , tmp ) ;
45683: LD_VAR 0 1
45687: PPUSH
45688: LD_VAR 0 5
45692: PPUSH
45693: CALL 51690 0 2
// break ;
45697: GO 45701
// end ; end ;
45699: GO 45553
45701: POP
45702: POP
// end ;
45703: LD_VAR 0 3
45707: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45708: LD_INT 0
45710: PPUSH
45711: PPUSH
45712: PPUSH
// if not mc_bases or not skirmish then
45713: LD_EXP 74
45717: NOT
45718: PUSH
45719: LD_EXP 72
45723: NOT
45724: OR
45725: IFFALSE 45729
// exit ;
45727: GO 45818
// for i = 1 to mc_bases do
45729: LD_ADDR_VAR 0 4
45733: PUSH
45734: DOUBLE
45735: LD_INT 1
45737: DEC
45738: ST_TO_ADDR
45739: LD_EXP 74
45743: PUSH
45744: FOR_TO
45745: IFFALSE 45816
// begin if building in mc_busy_turret_list [ i ] then
45747: LD_VAR 0 1
45751: PUSH
45752: LD_EXP 84
45756: PUSH
45757: LD_VAR 0 4
45761: ARRAY
45762: IN
45763: IFFALSE 45814
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45765: LD_ADDR_VAR 0 5
45769: PUSH
45770: LD_EXP 84
45774: PUSH
45775: LD_VAR 0 4
45779: ARRAY
45780: PUSH
45781: LD_VAR 0 1
45785: DIFF
45786: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45787: LD_ADDR_EXP 84
45791: PUSH
45792: LD_EXP 84
45796: PPUSH
45797: LD_VAR 0 4
45801: PPUSH
45802: LD_VAR 0 5
45806: PPUSH
45807: CALL_OW 1
45811: ST_TO_ADDR
// break ;
45812: GO 45816
// end ; end ;
45814: GO 45744
45816: POP
45817: POP
// end ;
45818: LD_VAR 0 3
45822: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45823: LD_INT 0
45825: PPUSH
45826: PPUSH
45827: PPUSH
// if not mc_bases or not skirmish then
45828: LD_EXP 74
45832: NOT
45833: PUSH
45834: LD_EXP 72
45838: NOT
45839: OR
45840: IFFALSE 45844
// exit ;
45842: GO 46043
// for i = 1 to mc_bases do
45844: LD_ADDR_VAR 0 5
45848: PUSH
45849: DOUBLE
45850: LD_INT 1
45852: DEC
45853: ST_TO_ADDR
45854: LD_EXP 74
45858: PUSH
45859: FOR_TO
45860: IFFALSE 46041
// if building in mc_bases [ i ] then
45862: LD_VAR 0 1
45866: PUSH
45867: LD_EXP 74
45871: PUSH
45872: LD_VAR 0 5
45876: ARRAY
45877: IN
45878: IFFALSE 46039
// begin tmp := mc_bases [ i ] diff building ;
45880: LD_ADDR_VAR 0 6
45884: PUSH
45885: LD_EXP 74
45889: PUSH
45890: LD_VAR 0 5
45894: ARRAY
45895: PUSH
45896: LD_VAR 0 1
45900: DIFF
45901: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
45902: LD_ADDR_EXP 74
45906: PUSH
45907: LD_EXP 74
45911: PPUSH
45912: LD_VAR 0 5
45916: PPUSH
45917: LD_VAR 0 6
45921: PPUSH
45922: CALL_OW 1
45926: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
45927: LD_VAR 0 1
45931: PUSH
45932: LD_EXP 82
45936: PUSH
45937: LD_VAR 0 5
45941: ARRAY
45942: IN
45943: IFFALSE 45982
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
45945: LD_ADDR_EXP 82
45949: PUSH
45950: LD_EXP 82
45954: PPUSH
45955: LD_VAR 0 5
45959: PPUSH
45960: LD_EXP 82
45964: PUSH
45965: LD_VAR 0 5
45969: ARRAY
45970: PUSH
45971: LD_VAR 0 1
45975: DIFF
45976: PPUSH
45977: CALL_OW 1
45981: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
45982: LD_VAR 0 1
45986: PUSH
45987: LD_EXP 83
45991: PUSH
45992: LD_VAR 0 5
45996: ARRAY
45997: IN
45998: IFFALSE 46037
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46000: LD_ADDR_EXP 83
46004: PUSH
46005: LD_EXP 83
46009: PPUSH
46010: LD_VAR 0 5
46014: PPUSH
46015: LD_EXP 83
46019: PUSH
46020: LD_VAR 0 5
46024: ARRAY
46025: PUSH
46026: LD_VAR 0 1
46030: DIFF
46031: PPUSH
46032: CALL_OW 1
46036: ST_TO_ADDR
// break ;
46037: GO 46041
// end ;
46039: GO 45859
46041: POP
46042: POP
// end ;
46043: LD_VAR 0 4
46047: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46048: LD_INT 0
46050: PPUSH
46051: PPUSH
46052: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46053: LD_EXP 74
46057: NOT
46058: PUSH
46059: LD_EXP 72
46063: NOT
46064: OR
46065: PUSH
46066: LD_VAR 0 3
46070: PUSH
46071: LD_EXP 100
46075: IN
46076: NOT
46077: OR
46078: IFFALSE 46082
// exit ;
46080: GO 46205
// for i = 1 to mc_vehicles do
46082: LD_ADDR_VAR 0 6
46086: PUSH
46087: DOUBLE
46088: LD_INT 1
46090: DEC
46091: ST_TO_ADDR
46092: LD_EXP 93
46096: PUSH
46097: FOR_TO
46098: IFFALSE 46203
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46100: LD_VAR 0 2
46104: PUSH
46105: LD_EXP 93
46109: PUSH
46110: LD_VAR 0 6
46114: ARRAY
46115: IN
46116: PUSH
46117: LD_VAR 0 1
46121: PUSH
46122: LD_EXP 93
46126: PUSH
46127: LD_VAR 0 6
46131: ARRAY
46132: IN
46133: OR
46134: IFFALSE 46201
// begin tmp := mc_vehicles [ i ] diff old ;
46136: LD_ADDR_VAR 0 7
46140: PUSH
46141: LD_EXP 93
46145: PUSH
46146: LD_VAR 0 6
46150: ARRAY
46151: PUSH
46152: LD_VAR 0 2
46156: DIFF
46157: ST_TO_ADDR
// tmp := tmp diff new ;
46158: LD_ADDR_VAR 0 7
46162: PUSH
46163: LD_VAR 0 7
46167: PUSH
46168: LD_VAR 0 1
46172: DIFF
46173: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46174: LD_ADDR_EXP 93
46178: PUSH
46179: LD_EXP 93
46183: PPUSH
46184: LD_VAR 0 6
46188: PPUSH
46189: LD_VAR 0 7
46193: PPUSH
46194: CALL_OW 1
46198: ST_TO_ADDR
// break ;
46199: GO 46203
// end ;
46201: GO 46097
46203: POP
46204: POP
// end ;
46205: LD_VAR 0 5
46209: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46210: LD_INT 0
46212: PPUSH
46213: PPUSH
46214: PPUSH
46215: PPUSH
// if not mc_bases or not skirmish then
46216: LD_EXP 74
46220: NOT
46221: PUSH
46222: LD_EXP 72
46226: NOT
46227: OR
46228: IFFALSE 46232
// exit ;
46230: GO 46609
// side := GetSide ( vehicle ) ;
46232: LD_ADDR_VAR 0 5
46236: PUSH
46237: LD_VAR 0 1
46241: PPUSH
46242: CALL_OW 255
46246: ST_TO_ADDR
// for i = 1 to mc_bases do
46247: LD_ADDR_VAR 0 4
46251: PUSH
46252: DOUBLE
46253: LD_INT 1
46255: DEC
46256: ST_TO_ADDR
46257: LD_EXP 74
46261: PUSH
46262: FOR_TO
46263: IFFALSE 46607
// begin if factory in mc_bases [ i ] then
46265: LD_VAR 0 2
46269: PUSH
46270: LD_EXP 74
46274: PUSH
46275: LD_VAR 0 4
46279: ARRAY
46280: IN
46281: IFFALSE 46605
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46283: LD_EXP 96
46287: PUSH
46288: LD_VAR 0 4
46292: ARRAY
46293: PUSH
46294: LD_EXP 85
46298: PUSH
46299: LD_VAR 0 4
46303: ARRAY
46304: LESS
46305: PUSH
46306: LD_VAR 0 1
46310: PPUSH
46311: CALL_OW 264
46315: PUSH
46316: LD_INT 31
46318: PUSH
46319: LD_INT 32
46321: PUSH
46322: LD_INT 51
46324: PUSH
46325: LD_EXP 68
46329: PUSH
46330: LD_INT 12
46332: PUSH
46333: LD_INT 30
46335: PUSH
46336: LD_EXP 67
46340: PUSH
46341: LD_INT 11
46343: PUSH
46344: LD_INT 53
46346: PUSH
46347: LD_INT 14
46349: PUSH
46350: LD_EXP 71
46354: PUSH
46355: LD_INT 29
46357: PUSH
46358: LD_EXP 69
46362: PUSH
46363: LD_INT 13
46365: PUSH
46366: LD_INT 52
46368: PUSH
46369: LD_INT 48
46371: PUSH
46372: LD_INT 8
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: IN
46394: NOT
46395: AND
46396: IFFALSE 46444
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46398: LD_ADDR_EXP 96
46402: PUSH
46403: LD_EXP 96
46407: PPUSH
46408: LD_VAR 0 4
46412: PUSH
46413: LD_EXP 96
46417: PUSH
46418: LD_VAR 0 4
46422: ARRAY
46423: PUSH
46424: LD_INT 1
46426: PLUS
46427: PUSH
46428: EMPTY
46429: LIST
46430: LIST
46431: PPUSH
46432: LD_VAR 0 1
46436: PPUSH
46437: CALL 57398 0 3
46441: ST_TO_ADDR
46442: GO 46488
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46444: LD_ADDR_EXP 93
46448: PUSH
46449: LD_EXP 93
46453: PPUSH
46454: LD_VAR 0 4
46458: PUSH
46459: LD_EXP 93
46463: PUSH
46464: LD_VAR 0 4
46468: ARRAY
46469: PUSH
46470: LD_INT 1
46472: PLUS
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PPUSH
46478: LD_VAR 0 1
46482: PPUSH
46483: CALL 57398 0 3
46487: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46488: LD_VAR 0 1
46492: PPUSH
46493: CALL_OW 263
46497: PUSH
46498: LD_INT 2
46500: EQUAL
46501: IFFALSE 46521
// begin repeat wait ( 0 0$1 ) ;
46503: LD_INT 35
46505: PPUSH
46506: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46510: LD_VAR 0 1
46514: PPUSH
46515: CALL_OW 312
46519: IFFALSE 46503
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46521: LD_VAR 0 1
46525: PPUSH
46526: LD_EXP 98
46530: PUSH
46531: LD_VAR 0 4
46535: ARRAY
46536: PPUSH
46537: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46541: LD_VAR 0 1
46545: PPUSH
46546: CALL_OW 263
46550: PUSH
46551: LD_INT 1
46553: NONEQUAL
46554: IFFALSE 46558
// break ;
46556: GO 46607
// repeat wait ( 0 0$1 ) ;
46558: LD_INT 35
46560: PPUSH
46561: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46565: LD_VAR 0 1
46569: PPUSH
46570: LD_EXP 98
46574: PUSH
46575: LD_VAR 0 4
46579: ARRAY
46580: PPUSH
46581: CALL_OW 308
46585: IFFALSE 46558
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46587: LD_VAR 0 1
46591: PPUSH
46592: CALL_OW 311
46596: PPUSH
46597: CALL_OW 121
// exit ;
46601: POP
46602: POP
46603: GO 46609
// end ; end ;
46605: GO 46262
46607: POP
46608: POP
// end ;
46609: LD_VAR 0 3
46613: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46614: LD_INT 0
46616: PPUSH
46617: PPUSH
46618: PPUSH
46619: PPUSH
// if not mc_bases or not skirmish then
46620: LD_EXP 74
46624: NOT
46625: PUSH
46626: LD_EXP 72
46630: NOT
46631: OR
46632: IFFALSE 46636
// exit ;
46634: GO 46989
// repeat wait ( 0 0$1 ) ;
46636: LD_INT 35
46638: PPUSH
46639: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46643: LD_VAR 0 2
46647: PPUSH
46648: LD_VAR 0 3
46652: PPUSH
46653: CALL_OW 284
46657: IFFALSE 46636
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46659: LD_VAR 0 2
46663: PPUSH
46664: LD_VAR 0 3
46668: PPUSH
46669: CALL_OW 283
46673: PUSH
46674: LD_INT 4
46676: EQUAL
46677: IFFALSE 46681
// exit ;
46679: GO 46989
// for i = 1 to mc_bases do
46681: LD_ADDR_VAR 0 7
46685: PUSH
46686: DOUBLE
46687: LD_INT 1
46689: DEC
46690: ST_TO_ADDR
46691: LD_EXP 74
46695: PUSH
46696: FOR_TO
46697: IFFALSE 46987
// begin if mc_crates_area [ i ] then
46699: LD_EXP 92
46703: PUSH
46704: LD_VAR 0 7
46708: ARRAY
46709: IFFALSE 46820
// for j in mc_crates_area [ i ] do
46711: LD_ADDR_VAR 0 8
46715: PUSH
46716: LD_EXP 92
46720: PUSH
46721: LD_VAR 0 7
46725: ARRAY
46726: PUSH
46727: FOR_IN
46728: IFFALSE 46818
// if InArea ( x , y , j ) then
46730: LD_VAR 0 2
46734: PPUSH
46735: LD_VAR 0 3
46739: PPUSH
46740: LD_VAR 0 8
46744: PPUSH
46745: CALL_OW 309
46749: IFFALSE 46816
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46751: LD_ADDR_EXP 90
46755: PUSH
46756: LD_EXP 90
46760: PPUSH
46761: LD_VAR 0 7
46765: PUSH
46766: LD_EXP 90
46770: PUSH
46771: LD_VAR 0 7
46775: ARRAY
46776: PUSH
46777: LD_INT 1
46779: PLUS
46780: PUSH
46781: EMPTY
46782: LIST
46783: LIST
46784: PPUSH
46785: LD_VAR 0 4
46789: PUSH
46790: LD_VAR 0 2
46794: PUSH
46795: LD_VAR 0 3
46799: PUSH
46800: EMPTY
46801: LIST
46802: LIST
46803: LIST
46804: PPUSH
46805: CALL 57398 0 3
46809: ST_TO_ADDR
// exit ;
46810: POP
46811: POP
46812: POP
46813: POP
46814: GO 46989
// end ;
46816: GO 46727
46818: POP
46819: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46820: LD_ADDR_VAR 0 9
46824: PUSH
46825: LD_EXP 74
46829: PUSH
46830: LD_VAR 0 7
46834: ARRAY
46835: PPUSH
46836: LD_INT 2
46838: PUSH
46839: LD_INT 30
46841: PUSH
46842: LD_INT 0
46844: PUSH
46845: EMPTY
46846: LIST
46847: LIST
46848: PUSH
46849: LD_INT 30
46851: PUSH
46852: LD_INT 1
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PUSH
46859: EMPTY
46860: LIST
46861: LIST
46862: LIST
46863: PPUSH
46864: CALL_OW 72
46868: ST_TO_ADDR
// if not depot then
46869: LD_VAR 0 9
46873: NOT
46874: IFFALSE 46878
// continue ;
46876: GO 46696
// for j in depot do
46878: LD_ADDR_VAR 0 8
46882: PUSH
46883: LD_VAR 0 9
46887: PUSH
46888: FOR_IN
46889: IFFALSE 46983
// if GetDistUnitXY ( j , x , y ) < 30 then
46891: LD_VAR 0 8
46895: PPUSH
46896: LD_VAR 0 2
46900: PPUSH
46901: LD_VAR 0 3
46905: PPUSH
46906: CALL_OW 297
46910: PUSH
46911: LD_INT 30
46913: LESS
46914: IFFALSE 46981
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46916: LD_ADDR_EXP 90
46920: PUSH
46921: LD_EXP 90
46925: PPUSH
46926: LD_VAR 0 7
46930: PUSH
46931: LD_EXP 90
46935: PUSH
46936: LD_VAR 0 7
46940: ARRAY
46941: PUSH
46942: LD_INT 1
46944: PLUS
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PPUSH
46950: LD_VAR 0 4
46954: PUSH
46955: LD_VAR 0 2
46959: PUSH
46960: LD_VAR 0 3
46964: PUSH
46965: EMPTY
46966: LIST
46967: LIST
46968: LIST
46969: PPUSH
46970: CALL 57398 0 3
46974: ST_TO_ADDR
// exit ;
46975: POP
46976: POP
46977: POP
46978: POP
46979: GO 46989
// end ;
46981: GO 46888
46983: POP
46984: POP
// end ;
46985: GO 46696
46987: POP
46988: POP
// end ;
46989: LD_VAR 0 6
46993: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
46994: LD_INT 0
46996: PPUSH
46997: PPUSH
46998: PPUSH
46999: PPUSH
// if not mc_bases or not skirmish then
47000: LD_EXP 74
47004: NOT
47005: PUSH
47006: LD_EXP 72
47010: NOT
47011: OR
47012: IFFALSE 47016
// exit ;
47014: GO 47293
// side := GetSide ( lab ) ;
47016: LD_ADDR_VAR 0 4
47020: PUSH
47021: LD_VAR 0 2
47025: PPUSH
47026: CALL_OW 255
47030: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47031: LD_VAR 0 4
47035: PUSH
47036: LD_EXP 100
47040: IN
47041: NOT
47042: PUSH
47043: LD_EXP 101
47047: NOT
47048: OR
47049: PUSH
47050: LD_EXP 74
47054: NOT
47055: OR
47056: IFFALSE 47060
// exit ;
47058: GO 47293
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47060: LD_ADDR_EXP 101
47064: PUSH
47065: LD_EXP 101
47069: PPUSH
47070: LD_VAR 0 4
47074: PPUSH
47075: LD_EXP 101
47079: PUSH
47080: LD_VAR 0 4
47084: ARRAY
47085: PUSH
47086: LD_VAR 0 1
47090: DIFF
47091: PPUSH
47092: CALL_OW 1
47096: ST_TO_ADDR
// for i = 1 to mc_bases do
47097: LD_ADDR_VAR 0 5
47101: PUSH
47102: DOUBLE
47103: LD_INT 1
47105: DEC
47106: ST_TO_ADDR
47107: LD_EXP 74
47111: PUSH
47112: FOR_TO
47113: IFFALSE 47291
// begin if lab in mc_bases [ i ] then
47115: LD_VAR 0 2
47119: PUSH
47120: LD_EXP 74
47124: PUSH
47125: LD_VAR 0 5
47129: ARRAY
47130: IN
47131: IFFALSE 47289
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47133: LD_VAR 0 1
47137: PUSH
47138: LD_INT 11
47140: PUSH
47141: LD_INT 4
47143: PUSH
47144: LD_INT 3
47146: PUSH
47147: LD_INT 2
47149: PUSH
47150: EMPTY
47151: LIST
47152: LIST
47153: LIST
47154: LIST
47155: IN
47156: PUSH
47157: LD_EXP 104
47161: PUSH
47162: LD_VAR 0 5
47166: ARRAY
47167: AND
47168: IFFALSE 47289
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47170: LD_ADDR_VAR 0 6
47174: PUSH
47175: LD_EXP 104
47179: PUSH
47180: LD_VAR 0 5
47184: ARRAY
47185: PUSH
47186: LD_INT 1
47188: ARRAY
47189: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47190: LD_ADDR_EXP 104
47194: PUSH
47195: LD_EXP 104
47199: PPUSH
47200: LD_VAR 0 5
47204: PPUSH
47205: EMPTY
47206: PPUSH
47207: CALL_OW 1
47211: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47212: LD_VAR 0 6
47216: PPUSH
47217: LD_INT 0
47219: PPUSH
47220: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47224: LD_VAR 0 6
47228: PPUSH
47229: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47233: LD_ADDR_EXP 103
47237: PUSH
47238: LD_EXP 103
47242: PPUSH
47243: LD_VAR 0 5
47247: PPUSH
47248: LD_EXP 103
47252: PUSH
47253: LD_VAR 0 5
47257: ARRAY
47258: PPUSH
47259: LD_INT 1
47261: PPUSH
47262: LD_VAR 0 6
47266: PPUSH
47267: CALL_OW 2
47271: PPUSH
47272: CALL_OW 1
47276: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47277: LD_VAR 0 5
47281: PPUSH
47282: LD_INT 112
47284: PPUSH
47285: CALL 24185 0 2
// end ; end ; end ;
47289: GO 47112
47291: POP
47292: POP
// end ;
47293: LD_VAR 0 3
47297: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47298: LD_INT 0
47300: PPUSH
47301: PPUSH
47302: PPUSH
47303: PPUSH
47304: PPUSH
47305: PPUSH
47306: PPUSH
47307: PPUSH
// if not mc_bases or not skirmish then
47308: LD_EXP 74
47312: NOT
47313: PUSH
47314: LD_EXP 72
47318: NOT
47319: OR
47320: IFFALSE 47324
// exit ;
47322: GO 48695
// for i = 1 to mc_bases do
47324: LD_ADDR_VAR 0 3
47328: PUSH
47329: DOUBLE
47330: LD_INT 1
47332: DEC
47333: ST_TO_ADDR
47334: LD_EXP 74
47338: PUSH
47339: FOR_TO
47340: IFFALSE 48693
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47342: LD_VAR 0 1
47346: PUSH
47347: LD_EXP 74
47351: PUSH
47352: LD_VAR 0 3
47356: ARRAY
47357: IN
47358: PUSH
47359: LD_VAR 0 1
47363: PUSH
47364: LD_EXP 81
47368: PUSH
47369: LD_VAR 0 3
47373: ARRAY
47374: IN
47375: OR
47376: PUSH
47377: LD_VAR 0 1
47381: PUSH
47382: LD_EXP 96
47386: PUSH
47387: LD_VAR 0 3
47391: ARRAY
47392: IN
47393: OR
47394: PUSH
47395: LD_VAR 0 1
47399: PUSH
47400: LD_EXP 93
47404: PUSH
47405: LD_VAR 0 3
47409: ARRAY
47410: IN
47411: OR
47412: PUSH
47413: LD_VAR 0 1
47417: PUSH
47418: LD_EXP 103
47422: PUSH
47423: LD_VAR 0 3
47427: ARRAY
47428: IN
47429: OR
47430: PUSH
47431: LD_VAR 0 1
47435: PUSH
47436: LD_EXP 104
47440: PUSH
47441: LD_VAR 0 3
47445: ARRAY
47446: IN
47447: OR
47448: IFFALSE 48691
// begin if un in mc_ape [ i ] then
47450: LD_VAR 0 1
47454: PUSH
47455: LD_EXP 103
47459: PUSH
47460: LD_VAR 0 3
47464: ARRAY
47465: IN
47466: IFFALSE 47505
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47468: LD_ADDR_EXP 103
47472: PUSH
47473: LD_EXP 103
47477: PPUSH
47478: LD_VAR 0 3
47482: PPUSH
47483: LD_EXP 103
47487: PUSH
47488: LD_VAR 0 3
47492: ARRAY
47493: PUSH
47494: LD_VAR 0 1
47498: DIFF
47499: PPUSH
47500: CALL_OW 1
47504: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47505: LD_VAR 0 1
47509: PUSH
47510: LD_EXP 104
47514: PUSH
47515: LD_VAR 0 3
47519: ARRAY
47520: IN
47521: IFFALSE 47545
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47523: LD_ADDR_EXP 104
47527: PUSH
47528: LD_EXP 104
47532: PPUSH
47533: LD_VAR 0 3
47537: PPUSH
47538: EMPTY
47539: PPUSH
47540: CALL_OW 1
47544: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47545: LD_VAR 0 1
47549: PPUSH
47550: CALL_OW 247
47554: PUSH
47555: LD_INT 2
47557: EQUAL
47558: PUSH
47559: LD_VAR 0 1
47563: PPUSH
47564: CALL_OW 110
47568: PUSH
47569: LD_INT 20
47571: EQUAL
47572: PUSH
47573: LD_VAR 0 1
47577: PUSH
47578: LD_EXP 96
47582: PUSH
47583: LD_VAR 0 3
47587: ARRAY
47588: IN
47589: OR
47590: PUSH
47591: LD_VAR 0 1
47595: PPUSH
47596: CALL_OW 264
47600: PUSH
47601: LD_INT 12
47603: PUSH
47604: LD_INT 51
47606: PUSH
47607: LD_EXP 68
47611: PUSH
47612: LD_INT 32
47614: PUSH
47615: LD_INT 13
47617: PUSH
47618: LD_INT 52
47620: PUSH
47621: LD_INT 31
47623: PUSH
47624: EMPTY
47625: LIST
47626: LIST
47627: LIST
47628: LIST
47629: LIST
47630: LIST
47631: LIST
47632: IN
47633: OR
47634: AND
47635: IFFALSE 47943
// begin if un in mc_defender [ i ] then
47637: LD_VAR 0 1
47641: PUSH
47642: LD_EXP 96
47646: PUSH
47647: LD_VAR 0 3
47651: ARRAY
47652: IN
47653: IFFALSE 47692
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47655: LD_ADDR_EXP 96
47659: PUSH
47660: LD_EXP 96
47664: PPUSH
47665: LD_VAR 0 3
47669: PPUSH
47670: LD_EXP 96
47674: PUSH
47675: LD_VAR 0 3
47679: ARRAY
47680: PUSH
47681: LD_VAR 0 1
47685: DIFF
47686: PPUSH
47687: CALL_OW 1
47691: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47692: LD_ADDR_VAR 0 8
47696: PUSH
47697: LD_VAR 0 3
47701: PPUSH
47702: LD_INT 3
47704: PPUSH
47705: CALL 44361 0 2
47709: ST_TO_ADDR
// if fac then
47710: LD_VAR 0 8
47714: IFFALSE 47943
// begin for j in fac do
47716: LD_ADDR_VAR 0 4
47720: PUSH
47721: LD_VAR 0 8
47725: PUSH
47726: FOR_IN
47727: IFFALSE 47941
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47729: LD_ADDR_VAR 0 9
47733: PUSH
47734: LD_VAR 0 8
47738: PPUSH
47739: LD_VAR 0 1
47743: PPUSH
47744: CALL_OW 265
47748: PPUSH
47749: LD_VAR 0 1
47753: PPUSH
47754: CALL_OW 262
47758: PPUSH
47759: LD_VAR 0 1
47763: PPUSH
47764: CALL_OW 263
47768: PPUSH
47769: LD_VAR 0 1
47773: PPUSH
47774: CALL_OW 264
47778: PPUSH
47779: CALL 54930 0 5
47783: ST_TO_ADDR
// if components then
47784: LD_VAR 0 9
47788: IFFALSE 47939
// begin if GetWeapon ( un ) = ar_control_tower then
47790: LD_VAR 0 1
47794: PPUSH
47795: CALL_OW 264
47799: PUSH
47800: LD_INT 31
47802: EQUAL
47803: IFFALSE 47920
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
47805: LD_VAR 0 1
47809: PPUSH
47810: CALL_OW 311
47814: PPUSH
47815: LD_INT 0
47817: PPUSH
47818: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
47822: LD_ADDR_EXP 114
47826: PUSH
47827: LD_EXP 114
47831: PPUSH
47832: LD_VAR 0 3
47836: PPUSH
47837: LD_EXP 114
47841: PUSH
47842: LD_VAR 0 3
47846: ARRAY
47847: PUSH
47848: LD_VAR 0 1
47852: PPUSH
47853: CALL_OW 311
47857: DIFF
47858: PPUSH
47859: CALL_OW 1
47863: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
47864: LD_ADDR_VAR 0 7
47868: PUSH
47869: LD_EXP 95
47873: PUSH
47874: LD_VAR 0 3
47878: ARRAY
47879: PPUSH
47880: LD_INT 1
47882: PPUSH
47883: LD_VAR 0 9
47887: PPUSH
47888: CALL_OW 2
47892: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
47893: LD_ADDR_EXP 95
47897: PUSH
47898: LD_EXP 95
47902: PPUSH
47903: LD_VAR 0 3
47907: PPUSH
47908: LD_VAR 0 7
47912: PPUSH
47913: CALL_OW 1
47917: ST_TO_ADDR
// end else
47918: GO 47937
// MC_InsertProduceList ( i , [ components ] ) ;
47920: LD_VAR 0 3
47924: PPUSH
47925: LD_VAR 0 9
47929: PUSH
47930: EMPTY
47931: LIST
47932: PPUSH
47933: CALL 43906 0 2
// break ;
47937: GO 47941
// end ; end ;
47939: GO 47726
47941: POP
47942: POP
// end ; end ; if GetType ( un ) = unit_building then
47943: LD_VAR 0 1
47947: PPUSH
47948: CALL_OW 247
47952: PUSH
47953: LD_INT 3
47955: EQUAL
47956: IFFALSE 48359
// begin btype := GetBType ( un ) ;
47958: LD_ADDR_VAR 0 5
47962: PUSH
47963: LD_VAR 0 1
47967: PPUSH
47968: CALL_OW 266
47972: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
47973: LD_VAR 0 5
47977: PUSH
47978: LD_INT 29
47980: PUSH
47981: LD_INT 30
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: IN
47988: IFFALSE 48061
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
47990: LD_VAR 0 1
47994: PPUSH
47995: CALL_OW 250
47999: PPUSH
48000: LD_VAR 0 1
48004: PPUSH
48005: CALL_OW 251
48009: PPUSH
48010: LD_VAR 0 1
48014: PPUSH
48015: CALL_OW 255
48019: PPUSH
48020: CALL_OW 440
48024: NOT
48025: IFFALSE 48061
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48027: LD_VAR 0 1
48031: PPUSH
48032: CALL_OW 250
48036: PPUSH
48037: LD_VAR 0 1
48041: PPUSH
48042: CALL_OW 251
48046: PPUSH
48047: LD_VAR 0 1
48051: PPUSH
48052: CALL_OW 255
48056: PPUSH
48057: CALL_OW 441
// end ; if btype = b_warehouse then
48061: LD_VAR 0 5
48065: PUSH
48066: LD_INT 1
48068: EQUAL
48069: IFFALSE 48087
// begin btype := b_depot ;
48071: LD_ADDR_VAR 0 5
48075: PUSH
48076: LD_INT 0
48078: ST_TO_ADDR
// pos := 1 ;
48079: LD_ADDR_VAR 0 6
48083: PUSH
48084: LD_INT 1
48086: ST_TO_ADDR
// end ; if btype = b_factory then
48087: LD_VAR 0 5
48091: PUSH
48092: LD_INT 3
48094: EQUAL
48095: IFFALSE 48113
// begin btype := b_workshop ;
48097: LD_ADDR_VAR 0 5
48101: PUSH
48102: LD_INT 2
48104: ST_TO_ADDR
// pos := 1 ;
48105: LD_ADDR_VAR 0 6
48109: PUSH
48110: LD_INT 1
48112: ST_TO_ADDR
// end ; if btype = b_barracks then
48113: LD_VAR 0 5
48117: PUSH
48118: LD_INT 5
48120: EQUAL
48121: IFFALSE 48131
// btype := b_armoury ;
48123: LD_ADDR_VAR 0 5
48127: PUSH
48128: LD_INT 4
48130: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48131: LD_VAR 0 5
48135: PUSH
48136: LD_INT 7
48138: PUSH
48139: LD_INT 8
48141: PUSH
48142: EMPTY
48143: LIST
48144: LIST
48145: IN
48146: IFFALSE 48156
// btype := b_lab ;
48148: LD_ADDR_VAR 0 5
48152: PUSH
48153: LD_INT 6
48155: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48156: LD_ADDR_EXP 79
48160: PUSH
48161: LD_EXP 79
48165: PPUSH
48166: LD_VAR 0 3
48170: PUSH
48171: LD_EXP 79
48175: PUSH
48176: LD_VAR 0 3
48180: ARRAY
48181: PUSH
48182: LD_INT 1
48184: PLUS
48185: PUSH
48186: EMPTY
48187: LIST
48188: LIST
48189: PPUSH
48190: LD_VAR 0 5
48194: PUSH
48195: LD_VAR 0 1
48199: PPUSH
48200: CALL_OW 250
48204: PUSH
48205: LD_VAR 0 1
48209: PPUSH
48210: CALL_OW 251
48214: PUSH
48215: LD_VAR 0 1
48219: PPUSH
48220: CALL_OW 254
48224: PUSH
48225: EMPTY
48226: LIST
48227: LIST
48228: LIST
48229: LIST
48230: PPUSH
48231: CALL 57398 0 3
48235: ST_TO_ADDR
// if pos = 1 then
48236: LD_VAR 0 6
48240: PUSH
48241: LD_INT 1
48243: EQUAL
48244: IFFALSE 48359
// begin tmp := mc_build_list [ i ] ;
48246: LD_ADDR_VAR 0 7
48250: PUSH
48251: LD_EXP 79
48255: PUSH
48256: LD_VAR 0 3
48260: ARRAY
48261: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48262: LD_VAR 0 7
48266: PPUSH
48267: LD_INT 2
48269: PUSH
48270: LD_INT 30
48272: PUSH
48273: LD_INT 0
48275: PUSH
48276: EMPTY
48277: LIST
48278: LIST
48279: PUSH
48280: LD_INT 30
48282: PUSH
48283: LD_INT 1
48285: PUSH
48286: EMPTY
48287: LIST
48288: LIST
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: LIST
48294: PPUSH
48295: CALL_OW 72
48299: IFFALSE 48309
// pos := 2 ;
48301: LD_ADDR_VAR 0 6
48305: PUSH
48306: LD_INT 2
48308: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48309: LD_ADDR_VAR 0 7
48313: PUSH
48314: LD_VAR 0 7
48318: PPUSH
48319: LD_VAR 0 6
48323: PPUSH
48324: LD_VAR 0 7
48328: PPUSH
48329: CALL 57724 0 3
48333: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48334: LD_ADDR_EXP 79
48338: PUSH
48339: LD_EXP 79
48343: PPUSH
48344: LD_VAR 0 3
48348: PPUSH
48349: LD_VAR 0 7
48353: PPUSH
48354: CALL_OW 1
48358: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48359: LD_VAR 0 1
48363: PUSH
48364: LD_EXP 74
48368: PUSH
48369: LD_VAR 0 3
48373: ARRAY
48374: IN
48375: IFFALSE 48414
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48377: LD_ADDR_EXP 74
48381: PUSH
48382: LD_EXP 74
48386: PPUSH
48387: LD_VAR 0 3
48391: PPUSH
48392: LD_EXP 74
48396: PUSH
48397: LD_VAR 0 3
48401: ARRAY
48402: PUSH
48403: LD_VAR 0 1
48407: DIFF
48408: PPUSH
48409: CALL_OW 1
48413: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48414: LD_VAR 0 1
48418: PUSH
48419: LD_EXP 81
48423: PUSH
48424: LD_VAR 0 3
48428: ARRAY
48429: IN
48430: IFFALSE 48469
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48432: LD_ADDR_EXP 81
48436: PUSH
48437: LD_EXP 81
48441: PPUSH
48442: LD_VAR 0 3
48446: PPUSH
48447: LD_EXP 81
48451: PUSH
48452: LD_VAR 0 3
48456: ARRAY
48457: PUSH
48458: LD_VAR 0 1
48462: DIFF
48463: PPUSH
48464: CALL_OW 1
48468: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48469: LD_VAR 0 1
48473: PUSH
48474: LD_EXP 93
48478: PUSH
48479: LD_VAR 0 3
48483: ARRAY
48484: IN
48485: IFFALSE 48524
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48487: LD_ADDR_EXP 93
48491: PUSH
48492: LD_EXP 93
48496: PPUSH
48497: LD_VAR 0 3
48501: PPUSH
48502: LD_EXP 93
48506: PUSH
48507: LD_VAR 0 3
48511: ARRAY
48512: PUSH
48513: LD_VAR 0 1
48517: DIFF
48518: PPUSH
48519: CALL_OW 1
48523: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48524: LD_VAR 0 1
48528: PUSH
48529: LD_EXP 96
48533: PUSH
48534: LD_VAR 0 3
48538: ARRAY
48539: IN
48540: IFFALSE 48579
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48542: LD_ADDR_EXP 96
48546: PUSH
48547: LD_EXP 96
48551: PPUSH
48552: LD_VAR 0 3
48556: PPUSH
48557: LD_EXP 96
48561: PUSH
48562: LD_VAR 0 3
48566: ARRAY
48567: PUSH
48568: LD_VAR 0 1
48572: DIFF
48573: PPUSH
48574: CALL_OW 1
48578: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48579: LD_VAR 0 1
48583: PUSH
48584: LD_EXP 83
48588: PUSH
48589: LD_VAR 0 3
48593: ARRAY
48594: IN
48595: IFFALSE 48634
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48597: LD_ADDR_EXP 83
48601: PUSH
48602: LD_EXP 83
48606: PPUSH
48607: LD_VAR 0 3
48611: PPUSH
48612: LD_EXP 83
48616: PUSH
48617: LD_VAR 0 3
48621: ARRAY
48622: PUSH
48623: LD_VAR 0 1
48627: DIFF
48628: PPUSH
48629: CALL_OW 1
48633: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48634: LD_VAR 0 1
48638: PUSH
48639: LD_EXP 82
48643: PUSH
48644: LD_VAR 0 3
48648: ARRAY
48649: IN
48650: IFFALSE 48689
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48652: LD_ADDR_EXP 82
48656: PUSH
48657: LD_EXP 82
48661: PPUSH
48662: LD_VAR 0 3
48666: PPUSH
48667: LD_EXP 82
48671: PUSH
48672: LD_VAR 0 3
48676: ARRAY
48677: PUSH
48678: LD_VAR 0 1
48682: DIFF
48683: PPUSH
48684: CALL_OW 1
48688: ST_TO_ADDR
// end ; break ;
48689: GO 48693
// end ;
48691: GO 47339
48693: POP
48694: POP
// end ;
48695: LD_VAR 0 2
48699: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48700: LD_INT 0
48702: PPUSH
48703: PPUSH
48704: PPUSH
// if not mc_bases or not skirmish then
48705: LD_EXP 74
48709: NOT
48710: PUSH
48711: LD_EXP 72
48715: NOT
48716: OR
48717: IFFALSE 48721
// exit ;
48719: GO 48936
// for i = 1 to mc_bases do
48721: LD_ADDR_VAR 0 3
48725: PUSH
48726: DOUBLE
48727: LD_INT 1
48729: DEC
48730: ST_TO_ADDR
48731: LD_EXP 74
48735: PUSH
48736: FOR_TO
48737: IFFALSE 48934
// begin if building in mc_construct_list [ i ] then
48739: LD_VAR 0 1
48743: PUSH
48744: LD_EXP 81
48748: PUSH
48749: LD_VAR 0 3
48753: ARRAY
48754: IN
48755: IFFALSE 48932
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48757: LD_ADDR_EXP 81
48761: PUSH
48762: LD_EXP 81
48766: PPUSH
48767: LD_VAR 0 3
48771: PPUSH
48772: LD_EXP 81
48776: PUSH
48777: LD_VAR 0 3
48781: ARRAY
48782: PUSH
48783: LD_VAR 0 1
48787: DIFF
48788: PPUSH
48789: CALL_OW 1
48793: ST_TO_ADDR
// if building in mc_lab [ i ] then
48794: LD_VAR 0 1
48798: PUSH
48799: LD_EXP 107
48803: PUSH
48804: LD_VAR 0 3
48808: ARRAY
48809: IN
48810: IFFALSE 48865
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
48812: LD_ADDR_EXP 108
48816: PUSH
48817: LD_EXP 108
48821: PPUSH
48822: LD_VAR 0 3
48826: PPUSH
48827: LD_EXP 108
48831: PUSH
48832: LD_VAR 0 3
48836: ARRAY
48837: PPUSH
48838: LD_INT 1
48840: PPUSH
48841: LD_EXP 108
48845: PUSH
48846: LD_VAR 0 3
48850: ARRAY
48851: PPUSH
48852: LD_INT 0
48854: PPUSH
48855: CALL 56816 0 4
48859: PPUSH
48860: CALL_OW 1
48864: ST_TO_ADDR
// if not building in mc_bases [ i ] then
48865: LD_VAR 0 1
48869: PUSH
48870: LD_EXP 74
48874: PUSH
48875: LD_VAR 0 3
48879: ARRAY
48880: IN
48881: NOT
48882: IFFALSE 48928
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48884: LD_ADDR_EXP 74
48888: PUSH
48889: LD_EXP 74
48893: PPUSH
48894: LD_VAR 0 3
48898: PUSH
48899: LD_EXP 74
48903: PUSH
48904: LD_VAR 0 3
48908: ARRAY
48909: PUSH
48910: LD_INT 1
48912: PLUS
48913: PUSH
48914: EMPTY
48915: LIST
48916: LIST
48917: PPUSH
48918: LD_VAR 0 1
48922: PPUSH
48923: CALL 57398 0 3
48927: ST_TO_ADDR
// exit ;
48928: POP
48929: POP
48930: GO 48936
// end ; end ;
48932: GO 48736
48934: POP
48935: POP
// end ;
48936: LD_VAR 0 2
48940: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
48941: LD_INT 0
48943: PPUSH
48944: PPUSH
48945: PPUSH
48946: PPUSH
48947: PPUSH
48948: PPUSH
48949: PPUSH
// if not mc_bases or not skirmish then
48950: LD_EXP 74
48954: NOT
48955: PUSH
48956: LD_EXP 72
48960: NOT
48961: OR
48962: IFFALSE 48966
// exit ;
48964: GO 49627
// for i = 1 to mc_bases do
48966: LD_ADDR_VAR 0 3
48970: PUSH
48971: DOUBLE
48972: LD_INT 1
48974: DEC
48975: ST_TO_ADDR
48976: LD_EXP 74
48980: PUSH
48981: FOR_TO
48982: IFFALSE 49625
// begin if building in mc_construct_list [ i ] then
48984: LD_VAR 0 1
48988: PUSH
48989: LD_EXP 81
48993: PUSH
48994: LD_VAR 0 3
48998: ARRAY
48999: IN
49000: IFFALSE 49623
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49002: LD_ADDR_EXP 81
49006: PUSH
49007: LD_EXP 81
49011: PPUSH
49012: LD_VAR 0 3
49016: PPUSH
49017: LD_EXP 81
49021: PUSH
49022: LD_VAR 0 3
49026: ARRAY
49027: PUSH
49028: LD_VAR 0 1
49032: DIFF
49033: PPUSH
49034: CALL_OW 1
49038: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49039: LD_ADDR_EXP 74
49043: PUSH
49044: LD_EXP 74
49048: PPUSH
49049: LD_VAR 0 3
49053: PUSH
49054: LD_EXP 74
49058: PUSH
49059: LD_VAR 0 3
49063: ARRAY
49064: PUSH
49065: LD_INT 1
49067: PLUS
49068: PUSH
49069: EMPTY
49070: LIST
49071: LIST
49072: PPUSH
49073: LD_VAR 0 1
49077: PPUSH
49078: CALL 57398 0 3
49082: ST_TO_ADDR
// btype := GetBType ( building ) ;
49083: LD_ADDR_VAR 0 5
49087: PUSH
49088: LD_VAR 0 1
49092: PPUSH
49093: CALL_OW 266
49097: ST_TO_ADDR
// side := GetSide ( building ) ;
49098: LD_ADDR_VAR 0 8
49102: PUSH
49103: LD_VAR 0 1
49107: PPUSH
49108: CALL_OW 255
49112: ST_TO_ADDR
// if btype = b_lab then
49113: LD_VAR 0 5
49117: PUSH
49118: LD_INT 6
49120: EQUAL
49121: IFFALSE 49171
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49123: LD_ADDR_EXP 107
49127: PUSH
49128: LD_EXP 107
49132: PPUSH
49133: LD_VAR 0 3
49137: PUSH
49138: LD_EXP 107
49142: PUSH
49143: LD_VAR 0 3
49147: ARRAY
49148: PUSH
49149: LD_INT 1
49151: PLUS
49152: PUSH
49153: EMPTY
49154: LIST
49155: LIST
49156: PPUSH
49157: LD_VAR 0 1
49161: PPUSH
49162: CALL 57398 0 3
49166: ST_TO_ADDR
// exit ;
49167: POP
49168: POP
49169: GO 49627
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49171: LD_VAR 0 5
49175: PUSH
49176: LD_INT 0
49178: PUSH
49179: LD_INT 2
49181: PUSH
49182: LD_INT 4
49184: PUSH
49185: EMPTY
49186: LIST
49187: LIST
49188: LIST
49189: IN
49190: IFFALSE 49314
// begin if btype = b_armoury then
49192: LD_VAR 0 5
49196: PUSH
49197: LD_INT 4
49199: EQUAL
49200: IFFALSE 49210
// btype := b_barracks ;
49202: LD_ADDR_VAR 0 5
49206: PUSH
49207: LD_INT 5
49209: ST_TO_ADDR
// if btype = b_depot then
49210: LD_VAR 0 5
49214: PUSH
49215: LD_INT 0
49217: EQUAL
49218: IFFALSE 49228
// btype := b_warehouse ;
49220: LD_ADDR_VAR 0 5
49224: PUSH
49225: LD_INT 1
49227: ST_TO_ADDR
// if btype = b_workshop then
49228: LD_VAR 0 5
49232: PUSH
49233: LD_INT 2
49235: EQUAL
49236: IFFALSE 49246
// btype := b_factory ;
49238: LD_ADDR_VAR 0 5
49242: PUSH
49243: LD_INT 3
49245: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49246: LD_VAR 0 5
49250: PPUSH
49251: LD_VAR 0 8
49255: PPUSH
49256: CALL_OW 323
49260: PUSH
49261: LD_INT 1
49263: EQUAL
49264: IFFALSE 49310
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49266: LD_ADDR_EXP 106
49270: PUSH
49271: LD_EXP 106
49275: PPUSH
49276: LD_VAR 0 3
49280: PUSH
49281: LD_EXP 106
49285: PUSH
49286: LD_VAR 0 3
49290: ARRAY
49291: PUSH
49292: LD_INT 1
49294: PLUS
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: PPUSH
49300: LD_VAR 0 1
49304: PPUSH
49305: CALL 57398 0 3
49309: ST_TO_ADDR
// exit ;
49310: POP
49311: POP
49312: GO 49627
// end ; if btype in [ b_bunker , b_turret ] then
49314: LD_VAR 0 5
49318: PUSH
49319: LD_INT 32
49321: PUSH
49322: LD_INT 33
49324: PUSH
49325: EMPTY
49326: LIST
49327: LIST
49328: IN
49329: IFFALSE 49619
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49331: LD_ADDR_EXP 82
49335: PUSH
49336: LD_EXP 82
49340: PPUSH
49341: LD_VAR 0 3
49345: PUSH
49346: LD_EXP 82
49350: PUSH
49351: LD_VAR 0 3
49355: ARRAY
49356: PUSH
49357: LD_INT 1
49359: PLUS
49360: PUSH
49361: EMPTY
49362: LIST
49363: LIST
49364: PPUSH
49365: LD_VAR 0 1
49369: PPUSH
49370: CALL 57398 0 3
49374: ST_TO_ADDR
// if btype = b_bunker then
49375: LD_VAR 0 5
49379: PUSH
49380: LD_INT 32
49382: EQUAL
49383: IFFALSE 49619
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49385: LD_ADDR_EXP 83
49389: PUSH
49390: LD_EXP 83
49394: PPUSH
49395: LD_VAR 0 3
49399: PUSH
49400: LD_EXP 83
49404: PUSH
49405: LD_VAR 0 3
49409: ARRAY
49410: PUSH
49411: LD_INT 1
49413: PLUS
49414: PUSH
49415: EMPTY
49416: LIST
49417: LIST
49418: PPUSH
49419: LD_VAR 0 1
49423: PPUSH
49424: CALL 57398 0 3
49428: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49429: LD_ADDR_VAR 0 6
49433: PUSH
49434: LD_EXP 74
49438: PUSH
49439: LD_VAR 0 3
49443: ARRAY
49444: PPUSH
49445: LD_INT 25
49447: PUSH
49448: LD_INT 1
49450: PUSH
49451: EMPTY
49452: LIST
49453: LIST
49454: PUSH
49455: LD_INT 3
49457: PUSH
49458: LD_INT 54
49460: PUSH
49461: EMPTY
49462: LIST
49463: PUSH
49464: EMPTY
49465: LIST
49466: LIST
49467: PUSH
49468: EMPTY
49469: LIST
49470: LIST
49471: PPUSH
49472: CALL_OW 72
49476: ST_TO_ADDR
// if tmp then
49477: LD_VAR 0 6
49481: IFFALSE 49487
// exit ;
49483: POP
49484: POP
49485: GO 49627
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49487: LD_ADDR_VAR 0 6
49491: PUSH
49492: LD_EXP 74
49496: PUSH
49497: LD_VAR 0 3
49501: ARRAY
49502: PPUSH
49503: LD_INT 2
49505: PUSH
49506: LD_INT 30
49508: PUSH
49509: LD_INT 4
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: PUSH
49516: LD_INT 30
49518: PUSH
49519: LD_INT 5
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: LIST
49530: PPUSH
49531: CALL_OW 72
49535: ST_TO_ADDR
// if not tmp then
49536: LD_VAR 0 6
49540: NOT
49541: IFFALSE 49547
// exit ;
49543: POP
49544: POP
49545: GO 49627
// for j in tmp do
49547: LD_ADDR_VAR 0 4
49551: PUSH
49552: LD_VAR 0 6
49556: PUSH
49557: FOR_IN
49558: IFFALSE 49617
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49560: LD_ADDR_VAR 0 7
49564: PUSH
49565: LD_VAR 0 4
49569: PPUSH
49570: CALL_OW 313
49574: PPUSH
49575: LD_INT 25
49577: PUSH
49578: LD_INT 1
49580: PUSH
49581: EMPTY
49582: LIST
49583: LIST
49584: PPUSH
49585: CALL_OW 72
49589: ST_TO_ADDR
// if units then
49590: LD_VAR 0 7
49594: IFFALSE 49615
// begin ComExitBuilding ( units [ 1 ] ) ;
49596: LD_VAR 0 7
49600: PUSH
49601: LD_INT 1
49603: ARRAY
49604: PPUSH
49605: CALL_OW 122
// exit ;
49609: POP
49610: POP
49611: POP
49612: POP
49613: GO 49627
// end ; end ;
49615: GO 49557
49617: POP
49618: POP
// end ; end ; exit ;
49619: POP
49620: POP
49621: GO 49627
// end ; end ;
49623: GO 48981
49625: POP
49626: POP
// end ;
49627: LD_VAR 0 2
49631: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49632: LD_INT 0
49634: PPUSH
49635: PPUSH
49636: PPUSH
49637: PPUSH
49638: PPUSH
49639: PPUSH
49640: PPUSH
// if not mc_bases or not skirmish then
49641: LD_EXP 74
49645: NOT
49646: PUSH
49647: LD_EXP 72
49651: NOT
49652: OR
49653: IFFALSE 49657
// exit ;
49655: GO 49888
// btype := GetBType ( building ) ;
49657: LD_ADDR_VAR 0 6
49661: PUSH
49662: LD_VAR 0 1
49666: PPUSH
49667: CALL_OW 266
49671: ST_TO_ADDR
// x := GetX ( building ) ;
49672: LD_ADDR_VAR 0 7
49676: PUSH
49677: LD_VAR 0 1
49681: PPUSH
49682: CALL_OW 250
49686: ST_TO_ADDR
// y := GetY ( building ) ;
49687: LD_ADDR_VAR 0 8
49691: PUSH
49692: LD_VAR 0 1
49696: PPUSH
49697: CALL_OW 251
49701: ST_TO_ADDR
// d := GetDir ( building ) ;
49702: LD_ADDR_VAR 0 9
49706: PUSH
49707: LD_VAR 0 1
49711: PPUSH
49712: CALL_OW 254
49716: ST_TO_ADDR
// for i = 1 to mc_bases do
49717: LD_ADDR_VAR 0 4
49721: PUSH
49722: DOUBLE
49723: LD_INT 1
49725: DEC
49726: ST_TO_ADDR
49727: LD_EXP 74
49731: PUSH
49732: FOR_TO
49733: IFFALSE 49886
// begin if not mc_build_list [ i ] then
49735: LD_EXP 79
49739: PUSH
49740: LD_VAR 0 4
49744: ARRAY
49745: NOT
49746: IFFALSE 49750
// continue ;
49748: GO 49732
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
49750: LD_VAR 0 6
49754: PUSH
49755: LD_VAR 0 7
49759: PUSH
49760: LD_VAR 0 8
49764: PUSH
49765: LD_VAR 0 9
49769: PUSH
49770: EMPTY
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: PPUSH
49776: LD_EXP 79
49780: PUSH
49781: LD_VAR 0 4
49785: ARRAY
49786: PUSH
49787: LD_INT 1
49789: ARRAY
49790: PPUSH
49791: CALL 63567 0 2
49795: IFFALSE 49884
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
49797: LD_ADDR_EXP 79
49801: PUSH
49802: LD_EXP 79
49806: PPUSH
49807: LD_VAR 0 4
49811: PPUSH
49812: LD_EXP 79
49816: PUSH
49817: LD_VAR 0 4
49821: ARRAY
49822: PPUSH
49823: LD_INT 1
49825: PPUSH
49826: CALL_OW 3
49830: PPUSH
49831: CALL_OW 1
49835: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
49836: LD_ADDR_EXP 81
49840: PUSH
49841: LD_EXP 81
49845: PPUSH
49846: LD_VAR 0 4
49850: PUSH
49851: LD_EXP 81
49855: PUSH
49856: LD_VAR 0 4
49860: ARRAY
49861: PUSH
49862: LD_INT 1
49864: PLUS
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: PPUSH
49870: LD_VAR 0 1
49874: PPUSH
49875: CALL 57398 0 3
49879: ST_TO_ADDR
// exit ;
49880: POP
49881: POP
49882: GO 49888
// end ; end ;
49884: GO 49732
49886: POP
49887: POP
// end ;
49888: LD_VAR 0 3
49892: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
49893: LD_INT 0
49895: PPUSH
49896: PPUSH
49897: PPUSH
// if not mc_bases or not skirmish then
49898: LD_EXP 74
49902: NOT
49903: PUSH
49904: LD_EXP 72
49908: NOT
49909: OR
49910: IFFALSE 49914
// exit ;
49912: GO 50104
// for i = 1 to mc_bases do
49914: LD_ADDR_VAR 0 4
49918: PUSH
49919: DOUBLE
49920: LD_INT 1
49922: DEC
49923: ST_TO_ADDR
49924: LD_EXP 74
49928: PUSH
49929: FOR_TO
49930: IFFALSE 50017
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
49932: LD_VAR 0 1
49936: PUSH
49937: LD_EXP 82
49941: PUSH
49942: LD_VAR 0 4
49946: ARRAY
49947: IN
49948: PUSH
49949: LD_VAR 0 1
49953: PUSH
49954: LD_EXP 83
49958: PUSH
49959: LD_VAR 0 4
49963: ARRAY
49964: IN
49965: NOT
49966: AND
49967: IFFALSE 50015
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49969: LD_ADDR_EXP 83
49973: PUSH
49974: LD_EXP 83
49978: PPUSH
49979: LD_VAR 0 4
49983: PUSH
49984: LD_EXP 83
49988: PUSH
49989: LD_VAR 0 4
49993: ARRAY
49994: PUSH
49995: LD_INT 1
49997: PLUS
49998: PUSH
49999: EMPTY
50000: LIST
50001: LIST
50002: PPUSH
50003: LD_VAR 0 1
50007: PPUSH
50008: CALL 57398 0 3
50012: ST_TO_ADDR
// break ;
50013: GO 50017
// end ; end ;
50015: GO 49929
50017: POP
50018: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50019: LD_VAR 0 1
50023: PPUSH
50024: CALL_OW 257
50028: PUSH
50029: LD_EXP 100
50033: IN
50034: PUSH
50035: LD_VAR 0 1
50039: PPUSH
50040: CALL_OW 266
50044: PUSH
50045: LD_INT 5
50047: EQUAL
50048: AND
50049: PUSH
50050: LD_VAR 0 2
50054: PPUSH
50055: CALL_OW 110
50059: PUSH
50060: LD_INT 18
50062: NONEQUAL
50063: AND
50064: IFFALSE 50104
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50066: LD_VAR 0 2
50070: PPUSH
50071: CALL_OW 257
50075: PUSH
50076: LD_INT 5
50078: PUSH
50079: LD_INT 8
50081: PUSH
50082: LD_INT 9
50084: PUSH
50085: EMPTY
50086: LIST
50087: LIST
50088: LIST
50089: IN
50090: IFFALSE 50104
// SetClass ( unit , 1 ) ;
50092: LD_VAR 0 2
50096: PPUSH
50097: LD_INT 1
50099: PPUSH
50100: CALL_OW 336
// end ;
50104: LD_VAR 0 3
50108: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50109: LD_INT 0
50111: PPUSH
50112: PPUSH
// if not mc_bases or not skirmish then
50113: LD_EXP 74
50117: NOT
50118: PUSH
50119: LD_EXP 72
50123: NOT
50124: OR
50125: IFFALSE 50129
// exit ;
50127: GO 50245
// if GetLives ( abandoned_vehicle ) > 250 then
50129: LD_VAR 0 2
50133: PPUSH
50134: CALL_OW 256
50138: PUSH
50139: LD_INT 250
50141: GREATER
50142: IFFALSE 50146
// exit ;
50144: GO 50245
// for i = 1 to mc_bases do
50146: LD_ADDR_VAR 0 6
50150: PUSH
50151: DOUBLE
50152: LD_INT 1
50154: DEC
50155: ST_TO_ADDR
50156: LD_EXP 74
50160: PUSH
50161: FOR_TO
50162: IFFALSE 50243
// begin if driver in mc_bases [ i ] then
50164: LD_VAR 0 1
50168: PUSH
50169: LD_EXP 74
50173: PUSH
50174: LD_VAR 0 6
50178: ARRAY
50179: IN
50180: IFFALSE 50241
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50182: LD_VAR 0 1
50186: PPUSH
50187: LD_EXP 74
50191: PUSH
50192: LD_VAR 0 6
50196: ARRAY
50197: PPUSH
50198: LD_INT 2
50200: PUSH
50201: LD_INT 30
50203: PUSH
50204: LD_INT 0
50206: PUSH
50207: EMPTY
50208: LIST
50209: LIST
50210: PUSH
50211: LD_INT 30
50213: PUSH
50214: LD_INT 1
50216: PUSH
50217: EMPTY
50218: LIST
50219: LIST
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: LIST
50225: PPUSH
50226: CALL_OW 72
50230: PUSH
50231: LD_INT 1
50233: ARRAY
50234: PPUSH
50235: CALL_OW 112
// break ;
50239: GO 50243
// end ; end ;
50241: GO 50161
50243: POP
50244: POP
// end ; end_of_file
50245: LD_VAR 0 5
50249: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50250: LD_INT 0
50252: PPUSH
50253: PPUSH
// if exist_mode then
50254: LD_VAR 0 2
50258: IFFALSE 50283
// unit := CreateCharacter ( prefix & ident ) else
50260: LD_ADDR_VAR 0 5
50264: PUSH
50265: LD_VAR 0 3
50269: PUSH
50270: LD_VAR 0 1
50274: STR
50275: PPUSH
50276: CALL_OW 34
50280: ST_TO_ADDR
50281: GO 50298
// unit := NewCharacter ( ident ) ;
50283: LD_ADDR_VAR 0 5
50287: PUSH
50288: LD_VAR 0 1
50292: PPUSH
50293: CALL_OW 25
50297: ST_TO_ADDR
// result := unit ;
50298: LD_ADDR_VAR 0 4
50302: PUSH
50303: LD_VAR 0 5
50307: ST_TO_ADDR
// end ;
50308: LD_VAR 0 4
50312: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50313: LD_INT 0
50315: PPUSH
50316: PPUSH
// if not side or not nation then
50317: LD_VAR 0 1
50321: NOT
50322: PUSH
50323: LD_VAR 0 2
50327: NOT
50328: OR
50329: IFFALSE 50333
// exit ;
50331: GO 50977
// case nation of nation_american :
50333: LD_VAR 0 2
50337: PUSH
50338: LD_INT 1
50340: DOUBLE
50341: EQUAL
50342: IFTRUE 50346
50344: GO 50520
50346: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
50347: LD_ADDR_VAR 0 4
50351: PUSH
50352: LD_INT 35
50354: PUSH
50355: LD_INT 45
50357: PUSH
50358: LD_INT 46
50360: PUSH
50361: LD_INT 47
50363: PUSH
50364: LD_INT 1
50366: PUSH
50367: LD_INT 2
50369: PUSH
50370: LD_INT 6
50372: PUSH
50373: LD_INT 15
50375: PUSH
50376: LD_INT 16
50378: PUSH
50379: LD_INT 7
50381: PUSH
50382: LD_INT 12
50384: PUSH
50385: LD_INT 13
50387: PUSH
50388: LD_INT 10
50390: PUSH
50391: LD_INT 14
50393: PUSH
50394: LD_INT 20
50396: PUSH
50397: LD_INT 21
50399: PUSH
50400: LD_INT 22
50402: PUSH
50403: LD_INT 25
50405: PUSH
50406: LD_INT 32
50408: PUSH
50409: LD_INT 27
50411: PUSH
50412: LD_INT 36
50414: PUSH
50415: LD_INT 69
50417: PUSH
50418: LD_INT 39
50420: PUSH
50421: LD_INT 34
50423: PUSH
50424: LD_INT 40
50426: PUSH
50427: LD_INT 48
50429: PUSH
50430: LD_INT 49
50432: PUSH
50433: LD_INT 50
50435: PUSH
50436: LD_INT 51
50438: PUSH
50439: LD_INT 52
50441: PUSH
50442: LD_INT 53
50444: PUSH
50445: LD_INT 54
50447: PUSH
50448: LD_INT 55
50450: PUSH
50451: LD_INT 56
50453: PUSH
50454: LD_INT 57
50456: PUSH
50457: LD_INT 58
50459: PUSH
50460: LD_INT 59
50462: PUSH
50463: LD_INT 60
50465: PUSH
50466: LD_INT 61
50468: PUSH
50469: LD_INT 62
50471: PUSH
50472: LD_INT 80
50474: PUSH
50475: EMPTY
50476: LIST
50477: LIST
50478: LIST
50479: LIST
50480: LIST
50481: LIST
50482: LIST
50483: LIST
50484: LIST
50485: LIST
50486: LIST
50487: LIST
50488: LIST
50489: LIST
50490: LIST
50491: LIST
50492: LIST
50493: LIST
50494: LIST
50495: LIST
50496: LIST
50497: LIST
50498: LIST
50499: LIST
50500: LIST
50501: LIST
50502: LIST
50503: LIST
50504: LIST
50505: LIST
50506: LIST
50507: LIST
50508: LIST
50509: LIST
50510: LIST
50511: LIST
50512: LIST
50513: LIST
50514: LIST
50515: LIST
50516: LIST
50517: ST_TO_ADDR
50518: GO 50901
50520: LD_INT 2
50522: DOUBLE
50523: EQUAL
50524: IFTRUE 50528
50526: GO 50710
50528: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50529: LD_ADDR_VAR 0 4
50533: PUSH
50534: LD_INT 35
50536: PUSH
50537: LD_INT 45
50539: PUSH
50540: LD_INT 46
50542: PUSH
50543: LD_INT 47
50545: PUSH
50546: LD_INT 70
50548: PUSH
50549: LD_INT 1
50551: PUSH
50552: LD_INT 11
50554: PUSH
50555: LD_INT 3
50557: PUSH
50558: LD_INT 4
50560: PUSH
50561: LD_INT 5
50563: PUSH
50564: LD_INT 6
50566: PUSH
50567: LD_INT 15
50569: PUSH
50570: LD_INT 18
50572: PUSH
50573: LD_INT 7
50575: PUSH
50576: LD_INT 17
50578: PUSH
50579: LD_INT 8
50581: PUSH
50582: LD_INT 20
50584: PUSH
50585: LD_INT 21
50587: PUSH
50588: LD_INT 22
50590: PUSH
50591: LD_INT 72
50593: PUSH
50594: LD_INT 26
50596: PUSH
50597: LD_INT 69
50599: PUSH
50600: LD_INT 39
50602: PUSH
50603: LD_INT 40
50605: PUSH
50606: LD_INT 41
50608: PUSH
50609: LD_INT 42
50611: PUSH
50612: LD_INT 43
50614: PUSH
50615: LD_INT 48
50617: PUSH
50618: LD_INT 49
50620: PUSH
50621: LD_INT 50
50623: PUSH
50624: LD_INT 51
50626: PUSH
50627: LD_INT 52
50629: PUSH
50630: LD_INT 53
50632: PUSH
50633: LD_INT 54
50635: PUSH
50636: LD_INT 55
50638: PUSH
50639: LD_INT 56
50641: PUSH
50642: LD_INT 60
50644: PUSH
50645: LD_INT 61
50647: PUSH
50648: LD_INT 62
50650: PUSH
50651: LD_INT 66
50653: PUSH
50654: LD_INT 67
50656: PUSH
50657: LD_INT 68
50659: PUSH
50660: LD_INT 81
50662: PUSH
50663: EMPTY
50664: LIST
50665: LIST
50666: LIST
50667: LIST
50668: LIST
50669: LIST
50670: LIST
50671: LIST
50672: LIST
50673: LIST
50674: LIST
50675: LIST
50676: LIST
50677: LIST
50678: LIST
50679: LIST
50680: LIST
50681: LIST
50682: LIST
50683: LIST
50684: LIST
50685: LIST
50686: LIST
50687: LIST
50688: LIST
50689: LIST
50690: LIST
50691: LIST
50692: LIST
50693: LIST
50694: LIST
50695: LIST
50696: LIST
50697: LIST
50698: LIST
50699: LIST
50700: LIST
50701: LIST
50702: LIST
50703: LIST
50704: LIST
50705: LIST
50706: LIST
50707: ST_TO_ADDR
50708: GO 50901
50710: LD_INT 3
50712: DOUBLE
50713: EQUAL
50714: IFTRUE 50718
50716: GO 50900
50718: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
50719: LD_ADDR_VAR 0 4
50723: PUSH
50724: LD_INT 46
50726: PUSH
50727: LD_INT 47
50729: PUSH
50730: LD_INT 1
50732: PUSH
50733: LD_INT 2
50735: PUSH
50736: LD_INT 11
50738: PUSH
50739: LD_INT 9
50741: PUSH
50742: LD_INT 20
50744: PUSH
50745: LD_INT 19
50747: PUSH
50748: LD_INT 21
50750: PUSH
50751: LD_INT 24
50753: PUSH
50754: LD_INT 22
50756: PUSH
50757: LD_INT 25
50759: PUSH
50760: LD_INT 28
50762: PUSH
50763: LD_INT 29
50765: PUSH
50766: LD_INT 30
50768: PUSH
50769: LD_INT 31
50771: PUSH
50772: LD_INT 37
50774: PUSH
50775: LD_INT 38
50777: PUSH
50778: LD_INT 32
50780: PUSH
50781: LD_INT 27
50783: PUSH
50784: LD_INT 33
50786: PUSH
50787: LD_INT 69
50789: PUSH
50790: LD_INT 39
50792: PUSH
50793: LD_INT 34
50795: PUSH
50796: LD_INT 40
50798: PUSH
50799: LD_INT 71
50801: PUSH
50802: LD_INT 23
50804: PUSH
50805: LD_INT 44
50807: PUSH
50808: LD_INT 48
50810: PUSH
50811: LD_INT 49
50813: PUSH
50814: LD_INT 50
50816: PUSH
50817: LD_INT 51
50819: PUSH
50820: LD_INT 52
50822: PUSH
50823: LD_INT 53
50825: PUSH
50826: LD_INT 54
50828: PUSH
50829: LD_INT 55
50831: PUSH
50832: LD_INT 56
50834: PUSH
50835: LD_INT 57
50837: PUSH
50838: LD_INT 58
50840: PUSH
50841: LD_INT 59
50843: PUSH
50844: LD_INT 63
50846: PUSH
50847: LD_INT 64
50849: PUSH
50850: LD_INT 65
50852: PUSH
50853: EMPTY
50854: LIST
50855: LIST
50856: LIST
50857: LIST
50858: LIST
50859: LIST
50860: LIST
50861: LIST
50862: LIST
50863: LIST
50864: LIST
50865: LIST
50866: LIST
50867: LIST
50868: LIST
50869: LIST
50870: LIST
50871: LIST
50872: LIST
50873: LIST
50874: LIST
50875: LIST
50876: LIST
50877: LIST
50878: LIST
50879: LIST
50880: LIST
50881: LIST
50882: LIST
50883: LIST
50884: LIST
50885: LIST
50886: LIST
50887: LIST
50888: LIST
50889: LIST
50890: LIST
50891: LIST
50892: LIST
50893: LIST
50894: LIST
50895: LIST
50896: LIST
50897: ST_TO_ADDR
50898: GO 50901
50900: POP
// if state > - 1 and state < 3 then
50901: LD_VAR 0 3
50905: PUSH
50906: LD_INT 1
50908: NEG
50909: GREATER
50910: PUSH
50911: LD_VAR 0 3
50915: PUSH
50916: LD_INT 3
50918: LESS
50919: AND
50920: IFFALSE 50977
// for i in result do
50922: LD_ADDR_VAR 0 5
50926: PUSH
50927: LD_VAR 0 4
50931: PUSH
50932: FOR_IN
50933: IFFALSE 50975
// if GetTech ( i , side ) <> state then
50935: LD_VAR 0 5
50939: PPUSH
50940: LD_VAR 0 1
50944: PPUSH
50945: CALL_OW 321
50949: PUSH
50950: LD_VAR 0 3
50954: NONEQUAL
50955: IFFALSE 50973
// result := result diff i ;
50957: LD_ADDR_VAR 0 4
50961: PUSH
50962: LD_VAR 0 4
50966: PUSH
50967: LD_VAR 0 5
50971: DIFF
50972: ST_TO_ADDR
50973: GO 50932
50975: POP
50976: POP
// end ;
50977: LD_VAR 0 4
50981: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50982: LD_INT 0
50984: PPUSH
50985: PPUSH
50986: PPUSH
// result := true ;
50987: LD_ADDR_VAR 0 3
50991: PUSH
50992: LD_INT 1
50994: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50995: LD_ADDR_VAR 0 5
50999: PUSH
51000: LD_VAR 0 2
51004: PPUSH
51005: CALL_OW 480
51009: ST_TO_ADDR
// if not tmp then
51010: LD_VAR 0 5
51014: NOT
51015: IFFALSE 51019
// exit ;
51017: GO 51068
// for i in tmp do
51019: LD_ADDR_VAR 0 4
51023: PUSH
51024: LD_VAR 0 5
51028: PUSH
51029: FOR_IN
51030: IFFALSE 51066
// if GetTech ( i , side ) <> state_researched then
51032: LD_VAR 0 4
51036: PPUSH
51037: LD_VAR 0 1
51041: PPUSH
51042: CALL_OW 321
51046: PUSH
51047: LD_INT 2
51049: NONEQUAL
51050: IFFALSE 51064
// begin result := false ;
51052: LD_ADDR_VAR 0 3
51056: PUSH
51057: LD_INT 0
51059: ST_TO_ADDR
// exit ;
51060: POP
51061: POP
51062: GO 51068
// end ;
51064: GO 51029
51066: POP
51067: POP
// end ;
51068: LD_VAR 0 3
51072: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51073: LD_INT 0
51075: PPUSH
51076: PPUSH
51077: PPUSH
51078: PPUSH
51079: PPUSH
51080: PPUSH
51081: PPUSH
51082: PPUSH
51083: PPUSH
51084: PPUSH
51085: PPUSH
51086: PPUSH
51087: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51088: LD_VAR 0 1
51092: NOT
51093: PUSH
51094: LD_VAR 0 1
51098: PPUSH
51099: CALL_OW 257
51103: PUSH
51104: LD_INT 9
51106: NONEQUAL
51107: OR
51108: IFFALSE 51112
// exit ;
51110: GO 51685
// side := GetSide ( unit ) ;
51112: LD_ADDR_VAR 0 9
51116: PUSH
51117: LD_VAR 0 1
51121: PPUSH
51122: CALL_OW 255
51126: ST_TO_ADDR
// tech_space := tech_spacanom ;
51127: LD_ADDR_VAR 0 12
51131: PUSH
51132: LD_INT 29
51134: ST_TO_ADDR
// tech_time := tech_taurad ;
51135: LD_ADDR_VAR 0 13
51139: PUSH
51140: LD_INT 28
51142: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51143: LD_ADDR_VAR 0 11
51147: PUSH
51148: LD_VAR 0 1
51152: PPUSH
51153: CALL_OW 310
51157: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51158: LD_VAR 0 11
51162: PPUSH
51163: CALL_OW 247
51167: PUSH
51168: LD_INT 2
51170: EQUAL
51171: IFFALSE 51175
// exit ;
51173: GO 51685
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51175: LD_ADDR_VAR 0 8
51179: PUSH
51180: LD_INT 81
51182: PUSH
51183: LD_VAR 0 9
51187: PUSH
51188: EMPTY
51189: LIST
51190: LIST
51191: PUSH
51192: LD_INT 3
51194: PUSH
51195: LD_INT 21
51197: PUSH
51198: LD_INT 3
51200: PUSH
51201: EMPTY
51202: LIST
51203: LIST
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: PUSH
51209: EMPTY
51210: LIST
51211: LIST
51212: PPUSH
51213: CALL_OW 69
51217: ST_TO_ADDR
// if not tmp then
51218: LD_VAR 0 8
51222: NOT
51223: IFFALSE 51227
// exit ;
51225: GO 51685
// if in_unit then
51227: LD_VAR 0 11
51231: IFFALSE 51255
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51233: LD_ADDR_VAR 0 10
51237: PUSH
51238: LD_VAR 0 8
51242: PPUSH
51243: LD_VAR 0 11
51247: PPUSH
51248: CALL_OW 74
51252: ST_TO_ADDR
51253: GO 51275
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51255: LD_ADDR_VAR 0 10
51259: PUSH
51260: LD_VAR 0 8
51264: PPUSH
51265: LD_VAR 0 1
51269: PPUSH
51270: CALL_OW 74
51274: ST_TO_ADDR
// if not enemy then
51275: LD_VAR 0 10
51279: NOT
51280: IFFALSE 51284
// exit ;
51282: GO 51685
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51284: LD_VAR 0 11
51288: PUSH
51289: LD_VAR 0 11
51293: PPUSH
51294: LD_VAR 0 10
51298: PPUSH
51299: CALL_OW 296
51303: PUSH
51304: LD_INT 13
51306: GREATER
51307: AND
51308: PUSH
51309: LD_VAR 0 1
51313: PPUSH
51314: LD_VAR 0 10
51318: PPUSH
51319: CALL_OW 296
51323: PUSH
51324: LD_INT 12
51326: GREATER
51327: OR
51328: IFFALSE 51332
// exit ;
51330: GO 51685
// missile := [ 1 ] ;
51332: LD_ADDR_VAR 0 14
51336: PUSH
51337: LD_INT 1
51339: PUSH
51340: EMPTY
51341: LIST
51342: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51343: LD_VAR 0 9
51347: PPUSH
51348: LD_VAR 0 12
51352: PPUSH
51353: CALL_OW 325
51357: IFFALSE 51386
// missile := Insert ( missile , missile + 1 , 2 ) ;
51359: LD_ADDR_VAR 0 14
51363: PUSH
51364: LD_VAR 0 14
51368: PPUSH
51369: LD_VAR 0 14
51373: PUSH
51374: LD_INT 1
51376: PLUS
51377: PPUSH
51378: LD_INT 2
51380: PPUSH
51381: CALL_OW 2
51385: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51386: LD_VAR 0 9
51390: PPUSH
51391: LD_VAR 0 13
51395: PPUSH
51396: CALL_OW 325
51400: PUSH
51401: LD_VAR 0 10
51405: PPUSH
51406: CALL_OW 255
51410: PPUSH
51411: LD_VAR 0 13
51415: PPUSH
51416: CALL_OW 325
51420: NOT
51421: AND
51422: IFFALSE 51451
// missile := Insert ( missile , missile + 1 , 3 ) ;
51424: LD_ADDR_VAR 0 14
51428: PUSH
51429: LD_VAR 0 14
51433: PPUSH
51434: LD_VAR 0 14
51438: PUSH
51439: LD_INT 1
51441: PLUS
51442: PPUSH
51443: LD_INT 3
51445: PPUSH
51446: CALL_OW 2
51450: ST_TO_ADDR
// if missile < 2 then
51451: LD_VAR 0 14
51455: PUSH
51456: LD_INT 2
51458: LESS
51459: IFFALSE 51463
// exit ;
51461: GO 51685
// x := GetX ( enemy ) ;
51463: LD_ADDR_VAR 0 4
51467: PUSH
51468: LD_VAR 0 10
51472: PPUSH
51473: CALL_OW 250
51477: ST_TO_ADDR
// y := GetY ( enemy ) ;
51478: LD_ADDR_VAR 0 5
51482: PUSH
51483: LD_VAR 0 10
51487: PPUSH
51488: CALL_OW 251
51492: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51493: LD_ADDR_VAR 0 6
51497: PUSH
51498: LD_VAR 0 4
51502: PUSH
51503: LD_INT 1
51505: NEG
51506: PPUSH
51507: LD_INT 1
51509: PPUSH
51510: CALL_OW 12
51514: PLUS
51515: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51516: LD_ADDR_VAR 0 7
51520: PUSH
51521: LD_VAR 0 5
51525: PUSH
51526: LD_INT 1
51528: NEG
51529: PPUSH
51530: LD_INT 1
51532: PPUSH
51533: CALL_OW 12
51537: PLUS
51538: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51539: LD_VAR 0 6
51543: PPUSH
51544: LD_VAR 0 7
51548: PPUSH
51549: CALL_OW 488
51553: NOT
51554: IFFALSE 51576
// begin _x := x ;
51556: LD_ADDR_VAR 0 6
51560: PUSH
51561: LD_VAR 0 4
51565: ST_TO_ADDR
// _y := y ;
51566: LD_ADDR_VAR 0 7
51570: PUSH
51571: LD_VAR 0 5
51575: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51576: LD_ADDR_VAR 0 3
51580: PUSH
51581: LD_INT 1
51583: PPUSH
51584: LD_VAR 0 14
51588: PPUSH
51589: CALL_OW 12
51593: ST_TO_ADDR
// case i of 1 :
51594: LD_VAR 0 3
51598: PUSH
51599: LD_INT 1
51601: DOUBLE
51602: EQUAL
51603: IFTRUE 51607
51605: GO 51624
51607: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51608: LD_VAR 0 1
51612: PPUSH
51613: LD_VAR 0 10
51617: PPUSH
51618: CALL_OW 115
51622: GO 51685
51624: LD_INT 2
51626: DOUBLE
51627: EQUAL
51628: IFTRUE 51632
51630: GO 51654
51632: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51633: LD_VAR 0 1
51637: PPUSH
51638: LD_VAR 0 6
51642: PPUSH
51643: LD_VAR 0 7
51647: PPUSH
51648: CALL_OW 153
51652: GO 51685
51654: LD_INT 3
51656: DOUBLE
51657: EQUAL
51658: IFTRUE 51662
51660: GO 51684
51662: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51663: LD_VAR 0 1
51667: PPUSH
51668: LD_VAR 0 6
51672: PPUSH
51673: LD_VAR 0 7
51677: PPUSH
51678: CALL_OW 154
51682: GO 51685
51684: POP
// end ;
51685: LD_VAR 0 2
51689: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51690: LD_INT 0
51692: PPUSH
51693: PPUSH
51694: PPUSH
51695: PPUSH
51696: PPUSH
51697: PPUSH
// if not unit or not building then
51698: LD_VAR 0 1
51702: NOT
51703: PUSH
51704: LD_VAR 0 2
51708: NOT
51709: OR
51710: IFFALSE 51714
// exit ;
51712: GO 51872
// x := GetX ( building ) ;
51714: LD_ADDR_VAR 0 5
51718: PUSH
51719: LD_VAR 0 2
51723: PPUSH
51724: CALL_OW 250
51728: ST_TO_ADDR
// y := GetY ( building ) ;
51729: LD_ADDR_VAR 0 6
51733: PUSH
51734: LD_VAR 0 2
51738: PPUSH
51739: CALL_OW 251
51743: ST_TO_ADDR
// for i = 0 to 5 do
51744: LD_ADDR_VAR 0 4
51748: PUSH
51749: DOUBLE
51750: LD_INT 0
51752: DEC
51753: ST_TO_ADDR
51754: LD_INT 5
51756: PUSH
51757: FOR_TO
51758: IFFALSE 51870
// begin _x := ShiftX ( x , i , 3 ) ;
51760: LD_ADDR_VAR 0 7
51764: PUSH
51765: LD_VAR 0 5
51769: PPUSH
51770: LD_VAR 0 4
51774: PPUSH
51775: LD_INT 3
51777: PPUSH
51778: CALL_OW 272
51782: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
51783: LD_ADDR_VAR 0 8
51787: PUSH
51788: LD_VAR 0 6
51792: PPUSH
51793: LD_VAR 0 4
51797: PPUSH
51798: LD_INT 3
51800: PPUSH
51801: CALL_OW 273
51805: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51806: LD_VAR 0 7
51810: PPUSH
51811: LD_VAR 0 8
51815: PPUSH
51816: CALL_OW 488
51820: NOT
51821: IFFALSE 51825
// continue ;
51823: GO 51757
// if HexInfo ( _x , _y ) = 0 then
51825: LD_VAR 0 7
51829: PPUSH
51830: LD_VAR 0 8
51834: PPUSH
51835: CALL_OW 428
51839: PUSH
51840: LD_INT 0
51842: EQUAL
51843: IFFALSE 51868
// begin ComMoveXY ( unit , _x , _y ) ;
51845: LD_VAR 0 1
51849: PPUSH
51850: LD_VAR 0 7
51854: PPUSH
51855: LD_VAR 0 8
51859: PPUSH
51860: CALL_OW 111
// exit ;
51864: POP
51865: POP
51866: GO 51872
// end ; end ;
51868: GO 51757
51870: POP
51871: POP
// end ;
51872: LD_VAR 0 3
51876: RET
// export function ScanBase ( side , base_area ) ; begin
51877: LD_INT 0
51879: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
51880: LD_ADDR_VAR 0 3
51884: PUSH
51885: LD_VAR 0 2
51889: PPUSH
51890: LD_INT 81
51892: PUSH
51893: LD_VAR 0 1
51897: PUSH
51898: EMPTY
51899: LIST
51900: LIST
51901: PPUSH
51902: CALL_OW 70
51906: ST_TO_ADDR
// end ;
51907: LD_VAR 0 3
51911: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
51912: LD_INT 0
51914: PPUSH
51915: PPUSH
51916: PPUSH
51917: PPUSH
51918: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
51919: LD_VAR 0 1
51923: NOT
51924: PUSH
51925: LD_EXP 74
51929: PUSH
51930: LD_VAR 0 1
51934: ARRAY
51935: NOT
51936: OR
51937: PUSH
51938: LD_VAR 0 2
51942: NOT
51943: OR
51944: PUSH
51945: LD_VAR 0 3
51949: NOT
51950: OR
51951: IFFALSE 51955
// exit ;
51953: GO 52468
// side := mc_sides [ base ] ;
51955: LD_ADDR_VAR 0 6
51959: PUSH
51960: LD_EXP 100
51964: PUSH
51965: LD_VAR 0 1
51969: ARRAY
51970: ST_TO_ADDR
// if not side then
51971: LD_VAR 0 6
51975: NOT
51976: IFFALSE 51980
// exit ;
51978: GO 52468
// for i in solds do
51980: LD_ADDR_VAR 0 7
51984: PUSH
51985: LD_VAR 0 2
51989: PUSH
51990: FOR_IN
51991: IFFALSE 52052
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
51993: LD_VAR 0 7
51997: PPUSH
51998: CALL_OW 310
52002: PPUSH
52003: CALL_OW 266
52007: PUSH
52008: LD_INT 32
52010: PUSH
52011: LD_INT 31
52013: PUSH
52014: EMPTY
52015: LIST
52016: LIST
52017: IN
52018: IFFALSE 52038
// solds := solds diff i else
52020: LD_ADDR_VAR 0 2
52024: PUSH
52025: LD_VAR 0 2
52029: PUSH
52030: LD_VAR 0 7
52034: DIFF
52035: ST_TO_ADDR
52036: GO 52050
// SetTag ( i , 18 ) ;
52038: LD_VAR 0 7
52042: PPUSH
52043: LD_INT 18
52045: PPUSH
52046: CALL_OW 109
52050: GO 51990
52052: POP
52053: POP
// if not solds then
52054: LD_VAR 0 2
52058: NOT
52059: IFFALSE 52063
// exit ;
52061: GO 52468
// repeat wait ( 0 0$1 ) ;
52063: LD_INT 35
52065: PPUSH
52066: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
52070: LD_ADDR_VAR 0 5
52074: PUSH
52075: LD_VAR 0 6
52079: PPUSH
52080: LD_VAR 0 3
52084: PPUSH
52085: CALL 51877 0 2
52089: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52090: LD_EXP 74
52094: PUSH
52095: LD_VAR 0 1
52099: ARRAY
52100: NOT
52101: PUSH
52102: LD_EXP 74
52106: PUSH
52107: LD_VAR 0 1
52111: ARRAY
52112: PUSH
52113: EMPTY
52114: EQUAL
52115: OR
52116: IFFALSE 52153
// begin for i in solds do
52118: LD_ADDR_VAR 0 7
52122: PUSH
52123: LD_VAR 0 2
52127: PUSH
52128: FOR_IN
52129: IFFALSE 52142
// ComStop ( i ) ;
52131: LD_VAR 0 7
52135: PPUSH
52136: CALL_OW 141
52140: GO 52128
52142: POP
52143: POP
// solds := [ ] ;
52144: LD_ADDR_VAR 0 2
52148: PUSH
52149: EMPTY
52150: ST_TO_ADDR
// exit ;
52151: GO 52468
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
52153: LD_VAR 0 5
52157: NOT
52158: PUSH
52159: LD_VAR 0 5
52163: PUSH
52164: LD_INT 3
52166: GREATER
52167: OR
52168: PUSH
52169: LD_EXP 96
52173: PUSH
52174: LD_VAR 0 1
52178: ARRAY
52179: OR
52180: IFFALSE 52221
// begin for i in solds do
52182: LD_ADDR_VAR 0 7
52186: PUSH
52187: LD_VAR 0 2
52191: PUSH
52192: FOR_IN
52193: IFFALSE 52217
// if HasTask ( i ) then
52195: LD_VAR 0 7
52199: PPUSH
52200: CALL_OW 314
52204: IFFALSE 52215
// ComStop ( i ) ;
52206: LD_VAR 0 7
52210: PPUSH
52211: CALL_OW 141
52215: GO 52192
52217: POP
52218: POP
// break ;
52219: GO 52456
// end ; for i in solds do
52221: LD_ADDR_VAR 0 7
52225: PUSH
52226: LD_VAR 0 2
52230: PUSH
52231: FOR_IN
52232: IFFALSE 52448
// begin if IsInUnit ( i ) then
52234: LD_VAR 0 7
52238: PPUSH
52239: CALL_OW 310
52243: IFFALSE 52254
// ComExitBuilding ( i ) ;
52245: LD_VAR 0 7
52249: PPUSH
52250: CALL_OW 122
// if GetLives ( i ) > 333 then
52254: LD_VAR 0 7
52258: PPUSH
52259: CALL_OW 256
52263: PUSH
52264: LD_INT 333
52266: GREATER
52267: IFFALSE 52295
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52269: LD_VAR 0 7
52273: PPUSH
52274: LD_VAR 0 5
52278: PPUSH
52279: LD_VAR 0 7
52283: PPUSH
52284: CALL_OW 74
52288: PPUSH
52289: CALL_OW 115
52293: GO 52446
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
52295: LD_ADDR_VAR 0 8
52299: PUSH
52300: LD_EXP 74
52304: PUSH
52305: LD_VAR 0 1
52309: ARRAY
52310: PPUSH
52311: LD_INT 2
52313: PUSH
52314: LD_INT 30
52316: PUSH
52317: LD_INT 0
52319: PUSH
52320: EMPTY
52321: LIST
52322: LIST
52323: PUSH
52324: LD_INT 30
52326: PUSH
52327: LD_INT 1
52329: PUSH
52330: EMPTY
52331: LIST
52332: LIST
52333: PUSH
52334: LD_INT 30
52336: PUSH
52337: LD_INT 6
52339: PUSH
52340: EMPTY
52341: LIST
52342: LIST
52343: PUSH
52344: EMPTY
52345: LIST
52346: LIST
52347: LIST
52348: LIST
52349: PPUSH
52350: CALL_OW 72
52354: PPUSH
52355: LD_VAR 0 7
52359: PPUSH
52360: CALL_OW 74
52364: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52365: LD_VAR 0 7
52369: PPUSH
52370: LD_VAR 0 8
52374: PPUSH
52375: CALL_OW 250
52379: PPUSH
52380: LD_INT 3
52382: PPUSH
52383: LD_INT 5
52385: PPUSH
52386: CALL_OW 272
52390: PPUSH
52391: LD_VAR 0 8
52395: PPUSH
52396: CALL_OW 251
52400: PPUSH
52401: LD_INT 3
52403: PPUSH
52404: LD_INT 5
52406: PPUSH
52407: CALL_OW 273
52411: PPUSH
52412: CALL_OW 111
// SetTag ( i , 0 ) ;
52416: LD_VAR 0 7
52420: PPUSH
52421: LD_INT 0
52423: PPUSH
52424: CALL_OW 109
// solds := solds diff i ;
52428: LD_ADDR_VAR 0 2
52432: PUSH
52433: LD_VAR 0 2
52437: PUSH
52438: LD_VAR 0 7
52442: DIFF
52443: ST_TO_ADDR
// continue ;
52444: GO 52231
// end ; end ;
52446: GO 52231
52448: POP
52449: POP
// until solds ;
52450: LD_VAR 0 2
52454: IFFALSE 52063
// MC_Reset ( base , 18 ) ;
52456: LD_VAR 0 1
52460: PPUSH
52461: LD_INT 18
52463: PPUSH
52464: CALL 24185 0 2
// end ;
52468: LD_VAR 0 4
52472: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52473: LD_INT 0
52475: PPUSH
52476: PPUSH
52477: PPUSH
52478: PPUSH
52479: PPUSH
52480: PPUSH
52481: PPUSH
52482: PPUSH
52483: PPUSH
52484: PPUSH
52485: PPUSH
52486: PPUSH
52487: PPUSH
52488: PPUSH
52489: PPUSH
52490: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52491: LD_ADDR_VAR 0 12
52495: PUSH
52496: LD_EXP 74
52500: PUSH
52501: LD_VAR 0 1
52505: ARRAY
52506: PPUSH
52507: LD_INT 25
52509: PUSH
52510: LD_INT 3
52512: PUSH
52513: EMPTY
52514: LIST
52515: LIST
52516: PPUSH
52517: CALL_OW 72
52521: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52522: LD_EXP 114
52526: PUSH
52527: LD_VAR 0 1
52531: ARRAY
52532: IFFALSE 52556
// mechs := mechs diff mc_remote_driver [ base ] ;
52534: LD_ADDR_VAR 0 12
52538: PUSH
52539: LD_VAR 0 12
52543: PUSH
52544: LD_EXP 114
52548: PUSH
52549: LD_VAR 0 1
52553: ARRAY
52554: DIFF
52555: ST_TO_ADDR
// for i in mechs do
52556: LD_ADDR_VAR 0 5
52560: PUSH
52561: LD_VAR 0 12
52565: PUSH
52566: FOR_IN
52567: IFFALSE 52602
// if GetTag ( i ) > 0 then
52569: LD_VAR 0 5
52573: PPUSH
52574: CALL_OW 110
52578: PUSH
52579: LD_INT 0
52581: GREATER
52582: IFFALSE 52600
// mechs := mechs diff i ;
52584: LD_ADDR_VAR 0 12
52588: PUSH
52589: LD_VAR 0 12
52593: PUSH
52594: LD_VAR 0 5
52598: DIFF
52599: ST_TO_ADDR
52600: GO 52566
52602: POP
52603: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52604: LD_ADDR_VAR 0 8
52608: PUSH
52609: LD_EXP 74
52613: PUSH
52614: LD_VAR 0 1
52618: ARRAY
52619: PPUSH
52620: LD_INT 2
52622: PUSH
52623: LD_INT 25
52625: PUSH
52626: LD_INT 1
52628: PUSH
52629: EMPTY
52630: LIST
52631: LIST
52632: PUSH
52633: LD_INT 25
52635: PUSH
52636: LD_INT 5
52638: PUSH
52639: EMPTY
52640: LIST
52641: LIST
52642: PUSH
52643: LD_INT 25
52645: PUSH
52646: LD_INT 8
52648: PUSH
52649: EMPTY
52650: LIST
52651: LIST
52652: PUSH
52653: LD_INT 25
52655: PUSH
52656: LD_INT 9
52658: PUSH
52659: EMPTY
52660: LIST
52661: LIST
52662: PUSH
52663: EMPTY
52664: LIST
52665: LIST
52666: LIST
52667: LIST
52668: LIST
52669: PPUSH
52670: CALL_OW 72
52674: ST_TO_ADDR
// if not defenders and not solds then
52675: LD_VAR 0 2
52679: NOT
52680: PUSH
52681: LD_VAR 0 8
52685: NOT
52686: AND
52687: IFFALSE 52691
// exit ;
52689: GO 54229
// depot_under_attack := false ;
52691: LD_ADDR_VAR 0 16
52695: PUSH
52696: LD_INT 0
52698: ST_TO_ADDR
// sold_defenders := [ ] ;
52699: LD_ADDR_VAR 0 17
52703: PUSH
52704: EMPTY
52705: ST_TO_ADDR
// if mechs then
52706: LD_VAR 0 12
52710: IFFALSE 52839
// for i in defenders do
52712: LD_ADDR_VAR 0 5
52716: PUSH
52717: LD_VAR 0 2
52721: PUSH
52722: FOR_IN
52723: IFFALSE 52837
// begin SetTag ( i , 20 ) ;
52725: LD_VAR 0 5
52729: PPUSH
52730: LD_INT 20
52732: PPUSH
52733: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
52737: LD_VAR 0 5
52741: PPUSH
52742: CALL_OW 263
52746: PUSH
52747: LD_INT 1
52749: EQUAL
52750: PUSH
52751: LD_VAR 0 5
52755: PPUSH
52756: CALL_OW 311
52760: NOT
52761: AND
52762: PUSH
52763: LD_VAR 0 12
52767: AND
52768: IFFALSE 52835
// begin un := mechs [ 1 ] ;
52770: LD_ADDR_VAR 0 10
52774: PUSH
52775: LD_VAR 0 12
52779: PUSH
52780: LD_INT 1
52782: ARRAY
52783: ST_TO_ADDR
// ComExitBuilding ( un ) ;
52784: LD_VAR 0 10
52788: PPUSH
52789: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
52793: LD_VAR 0 10
52797: PPUSH
52798: LD_VAR 0 5
52802: PPUSH
52803: CALL_OW 180
// SetTag ( un , 19 ) ;
52807: LD_VAR 0 10
52811: PPUSH
52812: LD_INT 19
52814: PPUSH
52815: CALL_OW 109
// mechs := mechs diff un ;
52819: LD_ADDR_VAR 0 12
52823: PUSH
52824: LD_VAR 0 12
52828: PUSH
52829: LD_VAR 0 10
52833: DIFF
52834: ST_TO_ADDR
// end ; end ;
52835: GO 52722
52837: POP
52838: POP
// if solds then
52839: LD_VAR 0 8
52843: IFFALSE 52902
// for i in solds do
52845: LD_ADDR_VAR 0 5
52849: PUSH
52850: LD_VAR 0 8
52854: PUSH
52855: FOR_IN
52856: IFFALSE 52900
// if not GetTag ( i ) then
52858: LD_VAR 0 5
52862: PPUSH
52863: CALL_OW 110
52867: NOT
52868: IFFALSE 52898
// begin defenders := defenders union i ;
52870: LD_ADDR_VAR 0 2
52874: PUSH
52875: LD_VAR 0 2
52879: PUSH
52880: LD_VAR 0 5
52884: UNION
52885: ST_TO_ADDR
// SetTag ( i , 18 ) ;
52886: LD_VAR 0 5
52890: PPUSH
52891: LD_INT 18
52893: PPUSH
52894: CALL_OW 109
// end ;
52898: GO 52855
52900: POP
52901: POP
// repeat wait ( 0 0$1 ) ;
52902: LD_INT 35
52904: PPUSH
52905: CALL_OW 67
// enemy := mc_scan [ base ] ;
52909: LD_ADDR_VAR 0 3
52913: PUSH
52914: LD_EXP 97
52918: PUSH
52919: LD_VAR 0 1
52923: ARRAY
52924: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52925: LD_EXP 74
52929: PUSH
52930: LD_VAR 0 1
52934: ARRAY
52935: NOT
52936: PUSH
52937: LD_EXP 74
52941: PUSH
52942: LD_VAR 0 1
52946: ARRAY
52947: PUSH
52948: EMPTY
52949: EQUAL
52950: OR
52951: IFFALSE 52988
// begin for i in defenders do
52953: LD_ADDR_VAR 0 5
52957: PUSH
52958: LD_VAR 0 2
52962: PUSH
52963: FOR_IN
52964: IFFALSE 52977
// ComStop ( i ) ;
52966: LD_VAR 0 5
52970: PPUSH
52971: CALL_OW 141
52975: GO 52963
52977: POP
52978: POP
// defenders := [ ] ;
52979: LD_ADDR_VAR 0 2
52983: PUSH
52984: EMPTY
52985: ST_TO_ADDR
// exit ;
52986: GO 54229
// end ; for i in defenders do
52988: LD_ADDR_VAR 0 5
52992: PUSH
52993: LD_VAR 0 2
52997: PUSH
52998: FOR_IN
52999: IFFALSE 53729
// begin e := NearestUnitToUnit ( enemy , i ) ;
53001: LD_ADDR_VAR 0 13
53005: PUSH
53006: LD_VAR 0 3
53010: PPUSH
53011: LD_VAR 0 5
53015: PPUSH
53016: CALL_OW 74
53020: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
53021: LD_ADDR_VAR 0 16
53025: PUSH
53026: LD_EXP 74
53030: PUSH
53031: LD_VAR 0 1
53035: ARRAY
53036: PPUSH
53037: LD_INT 2
53039: PUSH
53040: LD_INT 30
53042: PUSH
53043: LD_INT 0
53045: PUSH
53046: EMPTY
53047: LIST
53048: LIST
53049: PUSH
53050: LD_INT 30
53052: PUSH
53053: LD_INT 1
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: PUSH
53060: EMPTY
53061: LIST
53062: LIST
53063: LIST
53064: PPUSH
53065: CALL_OW 72
53069: NOT
53070: PUSH
53071: LD_EXP 74
53075: PUSH
53076: LD_VAR 0 1
53080: ARRAY
53081: PPUSH
53082: LD_INT 2
53084: PUSH
53085: LD_INT 30
53087: PUSH
53088: LD_INT 0
53090: PUSH
53091: EMPTY
53092: LIST
53093: LIST
53094: PUSH
53095: LD_INT 30
53097: PUSH
53098: LD_INT 1
53100: PUSH
53101: EMPTY
53102: LIST
53103: LIST
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: LIST
53109: PPUSH
53110: CALL_OW 72
53114: PPUSH
53115: CALL_OW 256
53119: PUSH
53120: LD_INT 600
53122: LESS
53123: OR
53124: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
53125: LD_VAR 0 5
53129: PPUSH
53130: CALL_OW 247
53134: PUSH
53135: LD_INT 2
53137: DOUBLE
53138: EQUAL
53139: IFTRUE 53143
53141: GO 53435
53143: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
53144: LD_VAR 0 5
53148: PPUSH
53149: CALL_OW 256
53153: PUSH
53154: LD_INT 650
53156: GREATER
53157: PUSH
53158: LD_VAR 0 5
53162: PPUSH
53163: LD_VAR 0 13
53167: PPUSH
53168: CALL_OW 296
53172: PUSH
53173: LD_INT 40
53175: LESS
53176: PUSH
53177: LD_VAR 0 13
53181: PPUSH
53182: LD_EXP 99
53186: PUSH
53187: LD_VAR 0 1
53191: ARRAY
53192: PPUSH
53193: CALL_OW 308
53197: OR
53198: AND
53199: IFFALSE 53217
// ComAttackUnit ( i , e ) else
53201: LD_VAR 0 5
53205: PPUSH
53206: LD_VAR 0 13
53210: PPUSH
53211: CALL_OW 115
53215: GO 53318
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
53217: LD_VAR 0 13
53221: PPUSH
53222: LD_EXP 99
53226: PUSH
53227: LD_VAR 0 1
53231: ARRAY
53232: PPUSH
53233: CALL_OW 308
53237: NOT
53238: PUSH
53239: LD_VAR 0 5
53243: PPUSH
53244: LD_VAR 0 13
53248: PPUSH
53249: CALL_OW 296
53253: PUSH
53254: LD_INT 40
53256: GREATEREQUAL
53257: AND
53258: PUSH
53259: LD_VAR 0 5
53263: PPUSH
53264: CALL_OW 256
53268: PUSH
53269: LD_INT 650
53271: LESSEQUAL
53272: OR
53273: PUSH
53274: LD_VAR 0 5
53278: PPUSH
53279: LD_EXP 98
53283: PUSH
53284: LD_VAR 0 1
53288: ARRAY
53289: PPUSH
53290: CALL_OW 308
53294: NOT
53295: AND
53296: IFFALSE 53318
// ComMoveToArea ( i , mc_parking [ base ] ) ;
53298: LD_VAR 0 5
53302: PPUSH
53303: LD_EXP 98
53307: PUSH
53308: LD_VAR 0 1
53312: ARRAY
53313: PPUSH
53314: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
53318: LD_VAR 0 5
53322: PPUSH
53323: CALL_OW 256
53327: PUSH
53328: LD_INT 998
53330: LESS
53331: PUSH
53332: LD_VAR 0 5
53336: PPUSH
53337: CALL_OW 263
53341: PUSH
53342: LD_INT 1
53344: EQUAL
53345: AND
53346: PUSH
53347: LD_VAR 0 5
53351: PPUSH
53352: CALL_OW 311
53356: AND
53357: PUSH
53358: LD_VAR 0 5
53362: PPUSH
53363: LD_EXP 98
53367: PUSH
53368: LD_VAR 0 1
53372: ARRAY
53373: PPUSH
53374: CALL_OW 308
53378: AND
53379: IFFALSE 53433
// begin mech := IsDrivenBy ( i ) ;
53381: LD_ADDR_VAR 0 9
53385: PUSH
53386: LD_VAR 0 5
53390: PPUSH
53391: CALL_OW 311
53395: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53396: LD_VAR 0 9
53400: PPUSH
53401: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53405: LD_VAR 0 9
53409: PPUSH
53410: LD_VAR 0 5
53414: PPUSH
53415: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53419: LD_VAR 0 9
53423: PPUSH
53424: LD_VAR 0 5
53428: PPUSH
53429: CALL_OW 180
// end ; end ; unit_human :
53433: GO 53700
53435: LD_INT 1
53437: DOUBLE
53438: EQUAL
53439: IFTRUE 53443
53441: GO 53699
53443: POP
// begin b := IsInUnit ( i ) ;
53444: LD_ADDR_VAR 0 18
53448: PUSH
53449: LD_VAR 0 5
53453: PPUSH
53454: CALL_OW 310
53458: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53459: LD_ADDR_VAR 0 19
53463: PUSH
53464: LD_VAR 0 18
53468: NOT
53469: PUSH
53470: LD_VAR 0 18
53474: PPUSH
53475: CALL_OW 266
53479: PUSH
53480: LD_INT 32
53482: PUSH
53483: LD_INT 31
53485: PUSH
53486: EMPTY
53487: LIST
53488: LIST
53489: IN
53490: OR
53491: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53492: LD_VAR 0 16
53496: PUSH
53497: LD_VAR 0 2
53501: PPUSH
53502: LD_INT 21
53504: PUSH
53505: LD_INT 2
53507: PUSH
53508: EMPTY
53509: LIST
53510: LIST
53511: PPUSH
53512: CALL_OW 72
53516: PUSH
53517: LD_INT 1
53519: LESSEQUAL
53520: OR
53521: PUSH
53522: LD_VAR 0 19
53526: AND
53527: PUSH
53528: LD_VAR 0 5
53532: PUSH
53533: LD_VAR 0 17
53537: IN
53538: NOT
53539: AND
53540: IFFALSE 53633
// begin if b then
53542: LD_VAR 0 18
53546: IFFALSE 53595
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53548: LD_VAR 0 18
53552: PPUSH
53553: LD_VAR 0 3
53557: PPUSH
53558: LD_VAR 0 18
53562: PPUSH
53563: CALL_OW 74
53567: PPUSH
53568: CALL_OW 296
53572: PUSH
53573: LD_INT 10
53575: LESS
53576: PUSH
53577: LD_VAR 0 18
53581: PPUSH
53582: CALL_OW 461
53586: PUSH
53587: LD_INT 7
53589: NONEQUAL
53590: AND
53591: IFFALSE 53595
// continue ;
53593: GO 52998
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53595: LD_ADDR_VAR 0 17
53599: PUSH
53600: LD_VAR 0 17
53604: PPUSH
53605: LD_VAR 0 17
53609: PUSH
53610: LD_INT 1
53612: PLUS
53613: PPUSH
53614: LD_VAR 0 5
53618: PPUSH
53619: CALL_OW 1
53623: ST_TO_ADDR
// ComExitBuilding ( i ) ;
53624: LD_VAR 0 5
53628: PPUSH
53629: CALL_OW 122
// end ; if sold_defenders then
53633: LD_VAR 0 17
53637: IFFALSE 53697
// if i in sold_defenders then
53639: LD_VAR 0 5
53643: PUSH
53644: LD_VAR 0 17
53648: IN
53649: IFFALSE 53697
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
53651: LD_VAR 0 5
53655: PPUSH
53656: CALL_OW 314
53660: NOT
53661: PUSH
53662: LD_VAR 0 5
53666: PPUSH
53667: LD_VAR 0 13
53671: PPUSH
53672: CALL_OW 296
53676: PUSH
53677: LD_INT 30
53679: LESS
53680: AND
53681: IFFALSE 53697
// ComAttackUnit ( i , e ) ;
53683: LD_VAR 0 5
53687: PPUSH
53688: LD_VAR 0 13
53692: PPUSH
53693: CALL_OW 115
// end ; end ; end ;
53697: GO 53700
53699: POP
// if IsDead ( i ) then
53700: LD_VAR 0 5
53704: PPUSH
53705: CALL_OW 301
53709: IFFALSE 53727
// defenders := defenders diff i ;
53711: LD_ADDR_VAR 0 2
53715: PUSH
53716: LD_VAR 0 2
53720: PUSH
53721: LD_VAR 0 5
53725: DIFF
53726: ST_TO_ADDR
// end ;
53727: GO 52998
53729: POP
53730: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
53731: LD_VAR 0 3
53735: NOT
53736: PUSH
53737: LD_VAR 0 2
53741: NOT
53742: OR
53743: PUSH
53744: LD_EXP 74
53748: PUSH
53749: LD_VAR 0 1
53753: ARRAY
53754: NOT
53755: OR
53756: IFFALSE 52902
// MC_Reset ( base , 18 ) ;
53758: LD_VAR 0 1
53762: PPUSH
53763: LD_INT 18
53765: PPUSH
53766: CALL 24185 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53770: LD_ADDR_VAR 0 2
53774: PUSH
53775: LD_VAR 0 2
53779: PUSH
53780: LD_VAR 0 2
53784: PPUSH
53785: LD_INT 2
53787: PUSH
53788: LD_INT 25
53790: PUSH
53791: LD_INT 1
53793: PUSH
53794: EMPTY
53795: LIST
53796: LIST
53797: PUSH
53798: LD_INT 25
53800: PUSH
53801: LD_INT 5
53803: PUSH
53804: EMPTY
53805: LIST
53806: LIST
53807: PUSH
53808: LD_INT 25
53810: PUSH
53811: LD_INT 8
53813: PUSH
53814: EMPTY
53815: LIST
53816: LIST
53817: PUSH
53818: LD_INT 25
53820: PUSH
53821: LD_INT 9
53823: PUSH
53824: EMPTY
53825: LIST
53826: LIST
53827: PUSH
53828: EMPTY
53829: LIST
53830: LIST
53831: LIST
53832: LIST
53833: LIST
53834: PPUSH
53835: CALL_OW 72
53839: DIFF
53840: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
53841: LD_VAR 0 3
53845: NOT
53846: PUSH
53847: LD_VAR 0 2
53851: PPUSH
53852: LD_INT 21
53854: PUSH
53855: LD_INT 2
53857: PUSH
53858: EMPTY
53859: LIST
53860: LIST
53861: PPUSH
53862: CALL_OW 72
53866: AND
53867: IFFALSE 54205
// begin tmp := FilterByTag ( defenders , 19 ) ;
53869: LD_ADDR_VAR 0 11
53873: PUSH
53874: LD_VAR 0 2
53878: PPUSH
53879: LD_INT 19
53881: PPUSH
53882: CALL 90658 0 2
53886: ST_TO_ADDR
// if tmp then
53887: LD_VAR 0 11
53891: IFFALSE 53961
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
53893: LD_ADDR_VAR 0 11
53897: PUSH
53898: LD_VAR 0 11
53902: PPUSH
53903: LD_INT 25
53905: PUSH
53906: LD_INT 3
53908: PUSH
53909: EMPTY
53910: LIST
53911: LIST
53912: PPUSH
53913: CALL_OW 72
53917: ST_TO_ADDR
// if tmp then
53918: LD_VAR 0 11
53922: IFFALSE 53961
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
53924: LD_ADDR_EXP 86
53928: PUSH
53929: LD_EXP 86
53933: PPUSH
53934: LD_VAR 0 1
53938: PPUSH
53939: LD_EXP 86
53943: PUSH
53944: LD_VAR 0 1
53948: ARRAY
53949: PUSH
53950: LD_VAR 0 11
53954: UNION
53955: PPUSH
53956: CALL_OW 1
53960: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
53961: LD_VAR 0 1
53965: PPUSH
53966: LD_INT 19
53968: PPUSH
53969: CALL 24185 0 2
// repeat wait ( 0 0$1 ) ;
53973: LD_INT 35
53975: PPUSH
53976: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53980: LD_EXP 74
53984: PUSH
53985: LD_VAR 0 1
53989: ARRAY
53990: NOT
53991: PUSH
53992: LD_EXP 74
53996: PUSH
53997: LD_VAR 0 1
54001: ARRAY
54002: PUSH
54003: EMPTY
54004: EQUAL
54005: OR
54006: IFFALSE 54043
// begin for i in defenders do
54008: LD_ADDR_VAR 0 5
54012: PUSH
54013: LD_VAR 0 2
54017: PUSH
54018: FOR_IN
54019: IFFALSE 54032
// ComStop ( i ) ;
54021: LD_VAR 0 5
54025: PPUSH
54026: CALL_OW 141
54030: GO 54018
54032: POP
54033: POP
// defenders := [ ] ;
54034: LD_ADDR_VAR 0 2
54038: PUSH
54039: EMPTY
54040: ST_TO_ADDR
// exit ;
54041: GO 54229
// end ; for i in defenders do
54043: LD_ADDR_VAR 0 5
54047: PUSH
54048: LD_VAR 0 2
54052: PUSH
54053: FOR_IN
54054: IFFALSE 54143
// begin if not IsInArea ( i , mc_parking [ base ] ) then
54056: LD_VAR 0 5
54060: PPUSH
54061: LD_EXP 98
54065: PUSH
54066: LD_VAR 0 1
54070: ARRAY
54071: PPUSH
54072: CALL_OW 308
54076: NOT
54077: IFFALSE 54101
// ComMoveToArea ( i , mc_parking [ base ] ) else
54079: LD_VAR 0 5
54083: PPUSH
54084: LD_EXP 98
54088: PUSH
54089: LD_VAR 0 1
54093: ARRAY
54094: PPUSH
54095: CALL_OW 113
54099: GO 54141
// if GetControl ( i ) = control_manual then
54101: LD_VAR 0 5
54105: PPUSH
54106: CALL_OW 263
54110: PUSH
54111: LD_INT 1
54113: EQUAL
54114: IFFALSE 54141
// if IsDrivenBy ( i ) then
54116: LD_VAR 0 5
54120: PPUSH
54121: CALL_OW 311
54125: IFFALSE 54141
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
54127: LD_VAR 0 5
54131: PPUSH
54132: CALL_OW 311
54136: PPUSH
54137: CALL_OW 121
// end ;
54141: GO 54053
54143: POP
54144: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
54145: LD_VAR 0 2
54149: PPUSH
54150: LD_INT 95
54152: PUSH
54153: LD_EXP 98
54157: PUSH
54158: LD_VAR 0 1
54162: ARRAY
54163: PUSH
54164: EMPTY
54165: LIST
54166: LIST
54167: PPUSH
54168: CALL_OW 72
54172: PUSH
54173: LD_VAR 0 2
54177: EQUAL
54178: PUSH
54179: LD_EXP 97
54183: PUSH
54184: LD_VAR 0 1
54188: ARRAY
54189: OR
54190: PUSH
54191: LD_EXP 74
54195: PUSH
54196: LD_VAR 0 1
54200: ARRAY
54201: NOT
54202: OR
54203: IFFALSE 53973
// end ; MC_Reset ( base , 19 ) ;
54205: LD_VAR 0 1
54209: PPUSH
54210: LD_INT 19
54212: PPUSH
54213: CALL 24185 0 2
// MC_Reset ( base , 20 ) ;
54217: LD_VAR 0 1
54221: PPUSH
54222: LD_INT 20
54224: PPUSH
54225: CALL 24185 0 2
// end ;
54229: LD_VAR 0 4
54233: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54234: LD_INT 0
54236: PPUSH
54237: PPUSH
54238: PPUSH
54239: PPUSH
// result := false ;
54240: LD_ADDR_VAR 0 2
54244: PUSH
54245: LD_INT 0
54247: ST_TO_ADDR
// side := GetSide ( unit ) ;
54248: LD_ADDR_VAR 0 3
54252: PUSH
54253: LD_VAR 0 1
54257: PPUSH
54258: CALL_OW 255
54262: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54263: LD_ADDR_VAR 0 4
54267: PUSH
54268: LD_VAR 0 1
54272: PPUSH
54273: CALL_OW 248
54277: ST_TO_ADDR
// case nat of 1 :
54278: LD_VAR 0 4
54282: PUSH
54283: LD_INT 1
54285: DOUBLE
54286: EQUAL
54287: IFTRUE 54291
54289: GO 54302
54291: POP
// tech := tech_lassight ; 2 :
54292: LD_ADDR_VAR 0 5
54296: PUSH
54297: LD_INT 12
54299: ST_TO_ADDR
54300: GO 54341
54302: LD_INT 2
54304: DOUBLE
54305: EQUAL
54306: IFTRUE 54310
54308: GO 54321
54310: POP
// tech := tech_mortar ; 3 :
54311: LD_ADDR_VAR 0 5
54315: PUSH
54316: LD_INT 41
54318: ST_TO_ADDR
54319: GO 54341
54321: LD_INT 3
54323: DOUBLE
54324: EQUAL
54325: IFTRUE 54329
54327: GO 54340
54329: POP
// tech := tech_bazooka ; end ;
54330: LD_ADDR_VAR 0 5
54334: PUSH
54335: LD_INT 44
54337: ST_TO_ADDR
54338: GO 54341
54340: POP
// if Researched ( side , tech ) then
54341: LD_VAR 0 3
54345: PPUSH
54346: LD_VAR 0 5
54350: PPUSH
54351: CALL_OW 325
54355: IFFALSE 54382
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54357: LD_ADDR_VAR 0 2
54361: PUSH
54362: LD_INT 5
54364: PUSH
54365: LD_INT 8
54367: PUSH
54368: LD_INT 9
54370: PUSH
54371: EMPTY
54372: LIST
54373: LIST
54374: LIST
54375: PUSH
54376: LD_VAR 0 4
54380: ARRAY
54381: ST_TO_ADDR
// end ;
54382: LD_VAR 0 2
54386: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54387: LD_INT 0
54389: PPUSH
54390: PPUSH
54391: PPUSH
// if not mines then
54392: LD_VAR 0 2
54396: NOT
54397: IFFALSE 54401
// exit ;
54399: GO 54545
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54401: LD_ADDR_VAR 0 5
54405: PUSH
54406: LD_INT 81
54408: PUSH
54409: LD_VAR 0 1
54413: PUSH
54414: EMPTY
54415: LIST
54416: LIST
54417: PUSH
54418: LD_INT 3
54420: PUSH
54421: LD_INT 21
54423: PUSH
54424: LD_INT 3
54426: PUSH
54427: EMPTY
54428: LIST
54429: LIST
54430: PUSH
54431: EMPTY
54432: LIST
54433: LIST
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: PPUSH
54439: CALL_OW 69
54443: ST_TO_ADDR
// for i in mines do
54444: LD_ADDR_VAR 0 4
54448: PUSH
54449: LD_VAR 0 2
54453: PUSH
54454: FOR_IN
54455: IFFALSE 54543
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54457: LD_VAR 0 4
54461: PUSH
54462: LD_INT 1
54464: ARRAY
54465: PPUSH
54466: LD_VAR 0 4
54470: PUSH
54471: LD_INT 2
54473: ARRAY
54474: PPUSH
54475: CALL_OW 458
54479: NOT
54480: IFFALSE 54484
// continue ;
54482: GO 54454
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54484: LD_VAR 0 4
54488: PUSH
54489: LD_INT 1
54491: ARRAY
54492: PPUSH
54493: LD_VAR 0 4
54497: PUSH
54498: LD_INT 2
54500: ARRAY
54501: PPUSH
54502: CALL_OW 428
54506: PUSH
54507: LD_VAR 0 5
54511: IN
54512: IFFALSE 54541
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54514: LD_VAR 0 4
54518: PUSH
54519: LD_INT 1
54521: ARRAY
54522: PPUSH
54523: LD_VAR 0 4
54527: PUSH
54528: LD_INT 2
54530: ARRAY
54531: PPUSH
54532: LD_VAR 0 1
54536: PPUSH
54537: CALL_OW 456
// end ;
54541: GO 54454
54543: POP
54544: POP
// end ;
54545: LD_VAR 0 3
54549: RET
// export function Count ( array ) ; var i ; begin
54550: LD_INT 0
54552: PPUSH
54553: PPUSH
// result := 0 ;
54554: LD_ADDR_VAR 0 2
54558: PUSH
54559: LD_INT 0
54561: ST_TO_ADDR
// for i in array do
54562: LD_ADDR_VAR 0 3
54566: PUSH
54567: LD_VAR 0 1
54571: PUSH
54572: FOR_IN
54573: IFFALSE 54597
// if i then
54575: LD_VAR 0 3
54579: IFFALSE 54595
// result := result + 1 ;
54581: LD_ADDR_VAR 0 2
54585: PUSH
54586: LD_VAR 0 2
54590: PUSH
54591: LD_INT 1
54593: PLUS
54594: ST_TO_ADDR
54595: GO 54572
54597: POP
54598: POP
// end ;
54599: LD_VAR 0 2
54603: RET
// export function IsEmpty ( building ) ; begin
54604: LD_INT 0
54606: PPUSH
// if not building then
54607: LD_VAR 0 1
54611: NOT
54612: IFFALSE 54616
// exit ;
54614: GO 54659
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54616: LD_ADDR_VAR 0 2
54620: PUSH
54621: LD_VAR 0 1
54625: PUSH
54626: LD_INT 22
54628: PUSH
54629: LD_VAR 0 1
54633: PPUSH
54634: CALL_OW 255
54638: PUSH
54639: EMPTY
54640: LIST
54641: LIST
54642: PUSH
54643: LD_INT 58
54645: PUSH
54646: EMPTY
54647: LIST
54648: PUSH
54649: EMPTY
54650: LIST
54651: LIST
54652: PPUSH
54653: CALL_OW 69
54657: IN
54658: ST_TO_ADDR
// end ;
54659: LD_VAR 0 2
54663: RET
// export function IsNotFull ( building ) ; begin
54664: LD_INT 0
54666: PPUSH
// if not building then
54667: LD_VAR 0 1
54671: NOT
54672: IFFALSE 54676
// exit ;
54674: GO 54695
// result := UnitsInside ( building ) < 6 ;
54676: LD_ADDR_VAR 0 2
54680: PUSH
54681: LD_VAR 0 1
54685: PPUSH
54686: CALL_OW 313
54690: PUSH
54691: LD_INT 6
54693: LESS
54694: ST_TO_ADDR
// end ;
54695: LD_VAR 0 2
54699: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54700: LD_INT 0
54702: PPUSH
54703: PPUSH
54704: PPUSH
54705: PPUSH
// tmp := [ ] ;
54706: LD_ADDR_VAR 0 3
54710: PUSH
54711: EMPTY
54712: ST_TO_ADDR
// list := [ ] ;
54713: LD_ADDR_VAR 0 5
54717: PUSH
54718: EMPTY
54719: ST_TO_ADDR
// for i = 16 to 25 do
54720: LD_ADDR_VAR 0 4
54724: PUSH
54725: DOUBLE
54726: LD_INT 16
54728: DEC
54729: ST_TO_ADDR
54730: LD_INT 25
54732: PUSH
54733: FOR_TO
54734: IFFALSE 54807
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54736: LD_ADDR_VAR 0 3
54740: PUSH
54741: LD_VAR 0 3
54745: PUSH
54746: LD_INT 22
54748: PUSH
54749: LD_VAR 0 1
54753: PPUSH
54754: CALL_OW 255
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: PUSH
54763: LD_INT 91
54765: PUSH
54766: LD_VAR 0 1
54770: PUSH
54771: LD_INT 6
54773: PUSH
54774: EMPTY
54775: LIST
54776: LIST
54777: LIST
54778: PUSH
54779: LD_INT 30
54781: PUSH
54782: LD_VAR 0 4
54786: PUSH
54787: EMPTY
54788: LIST
54789: LIST
54790: PUSH
54791: EMPTY
54792: LIST
54793: LIST
54794: LIST
54795: PUSH
54796: EMPTY
54797: LIST
54798: PPUSH
54799: CALL_OW 69
54803: ADD
54804: ST_TO_ADDR
54805: GO 54733
54807: POP
54808: POP
// for i = 1 to tmp do
54809: LD_ADDR_VAR 0 4
54813: PUSH
54814: DOUBLE
54815: LD_INT 1
54817: DEC
54818: ST_TO_ADDR
54819: LD_VAR 0 3
54823: PUSH
54824: FOR_TO
54825: IFFALSE 54913
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54827: LD_ADDR_VAR 0 5
54831: PUSH
54832: LD_VAR 0 5
54836: PUSH
54837: LD_VAR 0 3
54841: PUSH
54842: LD_VAR 0 4
54846: ARRAY
54847: PPUSH
54848: CALL_OW 266
54852: PUSH
54853: LD_VAR 0 3
54857: PUSH
54858: LD_VAR 0 4
54862: ARRAY
54863: PPUSH
54864: CALL_OW 250
54868: PUSH
54869: LD_VAR 0 3
54873: PUSH
54874: LD_VAR 0 4
54878: ARRAY
54879: PPUSH
54880: CALL_OW 251
54884: PUSH
54885: LD_VAR 0 3
54889: PUSH
54890: LD_VAR 0 4
54894: ARRAY
54895: PPUSH
54896: CALL_OW 254
54900: PUSH
54901: EMPTY
54902: LIST
54903: LIST
54904: LIST
54905: LIST
54906: PUSH
54907: EMPTY
54908: LIST
54909: ADD
54910: ST_TO_ADDR
54911: GO 54824
54913: POP
54914: POP
// result := list ;
54915: LD_ADDR_VAR 0 2
54919: PUSH
54920: LD_VAR 0 5
54924: ST_TO_ADDR
// end ;
54925: LD_VAR 0 2
54929: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54930: LD_INT 0
54932: PPUSH
54933: PPUSH
54934: PPUSH
54935: PPUSH
54936: PPUSH
54937: PPUSH
54938: PPUSH
// if not factory then
54939: LD_VAR 0 1
54943: NOT
54944: IFFALSE 54948
// exit ;
54946: GO 55541
// if control = control_apeman then
54948: LD_VAR 0 4
54952: PUSH
54953: LD_INT 5
54955: EQUAL
54956: IFFALSE 55065
// begin tmp := UnitsInside ( factory ) ;
54958: LD_ADDR_VAR 0 8
54962: PUSH
54963: LD_VAR 0 1
54967: PPUSH
54968: CALL_OW 313
54972: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54973: LD_VAR 0 8
54977: PPUSH
54978: LD_INT 25
54980: PUSH
54981: LD_INT 12
54983: PUSH
54984: EMPTY
54985: LIST
54986: LIST
54987: PPUSH
54988: CALL_OW 72
54992: NOT
54993: IFFALSE 55003
// control := control_manual ;
54995: LD_ADDR_VAR 0 4
54999: PUSH
55000: LD_INT 1
55002: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55003: LD_ADDR_VAR 0 8
55007: PUSH
55008: LD_VAR 0 1
55012: PPUSH
55013: CALL 54700 0 1
55017: ST_TO_ADDR
// if tmp then
55018: LD_VAR 0 8
55022: IFFALSE 55065
// begin for i in tmp do
55024: LD_ADDR_VAR 0 7
55028: PUSH
55029: LD_VAR 0 8
55033: PUSH
55034: FOR_IN
55035: IFFALSE 55063
// if i [ 1 ] = b_ext_radio then
55037: LD_VAR 0 7
55041: PUSH
55042: LD_INT 1
55044: ARRAY
55045: PUSH
55046: LD_INT 22
55048: EQUAL
55049: IFFALSE 55061
// begin control := control_remote ;
55051: LD_ADDR_VAR 0 4
55055: PUSH
55056: LD_INT 2
55058: ST_TO_ADDR
// break ;
55059: GO 55063
// end ;
55061: GO 55034
55063: POP
55064: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55065: LD_VAR 0 1
55069: PPUSH
55070: LD_VAR 0 2
55074: PPUSH
55075: LD_VAR 0 3
55079: PPUSH
55080: LD_VAR 0 4
55084: PPUSH
55085: LD_VAR 0 5
55089: PPUSH
55090: CALL_OW 448
55094: IFFALSE 55129
// begin result := [ chassis , engine , control , weapon ] ;
55096: LD_ADDR_VAR 0 6
55100: PUSH
55101: LD_VAR 0 2
55105: PUSH
55106: LD_VAR 0 3
55110: PUSH
55111: LD_VAR 0 4
55115: PUSH
55116: LD_VAR 0 5
55120: PUSH
55121: EMPTY
55122: LIST
55123: LIST
55124: LIST
55125: LIST
55126: ST_TO_ADDR
// exit ;
55127: GO 55541
// end ; _chassis := AvailableChassisList ( factory ) ;
55129: LD_ADDR_VAR 0 9
55133: PUSH
55134: LD_VAR 0 1
55138: PPUSH
55139: CALL_OW 475
55143: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55144: LD_ADDR_VAR 0 11
55148: PUSH
55149: LD_VAR 0 1
55153: PPUSH
55154: CALL_OW 476
55158: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55159: LD_ADDR_VAR 0 12
55163: PUSH
55164: LD_VAR 0 1
55168: PPUSH
55169: CALL_OW 477
55173: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55174: LD_ADDR_VAR 0 10
55178: PUSH
55179: LD_VAR 0 1
55183: PPUSH
55184: CALL_OW 478
55188: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55189: LD_VAR 0 9
55193: NOT
55194: PUSH
55195: LD_VAR 0 11
55199: NOT
55200: OR
55201: PUSH
55202: LD_VAR 0 12
55206: NOT
55207: OR
55208: PUSH
55209: LD_VAR 0 10
55213: NOT
55214: OR
55215: IFFALSE 55250
// begin result := [ chassis , engine , control , weapon ] ;
55217: LD_ADDR_VAR 0 6
55221: PUSH
55222: LD_VAR 0 2
55226: PUSH
55227: LD_VAR 0 3
55231: PUSH
55232: LD_VAR 0 4
55236: PUSH
55237: LD_VAR 0 5
55241: PUSH
55242: EMPTY
55243: LIST
55244: LIST
55245: LIST
55246: LIST
55247: ST_TO_ADDR
// exit ;
55248: GO 55541
// end ; if not chassis in _chassis then
55250: LD_VAR 0 2
55254: PUSH
55255: LD_VAR 0 9
55259: IN
55260: NOT
55261: IFFALSE 55287
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55263: LD_ADDR_VAR 0 2
55267: PUSH
55268: LD_VAR 0 9
55272: PUSH
55273: LD_INT 1
55275: PPUSH
55276: LD_VAR 0 9
55280: PPUSH
55281: CALL_OW 12
55285: ARRAY
55286: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55287: LD_VAR 0 2
55291: PPUSH
55292: LD_VAR 0 3
55296: PPUSH
55297: CALL 55546 0 2
55301: NOT
55302: IFFALSE 55361
// repeat engine := _engine [ 1 ] ;
55304: LD_ADDR_VAR 0 3
55308: PUSH
55309: LD_VAR 0 11
55313: PUSH
55314: LD_INT 1
55316: ARRAY
55317: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55318: LD_ADDR_VAR 0 11
55322: PUSH
55323: LD_VAR 0 11
55327: PPUSH
55328: LD_INT 1
55330: PPUSH
55331: CALL_OW 3
55335: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55336: LD_VAR 0 2
55340: PPUSH
55341: LD_VAR 0 3
55345: PPUSH
55346: CALL 55546 0 2
55350: PUSH
55351: LD_VAR 0 11
55355: PUSH
55356: EMPTY
55357: EQUAL
55358: OR
55359: IFFALSE 55304
// if not control in _control then
55361: LD_VAR 0 4
55365: PUSH
55366: LD_VAR 0 12
55370: IN
55371: NOT
55372: IFFALSE 55398
// control := _control [ rand ( 1 , _control ) ] ;
55374: LD_ADDR_VAR 0 4
55378: PUSH
55379: LD_VAR 0 12
55383: PUSH
55384: LD_INT 1
55386: PPUSH
55387: LD_VAR 0 12
55391: PPUSH
55392: CALL_OW 12
55396: ARRAY
55397: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55398: LD_VAR 0 2
55402: PPUSH
55403: LD_VAR 0 5
55407: PPUSH
55408: CALL 55766 0 2
55412: NOT
55413: IFFALSE 55472
// repeat weapon := _weapon [ 1 ] ;
55415: LD_ADDR_VAR 0 5
55419: PUSH
55420: LD_VAR 0 10
55424: PUSH
55425: LD_INT 1
55427: ARRAY
55428: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55429: LD_ADDR_VAR 0 10
55433: PUSH
55434: LD_VAR 0 10
55438: PPUSH
55439: LD_INT 1
55441: PPUSH
55442: CALL_OW 3
55446: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55447: LD_VAR 0 2
55451: PPUSH
55452: LD_VAR 0 5
55456: PPUSH
55457: CALL 55766 0 2
55461: PUSH
55462: LD_VAR 0 10
55466: PUSH
55467: EMPTY
55468: EQUAL
55469: OR
55470: IFFALSE 55415
// result := [ ] ;
55472: LD_ADDR_VAR 0 6
55476: PUSH
55477: EMPTY
55478: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55479: LD_VAR 0 1
55483: PPUSH
55484: LD_VAR 0 2
55488: PPUSH
55489: LD_VAR 0 3
55493: PPUSH
55494: LD_VAR 0 4
55498: PPUSH
55499: LD_VAR 0 5
55503: PPUSH
55504: CALL_OW 448
55508: IFFALSE 55541
// result := [ chassis , engine , control , weapon ] ;
55510: LD_ADDR_VAR 0 6
55514: PUSH
55515: LD_VAR 0 2
55519: PUSH
55520: LD_VAR 0 3
55524: PUSH
55525: LD_VAR 0 4
55529: PUSH
55530: LD_VAR 0 5
55534: PUSH
55535: EMPTY
55536: LIST
55537: LIST
55538: LIST
55539: LIST
55540: ST_TO_ADDR
// end ;
55541: LD_VAR 0 6
55545: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55546: LD_INT 0
55548: PPUSH
// if not chassis or not engine then
55549: LD_VAR 0 1
55553: NOT
55554: PUSH
55555: LD_VAR 0 2
55559: NOT
55560: OR
55561: IFFALSE 55565
// exit ;
55563: GO 55761
// case engine of engine_solar :
55565: LD_VAR 0 2
55569: PUSH
55570: LD_INT 2
55572: DOUBLE
55573: EQUAL
55574: IFTRUE 55578
55576: GO 55616
55578: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55579: LD_ADDR_VAR 0 3
55583: PUSH
55584: LD_INT 11
55586: PUSH
55587: LD_INT 12
55589: PUSH
55590: LD_INT 13
55592: PUSH
55593: LD_INT 14
55595: PUSH
55596: LD_INT 1
55598: PUSH
55599: LD_INT 2
55601: PUSH
55602: LD_INT 3
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: LIST
55609: LIST
55610: LIST
55611: LIST
55612: LIST
55613: ST_TO_ADDR
55614: GO 55745
55616: LD_INT 1
55618: DOUBLE
55619: EQUAL
55620: IFTRUE 55624
55622: GO 55686
55624: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55625: LD_ADDR_VAR 0 3
55629: PUSH
55630: LD_INT 11
55632: PUSH
55633: LD_INT 12
55635: PUSH
55636: LD_INT 13
55638: PUSH
55639: LD_INT 14
55641: PUSH
55642: LD_INT 1
55644: PUSH
55645: LD_INT 2
55647: PUSH
55648: LD_INT 3
55650: PUSH
55651: LD_INT 4
55653: PUSH
55654: LD_INT 5
55656: PUSH
55657: LD_INT 21
55659: PUSH
55660: LD_INT 23
55662: PUSH
55663: LD_INT 22
55665: PUSH
55666: LD_INT 24
55668: PUSH
55669: EMPTY
55670: LIST
55671: LIST
55672: LIST
55673: LIST
55674: LIST
55675: LIST
55676: LIST
55677: LIST
55678: LIST
55679: LIST
55680: LIST
55681: LIST
55682: LIST
55683: ST_TO_ADDR
55684: GO 55745
55686: LD_INT 3
55688: DOUBLE
55689: EQUAL
55690: IFTRUE 55694
55692: GO 55744
55694: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55695: LD_ADDR_VAR 0 3
55699: PUSH
55700: LD_INT 13
55702: PUSH
55703: LD_INT 14
55705: PUSH
55706: LD_INT 2
55708: PUSH
55709: LD_INT 3
55711: PUSH
55712: LD_INT 4
55714: PUSH
55715: LD_INT 5
55717: PUSH
55718: LD_INT 21
55720: PUSH
55721: LD_INT 22
55723: PUSH
55724: LD_INT 23
55726: PUSH
55727: LD_INT 24
55729: PUSH
55730: EMPTY
55731: LIST
55732: LIST
55733: LIST
55734: LIST
55735: LIST
55736: LIST
55737: LIST
55738: LIST
55739: LIST
55740: LIST
55741: ST_TO_ADDR
55742: GO 55745
55744: POP
// result := ( chassis in result ) ;
55745: LD_ADDR_VAR 0 3
55749: PUSH
55750: LD_VAR 0 1
55754: PUSH
55755: LD_VAR 0 3
55759: IN
55760: ST_TO_ADDR
// end ;
55761: LD_VAR 0 3
55765: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55766: LD_INT 0
55768: PPUSH
// if not chassis or not weapon then
55769: LD_VAR 0 1
55773: NOT
55774: PUSH
55775: LD_VAR 0 2
55779: NOT
55780: OR
55781: IFFALSE 55785
// exit ;
55783: GO 56811
// case weapon of us_machine_gun :
55785: LD_VAR 0 2
55789: PUSH
55790: LD_INT 2
55792: DOUBLE
55793: EQUAL
55794: IFTRUE 55798
55796: GO 55828
55798: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55799: LD_ADDR_VAR 0 3
55803: PUSH
55804: LD_INT 1
55806: PUSH
55807: LD_INT 2
55809: PUSH
55810: LD_INT 3
55812: PUSH
55813: LD_INT 4
55815: PUSH
55816: LD_INT 5
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: LIST
55823: LIST
55824: LIST
55825: ST_TO_ADDR
55826: GO 56795
55828: LD_INT 3
55830: DOUBLE
55831: EQUAL
55832: IFTRUE 55836
55834: GO 55866
55836: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55837: LD_ADDR_VAR 0 3
55841: PUSH
55842: LD_INT 1
55844: PUSH
55845: LD_INT 2
55847: PUSH
55848: LD_INT 3
55850: PUSH
55851: LD_INT 4
55853: PUSH
55854: LD_INT 5
55856: PUSH
55857: EMPTY
55858: LIST
55859: LIST
55860: LIST
55861: LIST
55862: LIST
55863: ST_TO_ADDR
55864: GO 56795
55866: LD_INT 11
55868: DOUBLE
55869: EQUAL
55870: IFTRUE 55874
55872: GO 55904
55874: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55875: LD_ADDR_VAR 0 3
55879: PUSH
55880: LD_INT 1
55882: PUSH
55883: LD_INT 2
55885: PUSH
55886: LD_INT 3
55888: PUSH
55889: LD_INT 4
55891: PUSH
55892: LD_INT 5
55894: PUSH
55895: EMPTY
55896: LIST
55897: LIST
55898: LIST
55899: LIST
55900: LIST
55901: ST_TO_ADDR
55902: GO 56795
55904: LD_INT 4
55906: DOUBLE
55907: EQUAL
55908: IFTRUE 55912
55910: GO 55938
55912: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55913: LD_ADDR_VAR 0 3
55917: PUSH
55918: LD_INT 2
55920: PUSH
55921: LD_INT 3
55923: PUSH
55924: LD_INT 4
55926: PUSH
55927: LD_INT 5
55929: PUSH
55930: EMPTY
55931: LIST
55932: LIST
55933: LIST
55934: LIST
55935: ST_TO_ADDR
55936: GO 56795
55938: LD_INT 5
55940: DOUBLE
55941: EQUAL
55942: IFTRUE 55946
55944: GO 55972
55946: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55947: LD_ADDR_VAR 0 3
55951: PUSH
55952: LD_INT 2
55954: PUSH
55955: LD_INT 3
55957: PUSH
55958: LD_INT 4
55960: PUSH
55961: LD_INT 5
55963: PUSH
55964: EMPTY
55965: LIST
55966: LIST
55967: LIST
55968: LIST
55969: ST_TO_ADDR
55970: GO 56795
55972: LD_INT 9
55974: DOUBLE
55975: EQUAL
55976: IFTRUE 55980
55978: GO 56006
55980: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55981: LD_ADDR_VAR 0 3
55985: PUSH
55986: LD_INT 2
55988: PUSH
55989: LD_INT 3
55991: PUSH
55992: LD_INT 4
55994: PUSH
55995: LD_INT 5
55997: PUSH
55998: EMPTY
55999: LIST
56000: LIST
56001: LIST
56002: LIST
56003: ST_TO_ADDR
56004: GO 56795
56006: LD_INT 7
56008: DOUBLE
56009: EQUAL
56010: IFTRUE 56014
56012: GO 56040
56014: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56015: LD_ADDR_VAR 0 3
56019: PUSH
56020: LD_INT 2
56022: PUSH
56023: LD_INT 3
56025: PUSH
56026: LD_INT 4
56028: PUSH
56029: LD_INT 5
56031: PUSH
56032: EMPTY
56033: LIST
56034: LIST
56035: LIST
56036: LIST
56037: ST_TO_ADDR
56038: GO 56795
56040: LD_INT 12
56042: DOUBLE
56043: EQUAL
56044: IFTRUE 56048
56046: GO 56074
56048: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56049: LD_ADDR_VAR 0 3
56053: PUSH
56054: LD_INT 2
56056: PUSH
56057: LD_INT 3
56059: PUSH
56060: LD_INT 4
56062: PUSH
56063: LD_INT 5
56065: PUSH
56066: EMPTY
56067: LIST
56068: LIST
56069: LIST
56070: LIST
56071: ST_TO_ADDR
56072: GO 56795
56074: LD_INT 13
56076: DOUBLE
56077: EQUAL
56078: IFTRUE 56082
56080: GO 56108
56082: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56083: LD_ADDR_VAR 0 3
56087: PUSH
56088: LD_INT 2
56090: PUSH
56091: LD_INT 3
56093: PUSH
56094: LD_INT 4
56096: PUSH
56097: LD_INT 5
56099: PUSH
56100: EMPTY
56101: LIST
56102: LIST
56103: LIST
56104: LIST
56105: ST_TO_ADDR
56106: GO 56795
56108: LD_INT 14
56110: DOUBLE
56111: EQUAL
56112: IFTRUE 56116
56114: GO 56134
56116: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56117: LD_ADDR_VAR 0 3
56121: PUSH
56122: LD_INT 4
56124: PUSH
56125: LD_INT 5
56127: PUSH
56128: EMPTY
56129: LIST
56130: LIST
56131: ST_TO_ADDR
56132: GO 56795
56134: LD_INT 6
56136: DOUBLE
56137: EQUAL
56138: IFTRUE 56142
56140: GO 56160
56142: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56143: LD_ADDR_VAR 0 3
56147: PUSH
56148: LD_INT 4
56150: PUSH
56151: LD_INT 5
56153: PUSH
56154: EMPTY
56155: LIST
56156: LIST
56157: ST_TO_ADDR
56158: GO 56795
56160: LD_INT 10
56162: DOUBLE
56163: EQUAL
56164: IFTRUE 56168
56166: GO 56186
56168: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56169: LD_ADDR_VAR 0 3
56173: PUSH
56174: LD_INT 4
56176: PUSH
56177: LD_INT 5
56179: PUSH
56180: EMPTY
56181: LIST
56182: LIST
56183: ST_TO_ADDR
56184: GO 56795
56186: LD_INT 22
56188: DOUBLE
56189: EQUAL
56190: IFTRUE 56194
56192: GO 56220
56194: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56195: LD_ADDR_VAR 0 3
56199: PUSH
56200: LD_INT 11
56202: PUSH
56203: LD_INT 12
56205: PUSH
56206: LD_INT 13
56208: PUSH
56209: LD_INT 14
56211: PUSH
56212: EMPTY
56213: LIST
56214: LIST
56215: LIST
56216: LIST
56217: ST_TO_ADDR
56218: GO 56795
56220: LD_INT 23
56222: DOUBLE
56223: EQUAL
56224: IFTRUE 56228
56226: GO 56254
56228: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56229: LD_ADDR_VAR 0 3
56233: PUSH
56234: LD_INT 11
56236: PUSH
56237: LD_INT 12
56239: PUSH
56240: LD_INT 13
56242: PUSH
56243: LD_INT 14
56245: PUSH
56246: EMPTY
56247: LIST
56248: LIST
56249: LIST
56250: LIST
56251: ST_TO_ADDR
56252: GO 56795
56254: LD_INT 24
56256: DOUBLE
56257: EQUAL
56258: IFTRUE 56262
56260: GO 56288
56262: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56263: LD_ADDR_VAR 0 3
56267: PUSH
56268: LD_INT 11
56270: PUSH
56271: LD_INT 12
56273: PUSH
56274: LD_INT 13
56276: PUSH
56277: LD_INT 14
56279: PUSH
56280: EMPTY
56281: LIST
56282: LIST
56283: LIST
56284: LIST
56285: ST_TO_ADDR
56286: GO 56795
56288: LD_INT 30
56290: DOUBLE
56291: EQUAL
56292: IFTRUE 56296
56294: GO 56322
56296: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56297: LD_ADDR_VAR 0 3
56301: PUSH
56302: LD_INT 11
56304: PUSH
56305: LD_INT 12
56307: PUSH
56308: LD_INT 13
56310: PUSH
56311: LD_INT 14
56313: PUSH
56314: EMPTY
56315: LIST
56316: LIST
56317: LIST
56318: LIST
56319: ST_TO_ADDR
56320: GO 56795
56322: LD_INT 25
56324: DOUBLE
56325: EQUAL
56326: IFTRUE 56330
56328: GO 56348
56330: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56331: LD_ADDR_VAR 0 3
56335: PUSH
56336: LD_INT 13
56338: PUSH
56339: LD_INT 14
56341: PUSH
56342: EMPTY
56343: LIST
56344: LIST
56345: ST_TO_ADDR
56346: GO 56795
56348: LD_INT 27
56350: DOUBLE
56351: EQUAL
56352: IFTRUE 56356
56354: GO 56374
56356: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56357: LD_ADDR_VAR 0 3
56361: PUSH
56362: LD_INT 13
56364: PUSH
56365: LD_INT 14
56367: PUSH
56368: EMPTY
56369: LIST
56370: LIST
56371: ST_TO_ADDR
56372: GO 56795
56374: LD_INT 28
56376: DOUBLE
56377: EQUAL
56378: IFTRUE 56382
56380: GO 56400
56382: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56383: LD_ADDR_VAR 0 3
56387: PUSH
56388: LD_INT 13
56390: PUSH
56391: LD_INT 14
56393: PUSH
56394: EMPTY
56395: LIST
56396: LIST
56397: ST_TO_ADDR
56398: GO 56795
56400: LD_INT 29
56402: DOUBLE
56403: EQUAL
56404: IFTRUE 56408
56406: GO 56426
56408: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56409: LD_ADDR_VAR 0 3
56413: PUSH
56414: LD_INT 13
56416: PUSH
56417: LD_INT 14
56419: PUSH
56420: EMPTY
56421: LIST
56422: LIST
56423: ST_TO_ADDR
56424: GO 56795
56426: LD_INT 31
56428: DOUBLE
56429: EQUAL
56430: IFTRUE 56434
56432: GO 56452
56434: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56435: LD_ADDR_VAR 0 3
56439: PUSH
56440: LD_INT 13
56442: PUSH
56443: LD_INT 14
56445: PUSH
56446: EMPTY
56447: LIST
56448: LIST
56449: ST_TO_ADDR
56450: GO 56795
56452: LD_INT 26
56454: DOUBLE
56455: EQUAL
56456: IFTRUE 56460
56458: GO 56478
56460: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56461: LD_ADDR_VAR 0 3
56465: PUSH
56466: LD_INT 13
56468: PUSH
56469: LD_INT 14
56471: PUSH
56472: EMPTY
56473: LIST
56474: LIST
56475: ST_TO_ADDR
56476: GO 56795
56478: LD_INT 42
56480: DOUBLE
56481: EQUAL
56482: IFTRUE 56486
56484: GO 56512
56486: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56487: LD_ADDR_VAR 0 3
56491: PUSH
56492: LD_INT 21
56494: PUSH
56495: LD_INT 22
56497: PUSH
56498: LD_INT 23
56500: PUSH
56501: LD_INT 24
56503: PUSH
56504: EMPTY
56505: LIST
56506: LIST
56507: LIST
56508: LIST
56509: ST_TO_ADDR
56510: GO 56795
56512: LD_INT 43
56514: DOUBLE
56515: EQUAL
56516: IFTRUE 56520
56518: GO 56546
56520: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56521: LD_ADDR_VAR 0 3
56525: PUSH
56526: LD_INT 21
56528: PUSH
56529: LD_INT 22
56531: PUSH
56532: LD_INT 23
56534: PUSH
56535: LD_INT 24
56537: PUSH
56538: EMPTY
56539: LIST
56540: LIST
56541: LIST
56542: LIST
56543: ST_TO_ADDR
56544: GO 56795
56546: LD_INT 44
56548: DOUBLE
56549: EQUAL
56550: IFTRUE 56554
56552: GO 56580
56554: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56555: LD_ADDR_VAR 0 3
56559: PUSH
56560: LD_INT 21
56562: PUSH
56563: LD_INT 22
56565: PUSH
56566: LD_INT 23
56568: PUSH
56569: LD_INT 24
56571: PUSH
56572: EMPTY
56573: LIST
56574: LIST
56575: LIST
56576: LIST
56577: ST_TO_ADDR
56578: GO 56795
56580: LD_INT 45
56582: DOUBLE
56583: EQUAL
56584: IFTRUE 56588
56586: GO 56614
56588: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56589: LD_ADDR_VAR 0 3
56593: PUSH
56594: LD_INT 21
56596: PUSH
56597: LD_INT 22
56599: PUSH
56600: LD_INT 23
56602: PUSH
56603: LD_INT 24
56605: PUSH
56606: EMPTY
56607: LIST
56608: LIST
56609: LIST
56610: LIST
56611: ST_TO_ADDR
56612: GO 56795
56614: LD_INT 49
56616: DOUBLE
56617: EQUAL
56618: IFTRUE 56622
56620: GO 56648
56622: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56623: LD_ADDR_VAR 0 3
56627: PUSH
56628: LD_INT 21
56630: PUSH
56631: LD_INT 22
56633: PUSH
56634: LD_INT 23
56636: PUSH
56637: LD_INT 24
56639: PUSH
56640: EMPTY
56641: LIST
56642: LIST
56643: LIST
56644: LIST
56645: ST_TO_ADDR
56646: GO 56795
56648: LD_INT 51
56650: DOUBLE
56651: EQUAL
56652: IFTRUE 56656
56654: GO 56682
56656: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56657: LD_ADDR_VAR 0 3
56661: PUSH
56662: LD_INT 21
56664: PUSH
56665: LD_INT 22
56667: PUSH
56668: LD_INT 23
56670: PUSH
56671: LD_INT 24
56673: PUSH
56674: EMPTY
56675: LIST
56676: LIST
56677: LIST
56678: LIST
56679: ST_TO_ADDR
56680: GO 56795
56682: LD_INT 52
56684: DOUBLE
56685: EQUAL
56686: IFTRUE 56690
56688: GO 56716
56690: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56691: LD_ADDR_VAR 0 3
56695: PUSH
56696: LD_INT 21
56698: PUSH
56699: LD_INT 22
56701: PUSH
56702: LD_INT 23
56704: PUSH
56705: LD_INT 24
56707: PUSH
56708: EMPTY
56709: LIST
56710: LIST
56711: LIST
56712: LIST
56713: ST_TO_ADDR
56714: GO 56795
56716: LD_INT 53
56718: DOUBLE
56719: EQUAL
56720: IFTRUE 56724
56722: GO 56742
56724: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56725: LD_ADDR_VAR 0 3
56729: PUSH
56730: LD_INT 23
56732: PUSH
56733: LD_INT 24
56735: PUSH
56736: EMPTY
56737: LIST
56738: LIST
56739: ST_TO_ADDR
56740: GO 56795
56742: LD_INT 46
56744: DOUBLE
56745: EQUAL
56746: IFTRUE 56750
56748: GO 56768
56750: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56751: LD_ADDR_VAR 0 3
56755: PUSH
56756: LD_INT 23
56758: PUSH
56759: LD_INT 24
56761: PUSH
56762: EMPTY
56763: LIST
56764: LIST
56765: ST_TO_ADDR
56766: GO 56795
56768: LD_INT 47
56770: DOUBLE
56771: EQUAL
56772: IFTRUE 56776
56774: GO 56794
56776: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56777: LD_ADDR_VAR 0 3
56781: PUSH
56782: LD_INT 23
56784: PUSH
56785: LD_INT 24
56787: PUSH
56788: EMPTY
56789: LIST
56790: LIST
56791: ST_TO_ADDR
56792: GO 56795
56794: POP
// result := ( chassis in result ) ;
56795: LD_ADDR_VAR 0 3
56799: PUSH
56800: LD_VAR 0 1
56804: PUSH
56805: LD_VAR 0 3
56809: IN
56810: ST_TO_ADDR
// end ;
56811: LD_VAR 0 3
56815: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56816: LD_INT 0
56818: PPUSH
56819: PPUSH
56820: PPUSH
56821: PPUSH
56822: PPUSH
56823: PPUSH
56824: PPUSH
// result := array ;
56825: LD_ADDR_VAR 0 5
56829: PUSH
56830: LD_VAR 0 1
56834: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56835: LD_VAR 0 1
56839: NOT
56840: PUSH
56841: LD_VAR 0 2
56845: NOT
56846: OR
56847: PUSH
56848: LD_VAR 0 3
56852: NOT
56853: OR
56854: PUSH
56855: LD_VAR 0 2
56859: PUSH
56860: LD_VAR 0 1
56864: GREATER
56865: OR
56866: PUSH
56867: LD_VAR 0 3
56871: PUSH
56872: LD_VAR 0 1
56876: GREATER
56877: OR
56878: IFFALSE 56882
// exit ;
56880: GO 57178
// if direction then
56882: LD_VAR 0 4
56886: IFFALSE 56950
// begin d := 1 ;
56888: LD_ADDR_VAR 0 9
56892: PUSH
56893: LD_INT 1
56895: ST_TO_ADDR
// if i_from > i_to then
56896: LD_VAR 0 2
56900: PUSH
56901: LD_VAR 0 3
56905: GREATER
56906: IFFALSE 56932
// length := ( array - i_from ) + i_to else
56908: LD_ADDR_VAR 0 11
56912: PUSH
56913: LD_VAR 0 1
56917: PUSH
56918: LD_VAR 0 2
56922: MINUS
56923: PUSH
56924: LD_VAR 0 3
56928: PLUS
56929: ST_TO_ADDR
56930: GO 56948
// length := i_to - i_from ;
56932: LD_ADDR_VAR 0 11
56936: PUSH
56937: LD_VAR 0 3
56941: PUSH
56942: LD_VAR 0 2
56946: MINUS
56947: ST_TO_ADDR
// end else
56948: GO 57011
// begin d := - 1 ;
56950: LD_ADDR_VAR 0 9
56954: PUSH
56955: LD_INT 1
56957: NEG
56958: ST_TO_ADDR
// if i_from > i_to then
56959: LD_VAR 0 2
56963: PUSH
56964: LD_VAR 0 3
56968: GREATER
56969: IFFALSE 56989
// length := i_from - i_to else
56971: LD_ADDR_VAR 0 11
56975: PUSH
56976: LD_VAR 0 2
56980: PUSH
56981: LD_VAR 0 3
56985: MINUS
56986: ST_TO_ADDR
56987: GO 57011
// length := ( array - i_to ) + i_from ;
56989: LD_ADDR_VAR 0 11
56993: PUSH
56994: LD_VAR 0 1
56998: PUSH
56999: LD_VAR 0 3
57003: MINUS
57004: PUSH
57005: LD_VAR 0 2
57009: PLUS
57010: ST_TO_ADDR
// end ; if not length then
57011: LD_VAR 0 11
57015: NOT
57016: IFFALSE 57020
// exit ;
57018: GO 57178
// tmp := array ;
57020: LD_ADDR_VAR 0 10
57024: PUSH
57025: LD_VAR 0 1
57029: ST_TO_ADDR
// for i = 1 to length do
57030: LD_ADDR_VAR 0 6
57034: PUSH
57035: DOUBLE
57036: LD_INT 1
57038: DEC
57039: ST_TO_ADDR
57040: LD_VAR 0 11
57044: PUSH
57045: FOR_TO
57046: IFFALSE 57166
// begin for j = 1 to array do
57048: LD_ADDR_VAR 0 7
57052: PUSH
57053: DOUBLE
57054: LD_INT 1
57056: DEC
57057: ST_TO_ADDR
57058: LD_VAR 0 1
57062: PUSH
57063: FOR_TO
57064: IFFALSE 57152
// begin k := j + d ;
57066: LD_ADDR_VAR 0 8
57070: PUSH
57071: LD_VAR 0 7
57075: PUSH
57076: LD_VAR 0 9
57080: PLUS
57081: ST_TO_ADDR
// if k > array then
57082: LD_VAR 0 8
57086: PUSH
57087: LD_VAR 0 1
57091: GREATER
57092: IFFALSE 57102
// k := 1 ;
57094: LD_ADDR_VAR 0 8
57098: PUSH
57099: LD_INT 1
57101: ST_TO_ADDR
// if not k then
57102: LD_VAR 0 8
57106: NOT
57107: IFFALSE 57119
// k := array ;
57109: LD_ADDR_VAR 0 8
57113: PUSH
57114: LD_VAR 0 1
57118: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57119: LD_ADDR_VAR 0 10
57123: PUSH
57124: LD_VAR 0 10
57128: PPUSH
57129: LD_VAR 0 8
57133: PPUSH
57134: LD_VAR 0 1
57138: PUSH
57139: LD_VAR 0 7
57143: ARRAY
57144: PPUSH
57145: CALL_OW 1
57149: ST_TO_ADDR
// end ;
57150: GO 57063
57152: POP
57153: POP
// array := tmp ;
57154: LD_ADDR_VAR 0 1
57158: PUSH
57159: LD_VAR 0 10
57163: ST_TO_ADDR
// end ;
57164: GO 57045
57166: POP
57167: POP
// result := array ;
57168: LD_ADDR_VAR 0 5
57172: PUSH
57173: LD_VAR 0 1
57177: ST_TO_ADDR
// end ;
57178: LD_VAR 0 5
57182: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57183: LD_INT 0
57185: PPUSH
57186: PPUSH
// result := 0 ;
57187: LD_ADDR_VAR 0 3
57191: PUSH
57192: LD_INT 0
57194: ST_TO_ADDR
// if not array or not value in array then
57195: LD_VAR 0 1
57199: NOT
57200: PUSH
57201: LD_VAR 0 2
57205: PUSH
57206: LD_VAR 0 1
57210: IN
57211: NOT
57212: OR
57213: IFFALSE 57217
// exit ;
57215: GO 57271
// for i = 1 to array do
57217: LD_ADDR_VAR 0 4
57221: PUSH
57222: DOUBLE
57223: LD_INT 1
57225: DEC
57226: ST_TO_ADDR
57227: LD_VAR 0 1
57231: PUSH
57232: FOR_TO
57233: IFFALSE 57269
// if value = array [ i ] then
57235: LD_VAR 0 2
57239: PUSH
57240: LD_VAR 0 1
57244: PUSH
57245: LD_VAR 0 4
57249: ARRAY
57250: EQUAL
57251: IFFALSE 57267
// begin result := i ;
57253: LD_ADDR_VAR 0 3
57257: PUSH
57258: LD_VAR 0 4
57262: ST_TO_ADDR
// exit ;
57263: POP
57264: POP
57265: GO 57271
// end ;
57267: GO 57232
57269: POP
57270: POP
// end ;
57271: LD_VAR 0 3
57275: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57276: LD_INT 0
57278: PPUSH
// vc_chassis := chassis ;
57279: LD_ADDR_OWVAR 37
57283: PUSH
57284: LD_VAR 0 1
57288: ST_TO_ADDR
// vc_engine := engine ;
57289: LD_ADDR_OWVAR 39
57293: PUSH
57294: LD_VAR 0 2
57298: ST_TO_ADDR
// vc_control := control ;
57299: LD_ADDR_OWVAR 38
57303: PUSH
57304: LD_VAR 0 3
57308: ST_TO_ADDR
// vc_weapon := weapon ;
57309: LD_ADDR_OWVAR 40
57313: PUSH
57314: LD_VAR 0 4
57318: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57319: LD_ADDR_OWVAR 41
57323: PUSH
57324: LD_VAR 0 5
57328: ST_TO_ADDR
// end ;
57329: LD_VAR 0 6
57333: RET
// export function WantPlant ( unit ) ; var task ; begin
57334: LD_INT 0
57336: PPUSH
57337: PPUSH
// result := false ;
57338: LD_ADDR_VAR 0 2
57342: PUSH
57343: LD_INT 0
57345: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57346: LD_ADDR_VAR 0 3
57350: PUSH
57351: LD_VAR 0 1
57355: PPUSH
57356: CALL_OW 437
57360: ST_TO_ADDR
// if task then
57361: LD_VAR 0 3
57365: IFFALSE 57393
// if task [ 1 ] [ 1 ] = p then
57367: LD_VAR 0 3
57371: PUSH
57372: LD_INT 1
57374: ARRAY
57375: PUSH
57376: LD_INT 1
57378: ARRAY
57379: PUSH
57380: LD_STRING p
57382: EQUAL
57383: IFFALSE 57393
// result := true ;
57385: LD_ADDR_VAR 0 2
57389: PUSH
57390: LD_INT 1
57392: ST_TO_ADDR
// end ;
57393: LD_VAR 0 2
57397: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57398: LD_INT 0
57400: PPUSH
57401: PPUSH
57402: PPUSH
57403: PPUSH
// if pos < 1 then
57404: LD_VAR 0 2
57408: PUSH
57409: LD_INT 1
57411: LESS
57412: IFFALSE 57416
// exit ;
57414: GO 57719
// if pos = 1 then
57416: LD_VAR 0 2
57420: PUSH
57421: LD_INT 1
57423: EQUAL
57424: IFFALSE 57457
// result := Replace ( arr , pos [ 1 ] , value ) else
57426: LD_ADDR_VAR 0 4
57430: PUSH
57431: LD_VAR 0 1
57435: PPUSH
57436: LD_VAR 0 2
57440: PUSH
57441: LD_INT 1
57443: ARRAY
57444: PPUSH
57445: LD_VAR 0 3
57449: PPUSH
57450: CALL_OW 1
57454: ST_TO_ADDR
57455: GO 57719
// begin tmp := arr ;
57457: LD_ADDR_VAR 0 6
57461: PUSH
57462: LD_VAR 0 1
57466: ST_TO_ADDR
// s_arr := [ tmp ] ;
57467: LD_ADDR_VAR 0 7
57471: PUSH
57472: LD_VAR 0 6
57476: PUSH
57477: EMPTY
57478: LIST
57479: ST_TO_ADDR
// for i = 1 to pos - 1 do
57480: LD_ADDR_VAR 0 5
57484: PUSH
57485: DOUBLE
57486: LD_INT 1
57488: DEC
57489: ST_TO_ADDR
57490: LD_VAR 0 2
57494: PUSH
57495: LD_INT 1
57497: MINUS
57498: PUSH
57499: FOR_TO
57500: IFFALSE 57545
// begin tmp := tmp [ pos [ i ] ] ;
57502: LD_ADDR_VAR 0 6
57506: PUSH
57507: LD_VAR 0 6
57511: PUSH
57512: LD_VAR 0 2
57516: PUSH
57517: LD_VAR 0 5
57521: ARRAY
57522: ARRAY
57523: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57524: LD_ADDR_VAR 0 7
57528: PUSH
57529: LD_VAR 0 7
57533: PUSH
57534: LD_VAR 0 6
57538: PUSH
57539: EMPTY
57540: LIST
57541: ADD
57542: ST_TO_ADDR
// end ;
57543: GO 57499
57545: POP
57546: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57547: LD_ADDR_VAR 0 6
57551: PUSH
57552: LD_VAR 0 6
57556: PPUSH
57557: LD_VAR 0 2
57561: PUSH
57562: LD_VAR 0 2
57566: ARRAY
57567: PPUSH
57568: LD_VAR 0 3
57572: PPUSH
57573: CALL_OW 1
57577: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57578: LD_ADDR_VAR 0 7
57582: PUSH
57583: LD_VAR 0 7
57587: PPUSH
57588: LD_VAR 0 7
57592: PPUSH
57593: LD_VAR 0 6
57597: PPUSH
57598: CALL_OW 1
57602: ST_TO_ADDR
// for i = s_arr downto 2 do
57603: LD_ADDR_VAR 0 5
57607: PUSH
57608: DOUBLE
57609: LD_VAR 0 7
57613: INC
57614: ST_TO_ADDR
57615: LD_INT 2
57617: PUSH
57618: FOR_DOWNTO
57619: IFFALSE 57703
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57621: LD_ADDR_VAR 0 6
57625: PUSH
57626: LD_VAR 0 7
57630: PUSH
57631: LD_VAR 0 5
57635: PUSH
57636: LD_INT 1
57638: MINUS
57639: ARRAY
57640: PPUSH
57641: LD_VAR 0 2
57645: PUSH
57646: LD_VAR 0 5
57650: PUSH
57651: LD_INT 1
57653: MINUS
57654: ARRAY
57655: PPUSH
57656: LD_VAR 0 7
57660: PUSH
57661: LD_VAR 0 5
57665: ARRAY
57666: PPUSH
57667: CALL_OW 1
57671: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57672: LD_ADDR_VAR 0 7
57676: PUSH
57677: LD_VAR 0 7
57681: PPUSH
57682: LD_VAR 0 5
57686: PUSH
57687: LD_INT 1
57689: MINUS
57690: PPUSH
57691: LD_VAR 0 6
57695: PPUSH
57696: CALL_OW 1
57700: ST_TO_ADDR
// end ;
57701: GO 57618
57703: POP
57704: POP
// result := s_arr [ 1 ] ;
57705: LD_ADDR_VAR 0 4
57709: PUSH
57710: LD_VAR 0 7
57714: PUSH
57715: LD_INT 1
57717: ARRAY
57718: ST_TO_ADDR
// end ; end ;
57719: LD_VAR 0 4
57723: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57724: LD_INT 0
57726: PPUSH
57727: PPUSH
// if not list then
57728: LD_VAR 0 1
57732: NOT
57733: IFFALSE 57737
// exit ;
57735: GO 57828
// i := list [ pos1 ] ;
57737: LD_ADDR_VAR 0 5
57741: PUSH
57742: LD_VAR 0 1
57746: PUSH
57747: LD_VAR 0 2
57751: ARRAY
57752: ST_TO_ADDR
// if not i then
57753: LD_VAR 0 5
57757: NOT
57758: IFFALSE 57762
// exit ;
57760: GO 57828
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57762: LD_ADDR_VAR 0 1
57766: PUSH
57767: LD_VAR 0 1
57771: PPUSH
57772: LD_VAR 0 2
57776: PPUSH
57777: LD_VAR 0 1
57781: PUSH
57782: LD_VAR 0 3
57786: ARRAY
57787: PPUSH
57788: CALL_OW 1
57792: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57793: LD_ADDR_VAR 0 1
57797: PUSH
57798: LD_VAR 0 1
57802: PPUSH
57803: LD_VAR 0 3
57807: PPUSH
57808: LD_VAR 0 5
57812: PPUSH
57813: CALL_OW 1
57817: ST_TO_ADDR
// result := list ;
57818: LD_ADDR_VAR 0 4
57822: PUSH
57823: LD_VAR 0 1
57827: ST_TO_ADDR
// end ;
57828: LD_VAR 0 4
57832: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57833: LD_INT 0
57835: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57836: LD_ADDR_VAR 0 5
57840: PUSH
57841: LD_VAR 0 1
57845: PPUSH
57846: CALL_OW 250
57850: PPUSH
57851: LD_VAR 0 1
57855: PPUSH
57856: CALL_OW 251
57860: PPUSH
57861: LD_VAR 0 2
57865: PPUSH
57866: LD_VAR 0 3
57870: PPUSH
57871: LD_VAR 0 4
57875: PPUSH
57876: CALL 57886 0 5
57880: ST_TO_ADDR
// end ;
57881: LD_VAR 0 5
57885: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57886: LD_INT 0
57888: PPUSH
57889: PPUSH
57890: PPUSH
57891: PPUSH
// if not list then
57892: LD_VAR 0 3
57896: NOT
57897: IFFALSE 57901
// exit ;
57899: GO 58289
// result := [ ] ;
57901: LD_ADDR_VAR 0 6
57905: PUSH
57906: EMPTY
57907: ST_TO_ADDR
// for i in list do
57908: LD_ADDR_VAR 0 7
57912: PUSH
57913: LD_VAR 0 3
57917: PUSH
57918: FOR_IN
57919: IFFALSE 58121
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57921: LD_ADDR_VAR 0 9
57925: PUSH
57926: LD_VAR 0 7
57930: PPUSH
57931: LD_VAR 0 1
57935: PPUSH
57936: LD_VAR 0 2
57940: PPUSH
57941: CALL_OW 297
57945: ST_TO_ADDR
// if not result then
57946: LD_VAR 0 6
57950: NOT
57951: IFFALSE 57977
// result := [ [ i , tmp ] ] else
57953: LD_ADDR_VAR 0 6
57957: PUSH
57958: LD_VAR 0 7
57962: PUSH
57963: LD_VAR 0 9
57967: PUSH
57968: EMPTY
57969: LIST
57970: LIST
57971: PUSH
57972: EMPTY
57973: LIST
57974: ST_TO_ADDR
57975: GO 58119
// begin if result [ result ] [ 2 ] < tmp then
57977: LD_VAR 0 6
57981: PUSH
57982: LD_VAR 0 6
57986: ARRAY
57987: PUSH
57988: LD_INT 2
57990: ARRAY
57991: PUSH
57992: LD_VAR 0 9
57996: LESS
57997: IFFALSE 58039
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57999: LD_ADDR_VAR 0 6
58003: PUSH
58004: LD_VAR 0 6
58008: PPUSH
58009: LD_VAR 0 6
58013: PUSH
58014: LD_INT 1
58016: PLUS
58017: PPUSH
58018: LD_VAR 0 7
58022: PUSH
58023: LD_VAR 0 9
58027: PUSH
58028: EMPTY
58029: LIST
58030: LIST
58031: PPUSH
58032: CALL_OW 2
58036: ST_TO_ADDR
58037: GO 58119
// for j = 1 to result do
58039: LD_ADDR_VAR 0 8
58043: PUSH
58044: DOUBLE
58045: LD_INT 1
58047: DEC
58048: ST_TO_ADDR
58049: LD_VAR 0 6
58053: PUSH
58054: FOR_TO
58055: IFFALSE 58117
// begin if tmp < result [ j ] [ 2 ] then
58057: LD_VAR 0 9
58061: PUSH
58062: LD_VAR 0 6
58066: PUSH
58067: LD_VAR 0 8
58071: ARRAY
58072: PUSH
58073: LD_INT 2
58075: ARRAY
58076: LESS
58077: IFFALSE 58115
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58079: LD_ADDR_VAR 0 6
58083: PUSH
58084: LD_VAR 0 6
58088: PPUSH
58089: LD_VAR 0 8
58093: PPUSH
58094: LD_VAR 0 7
58098: PUSH
58099: LD_VAR 0 9
58103: PUSH
58104: EMPTY
58105: LIST
58106: LIST
58107: PPUSH
58108: CALL_OW 2
58112: ST_TO_ADDR
// break ;
58113: GO 58117
// end ; end ;
58115: GO 58054
58117: POP
58118: POP
// end ; end ;
58119: GO 57918
58121: POP
58122: POP
// if result and not asc then
58123: LD_VAR 0 6
58127: PUSH
58128: LD_VAR 0 4
58132: NOT
58133: AND
58134: IFFALSE 58209
// begin tmp := result ;
58136: LD_ADDR_VAR 0 9
58140: PUSH
58141: LD_VAR 0 6
58145: ST_TO_ADDR
// for i = tmp downto 1 do
58146: LD_ADDR_VAR 0 7
58150: PUSH
58151: DOUBLE
58152: LD_VAR 0 9
58156: INC
58157: ST_TO_ADDR
58158: LD_INT 1
58160: PUSH
58161: FOR_DOWNTO
58162: IFFALSE 58207
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58164: LD_ADDR_VAR 0 6
58168: PUSH
58169: LD_VAR 0 6
58173: PPUSH
58174: LD_VAR 0 9
58178: PUSH
58179: LD_VAR 0 7
58183: MINUS
58184: PUSH
58185: LD_INT 1
58187: PLUS
58188: PPUSH
58189: LD_VAR 0 9
58193: PUSH
58194: LD_VAR 0 7
58198: ARRAY
58199: PPUSH
58200: CALL_OW 1
58204: ST_TO_ADDR
58205: GO 58161
58207: POP
58208: POP
// end ; tmp := [ ] ;
58209: LD_ADDR_VAR 0 9
58213: PUSH
58214: EMPTY
58215: ST_TO_ADDR
// if mode then
58216: LD_VAR 0 5
58220: IFFALSE 58289
// begin for i = 1 to result do
58222: LD_ADDR_VAR 0 7
58226: PUSH
58227: DOUBLE
58228: LD_INT 1
58230: DEC
58231: ST_TO_ADDR
58232: LD_VAR 0 6
58236: PUSH
58237: FOR_TO
58238: IFFALSE 58277
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58240: LD_ADDR_VAR 0 9
58244: PUSH
58245: LD_VAR 0 9
58249: PPUSH
58250: LD_VAR 0 7
58254: PPUSH
58255: LD_VAR 0 6
58259: PUSH
58260: LD_VAR 0 7
58264: ARRAY
58265: PUSH
58266: LD_INT 1
58268: ARRAY
58269: PPUSH
58270: CALL_OW 1
58274: ST_TO_ADDR
58275: GO 58237
58277: POP
58278: POP
// result := tmp ;
58279: LD_ADDR_VAR 0 6
58283: PUSH
58284: LD_VAR 0 9
58288: ST_TO_ADDR
// end ; end ;
58289: LD_VAR 0 6
58293: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58294: LD_INT 0
58296: PPUSH
58297: PPUSH
58298: PPUSH
58299: PPUSH
58300: PPUSH
58301: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58302: LD_ADDR_VAR 0 5
58306: PUSH
58307: LD_INT 0
58309: PUSH
58310: LD_INT 0
58312: PUSH
58313: LD_INT 0
58315: PUSH
58316: EMPTY
58317: PUSH
58318: EMPTY
58319: LIST
58320: LIST
58321: LIST
58322: LIST
58323: ST_TO_ADDR
// if not x or not y then
58324: LD_VAR 0 2
58328: NOT
58329: PUSH
58330: LD_VAR 0 3
58334: NOT
58335: OR
58336: IFFALSE 58340
// exit ;
58338: GO 59986
// if not range then
58340: LD_VAR 0 4
58344: NOT
58345: IFFALSE 58355
// range := 10 ;
58347: LD_ADDR_VAR 0 4
58351: PUSH
58352: LD_INT 10
58354: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58355: LD_ADDR_VAR 0 8
58359: PUSH
58360: LD_INT 81
58362: PUSH
58363: LD_VAR 0 1
58367: PUSH
58368: EMPTY
58369: LIST
58370: LIST
58371: PUSH
58372: LD_INT 92
58374: PUSH
58375: LD_VAR 0 2
58379: PUSH
58380: LD_VAR 0 3
58384: PUSH
58385: LD_VAR 0 4
58389: PUSH
58390: EMPTY
58391: LIST
58392: LIST
58393: LIST
58394: LIST
58395: PUSH
58396: LD_INT 3
58398: PUSH
58399: LD_INT 21
58401: PUSH
58402: LD_INT 3
58404: PUSH
58405: EMPTY
58406: LIST
58407: LIST
58408: PUSH
58409: EMPTY
58410: LIST
58411: LIST
58412: PUSH
58413: EMPTY
58414: LIST
58415: LIST
58416: LIST
58417: PPUSH
58418: CALL_OW 69
58422: ST_TO_ADDR
// if not tmp then
58423: LD_VAR 0 8
58427: NOT
58428: IFFALSE 58432
// exit ;
58430: GO 59986
// for i in tmp do
58432: LD_ADDR_VAR 0 6
58436: PUSH
58437: LD_VAR 0 8
58441: PUSH
58442: FOR_IN
58443: IFFALSE 59961
// begin points := [ 0 , 0 , 0 ] ;
58445: LD_ADDR_VAR 0 9
58449: PUSH
58450: LD_INT 0
58452: PUSH
58453: LD_INT 0
58455: PUSH
58456: LD_INT 0
58458: PUSH
58459: EMPTY
58460: LIST
58461: LIST
58462: LIST
58463: ST_TO_ADDR
// bpoints := 1 ;
58464: LD_ADDR_VAR 0 10
58468: PUSH
58469: LD_INT 1
58471: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58472: LD_VAR 0 6
58476: PPUSH
58477: CALL_OW 247
58481: PUSH
58482: LD_INT 1
58484: DOUBLE
58485: EQUAL
58486: IFTRUE 58490
58488: GO 59068
58490: POP
// begin if GetClass ( i ) = 1 then
58491: LD_VAR 0 6
58495: PPUSH
58496: CALL_OW 257
58500: PUSH
58501: LD_INT 1
58503: EQUAL
58504: IFFALSE 58525
// points := [ 10 , 5 , 3 ] ;
58506: LD_ADDR_VAR 0 9
58510: PUSH
58511: LD_INT 10
58513: PUSH
58514: LD_INT 5
58516: PUSH
58517: LD_INT 3
58519: PUSH
58520: EMPTY
58521: LIST
58522: LIST
58523: LIST
58524: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58525: LD_VAR 0 6
58529: PPUSH
58530: CALL_OW 257
58534: PUSH
58535: LD_INT 2
58537: PUSH
58538: LD_INT 3
58540: PUSH
58541: LD_INT 4
58543: PUSH
58544: EMPTY
58545: LIST
58546: LIST
58547: LIST
58548: IN
58549: IFFALSE 58570
// points := [ 3 , 2 , 1 ] ;
58551: LD_ADDR_VAR 0 9
58555: PUSH
58556: LD_INT 3
58558: PUSH
58559: LD_INT 2
58561: PUSH
58562: LD_INT 1
58564: PUSH
58565: EMPTY
58566: LIST
58567: LIST
58568: LIST
58569: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58570: LD_VAR 0 6
58574: PPUSH
58575: CALL_OW 257
58579: PUSH
58580: LD_INT 5
58582: EQUAL
58583: IFFALSE 58604
// points := [ 130 , 5 , 2 ] ;
58585: LD_ADDR_VAR 0 9
58589: PUSH
58590: LD_INT 130
58592: PUSH
58593: LD_INT 5
58595: PUSH
58596: LD_INT 2
58598: PUSH
58599: EMPTY
58600: LIST
58601: LIST
58602: LIST
58603: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58604: LD_VAR 0 6
58608: PPUSH
58609: CALL_OW 257
58613: PUSH
58614: LD_INT 8
58616: EQUAL
58617: IFFALSE 58638
// points := [ 35 , 35 , 30 ] ;
58619: LD_ADDR_VAR 0 9
58623: PUSH
58624: LD_INT 35
58626: PUSH
58627: LD_INT 35
58629: PUSH
58630: LD_INT 30
58632: PUSH
58633: EMPTY
58634: LIST
58635: LIST
58636: LIST
58637: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58638: LD_VAR 0 6
58642: PPUSH
58643: CALL_OW 257
58647: PUSH
58648: LD_INT 9
58650: EQUAL
58651: IFFALSE 58672
// points := [ 20 , 55 , 40 ] ;
58653: LD_ADDR_VAR 0 9
58657: PUSH
58658: LD_INT 20
58660: PUSH
58661: LD_INT 55
58663: PUSH
58664: LD_INT 40
58666: PUSH
58667: EMPTY
58668: LIST
58669: LIST
58670: LIST
58671: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58672: LD_VAR 0 6
58676: PPUSH
58677: CALL_OW 257
58681: PUSH
58682: LD_INT 12
58684: PUSH
58685: LD_INT 16
58687: PUSH
58688: EMPTY
58689: LIST
58690: LIST
58691: IN
58692: IFFALSE 58713
// points := [ 5 , 3 , 2 ] ;
58694: LD_ADDR_VAR 0 9
58698: PUSH
58699: LD_INT 5
58701: PUSH
58702: LD_INT 3
58704: PUSH
58705: LD_INT 2
58707: PUSH
58708: EMPTY
58709: LIST
58710: LIST
58711: LIST
58712: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58713: LD_VAR 0 6
58717: PPUSH
58718: CALL_OW 257
58722: PUSH
58723: LD_INT 17
58725: EQUAL
58726: IFFALSE 58747
// points := [ 100 , 50 , 75 ] ;
58728: LD_ADDR_VAR 0 9
58732: PUSH
58733: LD_INT 100
58735: PUSH
58736: LD_INT 50
58738: PUSH
58739: LD_INT 75
58741: PUSH
58742: EMPTY
58743: LIST
58744: LIST
58745: LIST
58746: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58747: LD_VAR 0 6
58751: PPUSH
58752: CALL_OW 257
58756: PUSH
58757: LD_INT 15
58759: EQUAL
58760: IFFALSE 58781
// points := [ 10 , 5 , 3 ] ;
58762: LD_ADDR_VAR 0 9
58766: PUSH
58767: LD_INT 10
58769: PUSH
58770: LD_INT 5
58772: PUSH
58773: LD_INT 3
58775: PUSH
58776: EMPTY
58777: LIST
58778: LIST
58779: LIST
58780: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58781: LD_VAR 0 6
58785: PPUSH
58786: CALL_OW 257
58790: PUSH
58791: LD_INT 14
58793: EQUAL
58794: IFFALSE 58815
// points := [ 10 , 0 , 0 ] ;
58796: LD_ADDR_VAR 0 9
58800: PUSH
58801: LD_INT 10
58803: PUSH
58804: LD_INT 0
58806: PUSH
58807: LD_INT 0
58809: PUSH
58810: EMPTY
58811: LIST
58812: LIST
58813: LIST
58814: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58815: LD_VAR 0 6
58819: PPUSH
58820: CALL_OW 257
58824: PUSH
58825: LD_INT 11
58827: EQUAL
58828: IFFALSE 58849
// points := [ 30 , 10 , 5 ] ;
58830: LD_ADDR_VAR 0 9
58834: PUSH
58835: LD_INT 30
58837: PUSH
58838: LD_INT 10
58840: PUSH
58841: LD_INT 5
58843: PUSH
58844: EMPTY
58845: LIST
58846: LIST
58847: LIST
58848: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58849: LD_VAR 0 1
58853: PPUSH
58854: LD_INT 5
58856: PPUSH
58857: CALL_OW 321
58861: PUSH
58862: LD_INT 2
58864: EQUAL
58865: IFFALSE 58882
// bpoints := bpoints * 1.8 ;
58867: LD_ADDR_VAR 0 10
58871: PUSH
58872: LD_VAR 0 10
58876: PUSH
58877: LD_REAL  1.80000000000000E+0000
58880: MUL
58881: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58882: LD_VAR 0 6
58886: PPUSH
58887: CALL_OW 257
58891: PUSH
58892: LD_INT 1
58894: PUSH
58895: LD_INT 2
58897: PUSH
58898: LD_INT 3
58900: PUSH
58901: LD_INT 4
58903: PUSH
58904: EMPTY
58905: LIST
58906: LIST
58907: LIST
58908: LIST
58909: IN
58910: PUSH
58911: LD_VAR 0 1
58915: PPUSH
58916: LD_INT 51
58918: PPUSH
58919: CALL_OW 321
58923: PUSH
58924: LD_INT 2
58926: EQUAL
58927: AND
58928: IFFALSE 58945
// bpoints := bpoints * 1.2 ;
58930: LD_ADDR_VAR 0 10
58934: PUSH
58935: LD_VAR 0 10
58939: PUSH
58940: LD_REAL  1.20000000000000E+0000
58943: MUL
58944: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58945: LD_VAR 0 6
58949: PPUSH
58950: CALL_OW 257
58954: PUSH
58955: LD_INT 5
58957: PUSH
58958: LD_INT 7
58960: PUSH
58961: LD_INT 9
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: LIST
58968: IN
58969: PUSH
58970: LD_VAR 0 1
58974: PPUSH
58975: LD_INT 52
58977: PPUSH
58978: CALL_OW 321
58982: PUSH
58983: LD_INT 2
58985: EQUAL
58986: AND
58987: IFFALSE 59004
// bpoints := bpoints * 1.5 ;
58989: LD_ADDR_VAR 0 10
58993: PUSH
58994: LD_VAR 0 10
58998: PUSH
58999: LD_REAL  1.50000000000000E+0000
59002: MUL
59003: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59004: LD_VAR 0 1
59008: PPUSH
59009: LD_INT 66
59011: PPUSH
59012: CALL_OW 321
59016: PUSH
59017: LD_INT 2
59019: EQUAL
59020: IFFALSE 59037
// bpoints := bpoints * 1.1 ;
59022: LD_ADDR_VAR 0 10
59026: PUSH
59027: LD_VAR 0 10
59031: PUSH
59032: LD_REAL  1.10000000000000E+0000
59035: MUL
59036: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59037: LD_ADDR_VAR 0 10
59041: PUSH
59042: LD_VAR 0 10
59046: PUSH
59047: LD_VAR 0 6
59051: PPUSH
59052: LD_INT 1
59054: PPUSH
59055: CALL_OW 259
59059: PUSH
59060: LD_REAL  1.15000000000000E+0000
59063: MUL
59064: MUL
59065: ST_TO_ADDR
// end ; unit_vehicle :
59066: GO 59890
59068: LD_INT 2
59070: DOUBLE
59071: EQUAL
59072: IFTRUE 59076
59074: GO 59878
59076: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59077: LD_VAR 0 6
59081: PPUSH
59082: CALL_OW 264
59086: PUSH
59087: LD_INT 2
59089: PUSH
59090: LD_INT 42
59092: PUSH
59093: LD_INT 24
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: LIST
59100: IN
59101: IFFALSE 59122
// points := [ 25 , 5 , 3 ] ;
59103: LD_ADDR_VAR 0 9
59107: PUSH
59108: LD_INT 25
59110: PUSH
59111: LD_INT 5
59113: PUSH
59114: LD_INT 3
59116: PUSH
59117: EMPTY
59118: LIST
59119: LIST
59120: LIST
59121: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59122: LD_VAR 0 6
59126: PPUSH
59127: CALL_OW 264
59131: PUSH
59132: LD_INT 4
59134: PUSH
59135: LD_INT 43
59137: PUSH
59138: LD_INT 25
59140: PUSH
59141: EMPTY
59142: LIST
59143: LIST
59144: LIST
59145: IN
59146: IFFALSE 59167
// points := [ 40 , 15 , 5 ] ;
59148: LD_ADDR_VAR 0 9
59152: PUSH
59153: LD_INT 40
59155: PUSH
59156: LD_INT 15
59158: PUSH
59159: LD_INT 5
59161: PUSH
59162: EMPTY
59163: LIST
59164: LIST
59165: LIST
59166: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59167: LD_VAR 0 6
59171: PPUSH
59172: CALL_OW 264
59176: PUSH
59177: LD_INT 3
59179: PUSH
59180: LD_INT 23
59182: PUSH
59183: EMPTY
59184: LIST
59185: LIST
59186: IN
59187: IFFALSE 59208
// points := [ 7 , 25 , 8 ] ;
59189: LD_ADDR_VAR 0 9
59193: PUSH
59194: LD_INT 7
59196: PUSH
59197: LD_INT 25
59199: PUSH
59200: LD_INT 8
59202: PUSH
59203: EMPTY
59204: LIST
59205: LIST
59206: LIST
59207: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59208: LD_VAR 0 6
59212: PPUSH
59213: CALL_OW 264
59217: PUSH
59218: LD_INT 5
59220: PUSH
59221: LD_INT 27
59223: PUSH
59224: LD_INT 44
59226: PUSH
59227: EMPTY
59228: LIST
59229: LIST
59230: LIST
59231: IN
59232: IFFALSE 59253
// points := [ 14 , 50 , 16 ] ;
59234: LD_ADDR_VAR 0 9
59238: PUSH
59239: LD_INT 14
59241: PUSH
59242: LD_INT 50
59244: PUSH
59245: LD_INT 16
59247: PUSH
59248: EMPTY
59249: LIST
59250: LIST
59251: LIST
59252: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59253: LD_VAR 0 6
59257: PPUSH
59258: CALL_OW 264
59262: PUSH
59263: LD_INT 6
59265: PUSH
59266: LD_INT 46
59268: PUSH
59269: EMPTY
59270: LIST
59271: LIST
59272: IN
59273: IFFALSE 59294
// points := [ 32 , 120 , 70 ] ;
59275: LD_ADDR_VAR 0 9
59279: PUSH
59280: LD_INT 32
59282: PUSH
59283: LD_INT 120
59285: PUSH
59286: LD_INT 70
59288: PUSH
59289: EMPTY
59290: LIST
59291: LIST
59292: LIST
59293: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
59294: LD_VAR 0 6
59298: PPUSH
59299: CALL_OW 264
59303: PUSH
59304: LD_INT 7
59306: PUSH
59307: LD_INT 28
59309: PUSH
59310: LD_INT 45
59312: PUSH
59313: EMPTY
59314: LIST
59315: LIST
59316: LIST
59317: IN
59318: IFFALSE 59339
// points := [ 35 , 20 , 45 ] ;
59320: LD_ADDR_VAR 0 9
59324: PUSH
59325: LD_INT 35
59327: PUSH
59328: LD_INT 20
59330: PUSH
59331: LD_INT 45
59333: PUSH
59334: EMPTY
59335: LIST
59336: LIST
59337: LIST
59338: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59339: LD_VAR 0 6
59343: PPUSH
59344: CALL_OW 264
59348: PUSH
59349: LD_INT 47
59351: PUSH
59352: EMPTY
59353: LIST
59354: IN
59355: IFFALSE 59376
// points := [ 67 , 45 , 75 ] ;
59357: LD_ADDR_VAR 0 9
59361: PUSH
59362: LD_INT 67
59364: PUSH
59365: LD_INT 45
59367: PUSH
59368: LD_INT 75
59370: PUSH
59371: EMPTY
59372: LIST
59373: LIST
59374: LIST
59375: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59376: LD_VAR 0 6
59380: PPUSH
59381: CALL_OW 264
59385: PUSH
59386: LD_INT 26
59388: PUSH
59389: EMPTY
59390: LIST
59391: IN
59392: IFFALSE 59413
// points := [ 120 , 30 , 80 ] ;
59394: LD_ADDR_VAR 0 9
59398: PUSH
59399: LD_INT 120
59401: PUSH
59402: LD_INT 30
59404: PUSH
59405: LD_INT 80
59407: PUSH
59408: EMPTY
59409: LIST
59410: LIST
59411: LIST
59412: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59413: LD_VAR 0 6
59417: PPUSH
59418: CALL_OW 264
59422: PUSH
59423: LD_INT 22
59425: PUSH
59426: EMPTY
59427: LIST
59428: IN
59429: IFFALSE 59450
// points := [ 40 , 1 , 1 ] ;
59431: LD_ADDR_VAR 0 9
59435: PUSH
59436: LD_INT 40
59438: PUSH
59439: LD_INT 1
59441: PUSH
59442: LD_INT 1
59444: PUSH
59445: EMPTY
59446: LIST
59447: LIST
59448: LIST
59449: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59450: LD_VAR 0 6
59454: PPUSH
59455: CALL_OW 264
59459: PUSH
59460: LD_INT 29
59462: PUSH
59463: EMPTY
59464: LIST
59465: IN
59466: IFFALSE 59487
// points := [ 70 , 200 , 400 ] ;
59468: LD_ADDR_VAR 0 9
59472: PUSH
59473: LD_INT 70
59475: PUSH
59476: LD_INT 200
59478: PUSH
59479: LD_INT 400
59481: PUSH
59482: EMPTY
59483: LIST
59484: LIST
59485: LIST
59486: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59487: LD_VAR 0 6
59491: PPUSH
59492: CALL_OW 264
59496: PUSH
59497: LD_INT 14
59499: PUSH
59500: LD_INT 53
59502: PUSH
59503: EMPTY
59504: LIST
59505: LIST
59506: IN
59507: IFFALSE 59528
// points := [ 40 , 10 , 20 ] ;
59509: LD_ADDR_VAR 0 9
59513: PUSH
59514: LD_INT 40
59516: PUSH
59517: LD_INT 10
59519: PUSH
59520: LD_INT 20
59522: PUSH
59523: EMPTY
59524: LIST
59525: LIST
59526: LIST
59527: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59528: LD_VAR 0 6
59532: PPUSH
59533: CALL_OW 264
59537: PUSH
59538: LD_INT 9
59540: PUSH
59541: EMPTY
59542: LIST
59543: IN
59544: IFFALSE 59565
// points := [ 5 , 70 , 20 ] ;
59546: LD_ADDR_VAR 0 9
59550: PUSH
59551: LD_INT 5
59553: PUSH
59554: LD_INT 70
59556: PUSH
59557: LD_INT 20
59559: PUSH
59560: EMPTY
59561: LIST
59562: LIST
59563: LIST
59564: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59565: LD_VAR 0 6
59569: PPUSH
59570: CALL_OW 264
59574: PUSH
59575: LD_INT 10
59577: PUSH
59578: EMPTY
59579: LIST
59580: IN
59581: IFFALSE 59602
// points := [ 35 , 110 , 70 ] ;
59583: LD_ADDR_VAR 0 9
59587: PUSH
59588: LD_INT 35
59590: PUSH
59591: LD_INT 110
59593: PUSH
59594: LD_INT 70
59596: PUSH
59597: EMPTY
59598: LIST
59599: LIST
59600: LIST
59601: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59602: LD_VAR 0 6
59606: PPUSH
59607: CALL_OW 265
59611: PUSH
59612: LD_INT 25
59614: EQUAL
59615: IFFALSE 59636
// points := [ 80 , 65 , 100 ] ;
59617: LD_ADDR_VAR 0 9
59621: PUSH
59622: LD_INT 80
59624: PUSH
59625: LD_INT 65
59627: PUSH
59628: LD_INT 100
59630: PUSH
59631: EMPTY
59632: LIST
59633: LIST
59634: LIST
59635: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59636: LD_VAR 0 6
59640: PPUSH
59641: CALL_OW 263
59645: PUSH
59646: LD_INT 1
59648: EQUAL
59649: IFFALSE 59684
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59651: LD_ADDR_VAR 0 10
59655: PUSH
59656: LD_VAR 0 10
59660: PUSH
59661: LD_VAR 0 6
59665: PPUSH
59666: CALL_OW 311
59670: PPUSH
59671: LD_INT 3
59673: PPUSH
59674: CALL_OW 259
59678: PUSH
59679: LD_INT 4
59681: MUL
59682: MUL
59683: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59684: LD_VAR 0 6
59688: PPUSH
59689: CALL_OW 263
59693: PUSH
59694: LD_INT 2
59696: EQUAL
59697: IFFALSE 59748
// begin j := IsControledBy ( i ) ;
59699: LD_ADDR_VAR 0 7
59703: PUSH
59704: LD_VAR 0 6
59708: PPUSH
59709: CALL_OW 312
59713: ST_TO_ADDR
// if j then
59714: LD_VAR 0 7
59718: IFFALSE 59748
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59720: LD_ADDR_VAR 0 10
59724: PUSH
59725: LD_VAR 0 10
59729: PUSH
59730: LD_VAR 0 7
59734: PPUSH
59735: LD_INT 3
59737: PPUSH
59738: CALL_OW 259
59742: PUSH
59743: LD_INT 3
59745: MUL
59746: MUL
59747: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59748: LD_VAR 0 6
59752: PPUSH
59753: CALL_OW 264
59757: PUSH
59758: LD_INT 5
59760: PUSH
59761: LD_INT 6
59763: PUSH
59764: LD_INT 46
59766: PUSH
59767: LD_INT 44
59769: PUSH
59770: LD_INT 47
59772: PUSH
59773: LD_INT 45
59775: PUSH
59776: LD_INT 28
59778: PUSH
59779: LD_INT 7
59781: PUSH
59782: LD_INT 27
59784: PUSH
59785: LD_INT 29
59787: PUSH
59788: EMPTY
59789: LIST
59790: LIST
59791: LIST
59792: LIST
59793: LIST
59794: LIST
59795: LIST
59796: LIST
59797: LIST
59798: LIST
59799: IN
59800: PUSH
59801: LD_VAR 0 1
59805: PPUSH
59806: LD_INT 52
59808: PPUSH
59809: CALL_OW 321
59813: PUSH
59814: LD_INT 2
59816: EQUAL
59817: AND
59818: IFFALSE 59835
// bpoints := bpoints * 1.2 ;
59820: LD_ADDR_VAR 0 10
59824: PUSH
59825: LD_VAR 0 10
59829: PUSH
59830: LD_REAL  1.20000000000000E+0000
59833: MUL
59834: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59835: LD_VAR 0 6
59839: PPUSH
59840: CALL_OW 264
59844: PUSH
59845: LD_INT 6
59847: PUSH
59848: LD_INT 46
59850: PUSH
59851: LD_INT 47
59853: PUSH
59854: EMPTY
59855: LIST
59856: LIST
59857: LIST
59858: IN
59859: IFFALSE 59876
// bpoints := bpoints * 1.2 ;
59861: LD_ADDR_VAR 0 10
59865: PUSH
59866: LD_VAR 0 10
59870: PUSH
59871: LD_REAL  1.20000000000000E+0000
59874: MUL
59875: ST_TO_ADDR
// end ; unit_building :
59876: GO 59890
59878: LD_INT 3
59880: DOUBLE
59881: EQUAL
59882: IFTRUE 59886
59884: GO 59889
59886: POP
// ; end ;
59887: GO 59890
59889: POP
// for j = 1 to 3 do
59890: LD_ADDR_VAR 0 7
59894: PUSH
59895: DOUBLE
59896: LD_INT 1
59898: DEC
59899: ST_TO_ADDR
59900: LD_INT 3
59902: PUSH
59903: FOR_TO
59904: IFFALSE 59957
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59906: LD_ADDR_VAR 0 5
59910: PUSH
59911: LD_VAR 0 5
59915: PPUSH
59916: LD_VAR 0 7
59920: PPUSH
59921: LD_VAR 0 5
59925: PUSH
59926: LD_VAR 0 7
59930: ARRAY
59931: PUSH
59932: LD_VAR 0 9
59936: PUSH
59937: LD_VAR 0 7
59941: ARRAY
59942: PUSH
59943: LD_VAR 0 10
59947: MUL
59948: PLUS
59949: PPUSH
59950: CALL_OW 1
59954: ST_TO_ADDR
59955: GO 59903
59957: POP
59958: POP
// end ;
59959: GO 58442
59961: POP
59962: POP
// result := Replace ( result , 4 , tmp ) ;
59963: LD_ADDR_VAR 0 5
59967: PUSH
59968: LD_VAR 0 5
59972: PPUSH
59973: LD_INT 4
59975: PPUSH
59976: LD_VAR 0 8
59980: PPUSH
59981: CALL_OW 1
59985: ST_TO_ADDR
// end ;
59986: LD_VAR 0 5
59990: RET
// export function DangerAtRange ( unit , range ) ; begin
59991: LD_INT 0
59993: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59994: LD_ADDR_VAR 0 3
59998: PUSH
59999: LD_VAR 0 1
60003: PPUSH
60004: CALL_OW 255
60008: PPUSH
60009: LD_VAR 0 1
60013: PPUSH
60014: CALL_OW 250
60018: PPUSH
60019: LD_VAR 0 1
60023: PPUSH
60024: CALL_OW 251
60028: PPUSH
60029: LD_VAR 0 2
60033: PPUSH
60034: CALL 58294 0 4
60038: ST_TO_ADDR
// end ;
60039: LD_VAR 0 3
60043: RET
// export function DangerInArea ( side , area ) ; begin
60044: LD_INT 0
60046: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60047: LD_ADDR_VAR 0 3
60051: PUSH
60052: LD_VAR 0 2
60056: PPUSH
60057: LD_INT 81
60059: PUSH
60060: LD_VAR 0 1
60064: PUSH
60065: EMPTY
60066: LIST
60067: LIST
60068: PPUSH
60069: CALL_OW 70
60073: ST_TO_ADDR
// end ;
60074: LD_VAR 0 3
60078: RET
// export function IsExtension ( b ) ; begin
60079: LD_INT 0
60081: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60082: LD_ADDR_VAR 0 2
60086: PUSH
60087: LD_VAR 0 1
60091: PUSH
60092: LD_INT 23
60094: PUSH
60095: LD_INT 20
60097: PUSH
60098: LD_INT 22
60100: PUSH
60101: LD_INT 17
60103: PUSH
60104: LD_INT 24
60106: PUSH
60107: LD_INT 21
60109: PUSH
60110: LD_INT 19
60112: PUSH
60113: LD_INT 16
60115: PUSH
60116: LD_INT 25
60118: PUSH
60119: LD_INT 18
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: LIST
60126: LIST
60127: LIST
60128: LIST
60129: LIST
60130: LIST
60131: LIST
60132: LIST
60133: IN
60134: ST_TO_ADDR
// end ;
60135: LD_VAR 0 2
60139: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
60140: LD_INT 0
60142: PPUSH
60143: PPUSH
60144: PPUSH
// result := [ ] ;
60145: LD_ADDR_VAR 0 3
60149: PUSH
60150: EMPTY
60151: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60152: LD_ADDR_VAR 0 4
60156: PUSH
60157: LD_VAR 0 2
60161: PPUSH
60162: LD_INT 21
60164: PUSH
60165: LD_INT 3
60167: PUSH
60168: EMPTY
60169: LIST
60170: LIST
60171: PPUSH
60172: CALL_OW 70
60176: ST_TO_ADDR
// if not tmp then
60177: LD_VAR 0 4
60181: NOT
60182: IFFALSE 60186
// exit ;
60184: GO 60244
// for i in tmp do
60186: LD_ADDR_VAR 0 5
60190: PUSH
60191: LD_VAR 0 4
60195: PUSH
60196: FOR_IN
60197: IFFALSE 60232
// if GetBase ( i ) <> base then
60199: LD_VAR 0 5
60203: PPUSH
60204: CALL_OW 274
60208: PUSH
60209: LD_VAR 0 1
60213: NONEQUAL
60214: IFFALSE 60230
// ComLinkToBase ( base , i ) ;
60216: LD_VAR 0 1
60220: PPUSH
60221: LD_VAR 0 5
60225: PPUSH
60226: CALL_OW 169
60230: GO 60196
60232: POP
60233: POP
// result := tmp ;
60234: LD_ADDR_VAR 0 3
60238: PUSH
60239: LD_VAR 0 4
60243: ST_TO_ADDR
// end ;
60244: LD_VAR 0 3
60248: RET
// export function ComComplete ( unit , b ) ; var i ; begin
60249: LD_INT 0
60251: PPUSH
60252: PPUSH
// if BuildingStatus ( b ) = bs_build then
60253: LD_VAR 0 2
60257: PPUSH
60258: CALL_OW 461
60262: PUSH
60263: LD_INT 1
60265: EQUAL
60266: IFFALSE 60326
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60268: LD_VAR 0 1
60272: PPUSH
60273: LD_STRING h
60275: PUSH
60276: LD_VAR 0 2
60280: PPUSH
60281: CALL_OW 250
60285: PUSH
60286: LD_VAR 0 2
60290: PPUSH
60291: CALL_OW 251
60295: PUSH
60296: LD_VAR 0 2
60300: PUSH
60301: LD_INT 0
60303: PUSH
60304: LD_INT 0
60306: PUSH
60307: LD_INT 0
60309: PUSH
60310: EMPTY
60311: LIST
60312: LIST
60313: LIST
60314: LIST
60315: LIST
60316: LIST
60317: LIST
60318: PUSH
60319: EMPTY
60320: LIST
60321: PPUSH
60322: CALL_OW 446
// end ;
60326: LD_VAR 0 3
60330: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60331: LD_INT 0
60333: PPUSH
60334: PPUSH
60335: PPUSH
60336: PPUSH
60337: PPUSH
60338: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
60339: LD_VAR 0 1
60343: NOT
60344: PUSH
60345: LD_VAR 0 1
60349: PPUSH
60350: CALL_OW 263
60354: PUSH
60355: LD_INT 2
60357: EQUAL
60358: NOT
60359: OR
60360: IFFALSE 60364
// exit ;
60362: GO 60680
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60364: LD_ADDR_VAR 0 6
60368: PUSH
60369: LD_INT 22
60371: PUSH
60372: LD_VAR 0 1
60376: PPUSH
60377: CALL_OW 255
60381: PUSH
60382: EMPTY
60383: LIST
60384: LIST
60385: PUSH
60386: LD_INT 2
60388: PUSH
60389: LD_INT 30
60391: PUSH
60392: LD_INT 36
60394: PUSH
60395: EMPTY
60396: LIST
60397: LIST
60398: PUSH
60399: LD_INT 34
60401: PUSH
60402: LD_INT 31
60404: PUSH
60405: EMPTY
60406: LIST
60407: LIST
60408: PUSH
60409: EMPTY
60410: LIST
60411: LIST
60412: LIST
60413: PUSH
60414: EMPTY
60415: LIST
60416: LIST
60417: PPUSH
60418: CALL_OW 69
60422: ST_TO_ADDR
// if not tmp then
60423: LD_VAR 0 6
60427: NOT
60428: IFFALSE 60432
// exit ;
60430: GO 60680
// result := [ ] ;
60432: LD_ADDR_VAR 0 2
60436: PUSH
60437: EMPTY
60438: ST_TO_ADDR
// for i in tmp do
60439: LD_ADDR_VAR 0 3
60443: PUSH
60444: LD_VAR 0 6
60448: PUSH
60449: FOR_IN
60450: IFFALSE 60521
// begin t := UnitsInside ( i ) ;
60452: LD_ADDR_VAR 0 4
60456: PUSH
60457: LD_VAR 0 3
60461: PPUSH
60462: CALL_OW 313
60466: ST_TO_ADDR
// if t then
60467: LD_VAR 0 4
60471: IFFALSE 60519
// for j in t do
60473: LD_ADDR_VAR 0 7
60477: PUSH
60478: LD_VAR 0 4
60482: PUSH
60483: FOR_IN
60484: IFFALSE 60517
// result := Insert ( result , result + 1 , j ) ;
60486: LD_ADDR_VAR 0 2
60490: PUSH
60491: LD_VAR 0 2
60495: PPUSH
60496: LD_VAR 0 2
60500: PUSH
60501: LD_INT 1
60503: PLUS
60504: PPUSH
60505: LD_VAR 0 7
60509: PPUSH
60510: CALL_OW 2
60514: ST_TO_ADDR
60515: GO 60483
60517: POP
60518: POP
// end ;
60519: GO 60449
60521: POP
60522: POP
// if not result then
60523: LD_VAR 0 2
60527: NOT
60528: IFFALSE 60532
// exit ;
60530: GO 60680
// mech := result [ 1 ] ;
60532: LD_ADDR_VAR 0 5
60536: PUSH
60537: LD_VAR 0 2
60541: PUSH
60542: LD_INT 1
60544: ARRAY
60545: ST_TO_ADDR
// if result > 1 then
60546: LD_VAR 0 2
60550: PUSH
60551: LD_INT 1
60553: GREATER
60554: IFFALSE 60666
// for i = 2 to result do
60556: LD_ADDR_VAR 0 3
60560: PUSH
60561: DOUBLE
60562: LD_INT 2
60564: DEC
60565: ST_TO_ADDR
60566: LD_VAR 0 2
60570: PUSH
60571: FOR_TO
60572: IFFALSE 60664
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60574: LD_ADDR_VAR 0 4
60578: PUSH
60579: LD_VAR 0 2
60583: PUSH
60584: LD_VAR 0 3
60588: ARRAY
60589: PPUSH
60590: LD_INT 3
60592: PPUSH
60593: CALL_OW 259
60597: PUSH
60598: LD_VAR 0 2
60602: PUSH
60603: LD_VAR 0 3
60607: ARRAY
60608: PPUSH
60609: CALL_OW 432
60613: MINUS
60614: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60615: LD_VAR 0 4
60619: PUSH
60620: LD_VAR 0 5
60624: PPUSH
60625: LD_INT 3
60627: PPUSH
60628: CALL_OW 259
60632: PUSH
60633: LD_VAR 0 5
60637: PPUSH
60638: CALL_OW 432
60642: MINUS
60643: GREATEREQUAL
60644: IFFALSE 60662
// mech := result [ i ] ;
60646: LD_ADDR_VAR 0 5
60650: PUSH
60651: LD_VAR 0 2
60655: PUSH
60656: LD_VAR 0 3
60660: ARRAY
60661: ST_TO_ADDR
// end ;
60662: GO 60571
60664: POP
60665: POP
// ComLinkTo ( vehicle , mech ) ;
60666: LD_VAR 0 1
60670: PPUSH
60671: LD_VAR 0 5
60675: PPUSH
60676: CALL_OW 135
// end ;
60680: LD_VAR 0 2
60684: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60685: LD_INT 0
60687: PPUSH
60688: PPUSH
60689: PPUSH
60690: PPUSH
60691: PPUSH
60692: PPUSH
60693: PPUSH
60694: PPUSH
60695: PPUSH
60696: PPUSH
60697: PPUSH
60698: PPUSH
60699: PPUSH
// result := [ ] ;
60700: LD_ADDR_VAR 0 7
60704: PUSH
60705: EMPTY
60706: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60707: LD_VAR 0 1
60711: PPUSH
60712: CALL_OW 266
60716: PUSH
60717: LD_INT 0
60719: PUSH
60720: LD_INT 1
60722: PUSH
60723: EMPTY
60724: LIST
60725: LIST
60726: IN
60727: NOT
60728: IFFALSE 60732
// exit ;
60730: GO 62363
// if name then
60732: LD_VAR 0 3
60736: IFFALSE 60752
// SetBName ( base_dep , name ) ;
60738: LD_VAR 0 1
60742: PPUSH
60743: LD_VAR 0 3
60747: PPUSH
60748: CALL_OW 500
// base := GetBase ( base_dep ) ;
60752: LD_ADDR_VAR 0 15
60756: PUSH
60757: LD_VAR 0 1
60761: PPUSH
60762: CALL_OW 274
60766: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60767: LD_ADDR_VAR 0 16
60771: PUSH
60772: LD_VAR 0 1
60776: PPUSH
60777: CALL_OW 255
60781: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60782: LD_ADDR_VAR 0 17
60786: PUSH
60787: LD_VAR 0 1
60791: PPUSH
60792: CALL_OW 248
60796: ST_TO_ADDR
// if sources then
60797: LD_VAR 0 5
60801: IFFALSE 60848
// for i = 1 to 3 do
60803: LD_ADDR_VAR 0 8
60807: PUSH
60808: DOUBLE
60809: LD_INT 1
60811: DEC
60812: ST_TO_ADDR
60813: LD_INT 3
60815: PUSH
60816: FOR_TO
60817: IFFALSE 60846
// AddResourceType ( base , i , sources [ i ] ) ;
60819: LD_VAR 0 15
60823: PPUSH
60824: LD_VAR 0 8
60828: PPUSH
60829: LD_VAR 0 5
60833: PUSH
60834: LD_VAR 0 8
60838: ARRAY
60839: PPUSH
60840: CALL_OW 276
60844: GO 60816
60846: POP
60847: POP
// buildings := GetBaseBuildings ( base , area ) ;
60848: LD_ADDR_VAR 0 18
60852: PUSH
60853: LD_VAR 0 15
60857: PPUSH
60858: LD_VAR 0 2
60862: PPUSH
60863: CALL 60140 0 2
60867: ST_TO_ADDR
// InitHc ;
60868: CALL_OW 19
// InitUc ;
60872: CALL_OW 18
// uc_side := side ;
60876: LD_ADDR_OWVAR 20
60880: PUSH
60881: LD_VAR 0 16
60885: ST_TO_ADDR
// uc_nation := nation ;
60886: LD_ADDR_OWVAR 21
60890: PUSH
60891: LD_VAR 0 17
60895: ST_TO_ADDR
// if buildings then
60896: LD_VAR 0 18
60900: IFFALSE 62222
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60902: LD_ADDR_VAR 0 19
60906: PUSH
60907: LD_VAR 0 18
60911: PPUSH
60912: LD_INT 2
60914: PUSH
60915: LD_INT 30
60917: PUSH
60918: LD_INT 29
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: PUSH
60925: LD_INT 30
60927: PUSH
60928: LD_INT 30
60930: PUSH
60931: EMPTY
60932: LIST
60933: LIST
60934: PUSH
60935: EMPTY
60936: LIST
60937: LIST
60938: LIST
60939: PPUSH
60940: CALL_OW 72
60944: ST_TO_ADDR
// if tmp then
60945: LD_VAR 0 19
60949: IFFALSE 60997
// for i in tmp do
60951: LD_ADDR_VAR 0 8
60955: PUSH
60956: LD_VAR 0 19
60960: PUSH
60961: FOR_IN
60962: IFFALSE 60995
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60964: LD_VAR 0 8
60968: PPUSH
60969: CALL_OW 250
60973: PPUSH
60974: LD_VAR 0 8
60978: PPUSH
60979: CALL_OW 251
60983: PPUSH
60984: LD_VAR 0 16
60988: PPUSH
60989: CALL_OW 441
60993: GO 60961
60995: POP
60996: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60997: LD_VAR 0 18
61001: PPUSH
61002: LD_INT 2
61004: PUSH
61005: LD_INT 30
61007: PUSH
61008: LD_INT 32
61010: PUSH
61011: EMPTY
61012: LIST
61013: LIST
61014: PUSH
61015: LD_INT 30
61017: PUSH
61018: LD_INT 33
61020: PUSH
61021: EMPTY
61022: LIST
61023: LIST
61024: PUSH
61025: EMPTY
61026: LIST
61027: LIST
61028: LIST
61029: PPUSH
61030: CALL_OW 72
61034: IFFALSE 61122
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61036: LD_ADDR_VAR 0 8
61040: PUSH
61041: LD_VAR 0 18
61045: PPUSH
61046: LD_INT 2
61048: PUSH
61049: LD_INT 30
61051: PUSH
61052: LD_INT 32
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: PUSH
61059: LD_INT 30
61061: PUSH
61062: LD_INT 33
61064: PUSH
61065: EMPTY
61066: LIST
61067: LIST
61068: PUSH
61069: EMPTY
61070: LIST
61071: LIST
61072: LIST
61073: PPUSH
61074: CALL_OW 72
61078: PUSH
61079: FOR_IN
61080: IFFALSE 61120
// begin if not GetBWeapon ( i ) then
61082: LD_VAR 0 8
61086: PPUSH
61087: CALL_OW 269
61091: NOT
61092: IFFALSE 61118
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61094: LD_VAR 0 8
61098: PPUSH
61099: LD_VAR 0 8
61103: PPUSH
61104: LD_VAR 0 2
61108: PPUSH
61109: CALL 62368 0 2
61113: PPUSH
61114: CALL_OW 431
// end ;
61118: GO 61079
61120: POP
61121: POP
// end ; for i = 1 to personel do
61122: LD_ADDR_VAR 0 8
61126: PUSH
61127: DOUBLE
61128: LD_INT 1
61130: DEC
61131: ST_TO_ADDR
61132: LD_VAR 0 6
61136: PUSH
61137: FOR_TO
61138: IFFALSE 62202
// begin if i > 4 then
61140: LD_VAR 0 8
61144: PUSH
61145: LD_INT 4
61147: GREATER
61148: IFFALSE 61152
// break ;
61150: GO 62202
// case i of 1 :
61152: LD_VAR 0 8
61156: PUSH
61157: LD_INT 1
61159: DOUBLE
61160: EQUAL
61161: IFTRUE 61165
61163: GO 61245
61165: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61166: LD_ADDR_VAR 0 12
61170: PUSH
61171: LD_VAR 0 18
61175: PPUSH
61176: LD_INT 22
61178: PUSH
61179: LD_VAR 0 16
61183: PUSH
61184: EMPTY
61185: LIST
61186: LIST
61187: PUSH
61188: LD_INT 58
61190: PUSH
61191: EMPTY
61192: LIST
61193: PUSH
61194: LD_INT 2
61196: PUSH
61197: LD_INT 30
61199: PUSH
61200: LD_INT 32
61202: PUSH
61203: EMPTY
61204: LIST
61205: LIST
61206: PUSH
61207: LD_INT 30
61209: PUSH
61210: LD_INT 4
61212: PUSH
61213: EMPTY
61214: LIST
61215: LIST
61216: PUSH
61217: LD_INT 30
61219: PUSH
61220: LD_INT 5
61222: PUSH
61223: EMPTY
61224: LIST
61225: LIST
61226: PUSH
61227: EMPTY
61228: LIST
61229: LIST
61230: LIST
61231: LIST
61232: PUSH
61233: EMPTY
61234: LIST
61235: LIST
61236: LIST
61237: PPUSH
61238: CALL_OW 72
61242: ST_TO_ADDR
61243: GO 61467
61245: LD_INT 2
61247: DOUBLE
61248: EQUAL
61249: IFTRUE 61253
61251: GO 61315
61253: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61254: LD_ADDR_VAR 0 12
61258: PUSH
61259: LD_VAR 0 18
61263: PPUSH
61264: LD_INT 22
61266: PUSH
61267: LD_VAR 0 16
61271: PUSH
61272: EMPTY
61273: LIST
61274: LIST
61275: PUSH
61276: LD_INT 2
61278: PUSH
61279: LD_INT 30
61281: PUSH
61282: LD_INT 0
61284: PUSH
61285: EMPTY
61286: LIST
61287: LIST
61288: PUSH
61289: LD_INT 30
61291: PUSH
61292: LD_INT 1
61294: PUSH
61295: EMPTY
61296: LIST
61297: LIST
61298: PUSH
61299: EMPTY
61300: LIST
61301: LIST
61302: LIST
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: PPUSH
61308: CALL_OW 72
61312: ST_TO_ADDR
61313: GO 61467
61315: LD_INT 3
61317: DOUBLE
61318: EQUAL
61319: IFTRUE 61323
61321: GO 61385
61323: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61324: LD_ADDR_VAR 0 12
61328: PUSH
61329: LD_VAR 0 18
61333: PPUSH
61334: LD_INT 22
61336: PUSH
61337: LD_VAR 0 16
61341: PUSH
61342: EMPTY
61343: LIST
61344: LIST
61345: PUSH
61346: LD_INT 2
61348: PUSH
61349: LD_INT 30
61351: PUSH
61352: LD_INT 2
61354: PUSH
61355: EMPTY
61356: LIST
61357: LIST
61358: PUSH
61359: LD_INT 30
61361: PUSH
61362: LD_INT 3
61364: PUSH
61365: EMPTY
61366: LIST
61367: LIST
61368: PUSH
61369: EMPTY
61370: LIST
61371: LIST
61372: LIST
61373: PUSH
61374: EMPTY
61375: LIST
61376: LIST
61377: PPUSH
61378: CALL_OW 72
61382: ST_TO_ADDR
61383: GO 61467
61385: LD_INT 4
61387: DOUBLE
61388: EQUAL
61389: IFTRUE 61393
61391: GO 61466
61393: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61394: LD_ADDR_VAR 0 12
61398: PUSH
61399: LD_VAR 0 18
61403: PPUSH
61404: LD_INT 22
61406: PUSH
61407: LD_VAR 0 16
61411: PUSH
61412: EMPTY
61413: LIST
61414: LIST
61415: PUSH
61416: LD_INT 2
61418: PUSH
61419: LD_INT 30
61421: PUSH
61422: LD_INT 6
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PUSH
61429: LD_INT 30
61431: PUSH
61432: LD_INT 7
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: PUSH
61439: LD_INT 30
61441: PUSH
61442: LD_INT 8
61444: PUSH
61445: EMPTY
61446: LIST
61447: LIST
61448: PUSH
61449: EMPTY
61450: LIST
61451: LIST
61452: LIST
61453: LIST
61454: PUSH
61455: EMPTY
61456: LIST
61457: LIST
61458: PPUSH
61459: CALL_OW 72
61463: ST_TO_ADDR
61464: GO 61467
61466: POP
// if i = 1 then
61467: LD_VAR 0 8
61471: PUSH
61472: LD_INT 1
61474: EQUAL
61475: IFFALSE 61586
// begin tmp := [ ] ;
61477: LD_ADDR_VAR 0 19
61481: PUSH
61482: EMPTY
61483: ST_TO_ADDR
// for j in f do
61484: LD_ADDR_VAR 0 9
61488: PUSH
61489: LD_VAR 0 12
61493: PUSH
61494: FOR_IN
61495: IFFALSE 61568
// if GetBType ( j ) = b_bunker then
61497: LD_VAR 0 9
61501: PPUSH
61502: CALL_OW 266
61506: PUSH
61507: LD_INT 32
61509: EQUAL
61510: IFFALSE 61537
// tmp := Insert ( tmp , 1 , j ) else
61512: LD_ADDR_VAR 0 19
61516: PUSH
61517: LD_VAR 0 19
61521: PPUSH
61522: LD_INT 1
61524: PPUSH
61525: LD_VAR 0 9
61529: PPUSH
61530: CALL_OW 2
61534: ST_TO_ADDR
61535: GO 61566
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61537: LD_ADDR_VAR 0 19
61541: PUSH
61542: LD_VAR 0 19
61546: PPUSH
61547: LD_VAR 0 19
61551: PUSH
61552: LD_INT 1
61554: PLUS
61555: PPUSH
61556: LD_VAR 0 9
61560: PPUSH
61561: CALL_OW 2
61565: ST_TO_ADDR
61566: GO 61494
61568: POP
61569: POP
// if tmp then
61570: LD_VAR 0 19
61574: IFFALSE 61586
// f := tmp ;
61576: LD_ADDR_VAR 0 12
61580: PUSH
61581: LD_VAR 0 19
61585: ST_TO_ADDR
// end ; x := personel [ i ] ;
61586: LD_ADDR_VAR 0 13
61590: PUSH
61591: LD_VAR 0 6
61595: PUSH
61596: LD_VAR 0 8
61600: ARRAY
61601: ST_TO_ADDR
// if x = - 1 then
61602: LD_VAR 0 13
61606: PUSH
61607: LD_INT 1
61609: NEG
61610: EQUAL
61611: IFFALSE 61820
// begin for j in f do
61613: LD_ADDR_VAR 0 9
61617: PUSH
61618: LD_VAR 0 12
61622: PUSH
61623: FOR_IN
61624: IFFALSE 61816
// repeat InitHc ;
61626: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61630: LD_VAR 0 9
61634: PPUSH
61635: CALL_OW 266
61639: PUSH
61640: LD_INT 5
61642: EQUAL
61643: IFFALSE 61713
// begin if UnitsInside ( j ) < 3 then
61645: LD_VAR 0 9
61649: PPUSH
61650: CALL_OW 313
61654: PUSH
61655: LD_INT 3
61657: LESS
61658: IFFALSE 61694
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61660: LD_INT 0
61662: PPUSH
61663: LD_INT 5
61665: PUSH
61666: LD_INT 8
61668: PUSH
61669: LD_INT 9
61671: PUSH
61672: EMPTY
61673: LIST
61674: LIST
61675: LIST
61676: PUSH
61677: LD_VAR 0 17
61681: ARRAY
61682: PPUSH
61683: LD_VAR 0 4
61687: PPUSH
61688: CALL_OW 380
61692: GO 61711
// PrepareHuman ( false , i , skill ) ;
61694: LD_INT 0
61696: PPUSH
61697: LD_VAR 0 8
61701: PPUSH
61702: LD_VAR 0 4
61706: PPUSH
61707: CALL_OW 380
// end else
61711: GO 61730
// PrepareHuman ( false , i , skill ) ;
61713: LD_INT 0
61715: PPUSH
61716: LD_VAR 0 8
61720: PPUSH
61721: LD_VAR 0 4
61725: PPUSH
61726: CALL_OW 380
// un := CreateHuman ;
61730: LD_ADDR_VAR 0 14
61734: PUSH
61735: CALL_OW 44
61739: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61740: LD_ADDR_VAR 0 7
61744: PUSH
61745: LD_VAR 0 7
61749: PPUSH
61750: LD_INT 1
61752: PPUSH
61753: LD_VAR 0 14
61757: PPUSH
61758: CALL_OW 2
61762: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61763: LD_VAR 0 14
61767: PPUSH
61768: LD_VAR 0 9
61772: PPUSH
61773: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61777: LD_VAR 0 9
61781: PPUSH
61782: CALL_OW 313
61786: PUSH
61787: LD_INT 6
61789: EQUAL
61790: PUSH
61791: LD_VAR 0 9
61795: PPUSH
61796: CALL_OW 266
61800: PUSH
61801: LD_INT 32
61803: PUSH
61804: LD_INT 31
61806: PUSH
61807: EMPTY
61808: LIST
61809: LIST
61810: IN
61811: OR
61812: IFFALSE 61626
61814: GO 61623
61816: POP
61817: POP
// end else
61818: GO 62200
// for j = 1 to x do
61820: LD_ADDR_VAR 0 9
61824: PUSH
61825: DOUBLE
61826: LD_INT 1
61828: DEC
61829: ST_TO_ADDR
61830: LD_VAR 0 13
61834: PUSH
61835: FOR_TO
61836: IFFALSE 62198
// begin InitHc ;
61838: CALL_OW 19
// if not f then
61842: LD_VAR 0 12
61846: NOT
61847: IFFALSE 61936
// begin PrepareHuman ( false , i , skill ) ;
61849: LD_INT 0
61851: PPUSH
61852: LD_VAR 0 8
61856: PPUSH
61857: LD_VAR 0 4
61861: PPUSH
61862: CALL_OW 380
// un := CreateHuman ;
61866: LD_ADDR_VAR 0 14
61870: PUSH
61871: CALL_OW 44
61875: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61876: LD_ADDR_VAR 0 7
61880: PUSH
61881: LD_VAR 0 7
61885: PPUSH
61886: LD_INT 1
61888: PPUSH
61889: LD_VAR 0 14
61893: PPUSH
61894: CALL_OW 2
61898: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61899: LD_VAR 0 14
61903: PPUSH
61904: LD_VAR 0 1
61908: PPUSH
61909: CALL_OW 250
61913: PPUSH
61914: LD_VAR 0 1
61918: PPUSH
61919: CALL_OW 251
61923: PPUSH
61924: LD_INT 10
61926: PPUSH
61927: LD_INT 0
61929: PPUSH
61930: CALL_OW 50
// continue ;
61934: GO 61835
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61936: LD_VAR 0 12
61940: PUSH
61941: LD_INT 1
61943: ARRAY
61944: PPUSH
61945: CALL_OW 313
61949: PUSH
61950: LD_VAR 0 12
61954: PUSH
61955: LD_INT 1
61957: ARRAY
61958: PPUSH
61959: CALL_OW 266
61963: PUSH
61964: LD_INT 32
61966: PUSH
61967: LD_INT 31
61969: PUSH
61970: EMPTY
61971: LIST
61972: LIST
61973: IN
61974: AND
61975: PUSH
61976: LD_VAR 0 12
61980: PUSH
61981: LD_INT 1
61983: ARRAY
61984: PPUSH
61985: CALL_OW 313
61989: PUSH
61990: LD_INT 6
61992: EQUAL
61993: OR
61994: IFFALSE 62014
// f := Delete ( f , 1 ) ;
61996: LD_ADDR_VAR 0 12
62000: PUSH
62001: LD_VAR 0 12
62005: PPUSH
62006: LD_INT 1
62008: PPUSH
62009: CALL_OW 3
62013: ST_TO_ADDR
// if not f then
62014: LD_VAR 0 12
62018: NOT
62019: IFFALSE 62037
// begin x := x + 2 ;
62021: LD_ADDR_VAR 0 13
62025: PUSH
62026: LD_VAR 0 13
62030: PUSH
62031: LD_INT 2
62033: PLUS
62034: ST_TO_ADDR
// continue ;
62035: GO 61835
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62037: LD_VAR 0 12
62041: PUSH
62042: LD_INT 1
62044: ARRAY
62045: PPUSH
62046: CALL_OW 266
62050: PUSH
62051: LD_INT 5
62053: EQUAL
62054: IFFALSE 62128
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62056: LD_VAR 0 12
62060: PUSH
62061: LD_INT 1
62063: ARRAY
62064: PPUSH
62065: CALL_OW 313
62069: PUSH
62070: LD_INT 3
62072: LESS
62073: IFFALSE 62109
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62075: LD_INT 0
62077: PPUSH
62078: LD_INT 5
62080: PUSH
62081: LD_INT 8
62083: PUSH
62084: LD_INT 9
62086: PUSH
62087: EMPTY
62088: LIST
62089: LIST
62090: LIST
62091: PUSH
62092: LD_VAR 0 17
62096: ARRAY
62097: PPUSH
62098: LD_VAR 0 4
62102: PPUSH
62103: CALL_OW 380
62107: GO 62126
// PrepareHuman ( false , i , skill ) ;
62109: LD_INT 0
62111: PPUSH
62112: LD_VAR 0 8
62116: PPUSH
62117: LD_VAR 0 4
62121: PPUSH
62122: CALL_OW 380
// end else
62126: GO 62145
// PrepareHuman ( false , i , skill ) ;
62128: LD_INT 0
62130: PPUSH
62131: LD_VAR 0 8
62135: PPUSH
62136: LD_VAR 0 4
62140: PPUSH
62141: CALL_OW 380
// un := CreateHuman ;
62145: LD_ADDR_VAR 0 14
62149: PUSH
62150: CALL_OW 44
62154: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62155: LD_ADDR_VAR 0 7
62159: PUSH
62160: LD_VAR 0 7
62164: PPUSH
62165: LD_INT 1
62167: PPUSH
62168: LD_VAR 0 14
62172: PPUSH
62173: CALL_OW 2
62177: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62178: LD_VAR 0 14
62182: PPUSH
62183: LD_VAR 0 12
62187: PUSH
62188: LD_INT 1
62190: ARRAY
62191: PPUSH
62192: CALL_OW 52
// end ;
62196: GO 61835
62198: POP
62199: POP
// end ;
62200: GO 61137
62202: POP
62203: POP
// result := result ^ buildings ;
62204: LD_ADDR_VAR 0 7
62208: PUSH
62209: LD_VAR 0 7
62213: PUSH
62214: LD_VAR 0 18
62218: ADD
62219: ST_TO_ADDR
// end else
62220: GO 62363
// begin for i = 1 to personel do
62222: LD_ADDR_VAR 0 8
62226: PUSH
62227: DOUBLE
62228: LD_INT 1
62230: DEC
62231: ST_TO_ADDR
62232: LD_VAR 0 6
62236: PUSH
62237: FOR_TO
62238: IFFALSE 62361
// begin if i > 4 then
62240: LD_VAR 0 8
62244: PUSH
62245: LD_INT 4
62247: GREATER
62248: IFFALSE 62252
// break ;
62250: GO 62361
// x := personel [ i ] ;
62252: LD_ADDR_VAR 0 13
62256: PUSH
62257: LD_VAR 0 6
62261: PUSH
62262: LD_VAR 0 8
62266: ARRAY
62267: ST_TO_ADDR
// if x = - 1 then
62268: LD_VAR 0 13
62272: PUSH
62273: LD_INT 1
62275: NEG
62276: EQUAL
62277: IFFALSE 62281
// continue ;
62279: GO 62237
// PrepareHuman ( false , i , skill ) ;
62281: LD_INT 0
62283: PPUSH
62284: LD_VAR 0 8
62288: PPUSH
62289: LD_VAR 0 4
62293: PPUSH
62294: CALL_OW 380
// un := CreateHuman ;
62298: LD_ADDR_VAR 0 14
62302: PUSH
62303: CALL_OW 44
62307: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62308: LD_VAR 0 14
62312: PPUSH
62313: LD_VAR 0 1
62317: PPUSH
62318: CALL_OW 250
62322: PPUSH
62323: LD_VAR 0 1
62327: PPUSH
62328: CALL_OW 251
62332: PPUSH
62333: LD_INT 10
62335: PPUSH
62336: LD_INT 0
62338: PPUSH
62339: CALL_OW 50
// result := result ^ un ;
62343: LD_ADDR_VAR 0 7
62347: PUSH
62348: LD_VAR 0 7
62352: PUSH
62353: LD_VAR 0 14
62357: ADD
62358: ST_TO_ADDR
// end ;
62359: GO 62237
62361: POP
62362: POP
// end ; end ;
62363: LD_VAR 0 7
62367: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62368: LD_INT 0
62370: PPUSH
62371: PPUSH
62372: PPUSH
62373: PPUSH
62374: PPUSH
62375: PPUSH
62376: PPUSH
62377: PPUSH
62378: PPUSH
62379: PPUSH
62380: PPUSH
62381: PPUSH
62382: PPUSH
62383: PPUSH
62384: PPUSH
62385: PPUSH
// result := false ;
62386: LD_ADDR_VAR 0 3
62390: PUSH
62391: LD_INT 0
62393: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62394: LD_VAR 0 1
62398: NOT
62399: PUSH
62400: LD_VAR 0 1
62404: PPUSH
62405: CALL_OW 266
62409: PUSH
62410: LD_INT 32
62412: PUSH
62413: LD_INT 33
62415: PUSH
62416: EMPTY
62417: LIST
62418: LIST
62419: IN
62420: NOT
62421: OR
62422: IFFALSE 62426
// exit ;
62424: GO 63562
// nat := GetNation ( tower ) ;
62426: LD_ADDR_VAR 0 12
62430: PUSH
62431: LD_VAR 0 1
62435: PPUSH
62436: CALL_OW 248
62440: ST_TO_ADDR
// side := GetSide ( tower ) ;
62441: LD_ADDR_VAR 0 16
62445: PUSH
62446: LD_VAR 0 1
62450: PPUSH
62451: CALL_OW 255
62455: ST_TO_ADDR
// x := GetX ( tower ) ;
62456: LD_ADDR_VAR 0 10
62460: PUSH
62461: LD_VAR 0 1
62465: PPUSH
62466: CALL_OW 250
62470: ST_TO_ADDR
// y := GetY ( tower ) ;
62471: LD_ADDR_VAR 0 11
62475: PUSH
62476: LD_VAR 0 1
62480: PPUSH
62481: CALL_OW 251
62485: ST_TO_ADDR
// if not x or not y then
62486: LD_VAR 0 10
62490: NOT
62491: PUSH
62492: LD_VAR 0 11
62496: NOT
62497: OR
62498: IFFALSE 62502
// exit ;
62500: GO 63562
// weapon := 0 ;
62502: LD_ADDR_VAR 0 18
62506: PUSH
62507: LD_INT 0
62509: ST_TO_ADDR
// fac_list := [ ] ;
62510: LD_ADDR_VAR 0 17
62514: PUSH
62515: EMPTY
62516: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62517: LD_ADDR_VAR 0 6
62521: PUSH
62522: LD_VAR 0 1
62526: PPUSH
62527: CALL_OW 274
62531: PPUSH
62532: LD_VAR 0 2
62536: PPUSH
62537: CALL 60140 0 2
62541: PPUSH
62542: LD_INT 30
62544: PUSH
62545: LD_INT 3
62547: PUSH
62548: EMPTY
62549: LIST
62550: LIST
62551: PPUSH
62552: CALL_OW 72
62556: ST_TO_ADDR
// if not factories then
62557: LD_VAR 0 6
62561: NOT
62562: IFFALSE 62566
// exit ;
62564: GO 63562
// for i in factories do
62566: LD_ADDR_VAR 0 8
62570: PUSH
62571: LD_VAR 0 6
62575: PUSH
62576: FOR_IN
62577: IFFALSE 62602
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62579: LD_ADDR_VAR 0 17
62583: PUSH
62584: LD_VAR 0 17
62588: PUSH
62589: LD_VAR 0 8
62593: PPUSH
62594: CALL_OW 478
62598: UNION
62599: ST_TO_ADDR
62600: GO 62576
62602: POP
62603: POP
// if not fac_list then
62604: LD_VAR 0 17
62608: NOT
62609: IFFALSE 62613
// exit ;
62611: GO 63562
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62613: LD_ADDR_VAR 0 5
62617: PUSH
62618: LD_INT 4
62620: PUSH
62621: LD_INT 5
62623: PUSH
62624: LD_INT 9
62626: PUSH
62627: LD_INT 10
62629: PUSH
62630: LD_INT 6
62632: PUSH
62633: LD_INT 7
62635: PUSH
62636: LD_INT 11
62638: PUSH
62639: EMPTY
62640: LIST
62641: LIST
62642: LIST
62643: LIST
62644: LIST
62645: LIST
62646: LIST
62647: PUSH
62648: LD_INT 27
62650: PUSH
62651: LD_INT 28
62653: PUSH
62654: LD_INT 26
62656: PUSH
62657: LD_INT 30
62659: PUSH
62660: EMPTY
62661: LIST
62662: LIST
62663: LIST
62664: LIST
62665: PUSH
62666: LD_INT 43
62668: PUSH
62669: LD_INT 44
62671: PUSH
62672: LD_INT 46
62674: PUSH
62675: LD_INT 45
62677: PUSH
62678: LD_INT 47
62680: PUSH
62681: LD_INT 49
62683: PUSH
62684: EMPTY
62685: LIST
62686: LIST
62687: LIST
62688: LIST
62689: LIST
62690: LIST
62691: PUSH
62692: EMPTY
62693: LIST
62694: LIST
62695: LIST
62696: PUSH
62697: LD_VAR 0 12
62701: ARRAY
62702: ST_TO_ADDR
// for i in list do
62703: LD_ADDR_VAR 0 8
62707: PUSH
62708: LD_VAR 0 5
62712: PUSH
62713: FOR_IN
62714: IFFALSE 62747
// if not i in fac_list then
62716: LD_VAR 0 8
62720: PUSH
62721: LD_VAR 0 17
62725: IN
62726: NOT
62727: IFFALSE 62745
// list := list diff i ;
62729: LD_ADDR_VAR 0 5
62733: PUSH
62734: LD_VAR 0 5
62738: PUSH
62739: LD_VAR 0 8
62743: DIFF
62744: ST_TO_ADDR
62745: GO 62713
62747: POP
62748: POP
// if not list then
62749: LD_VAR 0 5
62753: NOT
62754: IFFALSE 62758
// exit ;
62756: GO 63562
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62758: LD_VAR 0 12
62762: PUSH
62763: LD_INT 3
62765: EQUAL
62766: PUSH
62767: LD_INT 49
62769: PUSH
62770: LD_VAR 0 5
62774: IN
62775: AND
62776: PUSH
62777: LD_INT 31
62779: PPUSH
62780: LD_VAR 0 16
62784: PPUSH
62785: CALL_OW 321
62789: PUSH
62790: LD_INT 2
62792: EQUAL
62793: AND
62794: IFFALSE 62854
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62796: LD_INT 22
62798: PUSH
62799: LD_VAR 0 16
62803: PUSH
62804: EMPTY
62805: LIST
62806: LIST
62807: PUSH
62808: LD_INT 35
62810: PUSH
62811: LD_INT 49
62813: PUSH
62814: EMPTY
62815: LIST
62816: LIST
62817: PUSH
62818: LD_INT 91
62820: PUSH
62821: LD_VAR 0 1
62825: PUSH
62826: LD_INT 10
62828: PUSH
62829: EMPTY
62830: LIST
62831: LIST
62832: LIST
62833: PUSH
62834: EMPTY
62835: LIST
62836: LIST
62837: LIST
62838: PPUSH
62839: CALL_OW 69
62843: NOT
62844: IFFALSE 62854
// weapon := ru_time_lapser ;
62846: LD_ADDR_VAR 0 18
62850: PUSH
62851: LD_INT 49
62853: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62854: LD_VAR 0 12
62858: PUSH
62859: LD_INT 1
62861: PUSH
62862: LD_INT 2
62864: PUSH
62865: EMPTY
62866: LIST
62867: LIST
62868: IN
62869: PUSH
62870: LD_INT 11
62872: PUSH
62873: LD_VAR 0 5
62877: IN
62878: PUSH
62879: LD_INT 30
62881: PUSH
62882: LD_VAR 0 5
62886: IN
62887: OR
62888: AND
62889: PUSH
62890: LD_INT 6
62892: PPUSH
62893: LD_VAR 0 16
62897: PPUSH
62898: CALL_OW 321
62902: PUSH
62903: LD_INT 2
62905: EQUAL
62906: AND
62907: IFFALSE 63072
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62909: LD_INT 22
62911: PUSH
62912: LD_VAR 0 16
62916: PUSH
62917: EMPTY
62918: LIST
62919: LIST
62920: PUSH
62921: LD_INT 2
62923: PUSH
62924: LD_INT 35
62926: PUSH
62927: LD_INT 11
62929: PUSH
62930: EMPTY
62931: LIST
62932: LIST
62933: PUSH
62934: LD_INT 35
62936: PUSH
62937: LD_INT 30
62939: PUSH
62940: EMPTY
62941: LIST
62942: LIST
62943: PUSH
62944: EMPTY
62945: LIST
62946: LIST
62947: LIST
62948: PUSH
62949: LD_INT 91
62951: PUSH
62952: LD_VAR 0 1
62956: PUSH
62957: LD_INT 18
62959: PUSH
62960: EMPTY
62961: LIST
62962: LIST
62963: LIST
62964: PUSH
62965: EMPTY
62966: LIST
62967: LIST
62968: LIST
62969: PPUSH
62970: CALL_OW 69
62974: NOT
62975: PUSH
62976: LD_INT 22
62978: PUSH
62979: LD_VAR 0 16
62983: PUSH
62984: EMPTY
62985: LIST
62986: LIST
62987: PUSH
62988: LD_INT 2
62990: PUSH
62991: LD_INT 30
62993: PUSH
62994: LD_INT 32
62996: PUSH
62997: EMPTY
62998: LIST
62999: LIST
63000: PUSH
63001: LD_INT 30
63003: PUSH
63004: LD_INT 33
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: PUSH
63011: EMPTY
63012: LIST
63013: LIST
63014: LIST
63015: PUSH
63016: LD_INT 91
63018: PUSH
63019: LD_VAR 0 1
63023: PUSH
63024: LD_INT 12
63026: PUSH
63027: EMPTY
63028: LIST
63029: LIST
63030: LIST
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: LIST
63036: PUSH
63037: EMPTY
63038: LIST
63039: PPUSH
63040: CALL_OW 69
63044: PUSH
63045: LD_INT 2
63047: GREATER
63048: AND
63049: IFFALSE 63072
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63051: LD_ADDR_VAR 0 18
63055: PUSH
63056: LD_INT 11
63058: PUSH
63059: LD_INT 30
63061: PUSH
63062: EMPTY
63063: LIST
63064: LIST
63065: PUSH
63066: LD_VAR 0 12
63070: ARRAY
63071: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63072: LD_VAR 0 18
63076: NOT
63077: PUSH
63078: LD_INT 40
63080: PPUSH
63081: LD_VAR 0 16
63085: PPUSH
63086: CALL_OW 321
63090: PUSH
63091: LD_INT 2
63093: EQUAL
63094: AND
63095: PUSH
63096: LD_INT 7
63098: PUSH
63099: LD_VAR 0 5
63103: IN
63104: PUSH
63105: LD_INT 28
63107: PUSH
63108: LD_VAR 0 5
63112: IN
63113: OR
63114: PUSH
63115: LD_INT 45
63117: PUSH
63118: LD_VAR 0 5
63122: IN
63123: OR
63124: AND
63125: IFFALSE 63379
// begin hex := GetHexInfo ( x , y ) ;
63127: LD_ADDR_VAR 0 4
63131: PUSH
63132: LD_VAR 0 10
63136: PPUSH
63137: LD_VAR 0 11
63141: PPUSH
63142: CALL_OW 546
63146: ST_TO_ADDR
// if hex [ 1 ] then
63147: LD_VAR 0 4
63151: PUSH
63152: LD_INT 1
63154: ARRAY
63155: IFFALSE 63159
// exit ;
63157: GO 63562
// height := hex [ 2 ] ;
63159: LD_ADDR_VAR 0 15
63163: PUSH
63164: LD_VAR 0 4
63168: PUSH
63169: LD_INT 2
63171: ARRAY
63172: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63173: LD_ADDR_VAR 0 14
63177: PUSH
63178: LD_INT 0
63180: PUSH
63181: LD_INT 2
63183: PUSH
63184: LD_INT 3
63186: PUSH
63187: LD_INT 5
63189: PUSH
63190: EMPTY
63191: LIST
63192: LIST
63193: LIST
63194: LIST
63195: ST_TO_ADDR
// for i in tmp do
63196: LD_ADDR_VAR 0 8
63200: PUSH
63201: LD_VAR 0 14
63205: PUSH
63206: FOR_IN
63207: IFFALSE 63377
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63209: LD_ADDR_VAR 0 9
63213: PUSH
63214: LD_VAR 0 10
63218: PPUSH
63219: LD_VAR 0 8
63223: PPUSH
63224: LD_INT 5
63226: PPUSH
63227: CALL_OW 272
63231: PUSH
63232: LD_VAR 0 11
63236: PPUSH
63237: LD_VAR 0 8
63241: PPUSH
63242: LD_INT 5
63244: PPUSH
63245: CALL_OW 273
63249: PUSH
63250: EMPTY
63251: LIST
63252: LIST
63253: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63254: LD_VAR 0 9
63258: PUSH
63259: LD_INT 1
63261: ARRAY
63262: PPUSH
63263: LD_VAR 0 9
63267: PUSH
63268: LD_INT 2
63270: ARRAY
63271: PPUSH
63272: CALL_OW 488
63276: IFFALSE 63375
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63278: LD_ADDR_VAR 0 4
63282: PUSH
63283: LD_VAR 0 9
63287: PUSH
63288: LD_INT 1
63290: ARRAY
63291: PPUSH
63292: LD_VAR 0 9
63296: PUSH
63297: LD_INT 2
63299: ARRAY
63300: PPUSH
63301: CALL_OW 546
63305: ST_TO_ADDR
// if hex [ 1 ] then
63306: LD_VAR 0 4
63310: PUSH
63311: LD_INT 1
63313: ARRAY
63314: IFFALSE 63318
// continue ;
63316: GO 63206
// h := hex [ 2 ] ;
63318: LD_ADDR_VAR 0 13
63322: PUSH
63323: LD_VAR 0 4
63327: PUSH
63328: LD_INT 2
63330: ARRAY
63331: ST_TO_ADDR
// if h + 7 < height then
63332: LD_VAR 0 13
63336: PUSH
63337: LD_INT 7
63339: PLUS
63340: PUSH
63341: LD_VAR 0 15
63345: LESS
63346: IFFALSE 63375
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63348: LD_ADDR_VAR 0 18
63352: PUSH
63353: LD_INT 7
63355: PUSH
63356: LD_INT 28
63358: PUSH
63359: LD_INT 45
63361: PUSH
63362: EMPTY
63363: LIST
63364: LIST
63365: LIST
63366: PUSH
63367: LD_VAR 0 12
63371: ARRAY
63372: ST_TO_ADDR
// break ;
63373: GO 63377
// end ; end ; end ;
63375: GO 63206
63377: POP
63378: POP
// end ; if not weapon then
63379: LD_VAR 0 18
63383: NOT
63384: IFFALSE 63444
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63386: LD_ADDR_VAR 0 5
63390: PUSH
63391: LD_VAR 0 5
63395: PUSH
63396: LD_INT 11
63398: PUSH
63399: LD_INT 30
63401: PUSH
63402: LD_INT 49
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: LIST
63409: DIFF
63410: ST_TO_ADDR
// if not list then
63411: LD_VAR 0 5
63415: NOT
63416: IFFALSE 63420
// exit ;
63418: GO 63562
// weapon := list [ rand ( 1 , list ) ] ;
63420: LD_ADDR_VAR 0 18
63424: PUSH
63425: LD_VAR 0 5
63429: PUSH
63430: LD_INT 1
63432: PPUSH
63433: LD_VAR 0 5
63437: PPUSH
63438: CALL_OW 12
63442: ARRAY
63443: ST_TO_ADDR
// end ; if weapon then
63444: LD_VAR 0 18
63448: IFFALSE 63562
// begin tmp := CostOfWeapon ( weapon ) ;
63450: LD_ADDR_VAR 0 14
63454: PUSH
63455: LD_VAR 0 18
63459: PPUSH
63460: CALL_OW 451
63464: ST_TO_ADDR
// j := GetBase ( tower ) ;
63465: LD_ADDR_VAR 0 9
63469: PUSH
63470: LD_VAR 0 1
63474: PPUSH
63475: CALL_OW 274
63479: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63480: LD_VAR 0 9
63484: PPUSH
63485: LD_INT 1
63487: PPUSH
63488: CALL_OW 275
63492: PUSH
63493: LD_VAR 0 14
63497: PUSH
63498: LD_INT 1
63500: ARRAY
63501: GREATEREQUAL
63502: PUSH
63503: LD_VAR 0 9
63507: PPUSH
63508: LD_INT 2
63510: PPUSH
63511: CALL_OW 275
63515: PUSH
63516: LD_VAR 0 14
63520: PUSH
63521: LD_INT 2
63523: ARRAY
63524: GREATEREQUAL
63525: AND
63526: PUSH
63527: LD_VAR 0 9
63531: PPUSH
63532: LD_INT 3
63534: PPUSH
63535: CALL_OW 275
63539: PUSH
63540: LD_VAR 0 14
63544: PUSH
63545: LD_INT 3
63547: ARRAY
63548: GREATEREQUAL
63549: AND
63550: IFFALSE 63562
// result := weapon ;
63552: LD_ADDR_VAR 0 3
63556: PUSH
63557: LD_VAR 0 18
63561: ST_TO_ADDR
// end ; end ;
63562: LD_VAR 0 3
63566: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63567: LD_INT 0
63569: PPUSH
63570: PPUSH
// result := true ;
63571: LD_ADDR_VAR 0 3
63575: PUSH
63576: LD_INT 1
63578: ST_TO_ADDR
// if array1 = array2 then
63579: LD_VAR 0 1
63583: PUSH
63584: LD_VAR 0 2
63588: EQUAL
63589: IFFALSE 63649
// begin for i = 1 to array1 do
63591: LD_ADDR_VAR 0 4
63595: PUSH
63596: DOUBLE
63597: LD_INT 1
63599: DEC
63600: ST_TO_ADDR
63601: LD_VAR 0 1
63605: PUSH
63606: FOR_TO
63607: IFFALSE 63645
// if array1 [ i ] <> array2 [ i ] then
63609: LD_VAR 0 1
63613: PUSH
63614: LD_VAR 0 4
63618: ARRAY
63619: PUSH
63620: LD_VAR 0 2
63624: PUSH
63625: LD_VAR 0 4
63629: ARRAY
63630: NONEQUAL
63631: IFFALSE 63643
// begin result := false ;
63633: LD_ADDR_VAR 0 3
63637: PUSH
63638: LD_INT 0
63640: ST_TO_ADDR
// break ;
63641: GO 63645
// end ;
63643: GO 63606
63645: POP
63646: POP
// end else
63647: GO 63657
// result := false ;
63649: LD_ADDR_VAR 0 3
63653: PUSH
63654: LD_INT 0
63656: ST_TO_ADDR
// end ;
63657: LD_VAR 0 3
63661: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63662: LD_INT 0
63664: PPUSH
63665: PPUSH
63666: PPUSH
// pom := GetBase ( fac ) ;
63667: LD_ADDR_VAR 0 5
63671: PUSH
63672: LD_VAR 0 1
63676: PPUSH
63677: CALL_OW 274
63681: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63682: LD_ADDR_VAR 0 4
63686: PUSH
63687: LD_VAR 0 2
63691: PUSH
63692: LD_INT 1
63694: ARRAY
63695: PPUSH
63696: LD_VAR 0 2
63700: PUSH
63701: LD_INT 2
63703: ARRAY
63704: PPUSH
63705: LD_VAR 0 2
63709: PUSH
63710: LD_INT 3
63712: ARRAY
63713: PPUSH
63714: LD_VAR 0 2
63718: PUSH
63719: LD_INT 4
63721: ARRAY
63722: PPUSH
63723: CALL_OW 449
63727: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63728: LD_ADDR_VAR 0 3
63732: PUSH
63733: LD_VAR 0 5
63737: PPUSH
63738: LD_INT 1
63740: PPUSH
63741: CALL_OW 275
63745: PUSH
63746: LD_VAR 0 4
63750: PUSH
63751: LD_INT 1
63753: ARRAY
63754: GREATEREQUAL
63755: PUSH
63756: LD_VAR 0 5
63760: PPUSH
63761: LD_INT 2
63763: PPUSH
63764: CALL_OW 275
63768: PUSH
63769: LD_VAR 0 4
63773: PUSH
63774: LD_INT 2
63776: ARRAY
63777: GREATEREQUAL
63778: AND
63779: PUSH
63780: LD_VAR 0 5
63784: PPUSH
63785: LD_INT 3
63787: PPUSH
63788: CALL_OW 275
63792: PUSH
63793: LD_VAR 0 4
63797: PUSH
63798: LD_INT 3
63800: ARRAY
63801: GREATEREQUAL
63802: AND
63803: ST_TO_ADDR
// end ;
63804: LD_VAR 0 3
63808: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63809: LD_INT 0
63811: PPUSH
63812: PPUSH
63813: PPUSH
63814: PPUSH
// pom := GetBase ( building ) ;
63815: LD_ADDR_VAR 0 3
63819: PUSH
63820: LD_VAR 0 1
63824: PPUSH
63825: CALL_OW 274
63829: ST_TO_ADDR
// if not pom then
63830: LD_VAR 0 3
63834: NOT
63835: IFFALSE 63839
// exit ;
63837: GO 64009
// btype := GetBType ( building ) ;
63839: LD_ADDR_VAR 0 5
63843: PUSH
63844: LD_VAR 0 1
63848: PPUSH
63849: CALL_OW 266
63853: ST_TO_ADDR
// if btype = b_armoury then
63854: LD_VAR 0 5
63858: PUSH
63859: LD_INT 4
63861: EQUAL
63862: IFFALSE 63872
// btype := b_barracks ;
63864: LD_ADDR_VAR 0 5
63868: PUSH
63869: LD_INT 5
63871: ST_TO_ADDR
// if btype = b_depot then
63872: LD_VAR 0 5
63876: PUSH
63877: LD_INT 0
63879: EQUAL
63880: IFFALSE 63890
// btype := b_warehouse ;
63882: LD_ADDR_VAR 0 5
63886: PUSH
63887: LD_INT 1
63889: ST_TO_ADDR
// if btype = b_workshop then
63890: LD_VAR 0 5
63894: PUSH
63895: LD_INT 2
63897: EQUAL
63898: IFFALSE 63908
// btype := b_factory ;
63900: LD_ADDR_VAR 0 5
63904: PUSH
63905: LD_INT 3
63907: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63908: LD_ADDR_VAR 0 4
63912: PUSH
63913: LD_VAR 0 5
63917: PPUSH
63918: LD_VAR 0 1
63922: PPUSH
63923: CALL_OW 248
63927: PPUSH
63928: CALL_OW 450
63932: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63933: LD_ADDR_VAR 0 2
63937: PUSH
63938: LD_VAR 0 3
63942: PPUSH
63943: LD_INT 1
63945: PPUSH
63946: CALL_OW 275
63950: PUSH
63951: LD_VAR 0 4
63955: PUSH
63956: LD_INT 1
63958: ARRAY
63959: GREATEREQUAL
63960: PUSH
63961: LD_VAR 0 3
63965: PPUSH
63966: LD_INT 2
63968: PPUSH
63969: CALL_OW 275
63973: PUSH
63974: LD_VAR 0 4
63978: PUSH
63979: LD_INT 2
63981: ARRAY
63982: GREATEREQUAL
63983: AND
63984: PUSH
63985: LD_VAR 0 3
63989: PPUSH
63990: LD_INT 3
63992: PPUSH
63993: CALL_OW 275
63997: PUSH
63998: LD_VAR 0 4
64002: PUSH
64003: LD_INT 3
64005: ARRAY
64006: GREATEREQUAL
64007: AND
64008: ST_TO_ADDR
// end ;
64009: LD_VAR 0 2
64013: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64014: LD_INT 0
64016: PPUSH
64017: PPUSH
64018: PPUSH
// pom := GetBase ( building ) ;
64019: LD_ADDR_VAR 0 4
64023: PUSH
64024: LD_VAR 0 1
64028: PPUSH
64029: CALL_OW 274
64033: ST_TO_ADDR
// if not pom then
64034: LD_VAR 0 4
64038: NOT
64039: IFFALSE 64043
// exit ;
64041: GO 64144
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64043: LD_ADDR_VAR 0 5
64047: PUSH
64048: LD_VAR 0 2
64052: PPUSH
64053: LD_VAR 0 1
64057: PPUSH
64058: CALL_OW 248
64062: PPUSH
64063: CALL_OW 450
64067: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64068: LD_ADDR_VAR 0 3
64072: PUSH
64073: LD_VAR 0 4
64077: PPUSH
64078: LD_INT 1
64080: PPUSH
64081: CALL_OW 275
64085: PUSH
64086: LD_VAR 0 5
64090: PUSH
64091: LD_INT 1
64093: ARRAY
64094: GREATEREQUAL
64095: PUSH
64096: LD_VAR 0 4
64100: PPUSH
64101: LD_INT 2
64103: PPUSH
64104: CALL_OW 275
64108: PUSH
64109: LD_VAR 0 5
64113: PUSH
64114: LD_INT 2
64116: ARRAY
64117: GREATEREQUAL
64118: AND
64119: PUSH
64120: LD_VAR 0 4
64124: PPUSH
64125: LD_INT 3
64127: PPUSH
64128: CALL_OW 275
64132: PUSH
64133: LD_VAR 0 5
64137: PUSH
64138: LD_INT 3
64140: ARRAY
64141: GREATEREQUAL
64142: AND
64143: ST_TO_ADDR
// end ;
64144: LD_VAR 0 3
64148: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
64149: LD_INT 0
64151: PPUSH
64152: PPUSH
64153: PPUSH
64154: PPUSH
64155: PPUSH
64156: PPUSH
64157: PPUSH
64158: PPUSH
64159: PPUSH
64160: PPUSH
// result := false ;
64161: LD_ADDR_VAR 0 6
64165: PUSH
64166: LD_INT 0
64168: ST_TO_ADDR
// if not base or not btype or not x or not y then
64169: LD_VAR 0 1
64173: NOT
64174: PUSH
64175: LD_VAR 0 2
64179: NOT
64180: OR
64181: PUSH
64182: LD_VAR 0 3
64186: NOT
64187: OR
64188: PUSH
64189: LD_VAR 0 4
64193: NOT
64194: OR
64195: IFFALSE 64199
// exit ;
64197: GO 64808
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
64199: LD_ADDR_VAR 0 12
64203: PUSH
64204: LD_VAR 0 2
64208: PPUSH
64209: LD_VAR 0 3
64213: PPUSH
64214: LD_VAR 0 4
64218: PPUSH
64219: LD_VAR 0 5
64223: PPUSH
64224: LD_VAR 0 1
64228: PUSH
64229: LD_INT 1
64231: ARRAY
64232: PPUSH
64233: CALL_OW 248
64237: PPUSH
64238: LD_INT 0
64240: PPUSH
64241: CALL 65645 0 6
64245: ST_TO_ADDR
// if not hexes then
64246: LD_VAR 0 12
64250: NOT
64251: IFFALSE 64255
// exit ;
64253: GO 64808
// for i = 1 to hexes do
64255: LD_ADDR_VAR 0 7
64259: PUSH
64260: DOUBLE
64261: LD_INT 1
64263: DEC
64264: ST_TO_ADDR
64265: LD_VAR 0 12
64269: PUSH
64270: FOR_TO
64271: IFFALSE 64806
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64273: LD_ADDR_VAR 0 11
64277: PUSH
64278: LD_VAR 0 12
64282: PUSH
64283: LD_VAR 0 7
64287: ARRAY
64288: PUSH
64289: LD_INT 1
64291: ARRAY
64292: PPUSH
64293: LD_VAR 0 12
64297: PUSH
64298: LD_VAR 0 7
64302: ARRAY
64303: PUSH
64304: LD_INT 2
64306: ARRAY
64307: PPUSH
64308: CALL_OW 428
64312: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64313: LD_VAR 0 12
64317: PUSH
64318: LD_VAR 0 7
64322: ARRAY
64323: PUSH
64324: LD_INT 1
64326: ARRAY
64327: PPUSH
64328: LD_VAR 0 12
64332: PUSH
64333: LD_VAR 0 7
64337: ARRAY
64338: PUSH
64339: LD_INT 2
64341: ARRAY
64342: PPUSH
64343: CALL_OW 351
64347: PUSH
64348: LD_VAR 0 12
64352: PUSH
64353: LD_VAR 0 7
64357: ARRAY
64358: PUSH
64359: LD_INT 1
64361: ARRAY
64362: PPUSH
64363: LD_VAR 0 12
64367: PUSH
64368: LD_VAR 0 7
64372: ARRAY
64373: PUSH
64374: LD_INT 2
64376: ARRAY
64377: PPUSH
64378: CALL_OW 488
64382: NOT
64383: OR
64384: PUSH
64385: LD_VAR 0 11
64389: PPUSH
64390: CALL_OW 247
64394: PUSH
64395: LD_INT 3
64397: EQUAL
64398: OR
64399: IFFALSE 64405
// exit ;
64401: POP
64402: POP
64403: GO 64808
// if not tmp or not tmp in base then
64405: LD_VAR 0 11
64409: NOT
64410: PUSH
64411: LD_VAR 0 11
64415: PUSH
64416: LD_VAR 0 1
64420: IN
64421: NOT
64422: OR
64423: IFFALSE 64427
// continue ;
64425: GO 64270
// result := true ;
64427: LD_ADDR_VAR 0 6
64431: PUSH
64432: LD_INT 1
64434: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64435: LD_ADDR_VAR 0 15
64439: PUSH
64440: LD_VAR 0 1
64444: PPUSH
64445: LD_INT 22
64447: PUSH
64448: LD_VAR 0 11
64452: PPUSH
64453: CALL_OW 255
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: PUSH
64462: LD_INT 2
64464: PUSH
64465: LD_INT 30
64467: PUSH
64468: LD_INT 0
64470: PUSH
64471: EMPTY
64472: LIST
64473: LIST
64474: PUSH
64475: LD_INT 30
64477: PUSH
64478: LD_INT 1
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: PUSH
64485: EMPTY
64486: LIST
64487: LIST
64488: LIST
64489: PUSH
64490: EMPTY
64491: LIST
64492: LIST
64493: PPUSH
64494: CALL_OW 72
64498: ST_TO_ADDR
// if dep then
64499: LD_VAR 0 15
64503: IFFALSE 64639
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64505: LD_ADDR_VAR 0 14
64509: PUSH
64510: LD_VAR 0 15
64514: PUSH
64515: LD_INT 1
64517: ARRAY
64518: PPUSH
64519: CALL_OW 250
64523: PPUSH
64524: LD_VAR 0 15
64528: PUSH
64529: LD_INT 1
64531: ARRAY
64532: PPUSH
64533: CALL_OW 254
64537: PPUSH
64538: LD_INT 5
64540: PPUSH
64541: CALL_OW 272
64545: PUSH
64546: LD_VAR 0 15
64550: PUSH
64551: LD_INT 1
64553: ARRAY
64554: PPUSH
64555: CALL_OW 251
64559: PPUSH
64560: LD_VAR 0 15
64564: PUSH
64565: LD_INT 1
64567: ARRAY
64568: PPUSH
64569: CALL_OW 254
64573: PPUSH
64574: LD_INT 5
64576: PPUSH
64577: CALL_OW 273
64581: PUSH
64582: EMPTY
64583: LIST
64584: LIST
64585: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64586: LD_VAR 0 14
64590: PUSH
64591: LD_INT 1
64593: ARRAY
64594: PPUSH
64595: LD_VAR 0 14
64599: PUSH
64600: LD_INT 2
64602: ARRAY
64603: PPUSH
64604: CALL_OW 488
64608: IFFALSE 64639
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64610: LD_VAR 0 11
64614: PPUSH
64615: LD_VAR 0 14
64619: PUSH
64620: LD_INT 1
64622: ARRAY
64623: PPUSH
64624: LD_VAR 0 14
64628: PUSH
64629: LD_INT 2
64631: ARRAY
64632: PPUSH
64633: CALL_OW 111
// continue ;
64637: GO 64270
// end ; end ; r := GetDir ( tmp ) ;
64639: LD_ADDR_VAR 0 13
64643: PUSH
64644: LD_VAR 0 11
64648: PPUSH
64649: CALL_OW 254
64653: ST_TO_ADDR
// if r = 5 then
64654: LD_VAR 0 13
64658: PUSH
64659: LD_INT 5
64661: EQUAL
64662: IFFALSE 64672
// r := 0 ;
64664: LD_ADDR_VAR 0 13
64668: PUSH
64669: LD_INT 0
64671: ST_TO_ADDR
// for j = r to 5 do
64672: LD_ADDR_VAR 0 8
64676: PUSH
64677: DOUBLE
64678: LD_VAR 0 13
64682: DEC
64683: ST_TO_ADDR
64684: LD_INT 5
64686: PUSH
64687: FOR_TO
64688: IFFALSE 64802
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64690: LD_ADDR_VAR 0 9
64694: PUSH
64695: LD_VAR 0 11
64699: PPUSH
64700: CALL_OW 250
64704: PPUSH
64705: LD_VAR 0 8
64709: PPUSH
64710: LD_INT 2
64712: PPUSH
64713: CALL_OW 272
64717: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64718: LD_ADDR_VAR 0 10
64722: PUSH
64723: LD_VAR 0 11
64727: PPUSH
64728: CALL_OW 251
64732: PPUSH
64733: LD_VAR 0 8
64737: PPUSH
64738: LD_INT 2
64740: PPUSH
64741: CALL_OW 273
64745: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64746: LD_VAR 0 9
64750: PPUSH
64751: LD_VAR 0 10
64755: PPUSH
64756: CALL_OW 488
64760: PUSH
64761: LD_VAR 0 9
64765: PPUSH
64766: LD_VAR 0 10
64770: PPUSH
64771: CALL_OW 428
64775: NOT
64776: AND
64777: IFFALSE 64800
// begin ComMoveXY ( tmp , _x , _y ) ;
64779: LD_VAR 0 11
64783: PPUSH
64784: LD_VAR 0 9
64788: PPUSH
64789: LD_VAR 0 10
64793: PPUSH
64794: CALL_OW 111
// break ;
64798: GO 64802
// end ; end ;
64800: GO 64687
64802: POP
64803: POP
// end ;
64804: GO 64270
64806: POP
64807: POP
// end ;
64808: LD_VAR 0 6
64812: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
64813: LD_INT 0
64815: PPUSH
64816: PPUSH
64817: PPUSH
64818: PPUSH
64819: PPUSH
64820: PPUSH
64821: PPUSH
64822: PPUSH
64823: PPUSH
64824: PPUSH
// result := false ;
64825: LD_ADDR_VAR 0 6
64829: PUSH
64830: LD_INT 0
64832: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64833: LD_VAR 0 1
64837: NOT
64838: PUSH
64839: LD_VAR 0 1
64843: PPUSH
64844: CALL_OW 266
64848: PUSH
64849: LD_INT 0
64851: PUSH
64852: LD_INT 1
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: IN
64859: NOT
64860: OR
64861: PUSH
64862: LD_VAR 0 2
64866: NOT
64867: OR
64868: PUSH
64869: LD_VAR 0 5
64873: PUSH
64874: LD_INT 0
64876: PUSH
64877: LD_INT 1
64879: PUSH
64880: LD_INT 2
64882: PUSH
64883: LD_INT 3
64885: PUSH
64886: LD_INT 4
64888: PUSH
64889: LD_INT 5
64891: PUSH
64892: EMPTY
64893: LIST
64894: LIST
64895: LIST
64896: LIST
64897: LIST
64898: LIST
64899: IN
64900: NOT
64901: OR
64902: PUSH
64903: LD_VAR 0 3
64907: PPUSH
64908: LD_VAR 0 4
64912: PPUSH
64913: CALL_OW 488
64917: NOT
64918: OR
64919: IFFALSE 64923
// exit ;
64921: GO 65640
// pom := GetBase ( depot ) ;
64923: LD_ADDR_VAR 0 10
64927: PUSH
64928: LD_VAR 0 1
64932: PPUSH
64933: CALL_OW 274
64937: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64938: LD_ADDR_VAR 0 11
64942: PUSH
64943: LD_VAR 0 2
64947: PPUSH
64948: LD_VAR 0 1
64952: PPUSH
64953: CALL_OW 248
64957: PPUSH
64958: CALL_OW 450
64962: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64963: LD_VAR 0 10
64967: PPUSH
64968: LD_INT 1
64970: PPUSH
64971: CALL_OW 275
64975: PUSH
64976: LD_VAR 0 11
64980: PUSH
64981: LD_INT 1
64983: ARRAY
64984: GREATEREQUAL
64985: PUSH
64986: LD_VAR 0 10
64990: PPUSH
64991: LD_INT 2
64993: PPUSH
64994: CALL_OW 275
64998: PUSH
64999: LD_VAR 0 11
65003: PUSH
65004: LD_INT 2
65006: ARRAY
65007: GREATEREQUAL
65008: AND
65009: PUSH
65010: LD_VAR 0 10
65014: PPUSH
65015: LD_INT 3
65017: PPUSH
65018: CALL_OW 275
65022: PUSH
65023: LD_VAR 0 11
65027: PUSH
65028: LD_INT 3
65030: ARRAY
65031: GREATEREQUAL
65032: AND
65033: NOT
65034: IFFALSE 65038
// exit ;
65036: GO 65640
// if GetBType ( depot ) = b_depot then
65038: LD_VAR 0 1
65042: PPUSH
65043: CALL_OW 266
65047: PUSH
65048: LD_INT 0
65050: EQUAL
65051: IFFALSE 65063
// dist := 28 else
65053: LD_ADDR_VAR 0 14
65057: PUSH
65058: LD_INT 28
65060: ST_TO_ADDR
65061: GO 65071
// dist := 36 ;
65063: LD_ADDR_VAR 0 14
65067: PUSH
65068: LD_INT 36
65070: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65071: LD_VAR 0 1
65075: PPUSH
65076: LD_VAR 0 3
65080: PPUSH
65081: LD_VAR 0 4
65085: PPUSH
65086: CALL_OW 297
65090: PUSH
65091: LD_VAR 0 14
65095: GREATER
65096: IFFALSE 65100
// exit ;
65098: GO 65640
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65100: LD_ADDR_VAR 0 12
65104: PUSH
65105: LD_VAR 0 2
65109: PPUSH
65110: LD_VAR 0 3
65114: PPUSH
65115: LD_VAR 0 4
65119: PPUSH
65120: LD_VAR 0 5
65124: PPUSH
65125: LD_VAR 0 1
65129: PPUSH
65130: CALL_OW 248
65134: PPUSH
65135: LD_INT 0
65137: PPUSH
65138: CALL 65645 0 6
65142: ST_TO_ADDR
// if not hexes then
65143: LD_VAR 0 12
65147: NOT
65148: IFFALSE 65152
// exit ;
65150: GO 65640
// hex := GetHexInfo ( x , y ) ;
65152: LD_ADDR_VAR 0 15
65156: PUSH
65157: LD_VAR 0 3
65161: PPUSH
65162: LD_VAR 0 4
65166: PPUSH
65167: CALL_OW 546
65171: ST_TO_ADDR
// if hex [ 1 ] then
65172: LD_VAR 0 15
65176: PUSH
65177: LD_INT 1
65179: ARRAY
65180: IFFALSE 65184
// exit ;
65182: GO 65640
// height := hex [ 2 ] ;
65184: LD_ADDR_VAR 0 13
65188: PUSH
65189: LD_VAR 0 15
65193: PUSH
65194: LD_INT 2
65196: ARRAY
65197: ST_TO_ADDR
// for i = 1 to hexes do
65198: LD_ADDR_VAR 0 7
65202: PUSH
65203: DOUBLE
65204: LD_INT 1
65206: DEC
65207: ST_TO_ADDR
65208: LD_VAR 0 12
65212: PUSH
65213: FOR_TO
65214: IFFALSE 65544
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65216: LD_VAR 0 12
65220: PUSH
65221: LD_VAR 0 7
65225: ARRAY
65226: PUSH
65227: LD_INT 1
65229: ARRAY
65230: PPUSH
65231: LD_VAR 0 12
65235: PUSH
65236: LD_VAR 0 7
65240: ARRAY
65241: PUSH
65242: LD_INT 2
65244: ARRAY
65245: PPUSH
65246: CALL_OW 488
65250: NOT
65251: PUSH
65252: LD_VAR 0 12
65256: PUSH
65257: LD_VAR 0 7
65261: ARRAY
65262: PUSH
65263: LD_INT 1
65265: ARRAY
65266: PPUSH
65267: LD_VAR 0 12
65271: PUSH
65272: LD_VAR 0 7
65276: ARRAY
65277: PUSH
65278: LD_INT 2
65280: ARRAY
65281: PPUSH
65282: CALL_OW 428
65286: PUSH
65287: LD_INT 0
65289: GREATER
65290: OR
65291: PUSH
65292: LD_VAR 0 12
65296: PUSH
65297: LD_VAR 0 7
65301: ARRAY
65302: PUSH
65303: LD_INT 1
65305: ARRAY
65306: PPUSH
65307: LD_VAR 0 12
65311: PUSH
65312: LD_VAR 0 7
65316: ARRAY
65317: PUSH
65318: LD_INT 2
65320: ARRAY
65321: PPUSH
65322: CALL_OW 351
65326: OR
65327: IFFALSE 65333
// exit ;
65329: POP
65330: POP
65331: GO 65640
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65333: LD_ADDR_VAR 0 8
65337: PUSH
65338: LD_VAR 0 12
65342: PUSH
65343: LD_VAR 0 7
65347: ARRAY
65348: PUSH
65349: LD_INT 1
65351: ARRAY
65352: PPUSH
65353: LD_VAR 0 12
65357: PUSH
65358: LD_VAR 0 7
65362: ARRAY
65363: PUSH
65364: LD_INT 2
65366: ARRAY
65367: PPUSH
65368: CALL_OW 546
65372: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65373: LD_VAR 0 8
65377: PUSH
65378: LD_INT 1
65380: ARRAY
65381: PUSH
65382: LD_VAR 0 8
65386: PUSH
65387: LD_INT 2
65389: ARRAY
65390: PUSH
65391: LD_VAR 0 13
65395: PUSH
65396: LD_INT 2
65398: PLUS
65399: GREATER
65400: OR
65401: PUSH
65402: LD_VAR 0 8
65406: PUSH
65407: LD_INT 2
65409: ARRAY
65410: PUSH
65411: LD_VAR 0 13
65415: PUSH
65416: LD_INT 2
65418: MINUS
65419: LESS
65420: OR
65421: PUSH
65422: LD_VAR 0 8
65426: PUSH
65427: LD_INT 3
65429: ARRAY
65430: PUSH
65431: LD_INT 0
65433: PUSH
65434: LD_INT 8
65436: PUSH
65437: LD_INT 9
65439: PUSH
65440: LD_INT 10
65442: PUSH
65443: LD_INT 11
65445: PUSH
65446: LD_INT 12
65448: PUSH
65449: LD_INT 13
65451: PUSH
65452: LD_INT 16
65454: PUSH
65455: LD_INT 17
65457: PUSH
65458: LD_INT 18
65460: PUSH
65461: LD_INT 19
65463: PUSH
65464: LD_INT 20
65466: PUSH
65467: LD_INT 21
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: IN
65485: NOT
65486: OR
65487: PUSH
65488: LD_VAR 0 8
65492: PUSH
65493: LD_INT 5
65495: ARRAY
65496: NOT
65497: OR
65498: PUSH
65499: LD_VAR 0 8
65503: PUSH
65504: LD_INT 6
65506: ARRAY
65507: PUSH
65508: LD_INT 1
65510: PUSH
65511: LD_INT 2
65513: PUSH
65514: LD_INT 7
65516: PUSH
65517: LD_INT 9
65519: PUSH
65520: LD_INT 10
65522: PUSH
65523: LD_INT 11
65525: PUSH
65526: EMPTY
65527: LIST
65528: LIST
65529: LIST
65530: LIST
65531: LIST
65532: LIST
65533: IN
65534: NOT
65535: OR
65536: IFFALSE 65542
// exit ;
65538: POP
65539: POP
65540: GO 65640
// end ;
65542: GO 65213
65544: POP
65545: POP
// side := GetSide ( depot ) ;
65546: LD_ADDR_VAR 0 9
65550: PUSH
65551: LD_VAR 0 1
65555: PPUSH
65556: CALL_OW 255
65560: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65561: LD_VAR 0 9
65565: PPUSH
65566: LD_VAR 0 3
65570: PPUSH
65571: LD_VAR 0 4
65575: PPUSH
65576: LD_INT 20
65578: PPUSH
65579: CALL 58294 0 4
65583: PUSH
65584: LD_INT 4
65586: ARRAY
65587: IFFALSE 65591
// exit ;
65589: GO 65640
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65591: LD_VAR 0 2
65595: PUSH
65596: LD_INT 29
65598: PUSH
65599: LD_INT 30
65601: PUSH
65602: EMPTY
65603: LIST
65604: LIST
65605: IN
65606: PUSH
65607: LD_VAR 0 3
65611: PPUSH
65612: LD_VAR 0 4
65616: PPUSH
65617: LD_VAR 0 9
65621: PPUSH
65622: CALL_OW 440
65626: NOT
65627: AND
65628: IFFALSE 65632
// exit ;
65630: GO 65640
// result := true ;
65632: LD_ADDR_VAR 0 6
65636: PUSH
65637: LD_INT 1
65639: ST_TO_ADDR
// end ;
65640: LD_VAR 0 6
65644: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
65645: LD_INT 0
65647: PPUSH
65648: PPUSH
65649: PPUSH
65650: PPUSH
65651: PPUSH
65652: PPUSH
65653: PPUSH
65654: PPUSH
65655: PPUSH
65656: PPUSH
65657: PPUSH
65658: PPUSH
65659: PPUSH
65660: PPUSH
65661: PPUSH
65662: PPUSH
65663: PPUSH
65664: PPUSH
65665: PPUSH
65666: PPUSH
65667: PPUSH
65668: PPUSH
65669: PPUSH
65670: PPUSH
65671: PPUSH
65672: PPUSH
65673: PPUSH
65674: PPUSH
65675: PPUSH
65676: PPUSH
65677: PPUSH
65678: PPUSH
65679: PPUSH
65680: PPUSH
65681: PPUSH
65682: PPUSH
65683: PPUSH
65684: PPUSH
65685: PPUSH
65686: PPUSH
65687: PPUSH
65688: PPUSH
65689: PPUSH
65690: PPUSH
65691: PPUSH
65692: PPUSH
65693: PPUSH
65694: PPUSH
65695: PPUSH
65696: PPUSH
65697: PPUSH
65698: PPUSH
65699: PPUSH
65700: PPUSH
65701: PPUSH
65702: PPUSH
65703: PPUSH
65704: PPUSH
// result = [ ] ;
65705: LD_ADDR_VAR 0 7
65709: PUSH
65710: EMPTY
65711: ST_TO_ADDR
// temp_list = [ ] ;
65712: LD_ADDR_VAR 0 9
65716: PUSH
65717: EMPTY
65718: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65719: LD_VAR 0 4
65723: PUSH
65724: LD_INT 0
65726: PUSH
65727: LD_INT 1
65729: PUSH
65730: LD_INT 2
65732: PUSH
65733: LD_INT 3
65735: PUSH
65736: LD_INT 4
65738: PUSH
65739: LD_INT 5
65741: PUSH
65742: EMPTY
65743: LIST
65744: LIST
65745: LIST
65746: LIST
65747: LIST
65748: LIST
65749: IN
65750: NOT
65751: PUSH
65752: LD_VAR 0 1
65756: PUSH
65757: LD_INT 0
65759: PUSH
65760: LD_INT 1
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: IN
65767: PUSH
65768: LD_VAR 0 5
65772: PUSH
65773: LD_INT 1
65775: PUSH
65776: LD_INT 2
65778: PUSH
65779: LD_INT 3
65781: PUSH
65782: EMPTY
65783: LIST
65784: LIST
65785: LIST
65786: IN
65787: NOT
65788: AND
65789: OR
65790: IFFALSE 65794
// exit ;
65792: GO 84185
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65794: LD_VAR 0 1
65798: PUSH
65799: LD_INT 6
65801: PUSH
65802: LD_INT 7
65804: PUSH
65805: LD_INT 8
65807: PUSH
65808: LD_INT 13
65810: PUSH
65811: LD_INT 12
65813: PUSH
65814: LD_INT 15
65816: PUSH
65817: LD_INT 11
65819: PUSH
65820: LD_INT 14
65822: PUSH
65823: LD_INT 10
65825: PUSH
65826: EMPTY
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: IN
65837: IFFALSE 65847
// btype = b_lab ;
65839: LD_ADDR_VAR 0 1
65843: PUSH
65844: LD_INT 6
65846: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65847: LD_VAR 0 6
65851: PUSH
65852: LD_INT 0
65854: PUSH
65855: LD_INT 1
65857: PUSH
65858: LD_INT 2
65860: PUSH
65861: EMPTY
65862: LIST
65863: LIST
65864: LIST
65865: IN
65866: NOT
65867: PUSH
65868: LD_VAR 0 1
65872: PUSH
65873: LD_INT 0
65875: PUSH
65876: LD_INT 1
65878: PUSH
65879: LD_INT 2
65881: PUSH
65882: LD_INT 3
65884: PUSH
65885: LD_INT 6
65887: PUSH
65888: LD_INT 36
65890: PUSH
65891: LD_INT 4
65893: PUSH
65894: LD_INT 5
65896: PUSH
65897: LD_INT 31
65899: PUSH
65900: LD_INT 32
65902: PUSH
65903: LD_INT 33
65905: PUSH
65906: EMPTY
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: IN
65919: NOT
65920: PUSH
65921: LD_VAR 0 6
65925: PUSH
65926: LD_INT 1
65928: EQUAL
65929: AND
65930: OR
65931: PUSH
65932: LD_VAR 0 1
65936: PUSH
65937: LD_INT 2
65939: PUSH
65940: LD_INT 3
65942: PUSH
65943: EMPTY
65944: LIST
65945: LIST
65946: IN
65947: NOT
65948: PUSH
65949: LD_VAR 0 6
65953: PUSH
65954: LD_INT 2
65956: EQUAL
65957: AND
65958: OR
65959: IFFALSE 65969
// mode = 0 ;
65961: LD_ADDR_VAR 0 6
65965: PUSH
65966: LD_INT 0
65968: ST_TO_ADDR
// case mode of 0 :
65969: LD_VAR 0 6
65973: PUSH
65974: LD_INT 0
65976: DOUBLE
65977: EQUAL
65978: IFTRUE 65982
65980: GO 77435
65982: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65983: LD_ADDR_VAR 0 11
65987: PUSH
65988: LD_INT 0
65990: PUSH
65991: LD_INT 0
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: PUSH
65998: LD_INT 0
66000: PUSH
66001: LD_INT 1
66003: NEG
66004: PUSH
66005: EMPTY
66006: LIST
66007: LIST
66008: PUSH
66009: LD_INT 1
66011: PUSH
66012: LD_INT 0
66014: PUSH
66015: EMPTY
66016: LIST
66017: LIST
66018: PUSH
66019: LD_INT 1
66021: PUSH
66022: LD_INT 1
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: PUSH
66029: LD_INT 0
66031: PUSH
66032: LD_INT 1
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 1
66041: NEG
66042: PUSH
66043: LD_INT 0
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 1
66052: NEG
66053: PUSH
66054: LD_INT 1
66056: NEG
66057: PUSH
66058: EMPTY
66059: LIST
66060: LIST
66061: PUSH
66062: LD_INT 1
66064: NEG
66065: PUSH
66066: LD_INT 2
66068: NEG
66069: PUSH
66070: EMPTY
66071: LIST
66072: LIST
66073: PUSH
66074: LD_INT 0
66076: PUSH
66077: LD_INT 2
66079: NEG
66080: PUSH
66081: EMPTY
66082: LIST
66083: LIST
66084: PUSH
66085: LD_INT 1
66087: PUSH
66088: LD_INT 1
66090: NEG
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PUSH
66096: LD_INT 1
66098: PUSH
66099: LD_INT 2
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: LD_INT 0
66108: PUSH
66109: LD_INT 2
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PUSH
66116: LD_INT 1
66118: NEG
66119: PUSH
66120: LD_INT 1
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 1
66129: PUSH
66130: LD_INT 3
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 0
66139: PUSH
66140: LD_INT 3
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PUSH
66147: LD_INT 1
66149: NEG
66150: PUSH
66151: LD_INT 2
66153: PUSH
66154: EMPTY
66155: LIST
66156: LIST
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66176: LD_ADDR_VAR 0 12
66180: PUSH
66181: LD_INT 0
66183: PUSH
66184: LD_INT 0
66186: PUSH
66187: EMPTY
66188: LIST
66189: LIST
66190: PUSH
66191: LD_INT 0
66193: PUSH
66194: LD_INT 1
66196: NEG
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PUSH
66202: LD_INT 1
66204: PUSH
66205: LD_INT 0
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PUSH
66212: LD_INT 1
66214: PUSH
66215: LD_INT 1
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: PUSH
66222: LD_INT 0
66224: PUSH
66225: LD_INT 1
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: PUSH
66232: LD_INT 1
66234: NEG
66235: PUSH
66236: LD_INT 0
66238: PUSH
66239: EMPTY
66240: LIST
66241: LIST
66242: PUSH
66243: LD_INT 1
66245: NEG
66246: PUSH
66247: LD_INT 1
66249: NEG
66250: PUSH
66251: EMPTY
66252: LIST
66253: LIST
66254: PUSH
66255: LD_INT 1
66257: PUSH
66258: LD_INT 1
66260: NEG
66261: PUSH
66262: EMPTY
66263: LIST
66264: LIST
66265: PUSH
66266: LD_INT 2
66268: PUSH
66269: LD_INT 0
66271: PUSH
66272: EMPTY
66273: LIST
66274: LIST
66275: PUSH
66276: LD_INT 2
66278: PUSH
66279: LD_INT 1
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: PUSH
66286: LD_INT 1
66288: NEG
66289: PUSH
66290: LD_INT 1
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: PUSH
66297: LD_INT 2
66299: NEG
66300: PUSH
66301: LD_INT 0
66303: PUSH
66304: EMPTY
66305: LIST
66306: LIST
66307: PUSH
66308: LD_INT 2
66310: NEG
66311: PUSH
66312: LD_INT 1
66314: NEG
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: LD_INT 2
66322: NEG
66323: PUSH
66324: LD_INT 1
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: PUSH
66331: LD_INT 3
66333: NEG
66334: PUSH
66335: LD_INT 0
66337: PUSH
66338: EMPTY
66339: LIST
66340: LIST
66341: PUSH
66342: LD_INT 3
66344: NEG
66345: PUSH
66346: LD_INT 1
66348: NEG
66349: PUSH
66350: EMPTY
66351: LIST
66352: LIST
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66372: LD_ADDR_VAR 0 13
66376: PUSH
66377: LD_INT 0
66379: PUSH
66380: LD_INT 0
66382: PUSH
66383: EMPTY
66384: LIST
66385: LIST
66386: PUSH
66387: LD_INT 0
66389: PUSH
66390: LD_INT 1
66392: NEG
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 1
66400: PUSH
66401: LD_INT 0
66403: PUSH
66404: EMPTY
66405: LIST
66406: LIST
66407: PUSH
66408: LD_INT 1
66410: PUSH
66411: LD_INT 1
66413: PUSH
66414: EMPTY
66415: LIST
66416: LIST
66417: PUSH
66418: LD_INT 0
66420: PUSH
66421: LD_INT 1
66423: PUSH
66424: EMPTY
66425: LIST
66426: LIST
66427: PUSH
66428: LD_INT 1
66430: NEG
66431: PUSH
66432: LD_INT 0
66434: PUSH
66435: EMPTY
66436: LIST
66437: LIST
66438: PUSH
66439: LD_INT 1
66441: NEG
66442: PUSH
66443: LD_INT 1
66445: NEG
66446: PUSH
66447: EMPTY
66448: LIST
66449: LIST
66450: PUSH
66451: LD_INT 1
66453: NEG
66454: PUSH
66455: LD_INT 2
66457: NEG
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: PUSH
66463: LD_INT 2
66465: PUSH
66466: LD_INT 1
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: PUSH
66473: LD_INT 2
66475: PUSH
66476: LD_INT 2
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 1
66485: PUSH
66486: LD_INT 2
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: LD_INT 2
66495: NEG
66496: PUSH
66497: LD_INT 1
66499: NEG
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: LD_INT 2
66507: NEG
66508: PUSH
66509: LD_INT 2
66511: NEG
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PUSH
66517: LD_INT 2
66519: NEG
66520: PUSH
66521: LD_INT 3
66523: NEG
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: LD_INT 3
66531: NEG
66532: PUSH
66533: LD_INT 2
66535: NEG
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: PUSH
66541: LD_INT 3
66543: NEG
66544: PUSH
66545: LD_INT 3
66547: NEG
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: LIST
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: LIST
66565: LIST
66566: LIST
66567: LIST
66568: LIST
66569: LIST
66570: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66571: LD_ADDR_VAR 0 14
66575: PUSH
66576: LD_INT 0
66578: PUSH
66579: LD_INT 0
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: PUSH
66586: LD_INT 0
66588: PUSH
66589: LD_INT 1
66591: NEG
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 1
66599: PUSH
66600: LD_INT 0
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 1
66609: PUSH
66610: LD_INT 1
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: LD_INT 0
66619: PUSH
66620: LD_INT 1
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 1
66629: NEG
66630: PUSH
66631: LD_INT 0
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 1
66640: NEG
66641: PUSH
66642: LD_INT 1
66644: NEG
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: PUSH
66650: LD_INT 1
66652: NEG
66653: PUSH
66654: LD_INT 2
66656: NEG
66657: PUSH
66658: EMPTY
66659: LIST
66660: LIST
66661: PUSH
66662: LD_INT 0
66664: PUSH
66665: LD_INT 2
66667: NEG
66668: PUSH
66669: EMPTY
66670: LIST
66671: LIST
66672: PUSH
66673: LD_INT 1
66675: PUSH
66676: LD_INT 1
66678: NEG
66679: PUSH
66680: EMPTY
66681: LIST
66682: LIST
66683: PUSH
66684: LD_INT 1
66686: PUSH
66687: LD_INT 2
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: PUSH
66694: LD_INT 0
66696: PUSH
66697: LD_INT 2
66699: PUSH
66700: EMPTY
66701: LIST
66702: LIST
66703: PUSH
66704: LD_INT 1
66706: NEG
66707: PUSH
66708: LD_INT 1
66710: PUSH
66711: EMPTY
66712: LIST
66713: LIST
66714: PUSH
66715: LD_INT 1
66717: NEG
66718: PUSH
66719: LD_INT 3
66721: NEG
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: PUSH
66727: LD_INT 0
66729: PUSH
66730: LD_INT 3
66732: NEG
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: LD_INT 1
66740: PUSH
66741: LD_INT 2
66743: NEG
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66767: LD_ADDR_VAR 0 15
66771: PUSH
66772: LD_INT 0
66774: PUSH
66775: LD_INT 0
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: LD_INT 0
66784: PUSH
66785: LD_INT 1
66787: NEG
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: LD_INT 0
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: LD_INT 1
66805: PUSH
66806: LD_INT 1
66808: PUSH
66809: EMPTY
66810: LIST
66811: LIST
66812: PUSH
66813: LD_INT 0
66815: PUSH
66816: LD_INT 1
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 1
66825: NEG
66826: PUSH
66827: LD_INT 0
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: LD_INT 1
66836: NEG
66837: PUSH
66838: LD_INT 1
66840: NEG
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 1
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: LD_INT 2
66859: PUSH
66860: LD_INT 0
66862: PUSH
66863: EMPTY
66864: LIST
66865: LIST
66866: PUSH
66867: LD_INT 2
66869: PUSH
66870: LD_INT 1
66872: PUSH
66873: EMPTY
66874: LIST
66875: LIST
66876: PUSH
66877: LD_INT 1
66879: NEG
66880: PUSH
66881: LD_INT 1
66883: PUSH
66884: EMPTY
66885: LIST
66886: LIST
66887: PUSH
66888: LD_INT 2
66890: NEG
66891: PUSH
66892: LD_INT 0
66894: PUSH
66895: EMPTY
66896: LIST
66897: LIST
66898: PUSH
66899: LD_INT 2
66901: NEG
66902: PUSH
66903: LD_INT 1
66905: NEG
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: LD_INT 2
66913: PUSH
66914: LD_INT 1
66916: NEG
66917: PUSH
66918: EMPTY
66919: LIST
66920: LIST
66921: PUSH
66922: LD_INT 3
66924: PUSH
66925: LD_INT 0
66927: PUSH
66928: EMPTY
66929: LIST
66930: LIST
66931: PUSH
66932: LD_INT 3
66934: PUSH
66935: LD_INT 1
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: LIST
66946: LIST
66947: LIST
66948: LIST
66949: LIST
66950: LIST
66951: LIST
66952: LIST
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: LIST
66958: LIST
66959: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66960: LD_ADDR_VAR 0 16
66964: PUSH
66965: LD_INT 0
66967: PUSH
66968: LD_INT 0
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 0
66977: PUSH
66978: LD_INT 1
66980: NEG
66981: PUSH
66982: EMPTY
66983: LIST
66984: LIST
66985: PUSH
66986: LD_INT 1
66988: PUSH
66989: LD_INT 0
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: PUSH
66996: LD_INT 1
66998: PUSH
66999: LD_INT 1
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: PUSH
67006: LD_INT 0
67008: PUSH
67009: LD_INT 1
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 1
67018: NEG
67019: PUSH
67020: LD_INT 0
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: LD_INT 1
67029: NEG
67030: PUSH
67031: LD_INT 1
67033: NEG
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 1
67041: NEG
67042: PUSH
67043: LD_INT 2
67045: NEG
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: LD_INT 2
67053: PUSH
67054: LD_INT 1
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: PUSH
67061: LD_INT 2
67063: PUSH
67064: LD_INT 2
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: LD_INT 1
67073: PUSH
67074: LD_INT 2
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: PUSH
67081: LD_INT 2
67083: NEG
67084: PUSH
67085: LD_INT 1
67087: NEG
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PUSH
67093: LD_INT 2
67095: NEG
67096: PUSH
67097: LD_INT 2
67099: NEG
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: PUSH
67105: LD_INT 3
67107: PUSH
67108: LD_INT 2
67110: PUSH
67111: EMPTY
67112: LIST
67113: LIST
67114: PUSH
67115: LD_INT 3
67117: PUSH
67118: LD_INT 3
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 2
67127: PUSH
67128: LD_INT 3
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: PUSH
67135: EMPTY
67136: LIST
67137: LIST
67138: LIST
67139: LIST
67140: LIST
67141: LIST
67142: LIST
67143: LIST
67144: LIST
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67153: LD_ADDR_VAR 0 17
67157: PUSH
67158: LD_INT 0
67160: PUSH
67161: LD_INT 0
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 0
67170: PUSH
67171: LD_INT 1
67173: NEG
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: PUSH
67179: LD_INT 1
67181: PUSH
67182: LD_INT 0
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 1
67191: PUSH
67192: LD_INT 1
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 0
67201: PUSH
67202: LD_INT 1
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 1
67211: NEG
67212: PUSH
67213: LD_INT 0
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: PUSH
67220: LD_INT 1
67222: NEG
67223: PUSH
67224: LD_INT 1
67226: NEG
67227: PUSH
67228: EMPTY
67229: LIST
67230: LIST
67231: PUSH
67232: LD_INT 1
67234: NEG
67235: PUSH
67236: LD_INT 2
67238: NEG
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 0
67246: PUSH
67247: LD_INT 2
67249: NEG
67250: PUSH
67251: EMPTY
67252: LIST
67253: LIST
67254: PUSH
67255: LD_INT 1
67257: PUSH
67258: LD_INT 1
67260: NEG
67261: PUSH
67262: EMPTY
67263: LIST
67264: LIST
67265: PUSH
67266: LD_INT 2
67268: PUSH
67269: LD_INT 0
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: PUSH
67276: LD_INT 2
67278: PUSH
67279: LD_INT 1
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: PUSH
67286: LD_INT 2
67288: PUSH
67289: LD_INT 2
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 1
67298: PUSH
67299: LD_INT 2
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: LD_INT 0
67308: PUSH
67309: LD_INT 2
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 1
67318: NEG
67319: PUSH
67320: LD_INT 1
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: PUSH
67327: LD_INT 2
67329: NEG
67330: PUSH
67331: LD_INT 0
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: PUSH
67338: LD_INT 2
67340: NEG
67341: PUSH
67342: LD_INT 1
67344: NEG
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 2
67352: NEG
67353: PUSH
67354: LD_INT 2
67356: NEG
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: PUSH
67362: EMPTY
67363: LIST
67364: LIST
67365: LIST
67366: LIST
67367: LIST
67368: LIST
67369: LIST
67370: LIST
67371: LIST
67372: LIST
67373: LIST
67374: LIST
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67383: LD_ADDR_VAR 0 18
67387: PUSH
67388: LD_INT 0
67390: PUSH
67391: LD_INT 0
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 0
67400: PUSH
67401: LD_INT 1
67403: NEG
67404: PUSH
67405: EMPTY
67406: LIST
67407: LIST
67408: PUSH
67409: LD_INT 1
67411: PUSH
67412: LD_INT 0
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: PUSH
67419: LD_INT 1
67421: PUSH
67422: LD_INT 1
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: PUSH
67429: LD_INT 0
67431: PUSH
67432: LD_INT 1
67434: PUSH
67435: EMPTY
67436: LIST
67437: LIST
67438: PUSH
67439: LD_INT 1
67441: NEG
67442: PUSH
67443: LD_INT 0
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: LD_INT 1
67452: NEG
67453: PUSH
67454: LD_INT 1
67456: NEG
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PUSH
67462: LD_INT 1
67464: NEG
67465: PUSH
67466: LD_INT 2
67468: NEG
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 0
67476: PUSH
67477: LD_INT 2
67479: NEG
67480: PUSH
67481: EMPTY
67482: LIST
67483: LIST
67484: PUSH
67485: LD_INT 1
67487: PUSH
67488: LD_INT 1
67490: NEG
67491: PUSH
67492: EMPTY
67493: LIST
67494: LIST
67495: PUSH
67496: LD_INT 2
67498: PUSH
67499: LD_INT 0
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: PUSH
67506: LD_INT 2
67508: PUSH
67509: LD_INT 1
67511: PUSH
67512: EMPTY
67513: LIST
67514: LIST
67515: PUSH
67516: LD_INT 2
67518: PUSH
67519: LD_INT 2
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PUSH
67526: LD_INT 1
67528: PUSH
67529: LD_INT 2
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 0
67538: PUSH
67539: LD_INT 2
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: PUSH
67546: LD_INT 1
67548: NEG
67549: PUSH
67550: LD_INT 1
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: PUSH
67557: LD_INT 2
67559: NEG
67560: PUSH
67561: LD_INT 0
67563: PUSH
67564: EMPTY
67565: LIST
67566: LIST
67567: PUSH
67568: LD_INT 2
67570: NEG
67571: PUSH
67572: LD_INT 1
67574: NEG
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: PUSH
67580: LD_INT 2
67582: NEG
67583: PUSH
67584: LD_INT 2
67586: NEG
67587: PUSH
67588: EMPTY
67589: LIST
67590: LIST
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: LIST
67603: LIST
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67613: LD_ADDR_VAR 0 19
67617: PUSH
67618: LD_INT 0
67620: PUSH
67621: LD_INT 0
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 0
67630: PUSH
67631: LD_INT 1
67633: NEG
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: PUSH
67639: LD_INT 1
67641: PUSH
67642: LD_INT 0
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 1
67651: PUSH
67652: LD_INT 1
67654: PUSH
67655: EMPTY
67656: LIST
67657: LIST
67658: PUSH
67659: LD_INT 0
67661: PUSH
67662: LD_INT 1
67664: PUSH
67665: EMPTY
67666: LIST
67667: LIST
67668: PUSH
67669: LD_INT 1
67671: NEG
67672: PUSH
67673: LD_INT 0
67675: PUSH
67676: EMPTY
67677: LIST
67678: LIST
67679: PUSH
67680: LD_INT 1
67682: NEG
67683: PUSH
67684: LD_INT 1
67686: NEG
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 1
67694: NEG
67695: PUSH
67696: LD_INT 2
67698: NEG
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: LD_INT 0
67706: PUSH
67707: LD_INT 2
67709: NEG
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: LD_INT 1
67717: PUSH
67718: LD_INT 1
67720: NEG
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: PUSH
67726: LD_INT 2
67728: PUSH
67729: LD_INT 0
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: PUSH
67736: LD_INT 2
67738: PUSH
67739: LD_INT 1
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: LD_INT 2
67748: PUSH
67749: LD_INT 2
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PUSH
67756: LD_INT 1
67758: PUSH
67759: LD_INT 2
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: PUSH
67766: LD_INT 0
67768: PUSH
67769: LD_INT 2
67771: PUSH
67772: EMPTY
67773: LIST
67774: LIST
67775: PUSH
67776: LD_INT 1
67778: NEG
67779: PUSH
67780: LD_INT 1
67782: PUSH
67783: EMPTY
67784: LIST
67785: LIST
67786: PUSH
67787: LD_INT 2
67789: NEG
67790: PUSH
67791: LD_INT 0
67793: PUSH
67794: EMPTY
67795: LIST
67796: LIST
67797: PUSH
67798: LD_INT 2
67800: NEG
67801: PUSH
67802: LD_INT 1
67804: NEG
67805: PUSH
67806: EMPTY
67807: LIST
67808: LIST
67809: PUSH
67810: LD_INT 2
67812: NEG
67813: PUSH
67814: LD_INT 2
67816: NEG
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: LIST
67826: LIST
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67843: LD_ADDR_VAR 0 20
67847: PUSH
67848: LD_INT 0
67850: PUSH
67851: LD_INT 0
67853: PUSH
67854: EMPTY
67855: LIST
67856: LIST
67857: PUSH
67858: LD_INT 0
67860: PUSH
67861: LD_INT 1
67863: NEG
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 1
67871: PUSH
67872: LD_INT 0
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 1
67881: PUSH
67882: LD_INT 1
67884: PUSH
67885: EMPTY
67886: LIST
67887: LIST
67888: PUSH
67889: LD_INT 0
67891: PUSH
67892: LD_INT 1
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: PUSH
67899: LD_INT 1
67901: NEG
67902: PUSH
67903: LD_INT 0
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 1
67912: NEG
67913: PUSH
67914: LD_INT 1
67916: NEG
67917: PUSH
67918: EMPTY
67919: LIST
67920: LIST
67921: PUSH
67922: LD_INT 1
67924: NEG
67925: PUSH
67926: LD_INT 2
67928: NEG
67929: PUSH
67930: EMPTY
67931: LIST
67932: LIST
67933: PUSH
67934: LD_INT 0
67936: PUSH
67937: LD_INT 2
67939: NEG
67940: PUSH
67941: EMPTY
67942: LIST
67943: LIST
67944: PUSH
67945: LD_INT 1
67947: PUSH
67948: LD_INT 1
67950: NEG
67951: PUSH
67952: EMPTY
67953: LIST
67954: LIST
67955: PUSH
67956: LD_INT 2
67958: PUSH
67959: LD_INT 0
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 2
67968: PUSH
67969: LD_INT 1
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 2
67978: PUSH
67979: LD_INT 2
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: PUSH
67986: LD_INT 1
67988: PUSH
67989: LD_INT 2
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 0
67998: PUSH
67999: LD_INT 2
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 1
68008: NEG
68009: PUSH
68010: LD_INT 1
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 2
68019: NEG
68020: PUSH
68021: LD_INT 0
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PUSH
68028: LD_INT 2
68030: NEG
68031: PUSH
68032: LD_INT 1
68034: NEG
68035: PUSH
68036: EMPTY
68037: LIST
68038: LIST
68039: PUSH
68040: LD_INT 2
68042: NEG
68043: PUSH
68044: LD_INT 2
68046: NEG
68047: PUSH
68048: EMPTY
68049: LIST
68050: LIST
68051: PUSH
68052: EMPTY
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68073: LD_ADDR_VAR 0 21
68077: PUSH
68078: LD_INT 0
68080: PUSH
68081: LD_INT 0
68083: PUSH
68084: EMPTY
68085: LIST
68086: LIST
68087: PUSH
68088: LD_INT 0
68090: PUSH
68091: LD_INT 1
68093: NEG
68094: PUSH
68095: EMPTY
68096: LIST
68097: LIST
68098: PUSH
68099: LD_INT 1
68101: PUSH
68102: LD_INT 0
68104: PUSH
68105: EMPTY
68106: LIST
68107: LIST
68108: PUSH
68109: LD_INT 1
68111: PUSH
68112: LD_INT 1
68114: PUSH
68115: EMPTY
68116: LIST
68117: LIST
68118: PUSH
68119: LD_INT 0
68121: PUSH
68122: LD_INT 1
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PUSH
68129: LD_INT 1
68131: NEG
68132: PUSH
68133: LD_INT 0
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: LD_INT 1
68142: NEG
68143: PUSH
68144: LD_INT 1
68146: NEG
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PUSH
68152: LD_INT 1
68154: NEG
68155: PUSH
68156: LD_INT 2
68158: NEG
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: PUSH
68164: LD_INT 0
68166: PUSH
68167: LD_INT 2
68169: NEG
68170: PUSH
68171: EMPTY
68172: LIST
68173: LIST
68174: PUSH
68175: LD_INT 1
68177: PUSH
68178: LD_INT 1
68180: NEG
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: PUSH
68186: LD_INT 2
68188: PUSH
68189: LD_INT 0
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: PUSH
68196: LD_INT 2
68198: PUSH
68199: LD_INT 1
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: PUSH
68206: LD_INT 2
68208: PUSH
68209: LD_INT 2
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 1
68218: PUSH
68219: LD_INT 2
68221: PUSH
68222: EMPTY
68223: LIST
68224: LIST
68225: PUSH
68226: LD_INT 0
68228: PUSH
68229: LD_INT 2
68231: PUSH
68232: EMPTY
68233: LIST
68234: LIST
68235: PUSH
68236: LD_INT 1
68238: NEG
68239: PUSH
68240: LD_INT 1
68242: PUSH
68243: EMPTY
68244: LIST
68245: LIST
68246: PUSH
68247: LD_INT 2
68249: NEG
68250: PUSH
68251: LD_INT 0
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: LD_INT 2
68260: NEG
68261: PUSH
68262: LD_INT 1
68264: NEG
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 2
68272: NEG
68273: PUSH
68274: LD_INT 2
68276: NEG
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: PUSH
68282: EMPTY
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68303: LD_ADDR_VAR 0 22
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: LD_INT 0
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 0
68320: PUSH
68321: LD_INT 1
68323: NEG
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: LD_INT 1
68331: PUSH
68332: LD_INT 0
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 1
68341: PUSH
68342: LD_INT 1
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: PUSH
68349: LD_INT 0
68351: PUSH
68352: LD_INT 1
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PUSH
68359: LD_INT 1
68361: NEG
68362: PUSH
68363: LD_INT 0
68365: PUSH
68366: EMPTY
68367: LIST
68368: LIST
68369: PUSH
68370: LD_INT 1
68372: NEG
68373: PUSH
68374: LD_INT 1
68376: NEG
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: LD_INT 1
68384: NEG
68385: PUSH
68386: LD_INT 2
68388: NEG
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: PUSH
68394: LD_INT 0
68396: PUSH
68397: LD_INT 2
68399: NEG
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 1
68407: PUSH
68408: LD_INT 1
68410: NEG
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PUSH
68416: LD_INT 2
68418: PUSH
68419: LD_INT 0
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 2
68428: PUSH
68429: LD_INT 1
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PUSH
68436: LD_INT 2
68438: PUSH
68439: LD_INT 2
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: LD_INT 1
68448: PUSH
68449: LD_INT 2
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PUSH
68456: LD_INT 0
68458: PUSH
68459: LD_INT 2
68461: PUSH
68462: EMPTY
68463: LIST
68464: LIST
68465: PUSH
68466: LD_INT 1
68468: NEG
68469: PUSH
68470: LD_INT 1
68472: PUSH
68473: EMPTY
68474: LIST
68475: LIST
68476: PUSH
68477: LD_INT 2
68479: NEG
68480: PUSH
68481: LD_INT 0
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: PUSH
68488: LD_INT 2
68490: NEG
68491: PUSH
68492: LD_INT 1
68494: NEG
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: PUSH
68500: LD_INT 2
68502: NEG
68503: PUSH
68504: LD_INT 2
68506: NEG
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: LIST
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68533: LD_ADDR_VAR 0 23
68537: PUSH
68538: LD_INT 0
68540: PUSH
68541: LD_INT 0
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: LD_INT 0
68550: PUSH
68551: LD_INT 1
68553: NEG
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: LD_INT 1
68561: PUSH
68562: LD_INT 0
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 1
68571: PUSH
68572: LD_INT 1
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: PUSH
68579: LD_INT 0
68581: PUSH
68582: LD_INT 1
68584: PUSH
68585: EMPTY
68586: LIST
68587: LIST
68588: PUSH
68589: LD_INT 1
68591: NEG
68592: PUSH
68593: LD_INT 0
68595: PUSH
68596: EMPTY
68597: LIST
68598: LIST
68599: PUSH
68600: LD_INT 1
68602: NEG
68603: PUSH
68604: LD_INT 1
68606: NEG
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PUSH
68612: LD_INT 1
68614: NEG
68615: PUSH
68616: LD_INT 2
68618: NEG
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: LD_INT 0
68626: PUSH
68627: LD_INT 2
68629: NEG
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 1
68637: PUSH
68638: LD_INT 1
68640: NEG
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 2
68648: PUSH
68649: LD_INT 0
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: LD_INT 2
68658: PUSH
68659: LD_INT 1
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 2
68668: PUSH
68669: LD_INT 2
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 1
68678: PUSH
68679: LD_INT 2
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: PUSH
68686: LD_INT 0
68688: PUSH
68689: LD_INT 2
68691: PUSH
68692: EMPTY
68693: LIST
68694: LIST
68695: PUSH
68696: LD_INT 1
68698: NEG
68699: PUSH
68700: LD_INT 1
68702: PUSH
68703: EMPTY
68704: LIST
68705: LIST
68706: PUSH
68707: LD_INT 2
68709: NEG
68710: PUSH
68711: LD_INT 0
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: PUSH
68718: LD_INT 2
68720: NEG
68721: PUSH
68722: LD_INT 1
68724: NEG
68725: PUSH
68726: EMPTY
68727: LIST
68728: LIST
68729: PUSH
68730: LD_INT 2
68732: NEG
68733: PUSH
68734: LD_INT 2
68736: NEG
68737: PUSH
68738: EMPTY
68739: LIST
68740: LIST
68741: PUSH
68742: LD_INT 2
68744: NEG
68745: PUSH
68746: LD_INT 3
68748: NEG
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: PUSH
68754: LD_INT 1
68756: NEG
68757: PUSH
68758: LD_INT 3
68760: NEG
68761: PUSH
68762: EMPTY
68763: LIST
68764: LIST
68765: PUSH
68766: LD_INT 1
68768: PUSH
68769: LD_INT 2
68771: NEG
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 2
68779: PUSH
68780: LD_INT 1
68782: NEG
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PUSH
68788: EMPTY
68789: LIST
68790: LIST
68791: LIST
68792: LIST
68793: LIST
68794: LIST
68795: LIST
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: LIST
68804: LIST
68805: LIST
68806: LIST
68807: LIST
68808: LIST
68809: LIST
68810: LIST
68811: LIST
68812: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68813: LD_ADDR_VAR 0 24
68817: PUSH
68818: LD_INT 0
68820: PUSH
68821: LD_INT 0
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 0
68830: PUSH
68831: LD_INT 1
68833: NEG
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: LD_INT 1
68841: PUSH
68842: LD_INT 0
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: PUSH
68849: LD_INT 1
68851: PUSH
68852: LD_INT 1
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 0
68861: PUSH
68862: LD_INT 1
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: LD_INT 1
68871: NEG
68872: PUSH
68873: LD_INT 0
68875: PUSH
68876: EMPTY
68877: LIST
68878: LIST
68879: PUSH
68880: LD_INT 1
68882: NEG
68883: PUSH
68884: LD_INT 1
68886: NEG
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PUSH
68892: LD_INT 1
68894: NEG
68895: PUSH
68896: LD_INT 2
68898: NEG
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: PUSH
68904: LD_INT 0
68906: PUSH
68907: LD_INT 2
68909: NEG
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: PUSH
68915: LD_INT 1
68917: PUSH
68918: LD_INT 1
68920: NEG
68921: PUSH
68922: EMPTY
68923: LIST
68924: LIST
68925: PUSH
68926: LD_INT 2
68928: PUSH
68929: LD_INT 0
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: PUSH
68936: LD_INT 2
68938: PUSH
68939: LD_INT 1
68941: PUSH
68942: EMPTY
68943: LIST
68944: LIST
68945: PUSH
68946: LD_INT 2
68948: PUSH
68949: LD_INT 2
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: PUSH
68956: LD_INT 1
68958: PUSH
68959: LD_INT 2
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: PUSH
68966: LD_INT 0
68968: PUSH
68969: LD_INT 2
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: PUSH
68976: LD_INT 1
68978: NEG
68979: PUSH
68980: LD_INT 1
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 2
68989: NEG
68990: PUSH
68991: LD_INT 0
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 2
69000: NEG
69001: PUSH
69002: LD_INT 1
69004: NEG
69005: PUSH
69006: EMPTY
69007: LIST
69008: LIST
69009: PUSH
69010: LD_INT 2
69012: NEG
69013: PUSH
69014: LD_INT 2
69016: NEG
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: PUSH
69022: LD_INT 1
69024: PUSH
69025: LD_INT 2
69027: NEG
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: PUSH
69033: LD_INT 2
69035: PUSH
69036: LD_INT 1
69038: NEG
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PUSH
69044: LD_INT 3
69046: PUSH
69047: LD_INT 1
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: LD_INT 3
69056: PUSH
69057: LD_INT 2
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: EMPTY
69065: LIST
69066: LIST
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69089: LD_ADDR_VAR 0 25
69093: PUSH
69094: LD_INT 0
69096: PUSH
69097: LD_INT 0
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 0
69106: PUSH
69107: LD_INT 1
69109: NEG
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 1
69117: PUSH
69118: LD_INT 0
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: PUSH
69125: LD_INT 1
69127: PUSH
69128: LD_INT 1
69130: PUSH
69131: EMPTY
69132: LIST
69133: LIST
69134: PUSH
69135: LD_INT 0
69137: PUSH
69138: LD_INT 1
69140: PUSH
69141: EMPTY
69142: LIST
69143: LIST
69144: PUSH
69145: LD_INT 1
69147: NEG
69148: PUSH
69149: LD_INT 0
69151: PUSH
69152: EMPTY
69153: LIST
69154: LIST
69155: PUSH
69156: LD_INT 1
69158: NEG
69159: PUSH
69160: LD_INT 1
69162: NEG
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: PUSH
69168: LD_INT 1
69170: NEG
69171: PUSH
69172: LD_INT 2
69174: NEG
69175: PUSH
69176: EMPTY
69177: LIST
69178: LIST
69179: PUSH
69180: LD_INT 0
69182: PUSH
69183: LD_INT 2
69185: NEG
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: LD_INT 1
69193: PUSH
69194: LD_INT 1
69196: NEG
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 2
69204: PUSH
69205: LD_INT 0
69207: PUSH
69208: EMPTY
69209: LIST
69210: LIST
69211: PUSH
69212: LD_INT 2
69214: PUSH
69215: LD_INT 1
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: PUSH
69222: LD_INT 2
69224: PUSH
69225: LD_INT 2
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 1
69234: PUSH
69235: LD_INT 2
69237: PUSH
69238: EMPTY
69239: LIST
69240: LIST
69241: PUSH
69242: LD_INT 0
69244: PUSH
69245: LD_INT 2
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: PUSH
69252: LD_INT 1
69254: NEG
69255: PUSH
69256: LD_INT 1
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 2
69265: NEG
69266: PUSH
69267: LD_INT 0
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PUSH
69274: LD_INT 2
69276: NEG
69277: PUSH
69278: LD_INT 1
69280: NEG
69281: PUSH
69282: EMPTY
69283: LIST
69284: LIST
69285: PUSH
69286: LD_INT 2
69288: NEG
69289: PUSH
69290: LD_INT 2
69292: NEG
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PUSH
69298: LD_INT 3
69300: PUSH
69301: LD_INT 1
69303: PUSH
69304: EMPTY
69305: LIST
69306: LIST
69307: PUSH
69308: LD_INT 3
69310: PUSH
69311: LD_INT 2
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: LD_INT 2
69320: PUSH
69321: LD_INT 3
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 1
69330: PUSH
69331: LD_INT 3
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69363: LD_ADDR_VAR 0 26
69367: PUSH
69368: LD_INT 0
69370: PUSH
69371: LD_INT 0
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: PUSH
69378: LD_INT 0
69380: PUSH
69381: LD_INT 1
69383: NEG
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: PUSH
69389: LD_INT 1
69391: PUSH
69392: LD_INT 0
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: PUSH
69399: LD_INT 1
69401: PUSH
69402: LD_INT 1
69404: PUSH
69405: EMPTY
69406: LIST
69407: LIST
69408: PUSH
69409: LD_INT 0
69411: PUSH
69412: LD_INT 1
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: PUSH
69419: LD_INT 1
69421: NEG
69422: PUSH
69423: LD_INT 0
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: PUSH
69430: LD_INT 1
69432: NEG
69433: PUSH
69434: LD_INT 1
69436: NEG
69437: PUSH
69438: EMPTY
69439: LIST
69440: LIST
69441: PUSH
69442: LD_INT 1
69444: NEG
69445: PUSH
69446: LD_INT 2
69448: NEG
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 0
69456: PUSH
69457: LD_INT 2
69459: NEG
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: PUSH
69465: LD_INT 1
69467: PUSH
69468: LD_INT 1
69470: NEG
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 2
69478: PUSH
69479: LD_INT 0
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: LD_INT 2
69488: PUSH
69489: LD_INT 1
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 2
69498: PUSH
69499: LD_INT 2
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 1
69508: PUSH
69509: LD_INT 2
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: LD_INT 0
69518: PUSH
69519: LD_INT 2
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: PUSH
69526: LD_INT 1
69528: NEG
69529: PUSH
69530: LD_INT 1
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: PUSH
69537: LD_INT 2
69539: NEG
69540: PUSH
69541: LD_INT 0
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: LD_INT 2
69550: NEG
69551: PUSH
69552: LD_INT 1
69554: NEG
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 2
69562: NEG
69563: PUSH
69564: LD_INT 2
69566: NEG
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 2
69574: PUSH
69575: LD_INT 3
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 1
69584: PUSH
69585: LD_INT 3
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: PUSH
69592: LD_INT 1
69594: NEG
69595: PUSH
69596: LD_INT 2
69598: PUSH
69599: EMPTY
69600: LIST
69601: LIST
69602: PUSH
69603: LD_INT 2
69605: NEG
69606: PUSH
69607: LD_INT 1
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PUSH
69614: EMPTY
69615: LIST
69616: LIST
69617: LIST
69618: LIST
69619: LIST
69620: LIST
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69639: LD_ADDR_VAR 0 27
69643: PUSH
69644: LD_INT 0
69646: PUSH
69647: LD_INT 0
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 0
69656: PUSH
69657: LD_INT 1
69659: NEG
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 1
69667: PUSH
69668: LD_INT 0
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: PUSH
69675: LD_INT 1
69677: PUSH
69678: LD_INT 1
69680: PUSH
69681: EMPTY
69682: LIST
69683: LIST
69684: PUSH
69685: LD_INT 0
69687: PUSH
69688: LD_INT 1
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: PUSH
69695: LD_INT 1
69697: NEG
69698: PUSH
69699: LD_INT 0
69701: PUSH
69702: EMPTY
69703: LIST
69704: LIST
69705: PUSH
69706: LD_INT 1
69708: NEG
69709: PUSH
69710: LD_INT 1
69712: NEG
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 1
69720: NEG
69721: PUSH
69722: LD_INT 2
69724: NEG
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: LD_INT 0
69732: PUSH
69733: LD_INT 2
69735: NEG
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 1
69743: PUSH
69744: LD_INT 1
69746: NEG
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 2
69754: PUSH
69755: LD_INT 0
69757: PUSH
69758: EMPTY
69759: LIST
69760: LIST
69761: PUSH
69762: LD_INT 2
69764: PUSH
69765: LD_INT 1
69767: PUSH
69768: EMPTY
69769: LIST
69770: LIST
69771: PUSH
69772: LD_INT 2
69774: PUSH
69775: LD_INT 2
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 1
69784: PUSH
69785: LD_INT 2
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 0
69794: PUSH
69795: LD_INT 2
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 1
69804: NEG
69805: PUSH
69806: LD_INT 1
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 2
69815: NEG
69816: PUSH
69817: LD_INT 0
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 2
69826: NEG
69827: PUSH
69828: LD_INT 1
69830: NEG
69831: PUSH
69832: EMPTY
69833: LIST
69834: LIST
69835: PUSH
69836: LD_INT 2
69838: NEG
69839: PUSH
69840: LD_INT 2
69842: NEG
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 1
69850: NEG
69851: PUSH
69852: LD_INT 2
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 2
69861: NEG
69862: PUSH
69863: LD_INT 1
69865: PUSH
69866: EMPTY
69867: LIST
69868: LIST
69869: PUSH
69870: LD_INT 3
69872: NEG
69873: PUSH
69874: LD_INT 1
69876: NEG
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: PUSH
69882: LD_INT 3
69884: NEG
69885: PUSH
69886: LD_INT 2
69888: NEG
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: LIST
69898: LIST
69899: LIST
69900: LIST
69901: LIST
69902: LIST
69903: LIST
69904: LIST
69905: LIST
69906: LIST
69907: LIST
69908: LIST
69909: LIST
69910: LIST
69911: LIST
69912: LIST
69913: LIST
69914: LIST
69915: LIST
69916: LIST
69917: LIST
69918: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69919: LD_ADDR_VAR 0 28
69923: PUSH
69924: LD_INT 0
69926: PUSH
69927: LD_INT 0
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 0
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 1
69947: PUSH
69948: LD_INT 0
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 1
69957: PUSH
69958: LD_INT 1
69960: PUSH
69961: EMPTY
69962: LIST
69963: LIST
69964: PUSH
69965: LD_INT 0
69967: PUSH
69968: LD_INT 1
69970: PUSH
69971: EMPTY
69972: LIST
69973: LIST
69974: PUSH
69975: LD_INT 1
69977: NEG
69978: PUSH
69979: LD_INT 0
69981: PUSH
69982: EMPTY
69983: LIST
69984: LIST
69985: PUSH
69986: LD_INT 1
69988: NEG
69989: PUSH
69990: LD_INT 1
69992: NEG
69993: PUSH
69994: EMPTY
69995: LIST
69996: LIST
69997: PUSH
69998: LD_INT 1
70000: NEG
70001: PUSH
70002: LD_INT 2
70004: NEG
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 0
70012: PUSH
70013: LD_INT 2
70015: NEG
70016: PUSH
70017: EMPTY
70018: LIST
70019: LIST
70020: PUSH
70021: LD_INT 1
70023: PUSH
70024: LD_INT 1
70026: NEG
70027: PUSH
70028: EMPTY
70029: LIST
70030: LIST
70031: PUSH
70032: LD_INT 2
70034: PUSH
70035: LD_INT 0
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: PUSH
70042: LD_INT 2
70044: PUSH
70045: LD_INT 1
70047: PUSH
70048: EMPTY
70049: LIST
70050: LIST
70051: PUSH
70052: LD_INT 2
70054: PUSH
70055: LD_INT 2
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PUSH
70062: LD_INT 1
70064: PUSH
70065: LD_INT 2
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 0
70074: PUSH
70075: LD_INT 2
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: LD_INT 1
70084: NEG
70085: PUSH
70086: LD_INT 1
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: PUSH
70093: LD_INT 2
70095: NEG
70096: PUSH
70097: LD_INT 0
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 2
70106: NEG
70107: PUSH
70108: LD_INT 1
70110: NEG
70111: PUSH
70112: EMPTY
70113: LIST
70114: LIST
70115: PUSH
70116: LD_INT 2
70118: NEG
70119: PUSH
70120: LD_INT 2
70122: NEG
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: PUSH
70128: LD_INT 2
70130: NEG
70131: PUSH
70132: LD_INT 3
70134: NEG
70135: PUSH
70136: EMPTY
70137: LIST
70138: LIST
70139: PUSH
70140: LD_INT 1
70142: NEG
70143: PUSH
70144: LD_INT 3
70146: NEG
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 3
70154: NEG
70155: PUSH
70156: LD_INT 1
70158: NEG
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: PUSH
70164: LD_INT 3
70166: NEG
70167: PUSH
70168: LD_INT 2
70170: NEG
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: LIST
70180: LIST
70181: LIST
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70201: LD_ADDR_VAR 0 29
70205: PUSH
70206: LD_INT 0
70208: PUSH
70209: LD_INT 0
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 0
70218: PUSH
70219: LD_INT 1
70221: NEG
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 1
70229: PUSH
70230: LD_INT 0
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PUSH
70237: LD_INT 1
70239: PUSH
70240: LD_INT 1
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: LD_INT 0
70249: PUSH
70250: LD_INT 1
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 1
70259: NEG
70260: PUSH
70261: LD_INT 0
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: LD_INT 1
70270: NEG
70271: PUSH
70272: LD_INT 1
70274: NEG
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 1
70282: NEG
70283: PUSH
70284: LD_INT 2
70286: NEG
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: PUSH
70292: LD_INT 0
70294: PUSH
70295: LD_INT 2
70297: NEG
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PUSH
70303: LD_INT 1
70305: PUSH
70306: LD_INT 1
70308: NEG
70309: PUSH
70310: EMPTY
70311: LIST
70312: LIST
70313: PUSH
70314: LD_INT 2
70316: PUSH
70317: LD_INT 0
70319: PUSH
70320: EMPTY
70321: LIST
70322: LIST
70323: PUSH
70324: LD_INT 2
70326: PUSH
70327: LD_INT 1
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: PUSH
70334: LD_INT 1
70336: PUSH
70337: LD_INT 2
70339: PUSH
70340: EMPTY
70341: LIST
70342: LIST
70343: PUSH
70344: LD_INT 0
70346: PUSH
70347: LD_INT 2
70349: PUSH
70350: EMPTY
70351: LIST
70352: LIST
70353: PUSH
70354: LD_INT 1
70356: NEG
70357: PUSH
70358: LD_INT 1
70360: PUSH
70361: EMPTY
70362: LIST
70363: LIST
70364: PUSH
70365: LD_INT 2
70367: NEG
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 2
70379: NEG
70380: PUSH
70381: LD_INT 2
70383: NEG
70384: PUSH
70385: EMPTY
70386: LIST
70387: LIST
70388: PUSH
70389: LD_INT 2
70391: NEG
70392: PUSH
70393: LD_INT 3
70395: NEG
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: PUSH
70401: LD_INT 2
70403: PUSH
70404: LD_INT 1
70406: NEG
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: PUSH
70412: LD_INT 3
70414: PUSH
70415: LD_INT 1
70417: PUSH
70418: EMPTY
70419: LIST
70420: LIST
70421: PUSH
70422: LD_INT 1
70424: PUSH
70425: LD_INT 3
70427: PUSH
70428: EMPTY
70429: LIST
70430: LIST
70431: PUSH
70432: LD_INT 1
70434: NEG
70435: PUSH
70436: LD_INT 2
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 3
70445: NEG
70446: PUSH
70447: LD_INT 2
70449: NEG
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: LIST
70459: LIST
70460: LIST
70461: LIST
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70480: LD_ADDR_VAR 0 30
70484: PUSH
70485: LD_INT 0
70487: PUSH
70488: LD_INT 0
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: LD_INT 0
70497: PUSH
70498: LD_INT 1
70500: NEG
70501: PUSH
70502: EMPTY
70503: LIST
70504: LIST
70505: PUSH
70506: LD_INT 1
70508: PUSH
70509: LD_INT 0
70511: PUSH
70512: EMPTY
70513: LIST
70514: LIST
70515: PUSH
70516: LD_INT 1
70518: PUSH
70519: LD_INT 1
70521: PUSH
70522: EMPTY
70523: LIST
70524: LIST
70525: PUSH
70526: LD_INT 0
70528: PUSH
70529: LD_INT 1
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: PUSH
70536: LD_INT 1
70538: NEG
70539: PUSH
70540: LD_INT 0
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: PUSH
70547: LD_INT 1
70549: NEG
70550: PUSH
70551: LD_INT 1
70553: NEG
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 1
70561: NEG
70562: PUSH
70563: LD_INT 2
70565: NEG
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PUSH
70571: LD_INT 0
70573: PUSH
70574: LD_INT 2
70576: NEG
70577: PUSH
70578: EMPTY
70579: LIST
70580: LIST
70581: PUSH
70582: LD_INT 1
70584: PUSH
70585: LD_INT 1
70587: NEG
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: PUSH
70593: LD_INT 2
70595: PUSH
70596: LD_INT 0
70598: PUSH
70599: EMPTY
70600: LIST
70601: LIST
70602: PUSH
70603: LD_INT 2
70605: PUSH
70606: LD_INT 1
70608: PUSH
70609: EMPTY
70610: LIST
70611: LIST
70612: PUSH
70613: LD_INT 2
70615: PUSH
70616: LD_INT 2
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: PUSH
70623: LD_INT 1
70625: PUSH
70626: LD_INT 2
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: LD_INT 1
70635: NEG
70636: PUSH
70637: LD_INT 1
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 2
70646: NEG
70647: PUSH
70648: LD_INT 0
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 2
70657: NEG
70658: PUSH
70659: LD_INT 1
70661: NEG
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: LD_INT 1
70669: NEG
70670: PUSH
70671: LD_INT 3
70673: NEG
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: LD_INT 1
70681: PUSH
70682: LD_INT 2
70684: NEG
70685: PUSH
70686: EMPTY
70687: LIST
70688: LIST
70689: PUSH
70690: LD_INT 3
70692: PUSH
70693: LD_INT 2
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 2
70702: PUSH
70703: LD_INT 3
70705: PUSH
70706: EMPTY
70707: LIST
70708: LIST
70709: PUSH
70710: LD_INT 2
70712: NEG
70713: PUSH
70714: LD_INT 1
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PUSH
70721: LD_INT 3
70723: NEG
70724: PUSH
70725: LD_INT 1
70727: NEG
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: EMPTY
70734: LIST
70735: LIST
70736: LIST
70737: LIST
70738: LIST
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70758: LD_ADDR_VAR 0 31
70762: PUSH
70763: LD_INT 0
70765: PUSH
70766: LD_INT 0
70768: PUSH
70769: EMPTY
70770: LIST
70771: LIST
70772: PUSH
70773: LD_INT 0
70775: PUSH
70776: LD_INT 1
70778: NEG
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 1
70786: PUSH
70787: LD_INT 0
70789: PUSH
70790: EMPTY
70791: LIST
70792: LIST
70793: PUSH
70794: LD_INT 1
70796: PUSH
70797: LD_INT 1
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PUSH
70804: LD_INT 0
70806: PUSH
70807: LD_INT 1
70809: PUSH
70810: EMPTY
70811: LIST
70812: LIST
70813: PUSH
70814: LD_INT 1
70816: NEG
70817: PUSH
70818: LD_INT 0
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: PUSH
70825: LD_INT 1
70827: NEG
70828: PUSH
70829: LD_INT 1
70831: NEG
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: LD_INT 1
70839: NEG
70840: PUSH
70841: LD_INT 2
70843: NEG
70844: PUSH
70845: EMPTY
70846: LIST
70847: LIST
70848: PUSH
70849: LD_INT 1
70851: PUSH
70852: LD_INT 1
70854: NEG
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: PUSH
70860: LD_INT 2
70862: PUSH
70863: LD_INT 0
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 2
70872: PUSH
70873: LD_INT 1
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 2
70882: PUSH
70883: LD_INT 2
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: PUSH
70890: LD_INT 1
70892: PUSH
70893: LD_INT 2
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 0
70902: PUSH
70903: LD_INT 2
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: LD_INT 1
70912: NEG
70913: PUSH
70914: LD_INT 1
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: PUSH
70921: LD_INT 2
70923: NEG
70924: PUSH
70925: LD_INT 1
70927: NEG
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: LD_INT 2
70935: NEG
70936: PUSH
70937: LD_INT 2
70939: NEG
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: PUSH
70945: LD_INT 2
70947: NEG
70948: PUSH
70949: LD_INT 3
70951: NEG
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: PUSH
70957: LD_INT 2
70959: PUSH
70960: LD_INT 1
70962: NEG
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PUSH
70968: LD_INT 3
70970: PUSH
70971: LD_INT 1
70973: PUSH
70974: EMPTY
70975: LIST
70976: LIST
70977: PUSH
70978: LD_INT 1
70980: PUSH
70981: LD_INT 3
70983: PUSH
70984: EMPTY
70985: LIST
70986: LIST
70987: PUSH
70988: LD_INT 1
70990: NEG
70991: PUSH
70992: LD_INT 2
70994: PUSH
70995: EMPTY
70996: LIST
70997: LIST
70998: PUSH
70999: LD_INT 3
71001: NEG
71002: PUSH
71003: LD_INT 2
71005: NEG
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71036: LD_ADDR_VAR 0 32
71040: PUSH
71041: LD_INT 0
71043: PUSH
71044: LD_INT 0
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 0
71053: PUSH
71054: LD_INT 1
71056: NEG
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 1
71064: PUSH
71065: LD_INT 0
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 1
71074: PUSH
71075: LD_INT 1
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: LD_INT 0
71084: PUSH
71085: LD_INT 1
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 1
71094: NEG
71095: PUSH
71096: LD_INT 0
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 1
71105: NEG
71106: PUSH
71107: LD_INT 1
71109: NEG
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 1
71117: NEG
71118: PUSH
71119: LD_INT 2
71121: NEG
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 0
71129: PUSH
71130: LD_INT 2
71132: NEG
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 1
71140: PUSH
71141: LD_INT 1
71143: NEG
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 2
71151: PUSH
71152: LD_INT 1
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 2
71161: PUSH
71162: LD_INT 2
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 1
71171: PUSH
71172: LD_INT 2
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 0
71181: PUSH
71182: LD_INT 2
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 1
71191: NEG
71192: PUSH
71193: LD_INT 1
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 2
71202: NEG
71203: PUSH
71204: LD_INT 0
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: PUSH
71211: LD_INT 2
71213: NEG
71214: PUSH
71215: LD_INT 1
71217: NEG
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 1
71225: NEG
71226: PUSH
71227: LD_INT 3
71229: NEG
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 1
71237: PUSH
71238: LD_INT 2
71240: NEG
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: PUSH
71246: LD_INT 3
71248: PUSH
71249: LD_INT 2
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PUSH
71256: LD_INT 2
71258: PUSH
71259: LD_INT 3
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PUSH
71266: LD_INT 2
71268: NEG
71269: PUSH
71270: LD_INT 1
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: PUSH
71277: LD_INT 3
71279: NEG
71280: PUSH
71281: LD_INT 1
71283: NEG
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: PUSH
71289: EMPTY
71290: LIST
71291: LIST
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71314: LD_ADDR_VAR 0 33
71318: PUSH
71319: LD_INT 0
71321: PUSH
71322: LD_INT 0
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: LD_INT 0
71331: PUSH
71332: LD_INT 1
71334: NEG
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 1
71342: PUSH
71343: LD_INT 0
71345: PUSH
71346: EMPTY
71347: LIST
71348: LIST
71349: PUSH
71350: LD_INT 1
71352: PUSH
71353: LD_INT 1
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: PUSH
71360: LD_INT 0
71362: PUSH
71363: LD_INT 1
71365: PUSH
71366: EMPTY
71367: LIST
71368: LIST
71369: PUSH
71370: LD_INT 1
71372: NEG
71373: PUSH
71374: LD_INT 0
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: PUSH
71381: LD_INT 1
71383: NEG
71384: PUSH
71385: LD_INT 1
71387: NEG
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: PUSH
71393: LD_INT 1
71395: NEG
71396: PUSH
71397: LD_INT 2
71399: NEG
71400: PUSH
71401: EMPTY
71402: LIST
71403: LIST
71404: PUSH
71405: LD_INT 1
71407: PUSH
71408: LD_INT 1
71410: NEG
71411: PUSH
71412: EMPTY
71413: LIST
71414: LIST
71415: PUSH
71416: LD_INT 2
71418: PUSH
71419: LD_INT 0
71421: PUSH
71422: EMPTY
71423: LIST
71424: LIST
71425: PUSH
71426: LD_INT 2
71428: PUSH
71429: LD_INT 1
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: PUSH
71436: LD_INT 1
71438: PUSH
71439: LD_INT 2
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PUSH
71446: LD_INT 0
71448: PUSH
71449: LD_INT 2
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: PUSH
71456: LD_INT 1
71458: NEG
71459: PUSH
71460: LD_INT 1
71462: PUSH
71463: EMPTY
71464: LIST
71465: LIST
71466: PUSH
71467: LD_INT 2
71469: NEG
71470: PUSH
71471: LD_INT 0
71473: PUSH
71474: EMPTY
71475: LIST
71476: LIST
71477: PUSH
71478: LD_INT 2
71480: NEG
71481: PUSH
71482: LD_INT 1
71484: NEG
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: PUSH
71490: LD_INT 2
71492: NEG
71493: PUSH
71494: LD_INT 2
71496: NEG
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: PUSH
71502: LD_INT 2
71504: NEG
71505: PUSH
71506: LD_INT 3
71508: NEG
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: LD_INT 2
71516: PUSH
71517: LD_INT 1
71519: NEG
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 3
71527: PUSH
71528: LD_INT 1
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 1
71537: PUSH
71538: LD_INT 3
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: LD_INT 1
71547: NEG
71548: PUSH
71549: LD_INT 2
71551: PUSH
71552: EMPTY
71553: LIST
71554: LIST
71555: PUSH
71556: LD_INT 3
71558: NEG
71559: PUSH
71560: LD_INT 2
71562: NEG
71563: PUSH
71564: EMPTY
71565: LIST
71566: LIST
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: LIST
71572: LIST
71573: LIST
71574: LIST
71575: LIST
71576: LIST
71577: LIST
71578: LIST
71579: LIST
71580: LIST
71581: LIST
71582: LIST
71583: LIST
71584: LIST
71585: LIST
71586: LIST
71587: LIST
71588: LIST
71589: LIST
71590: LIST
71591: LIST
71592: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71593: LD_ADDR_VAR 0 34
71597: PUSH
71598: LD_INT 0
71600: PUSH
71601: LD_INT 0
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: PUSH
71608: LD_INT 0
71610: PUSH
71611: LD_INT 1
71613: NEG
71614: PUSH
71615: EMPTY
71616: LIST
71617: LIST
71618: PUSH
71619: LD_INT 1
71621: PUSH
71622: LD_INT 0
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: LD_INT 1
71631: PUSH
71632: LD_INT 1
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 0
71641: PUSH
71642: LD_INT 1
71644: PUSH
71645: EMPTY
71646: LIST
71647: LIST
71648: PUSH
71649: LD_INT 1
71651: NEG
71652: PUSH
71653: LD_INT 0
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 1
71662: NEG
71663: PUSH
71664: LD_INT 1
71666: NEG
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 1
71674: NEG
71675: PUSH
71676: LD_INT 2
71678: NEG
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: PUSH
71684: LD_INT 0
71686: PUSH
71687: LD_INT 2
71689: NEG
71690: PUSH
71691: EMPTY
71692: LIST
71693: LIST
71694: PUSH
71695: LD_INT 1
71697: PUSH
71698: LD_INT 1
71700: NEG
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: PUSH
71706: LD_INT 2
71708: PUSH
71709: LD_INT 1
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: PUSH
71716: LD_INT 2
71718: PUSH
71719: LD_INT 2
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: PUSH
71726: LD_INT 1
71728: PUSH
71729: LD_INT 2
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 1
71738: NEG
71739: PUSH
71740: LD_INT 1
71742: PUSH
71743: EMPTY
71744: LIST
71745: LIST
71746: PUSH
71747: LD_INT 2
71749: NEG
71750: PUSH
71751: LD_INT 0
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 2
71760: NEG
71761: PUSH
71762: LD_INT 1
71764: NEG
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PUSH
71770: LD_INT 2
71772: NEG
71773: PUSH
71774: LD_INT 2
71776: NEG
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 1
71784: NEG
71785: PUSH
71786: LD_INT 3
71788: NEG
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PUSH
71794: LD_INT 1
71796: PUSH
71797: LD_INT 2
71799: NEG
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 3
71807: PUSH
71808: LD_INT 2
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: LD_INT 2
71817: PUSH
71818: LD_INT 3
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 2
71827: NEG
71828: PUSH
71829: LD_INT 1
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 3
71838: NEG
71839: PUSH
71840: LD_INT 1
71842: NEG
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: LIST
71852: LIST
71853: LIST
71854: LIST
71855: LIST
71856: LIST
71857: LIST
71858: LIST
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71873: LD_ADDR_VAR 0 35
71877: PUSH
71878: LD_INT 0
71880: PUSH
71881: LD_INT 0
71883: PUSH
71884: EMPTY
71885: LIST
71886: LIST
71887: PUSH
71888: LD_INT 0
71890: PUSH
71891: LD_INT 1
71893: NEG
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: PUSH
71899: LD_INT 1
71901: PUSH
71902: LD_INT 0
71904: PUSH
71905: EMPTY
71906: LIST
71907: LIST
71908: PUSH
71909: LD_INT 1
71911: PUSH
71912: LD_INT 1
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 0
71921: PUSH
71922: LD_INT 1
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 1
71931: NEG
71932: PUSH
71933: LD_INT 0
71935: PUSH
71936: EMPTY
71937: LIST
71938: LIST
71939: PUSH
71940: LD_INT 1
71942: NEG
71943: PUSH
71944: LD_INT 1
71946: NEG
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 2
71954: PUSH
71955: LD_INT 1
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PUSH
71962: LD_INT 2
71964: NEG
71965: PUSH
71966: LD_INT 1
71968: NEG
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: LIST
71978: LIST
71979: LIST
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71985: LD_ADDR_VAR 0 36
71989: PUSH
71990: LD_INT 0
71992: PUSH
71993: LD_INT 0
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 0
72002: PUSH
72003: LD_INT 1
72005: NEG
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 1
72013: PUSH
72014: LD_INT 0
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 1
72023: PUSH
72024: LD_INT 1
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: PUSH
72031: LD_INT 0
72033: PUSH
72034: LD_INT 1
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 1
72043: NEG
72044: PUSH
72045: LD_INT 0
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: PUSH
72052: LD_INT 1
72054: NEG
72055: PUSH
72056: LD_INT 1
72058: NEG
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: LD_INT 1
72066: NEG
72067: PUSH
72068: LD_INT 2
72070: NEG
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 1
72078: PUSH
72079: LD_INT 2
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72097: LD_ADDR_VAR 0 37
72101: PUSH
72102: LD_INT 0
72104: PUSH
72105: LD_INT 0
72107: PUSH
72108: EMPTY
72109: LIST
72110: LIST
72111: PUSH
72112: LD_INT 0
72114: PUSH
72115: LD_INT 1
72117: NEG
72118: PUSH
72119: EMPTY
72120: LIST
72121: LIST
72122: PUSH
72123: LD_INT 1
72125: PUSH
72126: LD_INT 0
72128: PUSH
72129: EMPTY
72130: LIST
72131: LIST
72132: PUSH
72133: LD_INT 1
72135: PUSH
72136: LD_INT 1
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: PUSH
72143: LD_INT 0
72145: PUSH
72146: LD_INT 1
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: PUSH
72153: LD_INT 1
72155: NEG
72156: PUSH
72157: LD_INT 0
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: LD_INT 1
72166: NEG
72167: PUSH
72168: LD_INT 1
72170: NEG
72171: PUSH
72172: EMPTY
72173: LIST
72174: LIST
72175: PUSH
72176: LD_INT 1
72178: PUSH
72179: LD_INT 1
72181: NEG
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: LD_INT 1
72189: NEG
72190: PUSH
72191: LD_INT 1
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: EMPTY
72199: LIST
72200: LIST
72201: LIST
72202: LIST
72203: LIST
72204: LIST
72205: LIST
72206: LIST
72207: LIST
72208: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72209: LD_ADDR_VAR 0 38
72213: PUSH
72214: LD_INT 0
72216: PUSH
72217: LD_INT 0
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 0
72226: PUSH
72227: LD_INT 1
72229: NEG
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 1
72237: PUSH
72238: LD_INT 0
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 1
72247: PUSH
72248: LD_INT 1
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 0
72257: PUSH
72258: LD_INT 1
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: LD_INT 1
72267: NEG
72268: PUSH
72269: LD_INT 0
72271: PUSH
72272: EMPTY
72273: LIST
72274: LIST
72275: PUSH
72276: LD_INT 1
72278: NEG
72279: PUSH
72280: LD_INT 1
72282: NEG
72283: PUSH
72284: EMPTY
72285: LIST
72286: LIST
72287: PUSH
72288: LD_INT 2
72290: PUSH
72291: LD_INT 1
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 2
72300: NEG
72301: PUSH
72302: LD_INT 1
72304: NEG
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: LIST
72314: LIST
72315: LIST
72316: LIST
72317: LIST
72318: LIST
72319: LIST
72320: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72321: LD_ADDR_VAR 0 39
72325: PUSH
72326: LD_INT 0
72328: PUSH
72329: LD_INT 0
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: PUSH
72336: LD_INT 0
72338: PUSH
72339: LD_INT 1
72341: NEG
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PUSH
72347: LD_INT 1
72349: PUSH
72350: LD_INT 0
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PUSH
72357: LD_INT 1
72359: PUSH
72360: LD_INT 1
72362: PUSH
72363: EMPTY
72364: LIST
72365: LIST
72366: PUSH
72367: LD_INT 0
72369: PUSH
72370: LD_INT 1
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 1
72379: NEG
72380: PUSH
72381: LD_INT 0
72383: PUSH
72384: EMPTY
72385: LIST
72386: LIST
72387: PUSH
72388: LD_INT 1
72390: NEG
72391: PUSH
72392: LD_INT 1
72394: NEG
72395: PUSH
72396: EMPTY
72397: LIST
72398: LIST
72399: PUSH
72400: LD_INT 1
72402: NEG
72403: PUSH
72404: LD_INT 2
72406: NEG
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: LD_INT 1
72414: PUSH
72415: LD_INT 2
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: LIST
72426: LIST
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72433: LD_ADDR_VAR 0 40
72437: PUSH
72438: LD_INT 0
72440: PUSH
72441: LD_INT 0
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: PUSH
72448: LD_INT 0
72450: PUSH
72451: LD_INT 1
72453: NEG
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: LD_INT 1
72461: PUSH
72462: LD_INT 0
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: PUSH
72469: LD_INT 1
72471: PUSH
72472: LD_INT 1
72474: PUSH
72475: EMPTY
72476: LIST
72477: LIST
72478: PUSH
72479: LD_INT 0
72481: PUSH
72482: LD_INT 1
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PUSH
72489: LD_INT 1
72491: NEG
72492: PUSH
72493: LD_INT 0
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: LD_INT 1
72502: NEG
72503: PUSH
72504: LD_INT 1
72506: NEG
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: PUSH
72512: LD_INT 1
72514: PUSH
72515: LD_INT 1
72517: NEG
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 1
72525: NEG
72526: PUSH
72527: LD_INT 1
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: EMPTY
72535: LIST
72536: LIST
72537: LIST
72538: LIST
72539: LIST
72540: LIST
72541: LIST
72542: LIST
72543: LIST
72544: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72545: LD_ADDR_VAR 0 41
72549: PUSH
72550: LD_INT 0
72552: PUSH
72553: LD_INT 0
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 0
72562: PUSH
72563: LD_INT 1
72565: NEG
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: PUSH
72571: LD_INT 1
72573: PUSH
72574: LD_INT 0
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: PUSH
72581: LD_INT 1
72583: PUSH
72584: LD_INT 1
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: PUSH
72591: LD_INT 0
72593: PUSH
72594: LD_INT 1
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: PUSH
72601: LD_INT 1
72603: NEG
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 1
72614: NEG
72615: PUSH
72616: LD_INT 1
72618: NEG
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 1
72626: NEG
72627: PUSH
72628: LD_INT 2
72630: NEG
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 1
72638: PUSH
72639: LD_INT 1
72641: NEG
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: PUSH
72647: LD_INT 2
72649: PUSH
72650: LD_INT 0
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: PUSH
72657: LD_INT 2
72659: PUSH
72660: LD_INT 1
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: PUSH
72667: LD_INT 2
72669: PUSH
72670: LD_INT 2
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: PUSH
72677: LD_INT 1
72679: PUSH
72680: LD_INT 2
72682: PUSH
72683: EMPTY
72684: LIST
72685: LIST
72686: PUSH
72687: LD_INT 1
72689: NEG
72690: PUSH
72691: LD_INT 1
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: PUSH
72698: LD_INT 2
72700: NEG
72701: PUSH
72702: LD_INT 0
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PUSH
72709: LD_INT 2
72711: NEG
72712: PUSH
72713: LD_INT 1
72715: NEG
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PUSH
72721: LD_INT 2
72723: NEG
72724: PUSH
72725: LD_INT 2
72727: NEG
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 2
72735: NEG
72736: PUSH
72737: LD_INT 3
72739: NEG
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: LD_INT 2
72747: PUSH
72748: LD_INT 1
72750: NEG
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 3
72758: PUSH
72759: LD_INT 0
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: PUSH
72766: LD_INT 3
72768: PUSH
72769: LD_INT 1
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: LD_INT 3
72778: PUSH
72779: LD_INT 2
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 3
72788: PUSH
72789: LD_INT 3
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: LD_INT 2
72798: PUSH
72799: LD_INT 3
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 2
72808: NEG
72809: PUSH
72810: LD_INT 1
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: LD_INT 3
72819: NEG
72820: PUSH
72821: LD_INT 0
72823: PUSH
72824: EMPTY
72825: LIST
72826: LIST
72827: PUSH
72828: LD_INT 3
72830: NEG
72831: PUSH
72832: LD_INT 1
72834: NEG
72835: PUSH
72836: EMPTY
72837: LIST
72838: LIST
72839: PUSH
72840: LD_INT 3
72842: NEG
72843: PUSH
72844: LD_INT 2
72846: NEG
72847: PUSH
72848: EMPTY
72849: LIST
72850: LIST
72851: PUSH
72852: LD_INT 3
72854: NEG
72855: PUSH
72856: LD_INT 3
72858: NEG
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: PUSH
72864: EMPTY
72865: LIST
72866: LIST
72867: LIST
72868: LIST
72869: LIST
72870: LIST
72871: LIST
72872: LIST
72873: LIST
72874: LIST
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: LIST
72880: LIST
72881: LIST
72882: LIST
72883: LIST
72884: LIST
72885: LIST
72886: LIST
72887: LIST
72888: LIST
72889: LIST
72890: LIST
72891: LIST
72892: LIST
72893: LIST
72894: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72895: LD_ADDR_VAR 0 42
72899: PUSH
72900: LD_INT 0
72902: PUSH
72903: LD_INT 0
72905: PUSH
72906: EMPTY
72907: LIST
72908: LIST
72909: PUSH
72910: LD_INT 0
72912: PUSH
72913: LD_INT 1
72915: NEG
72916: PUSH
72917: EMPTY
72918: LIST
72919: LIST
72920: PUSH
72921: LD_INT 1
72923: PUSH
72924: LD_INT 0
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PUSH
72931: LD_INT 1
72933: PUSH
72934: LD_INT 1
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 0
72943: PUSH
72944: LD_INT 1
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 1
72953: NEG
72954: PUSH
72955: LD_INT 0
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 1
72964: NEG
72965: PUSH
72966: LD_INT 1
72968: NEG
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 1
72976: NEG
72977: PUSH
72978: LD_INT 2
72980: NEG
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 0
72988: PUSH
72989: LD_INT 2
72991: NEG
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 1
72999: PUSH
73000: LD_INT 1
73002: NEG
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: PUSH
73008: LD_INT 2
73010: PUSH
73011: LD_INT 1
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 2
73020: PUSH
73021: LD_INT 2
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PUSH
73028: LD_INT 1
73030: PUSH
73031: LD_INT 2
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 0
73040: PUSH
73041: LD_INT 2
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 1
73050: NEG
73051: PUSH
73052: LD_INT 1
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 2
73061: NEG
73062: PUSH
73063: LD_INT 1
73065: NEG
73066: PUSH
73067: EMPTY
73068: LIST
73069: LIST
73070: PUSH
73071: LD_INT 2
73073: NEG
73074: PUSH
73075: LD_INT 2
73077: NEG
73078: PUSH
73079: EMPTY
73080: LIST
73081: LIST
73082: PUSH
73083: LD_INT 2
73085: NEG
73086: PUSH
73087: LD_INT 3
73089: NEG
73090: PUSH
73091: EMPTY
73092: LIST
73093: LIST
73094: PUSH
73095: LD_INT 1
73097: NEG
73098: PUSH
73099: LD_INT 3
73101: NEG
73102: PUSH
73103: EMPTY
73104: LIST
73105: LIST
73106: PUSH
73107: LD_INT 0
73109: PUSH
73110: LD_INT 3
73112: NEG
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: PUSH
73118: LD_INT 1
73120: PUSH
73121: LD_INT 2
73123: NEG
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PUSH
73129: LD_INT 3
73131: PUSH
73132: LD_INT 2
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: LD_INT 3
73141: PUSH
73142: LD_INT 3
73144: PUSH
73145: EMPTY
73146: LIST
73147: LIST
73148: PUSH
73149: LD_INT 2
73151: PUSH
73152: LD_INT 3
73154: PUSH
73155: EMPTY
73156: LIST
73157: LIST
73158: PUSH
73159: LD_INT 1
73161: PUSH
73162: LD_INT 3
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: PUSH
73169: LD_INT 0
73171: PUSH
73172: LD_INT 3
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: PUSH
73179: LD_INT 1
73181: NEG
73182: PUSH
73183: LD_INT 2
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: PUSH
73190: LD_INT 3
73192: NEG
73193: PUSH
73194: LD_INT 2
73196: NEG
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: PUSH
73202: LD_INT 3
73204: NEG
73205: PUSH
73206: LD_INT 3
73208: NEG
73209: PUSH
73210: EMPTY
73211: LIST
73212: LIST
73213: PUSH
73214: EMPTY
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: LIST
73220: LIST
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: LIST
73240: LIST
73241: LIST
73242: LIST
73243: LIST
73244: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73245: LD_ADDR_VAR 0 43
73249: PUSH
73250: LD_INT 0
73252: PUSH
73253: LD_INT 0
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: PUSH
73260: LD_INT 0
73262: PUSH
73263: LD_INT 1
73265: NEG
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: PUSH
73271: LD_INT 1
73273: PUSH
73274: LD_INT 0
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: LD_INT 1
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: PUSH
73291: LD_INT 0
73293: PUSH
73294: LD_INT 1
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PUSH
73301: LD_INT 1
73303: NEG
73304: PUSH
73305: LD_INT 0
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 1
73314: NEG
73315: PUSH
73316: LD_INT 1
73318: NEG
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: PUSH
73324: LD_INT 1
73326: NEG
73327: PUSH
73328: LD_INT 2
73330: NEG
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: PUSH
73336: LD_INT 0
73338: PUSH
73339: LD_INT 2
73341: NEG
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: LD_INT 1
73349: PUSH
73350: LD_INT 1
73352: NEG
73353: PUSH
73354: EMPTY
73355: LIST
73356: LIST
73357: PUSH
73358: LD_INT 2
73360: PUSH
73361: LD_INT 0
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: PUSH
73368: LD_INT 2
73370: PUSH
73371: LD_INT 1
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 1
73380: PUSH
73381: LD_INT 2
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 0
73390: PUSH
73391: LD_INT 2
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 1
73400: NEG
73401: PUSH
73402: LD_INT 1
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 2
73411: NEG
73412: PUSH
73413: LD_INT 0
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PUSH
73420: LD_INT 2
73422: NEG
73423: PUSH
73424: LD_INT 1
73426: NEG
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: PUSH
73432: LD_INT 1
73434: NEG
73435: PUSH
73436: LD_INT 3
73438: NEG
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: LD_INT 0
73446: PUSH
73447: LD_INT 3
73449: NEG
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 1
73457: PUSH
73458: LD_INT 2
73460: NEG
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: LD_INT 2
73468: PUSH
73469: LD_INT 1
73471: NEG
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: LD_INT 3
73479: PUSH
73480: LD_INT 0
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: LD_INT 3
73489: PUSH
73490: LD_INT 1
73492: PUSH
73493: EMPTY
73494: LIST
73495: LIST
73496: PUSH
73497: LD_INT 1
73499: PUSH
73500: LD_INT 3
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: PUSH
73507: LD_INT 0
73509: PUSH
73510: LD_INT 3
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 1
73519: NEG
73520: PUSH
73521: LD_INT 2
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 2
73530: NEG
73531: PUSH
73532: LD_INT 1
73534: PUSH
73535: EMPTY
73536: LIST
73537: LIST
73538: PUSH
73539: LD_INT 3
73541: NEG
73542: PUSH
73543: LD_INT 0
73545: PUSH
73546: EMPTY
73547: LIST
73548: LIST
73549: PUSH
73550: LD_INT 3
73552: NEG
73553: PUSH
73554: LD_INT 1
73556: NEG
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: LIST
73577: LIST
73578: LIST
73579: LIST
73580: LIST
73581: LIST
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: LIST
73590: LIST
73591: LIST
73592: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73593: LD_ADDR_VAR 0 44
73597: PUSH
73598: LD_INT 0
73600: PUSH
73601: LD_INT 0
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 0
73610: PUSH
73611: LD_INT 1
73613: NEG
73614: PUSH
73615: EMPTY
73616: LIST
73617: LIST
73618: PUSH
73619: LD_INT 1
73621: PUSH
73622: LD_INT 0
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 1
73631: PUSH
73632: LD_INT 1
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 0
73641: PUSH
73642: LD_INT 1
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 1
73651: NEG
73652: PUSH
73653: LD_INT 0
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: PUSH
73660: LD_INT 1
73662: NEG
73663: PUSH
73664: LD_INT 1
73666: NEG
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 1
73674: NEG
73675: PUSH
73676: LD_INT 2
73678: NEG
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 1
73686: PUSH
73687: LD_INT 1
73689: NEG
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: LD_INT 2
73697: PUSH
73698: LD_INT 0
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: LD_INT 2
73707: PUSH
73708: LD_INT 1
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 2
73717: PUSH
73718: LD_INT 2
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PUSH
73725: LD_INT 1
73727: PUSH
73728: LD_INT 2
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 1
73737: NEG
73738: PUSH
73739: LD_INT 1
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PUSH
73746: LD_INT 2
73748: NEG
73749: PUSH
73750: LD_INT 0
73752: PUSH
73753: EMPTY
73754: LIST
73755: LIST
73756: PUSH
73757: LD_INT 2
73759: NEG
73760: PUSH
73761: LD_INT 1
73763: NEG
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: PUSH
73769: LD_INT 2
73771: NEG
73772: PUSH
73773: LD_INT 2
73775: NEG
73776: PUSH
73777: EMPTY
73778: LIST
73779: LIST
73780: PUSH
73781: LD_INT 2
73783: NEG
73784: PUSH
73785: LD_INT 3
73787: NEG
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: PUSH
73793: LD_INT 2
73795: PUSH
73796: LD_INT 1
73798: NEG
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 3
73806: PUSH
73807: LD_INT 0
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 3
73816: PUSH
73817: LD_INT 1
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 3
73826: PUSH
73827: LD_INT 2
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 3
73836: PUSH
73837: LD_INT 3
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: PUSH
73844: LD_INT 2
73846: PUSH
73847: LD_INT 3
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: PUSH
73854: LD_INT 2
73856: NEG
73857: PUSH
73858: LD_INT 1
73860: PUSH
73861: EMPTY
73862: LIST
73863: LIST
73864: PUSH
73865: LD_INT 3
73867: NEG
73868: PUSH
73869: LD_INT 0
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: PUSH
73876: LD_INT 3
73878: NEG
73879: PUSH
73880: LD_INT 1
73882: NEG
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 3
73890: NEG
73891: PUSH
73892: LD_INT 2
73894: NEG
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 3
73902: NEG
73903: PUSH
73904: LD_INT 3
73906: NEG
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: LIST
73918: LIST
73919: LIST
73920: LIST
73921: LIST
73922: LIST
73923: LIST
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: LIST
73932: LIST
73933: LIST
73934: LIST
73935: LIST
73936: LIST
73937: LIST
73938: LIST
73939: LIST
73940: LIST
73941: LIST
73942: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73943: LD_ADDR_VAR 0 45
73947: PUSH
73948: LD_INT 0
73950: PUSH
73951: LD_INT 0
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: LD_INT 0
73960: PUSH
73961: LD_INT 1
73963: NEG
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 1
73971: PUSH
73972: LD_INT 0
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: LD_INT 1
73981: PUSH
73982: LD_INT 1
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 0
73991: PUSH
73992: LD_INT 1
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 1
74001: NEG
74002: PUSH
74003: LD_INT 0
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: LD_INT 1
74012: NEG
74013: PUSH
74014: LD_INT 1
74016: NEG
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 1
74024: NEG
74025: PUSH
74026: LD_INT 2
74028: NEG
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 0
74036: PUSH
74037: LD_INT 2
74039: NEG
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: PUSH
74045: LD_INT 1
74047: PUSH
74048: LD_INT 1
74050: NEG
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: PUSH
74056: LD_INT 2
74058: PUSH
74059: LD_INT 1
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: LD_INT 2
74068: PUSH
74069: LD_INT 2
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 1
74078: PUSH
74079: LD_INT 2
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 0
74088: PUSH
74089: LD_INT 2
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 1
74098: NEG
74099: PUSH
74100: LD_INT 1
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 2
74109: NEG
74110: PUSH
74111: LD_INT 1
74113: NEG
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: LD_INT 2
74121: NEG
74122: PUSH
74123: LD_INT 2
74125: NEG
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PUSH
74131: LD_INT 2
74133: NEG
74134: PUSH
74135: LD_INT 3
74137: NEG
74138: PUSH
74139: EMPTY
74140: LIST
74141: LIST
74142: PUSH
74143: LD_INT 1
74145: NEG
74146: PUSH
74147: LD_INT 3
74149: NEG
74150: PUSH
74151: EMPTY
74152: LIST
74153: LIST
74154: PUSH
74155: LD_INT 0
74157: PUSH
74158: LD_INT 3
74160: NEG
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: PUSH
74166: LD_INT 1
74168: PUSH
74169: LD_INT 2
74171: NEG
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: LD_INT 3
74179: PUSH
74180: LD_INT 2
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 3
74189: PUSH
74190: LD_INT 3
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 2
74199: PUSH
74200: LD_INT 3
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 1
74209: PUSH
74210: LD_INT 3
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 0
74219: PUSH
74220: LD_INT 3
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: LD_INT 1
74229: NEG
74230: PUSH
74231: LD_INT 2
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: LD_INT 3
74240: NEG
74241: PUSH
74242: LD_INT 2
74244: NEG
74245: PUSH
74246: EMPTY
74247: LIST
74248: LIST
74249: PUSH
74250: LD_INT 3
74252: NEG
74253: PUSH
74254: LD_INT 3
74256: NEG
74257: PUSH
74258: EMPTY
74259: LIST
74260: LIST
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: LIST
74266: LIST
74267: LIST
74268: LIST
74269: LIST
74270: LIST
74271: LIST
74272: LIST
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: LIST
74284: LIST
74285: LIST
74286: LIST
74287: LIST
74288: LIST
74289: LIST
74290: LIST
74291: LIST
74292: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74293: LD_ADDR_VAR 0 46
74297: PUSH
74298: LD_INT 0
74300: PUSH
74301: LD_INT 0
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: PUSH
74308: LD_INT 0
74310: PUSH
74311: LD_INT 1
74313: NEG
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: PUSH
74319: LD_INT 1
74321: PUSH
74322: LD_INT 0
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 1
74331: PUSH
74332: LD_INT 1
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: PUSH
74339: LD_INT 0
74341: PUSH
74342: LD_INT 1
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: LD_INT 1
74351: NEG
74352: PUSH
74353: LD_INT 0
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: PUSH
74360: LD_INT 1
74362: NEG
74363: PUSH
74364: LD_INT 1
74366: NEG
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 1
74374: NEG
74375: PUSH
74376: LD_INT 2
74378: NEG
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 0
74386: PUSH
74387: LD_INT 2
74389: NEG
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: PUSH
74395: LD_INT 1
74397: PUSH
74398: LD_INT 1
74400: NEG
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 2
74408: PUSH
74409: LD_INT 0
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PUSH
74416: LD_INT 2
74418: PUSH
74419: LD_INT 1
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: PUSH
74426: LD_INT 1
74428: PUSH
74429: LD_INT 2
74431: PUSH
74432: EMPTY
74433: LIST
74434: LIST
74435: PUSH
74436: LD_INT 0
74438: PUSH
74439: LD_INT 2
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: PUSH
74446: LD_INT 1
74448: NEG
74449: PUSH
74450: LD_INT 1
74452: PUSH
74453: EMPTY
74454: LIST
74455: LIST
74456: PUSH
74457: LD_INT 2
74459: NEG
74460: PUSH
74461: LD_INT 0
74463: PUSH
74464: EMPTY
74465: LIST
74466: LIST
74467: PUSH
74468: LD_INT 2
74470: NEG
74471: PUSH
74472: LD_INT 1
74474: NEG
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: PUSH
74480: LD_INT 1
74482: NEG
74483: PUSH
74484: LD_INT 3
74486: NEG
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 0
74494: PUSH
74495: LD_INT 3
74497: NEG
74498: PUSH
74499: EMPTY
74500: LIST
74501: LIST
74502: PUSH
74503: LD_INT 1
74505: PUSH
74506: LD_INT 2
74508: NEG
74509: PUSH
74510: EMPTY
74511: LIST
74512: LIST
74513: PUSH
74514: LD_INT 2
74516: PUSH
74517: LD_INT 1
74519: NEG
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_INT 3
74527: PUSH
74528: LD_INT 0
74530: PUSH
74531: EMPTY
74532: LIST
74533: LIST
74534: PUSH
74535: LD_INT 3
74537: PUSH
74538: LD_INT 1
74540: PUSH
74541: EMPTY
74542: LIST
74543: LIST
74544: PUSH
74545: LD_INT 1
74547: PUSH
74548: LD_INT 3
74550: PUSH
74551: EMPTY
74552: LIST
74553: LIST
74554: PUSH
74555: LD_INT 0
74557: PUSH
74558: LD_INT 3
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 1
74567: NEG
74568: PUSH
74569: LD_INT 2
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 2
74578: NEG
74579: PUSH
74580: LD_INT 1
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: LD_INT 3
74589: NEG
74590: PUSH
74591: LD_INT 0
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 3
74600: NEG
74601: PUSH
74602: LD_INT 1
74604: NEG
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: LIST
74614: LIST
74615: LIST
74616: LIST
74617: LIST
74618: LIST
74619: LIST
74620: LIST
74621: LIST
74622: LIST
74623: LIST
74624: LIST
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: LIST
74634: LIST
74635: LIST
74636: LIST
74637: LIST
74638: LIST
74639: LIST
74640: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74641: LD_ADDR_VAR 0 47
74645: PUSH
74646: LD_INT 0
74648: PUSH
74649: LD_INT 0
74651: PUSH
74652: EMPTY
74653: LIST
74654: LIST
74655: PUSH
74656: LD_INT 0
74658: PUSH
74659: LD_INT 1
74661: NEG
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PUSH
74667: LD_INT 1
74669: PUSH
74670: LD_INT 0
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 1
74679: PUSH
74680: LD_INT 1
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 0
74689: PUSH
74690: LD_INT 1
74692: PUSH
74693: EMPTY
74694: LIST
74695: LIST
74696: PUSH
74697: LD_INT 1
74699: NEG
74700: PUSH
74701: LD_INT 0
74703: PUSH
74704: EMPTY
74705: LIST
74706: LIST
74707: PUSH
74708: LD_INT 1
74710: NEG
74711: PUSH
74712: LD_INT 1
74714: NEG
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 1
74722: NEG
74723: PUSH
74724: LD_INT 2
74726: NEG
74727: PUSH
74728: EMPTY
74729: LIST
74730: LIST
74731: PUSH
74732: LD_INT 0
74734: PUSH
74735: LD_INT 2
74737: NEG
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: PUSH
74743: LD_INT 1
74745: PUSH
74746: LD_INT 1
74748: NEG
74749: PUSH
74750: EMPTY
74751: LIST
74752: LIST
74753: PUSH
74754: LD_INT 2
74756: NEG
74757: PUSH
74758: LD_INT 1
74760: NEG
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: LD_INT 2
74768: NEG
74769: PUSH
74770: LD_INT 2
74772: NEG
74773: PUSH
74774: EMPTY
74775: LIST
74776: LIST
74777: PUSH
74778: EMPTY
74779: LIST
74780: LIST
74781: LIST
74782: LIST
74783: LIST
74784: LIST
74785: LIST
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74792: LD_ADDR_VAR 0 48
74796: PUSH
74797: LD_INT 0
74799: PUSH
74800: LD_INT 0
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 0
74809: PUSH
74810: LD_INT 1
74812: NEG
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: PUSH
74818: LD_INT 1
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 1
74830: PUSH
74831: LD_INT 1
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 0
74840: PUSH
74841: LD_INT 1
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: LD_INT 1
74850: NEG
74851: PUSH
74852: LD_INT 0
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 1
74861: NEG
74862: PUSH
74863: LD_INT 1
74865: NEG
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 1
74873: NEG
74874: PUSH
74875: LD_INT 2
74877: NEG
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: LD_INT 0
74885: PUSH
74886: LD_INT 2
74888: NEG
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: PUSH
74894: LD_INT 1
74896: PUSH
74897: LD_INT 1
74899: NEG
74900: PUSH
74901: EMPTY
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 2
74907: PUSH
74908: LD_INT 0
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: PUSH
74915: LD_INT 2
74917: PUSH
74918: LD_INT 1
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: LIST
74929: LIST
74930: LIST
74931: LIST
74932: LIST
74933: LIST
74934: LIST
74935: LIST
74936: LIST
74937: LIST
74938: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74939: LD_ADDR_VAR 0 49
74943: PUSH
74944: LD_INT 0
74946: PUSH
74947: LD_INT 0
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 0
74956: PUSH
74957: LD_INT 1
74959: NEG
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PUSH
74965: LD_INT 1
74967: PUSH
74968: LD_INT 0
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 1
74977: PUSH
74978: LD_INT 1
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 0
74987: PUSH
74988: LD_INT 1
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 1
74997: NEG
74998: PUSH
74999: LD_INT 0
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: LD_INT 1
75008: NEG
75009: PUSH
75010: LD_INT 1
75012: NEG
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: LD_INT 1
75020: PUSH
75021: LD_INT 1
75023: NEG
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: PUSH
75029: LD_INT 2
75031: PUSH
75032: LD_INT 0
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PUSH
75039: LD_INT 2
75041: PUSH
75042: LD_INT 1
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: LD_INT 2
75051: PUSH
75052: LD_INT 2
75054: PUSH
75055: EMPTY
75056: LIST
75057: LIST
75058: PUSH
75059: LD_INT 1
75061: PUSH
75062: LD_INT 2
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: LIST
75076: LIST
75077: LIST
75078: LIST
75079: LIST
75080: LIST
75081: LIST
75082: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75083: LD_ADDR_VAR 0 50
75087: PUSH
75088: LD_INT 0
75090: PUSH
75091: LD_INT 0
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: LD_INT 0
75100: PUSH
75101: LD_INT 1
75103: NEG
75104: PUSH
75105: EMPTY
75106: LIST
75107: LIST
75108: PUSH
75109: LD_INT 1
75111: PUSH
75112: LD_INT 0
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PUSH
75119: LD_INT 1
75121: PUSH
75122: LD_INT 1
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 0
75131: PUSH
75132: LD_INT 1
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 1
75141: NEG
75142: PUSH
75143: LD_INT 0
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: LD_INT 1
75152: NEG
75153: PUSH
75154: LD_INT 1
75156: NEG
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: PUSH
75162: LD_INT 2
75164: PUSH
75165: LD_INT 1
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 2
75174: PUSH
75175: LD_INT 2
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 1
75184: PUSH
75185: LD_INT 2
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 0
75194: PUSH
75195: LD_INT 2
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: LD_INT 1
75204: NEG
75205: PUSH
75206: LD_INT 1
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: EMPTY
75214: LIST
75215: LIST
75216: LIST
75217: LIST
75218: LIST
75219: LIST
75220: LIST
75221: LIST
75222: LIST
75223: LIST
75224: LIST
75225: LIST
75226: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75227: LD_ADDR_VAR 0 51
75231: PUSH
75232: LD_INT 0
75234: PUSH
75235: LD_INT 0
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: PUSH
75242: LD_INT 0
75244: PUSH
75245: LD_INT 1
75247: NEG
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: LD_INT 1
75255: PUSH
75256: LD_INT 0
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: PUSH
75263: LD_INT 1
75265: PUSH
75266: LD_INT 1
75268: PUSH
75269: EMPTY
75270: LIST
75271: LIST
75272: PUSH
75273: LD_INT 0
75275: PUSH
75276: LD_INT 1
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: PUSH
75283: LD_INT 1
75285: NEG
75286: PUSH
75287: LD_INT 0
75289: PUSH
75290: EMPTY
75291: LIST
75292: LIST
75293: PUSH
75294: LD_INT 1
75296: NEG
75297: PUSH
75298: LD_INT 1
75300: NEG
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 1
75308: PUSH
75309: LD_INT 2
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PUSH
75316: LD_INT 0
75318: PUSH
75319: LD_INT 2
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 1
75328: NEG
75329: PUSH
75330: LD_INT 1
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: PUSH
75337: LD_INT 2
75339: NEG
75340: PUSH
75341: LD_INT 0
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PUSH
75348: LD_INT 2
75350: NEG
75351: PUSH
75352: LD_INT 1
75354: NEG
75355: PUSH
75356: EMPTY
75357: LIST
75358: LIST
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: LIST
75364: LIST
75365: LIST
75366: LIST
75367: LIST
75368: LIST
75369: LIST
75370: LIST
75371: LIST
75372: LIST
75373: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75374: LD_ADDR_VAR 0 52
75378: PUSH
75379: LD_INT 0
75381: PUSH
75382: LD_INT 0
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 0
75391: PUSH
75392: LD_INT 1
75394: NEG
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 1
75402: PUSH
75403: LD_INT 0
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 1
75412: PUSH
75413: LD_INT 1
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 0
75422: PUSH
75423: LD_INT 1
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: LD_INT 1
75432: NEG
75433: PUSH
75434: LD_INT 0
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: PUSH
75441: LD_INT 1
75443: NEG
75444: PUSH
75445: LD_INT 1
75447: NEG
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 1
75455: NEG
75456: PUSH
75457: LD_INT 2
75459: NEG
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 1
75467: NEG
75468: PUSH
75469: LD_INT 1
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 2
75478: NEG
75479: PUSH
75480: LD_INT 0
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: PUSH
75487: LD_INT 2
75489: NEG
75490: PUSH
75491: LD_INT 1
75493: NEG
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 2
75501: NEG
75502: PUSH
75503: LD_INT 2
75505: NEG
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: LIST
75515: LIST
75516: LIST
75517: LIST
75518: LIST
75519: LIST
75520: LIST
75521: LIST
75522: LIST
75523: LIST
75524: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75525: LD_ADDR_VAR 0 53
75529: PUSH
75530: LD_INT 0
75532: PUSH
75533: LD_INT 0
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 0
75542: PUSH
75543: LD_INT 1
75545: NEG
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: LD_INT 1
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 1
75563: PUSH
75564: LD_INT 1
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 0
75573: PUSH
75574: LD_INT 1
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 1
75583: NEG
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 1
75594: NEG
75595: PUSH
75596: LD_INT 1
75598: NEG
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: PUSH
75604: LD_INT 1
75606: NEG
75607: PUSH
75608: LD_INT 2
75610: NEG
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 0
75618: PUSH
75619: LD_INT 2
75621: NEG
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: PUSH
75627: LD_INT 1
75629: PUSH
75630: LD_INT 1
75632: NEG
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 2
75640: PUSH
75641: LD_INT 0
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 2
75650: PUSH
75651: LD_INT 1
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 2
75660: PUSH
75661: LD_INT 2
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 1
75670: PUSH
75671: LD_INT 2
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 0
75680: PUSH
75681: LD_INT 2
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: LD_INT 1
75690: NEG
75691: PUSH
75692: LD_INT 1
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: PUSH
75699: LD_INT 2
75701: NEG
75702: PUSH
75703: LD_INT 0
75705: PUSH
75706: EMPTY
75707: LIST
75708: LIST
75709: PUSH
75710: LD_INT 2
75712: NEG
75713: PUSH
75714: LD_INT 1
75716: NEG
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 2
75724: NEG
75725: PUSH
75726: LD_INT 2
75728: NEG
75729: PUSH
75730: EMPTY
75731: LIST
75732: LIST
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: LIST
75738: LIST
75739: LIST
75740: LIST
75741: LIST
75742: LIST
75743: LIST
75744: LIST
75745: LIST
75746: LIST
75747: LIST
75748: LIST
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75755: LD_ADDR_VAR 0 54
75759: PUSH
75760: LD_INT 0
75762: PUSH
75763: LD_INT 0
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 0
75772: PUSH
75773: LD_INT 1
75775: NEG
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: PUSH
75781: LD_INT 1
75783: PUSH
75784: LD_INT 0
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: PUSH
75791: LD_INT 1
75793: PUSH
75794: LD_INT 1
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 0
75803: PUSH
75804: LD_INT 1
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: PUSH
75811: LD_INT 1
75813: NEG
75814: PUSH
75815: LD_INT 0
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PUSH
75822: LD_INT 1
75824: NEG
75825: PUSH
75826: LD_INT 1
75828: NEG
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 1
75836: NEG
75837: PUSH
75838: LD_INT 2
75840: NEG
75841: PUSH
75842: EMPTY
75843: LIST
75844: LIST
75845: PUSH
75846: LD_INT 0
75848: PUSH
75849: LD_INT 2
75851: NEG
75852: PUSH
75853: EMPTY
75854: LIST
75855: LIST
75856: PUSH
75857: LD_INT 1
75859: PUSH
75860: LD_INT 1
75862: NEG
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PUSH
75868: LD_INT 2
75870: PUSH
75871: LD_INT 0
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: PUSH
75878: LD_INT 2
75880: PUSH
75881: LD_INT 1
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 2
75890: PUSH
75891: LD_INT 2
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: LD_INT 1
75900: PUSH
75901: LD_INT 2
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: LD_INT 0
75910: PUSH
75911: LD_INT 2
75913: PUSH
75914: EMPTY
75915: LIST
75916: LIST
75917: PUSH
75918: LD_INT 1
75920: NEG
75921: PUSH
75922: LD_INT 1
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PUSH
75929: LD_INT 2
75931: NEG
75932: PUSH
75933: LD_INT 0
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: PUSH
75940: LD_INT 2
75942: NEG
75943: PUSH
75944: LD_INT 1
75946: NEG
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 2
75954: NEG
75955: PUSH
75956: LD_INT 2
75958: NEG
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: LIST
75968: LIST
75969: LIST
75970: LIST
75971: LIST
75972: LIST
75973: LIST
75974: LIST
75975: LIST
75976: LIST
75977: LIST
75978: LIST
75979: LIST
75980: LIST
75981: LIST
75982: LIST
75983: LIST
75984: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75985: LD_ADDR_VAR 0 55
75989: PUSH
75990: LD_INT 0
75992: PUSH
75993: LD_INT 0
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 0
76002: PUSH
76003: LD_INT 1
76005: NEG
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 1
76013: PUSH
76014: LD_INT 0
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PUSH
76021: LD_INT 1
76023: PUSH
76024: LD_INT 1
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 0
76033: PUSH
76034: LD_INT 1
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: LD_INT 1
76043: NEG
76044: PUSH
76045: LD_INT 0
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: LD_INT 1
76054: NEG
76055: PUSH
76056: LD_INT 1
76058: NEG
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 1
76066: NEG
76067: PUSH
76068: LD_INT 2
76070: NEG
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: LD_INT 0
76078: PUSH
76079: LD_INT 2
76081: NEG
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: PUSH
76087: LD_INT 1
76089: PUSH
76090: LD_INT 1
76092: NEG
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: PUSH
76098: LD_INT 2
76100: PUSH
76101: LD_INT 0
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: PUSH
76108: LD_INT 2
76110: PUSH
76111: LD_INT 1
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: PUSH
76118: LD_INT 2
76120: PUSH
76121: LD_INT 2
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 1
76130: PUSH
76131: LD_INT 2
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: PUSH
76138: LD_INT 0
76140: PUSH
76141: LD_INT 2
76143: PUSH
76144: EMPTY
76145: LIST
76146: LIST
76147: PUSH
76148: LD_INT 1
76150: NEG
76151: PUSH
76152: LD_INT 1
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: LD_INT 2
76161: NEG
76162: PUSH
76163: LD_INT 0
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: PUSH
76170: LD_INT 2
76172: NEG
76173: PUSH
76174: LD_INT 1
76176: NEG
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 2
76184: NEG
76185: PUSH
76186: LD_INT 2
76188: NEG
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: PUSH
76194: EMPTY
76195: LIST
76196: LIST
76197: LIST
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76215: LD_ADDR_VAR 0 56
76219: PUSH
76220: LD_INT 0
76222: PUSH
76223: LD_INT 0
76225: PUSH
76226: EMPTY
76227: LIST
76228: LIST
76229: PUSH
76230: LD_INT 0
76232: PUSH
76233: LD_INT 1
76235: NEG
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PUSH
76241: LD_INT 1
76243: PUSH
76244: LD_INT 0
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: PUSH
76251: LD_INT 1
76253: PUSH
76254: LD_INT 1
76256: PUSH
76257: EMPTY
76258: LIST
76259: LIST
76260: PUSH
76261: LD_INT 0
76263: PUSH
76264: LD_INT 1
76266: PUSH
76267: EMPTY
76268: LIST
76269: LIST
76270: PUSH
76271: LD_INT 1
76273: NEG
76274: PUSH
76275: LD_INT 0
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: PUSH
76282: LD_INT 1
76284: NEG
76285: PUSH
76286: LD_INT 1
76288: NEG
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: LD_INT 1
76296: NEG
76297: PUSH
76298: LD_INT 2
76300: NEG
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: LD_INT 0
76308: PUSH
76309: LD_INT 2
76311: NEG
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: LD_INT 1
76319: PUSH
76320: LD_INT 1
76322: NEG
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: PUSH
76328: LD_INT 2
76330: PUSH
76331: LD_INT 0
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 2
76340: PUSH
76341: LD_INT 1
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: LD_INT 2
76350: PUSH
76351: LD_INT 2
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: LD_INT 1
76360: PUSH
76361: LD_INT 2
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 0
76370: PUSH
76371: LD_INT 2
76373: PUSH
76374: EMPTY
76375: LIST
76376: LIST
76377: PUSH
76378: LD_INT 1
76380: NEG
76381: PUSH
76382: LD_INT 1
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 2
76391: NEG
76392: PUSH
76393: LD_INT 0
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: PUSH
76400: LD_INT 2
76402: NEG
76403: PUSH
76404: LD_INT 1
76406: NEG
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 2
76414: NEG
76415: PUSH
76416: LD_INT 2
76418: NEG
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: LIST
76428: LIST
76429: LIST
76430: LIST
76431: LIST
76432: LIST
76433: LIST
76434: LIST
76435: LIST
76436: LIST
76437: LIST
76438: LIST
76439: LIST
76440: LIST
76441: LIST
76442: LIST
76443: LIST
76444: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76445: LD_ADDR_VAR 0 57
76449: PUSH
76450: LD_INT 0
76452: PUSH
76453: LD_INT 0
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 0
76462: PUSH
76463: LD_INT 1
76465: NEG
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 1
76473: PUSH
76474: LD_INT 0
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: PUSH
76481: LD_INT 1
76483: PUSH
76484: LD_INT 1
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: PUSH
76491: LD_INT 0
76493: PUSH
76494: LD_INT 1
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: LD_INT 1
76503: NEG
76504: PUSH
76505: LD_INT 0
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PUSH
76512: LD_INT 1
76514: NEG
76515: PUSH
76516: LD_INT 1
76518: NEG
76519: PUSH
76520: EMPTY
76521: LIST
76522: LIST
76523: PUSH
76524: LD_INT 1
76526: NEG
76527: PUSH
76528: LD_INT 2
76530: NEG
76531: PUSH
76532: EMPTY
76533: LIST
76534: LIST
76535: PUSH
76536: LD_INT 0
76538: PUSH
76539: LD_INT 2
76541: NEG
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: PUSH
76547: LD_INT 1
76549: PUSH
76550: LD_INT 1
76552: NEG
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: PUSH
76558: LD_INT 2
76560: PUSH
76561: LD_INT 0
76563: PUSH
76564: EMPTY
76565: LIST
76566: LIST
76567: PUSH
76568: LD_INT 2
76570: PUSH
76571: LD_INT 1
76573: PUSH
76574: EMPTY
76575: LIST
76576: LIST
76577: PUSH
76578: LD_INT 2
76580: PUSH
76581: LD_INT 2
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PUSH
76588: LD_INT 1
76590: PUSH
76591: LD_INT 2
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: PUSH
76598: LD_INT 0
76600: PUSH
76601: LD_INT 2
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: PUSH
76608: LD_INT 1
76610: NEG
76611: PUSH
76612: LD_INT 1
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: LD_INT 2
76621: NEG
76622: PUSH
76623: LD_INT 0
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: LD_INT 2
76632: NEG
76633: PUSH
76634: LD_INT 1
76636: NEG
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: PUSH
76642: LD_INT 2
76644: NEG
76645: PUSH
76646: LD_INT 2
76648: NEG
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: LIST
76658: LIST
76659: LIST
76660: LIST
76661: LIST
76662: LIST
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: LIST
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76675: LD_ADDR_VAR 0 58
76679: PUSH
76680: LD_INT 0
76682: PUSH
76683: LD_INT 0
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 0
76692: PUSH
76693: LD_INT 1
76695: NEG
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: LD_INT 1
76703: PUSH
76704: LD_INT 0
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: PUSH
76711: LD_INT 1
76713: PUSH
76714: LD_INT 1
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: PUSH
76721: LD_INT 0
76723: PUSH
76724: LD_INT 1
76726: PUSH
76727: EMPTY
76728: LIST
76729: LIST
76730: PUSH
76731: LD_INT 1
76733: NEG
76734: PUSH
76735: LD_INT 0
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: LD_INT 1
76744: NEG
76745: PUSH
76746: LD_INT 1
76748: NEG
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 1
76756: NEG
76757: PUSH
76758: LD_INT 2
76760: NEG
76761: PUSH
76762: EMPTY
76763: LIST
76764: LIST
76765: PUSH
76766: LD_INT 0
76768: PUSH
76769: LD_INT 2
76771: NEG
76772: PUSH
76773: EMPTY
76774: LIST
76775: LIST
76776: PUSH
76777: LD_INT 1
76779: PUSH
76780: LD_INT 1
76782: NEG
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PUSH
76788: LD_INT 2
76790: PUSH
76791: LD_INT 0
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 2
76800: PUSH
76801: LD_INT 1
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 2
76810: PUSH
76811: LD_INT 2
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 1
76820: PUSH
76821: LD_INT 2
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 0
76830: PUSH
76831: LD_INT 2
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 1
76840: NEG
76841: PUSH
76842: LD_INT 1
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 2
76851: NEG
76852: PUSH
76853: LD_INT 0
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: LD_INT 2
76862: NEG
76863: PUSH
76864: LD_INT 1
76866: NEG
76867: PUSH
76868: EMPTY
76869: LIST
76870: LIST
76871: PUSH
76872: LD_INT 2
76874: NEG
76875: PUSH
76876: LD_INT 2
76878: NEG
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: LIST
76899: LIST
76900: LIST
76901: LIST
76902: LIST
76903: LIST
76904: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76905: LD_ADDR_VAR 0 59
76909: PUSH
76910: LD_INT 0
76912: PUSH
76913: LD_INT 0
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: PUSH
76920: LD_INT 0
76922: PUSH
76923: LD_INT 1
76925: NEG
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: PUSH
76931: LD_INT 1
76933: PUSH
76934: LD_INT 0
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: LD_INT 1
76943: PUSH
76944: LD_INT 1
76946: PUSH
76947: EMPTY
76948: LIST
76949: LIST
76950: PUSH
76951: LD_INT 0
76953: PUSH
76954: LD_INT 1
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: PUSH
76961: LD_INT 1
76963: NEG
76964: PUSH
76965: LD_INT 0
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 1
76974: NEG
76975: PUSH
76976: LD_INT 1
76978: NEG
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: LIST
76988: LIST
76989: LIST
76990: LIST
76991: LIST
76992: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76993: LD_ADDR_VAR 0 60
76997: PUSH
76998: LD_INT 0
77000: PUSH
77001: LD_INT 0
77003: PUSH
77004: EMPTY
77005: LIST
77006: LIST
77007: PUSH
77008: LD_INT 0
77010: PUSH
77011: LD_INT 1
77013: NEG
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 1
77021: PUSH
77022: LD_INT 0
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PUSH
77029: LD_INT 1
77031: PUSH
77032: LD_INT 1
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: LD_INT 0
77041: PUSH
77042: LD_INT 1
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 1
77051: NEG
77052: PUSH
77053: LD_INT 0
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 1
77062: NEG
77063: PUSH
77064: LD_INT 1
77066: NEG
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: LIST
77076: LIST
77077: LIST
77078: LIST
77079: LIST
77080: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77081: LD_ADDR_VAR 0 61
77085: PUSH
77086: LD_INT 0
77088: PUSH
77089: LD_INT 0
77091: PUSH
77092: EMPTY
77093: LIST
77094: LIST
77095: PUSH
77096: LD_INT 0
77098: PUSH
77099: LD_INT 1
77101: NEG
77102: PUSH
77103: EMPTY
77104: LIST
77105: LIST
77106: PUSH
77107: LD_INT 1
77109: PUSH
77110: LD_INT 0
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 1
77119: PUSH
77120: LD_INT 1
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 0
77129: PUSH
77130: LD_INT 1
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 1
77139: NEG
77140: PUSH
77141: LD_INT 0
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: LD_INT 1
77150: NEG
77151: PUSH
77152: LD_INT 1
77154: NEG
77155: PUSH
77156: EMPTY
77157: LIST
77158: LIST
77159: PUSH
77160: EMPTY
77161: LIST
77162: LIST
77163: LIST
77164: LIST
77165: LIST
77166: LIST
77167: LIST
77168: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77169: LD_ADDR_VAR 0 62
77173: PUSH
77174: LD_INT 0
77176: PUSH
77177: LD_INT 0
77179: PUSH
77180: EMPTY
77181: LIST
77182: LIST
77183: PUSH
77184: LD_INT 0
77186: PUSH
77187: LD_INT 1
77189: NEG
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: PUSH
77195: LD_INT 1
77197: PUSH
77198: LD_INT 0
77200: PUSH
77201: EMPTY
77202: LIST
77203: LIST
77204: PUSH
77205: LD_INT 1
77207: PUSH
77208: LD_INT 1
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 0
77217: PUSH
77218: LD_INT 1
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 1
77227: NEG
77228: PUSH
77229: LD_INT 0
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 1
77238: NEG
77239: PUSH
77240: LD_INT 1
77242: NEG
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: LIST
77252: LIST
77253: LIST
77254: LIST
77255: LIST
77256: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77257: LD_ADDR_VAR 0 63
77261: PUSH
77262: LD_INT 0
77264: PUSH
77265: LD_INT 0
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: LD_INT 0
77274: PUSH
77275: LD_INT 1
77277: NEG
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: PUSH
77283: LD_INT 1
77285: PUSH
77286: LD_INT 0
77288: PUSH
77289: EMPTY
77290: LIST
77291: LIST
77292: PUSH
77293: LD_INT 1
77295: PUSH
77296: LD_INT 1
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 0
77305: PUSH
77306: LD_INT 1
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: PUSH
77313: LD_INT 1
77315: NEG
77316: PUSH
77317: LD_INT 0
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: PUSH
77324: LD_INT 1
77326: NEG
77327: PUSH
77328: LD_INT 1
77330: NEG
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: LIST
77340: LIST
77341: LIST
77342: LIST
77343: LIST
77344: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77345: LD_ADDR_VAR 0 64
77349: PUSH
77350: LD_INT 0
77352: PUSH
77353: LD_INT 0
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: LD_INT 0
77362: PUSH
77363: LD_INT 1
77365: NEG
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PUSH
77371: LD_INT 1
77373: PUSH
77374: LD_INT 0
77376: PUSH
77377: EMPTY
77378: LIST
77379: LIST
77380: PUSH
77381: LD_INT 1
77383: PUSH
77384: LD_INT 1
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PUSH
77391: LD_INT 0
77393: PUSH
77394: LD_INT 1
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PUSH
77401: LD_INT 1
77403: NEG
77404: PUSH
77405: LD_INT 0
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 1
77414: NEG
77415: PUSH
77416: LD_INT 1
77418: NEG
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: LIST
77428: LIST
77429: LIST
77430: LIST
77431: LIST
77432: ST_TO_ADDR
// end ; 1 :
77433: GO 83330
77435: LD_INT 1
77437: DOUBLE
77438: EQUAL
77439: IFTRUE 77443
77441: GO 80066
77443: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77444: LD_ADDR_VAR 0 11
77448: PUSH
77449: LD_INT 1
77451: NEG
77452: PUSH
77453: LD_INT 3
77455: NEG
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: PUSH
77461: LD_INT 0
77463: PUSH
77464: LD_INT 3
77466: NEG
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 1
77474: PUSH
77475: LD_INT 2
77477: NEG
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: LIST
77487: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77488: LD_ADDR_VAR 0 12
77492: PUSH
77493: LD_INT 2
77495: PUSH
77496: LD_INT 1
77498: NEG
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: LD_INT 3
77506: PUSH
77507: LD_INT 0
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 3
77516: PUSH
77517: LD_INT 1
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: LIST
77528: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77529: LD_ADDR_VAR 0 13
77533: PUSH
77534: LD_INT 3
77536: PUSH
77537: LD_INT 2
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: LD_INT 3
77546: PUSH
77547: LD_INT 3
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PUSH
77554: LD_INT 2
77556: PUSH
77557: LD_INT 3
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: EMPTY
77565: LIST
77566: LIST
77567: LIST
77568: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77569: LD_ADDR_VAR 0 14
77573: PUSH
77574: LD_INT 1
77576: PUSH
77577: LD_INT 3
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 0
77586: PUSH
77587: LD_INT 3
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 1
77596: NEG
77597: PUSH
77598: LD_INT 2
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: LIST
77609: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77610: LD_ADDR_VAR 0 15
77614: PUSH
77615: LD_INT 2
77617: NEG
77618: PUSH
77619: LD_INT 1
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: LD_INT 3
77628: NEG
77629: PUSH
77630: LD_INT 0
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 3
77639: NEG
77640: PUSH
77641: LD_INT 1
77643: NEG
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: LIST
77653: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77654: LD_ADDR_VAR 0 16
77658: PUSH
77659: LD_INT 2
77661: NEG
77662: PUSH
77663: LD_INT 3
77665: NEG
77666: PUSH
77667: EMPTY
77668: LIST
77669: LIST
77670: PUSH
77671: LD_INT 3
77673: NEG
77674: PUSH
77675: LD_INT 2
77677: NEG
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_INT 3
77685: NEG
77686: PUSH
77687: LD_INT 3
77689: NEG
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: LIST
77699: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77700: LD_ADDR_VAR 0 17
77704: PUSH
77705: LD_INT 1
77707: NEG
77708: PUSH
77709: LD_INT 3
77711: NEG
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 0
77719: PUSH
77720: LD_INT 3
77722: NEG
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PUSH
77728: LD_INT 1
77730: PUSH
77731: LD_INT 2
77733: NEG
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: LIST
77743: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77744: LD_ADDR_VAR 0 18
77748: PUSH
77749: LD_INT 2
77751: PUSH
77752: LD_INT 1
77754: NEG
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 3
77762: PUSH
77763: LD_INT 0
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: PUSH
77770: LD_INT 3
77772: PUSH
77773: LD_INT 1
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: LIST
77784: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77785: LD_ADDR_VAR 0 19
77789: PUSH
77790: LD_INT 3
77792: PUSH
77793: LD_INT 2
77795: PUSH
77796: EMPTY
77797: LIST
77798: LIST
77799: PUSH
77800: LD_INT 3
77802: PUSH
77803: LD_INT 3
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: LD_INT 2
77812: PUSH
77813: LD_INT 3
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: LIST
77824: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77825: LD_ADDR_VAR 0 20
77829: PUSH
77830: LD_INT 1
77832: PUSH
77833: LD_INT 3
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: PUSH
77840: LD_INT 0
77842: PUSH
77843: LD_INT 3
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 1
77852: NEG
77853: PUSH
77854: LD_INT 2
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: LIST
77865: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77866: LD_ADDR_VAR 0 21
77870: PUSH
77871: LD_INT 2
77873: NEG
77874: PUSH
77875: LD_INT 1
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PUSH
77882: LD_INT 3
77884: NEG
77885: PUSH
77886: LD_INT 0
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 3
77895: NEG
77896: PUSH
77897: LD_INT 1
77899: NEG
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: LIST
77909: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77910: LD_ADDR_VAR 0 22
77914: PUSH
77915: LD_INT 2
77917: NEG
77918: PUSH
77919: LD_INT 3
77921: NEG
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: LD_INT 3
77929: NEG
77930: PUSH
77931: LD_INT 2
77933: NEG
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 3
77941: NEG
77942: PUSH
77943: LD_INT 3
77945: NEG
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: LIST
77955: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77956: LD_ADDR_VAR 0 23
77960: PUSH
77961: LD_INT 0
77963: PUSH
77964: LD_INT 3
77966: NEG
77967: PUSH
77968: EMPTY
77969: LIST
77970: LIST
77971: PUSH
77972: LD_INT 1
77974: NEG
77975: PUSH
77976: LD_INT 4
77978: NEG
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: PUSH
77984: LD_INT 1
77986: PUSH
77987: LD_INT 3
77989: NEG
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: EMPTY
77996: LIST
77997: LIST
77998: LIST
77999: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78000: LD_ADDR_VAR 0 24
78004: PUSH
78005: LD_INT 3
78007: PUSH
78008: LD_INT 0
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PUSH
78015: LD_INT 3
78017: PUSH
78018: LD_INT 1
78020: NEG
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 4
78028: PUSH
78029: LD_INT 1
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: LIST
78040: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78041: LD_ADDR_VAR 0 25
78045: PUSH
78046: LD_INT 3
78048: PUSH
78049: LD_INT 3
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 4
78058: PUSH
78059: LD_INT 3
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: LD_INT 3
78068: PUSH
78069: LD_INT 4
78071: PUSH
78072: EMPTY
78073: LIST
78074: LIST
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: LIST
78080: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78081: LD_ADDR_VAR 0 26
78085: PUSH
78086: LD_INT 0
78088: PUSH
78089: LD_INT 3
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: LD_INT 1
78098: PUSH
78099: LD_INT 4
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: LD_INT 1
78108: NEG
78109: PUSH
78110: LD_INT 3
78112: PUSH
78113: EMPTY
78114: LIST
78115: LIST
78116: PUSH
78117: EMPTY
78118: LIST
78119: LIST
78120: LIST
78121: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78122: LD_ADDR_VAR 0 27
78126: PUSH
78127: LD_INT 3
78129: NEG
78130: PUSH
78131: LD_INT 0
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PUSH
78138: LD_INT 3
78140: NEG
78141: PUSH
78142: LD_INT 1
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 4
78151: NEG
78152: PUSH
78153: LD_INT 1
78155: NEG
78156: PUSH
78157: EMPTY
78158: LIST
78159: LIST
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: LIST
78165: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78166: LD_ADDR_VAR 0 28
78170: PUSH
78171: LD_INT 3
78173: NEG
78174: PUSH
78175: LD_INT 3
78177: NEG
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 3
78185: NEG
78186: PUSH
78187: LD_INT 4
78189: NEG
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 4
78197: NEG
78198: PUSH
78199: LD_INT 3
78201: NEG
78202: PUSH
78203: EMPTY
78204: LIST
78205: LIST
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: LIST
78211: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78212: LD_ADDR_VAR 0 29
78216: PUSH
78217: LD_INT 1
78219: NEG
78220: PUSH
78221: LD_INT 3
78223: NEG
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: LD_INT 0
78231: PUSH
78232: LD_INT 3
78234: NEG
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: LD_INT 1
78242: PUSH
78243: LD_INT 2
78245: NEG
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 1
78253: NEG
78254: PUSH
78255: LD_INT 4
78257: NEG
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: LD_INT 0
78265: PUSH
78266: LD_INT 4
78268: NEG
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 1
78276: PUSH
78277: LD_INT 3
78279: NEG
78280: PUSH
78281: EMPTY
78282: LIST
78283: LIST
78284: PUSH
78285: LD_INT 1
78287: NEG
78288: PUSH
78289: LD_INT 5
78291: NEG
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 0
78299: PUSH
78300: LD_INT 5
78302: NEG
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: LD_INT 1
78310: PUSH
78311: LD_INT 4
78313: NEG
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 1
78321: NEG
78322: PUSH
78323: LD_INT 6
78325: NEG
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 0
78333: PUSH
78334: LD_INT 6
78336: NEG
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 1
78344: PUSH
78345: LD_INT 5
78347: NEG
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: LIST
78363: LIST
78364: LIST
78365: LIST
78366: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78367: LD_ADDR_VAR 0 30
78371: PUSH
78372: LD_INT 2
78374: PUSH
78375: LD_INT 1
78377: NEG
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: PUSH
78383: LD_INT 3
78385: PUSH
78386: LD_INT 0
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PUSH
78393: LD_INT 3
78395: PUSH
78396: LD_INT 1
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: PUSH
78403: LD_INT 3
78405: PUSH
78406: LD_INT 1
78408: NEG
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 4
78416: PUSH
78417: LD_INT 0
78419: PUSH
78420: EMPTY
78421: LIST
78422: LIST
78423: PUSH
78424: LD_INT 4
78426: PUSH
78427: LD_INT 1
78429: PUSH
78430: EMPTY
78431: LIST
78432: LIST
78433: PUSH
78434: LD_INT 4
78436: PUSH
78437: LD_INT 1
78439: NEG
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 5
78447: PUSH
78448: LD_INT 0
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 5
78457: PUSH
78458: LD_INT 1
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 5
78467: PUSH
78468: LD_INT 1
78470: NEG
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 6
78478: PUSH
78479: LD_INT 0
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 6
78488: PUSH
78489: LD_INT 1
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: LIST
78500: LIST
78501: LIST
78502: LIST
78503: LIST
78504: LIST
78505: LIST
78506: LIST
78507: LIST
78508: LIST
78509: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78510: LD_ADDR_VAR 0 31
78514: PUSH
78515: LD_INT 3
78517: PUSH
78518: LD_INT 2
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: LD_INT 3
78527: PUSH
78528: LD_INT 3
78530: PUSH
78531: EMPTY
78532: LIST
78533: LIST
78534: PUSH
78535: LD_INT 2
78537: PUSH
78538: LD_INT 3
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: PUSH
78545: LD_INT 4
78547: PUSH
78548: LD_INT 3
78550: PUSH
78551: EMPTY
78552: LIST
78553: LIST
78554: PUSH
78555: LD_INT 4
78557: PUSH
78558: LD_INT 4
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 3
78567: PUSH
78568: LD_INT 4
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 5
78577: PUSH
78578: LD_INT 4
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 5
78587: PUSH
78588: LD_INT 5
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 4
78597: PUSH
78598: LD_INT 5
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: LD_INT 6
78607: PUSH
78608: LD_INT 5
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_INT 6
78617: PUSH
78618: LD_INT 6
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 5
78627: PUSH
78628: LD_INT 6
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: LIST
78639: LIST
78640: LIST
78641: LIST
78642: LIST
78643: LIST
78644: LIST
78645: LIST
78646: LIST
78647: LIST
78648: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78649: LD_ADDR_VAR 0 32
78653: PUSH
78654: LD_INT 1
78656: PUSH
78657: LD_INT 3
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: LD_INT 0
78666: PUSH
78667: LD_INT 3
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 1
78676: NEG
78677: PUSH
78678: LD_INT 2
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: LD_INT 1
78687: PUSH
78688: LD_INT 4
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: PUSH
78695: LD_INT 0
78697: PUSH
78698: LD_INT 4
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 1
78707: NEG
78708: PUSH
78709: LD_INT 3
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 1
78718: PUSH
78719: LD_INT 5
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 0
78728: PUSH
78729: LD_INT 5
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 1
78738: NEG
78739: PUSH
78740: LD_INT 4
78742: PUSH
78743: EMPTY
78744: LIST
78745: LIST
78746: PUSH
78747: LD_INT 1
78749: PUSH
78750: LD_INT 6
78752: PUSH
78753: EMPTY
78754: LIST
78755: LIST
78756: PUSH
78757: LD_INT 0
78759: PUSH
78760: LD_INT 6
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: LD_INT 1
78769: NEG
78770: PUSH
78771: LD_INT 5
78773: PUSH
78774: EMPTY
78775: LIST
78776: LIST
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78792: LD_ADDR_VAR 0 33
78796: PUSH
78797: LD_INT 2
78799: NEG
78800: PUSH
78801: LD_INT 1
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 3
78810: NEG
78811: PUSH
78812: LD_INT 0
78814: PUSH
78815: EMPTY
78816: LIST
78817: LIST
78818: PUSH
78819: LD_INT 3
78821: NEG
78822: PUSH
78823: LD_INT 1
78825: NEG
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 3
78833: NEG
78834: PUSH
78835: LD_INT 1
78837: PUSH
78838: EMPTY
78839: LIST
78840: LIST
78841: PUSH
78842: LD_INT 4
78844: NEG
78845: PUSH
78846: LD_INT 0
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: PUSH
78853: LD_INT 4
78855: NEG
78856: PUSH
78857: LD_INT 1
78859: NEG
78860: PUSH
78861: EMPTY
78862: LIST
78863: LIST
78864: PUSH
78865: LD_INT 4
78867: NEG
78868: PUSH
78869: LD_INT 1
78871: PUSH
78872: EMPTY
78873: LIST
78874: LIST
78875: PUSH
78876: LD_INT 5
78878: NEG
78879: PUSH
78880: LD_INT 0
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 5
78889: NEG
78890: PUSH
78891: LD_INT 1
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 5
78901: NEG
78902: PUSH
78903: LD_INT 1
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 6
78912: NEG
78913: PUSH
78914: LD_INT 0
78916: PUSH
78917: EMPTY
78918: LIST
78919: LIST
78920: PUSH
78921: LD_INT 6
78923: NEG
78924: PUSH
78925: LD_INT 1
78927: NEG
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: LIST
78937: LIST
78938: LIST
78939: LIST
78940: LIST
78941: LIST
78942: LIST
78943: LIST
78944: LIST
78945: LIST
78946: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78947: LD_ADDR_VAR 0 34
78951: PUSH
78952: LD_INT 2
78954: NEG
78955: PUSH
78956: LD_INT 3
78958: NEG
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 3
78966: NEG
78967: PUSH
78968: LD_INT 2
78970: NEG
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PUSH
78976: LD_INT 3
78978: NEG
78979: PUSH
78980: LD_INT 3
78982: NEG
78983: PUSH
78984: EMPTY
78985: LIST
78986: LIST
78987: PUSH
78988: LD_INT 3
78990: NEG
78991: PUSH
78992: LD_INT 4
78994: NEG
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: LD_INT 4
79002: NEG
79003: PUSH
79004: LD_INT 3
79006: NEG
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: PUSH
79012: LD_INT 4
79014: NEG
79015: PUSH
79016: LD_INT 4
79018: NEG
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 4
79026: NEG
79027: PUSH
79028: LD_INT 5
79030: NEG
79031: PUSH
79032: EMPTY
79033: LIST
79034: LIST
79035: PUSH
79036: LD_INT 5
79038: NEG
79039: PUSH
79040: LD_INT 4
79042: NEG
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 5
79050: NEG
79051: PUSH
79052: LD_INT 5
79054: NEG
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 5
79062: NEG
79063: PUSH
79064: LD_INT 6
79066: NEG
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 6
79074: NEG
79075: PUSH
79076: LD_INT 5
79078: NEG
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 6
79086: NEG
79087: PUSH
79088: LD_INT 6
79090: NEG
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79110: LD_ADDR_VAR 0 41
79114: PUSH
79115: LD_INT 0
79117: PUSH
79118: LD_INT 2
79120: NEG
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 1
79128: NEG
79129: PUSH
79130: LD_INT 3
79132: NEG
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 1
79140: PUSH
79141: LD_INT 2
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: LIST
79153: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79154: LD_ADDR_VAR 0 42
79158: PUSH
79159: LD_INT 2
79161: PUSH
79162: LD_INT 0
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 2
79171: PUSH
79172: LD_INT 1
79174: NEG
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PUSH
79180: LD_INT 3
79182: PUSH
79183: LD_INT 1
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: LIST
79194: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79195: LD_ADDR_VAR 0 43
79199: PUSH
79200: LD_INT 2
79202: PUSH
79203: LD_INT 2
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 3
79212: PUSH
79213: LD_INT 2
79215: PUSH
79216: EMPTY
79217: LIST
79218: LIST
79219: PUSH
79220: LD_INT 2
79222: PUSH
79223: LD_INT 3
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: LIST
79234: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79235: LD_ADDR_VAR 0 44
79239: PUSH
79240: LD_INT 0
79242: PUSH
79243: LD_INT 2
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 1
79252: PUSH
79253: LD_INT 3
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 1
79262: NEG
79263: PUSH
79264: LD_INT 2
79266: PUSH
79267: EMPTY
79268: LIST
79269: LIST
79270: PUSH
79271: EMPTY
79272: LIST
79273: LIST
79274: LIST
79275: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79276: LD_ADDR_VAR 0 45
79280: PUSH
79281: LD_INT 2
79283: NEG
79284: PUSH
79285: LD_INT 0
79287: PUSH
79288: EMPTY
79289: LIST
79290: LIST
79291: PUSH
79292: LD_INT 2
79294: NEG
79295: PUSH
79296: LD_INT 1
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 3
79305: NEG
79306: PUSH
79307: LD_INT 1
79309: NEG
79310: PUSH
79311: EMPTY
79312: LIST
79313: LIST
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: LIST
79319: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79320: LD_ADDR_VAR 0 46
79324: PUSH
79325: LD_INT 2
79327: NEG
79328: PUSH
79329: LD_INT 2
79331: NEG
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 2
79339: NEG
79340: PUSH
79341: LD_INT 3
79343: NEG
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 3
79351: NEG
79352: PUSH
79353: LD_INT 2
79355: NEG
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: LIST
79365: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79366: LD_ADDR_VAR 0 47
79370: PUSH
79371: LD_INT 2
79373: NEG
79374: PUSH
79375: LD_INT 3
79377: NEG
79378: PUSH
79379: EMPTY
79380: LIST
79381: LIST
79382: PUSH
79383: LD_INT 1
79385: NEG
79386: PUSH
79387: LD_INT 3
79389: NEG
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79399: LD_ADDR_VAR 0 48
79403: PUSH
79404: LD_INT 1
79406: PUSH
79407: LD_INT 2
79409: NEG
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 2
79417: PUSH
79418: LD_INT 1
79420: NEG
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79430: LD_ADDR_VAR 0 49
79434: PUSH
79435: LD_INT 3
79437: PUSH
79438: LD_INT 1
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 3
79447: PUSH
79448: LD_INT 2
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79459: LD_ADDR_VAR 0 50
79463: PUSH
79464: LD_INT 2
79466: PUSH
79467: LD_INT 3
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: LD_INT 1
79476: PUSH
79477: LD_INT 3
79479: PUSH
79480: EMPTY
79481: LIST
79482: LIST
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79488: LD_ADDR_VAR 0 51
79492: PUSH
79493: LD_INT 1
79495: NEG
79496: PUSH
79497: LD_INT 2
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: LD_INT 2
79506: NEG
79507: PUSH
79508: LD_INT 1
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79519: LD_ADDR_VAR 0 52
79523: PUSH
79524: LD_INT 3
79526: NEG
79527: PUSH
79528: LD_INT 1
79530: NEG
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: PUSH
79536: LD_INT 3
79538: NEG
79539: PUSH
79540: LD_INT 2
79542: NEG
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79552: LD_ADDR_VAR 0 53
79556: PUSH
79557: LD_INT 1
79559: NEG
79560: PUSH
79561: LD_INT 3
79563: NEG
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 0
79571: PUSH
79572: LD_INT 3
79574: NEG
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: PUSH
79580: LD_INT 1
79582: PUSH
79583: LD_INT 2
79585: NEG
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: LIST
79595: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79596: LD_ADDR_VAR 0 54
79600: PUSH
79601: LD_INT 2
79603: PUSH
79604: LD_INT 1
79606: NEG
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 3
79614: PUSH
79615: LD_INT 0
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: LD_INT 3
79624: PUSH
79625: LD_INT 1
79627: PUSH
79628: EMPTY
79629: LIST
79630: LIST
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: LIST
79636: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79637: LD_ADDR_VAR 0 55
79641: PUSH
79642: LD_INT 3
79644: PUSH
79645: LD_INT 2
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 3
79654: PUSH
79655: LD_INT 3
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 2
79664: PUSH
79665: LD_INT 3
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: LIST
79676: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79677: LD_ADDR_VAR 0 56
79681: PUSH
79682: LD_INT 1
79684: PUSH
79685: LD_INT 3
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: PUSH
79692: LD_INT 0
79694: PUSH
79695: LD_INT 3
79697: PUSH
79698: EMPTY
79699: LIST
79700: LIST
79701: PUSH
79702: LD_INT 1
79704: NEG
79705: PUSH
79706: LD_INT 2
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: LIST
79717: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79718: LD_ADDR_VAR 0 57
79722: PUSH
79723: LD_INT 2
79725: NEG
79726: PUSH
79727: LD_INT 1
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 3
79736: NEG
79737: PUSH
79738: LD_INT 0
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PUSH
79745: LD_INT 3
79747: NEG
79748: PUSH
79749: LD_INT 1
79751: NEG
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: PUSH
79757: EMPTY
79758: LIST
79759: LIST
79760: LIST
79761: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79762: LD_ADDR_VAR 0 58
79766: PUSH
79767: LD_INT 2
79769: NEG
79770: PUSH
79771: LD_INT 3
79773: NEG
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: LD_INT 3
79781: NEG
79782: PUSH
79783: LD_INT 2
79785: NEG
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 3
79793: NEG
79794: PUSH
79795: LD_INT 3
79797: NEG
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: LIST
79807: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79808: LD_ADDR_VAR 0 59
79812: PUSH
79813: LD_INT 1
79815: NEG
79816: PUSH
79817: LD_INT 2
79819: NEG
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 0
79827: PUSH
79828: LD_INT 2
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 1
79838: PUSH
79839: LD_INT 1
79841: NEG
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: LIST
79851: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79852: LD_ADDR_VAR 0 60
79856: PUSH
79857: LD_INT 1
79859: PUSH
79860: LD_INT 1
79862: NEG
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PUSH
79868: LD_INT 2
79870: PUSH
79871: LD_INT 0
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: LD_INT 2
79880: PUSH
79881: LD_INT 1
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: LIST
79892: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79893: LD_ADDR_VAR 0 61
79897: PUSH
79898: LD_INT 2
79900: PUSH
79901: LD_INT 1
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 2
79910: PUSH
79911: LD_INT 2
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 1
79920: PUSH
79921: LD_INT 2
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: LIST
79932: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79933: LD_ADDR_VAR 0 62
79937: PUSH
79938: LD_INT 1
79940: PUSH
79941: LD_INT 2
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 0
79950: PUSH
79951: LD_INT 2
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: LD_INT 1
79960: NEG
79961: PUSH
79962: LD_INT 1
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PUSH
79969: EMPTY
79970: LIST
79971: LIST
79972: LIST
79973: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79974: LD_ADDR_VAR 0 63
79978: PUSH
79979: LD_INT 1
79981: NEG
79982: PUSH
79983: LD_INT 1
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 2
79992: NEG
79993: PUSH
79994: LD_INT 0
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 2
80003: NEG
80004: PUSH
80005: LD_INT 1
80007: NEG
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: LIST
80017: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80018: LD_ADDR_VAR 0 64
80022: PUSH
80023: LD_INT 1
80025: NEG
80026: PUSH
80027: LD_INT 2
80029: NEG
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 2
80037: NEG
80038: PUSH
80039: LD_INT 1
80041: NEG
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 2
80049: NEG
80050: PUSH
80051: LD_INT 2
80053: NEG
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: LIST
80063: ST_TO_ADDR
// end ; 2 :
80064: GO 83330
80066: LD_INT 2
80068: DOUBLE
80069: EQUAL
80070: IFTRUE 80074
80072: GO 83329
80074: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80075: LD_ADDR_VAR 0 29
80079: PUSH
80080: LD_INT 4
80082: PUSH
80083: LD_INT 0
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 4
80092: PUSH
80093: LD_INT 1
80095: NEG
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 5
80103: PUSH
80104: LD_INT 0
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PUSH
80111: LD_INT 5
80113: PUSH
80114: LD_INT 1
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: LD_INT 4
80123: PUSH
80124: LD_INT 1
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 3
80133: PUSH
80134: LD_INT 0
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: PUSH
80141: LD_INT 3
80143: PUSH
80144: LD_INT 1
80146: NEG
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 3
80154: PUSH
80155: LD_INT 2
80157: NEG
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: PUSH
80163: LD_INT 5
80165: PUSH
80166: LD_INT 2
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: PUSH
80173: LD_INT 3
80175: PUSH
80176: LD_INT 3
80178: PUSH
80179: EMPTY
80180: LIST
80181: LIST
80182: PUSH
80183: LD_INT 3
80185: PUSH
80186: LD_INT 2
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 4
80195: PUSH
80196: LD_INT 3
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 4
80205: PUSH
80206: LD_INT 4
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: PUSH
80213: LD_INT 3
80215: PUSH
80216: LD_INT 4
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 2
80225: PUSH
80226: LD_INT 3
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 2
80235: PUSH
80236: LD_INT 2
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 4
80245: PUSH
80246: LD_INT 2
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: LD_INT 2
80255: PUSH
80256: LD_INT 4
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 0
80265: PUSH
80266: LD_INT 4
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 0
80275: PUSH
80276: LD_INT 3
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 1
80285: PUSH
80286: LD_INT 4
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 1
80295: PUSH
80296: LD_INT 5
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 0
80305: PUSH
80306: LD_INT 5
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 1
80315: NEG
80316: PUSH
80317: LD_INT 4
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 1
80326: NEG
80327: PUSH
80328: LD_INT 3
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: LD_INT 2
80337: PUSH
80338: LD_INT 5
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 2
80347: NEG
80348: PUSH
80349: LD_INT 3
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 3
80358: NEG
80359: PUSH
80360: LD_INT 0
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 3
80369: NEG
80370: PUSH
80371: LD_INT 1
80373: NEG
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 2
80381: NEG
80382: PUSH
80383: LD_INT 0
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 2
80392: NEG
80393: PUSH
80394: LD_INT 1
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 3
80403: NEG
80404: PUSH
80405: LD_INT 1
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 4
80414: NEG
80415: PUSH
80416: LD_INT 0
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 4
80425: NEG
80426: PUSH
80427: LD_INT 1
80429: NEG
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 4
80437: NEG
80438: PUSH
80439: LD_INT 2
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 2
80449: NEG
80450: PUSH
80451: LD_INT 2
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: PUSH
80458: LD_INT 4
80460: NEG
80461: PUSH
80462: LD_INT 4
80464: NEG
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: LD_INT 4
80472: NEG
80473: PUSH
80474: LD_INT 5
80476: NEG
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 3
80484: NEG
80485: PUSH
80486: LD_INT 4
80488: NEG
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: LD_INT 3
80496: NEG
80497: PUSH
80498: LD_INT 3
80500: NEG
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 4
80508: NEG
80509: PUSH
80510: LD_INT 3
80512: NEG
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 5
80520: NEG
80521: PUSH
80522: LD_INT 4
80524: NEG
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 5
80532: NEG
80533: PUSH
80534: LD_INT 5
80536: NEG
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 3
80544: NEG
80545: PUSH
80546: LD_INT 5
80548: NEG
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 5
80556: NEG
80557: PUSH
80558: LD_INT 3
80560: NEG
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80613: LD_ADDR_VAR 0 30
80617: PUSH
80618: LD_INT 4
80620: PUSH
80621: LD_INT 4
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 4
80630: PUSH
80631: LD_INT 3
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 5
80640: PUSH
80641: LD_INT 4
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 5
80650: PUSH
80651: LD_INT 5
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 4
80660: PUSH
80661: LD_INT 5
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 3
80670: PUSH
80671: LD_INT 4
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 3
80680: PUSH
80681: LD_INT 3
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_INT 5
80690: PUSH
80691: LD_INT 3
80693: PUSH
80694: EMPTY
80695: LIST
80696: LIST
80697: PUSH
80698: LD_INT 3
80700: PUSH
80701: LD_INT 5
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: PUSH
80708: LD_INT 0
80710: PUSH
80711: LD_INT 3
80713: PUSH
80714: EMPTY
80715: LIST
80716: LIST
80717: PUSH
80718: LD_INT 0
80720: PUSH
80721: LD_INT 2
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 1
80730: PUSH
80731: LD_INT 3
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: LD_INT 1
80740: PUSH
80741: LD_INT 4
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 0
80750: PUSH
80751: LD_INT 4
80753: PUSH
80754: EMPTY
80755: LIST
80756: LIST
80757: PUSH
80758: LD_INT 1
80760: NEG
80761: PUSH
80762: LD_INT 3
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 1
80771: NEG
80772: PUSH
80773: LD_INT 2
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 2
80782: PUSH
80783: LD_INT 4
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: LD_INT 2
80792: NEG
80793: PUSH
80794: LD_INT 2
80796: PUSH
80797: EMPTY
80798: LIST
80799: LIST
80800: PUSH
80801: LD_INT 4
80803: NEG
80804: PUSH
80805: LD_INT 0
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 4
80814: NEG
80815: PUSH
80816: LD_INT 1
80818: NEG
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: LD_INT 3
80826: NEG
80827: PUSH
80828: LD_INT 0
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 3
80837: NEG
80838: PUSH
80839: LD_INT 1
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 4
80848: NEG
80849: PUSH
80850: LD_INT 1
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 5
80859: NEG
80860: PUSH
80861: LD_INT 0
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: LD_INT 5
80870: NEG
80871: PUSH
80872: LD_INT 1
80874: NEG
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 5
80882: NEG
80883: PUSH
80884: LD_INT 2
80886: NEG
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 3
80894: NEG
80895: PUSH
80896: LD_INT 2
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 3
80905: NEG
80906: PUSH
80907: LD_INT 3
80909: NEG
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 3
80917: NEG
80918: PUSH
80919: LD_INT 4
80921: NEG
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 2
80929: NEG
80930: PUSH
80931: LD_INT 3
80933: NEG
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 2
80941: NEG
80942: PUSH
80943: LD_INT 2
80945: NEG
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: LD_INT 3
80953: NEG
80954: PUSH
80955: LD_INT 2
80957: NEG
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: LD_INT 4
80965: NEG
80966: PUSH
80967: LD_INT 3
80969: NEG
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PUSH
80975: LD_INT 4
80977: NEG
80978: PUSH
80979: LD_INT 4
80981: NEG
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 2
80989: NEG
80990: PUSH
80991: LD_INT 4
80993: NEG
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 4
81001: NEG
81002: PUSH
81003: LD_INT 2
81005: NEG
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 0
81013: PUSH
81014: LD_INT 4
81016: NEG
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 0
81024: PUSH
81025: LD_INT 5
81027: NEG
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 1
81035: PUSH
81036: LD_INT 4
81038: NEG
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: PUSH
81044: LD_INT 1
81046: PUSH
81047: LD_INT 3
81049: NEG
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: PUSH
81055: LD_INT 0
81057: PUSH
81058: LD_INT 3
81060: NEG
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: PUSH
81066: LD_INT 1
81068: NEG
81069: PUSH
81070: LD_INT 4
81072: NEG
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 1
81080: NEG
81081: PUSH
81082: LD_INT 5
81084: NEG
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 2
81092: PUSH
81093: LD_INT 3
81095: NEG
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 2
81103: NEG
81104: PUSH
81105: LD_INT 5
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: LIST
81117: LIST
81118: LIST
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: LIST
81125: LIST
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81160: LD_ADDR_VAR 0 31
81164: PUSH
81165: LD_INT 0
81167: PUSH
81168: LD_INT 4
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 0
81177: PUSH
81178: LD_INT 3
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 1
81187: PUSH
81188: LD_INT 4
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 1
81197: PUSH
81198: LD_INT 5
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 0
81207: PUSH
81208: LD_INT 5
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 1
81217: NEG
81218: PUSH
81219: LD_INT 4
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 1
81228: NEG
81229: PUSH
81230: LD_INT 3
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 2
81239: PUSH
81240: LD_INT 5
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 2
81249: NEG
81250: PUSH
81251: LD_INT 3
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 3
81260: NEG
81261: PUSH
81262: LD_INT 0
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: LD_INT 3
81271: NEG
81272: PUSH
81273: LD_INT 1
81275: NEG
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: PUSH
81281: LD_INT 2
81283: NEG
81284: PUSH
81285: LD_INT 0
81287: PUSH
81288: EMPTY
81289: LIST
81290: LIST
81291: PUSH
81292: LD_INT 2
81294: NEG
81295: PUSH
81296: LD_INT 1
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: PUSH
81303: LD_INT 3
81305: NEG
81306: PUSH
81307: LD_INT 1
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_INT 4
81316: NEG
81317: PUSH
81318: LD_INT 0
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 4
81327: NEG
81328: PUSH
81329: LD_INT 1
81331: NEG
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 4
81339: NEG
81340: PUSH
81341: LD_INT 2
81343: NEG
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 2
81351: NEG
81352: PUSH
81353: LD_INT 2
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 4
81362: NEG
81363: PUSH
81364: LD_INT 4
81366: NEG
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: LD_INT 4
81374: NEG
81375: PUSH
81376: LD_INT 5
81378: NEG
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: PUSH
81384: LD_INT 3
81386: NEG
81387: PUSH
81388: LD_INT 4
81390: NEG
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 3
81398: NEG
81399: PUSH
81400: LD_INT 3
81402: NEG
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 4
81410: NEG
81411: PUSH
81412: LD_INT 3
81414: NEG
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 5
81422: NEG
81423: PUSH
81424: LD_INT 4
81426: NEG
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 5
81434: NEG
81435: PUSH
81436: LD_INT 5
81438: NEG
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: PUSH
81444: LD_INT 3
81446: NEG
81447: PUSH
81448: LD_INT 5
81450: NEG
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 5
81458: NEG
81459: PUSH
81460: LD_INT 3
81462: NEG
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: LD_INT 0
81470: PUSH
81471: LD_INT 3
81473: NEG
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 0
81481: PUSH
81482: LD_INT 4
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 1
81492: PUSH
81493: LD_INT 3
81495: NEG
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 1
81503: PUSH
81504: LD_INT 2
81506: NEG
81507: PUSH
81508: EMPTY
81509: LIST
81510: LIST
81511: PUSH
81512: LD_INT 0
81514: PUSH
81515: LD_INT 2
81517: NEG
81518: PUSH
81519: EMPTY
81520: LIST
81521: LIST
81522: PUSH
81523: LD_INT 1
81525: NEG
81526: PUSH
81527: LD_INT 3
81529: NEG
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 1
81537: NEG
81538: PUSH
81539: LD_INT 4
81541: NEG
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 2
81549: PUSH
81550: LD_INT 2
81552: NEG
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 2
81560: NEG
81561: PUSH
81562: LD_INT 4
81564: NEG
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: LD_INT 4
81572: PUSH
81573: LD_INT 0
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 4
81582: PUSH
81583: LD_INT 1
81585: NEG
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PUSH
81591: LD_INT 5
81593: PUSH
81594: LD_INT 0
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 5
81603: PUSH
81604: LD_INT 1
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 4
81613: PUSH
81614: LD_INT 1
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 3
81623: PUSH
81624: LD_INT 0
81626: PUSH
81627: EMPTY
81628: LIST
81629: LIST
81630: PUSH
81631: LD_INT 3
81633: PUSH
81634: LD_INT 1
81636: NEG
81637: PUSH
81638: EMPTY
81639: LIST
81640: LIST
81641: PUSH
81642: LD_INT 3
81644: PUSH
81645: LD_INT 2
81647: NEG
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 5
81655: PUSH
81656: LD_INT 2
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: LIST
81667: LIST
81668: LIST
81669: LIST
81670: LIST
81671: LIST
81672: LIST
81673: LIST
81674: LIST
81675: LIST
81676: LIST
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81710: LD_ADDR_VAR 0 32
81714: PUSH
81715: LD_INT 4
81717: NEG
81718: PUSH
81719: LD_INT 0
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: PUSH
81726: LD_INT 4
81728: NEG
81729: PUSH
81730: LD_INT 1
81732: NEG
81733: PUSH
81734: EMPTY
81735: LIST
81736: LIST
81737: PUSH
81738: LD_INT 3
81740: NEG
81741: PUSH
81742: LD_INT 0
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 3
81751: NEG
81752: PUSH
81753: LD_INT 1
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: PUSH
81760: LD_INT 4
81762: NEG
81763: PUSH
81764: LD_INT 1
81766: PUSH
81767: EMPTY
81768: LIST
81769: LIST
81770: PUSH
81771: LD_INT 5
81773: NEG
81774: PUSH
81775: LD_INT 0
81777: PUSH
81778: EMPTY
81779: LIST
81780: LIST
81781: PUSH
81782: LD_INT 5
81784: NEG
81785: PUSH
81786: LD_INT 1
81788: NEG
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: PUSH
81794: LD_INT 5
81796: NEG
81797: PUSH
81798: LD_INT 2
81800: NEG
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 3
81808: NEG
81809: PUSH
81810: LD_INT 2
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 3
81819: NEG
81820: PUSH
81821: LD_INT 3
81823: NEG
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 3
81831: NEG
81832: PUSH
81833: LD_INT 4
81835: NEG
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 2
81843: NEG
81844: PUSH
81845: LD_INT 3
81847: NEG
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: LD_INT 2
81855: NEG
81856: PUSH
81857: LD_INT 2
81859: NEG
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 3
81867: NEG
81868: PUSH
81869: LD_INT 2
81871: NEG
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 4
81879: NEG
81880: PUSH
81881: LD_INT 3
81883: NEG
81884: PUSH
81885: EMPTY
81886: LIST
81887: LIST
81888: PUSH
81889: LD_INT 4
81891: NEG
81892: PUSH
81893: LD_INT 4
81895: NEG
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_INT 2
81903: NEG
81904: PUSH
81905: LD_INT 4
81907: NEG
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 4
81915: NEG
81916: PUSH
81917: LD_INT 2
81919: NEG
81920: PUSH
81921: EMPTY
81922: LIST
81923: LIST
81924: PUSH
81925: LD_INT 0
81927: PUSH
81928: LD_INT 4
81930: NEG
81931: PUSH
81932: EMPTY
81933: LIST
81934: LIST
81935: PUSH
81936: LD_INT 0
81938: PUSH
81939: LD_INT 5
81941: NEG
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 1
81949: PUSH
81950: LD_INT 4
81952: NEG
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 1
81960: PUSH
81961: LD_INT 3
81963: NEG
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 0
81971: PUSH
81972: LD_INT 3
81974: NEG
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 1
81982: NEG
81983: PUSH
81984: LD_INT 4
81986: NEG
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PUSH
81992: LD_INT 1
81994: NEG
81995: PUSH
81996: LD_INT 5
81998: NEG
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 2
82006: PUSH
82007: LD_INT 3
82009: NEG
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 2
82017: NEG
82018: PUSH
82019: LD_INT 5
82021: NEG
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 3
82029: PUSH
82030: LD_INT 0
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 3
82039: PUSH
82040: LD_INT 1
82042: NEG
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 4
82050: PUSH
82051: LD_INT 0
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 4
82060: PUSH
82061: LD_INT 1
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: LD_INT 3
82070: PUSH
82071: LD_INT 1
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 2
82080: PUSH
82081: LD_INT 0
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 2
82090: PUSH
82091: LD_INT 1
82093: NEG
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 2
82101: PUSH
82102: LD_INT 2
82104: NEG
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: LD_INT 4
82112: PUSH
82113: LD_INT 2
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 4
82122: PUSH
82123: LD_INT 4
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 4
82132: PUSH
82133: LD_INT 3
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 5
82142: PUSH
82143: LD_INT 4
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 5
82152: PUSH
82153: LD_INT 5
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 4
82162: PUSH
82163: LD_INT 5
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 3
82172: PUSH
82173: LD_INT 4
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 3
82182: PUSH
82183: LD_INT 3
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 5
82192: PUSH
82193: LD_INT 3
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 3
82202: PUSH
82203: LD_INT 5
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: LIST
82221: LIST
82222: LIST
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82257: LD_ADDR_VAR 0 33
82261: PUSH
82262: LD_INT 4
82264: NEG
82265: PUSH
82266: LD_INT 4
82268: NEG
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 4
82276: NEG
82277: PUSH
82278: LD_INT 5
82280: NEG
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 3
82288: NEG
82289: PUSH
82290: LD_INT 4
82292: NEG
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_INT 3
82300: NEG
82301: PUSH
82302: LD_INT 3
82304: NEG
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: LD_INT 4
82312: NEG
82313: PUSH
82314: LD_INT 3
82316: NEG
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PUSH
82322: LD_INT 5
82324: NEG
82325: PUSH
82326: LD_INT 4
82328: NEG
82329: PUSH
82330: EMPTY
82331: LIST
82332: LIST
82333: PUSH
82334: LD_INT 5
82336: NEG
82337: PUSH
82338: LD_INT 5
82340: NEG
82341: PUSH
82342: EMPTY
82343: LIST
82344: LIST
82345: PUSH
82346: LD_INT 3
82348: NEG
82349: PUSH
82350: LD_INT 5
82352: NEG
82353: PUSH
82354: EMPTY
82355: LIST
82356: LIST
82357: PUSH
82358: LD_INT 5
82360: NEG
82361: PUSH
82362: LD_INT 3
82364: NEG
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 0
82372: PUSH
82373: LD_INT 3
82375: NEG
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PUSH
82381: LD_INT 0
82383: PUSH
82384: LD_INT 4
82386: NEG
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 1
82394: PUSH
82395: LD_INT 3
82397: NEG
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 1
82405: PUSH
82406: LD_INT 2
82408: NEG
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 0
82416: PUSH
82417: LD_INT 2
82419: NEG
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: PUSH
82425: LD_INT 1
82427: NEG
82428: PUSH
82429: LD_INT 3
82431: NEG
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 1
82439: NEG
82440: PUSH
82441: LD_INT 4
82443: NEG
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 2
82451: PUSH
82452: LD_INT 2
82454: NEG
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 2
82462: NEG
82463: PUSH
82464: LD_INT 4
82466: NEG
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 4
82474: PUSH
82475: LD_INT 0
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 4
82484: PUSH
82485: LD_INT 1
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 5
82495: PUSH
82496: LD_INT 0
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: PUSH
82503: LD_INT 5
82505: PUSH
82506: LD_INT 1
82508: PUSH
82509: EMPTY
82510: LIST
82511: LIST
82512: PUSH
82513: LD_INT 4
82515: PUSH
82516: LD_INT 1
82518: PUSH
82519: EMPTY
82520: LIST
82521: LIST
82522: PUSH
82523: LD_INT 3
82525: PUSH
82526: LD_INT 0
82528: PUSH
82529: EMPTY
82530: LIST
82531: LIST
82532: PUSH
82533: LD_INT 3
82535: PUSH
82536: LD_INT 1
82538: NEG
82539: PUSH
82540: EMPTY
82541: LIST
82542: LIST
82543: PUSH
82544: LD_INT 3
82546: PUSH
82547: LD_INT 2
82549: NEG
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 5
82557: PUSH
82558: LD_INT 2
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 3
82567: PUSH
82568: LD_INT 3
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 3
82577: PUSH
82578: LD_INT 2
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 4
82587: PUSH
82588: LD_INT 3
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 4
82597: PUSH
82598: LD_INT 4
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: LD_INT 3
82607: PUSH
82608: LD_INT 4
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 2
82617: PUSH
82618: LD_INT 3
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 2
82627: PUSH
82628: LD_INT 2
82630: PUSH
82631: EMPTY
82632: LIST
82633: LIST
82634: PUSH
82635: LD_INT 4
82637: PUSH
82638: LD_INT 2
82640: PUSH
82641: EMPTY
82642: LIST
82643: LIST
82644: PUSH
82645: LD_INT 2
82647: PUSH
82648: LD_INT 4
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: LD_INT 0
82657: PUSH
82658: LD_INT 4
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: PUSH
82665: LD_INT 0
82667: PUSH
82668: LD_INT 3
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 1
82677: PUSH
82678: LD_INT 4
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: LD_INT 1
82687: PUSH
82688: LD_INT 5
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 0
82697: PUSH
82698: LD_INT 5
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 1
82707: NEG
82708: PUSH
82709: LD_INT 4
82711: PUSH
82712: EMPTY
82713: LIST
82714: LIST
82715: PUSH
82716: LD_INT 1
82718: NEG
82719: PUSH
82720: LD_INT 3
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 2
82729: PUSH
82730: LD_INT 5
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 2
82739: NEG
82740: PUSH
82741: LD_INT 3
82743: PUSH
82744: EMPTY
82745: LIST
82746: LIST
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: LIST
82752: LIST
82753: LIST
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: LIST
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: LIST
82771: LIST
82772: LIST
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82795: LD_ADDR_VAR 0 34
82799: PUSH
82800: LD_INT 0
82802: PUSH
82803: LD_INT 4
82805: NEG
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: LD_INT 5
82816: NEG
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 1
82824: PUSH
82825: LD_INT 4
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 1
82835: PUSH
82836: LD_INT 3
82838: NEG
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 0
82846: PUSH
82847: LD_INT 3
82849: NEG
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 1
82857: NEG
82858: PUSH
82859: LD_INT 4
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 1
82869: NEG
82870: PUSH
82871: LD_INT 5
82873: NEG
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 2
82881: PUSH
82882: LD_INT 3
82884: NEG
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 2
82892: NEG
82893: PUSH
82894: LD_INT 5
82896: NEG
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: LD_INT 3
82904: PUSH
82905: LD_INT 0
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: PUSH
82912: LD_INT 3
82914: PUSH
82915: LD_INT 1
82917: NEG
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 4
82925: PUSH
82926: LD_INT 0
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 4
82935: PUSH
82936: LD_INT 1
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: PUSH
82943: LD_INT 3
82945: PUSH
82946: LD_INT 1
82948: PUSH
82949: EMPTY
82950: LIST
82951: LIST
82952: PUSH
82953: LD_INT 2
82955: PUSH
82956: LD_INT 0
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 2
82965: PUSH
82966: LD_INT 1
82968: NEG
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 2
82976: PUSH
82977: LD_INT 2
82979: NEG
82980: PUSH
82981: EMPTY
82982: LIST
82983: LIST
82984: PUSH
82985: LD_INT 4
82987: PUSH
82988: LD_INT 2
82990: PUSH
82991: EMPTY
82992: LIST
82993: LIST
82994: PUSH
82995: LD_INT 4
82997: PUSH
82998: LD_INT 4
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: PUSH
83005: LD_INT 4
83007: PUSH
83008: LD_INT 3
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: PUSH
83015: LD_INT 5
83017: PUSH
83018: LD_INT 4
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 5
83027: PUSH
83028: LD_INT 5
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 4
83037: PUSH
83038: LD_INT 5
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 3
83047: PUSH
83048: LD_INT 4
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 3
83057: PUSH
83058: LD_INT 3
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 5
83067: PUSH
83068: LD_INT 3
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_INT 3
83077: PUSH
83078: LD_INT 5
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: PUSH
83085: LD_INT 0
83087: PUSH
83088: LD_INT 3
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: PUSH
83095: LD_INT 0
83097: PUSH
83098: LD_INT 2
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: PUSH
83105: LD_INT 1
83107: PUSH
83108: LD_INT 3
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: LD_INT 1
83117: PUSH
83118: LD_INT 4
83120: PUSH
83121: EMPTY
83122: LIST
83123: LIST
83124: PUSH
83125: LD_INT 0
83127: PUSH
83128: LD_INT 4
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: LD_INT 1
83137: NEG
83138: PUSH
83139: LD_INT 3
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 1
83148: NEG
83149: PUSH
83150: LD_INT 2
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 2
83159: PUSH
83160: LD_INT 4
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PUSH
83167: LD_INT 2
83169: NEG
83170: PUSH
83171: LD_INT 2
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 4
83180: NEG
83181: PUSH
83182: LD_INT 0
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: LD_INT 4
83191: NEG
83192: PUSH
83193: LD_INT 1
83195: NEG
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 3
83203: NEG
83204: PUSH
83205: LD_INT 0
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 3
83214: NEG
83215: PUSH
83216: LD_INT 1
83218: PUSH
83219: EMPTY
83220: LIST
83221: LIST
83222: PUSH
83223: LD_INT 4
83225: NEG
83226: PUSH
83227: LD_INT 1
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 5
83236: NEG
83237: PUSH
83238: LD_INT 0
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 5
83247: NEG
83248: PUSH
83249: LD_INT 1
83251: NEG
83252: PUSH
83253: EMPTY
83254: LIST
83255: LIST
83256: PUSH
83257: LD_INT 5
83259: NEG
83260: PUSH
83261: LD_INT 2
83263: NEG
83264: PUSH
83265: EMPTY
83266: LIST
83267: LIST
83268: PUSH
83269: LD_INT 3
83271: NEG
83272: PUSH
83273: LD_INT 2
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: LIST
83303: LIST
83304: LIST
83305: LIST
83306: LIST
83307: LIST
83308: LIST
83309: LIST
83310: LIST
83311: LIST
83312: LIST
83313: LIST
83314: LIST
83315: LIST
83316: LIST
83317: LIST
83318: LIST
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: ST_TO_ADDR
// end ; end ;
83327: GO 83330
83329: POP
// case btype of b_depot , b_warehouse :
83330: LD_VAR 0 1
83334: PUSH
83335: LD_INT 0
83337: DOUBLE
83338: EQUAL
83339: IFTRUE 83349
83341: LD_INT 1
83343: DOUBLE
83344: EQUAL
83345: IFTRUE 83349
83347: GO 83550
83349: POP
// case nation of nation_american :
83350: LD_VAR 0 5
83354: PUSH
83355: LD_INT 1
83357: DOUBLE
83358: EQUAL
83359: IFTRUE 83363
83361: GO 83419
83363: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
83364: LD_ADDR_VAR 0 9
83368: PUSH
83369: LD_VAR 0 11
83373: PUSH
83374: LD_VAR 0 12
83378: PUSH
83379: LD_VAR 0 13
83383: PUSH
83384: LD_VAR 0 14
83388: PUSH
83389: LD_VAR 0 15
83393: PUSH
83394: LD_VAR 0 16
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: LIST
83406: PUSH
83407: LD_VAR 0 4
83411: PUSH
83412: LD_INT 1
83414: PLUS
83415: ARRAY
83416: ST_TO_ADDR
83417: GO 83548
83419: LD_INT 2
83421: DOUBLE
83422: EQUAL
83423: IFTRUE 83427
83425: GO 83483
83427: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83428: LD_ADDR_VAR 0 9
83432: PUSH
83433: LD_VAR 0 17
83437: PUSH
83438: LD_VAR 0 18
83442: PUSH
83443: LD_VAR 0 19
83447: PUSH
83448: LD_VAR 0 20
83452: PUSH
83453: LD_VAR 0 21
83457: PUSH
83458: LD_VAR 0 22
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: PUSH
83471: LD_VAR 0 4
83475: PUSH
83476: LD_INT 1
83478: PLUS
83479: ARRAY
83480: ST_TO_ADDR
83481: GO 83548
83483: LD_INT 3
83485: DOUBLE
83486: EQUAL
83487: IFTRUE 83491
83489: GO 83547
83491: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83492: LD_ADDR_VAR 0 9
83496: PUSH
83497: LD_VAR 0 23
83501: PUSH
83502: LD_VAR 0 24
83506: PUSH
83507: LD_VAR 0 25
83511: PUSH
83512: LD_VAR 0 26
83516: PUSH
83517: LD_VAR 0 27
83521: PUSH
83522: LD_VAR 0 28
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: PUSH
83535: LD_VAR 0 4
83539: PUSH
83540: LD_INT 1
83542: PLUS
83543: ARRAY
83544: ST_TO_ADDR
83545: GO 83548
83547: POP
83548: GO 84103
83550: LD_INT 2
83552: DOUBLE
83553: EQUAL
83554: IFTRUE 83564
83556: LD_INT 3
83558: DOUBLE
83559: EQUAL
83560: IFTRUE 83564
83562: GO 83620
83564: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83565: LD_ADDR_VAR 0 9
83569: PUSH
83570: LD_VAR 0 29
83574: PUSH
83575: LD_VAR 0 30
83579: PUSH
83580: LD_VAR 0 31
83584: PUSH
83585: LD_VAR 0 32
83589: PUSH
83590: LD_VAR 0 33
83594: PUSH
83595: LD_VAR 0 34
83599: PUSH
83600: EMPTY
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: PUSH
83608: LD_VAR 0 4
83612: PUSH
83613: LD_INT 1
83615: PLUS
83616: ARRAY
83617: ST_TO_ADDR
83618: GO 84103
83620: LD_INT 16
83622: DOUBLE
83623: EQUAL
83624: IFTRUE 83682
83626: LD_INT 17
83628: DOUBLE
83629: EQUAL
83630: IFTRUE 83682
83632: LD_INT 18
83634: DOUBLE
83635: EQUAL
83636: IFTRUE 83682
83638: LD_INT 19
83640: DOUBLE
83641: EQUAL
83642: IFTRUE 83682
83644: LD_INT 22
83646: DOUBLE
83647: EQUAL
83648: IFTRUE 83682
83650: LD_INT 20
83652: DOUBLE
83653: EQUAL
83654: IFTRUE 83682
83656: LD_INT 21
83658: DOUBLE
83659: EQUAL
83660: IFTRUE 83682
83662: LD_INT 23
83664: DOUBLE
83665: EQUAL
83666: IFTRUE 83682
83668: LD_INT 24
83670: DOUBLE
83671: EQUAL
83672: IFTRUE 83682
83674: LD_INT 25
83676: DOUBLE
83677: EQUAL
83678: IFTRUE 83682
83680: GO 83738
83682: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83683: LD_ADDR_VAR 0 9
83687: PUSH
83688: LD_VAR 0 35
83692: PUSH
83693: LD_VAR 0 36
83697: PUSH
83698: LD_VAR 0 37
83702: PUSH
83703: LD_VAR 0 38
83707: PUSH
83708: LD_VAR 0 39
83712: PUSH
83713: LD_VAR 0 40
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: PUSH
83726: LD_VAR 0 4
83730: PUSH
83731: LD_INT 1
83733: PLUS
83734: ARRAY
83735: ST_TO_ADDR
83736: GO 84103
83738: LD_INT 6
83740: DOUBLE
83741: EQUAL
83742: IFTRUE 83794
83744: LD_INT 7
83746: DOUBLE
83747: EQUAL
83748: IFTRUE 83794
83750: LD_INT 8
83752: DOUBLE
83753: EQUAL
83754: IFTRUE 83794
83756: LD_INT 13
83758: DOUBLE
83759: EQUAL
83760: IFTRUE 83794
83762: LD_INT 12
83764: DOUBLE
83765: EQUAL
83766: IFTRUE 83794
83768: LD_INT 15
83770: DOUBLE
83771: EQUAL
83772: IFTRUE 83794
83774: LD_INT 11
83776: DOUBLE
83777: EQUAL
83778: IFTRUE 83794
83780: LD_INT 14
83782: DOUBLE
83783: EQUAL
83784: IFTRUE 83794
83786: LD_INT 10
83788: DOUBLE
83789: EQUAL
83790: IFTRUE 83794
83792: GO 83850
83794: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
83795: LD_ADDR_VAR 0 9
83799: PUSH
83800: LD_VAR 0 41
83804: PUSH
83805: LD_VAR 0 42
83809: PUSH
83810: LD_VAR 0 43
83814: PUSH
83815: LD_VAR 0 44
83819: PUSH
83820: LD_VAR 0 45
83824: PUSH
83825: LD_VAR 0 46
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: PUSH
83838: LD_VAR 0 4
83842: PUSH
83843: LD_INT 1
83845: PLUS
83846: ARRAY
83847: ST_TO_ADDR
83848: GO 84103
83850: LD_INT 36
83852: DOUBLE
83853: EQUAL
83854: IFTRUE 83858
83856: GO 83914
83858: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83859: LD_ADDR_VAR 0 9
83863: PUSH
83864: LD_VAR 0 47
83868: PUSH
83869: LD_VAR 0 48
83873: PUSH
83874: LD_VAR 0 49
83878: PUSH
83879: LD_VAR 0 50
83883: PUSH
83884: LD_VAR 0 51
83888: PUSH
83889: LD_VAR 0 52
83893: PUSH
83894: EMPTY
83895: LIST
83896: LIST
83897: LIST
83898: LIST
83899: LIST
83900: LIST
83901: PUSH
83902: LD_VAR 0 4
83906: PUSH
83907: LD_INT 1
83909: PLUS
83910: ARRAY
83911: ST_TO_ADDR
83912: GO 84103
83914: LD_INT 4
83916: DOUBLE
83917: EQUAL
83918: IFTRUE 83940
83920: LD_INT 5
83922: DOUBLE
83923: EQUAL
83924: IFTRUE 83940
83926: LD_INT 34
83928: DOUBLE
83929: EQUAL
83930: IFTRUE 83940
83932: LD_INT 37
83934: DOUBLE
83935: EQUAL
83936: IFTRUE 83940
83938: GO 83996
83940: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83941: LD_ADDR_VAR 0 9
83945: PUSH
83946: LD_VAR 0 53
83950: PUSH
83951: LD_VAR 0 54
83955: PUSH
83956: LD_VAR 0 55
83960: PUSH
83961: LD_VAR 0 56
83965: PUSH
83966: LD_VAR 0 57
83970: PUSH
83971: LD_VAR 0 58
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: LIST
83980: LIST
83981: LIST
83982: LIST
83983: PUSH
83984: LD_VAR 0 4
83988: PUSH
83989: LD_INT 1
83991: PLUS
83992: ARRAY
83993: ST_TO_ADDR
83994: GO 84103
83996: LD_INT 31
83998: DOUBLE
83999: EQUAL
84000: IFTRUE 84046
84002: LD_INT 32
84004: DOUBLE
84005: EQUAL
84006: IFTRUE 84046
84008: LD_INT 33
84010: DOUBLE
84011: EQUAL
84012: IFTRUE 84046
84014: LD_INT 27
84016: DOUBLE
84017: EQUAL
84018: IFTRUE 84046
84020: LD_INT 26
84022: DOUBLE
84023: EQUAL
84024: IFTRUE 84046
84026: LD_INT 28
84028: DOUBLE
84029: EQUAL
84030: IFTRUE 84046
84032: LD_INT 29
84034: DOUBLE
84035: EQUAL
84036: IFTRUE 84046
84038: LD_INT 30
84040: DOUBLE
84041: EQUAL
84042: IFTRUE 84046
84044: GO 84102
84046: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
84047: LD_ADDR_VAR 0 9
84051: PUSH
84052: LD_VAR 0 59
84056: PUSH
84057: LD_VAR 0 60
84061: PUSH
84062: LD_VAR 0 61
84066: PUSH
84067: LD_VAR 0 62
84071: PUSH
84072: LD_VAR 0 63
84076: PUSH
84077: LD_VAR 0 64
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: PUSH
84090: LD_VAR 0 4
84094: PUSH
84095: LD_INT 1
84097: PLUS
84098: ARRAY
84099: ST_TO_ADDR
84100: GO 84103
84102: POP
// temp_list2 = [ ] ;
84103: LD_ADDR_VAR 0 10
84107: PUSH
84108: EMPTY
84109: ST_TO_ADDR
// for i in temp_list do
84110: LD_ADDR_VAR 0 8
84114: PUSH
84115: LD_VAR 0 9
84119: PUSH
84120: FOR_IN
84121: IFFALSE 84173
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84123: LD_ADDR_VAR 0 10
84127: PUSH
84128: LD_VAR 0 10
84132: PUSH
84133: LD_VAR 0 8
84137: PUSH
84138: LD_INT 1
84140: ARRAY
84141: PUSH
84142: LD_VAR 0 2
84146: PLUS
84147: PUSH
84148: LD_VAR 0 8
84152: PUSH
84153: LD_INT 2
84155: ARRAY
84156: PUSH
84157: LD_VAR 0 3
84161: PLUS
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: EMPTY
84168: LIST
84169: ADD
84170: ST_TO_ADDR
84171: GO 84120
84173: POP
84174: POP
// result = temp_list2 ;
84175: LD_ADDR_VAR 0 7
84179: PUSH
84180: LD_VAR 0 10
84184: ST_TO_ADDR
// end ;
84185: LD_VAR 0 7
84189: RET
// export function EnemyInRange ( unit , dist ) ; begin
84190: LD_INT 0
84192: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84193: LD_ADDR_VAR 0 3
84197: PUSH
84198: LD_VAR 0 1
84202: PPUSH
84203: CALL_OW 255
84207: PPUSH
84208: LD_VAR 0 1
84212: PPUSH
84213: CALL_OW 250
84217: PPUSH
84218: LD_VAR 0 1
84222: PPUSH
84223: CALL_OW 251
84227: PPUSH
84228: LD_VAR 0 2
84232: PPUSH
84233: CALL 58294 0 4
84237: PUSH
84238: LD_INT 4
84240: ARRAY
84241: ST_TO_ADDR
// end ;
84242: LD_VAR 0 3
84246: RET
// export function PlayerSeeMe ( unit ) ; begin
84247: LD_INT 0
84249: PPUSH
// result := See ( your_side , unit ) ;
84250: LD_ADDR_VAR 0 2
84254: PUSH
84255: LD_OWVAR 2
84259: PPUSH
84260: LD_VAR 0 1
84264: PPUSH
84265: CALL_OW 292
84269: ST_TO_ADDR
// end ;
84270: LD_VAR 0 2
84274: RET
// export function ReverseDir ( unit ) ; begin
84275: LD_INT 0
84277: PPUSH
// if not unit then
84278: LD_VAR 0 1
84282: NOT
84283: IFFALSE 84287
// exit ;
84285: GO 84333
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
84287: LD_ADDR_VAR 0 2
84291: PUSH
84292: LD_INT 3
84294: PUSH
84295: LD_INT 4
84297: PUSH
84298: LD_INT 5
84300: PUSH
84301: LD_INT 0
84303: PUSH
84304: LD_INT 1
84306: PUSH
84307: LD_INT 2
84309: PUSH
84310: EMPTY
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: PUSH
84318: LD_VAR 0 1
84322: PPUSH
84323: CALL_OW 254
84327: PUSH
84328: LD_INT 1
84330: PLUS
84331: ARRAY
84332: ST_TO_ADDR
// end ;
84333: LD_VAR 0 2
84337: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84338: LD_INT 0
84340: PPUSH
84341: PPUSH
84342: PPUSH
84343: PPUSH
84344: PPUSH
// if not hexes then
84345: LD_VAR 0 2
84349: NOT
84350: IFFALSE 84354
// exit ;
84352: GO 84502
// dist := 9999 ;
84354: LD_ADDR_VAR 0 5
84358: PUSH
84359: LD_INT 9999
84361: ST_TO_ADDR
// for i = 1 to hexes do
84362: LD_ADDR_VAR 0 4
84366: PUSH
84367: DOUBLE
84368: LD_INT 1
84370: DEC
84371: ST_TO_ADDR
84372: LD_VAR 0 2
84376: PUSH
84377: FOR_TO
84378: IFFALSE 84490
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84380: LD_VAR 0 1
84384: PPUSH
84385: LD_VAR 0 2
84389: PUSH
84390: LD_VAR 0 4
84394: ARRAY
84395: PUSH
84396: LD_INT 1
84398: ARRAY
84399: PPUSH
84400: LD_VAR 0 2
84404: PUSH
84405: LD_VAR 0 4
84409: ARRAY
84410: PUSH
84411: LD_INT 2
84413: ARRAY
84414: PPUSH
84415: CALL_OW 297
84419: PUSH
84420: LD_VAR 0 5
84424: LESS
84425: IFFALSE 84488
// begin hex := hexes [ i ] ;
84427: LD_ADDR_VAR 0 7
84431: PUSH
84432: LD_VAR 0 2
84436: PUSH
84437: LD_VAR 0 4
84441: ARRAY
84442: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84443: LD_ADDR_VAR 0 5
84447: PUSH
84448: LD_VAR 0 1
84452: PPUSH
84453: LD_VAR 0 2
84457: PUSH
84458: LD_VAR 0 4
84462: ARRAY
84463: PUSH
84464: LD_INT 1
84466: ARRAY
84467: PPUSH
84468: LD_VAR 0 2
84472: PUSH
84473: LD_VAR 0 4
84477: ARRAY
84478: PUSH
84479: LD_INT 2
84481: ARRAY
84482: PPUSH
84483: CALL_OW 297
84487: ST_TO_ADDR
// end ; end ;
84488: GO 84377
84490: POP
84491: POP
// result := hex ;
84492: LD_ADDR_VAR 0 3
84496: PUSH
84497: LD_VAR 0 7
84501: ST_TO_ADDR
// end ;
84502: LD_VAR 0 3
84506: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84507: LD_INT 0
84509: PPUSH
84510: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84511: LD_VAR 0 1
84515: NOT
84516: PUSH
84517: LD_VAR 0 1
84521: PUSH
84522: LD_INT 21
84524: PUSH
84525: LD_INT 2
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: PUSH
84532: LD_INT 23
84534: PUSH
84535: LD_INT 2
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PPUSH
84546: CALL_OW 69
84550: IN
84551: NOT
84552: OR
84553: IFFALSE 84557
// exit ;
84555: GO 84604
// for i = 1 to 3 do
84557: LD_ADDR_VAR 0 3
84561: PUSH
84562: DOUBLE
84563: LD_INT 1
84565: DEC
84566: ST_TO_ADDR
84567: LD_INT 3
84569: PUSH
84570: FOR_TO
84571: IFFALSE 84602
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84573: LD_VAR 0 1
84577: PPUSH
84578: CALL_OW 250
84582: PPUSH
84583: LD_VAR 0 1
84587: PPUSH
84588: CALL_OW 251
84592: PPUSH
84593: LD_INT 1
84595: PPUSH
84596: CALL_OW 453
84600: GO 84570
84602: POP
84603: POP
// end ;
84604: LD_VAR 0 2
84608: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84609: LD_INT 0
84611: PPUSH
84612: PPUSH
84613: PPUSH
84614: PPUSH
84615: PPUSH
84616: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84617: LD_VAR 0 1
84621: NOT
84622: PUSH
84623: LD_VAR 0 2
84627: NOT
84628: OR
84629: PUSH
84630: LD_VAR 0 1
84634: PPUSH
84635: CALL_OW 314
84639: OR
84640: IFFALSE 84644
// exit ;
84642: GO 85085
// x := GetX ( enemy_unit ) ;
84644: LD_ADDR_VAR 0 7
84648: PUSH
84649: LD_VAR 0 2
84653: PPUSH
84654: CALL_OW 250
84658: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84659: LD_ADDR_VAR 0 8
84663: PUSH
84664: LD_VAR 0 2
84668: PPUSH
84669: CALL_OW 251
84673: ST_TO_ADDR
// if not x or not y then
84674: LD_VAR 0 7
84678: NOT
84679: PUSH
84680: LD_VAR 0 8
84684: NOT
84685: OR
84686: IFFALSE 84690
// exit ;
84688: GO 85085
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84690: LD_ADDR_VAR 0 6
84694: PUSH
84695: LD_VAR 0 7
84699: PPUSH
84700: LD_INT 0
84702: PPUSH
84703: LD_INT 4
84705: PPUSH
84706: CALL_OW 272
84710: PUSH
84711: LD_VAR 0 8
84715: PPUSH
84716: LD_INT 0
84718: PPUSH
84719: LD_INT 4
84721: PPUSH
84722: CALL_OW 273
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_VAR 0 7
84735: PPUSH
84736: LD_INT 1
84738: PPUSH
84739: LD_INT 4
84741: PPUSH
84742: CALL_OW 272
84746: PUSH
84747: LD_VAR 0 8
84751: PPUSH
84752: LD_INT 1
84754: PPUSH
84755: LD_INT 4
84757: PPUSH
84758: CALL_OW 273
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_VAR 0 7
84771: PPUSH
84772: LD_INT 2
84774: PPUSH
84775: LD_INT 4
84777: PPUSH
84778: CALL_OW 272
84782: PUSH
84783: LD_VAR 0 8
84787: PPUSH
84788: LD_INT 2
84790: PPUSH
84791: LD_INT 4
84793: PPUSH
84794: CALL_OW 273
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_VAR 0 7
84807: PPUSH
84808: LD_INT 3
84810: PPUSH
84811: LD_INT 4
84813: PPUSH
84814: CALL_OW 272
84818: PUSH
84819: LD_VAR 0 8
84823: PPUSH
84824: LD_INT 3
84826: PPUSH
84827: LD_INT 4
84829: PPUSH
84830: CALL_OW 273
84834: PUSH
84835: EMPTY
84836: LIST
84837: LIST
84838: PUSH
84839: LD_VAR 0 7
84843: PPUSH
84844: LD_INT 4
84846: PPUSH
84847: LD_INT 4
84849: PPUSH
84850: CALL_OW 272
84854: PUSH
84855: LD_VAR 0 8
84859: PPUSH
84860: LD_INT 4
84862: PPUSH
84863: LD_INT 4
84865: PPUSH
84866: CALL_OW 273
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_VAR 0 7
84879: PPUSH
84880: LD_INT 5
84882: PPUSH
84883: LD_INT 4
84885: PPUSH
84886: CALL_OW 272
84890: PUSH
84891: LD_VAR 0 8
84895: PPUSH
84896: LD_INT 5
84898: PPUSH
84899: LD_INT 4
84901: PPUSH
84902: CALL_OW 273
84906: PUSH
84907: EMPTY
84908: LIST
84909: LIST
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: LIST
84915: LIST
84916: LIST
84917: LIST
84918: ST_TO_ADDR
// for i = tmp downto 1 do
84919: LD_ADDR_VAR 0 4
84923: PUSH
84924: DOUBLE
84925: LD_VAR 0 6
84929: INC
84930: ST_TO_ADDR
84931: LD_INT 1
84933: PUSH
84934: FOR_DOWNTO
84935: IFFALSE 85036
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84937: LD_VAR 0 6
84941: PUSH
84942: LD_VAR 0 4
84946: ARRAY
84947: PUSH
84948: LD_INT 1
84950: ARRAY
84951: PPUSH
84952: LD_VAR 0 6
84956: PUSH
84957: LD_VAR 0 4
84961: ARRAY
84962: PUSH
84963: LD_INT 2
84965: ARRAY
84966: PPUSH
84967: CALL_OW 488
84971: NOT
84972: PUSH
84973: LD_VAR 0 6
84977: PUSH
84978: LD_VAR 0 4
84982: ARRAY
84983: PUSH
84984: LD_INT 1
84986: ARRAY
84987: PPUSH
84988: LD_VAR 0 6
84992: PUSH
84993: LD_VAR 0 4
84997: ARRAY
84998: PUSH
84999: LD_INT 2
85001: ARRAY
85002: PPUSH
85003: CALL_OW 428
85007: PUSH
85008: LD_INT 0
85010: NONEQUAL
85011: OR
85012: IFFALSE 85034
// tmp := Delete ( tmp , i ) ;
85014: LD_ADDR_VAR 0 6
85018: PUSH
85019: LD_VAR 0 6
85023: PPUSH
85024: LD_VAR 0 4
85028: PPUSH
85029: CALL_OW 3
85033: ST_TO_ADDR
85034: GO 84934
85036: POP
85037: POP
// j := GetClosestHex ( unit , tmp ) ;
85038: LD_ADDR_VAR 0 5
85042: PUSH
85043: LD_VAR 0 1
85047: PPUSH
85048: LD_VAR 0 6
85052: PPUSH
85053: CALL 84338 0 2
85057: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85058: LD_VAR 0 1
85062: PPUSH
85063: LD_VAR 0 5
85067: PUSH
85068: LD_INT 1
85070: ARRAY
85071: PPUSH
85072: LD_VAR 0 5
85076: PUSH
85077: LD_INT 2
85079: ARRAY
85080: PPUSH
85081: CALL_OW 111
// end ;
85085: LD_VAR 0 3
85089: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85090: LD_INT 0
85092: PPUSH
85093: PPUSH
85094: PPUSH
// uc_side = 0 ;
85095: LD_ADDR_OWVAR 20
85099: PUSH
85100: LD_INT 0
85102: ST_TO_ADDR
// uc_nation = 0 ;
85103: LD_ADDR_OWVAR 21
85107: PUSH
85108: LD_INT 0
85110: ST_TO_ADDR
// InitHc ;
85111: CALL_OW 19
// InitVc ;
85115: CALL_OW 20
// if mastodonts then
85119: LD_VAR 0 6
85123: IFFALSE 85190
// for i = 1 to mastodonts do
85125: LD_ADDR_VAR 0 11
85129: PUSH
85130: DOUBLE
85131: LD_INT 1
85133: DEC
85134: ST_TO_ADDR
85135: LD_VAR 0 6
85139: PUSH
85140: FOR_TO
85141: IFFALSE 85188
// begin vc_chassis := 31 ;
85143: LD_ADDR_OWVAR 37
85147: PUSH
85148: LD_INT 31
85150: ST_TO_ADDR
// vc_control := control_rider ;
85151: LD_ADDR_OWVAR 38
85155: PUSH
85156: LD_INT 4
85158: ST_TO_ADDR
// animal := CreateVehicle ;
85159: LD_ADDR_VAR 0 12
85163: PUSH
85164: CALL_OW 45
85168: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85169: LD_VAR 0 12
85173: PPUSH
85174: LD_VAR 0 8
85178: PPUSH
85179: LD_INT 0
85181: PPUSH
85182: CALL 91935 0 3
// end ;
85186: GO 85140
85188: POP
85189: POP
// if horses then
85190: LD_VAR 0 5
85194: IFFALSE 85261
// for i = 1 to horses do
85196: LD_ADDR_VAR 0 11
85200: PUSH
85201: DOUBLE
85202: LD_INT 1
85204: DEC
85205: ST_TO_ADDR
85206: LD_VAR 0 5
85210: PUSH
85211: FOR_TO
85212: IFFALSE 85259
// begin hc_class := 21 ;
85214: LD_ADDR_OWVAR 28
85218: PUSH
85219: LD_INT 21
85221: ST_TO_ADDR
// hc_gallery :=  ;
85222: LD_ADDR_OWVAR 33
85226: PUSH
85227: LD_STRING 
85229: ST_TO_ADDR
// animal := CreateHuman ;
85230: LD_ADDR_VAR 0 12
85234: PUSH
85235: CALL_OW 44
85239: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85240: LD_VAR 0 12
85244: PPUSH
85245: LD_VAR 0 8
85249: PPUSH
85250: LD_INT 0
85252: PPUSH
85253: CALL 91935 0 3
// end ;
85257: GO 85211
85259: POP
85260: POP
// if birds then
85261: LD_VAR 0 1
85265: IFFALSE 85332
// for i = 1 to birds do
85267: LD_ADDR_VAR 0 11
85271: PUSH
85272: DOUBLE
85273: LD_INT 1
85275: DEC
85276: ST_TO_ADDR
85277: LD_VAR 0 1
85281: PUSH
85282: FOR_TO
85283: IFFALSE 85330
// begin hc_class = 18 ;
85285: LD_ADDR_OWVAR 28
85289: PUSH
85290: LD_INT 18
85292: ST_TO_ADDR
// hc_gallery =  ;
85293: LD_ADDR_OWVAR 33
85297: PUSH
85298: LD_STRING 
85300: ST_TO_ADDR
// animal := CreateHuman ;
85301: LD_ADDR_VAR 0 12
85305: PUSH
85306: CALL_OW 44
85310: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85311: LD_VAR 0 12
85315: PPUSH
85316: LD_VAR 0 8
85320: PPUSH
85321: LD_INT 0
85323: PPUSH
85324: CALL 91935 0 3
// end ;
85328: GO 85282
85330: POP
85331: POP
// if tigers then
85332: LD_VAR 0 2
85336: IFFALSE 85420
// for i = 1 to tigers do
85338: LD_ADDR_VAR 0 11
85342: PUSH
85343: DOUBLE
85344: LD_INT 1
85346: DEC
85347: ST_TO_ADDR
85348: LD_VAR 0 2
85352: PUSH
85353: FOR_TO
85354: IFFALSE 85418
// begin hc_class = class_tiger ;
85356: LD_ADDR_OWVAR 28
85360: PUSH
85361: LD_INT 14
85363: ST_TO_ADDR
// hc_gallery =  ;
85364: LD_ADDR_OWVAR 33
85368: PUSH
85369: LD_STRING 
85371: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85372: LD_ADDR_OWVAR 35
85376: PUSH
85377: LD_INT 7
85379: NEG
85380: PPUSH
85381: LD_INT 7
85383: PPUSH
85384: CALL_OW 12
85388: ST_TO_ADDR
// animal := CreateHuman ;
85389: LD_ADDR_VAR 0 12
85393: PUSH
85394: CALL_OW 44
85398: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85399: LD_VAR 0 12
85403: PPUSH
85404: LD_VAR 0 8
85408: PPUSH
85409: LD_INT 0
85411: PPUSH
85412: CALL 91935 0 3
// end ;
85416: GO 85353
85418: POP
85419: POP
// if apemans then
85420: LD_VAR 0 3
85424: IFFALSE 85547
// for i = 1 to apemans do
85426: LD_ADDR_VAR 0 11
85430: PUSH
85431: DOUBLE
85432: LD_INT 1
85434: DEC
85435: ST_TO_ADDR
85436: LD_VAR 0 3
85440: PUSH
85441: FOR_TO
85442: IFFALSE 85545
// begin hc_class = class_apeman ;
85444: LD_ADDR_OWVAR 28
85448: PUSH
85449: LD_INT 12
85451: ST_TO_ADDR
// hc_gallery =  ;
85452: LD_ADDR_OWVAR 33
85456: PUSH
85457: LD_STRING 
85459: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85460: LD_ADDR_OWVAR 35
85464: PUSH
85465: LD_INT 5
85467: NEG
85468: PPUSH
85469: LD_INT 5
85471: PPUSH
85472: CALL_OW 12
85476: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85477: LD_ADDR_OWVAR 31
85481: PUSH
85482: LD_INT 1
85484: PPUSH
85485: LD_INT 3
85487: PPUSH
85488: CALL_OW 12
85492: PUSH
85493: LD_INT 1
85495: PPUSH
85496: LD_INT 3
85498: PPUSH
85499: CALL_OW 12
85503: PUSH
85504: LD_INT 0
85506: PUSH
85507: LD_INT 0
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: ST_TO_ADDR
// animal := CreateHuman ;
85516: LD_ADDR_VAR 0 12
85520: PUSH
85521: CALL_OW 44
85525: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85526: LD_VAR 0 12
85530: PPUSH
85531: LD_VAR 0 8
85535: PPUSH
85536: LD_INT 0
85538: PPUSH
85539: CALL 91935 0 3
// end ;
85543: GO 85441
85545: POP
85546: POP
// if enchidnas then
85547: LD_VAR 0 4
85551: IFFALSE 85618
// for i = 1 to enchidnas do
85553: LD_ADDR_VAR 0 11
85557: PUSH
85558: DOUBLE
85559: LD_INT 1
85561: DEC
85562: ST_TO_ADDR
85563: LD_VAR 0 4
85567: PUSH
85568: FOR_TO
85569: IFFALSE 85616
// begin hc_class = 13 ;
85571: LD_ADDR_OWVAR 28
85575: PUSH
85576: LD_INT 13
85578: ST_TO_ADDR
// hc_gallery =  ;
85579: LD_ADDR_OWVAR 33
85583: PUSH
85584: LD_STRING 
85586: ST_TO_ADDR
// animal := CreateHuman ;
85587: LD_ADDR_VAR 0 12
85591: PUSH
85592: CALL_OW 44
85596: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85597: LD_VAR 0 12
85601: PPUSH
85602: LD_VAR 0 8
85606: PPUSH
85607: LD_INT 0
85609: PPUSH
85610: CALL 91935 0 3
// end ;
85614: GO 85568
85616: POP
85617: POP
// if fishes then
85618: LD_VAR 0 7
85622: IFFALSE 85689
// for i = 1 to fishes do
85624: LD_ADDR_VAR 0 11
85628: PUSH
85629: DOUBLE
85630: LD_INT 1
85632: DEC
85633: ST_TO_ADDR
85634: LD_VAR 0 7
85638: PUSH
85639: FOR_TO
85640: IFFALSE 85687
// begin hc_class = 20 ;
85642: LD_ADDR_OWVAR 28
85646: PUSH
85647: LD_INT 20
85649: ST_TO_ADDR
// hc_gallery =  ;
85650: LD_ADDR_OWVAR 33
85654: PUSH
85655: LD_STRING 
85657: ST_TO_ADDR
// animal := CreateHuman ;
85658: LD_ADDR_VAR 0 12
85662: PUSH
85663: CALL_OW 44
85667: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85668: LD_VAR 0 12
85672: PPUSH
85673: LD_VAR 0 9
85677: PPUSH
85678: LD_INT 0
85680: PPUSH
85681: CALL 91935 0 3
// end ;
85685: GO 85639
85687: POP
85688: POP
// end ;
85689: LD_VAR 0 10
85693: RET
// export function WantHeal ( sci , unit ) ; begin
85694: LD_INT 0
85696: PPUSH
// if GetTaskList ( sci ) > 0 then
85697: LD_VAR 0 1
85701: PPUSH
85702: CALL_OW 437
85706: PUSH
85707: LD_INT 0
85709: GREATER
85710: IFFALSE 85780
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85712: LD_VAR 0 1
85716: PPUSH
85717: CALL_OW 437
85721: PUSH
85722: LD_INT 1
85724: ARRAY
85725: PUSH
85726: LD_INT 1
85728: ARRAY
85729: PUSH
85730: LD_STRING l
85732: EQUAL
85733: PUSH
85734: LD_VAR 0 1
85738: PPUSH
85739: CALL_OW 437
85743: PUSH
85744: LD_INT 1
85746: ARRAY
85747: PUSH
85748: LD_INT 4
85750: ARRAY
85751: PUSH
85752: LD_VAR 0 2
85756: EQUAL
85757: AND
85758: IFFALSE 85770
// result := true else
85760: LD_ADDR_VAR 0 3
85764: PUSH
85765: LD_INT 1
85767: ST_TO_ADDR
85768: GO 85778
// result := false ;
85770: LD_ADDR_VAR 0 3
85774: PUSH
85775: LD_INT 0
85777: ST_TO_ADDR
// end else
85778: GO 85788
// result := false ;
85780: LD_ADDR_VAR 0 3
85784: PUSH
85785: LD_INT 0
85787: ST_TO_ADDR
// end ;
85788: LD_VAR 0 3
85792: RET
// export function HealTarget ( sci ) ; begin
85793: LD_INT 0
85795: PPUSH
// if not sci then
85796: LD_VAR 0 1
85800: NOT
85801: IFFALSE 85805
// exit ;
85803: GO 85870
// result := 0 ;
85805: LD_ADDR_VAR 0 2
85809: PUSH
85810: LD_INT 0
85812: ST_TO_ADDR
// if GetTaskList ( sci ) then
85813: LD_VAR 0 1
85817: PPUSH
85818: CALL_OW 437
85822: IFFALSE 85870
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85824: LD_VAR 0 1
85828: PPUSH
85829: CALL_OW 437
85833: PUSH
85834: LD_INT 1
85836: ARRAY
85837: PUSH
85838: LD_INT 1
85840: ARRAY
85841: PUSH
85842: LD_STRING l
85844: EQUAL
85845: IFFALSE 85870
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85847: LD_ADDR_VAR 0 2
85851: PUSH
85852: LD_VAR 0 1
85856: PPUSH
85857: CALL_OW 437
85861: PUSH
85862: LD_INT 1
85864: ARRAY
85865: PUSH
85866: LD_INT 4
85868: ARRAY
85869: ST_TO_ADDR
// end ;
85870: LD_VAR 0 2
85874: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
85875: LD_INT 0
85877: PPUSH
85878: PPUSH
85879: PPUSH
85880: PPUSH
85881: PPUSH
85882: PPUSH
85883: PPUSH
85884: PPUSH
85885: PPUSH
85886: PPUSH
85887: PPUSH
85888: PPUSH
85889: PPUSH
85890: PPUSH
85891: PPUSH
85892: PPUSH
85893: PPUSH
85894: PPUSH
85895: PPUSH
85896: PPUSH
85897: PPUSH
85898: PPUSH
85899: PPUSH
85900: PPUSH
85901: PPUSH
85902: PPUSH
85903: PPUSH
85904: PPUSH
85905: PPUSH
85906: PPUSH
85907: PPUSH
85908: PPUSH
85909: PPUSH
85910: PPUSH
// if not list then
85911: LD_VAR 0 1
85915: NOT
85916: IFFALSE 85920
// exit ;
85918: GO 90546
// base := list [ 1 ] ;
85920: LD_ADDR_VAR 0 3
85924: PUSH
85925: LD_VAR 0 1
85929: PUSH
85930: LD_INT 1
85932: ARRAY
85933: ST_TO_ADDR
// group := list [ 2 ] ;
85934: LD_ADDR_VAR 0 4
85938: PUSH
85939: LD_VAR 0 1
85943: PUSH
85944: LD_INT 2
85946: ARRAY
85947: ST_TO_ADDR
// path := list [ 3 ] ;
85948: LD_ADDR_VAR 0 5
85952: PUSH
85953: LD_VAR 0 1
85957: PUSH
85958: LD_INT 3
85960: ARRAY
85961: ST_TO_ADDR
// flags := list [ 4 ] ;
85962: LD_ADDR_VAR 0 6
85966: PUSH
85967: LD_VAR 0 1
85971: PUSH
85972: LD_INT 4
85974: ARRAY
85975: ST_TO_ADDR
// mined := [ ] ;
85976: LD_ADDR_VAR 0 27
85980: PUSH
85981: EMPTY
85982: ST_TO_ADDR
// bombed := [ ] ;
85983: LD_ADDR_VAR 0 28
85987: PUSH
85988: EMPTY
85989: ST_TO_ADDR
// healers := [ ] ;
85990: LD_ADDR_VAR 0 31
85994: PUSH
85995: EMPTY
85996: ST_TO_ADDR
// to_heal := [ ] ;
85997: LD_ADDR_VAR 0 30
86001: PUSH
86002: EMPTY
86003: ST_TO_ADDR
// repairs := [ ] ;
86004: LD_ADDR_VAR 0 33
86008: PUSH
86009: EMPTY
86010: ST_TO_ADDR
// to_repair := [ ] ;
86011: LD_ADDR_VAR 0 32
86015: PUSH
86016: EMPTY
86017: ST_TO_ADDR
// if not group or not path then
86018: LD_VAR 0 4
86022: NOT
86023: PUSH
86024: LD_VAR 0 5
86028: NOT
86029: OR
86030: IFFALSE 86034
// exit ;
86032: GO 90546
// side := GetSide ( group [ 1 ] ) ;
86034: LD_ADDR_VAR 0 35
86038: PUSH
86039: LD_VAR 0 4
86043: PUSH
86044: LD_INT 1
86046: ARRAY
86047: PPUSH
86048: CALL_OW 255
86052: ST_TO_ADDR
// if flags then
86053: LD_VAR 0 6
86057: IFFALSE 86201
// begin f_ignore_area := flags [ 1 ] ;
86059: LD_ADDR_VAR 0 17
86063: PUSH
86064: LD_VAR 0 6
86068: PUSH
86069: LD_INT 1
86071: ARRAY
86072: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
86073: LD_ADDR_VAR 0 18
86077: PUSH
86078: LD_VAR 0 6
86082: PUSH
86083: LD_INT 2
86085: ARRAY
86086: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
86087: LD_ADDR_VAR 0 19
86091: PUSH
86092: LD_VAR 0 6
86096: PUSH
86097: LD_INT 3
86099: ARRAY
86100: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
86101: LD_ADDR_VAR 0 20
86105: PUSH
86106: LD_VAR 0 6
86110: PUSH
86111: LD_INT 4
86113: ARRAY
86114: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86115: LD_ADDR_VAR 0 21
86119: PUSH
86120: LD_VAR 0 6
86124: PUSH
86125: LD_INT 5
86127: ARRAY
86128: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86129: LD_ADDR_VAR 0 22
86133: PUSH
86134: LD_VAR 0 6
86138: PUSH
86139: LD_INT 6
86141: ARRAY
86142: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86143: LD_ADDR_VAR 0 23
86147: PUSH
86148: LD_VAR 0 6
86152: PUSH
86153: LD_INT 7
86155: ARRAY
86156: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86157: LD_ADDR_VAR 0 24
86161: PUSH
86162: LD_VAR 0 6
86166: PUSH
86167: LD_INT 8
86169: ARRAY
86170: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86171: LD_ADDR_VAR 0 25
86175: PUSH
86176: LD_VAR 0 6
86180: PUSH
86181: LD_INT 9
86183: ARRAY
86184: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86185: LD_ADDR_VAR 0 26
86189: PUSH
86190: LD_VAR 0 6
86194: PUSH
86195: LD_INT 10
86197: ARRAY
86198: ST_TO_ADDR
// end else
86199: GO 86281
// begin f_ignore_area := false ;
86201: LD_ADDR_VAR 0 17
86205: PUSH
86206: LD_INT 0
86208: ST_TO_ADDR
// f_capture := false ;
86209: LD_ADDR_VAR 0 18
86213: PUSH
86214: LD_INT 0
86216: ST_TO_ADDR
// f_ignore_civ := false ;
86217: LD_ADDR_VAR 0 19
86221: PUSH
86222: LD_INT 0
86224: ST_TO_ADDR
// f_murder := false ;
86225: LD_ADDR_VAR 0 20
86229: PUSH
86230: LD_INT 0
86232: ST_TO_ADDR
// f_mines := false ;
86233: LD_ADDR_VAR 0 21
86237: PUSH
86238: LD_INT 0
86240: ST_TO_ADDR
// f_repair := false ;
86241: LD_ADDR_VAR 0 22
86245: PUSH
86246: LD_INT 0
86248: ST_TO_ADDR
// f_heal := false ;
86249: LD_ADDR_VAR 0 23
86253: PUSH
86254: LD_INT 0
86256: ST_TO_ADDR
// f_spacetime := false ;
86257: LD_ADDR_VAR 0 24
86261: PUSH
86262: LD_INT 0
86264: ST_TO_ADDR
// f_attack_depot := false ;
86265: LD_ADDR_VAR 0 25
86269: PUSH
86270: LD_INT 0
86272: ST_TO_ADDR
// f_crawl := false ;
86273: LD_ADDR_VAR 0 26
86277: PUSH
86278: LD_INT 0
86280: ST_TO_ADDR
// end ; if f_heal then
86281: LD_VAR 0 23
86285: IFFALSE 86312
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86287: LD_ADDR_VAR 0 31
86291: PUSH
86292: LD_VAR 0 4
86296: PPUSH
86297: LD_INT 25
86299: PUSH
86300: LD_INT 4
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PPUSH
86307: CALL_OW 72
86311: ST_TO_ADDR
// if f_repair then
86312: LD_VAR 0 22
86316: IFFALSE 86343
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86318: LD_ADDR_VAR 0 33
86322: PUSH
86323: LD_VAR 0 4
86327: PPUSH
86328: LD_INT 25
86330: PUSH
86331: LD_INT 3
86333: PUSH
86334: EMPTY
86335: LIST
86336: LIST
86337: PPUSH
86338: CALL_OW 72
86342: ST_TO_ADDR
// units_path := [ ] ;
86343: LD_ADDR_VAR 0 16
86347: PUSH
86348: EMPTY
86349: ST_TO_ADDR
// for i = 1 to group do
86350: LD_ADDR_VAR 0 7
86354: PUSH
86355: DOUBLE
86356: LD_INT 1
86358: DEC
86359: ST_TO_ADDR
86360: LD_VAR 0 4
86364: PUSH
86365: FOR_TO
86366: IFFALSE 86395
// units_path := Replace ( units_path , i , path ) ;
86368: LD_ADDR_VAR 0 16
86372: PUSH
86373: LD_VAR 0 16
86377: PPUSH
86378: LD_VAR 0 7
86382: PPUSH
86383: LD_VAR 0 5
86387: PPUSH
86388: CALL_OW 1
86392: ST_TO_ADDR
86393: GO 86365
86395: POP
86396: POP
// repeat for i = group downto 1 do
86397: LD_ADDR_VAR 0 7
86401: PUSH
86402: DOUBLE
86403: LD_VAR 0 4
86407: INC
86408: ST_TO_ADDR
86409: LD_INT 1
86411: PUSH
86412: FOR_DOWNTO
86413: IFFALSE 90509
// begin wait ( 5 ) ;
86415: LD_INT 5
86417: PPUSH
86418: CALL_OW 67
// tmp := [ ] ;
86422: LD_ADDR_VAR 0 14
86426: PUSH
86427: EMPTY
86428: ST_TO_ADDR
// attacking := false ;
86429: LD_ADDR_VAR 0 29
86433: PUSH
86434: LD_INT 0
86436: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86437: LD_VAR 0 4
86441: PUSH
86442: LD_VAR 0 7
86446: ARRAY
86447: PPUSH
86448: CALL_OW 301
86452: PUSH
86453: LD_VAR 0 4
86457: PUSH
86458: LD_VAR 0 7
86462: ARRAY
86463: NOT
86464: OR
86465: IFFALSE 86574
// begin if GetType ( group [ i ] ) = unit_human then
86467: LD_VAR 0 4
86471: PUSH
86472: LD_VAR 0 7
86476: ARRAY
86477: PPUSH
86478: CALL_OW 247
86482: PUSH
86483: LD_INT 1
86485: EQUAL
86486: IFFALSE 86532
// begin to_heal := to_heal diff group [ i ] ;
86488: LD_ADDR_VAR 0 30
86492: PUSH
86493: LD_VAR 0 30
86497: PUSH
86498: LD_VAR 0 4
86502: PUSH
86503: LD_VAR 0 7
86507: ARRAY
86508: DIFF
86509: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86510: LD_ADDR_VAR 0 31
86514: PUSH
86515: LD_VAR 0 31
86519: PUSH
86520: LD_VAR 0 4
86524: PUSH
86525: LD_VAR 0 7
86529: ARRAY
86530: DIFF
86531: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86532: LD_ADDR_VAR 0 4
86536: PUSH
86537: LD_VAR 0 4
86541: PPUSH
86542: LD_VAR 0 7
86546: PPUSH
86547: CALL_OW 3
86551: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86552: LD_ADDR_VAR 0 16
86556: PUSH
86557: LD_VAR 0 16
86561: PPUSH
86562: LD_VAR 0 7
86566: PPUSH
86567: CALL_OW 3
86571: ST_TO_ADDR
// continue ;
86572: GO 86412
// end ; if f_repair then
86574: LD_VAR 0 22
86578: IFFALSE 87067
// begin if GetType ( group [ i ] ) = unit_vehicle then
86580: LD_VAR 0 4
86584: PUSH
86585: LD_VAR 0 7
86589: ARRAY
86590: PPUSH
86591: CALL_OW 247
86595: PUSH
86596: LD_INT 2
86598: EQUAL
86599: IFFALSE 86789
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86601: LD_VAR 0 4
86605: PUSH
86606: LD_VAR 0 7
86610: ARRAY
86611: PPUSH
86612: CALL_OW 256
86616: PUSH
86617: LD_INT 700
86619: LESS
86620: PUSH
86621: LD_VAR 0 4
86625: PUSH
86626: LD_VAR 0 7
86630: ARRAY
86631: PUSH
86632: LD_VAR 0 32
86636: IN
86637: NOT
86638: AND
86639: IFFALSE 86663
// to_repair := to_repair union group [ i ] ;
86641: LD_ADDR_VAR 0 32
86645: PUSH
86646: LD_VAR 0 32
86650: PUSH
86651: LD_VAR 0 4
86655: PUSH
86656: LD_VAR 0 7
86660: ARRAY
86661: UNION
86662: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86663: LD_VAR 0 4
86667: PUSH
86668: LD_VAR 0 7
86672: ARRAY
86673: PPUSH
86674: CALL_OW 256
86678: PUSH
86679: LD_INT 1000
86681: EQUAL
86682: PUSH
86683: LD_VAR 0 4
86687: PUSH
86688: LD_VAR 0 7
86692: ARRAY
86693: PUSH
86694: LD_VAR 0 32
86698: IN
86699: AND
86700: IFFALSE 86724
// to_repair := to_repair diff group [ i ] ;
86702: LD_ADDR_VAR 0 32
86706: PUSH
86707: LD_VAR 0 32
86711: PUSH
86712: LD_VAR 0 4
86716: PUSH
86717: LD_VAR 0 7
86721: ARRAY
86722: DIFF
86723: ST_TO_ADDR
// if group [ i ] in to_repair then
86724: LD_VAR 0 4
86728: PUSH
86729: LD_VAR 0 7
86733: ARRAY
86734: PUSH
86735: LD_VAR 0 32
86739: IN
86740: IFFALSE 86787
// begin if not IsInArea ( group [ i ] , f_repair ) then
86742: LD_VAR 0 4
86746: PUSH
86747: LD_VAR 0 7
86751: ARRAY
86752: PPUSH
86753: LD_VAR 0 22
86757: PPUSH
86758: CALL_OW 308
86762: NOT
86763: IFFALSE 86785
// ComMoveToArea ( group [ i ] , f_repair ) ;
86765: LD_VAR 0 4
86769: PUSH
86770: LD_VAR 0 7
86774: ARRAY
86775: PPUSH
86776: LD_VAR 0 22
86780: PPUSH
86781: CALL_OW 113
// continue ;
86785: GO 86412
// end ; end else
86787: GO 87067
// if group [ i ] in repairs then
86789: LD_VAR 0 4
86793: PUSH
86794: LD_VAR 0 7
86798: ARRAY
86799: PUSH
86800: LD_VAR 0 33
86804: IN
86805: IFFALSE 87067
// begin if IsInUnit ( group [ i ] ) then
86807: LD_VAR 0 4
86811: PUSH
86812: LD_VAR 0 7
86816: ARRAY
86817: PPUSH
86818: CALL_OW 310
86822: IFFALSE 86890
// begin z := IsInUnit ( group [ i ] ) ;
86824: LD_ADDR_VAR 0 13
86828: PUSH
86829: LD_VAR 0 4
86833: PUSH
86834: LD_VAR 0 7
86838: ARRAY
86839: PPUSH
86840: CALL_OW 310
86844: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
86845: LD_VAR 0 13
86849: PUSH
86850: LD_VAR 0 32
86854: IN
86855: PUSH
86856: LD_VAR 0 13
86860: PPUSH
86861: LD_VAR 0 22
86865: PPUSH
86866: CALL_OW 308
86870: AND
86871: IFFALSE 86888
// ComExitVehicle ( group [ i ] ) ;
86873: LD_VAR 0 4
86877: PUSH
86878: LD_VAR 0 7
86882: ARRAY
86883: PPUSH
86884: CALL_OW 121
// end else
86888: GO 87067
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
86890: LD_ADDR_VAR 0 13
86894: PUSH
86895: LD_VAR 0 4
86899: PPUSH
86900: LD_INT 95
86902: PUSH
86903: LD_VAR 0 22
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: LD_INT 58
86914: PUSH
86915: EMPTY
86916: LIST
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PPUSH
86922: CALL_OW 72
86926: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
86927: LD_VAR 0 4
86931: PUSH
86932: LD_VAR 0 7
86936: ARRAY
86937: PPUSH
86938: CALL_OW 314
86942: NOT
86943: IFFALSE 87065
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
86945: LD_ADDR_VAR 0 10
86949: PUSH
86950: LD_VAR 0 13
86954: PPUSH
86955: LD_VAR 0 4
86959: PUSH
86960: LD_VAR 0 7
86964: ARRAY
86965: PPUSH
86966: CALL_OW 74
86970: ST_TO_ADDR
// if not x then
86971: LD_VAR 0 10
86975: NOT
86976: IFFALSE 86980
// continue ;
86978: GO 86412
// if GetLives ( x ) < 1000 then
86980: LD_VAR 0 10
86984: PPUSH
86985: CALL_OW 256
86989: PUSH
86990: LD_INT 1000
86992: LESS
86993: IFFALSE 87017
// ComRepairVehicle ( group [ i ] , x ) else
86995: LD_VAR 0 4
86999: PUSH
87000: LD_VAR 0 7
87004: ARRAY
87005: PPUSH
87006: LD_VAR 0 10
87010: PPUSH
87011: CALL_OW 129
87015: GO 87065
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
87017: LD_VAR 0 23
87021: PUSH
87022: LD_VAR 0 4
87026: PUSH
87027: LD_VAR 0 7
87031: ARRAY
87032: PPUSH
87033: CALL_OW 256
87037: PUSH
87038: LD_INT 1000
87040: LESS
87041: AND
87042: NOT
87043: IFFALSE 87065
// ComEnterUnit ( group [ i ] , x ) ;
87045: LD_VAR 0 4
87049: PUSH
87050: LD_VAR 0 7
87054: ARRAY
87055: PPUSH
87056: LD_VAR 0 10
87060: PPUSH
87061: CALL_OW 120
// end ; continue ;
87065: GO 86412
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
87067: LD_VAR 0 23
87071: PUSH
87072: LD_VAR 0 4
87076: PUSH
87077: LD_VAR 0 7
87081: ARRAY
87082: PPUSH
87083: CALL_OW 247
87087: PUSH
87088: LD_INT 1
87090: EQUAL
87091: AND
87092: IFFALSE 87570
// begin if group [ i ] in healers then
87094: LD_VAR 0 4
87098: PUSH
87099: LD_VAR 0 7
87103: ARRAY
87104: PUSH
87105: LD_VAR 0 31
87109: IN
87110: IFFALSE 87383
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87112: LD_VAR 0 4
87116: PUSH
87117: LD_VAR 0 7
87121: ARRAY
87122: PPUSH
87123: LD_VAR 0 23
87127: PPUSH
87128: CALL_OW 308
87132: NOT
87133: PUSH
87134: LD_VAR 0 4
87138: PUSH
87139: LD_VAR 0 7
87143: ARRAY
87144: PPUSH
87145: CALL_OW 314
87149: NOT
87150: AND
87151: IFFALSE 87175
// ComMoveToArea ( group [ i ] , f_heal ) else
87153: LD_VAR 0 4
87157: PUSH
87158: LD_VAR 0 7
87162: ARRAY
87163: PPUSH
87164: LD_VAR 0 23
87168: PPUSH
87169: CALL_OW 113
87173: GO 87381
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87175: LD_VAR 0 4
87179: PUSH
87180: LD_VAR 0 7
87184: ARRAY
87185: PPUSH
87186: CALL 85793 0 1
87190: PPUSH
87191: CALL_OW 256
87195: PUSH
87196: LD_INT 1000
87198: EQUAL
87199: IFFALSE 87218
// ComStop ( group [ i ] ) else
87201: LD_VAR 0 4
87205: PUSH
87206: LD_VAR 0 7
87210: ARRAY
87211: PPUSH
87212: CALL_OW 141
87216: GO 87381
// if not HasTask ( group [ i ] ) and to_heal then
87218: LD_VAR 0 4
87222: PUSH
87223: LD_VAR 0 7
87227: ARRAY
87228: PPUSH
87229: CALL_OW 314
87233: NOT
87234: PUSH
87235: LD_VAR 0 30
87239: AND
87240: IFFALSE 87381
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87242: LD_ADDR_VAR 0 13
87246: PUSH
87247: LD_VAR 0 30
87251: PPUSH
87252: LD_INT 3
87254: PUSH
87255: LD_INT 54
87257: PUSH
87258: EMPTY
87259: LIST
87260: PUSH
87261: EMPTY
87262: LIST
87263: LIST
87264: PPUSH
87265: CALL_OW 72
87269: PPUSH
87270: LD_VAR 0 4
87274: PUSH
87275: LD_VAR 0 7
87279: ARRAY
87280: PPUSH
87281: CALL_OW 74
87285: ST_TO_ADDR
// if z then
87286: LD_VAR 0 13
87290: IFFALSE 87381
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87292: LD_INT 91
87294: PUSH
87295: LD_VAR 0 13
87299: PUSH
87300: LD_INT 10
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 81
87310: PUSH
87311: LD_VAR 0 13
87315: PPUSH
87316: CALL_OW 255
87320: PUSH
87321: EMPTY
87322: LIST
87323: LIST
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PPUSH
87329: CALL_OW 69
87333: PUSH
87334: LD_INT 0
87336: EQUAL
87337: IFFALSE 87361
// ComHeal ( group [ i ] , z ) else
87339: LD_VAR 0 4
87343: PUSH
87344: LD_VAR 0 7
87348: ARRAY
87349: PPUSH
87350: LD_VAR 0 13
87354: PPUSH
87355: CALL_OW 128
87359: GO 87381
// ComMoveToArea ( group [ i ] , f_heal ) ;
87361: LD_VAR 0 4
87365: PUSH
87366: LD_VAR 0 7
87370: ARRAY
87371: PPUSH
87372: LD_VAR 0 23
87376: PPUSH
87377: CALL_OW 113
// end ; continue ;
87381: GO 86412
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87383: LD_VAR 0 4
87387: PUSH
87388: LD_VAR 0 7
87392: ARRAY
87393: PPUSH
87394: CALL_OW 256
87398: PUSH
87399: LD_INT 700
87401: LESS
87402: PUSH
87403: LD_VAR 0 4
87407: PUSH
87408: LD_VAR 0 7
87412: ARRAY
87413: PUSH
87414: LD_VAR 0 30
87418: IN
87419: NOT
87420: AND
87421: IFFALSE 87445
// to_heal := to_heal union group [ i ] ;
87423: LD_ADDR_VAR 0 30
87427: PUSH
87428: LD_VAR 0 30
87432: PUSH
87433: LD_VAR 0 4
87437: PUSH
87438: LD_VAR 0 7
87442: ARRAY
87443: UNION
87444: ST_TO_ADDR
// if group [ i ] in to_heal then
87445: LD_VAR 0 4
87449: PUSH
87450: LD_VAR 0 7
87454: ARRAY
87455: PUSH
87456: LD_VAR 0 30
87460: IN
87461: IFFALSE 87570
// begin if GetLives ( group [ i ] ) = 1000 then
87463: LD_VAR 0 4
87467: PUSH
87468: LD_VAR 0 7
87472: ARRAY
87473: PPUSH
87474: CALL_OW 256
87478: PUSH
87479: LD_INT 1000
87481: EQUAL
87482: IFFALSE 87508
// to_heal := to_heal diff group [ i ] else
87484: LD_ADDR_VAR 0 30
87488: PUSH
87489: LD_VAR 0 30
87493: PUSH
87494: LD_VAR 0 4
87498: PUSH
87499: LD_VAR 0 7
87503: ARRAY
87504: DIFF
87505: ST_TO_ADDR
87506: GO 87570
// begin if not IsInArea ( group [ i ] , to_heal ) then
87508: LD_VAR 0 4
87512: PUSH
87513: LD_VAR 0 7
87517: ARRAY
87518: PPUSH
87519: LD_VAR 0 30
87523: PPUSH
87524: CALL_OW 308
87528: NOT
87529: IFFALSE 87553
// ComMoveToArea ( group [ i ] , f_heal ) else
87531: LD_VAR 0 4
87535: PUSH
87536: LD_VAR 0 7
87540: ARRAY
87541: PPUSH
87542: LD_VAR 0 23
87546: PPUSH
87547: CALL_OW 113
87551: GO 87568
// ComHold ( group [ i ] ) ;
87553: LD_VAR 0 4
87557: PUSH
87558: LD_VAR 0 7
87562: ARRAY
87563: PPUSH
87564: CALL_OW 140
// continue ;
87568: GO 86412
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87570: LD_VAR 0 4
87574: PUSH
87575: LD_VAR 0 7
87579: ARRAY
87580: PPUSH
87581: LD_INT 10
87583: PPUSH
87584: CALL 84190 0 2
87588: NOT
87589: PUSH
87590: LD_VAR 0 16
87594: PUSH
87595: LD_VAR 0 7
87599: ARRAY
87600: PUSH
87601: EMPTY
87602: EQUAL
87603: NOT
87604: AND
87605: IFFALSE 87871
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87607: LD_VAR 0 4
87611: PUSH
87612: LD_VAR 0 7
87616: ARRAY
87617: PPUSH
87618: CALL_OW 262
87622: PUSH
87623: LD_INT 1
87625: PUSH
87626: LD_INT 2
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: IN
87633: IFFALSE 87674
// if GetFuel ( group [ i ] ) < 10 then
87635: LD_VAR 0 4
87639: PUSH
87640: LD_VAR 0 7
87644: ARRAY
87645: PPUSH
87646: CALL_OW 261
87650: PUSH
87651: LD_INT 10
87653: LESS
87654: IFFALSE 87674
// SetFuel ( group [ i ] , 12 ) ;
87656: LD_VAR 0 4
87660: PUSH
87661: LD_VAR 0 7
87665: ARRAY
87666: PPUSH
87667: LD_INT 12
87669: PPUSH
87670: CALL_OW 240
// if units_path [ i ] then
87674: LD_VAR 0 16
87678: PUSH
87679: LD_VAR 0 7
87683: ARRAY
87684: IFFALSE 87869
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
87686: LD_VAR 0 4
87690: PUSH
87691: LD_VAR 0 7
87695: ARRAY
87696: PPUSH
87697: LD_VAR 0 16
87701: PUSH
87702: LD_VAR 0 7
87706: ARRAY
87707: PUSH
87708: LD_INT 1
87710: ARRAY
87711: PUSH
87712: LD_INT 1
87714: ARRAY
87715: PPUSH
87716: LD_VAR 0 16
87720: PUSH
87721: LD_VAR 0 7
87725: ARRAY
87726: PUSH
87727: LD_INT 1
87729: ARRAY
87730: PUSH
87731: LD_INT 2
87733: ARRAY
87734: PPUSH
87735: CALL_OW 297
87739: PUSH
87740: LD_INT 6
87742: GREATER
87743: IFFALSE 87818
// begin if not HasTask ( group [ i ] ) then
87745: LD_VAR 0 4
87749: PUSH
87750: LD_VAR 0 7
87754: ARRAY
87755: PPUSH
87756: CALL_OW 314
87760: NOT
87761: IFFALSE 87816
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
87763: LD_VAR 0 4
87767: PUSH
87768: LD_VAR 0 7
87772: ARRAY
87773: PPUSH
87774: LD_VAR 0 16
87778: PUSH
87779: LD_VAR 0 7
87783: ARRAY
87784: PUSH
87785: LD_INT 1
87787: ARRAY
87788: PUSH
87789: LD_INT 1
87791: ARRAY
87792: PPUSH
87793: LD_VAR 0 16
87797: PUSH
87798: LD_VAR 0 7
87802: ARRAY
87803: PUSH
87804: LD_INT 1
87806: ARRAY
87807: PUSH
87808: LD_INT 2
87810: ARRAY
87811: PPUSH
87812: CALL_OW 114
// end else
87816: GO 87869
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
87818: LD_ADDR_VAR 0 15
87822: PUSH
87823: LD_VAR 0 16
87827: PUSH
87828: LD_VAR 0 7
87832: ARRAY
87833: PPUSH
87834: LD_INT 1
87836: PPUSH
87837: CALL_OW 3
87841: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
87842: LD_ADDR_VAR 0 16
87846: PUSH
87847: LD_VAR 0 16
87851: PPUSH
87852: LD_VAR 0 7
87856: PPUSH
87857: LD_VAR 0 15
87861: PPUSH
87862: CALL_OW 1
87866: ST_TO_ADDR
// continue ;
87867: GO 86412
// end ; end ; end else
87869: GO 90507
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
87871: LD_ADDR_VAR 0 14
87875: PUSH
87876: LD_INT 81
87878: PUSH
87879: LD_VAR 0 4
87883: PUSH
87884: LD_VAR 0 7
87888: ARRAY
87889: PPUSH
87890: CALL_OW 255
87894: PUSH
87895: EMPTY
87896: LIST
87897: LIST
87898: PPUSH
87899: CALL_OW 69
87903: ST_TO_ADDR
// if not tmp then
87904: LD_VAR 0 14
87908: NOT
87909: IFFALSE 87913
// continue ;
87911: GO 86412
// if f_ignore_area then
87913: LD_VAR 0 17
87917: IFFALSE 88005
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
87919: LD_ADDR_VAR 0 15
87923: PUSH
87924: LD_VAR 0 14
87928: PPUSH
87929: LD_INT 3
87931: PUSH
87932: LD_INT 92
87934: PUSH
87935: LD_VAR 0 17
87939: PUSH
87940: LD_INT 1
87942: ARRAY
87943: PUSH
87944: LD_VAR 0 17
87948: PUSH
87949: LD_INT 2
87951: ARRAY
87952: PUSH
87953: LD_VAR 0 17
87957: PUSH
87958: LD_INT 3
87960: ARRAY
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PPUSH
87972: CALL_OW 72
87976: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87977: LD_VAR 0 14
87981: PUSH
87982: LD_VAR 0 15
87986: DIFF
87987: IFFALSE 88005
// tmp := tmp diff tmp2 ;
87989: LD_ADDR_VAR 0 14
87993: PUSH
87994: LD_VAR 0 14
87998: PUSH
87999: LD_VAR 0 15
88003: DIFF
88004: ST_TO_ADDR
// end ; if not f_murder then
88005: LD_VAR 0 20
88009: NOT
88010: IFFALSE 88068
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
88012: LD_ADDR_VAR 0 15
88016: PUSH
88017: LD_VAR 0 14
88021: PPUSH
88022: LD_INT 3
88024: PUSH
88025: LD_INT 50
88027: PUSH
88028: EMPTY
88029: LIST
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PPUSH
88035: CALL_OW 72
88039: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88040: LD_VAR 0 14
88044: PUSH
88045: LD_VAR 0 15
88049: DIFF
88050: IFFALSE 88068
// tmp := tmp diff tmp2 ;
88052: LD_ADDR_VAR 0 14
88056: PUSH
88057: LD_VAR 0 14
88061: PUSH
88062: LD_VAR 0 15
88066: DIFF
88067: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
88068: LD_ADDR_VAR 0 14
88072: PUSH
88073: LD_VAR 0 4
88077: PUSH
88078: LD_VAR 0 7
88082: ARRAY
88083: PPUSH
88084: LD_VAR 0 14
88088: PPUSH
88089: LD_INT 1
88091: PPUSH
88092: LD_INT 1
88094: PPUSH
88095: CALL 57833 0 4
88099: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88100: LD_VAR 0 4
88104: PUSH
88105: LD_VAR 0 7
88109: ARRAY
88110: PPUSH
88111: CALL_OW 257
88115: PUSH
88116: LD_INT 1
88118: EQUAL
88119: IFFALSE 88567
// begin if WantPlant ( group [ i ] ) then
88121: LD_VAR 0 4
88125: PUSH
88126: LD_VAR 0 7
88130: ARRAY
88131: PPUSH
88132: CALL 57334 0 1
88136: IFFALSE 88140
// continue ;
88138: GO 86412
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88140: LD_VAR 0 18
88144: PUSH
88145: LD_VAR 0 4
88149: PUSH
88150: LD_VAR 0 7
88154: ARRAY
88155: PPUSH
88156: CALL_OW 310
88160: NOT
88161: AND
88162: PUSH
88163: LD_VAR 0 14
88167: PUSH
88168: LD_INT 1
88170: ARRAY
88171: PUSH
88172: LD_VAR 0 14
88176: PPUSH
88177: LD_INT 21
88179: PUSH
88180: LD_INT 2
88182: PUSH
88183: EMPTY
88184: LIST
88185: LIST
88186: PUSH
88187: LD_INT 58
88189: PUSH
88190: EMPTY
88191: LIST
88192: PUSH
88193: EMPTY
88194: LIST
88195: LIST
88196: PPUSH
88197: CALL_OW 72
88201: IN
88202: AND
88203: IFFALSE 88239
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88205: LD_VAR 0 4
88209: PUSH
88210: LD_VAR 0 7
88214: ARRAY
88215: PPUSH
88216: LD_VAR 0 14
88220: PUSH
88221: LD_INT 1
88223: ARRAY
88224: PPUSH
88225: CALL_OW 120
// attacking := true ;
88229: LD_ADDR_VAR 0 29
88233: PUSH
88234: LD_INT 1
88236: ST_TO_ADDR
// continue ;
88237: GO 86412
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88239: LD_VAR 0 26
88243: PUSH
88244: LD_VAR 0 4
88248: PUSH
88249: LD_VAR 0 7
88253: ARRAY
88254: PPUSH
88255: CALL_OW 257
88259: PUSH
88260: LD_INT 1
88262: EQUAL
88263: AND
88264: PUSH
88265: LD_VAR 0 4
88269: PUSH
88270: LD_VAR 0 7
88274: ARRAY
88275: PPUSH
88276: CALL_OW 256
88280: PUSH
88281: LD_INT 800
88283: LESS
88284: AND
88285: PUSH
88286: LD_VAR 0 4
88290: PUSH
88291: LD_VAR 0 7
88295: ARRAY
88296: PPUSH
88297: CALL_OW 318
88301: NOT
88302: AND
88303: IFFALSE 88320
// ComCrawl ( group [ i ] ) ;
88305: LD_VAR 0 4
88309: PUSH
88310: LD_VAR 0 7
88314: ARRAY
88315: PPUSH
88316: CALL_OW 137
// if f_mines then
88320: LD_VAR 0 21
88324: IFFALSE 88567
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88326: LD_VAR 0 14
88330: PUSH
88331: LD_INT 1
88333: ARRAY
88334: PPUSH
88335: CALL_OW 247
88339: PUSH
88340: LD_INT 3
88342: EQUAL
88343: PUSH
88344: LD_VAR 0 14
88348: PUSH
88349: LD_INT 1
88351: ARRAY
88352: PUSH
88353: LD_VAR 0 27
88357: IN
88358: NOT
88359: AND
88360: IFFALSE 88567
// begin x := GetX ( tmp [ 1 ] ) ;
88362: LD_ADDR_VAR 0 10
88366: PUSH
88367: LD_VAR 0 14
88371: PUSH
88372: LD_INT 1
88374: ARRAY
88375: PPUSH
88376: CALL_OW 250
88380: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88381: LD_ADDR_VAR 0 11
88385: PUSH
88386: LD_VAR 0 14
88390: PUSH
88391: LD_INT 1
88393: ARRAY
88394: PPUSH
88395: CALL_OW 251
88399: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88400: LD_ADDR_VAR 0 12
88404: PUSH
88405: LD_VAR 0 4
88409: PUSH
88410: LD_VAR 0 7
88414: ARRAY
88415: PPUSH
88416: CALL 84275 0 1
88420: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88421: LD_VAR 0 4
88425: PUSH
88426: LD_VAR 0 7
88430: ARRAY
88431: PPUSH
88432: LD_VAR 0 10
88436: PPUSH
88437: LD_VAR 0 11
88441: PPUSH
88442: LD_VAR 0 14
88446: PUSH
88447: LD_INT 1
88449: ARRAY
88450: PPUSH
88451: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88455: LD_VAR 0 4
88459: PUSH
88460: LD_VAR 0 7
88464: ARRAY
88465: PPUSH
88466: LD_VAR 0 10
88470: PPUSH
88471: LD_VAR 0 12
88475: PPUSH
88476: LD_INT 7
88478: PPUSH
88479: CALL_OW 272
88483: PPUSH
88484: LD_VAR 0 11
88488: PPUSH
88489: LD_VAR 0 12
88493: PPUSH
88494: LD_INT 7
88496: PPUSH
88497: CALL_OW 273
88501: PPUSH
88502: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88506: LD_VAR 0 4
88510: PUSH
88511: LD_VAR 0 7
88515: ARRAY
88516: PPUSH
88517: LD_INT 71
88519: PPUSH
88520: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88524: LD_ADDR_VAR 0 27
88528: PUSH
88529: LD_VAR 0 27
88533: PPUSH
88534: LD_VAR 0 27
88538: PUSH
88539: LD_INT 1
88541: PLUS
88542: PPUSH
88543: LD_VAR 0 14
88547: PUSH
88548: LD_INT 1
88550: ARRAY
88551: PPUSH
88552: CALL_OW 1
88556: ST_TO_ADDR
// attacking := true ;
88557: LD_ADDR_VAR 0 29
88561: PUSH
88562: LD_INT 1
88564: ST_TO_ADDR
// continue ;
88565: GO 86412
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88567: LD_VAR 0 4
88571: PUSH
88572: LD_VAR 0 7
88576: ARRAY
88577: PPUSH
88578: CALL_OW 257
88582: PUSH
88583: LD_INT 17
88585: EQUAL
88586: PUSH
88587: LD_VAR 0 4
88591: PUSH
88592: LD_VAR 0 7
88596: ARRAY
88597: PPUSH
88598: CALL_OW 110
88602: PUSH
88603: LD_INT 71
88605: EQUAL
88606: NOT
88607: AND
88608: IFFALSE 88754
// begin attacking := false ;
88610: LD_ADDR_VAR 0 29
88614: PUSH
88615: LD_INT 0
88617: ST_TO_ADDR
// k := 5 ;
88618: LD_ADDR_VAR 0 9
88622: PUSH
88623: LD_INT 5
88625: ST_TO_ADDR
// if tmp < k then
88626: LD_VAR 0 14
88630: PUSH
88631: LD_VAR 0 9
88635: LESS
88636: IFFALSE 88648
// k := tmp ;
88638: LD_ADDR_VAR 0 9
88642: PUSH
88643: LD_VAR 0 14
88647: ST_TO_ADDR
// for j = 1 to k do
88648: LD_ADDR_VAR 0 8
88652: PUSH
88653: DOUBLE
88654: LD_INT 1
88656: DEC
88657: ST_TO_ADDR
88658: LD_VAR 0 9
88662: PUSH
88663: FOR_TO
88664: IFFALSE 88752
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88666: LD_VAR 0 14
88670: PUSH
88671: LD_VAR 0 8
88675: ARRAY
88676: PUSH
88677: LD_VAR 0 14
88681: PPUSH
88682: LD_INT 58
88684: PUSH
88685: EMPTY
88686: LIST
88687: PPUSH
88688: CALL_OW 72
88692: IN
88693: NOT
88694: IFFALSE 88750
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88696: LD_VAR 0 4
88700: PUSH
88701: LD_VAR 0 7
88705: ARRAY
88706: PPUSH
88707: LD_VAR 0 14
88711: PUSH
88712: LD_VAR 0 8
88716: ARRAY
88717: PPUSH
88718: CALL_OW 115
// attacking := true ;
88722: LD_ADDR_VAR 0 29
88726: PUSH
88727: LD_INT 1
88729: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
88730: LD_VAR 0 4
88734: PUSH
88735: LD_VAR 0 7
88739: ARRAY
88740: PPUSH
88741: LD_INT 71
88743: PPUSH
88744: CALL_OW 109
// continue ;
88748: GO 88663
// end ; end ;
88750: GO 88663
88752: POP
88753: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
88754: LD_VAR 0 4
88758: PUSH
88759: LD_VAR 0 7
88763: ARRAY
88764: PPUSH
88765: CALL_OW 257
88769: PUSH
88770: LD_INT 8
88772: EQUAL
88773: PUSH
88774: LD_VAR 0 4
88778: PUSH
88779: LD_VAR 0 7
88783: ARRAY
88784: PPUSH
88785: CALL_OW 264
88789: PUSH
88790: LD_INT 28
88792: PUSH
88793: LD_INT 45
88795: PUSH
88796: LD_INT 7
88798: PUSH
88799: LD_INT 47
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: IN
88808: OR
88809: IFFALSE 89039
// begin attacking := false ;
88811: LD_ADDR_VAR 0 29
88815: PUSH
88816: LD_INT 0
88818: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
88819: LD_VAR 0 14
88823: PUSH
88824: LD_INT 1
88826: ARRAY
88827: PPUSH
88828: CALL_OW 266
88832: PUSH
88833: LD_INT 32
88835: PUSH
88836: LD_INT 31
88838: PUSH
88839: LD_INT 33
88841: PUSH
88842: LD_INT 4
88844: PUSH
88845: LD_INT 5
88847: PUSH
88848: EMPTY
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: IN
88855: IFFALSE 89039
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
88857: LD_ADDR_VAR 0 9
88861: PUSH
88862: LD_VAR 0 14
88866: PUSH
88867: LD_INT 1
88869: ARRAY
88870: PPUSH
88871: CALL_OW 266
88875: PPUSH
88876: LD_VAR 0 14
88880: PUSH
88881: LD_INT 1
88883: ARRAY
88884: PPUSH
88885: CALL_OW 250
88889: PPUSH
88890: LD_VAR 0 14
88894: PUSH
88895: LD_INT 1
88897: ARRAY
88898: PPUSH
88899: CALL_OW 251
88903: PPUSH
88904: LD_VAR 0 14
88908: PUSH
88909: LD_INT 1
88911: ARRAY
88912: PPUSH
88913: CALL_OW 254
88917: PPUSH
88918: LD_VAR 0 14
88922: PUSH
88923: LD_INT 1
88925: ARRAY
88926: PPUSH
88927: CALL_OW 248
88931: PPUSH
88932: LD_INT 0
88934: PPUSH
88935: CALL 65645 0 6
88939: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
88940: LD_ADDR_VAR 0 8
88944: PUSH
88945: LD_VAR 0 4
88949: PUSH
88950: LD_VAR 0 7
88954: ARRAY
88955: PPUSH
88956: LD_VAR 0 9
88960: PPUSH
88961: CALL 84338 0 2
88965: ST_TO_ADDR
// if j then
88966: LD_VAR 0 8
88970: IFFALSE 89039
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
88972: LD_VAR 0 8
88976: PUSH
88977: LD_INT 1
88979: ARRAY
88980: PPUSH
88981: LD_VAR 0 8
88985: PUSH
88986: LD_INT 2
88988: ARRAY
88989: PPUSH
88990: CALL_OW 488
88994: IFFALSE 89039
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
88996: LD_VAR 0 4
89000: PUSH
89001: LD_VAR 0 7
89005: ARRAY
89006: PPUSH
89007: LD_VAR 0 8
89011: PUSH
89012: LD_INT 1
89014: ARRAY
89015: PPUSH
89016: LD_VAR 0 8
89020: PUSH
89021: LD_INT 2
89023: ARRAY
89024: PPUSH
89025: CALL_OW 116
// attacking := true ;
89029: LD_ADDR_VAR 0 29
89033: PUSH
89034: LD_INT 1
89036: ST_TO_ADDR
// continue ;
89037: GO 86412
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
89039: LD_VAR 0 4
89043: PUSH
89044: LD_VAR 0 7
89048: ARRAY
89049: PPUSH
89050: CALL_OW 265
89054: PUSH
89055: LD_INT 11
89057: EQUAL
89058: IFFALSE 89336
// begin k := 10 ;
89060: LD_ADDR_VAR 0 9
89064: PUSH
89065: LD_INT 10
89067: ST_TO_ADDR
// x := 0 ;
89068: LD_ADDR_VAR 0 10
89072: PUSH
89073: LD_INT 0
89075: ST_TO_ADDR
// if tmp < k then
89076: LD_VAR 0 14
89080: PUSH
89081: LD_VAR 0 9
89085: LESS
89086: IFFALSE 89098
// k := tmp ;
89088: LD_ADDR_VAR 0 9
89092: PUSH
89093: LD_VAR 0 14
89097: ST_TO_ADDR
// for j = k downto 1 do
89098: LD_ADDR_VAR 0 8
89102: PUSH
89103: DOUBLE
89104: LD_VAR 0 9
89108: INC
89109: ST_TO_ADDR
89110: LD_INT 1
89112: PUSH
89113: FOR_DOWNTO
89114: IFFALSE 89189
// begin if GetType ( tmp [ j ] ) = unit_human then
89116: LD_VAR 0 14
89120: PUSH
89121: LD_VAR 0 8
89125: ARRAY
89126: PPUSH
89127: CALL_OW 247
89131: PUSH
89132: LD_INT 1
89134: EQUAL
89135: IFFALSE 89187
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89137: LD_VAR 0 4
89141: PUSH
89142: LD_VAR 0 7
89146: ARRAY
89147: PPUSH
89148: LD_VAR 0 14
89152: PUSH
89153: LD_VAR 0 8
89157: ARRAY
89158: PPUSH
89159: CALL 84609 0 2
// x := tmp [ j ] ;
89163: LD_ADDR_VAR 0 10
89167: PUSH
89168: LD_VAR 0 14
89172: PUSH
89173: LD_VAR 0 8
89177: ARRAY
89178: ST_TO_ADDR
// attacking := true ;
89179: LD_ADDR_VAR 0 29
89183: PUSH
89184: LD_INT 1
89186: ST_TO_ADDR
// end ; end ;
89187: GO 89113
89189: POP
89190: POP
// if not x then
89191: LD_VAR 0 10
89195: NOT
89196: IFFALSE 89336
// begin attacking := true ;
89198: LD_ADDR_VAR 0 29
89202: PUSH
89203: LD_INT 1
89205: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89206: LD_VAR 0 4
89210: PUSH
89211: LD_VAR 0 7
89215: ARRAY
89216: PPUSH
89217: CALL_OW 250
89221: PPUSH
89222: LD_VAR 0 4
89226: PUSH
89227: LD_VAR 0 7
89231: ARRAY
89232: PPUSH
89233: CALL_OW 251
89237: PPUSH
89238: CALL_OW 546
89242: PUSH
89243: LD_INT 2
89245: ARRAY
89246: PUSH
89247: LD_VAR 0 14
89251: PUSH
89252: LD_INT 1
89254: ARRAY
89255: PPUSH
89256: CALL_OW 250
89260: PPUSH
89261: LD_VAR 0 14
89265: PUSH
89266: LD_INT 1
89268: ARRAY
89269: PPUSH
89270: CALL_OW 251
89274: PPUSH
89275: CALL_OW 546
89279: PUSH
89280: LD_INT 2
89282: ARRAY
89283: EQUAL
89284: IFFALSE 89312
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89286: LD_VAR 0 4
89290: PUSH
89291: LD_VAR 0 7
89295: ARRAY
89296: PPUSH
89297: LD_VAR 0 14
89301: PUSH
89302: LD_INT 1
89304: ARRAY
89305: PPUSH
89306: CALL 84609 0 2
89310: GO 89336
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89312: LD_VAR 0 4
89316: PUSH
89317: LD_VAR 0 7
89321: ARRAY
89322: PPUSH
89323: LD_VAR 0 14
89327: PUSH
89328: LD_INT 1
89330: ARRAY
89331: PPUSH
89332: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89336: LD_VAR 0 4
89340: PUSH
89341: LD_VAR 0 7
89345: ARRAY
89346: PPUSH
89347: CALL_OW 264
89351: PUSH
89352: LD_INT 29
89354: EQUAL
89355: IFFALSE 89721
// begin if WantsToAttack ( group [ i ] ) in bombed then
89357: LD_VAR 0 4
89361: PUSH
89362: LD_VAR 0 7
89366: ARRAY
89367: PPUSH
89368: CALL_OW 319
89372: PUSH
89373: LD_VAR 0 28
89377: IN
89378: IFFALSE 89382
// continue ;
89380: GO 86412
// k := 8 ;
89382: LD_ADDR_VAR 0 9
89386: PUSH
89387: LD_INT 8
89389: ST_TO_ADDR
// x := 0 ;
89390: LD_ADDR_VAR 0 10
89394: PUSH
89395: LD_INT 0
89397: ST_TO_ADDR
// if tmp < k then
89398: LD_VAR 0 14
89402: PUSH
89403: LD_VAR 0 9
89407: LESS
89408: IFFALSE 89420
// k := tmp ;
89410: LD_ADDR_VAR 0 9
89414: PUSH
89415: LD_VAR 0 14
89419: ST_TO_ADDR
// for j = 1 to k do
89420: LD_ADDR_VAR 0 8
89424: PUSH
89425: DOUBLE
89426: LD_INT 1
89428: DEC
89429: ST_TO_ADDR
89430: LD_VAR 0 9
89434: PUSH
89435: FOR_TO
89436: IFFALSE 89568
// begin if GetType ( tmp [ j ] ) = unit_building then
89438: LD_VAR 0 14
89442: PUSH
89443: LD_VAR 0 8
89447: ARRAY
89448: PPUSH
89449: CALL_OW 247
89453: PUSH
89454: LD_INT 3
89456: EQUAL
89457: IFFALSE 89566
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89459: LD_VAR 0 14
89463: PUSH
89464: LD_VAR 0 8
89468: ARRAY
89469: PUSH
89470: LD_VAR 0 28
89474: IN
89475: NOT
89476: PUSH
89477: LD_VAR 0 14
89481: PUSH
89482: LD_VAR 0 8
89486: ARRAY
89487: PPUSH
89488: CALL_OW 313
89492: AND
89493: IFFALSE 89566
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89495: LD_VAR 0 4
89499: PUSH
89500: LD_VAR 0 7
89504: ARRAY
89505: PPUSH
89506: LD_VAR 0 14
89510: PUSH
89511: LD_VAR 0 8
89515: ARRAY
89516: PPUSH
89517: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89521: LD_ADDR_VAR 0 28
89525: PUSH
89526: LD_VAR 0 28
89530: PPUSH
89531: LD_VAR 0 28
89535: PUSH
89536: LD_INT 1
89538: PLUS
89539: PPUSH
89540: LD_VAR 0 14
89544: PUSH
89545: LD_VAR 0 8
89549: ARRAY
89550: PPUSH
89551: CALL_OW 1
89555: ST_TO_ADDR
// attacking := true ;
89556: LD_ADDR_VAR 0 29
89560: PUSH
89561: LD_INT 1
89563: ST_TO_ADDR
// break ;
89564: GO 89568
// end ; end ;
89566: GO 89435
89568: POP
89569: POP
// if not attacking and f_attack_depot then
89570: LD_VAR 0 29
89574: NOT
89575: PUSH
89576: LD_VAR 0 25
89580: AND
89581: IFFALSE 89676
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89583: LD_ADDR_VAR 0 13
89587: PUSH
89588: LD_VAR 0 14
89592: PPUSH
89593: LD_INT 2
89595: PUSH
89596: LD_INT 30
89598: PUSH
89599: LD_INT 0
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: LD_INT 30
89608: PUSH
89609: LD_INT 1
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: LIST
89620: PPUSH
89621: CALL_OW 72
89625: ST_TO_ADDR
// if z then
89626: LD_VAR 0 13
89630: IFFALSE 89676
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89632: LD_VAR 0 4
89636: PUSH
89637: LD_VAR 0 7
89641: ARRAY
89642: PPUSH
89643: LD_VAR 0 13
89647: PPUSH
89648: LD_VAR 0 4
89652: PUSH
89653: LD_VAR 0 7
89657: ARRAY
89658: PPUSH
89659: CALL_OW 74
89663: PPUSH
89664: CALL_OW 115
// attacking := true ;
89668: LD_ADDR_VAR 0 29
89672: PUSH
89673: LD_INT 1
89675: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
89676: LD_VAR 0 4
89680: PUSH
89681: LD_VAR 0 7
89685: ARRAY
89686: PPUSH
89687: CALL_OW 256
89691: PUSH
89692: LD_INT 500
89694: LESS
89695: IFFALSE 89721
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89697: LD_VAR 0 4
89701: PUSH
89702: LD_VAR 0 7
89706: ARRAY
89707: PPUSH
89708: LD_VAR 0 14
89712: PUSH
89713: LD_INT 1
89715: ARRAY
89716: PPUSH
89717: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
89721: LD_VAR 0 4
89725: PUSH
89726: LD_VAR 0 7
89730: ARRAY
89731: PPUSH
89732: CALL_OW 264
89736: PUSH
89737: LD_INT 49
89739: EQUAL
89740: IFFALSE 89861
// begin if not HasTask ( group [ i ] ) then
89742: LD_VAR 0 4
89746: PUSH
89747: LD_VAR 0 7
89751: ARRAY
89752: PPUSH
89753: CALL_OW 314
89757: NOT
89758: IFFALSE 89861
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
89760: LD_ADDR_VAR 0 9
89764: PUSH
89765: LD_INT 81
89767: PUSH
89768: LD_VAR 0 4
89772: PUSH
89773: LD_VAR 0 7
89777: ARRAY
89778: PPUSH
89779: CALL_OW 255
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: PPUSH
89788: CALL_OW 69
89792: PPUSH
89793: LD_VAR 0 4
89797: PUSH
89798: LD_VAR 0 7
89802: ARRAY
89803: PPUSH
89804: CALL_OW 74
89808: ST_TO_ADDR
// if k then
89809: LD_VAR 0 9
89813: IFFALSE 89861
// if GetDistUnits ( group [ i ] , k ) > 10 then
89815: LD_VAR 0 4
89819: PUSH
89820: LD_VAR 0 7
89824: ARRAY
89825: PPUSH
89826: LD_VAR 0 9
89830: PPUSH
89831: CALL_OW 296
89835: PUSH
89836: LD_INT 10
89838: GREATER
89839: IFFALSE 89861
// ComMoveUnit ( group [ i ] , k ) ;
89841: LD_VAR 0 4
89845: PUSH
89846: LD_VAR 0 7
89850: ARRAY
89851: PPUSH
89852: LD_VAR 0 9
89856: PPUSH
89857: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
89861: LD_VAR 0 4
89865: PUSH
89866: LD_VAR 0 7
89870: ARRAY
89871: PPUSH
89872: CALL_OW 256
89876: PUSH
89877: LD_INT 250
89879: LESS
89880: PUSH
89881: LD_VAR 0 4
89885: PUSH
89886: LD_VAR 0 7
89890: ARRAY
89891: PUSH
89892: LD_INT 21
89894: PUSH
89895: LD_INT 2
89897: PUSH
89898: EMPTY
89899: LIST
89900: LIST
89901: PUSH
89902: LD_INT 23
89904: PUSH
89905: LD_INT 2
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: PUSH
89912: EMPTY
89913: LIST
89914: LIST
89915: PPUSH
89916: CALL_OW 69
89920: IN
89921: AND
89922: IFFALSE 90047
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
89924: LD_ADDR_VAR 0 9
89928: PUSH
89929: LD_OWVAR 3
89933: PUSH
89934: LD_VAR 0 4
89938: PUSH
89939: LD_VAR 0 7
89943: ARRAY
89944: DIFF
89945: PPUSH
89946: LD_VAR 0 4
89950: PUSH
89951: LD_VAR 0 7
89955: ARRAY
89956: PPUSH
89957: CALL_OW 74
89961: ST_TO_ADDR
// if not k then
89962: LD_VAR 0 9
89966: NOT
89967: IFFALSE 89971
// continue ;
89969: GO 86412
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
89971: LD_VAR 0 9
89975: PUSH
89976: LD_INT 81
89978: PUSH
89979: LD_VAR 0 4
89983: PUSH
89984: LD_VAR 0 7
89988: ARRAY
89989: PPUSH
89990: CALL_OW 255
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PPUSH
89999: CALL_OW 69
90003: IN
90004: PUSH
90005: LD_VAR 0 9
90009: PPUSH
90010: LD_VAR 0 4
90014: PUSH
90015: LD_VAR 0 7
90019: ARRAY
90020: PPUSH
90021: CALL_OW 296
90025: PUSH
90026: LD_INT 5
90028: LESS
90029: AND
90030: IFFALSE 90047
// ComAutodestruct ( group [ i ] ) ;
90032: LD_VAR 0 4
90036: PUSH
90037: LD_VAR 0 7
90041: ARRAY
90042: PPUSH
90043: CALL 84507 0 1
// end ; if f_attack_depot then
90047: LD_VAR 0 25
90051: IFFALSE 90163
// begin k := 6 ;
90053: LD_ADDR_VAR 0 9
90057: PUSH
90058: LD_INT 6
90060: ST_TO_ADDR
// if tmp < k then
90061: LD_VAR 0 14
90065: PUSH
90066: LD_VAR 0 9
90070: LESS
90071: IFFALSE 90083
// k := tmp ;
90073: LD_ADDR_VAR 0 9
90077: PUSH
90078: LD_VAR 0 14
90082: ST_TO_ADDR
// for j = 1 to k do
90083: LD_ADDR_VAR 0 8
90087: PUSH
90088: DOUBLE
90089: LD_INT 1
90091: DEC
90092: ST_TO_ADDR
90093: LD_VAR 0 9
90097: PUSH
90098: FOR_TO
90099: IFFALSE 90161
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90101: LD_VAR 0 8
90105: PPUSH
90106: CALL_OW 266
90110: PUSH
90111: LD_INT 0
90113: PUSH
90114: LD_INT 1
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: IN
90121: IFFALSE 90159
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90123: LD_VAR 0 4
90127: PUSH
90128: LD_VAR 0 7
90132: ARRAY
90133: PPUSH
90134: LD_VAR 0 14
90138: PUSH
90139: LD_VAR 0 8
90143: ARRAY
90144: PPUSH
90145: CALL_OW 115
// attacking := true ;
90149: LD_ADDR_VAR 0 29
90153: PUSH
90154: LD_INT 1
90156: ST_TO_ADDR
// break ;
90157: GO 90161
// end ;
90159: GO 90098
90161: POP
90162: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90163: LD_VAR 0 4
90167: PUSH
90168: LD_VAR 0 7
90172: ARRAY
90173: PPUSH
90174: CALL_OW 302
90178: PUSH
90179: LD_VAR 0 29
90183: NOT
90184: AND
90185: IFFALSE 90507
// begin if GetTag ( group [ i ] ) = 71 then
90187: LD_VAR 0 4
90191: PUSH
90192: LD_VAR 0 7
90196: ARRAY
90197: PPUSH
90198: CALL_OW 110
90202: PUSH
90203: LD_INT 71
90205: EQUAL
90206: IFFALSE 90247
// begin if HasTask ( group [ i ] ) then
90208: LD_VAR 0 4
90212: PUSH
90213: LD_VAR 0 7
90217: ARRAY
90218: PPUSH
90219: CALL_OW 314
90223: IFFALSE 90229
// continue else
90225: GO 86412
90227: GO 90247
// SetTag ( group [ i ] , 0 ) ;
90229: LD_VAR 0 4
90233: PUSH
90234: LD_VAR 0 7
90238: ARRAY
90239: PPUSH
90240: LD_INT 0
90242: PPUSH
90243: CALL_OW 109
// end ; k := 8 ;
90247: LD_ADDR_VAR 0 9
90251: PUSH
90252: LD_INT 8
90254: ST_TO_ADDR
// x := 0 ;
90255: LD_ADDR_VAR 0 10
90259: PUSH
90260: LD_INT 0
90262: ST_TO_ADDR
// if tmp < k then
90263: LD_VAR 0 14
90267: PUSH
90268: LD_VAR 0 9
90272: LESS
90273: IFFALSE 90285
// k := tmp ;
90275: LD_ADDR_VAR 0 9
90279: PUSH
90280: LD_VAR 0 14
90284: ST_TO_ADDR
// for j = 1 to k do
90285: LD_ADDR_VAR 0 8
90289: PUSH
90290: DOUBLE
90291: LD_INT 1
90293: DEC
90294: ST_TO_ADDR
90295: LD_VAR 0 9
90299: PUSH
90300: FOR_TO
90301: IFFALSE 90399
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90303: LD_VAR 0 14
90307: PUSH
90308: LD_VAR 0 8
90312: ARRAY
90313: PPUSH
90314: CALL_OW 247
90318: PUSH
90319: LD_INT 1
90321: EQUAL
90322: PUSH
90323: LD_VAR 0 14
90327: PUSH
90328: LD_VAR 0 8
90332: ARRAY
90333: PPUSH
90334: CALL_OW 256
90338: PUSH
90339: LD_INT 250
90341: LESS
90342: PUSH
90343: LD_VAR 0 20
90347: AND
90348: PUSH
90349: LD_VAR 0 20
90353: NOT
90354: PUSH
90355: LD_VAR 0 14
90359: PUSH
90360: LD_VAR 0 8
90364: ARRAY
90365: PPUSH
90366: CALL_OW 256
90370: PUSH
90371: LD_INT 250
90373: GREATEREQUAL
90374: AND
90375: OR
90376: AND
90377: IFFALSE 90397
// begin x := tmp [ j ] ;
90379: LD_ADDR_VAR 0 10
90383: PUSH
90384: LD_VAR 0 14
90388: PUSH
90389: LD_VAR 0 8
90393: ARRAY
90394: ST_TO_ADDR
// break ;
90395: GO 90399
// end ;
90397: GO 90300
90399: POP
90400: POP
// if x then
90401: LD_VAR 0 10
90405: IFFALSE 90429
// ComAttackUnit ( group [ i ] , x ) else
90407: LD_VAR 0 4
90411: PUSH
90412: LD_VAR 0 7
90416: ARRAY
90417: PPUSH
90418: LD_VAR 0 10
90422: PPUSH
90423: CALL_OW 115
90427: GO 90453
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90429: LD_VAR 0 4
90433: PUSH
90434: LD_VAR 0 7
90438: ARRAY
90439: PPUSH
90440: LD_VAR 0 14
90444: PUSH
90445: LD_INT 1
90447: ARRAY
90448: PPUSH
90449: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90453: LD_VAR 0 4
90457: PUSH
90458: LD_VAR 0 7
90462: ARRAY
90463: PPUSH
90464: CALL_OW 314
90468: NOT
90469: IFFALSE 90507
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90471: LD_VAR 0 4
90475: PUSH
90476: LD_VAR 0 7
90480: ARRAY
90481: PPUSH
90482: LD_VAR 0 14
90486: PPUSH
90487: LD_VAR 0 4
90491: PUSH
90492: LD_VAR 0 7
90496: ARRAY
90497: PPUSH
90498: CALL_OW 74
90502: PPUSH
90503: CALL_OW 115
// end ; end ; end ;
90507: GO 86412
90509: POP
90510: POP
// wait ( 0 0$1 ) ;
90511: LD_INT 35
90513: PPUSH
90514: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90518: LD_VAR 0 4
90522: PUSH
90523: EMPTY
90524: EQUAL
90525: PUSH
90526: LD_INT 81
90528: PUSH
90529: LD_VAR 0 35
90533: PUSH
90534: EMPTY
90535: LIST
90536: LIST
90537: PPUSH
90538: CALL_OW 69
90542: NOT
90543: OR
90544: IFFALSE 86397
// end ;
90546: LD_VAR 0 2
90550: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90551: LD_INT 0
90553: PPUSH
90554: PPUSH
90555: PPUSH
90556: PPUSH
// if not base_units then
90557: LD_VAR 0 1
90561: NOT
90562: IFFALSE 90566
// exit ;
90564: GO 90653
// result := false ;
90566: LD_ADDR_VAR 0 2
90570: PUSH
90571: LD_INT 0
90573: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90574: LD_ADDR_VAR 0 5
90578: PUSH
90579: LD_VAR 0 1
90583: PPUSH
90584: LD_INT 21
90586: PUSH
90587: LD_INT 3
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PPUSH
90594: CALL_OW 72
90598: ST_TO_ADDR
// if not tmp then
90599: LD_VAR 0 5
90603: NOT
90604: IFFALSE 90608
// exit ;
90606: GO 90653
// for i in tmp do
90608: LD_ADDR_VAR 0 3
90612: PUSH
90613: LD_VAR 0 5
90617: PUSH
90618: FOR_IN
90619: IFFALSE 90651
// begin result := EnemyInRange ( i , 22 ) ;
90621: LD_ADDR_VAR 0 2
90625: PUSH
90626: LD_VAR 0 3
90630: PPUSH
90631: LD_INT 22
90633: PPUSH
90634: CALL 84190 0 2
90638: ST_TO_ADDR
// if result then
90639: LD_VAR 0 2
90643: IFFALSE 90649
// exit ;
90645: POP
90646: POP
90647: GO 90653
// end ;
90649: GO 90618
90651: POP
90652: POP
// end ;
90653: LD_VAR 0 2
90657: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
90658: LD_INT 0
90660: PPUSH
90661: PPUSH
// if not units then
90662: LD_VAR 0 1
90666: NOT
90667: IFFALSE 90671
// exit ;
90669: GO 90741
// result := [ ] ;
90671: LD_ADDR_VAR 0 3
90675: PUSH
90676: EMPTY
90677: ST_TO_ADDR
// for i in units do
90678: LD_ADDR_VAR 0 4
90682: PUSH
90683: LD_VAR 0 1
90687: PUSH
90688: FOR_IN
90689: IFFALSE 90739
// if GetTag ( i ) = tag then
90691: LD_VAR 0 4
90695: PPUSH
90696: CALL_OW 110
90700: PUSH
90701: LD_VAR 0 2
90705: EQUAL
90706: IFFALSE 90737
// result := Insert ( result , result + 1 , i ) ;
90708: LD_ADDR_VAR 0 3
90712: PUSH
90713: LD_VAR 0 3
90717: PPUSH
90718: LD_VAR 0 3
90722: PUSH
90723: LD_INT 1
90725: PLUS
90726: PPUSH
90727: LD_VAR 0 4
90731: PPUSH
90732: CALL_OW 2
90736: ST_TO_ADDR
90737: GO 90688
90739: POP
90740: POP
// end ;
90741: LD_VAR 0 3
90745: RET
// export function IsDriver ( un ) ; begin
90746: LD_INT 0
90748: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
90749: LD_ADDR_VAR 0 2
90753: PUSH
90754: LD_VAR 0 1
90758: PUSH
90759: LD_INT 55
90761: PUSH
90762: EMPTY
90763: LIST
90764: PPUSH
90765: CALL_OW 69
90769: IN
90770: ST_TO_ADDR
// end ;
90771: LD_VAR 0 2
90775: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
90776: LD_INT 0
90778: PPUSH
90779: PPUSH
// list := [ ] ;
90780: LD_ADDR_VAR 0 5
90784: PUSH
90785: EMPTY
90786: ST_TO_ADDR
// case d of 0 :
90787: LD_VAR 0 3
90791: PUSH
90792: LD_INT 0
90794: DOUBLE
90795: EQUAL
90796: IFTRUE 90800
90798: GO 90933
90800: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
90801: LD_ADDR_VAR 0 5
90805: PUSH
90806: LD_VAR 0 1
90810: PUSH
90811: LD_INT 4
90813: MINUS
90814: PUSH
90815: LD_VAR 0 2
90819: PUSH
90820: LD_INT 4
90822: MINUS
90823: PUSH
90824: LD_INT 2
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: LIST
90831: PUSH
90832: LD_VAR 0 1
90836: PUSH
90837: LD_INT 3
90839: MINUS
90840: PUSH
90841: LD_VAR 0 2
90845: PUSH
90846: LD_INT 1
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: LIST
90853: PUSH
90854: LD_VAR 0 1
90858: PUSH
90859: LD_INT 4
90861: PLUS
90862: PUSH
90863: LD_VAR 0 2
90867: PUSH
90868: LD_INT 4
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: LIST
90875: PUSH
90876: LD_VAR 0 1
90880: PUSH
90881: LD_INT 3
90883: PLUS
90884: PUSH
90885: LD_VAR 0 2
90889: PUSH
90890: LD_INT 3
90892: PLUS
90893: PUSH
90894: LD_INT 5
90896: PUSH
90897: EMPTY
90898: LIST
90899: LIST
90900: LIST
90901: PUSH
90902: LD_VAR 0 1
90906: PUSH
90907: LD_VAR 0 2
90911: PUSH
90912: LD_INT 4
90914: PLUS
90915: PUSH
90916: LD_INT 0
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: LIST
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: LIST
90930: ST_TO_ADDR
// end ; 1 :
90931: GO 91631
90933: LD_INT 1
90935: DOUBLE
90936: EQUAL
90937: IFTRUE 90941
90939: GO 91074
90941: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
90942: LD_ADDR_VAR 0 5
90946: PUSH
90947: LD_VAR 0 1
90951: PUSH
90952: LD_VAR 0 2
90956: PUSH
90957: LD_INT 4
90959: MINUS
90960: PUSH
90961: LD_INT 3
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: LIST
90968: PUSH
90969: LD_VAR 0 1
90973: PUSH
90974: LD_INT 3
90976: MINUS
90977: PUSH
90978: LD_VAR 0 2
90982: PUSH
90983: LD_INT 3
90985: MINUS
90986: PUSH
90987: LD_INT 2
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: LIST
90994: PUSH
90995: LD_VAR 0 1
90999: PUSH
91000: LD_INT 4
91002: MINUS
91003: PUSH
91004: LD_VAR 0 2
91008: PUSH
91009: LD_INT 1
91011: PUSH
91012: EMPTY
91013: LIST
91014: LIST
91015: LIST
91016: PUSH
91017: LD_VAR 0 1
91021: PUSH
91022: LD_VAR 0 2
91026: PUSH
91027: LD_INT 3
91029: PLUS
91030: PUSH
91031: LD_INT 0
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: LIST
91038: PUSH
91039: LD_VAR 0 1
91043: PUSH
91044: LD_INT 4
91046: PLUS
91047: PUSH
91048: LD_VAR 0 2
91052: PUSH
91053: LD_INT 4
91055: PLUS
91056: PUSH
91057: LD_INT 5
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: LIST
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: LIST
91069: LIST
91070: LIST
91071: ST_TO_ADDR
// end ; 2 :
91072: GO 91631
91074: LD_INT 2
91076: DOUBLE
91077: EQUAL
91078: IFTRUE 91082
91080: GO 91211
91082: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91083: LD_ADDR_VAR 0 5
91087: PUSH
91088: LD_VAR 0 1
91092: PUSH
91093: LD_VAR 0 2
91097: PUSH
91098: LD_INT 3
91100: MINUS
91101: PUSH
91102: LD_INT 3
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: LIST
91109: PUSH
91110: LD_VAR 0 1
91114: PUSH
91115: LD_INT 4
91117: PLUS
91118: PUSH
91119: LD_VAR 0 2
91123: PUSH
91124: LD_INT 4
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: LIST
91131: PUSH
91132: LD_VAR 0 1
91136: PUSH
91137: LD_VAR 0 2
91141: PUSH
91142: LD_INT 4
91144: PLUS
91145: PUSH
91146: LD_INT 0
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: LIST
91153: PUSH
91154: LD_VAR 0 1
91158: PUSH
91159: LD_INT 3
91161: MINUS
91162: PUSH
91163: LD_VAR 0 2
91167: PUSH
91168: LD_INT 1
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: LIST
91175: PUSH
91176: LD_VAR 0 1
91180: PUSH
91181: LD_INT 4
91183: MINUS
91184: PUSH
91185: LD_VAR 0 2
91189: PUSH
91190: LD_INT 4
91192: MINUS
91193: PUSH
91194: LD_INT 2
91196: PUSH
91197: EMPTY
91198: LIST
91199: LIST
91200: LIST
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: ST_TO_ADDR
// end ; 3 :
91209: GO 91631
91211: LD_INT 3
91213: DOUBLE
91214: EQUAL
91215: IFTRUE 91219
91217: GO 91352
91219: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
91220: LD_ADDR_VAR 0 5
91224: PUSH
91225: LD_VAR 0 1
91229: PUSH
91230: LD_INT 3
91232: PLUS
91233: PUSH
91234: LD_VAR 0 2
91238: PUSH
91239: LD_INT 4
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: LIST
91246: PUSH
91247: LD_VAR 0 1
91251: PUSH
91252: LD_INT 4
91254: PLUS
91255: PUSH
91256: LD_VAR 0 2
91260: PUSH
91261: LD_INT 4
91263: PLUS
91264: PUSH
91265: LD_INT 5
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: LIST
91272: PUSH
91273: LD_VAR 0 1
91277: PUSH
91278: LD_INT 4
91280: MINUS
91281: PUSH
91282: LD_VAR 0 2
91286: PUSH
91287: LD_INT 1
91289: PUSH
91290: EMPTY
91291: LIST
91292: LIST
91293: LIST
91294: PUSH
91295: LD_VAR 0 1
91299: PUSH
91300: LD_VAR 0 2
91304: PUSH
91305: LD_INT 4
91307: MINUS
91308: PUSH
91309: LD_INT 3
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: LIST
91316: PUSH
91317: LD_VAR 0 1
91321: PUSH
91322: LD_INT 3
91324: MINUS
91325: PUSH
91326: LD_VAR 0 2
91330: PUSH
91331: LD_INT 3
91333: MINUS
91334: PUSH
91335: LD_INT 2
91337: PUSH
91338: EMPTY
91339: LIST
91340: LIST
91341: LIST
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: ST_TO_ADDR
// end ; 4 :
91350: GO 91631
91352: LD_INT 4
91354: DOUBLE
91355: EQUAL
91356: IFTRUE 91360
91358: GO 91493
91360: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
91361: LD_ADDR_VAR 0 5
91365: PUSH
91366: LD_VAR 0 1
91370: PUSH
91371: LD_VAR 0 2
91375: PUSH
91376: LD_INT 4
91378: PLUS
91379: PUSH
91380: LD_INT 0
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: LIST
91387: PUSH
91388: LD_VAR 0 1
91392: PUSH
91393: LD_INT 3
91395: PLUS
91396: PUSH
91397: LD_VAR 0 2
91401: PUSH
91402: LD_INT 3
91404: PLUS
91405: PUSH
91406: LD_INT 5
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: LIST
91413: PUSH
91414: LD_VAR 0 1
91418: PUSH
91419: LD_INT 4
91421: PLUS
91422: PUSH
91423: LD_VAR 0 2
91427: PUSH
91428: LD_INT 4
91430: PUSH
91431: EMPTY
91432: LIST
91433: LIST
91434: LIST
91435: PUSH
91436: LD_VAR 0 1
91440: PUSH
91441: LD_VAR 0 2
91445: PUSH
91446: LD_INT 3
91448: MINUS
91449: PUSH
91450: LD_INT 3
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: LIST
91457: PUSH
91458: LD_VAR 0 1
91462: PUSH
91463: LD_INT 4
91465: MINUS
91466: PUSH
91467: LD_VAR 0 2
91471: PUSH
91472: LD_INT 4
91474: MINUS
91475: PUSH
91476: LD_INT 2
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: LIST
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: LIST
91488: LIST
91489: LIST
91490: ST_TO_ADDR
// end ; 5 :
91491: GO 91631
91493: LD_INT 5
91495: DOUBLE
91496: EQUAL
91497: IFTRUE 91501
91499: GO 91630
91501: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91502: LD_ADDR_VAR 0 5
91506: PUSH
91507: LD_VAR 0 1
91511: PUSH
91512: LD_INT 4
91514: MINUS
91515: PUSH
91516: LD_VAR 0 2
91520: PUSH
91521: LD_INT 1
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: LIST
91528: PUSH
91529: LD_VAR 0 1
91533: PUSH
91534: LD_VAR 0 2
91538: PUSH
91539: LD_INT 4
91541: MINUS
91542: PUSH
91543: LD_INT 3
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: LIST
91550: PUSH
91551: LD_VAR 0 1
91555: PUSH
91556: LD_INT 4
91558: PLUS
91559: PUSH
91560: LD_VAR 0 2
91564: PUSH
91565: LD_INT 4
91567: PLUS
91568: PUSH
91569: LD_INT 5
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: LIST
91576: PUSH
91577: LD_VAR 0 1
91581: PUSH
91582: LD_INT 3
91584: PLUS
91585: PUSH
91586: LD_VAR 0 2
91590: PUSH
91591: LD_INT 4
91593: PUSH
91594: EMPTY
91595: LIST
91596: LIST
91597: LIST
91598: PUSH
91599: LD_VAR 0 1
91603: PUSH
91604: LD_VAR 0 2
91608: PUSH
91609: LD_INT 3
91611: PLUS
91612: PUSH
91613: LD_INT 0
91615: PUSH
91616: EMPTY
91617: LIST
91618: LIST
91619: LIST
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: ST_TO_ADDR
// end ; end ;
91628: GO 91631
91630: POP
// result := list ;
91631: LD_ADDR_VAR 0 4
91635: PUSH
91636: LD_VAR 0 5
91640: ST_TO_ADDR
// end ;
91641: LD_VAR 0 4
91645: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91646: LD_INT 0
91648: PPUSH
91649: PPUSH
91650: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91651: LD_VAR 0 1
91655: NOT
91656: PUSH
91657: LD_VAR 0 2
91661: PUSH
91662: LD_INT 1
91664: PUSH
91665: LD_INT 2
91667: PUSH
91668: LD_INT 3
91670: PUSH
91671: LD_INT 4
91673: PUSH
91674: EMPTY
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: IN
91680: NOT
91681: OR
91682: IFFALSE 91686
// exit ;
91684: GO 91778
// tmp := [ ] ;
91686: LD_ADDR_VAR 0 5
91690: PUSH
91691: EMPTY
91692: ST_TO_ADDR
// for i in units do
91693: LD_ADDR_VAR 0 4
91697: PUSH
91698: LD_VAR 0 1
91702: PUSH
91703: FOR_IN
91704: IFFALSE 91747
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
91706: LD_ADDR_VAR 0 5
91710: PUSH
91711: LD_VAR 0 5
91715: PPUSH
91716: LD_VAR 0 5
91720: PUSH
91721: LD_INT 1
91723: PLUS
91724: PPUSH
91725: LD_VAR 0 4
91729: PPUSH
91730: LD_VAR 0 2
91734: PPUSH
91735: CALL_OW 259
91739: PPUSH
91740: CALL_OW 2
91744: ST_TO_ADDR
91745: GO 91703
91747: POP
91748: POP
// if not tmp then
91749: LD_VAR 0 5
91753: NOT
91754: IFFALSE 91758
// exit ;
91756: GO 91778
// result := SortListByListDesc ( units , tmp ) ;
91758: LD_ADDR_VAR 0 3
91762: PUSH
91763: LD_VAR 0 1
91767: PPUSH
91768: LD_VAR 0 5
91772: PPUSH
91773: CALL_OW 77
91777: ST_TO_ADDR
// end ;
91778: LD_VAR 0 3
91782: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
91783: LD_INT 0
91785: PPUSH
91786: PPUSH
91787: PPUSH
// x := GetX ( building ) ;
91788: LD_ADDR_VAR 0 4
91792: PUSH
91793: LD_VAR 0 2
91797: PPUSH
91798: CALL_OW 250
91802: ST_TO_ADDR
// y := GetY ( building ) ;
91803: LD_ADDR_VAR 0 5
91807: PUSH
91808: LD_VAR 0 2
91812: PPUSH
91813: CALL_OW 251
91817: ST_TO_ADDR
// if GetTaskList ( unit ) then
91818: LD_VAR 0 1
91822: PPUSH
91823: CALL_OW 437
91827: IFFALSE 91922
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91829: LD_STRING e
91831: PUSH
91832: LD_VAR 0 1
91836: PPUSH
91837: CALL_OW 437
91841: PUSH
91842: LD_INT 1
91844: ARRAY
91845: PUSH
91846: LD_INT 1
91848: ARRAY
91849: EQUAL
91850: PUSH
91851: LD_VAR 0 4
91855: PUSH
91856: LD_VAR 0 1
91860: PPUSH
91861: CALL_OW 437
91865: PUSH
91866: LD_INT 1
91868: ARRAY
91869: PUSH
91870: LD_INT 2
91872: ARRAY
91873: EQUAL
91874: AND
91875: PUSH
91876: LD_VAR 0 5
91880: PUSH
91881: LD_VAR 0 1
91885: PPUSH
91886: CALL_OW 437
91890: PUSH
91891: LD_INT 1
91893: ARRAY
91894: PUSH
91895: LD_INT 3
91897: ARRAY
91898: EQUAL
91899: AND
91900: IFFALSE 91912
// result := true else
91902: LD_ADDR_VAR 0 3
91906: PUSH
91907: LD_INT 1
91909: ST_TO_ADDR
91910: GO 91920
// result := false ;
91912: LD_ADDR_VAR 0 3
91916: PUSH
91917: LD_INT 0
91919: ST_TO_ADDR
// end else
91920: GO 91930
// result := false ;
91922: LD_ADDR_VAR 0 3
91926: PUSH
91927: LD_INT 0
91929: ST_TO_ADDR
// end ;
91930: LD_VAR 0 3
91934: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
91935: LD_INT 0
91937: PPUSH
91938: PPUSH
91939: PPUSH
91940: PPUSH
// if not unit or not area then
91941: LD_VAR 0 1
91945: NOT
91946: PUSH
91947: LD_VAR 0 2
91951: NOT
91952: OR
91953: IFFALSE 91957
// exit ;
91955: GO 92121
// tmp := AreaToList ( area , i ) ;
91957: LD_ADDR_VAR 0 6
91961: PUSH
91962: LD_VAR 0 2
91966: PPUSH
91967: LD_VAR 0 5
91971: PPUSH
91972: CALL_OW 517
91976: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
91977: LD_ADDR_VAR 0 5
91981: PUSH
91982: DOUBLE
91983: LD_INT 1
91985: DEC
91986: ST_TO_ADDR
91987: LD_VAR 0 6
91991: PUSH
91992: LD_INT 1
91994: ARRAY
91995: PUSH
91996: FOR_TO
91997: IFFALSE 92119
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
91999: LD_ADDR_VAR 0 7
92003: PUSH
92004: LD_VAR 0 6
92008: PUSH
92009: LD_INT 1
92011: ARRAY
92012: PUSH
92013: LD_VAR 0 5
92017: ARRAY
92018: PUSH
92019: LD_VAR 0 6
92023: PUSH
92024: LD_INT 2
92026: ARRAY
92027: PUSH
92028: LD_VAR 0 5
92032: ARRAY
92033: PUSH
92034: EMPTY
92035: LIST
92036: LIST
92037: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92038: LD_VAR 0 7
92042: PUSH
92043: LD_INT 1
92045: ARRAY
92046: PPUSH
92047: LD_VAR 0 7
92051: PUSH
92052: LD_INT 2
92054: ARRAY
92055: PPUSH
92056: CALL_OW 428
92060: PUSH
92061: LD_INT 0
92063: EQUAL
92064: IFFALSE 92117
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92066: LD_VAR 0 1
92070: PPUSH
92071: LD_VAR 0 7
92075: PUSH
92076: LD_INT 1
92078: ARRAY
92079: PPUSH
92080: LD_VAR 0 7
92084: PUSH
92085: LD_INT 2
92087: ARRAY
92088: PPUSH
92089: LD_VAR 0 3
92093: PPUSH
92094: CALL_OW 48
// result := IsPlaced ( unit ) ;
92098: LD_ADDR_VAR 0 4
92102: PUSH
92103: LD_VAR 0 1
92107: PPUSH
92108: CALL_OW 305
92112: ST_TO_ADDR
// exit ;
92113: POP
92114: POP
92115: GO 92121
// end ; end ;
92117: GO 91996
92119: POP
92120: POP
// end ;
92121: LD_VAR 0 4
92125: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92126: LD_INT 0
92128: PPUSH
92129: PPUSH
92130: PPUSH
// if not side or side > 8 then
92131: LD_VAR 0 1
92135: NOT
92136: PUSH
92137: LD_VAR 0 1
92141: PUSH
92142: LD_INT 8
92144: GREATER
92145: OR
92146: IFFALSE 92150
// exit ;
92148: GO 92337
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92150: LD_ADDR_VAR 0 4
92154: PUSH
92155: LD_INT 22
92157: PUSH
92158: LD_VAR 0 1
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: LD_INT 21
92169: PUSH
92170: LD_INT 3
92172: PUSH
92173: EMPTY
92174: LIST
92175: LIST
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PPUSH
92181: CALL_OW 69
92185: ST_TO_ADDR
// if not tmp then
92186: LD_VAR 0 4
92190: NOT
92191: IFFALSE 92195
// exit ;
92193: GO 92337
// enable_addtolog := true ;
92195: LD_ADDR_OWVAR 81
92199: PUSH
92200: LD_INT 1
92202: ST_TO_ADDR
// AddToLog ( [ ) ;
92203: LD_STRING [
92205: PPUSH
92206: CALL_OW 561
// for i in tmp do
92210: LD_ADDR_VAR 0 3
92214: PUSH
92215: LD_VAR 0 4
92219: PUSH
92220: FOR_IN
92221: IFFALSE 92328
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
92223: LD_STRING [
92225: PUSH
92226: LD_VAR 0 3
92230: PPUSH
92231: CALL_OW 266
92235: STR
92236: PUSH
92237: LD_STRING , 
92239: STR
92240: PUSH
92241: LD_VAR 0 3
92245: PPUSH
92246: CALL_OW 250
92250: STR
92251: PUSH
92252: LD_STRING , 
92254: STR
92255: PUSH
92256: LD_VAR 0 3
92260: PPUSH
92261: CALL_OW 251
92265: STR
92266: PUSH
92267: LD_STRING , 
92269: STR
92270: PUSH
92271: LD_VAR 0 3
92275: PPUSH
92276: CALL_OW 254
92280: STR
92281: PUSH
92282: LD_STRING , 
92284: STR
92285: PUSH
92286: LD_VAR 0 3
92290: PPUSH
92291: LD_INT 1
92293: PPUSH
92294: CALL_OW 268
92298: STR
92299: PUSH
92300: LD_STRING , 
92302: STR
92303: PUSH
92304: LD_VAR 0 3
92308: PPUSH
92309: LD_INT 2
92311: PPUSH
92312: CALL_OW 268
92316: STR
92317: PUSH
92318: LD_STRING ],
92320: STR
92321: PPUSH
92322: CALL_OW 561
// end ;
92326: GO 92220
92328: POP
92329: POP
// AddToLog ( ]; ) ;
92330: LD_STRING ];
92332: PPUSH
92333: CALL_OW 561
// end ;
92337: LD_VAR 0 2
92341: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
92342: LD_INT 0
92344: PPUSH
92345: PPUSH
92346: PPUSH
92347: PPUSH
92348: PPUSH
// if not area or not rate or not max then
92349: LD_VAR 0 1
92353: NOT
92354: PUSH
92355: LD_VAR 0 2
92359: NOT
92360: OR
92361: PUSH
92362: LD_VAR 0 4
92366: NOT
92367: OR
92368: IFFALSE 92372
// exit ;
92370: GO 92564
// while 1 do
92372: LD_INT 1
92374: IFFALSE 92564
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92376: LD_ADDR_VAR 0 9
92380: PUSH
92381: LD_VAR 0 1
92385: PPUSH
92386: LD_INT 1
92388: PPUSH
92389: CALL_OW 287
92393: PUSH
92394: LD_INT 10
92396: MUL
92397: ST_TO_ADDR
// r := rate / 10 ;
92398: LD_ADDR_VAR 0 7
92402: PUSH
92403: LD_VAR 0 2
92407: PUSH
92408: LD_INT 10
92410: DIVREAL
92411: ST_TO_ADDR
// time := 1 1$00 ;
92412: LD_ADDR_VAR 0 8
92416: PUSH
92417: LD_INT 2100
92419: ST_TO_ADDR
// if amount < min then
92420: LD_VAR 0 9
92424: PUSH
92425: LD_VAR 0 3
92429: LESS
92430: IFFALSE 92448
// r := r * 2 else
92432: LD_ADDR_VAR 0 7
92436: PUSH
92437: LD_VAR 0 7
92441: PUSH
92442: LD_INT 2
92444: MUL
92445: ST_TO_ADDR
92446: GO 92474
// if amount > max then
92448: LD_VAR 0 9
92452: PUSH
92453: LD_VAR 0 4
92457: GREATER
92458: IFFALSE 92474
// r := r / 2 ;
92460: LD_ADDR_VAR 0 7
92464: PUSH
92465: LD_VAR 0 7
92469: PUSH
92470: LD_INT 2
92472: DIVREAL
92473: ST_TO_ADDR
// time := time / r ;
92474: LD_ADDR_VAR 0 8
92478: PUSH
92479: LD_VAR 0 8
92483: PUSH
92484: LD_VAR 0 7
92488: DIVREAL
92489: ST_TO_ADDR
// if time < 0 then
92490: LD_VAR 0 8
92494: PUSH
92495: LD_INT 0
92497: LESS
92498: IFFALSE 92515
// time := time * - 1 ;
92500: LD_ADDR_VAR 0 8
92504: PUSH
92505: LD_VAR 0 8
92509: PUSH
92510: LD_INT 1
92512: NEG
92513: MUL
92514: ST_TO_ADDR
// wait ( time ) ;
92515: LD_VAR 0 8
92519: PPUSH
92520: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92524: LD_INT 35
92526: PPUSH
92527: LD_INT 875
92529: PPUSH
92530: CALL_OW 12
92534: PPUSH
92535: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92539: LD_INT 1
92541: PPUSH
92542: LD_INT 5
92544: PPUSH
92545: CALL_OW 12
92549: PPUSH
92550: LD_VAR 0 1
92554: PPUSH
92555: LD_INT 1
92557: PPUSH
92558: CALL_OW 55
// end ;
92562: GO 92372
// end ;
92564: LD_VAR 0 5
92568: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92569: LD_INT 0
92571: PPUSH
92572: PPUSH
92573: PPUSH
92574: PPUSH
92575: PPUSH
92576: PPUSH
92577: PPUSH
92578: PPUSH
// if not turrets or not factories then
92579: LD_VAR 0 1
92583: NOT
92584: PUSH
92585: LD_VAR 0 2
92589: NOT
92590: OR
92591: IFFALSE 92595
// exit ;
92593: GO 92902
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92595: LD_ADDR_VAR 0 10
92599: PUSH
92600: LD_INT 5
92602: PUSH
92603: LD_INT 6
92605: PUSH
92606: EMPTY
92607: LIST
92608: LIST
92609: PUSH
92610: LD_INT 2
92612: PUSH
92613: LD_INT 4
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: PUSH
92620: LD_INT 3
92622: PUSH
92623: LD_INT 5
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: LIST
92634: PUSH
92635: LD_INT 24
92637: PUSH
92638: LD_INT 25
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: LD_INT 23
92647: PUSH
92648: LD_INT 27
92650: PUSH
92651: EMPTY
92652: LIST
92653: LIST
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: PUSH
92659: LD_INT 42
92661: PUSH
92662: LD_INT 43
92664: PUSH
92665: EMPTY
92666: LIST
92667: LIST
92668: PUSH
92669: LD_INT 44
92671: PUSH
92672: LD_INT 46
92674: PUSH
92675: EMPTY
92676: LIST
92677: LIST
92678: PUSH
92679: LD_INT 45
92681: PUSH
92682: LD_INT 47
92684: PUSH
92685: EMPTY
92686: LIST
92687: LIST
92688: PUSH
92689: EMPTY
92690: LIST
92691: LIST
92692: LIST
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: LIST
92698: ST_TO_ADDR
// result := [ ] ;
92699: LD_ADDR_VAR 0 3
92703: PUSH
92704: EMPTY
92705: ST_TO_ADDR
// for i in turrets do
92706: LD_ADDR_VAR 0 4
92710: PUSH
92711: LD_VAR 0 1
92715: PUSH
92716: FOR_IN
92717: IFFALSE 92900
// begin nat := GetNation ( i ) ;
92719: LD_ADDR_VAR 0 7
92723: PUSH
92724: LD_VAR 0 4
92728: PPUSH
92729: CALL_OW 248
92733: ST_TO_ADDR
// weapon := 0 ;
92734: LD_ADDR_VAR 0 8
92738: PUSH
92739: LD_INT 0
92741: ST_TO_ADDR
// if not nat then
92742: LD_VAR 0 7
92746: NOT
92747: IFFALSE 92751
// continue ;
92749: GO 92716
// for j in list [ nat ] do
92751: LD_ADDR_VAR 0 5
92755: PUSH
92756: LD_VAR 0 10
92760: PUSH
92761: LD_VAR 0 7
92765: ARRAY
92766: PUSH
92767: FOR_IN
92768: IFFALSE 92809
// if GetBWeapon ( i ) = j [ 1 ] then
92770: LD_VAR 0 4
92774: PPUSH
92775: CALL_OW 269
92779: PUSH
92780: LD_VAR 0 5
92784: PUSH
92785: LD_INT 1
92787: ARRAY
92788: EQUAL
92789: IFFALSE 92807
// begin weapon := j [ 2 ] ;
92791: LD_ADDR_VAR 0 8
92795: PUSH
92796: LD_VAR 0 5
92800: PUSH
92801: LD_INT 2
92803: ARRAY
92804: ST_TO_ADDR
// break ;
92805: GO 92809
// end ;
92807: GO 92767
92809: POP
92810: POP
// if not weapon then
92811: LD_VAR 0 8
92815: NOT
92816: IFFALSE 92820
// continue ;
92818: GO 92716
// for k in factories do
92820: LD_ADDR_VAR 0 6
92824: PUSH
92825: LD_VAR 0 2
92829: PUSH
92830: FOR_IN
92831: IFFALSE 92896
// begin weapons := AvailableWeaponList ( k ) ;
92833: LD_ADDR_VAR 0 9
92837: PUSH
92838: LD_VAR 0 6
92842: PPUSH
92843: CALL_OW 478
92847: ST_TO_ADDR
// if not weapons then
92848: LD_VAR 0 9
92852: NOT
92853: IFFALSE 92857
// continue ;
92855: GO 92830
// if weapon in weapons then
92857: LD_VAR 0 8
92861: PUSH
92862: LD_VAR 0 9
92866: IN
92867: IFFALSE 92894
// begin result := [ i , weapon ] ;
92869: LD_ADDR_VAR 0 3
92873: PUSH
92874: LD_VAR 0 4
92878: PUSH
92879: LD_VAR 0 8
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: ST_TO_ADDR
// exit ;
92888: POP
92889: POP
92890: POP
92891: POP
92892: GO 92902
// end ; end ;
92894: GO 92830
92896: POP
92897: POP
// end ;
92898: GO 92716
92900: POP
92901: POP
// end ;
92902: LD_VAR 0 3
92906: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
92907: LD_INT 0
92909: PPUSH
// if not side or side > 8 then
92910: LD_VAR 0 3
92914: NOT
92915: PUSH
92916: LD_VAR 0 3
92920: PUSH
92921: LD_INT 8
92923: GREATER
92924: OR
92925: IFFALSE 92929
// exit ;
92927: GO 92988
// if not range then
92929: LD_VAR 0 4
92933: NOT
92934: IFFALSE 92945
// range := - 12 ;
92936: LD_ADDR_VAR 0 4
92940: PUSH
92941: LD_INT 12
92943: NEG
92944: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
92945: LD_VAR 0 1
92949: PPUSH
92950: LD_VAR 0 2
92954: PPUSH
92955: LD_VAR 0 3
92959: PPUSH
92960: LD_VAR 0 4
92964: PPUSH
92965: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
92969: LD_VAR 0 1
92973: PPUSH
92974: LD_VAR 0 2
92978: PPUSH
92979: LD_VAR 0 3
92983: PPUSH
92984: CALL_OW 331
// end ;
92988: LD_VAR 0 5
92992: RET
// export function Video ( mode ) ; begin
92993: LD_INT 0
92995: PPUSH
// ingame_video = mode ;
92996: LD_ADDR_OWVAR 52
93000: PUSH
93001: LD_VAR 0 1
93005: ST_TO_ADDR
// interface_hidden = mode ;
93006: LD_ADDR_OWVAR 54
93010: PUSH
93011: LD_VAR 0 1
93015: ST_TO_ADDR
// end ;
93016: LD_VAR 0 2
93020: RET
// export function Join ( array , element ) ; begin
93021: LD_INT 0
93023: PPUSH
// result := array ^ element ;
93024: LD_ADDR_VAR 0 3
93028: PUSH
93029: LD_VAR 0 1
93033: PUSH
93034: LD_VAR 0 2
93038: ADD
93039: ST_TO_ADDR
// end ;
93040: LD_VAR 0 3
93044: RET
// export function JoinUnion ( array , element ) ; begin
93045: LD_INT 0
93047: PPUSH
// result := array union element ;
93048: LD_ADDR_VAR 0 3
93052: PUSH
93053: LD_VAR 0 1
93057: PUSH
93058: LD_VAR 0 2
93062: UNION
93063: ST_TO_ADDR
// end ;
93064: LD_VAR 0 3
93068: RET
// export function GetBehemoths ( side ) ; begin
93069: LD_INT 0
93071: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93072: LD_ADDR_VAR 0 2
93076: PUSH
93077: LD_INT 22
93079: PUSH
93080: LD_VAR 0 1
93084: PUSH
93085: EMPTY
93086: LIST
93087: LIST
93088: PUSH
93089: LD_INT 31
93091: PUSH
93092: LD_INT 25
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PPUSH
93103: CALL_OW 69
93107: ST_TO_ADDR
// end ;
93108: LD_VAR 0 2
93112: RET
// export function Shuffle ( array ) ; var i , index ; begin
93113: LD_INT 0
93115: PPUSH
93116: PPUSH
93117: PPUSH
// result := [ ] ;
93118: LD_ADDR_VAR 0 2
93122: PUSH
93123: EMPTY
93124: ST_TO_ADDR
// if not array then
93125: LD_VAR 0 1
93129: NOT
93130: IFFALSE 93134
// exit ;
93132: GO 93233
// Randomize ;
93134: CALL_OW 10
// for i = array downto 1 do
93138: LD_ADDR_VAR 0 3
93142: PUSH
93143: DOUBLE
93144: LD_VAR 0 1
93148: INC
93149: ST_TO_ADDR
93150: LD_INT 1
93152: PUSH
93153: FOR_DOWNTO
93154: IFFALSE 93231
// begin index := rand ( 1 , array ) ;
93156: LD_ADDR_VAR 0 4
93160: PUSH
93161: LD_INT 1
93163: PPUSH
93164: LD_VAR 0 1
93168: PPUSH
93169: CALL_OW 12
93173: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93174: LD_ADDR_VAR 0 2
93178: PUSH
93179: LD_VAR 0 2
93183: PPUSH
93184: LD_VAR 0 2
93188: PUSH
93189: LD_INT 1
93191: PLUS
93192: PPUSH
93193: LD_VAR 0 1
93197: PUSH
93198: LD_VAR 0 4
93202: ARRAY
93203: PPUSH
93204: CALL_OW 2
93208: ST_TO_ADDR
// array := Delete ( array , index ) ;
93209: LD_ADDR_VAR 0 1
93213: PUSH
93214: LD_VAR 0 1
93218: PPUSH
93219: LD_VAR 0 4
93223: PPUSH
93224: CALL_OW 3
93228: ST_TO_ADDR
// end ;
93229: GO 93153
93231: POP
93232: POP
// end ;
93233: LD_VAR 0 2
93237: RET
// export function GetBaseMaterials ( base ) ; begin
93238: LD_INT 0
93240: PPUSH
// result := [ 0 , 0 , 0 ] ;
93241: LD_ADDR_VAR 0 2
93245: PUSH
93246: LD_INT 0
93248: PUSH
93249: LD_INT 0
93251: PUSH
93252: LD_INT 0
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: LIST
93259: ST_TO_ADDR
// if not base then
93260: LD_VAR 0 1
93264: NOT
93265: IFFALSE 93269
// exit ;
93267: GO 93318
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
93269: LD_ADDR_VAR 0 2
93273: PUSH
93274: LD_VAR 0 1
93278: PPUSH
93279: LD_INT 1
93281: PPUSH
93282: CALL_OW 275
93286: PUSH
93287: LD_VAR 0 1
93291: PPUSH
93292: LD_INT 2
93294: PPUSH
93295: CALL_OW 275
93299: PUSH
93300: LD_VAR 0 1
93304: PPUSH
93305: LD_INT 3
93307: PPUSH
93308: CALL_OW 275
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: LIST
93317: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
93318: LD_VAR 0 2
93322: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
93323: LD_INT 0
93325: PPUSH
93326: PPUSH
93327: PPUSH
93328: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93329: LD_VAR 0 1
93333: PPUSH
93334: CALL_OW 264
93338: PUSH
93339: LD_EXP 71
93343: EQUAL
93344: IFFALSE 93416
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93346: LD_INT 68
93348: PPUSH
93349: LD_VAR 0 1
93353: PPUSH
93354: CALL_OW 255
93358: PPUSH
93359: CALL_OW 321
93363: PUSH
93364: LD_INT 2
93366: EQUAL
93367: IFFALSE 93379
// eff := 70 else
93369: LD_ADDR_VAR 0 6
93373: PUSH
93374: LD_INT 70
93376: ST_TO_ADDR
93377: GO 93387
// eff := 30 ;
93379: LD_ADDR_VAR 0 6
93383: PUSH
93384: LD_INT 30
93386: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93387: LD_VAR 0 1
93391: PPUSH
93392: CALL_OW 250
93396: PPUSH
93397: LD_VAR 0 1
93401: PPUSH
93402: CALL_OW 251
93406: PPUSH
93407: LD_VAR 0 6
93411: PPUSH
93412: CALL_OW 495
// end ; end ;
93416: LD_VAR 0 4
93420: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
93421: LD_INT 0
93423: PPUSH
93424: PPUSH
93425: PPUSH
93426: PPUSH
93427: PPUSH
93428: PPUSH
// if cmd = 124 then
93429: LD_VAR 0 1
93433: PUSH
93434: LD_INT 124
93436: EQUAL
93437: IFFALSE 93643
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
93439: LD_ADDR_VAR 0 5
93443: PUSH
93444: LD_INT 2
93446: PUSH
93447: LD_INT 34
93449: PUSH
93450: LD_INT 53
93452: PUSH
93453: EMPTY
93454: LIST
93455: LIST
93456: PUSH
93457: LD_INT 34
93459: PUSH
93460: LD_INT 14
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: EMPTY
93468: LIST
93469: LIST
93470: LIST
93471: PPUSH
93472: CALL_OW 69
93476: ST_TO_ADDR
// if not tmp then
93477: LD_VAR 0 5
93481: NOT
93482: IFFALSE 93486
// exit ;
93484: GO 93643
// for i in tmp do
93486: LD_ADDR_VAR 0 3
93490: PUSH
93491: LD_VAR 0 5
93495: PUSH
93496: FOR_IN
93497: IFFALSE 93641
// begin taskList := GetTaskList ( i ) ;
93499: LD_ADDR_VAR 0 6
93503: PUSH
93504: LD_VAR 0 3
93508: PPUSH
93509: CALL_OW 437
93513: ST_TO_ADDR
// if not taskList then
93514: LD_VAR 0 6
93518: NOT
93519: IFFALSE 93523
// continue ;
93521: GO 93496
// for j = 1 to taskList do
93523: LD_ADDR_VAR 0 4
93527: PUSH
93528: DOUBLE
93529: LD_INT 1
93531: DEC
93532: ST_TO_ADDR
93533: LD_VAR 0 6
93537: PUSH
93538: FOR_TO
93539: IFFALSE 93637
// if taskList [ j ] [ 1 ] = | then
93541: LD_VAR 0 6
93545: PUSH
93546: LD_VAR 0 4
93550: ARRAY
93551: PUSH
93552: LD_INT 1
93554: ARRAY
93555: PUSH
93556: LD_STRING |
93558: EQUAL
93559: IFFALSE 93635
// begin _taskList := Delete ( taskList , 1 ) ;
93561: LD_ADDR_VAR 0 7
93565: PUSH
93566: LD_VAR 0 6
93570: PPUSH
93571: LD_INT 1
93573: PPUSH
93574: CALL_OW 3
93578: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
93579: LD_VAR 0 3
93583: PPUSH
93584: LD_VAR 0 7
93588: PPUSH
93589: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
93593: LD_VAR 0 3
93597: PPUSH
93598: LD_VAR 0 6
93602: PUSH
93603: LD_VAR 0 4
93607: ARRAY
93608: PUSH
93609: LD_INT 2
93611: ARRAY
93612: PPUSH
93613: LD_VAR 0 6
93617: PUSH
93618: LD_VAR 0 4
93622: ARRAY
93623: PUSH
93624: LD_INT 3
93626: ARRAY
93627: PPUSH
93628: LD_INT 8
93630: PPUSH
93631: CALL 93648 0 4
// end ;
93635: GO 93538
93637: POP
93638: POP
// end ;
93639: GO 93496
93641: POP
93642: POP
// end ; end ;
93643: LD_VAR 0 2
93647: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93648: LD_INT 0
93650: PPUSH
93651: PPUSH
93652: PPUSH
93653: PPUSH
93654: PPUSH
93655: PPUSH
93656: PPUSH
93657: PPUSH
93658: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93659: LD_VAR 0 1
93663: NOT
93664: PUSH
93665: LD_VAR 0 2
93669: PPUSH
93670: LD_VAR 0 3
93674: PPUSH
93675: CALL_OW 488
93679: NOT
93680: OR
93681: PUSH
93682: LD_VAR 0 4
93686: NOT
93687: OR
93688: IFFALSE 93692
// exit ;
93690: GO 94032
// list := [ ] ;
93692: LD_ADDR_VAR 0 13
93696: PUSH
93697: EMPTY
93698: ST_TO_ADDR
// if x - r < 0 then
93699: LD_VAR 0 2
93703: PUSH
93704: LD_VAR 0 4
93708: MINUS
93709: PUSH
93710: LD_INT 0
93712: LESS
93713: IFFALSE 93725
// min_x := 0 else
93715: LD_ADDR_VAR 0 7
93719: PUSH
93720: LD_INT 0
93722: ST_TO_ADDR
93723: GO 93741
// min_x := x - r ;
93725: LD_ADDR_VAR 0 7
93729: PUSH
93730: LD_VAR 0 2
93734: PUSH
93735: LD_VAR 0 4
93739: MINUS
93740: ST_TO_ADDR
// if y - r < 0 then
93741: LD_VAR 0 3
93745: PUSH
93746: LD_VAR 0 4
93750: MINUS
93751: PUSH
93752: LD_INT 0
93754: LESS
93755: IFFALSE 93767
// min_y := 0 else
93757: LD_ADDR_VAR 0 8
93761: PUSH
93762: LD_INT 0
93764: ST_TO_ADDR
93765: GO 93783
// min_y := y - r ;
93767: LD_ADDR_VAR 0 8
93771: PUSH
93772: LD_VAR 0 3
93776: PUSH
93777: LD_VAR 0 4
93781: MINUS
93782: ST_TO_ADDR
// max_x := x + r ;
93783: LD_ADDR_VAR 0 9
93787: PUSH
93788: LD_VAR 0 2
93792: PUSH
93793: LD_VAR 0 4
93797: PLUS
93798: ST_TO_ADDR
// max_y := y + r ;
93799: LD_ADDR_VAR 0 10
93803: PUSH
93804: LD_VAR 0 3
93808: PUSH
93809: LD_VAR 0 4
93813: PLUS
93814: ST_TO_ADDR
// for _x = min_x to max_x do
93815: LD_ADDR_VAR 0 11
93819: PUSH
93820: DOUBLE
93821: LD_VAR 0 7
93825: DEC
93826: ST_TO_ADDR
93827: LD_VAR 0 9
93831: PUSH
93832: FOR_TO
93833: IFFALSE 93950
// for _y = min_y to max_y do
93835: LD_ADDR_VAR 0 12
93839: PUSH
93840: DOUBLE
93841: LD_VAR 0 8
93845: DEC
93846: ST_TO_ADDR
93847: LD_VAR 0 10
93851: PUSH
93852: FOR_TO
93853: IFFALSE 93946
// begin if not ValidHex ( _x , _y ) then
93855: LD_VAR 0 11
93859: PPUSH
93860: LD_VAR 0 12
93864: PPUSH
93865: CALL_OW 488
93869: NOT
93870: IFFALSE 93874
// continue ;
93872: GO 93852
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
93874: LD_VAR 0 11
93878: PPUSH
93879: LD_VAR 0 12
93883: PPUSH
93884: CALL_OW 351
93888: PUSH
93889: LD_VAR 0 11
93893: PPUSH
93894: LD_VAR 0 12
93898: PPUSH
93899: CALL_OW 554
93903: AND
93904: IFFALSE 93944
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
93906: LD_ADDR_VAR 0 13
93910: PUSH
93911: LD_VAR 0 13
93915: PPUSH
93916: LD_VAR 0 13
93920: PUSH
93921: LD_INT 1
93923: PLUS
93924: PPUSH
93925: LD_VAR 0 11
93929: PUSH
93930: LD_VAR 0 12
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: PPUSH
93939: CALL_OW 2
93943: ST_TO_ADDR
// end ;
93944: GO 93852
93946: POP
93947: POP
93948: GO 93832
93950: POP
93951: POP
// if not list then
93952: LD_VAR 0 13
93956: NOT
93957: IFFALSE 93961
// exit ;
93959: GO 94032
// for i in list do
93961: LD_ADDR_VAR 0 6
93965: PUSH
93966: LD_VAR 0 13
93970: PUSH
93971: FOR_IN
93972: IFFALSE 94030
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
93974: LD_VAR 0 1
93978: PPUSH
93979: LD_STRING M
93981: PUSH
93982: LD_VAR 0 6
93986: PUSH
93987: LD_INT 1
93989: ARRAY
93990: PUSH
93991: LD_VAR 0 6
93995: PUSH
93996: LD_INT 2
93998: ARRAY
93999: PUSH
94000: LD_INT 0
94002: PUSH
94003: LD_INT 0
94005: PUSH
94006: LD_INT 0
94008: PUSH
94009: LD_INT 0
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: PUSH
94021: EMPTY
94022: LIST
94023: PPUSH
94024: CALL_OW 447
94028: GO 93971
94030: POP
94031: POP
// end ;
94032: LD_VAR 0 5
94036: RET
